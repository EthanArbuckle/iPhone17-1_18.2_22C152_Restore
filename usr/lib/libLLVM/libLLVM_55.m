uint64_t llvm::VPReductionRecipe::execute(llvm::VPReductionRecipe *this, llvm **a2)
{
  llvm::Instruction *v4;
  uint64_t v5;
  llvm::Type *v6;
  uint64_t result;
  uint64_t v8;
  llvm *v9;
  uint64_t v10;
  unsigned int i;
  llvm::Instruction *Select;
  llvm::VPValue *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned __int8 *RecurrenceIdentity;
  uint64_t v18;
  uint64_t v19;
  int v20;
  llvm::Instruction *VectorSplat;
  llvm::IRBuilderBase *v22;
  llvm::PHINode *v23;
  llvm::Instruction *TargetReduction;
  BOOL v25;
  uint64_t v26;
  uint64_t Opcode;
  uint64_t v29;
  llvm::Value *MinMaxOp;
  uint64_t v31;
  uint64_t v32;
  llvm::Instruction *v33;
  char v34;
  char v35;
  char v36;
  uint64_t v37;
  unsigned char v38[32];
  __int16 v39;

  v4 = llvm::VPTransformState::get((llvm::VPTransformState *)a2, **((llvm::VPValue ***)this + 6), 0);
  v5 = *((void *)this + 19);
  v6 = (llvm::Type *)*(unsigned int *)(v5 + 32);
  result = llvm::LoopVectorizeHints::allowReordering(*(llvm::LoopVectorizeHints **)(*((void *)a2[39] + 50) + 664));
  if (*(unsigned char *)(v5 + 57)) {
    v8 = result;
  }
  else {
    v8 = 1;
  }
  v9 = a2[34];
  v10 = *((unsigned int *)v9 + 24);
  v37 = *((void *)v9 + 11);
  v35 = *((unsigned char *)v9 + 101);
  v36 = *((unsigned char *)v9 + 100);
  v34 = *((unsigned char *)v9 + 102);
  *((_DWORD *)v9 + 24) = *(_DWORD *)(*((void *)this + 19) + 36);
  if (*((_DWORD *)a2 + 2))
  {
    for (i = 0; i < *((_DWORD *)a2 + 2); ++i)
    {
      Select = llvm::VPTransformState::get((llvm::VPTransformState *)a2, *(llvm::VPValue **)(*((void *)this + 6) + 8), i);
      if (*((_DWORD *)this + 14) >= 3u)
      {
        v13 = *(llvm::VPValue **)(*((void *)this + 6) + 16);
        if (v13)
        {
          v33 = llvm::VPTransformState::get((llvm::VPTransformState *)a2, v13, i);
          v14 = v8;
          v15 = v10;
          v16 = *(void *)Select;
          RecurrenceIdentity = (unsigned __int8 *)llvm::RecurrenceDescriptor::getRecurrenceIdentity(*((void **)this + 19), v6, *(llvm::ConstantFP **)(*(void *)Select + 24), *(_DWORD *)(*((void *)this + 19) + 36));
          v18 = (uint64_t)a2[34];
          v19 = *(unsigned int *)(v16 + 32);
          v20 = *(unsigned __int8 *)(v16 + 8);
          v10 = v15;
          v8 = v14;
          v39 = 257;
          VectorSplat = llvm::IRBuilderBase::CreateVectorSplat(v18, (llvm::Type *)(v19 | ((unint64_t)(v20 == 19) << 32)), RecurrenceIdentity, (uint64_t)v38);
          v22 = a2[34];
          v39 = 257;
          Select = llvm::IRBuilderBase::CreateSelect(v22, v33, Select, VectorSplat, (const llvm::Twine *)v38, 0);
        }
      }
      if (v8)
      {
        v4 = llvm::VPTransformState::get((llvm::VPTransformState *)a2, **((llvm::VPValue ***)this + 6), i);
        TargetReduction = (llvm::Instruction *)llvm::createTargetReduction(a2[34], *((llvm::IRBuilderBase **)this + 20), *((const llvm::TargetTransformInfo **)this + 19), Select, 0, v23);
      }
      else
      {
        if (*(_DWORD *)a2) {
          v25 = *((_DWORD *)a2 + 1) == 1;
        }
        else {
          v25 = 0;
        }
        v26 = (uint64_t)a2[34];
        if (v25 || *(_DWORD *)a2 >= 2u)
        {
          TargetReduction = (llvm::Instruction *)llvm::IRBuilderBase::CreateFAddReduce(a2[34], v4, Select);
        }
        else
        {
          Opcode = llvm::RecurrenceDescriptor::getOpcode((int)v6);
          v39 = 257;
          TargetReduction = sub_1CB844E98(v26, Opcode, (uint64_t)v4, (uint64_t)Select, (uint64_t)v38, 0);
        }
        v4 = TargetReduction;
      }
      v29 = (uint64_t)TargetReduction;
      if (v6 <= 0xD && ((1 << (char)v6) & 0x33C0) != 0)
      {
        MinMaxOp = llvm::createMinMaxOp(a2[34], *(_DWORD *)(*((void *)this + 19) + 32), TargetReduction, v4);
      }
      else
      {
        if (!v8) {
          goto LABEL_25;
        }
        v31 = (uint64_t)a2[34];
        v32 = llvm::RecurrenceDescriptor::getOpcode((int)v6);
        v39 = 257;
        MinMaxOp = sub_1CB844E98(v31, v32, v29, (uint64_t)v4, (uint64_t)v38, 0);
      }
      v29 = (uint64_t)MinMaxOp;
LABEL_25:
      result = (uint64_t)sub_1CD8C9514((uint64_t)a2, (char *)this + 96, v29, i);
    }
  }
  *((_DWORD *)v9 + 24) = v10;
  *((void *)v9 + 11) = v37;
  *((unsigned char *)v9 + 100) = v36;
  *((unsigned char *)v9 + 101) = v35;
  *((unsigned char *)v9 + 102) = v34;
  return result;
}

uint64_t llvm::VPPredInstPHIRecipe::execute(llvm::VPPredInstPHIRecipe *this, llvm::VPTransformState *a2)
{
  v4 = llvm::VPTransformState::get((uint64_t)a2, **((void **)this + 6), (unsigned int *)a2 + 3);
  v5 = (llvm::BasicBlock *)*((void *)v4 + 5);
  uint64_t SinglePredecessor = llvm::BasicBlock::getSinglePredecessor(v5);
  uint64_t v7 = *((unsigned int *)a2 + 3);
  v86 = (char *)**((void **)this + 6);
  v84[0] = 0;
  if (sub_1CD7D38CC((uint64_t *)a2 + 4, &v86, v84)
    && v84[0] != *((void *)a2 + 4) + 40 * *((unsigned int *)a2 + 12)
    && *(_DWORD *)(v84[0] + 16) > v7
    && *(void *)(*(void *)(v84[0] + 8) + 8 * v7))
  {
    v46 = (uint64_t *)llvm::VPTransformState::get(a2, **((llvm::VPValue ***)this + 6), v7);
    uint64_t v47 = *((void *)a2 + 34);
    uint64_t v48 = *v46;
    __int16 v85 = 257;
    v49 = sub_1CB93113C(v47, v48, 2, (uint64_t)v84);
    v10 = v49;
    uint64_t v50 = *(v46 - 12);
    int v51 = *((_DWORD *)v49 + 5);
    if ((v51 & 0x7FFFFFF) == *((_DWORD *)v49 + 15))
    {
      llvm::PHINode::growOperands(v49);
      int v51 = *((_DWORD *)v10 + 5);
    }
    uint64_t v52 = (v51 + 1) & 0x7FFFFFF;
    *((_DWORD *)v10 + 5) = v51 & 0xF8000000 | (v51 + 1) & 0x7FFFFFF;
    uint64_t v53 = (v52 - 1);
    if ((v51 & 0x40000000) != 0) {
      v54 = (char *)*((void *)v10 - 1);
    }
    else {
      v54 = (char *)v10 - 32 * v52;
    }
    v55 = &v54[32 * v53];
    if (*(void *)v55)
    {
      **((void **)v55 + 2) = *((void *)v55 + 1);
      uint64_t v82 = *((void *)v55 + 1);
      if (v82) {
        *(void *)(v82 + 16) = *((void *)v55 + 2);
      }
    }
    *(void *)v55 = v50;
    if (v50)
    {
      uint64_t v58 = *(void *)(v50 + 8);
      v57 = (char **)(v50 + 8);
      uint64_t v56 = v58;
      v59 = &v54[32 * v53];
      *((void *)v59 + 1) = v58;
      if (v58) {
        *(void *)(v56 + 16) = v59 + 8;
      }
      *((void *)v59 + 2) = v57;
      *v57 = v55;
    }
    int v60 = *((_DWORD *)v10 + 5);
    uint64_t v61 = v60 & 0x7FFFFFF;
    if ((v60 & 0x40000000) != 0) {
      v62 = (char *)*((void *)v10 - 1);
    }
    else {
      v62 = (char *)v10 - 32 * v61;
    }
    uint64_t v63 = *((unsigned int *)v10 + 15);
    *(void *)&v62[32 * v63 + 8 * (v61 - 1)] = SinglePredecessor;
    int v64 = *((_DWORD *)v10 + 5);
    if ((v64 & 0x7FFFFFF) == v63)
    {
      llvm::PHINode::growOperands(v10);
      int v64 = *((_DWORD *)v10 + 5);
    }
    uint64_t v65 = (v64 + 1) & 0x7FFFFFF;
    *((_DWORD *)v10 + 5) = v64 & 0xF8000000 | (v64 + 1) & 0x7FFFFFF;
    uint64_t v66 = (v65 - 1);
    if ((v64 & 0x40000000) != 0) {
      v67 = (char *)*((void *)v10 - 1);
    }
    else {
      v67 = (char *)v10 - 32 * v65;
    }
    v68 = &v67[32 * v66];
    v69 = v68;
    if (*(void *)v68)
    {
      **((void **)v68 + 2) = *((void *)v68 + 1);
      uint64_t v83 = *((void *)v68 + 1);
      if (v83) {
        *(void *)(v83 + 16) = *((void *)v68 + 2);
      }
    }
    *(void *)v68 = v46;
    uint64_t v72 = v46[1];
    v71 = (char **)(v46 + 1);
    uint64_t v70 = v72;
    *((void *)v68 + 1) = v72;
    v73 = v68 + 8;
    if (v72) {
      *(void *)(v70 + 16) = v73;
    }
    *(void *)&v67[32 * v66 + 16] = v71;
    *v71 = v69;
    int v74 = *((_DWORD *)v10 + 5);
    uint64_t v75 = v74 & 0x7FFFFFF;
    if ((v74 & 0x40000000) != 0) {
      v76 = (char *)*((void *)v10 - 1);
    }
    else {
      v76 = (char *)v10 - 32 * v75;
    }
    *(void *)&v76[32 * *((unsigned int *)v10 + 15) + 8 * (v75 - 1)] = v5;
    v86 = (char *)this + 96;
    v84[0] = 0;
    if (sub_1CD7D38CC((uint64_t *)a2 + 4, &v86, v84)
      && v84[0] != *((void *)a2 + 4) + 40 * *((unsigned int *)a2 + 12)
      && *(_DWORD *)(v84[0] + 16) > v7
      && *(void *)(*(void *)(v84[0] + 8) + 8 * v7))
    {
      v86 = (char *)this + 96;
      v84[0] = 0;
      int v80 = sub_1CD7D38CC((uint64_t *)a2 + 4, &v86, v84);
      uint64_t v81 = v84[0];
      if (!v80) {
        uint64_t v81 = *((void *)a2 + 4) + 40 * *((unsigned int *)a2 + 12);
      }
      *(void *)(*(void *)(v81 + 8) + 8 * v7) = v10;
    }
    else
    {
      sub_1CD8C9514((uint64_t)a2, (char *)this + 96, (uint64_t)v10, v7);
    }
    v86 = (char *)**((void **)this + 6);
    v84[0] = 0;
    uint64_t result = sub_1CD7D38CC((uint64_t *)a2 + 4, &v86, v84);
    uint64_t v77 = v84[0];
    if (!result) {
      uint64_t v77 = *((void *)a2 + 4) + 40 * *((unsigned int *)a2 + 12);
    }
    v45 = (void *)(v77 + 8);
  }
  else
  {
    uint64_t v8 = **(void **)(**((void **)this + 6) + 40);
    uint64_t v9 = *((void *)a2 + 34);
    __int16 v85 = 257;
    v10 = sub_1CB93113C(v9, v8, 2, (uint64_t)v84);
    v12 = llvm::PoisonValue::get(*(llvm::PoisonValue **)v4, v11);
    int v13 = *((_DWORD *)v10 + 5);
    if ((v13 & 0x7FFFFFF) == *((_DWORD *)v10 + 15))
    {
      llvm::PHINode::growOperands(v10);
      int v13 = *((_DWORD *)v10 + 5);
    }
    uint64_t v14 = (v13 + 1) & 0x7FFFFFF;
    *((_DWORD *)v10 + 5) = v13 & 0xF8000000 | (v13 + 1) & 0x7FFFFFF;
    uint64_t v15 = (v14 - 1);
    if ((v13 & 0x40000000) != 0) {
      v16 = (char *)*((void *)v10 - 1);
    }
    else {
      v16 = (char *)v10 - 32 * v14;
    }
    v17 = &v16[32 * v15];
    if (*(void *)v17)
    {
      **((void **)v17 + 2) = *((void *)v17 + 1);
      uint64_t v78 = *((void *)v17 + 1);
      if (v78) {
        *(void *)(v78 + 16) = *((void *)v17 + 2);
      }
    }
    *(void *)v17 = v12;
    if (v12)
    {
      uint64_t v20 = v12[1];
      v19 = (char **)(v12 + 1);
      uint64_t v18 = v20;
      v21 = &v16[32 * v15];
      *((void *)v21 + 1) = v20;
      if (v20) {
        *(void *)(v18 + 16) = v21 + 8;
      }
      *((void *)v21 + 2) = v19;
      *v19 = v17;
    }
    int v22 = *((_DWORD *)v10 + 5);
    uint64_t v23 = v22 & 0x7FFFFFF;
    if ((v22 & 0x40000000) != 0) {
      v24 = (char *)*((void *)v10 - 1);
    }
    else {
      v24 = (char *)v10 - 32 * v23;
    }
    uint64_t v25 = *((unsigned int *)v10 + 15);
    *(void *)&v24[32 * v25 + 8 * (v23 - 1)] = SinglePredecessor;
    int v26 = *((_DWORD *)v10 + 5);
    if ((v26 & 0x7FFFFFF) == v25)
    {
      llvm::PHINode::growOperands(v10);
      int v26 = *((_DWORD *)v10 + 5);
    }
    uint64_t v27 = (v26 + 1) & 0x7FFFFFF;
    *((_DWORD *)v10 + 5) = v26 & 0xF8000000 | (v26 + 1) & 0x7FFFFFF;
    uint64_t v28 = (v27 - 1);
    if ((v26 & 0x40000000) != 0) {
      v29 = (char *)*((void *)v10 - 1);
    }
    else {
      v29 = (char *)v10 - 32 * v27;
    }
    v30 = &v29[32 * v28];
    v31 = v30;
    if (*(void *)v30)
    {
      **((void **)v30 + 2) = *((void *)v30 + 1);
      uint64_t v79 = *((void *)v30 + 1);
      if (v79) {
        *(void *)(v79 + 16) = *((void *)v30 + 2);
      }
    }
    *(void *)v30 = v4;
    uint64_t v34 = *((void *)v4 + 1);
    v33 = (char **)((char *)v4 + 8);
    uint64_t v32 = v34;
    *((void *)v30 + 1) = v34;
    v35 = v30 + 8;
    if (v34) {
      *(void *)(v32 + 16) = v35;
    }
    *(void *)&v29[32 * v28 + 16] = v33;
    *v33 = v31;
    int v36 = *((_DWORD *)v10 + 5);
    uint64_t v37 = v36 & 0x7FFFFFF;
    if ((v36 & 0x40000000) != 0) {
      v38 = (char *)*((void *)v10 - 1);
    }
    else {
      v38 = (char *)v10 - 32 * v37;
    }
    *(void *)&v38[32 * *((unsigned int *)v10 + 15) + 8 * (v37 - 1)] = v5;
    if (sub_1CD319158((uint64_t)a2, (uint64_t)this + 96, *(void *)((char *)a2 + 12), *((_DWORD *)a2 + 5)))
    {
      v86 = (char *)this + 96;
      v84[0] = 0;
      int v39 = sub_1CD8D5D54((uint64_t *)a2 + 7, &v86, v84);
      uint64_t v40 = v84[0];
      if (!v39) {
        uint64_t v40 = *((void *)a2 + 7) + 120 * *((unsigned int *)a2 + 18);
      }
      if (*((unsigned char *)a2 + 20) == 1) {
        unsigned int v41 = *(_DWORD *)a2;
      }
      else {
        unsigned int v41 = 0;
      }
      *(void *)(*(void *)(*(void *)(v40 + 8) + 48 * *((unsigned int *)a2 + 3))
                + 8 * (*((_DWORD *)a2 + 4) + v41)) = v10;
    }
    else
    {
      sub_1CD8C9704(a2, (uint64_t)this + 96, (uint64_t)v10, (uint64_t)a2 + 12);
    }
    v86 = (char *)**((void **)this + 6);
    v84[0] = 0;
    uint64_t result = sub_1CD8D5D54((uint64_t *)a2 + 7, &v86, v84);
    uint64_t v43 = v84[0];
    if (!result) {
      uint64_t v43 = *((void *)a2 + 7) + 120 * *((unsigned int *)a2 + 18);
    }
    if (*((unsigned char *)a2 + 20) == 1) {
      unsigned int v44 = *(_DWORD *)a2;
    }
    else {
      unsigned int v44 = 0;
    }
    uint64_t v7 = *((_DWORD *)a2 + 4) + v44;
    v45 = (void *)(*(void *)(v43 + 8) + 48 * *((unsigned int *)a2 + 3));
  }
  *(void *)(*v45 + 8 * v7) = v10;
  return result;
}

BOOL sub_1CD319158(uint64_t a1, uint64_t a2, unint64_t a3, char a4)
{
  uint64_t v11 = a2;
  uint64_t v12 = 0;
  int v7 = sub_1CD8D5D54((uint64_t *)(a1 + 56), &v11, &v12);
  BOOL result = 0;
  if (v7 && v12 != *(void *)(a1 + 56) + 120 * *(unsigned int *)(a1 + 72))
  {
    unint64_t v9 = HIDWORD(a3);
    if (a4 == 1) {
      LODWORD(v9) = *(_DWORD *)a1 + HIDWORD(a3);
    }
    if (a3 >= (unint64_t)*(unsigned int *)(v12 + 16)) {
      return 0;
    }
    uint64_t v10 = *(void *)(v12 + 8) + 48 * a3;
    return *(_DWORD *)(v10 + 8) > v9 && *(void *)(*(void *)v10 + 8 * v9) != 0;
  }
  return result;
}

void llvm::VPWidenMemoryInstructionRecipe::execute(llvm::VPWidenMemoryInstructionRecipe *this, llvm::VPTransformState *a2)
{
  v65[2] = *MEMORY[0x1E4F143B8];
  v4 = (unsigned __int8 *)*((void *)this + 19);
  int v5 = v4[16];
  if (v5 == 61)
  {
    v6 = *(llvm::VPValue **)(*((void *)this + 6) + 8);
    int v7 = (llvm::Instruction *)*((void *)this + 19);
  }
  else
  {
    v6 = 0;
    int v7 = 0;
    if (v5 == 60)
    {
      int v7 = 0;
      uint64_t v8 = (uint64_t ***)*((void *)this + 19);
      goto LABEL_6;
    }
  }
  uint64_t v8 = (uint64_t ***)*((void *)v4 - 8);
  v4 = 0;
LABEL_6:
  unint64_t v9 = *v8;
  uint64_t v56 = *v8;
  uint64_t v10 = *(llvm::Type **)a2;
  if (HIDWORD(*(void *)a2) == 1) {
    llvm::ScalableVectorType::get(v9, v10);
  }
  else {
    llvm::FixedVectorType::get((llvm::FixedVectorType *)v9, v10);
  }
  v55 = v11;
  uint64_t v12 = *((void *)this + 19);
  int v13 = *(unsigned __int8 *)(v12 + 16);
  int v14 = __clz(1 << ((unint64_t)*(unsigned __int16 *)(v12 + 18) >> 1));
  int v52 = *((unsigned __int8 *)this + 160);
  uint64_t v15 = *((void *)a2 + 34);
  uint64_t v16 = *((unsigned int *)a2 + 2);
  v62 = v65;
  int v64 = 2;
  if (v16 >= 3)
  {
    int v63 = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (v16) {
    bzero(v65, 8 * v16);
  }
  int v63 = v16;
  int v17 = *((_DWORD *)this + 14);
  if (v13 != 61)
  {
    if (v17 == 2)
    {
      uint64_t v18 = 1;
      goto LABEL_16;
    }
LABEL_28:
    BOOL v54 = 0;
    goto LABEL_29;
  }
  if (v17 != 3) {
    goto LABEL_28;
  }
  uint64_t v18 = 2;
LABEL_16:
  uint64_t v19 = *(void *)(*((void *)this + 6) + 8 * v18);
  BOOL v54 = v19 != 0;
  if (v19 && *((_DWORD *)a2 + 2))
  {
    for (unint64_t i = 0; i < *((unsigned int *)a2 + 2); ++i)
    {
      int v21 = *((_DWORD *)this + 14);
      if (*(unsigned char *)(*((void *)this + 19) + 16) == 61)
      {
        if (v21 != 3) {
          goto LABEL_25;
        }
        uint64_t v22 = 2;
      }
      else
      {
        if (v21 != 2)
        {
LABEL_25:
          uint64_t v23 = 0;
          goto LABEL_26;
        }
        uint64_t v22 = 1;
      }
      uint64_t v23 = *(llvm::VPValue **)(*((void *)this + 6) + 8 * v22);
LABEL_26:
      v62[i] = llvm::VPTransformState::get(a2, v23, i);
    }
  }
LABEL_29:
  uint64_t v24 = v14 ^ 0x3Fu;
  v53[0] = (uint64_t)this;
  v53[1] = v15;
  v53[2] = (uint64_t)a2;
  v53[3] = (uint64_t)&v56;
  v53[4] = (uint64_t)&v54;
  v53[5] = (uint64_t)&v62;
  v53[6] = (uint64_t)&v55;
  uint64_t v25 = (unsigned __int8 *)*((void *)a2 + 39);
  if (v7)
  {
    llvm::InnerLoopVectorizer::setDebugLocFromInst(v25, (uint64_t)v7, 0, 0);
    if (*((_DWORD *)a2 + 2))
    {
      unint64_t v26 = 0;
      do
      {
        VectorReverse = (void **)llvm::VPTransformState::get(a2, v6, v26);
        if (v52)
        {
          if (*((unsigned char *)this + 161))
          {
            v59 = "reverse";
            __int16 v61 = 259;
            VectorReverse = (void **)llvm::IRBuilderBase::CreateVectorReverse((llvm::IRBuilderBase *)v15, VectorReverse, (const llvm::Twine *)&v59);
          }
          uint64_t v29 = **((void **)this + 6);
          char v60 = 0;
          v59 = 0;
          v30 = llvm::VPTransformState::get((uint64_t)a2, v29, (unsigned int *)&v59);
          v31 = (uint64_t *)sub_1CD319848(v53, v26, v30);
          if (v54)
          {
            MaskedStore = (llvm::Instruction *)llvm::IRBuilderBase::CreateMaskedStore(v15, VectorReverse, v31, v24, v62[v26]);
          }
          else
          {
            unint64_t v51 = v51 & 0xFFFFFFFFFFFF0000 | v24 | 0x100;
            MaskedStore = sub_1CC27BF8C((uint64_t *)v15, (uint64_t)VectorReverse, (uint64_t)v31, (unsigned __int16)v24 | 0x100u, 0);
          }
        }
        else
        {
          if (v54) {
            uint64_t v28 = (void *)v62[v26];
          }
          else {
            uint64_t v28 = 0;
          }
          v33 = (uint64_t *)llvm::VPTransformState::get(a2, **((llvm::VPValue ***)this + 6), v26);
          MaskedStore = (llvm::Instruction *)llvm::IRBuilderBase::CreateMaskedScatter(v15, (uint64_t *)VectorReverse, v33, v24, v28);
        }
        llvm::InnerLoopVectorizer::addMetadata(*((llvm::InnerLoopVectorizer **)a2 + 39), MaskedStore, v7);
        ++v26;
      }
      while (v26 < *((unsigned int *)a2 + 2));
    }
  }
  else
  {
    llvm::InnerLoopVectorizer::setDebugLocFromInst(v25, (uint64_t)v4, 0, 0);
    if (*((_DWORD *)a2 + 2))
    {
      unint64_t v34 = 0;
      v35 = (char *)this + 96;
      do
      {
        if (v52)
        {
          uint64_t v37 = **((void **)this + 6);
          char v60 = 0;
          v59 = 0;
          v38 = llvm::VPTransformState::get((uint64_t)a2, v37, (unsigned int *)&v59);
          uint64_t v40 = (uint64_t *)sub_1CD319848(v53, v34, v38);
          unsigned int v41 = v55;
          if (v54)
          {
            uint64_t v49 = v62[v34];
            uint64_t v50 = (llvm::UndefValue *)llvm::PoisonValue::get(v55, v39);
            v59 = "wide.masked.load";
            __int16 v61 = 259;
            MaskedLoad = (unsigned __int8 *)llvm::IRBuilderBase::CreateMaskedLoad(v15, v41, v40, v24, v49, v50, (uint64_t)&v59);
          }
          else
          {
            v57 = "wide.load";
            __int16 v58 = 259;
            v42 = (char *)operator new(0x60uLL);
            *((_DWORD *)v42 + 13) = *((_DWORD *)v42 + 13) & 0x38000000 | 1;
            MaskedLoad = (unsigned __int8 *)(v42 + 32);
            *(void *)v42 = 0;
            *((void *)v42 + 1) = 0;
            *((void *)v42 + 2) = 0;
            *((void *)v42 + 3) = v42 + 32;
            __int16 v61 = 257;
            llvm::LoadInst::LoadInst((llvm::Value *)(v42 + 32), (uint64_t)v41, (uint64_t)v40, &v59, 0, v24, 0);
            (*(void (**)(void, unsigned __int8 *, const char **, void, void))(**(void **)(v15 + 80)
                                                                                             + 16))(*(void *)(v15 + 80), MaskedLoad, &v57, *(void *)(v15 + 48), *(void *)(v15 + 56));
            uint64_t v44 = *(unsigned int *)(v15 + 8);
            if (v44)
            {
              uint64_t v45 = *(void *)v15;
              uint64_t v46 = *(void *)v15 + 16 * v44;
              do
              {
                llvm::Instruction::setMetadata((llvm::Instruction *)MaskedLoad, *(_DWORD *)v45, *(llvm::MDNode **)(v45 + 8));
                v45 += 16;
              }
              while (v45 != v46);
            }
          }
          v35 = (char *)this + 96;
          if (MaskedLoad && MaskedLoad[16] >= 0x1Cu) {
            llvm::InnerLoopVectorizer::addMetadata(*((llvm::InnerLoopVectorizer **)a2 + 39), (llvm::Instruction *)MaskedLoad, (llvm::Instruction *)v4);
          }
          if (*((unsigned char *)this + 161))
          {
            v59 = "reverse";
            __int16 v61 = 259;
            MaskedLoad = (unsigned __int8 *)llvm::IRBuilderBase::CreateVectorReverse((llvm::IRBuilderBase *)v15, (void **)MaskedLoad, (const llvm::Twine *)&v59);
          }
        }
        else
        {
          if (v54) {
            int v36 = (void *)v62[v34];
          }
          else {
            int v36 = 0;
          }
          uint64_t v47 = (uint64_t *)llvm::VPTransformState::get(a2, **((llvm::VPValue ***)this + 6), v34);
          v59 = "wide.masked.gather";
          __int16 v61 = 259;
          MaskedLoad = (unsigned __int8 *)llvm::IRBuilderBase::CreateMaskedGather(v15, v55, v47, v24, v36, 0, (uint64_t)&v59);
          if (MaskedLoad) {
            BOOL v48 = MaskedLoad[16] >= 0x1Cu;
          }
          else {
            BOOL v48 = 0;
          }
          if (v48) {
            llvm::InnerLoopVectorizer::addMetadata(*((llvm::InnerLoopVectorizer **)a2 + 39), (llvm::Instruction *)MaskedLoad, (llvm::Instruction *)v4);
          }
        }
        sub_1CD8C9514((uint64_t)a2, v35, (uint64_t)MaskedLoad, v34++);
      }
      while (v34 < *((unsigned int *)a2 + 2));
    }
  }
  if (v62 != v65) {
    free(v62);
  }
}

unsigned __int8 *sub_1CD319848(uint64_t *a1, unsigned int a2, llvm::Value *this)
{
  uint64_t v6 = *a1;
  int v7 = llvm::Value::stripPointerCasts(this);
  char v8 = 0;
  if (v7 && *((unsigned char *)v7 + 16) == 62) {
    char v8 = *((unsigned char *)v7 + 17) & 2;
  }
  unint64_t v9 = (llvm::IRBuilderBase *)a1[1];
  uint64_t v10 = (llvm::ConstantInt *)(**((void **)v9 + 8) + 1960);
  unint64_t v11 = *(void *)a1[2];
  if (*(unsigned char *)(v6 + 161))
  {
    RuntimeVF = llvm::getRuntimeVF(v9, v10, v11);
    uint64_t v18 = a1[1];
    uint64_t v19 = **(void **)(v18 + 64);
    uint64_t v20 = *(llvm::ConstantInt **)(v19 + 1960);
    unint64_t v21 = *(unsigned int *)(v19 + 1968);
    unsigned int v54 = v21 >> 8;
    if (v21 >> 8 > 0x40) {
      operator new[]();
    }
    if (v21 <= 0xFF) {
      LODWORD(v22) = 0;
    }
    else {
      unint64_t v22 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v21) + 63);
    }
    uint64_t v53 = (const char *)(v22 & -a2);
    uint64_t v23 = llvm::ConstantInt::get(v20, (llvm::LLVMContext *)&v53, v16);
    if (v54 >= 0x41 && v53) {
      MEMORY[0x1D25D9CB0](v53, 0x1000C8000313F17);
    }
    __int16 v55 = 257;
    uint64_t v25 = sub_1CC09A1EC(v18, (uint64_t)v23, (uint64_t)RuntimeVF, (uint64_t)&v53, 0, 0);
    uint64_t v26 = a1[1];
    uint64_t v27 = **(void **)(v26 + 64);
    uint64_t v28 = *(llvm::ConstantInt **)(v27 + 1960);
    unint64_t v29 = *(unsigned int *)(v27 + 1968);
    unsigned int v54 = v29 >> 8;
    if (v29 >> 8 > 0x40) {
      operator new[]();
    }
    if (v29 <= 0xFF) {
      LOBYTE(v30) = 0;
    }
    else {
      unint64_t v30 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v29) + 63);
    }
    uint64_t v53 = (const char *)(v30 & 1);
    v31 = llvm::ConstantInt::get(v28, (llvm::LLVMContext *)&v53, v24);
    if (v54 >= 0x41 && v53) {
      MEMORY[0x1D25D9CB0](v53, 0x1000C8000313F17);
    }
    __int16 v55 = 257;
    uint64_t v32 = sub_1CB84494C(v26, (uint64_t)v31, (uint64_t)RuntimeVF, (uint64_t)&v53, 0, 0);
    v33 = (uint64_t *)a1[1];
    uint64_t v34 = *(void *)a1[3];
    __int16 v55 = 257;
    v35 = sub_1CB930F7C(v33, v34, (uint64_t *)this, (const char *)v25, (uint64_t)&v53);
    *((unsigned char *)v35 + 17) = *((unsigned char *)v35 + 17) & 0xFD | v8;
    int v36 = (uint64_t *)a1[1];
    uint64_t v37 = *(void *)a1[3];
    __int16 v55 = 257;
    uint64_t v15 = (unsigned __int8 *)sub_1CB930F7C(v36, v37, (uint64_t *)v35, (const char *)v32, (uint64_t)&v53);
    v15[17] = v15[17] & 0xFD | v8;
    if (*(unsigned char *)a1[4])
    {
      uint64_t v46 = *(void ***)(*(void *)a1[5] + 8 * a2);
      uint64_t v47 = (llvm::IRBuilderBase *)a1[1];
      uint64_t v53 = "reverse";
      __int16 v55 = 259;
      *(void *)(*(void *)a1[5] + 8 * a2) = llvm::IRBuilderBase::CreateVectorReverse(v47, v46, (const llvm::Twine *)&v53);
    }
  }
  else
  {
    StepForVF = llvm::createStepForVF(v9, v10, v11, a2);
    int v13 = (uint64_t *)a1[1];
    uint64_t v14 = *(void *)a1[3];
    __int16 v55 = 257;
    uint64_t v15 = (unsigned __int8 *)sub_1CB930F7C(v13, v14, (uint64_t *)this, (const char *)StepForVF, (uint64_t)&v53);
    v15[17] = v15[17] & 0xFD | v8;
  }
  unsigned int v38 = *(_DWORD *)(*(void *)this + 8);
  if ((v38 & 0xFE) == 0x12) {
    unsigned int v38 = *(_DWORD *)(**(void **)(*(void *)this + 16) + 8);
  }
  int v39 = (uint64_t *)a1[1];
  unint64_t v40 = llvm::PointerType::get(*(llvm::PointerType **)a1[6], (llvm::Type *)(v38 >> 8));
  __int16 v52 = 257;
  if (*(void *)v15 != v40)
  {
    if (v15[16] <= 0x14u)
    {
      uint64_t v15 = (unsigned __int8 *)(*(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *, unint64_t))(*(void *)v39[9] + 224))(v39[9], 49, v15, v40);
      if (v15) {
        BOOL v44 = v15[16] >= 0x1Cu;
      }
      else {
        BOOL v44 = 0;
      }
      if (v44)
      {
        (*(void (**)(uint64_t, unsigned __int8 *, unsigned char *, uint64_t, uint64_t))(*(void *)v39[10] + 16))(v39[10], v15, v51, v39[6], v39[7]);
        uint64_t v48 = *((unsigned int *)v39 + 2);
        if (v48)
        {
          uint64_t v49 = *v39;
          uint64_t v50 = *v39 + 16 * v48;
          do
          {
            llvm::Instruction::setMetadata((llvm::Instruction *)v15, *(_DWORD *)v49, *(llvm::MDNode **)(v49 + 8));
            v49 += 16;
          }
          while (v49 != v50);
        }
      }
    }
    else
    {
      __int16 v55 = 257;
      uint64_t v15 = (unsigned __int8 *)llvm::CastInst::Create(49, (uint64_t)v15, v40, &v53, 0);
      (*(void (**)(uint64_t, unsigned __int8 *, unsigned char *, uint64_t, uint64_t))(*(void *)v39[10] + 16))(v39[10], v15, v51, v39[6], v39[7]);
      uint64_t v41 = *((unsigned int *)v39 + 2);
      if (v41)
      {
        uint64_t v42 = *v39;
        uint64_t v43 = *v39 + 16 * v41;
        do
        {
          llvm::Instruction::setMetadata((llvm::Instruction *)v15, *(_DWORD *)v42, *(llvm::MDNode **)(v42 + 8));
          v42 += 16;
        }
        while (v42 != v43);
      }
    }
  }
  return v15;
}

unsigned char *llvm::LoopVectorizePass::LoopVectorizePass(unsigned char *result, unsigned int a2)
{
  *BOOL result = a2 & 1 | (byte_1EBD0D7B0 == 0);
  int v2 = (a2 >> 8) & 1;
  if (!byte_1EBD0D870) {
    LOBYTE(v2) = 1;
  }
  result[1] = v2;
  return result;
}

{
  int v2;

  *BOOL result = a2 & 1 | (byte_1EBD0D7B0 == 0);
  int v2 = (a2 >> 8) & 1;
  if (!byte_1EBD0D870) {
    LOBYTE(v2) = 1;
  }
  result[1] = v2;
  return result;
}

void llvm::LoopVectorizePass::processLoop(llvm::LoopVectorizePass *this, llvm::Loop *a2, uint64_t a3, uint64_t a4)
{
  v4 = (unsigned __int8 *)MEMORY[0x1F4188790](this, a2, a3, a4);
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  llvm::LoopVectorizeHints::LoopVectorizeHints((uint64_t)v6, v5, *v4, *((void *)v4 + 11));
}

uint64_t sub_1CD31D128(uint64_t a1, uint64_t a2, uint64_t a3, llvm::ProfileSummaryInfo *a4, llvm::BlockFrequencyInfoImplBase **a5, void *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a1 && ((*(unsigned char *)(a1 + 17) & 4) != 0 || *(char *)(a1 + 13) < 0)) {
    return 1;
  }
  if (llvm::shouldOptimizeForSize(**(llvm::BasicBlock ***)(a2 + 32), a4, a5))
  {
    int v17 = *(_DWORD *)(a3 + 40);
    if (v17 == -1) {
      llvm::Loop::getLoopID(*(llvm::Loop **)(a3 + 104));
    }
    if (v17 != 1) {
      return 1;
    }
  }
  if (word_1EA61E4F0 && dword_1EA61E568 < 3) {
    return dword_1CFB339E4[dword_1EA61E568];
  }
  int v19 = *(_DWORD *)(a3 + 72);
  if (v19 == 1) {
    return 3;
  }
  if (!v19) {
    return 0;
  }
  if ((*(unsigned int (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)*a6 + 208))(*a6, a2, a9, a10, a8, a7, a11, *(void *)(a12 + 56)))
  {
    return 3;
  }
  return 0;
}

uint64_t sub_1CD31D2D4(uint64_t result, llvm::LoopInfo *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = result;
  if (*(void *)(result + 8) != *(void *)(result + 16) && byte_1EA61E4A8 == 0)
  {
    if (byte_1EBD0DAB0) {
      llvm::LoopVectorizeHints::LoopVectorizeHints((uint64_t)&v13, result, 1, a3);
    }
    goto LABEL_10;
  }
  sub_1CBFCBAB0((uint64_t)&v13, result);
  llvm::LoopBlocksDFS::perform((llvm::LoopBlocksDFS *)&v13, a2);
  if (sub_1CC1581E4(&v13, (uint64_t *)a2))
  {
    if (__p)
    {
      uint64_t v16 = __p;
      operator delete(__p);
    }
    BOOL result = MEMORY[0x1D25D9CD0](v14, 8);
LABEL_10:
    uint64_t v10 = *(uint64_t **)(v7 + 8);
    unint64_t v9 = *(uint64_t **)(v7 + 16);
    while (v10 != v9)
    {
      uint64_t v11 = *v10++;
      BOOL result = sub_1CD31D2D4(v11, a2, a3, a4);
    }
    return result;
  }
  unsigned int v12 = *(_DWORD *)(a4 + 8);
  if (v12 >= *(_DWORD *)(a4 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)a4 + 8 * v12) = v7;
  ++*(_DWORD *)(a4 + 8);
  if (__p)
  {
    uint64_t v16 = __p;
    operator delete(__p);
  }
  return MEMORY[0x1D25D9CD0](v14, 8);
}

char *sub_1CD31D500(char *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >> 59) {
      abort();
    }
    uint64_t v7 = result;
    BOOL result = (char *)operator new(32 * a4);
    *uint64_t v7 = result;
    v7[2] = &result[32 * a4];
    if (a2 != a3)
    {
      uint64_t v8 = 0;
      do
      {
        unint64_t v9 = &result[v8];
        uint64_t v10 = a2 + v8;
        *(void *)unint64_t v9 = *(void *)(a2 + v8);
        v9[8] = 0;
        v9[24] = 0;
        if (*(unsigned char *)(a2 + v8 + 24))
        {
          uint64_t v11 = *(void *)(v10 + 16);
          *((void *)v9 + 1) = *(void *)(v10 + 8);
          *((void *)v9 + 2) = v11;
          v9[24] = 1;
        }
        v8 += 32;
      }
      while (v10 + 32 != a3);
      result += v8;
    }
    v7[1] = result;
  }
  return result;
}

uint64_t sub_1CD31D5AC(uint64_t *a1, void *a2)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  if (v2 - *a1 == a2[1] - *a2)
  {
    if (v3 == v2) {
      return 1;
    }
    uint64_t v4 = *a2 + 16;
    for (uint64_t i = v3 + 16; ; i += 32)
    {
      uint64_t v6 = i - 16;
      if (*(void *)(i - 16) != *(void *)(v4 - 16)) {
        break;
      }
      int v7 = *(unsigned __int8 *)(v4 + 8);
      if (*(unsigned char *)(i + 8)) {
        BOOL v8 = v7 == 0;
      }
      else {
        BOOL v8 = 1;
      }
      if (v8)
      {
        if ((*(unsigned char *)(i + 8) == 0) == (v7 != 0)) {
          return 0;
        }
      }
      else if (*(void *)(i - 8) != *(void *)(v4 - 8) || *(void *)i != *(void *)v4)
      {
        return 0;
      }
      v4 += 32;
      if (v6 + 32 == v2) {
        return 1;
      }
    }
  }
  return 0;
}

char *sub_1CD31D650(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a1 + 8);
  if (v3 >= *(void *)(a1 + 16))
  {
    BOOL result = sub_1CD31D6B8((void **)a1, a2);
  }
  else
  {
    *(void *)unint64_t v3 = *(void *)a2;
    *(unsigned char *)(v3 + 8) = 0;
    *(unsigned char *)(v3 + 24) = 0;
    if (*(unsigned char *)(a2 + 24))
    {
      uint64_t v4 = *(void *)(a2 + 16);
      *(void *)(v3 + 8) = *(void *)(a2 + 8);
      *(void *)(v3 + 16) = v4;
      *(unsigned char *)(v3 + 24) = 1;
    }
    BOOL result = (char *)(v3 + 32);
  }
  *(void *)(a1 + 8) = result;
  return result;
}

char *sub_1CD31D6B8(void **a1, uint64_t a2)
{
  unint64_t v3 = (char *)*a1;
  uint64_t v2 = (char *)a1[1];
  uint64_t v4 = (v2 - (unsigned char *)*a1) >> 5;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 59) {
    abort();
  }
  uint64_t v8 = (unsigned char *)a1[2] - v3;
  if (v8 >> 4 > v5) {
    unint64_t v5 = v8 >> 4;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v9 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  if (v9)
  {
    if (v9 >> 59) {
      sub_1CB833614();
    }
    uint64_t v10 = (char *)operator new(32 * v9);
  }
  else
  {
    uint64_t v10 = 0;
  }
  uint64_t v11 = &v10[32 * v4];
  *(void *)uint64_t v11 = *(void *)a2;
  v11[8] = 0;
  v11[24] = 0;
  if (*(unsigned char *)(a2 + 24))
  {
    uint64_t v12 = *(void *)(a2 + 16);
    *((void *)v11 + 1) = *(void *)(a2 + 8);
    *((void *)v11 + 2) = v12;
    v11[24] = 1;
  }
  uint64_t v13 = &v10[32 * v9];
  uint64_t v14 = v11 + 32;
  if (v2 == v3)
  {
    *a1 = v11;
    a1[1] = v14;
    a1[2] = v13;
  }
  else
  {
    uint64_t v15 = 0;
    do
    {
      uint64_t v16 = &v11[v15];
      int v17 = &v2[v15];
      *((void *)v16 - 4) = *(void *)&v2[v15 - 32];
      *(v16 - 24) = 0;
      *(v16 - 8) = 0;
      if (v2[v15 - 8])
      {
        uint64_t v19 = *((void *)v17 - 3);
        uint64_t v18 = *((void *)v17 - 2);
        *((void *)v16 - 3) = v19;
        *((void *)v16 - 2) = v18;
        *(v16 - 8) = 1;
      }
      v15 -= 32;
    }
    while (&v2[v15] != v3);
    uint64_t v2 = (char *)*a1;
    uint64_t v20 = (char *)a1[1];
    *a1 = &v11[v15];
    a1[1] = v14;
    a1[2] = v13;
    while (v20 != v2)
    {
      if (*(v20 - 8)) {
        *(v20 - 8) = 0;
      }
      v20 -= 32;
    }
  }
  if (v2) {
    operator delete(v2);
  }
  return v14;
}

llvm::Instruction *sub_1CD31D81C(uint64_t *a1, uint64_t a2, llvm::Instruction *VectorSplat)
{
  if (!a2 || *(unsigned char *)(a2 + 16) != 16) {
    goto LABEL_12;
  }
  uint64_t v5 = *(unsigned int *)(a2 + 32);
  if (v5 <= 0x40)
  {
    if (*(void *)(a2 + 24) == 1) {
      return VectorSplat;
    }
LABEL_12:
    if (VectorSplat && *((unsigned char *)VectorSplat + 16) == 16)
    {
      uint64_t v11 = *((unsigned int *)VectorSplat + 8);
      if (v11 > 0x40)
      {
        int v16 = 0;
        int64_t v17 = (unint64_t)(v11 + 63) >> 6;
        do
        {
          BOOL v8 = v17-- < 1;
          if (v8) {
            break;
          }
          unint64_t v18 = *(void *)(*((void *)VectorSplat + 3) + 8 * v17);
          v16 += __clz(v18);
        }
        while (!v18);
        int v19 = v11 | 0xFFFFFFC0;
        if ((v11 & 0x3F) == 0) {
          int v19 = 0;
        }
        if (v16 + v19 != v11 - 1) {
          goto LABEL_16;
        }
      }
      else if (*((void *)VectorSplat + 3) != 1)
      {
        goto LABEL_16;
      }
      return (llvm::Instruction *)a2;
    }
LABEL_16:
    if (*(void *)a2) {
      BOOL v12 = (*(_DWORD *)(*(void *)a2 + 8) & 0xFE) == 18;
    }
    else {
      BOOL v12 = 0;
    }
    if (v12 && (*(_DWORD *)(*(void *)VectorSplat + 8) & 0xFE) != 0x12)
    {
      uint64_t v13 = *a1;
      uint64_t v14 = (llvm::Type *)(*(unsigned int *)(*(void *)a2 + 32) | ((unint64_t)(*(_DWORD *)(*(void *)a2 + 8) == 19) << 32));
      __int16 v22 = 257;
      VectorSplat = llvm::IRBuilderBase::CreateVectorSplat(v13, v14, (unsigned __int8 *)VectorSplat, (uint64_t)v21);
    }
    uint64_t v15 = *a1;
    __int16 v22 = 257;
    return sub_1CC09A1EC(v15, a2, (uint64_t)VectorSplat, (uint64_t)v21, 0, 0);
  }
  int v6 = 0;
  int64_t v7 = (unint64_t)(v5 + 63) >> 6;
  do
  {
    BOOL v8 = v7-- < 1;
    if (v8) {
      break;
    }
    unint64_t v9 = *(void *)(*(void *)(a2 + 24) + 8 * v7);
    v6 += __clz(v9);
  }
  while (!v9);
  int v10 = v5 | 0xFFFFFFC0;
  if ((v5 & 0x3F) == 0) {
    int v10 = 0;
  }
  if (v6 + v10 != v5 - 1) {
    goto LABEL_12;
  }
  return VectorSplat;
}

uint64_t sub_1CD31D9AC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = 0;
  uint64_t v5 = a2;
  if (sub_1CD7D38CC((uint64_t *)a1, &v5, &v4)) {
    return v4;
  }
  else {
    return *(void *)a1 + 40 * *(unsigned int *)(a1 + 16);
  }
}

unint64_t sub_1CD31DA00(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  int v1 = *(_DWORD *)(a1 + 20);
  if ((v1 & 0x40000000) != 0)
  {
    unint64_t v3 = *(uint64_t **)(a1 - 8);
    uint64_t v2 = v1 & 0x7FFFFFF;
  }
  else
  {
    uint64_t v2 = v1 & 0x7FFFFFF;
    unint64_t v3 = (uint64_t *)(a1 - 32 * v2);
  }
  int v4 = *(unsigned __int8 *)(a1 + 16);
  unint64_t v5 = sub_1CD8D6458(v3, &v3[4 * v2]);
  uint64_t v13 = 0;
  memset(v12, 0, sizeof(v12));
  int v6 = &unk_1EBCBE000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
  {
    unint64_t v11 = v5;
    int v8 = __cxa_guard_acquire(&qword_1EBCBE588);
    int v6 = &unk_1EBCBE000;
    int v9 = v8;
    unint64_t v5 = v11;
    if (v9)
    {
      unint64_t v10 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v10 = 0xFF51AFD7ED558CCDLL;
      }
      qword_1EBCBE580 = v10;
      __cxa_guard_release(&qword_1EBCBE588);
      int v6 = (void *)&unk_1EBCBE000;
      unint64_t v5 = v11;
    }
  }
  unint64_t v14 = v6[176];
  LODWORD(v12[0]) = v4 - 28;
  *(void *)((char *)v12 + 4) = v5;
  return sub_1CBAE06B8(v12, 0xCuLL, v14);
}

uint64_t sub_1CD31DB2C(uint64_t a1, uint64_t *a2, const llvm::Instruction ***a3)
{
  uint64_t v5 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v6 = 4;
  }
  else
  {
    int v6 = *(_DWORD *)(a1 + 16);
    if (!v6)
    {
      BOOL v12 = 0;
      uint64_t result = 0;
      goto LABEL_27;
    }
    uint64_t v5 = *(void *)(a1 + 8);
  }
  unsigned int v7 = sub_1CD31DA00(*a2);
  int v8 = 0;
  int v9 = v6 - 1;
  for (int i = 1; ; ++i)
  {
    unsigned int v11 = v7 & v9;
    BOOL v12 = (const llvm::Instruction **)(v5 + 16 * (v7 & v9));
    uint64_t v13 = *a2;
    unint64_t v14 = *v12;
    if (*v12 == (const llvm::Instruction *)-8192
      || v13 == -8192
      || v13 == -4096
      || v14 == (const llvm::Instruction *)-4096)
    {
      if ((const llvm::Instruction *)v13 == v14) {
        goto LABEL_22;
      }
    }
    else
    {
      if (llvm::Instruction::isIdenticalToWhenDefined((llvm::Instruction *)*a2, *v12)
        && (*((unsigned __int8 *)v14 + 17) ^ *(unsigned __int8 *)(v13 + 17)) < 2)
      {
LABEL_22:
        uint64_t result = 1;
        goto LABEL_27;
      }
      unint64_t v14 = *v12;
    }
    if (v14 == (const llvm::Instruction *)-4096) {
      break;
    }
    if (v8) {
      BOOL v15 = 0;
    }
    else {
      BOOL v15 = v14 == (const llvm::Instruction *)-8192;
    }
    if (v15) {
      int v8 = (const llvm::Instruction **)(v5 + 16 * v11);
    }
    unsigned int v7 = v11 + i;
  }
  uint64_t result = 0;
  if (v8) {
    BOOL v12 = v8;
  }
LABEL_27:
  *a3 = v12;
  return result;
}

uint64_t sub_1CD31DC54(uint64_t a1, unsigned int a2)
{
  v14[8] = *MEMORY[0x1E4F143B8];
  if (a2 >= 5)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    int v6 = *(uint64_t **)(a1 + 8);
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    if (a2 > 4)
    {
      uint64_t v13 = a2;
      *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CD31DDE0(a1, v6, &v6[2 * v7]);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v8 = 0;
  int v9 = v14;
  do
  {
    uint64_t v10 = *(void *)(a1 + v8 + 8);
    if ((v10 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      *int v9 = v10;
      v9[1] = *(void *)(a1 + v8 + 16);
      v9 += 2;
    }
    v8 += 16;
  }
  while (v8 != 64);
  if (a2 > 4)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v11 = a2;
    *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v11;
  }
  return sub_1CD31DDE0(a1, v14, v9);
}

uint64_t sub_1CD31DDE0(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  int v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    uint64_t v8 = (void *)(result + 8);
    int v9 = (void *)(result + 72);
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(result + 16);
    if (!v7) {
      goto LABEL_10;
    }
    uint64_t v8 = *(void **)(result + 8);
    int v9 = &v8[2 * v7];
  }
  do
  {
    *uint64_t v8 = -4096;
    v8 += 2;
  }
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v11 = 0;
      uint64_t result = sub_1CD31DB2C((uint64_t)v5, a2, &v11);
      uint64_t v10 = v11;
      char *v11 = (const llvm::Instruction *)*a2;
      v10[1] = (const llvm::Instruction *)a2[1];
      *v5 += 2;
    }
    a2 += 2;
  }
  return result;
}

_DWORD *sub_1CD31DEA8(_DWORD *result, int a2)
{
  uint64_t v2 = result;
  if (a2)
  {
    unint64_t v3 = (4 * a2 / 3u + 1) | ((unint64_t)(4 * a2 / 3u + 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    LODWORD(v4) = (((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8)) + 1;
    result[4] = v4;
    uint64_t result = operator new(40 * v4, (std::align_val_t)8uLL);
    *(void *)uint64_t v2 = result;
    *((void *)v2 + 1) = 0;
    uint64_t v5 = v2[4];
    if (v5)
    {
      uint64_t v6 = 40 * v5;
      do
      {
        *(_OWORD *)uint64_t result = xmmword_1CFB1B720;
        result += 10;
        v6 -= 40;
      }
      while (v6);
    }
  }
  else
  {
    *(void *)uint64_t result = 0;
    *((void *)result + 1) = 0;
    result[4] = 0;
  }
  return result;
}

_DWORD *sub_1CD31DF48(_DWORD *result, int a2)
{
  uint64_t v2 = result;
  if (a2)
  {
    unint64_t v3 = (4 * a2 / 3u + 1) | ((unint64_t)(4 * a2 / 3u + 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    LODWORD(v4) = (((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8)) + 1;
    result[4] = v4;
    uint64_t result = operator new(72 * v4, (std::align_val_t)8uLL);
    *(void *)uint64_t v2 = result;
    *((void *)v2 + 1) = 0;
    uint64_t v5 = v2[4];
    if (v5)
    {
      uint64_t v6 = 72 * v5;
      do
      {
        *(void *)uint64_t result = 0x1FFFFFFFFLL;
        result += 18;
        v6 -= 72;
      }
      while (v6);
    }
  }
  else
  {
    *(void *)uint64_t result = 0;
    *((void *)result + 1) = 0;
    result[4] = 0;
  }
  return result;
}

void sub_1CD31DFE4()
{
}

void sub_1CD31E02C(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD31E064(uint64_t a1, uint64_t a2)
{
  sub_1CB843600(a2, a2, (uint64_t)llvm::AssumptionCacheTracker::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::BlockFrequencyInfoWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::LoopInfoWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)llvm::ScalarEvolutionWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)llvm::TargetTransformInfoWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)llvm::AAResultsWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::LoopAccessLegacyAnalysis::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::DemandedBitsWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::OptimizationRemarkEmitterWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::InjectTLIMappingsLegacy::ID);
  if (!byte_1EBD0DAB0)
  {
    sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::LoopInfoWrapperPass::ID);
    sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  }
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::BasicAAWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::GlobalsAAWrapperPass::ID);

  sub_1CB843600(a2, a2, (uint64_t)llvm::ProfileSummaryInfoWrapperPass::ID);
}

uint64_t sub_1CD31E1E0(llvm::FunctionPass *a1, uint64_t a2)
{
  uint64_t v101 = *MEMORY[0x1E4F143B8];
  if (llvm::FunctionPass::skipFunction(a1, (llvm::LLVMContextImpl ****)a2)) {
    return 0;
  }
  uint64_t v6 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v7 = *v6;
  uint64_t v8 = v6[1];
  if (v7 == v8)
  {
LABEL_7:
    uint64_t v9 = 0;
  }
  else
  {
    while (*(char **)v7 != llvm::ScalarEvolutionWrapperPass::ID)
    {
      v7 += 16;
      if (v7 == v8) {
        goto LABEL_7;
      }
    }
    uint64_t v9 = *(void *)(v7 + 8);
  }
  uint64_t v10 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v9 + 96))(v9, llvm::ScalarEvolutionWrapperPass::ID);
  uint64_t v11 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v12 = *v11;
  uint64_t v13 = v11[1];
  uint64_t v75 = *(void *)(v10 + 32);
  if (v12 == v13)
  {
LABEL_12:
    uint64_t v14 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v12 != &llvm::LoopInfoWrapperPass::ID)
    {
      v12 += 16;
      if (v12 == v13) {
        goto LABEL_12;
      }
    }
    uint64_t v14 = *(void *)(v12 + 8);
  }
  uint64_t v15 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v14 + 96))(v14, &llvm::LoopInfoWrapperPass::ID);
  int v16 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v17 = *v16;
  uint64_t v18 = v16[1];
  if (v17 == v18)
  {
LABEL_17:
    uint64_t v19 = 0;
  }
  else
  {
    while (*(char **)v17 != llvm::TargetTransformInfoWrapperPass::ID)
    {
      v17 += 16;
      if (v17 == v18) {
        goto LABEL_17;
      }
    }
    uint64_t v19 = *(void *)(v17 + 8);
  }
  uint64_t v20 = (llvm::TargetTransformInfoWrapperPass *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v19 + 96))(v19, llvm::TargetTransformInfoWrapperPass::ID);
  TTI = llvm::TargetTransformInfoWrapperPass::getTTI(v20, (const Function *)a2);
  __int16 v22 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v23 = *v22;
  uint64_t v24 = v22[1];
  uint64_t v74 = (uint64_t)TTI;
  if (v23 == v24)
  {
LABEL_22:
    uint64_t v25 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v23 != &llvm::DominatorTreeWrapperPass::ID)
    {
      v23 += 16;
      if (v23 == v24) {
        goto LABEL_22;
      }
    }
    uint64_t v25 = *(void *)(v23 + 8);
  }
  uint64_t v26 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v25 + 96))(v25, &llvm::DominatorTreeWrapperPass::ID);
  uint64_t v27 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v28 = *v27;
  uint64_t v29 = v27[1];
  if (v28 == v29)
  {
LABEL_27:
    uint64_t v30 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v28 != &llvm::BlockFrequencyInfoWrapperPass::ID)
    {
      v28 += 16;
      if (v28 == v29) {
        goto LABEL_27;
      }
    }
    uint64_t v30 = *(void *)(v28 + 8);
  }
  uint64_t v31 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v30 + 96))(v30, &llvm::BlockFrequencyInfoWrapperPass::ID);
  uint64_t AnalysisPass = llvm::PMDataManager::findAnalysisPass(*(llvm::PMDataManager **)(*((void *)a1 + 1) + 24), llvm::TargetLibraryInfoWrapperPass::ID, 1);
  if (AnalysisPass)
  {
    uint64_t v33 = (*(uint64_t (**)(uint64_t, char *))(*(void *)AnalysisPass + 96))(AnalysisPass, llvm::TargetLibraryInfoWrapperPass::ID);
    if (v33)
    {
      v76[0] = 0;
      v76[1] = 0;
      int v77 = 0;
      uint64_t v78 = 0;
      uint64_t v79 = 0;
      int v80 = 0;
      uint64_t v81 = 0;
      uint64_t v82 = 0;
      int v83 = 0;
      uint64_t v34 = v33 + 32;
      if (!*(unsigned char *)(v33 + 232))
      {
        uint64_t v70 = *(void *)(a2 + 40) + 216;
        __int16 v85 = 260;
        v84[0] = v70;
        llvm::Triple::Triple((llvm::Triple *)__p, (const llvm::Twine *)v84);
        uint64_t v95 = 0;
        uint64_t v96 = 0;
        int v97 = 0;
        long long v98 = 0u;
        long long v99 = 0u;
        long long v100 = 0u;
        *(void *)&long long v71 = -1;
        *((void *)&v71 + 1) = -1;
        *(_OWORD *)__src = v71;
        long long v89 = v71;
        long long v90 = v71;
        long long v91 = v71;
        long long v92 = v71;
        long long v93 = v71;
        *(_OWORD *)v94 = v71;
        *(void *)&v94[13] = -1;
        sub_1CC153974((uint64_t)__src, (int *)__p);
        sub_1CD4D04B8(v34, (uint64_t)__src);
        sub_1CD4CFA4C((uint64_t *)__src);
        if (v87 < 0) {
          operator delete(__p[0]);
        }
      }
      sub_1CC1569E8(__src, v34);
    }
  }
  v35 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v36 = *v35;
  uint64_t v37 = v35[1];
  if (v36 == v37)
  {
LABEL_37:
    uint64_t v38 = 0;
  }
  else
  {
    while (*(char **)v36 != llvm::AAResultsWrapperPass::ID)
    {
      v36 += 16;
      if (v36 == v37) {
        goto LABEL_37;
      }
    }
    uint64_t v38 = *(void *)(v36 + 8);
  }
  uint64_t v39 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v38 + 96))(v38, llvm::AAResultsWrapperPass::ID);
  unint64_t v40 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v41 = *v40;
  uint64_t v42 = v40[1];
  if (v41 == v42)
  {
LABEL_42:
    uint64_t v43 = 0;
  }
  else
  {
    while (*(char **)v41 != llvm::AssumptionCacheTracker::ID)
    {
      v41 += 16;
      if (v41 == v42) {
        goto LABEL_42;
      }
    }
    uint64_t v43 = *(void *)(v41 + 8);
  }
  uint64_t v44 = *(void *)(v39 + 32);
  uint64_t v45 = (llvm::AssumptionCacheTracker *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v43 + 96))(v43, llvm::AssumptionCacheTracker::ID);
  uint64_t AssumptionCache = llvm::AssumptionCacheTracker::getAssumptionCache(v45, (llvm::Function *)a2);
  uint64_t v47 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v48 = *v47;
  uint64_t v49 = v47[1];
  if (v48 == v49)
  {
LABEL_47:
    uint64_t v50 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v48 != &llvm::LoopAccessLegacyAnalysis::ID)
    {
      v48 += 16;
      if (v48 == v49) {
        goto LABEL_47;
      }
    }
    uint64_t v50 = *(void *)(v48 + 8);
  }
  v76[0] = (*(uint64_t (**)(uint64_t, void *))(*(void *)v50 + 96))(v50, &llvm::LoopAccessLegacyAnalysis::ID);
  unint64_t v51 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v52 = *v51;
  uint64_t v53 = v51[1];
  if (v52 == v53)
  {
LABEL_52:
    uint64_t v54 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v52 != &llvm::DemandedBitsWrapperPass::ID)
    {
      v52 += 16;
      if (v52 == v53) {
        goto LABEL_52;
      }
    }
    uint64_t v54 = *(void *)(v52 + 8);
  }
  uint64_t v55 = v15 + 32;
  uint64_t v56 = v26 + 32;
  uint64_t v57 = v31 + 32;
  uint64_t v58 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v54 + 96))(v54, &llvm::DemandedBitsWrapperPass::ID)
      + 32;
  v59 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v60 = *v59;
  uint64_t v61 = v59[1];
  if (v60 == v61)
  {
LABEL_57:
    uint64_t v62 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v60 != &llvm::OptimizationRemarkEmitterWrapperPass::ID)
    {
      v60 += 16;
      if (v60 == v61) {
        goto LABEL_57;
      }
    }
    uint64_t v62 = *(void *)(v60 + 8);
  }
  uint64_t v63 = *(void *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v62 + 96))(v62, &llvm::OptimizationRemarkEmitterWrapperPass::ID)+ 32);
  int v64 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v65 = *v64;
  uint64_t v66 = v64[1];
  if (v65 == v66)
  {
LABEL_62:
    uint64_t v67 = 0;
  }
  else
  {
    while (*(char **)v65 != llvm::ProfileSummaryInfoWrapperPass::ID)
    {
      v65 += 16;
      if (v65 == v66) {
        goto LABEL_62;
      }
    }
    uint64_t v67 = *(void *)(v65 + 8);
  }
  uint64_t v68 = *(void *)((*(uint64_t (**)(uint64_t, char *))(*(void *)v67 + 96))(v67, llvm::ProfileSummaryInfoWrapperPass::ID)+ 32);
  __src[0] = &unk_1F264B400;
  __src[1] = v76;
  *((void *)&v89 + 1) = __src;
  *(void *)&long long v73 = AssumptionCache;
  *((void *)&v73 + 1) = __src;
  *(void *)&long long v72 = v58;
  *((void *)&v72 + 1) = v44;
  uint64_t v4 = llvm::LoopVectorizePass::runImpl((uint64_t)a1 + 32, v69, v75, v55, v74, v56, v57, 0, v72, v73, v63, v68) & 1;
  if (*((void ***)&v89 + 1) == __src)
  {
    (*((void (**)(void **))__src[0] + 4))(__src);
  }
  else if (*((void *)&v89 + 1))
  {
    (*(void (**)(void))(**((void **)&v89 + 1) + 40))();
  }
  return v4;
}

void sub_1CD31EADC()
{
}

void *sub_1CD31EAF0(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F264B400;
  result[1] = v3;
  return result;
}

uint64_t sub_1CD31EB38(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F264B400;
  a2[1] = v2;
  return result;
}

uint64_t sub_1CD31EB64(uint64_t a1, llvm::Loop *a2)
{
  return llvm::LoopAccessLegacyAnalysis::getInfo(**(llvm::LoopAccessLegacyAnalysis ***)(a1 + 8), a2);
}

void sub_1CD31EB74()
{
}

__n128 sub_1CD31EB88(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1F264B448;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1CD31EBDC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F264B448;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1CD31EC14(uint64_t a1, unint64_t *a2)
{
  unint64_t v3 = *a2;
  uint64_t v4 = *(uint64_t **)(a1 + 8);
  uint64_t v5 = **(void **)(a1 + 16);
  if (sub_1CD8CD258(*v4, v5, *a2) || sub_1CD30BE30(*v4, v5, v3)) {
    return 1;
  }
  uint64_t v7 = *(void *)(**(void **)(a1 + 16) + 8);
  if (v7)
  {
    uint64_t v8 = *(uint64_t **)(a1 + 8);
    uint64_t v9 = *(void *)(a1 + 24);
    while (1)
    {
      uint64_t v10 = *(void *)(v7 + 24);
      uint64_t v11 = *(void *)(v10 + 40);
      uint64_t v13 = *(void *)(v9 + 56);
      uint64_t v12 = *(void *)(v9 + 64);
      if (v12 == v13)
      {
        uint64_t v14 = *(unsigned int *)(v9 + 76);
        uint64_t v15 = (void *)(v12 + 8 * v14);
        if (v14)
        {
          uint64_t v16 = 0;
          uint64_t v17 = 8 * v14;
          while (*(void *)(v12 + v16) != v11)
          {
            v16 += 8;
            if (v17 == v16) {
              goto LABEL_24;
            }
          }
          uint64_t v15 = (void *)(v12 + v16);
        }
LABEL_24:
        uint64_t v13 = *(void *)(v9 + 64);
      }
      else
      {
        uint64_t v18 = *(unsigned int *)(v9 + 72);
        int v19 = v18 - 1;
        unsigned int v20 = (v18 - 1) & ((v11 >> 4) ^ (v11 >> 9));
        uint64_t v15 = (void *)(v12 + 8 * v20);
        uint64_t v21 = *v15;
        if (*v15 == -1)
        {
          __int16 v22 = 0;
LABEL_32:
          if (v22) {
            uint64_t v15 = v22;
          }
          if (*v15 != v11) {
            uint64_t v15 = (void *)(v12 + 8 * v18);
          }
        }
        else
        {
          __int16 v22 = 0;
          int v23 = 1;
          while (v21 != v11)
          {
            if (v22) {
              BOOL v24 = 0;
            }
            else {
              BOOL v24 = v21 == -2;
            }
            if (v24) {
              __int16 v22 = v15;
            }
            unsigned int v25 = v20 + v23++;
            unsigned int v20 = v25 & v19;
            uint64_t v15 = (void *)(v12 + 8 * (v25 & v19));
            uint64_t v21 = *v15;
            if (*v15 == -1) {
              goto LABEL_32;
            }
          }
        }
      }
      uint64_t v26 = (unsigned int *)(v12 == v13 ? v9 + 76 : v9 + 72);
      if (v15 != (void *)(v12 + 8 * *v26)
        && (sub_1CD8CD258(*v8, *(void *)(v7 + 24), v3) || sub_1CD30BE30(*v8, v10, v3)))
      {
        return 1;
      }
      uint64_t v7 = *(void *)(v7 + 8);
      if (!v7) {
        return 0;
      }
    }
  }
  return 0;
}

void sub_1CD31EDD0()
{
}

__n128 sub_1CD31EDE4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F264B490;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1CD31EE30(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F264B490;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

BOOL sub_1CD31EE60(uint64_t a1, unint64_t *a2)
{
  uint64_t v2 = *a2;
  unint64_t v3 = *(uint64_t **)(a1 + 8);
  uint64_t v4 = **(void **)(a1 + 16);
  if (sub_1CD8CD258(*v3, v4, *a2)) {
    return 1;
  }
  uint64_t v6 = *v3;

  return sub_1CD30BE30(v6, v4, v2);
}

void sub_1CD31EED8()
{
}

__n128 sub_1CD31EEEC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F264B4D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1CD31EF38(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F264B4D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

BOOL sub_1CD31EF68(uint64_t a1, llvm::Type **a2)
{
  return sub_1CD8CEA8C(*(void *)(*(void *)(a1 + 8) + 24), *(llvm::FixedVectorType ***)(a1 + 16), *a2);
}

void *sub_1CD31EF78(void *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v6 = sub_1CD8D778C((uint64_t)a1, 13, a3, a4);
  *(void *)uint64_t v6 = &unk_1F264AF18;
  *(void *)(v6 + 40) = &unk_1F264AF58;
  *(void *)(v6 + 96) = &unk_1F264BF30;
  *(unsigned char *)(v6 + 104) = 10;
  *(void *)(v6 + 112) = v6 + 128;
  *(void *)(v6 + 120) = 0x100000000;
  *(void *)(v6 + 136) = a2;
  *(void *)(v6 + 144) = v6;
  sub_1CD486FFC((unint64_t *)(v6 + 16), v6 + 96);
  *a1 = &unk_1F264AF18;
  a1[5] = &unk_1F264AF58;
  a1[12] = &unk_1F264AF78;
  a1[19] = a2;
  return a1;
}

uint64_t sub_1CD31F070@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *a1;
  sub_1CD31F2B8((uint64_t)v14, a2);
  sub_1CD8D856C(v6, v14, &v16);
  uint64_t v7 = a1[1];
  sub_1CD31F2B8((uint64_t)v9, a2);
  sub_1CD8D856C(v7, v9, &v11);
  sub_1CD8D8370(&v16, &v11, a3);
  if (v13 == v12)
  {
    (*(void (**)(void *))(v12[0] + 32))(v12);
  }
  else if (v13)
  {
    (*(void (**)(void))(*v13 + 40))();
  }
  if (v10 == v9)
  {
    (*(void (**)(void *))(v9[0] + 32))(v9);
  }
  else if (v10)
  {
    (*(void (**)(void))(*v10 + 40))();
  }
  if (v18 == v17)
  {
    (*(void (**)(void *))(v17[0] + 32))(v17);
  }
  else if (v18)
  {
    (*(void (**)(void *))(*v18 + 40))(v18);
  }
  uint64_t result = (uint64_t)v15;
  if (v15 == v14) {
    return (*(uint64_t (**)(void *))(v14[0] + 32))(v14);
  }
  if (v15) {
    return (*(uint64_t (**)(void))(*v15 + 40))();
  }
  return result;
}

uint64_t sub_1CD31F2B8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void sub_1CD31F350(void ***a1)
{
  int v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v3 = (char *)v1[1];
    uint64_t v4 = **a1;
    if (v3 != v2)
    {
      int32x2_t v5 = (int32x2_t)0x1FFFFFFFFLL;
      do
      {
        uint64_t v6 = (char *)*((void *)v3 - 4);
        if (v6 != v3 - 16)
        {
          BOOL v24 = a1;
          unsigned int v20 = v2;
          uint64_t v21 = v1;
          __int16 v22 = v3;
          int32x2_t v23 = v5;
          free(v6);
          int32x2_t v5 = v23;
          int v1 = v21;
          uint64_t v3 = v22;
          uint64_t v2 = v20;
          a1 = v24;
        }
        uint64_t v7 = *((void *)v3 - 9);
        if (v7 && v7 != -8192 && v7 != -4096)
        {
          unint64_t v8 = *((void *)v3 - 11) & 0xFFFFFFFFFFFFFFF8;
          *(void *)unint64_t v8 = *((void *)v3 - 10);
          uint64_t v9 = (unint64_t *)*((void *)v3 - 10);
          if (v9)
          {
            *uint64_t v9 = *v9 & 7 | v8;
          }
          else
          {
            uint64_t v10 = *((void *)v3 - 9);
            uint64_t v11 = ***(int32x2_t ****)v10;
            unint64_t v12 = (unint64_t)v11[303];
            if (v12 <= v8)
            {
              uint64_t v13 = v11[305].u32[0];
              if (v12 + 16 * v13 > v8)
              {
                unsigned int v14 = v13 - 1;
                LODWORD(v15) = v14 & ((v10 >> 4) ^ (v10 >> 9));
                uint64_t v16 = (uint64_t *)(v12 + 16 * v15);
                uint64_t v17 = *v16;
                if (v10 == *v16)
                {
LABEL_17:
                  uint64_t *v16 = -8192;
                  v11[304] = vadd_s32(v11[304], v5);
                  uint64_t v10 = *((void *)v3 - 9);
                }
                else
                {
                  int v18 = 1;
                  while (v17 != -4096)
                  {
                    int v19 = v15 + v18++;
                    uint64_t v15 = v19 & v14;
                    uint64_t v17 = *(void *)(v12 + 16 * v15);
                    if (v10 == v17)
                    {
                      uint64_t v16 = (uint64_t *)(v12 + 16 * v15);
                      goto LABEL_17;
                    }
                  }
                }
                *(unsigned char *)(v10 + 17) &= ~1u;
              }
            }
          }
        }
        v3 -= 96;
      }
      while (v3 != v2);
      uint64_t v4 = **a1;
    }
    v1[1] = v2;
    operator delete(v4);
  }
}

void sub_1CD31F4E8(void ***a1)
{
  int v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    int32x2_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = v4 - 176;
        sub_1CD48CFE4((llvm::ValueHandleBase *)(v4 - 168));
        uint64_t v4 = v6;
      }
      while (v6 != v2);
      int32x2_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t **sub_1CD31F570(uint64_t **result, uint64_t a2, uint64_t ***a3, uint64_t a4, char a5)
{
  uint64_t v256 = (uint64_t)result;
LABEL_2:
  v253 = (unint64_t *)(a2 - 16);
  unint64_t v255 = a2;
  uint64_t v248 = a2 - 48;
  uint64_t v249 = a2 - 32;
  unint64_t j = v256;
  while (1)
  {
    unint64_t v11 = j;
    uint64_t v12 = a2 - j;
    uint64_t v13 = (uint64_t)(a2 - j) >> 4;
    uint64_t v256 = v11;
    if (v6 || !v5)
    {
      switch(v13)
      {
        case 0:
        case 1:
          return result;
        case 2:
          v237 = (unint64_t *)(a2 - 16);
          uint64_t v238 = a2;
          int v239 = *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)(a2 - 16), (uint64_t **)(a2 - 16)) + 10);
          uint64_t result = sub_1CD4FD4E8(*a3, *(void *)v11, (uint64_t **)v11);
          if (v239 == *((_DWORD *)result + 10))
          {
            int v240 = *(_DWORD *)(v238 - 4);
            int v241 = *(_DWORD *)(v11 + 12);
            if (v240 == 1 || v241 != 1)
            {
              BOOL v243 = v241 != 1 && v240 == 1;
              if (v243 || *(_DWORD *)(v238 - 8) >= *(_DWORD *)(v11 + 8)) {
                return result;
              }
            }
          }
          else
          {
            unsigned int v247 = *((_DWORD *)sub_1CD4FD4E8(*a3, *v237, (uint64_t **)v237) + 10);
            uint64_t result = sub_1CD4FD4E8(*a3, *(void *)v11, (uint64_t **)v11);
            if (v247 >= *((_DWORD *)result + 10)) {
              return result;
            }
          }
          unint64_t v245 = *(void *)v11;
          *(void *)unint64_t v11 = *(void *)(v238 - 16);
          *(void *)(v238 - 16) = v245;
          uint64_t v246 = *(void *)(v11 + 8);
          *(void *)(v11 + 8) = *(void *)(v238 - 8);
          *(void *)(v238 - 8) = v246;
          return result;
        case 3:
          return sub_1CD320E44(v11, v11 + 16, (uint64_t)v253, a3);
        case 4:
          return sub_1CD321548(v11, v11 + 16, v11 + 32, (uint64_t)v253, a3);
        case 5:
          return sub_1CD320B18(v11, v11 + 16, v11 + 32, v11 + 48, (uint64_t)v253, a3);
        default:
          JUMPOUT(0);
      }
    }
    if (v12 <= 383) {
      break;
    }
    if (!a4)
    {
      if (v11 == a2) {
        return result;
      }
      int64_t v142 = (unint64_t)(v13 - 2) >> 1;
      int64_t v143 = v142;
      while (1)
      {
        int64_t v144 = v143;
        if (v142 < v143) {
          goto LABEL_257;
        }
        uint64_t v145 = (2 * v143) | 1;
        uint64_t v146 = v256 + 16 * v145;
        if (2 * v143 + 2 >= v13) {
          goto LABEL_277;
        }
        int v147 = *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)v146, (uint64_t **)(v256 + 16 * v145)) + 10);
        if (v147 == *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)(v146 + 16), (uint64_t **)(v146 + 16)) + 10))
        {
          uint64_t v148 = v256 + 16 * v145;
          int v149 = *(_DWORD *)(v148 + 12);
          int v150 = *(_DWORD *)(v146 + 28);
          if (v149 == 1 || v150 != 1)
          {
            BOOL v152 = v150 != 1 && v149 == 1;
            unsigned int v153 = *(_DWORD *)(v148 + 8);
            if (v152 || v153 >= *(_DWORD *)(v146 + 24)) {
              goto LABEL_277;
            }
          }
        }
        else
        {
          unsigned int v155 = *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)v146, (uint64_t **)v146) + 10);
          if (v155 >= *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)(v146 + 16), (uint64_t **)(v146 + 16)) + 10)) {
            goto LABEL_277;
          }
        }
        v146 += 16;
        uint64_t v145 = 2 * v144 + 2;
LABEL_277:
        v156 = (unint64_t *)(v256 + 16 * v144);
        int v157 = *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)v146, (uint64_t **)v146) + 10);
        uint64_t result = sub_1CD4FD4E8(*a3, *v156, (uint64_t **)v156);
        if (v157 == *((_DWORD *)result + 10))
        {
          int v158 = *(_DWORD *)(v146 + 12);
          uint64_t v159 = v256 + 16 * v144;
          int v160 = *(_DWORD *)(v159 + 12);
          BOOL v161 = v158 != 1 && v160 == 1;
          a2 = v255;
          if (v161) {
            goto LABEL_257;
          }
          BOOL v162 = v160 != 1 && v158 == 1;
          if (!v162 && *(_DWORD *)(v146 + 8) < *(_DWORD *)(v159 + 8)) {
            goto LABEL_257;
          }
        }
        else
        {
          unsigned int v183 = *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)v146, (uint64_t **)v146) + 10);
          uint64_t result = sub_1CD4FD4E8(*a3, *v156, (uint64_t **)v156);
          BOOL v5 = v183 >= *((_DWORD *)result + 10);
          a2 = v255;
          if (!v5) {
            goto LABEL_257;
          }
        }
        long long v257 = *(_OWORD *)v156;
        unint64_t *v156 = *(void *)v146;
        *(void *)(v256 + 16 * v144 + 8) = *(void *)(v146 + 8);
        if (v142 < v145)
        {
LABEL_292:
          uint64_t v164 = v146;
          goto LABEL_293;
        }
        while (1)
        {
          uint64_t v165 = 2 * v145;
          uint64_t v145 = (2 * v145) | 1;
          uint64_t v164 = v256 + 16 * v145;
          uint64_t v166 = v165 + 2;
          if (v165 + 2 >= v13) {
            goto LABEL_312;
          }
          int v167 = *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)v164, (uint64_t **)(v256 + 16 * v145)) + 10);
          if (v167 == *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)(v164 + 16), (uint64_t **)(v164 + 16)) + 10))
          {
            uint64_t v168 = v256 + 16 * v145;
            int v169 = *(_DWORD *)(v168 + 12);
            int v170 = *(_DWORD *)(v164 + 28);
            BOOL v171 = v169 != 1 && v170 == 1;
            if (v171
              || (v170 != 1 ? (BOOL v172 = v169 == 1) : (BOOL v172 = 0),
                  (unsigned int v173 = *(_DWORD *)(v168 + 8), !v172) ? (v174 = v173 >= *(_DWORD *)(v164 + 24)) : (v174 = 1),
                  !v174))
            {
LABEL_311:
              v164 += 16;
              uint64_t v145 = v166;
            }
          }
          else
          {
            unsigned int v175 = *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)v164, (uint64_t **)v164) + 10);
            if (v175 < *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)(v164 + 16), (uint64_t **)(v164 + 16)) + 10)) {
              goto LABEL_311;
            }
          }
LABEL_312:
          int v176 = *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)v164, (uint64_t **)v164) + 10);
          unint64_t v177 = v257;
          uint64_t result = sub_1CD4FD4E8(*a3, v257, (uint64_t **)&v257);
          if (v176 == *((_DWORD *)result + 10)) {
            break;
          }
          unsigned int v181 = *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)v164, (uint64_t **)v164) + 10);
          uint64_t result = sub_1CD4FD4E8(*a3, v177, (uint64_t **)&v257);
          BOOL v182 = v181 >= *((_DWORD *)result + 10);
LABEL_325:
          a2 = v255;
          if (!v182) {
            goto LABEL_292;
          }
          *(void *)uint64_t v146 = *(void *)v164;
          *(void *)(v146 + 8) = *(void *)(v164 + 8);
          uint64_t v146 = v164;
          if (v142 < v145) {
            goto LABEL_293;
          }
        }
        int v178 = *(_DWORD *)(v164 + 12);
        if (v178 == 1 || HIDWORD(v257) != 1)
        {
          BOOL v182 = HIDWORD(v257) != 1 && v178 == 1 || *(_DWORD *)(v164 + 8) >= DWORD2(v257);
          goto LABEL_325;
        }
        uint64_t v164 = v146;
        a2 = v255;
LABEL_293:
        *(_OWORD *)uint64_t v164 = v257;
LABEL_257:
        int64_t v143 = v144 - 1;
        if (!v144)
        {
LABEL_351:
          uint64_t v196 = 0;
          uint64_t v197 = v256;
          unint64_t v254 = *(void *)v256;
          uint64_t v252 = *(void *)(v256 + 8);
          while (1)
          {
            v198 = (void *)v197;
            uint64_t v199 = v196 + 1;
            v197 += 16 * (v196 + 1);
            uint64_t v200 = 2 * v196;
            uint64_t v196 = (2 * v196) | 1;
            uint64_t v201 = v200 + 2;
            if (v200 + 2 < v13)
            {
              int v202 = *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)v197, (uint64_t **)v197) + 10);
              uint64_t result = sub_1CD4FD4E8(*a3, *(void *)(v197 + 16), (uint64_t **)(v197 + 16));
              if (v202 == *((_DWORD *)result + 10))
              {
                v203 = &v198[2 * v199];
                int v204 = *((_DWORD *)v203 + 3);
                int v205 = *(_DWORD *)(v197 + 28);
                if (v204 == 1 || v205 != 1)
                {
                  BOOL v207 = v205 != 1 && v204 == 1;
                  unsigned int v208 = *((_DWORD *)v203 + 2);
                  if (v207 || v208 >= *(_DWORD *)(v197 + 24)) {
                    goto LABEL_354;
                  }
                }
              }
              else
              {
                unsigned int v210 = *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)v197, (uint64_t **)v197) + 10);
                uint64_t result = sub_1CD4FD4E8(*a3, *(void *)(v197 + 16), (uint64_t **)(v197 + 16));
                if (v210 >= *((_DWORD *)result + 10)) {
                  goto LABEL_354;
                }
              }
              v197 += 16;
              uint64_t v196 = v201;
            }
LABEL_354:
            void *v198 = *(void *)v197;
            v198[1] = *(void *)(v197 + 8);
            if (v196 > (uint64_t)((unint64_t)(v13 - 2) >> 1))
            {
              uint64_t v211 = a2 - 16;
              if (v197 == a2 - 16)
              {
                *(void *)uint64_t v197 = v254;
                *(void *)(v197 + 8) = v252;
                goto LABEL_389;
              }
              *(void *)uint64_t v197 = *(void *)(a2 - 16);
              *(void *)(v197 + 8) = *(void *)(a2 - 8);
              *(void *)(a2 - 16) = v254;
              *(void *)(a2 - 8) = v252;
              uint64_t v212 = v197 - v256 + 16;
              if (v212 >= 17)
              {
                unint64_t v213 = ((unint64_t)v212 >> 4) - 2;
                unint64_t v186 = v213 >> 1;
                v187 = (unint64_t *)(v256 + 16 * (v213 >> 1));
                int v214 = *((_DWORD *)sub_1CD4FD4E8(*a3, *v187, (uint64_t **)v187) + 10);
                uint64_t result = sub_1CD4FD4E8(*a3, *(void *)v197, (uint64_t **)v197);
                if (v214 == *((_DWORD *)result + 10))
                {
                  int v215 = *((_DWORD *)v187 + 3);
                  int v216 = *(_DWORD *)(v197 + 12);
                  BOOL v217 = v215 != 1 && v216 == 1;
                  if (v217
                    || (v216 != 1 ? (BOOL v218 = v215 == 1) : (BOOL v218 = 0),
                        !v218 ? (BOOL v219 = *(_DWORD *)(v256 + 16 * v186 + 8) >= *(_DWORD *)(v197 + 8)) : (BOOL v219 = 1),
                        !v219))
                  {
LABEL_387:
                    long long v257 = *(_OWORD *)v197;
                    *(void *)uint64_t v197 = *v187;
                    *(void *)(v197 + 8) = *(void *)(v256 + 16 * v186 + 8);
                    if (v213 >= 2)
                    {
                      do
                      {
                        v184 = v187;
                        unint64_t v185 = v186 - 1;
                        unint64_t v186 = (v186 - 1) >> 1;
                        v187 = (unint64_t *)(v256 + 16 * v186);
                        int v188 = *((_DWORD *)sub_1CD4FD4E8(*a3, *v187, (uint64_t **)v187) + 10);
                        unint64_t v189 = v257;
                        uint64_t result = sub_1CD4FD4E8(*a3, v257, (uint64_t **)&v257);
                        if (v188 == *((_DWORD *)result + 10))
                        {
                          int v190 = *((_DWORD *)v187 + 3);
                          if (v190 == 1 || HIDWORD(v257) != 1)
                          {
                            BOOL v192 = HIDWORD(v257) != 1 && v190 == 1;
                            if (v192 || *(_DWORD *)(v256 + 16 * v186 + 8) >= DWORD2(v257))
                            {
LABEL_348:
                              v187 = v184;
                              break;
                            }
                          }
                        }
                        else
                        {
                          unsigned int v194 = *((_DWORD *)sub_1CD4FD4E8(*a3, *v187, (uint64_t **)v187) + 10);
                          uint64_t result = sub_1CD4FD4E8(*a3, v189, (uint64_t **)&v257);
                          if (v194 >= *((_DWORD *)result + 10)) {
                            goto LABEL_348;
                          }
                        }
                        unint64_t *v184 = *v187;
                        v184[1] = *(void *)(v256 + 16 * v186 + 8);
                      }
                      while (v185 >= 2);
                    }
                    *(_OWORD *)v187 = v257;
                  }
                }
                else
                {
                  unsigned int v195 = *((_DWORD *)sub_1CD4FD4E8(*a3, *v187, (uint64_t **)v187) + 10);
                  uint64_t result = sub_1CD4FD4E8(*a3, *(void *)v197, (uint64_t **)v197);
                  if (v195 < *((_DWORD *)result + 10)) {
                    goto LABEL_387;
                  }
                }
              }
LABEL_389:
              a2 = v211;
              if (v13-- <= 2) {
                return result;
              }
              goto LABEL_351;
            }
          }
        }
      }
    }
    unint64_t v14 = (unint64_t)v13 >> 1;
    uint64_t v15 = (unint64_t *)(v11 + 16 * ((unint64_t)v13 >> 1));
    if ((unint64_t)v12 >= 0x801)
    {
      sub_1CD320E44(v11, v11 + 16 * ((unint64_t)v13 >> 1), (uint64_t)v253, a3);
      sub_1CD320E44(v11 + 16, (uint64_t)(v15 - 2), v249, a3);
      sub_1CD320E44(v11 + 32, v11 + 16 + 16 * v14, v248, a3);
      sub_1CD320E44((uint64_t)(v15 - 2), (uint64_t)v15, v11 + 16 + 16 * v14, a3);
      unint64_t v16 = *(void *)v11;
      unint64_t v17 = *(void *)(v11 + 8);
      unint64_t v18 = v15[1];
      *(void *)unint64_t v11 = *v15;
      *(void *)(v11 + 8) = v18;
      *uint64_t v15 = v16;
      v15[1] = v17;
    }
    else
    {
      sub_1CD320E44(v11 + 16 * ((unint64_t)v13 >> 1), v11, (uint64_t)v253, a3);
    }
    uint64_t v19 = a4 - 1;
    if (a5) {
      goto LABEL_11;
    }
    int v65 = *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)(v11 - 16), (uint64_t **)(v11 - 16)) + 10);
    if (v65 == *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)v11, (uint64_t **)v11) + 10))
    {
      int v66 = *(_DWORD *)(v11 - 4);
      int v67 = *(_DWORD *)(v11 + 12);
      if (v66 == 1 || v67 != 1)
      {
        BOOL v68 = v67 != 1 && v66 == 1;
        if (v68 || *(_DWORD *)(v11 - 8) >= *(_DWORD *)(v11 + 8)) {
          goto LABEL_112;
        }
      }
LABEL_11:
      uint64_t v251 = v19;
      uint64_t v20 = 0;
      long long v257 = *(_OWORD *)v11;
      unint64_t v21 = v257;
      unsigned int v22 = DWORD2(v257);
      int v23 = HIDWORD(v257);
      while (1)
      {
        int v24 = *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)(v11 + v20 + 16), (uint64_t **)(v11 + v20 + 16)) + 10);
        if (v24 == *((_DWORD *)sub_1CD4FD4E8(*a3, v21, (uint64_t **)&v257) + 10)) {
          break;
        }
        unsigned int v29 = *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)(v11 + v20 + 16), (uint64_t **)(v11 + v20 + 16)) + 10);
        if (v29 >= *((_DWORD *)sub_1CD4FD4E8(*a3, v21, (uint64_t **)&v257) + 10)) {
          goto LABEL_26;
        }
LABEL_24:
        v20 += 16;
      }
      int v25 = *(_DWORD *)(v11 + v20 + 28);
      if (v25 != 1 && v23 == 1) {
        goto LABEL_24;
      }
      BOOL v27 = v23 != 1 && v25 == 1;
      if (!v27 && *(_DWORD *)(v11 + v20 + 24) < v22) {
        goto LABEL_24;
      }
LABEL_26:
      unint64_t v30 = v11 + v20 + 16;
      int i = v253;
      if (v20)
      {
        while (1)
        {
          int v32 = *((_DWORD *)sub_1CD4FD4E8(*a3, *i, (uint64_t **)i) + 10);
          if (v32 == *((_DWORD *)sub_1CD4FD4E8(*a3, v21, (uint64_t **)&v257) + 10))
          {
            int v33 = *((_DWORD *)i + 3);
            BOOL v34 = v33 != 1 && v23 == 1;
            if (v34
              || (v23 != 1 ? (v35 = v33 == 1) : (v35 = 0), !v35 ? (BOOL v36 = *((_DWORD *)i + 2) >= v22) : (BOOL v36 = 1), !v36))
            {
LABEL_42:
              a2 = v255;
              goto LABEL_62;
            }
          }
          else
          {
            unsigned int v37 = *((_DWORD *)sub_1CD4FD4E8(*a3, *i, (uint64_t **)i) + 10);
            if (v37 < *((_DWORD *)sub_1CD4FD4E8(*a3, v21, (uint64_t **)&v257) + 10)) {
              goto LABEL_42;
            }
          }
          i -= 2;
        }
      }
      a2 = v255;
      int i = (unint64_t *)v255;
      if (v30 < v255)
      {
        for (int i = v253; ; i -= 2)
        {
          int v38 = *((_DWORD *)sub_1CD4FD4E8(*a3, *i, (uint64_t **)i) + 10);
          if (v38 == *((_DWORD *)sub_1CD4FD4E8(*a3, v21, (uint64_t **)&v257) + 10))
          {
            int v39 = *((_DWORD *)i + 3);
            if (v39 != 1 && v23 == 1) {
              break;
            }
            BOOL v42 = v23 != 1 && v39 == 1 || *((_DWORD *)i + 2) >= v22;
          }
          else
          {
            unsigned int v44 = *((_DWORD *)sub_1CD4FD4E8(*a3, *i, (uint64_t **)i) + 10);
            BOOL v42 = v44 >= *((_DWORD *)sub_1CD4FD4E8(*a3, v21, (uint64_t **)&v257) + 10);
          }
          if (!v42 || v30 >= (unint64_t)i) {
            break;
          }
        }
      }
LABEL_62:
      unint64_t j = v30;
      if (v30 < (unint64_t)i)
      {
        unint64_t v45 = (unint64_t)i;
        do
        {
          uint64_t v46 = *(uint64_t **)j;
          *(void *)unint64_t j = *(void *)v45;
          *(void *)unint64_t v45 = v46;
          uint64_t v47 = *(void *)(j + 8);
          *(void *)(j + 8) = *(void *)(v45 + 8);
          *(void *)(v45 + 8) = v47;
          unint64_t v21 = v257;
          unsigned int v48 = DWORD2(v257);
          int v49 = HIDWORD(v257);
          while (1)
          {
            while (1)
            {
              unint64_t v50 = *(void *)(j + 16);
              j += 16;
              int v51 = *((_DWORD *)sub_1CD4FD4E8(*a3, v50, (uint64_t **)j) + 10);
              if (v51 == *((_DWORD *)sub_1CD4FD4E8(*a3, v21, (uint64_t **)&v257) + 10)) {
                break;
              }
              unsigned int v56 = *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)j, (uint64_t **)j) + 10);
              if (v56 >= *((_DWORD *)sub_1CD4FD4E8(*a3, v21, (uint64_t **)&v257) + 10)) {
                goto LABEL_82;
              }
            }
            int v52 = *(_DWORD *)(j + 12);
            if (v52 == 1 || v49 != 1)
            {
              BOOL v54 = v49 != 1 && v52 == 1;
              if (v54 || *(_DWORD *)(j + 8) >= v48) {
                break;
              }
            }
          }
          do
          {
LABEL_82:
            while (1)
            {
              unint64_t v58 = *(void *)(v45 - 16);
              v45 -= 16;
              int v59 = *((_DWORD *)sub_1CD4FD4E8(*a3, v58, (uint64_t **)v45) + 10);
              if (v59 == *((_DWORD *)sub_1CD4FD4E8(*a3, v21, (uint64_t **)&v257) + 10)) {
                break;
              }
              unsigned int v57 = *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)v45, (uint64_t **)v45) + 10);
              if (v57 < *((_DWORD *)sub_1CD4FD4E8(*a3, v21, (uint64_t **)&v257) + 10)) {
                goto LABEL_94;
              }
            }
            int v60 = *(_DWORD *)(v45 + 12);
            if (v60 != 1 && v49 == 1) {
              break;
            }
            BOOL v62 = v49 != 1 && v60 == 1;
          }
          while (v62 || *(_DWORD *)(v45 + 8) >= v48);
LABEL_94:
          ;
        }
        while (j < v45);
      }
      if (j - 16 != v256)
      {
        *(void *)uint64_t v256 = *(void *)(j - 16);
        *(void *)(v256 + 8) = *(void *)(j - 8);
        unint64_t v21 = v257;
      }
      *(void *)(j - 16) = v21;
      *(void *)(j - 8) = *((void *)&v257 + 1);
      a4 = v251;
      if (v30 < (unint64_t)i)
      {
LABEL_100:
        uint64_t result = (uint64_t **)sub_1CD31F570(v256, j - 16, a3, v251, a5 & 1);
        a5 = 0;
      }
      else
      {
        BOOL v64 = sub_1CD321188(v256, j - 16, a3);
        uint64_t result = (uint64_t **)sub_1CD321188(j, a2, a3);
        if (result)
        {
          a2 = j - 16;
          if (v64) {
            return result;
          }
          goto LABEL_2;
        }
        if (!v64) {
          goto LABEL_100;
        }
      }
    }
    else
    {
      unsigned int v69 = *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)(v11 - 16), (uint64_t **)(v11 - 16)) + 10);
      if (v69 < *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)v11, (uint64_t **)v11) + 10)) {
        goto LABEL_11;
      }
LABEL_112:
      uint64_t v70 = v19;
      long long v257 = *(_OWORD *)v11;
      unint64_t v71 = v257;
      int v72 = *((_DWORD *)sub_1CD4FD4E8(*a3, v257, (uint64_t **)&v257) + 10);
      uint64_t result = sub_1CD4FD4E8(*a3, *v253, (uint64_t **)v253);
      if (v72 == *((_DWORD *)result + 10))
      {
        unint64_t v73 = v255;
        int v74 = *(_DWORD *)(v255 - 4);
        unsigned int v76 = DWORD2(v257);
        int v75 = HIDWORD(v257);
        if (HIDWORD(v257) != 1 && v74 == 1) {
          goto LABEL_121;
        }
        BOOL v77 = v74 != 1 && HIDWORD(v257) == 1;
        if (!v77 && DWORD2(v257) < *(_DWORD *)(v255 - 8)) {
          goto LABEL_121;
        }
      }
      else
      {
        unsigned int v83 = *((_DWORD *)sub_1CD4FD4E8(*a3, v71, (uint64_t **)&v257) + 10);
        uint64_t result = sub_1CD4FD4E8(*a3, *v253, (uint64_t **)v253);
        unint64_t v73 = v255;
        if (v83 < *((_DWORD *)result + 10))
        {
          unsigned int v76 = DWORD2(v257);
          int v75 = HIDWORD(v257);
LABEL_121:
          for (unint64_t j = v11 + 16; ; j += 16)
          {
            int v78 = *((_DWORD *)sub_1CD4FD4E8(*a3, v71, (uint64_t **)&v257) + 10);
            uint64_t result = sub_1CD4FD4E8(*a3, *(void *)j, (uint64_t **)j);
            if (v78 == *((_DWORD *)result + 10))
            {
              int v79 = *(_DWORD *)(j + 12);
              if (v75 != 1 && v79 == 1) {
                goto LABEL_155;
              }
              BOOL v80 = v79 != 1 && v75 == 1;
              if (!v80 && v76 < *(_DWORD *)(j + 8)) {
                goto LABEL_155;
              }
            }
            else
            {
              unsigned int v82 = *((_DWORD *)sub_1CD4FD4E8(*a3, v71, (uint64_t **)&v257) + 10);
              uint64_t result = sub_1CD4FD4E8(*a3, *(void *)j, (uint64_t **)j);
              if (v82 < *((_DWORD *)result + 10)) {
                goto LABEL_155;
              }
            }
          }
        }
      }
      unint64_t j = v11 + 16;
      if (v11 + 16 >= v73) {
        goto LABEL_155;
      }
      unsigned int v85 = DWORD2(v257);
      int v84 = HIDWORD(v257);
      while (1)
      {
        int v86 = *((_DWORD *)sub_1CD4FD4E8(*a3, v71, (uint64_t **)&v257) + 10);
        uint64_t result = sub_1CD4FD4E8(*a3, *(void *)j, (uint64_t **)j);
        if (v86 == *((_DWORD *)result + 10)) {
          break;
        }
        unsigned int v90 = *((_DWORD *)sub_1CD4FD4E8(*a3, v71, (uint64_t **)&v257) + 10);
        uint64_t result = sub_1CD4FD4E8(*a3, *(void *)j, (uint64_t **)j);
        if (v90 < *((_DWORD *)result + 10)) {
          goto LABEL_154;
        }
LABEL_151:
        j += 16;
        unint64_t v11 = v256;
        if (j >= v255) {
          goto LABEL_155;
        }
      }
      int v87 = *(_DWORD *)(j + 12);
      if (v84 == 1 || v87 != 1)
      {
        BOOL v88 = v87 != 1 && v84 == 1;
        if (v88 || v85 >= *(_DWORD *)(j + 8)) {
          goto LABEL_151;
        }
      }
LABEL_154:
      unint64_t v11 = v256;
LABEL_155:
      a2 = v255;
      long long v91 = (unint64_t *)v255;
      if (j >= v255) {
        goto LABEL_170;
      }
      unsigned int v93 = DWORD2(v257);
      int v92 = HIDWORD(v257);
      long long v91 = v253;
      while (2)
      {
        int v94 = *((_DWORD *)sub_1CD4FD4E8(*a3, v71, (uint64_t **)&v257) + 10);
        uint64_t result = sub_1CD4FD4E8(*a3, *v91, (uint64_t **)v91);
        if (v94 != *((_DWORD *)result + 10))
        {
          unsigned int v98 = *((_DWORD *)sub_1CD4FD4E8(*a3, v71, (uint64_t **)&v257) + 10);
          uint64_t result = sub_1CD4FD4E8(*a3, *v91, (uint64_t **)v91);
          if (v98 >= *((_DWORD *)result + 10)) {
            break;
          }
          goto LABEL_167;
        }
        int v95 = *((_DWORD *)v91 + 3);
        if (v92 != 1 && v95 == 1
          || (v95 != 1 ? (BOOL v96 = v92 == 1) : (BOOL v96 = 0), !v96 ? (v97 = v93 >= *((_DWORD *)v91 + 2)) : (v97 = 1), !v97))
        {
LABEL_167:
          v91 -= 2;
          continue;
        }
        break;
      }
      a2 = v255;
LABEL_170:
      a4 = v70;
      while (j < (unint64_t)v91)
      {
        long long v99 = *(uint64_t **)j;
        *(void *)unint64_t j = *v91;
        *long long v91 = (unint64_t)v99;
        unint64_t v100 = *(void *)(j + 8);
        *(void *)(j + 8) = v91[1];
        v91[1] = v100;
        unint64_t v71 = v257;
        unsigned int v102 = DWORD2(v257);
        int v101 = HIDWORD(v257);
        do
        {
          while (1)
          {
            int v103 = *((_DWORD *)sub_1CD4FD4E8(*a3, v71, (uint64_t **)&v257) + 10);
            unint64_t v104 = *(void *)(j + 16);
            j += 16;
            if (v103 == *((_DWORD *)sub_1CD4FD4E8(*a3, v104, (uint64_t **)j) + 10)) {
              break;
            }
            unsigned int v108 = *((_DWORD *)sub_1CD4FD4E8(*a3, v71, (uint64_t **)&v257) + 10);
            if (v108 < *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)j, (uint64_t **)j) + 10)) {
              goto LABEL_186;
            }
          }
          int v105 = *(_DWORD *)(j + 12);
          if (v101 != 1 && v105 == 1) {
            break;
          }
          BOOL v106 = v105 != 1 && v101 == 1;
        }
        while (v106 || v102 >= *(_DWORD *)(j + 8));
        while (1)
        {
LABEL_186:
          while (1)
          {
            int v110 = *((_DWORD *)sub_1CD4FD4E8(*a3, v71, (uint64_t **)&v257) + 10);
            unint64_t v111 = *(v91 - 2);
            v91 -= 2;
            uint64_t result = sub_1CD4FD4E8(*a3, v111, (uint64_t **)v91);
            if (v110 == *((_DWORD *)result + 10)) {
              break;
            }
            unsigned int v109 = *((_DWORD *)sub_1CD4FD4E8(*a3, v71, (uint64_t **)&v257) + 10);
            uint64_t result = sub_1CD4FD4E8(*a3, *v91, (uint64_t **)v91);
            if (v109 >= *((_DWORD *)result + 10)) {
              goto LABEL_197;
            }
          }
          int v112 = *((_DWORD *)v91 + 3);
          if (v101 == 1 || v112 != 1)
          {
            BOOL v113 = v112 != 1 && v101 == 1;
            if (v113 || v102 >= *((_DWORD *)v91 + 2)) {
              break;
            }
          }
        }
LABEL_197:
        ;
      }
      BOOL v5 = j - 16 >= v11;
      BOOL v6 = j - 16 == v11;
      if (j - 16 != v11)
      {
        *(void *)unint64_t v11 = *(void *)(j - 16);
        *(void *)(v11 + 8) = *(void *)(j - 8);
        unint64_t v71 = v257;
      }
      a5 = 0;
      *(void *)(j - 16) = v71;
      *(void *)(j - 8) = *((void *)&v257 + 1);
    }
  }
  if ((a5 & 1) == 0)
  {
    if (v11 == a2) {
      return result;
    }
    uint64_t v221 = v11 + 16;
    if (v11 + 16 == a2) {
      return result;
    }
    for (k = (uint64_t **)(v11 + 24); ; k += 2)
    {
      int v223 = *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)(v256 + 16), (uint64_t **)v221) + 10);
      uint64_t result = sub_1CD4FD4E8(*a3, *(void *)v256, (uint64_t **)v256);
      if (v223 == *((_DWORD *)result + 10))
      {
        int v224 = *(_DWORD *)(v221 + 12);
        int v225 = *(_DWORD *)(v256 + 12);
        if (v224 == 1 || v225 != 1)
        {
          BOOL v227 = v225 != 1 && v224 == 1;
          if (v227 || *(_DWORD *)(v221 + 8) >= *(_DWORD *)(v256 + 8)) {
            goto LABEL_421;
          }
        }
      }
      else
      {
        unsigned int v236 = *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)v221, (uint64_t **)v221) + 10);
        uint64_t result = sub_1CD4FD4E8(*a3, *(void *)v256, (uint64_t **)v256);
        if (v236 >= *((_DWORD *)result + 10)) {
          goto LABEL_421;
        }
      }
      long long v257 = *(_OWORD *)v221;
      for (m = k; ; m -= 2)
      {
        v230 = *(m - 2);
        *(m - 1) = *(m - 3);
        *m = v230;
        unint64_t v231 = v257;
        int v232 = *((_DWORD *)sub_1CD4FD4E8(*a3, v257, (uint64_t **)&v257) + 10);
        uint64_t result = sub_1CD4FD4E8(*a3, (unint64_t)*(m - 5), m - 5);
        if (v232 == *((_DWORD *)result + 10)) {
          break;
        }
        unsigned int v235 = *((_DWORD *)sub_1CD4FD4E8(*a3, v231, (uint64_t **)&v257) + 10);
        uint64_t result = sub_1CD4FD4E8(*a3, (unint64_t)*(m - 5), m - 5);
        if (v235 >= *((_DWORD *)result + 10)) {
          goto LABEL_420;
        }
LABEL_418:
        ;
      }
      int v233 = *((_DWORD *)m - 7);
      if (HIDWORD(v257) != 1 && v233 == 1) {
        goto LABEL_418;
      }
      BOOL v234 = v233 != 1 && HIDWORD(v257) == 1;
      if (!v234 && DWORD2(v257) < *((_DWORD *)m - 8)) {
        goto LABEL_418;
      }
LABEL_420:
      *(m - 3) = (uint64_t *)v231;
      *(m - 2) = (uint64_t *)*((void *)&v257 + 1);
LABEL_421:
      uint64_t v256 = v221;
      v221 += 16;
      if (v221 == v255) {
        return result;
      }
    }
  }
  if (v11 == a2) {
    return result;
  }
  v115 = (uint64_t **)(v11 + 16);
  if (v11 + 16 == a2) {
    return result;
  }
  uint64_t v116 = 0;
  unint64_t v117 = v11;
  while (2)
  {
    unint64_t v118 = v117;
    unint64_t v117 = (unint64_t)v115;
    int v119 = *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)(v118 + 16), v115) + 10);
    uint64_t result = sub_1CD4FD4E8(*a3, *(void *)v118, (uint64_t **)v118);
    if (v119 == *((_DWORD *)result + 10))
    {
      int v120 = *(_DWORD *)(v117 + 12);
      int v121 = *(_DWORD *)(v118 + 12);
      BOOL v122 = v120 != 1 && v121 == 1;
      unint64_t v123 = v255;
      v124 = (_OWORD *)v256;
      if (!v122)
      {
        BOOL v125 = v121 != 1 && v120 == 1;
        if (v125 || *(_DWORD *)(v117 + 8) >= *(_DWORD *)(v118 + 8)) {
          goto LABEL_249;
        }
      }
    }
    else
    {
      unsigned int v141 = *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)v117, (uint64_t **)v117) + 10);
      uint64_t result = sub_1CD4FD4E8(*a3, *(void *)v118, (uint64_t **)v118);
      unint64_t v123 = v255;
      v124 = (_OWORD *)v256;
      if (v141 >= *((_DWORD *)result + 10)) {
        goto LABEL_249;
      }
    }
    long long v257 = *(_OWORD *)v117;
    uint64_t v127 = *(void *)(v118 + 8);
    *(void *)(v118 + 16) = *(void *)v118;
    *(void *)(v117 + 8) = v127;
    v128 = v124;
    if ((_OWORD *)v118 == v124) {
      goto LABEL_248;
    }
    uint64_t v129 = v116;
    while (2)
    {
      v130 = (char *)v124 + v129;
      unint64_t v131 = v257;
      v132 = (unint64_t *)(v130 - 16);
      int v133 = *((_DWORD *)sub_1CD4FD4E8(*a3, v257, (uint64_t **)&v257) + 10);
      uint64_t result = sub_1CD4FD4E8(*a3, *((void *)v130 - 2), (uint64_t **)v130 - 2);
      if (v133 != *((_DWORD *)result + 10))
      {
        unsigned int v140 = *((_DWORD *)sub_1CD4FD4E8(*a3, v131, (uint64_t **)&v257) + 10);
        uint64_t result = sub_1CD4FD4E8(*a3, *v132, (uint64_t **)v130 - 2);
        v124 = (_OWORD *)v256;
        if (v140 >= *((_DWORD *)result + 10))
        {
          v128 = (_OWORD *)(v256 + v129);
          goto LABEL_247;
        }
        goto LABEL_243;
      }
      int v134 = *((_DWORD *)v130 - 1);
      BOOL v135 = HIDWORD(v257) != 1 && v134 == 1;
      v124 = (_OWORD *)v256;
      if (v135
        || (v134 != 1 ? (BOOL v136 = HIDWORD(v257) == 1) : (BOOL v136 = 0),
            !v136 ? (BOOL v137 = DWORD2(v257) >= *(_DWORD *)(v256 + v129 - 8)) : (BOOL v137 = 1),
            !v137))
      {
LABEL_243:
        v118 -= 16;
        v138 = (unint64_t *)((char *)v124 + v129);
        unint64_t v139 = *(void *)((char *)v124 + v129 - 8);
        unint64_t *v138 = *v132;
        v138[1] = v139;
        v129 -= 16;
        if (!v129)
        {
          v128 = v124;
          goto LABEL_247;
        }
        continue;
      }
      break;
    }
    v128 = (_OWORD *)v118;
LABEL_247:
    unint64_t v123 = v255;
LABEL_248:
    _OWORD *v128 = v257;
LABEL_249:
    v115 = (uint64_t **)(v117 + 16);
    v116 += 16;
    if (v117 + 16 != v123) {
      continue;
    }
    return result;
  }
}

uint64_t **sub_1CD320B18(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t ***a6)
{
  sub_1CD321548(a1, a2, a3, a4, a6);
  int v12 = *((_DWORD *)sub_1CD4FD4E8(*a6, *(void *)a5, (uint64_t **)a5) + 10);
  uint64_t result = sub_1CD4FD4E8(*a6, *(void *)a4, (uint64_t **)a4);
  if (v12 == *((_DWORD *)result + 10))
  {
    int v14 = *(_DWORD *)(a5 + 12);
    int v15 = *(_DWORD *)(a4 + 12);
    if (v14 == 1 || v15 != 1)
    {
      BOOL v17 = v15 != 1 && v14 == 1;
      if (v17 || *(_DWORD *)(a5 + 8) >= *(_DWORD *)(a4 + 8)) {
        return result;
      }
    }
  }
  else
  {
    unsigned int v19 = *((_DWORD *)sub_1CD4FD4E8(*a6, *(void *)a5, (uint64_t **)a5) + 10);
    uint64_t result = sub_1CD4FD4E8(*a6, *(void *)a4, (uint64_t **)a4);
    if (v19 >= *((_DWORD *)result + 10)) {
      return result;
    }
  }
  unint64_t v20 = *(void *)a4;
  *(void *)a4 = *(void *)a5;
  *(void *)a5 = v20;
  uint64_t v21 = *(void *)(a4 + 8);
  *(void *)(a4 + 8) = *(void *)(a5 + 8);
  *(void *)(a5 + 8) = v21;
  int v22 = *((_DWORD *)sub_1CD4FD4E8(*a6, *(void *)a4, (uint64_t **)a4) + 10);
  uint64_t result = sub_1CD4FD4E8(*a6, *(void *)a3, (uint64_t **)a3);
  if (v22 == *((_DWORD *)result + 10))
  {
    int v23 = *(_DWORD *)(a4 + 12);
    int v24 = *(_DWORD *)(a3 + 12);
    if (v23 == 1 || v24 != 1)
    {
      BOOL v25 = v24 != 1 && v23 == 1;
      if (v25 || *(_DWORD *)(a4 + 8) >= *(_DWORD *)(a3 + 8)) {
        return result;
      }
    }
  }
  else
  {
    unsigned int v40 = *((_DWORD *)sub_1CD4FD4E8(*a6, *(void *)a4, (uint64_t **)a4) + 10);
    uint64_t result = sub_1CD4FD4E8(*a6, *(void *)a3, (uint64_t **)a3);
    if (v40 >= *((_DWORD *)result + 10)) {
      return result;
    }
  }
  unint64_t v26 = *(void *)a3;
  *(void *)a3 = *(void *)a4;
  *(void *)a4 = v26;
  uint64_t v27 = *(void *)(a3 + 8);
  *(void *)(a3 + 8) = *(void *)(a4 + 8);
  *(void *)(a4 + 8) = v27;
  int v28 = *((_DWORD *)sub_1CD4FD4E8(*a6, *(void *)a3, (uint64_t **)a3) + 10);
  uint64_t result = sub_1CD4FD4E8(*a6, *(void *)a2, (uint64_t **)a2);
  if (v28 == *((_DWORD *)result + 10))
  {
    int v29 = *(_DWORD *)(a3 + 12);
    int v30 = *(_DWORD *)(a2 + 12);
    if (v29 == 1 || v30 != 1)
    {
      BOOL v31 = v30 != 1 && v29 == 1;
      if (v31 || *(_DWORD *)(a3 + 8) >= *(_DWORD *)(a2 + 8)) {
        return result;
      }
    }
  }
  else
  {
    unsigned int v41 = *((_DWORD *)sub_1CD4FD4E8(*a6, *(void *)a3, (uint64_t **)a3) + 10);
    uint64_t result = sub_1CD4FD4E8(*a6, *(void *)a2, (uint64_t **)a2);
    if (v41 >= *((_DWORD *)result + 10)) {
      return result;
    }
  }
  unint64_t v32 = *(void *)a2;
  *(void *)a2 = *(void *)a3;
  *(void *)a3 = v32;
  uint64_t v33 = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = *(void *)(a3 + 8);
  *(void *)(a3 + 8) = v33;
  int v34 = *((_DWORD *)sub_1CD4FD4E8(*a6, *(void *)a2, (uint64_t **)a2) + 10);
  uint64_t result = sub_1CD4FD4E8(*a6, *(void *)a1, (uint64_t **)a1);
  if (v34 == *((_DWORD *)result + 10))
  {
    int v35 = *(_DWORD *)(a2 + 12);
    int v36 = *(_DWORD *)(a1 + 12);
    if (v35 != 1 && v36 == 1) {
      goto LABEL_40;
    }
    BOOL v37 = v36 != 1 && v35 == 1;
    if (!v37 && *(_DWORD *)(a2 + 8) < *(_DWORD *)(a1 + 8)) {
      goto LABEL_40;
    }
  }
  else
  {
    unsigned int v42 = *((_DWORD *)sub_1CD4FD4E8(*a6, *(void *)a2, (uint64_t **)a2) + 10);
    uint64_t result = sub_1CD4FD4E8(*a6, *(void *)a1, (uint64_t **)a1);
    if (v42 < *((_DWORD *)result + 10))
    {
LABEL_40:
      unint64_t v38 = *(void *)a1;
      *(void *)a1 = *(void *)a2;
      *(void *)a2 = v38;
      uint64_t v39 = *(void *)(a1 + 8);
      *(void *)(a1 + 8) = *(void *)(a2 + 8);
      *(void *)(a2 + 8) = v39;
    }
  }
  return result;
}

uint64_t **sub_1CD320E44(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t ***a4)
{
  int v8 = *((_DWORD *)sub_1CD4FD4E8(*a4, *(void *)a2, (uint64_t **)a2) + 10);
  if (v8 == *((_DWORD *)sub_1CD4FD4E8(*a4, *(void *)a1, (uint64_t **)a1) + 10))
  {
    int v9 = *(_DWORD *)(a2 + 12);
    int v10 = *(_DWORD *)(a1 + 12);
    if (v9 != 1 && v10 == 1)
    {
      int v15 = 1;
      goto LABEL_17;
    }
    BOOL v13 = v9 == 1 && v10 != 1 || *(_DWORD *)(a2 + 8) >= *(_DWORD *)(a1 + 8);
  }
  else
  {
    unsigned int v14 = *((_DWORD *)sub_1CD4FD4E8(*a4, *(void *)a2, (uint64_t **)a2) + 10);
    BOOL v13 = v14 >= *((_DWORD *)sub_1CD4FD4E8(*a4, *(void *)a1, (uint64_t **)a1) + 10);
  }
  int v15 = !v13;
LABEL_17:
  int v16 = *((_DWORD *)sub_1CD4FD4E8(*a4, *(void *)a3, (uint64_t **)a3) + 10);
  uint64_t result = sub_1CD4FD4E8(*a4, *(void *)a2, (uint64_t **)a2);
  if (v16 == *((_DWORD *)result + 10))
  {
    int v18 = *(_DWORD *)(a3 + 12);
    int v19 = *(_DWORD *)(a2 + 12);
    if (v18 != 1 && v19 == 1)
    {
      if (v15)
      {
        uint64_t v21 = (uint64_t *)(a1 + 8);
        unint64_t v20 = *(void *)a1;
LABEL_33:
        *(void *)a1 = *(void *)a3;
LABEL_34:
        *(void *)a3 = v20;
        BOOL v25 = (uint64_t *)(a3 + 8);
LABEL_35:
        uint64_t v26 = *v21;
        uint64_t *v21 = *v25;
        *BOOL v25 = v26;
        return result;
      }
      goto LABEL_39;
    }
    BOOL v23 = v18 == 1 && v19 != 1 || *(_DWORD *)(a3 + 8) >= *(_DWORD *)(a2 + 8);
  }
  else
  {
    unsigned int v27 = *((_DWORD *)sub_1CD4FD4E8(*a4, *(void *)a3, (uint64_t **)a3) + 10);
    uint64_t result = sub_1CD4FD4E8(*a4, *(void *)a2, (uint64_t **)a2);
    BOOL v23 = v27 >= *((_DWORD *)result + 10);
  }
  int v24 = !v23;
  if (v15)
  {
    uint64_t v21 = (uint64_t *)(a1 + 8);
    unint64_t v20 = *(void *)a1;
    if (v24) {
      goto LABEL_33;
    }
    *(void *)a1 = *(void *)a2;
    uint64_t v21 = (uint64_t *)(a2 + 8);
    uint64_t v35 = *(void *)(a2 + 8);
    *(void *)a2 = v20;
    uint64_t v36 = *(void *)(a1 + 8);
    *(void *)(a1 + 8) = v35;
    *(void *)(a2 + 8) = v36;
    int v37 = *((_DWORD *)sub_1CD4FD4E8(*a4, *(void *)a3, (uint64_t **)a3) + 10);
    uint64_t result = sub_1CD4FD4E8(*a4, *(void *)a2, (uint64_t **)a2);
    if (v37 == *((_DWORD *)result + 10))
    {
      int v38 = *(_DWORD *)(a3 + 12);
      int v39 = *(_DWORD *)(a2 + 12);
      if (v38 == 1 || v39 != 1)
      {
        BOOL v40 = v39 != 1 && v38 == 1;
        if (v40 || *(_DWORD *)(a3 + 8) >= *(_DWORD *)v21) {
          return result;
        }
      }
    }
    else
    {
      unsigned int v42 = *((_DWORD *)sub_1CD4FD4E8(*a4, *(void *)a3, (uint64_t **)a3) + 10);
      uint64_t result = sub_1CD4FD4E8(*a4, *(void *)a2, (uint64_t **)a2);
      if (v42 >= *((_DWORD *)result + 10)) {
        return result;
      }
    }
    unint64_t v20 = *(void *)a2;
    *(void *)a2 = *(void *)a3;
    goto LABEL_34;
  }
  if (!v24) {
    return result;
  }
LABEL_39:
  unint64_t v28 = *(void *)a2;
  *(void *)a2 = *(void *)a3;
  *(void *)a3 = v28;
  BOOL v25 = (uint64_t *)(a2 + 8);
  uint64_t v29 = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = *(void *)(a3 + 8);
  *(void *)(a3 + 8) = v29;
  int v30 = *((_DWORD *)sub_1CD4FD4E8(*a4, *(void *)a2, (uint64_t **)a2) + 10);
  uint64_t result = sub_1CD4FD4E8(*a4, *(void *)a1, (uint64_t **)a1);
  if (v30 == *((_DWORD *)result + 10))
  {
    int v31 = *(_DWORD *)(a2 + 12);
    int v32 = *(_DWORD *)(a1 + 12);
    if (v31 != 1 && v32 == 1) {
      goto LABEL_47;
    }
    BOOL v33 = v32 != 1 && v31 == 1;
    if (!v33 && *(_DWORD *)v25 < *(_DWORD *)(a1 + 8)) {
      goto LABEL_47;
    }
  }
  else
  {
    unsigned int v41 = *((_DWORD *)sub_1CD4FD4E8(*a4, *(void *)a2, (uint64_t **)a2) + 10);
    uint64_t result = sub_1CD4FD4E8(*a4, *(void *)a1, (uint64_t **)a1);
    if (v41 < *((_DWORD *)result + 10))
    {
LABEL_47:
      unint64_t v34 = *(void *)a1;
      *(void *)a1 = *(void *)a2;
      *(void *)a2 = v34;
      uint64_t v21 = (uint64_t *)(a1 + 8);
      goto LABEL_35;
    }
  }
  return result;
}

BOOL sub_1CD321188(uint64_t a1, uint64_t a2, uint64_t ***a3)
{
  uint64_t v6 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unint64_t v28 = (unint64_t *)(a2 - 16);
      int v29 = *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)(a2 - 16), (uint64_t **)(a2 - 16)) + 10);
      if (v29 == *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)a1, (uint64_t **)a1) + 10))
      {
        int v30 = *(_DWORD *)(a2 - 4);
        int v31 = *(_DWORD *)(a1 + 12);
        if (v30 != 1 && v31 == 1) {
          goto LABEL_58;
        }
        BOOL v33 = v31 != 1 && v30 == 1;
        if (!v33 && *(_DWORD *)(a2 - 8) < *(_DWORD *)(a1 + 8)) {
          goto LABEL_58;
        }
      }
      else
      {
        unsigned int v37 = *((_DWORD *)sub_1CD4FD4E8(*a3, *v28, (uint64_t **)(a2 - 16)) + 10);
        if (v37 < *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)a1, (uint64_t **)a1) + 10))
        {
LABEL_58:
          unint64_t v35 = *(void *)a1;
          *(void *)a1 = *(void *)(a2 - 16);
          *(void *)(a2 - 16) = v35;
          uint64_t v36 = *(void *)(a1 + 8);
          *(void *)(a1 + 8) = *(void *)(a2 - 8);
          *(void *)(a2 - 8) = v36;
        }
      }
      return 1;
    case 3:
      sub_1CD320E44(a1, a1 + 16, a2 - 16, a3);
      return 1;
    case 4:
      sub_1CD321548(a1, a1 + 16, a1 + 32, a2 - 16, a3);
      return 1;
    case 5:
      sub_1CD320B18(a1, a1 + 16, a1 + 32, a1 + 48, a2 - 16, a3);
      return 1;
    default:
      uint64_t v8 = a1 + 32;
      sub_1CD320E44(a1, a1 + 16, a1 + 32, a3);
      uint64_t v9 = a1 + 48;
      if (a1 + 48 == a2) {
        return 1;
      }
      uint64_t v10 = 0;
      int v11 = 0;
      break;
  }
  do
  {
    int v12 = *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)v9, (uint64_t **)v9) + 10);
    if (v12 == *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)v8, (uint64_t **)v8) + 10))
    {
      int v13 = *(_DWORD *)(v9 + 12);
      int v14 = *(_DWORD *)(v8 + 12);
      if (v13 == 1 || v14 != 1)
      {
        BOOL v16 = v14 != 1 && v13 == 1;
        if (v16 || *(_DWORD *)(v9 + 8) >= *(_DWORD *)(v8 + 8)) {
          goto LABEL_37;
        }
      }
    }
    else
    {
      unsigned int v27 = *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)v9, (uint64_t **)v9) + 10);
      if (v27 >= *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)v8, (uint64_t **)v8) + 10)) {
        goto LABEL_37;
      }
    }
    long long v40 = *(_OWORD *)v9;
    *(void *)uint64_t v9 = *(void *)v8;
    *(void *)(v9 + 8) = *(void *)(v8 + 8);
    int v18 = (_OWORD *)a1;
    if (v8 == a1) {
      goto LABEL_36;
    }
    int v38 = v11;
    uint64_t v39 = v10;
    while (1)
    {
      uint64_t v19 = a1 + v10;
      unint64_t v20 = v40;
      int v21 = *((_DWORD *)sub_1CD4FD4E8(*a3, v40, (uint64_t **)&v40) + 10);
      if (v21 == *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)(v19 + 16), (uint64_t **)(v19 + 16)) + 10)) {
        break;
      }
      unsigned int v26 = *((_DWORD *)sub_1CD4FD4E8(*a3, v20, (uint64_t **)&v40) + 10);
      if (v26 >= *((_DWORD *)sub_1CD4FD4E8(*a3, *(void *)(v19 + 16), (uint64_t **)(v19 + 16)) + 10))
      {
        int v18 = (_OWORD *)(a1 + v10 + 32);
        goto LABEL_35;
      }
LABEL_31:
      v8 -= 16;
      *(void *)(v19 + 32) = *(void *)(v19 + 16);
      *(void *)(a1 + v10 + 40) = *(void *)(a1 + v10 + 24);
      v10 -= 16;
      if (v10 == -32)
      {
        int v18 = (_OWORD *)a1;
        goto LABEL_35;
      }
    }
    int v22 = *(_DWORD *)(v19 + 28);
    if (HIDWORD(v40) != 1 && v22 == 1) {
      goto LABEL_31;
    }
    BOOL v24 = v22 != 1 && HIDWORD(v40) == 1;
    if (!v24 && DWORD2(v40) < *(_DWORD *)(a1 + v10 + 24)) {
      goto LABEL_31;
    }
    int v18 = (_OWORD *)v8;
LABEL_35:
    uint64_t v10 = v39;
    int v11 = v38;
LABEL_36:
    *int v18 = v40;
    if (++v11 == 8) {
      return v9 + 16 == a2;
    }
LABEL_37:
    uint64_t v8 = v9;
    v10 += 16;
    BOOL result = 1;
    v9 += 16;
  }
  while (v9 != a2);
  return result;
}

uint64_t **sub_1CD321548(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t ***a5)
{
  sub_1CD320E44(a1, a2, a3, a5);
  int v10 = *((_DWORD *)sub_1CD4FD4E8(*a5, *(void *)a4, (uint64_t **)a4) + 10);
  BOOL result = sub_1CD4FD4E8(*a5, *(void *)a3, (uint64_t **)a3);
  if (v10 == *((_DWORD *)result + 10))
  {
    int v12 = *(_DWORD *)(a4 + 12);
    int v13 = *(_DWORD *)(a3 + 12);
    if (v12 == 1 || v13 != 1)
    {
      BOOL v15 = v13 != 1 && v12 == 1;
      if (v15 || *(_DWORD *)(a4 + 8) >= *(_DWORD *)(a3 + 8)) {
        return result;
      }
    }
  }
  else
  {
    unsigned int v17 = *((_DWORD *)sub_1CD4FD4E8(*a5, *(void *)a4, (uint64_t **)a4) + 10);
    BOOL result = sub_1CD4FD4E8(*a5, *(void *)a3, (uint64_t **)a3);
    if (v17 >= *((_DWORD *)result + 10)) {
      return result;
    }
  }
  unint64_t v18 = *(void *)a3;
  *(void *)a3 = *(void *)a4;
  *(void *)a4 = v18;
  uint64_t v19 = *(void *)(a3 + 8);
  *(void *)(a3 + 8) = *(void *)(a4 + 8);
  *(void *)(a4 + 8) = v19;
  int v20 = *((_DWORD *)sub_1CD4FD4E8(*a5, *(void *)a3, (uint64_t **)a3) + 10);
  BOOL result = sub_1CD4FD4E8(*a5, *(void *)a2, (uint64_t **)a2);
  if (v20 == *((_DWORD *)result + 10))
  {
    int v21 = *(_DWORD *)(a3 + 12);
    int v22 = *(_DWORD *)(a2 + 12);
    if (v21 == 1 || v22 != 1)
    {
      BOOL v23 = v22 != 1 && v21 == 1;
      if (v23 || *(_DWORD *)(a3 + 8) >= *(_DWORD *)(a2 + 8)) {
        return result;
      }
    }
  }
  else
  {
    unsigned int v32 = *((_DWORD *)sub_1CD4FD4E8(*a5, *(void *)a3, (uint64_t **)a3) + 10);
    BOOL result = sub_1CD4FD4E8(*a5, *(void *)a2, (uint64_t **)a2);
    if (v32 >= *((_DWORD *)result + 10)) {
      return result;
    }
  }
  unint64_t v24 = *(void *)a2;
  *(void *)a2 = *(void *)a3;
  *(void *)a3 = v24;
  uint64_t v25 = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = *(void *)(a3 + 8);
  *(void *)(a3 + 8) = v25;
  int v26 = *((_DWORD *)sub_1CD4FD4E8(*a5, *(void *)a2, (uint64_t **)a2) + 10);
  BOOL result = sub_1CD4FD4E8(*a5, *(void *)a1, (uint64_t **)a1);
  if (v26 == *((_DWORD *)result + 10))
  {
    int v27 = *(_DWORD *)(a2 + 12);
    int v28 = *(_DWORD *)(a1 + 12);
    if (v27 != 1 && v28 == 1) {
      goto LABEL_32;
    }
    BOOL v29 = v28 != 1 && v27 == 1;
    if (!v29 && *(_DWORD *)(a2 + 8) < *(_DWORD *)(a1 + 8)) {
      goto LABEL_32;
    }
  }
  else
  {
    unsigned int v33 = *((_DWORD *)sub_1CD4FD4E8(*a5, *(void *)a2, (uint64_t **)a2) + 10);
    BOOL result = sub_1CD4FD4E8(*a5, *(void *)a1, (uint64_t **)a1);
    if (v33 < *((_DWORD *)result + 10))
    {
LABEL_32:
      unint64_t v30 = *(void *)a1;
      *(void *)a1 = *(void *)a2;
      *(void *)a2 = v30;
      uint64_t v31 = *(void *)(a1 + 8);
      *(void *)(a1 + 8) = *(void *)(a2 + 8);
      *(void *)(a2 + 8) = v31;
    }
  }
  return result;
}

void sub_1CD3217B4()
{
}

__n128 sub_1CD3217C8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F264B568;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1CD321814(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F264B568;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1CD321844(uint64_t a1, unint64_t *a2)
{
  unint64_t v2 = *a2;
  if (HIDWORD(*a2) != 1 && *a2 == 1) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 8);
  int v7 = sub_1CD8CE880(*(void *)(v6 + 24), **(void **)(a1 + 16), v2);
  if (v7 == 3) {
    return 1;
  }
  int v8 = v7;
  if (sub_1CD8CD258(*(void *)(v6 + 24), **(void **)(a1 + 16), v2)) {
    return 0;
  }
  BOOL v9 = !sub_1CD30BE30(*(void *)(v6 + 24), **(void **)(a1 + 16), v2);
  return v8 != 5 && v9;
}

void sub_1CD3218F0()
{
}

__n128 sub_1CD321904(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)unint64_t v2 = &unk_1F264B5B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1CD321950(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F264B5B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1CD321980(uint64_t a1, llvm::Type **a2, uint64_t a3, llvm::DominatorTree *a4)
{
  return llvm::LoopVectorizationCostModel::isScalarWithPredication(*(void *)(*(void *)(a1 + 8) + 24), *(void *)(a1 + 16), *a2, a4);
}

void sub_1CD321994()
{
}

__n128 sub_1CD3219A8(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)unint64_t v2 = &unk_1F264B5F8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1CD3219F4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F264B5F8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1CD321A24(uint64_t a1, llvm::Type **a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 16);
  unsigned int v5 = llvm::getVectorIntrinsicIDForCall(**(void **)(a1 + 8), *(uint64_t **)(v4 + 8));
  char v13 = 0;
  uint64_t v6 = llvm::LoopVectorizationCostModel::getVectorCallCost(*(void *)(v4 + 24), **(void **)(a1 + 8), (unint64_t)v3, &v13);
  int v8 = v7;
  if (v5)
  {
    uint64_t VectorIntrinsicCost = llvm::LoopVectorizationCostModel::getVectorIntrinsicCost(*(void *)(v4 + 24), **(void **)(a1 + 8), v3);
  }
  else
  {
    int v10 = 0;
    uint64_t VectorIntrinsicCost = 0;
  }
  BOOL v11 = v6 >= VectorIntrinsicCost;
  if (v10 != v8) {
    BOOL v11 = v10 <= v8;
  }
  if (!v5) {
    BOOL v11 = 0;
  }
  return !v13 || v11;
}

void sub_1CD321AE8()
{
}

__n128 sub_1CD321AFC(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)unint64_t v2 = &unk_1F264B640;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1CD321B48(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F264B640;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1CD321B78(uint64_t a1, unint64_t *a2)
{
  uint64_t v3 = (llvm::Type *)*a2;
  uint64_t v4 = *(void *)(a1 + 8);
  if (sub_1CD8CD258(*(void *)(v4 + 24), *(void *)(a1 + 16), *a2)
    || sub_1CD30BE30(*(void *)(v4 + 24), *(void *)(a1 + 16), (uint64_t)v3))
  {
    return 1;
  }
  uint64_t v7 = *(void *)(v4 + 24);
  uint64_t v8 = *(void *)(a1 + 16);

  return llvm::LoopVectorizationCostModel::isScalarWithPredication(v7, v8, v3, v5);
}

void sub_1CD321C00()
{
}

__n128 sub_1CD321C14(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)unint64_t v2 = &unk_1F264B688;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1CD321C60(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F264B688;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

BOOL sub_1CD321C90(uint64_t a1, unint64_t *a2)
{
  return sub_1CD8CBF00(*(void *)(*(void *)(a1 + 8) + 24), **(void **)(a1 + 16), *a2);
}

void sub_1CD321CA8()
{
}

__n128 sub_1CD321CBC(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)unint64_t v2 = &unk_1F264B6D0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1CD321D10(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F264B6D0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1CD321D48(uint64_t a1, llvm::Type **a2)
{
  return sub_1CD8CDC44(*(void *)(*(void *)(a1 + 8) + 24), **(void **)(a1 + 16), *a2, (llvm::DominatorTree *)**(unsigned __int8 **)(a1 + 24));
}

uint64_t sub_1CD321D68(uint64_t a1, uint64_t **a2, int a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  *(void *)a1 = &unk_1F264BC48;
  *(void *)(a1 + 8) = a1 + 24;
  *(void *)(a1 + 16) = 0x200000000;
  *(_DWORD *)(a1 + 40) = a3;
  int v12 = *a2;
  sub_1CD31F2B8((uint64_t)v13, (uint64_t)(a2 + 1));
  BOOL v9 = a2[5];
  sub_1CD31F2B8((uint64_t)v10, (uint64_t)(a2 + 6));
  unsigned int v5 = v12;
  while (v5 != v9)
  {
    uint64_t v8 = *v5;
    if (!v14) {
      sub_1CB920400();
    }
    uint64_t v6 = (*(uint64_t (**)(void *, uint64_t *))(*v14 + 48))(v14, &v8);
    sub_1CD8D14C4(a1, v6);
    unsigned int v5 = v12 + 4;
    v12 += 4;
  }
  if (v11 == v10)
  {
    (*(void (**)(void *))(v10[0] + 32))(v10);
  }
  else if (v11)
  {
    (*(void (**)(void *))(*v11 + 40))(v11);
  }
  if (v14 == v13)
  {
    (*(void (**)(void *))(v13[0] + 32))(v13);
  }
  else if (v14)
  {
    (*(void (**)(void *))(*v14 + 40))(v14);
  }
  return a1;
}

void sub_1CD321F5C()
{
}

__n128 sub_1CD321F70(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)unint64_t v2 = &unk_1F264B718;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1CD321FBC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F264B718;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

BOOL sub_1CD321FEC(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  BOOL v4 = HIDWORD(*a2) == 1 && v2 != 0;
  return (v2 > 1 || v4)
      && sub_1CD8CE880(*(void *)(*(void *)(a1 + 16) + 40), *(void *)(*(void *)(a1 + 8) + 40), v2) == 3;
}

uint64_t sub_1CD322040(uint64_t a1, llvm::PHINode *a2)
{
  return llvm::LoopVectorizationLegality::getIntOrFpInductionDescriptor(*(llvm::LoopVectorizationLegality **)(*(void *)a1 + 32), a2);
}

void sub_1CD322050()
{
}

__n128 sub_1CD322064(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x48uLL);
  *(void *)uint64_t v2 = &unk_1F264B760;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(v2 + 40) = *(_OWORD *)(a1 + 40);
  __n128 result = *(__n128 *)(a1 + 56);
  *(__n128 *)(v2 + 56) = result;
  return result;
}

__n128 sub_1CD3220C8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F264B760;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  long long v4 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 56) = *(_OWORD *)(a1 + 56);
  *(_OWORD *)(a2 + 40) = v4;
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1CD322110()
{
}

uint64_t sub_1CD322164()
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  LOBYTE(v4) = 1;
  *(void *)&long long v1 = &v4;
  LODWORD(v3) = 1;
  v5.n128_u64[0] = (unint64_t)"Enable vectorization of epilogue loops.";
  v5.n128_u64[1] = 39;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBD005C0, "enable-epilogue-vectorization", (unsigned char **)&v1, &v3, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBD005C0, &dword_1CB82C000);
  LODWORD(v3) = 1;
  *(void *)&long long v1 = &v3;
  int v4 = 1;
  v5.n128_u64[0] = (unint64_t)"When epilogue vectorization is enabled, and a value greater than 1 is specified, fo"
                                     "rces the given VF for all applicable epilogue loops.";
  v5.n128_u64[1] = 135;
  sub_1CBF7A9F8((uint64_t)&algn_1EBD00641[63], "epilogue-vectorization-force-VF", (int **)&v1, &v4, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &algn_1EBD00641[63], &dword_1CB82C000);
  LODWORD(v3) = 16;
  *(void *)&long long v1 = &v3;
  int v4 = 1;
  v5.n128_u64[0] = (unint64_t)"Only loops with vectorization factor equal to or larger than the specified value ar"
                                     "e considered for epilogue vectorization.";
  v5.n128_u64[1] = 123;
  sub_1CBF7A9F8((uint64_t)&unk_1EBD00740, "epilogue-vectorization-minimum-VF", (int **)&v1, &v4, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBD00740, &dword_1CB82C000);
  LODWORD(v3) = 16;
  *(void *)&long long v1 = &v3;
  int v4 = 1;
  v5.n128_u64[0] = (unint64_t)"Loops with a constant trip count that is smaller than this value are vectorized onl"
                                     "y if no scalar iteration overheads are incurred.";
  v5.n128_u64[1] = 131;
  sub_1CBF7A9F8((uint64_t)&unk_1EBD00800, "vectorizer-min-trip-count", (int **)&v1, &v4, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBD00800, &dword_1CB82C000);
  LODWORD(v3) = 128;
  *(void *)&long long v1 = &v3;
  int v4 = 1;
  v5.n128_u64[0] = (unint64_t)"The maximum allowed number of runtime memory checks with a vectorize(enable) pragma.";
  v5.n128_u64[1] = 84;
  sub_1CD8DA210((int **)&v1, &v4, (long long *)&v5);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &qword_1EBD008C0, &dword_1CB82C000);
  int v4 = 0;
  long long v3 = &v4;
  int v2 = 1;
  *(void *)&long long v1 = "Tail-folding and predication preferences over creating a scalar epilogue loop.";
  *((void *)&v1 + 1) = 78;
  v5.n128_u64[0] = (unint64_t)v6;
  v6[0] = "scalar-epilogue";
  v6[1] = 15;
  int v7 = 0;
  uint64_t v8 = "Don't tail-predicate loops, create scalar epilogue";
  uint64_t v9 = 50;
  int v10 = "predicate-else-scalar-epilogue";
  uint64_t v11 = 30;
  int v12 = 1;
  char v13 = "prefer tail-folding, create scalar epilogue if tail folding fails.";
  uint64_t v14 = 66;
  uint64_t v15 = "predicate-dont-vectorize";
  uint64_t v16 = 24;
  int v17 = 2;
  unint64_t v18 = "prefers tail-folding, don't attempt vectorization if tail-folding fails.";
  uint64_t v19 = 72;
  v5.n128_u64[1] = 0x400000003;
  sub_1CD8DA338(&v3, &v2, &v1, (uint64_t)&v5);
  if ((void *)v5.n128_u64[0] != v6) {
    free((void *)v5.n128_u64[0]);
  }
  __cxa_atexit((void (*)(void *))sub_1CD8C908C, &qword_1EA61E4E8, &dword_1CB82C000);
  LOBYTE(v4) = 0;
  *(void *)&long long v1 = &v4;
  LODWORD(v3) = 1;
  v5.n128_u64[0] = (unint64_t)"Maximize bandwidth when selecting vectorization factor which will be determined by "
                                     "the smallest type in loop.";
  v5.n128_u64[1] = 109;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBD00980, "vectorizer-maximize-bandwidth", (unsigned char **)&v1, &v3, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBD00980, &dword_1CB82C000);
  LOBYTE(v4) = 0;
  *(void *)&long long v1 = &v4;
  LODWORD(v3) = 1;
  v5.n128_u64[0] = (unint64_t)"Enable vectorization on interleaved memory accesses in a loop";
  v5.n128_u64[1] = 61;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBD00A40, "enable-interleaved-mem-accesses", (unsigned char **)&v1, &v3, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBD00A40, &dword_1CB82C000);
  LOBYTE(v4) = 0;
  *(void *)&long long v1 = &v4;
  LODWORD(v3) = 1;
  v5.n128_u64[0] = (unint64_t)"Enable vectorization on masked interleaved memory accesses in a loop";
  v5.n128_u64[1] = 68;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBD00B00, "enable-masked-interleaved-mem-accesses", (unsigned char **)&v1, &v3, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBD00B00, &dword_1CB82C000);
  LODWORD(v3) = 128;
  *(void *)&long long v1 = &v3;
  int v4 = 1;
  v5.n128_u64[0] = (unint64_t)"We don't interleave loops with a estimated constant trip count below this number";
  v5.n128_u64[1] = 80;
  sub_1CBF7A9F8((uint64_t)&unk_1EBD00BC0, "tiny-trip-count-interleave-threshold", (int **)&v1, &v4, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBD00BC0, &dword_1CB82C000);
  LODWORD(v3) = 0;
  *(void *)&long long v1 = &v3;
  int v4 = 1;
  v5.n128_u64[0] = (unint64_t)"A flag that overrides the target's number of scalar registers.";
  v5.n128_u64[1] = 62;
  sub_1CBF7A9F8((uint64_t)&unk_1EBD00C80, "force-target-num-scalar-regs", (int **)&v1, &v4, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBD00C80, &dword_1CB82C000);
  LODWORD(v3) = 0;
  *(void *)&long long v1 = &v3;
  int v4 = 1;
  v5.n128_u64[0] = (unint64_t)"A flag that overrides the target's number of vector registers.";
  v5.n128_u64[1] = 62;
  sub_1CBF7A9F8((uint64_t)&unk_1EBD00D40, "force-target-num-vector-regs", (int **)&v1, &v4, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBD00D40, &dword_1CB82C000);
  LODWORD(v3) = 0;
  *(void *)&long long v1 = &v3;
  int v4 = 1;
  v5.n128_u64[0] = (unint64_t)"A flag that overrides the target's max interleave factor for scalar loops.";
  v5.n128_u64[1] = 74;
  sub_1CBF7A9F8((uint64_t)&unk_1EBD00E00, "force-target-max-scalar-interleave", (int **)&v1, &v4, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBD00E00, &dword_1CB82C000);
  LODWORD(v3) = 0;
  *(void *)&long long v1 = &v3;
  int v4 = 1;
  v5.n128_u64[0] = (unint64_t)"A flag that overrides the target's max interleave factor for vectorized loops.";
  v5.n128_u64[1] = 78;
  sub_1CBF7A9F8((uint64_t)&unk_1EBD00EC0, "force-target-max-vector-interleave", (int **)&v1, &v4, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBD00EC0, &dword_1CB82C000);
  LODWORD(v3) = 0;
  *(void *)&long long v1 = &v3;
  int v4 = 1;
  v5.n128_u64[0] = (unint64_t)"A flag that overrides the target's expected cost for an instruction to a single con"
                                     "stant value. Mostly useful for getting consistent testing.";
  v5.n128_u64[1] = 141;
  sub_1CBF7A9F8((uint64_t)&unk_1EBD00F80, "force-target-instruction-cost", (int **)&v1, &v4, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBD00F80, &dword_1CB82C000);
  LOBYTE(v4) = 0;
  *(void *)&long long v1 = &v4;
  LODWORD(v3) = 1;
  v5.n128_u64[0] = (unint64_t)"Pretend that scalable vectors are supported, even if the target does not support th"
                                     "em. This flag should only be used for testing.";
  v5.n128_u64[1] = 129;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBD01040, "force-target-supports-scalable-vectors", (unsigned char **)&v1, &v3, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBD01040, &dword_1CB82C000);
  LODWORD(v3) = 20;
  *(void *)&long long v1 = &v3;
  int v4 = 1;
  v5.n128_u64[0] = (unint64_t)"The cost of a loop that is considered 'small' by the interleaver.";
  v5.n128_u64[1] = 65;
  sub_1CD8DA828((int **)&v1, &v4, (long long *)&v5);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &qword_1EBD01100, &dword_1CB82C000);
  LOBYTE(v4) = 1;
  *(void *)&long long v1 = &v4;
  LODWORD(v3) = 1;
  v5.n128_u64[0] = (unint64_t)"Enable the use of the block frequency analysis to access PGO heuristics minimizing "
                                     "code growth in cold regions and being more aggressive in hot regions.";
  v5.n128_u64[1] = 152;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBD011C0, "loop-vectorize-with-block-frequency", (unsigned char **)&v1, &v3, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBD011C0, &dword_1CB82C000);
  LOBYTE(v4) = 1;
  *(void *)&long long v1 = &v4;
  LODWORD(v3) = 1;
  v5.n128_u64[0] = (unint64_t)"Enable runtime interleaving until load/store ports are saturated";
  v5.n128_u64[1] = 64;
  sub_1CBA9E5B0((llvm::cl::Option *)&algn_1EBD01241[63], "enable-loadstore-runtime-interleave", (unsigned char **)&v1, &v3, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &algn_1EBD01241[63], &dword_1CB82C000);
  LOBYTE(v4) = 0;
  *(void *)&long long v1 = &v4;
  LODWORD(v3) = 1;
  v5.n128_u64[0] = (unint64_t)"Enable interleaving for loops with small iteration counts that contain scalar reduc"
                                     "tions to expose ILP.";
  v5.n128_u64[1] = 103;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBD01340, "interleave-small-loop-scalar-reduction", (unsigned char **)&v1, &v3, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBD01340, &dword_1CB82C000);
  LODWORD(v3) = 1;
  *(void *)&long long v1 = &v3;
  int v4 = 1;
  v5.n128_u64[0] = (unint64_t)"Max number of stores to be predicated behind an if.";
  v5.n128_u64[1] = 51;
  sub_1CBF7A9F8((uint64_t)&unk_1EBD01400, "vectorize-num-stores-pred", (int **)&v1, &v4, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBD01400, &dword_1CB82C000);
  LOBYTE(v4) = 1;
  *(void *)&long long v1 = &v4;
  LODWORD(v3) = 1;
  v5.n128_u64[0] = (unint64_t)"Count the induction variable only once when interleaving";
  v5.n128_u64[1] = 56;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBD014C0, "enable-ind-var-reg-heur", (unsigned char **)&v1, &v3, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBD014C0, &dword_1CB82C000);
  LOBYTE(v4) = 1;
  *(void *)&long long v1 = &v4;
  LODWORD(v3) = 1;
  v5.n128_u64[0] = (unint64_t)"Enable if predication of stores during vectorization.";
  v5.n128_u64[1] = 53;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EA61E068, "enable-cond-stores-vec", (unsigned char **)&v1, &v3, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EA61E068, &dword_1CB82C000);
  LODWORD(v3) = 2;
  *(void *)&long long v1 = &v3;
  int v4 = 1;
  v5.n128_u64[0] = (unint64_t)"The maximum interleave count to use when interleaving a scalar reduction in a nested loop.";
  v5.n128_u64[1] = 90;
  sub_1CBF7A9F8((uint64_t)&unk_1EA61E128, "max-nested-scalar-reduction-interleave", (int **)&v1, &v4, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EA61E128, &dword_1CB82C000);
  LOBYTE(v4) = 0;
  *(void *)&long long v1 = &v4;
  LODWORD(v3) = 1;
  v5.n128_u64[0] = (unint64_t)"Prefer in-loop vector reductions, overriding the targets preference.";
  v5.n128_u64[1] = 68;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EA61E1E8, "prefer-inloop-reductions", (unsigned char **)&v1, &v3, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EA61E1E8, &dword_1CB82C000);
  LOBYTE(v4) = 0;
  *(void *)&long long v1 = &v4;
  LODWORD(v3) = 1;
  v5.n128_u64[0] = (unint64_t)"Enable the vectorisation of loops with in-order (strict) FP reductions";
  v5.n128_u64[1] = 70;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EA61E2A8, "force-ordered-reductions", (unsigned char **)&v1, &v3, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EA61E2A8, &dword_1CB82C000);
  LOBYTE(v4) = 0;
  *(void *)&long long v1 = &v4;
  LODWORD(v3) = 1;
  v5.n128_u64[0] = (unint64_t)"Prefer predicating a reduction operation over an after loop select.";
  v5.n128_u64[1] = 67;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EA61E368, "prefer-predicated-reduction-select", (unsigned char **)&v1, &v3, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EA61E368, &dword_1CB82C000);
  LOBYTE(v4) = 0;
  *(void *)&long long v1 = &v4;
  LODWORD(v3) = 1;
  v5.n128_u64[0] = (unint64_t)"Enable VPlan-native vectorization path with support for outer loop vectorization.";
  v5.n128_u64[1] = 81;
  sub_1CBA9E5B0((llvm::cl::Option *)&EnableVPlanNativePath, "enable-vplan-native-path", (unsigned char **)&v1, &v3, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &EnableVPlanNativePath, &dword_1CB82C000);
  LOBYTE(v4) = 0;
  *(void *)&long long v1 = &v4;
  LODWORD(v3) = 1;
  v5.n128_u64[0] = (unint64_t)"Enable VPlan-native vectorization path predicator with support for outer loop vectorization.";
  v5.n128_u64[1] = 92;
  sub_1CBA9E5B0((llvm::cl::Option *)&EnableVPlanPredication, "enable-vplan-predication", (unsigned char **)&v1, &v3, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &EnableVPlanPredication, &dword_1CB82C000);
  LOBYTE(v4) = 0;
  *(void *)&long long v1 = &v4;
  LODWORD(v3) = 1;
  v5.n128_u64[0] = (unint64_t)"Build VPlan for every supported loop nest in the function and bail out right after "
                                     "the build (stress test the VPlan H-CFG construction in the VPlan-native vectorization path).";
  v5.n128_u64[1] = 175;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EA61E428, "vplan-build-stress-test", (unsigned char **)&v1, &v3, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EA61E428, &dword_1CB82C000);
  LOBYTE(v4) = 1;
  *(void *)&long long v1 = &v4;
  LODWORD(v3) = 1;
  v5.n128_u64[0] = (unint64_t)"Enable loop interleaving in Loop vectorization passes";
  v5.n128_u64[1] = 53;
  sub_1CBA9E5B0((llvm::cl::Option *)&llvm::EnableLoopInterleaving, "interleave-loops", (unsigned char **)&v1, &v3, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &llvm::EnableLoopInterleaving, &dword_1CB82C000);
  LOBYTE(v4) = 1;
  *(void *)&long long v1 = &v4;
  LODWORD(v3) = 1;
  v5.n128_u64[0] = (unint64_t)"Run the Loop vectorization passes";
  v5.n128_u64[1] = 33;
  sub_1CBA9E5B0((llvm::cl::Option *)&llvm::EnableLoopVectorization, "vectorize-loops", (unsigned char **)&v1, &v3, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &llvm::EnableLoopVectorization, &dword_1CB82C000);
  LOBYTE(v4) = 0;
  *(void *)&long long v1 = &v4;
  LODWORD(v3) = 1;
  v5.n128_u64[0] = (unint64_t)"Use dot format instead of plain text when dumping VPlans";
  v5.n128_u64[1] = 56;
  sub_1CBA9E5B0((llvm::cl::Option *)&PrintVPlansInDotFormat, "vplan-print-in-dot-format", (unsigned char **)&v1, &v3, &v5);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &PrintVPlansInDotFormat, &dword_1CB82C000);
}

uint64_t ****sub_1CD322CB4(unsigned int *a1, uint64_t *a2)
{
  unsigned int v3 = a1[2];
  if (v3 >= a1[3])
  {
    return (uint64_t ****)sub_1CC9E6F68(a1, a2);
  }
  else
  {
    __n128 result = (uint64_t ****)(*(void *)a1 + 24 * v3);
    uint64_t v5 = *a2;
    *__n128 result = (uint64_t ***)6;
    result[1] = 0;
    result[2] = (uint64_t ***)v5;
    if (v5 != -8192 && v5 != -4096 && v5 != 0)
    {
      __n128 result = llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)result);
      unsigned int v3 = a1[2];
    }
    a1[2] = v3 + 1;
  }
  return result;
}

void llvm::slpvectorizer::BoUpSLP::findReusedOrderedScalars(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v54[2] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(unsigned int *)(a2 + 8);
  int v51 = v54;
  int v53 = 4;
  if (v5 >= 5)
  {
    unsigned int v52 = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (!v5)
  {
    unsigned int v52 = 0;
    unsigned int v48 = v50;
    uint64_t v49 = 0xC00000000;
    unint64_t v8 = 1;
LABEL_52:
    char v40 = 0;
LABEL_53:
    *(unsigned char *)a3 = 0;
    goto LABEL_54;
  }
  uint64_t v6 = v54;
  uint64_t v7 = v5;
  do
  {
    *v6++ = v5;
    --v7;
  }
  while (v7);
  unsigned int v52 = v5;
  unsigned int v48 = v50;
  uint64_t v49 = 0xC00000000;
  unint64_t v8 = (v5 << 58) | 1;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = a1 + 80;
  do
  {
    uint64_t v12 = *(void *)(*(void *)a2 + 8 * v9);
    unsigned int v13 = *(unsigned __int8 *)(v12 + 16) - 60;
    BOOL v14 = v13 > 0x20;
    uint64_t v15 = (1 << v13) & 0x120000001;
    if (!v14 && v15 != 0)
    {
      uint64_t v47 = 0;
      char v17 = sub_1CD4C64C4(v11, v12, &v47);
      if (v17)
      {
        uint64_t v18 = *(void *)(v47 + 8);
        if (v18)
        {
          if (v10)
          {
            if (v10 != v18) {
              goto LABEL_75;
            }
          }
          else
          {
            uint64_t v10 = *(void *)(v47 + 8);
          }
          uint64_t v19 = *(char **)v10;
          uint64_t v20 = *(unsigned int *)(v10 + 8);
          if (v20)
          {
            uint64_t v21 = 8 * v20;
            int v22 = *(char **)v10;
            BOOL v23 = &v19[8 * v20];
            while (*(void *)v22 != v12)
            {
              v22 += 8;
              v21 -= 8;
              if (!v21)
              {
                int v22 = v23;
                break;
              }
            }
          }
          else
          {
            int v22 = *(char **)v10;
          }
          unint64_t v24 = v22 - v19;
          unint64_t v25 = v24 >> 3;
          if (v5 <= (v24 >> 3))
          {
LABEL_75:
            char v40 = 0;
            goto LABEL_53;
          }
          uint64_t v26 = (v24 >> 3);
          int v27 = v51;
          unint64_t v28 = *((unsigned int *)v51 + v25);
          if (v28 != v5)
          {
            if (v9 != v26) {
              goto LABEL_11;
            }
            if (v8) {
              unint64_t v8 = ((2 * ~((1 << v28) | (-1 << (v8 >> 58)))) | 0xFC00000000000000) & v8 | 1;
            }
            else {
              *(void *)(*(void *)v8 + ((v28 >> 3) & 0x1FFFFFF8)) &= ~(1 << v28);
            }
          }
          v27[v26] = v9;
          if (v8) {
            unint64_t v8 = v8 & 0xFC00000000000000 | (2
          }
                                            * (((v8 >> 1) & ~(-1 << (v8 >> 58)) | (1 << v9)) & ~(-1 << (v8 >> 58)))) | 1;
          else {
            *(void *)(*(void *)v8 + 8 * (v9 >> 6)) |= 1 << v9;
          }
        }
      }
    }
LABEL_11:
    ++v9;
  }
  while (v9 != v5);
  if (!v10) {
    goto LABEL_52;
  }
  if (v8)
  {
    uint8x8_t v35 = (uint8x8_t)vcnt_s8((int8x8_t)((v8 >> 1) & ~(-1 << (v8 >> 58))));
    v35.i16[0] = vaddlv_u8(v35);
    unsigned int v30 = v35.i32[0];
    goto LABEL_42;
  }
  uint64_t v29 = *(unsigned int *)(v8 + 8);
  if (!v29) {
    goto LABEL_43;
  }
  unsigned int v30 = 0;
  uint64_t v31 = *(int8x8_t **)v8;
  uint64_t v32 = 8 * v29;
  do
  {
    int8x8_t v33 = *v31++;
    uint8x8_t v34 = (uint8x8_t)vcnt_s8(v33);
    v34.i16[0] = vaddlv_u8(v34);
    v30 += v34.i32[0];
    v32 -= 8;
  }
  while (v32);
LABEL_42:
  if (v30 <= 1)
  {
LABEL_43:
    if (*(_DWORD *)(v10 + 8) != 2) {
      goto LABEL_52;
    }
  }
  uint64_t v36 = 0;
  unsigned int v37 = v51;
  while (1)
  {
    uint64_t v38 = *((unsigned int *)v51 + v36);
    if (v38 != v5 && v36 != v38) {
      break;
    }
    if (v5 == ++v36)
    {
      unsigned int v52 = 0;
      *(void *)a3 = a3 + 16;
      *(void *)(a3 + 8) = 0x400000000;
      char v40 = 1;
      goto LABEL_54;
    }
  }
  unsigned int v41 = 0;
  unsigned int v42 = v51;
  do
  {
    char v43 = v41;
    unint64_t v44 = (v8 >> 1) & ~(-1 << (v8 >> 58));
    if ((v8 & 1) == 0)
    {
      char v43 = v41 & 0x3F;
      unint64_t v44 = *(void *)(*(void *)v8 + 8 * (v41 >> 6));
    }
    if ((v44 >> v43))
    {
      ++v41;
    }
    else
    {
      if (*v42 == v5) {
        _DWORD *v42 = v41++;
      }
      ++v42;
    }
  }
  while (v41 < v5);
  *(void *)a3 = a3 + 16;
  *(void *)(a3 + 8) = 0x400000000;
  unsigned int v45 = v52;
  char v40 = 1;
  if (v52 && &v51 != (void **)a3)
  {
    if (v37 == v54)
    {
      if (v52 >= 5) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy((void *)(a3 + 16), v54, 4 * v52);
      *(_DWORD *)(a3 + 8) = v45;
    }
    else
    {
      *(void *)a3 = v37;
      int v46 = v53;
      *(_DWORD *)(a3 + 8) = v45;
      *(_DWORD *)(a3 + 12) = v46;
      int v51 = v54;
      int v53 = 0;
    }
    unsigned int v52 = 0;
    char v40 = 1;
  }
LABEL_54:
  *(unsigned char *)(a3 + 32) = v40;
  if ((v8 & 1) == 0)
  {
    if (*(void *)v8 != v8 + 16) {
      free(*(void **)v8);
    }
    MEMORY[0x1D25D9CE0](v8, 0x1080C40EF38A13ELL);
  }
  if (v48 != v50) {
    free(v48);
  }
  if (v51 != v54) {
    free(v51);
  }
}

void llvm::slpvectorizer::BoUpSLP::getReorderingData(llvm::slpvectorizer::BoUpSLP *a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  v32[2] = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a2 + 104)) {
    goto LABEL_2;
  }
  int v8 = *(_DWORD *)(a2 + 88);
  if (v8 != 2)
  {
    if (!v8)
    {
      uint64_t v9 = *(void *)(a2 + 384);
      int v10 = *(unsigned __int8 *)(v9 + 16);
      BOOL v11 = (v10 - 60) > 0x20 || ((1 << (v10 - 60)) & 0x120000001) == 0;
      if ((!v11 || a3 && (v10 == 90 || v10 == 61)) && v9 == *(void *)(a2 + 392))
      {
        *(void *)a5 = a5 + 16;
        *(void *)(a5 + 8) = 0x400000000;
        unsigned int v12 = *(_DWORD *)(a2 + 136);
        if (v12 && a2 + 128 != a5)
        {
          if (v12 >= 5) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          memcpy((void *)(a5 + 16), *(const void **)(a2 + 128), 4 * *(unsigned int *)(a2 + 136));
          *(_DWORD *)(a5 + 8) = v12;
        }
        char v6 = 1;
        goto LABEL_3;
      }
    }
LABEL_2:
    char v6 = 0;
    *(unsigned char *)a5 = 0;
LABEL_3:
    *(unsigned char *)(a5 + 32) = v6;
    return;
  }
  uint64_t v14 = *(void *)(a2 + 384);
  if (v14 && (*(unsigned char *)(v14 + 16) == 89 ? (BOOL v15 = v14 == *(void *)(a2 + 392)) : (BOOL v15 = 0), v15))
  {
    uint64_t v18 = *(uint64_t **)a2;
    uint64_t v16 = *(unsigned int *)(a2 + 8);
LABEL_32:
    if (v16)
    {
      uint64_t v22 = 0;
      while (1)
      {
        uint64_t v23 = v18[v22];
        if (v23)
        {
          if (*(unsigned char *)(v23 + 16) == 89 && *(unsigned char *)(**(void **)(v23 - 64) + 8) != 18) {
            break;
          }
        }
        if (v16 == ++v22)
        {
          if ((int)v16 < 2) {
            goto LABEL_42;
          }
          unint64_t v24 = (void **)(v18 + 1);
          uint64_t v25 = v16 - 1;
          while (**v24 == *(void *)*v18)
          {
            ++v24;
            if (!--v25) {
              goto LABEL_42;
            }
          }
          break;
        }
      }
    }
    else
    {
LABEL_42:
      unsigned int v30 = v32;
      uint64_t v31 = 0x400000000;
      int v26 = llvm::slpvectorizer::BoUpSLP::canReuseExtract(a1, v18, v16, a4, (uint64_t)&v30);
      if (v31) {
        int v27 = 1;
      }
      else {
        int v27 = v26;
      }
      if (v27 == 1)
      {
        if (v31)
        {
          sub_1CD3238B0((unint64_t)&v30);
          unsigned int v28 = v31;
          *(void *)a5 = a5 + 16;
          *(void *)(a5 + 8) = 0x400000000;
          if (v28 && &v30 != (void **)a5)
          {
            if (v30 == v32)
            {
              if (v28 >= 5) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              memcpy((void *)(a5 + 16), v32, 4 * v28);
              *(_DWORD *)(a5 + 8) = v28;
            }
            else
            {
              *(void *)a5 = v30;
              int v29 = HIDWORD(v31);
              *(_DWORD *)(a5 + 8) = v28;
              *(_DWORD *)(a5 + 12) = v29;
              unsigned int v30 = v32;
              HIDWORD(v31) = 0;
            }
            LODWORD(v31) = 0;
          }
        }
        else
        {
          *(void *)a5 = a5 + 16;
          *(void *)(a5 + 8) = 0x400000000;
        }
        *(unsigned char *)(a5 + 32) = 1;
      }
      if (v30 != v32) {
        free(v30);
      }
      if (v27) {
        return;
      }
    }
  }
  else
  {
    uint64_t v16 = *(unsigned int *)(a2 + 8);
    if (v16)
    {
      unint64_t v17 = 0;
      uint64_t v18 = *(uint64_t **)a2;
      uint64_t v19 = 8 * v16;
      while (1)
      {
        int v20 = *(unsigned __int8 *)(v18[v17 / 8] + 16);
        if ((v20 - 11) >= 2 && v20 != 89) {
          break;
        }
        v17 += 8;
        if (v19 == v17)
        {
          unint64_t v21 = 0;
          while (*(unsigned char *)(v18[v21 / 8] + 16) != 89)
          {
            v21 += 8;
            if (v19 == v21) {
              goto LABEL_62;
            }
          }
          goto LABEL_32;
        }
      }
    }
  }
LABEL_62:
  llvm::slpvectorizer::BoUpSLP::findReusedOrderedScalars((uint64_t)a1, a2, a5);
  if (!*(unsigned char *)(a5 + 32)) {
    goto LABEL_2;
  }
}

uint64_t llvm::slpvectorizer::BoUpSLP::canReuseExtract(llvm::slpvectorizer::BoUpSLP *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a3)
  {
    uint64_t v8 = 8 * a3;
    uint64_t v9 = a2;
    while (1)
    {
      int v10 = *(unsigned __int8 *)(*v9 + 16);
      if (v10 == 89 || v10 == 92) {
        break;
      }
      ++v9;
      v8 -= 8;
      if (!v8)
      {
        uint64_t v9 = &a2[a3];
        break;
      }
    }
  }
  else
  {
    uint64_t v9 = a2;
  }
  uint64_t v11 = *v9;
  int v12 = *(_DWORD *)(v11 + 20);
  if ((v12 & 0x40000000) != 0) {
    unsigned int v13 = *(uint64_t **)(v11 - 8);
  }
  else {
    unsigned int v13 = (uint64_t *)(v11 - 32 * (v12 & 0x7FFFFFF));
  }
  uint64_t v14 = *v13;
  *(_DWORD *)(a5 + 8) = 0;
  if (*(unsigned char *)(v11 + 16) == 92)
  {
    uint64_t result = llvm::slpvectorizer::BoUpSLP::canMapToVector(a1, *(llvm::Type **)v14, (const llvm::DataLayout *)(*(void *)(*(void *)(*(void *)(v11 + 40) + 56) + 40) + 272));
    if (!result) {
      return result;
    }
    if (*(unsigned char *)(v14 + 16) != 60 || (*(_WORD *)(v14 + 18) & 0x381) != 0) {
      return 0;
    }
    uint64_t v16 = *(void *)(v14 + 8);
    if (a3)
    {
      int v17 = a3;
      while (v16)
      {
        uint64_t v16 = *(void *)(v16 + 8);
        if (!--v17) {
          goto LABEL_19;
        }
      }
      return 0;
    }
LABEL_19:
    if (v16) {
      return 0;
    }
  }
  else
  {
    LODWORD(result) = *(_DWORD *)(*(void *)v14 + 32);
  }
  if (a3 != result) {
    return 0;
  }
  if (a3 > (unint64_t)*(unsigned int *)(a5 + 12))
  {
    *(_DWORD *)(a5 + 8) = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  uint64_t v18 = *(_DWORD **)a5;
  unint64_t v19 = *(unsigned int *)(a5 + 8);
  if (v19 >= a3) {
    uint64_t v20 = a3;
  }
  else {
    uint64_t v20 = *(unsigned int *)(a5 + 8);
  }
  if (v20)
  {
    uint8x8_t v34 = *(_DWORD **)a5;
    do
    {
      *v34++ = a3;
      --v20;
    }
    while (v20);
    unint64_t v19 = *(unsigned int *)(a5 + 8);
  }
  unint64_t v21 = v19 - a3;
  if (v19 < a3)
  {
    uint64_t v22 = &v18[v19];
    do
    {
      *v22++ = a3;
      BOOL v28 = __CFADD__(v21++, 1);
    }
    while (!v28);
  }
  *(_DWORD *)(a5 + 8) = a3;
  if (!a3) {
    goto LABEL_58;
  }
  uint64_t v23 = 0;
  unint64_t v24 = *(_DWORD **)a5;
  char v25 = 1;
  do
  {
    while (1)
    {
      uint64_t v26 = a2[v23];
      unsigned int v27 = *(unsigned __int8 *)(v26 + 16);
      BOOL v28 = v26 && v27 >= 0x1C;
      if (!v28) {
        break;
      }
      int v29 = *(_DWORD *)(v26 + 20);
      if ((v29 & 0x40000000) != 0) {
        unsigned int v30 = *(void **)(v26 - 8);
      }
      else {
        unsigned int v30 = (void *)(v26 - 32 * (v29 & 0x7FFFFFF));
      }
      if (*v30 != v14)
      {
LABEL_56:
        uint64_t result = 0;
        goto LABEL_59;
      }
      if (v27 == 89 && *(unsigned __int8 *)(*(void *)(v26 - 32) + 16) - 11 < 2) {
        break;
      }
      unint64_t v31 = sub_1CD32B9E0(v26);
      if (!HIDWORD(v31)) {
        goto LABEL_56;
      }
      if (v23 == v31)
      {
        if (v24[v23] != a3) {
          goto LABEL_56;
        }
        v24[v23] = v23;
        break;
      }
      if (v31 >= a3) {
        goto LABEL_56;
      }
      uint64_t v32 = v31;
      if (v24[v31] != a3) {
        goto LABEL_56;
      }
      char v25 = 0;
      uint64_t result = 0;
      v24[v32] = v23;
      if (a3 - 1 == v23++) {
        return result;
      }
    }
    ++v23;
  }
  while (a3 != v23);
  if ((v25 & 1) == 0) {
    return 0;
  }
LABEL_58:
  uint64_t result = 1;
LABEL_59:
  *(_DWORD *)(a5 + 8) = 0;
  return result;
}

unint64_t sub_1CD3238B0(unint64_t result)
{
  long long v1 = (void *)result;
  uint64_t v2 = *(unsigned int *)(result + 8);
  if (v2 >= 0x3A) {
    operator new();
  }
  unint64_t v3 = (v2 << 58) | 1;
  unint64_t v4 = v3 | (2 * ~(-1 << v2));
  unint64_t v39 = v3;
  char v40 = (void **)v4;
  if (v2)
  {
    uint64_t v5 = 0;
    uint64_t v6 = *(void *)result;
    do
    {
      unint64_t v7 = *(unsigned int *)(v6 + 4 * v5);
      if (v7 >= v2)
      {
        if (v3)
        {
          unint64_t v3 = v3 & 0xFC00000000000000 | (2
                                          * (((v3 >> 1) & ~(-1 << (v3 >> 58)) | (1 << v5)) & ~(-1 << (v3 >> 58)))) | 1;
          unint64_t v39 = v3;
        }
        else
        {
          *(void *)(*(void *)v3 + 8 * (v5 >> 6)) |= 1 << v5;
        }
      }
      else if (v4)
      {
        unint64_t v4 = ((2 * ~((1 << v7) | (-1 << (v4 >> 58)))) | 0xFC00000000000000) & v4 | 1;
        char v40 = (void **)v4;
      }
      else
      {
        *(void *)(*(void *)v4 + ((v7 >> 3) & 0x1FFFFFF8)) &= ~(1 << v7);
      }
      ++v5;
    }
    while (v2 != v5);
  }
  if (v3)
  {
    if (((v3 >> 1) & ~(-1 << (v3 >> 58))) == 0) {
      goto LABEL_51;
    }
  }
  else
  {
    uint64_t v8 = *(unsigned int *)(v3 + 8);
    if (!v8) {
      goto LABEL_51;
    }
    uint64_t v9 = *(uint64_t **)v3;
    uint64_t v10 = 8 * v8;
    while (!*v9)
    {
      ++v9;
      v10 -= 8;
      if (!v10) {
        goto LABEL_51;
      }
    }
  }
  if (v4)
  {
    int v23 = __clz(__rbit64((v4 >> 1) & ~(-1 << (v4 >> 58))));
    if (((v4 >> 1) & ~(-1 << (v4 >> 58))) != 0) {
      int v18 = v23;
    }
    else {
      int v18 = -1;
    }
    if ((v3 & 1) == 0) {
      goto LABEL_35;
    }
    goto LABEL_47;
  }
  int v11 = *(_DWORD *)(v4 + 64);
  if (!v11)
  {
    int v18 = -1;
    if ((v3 & 1) == 0) {
      goto LABEL_35;
    }
LABEL_47:
    unint64_t v37 = (v3 >> 1) & ~(-1 << (v3 >> 58));
    if (!v37) {
      goto LABEL_51;
    }
    unsigned int v36 = __clz(__rbit64(v37));
    goto LABEL_49;
  }
  uint64_t v12 = 0;
  int v13 = -v11;
  int v14 = v11 - 1;
  BOOL v15 = *(uint64_t **)v4;
  unint64_t v16 = 0xFFFFFFFFFFFFFFFFLL >> v13;
  uint64_t v17 = v14 & 0xFFFFFFC0;
  int v18 = -1;
  while (1)
  {
    uint64_t v20 = *v15++;
    uint64_t v19 = v20;
    unint64_t v21 = v17 == v12 ? v16 : -1;
    unint64_t v22 = v21 & v19;
    if (v22) {
      break;
    }
    v12 += 64;
    if (v17 + 64 == v12) {
      goto LABEL_34;
    }
  }
  int v18 = __clz(__rbit64(v22)) + v12;
LABEL_34:
  if (v3) {
    goto LABEL_47;
  }
LABEL_35:
  int v24 = *(_DWORD *)(v3 + 64);
  if (v24)
  {
    uint64_t v25 = 0;
    int v26 = -v24;
    int v27 = v24 - 1;
    BOOL v28 = *(uint64_t **)v3;
    unint64_t v29 = 0xFFFFFFFFFFFFFFFFLL >> v26;
    uint64_t v30 = v27 & 0xFFFFFFC0;
    while (1)
    {
      uint64_t v32 = *v28++;
      uint64_t v31 = v32;
      unint64_t v33 = v30 == v25 ? v29 : -1;
      unint64_t v34 = v33 & v31;
      if (v34) {
        break;
      }
      v25 += 64;
      if (v30 + 64 == v25) {
        goto LABEL_51;
      }
    }
    uint64_t v35 = __clz(__rbit64(v34)) + v25;
    if ((v35 & 0x80000000) == 0)
    {
      unsigned int v36 = v35;
      do
      {
LABEL_49:
        *(_DWORD *)(*v1 + 4 * v36) = v18;
        int v18 = sub_1CB9F9DF0((unint64_t *)&v40, v18);
        uint64_t result = sub_1CB9F9DF0(&v39, v36);
        unsigned int v36 = result;
      }
      while ((result & 0x80000000) == 0);
      unint64_t v3 = v39;
    }
  }
LABEL_51:
  if ((v3 & 1) == 0 && v3)
  {
    if (*(void *)v3 != v3 + 16) {
      free(*(void **)v3);
    }
    uint64_t result = MEMORY[0x1D25D9CE0](v3, 0x1080C40EF38A13ELL);
  }
  uint64_t v38 = v40;
  if ((v40 & 1) == 0 && v40)
  {
    if (*v40 != v40 + 2) {
      free(*v40);
    }
    return MEMORY[0x1D25D9CE0](v38, 0x1080C40EF38A13ELL);
  }
  return result;
}

uint64_t *llvm::slpvectorizer::BoUpSLP::reorderTopToBottom(uint64_t **this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v114 = *MEMORY[0x1E4F143B8];
  v92[0] = 0;
  v92[1] = 0;
  unsigned int v93 = 0;
  v90[0] = 0;
  v90[1] = 0;
  unsigned int v91 = 0;
  unint64_t v4 = *this;
  uint64_t v5 = *((unsigned int *)this + 2);
  if (v5)
  {
    unint64_t v7 = &v4[v5];
    do
    {
      llvm::slpvectorizer::BoUpSLP::getReorderingData((llvm::slpvectorizer::BoUpSLP *)this, *v4, 1, a4, (uint64_t)&v109);
      if (v113[0])
      {
        int v8 = dword_1EBD01C10;
        if (*v4) {
          BOOL v9 = dword_1EBD01C10 == 0;
        }
        else {
          BOOL v9 = 1;
        }
        if (!v9)
        {
          uint64_t v10 = *v4;
          while (*(_DWORD *)(v10 + 176) == 1)
          {
            uint64_t v10 = **(void **)(v10 + 168);
            if (!*(_DWORD *)(v10 + 88) && *(void *)(v10 + 384) != *(void *)(v10 + 392) && *(_DWORD *)(v10 + 200)) {
              goto LABEL_16;
            }
            if (!--v8) {
              break;
            }
          }
        }
        LODWORD(__b) = *(_DWORD *)(*v4 + 8);
        int v11 = sub_1CD8E5B44((uint64_t)v92, (int *)&__b);
        int v105 = (char *)*v4;
        sub_1CC37AF14((void *)v11 + 1, (uint64_t *)&v105);
        if (*(_DWORD *)(*v4 + 88))
        {
          __b = (void *)*v4;
          sub_1CD8E5AB0((uint64_t)&v105, (uint64_t)v90, (uint64_t *)&__b, (uint64_t)&v109);
        }
LABEL_16:
        if (v113[0] && v109 != (void **)&v111) {
          free(v109);
        }
      }
      ++v4;
    }
    while (v4 != v7);
    unint64_t v4 = *this;
  }
  unsigned int v12 = *(_DWORD *)(*v4 + 8);
  if (v12 < 2) {
    goto LABEL_161;
  }
  do
  {
    if (!v93) {
      goto LABEL_28;
    }
    unsigned int v13 = (v93 - 1) & (37 * v12);
    uint64_t v14 = v92[0] + 56 * v13;
    int v15 = *(_DWORD *)v14;
    if (v12 != *(_DWORD *)v14)
    {
      int v16 = 1;
      while (v15 != -1)
      {
        unsigned int v17 = v13 + v16++;
        unsigned int v13 = v17 & (v93 - 1);
        uint64_t v14 = v92[0] + 56 * v13;
        int v15 = *(_DWORD *)v14;
        if (v12 == *(_DWORD *)v14) {
          goto LABEL_29;
        }
      }
LABEL_28:
      uint64_t v14 = v92[0] + 56 * v93;
    }
LABEL_29:
    if (v14 == v92[0] + 56 * v93) {
      goto LABEL_30;
    }
    uint64_t v19 = *(uint64_t **)(v14 + 32);
    uint64_t v20 = *(uint64_t **)(v14 + 40);
    v85[0] = 0;
    v85[1] = 0;
    unsigned int v86 = 0;
    BOOL v88 = 0;
    uint64_t v89 = 0;
    int v87 = 0;
    unsigned int v109 = (void **)v113;
    int v110 = (void **)v113;
    uint64_t v111 = 4;
    int v112 = 0;
    if (v20 == v19) {
      goto LABEL_156;
    }
    do
    {
      uint64_t v21 = *v19;
      if (*(_DWORD *)(*v19 + 104)) {
        goto LABEL_34;
      }
      int v22 = *(_DWORD *)(v21 + 88);
      if (v22 == 2)
      {
        int v105 = 0;
        uint64_t v23 = v90[0];
        unsigned int v24 = v91;
        int v25 = sub_1CD5101D0(v90[0], v91, v21, &v105);
        int v26 = v105;
        if (!v25) {
          int v26 = (char *)(v23 + 40 * v24);
        }
        int v27 = (void **)(v26 + 8);
        if (*(_DWORD *)(v21 + 88))
        {
LABEL_49:
          __b = v100;
          unint64_t v99 = 0x400000000;
          unint64_t v31 = *((unsigned int *)v27 + 2);
          if (v31) {
            BOOL v32 = &__b != v27;
          }
          else {
            BOOL v32 = 0;
          }
          if (v32)
          {
            if (v31 >= 5) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            memcpy(v100, *v27, 4 * *((unsigned int *)v27 + 2));
            LODWORD(v99) = v31;
            v101[0] = 0;
            int v105 = (char *)v107;
            unint64_t v106 = 0x400000000;
            if (__b == v100)
            {
              memcpy(v107, v100, 4 * v31);
              LODWORD(v106) = v31;
              int v33 = v101[0];
            }
            else
            {
              int v33 = 0;
              int v105 = (char *)__b;
              unint64_t v106 = __PAIR64__(HIDWORD(v99), v31);
              __b = v100;
              HIDWORD(v99) = 0;
            }
            LODWORD(v99) = 0;
          }
          else
          {
            int v33 = 0;
            v101[0] = 0;
            int v105 = (char *)v107;
            unint64_t v106 = 0x400000000;
          }
          v108[0] = v33;
          uint64_t v34 = sub_1CD8E5F18((uint64_t)v85, (uint64_t)&v105, v108);
          ++*(_DWORD *)(v34 + 32);
          if (v105 != (char *)v107) {
            free(v105);
          }
          uint64_t v35 = __b;
          if (__b != v100) {
            goto LABEL_61;
          }
          goto LABEL_34;
        }
      }
      else
      {
        int v27 = (void **)(v21 + 128);
        if (v22) {
          goto LABEL_49;
        }
      }
      uint64_t v28 = *(void *)(v21 + 384);
      if (v28) {
        BOOL v29 = v28 == *(void *)(v21 + 392);
      }
      else {
        BOOL v29 = 0;
      }
      if (!v29) {
        goto LABEL_49;
      }
      if (*(unsigned char *)(v28 + 16) != 61) {
        goto LABEL_49;
      }
      uint64_t v30 = *((unsigned int *)v27 + 2);
      if (!v30) {
        goto LABEL_49;
      }
      int v105 = (char *)v107;
      unsigned int v36 = (unsigned int *)*v27;
      unint64_t v106 = 0xC00000000;
      if (v30 >= 0xD) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      unint64_t v37 = v107;
      memset(v107, 255, 4 * v30);
      uint64_t v38 = 0;
      LODWORD(v106) = v106 + v30;
      do
      {
        v107[v36[v38]] = v38;
        ++v38;
      }
      while (v30 != v38);
      uint64_t v39 = *((unsigned int *)v27 + 2);
      __src = v104;
      HIDWORD(v103) = 4;
      if (v39 >= 5)
      {
        LODWORD(v103) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v39)
      {
        char v40 = v104;
        uint64_t v41 = v39;
        do
        {
          *v40++ = v39;
          --v41;
        }
        while (v41);
      }
      unsigned int v42 = v104;
      LODWORD(v103) = v39;
      if (v106)
      {
        uint64_t v43 = 4 * v106;
        do
        {
          int v45 = *v37++;
          int v44 = v45;
          if (v45 == -1) {
            int v44 = v39;
          }
          *v42++ = v44;
          v43 -= 4;
        }
        while (v43);
      }
      sub_1CD3238B0((unint64_t)&__src);
      int v94 = v96;
      uint64_t v95 = 0x400000000;
      unint64_t v46 = v103;
      if (v103)
      {
        if (v103 >= 5uLL) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        memcpy(v96, __src, 4 * v103);
        LODWORD(v95) = v46;
        int v97 = 0;
        __b = v100;
        unint64_t v99 = 0x400000000;
        if (v94 == v96)
        {
          if (v46 >= 5) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          memcpy(v100, v96, 4 * v46);
          LODWORD(v99) = v46;
          int v47 = v97;
        }
        else
        {
          int v47 = 0;
          __b = v94;
          unint64_t v99 = __PAIR64__(HIDWORD(v95), v46);
          int v94 = v96;
          HIDWORD(v95) = 0;
        }
        LODWORD(v95) = 0;
      }
      else
      {
        int v47 = 0;
        int v97 = 0;
        __b = v100;
        unint64_t v99 = 0x400000000;
      }
      v101[0] = v47;
      uint64_t v48 = sub_1CD8E5F18((uint64_t)v85, (uint64_t)&__b, v101);
      ++*(_DWORD *)(v48 + 32);
      if (__b != v100) {
        free(__b);
      }
      if (v94 != v96) {
        free(v94);
      }
      if (__src != v104) {
        free(__src);
      }
      uint64_t v35 = v105;
      if (v105 != (char *)v107) {
LABEL_61:
      }
        free(v35);
LABEL_34:
      ++v19;
    }
    while (v19 != v20);
    if (v87 == v88) {
      goto LABEL_156;
    }
    uint64_t v49 = *v87;
    unint64_t v50 = *((unsigned int *)v87 + 2);
    int v51 = v87 + 5;
    if (v87 + 5 != v88)
    {
      unsigned int v77 = *((_DWORD *)v87 + 8);
      do
      {
        unsigned int v78 = *((_DWORD *)v51 + 8);
        if (v77 >= v78)
        {
          if (v77 != v78 || *((_DWORD *)v51 + 2)) {
            goto LABEL_149;
          }
          unint64_t v50 = 0;
        }
        else
        {
          unint64_t v50 = *((unsigned int *)v51 + 2);
        }
        uint64_t v49 = *v51;
        unsigned int v77 = *((_DWORD *)v51 + 8);
LABEL_149:
        v51 += 5;
      }
      while (v51 != v88);
    }
    if (v50)
    {
      int v105 = (char *)v107;
      unint64_t v106 = 0xC00000000;
      if (v50 >= 0xDuLL) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memset(v107, 255, 4 * v50);
      LODWORD(v106) = v106 + v50;
      uint64_t v52 = 0;
      do
      {
        v107[*(unsigned int *)(v49 + 4 * v52)] = v52;
        ++v52;
      }
      while (v50 != v52);
      __b = v100;
      HIDWORD(v99) = 12;
      if (v50 > 0xC)
      {
        LODWORD(v99) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memset(v100, 255, 4 * v50);
      int v53 = v100;
      uint64_t v54 = 0;
      LODWORD(v99) = v50;
      do
      {
        unsigned int v55 = *(_DWORD *)(v49 + v54);
        if (v55 >= v50) {
          unsigned int v55 = -1;
        }
        *(_DWORD *)&v100[v54] = v55;
        v54 += 4;
      }
      while (4 * v50 != v54);
      uint64_t v56 = *((unsigned int *)this + 2);
      if (v56)
      {
        unsigned int v57 = *this;
        uint64_t v58 = (uint64_t)&(*this)[v56];
        do
        {
          uint64_t v59 = *v57;
          if (*(_DWORD *)(*v57 + 8) == v12)
          {
            if (*(_DWORD *)(v59 + 88)
              || ((uint64_t v60 = *(void *)(v59 + 384),
                   unsigned int v61 = *(unsigned __int8 *)(v60 + 16) - 60,
                   BOOL v18 = v61 > 0x20,
                   uint64_t v62 = (1 << v61) & 0x160000003,
                   !v18)
                ? (BOOL v63 = v62 == 0)
                : (BOOL v63 = 1),
                  v63 || v60 != *(void *)(v59 + 392)))
            {
              BOOL v64 = (llvm::Type *)v105;
              uint64_t v65 = *(unsigned int *)(v59 + 216);
              if (v65)
              {
                uint64_t v66 = *(void *)(v59 + 208);
                uint64_t v67 = 80 * v65;
                do
                {
                  sub_1CD324A9C(v66, v64);
                  v66 += 80;
                  v67 -= 80;
                }
                while (v67);
                uint64_t v59 = *v57;
                BOOL v64 = (llvm::Type *)v105;
              }
              sub_1CD324A9C(v59, v64);
            }
            else
            {
              sub_1CD32486C(v59 + 128, (int *)v105, v106);
              uint64_t v71 = *v57;
              int v72 = *(unsigned __int8 *)(*(void *)(*v57 + 384) + 16);
              if (v72 == 90 || v72 == 61)
              {
                uint64_t v73 = *(unsigned int *)(v71 + 216);
                if (v73)
                {
                  int v74 = (llvm::Type *)v105;
                  uint64_t v75 = *(void *)(v71 + 208);
                  uint64_t v76 = 80 * v73;
                  do
                  {
                    sub_1CD324A9C(v75, v74);
                    v75 += 80;
                    v76 -= 80;
                  }
                  while (v76);
                }
              }
            }
            if (*(_DWORD *)(*v57 + 104))
            {
              __src = v104;
              uint64_t v103 = 0x400000000;
              sub_1CD32486C((unint64_t)&__src, (int *)__b, v99);
              int v94 = v96;
              BOOL v68 = (unsigned int *)__src;
              uint64_t v69 = v103;
              uint64_t v95 = 0xC00000000;
              if (v103)
              {
                if (v103 >= 0xD) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                memset(v96, 255, 4 * v103);
                uint64_t v70 = 0;
                LODWORD(v95) = v95 + v69;
                do
                {
                  v96[v68[v70]] = v70;
                  ++v70;
                }
                while (v69 != v70);
              }
              sub_1CD324BD0(&v94, *(int **)(*v57 + 96), *(unsigned int *)(*v57 + 104));
              sub_1CD8DCFDC((_DWORD *)(*v57 + 96), &v94);
              if (v94 != v96) {
                free(v94);
              }
              if (__src != v104) {
                free(__src);
              }
            }
          }
          else if (*(_DWORD *)(v59 + 104) == v12)
          {
            sub_1CD324794((_DWORD *)(v59 + 96), (int *)v105);
          }
          ++v57;
        }
        while (v57 != (uint64_t *)v58);
        int v53 = __b;
      }
      if (v53 != v100) {
        free(v53);
      }
      if (v105 != (char *)v107) {
        free(v105);
      }
    }
LABEL_156:
    if (v110 != v109) {
      free(v110);
    }
    unsigned int v109 = (void **)&v87;
    sub_1CCCF7D58(&v109);
    sub_1CD8E19B8(v85[0], v86);
    MEMORY[0x1D25D9CD0](v85[0], 8);
LABEL_30:
    BOOL v18 = v12 > 3;
    v12 >>= 1;
  }
  while (v18);
LABEL_161:
  uint64_t v79 = v90[0];
  if (v91)
  {
    uint64_t v80 = 40 * v91;
    uint64_t v81 = v90[0] + 24;
    do
    {
      if ((*(void *)(v81 - 24) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        unsigned int v82 = *(void **)(v81 - 16);
        if ((void *)v81 != v82) {
          free(v82);
        }
      }
      v81 += 40;
      v80 -= 40;
    }
    while (v80);
  }
  MEMORY[0x1D25D9CD0](v79, 8);
  return sub_1CD8E5A44(v92);
}

void sub_1CD324794(_DWORD *a1, int *a2)
{
  v14[6] = *MEMORY[0x1E4F143B8];
  unint64_t v4 = *(unsigned char **)a1;
  uint64_t v5 = (unsigned char *)(*(void *)a1 + 4 * a1[2]);
  unsigned int v12 = v14;
  uint64_t v13 = 0xC00000000;
  sub_1CD46210C((unsigned int *)&v12, v4, v5);
  sub_1CD8DCFDC(&v12, a1);
  uint64_t v6 = v13;
  unint64_t v7 = v12;
  if (v13)
  {
    uint64_t v8 = *(void *)a1;
    BOOL v9 = v12;
    do
    {
      uint64_t v11 = *a2++;
      uint64_t v10 = v11;
      if (v11 != -1) {
        *(_DWORD *)(v8 + 4 * v10) = *v9;
      }
      ++v9;
      --v6;
    }
    while (v6);
  }
  if (v7 != v14) {
    free(v7);
  }
}

void sub_1CD32486C(unint64_t a1, int *a2, unint64_t a3)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  unsigned int v24 = v26;
  uint64_t v25 = 0xC00000000;
  uint64_t v6 = *(unsigned int *)(a1 + 8);
  if (v6)
  {
    unint64_t v7 = *(_DWORD **)a1;
    if (v6 >= 0xD) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    memset(v26, 255, 4 * v6);
    uint64_t v8 = 0;
    LODWORD(v25) = v25 + v6;
    do
    {
      v26[v7[v8]] = v8;
      ++v8;
    }
    while (v6 != v8);
  }
  else
  {
    sub_1CBB1173C((uint64_t)&v24, a3);
    if (v25)
    {
      uint64_t v9 = 0;
      uint64_t v10 = v24;
      uint64_t v11 = 4 * v25;
      do
      {
        v10[v9] = v9;
        ++v9;
        v11 -= 4;
      }
      while (v11);
    }
  }
  sub_1CD324794(&v24, a2);
  unsigned int v12 = v24;
  if (sub_1CC5D47FC(v24, v25, v25))
  {
    *(_DWORD *)(a1 + 8) = 0;
  }
  else
  {
    if (a3 > *(unsigned int *)(a1 + 12))
    {
      *(_DWORD *)(a1 + 8) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v13 = *(_DWORD **)a1;
    unint64_t v14 = *(unsigned int *)(a1 + 8);
    if (v14 >= a3) {
      unint64_t v15 = a3;
    }
    else {
      unint64_t v15 = *(unsigned int *)(a1 + 8);
    }
    if (v15)
    {
      uint64_t v23 = *(_DWORD **)a1;
      do
      {
        *v23++ = a3;
        --v15;
      }
      while (v15);
      unint64_t v14 = *(unsigned int *)(a1 + 8);
    }
    unint64_t v16 = v14 - a3;
    if (v14 < a3)
    {
      unsigned int v17 = &v13[v14];
      do
        *v17++ = a3;
      while (!__CFADD__(v16++, 1));
    }
    *(_DWORD *)(a1 + 8) = a3;
    if (a3)
    {
      uint64_t v19 = 0;
      uint64_t v20 = v24;
      uint64_t v21 = *(_DWORD **)a1;
      do
      {
        uint64_t v22 = v20[v19];
        if (v22 != -1) {
          v21[v22] = v19;
        }
        ++v19;
      }
      while (a3 != v19);
    }
    sub_1CD3238B0(a1);
    unsigned int v12 = v24;
  }
  if (v12 != v26) {
    free(v12);
  }
}

void sub_1CD324A9C(uint64_t a1, llvm::Type *a2)
{
  v14[6] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(unsigned int *)(a1 + 8);
  unsigned int v5 = *(_DWORD *)(a1 + 8);
  uint64_t v6 = llvm::UndefValue::get(***(llvm::UndefValue ****)a1, a2);
  uint64_t v11 = v14;
  int v13 = 6;
  if (v4 >= 7)
  {
    unsigned int v12 = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (v5)
  {
    unint64_t v7 = (llvm::UndefValue **)v14;
    do
    {
      *v7++ = v6;
      --v4;
    }
    while (v4);
  }
  unsigned int v12 = v5;
  sub_1CD499474(&v11, (_DWORD *)a1);
  uint64_t v8 = v12;
  if (v12)
  {
    uint64_t v9 = 0;
    do
    {
      uint64_t v10 = *((int *)a2 + v9);
      if (v10 != -1) {
        *(void *)(*(void *)a1 + 8 * v10) = *((void *)v11 + v9);
      }
      ++v9;
    }
    while (v8 != v9);
  }
  if (v11 != v14) {
    free(v11);
  }
}

void sub_1CD324BD0(_DWORD *a1, int *__src, unint64_t a3)
{
  v19[6] = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    uint64_t v4 = __src;
    unsigned int v6 = a1[2];
    if (v6)
    {
      __b = v19;
      int v18 = 12;
      if (a3 > 0xC)
      {
        int v17 = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memset(v19, 255, 4 * a3);
      int v17 = a3;
      int v8 = v6;
      if (a3 < v6) {
        int v8 = a3;
      }
      if ((int)a3 >= 1)
      {
        uint64_t v9 = *(void *)a1;
        uint64_t v10 = __b;
        uint64_t v11 = a3;
        do
        {
          int v13 = *v4++;
          int v12 = v13;
          if (v13 < v8 && v12 != -1)
          {
            int v15 = *(_DWORD *)(v9 + 4 * v12);
            if (v15 < v8) {
              _DWORD *v10 = v15;
            }
          }
          ++v10;
          --v11;
        }
        while (v11);
      }
      sub_1CD8DCFDC(a1, &__b);
      if (__b != v19) {
        free(__b);
      }
    }
    else
    {
      size_t v7 = 4 * a3;
      if ((uint64_t)(4 * a3) >> 2 > (unint64_t)a1[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(*(void **)a1, __src, v7);
      a1[2] += v7 >> 2;
    }
  }
}

uint64_t llvm::slpvectorizer::BoUpSLP::canReorderOperands(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6 = *(unsigned int *)(a2 + 216);
  if (!v6) {
    return 1;
  }
  uint64_t v8 = a5;
  uint64_t v13 = 0;
  uint64_t v36 = 8 * a5;
  while (1)
  {
    uint64_t v14 = *(unsigned int *)(a3 + 8);
    if (v14)
    {
      uint64_t v15 = 16 * v14;
      uint64_t v16 = *(void *)a3 + 8;
      while (v13 != *(_DWORD *)(v16 - 8) || *(_DWORD *)(*(void *)v16 + 88))
      {
        v16 += 16;
        v15 -= 16;
        if (!v15) {
          goto LABEL_8;
        }
      }
      goto LABEL_23;
    }
LABEL_8:
    uint64_t v17 = sub_1CD8DD160(a1, *(void *)(a2 + 208), v13);
    if (v17) {
      break;
    }
    if (v8)
    {
      uint64_t v32 = a1;
      int v33 = a4;
      uint64_t v34 = v8;
      uint64_t v35 = a6;
      unint64_t v21 = 0;
      uint64_t v22 = 0;
      uint64_t v23 = *(void *)(a2 + 208) + 80 * v13;
      unint64_t v37 = *(uint64_t **)v23;
      unint64_t v24 = *(unsigned int *)(v23 + 8);
      uint64_t v25 = v36;
      int v26 = a4;
      do
      {
        uint64_t v28 = *v26++;
        uint64_t v27 = v28;
        BOOL v29 = sub_1CD8DD67C(v28, v37, v24);
        if (v29) {
          uint64_t v22 = v27;
        }
        v21 += v29;
        v25 -= 8;
      }
      while (v25);
      if (v21 > 1) {
        return 0;
      }
      uint64_t v8 = v34;
      a6 = v35;
      a1 = v32;
      a4 = v33;
      if (v22)
      {
        unint64_t v30 = *(unsigned int *)(v35 + 8);
        if (v30 >= *(unsigned int *)(v35 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)v35 + 8 * v30) = v22;
        ++*(_DWORD *)(v35 + 8);
      }
    }
LABEL_23:
    if (++v13 == v6) {
      return 1;
    }
  }
  uint64_t v18 = *(unsigned int *)(v17 + 176);
  if (!v18)
  {
LABEL_13:
    sub_1CD324F38(a3, v13, v17);
    goto LABEL_23;
  }
  uint64_t v19 = *(void **)(v17 + 168);
  uint64_t v20 = 16 * v18;
  while (*v19 == a2)
  {
    v19 += 2;
    v20 -= 16;
    if (!v20) {
      goto LABEL_13;
    }
  }
  return 0;
}

uint64_t sub_1CD324F38(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(a1 + 8);
  if (v3 >= *(_DWORD *)(a1 + 12)) {
    return sub_1CD8E67F8(a1, a2, a3);
  }
  uint64_t v4 = *(void *)a1 + 16 * v3;
  *(_DWORD *)uint64_t v4 = a2;
  *(void *)(v4 + 8) = a3;
  *(_DWORD *)(a1 + 8) = v3 + 1;
  return a1;
}

void *llvm::slpvectorizer::BoUpSLP::reorderBottomToTop(llvm::slpvectorizer::BoUpSLP *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int v5 = this;
  v267[6] = *MEMORY[0x1E4F143B8];
  v231[0] = 0;
  v231[1] = 0;
  int v232 = 0;
  BOOL v234 = 0;
  uint64_t v235 = 0;
  int v233 = 0;
  v229[0] = 0;
  v229[1] = 0;
  unsigned int v230 = 0;
  v265 = v267;
  uint64_t v266 = 0x600000000;
  uint64_t v6 = *((unsigned int *)this + 2);
  if (!v6)
  {
    int v224 = v228;
    int v225 = v228;
    uint64_t v226 = 4;
    int v227 = 0;
    goto LABEL_17;
  }
  size_t v7 = *(void ***)this;
  uint64_t v8 = 8 * v6;
  do
  {
    uint64_t v9 = (uint64_t)*v7;
    if (*((_DWORD *)*v7 + 22))
    {
      if (v266 >= (unint64_t)HIDWORD(v266)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      v265[v266] = v9;
      LODWORD(v266) = v266 + 1;
      uint64_t v9 = (uint64_t)*v7;
    }
    llvm::slpvectorizer::BoUpSLP::getReorderingData(this, v9, 0, a4, (uint64_t)&v257);
    if (v261)
    {
      int v224 = (char *)*v7;
      sub_1CC37AF14(v231, (uint64_t *)&v224);
      if (*((_DWORD *)*v7 + 22))
      {
        v262 = *v7;
        sub_1CD8E5AB0((uint64_t)&v224, (uint64_t)v229, (uint64_t *)&v262, (uint64_t)&v257);
      }
      if (v261 && v257 != &v259) {
        free(v257);
      }
    }
    ++v7;
    v8 -= 8;
  }
  while (v8);
  uint64_t v10 = v233;
  uint64_t v11 = v234;
  int v224 = v228;
  int v225 = v228;
  uint64_t v226 = 4;
  int v227 = 0;
  unsigned int v5 = this;
  while (v233 != v234)
  {
    v219[0] = 0;
    v219[1] = 0;
    int v220 = 0;
    uint64_t v222 = 0;
    uint64_t v223 = 0;
    uint64_t v221 = 0;
    v262 = v264;
    uint64_t v263 = 0x600000000;
    do
    {
      uint64_t v18 = *v10;
      int v19 = *(_DWORD *)(*v10 + 88);
      if (v19)
      {
        if (v19 != 2 || !v230) {
          goto LABEL_42;
        }
        unsigned int v20 = (v230 - 1) & ((v18 >> 4) ^ (v18 >> 9));
        uint64_t v21 = *(void *)(v229[0] + 40 * v20);
        if (v18 != v21)
        {
          int v46 = 1;
          while (v21 != -4096)
          {
            unsigned int v47 = v20 + v46++;
            unsigned int v20 = v47 & (v230 - 1);
            uint64_t v21 = *(void *)(v229[0] + 40 * v20);
            if (v18 == v21) {
              goto LABEL_37;
            }
          }
          goto LABEL_42;
        }
      }
LABEL_37:
      uint64_t v22 = *(unsigned int *)(v18 + 176);
      if (!v22 || *(_DWORD *)(v18 + 104)) {
        goto LABEL_42;
      }
      uint64_t v23 = *(void **)(v18 + 168);
      uint64_t v24 = 2;
      while (2 * v22 != v24)
      {
        uint64_t v25 = v23[v24];
        v24 += 2;
        if (v25 != *v23) {
          goto LABEL_42;
        }
      }
      int v26 = v225;
      uint64_t v27 = HIDWORD(v226);
      if (v225 == v224)
      {
        if (HIDWORD(v226))
        {
          uint64_t v28 = 0;
          uint64_t v29 = 8 * HIDWORD(v226);
          unint64_t v30 = (uint64_t *)v225;
          while (*v30 != v18)
          {
            if (*v30 == -2) {
              uint64_t v28 = v30;
            }
            ++v30;
            v29 -= 8;
            if (!v29)
            {
              if (!v28) {
                goto LABEL_54;
              }
              *uint64_t v28 = v18;
              --v227;
              goto LABEL_56;
            }
          }
          goto LABEL_42;
        }
LABEL_54:
        unsigned int v31 = v226;
        if (HIDWORD(v226) < v226)
        {
          ++HIDWORD(v226);
          *(void *)&v225[8 * v27] = v18;
LABEL_56:
          uint64_t v32 = *(void *)(v18 + 168);
          uint64_t v33 = v32 + 16 * v22;
          goto LABEL_84;
        }
      }
      else
      {
        unsigned int v31 = v226;
      }
      if (3 * v31 <= 4 * (HIDWORD(v226) - v227))
      {
        if (v31 >= 0x40) {
          v31 *= 2;
        }
        else {
          unsigned int v31 = 128;
        }
LABEL_93:
        llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v224, v31);
        unsigned int v31 = v226;
        int v26 = v225;
        goto LABEL_60;
      }
      if (v31 - HIDWORD(v226) < v31 >> 3) {
        goto LABEL_93;
      }
LABEL_60:
      unsigned int v34 = v31 - 1;
      unsigned int v35 = (v31 - 1) & ((v18 >> 4) ^ (v18 >> 9));
      uint64_t v36 = &v26[8 * v35];
      uint64_t v37 = *(void *)v36;
      if (*(void *)v36 != -1)
      {
        uint64_t v38 = 0;
        int v39 = 1;
        while (v37 != v18)
        {
          if (v38) {
            BOOL v40 = 0;
          }
          else {
            BOOL v40 = v37 == -2;
          }
          if (v40) {
            uint64_t v38 = (uint64_t *)v36;
          }
          unsigned int v41 = v35 + v39++;
          unsigned int v35 = v41 & v34;
          uint64_t v36 = &v26[8 * (v41 & v34)];
          uint64_t v37 = *(void *)v36;
          if (*(void *)v36 == -1) {
            goto LABEL_72;
          }
        }
LABEL_42:
        if (v263 >= (unint64_t)HIDWORD(v263)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v262 + v263) = v18;
        LODWORD(v263) = v263 + 1;
        goto LABEL_44;
      }
      uint64_t v38 = 0;
LABEL_72:
      if (v38) {
        unsigned int v42 = v38;
      }
      else {
        unsigned int v42 = (uint64_t *)v36;
      }
      if (*v42 == v18) {
        goto LABEL_42;
      }
      if (*v42 == -2) {
        --v227;
      }
      else {
        ++HIDWORD(v226);
      }
      uint64_t *v42 = v18;
      uint64_t v43 = *(unsigned int *)(v18 + 176);
      if (!v43) {
        goto LABEL_44;
      }
      uint64_t v32 = *(void *)(v18 + 168);
      uint64_t v33 = v32 + 16 * v43;
      do
      {
LABEL_84:
        int v45 = *(void **)v32;
        uint64_t v44 = sub_1CD8DD204((uint64_t)v219, *(void *)v32);
        if (v222 == v44)
        {
          uint64_t v252 = &v254;
          __b = (void *)0x300000000;
          long long v257 = v45;
          v258 = &v260;
          uint64_t v259 = 0x300000000;
          uint64_t v44 = sub_1CD8E6878((uint64_t)v219, (uint64_t *)&v257, (uint64_t)&v258);
          if (v258 != &v260) {
            free(v258);
          }
          if (v252 != &v254) {
            free(v252);
          }
        }
        sub_1CD324F38(v44 + 8, *(_DWORD *)(v32 + 8), v18);
        v32 += 16;
      }
      while (v32 != v33);
LABEL_44:
      ++v10;
    }
    while (v10 != v11);
    if (v263)
    {
      uint64_t v48 = (void **)v262;
      uint64_t v49 = 8 * v263;
      do
      {
        unint64_t v50 = *v48++;
        long long v257 = v50;
        sub_1CD8DD398((uint64_t)v231, (uint64_t *)&v257);
        v49 -= 8;
      }
      while (v49);
    }
    uint64_t v51 = v221;
    uint64_t v52 = v222;
    unsigned int v5 = this;
    uint64_t v203 = v222;
    if (v221 != v222)
    {
      while (1)
      {
        long long v257 = &v259;
        v258 = (void *)0x600000000;
        if (llvm::slpvectorizer::BoUpSLP::canReorderOperands((uint64_t)v5, *(void *)v51, v51 + 8, v265, v266, (uint64_t)&v257))break; {
        uint64_t v53 = *(unsigned int *)(v51 + 16);
        }
        if (v53)
        {
          uint64_t v54 = 16 * v53;
          unsigned int v55 = (uint64_t *)(*(void *)(v51 + 8) + 8);
          do
          {
            sub_1CD8DD398((uint64_t)v231, v55);
            v55 += 2;
            v54 -= 16;
          }
          while (v54);
        }
LABEL_110:
        if (v257 != &v259) {
          free(v257);
        }
        v51 += 72;
        unsigned int v5 = this;
        if (v51 == v52) {
          goto LABEL_102;
        }
      }
      v214[0] = 0;
      v214[1] = 0;
      unsigned int v215 = 0;
      uint64_t v217 = 0;
      uint64_t v218 = 0;
      uint64_t v216 = 0;
      uint64_t v252 = v256;
      __b = v256;
      uint64_t v254 = 4;
      int v255 = 0;
      v209 = v213;
      unsigned int v210 = v213;
      uint64_t v211 = 4;
      int v212 = 0;
      uint64_t v56 = *(unsigned int *)(v51 + 16);
      if (!v56)
      {
LABEL_115:
        if (v210 != v209) {
          free(v210);
        }
        if (__b != v252) {
          free(__b);
        }
        uint64_t v252 = &v216;
        sub_1CCCF7D58((void ***)&v252);
        sub_1CD8E19B8(v214[0], v215);
        MEMORY[0x1D25D9CD0](v214[0], 8);
        goto LABEL_110;
      }
      uint64_t v57 = *(void *)(v51 + 8);
      uint64_t v58 = v57 + 16 * v56;
      uint64_t v59 = this;
      while (2)
      {
        uint64_t v60 = *(void *)(v57 + 8);
        unsigned int v61 = (char *)__b;
        uint64_t v62 = HIDWORD(v254);
        if (__b == v252)
        {
          if (HIDWORD(v254))
          {
            BOOL v63 = 0;
            uint64_t v64 = 8 * HIDWORD(v254);
            uint64_t v65 = (uint64_t *)__b;
            do
            {
              if (*v65 == v60) {
                goto LABEL_156;
              }
              if (*v65 == -2) {
                BOOL v63 = v65;
              }
              ++v65;
              v64 -= 8;
            }
            while (v64);
            if (v63)
            {
              *BOOL v63 = v60;
              --v255;
              goto LABEL_153;
            }
          }
          unsigned int v66 = v254;
          if (HIDWORD(v254) < v254)
          {
            ++HIDWORD(v254);
            *((void *)__b + v62) = v60;
            goto LABEL_153;
          }
        }
        else
        {
          unsigned int v66 = v254;
        }
        if (3 * v66 <= 4 * (HIDWORD(v254) - v255))
        {
          if (v66 >= 0x40) {
            v66 *= 2;
          }
          else {
            unsigned int v66 = 128;
          }
        }
        else if (v66 - HIDWORD(v254) >= v66 >> 3)
        {
          goto LABEL_134;
        }
        llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v252, v66);
        unsigned int v66 = v254;
        unsigned int v61 = (char *)__b;
LABEL_134:
        unsigned int v67 = v66 - 1;
        unsigned int v68 = (v66 - 1) & ((v60 >> 4) ^ (v60 >> 9));
        uint64_t v69 = &v61[8 * v68];
        uint64_t v70 = *(void *)v69;
        if (*(void *)v69 != -1)
        {
          uint64_t v71 = 0;
          int v72 = 1;
          while (v70 != v60)
          {
            if (v71) {
              BOOL v73 = 0;
            }
            else {
              BOOL v73 = v70 == -2;
            }
            if (v73) {
              uint64_t v71 = (uint64_t *)v69;
            }
            unsigned int v74 = v68 + v72++;
            unsigned int v68 = v74 & v67;
            uint64_t v69 = &v61[8 * (v74 & v67)];
            uint64_t v70 = *(void *)v69;
            if (*(void *)v69 == -1) {
              goto LABEL_146;
            }
          }
          goto LABEL_156;
        }
        uint64_t v71 = 0;
LABEL_146:
        if (v71) {
          uint64_t v75 = v71;
        }
        else {
          uint64_t v75 = (uint64_t *)v69;
        }
        if (*v75 == v60) {
          goto LABEL_156;
        }
        if (*v75 == -2) {
          --v255;
        }
        else {
          ++HIDWORD(v254);
        }
        *uint64_t v75 = v60;
LABEL_153:
        if (*(_DWORD *)(v60 + 104) || a2 && v60 == **(void **)v59)
        {
LABEL_156:
          v57 += 16;
          if (v57 != v58) {
            continue;
          }
          if (v216 == v217)
          {
            uint64_t v148 = *(unsigned int *)(v51 + 16);
            uint64_t v52 = v203;
            if (v148)
            {
              uint64_t v149 = 16 * v148;
              int v150 = (uint64_t *)(*(void *)(v51 + 8) + 8);
              do
              {
                sub_1CD8DD398((uint64_t)v231, v150);
                v150 += 2;
                v149 -= 16;
              }
              while (v149);
            }
            goto LABEL_115;
          }
          v151 = *(unsigned int **)v216;
          unint64_t v152 = *(unsigned int *)(v216 + 8);
          uint64_t v153 = v216 + 40;
          if (v216 + 40 == v217)
          {
LABEL_319:
            if (!v152)
            {
              uint64_t v154 = *(unsigned int *)(v51 + 16);
              uint64_t v52 = v203;
              if (v154)
              {
                uint64_t v155 = 16 * v154;
                v156 = (uint64_t *)(*(void *)(v51 + 8) + 8);
                do
                {
                  sub_1CD8DD398((uint64_t)v231, v156);
                  v156 += 2;
                  v155 -= 16;
                }
                while (v155);
              }
              goto LABEL_115;
            }
            if (__b == v252)
            {
LABEL_334:
              int v255 = 0;
              HIDWORD(v254) = 0;
            }
            else
            {
              if (v254 < 0x21 || 4 * (HIDWORD(v254) - v255) >= v254)
              {
                memset(__b, 255, 8 * v254);
                goto LABEL_334;
              }
              llvm::SmallPtrSetImplBase::shrink_and_clear(&v252);
            }
            uint64_t v248 = v250;
            unint64_t v249 = 0xC00000000;
            if (v152 >= 0xDuLL) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            memset(v250, 255, 4 * v152);
            LODWORD(v249) = v249 + v152;
            uint64_t v159 = 0;
            do
            {
              v250[v151[v159]] = v159;
              ++v159;
            }
            while (v152 != v159);
            int v160 = (int *)v238;
            unsigned int v236 = v238;
            HIDWORD(v237) = 12;
            uint64_t v161 = 4 * v152;
            if (v152 > 0xC)
            {
              LODWORD(v237) = 0;
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            memset(v238, 255, 4 * v152);
            LODWORD(v237) = v152;
            do
            {
              unsigned int v163 = *v151++;
              int v162 = v163;
              if (v163 >= v152) {
                int v162 = -1;
              }
              *v160++ = v162;
              v161 -= 4;
            }
            while (v161);
            uint64_t v164 = *(unsigned int *)(v51 + 16);
            if (!v164)
            {
LABEL_346:
              uint64_t v52 = v203;
              if (v258)
              {
                int v190 = (_DWORD **)v257;
                uint64_t v191 = 8 * v258;
                do
                {
                  BOOL v192 = *v190;
                  int v240 = v192;
                  if (v192[26])
                  {
                    sub_1CD324794(v192 + 24, (int *)v248);
                  }
                  else
                  {
                    sub_1CD324A9C((uint64_t)v192, (llvm::Type *)v248);
                    sub_1CD8DD398((uint64_t)v231, (uint64_t *)&v240);
                  }
                  ++v190;
                  v191 -= 8;
                }
                while (v191);
              }
              uint64_t v165 = *(void *)v51;
              if (*(_DWORD *)(*(void *)v51 + 88)
                || ((uint64_t v166 = *(void *)(v165 + 384),
                     unsigned int v167 = *(unsigned __int8 *)(v166 + 16) - 60,
                     BOOL v168 = v167 > 0x20,
                     uint64_t v169 = (1 << v167) & 0x120000001,
                     !v168)
                  ? (BOOL v170 = v169 == 0)
                  : (BOOL v170 = 1),
                    v170 || v166 != *(void *)(v165 + 392)))
              {
                uint64_t v171 = *(unsigned int *)(v165 + 216);
                if (v171)
                {
                  v193 = (llvm::Type *)v248;
                  uint64_t v194 = *(void *)(v165 + 208);
                  uint64_t v195 = 80 * v171;
                  do
                  {
                    sub_1CD324A9C(v194, v193);
                    v194 += 80;
                    v195 -= 80;
                  }
                  while (v195);
                  uint64_t v165 = *(void *)v51;
                  uint64_t v52 = v203;
                }
              }
              uint64_t v196 = *(void *)(v165 + 384);
              int v197 = *(unsigned __int8 *)(v196 + 16);
              if (v197 == 61 || v197 == 90)
              {
                v198 = (llvm::Type *)v248;
                if (v196 == *(void *)(v165 + 392))
                {
                  sub_1CD32486C(v165 + 128, (int *)v248, v249);
LABEL_418:
                  if (v236 != v238) {
                    free(v236);
                  }
                  if (v248 != v250) {
                    free(v248);
                  }
                  goto LABEL_115;
                }
              }
              else
              {
                v198 = (llvm::Type *)v248;
              }
              sub_1CD324A9C(v165, v198);
              sub_1CD32486C(*(void *)v51 + 128, (int *)v236, v237);
              uint64_t v199 = *(void *)v51;
              if (!*(_DWORD *)(*(void *)v51 + 104)
                && *(_DWORD *)(v199 + 136)
                && *(void *)(v199 + 384) == *(void *)(v199 + 392))
              {
                sub_1CC37AF14(v231, (uint64_t *)v51);
              }
              goto LABEL_418;
            }
            uint64_t v172 = *(void *)(v51 + 8);
            uint64_t v173 = v172 + 16 * v164;
            while (2)
            {
              BOOL v174 = *(_DWORD **)(v172 + 8);
              int v240 = v174;
              sub_1CD8DD398((uint64_t)v231, (uint64_t *)&v240);
              unsigned int v175 = (char *)__b;
              uint64_t v176 = HIDWORD(v254);
              if (__b == v252)
              {
                if (HIDWORD(v254))
                {
                  unint64_t v177 = 0;
                  uint64_t v178 = 8 * HIDWORD(v254);
                  v179 = __b;
                  while ((_DWORD *)*v179 != v174)
                  {
                    if (*v179 == -2) {
                      unint64_t v177 = v179;
                    }
                    ++v179;
                    v178 -= 8;
                    if (!v178)
                    {
                      if (!v177) {
                        goto LABEL_364;
                      }
                      *unint64_t v177 = v174;
                      --v255;
                      goto LABEL_388;
                    }
                  }
                  goto LABEL_392;
                }
LABEL_364:
                unsigned int v180 = v254;
                if (HIDWORD(v254) < v254)
                {
                  ++HIDWORD(v254);
                  *((void *)__b + v176) = v174;
                  goto LABEL_388;
                }
              }
              else
              {
                unsigned int v180 = v254;
              }
              if (3 * v180 <= 4 * (HIDWORD(v254) - v255))
              {
                if (v180 >= 0x40) {
                  v180 *= 2;
                }
                else {
                  unsigned int v180 = 128;
                }
              }
              else if (v180 - HIDWORD(v254) >= v180 >> 3)
              {
LABEL_369:
                unsigned int v181 = v180 - 1;
                unsigned int v182 = (v180 - 1) & ((v174 >> 4) ^ (v174 >> 9));
                unsigned int v183 = &v175[8 * v182];
                v184 = *(_DWORD **)v183;
                if (*(void *)v183 != -1)
                {
                  unint64_t v185 = 0;
                  int v186 = 1;
                  while (v184 != v174)
                  {
                    if (v185) {
                      BOOL v187 = 0;
                    }
                    else {
                      BOOL v187 = v184 == (_DWORD *)-2;
                    }
                    if (v187) {
                      unint64_t v185 = v183;
                    }
                    unsigned int v188 = v182 + v186++;
                    unsigned int v182 = v188 & v181;
                    unsigned int v183 = &v175[8 * (v188 & v181)];
                    v184 = *(_DWORD **)v183;
                    if (*(void *)v183 == -1) {
                      goto LABEL_381;
                    }
                  }
                  goto LABEL_392;
                }
                unint64_t v185 = 0;
LABEL_381:
                if (v185) {
                  unint64_t v189 = v185;
                }
                else {
                  unint64_t v189 = v183;
                }
                if (*(_DWORD **)v189 == v174)
                {
LABEL_392:
                  v172 += 16;
                  if (v172 == v173) {
                    goto LABEL_346;
                  }
                  continue;
                }
                if (*(void *)v189 == -2) {
                  --v255;
                }
                else {
                  ++HIDWORD(v254);
                }
                *(void *)unint64_t v189 = v174;
LABEL_388:
                if (v152 == v174[26])
                {
                  sub_1CD324794(v174 + 24, (int *)v248);
                }
                else if (!v174[22])
                {
                  sub_1CD32486C((unint64_t)(v174 + 32), (int *)v248, v249);
                }
                goto LABEL_392;
              }
              break;
            }
            llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v252, v180);
            unsigned int v180 = v254;
            unsigned int v175 = (char *)__b;
            goto LABEL_369;
          }
          unsigned int v157 = *(_DWORD *)(v216 + 32);
          while (2)
          {
            unsigned int v158 = *(_DWORD *)(v153 + 32);
            if (v157 < v158)
            {
              unint64_t v152 = *(unsigned int *)(v153 + 8);
              goto LABEL_327;
            }
            if (v157 == v158 && !*(_DWORD *)(v153 + 8))
            {
              unint64_t v152 = 0;
LABEL_327:
              v151 = *(unsigned int **)v153;
              unsigned int v157 = *(_DWORD *)(v153 + 32);
            }
            v153 += 40;
            if (v153 == v217) {
              goto LABEL_319;
            }
            continue;
          }
        }
        break;
      }
      if (*(_DWORD *)(v60 + 88) == 2)
      {
        uint64_t v248 = 0;
        uint64_t v76 = v229[0];
        unsigned int v77 = v230;
        int v78 = sub_1CD5101D0(v229[0], v230, v60, &v248);
        uint64_t v79 = (char *)v248;
        if (!v78) {
          uint64_t v79 = (char *)(v76 + 40 * v77);
        }
        uint64_t v80 = (void **)(v79 + 8);
      }
      else
      {
        uint64_t v80 = (void **)(v60 + 128);
      }
      uint64_t v81 = *(unsigned int *)(v51 + 16);
      if (v81)
      {
        int v82 = 0;
        uint64_t v83 = 16 * v81;
        int v84 = (uint64_t *)(*(void *)(v51 + 8) + 8);
        do
        {
          uint64_t v85 = *v84;
          v84 += 2;
          if (v85 == v60) {
            ++v82;
          }
          v83 -= 16;
        }
        while (v83);
      }
      else
      {
        int v82 = 0;
      }
      if (!*(_DWORD *)(v60 + 88)
        && ((v86 = *(void *)(v60 + 384)) != 0 ? (BOOL v87 = v86 == *(void *)(v60 + 392)) : (BOOL v87 = 0),
            v87 && *(unsigned char *)(v86 + 16) == 61 && (uint64_t v88 = *((unsigned int *)v80 + 2), v88)))
      {
        uint64_t v248 = v250;
        BOOL v135 = (unsigned int *)*v80;
        unint64_t v249 = 0xC00000000;
        if (v88 >= 0xD) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        BOOL v136 = v250;
        memset(v250, 255, 4 * v88);
        uint64_t v137 = 0;
        LODWORD(v249) = v249 + v88;
        do
        {
          v250[v135[v137]] = v137;
          ++v137;
        }
        while (v88 != v137);
        uint64_t v138 = *((unsigned int *)v80 + 2);
        __src = v247;
        int v246 = 4;
        if (v138 >= 5)
        {
          unsigned int v245 = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v138)
        {
          unint64_t v139 = v247;
          uint64_t v140 = v138;
          do
          {
            *v139++ = v138;
            --v140;
          }
          while (v140);
        }
        unsigned int v141 = v247;
        unsigned int v245 = v138;
        if (v249)
        {
          uint64_t v142 = 4 * v249;
          do
          {
            int v144 = *v136++;
            int v143 = v144;
            if (v144 == -1) {
              int v143 = v138;
            }
            *v141++ = v143;
            v142 -= 4;
          }
          while (v142);
        }
        sub_1CD3238B0((unint64_t)&__src);
        int v240 = v242;
        uint64_t v241 = 0x400000000;
        unint64_t v145 = v245;
        if (v245)
        {
          uint64_t v59 = this;
          if (v245 >= 5uLL) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          memcpy(v242, __src, 4 * v245);
          LODWORD(v241) = v145;
          int v243 = 0;
          unsigned int v236 = v238;
          unint64_t v237 = 0x400000000;
          if (v240 == v242)
          {
            if (v145 >= 5) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            memcpy(v238, v242, 4 * v145);
            LODWORD(v237) = v145;
            int v146 = v243;
          }
          else
          {
            int v146 = 0;
            unsigned int v236 = v240;
            unint64_t v237 = __PAIR64__(HIDWORD(v241), v145);
            int v240 = v242;
            HIDWORD(v241) = 0;
          }
          LODWORD(v241) = 0;
        }
        else
        {
          int v146 = 0;
          int v243 = 0;
          unsigned int v236 = v238;
          unint64_t v237 = 0x400000000;
          uint64_t v59 = this;
        }
        v239[0] = v146;
        uint64_t v147 = sub_1CD8E5F18((uint64_t)v214, (uint64_t)&v236, v239);
        *(_DWORD *)(v147 + 32) += v82;
        if (v236 != v238) {
          free(v236);
        }
        if (v240 != v242) {
          free(v240);
        }
        if (__src != v247) {
          free(__src);
        }
        unsigned int v93 = v248;
        if (v248 != v250) {
LABEL_190:
        }
          free(v93);
      }
      else
      {
        unsigned int v236 = v238;
        unint64_t v237 = 0x400000000;
        unint64_t v89 = *((unsigned int *)v80 + 2);
        if (v89) {
          BOOL v90 = &v236 != v80;
        }
        else {
          BOOL v90 = 0;
        }
        if (v90)
        {
          if (v89 >= 5) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          memcpy(v238, *v80, 4 * *((unsigned int *)v80 + 2));
          LODWORD(v237) = v89;
          v239[0] = 0;
          uint64_t v248 = v250;
          unint64_t v249 = 0x400000000;
          if (v236 == v238)
          {
            memcpy(v250, v238, 4 * v89);
            LODWORD(v249) = v89;
            int v91 = v239[0];
          }
          else
          {
            int v91 = 0;
            uint64_t v248 = v236;
            unint64_t v249 = __PAIR64__(HIDWORD(v237), v89);
            unsigned int v236 = v238;
            HIDWORD(v237) = 0;
          }
          LODWORD(v237) = 0;
        }
        else
        {
          int v91 = 0;
          v239[0] = 0;
          uint64_t v248 = v250;
          unint64_t v249 = 0x400000000;
        }
        v251[0] = v91;
        uint64_t v92 = sub_1CD8E5F18((uint64_t)v214, (uint64_t)&v248, v251);
        *(_DWORD *)(v92 + 32) += v82;
        if (v248 != v250) {
          free(v248);
        }
        unsigned int v93 = v236;
        if (v236 != v238) {
          goto LABEL_190;
        }
      }
      int v240 = v242;
      uint64_t v241 = 0x400000000;
      unsigned int v236 = v238;
      unint64_t v237 = 0x400000000;
      v239[0] = 0;
      uint64_t v248 = v250;
      unint64_t v249 = 0x400000000;
      v251[0] = 0;
      uint64_t v207 = sub_1CD8E5F18((uint64_t)v214, (uint64_t)&v248, v251);
      if (v248 != v250) {
        free(v248);
      }
      if (v236 != v238) {
        free(v236);
      }
      if (v240 != v242) {
        free(v240);
      }
      uint64_t v94 = *(unsigned int *)(v60 + 176);
      if (!v94) {
        goto LABEL_156;
      }
      uint64_t v95 = *(void ***)(v60 + 168);
      BOOL v96 = &v95[2 * v94];
      uint64_t v97 = v230;
      while (2)
      {
        unsigned int v98 = *v95;
        unsigned int v236 = *v95;
        unint64_t v99 = v210;
        uint64_t v100 = HIDWORD(v211);
        if (v210 != v209)
        {
          unsigned int v104 = v211;
          goto LABEL_210;
        }
        if (!HIDWORD(v211)) {
          goto LABEL_207;
        }
        int v101 = 0;
        uint64_t v102 = 8 * HIDWORD(v211);
        uint64_t v103 = v210;
        do
        {
          if ((_DWORD *)*v103 == v98) {
            goto LABEL_263;
          }
          if (*v103 == -2) {
            int v101 = v103;
          }
          ++v103;
          v102 -= 8;
        }
        while (v102);
        if (v101)
        {
          *int v101 = v98;
          --v212;
        }
        else
        {
LABEL_207:
          unsigned int v104 = v211;
          if (HIDWORD(v211) < v211)
          {
            ++HIDWORD(v211);
            *(void *)&v210[8 * v100] = v98;
            break;
          }
LABEL_210:
          if (3 * v104 <= 4 * (HIDWORD(v211) - v212))
          {
            if (v104 >= 0x40) {
              v104 *= 2;
            }
            else {
              unsigned int v104 = 128;
            }
          }
          else if (v104 - HIDWORD(v211) >= v104 >> 3)
          {
            goto LABEL_212;
          }
          uint64_t v134 = v97;
          llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v209, v104);
          uint64_t v97 = v134;
          unsigned int v104 = v211;
          unint64_t v99 = v210;
LABEL_212:
          unsigned int v105 = v104 - 1;
          unsigned int v106 = (v104 - 1) & ((v98 >> 4) ^ (v98 >> 9));
          v107 = &v99[8 * v106];
          unsigned int v108 = *(_DWORD **)v107;
          if (*(void *)v107 != -1)
          {
            unsigned int v109 = 0;
            int v110 = 1;
            while (v108 != v98)
            {
              if (v109) {
                BOOL v111 = 0;
              }
              else {
                BOOL v111 = v108 == (_DWORD *)-2;
              }
              if (v111) {
                unsigned int v109 = (void **)v107;
              }
              unsigned int v112 = v106 + v110++;
              unsigned int v106 = v112 & v105;
              v107 = &v99[8 * (v112 & v105)];
              unsigned int v108 = *(_DWORD **)v107;
              if (*(void *)v107 == -1) {
                goto LABEL_224;
              }
            }
            goto LABEL_263;
          }
          unsigned int v109 = 0;
LABEL_224:
          if (v109) {
            BOOL v113 = v109;
          }
          else {
            BOOL v113 = (void **)v107;
          }
          if (*v113 == v98)
          {
LABEL_263:
            v95 += 2;
            if (v95 == v96) {
              goto LABEL_156;
            }
            continue;
          }
          if (*v113 == (void *)-2) {
            --v212;
          }
          else {
            ++HIDWORD(v211);
          }
          *BOOL v113 = v98;
        }
        break;
      }
      if (v98[34]) {
        goto LABEL_263;
      }
      if (v98[26]) {
        goto LABEL_263;
      }
      int v114 = v98[22];
      if (!v114 && *((void *)v98 + 48) != *((void *)v98 + 49)) {
        goto LABEL_263;
      }
      if (a2 && !v98[50]) {
        goto LABEL_263;
      }
      if (v114 == 2)
      {
        uint64_t v248 = 0;
        uint64_t v204 = v229[0];
        uint64_t v115 = a2;
        uint64_t v116 = v97;
        int v117 = sub_1CD5101D0(v229[0], v97, (uint64_t)v98, &v248);
        uint64_t v97 = v116;
        a2 = v115;
        if (!v117 || v248 == (void *)(v204 + 40 * v97) || *((_DWORD *)v248 + 4)) {
          goto LABEL_263;
        }
      }
      uint64_t v206 = v97;
      uint64_t v118 = sub_1CD8DD278((uint64_t)v219, (uint64_t *)&v236);
      unint64_t v119 = *(unsigned int *)(v118 + 8);
      if (!v119)
      {
        unsigned int v120 = 0;
LABEL_272:
        uint64_t v59 = this;
        uint64_t v97 = v206;
        if (v120 <= v119 >> 1) {
          ++*(_DWORD *)(v207 + 32);
        }
        goto LABEL_263;
      }
      unsigned int v120 = 0;
      uint64_t v121 = *(void *)v118;
      uint64_t v122 = *(void *)v118 + 16 * v119;
      uint64_t v123 = v229[0];
      uint64_t v124 = v230;
      uint64_t v125 = v229[0] + 40 * v230;
      while (2)
      {
        uint64_t v126 = *(void *)(v121 + 8);
        if (*(_DWORD *)(v126 + 136)) {
          goto LABEL_244;
        }
        if (*(_DWORD *)(v126 + 104)) {
          goto LABEL_244;
        }
        int v132 = *(_DWORD *)(v126 + 88);
        if (!v132 && *(void *)(v126 + 384) != *(void *)(v126 + 392)) {
          goto LABEL_244;
        }
        if (a2 && !*(_DWORD *)(v126 + 200)) {
          goto LABEL_244;
        }
        if (v132 != 2) {
          goto LABEL_253;
        }
        uint64_t v248 = 0;
        uint64_t v205 = v124;
        uint64_t v201 = v123;
        unint64_t v202 = v119;
        uint64_t v200 = (void *)v125;
        int v133 = sub_1CD5101D0(v123, v124, v126, &v248);
        uint64_t v125 = (uint64_t)v200;
        uint64_t v123 = v201;
        uint64_t v124 = v205;
        unint64_t v119 = v202;
        if (!v133 || v248 == v200 || *((_DWORD *)v248 + 4))
        {
LABEL_244:
          uint64_t v127 = *(void *)(v121 + 8);
          uint64_t v128 = *(unsigned int *)(v127 + 176);
          if (v128)
          {
            uint64_t v129 = *(void ***)(v127 + 168);
            uint64_t v130 = 16 * v128;
            while (*v129 == v98)
            {
              v129 += 2;
              v130 -= 16;
              if (!v130) {
                goto LABEL_248;
              }
            }
            goto LABEL_253;
          }
LABEL_248:
          int v131 = 1;
        }
        else
        {
LABEL_253:
          int v131 = 0;
        }
        v120 += v131;
        v121 += 16;
        if (v121 == v122) {
          goto LABEL_272;
        }
        continue;
      }
    }
LABEL_102:
    if (v262 != v264) {
      free(v262);
    }
    sub_1CD8E1A94((uint64_t)v219);
    uint64_t v10 = v233;
    uint64_t v11 = v234;
  }
LABEL_17:
  if (a2)
  {
    uint64_t v12 = **(void **)v5;
    if (*(_DWORD *)(v12 + 136))
    {
      if (!*(_DWORD *)(v12 + 104)) {
        *(_DWORD *)(v12 + 136) = 0;
      }
    }
  }
  if (v225 != v224) {
    free(v225);
  }
  if (v265 != v267) {
    free(v265);
  }
  uint64_t v13 = v229[0];
  if (v230)
  {
    uint64_t v14 = 40 * v230;
    uint64_t v15 = v229[0] + 24;
    do
    {
      if ((*(void *)(v15 - 24) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t v16 = *(void **)(v15 - 16);
        if ((void *)v15 != v16) {
          free(v16);
        }
      }
      v15 += 40;
      v14 -= 40;
    }
    while (v14);
  }
  MEMORY[0x1D25D9CD0](v13, 8);
  return sub_1CD456CB4(v231);
}

unint64_t llvm::slpvectorizer::BoUpSLP::buildExternalUses(unint64_t result, uint64_t a2)
{
  unint64_t v38 = result;
  uint64_t v2 = *(unsigned int *)(result + 8);
  if (v2)
  {
    uint64_t v4 = *(uint64_t **)result;
    uint64_t v39 = *(void *)result + 8 * v2;
    unsigned int v5 = (uint64_t *)(result + 1048);
    unint64_t v36 = result + 1072;
    uint64_t v37 = result + 80;
    while (1)
    {
      uint64_t v6 = *v4;
      if (*(_DWORD *)(*v4 + 88) != 2)
      {
        uint64_t v7 = *(unsigned int *)(v6 + 8);
        if (v7) {
          break;
        }
      }
LABEL_49:
      if (++v4 == (uint64_t *)v39) {
        return result;
      }
    }
    uint64_t v8 = 0;
    while (1)
    {
      uint64_t v9 = *(void *)(*(void *)v6 + 8 * v8);
      int v10 = sub_1CD8DD454(v6, v9);
      uint64_t result = sub_1CD8DD4F0(a2, v9);
      if (*(void *)(a2 + 32) != result) {
        uint64_t result = sub_1CD8DD56C(v36, v9, v10);
      }
      uint64_t v11 = *(void *)(v9 + 8);
      if (v11) {
        break;
      }
LABEL_48:
      if (++v8 == v7) {
        goto LABEL_49;
      }
    }
    while (1)
    {
      uint64_t v12 = *(void *)(v11 + 24);
      if (v12 && *(unsigned __int8 *)(v12 + 16) >= 0x1Cu)
      {
        v40[0] = *(void *)(v11 + 24);
        uint64_t v42 = 0;
        uint64_t result = sub_1CD50F704(v5, v40, &v42);
        if ((result & 1) == 0)
        {
          v40[0] = 0;
          uint64_t result = sub_1CD4C64C4(v37, v12, v40);
          if ((result & 1) == 0 || (uint64_t v14 = *(void *)(v40[0] + 8)) == 0)
          {
LABEL_25:
            uint64_t v17 = *(void *)(v38 + 1904);
            uint64_t v18 = *(void *)(v38 + 1912);
            if (v18)
            {
              uint64_t v19 = 8 * v18;
              unsigned int v20 = *(void **)(v38 + 1904);
              while (*v20 != v12)
              {
                ++v20;
                v19 -= 8;
                if (!v19)
                {
                  unsigned int v20 = (void *)(v17 + 8 * v18);
                  break;
                }
              }
            }
            else
            {
              unsigned int v20 = *(void **)(v38 + 1904);
            }
            if (v18 == ((uint64_t)v20 - v17) >> 3)
            {
              v40[0] = v9;
              v40[1] = v12;
              int v41 = v10;
              uint64_t result = sub_1CD483108(v36, (unint64_t)v40);
              uint64_t v21 = *(void *)(v38 + 1072) + 24 * *(unsigned int *)(v38 + 1080);
              long long v22 = *(_OWORD *)result;
              *(void *)(v21 + 16) = *(void *)(result + 16);
              *(_OWORD *)uint64_t v21 = v22;
              ++*(_DWORD *)(v38 + 1080);
            }
            goto LABEL_13;
          }
          if (**(void **)v14 == v12 && *(_DWORD *)(v14 + 88) != 1) {
            break;
          }
        }
      }
LABEL_13:
      uint64_t v11 = *(void *)(v11 + 8);
      if (!v11) {
        goto LABEL_48;
      }
    }
    int v15 = *(unsigned __int8 *)(v12 + 16);
    if (v15 != 60)
    {
      if (v15 == 84)
      {
        uint64_t result = (unint64_t)llvm::getVectorIntrinsicIDForCall(v12, *(uint64_t **)(v38 + 1944));
        unsigned int v33 = result;
        int v23 = *(unsigned __int8 *)(v12 + 16);
        if (v23 == 84)
        {
          uint64_t v24 = 0;
        }
        else if (v23 == 39)
        {
          uint64_t v24 = (*(_DWORD *)(v12 + 80) + 1);
        }
        else
        {
          uint64_t v24 = 2;
        }
        int v25 = *(_DWORD *)(v12 + 20);
        if (v25 < 0 && (uint64_t v30 = v12 - 32 * (v25 & 0x7FFFFFF), v31 = *(void *)(v30 - 8), (v31 & 0xFFFFFFFF0) != 0))
        {
          uint64_t v27 = -(uint64_t)(v25 & 0x7FFFFFF);
          int v26 = *(_DWORD *)(v30 - 12) - *(_DWORD *)(v30 - v31);
        }
        else
        {
          int v26 = 0;
          uint64_t v27 = -(uint64_t)(v25 & 0x7FFFFFF);
        }
        uint64_t v28 = (uint64_t *)(v12 + 32 * v27);
        unint64_t v32 = (v12 - 32 * v24 + 32 * (unint64_t)-v26 - (unint64_t)v28 - 32) >> 5;
        if (!v32) {
          goto LABEL_13;
        }
        int v29 = 0;
        while (1)
        {
          unsigned int v35 = v28;
          int v34 = v29;
          uint64_t result = llvm::hasVectorInstrinsicScalarOpd((llvm *)v33, v29);
          if (result) {
            break;
          }
          int v29 = v34 + 1;
          uint64_t v28 = v35 + 4;
          if (v32 == v34 + 1) {
            goto LABEL_13;
          }
        }
        uint64_t v16 = *v35;
        goto LABEL_24;
      }
      if (v15 != 61) {
        goto LABEL_13;
      }
    }
    uint64_t v16 = *(void *)(v12 - 32);
LABEL_24:
    if (v16 == v9) {
      goto LABEL_25;
    }
    goto LABEL_13;
  }
  return result;
}

void llvm::slpvectorizer::BoUpSLP::buildTree(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  sub_1CD8DD5F8(a1);
  *(void *)(a1 + 1904) = a4;
  *(void *)(a1 + 1912) = a5;
  if ((int)a3 < 2)
  {
LABEL_5:
    *(void *)&long long v12 = 0;
    *((void *)&v12 + 1) = 0xFFFFFFFFLL;
    llvm::slpvectorizer::BoUpSLP::buildTree_rec(a1, a2, a3, 0, &v12);
  }
  else
  {
    int v10 = (void **)(a2 + 1);
    uint64_t v11 = a3 - 1;
    while (**v10 == *(void *)*a2)
    {
      ++v10;
      if (!--v11) {
        goto LABEL_5;
      }
    }
  }
}

void llvm::slpvectorizer::BoUpSLP::buildTree_rec(uint64_t a1, uint64_t *a2, uint64_t a3, int a4, _OWORD *a5)
{
  v69[6] = *MEMORY[0x1E4F143B8];
  *(void *)uint64_t v62 = a2;
  *(void *)BOOL v63 = a3;
  unsigned int v67 = v69;
  uint64_t v68 = 0xC00000000;
  v65[0] = v66;
  v65[1] = (void *)0x600000000;
  v61[0] = v62;
  v61[1] = &v67;
  v61[2] = v65;
  v61[3] = a5;
  v61[4] = a1;
  sub_1CD32A408((uint64_t)&v59, a2, a3);
  if (dword_1EBD01C10 == a4)
  {
LABEL_2:
    if (sub_1CD32A8E4(v61, (int)&v59)) {
      sub_1CD32B230(a1, v62[0], v63[0], 2, 0, 0, (int)&v59, (int)a5, v67, v68, 0, 0);
    }
    goto LABEL_44;
  }
  uint64_t v10 = v60;
  if (v60)
  {
    uint64_t v11 = v59;
    if (*(unsigned char *)(v60 + 16) == 89 && *(unsigned char *)(**((void **)v59 - 8) + 8) == 19) {
      goto LABEL_2;
    }
  }
  else
  {
    uint64_t v11 = v59;
  }
  int v12 = v11[16];
  if ((*(_DWORD *)(*(void *)v11 + 8) & 0xFE) == 0x12)
  {
    if (v12 == 90) {
      goto LABEL_16;
    }
LABEL_14:
    *(_OWORD *)__src = 0u;
    *(_OWORD *)uint64_t v57 = 0u;
    int v13 = a1;
LABEL_15:
    int v14 = (int)a2;
    int v15 = a3;
    goto LABEL_43;
  }
  if (v12 == 61 && (*(_DWORD *)(**((void **)v11 - 8) + 8) & 0xFE) == 0x12) {
    goto LABEL_14;
  }
LABEL_16:
  uint64_t v58 = a1;
  if (!a3) {
    goto LABEL_41;
  }
  uint64_t v16 = 8 * a3;
  uint64_t v17 = 8 * a3;
  uint64_t v18 = a2;
  while (1)
  {
    int v19 = *(unsigned __int8 *)(*v18 + 16);
    if (v19 == 5 || (v19 - 4) >= 0x11) {
      break;
    }
    ++v18;
    v17 -= 8;
    if (!v17) {
      goto LABEL_41;
    }
  }
  uint64_t v21 = 0;
  uint64_t v22 = 8 * a3;
  int v23 = a2;
  do
  {
    if (*(unsigned __int8 *)(*v23 + 16) - 11 >= 2)
    {
      if (v21)
      {
        if (*v23 != v21) {
          goto LABEL_32;
        }
      }
      else
      {
        uint64_t v21 = *v23;
      }
    }
    ++v23;
    v22 -= 8;
  }
  while (v22);
  if (v21)
  {
LABEL_41:
    if (sub_1CD32A8E4(v61, (int)&v59)) {
      goto LABEL_42;
    }
    goto LABEL_44;
  }
LABEL_32:
  int v24 = sub_1CD32AB9C(a2, a3);
  if (!v10 || !v24) {
    goto LABEL_41;
  }
  int v25 = *(unsigned __int8 *)(v10 + 16);
  if ((v25 - 89) <= 3 && v25 != 91)
  {
    int v26 = a2;
    while (sub_1CD32AC64(*v26))
    {
      ++v26;
      v16 -= 8;
      if (!v16) {
        goto LABEL_49;
      }
    }
    goto LABEL_41;
  }
  if (v25 == 28) {
    goto LABEL_41;
  }
LABEL_49:
  uint64_t v27 = *(void *)(v58 + 1480);
  uint64_t v28 = *(void *)(v58 + 1472);
  if (v27 == v28) {
    int v29 = (unsigned int *)(v58 + 1492);
  }
  else {
    int v29 = (unsigned int *)(v58 + 1488);
  }
  uint64_t v30 = *(void *)(v58 + 1480);
  uint64_t v31 = a2;
  do
  {
    uint64_t v32 = *v31;
    if (v30 == v28)
    {
      uint64_t v33 = *(unsigned int *)(v58 + 1492);
      int v34 = (void *)(v28 + 8 * v33);
      if (v33)
      {
        uint64_t v35 = 0;
        uint64_t v36 = 8 * v33;
        while (*(void *)(v28 + v35) != v32)
        {
          v35 += 8;
          if (v36 == v35) {
            goto LABEL_71;
          }
        }
        int v34 = (void *)(v28 + v35);
      }
LABEL_71:
      uint64_t v30 = *(void *)(v58 + 1472);
    }
    else
    {
      int v37 = *(_DWORD *)(v58 + 1488) - 1;
      unsigned int v38 = v37 & ((v32 >> 4) ^ (v32 >> 9));
      int v34 = (void *)(v27 + 8 * v38);
      uint64_t v39 = *v34;
      if (*v34 == -1)
      {
        BOOL v40 = 0;
LABEL_73:
        if (v40) {
          int v34 = v40;
        }
        if (*v34 != v32) {
          int v34 = (void *)(v27 + 8 * *v29);
        }
      }
      else
      {
        BOOL v40 = 0;
        int v41 = 1;
        while (v39 != v32)
        {
          if (v40) {
            BOOL v42 = 0;
          }
          else {
            BOOL v42 = v39 == -2;
          }
          if (v42) {
            BOOL v40 = v34;
          }
          unsigned int v43 = v38 + v41++;
          unsigned int v38 = v43 & v37;
          int v34 = (void *)(v27 + 8 * (v43 & v37));
          uint64_t v39 = *v34;
          if (*v34 == -1) {
            goto LABEL_73;
          }
        }
      }
      uint64_t v30 = *(void *)(v58 + 1480);
    }
    if (v30 == v28) {
      uint64_t v44 = (unsigned int *)(v58 + 1492);
    }
    else {
      uint64_t v44 = (unsigned int *)(v58 + 1488);
    }
    if (v34 != (void *)(v30 + 8 * *v44))
    {
      *(_OWORD *)__src = 0u;
      *(_OWORD *)uint64_t v57 = 0u;
      int v13 = v58;
      goto LABEL_15;
    }
    ++v31;
  }
  while (v31 != &a2[a3]);
  uint64_t v64 = 0;
  if (sub_1CD4C64C4(v58 + 80, (uint64_t)v11, &v64))
  {
    uint64_t v45 = *((void *)v64 + 1);
    if (v45)
    {
      if (sub_1CD8DD67C(*((void *)v64 + 1), *(uint64_t **)v62, *(unint64_t *)v63))
      {
        unsigned int v55 = *(_DWORD *)(v45 + 176);
        if (v55 >= *(_DWORD *)(v45 + 180)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(_OWORD *)(*(void *)(v45 + 168) + 16 * v55) = *a5;
        ++*(_DWORD *)(v45 + 176);
        goto LABEL_44;
      }
      goto LABEL_41;
    }
  }
  if (!*(void *)v63) {
    goto LABEL_108;
  }
  int v46 = *(uint64_t **)v62;
  uint64_t v47 = 8 * *(void *)v63;
  do
  {
    uint64_t v48 = *v46;
    if (*v46) {
      BOOL v49 = *(unsigned __int8 *)(*v46 + 16) >= 0x1Cu;
    }
    else {
      BOOL v49 = 0;
    }
    if (v49)
    {
      uint64_t v64 = 0;
      if (sub_1CD4C64C4(v58 + 80, v48, &v64))
      {
        if (*((void *)v64 + 1)) {
          goto LABEL_95;
        }
      }
    }
    ++v46;
    v47 -= 8;
  }
  while (v47);
  if (!*(void *)v63) {
LABEL_108:
  }
    llvm::DominatorTreeBase<llvm::BasicBlock,false>::isReachableFromEntry();
  unint64_t v50 = *(uint64_t **)v62;
  uint64_t v51 = *(void *)(v58 + 1904);
  uint64_t v52 = *(void *)(v58 + 1912);
  while (1)
  {
    if (v52)
    {
      uint64_t v53 = 8 * v52;
      uint64_t v54 = *(void **)(v58 + 1904);
      while (*v54 != *v50)
      {
        ++v54;
        v53 -= 8;
        if (!v53)
        {
          uint64_t v54 = (void *)(v51 + 8 * v52);
          break;
        }
      }
    }
    else
    {
      uint64_t v54 = *(void **)(v58 + 1904);
    }
    if (v52 != ((uint64_t)v54 - v51) >> 3) {
      break;
    }
    if (++v50 == (uint64_t *)(*(void *)v62 + 8 * *(void *)v63)) {
      goto LABEL_108;
    }
  }
LABEL_95:
  if (sub_1CD32A8E4(v61, (int)&v59))
  {
LABEL_42:
    int v14 = v62[0];
    int v15 = v63[0];
    *(_OWORD *)uint64_t v57 = 0uLL;
    __src[0] = v67;
    __src[1] = (void *)v68;
    int v13 = v58;
LABEL_43:
    sub_1CD32B230(v13, v14, v15, 2, 0, 0, (int)&v59, (int)a5, __src[0], (uint64_t)__src[1], v57[0], v57[1]);
  }
LABEL_44:
  if (v65[0] != v66) {
    free(v65[0]);
  }
  if (v67 != v69) {
    free(v67);
  }
}

uint64_t sub_1CD32A408(uint64_t result, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = (void *)result;
  if (!a3)
  {
LABEL_5:
    uint64_t v6 = *a2;
    unsigned int v7 = *(unsigned __int8 *)(*a2 + 16);
    BOOL v8 = v7 - 66 < 0xD && v7 > 0x1B;
    BOOL v9 = v7 - 41 < 0x12 && v7 > 0x1B;
    uint64_t v10 = v7 - 81 < 2 && v7 > 0x1B;
    if (v10 == 1) {
      uint64_t v11 = *(_WORD *)(v6 + 18) & 0x3F;
    }
    else {
      uint64_t v11 = 42;
    }
    uint64_t v12 = *a2;
    if ((int)a3 < 1)
    {
LABEL_109:
      void *v4 = v12;
      v4[1] = v12;
      v4[2] = v6;
      return result;
    }
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = v7 - 28;
    uint64_t v16 = a3;
    unsigned int v17 = v7 - 28;
    uint64_t v18 = &unk_1CFB33A68;
    while (1)
    {
      uint64_t v19 = a2[v13];
      unsigned int v20 = *(unsigned __int8 *)(v19 + 16);
      unsigned int v21 = v20 - 28;
      if (v9)
      {
        BOOL v22 = v20 < 0x1C || v20 - 41 > 0x11;
        if (!v22) {
          break;
        }
      }
      if (v8 && v20 >= 0x1C && v20 - 66 <= 0xC)
      {
        uint64_t v29 = *a2;
        int v30 = *(_DWORD *)(*a2 + 20);
        if ((v30 & 0x40000000) != 0) {
          uint64_t v31 = *(void ***)(v29 - 8);
        }
        else {
          uint64_t v31 = (void **)(v29 - 32 * (v30 & 0x7FFFFFF));
        }
        int v35 = *(_DWORD *)(v19 + 20);
        if ((v35 & 0x40000000) != 0) {
          uint64_t v36 = *(void ***)(v19 - 8);
        }
        else {
          uint64_t v36 = (void **)(v19 - 32 * (v35 & 0x7FFFFFF));
        }
        if (**v31 != **v36) {
          goto LABEL_108;
        }
        if (v20 == v7 || v21 == v17) {
          goto LABEL_70;
        }
        if (v15 != v17) {
          goto LABEL_108;
        }
LABEL_69:
        uint64_t v14 = v13;
        unsigned int v17 = v21;
        goto LABEL_70;
      }
      if (!v10 || (v20 >= 0x1C ? (BOOL v24 = v20 - 81 > 1) : (BOOL v24 = 1), v24))
      {
        BOOL v25 = v20 == v7 || v21 == v17;
        if (!v25) {
          goto LABEL_108;
        }
        goto LABEL_70;
      }
      uint64_t v32 = *a2;
      int v33 = *(_DWORD *)(*a2 + 20);
      if ((v33 & 0x40000000) != 0) {
        int v34 = *(void ***)(v32 - 8);
      }
      else {
        int v34 = (void **)(v32 - 32 * (v33 & 0x7FFFFFF));
      }
      int v38 = *(_DWORD *)(v19 + 20);
      if ((v38 & 0x40000000) != 0) {
        uint64_t v39 = *(void ***)(v19 - 8);
      }
      else {
        uint64_t v39 = (void **)(v19 - 32 * (v38 & 0x7FFFFFF));
      }
      if (**v34 != **v39) {
        goto LABEL_108;
      }
      if ((v33 & 0x40000000) != 0) {
        BOOL v40 = *(uint64_t **)(v32 - 8);
      }
      else {
        BOOL v40 = (uint64_t *)(v32 - 32 * (v33 & 0x7FFFFFF));
      }
      uint64_t v41 = *(_WORD *)(v19 + 18) & 0x3F;
      int v42 = v18[v41];
      if (v20 != v7)
      {
LABEL_95:
        if (v14 || v11 == v41)
        {
          if (v11 != v41)
          {
            int v56 = *(_WORD *)(a2[v14] + 18) & 0x3F;
            BOOL v57 = v11 == v42 || v56 == v41;
            if (!v57 && v42 != v56) {
              goto LABEL_108;
            }
          }
        }
        else
        {
          uint64_t v14 = v13;
        }
        goto LABEL_70;
      }
      unsigned int v74 = v4;
      uint64_t v75 = v14;
      uint64_t v43 = *v40;
      int v73 = v18[v41];
      if (v11 == v41)
      {
        BOOL v62 = v8;
        uint64_t v66 = v16;
        uint64_t v69 = a3;
        uint64_t v44 = v10;
        uint64_t v45 = v11;
        uint64_t v46 = v15;
        uint64_t v47 = v18;
        uint64_t v60 = *v40;
        uint64_t result = sub_1CD32B748(v43);
        uint64_t v43 = v60;
        int v42 = v73;
        uint64_t v14 = v75;
        uint64_t v18 = v47;
        uint64_t v16 = v66;
        a3 = v69;
        uint64_t v15 = v46;
        uint64_t v11 = v45;
        uint64_t v10 = v44;
        BOOL v8 = v62;
        if (result) {
          goto LABEL_91;
        }
      }
      unsigned int v64 = v15;
      unsigned int v65 = v11;
      if (v11 == v42)
      {
        unsigned int v70 = v10;
        uint64_t v48 = a3;
        uint64_t result = sub_1CD32B748(v43);
        a3 = v48;
        if (v48 == 2)
        {
          uint64_t v4 = v74;
          uint64_t v14 = v75;
          uint64_t v10 = v70;
          uint64_t v15 = v64;
          uint64_t v11 = v65;
          uint64_t v18 = &unk_1CFB33A68;
          goto LABEL_70;
        }
        uint64_t v10 = v70;
        uint64_t v15 = v64;
        uint64_t v11 = v65;
        uint64_t v18 = &unk_1CFB33A68;
        uint64_t v14 = v75;
        if (result)
        {
LABEL_91:
          uint64_t v4 = v74;
          goto LABEL_70;
        }
      }
      else if (a3 == 2 && v11 == v41)
      {
        goto LABEL_91;
      }
      uint64_t v49 = a2[v14];
      int v50 = *(_WORD *)(v49 + 18) & 0x3F;
      uint64_t v51 = *(void *)(v49 - 64);
      if (v50 == v41)
      {
        BOOL v63 = v8;
        uint64_t v67 = v16;
        uint64_t v71 = a3;
        uint64_t v52 = v10;
        uint64_t v53 = v18;
        uint64_t v61 = *(void *)(v49 - 64);
        uint64_t result = sub_1CD32B748(v61);
        uint64_t v51 = v61;
        uint64_t v14 = v75;
        uint64_t v18 = v53;
        uint64_t v16 = v67;
        a3 = v71;
        uint64_t v15 = v64;
        uint64_t v11 = v65;
        uint64_t v10 = v52;
        BOOL v8 = v63;
        if (result) {
          goto LABEL_91;
        }
      }
      int v42 = v73;
      BOOL v25 = v73 == v50;
      uint64_t v4 = v74;
      if (!v25) {
        goto LABEL_95;
      }
      uint64_t v68 = v16;
      uint64_t v72 = a3;
      uint64_t v54 = v10;
      unsigned int v55 = v18;
      uint64_t result = sub_1CD32B748(v51);
      int v42 = v73;
      uint64_t v14 = v75;
      uint64_t v18 = v55;
      uint64_t v16 = v68;
      a3 = v72;
      uint64_t v15 = v64;
      uint64_t v11 = v65;
      uint64_t v10 = v54;
      if ((result & 1) == 0) {
        goto LABEL_95;
      }
LABEL_70:
      if (v16 == ++v13)
      {
        uint64_t v12 = *a2;
        uint64_t v6 = a2[v14];
        goto LABEL_109;
      }
    }
    if (v20 == v7 || v21 == v17) {
      goto LABEL_70;
    }
    if (v15 != v17) {
      goto LABEL_108;
    }
    BOOL v22 = v20 > 0x33;
    uint64_t v27 = (1 << v20) & 0xD800000000000;
    BOOL v28 = v22 || v27 == 0;
    if (!v28 || v7 <= 0x33 && ((1 << v7) & 0xD800000000000) != 0) {
      goto LABEL_108;
    }
    goto LABEL_69;
  }
  uint64_t v5 = 0;
  while (*(unsigned __int8 *)(a2[v5] + 16) > 0x1Bu)
  {
    if (a3 == ++v5) {
      goto LABEL_5;
    }
  }
LABEL_108:
  uint64_t v59 = *a2;
  v4[1] = 0;
  v4[2] = 0;
  void *v4 = v59;
  return result;
}

uint64_t sub_1CD32A8E4(void *a1, int a2)
{
  uint64_t v4 = a1[4];
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  int v32 = 0;
  uint64_t v5 = *a1;
  uint64_t v6 = *(void *)(*a1 + 8);
  if (v6)
  {
    unsigned int v7 = *(uint64_t **)v5;
    uint64_t v8 = 8 * v6;
    while (1)
    {
      uint64_t v29 = *v7;
      int v9 = *(unsigned __int8 *)(v29 + 16);
      if (v9 == 5 || (v9 - 4) > 0x10)
      {
        uint64_t v26 = *(unsigned int *)(a1[2] + 8);
        sub_1CD8DF344((uint64_t)&v27, (uint64_t)&v30, &v29, &v26);
        uint64_t v16 = a1[1];
        uint64_t v17 = *(unsigned int *)(v16 + 8);
        if (v17 >= *(_DWORD *)(v16 + 12))
        {
          sub_1CD62990C(v16, *(_DWORD *)(v27 + 8));
        }
        else
        {
          *(_DWORD *)(*(void *)v16 + 4 * v17) = *(_DWORD *)(v27 + 8);
          ++*(_DWORD *)(v16 + 8);
        }
        if (!v28) {
          goto LABEL_13;
        }
        uint64_t v14 = a1[2];
        uint64_t v15 = *(unsigned int *)(v14 + 8);
        if (v15 >= *(_DWORD *)(v14 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
      }
      else
      {
        if ((v9 - 11) >= 2) {
          int v11 = *(_DWORD *)(a1[2] + 8);
        }
        else {
          int v11 = -1;
        }
        uint64_t v12 = a1[1];
        uint64_t v13 = *(unsigned int *)(v12 + 8);
        if (v13 >= *(_DWORD *)(v12 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(_DWORD *)(*(void *)v12 + 4 * v13) = v11;
        ++*(_DWORD *)(v12 + 8);
        uint64_t v14 = a1[2];
        uint64_t v15 = *(unsigned int *)(v14 + 8);
        if (v15 >= *(_DWORD *)(v14 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
      }
      *(void *)(*(void *)v14 + 8 * v15) = v29;
      *(_DWORD *)(v14 + 8) = v15 + 1;
LABEL_13:
      ++v7;
      v8 -= 8;
      if (!v8)
      {
        uint64_t v5 = *a1;
        uint64_t v18 = *(void *)(*a1 + 8);
        goto LABEL_24;
      }
    }
  }
  uint64_t v18 = 0;
LABEL_24:
  uint64_t v19 = (uint64_t *)a1[2];
  uint64_t v20 = *((unsigned int *)v19 + 2);
  if (v18 == v20)
  {
    *(_DWORD *)(a1[1] + 8) = 0;
  }
  else
  {
    if (v20 < 2) {
      goto LABEL_39;
    }
    if (v31 == 1)
    {
      uint64_t v21 = *v19;
      uint64_t v22 = 8 * v20;
      while (1)
      {
        int v23 = *(unsigned __int8 *)(*(void *)v21 + 16);
        if ((v23 - 11) >= 2 && v23 != 5 && (v23 - 21) > 0xFFFFFFEE) {
          break;
        }
        v21 += 8;
        v22 -= 8;
        if (!v22) {
          goto LABEL_39;
        }
      }
    }
    if ((v20 & (v20 - 1)) != 0) {
LABEL_39:
    }
      sub_1CD32B230(v4, *(void *)v5, v18, 2, 0, 0, a2, a1[3], 0, 0, 0, 0);
    *(void *)uint64_t v5 = *v19;
    *(void *)(v5 + 8) = v20;
  }
  MEMORY[0x1D25D9CD0](v30, 8);
  return 1;
}

uint64_t sub_1CD32AB9C(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  if (*a1) {
    BOOL v3 = *(unsigned __int8 *)(*a1 + 16) >= 0x1Cu;
  }
  else {
    BOOL v3 = 0;
  }
  if (!v3) {
    return 0;
  }
  int v5 = a2;
  if (a2)
  {
    uint64_t v7 = 8 * a2;
    for (int i = a1; sub_1CD32AC64(*i); ++i)
    {
      v7 -= 8;
      if (!v7) {
        return 1;
      }
    }
    if (v5 >= 2)
    {
      int v9 = a1 + 1;
      uint64_t v10 = v5 - 1;
      uint64_t result = 1;
      while (1)
      {
        BOOL v11 = *v9 && *(unsigned __int8 *)(*v9 + 16) >= 0x1Cu;
        if (!v11 || *(void *)(v2 + 40) != *(void *)(*v9 + 40)) {
          break;
        }
        ++v9;
        if (!--v10) {
          return result;
        }
      }
      return 0;
    }
  }
  return 1;
}

BOOL sub_1CD32AC64(uint64_t a1)
{
  unsigned int v1 = *(unsigned __int8 *)(a1 + 16);
  if (v1 - 89 >= 2 && v1 - 11 >= 2 && v1 != 92) {
    return 0;
  }
  uint64_t v2 = 1;
  if (v1 < 0x1C || v1 == 92) {
    return v2;
  }
  int v3 = *(_DWORD *)(a1 + 20);
  uint64_t v4 = (v3 & 0x40000000) != 0 ? *(void *)(a1 - 8) : a1 - 32 * (v3 & 0x7FFFFFF);
  if (*(unsigned char *)(**(void **)v4 + 8) != 18) {
    return 0;
  }
  if (v1 == 89)
  {
    if ((v3 & 0x40000000) != 0) {
      uint64_t v5 = *(void *)(a1 - 8);
    }
    else {
      uint64_t v5 = a1 - 32 * (v3 & 0x7FFFFFF);
    }
    uint64_t v7 = *(void *)(v5 + 32);
  }
  else
  {
    if ((v3 & 0x40000000) != 0) {
      uint64_t v6 = *(void *)(a1 - 8);
    }
    else {
      uint64_t v6 = a1 - 32 * (v3 & 0x7FFFFFF);
    }
    uint64_t v7 = *(void *)(v6 + 64);
  }
  int v8 = *(unsigned __int8 *)(v7 + 16);
  return v8 != 5 && (v8 - 4) < 0x11;
}

void llvm::slpvectorizer::BoUpSLP::BlockScheduling::cancelScheduling(uint64_t a1, llvm **a2, uint64_t a3, uint64_t a4)
{
  if (*(unsigned char *)(a4 + 16) == 83) {
    return;
  }
  uint64_t v4 = (llvm *)a4;
  if (sub_1CD32AC64(a4) || (sub_1CD333508(a2, a3) & 1) != 0) {
    return;
  }
  if (sub_1CD34172C(v4, v8) && sub_1CD333588((uint64_t)v4))
  {
    if (a3)
    {
      uint64_t v10 = 8 * a3;
      BOOL v11 = &a2[a3];
      while (1)
      {
        uint64_t v12 = *a2;
        if (!sub_1CD34172C(*a2, v9) || !sub_1CD333588((uint64_t)v12)) {
          break;
        }
        ++a2;
        v10 -= 8;
        if (!v10)
        {
          a2 = v11;
          break;
        }
      }
    }
    uint64_t v4 = *a2;
  }
  if (v4) {
    BOOL v13 = *((unsigned __int8 *)v4 + 16) > 0x1Bu;
  }
  else {
    BOOL v13 = 0;
  }
  if (v13)
  {
    uint64_t v19 = sub_1CD8DFC80(a1, (uint64_t)v4);
    uint64_t v14 = v19;
    uint64_t v24 = v19;
    if (v19)
    {
      int v20 = 0;
      uint64_t v21 = v19;
      while (1)
      {
        int v22 = *(_DWORD *)(v21 + 156);
        if (v22 == -1) {
          goto LABEL_20;
        }
        v20 += v22;
        uint64_t v21 = *(void *)(v21 + 32);
        if (!v21)
        {
          if (v20) {
            goto LABEL_20;
          }
          break;
        }
      }
    }
  }
  else
  {
    uint64_t v14 = 0;
    uint64_t v24 = 0;
  }
  if (!*(unsigned char *)(v14 + 160)) {
    sub_1CD8DD398(a1 + 88, &v24);
  }
LABEL_20:
  uint64_t v23 = v14;
  uint64_t v15 = (void *)(a1 + 88);
  do
  {
    int v16 = 0;
    uint64_t v17 = v14;
    uint64_t v14 = *(void *)(v14 + 32);
    *(void *)(v17 + 24) = v17;
    *(void *)(v17 + 32) = 0;
    *(void *)(v17 + 16) = 0;
    while (1)
    {
      int v18 = *(_DWORD *)(v17 + 156);
      if (v18 == -1) {
        break;
      }
      v16 += v18;
      uint64_t v17 = *(void *)(v17 + 32);
      if (!v17)
      {
        if (!v16) {
          sub_1CC37AF14(v15, &v23);
        }
        break;
      }
    }
    uint64_t v23 = v14;
  }
  while (v14);
}

uint64_t sub_1CD32AEA4(uint64_t a1, int a2)
{
  if (!a1 || *(unsigned char *)(a1 + 16) != 90)
  {
    uint64_t v7 = *(unsigned int *)(a1 + 72);
    if (v7)
    {
      int v8 = *(unsigned int **)(a1 + 64);
      uint64_t v9 = 4 * v7;
      while (1)
      {
        uint64_t v10 = *(void *)a1;
        uint64_t v11 = *v8;
        int v12 = *(unsigned __int8 *)(*(void *)a1 + 8);
        if (*(void *)a1) {
          BOOL v13 = v12 == 16;
        }
        else {
          BOOL v13 = 0;
        }
        if (v13)
        {
          int v15 = *(_DWORD *)(v10 + 12);
          a1 = *(void *)(v10 + 16) + 8 * v11;
        }
        else
        {
          if (v10) {
            BOOL v14 = v12 == 17;
          }
          else {
            BOOL v14 = 0;
          }
          if (!v14) {
            goto LABEL_35;
          }
          int v15 = *(_DWORD *)(v10 + 32);
          a1 = v10 + 24;
        }
        a2 = v11 + v15 * a2;
        ++v8;
        v9 -= 4;
        if (!v9) {
          goto LABEL_34;
        }
      }
    }
    goto LABEL_34;
  }
  uint64_t v2 = *(void *)(a1 - 32);
  if (v2) {
    BOOL v3 = *(unsigned char *)(v2 + 16) == 16;
  }
  else {
    BOOL v3 = 0;
  }
  if (!v3) {
    goto LABEL_35;
  }
  unint64_t v4 = *(unsigned int *)(*(void *)a1 + 32);
  uint64_t v5 = *(unsigned int *)(v2 + 32);
  if (v5 >= 0x41)
  {
    int v16 = 0;
    int64_t v17 = (unint64_t)(v5 + 63) >> 6;
    do
    {
      if (v17-- < 1) {
        break;
      }
      unint64_t v19 = *(void *)(*(void *)(v2 + 24) + 8 * v17);
      v16 += __clz(v19);
    }
    while (!v19);
    int v20 = v5 | 0xFFFFFFC0;
    if ((v5 & 0x3F) == 0) {
      int v20 = 0;
    }
    if ((v5 - v16 - v20) >= 0x41) {
      goto LABEL_35;
    }
    unint64_t v6 = **(void **)(v2 + 24);
  }
  else
  {
    unint64_t v6 = *(void *)(v2 + 24);
  }
  if (v6 >= v4)
  {
LABEL_35:
    uint64_t v22 = 0;
    LOBYTE(a2) = 0;
    unsigned int v21 = 0;
    return v22 | v21 | a2;
  }
  a2 = v6 + v4 * a2;
LABEL_34:
  unsigned int v21 = a2 & 0xFFFFFF00;
  uint64_t v22 = 0x100000000;
  return v22 | v21 | a2;
}

uint64_t sub_1CD32AFC4(uint64_t *a1, unint64_t a2, uint64_t a3, BOOL a4, llvm::DataLayout *a5, const llvm::DataLayout *a6, unsigned int **a7, uint64_t a8)
{
  int v15 = *(llvm::Type **)a3;
  uint64_t v16 = sub_1CB83544C((uint64_t)a5, *(void *)a3);
  int v18 = v17;
  if (v16 != sub_1CC5CA218(a5, v15) || v18 != v19) {
    return 0;
  }
  BOOL v40 = a4;
  *(_DWORD *)(a8 + 8) = 0;
  sub_1CD42769C(a8, a2);
  uint64_t v23 = *(llvm::Type ***)a8;
  if (a2)
  {
    uint64_t v24 = 8 * a2;
    BOOL v25 = a1;
    uint64_t v26 = v15;
    do
    {
      uint64_t v27 = *v25;
      int v28 = *(unsigned __int8 *)(*v25 + 16);
      if (v28 == 60 || v28 == 61)
      {
        __int16 v29 = *(_WORD *)(v27 + 18);
        if (v29 & 0x380) != 0 || (v29) {
          return 0;
        }
      }
      else if (v28 - 63) < 3 || (*(_WORD *)(v27 + 18))
      {
        return 0;
      }
      *v23++ = *(llvm::Type **)(v27 - 32);
      ++v25;
      v24 -= 8;
    }
    while (v24);
    uint64_t v23 = *(llvm::Type ***)a8;
  }
  else
  {
    uint64_t v26 = v15;
  }
  *((_DWORD *)a7 + 2) = 0;
  if (!llvm::sortPtrAccesses(v23, *(unsigned int *)(a8 + 8), v26, a5, a6, (uint64_t)a7)) {
    return 0;
  }
  uint64_t v30 = *((unsigned int *)a7 + 2);
  if (v30)
  {
    uint64_t v31 = (llvm::Type **)(*(void *)a8 + 8 * **a7);
    int v32 = (llvm::Type **)(*(void *)a8 + 8 * (*a7)[v30 - 1]);
  }
  else
  {
    uint64_t v31 = *(llvm::Type ***)a8;
    int v32 = (llvm::Type **)(*(void *)a8 + 8 * *(unsigned int *)(a8 + 8) - 8);
  }
  uint64_t v21 = 1;
  if (a2 - 1 != llvm::getPointersDiff(v26, *v31, v26, *v32, a5, a6, 0, 1, v40))
  {
    unsigned int v33 = __clz(1 << ((unint64_t)*(unsigned __int16 *)(a3 + 18) >> 1)) ^ 0x3F;
    if (a2)
    {
      uint64_t v34 = 8 * a2;
      int v35 = *(void **)v41;
      do
      {
        uint64_t v36 = *a1++;
        unsigned int v37 = __clz(1 << ((unint64_t)*(unsigned __int16 *)(v36 + 18) >> 1)) ^ 0x3F;
        if (v37 >= v33) {
          unsigned int v33 = v33;
        }
        else {
          unsigned int v33 = v37;
        }
        v34 -= 8;
      }
      while (v34);
    }
    else
    {
      int v35 = *(void **)v41;
    }
    double v38 = llvm::FixedVectorType::get(v26, (llvm::Type *)a2);
    if ((*(uint64_t (**)(void, uint64_t, void, double))(*(void *)*v35 + 368))(*v35, v39, v33, v38)) {
      return 2;
    }
    return 0;
  }
  return v21;
}

void sub_1CD32B230(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__src, uint64_t a10, uint64_t a11, uint64_t a12)
{
}

BOOL sub_1CD32B748(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v21[2] = *MEMORY[0x1E4F143B8];
  unsigned int v6 = *(unsigned __int8 *)(a1 + 16);
  if (v6 != 5 && v6 - 4 <= 0x10)
  {
    int v8 = *(unsigned __int8 *)(a3 + 16);
    if (v8 != 5 && (v8 - 4) < 0x11) {
      return 1;
    }
  }
  unsigned int v10 = *(unsigned __int8 *)(a2 + 16);
  if (v10 != 5 && v10 - 4 <= 0x10)
  {
    int v12 = *(unsigned __int8 *)(a4 + 16);
    if (v12 != 5 && (v12 - 4) < 0x11) {
      return 1;
    }
  }
  if (v6 <= 0x1B)
  {
    BOOL v14 = v10 > 0x1B || *(unsigned __int8 *)(a3 + 16) > 0x1Bu;
    if (!v14 && *(unsigned __int8 *)(a4 + 16) < 0x1Cu) {
      return 1;
    }
  }
  v21[0] = a1;
  v21[1] = a3;
  sub_1CD32A408((uint64_t)v18, v21, 2);
  if (v19)
  {
    if (*(unsigned char *)(v19 + 16) != 28) {
      return 1;
    }
  }
  v20[0] = a2;
  v20[1] = a4;
  sub_1CD32A408((uint64_t)v16, v20, 2);
  return v17 && *(unsigned char *)(v17 + 16) != 28;
}

uint64_t llvm::slpvectorizer::BoUpSLP::canMapToVector(llvm::slpvectorizer::BoUpSLP *this, llvm::Type *a2, const llvm::DataLayout *a3)
{
  uint64_t v6 = 1;
  uint64_t v7 = a2;
  while (1)
  {
    int v8 = *((_DWORD *)v7 + 2);
    if ((v8 & 0xFC | 2) != 0x12) {
      break;
    }
    if (*((_DWORD *)v7 + 2) == 16)
    {
      uint64_t v9 = (llvm::Type **)*((void *)v7 + 2);
      uint64_t v10 = *((unsigned int *)v7 + 3);
      if (v10)
      {
        uint64_t v11 = 0;
        while (v9[v11] == *v9)
        {
          if (v10 == ++v11) {
            goto LABEL_10;
          }
        }
        return 0;
      }
    }
    else
    {
      LODWORD(v10) = *((_DWORD *)v7 + 8);
      uint64_t v9 = (llvm::Type **)((char *)v7 + 24);
    }
LABEL_10:
    uint64_t v7 = *v9;
    uint64_t v6 = (v10 * v6);
  }
  BOOL v12 = *((_DWORD *)v7 + 2) > 0x14u || ((1 << v8) & 0x10A07F) == 0;
  if (v12 || (v8 & 0xFD) == 4) {
    return 0;
  }
  llvm::FixedVectorType::get(v7, (llvm::Type *)v6);
  unint64_t v15 = (sub_1CB83544C((uint64_t)a3, v13) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v14 == 1) {
  if (v15 < *((unsigned int *)this + 501) || v15 > *((unsigned int *)this + 500))
  }
    return 0;
  unint64_t v18 = (sub_1CB83544C((uint64_t)a3, (uint64_t)a2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v17 == 1) {
  if (v15 == v18)
  }
    return v6;
  else {
    return 0;
  }
}

uint64_t sub_1CD32B9E0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 16) == 89)
  {
    int v1 = *(_DWORD *)(a1 + 20);
    if ((v1 & 0x40000000) != 0) {
      uint64_t v2 = *(void *)(a1 - 8);
    }
    else {
      uint64_t v2 = a1 - 32 * (v1 & 0x7FFFFFF);
    }
    uint64_t v4 = *(void *)(v2 + 32);
    if (v4) {
      BOOL v5 = *(unsigned char *)(v4 + 16) == 16;
    }
    else {
      BOOL v5 = 0;
    }
    if (!v5) {
      goto LABEL_11;
    }
    BOOL v3 = (void *)(v4 + 24);
    if (*(_DWORD *)(v4 + 32) >= 0x41u) {
      BOOL v3 = (void *)*v3;
    }
LABEL_14:
    int v6 = *(_DWORD *)v3;
    unsigned int v8 = v6 & 0xFFFFFF00;
    uint64_t v7 = 0x100000000;
    return v7 | v8 | v6;
  }
  if (*(_DWORD *)(a1 + 72) == 1)
  {
    BOOL v3 = *(void **)(a1 + 64);
    goto LABEL_14;
  }
LABEL_11:
  LOBYTE(v6) = 0;
  uint64_t v7 = 0;
  unsigned int v8 = 0;
  return v7 | v8 | v6;
}

uint64_t llvm::slpvectorizer::BoUpSLP::getEntryCost(uint64_t a1, uint64_t **a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = (uint64_t)a2;
  v616[6] = *MEMORY[0x1E4F143B8];
  unsigned int v8 = *a2;
  unint64_t v9 = *((unsigned int *)a2 + 2);
  LODWORD(v10) = v9;
  uint64_t v11 = **a2;
  unsigned int v12 = *(unsigned __int8 *)(v11 + 16);
  if (v12 == 61
    || (v12 > 0x1B ? (BOOL v13 = v12 - 81 >= 2) : (BOOL v13 = 1),
        v13 ? (int v14 = 0) : (int v14 = 1),
        v12 != 90 ? (BOOL v15 = v14 == 0) : (BOOL v15 = 0),
        !v15))
  {
    uint64_t v11 = *(void *)(v11 - 64);
  }
  v556 = *(llvm::FixedVectorType **)v11;
  llvm::FixedVectorType::get(*(llvm::FixedVectorType **)v11, (llvm::Type *)v9);
  uint64_t v17 = v16;
  uint64_t v18 = *(void *)(a1 + 2144);
  uint64_t v19 = *(unsigned int *)(a1 + 2160);
  if (v19)
  {
    LODWORD(v20) = ((*v8 >> 4) ^ (*v8 >> 9)) & (v19 - 1);
    uint64_t v21 = (uint64_t *)(v18 + 16 * v20);
    uint64_t v22 = *v21;
    if (*v8 == *v21) {
      goto LABEL_20;
    }
    int v23 = 1;
    while (v22 != -4096)
    {
      int v24 = v20 + v23++;
      uint64_t v20 = v24 & (v19 - 1);
      uint64_t v22 = *(void *)(v18 + 16 * v20);
      if (*v8 == v22)
      {
        uint64_t v21 = (uint64_t *)(v18 + 16 * v20);
        goto LABEL_20;
      }
    }
  }
  uint64_t v21 = (uint64_t *)(v18 + 16 * v19);
LABEL_20:
  if (v21 != (uint64_t *)(v18 + 16 * v19))
  {
    unint64_t v139 = ***(llvm::IntegerType ****)(a1 + 1920);
    uint64_t v140 = (unsigned int *)sub_1CD8DDDCC(a1 + 2144, v8);
    unsigned int v141 = (llvm::FixedVectorType *)llvm::IntegerType::get(v139, (llvm::LLVMContext *)*v140);
    llvm::FixedVectorType::get(v141, (llvm::Type *)v9);
    uint64_t v17 = v142;
  }
  BOOL v25 = (llvm::Type *)*(unsigned int *)(v6 + 104);
  if (!v25) {
    BOOL v25 = (llvm::Type *)*(unsigned int *)(v6 + 8);
  }
  llvm::FixedVectorType::get(*(llvm::FixedVectorType **)(v17 + 24), v25);
  uint64_t v560 = v27;
  int v28 = *(_DWORD *)(v6 + 104);
  uint64_t v29 = *(void *)(a1 + 1936);
  v584[0] = a1;
  v584[1] = v29;
  int v585 = 0;
  v586 = v8;
  unint64_t v587 = v9;
  uint64_t v588 = v17;
  uint64_t v589 = a3;
  uint64_t v590 = a4;
  uint64_t v591 = v6;
  uint64_t v579 = v6;
  uint64_t v582 = a1;
  uint64_t v565 = v17;
  if (*(_DWORD *)(v6 + 88) != 2)
  {
    v595[0] = 0;
    LODWORD(v595[1]) = 0;
    v614 = (char *)v616;
    uint64_t v34 = 0xC00000000;
    uint64_t v615 = 0xC00000000;
    unint64_t v35 = *(unsigned int *)(v6 + 136);
    if (v35)
    {
      __dst = &v602;
      uint64_t v601 = 0xC00000000;
      uint64_t v36 = *(void *)(v6 + 384);
      if (v36 && *(unsigned char *)(v36 + 16) == 61)
      {
        sub_1CBB1173C((uint64_t)&__dst, v35);
        uint64_t v37 = *(unsigned int *)(v6 + 136);
        double v38 = (int *)__dst;
        if (v37)
        {
          memmove(__dst, *(const void **)(v6 + 128), 4 * v37);
          double v38 = (int *)__dst;
        }
      }
      else
      {
        uint64_t v39 = *(void *)(v6 + 128);
        if (v35 >= 0xD) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        double v38 = (int *)&v602;
        memset(&v602, 255, 4 * v35);
        uint64_t v40 = 0;
        LODWORD(v601) = v601 + v35;
        do
        {
          *((_DWORD *)&v602 + *(unsigned int *)(v39 + 4 * v40)) = v40;
          ++v40;
        }
        while (v35 != v40);
        uint64_t v17 = v565;
      }
      sub_1CD324BD0(&v614, v38, v601);
      if (__dst != &v602) {
        free(__dst);
      }
      a1 = v582;
    }
    if (v28) {
      sub_1CD324BD0(&v614, *(int **)(v6 + 96), *(unsigned int *)(v6 + 104));
    }
    uint64_t v41 = v615;
    if (v615)
    {
      int v42 = v614;
      if (sub_1CC5D47FC((int *)v614, v615, v615))
      {
        v572 = 0;
        LODWORD(v41) = 0;
      }
      else
      {
        uint64_t v43 = (unsigned char *)(*(uint64_t (**)(void, uint64_t, uint64_t, char *, uint64_t, void, void))(***(void ***)(a1 + 1936) + 832))(**(void **)(a1 + 1936), 7, v560, v42, v41, 0, 0);
        LODWORD(v41) = v26;
        v572 = v43;
        v595[0] = v43;
        LODWORD(v595[1]) = v26;
      }
    }
    else
    {
      v572 = 0;
    }
    uint64_t v554 = *(void *)(v6 + 384);
    v562 = (llvm::Type *)v9;
    if (v554 != *(void *)(v6 + 392))
    {
LABEL_55:
      uint64_t v44 = 8 * v9;
      if (v28)
      {
        uint64_t v45 = *(unsigned int *)(v6 + 104);
        if (v45)
        {
          uint64_t v46 = *(unsigned int **)(v6 + 96);
          uint64_t v47 = 4 * v45;
          do
          {
            uint64_t v48 = v8[*v46];
            unsigned int v49 = *(unsigned __int8 *)(v48 + 16) - 29;
            BOOL v50 = v49 > 0x3F;
            unint64_t v51 = (1 << v49) & 0xF1F3FFE3BFFFF807;
            if (v50 || v51 == 0) {
              int v53 = 0;
            }
            else {
              sub_1CBFB51A8(*(void **)(a1 + 1936), v48);
            }
            if (v53 == 1) {
              LODWORD(v41) = 1;
            }
            ++v46;
            v47 -= 4;
          }
          while (v47);
        }
        if (v562)
        {
          uint64_t v54 = v44;
          unsigned int v55 = v8;
          do
          {
            unsigned int v56 = *(unsigned __int8 *)(*v55 + 16) - 29;
            BOOL v50 = v56 > 0x3F;
            unint64_t v57 = (1 << v56) & 0xF1F3FFE3BFFFF807;
            if (v50 || v57 == 0) {
              int v59 = 0;
            }
            else {
              sub_1CBFB51A8(*(void **)(a1 + 1936), *v55);
            }
            if (v59 == 1) {
              LODWORD(v41) = 1;
            }
            ++v55;
            v54 -= 8;
          }
          while (v54);
        }
        LODWORD(v595[1]) = v41;
        uint64_t v6 = v579;
        LODWORD(v10) = v562;
      }
      if (v10)
      {
        int v60 = 0;
        unint64_t v61 = 0;
        do
        {
          unsigned int v62 = *(unsigned __int8 *)(*v8 + 16) - 29;
          BOOL v50 = v62 > 0x3F;
          unint64_t v63 = (1 << v62) & 0xF1F3FFE3BFFFF807;
          if (v50 || v63 == 0)
          {
            int v66 = 0;
            uint64_t v65 = -1;
          }
          else
          {
            uint64_t v65 = sub_1CBFB51A8(*(void **)(a1 + 1936), *v8);
          }
          if (v66 == 1) {
            int v60 = 1;
          }
          if (__OFADD__(v61, v65)) {
            unint64_t v61 = ((uint64_t)(v61 + v65) >> 63) ^ 0x8000000000000000;
          }
          else {
            v61 += v65;
          }
          ++v8;
          v44 -= 8;
        }
        while (v44);
      }
      else
      {
        unint64_t v61 = 0;
        int v60 = 0;
      }
      int v553 = v60;
      uint64_t v70 = *(unsigned int *)(a1 + 8);
      uint64_t v71 = v562;
      if (v70)
      {
        uint64_t v72 = *(uint64_t **)a1;
        uint64_t v73 = *(void *)a1 + 8 * v70;
        unint64_t v568 = v61;
        uint64_t v551 = v73;
        do
        {
          uint64_t v74 = *v72;
          if (*v72 == v6) {
            break;
          }
          uint64_t v76 = *(void *)(v74 + 384);
          uint64_t v75 = *(void *)(v74 + 392);
          if (v76 != v75)
          {
            int v77 = v76 ? *(unsigned __int8 *)(v76 + 16) - 28 : 0;
            uint64_t v78 = *(void *)(v6 + 384);
            int v79 = v78 ? *(unsigned __int8 *)(v78 + 16) - 28 : 0;
            if (v77 == v79)
            {
              if (v75) {
                int v80 = *(unsigned __int8 *)(v75 + 16) - 28;
              }
              else {
                int v80 = 0;
              }
              uint64_t v81 = *(void *)(v6 + 392);
              if (v81) {
                LODWORD(v81) = *(unsigned __int8 *)(v81 + 16) - 28;
              }
              if (v80 == v81) {
                goto LABEL_127;
              }
            }
            if (v76) {
              LODWORD(v76) = *(unsigned __int8 *)(v76 + 16) - 28;
            }
            uint64_t v82 = *(void *)(v6 + 392);
            if (v82) {
              LODWORD(v82) = *(unsigned __int8 *)(v82 + 16) - 28;
            }
            if (v76 == v82)
            {
              if (v75) {
                LODWORD(v75) = *(unsigned __int8 *)(v75 + 16) - 28;
              }
              if (v78) {
                LODWORD(v78) = *(unsigned __int8 *)(v78 + 16) - 28;
              }
              if (v75 == v78)
              {
LABEL_127:
                uint64_t v83 = *(unsigned int *)(v6 + 216);
                if (v83 == *(_DWORD *)(v74 + 216))
                {
                  if (v83 > 0x39) {
                    operator new();
                  }
                  unint64_t v84 = (v83 << 58) | 1;
                  if (v83)
                  {
                    uint64_t v85 = 0;
                    BOOL v86 = 0;
                    while (1)
                    {
                      unint64_t v87 = v84 >> 1;
                      unint64_t v88 = v84 >> 58;
                      BOOL v566 = v86;
                      if (v84)
                      {
                        uint8x8_t v95 = (uint8x8_t)vcnt_s8((int8x8_t)(v87 & ~(-1 << v88)));
                        v95.i16[0] = vaddlv_u8(v95);
                        __int32 v90 = v95.i32[0];
                      }
                      else
                      {
                        uint64_t v89 = *(unsigned int *)(v84 + 8);
                        if (v89)
                        {
                          __int32 v90 = 0;
                          int v91 = *(int8x8_t **)v84;
                          uint64_t v92 = 8 * v89;
                          do
                          {
                            int8x8_t v93 = *v91++;
                            uint8x8_t v94 = (uint8x8_t)vcnt_s8(v93);
                            v94.i16[0] = vaddlv_u8(v94);
                            v90 += v94.i32[0];
                            v92 -= 8;
                          }
                          while (v92);
                        }
                        else
                        {
                          __int32 v90 = 0;
                        }
                      }
                      uint64_t v96 = 0;
                      uint64_t v573 = ~(-1 << v88);
                      uint64_t v97 = v87 & v573;
                      uint64_t v98 = *(void *)(v6 + 208) + 80 * v85;
                      uint64_t v99 = 8;
                      while (1)
                      {
                        char v100 = v96;
                        unint64_t v101 = v97;
                        if ((v84 & 1) == 0)
                        {
                          char v100 = v96 & 0x3F;
                          unint64_t v101 = *(void *)(*(void *)v84 + 8 * (v96 >> 6));
                        }
                        if (((v101 >> v100) & 1) == 0)
                        {
                          uint64_t v102 = (const void **)(*(void *)(v74 + 208) + v99);
                          uint64_t v103 = *(unsigned int *)v102;
                          if (v103 == *(_DWORD *)(v98 + 8)
                            && !memcmp(*(v102 - 1), *(const void **)v98, 8 * v103))
                          {
                            break;
                          }
                        }
                        ++v96;
                        v99 += 80;
                        if (v83 == v96) {
                          goto LABEL_145;
                        }
                      }
                      if (v84) {
                        unint64_t v84 = v84 & 0xFC00000000000000 | (2 * (((1 << v96) | v97) & v573)) | 1;
                      }
                      else {
                        *(void *)(*(void *)v84 + 8 * (v96 >> 6)) |= 1 << v96;
                      }
LABEL_145:
                      uint64_t v6 = v579;
                      unint64_t v61 = v568;
                      if (v84)
                      {
                        uint8x8_t v110 = (uint8x8_t)vcnt_s8((int8x8_t)((v84 >> 1) & ~(-1 << (v84 >> 58))));
                        v110.i16[0] = vaddlv_u8(v110);
                        __int32 v105 = v110.i32[0];
                      }
                      else
                      {
                        uint64_t v104 = *(unsigned int *)(v84 + 8);
                        if (v104)
                        {
                          __int32 v105 = 0;
                          unsigned int v106 = *(int8x8_t **)v84;
                          uint64_t v107 = 8 * v104;
                          do
                          {
                            int8x8_t v108 = *v106++;
                            uint8x8_t v109 = (uint8x8_t)vcnt_s8(v108);
                            v109.i16[0] = vaddlv_u8(v109);
                            v105 += v109.i32[0];
                            v107 -= 8;
                          }
                          while (v107);
                        }
                        else
                        {
                          __int32 v105 = 0;
                        }
                      }
                      if (v90 == v105) {
                        break;
                      }
                      BOOL v86 = ++v85 >= (unint64_t)v83;
                      a1 = v582;
                      if (v85 == v83) {
                        goto LABEL_161;
                      }
                    }
                    a1 = v582;
                    BOOL v86 = v566;
                  }
                  else
                  {
                    BOOL v86 = 1;
                  }
LABEL_161:
                  if (v84)
                  {
                    uint64_t v71 = v562;
                    uint64_t v73 = v551;
                    if (v86) {
                      goto LABEL_316;
                    }
                  }
                  else
                  {
                    BOOL v111 = v86;
                    uint64_t v71 = v562;
                    if (*(void *)v84 != v84 + 16) {
                      free(*(void **)v84);
                    }
                    MEMORY[0x1D25D9CE0](v84, 0x1080C40EF38A13ELL);
                    uint64_t v73 = v551;
                    if (v111)
                    {
LABEL_316:
                      unint64_t v168 = 0;
                      int v167 = 0;
                      goto LABEL_252;
                    }
                  }
                }
              }
            }
          }
          ++v72;
        }
        while (v72 != (uint64_t *)v73);
      }
      uint64_t v112 = *(void *)(v6 + 384);
      if (v112)
      {
        int v113 = *(unsigned __int8 *)(v112 + 16);
        uint64_t v114 = v565;
        uint64_t v115 = v554;
        if ((v113 - 41) <= 0x11)
        {
          uint64_t v116 = (*(uint64_t (**)(void, void, uint64_t, void, void, void, void, void, void, void, void))(***(void ***)(a1 + 1936) + 824))(**(void **)(a1 + 1936), (v113 - 28), v565, 0, 0, 0, 0, 0, 0, 0, 0);
          int v118 = v117;
          uint64_t v119 = *(void *)(v6 + 392);
          if (v119) {
            uint64_t v120 = *(unsigned __int8 *)(v119 + 16) - 28;
          }
          else {
            uint64_t v120 = 0;
          }
          uint64_t v169 = (*(uint64_t (**)(void, uint64_t, uint64_t, void, void, void, void, void, void, void, void))(***(void ***)(a1 + 1936) + 824))(**(void **)(a1 + 1936), v120, v565, 0, 0, 0, 0, 0, 0, 0, 0);
LABEL_246:
          if (v170 == 1) {
            int v167 = 1;
          }
          else {
            int v167 = v118;
          }
          if (__OFADD__(v116, v169)) {
            unint64_t v168 = ((v116 + v169) >> 63) ^ 0x8000000000000000;
          }
          else {
            unint64_t v168 = v116 + v169;
          }
LABEL_252:
          __dst = &v602;
          uint64_t v601 = 0xC00000000;
          uint64_t v185 = *(void *)v6;
          unsigned int v186 = *(_DWORD *)(v6 + 8);
          uint64_t v187 = *(void *)(v6 + 128);
          uint64_t v188 = *(unsigned int *)(v6 + 136);
          unint64_t v189 = *(int **)(v6 + 96);
          unint64_t v190 = *(unsigned int *)(v6 + 104);
          v610 = (uint64_t *)v6;
          sub_1CD330E8C(v185, v186, v187, v188, v189, v190, (unsigned int (*)(uint64_t, uint64_t))sub_1CD3444E0, (uint64_t)&v610, &__dst, 0, 0);
          uint64_t v191 = (*(uint64_t (**)(void, uint64_t))(***(void ***)(a1 + 1936) + 832))(**(void **)(a1 + 1936), 2);
          LODWORD(v595[1]) = v192;
          v193 = v595[1];
          unint64_t v194 = v191 + v168;
          if (__OFADD__(v191, v168)) {
            unint64_t v194 = ((uint64_t)(v191 + v168) >> 63) ^ 0x8000000000000000;
          }
          if (v167 == 1 || v553 == 1) {
            v193 = (void *)((unint64_t)v595[1] & 0xFFFFFFFF00000000 | 1);
          }
          BOOL v270 = __OFSUB__(v194, v61);
          int64_t v196 = v194 - v61;
          if (v270) {
            int64_t v196 = (v196 >> 63) ^ 0x8000000000000000;
          }
          *(void *)&long long v592 = v196;
          *((void *)&v592 + 1) = v193;
          if (__dst != &v602) {
            free(__dst);
          }
          goto LABEL_281;
        }
        if (v554 && *(unsigned __int8 *)(v554 + 16) - 83 >= 0xFFFFFFFE)
        {
          uint64_t v121 = (v113 - 28);
          goto LABEL_179;
        }
      }
      else
      {
        uint64_t v114 = v565;
        uint64_t v115 = v554;
        if (v554 && *(unsigned __int8 *)(v554 + 16) - 83 >= 0xFFFFFFFE)
        {
          uint64_t v121 = 0;
LABEL_179:
          uint64_t v116 = (*(uint64_t (**)(void, uint64_t, llvm::FixedVectorType *, uint64_t, void, void))(***(void ***)(a1 + 1936) + 864))(**(void **)(a1 + 1936), v121, v556, **(void **)(a1 + 2072) + 1888, *(_WORD *)(v115 + 18) & 0x3F, 0);
          int v118 = v122;
          uint64_t v123 = *(void *)(v6 + 384);
          if (v123) {
            uint64_t v124 = *(unsigned __int8 *)(v123 + 16) - 28;
          }
          else {
            uint64_t v124 = 0;
          }
          uint64_t v169 = (*(uint64_t (**)(void, uint64_t, llvm::FixedVectorType *, uint64_t, void, void))(***(void ***)(a1 + 1936) + 864))(**(void **)(a1 + 1936), v124, v556, **(void **)(a1 + 2072) + 1888, *(_WORD *)(*(void *)(v6 + 392) + 18) & 0x3F, 0);
          goto LABEL_246;
        }
      }
      int v125 = *(_DWORD *)(v112 + 20);
      if ((v125 & 0x40000000) != 0) {
        uint64_t v126 = *(llvm::FixedVectorType ****)(v112 - 8);
      }
      else {
        uint64_t v126 = (llvm::FixedVectorType ***)(v112 - 32 * (v125 & 0x7FFFFFF));
      }
      int v143 = **v126;
      uint64_t v144 = *(void *)(v6 + 392);
      int v145 = *(_DWORD *)(v144 + 20);
      if ((v145 & 0x40000000) != 0) {
        int v146 = *(llvm::FixedVectorType ****)(v144 - 8);
      }
      else {
        int v146 = (llvm::FixedVectorType ***)(v144 - 32 * (v145 & 0x7FFFFFF));
      }
      uint64_t v147 = **v146;
      llvm::FixedVectorType::get(v143, v71);
      uint64_t v149 = v148;
      v150.n128_f64[0] = llvm::FixedVectorType::get(v147, v71);
      uint64_t v152 = v151;
      uint64_t v153 = *(void *)(v6 + 384);
      if (v153) {
        uint64_t v154 = *(unsigned __int8 *)(v153 + 16) - 28;
      }
      else {
        uint64_t v154 = 0;
      }
      uint64_t v160 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, void, void, void, __n128))(***(void ***)(a1 + 1936) + 840))(**(void **)(a1 + 1936), v154, v114, v149, 0, 0, 0, v150);
      int v162 = v161;
      uint64_t v163 = *(void *)(v579 + 392);
      if (v163) {
        uint64_t v164 = *(unsigned __int8 *)(v163 + 16) - 28;
      }
      else {
        uint64_t v164 = 0;
      }
      uint64_t v165 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, void, void, void))(***(void ***)(a1 + 1936)
                                                                                                  + 840))(**(void **)(a1 + 1936), v164, v114, v152, 0, 0, 0);
      if (v166 == 1) {
        int v167 = 1;
      }
      else {
        int v167 = v162;
      }
      if (__OFADD__(v160, v165)) {
        unint64_t v168 = ((v160 + v165) >> 63) ^ 0x8000000000000000;
      }
      else {
        unint64_t v168 = v160 + v165;
      }
      uint64_t v6 = v579;
      goto LABEL_252;
    }
    uint64_t v67 = *(unsigned __int8 *)(v554 + 16) - 28;
    switch(*(unsigned char *)(v554 + 16))
    {
      case ';':
      case '?':
      case '@':
      case 'A':
      case 'N':
      case 'O':
      case 'P':
      case 'V':
      case 'W':
      case 'X':
        __break(1u);
        goto LABEL_895;
      case '<':
        uint64_t v247 = __clz(1 << ((unint64_t)*(unsigned __int16 *)(v554 + 18) >> 1)) ^ 0x3F;
        v610 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, llvm::FixedVectorType *, uint64_t, void, void))(***(void ***)(a1 + 1936) + 888))(**(void **)(a1 + 1936), 32, v556, v247, 0, 0);
        uint64_t v611 = v248;
        if (v28)
        {
          __dst = (void *)(v25 - v9);
          LODWORD(v601) = 0;
          sub_1CB90C9D4((uint64_t)&__dst, (uint64_t)&v610);
          if (v601 == 1) {
            LODWORD(v595[1]) = 1;
          }
          if (__OFSUB__(v572, __dst)) {
            unint64_t v249 = ((v572 - (unsigned char *)__dst) >> 63) ^ 0x8000000000000000;
          }
          else {
            unint64_t v249 = v572 - (unsigned char *)__dst;
          }
        }
        else
        {
          unint64_t v249 = (unint64_t)v572;
        }
        __dst = (void *)*(unsigned int *)(v17 + 32);
        LODWORD(v601) = 0;
        sub_1CB90C9D4((uint64_t)&__dst, (uint64_t)&v610);
        uint64_t v381 = v17;
        uint64_t v252 = __dst;
        uint64_t v382 = v601;
        if (*(_DWORD *)(v6 + 88))
        {
          if (v9)
          {
            uint64_t v383 = 8 * v9;
            do
            {
              uint64_t v384 = *v8++;
              unsigned int v385 = __clz(1 << ((unint64_t)*(unsigned __int16 *)(v384 + 18) >> 1)) ^ 0x3F;
              if (v385 >= v247) {
                uint64_t v247 = v247;
              }
              else {
                uint64_t v247 = v385;
              }
              v383 -= 8;
            }
            while (v383);
          }
          uint64_t v386 = (*(uint64_t (**)(void, uint64_t, uint64_t, void, void, uint64_t, void))(***(void ***)(a1 + 1936) + 912))(**(void **)(a1 + 1936), 32, v565, *(void *)(v554 - 32), 0, v247, 0);
        }
        else
        {
          uint64_t v386 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, void, void, uint64_t))(***(void ***)(a1 + 1936) + 888))(**(void **)(a1 + 1936), 32, v381, v247, 0, 0, v554);
        }
        uint64_t v256 = v595[1];
        unint64_t v257 = v249 + v386;
        if (__OFADD__(v249, v386)) {
          unint64_t v257 = ((uint64_t)(v249 + v386) >> 63) ^ 0x8000000000000000;
        }
        unint64_t v258 = (unint64_t)v595[1] & 0xFFFFFFFF00000000 | 1;
        BOOL v259 = v387 == 1 || v382 == 1;
        goto LABEL_601;
      case '=':
        uint64_t v250 = *(void *)(v6 + 384);
        if (*(_DWORD *)(v6 + 136)) {
          uint64_t v250 = v8[**(unsigned int **)(v6 + 128)];
        }
        v610 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, llvm::FixedVectorType *, unint64_t, void, void, uint64_t))(***(void ***)(a1 + 1936) + 888))(**(void **)(a1 + 1936), 33, v556, ((unint64_t)*(unsigned __int16 *)(v250 + 18) >> 1) & 0x3F, 0, 0, v554);
        uint64_t v611 = v251;
        __dst = (void *)*(unsigned int *)(v17 + 32);
        LODWORD(v601) = 0;
        sub_1CB90C9D4((uint64_t)&__dst, (uint64_t)&v610);
        uint64_t v252 = __dst;
        int v253 = v601;
        uint64_t v254 = (*(uint64_t (**)(void))(***(void ***)(a1 + 1936) + 888))();
        uint64_t v256 = v595[1];
        unint64_t v257 = (unint64_t)&v572[v254];
        if (__OFADD__(v572, v254)) {
          unint64_t v257 = ((uint64_t)&v572[v254] >> 63) ^ 0x8000000000000000;
        }
        unint64_t v258 = (unint64_t)v595[1] & 0xFFFFFFFF00000000 | 1;
        BOOL v259 = v255 == 1 || v253 == 1;
        goto LABEL_601;
      case '>':
        v610 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, llvm::FixedVectorType *, void, void, uint64_t, void, void, void, void, void))(***(void ***)(a1 + 1936) + 824))(**(void **)(a1 + 1936), 13, v556, 0, 0, 2, 0, 0, 0, 0, 0);
        uint64_t v611 = v245;
        if (v28)
        {
          __dst = (void *)(v25 - v9);
          LODWORD(v601) = 0;
          sub_1CB90C9D4((uint64_t)&__dst, (uint64_t)&v610);
          if (v601 == 1) {
            LODWORD(v595[1]) = 1;
          }
          if (__OFSUB__(v572, __dst)) {
            unint64_t v246 = ((v572 - (unsigned char *)__dst) >> 63) ^ 0x8000000000000000;
          }
          else {
            unint64_t v246 = v572 - (unsigned char *)__dst;
          }
        }
        else
        {
          unint64_t v246 = (unint64_t)v572;
        }
        __dst = (void *)*(unsigned int *)(v17 + 32);
        LODWORD(v601) = 0;
        sub_1CB90C9D4((uint64_t)&__dst, (uint64_t)&v610);
        uint64_t v377 = v17;
        uint64_t v252 = __dst;
        int v378 = v601;
        uint64_t v379 = (*(uint64_t (**)(void, uint64_t, uint64_t))(***(void ***)(a1 + 1936) + 824))(**(void **)(a1 + 1936), 13, v377);
        uint64_t v256 = v595[1];
        unint64_t v257 = v246 + v379;
        if (__OFADD__(v246, v379)) {
          unint64_t v257 = ((uint64_t)(v246 + v379) >> 63) ^ 0x8000000000000000;
        }
        unint64_t v258 = (unint64_t)v595[1] & 0xFFFFFFFF00000000 | 1;
        BOOL v259 = v380 == 1 || v378 == 1;
LABEL_601:
        if (v259) {
          uint64_t v256 = (void *)v258;
        }
        BOOL v270 = __OFSUB__(v257, v252);
        int64_t v388 = v257 - (void)v252;
        if (v270) {
          int64_t v388 = (v388 >> 63) ^ 0x8000000000000000;
        }
        *(void *)&long long v592 = v388;
        *((void *)&v592 + 1) = v256;
        goto LABEL_281;
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
        int v68 = *(_DWORD *)(v554 + 20);
        if ((v68 & 0x40000000) != 0) {
          uint64_t v69 = *(llvm::FixedVectorType ****)(v554 - 8);
        }
        else {
          uint64_t v69 = (llvm::FixedVectorType ***)(v554 - 32 * (v68 & 0x7FFFFFF));
        }
        uint64_t v155 = **v69;
        uint64_t v156 = *(void *)(a1 + 1936);
        llvm::TargetTransformInfo::getCastContextHint(v554);
        v610 = (uint64_t *)(*(uint64_t (**)(void))(**(void **)v156 + 840))();
        uint64_t v611 = v157;
        if (v28)
        {
          __dst = (void *)(v25 - v9);
          LODWORD(v601) = 0;
          sub_1CB90C9D4((uint64_t)&__dst, (uint64_t)&v610);
          if (v601 == 1) {
            LODWORD(v595[1]) = 1;
          }
          if (__OFSUB__(v572, __dst)) {
            unint64_t v158 = ((v572 - (unsigned char *)__dst) >> 63) ^ 0x8000000000000000;
          }
          else {
            unint64_t v158 = v572 - (unsigned char *)__dst;
          }
          uint64_t v159 = v565;
        }
        else
        {
          uint64_t v159 = v565;
          unint64_t v158 = (unint64_t)v572;
        }
        __dst = (void *)v9;
        LODWORD(v601) = 0;
        sub_1CB90C9D4((uint64_t)&__dst, (uint64_t)&v610);
        BOOL v174 = __dst;
        uint64_t v175 = v601;
        llvm::FixedVectorType::get(v155, v562);
        uint64_t v177 = v176;
        uint64_t v178 = *(void *)(a1 + 2144);
        uint64_t v179 = *(unsigned int *)(a1 + 2160);
        if (!v179) {
          goto LABEL_264;
        }
        LODWORD(v180) = (v179 - 1) & ((v554 >> 4) ^ (v554 >> 9));
        unsigned int v181 = (uint64_t *)(v178 + 16 * v180);
        uint64_t v182 = *v181;
        if (v554 == *v181) {
          goto LABEL_265;
        }
        int v183 = 1;
        do
        {
          if (v182 == -4096)
          {
LABEL_264:
            unsigned int v181 = (uint64_t *)(v178 + 16 * v179);
            goto LABEL_265;
          }
          int v184 = v180 + v183++;
          uint64_t v180 = v184 & (v179 - 1);
          uint64_t v182 = *(void *)(v178 + 16 * v180);
        }
        while (v554 != v182);
        unsigned int v181 = (uint64_t *)(v178 + 16 * v180);
LABEL_265:
        if (v181 == (uint64_t *)(v178 + 16 * v179) || v159 != v176)
        {
          uint64_t v199 = v6;
          uint64_t v200 = *(void **)(a1 + 1936);
          uint64_t v201 = *(void *)(v199 + 384);
          if (v201) {
            uint64_t v202 = *(unsigned __int8 *)(v201 + 16) - 28;
          }
          else {
            uint64_t v202 = 0;
          }
          uint64_t CastContextHint = llvm::TargetTransformInfo::getCastContextHint(v554);
          uint64_t v205 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, void, uint64_t))(*(void *)*v200 + 840))(*v200, v202, v565, v177, CastContextHint, 0, v554);
          uint64_t v198 = LODWORD(v595[1]);
          unint64_t v197 = v158 + v205;
          if (__OFADD__(v158, v205)) {
            unint64_t v197 = ((uint64_t)(v158 + v205) >> 63) ^ 0x8000000000000000;
          }
          if (v206 == 1) {
            uint64_t v198 = 1;
          }
        }
        else
        {
          unint64_t v197 = 0;
          uint64_t v198 = 0;
        }
        if (v175 == 1) {
          uint64_t v198 = 1;
        }
        BOOL v270 = __OFSUB__(v197, v174);
        int64_t v207 = v197 - (void)v174;
        if (v270) {
          int64_t v207 = (v207 >> 63) ^ 0x8000000000000000;
        }
        *(void *)&long long v592 = v207;
        *((void *)&v592 + 1) = v198;
        goto LABEL_281;
      case 'Q':
      case 'R':
      case 'U':
        v610 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, llvm::FixedVectorType *, uint64_t, uint64_t, void, uint64_t))(***(void ***)(a1 + 1936) + 864))(**(void **)(a1 + 1936), v67, v556, **(void **)(a1 + 2072) + 1888, 42, 0, v554);
        uint64_t v611 = v463;
        if (v28)
        {
          __dst = (void *)(v25 - v9);
          LODWORD(v601) = 0;
          sub_1CB90C9D4((uint64_t)&__dst, (uint64_t)&v610);
          if (v601 == 1) {
            LODWORD(v595[1]) = 1;
          }
          int64_t v464 = v572 - (unsigned char *)__dst;
          if (__OFSUB__(v572, __dst)) {
            int64_t v464 = (v464 >> 63) ^ 0x8000000000000000;
          }
          v572 = (unsigned char *)v464;
        }
        llvm::FixedVectorType::get((llvm::FixedVectorType *)(**(void **)(a1 + 2072) + 1888), (llvm::Type *)v9);
        uint64_t v583 = v465;
        __dst = (void *)*(unsigned int *)(v17 + 32);
        LODWORD(v601) = 0;
        sub_1CB90C9D4((uint64_t)&__dst, (uint64_t)&v610);
        v466 = __dst;
        uint64_t v571 = v601;
        if (!v9) {
          goto LABEL_742;
        }
        uint64_t v470 = 8 * v9;
        char v471 = 1;
        int v472 = 42;
        v473 = v8;
        while (1)
        {
          uint64_t v474 = *v473;
          LODWORD(__dst) = 0;
          if (sub_1CD8E6F44((int *)&__dst, v474))
          {
            uint64_t v467 = __dst;
          }
          else
          {
            unsigned int v475 = *(unsigned __int8 *)(v474 + 16);
            if (v474) {
              BOOL v476 = v475 >= 0x1C;
            }
            else {
              BOOL v476 = 0;
            }
            if (!v476 || v475 - 83 < 0xFFFFFFFE)
            {
LABEL_742:
              uint64_t v467 = 42;
LABEL_743:
              uint64_t v468 = *(void *)(v579 + 384);
              if (v468) {
                uint64_t v469 = *(unsigned __int8 *)(v468 + 16) - 28;
              }
              else {
                uint64_t v469 = 0;
              }
              v478 = (void *)(*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, void, uint64_t))(***(void ***)(a1 + 1936) + 864))(**(void **)(a1 + 1936), v469, v565, v583, v467, 0, v554);
              int v480 = v479;
              v597 = v478;
              uint64_t v598 = v479;
              uint64_t canConvertToMinOrMaxIntrinsic = llvm::canConvertToMinOrMaxIntrinsic(v8, v9);
              uint64_t v482 = canConvertToMinOrMaxIntrinsic;
              if (canConvertToMinOrMaxIntrinsic)
              {
                v581 = v466;
                uint64_t __src = v565;
                uint64_t v594 = v565;
                __dst = 0;
                uint64_t v601 = v565;
                LODWORD(v602) = canConvertToMinOrMaxIntrinsic;
                v603 = v605;
                uint64_t v604 = 0x400000000;
                v606 = v608;
                uint64_t v607 = 0x400000000;
                v608[8] = 0;
                long long v609 = xmmword_1CD96D880;
                sub_1CC1587C8((uint64_t)&v603, (uint64_t)v605, (char *)&__src, (char *)v595);
                int64_t v483 = (*(uint64_t (**)(void))(***(void ***)(a1 + 1936) + 952))();
                int v485 = v484;
                uint64_t __src = v483;
                uint64_t v594 = v484;
                if ((v482 & 0x100000000) != 0)
                {
                  uint64_t v486 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, void, void))(***(void ***)(a1 + 1936) + 864))(**(void **)(a1 + 1936), 53, v565, v583, v467, 0, 0);
                  if (v487 == 1)
                  {
                    int v485 = 1;
                    LODWORD(v594) = 1;
                  }
                  if (__OFSUB__(v483, v486)) {
                    int64_t v483 = ((v483 - v486) >> 63) ^ 0x8000000000000000;
                  }
                  else {
                    v483 -= v486;
                  }
                  uint64_t __src = v483;
                }
                BOOL v488 = v483 < (uint64_t)v478;
                if (v485 != v480) {
                  BOOL v488 = v485 < v480;
                }
                BOOL v15 = !v488;
                p_src = &v597;
                if (!v15) {
                  p_src = (void **)&__src;
                }
                v490 = *p_src;
                LODWORD(v598) = *((_DWORD *)p_src + 2);
                v597 = v490;
                if (v606 != v608) {
                  free(v606);
                }
                v491 = v572;
                v466 = v581;
                if (v603 != v605) {
                  free(v603);
                }
                int v480 = v598;
                v478 = v597;
              }
              else
              {
                v491 = v572;
              }
              v496 = v595[1];
              unint64_t v497 = (unint64_t)v478 + (void)v491;
              if (__OFADD__(v491, v478)) {
                unint64_t v497 = (((uint64_t)v478 + (uint64_t)v491) >> 63) ^ 0x8000000000000000;
              }
              if (v480 == 1 || v571 == 1) {
                v496 = (void *)((unint64_t)v595[1] & 0xFFFFFFFF00000000 | 1);
              }
              BOOL v270 = __OFSUB__(v497, v466);
              int64_t v499 = v497 - (void)v466;
              if (v270) {
                int64_t v499 = (v499 >> 63) ^ 0x8000000000000000;
              }
              *(void *)&long long v592 = v499;
              *((void *)&v592 + 1) = v496;
LABEL_281:
              unsigned int v208 = v614;
              if (v614 == (char *)v616) {
                return v592;
              }
LABEL_282:
              free(v208);
              return v592;
            }
            uint64_t v467 = *(_WORD *)(v474 + 18) & 0x3F;
          }
          if (!(v471 & 1 | (v472 == v467))) {
            goto LABEL_742;
          }
          char v471 = 0;
          ++v473;
          int v472 = v467;
          v470 -= 8;
          if (!v470) {
            goto LABEL_743;
          }
        }
      case 'S':
        *(void *)&long long v592 = 0;
        DWORD2(v592) = 0;
        goto LABEL_281;
      case 'T':
        int v242 = llvm::getVectorIntrinsicIDForCall(v554, *(uint64_t **)(a1 + 1944));
        llvm::IntrinsicCostAttributes::IntrinsicCostAttributes((uint64_t)&__dst, v242, v554, 1, 0);
        v597 = (void *)(*(uint64_t (**)(void))(***(void ***)(a1 + 1936) + 952))();
        uint64_t v598 = v243;
        if (v28)
        {
          v610 = (uint64_t *)(v25 - v9);
          LODWORD(v611) = 0;
          sub_1CB90C9D4((uint64_t)&v610, (uint64_t)&v597);
          if (v611 == 1) {
            LODWORD(v595[1]) = 1;
          }
          if (__OFSUB__(v572, v610)) {
            unint64_t v244 = ((v572 - (unsigned char *)v610) >> 63) ^ 0x8000000000000000;
          }
          else {
            unint64_t v244 = v572 - (unsigned char *)v610;
          }
        }
        else
        {
          unint64_t v244 = (unint64_t)v572;
        }
        v610 = (uint64_t *)*(unsigned int *)(v565 + 32);
        LODWORD(v611) = 0;
        sub_1CB90C9D4((uint64_t)&v610, (uint64_t)&v597);
        v366 = v610;
        int v367 = v611;
        sub_1CD3309C4((uint64_t)&v610, v554, v565, *(void **)(a1 + 1936), *(uint64_t **)(a1 + 1944));
        int v368 = v613;
        uint64_t v369 = v612;
        BOOL v370 = v612 < (uint64_t)v610;
        if (v613 != v611) {
          BOOL v370 = v613 < (int)v611;
        }
        if (!v370)
        {
          uint64_t v369 = (uint64_t)v610;
          int v368 = v611;
        }
        BOOL v270 = __OFADD__(v244, v369);
        int64_t v371 = v244 + v369;
        if (v270) {
          int64_t v371 = (v371 >> 63) ^ 0x8000000000000000;
        }
        BOOL v15 = v368 == 1;
        v372 = (void *)((unint64_t)v595[1] & 0xFFFFFFFF00000000 | 1);
        if (!v15 && v367 != 1) {
          v372 = v595[1];
        }
        BOOL v270 = __OFSUB__(v371, v366);
        unint64_t v374 = v371 - (void)v366;
        unint64_t v375 = ((v371 - (uint64_t)v366) >> 63) ^ 0x8000000000000000;
        if (v270) {
          unint64_t v374 = v375;
        }
        *(void *)&long long v592 = v374;
        *((void *)&v592 + 1) = v372;
        if (v606 != v608) {
          free(v606);
        }
        v376 = v603;
        if (v603 == v605) {
          goto LABEL_281;
        }
        goto LABEL_734;
      case 'Y':
      case '\\':
        if (v28)
        {
          uint64_t v210 = *(unsigned int *)(v6 + 104);
          if (v210)
          {
            uint64_t v211 = 0;
            int v212 = *(unsigned int **)(v6 + 96);
            uint64_t v213 = 4 * v210;
            do
            {
              if (v67 == 61)
              {
                int v214 = *(uint64_t **)(v582 + 1936);
                sub_1CD32B9E0(v8[*v212]);
                uint64_t v215 = *v214;
                a1 = v582;
                LODWORD(v10) = v9;
                uint64_t v216 = (*(uint64_t (**)(void))(*(void *)v215 + 872))();
                if (v217 == 1) {
                  LODWORD(v41) = 1;
                }
                unint64_t v218 = (unint64_t)&v572[-v216];
                if (__OFSUB__(v572, v216)) {
                  unint64_t v218 = ((uint64_t)&v572[-v216] >> 63) ^ 0x8000000000000000;
                }
                v572 = (unsigned char *)v218;
              }
              else
              {
                uint64_t v219 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(***(void ***)(a1 + 1936) + 872))(**(void **)(a1 + 1936), 61, v565, v211);
                if (v220 == 1) {
                  LODWORD(v41) = 1;
                }
                unint64_t v221 = (unint64_t)&v572[-v219];
                if (__OFSUB__(v572, v219)) {
                  unint64_t v221 = ((uint64_t)&v572[-v219] >> 63) ^ 0x8000000000000000;
                }
                v572 = (unsigned char *)v221;
                uint64_t v211 = (v211 + 1);
              }
              ++v212;
              v213 -= 4;
            }
            while (v213);
          }
          if (v10)
          {
            uint64_t v222 = 8 * v9;
            uint64_t v223 = v8;
            do
            {
              uint64_t v224 = *(void *)(a1 + 1936);
              if (v67 == 61)
              {
                sub_1CD32B9E0(*v223);
                int v225 = *(uint64_t (**)(void))(**(void **)v224 + 872);
                LODWORD(v10) = v9;
              }
              else
              {
                LODWORD(v25) = v25 - 1;
                int v225 = *(uint64_t (**)(void))(**(void **)v224 + 872);
              }
              uint64_t v226 = v225();
              if (v227 == 1) {
                LODWORD(v41) = 1;
              }
              unint64_t v228 = (unint64_t)&v572[v226];
              if (__OFADD__(v572, v226)) {
                unint64_t v228 = ((uint64_t)&v572[v226] >> 63) ^ 0x8000000000000000;
              }
              v572 = (unsigned char *)v228;
              ++v223;
              v222 -= 8;
            }
            while (v222);
          }
          LODWORD(v595[1]) = v41;
          v229 = v572;
          v595[0] = v572;
        }
        else
        {
          v229 = v572;
        }
        if (v67 != 64)
        {
          sub_1CD33017C((uint64_t)v584, (int64_t *)v595);
LABEL_369:
          long long v592 = *(_OWORD *)v595;
          goto LABEL_281;
        }
        if (!v10) {
          goto LABEL_367;
        }
        uint64_t v260 = 0;
        while (1)
        {
          uint64_t v261 = *(void *)(v8[v260] + 8);
          if (!v261) {
            goto LABEL_360;
          }
          if (*(void *)(v261 + 8)) {
            goto LABEL_360;
          }
          uint64_t v262 = *(void *)(v261 + 24);
          int v263 = *(unsigned __int8 *)(v262 + 16);
          if ((v263 - 67) > 1) {
            goto LABEL_360;
          }
          uint64_t v264 = *(void *)(v262 + 8);
          if (v264) {
            break;
          }
LABEL_355:
          uint64_t v265 = (*(uint64_t (**)(void, void, void, uint64_t, uint64_t))(***(void ***)(a1 + 1936) + 848))(**(void **)(a1 + 1936), (v263 - 28), *(void *)v262, v565, v260);
          unint64_t v267 = (unint64_t)v229 - v265;
          if (__OFSUB__(v229, v265)) {
            unint64_t v267 = (((uint64_t)v229 - v265) >> 63) ^ 0x8000000000000000;
          }
          unint64_t v575 = v267;
          int v580 = v266;
          uint64_t v268 = *(void *)(a1 + 1936);
          llvm::TargetTransformInfo::getCastContextHint(v262);
          a1 = v582;
          uint64_t v269 = (*(uint64_t (**)(void))(**(void **)v268 + 840))();
          if (v580 == 1) {
            LODWORD(v41) = 1;
          }
          BOOL v270 = __OFADD__(v575, v269);
          uint64_t v271 = v575 + v269;
LABEL_363:
          if (v270) {
            v229 = (void *)((v271 >> 63) ^ 0x8000000000000000);
          }
          else {
            v229 = (void *)v271;
          }
          if (++v260 == v9)
          {
LABEL_367:
            LODWORD(v595[1]) = v41;
            v595[0] = v229;
            goto LABEL_369;
          }
        }
        while (*(unsigned char *)(*(void *)(v264 + 24) + 16) == 62)
        {
          uint64_t v264 = *(void *)(v264 + 8);
          if (!v264) {
            goto LABEL_355;
          }
        }
LABEL_360:
        uint64_t v272 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(***(void ***)(a1 + 1936) + 872))(**(void **)(a1 + 1936), 61, v565, v260);
        if (v273 == 1) {
          LODWORD(v41) = 1;
        }
        BOOL v270 = __OFSUB__(v229, v272);
        uint64_t v271 = (uint64_t)v229 - v272;
        goto LABEL_363;
      case 'Z':
        uint64_t v578 = *(void *)v554;
        uint64_t v500 = *(unsigned int *)(*(void *)v554 + 32);
        LODWORD(v594) = v500;
        if (v500 > 0x40) {
          llvm::APInt::initSlowCase((llvm::APInt *)&__src);
        }
        uint64_t __src = 0;
        __dst = &v602;
        HIDWORD(v601) = 12;
        uint64_t v501 = *(unsigned int *)(v6 + 136);
        if (v501)
        {
          uint64_t v504 = *(void *)(v6 + 128);
          LODWORD(v601) = 0;
          if (v501 >= 0xD) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          memset(&v602, 255, 4 * v501);
          uint64_t v505 = 0;
          LODWORD(v601) = v601 + v501;
          do
          {
            *((_DWORD *)&v602 + *(unsigned int *)(v504 + 4 * v505)) = v505;
            ++v505;
          }
          while (v501 != v505);
          uint64_t v506 = (v500 - v9);
          int v507 = v601;
          if ((unint64_t)v601 + v506 > HIDWORD(v601)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          if (v500 != v9)
          {
            memset((char *)__dst + 4 * v601, 255, 4 * v506);
            int v507 = v601;
          }
          LODWORD(v601) = v507 + v506;
        }
        else
        {
          if (v500 >= 0xD)
          {
            LODWORD(v601) = 0;
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          if (v500) {
            memset(&v602, 255, 4 * v500);
          }
          LODWORD(v601) = v500;
          if (v9)
          {
            uint64_t v502 = 0;
            uint64_t v503 = 4 * v9;
            do
            {
              *((_DWORD *)&v602 + v502) = v502;
              ++v502;
              v503 -= 4;
            }
            while (v503);
          }
        }
        unsigned int v508 = sub_1CD32AEA4(v554, 0);
        v610 = &v612;
        HIDWORD(v611) = 12;
        if (v500 >= 0xD)
        {
          LODWORD(v611) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v500) {
          memset(&v612, 255, 4 * v500);
        }
        LODWORD(v611) = v500;
        sub_1CD8DCFDC(&__dst, &v610);
        if (v9)
        {
          uint64_t v509 = 0;
          v510 = v610;
          v511 = __dst;
          char v512 = 1;
          do
          {
            unsigned int v513 = sub_1CD32AEA4(v8[*((int *)v510 + v509)], 0);
            uint64_t v514 = 1 << v513;
            if (v594 > 0x40) {
              *(void *)(__src + 8 * (v513 >> 6)) |= v514;
            }
            else {
              __src |= v514;
            }
            uint64_t v515 = v513 - v508;
            v512 &= v509 == v515;
            v511[v515] = v509++;
          }
          while (v9 != v509);
        }
        else
        {
          char v512 = 1;
        }
        uint64_t v516 = (*(uint64_t (**)(void, uint64_t, uint64_t *, uint64_t, void))(***(void ***)(v582 + 1936)
                                                                                      + 528))(**(void **)(v582 + 1936), v578, &__src, 1, 0);
        DWORD2(v592) = v517 == 1;
        if (__OFSUB__(0, v516)) {
          uint64_t v518 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v518 = -v516;
        }
        *(void *)&long long v592 = v518;
        if (v500 == v9) {
          char v519 = 0;
        }
        else {
          char v519 = v512;
        }
        if ((v519 & 1) != 0 && v508 % v9)
        {
          if (v9 + v508)
          {
            unint64_t v520 = (v9 + v508 - 1) | (((unint64_t)(v9 + v508) - 1) >> 1) | (((v9 + v508 - 1) | (((unint64_t)(v9 + v508) - 1) >> 1)) >> 2);
            unint64_t v521 = v520 | (v520 >> 4) | ((v520 | (v520 >> 4)) >> 8);
            v522 = (llvm::Type *)(((v521 >> 16) | v521) + 1);
          }
          else
          {
            v522 = 0;
          }
          uint64_t v532 = *(void *)(v582 + 1936);
          v533.n128_f64[0] = llvm::FixedVectorType::get(*(llvm::FixedVectorType **)(v578 + 24), v522);
          uint64_t v534 = (*(uint64_t (**)(__n128))(**(void **)v532 + 832))(v533);
        }
        else
        {
          if (v512) {
            goto LABEL_866;
          }
          v523 = *(uint64_t **)v579;
          uint64_t v524 = *(unsigned int *)(v579 + 8);
          if (v524)
          {
            v525 = *(uint64_t **)v579;
            while (1)
            {
              uint64_t v526 = *v525;
              int v527 = *(_DWORD *)(*v525 + 20);
              v528 = (v527 & 0x40000000) != 0 ? *(uint64_t **)(v526 - 8) : (uint64_t *)(v526 - 32 * (v527 & 0x7FFFFFF));
              uint64_t v529 = *v528;
              uint64_t v530 = 8 * v524;
              v531 = *(uint64_t **)v579;
              do
              {
                if (*v531 == v529) {
                  goto LABEL_850;
                }
                ++v531;
                v530 -= 8;
              }
              while (v530);
              v531 = &v523[v524];
LABEL_850:
              if (v524 == v531 - v523) {
                break;
              }
              if (++v525 == &v523[v524])
              {
                v523 += v524;
                goto LABEL_856;
              }
            }
            v523 = v525;
          }
LABEL_856:
          uint64_t v536 = *v523;
          int v537 = *(_DWORD *)(v536 + 20);
          if ((v537 & 0x40000000) != 0) {
            v538 = *(unsigned __int8 ***)(v536 - 8);
          }
          else {
            v538 = (unsigned __int8 **)(v536 - 32 * (v537 & 0x7FFFFFF));
          }
          if (!sub_1CD330918(*v538))
          {
            v597 = v599;
            HIDWORD(v598) = 12;
            if (v500)
            {
              bzero(v599, 4 * v500);
              uint64_t v540 = 0;
              LODWORD(v598) = v500;
              uint64_t v541 = 4 * v500;
              do
              {
                v599[v540] = v540;
                ++v540;
                v541 -= 4;
              }
              while (v541);
              v542 = (int *)__dst;
              uint64_t v543 = v500;
              do
              {
                int v544 = *v542++;
                if (v544 != -1) {
                  v599[v508] = v500;
                }
                ++v508;
                LODWORD(v500) = v500 + 1;
                --v543;
              }
              while (v543);
              uint64_t v545 = v598;
            }
            else
            {
              uint64_t v545 = 0;
              LODWORD(v598) = 0;
            }
            uint64_t v546 = (*(uint64_t (**)(void, uint64_t, uint64_t, _DWORD *, uint64_t, void, void))(***(void ***)(v582 + 1936) + 832))(**(void **)(v582 + 1936), 6, v578, v599, v545, 0, 0);
            if (v547 == 1) {
              DWORD2(v592) = 1;
            }
            unint64_t v548 = v518 + v546;
            if (__OFADD__(v518, v546)) {
              unint64_t v548 = ((v518 + v546) >> 63) ^ 0x8000000000000000;
            }
            *(void *)&long long v592 = v548;
            if (v597 != v599) {
              free(v597);
            }
LABEL_866:
            if (v610 != &v612) {
              free(v610);
            }
            if (__dst != &v602) {
              free(__dst);
            }
            if (v594 >= 0x41 && __src) {
              MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
            }
            goto LABEL_281;
          }
          uint64_t v534 = (*(uint64_t (**)(void, uint64_t, uint64_t, void *, void, void, void))(***(void ***)(v582 + 1936) + 832))(**(void **)(v582 + 1936), 7, v578, __dst, v601, 0, 0);
        }
        if (v535 == 1) {
          DWORD2(v592) = 1;
        }
        unint64_t v539 = v518 + v534;
        if (__OFADD__(v518, v534)) {
          unint64_t v539 = ((v518 + v534) >> 63) ^ 0x8000000000000000;
        }
        *(void *)&long long v592 = v539;
        goto LABEL_866;
      case '[':
        goto LABEL_55;
      default:
        if (!v9)
        {
          uint64_t v240 = 1;
          uint64_t v241 = 2;
          goto LABEL_708;
        }
        uint64_t v332 = 0;
        uint64_t v333 = 0;
        LODWORD(v241) = 2;
        LODWORD(v240) = 1;
        break;
    }
    while (1)
    {
      uint64_t v334 = v8[v332];
      int v335 = *(_DWORD *)(v334 + 20);
      if ((v335 & 0x40000000) != 0) {
        uint64_t v336 = *(void *)(v334 - 8);
      }
      else {
        uint64_t v336 = v334 - 32 * (v335 & 0x7FFFFFF);
      }
      uint64_t v337 = *(void *)(v336 + 32 * (*(unsigned __int8 *)(v334 + 16) - 41 < 0x12));
      if (v337) {
        BOOL v338 = *(unsigned char *)(v337 + 16) == 16;
      }
      else {
        BOOL v338 = 0;
      }
      if (!v338)
      {
        uint64_t v241 = 0;
        uint64_t v240 = 0;
LABEL_708:
        int v446 = *(_DWORD *)(v554 + 20);
        if ((v446 & 0x40000000) != 0)
        {
          v448 = *(char **)(v554 - 8);
          uint64_t v447 = v446 & 0x7FFFFFF;
        }
        else
        {
          uint64_t v447 = v446 & 0x7FFFFFF;
          v448 = (char *)(v554 - 32 * v447);
        }
        __dst = &v602;
        uint64_t v601 = 0x400000000;
        sub_1CD77B118((uint64_t)&__dst, v448, &v448[32 * v447]);
        uint64_t v449 = *(void *)(v579 + 384);
        if (v449) {
          uint64_t v450 = *(unsigned __int8 *)(v449 + 16) - 28;
        }
        else {
          uint64_t v450 = 0;
        }
        v597 = (void *)(*(uint64_t (**)(void, uint64_t, llvm::FixedVectorType *, void, void, uint64_t, void, uint64_t, void *, void, uint64_t))(***(void ***)(a1 + 1936) + 824))(**(void **)(a1 + 1936), v450, v556, 0, 0, v241, 0, v240, __dst, v601, v554);
        uint64_t v598 = v451;
        if (v28)
        {
          v610 = (uint64_t *)(v25 - v9);
          LODWORD(v611) = 0;
          sub_1CB90C9D4((uint64_t)&v610, (uint64_t)&v597);
          if (v611 == 1) {
            LODWORD(v595[1]) = 1;
          }
          if (__OFSUB__(v572, v610)) {
            unint64_t v452 = ((v572 - (unsigned char *)v610) >> 63) ^ 0x8000000000000000;
          }
          else {
            unint64_t v452 = v572 - (unsigned char *)v610;
          }
        }
        else
        {
          unint64_t v452 = (unint64_t)v572;
        }
        v610 = (uint64_t *)*(unsigned int *)(v565 + 32);
        LODWORD(v611) = 0;
        sub_1CB90C9D4((uint64_t)&v610, (uint64_t)&v597);
        v453 = v610;
        uint64_t v454 = v611;
        uint64_t v455 = *(void *)(v579 + 384);
        if (v455) {
          uint64_t v456 = *(unsigned __int8 *)(v455 + 16) - 28;
        }
        else {
          uint64_t v456 = 0;
        }
        uint64_t v457 = (*(uint64_t (**)(void, uint64_t, uint64_t, void, void, uint64_t, void, uint64_t, void *, void, uint64_t))(***(void ***)(a1 + 1936) + 824))(**(void **)(a1 + 1936), v456, v565, 0, 0, v241, 0, v240, __dst, v601, v554);
        v459 = v595[1];
        unint64_t v460 = v452 + v457;
        if (__OFADD__(v452, v457)) {
          unint64_t v460 = ((uint64_t)(v452 + v457) >> 63) ^ 0x8000000000000000;
        }
        if (v458 == 1 || v454 == 1) {
          v459 = (void *)((unint64_t)v595[1] & 0xFFFFFFFF00000000 | 1);
        }
        BOOL v270 = __OFSUB__(v460, v453);
        int64_t v462 = v460 - (void)v453;
        if (v270) {
          int64_t v462 = (v462 >> 63) ^ 0x8000000000000000;
        }
        *(void *)&long long v592 = v462;
        *((void *)&v592 + 1) = v459;
        v376 = __dst;
        if (__dst != &v602) {
LABEL_734:
        }
          free(v376);
        goto LABEL_281;
      }
      if (v240 != 1) {
        break;
      }
      uint64_t v339 = *(unsigned int *)(v337 + 32);
      if (v339 > 0x40)
      {
        int v342 = 0;
        unint64_t v343 = (unint64_t)(v339 + 63) >> 6;
        v344 = *(int8x8_t **)(v337 + 24);
        do
        {
          int8x8_t v345 = *v344++;
          uint8x8_t v346 = (uint8x8_t)vcnt_s8(v345);
          v346.i16[0] = vaddlv_u8(v346);
          v342 += v346.i32[0];
          --v343;
        }
        while (v343);
        BOOL v341 = v342 == 1;
      }
      else
      {
        uint64_t v340 = *(void *)(v337 + 24);
        if (!v340) {
          break;
        }
        BOOL v341 = (v340 & (v340 - 1)) == 0;
      }
      uint64_t v240 = v341;
LABEL_521:
      if (v333 == v337 || v332 == 0) {
        uint64_t v241 = v241;
      }
      else {
        uint64_t v241 = 3;
      }
      if (!v332) {
        uint64_t v333 = v337;
      }
      if (++v332 == v9) {
        goto LABEL_708;
      }
    }
    uint64_t v240 = 0;
    goto LABEL_521;
  }
  if (!v9)
  {
LABEL_32:
    *(void *)&long long v592 = 0;
    DWORD2(v592) = 0;
    return v592;
  }
  unint64_t v30 = 0;
  uint64_t v31 = 8 * v9;
  while (1)
  {
    int v32 = *(unsigned __int8 *)(v8[v30 / 8] + 16);
    if (v32 == 5 || (v32 - 4) >= 0x11) {
      break;
    }
    v30 += 8;
    if (v31 == v30) {
      goto LABEL_32;
    }
  }
  if (*(unsigned char *)(*v8 + 16) == 90) {
    return xmmword_1CD96D880;
  }
  v614 = (char *)v616;
  uint64_t v615 = 0xC00000000;
  v552 = &v612;
  v610 = &v612;
  uint64_t v34 = 0x600000000;
  uint64_t v611 = 0x600000000;
  unint64_t isGatherShuffledEntry = llvm::slpvectorizer::BoUpSLP::isGatherShuffledEntry(a1, v6, &v614, (uint64_t *)&v610);
  if (HIDWORD(isGatherShuffledEntry))
  {
    unint64_t v171 = isGatherShuffledEntry;
    *(void *)&long long v592 = 0;
    DWORD2(v592) = 0;
    if (!sub_1CC5D47FC((int *)v614, v615, v615))
    {
      sub_1CD324BD0(&v614, *(int **)(v6 + 96), *(unsigned int *)(v6 + 104));
      *(void *)&long long v592 = (*(uint64_t (**)(void, unint64_t))(***(void ***)(a1 + 1936) + 832))(**(void **)(a1 + 1936), v171);
      DWORD2(v592) = v203;
      goto LABEL_787;
    }
    uint64_t v172 = &v612;
    if (v28)
    {
      *(void *)&long long v592 = (*(uint64_t (**)(void, uint64_t, uint64_t, void, void, void, void))(***(void ***)(a1 + 1936) + 832))(**(void **)(a1 + 1936), 7, v560, *(void *)(v6 + 96), *(unsigned int *)(v6 + 104), 0, 0);
      DWORD2(v592) = v173;
    }
    goto LABEL_788;
  }
  uint64_t v128 = *(void *)(v6 + 384);
  if (!v128 || *(unsigned char *)(v128 + 16) != 89)
  {
    uint64_t v129 = *(unsigned int *)(v6 + 8);
    if (v129)
    {
      uint64_t v130 = *(void *)v6;
      uint64_t v131 = 8 * v129;
      do
      {
        int v132 = *(unsigned __int8 *)(*(void *)v130 + 16);
        if ((v132 - 11) >= 2 && v132 != 89) {
          goto LABEL_198;
        }
        v130 += 8;
        v131 -= 8;
      }
      while (v131);
    }
  }
  if ((int)v9 >= 2)
  {
    int v133 = (void **)(v8 + 1);
    unint64_t v134 = v9 - 1;
    while (**v133 == *(void *)*v8)
    {
      ++v133;
      if (!--v134) {
        goto LABEL_195;
      }
    }
    goto LABEL_198;
  }
LABEL_195:
  __dst = &v602;
  uint64_t v601 = 0xC00000000;
  unint64_t v135 = sub_1CD32FEE4((uint64_t)v8, v9, (char **)&__dst);
  if (HIDWORD(v135))
  {
    unint64_t v232 = v135;
    v574 = __dst;
    uint64_t v233 = v601;
    BOOL v234 = *(void **)(a1 + 1936);
    unsigned int v235 = (*(uint64_t (**)(void, uint64_t))(*(void *)*v234 + 968))(*v234, v565);
    if (v232 != 7 || !v235 || (unsigned int v236 = *(_DWORD *)(v565 + 32), v236 < v235))
    {
      uint64_t v237 = (*(uint64_t (**)(void, unint64_t, uint64_t, _DWORD *, uint64_t, void, void))(*(void *)*v234 + 832))(*v234, v232, v565, v574, v233, 0, 0);
      unint64_t v239 = v238 & 0xFFFFFFFF00000000;
LABEL_554:
      *(void *)&long long v592 = v237;
      *((void *)&v592 + 1) = v239 | v238;
      sub_1CD33017C((uint64_t)v584, (int64_t *)&v592);
      uint64_t v172 = &v612;
      if (v28)
      {
        uint64_t v363 = (*(uint64_t (**)(void, uint64_t, uint64_t, void, void, void, void))(***(void ***)(a1 + 1936) + 832))(**(void **)(a1 + 1936), 7, v560, *(void *)(v579 + 96), *(unsigned int *)(v579 + 104), 0, 0);
        if (v364 == 1) {
          DWORD2(v592) = 1;
        }
        unint64_t v365 = v592 + v363;
        if (__OFADD__((void)v592, v363)) {
          unint64_t v365 = (((uint64_t)v592 + v363) >> 63) ^ 0x8000000000000000;
        }
        *(void *)&long long v592 = v365;
      }
      if (__dst != &v602) {
        free(__dst);
      }
      goto LABEL_788;
    }
    v558 = v234;
    int v564 = 0;
    unint64_t v567 = 0;
    unsigned int v348 = 1;
    v349 = v8;
    char v350 = 1;
    v351 = (llvm::Type *)(v236 / v235);
    while (1)
    {
      if (*(unsigned __int8 *)(*v349 + 16) - 11 < 2) {
        goto LABEL_552;
      }
      unsigned int v352 = v348 - 1;
      if (v574[v348 - 1] == -1) {
        goto LABEL_552;
      }
      unsigned int v353 = v352 % v351;
      if (v352 % v351) {
        break;
      }
      char v350 = 1;
LABEL_552:
      ++v349;
      ++v348;
      v31 -= 8;
      if (!v31)
      {
        unint64_t v239 = 0;
        uint64_t v237 = v567;
        LODWORD(v238) = v564;
        goto LABEL_554;
      }
    }
    char v569 = v350;
    uint64_t v354 = v348 - 2;
    unsigned int v355 = sub_1CD32B9E0(*v349);
    uint64_t v356 = v8[v354];
    if (*(unsigned __int8 *)(v356 + 16) - 11 < 2 || v574[v354] == -1)
    {
      if ((v569 & 1) == 0) {
        goto LABEL_539;
      }
    }
    else if (sub_1CD32B9E0(v356) + 1 != v355 {
           || (v569 & (v355 % v351 == v353)) == 0)
    }
    {
LABEL_539:
      if (!(v348 % v351) || v9 == v348)
      {
        double v357 = llvm::FixedVectorType::get(*(llvm::FixedVectorType **)(v565 + 24), v351);
        uint64_t v359 = (*(uint64_t (**)(void, uint64_t, uint64_t, void, void, void, void, double))(*(void *)*v558 + 832))(*v558, 7, v358, 0, 0, 0, 0, v357);
        char v350 = 0;
        if (v360 == 1) {
          int v361 = 1;
        }
        else {
          int v361 = v564;
        }
        int v564 = v361;
        unint64_t v362 = v567 + v359;
        if (__OFADD__(v567, v359)) {
          unint64_t v362 = ((uint64_t)(v567 + v359) >> 63) ^ 0x8000000000000000;
        }
        unint64_t v567 = v362;
      }
      else
      {
        char v350 = 0;
      }
      goto LABEL_551;
    }
    char v350 = 1;
LABEL_551:
    a1 = v582;
    goto LABEL_552;
  }
  if (__dst != &v602) {
    free(__dst);
  }
LABEL_198:
  uint64_t v136 = 0;
  uint64_t v137 = v8;
  do
  {
    if (*(unsigned __int8 *)(*v137 + 16) - 11 >= 2)
    {
      if (v136)
      {
        if (*v137 != v136) {
          goto LABEL_310;
        }
      }
      else
      {
        uint64_t v136 = *v137;
      }
    }
    ++v137;
    v31 -= 8;
  }
  while (v31);
  if (v136)
  {
    *(void *)&long long v592 = (*(uint64_t (**)(void, void, uint64_t, void, void, void, void))(***(void ***)(a1 + 1936) + 832))(**(void **)(a1 + 1936), 0, v565, 0, 0, 0, 0);
    *((void *)&v592 + 1) = v138;
    goto LABEL_787;
  }
LABEL_310:
  if (v28)
  {
    uint64_t v550 = (*(uint64_t (**)(void, uint64_t, uint64_t, void, void, void, void))(***(void ***)(a1 + 1936)
                                                                                               + 832))(**(void **)(a1 + 1936), 7, v560, *(void *)(v6 + 96), *(unsigned int *)(v6 + 104), 0, 0);
    uint64_t v231 = v230;
  }
  else
  {
    uint64_t v550 = 0;
    uint64_t v231 = 0;
  }
  if (v9 < 3
    || (uint64_t v274 = *(void *)(v6 + 384)) == 0
    || *(unsigned char *)(v274 + 16) != 60
    || v274 != *(void *)(v6 + 392))
  {
LABEL_781:
    unint64_t GatherCost = llvm::slpvectorizer::BoUpSLP::getGatherCost(a1, (llvm::FixedVectorType ***)v8, (llvm::Type *)v9);
    if (v493 == 1) {
      uint64_t v494 = 1;
    }
    else {
      uint64_t v494 = v231;
    }
    unint64_t v495 = v550 + GatherCost;
    if (__OFADD__(v550, GatherCost)) {
      unint64_t v495 = ((uint64_t)(v550 + GatherCost) >> 63) ^ 0x8000000000000000;
    }
    *(void *)&long long v592 = v495;
    *((void *)&v592 + 1) = v494;
    goto LABEL_787;
  }
  uint64_t v549 = v231;
  __dst = &v604;
  uint64_t v601 = (uint64_t)&v604;
  uint64_t v602 = 16;
  LODWORD(v603) = 0;
  LODWORD(v41) = sub_1CB83544C(*(void *)(a1 + 1984), *(void *)v274);
  if (v26 == 1) {
LABEL_895:
  }
  unsigned int v275 = 0;
  unsigned int v561 = 0;
  unsigned int v276 = 0;
  unsigned int v277 = *(_DWORD *)(a1 + 2004) / (2 * v41);
  if (v277 <= 2) {
    unsigned int v277 = 2;
  }
  unsigned int v555 = v277;
  do
  {
    unint64_t v10 = v10 >> 1;
    if (v10 < v555)
    {
      int v279 = HIDWORD(v602);
      int v280 = (int)v603;
      break;
    }
    unsigned int v278 = v276 + v10;
    unsigned int v576 = v276;
    if (v276 + v10 > v9) {
      goto LABEL_381;
    }
    unint64_t v281 = v10 - 1;
    v563 = (llvm::Type *)v10;
    do
    {
      unsigned int v282 = v276;
      unsigned int v276 = v278;
      v283 = &v8[v282];
      uint64_t v284 = *v283;
      v285 = __dst;
      if ((void *)v601 == __dst)
      {
        unsigned int v286 = HIDWORD(v602);
        v287 = (char *)(v601 + 8 * HIDWORD(v602));
        if (HIDWORD(v602))
        {
          uint64_t v288 = 0;
          while (*(void *)(v601 + v288) != v284)
          {
            v288 += 8;
            if (8 * HIDWORD(v602) == v288) {
              goto LABEL_404;
            }
          }
          v287 = (char *)(v601 + v288);
        }
LABEL_404:
        v296 = (void *)v601;
      }
      else
      {
        int v289 = v602 - 1;
        unsigned int v290 = (v602 - 1) & ((v284 >> 4) ^ (v284 >> 9));
        v287 = (char *)(v601 + 8 * v290);
        uint64_t v291 = *(void *)v287;
        if (*(void *)v287 == -1)
        {
          v292 = 0;
LABEL_406:
          if (v292) {
            v287 = v292;
          }
          unsigned int v286 = HIDWORD(v602);
          if (*(void *)v287 != v284) {
            v287 = (char *)(v601 + 8 * v602);
          }
        }
        else
        {
          v292 = 0;
          int v293 = 1;
          while (v291 != v284)
          {
            if (v292) {
              BOOL v294 = 0;
            }
            else {
              BOOL v294 = v291 == -2;
            }
            if (v294) {
              v292 = v287;
            }
            unsigned int v295 = v290 + v293++;
            unsigned int v290 = v295 & v289;
            v287 = (char *)(v601 + 8 * (v295 & v289));
            uint64_t v291 = *(void *)v287;
            if (*(void *)v287 == -1) {
              goto LABEL_406;
            }
          }
          unsigned int v286 = HIDWORD(v602);
        }
        v296 = __dst;
      }
      if ((void *)v601 == v296) {
        unsigned int v297 = v286;
      }
      else {
        unsigned int v297 = v602;
      }
      if (v287 != (char *)(v601 + 8 * v297)) {
        goto LABEL_490;
      }
      uint64_t v298 = v283[v281];
      if ((void *)v601 == v296)
      {
        v299 = (char *)(v601 + 8 * v286);
        if (v286)
        {
          uint64_t v300 = 0;
          while (*(void *)(v601 + v300) != v298)
          {
            v300 += 8;
            if (8 * v286 == v300) {
              goto LABEL_433;
            }
          }
          v299 = (char *)(v601 + v300);
        }
LABEL_433:
        v285 = (void *)v601;
      }
      else
      {
        int v301 = v602 - 1;
        unsigned int v302 = ((v298 >> 4) ^ (v298 >> 9)) & (v602 - 1);
        v299 = (char *)(v601 + 8 * v302);
        uint64_t v303 = *(void *)v299;
        if (*(void *)v299 == -1)
        {
          v304 = 0;
LABEL_493:
          if (v304) {
            v299 = v304;
          }
          if (*(void *)v299 != v298)
          {
            if ((void *)v601 == __dst) {
              unsigned int v331 = v286;
            }
            else {
              unsigned int v331 = v602;
            }
            v299 = (char *)(v601 + 8 * v331);
          }
        }
        else
        {
          v304 = 0;
          int v305 = 1;
          while (v303 != v298)
          {
            if (v304) {
              BOOL v306 = 0;
            }
            else {
              BOOL v306 = v303 == -2;
            }
            if (v306) {
              v304 = v299;
            }
            unsigned int v307 = v302 + v305++;
            unsigned int v302 = v307 & v301;
            v299 = (char *)(v601 + 8 * (v307 & v301));
            uint64_t v303 = *(void *)v299;
            if (*(void *)v299 == -1) {
              goto LABEL_493;
            }
          }
        }
      }
      if ((void *)v601 == v285) {
        unsigned int v308 = v286;
      }
      else {
        unsigned int v308 = v602;
      }
      if (v299 != (char *)(v601 + 8 * v308) || !sub_1CD32AB9C(&v8[v282], v10)) {
        goto LABEL_490;
      }
      v597 = v599;
      uint64_t v598 = v34;
      v595[0] = v596;
      v595[1] = (void *)0x400000000;
      int v309 = sub_1CD32AFC4(&v8[v282], v10, v284, *(void *)(v582 + 1936), *(llvm::DataLayout **)(v582 + 1984), *(const llvm::DataLayout **)(v582 + 1928), (unsigned int **)v595, (uint64_t)&v597);
      if ((v309 - 1) > 1) {
        goto LABEL_486;
      }
      unsigned int v557 = v275;
      BOOL v310 = v309 != 1;
      uint64_t v311 = v309 == 1;
      v312 = &v283[v10];
      v313 = (uint64_t *)v601;
      do
      {
        uint64_t v314 = *v283;
        uint64_t v315 = HIDWORD(v602);
        if (v313 != __dst)
        {
          unsigned int v319 = v602;
          goto LABEL_452;
        }
        if (!HIDWORD(v602))
        {
LABEL_449:
          unsigned int v319 = v602;
          if (HIDWORD(v602) < v602)
          {
            ++HIDWORD(v602);
            v313[v315] = v314;
            goto LABEL_473;
          }
LABEL_452:
          if (3 * v319 <= 4 * (HIDWORD(v602) - (int)v603))
          {
            if (v319 >= 0x40) {
              v319 *= 2;
            }
            else {
              unsigned int v319 = 128;
            }
          }
          else if (v319 - HIDWORD(v602) >= v319 >> 3)
          {
            goto LABEL_454;
          }
          uint64_t v329 = v311;
          llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&__dst, v319);
          uint64_t v311 = v329;
          unsigned int v319 = v602;
          v313 = (uint64_t *)v601;
LABEL_454:
          unsigned int v320 = v319 - 1;
          unsigned int v321 = (v319 - 1) & ((v314 >> 4) ^ (v314 >> 9));
          v322 = &v313[v321];
          uint64_t v323 = *v322;
          if (*v322 == -1)
          {
            v324 = 0;
LABEL_466:
            if (v324) {
              v328 = v324;
            }
            else {
              v328 = v322;
            }
            if (*v328 != v314)
            {
              if (*v328 == -2) {
                LODWORD(v603) = v603 - 1;
              }
              else {
                ++HIDWORD(v602);
              }
              uint64_t *v328 = v314;
            }
          }
          else
          {
            v324 = 0;
            int v325 = 1;
            while (v323 != v314)
            {
              if (v324) {
                BOOL v326 = 0;
              }
              else {
                BOOL v326 = v323 == -2;
              }
              if (v326) {
                v324 = v322;
              }
              unsigned int v327 = v321 + v325++;
              unsigned int v321 = v327 & v320;
              v322 = &v313[v327 & v320];
              uint64_t v323 = *v322;
              if (*v322 == -1) {
                goto LABEL_466;
              }
            }
          }
          goto LABEL_473;
        }
        v316 = 0;
        uint64_t v317 = 8 * HIDWORD(v602);
        v318 = v313;
        while (*v318 != v314)
        {
          if (*v318 == -2) {
            v316 = v318;
          }
          ++v318;
          v317 -= 8;
          if (!v317)
          {
            if (!v316) {
              goto LABEL_449;
            }
            uint64_t *v316 = v314;
            LODWORD(v603) = v603 - 1;
            break;
          }
        }
LABEL_473:
        v313 = (uint64_t *)v601;
        ++v283;
      }
      while (v283 != v312);
      unsigned int v275 = v557 + v310;
      v561 += v311;
      unint64_t v10 = (unint64_t)v563;
      if (v282 == v576) {
        int v330 = (int)v563;
      }
      else {
        int v330 = 0;
      }
      v576 += v330;
LABEL_486:
      if (v595[0] != v596) {
        free(v595[0]);
      }
      if (v597 != v599) {
        free(v597);
      }
LABEL_490:
      unsigned int v278 = v276 + v10;
    }
    while (v276 + v10 <= v9);
LABEL_381:
    int v279 = HIDWORD(v602);
    int v280 = (int)v603;
    unsigned int v276 = v576;
    if (v9 <= v576)
    {
      a1 = v582;
      break;
    }
    a1 = v582;
  }
  while (HIDWORD(v602) == v603);
  if (v279 == v280)
  {
    if ((void *)v601 != __dst) {
      free((void *)v601);
    }
    uint64_t v231 = v549;
    goto LABEL_781;
  }
  unsigned int v389 = (*(uint64_t (**)(void, uint64_t, uint64_t))(***(void ***)(a1 + 1936) + 968))(**(void **)(a1 + 1936), v565, -2);
  unsigned int v559 = v275;
  v390 = (llvm::Type *)v10;
  if (v389) {
    BOOL v391 = v9 / v10 > v389;
  }
  else {
    BOOL v391 = 1;
  }
  BOOL v577 = v391;
  unsigned int v392 = 0;
  int v393 = 0;
  unint64_t v394 = 0;
  do
  {
    v395 = (llvm::FixedVectorType ***)&v8[v392];
    v396 = *v395;
    v397 = __dst;
    if ((void *)v601 == __dst)
    {
      unsigned int v398 = HIDWORD(v602);
      v399 = (char *)(v601 + 8 * HIDWORD(v602));
      if (HIDWORD(v602))
      {
        uint64_t v400 = 0;
        while (*(llvm::FixedVectorType ***)(v601 + v400) != v396)
        {
          v400 += 8;
          if (8 * HIDWORD(v602) == v400) {
            goto LABEL_631;
          }
        }
        v399 = (char *)(v601 + v400);
      }
LABEL_631:
      v397 = (void *)v601;
    }
    else
    {
      int v401 = v602 - 1;
      unsigned int v402 = (v602 - 1) & ((v396 >> 4) ^ (v396 >> 9));
      v399 = (char *)(v601 + 8 * v402);
      v403 = *(llvm::FixedVectorType ***)v399;
      if (*(void *)v399 == -1)
      {
        v404 = 0;
LABEL_638:
        if (v404) {
          v399 = v404;
        }
        unsigned int v398 = HIDWORD(v602);
        if (*(llvm::FixedVectorType ***)v399 != v396) {
          v399 = (char *)(v601 + 8 * v602);
        }
      }
      else
      {
        v404 = 0;
        int v405 = 1;
        while (v403 != v396)
        {
          if (v404) {
            BOOL v406 = 0;
          }
          else {
            BOOL v406 = v403 == (llvm::FixedVectorType **)-2;
          }
          if (v406) {
            v404 = v399;
          }
          unsigned int v407 = v402 + v405++;
          unsigned int v402 = v407 & v401;
          v399 = (char *)(v601 + 8 * (v407 & v401));
          v403 = *(llvm::FixedVectorType ***)v399;
          if (*(void *)v399 == -1) {
            goto LABEL_638;
          }
        }
        unsigned int v398 = HIDWORD(v602);
      }
    }
    unsigned int v408 = v602;
    if ((void *)v601 == v397) {
      unsigned int v408 = v398;
    }
    if (v399 == (char *)(v601 + 8 * v408))
    {
      unint64_t v409 = llvm::slpvectorizer::BoUpSLP::getGatherCost(a1, v395, (llvm::Type *)v10);
      if (v410 == 1) {
        int v393 = 1;
      }
      if (__OFADD__(v394, v409)) {
        unint64_t v394 = ((uint64_t)(v394 + v409) >> 63) ^ 0x8000000000000000;
      }
      else {
        v394 += v409;
      }
    }
    v392 += v10;
  }
  while (v392 < v9);
  if ((void *)v601 == __dst) {
    v411 = (uint64_t *)((char *)&v602 + 4);
  }
  else {
    v411 = &v602;
  }
  uint64_t v412 = *(unsigned int *)v411;
  if (v412)
  {
    uint64_t v413 = 8 * v412;
    v414 = (unint64_t *)v601;
    while (*v414 >= 0xFFFFFFFFFFFFFFFELL)
    {
      ++v414;
      v413 -= 8;
      if (!v413) {
        goto LABEL_670;
      }
    }
  }
  else
  {
    v414 = (unint64_t *)v601;
  }
  v415 = (unint64_t *)(v601 + 8 * v412);
  if (v414 == v415)
  {
LABEL_670:
    unint64_t v570 = 0;
    int v416 = 0;
  }
  else
  {
    int v416 = 0;
    unint64_t v417 = 0;
    unint64_t v418 = *v414;
LABEL_659:
    uint64_t v419 = **(void **)(v418 - 32);
    unsigned int v420 = *(_DWORD *)(v419 + 8);
    if ((v420 & 0xFE) == 0x12) {
      unsigned int v420 = *(_DWORD *)(**(void **)(v419 + 16) + 8);
    }
    uint64_t v421 = (*(uint64_t (**)(void, uint64_t, void, unint64_t, void, void))(***(void ***)(v582 + 1936)
                                                                                                + 888))(**(void **)(v582 + 1936), 32, *(void *)v418, ((unint64_t)*(unsigned __int16 *)(v418 + 18) >> 1) & 0x3F, v420 >> 8, 0);
    if (v422 == 1) {
      int v416 = 1;
    }
    if (__OFADD__(v417, v421)) {
      unint64_t v417 = ((uint64_t)(v417 + v421) >> 63) ^ 0x8000000000000000;
    }
    else {
      v417 += v421;
    }
    v423 = v414 + 1;
    while (v423 != v415)
    {
      unint64_t v424 = *v423++;
      unint64_t v418 = v424;
      if (v424 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        v414 = v423 - 1;
        goto LABEL_659;
      }
    }
    unint64_t v570 = v417;
  }
  uint64_t v425 = *(void *)(v579 + 384);
  v427.n128_f64[0] = llvm::FixedVectorType::get(*(llvm::FixedVectorType **)v425, v390);
  uint64_t v428 = v426;
  uint64_t v429 = **(void **)(v425 - 32);
  unsigned int v430 = *(_DWORD *)(v429 + 8);
  if ((v430 & 0xFE) == 0x12) {
    unsigned int v430 = *(_DWORD *)(**(void **)(v429 + 16) + 8);
  }
  v595[0] = (void *)(*(uint64_t (**)(void, uint64_t, uint64_t, unint64_t, void, void, uint64_t, __n128))(***(void ***)(v582 + 1936) + 888))(**(void **)(v582 + 1936), 32, v426, ((unint64_t)*(unsigned __int16 *)(v425 + 18) >> 1) & 0x3F, v430 >> 8, 0, v425, v427);
  v595[1] = v431;
  v597 = (void *)v561;
  LODWORD(v598) = 0;
  sub_1CB90C9D4((uint64_t)&v597, (uint64_t)v595);
  int v432 = v598;
  if (__OFADD__(v394, v597)) {
    v433 = (char *)(((uint64_t)((uint64_t)v597 + v394) >> 63) ^ 0x8000000000000000);
  }
  else {
    v433 = (char *)v597 + v394;
  }
  v595[0] = (void *)(*(uint64_t (**)(void))(***(void ***)(v582 + 1936) + 912))();
  v595[1] = v434;
  v597 = (void *)v559;
  LODWORD(v598) = 0;
  sub_1CB90C9D4((uint64_t)&v597, (uint64_t)v595);
  if (v432 == 1 || v598 == 1) {
    int v436 = 1;
  }
  else {
    int v436 = v393;
  }
  if (__OFADD__(v433, v597)) {
    v437 = (char *)((((uint64_t)v597 + (uint64_t)v433) >> 63) ^ 0x8000000000000000);
  }
  else {
    v437 = (char *)v597 + (void)v433;
  }
  BOOL v438 = v577;
  if ((int)v390 >= (int)v9) {
    BOOL v438 = 0;
  }
  if (v438)
  {
    v439 = v390;
    do
    {
      uint64_t v440 = (*(uint64_t (**)(void, uint64_t, uint64_t, void, void, llvm::Type *, uint64_t))(***(void ***)(v582 + 1936) + 832))(**(void **)(v582 + 1936), 4, v565, 0, 0, v439, v428);
      if (v441 == 1) {
        int v436 = 1;
      }
      if (__OFADD__(v437, v440)) {
        v437 = (char *)(((uint64_t)&v437[v440] >> 63) ^ 0x8000000000000000);
      }
      else {
        v437 += v440;
      }
      v439 = (llvm::Type *)(v439 + v390);
    }
    while ((int)v439 < (int)v9);
  }
  unint64_t v442 = (unint64_t)&v437[v550];
  if (__OFADD__(v550, v437)) {
    unint64_t v442 = ((uint64_t)&v437[v550] >> 63) ^ 0x8000000000000000;
  }
  BOOL v443 = v436 == 1 || v416 == 1;
  uint64_t v444 = v549;
  if (v443) {
    uint64_t v444 = 1;
  }
  BOOL v270 = __OFSUB__(v442, v570);
  int64_t v445 = v442 - v570;
  if (v270) {
    int64_t v445 = (v445 >> 63) ^ 0x8000000000000000;
  }
  *(void *)&long long v592 = v445;
  *((void *)&v592 + 1) = v444;
  if ((void *)v601 != __dst) {
    free((void *)v601);
  }
LABEL_787:
  uint64_t v172 = v552;
LABEL_788:
  if (v610 != v172) {
    free(v610);
  }
  unsigned int v208 = v614;
  if (v614 != (char *)v616) {
    goto LABEL_282;
  }
  return v592;
}

uint64_t llvm::slpvectorizer::BoUpSLP::isGatherShuffledEntry(uint64_t a1, uint64_t a2, char **a3, uint64_t *a4)
{
  v171[8] = *MEMORY[0x1E4F143B8];
  unint64_t v7 = *(unsigned int *)(a2 + 8);
  int v8 = v7;
  if (*((_DWORD *)a3 + 3) < v7)
  {
    *((_DWORD *)a3 + 2) = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  unint64_t v9 = *a3;
  uint64_t v11 = a3 + 1;
  unint64_t v10 = *((unsigned int *)a3 + 2);
  if (v10 >= v7) {
    uint64_t v12 = *(unsigned int *)(a2 + 8);
  }
  else {
    uint64_t v12 = *((unsigned int *)a3 + 2);
  }
  if (v12)
  {
    __n128 v150 = *a3;
    memset(v9, 255, 4 * v12);
    unint64_t v9 = v150;
    unint64_t v10 = *v11;
  }
  BOOL v13 = v7 > v10;
  unint64_t v14 = v7 - v10;
  if (v13) {
    memset(&v9[4 * v10], 255, 4 * v14);
  }
  _DWORD *v11 = v8;
  uint64_t v148 = a4;
  *((_DWORD *)a4 + 2) = 0;
  v167[0] = 0;
  v167[1] = 0;
  unsigned int v168 = 0;
  uint64_t v15 = *(unsigned int *)(a1 + 8);
  if (v15)
  {
    uint64_t v16 = *(uint64_t **)a1;
    uint64_t v17 = *(void *)a1 + 8 * v15;
    while (1)
    {
      uint64_t v18 = *v16;
      if (*v16 == a2) {
        goto LABEL_57;
      }
      if (*(_DWORD *)(v18 + 88) == 2)
      {
        uint64_t v19 = *(unsigned int *)(v18 + 8);
        if (v19) {
          break;
        }
      }
LABEL_56:
      if (++v16 == (uint64_t *)v17) {
        goto LABEL_57;
      }
    }
    uint64_t v20 = *(uint64_t ***)v18;
    uint64_t v21 = *(void *)v18 + 8 * v19;
    while (1)
    {
      uint64_t v159 = *v20;
      sub_1CD8DE1E0((uint64_t)&v169, (uint64_t)v167, (uint64_t *)&v159);
      uint64_t v22 = v169;
      uint64_t v23 = *v16;
      uint64_t v24 = *((void *)v169 + 2);
      uint64_t v25 = *((unsigned int *)v169 + 7);
      if (v24 != *((void *)v169 + 1)) {
        break;
      }
      if (v25)
      {
        uint64_t v26 = 0;
        uint64_t v27 = 8 * v25;
        int v28 = (void *)*((void *)v169 + 2);
        while (*v28 != v23)
        {
          if (*v28 == -2) {
            uint64_t v26 = v28;
          }
          ++v28;
          v27 -= 8;
          if (!v27)
          {
            if (!v26) {
              goto LABEL_24;
            }
            *uint64_t v26 = v23;
            --*((_DWORD *)v22 + 8);
            goto LABEL_48;
          }
        }
        goto LABEL_48;
      }
LABEL_24:
      unsigned int v29 = *((_DWORD *)v169 + 6);
      if (v25 >= v29) {
        goto LABEL_27;
      }
      *((_DWORD *)v169 + 7) = v25 + 1;
      *(void *)(v24 + 8 * v25) = v23;
LABEL_48:
      if (++v20 == (uint64_t **)v21) {
        goto LABEL_56;
      }
    }
    unsigned int v29 = *((_DWORD *)v169 + 6);
LABEL_27:
    if (3 * v29 <= 4 * ((int)v25 - *((_DWORD *)v169 + 8)))
    {
      if (v29 >= 0x40) {
        v29 *= 2;
      }
      else {
        unsigned int v29 = 128;
      }
    }
    else if (v29 - v25 >= v29 >> 3)
    {
      goto LABEL_29;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)(v169 + 8), v29);
    unsigned int v29 = *((_DWORD *)v22 + 6);
    uint64_t v24 = *((void *)v22 + 2);
LABEL_29:
    unsigned int v30 = v29 - 1;
    unsigned int v31 = (v29 - 1) & ((v23 >> 4) ^ (v23 >> 9));
    int v32 = (void *)(v24 + 8 * v31);
    uint64_t v33 = *v32;
    if (*v32 == -1)
    {
      uint64_t v34 = 0;
LABEL_41:
      if (v34) {
        double v38 = v34;
      }
      else {
        double v38 = v32;
      }
      if (*v38 != v23)
      {
        if (*v38 == -2) {
          --*((_DWORD *)v22 + 8);
        }
        else {
          ++*((_DWORD *)v22 + 7);
        }
        void *v38 = v23;
      }
    }
    else
    {
      uint64_t v34 = 0;
      int v35 = 1;
      while (v33 != v23)
      {
        if (v34) {
          BOOL v36 = 0;
        }
        else {
          BOOL v36 = v33 == -2;
        }
        if (v36) {
          uint64_t v34 = v32;
        }
        unsigned int v37 = v31 + v35++;
        unsigned int v31 = v37 & v30;
        int v32 = (void *)(v24 + 8 * (v37 & v30));
        uint64_t v33 = *v32;
        if (*v32 == -1) {
          goto LABEL_41;
        }
      }
    }
    goto LABEL_48;
  }
LABEL_57:
  uint64_t v39 = (char *)v171;
  uint64_t v169 = (char *)v171;
  uint64_t v170 = 0x100000000;
  v165[0] = 0;
  v165[1] = 0;
  int v166 = 0;
  uint64_t v40 = *(unsigned int *)(a2 + 8);
  if (!v40)
  {
    uint64_t v41 = a4;
    goto LABEL_156;
  }
  int v42 = *(uint64_t **)a2;
  uint64_t v43 = *(void *)a2 + 8 * v40;
  uint64_t v44 = a1 + 80;
  do
  {
    uint64_t v45 = *v42;
    uint64_t v164 = v45;
    if (*(unsigned __int8 *)(v45 + 16) - 11 <= 1) {
      goto LABEL_61;
    }
    uint64_t v159 = (uint64_t *)v163;
    uint64_t v160 = (uint64_t *)v163;
    uint64_t v161 = 4;
    int v162 = 0;
    if (v168)
    {
      unsigned int v46 = (v168 - 1) & ((v45 >> 4) ^ (v45 >> 9));
      uint64_t v47 = (uint64_t *)(v167[0] + 72 * v46);
      uint64_t v48 = *v47;
      if (*v47 == v45)
      {
LABEL_65:
        unsigned int v49 = (const llvm::SmallPtrSetImplBase *)(v47 + 1);
        if (v47 != (uint64_t *)(v167[0] + 72 * v168) && v49 != (const llvm::SmallPtrSetImplBase *)&v159) {
          llvm::SmallPtrSetImplBase::CopyFrom((llvm::SmallPtrSetImplBase *)&v159, v49);
        }
      }
      else
      {
        int v77 = 1;
        while (v48 != -4096)
        {
          unsigned int v78 = v46 + v77++;
          unsigned int v46 = v78 & (v168 - 1);
          uint64_t v47 = (uint64_t *)(v167[0] + 72 * v46);
          uint64_t v48 = *v47;
          if (*v47 == v45) {
            goto LABEL_65;
          }
        }
      }
    }
    uint64_t v153 = 0;
    if (sub_1CD4C64C4(v44, v45, &v153))
    {
      uint64_t v51 = v153[1];
      if (v51)
      {
        uint64_t v52 = v160;
        uint64_t v53 = HIDWORD(v161);
        if (v160 == v159)
        {
          if (HIDWORD(v161))
          {
            uint64_t v54 = 0;
            uint64_t v55 = 8 * HIDWORD(v161);
            unsigned int v56 = v160;
            while (*v56 != v51)
            {
              if (*v56 == -2) {
                uint64_t v54 = v56;
              }
              ++v56;
              v55 -= 8;
              if (!v55)
              {
                if (!v54) {
                  goto LABEL_80;
                }
                uint64_t *v54 = v51;
                --v162;
                goto LABEL_104;
              }
            }
            goto LABEL_104;
          }
LABEL_80:
          unsigned int v57 = v161;
          if (HIDWORD(v161) < v161)
          {
            ++HIDWORD(v161);
            v160[v53] = v51;
            goto LABEL_104;
          }
        }
        else
        {
          unsigned int v57 = v161;
        }
        if (3 * v57 <= 4 * (HIDWORD(v161) - v162))
        {
          if (v57 >= 0x40) {
            v57 *= 2;
          }
          else {
            unsigned int v57 = 128;
          }
        }
        else if (v57 - HIDWORD(v161) >= v57 >> 3)
        {
          goto LABEL_85;
        }
        llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v159, v57);
        unsigned int v57 = v161;
        uint64_t v52 = v160;
LABEL_85:
        unsigned int v58 = v57 - 1;
        unsigned int v59 = (v57 - 1) & ((v51 >> 4) ^ (v51 >> 9));
        int v60 = &v52[v59];
        uint64_t v61 = *v60;
        if (*v60 == -1)
        {
          unsigned int v62 = 0;
LABEL_97:
          if (v62) {
            int v66 = v62;
          }
          else {
            int v66 = v60;
          }
          if (*v66 != v51)
          {
            if (*v66 == -2) {
              --v162;
            }
            else {
              ++HIDWORD(v161);
            }
            *int v66 = v51;
          }
        }
        else
        {
          unsigned int v62 = 0;
          int v63 = 1;
          while (v61 != v51)
          {
            if (v62) {
              BOOL v64 = 0;
            }
            else {
              BOOL v64 = v61 == -2;
            }
            if (v64) {
              unsigned int v62 = v60;
            }
            unsigned int v65 = v59 + v63++;
            unsigned int v59 = v65 & v58;
            int v60 = &v52[v65 & v58];
            uint64_t v61 = *v60;
            if (*v60 == -1) {
              goto LABEL_97;
            }
          }
        }
      }
    }
LABEL_104:
    unsigned int v67 = HIDWORD(v161);
    if (HIDWORD(v161) == v162) {
      goto LABEL_122;
    }
    if (v170)
    {
      uint64_t v153 = v158;
      int v68 = v160;
      if (v160 == v159)
      {
        uint64_t v154 = v158;
        uint64_t v69 = v158;
        uint64_t v70 = v160;
      }
      else
      {
        int v76 = v161;
        uint64_t v69 = malloc_type_malloc(8 * v161, 0x4065EBACuLL);
        if (!v69 && (v76 || (uint64_t v69 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0)) {
          llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
        }
        uint64_t v154 = v69;
        uint64_t v70 = v159;
        int v68 = v160;
        unsigned int v67 = HIDWORD(v161);
      }
      int v155 = v161;
      if (v68 == v70) {
        unsigned int v71 = v67;
      }
      else {
        unsigned int v71 = v161;
      }
      if (v71)
      {
        memmove(v69, v68, 8 * v71);
        unsigned int v67 = HIDWORD(v161);
      }
      unsigned int v156 = v67;
      int v157 = v162;
      if (v170)
      {
        int v72 = 0;
        uint64_t v73 = v169;
        unint64_t v74 = (unint64_t)v170 << 6;
        while (1)
        {
          sub_1CD76E044(&v159, v73);
          if (HIDWORD(v161) != v162) {
            break;
          }
          llvm::SmallPtrSetImplBase::CopyFrom((llvm::SmallPtrSetImplBase *)&v159, (const llvm::SmallPtrSetImplBase *)&v153);
          ++v72;
          v73 += 64;
          v74 -= 64;
          if (!v74)
          {
            int v152 = v72;
            goto LABEL_118;
          }
        }
        int v152 = v72;
        llvm::SmallPtrSetImplBase::swap((uint64_t *)v73, &v159);
LABEL_118:
        if (v170 != v72) {
          goto LABEL_128;
        }
        if (v72 == 2)
        {
          if (v154 != (unsigned char *)v153) {
            free(v154);
          }
LABEL_122:
          int v75 = 0;
          goto LABEL_123;
        }
      }
      sub_1CD885954((uint64_t)&v169, (llvm::SmallPtrSetImplBase *)&v153);
      int v152 = v170 - 1;
LABEL_128:
      sub_1CD40E370((uint64_t)v151, (uint64_t)v165, &v164, &v152);
      if (v154 != (unsigned char *)v153) {
        free(v154);
      }
      goto LABEL_132;
    }
    sub_1CD885954((uint64_t)&v169, (llvm::SmallPtrSetImplBase *)&v159);
LABEL_132:
    int v75 = 1;
LABEL_123:
    if (v160 != v159) {
      free(v160);
    }
    if (!v75) {
      goto LABEL_191;
    }
LABEL_61:
    ++v42;
  }
  while (v42 != (uint64_t *)v43);
  LODWORD(v40) = v170;
  uint64_t v39 = v169;
  uint64_t v41 = v148;
  if (v170 != 1)
  {
LABEL_156:
    uint64_t v159 = 0;
    uint64_t v160 = 0;
    LODWORD(v161) = 0;
    uint64_t v87 = *((void *)v39 + 1);
    uint64_t v88 = 16;
    if (v87 == *(void *)v39) {
      uint64_t v88 = 20;
    }
    uint64_t v89 = *(unsigned int *)&v39[v88];
    if (v89)
    {
      uint64_t v96 = 8 * v89;
      __int32 v90 = (unint64_t *)*((void *)v39 + 1);
      while (*v90 >= 0xFFFFFFFFFFFFFFFELL)
      {
        ++v90;
        v96 -= 8;
        if (!v96) {
          goto LABEL_172;
        }
      }
    }
    else
    {
      __int32 v90 = (unint64_t *)*((void *)v39 + 1);
    }
    int v91 = (unint64_t *)(v87 + 8 * v89);
    if (v90 != v91)
    {
LABEL_161:
      v151[0] = 0;
      unint64_t v92 = *v90;
      v151[0] = v92;
      int v93 = *(_DWORD *)(v92 + 104);
      if (!v93) {
        int v93 = *(_DWORD *)(v92 + 8);
      }
      LODWORD(v164) = v93;
      sub_1CD8DE28C((uint64_t)&v153, (uint64_t)&v159, &v164, v151);
      uint8x8_t v94 = v90 + 1;
      while (v94 != v91)
      {
        unint64_t v95 = *v94++;
        if (v95 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          __int32 v90 = v94 - 1;
          goto LABEL_161;
        }
      }
      uint64_t v39 = v169;
      LODWORD(v40) = v170;
    }
LABEL_172:
    uint64_t v97 = &v39[64 * (unint64_t)v40];
    uint64_t v98 = (unint64_t *)*((void *)v97 - 7);
    uint64_t v99 = -48;
    if (v98 == *((unint64_t **)v97 - 8)) {
      uint64_t v99 = -44;
    }
    uint64_t v100 = *(unsigned int *)&v97[v99];
    if (v100)
    {
      uint64_t v111 = 8 * v100;
      unint64_t v101 = v98;
      while (*v101 >= 0xFFFFFFFFFFFFFFFELL)
      {
        ++v101;
        v111 -= 8;
        if (!v111)
        {
          uint64_t v103 = v159;
          goto LABEL_189;
        }
      }
    }
    else
    {
      unint64_t v101 = v98;
    }
    uint64_t v102 = &v98[v100];
    uint64_t v103 = v159;
    if (v101 != v102)
    {
      unsigned int v104 = v161;
      __int32 v105 = &v159[2 * v161];
      unint64_t v106 = *v101;
LABEL_178:
      int v107 = *(_DWORD *)(v106 + 104);
      if (!v107) {
        int v107 = *(_DWORD *)(v106 + 8);
      }
      int8x8_t v108 = sub_1CD4D7294((uint64_t)v103, v104, v107);
      if (v105 != (uint64_t *)v108)
      {
        int v112 = *v108;
        unsigned int v144 = *((_DWORD *)v41 + 2);
        if (v144 >= *((_DWORD *)v41 + 3)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*v41 + 8 * v144) = *((void *)v108 + 1);
        unsigned int v145 = *((_DWORD *)v41 + 3);
        unsigned int v146 = *((_DWORD *)v41 + 2) + 1;
        *((_DWORD *)v41 + 2) = v146;
        if (v146 >= v145) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*v41 + 8 * v146) = v106;
        int v113 = *((_DWORD *)v41 + 2) + 1;
        *((_DWORD *)v41 + 2) = v113;
        goto LABEL_190;
      }
      uint8x8_t v109 = v101 + 1;
      while (v109 != v102)
      {
        unint64_t v110 = *v109++;
        unint64_t v106 = v110;
        if (v110 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          unint64_t v101 = v109 - 1;
          goto LABEL_178;
        }
      }
    }
LABEL_189:
    int v112 = 0;
    int v113 = *((_DWORD *)v41 + 2);
LABEL_190:
    MEMORY[0x1D25D9CD0](v103, 8);
    if (v113) {
      goto LABEL_218;
    }
LABEL_191:
    uint64_t v114 = 0;
    uint64_t v115 = 0;
    goto LABEL_241;
  }
  int v80 = *(uint64_t **)v169;
  int v79 = (uint64_t *)*((void *)v169 + 1);
  uint64_t v81 = v169 + 20;
  if (v79 != *(uint64_t **)v169) {
    uint64_t v81 = v169 + 16;
  }
  uint64_t v82 = *(unsigned int *)v81;
  uint64_t v83 = &v79[v82];
  unint64_t v84 = (uint64_t *)*((void *)v169 + 1);
  if (v82)
  {
    unint64_t v85 = 0;
    uint64_t v86 = 8 * v82;
    while ((unint64_t)v79[v85 / 8] >= 0xFFFFFFFFFFFFFFFELL)
    {
      v85 += 8;
      if (v86 == v85) {
        goto LABEL_201;
      }
    }
    unint64_t v84 = &v79[v85 / 8];
  }
  if (v84 != v83)
  {
    if (!sub_1CD8DD67C(*v84, *(uint64_t **)a2, *(unsigned int *)(a2 + 8)))
    {
      while (++v84 != v83)
      {
        if ((unint64_t)*v84 < 0xFFFFFFFFFFFFFFFELL
          && sub_1CD8DD67C(*v84, *(uint64_t **)a2, *(unsigned int *)(a2 + 8)))
        {
          goto LABEL_200;
        }
      }
      unint64_t v84 = v83;
    }
LABEL_200:
    uint64_t v39 = v169;
    int v80 = *(uint64_t **)v169;
    int v79 = (uint64_t *)*((void *)v169 + 1);
    uint64_t v83 = v84;
  }
LABEL_201:
  BOOL v36 = v79 == v80;
  uint64_t v116 = 16;
  if (v36) {
    uint64_t v116 = 20;
  }
  uint64_t v117 = *(unsigned int *)&v39[v116];
  int v118 = &v79[v117];
  if (v83 == v118)
  {
    if (v117)
    {
      while ((unint64_t)*v79 >= 0xFFFFFFFFFFFFFFFELL)
      {
        if (++v79 == v83)
        {
          int v79 = v83;
          break;
        }
      }
    }
    unsigned int v119 = *((_DWORD *)v148 + 2);
    if (v119 >= *((_DWORD *)v148 + 3)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v114 = 0;
    uint64_t v115 = 0;
    *(void *)(*v148 + 8 * v119) = *v79;
    ++*((_DWORD *)v148 + 2);
LABEL_216:
    if (v83 == v118)
    {
      int v112 = 0;
LABEL_218:
      uint64_t v125 = *(unsigned int *)(a2 + 8);
      if ((int)v125 < 1)
      {
LABEL_233:
        int v139 = *((_DWORD *)v148 + 2);
        uint64_t v140 = 0x100000000;
        uint64_t v141 = 6;
        if (v139 != 2)
        {
          uint64_t v140 = 0;
          uint64_t v141 = 0;
        }
        if (v139 == 1) {
          uint64_t v114 = 0x100000000;
        }
        else {
          uint64_t v114 = v140;
        }
        if (v139 == 1) {
          uint64_t v115 = 7;
        }
        else {
          uint64_t v115 = v141;
        }
        goto LABEL_241;
      }
      uint64_t v126 = 0;
      uint64_t v127 = *(uint64_t **)a2;
      uint64_t v128 = v165[0];
      int v129 = v166;
      unsigned int v149 = v166 - 1;
      uint64_t v130 = *v148;
      uint64_t v131 = *a3;
      while (2)
      {
        uint64_t v132 = v127[v126];
        if (*(unsigned __int8 *)(v132 + 16) - 11 < 2)
        {
LABEL_221:
          if (++v126 == v125) {
            goto LABEL_233;
          }
          continue;
        }
        break;
      }
      if (v129)
      {
        uint64_t v134 = v149 & ((v132 >> 4) ^ (v132 >> 9));
        uint64_t v135 = *(void *)(v128 + 16 * v134);
        if (v132 != v135)
        {
          int v137 = 1;
          while (v135 != -4096)
          {
            int v138 = v134 + v137++;
            uint64_t v134 = v138 & v149;
            uint64_t v135 = *(void *)(v128 + 16 * v134);
            if (v132 == v135) {
              goto LABEL_226;
            }
          }
          goto LABEL_224;
        }
LABEL_226:
        unsigned int v133 = *(_DWORD *)(v128 + 16 * v134 + 8);
      }
      else
      {
LABEL_224:
        unsigned int v133 = 0;
      }
      int v136 = sub_1CD8DD454(*(void *)(v130 + 8 * v133), v132) + v133 * v112;
      *(_DWORD *)&v131[4 * v126] = v136;
      if (v136 >= 2 * (int)v125) {
        goto LABEL_191;
      }
      goto LABEL_221;
    }
  }
  else
  {
    unsigned int v120 = *((_DWORD *)v148 + 2);
    if (v120 >= *((_DWORD *)v148 + 3)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*v148 + 8 * v120) = *v83;
    ++*((_DWORD *)v148 + 2);
    uint64_t v121 = *((unsigned int *)a3 + 2);
    if (v121)
    {
      uint64_t v122 = 0;
      uint64_t v123 = *a3;
      uint64_t v124 = 4 * v121;
      uint64_t v115 = 7;
      do
      {
        *(_DWORD *)&v123[4 * v122] = v122;
        ++v122;
        v124 -= 4;
      }
      while (v124);
      uint64_t v114 = 0x100000000;
      goto LABEL_216;
    }
    uint64_t v114 = 0x100000000;
    uint64_t v115 = 7;
  }
LABEL_241:
  MEMORY[0x1D25D9CD0](v165[0], 8);
  sub_1CD541FBC(&v169);
  uint64_t v142 = v167[0];
  sub_1CD5A0268(v167[0], v168);
  MEMORY[0x1D25D9CD0](v142, 8);
  return v114 & 0x100000000 | v115;
}

uint64_t sub_1CD32FEE4(uint64_t a1, unint64_t a2, char **a3)
{
  if (!a2)
  {
    uint64_t v6 = 0;
    uint64_t v8 = 0;
    return v8 | v6;
  }
  uint64_t v6 = 8 * a2;
  uint64_t v7 = a1;
  while (*(unsigned char *)(*(void *)v7 + 16) != 89)
  {
    v7 += 8;
    v6 -= 8;
    if (!v6) {
      goto LABEL_9;
    }
  }
  uint64_t v9 = **(void **)(*(void *)v7 - 64);
  if (*(unsigned char *)(v9 + 8) != 19)
  {
    unint64_t v11 = *(unsigned int *)(v9 + 32);
    if (a2 > *((unsigned int *)a3 + 3))
    {
      *((_DWORD *)a3 + 2) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v12 = *a3;
    unint64_t v14 = a3 + 1;
    unint64_t v13 = *((unsigned int *)a3 + 2);
    if (v13 >= a2) {
      unint64_t v15 = a2;
    }
    else {
      unint64_t v15 = *((unsigned int *)a3 + 2);
    }
    if (v15)
    {
      uint64_t v33 = *a3;
      memset(v12, 255, 4 * v15);
      uint64_t v12 = v33;
      unint64_t v13 = *v14;
    }
    if (a2 > v13) {
      memset(&v12[4 * v13], 255, 4 * (a2 - v13));
    }
    *unint64_t v14 = a2;
    if (!a2) {
      goto LABEL_53;
    }
    uint64_t v16 = 0;
    int v17 = 0;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t v20 = a2;
    while (1)
    {
      uint64_t v21 = *(void *)(a1 + 8 * v16);
      if (*(unsigned __int8 *)(v21 + 16) - 11 >= 2)
      {
        uint64_t v22 = *(void *)(v21 - 64);
        if (*(unsigned char *)(*(void *)v22 + 8) == 19) {
          break;
        }
        if ((sub_1CD330918(*(unsigned __int8 **)(v21 - 64)) & 1) == 0)
        {
          if (*(_DWORD *)(*(void *)v22 + 32) != v11) {
            break;
          }
          uint64_t v23 = *(void *)(v21 - 32);
          int v24 = *(unsigned __int8 *)(v23 + 16);
          if ((v24 - 11) >= 2)
          {
            if (v24 != 16) {
              break;
            }
            uint64_t v25 = *(unsigned int *)(v23 + 32);
            if (v25 < 0x41)
            {
              unint64_t v26 = *(void *)(v23 + 24);
              goto LABEL_36;
            }
            int v27 = 0;
            int64_t v28 = (unint64_t)(v25 + 63) >> 6;
            do
            {
              if (v28-- < 1) {
                break;
              }
              unint64_t v30 = *(void *)(*(void *)(v23 + 24) + 8 * v28);
              v27 += __clz(v30);
            }
            while (!v30);
            int v31 = v25 | 0xFFFFFFC0;
            if ((v25 & 0x3F) == 0) {
              int v31 = 0;
            }
            if ((v25 - v27 - v31) < 0x41)
            {
              unint64_t v26 = **(void **)(v23 + 24);
LABEL_36:
              if (v26 < v11)
              {
                int v32 = *a3;
                *(_DWORD *)&(*a3)[4 * v16] = v26;
                if (!v19 || v19 == v22)
                {
                  uint64_t v19 = v22;
                  uint64_t v22 = v18;
                }
                else
                {
                  if (v18 && v18 != v22) {
                    break;
                  }
                  *(_DWORD *)&v32[4 * v16] = v11 + v26;
                }
                if (v17 != 2)
                {
                  if (v16 == v26) {
                    int v17 = 1;
                  }
                  else {
                    int v17 = 2;
                  }
                }
                uint64_t v18 = v22;
              }
            }
          }
        }
      }
      if (++v16 == v20)
      {
        uint64_t v8 = 2;
        if (v17 != 1) {
          uint64_t v8 = 6;
        }
        if (v18)
        {
          uint64_t v6 = 0x100000000;
          return v8 | v6;
        }
LABEL_53:
        uint64_t v6 = 0x100000000;
        uint64_t v8 = 7;
        return v8 | v6;
      }
    }
  }
  uint64_t v6 = 0;
LABEL_9:
  uint64_t v8 = 0;
  return v8 | v6;
}

uint64_t sub_1CD33017C(uint64_t a1, int64_t *a2)
{
  uint64_t v4 = *(void *)a1;
  unsigned int v67 = 0;
  uint64_t v68 = 0;
  unsigned int v69 = 0;
  unsigned int v62 = v66;
  int v63 = v66;
  uint64_t v64 = 4;
  int v65 = 0;
  uint64_t v5 = *(void *)(a1 + 32);
  if (!v5)
  {
    uint64_t v43 = 0;
    goto LABEL_80;
  }
  uint64_t v6 = *(uint64_t **)(a1 + 24);
  uint64_t v7 = &v6[v5];
  do
  {
    uint64_t v8 = *v6;
    if (*(unsigned __int8 *)(*v6 + 16) - 11 < 2) {
      goto LABEL_4;
    }
    v60[0] = 0;
    uint64_t v9 = 0;
    if (sub_1CD4C64C4(v4 + 80, v8, v60)) {
      uint64_t v9 = *(void *)(v60[0] + 8);
    }
    unint64_t v10 = v63;
    uint64_t v11 = HIDWORD(v64);
    if (v63 == v62)
    {
      if (HIDWORD(v64))
      {
        uint64_t v12 = 0;
        uint64_t v13 = 8 * HIDWORD(v64);
        unint64_t v14 = (uint64_t *)v63;
        while (*v14 != v8)
        {
          if (*v14 == -2) {
            uint64_t v12 = v14;
          }
          ++v14;
          v13 -= 8;
          if (!v13)
          {
            if (!v12) {
              goto LABEL_16;
            }
            uint64_t *v12 = v8;
            --v65;
            goto LABEL_40;
          }
        }
        goto LABEL_4;
      }
LABEL_16:
      unsigned int v15 = v64;
      if (HIDWORD(v64) < v64)
      {
        ++HIDWORD(v64);
        *(void *)&v63[8 * v11] = v8;
        goto LABEL_40;
      }
    }
    else
    {
      unsigned int v15 = v64;
    }
    if (3 * v15 <= 4 * (HIDWORD(v64) - v65))
    {
      if (v15 >= 0x40) {
        v15 *= 2;
      }
      else {
        unsigned int v15 = 128;
      }
    }
    else if (v15 - HIDWORD(v64) >= v15 >> 3)
    {
      goto LABEL_21;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v62, v15);
    unsigned int v15 = v64;
    unint64_t v10 = v63;
LABEL_21:
    unsigned int v16 = v15 - 1;
    unsigned int v17 = (v15 - 1) & ((v8 >> 4) ^ (v8 >> 9));
    uint64_t v18 = &v10[8 * v17];
    uint64_t v19 = *(void *)v18;
    if (*(void *)v18 == -1)
    {
      uint64_t v20 = 0;
LABEL_33:
      if (v20) {
        int v24 = v20;
      }
      else {
        int v24 = (uint64_t *)v18;
      }
      if (*v24 != v8)
      {
        if (*v24 == -2) {
          --v65;
        }
        else {
          ++HIDWORD(v64);
        }
        uint64_t *v24 = v8;
LABEL_40:
        if (!llvm::slpvectorizer::BoUpSLP::areAllUsersVectorized(v4, v8, *(void **)(a1 + 48), *(void *)(a1 + 56))|| v9 && v9 != *(void *)(a1 + 64))
        {
          goto LABEL_4;
        }
        unint64_t v25 = sub_1CD32B9E0(v8);
        if (!HIDWORD(v25)) {
          goto LABEL_4;
        }
        unint64_t v26 = v25;
        int v61 = v25;
        int v27 = (*(uint64_t (**)(void, void))(***(void ***)(a1 + 8) + 968))(**(void **)(a1 + 8), *(void *)(a1 + 40));
        if (v27 != (*(unsigned int (**)(void))(***(void ***)(a1 + 8) + 968))())
        {
          uint64_t v59 = *(void *)(v8 - 64);
          sub_1CD40E370((uint64_t)v60, (uint64_t)&v67, &v59, &v61);
          int v42 = *(_DWORD *)(v60[0] + 8);
          if ((int)v26 < v42) {
            int v42 = v26;
          }
          *(_DWORD *)(v60[0] + 8) = v42;
        }
        uint64_t v28 = *(void *)(v8 + 8);
        if (!v28
          || *(void *)(v28 + 8)
          || (uint64_t v29 = *(void *)(v28 + 24), v30 = *(unsigned __int8 *)(v29 + 16), (v30 - 67) > 1))
        {
LABEL_58:
          uint64_t v40 = (*(uint64_t (**)(void, uint64_t, void, unint64_t))(***(void ***)(a1 + 8) + 872))(**(void **)(a1 + 8), 61, **(void **)(v8 - 64), v26);
          if (v41 == 1) {
            *((_DWORD *)a2 + 2) = 1;
          }
          BOOL v38 = __OFSUB__(*a2, v40);
          int64_t v39 = *a2 - v40;
        }
        else
        {
          uint64_t v31 = *(void *)(v29 + 8);
          if (v31)
          {
            while (*(unsigned char *)(*(void *)(v31 + 24) + 16) == 62)
            {
              uint64_t v31 = *(void *)(v31 + 8);
              if (!v31) {
                goto LABEL_51;
              }
            }
            goto LABEL_58;
          }
LABEL_51:
          uint64_t v32 = (*(uint64_t (**)(void, void, void, void, unint64_t))(***(void ***)(a1 + 8)
                                                                                            + 848))(**(void **)(a1 + 8), (v30 - 28), *(void *)v29, **(void **)(v8 - 64), v26);
          if (v33 == 1) {
            *((_DWORD *)a2 + 2) = 1;
          }
          int64_t v34 = *a2 - v32;
          if (__OFSUB__(*a2, v32)) {
            int64_t v34 = (v34 >> 63) ^ 0x8000000000000000;
          }
          *a2 = v34;
          uint64_t v35 = *(void *)(a1 + 8);
          llvm::TargetTransformInfo::getCastContextHint(v29);
          uint64_t v36 = (*(uint64_t (**)(void))(**(void **)v35 + 840))();
          if (v37 == 1) {
            *((_DWORD *)a2 + 2) = 1;
          }
          BOOL v38 = __OFADD__(*a2, v36);
          int64_t v39 = *a2 + v36;
        }
        if (v38) {
          int64_t v39 = (v39 >> 63) ^ 0x8000000000000000;
        }
        *a2 = v39;
      }
    }
    else
    {
      uint64_t v20 = 0;
      int v21 = 1;
      while (v19 != v8)
      {
        if (v20) {
          BOOL v22 = 0;
        }
        else {
          BOOL v22 = v19 == -2;
        }
        if (v22) {
          uint64_t v20 = (uint64_t *)v18;
        }
        unsigned int v23 = v17 + v21++;
        unsigned int v17 = v23 & v16;
        uint64_t v18 = &v10[8 * (v23 & v16)];
        uint64_t v19 = *(void *)v18;
        if (*(void *)v18 == -1) {
          goto LABEL_33;
        }
      }
    }
LABEL_4:
    ++v6;
  }
  while (v6 != v7);
  uint64_t v43 = v67;
  LODWORD(v5) = v69;
  if (!v68)
  {
LABEL_80:
    unsigned int v46 = &v43[2 * v5];
    uint64_t v44 = v46;
    goto LABEL_81;
  }
  uint64_t v44 = &v67[2 * v69];
  if (v69)
  {
    uint64_t v45 = 0;
    while (((unint64_t)v67[v45] | 0x1000) == 0xFFFFFFFFFFFFF000)
    {
      v45 += 2;
      if (2 * v69 == v45)
      {
        unsigned int v46 = &v67[2 * v69];
        goto LABEL_81;
      }
    }
    unsigned int v46 = &v67[v45];
  }
  else
  {
    unsigned int v46 = v67;
  }
LABEL_81:
  uint64_t v47 = &v43[2 * v5];
  while (v46 != v47)
  {
    unsigned int v48 = *(_DWORD *)(*(void *)(a1 + 40) + 32);
    if (*((_DWORD *)v46 + 2) % v48)
    {
      uint64_t v49 = **v46;
      unsigned int v50 = (*(uint64_t (**)(void, uint64_t))(***(void ***)(a1 + 8) + 968))(**(void **)(a1 + 8), v49);
      if (v50 <= (*(unsigned int (**)(void))(***(void ***)(a1 + 8) + 968))())
      {
        uint64_t v54 = (*(uint64_t (**)(void, uint64_t))(***(void ***)(a1 + 8) + 832))(**(void **)(a1 + 8), 4);
      }
      else
      {
        int v51 = *((_DWORD *)v46 + 2) / v48 * v48;
        unsigned int v52 = *(_DWORD *)(v49 + 32);
        if (v51 + v48 <= v52)
        {
          uint64_t v54 = (*(uint64_t (**)(void, uint64_t))(***(void ***)(a1 + 8) + 832))(**(void **)(a1 + 8), 5);
        }
        else
        {
          v53.n128_f64[0] = llvm::FixedVectorType::get(*(llvm::FixedVectorType **)(*(void *)(a1 + 40) + 24), (llvm::Type *)(v52 - v51));
          uint64_t v54 = (*(uint64_t (**)(__n128))(***(void ***)(a1 + 8) + 832))(v53);
        }
      }
      if (v55 == 1) {
        *((_DWORD *)a2 + 2) = 1;
      }
      int64_t v56 = *a2 + v54;
      if (__OFADD__(*a2, v54)) {
        int64_t v56 = (v56 >> 63) ^ 0x8000000000000000;
      }
      *a2 = v56;
    }
    unsigned int v57 = v46 + 2;
    unsigned int v46 = v44;
    if (v57 != v44)
    {
      unsigned int v46 = v57;
      while (((unint64_t)*v46 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v46 += 2;
        if (v46 == v44)
        {
          unsigned int v46 = v44;
          break;
        }
      }
    }
  }
  if (v63 != v62) {
    free(v63);
  }
  return MEMORY[0x1D25D9CD0](v43, 8);
}

uint64_t sub_1CD330918(unsigned __int8 *a1)
{
  unsigned int v1 = a1[16];
  if (v1 - 11 < 2) {
    return 1;
  }
  if (v1 > 0x14) {
    return 0;
  }
  uint64_t result = llvm::Constant::containsUndefOrPoisonElement((llvm::Constant *)a1);
  if (result)
  {
    uint64_t result = 0;
    uint64_t v4 = *(void *)a1;
    if (*(void *)a1)
    {
      if (*(unsigned char *)(v4 + 8) == 18)
      {
        int v5 = *(_DWORD *)(v4 + 32);
        if (!v5) {
          return 1;
        }
        uint64_t v6 = 0;
        while (1)
        {
          AggregateElement = llvm::Constant::getAggregateElement((llvm::Constant *)a1, v6);
          if (AggregateElement)
          {
            if (*((unsigned __int8 *)AggregateElement + 16) - 11 > 1) {
              break;
            }
          }
          uint64_t v6 = (llvm::Type *)(v6 + 1);
          uint64_t result = 1;
          if (v5 == v6) {
            return result;
          }
        }
        return 0;
      }
    }
  }
  return result;
}

void sub_1CD3309C4(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t *a5)
{
  v59[4] = *MEMORY[0x1E4F143B8];
  int v9 = llvm::getVectorIntrinsicIDForCall(a2, a5);
  unsigned int v57 = (char *)v59;
  uint64_t v58 = 0x400000000;
  int v10 = *(_DWORD *)(a2 + 20);
  uint64_t v11 = v10 & 0x7FFFFFF;
  uint64_t v12 = (llvm::FixedVectorType ***)(a2 - 32 * v11);
  int v13 = *(unsigned __int8 *)(a2 + 16);
  if (v13 == 84)
  {
    uint64_t v14 = 0;
  }
  else if (v13 == 39)
  {
    uint64_t v14 = (*(_DWORD *)(a2 + 80) + 1);
  }
  else
  {
    uint64_t v14 = 2;
  }
  if (v10 < 0 && (uint64_t v38 = (uint64_t)*(v12 - 1), (v38 & 0xFFFFFFFF0) != 0)) {
    uint64_t v15 = (*((_DWORD *)v12 - 3) - *(_DWORD *)((char *)v12 - v38));
  }
  else {
    uint64_t v15 = 0;
  }
  if (v12 != (llvm::FixedVectorType ***)(a2 - 32 * v14 - 32 * v15 - 32))
  {
    uint64_t v17 = 32 * v11 - 32 * v14 - 32 * v15 - 32;
    do
    {
      llvm::FixedVectorType::get(**v12, (llvm::Type *)*(unsigned int *)(a3 + 32));
      if (v58 >= (unint64_t)HIDWORD(v58)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)&v57[8 * v58] = v18;
      LODWORD(v58) = v58 + 1;
      v12 += 4;
      v17 -= 32;
    }
    while (v17);
  }
  if (sub_1CB845E74(a2))
  {
    if ((unint64_t)*(unsigned __int8 *)(a2 + 17) >> 1 == 127) {
      LODWORD(v16) = -1;
    }
    else {
      unint64_t v16 = (unint64_t)*(unsigned __int8 *)(a2 + 17) >> 1;
    }
  }
  else
  {
    LODWORD(v16) = 0;
  }
  int v19 = *(_DWORD *)(a2 + 20);
  uint64_t v20 = (char *)(a2 - 32 * (v19 & 0x7FFFFFF));
  int v21 = *(unsigned __int8 *)(a2 + 16);
  if (v21 == 84)
  {
    uint64_t v22 = 0;
  }
  else if (v21 == 39)
  {
    uint64_t v22 = (*(_DWORD *)(a2 + 80) + 1);
  }
  else
  {
    uint64_t v22 = 2;
  }
  if (v19 < 0 && (uint64_t v39 = *((void *)v20 - 1), (v39 & 0xFFFFFFFF0) != 0)) {
    uint64_t v23 = (*((_DWORD *)v20 - 3) - *(_DWORD *)&v20[-v39]);
  }
  else {
    uint64_t v23 = 0;
  }
  uint64_t v54 = (uint64_t *)v56;
  uint64_t v55 = 0x600000000;
  sub_1CD77B118((uint64_t)&v54, v20, (char *)(a2 - 32 * v22 - 32 * v23 - 32));
  uint64_t v24 = *(void *)(a2 - 32);
  if (v24)
  {
    if (*(unsigned char *)(v24 + 16) || *(void *)(v24 + 24) != *(void *)(a2 + 72))
    {
      uint64_t v24 = 0;
    }
    else if ((*(unsigned char *)(v24 + 33) & 0x20) != 0)
    {
      uint64_t v24 = a2;
    }
    else
    {
      uint64_t v24 = 0;
    }
  }
  llvm::IntrinsicCostAttributes::IntrinsicCostAttributes((uint64_t)v49, v9, a3, v54, v55, v57, v58, v16, v24, 0, 1);
  uint64_t v25 = (*(uint64_t (**)(void))(*(void *)*a4 + 952))();
  uint64_t v27 = v26;
  sub_1CD8CB164(a2, *(unsigned int *)(a3 + 32), 0, &v46);
  v42[0] = *(void *)(*(void *)(*(void *)(a2 + 40) + 56) + 40);
  v42[1] = a2;
  uint64_t v43 = v45;
  uint64_t v44 = 0x800000000;
  sub_1CC076744((void **)a2, (uint64_t)&v43);
  uint64_t v28 = sub_1CD8CB328((uint64_t)v42, (uint64_t)&v46);
  uint64_t v29 = v43;
  if (v44)
  {
    uint64_t v40 = v28;
    uint64_t v41 = v27;
    uint64_t v30 = a1;
    uint64_t v31 = a4;
    uint64_t v32 = 208 * v44;
    int v33 = (char *)v43 - 208;
    do
    {
      sub_1CD49DEA4((uint64_t)&v33[v32]);
      v32 -= 208;
    }
    while (v32);
    uint64_t v29 = v43;
    a4 = v31;
    a1 = v30;
    uint64_t v28 = v40;
    uint64_t v27 = v41;
  }
  if (v29 != v45) {
    free(v29);
  }
  uint64_t v34 = *(void *)(a2 + 64);
  if (v34 && (*(unsigned char *)(v34 + 14) & 0x10) != 0) {
    goto LABEL_37;
  }
  if (!llvm::CallBase::hasFnAttrOnCalledFunction(a2, 20)) {
    goto LABEL_39;
  }
  uint64_t v34 = *(void *)(a2 + 64);
  if (v34)
  {
LABEL_37:
    if ((*(unsigned char *)(v34 + 12) & 0x10) == 0) {
      goto LABEL_38;
    }
LABEL_39:
    char v35 = 0;
    goto LABEL_40;
  }
LABEL_38:
  char v35 = llvm::CallBase::hasFnAttrOnCalledFunction(a2, 4) ^ 1;
LABEL_40:
  uint64_t v36 = v25;
  int v37 = v27;
  if ((v35 & 1) == 0)
  {
    uint64_t v36 = v25;
    int v37 = v27;
    if (v28) {
      uint64_t v36 = (*(uint64_t (**)(void, void, uint64_t, char *, void, void))(*(void *)*a4 + 960))(*a4, 0, a3, v57, v58, 0);
    }
  }
  *(void *)a1 = v25;
  *(void *)(a1 + 8) = v27;
  *(void *)(a1 + 16) = v36;
  *(_DWORD *)(a1 + 24) = v37;
  *(_DWORD *)(a1 + 28) = HIDWORD(v27);
  if (v47 != &v48) {
    free(v47);
  }
  if (v52 != &v53) {
    free(v52);
  }
  if (v50 != &v51) {
    free(v50);
  }
  if (v54 != (uint64_t *)v56) {
    free(v54);
  }
  if (v57 != (char *)v59) {
    free(v57);
  }
}

void sub_1CD330E8C(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, int *a5, unint64_t a6, unsigned int (*a7)(uint64_t, uint64_t), uint64_t a8, _DWORD *a9, uint64_t a10, uint64_t a11)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  unint64_t v16 = a2;
  if (a2 > (unint64_t)a9[3])
  {
    a9[2] = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  uint64_t v17 = *(char **)a9;
  int v19 = a9 + 2;
  unint64_t v18 = a9[2];
  if (v18 >= a2) {
    uint64_t v20 = a2;
  }
  else {
    uint64_t v20 = a9[2];
  }
  if (v20)
  {
    memset(v17, 255, 4 * v20);
    unint64_t v18 = *v19;
  }
  if (v16 > v18) {
    memset(&v17[4 * v18], 255, 4 * (v16 - v18));
  }
  *int v19 = a2;
  uint64_t v38 = v40;
  uint64_t v39 = 0xC00000000;
  if (a4 && a4)
  {
    if (a4 >= 0xDuLL) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    memset(v40, 255, 4 * a4);
    LODWORD(v39) = v39 + a4;
    if (a4)
    {
      uint64_t v21 = 0;
      do
      {
        v40[*(unsigned int *)(a3 + 4 * v21)] = v21;
        ++v21;
      }
      while (a4 != v21);
    }
  }
  if (a2)
  {
    for (uint64_t i = 0; v16 != i; ++i)
    {
      if (a4) {
        unsigned int v23 = *((_DWORD *)v38 + i);
      }
      else {
        unsigned int v23 = i;
      }
      uint64_t v24 = *(void *)(a1 + 8 * v23);
      if (a7(a8, v24))
      {
        *(_DWORD *)(*(void *)a9 + 4 * i) = v23 + a2;
        if (a11)
        {
          unint64_t v25 = *(unsigned int *)(a11 + 8);
          if (v25 >= *(unsigned int *)(a11 + 12)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          uint64_t v26 = a11;
LABEL_29:
          *(void *)(*(void *)v26 + 8 * v25) = v24;
          ++*(_DWORD *)(v26 + 8);
        }
      }
      else
      {
        *(_DWORD *)(*(void *)a9 + 4 * i) = v23;
        if (a10)
        {
          unint64_t v25 = *(unsigned int *)(a10 + 8);
          if (v25 >= *(unsigned int *)(a10 + 12)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          uint64_t v26 = a10;
          goto LABEL_29;
        }
      }
    }
  }
  if (a6)
  {
    __b = v37;
    int v36 = 12;
    uint64_t v27 = 4 * a6;
    if (a6 > 0xC)
    {
      int v35 = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    memset(v37, 255, 4 * a6);
    uint64_t v28 = v37;
    int v35 = a6;
    uint64_t v29 = *(void *)a9;
    do
    {
      uint64_t v30 = *a5;
      if (v30 != -1) {
        LODWORD(v30) = *(_DWORD *)(v29 + 4 * v30);
      }
      *v28++ = v30;
      ++a5;
      v27 -= 4;
    }
    while (v27);
    sub_1CD8DCFDC(a9, &__b);
    if (__b != v37) {
      free(__b);
    }
  }
  if (v38 != v40) {
    free(v38);
  }
}

BOOL llvm::slpvectorizer::BoUpSLP::isFullyVectorizableTinyTree(uint64_t **this, int a2)
{
  int v3 = *((_DWORD *)this + 2);
  if (v3 == 1)
  {
    uint64_t v4 = **this;
    if (!*(_DWORD *)(v4 + 88)) {
      return 1;
    }
    if (a2 && sub_1CD331344((uint64_t)this, **this, *(_DWORD *)(v4 + 8)))
    {
      uint64_t v5 = **this;
      unsigned int v6 = *(_DWORD *)(v5 + 104);
      if (!v6) {
        unsigned int v6 = *(_DWORD *)(v5 + 8);
      }
      if (v6 > 2) {
        return 1;
      }
    }
    int v3 = *((_DWORD *)this + 2);
  }
  if (v3 != 2) {
    return 0;
  }
  uint64_t v8 = *this;
  uint64_t v9 = **this;
  int v10 = *(_DWORD *)(v9 + 88);
  if (!v10)
  {
    if (sub_1CD331344((uint64_t)this, v8[1], *(_DWORD *)(v9 + 8))) {
      return 1;
    }
    uint64_t v8 = *this;
    int v10 = *(_DWORD *)(**this + 88);
  }
  if (v10 == 2) {
    return 0;
  }
  int v11 = *(_DWORD *)(v8[1] + 88);
  return v10 == 1 || v11 != 2;
}

BOOL sub_1CD331344(uint64_t a1, uint64_t a2, unsigned int a3)
{
  v38[6] = *MEMORY[0x1E4F143B8];
  v37[0] = v38;
  v37[1] = (void *)0xC00000000;
  if (*(_DWORD *)(a2 + 88) == 2)
  {
    unint64_t v4 = *(unsigned int *)(a2 + 8);
    if (!v4)
    {
LABEL_43:
      BOOL v28 = 1;
      goto LABEL_67;
    }
    uint64_t v5 = *(void *)(a1 + 1480);
    uint64_t v6 = *(void *)(a1 + 1472);
    if (v5 == v6) {
      uint64_t v7 = (unsigned int *)(a1 + 1492);
    }
    else {
      uint64_t v7 = (unsigned int *)(a1 + 1488);
    }
    uint64_t v8 = *(void *)(a1 + 1480);
    uint64_t v9 = *(uint64_t **)a2;
    while (1)
    {
      uint64_t v10 = *v9;
      if (v8 == v6)
      {
        uint64_t v11 = *(unsigned int *)(a1 + 1492);
        uint64_t v12 = (void *)(v6 + 8 * v11);
        if (v11)
        {
          uint64_t v13 = 0;
          uint64_t v14 = 8 * v11;
          while (*(void *)(v6 + v13) != v10)
          {
            v13 += 8;
            if (v14 == v13) {
              goto LABEL_25;
            }
          }
          uint64_t v12 = (void *)(v6 + v13);
        }
LABEL_25:
        uint64_t v8 = *(void *)(a1 + 1472);
      }
      else
      {
        int v15 = *(_DWORD *)(a1 + 1488) - 1;
        unsigned int v16 = v15 & ((v10 >> 4) ^ (v10 >> 9));
        uint64_t v12 = (void *)(v5 + 8 * v16);
        uint64_t v17 = *v12;
        if (*v12 == -1)
        {
          unint64_t v18 = 0;
LABEL_27:
          if (v18) {
            uint64_t v12 = v18;
          }
          if (*v12 != v10) {
            uint64_t v12 = (void *)(v5 + 8 * *v7);
          }
        }
        else
        {
          unint64_t v18 = 0;
          int v19 = 1;
          while (v17 != v10)
          {
            if (v18) {
              BOOL v20 = 0;
            }
            else {
              BOOL v20 = v17 == -2;
            }
            if (v20) {
              unint64_t v18 = v12;
            }
            unsigned int v21 = v16 + v19++;
            unsigned int v16 = v21 & v15;
            uint64_t v12 = (void *)(v5 + 8 * (v21 & v15));
            uint64_t v17 = *v12;
            if (*v12 == -1) {
              goto LABEL_27;
            }
          }
        }
        uint64_t v8 = *(void *)(a1 + 1480);
      }
      uint64_t v22 = (unsigned int *)(v8 == v6 ? a1 + 1492 : a1 + 1488);
      if (v12 != (void *)(v8 + 8 * *v22)) {
        break;
      }
      if (++v9 == (uint64_t *)(*(void *)a2 + 8 * v4))
      {
        uint64_t v23 = 8 * v4;
        uint64_t v24 = 8 * v4;
        unint64_t v25 = *(uint64_t **)a2;
        while (1)
        {
          int v26 = *(unsigned __int8 *)(*v25 + 16);
          if (v26 == 5 || (v26 - 4) >= 0x11) {
            break;
          }
          ++v25;
          v24 -= 8;
          if (!v24) {
            goto LABEL_43;
          }
        }
        uint64_t v29 = 0;
        uint64_t v30 = 8 * v4;
        uint64_t v31 = *(uint64_t **)a2;
        do
        {
          if (*(unsigned __int8 *)(*v31 + 16) - 11 >= 2)
          {
            if (v29)
            {
              if (*v31 != v29)
              {
                if (v4 < a3) {
                  goto LABEL_43;
                }
                goto LABEL_55;
              }
            }
            else
            {
              uint64_t v29 = *v31;
            }
          }
          ++v31;
          v30 -= 8;
        }
        while (v30);
        BOOL v28 = 1;
        if (v4 < a3 || v29) {
          goto LABEL_67;
        }
LABEL_55:
        uint64_t v32 = *(void *)(a2 + 384);
        if (v32 && *(unsigned char *)(v32 + 16) == 89)
        {
LABEL_61:
          if ((unint64_t)sub_1CD32FEE4(*(void *)a2, v4, (char **)v37) >> 32) {
            goto LABEL_43;
          }
          if (*(_DWORD *)(a2 + 88) != 2) {
            break;
          }
        }
        else
        {
          uint64_t v33 = *(void *)a2;
          while (1)
          {
            int v34 = *(unsigned __int8 *)(*(void *)v33 + 16);
            if ((v34 - 11) >= 2 && v34 != 89) {
              break;
            }
            v33 += 8;
            v23 -= 8;
            if (!v23) {
              goto LABEL_61;
            }
          }
        }
        uint64_t v35 = *(void *)(a2 + 384);
        if (v35 && *(unsigned char *)(v35 + 16) == 60)
        {
          BOOL v28 = v35 == *(void *)(a2 + 392);
          goto LABEL_67;
        }
        break;
      }
    }
  }
  BOOL v28 = 0;
LABEL_67:
  if (v37[0] != v38) {
    free(v37[0]);
  }
  return v28;
}

uint64_t llvm::slpvectorizer::BoUpSLP::isLoadCombineReductionCandidate(uint64_t a1, int a2)
{
  if (a2 == 3) {
    return sub_1CD33164C(****(void ****)a1, *(_DWORD *)(**(void **)a1 + 8), *(void *)(a1 + 1936), 0);
  }
  else {
    return 0;
  }
}

uint64_t sub_1CD33164C(uint64_t a1, int a2, uint64_t a3, int a4)
{
  uint64_t v17 = 0;
  uint64_t v9 = (unsigned char *)(a1 + 16);
  int v8 = *(unsigned __int8 *)(a1 + 16);
  if (v8 != 5)
  {
    int v10 = 0;
    uint64_t v11 = a1;
    while (1)
    {
      if (v8 != 57)
      {
        v16[0] = &v17;
        v16[1] = 0;
        int v12 = *v9;
        if (v12 == 5)
        {
          if (*(_WORD *)(v11 + 18) != 25
            || !sub_1CBF5295C((uint64_t)v16, *(llvm::Constant **)(v11 - 32 * (*(_DWORD *)(v11 + 20) & 0x7FFFFFF) + 32)))
          {
            goto LABEL_13;
          }
        }
        else if (v12 != 53 || (sub_1CBF528D8((uint64_t)v16, *(unsigned __int8 **)(v11 - 32)) & 1) == 0)
        {
          goto LABEL_13;
        }
        if (llvm::APInt::urem((uint64_t **)v17, 8uLL)) {
          goto LABEL_13;
        }
      }
      uint64_t v11 = *(void *)(v11 - 64);
      v10 |= *v9 == 57;
      uint64_t v9 = (unsigned char *)(v11 + 16);
      int v8 = *(unsigned __int8 *)(v11 + 16);
      if (v8 == 5) {
        goto LABEL_13;
      }
    }
  }
  int v10 = 0;
  uint64_t v11 = a1;
LABEL_13:
  int v15 = 0;
  if (v11 == a1) {
    return 0;
  }
  if (a4 & (v10 ^ 1)) {
    return 0;
  }
  uint64_t v14 = &v15;
  if (!sub_1CBC5BE40(&v14, v11) || v15[16] != 60) {
    return 0;
  }
  llvm::IntegerType::get(**(llvm::IntegerType ***)a1, (llvm::LLVMContext *)((*(_DWORD *)(*(void *)v15 + 8) >> 8) * a2));
  return (*(uint64_t (**)(void))(**(void **)a3 + 480))();
}

uint64_t llvm::slpvectorizer::BoUpSLP::getSpillCost(llvm::slpvectorizer::BoUpSLP *this)
{
  v90[16] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(uint64_t ****)this;
  unsigned int v73 = *(_DWORD *)(**(void **)this + 8);
  unsigned int v78 = v82;
  int v79 = v82;
  uint64_t v80 = 4;
  int v81 = 0;
  uint64_t v88 = v90;
  uint64_t v89 = 0x1000000000;
  uint64_t v3 = *((unsigned int *)this + 2);
  if (v3)
  {
    unsigned int v4 = 0;
    uint64_t v5 = 8 * v3;
    do
    {
      uint64_t v6 = ***v2;
      if (v6) {
        BOOL v7 = *(unsigned __int8 *)(v6 + 16) >= 0x1Cu;
      }
      else {
        BOOL v7 = 0;
      }
      if (v7)
      {
        if (v4 >= HIDWORD(v89)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v88 + v4) = v6;
        unsigned int v4 = v89 + 1;
        LODWORD(v89) = v89 + 1;
      }
      ++v2;
      v5 -= 8;
    }
    while (v5);
    int v8 = (uint64_t *)v88;
    uint64_t v9 = (uint64_t *)((char *)v88 + 8 * v4);
    unint64_t v85 = this;
    if (v4)
    {
      uint64_t v10 = 126 - 2 * __clz(v4);
      goto LABEL_17;
    }
  }
  else
  {
    unint64_t v85 = this;
    uint64_t v9 = v90;
    int v8 = v90;
  }
  uint64_t v10 = 0;
LABEL_17:
  sub_1CD3445A4(v8, v9, (uint64_t)&v85, v10, 1);
  uint64_t v11 = (char *)v88;
  if (v89)
  {
    uint64_t v12 = 0;
    int v76 = 0;
    unint64_t v74 = this;
    int64_t v75 = 0;
    uint64_t v13 = (char *)this + 80;
    uint64_t v14 = (char *)v88 + 8 * v89;
    do
    {
      uint64_t v15 = v12;
      uint64_t v12 = *(void *)v11;
      if (v15)
      {
        unsigned int v16 = v78;
        if (v79 == v78)
        {
          int v17 = HIDWORD(v80);
          unint64_t v18 = &v79[8 * HIDWORD(v80)];
          if (HIDWORD(v80))
          {
            uint64_t v19 = 0;
            while (*(void *)&v79[v19] != v15)
            {
              v19 += 8;
              if (8 * HIDWORD(v80) == v19) {
                goto LABEL_39;
              }
            }
            unint64_t v18 = &v79[v19];
          }
LABEL_39:
          unsigned int v16 = v79;
        }
        else
        {
          int v20 = v80 - 1;
          unsigned int v21 = (v80 - 1) & ((v15 >> 4) ^ (v15 >> 9));
          unint64_t v18 = &v79[8 * v21];
          uint64_t v22 = *(void *)v18;
          if (*(void *)v18 == -1)
          {
            uint64_t v23 = 0;
LABEL_142:
            if (v23) {
              unint64_t v18 = v23;
            }
            int v17 = HIDWORD(v80);
            if (*(void *)v18 != v15) {
              unint64_t v18 = &v79[8 * v80];
            }
          }
          else
          {
            uint64_t v23 = 0;
            int v24 = 1;
            while (v22 != v15)
            {
              if (v23) {
                BOOL v25 = 0;
              }
              else {
                BOOL v25 = v22 == -2;
              }
              if (v25) {
                uint64_t v23 = v18;
              }
              unsigned int v26 = v21 + v24++;
              unsigned int v21 = v26 & v20;
              unint64_t v18 = &v79[8 * (v26 & v20)];
              uint64_t v22 = *(void *)v18;
              if (*(void *)v18 == -1) {
                goto LABEL_142;
              }
            }
            int v17 = HIDWORD(v80);
          }
        }
        if (v79 == v16) {
          int v27 = v17;
        }
        else {
          int v27 = v80;
        }
        if (v18 != &v79[8 * v27])
        {
          *(void *)unint64_t v18 = -2;
          ++v81;
        }
        int v28 = *(_DWORD *)(v15 + 20);
        if ((v28 & 0x40000000) != 0)
        {
          uint64_t v30 = *(uint64_t **)(v15 - 8);
          uint64_t v29 = v28 & 0x7FFFFFF;
        }
        else
        {
          uint64_t v29 = v28 & 0x7FFFFFF;
          uint64_t v30 = (uint64_t *)(v15 - 32 * v29);
        }
        uint64_t v31 = &v30[4 * v29];
        if (v29)
        {
          do
          {
            uint64_t v32 = *v30;
            if (*(unsigned __int8 *)(*v30 + 16) >= 0x1Cu)
            {
              unint64_t v85 = 0;
              if (sub_1CD4C64C4((uint64_t)v13, v32, &v85))
              {
                if (*((void *)v85 + 1))
                {
                  uint64_t v33 = *v30;
                  int v34 = v79;
                  uint64_t v35 = HIDWORD(v80);
                  if (v79 != v78)
                  {
                    unsigned int v39 = v80;
LABEL_65:
                    if (3 * v39 <= 4 * (HIDWORD(v80) - v81))
                    {
                      if (v39 >= 0x40) {
                        v39 *= 2;
                      }
                      else {
                        unsigned int v39 = 128;
                      }
                    }
                    else if (v39 - HIDWORD(v80) >= v39 >> 3)
                    {
                      goto LABEL_67;
                    }
                    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v78, v39);
                    unsigned int v39 = v80;
                    int v34 = v79;
LABEL_67:
                    unsigned int v40 = v39 - 1;
                    unsigned int v41 = (v39 - 1) & ((v33 >> 4) ^ (v33 >> 9));
                    int v42 = &v34[8 * v41];
                    uint64_t v43 = *(void *)v42;
                    if (*(void *)v42 == -1)
                    {
                      uint64_t v44 = 0;
LABEL_79:
                      if (v44) {
                        uint64_t v48 = v44;
                      }
                      else {
                        uint64_t v48 = (uint64_t *)v42;
                      }
                      if (*v48 != v33)
                      {
                        if (*v48 == -2) {
                          --v81;
                        }
                        else {
                          ++HIDWORD(v80);
                        }
                        *uint64_t v48 = v33;
                      }
                    }
                    else
                    {
                      uint64_t v44 = 0;
                      int v45 = 1;
                      while (v43 != v33)
                      {
                        if (v44) {
                          BOOL v46 = 0;
                        }
                        else {
                          BOOL v46 = v43 == -2;
                        }
                        if (v46) {
                          uint64_t v44 = (uint64_t *)v42;
                        }
                        unsigned int v47 = v41 + v45++;
                        unsigned int v41 = v47 & v40;
                        int v42 = &v34[8 * (v47 & v40)];
                        uint64_t v43 = *(void *)v42;
                        if (*(void *)v42 == -1) {
                          goto LABEL_79;
                        }
                      }
                    }
                    goto LABEL_50;
                  }
                  if (HIDWORD(v80))
                  {
                    int v36 = 0;
                    uint64_t v37 = 8 * HIDWORD(v80);
                    uint64_t v38 = (uint64_t *)v79;
                    while (*v38 != v33)
                    {
                      if (*v38 == -2) {
                        int v36 = v38;
                      }
                      ++v38;
                      v37 -= 8;
                      if (!v37)
                      {
                        if (!v36) {
                          goto LABEL_62;
                        }
                        *int v36 = v33;
                        --v81;
                        goto LABEL_50;
                      }
                    }
                    goto LABEL_50;
                  }
LABEL_62:
                  unsigned int v39 = v80;
                  if (HIDWORD(v80) >= v80) {
                    goto LABEL_65;
                  }
                  ++HIDWORD(v80);
                  *(void *)&v79[8 * v35] = v33;
                }
              }
            }
LABEL_50:
            v30 += 4;
          }
          while (v30 != v31);
        }
        uint64_t v49 = *(void **)(v12 + 24);
        unsigned int v50 = (void *)(v15 + 24);
        if (v49 != (void *)(v15 + 24))
        {
          unsigned int v51 = 0;
          do
          {
            while (v50 == (void *)(*(void *)(v15 + 40) + 40))
            {
              unsigned int v50 = *(void **)(*(void *)(v12 + 40) + 40);
              if (v49 == v50) {
                goto LABEL_107;
              }
            }
            if (v50) {
              uint64_t v52 = (uint64_t)(v50 - 3);
            }
            else {
              uint64_t v52 = 0;
            }
            if (*(unsigned char *)(v52 + 16) == 84)
            {
              BOOL v53 = sub_1CBF63B28(v52);
              int v54 = v52 == v15 ? v51 : v51 + 1;
              if (!v53) {
                unsigned int v51 = v54;
              }
            }
            unsigned int v50 = (void *)*v50;
          }
          while (v49 != v50);
LABEL_107:
          if (v51)
          {
            unint64_t v85 = v87;
            uint64_t v86 = 0x400000000;
            if (v79 == v78) {
              uint64_t v55 = (uint64_t *)((char *)&v80 + 4);
            }
            else {
              uint64_t v55 = &v80;
            }
            uint64_t v56 = *(unsigned int *)v55;
            if (v56)
            {
              uint64_t v57 = 8 * v56;
              uint64_t v58 = (unint64_t *)v79;
              while (*v58 >= 0xFFFFFFFFFFFFFFFELL)
              {
                ++v58;
                v57 -= 8;
                if (!v57) {
                  goto LABEL_131;
                }
              }
            }
            else
            {
              uint64_t v58 = (unint64_t *)v79;
            }
            uint64_t v59 = &v79[8 * v56];
            if (v58 == (unint64_t *)v59)
            {
LABEL_131:
              unsigned int v64 = 0;
              unsigned int v67 = v87;
            }
            else
            {
              unint64_t v60 = *v58;
LABEL_119:
              int v61 = *(llvm::FixedVectorType **)v60;
              if (*(void *)v60) {
                BOOL v62 = *(unsigned char *)(*(void *)v60 + 8) == 18;
              }
              else {
                BOOL v62 = 0;
              }
              if (v62) {
                int v61 = (llvm::FixedVectorType *)*((void *)v61 + 3);
              }
              llvm::FixedVectorType::get(v61, (llvm::Type *)v73);
              if (v86 >= (unint64_t)HIDWORD(v86)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((void *)v85 + v86) = v63;
              unsigned int v64 = v86 + 1;
              LODWORD(v86) = v86 + 1;
              int v65 = v58 + 1;
              while (v65 != (unint64_t *)v59)
              {
                unint64_t v66 = *v65++;
                unint64_t v60 = v66;
                if (v66 <= 0xFFFFFFFFFFFFFFFDLL)
                {
                  uint64_t v58 = v65 - 1;
                  goto LABEL_119;
                }
              }
              unsigned int v67 = v85;
            }
            v77[0] = (*(uint64_t (**)(void, unsigned char *, void))(***((void ***)v74 + 242) + 984))(**((void **)v74 + 242), v67, v64);
            v77[1] = v68;
            uint64_t v83 = v51;
            int v84 = 0;
            sub_1CB90C9D4((uint64_t)&v83, (uint64_t)v77);
            int v69 = v76;
            if (v84 == 1) {
              int v69 = 1;
            }
            int v76 = v69;
            int64_t v70 = v75 + v83;
            if (__OFADD__(v75, v83)) {
              int64_t v70 = (v70 >> 63) ^ 0x8000000000000000;
            }
            int64_t v75 = v70;
            if (v85 != v87) {
              free(v85);
            }
          }
        }
      }
      v11 += 8;
    }
    while (v11 != v14);
    uint64_t v11 = (char *)v88;
    int64_t v71 = v75;
  }
  else
  {
    int64_t v71 = 0;
  }
  if (v11 != (char *)v90) {
    free(v11);
  }
  if (v79 != v78) {
    free(v79);
  }
  return v71;
}

unint64_t llvm::slpvectorizer::BoUpSLP::getTreeCost(void *****a1, uint64_t a2, uint64_t a3)
{
  v171[6] = *MEMORY[0x1E4F143B8];
  unsigned int v146 = *((_DWORD *)**a1 + 2);
  uint64_t v4 = *((unsigned int *)a1 + 2);
  if (v4)
  {
    unint64_t v7 = 0;
    unint64_t v8 = 0;
    uint64_t v9 = 8 * v4;
    do
    {
      uint64_t EntryCost = llvm::slpvectorizer::BoUpSLP::getEntryCost((uint64_t)a1, (uint64_t **)(*a1)[v7 / 8], a2, a3);
      if (__OFADD__(v8, EntryCost)) {
        unint64_t v8 = ((uint64_t)(v8 + EntryCost) >> 63) ^ 0x8000000000000000;
      }
      else {
        v8 += EntryCost;
      }
      v7 += 8;
    }
    while (v9 != v7);
  }
  else
  {
    unint64_t v8 = 0;
  }
  uint64_t v151 = v155;
  int v152 = v155;
  uint64_t v153 = 16;
  int v154 = 0;
  uint64_t v169 = v171;
  uint64_t v170 = 0xC00000000;
  int v166 = v168;
  uint64_t v167 = 0x100000000;
  uint64_t v163 = v165;
  uint64_t v164 = 0x600000000;
  uint64_t v160 = v162;
  uint64_t v161 = 0x300000000;
  unsigned int v11 = *((_DWORD *)a1 + 270);
  if (v11)
  {
    int v12 = 0;
    unint64_t v148 = 0;
    uint64_t v13 = (llvm::FixedVectorType ***)a1[134];
    uint64_t v14 = &v13[3 * v11];
    uint64_t v144 = (uint64_t)(a1 + 10);
    uint64_t v145 = (uint64_t)(a1 + 268);
    while (1)
    {
      uint64_t v15 = (uint64_t)v13[1];
      if (!v15 || *(unsigned char *)(v15 + 16) != 90) {
        break;
      }
LABEL_46:
      uint64_t v32 = a1[185];
      uint64_t v33 = a1[184];
      if (v32 == v33)
      {
        uint64_t v34 = *((unsigned int *)a1 + 373);
        uint64_t v35 = &v32[v34];
        if (v34)
        {
          unint64_t v36 = 0;
          uint64_t v37 = 8 * v34;
          while (v32[v36 / 8] != (void ***)v15)
          {
            v36 += 8;
            if (v37 == v36) {
              goto LABEL_64;
            }
          }
          uint64_t v35 = &v32[v36 / 8];
        }
LABEL_64:
        uint64_t v33 = a1[185];
      }
      else
      {
        uint64_t v38 = *((unsigned int *)a1 + 372);
        int v39 = v38 - 1;
        unsigned int v40 = (v38 - 1) & ((v15 >> 4) ^ (v15 >> 9));
        uint64_t v35 = &v32[v40];
        unsigned int v41 = *v35;
        if (*v35 == (void ***)-1)
        {
          int v42 = 0;
LABEL_83:
          if (v42) {
            uint64_t v35 = v42;
          }
          if (*v35 != (void ***)v15) {
            uint64_t v35 = &v32[v38];
          }
        }
        else
        {
          int v42 = 0;
          int v43 = 1;
          while (v41 != (void ***)v15)
          {
            if (v42) {
              BOOL v44 = 0;
            }
            else {
              BOOL v44 = v41 == (void ***)-2;
            }
            if (v44) {
              int v42 = v35;
            }
            unsigned int v45 = v40 + v43++;
            unsigned int v40 = v45 & v39;
            uint64_t v35 = &v32[v45 & v39];
            unsigned int v41 = *v35;
            if (*v35 == (void ***)-1) {
              goto LABEL_83;
            }
          }
        }
      }
      if (v32 == v33) {
        BOOL v46 = (unsigned int *)a1 + 373;
      }
      else {
        BOOL v46 = (unsigned int *)(a1 + 186);
      }
      if (v35 != &v32[*v46]) {
        goto LABEL_95;
      }
      unsigned int v47 = **v13;
      if (*((unsigned char *)v47 + 8) == 18 || *((unsigned char *)*v13 + 16) == 89) {
        goto LABEL_95;
      }
      int v147 = v12;
      if (!v15
        || *(unsigned char *)(v15 + 16) != 90
        || (uint64_t v48 = *(void *)v15) == 0
        || *(unsigned char *)(v48 + 8) != 18
        || (unint64_t v49 = sub_1CD32AEA4(v15, 0), !HIDWORD(v49)))
      {
        v51.n128_f64[0] = llvm::FixedVectorType::get(v47, (llvm::Type *)v146);
        uint64_t v52 = (void ***)****a1;
        __b = v52;
        BOOL v53 = a1[268];
        uint64_t v54 = *((unsigned int *)a1 + 540);
        int v12 = v147;
        if (!v54) {
          goto LABEL_87;
        }
        LODWORD(v55) = ((v52 >> 4) ^ (v52 >> 9)) & (v54 - 1);
        uint64_t v56 = (void **)&v53[2 * v55];
        uint64_t v57 = (void ***)*v56;
        if (v52 != *v56)
        {
          int v58 = 1;
          while (v57 != (void ***)-4096)
          {
            int v59 = v55 + v58++;
            uint64_t v55 = v59 & (v54 - 1);
            uint64_t v57 = v53[2 * v55];
            if (v52 == v57)
            {
              uint64_t v56 = (void **)&v53[2 * v55];
              goto LABEL_88;
            }
          }
LABEL_87:
          uint64_t v56 = (void **)&v53[2 * v54];
        }
LABEL_88:
        if (v56 == (void **)&v53[2 * v54])
        {
          uint64_t v60 = ((uint64_t (*)(void, uint64_t, uint64_t, void, __n128))(**a1[242])[109])(*a1[242], 61, v50, *((unsigned int *)v13 + 4), v51);
        }
        else
        {
          unint64_t v74 = (llvm::IntegerType *)**a1[240];
          int64_t v75 = (unsigned int *)sub_1CD8DDDCC(v145, (uint64_t *)&__b);
          int v76 = (llvm::FixedVectorType *)llvm::IntegerType::get(v74, (llvm::LLVMContext *)*v75);
          sub_1CD8DDDCC(v145, (uint64_t *)&__b);
          v77.n128_f64[0] = llvm::FixedVectorType::get(v76, (llvm::Type *)v146);
          uint64_t v60 = ((uint64_t (*)(__n128))(**a1[242])[106])(v77);
        }
        if (v61 == 1) {
          int v12 = 1;
        }
        unint64_t v62 = v148 + v60;
        if (__OFADD__(v148, v60)) {
          unint64_t v62 = ((uint64_t)(v148 + v60) >> 63) ^ 0x8000000000000000;
        }
        unint64_t v148 = v62;
        goto LABEL_95;
      }
      if (v164)
      {
        uint64_t v63 = v163;
        while (1)
        {
          unsigned int v64 = *(void **)v63;
          if (*(void *)(v15 + 40) == *(void *)(*(void *)v63 + 40) && v48 == *v64)
          {
            uint64_t v65 = *(void *)(v15 + 8);
            if (v65)
            {
              if (!*(void *)(v65 + 8)) {
                break;
              }
            }
            uint64_t v66 = v64[1];
            if (v66)
            {
              if (!*(void *)(v66 + 8)) {
                break;
              }
            }
          }
LABEL_102:
          v63 += 8;
          if (v63 == (char *)v163 + 8 * v164) {
            goto LABEL_139;
          }
        }
        uint64_t v67 = v15;
        uint64_t v68 = *(void *)v63;
        while (2)
        {
          if (v68 == v15 || (void *)v67 == v64)
          {
            uint64_t v71 = (v63 - (unsigned char *)v163) >> 3;
            int v12 = v147;
            goto LABEL_130;
          }
          if (v67)
          {
            if (v67 != v15)
            {
              uint64_t v69 = *(void *)(v67 + 8);
              if (!v69 || *(void *)(v69 + 8))
              {
                uint64_t v67 = 0;
                goto LABEL_116;
              }
            }
            uint64_t v67 = *(void *)(v67 - 96);
            if (*(unsigned char *)(v67 + 16) != 90) {
              uint64_t v67 = 0;
            }
            if (v68)
            {
LABEL_121:
              if ((void *)v68 == v64 || (uint64_t v70 = *(void *)(v68 + 8)) != 0 && !*(void *)(v70 + 8))
              {
                uint64_t v68 = *(void *)(v68 - 96);
                if (*(unsigned char *)(v68 + 16) != 90) {
                  uint64_t v68 = 0;
                }
              }
              else
              {
                uint64_t v68 = 0;
              }
            }
          }
          else
          {
LABEL_116:
            if (v68) {
              goto LABEL_121;
            }
          }
          if (!(v67 | v68)) {
            goto LABEL_102;
          }
          continue;
        }
      }
LABEL_139:
      int v78 = *(_DWORD *)(v48 + 32);
      int v143 = v49;
      if (v170 >= (unint64_t)HIDWORD(v170)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      int v12 = v147;
      v169[v170] = v78;
      LODWORD(v170) = v170 + 1;
      sub_1CD8DE160((uint64_t)&v166, &v169[v170 - 1]);
      if (*(unsigned char *)(v15 + 16) == 90)
      {
        uint64_t v79 = v15;
        while (1)
        {
          __b = 0;
          if (sub_1CD4C64C4(v144, v79, &__b))
          {
            uint64_t v80 = *((void *)__b + 1);
            if (v80) {
              break;
            }
          }
          uint64_t v79 = *(void *)(v79 - 96);
          if (*(unsigned char *)(v79 + 16) != 90) {
            goto LABEL_145;
          }
        }
        uint64_t v84 = v79;
        uint64_t v142 = *((void *)__b + 1);
        do
        {
          int v85 = sub_1CD8DD454(v80, v84);
          *(_DWORD *)(*(void *)&v166[64 * (unint64_t)v167 - 64] + 4 * v85) = v85;
          uint64_t v84 = *(void *)(v84 - 96);
          __b = 0;
          int v86 = sub_1CD4C64C4(v144, v84, &__b);
          uint64_t v87 = 0;
          if (v86) {
            uint64_t v87 = *((void *)__b + 1);
          }
          uint64_t v80 = v142;
        }
        while (v142 == v87);
        uint64_t v15 = v79;
      }
LABEL_145:
      if (v164 >= (unint64_t)HIDWORD(v164)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v163 + v164) = v15;
      LODWORD(v164) = v164 + 1;
      unsigned int v157 = v169[v170 - 1];
      if (v157 > 0x40) {
        llvm::APInt::initSlowCase((llvm::APInt *)&__b);
      }
      __b = 0;
      int v81 = (char *)v160;
      if (v161 >= HIDWORD(v161))
      {
        unint64_t v88 = v161 + 1;
        if (v160 <= &__b && (char *)v160 + 16 * v161 > (char *)&__b)
        {
          int64_t v89 = (char *)&__b - (unsigned char *)v160;
          sub_1CBFC6948((uint64_t)&v160, v88);
          int v81 = (char *)v160;
          p_b = (void **)((char *)v160 + v89);
        }
        else
        {
          sub_1CBFC6948((uint64_t)&v160, v88);
          p_b = &__b;
          int v81 = (char *)v160;
        }
        int v12 = v147;
      }
      else
      {
        p_b = &__b;
      }
      uint64_t v83 = &v81[16 * v161];
      *((_DWORD *)v83 + 2) = *((_DWORD *)p_b + 2);
      *(void *)uint64_t v83 = *p_b;
      *((_DWORD *)p_b + 2) = 0;
      LODWORD(v161) = v161 + 1;
      if (v157 >= 0x41 && __b) {
        MEMORY[0x1D25D9CB0](__b, 0x1000C8000313F17);
      }
      LODWORD(v71) = v164 - 1;
      LODWORD(v49) = v143;
LABEL_130:
      *(_DWORD *)(*(void *)&v166[64 * (uint64_t)(int)v71] + 4 * v49) = *((_DWORD *)v13 + 4);
      int v72 = (char *)v160 + 16 * (int)v71;
      uint64_t v73 = 1 << v49;
      if (*((_DWORD *)v72 + 2) > 0x40u) {
        *(void *)(*(void *)v72 + 8 * (v49 >> 6)) |= v73;
      }
      else {
        *(void *)v72 |= v73;
      }
LABEL_95:
      v13 += 3;
      if (v13 == v14) {
        goto LABEL_167;
      }
    }
    unsigned int v16 = *v13;
    int v17 = v152;
    uint64_t v18 = HIDWORD(v153);
    if (v152 == v151)
    {
      if (HIDWORD(v153))
      {
        uint64_t v19 = 0;
        uint64_t v20 = 8 * HIDWORD(v153);
        unsigned int v21 = (llvm::FixedVectorType ***)v152;
        do
        {
          if (*v21 == v16) {
            goto LABEL_95;
          }
          if (*v21 == (llvm::FixedVectorType **)-2) {
            uint64_t v19 = v21;
          }
          ++v21;
          v20 -= 8;
        }
        while (v20);
        if (v19)
        {
          *uint64_t v19 = v16;
          --v154;
          goto LABEL_45;
        }
      }
      unsigned int v22 = v153;
      if (HIDWORD(v153) < v153)
      {
        ++HIDWORD(v153);
        *(void *)&v152[8 * v18] = v16;
LABEL_45:
        uint64_t v15 = (uint64_t)v13[1];
        goto LABEL_46;
      }
    }
    else
    {
      unsigned int v22 = v153;
    }
    if (3 * v22 <= 4 * (HIDWORD(v153) - v154))
    {
      if (v22 >= 0x40) {
        v22 *= 2;
      }
      else {
        unsigned int v22 = 128;
      }
    }
    else if (v22 - HIDWORD(v153) >= v22 >> 3)
    {
LABEL_26:
      unsigned int v23 = v22 - 1;
      unsigned int v24 = (v22 - 1) & ((v16 >> 4) ^ (v16 >> 9));
      BOOL v25 = &v17[8 * v24];
      unsigned int v26 = *(llvm::FixedVectorType ***)v25;
      if (*(void *)v25 != -1)
      {
        int v27 = 0;
        int v28 = 1;
        while (v26 != v16)
        {
          if (v27) {
            BOOL v29 = 0;
          }
          else {
            BOOL v29 = v26 == (llvm::FixedVectorType **)-2;
          }
          if (v29) {
            int v27 = v25;
          }
          unsigned int v30 = v24 + v28++;
          unsigned int v24 = v30 & v23;
          BOOL v25 = &v17[8 * (v30 & v23)];
          unsigned int v26 = *(llvm::FixedVectorType ***)v25;
          if (*(void *)v25 == -1) {
            goto LABEL_38;
          }
        }
        goto LABEL_95;
      }
      int v27 = 0;
LABEL_38:
      if (v27) {
        uint64_t v31 = (llvm::FixedVectorType ***)v27;
      }
      else {
        uint64_t v31 = (llvm::FixedVectorType ***)v25;
      }
      if (*v31 == v16) {
        goto LABEL_95;
      }
      if (*v31 == (llvm::FixedVectorType **)-2) {
        --v154;
      }
      else {
        ++HIDWORD(v153);
      }
      uint64_t *v31 = v16;
      goto LABEL_45;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v151, v22);
    unsigned int v22 = v153;
    int v17 = v152;
    goto LABEL_26;
  }
  unint64_t v148 = 0;
LABEL_167:
  uint64_t SpillCost = llvm::slpvectorizer::BoUpSLP::getSpillCost((llvm::slpvectorizer::BoUpSLP *)a1);
  unint64_t v91 = SpillCost + v148;
  if (__OFADD__(SpillCost, v148)) {
    unint64_t v91 = ((uint64_t)(SpillCost + v148) >> 63) ^ 0x8000000000000000;
  }
  BOOL v92 = __OFADD__(v8, v91);
  uint64_t v93 = v8 + v91;
  if (v92) {
    unint64_t v94 = (v93 >> 63) ^ 0x8000000000000000;
  }
  else {
    unint64_t v94 = v93;
  }
  if (v164)
  {
    if (v164 == 1)
    {
      uint64_t v95 = *((unsigned int *)v166 + 2);
      uint64_t v96 = *(int **)v166;
      if (v95)
      {
        uint64_t v97 = 4 * v95;
        uint64_t v98 = *(_DWORD **)v166;
        while (*v98 < 2 * (int)v95)
        {
          ++v98;
          v97 -= 4;
          if (!v97) {
            goto LABEL_178;
          }
        }
      }
      else
      {
LABEL_178:
        if ((sub_1CC5D47FC(*(int **)v166, *((unsigned int *)v166 + 2), *((_DWORD *)v166 + 2)) & 1) == 0)
        {
          uint64_t v99 = ((uint64_t (*)(void, uint64_t, void, int *, uint64_t, void, void))(**a1[242])[104])(*a1[242], 7, **(void **)v163, v96, v95, 0, 0);
          if (__OFADD__(v94, v99)) {
            unint64_t v94 = ((uint64_t)(v94 + v99) >> 63) ^ 0x8000000000000000;
          }
          else {
            v94 += v99;
          }
        }
      }
      uint64_t v100 = ((uint64_t (*)(void, void, void *, uint64_t, void))(**a1[242])[66])(*a1[242], **(void **)v163, v160, 1, 0);
      if (__OFSUB__(v94, v100)) {
        unint64_t v94 = ((uint64_t)(v94 - v100) >> 63) ^ 0x8000000000000000;
      }
      else {
        v94 -= v100;
      }
    }
    else
    {
      unint64_t v101 = v169;
      if (v170 >= 2)
      {
        uint64_t v103 = (char *)(v169 + 1);
        unsigned int v102 = *v169;
        uint64_t v104 = 4 * v170 - 4;
        __int32 v105 = (char *)(v169 + 1);
        do
        {
          unsigned int v107 = *(_DWORD *)v105;
          v105 += 4;
          unsigned int v106 = v107;
          BOOL v108 = v102 >= v107;
          if (v102 <= v107) {
            unsigned int v102 = v106;
          }
          if (!v108) {
            unint64_t v101 = (unsigned int *)v103;
          }
          uint64_t v103 = v105;
          v104 -= 4;
        }
        while (v104);
      }
      uint8x8_t v109 = (llvm::Type *)*v101;
      __b = v159;
      int v158 = 12;
      if (v109 >= 0xD)
      {
        unsigned int v157 = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v109) {
        memset(v159, 255, 4 * (void)v109);
      }
      unsigned int v157 = v109;
      uint64_t v110 = *((unsigned int *)v166 + 2);
      if (v110) {
        memmove(v159, *(const void **)v166, 4 * v110);
      }
      unsigned int v111 = *((_DWORD *)v160 + 2);
      if (v111 < v109)
      {
        unsigned int v150 = v109;
        unint64_t v112 = *(void *)v160 & (0xFFFFFFFFFFFFFFFFLL >> -(char)v109);
      }
      else
      {
        unsigned int v150 = *((_DWORD *)v160 + 2);
        if (v111 > 0x40) {
          operator new[]();
        }
        unint64_t v112 = *(void *)v160;
      }
      unint64_t v149 = v112;
      v114.n128_f64[0] = llvm::FixedVectorType::get(*(llvm::FixedVectorType **)(**(void **)v163 + 24), v109);
      uint64_t v115 = v113;
      uint64_t v116 = *((unsigned int *)v166 + 18);
      uint64_t v117 = __b;
      if ((int)v116 >= 1)
      {
        uint64_t v118 = 0;
        uint64_t v119 = *((void *)v166 + 8);
        do
        {
          int v120 = *(_DWORD *)(v119 + 4 * v118);
          if (v120 != -1)
          {
            v117[v118] = v120 + v109;
            uint64_t v121 = 1 << v118;
            if (v150 > 0x40) {
              *(void *)(v149 + 8 * (v118 >> 6)) |= v121;
            }
            else {
              v149 |= v121;
            }
          }
          ++v118;
        }
        while (v116 != v118);
      }
      uint64_t v122 = ((uint64_t (*)(void, uint64_t, uint64_t, _DWORD *, void, void, void, __n128))(**a1[242])[104])(*a1[242], 6, v113, v117, v157, 0, 0, v114);
      if (__OFADD__(v94, v122)) {
        unint64_t v123 = ((uint64_t)(v94 + v122) >> 63) ^ 0x8000000000000000;
      }
      else {
        unint64_t v123 = v94 + v122;
      }
      uint64_t v124 = ((uint64_t (*)(void))(**a1[242])[66])();
      if (__OFSUB__(v123, v124)) {
        unint64_t v94 = ((uint64_t)(v123 - v124) >> 63) ^ 0x8000000000000000;
      }
      else {
        unint64_t v94 = v123 - v124;
      }
      uint64_t v125 = v164;
      if ((int)v164 >= 3)
      {
        uint64_t v126 = 2;
        do
        {
          uint64_t v127 = (llvm::Type *)*(unsigned int *)&v166[64 * v126 + 8];
          uint64_t v128 = __b;
          if (v127)
          {
            int v129 = 0;
            uint64_t v130 = *(void *)&v166[64 * v126];
            do
            {
              int v131 = *(_DWORD *)(v130 + 4 * (void)v129);
              if (v131 == -1)
              {
                if (v128[(void)v129] != -1) {
                  v128[(void)v129] = v129;
                }
              }
              else
              {
                v128[(void)v129] = v131 + v109;
              }
              int v129 = (llvm::Type *)((char *)v129 + 1);
            }
            while (v127 != v129);
          }
          if (v127 < v109)
          {
            do
            {
              if (v128[(void)v127] != -1) {
                v128[(void)v127] = v127;
              }
              uint64_t v127 = (llvm::Type *)((char *)v127 + 1);
            }
            while (v109 != v127);
          }
          uint64_t v132 = ((uint64_t (*)(void, uint64_t, uint64_t, _DWORD *, void, void, void))(**a1[242])[104])(*a1[242], 6, v115, v128, v157, 0, 0);
          if (__OFADD__(v94, v132)) {
            unint64_t v133 = ((uint64_t)(v94 + v132) >> 63) ^ 0x8000000000000000;
          }
          else {
            unint64_t v133 = v94 + v132;
          }
          uint64_t v134 = ((uint64_t (*)(void))(**a1[242])[66])();
          if (__OFSUB__(v133, v134)) {
            unint64_t v94 = ((uint64_t)(v133 - v134) >> 63) ^ 0x8000000000000000;
          }
          else {
            unint64_t v94 = v133 - v134;
          }
          ++v126;
        }
        while (v126 != v125);
      }
      if (v150 >= 0x41 && v149) {
        MEMORY[0x1D25D9CB0](v149, 0x1000C8000313F17);
      }
      if (__b != v159) {
        free(__b);
      }
    }
  }
  uint64_t v135 = (char *)v160;
  if (v161)
  {
    uint64_t v136 = 16 * v161;
    do
    {
      if (*(_DWORD *)&v135[v136 - 8] >= 0x41u)
      {
        uint64_t v137 = *(void *)&v135[v136 - 16];
        if (v137) {
          MEMORY[0x1D25D9CB0](v137, 0x1000C8000313F17);
        }
      }
      v136 -= 16;
    }
    while (v136);
    uint64_t v135 = (char *)v160;
  }
  if (v135 != v162) {
    free(v135);
  }
  if (v163 != v165) {
    free(v163);
  }
  int v138 = v166;
  if (v167)
  {
    unint64_t v139 = (unint64_t)v167 << 6;
    do
    {
      uint64_t v140 = *(char **)&v138[v139 - 64];
      if (&v138[v139 - 48] != v140) {
        free(v140);
      }
      v139 -= 64;
    }
    while (v139);
    int v138 = v166;
  }
  if (v138 != v168) {
    free(v138);
  }
  if (v169 != (_DWORD *)v171) {
    free(v169);
  }
  if (v152 != v151) {
    free(v152);
  }
  return v94;
}

uint64_t llvm::slpvectorizer::BoUpSLP::setInsertPointAfterBundle(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(llvm **)(a2 + 384);
  uint64_t v5 = *((void *)v4 + 5);
  uint64_t v81 = v5;
  if (*(_DWORD *)(a2 + 88) == 2 || !sub_1CD333508(*(llvm ***)a2, *(unsigned int *)(a2 + 8)))
  {
    uint64_t v20 = *(void *)(a1 + 1856);
    uint64_t v21 = *(unsigned int *)(a1 + 1872);
    if (v21)
    {
      LODWORD(v22) = (v21 - 1) & ((v5 >> 4) ^ (v5 >> 9));
      unsigned int v23 = (uint64_t *)(v20 + 16 * v22);
      uint64_t v24 = *v23;
      if (v5 == *v23)
      {
LABEL_66:
        if (v23 == (uint64_t *)(v20 + 16 * v21)) {
          goto LABEL_67;
        }
        int v58 = *(llvm **)(*(void *)a2 + 8 * *(unsigned int *)(a2 + 8) - 8);
        unsigned int v59 = *((unsigned __int8 *)v58 + 16);
        uint64_t v60 = *(void *)(a2 + 384);
        if (v58) {
          BOOL v61 = v59 >= 0x1C;
        }
        else {
          BOOL v61 = 0;
        }
        if (!v61) {
          goto LABEL_97;
        }
        unsigned int v62 = v59 - 28;
        int v63 = v60 ? *(unsigned __int8 *)(v60 + 16) - 28 : 0;
        if (v63 != v62)
        {
          uint64_t v64 = *(void *)(a2 + 392);
          if (v64) {
            LODWORD(v64) = *(unsigned __int8 *)(v64 + 16) - 28;
          }
          if (v64 != v62) {
LABEL_97:
          }
            int v58 = *(llvm **)(a2 + 384);
        }
        if (sub_1CD34172C(v58, (const llvm::Instruction *)a2)
          && sub_1CD333588((uint64_t)v58))
        {
          uint64_t v66 = *(llvm ***)a2;
          uint64_t v67 = *(unsigned int *)(a2 + 8);
          if (v67)
          {
            uint64_t v68 = 8 * v67;
            uint64_t v69 = &v66[v67];
            while (1)
            {
              uint64_t v70 = *v66;
              if (!sub_1CD34172C(*v66, v65) || !sub_1CD333588((uint64_t)v70)) {
                break;
              }
              ++v66;
              v68 -= 8;
              if (!v68)
              {
                uint64_t v66 = v69;
                break;
              }
            }
          }
          int v58 = *v66;
        }
        uint64_t v71 = (uint64_t *)sub_1CD8DD80C(a1 + 1856, &v81);
        if (!v58 || *((unsigned __int8 *)v58 + 16) < 0x1Cu) {
          goto LABEL_67;
        }
        uint64_t v73 = (llvm **)sub_1CD8DFC80(*v71, (uint64_t)v58);
        if (!v73 || !v73[4] && v73[3] == (llvm *)v73 && !v73[2]) {
          goto LABEL_67;
        }
        uint64_t v48 = 0;
        do
        {
          if (v73[1] == *v73) {
            uint64_t v48 = *v73;
          }
          uint64_t v73 = (llvm **)v73[4];
        }
        while (v73);
        if (!v48)
        {
LABEL_67:
          uint64_t v47 = *(unsigned int *)(a2 + 8);
          uint64_t v48 = v4;
          if (v47)
          {
            unint64_t v49 = *(llvm ***)a2;
            uint64_t v50 = *(void *)a2 + 8 * v47;
            uint64_t v48 = v4;
            do
            {
              __n128 v51 = *v49;
              if (*v49) {
                BOOL v52 = *((unsigned __int8 *)*v49 + 16) >= 0x1Cu;
              }
              else {
                BOOL v52 = 0;
              }
              if (v52)
              {
                uint64_t v53 = *((void *)v48 + 5);
                int v54 = *(__int16 *)(v53 + 18);
                if ((v54 & 0x80000000) == 0)
                {
                  uint64_t v55 = *(void *)(v53 + 48);
                  if (v55 != v53 + 40)
                  {
                    int v56 = 0;
                    do
                    {
                      uint64_t v57 = v55 - 24;
                      if (!v55) {
                        uint64_t v57 = 0;
                      }
                      *(_DWORD *)(v57 + 56) = v56++;
                      uint64_t v55 = *(void *)(v55 + 8);
                    }
                    while (v55 != v53 + 40);
                  }
                  *(_WORD *)(v53 + 18) = v54 | 0x8000;
                }
                if (*((_DWORD *)v48 + 14) < *((_DWORD *)v51 + 14)) {
                  uint64_t v48 = v51;
                }
              }
              ++v49;
            }
            while (v49 != (llvm **)v50);
          }
        }
        uint64_t v74 = a1 + 2008;
        sub_1CBF5385C(v74, v5, *((void *)v48 + 4));
        int64_t v75 = (unsigned __int8 *)*((void *)v4 + 6);
        uint64_t v79 = v75;
        if (v75)
        {
          llvm::MetadataTracking::track((uint64_t)&v79, v75, 2);
          uint64_t v76 = (uint64_t)v79;
        }
        else
        {
          uint64_t v76 = 0;
        }
        uint64_t result = sub_1CB8461A4(v74, 0, v76);
        unsigned int v41 = v79;
        if (!v79) {
          return result;
        }
        int v42 = *v79;
        if ((v42 - 4) > 0x1E)
        {
          if ((v42 - 3) >= 0xFFFFFFFE) {
            int v78 = v79;
          }
          else {
            int v78 = 0;
          }
          if ((v42 - 3) < 0xFFFFFFFE)
          {
LABEL_138:
            if (v42 == 3) {
              *((void *)v41 + 1) = 0;
            }
            return result;
          }
          unint64_t v44 = (unint64_t)(v78 + 8);
        }
        else
        {
          if ((v79[1] & 0x7F) != 2 && !*((_DWORD *)v79 + 3)) {
            return result;
          }
          uint64_t v77 = *((void *)v79 + 2);
          if ((v77 & 4) == 0) {
            return result;
          }
          unint64_t v44 = v77 & 0xFFFFFFFFFFFFFFF8;
          if (!v44) {
            return result;
          }
        }
        BOOL v46 = &v79;
        goto LABEL_137;
      }
      int v25 = 1;
      while (v24 != -4096)
      {
        int v26 = v22 + v25++;
        uint64_t v22 = v26 & (v21 - 1);
        uint64_t v24 = *(void *)(v20 + 16 * v22);
        if (v5 == v24)
        {
          unsigned int v23 = (uint64_t *)(v20 + 16 * v22);
          goto LABEL_66;
        }
      }
    }
    unsigned int v23 = (uint64_t *)(v20 + 16 * v21);
    goto LABEL_66;
  }
  uint64_t v6 = *(unsigned int *)(a2 + 8);
  unint64_t v7 = v4;
  if (v6)
  {
    unint64_t v8 = *(uint64_t **)a2;
    uint64_t v9 = 8 * v6;
    while ((sub_1CD333588(*v8) & 1) != 0)
    {
      ++v8;
      v9 -= 8;
      if (!v9)
      {
        uint64_t v10 = *(unsigned int *)(a2 + 8);
        unint64_t v7 = v4;
        if (v10)
        {
          unsigned int v11 = *(llvm ***)a2;
          uint64_t v12 = *(void *)a2 + 8 * v10;
          unint64_t v7 = v4;
          do
          {
            uint64_t v13 = *v11;
            if (*v11) {
              BOOL v14 = *((unsigned __int8 *)*v11 + 16) >= 0x1Cu;
            }
            else {
              BOOL v14 = 0;
            }
            if (v14)
            {
              uint64_t v15 = *((void *)v7 + 5);
              int v16 = *(__int16 *)(v15 + 18);
              if ((v16 & 0x80000000) == 0)
              {
                uint64_t v17 = *(void *)(v15 + 48);
                if (v17 != v15 + 40)
                {
                  int v18 = 0;
                  do
                  {
                    uint64_t v19 = v17 - 24;
                    if (!v17) {
                      uint64_t v19 = 0;
                    }
                    *(_DWORD *)(v19 + 56) = v18++;
                    uint64_t v17 = *(void *)(v17 + 8);
                  }
                  while (v17 != v15 + 40);
                }
                *(_WORD *)(v15 + 18) = v16 | 0x8000;
              }
              if (*((_DWORD *)v7 + 14) < *((_DWORD *)v13 + 14)) {
                unint64_t v7 = v13;
              }
            }
            ++v11;
          }
          while (v11 != (llvm **)v12);
        }
        goto LABEL_49;
      }
    }
    uint64_t v27 = *(unsigned int *)(a2 + 8);
    unint64_t v7 = v4;
    if (v27)
    {
      int v28 = *(llvm ***)a2;
      uint64_t v29 = *(void *)a2 + 8 * v27;
      unint64_t v7 = v4;
      do
      {
        unsigned int v30 = *v28;
        if (*v28) {
          BOOL v31 = *((unsigned __int8 *)*v28 + 16) >= 0x1Cu;
        }
        else {
          BOOL v31 = 0;
        }
        if (v31)
        {
          uint64_t v32 = *((void *)v30 + 5);
          int v33 = *(__int16 *)(v32 + 18);
          if ((v33 & 0x80000000) == 0)
          {
            uint64_t v34 = *(void *)(v32 + 48);
            if (v34 != v32 + 40)
            {
              int v35 = 0;
              do
              {
                uint64_t v36 = v34 - 24;
                if (!v34) {
                  uint64_t v36 = 0;
                }
                *(_DWORD *)(v36 + 56) = v35++;
                uint64_t v34 = *(void *)(v34 + 8);
              }
              while (v34 != v32 + 40);
            }
            *(_WORD *)(v32 + 18) = v33 | 0x8000;
          }
          if (*((_DWORD *)v30 + 14) < *((_DWORD *)v7 + 14)) {
            unint64_t v7 = v30;
          }
        }
        ++v28;
      }
      while (v28 != (llvm **)v29);
    }
  }
LABEL_49:
  uint64_t v37 = a1 + 2008;
  sub_1CBF5385C(v37, v5, (uint64_t)v7 + 24);
  uint64_t v38 = (unsigned __int8 *)*((void *)v4 + 6);
  uint64_t v80 = v38;
  if (v38)
  {
    llvm::MetadataTracking::track((uint64_t)&v80, v38, 2);
    uint64_t v39 = (uint64_t)v80;
  }
  else
  {
    uint64_t v39 = 0;
  }
  uint64_t result = sub_1CB8461A4(v37, 0, v39);
  unsigned int v41 = v80;
  if (!v80) {
    return result;
  }
  int v42 = *v80;
  if ((v42 - 4) > 0x1E)
  {
    if ((v42 - 3) >= 0xFFFFFFFE) {
      unsigned int v45 = v80;
    }
    else {
      unsigned int v45 = 0;
    }
    if ((v42 - 3) >= 0xFFFFFFFE)
    {
      unint64_t v44 = (unint64_t)(v45 + 8);
LABEL_64:
      BOOL v46 = &v80;
LABEL_137:
      uint64_t v82 = v46;
      return sub_1CC5FA668(v44 + 16, &v82);
    }
    goto LABEL_138;
  }
  if ((v80[1] & 0x7F) == 2 || *((_DWORD *)v80 + 3))
  {
    uint64_t v43 = *((void *)v80 + 2);
    if ((v43 & 4) != 0)
    {
      unint64_t v44 = v43 & 0xFFFFFFFFFFFFFFF8;
      if (v44) {
        goto LABEL_64;
      }
    }
  }
  return result;
}

uint64_t sub_1CD333508(llvm **a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v2 = a1;
  uint64_t v3 = 8 * a2;
  uint64_t v4 = 8 * a2;
  for (uint64_t i = (uint64_t *)a1; (sub_1CD333588(*i) & 1) != 0; ++i)
  {
    v4 -= 8;
    if (!v4) {
      return 1;
    }
  }
  uint64_t v8 = v3 - 8;
  do
  {
    uint64_t v9 = *v2++;
    uint64_t result = sub_1CD34172C(v9, v6);
    if (result) {
      BOOL v10 = v8 == 0;
    }
    else {
      BOOL v10 = 1;
    }
    v8 -= 8;
  }
  while (!v10);
  return result;
}

uint64_t sub_1CD333588(uint64_t a1)
{
  uint64_t result = 1;
  if (!a1) {
    return result;
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 16);
  if (v3 < 0x1C) {
    return result;
  }
  uint64_t v4 = v3 - 33;
  if (v4 > 0x37) {
    goto LABEL_7;
  }
  if (((1 << (v3 - 33)) & 0x8000000000041) != 0)
  {
    uint64_t v15 = *(void *)(a1 + 64);
    if (!v15 || (*(unsigned char *)(v15 + 20) & 4) == 0 && (*(unsigned char *)(v15 + 17) & 0x10) == 0)
    {
      __int32 v28 = 7;
      if (sub_1CC5CB59C(a1, &v28, 1uLL))
      {
        uint64_t v18 = *(void *)(a1 - 32);
        if (!v18 || *(unsigned char *)(v18 + 16) || *(void *)(v18 + 24) != *(void *)(a1 + 72) || *(_DWORD *)(v18 + 36) != 7) {
          return 0;
        }
      }
      if ((llvm::CallBase::hasFnAttrOnCalledFunction(a1, 66) & 1) == 0)
      {
        uint64_t result = llvm::CallBase::hasFnAttrOnCalledFunction(a1, 44);
        if (!result) {
          return result;
        }
      }
    }
    goto LABEL_33;
  }
  if (((1 << (v3 - 33)) & 0x808001C8000010) != 0) {
    return 0;
  }
  if (v4 == 28)
  {
    if ((*(_WORD *)(a1 + 18) & 0x301) != 0) {
      return 0;
    }
LABEL_33:
    unsigned int v3 = *(unsigned __int8 *)(a1 + 16);
  }
LABEL_7:
  uint64_t v5 = v3 - 33;
  if (v5 > 0x37)
  {
LABEL_11:
    uint64_t v6 = *(void *)(a1 + 8);
    if (!v6) {
      return 1;
    }
    int v7 = -7;
    uint64_t v8 = *(void *)(a1 + 8);
    do
    {
      int v9 = v7;
      if (!v7) {
        break;
      }
      uint64_t v8 = *(void *)(v8 + 8);
      ++v7;
    }
    while (v8);
    if (v9)
    {
      while (1)
      {
        uint64_t v10 = *(void *)(v6 + 24);
        unsigned int v11 = *(unsigned __int8 *)(v10 + 16);
        if (v10 && v11 >= 0x1C)
        {
          uint64_t v13 = *(void *)(v10 + 40);
          if (v11 != 83 && v13 == *(void *)(a1 + 40)) {
            break;
          }
        }
        uint64_t v6 = *(void *)(v6 + 8);
        if (!v6) {
          return 1;
        }
      }
    }
    return 0;
  }
  if (((1 << v5) & 0x8000000000041) == 0)
  {
    if (v5 == 27)
    {
      if ((*(_WORD *)(a1 + 18) & 0x301) == 0) {
        goto LABEL_11;
      }
    }
    else if (((1 << v5) & 0x808001D0000010) == 0)
    {
      goto LABEL_11;
    }
    return 0;
  }
  uint64_t v16 = *(void *)(a1 + 64);
  if (v16 && (*(unsigned char *)(v16 + 17) & 0x30) != 0) {
    goto LABEL_11;
  }
  int v17 = *(_DWORD *)(a1 + 20);
  if (v17 < 0)
  {
    uint64_t v19 = a1 - 32 * (v17 & 0x7FFFFFF);
    uint64_t v22 = *(void *)(v19 - 8);
    uint64_t v20 = v19 - 8;
    uint64_t v21 = v22;
    if (v22)
    {
      uint64_t v23 = -v21;
      do
      {
        unsigned int v24 = *(_DWORD *)(*(void *)(v20 + v23) + 8);
        BOOL v25 = v24 > 7;
        int v26 = (1 << v24) & 0x83;
        if (v25 || v26 == 0) {
          return 0;
        }
        v23 += 16;
      }
      while (v23);
    }
  }
  if (llvm::CallBase::hasFnAttrOnCalledFunction(a1, 45)) {
    goto LABEL_11;
  }
  uint64_t result = llvm::CallBase::hasFnAttrOnCalledFunction(a1, 44);
  if (result) {
    goto LABEL_11;
  }
  return result;
}

unsigned __int8 *llvm::slpvectorizer::BoUpSLP::gather(uint64_t a1, llvm::FixedVectorType ***a2, llvm::Type *a3)
{
  v103[4] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = v98;
  uint64_t v95 = 0;
  uint64_t v96 = v98;
  uint64_t v97 = 0x400000000;
  int v7 = v92;
  __int32 v90 = v92;
  uint64_t v91 = 0x400000000;
  uint64_t v93 = &v94;
  unint64_t v94 = 0;
  uint64_t v8 = *(uint64_t **)(a1 + 1952);
  int v9 = *((_DWORD *)v8 + 4);
  if (!v9)
  {
LABEL_7:
    uint64_t v17 = 0;
    goto LABEL_8;
  }
  uint64_t v10 = *(void *)(a1 + 2056);
  uint64_t v11 = *v8;
  unsigned int v12 = v9 - 1;
  uint64_t v13 = ((v10 >> 4) ^ (v10 >> 9)) & (v9 - 1);
  uint64_t v14 = *(void *)(v11 + 16 * v13);
  if (v10 != v14)
  {
    int v15 = 1;
    while (v14 != -4096)
    {
      int v16 = v13 + v15++;
      uint64_t v13 = v16 & v12;
      uint64_t v14 = *(void *)(v11 + 16 * v13);
      if (v10 == v14) {
        goto LABEL_6;
      }
    }
    goto LABEL_7;
  }
LABEL_6:
  uint64_t v17 = *(void *)(v11 + 16 * v13 + 8);
LABEL_8:
  int v89 = 0;
  if ((int)a3 < 1) {
    goto LABEL_101;
  }
  int v18 = 0;
  uint64_t v85 = a1 + 80;
  int v86 = (unsigned int *)(v17 + 76);
  uint64_t v82 = (unsigned int *)(v17 + 72);
  uint64_t v87 = v17;
  do
  {
    uint64_t v19 = (uint64_t)a2[v18];
    if (v19) {
      BOOL v20 = *(unsigned __int8 *)(v19 + 16) >= 0x1Cu;
    }
    else {
      BOOL v20 = 0;
    }
    if (!v20) {
      goto LABEL_14;
    }
    uint64_t v21 = *(llvm::BasicBlock **)(v19 + 40);
    uint64_t v22 = *(llvm::BasicBlock **)(a1 + 2056);
    uint64_t v99 = v103;
    uint64_t v100 = (uint64_t)v103;
    uint64_t v101 = 4;
    int v102 = 0;
    BOOL v23 = v22 != 0;
    unint64_t v88 = v21;
    BOOL v24 = v22 == v21;
    BOOL v25 = v22 == v21 || v22 == 0;
    if (v25) {
      goto LABEL_64;
    }
    uint64_t v83 = v7;
    uint64_t v84 = v6;
    unsigned int v26 = 4;
    uint64_t v27 = v103;
    while (1)
    {
      uint64_t v28 = HIDWORD(v101);
      if (v27 != v99) {
        goto LABEL_31;
      }
      if (HIDWORD(v101)) {
        break;
      }
LABEL_29:
      if (HIDWORD(v101) < v26)
      {
        ++HIDWORD(v101);
        v27[v28] = (uint64_t)v22;
        goto LABEL_51;
      }
LABEL_31:
      if (3 * v26 <= 4 * (HIDWORD(v101) - v102))
      {
        if (v26 >= 0x40) {
          v26 *= 2;
        }
        else {
          unsigned int v26 = 128;
        }
LABEL_59:
        llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v99, v26);
        unsigned int v26 = v101;
        uint64_t v27 = (uint64_t *)v100;
        goto LABEL_33;
      }
      if (v26 - HIDWORD(v101) < v26 >> 3) {
        goto LABEL_59;
      }
LABEL_33:
      unsigned int v32 = v26 - 1;
      unsigned int v33 = (v26 - 1) & ((v22 >> 4) ^ (v22 >> 9));
      uint64_t v34 = (llvm::BasicBlock **)&v27[v33];
      int v35 = *v34;
      if (*v34 != (llvm::BasicBlock *)-1)
      {
        uint64_t v36 = 0;
        int v37 = 1;
        while (v35 != v22)
        {
          if (v36) {
            BOOL v38 = 0;
          }
          else {
            BOOL v38 = v35 == (llvm::BasicBlock *)-2;
          }
          if (v38) {
            uint64_t v36 = v34;
          }
          unsigned int v39 = v33 + v37++;
          unsigned int v33 = v39 & v32;
          uint64_t v34 = (llvm::BasicBlock **)&v27[v39 & v32];
          int v35 = *v34;
          if (*v34 == (llvm::BasicBlock *)-1) {
            goto LABEL_45;
          }
        }
        goto LABEL_60;
      }
      uint64_t v36 = 0;
LABEL_45:
      if (v36) {
        uint64_t v34 = v36;
      }
      if (*v34 == v22) {
        goto LABEL_60;
      }
      if (*v34 == (llvm::BasicBlock *)-2) {
        --v102;
      }
      else {
        ++HIDWORD(v101);
      }
      *uint64_t v34 = v22;
LABEL_51:
      uint64_t v27 = (uint64_t *)v100;
      uint64_t SinglePredecessor = llvm::BasicBlock::getSinglePredecessor(v22);
      BOOL v23 = SinglePredecessor != 0;
      BOOL v24 = SinglePredecessor == (void)v88;
      if ((llvm::BasicBlock *)SinglePredecessor != v88)
      {
        uint64_t v22 = (llvm::BasicBlock *)SinglePredecessor;
        if (SinglePredecessor) {
          continue;
        }
      }
      goto LABEL_61;
    }
    uint64_t v29 = 0;
    unsigned int v30 = 0;
    while (1)
    {
      BOOL v31 = (llvm::BasicBlock *)v27[v29];
      if (v31 == v22) {
        break;
      }
      if (v31 == (llvm::BasicBlock *)-2) {
        unsigned int v30 = (llvm::BasicBlock **)&v27[v29];
      }
      if (HIDWORD(v101) == ++v29)
      {
        if (!v30) {
          goto LABEL_29;
        }
        llvm *v30 = v22;
        --v102;
        goto LABEL_51;
      }
    }
LABEL_60:
    BOOL v24 = 0;
LABEL_61:
    if (v27 != v99) {
      free(v27);
    }
    int v7 = v83;
    uint64_t v6 = v84;
LABEL_64:
    if (v24 && v23) {
      goto LABEL_66;
    }
    uint64_t v99 = 0;
    if (sub_1CD4C64C4(v85, v19, &v99))
    {
      if (v99[1]) {
        goto LABEL_66;
      }
    }
    if (v87)
    {
      uint64_t v44 = *(void *)(v19 + 40);
      uint64_t v46 = *(void *)(v87 + 56);
      uint64_t v45 = *(void *)(v87 + 64);
      if (v45 == v46)
      {
        uint64_t v47 = *v86;
        uint64_t v48 = (void *)(v45 + 8 * v47);
        if (v47)
        {
          uint64_t v49 = 0;
          uint64_t v50 = 8 * v47;
          while (*(void *)(v45 + v49) != v44)
          {
            v49 += 8;
            if (v50 == v49) {
              goto LABEL_90;
            }
          }
          uint64_t v48 = (void *)(v45 + v49);
        }
LABEL_90:
        uint64_t v46 = *(void *)(v87 + 64);
      }
      else
      {
        uint64_t v51 = *v82;
        int v52 = v51 - 1;
        unsigned int v53 = (v51 - 1) & ((v44 >> 4) ^ (v44 >> 9));
        uint64_t v48 = (void *)(v45 + 8 * v53);
        uint64_t v54 = *v48;
        if (*v48 == -1)
        {
          uint64_t v55 = 0;
LABEL_96:
          if (v55) {
            uint64_t v48 = v55;
          }
          if (*v48 != v44) {
            uint64_t v48 = (void *)(v45 + 8 * v51);
          }
        }
        else
        {
          uint64_t v55 = 0;
          int v56 = 1;
          while (v54 != v44)
          {
            if (v55) {
              BOOL v57 = 0;
            }
            else {
              BOOL v57 = v54 == -2;
            }
            if (v57) {
              uint64_t v55 = v48;
            }
            unsigned int v58 = v53 + v56++;
            unsigned int v53 = v58 & v52;
            uint64_t v48 = (void *)(v45 + 8 * (v58 & v52));
            uint64_t v54 = *v48;
            if (*v48 == -1) {
              goto LABEL_96;
            }
          }
        }
      }
      BOOL v25 = v45 == v46;
      unsigned int v59 = v86;
      if (!v25) {
        unsigned int v59 = v82;
      }
      if (v48 != (void *)(v45 + 8 * *v59))
      {
LABEL_66:
        if ((sub_1CD8DEA84((uint64_t)&v90, &v89) & 0x100000000) != 0)
        {
          int v41 = v89;
          int v42 = v97;
          if (v97 >= HIDWORD(v97)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          uint64_t v43 = (char *)v96 + 16 * v97;
          *(void *)uint64_t v43 = v19;
          *((_DWORD *)v43 + 2) = v41;
          LODWORD(v97) = v42 + 1;
        }
      }
    }
LABEL_14:
    int v18 = v89 + 1;
    int v89 = v18;
  }
  while (v18 < (int)a3);
LABEL_101:
  uint64_t v60 = *a2;
  if (*((unsigned char *)*a2 + 16) == 61) {
    uint64_t v60 = (llvm::FixedVectorType **)*(v60 - 8);
  }
  llvm::FixedVectorType::get(*v60, a3);
  int v63 = (unsigned __int8 *)llvm::PoisonValue::get(v61, v62);
  uint64_t v99 = &v101;
  uint64_t v100 = 0xC00000000;
  if ((int)a3 >= 1)
  {
    uint64_t v64 = 0;
    while (1)
    {
      if (v95)
      {
        uint64_t v65 = v94;
        uint64_t v66 = &v94;
        if (v94)
        {
          do
          {
            uint64_t v67 = v66;
            uint64_t v68 = v65;
            uint64_t v69 = *((int *)v65 + 7);
            uint64_t v70 = v65 + 1;
            if (v64 <= v69)
            {
              uint64_t v70 = v68;
              uint64_t v66 = (void **)v68;
            }
            uint64_t v65 = (void *)*v70;
          }
          while (v65);
          if (v66 != &v94)
          {
            if (v64 <= v69) {
              uint64_t v67 = (void **)v68;
            }
            if (v64 >= *((int *)v67 + 7)) {
              goto LABEL_128;
            }
          }
        }
      }
      else if (v91)
      {
        uint64_t v71 = v90;
        uint64_t v72 = 4 * v91;
        while (v64 != *v71)
        {
          ++v71;
          v72 -= 4;
          if (!v72) {
            goto LABEL_121;
          }
        }
        if (v72) {
          goto LABEL_128;
        }
      }
LABEL_121:
      uint64_t v73 = (unsigned __int8 *)a2[v64];
      int v74 = v73[16];
      if (v74 == 5 || (v74 - 4) >= 0x11)
      {
        if (v100 >= (unint64_t)HIDWORD(v100)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((_DWORD *)v99 + v100) = v64;
        LODWORD(v100) = v100 + 1;
      }
      else
      {
        int v63 = (unsigned __int8 *)sub_1CD333F28(a1, v63, (const llvm::APInt *)v73, v64);
      }
LABEL_128:
      if (++v64 == a3)
      {
        if (v100)
        {
          uint64_t v76 = v99;
          uint64_t v77 = 4 * v100;
          do
          {
            uint64_t v78 = *(int *)v76;
            uint64_t v76 = (uint64_t *)((char *)v76 + 4);
            int v63 = (unsigned __int8 *)sub_1CD333F28(a1, v63, (const llvm::APInt *)a2[v78], v78);
            v77 -= 4;
          }
          while (v77);
        }
        break;
      }
    }
  }
  if (v97)
  {
    uint64_t v79 = (char *)v96;
    uint64_t v80 = (char *)v96 + 16 * v97;
    do
    {
      int v63 = (unsigned __int8 *)sub_1CD333F28(a1, v63, *(const llvm::APInt **)v79, *((_DWORD *)v79 + 2));
      v79 += 16;
    }
    while (v79 != v80);
  }
  if (v99 != &v101) {
    free(v99);
  }
  sub_1CD3C5048((uint64_t)&v93, v94);
  if (v90 != v7) {
    free(v90);
  }
  if (v96 != v6) {
    free(v96);
  }
  return v63;
}

uint64_t sub_1CD333F28(uint64_t a1, unsigned __int8 *a2, const llvm::APInt *a3, unsigned int a4)
{
  uint64_t v7 = a1 + 2008;
  uint64_t v8 = **(void **)(a1 + 2072);
  int v9 = *(llvm::ConstantInt **)(v8 + 1960);
  unint64_t v10 = *(unsigned int *)(v8 + 1968);
  unsigned int v19 = v10 >> 8;
  if (v10 >> 8 > 0x40) {
    llvm::APInt::initSlowCase((llvm::APInt *)&v18);
  }
  if (v10 <= 0xFF) {
    int v11 = 0;
  }
  else {
    int v11 = 0xFFFFFFFFFFFFFFFFLL >> -BYTE1(v10);
  }
  int v18 = (llvm::Instruction *)(v11 & a4);
  unsigned int v12 = (unsigned __int8 *)llvm::ConstantInt::get(v9, (llvm::LLVMContext *)&v18, a3);
  if (v19 >= 0x41 && v18) {
    MEMORY[0x1D25D9CB0](v18, 0x1000C8000313F17);
  }
  __int16 v20 = 257;
  uint64_t v13 = sub_1CB84478C(v7, a2, (unsigned __int8 *)a3, v12, (uint64_t)&v18);
  uint64_t v14 = (uint64_t)v13;
  if (v13)
  {
    if (*((unsigned char *)v13 + 16) == 90)
    {
      int v18 = v13;
      sub_1CC27C13C((void *)(a1 + 1760), &v18);
      int v18 = *(llvm::Instruction **)(v14 + 40);
      sub_1CBB239A4(a1 + 1808, &v18);
      int v18 = 0;
      if (sub_1CD4C64C4(a1 + 80, (uint64_t)a3, &v18))
      {
        uint64_t v16 = *((void *)v18 + 1);
        if (v16)
        {
          int v17 = sub_1CD8DD454(v16, (uint64_t)a3);
          sub_1CD49C354(a1 + 1072, (uint64_t)a3, v14, v17);
        }
      }
    }
  }
  return v14;
}

llvm::PoisonValue **llvm::slpvectorizer::BoUpSLP::vectorizeTree(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1;
  v538[4] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (uint64_t *)(a1 + 2008);
  uint64_t v512 = a1 + 2008;
  long long v513 = *(_OWORD *)(a1 + 2056);
  uint64_t v5 = &v514;
  uint64_t v6 = *(unsigned int *)(a1 + 2016);
  if (v6)
  {
    unint64_t v218 = (unsigned __int8 **)(*(void *)(a1 + 2008) + 8);
    uint64_t v219 = 16 * v6;
    while (*((_DWORD *)v218 - 2))
    {
      v218 += 2;
      v219 -= 16;
      if (!v219) {
        goto LABEL_2;
      }
    }
    int v220 = *v218;
    uint64_t v514 = v220;
    if (v220) {
      llvm::MetadataTracking::track((uint64_t)&v514, v220, 2);
    }
  }
  else
  {
LABEL_2:
    uint64_t v514 = 0;
  }
  uint64_t v7 = *(llvm::PoisonValue ***)(a2 + 80);
  if (v7) {
    goto LABEL_80;
  }
  int v8 = *(_DWORD *)(a2 + 104);
  int v9 = v8;
  if (!v8) {
    int v9 = *(_DWORD *)(a2 + 8);
  }
  unint64_t v10 = (void *)(v3 + 1760);
  int v11 = (llvm::Instruction *)(v3 + 1808);
  uint64_t v534 = v4;
  int v535 = v9;
  char v536 = 0;
  *(void *)uint64_t v504 = v537;
  uint64_t v505 = v538;
  v537[0] = v538;
  v537[1] = (void *)0x400000000;
  v538[2] = v3 + 1760;
  v538[3] = v3 + 1808;
  unsigned int v12 = *(void ***)(a2 + 384);
  if (*(_DWORD *)(a2 + 88) == 2)
  {
    if (v12) {
      llvm::slpvectorizer::BoUpSLP::setInsertPointAfterBundle(v3, a2);
    }
    __b = &v517;
    *(void *)uint64_t v516 = 0xC00000000;
    unint64_t v520 = &v522;
    unint64_t v521 = (void *)0x600000000;
    if ((unint64_t)llvm::slpvectorizer::BoUpSLP::isGatherShuffledEntry(v3, a2, (char **)&__b, (uint64_t *)&v520) >> 32)
    {
      uint64_t v16 = *(void *)(*(void *)v520 + 80);
      uint64_t v17 = *(void *)(*((void *)v520 + v521 - 1) + 80);
      __int16 v533 = 257;
      int v18 = sub_1CB935A74((uint64_t)v4, v16, v17, __b, (llvm::Type *)v516[0], (uint64_t)&v529);
      uint64_t v13 = (llvm::PoisonValue **)v18;
      if (*((unsigned __int8 *)v18 + 16) <= 0x1Bu) {
        unsigned int v19 = 0;
      }
      else {
        unsigned int v19 = (void **)v18;
      }
      uint64_t v529 = v19;
      if (v19)
      {
        sub_1CC27C13C(v10, &v529);
        v525 = v529[5];
        sub_1CBB239A4((uint64_t)v11, &v525);
      }
    }
    else
    {
      uint64_t v13 = (llvm::PoisonValue **)llvm::slpvectorizer::BoUpSLP::gather(v3, *(llvm::FixedVectorType ****)a2, (llvm::Type *)*(unsigned int *)(a2 + 8));
    }
    uint64_t v5 = &v514;
    if (v8)
    {
      sub_1CD324BD0(*(_DWORD **)v504, *(int **)(a2 + 96), *(unsigned int *)(a2 + 104));
      uint64_t v13 = sub_1CD3376B4((uint64_t)&v534, v13);
    }
    *(void *)(a2 + 80) = v13;
    if (v520 != &v522) {
      free(v520);
    }
    uint64_t v506 = v13;
    goto LABEL_23;
  }
  int v14 = *((unsigned __int8 *)v12 + 16);
  if (v12 == *(void ***)(a2 + 392)) {
    uint64_t v15 = (v14 - 28);
  }
  else {
    uint64_t v15 = 63;
  }
  if (v14 == 90 || (uint64_t v21 = *(llvm::FixedVectorType ***)(a2 + 384), v14 == 61)) {
    uint64_t v21 = (llvm::FixedVectorType **)*(v12 - 8);
  }
  llvm::FixedVectorType::get(*v21, (llvm::Type *)*(unsigned int *)(a2 + 8));
  int v507 = v12;
  switch((int)v15)
  {
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
      llvm::slpvectorizer::BoUpSLP::setInsertPointAfterBundle(v3, a2);
      BOOL v24 = llvm::slpvectorizer::BoUpSLP::vectorizeTree(v3, **(uint64_t ***)(a2 + 208), *(unsigned int *)(*(void *)(a2 + 208) + 8));
      BOOL v25 = llvm::slpvectorizer::BoUpSLP::vectorizeTree(v3, *(uint64_t **)(*(void *)(a2 + 208) + 80), *(unsigned int *)(*(void *)(a2 + 208) + 88));
      uint64_t v506 = *(llvm::PoisonValue ***)(a2 + 80);
      if (v506) {
        goto LABEL_77;
      }
      uint64_t v26 = *(void *)(a2 + 384);
      if (v26) {
        uint64_t v27 = *(unsigned __int8 *)(v26 + 16) - 28;
      }
      else {
        uint64_t v27 = 0;
      }
      v519[0] = 257;
      Select = (unsigned __int8 *)sub_1CB844E98((uint64_t)v4, v27, (uint64_t)v24, (uint64_t)v25, (uint64_t)&__b, 0);
      llvm::propagateIRFlags((uint64_t)Select, *(uint64_t **)a2, *(unsigned int *)(a2 + 8), (uint64_t)v507);
      if (Select && Select[16] >= 0x1Cu) {
        llvm::propagateMetadata((llvm *)Select, *(llvm::MDNode ***)a2, *(unsigned int *)(a2 + 8));
      }
      goto LABEL_36;
    case 31:
    case 35:
    case 36:
    case 37:
    case 50:
    case 51:
    case 52:
    case 58:
    case 59:
    case 60:
      __break(1u);
      goto LABEL_764;
    case 32:
      uint64_t v271 = (llvm::UndefValue *)v22;
      llvm::slpvectorizer::BoUpSLP::setInsertPointAfterBundle(v3, a2);
      uint64_t v272 = (unsigned __int8 *)*(v12 - 4);
      unsigned int v273 = *(_DWORD *)(*(void *)v272 + 8);
      if ((v273 & 0xFE) == 0x12) {
        unsigned int v273 = *(_DWORD *)(**(void **)(*(void *)v272 + 16) + 8);
      }
      if (*(_DWORD *)(a2 + 88))
      {
        unsigned int v321 = (uint64_t *)llvm::slpvectorizer::BoUpSLP::vectorizeTree(v3, **(uint64_t ***)(a2 + 208), *(unsigned int *)(*(void *)(a2 + 208) + 8));
        unsigned __int8 v322 = __clz(1 << ((unint64_t)*((unsigned __int16 *)v12 + 9) >> 1)) ^ 0x3F;
        uint64_t v323 = *(unsigned int *)(a2 + 8);
        if (v323)
        {
          unint64_t v374 = *(llvm::FixedVectorType ****)a2;
          uint64_t v375 = 8 * v323;
          v324 = *(_DWORD **)v504;
          do
          {
            uint64_t v376 = (uint64_t)*v374++;
            unsigned int v377 = __clz(1 << ((unint64_t)*(unsigned __int16 *)(v376 + 18) >> 1)) ^ 0x3F;
            if (v377 < v322) {
              unsigned __int8 v322 = v377;
            }
            v375 -= 8;
          }
          while (v375);
        }
        else
        {
          v324 = *(_DWORD **)v504;
        }
        v519[0] = 257;
        MaskedGather = (llvm::Instruction *)llvm::IRBuilderBase::CreateMaskedGather((uint64_t)v4, v271, v321, v322, 0, 0, (uint64_t)&__b);
      }
      else
      {
        unint64_t v274 = llvm::PointerType::get(v271, (llvm::Type *)(v273 >> 8));
        v524[0] = 257;
        unsigned int v275 = v272;
        if (*(void *)v272 != v274)
        {
          if (v272[16] <= 0x14u)
          {
            unsigned int v275 = (unsigned __int8 *)(*(uint64_t (**)(void, uint64_t, unsigned __int8 *, unint64_t))(**(void **)(v3 + 2080) + 224))(*(void *)(v3 + 2080), 49, v272, v274);
            if (v275) {
              BOOL v386 = v275[16] >= 0x1Cu;
            }
            else {
              BOOL v386 = 0;
            }
            if (v386)
            {
              (*(void (**)(void, unsigned __int8 *, void **, void, void))(**(void **)(v3 + 2088)
                                                                                         + 16))(*(void *)(v3 + 2088), v275, &v520, *(void *)(v3 + 2056), *(void *)(v3 + 2064));
              uint64_t v484 = v3;
              uint64_t v485 = *(unsigned int *)(v3 + 2016);
              if (v485)
              {
                uint64_t v492 = *(void *)(v3 + 2008);
                uint64_t v493 = v492 + 16 * v485;
                do
                {
                  llvm::Instruction::setMetadata((llvm::Instruction *)v275, *(_DWORD *)v492, *(llvm::MDNode **)(v492 + 8));
                  v492 += 16;
                }
                while (v492 != v493);
              }
              uint64_t v3 = v484;
              unsigned int v12 = v507;
            }
          }
          else
          {
            v519[0] = 257;
            unsigned int v275 = (unsigned __int8 *)llvm::CastInst::Create(49, (uint64_t)v272, v274, (const char **)&__b, 0);
            (*(void (**)(void, unsigned __int8 *, void **, void, void))(**(void **)(v3 + 2088) + 16))(*(void *)(v3 + 2088), v275, &v520, *(void *)(v3 + 2056), *(void *)(v3 + 2064));
            uint64_t v276 = v3;
            uint64_t v277 = *(unsigned int *)(v3 + 2016);
            if (v277)
            {
              uint64_t v459 = *(void *)(v3 + 2008);
              uint64_t v460 = v459 + 16 * v277;
              do
              {
                llvm::Instruction::setMetadata((llvm::Instruction *)v275, *(_DWORD *)v459, *(llvm::MDNode **)(v459 + 8));
                v459 += 16;
              }
              while (v459 != v460);
            }
            uint64_t v3 = v276;
          }
        }
        unint64_t v387 = *((unsigned __int16 *)v12 + 9);
        v524[0] = 257;
        uint64_t v388 = (v387 >> 1) & 0x3F;
        unsigned int v389 = operator new(0x60uLL);
        v389[13] = v389[13] & 0x38000000 | 1;
        uint64_t v390 = v3;
        MaskedGather = (llvm::Instruction *)(v389 + 8);
        *(void *)unsigned int v389 = 0;
        *((void *)v389 + 1) = 0;
        *((void *)v389 + 2) = 0;
        *((void *)v389 + 3) = v389 + 8;
        v519[0] = 257;
        llvm::LoadInst::LoadInst((llvm::Value *)(v389 + 8), (uint64_t)v271, (uint64_t)v275, (const char **)&__b, 0, v388, 0);
        (*(void (**)(void, llvm::Instruction *, void **, void, void))(**(void **)(v390 + 2088) + 16))(*(void *)(v390 + 2088), MaskedGather, &v520, *(void *)(v390 + 2056), *(void *)(v390 + 2064));
        uint64_t v391 = *(unsigned int *)(v390 + 2016);
        if (v391)
        {
          uint64_t v448 = *(void *)(v390 + 2008);
          uint64_t v449 = v448 + 16 * v391;
          do
          {
            llvm::Instruction::setMetadata(MaskedGather, *(_DWORD *)v448, *(llvm::MDNode **)(v448 + 8));
            v448 += 16;
          }
          while (v448 != v449);
        }
        __b = 0;
        if (sub_1CD4C64C4(v390 + 80, (uint64_t)v272, &__b))
        {
          uint64_t v392 = *((void *)__b + 1);
          uint64_t v5 = &v514;
          if (v392)
          {
            int v393 = sub_1CD8DD454(v392, (uint64_t)v272);
            if (v272 == v275) {
              uint64_t v394 = (uint64_t)MaskedGather;
            }
            else {
              uint64_t v394 = (uint64_t)v275;
            }
            sub_1CD49C354(v390 + 1072, (uint64_t)v272, v394, v393);
          }
        }
        else
        {
          uint64_t v5 = &v514;
        }
        v324 = *(_DWORD **)v504;
      }
      llvm::propagateMetadata(MaskedGather, *(llvm::MDNode ***)a2, *(unsigned int *)(a2 + 8));
      sub_1CD33789C((uint64_t)&v534, *(void *)(a2 + 128), *(unsigned int *)(a2 + 136));
      sub_1CD324BD0(v324, *(int **)(a2 + 96), *(unsigned int *)(a2 + 104));
      BOOL v31 = (llvm::PoisonValue **)MaskedGather;
      goto LABEL_76;
    case 33:
      uint64_t v248 = *(void *)*(v12 - 4);
      unsigned int v249 = *(_DWORD *)(v248 + 8);
      if ((v249 & 0xFE) == 0x12) {
        unsigned int v249 = *(_DWORD *)(**(void **)(v248 + 16) + 8);
      }
      uint64_t v250 = (llvm::Type *)(v249 >> 8);
      llvm::slpvectorizer::BoUpSLP::setInsertPointAfterBundle(v3, a2);
      uint64_t v251 = llvm::slpvectorizer::BoUpSLP::vectorizeTree(v3, **(uint64_t ***)(a2 + 208), *(unsigned int *)(*(void *)(a2 + 208) + 8));
      uint64_t v252 = *(char **)(a2 + 128);
      int v253 = &v252[4 * *(unsigned int *)(a2 + 136)];
      __b = &v517;
      *(void *)uint64_t v516 = 0x400000000;
      sub_1CD462190((uint64_t)&__b, v252, v253);
      sub_1CD324BD0(*(_DWORD **)v504, (int *)__b, v516[0]);
      if (__b != &v517) {
        free(__b);
      }
      uint64_t v254 = sub_1CD3376B4((uint64_t)&v534, v251);
      int v255 = (llvm::Instruction *)*(v507 - 4);
      unint64_t v256 = llvm::PointerType::get(*v254, v250);
      v524[0] = 257;
      unint64_t v257 = v255;
      if (*(void *)v255 != v256)
      {
        if (*((unsigned __int8 *)v255 + 16) <= 0x14u)
        {
          uint64_t v325 = (*(uint64_t (**)(void, uint64_t, llvm::Instruction *, unint64_t))(**(void **)(v3 + 2080) + 224))(*(void *)(v3 + 2080), 49, v255, v256);
          unint64_t v257 = (llvm::Instruction *)v325;
          if (v325 && *(unsigned __int8 *)(v325 + 16) >= 0x1Cu)
          {
            uint64_t v480 = v3;
            v481 = v4;
            (*(void (**)(void, uint64_t, void **, void, void))(**(void **)(v480 + 2088) + 16))(*(void *)(v480 + 2088), v325, &v520, *(void *)(v480 + 2056), *(void *)(v480 + 2064));
            uint64_t v482 = v480;
            uint64_t v483 = *(unsigned int *)(v480 + 2016);
            if (v483)
            {
              uint64_t v490 = *(void *)(v480 + 2008);
              uint64_t v491 = v490 + 16 * v483;
              do
              {
                llvm::Instruction::setMetadata(v257, *(_DWORD *)v490, *(llvm::MDNode **)(v490 + 8));
                v490 += 16;
              }
              while (v490 != v491);
            }
            uint64_t v5 = &v514;
            uint64_t v4 = v481;
            uint64_t v3 = v482;
          }
        }
        else
        {
          unint64_t v258 = v4;
          v519[0] = 257;
          unint64_t v257 = llvm::CastInst::Create(49, (uint64_t)v255, v256, (const char **)&__b, 0);
          (*(void (**)(void, llvm::Instruction *, void **, void, void))(**(void **)(v3 + 2088) + 16))(*(void *)(v3 + 2088), v257, &v520, *(void *)(v3 + 2056), *(void *)(v3 + 2064));
          uint64_t v259 = *(unsigned int *)(v3 + 2016);
          if (v259)
          {
            uint64_t v456 = *(void *)(v3 + 2008);
            uint64_t v457 = v456 + 16 * v259;
            do
            {
              llvm::Instruction::setMetadata(v257, *(_DWORD *)v456, *(llvm::MDNode **)(v456 + 8));
              v456 += 16;
            }
            while (v456 != v457);
          }
          uint64_t v4 = v258;
        }
      }
      BOOL v326 = sub_1CC27BF8C(v4, (uint64_t)v254, (uint64_t)v257, (*((_WORD *)v507 + 9) >> 1) & 0x3F | 0x100u, 0);
      __b = 0;
      if (sub_1CD4C64C4(v3 + 80, (uint64_t)v255, &__b))
      {
        uint64_t v327 = *((void *)__b + 1);
        if (v327)
        {
          int v450 = sub_1CD8DD454(v327, (uint64_t)v255);
          if (v255 == v257) {
            uint64_t v451 = v326;
          }
          else {
            uint64_t v451 = v257;
          }
          __b = v255;
          *(void *)uint64_t v516 = v451;
          LODWORD(v517) = v450;
          unint64_t v452 = sub_1CD483108(v3 + 1072, (unint64_t)&__b);
          uint64_t v453 = *(void *)(v3 + 1072) + 24 * *(unsigned int *)(v3 + 1080);
          long long v454 = *(_OWORD *)v452;
          *(void *)(v453 + 16) = *(void *)(v452 + 16);
          *(_OWORD *)uint64_t v453 = v454;
          ++*(_DWORD *)(v3 + 1080);
        }
      }
      llvm::propagateMetadata(v326, *(llvm::MDNode ***)a2, *(unsigned int *)(a2 + 8));
      uint64_t v506 = (llvm::PoisonValue **)v326;
      *(void *)(a2 + 80) = v326;
      goto LABEL_77;
    case 34:
      llvm::slpvectorizer::BoUpSLP::setInsertPointAfterBundle(v3, a2);
      int v263 = (uint64_t *)llvm::slpvectorizer::BoUpSLP::vectorizeTree(v3, **(uint64_t ***)(a2 + 208), *(unsigned int *)(*(void *)(a2 + 208) + 8));
      __b = &v517;
      *(void *)uint64_t v516 = 0x600000000;
      unsigned int v264 = *((_DWORD *)v12 + 5) & 0x7FFFFFF;
      if (v264 < 2)
      {
        uint64_t v270 = 0;
        v316 = (uint64_t *)&v517;
      }
      else
      {
        uint64_t v265 = v3;
        int v266 = v4;
        uint64_t v267 = 0;
        uint64_t v268 = 80 * v264 - 80;
        do
        {
          uint64_t v269 = llvm::slpvectorizer::BoUpSLP::vectorizeTree(v265, *(uint64_t **)(*(void *)(a2 + 208) + v267 + 80), *(unsigned int *)(*(void *)(a2 + 208) + v267 + 88));
          if (v516[0] >= (unint64_t)v516[1]) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)__b + v516[0]) = v269;
          uint64_t v270 = ++v516[0];
          v267 += 80;
        }
        while (v268 != v267);
        v316 = (uint64_t *)__b;
        uint64_t v4 = v266;
      }
      uint64_t v317 = (uint64_t)v12[8];
      v524[0] = 257;
      v318 = (unsigned __int8 *)sub_1CC27CEC0(v4, v317, v263, v316, v270, (uint64_t)&v520);
      unsigned int v319 = (llvm::PoisonValue **)v318;
      if (v318) {
        BOOL v320 = v318[16] >= 0x1Cu;
      }
      else {
        BOOL v320 = 0;
      }
      if (v320) {
        llvm::propagateMetadata((llvm *)v318, *(llvm::MDNode ***)a2, *(unsigned int *)(a2 + 8));
      }
      sub_1CD33789C((uint64_t)&v534, *(void *)(a2 + 128), *(unsigned int *)(a2 + 136));
      sub_1CD324BD0(*(_DWORD **)v504, *(int **)(a2 + 96), *(unsigned int *)(a2 + 104));
      uint64_t v506 = sub_1CD3376B4((uint64_t)&v534, v319);
      *(void *)(a2 + 80) = v506;
      __int16 v20 = __b;
      if (__b == &v517) {
        goto LABEL_77;
      }
      goto LABEL_24;
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
      uint64_t v50 = (uint64_t)v22;
      llvm::slpvectorizer::BoUpSLP::setInsertPointAfterBundle(v3, a2);
      uint64_t v51 = llvm::slpvectorizer::BoUpSLP::vectorizeTree(v3, **(uint64_t ***)(a2 + 208), *(unsigned int *)(*(void *)(a2 + 208) + 8));
      uint64_t v506 = *(llvm::PoisonValue ***)(a2 + 80);
      if (v506) {
        goto LABEL_77;
      }
      int v52 = (llvm::Instruction *)v51;
      int v53 = *((unsigned __int8 *)v507 + 16);
      v524[0] = 257;
      if (*v51 == (llvm::PoisonValue *)v50) {
        goto LABEL_391;
      }
      uint64_t v54 = v50;
      uint64_t v55 = (v53 - 28);
      if (*((unsigned __int8 *)v51 + 16) <= 0x14u)
      {
        uint64_t v235 = v3;
        uint64_t v236 = (*(uint64_t (**)(void, uint64_t, llvm::PoisonValue **, uint64_t))(**(void **)(v3 + 2080)
                                                                                         + 224))(*(void *)(v3 + 2080), v55, v51, v54);
        int v52 = (llvm::Instruction *)v236;
        uint64_t v58 = a2;
        if (v236 && *(unsigned __int8 *)(v236 + 16) >= 0x1Cu)
        {
          (*(void (**)(void, uint64_t, void **, void, void))(**(void **)(v235 + 2088) + 16))(*(void *)(v235 + 2088), v236, &v520, *(void *)(v235 + 2056), *(void *)(v235 + 2064));
          uint64_t v237 = *(unsigned int *)(v235 + 2016);
          if (v237)
          {
            uint64_t v486 = *(void *)(v235 + 2008);
            uint64_t v487 = v486 + 16 * v237;
            do
            {
              llvm::Instruction::setMetadata(v52, *(_DWORD *)v486, *(llvm::MDNode **)(v486 + 8));
              v486 += 16;
            }
            while (v486 != v487);
          }
LABEL_391:
          uint64_t v58 = a2;
        }
      }
      else
      {
        v519[0] = 257;
        int v52 = llvm::CastInst::Create(v55, (uint64_t)v51, v50, (const char **)&__b, 0);
        (*(void (**)(void, llvm::Instruction *, void **, void, void))(**(void **)(v3 + 2088) + 16))(*(void *)(v3 + 2088), v52, &v520, *(void *)(v3 + 2056), *(void *)(v3 + 2064));
        uint64_t v56 = *(unsigned int *)(v3 + 2016);
        uint64_t v57 = v3;
        uint64_t v58 = a2;
        if (v56)
        {
          uint64_t v59 = *(void *)(v57 + 2008);
          uint64_t v60 = v59 + 16 * v56;
          do
          {
            llvm::Instruction::setMetadata(v52, *(_DWORD *)v59, *(llvm::MDNode **)(v59 + 8));
            v59 += 16;
          }
          while (v59 != v60);
        }
      }
      sub_1CD33789C((uint64_t)&v534, *(void *)(v58 + 128), *(unsigned int *)(v58 + 136));
      sub_1CD324BD0(*(_DWORD **)v504, *(int **)(v58 + 96), *(unsigned int *)(v58 + 104));
      uint64_t v506 = sub_1CD3376B4((uint64_t)&v534, (llvm::PoisonValue **)v52);
      *(void *)(v58 + 80) = v506;
      goto LABEL_77;
    case 53:
    case 54:
      llvm::slpvectorizer::BoUpSLP::setInsertPointAfterBundle(v3, a2);
      uint64_t v231 = llvm::slpvectorizer::BoUpSLP::vectorizeTree(v3, **(uint64_t ***)(a2 + 208), *(unsigned int *)(*(void *)(a2 + 208) + 8));
      unint64_t v232 = llvm::slpvectorizer::BoUpSLP::vectorizeTree(v3, *(uint64_t **)(*(void *)(a2 + 208) + 80), *(unsigned int *)(*(void *)(a2 + 208) + 88));
      uint64_t v506 = *(llvm::PoisonValue ***)(a2 + 80);
      if (v506) {
        goto LABEL_77;
      }
      uint64_t v233 = *((_WORD *)v507 + 9) & 0x3F;
      v519[0] = 257;
      if (v233 > 0xF) {
        FCmpHelper = sub_1CB845F20((uint64_t)v4, v233, v231, (uint64_t)v232, (uint64_t)&__b);
      }
      else {
        FCmpHelper = llvm::IRBuilderBase::CreateFCmpHelper((uint64_t)v4, v233, (uint64_t)v231, (uint64_t)v232, (uint64_t)&__b, 0, 0);
      }
      Select = (unsigned __int8 *)FCmpHelper;
      llvm::propagateIRFlags((uint64_t)FCmpHelper, *(uint64_t **)a2, *(unsigned int *)(a2 + 8), (uint64_t)v507);
      goto LABEL_36;
    case 55:
      unsigned int v32 = (void *)*((void *)v12[5] + 6);
      unsigned int v33 = v32 - 3;
      if (!v32) {
        unsigned int v33 = 0;
      }
      if (*((unsigned char *)v33 + 16) == 83)
      {
        uint64_t v15 = *(void *)v504;
        do
        {
          unsigned int v32 = (void *)v32[1];
          uint64_t v34 = v32 - 3;
          if (!v32) {
            uint64_t v34 = 0;
          }
        }
        while (*((unsigned char *)v34 + 16) == 83);
      }
      else
      {
        uint64_t v15 = *(void *)v504;
      }
      uint64_t v70 = v22;
      *(void *)(v3 + 2056) = v32[2];
      *(void *)(v3 + 2064) = v32;
      uint64_t v71 = (void *)v32[3];
      unint64_t v520 = v71;
      if (v71)
      {
        llvm::MetadataTracking::track((uint64_t)&v520, (unsigned __int8 *)v71, 2);
        uint64_t v72 = v520;
      }
      else
      {
        uint64_t v72 = 0;
      }
      sub_1CB8461A4((uint64_t)v4, 0, (uint64_t)v72);
      if (!v520) {
        goto LABEL_92;
      }
      int v307 = *(unsigned __int8 *)v520;
      if ((v307 - 4) > 0x1E)
      {
        if ((v307 - 3) >= 0xFFFFFFFE) {
          BOOL v338 = v520;
        }
        else {
          BOOL v338 = 0;
        }
        if ((v307 - 3) >= 0xFFFFFFFE)
        {
          unint64_t v309 = (unint64_t)v338 + 8;
LABEL_539:
          __b = &v520;
          sub_1CC5FA668(v309 + 16, &__b);
          goto LABEL_92;
        }
        if (v307 == 3) {
          *((void *)v520 + 1) = 0;
        }
      }
      else if ((*((unsigned char *)v520 + 1) & 0x7F) == 2 || *((_DWORD *)v520 + 3))
      {
        uint64_t v308 = *((void *)v520 + 2);
        if ((v308 & 4) != 0)
        {
          unint64_t v309 = v308 & 0xFFFFFFFFFFFFFFF8;
          if (v309) {
            goto LABEL_539;
          }
        }
      }
LABEL_92:
      uint64_t v73 = (unsigned __int8 *)v12[6];
      v511 = v73;
      if (v73)
      {
        llvm::MetadataTracking::track((uint64_t)&v511, v73, 2);
        uint64_t v74 = (uint64_t)v511;
      }
      else
      {
        uint64_t v74 = 0;
      }
      sub_1CB8461A4((uint64_t)v4, 0, v74);
      uint64_t v75 = (uint64_t)v70;
      if (!v511) {
        goto LABEL_99;
      }
      int v76 = *v511;
      if ((v76 - 4) > 0x1E)
      {
        if ((v76 - 3) >= 0xFFFFFFFE) {
          int v227 = v511;
        }
        else {
          int v227 = 0;
        }
        if ((v76 - 3) < 0xFFFFFFFE)
        {
          if (v76 == 3) {
            *((void *)v511 + 1) = 0;
          }
          goto LABEL_99;
        }
        unint64_t v228 = (unint64_t)(v227 + 8);
      }
      else
      {
        if ((v511[1] & 0x7F) != 2 && !*((_DWORD *)v511 + 3)) {
          goto LABEL_99;
        }
        uint64_t v464 = *((void *)v511 + 2);
        if ((v464 & 4) == 0) {
          goto LABEL_99;
        }
        unint64_t v228 = v464 & 0xFFFFFFFFFFFFFFF8;
        if (!v228) {
          goto LABEL_99;
        }
      }
      __b = &v511;
      sub_1CC5FA668(v228 + 16, &__b);
      uint64_t v75 = (uint64_t)v70;
LABEL_99:
      int v77 = *((_DWORD *)v12 + 5) & 0x7FFFFFF;
      v519[0] = 257;
      int v11 = sub_1CB93113C((uint64_t)v4, v75, v77, (uint64_t)&__b);
      uint64_t v78 = v12[5];
      uint64_t v79 = (char *)(v78 + 5);
      for (uint64_t i = (char *)v78[6]; ; uint64_t i = (char *)*((void *)i + 1))
      {
        if (i == v79) {
          goto LABEL_111;
        }
        uint64_t v80 = i - 24;
        if (!i) {
          uint64_t v80 = 0;
        }
        if (v80[16] != 83) {
          break;
        }
      }
      unsigned int v81 = *(i - 8) - 38;
      BOOL v82 = v81 > 0x38;
      uint64_t v83 = (1 << v81) & 0x100060000000001;
      if (v82 || v83 == 0) {
        uint64_t v79 = i;
      }
      else {
LABEL_764:
      }
        uint64_t v79 = (char *)*((void *)i + 1);
LABEL_111:
      uint64_t v85 = 0;
      if (v79) {
        int v86 = v79 - 24;
      }
      else {
        int v86 = 0;
      }
      *(void *)(v3 + 2056) = *((void *)v86 + 5);
      *(void *)(v3 + 2064) = v86 + 24;
      uint64_t v87 = (void *)*((void *)v86 + 6);
      unint64_t v520 = v87;
      if (v87)
      {
        llvm::MetadataTracking::track((uint64_t)&v520, (unsigned __int8 *)v87, 2);
        uint64_t v85 = v520;
      }
      sub_1CB8461A4((uint64_t)v4, 0, (uint64_t)v85);
      if (!v520)
      {
LABEL_117:
        unint64_t v88 = (unsigned __int8 *)v12[6];
        v510 = v88;
        if (v88)
        {
          llvm::MetadataTracking::track((uint64_t)&v510, v88, 2);
          uint64_t v89 = (uint64_t)v510;
        }
        else
        {
          uint64_t v89 = 0;
        }
        sub_1CB8461A4((uint64_t)v4, 0, v89);
        if (!v510) {
          goto LABEL_124;
        }
        int v90 = *v510;
        if ((v90 - 4) > 0x1E)
        {
          if ((v90 - 3) >= 0xFFFFFFFE) {
            v229 = v510;
          }
          else {
            v229 = 0;
          }
          if ((v90 - 3) < 0xFFFFFFFE)
          {
            if (v90 == 3) {
              *((void *)v510 + 1) = 0;
            }
            goto LABEL_124;
          }
          unint64_t v230 = (unint64_t)(v229 + 8);
        }
        else
        {
          if ((v510[1] & 0x7F) != 2 && !*((_DWORD *)v510 + 3)) {
            goto LABEL_124;
          }
          uint64_t v465 = *((void *)v510 + 2);
          if ((v465 & 4) == 0) {
            goto LABEL_124;
          }
          unint64_t v230 = v465 & 0xFFFFFFFFFFFFFFF8;
          if (!v230) {
            goto LABEL_124;
          }
        }
        __b = &v510;
        sub_1CC5FA668(v230 + 16, &__b);
LABEL_124:
        sub_1CD33789C((uint64_t)&v534, *(void *)(a2 + 128), *(unsigned int *)(a2 + 136));
        sub_1CD324BD0((_DWORD *)v15, *(int **)(a2 + 96), *(unsigned int *)(a2 + 104));
        uint64_t v506 = sub_1CD3376B4((uint64_t)&v534, (llvm::PoisonValue **)v11);
        *(void *)(a2 + 80) = v506;
        unint64_t v520 = v524;
        unint64_t v521 = v524;
        uint64_t v522 = 4;
        int v523 = 0;
        int v91 = *((_DWORD *)v12 + 5);
        uint64_t v92 = v91 & 0x7FFFFFF;
        if ((v91 & 0x7FFFFFF) == 0) {
          goto LABEL_77;
        }
        uint64_t v93 = 0;
        unint64_t v94 = &v517;
        uint64_t v501 = v91 & 0x7FFFFFF;
        uint64_t v502 = a2;
        *(void *)uint64_t v504 = &v517;
        int64_t v499 = &v514;
        *(void *)uint64_t v500 = v4;
        while (1)
        {
          __b = v94;
          *(void *)uint64_t v516 = 0x800000000;
          int v95 = *((_DWORD *)v12 + 5);
          uint64_t v96 = (v95 & 0x40000000) != 0 ? *(v12 - 1) : &v12[-4 * (v95 & 0x7FFFFFF)];
          uint64_t v97 = v96[4 * *((unsigned int *)v12 + 15) + v93];
          uint64_t v98 = (char *)v521;
          uint64_t v99 = HIDWORD(v522);
          if (v521 == v520)
          {
            if (HIDWORD(v522))
            {
              uint64_t v100 = 0;
              uint64_t v101 = 8 * HIDWORD(v522);
              int v102 = (uint64_t *)v521;
              while (*v102 != v97)
              {
                if (*v102 == -2) {
                  uint64_t v100 = v102;
                }
                ++v102;
                v101 -= 8;
                if (!v101)
                {
                  if (!v100) {
                    goto LABEL_137;
                  }
                  *uint64_t v100 = v97;
                  --v523;
                  goto LABEL_161;
                }
              }
              goto LABEL_190;
            }
LABEL_137:
            unsigned int v103 = v522;
            if (HIDWORD(v522) < v522)
            {
              ++HIDWORD(v522);
              *((void *)v521 + v99) = v97;
              goto LABEL_161;
            }
          }
          else
          {
            unsigned int v103 = v522;
          }
          if (3 * v103 <= 4 * (HIDWORD(v522) - v523)) {
            break;
          }
          if (v103 - HIDWORD(v522) < v103 >> 3) {
            goto LABEL_265;
          }
LABEL_142:
          unsigned int v104 = v103 - 1;
          unsigned int v105 = (v103 - 1) & ((v97 >> 4) ^ (v97 >> 9));
          unsigned int v106 = &v98[8 * v105];
          uint64_t v107 = *(void *)v106;
          if (*(void *)v106 != -1)
          {
            BOOL v108 = 0;
            int v109 = 1;
            while (v107 != v97)
            {
              if (v108) {
                BOOL v110 = 0;
              }
              else {
                BOOL v110 = v107 == -2;
              }
              if (v110) {
                BOOL v108 = (uint64_t *)v106;
              }
              unsigned int v111 = v105 + v109++;
              unsigned int v105 = v111 & v104;
              unsigned int v106 = &v98[8 * (v111 & v104)];
              uint64_t v107 = *(void *)v106;
              if (*(void *)v106 == -1) {
                goto LABEL_154;
              }
            }
LABEL_190:
            uint64_t v135 = v3;
            uint64_t v136 = v5;
            uint64_t v137 = v4;
            uint64_t v138 = sub_1CBF73380((uint64_t)v11, v97);
            int v139 = *((_DWORD *)v11 + 5);
            uint64_t v140 = v139 & 0x7FFFFFF;
            if ((v139 & 0x7FFFFFF) == *((_DWORD *)v11 + 15))
            {
              unsigned int v168 = v140 + (v140 >> 1);
              if (v168 <= 2) {
                uint64_t v169 = 2;
              }
              else {
                uint64_t v169 = v168;
              }
              *((_DWORD *)v11 + 15) = v169;
              if ((v139 & 0x40000000) != 0) {
                uint64_t v170 = (char *)*((void *)v11 - 1);
              }
              else {
                uint64_t v170 = (char *)v11 - 32 * v140;
              }
              __p = v170;
              unint64_t v171 = operator new(40 * v169);
              uint64_t v498 = v169;
              *((void *)v11 - 1) = v171;
              uint64_t v172 = v171;
              do
              {
                *uint64_t v172 = 0;
                v172[1] = 0;
                v172[2] = 0;
                v172[3] = v11;
                v172 += 4;
              }
              while (v172 != &v171[4 * v169]);
              int v173 = *((_DWORD *)v11 + 5);
              if ((v173 & 0x40000000) != 0) {
                uint64_t v174 = (uint64_t)v171;
              }
              else {
                uint64_t v174 = (uint64_t)v11 - 32 * (v173 & 0x7FFFFFF);
              }
              unint64_t v497 = (void *)v174;
              sub_1CC5E4108((uint64_t)&v529, (uint64_t *)__p, (uint64_t *)__p + 4 * v140, v174);
              if (v140)
              {
                memmove(&v497[4 * v498], (char *)__p + 32 * v140, 8 * v140);
                uint64_t v175 = 32 * v140;
                do
                {
                  uint64_t v176 = (char *)__p + v175;
                  if (*(void *)((char *)__p + v175 - 32))
                  {
                    **((void **)v176 - 2) = *((void *)v176 - 3);
                    uint64_t v177 = *((void *)v176 - 3);
                    if (v177) {
                      *(void *)(v177 + 16) = *((void *)v176 - 2);
                    }
                  }
                  v175 -= 32;
                }
                while (v175);
              }
              operator delete(__p);
              int v139 = *((_DWORD *)v11 + 5);
              a2 = v502;
            }
            uint64_t v141 = (v139 + 1) & 0x7FFFFFF;
            *((_DWORD *)v11 + 5) = v139 & 0xF8000000 | (v139 + 1) & 0x7FFFFFF;
            uint64_t v4 = v137;
            if ((v139 & 0x40000000) != 0) {
              uint64_t v142 = (char *)*((void *)v11 - 1);
            }
            else {
              uint64_t v142 = (char *)v11 - 32 * v141;
            }
            uint64_t v5 = v136;
            uint64_t v92 = v501;
            uint64_t v143 = (v141 - 1);
            uint64_t v144 = &v142[32 * v143];
            uint64_t v3 = v135;
            if (*(void *)v144)
            {
              **((void **)v144 + 2) = *((void *)v144 + 1);
              uint64_t v166 = *((void *)v144 + 1);
              if (v166) {
                *(void *)(v166 + 16) = *((void *)v144 + 2);
              }
            }
            *(void *)uint64_t v144 = v138;
            unsigned int v12 = v507;
            if (v138)
            {
              uint64_t v147 = *(void *)(v138 + 8);
              unsigned int v146 = (char **)(v138 + 8);
              uint64_t v145 = v147;
              unint64_t v148 = &v142[32 * v143];
              *((void *)v148 + 1) = v147;
              if (v147) {
                *(void *)(v145 + 16) = v148 + 8;
              }
              *((void *)v148 + 2) = v146;
              *unsigned int v146 = v144;
            }
            int v149 = *((_DWORD *)v11 + 5);
            uint64_t v133 = v149 & 0x7FFFFFF;
            if ((v149 & 0x40000000) != 0) {
              uint64_t v134 = (char *)*((void *)v11 - 1);
            }
            else {
              uint64_t v134 = (char *)v11 - 32 * v133;
            }
            goto LABEL_186;
          }
          BOOL v108 = 0;
LABEL_154:
          if (v108) {
            unint64_t v112 = v108;
          }
          else {
            unint64_t v112 = (uint64_t *)v106;
          }
          if (*v112 == v97) {
            goto LABEL_190;
          }
          if (*v112 == -2) {
            --v523;
          }
          else {
            ++HIDWORD(v522);
          }
          *unint64_t v112 = v97;
LABEL_161:
          uint64_t v113 = 0;
          uint64_t v114 = *(void *)(v97 + 40);
          if (v114) {
            uint64_t v115 = v114 - 24;
          }
          else {
            uint64_t v115 = 0;
          }
          if (*(unsigned __int8 *)(v115 + 16) - 29 >= 0xB) {
            uint64_t v115 = 0;
          }
          *(void *)(v3 + 2056) = *(void *)(v115 + 40);
          *(void *)(v3 + 2064) = v115 + 24;
          uint64_t v116 = *(void **)(v115 + 48);
          v525 = v116;
          if (v116)
          {
            llvm::MetadataTracking::track((uint64_t)&v525, (unsigned __int8 *)v116, 2);
            uint64_t v113 = v525;
          }
          sub_1CB8461A4((uint64_t)v4, 0, (uint64_t)v113);
          if (v525)
          {
            int v163 = *(unsigned __int8 *)v525;
            if ((v163 - 4) > 0x1E)
            {
              if ((v163 - 3) >= 0xFFFFFFFE) {
                uint64_t v167 = v525;
              }
              else {
                uint64_t v167 = 0;
              }
              if ((v163 - 3) >= 0xFFFFFFFE)
              {
                unint64_t v165 = (unint64_t)v167 + 8;
LABEL_241:
                uint64_t v529 = &v525;
                sub_1CC5FA668(v165 + 16, &v529);
                goto LABEL_169;
              }
              if (v163 == 3) {
                *((void *)v525 + 1) = 0;
              }
            }
            else if ((*((unsigned char *)v525 + 1) & 0x7F) == 2 || *((_DWORD *)v525 + 3))
            {
              uint64_t v164 = *((void *)v525 + 2);
              if ((v164 & 4) != 0)
              {
                unint64_t v165 = v164 & 0xFFFFFFFFFFFFFFF8;
                if (v165) {
                  goto LABEL_241;
                }
              }
            }
          }
LABEL_169:
          uint64_t v117 = (unsigned __int8 *)v12[6];
          uint64_t v509 = v117;
          if (v117)
          {
            llvm::MetadataTracking::track((uint64_t)&v509, v117, 2);
            uint64_t v118 = (uint64_t)v509;
          }
          else
          {
            uint64_t v118 = 0;
          }
          sub_1CB8461A4((uint64_t)v4, 0, v118);
          if (!v509) {
            goto LABEL_176;
          }
          int v119 = *v509;
          if ((v119 - 4) > 0x1E)
          {
            if ((v119 - 3) >= 0xFFFFFFFE) {
              unsigned int v150 = v509;
            }
            else {
              unsigned int v150 = 0;
            }
            if ((v119 - 3) < 0xFFFFFFFE)
            {
              if (v119 == 3) {
                *((void *)v509 + 1) = 0;
              }
              goto LABEL_176;
            }
            unint64_t v151 = (unint64_t)(v150 + 8);
          }
          else
          {
            if ((v509[1] & 0x7F) != 2 && !*((_DWORD *)v509 + 3)) {
              goto LABEL_176;
            }
            uint64_t v178 = *((void *)v509 + 2);
            if ((v178 & 4) == 0) {
              goto LABEL_176;
            }
            unint64_t v151 = v178 & 0xFFFFFFFFFFFFFFF8;
            if (!v151) {
              goto LABEL_176;
            }
          }
          uint64_t v529 = (void **)&v509;
          sub_1CC5FA668(v151 + 16, &v529);
LABEL_176:
          uint64_t v120 = v3;
          uint64_t v121 = llvm::slpvectorizer::BoUpSLP::vectorizeTree(v3, *(uint64_t **)(*(void *)(a2 + 208) + 80 * v93), *(unsigned int *)(*(void *)(a2 + 208) + 80 * v93 + 8));
          int v122 = *((_DWORD *)v11 + 5);
          uint64_t v123 = v122 & 0x7FFFFFF;
          if ((v122 & 0x7FFFFFF) == *((_DWORD *)v11 + 15))
          {
            unsigned int v153 = v123 + (v123 >> 1);
            if (v153 <= 2) {
              uint64_t v154 = 2;
            }
            else {
              uint64_t v154 = v153;
            }
            *((_DWORD *)v11 + 15) = v154;
            if ((v122 & 0x40000000) != 0) {
              int v155 = (char *)*((void *)v11 - 1);
            }
            else {
              int v155 = (char *)v11 - 32 * v123;
            }
            __p = v155;
            unsigned int v156 = operator new(40 * v154);
            *((void *)v11 - 1) = v156;
            unsigned int v157 = v156;
            do
            {
              *unsigned int v157 = 0;
              v157[1] = 0;
              v157[2] = 0;
              v157[3] = v11;
              v157 += 4;
            }
            while (v157 != &v156[4 * v154]);
            int v158 = *((_DWORD *)v11 + 5);
            if ((v158 & 0x40000000) != 0) {
              uint64_t v159 = (uint64_t)v156;
            }
            else {
              uint64_t v159 = (uint64_t)v11 - 32 * (v158 & 0x7FFFFFF);
            }
            sub_1CC5E4108((uint64_t)&v529, (uint64_t *)__p, (uint64_t *)__p + 4 * v123, v159);
            if (v123)
            {
              memmove((void *)(v159 + 32 * v154), (char *)__p + 32 * v123, 8 * v123);
              uint64_t v160 = 32 * v123;
              do
              {
                uint64_t v161 = (char *)__p + v160;
                if (*(void *)((char *)__p + v160 - 32))
                {
                  **((void **)v161 - 2) = *((void *)v161 - 3);
                  uint64_t v162 = *((void *)v161 - 3);
                  if (v162) {
                    *(void *)(v162 + 16) = *((void *)v161 - 2);
                  }
                }
                v160 -= 32;
              }
              while (v160);
            }
            operator delete(__p);
            int v122 = *((_DWORD *)v11 + 5);
            uint64_t v5 = v499;
            uint64_t v4 = *(uint64_t **)v500;
            uint64_t v92 = v501;
            a2 = v502;
          }
          uint64_t v124 = (v122 + 1) & 0x7FFFFFF;
          *((_DWORD *)v11 + 5) = v122 & 0xF8000000 | (v122 + 1) & 0x7FFFFFF;
          uint64_t v3 = v120;
          if ((v122 & 0x40000000) != 0) {
            uint64_t v125 = (char *)*((void *)v11 - 1);
          }
          else {
            uint64_t v125 = (char *)v11 - 32 * v124;
          }
          unsigned int v12 = v507;
          uint64_t v126 = (v124 - 1);
          uint64_t v127 = &v125[32 * v126];
          if (*(void *)v127)
          {
            **((void **)v127 + 2) = *((void *)v127 + 1);
            uint64_t v152 = *((void *)v127 + 1);
            if (v152) {
              *(void *)(v152 + 16) = *((void *)v127 + 2);
            }
          }
          *(void *)uint64_t v127 = v121;
          if (v121)
          {
            uint64_t v130 = v121[1];
            int v129 = (char **)(v121 + 1);
            uint64_t v128 = v130;
            int v131 = &v125[32 * v126];
            *((void *)v131 + 1) = v130;
            if (v130) {
              *((void *)v128 + 2) = v131 + 8;
            }
            *((void *)v131 + 2) = v129;
            *int v129 = v127;
          }
          int v132 = *((_DWORD *)v11 + 5);
          uint64_t v133 = v132 & 0x7FFFFFF;
          if ((v132 & 0x40000000) != 0) {
            uint64_t v134 = (char *)*((void *)v11 - 1);
          }
          else {
            uint64_t v134 = (char *)v11 - 32 * v133;
          }
LABEL_186:
          unint64_t v94 = *(void ***)v504;
          *(void *)&v134[32 * *((unsigned int *)v11 + 15) + 8 * (v133 - 1)] = v97;
          if (__b != *(void **)v504) {
            free(__b);
          }
          if (++v93 == v92)
          {
            __int16 v20 = v521;
            if (v521 == v520) {
              goto LABEL_77;
            }
LABEL_24:
            free(v20);
            goto LABEL_77;
          }
        }
        if (v103 >= 0x40) {
          v103 *= 2;
        }
        else {
          unsigned int v103 = 128;
        }
LABEL_265:
        llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v520, v103);
        unsigned int v103 = v522;
        uint64_t v98 = (char *)v521;
        goto LABEL_142;
      }
      int v310 = *(unsigned __int8 *)v520;
      if ((v310 - 4) > 0x1E)
      {
        if ((v310 - 3) >= 0xFFFFFFFE) {
          uint64_t v339 = v520;
        }
        else {
          uint64_t v339 = 0;
        }
        if ((v310 - 3) < 0xFFFFFFFE)
        {
          if (v310 == 3) {
            *((void *)v520 + 1) = 0;
          }
          goto LABEL_117;
        }
        unint64_t v312 = (unint64_t)v339 + 8;
      }
      else
      {
        if ((*((unsigned char *)v520 + 1) & 0x7F) != 2 && !*((_DWORD *)v520 + 3)) {
          goto LABEL_117;
        }
        uint64_t v311 = *((void *)v520 + 2);
        if ((v311 & 4) == 0) {
          goto LABEL_117;
        }
        unint64_t v312 = v311 & 0xFFFFFFFFFFFFFFF8;
        if (!v312) {
          goto LABEL_117;
        }
      }
      __b = &v520;
      sub_1CC5FA668(v312 + 16, &__b);
      goto LABEL_117;
    case 56:
      uint64_t v498 = (uint64_t)v22;
      llvm::slpvectorizer::BoUpSLP::setInsertPointAfterBundle(v3, a2);
      uint64_t v46 = (uint64_t)*(v12 - 4);
      if (v46 && !*(unsigned char *)(v46 + 16) && *(void **)(v46 + 24) == v12[9]) {
        uint64_t v47 = (llvm *)*(unsigned int *)(v46 + 36);
      }
      else {
        uint64_t v47 = 0;
      }
      unsigned int v48 = llvm::getVectorIntrinsicIDForCall((uint64_t)v12, *(uint64_t **)(v3 + 1944));
      sub_1CD3309C4((uint64_t)&v529, (uint64_t)v12, v498, *(void **)(v3 + 1936), *(uint64_t **)(v3 + 1944));
      unsigned int v496 = v48;
      if (v48)
      {
        BOOL v49 = v532 >= (int)v530;
        if (v532 == v530) {
          BOOL v49 = v531 >= (uint64_t)v529;
        }
        LODWORD(v506) = v49;
      }
      else
      {
        LODWORD(v506) = 0;
      }
      llvm::FixedVectorType::get((llvm::FixedVectorType *)*v12, (llvm::Type *)*(unsigned int *)(a2 + 8));
      unint64_t v497 = v527;
      v525 = v527;
      v527[0] = v179;
      uint64_t v526 = 0x200000001;
      int v180 = *((unsigned __int8 *)v12 + 16);
      if (v180 == 84)
      {
        uint64_t v181 = 0;
      }
      else if (v180 == 39)
      {
        unsigned int v12 = v507;
        uint64_t v181 = (*((_DWORD *)v507 + 20) + 1);
      }
      else
      {
        uint64_t v181 = 2;
        unsigned int v12 = v507;
      }
      int v182 = *((_DWORD *)v12 + 5);
      if (v182 < 0 && (v466 = &v12[-4 * (v182 & 0x7FFFFFF)], uint64_t v467 = (uint64_t)*(v466 - 1), (v467 & 0xFFFFFFFF0) != 0))
      {
        uint64_t v184 = -(uint64_t)(v182 & 0x7FFFFFF);
        uint64_t v183 = (*((_DWORD *)v466 - 3) - *(_DWORD *)((char *)v466 - v467));
      }
      else
      {
        uint64_t v183 = 0;
        uint64_t v184 = -(uint64_t)(v182 & 0x7FFFFFF);
      }
      *(void *)uint64_t v500 = v4;
      uint64_t v501 = v3;
      uint64_t v502 = a2;
      int64_t v499 = &v514;
      unint64_t v185 = -32 * v181 - 32 * v183 - 32 * v184 - 32;
      if ((int)(v185 >> 5) < 1)
      {
        unint64_t v190 = 0;
        unint64_t v189 = 0;
        uint64_t v187 = 0;
      }
      else
      {
        unsigned int v186 = 0;
        uint64_t v187 = 0;
        uint64_t v188 = 0;
        unint64_t v189 = 0;
        unint64_t v190 = 0;
        unint64_t v191 = (v185 >> 5);
        __p = (void *)v191;
        do
        {
          __b = &v517;
          *(void *)uint64_t v516 = 0x800000000;
          if (v506 && llvm::hasVectorInstrinsicScalarOpd(v47, (int)v186))
          {
            uint64_t v187 = (llvm::PoisonValue **)*(&v507[4 * (void)v186] - 4 * (*((_DWORD *)v507 + 5) & 0x7FFFFFF));
            if (v189 >= (llvm::PoisonValue ***)v188)
            {
              uint64_t v192 = ((char *)v189 - (char *)v190) >> 3;
              unint64_t v193 = v192 + 1;
              if ((unint64_t)(v192 + 1) >> 61) {
                goto LABEL_759;
              }
              if ((v188 - (char *)v190) >> 2 > v193) {
                unint64_t v193 = (v188 - (char *)v190) >> 2;
              }
              if ((unint64_t)(v188 - (char *)v190) >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v194 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v194 = v193;
              }
              if (v194)
              {
                if (v194 >> 61) {
                  goto LABEL_760;
                }
                uint64_t v195 = (char *)operator new(8 * v194);
              }
              else
              {
                uint64_t v195 = 0;
              }
              int64_t v196 = (uint64_t *)&v195[8 * v192];
              *int64_t v196 = (uint64_t)v187;
              unint64_t v197 = (llvm::PoisonValue ***)(v196 + 1);
              if (v189 != (llvm::PoisonValue ***)v190)
              {
                do
                {
                  uint64_t v198 = (uint64_t)*--v189;
                  *--int64_t v196 = v198;
                }
                while (v189 != (llvm::PoisonValue ***)v190);
                unint64_t v189 = (llvm::PoisonValue ***)v190;
              }
              unint64_t v190 = v196;
              uint64_t v188 = &v195[8 * v194];
              if (v189) {
                operator delete(v189);
              }
              unint64_t v189 = v197;
              unint64_t v191 = (unint64_t)__p;
            }
            else
            {
              *v189++ = v187;
            }
            if (v47 == 239 && v186 == 1)
            {
              if (v526 >= (unint64_t)HIDWORD(v526)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((void *)v525 + v526) = *v187;
              LODWORD(v526) = v526 + 1;
            }
          }
          else
          {
            uint64_t v199 = llvm::slpvectorizer::BoUpSLP::vectorizeTree(v501, *(uint64_t **)(*(void *)(v502 + 208) + 80 * (void)v186), *(unsigned int *)(*(void *)(v502 + 208) + 80 * (void)v186 + 8));
            uint64_t v200 = v199;
            if (v189 >= (llvm::PoisonValue ***)v188)
            {
              uint64_t v201 = ((char *)v189 - (char *)v190) >> 3;
              unint64_t v202 = v201 + 1;
              if ((unint64_t)(v201 + 1) >> 61) {
LABEL_759:
              }
                abort();
              if ((v188 - (char *)v190) >> 2 > v202) {
                unint64_t v202 = (v188 - (char *)v190) >> 2;
              }
              if ((unint64_t)(v188 - (char *)v190) >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v203 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v203 = v202;
              }
              if (v203)
              {
                if (v203 >> 61) {
LABEL_760:
                }
                  sub_1CB833614();
                uint64_t v204 = (char *)operator new(8 * v203);
              }
              else
              {
                uint64_t v204 = 0;
              }
              uint64_t v205 = (uint64_t *)&v204[8 * v201];
              *uint64_t v205 = (uint64_t)v200;
              int v206 = (llvm::PoisonValue ***)(v205 + 1);
              if (v189 != (llvm::PoisonValue ***)v190)
              {
                do
                {
                  uint64_t v207 = (uint64_t)*--v189;
                  *--uint64_t v205 = v207;
                }
                while (v189 != (llvm::PoisonValue ***)v190);
                unint64_t v189 = (llvm::PoisonValue ***)v190;
              }
              unint64_t v190 = v205;
              uint64_t v188 = &v204[8 * v203];
              if (v189) {
                operator delete(v189);
              }
              unint64_t v189 = v206;
              unint64_t v191 = (unint64_t)__p;
            }
            else
            {
              *v189++ = v199;
            }
          }
          if (__b != &v517) {
            free(__b);
          }
          unsigned int v186 = (char *)v186 + 1;
        }
        while (v186 != (void *)v191);
      }
      if (v506)
      {
        uint64_t Declaration = llvm::Intrinsic::getDeclaration(*(uint64_t ***)(*(void *)(v501 + 1920) + 40), v496, (uint64_t)v525, v526);
        uint64_t v209 = v502;
        uint64_t v210 = v507;
      }
      else
      {
        uint64_t v210 = v507;
        sub_1CD8CB164((uint64_t)v507, *(unsigned int *)(v498 + 32), 0, &v520);
        __b = *(void **)(*((void *)v507[5] + 7) + 40);
        *(void *)uint64_t v516 = v507;
        int v517 = v519;
        uint64_t v518 = 0x800000000;
        sub_1CC076744(v507, (uint64_t)&v517);
        uint64_t Declaration = sub_1CD8CB328((uint64_t)&__b, (uint64_t)&v520);
        unsigned int v295 = v517;
        uint64_t v209 = v502;
        if (v518)
        {
          uint64_t v296 = 208 * v518;
          unsigned int v297 = (char *)v517 - 208;
          do
          {
            sub_1CD49DEA4((uint64_t)&v297[v296]);
            v296 -= 208;
          }
          while (v296);
          unsigned int v295 = v517;
        }
        if (v295 != v519) {
          free(v295);
        }
        if (v521 != &v523) {
          free(v521);
        }
      }
      __b = &v517;
      *(void *)uint64_t v516 = 0x100000000;
      int v211 = *((_DWORD *)v210 + 5);
      if (v211 < 0)
      {
        unint64_t v468 = (unint64_t)v210[-4 * (v211 & 0x7FFFFFF) - 1];
        if ((v468 & 0xFFFFFFFF0) != 0)
        {
          uint64_t v469 = (v468 >> 4);
          uint64_t v470 = v210;
          do
          {
            uint64_t v471 = *((_DWORD *)v210 + 5) & 0x7FFFFFF;
            int v472 = &v210[-4 * v471];
            v473 = (unsigned int *)((char *)v470 - ((unsigned char *)*(v472 - 1) + 32 * v471));
            uint64_t v474 = *v473;
            uint64_t v475 = v473[1];
            uint64_t v476 = *((void *)v473 - 1);
            unint64_t v520 = &v472[4 * v474];
            unint64_t v521 = (void *)(v475 - v474);
            uint64_t v522 = v476;
            sub_1CD5C74F0((uint64_t)&__b, (uint64_t)&v520);
            v470 += 2;
            --v469;
          }
          while (v469);
        }
      }
      if (Declaration) {
        int v212 = *(uint64_t ***)(Declaration + 24);
      }
      else {
        int v212 = 0;
      }
      v524[0] = 257;
      uint64_t v213 = (void *)sub_1CC233B6C(*(uint64_t **)v500, v212, (uint64_t **)Declaration, v190, ((char *)v189 - (char *)v190) >> 3, (uint64_t)__b, v516[0], (uint64_t)&v520, 0);
      if (v187)
      {
        unint64_t v520 = 0;
        if (sub_1CD4C64C4(v501 + 80, (uint64_t)v187, &v520))
        {
          uint64_t v298 = *((void *)v520 + 1);
          if (v298)
          {
            int v299 = sub_1CD8DD454(v298, (uint64_t)v187);
            uint64_t v300 = v501;
            unint64_t v520 = v187;
            unint64_t v521 = v213;
            LODWORD(v522) = v299;
            unint64_t v301 = sub_1CD483108(v501 + 1072, (unint64_t)&v520);
            uint64_t v302 = *(void *)(v300 + 1072) + 24 * *(unsigned int *)(v300 + 1080);
            long long v303 = *(_OWORD *)v301;
            *(void *)(v302 + 16) = *(void *)(v301 + 16);
            *(_OWORD *)uint64_t v302 = v303;
            ++*(_DWORD *)(v300 + 1080);
          }
        }
      }
      llvm::propagateIRFlags((uint64_t)v213, *(uint64_t **)v209, *(unsigned int *)(v209 + 8), (uint64_t)v210);
      sub_1CD33789C((uint64_t)&v534, *(void *)(v209 + 128), *(unsigned int *)(v209 + 136));
      sub_1CD324BD0(*(_DWORD **)v504, *(int **)(v209 + 96), *(unsigned int *)(v209 + 104));
      int v214 = sub_1CD3376B4((uint64_t)&v534, (llvm::PoisonValue **)v213);
      *(void *)(v209 + 80) = v214;
      uint64_t v215 = (void **)__b;
      if (v516[0])
      {
        uint64_t v216 = 48 * v516[0];
        int v217 = (char *)__b - 48;
        uint64_t v5 = v499;
        do
        {
          sub_1CD4AF9B4((uint64_t)&v217[v216]);
          v216 -= 48;
        }
        while (v216);
        uint64_t v215 = (void **)__b;
      }
      else
      {
        uint64_t v5 = v499;
      }
      if (v215 != &v517) {
        free(v215);
      }
      if (v525 != v497) {
        free(v525);
      }
      uint64_t v506 = v214;
      if (v190) {
        operator delete(v190);
      }
      goto LABEL_77;
    case 57:
      llvm::slpvectorizer::BoUpSLP::setInsertPointAfterBundle(v3, a2);
      unsigned int v290 = llvm::slpvectorizer::BoUpSLP::vectorizeTree(v3, **(uint64_t ***)(a2 + 208), *(unsigned int *)(*(void *)(a2 + 208) + 8));
      uint64_t v291 = llvm::slpvectorizer::BoUpSLP::vectorizeTree(v3, *(uint64_t **)(*(void *)(a2 + 208) + 80), *(unsigned int *)(*(void *)(a2 + 208) + 88));
      uint64_t v292 = v3;
      int v293 = (llvm::Value *)v291;
      BOOL v294 = llvm::slpvectorizer::BoUpSLP::vectorizeTree(v292, *(uint64_t **)(*(void *)(a2 + 208) + 160), *(unsigned int *)(*(void *)(a2 + 208) + 168));
      uint64_t v506 = *(llvm::PoisonValue ***)(a2 + 80);
      if (v506) {
        goto LABEL_77;
      }
      v519[0] = 257;
      Select = (unsigned __int8 *)llvm::IRBuilderBase::CreateSelect((llvm::IRBuilderBase *)v4, (llvm::Value *)v290, v293, (llvm::Value *)v294, (const llvm::Twine *)&__b, 0);
      goto LABEL_36;
    case 61:
      Select = ***(unsigned __int8 ****)(a2 + 208);
      *(void *)(v3 + 2056) = v12[5];
      *(void *)(v3 + 2064) = v12 + 3;
      uint64_t v29 = v12[6];
      unint64_t v520 = v29;
      if (v29)
      {
        llvm::MetadataTracking::track((uint64_t)&v520, (unsigned __int8 *)v29, 2);
        unsigned int v30 = v520;
      }
      else
      {
        unsigned int v30 = 0;
      }
      sub_1CB8461A4((uint64_t)v4, 0, (uint64_t)v30);
      if (!v520) {
        goto LABEL_36;
      }
      int v304 = *(unsigned __int8 *)v520;
      if ((v304 - 4) > 0x1E)
      {
        if ((v304 - 3) >= 0xFFFFFFFE) {
          uint64_t v337 = v520;
        }
        else {
          uint64_t v337 = 0;
        }
        if ((v304 - 3) >= 0xFFFFFFFE)
        {
          unint64_t v306 = (unint64_t)v337 + 8;
LABEL_533:
          __b = &v520;
          sub_1CC5FA668(v306 + 16, &__b);
          goto LABEL_36;
        }
        if (v304 == 3) {
          *((void *)v520 + 1) = 0;
        }
      }
      else if ((*((unsigned char *)v520 + 1) & 0x7F) == 2 || *((_DWORD *)v520 + 3))
      {
        uint64_t v305 = *((void *)v520 + 2);
        if ((v305 & 4) != 0)
        {
          unint64_t v306 = v305 & 0xFFFFFFFFFFFFFFF8;
          if (v306) {
            goto LABEL_533;
          }
        }
      }
LABEL_36:
      sub_1CD33789C((uint64_t)&v534, *(void *)(a2 + 128), *(unsigned int *)(a2 + 136));
      sub_1CD324BD0(*(_DWORD **)v504, *(int **)(a2 + 96), *(unsigned int *)(a2 + 104));
      BOOL v31 = (llvm::PoisonValue **)Select;
      goto LABEL_76;
    case 62:
      uint64_t v278 = *(void *)(*(void *)a2 + 8 * *(unsigned int *)(a2 + 8) - 8);
      *(void *)(v3 + 2056) = *(void *)(v278 + 40);
      *(void *)(v3 + 2064) = v278 + 24;
      int v279 = *(void **)(v278 + 48);
      unint64_t v520 = v279;
      if (v279)
      {
        llvm::MetadataTracking::track((uint64_t)&v520, (unsigned __int8 *)v279, 2);
        int v280 = v520;
      }
      else
      {
        int v280 = 0;
      }
      sub_1CB8461A4((uint64_t)v4, 0, (uint64_t)v280);
      if (!v520) {
        goto LABEL_445;
      }
      int v424 = *(unsigned __int8 *)v520;
      if ((v424 - 4) > 0x1E)
      {
        if ((v424 - 3) >= 0xFFFFFFFE) {
          int v458 = v520;
        }
        else {
          int v458 = 0;
        }
        if ((v424 - 3) >= 0xFFFFFFFE)
        {
          unint64_t v426 = (unint64_t)v458 + 8;
LABEL_738:
          __b = &v520;
          sub_1CC5FA668(v426 + 16, &__b);
          goto LABEL_445;
        }
        if (v424 == 3) {
          *((void *)v520 + 1) = 0;
        }
      }
      else if ((*((unsigned char *)v520 + 1) & 0x7F) == 2 || *((_DWORD *)v520 + 3))
      {
        uint64_t v425 = *((void *)v520 + 2);
        if ((v425 & 4) != 0)
        {
          unint64_t v426 = v425 & 0xFFFFFFFFFFFFFFF8;
          if (v426) {
            goto LABEL_738;
          }
        }
      }
LABEL_445:
      uint64_t v506 = llvm::slpvectorizer::BoUpSLP::vectorizeTree(v3, *(uint64_t **)(*(void *)(a2 + 208) + 80), *(unsigned int *)(*(void *)(a2 + 208) + 88));
      unint64_t v281 = *(llvm::FixedVectorType ****)a2;
      uint64_t v502 = a2;
      uint64_t v282 = *(unsigned int *)(a2 + 8);
      if (v282)
      {
        v283 = v281;
        while (1)
        {
          uint64_t v284 = *v283;
          int v285 = *((_DWORD *)*v283 + 5);
          unsigned int v286 = (v285 & 0x40000000) != 0
               ? (llvm::FixedVectorType ***)*(v284 - 1)
               : (llvm::FixedVectorType ***)&v284[-4 * (v285 & 0x7FFFFFF)];
          v287 = *v286;
          uint64_t v288 = 8 * v282;
          int v289 = v281;
          while (*v289 != v287)
          {
            ++v289;
            v288 -= 8;
            if (!v288)
            {
              int v289 = &v281[v282];
              break;
            }
          }
          if (v282 == v289 - v281) {
            break;
          }
          if (++v283 == &v281[v282])
          {
            v281 += v282;
            goto LABEL_553;
          }
        }
        unint64_t v281 = v283;
      }
LABEL_553:
      uint64_t v341 = (uint64_t)*v281;
      int v342 = (void **)*((unsigned int *)**v281 + 8);
      *(void *)uint64_t v504 = sub_1CD32AEA4((uint64_t)v507, 0);
      __b = &v517;
      v516[1] = 12;
      uint64_t v343 = *(unsigned int *)(v502 + 136);
      int64_t v499 = &v514;
      if (v343)
      {
        uint8x8_t v346 = v342;
        uint64_t v347 = *(void *)(v502 + 128);
        v516[0] = 0;
        if (v343 >= 0xD) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        memset(&v517, 255, 4 * v343);
        uint64_t v348 = 0;
        v516[0] += v343;
        do
        {
          *((_DWORD *)&v517 + *(unsigned int *)(v347 + 4 * v348)) = v348;
          ++v348;
        }
        while (v343 != v348);
        int v342 = v346;
        uint64_t v349 = (v346 - v282);
        int v350 = v516[0];
        if ((unint64_t)v516[0] + v349 > v516[1]) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v346 != v282)
        {
          memset((char *)__b + 4 * v516[0], 255, 4 * v349);
          int v350 = v516[0];
        }
        v516[0] = v350 + v349;
      }
      else
      {
        if (v342 >= 0xD)
        {
          v516[0] = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v342) {
          memset(&v517, 255, 4 * (void)v342);
        }
        v516[0] = (int)v342;
        if (v282)
        {
          uint64_t v344 = 0;
          uint64_t v345 = 4 * v282;
          do
          {
            *((_DWORD *)&v517 + v344) = v344;
            ++v344;
            v345 -= 4;
          }
          while (v345);
        }
      }
      unint64_t v520 = &v522;
      HIDWORD(v521) = 12;
      size_t v351 = 4 * (void)v342;
      if (v342 >= 0xD)
      {
        LODWORD(v521) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v342) {
        memset(&v522, 255, 4 * (void)v342);
      }
      uint64_t v498 = (uint64_t)&v522;
      *(void *)uint64_t v500 = v4;
      uint64_t v501 = v341;
      __p = &v517;
      int v507 = v342;
      LODWORD(v521) = v342;
      sub_1CD8DCFDC(&__b, &v520);
      if (v282)
      {
        uint64_t v353 = 0;
        uint64_t v354 = (int *)v520;
        uint64_t v355 = *(void *)v502;
        LOBYTE(v356) = 1;
        double v357 = __b;
        int v358 = v504[0];
        do
        {
          uint64_t v359 = sub_1CD32AEA4(*(void *)(v355 + 8 * v354[v353]), 0) - v358;
          int v356 = v356 & (v353 == v359);
          v357[v359] = v353++;
        }
        while (v282 != v353);
      }
      else
      {
        int v356 = 1;
      }
      if (v356) {
        BOOL v360 = v507 == v282;
      }
      else {
        BOOL v360 = 0;
      }
      if (v360)
      {
        int v368 = *(uint64_t **)v500;
        uint64_t v367 = v501;
      }
      else
      {
        int v361 = __b;
        unint64_t v362 = (llvm::Type *)v516[0];
        __int16 v533 = 257;
        uint64_t v363 = llvm::PoisonValue::get(*v506, v352);
        int v364 = sub_1CB935A74(*(uint64_t *)v500, (uint64_t)v506, (uint64_t)v363, v361, v362, (uint64_t)&v529);
        unsigned int v365 = *((unsigned __int8 *)v364 + 16);
        uint64_t v506 = (llvm::PoisonValue **)v364;
        if (v365 <= 0x1B) {
          v366 = 0;
        }
        else {
          v366 = (void **)v364;
        }
        uint64_t v529 = v366;
        uint64_t v367 = v501;
        if (v366)
        {
          sub_1CC27C13C(v10, &v529);
          v525 = v529[5];
          sub_1CBB239A4((uint64_t)v11, &v525);
        }
        int v368 = *(uint64_t **)v500;
      }
      uint64_t v369 = __p;
      if (v504[0]) {
        int v370 = 0;
      }
      else {
        int v370 = v356;
      }
      if (v370 == 1)
      {
        int v371 = *(_DWORD *)(v367 + 20);
        v372 = v507;
        if ((v371 & 0x40000000) != 0) {
          v373 = *(unsigned __int8 ***)(v367 - 8);
        }
        else {
          v373 = (unsigned __int8 **)(v367 - 32 * (v371 & 0x7FFFFFF));
        }
        if (sub_1CD330918(*v373)) {
          goto LABEL_611;
        }
      }
      else
      {
        v372 = v507;
      }
      if (v372 == v282)
      {
LABEL_611:
        uint64_t v384 = v502;
        uint64_t v5 = v499;
        unsigned int v385 = v506;
        goto LABEL_665;
      }
      uint64_t v529 = (void **)&v531;
      HIDWORD(v530) = 12;
      if (v372 >= 0xD)
      {
        LODWORD(v530) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v372)
      {
        bzero(&v531, v351);
        uint64_t v379 = 0;
        LODWORD(v530) = v372;
        uint64_t v380 = *(void *)v504;
        do
        {
          *((_DWORD *)&v531 + v379) = v379;
          ++v379;
          v351 -= 4;
        }
        while (v351);
        uint64_t v381 = (int *)__b;
        uint64_t v382 = v372;
        uint64_t v5 = v499;
        do
        {
          int v383 = *v381++;
          if (v383 != -1) {
            *((_DWORD *)&v531 + v380) = v372;
          }
          ++v380;
          LODWORD(v372) = v372 + 1;
          uint64_t v382 = (void **)((char *)v382 - 1);
        }
        while (v382);
      }
      else
      {
        LODWORD(v530) = 0;
        uint64_t v5 = v499;
      }
      int v395 = *(_DWORD *)(v367 + 20);
      if ((v395 & 0x40000000) != 0) {
        v396 = *(uint64_t **)(v367 - 8);
      }
      else {
        v396 = (uint64_t *)(v367 - 32 * (v395 & 0x7FFFFFF));
      }
      uint64_t v397 = *v396;
      unsigned int v398 = *(uint64_t ****)(*(void *)v502 + 8 * *(unsigned int *)(v502 + 8) - 8);
      if ((*((unsigned char *)v398 + 23) & 0x10) != 0)
      {
        uint64_t v399 = ***v398;
        uint64_t v400 = *(void *)(v399 + 152);
        uint64_t v401 = *(unsigned int *)(v399 + 168);
        if (v401)
        {
          LODWORD(v402) = (v401 - 1) & ((v398 >> 4) ^ (v398 >> 9));
          v403 = (uint64_t ****)(v400 + 16 * v402);
          v404 = *v403;
          if (*v403 == v398)
          {
LABEL_656:
            int v416 = v403[1];
            uint64_t v419 = (uint64_t)*v416;
            unint64_t v417 = (char *)(v416 + 2);
            uint64_t v418 = v419;
            goto LABEL_657;
          }
          int v405 = 1;
          while (v404 != (uint64_t ***)-4096)
          {
            int v406 = v402 + v405++;
            uint64_t v402 = v406 & (v401 - 1);
            v404 = *(uint64_t ****)(v400 + 16 * v402);
            if (v404 == v398)
            {
              v403 = (uint64_t ****)(v400 + 16 * v402);
              goto LABEL_656;
            }
          }
        }
        v403 = (uint64_t ****)(v400 + 16 * v401);
        goto LABEL_656;
      }
      uint64_t v418 = 0;
      unint64_t v417 = &byte_1CFBCE98E;
LABEL_657:
      __int16 v528 = 261;
      v525 = v417;
      uint64_t v526 = v418;
      unsigned int v420 = sub_1CB935A74((uint64_t)v368, v397, (uint64_t)v506, &v531, (llvm::Type *)v530, (uint64_t)&v525);
      unsigned int v385 = (llvm::PoisonValue **)v420;
      if (*((unsigned __int8 *)v420 + 16) <= 0x1Bu) {
        uint64_t v421 = 0;
      }
      else {
        uint64_t v421 = v420;
      }
      v525 = v421;
      if (v421)
      {
        sub_1CC27C13C(v10, &v525);
        uint64_t v508 = *((void *)v525 + 5);
        sub_1CBB239A4((uint64_t)v11, &v508);
      }
      if (v529 != (void **)&v531) {
        free(v529);
      }
      uint64_t v384 = v502;
LABEL_665:
      *(void *)(v384 + 80) = v385;
      if (v520 != (void *)v498) {
        free(v520);
      }
      uint64_t v506 = v385;
      __int16 v20 = __b;
      if (__b != v369) {
        goto LABEL_24;
      }
LABEL_77:
      if (v537[0] != v505) {
        free(v537[0]);
      }
      uint64_t v7 = v506;
LABEL_80:
      uint64_t v67 = v512;
      if ((void)v513)
      {
        sub_1CBF5385C(v512, v513, *((uint64_t *)&v513 + 1));
        uint64_t v67 = v512;
      }
      else
      {
        *(void *)(v512 + 48) = 0;
        *(void *)(v67 + 56) = 0;
      }
      unint64_t v520 = v514;
      if (v514)
      {
        llvm::MetadataTracking::track((uint64_t)&v520, v514, 2);
        uint64_t v68 = v520;
      }
      else
      {
        uint64_t v68 = 0;
      }
      sub_1CB8461A4(v67, 0, (uint64_t)v68);
      if (!v520) {
        goto LABEL_86;
      }
      int v221 = *(unsigned __int8 *)v520;
      if ((v221 - 4) <= 0x1E)
      {
        if ((*((unsigned char *)v520 + 1) & 0x7F) != 2 && !*((_DWORD *)v520 + 3)) {
          goto LABEL_86;
        }
        uint64_t v222 = *((void *)v520 + 2);
        if ((v222 & 4) == 0) {
          goto LABEL_86;
        }
        unint64_t v223 = v222 & 0xFFFFFFFFFFFFFFF8;
        if (!v223) {
          goto LABEL_86;
        }
LABEL_403:
        __b = &v520;
        sub_1CC5FA668(v223 + 16, &__b);
        goto LABEL_86;
      }
      if ((v221 - 3) >= 0xFFFFFFFE) {
        uint64_t v238 = v520;
      }
      else {
        uint64_t v238 = 0;
      }
      if ((v221 - 3) >= 0xFFFFFFFE)
      {
        unint64_t v223 = (unint64_t)v238 + 8;
        goto LABEL_403;
      }
      if (v221 == 3) {
        *((void *)v520 + 1) = 0;
      }
LABEL_86:
      if (!v514) {
        return v7;
      }
      int v224 = *v514;
      if ((v224 - 4) > 0x1E)
      {
        if ((v224 - 3) >= 0xFFFFFFFE) {
          unint64_t v239 = v514;
        }
        else {
          unint64_t v239 = 0;
        }
        if ((v224 - 3) >= 0xFFFFFFFE)
        {
          unint64_t v226 = (unint64_t)(v239 + 8);
LABEL_409:
          __b = v5;
          sub_1CC5FA668(v226 + 16, &__b);
          return v7;
        }
        if (v224 == 3) {
          *((void *)v514 + 1) = 0;
        }
      }
      else if ((v514[1] & 0x7F) == 2 || *((_DWORD *)v514 + 3))
      {
        uint64_t v225 = *((void *)v514 + 2);
        if ((v225 & 4) != 0)
        {
          unint64_t v226 = v225 & 0xFFFFFFFFFFFFFFF8;
          if (v226) {
            goto LABEL_409;
          }
        }
      }
      return v7;
    case 63:
      uint64_t v242 = (uint64_t)v22;
      uint64_t v243 = *(void *)(a2 + 384);
      if (v243 && *(unsigned __int8 *)(v243 + 16) - 41 < 0x12
        || *((unsigned __int8 *)v12 + 16) - 81 <= 1)
      {
        llvm::slpvectorizer::BoUpSLP::setInsertPointAfterBundle(v3, a2);
        unint64_t v244 = (unsigned __int8 *)llvm::slpvectorizer::BoUpSLP::vectorizeTree(v3, **(uint64_t ***)(a2 + 208), *(unsigned int *)(*(void *)(a2 + 208) + 8));
        uint64_t v245 = llvm::slpvectorizer::BoUpSLP::vectorizeTree(v3, *(uint64_t **)(*(void *)(a2 + 208) + 80), *(unsigned int *)(*(void *)(a2 + 208) + 88));
        uint64_t v246 = a2;
        uint64_t v247 = (uint64_t)v245;
      }
      else
      {
        llvm::slpvectorizer::BoUpSLP::setInsertPointAfterBundle(v3, a2);
        unint64_t v244 = (unsigned __int8 *)llvm::slpvectorizer::BoUpSLP::vectorizeTree(v3, **(uint64_t ***)(a2 + 208), *(unsigned int *)(*(void *)(a2 + 208) + 8));
        uint64_t v246 = a2;
        uint64_t v247 = 0;
      }
      uint64_t v506 = *(llvm::PoisonValue ***)(v246 + 80);
      if (v506) {
        goto LABEL_77;
      }
      v328 = &v514;
      uint64_t v329 = v246;
      uint64_t v330 = *(void *)(v246 + 384);
      if (v330)
      {
        int v331 = *(unsigned __int8 *)(v330 + 16);
        if ((v331 - 41) <= 0x11)
        {
          v519[0] = 257;
          uint64_t v332 = sub_1CB844E98((uint64_t)v4, (v331 - 28), (uint64_t)v244, v247, (uint64_t)&__b, 0);
          uint64_t v333 = *(void *)(v329 + 392);
          if (v333) {
            uint64_t v334 = *(unsigned __int8 *)(v333 + 16) - 28;
          }
          else {
            uint64_t v334 = 0;
          }
          v519[0] = 257;
          v423 = sub_1CB844E98((uint64_t)v4, v334, (uint64_t)v244, v247, (uint64_t)&__b, 0);
LABEL_700:
          unint64_t v244 = (unsigned __int8 *)v423;
LABEL_701:
          uint64_t v411 = v329;
          goto LABEL_702;
        }
        unsigned int v407 = v507;
        if (*((unsigned __int8 *)v507 + 16) - 83 < 0xFFFFFFFE)
        {
          uint64_t v408 = v3;
          uint64_t v409 = (v331 - 28);
LABEL_649:
          v524[0] = 257;
          uint64_t v332 = (llvm::Instruction *)v244;
          uint64_t v410 = v242;
          uint64_t v411 = v329;
          if (*(void *)v244 != v242)
          {
            if (v244[16] <= 0x14u)
            {
              uint64_t v427 = (*(uint64_t (**)(void, uint64_t, unsigned __int8 *, uint64_t))(**(void **)(v408 + 2080)
                                                                                            + 224))(*(void *)(v408 + 2080), v409, v244, v242);
              uint64_t v332 = (llvm::Instruction *)v427;
              if (v427)
              {
                if (*(unsigned __int8 *)(v427 + 16) >= 0x1Cu)
                {
                  (*(void (**)(void, uint64_t, void **, void, void))(**(void **)(v408 + 2088) + 16))(*(void *)(v408 + 2088), v427, &v520, *(void *)(v408 + 2056), *(void *)(v408 + 2064));
                  uint64_t v488 = *(unsigned int *)(v408 + 2016);
                  if (v488)
                  {
                    uint64_t v489 = *(void *)(v408 + 2008);
                    int v507 = (void **)(v489 + 16 * v488);
                    do
                    {
                      llvm::Instruction::setMetadata(v332, *(_DWORD *)v489, *(llvm::MDNode **)(v489 + 8));
                      v489 += 16;
                    }
                    while ((void **)v489 != v507);
                  }
                }
                v328 = &v514;
                uint64_t v411 = v329;
              }
            }
            else
            {
              int64_t v499 = &v514;
              uint64_t v412 = v4;
              v519[0] = 257;
              uint64_t v332 = llvm::CastInst::Create(v409, (uint64_t)v244, v242, (const char **)&__b, 0);
              (*(void (**)(void, llvm::Instruction *, void **, void, void))(**(void **)(v408 + 2088)
                                                                                           + 16))(*(void *)(v408 + 2088), v332, &v520, *(void *)(v408 + 2056), *(void *)(v408 + 2064));
              uint64_t v413 = *(unsigned int *)(v408 + 2016);
              if (v413)
              {
                uint64_t v461 = *(void *)(v408 + 2008);
                int v507 = (void **)(v461 + 16 * v413);
                do
                {
                  llvm::Instruction::setMetadata(v332, *(_DWORD *)v461, *(llvm::MDNode **)(v461 + 8));
                  v461 += 16;
                }
                while ((void **)v461 != v507);
              }
              uint64_t v4 = v412;
              v328 = v499;
            }
            uint64_t v410 = v242;
          }
          uint64_t v428 = *(void *)(v411 + 392);
          if (v428) {
            uint64_t v429 = *(unsigned __int8 *)(v428 + 16) - 28;
          }
          else {
            uint64_t v429 = 0;
          }
          v524[0] = 257;
          if (*(void *)v244 != v410)
          {
            if (v244[16] <= 0x14u)
            {
              unint64_t v244 = (unsigned __int8 *)(*(uint64_t (**)(void, uint64_t, unsigned __int8 *, uint64_t))(**(void **)(v408 + 2080) + 224))(*(void *)(v408 + 2080), v429, v244, v410);
              if (v244) {
                BOOL v432 = v244[16] >= 0x1Cu;
              }
              else {
                BOOL v432 = 0;
              }
              if (v432)
              {
                (*(void (**)(void, unsigned __int8 *, void **, void, void))(**(void **)(v408 + 2088)
                                                                                           + 16))(*(void *)(v408 + 2088), v244, &v520, *(void *)(v408 + 2056), *(void *)(v408 + 2064));
                uint64_t v433 = *(unsigned int *)(v408 + 2016);
                if (v433)
                {
                  uint64_t v494 = *(void *)(v408 + 2008);
                  uint64_t v495 = v494 + 16 * v433;
                  do
                  {
                    llvm::Instruction::setMetadata((llvm::Instruction *)v244, *(_DWORD *)v494, *(llvm::MDNode **)(v494 + 8));
                    v494 += 16;
                  }
                  while (v494 != v495);
                }
                goto LABEL_701;
              }
            }
            else
            {
              unsigned int v430 = v4;
              v519[0] = 257;
              unint64_t v244 = (unsigned __int8 *)llvm::CastInst::Create(v429, (uint64_t)v244, v410, (const char **)&__b, 0);
              (*(void (**)(void, unsigned __int8 *, void **, void, void))(**(void **)(v408 + 2088)
                                                                                         + 16))(*(void *)(v408 + 2088), v244, &v520, *(void *)(v408 + 2056), *(void *)(v408 + 2064));
              uint64_t v431 = *(unsigned int *)(v408 + 2016);
              if (v431)
              {
                uint64_t v462 = *(void *)(v408 + 2008);
                uint64_t v463 = v462 + 16 * v431;
                do
                {
                  llvm::Instruction::setMetadata((llvm::Instruction *)v244, *(_DWORD *)v462, *(llvm::MDNode **)(v462 + 8));
                  v462 += 16;
                }
                while (v462 != v463);
              }
              uint64_t v4 = v430;
            }
          }
LABEL_702:
          uint64_t v434 = (uint64_t)v4;
          char v435 = 0;
          uint64_t v436 = 0;
          __b = v332;
          *(void *)uint64_t v516 = v244;
          do
          {
            char v437 = v435;
            BOOL v438 = *(unsigned __int8 **)&v516[2 * v436 - 2];
            if (v438[16] <= 0x1Bu) {
              BOOL v438 = 0;
            }
            unint64_t v520 = v438;
            if (v438)
            {
              sub_1CC27C13C(v10, &v520);
              uint64_t v529 = (void **)*((void *)v520 + 5);
              sub_1CBB239A4((uint64_t)v11, &v529);
            }
            char v435 = 1;
            uint64_t v436 = 1;
          }
          while ((v437 & 1) == 0);
          __b = &v517;
          *(void *)uint64_t v516 = 0x800000000;
          unint64_t v520 = &v522;
          unint64_t v521 = (void *)0x800000000;
          uint64_t v529 = (void **)&v531;
          uint64_t v530 = 0xC00000000;
          v439 = *(llvm::MDNode ***)v411;
          unsigned int v440 = *(_DWORD *)(v411 + 8);
          uint64_t v441 = *(void *)(v411 + 128);
          uint64_t v442 = *(unsigned int *)(v411 + 136);
          BOOL v443 = *(int **)(v411 + 96);
          unint64_t v444 = *(unsigned int *)(v411 + 104);
          v525 = (void *)v411;
          sub_1CD330E8C((uint64_t)v439, v440, v441, v442, v443, v444, (unsigned int (*)(uint64_t, uint64_t))sub_1CD348970, (uint64_t)&v525, &v529, (uint64_t)&__b, (uint64_t)&v520);
          llvm::propagateIRFlags((uint64_t)v332, (uint64_t *)__b, v516[0], 0);
          llvm::propagateIRFlags((uint64_t)v244, (uint64_t *)v520, v521, 0);
          __int16 v528 = 257;
          int64_t v445 = (unsigned __int8 *)sub_1CB935A74(v434, (uint64_t)v332, (uint64_t)v244, v529, (llvm::Type *)v530, (uint64_t)&v525);
          int v446 = (llvm::PoisonValue **)v445;
          if (v445[16] <= 0x1Bu) {
            int64_t v445 = 0;
          }
          v525 = v445;
          if (v445)
          {
            llvm::propagateMetadata((llvm *)v445, *(llvm::MDNode ***)v411, *(unsigned int *)(v411 + 8));
            sub_1CC27C13C(v10, &v525);
            uint64_t v508 = *((void *)v525 + 5);
            sub_1CBB239A4((uint64_t)v11, &v508);
          }
          uint64_t v447 = sub_1CD3376B4((uint64_t)&v534, v446);
          *(void *)(v411 + 80) = v447;
          if (v529 != (void **)&v531) {
            free(v529);
          }
          uint64_t v5 = v328;
          if (v520 != &v522) {
            free(v520);
          }
          uint64_t v506 = v447;
LABEL_23:
          __int16 v20 = __b;
          if (__b == &v517) {
            goto LABEL_77;
          }
          goto LABEL_24;
        }
      }
      else
      {
        unsigned int v407 = v507;
        if (*((unsigned __int8 *)v507 + 16) - 83 < 0xFFFFFFFE)
        {
          uint64_t v408 = v3;
          uint64_t v409 = 0;
          goto LABEL_649;
        }
      }
      uint64_t v414 = *((_WORD *)v407 + 9) & 0x3F;
      v519[0] = 257;
      if (v414 > 0xF) {
        v415 = sub_1CB845F20((uint64_t)v4, v414, v244, v247, (uint64_t)&__b);
      }
      else {
        v415 = llvm::IRBuilderBase::CreateFCmpHelper((uint64_t)v4, v414, (uint64_t)v244, v247, (uint64_t)&__b, 0, 0);
      }
      uint64_t v332 = v415;
      uint64_t v422 = *(_WORD *)(*(void *)(v329 + 392) + 18) & 0x3F;
      v519[0] = 257;
      if (v422 > 0xF) {
        v423 = sub_1CB845F20((uint64_t)v4, v422, v244, v247, (uint64_t)&__b);
      }
      else {
        v423 = llvm::IRBuilderBase::CreateFCmpHelper((uint64_t)v4, v422, (uint64_t)v244, v247, (uint64_t)&__b, 0, 0);
      }
      goto LABEL_700;
    case 64:
      uint64_t v35 = (uint64_t)v22;
      uint64_t v36 = ***(void ***)(a2 + 208);
      *(void *)(v3 + 2056) = *(void *)(v36 + 40);
      *(void *)(v3 + 2064) = v36 + 24;
      int v37 = *(void **)(v36 + 48);
      unint64_t v520 = v37;
      if (v37)
      {
        llvm::MetadataTracking::track((uint64_t)&v520, (unsigned __int8 *)v37, 2);
        BOOL v38 = v520;
      }
      else
      {
        BOOL v38 = 0;
      }
      sub_1CB8461A4((uint64_t)v4, 0, (uint64_t)v38);
      unsigned int v39 = (llvm::PointerType *)v35;
      if (!v520) {
        goto LABEL_48;
      }
      int v313 = *(unsigned __int8 *)v520;
      if ((v313 - 4) > 0x1E)
      {
        if ((v313 - 3) >= 0xFFFFFFFE) {
          uint64_t v340 = v520;
        }
        else {
          uint64_t v340 = 0;
        }
        if ((v313 - 3) >= 0xFFFFFFFE)
        {
          unint64_t v315 = (unint64_t)v340 + 8;
LABEL_551:
          __b = &v520;
          sub_1CC5FA668(v315 + 16, &__b);
          unsigned int v39 = (llvm::PointerType *)v35;
          goto LABEL_48;
        }
        if (v313 == 3) {
          *((void *)v520 + 1) = 0;
        }
      }
      else if ((*((unsigned char *)v520 + 1) & 0x7F) == 2 || *((_DWORD *)v520 + 3))
      {
        uint64_t v314 = *((void *)v520 + 2);
        if ((v314 & 4) != 0)
        {
          unint64_t v315 = v314 & 0xFFFFFFFFFFFFFFF8;
          if (v315) {
            goto LABEL_551;
          }
        }
      }
LABEL_48:
      uint64_t v40 = **(void **)(v36 - 32);
      unsigned int v41 = *(_DWORD *)(v40 + 8);
      if ((v41 & 0xFE) == 0x12) {
        unsigned int v41 = *(_DWORD *)(**(void **)(v40 + 16) + 8);
      }
      unint64_t v42 = llvm::PointerType::get(v39, (llvm::Type *)(v41 >> 8));
      uint64_t v43 = *(unsigned __int8 **)(v36 - 32);
      v524[0] = 257;
      if (*(void *)v43 == v42)
      {
        uint64_t v45 = v3;
      }
      else
      {
        if (v43[16] <= 0x14u)
        {
          uint64_t v45 = v3;
          uint64_t v43 = (unsigned __int8 *)(*(uint64_t (**)(void, uint64_t, unsigned __int8 *, unint64_t))(**(void **)(v3 + 2080) + 224))(*(void *)(v3 + 2080), 49, v43, v42);
          if (v43) {
            BOOL v61 = v43[16] >= 0x1Cu;
          }
          else {
            BOOL v61 = 0;
          }
          if (!v61) {
            goto LABEL_74;
          }
          (*(void (**)(void, unsigned __int8 *, void **, void, void))(**(void **)(v3 + 2088) + 16))(*(void *)(v3 + 2088), v43, &v520, *(void *)(v3 + 2056), *(void *)(v3 + 2064));
          uint64_t v477 = *(unsigned int *)(v3 + 2016);
          if (v477)
          {
            uint64_t v478 = *(void *)(v3 + 2008);
            uint64_t v479 = v478 + 16 * v477;
            do
            {
              llvm::Instruction::setMetadata((llvm::Instruction *)v43, *(_DWORD *)v478, *(llvm::MDNode **)(v478 + 8));
              v478 += 16;
            }
            while (v478 != v479);
          }
        }
        else
        {
          v519[0] = 257;
          uint64_t v43 = (unsigned __int8 *)llvm::CastInst::Create(49, (uint64_t)v43, v42, (const char **)&__b, 0);
          (*(void (**)(void, unsigned __int8 *, void **, void, void))(**(void **)(v3 + 2088) + 16))(*(void *)(v3 + 2088), v43, &v520, *(void *)(v3 + 2056), *(void *)(v3 + 2064));
          uint64_t v44 = *(unsigned int *)(v3 + 2016);
          if (v44)
          {
            uint64_t v335 = *(void *)(v3 + 2008);
            uint64_t v336 = v335 + 16 * v44;
            do
            {
              llvm::Instruction::setMetadata((llvm::Instruction *)v43, *(_DWORD *)v335, *(llvm::MDNode **)(v335 + 8));
              v335 += 16;
            }
            while (v335 != v336);
          }
          uint64_t v45 = v3;
        }
        uint64_t v5 = &v514;
      }
LABEL_74:
      unint64_t v62 = *(unsigned __int16 *)(v36 + 18);
      v524[0] = 257;
      uint64_t v63 = (v62 >> 1) & 0x3F;
      uint64_t v64 = operator new(0x60uLL);
      v64[13] = v64[13] & 0x38000000 | 1;
      uint64_t v65 = (llvm::Instruction *)(v64 + 8);
      *(void *)uint64_t v64 = 0;
      *((void *)v64 + 1) = 0;
      *((void *)v64 + 2) = 0;
      *((void *)v64 + 3) = v64 + 8;
      v519[0] = 257;
      llvm::LoadInst::LoadInst((llvm::Value *)(v64 + 8), v35, (uint64_t)v43, (const char **)&__b, 0, v63, 0);
      (*(void (**)(void, llvm::Instruction *, void **, void, void))(**(void **)(v45 + 2088) + 16))(*(void *)(v45 + 2088), v65, &v520, *(void *)(v45 + 2056), *(void *)(v45 + 2064));
      uint64_t v66 = *(unsigned int *)(v45 + 2016);
      if (v66)
      {
        uint64_t v240 = *(void *)(v45 + 2008);
        uint64_t v241 = v240 + 16 * v66;
        do
        {
          llvm::Instruction::setMetadata(v65, *(_DWORD *)v240, *(llvm::MDNode **)(v240 + 8));
          v240 += 16;
        }
        while (v240 != v241);
      }
      llvm::propagateMetadata(v65, *(llvm::MDNode ***)a2, *(unsigned int *)(a2 + 8));
      sub_1CD33789C((uint64_t)&v534, *(void *)(a2 + 128), *(unsigned int *)(a2 + 136));
      sub_1CD324BD0(*(_DWORD **)v504, *(int **)(a2 + 96), *(unsigned int *)(a2 + 104));
      BOOL v31 = (llvm::PoisonValue **)v65;
LABEL_76:
      uint64_t v506 = sub_1CD3376B4((uint64_t)&v534, v31);
      *(void *)(a2 + 80) = v506;
      goto LABEL_77;
    default:
      llvm::slpvectorizer::BoUpSLP::setInsertPointAfterBundle(v3, a2);
      uint64_t v260 = llvm::slpvectorizer::BoUpSLP::vectorizeTree(v3, **(uint64_t ***)(a2 + 208), *(unsigned int *)(*(void *)(a2 + 208) + 8));
      uint64_t v506 = *(llvm::PoisonValue ***)(a2 + 80);
      if (!v506)
      {
        uint64_t v261 = *(void *)(a2 + 384);
        if (v261) {
          uint64_t v262 = *(unsigned __int8 *)(v261 + 16) - 28;
        }
        else {
          uint64_t v262 = 0;
        }
        v519[0] = 257;
        uint64_t v455 = (unsigned __int8 *)sub_1CD5C2B18((uint64_t)v4, v262, (uint64_t)v260, (uint64_t)&__b, 0);
        llvm::propagateIRFlags((uint64_t)v455, *(uint64_t **)a2, *(unsigned int *)(a2 + 8), (uint64_t)v507);
        if (v455 && v455[16] >= 0x1Cu) {
          llvm::propagateMetadata((llvm *)v455, *(llvm::MDNode ***)a2, *(unsigned int *)(a2 + 8));
        }
        sub_1CD33789C((uint64_t)&v534, *(void *)(a2 + 128), *(unsigned int *)(a2 + 136));
        sub_1CD324BD0(*(_DWORD **)v504, *(int **)(a2 + 96), *(unsigned int *)(a2 + 104));
        uint64_t v506 = sub_1CD3376B4((uint64_t)&v534, (llvm::PoisonValue **)v455);
        *(void *)(a2 + 80) = v506;
      }
      goto LABEL_77;
  }
}

llvm::PoisonValue **sub_1CD3376B4(uint64_t a1, llvm::PoisonValue **a2)
{
  uint64_t v2 = a2;
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  *(unsigned char *)(a1 + 12) = 1;
  int v4 = *((_DWORD *)*a2 + 8);
  uint64_t v5 = *(unsigned int *)(a1 + 8);
  if (v5 != v4 || *(_DWORD *)(a1 + 24))
  {
    __b = v24;
    int v23 = 4;
    uint64_t v6 = 4 * v5;
    if (v5 >= 5)
    {
      unsigned int v22 = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    if (v5)
    {
      memset(v24, 255, 4 * v5);
      uint64_t v7 = 0;
      unsigned int v22 = v5;
      do
      {
        v24[v7] = v7;
        ++v7;
        v6 -= 4;
      }
      while (v6);
      unint64_t v8 = v22;
    }
    else
    {
      unint64_t v8 = 0;
      unsigned int v22 = 0;
    }
    sub_1CD324BD0((_DWORD *)(a1 + 16), v24, v8);
    unint64_t v10 = *(void **)(a1 + 16);
    int v11 = (llvm::Type *)*(unsigned int *)(a1 + 24);
    if (*(_DWORD *)(a1 + 8) != v4
      || (sub_1CC5D47FC(*(int **)(a1 + 16), *(unsigned int *)(a1 + 24), *(_DWORD *)(a1 + 24)) & 1) == 0)
    {
      uint64_t v12 = *(void *)a1;
      v19[0] = "shuffle";
      __int16 v20 = 259;
      uint64_t v13 = llvm::PoisonValue::get(*v2, v9);
      int v14 = sub_1CB935A74(v12, (uint64_t)v2, (uint64_t)v13, v10, v11, (uint64_t)v19);
      uint64_t v2 = (llvm::PoisonValue **)v14;
      uint64_t v15 = *((unsigned __int8 *)v14 + 16) <= 0x1Bu ? 0 : v14;
      v19[0] = v15;
      if (v15)
      {
        sub_1CC27C13C(*(void **)(a1 + 48), v19);
        uint64_t v16 = *(void *)(a1 + 56);
        uint64_t v18 = *(void *)(v19[0] + 40);
        sub_1CBB239A4(v16, &v18);
      }
    }
    if (__b != v24) {
      free(__b);
    }
  }
  return v2;
}

void sub_1CD33789C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    unsigned int v3 = a3;
    uint64_t v6 = a3;
    if (a3)
    {
      if (a3 >= 5uLL) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memset(v9, 255, 4 * a3);
      unsigned int v7 = v3;
      if (v3)
      {
        uint64_t v8 = 0;
        do
        {
          v9[*(unsigned int *)(a2 + 4 * v8)] = v8;
          ++v8;
        }
        while (v6 != v8);
        unsigned int v7 = v3;
      }
    }
    else
    {
      unsigned int v7 = 0;
    }
    sub_1CD324BD0((_DWORD *)(a1 + 16), v9, v7);
  }
}

uint64_t *llvm::slpvectorizer::BoUpSLP::vectorizeTree(uint64_t ****this)
{
  v3[0] = 0;
  v3[1] = 0;
  int v4 = 0;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  uint64_t v5 = 0;
  unsigned int v1 = llvm::slpvectorizer::BoUpSLP::vectorizeTree(this, (uint64_t)v3);
  sub_1CD8E420C((uint64_t)v3);
  return v1;
}

void llvm::slpvectorizer::BoUpSLP::scheduleBlock(llvm::slpvectorizer::BoUpSLP *this, llvm::Instruction **a2)
{
  if (a2[17])
  {
    llvm::slpvectorizer::BoUpSLP::BlockScheduling::resetSchedule((llvm::slpvectorizer::BoUpSLP::BlockScheduling *)a2);
    uint64_t v58 = 0;
    uint64_t v59 = 0;
    uint64_t v57 = &v58;
    int v56 = 0;
    int v4 = a2[17];
    if (v4 != a2[18])
    {
      do
      {
        v55[0] = this;
        v55[1] = &v56;
        v55[2] = a2;
        sub_1CD339D6C((uint64_t)a2, (uint64_t)v4, (void (*)(uint64_t, uint64_t))sub_1CD3498A8, (uint64_t)v55);
        uint64_t v5 = *((void *)v4 + 4);
        if (v5) {
          BOOL v6 = v5 == *((void *)v4 + 5) + 40;
        }
        else {
          BOOL v6 = 1;
        }
        if (v6) {
          int v4 = 0;
        }
        else {
          int v4 = (llvm::Instruction *)(v5 - 24);
        }
      }
      while (v4 != a2[18]);
      if (a2[17] != v4)
      {
        int v4 = a2[17];
        do
        {
          v55[0] = &v57;
          sub_1CD339D6C((uint64_t)a2, (uint64_t)v4, (void (*)(uint64_t, uint64_t))sub_1CD349954, (uint64_t)v55);
          uint64_t v7 = *((void *)v4 + 4);
          if (v7) {
            BOOL v8 = v7 == *((void *)v4 + 5) + 40;
          }
          else {
            BOOL v8 = 1;
          }
          if (v8) {
            int v4 = 0;
          }
          else {
            int v4 = (llvm::Instruction *)(v7 - 24);
          }
        }
        while (v4 != a2[18]);
      }
    }
    for (uint64_t i = v59; v59; uint64_t i = v59)
    {
      uint64_t v10 = (uint64_t *)v57;
      int v11 = v57[1];
      uint64_t v12 = (uint64_t)v57;
      if (v11)
      {
        do
        {
          uint64_t v13 = (uint64_t **)v11;
          int v11 = (uint64_t *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v13 = *(uint64_t ***)(v12 + 16);
          BOOL v6 = *v13 == (uint64_t *)v12;
          uint64_t v12 = (uint64_t)v13;
        }
        while (!v6);
      }
      int v14 = v57[4];
      uint64_t v57 = v13;
      uint64_t v59 = i - 1;
      sub_1CB91F7C8(v58, v10);
      operator delete(v10);
      for (j = v14; j; int v4 = v16)
      {
        uint64_t v16 = (llvm::Instruction *)*j;
        uint64_t v17 = *(void *)(*j + 32);
        if (v17) {
          BOOL v18 = v17 == *(void *)(*j + 40) + 40;
        }
        else {
          BOOL v18 = 1;
        }
        if (v18) {
          unsigned int v19 = 0;
        }
        else {
          unsigned int v19 = (llvm::Instruction *)(v17 - 24);
        }
        if (v19 != v4) {
          llvm::Instruction::moveBefore((llvm::Instruction *)*j, v4);
        }
        unint64_t j = (uint64_t *)j[4];
      }
      *((unsigned char *)v14 + 160) = 1;
      do
      {
        uint64_t v20 = *v14;
        if (*v14 != v14[1]) {
          goto LABEL_85;
        }
        uint64_t v21 = v14[2];
        if (v21)
        {
          unsigned int v22 = *(void **)v21;
          uint64_t v23 = *(unsigned int *)(v21 + 8);
          if (v23)
          {
            uint64_t v24 = 8 * v23;
            uint64_t v25 = *(void **)v21;
            uint64_t v26 = &v22[v23];
            while (*v25 != v20)
            {
              ++v25;
              v24 -= 8;
              if (!v24)
              {
                uint64_t v25 = v26;
                break;
              }
            }
          }
          else
          {
            uint64_t v25 = *(void **)v21;
          }
          uint64_t v30 = *(unsigned int *)(v21 + 216);
          if (v30)
          {
            uint64_t v31 = 0;
            uint64_t v32 = (int)(v25 - v22);
            uint64_t v33 = 80 * v30;
            do
            {
              uint64_t v34 = *(void *)(*(void *)(*(void *)(v21 + 208) + v31) + 8 * v32);
              if (v34) {
                BOOL v35 = *(unsigned __int8 *)(v34 + 16) >= 0x1Cu;
              }
              else {
                BOOL v35 = 0;
              }
              if (v35)
              {
                v55[0] = &v57;
                sub_1CD339D6C((uint64_t)a2, v34, (void (*)(uint64_t, uint64_t))sub_1CD349A68, (uint64_t)v55);
              }
              v31 += 80;
            }
            while (v33 != v31);
          }
          goto LABEL_66;
        }
        int v27 = *(_DWORD *)(v20 + 20);
        if ((v27 & 0x40000000) != 0)
        {
          uint64_t v29 = *(uint64_t **)(v20 - 8);
          uint64_t v28 = v27 & 0x7FFFFFF;
          if (v28)
          {
LABEL_58:
            uint64_t v36 = 32 * v28;
            do
            {
              uint64_t v37 = *v29;
              if (*v29) {
                BOOL v38 = *(unsigned __int8 *)(*v29 + 16) >= 0x1Cu;
              }
              else {
                BOOL v38 = 0;
              }
              if (v38)
              {
                v55[0] = &v57;
                sub_1CD339D6C((uint64_t)a2, v37, (void (*)(uint64_t, uint64_t))sub_1CD349A68, (uint64_t)v55);
              }
              v29 += 4;
              v36 -= 32;
            }
            while (v36);
          }
        }
        else
        {
          uint64_t v28 = v27 & 0x7FFFFFF;
          uint64_t v29 = (uint64_t *)(v20 - 32 * v28);
          if (v28) {
            goto LABEL_58;
          }
        }
LABEL_66:
        uint64_t v39 = *((unsigned int *)v14 + 14);
        if (v39)
        {
          uint64_t v40 = v14[6];
          uint64_t v41 = v40 + 8 * v39;
          do
          {
            uint64_t v42 = *(void *)v40;
            if (*(_DWORD *)(*(void *)v40 + 152) != -1)
            {
              --*(_DWORD *)(v42 + 156);
              uint64_t v43 = *(void *)(v42 + 24);
              if (v43)
              {
                int v44 = 0;
                uint64_t v45 = v43;
                while (1)
                {
                  int v46 = *(_DWORD *)(v45 + 156);
                  if (v46 == -1) {
                    break;
                  }
                  v44 += v46;
                  uint64_t v45 = *(void *)(v45 + 32);
                  if (!v45)
                  {
                    if (v44) {
                      break;
                    }
                    goto LABEL_74;
                  }
                }
              }
              else
              {
LABEL_74:
                sub_1CD3499A4((uint64_t *)&v57, v43);
              }
            }
            v40 += 8;
          }
          while (v40 != v41);
        }
        uint64_t v47 = *((unsigned int *)v14 + 26);
        if (v47)
        {
          uint64_t v48 = v14[12];
          uint64_t v49 = v48 + 8 * v47;
          do
          {
            uint64_t v50 = *(void *)v48;
            *(_DWORD *)(v50 + 156) = *(_DWORD *)(*(void *)v48 + 156) - 1;
            uint64_t v51 = *(void *)(v50 + 24);
            if (v51)
            {
              int v52 = 0;
              uint64_t v53 = v51;
              while (1)
              {
                int v54 = *(_DWORD *)(v53 + 156);
                if (v54 == -1) {
                  break;
                }
                v52 += v54;
                uint64_t v53 = *(void *)(v53 + 32);
                if (!v53)
                {
                  if (v52) {
                    break;
                  }
                  goto LABEL_83;
                }
              }
            }
            else
            {
LABEL_83:
              sub_1CD3499A4((uint64_t *)&v57, v51);
            }
            v48 += 8;
          }
          while (v48 != v49);
        }
LABEL_85:
        int v14 = (uint64_t *)v14[4];
      }
      while (v14);
    }
    a2[17] = 0;
    sub_1CBB0D544(v58);
  }
}

unsigned __int8 *sub_1CD337DF8(uint64_t ***a1, unsigned __int8 *a2)
{
  uint64_t v2 = a2;
  unsigned int v3 = **a1;
  if (*v3 == *(void *)a2) {
    return v2;
  }
  uint64_t v5 = a1[1];
  if (*((unsigned char *)v3 + 16) == 89)
  {
    a2 = (unsigned __int8 *)*(v3 - 8);
    BOOL v6 = (unsigned __int8 *)*(v3 - 4);
  }
  else
  {
    BOOL v6 = (unsigned __int8 *)*a1[2];
  }
  __int16 v35 = 257;
  uint64_t v2 = (unsigned __int8 *)sub_1CB8445F4((uint64_t)(v5 + 251), a2, v6, (uint64_t)v34);
  uint64_t v7 = (uint64_t *)a1[3];
  BOOL v8 = v5[268];
  uint64_t v9 = *((unsigned int *)v5 + 540);
  if (v9)
  {
    LODWORD(v10) = ((*v7 >> 4) ^ (*v7 >> 9)) & (v9 - 1);
    int v11 = &v8[2 * v10];
    uint64_t v12 = *v11;
    if (*v7 == *v11) {
      goto LABEL_12;
    }
    int v13 = 1;
    while (v12 != -4096)
    {
      int v14 = v10 + v13++;
      uint64_t v10 = v14 & (v9 - 1);
      uint64_t v12 = v8[2 * v10];
      if (*v7 == v12)
      {
        int v11 = &v8[2 * v10];
        goto LABEL_12;
      }
    }
  }
  int v11 = &v8[2 * v9];
LABEL_12:
  if (v11 != &v8[2 * v9])
  {
    uint64_t v16 = sub_1CD8DDDCC((uint64_t)(v5 + 268), v7);
    uint64_t v17 = ***a1;
    if (*(unsigned char *)(v16 + 8))
    {
      __int16 v33 = 257;
      if (*(void *)v2 != v17)
      {
        if (v2[16] <= 0x14u)
        {
          uint64_t v2 = (unsigned __int8 *)(*(uint64_t (**)(uint64_t *, uint64_t, unsigned __int8 *, uint64_t))(*v5[260] + 224))(v5[260], 40, v2, v17);
          if (v2) {
            BOOL v24 = v2[16] >= 0x1Cu;
          }
          else {
            BOOL v24 = 0;
          }
          if (v24)
          {
            (*(void (**)(uint64_t *, unsigned __int8 *, unsigned char *, uint64_t *, uint64_t *))(*v5[261] + 16))(v5[261], v2, v32, v5[257], v5[258]);
            uint64_t v25 = *((unsigned int *)v5 + 504);
            if (v25)
            {
              uint64_t v26 = v5[251];
              int v27 = &v26[2 * v25];
              do
              {
                llvm::Instruction::setMetadata((llvm::Instruction *)v2, *(_DWORD *)v26, (llvm::MDNode *)v26[1]);
                v26 += 2;
              }
              while (v26 != v27);
            }
          }
        }
        else
        {
          __int16 v35 = 257;
          uint64_t v2 = (unsigned __int8 *)llvm::CastInst::Create(40, (uint64_t)v2, v17, v34, 0);
          (*(void (**)(uint64_t *, unsigned __int8 *, unsigned char *, uint64_t *, uint64_t *))(*v5[261] + 16))(v5[261], v2, v32, v5[257], v5[258]);
          uint64_t v18 = *((unsigned int *)v5 + 504);
          if (v18)
          {
            unsigned int v19 = v5[251];
            uint64_t v20 = &v19[2 * v18];
            do
            {
              llvm::Instruction::setMetadata((llvm::Instruction *)v2, *(_DWORD *)v19, (llvm::MDNode *)v19[1]);
              v19 += 2;
            }
            while (v19 != v20);
          }
        }
      }
    }
    else
    {
      __int16 v33 = 257;
      if (*(void *)v2 != v17)
      {
        if (v2[16] <= 0x14u)
        {
          uint64_t v2 = (unsigned __int8 *)(*(uint64_t (**)(uint64_t *, uint64_t, unsigned __int8 *, uint64_t))(*v5[260] + 224))(v5[260], 39, v2, v17);
          if (v2) {
            BOOL v28 = v2[16] >= 0x1Cu;
          }
          else {
            BOOL v28 = 0;
          }
          if (v28)
          {
            (*(void (**)(uint64_t *, unsigned __int8 *, unsigned char *, uint64_t *, uint64_t *))(*v5[261] + 16))(v5[261], v2, v32, v5[257], v5[258]);
            uint64_t v29 = *((unsigned int *)v5 + 504);
            if (v29)
            {
              uint64_t v30 = v5[251];
              uint64_t v31 = &v30[2 * v29];
              do
              {
                llvm::Instruction::setMetadata((llvm::Instruction *)v2, *(_DWORD *)v30, (llvm::MDNode *)v30[1]);
                v30 += 2;
              }
              while (v30 != v31);
            }
          }
        }
        else
        {
          __int16 v35 = 257;
          uint64_t v2 = (unsigned __int8 *)llvm::CastInst::Create(39, (uint64_t)v2, v17, v34, 0);
          (*(void (**)(uint64_t *, unsigned __int8 *, unsigned char *, uint64_t *, uint64_t *))(*v5[261] + 16))(v5[261], v2, v32, v5[257], v5[258]);
          uint64_t v21 = *((unsigned int *)v5 + 504);
          if (v21)
          {
            unsigned int v22 = v5[251];
            uint64_t v23 = &v22[2 * v21];
            do
            {
              llvm::Instruction::setMetadata((llvm::Instruction *)v2, *(_DWORD *)v22, (llvm::MDNode *)v22[1]);
              v22 += 2;
            }
            while (v22 != v23);
          }
        }
      }
    }
  }
  return v2;
}

void llvm::slpvectorizer::BoUpSLP::optimizeGatherSequence(llvm::slpvectorizer::BoUpSLP *this)
{
  v56[8] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (void **)*((void *)this + 223);
  for (uint64_t i = (void **)*((void *)this + 224); v2 != i; ++v2)
  {
    __int16 v35 = *v2;
    uint64_t v51 = *v2;
    int v54 = 0;
    if ((sub_1CD50F704((uint64_t *)this + 131, &v51, &v54) & 1) == 0)
    {
      uint64_t v36 = (uint64_t *)*((void *)this + 244);
      int v37 = *((_DWORD *)v36 + 4);
      if (v37)
      {
        uint64_t v38 = v35[5];
        uint64_t v39 = *v36;
        unsigned int v40 = v37 - 1;
        uint64_t v41 = ((v38 >> 4) ^ (v38 >> 9)) & (v37 - 1);
        uint64_t v42 = *(void *)(v39 + 16 * v41);
        if (v38 == v42)
        {
LABEL_71:
          if (*(void *)(v39 + 16 * v41 + 8))
          {
            uint64_t v51 = 0;
            llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getLoopPredecessor();
          }
        }
        else
        {
          int v43 = 1;
          while (v42 != -4096)
          {
            int v44 = v41 + v43++;
            uint64_t v41 = v44 & v40;
            uint64_t v42 = *(void *)(v39 + 16 * v41);
            if (v38 == v42) {
              goto LABEL_71;
            }
          }
        }
      }
    }
  }
  int v54 = v56;
  uint64_t v55 = 0x800000000;
  int v4 = (char *)*((void *)this + 230);
  uint64_t v5 = (char *)*((void *)this + 229);
  if ((unint64_t)(v4 - v5) >= 0x41) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  uint64_t v45 = (uint64_t *)((char *)this + 1760);
  while (v5 != v4)
  {
    uint64_t v6 = *((void *)this + 245);
    uint64_t v7 = *(void *)(v6 + 24);
    uint64_t v8 = *(unsigned int *)(v6 + 40);
    if (!v8) {
      goto LABEL_12;
    }
    LODWORD(v9) = ((*(void *)v5 >> 4) ^ (*(void *)v5 >> 9)) & (v8 - 1);
    uint64_t v10 = (uint64_t *)(v7 + 16 * v9);
    uint64_t v11 = *v10;
    if (*(void *)v5 != *v10)
    {
      int v12 = 1;
      while (v11 != -4096)
      {
        int v13 = v9 + v12++;
        uint64_t v9 = v13 & (v8 - 1);
        uint64_t v11 = *(void *)(v7 + 16 * v9);
        if (*(void *)v5 == v11)
        {
          uint64_t v10 = (uint64_t *)(v7 + 16 * v9);
          goto LABEL_13;
        }
      }
LABEL_12:
      uint64_t v10 = (uint64_t *)(v7 + 16 * v8);
    }
LABEL_13:
    if (v10 != (uint64_t *)(v7 + 16 * v8))
    {
      uint64_t v14 = v10[1];
      if (v14)
      {
        if (v55 >= (unint64_t)HIDWORD(v55)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        v54[v55] = v14;
        LODWORD(v55) = v55 + 1;
      }
    }
    v5 += 8;
  }
  unint64_t v15 = 126 - 2 * __clz(v55);
  if (v55) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  sub_1CD348DC4(v54, &v54[v55], v16, 1);
  uint64_t v51 = v53;
  uint64_t v52 = 0x1000000000;
  if (v55)
  {
    uint64_t v17 = v54;
    int v46 = &v54[v55];
    uint64_t v18 = (uint64_t *)((char *)this + 1048);
    do
    {
      uint64_t v19 = *(void *)*v17;
      uint64_t v20 = v19 + 40;
      uint64_t v21 = *(void *)(v19 + 48);
      if (v21 != v19 + 40)
      {
        do
        {
          uint64_t v22 = *(void *)(v21 + 8);
          if (v21) {
            uint64_t v23 = (unsigned char *)(v21 - 24);
          }
          else {
            uint64_t v23 = 0;
          }
          __src[0] = v23;
          v48[0] = 0;
          if ((sub_1CD50F704(v18, __src, v48) & 1) == 0)
          {
            if (v23[16] - 89 < 3
              || ((__src[0] = v23, v48[0] = 0, !sub_1CD50F704(v45, __src, v48))
                ? (v33 = *((void *)this + 220), v34 = *((unsigned int *)this + 444), uint64_t v32 = v33 + 8 * v34)
                : (uint64_t v32 = v48[0], v33 = *((void *)this + 220), v34 = *((unsigned int *)this + 444)),
                  v32 != v33 + 8 * v34))
            {
              if (v52)
              {
                BOOL v24 = (llvm::Instruction **)v51;
                uint64_t v25 = 8 * v52 - 8;
                do
                {
                  __src[0] = v50;
                  __src[1] = (void *)0xC00000000;
                  if (sub_1CD338A00((uint64_t)this, (llvm::Instruction *)v23, *v24, (uint64_t)__src)) {
                    llvm::DominatorTreeBase<llvm::BasicBlock,false>::dominates();
                  }
                  if (v23[16] == 91)
                  {
                    uint64_t v26 = *v24;
                    if (*((unsigned char *)*v24 + 16) == 91)
                    {
                      uint64_t v47 = 0;
                      v48[0] = v26;
                      if (sub_1CD50F704(v45, v48, &v47))
                      {
                        uint64_t v28 = v47;
                        uint64_t v29 = *((void *)this + 220);
                        uint64_t v30 = *((unsigned int *)this + 444);
                      }
                      else
                      {
                        uint64_t v29 = *((void *)this + 220);
                        uint64_t v30 = *((unsigned int *)this + 444);
                        uint64_t v28 = v29 + 8 * v30;
                      }
                      if (v28 != v29 + 8 * v30
                        && sub_1CD338A00((uint64_t)this, *v24, (llvm::Instruction *)v23, (uint64_t)__src))
                      {
                        llvm::DominatorTreeBase<llvm::BasicBlock,false>::dominates();
                      }
                    }
                  }
                  if (__src[0] != v50) {
                    free(__src[0]);
                  }
                  ++v24;
                  BOOL v27 = v25 == 0;
                  v25 -= 8;
                }
                while (!v27);
                uint64_t v18 = (uint64_t *)((char *)this + 1048);
                unint64_t v31 = v52;
              }
              else
              {
                unint64_t v31 = 0;
              }
              if (v31 >= HIDWORD(v52)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((void *)v51 + v31) = v23;
              LODWORD(v52) = v52 + 1;
            }
          }
          uint64_t v21 = v22;
        }
        while (v22 != v20);
      }
      ++v17;
    }
    while (v17 != v46);
  }
  sub_1CBFC9A80((_DWORD *)this + 452);
  *((void *)this + 230) = *((void *)this + 229);
  sub_1CD47558C(v45);
  *((void *)this + 224) = *((void *)this + 223);
  if (v51 != v53) {
    free(v51);
  }
  if (v54 != v56) {
    free(v54);
  }
}

uint64_t sub_1CD338A00(uint64_t a1, llvm::Instruction *this, llvm::Instruction *a3, uint64_t a4)
{
  if (*(void *)this != *(void *)a3) {
    return 0;
  }
  int v7 = *((unsigned __int8 *)this + 16);
  int v8 = *((unsigned __int8 *)a3 + 16);
  if (v8 == 91) {
    uint64_t v9 = a3;
  }
  else {
    uint64_t v9 = 0;
  }
  if (v7 == 91) {
    uint64_t v10 = this;
  }
  else {
    uint64_t v10 = 0;
  }
  if (v7 == 91 && v8 == 91)
  {
    if (llvm::Instruction::isIdenticalToWhenDefined(v10, v9)
      && (*((unsigned __int8 *)v9 + 17) ^ *((unsigned __int8 *)v10 + 17)) < 2)
    {
      return 1;
    }
    uint64_t v13 = 0;
    char v14 = 1;
    while (1)
    {
      char v15 = v14;
      if (*((void *)v10 + 4 * v13 - 8) != *((void *)v9 + 4 * v13 - 8)) {
        return 0;
      }
      char v14 = 0;
      uint64_t v13 = 1;
      if ((v15 & 1) == 0)
      {
        uint64_t v16 = (const void *)*((void *)v9 + 8);
        uint64_t v17 = *((unsigned int *)v9 + 18);
        *(_DWORD *)(a4 + 8) = 0;
        if (v17 > *(_DWORD *)(a4 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v17)
        {
          memcpy(*(void **)a4, v16, 4 * v17);
          int v18 = *(_DWORD *)(a4 + 8);
        }
        else
        {
          int v18 = 0;
        }
        uint64_t v19 = (v18 + v17);
        *(_DWORD *)(a4 + 8) = v19;
        uint64_t v20 = *((unsigned int *)v10 + 18);
        if ((int)v19 < 1)
        {
          unsigned int v21 = 0;
LABEL_41:
          if (v20 - (unint64_t)v21 >= 2)
          {
            int v29 = (*(uint64_t (**)(void, void))(***(void ***)(a1 + 1936) + 968))(**(void **)(a1 + 1936), *(void *)v10);
            uint64_t v30 = *(void *)(a1 + 1936);
            v31.n128_f64[0] = llvm::FixedVectorType::get(*(llvm::FixedVectorType **)(*(void *)v10 + 24), (llvm::Type *)(v20 - v21));
            return v29 == (*(unsigned int (**)(__n128))(**(void **)v30 + 968))(v31);
          }
        }
        else
        {
          unsigned int v21 = 0;
          uint64_t v22 = (int *)*((void *)v10 + 8);
          uint64_t v23 = *(int **)a4;
          while (1)
          {
            int v25 = *v22++;
            int v24 = v25;
            if (v25 == -1) {
              ++v21;
            }
            else {
              unsigned int v21 = 0;
            }
            int v26 = *v23;
            BOOL v27 = *v23 == -1 || v24 == -1;
            if (!v27 && v26 != v24) {
              break;
            }
            if (v26 == -1) {
              *uint64_t v23 = v24;
            }
            ++v23;
            if (!--v19) {
              goto LABEL_41;
            }
          }
        }
        return 0;
      }
    }
  }
  uint64_t result = llvm::Instruction::isIdenticalToWhenDefined(this, a3);
  if (result) {
    return (*((unsigned __int8 *)a3 + 17) ^ *((unsigned __int8 *)this + 17)) < 2;
  }
  return result;
}

void sub_1CD338C68(uint64_t a1, unint64_t a2)
{
}

uint64_t llvm::slpvectorizer::BoUpSLP::BlockScheduling::initScheduleData(uint64_t result, const llvm::Instruction *a2, const llvm::Instruction *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7 = result;
  uint64_t v32 = (uint64_t)a2;
  if (a2 != a3)
  {
    uint64_t v9 = (uint64_t)a2;
    do
    {
      if (sub_1CD34172C((llvm *)v9, a2))
      {
        uint64_t result = sub_1CD333588(v9);
        if (result) {
          goto LABEL_5;
        }
      }
      uint64_t v33 = 0;
      uint64_t result = sub_1CD40EA84(*(void *)(v7 + 40), *(_DWORD *)(v7 + 56), v9, &v33);
      if ((result & 1) == 0 || (uint64_t ScheduleDataChunks = *(void *)(v33 + 8)) == 0)
      {
        uint64_t ScheduleDataChunks = llvm::slpvectorizer::BoUpSLP::BlockScheduling::allocateScheduleDataChunks((llvm::slpvectorizer::BoUpSLP::BlockScheduling *)v7);
        uint64_t result = (uint64_t)sub_1CD467E2C(v7 + 40, &v32);
        *(void *)(result + 8) = ScheduleDataChunks;
        *(void *)uint64_t ScheduleDataChunks = v9;
      }
      int v13 = *(_DWORD *)(v7 + 180);
      *(unsigned char *)(ScheduleDataChunks + 160) = 0;
      *(void *)(ScheduleDataChunks + 32) = 0;
      *(void *)(ScheduleDataChunks + 40) = 0;
      *(void *)(ScheduleDataChunks + 16) = 0;
      *(void *)(ScheduleDataChunks + 24) = ScheduleDataChunks;
      *(_DWORD *)(ScheduleDataChunks + 144) = v13;
      *(void *)(ScheduleDataChunks + 152) = -1;
      *(_DWORD *)(ScheduleDataChunks + 56) = 0;
      *(_DWORD *)(ScheduleDataChunks + 104) = 0;
      *(void *)(ScheduleDataChunks + 8) = v9;
      int v14 = *(unsigned __int8 *)(v9 + 16);
      uint64_t v15 = (v14 - 33);
      if (v15 <= 0x37)
      {
        if (((1 << (v14 - 33)) & 0x8000000000041) != 0)
        {
          uint64_t v17 = *(void *)(v9 + 64);
          if (!v17 || (*(unsigned char *)(v17 + 20) & 4) == 0 && (*(unsigned char *)(v17 + 17) & 0x10) == 0)
          {
            LODWORD(v33) = 7;
            uint64_t result = sub_1CC5CB59C(v9, (__int32 *)&v33, 1uLL);
            if (result)
            {
              uint64_t v22 = *(void *)(v9 - 32);
              if (!v22
                || *(unsigned char *)(v22 + 16)
                || *(void *)(v22 + 24) != *(void *)(v9 + 72)
                || *(_DWORD *)(v22 + 36) != 7)
              {
                goto LABEL_41;
              }
            }
            uint64_t result = llvm::CallBase::hasFnAttrOnCalledFunction(v9, 66);
            if ((result & 1) == 0)
            {
              uint64_t result = llvm::CallBase::hasFnAttrOnCalledFunction(v9, 44);
              if (!result) {
                goto LABEL_41;
              }
            }
          }
          goto LABEL_30;
        }
        if (((1 << (v14 - 33)) & 0x808001C8000010) != 0) {
          goto LABEL_42;
        }
        if (v15 == 28)
        {
          if ((*(_WORD *)(v9 + 18) & 0x301) != 0) {
            goto LABEL_41;
          }
LABEL_30:
          int v14 = *(unsigned __int8 *)(v9 + 16);
        }
      }
      uint64_t v16 = (v14 - 33);
      if (v16 <= 0x37)
      {
        if (((1 << v16) & 0x8000000000041) != 0)
        {
          uint64_t v18 = *(void *)(v9 + 64);
          if (!v18 || (*(unsigned char *)(v18 + 17) & 0x30) == 0)
          {
            int v19 = *(_DWORD *)(v9 + 20);
            if (v19 < 0)
            {
              uint64_t v23 = v9 - 32 * (v19 & 0x7FFFFFF);
              uint64_t v26 = *(void *)(v23 - 8);
              uint64_t v24 = v23 - 8;
              uint64_t v25 = v26;
              if (v26)
              {
                uint64_t v27 = -v25;
                while (1)
                {
                  unsigned int v28 = *(_DWORD *)(*(void *)(v24 + v27) + 8);
                  BOOL v29 = v28 > 7;
                  int v30 = (1 << v28) & 0x83;
                  if (v29 || v30 == 0) {
                    break;
                  }
                  v27 += 16;
                  if (!v27) {
                    goto LABEL_35;
                  }
                }
LABEL_41:
                int v14 = *(unsigned __int8 *)(v9 + 16);
LABEL_42:
                if (v14 == 84)
                {
                  uint64_t v20 = *(void *)(v9 - 32);
                  if (v20)
                  {
                    if (!*(unsigned char *)(v20 + 16)
                      && *(void *)(v20 + 24) == *(void *)(v9 + 72)
                      && (*(unsigned char *)(v20 + 33) & 0x20) != 0)
                    {
                      int v21 = *(_DWORD *)(v20 + 36);
                      if (v21 == 244 || v21 == 272)
                      {
LABEL_55:
                        if (!*(unsigned char *)(v20 + 16)
                          && *(void *)(v20 + 24) == *(void *)(v9 + 72)
                          && (*(_DWORD *)(v20 + 36) - 287) <= 1)
                        {
                          *(unsigned char *)(v7 + 168) = 1;
                        }
                        goto LABEL_5;
                      }
                    }
                  }
                }
                if (a4) {
                  *(void *)(a4 + 40) = ScheduleDataChunks;
                }
                else {
                  *(void *)(v7 + 152) = ScheduleDataChunks;
                }
                a4 = ScheduleDataChunks;
                goto LABEL_53;
              }
            }
LABEL_35:
            uint64_t result = llvm::CallBase::hasFnAttrOnCalledFunction(v9, 45);
            if ((result & 1) == 0)
            {
              uint64_t result = llvm::CallBase::hasFnAttrOnCalledFunction(v9, 44);
              if (!result) {
                goto LABEL_41;
              }
            }
          }
        }
        else if (v16 == 27)
        {
          if ((*(_WORD *)(v9 + 18) & 0x301) != 0) {
            goto LABEL_41;
          }
        }
        else if (((1 << v16) & 0x808001D0000010) != 0)
        {
          goto LABEL_41;
        }
      }
      int v14 = *(unsigned __int8 *)(v9 + 16);
LABEL_53:
      if (v14 == 84)
      {
        uint64_t v20 = *(void *)(v9 - 32);
        if (v20) {
          goto LABEL_55;
        }
      }
LABEL_5:
      uint64_t v10 = *(void *)(v9 + 32);
      if (v10) {
        BOOL v11 = v10 == *(void *)(v9 + 40) + 40;
      }
      else {
        BOOL v11 = 1;
      }
      if (v11) {
        uint64_t v9 = 0;
      }
      else {
        uint64_t v9 = v10 - 24;
      }
      uint64_t v32 = v9;
    }
    while ((const llvm::Instruction *)v9 != a3);
  }
  if (a5)
  {
    if (a4) {
      *(void *)(a4 + 40) = a5;
    }
  }
  else
  {
    *(void *)(v7 + 160) = a4;
  }
  return result;
}

void llvm::slpvectorizer::BoUpSLP::BlockScheduling::calculateDependencies(uint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  v127[10] = *MEMORY[0x1E4F143B8];
  uint64_t v124 = v127;
  unsigned int v126 = 10;
  uint64_t v5 = v119;
  v127[0] = a2;
  uint64_t v117 = a4 + 384;
  uint64_t v113 = (void *)(a1 + 88);
  uint64_t v114 = a4 + 416;
  unsigned int v6 = 1;
  do
  {
    uint64_t v7 = *((void *)v124 + v6 - 1);
    unsigned int v125 = v6 - 1;
    uint64_t v120 = v7;
    while (v7)
    {
      if (*(_DWORD *)(v7 + 152) != -1) {
        goto LABEL_4;
      }
      *(void *)(v7 + 152) = 0;
      uint64_t v8 = *(void *)(v7 + 8);
      if (v8 == *(void *)v7)
      {
        for (uint64_t i = *(void *)(v8 + 8); i; uint64_t i = *(void *)(i + 8))
        {
          uint64_t v10 = sub_1CD8DFC80(a1, *(void *)(i + 24));
          if (v10)
          {
            ++*(_DWORD *)(v7 + 152);
            uint64_t v11 = *(void *)(v10 + 24);
            if (!*(unsigned char *)(v11 + 160)) {
              ++*(_DWORD *)(v7 + 156);
            }
            if (*(_DWORD *)(v11 + 152) == -1)
            {
              if (v125 >= (unint64_t)v126) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((void *)v124 + v125++) = v11;
            }
          }
        }
      }
      else
      {
        uint64_t v12 = sub_1CD8DFC80(a1, *(void *)v7);
        if (v12)
        {
          ++*(_DWORD *)(v7 + 152);
          uint64_t v13 = *(void *)(v12 + 24);
          if (!*(unsigned char *)(v13 + 160)) {
            ++*(_DWORD *)(v7 + 156);
          }
          if (*(_DWORD *)(v13 + 152) == -1)
          {
            if (v125 >= (unint64_t)v126) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((void *)v124 + v125++) = v13;
          }
        }
      }
      uint64_t v14 = *(void *)v7;
      int v15 = *(unsigned __int8 *)(*(void *)v7 + 16);
      if (v15 != 84)
      {
        switch(*(unsigned char *)(*(void *)v7 + 16))
        {
          case 0x1D:
          case 0x22:
          case 0x23:
            goto LABEL_70;
          case 0x1E:
          case 0x1F:
          case 0x20:
          case 0x21:
          case 0x25:
            goto LABEL_28;
          case 0x24:
          case 0x26:
            if ((*(_WORD *)(v14 + 18) & 1) == 0) {
              goto LABEL_70;
            }
            goto LABEL_28;
          default:
            if (v15 != 80) {
              goto LABEL_28;
            }
            PersonalityFn = (llvm::Value *)llvm::Function::getPersonalityFn(*(llvm::Function **)(*(void *)(v14 + 40)
                                                                                               + 56));
            if (llvm::classifyEHPersonality(PersonalityFn, v101) != 10) {
              goto LABEL_70;
            }
            goto LABEL_29;
        }
      }
      uint64_t v31 = *(void *)(v14 + 64);
      if (v31 && (*(unsigned char *)(v31 + 16) & 0x20) != 0
        || llvm::CallBase::hasFnAttrOnCalledFunction(*(void *)v7, 37))
      {
LABEL_28:
        if (llvm::Instruction::willReturn((llvm::Instruction *)v14)) {
          goto LABEL_29;
        }
      }
LABEL_70:
      uint64_t v32 = *(void *)(*(void *)v7 + 32);
      uint64_t v33 = v32 - 24;
      if (v32) {
        BOOL v34 = v32 == *(void *)(*(void *)v7 + 40) + 40;
      }
      else {
        BOOL v34 = 1;
      }
      while (1)
      {
        uint64_t v35 = v34 ? 0 : v33;
        if (v35 == *(void *)(a1 + 144)) {
          break;
        }
        uint64_t v36 = *(void *)(*(void *)a1 + 48);
        if (v36) {
          int v37 = (uint64_t *)(v36 - 24);
        }
        else {
          int v37 = 0;
        }
        if ((llvm::isSafeToSpeculativelyExecute(v35, v37, 0, 0) & 1) == 0)
        {
          uint64_t v39 = sub_1CD8DFC80(a1, v35);
          unint64_t v40 = *(unsigned int *)(v39 + 104);
          if (v40 >= *(unsigned int *)(v39 + 108)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)(v39 + 96) + 8 * v40) = v7;
          ++*(_DWORD *)(v39 + 104);
          ++*(_DWORD *)(v7 + 152);
          uint64_t v41 = *(void *)(v39 + 24);
          if (!*(unsigned char *)(v41 + 160)) {
            ++*(_DWORD *)(v7 + 156);
          }
          if (*(_DWORD *)(v41 + 152) == -1)
          {
            if (v125 >= (unint64_t)v126) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((void *)v124 + v125++) = v41;
          }
          int v42 = *(unsigned __int8 *)(v35 + 16);
          if (v42 != 84)
          {
            switch(*(unsigned char *)(v35 + 16))
            {
              case 0x1D:
              case 0x22:
              case 0x23:
                goto LABEL_29;
              case 0x1E:
              case 0x1F:
              case 0x20:
              case 0x21:
              case 0x25:
                goto LABEL_95;
              case 0x24:
              case 0x26:
                if ((*(_WORD *)(v35 + 18) & 1) == 0) {
                  goto LABEL_29;
                }
                goto LABEL_95;
              default:
                if (v42 != 80) {
                  goto LABEL_95;
                }
                int v44 = (llvm::Value *)llvm::Function::getPersonalityFn(*(llvm::Function **)(*(void *)(v35 + 40) + 56));
                if (llvm::classifyEHPersonality(v44, v45) != 10) {
                  goto LABEL_29;
                }
                goto LABEL_81;
            }
          }
          uint64_t v43 = *(void *)(v35 + 64);
          if ((!v43 || (*(unsigned char *)(v43 + 16) & 0x20) == 0)
            && !llvm::CallBase::hasFnAttrOnCalledFunction(v35, 37))
          {
            break;
          }
LABEL_95:
          if (!llvm::Instruction::willReturn((llvm::Instruction *)v35)) {
            break;
          }
        }
LABEL_81:
        uint64_t v38 = *(void *)(v35 + 32);
        uint64_t v33 = v38 - 24;
        if (v38) {
          BOOL v34 = v38 == *(void *)(v35 + 40) + 40;
        }
        else {
          BOOL v34 = 1;
        }
      }
LABEL_29:
      if (!*(unsigned char *)(a1 + 168)) {
        goto LABEL_132;
      }
      uint64_t v16 = *(void *)v7;
      int v17 = *(unsigned __int8 *)(*(void *)v7 + 16);
      if (*(void *)v7 && v17 == 84)
      {
        uint64_t v18 = *(void *)(v16 - 32);
        if (!v18
          || *(unsigned char *)(v18 + 16)
          || *(void *)(v18 + 24) != *(void *)(v16 + 72)
          || (*(_DWORD *)(v18 + 36) - 287) > 1)
        {
          goto LABEL_132;
        }
        uint64_t v20 = v16 + 32;
        uint64_t v19 = *(void *)(v16 + 32);
        uint64_t v21 = *(void *)(v20 + 8) + 40;
        BOOL v22 = !v19 || v19 == v21;
        uint64_t v23 = v22 ? 0 : v19 - 24;
        if (v23 == *(void *)(a1 + 144)) {
          goto LABEL_132;
        }
        do
        {
          int v24 = *(unsigned __int8 *)(v23 + 16);
          if (v23 && v24 == 84)
          {
            uint64_t v25 = *(void *)(v23 - 32);
            if (v25
              && !*(unsigned char *)(v25 + 16)
              && *(void *)(v25 + 24) == *(void *)(v23 + 72)
              && (*(_DWORD *)(v25 + 36) - 287) < 2)
            {
              break;
            }
          }
          else if (v24 == 59)
          {
            uint64_t v28 = sub_1CD8DFC80(a1, v23);
            unint64_t v29 = *(unsigned int *)(v28 + 104);
            if (v29 >= *(unsigned int *)(v28 + 108)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(*(void *)(v28 + 96) + 8 * v29) = v7;
            ++*(_DWORD *)(v28 + 104);
            ++*(_DWORD *)(v7 + 152);
            uint64_t v30 = *(void *)(v28 + 24);
            if (!*(unsigned char *)(v30 + 160)) {
              ++*(_DWORD *)(v7 + 156);
            }
            if (*(_DWORD *)(v30 + 152) == -1)
            {
              if (v125 >= (unint64_t)v126) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((void *)v124 + v125++) = v30;
            }
          }
          uint64_t v26 = *(void *)(v23 + 32);
          if (v26) {
            BOOL v27 = v26 == *(void *)(v23 + 40) + 40;
          }
          else {
            BOOL v27 = 1;
          }
          if (v27) {
            uint64_t v23 = 0;
          }
          else {
            uint64_t v23 = v26 - 24;
          }
        }
        while (v23 != *(void *)(a1 + 144));
        uint64_t v16 = *(void *)v7;
        int v17 = *(unsigned __int8 *)(*(void *)v7 + 16);
      }
      if (v17 == 59)
      {
        uint64_t v47 = v16 + 32;
        uint64_t v46 = *(void *)(v16 + 32);
        uint64_t v48 = *(void *)(v47 + 8) + 40;
        if (v46) {
          BOOL v49 = v46 == v48;
        }
        else {
          BOOL v49 = 1;
        }
        if (v49) {
          uint64_t v50 = 0;
        }
        else {
          uint64_t v50 = v46 - 24;
        }
        while (v50 != *(void *)(a1 + 144))
        {
          if (v50)
          {
            if (*(unsigned char *)(v50 + 16) == 84)
            {
              uint64_t v51 = *(void *)(v50 - 32);
              if (v51)
              {
                if (!*(unsigned char *)(v51 + 16)
                  && *(void *)(v51 + 24) == *(void *)(v50 + 72)
                  && (*(_DWORD *)(v51 + 36) - 287) <= 1)
                {
                  uint64_t v54 = sub_1CD8DFC80(a1, v50);
                  unint64_t v55 = *(unsigned int *)(v54 + 104);
                  if (v55 >= *(unsigned int *)(v54 + 108)) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  *(void *)(*(void *)(v54 + 96) + 8 * v55) = v7;
                  ++*(_DWORD *)(v54 + 104);
                  ++*(_DWORD *)(v7 + 152);
                  uint64_t v56 = *(void *)(v54 + 24);
                  if (!*(unsigned char *)(v56 + 160)) {
                    ++*(_DWORD *)(v7 + 156);
                  }
                  if (*(_DWORD *)(v56 + 152) == -1)
                  {
                    if (v125 >= (unint64_t)v126) {
                      llvm::SmallVectorBase<unsigned int>::grow_pod();
                    }
                    *((void *)v124 + v125++) = v56;
                  }
                  break;
                }
              }
            }
          }
          uint64_t v52 = *(void *)(v50 + 32);
          if (v52) {
            BOOL v53 = v52 == *(void *)(v50 + 40) + 40;
          }
          else {
            BOOL v53 = 1;
          }
          if (v53) {
            uint64_t v50 = 0;
          }
          else {
            uint64_t v50 = v52 - 24;
          }
        }
      }
LABEL_132:
      uint64_t v57 = *(uint64_t **)(v7 + 40);
      if (v57)
      {
        uint64_t v58 = *(void *)v7;
        int v59 = *(unsigned __int8 *)(*(void *)v7 + 16);
        if (*(void *)v7 && v59 == 61)
        {
          uint64_t v60 = *(void *)(*(void *)(*(void *)(v58 + 40) + 56) + 40) + 272;
          uint64_t v61 = *(void *)(v58 - 32);
          unint64_t v62 = **(uint64_t ****)(v58 - 64);
          goto LABEL_139;
        }
        if (v58 && v59 == 60)
        {
          uint64_t v60 = *(void *)(*(void *)(*(void *)(v58 + 40) + 56) + 40) + 272;
          uint64_t v61 = *(void *)(v58 - 32);
          unint64_t v62 = *(uint64_t ***)v58;
LABEL_139:
          uint64_t v63 = sub_1CB83544C(v60, (uint64_t)v62);
          if (v64 == 1) {
            unint64_t v65 = -2;
          }
          else {
            unint64_t v65 = (unint64_t)(v63 + 7) >> 3;
          }
          llvm::Instruction::getAAMetadata((uint64_t ***)v58, v5);
          *(void *)&long long v118 = v61;
          *((void *)&v118 + 1) = v65;
        }
        else
        {
          *(void *)&long long v118 = 0;
          *((void *)&v118 + 1) = -1;
          _OWORD *v5 = 0u;
          v5[1] = 0u;
        }
        char v66 = 0;
        uint64_t v67 = *(void *)v7;
        uint64_t v68 = *(unsigned __int8 *)(*(void *)v7 + 16) - 33;
        if (v68 <= 0x37)
        {
          if (((1 << (*(unsigned char *)(*(void *)v7 + 16) - 33)) & 0x8000000000041) == 0)
          {
            if (v68 == 27) {
              char v66 = (*(_WORD *)(v67 + 18) & 0x301) != 0;
            }
            else {
              char v66 = ((1 << (*(unsigned char *)(*(void *)v7 + 16) - 33)) & 0x808001D0000010) != 0;
            }
            goto LABEL_154;
          }
          uint64_t v69 = *(void *)(v67 + 64);
          if (!v69 || (*(unsigned char *)(v69 + 17) & 0x30) == 0)
          {
            int v70 = *(_DWORD *)(v67 + 20);
            if (v70 < 0)
            {
              uint64_t v102 = v67 - 32 * (v70 & 0x7FFFFFF);
              uint64_t v105 = *(void *)(v102 - 8);
              uint64_t v103 = v102 - 8;
              uint64_t v104 = v105;
              if (v105)
              {
                uint64_t v106 = -v104;
                while (1)
                {
                  unsigned int v107 = *(_DWORD *)(*(void *)(v103 + v106) + 8);
                  BOOL v89 = v107 > 7;
                  int v108 = (1 << v107) & 0x83;
                  if (v89 || v108 == 0) {
                    break;
                  }
                  v106 += 16;
                  if (!v106) {
                    goto LABEL_151;
                  }
                }
                char v66 = 1;
                goto LABEL_154;
              }
            }
LABEL_151:
            if ((llvm::CallBase::hasFnAttrOnCalledFunction(*(void *)v7, 45) & 1) == 0)
            {
              char v66 = llvm::CallBase::hasFnAttrOnCalledFunction(v67, 44) ^ 1;
              goto LABEL_154;
            }
          }
          char v66 = 0;
        }
LABEL_154:
        unsigned int v71 = 0;
        unsigned int v72 = 1;
        while (2)
        {
          if (v72 > 0x9F) {
            goto LABEL_158;
          }
          if (v66) {
            goto LABEL_157;
          }
          uint64_t v75 = *v57;
          uint64_t v76 = *(unsigned __int8 *)(*v57 + 16) - 33;
          if (v76 > 0x37) {
            goto LABEL_166;
          }
          if (((1 << (*(unsigned char *)(*v57 + 16) - 33)) & 0x8000000000041) == 0)
          {
            if (v76 == 27)
            {
              if ((*(_WORD *)(v75 + 18) & 0x301) != 0) {
                goto LABEL_157;
              }
            }
            else if (((1 << (*(unsigned char *)(*v57 + 16) - 33)) & 0x808001D0000010) != 0)
            {
              goto LABEL_157;
            }
LABEL_166:
            ++v72;
            uint64_t v57 = (uint64_t *)v57[5];
            if (!v57) {
              goto LABEL_4;
            }
            continue;
          }
          break;
        }
        uint64_t v77 = *(void *)(v75 + 64);
        if (v77 && (*(unsigned char *)(v77 + 17) & 0x30) != 0) {
          goto LABEL_166;
        }
        int v78 = *(_DWORD *)(v75 + 20);
        if (v78 < 0
          && (uint64_t v92 = v75 - 32 * (v78 & 0x7FFFFFF), v95 = *(void *)(v92 - 8), v93 = v92 - 8, (v94 = v95) != 0))
        {
          uint64_t v96 = -v94;
          while (1)
          {
            unsigned int v97 = *(_DWORD *)(*(void *)(v93 + v96) + 8);
            BOOL v89 = v97 > 7;
            int v98 = (1 << v97) & 0x83;
            if (v89 || v98 == 0) {
              break;
            }
            v96 += 16;
            if (!v96) {
              goto LABEL_176;
            }
          }
        }
        else
        {
LABEL_176:
          if ((llvm::CallBase::hasFnAttrOnCalledFunction(*v57, 45) & 1) != 0
            || (llvm::CallBase::hasFnAttrOnCalledFunction(v75, 44) & 1) != 0)
          {
            goto LABEL_166;
          }
        }
LABEL_157:
        if (v71 > 9)
        {
LABEL_158:
          unint64_t v73 = *((unsigned int *)v57 + 14);
          if (v73 >= *((unsigned int *)v57 + 15)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(v57[6] + 8 * v73) = v7;
          ++*((_DWORD *)v57 + 14);
          ++*(_DWORD *)(v7 + 152);
          uint64_t v74 = v57[3];
          if (!*(unsigned char *)(v74 + 160)) {
            ++*(_DWORD *)(v7 + 156);
          }
          if (*(_DWORD *)(v74 + 152) == -1)
          {
            if (v125 >= (unint64_t)v126) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((void *)v124 + v125++) = v74;
          }
          if (v72 > 0x13F) {
            goto LABEL_4;
          }
          ++v71;
          goto LABEL_166;
        }
        uint64_t v79 = v5;
        uint64_t v80 = (llvm::Instruction *)*v57;
        v123[0] = v58;
        v123[1] = (uint64_t)v80;
        unsigned int v81 = sub_1CD8E46F4(v117, v123);
        BOOL v82 = v81;
        if (*((unsigned char *)v81 + 17))
        {
          int v83 = *((unsigned __int8 *)v81 + 16);
          goto LABEL_206;
        }
        if ((void)v118)
        {
          int v84 = *(unsigned __int8 *)(v58 + 16);
          if (v58 && v84 == 60 || v58 && v84 == 61)
          {
            if ((*(_WORD *)(v58 + 18) & 0x381) != 0) {
              goto LABEL_189;
            }
LABEL_202:
            v121[0] = v118;
            v121[1] = v119[0];
            v121[2] = v119[1];
            char v122 = 1;
            int v83 = (llvm::AAResults::getModRefInfo(*(void *)(a4 + 408), v80, v121, v114) & 3) != 0;
          }
          else
          {
            if (!sub_1CBFB3AB0(v58)) {
              goto LABEL_202;
            }
            uint64_t v85 = *(void *)(v58 + 96 - 32 * (*(_DWORD *)(v58 + 20) & 0x7FFFFFF));
            uint64_t v86 = *(unsigned int *)(v85 + 32);
            if (v86 > 0x40)
            {
              int v87 = 0;
              int64_t v88 = (unint64_t)(v86 + 63) >> 6;
              do
              {
                BOOL v89 = v88-- < 1;
                if (v89) {
                  break;
                }
                unint64_t v90 = *(void *)(*(void *)(v85 + 24) + 8 * v88);
                v87 += __clz(v90);
              }
              while (!v90);
              int v91 = v86 | 0xFFFFFFC0;
              if ((v86 & 0x3F) == 0) {
                int v91 = 0;
              }
              if (v87 + v91 == v86) {
                goto LABEL_202;
              }
            }
            else if (!*(void *)(v85 + 24))
            {
              goto LABEL_202;
            }
LABEL_189:
            int v83 = 1;
          }
          if (*((unsigned char *)v82 + 17))
          {
            *((unsigned char *)v82 + 16) = v83;
            goto LABEL_206;
          }
        }
        else
        {
          int v83 = 1;
        }
        *((unsigned char *)v82 + 16) = v83;
        *((unsigned char *)v82 + 17) = 1;
LABEL_206:
        uint64_t v5 = v79;
        if (!v83) {
          goto LABEL_166;
        }
        goto LABEL_158;
      }
LABEL_4:
      uint64_t v7 = *(void *)(v7 + 32);
    }
    if (a3)
    {
      if (v120)
      {
        int v110 = 0;
        uint64_t v111 = v120;
        while (1)
        {
          int v112 = *(_DWORD *)(v111 + 156);
          if (v112 == -1) {
            break;
          }
          v110 += v112;
          uint64_t v111 = *(void *)(v111 + 32);
          if (!v111)
          {
            if (v110) {
              break;
            }
            goto LABEL_238;
          }
        }
      }
      else
      {
LABEL_238:
        if (!*(unsigned char *)(v120 + 160)) {
          sub_1CC37AF14(v113, &v120);
        }
      }
    }
    unsigned int v6 = v125;
  }
  while (v125);
  if (v124 != v127) {
    free(v124);
  }
}

uint64_t sub_1CD339D6C(uint64_t a1, uint64_t a2, void (*a3)(uint64_t, uint64_t), uint64_t a4)
{
  if (a2)
  {
    if (*(unsigned __int8 *)(a2 + 16) >= 0x1Cu)
    {
      uint64_t v8 = sub_1CD8DFC80(a1, a2);
      if (v8) {
        a3(a4, v8);
      }
    }
  }
  uint64_t v18 = 0;
  uint64_t result = sub_1CD4C612C(*(void *)(a1 + 64), *(_DWORD *)(a1 + 80), a2, &v18);
  uint64_t v10 = v18;
  if (result) {
    BOOL v11 = v18 == *(void *)(a1 + 64) + 80 * *(unsigned int *)(a1 + 80);
  }
  else {
    BOOL v11 = 1;
  }
  if (!v11)
  {
    uint64_t result = (uint64_t)sub_1CD89224C((int *)(v18 + 8));
    uint64_t v13 = (void *)result;
    uint64_t v14 = v12;
    if (*(unsigned char *)(v10 + 8))
    {
      uint64_t v15 = v10 + 16;
      uint64_t v16 = 4;
    }
    else
    {
      uint64_t v15 = *(void *)(v10 + 16);
      uint64_t v16 = *(unsigned int *)(v10 + 24);
    }
    int v17 = (void *)(v15 + 16 * v16);
    if (v17 != (void *)result)
    {
      do
      {
        if (*(_DWORD *)(v13[1] + 144) == *(_DWORD *)(a1 + 180)) {
          uint64_t result = ((uint64_t (*)(uint64_t))a3)(a4);
        }
        while (1)
        {
          v13 += 2;
          if (v13 == v14) {
            break;
          }
          if ((*v13 | 0x1000) != 0xFFFFFFFFFFFFF000) {
            goto LABEL_21;
          }
        }
        uint64_t v13 = v14;
LABEL_21:
        ;
      }
      while (v13 != v17);
    }
  }
  return result;
}

uint64_t llvm::slpvectorizer::BoUpSLP::getVectorElementSize(llvm::slpvectorizer::BoUpSLP *this, llvm::Value *a2)
{
  uint64_t v2 = a2;
  v86[32] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = (unsigned __int8 *)a2 + 16;
  int v4 = *((unsigned __int8 *)a2 + 16);
  BOOL v6 = a2 == 0;
  if (a2 && v4 == 61)
  {
LABEL_3:
    uint64_t v7 = *((void *)v2 - 8);
    uint64_t v8 = *((void *)this + 248);
    if (v7 && *(unsigned char *)(v7 + 16) == 66)
    {
      uint64_t v10 = sub_1CB83544C(v8, **(void **)(v7 - 32));
      if (v9 != 1) {
        return v10;
      }
    }
    else
    {
      uint64_t v10 = sub_1CB83544C(v8, *(void *)v7);
      if (v9 != 1) {
        return v10;
      }
    }
    return v10;
  }
  if (a2 && v4 == 90)
  {
    do
    {
      uint64_t v2 = (llvm::Value *)*((void *)v2 - 8);
      int v11 = *((unsigned __int8 *)v2 + 16);
      BOOL v6 = v2 == 0;
      if (v2 && v11 == 61) {
        goto LABEL_3;
      }
    }
    while (v2 && v11 == 90);
    uint64_t v5 = (unsigned __int8 *)v2 + 16;
  }
  uint64_t v12 = (_DWORD *)((char *)this + 152);
  uint64_t v13 = sub_1CD8DFD8C((uint64_t)this + 152, (uint64_t)v2);
  if (*((unsigned char *)this + 152))
  {
    uint64_t v14 = (char *)this + 160;
    uint64_t v15 = 4;
  }
  else
  {
    uint64_t v14 = (char *)*((void *)this + 20);
    uint64_t v15 = *((unsigned int *)this + 42);
  }
  if (&v14[16 * v15] != (char *)v13) {
    return *(unsigned int *)(v13 + 8);
  }
  int v84 = v86;
  uint64_t v85 = 0x1000000000;
  uint64_t v79 = v83;
  uint64_t v80 = v83;
  uint64_t v81 = 16;
  int v82 = 0;
  if (*v5 < 0x1Cu) {
    goto LABEL_55;
  }
  unint64_t v78 = *((void *)v2 + 5);
  sub_1CCD94EF8((uint64_t)&v84, (uint64_t)v2, &v78);
  int v17 = v80;
  uint64_t v18 = HIDWORD(v81);
  if (v80 != v79)
  {
    unsigned int v22 = v81;
    goto LABEL_34;
  }
  if (HIDWORD(v81))
  {
    uint64_t v19 = 0;
    uint64_t v20 = 8 * HIDWORD(v81);
    uint64_t v21 = (llvm::Value **)v80;
    while (*v21 != v2)
    {
      if (*v21 == (llvm::Value *)-2) {
        uint64_t v19 = v21;
      }
      ++v21;
      v20 -= 8;
      if (!v20)
      {
        if (!v19) {
          goto LABEL_31;
        }
        *uint64_t v19 = v2;
        --v82;
        goto LABEL_55;
      }
    }
    goto LABEL_55;
  }
LABEL_31:
  unsigned int v22 = v81;
  if (HIDWORD(v81) >= v81)
  {
LABEL_34:
    if (3 * v22 <= 4 * (HIDWORD(v81) - v82))
    {
      if (v22 >= 0x40) {
        v22 *= 2;
      }
      else {
        unsigned int v22 = 128;
      }
    }
    else if (v22 - HIDWORD(v81) >= v22 >> 3)
    {
      goto LABEL_36;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v79, v22);
    unsigned int v22 = v81;
    int v17 = v80;
LABEL_36:
    unsigned int v23 = v22 - 1;
    unsigned int v24 = (v22 - 1) & ((v2 >> 4) ^ (v2 >> 9));
    uint64_t v25 = (llvm::Value **)&v17[8 * v24];
    uint64_t v26 = *v25;
    if (*v25 == (llvm::Value *)-1)
    {
      BOOL v27 = 0;
LABEL_48:
      if (v27) {
        uint64_t v31 = v27;
      }
      else {
        uint64_t v31 = v25;
      }
      if (*v31 != v2)
      {
        if (*v31 == (llvm::Value *)-2) {
          --v82;
        }
        else {
          ++HIDWORD(v81);
        }
        uint64_t *v31 = v2;
      }
    }
    else
    {
      BOOL v27 = 0;
      int v28 = 1;
      while (v26 != v2)
      {
        if (v27) {
          BOOL v29 = 0;
        }
        else {
          BOOL v29 = v26 == (llvm::Value *)-2;
        }
        if (v29) {
          BOOL v27 = v25;
        }
        unsigned int v30 = v24 + v28++;
        unsigned int v24 = v30 & v23;
        uint64_t v25 = (llvm::Value **)&v17[8 * (v30 & v23)];
        uint64_t v26 = *v25;
        if (*v25 == (llvm::Value *)-1) {
          goto LABEL_48;
        }
      }
    }
    goto LABEL_55;
  }
  ++HIDWORD(v81);
  *(void *)&v80[8 * v18] = v2;
LABEL_55:
  unsigned int v32 = v85;
  if (!v85) {
    goto LABEL_138;
  }
  uint64_t v10 = 0;
  do
  {
    uint64_t v33 = (char *)v84 + 16 * v32;
    BOOL v34 = (unsigned __int8 *)*((void *)v33 - 2);
    unint64_t v35 = *((void *)v33 - 1);
    LODWORD(v85) = v32 - 1;
    if ((*(_DWORD *)(*(void *)v34 + 8) & 0xFE) == 0x12) {
      goto LABEL_69;
    }
    unsigned int v36 = v34[16];
    if (v36 > 0x58)
    {
      if (v36 == 92 || v36 == 89)
      {
LABEL_64:
        unsigned int v38 = sub_1CB83544C(*((void *)this + 248), *(void *)v34);
        if (v37 == 1) {
        if (v10 <= v38)
        }
          uint64_t v10 = v38;
        else {
          uint64_t v10 = v10;
        }
        goto LABEL_69;
      }
    }
    else
    {
      if (v36 == 60) {
        goto LABEL_64;
      }
      if (v36 == 83) {
        goto LABEL_83;
      }
    }
    if (v36 != 40 && v36 != 85)
    {
      BOOL v39 = v36 != 62 && v36 - 66 >= 0xD;
      BOOL v40 = v39 && v36 - 81 >= 2;
      if (v40 && v36 - 41 > 0x11) {
        break;
      }
    }
LABEL_83:
    int v42 = *((_DWORD *)v34 + 5);
    if ((v42 & 0x40000000) != 0)
    {
      int v44 = (uint64_t *)*((void *)v34 - 1);
      uint64_t v43 = v42 & 0x7FFFFFF;
    }
    else
    {
      uint64_t v43 = v42 & 0x7FFFFFF;
      int v44 = (uint64_t *)&v34[-32 * v43];
    }
    if (v43)
    {
      uint64_t v45 = &v44[4 * v43];
      while (1)
      {
        uint64_t v46 = *v44;
        if (*v44) {
          BOOL v47 = *(unsigned __int8 *)(*v44 + 16) >= 0x1Cu;
        }
        else {
          BOOL v47 = 0;
        }
        if (!v47) {
          goto LABEL_129;
        }
        uint64_t v48 = v80;
        uint64_t v49 = HIDWORD(v81);
        if (v80 == v79)
        {
          if (HIDWORD(v81))
          {
            uint64_t v50 = 0;
            uint64_t v51 = 8 * HIDWORD(v81);
            uint64_t v52 = (uint64_t *)v80;
            while (*v52 != v46)
            {
              if (*v52 == -2) {
                uint64_t v50 = v52;
              }
              ++v52;
              v51 -= 8;
              if (!v51)
              {
                if (!v50) {
                  goto LABEL_101;
                }
                *uint64_t v50 = v46;
                --v82;
                goto LABEL_125;
              }
            }
            goto LABEL_129;
          }
LABEL_101:
          unsigned int v53 = v81;
          if (HIDWORD(v81) < v81)
          {
            ++HIDWORD(v81);
            *(void *)&v80[8 * v49] = v46;
            goto LABEL_125;
          }
        }
        else
        {
          unsigned int v53 = v81;
        }
        if (3 * v53 <= 4 * (HIDWORD(v81) - v82)) {
          break;
        }
        if (v53 - HIDWORD(v81) < v53 >> 3) {
          goto LABEL_136;
        }
LABEL_106:
        unsigned int v54 = v53 - 1;
        unsigned int v55 = (v53 - 1) & ((v46 >> 4) ^ (v46 >> 9));
        uint64_t v56 = (uint64_t *)&v48[8 * v55];
        uint64_t v57 = *v56;
        if (*v56 != -1)
        {
          uint64_t v58 = 0;
          int v59 = 1;
          while (v57 != v46)
          {
            if (v58) {
              BOOL v60 = 0;
            }
            else {
              BOOL v60 = v57 == -2;
            }
            if (v60) {
              uint64_t v58 = v56;
            }
            unsigned int v61 = v55 + v59++;
            unsigned int v55 = v61 & v54;
            uint64_t v56 = (uint64_t *)&v48[8 * (v61 & v54)];
            uint64_t v57 = *v56;
            if (*v56 == -1) {
              goto LABEL_118;
            }
          }
          goto LABEL_129;
        }
        uint64_t v58 = 0;
LABEL_118:
        if (v58) {
          unint64_t v62 = v58;
        }
        else {
          unint64_t v62 = v56;
        }
        if (*v62 == v46) {
          goto LABEL_129;
        }
        if (*v62 == -2) {
          --v82;
        }
        else {
          ++HIDWORD(v81);
        }
        uint64_t *v62 = v46;
LABEL_125:
        unint64_t v63 = *(void *)(v46 + 40);
        if (v34[16] == 83) {
          goto LABEL_128;
        }
        if (v63 == v35)
        {
          unint64_t v63 = v35;
LABEL_128:
          unint64_t v78 = v63;
          sub_1CCD94EF8((uint64_t)&v84, v46, &v78);
        }
LABEL_129:
        v44 += 4;
        if (v44 == v45) {
          goto LABEL_69;
        }
      }
      if (v53 >= 0x40) {
        v53 *= 2;
      }
      else {
        unsigned int v53 = 128;
      }
LABEL_136:
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v79, v53);
      unsigned int v53 = v81;
      uint64_t v48 = v80;
      goto LABEL_106;
    }
LABEL_69:
    unsigned int v32 = v85;
  }
  while (v85);
  uint64_t v12 = (_DWORD *)((char *)this + 152);
  if (!v10)
  {
LABEL_138:
    unsigned int v64 = *v5;
    char v66 = v64 < 0x1C || v64 - 83 < 0xFFFFFFFE || v6;
    if ((v66 & 1) == 0) {
      uint64_t v2 = (llvm::Value *)*((void *)v2 - 8);
    }
    uint64_t v10 = sub_1CB83544C(*((void *)this + 248), *(void *)v2);
    if (v67 == 1) {
  }
    }
  uint64_t v69 = v79;
  uint64_t v68 = v80;
  int v70 = &v81;
  if (v80 == v79) {
    int v70 = (uint64_t *)((char *)&v81 + 4);
  }
  uint64_t v71 = *(unsigned int *)v70;
  unsigned int v72 = (unint64_t *)v80;
  if (v71)
  {
    uint64_t v73 = 0;
    while (*(void *)&v80[v73] >= 0xFFFFFFFFFFFFFFFELL)
    {
      v73 += 8;
      if (8 * v71 == v73) {
        goto LABEL_163;
      }
    }
    unsigned int v72 = (unint64_t *)&v80[v73];
  }
  uint64_t v74 = (unint64_t *)&v80[8 * v71];
  if (v72 != v74)
  {
    unint64_t v75 = *v72;
LABEL_158:
    unint64_t v78 = v75;
    *((_DWORD *)sub_1CD8E730C(v12, &v78) + 2) = v10;
    uint64_t v76 = v72 + 1;
    while (v76 != v74)
    {
      unint64_t v77 = *v76++;
      unint64_t v75 = v77;
      if (v77 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        unsigned int v72 = v76 - 1;
        goto LABEL_158;
      }
    }
    uint64_t v69 = v79;
    uint64_t v68 = v80;
  }
LABEL_163:
  if (v68 != v69) {
    free(v68);
  }
  if (v84 != v86) {
    free(v84);
  }
  return v10;
}

void llvm::slpvectorizer::BoUpSLP::computeMinimumValueSizes(uint64_t ****this)
{
  v130[32] = *MEMORY[0x1E4F143B8];
  if (*((_DWORD *)this + 270))
  {
    uint64_t v2 = **this;
    uint64_t v3 = *(void *)**v2;
    if (v3 && *(unsigned char *)(v3 + 8) == 13)
    {
      sub_1CD8E7370((llvm::SmallPtrSetImplBase *)&v110, *v2, &(*v2)[*((unsigned int *)v2 + 2)]);
      unsigned int v5 = *((_DWORD *)this + 270);
      if (v5)
      {
        BOOL v6 = this[134];
        uint64_t v7 = &v6[3 * v5];
        int v8 = v114;
        while (1)
        {
          uint64_t v9 = *v6;
          uint64_t v10 = v110;
          if (v111 == v110)
          {
            unsigned int v11 = v113;
            uint64_t v12 = &v111[8 * v113];
            if (v113)
            {
              uint64_t v13 = 0;
              while (*(uint64_t ***)&v111[v13] != v9)
              {
                v13 += 8;
                if (8 * v113 == v13) {
                  goto LABEL_28;
                }
              }
              uint64_t v12 = &v111[v13];
            }
LABEL_28:
            uint64_t v10 = v111;
          }
          else
          {
            unsigned int v14 = v112 - 1;
            unsigned int v15 = (v112 - 1) & ((v9 >> 4) ^ (v9 >> 9));
            uint64_t v12 = &v111[8 * v15];
            uint64_t v16 = *(uint64_t ***)v12;
            if (*(void *)v12 == -1)
            {
              int v17 = 0;
LABEL_35:
              if (v17) {
                uint64_t v12 = v17;
              }
              unsigned int v11 = v113;
              if (*(uint64_t ***)v12 != v9) {
                uint64_t v12 = &v111[8 * v112];
              }
            }
            else
            {
              int v17 = 0;
              int v18 = 1;
              while (v16 != v9)
              {
                if (v17) {
                  BOOL v19 = 0;
                }
                else {
                  BOOL v19 = v16 == (uint64_t **)-2;
                }
                if (v19) {
                  int v17 = v12;
                }
                unsigned int v20 = v15 + v18++;
                unsigned int v15 = v20 & v14;
                uint64_t v12 = &v111[8 * (v20 & v14)];
                uint64_t v16 = *(uint64_t ***)v12;
                if (*(void *)v12 == -1) {
                  goto LABEL_35;
                }
              }
              unsigned int v11 = v113;
            }
          }
          unsigned int v21 = v112;
          if (v111 == v10) {
            unsigned int v21 = v11;
          }
          if (v12 == &v111[8 * v21]) {
            goto LABEL_206;
          }
          *(void *)uint64_t v12 = -2;
          int v114 = ++v8;
          v6 += 3;
          if (v6 == v7) {
            goto LABEL_41;
          }
        }
      }
      unsigned int v11 = v113;
      int v8 = v114;
LABEL_41:
      if (v11 != v8) {
        goto LABEL_206;
      }
      uint64_t v22 = *((unsigned int *)this + 2);
      if (v22)
      {
        unsigned int v23 = *this;
        uint64_t v24 = (uint64_t)&(*this)[v22];
        while (1)
        {
          uint64_t v25 = *v23;
          uint64_t v26 = *((unsigned int *)*v23 + 2);
          if (v26) {
            break;
          }
LABEL_85:
          if (++v23 == (uint64_t ***)v24) {
            goto LABEL_86;
          }
        }
        BOOL v27 = *v25;
        uint64_t v28 = (uint64_t)&(*v25)[v26];
        BOOL v29 = v111;
        while (1)
        {
          uint64_t v30 = *v27;
          if (v29 != v110) {
            break;
          }
          if (v11)
          {
            uint64_t v31 = 0;
            uint64_t v32 = 8 * v11;
            uint64_t v33 = v29;
            while (*v33 != v30)
            {
              if (*v33 == -2) {
                uint64_t v31 = v33;
              }
              ++v33;
              v32 -= 8;
              if (!v32)
              {
                if (!v31) {
                  goto LABEL_54;
                }
                void *v31 = v30;
                --v114;
                goto LABEL_77;
              }
            }
            goto LABEL_77;
          }
LABEL_54:
          unsigned int v34 = v112;
          if (v11 >= v112) {
            goto LABEL_57;
          }
          unsigned int v113 = v11 + 1;
          *(void *)&v29[8 * v11] = v30;
LABEL_77:
          BOOL v29 = v111;
          unsigned int v11 = v113;
          if (++v27 == (uint64_t *)v28) {
            goto LABEL_85;
          }
        }
        unsigned int v34 = v112;
LABEL_57:
        if (3 * v34 <= 4 * (v11 - v114))
        {
          if (v34 >= 0x40) {
            v34 *= 2;
          }
          else {
            unsigned int v34 = 128;
          }
        }
        else if (v34 - v11 >= v34 >> 3)
        {
          goto LABEL_59;
        }
        llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v110, v34);
        unsigned int v34 = v112;
        BOOL v29 = v111;
LABEL_59:
        unsigned int v35 = v34 - 1;
        unsigned int v36 = (v34 - 1) & ((v30 >> 4) ^ (v30 >> 9));
        int v37 = &v29[8 * v36];
        uint64_t v38 = *(void *)v37;
        if (*(void *)v37 == -1)
        {
          BOOL v39 = 0;
LABEL_71:
          if (v39) {
            int v37 = v39;
          }
          if (*(void *)v37 != v30)
          {
            if (*(void *)v37 == -2) {
              --v114;
            }
            else {
              ++v113;
            }
            *(void *)int v37 = v30;
          }
        }
        else
        {
          BOOL v39 = 0;
          int v40 = 1;
          while (v38 != v30)
          {
            if (v39) {
              BOOL v41 = 0;
            }
            else {
              BOOL v41 = v38 == -2;
            }
            if (v41) {
              BOOL v39 = v37;
            }
            unsigned int v42 = v36 + v40++;
            unsigned int v36 = v42 & v35;
            int v37 = &v29[8 * (v42 & v35)];
            uint64_t v38 = *(void *)v37;
            if (*(void *)v37 == -1) {
              goto LABEL_71;
            }
          }
        }
        goto LABEL_77;
      }
LABEL_86:
      uint64_t v43 = *((unsigned int *)v2 + 2);
      if (v43)
      {
        int v44 = *v2;
        uint64_t v45 = (uint64_t)&(*v2)[v43];
        unsigned int v46 = v112 - 1;
        do
        {
          uint64_t v47 = *(void *)(*v44 + 8);
          if (!v47 || *(void *)(v47 + 8)) {
            goto LABEL_206;
          }
          uint64_t v48 = *(void *)(v47 + 24);
          if (v111 == v110)
          {
            if (v113)
            {
              uint64_t v49 = 0;
              while (*(void *)&v111[v49] != v48)
              {
                v49 += 8;
                if (8 * v113 == v49)
                {
                  unsigned int v50 = v113;
                  goto LABEL_110;
                }
              }
              int v59 = &v111[v49];
              unsigned int v50 = v113;
              BOOL v60 = v111;
            }
            else
            {
              unsigned int v50 = 0;
LABEL_110:
              BOOL v60 = v111;
              int v59 = &v111[8 * v113];
            }
          }
          else
          {
            unsigned int v51 = v46 & ((v48 >> 4) ^ (v48 >> 9));
            uint64_t v52 = &v111[8 * v51];
            uint64_t v53 = *(void *)v52;
            if (*(void *)v52 == -1)
            {
              unsigned int v54 = 0;
LABEL_112:
              if (v54) {
                uint64_t v52 = v54;
              }
              uint64_t v58 = *(void *)v52;
            }
            else
            {
              unsigned int v54 = 0;
              int v55 = 1;
              while (v53 != v48)
              {
                if (v54) {
                  BOOL v56 = 0;
                }
                else {
                  BOOL v56 = v53 == -2;
                }
                if (v56) {
                  unsigned int v54 = v52;
                }
                unsigned int v57 = v51 + v55++;
                unsigned int v51 = v57 & v46;
                uint64_t v52 = &v111[8 * (v57 & v46)];
                uint64_t v53 = *(void *)v52;
                if (*(void *)v52 == -1) {
                  goto LABEL_112;
                }
              }
              uint64_t v58 = v48;
            }
            int v59 = v58 == v48 ? v52 : &v111[8 * v112];
            unsigned int v50 = v113;
            BOOL v60 = v110;
          }
          if (v111 != v60) {
            unsigned int v50 = v112;
          }
          if (v59 != &v111[8 * v50]) {
            goto LABEL_206;
          }
          ++v44;
        }
        while (v44 != (uint64_t *)v45);
      }
      uint64_t v128 = v130;
      uint64_t v129 = 0x2000000000;
      unsigned int v125 = v127;
      uint64_t v126 = 0x400000000;
      unsigned int v61 = *v2;
      uint64_t v62 = *((unsigned int *)v2 + 2);
      if (v62)
      {
        uint64_t v63 = 8 * v62;
        while ((sub_1CD33AE6C(*v61, (uint64_t *)&v110, (uint64_t)&v128, (uint64_t)&v125) & 1) != 0)
        {
          ++v61;
          v63 -= 8;
          if (!v63)
          {
            unsigned int v61 = *v2;
            uint64_t v64 = *((unsigned int *)v2 + 2);
            if (!v64) {
              goto LABEL_144;
            }
            unint64_t v65 = &v61[v64];
            unsigned int v66 = 8;
            do
            {
              llvm::DemandedBits::getDemandedBits((llvm::DemandedBits *)this[247], (llvm::Instruction *)*v61, (llvm::APInt *)&v119);
              if (v120 > 0x40)
              {
                int v68 = 0;
                int64_t v69 = ((unint64_t)v120 + 63) >> 6;
                do
                {
                  if (v69-- < 1) {
                    break;
                  }
                  unint64_t v71 = *((void *)v119 + v69);
                  v68 += __clz(v71);
                }
                while (!v71);
                unsigned int v72 = v120 | 0xFFFFFFC0;
                if ((v120 & 0x3F) == 0) {
                  unsigned int v72 = 0;
                }
                if (v120 - v68 - v72 > v66) {
                  unsigned int v66 = v120 - v68 - v72;
                }
                if (v119) {
                  MEMORY[0x1D25D9CB0](v119, 0x1000C8000313F17);
                }
              }
              else
              {
                unsigned int v67 = 64 - __clz((unint64_t)v119);
                if (v67 > v66) {
                  unsigned int v66 = v67;
                }
              }
              ++v61;
            }
            while (v61 != v65);
            unsigned int v61 = *v2;
            goto LABEL_145;
          }
        }
        goto LABEL_202;
      }
LABEL_144:
      unsigned int v66 = 8;
LABEL_145:
      int8x8_t v73 = (int8x8_t)v66;
      uint64_t v75 = sub_1CB83544C((uint64_t)this[248], *(void *)*v61);
      if (v74 == 1) {
      if (v75 == v66)
      }
      {
        uint64_t v76 = *((unsigned int *)v2 + 2);
        if (!v76)
        {
          BOOL v88 = 0;
LABEL_176:
          if (v129)
          {
            unint64_t v90 = (char *)v128;
            uint64_t v91 = 8 * v129;
            unsigned int v92 = 8;
            do
            {
              uint64_t v93 = *(llvm::Constant **)v90;
              if (*(void *)v90) {
                BOOL v94 = *(unsigned __int8 *)(*(void *)v90 + 16) >= 0x1Cu;
              }
              else {
                BOOL v94 = 0;
              }
              if (!v94 || (uint64_t v95 = *(void *)v90, !*((void *)v93 + 5))) {
                uint64_t v95 = 0;
              }
              uint64_t v96 = this[246];
              unsigned int v97 = this[245];
              int v119 = (const llvm::DataLayout *)this[248];
              uint64_t v120 = v96;
              uint64_t v121 = v95;
              char v122 = v97;
              uint64_t v123 = 0;
              char v124 = 1;
              int v98 = sub_1CC162D6C(v93, 0, (uint64_t)&v119);
              int v100 = sub_1CB83544C((uint64_t)this[248], *(void *)v93);
              if (v99 == 1) {
              if (v100 - v98 > v92)
              }
                unsigned int v92 = v100 - v98;
              v90 += 8;
              v91 -= 8;
            }
            while (v91);
          }
          else
          {
            unsigned int v92 = 8;
          }
          int8x8_t v73 = (int8x8_t)(v92 + v88);
          unsigned int v66 = v73.i32[0];
          goto LABEL_193;
        }
        unint64_t v77 = *v2;
        uint64_t v78 = 8 * v76;
        uint64_t v79 = v78;
        uint64_t v80 = *v2;
        while (*(unsigned char *)(*(void *)(*(void *)(*v80 + 8) + 24) + 16) == 62)
        {
          ++v80;
          v79 -= 8;
          if (!v79)
          {
            uint64_t v81 = v78 - 8;
            do
            {
              int v82 = (uint64_t *)*v77;
              if (*v77) {
                BOOL v83 = *(unsigned __int8 *)(*v77 + 16) >= 0x1Cu;
              }
              else {
                BOOL v83 = 0;
              }
              if (!v83 || (uint64_t v84 = *v77, !v82[5])) {
                uint64_t v84 = 0;
              }
              int v119 = (const llvm::DataLayout *)this[248];
              uint64_t v120 = 0;
              uint64_t v121 = v84;
              char v122 = 0;
              uint64_t v123 = 0;
              char v124 = 1;
              sub_1CC16089C(v82, 0, &v119, (uint64_t)&v115);
              unsigned int v85 = v116;
              uint64_t v86 = (uint64_t *)(v115 + 8 * ((v116 - 1) >> 6));
              if (v116 < 0x41) {
                uint64_t v86 = &v115;
              }
              uint64_t v87 = (1 << (v116 - 1)) & *v86;
              BOOL v88 = v87 == 0;
              if (v118 >= 0x41 && v117)
              {
                MEMORY[0x1D25D9CB0](v117, 0x1000C8000313F17);
                unsigned int v85 = v116;
              }
              if (v85 >= 0x41 && v115) {
                MEMORY[0x1D25D9CB0](v115, 0x1000C8000313F17);
              }
              ++v77;
              if (v87) {
                BOOL v89 = v81 == 0;
              }
              else {
                BOOL v89 = 1;
              }
              v81 -= 8;
            }
            while (!v89);
            goto LABEL_176;
          }
        }
      }
      LOBYTE(v88) = 0;
LABEL_193:
      if (!v66 || (uint8x8_t v101 = (uint8x8_t)vcnt_s8(v73), v101.i16[0] = vaddlv_u8(v101), v101.u32[0] >= 2uLL))
      {
        unint64_t v102 = *(void *)&v73 | (*(void *)&v73 >> 1) | ((*(void *)&v73 | (*(void *)&v73 >> 1)) >> 2);
        unint64_t v103 = v102 | (v102 >> 4) | ((v102 | (v102 >> 4)) >> 8);
        unsigned int v66 = ((v103 >> 16) | v103) + 1;
      }
      if (v66 < *(_DWORD *)(v3 + 8) >> 8)
      {
        while (v126)
        {
          uint64_t v104 = *((void *)v125 + v126 - 1);
          LODWORD(v126) = v126 - 1;
          sub_1CD33AE6C(v104, (uint64_t *)&v110, (uint64_t)&v128, (uint64_t)&v125);
        }
        if (v129)
        {
          uint64_t v105 = (const llvm::DataLayout **)v128;
          uint64_t v106 = (char *)(this + 268);
          uint64_t v107 = 8 * v129;
          do
          {
            int v108 = *v105++;
            int v119 = v108;
            uint64_t v109 = sub_1CD8DDDCC((uint64_t)v106, (uint64_t *)&v119);
            *(void *)uint64_t v109 = v66;
            *(unsigned char *)(v109 + 8) = v88;
            v107 -= 8;
          }
          while (v107);
        }
      }
LABEL_202:
      if (v125 != v127) {
        free(v125);
      }
      if (v128 != v130) {
        free(v128);
      }
LABEL_206:
      if (v111 != v110) {
        free(v111);
      }
    }
  }
}

uint64_t sub_1CD33AE6C(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  int v6 = *(unsigned __int8 *)(a1 + 16);
  if (v6 <= 0x14) {
    goto LABEL_2;
  }
  if (v6 < 0x1C) {
    return 0;
  }
  uint64_t v9 = *(void *)(a1 + 8);
  if (!v9 || *(void *)(v9 + 8)) {
    return 0;
  }
  uint64_t v13 = *a2;
  uint64_t v12 = a2[1];
  if (v12 == *a2)
  {
    uint64_t v14 = *((unsigned int *)a2 + 5);
    unsigned int v15 = (void *)(v12 + 8 * v14);
    if (v14)
    {
      uint64_t v16 = 0;
      while (*(void *)(v12 + v16) != a1)
      {
        v16 += 8;
        if (8 * v14 == v16) {
          goto LABEL_27;
        }
      }
      unsigned int v15 = (void *)(v12 + v16);
    }
LABEL_27:
    uint64_t v13 = a2[1];
  }
  else
  {
    uint64_t v17 = *((unsigned int *)a2 + 4);
    int v18 = v17 - 1;
    unsigned int v19 = (v17 - 1) & ((a1 >> 4) ^ (a1 >> 9));
    unsigned int v15 = (void *)(v12 + 8 * v19);
    uint64_t v20 = *v15;
    if (*v15 == -1)
    {
      unsigned int v21 = 0;
LABEL_29:
      if (v21) {
        unsigned int v15 = v21;
      }
      if (*v15 != a1)
      {
        LODWORD(v14) = *((_DWORD *)a2 + 5);
        unsigned int v15 = (void *)(v12 + 8 * v17);
        goto LABEL_34;
      }
    }
    else
    {
      unsigned int v21 = 0;
      int v22 = 1;
      while (v20 != a1)
      {
        if (v21) {
          BOOL v23 = 0;
        }
        else {
          BOOL v23 = v20 == -2;
        }
        if (v23) {
          unsigned int v21 = v15;
        }
        unsigned int v24 = v19 + v22++;
        unsigned int v19 = v24 & v18;
        unsigned int v15 = (void *)(v12 + 8 * (v24 & v18));
        uint64_t v20 = *v15;
        if (*v15 == -1) {
          goto LABEL_29;
        }
      }
    }
    LODWORD(v14) = *((_DWORD *)a2 + 5);
  }
LABEL_34:
  if (v12 == v13) {
    unsigned int v25 = v14;
  }
  else {
    unsigned int v25 = *((_DWORD *)a2 + 4);
  }
  if (v15 == (void *)(v12 + 8 * v25)) {
    return 0;
  }
  uint64_t result = 0;
  if (v6 > 65)
  {
    if (v6 <= 82)
    {
      if ((v6 - 67) >= 2)
      {
        if (v6 != 66) {
          return result;
        }
        int v33 = *(_DWORD *)(a1 + 20);
        if ((v33 & 0x40000000) != 0) {
          unsigned int v34 = *(uint64_t **)(a1 - 8);
        }
        else {
          unsigned int v34 = (uint64_t *)(a1 - 32 * (v33 & 0x7FFFFFF));
        }
        uint64_t v39 = *v34;
        unsigned int v40 = *(_DWORD *)(a4 + 8);
        if (v40 >= *(_DWORD *)(a4 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)a4 + 8 * v40) = v39;
        ++*(_DWORD *)(a4 + 8);
        goto LABEL_2;
      }
      int v26 = *(_DWORD *)(a1 + 20);
      if ((v26 & 0x40000000) != 0) {
        uint64_t v27 = *(void *)(a1 - 8);
      }
      else {
        uint64_t v27 = a1 - 32 * (v26 & 0x7FFFFFF);
      }
      int v35 = *(unsigned __int8 *)(*(void *)v27 + 16);
      if (v35 != 89 && v35 != 90)
      {
LABEL_2:
        unsigned int v7 = *(_DWORD *)(a3 + 8);
        if (v7 >= *(_DWORD *)(a3 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)a3 + 8 * v7) = a1;
        ++*(_DWORD *)(a3 + 8);
        return 1;
      }
      return 0;
    }
    if (v6 == 83)
    {
      int v36 = *(_DWORD *)(a1 + 20);
      if ((v36 & 0x40000000) != 0)
      {
        uint64_t v38 = *(void **)(a1 - 8);
        uint64_t v37 = v36 & 0x7FFFFFF;
      }
      else
      {
        uint64_t v37 = v36 & 0x7FFFFFF;
        uint64_t v38 = (void *)(a1 - 32 * v37);
      }
      if (!v37) {
        goto LABEL_2;
      }
      uint64_t v41 = 32 * v37;
      while ((sub_1CD33AE6C(*v38, a2, a3, a4) & 1) != 0)
      {
        v38 += 4;
        v41 -= 32;
        if (!v41) {
          goto LABEL_2;
        }
      }
      return 0;
    }
    if (v6 != 85) {
      return result;
    }
    uint64_t result = sub_1CD33AE6C(*(void *)(a1 - 64), a2, a3, a4);
    if (!result) {
      return result;
    }
    uint64_t v32 = *(void *)(a1 - 32);
LABEL_61:
    if (sub_1CD33AE6C(v32, a2, a3, a4)) {
      goto LABEL_2;
    }
    return 0;
  }
  if (v6 > 55)
  {
    if ((v6 - 56) >= 3) {
      return result;
    }
  }
  else if (v6 != 41 && v6 != 43 && v6 != 45)
  {
    return result;
  }
  int v28 = *(_DWORD *)(a1 + 20);
  if ((v28 & 0x40000000) != 0) {
    BOOL v29 = *(void **)(a1 - 8);
  }
  else {
    BOOL v29 = (void *)(a1 - 32 * (v28 & 0x7FFFFFF));
  }
  uint64_t result = sub_1CD33AE6C(*v29, a2, a3, a4);
  if (result)
  {
    int v30 = *(_DWORD *)(a1 + 20);
    if ((v30 & 0x40000000) != 0) {
      uint64_t v31 = *(void *)(a1 - 8);
    }
    else {
      uint64_t v31 = a1 - 32 * (v30 & 0x7FFFFFF);
    }
    uint64_t v32 = *(void *)(v31 + 32);
    goto LABEL_61;
  }
  return result;
}

void llvm::SLPVectorizerPass::collectSeedInstructions(llvm::SLPVectorizerPass *this, llvm::BasicBlock *a2)
{
  int v4 = (char *)this + 72;
  sub_1CD770FB4((uint64_t)this + 72);
  unsigned int v5 = (char *)this + 120;
  sub_1CD770FB4((uint64_t)v5);
  int v6 = (char *)a2 + 40;
  uint64_t v7 = *((void *)a2 + 6);
  if ((char *)v7 != v6)
  {
    while (1)
    {
      uint64_t v8 = v7 ? v7 - 24 : 0;
      int v9 = *(unsigned __int8 *)(v8 + 16);
      uint64_t v10 = v9 == 61 ? v8 : 0;
      if (!v7 || v9 != 61) {
        break;
      }
      int v11 = *(unsigned __int8 *)(v10 + 16);
      if (v11 == 60 || v11 == 61)
      {
        __int16 v12 = *(_WORD *)(v10 + 18);
        if ((v12 & 0x380) == 0 && (v12 & 1) == 0) {
          goto LABEL_13;
        }
      }
      else if ((v11 - 63) >= 3 && (*(_WORD *)(v10 + 18) & 1) == 0)
      {
LABEL_13:
        int v13 = *(_DWORD *)(**(void **)(v10 - 64) + 8);
        BOOL v14 = v13 > 0x14u || ((1 << v13) & 0x10A07F) == 0;
        int v15 = v13 & 0xFD;
        if (v14 || v15 == 4) {
          goto LABEL_39;
        }
        UnderlyingObject = llvm::getUnderlyingObject(*(llvm **)(v10 - 32), (const llvm::Value *)6);
        uint64_t v17 = sub_1CD77100C((uint64_t)v4, (uint64_t *)&UnderlyingObject);
        goto LABEL_37;
      }
LABEL_39:
      uint64_t v7 = *(void *)(v7 + 8);
      if ((char *)v7 == v6) {
        return;
      }
    }
    if (v9 == 62) {
      uint64_t v10 = v8;
    }
    else {
      uint64_t v10 = 0;
    }
    if (!v7) {
      goto LABEL_39;
    }
    if (v9 != 62) {
      goto LABEL_39;
    }
    uint64_t v18 = *(_DWORD *)(v10 + 20) & 0x7FFFFFF;
    if ((v18 - 3) < 0xFFFFFFFE) {
      goto LABEL_39;
    }
    unsigned int v19 = (uint64_t *)(v10 - 32 * v18);
    uint64_t v20 = (unsigned __int8 *)v19[4];
    if (v20[16] < 0x15u) {
      goto LABEL_39;
    }
    int v21 = *(_DWORD *)(*(void *)v20 + 8);
    BOOL v22 = v21 > 0x14u || ((1 << v21) & 0x10A07F) == 0;
    int v23 = v21 & 0xFD;
    BOOL v24 = v22 || v23 == 4;
    if (v24 || (*(_DWORD *)(*(void *)v10 + 8) & 0xFE) == 0x12) {
      goto LABEL_39;
    }
    UnderlyingObject = (llvm *)*v19;
    uint64_t v17 = sub_1CD8E10A0((uint64_t)v5, (uint64_t *)&UnderlyingObject);
LABEL_37:
    unint64_t v25 = *(unsigned int *)(v17 + 8);
    if (v25 >= *(unsigned int *)(v17 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)v17 + 8 * v25) = v10;
    ++*(_DWORD *)(v17 + 8);
    goto LABEL_39;
  }
}

uint64_t llvm::SLPVectorizerPass::vectorizeChainsInBlock(llvm::TargetTransformInfo **this, llvm::BasicBlock *a2, llvm::slpvectorizer::BoUpSLP *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a2;
  char v9 = 0;
  v168[4] = *MEMORY[0x1E4F143B8];
  unint64_t v165 = v168;
  unsigned int v167 = 4;
  unint64_t v151 = v155;
  uint64_t v152 = v155;
  uint64_t v10 = (char *)a2 + 40;
  uint64_t v153 = 16;
  int v154 = 0;
  v149[0] = 0;
  v149[1] = 0;
  unsigned int v150 = 0;
  v148[0] = this;
  v148[1] = v149;
  unsigned int v146 = a3;
  uint64_t v147 = v149;
  uint64_t v140 = (uint64_t *)((char *)a3 + 1048);
  do
  {
    char v11 = v9;
    unsigned int v166 = 0;
    uint64_t v12 = *((void *)v8 + 6);
    if ((char *)v12 == v10) {
      goto LABEL_117;
    }
    do
    {
      int v13 = (unsigned __int8 *)(v12 - 24);
      if (!v12) {
        int v13 = 0;
      }
      int v14 = v13[16];
      if (v14 == 83) {
        int v15 = v13;
      }
      else {
        int v15 = 0;
      }
      if (!v12 || v14 != 83) {
        break;
      }
      uint64_t v16 = v151;
      if (v152 == v151)
      {
        int v17 = HIDWORD(v153);
        uint64_t v18 = &v152[8 * HIDWORD(v153)];
        if (HIDWORD(v153))
        {
          uint64_t v19 = 0;
          while (*(unsigned __int8 **)&v152[v19] != v15)
          {
            v19 += 8;
            if (8 * HIDWORD(v153) == v19) {
              goto LABEL_29;
            }
          }
          uint64_t v18 = &v152[v19];
        }
LABEL_29:
        uint64_t v16 = v152;
      }
      else
      {
        int v20 = v153 - 1;
        unsigned int v21 = (v153 - 1) & ((v15 >> 4) ^ (v15 >> 9));
        uint64_t v18 = &v152[8 * v21];
        BOOL v22 = *(unsigned __int8 **)v18;
        if (*(void *)v18 == -1)
        {
          int v23 = 0;
LABEL_37:
          if (v23) {
            uint64_t v18 = v23;
          }
          int v17 = HIDWORD(v153);
          if (*(unsigned __int8 **)v18 != v15) {
            uint64_t v18 = &v152[8 * v153];
          }
        }
        else
        {
          int v23 = 0;
          int v24 = 1;
          while (v22 != v15)
          {
            if (v23) {
              BOOL v25 = 0;
            }
            else {
              BOOL v25 = v22 == (unsigned __int8 *)-2;
            }
            if (v25) {
              int v23 = v18;
            }
            unsigned int v26 = v21 + v24++;
            unsigned int v21 = v26 & v20;
            uint64_t v18 = &v152[8 * (v26 & v20)];
            BOOL v22 = *(unsigned __int8 **)v18;
            if (*(void *)v18 == -1) {
              goto LABEL_37;
            }
          }
          int v17 = HIDWORD(v153);
        }
      }
      if (v152 == v16) {
        int v27 = v17;
      }
      else {
        int v27 = v153;
      }
      if (v18 == &v152[8 * v27])
      {
        int v158 = v15;
        uint64_t v163 = 0;
        if ((sub_1CD50F704(v140, &v158, &v163) & 1) == 0)
        {
          int v28 = *(_DWORD *)(*(void *)v15 + 8);
          BOOL v29 = v28 > 0x14u || ((1 << v28) & 0x10A07F) == 0;
          int v30 = v28 & 0xFD;
          if (!v29 && v30 != 4)
          {
            if (v166 >= (unint64_t)v167) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            v165[v166++] = (uint64_t)v15;
          }
        }
      }
      uint64_t v12 = *(void *)(v12 + 8);
    }
    while ((char *)v12 != v10);
    if (!v166) {
      goto LABEL_117;
    }
    uint64_t v32 = v165;
    int v33 = &v165[v166];
    char v142 = v11;
    uint64_t v141 = (char *)v33;
    do
    {
      uint64_t v34 = *v32;
      v157[0] = *v32;
      sub_1CD8E17B0((uint64_t)&v158, (uint64_t)v149, v157);
      int v35 = v158;
      int v36 = (char *)v158 + 16;
      if (*((_DWORD *)v158 + 4)) {
        goto LABEL_116;
      }
      uint64_t v37 = (char *)v158 + 8;
      uint64_t v163 = (uint64_t)v164 + 8;
      DWORD1(v164[0]) = 4;
      *((void *)&v164[0] + 1) = v34;
      int v158 = v162;
      uint64_t v159 = (uint64_t)v162;
      uint64_t v160 = 4;
      uint64_t v38 = (char *)(v35 + 6);
      unsigned int v39 = 1;
      int v161 = 0;
      do
      {
        uint64_t v40 = *(void *)(v163 + 8 * v39 - 8);
        LODWORD(v164[0]) = v39 - 1;
        uint64_t v41 = v159;
        uint64_t v42 = HIDWORD(v160);
        if ((void *)v159 == v158)
        {
          if (HIDWORD(v160))
          {
            uint64_t v43 = 0;
            uint64_t v44 = 8 * HIDWORD(v160);
            uint64_t v45 = (void *)v159;
            while (*v45 != v40)
            {
              if (*v45 == -2) {
                uint64_t v43 = v45;
              }
              ++v45;
              v44 -= 8;
              if (!v44)
              {
                if (!v43) {
                  goto LABEL_65;
                }
                *uint64_t v43 = v40;
                --v161;
                goto LABEL_89;
              }
            }
            goto LABEL_104;
          }
LABEL_65:
          unsigned int v46 = v160;
          if (HIDWORD(v160) < v160)
          {
            ++HIDWORD(v160);
            *(void *)(v159 + 8 * v42) = v40;
LABEL_89:
            int v56 = *(_DWORD *)(v40 + 20);
            if ((v56 & 0x40000000) != 0)
            {
              uint64_t v58 = *(uint64_t **)(v40 - 8);
              uint64_t v57 = v56 & 0x7FFFFFF;
              if (!v57) {
                goto LABEL_104;
              }
            }
            else
            {
              uint64_t v57 = v56 & 0x7FFFFFF;
              uint64_t v58 = (uint64_t *)(v40 - 32 * v57);
              if (!v57) {
                goto LABEL_104;
              }
            }
            uint64_t v59 = 32 * v57;
            do
            {
              uint64_t v60 = *v58;
              if (*v58 && *(unsigned char *)(v60 + 16) == 83)
              {
                if (LODWORD(v164[0]) >= (unint64_t)DWORD1(v164[0])) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                *(void *)(v163 + 8 * LODWORD(v164[0])) = v60;
                LODWORD(v61) = v164[0];
                uint64_t v62 = v164;
              }
              else
              {
                uint64_t v61 = v35[4];
                if (v61 >= v35[5]) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                *(void *)(*v37 + 8 * v61) = v60;
                uint64_t v62 = v36;
              }
              _DWORD *v62 = v61 + 1;
              v58 += 4;
              v59 -= 32;
            }
            while (v59);
            goto LABEL_104;
          }
        }
        else
        {
          unsigned int v46 = v160;
        }
        if (3 * v46 <= 4 * (HIDWORD(v160) - v161))
        {
          if (v46 >= 0x40) {
            v46 *= 2;
          }
          else {
            unsigned int v46 = 128;
          }
        }
        else if (v46 - HIDWORD(v160) >= v46 >> 3)
        {
          goto LABEL_70;
        }
        uint64_t v63 = v38;
        llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v158, v46);
        uint64_t v38 = v63;
        unsigned int v46 = v160;
        uint64_t v41 = v159;
LABEL_70:
        unsigned int v47 = v46 - 1;
        unsigned int v48 = (v46 - 1) & ((v40 >> 4) ^ (v40 >> 9));
        uint64_t v49 = (void *)(v41 + 8 * v48);
        uint64_t v50 = *v49;
        if (*v49 != -1)
        {
          unsigned int v51 = 0;
          int v52 = 1;
          while (v50 != v40)
          {
            if (v51) {
              BOOL v53 = 0;
            }
            else {
              BOOL v53 = v50 == -2;
            }
            if (v53) {
              unsigned int v51 = v49;
            }
            unsigned int v54 = v48 + v52++;
            unsigned int v48 = v54 & v47;
            uint64_t v49 = (void *)(v41 + 8 * (v54 & v47));
            uint64_t v50 = *v49;
            if (*v49 == -1) {
              goto LABEL_82;
            }
          }
          goto LABEL_104;
        }
        unsigned int v51 = 0;
LABEL_82:
        if (v51) {
          int v55 = v51;
        }
        else {
          int v55 = v49;
        }
        if (*v55 != v40)
        {
          if (*v55 == -2) {
            --v161;
          }
          else {
            ++HIDWORD(v160);
          }
          void *v55 = v40;
          goto LABEL_89;
        }
LABEL_104:
        unsigned int v39 = v164[0];
      }
      while (LODWORD(v164[0]));
      if ((void *)v159 != v158) {
        free((void *)v159);
      }
      char v11 = v142;
      int v33 = (uint64_t *)v141;
      if ((_OWORD *)v163 != (_OWORD *)((char *)v164 + 8)) {
        free((void *)v163);
      }
LABEL_116:
      ++v32;
    }
    while (v32 != v33);
LABEL_117:
    int v158 = this;
    uint64_t v159 = (uint64_t)a3;
    char v64 = sub_1CD340A54((uint64_t)&v165, (unsigned int (*)(uint64_t, void))sub_1CD34A7A4, (uint64_t)&v146, sub_1CD34A7E4, (uint64_t)v148, (uint64_t (*)(uint64_t, void, void))sub_1CD34AAAC, (uint64_t)&v147, a8, (uint64_t (*)(uint64_t, void *))sub_1CD34AC08, (uint64_t)&v158);
    if (v166)
    {
      unint64_t v65 = v165;
      unsigned int v66 = (char *)&v165[v166];
      unsigned int v67 = v152;
      while (1)
      {
        uint64_t v68 = *v65;
        uint64_t v69 = HIDWORD(v153);
        if (v67 != v151) {
          break;
        }
        if (HIDWORD(v153))
        {
          int v70 = 0;
          uint64_t v71 = 8 * HIDWORD(v153);
          unsigned int v72 = v67;
          while (*v72 != v68)
          {
            if (*v72 == -2) {
              int v70 = v72;
            }
            ++v72;
            v71 -= 8;
            if (!v71)
            {
              if (!v70) {
                goto LABEL_127;
              }
              *int v70 = v68;
              --v154;
              goto LABEL_151;
            }
          }
          goto LABEL_151;
        }
LABEL_127:
        unsigned int v73 = v153;
        if (HIDWORD(v153) >= v153) {
          goto LABEL_130;
        }
        ++HIDWORD(v153);
        *(void *)&v67[8 * v69] = v68;
LABEL_151:
        unsigned int v67 = v152;
        if (++v65 == (uint64_t *)v66) {
          goto LABEL_159;
        }
      }
      unsigned int v73 = v153;
LABEL_130:
      if (3 * v73 <= 4 * (HIDWORD(v153) - v154))
      {
        if (v73 >= 0x40) {
          v73 *= 2;
        }
        else {
          unsigned int v73 = 128;
        }
      }
      else if (v73 - HIDWORD(v153) >= v73 >> 3)
      {
        goto LABEL_132;
      }
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v151, v73);
      unsigned int v73 = v153;
      unsigned int v67 = v152;
LABEL_132:
      unsigned int v74 = v73 - 1;
      unsigned int v75 = (v73 - 1) & ((v68 >> 4) ^ (v68 >> 9));
      uint64_t v76 = &v67[8 * v75];
      uint64_t v77 = *(void *)v76;
      if (*(void *)v76 == -1)
      {
        uint64_t v78 = 0;
LABEL_144:
        if (v78) {
          int v82 = v78;
        }
        else {
          int v82 = v76;
        }
        if (*(void *)v82 != v68)
        {
          if (*(void *)v82 == -2) {
            --v154;
          }
          else {
            ++HIDWORD(v153);
          }
          *(void *)int v82 = v68;
        }
      }
      else
      {
        uint64_t v78 = 0;
        int v79 = 1;
        while (v77 != v68)
        {
          if (v78) {
            BOOL v80 = 0;
          }
          else {
            BOOL v80 = v77 == -2;
          }
          if (v80) {
            uint64_t v78 = v76;
          }
          unsigned int v81 = v75 + v79++;
          unsigned int v75 = v81 & v74;
          uint64_t v76 = &v67[8 * (v81 & v74)];
          uint64_t v77 = *(void *)v76;
          if (*(void *)v76 == -1) {
            goto LABEL_144;
          }
        }
      }
      goto LABEL_151;
    }
LABEL_159:
    char v9 = 1;
    uint64_t v8 = a2;
  }
  while ((v64 & 1) != 0);
  if (v152 == v151) {
    goto LABEL_161;
  }
  if (v153 >= 0x21 && 4 * (HIDWORD(v153) - v154) < v153)
  {
    llvm::SmallPtrSetImplBase::shrink_and_clear((void **)&v151);
  }
  else
  {
    memset(v152, 255, 8 * v153);
LABEL_161:
    HIDWORD(v153) = 0;
    int v154 = 0;
  }
  int v158 = &v160;
  uint64_t v159 = 0x800000000;
  uint64_t v163 = 1;
  v164[0] = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  v164[1] = v164[0];
  uint64_t v83 = *((void *)a2 + 6);
  if ((char *)v83 != v10)
  {
    uint64_t v84 = &dword_1EBD01000;
    unsigned int v85 = this;
    while (1)
    {
      if (v83) {
        uint64_t v86 = v83 - 24;
      }
      else {
        uint64_t v86 = 0;
      }
      if (*(unsigned char *)(*(void *)v86 + 8) == 19) {
        goto LABEL_168;
      }
      uint64_t v156 = 0;
      v157[0] = v86;
      if (sub_1CD50F704(v140, v157, &v156)) {
        goto LABEL_168;
      }
      uint64_t v87 = v152;
      uint64_t v88 = HIDWORD(v153);
      if (v152 == v151)
      {
        if (HIDWORD(v153))
        {
          BOOL v89 = 0;
          uint64_t v90 = 8 * HIDWORD(v153);
          uint64_t v91 = (uint64_t *)v152;
          while (*v91 != v86)
          {
            if (*v91 == -2) {
              BOOL v89 = v91;
            }
            ++v91;
            v90 -= 8;
            if (!v90)
            {
              if (!v89) {
                goto LABEL_179;
              }
              *BOOL v89 = v86;
              --v154;
              goto LABEL_203;
            }
          }
          goto LABEL_214;
        }
LABEL_179:
        unsigned int v92 = v153;
        if (HIDWORD(v153) < v153)
        {
          ++HIDWORD(v153);
          *(void *)&v152[8 * v88] = v86;
          goto LABEL_203;
        }
      }
      else
      {
        unsigned int v92 = v153;
      }
      if (3 * v92 <= 4 * (HIDWORD(v153) - v154)) {
        break;
      }
      if (v92 - HIDWORD(v153) < v92 >> 3) {
        goto LABEL_267;
      }
LABEL_184:
      unsigned int v93 = v92 - 1;
      unsigned int v94 = (v92 - 1) & ((v86 >> 4) ^ (v86 >> 9));
      uint64_t v95 = &v87[8 * v94];
      uint64_t v96 = *(void *)v95;
      if (*(void *)v95 != -1)
      {
        unsigned int v97 = 0;
        int v98 = 1;
        while (v96 != v86)
        {
          if (v97) {
            BOOL v99 = 0;
          }
          else {
            BOOL v99 = v96 == -2;
          }
          if (v99) {
            unsigned int v97 = (uint64_t *)v95;
          }
          unsigned int v100 = v94 + v98++;
          unsigned int v94 = v100 & v93;
          uint64_t v95 = &v87[8 * (v100 & v93)];
          uint64_t v96 = *(void *)v95;
          if (*(void *)v95 == -1) {
            goto LABEL_196;
          }
        }
LABEL_214:
        if (!*(void *)(v86 + 8))
        {
          uint64_t v108 = sub_1CD8E7A04((uint64_t)&v163, v86);
          uint64_t v109 = v164;
          if (v163)
          {
            unsigned int v110 = 4;
          }
          else
          {
            uint64_t v109 = *(_OWORD **)&v164[0];
            unsigned int v110 = DWORD2(v164[0]);
          }
          if ((_OWORD *)((char *)v109 + 8 * v110) != (_OWORD *)v108
            && llvm::SLPVectorizerPass::vectorizeSimpleInstructions(v85, (uint64_t)&v158, v8, (uint64_t *)a3, *(unsigned __int8 *)(v86 + 16) - 29 < 0xB))
          {
            uint64_t v83 = *((void *)v8 + 6);
            char v11 = 1;
          }
        }
        goto LABEL_168;
      }
      unsigned int v97 = 0;
LABEL_196:
      if (v97) {
        uint8x8_t v101 = v97;
      }
      else {
        uint8x8_t v101 = (uint64_t *)v95;
      }
      if (*v101 == v86) {
        goto LABEL_214;
      }
      if (*v101 == -2) {
        --v154;
      }
      else {
        ++HIDWORD(v153);
      }
      *uint8x8_t v101 = v86;
LABEL_203:
      if (sub_1CBF63B28(v86)) {
        goto LABEL_168;
      }
      int v102 = *(unsigned __int8 *)(v86 + 16);
      if (v102 == 83) {
        unint64_t v103 = (_DWORD *)v86;
      }
      else {
        unint64_t v103 = 0;
      }
      if (!v83 || v102 != 83)
      {
        if (*(void *)(v86 + 8) || *(unsigned char *)(*(void *)v86 + 8) != 7 && v102 != 84 && v102 != 33) {
          goto LABEL_224;
        }
        uint64_t v156 = v86;
        sub_1CD8E7A68((uint64_t)v157, (uint64_t)&v163, &v156);
        if (*((unsigned char *)v84 + 1936) || *(unsigned char *)(v86 + 16) != 61)
        {
          int v122 = *(_DWORD *)(v86 + 20);
          uint64_t v120 = a3;
          if ((v122 & 0x40000000) != 0)
          {
            char v124 = *(llvm::Value ***)(v86 - 8);
            uint64_t v123 = v122 & 0x7FFFFFF;
          }
          else
          {
            uint64_t v123 = v122 & 0x7FFFFFF;
            char v124 = (llvm::Value **)(v86 - 32 * v123);
          }
          char v119 = 0;
          if (v123)
          {
            uint64_t v131 = 32 * v123;
            unsigned int v85 = this;
            uint64_t v121 = a2;
            do
            {
              int v132 = *v124;
              v124 += 4;
              char v133 = llvm::SLPVectorizerPass::vectorizeRootInstruction((llvm::SLPVectorizerPass *)this, 0, v132, a2, v120, this[1]);
              uint64_t v120 = a3;
              v119 |= v133;
              v131 -= 32;
            }
            while (v131);
          }
          else
          {
            unsigned int v85 = this;
            uint64_t v121 = a2;
          }
        }
        else
        {
          char v119 = 0;
          uint64_t v120 = a3;
          uint64_t v121 = v8;
        }
        char v134 = llvm::SLPVectorizerPass::vectorizeSimpleInstructions(v85, (uint64_t)&v158, v121, (uint64_t *)v120, *(unsigned __int8 *)(v86 + 16) - 29 < 0xB);
        uint64_t v8 = v121;
        if ((v119 & 1) == 0 && (v134 & 1) == 0)
        {
          int v102 = *(unsigned __int8 *)(v86 + 16);
          unsigned int v85 = this;
          uint64_t v84 = &dword_1EBD01000;
LABEL_224:
          if ((v102 - 81) < 2 || v102 == 93 || v102 == 90)
          {
            if (v159 >= (unint64_t)HIDWORD(v159)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((void *)v158 + v159) = v86;
            LODWORD(v159) = v159 + 1;
          }
          goto LABEL_168;
        }
        uint64_t v83 = *((void *)v121 + 6);
        char v11 = 1;
        unsigned int v85 = this;
        uint64_t v84 = &dword_1EBD01000;
        goto LABEL_168;
      }
      int v104 = v103[5];
      uint64_t v105 = v104 & 0x7FFFFFF;
      if (v105 != 2) {
        goto LABEL_253;
      }
      uint64_t v106 = v85[4];
      if ((v104 & 0x40000000) != 0) {
        uint64_t v107 = (_DWORD *)*((void *)v103 - 1);
      }
      else {
        uint64_t v107 = v103 - 16;
      }
      uint64_t v111 = v103[15];
      if (*(llvm::BasicBlock **)&v107[8 * v111] == v8) {
        goto LABEL_235;
      }
      if (*(llvm::BasicBlock **)&v107[8 * v111 + 2] == v8)
      {
        v107 += 8;
LABEL_235:
        if (*(void *)v107 && *(unsigned __int8 *)(*(void *)v107 + 16) >= 0x1Cu) {
          llvm::DominatorTreeBase<llvm::BasicBlock,false>::dominates();
        }
      }
      int v112 = *((_DWORD *)v106 + 4);
      if (v112)
      {
        uint64_t v113 = *(void *)v106;
        unsigned int v114 = v112 - 1;
        uint64_t v115 = (v112 - 1) & ((a2 >> 4) ^ (a2 >> 9));
        unsigned int v116 = *(llvm::BasicBlock **)(*(void *)v106 + 16 * v115);
        if (v116 == a2)
        {
LABEL_243:
          if (*(void *)(v113 + 16 * v115 + 8)) {
            llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getLoopLatch();
          }
        }
        else
        {
          int v117 = 1;
          while (v116 != (llvm::BasicBlock *)-4096)
          {
            int v118 = v115 + v117++;
            uint64_t v115 = v118 & v114;
            unsigned int v116 = *(llvm::BasicBlock **)(v113 + 16 * v115);
            if (v116 == a2) {
              goto LABEL_243;
            }
          }
        }
      }
      uint64_t v8 = a2;
      if ((llvm::SLPVectorizerPass::vectorizeRootInstruction((llvm::SLPVectorizerPass *)v85, (llvm::PHINode *)v103, 0, a2, a3, v85[1]) & 1) == 0)
      {
        uint64_t v105 = v103[5] & 0x7FFFFFF;
LABEL_253:
        if (v105)
        {
          uint64_t v125 = 0;
          uint64_t v126 = 0;
          uint64_t v127 = 32 * v105;
          do
          {
            int v128 = v103[5];
            if ((v128 & 0x40000000) != 0)
            {
              uint64_t v130 = (_DWORD *)*((void *)v103 - 1);
              uint64_t v129 = v103[15];
            }
            else
            {
              uint64_t v129 = v103[15];
              uint64_t v130 = &v103[-8 * (v128 & 0x7FFFFFF)];
            }
            if (*(llvm::BasicBlock **)&v130[8 * v129 + v125] != a2) {
              llvm::DominatorTreeBase<llvm::BasicBlock,false>::isReachableFromEntry();
            }
            v126 += 32;
            v125 += 2;
          }
          while (v127 != v126);
          uint64_t v8 = a2;
        }
        goto LABEL_168;
      }
      uint64_t v83 = *((void *)a2 + 6);
      char v11 = 1;
LABEL_168:
      uint64_t v83 = *(void *)(v83 + 8);
      if ((char *)v83 == v10) {
        goto LABEL_278;
      }
    }
    if (v92 >= 0x40) {
      v92 *= 2;
    }
    else {
      unsigned int v92 = 128;
    }
LABEL_267:
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v151, v92);
    unsigned int v92 = v153;
    uint64_t v87 = v152;
    goto LABEL_184;
  }
LABEL_278:
  if ((v163 & 1) == 0) {
    MEMORY[0x1D25D9CD0](*(void *)&v164[0], 8);
  }
  if (v158 != &v160) {
    free(v158);
  }
  uint64_t v135 = v149[0];
  if (v150)
  {
    uint64_t v136 = 56 * v150;
    uint64_t v137 = v149[0] + 24;
    do
    {
      if ((*(void *)(v137 - 24) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t v138 = *(void **)(v137 - 16);
        if ((void *)v137 != v138) {
          free(v138);
        }
      }
      v137 += 56;
      v136 -= 56;
    }
    while (v136);
    uint64_t v135 = v149[0];
  }
  MEMORY[0x1D25D9CD0](v135, 8);
  if (v152 != v151) {
    free(v152);
  }
  if (v165 != v168) {
    free(v165);
  }
  return v11 & 1;
}

uint64_t llvm::SLPVectorizerPass::vectorizeStoreChain(int a1, llvm::Value **a2, uint64_t a3, llvm::slpvectorizer::BoUpSLP *this)
{
  v46[35] = *MEMORY[0x1E4F143B8];
  __int32 VectorElementSize = llvm::slpvectorizer::BoUpSLP::getVectorElementSize(this, *a2);
  v8.i32[0] = VectorElementSize;
  int8x8_t v9 = vcnt_s8(v8);
  v9.i16[0] = vaddlv_u8((uint8x8_t)v9);
  if (v9.i32[0] != 1 || a3 == 0) {
    return 0;
  }
  unsigned __int32 v12 = VectorElementSize;
  uint64_t result = 0;
  if (a3 < 2) {
    return result;
  }
  unsigned int v13 = *((_DWORD *)this + 501) / v12;
  v9.i32[0] = a3;
  uint8x8_t v14 = (uint8x8_t)vcnt_s8(v9);
  v14.i16[0] = vaddlv_u8(v14);
  if (v14.i32[0] > 1u || v13 > a3) {
    return result;
  }
  llvm::slpvectorizer::BoUpSLP::buildTree((uint64_t)this, (uint64_t *)a2, a3, 0, 0);
  BOOL isTreeTinyAndNotFullyVectorizable = llvm::slpvectorizer::BoUpSLP::isTreeTinyAndNotFullyVectorizable(this, 0);
  uint64_t result = 0;
  if (isTreeTinyAndNotFullyVectorizable) {
    return result;
  }
  if (llvm::slpvectorizer::BoUpSLP::isLoadCombineCandidate(this)) {
    return 0;
  }
  llvm::slpvectorizer::BoUpSLP::reorderTopToBottom((uint64_t **)this, v17, v18, v19);
  llvm::slpvectorizer::BoUpSLP::reorderBottomToTop(this, 0, v20, v21);
  long long v42 = 0u;
  long long v43 = 0u;
  long long v41 = 0u;
  llvm::slpvectorizer::BoUpSLP::buildExternalUses((unint64_t)this, (uint64_t)&v41);
  sub_1CD8E420C((uint64_t)&v41);
  llvm::slpvectorizer::BoUpSLP::computeMinimumValueSizes((uint64_t ****)this);
  int64_t TreeCost = llvm::slpvectorizer::BoUpSLP::getTreeCost((void *****)this, 0, 0);
  uint64_t v24 = v22;
  uint64_t result = 0;
  BOOL v25 = TreeCost < -(uint64_t)dword_1EBD01610;
  if (v22) {
    BOOL v25 = (int)v22 < 0;
  }
  if (v25)
  {
    unsigned int v26 = (uint64_t ***)*((void *)this + 249);
    llvm::OptimizationRemark::OptimizationRemark((uint64_t)&v41, (uint64_t)"slp-vectorizer", (uint64_t)"StoresVectorized", 16, (uint64_t)*a2);
    unsigned int v39 = "Stores SLP vectorized with cost ";
    uint64_t v40 = 32;
    sub_1CC59ADEC((uint64_t *)&v44, (uint64_t)&v39);
    llvm::DiagnosticInfoOptimizationBase::Argument::Argument((uint64_t)v35, "Cost", 4uLL, TreeCost, v24);
    uint64_t v27 = sub_1CD3D6290((uint64_t)&v41, (long long *)v35);
    unsigned int v39 = " and with tree size ";
    uint64_t v40 = 20;
    sub_1CC59ADEC((uint64_t *)(v27 + 80), (uint64_t)&v39);
    llvm::DiagnosticInfoOptimizationBase::Argument::Argument(&v32, "TreeSize", 8uLL, *((_DWORD *)this + 2));
    int v28 = (llvm::DiagnosticInfoOptimizationBase *)sub_1CD3D6290(v27, (long long *)&v32);
    llvm::OptimizationRemarkEmitter::emit(v26, v28);
    if (v34 < 0) {
      operator delete(__p);
    }
    if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v32.__r_.__value_.__l.__data_);
    }
    if (v38 < 0) {
      operator delete(v37);
    }
    if (v36 < 0) {
      operator delete(v35[0]);
    }
    *(void *)&long long v41 = &unk_1F2616800;
    BOOL v29 = (char *)v44;
    if (v45)
    {
      unint64_t v30 = (unint64_t)v45 << 6;
      do
      {
        uint64_t v31 = (void **)&v29[v30];
        if (v29[v30 - 17] < 0) {
          operator delete(*(v31 - 5));
        }
        if (*((char *)v31 - 41) < 0) {
          operator delete(*(v31 - 8));
        }
        v30 -= 64;
      }
      while (v30);
      BOOL v29 = (char *)v44;
    }
    if (v29 != (char *)v46) {
      free(v29);
    }
    long long v41 = 0uLL;
    LODWORD(v42) = 0;
    long long v43 = 0uLL;
    *((void *)&v42 + 1) = 0;
    llvm::slpvectorizer::BoUpSLP::vectorizeTree((uint64_t ****)this, (uint64_t)&v41);
    sub_1CD8E420C((uint64_t)&v41);
    return 1;
  }
  return result;
}

uint64_t sub_1CD33C62C(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v3 = *(_DWORD **)(a1 + 24);
  if (*v3 >= *(_DWORD *)(a1 + 32)) {
    return 1;
  }
  uint64_t v7 = **(void **)(a1 + 40);
  unint64_t v8 = *(void *)(v7 + 8 * a3);
  if (v8)
  {
    if (((1 << a2) & (v8 >> 1) & ~(-1 << (v8 >> 58))) != 0)
    {
LABEL_4:
      uint64_t v9 = **(void **)(a1 + 48);
      if (*(_DWORD *)(v9 + 8 * (int)a2 + 4) == 1) {
        return *(_DWORD *)(v9 + 8 * (int)a2) == a3;
      }
      return 0;
    }
  }
  else if ((*(void *)(*(void *)v8 + 8 * (a2 >> 6)) & (1 << a2)) != 0)
  {
    goto LABEL_4;
  }
  unsigned __int32 v12 = *(const llvm::DataLayout ***)a1;
  char v13 = a3;
  ++*v3;
  unint64_t v14 = *(void *)(v7 + 8 * (int)a3);
  if (v14) {
    *(void *)(v7 + 8 * (int)a3) = v14 & 0xFC00000000000000 | (2
  }
                                                                  * (((v14 >> 1) & ~(-1 << (v14 >> 58)) | (1 << a2)) & ~(-1 << (v14 >> 58)))) | 1;
  else {
    *(void *)(*(void *)v14 + 8 * (a2 >> 6)) |= 1 << a2;
  }
  unint64_t v15 = *(void *)(v7 + 8 * (int)a2);
  if (v15) {
    *(void *)(v7 + 8 * (int)a2) = v15 & 0xFC00000000000000 | (2
  }
                                                                  * (((v15 >> 1) & ~(-1 << (v15 >> 58)) | (1 << a3)) & ~(-1 << (v15 >> 58)))) | 1;
  else {
    *(void *)(*(void *)v15 + 8 * (a3 >> 6)) |= 1 << a3;
  }
  uint64_t v16 = **(void **)(a1 + 8);
  unint64_t PointersDiff = llvm::getPointersDiff(**(llvm ***)(*(void *)(v16 + 8 * (int)a2) - 64), *(llvm::Type **)(*(void *)(v16 + 8 * (int)a2) - 32), **(llvm::Value ***)(*(void *)(v16 + 8 * (int)a3) - 64), *(llvm::Type **)(*(void *)(v16 + 8 * (int)a3) - 32), v12[8], *v12, (llvm::ScalarEvolution *)1, 1, v31);
  if ((PointersDiff & 0xFF00000000) == 0 || PointersDiff == 0) {
    return 0;
  }
  uint64_t v19 = **(void **)(a1 + 48);
  if ((PointersDiff & 0x80000000) == 0)
  {
    uint64_t v20 = v19 + 8 * (int)a2;
    int v22 = *(_DWORD *)(v20 + 4);
    uint64_t v21 = (_DWORD *)(v20 + 4);
    if (v22 > (int)PointersDiff)
    {
      int v23 = *(unint64_t **)(a1 + 16);
      unint64_t v24 = *v23;
      if (*v23) {
        *int v23 = v24 & 0xFC00000000000000 | (2
      }
                                           * (((v24 >> 1) & ~(-1 << (v24 >> 58)) | (1 << v13)) & ~(-1 << (v24 >> 58)))) | 1;
      else {
        *(void *)(*(void *)v24 + 8 * (a3 >> 6)) |= 1 << a3;
      }
      *(_DWORD *)(v19 + 8 * (int)a2) = a3;
      _DWORD *v21 = PointersDiff;
      return PointersDiff == 1;
    }
    return 0;
  }
  uint64_t v11 = 0;
  uint64_t v26 = v19 + 8 * (int)a3;
  int v28 = *(_DWORD *)(v26 + 4);
  uint64_t v27 = (_DWORD *)(v26 + 4);
  if (v28 > -(int)PointersDiff)
  {
    BOOL v29 = *(unint64_t **)(a1 + 16);
    unint64_t v30 = *v29;
    if (*v29) {
      unint64_t *v29 = v30 & 0xFC00000000000000 | (2
    }
                                         * (((v30 >> 1) & ~(-1 << (v30 >> 58)) | (1 << a2)) & ~(-1 << (v30 >> 58)))) | 1;
    else {
      *(void *)(*(void *)v30 + 8 * (a2 >> 6)) |= 1 << a2;
    }
    uint64_t v11 = 0;
    *(_DWORD *)(v19 + 8 * (int)a3) = a2;
    *uint64_t v27 = -(int)PointersDiff;
  }
  return v11;
}

uint64_t llvm::SLPVectorizerPass::tryToVectorizePair(llvm::SLPVectorizerPass *this, llvm::Value *a2, llvm::Value *a3, llvm::slpvectorizer::BoUpSLP *a4)
{
  uint64_t v4 = 0;
  void v6[2] = *MEMORY[0x1E4F143B8];
  if (a2 && a3)
  {
    if (*((unsigned char *)a2 + 16) == 90 || *((unsigned char *)a3 + 16) == 90)
    {
      return 0;
    }
    else
    {
      v6[0] = (uint64_t)a2;
      v6[1] = (uint64_t)a3;
      return llvm::SLPVectorizerPass::tryToVectorizeList((uint64_t)this, v6, 2uLL, a4, 0);
    }
  }
  return v4;
}

uint64_t llvm::SLPVectorizerPass::tryToVectorizeList(uint64_t a1, uint64_t *a2, unint64_t a3, llvm::slpvectorizer::BoUpSLP *a4, char a5)
{
  uint64_t v170 = *MEMORY[0x1E4F143B8];
  if (a3 < 2) {
    return 0;
  }
  uint64_t v7 = a2;
  sub_1CD32A408((uint64_t)&v130, a2, a3);
  uint64_t v9 = v131;
  if (!v131 || *(unsigned char *)(v131 + 16) == 28) {
    return 0;
  }
  uint64_t v116 = a1;
  uint64_t v11 = 0;
  unsigned __int32 v12 = v130;
  do
  {
    char v13 = (unsigned char *)v7[v11];
    if (v13[16] != 90)
    {
      unint64_t v14 = *(llvm::Type **)v13;
      int v15 = *(_DWORD *)(*(void *)v13 + 8);
      BOOL v16 = v15 > 0x14u || ((1 << v15) & 0x10A07F) == 0;
      int v17 = v15 & 0xFD;
      if (v16 || v17 == 4)
      {
        unint64_t v24 = (uint64_t ***)*((void *)a4 + 249);
        uint64_t v25 = *(void *)***v24;
        if (!*(void *)(v25 + 128))
        {
          uint64_t result = (*(uint64_t (**)(void))(**(void **)(v25 + 72) + 48))(*(void *)(v25 + 72));
          if (!result) {
            return result;
          }
        }
        long long v144 = 0uLL;
        uint64_t v145 = 0;
        DWORD2(v135) = 0;
        char v139 = 0;
        uint64_t v141 = 0;
        uint64_t v143 = &v144;
        int v142 = 0;
        *(void *)&long long v135 = &unk_1F2646F30;
        uint64_t v136 = 0;
        uint64_t v137 = 0;
        uint64_t v138 = 0;
        llvm::Type::print(v14, (llvm::raw_ostream *)&v135, 0, 0);
        llvm::OptimizationRemarkMissed::OptimizationRemarkMissed((uint64_t)&v160, (uint64_t)"slp-vectorizer", (uint64_t)"UnsupportedType", 15, (uint64_t)v12);
        unint64_t v148 = "Cannot SLP vectorize list: type ";
        uint64_t v149 = 32;
        sub_1CC59ADEC((uint64_t *)&v165, (uint64_t)&v148);
        uint64_t v26 = (char *)v143;
        char v27 = *((unsigned char *)v143 + 23);
        int v28 = v27;
        size_t v29 = v27 & 0x7F;
        if (v28 >= 0) {
          size_t v30 = v29;
        }
        else {
          size_t v30 = *((void *)v143 + 1);
        }
        sub_1CB907098((uint64_t)&__p, v30 + 29);
        if (v134 >= 0) {
          p_p = &__p;
        }
        else {
          p_p = __p;
        }
        if (v30)
        {
          if (v26[23] >= 0) {
            std::string v32 = v26;
          }
          else {
            std::string v32 = *(char **)v26;
          }
          memmove(p_p, v32, v30);
        }
        strcpy((char *)p_p + v30, " is unsupported by vectorizer");
        int v33 = (const char *)__p;
        if (v134 >= 0) {
          int v33 = (const char *)&__p;
        }
        uint64_t v34 = v134 & 0x7F;
        if (v134 < 0) {
          uint64_t v34 = v133;
        }
        unint64_t v148 = v33;
        uint64_t v149 = v34;
        sub_1CC59ADEC((uint64_t *)&v165, (uint64_t)&v148);
        LODWORD(v149) = DWORD2(v160);
        BYTE4(v149) = BYTE12(v160);
        long long v150 = v161;
        uint64_t v151 = *(void *)v162;
        long long v152 = *(_OWORD *)&v162[8];
        long long v153 = v163;
        unint64_t v148 = (const char *)&unk_1F2616800;
        uint64_t v154 = v164;
        int v155 = v157;
        uint64_t v156 = 0x400000000;
        if (v166) {
          sub_1CD494D68((uint64_t)&v155, (uint64_t)&v165);
        }
        uint64_t v158 = v168;
        uint64_t v159 = v169;
        unint64_t v148 = (const char *)&unk_1F26165A8;
        if (v134 < 0) {
          operator delete(__p);
        }
        *(void *)&long long v160 = &unk_1F2616800;
        int v35 = (char *)v165;
        if (v166)
        {
          unint64_t v36 = (unint64_t)v166 << 6;
          do
          {
            uint64_t v37 = (void **)&v35[v36];
            if (v35[v36 - 17] < 0) {
              operator delete(*(v37 - 5));
            }
            if (*((char *)v37 - 41) < 0) {
              operator delete(*(v37 - 8));
            }
            v36 -= 64;
          }
          while (v36);
          int v35 = (char *)v165;
        }
        if (v35 != v167) {
          free(v35);
        }
        *(void *)&long long v135 = &unk_1F2646B98;
        if (v142 == 1 && v136) {
          MEMORY[0x1D25D9CB0](v136, 0x1000C8077774924);
        }
        if (SHIBYTE(v145) < 0) {
          operator delete((void *)v144);
        }
        llvm::OptimizationRemarkEmitter::emit(v24, (llvm::DiagnosticInfoOptimizationBase *)&v148);
        unint64_t v148 = (const char *)&unk_1F2616800;
        unint64_t v103 = (char *)v155;
        if (!v156) {
          goto LABEL_217;
        }
        unint64_t v104 = (unint64_t)v156 << 6;
        do
        {
          uint64_t v105 = (void **)&v103[v104];
          if (v103[v104 - 17] < 0) {
            operator delete(*(v105 - 5));
          }
          if (*((char *)v105 - 41) < 0) {
            operator delete(*(v105 - 8));
          }
          v104 -= 64;
        }
        while (v104);
LABEL_216:
        unint64_t v103 = (char *)v155;
        goto LABEL_217;
      }
    }
    ++v11;
  }
  while (a3 != v11);
  uint64_t VectorElementSize = llvm::slpvectorizer::BoUpSLP::getVectorElementSize(a4, v130);
  if (*((_DWORD *)a4 + 501) / VectorElementSize <= 2) {
    unsigned int v20 = 2;
  }
  else {
    unsigned int v20 = *((_DWORD *)a4 + 501) / VectorElementSize;
  }
  uint64_t v21 = 1 << (__clz(a3) ^ 0x3Fu);
  unsigned int v120 = v20;
  if (v20 <= v21) {
    unsigned int v22 = v21;
  }
  else {
    unsigned int v22 = v20;
  }
  if (word_1EBD01898) {
    int v23 = dword_1EBD01910;
  }
  else {
    int v23 = (*(uint64_t (**)(void, uint64_t, void))(***((void ***)a4 + 242) + 744))(**((void **)a4 + 242), VectorElementSize, *(unsigned __int8 *)(v9 + 16) - 28);
  }
  if (v23) {
    unsigned int v38 = v23;
  }
  else {
    unsigned int v38 = -1;
  }
  if (v22 < v38) {
    unsigned int v38 = v22;
  }
  unsigned int v119 = v38;
  if (v38 <= 1)
  {
    unsigned int v39 = (uint64_t ***)*((void *)a4 + 249);
    uint64_t v40 = *(void *)***v39;
    if (*(void *)(v40 + 128)
      || (uint64_t result = (*(uint64_t (**)(void))(**(void **)(v40 + 72) + 48))(*(void *)(v40 + 72)),
          result))
    {
      llvm::OptimizationRemarkMissed::OptimizationRemarkMissed((uint64_t)&v160, (uint64_t)"slp-vectorizer", (uint64_t)"SmallVF", 7, (uint64_t)v12);
      unint64_t v148 = "Cannot SLP vectorize list: vectorization factor ";
      uint64_t v149 = 48;
      sub_1CC59ADEC((uint64_t *)&v165, (uint64_t)&v148);
      unint64_t v148 = "less than 2 is not supported";
      uint64_t v149 = 28;
      sub_1CC59ADEC((uint64_t *)&v165, (uint64_t)&v148);
      LODWORD(v149) = DWORD2(v160);
      BYTE4(v149) = BYTE12(v160);
      long long v150 = v161;
      uint64_t v151 = *(void *)v162;
      long long v152 = *(_OWORD *)&v162[8];
      long long v153 = v163;
      unint64_t v148 = (const char *)&unk_1F2616800;
      uint64_t v154 = v164;
      int v155 = v157;
      uint64_t v156 = 0x400000000;
      unsigned int v41 = v166;
      if (v166)
      {
        sub_1CD494D68((uint64_t)&v155, (uint64_t)&v165);
        unsigned int v41 = v166;
      }
      uint64_t v158 = v168;
      uint64_t v159 = v169;
      unint64_t v148 = (const char *)&unk_1F26165A8;
      *(void *)&long long v160 = &unk_1F2616800;
      long long v42 = (char *)v165;
      if (v41)
      {
        unint64_t v43 = (unint64_t)v41 << 6;
        do
        {
          uint64_t v44 = (void **)&v42[v43];
          if (v42[v43 - 17] < 0) {
            operator delete(*(v44 - 5));
          }
          if (*((char *)v44 - 41) < 0) {
            operator delete(*(v44 - 8));
          }
          v43 -= 64;
        }
        while (v43);
        long long v42 = (char *)v165;
      }
      if (v42 != v167) {
        free(v42);
      }
      llvm::OptimizationRemarkEmitter::emit(v39, (llvm::DiagnosticInfoOptimizationBase *)&v148);
      unint64_t v148 = (const char *)&unk_1F2616800;
      unint64_t v103 = (char *)v155;
      if (v156)
      {
        unint64_t v106 = (unint64_t)v156 << 6;
        do
        {
          uint64_t v107 = (void **)&v103[v106];
          if (v103[v106 - 17] < 0) {
            operator delete(*(v107 - 5));
          }
          if (*((char *)v107 - 41) < 0) {
            operator delete(*(v107 - 8));
          }
          v106 -= 64;
        }
        while (v106);
        goto LABEL_216;
      }
      goto LABEL_217;
    }
    return result;
  }
  __p = (void *)dword_1EBD01610;
  LODWORD(v133) = 0;
  unsigned int v45 = (llvm::FixedVectorType **)*v7;
  if (*(unsigned char *)(*v7 + 16) == 90) {
    unsigned int v45 = (llvm::FixedVectorType **)*(v45 - 8);
  }
  if (a3 < 2 || v119 < v120) {
    goto LABEL_142;
  }
  char v113 = 0;
  char v114 = 0;
  unsigned int v46 = 0;
  unsigned int v47 = *v45;
  int v118 = a4;
  unsigned int v48 = (uint64_t *)((char *)a4 + 1048);
  uint64_t v112 = (uint64_t)v12;
  uint64_t v49 = (llvm::Type *)v119;
  uint64_t v50 = v116;
  uint64_t v115 = *v45;
  while (2)
  {
    double v51 = llvm::FixedVectorType::get(v47, v49);
    int v53 = (*(uint64_t (**)(void, uint64_t, double))(***(void ***)(v50 + 8) + 968))(**(void **)(v50 + 8), v52, v51);
    unsigned int v122 = v49 >> 1;
    if (v46 < a3 && v53 != v49)
    {
      unsigned int v117 = v46;
      while (1)
      {
        unsigned int v55 = v46 + v49;
        if (v46 + v49 <= a3) {
          uint64_t v56 = v49;
        }
        else {
          uint64_t v56 = a3 - v46;
        }
        v54.i32[0] = v56;
        int8x8_t v54 = vcnt_s8(v54);
        v54.i16[0] = vaddlv_u8((uint8x8_t)v54);
        if (v54.i32[0] == 1)
        {
          BOOL v57 = v49 == v120;
          BOOL v58 = v49 > v120;
          char v59 = a5;
          if (v56 >= v119) {
            char v59 = 0;
          }
          if (v56 > v122) {
            BOOL v58 = 0;
          }
          if (v56 >= 2) {
            BOOL v57 = 0;
          }
          if ((v59 & 1) != 0 || v58 || v57)
          {
LABEL_136:
            uint64_t v49 = (llvm::Type *)v122;
            unsigned int v47 = v115;
            uint64_t v50 = v116;
            unsigned int v46 = v117;
            goto LABEL_137;
          }
          uint64_t v60 = v7;
          uint64_t v61 = &v7[v46];
          if (v56)
          {
            uint64_t v62 = 8 * v56;
            uint64_t v63 = &v7[v46];
            while (1)
            {
              if (*v63 && *(unsigned __int8 *)(*v63 + 16) >= 0x1Cu)
              {
                *(void *)&long long v160 = *v63;
                unint64_t v148 = 0;
                if (sub_1CD50F704(v48, &v160, &v148)) {
                  break;
                }
              }
              ++v63;
              v62 -= 8;
              if (!v62) {
                goto LABEL_103;
              }
            }
          }
          else
          {
LABEL_103:
            llvm::slpvectorizer::BoUpSLP::buildTree((uint64_t)v118, v61, v56, 0, 0);
            if (!llvm::slpvectorizer::BoUpSLP::isTreeTinyAndNotFullyVectorizable(v118, 0))
            {
              llvm::slpvectorizer::BoUpSLP::reorderTopToBottom((uint64_t **)v118, v65, v66, v67);
              llvm::slpvectorizer::BoUpSLP::reorderBottomToTop(v118, *(unsigned __int8 *)(*v61 + 16) != 90, v68, v69);
              long long v161 = 0u;
              *(_OWORD *)uint64_t v162 = 0u;
              long long v160 = 0u;
              llvm::slpvectorizer::BoUpSLP::buildExternalUses((unint64_t)v118, (uint64_t)&v160);
              sub_1CD8E420C((uint64_t)&v160);
              llvm::slpvectorizer::BoUpSLP::computeMinimumValueSizes((uint64_t ****)v118);
              int64_t TreeCost = llvm::slpvectorizer::BoUpSLP::getTreeCost((void *****)v118, 0, 0);
              *(void *)&long long v135 = TreeCost;
              *((void *)&v135 + 1) = v71;
              BOOL v72 = (int)v133 > (int)v71;
              if (v133 == v71) {
                BOOL v72 = TreeCost < (uint64_t)__p;
              }
              BOOL v16 = !v72;
              unsigned int v73 = &__p;
              if (!v16) {
                unsigned int v73 = &v135;
              }
              int v74 = v73[2];
              __p = *(void **)v73;
              LODWORD(v133) = v74;
              BOOL v75 = TreeCost < -(uint64_t)dword_1EBD01610;
              if (v71) {
                BOOL v75 = (int)v71 < 0;
              }
              if (v75)
              {
                uint64_t v76 = TreeCost;
                uint64_t v77 = (uint64_t ***)*((void *)v118 + 249);
                uint64_t v78 = *v61;
                uint64_t v79 = v71;
                llvm::OptimizationRemark::OptimizationRemark((uint64_t)&v160, (uint64_t)"slp-vectorizer", (uint64_t)"VectorizedList", 14, v78);
                unint64_t v148 = "SLP vectorized with cost ";
                uint64_t v149 = 25;
                sub_1CC59ADEC((uint64_t *)&v165, (uint64_t)&v148);
                llvm::DiagnosticInfoOptimizationBase::Argument::Argument((uint64_t)v126, "Cost", 4uLL, v76, v79);
                uint64_t v80 = sub_1CD3D6290((uint64_t)&v160, (long long *)v126);
                unint64_t v148 = " and with tree size ";
                uint64_t v149 = 20;
                sub_1CC59ADEC((uint64_t *)(v80 + 80), (uint64_t)&v148);
                llvm::DiagnosticInfoOptimizationBase::Argument::Argument(&v123, "TreeSize", 8uLL, *((_DWORD *)v118 + 2));
                unsigned int v81 = (llvm::DiagnosticInfoOptimizationBase *)sub_1CD3D6290(v80, (long long *)&v123);
                llvm::OptimizationRemarkEmitter::emit(v77, v81);
                if (v125 < 0) {
                  operator delete(v124);
                }
                uint64_t v7 = v60;
                if (SHIBYTE(v123.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v123.__r_.__value_.__l.__data_);
                }
                if (v129 < 0) {
                  operator delete(v128);
                }
                if (v127 < 0) {
                  operator delete(v126[0]);
                }
                *(void *)&long long v160 = &unk_1F2616800;
                int v82 = (char *)v165;
                if (v166)
                {
                  unint64_t v83 = (unint64_t)v166 << 6;
                  do
                  {
                    uint64_t v84 = (void **)&v82[v83];
                    if (v82[v83 - 17] < 0) {
                      operator delete(*(v84 - 5));
                    }
                    if (*((char *)v84 - 41) < 0) {
                      operator delete(*(v84 - 8));
                    }
                    v83 -= 64;
                  }
                  while (v83);
                  int v82 = (char *)v165;
                }
                if (v82 != v167) {
                  free(v82);
                }
                long long v160 = 0uLL;
                LODWORD(v161) = 0;
                *(void *)uint64_t v162 = 0;
                *(void *)&v162[8] = 0;
                *((void *)&v161 + 1) = 0;
                llvm::slpvectorizer::BoUpSLP::vectorizeTree((uint64_t ****)v118, (uint64_t)&v160);
                sub_1CD8E420C((uint64_t)&v160);
                v46 += v49 - 1;
                char v113 = 1;
                unsigned int v117 = v55;
              }
              else
              {
                uint64_t v7 = v60;
              }
              char v114 = 1;
              goto LABEL_105;
            }
          }
          uint64_t v7 = v60;
        }
LABEL_105:
        if (++v46 >= a3) {
          goto LABEL_136;
        }
      }
    }
    uint64_t v49 = (llvm::Type *)v122;
LABEL_137:
    if (v46 + 1 < a3 && v49 >= v120) {
      continue;
    }
    break;
  }
  unsigned __int32 v12 = (llvm::Value *)v112;
  if (!(v113 & 1 | ((v114 & 1) == 0)))
  {
    uint64_t v91 = (uint64_t ***)*((void *)v118 + 249);
    uint64_t v92 = *(void *)***v91;
    if (!*(void *)(v92 + 128))
    {
      uint64_t result = (*(uint64_t (**)(void))(**(void **)(v92 + 72) + 48))(*(void *)(v92 + 72));
      if (!result) {
        return result;
      }
    }
    llvm::OptimizationRemarkMissed::OptimizationRemarkMissed((uint64_t)&v160, (uint64_t)"slp-vectorizer", (uint64_t)"NotBeneficial", 13, v112);
    unint64_t v148 = "List vectorization was possible but not beneficial with cost ";
    uint64_t v149 = 61;
    sub_1CC59ADEC((uint64_t *)&v165, (uint64_t)&v148);
    llvm::DiagnosticInfoOptimizationBase::Argument::Argument((uint64_t)&v135, "Cost", 4uLL, (uint64_t)__p, v133);
    uint64_t v93 = sub_1CD3D6290((uint64_t)&v160, &v135);
    unint64_t v148 = " >= ";
    uint64_t v149 = 4;
    sub_1CC59ADEC((uint64_t *)(v93 + 80), (uint64_t)&v148);
    llvm::DiagnosticInfoOptimizationBase::Argument::Argument(&v144, "Treshold", 8uLL, -dword_1EBD01610);
    uint64_t v94 = sub_1CD3D6290(v93, &v144);
    int v95 = *(_DWORD *)(v94 + 8);
    BYTE4(v149) = *(unsigned char *)(v94 + 12);
    LODWORD(v149) = v95;
    long long v96 = *(_OWORD *)(v94 + 16);
    uint64_t v151 = *(void *)(v94 + 32);
    long long v150 = v96;
    uint64_t v97 = *(void *)(v94 + 72);
    long long v98 = *(_OWORD *)(v94 + 56);
    long long v152 = *(_OWORD *)(v94 + 40);
    long long v153 = v98;
    unint64_t v148 = (const char *)&unk_1F2616800;
    uint64_t v154 = v97;
    int v155 = v157;
    uint64_t v156 = 0x400000000;
    if (*(_DWORD *)(v94 + 88)) {
      sub_1CD494D68((uint64_t)&v155, v94 + 80);
    }
    uint64_t v99 = *(void *)(v94 + 360);
    uint64_t v158 = *(void *)(v94 + 352);
    uint64_t v159 = v99;
    unint64_t v148 = (const char *)&unk_1F26165A8;
    if (v147 < 0) {
      operator delete(v146);
    }
    if (SHIBYTE(v145) < 0) {
      operator delete((void *)v144);
    }
    if (v140 < 0) {
      operator delete(v137);
    }
    if (SHIBYTE(v136) < 0) {
      operator delete((void *)v135);
    }
    *(void *)&long long v160 = &unk_1F2616800;
    unsigned int v100 = (char *)v165;
    if (v166)
    {
      unint64_t v101 = (unint64_t)v166 << 6;
      do
      {
        int v102 = (void **)&v100[v101];
        if (v100[v101 - 17] < 0) {
          operator delete(*(v102 - 5));
        }
        if (*((char *)v102 - 41) < 0) {
          operator delete(*(v102 - 8));
        }
        v101 -= 64;
      }
      while (v101);
      unsigned int v100 = (char *)v165;
    }
    if (v100 != v167) {
      free(v100);
    }
    llvm::OptimizationRemarkEmitter::emit(v91, (llvm::DiagnosticInfoOptimizationBase *)&v148);
    unint64_t v148 = (const char *)&unk_1F2616800;
    unint64_t v103 = (char *)v155;
    if (!v156) {
      goto LABEL_217;
    }
    unint64_t v110 = (unint64_t)v156 << 6;
    do
    {
      uint64_t v111 = (void **)&v103[v110];
      if (v103[v110 - 17] < 0) {
        operator delete(*(v111 - 5));
      }
      if (*((char *)v111 - 41) < 0) {
        operator delete(*(v111 - 8));
      }
      v110 -= 64;
    }
    while (v110);
    goto LABEL_216;
  }
  a4 = v118;
  if (v113) {
    return 1;
  }
LABEL_142:
  unsigned int v85 = (uint64_t ***)*((void *)a4 + 249);
  uint64_t v86 = *(void *)***v85;
  if (*(void *)(v86 + 128)
    || (uint64_t result = (*(uint64_t (**)(void))(**(void **)(v86 + 72) + 48))(*(void *)(v86 + 72)),
        result))
  {
    llvm::OptimizationRemarkMissed::OptimizationRemarkMissed((uint64_t)&v160, (uint64_t)"slp-vectorizer", (uint64_t)"NotPossible", 11, (uint64_t)v12);
    unint64_t v148 = "Cannot SLP vectorize list: vectorization was impossible";
    uint64_t v149 = 55;
    sub_1CC59ADEC((uint64_t *)&v165, (uint64_t)&v148);
    unint64_t v148 = " with available vectorization factors";
    uint64_t v149 = 37;
    sub_1CC59ADEC((uint64_t *)&v165, (uint64_t)&v148);
    LODWORD(v149) = DWORD2(v160);
    BYTE4(v149) = BYTE12(v160);
    long long v150 = v161;
    uint64_t v151 = *(void *)v162;
    long long v152 = *(_OWORD *)&v162[8];
    long long v153 = v163;
    unint64_t v148 = (const char *)&unk_1F2616800;
    uint64_t v154 = v164;
    int v155 = v157;
    uint64_t v156 = 0x400000000;
    unsigned int v87 = v166;
    if (v166)
    {
      sub_1CD494D68((uint64_t)&v155, (uint64_t)&v165);
      unsigned int v87 = v166;
    }
    uint64_t v158 = v168;
    uint64_t v159 = v169;
    unint64_t v148 = (const char *)&unk_1F26165A8;
    *(void *)&long long v160 = &unk_1F2616800;
    uint64_t v88 = (char *)v165;
    if (v87)
    {
      unint64_t v89 = (unint64_t)v87 << 6;
      do
      {
        uint64_t v90 = (void **)&v88[v89];
        if (v88[v89 - 17] < 0) {
          operator delete(*(v90 - 5));
        }
        if (*((char *)v90 - 41) < 0) {
          operator delete(*(v90 - 8));
        }
        v89 -= 64;
      }
      while (v89);
      uint64_t v88 = (char *)v165;
    }
    if (v88 != v167) {
      free(v88);
    }
    llvm::OptimizationRemarkEmitter::emit(v85, (llvm::DiagnosticInfoOptimizationBase *)&v148);
    unint64_t v148 = (const char *)&unk_1F2616800;
    unint64_t v103 = (char *)v155;
    if (v156)
    {
      unint64_t v108 = (unint64_t)v156 << 6;
      do
      {
        uint64_t v109 = (void **)&v103[v108];
        if (v103[v108 - 17] < 0) {
          operator delete(*(v109 - 5));
        }
        if (*((char *)v109 - 41) < 0) {
          operator delete(*(v109 - 8));
        }
        v108 -= 64;
      }
      while (v108);
      goto LABEL_216;
    }
LABEL_217:
    if (v103 != v157) {
      free(v103);
    }
    return 0;
  }
  return result;
}

uint64_t llvm::SLPVectorizerPass::tryToVectorize(llvm::SLPVectorizerPass *this, llvm::Instruction *a2, llvm::slpvectorizer::BoUpSLP *a3)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 0;
  }
  int v3 = *((unsigned __int8 *)a2 + 16);
  unsigned int v4 = v3 - 41;
  unsigned int v5 = v3 - 81;
  if (v4 >= 0x12 && v5 > 1) {
    return 0;
  }
  int v9 = *((_DWORD *)a2 + 5);
  uint64_t v10 = (v9 & 0x40000000) != 0
      ? (llvm::Instruction *)*((void *)a2 - 1)
      : (llvm::Instruction *)((char *)a2 - 32 * (v9 & 0x7FFFFFF));
  uint64_t v11 = *(unsigned __int8 *)(*(void *)v10 + 16) <= 0x1Bu ? 0 : *(void *)v10;
  uint64_t v12 = *((void *)v10 + 4);
  uint64_t v13 = *(unsigned __int8 *)(v12 + 16) <= 0x1Bu ? 0 : v12;
  if (!v11 || v13 == 0) {
    return 0;
  }
  uint64_t v15 = *((void *)a2 + 5);
  if (*(void *)(v11 + 40) != v15 || *(void *)(v13 + 40) != v15) {
    return 0;
  }
  int v16 = *(unsigned __int8 *)(v11 + 16);
  if (v16 != 90 && *(unsigned char *)(v13 + 16) != 90)
  {
    uint64_t v42 = v11;
    uint64_t v43 = v13;
    if (llvm::SLPVectorizerPass::tryToVectorizeList((uint64_t)this, &v42, 2uLL, a3, 0)) {
      return 1;
    }
    int v16 = *(unsigned __int8 *)(v11 + 16);
  }
  unsigned int v18 = v16 - 59;
  if ((v16 - 59) >= 0xFFFFFFEE) {
    uint64_t v19 = v11;
  }
  else {
    uint64_t v19 = 0;
  }
  unsigned int v20 = *(unsigned __int8 *)(v13 + 16) - 59;
  if (v20 >= 0xFFFFFFEE) {
    uint64_t v21 = v13;
  }
  else {
    uint64_t v21 = 0;
  }
  if (v20 < 0xFFFFFFEE) {
    goto LABEL_35;
  }
  uint64_t v22 = *(void *)(v13 + 8);
  if (!v22 || *(void *)(v22 + 8)) {
    goto LABEL_35;
  }
  uint64_t v33 = *(void *)(v13 - 64);
  unsigned int v34 = *(unsigned __int8 *)(v33 + 16);
  unsigned int v35 = *(unsigned __int8 *)(*(void *)(v13 - 32) + 16);
  if (v35 - 41 < 0x12 && v35 > 0x1B) {
    uint64_t v37 = *(void *)(v13 - 32);
  }
  else {
    uint64_t v37 = 0;
  }
  if (v33) {
    BOOL v38 = v34 >= 0x1C;
  }
  else {
    BOOL v38 = 0;
  }
  if (v38
    && v34 - 59 >= 0xFFFFFFEE
    && *(void *)(v33 + 40) == v15
    && v18 >= 0xFFFFFFEE
    && v34 != 90
    && *(unsigned char *)(v19 + 16) != 90)
  {
    uint64_t v42 = v19;
    uint64_t v43 = v33;
    if (llvm::SLPVectorizerPass::tryToVectorizeList((uint64_t)this, &v42, 2uLL, a3, 0)) {
      return 1;
    }
  }
  if (v37 && (*(void *)(v37 + 40) == v15 ? (BOOL v41 = v18 >= 0xFFFFFFEE) : (BOOL v41 = 0), v41))
  {
    if (*(unsigned char *)(v19 + 16) != 90 && *(unsigned char *)(v37 + 16) != 90)
    {
      uint64_t v42 = v19;
      uint64_t v43 = v37;
      if (llvm::SLPVectorizerPass::tryToVectorizeList((uint64_t)this, &v42, 2uLL, a3, 0)) {
        return 1;
      }
    }
  }
  else
  {
LABEL_35:
    if (v18 < 0xFFFFFFEE) {
      return 0;
    }
  }
  uint64_t v23 = *(void *)(v19 + 8);
  if (v23 && !*(void *)(v23 + 8))
  {
    uint64_t v24 = *(void *)(v19 - 64);
    unsigned int v25 = *(unsigned __int8 *)(v24 + 16);
    unsigned int v26 = *(unsigned __int8 *)(*(void *)(v19 - 32) + 16);
    BOOL v27 = v26 - 41 < 0x12 && v26 > 0x1B;
    uint64_t v28 = v27 ? *(void *)(v19 - 32) : 0;
    BOOL v29 = v24 && v25 >= 0x1C;
    BOOL v30 = v29 && v25 - 59 >= 0xFFFFFFEE;
    if (v30 && v20 >= 0xFFFFFFEE && v25 != 90 && *(void *)(v24 + 40) == v15 && *(unsigned char *)(v21 + 16) != 90)
    {
      uint64_t v42 = v24;
      uint64_t v43 = v21;
      if (llvm::SLPVectorizerPass::tryToVectorizeList((uint64_t)this, &v42, 2uLL, a3, 0)) {
        return 1;
      }
    }
    if (v28)
    {
      if (v20 >= 0xFFFFFFEE && *(void *)(v28 + 40) == v15 && *(unsigned char *)(v28 + 16) != 90 && *(unsigned char *)(v21 + 16) != 90)
      {
        uint64_t v42 = v28;
        uint64_t v43 = v21;
        if (llvm::SLPVectorizerPass::tryToVectorizeList((uint64_t)this, &v42, 2uLL, a3, 0)) {
          return 1;
        }
      }
    }
  }
  return 0;
}

uint64_t llvm::SLPVectorizerPass::vectorizeRootInstruction(llvm::SLPVectorizerPass *this, llvm::PHINode *a2, llvm::Value *a3, llvm::BasicBlock *a4, llvm::slpvectorizer::BoUpSLP *a5, llvm::TargetTransformInfo *a6)
{
  uint64_t v444 = *MEMORY[0x1E4F143B8];
  if (!a3) {
    goto LABEL_11;
  }
  unsigned int v7 = *((unsigned __int8 *)a3 + 16);
  if (v7 < 0x1C) {
    goto LABEL_11;
  }
  if (v7 - 41 >= 0x12) {
    a2 = 0;
  }
  v372 = a3;
  if (!byte_1EBD016D0 || (v7 != 83 ? (BOOL v10 = *((void *)a3 + 5) == (void)a4) : (BOOL v10 = 0), !v10))
  {
LABEL_11:
    LOBYTE(v11) = 0;
    return v11 & 1;
  }
  long long v370 = 0u;
  long long v371 = 0u;
  *(_OWORD *)uint64_t v369 = 0u;
  LODWORD(v389) = 0;
  sub_1CD8E4CD8(v369, &v372, &v389);
  LOBYTE(v11) = 0;
  int v364 = v368;
  unsigned int v365 = v368;
  uint64_t v366 = 8;
  int v367 = 0;
  BOOL v386 = (char *)&v388;
  uint64_t v387 = 0x200000000;
  uint64_t v15 = *((void *)&v371 + 1);
  if (*((void *)&v371 + 1))
  {
    int v11 = 0;
    int v16 = (uint64_t *)((char *)a5 + 1048);
    BOOL v360 = a2;
    int v358 = (uint64_t *)((char *)a5 + 1048);
    double v357 = a4;
    while (1)
    {
      uint64_t v17 = *(void *)((char *)v369[1] + (((unint64_t)v371 >> 5) & 0x7FFFFFFFFFFFFF8))
          + 16 * v371;
      uint64_t v18 = *(void *)v17;
      int v363 = *(_DWORD *)(v17 + 8);
      *((void *)&v371 + 1) = v15 - 1;
      *(void *)&long long v371 = v371 + 1;
      if ((unint64_t)v371 >= 0x200)
      {
        operator delete(*(void **)v369[1]);
        v369[1] = (char *)v369[1] + 8;
        *(void *)&long long v371 = v371 - 256;
      }
      unint64_t v389 = v18;
      unsigned int v407 = 0;
      if (sub_1CD50F704(v16, &v389, &v407)) {
        goto LABEL_164;
      }
      uint64_t v361 = 0;
      uint64_t v362 = 0;
      if (v18) {
        BOOL v19 = *(unsigned __int8 *)(v18 + 16) - 41 > 0x11;
      }
      else {
        BOOL v19 = 1;
      }
      if (!v19 && *(void *)(v18 - 64) && (uint64_t v362 = *(void *)(v18 - 64), *(void *)(v18 - 32)))
      {
        uint64_t v361 = *(void *)(v18 - 32);
      }
      else
      {
        LODWORD(v389) = 193;
        uint64_t v390 = 0;
        uint64_t v391 = (int32x2_t ****)&v362;
        uint64_t v392 = 1;
        int v393 = &v361;
        if (!sub_1CCE32538((uint64_t)&v389, v18))
        {
          LODWORD(v389) = 202;
          uint64_t v390 = 0;
          uint64_t v391 = (int32x2_t ****)&v362;
          uint64_t v392 = 1;
          int v393 = &v361;
          if (!sub_1CCE32538((uint64_t)&v389, v18))
          {
            LODWORD(v389) = 274;
            uint64_t v390 = 0;
            uint64_t v391 = (int32x2_t ****)&v362;
            uint64_t v392 = 1;
            int v393 = &v361;
            if (!sub_1CCE32538((uint64_t)&v389, v18))
            {
              LODWORD(v389) = 275;
              uint64_t v390 = 0;
              uint64_t v391 = (int32x2_t ****)&v362;
              uint64_t v392 = 1;
              int v393 = &v361;
              if (!sub_1CCE32538((uint64_t)&v389, v18))
              {
                LODWORD(v389) = 305;
                uint64_t v390 = 0;
                uint64_t v391 = (int32x2_t ****)&v362;
                uint64_t v392 = 1;
                int v393 = &v361;
                if (!sub_1CCE32538((uint64_t)&v389, v18))
                {
                  LODWORD(v389) = 306;
                  uint64_t v390 = 0;
                  uint64_t v391 = (int32x2_t ****)&v362;
                  uint64_t v392 = 1;
                  int v393 = &v361;
                  if (!sub_1CCE32538((uint64_t)&v389, v18) && *(unsigned char *)(v18 + 16) != 85) {
                    goto LABEL_122;
                  }
                }
              }
            }
          }
        }
      }
      unint64_t v389 = (unint64_t)&v391;
      uint64_t v390 = 0x200000000;
      uint64_t v394 = v396;
      uint64_t v395 = 0x2000000000;
      v397[0] = 0;
      v397[1] = 0;
      int v398 = 0;
      uint64_t v400 = 0;
      uint64_t v401 = 0;
      uint64_t v399 = 0;
      uint64_t v402 = 6;
      v403 = 0;
      v404 = 0;
      int v406 = -1;
      uint64_t v20 = sub_1CD341AC8(v18);
      unsigned int v405 = v20;
      uint64_t v359 = v18;
      if (v360)
      {
        if (v20)
        {
          BOOL v24 = sub_1CD342028(v18);
          int v25 = *(_DWORD *)(v18 + 20);
          if ((v25 & 0x40000000) != 0) {
            uint64_t v26 = *(void *)(v18 - 8);
          }
          else {
            uint64_t v26 = v18 - 32 * (v25 & 0x7FFFFFF);
          }
          uint64_t v23 = *(llvm::PHINode **)(v26 + 32 * v24);
          unsigned int v22 = v405;
        }
        else
        {
          unsigned int v22 = 0;
          uint64_t v23 = 0;
        }
        if (v23 == v360)
        {
          if (!v22) {
            goto LABEL_97;
          }
          BOOL v27 = sub_1CD342028(v18);
          int v28 = *(_DWORD *)(v18 + 20);
          if ((v28 & 0x40000000) != 0) {
            uint64_t v29 = *(void *)(v18 - 8);
          }
          else {
            uint64_t v29 = v18 - 32 * (v28 & 0x7FFFFFF);
          }
          uint64_t v33 = 32;
          if (v27) {
            uint64_t v33 = 64;
          }
LABEL_52:
          uint64_t v18 = *(void *)(v29 + v33);
          if (v18) {
            BOOL v34 = *(unsigned __int8 *)(v18 + 16) >= 0x1Cu;
          }
          else {
            BOOL v34 = 0;
          }
          if (!v34) {
            goto LABEL_97;
          }
          uint64_t v20 = sub_1CD341AC8(v18);
          uint64_t v21 = 0;
          unsigned int v405 = v20;
          goto LABEL_66;
        }
        if (v22)
        {
          BOOL v30 = sub_1CD342028(v18);
          int v31 = *(_DWORD *)(v18 + 20);
          if ((v31 & 0x40000000) != 0) {
            uint64_t v32 = *(void *)(v18 - 8);
          }
          else {
            uint64_t v32 = v18 - 32 * (v31 & 0x7FFFFFF);
          }
          uint64_t v35 = 32;
          if (v30) {
            uint64_t v35 = 64;
          }
          uint64_t v20 = v405;
          if (*(llvm::PHINode **)(v32 + v35) == v360)
          {
            if (!v405) {
              goto LABEL_97;
            }
            BOOL v36 = sub_1CD342028(v18);
            int v37 = *(_DWORD *)(v18 + 20);
            if ((v37 & 0x40000000) != 0) {
              uint64_t v29 = *(void *)(v18 - 8);
            }
            else {
              uint64_t v29 = v18 - 32 * (v37 & 0x7FFFFFF);
            }
            uint64_t v33 = 32 * v36;
            goto LABEL_52;
          }
        }
        else
        {
          uint64_t v20 = 0;
        }
        uint64_t v21 = v360;
      }
      else
      {
        uint64_t v21 = 0;
      }
LABEL_66:
      if (!sub_1CD341E7C(v20, (unsigned __int8 *)v18)) {
        goto LABEL_97;
      }
      unsigned int v38 = *(unsigned __int8 *)(*(void *)v18 + 8);
      if (v38 > 0x14 || ((1 << v38) & 0x10A07F) == 0) {
        goto LABEL_97;
      }
      if ((v38 & 0xFFFFFFFD) == 4 || v38 == 15) {
        goto LABEL_97;
      }
      if (*(unsigned char *)(v18 + 16) == 85)
      {
        uint64_t v41 = *(void *)(*(void *)(v18 - 96) + 8);
        if (!v41 || *(void *)(v41 + 8)) {
          goto LABEL_97;
        }
      }
      if (v404 != (llvm::ValueAsMetadata *)v18)
      {
        if (v404 && v404 != (llvm::ValueAsMetadata *)-8192 && v404 != (llvm::ValueAsMetadata *)-4096)
        {
          unint64_t v267 = v402 & 0xFFFFFFFFFFFFFFF8;
          *(void *)(v402 & 0xFFFFFFFFFFFFFFF8) = v403;
          if (v403)
          {
            unint64_t *v403 = *v403 & 7 | v267;
          }
          else
          {
            uint64_t v268 = v404;
            uint64_t v269 = ***(int32x2_t ****)v404;
            unint64_t v270 = (unint64_t)v269[303];
            if (v270 <= v267)
            {
              uint64_t v271 = v269[305].u32[0];
              if (v270 + 16 * v271 > v267)
              {
                unsigned int v272 = v271 - 1;
                LODWORD(v273) = v272 & ((v404 >> 4) ^ (v404 >> 9));
                unint64_t v274 = (llvm::ValueAsMetadata **)(v270 + 16 * v273);
                unsigned int v275 = *v274;
                if (v404 == *v274)
                {
LABEL_534:
                  *unint64_t v274 = (llvm::ValueAsMetadata *)-8192;
                  v269[304] = vadd_s32(v269[304], (int32x2_t)0x1FFFFFFFFLL);
                  uint64_t v268 = v404;
                }
                else
                {
                  int v276 = 1;
                  while (v275 != (llvm::ValueAsMetadata *)-4096)
                  {
                    int v277 = v273 + v276++;
                    uint64_t v273 = v277 & v272;
                    unsigned int v275 = *(llvm::ValueAsMetadata **)(v270 + 16 * v273);
                    if (v404 == v275)
                    {
                      unint64_t v274 = (llvm::ValueAsMetadata **)(v270 + 16 * v273);
                      goto LABEL_534;
                    }
                  }
                }
                *((unsigned char *)v268 + 17) &= ~1u;
              }
            }
          }
        }
        v404 = (llvm::ValueAsMetadata *)v18;
        if (v18 != -8192 && v18 != -4096 && v18) {
          llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v402);
        }
      }
      unsigned int v407 = v409;
      uint64_t v408 = 0x2000000000;
      BOOL v42 = sub_1CD342028(v18);
      if (v408 >= (unint64_t)HIDWORD(v408)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v43 = (uint64_t *)((char *)v407 + 16 * v408);
      *uint64_t v43 = v18;
      v43[1] = v42;
      LODWORD(v408) = v408 + 1;
      if (sub_1CD342028(v18))
      {
        BOOL v432 = &v434;
        uint64_t v433 = 0x1000000000;
        unint64_t v44 = 2;
      }
      else
      {
        BOOL v432 = &v434;
        uint64_t v433 = 0x1000000000;
        unint64_t v44 = 1;
      }
      sub_1CD8E4D78((uint64_t)&v389, v44, (uint64_t)&v432);
      if (v432 != &v434) {
        free(v432);
      }
      unsigned int v45 = v408;
      if (!v408)
      {
LABEL_91:
        int v46 = 1;
        goto LABEL_92;
      }
      int v104 = 0;
      while (1)
      {
        while (1)
        {
          BOOL v432 = 0;
          uint64_t v105 = (char *)v407 + 16 * v45;
          BOOL v432 = (void *)*((void *)v105 - 2);
          unint64_t v106 = v432;
          uint64_t v107 = *((unsigned int *)v105 - 2);
          *((_DWORD *)v105 - 2) = v107 + 1;
          int v108 = sub_1CD341AC8((uint64_t)v106);
          if (v108 != v405)
          {
            if (v395 >= (unint64_t)HIDWORD(v395)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((void *)v394 + v395) = v432;
            LODWORD(v395) = v395 + 1;
            goto LABEL_234;
          }
          unsigned int v109 = sub_1CD342028((uint64_t)v432) ? 3 : 2;
          if (v107 >= v109) {
            break;
          }
          unint64_t v110 = v432;
          if (sub_1CD341AC8((uint64_t)v432) == 3 && v107 == 1 && *((unsigned char *)v110 + 16) == 85)
          {
            int v111 = v110[5];
            if ((v111 & 0x40000000) != 0) {
              uint64_t v112 = (char *)*((void *)v110 - 1);
            }
            else {
              uint64_t v112 = (char *)&v110[-8 * (v111 & 0x7FFFFFF)];
            }
            uint64_t v115 = (uint64_t *)(v112 + 64);
          }
          else
          {
            int v113 = v110[5];
            if ((v113 & 0x40000000) != 0) {
              char v114 = (char *)*((void *)v110 - 1);
            }
            else {
              char v114 = (char *)&v110[-8 * (v113 & 0x7FFFFFF)];
            }
            uint64_t v115 = (uint64_t *)&v114[32 * v107];
          }
          uint64_t v116 = *v115;
          unsigned int v117 = *(unsigned __int8 *)(*v115 + 16);
          if (v116) {
            BOOL v118 = v117 >= 0x1C;
          }
          else {
            BOOL v118 = 0;
          }
          if (!v118) {
            goto LABEL_265;
          }
          uint64_t v119 = sub_1CD341AC8(v116);
          if ((llvm::PHINode *)v116 == v21 || v116 == v18) {
            goto LABEL_265;
          }
          uint64_t v6 = v119;
          unsigned int v121 = v405;
          uint64_t v122 = *(void *)(v18 + 40);
          if (sub_1CD342028(v116)
            || (sub_1CCA16428((uint64_t)&v414, (unsigned __int8 *)v116)
             || (BOOL v123 = sub_1CCA16538((uint64_t)v417, (unsigned __int8 *)v116), v124 = v116, v123))
            && (uint64_t v124 = v116, *(unsigned char *)(v116 + 16) == 85))
          {
            uint64_t v124 = *(void *)(v116 - 96);
            BOOL v125 = *(void *)(v116 + 40) != v122 || v124 == 0;
            if (v125 || *(unsigned __int8 *)(v124 + 16) < 0x1Cu) {
              goto LABEL_265;
            }
          }
          if (*(void *)(v124 + 40) != v122) {
            goto LABEL_265;
          }
          if (!sub_1CD342028(v18))
          {
            uint64_t v136 = *(void *)(v116 + 8);
            if (!v136) {
              goto LABEL_265;
            }
            goto LABEL_281;
          }
          uint64_t v133 = *(void *)(v116 + 8);
          if (!v133) {
            goto LABEL_265;
          }
          uint64_t v134 = *(void *)(v133 + 8);
          if (!v134) {
            goto LABEL_265;
          }
          uint64_t v135 = *(void *)(v134 + 8);
          if (*(unsigned char *)(v116 + 16) == 85)
          {
            if (v135) {
              goto LABEL_265;
            }
            uint64_t v136 = *(void *)(*(void *)(v116 - 96) + 8);
            if (!v136) {
              goto LABEL_265;
            }
LABEL_281:
            uint64_t v135 = *(void *)(v136 + 8);
          }
          if (!v135)
          {
            if (v104)
            {
              if (v104 != *(unsigned __int8 *)(v116 + 16) - 28 && v6 != v121) {
                goto LABEL_265;
              }
              if (v6 != v121) {
                goto LABEL_297;
              }
            }
            else if (v6 != v121)
            {
              int v104 = *(unsigned __int8 *)(v116 + 16) - 28;
LABEL_297:
              uint64_t v6 = sub_1CD342028(v116);
              if (v408 >= (unint64_t)HIDWORD(v408)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              char v139 = (uint64_t *)((char *)v407 + 16 * v408);
              *char v139 = v116;
              v139[1] = v6;
              unsigned int v45 = v408 + 1;
              goto LABEL_235;
            }
            if (sub_1CD341E7C(v6, (unsigned __int8 *)v116)) {
              goto LABEL_297;
            }
          }
LABEL_265:
          sub_1CD341F64((uint64_t)&v389, (uint64_t)v407 + 16 * v408 - 16, v116);
          unsigned int v45 = v408;
          if (!v408) {
            goto LABEL_91;
          }
        }
        uint64_t v127 = sub_1CD48D03C((uint64_t)v397, (uint64_t *)&v432);
        if (v400 != (void *)v127 && !*(void *)(v127 + 8)) {
          break;
        }
        int v128 = v432;
        BOOL v129 = sub_1CD342028((uint64_t)v432);
        uint64_t v6 = v389;
        if (v129)
        {
          uint64_t v130 = *(unsigned int *)(v389 + 8);
          if (v130 >= *(_DWORD *)(v389 + 12)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)v389 + 8 * v130) = *(v128 - 12);
          *(_DWORD *)(v6 + 8) = v130 + 1;
          unint64_t v131 = v389;
          uint64_t v132 = *(unsigned int *)(v389 + 152);
          if (v132 >= *(_DWORD *)(v389 + 156)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)(v389 + 144) + 8 * v132) = v128;
          *(_DWORD *)(v131 + 152) = v132 + 1;
        }
        else
        {
          uint64_t v138 = *(unsigned int *)(v389 + 8);
          if (v138 >= *(_DWORD *)(v389 + 12)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)v389 + 8 * v138) = v128;
          *(_DWORD *)(v6 + 8) = v138 + 1;
        }
LABEL_234:
        unsigned int v45 = v408 - 1;
LABEL_235:
        LODWORD(v408) = v45;
        if (!v45) {
          goto LABEL_91;
        }
      }
      if (v408 > 1)
      {
        sub_1CD341F64((uint64_t)&v389, (uint64_t)v407 + 16 * v408 - 32, (uint64_t)v432);
        char v140 = (void *)sub_1CD48D03C((uint64_t)v397, (uint64_t *)&v432);
        if (v400 != v140) {
          sub_1CD8E4FB8(v397, v140);
        }
        goto LABEL_234;
      }
      int v46 = 0;
LABEL_92:
      if (v407 != v409) {
        free(v407);
      }
      if (!v46)
      {
LABEL_97:
        char v47 = 0;
        goto LABEL_98;
      }
      if (v395 < 4)
      {
        uint64_t v6 = 0;
        goto LABEL_652;
      }
      unint64_t v350 = v395;
      uint64_t v347 = a5;
      if (v390)
      {
        unint64_t v142 = v389;
        uint64_t v143 = (char *)(v389 + 144 * v390);
        unsigned int v141 = -1;
        do
        {
          uint64_t v144 = *(unsigned int *)(v142 + 8);
          if (v144)
          {
            uint64_t v145 = *(uint64_t **)v142;
            uint64_t v146 = 8 * v144;
            do
            {
              uint64_t v147 = *v145;
              BOOL v148 = sub_1CB845E74(*v145);
              if (v147) {
                BOOL v149 = !v148;
              }
              else {
                BOOL v149 = 1;
              }
              if (!v149)
              {
                int v150 = *(unsigned __int8 *)(v147 + 17) >> 1;
                if (v150 == 127) {
                  int v150 = -1;
                }
                v141 &= v150;
              }
              ++v145;
              v146 -= 8;
            }
            while (v146);
          }
          v142 += 144;
        }
        while ((char *)v142 != v143);
      }
      else
      {
        unsigned int v141 = -1;
      }
      uint64_t v151 = 0;
      uint64_t v152 = **(void **)v404;
      v417[0] = v418;
      v417[1] = (void *)0x200000000;
      uint64_t v421 = v152;
      uint64_t v422 = &v430;
      v423 = &v431;
      uint64_t v424 = 0;
      unsigned int v425 = 0;
      __int16 v426 = 512;
      char v427 = 7;
      uint64_t v419 = 0;
      unsigned int v420 = 0;
      uint64_t v428 = 0;
      uint64_t v429 = 0;
      unsigned int v430 = &unk_1F2616E88;
      uint64_t v431 = &unk_1F2617008;
      uint64_t v419 = *((void *)v404 + 5);
      unsigned int v420 = (char *)v404 + 24;
      long long v153 = (void *)*((void *)v404 + 6);
      BOOL v432 = v153;
      if (v153)
      {
        llvm::MetadataTracking::track((uint64_t)&v432, (unsigned __int8 *)v153, 2);
        uint64_t v151 = v432;
      }
      sub_1CB8461A4((uint64_t)v417, 0, (uint64_t)v151);
      unint64_t v154 = v350;
      if (v432)
      {
        int v293 = *(unsigned __int8 *)v432;
        if ((v293 - 4) > 0x1E)
        {
          if ((v293 - 3) >= 0xFFFFFFFE) {
            uint64_t v333 = v432;
          }
          else {
            uint64_t v333 = 0;
          }
          if ((v293 - 3) < 0xFFFFFFFE)
          {
            unint64_t v154 = v350;
            if (v293 == 3) {
              *((void *)v432 + 1) = 0;
            }
            goto LABEL_327;
          }
          unint64_t v295 = (unint64_t)v333 + 8;
        }
        else
        {
          if ((*((unsigned char *)v432 + 1) & 0x7F) != 2 && !*((_DWORD *)v432 + 3)) {
            goto LABEL_327;
          }
          uint64_t v294 = *((void *)v432 + 2);
          if ((v294 & 4) == 0) {
            goto LABEL_327;
          }
          unint64_t v295 = v294 & 0xFFFFFFFFFFFFFFF8;
          if (!v295) {
            goto LABEL_327;
          }
        }
        unsigned int v407 = &v432;
        sub_1CC5FA668(v295 + 16, &v407);
        unint64_t v154 = v350;
      }
LABEL_327:
      unsigned int v425 = v141;
      v374[1] = 0;
      v374[0] = 0;
      int v375 = 0;
      uint64_t v377 = 0;
      uint64_t v378 = 0;
      uint64_t v376 = 0;
      int v155 = v399;
      uint64_t v156 = v400;
      while (v155 != v156)
      {
        uint64_t v157 = sub_1CD8DF9A8((uint64_t)v374, v155 + 1);
        unint64_t v158 = *(unsigned int *)(v157 + 8);
        if (v158 >= *(unsigned int *)(v157 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)v157 + 8 * v158) = *v155;
        ++*(_DWORD *)(v157 + 8);
        v155 += 2;
      }
      unsigned int v407 = v404;
      sub_1CD8DF9A8((uint64_t)v374, (uint64_t *)&v407);
      uint64_t v414 = v416;
      uint64_t v415 = 0x1000000000;
      if (v390)
      {
        unint64_t v159 = v389;
        long long v160 = (char *)(v389 + 144 * v390);
        do
        {
          sub_1CB935BDC((unsigned int *)&v414, *(unsigned char **)v159, (unsigned char *)(*(void *)v159 + 8 * *(unsigned int *)(v159 + 8)));
          v159 += 144;
        }
        while ((char *)v159 != v160);
      }
      uint64_t v161 = 1 << (__clz(v154) ^ 0x3Fu);
      a5 = v347;
      if (v154 > v161)
      {
        unsigned int v407 = (void *)1;
        for (uint64_t i = 8; i != 40; i += 8)
          *(_DWORD *)((char *)&v407 + i) = -1;
        long long v163 = (char *)v394;
        if (!v395)
        {
          unint64_t v164 = 0;
          BOOL v432 = &v407;
          unint64_t v165 = (char *)v394;
          goto LABEL_355;
        }
        uint64_t v166 = 8 * v395;
        do
        {
          unsigned int v167 = *(unsigned __int8 *)(*(void *)v163 + 16);
          if (*(void *)v163) {
            BOOL v168 = v167 >= 0x1C;
          }
          else {
            BOOL v168 = 0;
          }
          if (v168 && v167 - 83 >= 0xFFFFFFFE)
          {
            LODWORD(v432) = *(_WORD *)(*(void *)v163 + 18) & 0x3F;
            uint64_t v170 = sub_1CD8E5148(&v407, &v432);
            ++v170[1];
          }
          v163 += 8;
          v166 -= 8;
        }
        while (v166);
        unint64_t v165 = (char *)v394;
        unint64_t v164 = v395;
        long long v163 = (char *)v394 + 8 * v395;
        BOOL v432 = &v407;
        if (v395 < 0x81)
        {
LABEL_355:
          sub_1CD342140(v165, v163, (_DWORD **)&v432, v164, 0, 0);
        }
        else
        {
          unint64_t v154 = v395;
          while (1)
          {
            unint64_t v171 = (uint64_t *)operator new(8 * v154, MEMORY[0x1E4FBA2D0]);
            if (v171) {
              break;
            }
            BOOL v19 = v154 > 1;
            v154 >>= 1;
            if (!v19)
            {
              LODWORD(v154) = v350;
              goto LABEL_355;
            }
          }
          uint64_t v292 = v171;
          sub_1CD342140(v165, v163, (_DWORD **)&v432, v164, v171, v154);
          operator delete(v292);
          LODWORD(v154) = v350;
        }
        if ((v407 & 1) == 0) {
          MEMORY[0x1D25D9CD0](v408, 4);
        }
      }
      uint64_t v6 = 0;
      if (v161 >= 3)
      {
        int v348 = v154 + 1;
        if (v154 + 1 != v161)
        {
          uint64_t v6 = 0;
          unsigned int v172 = 0;
          uint64_t v346 = v141 | 0x100000000;
          while (1)
          {
            int v173 = (uint64_t *)((char *)v394 + 8 * v172);
            llvm::slpvectorizer::BoUpSLP::buildTree((uint64_t)a5, v173, v161, (uint64_t)v414, v415);
            if (llvm::slpvectorizer::BoUpSLP::isTreeTinyAndNotFullyVectorizable(a5, 1)
              || v405 == 3
              && (sub_1CD33164C(****(void ****)a5, *(_DWORD *)(**(void **)a5 + 8), *((void *)a5 + 242), 0) & 1) != 0)
            {
              goto LABEL_582;
            }
            llvm::slpvectorizer::BoUpSLP::reorderTopToBottom((uint64_t **)a5, v174, v175, v176);
            llvm::slpvectorizer::BoUpSLP::reorderBottomToTop(a5, 1, v177, v178);
            llvm::slpvectorizer::BoUpSLP::buildExternalUses((unint64_t)a5, (uint64_t)v374);
            uint64_t v179 = (unsigned __int8 *)v404;
            if (*((unsigned char *)v404 + 16) == 85)
            {
              BOOL v180 = sub_1CCA16428((uint64_t)&v407, (unsigned __int8 *)v404) || sub_1CCA16538((uint64_t)&v432, v179);
              if (v161 != v154 && v180) {
                goto LABEL_582;
              }
            }
            llvm::slpvectorizer::BoUpSLP::computeMinimumValueSizes((uint64_t ****)a5);
            unint64_t TreeCost = llvm::slpvectorizer::BoUpSLP::getTreeCost((void *****)a5, (uint64_t)v394 + 8 * v172, v161);
            unint64_t v353 = v182;
            unint64_t v354 = TreeCost;
            uint64_t v351 = v172;
            uint64_t v183 = (llvm::FixedVectorType *)**((void **)v394 + v172);
            llvm::FixedVectorType::get(v183, (llvm::Type *)v161);
            unint64_t v185 = v184;
            BOOL v432 = 0;
            LODWORD(v433) = 0;
            uint64_t v349 = v173;
            if (((1 << v405) & 0xC3E) != 0)
            {
              uint64_t Opcode = llvm::RecurrenceDescriptor::getOpcode(v405);
              uint64_t v352 = (*(uint64_t (**)(void, uint64_t, _DWORD *, uint64_t, void))(**(void **)a6 + 928))(*(void *)a6, Opcode, v185, v346, 0);
              int v188 = v187;
              BOOL v432 = (void *)(*(uint64_t (**)(void, uint64_t, llvm::FixedVectorType *))(**(void **)a6
                                                                                                 + 824))(*(void *)a6, Opcode, v183);
            }
            else
            {
              if (((1 << v405) & 0x3C0) != 0)
              {
                if (v183) {
                  BOOL v190 = (*((_DWORD *)v183 + 2) & 0xFE) == 18;
                }
                else {
                  BOOL v190 = 0;
                }
                if (v190)
                {
                  unint64_t v257 = (llvm::Type *)*((unsigned int *)v183 + 8);
                  unint64_t v258 = (uint64_t **)(**(void **)v183 + 1888);
                  if (*((_DWORD *)v183 + 2) == 19) {
                    llvm::ScalableVectorType::get(v258, v257);
                  }
                  else {
                    llvm::FixedVectorType::get((llvm::FixedVectorType *)v258, v257);
                  }
                  a5 = v347;
                }
                unint64_t v191 = (uint64_t **)(**(void **)v185 + 1888);
                unsigned int v345 = v172;
                if (v185 && (v185[2] & 0xFE) == 0x12)
                {
                  uint64_t v259 = (llvm::Type *)v185[8];
                  if (v185[2] == 19) {
                    llvm::ScalableVectorType::get(v191, v259);
                  }
                  else {
                    llvm::FixedVectorType::get((llvm::FixedVectorType *)v191, v259);
                  }
                  unint64_t v191 = v260;
                  a5 = v347;
                }
                uint64_t v352 = (*(uint64_t (**)(void, _DWORD *, uint64_t **, BOOL, void))(**(void **)a6 + 936))(*(void *)a6, v185, v191, (v405 & 0xFFFFFFFE) == 8, 0);
                int v193 = v192;
                uint64_t v194 = (*(uint64_t (**)(void))(**(void **)a6 + 864))();
                int v343 = v195;
                uint64_t v196 = (*(uint64_t (**)(void))(**(void **)a6 + 864))();
                BOOL v198 = __OFADD__(v194, v196);
                int64_t v199 = v194 + v196;
                int v188 = v193;
                if (v198) {
                  int64_t v199 = (v199 >> 63) ^ 0x8000000000000000;
                }
                BOOL v432 = (void *)v199;
                BOOL v200 = v197 == 1;
                int v201 = v343;
                unsigned int v172 = v345;
              }
              else
              {
                if (v183) {
                  BOOL v202 = (*((_DWORD *)v183 + 2) & 0xFE) == 18;
                }
                else {
                  BOOL v202 = 0;
                }
                if (v202)
                {
                  uint64_t v261 = (llvm::Type *)*((unsigned int *)v183 + 8);
                  uint64_t v262 = (uint64_t **)(**(void **)v183 + 1888);
                  if (*((_DWORD *)v183 + 2) == 19) {
                    llvm::ScalableVectorType::get(v262, v261);
                  }
                  else {
                    llvm::FixedVectorType::get((llvm::FixedVectorType *)v262, v261);
                  }
                  a5 = v347;
                }
                unint64_t v203 = (uint64_t **)(**(void **)v185 + 1888);
                if (v185 && (v185[2] & 0xFE) == 0x12)
                {
                  int v263 = (llvm::Type *)v185[8];
                  if (v185[2] == 19) {
                    llvm::ScalableVectorType::get(v203, v263);
                  }
                  else {
                    llvm::FixedVectorType::get((llvm::FixedVectorType *)v203, v263);
                  }
                  unint64_t v203 = v264;
                  a5 = v347;
                }
                uint64_t v352 = (*(uint64_t (**)(void, _DWORD *, uint64_t **, void, void))(**(void **)a6 + 936))(*(void *)a6, v185, v203, 0, 0);
                int v188 = v204;
                uint64_t v342 = (*(uint64_t (**)(void))(**(void **)a6 + 864))();
                int v344 = v205;
                uint64_t v206 = (*(uint64_t (**)(void))(**(void **)a6 + 864))();
                unsigned int v208 = (void *)(v342 + v206);
                if (__OFADD__(v342, v206)) {
                  unsigned int v208 = (void *)(((v342 + v206) >> 63) ^ 0x8000000000000000);
                }
                BOOL v432 = v208;
                BOOL v200 = v207 == 1;
                int v201 = v344;
              }
              if (v200) {
                int v189 = 1;
              }
              else {
                int v189 = v201;
              }
            }
            LODWORD(v433) = v189;
            int v209 = v161;
            unsigned int v407 = (void *)(v161 - 1);
            LODWORD(v408) = 0;
            sub_1CB90C9D4((uint64_t)&v432, (uint64_t)&v407);
            unint64_t v210 = v352 - (void)v432;
            if (__OFSUB__(v352, v432)) {
              unint64_t v210 = ((v352 - (uint64_t)v432) >> 63) ^ 0x8000000000000000;
            }
            if (v188 == 1 || v433 == 1) {
              unint64_t v212 = v353 & 0xFFFFFFFF00000000 | 1;
            }
            else {
              unint64_t v212 = v353;
            }
            BOOL v198 = __OFADD__(v354, v210);
            uint64_t v213 = v354 + v210;
            unint64_t v214 = ((uint64_t)(v354 + v210) >> 63) ^ 0x8000000000000000;
            if (v198) {
              uint64_t v215 = v214;
            }
            else {
              uint64_t v215 = v213;
            }
            if (v212)
            {
              uint64_t v6 = 0;
              goto LABEL_648;
            }
            uint64_t v216 = (uint64_t ***)*((void *)a5 + 249);
            uint64_t v217 = *(void *)***v216;
            uint64_t v218 = *(void *)(v217 + 128);
            if (v215 >= -(uint64_t)dword_1EBD01610) {
              break;
            }
            if (v218
              || (*(unsigned int (**)(void))(**(void **)(v217 + 72) + 48))(*(void *)(v217 + 72)))
            {
              llvm::OptimizationRemark::OptimizationRemark((uint64_t)&v407, (uint64_t)"slp-vectorizer", (uint64_t)"VectorizedHorizontalReduction", 29, *v349);
              v382[0] = "Vectorized horizontal reduction with cost ";
              v382[1] = (void *)42;
              sub_1CC59ADEC((uint64_t *)&v411, (uint64_t)v382);
              llvm::DiagnosticInfoOptimizationBase::Argument::Argument((uint64_t)v382, "Cost", 4uLL, v215, v212);
              uint64_t v219 = sub_1CD3D6290((uint64_t)&v407, (long long *)v382);
              v379.__r_.__value_.__r.__words[0] = (std::string::size_type)" and with tree size ";
              v379.__r_.__value_.__l.__size_ = 20;
              sub_1CC59ADEC((uint64_t *)(v219 + 80), (uint64_t)&v379);
              llvm::DiagnosticInfoOptimizationBase::Argument::Argument(&v379, "TreeSize", 8uLL, *((_DWORD *)a5 + 2));
              uint64_t v220 = sub_1CD3D6290(v219, (long long *)&v379);
              uint64_t v221 = v220;
              int v222 = *(_DWORD *)(v220 + 8);
              BYTE4(v433) = *(unsigned char *)(v220 + 12);
              LODWORD(v433) = v222;
              long long v223 = *(_OWORD *)(v220 + 16);
              uint64_t v435 = *(void *)(v220 + 32);
              long long v434 = v223;
              uint64_t v224 = *(void *)(v220 + 72);
              long long v225 = *(_OWORD *)(v220 + 56);
              long long v436 = *(_OWORD *)(v220 + 40);
              long long v437 = v225;
              uint64_t v438 = v224;
              BOOL v432 = &unk_1F2616800;
              v439 = v441;
              uint64_t v440 = 0x400000000;
              if (*(_DWORD *)(v220 + 88)) {
                sub_1CD494D68((uint64_t)&v439, v220 + 80);
              }
              uint64_t v226 = *(void *)(v221 + 360);
              uint64_t v442 = *(void *)(v221 + 352);
              uint64_t v443 = v226;
              BOOL v432 = &unk_1F2616570;
              if (v381 < 0) {
                operator delete(__p);
              }
              if (SHIBYTE(v379.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v379.__r_.__value_.__l.__data_);
              }
              if (v385 < 0) {
                operator delete(v384);
              }
              if (v383 < 0) {
                operator delete(v382[0]);
              }
              unsigned int v407 = &unk_1F2616800;
              int v227 = (char *)v411;
              if (v412)
              {
                uint64_t v355 = v216;
                unsigned int v228 = v172;
                unint64_t v229 = (unint64_t)v412 << 6;
                do
                {
                  unint64_t v230 = (void **)&v227[v229];
                  if (v227[v229 - 17] < 0) {
                    operator delete(*(v230 - 5));
                  }
                  if (*((char *)v230 - 41) < 0) {
                    operator delete(*(v230 - 8));
                  }
                  v229 -= 64;
                }
                while (v229);
                int v227 = (char *)v411;
                unsigned int v172 = v228;
                uint64_t v216 = v355;
              }
              if (v227 != v413) {
                free(v227);
              }
              llvm::OptimizationRemarkEmitter::emit(v216, (llvm::DiagnosticInfoOptimizationBase *)&v432);
              BOOL v432 = &unk_1F2616800;
              uint64_t v231 = (char *)v439;
              int v209 = v161;
              if (v440)
              {
                unsigned int v232 = v172;
                unint64_t v233 = (unint64_t)v440 << 6;
                do
                {
                  BOOL v234 = (void **)&v231[v233];
                  if (v231[v233 - 17] < 0) {
                    operator delete(*(v234 - 5));
                  }
                  if (*((char *)v234 - 41) < 0) {
                    operator delete(*(v234 - 8));
                  }
                  v233 -= 64;
                }
                while (v233);
                uint64_t v231 = (char *)v439;
                unsigned int v172 = v232;
              }
              if (v231 != v441) {
                free(v231);
              }
            }
            uint64_t v235 = *(void **)(*((void *)v394 + v351) + 48);
            v382[0] = v235;
            if (v235) {
              llvm::MetadataTracking::track((uint64_t)v382, (unsigned __int8 *)v235, 2);
            }
            uint64_t v236 = (llvm::Value *)llvm::slpvectorizer::BoUpSLP::vectorizeTree((uint64_t ****)a5, (uint64_t)v374);
            uint64_t v237 = v404;
            if (sub_1CD342028((uint64_t)v404))
            {
              uint64_t v238 = *((void *)v237 - 12);
              uint64_t v419 = *(void *)(v238 + 40);
              unsigned int v420 = (char *)(v238 + 24);
              unint64_t v239 = *(void **)(v238 + 48);
            }
            else
            {
              uint64_t v419 = *((void *)v237 + 5);
              unsigned int v420 = (char *)v237 + 24;
              unint64_t v239 = (void *)*((void *)v237 + 6);
            }
            BOOL v432 = v239;
            if (v239)
            {
              llvm::MetadataTracking::track((uint64_t)&v432, (unsigned __int8 *)v239, 2);
              uint64_t v240 = v432;
            }
            else
            {
              uint64_t v240 = 0;
            }
            sub_1CB8461A4((uint64_t)v417, 0, (uint64_t)v240);
            if (v432)
            {
              int v253 = *(unsigned __int8 *)v432;
              if ((v253 - 4) > 0x1E)
              {
                if ((v253 - 3) >= 0xFFFFFFFE) {
                  unint64_t v256 = v432;
                }
                else {
                  unint64_t v256 = 0;
                }
                if ((v253 - 3) >= 0xFFFFFFFE)
                {
                  unint64_t v255 = (unint64_t)v256 + 8;
LABEL_499:
                  unsigned int v407 = &v432;
                  sub_1CC5FA668(v255 + 16, &v407);
                  a5 = v347;
                  goto LABEL_447;
                }
                a5 = v347;
                if (v253 == 3) {
                  *((void *)v432 + 1) = 0;
                }
              }
              else if ((*((unsigned char *)v432 + 1) & 0x7F) == 2 || *((_DWORD *)v432 + 3))
              {
                uint64_t v254 = *((void *)v432 + 2);
                if ((v254 & 4) != 0)
                {
                  unint64_t v255 = v254 & 0xFFFFFFFFFFFFFFF8;
                  if (v255) {
                    goto LABEL_499;
                  }
                }
              }
            }
LABEL_447:
            if (*((unsigned char *)v237 + 16) == 85
              && (sub_1CCA16428((uint64_t)&v407, (unsigned __int8 *)v237)
               || sub_1CCA16538((uint64_t)&v432, (unsigned __int8 *)v237)))
            {
              LOWORD(v435) = 257;
              uint64_t v241 = operator new(0x60uLL);
              v241[13] = v241[13] & 0x38000000 | 1;
              uint64_t v242 = (llvm::Instruction *)(v241 + 8);
              *(void *)uint64_t v241 = 0;
              *((void *)v241 + 1) = 0;
              *((void *)v241 + 2) = 0;
              *((void *)v241 + 3) = v241 + 8;
              __int16 v410 = 257;
              llvm::FreezeInst::FreezeInst((llvm::FreezeInst *)(v241 + 8), v236, (const char **)&v407, 0);
              uint64_t v236 = sub_1CB844E0C((uint64_t *)v417, v242, (uint64_t)&v432);
            }
            uint64_t SimpleTargetReduction = llvm::createSimpleTargetReduction((llvm::IRBuilderBase *)v417, a6, v236, v405);
            unint64_t v244 = (llvm::Value *)SimpleTargetReduction;
            LODWORD(v154) = v350;
            if (!v6)
            {
              uint64_t v6 = SimpleTargetReduction;
              goto LABEL_461;
            }
            v373 = (unsigned __int8 *)v382[0];
            if (v382[0])
            {
              llvm::MetadataTracking::track((uint64_t)&v373, (unsigned __int8 *)v382[0], 2);
              uint64_t v245 = (uint64_t)v373;
            }
            else
            {
              uint64_t v245 = 0;
            }
            sub_1CB8461A4((uint64_t)v417, 0, v245);
            if (v373)
            {
              int v246 = *v373;
              if ((v246 - 4) > 0x1E)
              {
                if ((v246 - 3) >= 0xFFFFFFFE) {
                  uint64_t v251 = v373;
                }
                else {
                  uint64_t v251 = 0;
                }
                if ((v246 - 3) < 0xFFFFFFFE)
                {
                  if (v246 == 3) {
                    *((void *)v373 + 1) = 0;
                  }
                  goto LABEL_460;
                }
                unint64_t v252 = (unint64_t)(v251 + 8);
              }
              else
              {
                if ((v373[1] & 0x7F) != 2 && !*((_DWORD *)v373 + 3)) {
                  goto LABEL_460;
                }
                uint64_t v266 = *((void *)v373 + 2);
                if ((v266 & 4) == 0) {
                  goto LABEL_460;
                }
                unint64_t v252 = v266 & 0xFFFFFFFFFFFFFFF8;
                if (!v252) {
                  goto LABEL_460;
                }
              }
              unsigned int v407 = &v373;
              sub_1CC5FA668(v252 + 16, &v407);
            }
LABEL_460:
            unsigned int v407 = "op.rdx";
            __int16 v410 = 259;
            uint64_t v6 = sub_1CD34206C((uint64_t)v417, v405, (llvm::Value *)v6, v244, (const llvm::Twine *)&v407, (uint64_t ***)&v389);
LABEL_461:
            v172 += v209;
            uint64_t v161 = 1 << ~__clz(v350 - v172);
            if (v350 == v172) {
              unsigned int v247 = 0;
            }
            else {
              unsigned int v247 = v161;
            }
            if (!v382[0]) {
              goto LABEL_468;
            }
            int v248 = *(unsigned __int8 *)v382[0];
            if ((v248 - 4) > 0x1E)
            {
              if ((v248 - 3) >= 0xFFFFFFFE) {
                unsigned int v249 = v382[0];
              }
              else {
                unsigned int v249 = 0;
              }
              if ((v248 - 3) < 0xFFFFFFFE)
              {
                if (v248 == 3) {
                  *((void *)v382[0] + 1) = 0;
                }
                goto LABEL_468;
              }
              unint64_t v250 = (unint64_t)v249 + 8;
            }
            else
            {
              if ((*((unsigned char *)v382[0] + 1) & 0x7F) != 2 && !*((_DWORD *)v382[0] + 3)) {
                goto LABEL_468;
              }
              uint64_t v265 = *((void *)v382[0] + 2);
              if ((v265 & 4) == 0) {
                goto LABEL_468;
              }
              unint64_t v250 = v265 & 0xFFFFFFFFFFFFFFF8;
              if (!v250) {
                goto LABEL_468;
              }
            }
            unsigned int v407 = v382;
            sub_1CC5FA668(v250 + 16, &v407);
LABEL_468:
            if (v247 < 3 || v172 >= v348 - v247) {
              goto LABEL_582;
            }
          }
          if (v218
            || (*(unsigned int (**)(void))(**(void **)(v217 + 72) + 48))(*(void *)(v217 + 72)))
          {
            int v279 = v216;
            llvm::OptimizationRemarkMissed::OptimizationRemarkMissed((uint64_t)&v407, (uint64_t)"slp-vectorizer", (uint64_t)"HorSLPNotBeneficial", 19, *v349);
            v382[0] = "Vectorizing horizontal reduction is possible";
            v382[1] = (void *)44;
            sub_1CC59ADEC((uint64_t *)&v411, (uint64_t)v382);
            v382[0] = "but not beneficial with cost ";
            v382[1] = (void *)29;
            sub_1CC59ADEC((uint64_t *)&v411, (uint64_t)v382);
            llvm::DiagnosticInfoOptimizationBase::Argument::Argument((uint64_t)v382, "Cost", 4uLL, v215, v212);
            uint64_t v280 = sub_1CD3D6290((uint64_t)&v407, (long long *)v382);
            v379.__r_.__value_.__r.__words[0] = (std::string::size_type)" and threshold ";
            v379.__r_.__value_.__l.__size_ = 15;
            sub_1CC59ADEC((uint64_t *)(v280 + 80), (uint64_t)&v379);
            llvm::DiagnosticInfoOptimizationBase::Argument::Argument(&v379, "Threshold", 9uLL, -dword_1EBD01610);
            uint64_t v281 = sub_1CD3D6290(v280, (long long *)&v379);
            uint64_t v282 = v281;
            int v283 = *(_DWORD *)(v281 + 8);
            BYTE4(v433) = *(unsigned char *)(v281 + 12);
            LODWORD(v433) = v283;
            long long v284 = *(_OWORD *)(v281 + 16);
            uint64_t v435 = *(void *)(v281 + 32);
            long long v434 = v284;
            uint64_t v285 = *(void *)(v281 + 72);
            long long v286 = *(_OWORD *)(v281 + 56);
            long long v436 = *(_OWORD *)(v281 + 40);
            long long v437 = v286;
            uint64_t v438 = v285;
            BOOL v432 = &unk_1F2616800;
            v439 = v441;
            uint64_t v440 = 0x400000000;
            if (*(_DWORD *)(v281 + 88)) {
              sub_1CD494D68((uint64_t)&v439, v281 + 80);
            }
            uint64_t v287 = *(void *)(v282 + 360);
            uint64_t v442 = *(void *)(v282 + 352);
            uint64_t v443 = v287;
            BOOL v432 = &unk_1F26165A8;
            if (v381 < 0) {
              operator delete(__p);
            }
            if (SHIBYTE(v379.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v379.__r_.__value_.__l.__data_);
            }
            if (v385 < 0) {
              operator delete(v384);
            }
            if (v383 < 0) {
              operator delete(v382[0]);
            }
            unsigned int v407 = &unk_1F2616800;
            uint64_t v288 = (char *)v411;
            if (v412)
            {
              unsigned int v289 = v172;
              unint64_t v290 = (unint64_t)v412 << 6;
              do
              {
                uint64_t v291 = (void **)&v288[v290];
                if (v288[v290 - 17] < 0) {
                  operator delete(*(v291 - 5));
                }
                if (*((char *)v291 - 41) < 0) {
                  operator delete(*(v291 - 8));
                }
                v290 -= 64;
              }
              while (v290);
              uint64_t v288 = (char *)v411;
              unsigned int v172 = v289;
              uint64_t v216 = v279;
            }
            if (v288 != v413) {
              free(v288);
            }
            llvm::OptimizationRemarkEmitter::emit(v216, (llvm::DiagnosticInfoOptimizationBase *)&v432);
            BOOL v432 = &unk_1F2616800;
            uint64_t v296 = (char *)v439;
            if (v440)
            {
              unsigned int v297 = v172;
              unint64_t v298 = (unint64_t)v440 << 6;
              do
              {
                int v299 = (void **)&v296[v298];
                if (v296[v298 - 17] < 0) {
                  operator delete(*(v299 - 5));
                }
                if (*((char *)v299 - 41) < 0) {
                  operator delete(*(v299 - 8));
                }
                v298 -= 64;
              }
              while (v298);
              uint64_t v296 = (char *)v439;
              unsigned int v172 = v297;
            }
            if (v296 != v441) {
              free(v296);
            }
          }
          LODWORD(v154) = v350;
LABEL_582:
          if (v6)
          {
            if (v172 < v154)
            {
              int v300 = v154 - v172;
              uint64_t v301 = 8 * v172;
              do
              {
                uint64_t v302 = *(llvm::Value **)((char *)v394 + v301);
                long long v303 = (void *)*((void *)v302 + 6);
                v382[0] = v303;
                if (v303)
                {
                  llvm::MetadataTracking::track((uint64_t)v382, (unsigned __int8 *)v303, 2);
                  int v304 = v382[0];
                }
                else
                {
                  int v304 = 0;
                }
                sub_1CB8461A4((uint64_t)v417, 0, (uint64_t)v304);
                if (!v382[0]) {
                  goto LABEL_592;
                }
                int v305 = *(unsigned __int8 *)v382[0];
                if ((v305 - 4) > 0x1E)
                {
                  if ((v305 - 3) >= 0xFFFFFFFE) {
                    unint64_t v306 = v382[0];
                  }
                  else {
                    unint64_t v306 = 0;
                  }
                  if ((v305 - 3) < 0xFFFFFFFE)
                  {
                    if (v305 == 3) {
                      *((void *)v382[0] + 1) = 0;
                    }
                    goto LABEL_592;
                  }
                  unint64_t v307 = (unint64_t)v306 + 8;
                }
                else
                {
                  if ((*((unsigned char *)v382[0] + 1) & 0x7F) != 2 && !*((_DWORD *)v382[0] + 3)) {
                    goto LABEL_592;
                  }
                  uint64_t v308 = *((void *)v382[0] + 2);
                  if ((v308 & 4) == 0) {
                    goto LABEL_592;
                  }
                  unint64_t v307 = v308 & 0xFFFFFFFFFFFFFFF8;
                  if (!v307) {
                    goto LABEL_592;
                  }
                }
                unsigned int v407 = v382;
                sub_1CC5FA668(v307 + 16, &v407);
LABEL_592:
                __int16 v410 = 257;
                uint64_t v6 = sub_1CD34206C((uint64_t)v417, v405, (llvm::Value *)v6, v302, (const llvm::Twine *)&v407, (uint64_t ***)&v389);
                v301 += 8;
                --v300;
              }
              while (v300);
            }
            uint64_t v309 = v376;
            uint64_t v310 = v377;
            while (2)
            {
              if (v309 != v310)
              {
                uint64_t v311 = *(unsigned int *)(v309 + 16);
                if (!v311)
                {
LABEL_641:
                  v309 += 40;
                  continue;
                }
                uint64_t v312 = *(void *)(v309 + 8);
                uint64_t v313 = 8 * v311;
                while (2)
                {
                  uint64_t v314 = *(unsigned char **)v312;
                  unint64_t v315 = *(unsigned __int8 **)(*(void *)v312 + 48);
                  v379.__r_.__value_.__r.__words[0] = (std::string::size_type)v315;
                  if (v315)
                  {
                    llvm::MetadataTracking::track((uint64_t)&v379, v315, 2);
                    uint64_t v316 = v379.__r_.__value_.__r.__words[0];
                  }
                  else
                  {
                    uint64_t v316 = 0;
                  }
                  sub_1CB8461A4((uint64_t)v417, 0, v316);
                  if (v379.__r_.__value_.__r.__words[0])
                  {
                    int v317 = *v379.__r_.__value_.__l.__data_;
                    if ((v317 - 4) > 0x1E)
                    {
                      if ((v317 - 3) >= 0xFFFFFFFE) {
                        std::string::size_type v325 = v379.__r_.__value_.__r.__words[0];
                      }
                      else {
                        std::string::size_type v325 = 0;
                      }
                      if ((v317 - 3) >= 0xFFFFFFFE)
                      {
                        unint64_t v326 = v325 + 8;
                        goto LABEL_635;
                      }
                      if (v317 == 3) {
                        *(void *)(v379.__r_.__value_.__r.__words[0] + 8) = 0;
                      }
                    }
                    else if ((*(unsigned char *)(v379.__r_.__value_.__r.__words[0] + 1) & 0x7F) == 2 {
                           || *(_DWORD *)(v379.__r_.__value_.__r.__words[0] + 12))
                    }
                    {
                      uint64_t v327 = *(void *)(v379.__r_.__value_.__r.__words[0] + 16);
                      if ((v327 & 4) != 0)
                      {
                        unint64_t v326 = v327 & 0xFFFFFFFFFFFFFFF8;
                        if (v326)
                        {
LABEL_635:
                          unsigned int v407 = &v379;
                          sub_1CC5FA668(v326 + 16, &v407);
                        }
                      }
                    }
                  }
                  unsigned int v318 = v405;
                  unsigned int v319 = *(llvm::Value **)v309;
                  unsigned int v407 = "op.extra";
                  __int16 v410 = 259;
                  if (v314[16] == 85) {
                    BOOL v320 = v314;
                  }
                  else {
                    BOOL v320 = 0;
                  }
                  unsigned int v321 = sub_1CD342FB8((uint64_t)v417, v405, (llvm::Value *)v6, v319, (const llvm::Twine *)&v407, v320 != 0);
                  uint64_t v6 = (uint64_t)v321;
                  if (v318 - 6 <= 3 && v320 != 0 && *((unsigned char *)v321 + 16) == 85 && v321 != 0)
                  {
                    uint64_t v324 = *((void *)v321 - 12);
                    BOOL v432 = (void *)*((void *)v320 - 12);
                    llvm::propagateIRFlags(v324, (uint64_t *)&v432, 1, 0);
                  }
                  BOOL v432 = v314;
                  llvm::propagateIRFlags(v6, (uint64_t *)&v432, 1, 0);
                  v312 += 8;
                  v313 -= 8;
                  if (!v313) {
                    goto LABEL_641;
                  }
                  continue;
                }
              }
              break;
            }
            llvm::Value::doRAUW(v404, (llvm::Value *)v6, (llvm::Value *)1);
            if (v415)
            {
              uint64_t v329 = (llvm::UndefValue ***)v414;
              uint64_t v330 = 8 * v415;
              a5 = v347;
              do
              {
                int v331 = *v329;
                if ((*v329)[1])
                {
                  uint64_t v332 = llvm::UndefValue::get(*v331, v328);
                  llvm::Value::doRAUW((llvm::ValueAsMetadata *)v331, v332, (llvm::Value *)1);
                }
                BOOL v432 = v331;
                sub_1CD50F67C((uint64_t)v358, &v432, (uint64_t)&v407);
                ++v329;
                v330 -= 8;
              }
              while (v330);
            }
            else
            {
              a5 = v347;
            }
          }
        }
      }
LABEL_648:
      if (v414 != v416) {
        free(v414);
      }
      sub_1CD8E420C((uint64_t)v374);
      if (v417[0] != v418) {
        free(v417[0]);
      }
LABEL_652:
      char v47 = 1;
LABEL_98:
      if (v404 != (llvm::ValueAsMetadata *)-8192 && v404 != (llvm::ValueAsMetadata *)-4096 && v404)
      {
        unint64_t v48 = v402 & 0xFFFFFFFFFFFFFFF8;
        *(void *)(v402 & 0xFFFFFFFFFFFFFFF8) = v403;
        if (v403)
        {
          unint64_t *v403 = *v403 & 7 | v48;
        }
        else
        {
          uint64_t v49 = v404;
          uint64_t v50 = ***(int32x2_t ****)v404;
          unint64_t v51 = (unint64_t)v50[303];
          if (v51 <= v48)
          {
            uint64_t v52 = v50[305].u32[0];
            if (v51 + 16 * v52 > v48)
            {
              unsigned int v53 = v52 - 1;
              LODWORD(v54) = v53 & ((v404 >> 4) ^ (v404 >> 9));
              unsigned int v55 = (llvm::ValueAsMetadata **)(v51 + 16 * v54);
              uint64_t v56 = *v55;
              if (v404 == *v55)
              {
LABEL_109:
                void *v55 = (llvm::ValueAsMetadata *)-8192;
                v50[304] = vadd_s32(v50[304], (int32x2_t)0x1FFFFFFFFLL);
                uint64_t v49 = v404;
              }
              else
              {
                int v57 = 1;
                while (v56 != (llvm::ValueAsMetadata *)-4096)
                {
                  int v58 = v54 + v57++;
                  uint64_t v54 = v58 & v53;
                  uint64_t v56 = *(llvm::ValueAsMetadata **)(v51 + 16 * v54);
                  if (v404 == v56)
                  {
                    unsigned int v55 = (llvm::ValueAsMetadata **)(v51 + 16 * v54);
                    goto LABEL_109;
                  }
                }
              }
              *((unsigned char *)v49 + 17) &= ~1u;
            }
          }
        }
      }
      sub_1CD456CB4(v397);
      if (v394 != v396) {
        free(v394);
      }
      sub_1CD63C448((char **)&v389);
      char v59 = v47 ^ 1;
      if (!v6) {
        char v59 = 1;
      }
      uint64_t v18 = v359;
      if ((v59 & 1) == 0)
      {
        if (*(unsigned __int8 *)(v6 + 16) <= 0x1Bu) {
          uint64_t v60 = 0;
        }
        else {
          uint64_t v60 = (char *)v6;
        }
        unint64_t v389 = (unint64_t)v60;
        if (!v60)
        {
          int v11 = 1;
          int v16 = v358;
          uint64_t v61 = v357;
          goto LABEL_125;
        }
        sub_1CD8E4CD8(v369, &v389, &v363);
        int v11 = 1;
        int v16 = v358;
        goto LABEL_163;
      }
LABEL_122:
      if (!v360)
      {
        int v16 = v358;
        uint64_t v61 = v357;
LABEL_124:
        if (*(unsigned __int8 *)(v18 + 16) - 81 >= 2)
        {
          unint64_t v389 = 6;
          uint64_t v390 = 0;
          uint64_t v391 = (int32x2_t ****)v18;
          if (v18 != -8192 && v18 != -4096 && v18) {
            llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v389);
          }
          uint64_t v66 = v386;
          if (v387 >= HIDWORD(v387))
          {
            unint64_t v278 = v387 + 1;
            if (v386 <= (char *)&v389 && &v386[24 * v387] > (char *)&v389)
            {
              uint64_t v334 = (char *)&v389 - v386;
              sub_1CC261F80((unsigned int *)&v386, v278);
              uint64_t v66 = v386;
              uint64_t v67 = &v386[v334];
            }
            else
            {
              sub_1CC261F80((unsigned int *)&v386, v278);
              uint64_t v67 = (char *)&v389;
              uint64_t v66 = v386;
            }
          }
          else
          {
            uint64_t v67 = (char *)&v389;
          }
          int v68 = v387;
          uint64_t v69 = (unint64_t *)&v66[24 * v387];
          unint64_t *v69 = 6;
          v69[1] = 0;
          unint64_t v70 = *((void *)v67 + 2);
          v69[2] = v70;
          if (v70 != -8192 && v70 != -4096)
          {
            if (v70)
            {
              unint64_t v71 = *(void *)v67 & 0xFFFFFFFFFFFFFFF8;
              v69[1] = *(void *)v71;
              *(void *)unint64_t v71 = v69;
              unint64_t *v69 = v71 | 6;
              BOOL v72 = (unint64_t *)v69[1];
              if (v72) {
                *BOOL v72 = *v72 & 7 | (unint64_t)(v69 + 1);
              }
            }
          }
          LODWORD(v387) = v68 + 1;
          if (v391 != (int32x2_t ****)-8192 && v391 != (int32x2_t ****)-4096 && v391)
          {
            unint64_t v73 = v389 & 0xFFFFFFFFFFFFFFF8;
            *(void *)(v389 & 0xFFFFFFFFFFFFFFF8) = v390;
            if (v390)
            {
              *(void *)uint64_t v390 = *(void *)v390 & 7 | v73;
            }
            else
            {
              int v74 = v391;
              BOOL v75 = ***v391;
              unint64_t v76 = (unint64_t)v75[303];
              if (v76 <= v73)
              {
                uint64_t v77 = v75[305].u32[0];
                if (v76 + 16 * v77 > v73)
                {
                  unsigned int v78 = v77 - 1;
                  LODWORD(v79) = v78 & ((v391 >> 4) ^ (v391 >> 9));
                  uint64_t v80 = (int32x2_t *****)(v76 + 16 * v79);
                  unsigned int v81 = *v80;
                  if (v391 == *v80)
                  {
LABEL_159:
                    *uint64_t v80 = (int32x2_t ****)-8192;
                    v75[304] = vadd_s32(v75[304], (int32x2_t)0x1FFFFFFFFLL);
                    int v74 = v391;
                  }
                  else
                  {
                    int v82 = 1;
                    while (v81 != (int32x2_t ****)-4096)
                    {
                      int v83 = v79 + v82++;
                      uint64_t v79 = v83 & v78;
                      unsigned int v81 = *(int32x2_t *****)(v76 + 16 * v79);
                      if (v391 == v81)
                      {
                        uint64_t v80 = (int32x2_t *****)(v76 + 16 * v79);
                        goto LABEL_159;
                      }
                    }
                  }
                  *((unsigned char *)v74 + 17) &= ~1u;
                }
              }
            }
          }
        }
LABEL_125:
        if (++v363 >= dword_1EBD01C10) {
          goto LABEL_163;
        }
        int v62 = *(_DWORD *)(v18 + 20);
        if ((v62 & 0x40000000) != 0)
        {
          char v64 = *(unint64_t **)(v18 - 8);
          uint64_t v63 = v62 & 0x7FFFFFF;
        }
        else
        {
          uint64_t v63 = v62 & 0x7FFFFFF;
          char v64 = (unint64_t *)(v18 - 32 * v63);
        }
        if (!v63) {
          goto LABEL_163;
        }
        uint64_t v84 = &v64[4 * v63];
        while (2)
        {
          unint64_t v85 = *v64;
          uint64_t v86 = v365;
          uint64_t v87 = HIDWORD(v366);
          if (v365 == v364)
          {
            if (HIDWORD(v366))
            {
              uint64_t v88 = 0;
              uint64_t v89 = 8 * HIDWORD(v366);
              uint64_t v90 = (unint64_t *)v365;
              while (*v90 != v85)
              {
                if (*v90 == -2) {
                  uint64_t v88 = v90;
                }
                ++v90;
                v89 -= 8;
                if (!v89)
                {
                  if (!v88) {
                    goto LABEL_175;
                  }
                  *uint64_t v88 = v85;
                  --v367;
                  goto LABEL_199;
                }
              }
              goto LABEL_207;
            }
LABEL_175:
            unsigned int v91 = v366;
            if (HIDWORD(v366) < v366)
            {
              ++HIDWORD(v366);
              *(void *)&v365[8 * v87] = v85;
              goto LABEL_199;
            }
          }
          else
          {
            unsigned int v91 = v366;
          }
          if (3 * v91 <= 4 * (HIDWORD(v366) - v367))
          {
            if (v91 >= 0x40) {
              v91 *= 2;
            }
            else {
              unsigned int v91 = 128;
            }
          }
          else if (v91 - HIDWORD(v366) >= v91 >> 3)
          {
LABEL_180:
            unsigned int v92 = v91 - 1;
            unsigned int v93 = (v91 - 1) & ((v85 >> 4) ^ (v85 >> 9));
            uint64_t v94 = &v86[8 * v93];
            uint64_t v95 = *(void *)v94;
            if (*(void *)v94 != -1)
            {
              long long v96 = 0;
              int v97 = 1;
              while (v95 != v85)
              {
                if (v96) {
                  BOOL v98 = 0;
                }
                else {
                  BOOL v98 = v95 == -2;
                }
                if (v98) {
                  long long v96 = v94;
                }
                unsigned int v99 = v93 + v97++;
                unsigned int v93 = v99 & v92;
                uint64_t v94 = &v86[8 * (v99 & v92)];
                uint64_t v95 = *(void *)v94;
                if (*(void *)v94 == -1) {
                  goto LABEL_192;
                }
              }
              goto LABEL_207;
            }
            long long v96 = 0;
LABEL_192:
            if (v96) {
              unsigned int v100 = v96;
            }
            else {
              unsigned int v100 = v94;
            }
            if (*v100 == v85)
            {
LABEL_207:
              v64 += 4;
              if (v64 == v84) {
                goto LABEL_163;
              }
              continue;
            }
            if (*v100 == -2) {
              --v367;
            }
            else {
              ++HIDWORD(v366);
            }
            *unsigned int v100 = v85;
LABEL_199:
            if (*(unsigned __int8 *)(v85 + 16) <= 0x1Bu) {
              unint64_t v101 = 0;
            }
            else {
              unint64_t v101 = v85;
            }
            BOOL v432 = (void *)v101;
            if (v101)
            {
              int v102 = *(unsigned __int8 *)(v101 + 16);
              if (v102 != 83 && (v102 - 81) >= 2)
              {
                unint64_t v389 = v101;
                unsigned int v407 = 0;
                if ((sub_1CD50F704(v16, &v389, &v407) & 1) == 0 && *(llvm::BasicBlock **)(v101 + 40) == v61) {
                  sub_1CD8E4CD8(v369, &v432, &v363);
                }
              }
            }
            goto LABEL_207;
          }
          break;
        }
        llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v364, v91);
        unsigned int v91 = v366;
        uint64_t v86 = v365;
        goto LABEL_180;
      }
      uint64_t v61 = v357;
      if (!v362)
      {
        int v16 = v358;
        goto LABEL_124;
      }
      int v16 = v358;
      if (!v361) {
        goto LABEL_124;
      }
      if (*(unsigned __int8 *)(v362 + 16) <= 0x1Bu) {
        uint64_t v65 = 0;
      }
      else {
        uint64_t v65 = (llvm::PHINode *)v362;
      }
      if (v65 == v360)
      {
        uint64_t v18 = v361;
        if (*(unsigned __int8 *)(v361 + 16) > 0x1Bu) {
          goto LABEL_124;
        }
      }
      else
      {
        uint64_t v18 = v362;
        if (v65) {
          goto LABEL_124;
        }
      }
LABEL_163:
      BOOL v360 = 0;
LABEL_164:
      uint64_t v15 = *((void *)&v371 + 1);
      if (!*((void *)&v371 + 1))
      {
        if (v387)
        {
          uint64_t v338 = 24 * v387;
          uint64_t v339 = v386 + 16;
          do
          {
            uint64_t v340 = *(llvm::Instruction **)v339;
            if (*(void *)v339) {
              BOOL v341 = *(unsigned __int8 *)(*(void *)v339 + 16) >= 0x1Cu;
            }
            else {
              BOOL v341 = 0;
            }
            if (v341)
            {
              unint64_t v389 = *(void *)v339;
              unsigned int v407 = 0;
              if ((sub_1CD50F704(v16, &v389, &v407) & 1) == 0) {
                v11 |= llvm::SLPVectorizerPass::tryToVectorize(this, v340, a5);
              }
            }
            v339 += 24;
            v338 -= 24;
          }
          while (v338);
        }
        break;
      }
    }
  }
  sub_1CC92A490(&v386);
  if (v365 != v364) {
    free(v365);
  }
  sub_1CD890060(v369);
  uint64_t v335 = (void **)v369[1];
  uint64_t v336 = (void **)v370;
  if (v369[1] != (void *)v370)
  {
    do
    {
      uint64_t v337 = *v335++;
      operator delete(v337);
    }
    while (v335 != v336);
    if ((void *)v370 != v369[1]) {
      *(void *)&long long v370 = v370 + (((unint64_t)v369[1] - v370 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (v369[0]) {
    operator delete(v369[0]);
  }
  return v11 & 1;
}

BOOL sub_1CD340810(unsigned char *a1, uint64_t a2, uint64_t a3)
{
  if (a1 && a1[16] == 90)
  {
    unsigned int v6 = *(_DWORD *)(*(void *)a1 + 32);
    goto LABEL_31;
  }
  unsigned int v6 = 1;
  unsigned int v7 = a1;
  while (1)
  {
    uint64_t v8 = *(void *)v7;
    int v9 = *(_DWORD *)(*(void *)v7 + 8);
    if (!v8 || v9 != 16) {
      break;
    }
    unsigned int v7 = *(unsigned char **)(v8 + 16);
    uint64_t v12 = *(unsigned int *)(v8 + 12);
    if (v12)
    {
      uint64_t v13 = 0;
      while (*(void *)&v7[v13] == *(void *)v7)
      {
        v13 += 8;
        if (8 * v12 == v13) {
          goto LABEL_18;
        }
      }
      return 0;
    }
LABEL_18:
    v6 *= v12;
  }
  if (v8) {
    BOOL v11 = v9 == 17;
  }
  else {
    BOOL v11 = 0;
  }
  if (v11)
  {
    LODWORD(v12) = *(_DWORD *)(v8 + 32);
    unsigned int v7 = (unsigned char *)(v8 + 24);
    goto LABEL_18;
  }
  if (v8) {
    BOOL v14 = v9 == 18;
  }
  else {
    BOOL v14 = 0;
  }
  if (!v14)
  {
    if ((v9 & 0xFE) == 0x12) {
      goto LABEL_31;
    }
    BOOL v15 = v9 > 0x15u;
    int v16 = (1 << v9) & 0x20AC7F;
    if (!v15 && v16 != 0) {
      goto LABEL_31;
    }
    return 0;
  }
  v6 *= *(_DWORD *)(v8 + 32);
LABEL_31:
  unint64_t v19 = v6;
  sub_1CD42769C(a2, v6);
  sub_1CD42769C(a3, v19);
  sub_1CD3433C8((uint64_t)a1, (void *)a2, (void *)a3, 0);
  uint64_t v20 = *(char **)a2;
  uint64_t v21 = *(unsigned int *)(a2 + 8);
  unsigned int v22 = *(char **)a2;
  if (v21)
  {
    uint64_t v23 = 8 * v21;
    unsigned int v22 = *(char **)a2;
    while (*(void *)v22)
    {
      v22 += 8;
      v23 -= 8;
      if (!v23)
      {
        unsigned int v22 = (char *)(*(void *)a2 + 8 * v21);
        break;
      }
    }
  }
  uint64_t v24 = (v22 - v20) >> 3;
  int v25 = v22 + 8;
  if (v24 != v21 && v25 != (void *)(*(void *)a2 + 8 * v21))
  {
    uint64_t v27 = 8 * v21 - 8 * v24 - 8;
    do
    {
      if (*v25)
      {
        *(void *)unsigned int v22 = *v25;
        v22 += 8;
      }
      ++v25;
      v27 -= 8;
    }
    while (v27);
    uint64_t v20 = *(char **)a2;
  }
  *(_DWORD *)(a2 + 8) = (unint64_t)(v22 - v20) >> 3;
  int v28 = *(char **)a3;
  uint64_t v29 = *(unsigned int *)(a3 + 8);
  BOOL v30 = *(char **)a3;
  if (v29)
  {
    uint64_t v31 = 8 * v29;
    BOOL v30 = *(char **)a3;
    while (*(void *)v30)
    {
      v30 += 8;
      v31 -= 8;
      if (!v31)
      {
        BOOL v30 = (char *)(*(void *)a3 + 8 * v29);
        break;
      }
    }
  }
  uint64_t v32 = (v30 - v28) >> 3;
  uint64_t v33 = v30 + 8;
  if (v32 != v29 && v33 != (void *)(*(void *)a3 + 8 * v29))
  {
    uint64_t v35 = 8 * v29 - 8 * v32 - 8;
    do
    {
      if (*v33)
      {
        *(void *)BOOL v30 = *v33;
        v30 += 8;
      }
      ++v33;
      v35 -= 8;
    }
    while (v35);
    int v28 = *(char **)a3;
  }
  *(_DWORD *)(a3 + 8) = (unint64_t)(v30 - v28) >> 3;
  return *(_DWORD *)(a2 + 8) > 1u;
}

uint64_t sub_1CD340A54(uint64_t a1, unsigned int (*a2)(uint64_t, void), uint64_t a3, void *a4, uint64_t a5, uint64_t (*a6)(uint64_t, void, void), uint64_t a7, uint64_t a8, uint64_t (*a9)(uint64_t, void *), uint64_t a10)
{
  v39[6] = *MEMORY[0x1E4F143B8];
  uint64_t v13 = *(uint64_t **)a1;
  unint64_t v14 = *(unsigned int *)(a1 + 8);
  BOOL v15 = (uint64_t *)(*(void *)a1 + 8 * v14);
  int v37 = a4;
  uint64_t v38 = a5;
  if (v14 < 0x81)
  {
LABEL_5:
    sub_1CD8E7648(v13, v15, (uint64_t)&v37, v14, 0, 0);
  }
  else
  {
    int v16 = (const std::nothrow_t *)MEMORY[0x1E4FBA2D0];
    unint64_t v17 = v14;
    while (1)
    {
      uint64_t v18 = (uint64_t *)operator new(8 * v17, v16);
      if (v18) {
        break;
      }
      BOOL v19 = v17 > 1;
      v17 >>= 1;
      if (!v19) {
        goto LABEL_5;
      }
    }
    uint64_t v20 = v18;
    sub_1CD8E7648(v13, v15, (uint64_t)&v37, v14, v18, v17);
    operator delete(v20);
  }
  int v37 = v39;
  uint64_t v38 = 0x600000000;
  uint64_t v21 = *(unsigned int *)(a1 + 8);
  if (v21)
  {
    uint64_t v22 = 0;
    uint64_t v23 = *(char **)a1;
    uint64_t v24 = *(void *)a1 + 8 * v21;
    do
    {
      int v25 = v23;
      while (1)
      {
        int v26 = a6(a7, *(void *)v23, *(void *)v25);
        char v27 = v26;
        if (!v26) {
          break;
        }
        v23 += 8;
        if (v23 == (char *)v24)
        {
          uint64_t v23 = (char *)v24;
          break;
        }
      }
      unint64_t v28 = v23 - v25;
      unint64_t v29 = (unint64_t)(v23 - v25) >> 3;
      if (v29 < 2
        || (uint64_t v30 = 1,
            (((uint64_t (*)(uint64_t, char *, void, uint64_t))a9)(a10, v25, (v28 >> 3), 1) & 1) == 0))
      {
        if (a2(a3, *(void *)v25) > v29 && (!v38 || **(void **)v37 == **(void **)v25)) {
          sub_1CB935BDC((unsigned int *)&v37, v25, &v25[v28 & 0x7FFFFFFF8]);
        }
        uint64_t v30 = v22;
      }
      if (v38 >= 2 && ((v27 & 1) != 0 || **(void **)v23 != **(void **)v25))
      {
        if (a9(a10, v37))
        {
          uint64_t v30 = 1;
        }
        else if (v38)
        {
          uint64_t v31 = (char *)v37;
          uint64_t v32 = (char *)v37 + 8 * v38;
          do
          {
            uint64_t v33 = v31;
            while (a6(a7, *(void *)v31, *(void *)v33))
            {
              v31 += 8;
              if (v31 == v32)
              {
                uint64_t v31 = v32;
                break;
              }
            }
            if (((v31 - v33) & 0x7FFFFFFF0) != 0) {
              uint64_t v30 = ((unsigned int (*)(uint64_t, char *, void, void))a9)(a10, v33, ((unint64_t)(v31 - v33) >> 3), 0) | v30;
            }
          }
          while (v31 != v32);
        }
        LODWORD(v38) = 0;
      }
      uint64_t v22 = v30;
    }
    while (v23 != (char *)v24);
    if (v37 != v39) {
      free(v37);
    }
  }
  else
  {
    LOBYTE(v22) = 0;
  }
  return v22 & 1;
}

void llvm::initializeSLPVectorizerPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBD01588, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CD340D94;
    v4[1] = &v2;
    int v3 = v4;
    std::__call_once(&qword_1EBD01588, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CD340D94(llvm *a1, llvm::PassRegistry *a2)
{
  llvm::initializeAAResultsWrapperPassPass(a1, a2);
  llvm::initializeTargetTransformInfoWrapperPassPass((uint64_t)a1);
  llvm::initializeAssumptionCacheTrackerPass((uint64_t)a1);
  llvm::initializeScalarEvolutionWrapperPassPass(a1, v3);
  llvm::initializeLoopSimplifyPass(a1, v4);
  llvm::initializeDemandedBitsWrapperPassPass(a1, v5);
  llvm::initializeOptimizationRemarkEmitterWrapperPassPass(a1, v6);
  llvm::initializeInjectTLIMappingsLegacyPass(a1, v7);
  operator new();
}

uint64_t sub_1CD340E68(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBD01580;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F264BDF0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 108) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 156) = 0u;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 176) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBD01588, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CD340D94;
    v5[1] = &PassRegistry;
    unsigned int v4 = v5;
    std::__call_once(&qword_1EBD01588, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

uint64_t sub_1CD340F3C(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  for (uint64_t i = *(void *)(result + 8); i != a2; i -= 16)
  {
    uint64_t result = *(void *)(i - 8);
    *(void *)(i - 8) = 0;
    if (result)
    {
      uint64_t v5 = sub_1CD8E6BC8(result);
      uint64_t result = MEMORY[0x1D25D9CE0](v5, 0x10A0C4010E67334);
    }
  }
  *(void *)(v3 + 8) = a2;
  return result;
}

uint64_t sub_1CD340FB0(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 504) & 1) == 0) {
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 512), 8);
  }
  uint64_t v2 = *(void **)(a1 + 352);
  if (v2 != (void *)(a1 + 368)) {
    free(v2);
  }
  if ((*(unsigned char *)(a1 + 8) & 1) == 0) {
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 16), 8);
  }
  return a1;
}

void sub_1CD34101C(void ***a1)
{
  unsigned int v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    unsigned int v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        unsigned int v6 = (char *)*((void *)v4 - 8);
        if (v4 - 48 != v6) {
          free(v6);
        }
        v4 -= 72;
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1CD3410AC(uint64_t a1)
{
  int v1 = *(unsigned __int8 *)(a1 + 16);
  if (a1 && (v1 - 83) >= 0xFFFFFFFE)
  {
    __int16 v2 = *(_WORD *)(a1 + 18);
    if (v1 == 81)
    {
      return (v2 & 0x3E) == 32;
    }
    else if ((v2 & 0x3Fu) >= 0x10)
    {
      return 0;
    }
    else
    {
      return (0xC3C3u >> (v2 & 0x3F)) & 1;
    }
  }
  else if ((v1 - 41) > 0x11)
  {
    return 0;
  }
  else
  {
    return llvm::Instruction::isCommutative((llvm::Instruction *)a1);
  }
}

BOOL sub_1CD341110(_DWORD *a1)
{
  __int16 v2 = v54;
  uint64_t v50 = v54;
  unint64_t v51 = v54;
  uint64_t v52 = 4;
  int v53 = 0;
  uint64_t v3 = *(uint64_t ***)a1;
  uint64_t v4 = *(unsigned int *)(*(void *)a1 + 8);
  if (v4)
  {
    unsigned int v5 = 0;
    unsigned int v6 = *v3;
    uint64_t v7 = (uint64_t)&(*v3)[2 * v4];
    unsigned int v8 = 4;
    int v9 = v54;
    while (1)
    {
      uint64_t v10 = *v6;
      if (v9 != v2) {
        break;
      }
      if (v5)
      {
        BOOL v11 = 0;
        uint64_t v12 = 8 * v5;
        uint64_t v13 = v2;
        while (*v13 != v10)
        {
          if (*v13 == -2) {
            BOOL v11 = v13;
          }
          ++v13;
          v12 -= 8;
          if (!v12)
          {
            if (!v11) {
              goto LABEL_11;
            }
            void *v11 = v10;
            --v53;
            goto LABEL_33;
          }
        }
        goto LABEL_33;
      }
LABEL_11:
      if (v8 <= v5) {
        break;
      }
      HIDWORD(v52) = v5 + 1;
      *(void *)&v2[8 * v5] = v10;
LABEL_33:
      __int16 v2 = v50;
      int v9 = v51;
      unsigned int v8 = v52;
      unsigned int v5 = HIDWORD(v52);
      v6 += 2;
      if (v6 == (uint64_t *)v7)
      {
        uint64_t v3 = *(uint64_t ***)a1;
        goto LABEL_42;
      }
    }
    if (3 * v8 <= 4 * (v5 - v53))
    {
      if (v8 >= 0x40) {
        v8 *= 2;
      }
      else {
        unsigned int v8 = 128;
      }
    }
    else if (v8 - v5 >= v8 >> 3)
    {
      goto LABEL_15;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v50, v8);
    unsigned int v8 = v52;
    int v9 = v51;
LABEL_15:
    unsigned int v14 = v8 - 1;
    unsigned int v15 = (v8 - 1) & ((v10 >> 4) ^ (v10 >> 9));
    int v16 = &v9[8 * v15];
    uint64_t v17 = *v16;
    if (*v16 == -1)
    {
      uint64_t v18 = 0;
LABEL_27:
      if (v18) {
        int v16 = v18;
      }
      if (*v16 != v10)
      {
        if (*v16 == -2) {
          --v53;
        }
        else {
          ++HIDWORD(v52);
        }
        void *v16 = v10;
      }
    }
    else
    {
      uint64_t v18 = 0;
      int v19 = 1;
      while (v17 != v10)
      {
        if (v18) {
          BOOL v20 = 0;
        }
        else {
          BOOL v20 = v17 == -2;
        }
        if (v20) {
          uint64_t v18 = v16;
        }
        unsigned int v21 = v15 + v19++;
        unsigned int v15 = v21 & v14;
        int v16 = &v9[8 * (v21 & v14)];
        uint64_t v17 = *v16;
        if (*v16 == -1) {
          goto LABEL_27;
        }
      }
    }
    goto LABEL_33;
  }
  unsigned int v5 = 0;
  unsigned int v8 = 4;
  int v9 = v54;
LABEL_42:
  unsigned int v22 = a1[2];
  if (v22 == 1)
  {
LABEL_43:
    int v23 = v5 - v53;
    int v24 = v23 | 2;
    BOOL v25 = (v23 & (v23 - 1)) == 0;
    BOOL v26 = v24 != 2 && v25;
  }
  else
  {
    char v27 = &v3[6 * v22];
    unint64_t v28 = v3 + 6;
    unsigned int v29 = v8 - 1;
    if (v9 == v2) {
      unsigned int v30 = v5;
    }
    else {
      unsigned int v30 = v8;
    }
    uint64_t v31 = &v9[8 * v30];
    uint64_t v32 = v2;
    while (1)
    {
      uint64_t v33 = v3;
      uint64_t v3 = v28;
      uint64_t v34 = *((unsigned int *)v33 + 14);
      if (v34) {
        break;
      }
LABEL_83:
      unint64_t v28 = v3 + 6;
      if (v3 + 6 == v27) {
        goto LABEL_43;
      }
    }
    uint64_t v35 = v33[6];
    BOOL v36 = &v35[2 * v34];
    while (1)
    {
      uint64_t v37 = *v35;
      if (v9 == (unsigned char *)v32)
      {
        uint64_t v38 = &v32[v5];
        if (v5)
        {
          uint64_t v39 = 8 * v5;
          while (*v32 != v37)
          {
            ++v32;
            v39 -= 8;
            if (!v39) {
              goto LABEL_78;
            }
          }
          uint64_t v38 = v32;
        }
      }
      else
      {
        unsigned int v40 = v29 & ((v37 >> 4) ^ (v37 >> 9));
        uint64_t v41 = &v9[8 * v40];
        uint64_t v42 = *v41;
        if (*v41 == -1)
        {
          uint64_t v43 = 0;
LABEL_72:
          if (v43) {
            uint64_t v41 = v43;
          }
          uint64_t v47 = *v41;
        }
        else
        {
          uint64_t v43 = 0;
          int v44 = 1;
          while (v42 != v37)
          {
            if (v43) {
              BOOL v45 = 0;
            }
            else {
              BOOL v45 = v42 == -2;
            }
            if (v45) {
              uint64_t v43 = v41;
            }
            unsigned int v46 = v40 + v44++;
            unsigned int v40 = v46 & v29;
            uint64_t v41 = &v9[8 * (v46 & v29)];
            uint64_t v42 = *v41;
            if (*v41 == -1) {
              goto LABEL_72;
            }
          }
          uint64_t v47 = *v35;
        }
        uint64_t v38 = v47 == v37 ? v41 : v31;
      }
LABEL_78:
      unsigned int v48 = v9 == v2 ? v5 : v8;
      if (v38 == (void *)&v9[8 * v48]) {
        break;
      }
      v35 += 2;
      uint64_t v32 = v2;
      if (v35 == v36) {
        goto LABEL_83;
      }
    }
    BOOL v26 = 0;
  }
  if (v9 != v2) {
    free(v9);
  }
  return v26;
}

char *sub_1CD341470(char **a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  __int16 v2 = a1[1];
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((v2 - *a1) >> 2);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x1555555555555555) {
    abort();
  }
  if (0x5555555555555556 * ((a1[2] - v3) >> 2) > v5) {
    unint64_t v5 = 0x5555555555555556 * ((a1[2] - v3) >> 2);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 2) >= 0xAAAAAAAAAAAAAAALL) {
    unint64_t v8 = 0x1555555555555555;
  }
  else {
    unint64_t v8 = v5;
  }
  if (v8)
  {
    if (v8 > 0x1555555555555555) {
      sub_1CB833614();
    }
    int v9 = (char *)operator new(12 * v8);
  }
  else
  {
    int v9 = 0;
  }
  uint64_t v10 = &v9[12 * v4];
  *(void *)uint64_t v10 = *(void *)a2;
  *((_DWORD *)v10 + 2) = *(_DWORD *)(a2 + 8);
  BOOL v11 = v10 + 12;
  if (v2 != v3)
  {
    do
    {
      uint64_t v12 = *(void *)(v2 - 12);
      v2 -= 12;
      int v13 = *((_DWORD *)v2 + 2);
      *(void *)(v10 - 12) = v12;
      v10 -= 12;
      *((_DWORD *)v10 + 2) = v13;
    }
    while (v2 != v3);
    __int16 v2 = *a1;
  }
  *a1 = v10;
  a1[1] = v11;
  a1[2] = &v9[12 * v8];
  if (v2) {
    operator delete(v2);
  }
  return v11;
}

uint64_t sub_1CD341580(void **a1, uint64_t a2)
{
  v26[8] = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a2 + 16) != 89) {
    return 0;
  }
  int v2 = *(_DWORD *)(a2 + 20);
  uint64_t v3 = (v2 & 0x40000000) != 0 ? *(uint64_t **)(a2 - 8) : (uint64_t *)(a2 - 32 * (v2 & 0x7FFFFFF));
  uint64_t v4 = *v3;
  if (!v4) {
    return 0;
  }
  **a1 = v4;
  int v5 = *(_DWORD *)(a2 + 20);
  if ((v5 & 0x40000000) != 0) {
    uint64_t v6 = *(void *)(a2 - 8);
  }
  else {
    uint64_t v6 = a2 - 32 * (v5 & 0x7FFFFFF);
  }
  uint64_t v7 = *(void *)(v6 + 32);
  int v8 = *(unsigned __int8 *)(v7 + 16);
  if (v7) {
    BOOL v9 = v8 == 16;
  }
  else {
    BOOL v9 = 0;
  }
  if (v9)
  {
    *a1[1] = v7;
    return 1;
  }
  unsigned int v10 = (v8 - 11);
  if (v10 < 2) {
    return 1;
  }
  if (v10 < 0xFD) {
    return 0;
  }
  int v19 = v23;
  BOOL v20 = v23;
  uint64_t v21 = 8;
  int v22 = 0;
  int v24 = v26;
  uint64_t v25 = 0x800000000;
  v18[0] = (llvm::SmallPtrSetImplBase *)&v19;
  v18[1] = (llvm::SmallPtrSetImplBase *)&v24;
  int v12 = sub_1CC04C108(v18, v7);
  uint64_t result = 0;
  if (v12)
  {
    while (1)
    {
      BOOL v17 = v25 == 0;
      if (!v25) {
        break;
      }
      uint64_t v15 = v24[v25 - 1];
      LODWORD(v25) = v25 - 1;
      char v16 = sub_1CC04C108(v18, v15);
      uint64_t result = v17;
      if ((v16 & 1) == 0) {
        goto LABEL_20;
      }
    }
    uint64_t result = 1;
  }
LABEL_20:
  if (v24 != v26)
  {
    uint64_t v14 = result;
    free(v24);
    uint64_t result = v14;
  }
  if (v20 != v19)
  {
    uint64_t v13 = result;
    free(v20);
    return v13;
  }
  return result;
}

uint64_t sub_1CD34172C(llvm *this, const llvm::Instruction *a2)
{
  uint64_t result = 1;
  if (this && *((unsigned __int8 *)this + 16) >= 0x1Cu)
  {
    if (llvm::mayHaveNonDefUseDependency(this, a2)) {
      return 0;
    }
    int v4 = *((_DWORD *)this + 5);
    if ((v4 & 0x40000000) != 0)
    {
      uint64_t v6 = (char *)*((void *)this - 1);
      uint64_t v5 = v4 & 0x7FFFFFF;
      if (!v5) {
        return 1;
      }
    }
    else
    {
      uint64_t v5 = v4 & 0x7FFFFFF;
      uint64_t v6 = (char *)this - 32 * v5;
      if (!v5) {
        return 1;
      }
    }
    uint64_t v7 = 32 * v5;
    while (1)
    {
      uint64_t v8 = *(void *)v6;
      unsigned int v9 = *(unsigned __int8 *)(*(void *)v6 + 16);
      BOOL v10 = v9 == 83 || v8 == 0;
      BOOL v11 = !v10 && v9 >= 0x1C;
      if (v11 && *(void *)(v8 + 40) == *((void *)this + 5)) {
        break;
      }
      v6 += 32;
      v7 -= 32;
      if (!v7) {
        return 1;
      }
    }
    return 0;
  }
  return result;
}

void sub_1CD3417D4(void ***a1)
{
  int v1 = *a1;
  int v2 = (char *)**a1;
  if (v2)
  {
    int v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = v4 - 16;
      do
      {
        uint64_t v7 = (char *)*((void *)v6 - 2);
        if (v6 != v7) {
          free(v7);
        }
        uint64_t v8 = v6 - 24;
        v6 -= 40;
      }
      while (v8 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1CD341868(uint64_t a1, uint64_t *a2, void *a3)
{
  int v4 = a2;
  *((unsigned char *)a2 + 160) = 1;
  do
  {
    uint64_t v6 = *v4;
    if (*v4 != v4[1]) {
      goto LABEL_51;
    }
    uint64_t v7 = v4[2];
    if (v7)
    {
      uint64_t v8 = *(void **)v7;
      uint64_t v9 = *(unsigned int *)(v7 + 8);
      if (v9)
      {
        uint64_t v10 = 8 * v9;
        BOOL v11 = *(void **)v7;
        int v12 = &v8[v9];
        while (*v11 != v6)
        {
          ++v11;
          v10 -= 8;
          if (!v10)
          {
            BOOL v11 = v12;
            break;
          }
        }
      }
      else
      {
        BOOL v11 = *(void **)v7;
      }
      uint64_t v16 = *(unsigned int *)(v7 + 216);
      if (v16)
      {
        uint64_t v17 = 0;
        uint64_t v18 = (int)(v11 - v8);
        uint64_t v19 = 80 * v16;
        do
        {
          uint64_t v20 = *(void *)(*(void *)(*(void *)(v7 + 208) + v17) + 8 * v18);
          if (v20) {
            BOOL v21 = *(unsigned __int8 *)(v20 + 16) >= 0x1Cu;
          }
          else {
            BOOL v21 = 0;
          }
          if (v21)
          {
            uint64_t v41 = a3;
            sub_1CD339D6C(a1, v20, (void (*)(uint64_t, uint64_t))sub_1CD8E4678, (uint64_t)&v41);
          }
          v17 += 80;
        }
        while (v19 != v17);
      }
      goto LABEL_32;
    }
    int v13 = *(_DWORD *)(v6 + 20);
    if ((v13 & 0x40000000) != 0)
    {
      uint64_t v15 = *(uint64_t **)(v6 - 8);
      uint64_t v14 = v13 & 0x7FFFFFF;
      if (v14)
      {
LABEL_24:
        uint64_t v22 = 32 * v14;
        do
        {
          uint64_t v23 = *v15;
          if (*v15) {
            BOOL v24 = *(unsigned __int8 *)(*v15 + 16) >= 0x1Cu;
          }
          else {
            BOOL v24 = 0;
          }
          if (v24)
          {
            uint64_t v41 = a3;
            sub_1CD339D6C(a1, v23, (void (*)(uint64_t, uint64_t))sub_1CD8E4678, (uint64_t)&v41);
          }
          v15 += 4;
          v22 -= 32;
        }
        while (v22);
      }
    }
    else
    {
      uint64_t v14 = v13 & 0x7FFFFFF;
      uint64_t v15 = (uint64_t *)(v6 - 32 * v14);
      if (v14) {
        goto LABEL_24;
      }
    }
LABEL_32:
    uint64_t v25 = *((unsigned int *)v4 + 14);
    if (v25)
    {
      BOOL v26 = (uint64_t *)v4[6];
      char v27 = &v26[v25];
      do
      {
        uint64_t v28 = *v26;
        if (*(_DWORD *)(*v26 + 152) != -1)
        {
          --*(_DWORD *)(v28 + 156);
          uint64_t v29 = *(void *)(v28 + 24);
          if (v29)
          {
            int v30 = 0;
            uint64_t v31 = v29;
            while (1)
            {
              int v32 = *(_DWORD *)(v31 + 156);
              if (v32 == -1) {
                break;
              }
              v30 += v32;
              uint64_t v31 = *(void *)(v31 + 32);
              if (!v31)
              {
                if (v30) {
                  break;
                }
                goto LABEL_40;
              }
            }
          }
          else
          {
LABEL_40:
            uint64_t v41 = (void *)v29;
            sub_1CC37AF14(a3, (uint64_t *)&v41);
          }
        }
        ++v26;
      }
      while (v26 != v27);
    }
    uint64_t v33 = *((unsigned int *)v4 + 26);
    if (v33)
    {
      uint64_t v34 = (uint64_t *)v4[12];
      uint64_t v35 = &v34[v33];
      do
      {
        uint64_t v36 = *v34;
        *(_DWORD *)(v36 + 156) = *(_DWORD *)(*v34 + 156) - 1;
        uint64_t v37 = *(void *)(v36 + 24);
        if (v37)
        {
          int v38 = 0;
          uint64_t v39 = v37;
          while (1)
          {
            int v40 = *(_DWORD *)(v39 + 156);
            if (v40 == -1) {
              break;
            }
            v38 += v40;
            uint64_t v39 = *(void *)(v39 + 32);
            if (!v39)
            {
              if (v38) {
                break;
              }
              goto LABEL_49;
            }
          }
        }
        else
        {
LABEL_49:
          uint64_t v41 = (void *)v37;
          sub_1CC37AF14(a3, (uint64_t *)&v41);
        }
        ++v34;
      }
      while (v34 != v35);
    }
LABEL_51:
    int v4 = (uint64_t *)v4[4];
  }
  while (v4);
}

double sub_1CD341AB4(uint64_t a1, uint64_t a2)
{
  double result = NAN;
  *(void *)(a2 + 152) = -1;
  *(_DWORD *)(a2 + 56) = 0;
  *(_DWORD *)(a2 + 104) = 0;
  return result;
}

uint64_t sub_1CD341AC8(uint64_t a1)
{
  unsigned int v2 = *(unsigned __int8 *)(a1 + 16);
  if (v2 <= 0x2C)
  {
    if (v2 != 5)
    {
      if (v2 != 41) {
        goto LABEL_13;
      }
      return 1;
    }
    int v3 = *(unsigned __int16 *)(a1 + 18);
    if (v3 == 13) {
      return 1;
    }
    if (v3 == 17) {
      return 2;
    }
    if (v3 != 28) {
      goto LABEL_13;
    }
    return 4;
  }
  if (v2 == 45) {
    return 2;
  }
  if (v2 == 56) {
    return 4;
  }
LABEL_13:
  if (sub_1CCA16428((uint64_t)&v26, (unsigned __int8 *)a1)) {
    return 4;
  }
  int v5 = *(unsigned __int8 *)(a1 + 16);
  if (v5 == 57 || v5 == 5 && *(_WORD *)(a1 + 18) == 29 || sub_1CCA16538((uint64_t)&v26, (unsigned __int8 *)a1)) {
    return 3;
  }
  unsigned int v6 = *(unsigned __int8 *)(a1 + 16);
  if (v6 > 0x2D)
  {
    if (v6 != 46)
    {
      if (v6 != 58) {
        goto LABEL_27;
      }
      return 5;
    }
    return 11;
  }
  if (v6 != 5)
  {
    if (v6 != 42)
    {
LABEL_27:
      LODWORD(v26) = 193;
      *(void *)((char *)&v26 + 4) = 0;
      if (v6 == 84)
      {
        uint64_t v7 = *(void *)(a1 - 32);
        if (v7)
        {
          if (!*(unsigned char *)(v7 + 16) && *(void *)(v7 + 24) == *(void *)(a1 + 72))
          {
            if (*(_DWORD *)(v7 + 36) == v26) {
              return 13;
            }
            if (*(_DWORD *)(v7 + 36) == 202) {
              return 12;
            }
          }
        }
      }
      goto LABEL_41;
    }
    return 10;
  }
  int v8 = *(unsigned __int16 *)(a1 + 18);
  switch(v8)
  {
    case 14:
      return 10;
    case 18:
      return 11;
    case 30:
      return 5;
  }
LABEL_41:
  if (sub_1CC003024((uint64_t)&v26, a1)) {
    return 7;
  }
  if (sub_1CC0030E0((uint64_t)&v26, a1)) {
    return 6;
  }
  if (sub_1CC002F68((uint64_t)&v26, a1)) {
    return 9;
  }
  if (sub_1CC002EAC((uint64_t)&v26, a1)) {
    return 8;
  }
  if (*(unsigned char *)(a1 + 16) != 85) {
    return 0;
  }
  int v30 = 0;
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  uint64_t v9 = *(unsigned __int8 **)(a1 - 64);
  uint64_t v10 = *(const llvm::Instruction **)(a1 - 32);
  uint64_t v11 = *(void *)(a1 - 96);
  if (!v11) {
    goto LABEL_63;
  }
  unsigned int v12 = *(unsigned __int8 *)(v11 + 16);
  if (v12 < 0x1C || v12 - 83 < 0xFFFFFFFE) {
    goto LABEL_63;
  }
  int v13 = *(unsigned __int8 **)(v11 - 64);
  if (v9 == v13)
  {
    uint64_t v18 = *(void *)(v11 - 32);
    if (v18)
    {
      if (*(unsigned __int8 *)(v18 + 16) >= 0x1Cu)
      {
        BOOL v24 = *(unsigned __int8 **)(v11 - 32);
        uint64_t v28 = (llvm::Instruction *)v24;
        uint64_t v19 = v10;
        if (*((unsigned char *)v10 + 16) != 89) {
          return 0;
        }
        __int16 v20 = *(_WORD *)(v11 + 18);
        uint64_t result = llvm::Instruction::isIdenticalToWhenDefined((llvm::Instruction *)v24, v10);
        if (result)
        {
          unsigned int v21 = *((unsigned __int8 *)v19 + 17) ^ v24[17];
          goto LABEL_73;
        }
        return result;
      }
    }
  }
  if (!v13
    || v13[16] < 0x1Cu
    || (uint64_t v29 = *(llvm::Instruction **)(v11 - 64), v10 != *(const llvm::Instruction **)(v11 - 32)))
  {
LABEL_63:
    if (v9[16] == 89)
    {
      uint64_t v23 = (unsigned __int8 *)v10;
      if (*((unsigned char *)v10 + 16) == 89)
      {
        uint64_t v14 = v9;
        *(void *)&long long v26 = &v30;
        *((void *)&v26 + 1) = &v29;
        char v27 = &v28;
        if (sub_1CCA80EE0((uint64_t)&v26, v11))
        {
          uint64_t v15 = v29;
          if (llvm::Instruction::isIdenticalToWhenDefined(v29, (const llvm::Instruction *)v14))
          {
            if ((v14[17] ^ *((unsigned __int8 *)v15 + 17)) <= 1)
            {
              uint64_t v16 = v28;
              if ((llvm::Instruction::isIdenticalToWhenDefined(v28, (const llvm::Instruction *)v23) & 1) != 0
                && (v23[17] ^ *((unsigned __int8 *)v16 + 17)) <= 1)
              {
                int v17 = v30;
                goto LABEL_75;
              }
            }
          }
        }
      }
    }
    return 0;
  }
  uint64_t v25 = (llvm::Instruction *)v9;
  if (v9[16] != 89) {
    return 0;
  }
  __int16 v20 = *(_WORD *)(v11 + 18);
  uint64_t result = llvm::Instruction::isIdenticalToWhenDefined((llvm::Instruction *)v13, (const llvm::Instruction *)v9);
  if (result)
  {
    unsigned int v21 = *((unsigned __int8 *)v25 + 17) ^ v13[17];
LABEL_73:
    if (v21 < 2)
    {
      int v17 = v20 & 0x3F;
LABEL_75:
      unsigned int v22 = v17 - 34;
      if (v22 <= 7) {
        return dword_1CFB33A48[v22];
      }
      return 0;
    }
    return 0;
  }
  return result;
}

uint64_t sub_1CD341E7C(uint64_t result, unsigned __int8 *a2)
{
  if (result)
  {
    int v2 = result;
    if ((result - 6) < 4 || sub_1CCA16428((uint64_t)v6, a2) || sub_1CCA16538((uint64_t)v5, a2))
    {
      return 1;
    }
    else if ((v2 & 0xFFFFFFFE) == 0xC)
    {
      return (a2[17] >> 2) & 1;
    }
    else
    {
      uint64_t result = 1;
      switch(a2[16])
      {
        case ')':
        case '-':
          return result;
        case '*':
        case '.':
          unsigned int v4 = a2[17];
          if ((v4 & 2) != 0) {
            uint64_t result = (v4 >> 4) & 1;
          }
          else {
            uint64_t result = 0;
          }
          break;
        case '+':
        case ',':
          goto LABEL_14;
        default:
          if (a2[16] - 56 >= 3) {
LABEL_14:
          }
            uint64_t result = 0;
          break;
      }
    }
  }
  return result;
}

void *sub_1CD341F64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a1 + 576;
  uint64_t v7 = *(void *)(a1 + 576);
  uint64_t v8 = *(unsigned int *)(a1 + 592);
  if (v8)
  {
    LODWORD(v9) = ((*(void *)a2 >> 4) ^ (*(void *)a2 >> 9)) & (v8 - 1);
    uint64_t v10 = (uint64_t *)(v7 + 16 * v9);
    uint64_t v11 = *v10;
    if (*(void *)a2 == *v10) {
      goto LABEL_8;
    }
    int v12 = 1;
    while (v11 != -4096)
    {
      int v13 = v9 + v12++;
      uint64_t v9 = v13 & (v8 - 1);
      uint64_t v11 = *(void *)(v7 + 16 * v9);
      if (*(void *)a2 == v11)
      {
        uint64_t v10 = (uint64_t *)(v7 + 16 * v9);
        goto LABEL_8;
      }
    }
  }
  uint64_t v10 = (uint64_t *)(v7 + 16 * v8);
LABEL_8:
  uint64_t v14 = (uint64_t *)(v7 + 16 * v8);
  uint64_t result = (void *)sub_1CD48CC08(v6, (uint64_t *)a2);
  if (v10 != v14)
  {
    a3 = 0;
    *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 652);
  }
  *uint64_t result = a3;
  return result;
}

BOOL sub_1CD342028(uint64_t a1)
{
  BOOL result = sub_1CD8E5100(a1);
  if (result)
  {
    int v3 = sub_1CD341AC8(a1);
    return (v3 - 6) < 4 || (v3 & 0xE) == 12;
  }
  return result;
}

uint64_t sub_1CD34206C(uint64_t a1, int a2, llvm::Value *a3, llvm::Value *a4, const llvm::Twine *a5, uint64_t ***a6)
{
  int v8 = *((_DWORD *)a6 + 2);
  if (v8 == 2) {
    int v9 = 1;
  }
  else {
    int v9 = v8 == 1 && *(unsigned __int8 *)(***a6 + 16) == 85;
  }
  uint64_t v10 = sub_1CD342FB8(a1, a2, a3, a4, a5, v9);
  uint64_t v11 = (uint64_t)v10;
  if ((a2 - 6) > 3 || (*((unsigned char *)v10 + 16) == 85 ? (BOOL v12 = v10 == 0) : (BOOL v12 = 1), v12))
  {
    int v13 = **a6;
    uint64_t v14 = *((unsigned int *)*a6 + 2);
  }
  else
  {
    llvm::propagateIRFlags(*((void *)v10 - 12), **a6, *((unsigned int *)*a6 + 2), 0);
    int v13 = (*a6)[18];
    uint64_t v14 = *((unsigned int *)*a6 + 38);
  }
  llvm::propagateIRFlags(v11, v13, v14, 0);
  return v11;
}

char *sub_1CD342140(char *result, char *a2, _DWORD **a3, unint64_t a4, uint64_t *a5, uint64_t a6)
{
  if (a4 < 2) {
    return result;
  }
  int v8 = result;
  if (a4 == 2)
  {
    uint64_t v9 = *((void *)a2 - 1);
    unsigned int v10 = *(unsigned __int8 *)(v9 + 16);
    if (v9) {
      BOOL v11 = v10 >= 0x1C;
    }
    else {
      BOOL v11 = 0;
    }
    if (v11 && v10 - 83 >= 0xFFFFFFFE)
    {
      uint64_t v13 = *(void *)result;
      if (*(void *)result)
      {
        unsigned int v14 = *(unsigned __int8 *)(v13 + 16);
        if (v14 >= 0x1C && v14 - 83 >= 0xFFFFFFFE)
        {
          int v16 = *(_WORD *)(v13 + 18) & 0x3F;
          int v17 = *a3;
          int v76 = *(_WORD *)(v9 + 18) & 0x3F;
          unsigned int v18 = sub_1CD8E5148(v17, &v76)[1];
          uint64_t v19 = *a3;
          int v75 = v16;
          BOOL result = (char *)sub_1CD8E5148(v19, &v75);
          if (v18 > *((_DWORD *)result + 1))
          {
            uint64_t v20 = *(void *)v8;
            *(void *)int v8 = *((void *)a2 - 1);
            *((void *)a2 - 1) = v20;
          }
        }
      }
    }
    return result;
  }
  if ((uint64_t)a4 > 128)
  {
    uint64_t v54 = (char *)a5;
    unint64_t v55 = a4 >> 1;
    uint64_t v56 = (uint64_t *)&result[8 * (a4 >> 1)];
    unint64_t v57 = a4 >> 1;
    if ((uint64_t)a4 > a6)
    {
      sub_1CD342140(result, v56, a3, v57, a5, a6);
      sub_1CD342140(&v8[8 * (a4 >> 1)], a2, a3, a4 - (a4 >> 1), v54, a6);
      return sub_1CD34292C(v8, &v8[8 * (a4 >> 1)], a2, a3, a4 >> 1, a4 - (a4 >> 1), v54, a6);
    }
    sub_1CD342550((uint64_t *)result, v56, a3, v57, a5);
    int v58 = (uint64_t *)&v54[8 * v55];
    BOOL result = (char *)sub_1CD342550((uint64_t *)&v8[8 * (a4 >> 1)], (uint64_t *)a2, a3, a4 - (a4 >> 1), v58);
    char v59 = &v54[8 * a4];
    uint64_t v60 = v58;
    while (1)
    {
      if (v60 == (uint64_t *)v59)
      {
        if (v54 != (char *)v58)
        {
          uint64_t v73 = 0;
          do
          {
            *(void *)&v8[v73] = *(void *)&v54[v73];
            v73 += 8;
          }
          while (&v54[v73] != (char *)v58);
        }
        return result;
      }
      uint64_t v61 = *(void *)v54;
      unsigned int v62 = *(unsigned __int8 *)(*v60 + 16);
      if (*v60) {
        BOOL v63 = v62 >= 0x1C;
      }
      else {
        BOOL v63 = 0;
      }
      if (v63 && v62 - 83 >= 0xFFFFFFFE)
      {
        unsigned int v65 = *(unsigned __int8 *)(v61 + 16);
        BOOL v66 = v61 && v65 >= 0x1C;
        if (v66 && v65 - 83 >= 0xFFFFFFFE)
        {
          int v68 = *(_WORD *)(v61 + 18) & 0x3F;
          uint64_t v69 = *a3;
          int v76 = *(_WORD *)(*v60 + 18) & 0x3F;
          unsigned int v70 = sub_1CD8E5148(v69, &v76)[1];
          unint64_t v71 = *a3;
          int v75 = v68;
          BOOL result = (char *)sub_1CD8E5148(v71, &v75);
          if (v70 > *((_DWORD *)result + 1))
          {
            uint64_t v72 = *v60++;
            *(void *)int v8 = v72;
            goto LABEL_84;
          }
          uint64_t v61 = *(void *)v54;
        }
      }
      *(void *)int v8 = v61;
      v54 += 8;
LABEL_84:
      v8 += 8;
      if (v54 == (char *)v58)
      {
        if (v60 != (uint64_t *)v59)
        {
          uint64_t v74 = 0;
          do
          {
            *(void *)&v8[v74 * 8] = v60[v74];
            ++v74;
          }
          while (&v60[v74] != (uint64_t *)v59);
        }
        return result;
      }
    }
  }
  if (result != a2)
  {
    unsigned int v22 = result + 8;
    if (result + 8 != a2)
    {
      uint64_t v23 = 0;
      BOOL v24 = result;
      do
      {
        uint64_t v25 = v24;
        BOOL v24 = v22;
        uint64_t v26 = *((void *)v25 + 1);
        unsigned int v27 = *(unsigned __int8 *)(v26 + 16);
        if (v26) {
          BOOL v28 = v27 >= 0x1C;
        }
        else {
          BOOL v28 = 0;
        }
        if (v28 && v27 - 83 >= 0xFFFFFFFE)
        {
          uint64_t v30 = *(void *)v25;
          unsigned int v31 = *(unsigned __int8 *)(v30 + 16);
          BOOL v32 = v30 && v31 >= 0x1C;
          if (v32 && v31 - 83 >= 0xFFFFFFFE)
          {
            int v34 = *(_WORD *)(v30 + 18) & 0x3F;
            uint64_t v35 = *a3;
            int v76 = *(_WORD *)(v26 + 18) & 0x3F;
            unsigned int v36 = sub_1CD8E5148(v35, &v76)[1];
            uint64_t v37 = *a3;
            int v75 = v34;
            BOOL result = (char *)sub_1CD8E5148(v37, &v75);
            if (v36 > *((_DWORD *)result + 1))
            {
              uint64_t v38 = *(void *)v24;
              uint64_t v39 = v23;
              while (1)
              {
                uint64_t v40 = v39;
                uint64_t v41 = &v8[v39];
                *((void *)v41 + 1) = *(void *)v41;
                if (!v40) {
                  break;
                }
                if (v38)
                {
                  unsigned int v42 = *(unsigned __int8 *)(v38 + 16);
                  if (v42 >= 0x1C && v42 - 83 >= 0xFFFFFFFE)
                  {
                    uint64_t v44 = *((void *)v41 - 1);
                    unsigned int v45 = *(unsigned __int8 *)(v44 + 16);
                    BOOL v46 = v44 && v45 >= 0x1C;
                    if (v46 && v45 - 83 >= 0xFFFFFFFE)
                    {
                      int v48 = *(_WORD *)(v44 + 18) & 0x3F;
                      uint64_t v49 = *a3;
                      int v76 = *(_WORD *)(v38 + 18) & 0x3F;
                      unsigned int v50 = sub_1CD8E5148(v49, &v76)[1];
                      unint64_t v51 = *a3;
                      int v75 = v48;
                      BOOL result = (char *)sub_1CD8E5148(v51, &v75);
                      uint64_t v39 = v40 - 8;
                      if (v50 > *((_DWORD *)result + 1)) {
                        continue;
                      }
                    }
                  }
                }
                uint64_t v52 = &v8[v40];
                goto LABEL_60;
              }
              uint64_t v52 = v8;
LABEL_60:
              *(void *)uint64_t v52 = v38;
            }
          }
        }
        unsigned int v22 = v24 + 8;
        v23 += 8;
      }
      while (v24 + 8 != a2);
    }
  }
  return result;
}

uint64_t *sub_1CD342550(uint64_t *result, uint64_t *a2, _DWORD **a3, unint64_t a4, uint64_t *a5)
{
  if (!a4) {
    return result;
  }
  int v5 = a5;
  uint64_t v7 = result;
  if (a4 == 1)
  {
LABEL_16:
    uint64_t *v5 = *v7;
    return result;
  }
  if (a4 == 2)
  {
    BOOL v11 = a2 - 1;
    uint64_t v10 = *(a2 - 1);
    uint64_t v12 = *result;
    if (v10)
    {
      unsigned int v13 = *(unsigned __int8 *)(v10 + 16);
      BOOL v14 = v13 >= 0x1C && v13 - 83 >= 0xFFFFFFFE;
      if (v14 && v12)
      {
        unsigned int v15 = *(unsigned __int8 *)(v12 + 16);
        if (v15 >= 0x1C && v15 - 83 >= 0xFFFFFFFE)
        {
          int v62 = *(_WORD *)(v12 + 18) & 0x3F;
          BOOL v63 = *a3;
          int v71 = *(_WORD *)(v10 + 18) & 0x3F;
          unsigned int v64 = sub_1CD8E5148(v63, &v71)[1];
          unsigned int v65 = *a3;
          int v70 = v62;
          BOOL result = (uint64_t *)sub_1CD8E5148(v65, &v70);
          unsigned int v66 = *((_DWORD *)result + 1);
          BOOL v67 = v64 > v66;
          if (v64 <= v66) {
            int v68 = v7;
          }
          else {
            int v68 = v11;
          }
          if (v67) {
            BOOL v11 = v7;
          }
          uint64_t v12 = *v68;
        }
      }
    }
    *v5++ = v12;
    uint64_t v7 = v11;
    goto LABEL_16;
  }
  if ((uint64_t)a4 <= 8)
  {
    if (result == a2) {
      return result;
    }
    int v17 = result + 1;
    *a5 = *result;
    if (result + 1 == a2) {
      return result;
    }
    uint64_t v18 = 0;
    uint64_t v19 = a5;
    uint64_t v20 = a5;
    while (1)
    {
      uint64_t v22 = *v20++;
      uint64_t v21 = v22;
      uint64_t v23 = *v17;
      unsigned int v24 = *(unsigned __int8 *)(*v17 + 16);
      if (*v17) {
        BOOL v25 = v24 >= 0x1C;
      }
      else {
        BOOL v25 = 0;
      }
      if (v25 && v24 - 83 >= 0xFFFFFFFE)
      {
        unsigned int v27 = *(unsigned __int8 *)(v21 + 16);
        BOOL v28 = v21 && v27 >= 0x1C;
        if (v28 && v27 - 83 >= 0xFFFFFFFE)
        {
          int v30 = *(_WORD *)(v21 + 18) & 0x3F;
          unsigned int v31 = *a3;
          int v71 = *(_WORD *)(v23 + 18) & 0x3F;
          unsigned int v32 = sub_1CD8E5148(v31, &v71)[1];
          uint64_t v33 = *a3;
          int v70 = v30;
          BOOL result = (uint64_t *)sub_1CD8E5148(v33, &v70);
          if (v32 > *((_DWORD *)result + 1))
          {
            v19[1] = *v19;
            int v34 = v5;
            if (v19 != v5)
            {
              uint64_t v35 = v18;
              while (1)
              {
                unsigned int v36 = *(unsigned __int8 *)(*v17 + 16);
                BOOL v37 = *v17 && v36 >= 0x1C;
                if (!v37 || v36 - 83 < 0xFFFFFFFE) {
                  break;
                }
                uint64_t v39 = *(uint64_t *)((char *)v5 + v35 - 8);
                unsigned int v40 = *(unsigned __int8 *)(v39 + 16);
                if (v39) {
                  BOOL v41 = v40 >= 0x1C;
                }
                else {
                  BOOL v41 = 0;
                }
                if (!v41 || v40 - 83 < 0xFFFFFFFE)
                {
                  int v34 = (uint64_t *)((char *)v5 + v35);
                  goto LABEL_63;
                }
                int v69 = *(_WORD *)(v39 + 18) & 0x3F;
                uint64_t v43 = *a3;
                int v71 = *(_WORD *)(*v17 + 18) & 0x3F;
                unsigned int v44 = sub_1CD8E5148(v43, &v71)[1];
                unsigned int v45 = *a3;
                int v70 = v69;
                BOOL result = (uint64_t *)sub_1CD8E5148(v45, &v70);
                if (v44 <= *((_DWORD *)result + 1)) {
                  break;
                }
                --v19;
                *(uint64_t *)((char *)v5 + v35) = *(uint64_t *)((char *)v5 + v35 - 8);
                v35 -= 8;
                if (!v35)
                {
                  int v34 = v5;
                  goto LABEL_63;
                }
              }
              int v34 = v19;
            }
LABEL_63:
            *int v34 = *v17;
            goto LABEL_38;
          }
          uint64_t v23 = *v17;
        }
      }
      *uint64_t v20 = v23;
LABEL_38:
      ++v17;
      v18 += 8;
      uint64_t v19 = v20;
      if (v17 == a2) {
        return result;
      }
    }
  }
  BOOL v46 = &result[a4 >> 1];
  sub_1CD342140(result, v46, a3, a4 >> 1, a5, a4 >> 1);
  BOOL result = (uint64_t *)sub_1CD342140(&v7[a4 >> 1], a2, a3, a4 - (a4 >> 1), &v5[a4 >> 1], a4 - (a4 >> 1));
  uint64_t v47 = &v7[a4 >> 1];
  while (v47 != a2)
  {
    uint64_t v48 = *v7;
    unsigned int v49 = *(unsigned __int8 *)(*v47 + 16);
    if (*v47) {
      BOOL v50 = v49 >= 0x1C;
    }
    else {
      BOOL v50 = 0;
    }
    if (v50 && v49 - 83 >= 0xFFFFFFFE)
    {
      unsigned int v52 = *(unsigned __int8 *)(v48 + 16);
      BOOL v53 = v48 && v52 >= 0x1C;
      if (v53 && v52 - 83 >= 0xFFFFFFFE)
      {
        int v55 = *(_WORD *)(v48 + 18) & 0x3F;
        uint64_t v56 = *a3;
        int v71 = *(_WORD *)(*v47 + 18) & 0x3F;
        unsigned int v57 = sub_1CD8E5148(v56, &v71)[1];
        int v58 = *a3;
        int v70 = v55;
        BOOL result = (uint64_t *)sub_1CD8E5148(v58, &v70);
        if (v57 > *((_DWORD *)result + 1))
        {
          uint64_t v59 = *v47++;
          uint64_t *v5 = v59;
          goto LABEL_83;
        }
        uint64_t v48 = *v7;
      }
    }
    uint64_t *v5 = v48;
    ++v7;
LABEL_83:
    ++v5;
    if (v7 == v46)
    {
      if (v47 != a2)
      {
        uint64_t v61 = 0;
        do
        {
          v5[v61] = v47[v61];
          ++v61;
        }
        while (&v47[v61] != a2);
      }
      return result;
    }
  }
  if (v7 != v46)
  {
    uint64_t v60 = 0;
    do
    {
      v5[v60] = v7[v60];
      ++v60;
    }
    while (&v7[v60] != v46);
  }
  return result;
}

char *sub_1CD34292C(char *result, char *a2, char *a3, _DWORD **a4, uint64_t a5, uint64_t a6, char *a7, uint64_t a8)
{
  if (!a6) {
    return result;
  }
  uint64_t v10 = a6;
  unsigned int v15 = result;
  while (a5 > a8 && v10 > a8)
  {
    if (!a5) {
      return result;
    }
    while (1)
    {
      unsigned int v16 = *(unsigned __int8 *)(*(void *)a2 + 16);
      BOOL v17 = *(void *)a2 && v16 >= 0x1C;
      if (v17 && v16 - 83 >= 0xFFFFFFFE)
      {
        unsigned int v19 = *(unsigned __int8 *)(*(void *)v15 + 16);
        BOOL v20 = *(void *)v15 && v19 >= 0x1C;
        if (v20 && v19 - 83 >= 0xFFFFFFFE)
        {
          int v22 = *(_WORD *)(*(void *)v15 + 18) & 0x3F;
          uint64_t v23 = *a4;
          int v120 = *(_WORD *)(*(void *)a2 + 18) & 0x3F;
          unsigned int v24 = sub_1CD8E5148(v23, &v120)[1];
          BOOL v25 = *a4;
          int v119 = v22;
          BOOL result = (char *)sub_1CD8E5148(v25, &v119);
          if (v24 > *((_DWORD *)result + 1)) {
            break;
          }
        }
      }
      v15 += 8;
      if (!--a5) {
        return result;
      }
    }
    BOOL v118 = a3;
    if (a5 >= v10)
    {
      if (a5 == 1)
      {
        uint64_t v105 = *(void *)v15;
        *(void *)unsigned int v15 = *(void *)a2;
        *(void *)a2 = v105;
        return result;
      }
      if (a5 >= 0) {
        uint64_t v47 = a5;
      }
      else {
        uint64_t v47 = a5 + 1;
      }
      BOOL v28 = a3;
      unint64_t v29 = v47 >> 1;
      int v30 = &v15[8 * (v47 >> 1)];
      if (v28 == a2)
      {
        uint64_t v27 = 0;
LABEL_87:
        unsigned int v44 = v30;
        goto LABEL_90;
      }
      uint64_t __src = a7;
      uint64_t v27 = 0;
      unint64_t v110 = *a4;
      unint64_t v48 = (v28 - a2) >> 3;
      do
      {
        unint64_t v49 = v27 + (v48 >> 1);
        uint64_t v50 = *(void *)&a2[8 * v49];
        unint64_t v51 = v48 >> 1;
        unsigned int v52 = *(unsigned __int8 *)(v50 + 16);
        if (v50) {
          BOOL v53 = v52 >= 0x1C;
        }
        else {
          BOOL v53 = 0;
        }
        if (v53 && v52 - 83 >= 0xFFFFFFFE)
        {
          unsigned int v55 = *(unsigned __int8 *)(*(void *)v30 + 16);
          BOOL v56 = *(void *)v30 && v55 >= 0x1C;
          if (v56 && v55 - 83 >= 0xFFFFFFFE)
          {
            int v108 = *(_WORD *)(*(void *)v30 + 18) & 0x3F;
            int v120 = *(_WORD *)(v50 + 18) & 0x3F;
            uint64_t v112 = v27;
            uint64_t v115 = v30;
            unsigned int v106 = sub_1CD8E5148(v110, &v120)[1];
            int v119 = v108;
            int v58 = sub_1CD8E5148(v110, &v119);
            uint64_t v27 = v112;
            int v30 = v115;
            if (v106 > v58[1])
            {
              unint64_t v51 = v48 + ~v51;
              uint64_t v27 = v49 + 1;
            }
          }
        }
        unint64_t v48 = v51;
      }
      while (v51);
    }
    else
    {
      if (v10 >= 0) {
        uint64_t v26 = v10;
      }
      else {
        uint64_t v26 = v10 + 1;
      }
      uint64_t v27 = v26 >> 1;
      BOOL v28 = &a2[8 * (v26 >> 1)];
      unint64_t v29 = (a2 - v15) >> 3;
      if (a2 == v15)
      {
        v10 -= v27;
        goto LABEL_85;
      }
      uint64_t __src = a7;
      int v30 = v15;
      do
      {
        while (1)
        {
          unint64_t v31 = v29 >> 1;
          unsigned int v32 = &v30[8 * (v29 >> 1)];
          unsigned int v33 = *(unsigned __int8 *)(*(void *)v28 + 16);
          BOOL v34 = *(void *)v28 && v33 >= 0x1C;
          if (v34 && v33 - 83 >= 0xFFFFFFFE)
          {
            unsigned int v36 = *(unsigned __int8 *)(*(void *)v32 + 16);
            BOOL v37 = *(void *)v32 && v36 >= 0x1C;
            if (v37 && v36 - 83 > 0xFFFFFFFD) {
              break;
            }
          }
          int v30 = v32 + 8;
          v29 += ~v31;
          if (!v29) {
            goto LABEL_51;
          }
        }
        int v109 = *(_WORD *)(*(void *)v32 + 18) & 0x3F;
        uint64_t v39 = *a4;
        int v120 = *(_WORD *)(*(void *)v28 + 18) & 0x3F;
        uint64_t v111 = v27;
        int v113 = v30;
        unsigned int v40 = v28;
        unsigned int v107 = sub_1CD8E5148(v39, &v120)[1];
        BOOL v41 = *a4;
        int v119 = v109;
        unsigned int v42 = sub_1CD8E5148(v41, &v119);
        BOOL v28 = v40;
        uint64_t v27 = v111;
        int v30 = v113;
        if (v107 > v42[1])
        {
          v29 >>= 1;
        }
        else
        {
          int v30 = v32 + 8;
          v29 += ~v31;
        }
      }
      while (v29);
LABEL_51:
      unint64_t v29 = (v30 - v15) >> 3;
    }
    BOOL v28 = &a2[8 * v27];
    v10 -= v27;
    a7 = __src;
    if (v30 != a2)
    {
      if (v27)
      {
        if (v30 + 8 == a2)
        {
          uint64_t v116 = *(void *)v30;
          uint64_t v59 = v30;
          uint64_t v60 = v30;
          uint64_t v61 = a2;
          uint64_t v62 = v27;
          BOOL v63 = v28;
          memmove(v59, v61, 8 * v27);
          BOOL v28 = v63;
          uint64_t v27 = v62;
          int v30 = v60;
          unsigned int v44 = &v60[8 * v62];
          *(void *)unsigned int v44 = v116;
        }
        else if (v27 == 1)
        {
          uint64_t v43 = *((void *)v28 - 1);
          unsigned int v44 = v30 + 8;
          if (v28 - 8 != v30)
          {
            unsigned int v45 = v30;
            BOOL v46 = v28;
            uint64_t v114 = *((void *)v28 - 1);
            memmove(v30 + 8, v30, v28 - 8 - v30);
            uint64_t v43 = v114;
            BOOL v28 = v46;
            int v30 = v45;
          }
          *(void *)int v30 = v43;
          uint64_t v27 = 1;
        }
        else
        {
          unsigned int v64 = v30;
          unsigned int v65 = v30;
          unsigned int v66 = a2;
          uint64_t v67 = v27;
          int v68 = &a2[8 * v27];
          int v69 = (char *)sub_1CC057214(v64, v66, v68);
          BOOL v28 = v68;
          uint64_t v27 = v67;
          int v30 = v65;
          unsigned int v44 = v69;
        }
        goto LABEL_90;
      }
      goto LABEL_87;
    }
LABEL_85:
    int v30 = a2;
    unsigned int v44 = v28;
LABEL_90:
    a5 -= v29;
    if ((uint64_t)(v27 + v29) >= a5 + v10)
    {
      int v70 = v30;
      uint64_t v71 = v27;
      BOOL result = (char *)sub_1CD34292C(v44, v28, v118, a4, a5, v10, a7, a8);
      uint64_t v10 = v71;
      a5 = v29;
      a3 = v44;
    }
    else
    {
      int v70 = v28;
      BOOL result = (char *)sub_1CD34292C(v15, v30, v44, a4, v29, v27, a7, a8);
      unsigned int v15 = v44;
      a3 = v118;
    }
    a2 = v70;
    if (!v10) {
      return result;
    }
  }
  if (a5 <= v10)
  {
    if (v15 == a2) {
      return result;
    }
    uint64_t v90 = 0;
    do
    {
      *(void *)&a7[v90] = *(void *)&v15[v90];
      v90 += 8;
    }
    while (&v15[v90] != a2);
    if (!v90) {
      return result;
    }
    unsigned int v91 = a7;
    while (1)
    {
      if (a2 == a3) {
        return (char *)memmove(v15, v91, a7 - v91 + v90);
      }
      uint64_t v92 = *(void *)v91;
      unsigned int v93 = *(unsigned __int8 *)(*(void *)a2 + 16);
      if (*(void *)a2) {
        BOOL v94 = v93 >= 0x1C;
      }
      else {
        BOOL v94 = 0;
      }
      if (v94 && v93 - 83 >= 0xFFFFFFFE)
      {
        unsigned int v96 = *(unsigned __int8 *)(v92 + 16);
        BOOL v97 = v92 && v96 >= 0x1C;
        if (v97 && v96 - 83 >= 0xFFFFFFFE)
        {
          int v99 = *(_WORD *)(v92 + 18) & 0x3F;
          unsigned int v100 = *a4;
          int v120 = *(_WORD *)(*(void *)a2 + 18) & 0x3F;
          unsigned int v101 = sub_1CD8E5148(v100, &v120)[1];
          int v102 = *a4;
          int v119 = v99;
          BOOL result = (char *)sub_1CD8E5148(v102, &v119);
          if (v101 > *((_DWORD *)result + 1))
          {
            uint64_t v103 = *(void *)a2;
            a2 += 8;
            *(void *)unsigned int v15 = v103;
            goto LABEL_145;
          }
          uint64_t v92 = *(void *)v91;
        }
      }
      *(void *)unsigned int v15 = v92;
      v91 += 8;
LABEL_145:
      v15 += 8;
      if (&a7[v90] == v91) {
        return result;
      }
    }
  }
  if (a2 != a3)
  {
    uint64_t v72 = 0;
    do
    {
      *(void *)&a7[v72] = *(void *)&a2[v72];
      v72 += 8;
    }
    while (&a2[v72] != a3);
    if (v72)
    {
      uint64_t v73 = &a7[v72];
      uint64_t v74 = a3 - 8;
      while (a2 != v15)
      {
        int v76 = v73 - 8;
        uint64_t v75 = *((void *)v73 - 1);
        unsigned int v77 = *(unsigned __int8 *)(v75 + 16);
        if (v75) {
          BOOL v78 = v77 >= 0x1C;
        }
        else {
          BOOL v78 = 0;
        }
        if (v78 && v77 - 83 >= 0xFFFFFFFE)
        {
          uint64_t v80 = *((void *)a2 - 1);
          if (v80)
          {
            unsigned int v81 = *(unsigned __int8 *)(v80 + 16);
            if (v81 >= 0x1C && v81 - 83 >= 0xFFFFFFFE)
            {
              int v83 = *(_WORD *)(v80 + 18) & 0x3F;
              uint64_t v84 = *a4;
              int v120 = *(_WORD *)(v75 + 18) & 0x3F;
              unsigned int v85 = sub_1CD8E5148(v84, &v120)[1];
              uint64_t v86 = *a4;
              int v119 = v83;
              BOOL result = (char *)sub_1CD8E5148(v86, &v119);
              unsigned int v87 = *((_DWORD *)result + 1);
              BOOL v88 = v85 > v87;
              if (v85 <= v87) {
                uint64_t v89 = v73;
              }
              else {
                uint64_t v89 = a2;
              }
              if (v88)
              {
                a2 -= 8;
                int v76 = v73;
              }
              uint64_t v75 = *((void *)v89 - 1);
            }
          }
        }
        *(void *)uint64_t v74 = v75;
        v74 -= 8;
        uint64_t v73 = v76;
        if (v76 == a7) {
          return result;
        }
      }
      if (v73 != a7)
      {
        uint64_t v104 = 0;
        do
        {
          *(void *)&v74[v104] = *(void *)&v73[v104 - 8];
          v104 -= 8;
        }
        while (&v73[v104] != a7);
      }
    }
  }
  return result;
}

llvm::Instruction *sub_1CD342FB8(uint64_t a1, int a2, llvm::Value *a3, llvm::Value *a4, const llvm::Twine *a5, int a6)
{
  uint64_t Opcode = llvm::RecurrenceDescriptor::getOpcode(a2);
  switch(a2)
  {
    case 3:
      if (!a6) {
        goto LABEL_2;
      }
      uint64_t v27 = *(uint64_t ***)a3;
      BOOL v28 = (uint64_t **)(***(void ***)a3 + 1888);
      if (*(void *)a3) {
        BOOL v29 = (*(_DWORD *)(*(void *)a3 + 8) & 0xFE) == 18;
      }
      else {
        BOOL v29 = 0;
      }
      if (v29)
      {
        BOOL v37 = (llvm::Type *)*((unsigned int *)v27 + 8);
        if (*(_DWORD *)(*(void *)a3 + 8) == 19) {
          llvm::ScalableVectorType::get(v28, v37);
        }
        else {
          llvm::FixedVectorType::get((llvm::FixedVectorType *)v28, v37);
        }
      }
      if (v27 != v28) {
        goto LABEL_2;
      }
      int v30 = *(uint64_t **)(a1 + 64);
      uint64_t v31 = *v30;
      unsigned int v32 = *(llvm::Value **)(*v30 + 1560);
      if (!v32)
      {
        uint64_t v38 = *(llvm::ConstantInt **)(v31 + 1888);
        unsigned int v39 = *(_DWORD *)(v31 + 1896);
        unsigned int v42 = v39 >> 8;
        if (v39 >> 8 > 0x40) {
          llvm::APInt::initSlowCase((llvm::APInt *)&v41);
        }
        if (v39 <= 0xFF) {
          char v40 = 0;
        }
        else {
          char v40 = 0xFFFFFFFFFFFFFFFFLL >> -BYTE1(v39);
        }
        uint64_t v41 = v40 & 1;
        unsigned int v32 = (llvm::Value *)llvm::ConstantInt::get(v38, (llvm::LLVMContext *)&v41, v12);
        if (v42 >= 0x41 && v41) {
          MEMORY[0x1D25D9CB0](v41, 0x1000C8000313F17);
        }
        *(void *)(v31 + 1560) = v32;
      }
      uint64_t v21 = (llvm::IRBuilderBase *)a1;
      int v22 = a3;
      uint64_t v23 = v32;
      goto LABEL_32;
    case 4:
      if (!a6) {
        goto LABEL_2;
      }
      unsigned int v15 = *(uint64_t ***)a3;
      unsigned int v16 = (uint64_t **)(***(void ***)a3 + 1888);
      if (*(void *)a3) {
        BOOL v17 = (*(_DWORD *)(*(void *)a3 + 8) & 0xFE) == 18;
      }
      else {
        BOOL v17 = 0;
      }
      if (v17)
      {
        unsigned int v36 = (llvm::Type *)*((unsigned int *)v15 + 8);
        if (*(_DWORD *)(*(void *)a3 + 8) == 19) {
          llvm::ScalableVectorType::get(v16, v36);
        }
        else {
          llvm::FixedVectorType::get((llvm::FixedVectorType *)v16, v36);
        }
      }
      if (v15 != v16) {
        goto LABEL_2;
      }
      uint64_t v18 = *(uint64_t **)(a1 + 64);
      uint64_t v19 = *v18;
      BOOL v20 = *(llvm::Value **)(*v18 + 1568);
      if (!v20)
      {
        uint64_t v35 = *(llvm::ConstantInt **)(v19 + 1888);
        unsigned int v42 = *(_DWORD *)(v19 + 1896) >> 8;
        if (v42 > 0x40) {
          llvm::APInt::initSlowCase((llvm::APInt *)&v41);
        }
        uint64_t v41 = 0;
        BOOL v20 = (llvm::Value *)llvm::ConstantInt::get(v35, (llvm::LLVMContext *)&v41, v12);
        if (v42 >= 0x41 && v41) {
          MEMORY[0x1D25D9CB0](v41, 0x1000C8000313F17);
        }
        *(void *)(v19 + 1568) = v20;
      }
      uint64_t v21 = (llvm::IRBuilderBase *)a1;
      int v22 = a3;
      uint64_t v23 = a4;
      unsigned int v24 = v20;
      goto LABEL_33;
    case 6:
      if (a6)
      {
        uint64_t v33 = a1;
        __int16 v34 = 40;
        goto LABEL_31;
      }
      __int16 v43 = 257;
      BOOL v25 = (llvm::IRBuilderBase *)a1;
      int v26 = 275;
      return (llvm::Instruction *)llvm::IRBuilderBase::CreateBinaryIntrinsic(v25, v26, a3, a4, 0, (const llvm::Twine *)&v41);
    case 7:
      if (a6)
      {
        uint64_t v33 = a1;
        __int16 v34 = 38;
        goto LABEL_31;
      }
      __int16 v43 = 257;
      BOOL v25 = (llvm::IRBuilderBase *)a1;
      int v26 = 274;
      return (llvm::Instruction *)llvm::IRBuilderBase::CreateBinaryIntrinsic(v25, v26, a3, a4, 0, (const llvm::Twine *)&v41);
    case 8:
      if (a6)
      {
        uint64_t v33 = a1;
        __int16 v34 = 36;
        goto LABEL_31;
      }
      __int16 v43 = 257;
      BOOL v25 = (llvm::IRBuilderBase *)a1;
      int v26 = 306;
      return (llvm::Instruction *)llvm::IRBuilderBase::CreateBinaryIntrinsic(v25, v26, a3, a4, 0, (const llvm::Twine *)&v41);
    case 9:
      if (a6)
      {
        uint64_t v33 = a1;
        __int16 v34 = 34;
LABEL_31:
        int v22 = sub_1CB845F20(v33, v34, a3, (uint64_t)a4, (uint64_t)a5);
        uint64_t v21 = (llvm::IRBuilderBase *)a1;
        uint64_t v23 = a3;
LABEL_32:
        unsigned int v24 = a4;
LABEL_33:
        return llvm::IRBuilderBase::CreateSelect(v21, v22, v23, v24, a5, 0);
      }
      else
      {
        __int16 v43 = 257;
        BOOL v25 = (llvm::IRBuilderBase *)a1;
        int v26 = 305;
        return (llvm::Instruction *)llvm::IRBuilderBase::CreateBinaryIntrinsic(v25, v26, a3, a4, 0, (const llvm::Twine *)&v41);
      }
    case 12:
      __int16 v43 = 257;
      BOOL v25 = (llvm::IRBuilderBase *)a1;
      int v26 = 202;
      return (llvm::Instruction *)llvm::IRBuilderBase::CreateBinaryIntrinsic(v25, v26, a3, a4, 0, (const llvm::Twine *)&v41);
    case 13:
      __int16 v43 = 257;
      BOOL v25 = (llvm::IRBuilderBase *)a1;
      int v26 = 193;
      return (llvm::Instruction *)llvm::IRBuilderBase::CreateBinaryIntrinsic(v25, v26, a3, a4, 0, (const llvm::Twine *)&v41);
    default:
LABEL_2:
      return sub_1CB844E98(a1, Opcode, (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, 0);
  }
}

unint64_t sub_1CD3433C8(uint64_t a1, void *a2, void *a3, int a4)
{
  do
  {
    int v8 = *(_DWORD *)(a1 + 20);
    if ((v8 & 0x40000000) != 0) {
      uint64_t v9 = *(void *)(a1 - 8);
    }
    else {
      uint64_t v9 = a1 - 32 * (v8 & 0x7FFFFFF);
    }
    uint64_t v10 = *(void *)(v9 + 32);
    unint64_t result = sub_1CD32AEA4(a1, a4);
    if (!HIDWORD(result)) {
      break;
    }
    int v12 = *(unsigned __int8 *)(v10 + 16);
    if (v12 == 93 || v12 == 90)
    {
      unint64_t result = sub_1CD3433C8(v10, a2, a3, result);
    }
    else
    {
      uint64_t v13 = 8 * result;
      *(void *)(*a2 + v13) = v10;
      *(void *)(*a3 + v13) = a1;
    }
    int v14 = *(_DWORD *)(a1 + 20);
    unsigned int v15 = (v14 & 0x40000000) != 0 ? *(uint64_t **)(a1 - 8) : (uint64_t *)(a1 - 32 * (v14 & 0x7FFFFFF));
    a1 = *v15;
    if (!*v15) {
      break;
    }
    unsigned int v16 = *(unsigned __int8 *)(a1 + 16);
    if (v16 < 0x1C || v16 != 93 && v16 != 90) {
      break;
    }
    uint64_t v17 = *(void *)(a1 + 8);
    if (!v17) {
      break;
    }
  }
  while (!*(void *)(v17 + 8));
  return result;
}

void sub_1CD3434C0()
{
}

void sub_1CD3434FC(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F264BDF0;
  sub_1CD719F1C((uint64_t)a1 + 152);
  sub_1CD719F1C((uint64_t)a1 + 104);

  llvm::Pass::~Pass(a1);
}

void sub_1CD343558(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F264BDF0;
  sub_1CD719F1C((uint64_t)a1 + 152);
  sub_1CD719F1C((uint64_t)a1 + 104);
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD3435C8()
{
  return 0;
}

void sub_1CD3435D0(uint64_t a1, uint64_t a2)
{
  sub_1CB843600(a2, a2, (uint64_t)llvm::AssumptionCacheTracker::ID);
  sub_1CB843600(a2, a2, (uint64_t)llvm::ScalarEvolutionWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)llvm::AAResultsWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)llvm::TargetTransformInfoWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::LoopInfoWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::DemandedBitsWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::OptimizationRemarkEmitterWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::InjectTLIMappingsLegacy::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::LoopInfoWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)llvm::AAResultsWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::GlobalsAAWrapperPass::ID);
  v5[0] = &unk_1F2617E40;
  v5[1] = a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(v3);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v5);
}

uint64_t sub_1CD343738(llvm::FunctionPass *a1, uint64_t a2)
{
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  if (llvm::FunctionPass::skipFunction(a1, (llvm::LLVMContextImpl ****)a2)) {
    return 0;
  }
  int v5 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v6 = *v5;
  uint64_t v7 = v5[1];
  if (v6 == v7)
  {
LABEL_6:
    uint64_t v8 = 0;
  }
  else
  {
    while (*(char **)v6 != llvm::ScalarEvolutionWrapperPass::ID)
    {
      v6 += 16;
      if (v6 == v7) {
        goto LABEL_6;
      }
    }
    uint64_t v8 = *(void *)(v6 + 8);
  }
  uint64_t v9 = *(void *)((*(uint64_t (**)(uint64_t, char *))(*(void *)v8 + 96))(v8, llvm::ScalarEvolutionWrapperPass::ID)+ 32);
  uint64_t v10 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v11 = *v10;
  uint64_t v12 = v10[1];
  if (v11 == v12)
  {
LABEL_11:
    uint64_t v13 = 0;
  }
  else
  {
    while (*(char **)v11 != llvm::TargetTransformInfoWrapperPass::ID)
    {
      v11 += 16;
      if (v11 == v12) {
        goto LABEL_11;
      }
    }
    uint64_t v13 = *(void *)(v11 + 8);
  }
  int v14 = (llvm::TargetTransformInfoWrapperPass *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v13 + 96))(v13, llvm::TargetTransformInfoWrapperPass::ID);
  TTI = llvm::TargetTransformInfoWrapperPass::getTTI(v14, (const Function *)a2);
  uint64_t AnalysisPass = llvm::PMDataManager::findAnalysisPass(*(llvm::PMDataManager **)(*((void *)a1 + 1) + 24), llvm::TargetLibraryInfoWrapperPass::ID, 1);
  if (AnalysisPass)
  {
    uint64_t v17 = (*(uint64_t (**)(uint64_t, char *))(*(void *)AnalysisPass + 96))(AnalysisPass, llvm::TargetLibraryInfoWrapperPass::ID);
    if (v17)
    {
      uint64_t v18 = v17 + 32;
      if (!*(unsigned char *)(v17 + 232))
      {
        uint64_t v53 = *(void *)(a2 + 40) + 216;
        __int16 v56 = 260;
        v55[0] = v53;
        llvm::Triple::Triple((llvm::Triple *)__p, (const llvm::Twine *)v55);
        uint64_t v66 = 0;
        uint64_t v67 = 0;
        int v68 = 0;
        long long v69 = 0u;
        long long v70 = 0u;
        long long v71 = 0u;
        *(void *)&long long v54 = -1;
        *((void *)&v54 + 1) = -1;
        *(_OWORD *)uint64_t __src = v54;
        long long v60 = v54;
        long long v61 = v54;
        long long v62 = v54;
        long long v63 = v54;
        long long v64 = v54;
        *(_OWORD *)unsigned int v65 = v54;
        *(void *)&v65[13] = -1;
        sub_1CC153974((uint64_t)__src, (int *)__p);
        sub_1CD4D04B8(v18, (uint64_t)__src);
        sub_1CD4CFA4C((uint64_t *)__src);
        if (v58 < 0) {
          operator delete(__p[0]);
        }
      }
      sub_1CC1569E8(__src, v18);
    }
  }
  uint64_t v19 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v20 = *v19;
  uint64_t v21 = v19[1];
  if (v20 == v21)
  {
LABEL_21:
    uint64_t v22 = 0;
  }
  else
  {
    while (*(char **)v20 != llvm::AAResultsWrapperPass::ID)
    {
      v20 += 16;
      if (v20 == v21) {
        goto LABEL_21;
      }
    }
    uint64_t v22 = *(void *)(v20 + 8);
  }
  uint64_t v23 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v22 + 96))(v22, llvm::AAResultsWrapperPass::ID);
  unsigned int v24 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v25 = *v24;
  uint64_t v26 = v24[1];
  if (v25 == v26)
  {
LABEL_26:
    uint64_t v27 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v25 != &llvm::LoopInfoWrapperPass::ID)
    {
      v25 += 16;
      if (v25 == v26) {
        goto LABEL_26;
      }
    }
    uint64_t v27 = *(void *)(v25 + 8);
  }
  uint64_t v28 = *(void *)(v23 + 32);
  uint64_t v29 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v27 + 96))(v27, &llvm::LoopInfoWrapperPass::ID);
  int v30 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v31 = *v30;
  uint64_t v32 = v30[1];
  if (v31 == v32)
  {
LABEL_31:
    uint64_t v33 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v31 != &llvm::DominatorTreeWrapperPass::ID)
    {
      v31 += 16;
      if (v31 == v32) {
        goto LABEL_31;
      }
    }
    uint64_t v33 = *(void *)(v31 + 8);
  }
  uint64_t v34 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v33 + 96))(v33, &llvm::DominatorTreeWrapperPass::ID);
  uint64_t v35 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v36 = *v35;
  uint64_t v37 = v35[1];
  if (v36 == v37)
  {
LABEL_36:
    uint64_t v38 = 0;
  }
  else
  {
    while (*(char **)v36 != llvm::AssumptionCacheTracker::ID)
    {
      v36 += 16;
      if (v36 == v37) {
        goto LABEL_36;
      }
    }
    uint64_t v38 = *(void *)(v36 + 8);
  }
  uint64_t v39 = v29 + 32;
  uint64_t v40 = v34 + 32;
  uint64_t v41 = (llvm::AssumptionCacheTracker *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v38 + 96))(v38, llvm::AssumptionCacheTracker::ID);
  uint64_t AssumptionCache = llvm::AssumptionCacheTracker::getAssumptionCache(v41, (llvm::Function *)a2);
  __int16 v43 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v44 = *v43;
  uint64_t v45 = v43[1];
  if (v44 == v45)
  {
LABEL_41:
    uint64_t v46 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v44 != &llvm::DemandedBitsWrapperPass::ID)
    {
      v44 += 16;
      if (v44 == v45) {
        goto LABEL_41;
      }
    }
    uint64_t v46 = *(void *)(v44 + 8);
  }
  uint64_t v47 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v46 + 96))(v46, &llvm::DemandedBitsWrapperPass::ID)
      + 32;
  unint64_t v48 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v49 = *v48;
  uint64_t v50 = v48[1];
  if (v49 == v50)
  {
LABEL_46:
    uint64_t v51 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v49 != &llvm::OptimizationRemarkEmitterWrapperPass::ID)
    {
      v49 += 16;
      if (v49 == v50) {
        goto LABEL_46;
      }
    }
    uint64_t v51 = *(void *)(v49 + 8);
  }
  uint64_t v52 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v51 + 96))(v51, &llvm::OptimizationRemarkEmitterWrapperPass::ID);
  return llvm::SLPVectorizerPass::runImpl((uint64_t)a1 + 32, a2, v9, (uint64_t)TTI, 0, v28, v39, v40, AssumptionCache, v47, *(void *)(v52 + 32));
}

uint64_t sub_1CD343E58(uint64_t *a1, uint64_t a2, _DWORD *a3)
{
  unint64_t v3 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 3);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0x666666666666666) {
    abort();
  }
  if (0x999999999999999ALL * ((a1[2] - *a1) >> 3) > v4) {
    unint64_t v4 = 0x999999999999999ALL * ((a1[2] - *a1) >> 3);
  }
  if (0xCCCCCCCCCCCCCCCDLL * ((a1[2] - *a1) >> 3) >= 0x333333333333333) {
    unint64_t v8 = 0x666666666666666;
  }
  else {
    unint64_t v8 = v4;
  }
  uint64_t v25 = a1 + 2;
  if (v8)
  {
    if (v8 > 0x666666666666666) {
      sub_1CB833614();
    }
    uint64_t v9 = (char *)operator new(40 * v8);
  }
  else
  {
    uint64_t v9 = 0;
  }
  uint64_t v10 = &v9[40 * v3];
  __p = v9;
  uint64_t v22 = v10;
  unsigned int v24 = &v9[40 * v8];
  *(void *)uint64_t v10 = v10 + 16;
  *((void *)v10 + 1) = 0x400000000;
  unsigned int v11 = *(_DWORD *)(a2 + 8);
  if (v10 != (char *)a2 && v11 != 0)
  {
    uint64_t v13 = *(const void **)a2;
    if (*(void *)a2 == a2 + 16)
    {
      if (v11 >= 5) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v10 + 16, v13, 4 * *(unsigned int *)(a2 + 8));
      *((_DWORD *)v10 + 2) = v11;
    }
    else
    {
      *(void *)uint64_t v10 = v13;
      int v20 = *(_DWORD *)(a2 + 12);
      *((_DWORD *)v10 + 2) = v11;
      *((_DWORD *)v10 + 3) = v20;
      *(void *)a2 = a2 + 16;
      *(_DWORD *)(a2 + 12) = 0;
    }
    *(_DWORD *)(a2 + 8) = 0;
  }
  *(_DWORD *)&v9[40 * v3 + 32] = *a3;
  uint64_t v23 = v10 + 40;
  sub_1CD8E671C(a1, &__p);
  uint64_t v14 = a1[1];
  unsigned int v15 = v22;
  unsigned int v16 = v23;
  while (v16 != v15)
  {
    uint64_t v18 = (char *)*((void *)v16 - 5);
    v16 -= 40;
    uint64_t v17 = v18;
    if (v16 + 16 != v18) {
      free(v17);
    }
  }
  if (__p) {
    operator delete(__p);
  }
  return v14;
}

uint64_t sub_1CD344030(uint64_t *a1, void *a2, uint64_t a3)
{
  unint64_t v3 = 0x8E38E38E38E38E39 * ((a1[1] - *a1) >> 3);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0x38E38E38E38E38ELL) {
    abort();
  }
  if (0x1C71C71C71C71C72 * ((a1[2] - *a1) >> 3) > v4) {
    unint64_t v4 = 0x1C71C71C71C71C72 * ((a1[2] - *a1) >> 3);
  }
  if (0x8E38E38E38E38E39 * ((a1[2] - *a1) >> 3) >= 0x1C71C71C71C71C7) {
    unint64_t v6 = 0x38E38E38E38E38ELL;
  }
  else {
    unint64_t v6 = v4;
  }
  uint64_t v21 = a1 + 2;
  if (v6 > 0x38E38E38E38E38ELL) {
    sub_1CB833614();
  }
  uint64_t v9 = 9 * v6;
  uint64_t v10 = (char *)operator new(72 * v6);
  unsigned int v11 = &v10[72 * v3];
  __p = v10;
  uint64_t v18 = v11;
  int v20 = &v10[8 * v9];
  *(void *)unsigned int v11 = *a2;
  *((void *)v11 + 1) = v11 + 24;
  *((void *)v11 + 2) = 0x300000000;
  if (*(_DWORD *)(a3 + 8)) {
    sub_1CD8E699C((uint64_t)(v11 + 8), (uint64_t *)a3);
  }
  uint64_t v19 = v11 + 72;
  sub_1CD8E6AF0(a1, &__p);
  uint64_t v12 = a1[1];
  uint64_t v13 = v18;
  for (uint64_t i = v19; i != v13; i -= 72)
  {
    unsigned int v15 = (char *)*((void *)i - 8);
    if (i - 48 != v15) {
      free(v15);
    }
  }
  if (__p) {
    operator delete(__p);
  }
  return v12;
}

void sub_1CD344198(uint64_t *a1, uint64_t a2)
{
  unint64_t v4 = a1[2];
  int v5 = (void *)a1[1];
  if ((unint64_t)v5 >= v4)
  {
    unint64_t v7 = 0x8E38E38E38E38E39 * (((uint64_t)v5 - *a1) >> 3);
    if (v7 + 1 > 0x38E38E38E38E38ELL) {
      abort();
    }
    unint64_t v8 = 0x8E38E38E38E38E39 * ((uint64_t)(v4 - *a1) >> 3);
    uint64_t v9 = 2 * v8;
    if (2 * v8 <= v7 + 1) {
      uint64_t v9 = v7 + 1;
    }
    if (v8 >= 0x1C71C71C71C71C7) {
      unint64_t v10 = 0x38E38E38E38E38ELL;
    }
    else {
      unint64_t v10 = v9;
    }
    uint64_t v21 = a1 + 2;
    if (v10 > 0x38E38E38E38E38ELL) {
      sub_1CB833614();
    }
    uint64_t v11 = 9 * v10;
    uint64_t v12 = (char *)operator new(72 * v10);
    uint64_t v13 = &v12[72 * v7];
    __p = v12;
    uint64_t v18 = v13;
    int v20 = &v12[8 * v11];
    *(void *)uint64_t v13 = *(void *)a2;
    *((void *)v13 + 1) = v13 + 24;
    *((void *)v13 + 2) = 0x300000000;
    if (*(_DWORD *)(a2 + 16)) {
      sub_1CD8E699C((uint64_t)(v13 + 8), (uint64_t *)(a2 + 8));
    }
    uint64_t v19 = v13 + 72;
    sub_1CD8E6AF0(a1, &__p);
    unint64_t v6 = (void *)a1[1];
    uint64_t v14 = v18;
    for (uint64_t i = v19; i != v14; i -= 72)
    {
      unsigned int v16 = (char *)*((void *)i - 8);
      if (i - 48 != v16) {
        free(v16);
      }
    }
    if (__p) {
      operator delete(__p);
    }
  }
  else
  {
    void *v5 = *(void *)a2;
    v5[1] = v5 + 3;
    void v5[2] = 0x300000000;
    if (*(_DWORD *)(a2 + 16)) {
      sub_1CD8E699C((uint64_t)(v5 + 1), (uint64_t *)(a2 + 8));
    }
    unint64_t v6 = v5 + 9;
  }
  a1[1] = (uint64_t)v6;
}

char *sub_1CD34433C(char **a1, long long *a2)
{
  uint64_t v2 = (a1[1] - *a1) >> 4;
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 60) {
    abort();
  }
  uint64_t v5 = a1[2] - *a1;
  if (v5 >> 3 > v3) {
    unint64_t v3 = v5 >> 3;
  }
  if ((unint64_t)v5 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v6 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v6 = v3;
  }
  if (v6 >> 60) {
    sub_1CB833614();
  }
  unint64_t v8 = (char *)operator new(16 * v6);
  uint64_t v9 = &v8[16 * v2];
  unint64_t v10 = &v8[16 * v6];
  long long v11 = *a2;
  *((void *)a2 + 1) = 0;
  *(_OWORD *)uint64_t v9 = v11;
  uint64_t v12 = v9 + 16;
  uint64_t v13 = *a1;
  uint64_t v14 = a1[1];
  if (v14 == *a1)
  {
    *a1 = v9;
    a1[1] = v12;
    a1[2] = v10;
  }
  else
  {
    do
    {
      uint64_t v15 = *((void *)v14 - 2);
      v14 -= 16;
      *((void *)v9 - 2) = v15;
      v9 -= 16;
      uint64_t v16 = *((void *)v14 + 1);
      *((void *)v14 + 1) = 0;
      *((void *)v9 + 1) = v16;
    }
    while (v14 != v13);
    uint64_t v14 = *a1;
    uint64_t v17 = a1[1];
    *a1 = v9;
    a1[1] = v12;
    a1[2] = v10;
    while (v17 != v14)
    {
      uint64_t v18 = *((void *)v17 - 1);
      *((void *)v17 - 1) = 0;
      if (v18)
      {
        uint64_t v19 = sub_1CD8E6BC8(v18);
        MEMORY[0x1D25D9CE0](v19, 0x10A0C4010E67334);
      }
      v17 -= 16;
    }
  }
  if (v14) {
    operator delete(v14);
  }
  return v12;
}

void sub_1CD344458(void ***a1)
{
  int v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    unint64_t v4 = v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = *--v4;
        uint64_t v6 = v7;
        void *v4 = 0;
        if (v7) {
          sub_1CD3496FC(v6);
        }
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1CD3444E0(uint64_t a1, uint64_t a2)
{
  return sub_1CD3444F4(a2, *(void *)(*(void *)a1 + 384), *(void *)(*(void *)a1 + 392));
}

uint64_t sub_1CD3444F4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 && *(unsigned __int8 *)(a2 + 16) - 83 >= 0xFFFFFFFE)
  {
    uint64_t v3 = *(_WORD *)(a3 + 18) & 0x3F;
    int v4 = dword_1CFB33A68[v3];
    if (v4 == (*(_WORD *)(a2 + 18) & 0x3F))
    {
      if (a3 == a1) {
        return 1;
      }
      if (a1 == a2) {
        return 0;
      }
      return !sub_1CD32B748(*(void *)(a2 - 64), *(void *)(a2 - 32), *(void *)(a1 - 64), *(void *)(a1 - 32));
    }
    int v7 = *(_WORD *)(a1 + 18) & 0x3F;
    return v3 == v7 || v4 == v7;
  }
  else
  {
    return *(unsigned __int8 *)(a1 + 16) == *(unsigned __int8 *)(a3 + 16);
  }
}

uint64_t *sub_1CD3445A4(uint64_t *result, uint64_t *a2, uint64_t a3, uint64_t a4, char a5)
{
  long long v11 = result;
LABEL_2:
  uint64_t v12 = a2 - 1;
  uint64_t v13 = v11;
  while (1)
  {
    long long v11 = v13;
    uint64_t v14 = (char *)a2 - (char *)v13;
    uint64_t v15 = a2 - v13;
    if (v6 || !v5)
    {
      switch(v15)
      {
        case 0:
        case 1:
          return result;
        case 2:
          uint64_t v302 = *(a2 - 1);
          uint64_t v303 = *v13;
          uint64_t v304 = *(void *)(*(void *)a3 + 1960);
          uint64_t v305 = *(void *)(v304 + 24);
          uint64_t v306 = *(unsigned int *)(v304 + 40);
          if (!v306) {
            goto LABEL_820;
          }
          uint64_t v307 = *(void *)(v302 + 40);
          LODWORD(v308) = ((v307 >> 4) ^ (v307 >> 9)) & (v306 - 1);
          uint64_t v309 = (uint64_t *)(v305 + 16 * v308);
          uint64_t v310 = *v309;
          if (v307 == *v309) {
            goto LABEL_821;
          }
          int v311 = 1;
          while (v310 != -4096)
          {
            int v312 = v308 + v311++;
            uint64_t v308 = v312 & (v306 - 1);
            uint64_t v310 = *(void *)(v305 + 16 * v308);
            if (v307 == v310)
            {
              uint64_t v309 = (uint64_t *)(v305 + 16 * v308);
              goto LABEL_821;
            }
          }
LABEL_820:
          uint64_t v309 = (uint64_t *)(v305 + 16 * v306);
LABEL_821:
          if (v309 == (uint64_t *)(v305 + 16 * v306)) {
            uint64_t v602 = 0;
          }
          else {
            uint64_t v602 = v309[1];
          }
          uint64_t v603 = *(void *)(v303 + 40);
          if (!v306) {
            goto LABEL_840;
          }
          LODWORD(v604) = ((v603 >> 4) ^ (v603 >> 9)) & (v306 - 1);
          v605 = (uint64_t *)(v305 + 16 * v604);
          uint64_t v606 = *v605;
          if (v603 != *v605)
          {
            int v607 = 1;
            while (v606 != -4096)
            {
              int v608 = v604 + v607++;
              uint64_t v604 = v608 & (v306 - 1);
              uint64_t v606 = *(void *)(v305 + 16 * v604);
              if (v603 == v606)
              {
                v605 = (uint64_t *)(v305 + 16 * v604);
                goto LABEL_841;
              }
            }
LABEL_840:
            v605 = (uint64_t *)(v305 + 16 * v306);
          }
LABEL_841:
          if (v605 == (uint64_t *)(v305 + 16 * v306)) {
            uint64_t v616 = 0;
          }
          else {
            uint64_t v616 = v605[1];
          }
          if (v602 == v616)
          {
            int v617 = *(__int16 *)(v603 + 18);
            if ((v617 & 0x80000000) == 0)
            {
              uint64_t v669 = *(void *)(v603 + 48);
              if (v669 != v603 + 40)
              {
                int v670 = 0;
                do
                {
                  uint64_t v671 = v669 - 24;
                  if (!v669) {
                    uint64_t v671 = 0;
                  }
                  *(_DWORD *)(v671 + 56) = v670++;
                  uint64_t v669 = *(void *)(v669 + 8);
                }
                while (v669 != v603 + 40);
              }
              *(_WORD *)(v603 + 18) = v617 | 0x8000;
            }
            if (*(_DWORD *)(v303 + 56) >= *(_DWORD *)(v302 + 56)) {
              return result;
            }
          }
          else if (*(_DWORD *)(v602 + 72) >= *(_DWORD *)(v616 + 72))
          {
            return result;
          }
          *uint64_t v13 = v302;
          *(a2 - 1) = v303;
          return result;
        case 3:
          return sub_1CD3471D4(v13, v13 + 1, a2 - 1, a3);
        case 4:
          return sub_1CD3484B4(v13, v13 + 1, v13 + 2, a2 - 1, a3);
        case 5:
          uint64_t v313 = v13 + 2;
          uint64_t v314 = v13 + 3;
          unint64_t result = sub_1CD3484B4(v13, v13 + 1, v13 + 2, v13 + 3, a3);
          uint64_t v315 = *(a2 - 1);
          uint64_t v316 = v13[3];
          uint64_t v317 = *(void *)(*(void *)a3 + 1960);
          uint64_t v318 = *(void *)(v317 + 24);
          uint64_t v319 = *(unsigned int *)(v317 + 40);
          if (!v319) {
            goto LABEL_830;
          }
          uint64_t v320 = *(void *)(v315 + 40);
          LODWORD(v321) = ((v320 >> 4) ^ (v320 >> 9)) & (v319 - 1);
          unsigned __int8 v322 = (uint64_t *)(v318 + 16 * v321);
          uint64_t v323 = *v322;
          if (v320 == *v322) {
            goto LABEL_831;
          }
          int v324 = 1;
          while (v323 != -4096)
          {
            int v325 = v321 + v324++;
            uint64_t v321 = v325 & (v319 - 1);
            uint64_t v323 = *(void *)(v318 + 16 * v321);
            if (v320 == v323)
            {
              unsigned __int8 v322 = (uint64_t *)(v318 + 16 * v321);
              goto LABEL_831;
            }
          }
LABEL_830:
          unsigned __int8 v322 = (uint64_t *)(v318 + 16 * v319);
LABEL_831:
          if (v322 == (uint64_t *)(v318 + 16 * v319)) {
            uint64_t v609 = 0;
          }
          else {
            uint64_t v609 = v322[1];
          }
          uint64_t v610 = *(void *)(v316 + 40);
          if (!v319) {
            goto LABEL_850;
          }
          LODWORD(v611) = ((v610 >> 4) ^ (v610 >> 9)) & (v319 - 1);
          uint64_t v612 = (uint64_t *)(v318 + 16 * v611);
          uint64_t v613 = *v612;
          if (v610 != *v612)
          {
            int v614 = 1;
            while (v613 != -4096)
            {
              int v615 = v611 + v614++;
              uint64_t v611 = v615 & (v319 - 1);
              uint64_t v613 = *(void *)(v318 + 16 * v611);
              if (v610 == v613)
              {
                uint64_t v612 = (uint64_t *)(v318 + 16 * v611);
                goto LABEL_851;
              }
            }
LABEL_850:
            uint64_t v612 = (uint64_t *)(v318 + 16 * v319);
          }
LABEL_851:
          if (v612 == (uint64_t *)(v318 + 16 * v319)) {
            uint64_t v618 = 0;
          }
          else {
            uint64_t v618 = v612[1];
          }
          if (v609 == v618)
          {
            int v619 = *(__int16 *)(v610 + 18);
            if ((v619 & 0x80000000) == 0)
            {
              uint64_t v672 = *(void *)(v610 + 48);
              if (v672 != v610 + 40)
              {
                int v673 = 0;
                do
                {
                  uint64_t v674 = v672 - 24;
                  if (!v672) {
                    uint64_t v674 = 0;
                  }
                  *(_DWORD *)(v674 + 56) = v673++;
                  uint64_t v672 = *(void *)(v672 + 8);
                }
                while (v672 != v610 + 40);
              }
              *(_WORD *)(v610 + 18) = v619 | 0x8000;
            }
            if (*(_DWORD *)(v316 + 56) >= *(_DWORD *)(v315 + 56)) {
              return result;
            }
          }
          else if (*(_DWORD *)(v609 + 72) >= *(_DWORD *)(v618 + 72))
          {
            return result;
          }
          *uint64_t v314 = v315;
          *(a2 - 1) = v316;
          uint64_t v620 = *v314;
          uint64_t v621 = *v313;
          uint64_t v622 = *(void *)(*(void *)a3 + 1960);
          uint64_t v623 = *(void *)(v622 + 24);
          uint64_t v624 = *(unsigned int *)(v622 + 40);
          if (!v624) {
            goto LABEL_865;
          }
          uint64_t v625 = *(void *)(v620 + 40);
          LODWORD(v626) = ((v625 >> 4) ^ (v625 >> 9)) & (v624 - 1);
          v627 = (uint64_t *)(v623 + 16 * v626);
          uint64_t v628 = *v627;
          if (v625 != *v627)
          {
            int v629 = 1;
            while (v628 != -4096)
            {
              int v630 = v626 + v629++;
              uint64_t v626 = v630 & (v624 - 1);
              uint64_t v628 = *(void *)(v623 + 16 * v626);
              if (v625 == v628)
              {
                v627 = (uint64_t *)(v623 + 16 * v626);
                goto LABEL_866;
              }
            }
LABEL_865:
            v627 = (uint64_t *)(v623 + 16 * v624);
          }
LABEL_866:
          if (v627 == (uint64_t *)(v623 + 16 * v624)) {
            uint64_t v631 = 0;
          }
          else {
            uint64_t v631 = v627[1];
          }
          uint64_t v632 = *(void *)(v621 + 40);
          if (!v624) {
            goto LABEL_875;
          }
          LODWORD(v633) = ((v632 >> 4) ^ (v632 >> 9)) & (v624 - 1);
          v634 = (uint64_t *)(v623 + 16 * v633);
          uint64_t v635 = *v634;
          if (v632 != *v634)
          {
            int v636 = 1;
            while (v635 != -4096)
            {
              int v637 = v633 + v636++;
              uint64_t v633 = v637 & (v624 - 1);
              uint64_t v635 = *(void *)(v623 + 16 * v633);
              if (v632 == v635)
              {
                v634 = (uint64_t *)(v623 + 16 * v633);
                goto LABEL_876;
              }
            }
LABEL_875:
            v634 = (uint64_t *)(v623 + 16 * v624);
          }
LABEL_876:
          if (v634 == (uint64_t *)(v623 + 16 * v624)) {
            uint64_t v638 = 0;
          }
          else {
            uint64_t v638 = v634[1];
          }
          if (v631 == v638)
          {
            int v639 = *(__int16 *)(v632 + 18);
            if ((v639 & 0x80000000) == 0)
            {
              uint64_t v684 = *(void *)(v632 + 48);
              if (v684 != v632 + 40)
              {
                int v685 = 0;
                do
                {
                  uint64_t v686 = v684 - 24;
                  if (!v684) {
                    uint64_t v686 = 0;
                  }
                  *(_DWORD *)(v686 + 56) = v685++;
                  uint64_t v684 = *(void *)(v684 + 8);
                }
                while (v684 != v632 + 40);
              }
              *(_WORD *)(v632 + 18) = v639 | 0x8000;
            }
            if (*(_DWORD *)(v621 + 56) >= *(_DWORD *)(v620 + 56)) {
              return result;
            }
          }
          else if (*(_DWORD *)(v631 + 72) >= *(_DWORD *)(v638 + 72))
          {
            return result;
          }
          uint64_t *v313 = v620;
          *uint64_t v314 = v621;
          uint64_t v640 = v13[1];
          uint64_t v641 = *(void *)(*(void *)a3 + 1960);
          uint64_t v642 = *(void *)(v641 + 24);
          uint64_t v643 = *(unsigned int *)(v641 + 40);
          if (!v643) {
            goto LABEL_890;
          }
          uint64_t v644 = *(void *)(v620 + 40);
          LODWORD(v645) = ((v644 >> 4) ^ (v644 >> 9)) & (v643 - 1);
          v646 = (uint64_t *)(v642 + 16 * v645);
          uint64_t v647 = *v646;
          if (v644 != *v646)
          {
            int v648 = 1;
            while (v647 != -4096)
            {
              int v649 = v645 + v648++;
              uint64_t v645 = v649 & (v643 - 1);
              uint64_t v647 = *(void *)(v642 + 16 * v645);
              if (v644 == v647)
              {
                v646 = (uint64_t *)(v642 + 16 * v645);
                goto LABEL_891;
              }
            }
LABEL_890:
            v646 = (uint64_t *)(v642 + 16 * v643);
          }
LABEL_891:
          if (v646 == (uint64_t *)(v642 + 16 * v643)) {
            uint64_t v650 = 0;
          }
          else {
            uint64_t v650 = v646[1];
          }
          uint64_t v651 = *(void *)(v640 + 40);
          if (!v643) {
            goto LABEL_900;
          }
          LODWORD(v652) = ((v651 >> 4) ^ (v651 >> 9)) & (v643 - 1);
          v653 = (uint64_t *)(v642 + 16 * v652);
          uint64_t v654 = *v653;
          if (v651 != *v653)
          {
            int v655 = 1;
            while (v654 != -4096)
            {
              int v656 = v652 + v655++;
              uint64_t v652 = v656 & (v643 - 1);
              uint64_t v654 = *(void *)(v642 + 16 * v652);
              if (v651 == v654)
              {
                v653 = (uint64_t *)(v642 + 16 * v652);
                goto LABEL_901;
              }
            }
LABEL_900:
            v653 = (uint64_t *)(v642 + 16 * v643);
          }
LABEL_901:
          if (v653 == (uint64_t *)(v642 + 16 * v643)) {
            uint64_t v657 = 0;
          }
          else {
            uint64_t v657 = v653[1];
          }
          if (v650 == v657)
          {
            int v658 = *(__int16 *)(v651 + 18);
            if ((v658 & 0x80000000) == 0)
            {
              uint64_t v687 = *(void *)(v651 + 48);
              if (v687 != v651 + 40)
              {
                int v688 = 0;
                do
                {
                  uint64_t v689 = v687 - 24;
                  if (!v687) {
                    uint64_t v689 = 0;
                  }
                  *(_DWORD *)(v689 + 56) = v688++;
                  uint64_t v687 = *(void *)(v687 + 8);
                }
                while (v687 != v651 + 40);
              }
              *(_WORD *)(v651 + 18) = v658 | 0x8000;
            }
            if (*(_DWORD *)(v640 + 56) >= *(_DWORD *)(v620 + 56)) {
              return result;
            }
          }
          else if (*(_DWORD *)(v650 + 72) >= *(_DWORD *)(v657 + 72))
          {
            return result;
          }
          v13[1] = v620;
          v13[2] = v640;
          uint64_t v659 = *v13;
          uint64_t v660 = *(void *)(*(void *)a3 + 1960);
          uint64_t v661 = *(void *)(v660 + 24);
          uint64_t v662 = *(unsigned int *)(v660 + 40);
          if (!v662) {
            goto LABEL_927;
          }
          uint64_t v663 = *(void *)(v620 + 40);
          LODWORD(v664) = ((v663 >> 4) ^ (v663 >> 9)) & (v662 - 1);
          v665 = (uint64_t *)(v661 + 16 * v664);
          uint64_t v666 = *v665;
          if (v663 != *v665)
          {
            int v667 = 1;
            while (v666 != -4096)
            {
              int v668 = v664 + v667++;
              uint64_t v664 = v668 & (v662 - 1);
              uint64_t v666 = *(void *)(v661 + 16 * v664);
              if (v663 == v666)
              {
                v665 = (uint64_t *)(v661 + 16 * v664);
                goto LABEL_928;
              }
            }
LABEL_927:
            v665 = (uint64_t *)(v661 + 16 * v662);
          }
LABEL_928:
          if (v665 == (uint64_t *)(v661 + 16 * v662)) {
            uint64_t v675 = 0;
          }
          else {
            uint64_t v675 = v665[1];
          }
          uint64_t v676 = *(void *)(v659 + 40);
          if (!v662) {
            goto LABEL_937;
          }
          LODWORD(v677) = ((v676 >> 4) ^ (v676 >> 9)) & (v662 - 1);
          v678 = (uint64_t *)(v661 + 16 * v677);
          uint64_t v679 = *v678;
          if (v676 != *v678)
          {
            int v680 = 1;
            while (v679 != -4096)
            {
              int v681 = v677 + v680++;
              uint64_t v677 = v681 & (v662 - 1);
              uint64_t v679 = *(void *)(v661 + 16 * v677);
              if (v676 == v679)
              {
                v678 = (uint64_t *)(v661 + 16 * v677);
                goto LABEL_938;
              }
            }
LABEL_937:
            v678 = (uint64_t *)(v661 + 16 * v662);
          }
LABEL_938:
          if (v678 == (uint64_t *)(v661 + 16 * v662)) {
            uint64_t v682 = 0;
          }
          else {
            uint64_t v682 = v678[1];
          }
          if (v675 == v682)
          {
            int v683 = *(__int16 *)(v676 + 18);
            if ((v683 & 0x80000000) == 0)
            {
              uint64_t v690 = *(void *)(v676 + 48);
              if (v690 != v676 + 40)
              {
                int v691 = 0;
                do
                {
                  uint64_t v692 = v690 - 24;
                  if (!v690) {
                    uint64_t v692 = 0;
                  }
                  *(_DWORD *)(v692 + 56) = v691++;
                  uint64_t v690 = *(void *)(v690 + 8);
                }
                while (v690 != v676 + 40);
              }
              *(_WORD *)(v676 + 18) = v683 | 0x8000;
            }
            if (*(_DWORD *)(v659 + 56) >= *(_DWORD *)(v620 + 56)) {
              return result;
            }
          }
          else if (*(_DWORD *)(v675 + 72) >= *(_DWORD *)(v682 + 72))
          {
            return result;
          }
          *uint64_t v13 = v620;
          v13[1] = v659;
          return result;
        default:
          JUMPOUT(0);
      }
    }
    if (v14 <= 191) {
      break;
    }
    if (!a4)
    {
      if (v13 == a2) {
        return result;
      }
      int64_t v376 = (unint64_t)(v15 - 2) >> 1;
      int64_t v377 = v376;
      while (1)
      {
        int64_t v378 = v377;
        if (v376 >= v377)
        {
          uint64_t v379 = (2 * v377) | 1;
          uint64_t v380 = &v13[v379];
          uint64_t v381 = *(void *)a3;
          if (2 * v378 + 2 < v15)
          {
            uint64_t v382 = *v380;
            uint64_t v383 = *(void *)(v381 + 1960);
            uint64_t v391 = *(void *)(v383 + 24);
            uint64_t v392 = *(unsigned int *)(v383 + 40);
            if (v392)
            {
              uint64_t v384 = *(void *)(v382 + 40);
              LODWORD(v385) = ((v384 >> 4) ^ (v384 >> 9)) & (v392 - 1);
              BOOL v386 = (uint64_t *)(v391 + 16 * v385);
              uint64_t v387 = *v386;
              if (v384 != *v386)
              {
                int v388 = 1;
                do
                {
                  if (v387 == -4096) {
                    goto LABEL_507;
                  }
                  int v389 = v385 + v388++;
                  uint64_t v385 = v389 & (v392 - 1);
                  uint64_t v387 = *(void *)(v391 + 16 * v385);
                }
                while (v384 != v387);
                BOOL v386 = (uint64_t *)(v391 + 16 * v385);
              }
            }
            else
            {
LABEL_507:
              BOOL v386 = (uint64_t *)(v391 + 16 * v392);
            }
            if (v386 == (uint64_t *)(v391 + 16 * v392)) {
              uint64_t v393 = 0;
            }
            else {
              uint64_t v393 = v386[1];
            }
            uint64_t v395 = v380[1];
            ++v380;
            uint64_t v394 = v395;
            uint64_t v396 = *(void *)(v395 + 40);
            if (v392)
            {
              LODWORD(v397) = ((v396 >> 4) ^ (v396 >> 9)) & (v392 - 1);
              int v398 = (uint64_t *)(v391 + 16 * v397);
              uint64_t v399 = *v398;
              if (v396 != *v398)
              {
                int v400 = 1;
                do
                {
                  if (v399 == -4096) {
                    goto LABEL_517;
                  }
                  int v401 = v397 + v400++;
                  uint64_t v397 = v401 & (v392 - 1);
                  uint64_t v399 = *(void *)(v391 + 16 * v397);
                }
                while (v396 != v399);
                int v398 = (uint64_t *)(v391 + 16 * v397);
              }
            }
            else
            {
LABEL_517:
              int v398 = (uint64_t *)(v391 + 16 * v392);
            }
            if (v398 == (uint64_t *)(v391 + 16 * v392)) {
              uint64_t v402 = 0;
            }
            else {
              uint64_t v402 = v398[1];
            }
            if (v393 == v402)
            {
              int v405 = *(__int16 *)(v396 + 18);
              if ((v405 & 0x80000000) == 0)
              {
                uint64_t v475 = *(void *)(v396 + 48);
                if (v475 != v396 + 40)
                {
                  int v476 = 0;
                  do
                  {
                    uint64_t v477 = v475 - 24;
                    if (!v475) {
                      uint64_t v477 = 0;
                    }
                    *(_DWORD *)(v477 + 56) = v476++;
                    uint64_t v475 = *(void *)(v475 + 8);
                  }
                  while (v475 != v396 + 40);
                }
                *(_WORD *)(v396 + 18) = v405 | 0x8000;
              }
              v403 = (_DWORD *)(v394 + 56);
              v404 = (_DWORD *)(v382 + 56);
            }
            else
            {
              v403 = (_DWORD *)(v393 + 72);
              v404 = (_DWORD *)(v402 + 72);
            }
            if (*v403 < *v404) {
              uint64_t v379 = 2 * v378 + 2;
            }
            else {
              uint64_t v380 = &v13[v379];
            }
          }
          else
          {
            uint64_t v390 = *(void *)(v381 + 1960);
            uint64_t v391 = *(void *)(v390 + 24);
            LODWORD(v392) = *(_DWORD *)(v390 + 40);
          }
          uint64_t v406 = *v380;
          uint64_t v407 = v13[v378];
          if (v392)
          {
            uint64_t v408 = *(void *)(v406 + 40);
            LODWORD(v409) = ((v408 >> 4) ^ (v408 >> 9)) & (v392 - 1);
            __int16 v410 = (uint64_t *)(v391 + 16 * v409);
            uint64_t v411 = *v410;
            if (v408 != *v410)
            {
              int v412 = 1;
              do
              {
                if (v411 == -4096) {
                  goto LABEL_628;
                }
                int v413 = v409 + v412++;
                uint64_t v409 = v413 & (v392 - 1);
                uint64_t v411 = *(void *)(v391 + 16 * v409);
              }
              while (v408 != v411);
              __int16 v410 = (uint64_t *)(v391 + 16 * v409);
            }
            uint64_t v414 = v392;
          }
          else
          {
LABEL_628:
            uint64_t v414 = v392;
            __int16 v410 = (uint64_t *)(v391 + 16 * v392);
          }
          if (v410 == (uint64_t *)(v391 + 16 * v414)) {
            unint64_t result = 0;
          }
          else {
            unint64_t result = (uint64_t *)v410[1];
          }
          uint64_t v415 = *(void *)(v407 + 40);
          if (v392)
          {
            LODWORD(v416) = ((v415 >> 4) ^ (v415 >> 9)) & (v392 - 1);
            unint64_t v417 = (uint64_t *)(v391 + 16 * v416);
            uint64_t v418 = *v417;
            if (v415 != *v417)
            {
              int v419 = 1;
              do
              {
                if (v418 == -4096) {
                  goto LABEL_629;
                }
                int v420 = v416 + v419++;
                uint64_t v416 = v420 & (v392 - 1);
                uint64_t v418 = *(void *)(v391 + 16 * v416);
              }
              while (v415 != v418);
              unint64_t v417 = (uint64_t *)(v391 + 16 * v416);
            }
            uint64_t v421 = v392;
          }
          else
          {
LABEL_629:
            uint64_t v421 = v392;
            unint64_t v417 = (uint64_t *)(v391 + 16 * v392);
          }
          if (v417 == (uint64_t *)(v391 + 16 * v421)) {
            uint64_t v422 = 0;
          }
          else {
            uint64_t v422 = v417[1];
          }
          if (result == (uint64_t *)v422)
          {
            int v423 = *(__int16 *)(v415 + 18);
            if ((v423 & 0x80000000) == 0)
            {
              unint64_t result = *(uint64_t **)(v415 + 48);
              if (result != (uint64_t *)(v415 + 40))
              {
                int v473 = 0;
                do
                {
                  uint64_t v474 = result - 3;
                  if (!result) {
                    uint64_t v474 = 0;
                  }
                  *((_DWORD *)v474 + 14) = v473++;
                  unint64_t result = (uint64_t *)result[1];
                }
                while (result != (uint64_t *)(v415 + 40));
              }
              *(_WORD *)(v415 + 18) = v423 | 0x8000;
            }
            if (*(_DWORD *)(v407 + 56) >= *(_DWORD *)(v406 + 56))
            {
LABEL_553:
              v13[v378] = v406;
              if (v376 >= v379)
              {
                while (1)
                {
                  uint64_t v425 = (2 * v379) | 1;
                  uint64_t v424 = &v13[v425];
                  uint64_t v379 = 2 * v379 + 2;
                  uint64_t v426 = *(void *)a3;
                  if (v379 < v15)
                  {
                    uint64_t v427 = *v424;
                    uint64_t v428 = *(void *)(v426 + 1960);
                    uint64_t v436 = *(void *)(v428 + 24);
                    uint64_t v437 = *(unsigned int *)(v428 + 40);
                    if (v437)
                    {
                      uint64_t v429 = *(void *)(v427 + 40);
                      LODWORD(v430) = ((v429 >> 4) ^ (v429 >> 9)) & (v437 - 1);
                      uint64_t v431 = (uint64_t *)(v436 + 16 * v430);
                      uint64_t v432 = *v431;
                      if (v429 != *v431)
                      {
                        int v433 = 1;
                        do
                        {
                          if (v432 == -4096) {
                            goto LABEL_566;
                          }
                          int v434 = v430 + v433++;
                          uint64_t v430 = v434 & (v437 - 1);
                          uint64_t v432 = *(void *)(v436 + 16 * v430);
                        }
                        while (v429 != v432);
                        uint64_t v431 = (uint64_t *)(v436 + 16 * v430);
                      }
                    }
                    else
                    {
LABEL_566:
                      uint64_t v431 = (uint64_t *)(v436 + 16 * v437);
                    }
                    if (v431 == (uint64_t *)(v436 + 16 * v437)) {
                      uint64_t v438 = 0;
                    }
                    else {
                      uint64_t v438 = v431[1];
                    }
                    uint64_t v439 = v424[1];
                    uint64_t v440 = *(void *)(v439 + 40);
                    if (v437)
                    {
                      LODWORD(v441) = ((v440 >> 4) ^ (v440 >> 9)) & (v437 - 1);
                      uint64_t v442 = (uint64_t *)(v436 + 16 * v441);
                      uint64_t v443 = *v442;
                      if (v440 != *v442)
                      {
                        int v444 = 1;
                        do
                        {
                          if (v443 == -4096) {
                            goto LABEL_576;
                          }
                          int v445 = v441 + v444++;
                          uint64_t v441 = v445 & (v437 - 1);
                          uint64_t v443 = *(void *)(v436 + 16 * v441);
                        }
                        while (v440 != v443);
                        uint64_t v442 = (uint64_t *)(v436 + 16 * v441);
                      }
                    }
                    else
                    {
LABEL_576:
                      uint64_t v442 = (uint64_t *)(v436 + 16 * v437);
                    }
                    if (v442 == (uint64_t *)(v436 + 16 * v437)) {
                      uint64_t v446 = 0;
                    }
                    else {
                      uint64_t v446 = v442[1];
                    }
                    if (v438 == v446)
                    {
                      int v449 = *(__int16 *)(v440 + 18);
                      if ((v449 & 0x80000000) == 0)
                      {
                        uint64_t v470 = *(void *)(v440 + 48);
                        if (v470 != v440 + 40)
                        {
                          int v471 = 0;
                          do
                          {
                            uint64_t v472 = v470 - 24;
                            if (!v470) {
                              uint64_t v472 = 0;
                            }
                            *(_DWORD *)(v472 + 56) = v471++;
                            uint64_t v470 = *(void *)(v470 + 8);
                          }
                          while (v470 != v440 + 40);
                        }
                        *(_WORD *)(v440 + 18) = v449 | 0x8000;
                      }
                      uint64_t v447 = (_DWORD *)(v439 + 56);
                      uint64_t v448 = (_DWORD *)(v427 + 56);
                    }
                    else
                    {
                      uint64_t v447 = (_DWORD *)(v438 + 72);
                      uint64_t v448 = (_DWORD *)(v446 + 72);
                    }
                    if (*v447 >= *v448) {
                      uint64_t v379 = v425;
                    }
                    else {
                      ++v424;
                    }
                  }
                  else
                  {
                    uint64_t v435 = *(void *)(v426 + 1960);
                    uint64_t v436 = *(void *)(v435 + 24);
                    LODWORD(v437) = *(_DWORD *)(v435 + 40);
                    uint64_t v379 = v425;
                  }
                  uint64_t v450 = *v424;
                  if (v437)
                  {
                    uint64_t v451 = *(void *)(v450 + 40);
                    LODWORD(v452) = ((v451 >> 4) ^ (v451 >> 9)) & (v437 - 1);
                    uint64_t v453 = (uint64_t *)(v436 + 16 * v452);
                    uint64_t v454 = *v453;
                    if (v451 != *v453)
                    {
                      int v455 = 1;
                      do
                      {
                        if (v454 == -4096) {
                          goto LABEL_614;
                        }
                        int v456 = v452 + v455++;
                        uint64_t v452 = v456 & (v437 - 1);
                        uint64_t v454 = *(void *)(v436 + 16 * v452);
                      }
                      while (v451 != v454);
                      uint64_t v453 = (uint64_t *)(v436 + 16 * v452);
                    }
                    uint64_t v457 = v437;
                  }
                  else
                  {
LABEL_614:
                    uint64_t v457 = v437;
                    uint64_t v453 = (uint64_t *)(v436 + 16 * v437);
                  }
                  if (v453 == (uint64_t *)(v436 + 16 * v457)) {
                    uint64_t v458 = 0;
                  }
                  else {
                    uint64_t v458 = v453[1];
                  }
                  unint64_t result = *(uint64_t **)(v407 + 40);
                  if (v437)
                  {
                    LODWORD(v459) = ((result >> 4) ^ (result >> 9)) & (v437 - 1);
                    uint64_t v460 = (uint64_t **)(v436 + 16 * v459);
                    uint64_t v461 = *v460;
                    if (result != *v460)
                    {
                      int v462 = 1;
                      do
                      {
                        if (v461 == (uint64_t *)-4096) {
                          goto LABEL_615;
                        }
                        int v463 = v459 + v462++;
                        uint64_t v459 = v463 & (v437 - 1);
                        uint64_t v461 = *(uint64_t **)(v436 + 16 * v459);
                      }
                      while (result != v461);
                      uint64_t v460 = (uint64_t **)(v436 + 16 * v459);
                    }
                    uint64_t v464 = v437;
                  }
                  else
                  {
LABEL_615:
                    uint64_t v464 = v437;
                    uint64_t v460 = (uint64_t **)(v436 + 16 * v437);
                  }
                  if (v460 == (uint64_t **)(v436 + 16 * v464)) {
                    uint64_t v465 = 0;
                  }
                  else {
                    uint64_t v465 = v460[1];
                  }
                  if ((uint64_t *)v458 == v465)
                  {
                    int v466 = *((__int16 *)result + 9);
                    if ((v466 & 0x80000000) == 0)
                    {
                      uint64_t v467 = (uint64_t *)result[6];
                      if (v467 != result + 5)
                      {
                        int v468 = 0;
                        do
                        {
                          uint64_t v469 = v467 - 3;
                          if (!v467) {
                            uint64_t v469 = 0;
                          }
                          *((_DWORD *)v469 + 14) = v468++;
                          uint64_t v467 = (uint64_t *)v467[1];
                        }
                        while (v467 != result + 5);
                      }
                      *((_WORD *)result + 9) = v466 | 0x8000;
                    }
                    if (*(_DWORD *)(v407 + 56) < *(_DWORD *)(v450 + 56)) {
                      break;
                    }
                  }
                  else if (*(_DWORD *)(v458 + 72) < *((_DWORD *)v465 + 18))
                  {
                    break;
                  }
                  *uint64_t v380 = v450;
                  uint64_t v380 = v424;
                  if (v376 < v379) {
                    goto LABEL_555;
                  }
                }
              }
              uint64_t v424 = v380;
LABEL_555:
              *uint64_t v424 = v407;
            }
          }
          else if (*((_DWORD *)result + 18) >= *(_DWORD *)(v422 + 72))
          {
            goto LABEL_553;
          }
        }
        int64_t v377 = v378 - 1;
        if (!v378)
        {
          while (1)
          {
            uint64_t v504 = 0;
            uint64_t v505 = *v13;
            uint64_t v506 = v13;
            do
            {
              int v507 = &v506[v504 + 1];
              uint64_t v508 = (2 * v504) | 1;
              uint64_t v509 = 2 * v504 + 2;
              if (v509 >= v15) {
                goto LABEL_709;
              }
              uint64_t v510 = *v507;
              uint64_t v511 = *(void *)(*(void *)a3 + 1960);
              uint64_t v512 = *(void *)(v511 + 24);
              uint64_t v513 = *(unsigned int *)(v511 + 40);
              if (v513)
              {
                uint64_t v514 = *(void *)(v510 + 40);
                LODWORD(v515) = ((v514 >> 4) ^ (v514 >> 9)) & (v513 - 1);
                uint64_t v516 = (uint64_t *)(v512 + 16 * v515);
                uint64_t v517 = *v516;
                if (v514 == *v516) {
                  goto LABEL_690;
                }
                int v518 = 1;
                while (v517 != -4096)
                {
                  int v519 = v515 + v518++;
                  uint64_t v515 = v519 & (v513 - 1);
                  uint64_t v517 = *(void *)(v512 + 16 * v515);
                  if (v514 == v517)
                  {
                    uint64_t v516 = (uint64_t *)(v512 + 16 * v515);
                    goto LABEL_690;
                  }
                }
              }
              uint64_t v516 = (uint64_t *)(v512 + 16 * v513);
LABEL_690:
              if (v516 == (uint64_t *)(v512 + 16 * v513)) {
                uint64_t v520 = 0;
              }
              else {
                uint64_t v520 = v516[1];
              }
              unint64_t result = v507 + 1;
              uint64_t v521 = v507[1];
              uint64_t v522 = *(void *)(v521 + 40);
              if (!v513) {
                goto LABEL_699;
              }
              LODWORD(v523) = ((v522 >> 4) ^ (v522 >> 9)) & (v513 - 1);
              uint64_t v524 = (uint64_t *)(v512 + 16 * v523);
              uint64_t v525 = *v524;
              if (v522 != *v524)
              {
                int v526 = 1;
                while (v525 != -4096)
                {
                  int v527 = v523 + v526++;
                  uint64_t v523 = v527 & (v513 - 1);
                  uint64_t v525 = *(void *)(v512 + 16 * v523);
                  if (v522 == v525)
                  {
                    uint64_t v524 = (uint64_t *)(v512 + 16 * v523);
                    goto LABEL_700;
                  }
                }
LABEL_699:
                uint64_t v524 = (uint64_t *)(v512 + 16 * v513);
              }
LABEL_700:
              if (v524 == (uint64_t *)(v512 + 16 * v513)) {
                uint64_t v528 = 0;
              }
              else {
                uint64_t v528 = v524[1];
              }
              if (v520 == v528)
              {
                int v531 = *(__int16 *)(v522 + 18);
                if ((v531 & 0x80000000) == 0)
                {
                  uint64_t v532 = *(void *)(v522 + 48);
                  if (v532 != v522 + 40)
                  {
                    int v533 = 0;
                    do
                    {
                      uint64_t v534 = v532 - 24;
                      if (!v532) {
                        uint64_t v534 = 0;
                      }
                      *(_DWORD *)(v534 + 56) = v533++;
                      uint64_t v532 = *(void *)(v532 + 8);
                    }
                    while (v532 != v522 + 40);
                  }
                  *(_WORD *)(v522 + 18) = v531 | 0x8000;
                }
                uint64_t v529 = (_DWORD *)(v521 + 56);
                uint64_t v530 = (_DWORD *)(v510 + 56);
              }
              else
              {
                uint64_t v529 = (_DWORD *)(v520 + 72);
                uint64_t v530 = (_DWORD *)(v528 + 72);
              }
              if (*v529 < *v530)
              {
                ++v507;
                uint64_t v508 = v509;
              }
LABEL_709:
              *uint64_t v506 = *v507;
              uint64_t v506 = v507;
              uint64_t v504 = v508;
            }
            while (v508 <= (uint64_t)((unint64_t)(v15 - 2) >> 1));
            if (v507 == --a2)
            {
              *int v507 = v505;
              goto LABEL_748;
            }
            *int v507 = *a2;
            *a2 = v505;
            uint64_t v535 = (char *)v507 - (char *)v13 + 8;
            if (v535 >= 9)
            {
              unint64_t v536 = ((unint64_t)v535 >> 3) - 2;
              unint64_t v479 = v536 >> 1;
              int64_t v499 = &v13[v536 >> 1];
              uint64_t v537 = *v499;
              uint64_t v538 = *(void *)(*(void *)a3 + 1960);
              uint64_t v539 = *(void *)(v538 + 24);
              uint64_t v540 = *(unsigned int *)(v538 + 40);
              if (!v540) {
                goto LABEL_726;
              }
              uint64_t v541 = *(void *)(v537 + 40);
              LODWORD(v542) = ((v541 >> 4) ^ (v541 >> 9)) & (v540 - 1);
              uint64_t v543 = (uint64_t *)(v539 + 16 * v542);
              uint64_t v544 = *v543;
              if (v541 != *v543)
              {
                int v545 = 1;
                while (v544 != -4096)
                {
                  int v546 = v542 + v545++;
                  uint64_t v542 = v546 & (v540 - 1);
                  uint64_t v544 = *(void *)(v539 + 16 * v542);
                  if (v541 == v544)
                  {
                    uint64_t v543 = (uint64_t *)(v539 + 16 * v542);
                    goto LABEL_727;
                  }
                }
LABEL_726:
                uint64_t v543 = (uint64_t *)(v539 + 16 * v540);
              }
LABEL_727:
              if (v543 == (uint64_t *)(v539 + 16 * v540)) {
                unint64_t result = 0;
              }
              else {
                unint64_t result = (uint64_t *)v543[1];
              }
              uint64_t v547 = *v507;
              uint64_t v548 = *(void *)(*v507 + 40);
              if (v540)
              {
                LODWORD(v549) = ((v548 >> 4) ^ (v548 >> 9)) & (v540 - 1);
                uint64_t v550 = (uint64_t *)(v539 + 16 * v549);
                uint64_t v551 = *v550;
                if (v548 != *v550)
                {
                  int v552 = 1;
                  while (v551 != -4096)
                  {
                    int v553 = v549 + v552++;
                    uint64_t v549 = v553 & (v540 - 1);
                    uint64_t v551 = *(void *)(v539 + 16 * v549);
                    if (v548 == v551)
                    {
                      uint64_t v550 = (uint64_t *)(v539 + 16 * v549);
                      goto LABEL_737;
                    }
                  }
                  goto LABEL_736;
                }
              }
              else
              {
LABEL_736:
                uint64_t v550 = (uint64_t *)(v539 + 16 * v540);
              }
LABEL_737:
              if (v550 == (uint64_t *)(v539 + 16 * v540)) {
                uint64_t v554 = 0;
              }
              else {
                uint64_t v554 = v550[1];
              }
              if (result != (uint64_t *)v554)
              {
                if (*((_DWORD *)result + 18) >= *(_DWORD *)(v554 + 72)) {
                  goto LABEL_748;
                }
LABEL_745:
                *int v507 = v537;
                if (v536 < 2)
                {
LABEL_746:
                  uint64_t v480 = v499;
LABEL_747:
                  *uint64_t v480 = v547;
                  goto LABEL_748;
                }
                while (2)
                {
                  unint64_t v478 = v479 - 1;
                  unint64_t v479 = (v479 - 1) >> 1;
                  uint64_t v480 = &v13[v479];
                  uint64_t v481 = *v480;
                  uint64_t v482 = *(void *)(*(void *)a3 + 1960);
                  uint64_t v483 = *(void *)(v482 + 24);
                  uint64_t v484 = *(unsigned int *)(v482 + 40);
                  if (v484)
                  {
                    uint64_t v485 = *(void *)(v481 + 40);
                    LODWORD(v486) = ((v485 >> 4) ^ (v485 >> 9)) & (v484 - 1);
                    uint64_t v487 = (uint64_t *)(v483 + 16 * v486);
                    uint64_t v488 = *v487;
                    if (v485 != *v487)
                    {
                      int v489 = 1;
                      while (v488 != -4096)
                      {
                        int v490 = v486 + v489++;
                        uint64_t v486 = v490 & (v484 - 1);
                        uint64_t v488 = *(void *)(v483 + 16 * v486);
                        if (v485 == v488)
                        {
                          uint64_t v487 = (uint64_t *)(v483 + 16 * v486);
                          goto LABEL_649;
                        }
                      }
                      goto LABEL_648;
                    }
                  }
                  else
                  {
LABEL_648:
                    uint64_t v487 = (uint64_t *)(v483 + 16 * v484);
                  }
LABEL_649:
                  if (v487 == (uint64_t *)(v483 + 16 * v484)) {
                    unint64_t result = 0;
                  }
                  else {
                    unint64_t result = (uint64_t *)v487[1];
                  }
                  uint64_t v491 = *(void *)(v547 + 40);
                  if (v484)
                  {
                    LODWORD(v492) = ((v491 >> 4) ^ (v491 >> 9)) & (v484 - 1);
                    uint64_t v493 = (uint64_t *)(v483 + 16 * v492);
                    uint64_t v494 = *v493;
                    if (v491 != *v493)
                    {
                      int v495 = 1;
                      while (v494 != -4096)
                      {
                        int v496 = v492 + v495++;
                        uint64_t v492 = v496 & (v484 - 1);
                        uint64_t v494 = *(void *)(v483 + 16 * v492);
                        if (v491 == v494)
                        {
                          uint64_t v493 = (uint64_t *)(v483 + 16 * v492);
                          goto LABEL_659;
                        }
                      }
                      goto LABEL_658;
                    }
                  }
                  else
                  {
LABEL_658:
                    uint64_t v493 = (uint64_t *)(v483 + 16 * v484);
                  }
LABEL_659:
                  if (v493 == (uint64_t *)(v483 + 16 * v484)) {
                    uint64_t v497 = 0;
                  }
                  else {
                    uint64_t v497 = v493[1];
                  }
                  if (result == (uint64_t *)v497)
                  {
                    int v498 = *(__int16 *)(v491 + 18);
                    if ((v498 & 0x80000000) == 0)
                    {
                      unint64_t result = *(uint64_t **)(v491 + 48);
                      if (result != (uint64_t *)(v491 + 40))
                      {
                        int v500 = 0;
                        do
                        {
                          uint64_t v501 = result - 3;
                          if (!result) {
                            uint64_t v501 = 0;
                          }
                          *((_DWORD *)v501 + 14) = v500++;
                          unint64_t result = (uint64_t *)result[1];
                        }
                        while (result != (uint64_t *)(v491 + 40));
                      }
                      *(_WORD *)(v491 + 18) = v498 | 0x8000;
                    }
                    if (*(_DWORD *)(v547 + 56) >= *(_DWORD *)(v481 + 56)) {
                      goto LABEL_746;
                    }
                  }
                  else if (*((_DWORD *)result + 18) >= *(_DWORD *)(v497 + 72))
                  {
                    goto LABEL_746;
                  }
                  *int64_t v499 = v481;
                  int64_t v499 = &v13[v479];
                  if (v478 <= 1) {
                    goto LABEL_747;
                  }
                  continue;
                }
              }
              int v555 = *(__int16 *)(v548 + 18);
              if ((v555 & 0x80000000) == 0)
              {
                unint64_t result = *(uint64_t **)(v548 + 48);
                if (result != (uint64_t *)(v548 + 40))
                {
                  int v502 = 0;
                  do
                  {
                    uint64_t v503 = result - 3;
                    if (!result) {
                      uint64_t v503 = 0;
                    }
                    *((_DWORD *)v503 + 14) = v502++;
                    unint64_t result = (uint64_t *)result[1];
                  }
                  while (result != (uint64_t *)(v548 + 40));
                }
                *(_WORD *)(v548 + 18) = v555 | 0x8000;
              }
              if (*(_DWORD *)(v547 + 56) < *(_DWORD *)(v537 + 56)) {
                goto LABEL_745;
              }
            }
LABEL_748:
            if (v15-- <= 2) {
              return result;
            }
          }
        }
      }
    }
    unint64_t v16 = (unint64_t)v15 >> 1;
    uint64_t v17 = &v13[(unint64_t)v15 >> 1];
    if ((unint64_t)v14 >= 0x401)
    {
      sub_1CD3471D4(v11, &v11[(unint64_t)v15 >> 1], a2 - 1, a3);
      sub_1CD3471D4(v11 + 1, v17 - 1, a2 - 2, a3);
      sub_1CD3471D4(v11 + 2, &v11[v16 + 1], a2 - 3, a3);
      sub_1CD3471D4(v17 - 1, v17, &v11[v16 + 1], a3);
      uint64_t v18 = *v11;
      uint64_t *v11 = *v17;
      uint64_t *v17 = v18;
    }
    else
    {
      sub_1CD3471D4(&v11[(unint64_t)v15 >> 1], v11, a2 - 1, a3);
    }
    --a4;
    uint64_t v19 = *v11;
    uint64_t v20 = *(void *)a3;
    if (a5)
    {
      uint64_t v22 = *(void *)(v20 + 1960);
      uint64_t v21 = *(void *)(v22 + 24);
      LODWORD(v22) = *(_DWORD *)(v22 + 40);
      uint64_t v23 = *(void *)(v19 + 40);
LABEL_34:
      unsigned int v39 = v22 - 1;
      uint64_t v40 = (uint64_t *)(v21 + 16 * v22);
      unsigned int v41 = ((v23 >> 4) ^ (v23 >> 9)) & (v22 - 1);
      unsigned int v42 = (uint64_t *)(v21 + 16 * v41);
      uint64_t v43 = v23 + 40;
      uint64_t v44 = v11;
      do
      {
        uint64_t v45 = v44;
        uint64_t v47 = v44[1];
        ++v44;
        uint64_t v46 = v47;
        if (!v22) {
          goto LABEL_54;
        }
        uint64_t v48 = *(void *)(v46 + 40);
        LODWORD(v49) = ((v48 >> 4) ^ (v48 >> 9)) & v39;
        uint64_t v50 = (uint64_t *)(v21 + 16 * v49);
        uint64_t v51 = *v50;
        if (v48 == *v50)
        {
LABEL_41:
          if (v50 != v40)
          {
            uint64_t v54 = v50[1];
            goto LABEL_44;
          }
        }
        else
        {
          int v52 = 1;
          while (v51 != -4096)
          {
            int v53 = v49 + v52++;
            uint64_t v49 = v53 & v39;
            uint64_t v51 = *(void *)(v21 + 16 * v49);
            if (v48 == v51)
            {
              uint64_t v50 = (uint64_t *)(v21 + 16 * v49);
              goto LABEL_41;
            }
          }
        }
        uint64_t v54 = 0;
LABEL_44:
        uint64_t v55 = *v42;
        __int16 v56 = (uint64_t *)(v21 + 16 * v41);
        if (v23 == *v42)
        {
LABEL_49:
          if (v56 != v40)
          {
            uint64_t v60 = v56[1];
            goto LABEL_52;
          }
        }
        else
        {
          int v57 = 1;
          LODWORD(v58) = ((v23 >> 4) ^ (v23 >> 9)) & v39;
          while (v55 != -4096)
          {
            int v59 = v58 + v57++;
            uint64_t v58 = v59 & v39;
            uint64_t v55 = *(void *)(v21 + 16 * v58);
            if (v23 == v55)
            {
              __int16 v56 = (uint64_t *)(v21 + 16 * v58);
              goto LABEL_49;
            }
          }
        }
        uint64_t v60 = 0;
LABEL_52:
        if (v54 != v60)
        {
          unsigned int v61 = *(_DWORD *)(v54 + 72);
          unsigned int v62 = *(_DWORD *)(v60 + 72);
          continue;
        }
LABEL_54:
        int v63 = *(__int16 *)(v23 + 18);
        if ((v63 & 0x80000000) == 0)
        {
          uint64_t v64 = *(void *)(v23 + 48);
          if (v64 != v43)
          {
            int v65 = 0;
            do
            {
              uint64_t v66 = v64 - 24;
              if (!v64) {
                uint64_t v66 = 0;
              }
              *(_DWORD *)(v66 + 56) = v65++;
              uint64_t v64 = *(void *)(v64 + 8);
            }
            while (v64 != v43);
          }
          *(_WORD *)(v23 + 18) = v63 | 0x8000;
        }
        unsigned int v61 = *(_DWORD *)(v19 + 56);
        unsigned int v62 = *(_DWORD *)(v46 + 56);
      }
      while (v61 < v62);
      uint64_t v67 = a2;
      if (v45 != v11)
      {
        while (2)
        {
          while (1)
          {
            uint64_t v69 = *--v67;
            uint64_t v68 = v69;
            if (v22) {
              break;
            }
LABEL_85:
            int v83 = *(__int16 *)(v23 + 18);
            if ((v83 & 0x80000000) == 0)
            {
              uint64_t v84 = *(void *)(v23 + 48);
              if (v84 != v43)
              {
                int v85 = 0;
                do
                {
                  uint64_t v86 = v84 - 24;
                  if (!v84) {
                    uint64_t v86 = 0;
                  }
                  *(_DWORD *)(v86 + 56) = v85++;
                  uint64_t v84 = *(void *)(v84 + 8);
                }
                while (v84 != v43);
              }
              *(_WORD *)(v23 + 18) = v83 | 0x8000;
            }
            if (*(_DWORD *)(v19 + 56) < *(_DWORD *)(v68 + 56)) {
              goto LABEL_127;
            }
          }
          uint64_t v70 = *(void *)(v68 + 40);
          LODWORD(v71) = ((v70 >> 4) ^ (v70 >> 9)) & v39;
          uint64_t v72 = (uint64_t *)(v21 + 16 * v71);
          uint64_t v73 = *v72;
          if (v70 == *v72)
          {
LABEL_71:
            if (v72 == v40) {
              goto LABEL_73;
            }
            uint64_t v76 = v72[1];
          }
          else
          {
            int v74 = 1;
            while (v73 != -4096)
            {
              int v75 = v71 + v74++;
              uint64_t v71 = v75 & v39;
              uint64_t v73 = *(void *)(v21 + 16 * v71);
              if (v70 == v73)
              {
                uint64_t v72 = (uint64_t *)(v21 + 16 * v71);
                goto LABEL_71;
              }
            }
LABEL_73:
            uint64_t v76 = 0;
          }
          uint64_t v77 = *v42;
          BOOL v78 = (uint64_t *)(v21 + 16 * v41);
          if (v23 == *v42)
          {
LABEL_79:
            if (v78 == v40) {
              goto LABEL_81;
            }
            uint64_t v82 = v78[1];
          }
          else
          {
            int v79 = 1;
            LODWORD(v80) = ((v23 >> 4) ^ (v23 >> 9)) & v39;
            while (v77 != -4096)
            {
              int v81 = v80 + v79++;
              uint64_t v80 = v81 & v39;
              uint64_t v77 = *(void *)(v21 + 16 * v80);
              if (v23 == v77)
              {
                BOOL v78 = (uint64_t *)(v21 + 16 * v80);
                goto LABEL_79;
              }
            }
LABEL_81:
            uint64_t v82 = 0;
          }
          if (v76 == v82) {
            goto LABEL_85;
          }
          if (*(_DWORD *)(v76 + 72) < *(_DWORD *)(v82 + 72)) {
            goto LABEL_127;
          }
          continue;
        }
      }
      uint64_t v67 = a2;
      if (v44 < a2)
      {
        uint64_t v67 = a2;
        while (2)
        {
          while (1)
          {
            uint64_t v88 = *--v67;
            uint64_t v87 = v88;
            if (v22) {
              break;
            }
LABEL_117:
            int v102 = *(__int16 *)(v23 + 18);
            if ((v102 & 0x80000000) == 0)
            {
              uint64_t v103 = *(void *)(v23 + 48);
              if (v103 != v43)
              {
                int v104 = 0;
                do
                {
                  uint64_t v105 = v103 - 24;
                  if (!v103) {
                    uint64_t v105 = 0;
                  }
                  *(_DWORD *)(v105 + 56) = v104++;
                  uint64_t v103 = *(void *)(v103 + 8);
                }
                while (v103 != v43);
              }
              *(_WORD *)(v23 + 18) = v102 | 0x8000;
            }
            if (v44 >= v67 || *(_DWORD *)(v19 + 56) < *(_DWORD *)(v87 + 56)) {
              goto LABEL_127;
            }
          }
          uint64_t v89 = *(void *)(v87 + 40);
          LODWORD(v90) = ((v89 >> 4) ^ (v89 >> 9)) & v39;
          unsigned int v91 = (uint64_t *)(v21 + 16 * v90);
          uint64_t v92 = *v91;
          if (v89 == *v91)
          {
LABEL_102:
            if (v91 == v40) {
              goto LABEL_104;
            }
            uint64_t v95 = v91[1];
          }
          else
          {
            int v93 = 1;
            while (v92 != -4096)
            {
              int v94 = v90 + v93++;
              uint64_t v90 = v94 & v39;
              uint64_t v92 = *(void *)(v21 + 16 * v90);
              if (v89 == v92)
              {
                unsigned int v91 = (uint64_t *)(v21 + 16 * v90);
                goto LABEL_102;
              }
            }
LABEL_104:
            uint64_t v95 = 0;
          }
          uint64_t v96 = *v42;
          BOOL v97 = (uint64_t *)(v21 + 16 * v41);
          if (v23 == *v42)
          {
LABEL_110:
            if (v97 == v40) {
              goto LABEL_112;
            }
            uint64_t v101 = v97[1];
          }
          else
          {
            int v98 = 1;
            LODWORD(v99) = ((v23 >> 4) ^ (v23 >> 9)) & v39;
            while (v96 != -4096)
            {
              int v100 = v99 + v98++;
              uint64_t v99 = v100 & v39;
              uint64_t v96 = *(void *)(v21 + 16 * v99);
              if (v23 == v96)
              {
                BOOL v97 = (uint64_t *)(v21 + 16 * v99);
                goto LABEL_110;
              }
            }
LABEL_112:
            uint64_t v101 = 0;
          }
          if (v95 == v101) {
            goto LABEL_117;
          }
          if (v44 >= v67 || *(_DWORD *)(v95 + 72) < *(_DWORD *)(v101 + 72)) {
            break;
          }
          continue;
        }
      }
LABEL_127:
      if (v44 >= v67)
      {
        uint64_t v13 = v44;
        goto LABEL_190;
      }
      uint64_t v106 = *v67;
      uint64_t v13 = v44;
      unsigned int v107 = v67;
      while (2)
      {
        *uint64_t v13 = v106;
        uint64_t *v107 = v46;
        uint64_t v108 = *(void *)(*(void *)a3 + 1960);
        uint64_t v109 = *(void *)(v108 + 24);
        uint64_t v110 = *(unsigned int *)(v108 + 40);
        uint64_t v111 = *(void *)(v19 + 40);
        unsigned int v112 = v110 - 1;
        int v113 = (uint64_t *)(v109 + 16 * v110);
        unsigned int v114 = ((v111 >> 4) ^ (v111 >> 9)) & (v110 - 1);
        uint64_t v115 = (uint64_t *)(v109 + 16 * v114);
        uint64_t v116 = v111 + 40;
        while (2)
        {
          uint64_t v117 = v13[1];
          ++v13;
          uint64_t v46 = v117;
          if (!v110) {
            goto LABEL_149;
          }
          uint64_t v118 = *(void *)(v46 + 40);
          LODWORD(v119) = ((v118 >> 4) ^ (v118 >> 9)) & v112;
          int v120 = (uint64_t *)(v109 + 16 * v119);
          uint64_t v121 = *v120;
          if (v118 == *v120)
          {
LABEL_136:
            if (v120 == v113) {
              goto LABEL_138;
            }
            uint64_t v124 = v120[1];
          }
          else
          {
            int v122 = 1;
            while (v121 != -4096)
            {
              int v123 = v119 + v122++;
              uint64_t v119 = v123 & v112;
              uint64_t v121 = *(void *)(v109 + 16 * v119);
              if (v118 == v121)
              {
                int v120 = (uint64_t *)(v109 + 16 * v119);
                goto LABEL_136;
              }
            }
LABEL_138:
            uint64_t v124 = 0;
          }
          uint64_t v125 = *v115;
          uint64_t v126 = (uint64_t *)(v109 + 16 * v114);
          if (v111 == *v115)
          {
LABEL_144:
            if (v126 == v113) {
              goto LABEL_146;
            }
            uint64_t v130 = v126[1];
          }
          else
          {
            int v127 = 1;
            LODWORD(v128) = ((v111 >> 4) ^ (v111 >> 9)) & (v110 - 1);
            while (v125 != -4096)
            {
              int v129 = v128 + v127++;
              uint64_t v128 = v129 & v112;
              uint64_t v125 = *(void *)(v109 + 16 * v128);
              if (v111 == v125)
              {
                uint64_t v126 = (uint64_t *)(v109 + 16 * v128);
                goto LABEL_144;
              }
            }
LABEL_146:
            uint64_t v130 = 0;
          }
          if (v124 == v130)
          {
LABEL_149:
            int v133 = *(__int16 *)(v111 + 18);
            if ((v133 & 0x80000000) == 0)
            {
              uint64_t v134 = *(void *)(v111 + 48);
              if (v134 != v116)
              {
                int v135 = 0;
                do
                {
                  uint64_t v136 = v134 - 24;
                  if (!v134) {
                    uint64_t v136 = 0;
                  }
                  *(_DWORD *)(v136 + 56) = v135++;
                  uint64_t v134 = *(void *)(v134 + 8);
                }
                while (v134 != v116);
              }
              *(_WORD *)(v111 + 18) = v133 | 0x8000;
            }
            unsigned int v131 = *(_DWORD *)(v19 + 56);
            unsigned int v132 = *(_DWORD *)(v46 + 56);
          }
          else
          {
            unsigned int v131 = *(_DWORD *)(v124 + 72);
            unsigned int v132 = *(_DWORD *)(v130 + 72);
          }
          if (v131 < v132) {
            continue;
          }
          break;
        }
        while (2)
        {
          uint64_t v140 = *--v107;
          uint64_t v106 = v140;
          if (!v110) {
            goto LABEL_184;
          }
          uint64_t v141 = *(void *)(v106 + 40);
          LODWORD(v142) = ((v141 >> 4) ^ (v141 >> 9)) & v112;
          uint64_t v143 = (uint64_t *)(v109 + 16 * v142);
          uint64_t v144 = *v143;
          if (v141 == *v143)
          {
LABEL_171:
            if (v143 == v113) {
              goto LABEL_173;
            }
            uint64_t v147 = v143[1];
          }
          else
          {
            int v145 = 1;
            while (v144 != -4096)
            {
              int v146 = v142 + v145++;
              uint64_t v142 = v146 & v112;
              uint64_t v144 = *(void *)(v109 + 16 * v142);
              if (v141 == v144)
              {
                uint64_t v143 = (uint64_t *)(v109 + 16 * v142);
                goto LABEL_171;
              }
            }
LABEL_173:
            uint64_t v147 = 0;
          }
          uint64_t v148 = *v115;
          BOOL v149 = (uint64_t *)(v109 + 16 * v114);
          if (v111 == *v115)
          {
LABEL_179:
            if (v149 == v113) {
              goto LABEL_181;
            }
            uint64_t v153 = v149[1];
          }
          else
          {
            int v150 = 1;
            LODWORD(v151) = ((v111 >> 4) ^ (v111 >> 9)) & (v110 - 1);
            while (v148 != -4096)
            {
              int v152 = v151 + v150++;
              uint64_t v151 = v152 & v112;
              uint64_t v148 = *(void *)(v109 + 16 * v151);
              if (v111 == v148)
              {
                BOOL v149 = (uint64_t *)(v109 + 16 * v151);
                goto LABEL_179;
              }
            }
LABEL_181:
            uint64_t v153 = 0;
          }
          if (v147 == v153)
          {
LABEL_184:
            int v156 = *(__int16 *)(v111 + 18);
            if ((v156 & 0x80000000) == 0)
            {
              uint64_t v137 = *(void *)(v111 + 48);
              if (v137 != v116)
              {
                int v138 = 0;
                do
                {
                  uint64_t v139 = v137 - 24;
                  if (!v137) {
                    uint64_t v139 = 0;
                  }
                  *(_DWORD *)(v139 + 56) = v138++;
                  uint64_t v137 = *(void *)(v137 + 8);
                }
                while (v137 != v116);
              }
              *(_WORD *)(v111 + 18) = v156 | 0x8000;
            }
            unsigned int v154 = *(_DWORD *)(v19 + 56);
            unsigned int v155 = *(_DWORD *)(v106 + 56);
          }
          else
          {
            unsigned int v154 = *(_DWORD *)(v147 + 72);
            unsigned int v155 = *(_DWORD *)(v153 + 72);
          }
          if (v154 >= v155) {
            continue;
          }
          break;
        }
        if (v13 < v107) {
          continue;
        }
        break;
      }
LABEL_190:
      uint64_t v157 = v13 - 1;
      if (v13 - 1 != v11) {
        uint64_t *v11 = *v157;
      }
      *uint64_t v157 = v19;
      if (v44 < v67)
      {
LABEL_195:
        unint64_t result = (uint64_t *)sub_1CD3445A4(v11, v13 - 1, a3, a4, a5 & 1);
        a5 = 0;
      }
      else
      {
        BOOL v158 = sub_1CD3478FC(v11, v13 - 1, a3);
        unint64_t result = (uint64_t *)sub_1CD3478FC(v13, a2, a3);
        if (result)
        {
          a2 = v13 - 1;
          if (v158) {
            return result;
          }
          goto LABEL_2;
        }
        if (!v158) {
          goto LABEL_195;
        }
      }
    }
    else
    {
      uint64_t v24 = *(v11 - 1);
      uint64_t v25 = *(void *)(v20 + 1960);
      uint64_t v21 = *(void *)(v25 + 24);
      uint64_t v22 = *(unsigned int *)(v25 + 40);
      if (v22)
      {
        uint64_t v26 = *(void *)(v24 + 40);
        LODWORD(v27) = ((v26 >> 4) ^ (v26 >> 9)) & (v22 - 1);
        uint64_t v28 = (uint64_t *)(v21 + 16 * v27);
        uint64_t v29 = *v28;
        if (v26 == *v28) {
          goto LABEL_19;
        }
        int v30 = 1;
        while (v29 != -4096)
        {
          int v31 = v27 + v30++;
          uint64_t v27 = v31 & (v22 - 1);
          uint64_t v29 = *(void *)(v21 + 16 * v27);
          if (v26 == v29)
          {
            uint64_t v28 = (uint64_t *)(v21 + 16 * v27);
            goto LABEL_19;
          }
        }
      }
      uint64_t v28 = (uint64_t *)(v21 + 16 * v22);
LABEL_19:
      if (v28 == (uint64_t *)(v21 + 16 * v22)) {
        uint64_t v32 = 0;
      }
      else {
        uint64_t v32 = v28[1];
      }
      uint64_t v23 = *(void *)(v19 + 40);
      unsigned int v33 = v23 >> 4;
      if (v22)
      {
        LODWORD(v34) = (v33 ^ (v23 >> 9)) & (v22 - 1);
        unint64_t result = (uint64_t *)(v21 + 16 * v34);
        uint64_t v35 = *result;
        if (v23 == *result) {
          goto LABEL_29;
        }
        int v36 = 1;
        while (v35 != -4096)
        {
          int v37 = v34 + v36++;
          uint64_t v34 = v37 & (v22 - 1);
          uint64_t v35 = *(void *)(v21 + 16 * v34);
          if (v23 == v35)
          {
            unint64_t result = (uint64_t *)(v21 + 16 * v34);
            goto LABEL_29;
          }
        }
      }
      unint64_t result = (uint64_t *)(v21 + 16 * v22);
LABEL_29:
      if (result == (uint64_t *)(v21 + 16 * v22)) {
        uint64_t v38 = 0;
      }
      else {
        uint64_t v38 = result[1];
      }
      if (v32 == v38)
      {
        int v159 = *(__int16 *)(v23 + 18);
        if ((v159 & 0x80000000) == 0)
        {
          uint64_t v165 = *(void *)(v23 + 48);
          if (v165 != v23 + 40)
          {
            int v166 = 0;
            do
            {
              unint64_t result = (uint64_t *)(v165 - 24);
              if (!v165) {
                unint64_t result = 0;
              }
              *((_DWORD *)result + 14) = v166++;
              uint64_t v165 = *(void *)(v165 + 8);
            }
            while (v165 != v23 + 40);
          }
          *(_WORD *)(v23 + 18) = v159 | 0x8000;
        }
        if (*(_DWORD *)(v19 + 56) < *(_DWORD *)(v24 + 56)) {
          goto LABEL_34;
        }
      }
      else if (*(_DWORD *)(v32 + 72) < *(_DWORD *)(v38 + 72))
      {
        goto LABEL_34;
      }
      if (v22)
      {
        LODWORD(v160) = (v33 ^ (v23 >> 9)) & (v22 - 1);
        uint64_t v161 = (uint64_t *)(v21 + 16 * v160);
        uint64_t v162 = *v161;
        if (v23 == *v161) {
          goto LABEL_211;
        }
        int v163 = 1;
        while (v162 != -4096)
        {
          int v164 = v160 + v163++;
          uint64_t v160 = v164 & (v22 - 1);
          uint64_t v162 = *(void *)(v21 + 16 * v160);
          if (v23 == v162)
          {
            uint64_t v161 = (uint64_t *)(v21 + 16 * v160);
            goto LABEL_211;
          }
        }
      }
      uint64_t v161 = (uint64_t *)(v21 + 16 * v22);
LABEL_211:
      if (v161 == (uint64_t *)(v21 + 16 * v22)) {
        uint64_t v167 = 0;
      }
      else {
        uint64_t v167 = v161[1];
      }
      uint64_t v168 = *v12;
      uint64_t v169 = *(void *)(*v12 + 40);
      if (!v22) {
        goto LABEL_220;
      }
      LODWORD(v170) = ((v169 >> 4) ^ (v169 >> 9)) & (v22 - 1);
      uint64_t v171 = v21 + 16 * v170;
      unint64_t result = *(uint64_t **)v171;
      if (v169 != *(void *)v171)
      {
        int v172 = 1;
        while (result != (uint64_t *)-4096)
        {
          int v173 = v170 + v172++;
          uint64_t v170 = v173 & (v22 - 1);
          unint64_t result = *(uint64_t **)(v21 + 16 * v170);
          if ((uint64_t *)v169 == result)
          {
            uint64_t v171 = v21 + 16 * v170;
            goto LABEL_221;
          }
        }
LABEL_220:
        uint64_t v171 = v21 + 16 * v22;
      }
LABEL_221:
      if (v171 == v21 + 16 * v22) {
        uint64_t v174 = 0;
      }
      else {
        uint64_t v174 = *(void *)(v171 + 8);
      }
      if (v167 == v174)
      {
        int v177 = *(__int16 *)(v169 + 18);
        if ((v177 & 0x80000000) == 0)
        {
          uint64_t v300 = *(void *)(v169 + 48);
          if (v300 != v169 + 40)
          {
            LODWORD(result) = 0;
            do
            {
              uint64_t v301 = v300 - 24;
              if (!v300) {
                uint64_t v301 = 0;
              }
              *(_DWORD *)(v301 + 56) = result;
              unint64_t result = (uint64_t *)(result + 1);
              uint64_t v300 = *(void *)(v300 + 8);
            }
            while (v300 != v169 + 40);
          }
          *(_WORD *)(v169 + 18) = v177 | 0x8000;
        }
        unsigned int v175 = *(_DWORD *)(v168 + 56);
        unsigned int v176 = *(_DWORD *)(v19 + 56);
      }
      else
      {
        unsigned int v175 = *(_DWORD *)(v167 + 72);
        unsigned int v176 = *(_DWORD *)(v174 + 72);
      }
      if (v175 < v176)
      {
        unsigned int v178 = v22 - 1;
        unsigned int v179 = (v33 ^ (v23 >> 9)) & (v22 - 1);
        BOOL v180 = (uint64_t *)(v21 + 16 * v179);
        uint64_t v181 = (uint64_t *)(v21 + 16 * v22);
        uint64_t v13 = v11;
        while (1)
        {
          uint64_t v183 = v13[1];
          ++v13;
          uint64_t v182 = v183;
          if (!v22)
          {
            uint64_t v190 = *(void *)(v182 + 40);
LABEL_250:
            int v198 = *(__int16 *)(v190 + 18);
            if ((v198 & 0x80000000) == 0)
            {
              uint64_t v199 = *(void *)(v190 + 48);
              if (v199 != v190 + 40)
              {
                int v200 = 0;
                do
                {
                  uint64_t v201 = v199 - 24;
                  if (!v199) {
                    uint64_t v201 = 0;
                  }
                  *(_DWORD *)(v201 + 56) = v200++;
                  uint64_t v199 = *(void *)(v199 + 8);
                }
                while (v199 != v190 + 40);
              }
              *(_WORD *)(v190 + 18) = v198 | 0x8000;
            }
            unint64_t result = (uint64_t *)*(unsigned int *)(v182 + 56);
            unsigned int v197 = *(_DWORD *)(v19 + 56);
            goto LABEL_252;
          }
          uint64_t v184 = *v180;
          unint64_t v185 = (uint64_t *)(v21 + 16 * v179);
          if (v23 == *v180)
          {
LABEL_236:
            if (v185 != v181)
            {
              uint64_t v189 = v185[1];
              goto LABEL_239;
            }
          }
          else
          {
            int v186 = 1;
            LODWORD(v187) = (v33 ^ (v23 >> 9)) & v178;
            while (v184 != -4096)
            {
              int v188 = v187 + v186++;
              uint64_t v187 = v188 & v178;
              uint64_t v184 = *(void *)(v21 + 16 * v187);
              if (v23 == v184)
              {
                unint64_t v185 = (uint64_t *)(v21 + 16 * v187);
                goto LABEL_236;
              }
            }
          }
          uint64_t v189 = 0;
LABEL_239:
          uint64_t v190 = *(void *)(v182 + 40);
          LODWORD(v191) = ((v190 >> 4) ^ (v190 >> 9)) & v178;
          int v192 = (uint64_t *)(v21 + 16 * v191);
          uint64_t v193 = *v192;
          if (v190 == *v192)
          {
LABEL_244:
            if (v192 != v181)
            {
              uint64_t v196 = v192[1];
              goto LABEL_247;
            }
          }
          else
          {
            int v194 = 1;
            while (v193 != -4096)
            {
              int v195 = v191 + v194++;
              uint64_t v191 = v195 & v178;
              uint64_t v193 = *(void *)(v21 + 16 * v191);
              if (v190 == v193)
              {
                int v192 = (uint64_t *)(v21 + 16 * v191);
                goto LABEL_244;
              }
            }
          }
          uint64_t v196 = 0;
LABEL_247:
          if (v189 == v196) {
            goto LABEL_250;
          }
          unint64_t result = (uint64_t *)*(unsigned int *)(v189 + 72);
          unsigned int v197 = *(_DWORD *)(v196 + 72);
LABEL_252:
          if (result < v197) {
            goto LABEL_293;
          }
        }
      }
      uint64_t v13 = v11 + 1;
      if (v11 + 1 < a2)
      {
        unsigned int v202 = v22 - 1;
        unsigned int v203 = (v33 ^ (v23 >> 9)) & (v22 - 1);
        int v204 = (uint64_t *)(v21 + 16 * v203);
        int v205 = (uint64_t *)(v21 + 16 * v22);
        while (1)
        {
          uint64_t v206 = *v13;
          if (!v22)
          {
            uint64_t v213 = *(void *)(v206 + 40);
LABEL_282:
            int v221 = *(__int16 *)(v213 + 18);
            if ((v221 & 0x80000000) == 0)
            {
              uint64_t v222 = *(void *)(v213 + 48);
              if (v222 != v213 + 40)
              {
                int v223 = 0;
                do
                {
                  uint64_t v224 = v222 - 24;
                  if (!v222) {
                    uint64_t v224 = 0;
                  }
                  *(_DWORD *)(v224 + 56) = v223++;
                  uint64_t v222 = *(void *)(v222 + 8);
                }
                while (v222 != v213 + 40);
              }
              *(_WORD *)(v213 + 18) = v221 | 0x8000;
            }
            unint64_t result = (uint64_t *)*(unsigned int *)(v206 + 56);
            unsigned int v220 = *(_DWORD *)(v19 + 56);
            goto LABEL_284;
          }
          uint64_t v207 = *v204;
          unsigned int v208 = (uint64_t *)(v21 + 16 * v203);
          if (v23 == *v204)
          {
LABEL_268:
            if (v208 != v205)
            {
              uint64_t v212 = v208[1];
              goto LABEL_271;
            }
          }
          else
          {
            int v209 = 1;
            LODWORD(v210) = (v33 ^ (v23 >> 9)) & v202;
            while (v207 != -4096)
            {
              int v211 = v210 + v209++;
              uint64_t v210 = v211 & v202;
              uint64_t v207 = *(void *)(v21 + 16 * v210);
              if (v23 == v207)
              {
                unsigned int v208 = (uint64_t *)(v21 + 16 * v210);
                goto LABEL_268;
              }
            }
          }
          uint64_t v212 = 0;
LABEL_271:
          uint64_t v213 = *(void *)(v206 + 40);
          LODWORD(v214) = ((v213 >> 4) ^ (v213 >> 9)) & v202;
          uint64_t v215 = (uint64_t *)(v21 + 16 * v214);
          uint64_t v216 = *v215;
          if (v213 == *v215)
          {
LABEL_276:
            if (v215 != v205)
            {
              uint64_t v219 = v215[1];
              goto LABEL_279;
            }
          }
          else
          {
            int v217 = 1;
            while (v216 != -4096)
            {
              int v218 = v214 + v217++;
              uint64_t v214 = v218 & v202;
              uint64_t v216 = *(void *)(v21 + 16 * v214);
              if (v213 == v216)
              {
                uint64_t v215 = (uint64_t *)(v21 + 16 * v214);
                goto LABEL_276;
              }
            }
          }
          uint64_t v219 = 0;
LABEL_279:
          if (v212 == v219) {
            goto LABEL_282;
          }
          unint64_t result = (uint64_t *)*(unsigned int *)(v212 + 72);
          unsigned int v220 = *(_DWORD *)(v219 + 72);
LABEL_284:
          if (result >= v220 && ++v13 < a2) {
            continue;
          }
          break;
        }
      }
LABEL_293:
      long long v225 = (uint64_t **)a2;
      if (v13 < a2)
      {
        unsigned int v226 = v33 ^ (v23 >> 9);
        unsigned int v227 = v22 - 1;
        unsigned int v228 = v226 & (v22 - 1);
        unint64_t v229 = (uint64_t *)(v21 + 16 * v228);
        unint64_t v230 = (uint64_t *)(v21 + 16 * v22);
        for (unint64_t result = a2; ; --result)
        {
          long long v225 = (uint64_t **)(result - 1);
          if (!v22)
          {
            uint64_t v237 = *(void *)(v168 + 40);
            goto LABEL_315;
          }
          uint64_t v231 = *v229;
          unsigned int v232 = (uint64_t *)(v21 + 16 * v228);
          if (v23 == *v229)
          {
LABEL_301:
            if (v232 != v230)
            {
              uint64_t v236 = v232[1];
              goto LABEL_304;
            }
          }
          else
          {
            int v233 = 1;
            LODWORD(v234) = v228;
            while (v231 != -4096)
            {
              int v235 = v234 + v233++;
              uint64_t v234 = v235 & v227;
              uint64_t v231 = *(void *)(v21 + 16 * v234);
              if (v23 == v231)
              {
                unsigned int v232 = (uint64_t *)(v21 + 16 * v234);
                goto LABEL_301;
              }
            }
          }
          uint64_t v236 = 0;
LABEL_304:
          uint64_t v237 = *(void *)(v168 + 40);
          LODWORD(v238) = ((v237 >> 4) ^ (v237 >> 9)) & v227;
          unint64_t v239 = (uint64_t *)(v21 + 16 * v238);
          uint64_t v240 = *v239;
          if (v237 == *v239)
          {
LABEL_309:
            if (v239 != v230)
            {
              uint64_t v243 = v239[1];
              goto LABEL_312;
            }
          }
          else
          {
            int v241 = 1;
            while (v240 != -4096)
            {
              int v242 = v238 + v241++;
              uint64_t v238 = v242 & v227;
              uint64_t v240 = *(void *)(v21 + 16 * v238);
              if (v237 == v240)
              {
                unint64_t v239 = (uint64_t *)(v21 + 16 * v238);
                goto LABEL_309;
              }
            }
          }
          uint64_t v243 = 0;
LABEL_312:
          if (v236 != v243)
          {
            unsigned int v244 = *(_DWORD *)(v236 + 72);
            unsigned int v245 = *(_DWORD *)(v243 + 72);
            goto LABEL_317;
          }
LABEL_315:
          int v246 = *(__int16 *)(v237 + 18);
          if ((v246 & 0x80000000) == 0)
          {
            uint64_t v247 = *(void *)(v237 + 48);
            if (v247 != v237 + 40)
            {
              int v248 = 0;
              do
              {
                uint64_t v249 = v247 - 24;
                if (!v247) {
                  uint64_t v249 = 0;
                }
                *(_DWORD *)(v249 + 56) = v248++;
                uint64_t v247 = *(void *)(v247 + 8);
              }
              while (v247 != v237 + 40);
            }
            *(_WORD *)(v237 + 18) = v246 | 0x8000;
          }
          unsigned int v244 = *(_DWORD *)(v168 + 56);
          unsigned int v245 = *(_DWORD *)(v19 + 56);
LABEL_317:
          if (v244 >= v245) {
            break;
          }
          uint64_t v168 = *(result - 2);
        }
      }
      if (v13 >= (uint64_t *)v225) {
        goto LABEL_388;
      }
      uint64_t v250 = *v13;
      unint64_t result = *v225;
      do
      {
        *uint64_t v13 = (uint64_t)result;
        *long long v225 = (uint64_t *)v250;
        uint64_t v251 = *(void *)(*(void *)a3 + 1960);
        uint64_t v252 = *(void *)(v19 + 40);
        uint64_t v253 = *(void *)(v251 + 24);
        uint64_t v254 = *(unsigned int *)(v251 + 40);
        unsigned int v255 = v254 - 1;
        unsigned int v256 = ((v252 >> 4) ^ (v252 >> 9)) & (v254 - 1);
        unint64_t v257 = (uint64_t *)(v253 + 16 * v256);
        unint64_t v258 = (uint64_t *)(v253 + 16 * v254);
        do
        {
          uint64_t v259 = v13[1];
          ++v13;
          uint64_t v250 = v259;
          if (!v254)
          {
            uint64_t v266 = *(void *)(v250 + 40);
            goto LABEL_348;
          }
          uint64_t v260 = *v257;
          uint64_t v261 = (uint64_t *)(v253 + 16 * v256);
          if (v252 == *v257)
          {
LABEL_334:
            if (v261 != v258)
            {
              uint64_t v265 = v261[1];
              goto LABEL_337;
            }
          }
          else
          {
            int v262 = 1;
            LODWORD(v263) = ((v252 >> 4) ^ (v252 >> 9)) & (v254 - 1);
            while (v260 != -4096)
            {
              int v264 = v263 + v262++;
              uint64_t v263 = v264 & v255;
              uint64_t v260 = *(void *)(v253 + 16 * v263);
              if (v252 == v260)
              {
                uint64_t v261 = (uint64_t *)(v253 + 16 * v263);
                goto LABEL_334;
              }
            }
          }
          uint64_t v265 = 0;
LABEL_337:
          uint64_t v266 = *(void *)(v250 + 40);
          LODWORD(v267) = ((v266 >> 4) ^ (v266 >> 9)) & v255;
          uint64_t v268 = (uint64_t *)(v253 + 16 * v267);
          uint64_t v269 = *v268;
          if (v266 == *v268)
          {
LABEL_342:
            if (v268 != v258)
            {
              uint64_t v272 = v268[1];
              goto LABEL_345;
            }
          }
          else
          {
            int v270 = 1;
            while (v269 != -4096)
            {
              int v271 = v267 + v270++;
              uint64_t v267 = v271 & v255;
              uint64_t v269 = *(void *)(v253 + 16 * v267);
              if (v266 == v269)
              {
                uint64_t v268 = (uint64_t *)(v253 + 16 * v267);
                goto LABEL_342;
              }
            }
          }
          uint64_t v272 = 0;
LABEL_345:
          if (v265 != v272)
          {
            unsigned int v273 = *(_DWORD *)(v265 + 72);
            unsigned int v274 = *(_DWORD *)(v272 + 72);
            continue;
          }
LABEL_348:
          int v275 = *(__int16 *)(v266 + 18);
          if ((v275 & 0x80000000) == 0)
          {
            uint64_t v276 = *(void *)(v266 + 48);
            if (v276 != v266 + 40)
            {
              int v277 = 0;
              do
              {
                uint64_t v278 = v276 - 24;
                if (!v276) {
                  uint64_t v278 = 0;
                }
                *(_DWORD *)(v278 + 56) = v277++;
                uint64_t v276 = *(void *)(v276 + 8);
              }
              while (v276 != v266 + 40);
            }
            *(_WORD *)(v266 + 18) = v275 | 0x8000;
          }
          unsigned int v273 = *(_DWORD *)(v250 + 56);
          unsigned int v274 = *(_DWORD *)(v19 + 56);
        }
        while (v273 >= v274);
        do
        {
          uint64_t v282 = *--v225;
          unint64_t result = v282;
          if (!v254)
          {
            uint64_t v289 = result[5];
            goto LABEL_384;
          }
          uint64_t v283 = *v257;
          long long v284 = (uint64_t *)(v253 + 16 * v256);
          if (v252 == *v257)
          {
LABEL_370:
            if (v284 != v258)
            {
              uint64_t v288 = v284[1];
              goto LABEL_373;
            }
          }
          else
          {
            int v285 = 1;
            LODWORD(v286) = ((v252 >> 4) ^ (v252 >> 9)) & (v254 - 1);
            while (v283 != -4096)
            {
              int v287 = v286 + v285++;
              uint64_t v286 = v287 & v255;
              uint64_t v283 = *(void *)(v253 + 16 * v286);
              if (v252 == v283)
              {
                long long v284 = (uint64_t *)(v253 + 16 * v286);
                goto LABEL_370;
              }
            }
          }
          uint64_t v288 = 0;
LABEL_373:
          uint64_t v289 = result[5];
          LODWORD(v290) = ((v289 >> 4) ^ (v289 >> 9)) & v255;
          uint64_t v291 = (uint64_t *)(v253 + 16 * v290);
          uint64_t v292 = *v291;
          if (v289 == *v291)
          {
LABEL_378:
            if (v291 != v258)
            {
              uint64_t v295 = v291[1];
              goto LABEL_381;
            }
          }
          else
          {
            int v293 = 1;
            while (v292 != -4096)
            {
              int v294 = v290 + v293++;
              uint64_t v290 = v294 & v255;
              uint64_t v292 = *(void *)(v253 + 16 * v290);
              if (v289 == v292)
              {
                uint64_t v291 = (uint64_t *)(v253 + 16 * v290);
                goto LABEL_378;
              }
            }
          }
          uint64_t v295 = 0;
LABEL_381:
          if (v288 != v295)
          {
            unsigned int v296 = *(_DWORD *)(v288 + 72);
            unsigned int v297 = *(_DWORD *)(v295 + 72);
            continue;
          }
LABEL_384:
          int v298 = *(__int16 *)(v289 + 18);
          if ((v298 & 0x80000000) == 0)
          {
            uint64_t v279 = *(void *)(v289 + 48);
            if (v279 != v289 + 40)
            {
              int v280 = 0;
              do
              {
                uint64_t v281 = v279 - 24;
                if (!v279) {
                  uint64_t v281 = 0;
                }
                *(_DWORD *)(v281 + 56) = v280++;
                uint64_t v279 = *(void *)(v279 + 8);
              }
              while (v279 != v289 + 40);
            }
            *(_WORD *)(v289 + 18) = v298 | 0x8000;
          }
          unsigned int v296 = *((_DWORD *)result + 14);
          unsigned int v297 = *(_DWORD *)(v19 + 56);
        }
        while (v296 < v297);
      }
      while (v13 < (uint64_t *)v225);
LABEL_388:
      int v299 = v13 - 1;
      BOOL v5 = v13 - 1 >= v11;
      BOOL v6 = v13 - 1 == v11;
      if (v13 - 1 != v11) {
        uint64_t *v11 = *v299;
      }
      a5 = 0;
      uint64_t *v299 = v19;
    }
  }
  unint64_t v326 = v13 + 1;
  BOOL v328 = v13 == a2 || v326 == a2;
  if ((a5 & 1) == 0)
  {
    if (v328) {
      return result;
    }
    uint64_t v557 = *(void *)a3;
    while (1)
    {
      v558 = v11;
      long long v11 = v326;
      uint64_t v559 = v558[1];
      uint64_t v560 = *(void *)(v557 + 1960);
      uint64_t v561 = *(void *)(v560 + 24);
      uint64_t v562 = *(unsigned int *)(v560 + 40);
      if (v562)
      {
        uint64_t v563 = *(void *)(v559 + 40);
        LODWORD(v564) = ((v563 >> 4) ^ (v563 >> 9)) & (v562 - 1);
        uint64_t v565 = (uint64_t *)(v561 + 16 * v564);
        uint64_t v566 = *v565;
        if (v563 != *v565)
        {
          int v567 = 1;
          do
          {
            if (v566 == -4096) {
              goto LABEL_759;
            }
            int v568 = v564 + v567++;
            uint64_t v564 = v568 & (v562 - 1);
            uint64_t v566 = *(void *)(v561 + 16 * v564);
          }
          while (v563 != v566);
          uint64_t v565 = (uint64_t *)(v561 + 16 * v564);
        }
      }
      else
      {
LABEL_759:
        uint64_t v565 = (uint64_t *)(v561 + 16 * v562);
      }
      if (v565 == (uint64_t *)(v561 + 16 * v562)) {
        uint64_t v569 = 0;
      }
      else {
        uint64_t v569 = v565[1];
      }
      uint64_t v570 = *v558;
      uint64_t v571 = *(void *)(*v558 + 40);
      if (v562)
      {
        LODWORD(v572) = ((v571 >> 4) ^ (v571 >> 9)) & (v562 - 1);
        uint64_t v573 = v561 + 16 * v572;
        unint64_t result = *(uint64_t **)v573;
        if (v571 != *(void *)v573)
        {
          int v574 = 1;
          do
          {
            if (result == (uint64_t *)-4096) {
              goto LABEL_769;
            }
            int v575 = v572 + v574++;
            uint64_t v572 = v575 & (v562 - 1);
            unint64_t result = *(uint64_t **)(v561 + 16 * v572);
          }
          while ((uint64_t *)v571 != result);
          uint64_t v573 = v561 + 16 * v572;
        }
      }
      else
      {
LABEL_769:
        uint64_t v573 = v561 + 16 * v562;
      }
      if (v573 == v561 + 16 * v562) {
        uint64_t v576 = 0;
      }
      else {
        uint64_t v576 = *(void *)(v573 + 8);
      }
      if (v569 == v576)
      {
        int v577 = *(__int16 *)(v571 + 18);
        if ((v577 & 0x80000000) == 0)
        {
          uint64_t v599 = *(void *)(v571 + 48);
          if (v599 != v571 + 40)
          {
            int v600 = 0;
            do
            {
              uint64_t v601 = v599 - 24;
              if (!v599) {
                uint64_t v601 = 0;
              }
              *(_DWORD *)(v601 + 56) = v600++;
              uint64_t v599 = *(void *)(v599 + 8);
            }
            while (v599 != v571 + 40);
          }
          *(_WORD *)(v571 + 18) = v577 | 0x8000;
        }
        if (*(_DWORD *)(v570 + 56) >= *(_DWORD *)(v559 + 56)) {
          goto LABEL_812;
        }
      }
      else if (*(_DWORD *)(v569 + 72) >= *(_DWORD *)(v576 + 72))
      {
        goto LABEL_812;
      }
      uint64_t v578 = v11;
      do
      {
        while (1)
        {
          *uint64_t v578 = v570;
          uint64_t v578 = v558;
          uint64_t v579 = *(void *)(*(void *)a3 + 1960);
          uint64_t v580 = *(void *)(v579 + 24);
          uint64_t v581 = *(unsigned int *)(v579 + 40);
          if (v581)
          {
            uint64_t v582 = *(void *)(v559 + 40);
            LODWORD(v583) = ((v582 >> 4) ^ (v582 >> 9)) & (v581 - 1);
            v584 = (uint64_t *)(v580 + 16 * v583);
            uint64_t v585 = *v584;
            if (v582 != *v584)
            {
              int v586 = 1;
              do
              {
                if (v585 == -4096) {
                  goto LABEL_785;
                }
                int v587 = v583 + v586++;
                uint64_t v583 = v587 & (v581 - 1);
                uint64_t v585 = *(void *)(v580 + 16 * v583);
              }
              while (v582 != v585);
              v584 = (uint64_t *)(v580 + 16 * v583);
            }
          }
          else
          {
LABEL_785:
            v584 = (uint64_t *)(v580 + 16 * v581);
          }
          v558 = v578 - 1;
          uint64_t v570 = *(v578 - 1);
          uint64_t v588 = v584 == (uint64_t *)(v580 + 16 * v581) ? 0 : v584[1];
          uint64_t v589 = *(void *)(v570 + 40);
          if (v581)
          {
            LODWORD(v590) = ((v589 >> 4) ^ (v589 >> 9)) & (v581 - 1);
            uint64_t v591 = v580 + 16 * v590;
            unint64_t result = *(uint64_t **)v591;
            if (v589 != *(void *)v591)
            {
              int v592 = 1;
              do
              {
                if (result == (uint64_t *)-4096) {
                  goto LABEL_795;
                }
                int v593 = v590 + v592++;
                uint64_t v590 = v593 & (v581 - 1);
                unint64_t result = *(uint64_t **)(v580 + 16 * v590);
              }
              while ((uint64_t *)v589 != result);
              uint64_t v591 = v580 + 16 * v590;
            }
          }
          else
          {
LABEL_795:
            uint64_t v591 = v580 + 16 * v581;
          }
          uint64_t v594 = v591 == v580 + 16 * v581 ? 0 : *(void *)(v591 + 8);
          if (v588 == v594) {
            break;
          }
          if (*(_DWORD *)(v588 + 72) >= *(_DWORD *)(v594 + 72)) {
            goto LABEL_811;
          }
        }
        int v595 = *(__int16 *)(v589 + 18);
        if ((v595 & 0x80000000) == 0)
        {
          uint64_t v596 = *(void *)(v589 + 48);
          if (v596 != v589 + 40)
          {
            int v597 = 0;
            do
            {
              uint64_t v598 = v596 - 24;
              if (!v596) {
                uint64_t v598 = 0;
              }
              *(_DWORD *)(v598 + 56) = v597++;
              uint64_t v596 = *(void *)(v596 + 8);
            }
            while (v596 != v589 + 40);
          }
          *(_WORD *)(v589 + 18) = v595 | 0x8000;
        }
      }
      while (*(_DWORD *)(v570 + 56) < *(_DWORD *)(v559 + 56));
LABEL_811:
      *uint64_t v578 = v559;
      uint64_t v557 = *(void *)a3;
LABEL_812:
      unint64_t v326 = v11 + 1;
      if (v11 + 1 == a2) {
        return result;
      }
    }
  }
  if (v328) {
    return result;
  }
  uint64_t v329 = *(void *)a3;
  uint64_t v330 = v13;
  while (2)
  {
    int v331 = v330;
    uint64_t v330 = v326;
    uint64_t v332 = v331[1];
    uint64_t v333 = *(void *)(v329 + 1960);
    uint64_t v334 = *(void *)(v333 + 24);
    uint64_t v335 = *(unsigned int *)(v333 + 40);
    if (v335)
    {
      uint64_t v336 = *(void *)(v332 + 40);
      LODWORD(v337) = ((v336 >> 4) ^ (v336 >> 9)) & (v335 - 1);
      unint64_t result = (uint64_t *)(v334 + 16 * v337);
      uint64_t v338 = *result;
      if (v336 != *result)
      {
        int v339 = 1;
        while (v338 != -4096)
        {
          int v340 = v337 + v339++;
          uint64_t v337 = v340 & (v335 - 1);
          uint64_t v338 = *(void *)(v334 + 16 * v337);
          if (v336 == v338)
          {
            unint64_t result = (uint64_t *)(v334 + 16 * v337);
            goto LABEL_434;
          }
        }
        goto LABEL_433;
      }
    }
    else
    {
LABEL_433:
      unint64_t result = (uint64_t *)(v334 + 16 * v335);
    }
LABEL_434:
    if (result == (uint64_t *)(v334 + 16 * v335)) {
      uint64_t v341 = 0;
    }
    else {
      uint64_t v341 = result[1];
    }
    uint64_t v342 = *v331;
    uint64_t v343 = *(void *)(*v331 + 40);
    if (v335)
    {
      unint64_t result = (uint64_t *)(v335 - 1);
      LODWORD(v344) = ((v343 >> 4) ^ (v343 >> 9)) & result;
      unsigned int v345 = (uint64_t *)(v334 + 16 * v344);
      uint64_t v346 = *v345;
      if (v343 != *v345)
      {
        int v347 = 1;
        while (v346 != -4096)
        {
          int v348 = v344 + v347++;
          uint64_t v344 = v348 & result;
          uint64_t v346 = *(void *)(v334 + 16 * v344);
          if (v343 == v346)
          {
            unsigned int v345 = (uint64_t *)(v334 + 16 * v344);
            goto LABEL_444;
          }
        }
        goto LABEL_443;
      }
    }
    else
    {
LABEL_443:
      unsigned int v345 = (uint64_t *)(v334 + 16 * v335);
    }
LABEL_444:
    if (v345 == (uint64_t *)(v334 + 16 * v335)) {
      uint64_t v349 = 0;
    }
    else {
      uint64_t v349 = v345[1];
    }
    if (v341 == v349)
    {
      int v350 = *(__int16 *)(v343 + 18);
      if ((v350 & 0x80000000) == 0)
      {
        uint64_t v374 = *(void *)(v343 + 48);
        if (v374 != v343 + 40)
        {
          int v375 = 0;
          do
          {
            unint64_t result = (uint64_t *)(v374 - 24);
            if (!v374) {
              unint64_t result = 0;
            }
            *((_DWORD *)result + 14) = v375++;
            uint64_t v374 = *(void *)(v374 + 8);
          }
          while (v374 != v343 + 40);
        }
        *(_WORD *)(v343 + 18) = v350 | 0x8000;
      }
      if (*(_DWORD *)(v342 + 56) >= *(_DWORD *)(v332 + 56)) {
        goto LABEL_488;
      }
    }
    else if (*(_DWORD *)(v341 + 72) >= *(_DWORD *)(v349 + 72))
    {
      goto LABEL_488;
    }
    v331[1] = v342;
    uint64_t v351 = v13;
    if (v331 == v13) {
      goto LABEL_487;
    }
    while (2)
    {
      uint64_t v352 = *(void *)(*(void *)a3 + 1960);
      uint64_t v353 = *(void *)(v352 + 24);
      uint64_t v354 = *(unsigned int *)(v352 + 40);
      if (v354)
      {
        uint64_t v355 = *(void *)(v332 + 40);
        LODWORD(v356) = ((v355 >> 4) ^ (v355 >> 9)) & (v354 - 1);
        double v357 = (uint64_t *)(v353 + 16 * v356);
        uint64_t v358 = *v357;
        if (v355 != *v357)
        {
          int v359 = 1;
          while (v358 != -4096)
          {
            int v360 = v356 + v359++;
            uint64_t v356 = v360 & (v354 - 1);
            uint64_t v358 = *(void *)(v353 + 16 * v356);
            if (v355 == v358)
            {
              double v357 = (uint64_t *)(v353 + 16 * v356);
              goto LABEL_460;
            }
          }
          goto LABEL_459;
        }
      }
      else
      {
LABEL_459:
        double v357 = (uint64_t *)(v353 + 16 * v354);
      }
LABEL_460:
      if (v357 == (uint64_t *)(v353 + 16 * v354)) {
        uint64_t v361 = 0;
      }
      else {
        uint64_t v361 = v357[1];
      }
      uint64_t v362 = v331 - 1;
      uint64_t v363 = *(v331 - 1);
      uint64_t v364 = *(void *)(v363 + 40);
      if (v354)
      {
        unint64_t result = (uint64_t *)(v354 - 1);
        LODWORD(v365) = ((v364 >> 4) ^ (v364 >> 9)) & result;
        uint64_t v366 = (uint64_t *)(v353 + 16 * v365);
        uint64_t v367 = *v366;
        if (v364 != *v366)
        {
          int v368 = 1;
          while (v367 != -4096)
          {
            int v369 = v365 + v368++;
            uint64_t v365 = v369 & result;
            uint64_t v367 = *(void *)(v353 + 16 * v365);
            if (v364 == v367)
            {
              uint64_t v366 = (uint64_t *)(v353 + 16 * v365);
              goto LABEL_470;
            }
          }
          goto LABEL_469;
        }
      }
      else
      {
LABEL_469:
        uint64_t v366 = (uint64_t *)(v353 + 16 * v354);
      }
LABEL_470:
      if (v366 == (uint64_t *)(v353 + 16 * v354)) {
        uint64_t v370 = 0;
      }
      else {
        uint64_t v370 = v366[1];
      }
      if (v361 != v370)
      {
        if (*(_DWORD *)(v361 + 72) >= *(_DWORD *)(v370 + 72)) {
          break;
        }
        goto LABEL_478;
      }
      int v371 = *(__int16 *)(v364 + 18);
      if ((v371 & 0x80000000) == 0)
      {
        uint64_t v372 = *(void *)(v364 + 48);
        if (v372 != v364 + 40)
        {
          int v373 = 0;
          do
          {
            unint64_t result = (uint64_t *)(v372 - 24);
            if (!v372) {
              unint64_t result = 0;
            }
            *((_DWORD *)result + 14) = v373++;
            uint64_t v372 = *(void *)(v372 + 8);
          }
          while (v372 != v364 + 40);
        }
        *(_WORD *)(v364 + 18) = v371 | 0x8000;
      }
      if (*(_DWORD *)(v363 + 56) < *(_DWORD *)(v332 + 56))
      {
LABEL_478:
        *v331-- = v363;
        if (v362 == v13)
        {
          uint64_t v351 = v13;
          goto LABEL_487;
        }
        continue;
      }
      break;
    }
    uint64_t v351 = v331;
LABEL_487:
    uint64_t *v351 = v332;
    uint64_t v329 = *(void *)a3;
LABEL_488:
    unint64_t v326 = v330 + 1;
    if (v330 + 1 != a2) {
      continue;
    }
    return result;
  }
}

uint64_t *sub_1CD3471D4(uint64_t *result, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *result;
  uint64_t v6 = *(void *)(*(void *)a4 + 1960);
  uint64_t v7 = *(void *)(*a2 + 40);
  uint64_t v8 = *(void *)(v6 + 24);
  uint64_t v9 = *(unsigned int *)(v6 + 40);
  unsigned int v10 = v7 >> 4;
  if (v9)
  {
    LODWORD(v11) = (v10 ^ (v7 >> 9)) & (v9 - 1);
    uint64_t v12 = (uint64_t *)(v8 + 16 * v11);
    uint64_t v13 = *v12;
    if (v7 == *v12) {
      goto LABEL_8;
    }
    int v14 = 1;
    while (v13 != -4096)
    {
      int v15 = v11 + v14++;
      uint64_t v11 = v15 & (v9 - 1);
      uint64_t v13 = *(void *)(v8 + 16 * v11);
      if (v7 == v13)
      {
        uint64_t v12 = (uint64_t *)(v8 + 16 * v11);
        goto LABEL_8;
      }
    }
  }
  uint64_t v12 = (uint64_t *)(v8 + 16 * v9);
LABEL_8:
  if (v12 == (uint64_t *)(v8 + 16 * v9)) {
    uint64_t v16 = 0;
  }
  else {
    uint64_t v16 = v12[1];
  }
  uint64_t v17 = *(void *)(v5 + 40);
  if (v9)
  {
    LODWORD(v18) = ((v17 >> 4) ^ (v17 >> 9)) & (v9 - 1);
    uint64_t v19 = (uint64_t *)(v8 + 16 * v18);
    uint64_t v20 = *v19;
    if (v17 == *v19) {
      goto LABEL_18;
    }
    int v21 = 1;
    while (v20 != -4096)
    {
      int v22 = v18 + v21++;
      uint64_t v18 = v22 & (v9 - 1);
      uint64_t v20 = *(void *)(v8 + 16 * v18);
      if (v17 == v20)
      {
        uint64_t v19 = (uint64_t *)(v8 + 16 * v18);
        goto LABEL_18;
      }
    }
  }
  uint64_t v19 = (uint64_t *)(v8 + 16 * v9);
LABEL_18:
  if (v19 == (uint64_t *)(v8 + 16 * v9)) {
    uint64_t v23 = 0;
  }
  else {
    uint64_t v23 = v19[1];
  }
  if (v16 == v23)
  {
    int v26 = *(__int16 *)(v17 + 18);
    if ((v26 & 0x80000000) == 0)
    {
      uint64_t v100 = *(void *)(v17 + 48);
      if (v100 != v17 + 40)
      {
        int v101 = 0;
        do
        {
          uint64_t v102 = v100 - 24;
          if (!v100) {
            uint64_t v102 = 0;
          }
          *(_DWORD *)(v102 + 56) = v101++;
          uint64_t v100 = *(void *)(v100 + 8);
        }
        while (v100 != v17 + 40);
      }
      *(_WORD *)(v17 + 18) = v26 | 0x8000;
    }
    unsigned int v24 = *(_DWORD *)(v5 + 56);
    unsigned int v25 = *(_DWORD *)(v4 + 56);
  }
  else
  {
    unsigned int v24 = *(_DWORD *)(v16 + 72);
    unsigned int v25 = *(_DWORD *)(v23 + 72);
  }
  if (v24 >= v25)
  {
    uint64_t v34 = *a3;
    if (v9)
    {
      uint64_t v35 = *(void *)(v34 + 40);
      LODWORD(v36) = ((v35 >> 4) ^ (v35 >> 9)) & (v9 - 1);
      int v37 = (uint64_t *)(v8 + 16 * v36);
      uint64_t v38 = *v37;
      if (v35 == *v37) {
        goto LABEL_49;
      }
      int v39 = 1;
      while (v38 != -4096)
      {
        int v40 = v36 + v39++;
        uint64_t v36 = v40 & (v9 - 1);
        uint64_t v38 = *(void *)(v8 + 16 * v36);
        if (v35 == v38)
        {
          int v37 = (uint64_t *)(v8 + 16 * v36);
          goto LABEL_49;
        }
      }
    }
    int v37 = (uint64_t *)(v8 + 16 * v9);
LABEL_49:
    if (v37 == (uint64_t *)(v8 + 16 * v9))
    {
      uint64_t v47 = 0;
      if (!v9) {
        goto LABEL_74;
      }
    }
    else
    {
      uint64_t v47 = v37[1];
      if (!v9) {
        goto LABEL_74;
      }
    }
    LODWORD(v48) = (v10 ^ (v7 >> 9)) & (v9 - 1);
    uint64_t v49 = (uint64_t *)(v8 + 16 * v48);
    uint64_t v50 = *v49;
    if (v7 == *v49) {
      goto LABEL_75;
    }
    int v51 = 1;
    while (v50 != -4096)
    {
      int v52 = v48 + v51++;
      uint64_t v48 = v52 & (v9 - 1);
      uint64_t v50 = *(void *)(v8 + 16 * v48);
      if (v7 == v50)
      {
        uint64_t v49 = (uint64_t *)(v8 + 16 * v48);
        goto LABEL_75;
      }
    }
LABEL_74:
    uint64_t v49 = (uint64_t *)(v8 + 16 * v9);
LABEL_75:
    if (v49 == (uint64_t *)(v8 + 16 * v9)) {
      uint64_t v67 = 0;
    }
    else {
      uint64_t v67 = v49[1];
    }
    if (v47 == v67)
    {
      int v70 = *(__int16 *)(v7 + 18);
      if ((v70 & 0x80000000) == 0)
      {
        uint64_t v106 = *(void *)(v7 + 48);
        if (v106 != v7 + 40)
        {
          int v107 = 0;
          do
          {
            uint64_t v108 = v106 - 24;
            if (!v106) {
              uint64_t v108 = 0;
            }
            *(_DWORD *)(v108 + 56) = v107++;
            uint64_t v106 = *(void *)(v106 + 8);
          }
          while (v106 != v7 + 40);
        }
        *(_WORD *)(v7 + 18) = v70 | 0x8000;
      }
      unsigned int v68 = *(_DWORD *)(v4 + 56);
      unsigned int v69 = *(_DWORD *)(v34 + 56);
    }
    else
    {
      unsigned int v68 = *(_DWORD *)(v47 + 72);
      unsigned int v69 = *(_DWORD *)(v67 + 72);
    }
    if (v68 >= v69) {
      return result;
    }
    *a2 = v34;
    *a3 = v4;
    uint64_t v71 = *a2;
    uint64_t v72 = *result;
    uint64_t v73 = *(void *)(*(void *)a4 + 1960);
    uint64_t v74 = *(void *)(v73 + 24);
    uint64_t v75 = *(unsigned int *)(v73 + 40);
    if (v75)
    {
      uint64_t v76 = *(void *)(v71 + 40);
      LODWORD(v77) = ((v76 >> 4) ^ (v76 >> 9)) & (v75 - 1);
      BOOL v78 = (uint64_t *)(v74 + 16 * v77);
      uint64_t v79 = *v78;
      if (v76 == *v78) {
        goto LABEL_100;
      }
      int v80 = 1;
      while (v79 != -4096)
      {
        int v81 = v77 + v80++;
        uint64_t v77 = v81 & (v75 - 1);
        uint64_t v79 = *(void *)(v74 + 16 * v77);
        if (v76 == v79)
        {
          BOOL v78 = (uint64_t *)(v74 + 16 * v77);
          goto LABEL_100;
        }
      }
    }
    BOOL v78 = (uint64_t *)(v74 + 16 * v75);
LABEL_100:
    if (v78 == (uint64_t *)(v74 + 16 * v75)) {
      uint64_t v89 = 0;
    }
    else {
      uint64_t v89 = v78[1];
    }
    uint64_t v90 = *(void *)(v72 + 40);
    if (v75)
    {
      LODWORD(v91) = ((v90 >> 4) ^ (v90 >> 9)) & (v75 - 1);
      uint64_t v92 = (uint64_t *)(v74 + 16 * v91);
      uint64_t v93 = *v92;
      if (v90 == *v92) {
        goto LABEL_121;
      }
      int v94 = 1;
      while (v93 != -4096)
      {
        int v95 = v91 + v94++;
        uint64_t v91 = v95 & (v75 - 1);
        uint64_t v93 = *(void *)(v74 + 16 * v91);
        if (v90 == v93)
        {
          uint64_t v92 = (uint64_t *)(v74 + 16 * v91);
          goto LABEL_121;
        }
      }
    }
    uint64_t v92 = (uint64_t *)(v74 + 16 * v75);
LABEL_121:
    if (v92 == (uint64_t *)(v74 + 16 * v75)) {
      uint64_t v98 = 0;
    }
    else {
      uint64_t v98 = v92[1];
    }
    if (v89 == v98)
    {
      int v99 = *(__int16 *)(v90 + 18);
      if ((v99 & 0x80000000) == 0)
      {
        uint64_t v112 = *(void *)(v90 + 48);
        if (v112 != v90 + 40)
        {
          int v113 = 0;
          do
          {
            uint64_t v114 = v112 - 24;
            if (!v112) {
              uint64_t v114 = 0;
            }
            *(_DWORD *)(v114 + 56) = v113++;
            uint64_t v112 = *(void *)(v112 + 8);
          }
          while (v112 != v90 + 40);
        }
        *(_WORD *)(v90 + 18) = v99 | 0x8000;
      }
      if (*(_DWORD *)(v72 + 56) >= *(_DWORD *)(v71 + 56)) {
        return result;
      }
    }
    else if (*(_DWORD *)(v89 + 72) >= *(_DWORD *)(v98 + 72))
    {
      return result;
    }
    *unint64_t result = v71;
    *a2 = v72;
    return result;
  }
  uint64_t v27 = *a3;
  if (v9)
  {
    uint64_t v28 = *(void *)(v27 + 40);
    LODWORD(v29) = ((v28 >> 4) ^ (v28 >> 9)) & (v9 - 1);
    int v30 = (uint64_t *)(v8 + 16 * v29);
    uint64_t v31 = *v30;
    if (v28 == *v30) {
      goto LABEL_39;
    }
    int v32 = 1;
    while (v31 != -4096)
    {
      int v33 = v29 + v32++;
      uint64_t v29 = v33 & (v9 - 1);
      uint64_t v31 = *(void *)(v8 + 16 * v29);
      if (v28 == v31)
      {
        int v30 = (uint64_t *)(v8 + 16 * v29);
        goto LABEL_39;
      }
    }
  }
  int v30 = (uint64_t *)(v8 + 16 * v9);
LABEL_39:
  if (v30 == (uint64_t *)(v8 + 16 * v9))
  {
    uint64_t v41 = 0;
    if (!v9) {
      goto LABEL_58;
    }
  }
  else
  {
    uint64_t v41 = v30[1];
    if (!v9) {
      goto LABEL_58;
    }
  }
  LODWORD(v42) = (v10 ^ (v7 >> 9)) & (v9 - 1);
  uint64_t v43 = (uint64_t *)(v8 + 16 * v42);
  uint64_t v44 = *v43;
  if (v7 == *v43) {
    goto LABEL_59;
  }
  int v45 = 1;
  while (v44 != -4096)
  {
    int v46 = v42 + v45++;
    uint64_t v42 = v46 & (v9 - 1);
    uint64_t v44 = *(void *)(v8 + 16 * v42);
    if (v7 == v44)
    {
      uint64_t v43 = (uint64_t *)(v8 + 16 * v42);
      goto LABEL_59;
    }
  }
LABEL_58:
  uint64_t v43 = (uint64_t *)(v8 + 16 * v9);
LABEL_59:
  if (v43 == (uint64_t *)(v8 + 16 * v9)) {
    uint64_t v53 = 0;
  }
  else {
    uint64_t v53 = v43[1];
  }
  if (v41 == v53)
  {
    int v56 = *(__int16 *)(v7 + 18);
    if ((v56 & 0x80000000) == 0)
    {
      uint64_t v103 = *(void *)(v7 + 48);
      if (v103 != v7 + 40)
      {
        int v104 = 0;
        do
        {
          uint64_t v105 = v103 - 24;
          if (!v103) {
            uint64_t v105 = 0;
          }
          *(_DWORD *)(v105 + 56) = v104++;
          uint64_t v103 = *(void *)(v103 + 8);
        }
        while (v103 != v7 + 40);
      }
      *(_WORD *)(v7 + 18) = v56 | 0x8000;
    }
    unsigned int v54 = *(_DWORD *)(v4 + 56);
    unsigned int v55 = *(_DWORD *)(v27 + 56);
  }
  else
  {
    unsigned int v54 = *(_DWORD *)(v41 + 72);
    unsigned int v55 = *(_DWORD *)(v53 + 72);
  }
  if (v54 < v55)
  {
    *unint64_t result = v27;
LABEL_119:
    *a3 = v5;
    return result;
  }
  *unint64_t result = v4;
  *a2 = v5;
  uint64_t v57 = *a3;
  uint64_t v58 = *(void *)(*(void *)a4 + 1960);
  uint64_t v59 = *(void *)(v58 + 24);
  uint64_t v60 = *(unsigned int *)(v58 + 40);
  if (v60)
  {
    uint64_t v61 = *(void *)(v57 + 40);
    LODWORD(v62) = ((v61 >> 4) ^ (v61 >> 9)) & (v60 - 1);
    int v63 = (uint64_t *)(v59 + 16 * v62);
    uint64_t v64 = *v63;
    if (v61 == *v63) {
      goto LABEL_90;
    }
    int v65 = 1;
    while (v64 != -4096)
    {
      int v66 = v62 + v65++;
      uint64_t v62 = v66 & (v60 - 1);
      uint64_t v64 = *(void *)(v59 + 16 * v62);
      if (v61 == v64)
      {
        int v63 = (uint64_t *)(v59 + 16 * v62);
        goto LABEL_90;
      }
    }
  }
  int v63 = (uint64_t *)(v59 + 16 * v60);
LABEL_90:
  if (v63 == (uint64_t *)(v59 + 16 * v60)) {
    uint64_t v82 = 0;
  }
  else {
    uint64_t v82 = v63[1];
  }
  uint64_t v83 = *(void *)(v5 + 40);
  if (!v60)
  {
LABEL_109:
    int v85 = (uint64_t *)(v59 + 16 * v60);
    goto LABEL_110;
  }
  LODWORD(v84) = ((v83 >> 4) ^ (v83 >> 9)) & (v60 - 1);
  int v85 = (uint64_t *)(v59 + 16 * v84);
  uint64_t v86 = *v85;
  if (v83 != *v85)
  {
    int v87 = 1;
    while (v86 != -4096)
    {
      int v88 = v84 + v87++;
      uint64_t v84 = v88 & (v60 - 1);
      uint64_t v86 = *(void *)(v59 + 16 * v84);
      if (v83 == v86)
      {
        int v85 = (uint64_t *)(v59 + 16 * v84);
        goto LABEL_110;
      }
    }
    goto LABEL_109;
  }
LABEL_110:
  if (v85 == (uint64_t *)(v59 + 16 * v60)) {
    uint64_t v96 = 0;
  }
  else {
    uint64_t v96 = v85[1];
  }
  if (v82 != v96)
  {
    if (*(_DWORD *)(v82 + 72) >= *(_DWORD *)(v96 + 72)) {
      return result;
    }
LABEL_118:
    *a2 = v57;
    goto LABEL_119;
  }
  int v97 = *(__int16 *)(v83 + 18);
  if ((v97 & 0x80000000) == 0)
  {
    uint64_t v109 = *(void *)(v83 + 48);
    if (v109 != v83 + 40)
    {
      int v110 = 0;
      do
      {
        uint64_t v111 = v109 - 24;
        if (!v109) {
          uint64_t v111 = 0;
        }
        *(_DWORD *)(v111 + 56) = v110++;
        uint64_t v109 = *(void *)(v109 + 8);
      }
      while (v109 != v83 + 40);
    }
    *(_WORD *)(v83 + 18) = v97 | 0x8000;
  }
  if (*(_DWORD *)(v5 + 56) < *(_DWORD *)(v57 + 56)) {
    goto LABEL_118;
  }
  return result;
}

BOOL sub_1CD3478FC(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v8 = *(a2 - 1);
      uint64_t v9 = *a1;
      uint64_t v10 = *(void *)(*(void *)a3 + 1960);
      uint64_t v11 = *(void *)(v10 + 24);
      uint64_t v12 = *(unsigned int *)(v10 + 40);
      if (!v12) {
        goto LABEL_88;
      }
      uint64_t v13 = *(void *)(v8 + 40);
      LODWORD(v14) = ((v13 >> 4) ^ (v13 >> 9)) & (v12 - 1);
      int v15 = (uint64_t *)(v11 + 16 * v14);
      uint64_t v16 = *v15;
      if (v13 == *v15) {
        goto LABEL_89;
      }
      int v17 = 1;
      while (v16 != -4096)
      {
        int v18 = v14 + v17++;
        uint64_t v14 = v18 & (v12 - 1);
        uint64_t v16 = *(void *)(v11 + 16 * v14);
        if (v13 == v16)
        {
          int v15 = (uint64_t *)(v11 + 16 * v14);
          goto LABEL_89;
        }
      }
LABEL_88:
      int v15 = (uint64_t *)(v11 + 16 * v12);
LABEL_89:
      if (v15 == (uint64_t *)(v11 + 16 * v12)) {
        uint64_t v82 = 0;
      }
      else {
        uint64_t v82 = v15[1];
      }
      uint64_t v83 = *(void *)(v9 + 40);
      if (!v12) {
        goto LABEL_108;
      }
      LODWORD(v84) = ((v83 >> 4) ^ (v83 >> 9)) & (v12 - 1);
      int v85 = (uint64_t *)(v11 + 16 * v84);
      uint64_t v86 = *v85;
      if (v83 != *v85)
      {
        int v87 = 1;
        while (v86 != -4096)
        {
          int v88 = v84 + v87++;
          uint64_t v84 = v88 & (v12 - 1);
          uint64_t v86 = *(void *)(v11 + 16 * v84);
          if (v83 == v86)
          {
            int v85 = (uint64_t *)(v11 + 16 * v84);
            goto LABEL_109;
          }
        }
LABEL_108:
        int v85 = (uint64_t *)(v11 + 16 * v12);
      }
LABEL_109:
      if (v85 == (uint64_t *)(v11 + 16 * v12)) {
        uint64_t v96 = 0;
      }
      else {
        uint64_t v96 = v85[1];
      }
      if (v82 != v96)
      {
        if (*(_DWORD *)(v82 + 72) >= *(_DWORD *)(v96 + 72)) {
          return 1;
        }
        goto LABEL_117;
      }
      int v97 = *(__int16 *)(v83 + 18);
      if ((v97 & 0x80000000) == 0)
      {
        uint64_t v149 = *(void *)(v83 + 48);
        if (v149 != v83 + 40)
        {
          int v150 = 0;
          do
          {
            uint64_t v151 = v149 - 24;
            if (!v149) {
              uint64_t v151 = 0;
            }
            *(_DWORD *)(v151 + 56) = v150++;
            uint64_t v149 = *(void *)(v149 + 8);
          }
          while (v149 != v83 + 40);
        }
        *(_WORD *)(v83 + 18) = v97 | 0x8000;
      }
      if (*(_DWORD *)(v9 + 56) < *(_DWORD *)(v8 + 56))
      {
LABEL_117:
        *a1 = v8;
        *(a2 - 1) = v9;
        return 1;
      }
      return 1;
    case 3:
      sub_1CD3471D4(a1, a1 + 1, a2 - 1, a3);
      return 1;
    case 4:
      sub_1CD3484B4(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      unsigned int v69 = a1 + 2;
      int v70 = a1 + 3;
      sub_1CD3484B4(a1, a1 + 1, a1 + 2, a1 + 3, a3);
      uint64_t v71 = *(a2 - 1);
      uint64_t v72 = a1[3];
      uint64_t v73 = *(void *)(*(void *)a3 + 1960);
      uint64_t v74 = *(void *)(v73 + 24);
      uint64_t v75 = *(unsigned int *)(v73 + 40);
      if (!v75) {
        goto LABEL_98;
      }
      uint64_t v76 = *(void *)(v71 + 40);
      LODWORD(v77) = ((v76 >> 4) ^ (v76 >> 9)) & (v75 - 1);
      BOOL v78 = (uint64_t *)(v74 + 16 * v77);
      uint64_t v79 = *v78;
      if (v76 == *v78) {
        goto LABEL_99;
      }
      int v80 = 1;
      while (v79 != -4096)
      {
        int v81 = v77 + v80++;
        uint64_t v77 = v81 & (v75 - 1);
        uint64_t v79 = *(void *)(v74 + 16 * v77);
        if (v76 == v79)
        {
          BOOL v78 = (uint64_t *)(v74 + 16 * v77);
          goto LABEL_99;
        }
      }
LABEL_98:
      BOOL v78 = (uint64_t *)(v74 + 16 * v75);
LABEL_99:
      if (v78 == (uint64_t *)(v74 + 16 * v75)) {
        uint64_t v89 = 0;
      }
      else {
        uint64_t v89 = v78[1];
      }
      uint64_t v90 = *(void *)(v72 + 40);
      if (!v75) {
        goto LABEL_118;
      }
      LODWORD(v91) = ((v90 >> 4) ^ (v90 >> 9)) & (v75 - 1);
      uint64_t v92 = (uint64_t *)(v74 + 16 * v91);
      uint64_t v93 = *v92;
      if (v90 != *v92)
      {
        int v94 = 1;
        while (v93 != -4096)
        {
          int v95 = v91 + v94++;
          uint64_t v91 = v95 & (v75 - 1);
          uint64_t v93 = *(void *)(v74 + 16 * v91);
          if (v90 == v93)
          {
            uint64_t v92 = (uint64_t *)(v74 + 16 * v91);
            goto LABEL_119;
          }
        }
LABEL_118:
        uint64_t v92 = (uint64_t *)(v74 + 16 * v75);
      }
LABEL_119:
      if (v92 == (uint64_t *)(v74 + 16 * v75)) {
        uint64_t v98 = 0;
      }
      else {
        uint64_t v98 = v92[1];
      }
      if (v89 == v98)
      {
        int v99 = *(__int16 *)(v90 + 18);
        if ((v99 & 0x80000000) == 0)
        {
          uint64_t v152 = *(void *)(v90 + 48);
          if (v152 != v90 + 40)
          {
            int v153 = 0;
            do
            {
              uint64_t v154 = v152 - 24;
              if (!v152) {
                uint64_t v154 = 0;
              }
              *(_DWORD *)(v154 + 56) = v153++;
              uint64_t v152 = *(void *)(v152 + 8);
            }
            while (v152 != v90 + 40);
          }
          *(_WORD *)(v90 + 18) = v99 | 0x8000;
        }
        if (*(_DWORD *)(v72 + 56) >= *(_DWORD *)(v71 + 56)) {
          return 1;
        }
      }
      else if (*(_DWORD *)(v89 + 72) >= *(_DWORD *)(v98 + 72))
      {
        return 1;
      }
      *int v70 = v71;
      *(a2 - 1) = v72;
      uint64_t v100 = *v70;
      uint64_t v101 = *v69;
      uint64_t v102 = *(void *)(*(void *)a3 + 1960);
      uint64_t v103 = *(void *)(v102 + 24);
      uint64_t v104 = *(unsigned int *)(v102 + 40);
      if (!v104) {
        goto LABEL_133;
      }
      uint64_t v105 = *(void *)(v100 + 40);
      LODWORD(v106) = ((v105 >> 4) ^ (v105 >> 9)) & (v104 - 1);
      int v107 = (uint64_t *)(v103 + 16 * v106);
      uint64_t v108 = *v107;
      if (v105 != *v107)
      {
        int v109 = 1;
        while (v108 != -4096)
        {
          int v110 = v106 + v109++;
          uint64_t v106 = v110 & (v104 - 1);
          uint64_t v108 = *(void *)(v103 + 16 * v106);
          if (v105 == v108)
          {
            int v107 = (uint64_t *)(v103 + 16 * v106);
            goto LABEL_134;
          }
        }
LABEL_133:
        int v107 = (uint64_t *)(v103 + 16 * v104);
      }
LABEL_134:
      if (v107 == (uint64_t *)(v103 + 16 * v104)) {
        uint64_t v111 = 0;
      }
      else {
        uint64_t v111 = v107[1];
      }
      uint64_t v112 = *(void *)(v101 + 40);
      if (!v104) {
        goto LABEL_143;
      }
      LODWORD(v113) = ((v112 >> 4) ^ (v112 >> 9)) & (v104 - 1);
      uint64_t v114 = (uint64_t *)(v103 + 16 * v113);
      uint64_t v115 = *v114;
      if (v112 != *v114)
      {
        int v116 = 1;
        while (v115 != -4096)
        {
          int v117 = v113 + v116++;
          uint64_t v113 = v117 & (v104 - 1);
          uint64_t v115 = *(void *)(v103 + 16 * v113);
          if (v112 == v115)
          {
            uint64_t v114 = (uint64_t *)(v103 + 16 * v113);
            goto LABEL_144;
          }
        }
LABEL_143:
        uint64_t v114 = (uint64_t *)(v103 + 16 * v104);
      }
LABEL_144:
      if (v114 == (uint64_t *)(v103 + 16 * v104)) {
        uint64_t v118 = 0;
      }
      else {
        uint64_t v118 = v114[1];
      }
      if (v111 == v118)
      {
        int v119 = *(__int16 *)(v112 + 18);
        if ((v119 & 0x80000000) == 0)
        {
          uint64_t v164 = *(void *)(v112 + 48);
          if (v164 != v112 + 40)
          {
            int v165 = 0;
            do
            {
              uint64_t v166 = v164 - 24;
              if (!v164) {
                uint64_t v166 = 0;
              }
              *(_DWORD *)(v166 + 56) = v165++;
              uint64_t v164 = *(void *)(v164 + 8);
            }
            while (v164 != v112 + 40);
          }
          *(_WORD *)(v112 + 18) = v119 | 0x8000;
        }
        if (*(_DWORD *)(v101 + 56) >= *(_DWORD *)(v100 + 56)) {
          return 1;
        }
      }
      else if (*(_DWORD *)(v111 + 72) >= *(_DWORD *)(v118 + 72))
      {
        return 1;
      }
      uint64_t *v69 = v100;
      *int v70 = v101;
      uint64_t v120 = a1[1];
      uint64_t v121 = *(void *)(*(void *)a3 + 1960);
      uint64_t v122 = *(void *)(v121 + 24);
      uint64_t v123 = *(unsigned int *)(v121 + 40);
      if (!v123) {
        goto LABEL_158;
      }
      uint64_t v124 = *(void *)(v100 + 40);
      LODWORD(v125) = ((v124 >> 4) ^ (v124 >> 9)) & (v123 - 1);
      uint64_t v126 = (uint64_t *)(v122 + 16 * v125);
      uint64_t v127 = *v126;
      if (v124 != *v126)
      {
        int v128 = 1;
        while (v127 != -4096)
        {
          int v129 = v125 + v128++;
          uint64_t v125 = v129 & (v123 - 1);
          uint64_t v127 = *(void *)(v122 + 16 * v125);
          if (v124 == v127)
          {
            uint64_t v126 = (uint64_t *)(v122 + 16 * v125);
            goto LABEL_159;
          }
        }
LABEL_158:
        uint64_t v126 = (uint64_t *)(v122 + 16 * v123);
      }
LABEL_159:
      if (v126 == (uint64_t *)(v122 + 16 * v123)) {
        uint64_t v130 = 0;
      }
      else {
        uint64_t v130 = v126[1];
      }
      uint64_t v131 = *(void *)(v120 + 40);
      if (!v123) {
        goto LABEL_168;
      }
      LODWORD(v132) = ((v131 >> 4) ^ (v131 >> 9)) & (v123 - 1);
      int v133 = (uint64_t *)(v122 + 16 * v132);
      uint64_t v134 = *v133;
      if (v131 != *v133)
      {
        int v135 = 1;
        while (v134 != -4096)
        {
          int v136 = v132 + v135++;
          uint64_t v132 = v136 & (v123 - 1);
          uint64_t v134 = *(void *)(v122 + 16 * v132);
          if (v131 == v134)
          {
            int v133 = (uint64_t *)(v122 + 16 * v132);
            goto LABEL_169;
          }
        }
LABEL_168:
        int v133 = (uint64_t *)(v122 + 16 * v123);
      }
LABEL_169:
      if (v133 == (uint64_t *)(v122 + 16 * v123)) {
        uint64_t v137 = 0;
      }
      else {
        uint64_t v137 = v133[1];
      }
      if (v130 == v137)
      {
        int v138 = *(__int16 *)(v131 + 18);
        if ((v138 & 0x80000000) == 0)
        {
          uint64_t v167 = *(void *)(v131 + 48);
          if (v167 != v131 + 40)
          {
            int v168 = 0;
            do
            {
              uint64_t v169 = v167 - 24;
              if (!v167) {
                uint64_t v169 = 0;
              }
              *(_DWORD *)(v169 + 56) = v168++;
              uint64_t v167 = *(void *)(v167 + 8);
            }
            while (v167 != v131 + 40);
          }
          *(_WORD *)(v131 + 18) = v138 | 0x8000;
        }
        if (*(_DWORD *)(v120 + 56) >= *(_DWORD *)(v100 + 56)) {
          return 1;
        }
      }
      else if (*(_DWORD *)(v130 + 72) >= *(_DWORD *)(v137 + 72))
      {
        return 1;
      }
      a1[1] = v100;
      a1[2] = v120;
      uint64_t v139 = *a1;
      uint64_t v140 = *(void *)(*(void *)a3 + 1960);
      uint64_t v141 = *(void *)(v140 + 24);
      uint64_t v142 = *(unsigned int *)(v140 + 40);
      if (!v142) {
        goto LABEL_195;
      }
      uint64_t v143 = *(void *)(v100 + 40);
      LODWORD(v144) = ((v143 >> 4) ^ (v143 >> 9)) & (v142 - 1);
      int v145 = (uint64_t *)(v141 + 16 * v144);
      uint64_t v146 = *v145;
      if (v143 != *v145)
      {
        int v147 = 1;
        while (v146 != -4096)
        {
          int v148 = v144 + v147++;
          uint64_t v144 = v148 & (v142 - 1);
          uint64_t v146 = *(void *)(v141 + 16 * v144);
          if (v143 == v146)
          {
            int v145 = (uint64_t *)(v141 + 16 * v144);
            goto LABEL_196;
          }
        }
LABEL_195:
        int v145 = (uint64_t *)(v141 + 16 * v142);
      }
LABEL_196:
      if (v145 == (uint64_t *)(v141 + 16 * v142)) {
        uint64_t v155 = 0;
      }
      else {
        uint64_t v155 = v145[1];
      }
      uint64_t v156 = *(void *)(v139 + 40);
      if (!v142) {
        goto LABEL_205;
      }
      LODWORD(v157) = ((v156 >> 4) ^ (v156 >> 9)) & (v142 - 1);
      BOOL v158 = (uint64_t *)(v141 + 16 * v157);
      uint64_t v159 = *v158;
      if (v156 != *v158)
      {
        int v160 = 1;
        while (v159 != -4096)
        {
          int v161 = v157 + v160++;
          uint64_t v157 = v161 & (v142 - 1);
          uint64_t v159 = *(void *)(v141 + 16 * v157);
          if (v156 == v159)
          {
            BOOL v158 = (uint64_t *)(v141 + 16 * v157);
            goto LABEL_206;
          }
        }
LABEL_205:
        BOOL v158 = (uint64_t *)(v141 + 16 * v142);
      }
LABEL_206:
      if (v158 == (uint64_t *)(v141 + 16 * v142)) {
        uint64_t v162 = 0;
      }
      else {
        uint64_t v162 = v158[1];
      }
      if (v155 != v162)
      {
        if (*(_DWORD *)(v155 + 72) >= *(_DWORD *)(v162 + 72)) {
          return 1;
        }
        goto LABEL_211;
      }
      int v163 = *(__int16 *)(v156 + 18);
      if ((v163 & 0x80000000) == 0)
      {
        uint64_t v170 = *(void *)(v156 + 48);
        if (v170 != v156 + 40)
        {
          int v171 = 0;
          do
          {
            uint64_t v172 = v170 - 24;
            if (!v170) {
              uint64_t v172 = 0;
            }
            *(_DWORD *)(v172 + 56) = v171++;
            uint64_t v170 = *(void *)(v170 + 8);
          }
          while (v170 != v156 + 40);
        }
        *(_WORD *)(v156 + 18) = v163 | 0x8000;
      }
      if (*(_DWORD *)(v139 + 56) < *(_DWORD *)(v100 + 56))
      {
LABEL_211:
        *a1 = v100;
        a1[1] = v139;
      }
      return 1;
    default:
      uint64_t v19 = a1 + 2;
      sub_1CD3471D4(a1, a1 + 1, a1 + 2, a3);
      uint64_t v20 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v21 = 0;
      while (2)
      {
        uint64_t v22 = *v20;
        uint64_t v23 = *(void *)(*(void *)a3 + 1960);
        uint64_t v24 = *(void *)(v23 + 24);
        uint64_t v25 = *(unsigned int *)(v23 + 40);
        if (!v25) {
          goto LABEL_16;
        }
        uint64_t v26 = *(void *)(v22 + 40);
        LODWORD(v27) = ((v26 >> 4) ^ (v26 >> 9)) & (v25 - 1);
        uint64_t v28 = (uint64_t *)(v24 + 16 * v27);
        uint64_t v29 = *v28;
        if (v26 == *v28) {
          goto LABEL_17;
        }
        int v30 = 1;
        while (v29 != -4096)
        {
          int v31 = v27 + v30++;
          uint64_t v27 = v31 & (v25 - 1);
          uint64_t v29 = *(void *)(v24 + 16 * v27);
          if (v26 == v29)
          {
            uint64_t v28 = (uint64_t *)(v24 + 16 * v27);
            goto LABEL_17;
          }
        }
LABEL_16:
        uint64_t v28 = (uint64_t *)(v24 + 16 * v25);
LABEL_17:
        if (v28 == (uint64_t *)(v24 + 16 * v25)) {
          uint64_t v32 = 0;
        }
        else {
          uint64_t v32 = v28[1];
        }
        uint64_t v33 = *v19;
        uint64_t v34 = *(void *)(*v19 + 40);
        if (!v25) {
          goto LABEL_26;
        }
        LODWORD(v35) = ((v34 >> 4) ^ (v34 >> 9)) & (v25 - 1);
        uint64_t v36 = (uint64_t *)(v24 + 16 * v35);
        uint64_t v37 = *v36;
        if (v34 != *v36)
        {
          int v38 = 1;
          while (v37 != -4096)
          {
            int v39 = v35 + v38++;
            uint64_t v35 = v39 & (v25 - 1);
            uint64_t v37 = *(void *)(v24 + 16 * v35);
            if (v34 == v37)
            {
              uint64_t v36 = (uint64_t *)(v24 + 16 * v35);
              goto LABEL_27;
            }
          }
LABEL_26:
          uint64_t v36 = (uint64_t *)(v24 + 16 * v25);
        }
LABEL_27:
        if (v36 == (uint64_t *)(v24 + 16 * v25)) {
          uint64_t v40 = 0;
        }
        else {
          uint64_t v40 = v36[1];
        }
        if (v32 == v40)
        {
          int v41 = *(__int16 *)(v34 + 18);
          if ((v41 & 0x80000000) == 0)
          {
            uint64_t v66 = *(void *)(v34 + 48);
            if (v66 != v34 + 40)
            {
              int v67 = 0;
              do
              {
                uint64_t v68 = v66 - 24;
                if (!v66) {
                  uint64_t v68 = 0;
                }
                *(_DWORD *)(v68 + 56) = v67++;
                uint64_t v66 = *(void *)(v66 + 8);
              }
              while (v66 != v34 + 40);
            }
            *(_WORD *)(v34 + 18) = v41 | 0x8000;
          }
          if (*(_DWORD *)(v33 + 56) >= *(_DWORD *)(v22 + 56)) {
            goto LABEL_71;
          }
        }
        else if (*(_DWORD *)(v32 + 72) >= *(_DWORD *)(v40 + 72))
        {
          goto LABEL_71;
        }
        *uint64_t v20 = v33;
        uint64_t v42 = a1;
        if (v19 == a1) {
          goto LABEL_70;
        }
        while (2)
        {
          uint64_t v43 = *(void *)(*(void *)a3 + 1960);
          uint64_t v44 = *(void *)(v43 + 24);
          uint64_t v45 = *(unsigned int *)(v43 + 40);
          if (!v45) {
            goto LABEL_42;
          }
          uint64_t v46 = *(void *)(v22 + 40);
          LODWORD(v47) = ((v46 >> 4) ^ (v46 >> 9)) & (v45 - 1);
          uint64_t v48 = (uint64_t *)(v44 + 16 * v47);
          uint64_t v49 = *v48;
          if (v46 != *v48)
          {
            int v50 = 1;
            while (v49 != -4096)
            {
              int v51 = v47 + v50++;
              uint64_t v47 = v51 & (v45 - 1);
              uint64_t v49 = *(void *)(v44 + 16 * v47);
              if (v46 == v49)
              {
                uint64_t v48 = (uint64_t *)(v44 + 16 * v47);
                goto LABEL_43;
              }
            }
LABEL_42:
            uint64_t v48 = (uint64_t *)(v44 + 16 * v45);
          }
LABEL_43:
          if (v48 == (uint64_t *)(v44 + 16 * v45)) {
            uint64_t v52 = 0;
          }
          else {
            uint64_t v52 = v48[1];
          }
          uint64_t v53 = v19 - 1;
          uint64_t v54 = *(v19 - 1);
          uint64_t v55 = *(void *)(v54 + 40);
          if (!v45) {
            goto LABEL_52;
          }
          LODWORD(v56) = ((v55 >> 4) ^ (v55 >> 9)) & (v45 - 1);
          uint64_t v57 = (uint64_t *)(v44 + 16 * v56);
          uint64_t v58 = *v57;
          if (v55 != *v57)
          {
            int v59 = 1;
            while (v58 != -4096)
            {
              int v60 = v56 + v59++;
              uint64_t v56 = v60 & (v45 - 1);
              uint64_t v58 = *(void *)(v44 + 16 * v56);
              if (v55 == v58)
              {
                uint64_t v57 = (uint64_t *)(v44 + 16 * v56);
                goto LABEL_53;
              }
            }
LABEL_52:
            uint64_t v57 = (uint64_t *)(v44 + 16 * v45);
          }
LABEL_53:
          if (v57 == (uint64_t *)(v44 + 16 * v45)) {
            uint64_t v61 = 0;
          }
          else {
            uint64_t v61 = v57[1];
          }
          if (v52 != v61)
          {
            if (*(_DWORD *)(v52 + 72) >= *(_DWORD *)(v61 + 72)) {
              break;
            }
            goto LABEL_61;
          }
          int v62 = *(__int16 *)(v55 + 18);
          if ((v62 & 0x80000000) == 0)
          {
            uint64_t v63 = *(void *)(v55 + 48);
            if (v63 != v55 + 40)
            {
              int v64 = 0;
              do
              {
                uint64_t v65 = v63 - 24;
                if (!v63) {
                  uint64_t v65 = 0;
                }
                *(_DWORD *)(v65 + 56) = v64++;
                uint64_t v63 = *(void *)(v63 + 8);
              }
              while (v63 != v55 + 40);
            }
            *(_WORD *)(v55 + 18) = v62 | 0x8000;
          }
          if (*(_DWORD *)(v54 + 56) < *(_DWORD *)(v22 + 56))
          {
LABEL_61:
            *v19-- = v54;
            if (v53 == a1)
            {
              uint64_t v42 = a1;
              goto LABEL_70;
            }
            continue;
          }
          break;
        }
        uint64_t v42 = v19;
LABEL_70:
        uint64_t *v42 = v22;
        if (++v21 != 8)
        {
LABEL_71:
          uint64_t v19 = v20++;
          if (v20 == a2) {
            return 1;
          }
          continue;
        }
        return v20 + 1 == a2;
      }
  }
}

uint64_t *sub_1CD3484B4(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  BOOL result = sub_1CD3471D4(a1, a2, a3, a5);
  uint64_t v11 = *a4;
  uint64_t v12 = *a3;
  uint64_t v13 = *(void *)(*(void *)a5 + 1960);
  uint64_t v14 = *(void *)(v13 + 24);
  uint64_t v15 = *(unsigned int *)(v13 + 40);
  if (v15)
  {
    uint64_t v16 = *(void *)(v11 + 40);
    LODWORD(v17) = ((v16 >> 4) ^ (v16 >> 9)) & (v15 - 1);
    int v18 = (uint64_t *)(v14 + 16 * v17);
    uint64_t v19 = *v18;
    if (v16 == *v18) {
      goto LABEL_8;
    }
    int v20 = 1;
    while (v19 != -4096)
    {
      int v21 = v17 + v20++;
      uint64_t v17 = v21 & (v15 - 1);
      uint64_t v19 = *(void *)(v14 + 16 * v17);
      if (v16 == v19)
      {
        int v18 = (uint64_t *)(v14 + 16 * v17);
        goto LABEL_8;
      }
    }
  }
  int v18 = (uint64_t *)(v14 + 16 * v15);
LABEL_8:
  if (v18 == (uint64_t *)(v14 + 16 * v15)) {
    uint64_t v22 = 0;
  }
  else {
    uint64_t v22 = v18[1];
  }
  uint64_t v23 = *(void *)(v12 + 40);
  if (v15)
  {
    LODWORD(v24) = ((v23 >> 4) ^ (v23 >> 9)) & (v15 - 1);
    uint64_t v25 = (uint64_t *)(v14 + 16 * v24);
    uint64_t v26 = *v25;
    if (v23 == *v25) {
      goto LABEL_18;
    }
    int v27 = 1;
    while (v26 != -4096)
    {
      int v28 = v24 + v27++;
      uint64_t v24 = v28 & (v15 - 1);
      uint64_t v26 = *(void *)(v14 + 16 * v24);
      if (v23 == v26)
      {
        uint64_t v25 = (uint64_t *)(v14 + 16 * v24);
        goto LABEL_18;
      }
    }
  }
  uint64_t v25 = (uint64_t *)(v14 + 16 * v15);
LABEL_18:
  if (v25 == (uint64_t *)(v14 + 16 * v15)) {
    uint64_t v29 = 0;
  }
  else {
    uint64_t v29 = v25[1];
  }
  if (v22 == v29)
  {
    int v30 = *(__int16 *)(v23 + 18);
    if ((v30 & 0x80000000) == 0)
    {
      uint64_t v71 = *(void *)(v23 + 48);
      if (v71 != v23 + 40)
      {
        int v72 = 0;
        do
        {
          uint64_t v73 = v71 - 24;
          if (!v71) {
            uint64_t v73 = 0;
          }
          *(_DWORD *)(v73 + 56) = v72++;
          uint64_t v71 = *(void *)(v71 + 8);
        }
        while (v71 != v23 + 40);
      }
      *(_WORD *)(v23 + 18) = v30 | 0x8000;
    }
    if (*(_DWORD *)(v12 + 56) >= *(_DWORD *)(v11 + 56)) {
      return result;
    }
  }
  else if (*(_DWORD *)(v22 + 72) >= *(_DWORD *)(v29 + 72))
  {
    return result;
  }
  *a3 = v11;
  *a4 = v12;
  uint64_t v31 = *a3;
  uint64_t v32 = *a2;
  uint64_t v33 = *(void *)(*(void *)a5 + 1960);
  uint64_t v34 = *(void *)(v33 + 24);
  uint64_t v35 = *(unsigned int *)(v33 + 40);
  if (v35)
  {
    uint64_t v36 = *(void *)(v31 + 40);
    LODWORD(v37) = ((v36 >> 4) ^ (v36 >> 9)) & (v35 - 1);
    int v38 = (uint64_t *)(v34 + 16 * v37);
    uint64_t v39 = *v38;
    if (v36 == *v38) {
      goto LABEL_33;
    }
    int v40 = 1;
    while (v39 != -4096)
    {
      int v41 = v37 + v40++;
      uint64_t v37 = v41 & (v35 - 1);
      uint64_t v39 = *(void *)(v34 + 16 * v37);
      if (v36 == v39)
      {
        int v38 = (uint64_t *)(v34 + 16 * v37);
        goto LABEL_33;
      }
    }
  }
  int v38 = (uint64_t *)(v34 + 16 * v35);
LABEL_33:
  if (v38 == (uint64_t *)(v34 + 16 * v35)) {
    uint64_t v42 = 0;
  }
  else {
    uint64_t v42 = v38[1];
  }
  uint64_t v43 = *(void *)(v32 + 40);
  if (v35)
  {
    LODWORD(v44) = ((v43 >> 4) ^ (v43 >> 9)) & (v35 - 1);
    uint64_t v45 = (uint64_t *)(v34 + 16 * v44);
    uint64_t v46 = *v45;
    if (v43 == *v45) {
      goto LABEL_43;
    }
    int v47 = 1;
    while (v46 != -4096)
    {
      int v48 = v44 + v47++;
      uint64_t v44 = v48 & (v35 - 1);
      uint64_t v46 = *(void *)(v34 + 16 * v44);
      if (v43 == v46)
      {
        uint64_t v45 = (uint64_t *)(v34 + 16 * v44);
        goto LABEL_43;
      }
    }
  }
  uint64_t v45 = (uint64_t *)(v34 + 16 * v35);
LABEL_43:
  if (v45 == (uint64_t *)(v34 + 16 * v35)) {
    uint64_t v49 = 0;
  }
  else {
    uint64_t v49 = v45[1];
  }
  if (v42 == v49)
  {
    int v50 = *(__int16 *)(v43 + 18);
    if ((v50 & 0x80000000) == 0)
    {
      uint64_t v74 = *(void *)(v43 + 48);
      if (v74 != v43 + 40)
      {
        int v75 = 0;
        do
        {
          uint64_t v76 = v74 - 24;
          if (!v74) {
            uint64_t v76 = 0;
          }
          *(_DWORD *)(v76 + 56) = v75++;
          uint64_t v74 = *(void *)(v74 + 8);
        }
        while (v74 != v43 + 40);
      }
      *(_WORD *)(v43 + 18) = v50 | 0x8000;
    }
    if (*(_DWORD *)(v32 + 56) >= *(_DWORD *)(v31 + 56)) {
      return result;
    }
  }
  else if (*(_DWORD *)(v42 + 72) >= *(_DWORD *)(v49 + 72))
  {
    return result;
  }
  *a2 = v31;
  *a3 = v32;
  uint64_t v51 = *a2;
  uint64_t v52 = *a1;
  uint64_t v53 = *(void *)(*(void *)a5 + 1960);
  uint64_t v54 = *(void *)(v53 + 24);
  uint64_t v55 = *(unsigned int *)(v53 + 40);
  if (v55)
  {
    uint64_t v56 = *(void *)(v51 + 40);
    LODWORD(v57) = ((v56 >> 4) ^ (v56 >> 9)) & (v55 - 1);
    uint64_t v58 = (uint64_t *)(v54 + 16 * v57);
    uint64_t v59 = *v58;
    if (v56 == *v58) {
      goto LABEL_58;
    }
    int v60 = 1;
    while (v59 != -4096)
    {
      int v61 = v57 + v60++;
      uint64_t v57 = v61 & (v55 - 1);
      uint64_t v59 = *(void *)(v54 + 16 * v57);
      if (v56 == v59)
      {
        uint64_t v58 = (uint64_t *)(v54 + 16 * v57);
        goto LABEL_58;
      }
    }
  }
  uint64_t v58 = (uint64_t *)(v54 + 16 * v55);
LABEL_58:
  if (v58 == (uint64_t *)(v54 + 16 * v55)) {
    uint64_t v62 = 0;
  }
  else {
    uint64_t v62 = v58[1];
  }
  uint64_t v63 = *(void *)(v52 + 40);
  if (!v55)
  {
LABEL_67:
    uint64_t v65 = (uint64_t *)(v54 + 16 * v55);
    goto LABEL_68;
  }
  LODWORD(v64) = ((v63 >> 4) ^ (v63 >> 9)) & (v55 - 1);
  uint64_t v65 = (uint64_t *)(v54 + 16 * v64);
  uint64_t v66 = *v65;
  if (v63 != *v65)
  {
    int v67 = 1;
    while (v66 != -4096)
    {
      int v68 = v64 + v67++;
      uint64_t v64 = v68 & (v55 - 1);
      uint64_t v66 = *(void *)(v54 + 16 * v64);
      if (v63 == v66)
      {
        uint64_t v65 = (uint64_t *)(v54 + 16 * v64);
        goto LABEL_68;
      }
    }
    goto LABEL_67;
  }
LABEL_68:
  if (v65 == (uint64_t *)(v54 + 16 * v55)) {
    uint64_t v69 = 0;
  }
  else {
    uint64_t v69 = v65[1];
  }
  if (v62 != v69)
  {
    if (*(_DWORD *)(v62 + 72) >= *(_DWORD *)(v69 + 72)) {
      return result;
    }
    goto LABEL_73;
  }
  int v70 = *(__int16 *)(v63 + 18);
  if ((v70 & 0x80000000) == 0)
  {
    uint64_t v77 = *(void *)(v63 + 48);
    if (v77 != v63 + 40)
    {
      int v78 = 0;
      do
      {
        uint64_t v79 = v77 - 24;
        if (!v77) {
          uint64_t v79 = 0;
        }
        *(_DWORD *)(v79 + 56) = v78++;
        uint64_t v77 = *(void *)(v77 + 8);
      }
      while (v77 != v63 + 40);
    }
    *(_WORD *)(v63 + 18) = v70 | 0x8000;
  }
  if (*(_DWORD *)(v52 + 56) < *(_DWORD *)(v51 + 56))
  {
LABEL_73:
    *a1 = v51;
    *a2 = v52;
  }
  return result;
}

uint64_t sub_1CD348970(uint64_t a1, uint64_t a2)
{
  return sub_1CD3444F4(a2, *(void *)(*(void *)a1 + 384), *(void *)(*(void *)a1 + 392));
}

void sub_1CD348984(uint64_t *a1, uint64_t a2)
{
  unint64_t v4 = a1[2];
  unint64_t v5 = a1[1];
  if (v5 >= v4)
  {
    unint64_t v11 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v5 - *a1) >> 3);
    if (v11 + 1 > 0x666666666666666) {
      abort();
    }
    unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v4 - *a1) >> 3);
    uint64_t v13 = 2 * v12;
    if (2 * v12 <= v11 + 1) {
      uint64_t v13 = v11 + 1;
    }
    if (v12 >= 0x333333333333333) {
      unint64_t v14 = 0x666666666666666;
    }
    else {
      unint64_t v14 = v13;
    }
    int v30 = a1 + 2;
    if (v14 > 0x666666666666666) {
      sub_1CB833614();
    }
    uint64_t v15 = 5 * v14;
    uint64_t v16 = (char *)operator new(40 * v14);
    uint64_t v17 = &v16[40 * v11];
    __p = v16;
    int v27 = v17;
    uint64_t v29 = &v16[8 * v15];
    *(void *)uint64_t v17 = *(void *)a2;
    *((void *)v17 + 1) = v17 + 24;
    int v18 = v17 + 8;
    *((void *)v17 + 2) = 0x200000000;
    unsigned int v19 = *(_DWORD *)(a2 + 16);
    if (v19 && v18 != (void *)(a2 + 8))
    {
      int v20 = *(const void **)(a2 + 8);
      if (v20 == (const void *)(a2 + 24))
      {
        if (v19 >= 3)
        {
          *((_DWORD *)v17 + 4) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        memcpy(v17 + 24, v20, 8 * *(unsigned int *)(a2 + 16));
        *((_DWORD *)v17 + 4) = v19;
      }
      else
      {
        *int v18 = v20;
        int v25 = *(_DWORD *)(a2 + 20);
        *((_DWORD *)v17 + 4) = v19;
        *((_DWORD *)v17 + 5) = v25;
        *(void *)(a2 + 8) = a2 + 24;
        *(_DWORD *)(a2 + 20) = 0;
      }
      *(_DWORD *)(a2 + 16) = 0;
    }
    int v28 = v17 + 40;
    sub_1CD8E70B0(a1, &__p);
    uint64_t v10 = a1[1];
    int v21 = v27;
    if (v28 != v27)
    {
      uint64_t v22 = v28 - 16;
      do
      {
        uint64_t v23 = (char *)*((void *)v22 - 2);
        if (v22 != v23) {
          free(v23);
        }
        uint64_t v24 = v22 - 24;
        v22 -= 40;
      }
      while (v24 != v21);
    }
    if (__p) {
      operator delete(__p);
    }
  }
  else
  {
    *(void *)unint64_t v5 = *(void *)a2;
    *(void *)(v5 + 8) = v5 + 24;
    *(void *)(v5 + 16) = 0x200000000;
    unsigned int v6 = *(_DWORD *)(a2 + 16);
    if (v6) {
      BOOL v7 = v5 == a2;
    }
    else {
      BOOL v7 = 1;
    }
    if (!v7)
    {
      uint64_t v8 = *(void *)(a2 + 8);
      uint64_t v9 = (const void *)(a2 + 24);
      if (v8 == a2 + 24)
      {
        if (v6 >= 3) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        memcpy((void *)(v5 + 24), v9, 8 * *(unsigned int *)(a2 + 16));
        *(_DWORD *)(v5 + 16) = v6;
      }
      else
      {
        *(void *)(v5 + 8) = v8;
        *(_DWORD *)(v5 + 16) = v6;
        *(_DWORD *)(v5 + 20) = *(_DWORD *)(a2 + 20);
        *(void *)(a2 + 8) = v9;
        *(_DWORD *)(a2 + 20) = 0;
      }
      *(_DWORD *)(a2 + 16) = 0;
    }
    uint64_t v10 = v5 + 40;
  }
  a1[1] = v10;
}

char *sub_1CD348C28(uint64_t a1, char *a2)
{
  unint64_t v4 = *(char **)(a1 + 8);
  unint64_t v5 = a2 + 40;
  if (a2 + 40 == v4)
  {
    uint64_t v15 = a2;
  }
  else
  {
    unsigned int v6 = a2;
    do
    {
      BOOL v7 = (char *)*((void *)v5 + 1);
      *((void *)v5 - 5) = *(void *)v5;
      if (v5 + 24 == v7)
      {
        uint64_t v8 = (void **)(v5 - 32);
        uint64_t v10 = v5 + 16;
        uint64_t v9 = *((unsigned int *)v5 + 4);
        uint64_t v11 = *((unsigned int *)v5 - 6);
        if (v11 >= v9)
        {
          if (v9) {
            memmove(*v8, v7, 8 * v9);
          }
        }
        else
        {
          if (*((_DWORD *)v5 - 5) < v9)
          {
            *((_DWORD *)v5 - 6) = 0;
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          if (v11)
          {
            uint64_t v20 = *((unsigned int *)v5 - 6);
            memmove(*v8, v7, 8 * v11);
            uint64_t v12 = v20;
          }
          else
          {
            uint64_t v12 = 0;
          }
          uint64_t v13 = *v10;
          if (v12 != v13) {
            memcpy((void *)(*((void *)v5 - 4) + 8 * v12), (const void *)(*((void *)v5 + 1) + 8 * v12), 8 * v13 - 8 * v12);
          }
        }
        *((_DWORD *)v5 - 6) = v9;
      }
      else
      {
        unint64_t v14 = (char *)*((void *)v5 - 4);
        if (v5 - 16 != v14)
        {
          free(v14);
          BOOL v7 = (char *)*((void *)v5 + 1);
        }
        *((void *)v5 - 4) = v7;
        uint64_t v10 = v6 + 56;
        *((void *)v5 - 3) = *((void *)v5 + 2);
        *((void *)v5 + 1) = v5 + 24;
        *((_DWORD *)v5 + 5) = 0;
      }
      _DWORD *v10 = 0;
      v6 += 40;
      v5 += 40;
    }
    while (v5 != v4);
    unint64_t v4 = *(char **)(a1 + 8);
    uint64_t v15 = v5 - 40;
  }
  if (v4 != v15)
  {
    uint64_t v16 = v4 - 16;
    do
    {
      uint64_t v17 = (char *)*((void *)v16 - 2);
      if (v16 != v17) {
        free(v17);
      }
      int v18 = v16 - 24;
      v16 -= 40;
    }
    while (v18 != v15);
  }
  *(void *)(a1 + 8) = v15;
  return a2;
}

uint64_t *sub_1CD348DC4(uint64_t *result, uint64_t *a2, uint64_t a3, char a4)
{
  uint64_t v9 = result;
  while (2)
  {
    uint64_t v10 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v9 = v10;
          uint64_t v11 = (char *)a2 - (char *)v10;
          uint64_t v12 = a2 - v10;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0:
              case 1:
                return result;
              case 2:
                uint64_t v39 = *(a2 - 1);
                uint64_t v40 = *v10;
                if (*(_DWORD *)(v39 + 72) < *(_DWORD *)(*v10 + 72))
                {
                  uint64_t *v10 = v39;
                  *(a2 - 1) = v40;
                }
                break;
              case 3:
                BOOL result = sub_1CC3463C4(v10, v10 + 1, a2 - 1);
                break;
              case 4:
                BOOL result = sub_1CC346778(v10, v10 + 1, v10 + 2, a2 - 1);
                break;
              case 5:
                int v41 = v10 + 1;
                uint64_t v42 = v10 + 2;
                uint64_t v43 = v10 + 3;
                BOOL result = sub_1CC346778(v10, v10 + 1, v10 + 2, v10 + 3);
                uint64_t v44 = *(a2 - 1);
                uint64_t v45 = v10[3];
                if (*(_DWORD *)(v44 + 72) < *(_DWORD *)(v45 + 72))
                {
                  *uint64_t v43 = v44;
                  *(a2 - 1) = v45;
                  uint64_t v46 = *v43;
                  uint64_t v47 = *v42;
                  unsigned int v48 = *(_DWORD *)(*v43 + 72);
                  if (v48 < *(_DWORD *)(*v42 + 72))
                  {
                    uint64_t *v42 = v46;
                    *uint64_t v43 = v47;
                    uint64_t v49 = *v41;
                    if (v48 < *(_DWORD *)(*v41 + 72))
                    {
                      v10[1] = v46;
                      v10[2] = v49;
                      uint64_t v50 = *v10;
                      if (v48 < *(_DWORD *)(*v10 + 72))
                      {
                        uint64_t *v10 = v46;
                        v10[1] = v50;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v11 <= 191)
          {
            uint64_t v51 = v10 + 1;
            BOOL v53 = v10 == a2 || v51 == a2;
            if (a4)
            {
              if (!v53)
              {
                uint64_t v54 = 8;
                uint64_t v55 = v10;
                do
                {
                  uint64_t v57 = *v55;
                  uint64_t v56 = v55[1];
                  uint64_t v55 = v51;
                  unsigned int v58 = *(_DWORD *)(v56 + 72);
                  if (v58 < *(_DWORD *)(v57 + 72))
                  {
                    uint64_t v59 = v54;
                    do
                    {
                      *(uint64_t *)((char *)v10 + v59) = v57;
                      uint64_t v60 = v59 - 8;
                      if (v59 == 8)
                      {
                        int v61 = v10;
                        goto LABEL_85;
                      }
                      uint64_t v57 = *(uint64_t *)((char *)v10 + v59 - 16);
                      v59 -= 8;
                    }
                    while (v58 < *(_DWORD *)(v57 + 72));
                    int v61 = (uint64_t *)((char *)v10 + v60);
LABEL_85:
                    *int v61 = v56;
                  }
                  uint64_t v51 = v55 + 1;
                  v54 += 8;
                }
                while (v55 + 1 != a2);
              }
            }
            else if (!v53)
            {
              do
              {
                uint64_t v91 = *v9;
                uint64_t v90 = v9[1];
                uint64_t v9 = v51;
                unsigned int v92 = *(_DWORD *)(v90 + 72);
                if (v92 < *(_DWORD *)(v91 + 72))
                {
                  do
                  {
                    *uint64_t v51 = v91;
                    uint64_t v91 = *(v51 - 2);
                    --v51;
                  }
                  while (v92 < *(_DWORD *)(v91 + 72));
                  *uint64_t v51 = v90;
                }
                uint64_t v51 = v9 + 1;
              }
              while (v9 + 1 != a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v62 = (unint64_t)(v12 - 2) >> 1;
              int64_t v63 = v62;
              do
              {
                int64_t v64 = v63;
                if (v62 >= v63)
                {
                  uint64_t v65 = (2 * v63) | 1;
                  uint64_t v66 = &v10[v65];
                  uint64_t v67 = *v66;
                  if (2 * v64 + 2 < v12 && *(_DWORD *)(v67 + 72) < *(_DWORD *)(v66[1] + 72))
                  {
                    uint64_t v67 = v66[1];
                    ++v66;
                    uint64_t v65 = 2 * v64 + 2;
                  }
                  BOOL result = &v10[v64];
                  uint64_t v68 = *result;
                  unsigned int v69 = *(_DWORD *)(*result + 72);
                  if (*(_DWORD *)(v67 + 72) >= v69)
                  {
                    do
                    {
                      int v70 = v66;
                      *BOOL result = v67;
                      if (v62 < v65) {
                        break;
                      }
                      uint64_t v71 = (2 * v65) | 1;
                      uint64_t v66 = &v10[v71];
                      uint64_t v72 = 2 * v65 + 2;
                      uint64_t v67 = *v66;
                      if (v72 < v12 && *(_DWORD *)(v67 + 72) < *(_DWORD *)(v66[1] + 72))
                      {
                        uint64_t v67 = v66[1];
                        ++v66;
                        uint64_t v71 = v72;
                      }
                      BOOL result = v70;
                      uint64_t v65 = v71;
                    }
                    while (*(_DWORD *)(v67 + 72) >= v69);
                    *int v70 = v68;
                  }
                }
                int64_t v63 = v64 - 1;
              }
              while (v64);
              do
              {
                uint64_t v73 = 0;
                uint64_t v74 = *v10;
                int v75 = v10;
                do
                {
                  uint64_t v76 = &v75[v73];
                  uint64_t v79 = v76[1];
                  uint64_t v77 = v76 + 1;
                  uint64_t v78 = v79;
                  uint64_t v80 = (2 * v73) | 1;
                  uint64_t v81 = 2 * v73 + 2;
                  if (v81 < v12)
                  {
                    BOOL result = (uint64_t *)*(unsigned int *)(v78 + 72);
                    if (result < *(_DWORD *)(v77[1] + 72))
                    {
                      uint64_t v78 = v77[1];
                      ++v77;
                      uint64_t v80 = v81;
                    }
                  }
                  *int v75 = v78;
                  int v75 = v77;
                  uint64_t v73 = v80;
                }
                while (v80 <= (uint64_t)((unint64_t)(v12 - 2) >> 1));
                if (v77 == --a2)
                {
                  *uint64_t v77 = v74;
                }
                else
                {
                  *uint64_t v77 = *a2;
                  *a2 = v74;
                  uint64_t v82 = (char *)v77 - (char *)v10 + 8;
                  if (v82 >= 9)
                  {
                    unint64_t v83 = (((unint64_t)v82 >> 3) - 2) >> 1;
                    uint64_t v84 = &v10[v83];
                    uint64_t v85 = *v84;
                    uint64_t v86 = *v77;
                    unsigned int v87 = *(_DWORD *)(*v77 + 72);
                    if (*(_DWORD *)(*v84 + 72) < v87)
                    {
                      do
                      {
                        int v88 = v84;
                        *uint64_t v77 = v85;
                        if (!v83) {
                          break;
                        }
                        unint64_t v83 = (v83 - 1) >> 1;
                        uint64_t v84 = &v10[v83];
                        uint64_t v85 = *v84;
                        uint64_t v77 = v88;
                      }
                      while (*(_DWORD *)(*v84 + 72) < v87);
                      *int v88 = v86;
                    }
                  }
                }
              }
              while (v12-- > 2);
            }
            return result;
          }
          unint64_t v13 = (unint64_t)v12 >> 1;
          unint64_t v14 = &v10[(unint64_t)v12 >> 1];
          if ((unint64_t)v11 >= 0x401)
          {
            sub_1CC3463C4(v9, &v9[(unint64_t)v12 >> 1], a2 - 1);
            sub_1CC3463C4(v9 + 1, v14 - 1, a2 - 2);
            sub_1CC3463C4(v9 + 2, &v9[v13 + 1], a2 - 3);
            BOOL result = sub_1CC3463C4(v14 - 1, v14, &v9[v13 + 1]);
            uint64_t v15 = *v9;
            *uint64_t v9 = *v14;
            *unint64_t v14 = v15;
          }
          else
          {
            BOOL result = sub_1CC3463C4(&v9[(unint64_t)v12 >> 1], v9, a2 - 1);
          }
          --a3;
          uint64_t v16 = *v9;
          if (a4) {
            break;
          }
          unsigned int v17 = *(_DWORD *)(v16 + 72);
          if (*(_DWORD *)(*(v9 - 1) + 72) < v17) {
            goto LABEL_13;
          }
          if (v17 >= *(_DWORD *)(*(a2 - 1) + 72))
          {
            uint64_t v31 = v9 + 1;
            do
            {
              uint64_t v10 = v31;
              if (v31 >= a2) {
                break;
              }
              ++v31;
            }
            while (v17 >= *(_DWORD *)(*v10 + 72));
          }
          else
          {
            uint64_t v10 = v9;
            do
            {
              uint64_t v30 = v10[1];
              ++v10;
            }
            while (v17 >= *(_DWORD *)(v30 + 72));
          }
          uint64_t v32 = a2;
          if (v10 < a2)
          {
            uint64_t v32 = a2;
            do
              uint64_t v33 = *--v32;
            while (v17 < *(_DWORD *)(v33 + 72));
          }
          if (v10 < v32)
          {
            uint64_t v34 = *v10;
            uint64_t v35 = *v32;
            do
            {
              uint64_t *v10 = v35;
              *uint64_t v32 = v34;
              do
              {
                uint64_t v36 = v10[1];
                ++v10;
                uint64_t v34 = v36;
              }
              while (v17 >= *(_DWORD *)(v36 + 72));
              do
              {
                uint64_t v37 = *--v32;
                uint64_t v35 = v37;
              }
              while (v17 < *(_DWORD *)(v37 + 72));
            }
            while (v10 < v32);
          }
          int v38 = v10 - 1;
          BOOL v4 = v10 - 1 >= v9;
          BOOL v5 = v10 - 1 == v9;
          if (v10 - 1 != v9) {
            *uint64_t v9 = *v38;
          }
          a4 = 0;
          uint64_t *v38 = v16;
        }
        unsigned int v17 = *(_DWORD *)(v16 + 72);
LABEL_13:
        uint64_t v18 = 0;
        do
          uint64_t v19 = v9[++v18];
        while (*(_DWORD *)(v19 + 72) < v17);
        uint64_t v20 = &v9[v18];
        int v21 = a2;
        if (v18 == 1)
        {
          int v21 = a2;
          do
          {
            if (v20 >= v21) {
              break;
            }
            uint64_t v23 = *--v21;
          }
          while (*(_DWORD *)(v23 + 72) >= v17);
        }
        else
        {
          do
            uint64_t v22 = *--v21;
          while (*(_DWORD *)(v22 + 72) >= v17);
        }
        if (v20 >= v21)
        {
          uint64_t v10 = &v9[v18];
        }
        else
        {
          uint64_t v24 = *v21;
          uint64_t v10 = &v9[v18];
          int v25 = v21;
          do
          {
            uint64_t *v10 = v24;
            *int v25 = v19;
            do
            {
              uint64_t v26 = v10[1];
              ++v10;
              uint64_t v19 = v26;
            }
            while (*(_DWORD *)(v26 + 72) < v17);
            do
            {
              uint64_t v27 = *--v25;
              uint64_t v24 = v27;
            }
            while (*(_DWORD *)(v27 + 72) >= v17);
          }
          while (v10 < v25);
        }
        int v28 = v10 - 1;
        if (v10 - 1 != v9) {
          *uint64_t v9 = *v28;
        }
        *int v28 = v16;
        if (v20 >= v21) {
          break;
        }
LABEL_34:
        BOOL result = (uint64_t *)sub_1CD348DC4(v9, v10 - 1, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v29 = sub_1CD3494F0(v9, v10 - 1);
      BOOL result = (uint64_t *)sub_1CD3494F0(v10, a2);
      if (result) {
        break;
      }
      if (!v29) {
        goto LABEL_34;
      }
    }
    a2 = v10 - 1;
    if (!v29) {
      continue;
    }
    return result;
  }
}

BOOL sub_1CD3494F0(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v6 = *(a2 - 1);
      uint64_t v7 = *a1;
      if (*(_DWORD *)(v6 + 72) < *(_DWORD *)(*a1 + 72))
      {
        *a1 = v6;
        *(a2 - 1) = v7;
      }
      return result;
    case 3:
      sub_1CC3463C4(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      sub_1CC346778(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      uint64_t v18 = a1 + 1;
      uint64_t v19 = a1 + 2;
      uint64_t v20 = a1 + 3;
      sub_1CC346778(a1, a1 + 1, a1 + 2, a1 + 3);
      uint64_t v21 = *(a2 - 1);
      uint64_t v22 = a1[3];
      if (*(_DWORD *)(v21 + 72) < *(_DWORD *)(v22 + 72))
      {
        *uint64_t v20 = v21;
        *(a2 - 1) = v22;
        uint64_t v23 = *v20;
        uint64_t v24 = *v19;
        unsigned int v25 = *(_DWORD *)(*v20 + 72);
        if (v25 < *(_DWORD *)(*v19 + 72))
        {
          *uint64_t v19 = v23;
          *uint64_t v20 = v24;
          uint64_t v26 = *v18;
          if (v25 < *(_DWORD *)(*v18 + 72))
          {
            a1[1] = v23;
            a1[2] = v26;
            uint64_t v27 = *a1;
            if (v25 < *(_DWORD *)(*a1 + 72))
            {
              *a1 = v23;
              a1[1] = v27;
            }
          }
        }
      }
      return 1;
    default:
      uint64_t v8 = a1 + 2;
      sub_1CC3463C4(a1, a1 + 1, a1 + 2);
      uint64_t v9 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v10 = 0;
      uint64_t v11 = 24;
      break;
  }
  while (1)
  {
    uint64_t v12 = *v9;
    uint64_t v13 = *v8;
    unsigned int v14 = *(_DWORD *)(*v9 + 72);
    if (v14 < *(_DWORD *)(*v8 + 72))
    {
      uint64_t v15 = v11;
      while (1)
      {
        *(uint64_t *)((char *)a1 + v15) = v13;
        uint64_t v16 = v15 - 8;
        if (v15 == 8) {
          break;
        }
        uint64_t v13 = *(uint64_t *)((char *)a1 + v15 - 16);
        v15 -= 8;
        if (v14 >= *(_DWORD *)(v13 + 72))
        {
          unsigned int v17 = (uint64_t *)((char *)a1 + v16);
          goto LABEL_13;
        }
      }
      unsigned int v17 = a1;
LABEL_13:
      uint64_t *v17 = v12;
      if (++v10 == 8) {
        return v9 + 1 == a2;
      }
    }
    uint64_t v8 = v9;
    v11 += 8;
    if (++v9 == a2) {
      return 1;
    }
  }
}

void sub_1CD3496FC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 - 8);
  if (v2)
  {
    uint64_t v3 = 168 * v2;
    do
    {
      uint64_t v4 = a1 + v3;
      BOOL v5 = *(void **)(a1 + v3 - 72);
      if ((void *)(a1 + v3 - 56) != v5) {
        free(v5);
      }
      uint64_t v6 = *(void **)(v4 - 120);
      if ((void *)(v4 - 104) != v6) {
        free(v6);
      }
      v3 -= 168;
    }
    while (v3);
  }

  JUMPOUT(0x1D25D9CB0);
}

char *sub_1CD34978C(char **a1, void *a2)
{
  uint64_t v2 = (a1[1] - *a1) >> 3;
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 61) {
    abort();
  }
  uint64_t v6 = a1[2] - *a1;
  if (v6 >> 2 > v3) {
    unint64_t v3 = v6 >> 2;
  }
  if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v7 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v7 = v3;
  }
  uint64_t v21 = a1 + 2;
  if (v7)
  {
    if (v7 >> 61) {
      sub_1CB833614();
    }
    uint64_t v8 = (char *)operator new(8 * v7);
  }
  else
  {
    uint64_t v8 = 0;
  }
  uint64_t v9 = &v8[8 * v2];
  int v10 = &v8[8 * v7];
  *(void *)uint64_t v9 = *a2;
  uint64_t v11 = v9 + 8;
  *a2 = 0;
  v19.i64[1] = (uint64_t)(v9 + 8);
  uint64_t v20 = v10;
  uint64_t v13 = *a1;
  uint64_t v12 = a1[1];
  if (v12 == *a1)
  {
    int64x2_t v14 = vdupq_n_s64((unint64_t)v12);
  }
  else
  {
    do
    {
      uint64_t v15 = *((void *)v12 - 1);
      v12 -= 8;
      *(void *)uint64_t v12 = 0;
      *((void *)v9 - 1) = v15;
      v9 -= 8;
    }
    while (v12 != v13);
    int64x2_t v14 = *(int64x2_t *)a1;
    uint64_t v11 = (char *)v19.i64[1];
    int v10 = v20;
  }
  *a1 = v9;
  a1[1] = v11;
  int64x2_t v19 = v14;
  uint64_t v16 = a1[2];
  a1[2] = v10;
  uint64_t v20 = v16;
  uint64_t v18 = v14.i64[0];
  sub_1CD8E72B0((uint64_t)&v18);
  return v11;
}

void sub_1CD349898(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 0;
  *(_DWORD *)(a2 + 156) = *(_DWORD *)(a2 + 152);
}

void sub_1CD3498A8(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a1;
  sub_1CD4C64C4(*a1 + 80, *a2, &v9);
  BOOL v5 = (_DWORD *)a1[1];
  int v6 = (*v5)++;
  uint64_t v7 = a2[3];
  *(_DWORD *)(v7 + 148) = v6;
  if ((uint64_t *)v7 == a2 && (a2[4] || a2[2]))
  {
    uint64_t v8 = a1[2];
    llvm::slpvectorizer::BoUpSLP::BlockScheduling::calculateDependencies(v8, (uint64_t)a2, 0, v4);
  }
}

uint64_t *sub_1CD349954(uint64_t *result, uint64_t a2)
{
  if (*(void *)(a2 + 24) == a2 && *(_DWORD *)(a2 + 152) != -1)
  {
    int v2 = 0;
    uint64_t v3 = a2;
    while (1)
    {
      int v4 = *(_DWORD *)(v3 + 156);
      if (v4 == -1) {
        break;
      }
      v2 += v4;
      uint64_t v3 = *(void *)(v3 + 32);
      if (!v3)
      {
        if (!v2 && !*(unsigned char *)(a2 + 160)) {
          return sub_1CD3499A4((uint64_t *)*result, a2);
        }
        return result;
      }
    }
  }
  return result;
}

uint64_t *sub_1CD3499A4(uint64_t *result, uint64_t a2)
{
  uint64_t v3 = result;
  BOOL v5 = (uint64_t **)(result + 1);
  int v4 = (uint64_t *)result[1];
  if (v4)
  {
    int v6 = *(_DWORD *)(a2 + 148);
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v4;
        int v8 = *(_DWORD *)(v4[4] + 148);
        if (v8 >= v6) {
          break;
        }
        int v4 = *v7;
        BOOL v5 = v7;
        if (!*v7) {
          goto LABEL_10;
        }
      }
      if (v6 >= v8) {
        break;
      }
      int v4 = v7[1];
      if (!v4)
      {
        BOOL v5 = v7 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v7 = (uint64_t **)(result + 1);
LABEL_10:
    uint64_t v9 = (uint64_t *)operator new(0x28uLL);
    int v9[4] = a2;
    *uint64_t v9 = 0;
    v9[1] = 0;
    v9[2] = (uint64_t)v7;
    _DWORD *v5 = v9;
    uint64_t v10 = *(void *)*v3;
    if (v10)
    {
      *uint64_t v3 = v10;
      uint64_t v11 = *v5;
    }
    else
    {
      uint64_t v11 = v9;
    }
    BOOL result = sub_1CB8358B8((uint64_t *)v3[1], v11);
    ++v3[2];
  }
  return result;
}

uint64_t *sub_1CD349A68(uint64_t *result, uint64_t a2)
{
  if (a2 && *(_DWORD *)(a2 + 152) != -1)
  {
    --*(_DWORD *)(a2 + 156);
    uint64_t v2 = *(void *)(a2 + 24);
    if (v2)
    {
      int v3 = 0;
      uint64_t v4 = v2;
      while (1)
      {
        int v5 = *(_DWORD *)(v4 + 156);
        if (v5 == -1) {
          break;
        }
        v3 += v5;
        uint64_t v4 = *(void *)(v4 + 32);
        if (!v4)
        {
          if (!v3) {
            return sub_1CD3499A4((uint64_t *)*result, v2);
          }
          return result;
        }
      }
    }
    else
    {
      return sub_1CD3499A4((uint64_t *)*result, v2);
    }
  }
  return result;
}

void *sub_1CD349ABC(void *result, void *a2)
{
  *BOOL result = 1;
  if ((*a2 & 1) == 0) {
    operator new();
  }
  *BOOL result = *a2;
  return result;
}

void sub_1CD349B94(uint64_t *a1, uint64_t a2)
{
  unint64_t v4 = a1[2];
  int v5 = (void *)a1[1];
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = 0x2E8BA2E8BA2E8BA3 * (((uint64_t)v5 - *a1) >> 3);
    if ((unint64_t)(v7 + 1) > 0x2E8BA2E8BA2E8BALL) {
      abort();
    }
    unint64_t v8 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v4 - *a1) >> 3);
    uint64_t v9 = 2 * v8;
    if (2 * v8 <= v7 + 1) {
      uint64_t v9 = v7 + 1;
    }
    if (v8 >= 0x1745D1745D1745DLL) {
      unint64_t v10 = 0x2E8BA2E8BA2E8BALL;
    }
    else {
      unint64_t v10 = v9;
    }
    uint64_t v21 = a1 + 2;
    if (v10 > 0x2E8BA2E8BA2E8BALL) {
      sub_1CB833614();
    }
    uint64_t v11 = 88 * v10;
    uint64_t v12 = (char *)operator new(88 * v10);
    uint64_t v13 = &v12[88 * v7];
    __p = v12;
    uint64_t v18 = v13;
    uint64_t v20 = &v12[v11];
    *(void *)uint64_t v13 = *(void *)a2;
    *((void *)v13 + 1) = v13 + 24;
    *((void *)v13 + 2) = 0x800000000;
    if (*(_DWORD *)(a2 + 16)) {
      sub_1CD41C56C((uint64_t)(v13 + 8), a2 + 8);
    }
    int64x2_t v19 = v13 + 88;
    sub_1CD771130(a1, &__p);
    int v6 = (void *)a1[1];
    int64x2_t v14 = v18;
    for (uint64_t i = v19; i != v14; i -= 88)
    {
      uint64_t v16 = (char *)*((void *)i - 10);
      if (i - 64 != v16) {
        free(v16);
      }
    }
    if (__p) {
      operator delete(__p);
    }
  }
  else
  {
    void *v5 = *(void *)a2;
    v5[1] = v5 + 3;
    void v5[2] = 0x800000000;
    if (*(_DWORD *)(a2 + 16)) {
      sub_1CD41C56C((uint64_t)(v5 + 1), a2 + 8);
    }
    int v6 = v5 + 11;
  }
  a1[1] = (uint64_t)v6;
}

uint64_t sub_1CD349D40(uint64_t result, uint64_t *a2, uint64_t a3)
{
  if ((uint64_t *)result != a2)
  {
    unint64_t v4 = (void *)result;
    int v5 = (uint64_t *)(result + 8);
    if ((uint64_t *)(result + 8) != a2)
    {
      uint64_t v7 = 0;
      unint64_t v8 = (uint64_t *)result;
      do
      {
        uint64_t v10 = *v8;
        uint64_t v9 = v8[1];
        unint64_t v8 = v5;
        BOOL result = (*(uint64_t (**)(void, uint64_t, uint64_t))a3)(*(void *)(a3 + 8), v9, v10);
        if (result)
        {
          uint64_t v11 = *v8;
          uint64_t v12 = v7;
          while (1)
          {
            *(void *)((char *)v4 + v12 + 8) = *(void *)((char *)v4 + v12);
            if (!v12) {
              break;
            }
            BOOL result = (*(uint64_t (**)(void, uint64_t, void))a3)(*(void *)(a3 + 8), v11, *(void *)((char *)v4 + v12 - 8));
            v12 -= 8;
            if ((result & 1) == 0)
            {
              uint64_t v13 = (void *)((char *)v4 + v12 + 8);
              goto LABEL_10;
            }
          }
          uint64_t v13 = v4;
LABEL_10:
          *uint64_t v13 = v11;
        }
        int v5 = v8 + 1;
        v7 += 8;
      }
      while (v8 + 1 != a2);
    }
  }
  return result;
}

uint64_t sub_1CD349E08(uint64_t result, char *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, char *a7, uint64_t a8)
{
  if (!a6) {
    return result;
  }
  uint64_t v10 = a6;
  uint64_t v15 = (char *)result;
  while (a5 > a8 && v10 > a8)
  {
    if (!a5) {
      return result;
    }
    while (1)
    {
      BOOL result = (*(uint64_t (**)(void, void, void))a4)(*(void *)(a4 + 8), *(void *)a2, *(void *)v15);
      if (result) {
        break;
      }
      v15 += 8;
      if (!--a5) {
        return result;
      }
    }
    uint64_t v45 = a3;
    uint64_t __src = a7;
    uint64_t v47 = v10;
    if (a5 >= v10)
    {
      if (a5 == 1)
      {
        uint64_t v39 = *(void *)v15;
        *(void *)uint64_t v15 = *(void *)a2;
        *(void *)a2 = v39;
        return result;
      }
      if (a5 >= 0) {
        uint64_t v23 = a5;
      }
      else {
        uint64_t v23 = a5 + 1;
      }
      unint64_t v18 = v23 >> 1;
      uint64_t v22 = a2;
      a2 = &v15[8 * (v23 >> 1)];
      uint64_t v10 = (a3 - v22) >> 3;
      if (a3 == v22)
      {
        unsigned int v17 = a3;
        goto LABEL_36;
      }
      uint64_t v42 = v22;
      uint64_t v43 = a8;
      uint64_t v24 = *(void *)(a4 + 8);
      unsigned int v48 = *(uint64_t (**)(uint64_t, uint64_t, void))a4;
      unsigned int v17 = v22;
      do
      {
        unsigned int v25 = &v17[8 * ((unint64_t)v10 >> 1)];
        uint64_t v27 = *(void *)v25;
        uint64_t v26 = v25 + 8;
        int v28 = v48(v24, v27, *(void *)a2);
        if (v28) {
          v10 += ~((unint64_t)v10 >> 1);
        }
        else {
          uint64_t v10 = (unint64_t)v10 >> 1;
        }
        if (v28) {
          unsigned int v17 = v26;
        }
      }
      while (v10);
      uint64_t v22 = v42;
      uint64_t v10 = (v17 - v42) >> 3;
    }
    else
    {
      if (v10 >= 0) {
        uint64_t v16 = v10;
      }
      else {
        uint64_t v16 = v10 + 1;
      }
      uint64_t v10 = v16 >> 1;
      unsigned int v17 = &a2[8 * (v16 >> 1)];
      unint64_t v18 = (a2 - v15) >> 3;
      if (a2 == v15)
      {
        uint64_t v15 = a2;
        goto LABEL_42;
      }
      int v41 = a2;
      uint64_t v43 = a8;
      a2 = v15;
      do
      {
        int64x2_t v19 = &a2[8 * (v18 >> 1)];
        uint64_t v21 = *(void *)v19;
        uint64_t v20 = v19 + 8;
        if ((*(unsigned int (**)(void, void, uint64_t))a4)(*(void *)(a4 + 8), *(void *)v17, v21))
        {
          v18 >>= 1;
        }
        else
        {
          a2 = v20;
          v18 += ~(v18 >> 1);
        }
      }
      while (v18);
      unint64_t v18 = (a2 - v15) >> 3;
      uint64_t v22 = v41;
    }
    a8 = v43;
LABEL_36:
    if (a2 != v22)
    {
      if (v22 == v17)
      {
        unsigned int v17 = v22;
        a3 = a2;
      }
      else if (a2 + 8 == v22)
      {
        uint64_t v49 = *(void *)a2;
        uint64_t v29 = a8;
        int64_t v30 = v17 - v22;
        memmove(a2, v22, v17 - v22);
        a3 = &a2[v30];
        a8 = v29;
        *(void *)a3 = v49;
      }
      else if (v22 + 8 == v17)
      {
        uint64_t v44 = a8;
        uint64_t v31 = *((void *)v17 - 1);
        a3 = a2 + 8;
        if (v17 - 8 != a2) {
          memmove(a2 + 8, a2, v17 - 8 - a2);
        }
        *(void *)a2 = v31;
        a8 = v44;
      }
      else
      {
        a3 = (char *)sub_1CC057214(a2, v22, v17);
      }
      goto LABEL_48;
    }
    a2 = v22;
LABEL_42:
    a3 = v17;
LABEL_48:
    a5 -= v18;
    if ((uint64_t)(v10 + v18) >= v47 - v10 + a5)
    {
      a7 = __src;
      BOOL result = sub_1CD349E08(a3, v17, v45, a4, a5, v47 - v10, __src, a8);
      unsigned int v17 = a2;
      a5 = v18;
    }
    else
    {
      BOOL result = sub_1CD349E08(v15, a2, a3, a4, v18, v10, __src, a8);
      uint64_t v15 = a3;
      a3 = v45;
      uint64_t v10 = v47 - v10;
      a7 = __src;
    }
    a2 = v17;
    if (!v10) {
      return result;
    }
  }
  if (a5 <= v10)
  {
    if (v15 != a2)
    {
      unint64_t v36 = 0;
      do
      {
        *(void *)&a7[v36] = *(void *)&v15[v36];
        v36 += 8;
      }
      while (&v15[v36] != a2);
      if (v36)
      {
        uint64_t v37 = a7;
        while (a2 != a3)
        {
          BOOL result = (*(uint64_t (**)(void, void, void))a4)(*(void *)(a4 + 8), *(void *)a2, *(void *)v37);
          if (result) {
            int v38 = a2;
          }
          else {
            int v38 = v37;
          }
          v37 += 8 * (result ^ 1);
          a2 += 8 * result;
          *(void *)uint64_t v15 = *(void *)v38;
          v15 += 8;
          if (&a7[v36] == v37) {
            return result;
          }
        }
        return (uint64_t)memmove(v15, v37, a7 - v37 + v36);
      }
    }
  }
  else if (a2 != a3)
  {
    uint64_t v32 = 0;
    do
    {
      *(void *)&a7[v32] = *(void *)&a2[v32];
      v32 += 8;
    }
    while (&a2[v32] != a3);
    if (v32)
    {
      uint64_t v33 = &a7[v32];
      uint64_t v34 = a3 - 8;
      while (a2 != v15)
      {
        BOOL result = (*(uint64_t (**)(void, void, void))a4)(*(void *)(a4 + 8), *((void *)v33 - 1), *((void *)a2 - 1));
        if (result) {
          uint64_t v35 = a2;
        }
        else {
          uint64_t v35 = v33;
        }
        if (result) {
          a2 -= 8;
        }
        else {
          v33 -= 8;
        }
        *(void *)uint64_t v34 = *((void *)v35 - 1);
        v34 -= 8;
        if (v33 == a7) {
          return result;
        }
      }
      if (v33 != a7)
      {
        uint64_t v40 = 0;
        do
        {
          *(void *)&v34[v40] = *(void *)&v33[v40 - 8];
          v40 -= 8;
        }
        while (&v33[v40] != a7);
      }
    }
  }
  return result;
}

uint64_t *sub_1CD34A264(uint64_t *result, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  if (result != a2)
  {
    int v6 = result + 1;
    *a3 = *result;
    if (result + 1 != a2)
    {
      uint64_t v8 = 0;
      uint64_t v9 = a3;
      do
      {
        uint64_t v10 = v9;
        uint64_t v11 = *v9++;
        BOOL result = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))a4)(*(void *)(a4 + 8), *v6, v11);
        uint64_t v12 = v9;
        if (result)
        {
          v10[1] = *v10;
          uint64_t v12 = a3;
          if (v10 != a3)
          {
            uint64_t v13 = v8;
            while (1)
            {
              uint64_t v12 = (uint64_t *)((char *)a3 + v13);
              BOOL result = (uint64_t *)(*(uint64_t (**)(void, uint64_t, void))a4)(*(void *)(a4 + 8), *v6, *(uint64_t *)((char *)a3 + v13 - 8));
              if (!result) {
                break;
              }
              uint64_t *v12 = *(v12 - 1);
              v13 -= 8;
              if (!v13)
              {
                uint64_t v12 = a3;
                break;
              }
            }
          }
        }
        uint64_t v14 = *v6++;
        uint64_t *v12 = v14;
        v8 += 8;
      }
      while (v6 != a2);
    }
  }
  return result;
}

uint64_t sub_1CD34A340(llvm::slpvectorizer::BoUpSLP **a1, llvm::Value *a2)
{
  unsigned int v2 = *((_DWORD *)*a1 + 500) / llvm::slpvectorizer::BoUpSLP::getVectorElementSize(*a1, a2);
  if (v2 <= 2) {
    return 2;
  }
  else {
    return v2;
  }
}

uint64_t sub_1CD34A380(void *a1, uint64_t a2, _WORD *a3)
{
  v29[2] = *MEMORY[0x1E4F143B8];
  int v5 = (uint64_t *)(*a1 + 1048);
  uint64_t v27 = a3;
  v29[0] = 0;
  if (sub_1CD50F704(v5, &v27, v29)) {
    return 0;
  }
  int v6 = *(_DWORD *)(*(void *)a3 + 8);
  BOOL v7 = v6 > 0x14u || ((1 << v6) & 0x10A07F) == 0;
  if (v7 || (v6 & 0xFD) == 4) {
    return 0;
  }
  uint64_t v8 = a2 - 64;
  unsigned int v9 = *(unsigned __int8 *)(**(void **)(a2 - 64) + 8);
  uint64_t v10 = a3 - 32;
  unsigned int v11 = *(unsigned __int8 *)(**((void **)a3 - 8) + 8);
  if (v9 >= v11)
  {
    if (v9 > v11) {
      return 0;
    }
    uint64_t v12 = *(_WORD *)(a2 + 18) & 0x3F;
    uint64_t v13 = a3[9] & 0x3F;
    unsigned int v14 = dword_1CFB33A68[v12];
    unsigned int v15 = dword_1CFB33A68[v13];
    if (v14 >= v12) {
      unsigned int v14 = *(_WORD *)(a2 + 18) & 0x3F;
    }
    if (v15 >= v13) {
      unsigned int v15 = a3[9] & 0x3F;
    }
    if (v14 >= v15)
    {
      if (v14 > v15) {
        return 0;
      }
      uint64_t v17 = *(void *)(v8 + 32 * (v12 > v13));
      uint64_t v18 = *(void *)&v10[16 * (v12 < v13)];
      unsigned int v19 = *(unsigned __int8 *)(v17 + 16);
      unsigned int v20 = *(unsigned __int8 *)(v18 + 16);
      if (v19 >= v20)
      {
        BOOL v21 = v12 > v13;
        BOOL v22 = v12 >= v13;
        uint64_t v23 = !v21;
        uint64_t v24 = (uint64_t *)(v8 + 32 * v23);
        unsigned int v25 = (uint64_t *)&v10[16 * v22];
        char v26 = 1;
        while (v19 <= v20)
        {
          if (v19 < 0x1C || v20 < 0x1C)
          {
            if ((v26 & 1) == 0) {
              return 0;
            }
          }
          else
          {
            if (*(void *)(v17 + 40) != *(void *)(v18 + 40)) {
              return 0;
            }
            v29[0] = v17;
            v29[1] = v18;
            sub_1CD32A408((uint64_t)&v27, v29, 2);
            if (!v28 || (v26 & (*(unsigned char *)(v28 + 16) != 28)) == 0) {
              return 0;
            }
          }
          char v26 = 0;
          uint64_t v17 = *v24;
          uint64_t v18 = *v25;
          unsigned int v19 = *(unsigned __int8 *)(*v24 + 16);
          unsigned int v20 = *(unsigned __int8 *)(*v25 + 16);
          uint64_t result = 1;
          if (v19 < v20) {
            return result;
          }
        }
        return 0;
      }
    }
  }
  return 1;
}

uint64_t sub_1CD34A578(void *a1, _WORD *a2, _WORD *a3)
{
  v24[2] = *MEMORY[0x1E4F143B8];
  if (a2 == a3) {
    return 1;
  }
  int v6 = (uint64_t *)(*a1 + 1048);
  BOOL v22 = a3;
  v24[0] = 0;
  if ((sub_1CD50F704(v6, &v22, v24) & 1) == 0)
  {
    int v7 = *(_DWORD *)(*(void *)a3 + 8);
    if (v7 <= 0x14u && ((1 << v7) & 0x10A07F) != 0 && (v7 & 0xFD) != 4)
    {
      unsigned int v9 = a2 - 32;
      uint64_t v10 = a3 - 32;
      if (*(unsigned __int8 *)(**((void **)a3 - 8) + 8) == *(unsigned __int8 *)(**((void **)a2 - 8) + 8))
      {
        uint64_t v11 = a2[9] & 0x3F;
        uint64_t v12 = a3[9] & 0x3F;
        unsigned int v13 = dword_1CFB33A68[v11];
        unsigned int v14 = dword_1CFB33A68[v12];
        if (v13 >= v11) {
          unsigned int v13 = v11;
        }
        if (v14 >= v12) {
          unsigned int v14 = v12;
        }
        if (v13 == v14)
        {
          LODWORD(result) = 0;
          for (char i = 1; ; char i = 0)
          {
            char v16 = i;
            int v17 = result ^ 1;
            int v18 = v11 <= v12 ? result : result ^ 1;
            uint64_t v19 = *(void *)&v9[16 * v18];
            if (v11 >= v12) {
              int v17 = result;
            }
            uint64_t v20 = *(void *)&v10[16 * v17];
            unsigned int v21 = *(unsigned __int8 *)(v19 + 16);
            if (v21 != *(unsigned __int8 *)(v20 + 16)) {
              break;
            }
            if (v21 >= 0x1C)
            {
              if (*(void *)(v19 + 40) != *(void *)(v20 + 40)) {
                break;
              }
              v24[0] = v19;
              v24[1] = v20;
              sub_1CD32A408((uint64_t)&v22, v24, 2);
              if (!v23 || *(unsigned char *)(v23 + 16) == 28) {
                break;
              }
            }
            uint64_t result = 1;
            if ((v16 & 1) == 0) {
              return result;
            }
          }
        }
      }
    }
  }
  return 0;
}

uint64_t sub_1CD34A73C(uint64_t a1, uint64_t *a2, unint64_t a3, char a4)
{
  uint64_t v5 = *(void *)a1;
  if (!a3) {
    return llvm::SLPVectorizerPass::tryToVectorizeList(v5, a2, a3, *(llvm::slpvectorizer::BoUpSLP **)(a1 + 8), a4);
  }
  int v6 = a2;
  while (1)
  {
    uint64_t v7 = *(void *)(*v6 + 8);
    if (v7) {
      break;
    }
LABEL_7:
    if (++v6 == &a2[a3]) {
      return llvm::SLPVectorizerPass::tryToVectorizeList(v5, a2, a3, *(llvm::slpvectorizer::BoUpSLP **)(a1 + 8), a4);
    }
  }
  while (1)
  {
    uint64_t v8 = *(void *)(v7 + 24);
    if (*(unsigned char *)(v8 + 16) == 85 && *(void *)(v8 + 40) != *(void *)(*v6 + 40)) {
      return 0;
    }
    uint64_t v7 = *(void *)(v7 + 8);
    if (!v7) {
      goto LABEL_7;
    }
  }
}

uint64_t sub_1CD34A7A4(llvm::slpvectorizer::BoUpSLP **a1, llvm::Value *a2)
{
  unsigned int v2 = *((_DWORD *)*a1 + 500) / llvm::slpvectorizer::BoUpSLP::getVectorElementSize(*a1, a2);
  if (v2 <= 2) {
    return 2;
  }
  else {
    return v2;
  }
}

uint64_t sub_1CD34A7E4(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v49[2] = *MEMORY[0x1E4F143B8];
  uint64_t v47 = a3;
  uint64_t v48 = a2;
  unsigned int v3 = *(unsigned __int8 *)(*(void *)a2 + 8);
  unsigned int v4 = *(unsigned __int8 *)(*(void *)a3 + 8);
  if (v3 < v4) {
    return 1;
  }
  if (v3 > v4) {
    return 0;
  }
  uint64_t v7 = *a1;
  uint64_t v8 = sub_1CD4C93F8(a1[1], &v48);
  uint64_t v9 = v8[1];
  uint64_t v10 = *((unsigned int *)v8 + 4);
  uint64_t v11 = sub_1CD4C93F8(a1[1], &v47);
  unsigned int v12 = *((_DWORD *)v11 + 4);
  if (v10 < v12) {
    return 1;
  }
  if (v10 > v12) {
    return 0;
  }
  if ((int)v10 < 1)
  {
    char v15 = 0;
    int v14 = 0;
LABEL_60:
    if (v15) {
      BOOL v44 = v14 == 0;
    }
    else {
      BOOL v44 = 1;
    }
    return !v44;
  }
  uint64_t v13 = 0;
  int v14 = 0;
  char v15 = 0;
  uint64_t v16 = v11[1];
  while (1)
  {
    uint64_t v17 = *(void *)(v9 + 8 * v13);
    unsigned int v18 = *(unsigned __int8 *)(v17 + 16);
    if (v18 - 13 > 0xFFFFFFFD || (v19 = *(void *)(v16 + 8 * v13), unsigned int v20 = *(unsigned __int8 *)(v19 + 16), v20 - 11 < 2))
    {
      if (!v14)
      {
        BOOL v21 = __CFADD__(v18 - 13, 2);
        goto LABEL_14;
      }
      goto LABEL_17;
    }
    unsigned int v22 = v18 - 28;
    if (v18 >= 0x1C && v20 >= 0x1C) {
      break;
    }
    if (v18 <= 0x14 && v20 <= 0x14)
    {
      if (!v14)
      {
        BOOL v21 = v18 >= v20;
LABEL_14:
        char v15 = !v21;
      }
LABEL_17:
      int v14 = 1;
      goto LABEL_18;
    }
    if (v18 < v20) {
      return 1;
    }
    if (v18 > v20) {
      return 0;
    }
LABEL_18:
    if (++v13 == v10) {
      goto LABEL_60;
    }
  }
  uint64_t v25 = *(void *)(v7 + 40);
  uint64_t v26 = *(void *)(v25 + 24);
  uint64_t v27 = *(unsigned int *)(v25 + 40);
  if (v27)
  {
    uint64_t v28 = *(void *)(v17 + 40);
    LODWORD(v29) = ((v28 >> 4) ^ (v28 >> 9)) & (v27 - 1);
    int64_t v30 = (uint64_t *)(v26 + 16 * v29);
    uint64_t v31 = *v30;
    if (v28 == *v30) {
      goto LABEL_41;
    }
    int v32 = 1;
    while (v31 != -4096)
    {
      int v33 = v29 + v32++;
      uint64_t v29 = v33 & (v27 - 1);
      uint64_t v31 = *(void *)(v26 + 16 * v29);
      if (v28 == v31)
      {
        int64_t v30 = (uint64_t *)(v26 + 16 * v29);
        goto LABEL_41;
      }
    }
  }
  int64_t v30 = (uint64_t *)(v26 + 16 * v27);
LABEL_41:
  uint64_t v34 = (uint64_t *)(v26 + 16 * v27);
  if (v30 == v34) {
    uint64_t v35 = 0;
  }
  else {
    uint64_t v35 = v30[1];
  }
  if (v27)
  {
    uint64_t v36 = *(void *)(v19 + 40);
    unsigned int v37 = v27 - 1;
    LODWORD(v27) = ((v36 >> 4) ^ (v36 >> 9)) & (v27 - 1);
    int v38 = (uint64_t *)(v26 + 16 * v27);
    uint64_t v39 = *v38;
    if (v36 == *v38)
    {
LABEL_50:
      if (v38 != v34)
      {
        uint64_t v42 = v38[1];
        goto LABEL_53;
      }
    }
    else
    {
      int v40 = 1;
      while (v39 != -4096)
      {
        int v41 = v27 + v40++;
        uint64_t v27 = v41 & v37;
        uint64_t v39 = *(void *)(v26 + 16 * v27);
        if (v36 == v39)
        {
          int v38 = (uint64_t *)(v26 + 16 * v27);
          goto LABEL_50;
        }
      }
    }
  }
  uint64_t v42 = 0;
LABEL_53:
  if (!v35)
  {
    BOOL v44 = v42 == 0;
    return !v44;
  }
  if (!v42) {
    return 0;
  }
  if (v35 == v42)
  {
    v49[0] = *(void *)(v9 + 8 * v13);
    v49[1] = v19;
    sub_1CD32A408((uint64_t)&v45, v49, 2);
    if (!v46 || *(unsigned char *)(v46 + 16) == 28)
    {
      BOOL v43 = v22 >= v20 - 28;
      return !v43;
    }
    goto LABEL_18;
  }
  BOOL v43 = *(_DWORD *)(v35 + 72) >= *(_DWORD *)(v42 + 72);
  return !v43;
}

uint64_t sub_1CD34AAAC(uint64_t *a1, void *a2, void *a3)
{
  v21[2] = *MEMORY[0x1E4F143B8];
  uint64_t v19 = a3;
  unsigned int v20 = a2;
  if (a2 != a3)
  {
    if (*a2 != *a3) {
      return 0;
    }
    uint64_t v5 = sub_1CD4C93F8(*a1, (uint64_t *)&v20);
    uint64_t v6 = v5[1];
    uint64_t v7 = *((unsigned int *)v5 + 4);
    uint64_t v8 = sub_1CD4C93F8(*a1, (uint64_t *)&v19);
    if (v7 != *((_DWORD *)v8 + 4)) {
      return 0;
    }
    if ((int)v7 >= 1)
    {
      uint64_t v9 = (uint64_t *)v8[1];
      while (1)
      {
        unsigned int v10 = *(unsigned __int8 *)(*(void *)v6 + 16);
        if (v10 - 11 >= 2)
        {
          uint64_t v11 = *v9;
          unsigned int v12 = *(unsigned __int8 *)(*v9 + 16);
          if (v12 - 11 >= 2)
          {
            if (v10 >= 0x1C && v12 >= 0x1C)
            {
              if (*(void *)(*(void *)v6 + 40) != *(void *)(v11 + 40)) {
                return 0;
              }
              v21[0] = *(void *)v6;
              v21[1] = v11;
              sub_1CD32A408((uint64_t)&v17, v21, 2);
              if (!v18 || *(unsigned char *)(v18 + 16) == 28) {
                return 0;
              }
            }
            else
            {
              BOOL v15 = v10 < 0x15 && v12 < 0x15;
              if (v10 != v12 && !v15) {
                return 0;
              }
            }
          }
        }
        ++v9;
        v6 += 8;
        uint64_t result = 1;
        if (!--v7) {
          return result;
        }
      }
    }
  }
  return 1;
}

uint64_t sub_1CD34AC08(uint64_t a1, uint64_t *a2, unint64_t a3, char a4)
{
  return llvm::SLPVectorizerPass::tryToVectorizeList(*(void *)a1, a2, a3, *(llvm::slpvectorizer::BoUpSLP **)(a1 + 8), a4);
}

uint64_t sub_1CD34AC18(void *a1, void *a2)
{
  unsigned int v4 = (void *)*a2;
  uint64_t v5 = (uint64_t *)(*a1 + 1048);
  uint64_t v9 = 0;
  unsigned int v10 = v4;
  uint64_t v6 = sub_1CD50F704(v5, &v10, &v9);
  if (v6)
  {
    uint64_t v7 = a1[1];
    unsigned int v10 = 0;
    if (sub_1CBF5FB7C((uint64_t *)v7, a2, &v10))
    {
      void *v10 = -8192;
      *(int32x2_t *)(v7 + 8) = vadd_s32(*(int32x2_t *)(v7 + 8), (int32x2_t)0x1FFFFFFFFLL);
    }
  }
  return v6;
}

void sub_1CD34ACB0(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  unint64_t v6 = a2 - a1;
  if ((char *)a2 - (char *)a1 < 1025)
  {
LABEL_5:
    sub_1CD8E7B2C(a1, a2, a3, v6, 0, 0);
  }
  else
  {
    uint64_t v7 = (const std::nothrow_t *)MEMORY[0x1E4FBA2D0];
    unint64_t v8 = a2 - a1;
    while (1)
    {
      uint64_t v9 = (uint64_t *)operator new(8 * v8, v7);
      if (v9) {
        break;
      }
      BOOL v10 = v8 > 1;
      v8 >>= 1;
      if (!v10) {
        goto LABEL_5;
      }
    }
    uint64_t v11 = v9;
    sub_1CD8E7B2C(a1, a2, a3, v6, v9, v8);
    operator delete(v11);
  }
}

uint64_t sub_1CD34ADA0(uint64_t result, void *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8)
{
  if (!a6) {
    return result;
  }
  uint64_t v9 = a6;
  int v14 = (void *)result;
  while (a5 > a8 && v9 > a8)
  {
    if (!a5) {
      return result;
    }
    while (1)
    {
      uint64_t result = (*(uint64_t (**)(void, void, void))a4)(*(void *)(a4 + 8), *a2, *v14);
      if (result) {
        break;
      }
      ++v14;
      if (!--a5) {
        return result;
      }
    }
    uint64_t v74 = a8;
    if (a5 >= v9)
    {
      if (a5 == 1)
      {
        uint64_t v64 = *v14;
        *int v14 = *a2;
        *a2 = v64;
        return result;
      }
      uint64_t v19 = a3;
      if (a5 >= 0) {
        uint64_t v24 = a5;
      }
      else {
        uint64_t v24 = a5 + 1;
      }
      unint64_t v18 = v24 >> 1;
      uint64_t v17 = &v14[v24 >> 1];
      unint64_t v16 = a3 - a2;
      if (a3 == a2)
      {
        uint64_t v23 = a2;
        a2 = a3;
        goto LABEL_36;
      }
      uint64_t v66 = a4;
      uint64_t v67 = v9;
      unsigned int v69 = a2;
      uint64_t v71 = a3;
      uint64_t v26 = *(uint64_t (**)(uint64_t, uint64_t, void))a4;
      uint64_t v25 = *(void *)(a4 + 8);
      do
      {
        uint64_t v27 = &a2[v16 >> 1];
        uint64_t v29 = *v27;
        uint64_t v28 = v27 + 1;
        int v30 = v26(v25, v29, *v17);
        if (v30) {
          v16 += ~(v16 >> 1);
        }
        else {
          v16 >>= 1;
        }
        if (v30) {
          a2 = v28;
        }
      }
      while (v16);
      uint64_t v23 = v69;
      uint64_t v19 = v71;
      unint64_t v16 = a2 - v69;
      a4 = v66;
    }
    else
    {
      if (v9 >= 0) {
        uint64_t v15 = v9;
      }
      else {
        uint64_t v15 = v9 + 1;
      }
      unint64_t v16 = v15 >> 1;
      uint64_t v17 = a2;
      a2 += v15 >> 1;
      unint64_t v18 = v17 - v14;
      uint64_t v19 = a3;
      if (v17 == v14)
      {
        int v14 = v17;
        goto LABEL_49;
      }
      uint64_t v67 = v9;
      uint64_t v68 = v17;
      int v70 = a3;
      uint64_t v17 = v14;
      do
      {
        unsigned int v20 = &v17[v18 >> 1];
        uint64_t v22 = *v20;
        BOOL v21 = v20 + 1;
        if ((*(unsigned int (**)(void, void, uint64_t))a4)(*(void *)(a4 + 8), *a2, v22))
        {
          v18 >>= 1;
        }
        else
        {
          uint64_t v17 = v21;
          v18 += ~(v18 >> 1);
        }
      }
      while (v18);
      unint64_t v18 = v17 - v14;
      uint64_t v23 = v68;
      uint64_t v19 = v70;
    }
    uint64_t v9 = v67;
LABEL_36:
    if (v17 != v23)
    {
      if (v23 == a2)
      {
        a2 = v23;
        unsigned int v37 = v17;
      }
      else if (v17 + 1 == v23)
      {
        uint64_t v72 = v19;
        uint64_t v38 = a4;
        uint64_t v39 = *v17;
        int64_t v40 = (char *)a2 - (char *)v23;
        memmove(v17, v23, (char *)a2 - (char *)v23);
        unsigned int v37 = (void *)((char *)v17 + v40);
        *unsigned int v37 = v39;
        a4 = v38;
        uint64_t v19 = v72;
      }
      else if (v23 + 1 == a2)
      {
        uint64_t v41 = *(a2 - 1);
        unsigned int v37 = v17 + 1;
        if (a2 - 1 != v17)
        {
          uint64_t v73 = v19;
          memmove(v17 + 1, v17, (char *)(a2 - 1) - (char *)v17);
          uint64_t v19 = v73;
        }
        void *v17 = v41;
      }
      else
      {
        uint64_t v31 = v23 - v17;
        if (v31 == a2 - v23)
        {
          uint64_t v32 = 0;
          do
          {
            uint64_t v33 = v17[v32];
            v17[v32] = v23[v32];
            uint64_t v34 = (uint64_t)&v17[v32 + 1];
            v23[v32] = v33;
            uint64_t v35 = (uint64_t)&v23[++v32];
          }
          while ((void *)v34 != v23 && v35 != (void)a2);
          unsigned int v37 = v23;
        }
        else
        {
          uint64_t v42 = a2 - v23;
          uint64_t v43 = v23 - v17;
          do
          {
            uint64_t v44 = v43;
            uint64_t v43 = v42;
            uint64_t v42 = v44 % v42;
          }
          while (v42);
          if (v43)
          {
            uint64_t v45 = &v17[v43];
            do
            {
              uint64_t v47 = *--v45;
              uint64_t v46 = v47;
              uint64_t v48 = &v45[v31];
              uint64_t v49 = v45;
              do
              {
                uint64_t v50 = v49;
                uint64_t v49 = v48;
                *uint64_t v50 = *v48;
                BOOL v51 = __OFSUB__(v31, a2 - v48);
                uint64_t v53 = v31 - (a2 - v48);
                char v52 = (v53 < 0) ^ v51;
                uint64_t v48 = &v17[v53];
                if (v52) {
                  uint64_t v48 = &v49[v31];
                }
              }
              while (v48 != v45);
              void *v49 = v46;
            }
            while (v45 != v17);
          }
          unsigned int v37 = &v17[a2 - v23];
        }
      }
      goto LABEL_65;
    }
    uint64_t v17 = v23;
LABEL_49:
    unsigned int v37 = a2;
LABEL_65:
    a5 -= v18;
    v9 -= v16;
    if ((uint64_t)(v16 + v18) >= v9 + a5)
    {
      a3 = v37;
      uint64_t v56 = v37;
      a8 = v74;
      uint64_t result = sub_1CD34ADA0(v56, a2, v19, a4, a5, v9, a7, v74);
      a2 = v17;
      uint64_t v9 = v16;
      a5 = v18;
      if (!v16) {
        return result;
      }
    }
    else
    {
      a3 = v19;
      uint64_t v54 = v14;
      int v14 = v37;
      uint64_t v55 = v37;
      a8 = v74;
      uint64_t result = sub_1CD34ADA0(v54, v17, v55, a4, v18, v16, a7, v74);
      if (!v9) {
        return result;
      }
    }
  }
  if (a5 <= v9)
  {
    if (v14 != a2)
    {
      uint64_t v61 = 0;
      do
      {
        a7[v61] = v14[v61];
        ++v61;
      }
      while (&v14[v61] != a2);
      if (v61 * 8)
      {
        int64_t v62 = a7;
        while (a2 != a3)
        {
          uint64_t result = (*(uint64_t (**)(void, void, void))a4)(*(void *)(a4 + 8), *a2, *v62);
          if (result) {
            int64_t v63 = a2;
          }
          else {
            int64_t v63 = v62;
          }
          v62 += result ^ 1;
          a2 += result;
          *v14++ = *v63;
          if (&a7[v61] == v62) {
            return result;
          }
        }
        return (uint64_t)memmove(v14, v62, (char *)a7 - (char *)v62 + v61 * 8);
      }
    }
  }
  else if (a2 != a3)
  {
    uint64_t v57 = 0;
    do
    {
      a7[v57] = a2[v57];
      ++v57;
    }
    while (&a2[v57] != a3);
    if (v57 * 8)
    {
      unsigned int v58 = &a7[v57];
      uint64_t v59 = a3 - 1;
      while (a2 != v14)
      {
        uint64_t result = (*(uint64_t (**)(void, void, void))a4)(*(void *)(a4 + 8), *(v58 - 1), *(a2 - 1));
        if (result) {
          uint64_t v60 = a2;
        }
        else {
          uint64_t v60 = v58;
        }
        if (result) {
          --a2;
        }
        else {
          --v58;
        }
        *v59-- = *(v60 - 1);
        if (v58 == a7) {
          return result;
        }
      }
      if (v58 != a7)
      {
        uint64_t v65 = 0;
        do
        {
          v59[v65] = v58[v65 - 1];
          --v65;
        }
        while (&v58[v65] != a7);
      }
    }
  }
  return result;
}

uint64_t sub_1CD34B2C4(void *a1, uint64_t a2)
{
  unsigned int v3 = sub_1CB83544C(*(void *)(a1[1] + 64), a2);
  if (v4 == 1)
  {
    unsigned int v7 = v3;
    unsigned int v3 = v7;
  }
  unsigned int v5 = *(_DWORD *)(*a1 + 2004) / v3;
  if (v5 <= 2) {
    return 2;
  }
  else {
    return v5;
  }
}

uint64_t sub_1CD34B334(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v34[2] = *MEMORY[0x1E4F143B8];
  unsigned int v3 = *(unsigned __int8 *)(**(void **)(a2 - 32) + 8);
  unsigned int v4 = *(unsigned __int8 *)(**(void **)(a3 - 32) + 8);
  if (v3 < v4) {
    return 1;
  }
  if (v3 > v4) {
    return 0;
  }
  uint64_t v6 = *(void *)(a2 - 64);
  unsigned int v7 = *(unsigned __int8 *)(v6 + 16);
  if (v7 - 11 < 2) {
    return 0;
  }
  uint64_t v8 = *(void *)(a3 - 64);
  unsigned int v9 = *(unsigned __int8 *)(v8 + 16);
  if (v9 - 11 < 2) {
    return 0;
  }
  unsigned int v10 = v7 - 28;
  if (v7 < 0x1C || v9 < 0x1C)
  {
    BOOL v13 = v7 <= 0x14 && v9 <= 0x14 || v7 >= v9;
    return !v13;
  }
  uint64_t v14 = *(void *)(*(void *)a1 + 40);
  uint64_t v15 = *(void *)(v14 + 24);
  uint64_t v16 = *(unsigned int *)(v14 + 40);
  if (v16)
  {
    uint64_t v17 = *(void *)(v6 + 40);
    LODWORD(v18) = ((v17 >> 4) ^ (v17 >> 9)) & (v16 - 1);
    uint64_t v19 = (uint64_t *)(v15 + 16 * v18);
    uint64_t v20 = *v19;
    if (v17 == *v19) {
      goto LABEL_25;
    }
    int v21 = 1;
    while (v20 != -4096)
    {
      int v22 = v18 + v21++;
      uint64_t v18 = v22 & (v16 - 1);
      uint64_t v20 = *(void *)(v15 + 16 * v18);
      if (v17 == v20)
      {
        uint64_t v19 = (uint64_t *)(v15 + 16 * v18);
        goto LABEL_25;
      }
    }
  }
  uint64_t v19 = (uint64_t *)(v15 + 16 * v16);
LABEL_25:
  uint64_t v23 = (uint64_t *)(v15 + 16 * v16);
  if (v19 == v23) {
    uint64_t v24 = 0;
  }
  else {
    uint64_t v24 = v19[1];
  }
  if (v16)
  {
    uint64_t v25 = *(void *)(v8 + 40);
    unsigned int v26 = v16 - 1;
    LODWORD(v16) = ((v25 >> 4) ^ (v25 >> 9)) & (v16 - 1);
    uint64_t v27 = (uint64_t *)(v15 + 16 * v16);
    uint64_t v28 = *v27;
    if (v25 == *v27)
    {
LABEL_34:
      if (v27 != v23)
      {
        uint64_t v31 = v27[1];
        goto LABEL_37;
      }
    }
    else
    {
      int v29 = 1;
      while (v28 != -4096)
      {
        int v30 = v16 + v29++;
        uint64_t v16 = v30 & v26;
        uint64_t v28 = *(void *)(v15 + 16 * v16);
        if (v25 == v28)
        {
          uint64_t v27 = (uint64_t *)(v15 + 16 * v16);
          goto LABEL_34;
        }
      }
    }
  }
  uint64_t v31 = 0;
LABEL_37:
  if (v24 == v31)
  {
    v34[0] = *(void *)(a2 - 64);
    v34[1] = v8;
    sub_1CD32A408((uint64_t)&v32, v34, 2);
    if (v33 && *(unsigned char *)(v33 + 16) != 28) {
      return 0;
    }
    BOOL v13 = v10 >= v9 - 28;
  }
  else
  {
    BOOL v13 = *(_DWORD *)(v24 + 72) >= *(_DWORD *)(v31 + 72);
  }
  return !v13;
}

BOOL sub_1CD34B534(uint64_t a1, uint64_t a2)
{
  v12[2] = *MEMORY[0x1E4F143B8];
  if (a1 == a2) {
    return 1;
  }
  if (**(void **)(a1 - 32) != **(void **)(a2 - 32)) {
    return 0;
  }
  uint64_t v3 = *(void *)(a1 - 64);
  unsigned int v4 = *(unsigned __int8 *)(v3 + 16);
  if (v4 - 11 < 2) {
    return 1;
  }
  uint64_t v5 = *(void *)(a2 - 64);
  unsigned int v6 = *(unsigned __int8 *)(v5 + 16);
  if (v6 - 11 < 2) {
    return 1;
  }
  if (v4 < 0x1C || v6 < 0x1C) {
    return v4 < 0x15 && v6 < 0x15 || v4 == v6;
  }
  if (*(void *)(v3 + 40) != *(void *)(v5 + 40)) {
    return 0;
  }
  v12[0] = *(void *)(a1 - 64);
  v12[1] = v5;
  sub_1CD32A408((uint64_t)&v10, v12, 2);
  if (!v11) {
    return 0;
  }
  return *(unsigned char *)(v11 + 16) != 28;
}

uint64_t sub_1CD34B62C()
{
  LOBYTE(v1) = 1;
  uint64_t v3 = &v1;
  int v2 = 1;
  v4.n128_u64[0] = (unint64_t)"Run the SLP vectorization passes";
  v4.n128_u64[1] = 32;
  sub_1CBA9E5B0((llvm::cl::Option *)&RunSLPVectorization, "vectorize-slp", (unsigned char **)&v3, &v2, &v4);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &RunSLPVectorization, &dword_1CB82C000);
  int v1 = 1;
  int v2 = 0;
  uint64_t v3 = &v2;
  v4.n128_u64[0] = (unint64_t)"Only vectorize if you gain more than this number ";
  v4.n128_u64[1] = 49;
  sub_1CD8E51A8(&v3, &v1, &v4);
  __cxa_atexit((void (*)(void *))sub_1CBB1C45C, &qword_1EBD01590, &dword_1CB82C000);
  LOBYTE(v1) = 1;
  int v2 = 1;
  uint64_t v3 = &v1;
  v4.n128_u64[0] = (unint64_t)"Attempt to vectorize horizontal reductions";
  v4.n128_u64[1] = 42;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBD01650, "slp-vectorize-hor", (unsigned char **)&v3, &v2, &v4);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBD01650, &dword_1CB82C000);
  LOBYTE(v1) = 0;
  int v2 = 1;
  uint64_t v3 = &v1;
  v4.n128_u64[0] = (unint64_t)"Attempt to vectorize horizontal reductions feeding into a store";
  v4.n128_u64[1] = 63;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBD01710, "slp-vectorize-hor-store", (unsigned char **)&v3, &v2, &v4);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBD01710, &dword_1CB82C000);
  int v1 = 1;
  int v2 = 128;
  uint64_t v3 = &v2;
  v4.n128_u64[0] = (unint64_t)"Attempt to vectorize for this register size in bits";
  v4.n128_u64[1] = 51;
  sub_1CD57D1E4((llvm::cl::Option *)&unk_1EBD017D0, "slp-max-reg-size", &v3, &v1, &v4);
  __cxa_atexit((void (*)(void *))sub_1CBB1C45C, &unk_1EBD017D0, &dword_1CB82C000);
  int v1 = 1;
  int v2 = 0;
  uint64_t v3 = &v2;
  v4.n128_u64[0] = (unint64_t)"Maximum SLP vectorization factor (0=unlimited)";
  v4.n128_u64[1] = 46;
  sub_1CD8E5320(&v3, &v1, (long long *)&v4);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &qword_1EBD01890, &dword_1CB82C000);
  int v1 = 1;
  int v2 = 32;
  uint64_t v3 = &v2;
  v4.n128_u64[0] = (unint64_t)"Maximum depth of the lookup for consecutive stores.";
  v4.n128_u64[1] = 51;
  sub_1CD8E5448(&v3, &v1, &v4);
  __cxa_atexit((void (*)(void *))sub_1CBB1C45C, &qword_1EBD01950, &dword_1CB82C000);
  int v1 = 1;
  int v2 = 100000;
  uint64_t v3 = &v2;
  v4.n128_u64[0] = (unint64_t)"Limit the size of the SLP scheduling region per block";
  v4.n128_u64[1] = 53;
  sub_1CD8E55C0(&v3, &v1, &v4);
  __cxa_atexit((void (*)(void *))sub_1CBB1C45C, &qword_1EBD01A10, &dword_1CB82C000);
  int v1 = 1;
  int v2 = 128;
  uint64_t v3 = &v2;
  v4.n128_u64[0] = (unint64_t)"Attempt to vectorize for this register size in bits";
  v4.n128_u64[1] = 51;
  sub_1CD57D1E4((llvm::cl::Option *)&unk_1EBD01AD0, "slp-min-reg-size", &v3, &v1, &v4);
  __cxa_atexit((void (*)(void *))sub_1CBB1C45C, &unk_1EBD01AD0, &dword_1CB82C000);
  int v1 = 1;
  int v2 = 12;
  uint64_t v3 = &v2;
  v4.n128_u64[0] = (unint64_t)"Limit the recursion depth when building a vectorizable tree";
  v4.n128_u64[1] = 59;
  sub_1CBF7A9F8((uint64_t)&unk_1EBD01B90, "slp-recursion-max-depth", &v3, &v1, &v4);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBD01B90, &dword_1CB82C000);
  int v1 = 1;
  int v2 = 3;
  uint64_t v3 = &v2;
  v4.n128_u64[0] = (unint64_t)"Only vectorize small trees if they are fully vectorizable";
  v4.n128_u64[1] = 57;
  sub_1CBF7A9F8((uint64_t)&unk_1EBD01C50, "slp-min-tree-size", &v3, &v1, &v4);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBD01C50, &dword_1CB82C000);
  int v1 = 1;
  int v2 = 2;
  uint64_t v3 = &v2;
  v4.n128_u64[0] = (unint64_t)"The maximum look-ahead depth for operand reordering scores";
  v4.n128_u64[1] = 58;
  sub_1CD8E5738(&v3, &v1, &v4);
  __cxa_atexit((void (*)(void *))sub_1CBB1C45C, &qword_1EBD01D10, &dword_1CB82C000);
  LODWORD(v3) = 1;
  v4.n128_u64[0] = (unint64_t)"Display the SLP trees with Graphviz";
  v4.n128_u64[1] = 35;
  sub_1CD8E58B0(&v3, (long long *)&v4);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBD01DD0, &dword_1CB82C000);
}

void llvm::initializeVectorization(llvm *this, llvm::PassRegistry *a2)
{
  llvm::initializeLoopVectorizePass(this, a2);
  llvm::initializeSLPVectorizerPass(this, v3);
  llvm::initializeLoadStoreVectorizerLegacyPassPass(this, v4);

  llvm::initializeVectorCombineLegacyPassPass(this, v5);
}

void LLVMInitializeVectorization(llvm *a1, llvm::PassRegistry *a2)
{
  llvm::initializeLoopVectorizePass(a1, a2);
  llvm::initializeSLPVectorizerPass(a1, v3);
  llvm::initializeLoadStoreVectorizerLegacyPassPass(a1, v4);

  llvm::initializeVectorCombineLegacyPassPass(a1, v5);
}

void LLVMAddLoopVectorizePass(llvm *a1)
{
}

void LLVMAddSLPVectorizePass(llvm *a1)
{
}

void llvm::initializeVectorCombineLegacyPassPass(llvm *this, llvm::PassRegistry *a2)
{
  int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBD01E98, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CD34BBD8;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBD01E98, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CD34BBD8(uint64_t a1)
{
}

uint64_t sub_1CD34BC80(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBD01E90;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F264BE90;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBD01E98, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CD34BBD8;
    v5[1] = &PassRegistry;
    __n128 v4 = v5;
    std::__call_once(&qword_1EBD01E98, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

double sub_1CD34BD30(uint64_t a1, uint64_t **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7)
{
  *(void *)a1 = a2;
  uint64_t v7 = **a2;
  *(void *)(a1 + 8) = a1 + 24;
  *(void *)(a1 + 16) = 0x200000000;
  *(void *)(a1 + 72) = v7;
  *(void *)(a1 + 80) = a1 + 128;
  *(void *)(a1 + 88) = a1 + 136;
  *(void *)(a1 + 96) = 0;
  *(_DWORD *)(a1 + 104) = 0;
  *(_WORD *)(a1 + 108) = 512;
  *(unsigned char *)(a1 + 110) = 7;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(void *)(a1 + 128) = &unk_1F2616E88;
  *(void *)(a1 + 136) = &unk_1F2617008;
  *(void *)(a1 + 144) = a3;
  *(void *)(a1 + 152) = a4;
  *(void *)(a1 + 160) = a5;
  *(void *)(a1 + 168) = a6;
  *(unsigned char *)(a1 + 176) = a7;
  *(void *)(a1 + 184) = a1 + 200;
  *(void *)(a1 + 192) = 0x10000000000;
  *(_DWORD *)(a1 + 2264) = 0;
  *(_OWORD *)(a1 + 2248) = 0u;
  *(void *)(a1 + 2272) = 1;
  uint64_t v8 = 2280;
  int64x2_t v9 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  do
  {
    *(int64x2_t *)(a1 + v8) = v9;
    v8 += 16;
  }
  while (v8 != 2408);
  *(void *)(a1 + 2408) = a1 + 2424;
  *(void *)&double result = 0x1000000000;
  *(void *)(a1 + 2416) = 0x1000000000;
  return result;
}

uint64_t sub_1CD34BE24(int32x2_t *a1)
{
  if (byte_1EBD01F20) {
    return 0;
  }
  uint64_t v3 = (void *)a1[18];
  (*(void (**)(void, uint64_t, void))(*(void *)*v3 + 680))(*v3, 1, 0);
  uint64_t result = (*(uint64_t (**)(void))(*(void *)*v3 + 672))();
  if (result)
  {
    char v15 = 0;
    v14[0] = (uint64_t)a1;
    v14[1] = (uint64_t)&v15;
    if (*(void *)(*(void *)a1 + 80) != *(void *)a1 + 72) {
      llvm::DominatorTreeBase<llvm::BasicBlock,false>::isReachableFromEntry();
    }
    do
    {
      while (1)
      {
        uint64_t v4 = a1[24].u32[0];
        if (!v4) {
          break;
        }
        uint64_t v5 = *(void *)(*(void *)&a1[23] + 8 * v4 - 8);
        a1[24].i32[0] = v4 - 1;
        __int32 v6 = a1[283].i32[0];
        if (v6)
        {
          int32x2_t v7 = a1[281];
          __int32 v8 = v6 - 1;
          LODWORD(v9) = ((v5 >> 4) ^ (v5 >> 9)) & (v6 - 1);
          uint64_t v10 = (uint64_t *)(*(void *)&v7 + 16 * v9);
          uint64_t v11 = *v10;
          if (v5 == *v10)
          {
LABEL_15:
            uint64_t *v10 = -8192;
            a1[282] = vadd_s32(a1[282], (int32x2_t)0x1FFFFFFFFLL);
          }
          else
          {
            int v12 = 1;
            while (v11 != -4096)
            {
              int v13 = v9 + v12++;
              uint64_t v9 = v13 & v8;
              uint64_t v11 = *(void *)(*(void *)&v7 + 16 * v9);
              if (v5 == v11)
              {
                uint64_t v10 = (uint64_t *)(*(void *)&v7 + 16 * v9);
                goto LABEL_15;
              }
            }
          }
        }
        if (v5)
        {
          if (!*(void *)(v5 + 8))
          {
            if (llvm::wouldInstructionBeTriviallyDead(v5, 0)) {
              sub_1CD350AB4(a1, v5);
            }
          }
          sub_1CD34C4B0(v14, (uint64_t ***)v5);
        }
      }
    }
    while (a1[302].i32[0]);
    return v15 != 0;
  }
  return result;
}

void sub_1CD34C058()
{
}

void sub_1CD34C098(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD34C0D0(uint64_t a1, uint64_t a2)
{
  sub_1CB843600(a2, a2, (uint64_t)llvm::AssumptionCacheTracker::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)llvm::TargetTransformInfoWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)llvm::AAResultsWrapperPass::ID);
  v5[0] = &unk_1F2617E40;
  v5[1] = a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(v3);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v5);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::GlobalsAAWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)llvm::AAResultsWrapperPass::ID);

  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::BasicAAWrapperPass::ID);
}

uint64_t sub_1CD34C1D8(llvm::FunctionPass *a1, llvm::LLVMContextImpl ****a2)
{
  v36[16] = *MEMORY[0x1E4F143B8];
  if (llvm::FunctionPass::skipFunction(a1, a2)) {
    return 0;
  }
  uint64_t v5 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v6 = *v5;
  uint64_t v7 = v5[1];
  if (v6 == v7)
  {
LABEL_6:
    uint64_t v8 = 0;
  }
  else
  {
    while (*(char **)v6 != llvm::AssumptionCacheTracker::ID)
    {
      v6 += 16;
      if (v6 == v7) {
        goto LABEL_6;
      }
    }
    uint64_t v8 = *(void *)(v6 + 8);
  }
  uint64_t v9 = (llvm::AssumptionCacheTracker *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v8 + 96))(v8, llvm::AssumptionCacheTracker::ID);
  uint64_t AssumptionCache = llvm::AssumptionCacheTracker::getAssumptionCache(v9, (llvm::Function *)a2);
  uint64_t v11 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v12 = *v11;
  uint64_t v13 = v11[1];
  if (v12 == v13)
  {
LABEL_11:
    uint64_t v14 = 0;
  }
  else
  {
    while (*(char **)v12 != llvm::TargetTransformInfoWrapperPass::ID)
    {
      v12 += 16;
      if (v12 == v13) {
        goto LABEL_11;
      }
    }
    uint64_t v14 = *(void *)(v12 + 8);
  }
  char v15 = (llvm::TargetTransformInfoWrapperPass *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v14 + 96))(v14, llvm::TargetTransformInfoWrapperPass::ID);
  TTI = llvm::TargetTransformInfoWrapperPass::getTTI(v15, (const Function *)a2);
  uint64_t v17 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v18 = *v17;
  uint64_t v19 = v17[1];
  if (v18 == v19)
  {
LABEL_16:
    uint64_t v20 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v18 != &llvm::DominatorTreeWrapperPass::ID)
    {
      v18 += 16;
      if (v18 == v19) {
        goto LABEL_16;
      }
    }
    uint64_t v20 = *(void *)(v18 + 8);
  }
  uint64_t v21 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v20 + 96))(v20, &llvm::DominatorTreeWrapperPass::ID)
      + 32;
  int v22 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v23 = *v22;
  uint64_t v24 = v22[1];
  if (v23 == v24)
  {
LABEL_21:
    uint64_t v25 = 0;
  }
  else
  {
    while (*(char **)v23 != llvm::AAResultsWrapperPass::ID)
    {
      v23 += 16;
      if (v23 == v24) {
        goto LABEL_21;
      }
    }
    uint64_t v25 = *(void *)(v23 + 8);
  }
  uint64_t v26 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v25 + 96))(v25, llvm::AAResultsWrapperPass::ID);
  sub_1CD34BD30((uint64_t)&v28, (uint64_t **)a2, (uint64_t)TTI, v21, *(void *)(v26 + 32), AssumptionCache, 0);
  uint64_t v4 = sub_1CD34BE24(&v28);
  if (v35 != v36) {
    free(v35);
  }
  if ((v33 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v34, 8);
  }
  MEMORY[0x1D25D9CD0](v32[256], 8);
  if (v31 != v32) {
    free(v31);
  }
  if (v29 != &v30) {
    free(v29);
  }
  return v4;
}

void sub_1CD34C4B0(uint64_t *a1, uint64_t ***a2)
{
  uint64_t v4 = a1;
  uint64_t v727 = *MEMORY[0x1E4F143B8];
  uint64_t v684 = (uint64_t *)(*a1 + 8);
  uint64_t v685 = *a1;
  *(void *)(v685 + 56) = a2[5];
  *(void *)(v685 + 64) = a2 + 3;
  uint64_t v679 = a2 + 3;
  uint64_t v5 = a2[6];
  v699[0] = v5;
  if (v5)
  {
    llvm::MetadataTracking::track((uint64_t)v699, (unsigned __int8 *)v5, 2);
    uint64_t v6 = v699[0];
  }
  else
  {
    uint64_t v6 = 0;
  }
  sub_1CB8461A4((uint64_t)v684, 0, (uint64_t)v6);
  if (!v699[0]) {
    goto LABEL_4;
  }
  int v11 = *(unsigned __int8 *)v699[0];
  if ((v11 - 4) > 0x1E)
  {
    if ((v11 - 3) >= 0xFFFFFFFE) {
      char v33 = v699[0];
    }
    else {
      char v33 = 0;
    }
    if ((v11 - 3) >= 0xFFFFFFFE)
    {
      unint64_t v13 = (unint64_t)v33 + 8;
LABEL_64:
      v703 = v699;
      sub_1CC5FA668(v13 + 16, &v703);
      goto LABEL_4;
    }
    if (v11 == 3) {
      *((void *)v699[0] + 1) = 0;
    }
  }
  else if ((*((unsigned char *)v699[0] + 1) & 0x7F) == 2 || *((_DWORD *)v699[0] + 3))
  {
    uint64_t v12 = *((void *)v699[0] + 2);
    if ((v12 & 4) != 0)
    {
      unint64_t v13 = v12 & 0xFFFFFFFFFFFFFFF8;
      if (v13) {
        goto LABEL_64;
      }
    }
  }
LABEL_4:
  if (*(unsigned char *)(v685 + 176)) {
    goto LABEL_97;
  }
  uint64_t v7 = *a2;
  int v8 = *((unsigned __int8 *)*a2 + 8);
  *((void *)&v695 + 1) = 0;
  if (!v7) {
    goto LABEL_20;
  }
  if (v8 != 18) {
    goto LABEL_20;
  }
  *((void *)&v696 + 1) = (char *)&v695 + 8;
  if (*((unsigned char *)a2 + 16) != 90) {
    goto LABEL_20;
  }
  int v9 = *((_DWORD *)a2 + 5);
  if ((v9 & 0x40000000) != 0) {
    uint64_t v10 = (uint64_t *)*(a2 - 1);
  }
  else {
    uint64_t v10 = (uint64_t *)&a2[-4 * (v9 & 0x7FFFFFF)];
  }
  uint64_t v14 = *v10;
  unsigned int v15 = (*(unsigned char *)(*v10 + 16) - 11);
  if (v15 >= 2)
  {
    if (v15 < 0xFD)
    {
LABEL_20:
      LOBYTE(v16) = 0;
      goto LABEL_21;
    }
    v703 = (char *)&v706 + 8;
    uint64_t v704 = (uint64_t)&v706 + 8;
    uint64_t v705 = 8;
    LODWORD(v706) = 0;
    v699[0] = &v700;
    v699[1] = (void *)0x800000000;
    *(void *)uint64_t v686 = &v703;
    *(void *)&v686[2] = v699;
    BOOL v394 = 0;
    if (sub_1CC04C108((llvm::SmallPtrSetImplBase **)v686, v14))
    {
      do
      {
        BOOL v394 = LODWORD(v699[1]) == 0;
        if (!LODWORD(v699[1])) {
          break;
        }
        uint64_t v633 = *((void *)v699[0] + LODWORD(v699[1]) - 1);
        --LODWORD(v699[1]);
      }
      while ((sub_1CC04C108((llvm::SmallPtrSetImplBase **)v686, v633) & 1) != 0);
    }
    if (v699[0] != &v700) {
      free(v699[0]);
    }
    if ((void *)v704 == v703)
    {
      if (!v394) {
        goto LABEL_20;
      }
    }
    else
    {
      free((void *)v704);
      if (!v394) {
        goto LABEL_20;
      }
    }
    int v9 = *((_DWORD *)a2 + 5);
  }
  if ((v9 & 0x40000000) != 0) {
    uint64_t v395 = (uint64_t ***)*(a2 - 1);
  }
  else {
    uint64_t v395 = &a2[-4 * (v9 & 0x7FFFFFF)];
  }
  uint64_t v396 = v395[4];
  if (!v396) {
    goto LABEL_20;
  }
  **((void **)&v696 + 1) = v396;
  int v397 = *((_DWORD *)a2 + 5);
  int v398 = (v397 & 0x40000000) != 0 ? *(a2 - 1) : (uint64_t **)&a2[-4 * (v397 & 0x7FFFFFF)];
  if (!sub_1CBF535C4((uint64_t)&v697, (llvm::Constant *)v398[8])) {
    goto LABEL_20;
  }
  uint64_t v399 = (uint64_t **)*((void *)&v695 + 1);
  uint64_t v400 = *(void *)(*((void *)&v695 + 1) + 8);
  if (!v400 || *(void *)(v400 + 8)) {
    goto LABEL_20;
  }
  int v401 = v4;
  *(void *)&long long v695 = 0;
  v703 = &v695;
  if (*(unsigned char *)(*((void *)&v695 + 1) + 16) != 89) {
    goto LABEL_733;
  }
  int v402 = *(_DWORD *)(*((void *)&v695 + 1) + 20);
  v403 = (v402 & 0x40000000) != 0
       ? *(uint64_t **)(*((void *)&v695 + 1) - 8)
       : (uint64_t *)(*((void *)&v695 + 1) - 32 * (v402 & 0x7FFFFFF));
  uint64_t v471 = *v403;
  if (!v471) {
    goto LABEL_733;
  }
  *(void *)&long long v695 = v471;
  int v472 = *(_DWORD *)(*((void *)&v695 + 1) + 20);
  if ((v472 & 0x40000000) != 0) {
    uint64_t v473 = *(void *)(*((void *)&v695 + 1) - 8);
  }
  else {
    uint64_t v473 = *((void *)&v695 + 1) - 32 * (v472 & 0x7FFFFFF);
  }
  if ((sub_1CBF535C4((uint64_t)&v704, *(llvm::Constant **)(v473 + 32)) & 1) == 0)
  {
    uint64_t v399 = (uint64_t **)*((void *)&v695 + 1);
LABEL_733:
    uint64_t v474 = 0;
    *(void *)&long long v695 = v399;
    goto LABEL_734;
  }
  uint64_t v474 = 1;
  uint64_t v399 = (uint64_t **)v695;
LABEL_734:
  LOBYTE(v16) = 0;
  if (!v399 || *((unsigned char *)v399 + 16) != 60) {
    goto LABEL_738;
  }
  if ((*((_WORD *)v399 + 9) & 0x381) == 0)
  {
    uint64_t v475 = v399[1];
    if (v475)
    {
      if (!v475[1])
      {
        uint64_t v476 = *(void *)(v399[5][7] + 112);
        if (v476)
        {
          if (*((_WORD *)v399 + 9) & 0x301 | *(unsigned char *)(v476 + 18) & 0x5C) {
            goto LABEL_737;
          }
        }
        else if ((*((_WORD *)v399 + 9) & 0x301) != 0)
        {
          goto LABEL_737;
        }
        uint64_t v518 = a2[5][7][5];
        PointerBitCastOrAddrSpaceCast = llvm::Value::stripPointerCasts((llvm::Value *)*(v399 - 4));
        uint64_t v519 = **(v399 - 4);
        unsigned int v520 = *(_DWORD *)(v519 + 8);
        if ((v520 & 0xFE) == 0x12) {
          unsigned int v520 = *(_DWORD *)(**(void **)(v519 + 16) + 8);
        }
        uint64_t v521 = (llvm::FixedVectorType *)**((void **)&v695 + 1);
        unint64_t PrimitiveSizeInBits = llvm::Type::getPrimitiveSizeInBits(**((llvm::Type ***)&v695 + 1));
        if (v522 == 1) {
        unsigned int v524 = (*(uint64_t (**)(void))(***(void ***)(v685 + 144) + 704))(**(void **)(v685 + 144));
        }
        LOBYTE(v16) = 0;
        if (!PrimitiveSizeInBits || !v524) {
          goto LABEL_738;
        }
        unint64_t __bf = v524 / PrimitiveSizeInBits;
        if (!((v524 % PrimitiveSizeInBits) | PrimitiveSizeInBits & 7))
        {
          llvm::FixedVectorType::get(v521, (llvm::Type *)__bf);
          unsigned __int8 v649 = __clz(1 << ((unint64_t)*((unsigned __int16 *)v399 + 9) >> 1)) ^ 0x3F;
          uint64_t v657 = (llvm::DataLayout *)(v518 + 272);
          v665 = (llvm::PointerType *)v525;
          if (llvm::isSafeToLoadUnconditionally(PointerBitCastOrAddrSpaceCast, v525, 0, v518 + 272, (uint64_t *)v399, *(unsigned __int8 **)(v685 + 152), 0))
          {
            unsigned int v644 = 0;
            goto LABEL_830;
          }
          unsigned int v527 = *(_DWORD *)(*(void *)PointerBitCastOrAddrSpaceCast + 8);
          if ((v527 & 0xFE) == 0x12) {
            unsigned int v527 = *(_DWORD *)(**(void **)(*(void *)PointerBitCastOrAddrSpaceCast + 16) + 8);
          }
          if (v527 < 0x100) {
            goto LABEL_817;
          }
          unsigned int v528 = v527 >> 8;
          uint64_t v529 = *(unsigned int *)(v518 + 512);
          uint64_t v530 = *(void *)(v518 + 504);
          if (v529)
          {
            uint64_t v530 = *(void *)(v518 + 504);
            unint64_t v531 = *(unsigned int *)(v518 + 512);
            do
            {
              unint64_t v532 = v531 >> 1;
              uint64_t v533 = v530 + 16 * (v531 >> 1);
              unsigned int v534 = *(_DWORD *)(v533 + 8);
              uint64_t v535 = v533 + 16;
              v531 += ~(v531 >> 1);
              if (v534 < v528) {
                uint64_t v530 = v535;
              }
              else {
                unint64_t v531 = v532;
              }
            }
            while (v531);
          }
          if (v530 == *(void *)(v518 + 504) + 16 * v529 || *(_DWORD *)(v530 + 8) != v528) {
LABEL_817:
          }
            uint64_t v530 = *(void *)(v518 + 504);
          LODWORD(v704) = *(_DWORD *)(v530 + 12);
          if (v704 > 0x40) {
            operator new[]();
          }
          v703 = 0;
          PointerBitCastOrAddrSpaceCast = llvm::Value::stripAndAccumulateConstantOffsets(PointerBitCastOrAddrSpaceCast, v657, (llvm::APInt *)&v703, 0, 0, 0, v526);
          if (v704 >= 0x41) {
            unint64_t v536 = (void **)((char *)v703 + 8 * ((v704 - 1) >> 6));
          }
          else {
            unint64_t v536 = &v703;
          }
          if ((((unint64_t)*v536 >> (v704 - 1)) & 1) != 0
            || llvm::APInt::urem((uint64_t **)&v703, PrimitiveSizeInBits >> 3))
          {
            unsigned int v644 = 0;
          }
          else
          {
            llvm::APInt::udiv((llvm::APInt *)&v703, PrimitiveSizeInBits >> 3, (uint64_t)v699);
            if (LODWORD(v699[1]) >= 0x41) {
              uint64_t v604 = (void **)v699[0];
            }
            else {
              uint64_t v604 = v699;
            }
            unsigned int v644 = *(_DWORD *)v604;
            if (LODWORD(v699[1]) >= 0x41 && v699[0]) {
              MEMORY[0x1D25D9CB0]();
            }
            if (v644 < __bf
              && llvm::isSafeToLoadUnconditionally(PointerBitCastOrAddrSpaceCast, (uint64_t)v665, 0, (uint64_t)v657, (uint64_t *)v399, *(unsigned __int8 **)(v685 + 152), 0))
            {
              v605 = &v703;
              if (v704 >= 0x41) {
                v605 = v703;
              }
              int v537 = 1;
              unsigned __int8 v649 = 63 - __clz((*v605 | (1 << v649)) & -(*v605 | (1 << v649)));
LABEL_826:
              if (v704 >= 0x41 && v703) {
                MEMORY[0x1D25D9CB0](v703, 0x1000C8000313F17);
              }
              if (v537)
              {
LABEL_830:
                unsigned int PointerAlignment = llvm::Value::getPointerAlignment(PointerBitCastOrAddrSpaceCast, v657);
                if (PointerAlignment <= v649) {
                  char v539 = v649;
                }
                else {
                  char v539 = PointerAlignment;
                }
                char v658 = v539;
                unsigned int v650 = v520 >> 8;
                uint64_t v540 = (*(uint64_t (**)(void, uint64_t, uint64_t *))(***(void ***)(v685 + 144) + 888))(**(void **)(v685 + 144), 32, *v399);
                int v641 = v541;
                unsigned int v689 = __bf;
                if (__bf >= 0x41) {
                  operator new[]();
                }
                int v688 = (llvm::Constant *)1;
                uint64_t v542 = (*(uint64_t (**)(void, llvm::PointerType *, llvm::Constant **, uint64_t, uint64_t))(***(void ***)(v685 + 144) + 528))(**(void **)(v685 + 144), v665, &v688, 1, v474);
                int v544 = v543;
                if (__OFADD__(v540, v542)) {
                  int64_t v545 = ((v540 + v542) >> 63) ^ 0x8000000000000000;
                }
                else {
                  int64_t v545 = v540 + v542;
                }
                int64_t v546 = (*(uint64_t (**)(void))(***(void ***)(v685 + 144) + 888))();
                int v548 = v547;
                uint64_t v549 = *((unsigned int *)v7 + 8);
                v699[0] = &v700;
                HIDWORD(v699[1]) = 16;
                if (v549 >= 0x11)
                {
                  LODWORD(v699[1]) = 0;
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                if (v549) {
                  memset(&v700, 255, 4 * v549);
                }
                LODWORD(v699[1]) = v549;
                LODWORD(v700) = v644;
                if (v644)
                {
                  uint64_t v550 = (*(uint64_t (**)(void, uint64_t, llvm::PointerType *, long long *, void, void, void))(***(void ***)(v685 + 144) + 832))(**(void **)(v685 + 144), 7, v665, &v700, LODWORD(v699[1]), 0, 0);
                  if (v551 == 1) {
                    int v548 = 1;
                  }
                  if (__OFADD__(v546, v550)) {
                    int64_t v546 = ((v546 + v550) >> 63) ^ 0x8000000000000000;
                  }
                  else {
                    v546 += v550;
                  }
                }
                if (v544 == 1) {
                  int v552 = 1;
                }
                else {
                  int v552 = v641;
                }
                BOOL v30 = v552 == v548;
                BOOL v553 = v552 >= v548;
                if (v30) {
                  BOOL v553 = v545 >= v546;
                }
                if (v548) {
                  BOOL v16 = 0;
                }
                else {
                  BOOL v16 = v553;
                }
                if (!v16) {
                  goto LABEL_864;
                }
                uint64_t v554 = 0;
                uint64_t v555 = **v399;
                v703 = &v705;
                uint64_t v704 = 0x200000000;
                v708 = 0;
                uint64_t v709 = v555;
                v710 = &v718;
                v711 = &v719;
                uint64_t v712 = 0;
                int v713 = 0;
                __int16 v714 = 512;
                char v715 = 7;
                *((void *)&v707 + 1) = 0;
                uint64_t v717 = 0;
                uint64_t v716 = 0;
                v718 = &unk_1F2616E88;
                v719 = &unk_1F2617008;
                *((void *)&v707 + 1) = v399[5];
                v708 = v399 + 3;
                v556 = (unsigned __int8 *)v399[6];
                *(void *)uint64_t v686 = v556;
                if (v556)
                {
                  llvm::MetadataTracking::track((uint64_t)v686, v556, 2);
                  uint64_t v554 = *(void *)v686;
                }
                sub_1CB8461A4((uint64_t)&v703, 0, v554);
                if (*(void *)v686)
                {
                  int v608 = **(unsigned char **)v686;
                  if ((v608 - 4) > 0x1E)
                  {
                    if ((v608 - 3) >= 0xFFFFFFFE) {
                      uint64_t v613 = *(void *)v686;
                    }
                    else {
                      uint64_t v613 = 0;
                    }
                    if ((v608 - 3) < 0xFFFFFFFE)
                    {
                      if (v608 == 3) {
                        *(void *)(*(void *)v686 + 8) = 0;
                      }
                      goto LABEL_858;
                    }
                    unint64_t v610 = v613 + 8;
                  }
                  else
                  {
                    if ((*(unsigned char *)(*(void *)v686 + 1) & 0x7F) != 2 && !*(_DWORD *)(*(void *)v686 + 12)) {
                      goto LABEL_858;
                    }
                    uint64_t v609 = *(void *)(*(void *)v686 + 16);
                    if ((v609 & 4) == 0) {
                      goto LABEL_858;
                    }
                    unint64_t v610 = v609 & 0xFFFFFFFFFFFFFFF8;
                    if (!v610) {
                      goto LABEL_858;
                    }
                  }
                  *(void *)&long long v696 = v686;
                  sub_1CC5FA668(v610 + 16, &v696);
                }
LABEL_858:
                uint64_t v557 = (llvm::Value *)llvm::PointerType::get(v665, (llvm::Type *)v650);
                __int16 v687 = 257;
                if (*(llvm::Value **)PointerBitCastOrAddrSpaceCast != v557)
                {
                  if (*((unsigned __int8 *)PointerBitCastOrAddrSpaceCast + 16) <= 0x14u)
                  {
                    PointerBitCastOrAddrSpaceCast = (llvm::Value *)(*((uint64_t (**)(void **, llvm::Value *, llvm::Value *))*v710
                                                                    + 30))(v710, PointerBitCastOrAddrSpaceCast, v557);
                    if (PointerBitCastOrAddrSpaceCast)
                    {
                      if (*((unsigned __int8 *)PointerBitCastOrAddrSpaceCast + 16) >= 0x1Cu)
                      {
                        (*((void (**)(void **, llvm::Value *, unsigned int *, void, void **))*v711 + 2))(v711, PointerBitCastOrAddrSpaceCast, v686, *((void *)&v707 + 1), v708);
                        if (v704)
                        {
                          uint64_t v631 = (llvm::MDNode **)v703;
                          uint64_t v632 = (llvm::MDNode **)((char *)v703 + 16 * v704);
                          do
                          {
                            llvm::Instruction::setMetadata(PointerBitCastOrAddrSpaceCast, *(_DWORD *)v631, v631[1]);
                            v631 += 2;
                          }
                          while (v631 != v632);
                        }
                      }
                    }
                  }
                  else
                  {
                    LOWORD(v698) = 257;
                    PointerBitCastOrAddrSpaceCast = llvm::CastInst::CreatePointerBitCastOrAddrSpaceCast(PointerBitCastOrAddrSpaceCast, v557, (const char **)&v696, 0, v558);
                    (*((void (**)(void **))*v711 + 2))(v711);
                    if (v704)
                    {
                      uint64_t v611 = (llvm::MDNode **)v703;
                      uint64_t v612 = (llvm::MDNode **)((char *)v703 + 16 * v704);
                      do
                      {
                        llvm::Instruction::setMetadata(PointerBitCastOrAddrSpaceCast, *(_DWORD *)v611, v611[1]);
                        v611 += 2;
                      }
                      while (v611 != v612);
                    }
                  }
                }
                __int16 v687 = 257;
                uint64_t v559 = operator new(0x60uLL);
                v559[13] = v559[13] & 0x38000000 | 1;
                uint64_t v560 = (llvm::Instruction *)(v559 + 8);
                *(void *)uint64_t v559 = 0;
                *((void *)v559 + 1) = 0;
                *((void *)v559 + 2) = 0;
                *((void *)v559 + 3) = v559 + 8;
                LOWORD(v698) = 257;
                llvm::LoadInst::LoadInst((llvm::Value *)(v559 + 8), (uint64_t)v665, (uint64_t)PointerBitCastOrAddrSpaceCast, (const char **)&v696, 0, v658, 0);
                (*((void (**)(void **, llvm::Instruction *, unsigned int *, void, void **))*v711 + 2))(v711, v560, v686, *((void *)&v707 + 1), v708);
                if (v704)
                {
                  uint64_t v606 = (llvm::MDNode **)v703;
                  int v607 = (llvm::MDNode **)((char *)v703 + 16 * v704);
                  do
                  {
                    llvm::Instruction::setMetadata(v560, *(_DWORD *)v606, v606[1]);
                    v606 += 2;
                  }
                  while (v606 != v607);
                }
                uint64_t v562 = v699[0];
                uint64_t v563 = (llvm::Type *)LODWORD(v699[1]);
                LOWORD(v698) = 257;
                uint64_t v564 = llvm::PoisonValue::get(*(llvm::PoisonValue **)v560, v561);
                uint64_t v565 = sub_1CB935A74((uint64_t)&v703, (uint64_t)v560, (uint64_t)v564, v562, v563, (uint64_t)&v696);
                sub_1CD350D64(v685, (llvm::ValueAsMetadata *)a2, v565);
                if (v703 != &v705) {
                  free(v703);
                }
LABEL_864:
                if (v699[0] != &v700) {
                  free(v699[0]);
                }
                if (v689 >= 0x41 && v688) {
                  MEMORY[0x1D25D9CB0](v688, 0x1000C8000313F17);
                }
                goto LABEL_738;
              }
              goto LABEL_737;
            }
          }
          int v537 = 0;
          goto LABEL_826;
        }
      }
    }
  }
LABEL_737:
  LOBYTE(v16) = 0;
LABEL_738:
  uint64_t v4 = v401;
LABEL_21:
  *(unsigned char *)v4[1] |= v16;
  if (!llvm::isSafeToSpeculativelyExecute((uint64_t)a2, 0, 0, 0)) {
    goto LABEL_37;
  }
  int v17 = *((unsigned __int8 *)a2 + 16);
  if ((v17 - 83) < 0xFFFFFFFE)
  {
    if ((v17 - 59) >= 0xFFFFFFEE)
    {
      char v18 = 0;
      uint64_t v19 = (unsigned __int8 *)*(a2 - 8);
      if (v19)
      {
        if (v19[16] >= 0x1Cu)
        {
          char v18 = 0;
          uint64_t v20 = (uint64_t)*(a2 - 4);
          if (v20)
          {
            if (*(unsigned __int8 *)(v20 + 16) >= 0x1Cu)
            {
              int v21 = 42;
LABEL_34:
              int v688 = 0;
              long long v695 = 0uLL;
              v694 = 0;
              v703 = &v688;
              uint64_t v704 = (uint64_t)&v695;
              if (!sub_1CD3510C8((void **)&v703, (uint64_t)v19)) {
                goto LABEL_37;
              }
              v699[0] = (char *)&v695 + 8;
              v699[1] = &v694;
              if (!sub_1CD3510C8((void **)v699, v20) || *(void *)v688 != **((void **)&v695 + 1)) {
                goto LABEL_37;
              }
              int v90 = -1;
              uint64_t v693 = 0xFFFFFFFFLL;
              uint64_t v91 = a2[1];
              if (v91)
              {
                if (v91[1])
                {
                  int v90 = -1;
                }
                else
                {
                  uint64_t v437 = (uint64_t)v91[3];
                  uint64_t v704 = (uint64_t)&v693;
                  sub_1CD8E80B8((uint64_t)&v703, v437);
                  int v90 = v693;
                }
              }
              int v674 = v90;
              int v92 = *((unsigned __int8 *)a2 + 16);
              uint64_t v93 = (v92 - 28);
              int v94 = *(_DWORD **)v19;
              int v95 = (_DWORD *)**((void **)v19 - 8);
              unsigned int v645 = v92 - 41;
              if ((v92 - 41) > 0x11)
              {
                uint64_t v99 = *((_WORD *)a2 + 9) & 0x3F;
                uint64_t v100 = *(void **)(v685 + 144);
                uint64_t v101 = (uint64_t **)(**(void **)v94 + 1888);
                if (v94 && (v94[2] & 0xFE) == 0x12)
                {
                  uint64_t v484 = (llvm::Type *)v94[8];
                  if (v94[2] == 19) {
                    llvm::ScalableVectorType::get(v101, v484);
                  }
                  else {
                    llvm::FixedVectorType::get((llvm::FixedVectorType *)v101, v484);
                  }
                  uint64_t v101 = v485;
                }
                uint64_t v651 = (llvm::DataLayout *)(*(uint64_t (**)(void, uint64_t, _DWORD *, uint64_t **, uint64_t, void, void))(*(void *)*v100 + 864))(*v100, v93, v94, v101, v99, 0, 0);
                int v659 = v102;
                uint64_t v103 = *(void **)(v685 + 144);
                uint64_t v104 = (uint64_t **)(**(void **)v95 + 1888);
                if (v95 && (v95[2] & 0xFE) == 0x12)
                {
                  uint64_t v486 = (llvm::Type *)v95[8];
                  if (v95[2] == 19) {
                    llvm::ScalableVectorType::get(v104, v486);
                  }
                  else {
                    llvm::FixedVectorType::get((llvm::FixedVectorType *)v104, v486);
                  }
                  uint64_t v104 = v487;
                }
                uint64_t v97 = (*(uint64_t (**)(void, uint64_t, _DWORD *, uint64_t **, uint64_t, void, void))(*(void *)*v103 + 864))(*v103, v93, v95, v104, v99, 0, 0);
                int __ba = v105;
              }
              else
              {
                uint64_t v651 = (llvm::DataLayout *)(*(uint64_t (**)(void, uint64_t, _DWORD *, void, void, void, void, void, void, void, void))(***(void ***)(v685 + 144) + 824))(**(void **)(v685 + 144), v93, v94, 0, 0, 0, 0, 0, 0, 0, 0);
                int v659 = v96;
                uint64_t v97 = (*(uint64_t (**)(void, uint64_t, _DWORD *))(***(void ***)(v685 + 144) + 824))(**(void **)(v685 + 144), v93, v95);
                int __ba = v98;
              }
              uint64_t v106 = *((void *)v19 - 4);
              int v107 = (unsigned int *)(v106 + 24);
              if (*(_DWORD *)(v106 + 32) >= 0x41u) {
                int v107 = *(unsigned int **)v107;
              }
              uint64_t v108 = *v107;
              uint64_t v109 = *(void *)(v20 - 32);
              int v110 = (void *)(v109 + 24);
              if (*(_DWORD *)(v109 + 32) >= 0x41u) {
                int v110 = (void *)*v110;
              }
              int v111 = *(_DWORD *)v110;
              v699[0] = (void *)(*(uint64_t (**)(void, uint64_t, _DWORD *, uint64_t))(***(void ***)(v685 + 144)
                                                                                              + 872))(**(void **)(v685 + 144), 61, v95, v108);
              v699[1] = v112;
              uint64_t v113 = (*(uint64_t (**)(void))(***(void ***)(v685 + 144) + 872))();
              *(void *)&long long v696 = v113;
              *((void *)&v696 + 1) = v114;
              BOOL v115 = SLODWORD(v699[1]) > (int)v114;
              if (LODWORD(v699[1]) == v114) {
                BOOL v115 = v113 < (uint64_t)v699[0];
              }
              BOOL v30 = !v115;
              int v116 = v699;
              if (!v30) {
                int v116 = (void **)&v696;
              }
              *(_OWORD *)uint64_t v686 = *(_OWORD *)v116;
              uint64_t v682 = v4;
              if (*((void *)v19 - 8) == *(void *)(v20 - 64) && v108 == v111)
              {
                uint64_t v117 = *((void *)v19 + 1);
                if (v19 == (unsigned __int8 *)v20)
                {
                  if (v117)
                  {
                    uint64_t v117 = *(void *)(v117 + 8);
                    if (v117) {
                      LODWORD(v117) = *(void *)(v117 + 8) == 0;
                    }
                  }
                  unsigned int v118 = v117 ^ 1;
                }
                else
                {
                  unsigned int v118 = !v117
                      || *(void *)(v117 + 8)
                      || (uint64_t v393 = *(void *)(v20 + 8)) == 0
                      || *(void *)(v393 + 8) != 0;
                }
                unsigned int v143 = v686[2];
                if (__OFADD__(*(void *)v686, v651)) {
                  int64_t v121 = (((uint64_t)v651 + *(void *)v686) >> 63) ^ 0x8000000000000000;
                }
                else {
                  int64_t v121 = (int64_t)v651 + *(void *)v686;
                }
                if (v659 == 1) {
                  signed int v123 = 1;
                }
                else {
                  signed int v123 = v686[2];
                }
                if (__OFADD__(v97, *(void *)v686)) {
                  unint64_t v144 = ((v97 + *(void *)v686) >> 63) ^ 0x8000000000000000;
                }
                else {
                  unint64_t v144 = v97 + *(void *)v686;
                }
                v703 = (void *)v118;
                LODWORD(v704) = 0;
                sub_1CB90C9D4((uint64_t)&v703, (uint64_t)v686);
                BOOL v140 = v704 == 1 || v143 == 1;
                BOOL v141 = __OFADD__(v144, v703);
                uint64_t v142 = (uint64_t)v703 + v144;
              }
              else
              {
                int64_t v119 = (int64_t)v699[0] + v113;
                if (__OFADD__(v699[0], v113)) {
                  int64_t v119 = (v119 >> 63) ^ 0x8000000000000000;
                }
                BOOL v141 = __OFADD__(v119, v651);
                uint64_t v120 = (uint64_t)v651 + v119;
                if (v141) {
                  int64_t v121 = (v120 >> 63) ^ 0x8000000000000000;
                }
                else {
                  int64_t v121 = v120;
                }
                if (v114 == 1 || v659 == 1) {
                  signed int v123 = 1;
                }
                else {
                  signed int v123 = (signed int)v699[1];
                }
                if (__OFADD__(v97, *(void *)v686)) {
                  unint64_t v124 = ((v97 + *(void *)v686) >> 63) ^ 0x8000000000000000;
                }
                else {
                  unint64_t v124 = v97 + *(void *)v686;
                }
                uint64_t v125 = *((void *)v19 + 1);
                if (v125) {
                  BOOL v126 = *(void *)(v125 + 8) != 0;
                }
                else {
                  BOOL v126 = 1;
                }
                unsigned int v133 = v686[2];
                v703 = (void *)v126;
                LODWORD(v704) = 0;
                sub_1CB90C9D4((uint64_t)&v703, (uint64_t)v699);
                uint64_t v134 = v704;
                if (__OFADD__(v124, v703)) {
                  int v135 = (char *)(((uint64_t)((uint64_t)v703 + v124) >> 63) ^ 0x8000000000000000);
                }
                else {
                  int v135 = (char *)v703 + v124;
                }
                uint64_t v136 = *(void *)(v20 + 8);
                if (v136) {
                  BOOL v137 = *(void *)(v136 + 8) != 0;
                }
                else {
                  BOOL v137 = 1;
                }
                v703 = (void *)v137;
                LODWORD(v704) = 0;
                sub_1CB90C9D4((uint64_t)&v703, (uint64_t)&v696);
                BOOL v140 = v704 == 1 || v134 == 1 || v133 == 1;
                BOOL v141 = __OFADD__(v135, v703);
                uint64_t v142 = (uint64_t)v703 + (void)v135;
              }
              if (v141) {
                int64_t v146 = (v142 >> 63) ^ 0x8000000000000000;
              }
              else {
                int64_t v146 = v142;
              }
              if (v140) {
                int v147 = 1;
              }
              else {
                int v147 = __ba;
              }
              uint64_t v148 = sub_1CD3511A8(v685, (uint64_t)v19, v20, v674);
              if (v148)
              {
                uint64_t v149 = (unsigned __int8 *)v148;
                if (v645 > 0x11 || !byte_1EBD01FE0)
                {
                  uint64_t v150 = (*(uint64_t (**)(void, uint64_t, _DWORD *, void, void, void, void))(***(void ***)(v685 + 144) + 832))(**(void **)(v685 + 144), 7, v95, 0, 0, 0, 0);
                  char v18 = 0;
                  if (v151 == 1) {
                    int v152 = 1;
                  }
                  else {
                    int v152 = v147;
                  }
                  int64_t v153 = v146 + v150;
                  if (__OFADD__(v146, v150)) {
                    int64_t v153 = ((v146 + v150) >> 63) ^ 0x8000000000000000;
                  }
                  BOOL v154 = v121 < v153;
                  BOOL v30 = v123 == v152;
                  BOOL v155 = v123 < v152;
                  if (v30) {
                    BOOL v155 = v154;
                  }
                  if (v155) {
                    goto LABEL_674;
                  }
                  uint64_t v156 = (void **)&v695;
                  if (v149 == v19) {
                    uint64_t v156 = &v694;
                  }
                  uint64_t v157 = *((void *)v149 - 8);
                  if (*(unsigned __int8 *)(v157 + 16) >= 0x15u)
                  {
                    BOOL v158 = *v156;
                    uint64_t v159 = *((void *)v149 - 4);
                    int v160 = (unsigned int *)(v159 + 24);
                    if (*(_DWORD *)(v159 + 32) >= 0x41u) {
                      int v160 = *(unsigned int **)v160;
                    }
                    uint64_t v162 = (unsigned __int8 *)sub_1CD351348(v157, (llvm::Type *)*v160, (int)v158, (uint64_t)v684);
                    uint64_t v163 = v158;
                    WORD4(v706) = 257;
                    uint64_t v164 = **(void **)(v685 + 72);
                    int v165 = *(llvm::ConstantInt **)(v164 + 1984);
                    unint64_t v166 = *(unsigned int *)(v164 + 1992);
                    LODWORD(v699[1]) = v166 >> 8;
                    if (v166 >> 8 > 0x40) {
                      operator new[]();
                    }
                    if (v166 <= 0xFF) {
                      unint64_t v167 = 0;
                    }
                    else {
                      unint64_t v167 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v166) + 63);
                    }
                    v699[0] = (void *)(v167 & v163);
                    int v168 = (unsigned __int8 *)llvm::ConstantInt::get(v165, (llvm::LLVMContext *)v699, v161);
                    if (LODWORD(v699[1]) >= 0x41 && v699[0]) {
                      MEMORY[0x1D25D9CB0](v699[0], 0x1000C8000313F17);
                    }
                    uint64_t v169 = sub_1CB8445F4((uint64_t)v684, v162, v168, (uint64_t)&v703);
                    if (v149 == v19) {
                      uint64_t v170 = (unsigned __int8 *)v169;
                    }
                    else {
                      uint64_t v170 = v19;
                    }
                    if (v169) {
                      BOOL v171 = v149 == v19;
                    }
                    else {
                      BOOL v171 = 1;
                    }
                    if (!v171) {
                      uint64_t v20 = (uint64_t)v169;
                    }
                    if (v169)
                    {
                      uint64_t v19 = v170;
                      goto LABEL_311;
                    }
                  }
                }
              }
              else
              {
                BOOL v172 = v121 < v146;
                if (v123 != v147) {
                  BOOL v172 = v123 < v147;
                }
                if (!v172)
                {
LABEL_311:
                  if (v21 == 42)
                  {
                    uint64_t v173 = *((void *)v19 - 8);
                    uint64_t v174 = *(void *)(v20 - 64);
                    uint64_t v175 = *((unsigned __int8 *)a2 + 16) - 28;
                    WORD4(v706) = 257;
                    unsigned int v176 = sub_1CB844E98((uint64_t)v684, v175, v173, v174, (uint64_t)&v703, 0);
                    int v177 = (unsigned __int8 *)v176;
                    if (v176 && *((unsigned __int8 *)v176 + 16) >= 0x1Cu) {
                      llvm::Instruction::copyIRFlags((uint64_t)v176, (uint64_t)a2, 1);
                    }
                    unsigned int v178 = (unsigned __int8 *)*((void *)v19 - 4);
                    WORD4(v706) = 257;
                    uint64_t v179 = (uint64_t)v684;
                    BOOL v180 = v177;
                  }
                  else
                  {
                    uint64_t v389 = *((_WORD *)a2 + 9) & 0x3F;
                    uint64_t v390 = (void *)*((void *)v19 - 8);
                    uint64_t v391 = *(void *)(v20 - 64);
                    WORD4(v706) = 257;
                    if (v389 > 0xF) {
                      FCmpHelper = sub_1CB845F20((uint64_t)v684, v389, v390, v391, (uint64_t)&v703);
                    }
                    else {
                      FCmpHelper = llvm::IRBuilderBase::CreateFCmpHelper((uint64_t)v684, v389, (uint64_t)v390, v391, (uint64_t)&v703, 0, 0);
                    }
                    BOOL v180 = (unsigned __int8 *)FCmpHelper;
                    unsigned int v178 = (unsigned __int8 *)*((void *)v19 - 4);
                    WORD4(v706) = 257;
                    uint64_t v179 = (uint64_t)v684;
                  }
                  int v412 = sub_1CB8445F4(v179, v180, v178, (uint64_t)&v703);
                  sub_1CD350D64(v685, (llvm::ValueAsMetadata *)a2, v412);
                  int v413 = *(_DWORD *)(v685 + 192);
                  v703 = v19;
                  LODWORD(v704) = v413;
                  int v414 = *(_DWORD *)(v685 + 2264);
                  if (v414)
                  {
                    uint64_t v415 = *(void *)(v685 + 2248);
                    unsigned int v416 = (v414 - 1) & ((v19 >> 4) ^ (v19 >> 9));
                    unint64_t v417 = (unsigned __int8 **)(v415 + 16 * v416);
                    uint64_t v418 = *v417;
                    if (*v417 == v19) {
                      goto LABEL_657;
                    }
                    int v419 = 0;
                    int v420 = 1;
                    while (v418 != (unsigned __int8 *)-4096)
                    {
                      if (v419) {
                        BOOL v421 = 0;
                      }
                      else {
                        BOOL v421 = v418 == (unsigned __int8 *)-8192;
                      }
                      if (v421) {
                        int v419 = v417;
                      }
                      unsigned int v422 = v416 + v420++;
                      unsigned int v416 = v422 & (v414 - 1);
                      unint64_t v417 = (unsigned __int8 **)(v415 + 16 * v416);
                      uint64_t v418 = *v417;
                      if (*v417 == v19) {
                        goto LABEL_657;
                      }
                    }
                    if (v419) {
                      int v423 = v419;
                    }
                    else {
                      int v423 = v417;
                    }
                  }
                  else
                  {
                    int v423 = 0;
                  }
                  uint64_t v424 = sub_1CBF569E0((_DWORD *)(v685 + 2248), (uint64_t)&v703, (uint64_t *)&v703, v423);
                  *uint64_t v424 = v703;
                  *((_DWORD *)v424 + 2) = v704;
                  unsigned int v425 = *(_DWORD *)(v685 + 192);
                  if (v425 >= *(_DWORD *)(v685 + 196)) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  *(void *)(*(void *)(v685 + 184) + 8 * v425) = v19;
                  int v413 = *(_DWORD *)(v685 + 192) + 1;
                  *(_DWORD *)(v685 + 192) = v413;
                  uint64_t v415 = *(void *)(v685 + 2248);
                  int v414 = *(_DWORD *)(v685 + 2264);
LABEL_657:
                  v703 = (void *)v20;
                  LODWORD(v704) = v413;
                  if (v414)
                  {
                    int v426 = v414 - 1;
                    unsigned int v427 = (v414 - 1) & ((v20 >> 4) ^ (v20 >> 9));
                    uint64_t v428 = (void *)(v415 + 16 * v427);
                    uint64_t v429 = *v428;
                    if (*v428 == v20)
                    {
LABEL_673:
                      char v18 = 1;
                      goto LABEL_674;
                    }
                    uint64_t v430 = 0;
                    int v431 = 1;
                    while (v429 != -4096)
                    {
                      if (v430) {
                        BOOL v432 = 0;
                      }
                      else {
                        BOOL v432 = v429 == -8192;
                      }
                      if (v432) {
                        uint64_t v430 = v428;
                      }
                      unsigned int v433 = v427 + v431++;
                      unsigned int v427 = v433 & v426;
                      uint64_t v428 = (void *)(v415 + 16 * v427);
                      uint64_t v429 = *v428;
                      if (*v428 == v20) {
                        goto LABEL_673;
                      }
                    }
                    if (v430) {
                      int v434 = v430;
                    }
                    else {
                      int v434 = v428;
                    }
                  }
                  else
                  {
                    int v434 = 0;
                  }
                  uint64_t v435 = sub_1CBF569E0((_DWORD *)(v685 + 2248), (uint64_t)&v703, (uint64_t *)&v703, v434);
                  *uint64_t v435 = v703;
                  *((_DWORD *)v435 + 2) = v704;
                  unsigned int v436 = *(_DWORD *)(v685 + 192);
                  if (v436 >= *(_DWORD *)(v685 + 196)) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  *(void *)(*(void *)(v685 + 184) + 8 * v436) = v20;
                  ++*(_DWORD *)(v685 + 192);
                  goto LABEL_673;
                }
              }
              char v18 = 0;
LABEL_674:
              uint64_t v4 = v682;
              goto LABEL_38;
            }
          }
        }
      }
      goto LABEL_38;
    }
LABEL_37:
    char v18 = 0;
    goto LABEL_38;
  }
  char v18 = 0;
  uint64_t v19 = (unsigned __int8 *)*(a2 - 8);
  if (v19)
  {
    if (v19[16] >= 0x1Cu)
    {
      char v18 = 0;
      uint64_t v20 = (uint64_t)*(a2 - 4);
      if (v20)
      {
        if (*(unsigned __int8 *)(v20 + 16) >= 0x1Cu)
        {
          int v21 = *((_WORD *)a2 + 9) & 0x3F;
          goto LABEL_34;
        }
      }
    }
  }
LABEL_38:
  *(unsigned char *)v4[1] |= v18;
  int v688 = 0;
  memset(v686, 0, sizeof(v686));
  v703 = &v688;
  uint64_t v705 = (uint64_t)v686;
  unsigned int v22 = *((unsigned __int8 *)a2 + 16);
  BOOL v342 = v22 >= 0x1C;
  unsigned int v23 = v22 - 28;
  if (!v342) {
    unsigned int v23 = *((unsigned __int16 *)a2 + 9);
  }
  if (v23 == 49)
  {
    int v24 = *((_DWORD *)a2 + 5);
    uint64_t v25 = (v24 & 0x40000000) != 0 ? (uint64_t *)*(a2 - 1) : (uint64_t *)&a2[-4 * (v24 & 0x7FFFFFF)];
    uint64_t v26 = *v25;
    uint64_t v27 = *(void *)(*v25 + 8);
    if (v27)
    {
      if (!*(void *)(v27 + 8) && sub_1CC9E8D20((uint64_t)&v703, v26))
      {
        uint64_t v28 = *((unsigned char *)*a2 + 8) == 18 ? (uint64_t)*a2 : 0;
        uint64_t v29 = *(unsigned char *)(*(void *)v688 + 8) == 18 ? *(void *)v688 : 0;
        BOOL v30 = !v29 || v28 == 0;
        if (!v30)
        {
          int v31 = *((_DWORD *)a2 + 5);
          uint64_t v32 = (v31 & 0x40000000) != 0 ? *(a2 - 1) : (uint64_t **)&a2[-4 * (v31 & 0x7FFFFFF)];
          if (**v32 == v29)
          {
            unsigned int v79 = *(_DWORD *)(v28 + 32);
            unsigned int v80 = *(_DWORD *)(v29 + 32);
            v703 = &v705;
            uint64_t v704 = 0x1000000000;
            if (v80 > v79)
            {
              if (!llvm::widenShuffleMaskElts(v80 / v79, *(int **)v686, *(unint64_t *)&v686[2], (unsigned int *)&v703))
              {
                char v34 = 0;
LABEL_232:
                if (v703 != &v705) {
                  free(v703);
                }
                goto LABEL_70;
              }
            }
            else
            {
              llvm::narrowShuffleMaskElts(v79 / v80, *(int **)v686, *(uint64_t *)&v686[2], (uint64_t)&v703);
            }
            uint64_t v81 = (*(uint64_t (**)(void, uint64_t, uint64_t, void *, void, void, void))(***(void ***)(v685 + 144) + 832))(**(void **)(v685 + 144), 7, v28, v703, v704, 0, 0);
            int v83 = v82;
            char v34 = 0;
            BOOL v85 = (*(uint64_t (**)(void, uint64_t))(***(void ***)(v685 + 144) + 832))(**(void **)(v685 + 144), 7) >= v81;
            if (v84 != v83) {
              BOOL v85 = (int)v84 >= v83;
            }
            if (!v83 && v85)
            {
              uint64_t v86 = v688;
              LOWORD(v698) = 257;
              if (*(void *)v688 != v28)
              {
                if (*((unsigned __int8 *)v688 + 16) <= 0x14u)
                {
                  uint64_t v128 = (*(uint64_t (**)(void, uint64_t, llvm::Constant *, uint64_t))(**(void **)(v685 + 80)
                                                                                               + 224))(*(void *)(v685 + 80), 49, v688, v28);
                  uint64_t v86 = (llvm::Constant *)v128;
                  if (v128)
                  {
                    if (*(unsigned __int8 *)(v128 + 16) >= 0x1Cu)
                    {
                      (*(void (**)(void, uint64_t, long long *, void, void))(**(void **)(v685 + 88)
                                                                                          + 16))(*(void *)(v685 + 88), v128, &v696, *(void *)(v685 + 56), *(void *)(v685 + 64));
                      uint64_t v628 = *(unsigned int *)(v685 + 16);
                      if (v628)
                      {
                        uint64_t v629 = *(void *)(v685 + 8);
                        uint64_t v630 = v629 + 16 * v628;
                        do
                        {
                          llvm::Instruction::setMetadata(v86, *(_DWORD *)v629, *(llvm::MDNode **)(v629 + 8));
                          v629 += 16;
                        }
                        while (v629 != v630);
                      }
                    }
                  }
                }
                else
                {
                  LOWORD(v701) = 257;
                  uint64_t v86 = llvm::CastInst::Create(49, (uint64_t)v688, v28, (const char **)v699, 0);
                  (*(void (**)(void, llvm::Constant *, long long *, void, void))(**(void **)(v685 + 88)
                                                                                               + 16))(*(void *)(v685 + 88), v86, &v696, *(void *)(v685 + 56), *(void *)(v685 + 64));
                  uint64_t v87 = *(unsigned int *)(v685 + 16);
                  if (v87)
                  {
                    uint64_t v88 = *(void *)(v685 + 8);
                    uint64_t v89 = v88 + 16 * v87;
                    do
                    {
                      llvm::Instruction::setMetadata(v86, *(_DWORD *)v88, *(llvm::MDNode **)(v88 + 8));
                      v88 += 16;
                    }
                    while (v88 != v89);
                  }
                }
              }
              int v129 = v703;
              uint64_t v130 = (llvm::Type *)v704;
              LOWORD(v701) = 257;
              uint64_t v131 = llvm::PoisonValue::get(*(llvm::PoisonValue **)v86, v84);
              uint64_t v132 = sub_1CB935A74((uint64_t)v684, (uint64_t)v86, (uint64_t)v131, v129, v130, (uint64_t)v699);
              sub_1CD350D64(v685, (llvm::ValueAsMetadata *)a2, v132);
              char v34 = 1;
            }
            goto LABEL_232;
          }
        }
      }
    }
  }
  char v34 = 0;
LABEL_70:
  uint64_t v35 = (char *)v4[1];
  char v36 = *v35 | v34;
  char *v35 = v36;
  unsigned int v37 = *a2;
  if (*((unsigned __int8 *)a2 + 16) - 41 <= 0x11 && *((_DWORD *)v37 + 2) == 269)
  {
    int v38 = *((_DWORD *)a2 + 5);
    if ((v38 & 0x40000000) != 0) {
      uint64_t v39 = (uint64_t *)*(a2 - 1);
    }
    else {
      uint64_t v39 = (uint64_t *)&a2[-4 * (v38 & 0x7FFFFFF)];
    }
    uint64_t v40 = *v39;
    uint64_t v41 = v39[4];
    int v688 = 0;
    long long v695 = 0uLL;
    v694 = 0;
    uint64_t v692 = 0;
    v703 = (char *)&v692 + 4;
    uint64_t v704 = (uint64_t)&v688;
    uint64_t v705 = (uint64_t)&v695;
    uint64_t v42 = *(void *)(v40 + 8);
    if (!v42) {
      goto LABEL_88;
    }
    if (*(void *)(v42 + 8)) {
      goto LABEL_88;
    }
    if (!sub_1CD351494((uint64_t)&v703, v40)) {
      goto LABEL_88;
    }
    v699[0] = &v692;
    v699[1] = (char *)&v695 + 8;
    *(void *)&long long v700 = &v694;
    uint64_t v43 = *(void *)(v41 + 8);
    if (!v43) {
      goto LABEL_88;
    }
    if (*(void *)(v43 + 8)) {
      goto LABEL_88;
    }
    if (!sub_1CD351494((uint64_t)v699, v41)) {
      goto LABEL_88;
    }
    if (HIDWORD(v692) != v692) {
      goto LABEL_88;
    }
    uint64_t v693 = 0;
    uint64_t v690 = 0;
    uint64_t v691 = 0;
    v703 = &v693;
    uint64_t v704 = (uint64_t)&v691;
    uint64_t v44 = *((void *)v688 + 1);
    if (!v44) {
      goto LABEL_88;
    }
    if (!*(void *)(v44 + 8)
      && sub_1CD3510C8((void **)&v703, (uint64_t)v688)
      && (v699[0] = (void *)v693, v699[1] = &v690, (uint64_t v45 = *(void *)(*((void *)&v695 + 1) + 8)) != 0)
      && !*(void *)(v45 + 8)
      && (sub_1CD63F4FC((uint64_t)v699, *((uint64_t *)&v695 + 1)) & 1) != 0
      && (uint64_t v488 = v688, (v489 = sub_1CD3511A8(v685, (uint64_t)v688, *((uint64_t *)&v695 + 1), -1)) != 0))
    {
      LOBYTE(v2) = 0;
      int v490 = *(void ***)v693;
      if (*(void *)v693 && *((unsigned char *)v490 + 8) == 18)
      {
        uint64_t v491 = (llvm::Constant *)v489;
        unsigned int v677 = HIDWORD(v692);
        if (HIDWORD(v692) >= 0x10) {
          uint64_t v492 = 53;
        }
        else {
          uint64_t v492 = 54;
        }
        uint64_t v493 = (*(uint64_t (**)(void, void, void **, void))(***(void ***)(v685 + 144) + 872))(**(void **)(v685 + 144), *((unsigned __int8 *)v488 + 16) - 28, v490, v691);
        int v648 = v494;
        uint64_t v495 = (*(uint64_t (**)(void))(***(void ***)(v685 + 144) + 872))();
        int __be = v496;
        if (__OFADD__(v493, v495)) {
          unint64_t v497 = ((v493 + v495) >> 63) ^ 0x8000000000000000;
        }
        else {
          unint64_t v497 = v493 + v495;
        }
        int v498 = *(void **)(v685 + 144);
        uint64_t v499 = *(void *)v688;
        int v500 = (uint64_t **)(***(void ***)v688 + 1888);
        if (*(void *)v688 && (*(_DWORD *)(v499 + 8) & 0xFE) == 0x12)
        {
          int v614 = (llvm::Type *)*(unsigned int *)(v499 + 32);
          if (*(_DWORD *)(v499 + 8) == 19) {
            llvm::ScalableVectorType::get(v500, v614);
          }
          else {
            llvm::FixedVectorType::get((llvm::FixedVectorType *)v500, v614);
          }
          int v500 = v615;
        }
        uint64_t v501 = (void *)(*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t **, void, void, void))(*(void *)*v498 + 864))(*v498, v492, v499, v500, v677, 0, 0);
        v699[0] = (void *)2;
        LODWORD(v699[1]) = 0;
        v703 = v501;
        uint64_t v704 = v502;
        sub_1CB90C9D4((uint64_t)&v703, (uint64_t)v699);
        uint64_t v643 = v704;
        if (__OFADD__(v497, v703)) {
          uint64_t v503 = (char *)(((uint64_t)((uint64_t)v703 + v497) >> 63) ^ 0x8000000000000000);
        }
        else {
          uint64_t v503 = (char *)v703 + v497;
        }
        uint64_t v504 = (*(uint64_t (**)(void, void, uint64_t **))(***(void ***)(v685 + 144) + 824))(**(void **)(v685 + 144), *((unsigned __int8 *)a2 + 16) - 28, *a2);
        unsigned int v506 = v505;
        unint64_t v507 = (unint64_t)&v503[v504];
        if (__OFADD__(v503, v504)) {
          unint64_t v507 = ((uint64_t)&v503[v504] >> 63) ^ 0x8000000000000000;
        }
        int64_t v640 = v507;
        if (v491 == v488) {
          int v508 = v690;
        }
        else {
          int v508 = v691;
        }
        int v664 = v508;
        if (v491 == v488) {
          unsigned int v509 = v691;
        }
        else {
          unsigned int v509 = v690;
        }
        unsigned int v656 = v509;
        uint64_t v510 = *(void ***)v693;
        uint64_t v511 = (uint64_t **)(***(void ***)v693 + 1888);
        if (*(void *)v693 && (v510[1] & 0xFE) == 0x12)
        {
          uint64_t v616 = (llvm::Type *)*((unsigned int *)v510 + 8);
          if (*((_DWORD *)v510 + 2) == 19) {
            llvm::ScalableVectorType::get(v511, v616);
          }
          else {
            llvm::FixedVectorType::get((llvm::FixedVectorType *)v511, v616);
          }
          uint64_t v511 = v617;
        }
        uint64_t v512 = *(void **)(v685 + 144);
        uint64_t v513 = *(void *)v693;
        uint64_t v514 = (uint64_t **)(***(void ***)v693 + 1888);
        if (*(void *)v693 && (*(_DWORD *)(v513 + 8) & 0xFE) == 0x12)
        {
          uint64_t v618 = (llvm::Type *)*(unsigned int *)(v513 + 32);
          if (*(_DWORD *)(v513 + 8) == 19) {
            llvm::ScalableVectorType::get(v514, v618);
          }
          else {
            llvm::FixedVectorType::get((llvm::FixedVectorType *)v514, v618);
          }
          uint64_t v514 = v619;
        }
        uint64_t v635 = v506;
        uint64_t v515 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t **, void, void, void))(*(void *)*v512 + 864))(*v512, v492, v513, v514, v677, 0, 0);
        int v634 = v516;
        uint64_t v517 = *((unsigned int *)v490 + 8);
        v699[0] = &v700;
        HIDWORD(v699[1]) = 32;
        if (v517 >= 0x21)
        {
          LODWORD(v699[1]) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v517) {
          memset(&v700, 255, 4 * v517);
        }
        LODWORD(v699[1]) = v517;
        *((_DWORD *)&v700 + v664) = v656;
        uint64_t v566 = (*(uint64_t (**)(void, uint64_t))(***(void ***)(v685 + 144) + 832))(**(void **)(v685 + 144), 7);
        int v568 = v567;
        if (__OFADD__(v515, v566)) {
          unint64_t v569 = ((v515 + v566) >> 63) ^ 0x8000000000000000;
        }
        else {
          unint64_t v569 = v515 + v566;
        }
        uint64_t v570 = (*(uint64_t (**)(void, void, uint64_t **))(***(void ***)(v685 + 144) + 824))(**(void **)(v685 + 144), *((unsigned __int8 *)a2 + 16) - 28, v511);
        int v572 = v571;
        if (__OFADD__(v569, v570)) {
          unint64_t v573 = ((uint64_t)(v569 + v570) >> 63) ^ 0x8000000000000000;
        }
        else {
          unint64_t v573 = v569 + v570;
        }
        uint64_t v574 = (*(uint64_t (**)(void))(***(void ***)(v685 + 144) + 872))();
        int64_t v576 = v573 + v574;
        if (__OFADD__(v573, v574)) {
          int64_t v576 = ((uint64_t)(v573 + v574) >> 63) ^ 0x8000000000000000;
        }
        if (__be == 1 || v643 == 1 || v635 == 1) {
          int v579 = 1;
        }
        else {
          int v579 = v648;
        }
        if (v568 == 1 || v572 == 1 || v575 == 1) {
          int v582 = 1;
        }
        else {
          int v582 = v634;
        }
        BOOL v583 = v640 >= v576;
        BOOL v30 = v579 == v582;
        BOOL v584 = v579 >= v582;
        if (!v30) {
          BOOL v583 = v584;
        }
        if (v582) {
          LODWORD(v2) = 0;
        }
        else {
          LODWORD(v2) = v583;
        }
        if (v2 == 1)
        {
          unint64_t v585 = *((unsigned int *)v490 + 8);
          int v586 = llvm::UndefValue::get((llvm::UndefValue *)v490[3], v575);
          v703 = &v705;
          uint64_t v704 = 0x2000000000;
          sub_1CBFC6B20((uint64_t)&v703, v585, (uint64_t)v586);
          *((void *)v703 + v691) = v695;
          *((void *)v703 + v690) = v694;
          int v587 = (void *)v693;
          uint64_t v588 = (llvm::FixedVectorType ***)v703;
          uint64_t v589 = v704;
          uint64_t Impl = (uint64_t)llvm::ConstantVector::getImpl((llvm::FixedVectorType ***)v703, (llvm::Type *)v704);
          if (!Impl)
          {
            llvm::FixedVectorType::get(**v588, (llvm::Type *)v589);
            uint64_t Impl = sub_1CC56A4DC(**v591 + 1288, (uint64_t)v591, v588, v589);
          }
          LOWORD(v698) = 257;
          if (v677 > 0xF) {
            int v592 = sub_1CB845F20((uint64_t)v684, v677, v587, Impl, (uint64_t)&v696);
          }
          else {
            int v592 = llvm::IRBuilderBase::CreateFCmpHelper((uint64_t)v684, v677, (uint64_t)v587, Impl, (uint64_t)&v696, 0, 0);
          }
          uint64_t v593 = (uint64_t)v592;
          uint64_t v594 = sub_1CD351348((uint64_t)v592, (llvm::Type *)v656, v664, (uint64_t)v684);
          uint64_t v595 = *((unsigned __int8 *)a2 + 16) - 28;
          LOWORD(v698) = 257;
          int v597 = (unsigned __int8 *)sub_1CB844E98((uint64_t)v684, v595, v593, (uint64_t)v594, (uint64_t)&v696, 0);
          LOWORD(v698) = 257;
          uint64_t v598 = **(void **)(v685 + 72);
          uint64_t v599 = *(llvm::ConstantInt **)(v598 + 1984);
          unint64_t v600 = *(unsigned int *)(v598 + 1992);
          v686[2] = v600 >> 8;
          if (v600 >> 8 > 0x40) {
            operator new[]();
          }
          if (v600 <= 0xFF) {
            unint64_t v601 = 0;
          }
          else {
            unint64_t v601 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v600) + 63);
          }
          *(void *)uint64_t v686 = v601 & v664;
          uint64_t v602 = (unsigned __int8 *)llvm::ConstantInt::get(v599, (llvm::LLVMContext *)v686, v596);
          if (v686[2] >= 0x41 && *(void *)v686) {
            MEMORY[0x1D25D9CB0](*(void *)v686, 0x1000C8000313F17);
          }
          uint64_t v603 = sub_1CB8445F4((uint64_t)v684, v597, v602, (uint64_t)&v696);
          sub_1CD350D64(v685, (llvm::ValueAsMetadata *)a2, v603);
          if (v703 != &v705) {
            free(v703);
          }
        }
        if (v699[0] != &v700) {
          free(v699[0]);
        }
      }
    }
    else
    {
LABEL_88:
      LOBYTE(v2) = 0;
    }
    uint64_t v35 = (char *)v4[1];
    char v36 = *v35;
    unsigned int v37 = *a2;
  }
  else
  {
    LOBYTE(v2) = 0;
  }
  char v46 = 0;
  char v47 = v36 | v2;
  char *v35 = v47;
  if (!v37 || *((unsigned char *)v37 + 8) != 18 || *((unsigned char *)a2 + 16) != 91) {
    goto LABEL_96;
  }
  uint64_t v48 = (uint64_t)*(a2 - 8);
  uint64_t v49 = *(void *)(v48 + 8);
  if (v49 && !*(void *)(v49 + 8))
  {
    char v46 = 0;
    unsigned int v59 = *(unsigned __int8 *)(v48 + 16);
    if (v59 < 0x1C || v59 - 59 < 0xFFFFFFEE) {
      goto LABEL_96;
    }
    uint64_t v60 = (uint64_t)*(a2 - 4);
    uint64_t v61 = *(void *)(v60 + 8);
    if (v61)
    {
      if (!*(void *)(v61 + 8))
      {
        char v46 = 0;
        unsigned int v62 = *(unsigned __int8 *)(v60 + 16);
        if (v62 < 0x1C || v62 - 59 < 0xFFFFFFEE) {
          goto LABEL_96;
        }
        if (v59 == v62 && *(uint64_t ***)v48 == v37)
        {
          int v681 = v4;
          int64_t v63 = a2[8];
          uint64_t v64 = *((unsigned int *)a2 + 18);
          llvm::createUnaryMask(v63, v64, *((_DWORD *)a2 + 18), (uint64_t)&v703);
          v699[0] = &v700;
          v699[1] = (void *)0xC00000000;
          if (v704) {
            sub_1CD41B598((uint64_t)v699, (uint64_t)&v703);
          }
          if (v703 != &v705) {
            free(v703);
          }
          LODWORD(v2) = *(unsigned __int8 *)(v48 + 16);
          unsigned int __b = v2 - 28;
          uint64_t v65 = (*(uint64_t (**)(void))(***(void ***)(v685 + 144) + 824))(**(void **)(v685 + 144));
          int v67 = v66;
          char v46 = 0;
          BOOL v69 = v65 < (*(uint64_t (**)(void, uint64_t))(***(void ***)(v685 + 144) + 832))(**(void **)(v685 + 144), 7);
          if (v67 != v68) {
            BOOL v69 = v67 < v68;
          }
          if (v69) {
            goto LABEL_711;
          }
          int v70 = *(llvm::PoisonValue ***)(v60 - 64);
          uint64_t v71 = *(llvm::PoisonValue ***)(v60 - 32);
          if ((v2 > 0x3A) | (0xFF99FFFFFFFFFFuLL >> v2) & 1 | (*(void *)(v48 - 64) == (void)v70) | (*(void *)(v48 - 32) == (void)v71)) {
            uint64_t v72 = *(llvm::PoisonValue ***)(v48 - 32);
          }
          else {
            uint64_t v72 = *(llvm::PoisonValue ***)(v48 - 64);
          }
          if ((v2 > 0x3A) | (0xFF99FFFFFFFFFFuLL >> v2) & 1 | (*(void *)(v48 - 64) == (void)v70) | (*(void *)(v48 - 32) == (void)v71)) {
            uint64_t v73 = *(llvm::Type **)(v48 - 64);
          }
          else {
            uint64_t v73 = *(llvm::Type **)(v48 - 32);
          }
          if (v73 == (llvm::Type *)v70)
          {
            int v655 = (llvm::DataLayout *)LODWORD(v699[1]);
            uint64_t v663 = v699[0];
            LOBYTE(v2) = 1;
            WORD4(v706) = 257;
            uint64_t v442 = llvm::PoisonValue::get(*v70, v73);
            uint64_t v443 = (uint64_t)v684;
            int v444 = sub_1CB935A74((uint64_t)v684, (uint64_t)v70, (uint64_t)v442, v663, v655, (uint64_t)&v703);
            WORD4(v706) = 257;
            uint64_t v445 = (uint64_t)v684;
            uint64_t v446 = (uint64_t)v72;
            uint64_t v447 = v71;
          }
          else
          {
            if (v72 != v71)
            {
              char v46 = 0;
LABEL_711:
              if (v699[0] != &v700) {
                free(v699[0]);
              }
              uint64_t v4 = v681;
              uint64_t v35 = (char *)v681[1];
              char v47 = *v35;
              goto LABEL_96;
            }
            LOBYTE(v2) = 1;
            WORD4(v706) = 257;
            uint64_t v443 = (uint64_t)v684;
            int v444 = sub_1CB935A74((uint64_t)v684, (uint64_t)v73, (uint64_t)v70, v63, (llvm::Type *)v64, (uint64_t)&v703);
            int64_t v63 = (uint64_t **)v699[0];
            uint64_t v64 = LODWORD(v699[1]);
            WORD4(v706) = 257;
            uint64_t v447 = llvm::PoisonValue::get(*v71, v461);
            uint64_t v445 = (uint64_t)v684;
            uint64_t v446 = (uint64_t)v71;
          }
          int v462 = sub_1CB935A74(v445, v446, (uint64_t)v447, v63, (llvm::Type *)v64, (uint64_t)&v703);
          WORD4(v706) = 257;
          int v463 = sub_1CB844E98(v443, __b, (uint64_t)v444, (uint64_t)v462, (uint64_t)&v703, 0);
          uint64_t v464 = v463;
          if (v463 && *((unsigned __int8 *)v463 + 16) >= 0x1Cu)
          {
            llvm::Instruction::copyIRFlags((uint64_t)v463, v48, 1);
            llvm::Instruction::andIRFlags((uint64_t)v464, v60);
          }
          sub_1CD350D64(v685, (llvm::ValueAsMetadata *)a2, v464);
          char v46 = 1;
          goto LABEL_711;
        }
      }
    }
  }
  char v46 = 0;
LABEL_96:
  char *v35 = v47 | v46;
LABEL_97:
  int v50 = *((unsigned __int8 *)a2 + 16);
  if ((v50 - 41) > 0x11)
  {
    if ((v50 - 83) >= 0xFFFFFFFE)
    {
      uint64_t v51 = (uint64_t)*(a2 - 8);
      if (v51)
      {
        uint64_t v52 = (uint64_t)*(a2 - 4);
        if (!v52) {
          goto LABEL_438;
        }
        int v53 = *((_WORD *)a2 + 9) & 0x3F;
        if (v53 == 42) {
          goto LABEL_101;
        }
        uint64_t v54 = a2[1];
        if (!v54)
        {
LABEL_118:
          LOBYTE(v2) = 0;
LABEL_102:
          *(void *)uint64_t v686 = 0;
          int v688 = 0;
          long long v695 = 0uLL;
          uint64_t v693 = 0;
          v694 = 0;
          v703 = v686;
          uint64_t v704 = (uint64_t)&v695 + 8;
          uint64_t v705 = (uint64_t)&v694;
          if ((sub_1CD351510((void **)&v703, v51) & 1) == 0)
          {
            if (*(unsigned __int8 *)(v51 + 16) > 0x14u) {
              goto LABEL_121;
            }
            *(void *)uint64_t v686 = v51;
          }
          v703 = &v688;
          uint64_t v704 = (uint64_t)&v695;
          uint64_t v705 = (uint64_t)&v693;
          if (sub_1CD351510((void **)&v703, v52))
          {
            int v680 = v4;
            goto LABEL_123;
          }
          if (*(unsigned __int8 *)(v52 + 16) <= 0x14u)
          {
            int v680 = v4;
            int v688 = (llvm::Constant *)v52;
LABEL_123:
            uint64_t v58 = *((void *)&v695 + 1);
            if (v695 == 0)
            {
LABEL_124:
              LOBYTE(v52) = 0;
LABEL_436:
              uint64_t v4 = v680;
              goto LABEL_437;
            }
            int v673 = (llvm::CastInst *)v695;
            if (*((void *)&v695 + 1) && (void)v695)
            {
              if (v694 != (void *)v693) {
                goto LABEL_124;
              }
              goto LABEL_322;
            }
            if (*((void *)&v695 + 1))
            {
              if ((void)v695) {
                goto LABEL_322;
              }
              unsigned int v74 = *(unsigned __int8 *)(*((void *)&v695 + 1) + 16);
              if (v74 <= 0x1B) {
                goto LABEL_322;
              }
              uint64_t v75 = v74 - 33;
              if (v75 > 0x37) {
                goto LABEL_322;
              }
              if (((1 << v75) & 0x8000000000041) != 0)
              {
                uint64_t v127 = *(void *)(*((void *)&v695 + 1) + 64);
                if (!v127 || (*(unsigned char *)(v127 + 20) & 4) == 0 && (*(unsigned char *)(v127 + 17) & 0x10) == 0)
                {
                  LODWORD(v703) = 7;
                  if (sub_1CC5CB59C(*((uint64_t *)&v695 + 1), (__int32 *)&v703, 1uLL))
                  {
                    uint64_t v626 = *(void *)(v58 - 32);
                    if (!v626
                      || *(unsigned char *)(v626 + 16)
                      || *(void *)(v626 + 24) != *(void *)(v58 + 72)
                      || *(_DWORD *)(v626 + 36) != 7)
                    {
                      goto LABEL_124;
                    }
                  }
                  if ((llvm::CallBase::hasFnAttrOnCalledFunction(v58, 66) & 1) == 0
                    && !llvm::CallBase::hasFnAttrOnCalledFunction(v58, 44))
                  {
                    goto LABEL_124;
                  }
                }
                goto LABEL_322;
              }
              if (((1 << v75) & 0x808001C8000010) != 0) {
                goto LABEL_124;
              }
              if (v75 == 28)
              {
                __int16 v76 = *(_WORD *)(*((void *)&v695 + 1) + 18);
                goto LABEL_168;
              }
            }
            else
            {
              if (!(void)v695) {
                goto LABEL_322;
              }
              unsigned int v77 = *(unsigned __int8 *)(v695 + 16);
              if (v77 < 0x1C) {
                goto LABEL_322;
              }
              uint64_t v78 = v77 - 33;
              if (v78 > 0x37) {
                goto LABEL_322;
              }
              if (((1 << v78) & 0x8000000000041) != 0)
              {
                uint64_t v181 = *(void *)(v695 + 64);
                if (!v181 || (*(unsigned char *)(v181 + 20) & 4) == 0 && (*(unsigned char *)(v181 + 17) & 0x10) == 0)
                {
                  LODWORD(v703) = 7;
                  if (sub_1CC5CB59C(v695, (__int32 *)&v703, 1uLL))
                  {
                    uint64_t v627 = *((void *)v673 - 4);
                    if (!v627
                      || *(unsigned char *)(v627 + 16)
                      || *(void *)(v627 + 24) != *((void *)v673 + 9)
                      || *(_DWORD *)(v627 + 36) != 7)
                    {
                      goto LABEL_124;
                    }
                  }
                  if ((llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)v673, 66) & 1) == 0
                    && (llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)v673, 44) & 1) == 0)
                  {
                    goto LABEL_124;
                  }
                }
                goto LABEL_322;
              }
              if (((1 << v78) & 0x808001C8000010) != 0) {
                goto LABEL_124;
              }
              if (v78 == 28)
              {
                __int16 v76 = *(_WORD *)(v695 + 18);
LABEL_168:
                if ((v76 & 0x301) != 0) {
                  goto LABEL_124;
                }
              }
            }
LABEL_322:
            uint64_t v182 = v694;
            if (!v58) {
              uint64_t v182 = (void *)v693;
            }
            __bb = v182;
            uint64_t v183 = (long long *)((char *)&v695 + 8);
            if (!v58) {
              uint64_t v183 = &v695;
            }
            uint64_t v184 = **(_DWORD ***)v183;
            unint64_t v185 = *a2;
            int v186 = *((unsigned __int8 *)a2 + 16);
            uint64_t v187 = (v186 - 28);
            char v660 = v2;
            unsigned int v652 = v53;
            unsigned int v646 = v186 - 28;
            uint64_t v642 = v693;
            if (v2)
            {
              uint64_t v188 = (v186 - 28);
              uint64_t v189 = v685;
              uint64_t v190 = (*(uint64_t (**)(void, uint64_t, _DWORD *, void, void, void, void, void, void, void, void))(***(void ***)(v685 + 144) + 824))(**(void **)(v685 + 144), v188, v184, 0, 0, 0, 0, 0, 0, 0, 0);
              int v192 = v191;
              uint64_t v193 = (*(uint64_t (**)(void, uint64_t, uint64_t **))(***(void ***)(v685 + 144) + 824))(**(void **)(v685 + 144), v188, v185);
              int v194 = v185;
              int v196 = v195;
            }
            else
            {
              uint64_t v197 = *((_WORD *)a2 + 9) & 0x3F;
              int v198 = *(void **)(v685 + 144);
              uint64_t v199 = (uint64_t **)(**(void **)v184 + 1888);
              if (v184 && (v184[2] & 0xFE) == 0x12)
              {
                uint64_t v438 = (llvm::Type *)v184[8];
                if (v184[2] == 19) {
                  llvm::ScalableVectorType::get(v199, v438);
                }
                else {
                  llvm::FixedVectorType::get((llvm::FixedVectorType *)v199, v438);
                }
                uint64_t v199 = v439;
              }
              unsigned int v639 = v197;
              uint64_t v200 = (*(uint64_t (**)(void, uint64_t, _DWORD *, uint64_t **, uint64_t, void, void))(*(void *)*v198 + 864))(*v198, v187, v184, v199, v197, 0, 0);
              int v192 = v201;
              unsigned int v202 = *(void **)(v685 + 144);
              unsigned int v203 = (uint64_t **)(**v185 + 1888);
              uint64_t v204 = v200;
              if (v185 && (v185[1] & 0xFE) == 0x12)
              {
                uint64_t v440 = (llvm::Type *)*((unsigned int *)v185 + 8);
                if (*((_DWORD *)v185 + 2) == 19) {
                  llvm::ScalableVectorType::get(v203, v440);
                }
                else {
                  llvm::FixedVectorType::get((llvm::FixedVectorType *)v203, v440);
                }
                unsigned int v203 = v441;
              }
              uint64_t v193 = (*(uint64_t (**)(void, uint64_t, uint64_t **, uint64_t **, void, void, void))(*(void *)*v202 + 864))(*v202, v187, v185, v203, v639, 0, 0);
              int v194 = v185;
              int v196 = v205;
              uint64_t v189 = v685;
              uint64_t v190 = v204;
            }
            uint64_t v206 = (*(uint64_t (**)(void, uint64_t, uint64_t **, void *))(***(void ***)(v189 + 144) + 872))(**(void **)(v189 + 144), 62, v194, __bb);
            if (v58) {
              uint64_t v209 = v206;
            }
            else {
              uint64_t v209 = 0;
            }
            if (v58) {
              int v210 = v207;
            }
            else {
              int v210 = 0;
            }
            if (v207 == 1) {
              int v192 = 1;
            }
            int v211 = v673;
            BOOL v212 = v207 != 1 || v673 == 0;
            *(void *)&long long v696 = v206;
            *((void *)&v696 + 1) = v207;
            if (v212) {
              int v213 = v210;
            }
            else {
              int v213 = 1;
            }
            if (v673) {
              uint64_t v214 = v206;
            }
            else {
              uint64_t v214 = 0;
            }
            BOOL v141 = __OFADD__(v209, v214);
            int64_t v215 = v209 + v214;
            if (v141) {
              int64_t v215 = (v215 >> 63) ^ 0x8000000000000000;
            }
            BOOL v141 = __OFADD__(v215, v193);
            uint64_t v216 = v215 + v193;
            if (v141) {
              int64_t v217 = (v216 >> 63) ^ 0x8000000000000000;
            }
            else {
              int64_t v217 = v216;
            }
            if (__OFADD__(v190, v206)) {
              unint64_t v218 = ((v190 + v206) >> 63) ^ 0x8000000000000000;
            }
            else {
              unint64_t v218 = v190 + v206;
            }
            if (v58)
            {
              uint64_t v219 = *(void *)(v51 + 8);
              if (v219) {
                BOOL v220 = *(void *)(v219 + 8) != 0;
              }
              else {
                BOOL v220 = 1;
              }
              v703 = (void *)v220;
              LODWORD(v704) = 0;
              sub_1CB90C9D4((uint64_t)&v703, (uint64_t)&v696);
              int v221 = v703;
              if (v704 == 1) {
                int v192 = 1;
              }
              int v211 = v673;
            }
            else
            {
              int v221 = 0;
            }
            BOOL v141 = __OFADD__(v218, v221);
            uint64_t v222 = (uint64_t)v221 + v218;
            if (v141) {
              unint64_t v2 = (v222 >> 63) ^ 0x8000000000000000;
            }
            else {
              unint64_t v2 = v222;
            }
            if (v211)
            {
              uint64_t v223 = *(void *)(v52 + 8);
              if (v223) {
                BOOL v224 = *(void *)(v223 + 8) != 0;
              }
              else {
                BOOL v224 = 1;
              }
              v703 = (void *)v224;
              LODWORD(v704) = 0;
              sub_1CB90C9D4((uint64_t)&v703, (uint64_t)&v696);
              long long v225 = v703;
              if (v704 == 1) {
                int v192 = 1;
              }
              int v211 = v673;
            }
            else
            {
              long long v225 = 0;
            }
            BOOL v141 = __OFADD__(v2, v225);
            int64_t v226 = (int64_t)v225 + v2;
            if (v141) {
              int64_t v226 = (v226 >> 63) ^ 0x8000000000000000;
            }
            if (v196 == 1) {
              int v227 = 1;
            }
            else {
              int v227 = v213;
            }
            BOOL v228 = v217 >= v226;
            BOOL v30 = v227 == v192;
            BOOL v229 = v227 >= v192;
            if (!v30) {
              BOOL v228 = v229;
            }
            if (v192) {
              LODWORD(v52) = 0;
            }
            else {
              LODWORD(v52) = v228;
            }
            if (v52 != 1) {
              goto LABEL_436;
            }
            unint64_t v230 = (unint64_t)__bb;
            if (!v58)
            {
              uint64_t v231 = *(llvm **)v686;
              uint64_t v232 = **(void **)(v685 + 72);
              int v233 = *(llvm::ConstantInt **)(v232 + 1984);
              unint64_t v234 = *(unsigned int *)(v232 + 1992);
              LODWORD(v704) = v234 >> 8;
              if (v234 >> 8 > 0x40) {
                operator new[]();
              }
              if (v234 <= 0xFF) {
                unint64_t v235 = 0;
              }
              else {
                unint64_t v235 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v234) + 63);
              }
              v703 = (void *)(v235 & v642);
              uint64_t v237 = (llvm::Constant *)llvm::ConstantInt::get(v233, (llvm::LLVMContext *)&v703, v208);
              if (v704 >= 0x41 && v703) {
                MEMORY[0x1D25D9CB0](v703, 0x1000C8000313F17);
              }
              uint64_t ElementInstruction = (uint64_t)llvm::ConstantFoldExtractElementInstruction(v231, v237, v236);
              if (!ElementInstruction)
              {
                uint64_t v620 = *(void ***)v231;
                uint64_t v621 = *(void *)(*(void *)v231 + 24);
                if (v621)
                {
                  v699[0] = v231;
                  v699[1] = v237;
                  uint64_t v622 = **v620 + 1512;
                  LODWORD(v703) = 61;
                  uint64_t v704 = (uint64_t)v699;
                  uint64_t v705 = 2;
                  long long v706 = 0u;
                  long long v707 = 0u;
                  v708 = 0;
                  uint64_t ElementInstruction = sub_1CC56C20C(v622, v621, (unsigned __int8 *)&v703);
                }
                else
                {
                  uint64_t ElementInstruction = 0;
                }
                unint64_t v230 = (unint64_t)__bb;
              }
              *((void *)&v695 + 1) = ElementInstruction;
              int v211 = v673;
            }
            uint64_t v239 = v652;
            if (v211)
            {
              uint64_t v240 = v695;
            }
            else
            {
              int v241 = v688;
              uint64_t v242 = **(void **)(v685 + 72);
              uint64_t v243 = *(llvm::ConstantInt **)(v242 + 1984);
              unint64_t v244 = *(unsigned int *)(v242 + 1992);
              LODWORD(v704) = v244 >> 8;
              if (v244 >> 8 > 0x40) {
                operator new[]();
              }
              if (v244 <= 0xFF) {
                unint64_t v245 = 0;
              }
              else {
                unint64_t v245 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v244) + 63);
              }
              v703 = (void *)(v245 & v230);
              uint64_t v247 = (llvm::Constant *)llvm::ConstantInt::get(v243, (llvm::LLVMContext *)&v703, v208);
              if (v704 >= 0x41 && v703) {
                MEMORY[0x1D25D9CB0](v703, 0x1000C8000313F17);
              }
              uint64_t v240 = (uint64_t)llvm::ConstantFoldExtractElementInstruction(v241, v247, v246);
              if (!v240)
              {
                uint64_t v623 = *(void ***)v241;
                uint64_t v624 = *(void *)(*(void *)v241 + 24);
                if (v624)
                {
                  v699[0] = v241;
                  v699[1] = v247;
                  uint64_t v625 = **v623 + 1512;
                  LODWORD(v703) = 61;
                  uint64_t v704 = (uint64_t)v699;
                  uint64_t v705 = 2;
                  long long v706 = 0u;
                  long long v707 = 0u;
                  v708 = 0;
                  uint64_t v240 = sub_1CC56C20C(v625, v624, (unsigned __int8 *)&v703);
                }
                else
                {
                  uint64_t v240 = 0;
                }
                unint64_t v230 = (unint64_t)__bb;
              }
              *(void *)&long long v695 = v240;
              uint64_t v239 = v652;
            }
            if (v660)
            {
              WORD4(v706) = 257;
              int v248 = sub_1CB844E98((uint64_t)v684, v646, *((uint64_t *)&v695 + 1), v240, (uint64_t)&v703, 0);
            }
            else
            {
              WORD4(v706) = 257;
              if (v239 > 0xF) {
                int v248 = sub_1CB845F20((uint64_t)v684, v239, *((void **)&v695 + 1), v240, (uint64_t)&v703);
              }
              else {
                int v248 = llvm::IRBuilderBase::CreateFCmpHelper((uint64_t)v684, v239, *((uint64_t *)&v695 + 1), v240, (uint64_t)&v703, 0, 0);
              }
            }
            uint64_t v249 = (unsigned __int8 *)v248;
            if ((*((unsigned char *)a2 + 23) & 0x10) == 0)
            {
              uint64_t v260 = 0;
              uint64_t v259 = &byte_1CFBCE98E;
              goto LABEL_417;
            }
            uint64_t v250 = ***a2;
            uint64_t v251 = *(void *)(v250 + 152);
            uint64_t v252 = *(unsigned int *)(v250 + 168);
            if (v252)
            {
              LODWORD(v253) = (v252 - 1) & ((a2 >> 4) ^ (a2 >> 9));
              uint64_t v254 = (uint64_t ****)(v251 + 16 * v253);
              unsigned int v255 = *v254;
              if (*v254 == a2)
              {
LABEL_416:
                unint64_t v258 = v254[1];
                uint64_t v261 = (uint64_t)*v258;
                uint64_t v259 = (char *)(v258 + 2);
                uint64_t v260 = v261;
LABEL_417:
                WORD4(v706) = 773;
                v703 = v259;
                uint64_t v704 = v260;
                uint64_t v705 = (uint64_t)".scalar";
                llvm::Value::setNameImpl(v248, (const char **)&v703);
                if (!v249 || v249[16])
                {
                  if (!v249)
                  {
LABEL_422:
                    int v264 = *(void ****)v686;
                    uint64_t v265 = v688;
                    if (v660)
                    {
                      uint64_t v267 = (unsigned __int8 *)llvm::ConstantFoldBinaryInstruction((llvm *)v646, *(llvm::Constant **)v686, v688, v262);
                      if (!v267)
                      {
                        uint64_t v268 = *v264;
                        if (*v264)
                        {
                          v699[0] = v264;
                          v699[1] = v265;
                          uint64_t v269 = **v268 + 1512;
                          LODWORD(v703) = v646;
                          uint64_t v704 = (uint64_t)v699;
                          uint64_t v705 = 2;
                          long long v706 = 0u;
                          long long v707 = 0u;
                          v708 = 0;
                          uint64_t v267 = (unsigned __int8 *)sub_1CC56C20C(v269, (uint64_t)v268, (unsigned __int8 *)&v703);
                        }
                        else
                        {
                          uint64_t v267 = 0;
                        }
                        unint64_t v230 = (unint64_t)__bb;
                      }
                    }
                    else
                    {
                      if (v239 <= 0xF) {
                        uint64_t FCmp = llvm::ConstantExpr::getFCmp((llvm::ConstantExpr *)v239, *(uint64_t ****)v686, v688, 0);
                      }
                      else {
                        uint64_t FCmp = (uint64_t)llvm::ConstantExpr::getICmp((llvm::ConstantExpr *)v239, *(llvm::Type **)v686, v688, 0, v263);
                      }
                      uint64_t v267 = (unsigned __int8 *)FCmp;
                    }
                    WORD4(v706) = 257;
                    uint64_t v271 = **(void **)(v685 + 72);
                    uint64_t v272 = *(llvm::ConstantInt **)(v271 + 1984);
                    unint64_t v273 = *(unsigned int *)(v271 + 1992);
                    LODWORD(v699[1]) = v273 >> 8;
                    unint64_t v2 = (v273 >> 8) + 63;
                    if (v273 >> 8 > 0x40) {
                      operator new[]();
                    }
                    if (v273 <= 0xFF) {
                      unint64_t v274 = 0;
                    }
                    else {
                      unint64_t v274 = 0xFFFFFFFFFFFFFFFFLL >> ~(_BYTE)v2;
                    }
                    v699[0] = (void *)(v274 & v230);
                    int v275 = (unsigned __int8 *)llvm::ConstantInt::get(v272, (llvm::LLVMContext *)v699, v266);
                    if (LODWORD(v699[1]) >= 0x41 && v699[0]) {
                      MEMORY[0x1D25D9CB0](v699[0], 0x1000C8000313F17);
                    }
                    uint64_t v276 = sub_1CB84478C((uint64_t)v684, v267, v249, v275, (uint64_t)&v703);
                    sub_1CD350D64(v685, (llvm::ValueAsMetadata *)a2, v276);
                    goto LABEL_436;
                  }
LABEL_420:
                  if (v249[16] >= 0x1Cu) {
                    llvm::Instruction::copyIRFlags((uint64_t)v249, (uint64_t)a2, 1);
                  }
                  goto LABEL_422;
                }
                if ((v249[23] & 0x10) == 0) {
                  goto LABEL_722;
                }
                uint64_t v404 = ***(void ***)v249;
                uint64_t v405 = *(void *)(v404 + 152);
                uint64_t v406 = *(unsigned int *)(v404 + 168);
                if (v406)
                {
                  LODWORD(v407) = (v406 - 1) & ((v249 >> 4) ^ (v249 >> 9));
                  uint64_t v408 = (unsigned __int8 **)(v405 + 16 * v407);
                  uint64_t v409 = *v408;
                  if (*v408 == v249)
                  {
LABEL_715:
                    uint64_t v465 = v408[1];
                    unint64_t v468 = *(void *)v465;
                    int v466 = v465 + 16;
                    unint64_t v467 = v468;
                    if (v468 >= 5 && *(_DWORD *)v466 == *(_DWORD *)"llvm." && v466[4] == aLlvm_1[4])
                    {
                      *((_DWORD *)v249 + 8) |= 0x2000u;
                      int v470 = llvm::Function::lookupIntrinsicID(v466, v467);
LABEL_723:
                      *((_DWORD *)v249 + 9) = v470;
                      goto LABEL_420;
                    }
LABEL_722:
                    int v470 = 0;
                    *((_DWORD *)v249 + 8) &= ~0x2000u;
                    goto LABEL_723;
                  }
                  int v410 = 1;
                  while (v409 != (unsigned __int8 *)-4096)
                  {
                    int v411 = v407 + v410++;
                    uint64_t v407 = v411 & (v406 - 1);
                    uint64_t v409 = *(unsigned __int8 **)(v405 + 16 * v407);
                    if (v409 == v249)
                    {
                      uint64_t v408 = (unsigned __int8 **)(v405 + 16 * v407);
                      goto LABEL_715;
                    }
                  }
                }
                uint64_t v408 = (unsigned __int8 **)(v405 + 16 * v406);
                goto LABEL_715;
              }
              int v256 = 1;
              while (v255 != (uint64_t ***)-4096)
              {
                int v257 = v253 + v256++;
                uint64_t v253 = v257 & (v252 - 1);
                unsigned int v255 = *(uint64_t ****)(v251 + 16 * v253);
                if (v255 == a2)
                {
                  uint64_t v254 = (uint64_t ****)(v251 + 16 * v253);
                  goto LABEL_416;
                }
              }
            }
            uint64_t v254 = (uint64_t ****)(v251 + 16 * v252);
            goto LABEL_416;
          }
LABEL_121:
          LOBYTE(v52) = 0;
LABEL_437:
          int v50 = *((unsigned __int8 *)a2 + 16);
          goto LABEL_438;
        }
        while (1)
        {
          uint64_t v55 = v54[3];
          if (*((unsigned char *)v55 + 16) == 85)
          {
            int v56 = *((_DWORD *)v55 + 5);
            uint64_t v57 = (v56 & 0x40000000) != 0 ? (uint64_t ****)*(v55 - 1) : (uint64_t ****)&v55[-4 * (v56 & 0x7FFFFFF)];
            if (*v57 == a2) {
              break;
            }
          }
          uint64_t v54 = (uint64_t **)v54[1];
          if (!v54) {
            goto LABEL_118;
          }
        }
      }
    }
LABEL_119:
    LOBYTE(v52) = 0;
    goto LABEL_438;
  }
  uint64_t v51 = (uint64_t)*(a2 - 8);
  if (!v51) {
    goto LABEL_119;
  }
  uint64_t v52 = (uint64_t)*(a2 - 4);
  if (v52)
  {
    int v53 = 42;
LABEL_101:
    LOBYTE(v2) = 1;
    goto LABEL_102;
  }
LABEL_438:
  int v277 = (char *)v4[1];
  char v278 = *v277 | v52;
  *int v277 = v278;
  if (v50 != 60)
  {
    char v281 = 0;
    goto LABEL_451;
  }
  int v279 = *((_DWORD *)a2 + 5);
  int v683 = v4;
  if ((v279 & 0x40000000) != 0) {
    int v280 = (unint64_t *)*(a2 - 1);
  }
  else {
    int v280 = (unint64_t *)&a2[-4 * (v279 & 0x7FFFFFF)];
  }
  unint64_t v2 = *v280;
  if (!*v280 || (*((_WORD *)a2 + 9) & 1) != 0) {
    goto LABEL_449;
  }
  uint64_t v282 = a2[5][7][5] + 272;
  uint64_t v283 = (uint64_t)*a2;
  uint64_t v284 = sub_1CB83544C(v282, (uint64_t)*a2);
  int v286 = v285;
  __bc = (void *)v282;
  if (v284 != ((sub_1CB83544C(v282, v283) + 7) & 0xFFFFFFFFFFFFFFF8) || v286 != (v287 == 1)) {
    goto LABEL_449;
  }
  char v281 = 0;
  if (!*a2) {
    goto LABEL_450;
  }
  uint64_t v661 = (uint64_t *)v2;
  uint64_t v675 = (llvm::CastInst *)*a2;
  if (*((unsigned char *)*a2 + 8) != 18) {
    goto LABEL_450;
  }
  uint64_t v295 = (uint64_t)**(a2 - 4);
  unsigned int v296 = *(_DWORD *)(v295 + 8);
  if ((v296 & 0xFE) == 0x12) {
    unsigned int v296 = *(_DWORD *)(**(void **)(v295 + 16) + 8);
  }
  v653 = (llvm::DataLayout *)(*(uint64_t (**)(void, uint64_t, uint64_t **, unint64_t, void, void, void))(***(void ***)(v685 + 144) + 888))(**(void **)(v685 + 144), 32, *a2, ((unint64_t)*((unsigned __int16 *)a2 + 9) >> 1) & 0x3F, v296 >> 8, 0, 0);
  uint64_t v298 = v297;
  int v299 = a2[1];
  if (v299)
  {
    int v300 = 0;
    LODWORD(v2) = 0;
    int64_t v301 = 0;
    uint64_t v302 = a2;
    while (1)
    {
      char v281 = 0;
      uint64_t v303 = v299[3];
      if (!v303 || *((unsigned char *)v303 + 16) != 89) {
        goto LABEL_450;
      }
      if ((uint64_t **)v303[5] != a2[5]
        || !sub_1CC16A22C((uint64_t ***)*(v303 - 4), *(void *)(v685 + 168), (uint64_t)a2, *(void *)(v685 + 152), 0, 1))
      {
        goto LABEL_449;
      }
      uint64_t v304 = v302[5];
      int v305 = *((__int16 *)v304 + 9);
      uint64_t v306 = (uint64_t)v675;
      if ((v305 & 0x80000000) == 0)
      {
        uint64_t v337 = (uint64_t **)v304[6];
        if (v337 != v304 + 5)
        {
          int v338 = 0;
          do
          {
            int v339 = v337 - 3;
            if (!v337) {
              int v339 = 0;
            }
            *((_DWORD *)v339 + 14) = v338++;
            uint64_t v337 = (uint64_t **)v337[1];
          }
          while (v337 != v304 + 5);
        }
        *((_WORD *)v304 + 9) = v305 | 0x8000;
      }
      if (*((_DWORD *)v302 + 14) < *((_DWORD *)v303 + 14))
      {
        uint64_t v307 = a2[4];
        if (v307 != (uint64_t **)(v303 + 3))
        {
          while (v300 != dword_1EBD020A0)
          {
            if (v307) {
              uint64_t v308 = (uint64_t)(v307 - 3);
            }
            else {
              uint64_t v308 = 0;
            }
            uint64_t v309 = *(unsigned __int8 *)(v308 + 16) - 33;
            if (v309 <= 0x37)
            {
              if (((1 << (*(unsigned char *)(v308 + 16) - 33)) & 0x8000000000041) != 0)
              {
                uint64_t v310 = *(void *)(v308 + 64);
                if (!v310 || (*(unsigned char *)(v310 + 17) & 0x30) == 0)
                {
                  int v311 = *(_DWORD *)(v308 + 20);
                  if (v311 < 0)
                  {
                    uint64_t v312 = v308 - 32 * (v311 & 0x7FFFFFF);
                    uint64_t v315 = *(void *)(v312 - 8);
                    uint64_t v313 = v312 - 8;
                    uint64_t v314 = v315;
                    if (v315)
                    {
                      uint64_t v316 = -v314;
                      do
                      {
                        unsigned int v317 = *(_DWORD *)(*(void *)(v313 + v316) + 8);
                        BOOL v318 = v317 > 7;
                        int v319 = (1 << v317) & 0x83;
                        if (v318 || v319 == 0) {
                          goto LABEL_449;
                        }
                        v316 += 16;
                      }
                      while (v316);
                    }
                  }
                  if ((llvm::CallBase::hasFnAttrOnCalledFunction(v308, 45) & 1) == 0
                    && !llvm::CallBase::hasFnAttrOnCalledFunction(v308, 44))
                  {
                    goto LABEL_449;
                  }
                }
              }
              else if (v309 == 27)
              {
                if ((*(_WORD *)(v308 + 18) & 0x301) != 0) {
                  goto LABEL_449;
                }
              }
              else if (((1 << (*(unsigned char *)(v308 + 16) - 33)) & 0x808001D0000010) != 0)
              {
                goto LABEL_449;
              }
            }
            ++v300;
            uint64_t v307 = (uint64_t **)v307[1];
            if (v307 == (uint64_t **)(v303 + 3)) {
              goto LABEL_499;
            }
          }
          goto LABEL_449;
        }
LABEL_499:
        uint64_t v302 = (uint64_t ***)v303;
        uint64_t v306 = (uint64_t)v675;
      }
      sub_1CD351628((uint64_t)&v703, v306, *(v303 - 4), (llvm::AssumptionCache *)a2, *(void *)(v685 + 168), *(const llvm::Instruction **)(v685 + 152));
      if (v703 != 1) {
        goto LABEL_449;
      }
      uint64_t v321 = *(v303 - 4);
      uint64_t v322 = -1;
      if (v321 && *(unsigned char *)(v321 + 16) == 16)
      {
        uint64_t v323 = (uint64_t *)(v321 + 24);
        if (*(_DWORD *)(v321 + 32) >= 0x41u) {
          uint64_t v323 = (uint64_t *)*v323;
        }
        uint64_t v322 = *v323;
      }
      uint64_t v324 = (*(uint64_t (**)(void, uint64_t, uint64_t **, uint64_t))(***(void ***)(v685 + 144) + 872))(**(void **)(v685 + 144), 61, *a2, v322);
      if (v325 == 1) {
        uint64_t v326 = 1;
      }
      else {
        uint64_t v326 = v298;
      }
      unint64_t v327 = (unint64_t)v653 + v324;
      if (__OFADD__(v653, v324)) {
        unint64_t v327 = (((uint64_t)v653 + v324) >> 63) ^ 0x8000000000000000;
      }
      v653 = (llvm::DataLayout *)v327;
      uint64_t v328 = (uint64_t)**(a2 - 4);
      unsigned int v329 = *(_DWORD *)(v328 + 8);
      if ((v329 & 0xFE) == 0x12) {
        unsigned int v329 = *(_DWORD *)(**(void **)(v328 + 16) + 8);
      }
      uint64_t v330 = (*(uint64_t (**)(void, uint64_t, void, void, void, void, void))(***(void ***)(v685 + 144)
                                                                                                + 888))(**(void **)(v685 + 144), 32, *(void *)(v306 + 24), 0, v329 >> 8, 0, 0);
      int v332 = v331;
      if (__OFADD__(v301, v330)) {
        unint64_t v333 = ((v301 + v330) >> 63) ^ 0x8000000000000000;
      }
      else {
        unint64_t v333 = v301 + v330;
      }
      uint64_t v334 = (*(uint64_t (**)(void))(***(void ***)(v685 + 144) + 976))();
      if (v332 == 1 || v335 == 1) {
        LODWORD(v2) = 1;
      }
      if (__OFADD__(v333, v334)) {
        int64_t v301 = ((uint64_t)(v333 + v334) >> 63) ^ 0x8000000000000000;
      }
      else {
        int64_t v301 = v333 + v334;
      }
      int v299 = (uint64_t **)v299[1];
      uint64_t v298 = v326;
      if (!v299) {
        goto LABEL_557;
      }
    }
  }
  int64_t v301 = 0;
  LODWORD(v2) = 0;
LABEL_557:
  BOOL v356 = v301 >= (uint64_t)v653;
  if (v2 != v298) {
    BOOL v356 = (int)v2 >= (int)v298;
  }
  if (v356)
  {
LABEL_449:
    char v281 = 0;
  }
  else
  {
    double v357 = a2[1];
    if (v357)
    {
      while (1)
      {
        uint64_t v358 = (llvm::ValueAsMetadata *)v357[3];
        *(void *)(v685 + 56) = *((void *)v358 + 5);
        *(void *)(v685 + 64) = (char *)v358 + 24;
        int v359 = (void *)*((void *)v358 + 6);
        v699[0] = v359;
        if (v359)
        {
          llvm::MetadataTracking::track((uint64_t)v699, (unsigned __int8 *)v359, 2);
          int v360 = v699[0];
        }
        else
        {
          int v360 = 0;
        }
        sub_1CB8461A4((uint64_t)v684, 0, (uint64_t)v360);
        if (v699[0])
        {
          int v385 = *(unsigned __int8 *)v699[0];
          if ((v385 - 4) > 0x1E)
          {
            if ((v385 - 3) >= 0xFFFFFFFE) {
              int v388 = v699[0];
            }
            else {
              int v388 = 0;
            }
            if ((v385 - 3) >= 0xFFFFFFFE)
            {
              unint64_t v387 = (unint64_t)v388 + 8;
LABEL_594:
              v703 = v699;
              sub_1CC5FA668(v387 + 16, &v703);
              goto LABEL_564;
            }
            if (v385 == 3) {
              *((void *)v699[0] + 1) = 0;
            }
          }
          else if ((*((unsigned char *)v699[0] + 1) & 0x7F) == 2 || *((_DWORD *)v699[0] + 3))
          {
            uint64_t v386 = *((void *)v699[0] + 2);
            if ((v386 & 4) != 0)
            {
              unint64_t v387 = v386 & 0xFFFFFFFFFFFFFFF8;
              if (v387) {
                goto LABEL_594;
              }
            }
          }
        }
LABEL_564:
        uint64_t v362 = (void *)*((void *)v358 - 4);
        uint64_t v363 = **(void **)(v685 + 72);
        uint64_t v364 = *(llvm::ConstantInt **)(v363 + 1960);
        unsigned int v365 = *(_DWORD *)(v363 + 1968);
        LODWORD(v704) = v365 >> 8;
        if (v365 >> 8 >= 0x41) {
          operator new[]();
        }
        v703 = 0;
        uint64_t v366 = llvm::ConstantInt::get(v364, (llvm::LLVMContext *)&v703, v361);
        if (v704 >= 0x41 && v703) {
          MEMORY[0x1D25D9CB0](v703, 0x1000C8000313F17);
        }
        v699[0] = v366;
        v699[1] = v362;
        WORD4(v706) = 257;
        uint64_t v367 = sub_1CC57EEA0(v684, (uint64_t)v675, v661, (uint64_t *)v699, 2, (uint64_t)&v703);
        int v368 = (llvm::Type *)*((void *)v675 + 3);
        if ((*((unsigned char *)v358 + 23) & 0x10) == 0)
        {
          int64_t v378 = 0;
          uint64_t v379 = &byte_1CFBCE98E;
          goto LABEL_575;
        }
        uint64_t v369 = ***(void ***)v358;
        uint64_t v370 = *(void *)(v369 + 152);
        uint64_t v371 = *(unsigned int *)(v369 + 168);
        if (!v371) {
          goto LABEL_573;
        }
        LODWORD(v372) = (v371 - 1) & ((v358 >> 4) ^ (v358 >> 9));
        int v373 = (llvm::ValueAsMetadata **)(v370 + 16 * v372);
        uint64_t v374 = *v373;
        if (*v373 != v358)
        {
          int v375 = 1;
          while (v374 != (llvm::ValueAsMetadata *)-4096)
          {
            int v376 = v372 + v375++;
            uint64_t v372 = v376 & (v371 - 1);
            uint64_t v374 = *(llvm::ValueAsMetadata **)(v370 + 16 * v372);
            if (v374 == v358)
            {
              int v373 = (llvm::ValueAsMetadata **)(v370 + 16 * v372);
              goto LABEL_574;
            }
          }
LABEL_573:
          int v373 = (llvm::ValueAsMetadata **)(v370 + 16 * v371);
        }
LABEL_574:
        int64_t v377 = v373[1];
        uint64_t v380 = *(void **)v377;
        uint64_t v379 = (char *)v377 + 16;
        int64_t v378 = v380;
LABEL_575:
        LOWORD(v701) = 773;
        v699[0] = v379;
        v699[1] = v378;
        *(void *)&long long v700 = ".scalar";
        LOBYTE(v2) = llvm::DataLayout::getAlignment((llvm::DataLayout *)(*(void *)(*(void *)(*(void *)(v685 + 56) + 56) + 40) + 272), v368, 1);
        uint64_t v381 = operator new(0x60uLL);
        v381[13] = v381[13] & 0x38000000 | 1;
        uint64_t v382 = (llvm::Instruction *)(v381 + 8);
        *(void *)uint64_t v381 = 0;
        *((void *)v381 + 1) = 0;
        *((void *)v381 + 2) = 0;
        *((void *)v381 + 3) = v381 + 8;
        WORD4(v706) = 257;
        llvm::LoadInst::LoadInst((llvm::Value *)(v381 + 8), (uint64_t)v368, v367, (const char **)&v703, 0, v2, 0);
        (*(void (**)(void, _DWORD *, void **, void, void))(**(void **)(v685 + 88) + 16))(*(void *)(v685 + 88), v381 + 8, v699, *(void *)(v685 + 56), *(void *)(v685 + 64));
        uint64_t v383 = *(unsigned int *)(v685 + 16);
        if (v383)
        {
          unint64_t v2 = *(void *)(v685 + 8);
          unint64_t v384 = v2 + 16 * v383;
          do
          {
            llvm::Instruction::setMetadata(v382, *(_DWORD *)v2, *(llvm::MDNode **)(v2 + 8));
            v2 += 16;
          }
          while (v2 != v384);
        }
        *((_WORD *)v381 + 25) = *((_WORD *)v381 + 25) & 0xFF81 | (2
                                                                * sub_1CD351E7C(((unint64_t)*((unsigned __int16 *)a2 + 9) >> 1) & 0x3F, *((void *)v675 + 3), (uint64_t)v362, (uint64_t)__bc));
        sub_1CD350D64(v685, v358, v382);
        double v357 = (uint64_t **)v357[1];
        char v281 = 1;
        if (!v357) {
          goto LABEL_450;
        }
      }
    }
    char v281 = 1;
  }
LABEL_450:
  int v50 = *((unsigned __int8 *)a2 + 16);
  uint64_t v4 = v683;
  int v277 = (char *)v683[1];
  char v278 = *v277;
LABEL_451:
  char v289 = v278 | v281;
  *int v277 = v289;
  if (v50 == 61) {
    uint64_t v290 = (uint64_t)a2;
  }
  else {
    uint64_t v290 = 0;
  }
  if (v50 != 61) {
    goto LABEL_554;
  }
  if ((*((_WORD *)a2 + 9) & 0x381) != 0) {
    goto LABEL_554;
  }
  uint64_t v291 = (uint64_t)*(a2 - 8);
  uint64_t v292 = *(void *)v291;
  if (*(unsigned char *)(*(void *)v291 + 8) != 18 || *(unsigned char *)(v291 + 16) != 90) {
    goto LABEL_554;
  }
  int v293 = *(_DWORD *)(v291 + 20);
  int v294 = (v293 & 0x40000000) != 0 ? *(void **)(v291 - 8) : (void *)(v291 - 32 * (v293 & 0x7FFFFFF));
  uint64_t v340 = *v294;
  unsigned int v341 = *(unsigned __int8 *)(*v294 + 16);
  BOOL v342 = *v294 && v341 >= 0x1C;
  if (!v342 || (uint64_t v343 = (uint64_t *)v294[4]) == 0 || (v344 = v4, (v345 = (llvm::ConstantInt **)v294[8]) == 0))
  {
LABEL_554:
    char v355 = 0;
    goto LABEL_555;
  }
  if (v341 == 60)
  {
    uint64_t v346 = a2[5][7][5];
    int v347 = llvm::Value::stripPointerCasts(*(llvm::Value **)(v340 - 32));
    int v348 = *(unsigned __int8 *)(v340 + 16);
    if (v348 == 60 || v348 == 61)
    {
      __int16 v349 = *(_WORD *)(v340 + 18);
      if (v349 & 0x380) != 0 || (v349)
      {
LABEL_552:
        LOBYTE(v2) = 0;
        goto LABEL_553;
      }
    }
    else if (v348 - 63) < 3 || (*(_WORD *)(v340 + 18))
    {
      goto LABEL_552;
    }
    if (*(uint64_t ***)(v340 + 40) == a2[5])
    {
      uint64_t v350 = v346 + 272;
      uint64_t v662 = *(void *)v340;
      uint64_t v351 = sub_1CB83544C(v350, *(void *)v340);
      int __bd = v352;
      uint64_t v654 = (llvm::DataLayout *)v350;
      if (v351 == ((sub_1CB83544C(v350, v662) + 7) & 0xFFFFFFFFFFFFFFF8)
        && __bd == (v353 == 1)
        && v347 == llvm::Value::stripPointerCasts((llvm::Value *)*(a2 - 4)))
      {
        sub_1CD351628((uint64_t)v686, v292, (uint64_t)v345, (llvm::AssumptionCache *)v340, *(void *)(v685 + 168), *(const llvm::Instruction **)(v685 + 152));
        unsigned int v448 = v686[0];
        if (v686[0])
        {
          uint64_t v449 = (uint64_t)*(a2 - 4);
          uint64_t v450 = sub_1CB83544C(a2[5][7][5] + 272, (uint64_t)**(a2 - 8));
          if (v451 == 1) {
            unint64_t v452 = -2;
          }
          else {
            unint64_t v452 = (unint64_t)(v450 + 7) >> 3;
          }
          llvm::Instruction::getAAMetadata(a2, &v697);
          *(void *)&long long v696 = v449;
          *((void *)&v696 + 1) = v452;
          if ((uint64_t ***)v340 != a2)
          {
            int v453 = 0;
            uint64_t v454 = v340 + 24;
            uint64_t v647 = *(llvm::Type **)(v685 + 160);
            long long v455 = xmmword_1CFAC3060;
            do
            {
              *(_OWORD *)v699 = v696;
              long long v700 = v697;
              long long v701 = v698;
              char v702 = 1;
              v703 = (void *)1;
              uint64_t v456 = 8;
              do
              {
                uint64_t v457 = (char *)&v703 + v456;
                *(_OWORD *)uint64_t v457 = v455;
                *((_OWORD *)v457 + 1) = v455;
                v456 += 40;
              }
              while (v457 + 40 != (char *)v720);
              int v676 = v453;
              v720[0] = &v724;
              v720[1] = 0;
              v721 = v723;
              uint64_t v722 = 0x400000000;
              v724 = &unk_1F2600DB8;
              uint64_t v458 = 504;
              uint64_t v725 = 1;
              do
              {
                *(void **)((char *)&v703 + v458) = (void *)-4096;
                v458 += 16;
              }
              while (v458 != 632);
              if (v454) {
                uint64_t v459 = (llvm::Instruction *)(v454 - 24);
              }
              else {
                uint64_t v459 = 0;
              }
              char ModRefInfo = llvm::AAResults::getModRefInfo((uint64_t)v647, v459, (long long *)v699, (uint64_t)&v703);
              if ((v725 & 1) == 0)
              {
                char v637 = ModRefInfo;
                MEMORY[0x1D25D9CD0](v726, 8);
                char ModRefInfo = v637;
              }
              long long v455 = xmmword_1CFAC3060;
              if (v721 != v723)
              {
                char v638 = ModRefInfo;
                free(v721);
                char ModRefInfo = v638;
                long long v455 = xmmword_1CFAC3060;
              }
              if ((v703 & 1) == 0)
              {
                char v636 = ModRefInfo;
                MEMORY[0x1D25D9CD0](v704, 8);
                char ModRefInfo = v636;
                long long v455 = xmmword_1CFAC3060;
              }
              if ((ModRefInfo & 2) != 0) {
                goto LABEL_552;
              }
              int v453 = v676 + 1;
              if (v676 + 1 > dword_1EBD020A0) {
                goto LABEL_552;
              }
              uint64_t v454 = *(void *)(v454 + 8);
            }
            while ((void ***)v454 != v679);
            unsigned int v448 = v686[0];
          }
          if (v448 == 2) {
            sub_1CD8E80EC((uint64_t)v686, (llvm::IRBuilderBase *)v684, (uint64_t)v345);
          }
          uint64_t v477 = (uint64_t)**(a2 - 8);
          unint64_t v478 = (uint64_t *)*(a2 - 4);
          v699[0] = llvm::ConstantInt::get(*v345, 0, 0);
          v699[1] = v345;
          WORD4(v706) = 257;
          uint64_t v479 = sub_1CC57EEA0(v684, v477, v478, (uint64_t *)v699, 2, (uint64_t)&v703);
          uint64_t v480 = sub_1CC27BF8C(v684, (uint64_t)v343, v479, 0, 0);
          llvm::Instruction::copyMetadata((uint64_t)v480, v290, 0, 0);
          unsigned int v481 = __clz(1 << ((unint64_t)*((unsigned __int16 *)a2 + 9) >> 1)) ^ 0x3F;
          unsigned int v482 = __clz(1 << ((unint64_t)*(unsigned __int16 *)(v340 + 18) >> 1)) ^ 0x3F;
          if (v481 <= v482) {
            char v483 = v482;
          }
          else {
            char v483 = v481;
          }
          *((_WORD *)v480 + 9) = *((_WORD *)v480 + 9) & 0xFF81 | (2
                                                                * sub_1CD351E7C(v483, *v343, (uint64_t)v345, (uint64_t)v654));
          sub_1CD350D64(v685, (llvm::ValueAsMetadata *)a2, v480);
          sub_1CD350AB4((int32x2_t *)v685, (uint64_t)a2);
        }
      }
    }
    goto LABEL_552;
  }
LABEL_553:
  char v355 = (v341 == 60) & v2;
  int v277 = (char *)v344[1];
  char v289 = *v277;
LABEL_555:
  *int v277 = v289 | v355;
}

void sub_1CD350AB4(int32x2_t *a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a2 + 20);
  if ((v4 & 0x40000000) != 0)
  {
    uint64_t v6 = *(void *)(a2 - 8);
    uint64_t v5 = v4 & 0x7FFFFFF;
    if (!v5) {
      goto LABEL_31;
    }
  }
  else
  {
    uint64_t v5 = v4 & 0x7FFFFFF;
    uint64_t v6 = a2 - 32 * v5;
    if (!v5)
    {
LABEL_31:
      uint64_t v35 = a2;
      int32x2_t v24 = a1[281];
      uint64_t v25 = a1[283].u32[0];
      if (v25)
      {
        LODWORD(v26) = (v25 - 1) & ((a2 >> 4) ^ (a2 >> 9));
        uint64_t v27 = *(void *)&v24 + 16 * v26;
        uint64_t v28 = *(void *)v27;
        if (*(void *)v27 != a2)
        {
          int v29 = 1;
          do
          {
            if (v28 == -4096) {
              goto LABEL_37;
            }
            int v30 = v26 + v29++;
            uint64_t v26 = v30 & (v25 - 1);
            uint64_t v28 = *(void *)(*(void *)&v24 + 16 * v26);
          }
          while (v28 != a2);
          uint64_t v27 = *(void *)&v24 + 16 * v26;
        }
      }
      else
      {
LABEL_37:
        uint64_t v27 = *(void *)&v24 + 16 * v25;
      }
      if (v27 != *(void *)&v24 + 16 * v25)
      {
        *(void *)(*(void *)&a1[23] + 8 * *(unsigned int *)(v27 + 8)) = 0;
        *(void *)uint64_t v27 = -8192;
        a1[282] = vadd_s32(a1[282], (int32x2_t)0x1FFFFFFFFLL);
      }
      if (sub_1CBFD6090((uint64_t)&a1[284], &v35))
      {
        int v31 = (void *)a1[301];
        uint64_t v32 = a1[302].u32[0];
        char v33 = &v31[v32];
        if (v32)
        {
          uint64_t v34 = 8 * v32;
          do
          {
            if (*v31 == v35) {
              goto LABEL_47;
            }
            ++v31;
            v34 -= 8;
          }
          while (v34);
          int v31 = v33;
        }
LABEL_47:
        if (v33 != v31 + 1)
        {
          memmove(v31, v31 + 1, (char *)v33 - (char *)(v31 + 1));
          LODWORD(v32) = a1[302].i32[0];
        }
        a1[302].i32[0] = v32 - 1;
      }
      llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
    }
  }
  uint64_t v7 = v6 + 32 * v5;
  while (1)
  {
    uint64_t v8 = *(void *)v6;
    if (*(void *)v6) {
      BOOL v9 = *(unsigned __int8 *)(*(void *)v6 + 16) >= 0x1Cu;
    }
    else {
      BOOL v9 = 0;
    }
    if (v9)
    {
      __int32 v10 = a1[24].i32[0];
      uint64_t v35 = *(void *)v6;
      __int32 v36 = v10;
      __int32 v11 = a1[283].i32[0];
      if (!v11)
      {
        int v21 = 0;
LABEL_25:
        unsigned int v22 = sub_1CBF569E0(&a1[281], (uint64_t)&v35, &v35, v21);
        *unsigned int v22 = v35;
        *((_DWORD *)v22 + 2) = v36;
        unint64_t v23 = a1[24].u32[0];
        if (v23 >= a1[24].u32[1]) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)&a1[23] + 8 * v23) = v8;
        ++a1[24].i32[0];
        goto LABEL_27;
      }
      int32x2_t v12 = a1[281];
      __int32 v13 = v11 - 1;
      unsigned int v14 = v13 & ((v8 >> 4) ^ (v8 >> 9));
      unsigned int v15 = (void *)(*(void *)&v12 + 16 * v14);
      uint64_t v16 = *v15;
      if (*v15 != v8)
      {
        int v17 = 0;
        int v18 = 1;
        while (v16 != -4096)
        {
          if (v17) {
            BOOL v19 = 0;
          }
          else {
            BOOL v19 = v16 == -8192;
          }
          if (v19) {
            int v17 = v15;
          }
          unsigned int v20 = v14 + v18++;
          unsigned int v14 = v20 & v13;
          unsigned int v15 = (void *)(*(void *)&v12 + 16 * v14);
          uint64_t v16 = *v15;
          if (*v15 == v8) {
            goto LABEL_27;
          }
        }
        if (v17) {
          int v21 = v17;
        }
        else {
          int v21 = v15;
        }
        goto LABEL_25;
      }
    }
LABEL_27:
    v6 += 32;
    if (v6 == v7) {
      goto LABEL_31;
    }
  }
}

void sub_1CD350D64(uint64_t a1, llvm::ValueAsMetadata *this, llvm::Value *a3)
{
  llvm::Value::doRAUW(this, a3, (llvm::Value *)1);
  llvm::Value::takeName((int32x2_t ****)a3, this);
  unsigned int v6 = *((unsigned __int8 *)a3 + 16);
  if (v6 >= 0x1C) {
    uint64_t v7 = a3;
  }
  else {
    uint64_t v7 = 0;
  }
  if (v6 >= 0x1C)
  {
    uint64_t v8 = *((void *)a3 + 1);
    if (v8)
    {
      int v9 = *(_DWORD *)(a1 + 192);
      while (1)
      {
        uint64_t v10 = *(void *)(v8 + 24);
        uint64_t v52 = (llvm::ValueAsMetadata *)v10;
        int v53 = v9;
        int v11 = *(_DWORD *)(a1 + 2264);
        if (!v11) {
          break;
        }
        uint64_t v12 = *(void *)(a1 + 2248);
        int v13 = v11 - 1;
        unsigned int v14 = v13 & ((v10 >> 4) ^ (v10 >> 9));
        unsigned int v15 = (void *)(v12 + 16 * v14);
        uint64_t v16 = *v15;
        if (*v15 != v10)
        {
          int v17 = 0;
          int v18 = 1;
          while (v16 != -4096)
          {
            if (v17) {
              BOOL v19 = 0;
            }
            else {
              BOOL v19 = v16 == -8192;
            }
            if (v19) {
              int v17 = v15;
            }
            unsigned int v20 = v14 + v18++;
            unsigned int v14 = v20 & v13;
            unsigned int v15 = (void *)(v12 + 16 * v14);
            uint64_t v16 = *v15;
            if (*v15 == v10) {
              goto LABEL_23;
            }
          }
          if (v17) {
            int v21 = v17;
          }
          else {
            int v21 = v15;
          }
          goto LABEL_21;
        }
LABEL_23:
        uint64_t v8 = *(void *)(v8 + 8);
        if (!v8) {
          goto LABEL_27;
        }
      }
      int v21 = 0;
LABEL_21:
      unsigned int v22 = sub_1CBF569E0((_DWORD *)(a1 + 2248), (uint64_t)&v52, (uint64_t *)&v52, v21);
      *unsigned int v22 = v52;
      *((_DWORD *)v22 + 2) = v53;
      unint64_t v23 = *(unsigned int *)(a1 + 192);
      if (v23 >= *(unsigned int *)(a1 + 196)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(a1 + 184) + 8 * v23) = v10;
      int v9 = *(_DWORD *)(a1 + 192) + 1;
      *(_DWORD *)(a1 + 192) = v9;
      goto LABEL_23;
    }
LABEL_27:
    if (*((unsigned __int8 *)v7 + 16) >= 0x1Cu)
    {
      int v24 = *(_DWORD *)(a1 + 192);
      uint64_t v52 = v7;
      int v53 = v24;
      int v25 = *(_DWORD *)(a1 + 2264);
      if (v25)
      {
        uint64_t v26 = *(void *)(a1 + 2248);
        int v27 = v25 - 1;
        unsigned int v28 = v27 & ((v7 >> 4) ^ (v7 >> 9));
        int v29 = (llvm::Value **)(v26 + 16 * v28);
        int v30 = *v29;
        if (*v29 == v7) {
          goto LABEL_44;
        }
        int v31 = 0;
        int v32 = 1;
        while (v30 != (llvm::Value *)-4096)
        {
          if (v31) {
            BOOL v33 = 0;
          }
          else {
            BOOL v33 = v30 == (llvm::Value *)-8192;
          }
          if (v33) {
            int v31 = v29;
          }
          unsigned int v34 = v28 + v32++;
          unsigned int v28 = v34 & v27;
          int v29 = (llvm::Value **)(v26 + 16 * v28);
          int v30 = *v29;
          if (*v29 == v7) {
            goto LABEL_44;
          }
        }
        if (v31) {
          uint64_t v35 = v31;
        }
        else {
          uint64_t v35 = v29;
        }
      }
      else
      {
        uint64_t v35 = 0;
      }
      __int32 v36 = sub_1CBF569E0((_DWORD *)(a1 + 2248), (uint64_t)&v52, (uint64_t *)&v52, v35);
      *__int32 v36 = v52;
      *((_DWORD *)v36 + 2) = v53;
      unsigned int v37 = *(_DWORD *)(a1 + 192);
      if (v37 >= *(_DWORD *)(a1 + 196)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(a1 + 184) + 8 * v37) = v7;
      ++*(_DWORD *)(a1 + 192);
    }
  }
LABEL_44:
  if (*((unsigned __int8 *)this + 16) < 0x1Cu) {
    return;
  }
  int v38 = *(_DWORD *)(a1 + 192);
  uint64_t v52 = this;
  int v53 = v38;
  int v39 = *(_DWORD *)(a1 + 2264);
  if (v39)
  {
    uint64_t v40 = *(void *)(a1 + 2248);
    int v41 = v39 - 1;
    unsigned int v42 = v41 & ((this >> 4) ^ (this >> 9));
    uint64_t v43 = (llvm::ValueAsMetadata **)(v40 + 16 * v42);
    uint64_t v44 = *v43;
    if (*v43 == this) {
      return;
    }
    uint64_t v45 = 0;
    int v46 = 1;
    while (v44 != (llvm::ValueAsMetadata *)-4096)
    {
      if (v45) {
        BOOL v47 = 0;
      }
      else {
        BOOL v47 = v44 == (llvm::ValueAsMetadata *)-8192;
      }
      if (v47) {
        uint64_t v45 = v43;
      }
      unsigned int v48 = v42 + v46++;
      unsigned int v42 = v48 & v41;
      uint64_t v43 = (llvm::ValueAsMetadata **)(v40 + 16 * v42);
      uint64_t v44 = *v43;
      if (*v43 == this) {
        return;
      }
    }
    if (v45) {
      uint64_t v49 = v45;
    }
    else {
      uint64_t v49 = v43;
    }
  }
  else
  {
    uint64_t v49 = 0;
  }
  int v50 = sub_1CBF569E0((_DWORD *)(a1 + 2248), (uint64_t)&v52, (uint64_t *)&v52, v49);
  *int v50 = v52;
  *((_DWORD *)v50 + 2) = v53;
  unsigned int v51 = *(_DWORD *)(a1 + 192);
  if (v51 >= *(_DWORD *)(a1 + 196)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)(a1 + 184) + 8 * v51) = this;
  ++*(_DWORD *)(a1 + 192);
}

uint64_t sub_1CD3510C8(void **a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 16) != 89) {
    return 0;
  }
  int v2 = *(_DWORD *)(a2 + 20);
  if ((v2 & 0x40000000) != 0) {
    uint64_t v3 = *(uint64_t **)(a2 - 8);
  }
  else {
    uint64_t v3 = (uint64_t *)(a2 - 32 * (v2 & 0x7FFFFFF));
  }
  uint64_t v4 = *v3;
  if (v4)
  {
    **a1 = v4;
    int v5 = *(_DWORD *)(a2 + 20);
    if ((v5 & 0x40000000) != 0) {
      uint64_t v6 = *(void *)(a2 - 8);
    }
    else {
      uint64_t v6 = a2 - 32 * (v5 & 0x7FFFFFF);
    }
    uint64_t v7 = *(void *)(v6 + 32);
    if (v7) {
      BOOL v8 = *(unsigned char *)(v7 + 16) == 16;
    }
    else {
      BOOL v8 = 0;
    }
    if (!v8) {
      return 0;
    }
    int v9 = (void *)(v7 + 24);
    uint64_t v10 = *(unsigned int *)(v7 + 32);
    if (v10 < 0x41) {
      goto LABEL_15;
    }
    int v12 = 0;
    int64_t v13 = (unint64_t)(v10 + 63) >> 6;
    do
    {
      if (v13-- < 1) {
        break;
      }
      unint64_t v15 = *(void *)(*v9 + 8 * v13);
      v12 += __clz(v15);
    }
    while (!v15);
    uint64_t v4 = 0;
    int v16 = v10 | 0xFFFFFFC0;
    if ((v10 & 0x3F) == 0) {
      int v16 = 0;
    }
    if ((v10 - v12 - v16) <= 0x40)
    {
      int v9 = (void *)*v9;
LABEL_15:
      *a1[1] = *v9;
      return 1;
    }
  }
  return v4;
}

uint64_t sub_1CD3511A8(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v6 = a2;
  uint64_t v8 = *(void *)(a2 - 32);
  int v9 = (unsigned int *)(v8 + 24);
  if (*(_DWORD *)(v8 + 32) >= 0x41u) {
    int v9 = *(unsigned int **)v9;
  }
  uint64_t v10 = *v9;
  uint64_t v11 = *(void *)(a3 - 32);
  int v12 = (void *)(v11 + 24);
  if (*(_DWORD *)(v11 + 32) >= 0x41u) {
    int v12 = (void *)*v12;
  }
  unsigned int v13 = *(_DWORD *)v12;
  if (v10 == *(_DWORD *)v12) {
    return 0;
  }
  uint64_t v14 = (*(uint64_t (**)(void, void, void, uint64_t))(***(void ***)(a1 + 144) + 872))(**(void **)(a1 + 144), *(unsigned __int8 *)(a2 + 16) - 28, **(void **)(a2 - 64), v10);
  int v16 = v15;
  uint64_t v17 = (*(uint64_t (**)(void))(***(void ***)(a1 + 144) + 872))();
  if (v16 && v18 != 0) {
    return 0;
  }
  BOOL v20 = v17 < v14;
  if (v18 != v16) {
    BOOL v20 = v18 < v16;
  }
  if (!v20)
  {
    BOOL v21 = v16 < v18;
    if (v18 == v16) {
      BOOL v21 = v14 < v17;
    }
    if (v21 || v10 == a4)
    {
      return a3;
    }
    else if (v13 != a4 && v10 <= v13)
    {
      return a3;
    }
  }
  return v6;
}

llvm::Instruction *sub_1CD351348(uint64_t a1, llvm::Type *a2, int a3, uint64_t a4)
{
  int v6 = (int)a2;
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(llvm::PoisonValue **)a1;
  uint64_t v9 = *(unsigned int *)(*(void *)a1 + 32);
  unsigned int __b = v18;
  int v17 = 32;
  if (v9 >= 0x21)
  {
    unsigned int v16 = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (v9) {
    memset(v18, 255, 4 * v9);
  }
  unsigned int v16 = v9;
  v18[a3] = v6;
  unsigned int v13 = "shift";
  __int16 v14 = 259;
  uint64_t v10 = llvm::PoisonValue::get(v8, a2);
  uint64_t v11 = sub_1CB935A74(a4, a1, (uint64_t)v10, v18, (llvm::Type *)v16, (uint64_t)&v13);
  if (__b != v18) {
    free(__b);
  }
  return v11;
}

uint64_t sub_1CD351494(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 0;
  if (a2)
  {
    unsigned int v3 = *(unsigned __int8 *)(a2 + 16);
    if (v3 >= 0x1C && v3 - 83 >= 0xFFFFFFFE)
    {
      uint64_t v5 = *(void *)(a2 - 64);
      if (v5) {
        BOOL v6 = *(unsigned __int8 *)(v5 + 16) >= 0x1Cu;
      }
      else {
        BOOL v6 = 0;
      }
      if (v6)
      {
        uint64_t v2 = 0;
        **(void **)(a1 + 8) = v5;
        uint64_t v7 = *(void *)(a2 - 32);
        if (v7 && *(unsigned __int8 *)(v7 + 16) <= 0x14u)
        {
          **(void **)(a1 + 16) = v7;
          **(_DWORD **)a1 = *(_WORD *)(a2 + 18) & 0x3F;
          return 1;
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return v2;
}

uint64_t sub_1CD351510(void **a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 16) != 90) {
    return 0;
  }
  int v2 = *(_DWORD *)(a2 + 20);
  unsigned int v3 = (v2 & 0x40000000) != 0 ? *(uint64_t **)(a2 - 8) : (uint64_t *)(a2 - 32 * (v2 & 0x7FFFFFF));
  uint64_t v4 = *v3;
  BOOL v5 = !v4 || *(unsigned __int8 *)(v4 + 16) > 0x14u;
  if (v5) {
    return 0;
  }
  **a1 = v4;
  int v8 = *(_DWORD *)(a2 + 20);
  if ((v8 & 0x40000000) != 0) {
    uint64_t v9 = *(void *)(a2 - 8);
  }
  else {
    uint64_t v9 = a2 - 32 * (v8 & 0x7FFFFFF);
  }
  uint64_t v6 = *(void *)(v9 + 32);
  if (v6)
  {
    *a1[1] = v6;
    int v10 = *(_DWORD *)(a2 + 20);
    uint64_t v11 = (v10 & 0x40000000) != 0 ? *(void *)(a2 - 8) : a2 - 32 * (v10 & 0x7FFFFFF);
    uint64_t v6 = 0;
    uint64_t v12 = *(void *)(v11 + 64);
    if (v12)
    {
      if (*(unsigned char *)(v12 + 16) == 16)
      {
        unsigned int v13 = (void *)(v12 + 24);
        uint64_t v14 = *(unsigned int *)(v12 + 32);
        if (v14 < 0x41)
        {
LABEL_22:
          *a1[2] = *v13;
          return 1;
        }
        int v15 = 0;
        int64_t v16 = (unint64_t)(v14 + 63) >> 6;
        do
        {
          BOOL v5 = v16-- < 1;
          if (v5) {
            break;
          }
          unint64_t v17 = *(void *)(*v13 + 8 * v16);
          v15 += __clz(v17);
        }
        while (!v17);
        uint64_t v6 = 0;
        int v18 = v14 | 0xFFFFFFC0;
        if ((v14 & 0x3F) == 0) {
          int v18 = 0;
        }
        if ((v14 - v15 - v18) <= 0x40)
        {
          unsigned int v13 = (void *)*v13;
          goto LABEL_22;
        }
      }
    }
  }
  return v6;
}

uint64_t sub_1CD351628(uint64_t result, uint64_t a2, uint64_t a3, llvm::AssumptionCache *a4, uint64_t a5, const llvm::Instruction *a6)
{
  uint64_t v11 = result;
  if (a3 && *(unsigned char *)(a3 + 16) == 16)
  {
    uint64_t v12 = (void *)(a3 + 24);
    uint64_t v13 = *(unsigned int *)(a3 + 32);
    if (v13 >= 0x41)
    {
      int v14 = 0;
      int64_t v15 = (unint64_t)(v13 + 63) >> 6;
      do
      {
        if (v15-- < 1) {
          break;
        }
        unint64_t v17 = *(void *)(*v12 + 8 * v15);
        v14 += __clz(v17);
      }
      while (!v17);
      int v18 = v13 | 0xFFFFFFC0;
      if ((v13 & 0x3F) == 0) {
        int v18 = 0;
      }
      if ((v13 - v14 - v18) > 0x40) {
        goto LABEL_25;
      }
      uint64_t v12 = (void *)*v12;
    }
    if (*v12 < (unint64_t)*(unsigned int *)(a2 + 32))
    {
      *(_DWORD *)uint64_t result = 1;
LABEL_26:
      *(void *)(result + 8) = 0;
      return result;
    }
LABEL_25:
    *(_DWORD *)uint64_t result = 0;
    goto LABEL_26;
  }
  uint64_t v19 = *(llvm::Type **)a3;
  if ((*(_DWORD *)(*(void *)a3 + 8) & 0xFE) == 0x12) {
    uint64_t v19 = (llvm::Type *)**((void **)v19 + 2);
  }
  unsigned int PrimitiveSizeInBits = llvm::Type::getPrimitiveSizeInBits(v19);
  unsigned int v21 = PrimitiveSizeInBits;
  if (PrimitiveSizeInBits > 0x40) {
    operator new[]();
  }
  uint64_t v22 = *(unsigned int *)(a2 + 32);
  unint64_t v23 = (void *)(0xFFFFFFFFFFFFFFFFLL >> -(char)PrimitiveSizeInBits);
  unint64_t v24 = (unint64_t)v23;
  if (!PrimitiveSizeInBits) {
    unint64_t v24 = 0;
  }
  unint64_t v25 = v24 & v22;
  unsigned int v55 = PrimitiveSizeInBits;
  uint64_t v54 = 0;
  unsigned int v57 = PrimitiveSizeInBits;
  uint64_t v56 = v24 & v22;
  unsigned int v51 = PrimitiveSizeInBits;
  if (!PrimitiveSizeInBits) {
    unint64_t v23 = 0;
  }
  uint64_t __src = v23;
  unsigned int v53 = PrimitiveSizeInBits;
  uint64_t v52 = (uint64_t)v23;
  if (sub_1CC16A22C((uint64_t ***)a3, a5, 0, 0, 0, 1))
  {
    llvm::computeConstantRange((llvm *)a3, 0, a4, a6, 0, 1, a5, &v46);
    uint64_t result = llvm::ConstantRange::contains((llvm::ConstantRange *)&v54, (const llvm::ConstantRange *)&v46);
    int v26 = result;
    if (v49 >= 0x41)
    {
      uint64_t result = v48;
      if (v48) {
        uint64_t result = MEMORY[0x1D25D9CB0](v48, 0x1000C8000313F17);
      }
    }
    if (v47 >= 0x41)
    {
      uint64_t result = (uint64_t)v46;
      if (v46) {
        uint64_t result = MEMORY[0x1D25D9CB0](v46, 0x1000C8000313F17);
      }
    }
    if (v26) {
      *(_DWORD *)uint64_t v11 = 1;
    }
    else {
      *(_DWORD *)uint64_t v11 = 0;
    }
    *(void *)(v11 + 8) = 0;
    goto LABEL_73;
  }
  int v27 = *(unsigned __int8 *)(a3 + 16);
  if (v27 == 5)
  {
    int v31 = *(unsigned __int16 *)(a3 + 18);
    if (v31 != 22)
    {
      if (v31 == 28)
      {
        int v32 = (uint64_t *)(a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF));
        uint64_t v28 = *v32;
        if (!*v32) {
          goto LABEL_66;
        }
        uint64_t v29 = v32[4];
        if (!v29 || *(unsigned char *)(v29 + 16) != 16) {
          goto LABEL_66;
        }
LABEL_48:
        unsigned int v34 = *(_DWORD *)(v29 + 32);
        if (v34 > 0x40) {
          operator new[]();
        }
        uint64_t v35 = *(void **)(v29 + 24);
        unsigned int v43 = v34;
        unsigned int v42 = v35;
        unsigned int v47 = v34;
        int v46 = v35;
        llvm::APInt::operator+=((uint64_t)&v46, 1uLL);
        unsigned int v45 = v47;
        uint64_t v44 = v46;
        llvm::ConstantRange::binaryAnd((const void **)&__src, (const llvm::ConstantRange *)&v42, (uint64_t)&v46);
LABEL_61:
        if (v51 >= 0x41 && __src) {
          MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
        }
        uint64_t __src = v46;
        unsigned int v51 = v47;
        unsigned int v47 = 0;
        if (v53 >= 0x41 && v52)
        {
          MEMORY[0x1D25D9CB0](v52, 0x1000C8000313F17);
          uint64_t v52 = v48;
          unsigned int v53 = v49;
          unsigned int v49 = 0;
          if (v47 >= 0x41 && v46) {
            MEMORY[0x1D25D9CB0](v46, 0x1000C8000313F17);
          }
        }
        else
        {
          uint64_t v52 = v48;
          unsigned int v53 = v49;
          unsigned int v49 = 0;
        }
        if (v45 >= 0x41 && v44) {
          MEMORY[0x1D25D9CB0](v44, 0x1000C8000313F17);
        }
        if (v43 >= 0x41 && v42) {
          MEMORY[0x1D25D9CB0](v42, 0x1000C8000313F17);
        }
        goto LABEL_66;
      }
LABEL_50:
      uint64_t v28 = 0;
      goto LABEL_66;
    }
    __int32 v36 = (uint64_t *)(a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF));
    uint64_t v28 = *v36;
    if (!*v36) {
      goto LABEL_66;
    }
    uint64_t v30 = v36[4];
    if (!v30 || *(unsigned char *)(v30 + 16) != 16) {
      goto LABEL_66;
    }
LABEL_57:
    unsigned int v38 = *(_DWORD *)(v30 + 32);
    if (v38 > 0x40) {
      operator new[]();
    }
    int v39 = *(void **)(v30 + 24);
    unsigned int v43 = v38;
    unsigned int v42 = v39;
    unsigned int v47 = v38;
    int v46 = v39;
    llvm::APInt::operator+=((uint64_t)&v46, 1uLL);
    unsigned int v45 = v47;
    uint64_t v44 = v46;
    llvm::ConstantRange::urem((llvm::ConstantRange *)&__src, (const llvm::ConstantRange *)&v42, (uint64_t)&v46);
    goto LABEL_61;
  }
  if (v27 != 50)
  {
    if (v27 == 56)
    {
      uint64_t v28 = *(void *)(a3 - 64);
      if (!v28) {
        goto LABEL_66;
      }
      uint64_t v29 = *(void *)(a3 - 32);
      if (!v29 || *(unsigned char *)(v29 + 16) != 16) {
        goto LABEL_66;
      }
      goto LABEL_48;
    }
    goto LABEL_50;
  }
  uint64_t v28 = *(void *)(a3 - 64);
  if (v28)
  {
    uint64_t v30 = *(void *)(a3 - 32);
    if (v30)
    {
      if (*(unsigned char *)(v30 + 16) == 16) {
        goto LABEL_57;
      }
    }
  }
LABEL_66:
  uint64_t result = llvm::ConstantRange::contains((llvm::ConstantRange *)&v54, (const llvm::ConstantRange *)&__src);
  if (result) {
    int v40 = 2;
  }
  else {
    int v40 = 0;
  }
  if (result) {
    uint64_t v41 = v28;
  }
  else {
    uint64_t v41 = 0;
  }
  *(_DWORD *)uint64_t v11 = v40;
  *(void *)(v11 + 8) = v41;
LABEL_73:
  if (v53 >= 0x41)
  {
    uint64_t result = v52;
    if (v52) {
      uint64_t result = MEMORY[0x1D25D9CB0](v52, 0x1000C8000313F17);
    }
  }
  if (v51 >= 0x41)
  {
    uint64_t result = (uint64_t)__src;
    if (__src) {
      uint64_t result = MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
    }
  }
  if (v57 >= 0x41)
  {
    uint64_t result = v56;
    if (v56) {
      uint64_t result = MEMORY[0x1D25D9CB0](v56, 0x1000C8000313F17);
    }
  }
  if (v55 >= 0x41)
  {
    uint64_t result = v54;
    if (v54) {
      uint64_t result = MEMORY[0x1D25D9CB0](v54, 0x1000C8000313F17);
    }
  }
  if (v21 >= 0x41 && v25) {
    return MEMORY[0x1D25D9CB0](v25, 0x1000C8000313F17);
  }
  return result;
}

uint64_t sub_1CD351E7C(char a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3 && *(unsigned char *)(a3 + 16) == 16)
  {
    BOOL v5 = (void *)(a3 + 24);
    if (*(_DWORD *)(a3 + 32) >= 0x41u) {
      BOOL v5 = (void *)*v5;
    }
    uint64_t v6 = (void *)*v5;
    unint64_t v8 = ((unint64_t)(sub_1CB83544C(a4, a2) + 7) >> 3) * (void)v6;
  }
  else
  {
    unint64_t v8 = (unint64_t)(sub_1CB83544C(a4, a2) + 7) >> 3;
  }
  if (v7 == 1)
  {
    unint64_t v10 = v8;
    unint64_t v8 = v10;
  }
  return 63 - __clz((v8 | (1 << a1)) & -(uint64_t)(v8 | (1 << a1)));
}

uint64_t sub_1CD351F34()
{
  LOBYTE(v2) = 0;
  uint64_t v4 = &v2;
  int v3 = 1;
  v1.n128_u64[0] = (unint64_t)"Disable all vector combine transforms";
  v1.n128_u64[1] = 37;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBD01EA0, "disable-vector-combine", (unsigned char **)&v4, &v3, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBD01EA0, &dword_1CB82C000);
  LOBYTE(v2) = 0;
  uint64_t v4 = &v2;
  int v3 = 1;
  v1.n128_u64[0] = (unint64_t)"Disable binop extract to shuffle transforms";
  v1.n128_u64[1] = 43;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBD01F60, "disable-binop-extract-shuffle", (unsigned char **)&v4, &v3, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBD01F60, &dword_1CB82C000);
  int v2 = 1;
  int v3 = 30;
  uint64_t v4 = &v3;
  v1.n128_u64[0] = (unint64_t)"Max number of instructions to scan for vector combining.";
  v1.n128_u64[1] = 56;
  sub_1CBF7A9F8((uint64_t)&unk_1EBD02020, "vector-combine-max-scan-instrs", &v4, &v2, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBD02020, &dword_1CB82C000);
}

llvm::raw_ostream *llvm::operator<<(llvm::raw_ostream *a1, unsigned char *a2)
{
  if (a2[8] == 1 && (uint64_t v4 = (llvm::VPBlockBase *)*((void *)a2 - 1)) != 0)
  {
    Plan = (const llvm::VPlan *)llvm::VPBlockBase::getPlan(v4);
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    int v10 = 0;
    int v9 = 0;
    if (Plan) {
      llvm::VPSlotTracker::assignSlots((llvm::VPSlotTracker *)&v7, Plan);
    }
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    int v10 = 0;
    int v9 = 0;
  }
  llvm::VPValue::print((llvm::VPValue *)a2, a1, (llvm::VPSlotTracker *)&v7);
  MEMORY[0x1D25D9CD0](v7, 8);
  return a1;
}

llvm::raw_ostream *llvm::VPValue::print(llvm::VPValue *this, llvm::raw_ostream *a2, llvm::VPSlotTracker *a3)
{
  uint64_t v4 = *((void *)this + 6);
  if (v4)
  {
    __int16 v7 = 257;
    return (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t, llvm::raw_ostream *, unsigned char *, llvm::VPSlotTracker *))(*(void *)v4 + 16))(v4, a2, v6, a3);
  }
  else
  {
    return llvm::VPValue::printAsOperand(this, a2, a3);
  }
}

llvm::raw_ostream *llvm::VPValue::printAsOperand(llvm::VPValue *this, llvm::raw_ostream *a2, llvm::VPSlotTracker *a3)
{
  uint64_t v4 = (llvm::Value *)*((void *)this + 5);
  if (v4)
  {
    uint64_t v13 = *((void *)a2 + 4);
    if ((unint64_t)(*((void *)a2 + 3) - v13) > 2)
    {
      *(unsigned char *)(v13 + 2) = 60;
      *(_WORD *)uint64_t v13 = 29289;
      *((void *)a2 + 4) += 3;
    }
    else
    {
      llvm::raw_ostream::write(a2, "ir<", 3uLL);
    }
    uint64_t result = (llvm::raw_ostream *)llvm::Value::printAsOperand(v4, a2, 0, 0);
LABEL_12:
    int v14 = (unsigned char *)*((void *)a2 + 4);
    if (*((unsigned char **)a2 + 3) == v14)
    {
      int v10 = ">";
      uint64_t v11 = a2;
      size_t v12 = 1;
      goto LABEL_14;
    }
    *int v14 = 62;
    uint64_t v18 = *((void *)a2 + 4) + 1;
LABEL_26:
    *((void *)a2 + 4) = v18;
    return result;
  }
  uint64_t v19 = 0;
  uint64_t result = (llvm::raw_ostream *)sub_1CD40EA84(*(void *)a3, *((_DWORD *)a3 + 4), (uint64_t)this, &v19);
  if (result) {
    BOOL v8 = v19 == *(void *)a3 + 16 * *((unsigned int *)a3 + 4);
  }
  else {
    BOOL v8 = 1;
  }
  if (!v8 && *(_DWORD *)(v19 + 8) != -1)
  {
    int64_t v15 = (_DWORD *)*((void *)a2 + 4);
    if (*((void *)a2 + 3) - (void)v15 > 3uLL)
    {
      *int64_t v15 = 624717942;
      *((void *)a2 + 4) += 4;
    }
    else
    {
      llvm::raw_ostream::write(a2, "vp<%", 4uLL);
    }
    uint64_t v19 = 0;
    int v16 = sub_1CD40EA84(*(void *)a3, *((_DWORD *)a3 + 4), (uint64_t)this, &v19);
    unint64_t v17 = 0xFFFFFFFFLL;
    if (v16 && v19 != *(void *)a3 + 16 * *((unsigned int *)a3 + 4)) {
      unint64_t v17 = *(unsigned int *)(v19 + 8);
    }
    uint64_t result = sub_1CD098D14(a2, v17, 0, 0, 0);
    goto LABEL_12;
  }
  int v9 = (void *)*((void *)a2 + 4);
  if (*((void *)a2 + 3) - (void)v9 > 7uLL)
  {
    *int v9 = 0x3E6665726461623CLL;
    uint64_t v18 = *((void *)a2 + 4) + 8;
    goto LABEL_26;
  }
  int v10 = "<badref>";
  uint64_t v11 = a2;
  size_t v12 = 8;
LABEL_14:

  return llvm::raw_ostream::write(v11, v10, v12);
}

uint64_t llvm::VPValue::dump(llvm::VPValue *this)
{
  __n128 v1 = this;
  uint64_t v2 = *((void *)this + 6);
  if (v2 && (this = *(llvm::VPValue **)(v2 + 88)) != 0)
  {
    this = (llvm::VPValue *)llvm::VPBlockBase::getPlan(this);
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    int v11 = 0;
    int v10 = 0;
    if (this) {
      llvm::VPSlotTracker::assignSlots((llvm::VPSlotTracker *)&v8, this);
    }
  }
  else
  {
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    int v11 = 0;
    int v10 = 0;
  }
  int v3 = llvm::dbgs(this);
  uint64_t v4 = llvm::VPValue::print(v1, v3, (llvm::VPSlotTracker *)&v8);
  BOOL v5 = llvm::dbgs(v4);
  uint64_t v6 = (unsigned char *)*((void *)v5 + 4);
  if (*((unsigned char **)v5 + 3) == v6)
  {
    llvm::raw_ostream::write(v5, "\n", 1uLL);
  }
  else
  {
    unsigned char *v6 = 10;
    ++*((void *)v5 + 4);
  }
  return MEMORY[0x1D25D9CD0](v8, 8);
}

uint64_t llvm::VPDef::dump(llvm::VPDef *this)
{
  __n128 v1 = this;
  if (this && (this = (llvm::VPDef *)*((void *)this + 11)) != 0)
  {
    this = (llvm::VPDef *)llvm::VPBlockBase::getPlan(this);
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    int v12 = 0;
    int v11 = 0;
    if (this) {
      llvm::VPSlotTracker::assignSlots((llvm::VPSlotTracker *)&v9, this);
    }
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    int v12 = 0;
    int v11 = 0;
  }
  uint64_t v2 = llvm::dbgs(this);
  __int16 v8 = 257;
  int v3 = (llvm *)(*(uint64_t (**)(llvm::VPDef *, llvm *, unsigned char *, uint64_t *))(*(void *)v1 + 16))(v1, v2, v7, &v9);
  uint64_t v4 = llvm::dbgs(v3);
  BOOL v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "\n", 1uLL);
  }
  else
  {
    unsigned char *v5 = 10;
    ++*((void *)v4 + 4);
  }
  return MEMORY[0x1D25D9CD0](v9, 8);
}

uint64_t llvm::VPBlockBase::getEntryBasicBlock(uint64_t this)
{
  if (this && *(unsigned char *)(this + 8) == 1)
  {
    do
    {
      this = *(void *)(this + 200);
      if (this) {
        BOOL v1 = *(unsigned char *)(this + 8) == 1;
      }
      else {
        BOOL v1 = 0;
      }
    }
    while (v1);
  }
  return this;
}

{
  BOOL v1;

  if (this && *(unsigned char *)(this + 8) == 1)
  {
    do
    {
      this = *(void *)(this + 200);
      if (this) {
        BOOL v1 = *(unsigned char *)(this + 8) == 1;
      }
      else {
        BOOL v1 = 0;
      }
    }
    while (v1);
  }
  return this;
}

uint64_t llvm::VPBlockBase::getExitBasicBlock(uint64_t this)
{
  if (this && *(unsigned char *)(this + 8) == 1)
  {
    do
    {
      this = *(void *)(this + 208);
      if (this) {
        BOOL v1 = *(unsigned char *)(this + 8) == 1;
      }
      else {
        BOOL v1 = 0;
      }
    }
    while (v1);
  }
  return this;
}

{
  BOOL v1;

  if (this && *(unsigned char *)(this + 8) == 1)
  {
    do
    {
      this = *(void *)(this + 208);
      if (this) {
        BOOL v1 = *(unsigned char *)(this + 8) == 1;
      }
      else {
        BOOL v1 = 0;
      }
    }
    while (v1);
  }
  return this;
}

uint64_t llvm::VPBlockBase::getCondBit(llvm::VPBlockBase *this)
{
  if (*((_DWORD *)this + 28) == 1) {
    return **((void **)this + 13);
  }
  else {
    return 0;
  }
}

{
  if (*((_DWORD *)this + 28) == 1) {
    return **((void **)this + 13);
  }
  else {
    return 0;
  }
}

uint64_t llvm::VPBlockBase::getPredicate(llvm::VPBlockBase *this)
{
  if (*((_DWORD *)this + 40) == 1) {
    return **((void **)this + 19);
  }
  else {
    return 0;
  }
}

{
  if (*((_DWORD *)this + 40) == 1) {
    return **((void **)this + 19);
  }
  else {
    return 0;
  }
}

uint64_t llvm::VPTransformState::CFGState::getPreheaderBBFor(llvm::VPTransformState::CFGState *this, llvm::VPRecipeBase *a2)
{
  uint64_t v2 = *(void *)(*((void *)a2 + 11) + 40);
  if (v2 && *(unsigned char *)(v2 + 216)) {
    uint64_t v2 = *(void *)(v2 + 40);
  }
  if (*(_DWORD *)(v2 + 56) == 1)
  {
    for (uint64_t i = **(void **)(v2 + 48); i && *(unsigned char *)(i + 8) == 1; uint64_t i = *(void *)(i + 208))
      ;
  }
  else
  {
    uint64_t i = 0;
  }
  uint64_t v6 = i;
  return sub_1CD645138((_DWORD *)this + 6, &v6)[1];
}

void llvm::VPBasicBlock::createEmptyBasicBlock(llvm::VPBasicBlock *this, llvm::VPTransformState::CFGState *a2)
{
  __int16 v3 = 260;
  uint64_t v2 = (char *)this + 16;
  operator new();
}

void *llvm::VPBasicBlock::execute(uint64_t **this, llvm::VPTransformState *a2)
{
  if (*((unsigned char *)a2 + 24))
  {
    BOOL v5 = !*((_DWORD *)a2 + 3) && !*((_DWORD *)a2 + 4) && *((unsigned char *)a2 + 20) == 0;
    int v4 = !v5;
  }
  else
  {
    int v4 = 0;
  }
  uint64_t v7 = *((void *)a2 + 10);
  uint64_t v6 = (llvm::BasicBlock *)*((void *)a2 + 11);
  uint64_t Plan = llvm::VPBlockBase::getPlan((llvm::VPBlockBase *)this);
  uint64_t v9 = *(void *)Plan;
  if (*(void *)Plan) {
    BOOL v10 = *(unsigned char *)(*(void *)Plan + 8) == 1;
  }
  else {
    BOOL v10 = 0;
  }
  if (!v10)
  {
    if (*(_DWORD *)(v9 + 80) == 1) {
      uint64_t v9 = **(void **)(v9 + 72);
    }
    else {
      uint64_t v9 = 0;
    }
  }
  if (*(_DWORD *)(v9 + 80) == 1) {
    int v11 = **(llvm::VPBasicBlock ***)(v9 + 72);
  }
  else {
    int v11 = 0;
  }
  if (v11 == (llvm::VPBasicBlock *)this)
  {
    uint64_t v6 = (llvm::BasicBlock *)*((void *)a2 + 12);
    *((void *)a2 + 11) = v6;
  }
  else if (v7)
  {
    int v12 = (llvm::VPBasicBlock *)this;
    while (1)
    {
      int v13 = *((_DWORD *)v12 + 14);
      if (v13) {
        break;
      }
      int v12 = (llvm::VPBasicBlock *)*((void *)v12 + 5);
      if (!v12) {
        goto LABEL_45;
      }
    }
    if (v13 != 1) {
      goto LABEL_45;
    }
    uint64_t v14 = **((void **)v12 + 6);
    if (!v14) {
      goto LABEL_45;
    }
    int v15 = *(unsigned __int8 *)(v14 + 8);
    uint64_t v16 = v14;
    if (v15 == 1)
    {
      uint64_t v16 = v14;
      do
      {
        uint64_t v16 = *(void *)(v16 + 208);
        if (v16) {
          BOOL v17 = *(unsigned char *)(v16 + 8) == 1;
        }
        else {
          BOOL v17 = 0;
        }
      }
      while (v17);
    }
    if (v16 != v7) {
      goto LABEL_45;
    }
    while (1)
    {
      int v18 = *(_DWORD *)(v7 + 80);
      if (v18) {
        break;
      }
      uint64_t v7 = *(void *)(v7 + 40);
      if (!v7) {
        goto LABEL_45;
      }
    }
    if (v18 != 1 || !**(void **)(v7 + 72)) {
      goto LABEL_45;
    }
    uint64_t v19 = this[5];
    if (v19 && *((unsigned char *)v19 + 216)) {
      uint64_t v19 = (uint64_t *)v19[5];
    }
    if (*(uint64_t **)(v14 + 40) != v19 || v15 == 1 && !*(unsigned char *)(v14 + 216))
    {
LABEL_45:
      if (!v4 || *((_DWORD *)this + 14)) {
        llvm::VPBasicBlock::createEmptyBasicBlock((llvm::VPBasicBlock *)this, (llvm::VPTransformState *)((char *)a2 + 80));
      }
    }
  }
  uint64_t v35 = (uint64_t *)this;
  uint64_t result = sub_1CD645138((_DWORD *)a2 + 26, &v35);
  result[1] = v6;
  *((void *)a2 + 10) = this;
  for (uint64_t i = (uint64_t **)this[26]; i != this + 25; uint64_t i = (uint64_t **)i[1])
  {
    if (i) {
      uint64_t v22 = i - 3;
    }
    else {
      uint64_t v22 = 0;
    }
    uint64_t result = (void *)((uint64_t (*)(uint64_t **, llvm::VPTransformState *))(*v22)[3])(v22, a2);
  }
  if (byte_1EBD0DAB0)
  {
    if (*((_DWORD *)this + 28) == 1)
    {
      uint64_t v23 = *this[13];
      if (v23)
      {
        char v36 = 0;
        uint64_t v35 = 0;
        unint64_t v24 = llvm::VPTransformState::get((uint64_t)a2, v23, (unsigned int *)&v35);
        unint64_t v25 = (void *)*((void *)v6 + 5);
        if (v25 == (void *)((char *)v6 + 40))
        {
          int v27 = 0;
        }
        else
        {
          if (v25) {
            int v26 = v25 - 3;
          }
          else {
            int v26 = 0;
          }
          if (*((unsigned __int8 *)v26 + 16) - 29 >= 0xB) {
            int v27 = 0;
          }
          else {
            int v27 = v26;
          }
        }
        uint64_t v28 = operator new(0xA0uLL);
        uint64_t v29 = v28;
        uint64_t v30 = 0;
        int v31 = (llvm::Value *)(v28 + 24);
        v28[29] = v28[29] & 0x38000000 | 3;
        do
        {
          int v32 = &v28[v30];
          *int v32 = 0;
          v32[1] = 0;
          v32[2] = 0;
          void v32[3] = v31;
          v30 += 8;
        }
        while (v30 != 24);
        llvm::BranchInst::BranchInst((llvm::BranchInst *)(v28 + 24), v6, 0, v24, 0);
        if (*((void *)v29 + 8))
        {
          **((void **)v29 + 10) = *((void *)v29 + 9);
          uint64_t v33 = *((void *)v29 + 9);
          if (v33) {
            *(void *)(v33 + 16) = *((void *)v29 + 10);
          }
        }
        *((void *)v29 + 8) = 0;
        unsigned int v34 = v27 + 3;
        if (!v27) {
          unsigned int v34 = 0;
        }
        uint64_t v35 = v34;
        llvm::ReplaceInstWithInst(v27[5] + 40, &v35, v31);
      }
    }
  }
  return result;
}

void llvm::VPRegionBlock::execute(uint64_t a1, int *a2)
{
  __p = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  sub_1CD8EDE88((char **)&__p, (uint64_t *)(a1 + 200));
  if (!*(unsigned char *)(a1 + 216))
  {
    uint64_t v11 = *((void *)a2 + 61);
    uint64_t v12 = *((void *)a2 + 32);
    *(void *)(v12 + 128) += 152;
    uint64_t v13 = *(void *)(v12 + 48);
    if (((v13 + 7) & 0xFFFFFFFFFFFFFFF8) - v13 + 152 > *(void *)(v12 + 56) - v13)
    {
      unsigned int v55 = *(_DWORD *)(v12 + 72) >> 7;
      if (v55 >= 0x1E) {
        LOBYTE(v55) = 30;
      }
      uint64_t v56 = 4096 << v55;
      unint64_t v14 = (unint64_t)operator new(4096 << v55, (std::align_val_t)8uLL);
      unsigned int v57 = *(_DWORD *)(v12 + 72);
      if (v57 >= *(_DWORD *)(v12 + 76)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(v12 + 64) + 8 * v57) = v14;
      ++*(_DWORD *)(v12 + 72);
      *(void *)(v12 + 56) = v14 + v56;
    }
    else
    {
      unint64_t v14 = (v13 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    uint64_t v15 = 0;
    *(void *)(v12 + 48) = v14 + 152;
    *(void *)(v14 + 144) = 0;
    *(_OWORD *)(v14 + 112) = 0u;
    *(_OWORD *)(v14 + 128) = 0u;
    *(_OWORD *)(v14 + 80) = 0u;
    *(_OWORD *)(v14 + 96) = 0u;
    *(_OWORD *)(v14 + 48) = 0u;
    *(_OWORD *)(v14 + 64) = 0u;
    *(_OWORD *)(v14 + 16) = 0u;
    *(_OWORD *)(v14 + 32) = 0u;
    *(_OWORD *)unint64_t v14 = 0u;
    *(void *)(v14 + 56) = v14 + 88;
    *(void *)(v14 + 64) = v14 + 88;
    *(_DWORD *)(v14 + 72) = 8;
    *((void *)a2 + 61) = v14;
    if (*(_DWORD *)(a1 + 56) == 1)
    {
      uint64_t v15 = **(void **)(a1 + 48);
      if (v15)
      {
        if (*(unsigned char *)(v15 + 8) == 1)
        {
          do
          {
            uint64_t v15 = *(void *)(v15 + 208);
            if (v15) {
              BOOL v16 = *(unsigned char *)(v15 + 8) == 1;
            }
            else {
              BOOL v16 = 0;
            }
          }
          while (v16);
        }
      }
    }
    uint64_t v58 = v15;
    BOOL v17 = sub_1CD645138(a2 + 26, &v58);
    int v18 = (uint64_t *)*((void *)a2 + 32);
    int v19 = *((_DWORD *)v18 + 4);
    if (v19)
    {
      uint64_t v20 = v17[1];
      uint64_t v21 = *v18;
      unsigned int v22 = v19 - 1;
      uint64_t v23 = (v19 - 1) & ((v20 >> 4) ^ (v20 >> 9));
      uint64_t v24 = *(void *)(*v18 + 16 * v23);
      if (v20 == v24)
      {
LABEL_32:
        int v27 = *(void **)(v21 + 16 * v23 + 8);
        if (v27)
        {
          uint64_t v28 = (void *)*((void *)a2 + 61);
          *uint64_t v28 = v27;
          uint64_t v30 = (void *)v27[2];
          unint64_t v29 = v27[3];
          if ((unint64_t)v30 >= v29)
          {
            unsigned int v42 = (void *)v27[1];
            uint64_t v43 = v30 - v42;
            unint64_t v44 = v43 + 1;
            if ((unint64_t)(v43 + 1) >> 61) {
              goto LABEL_78;
            }
            uint64_t v45 = v29 - (void)v42;
            if (v45 >> 2 > v44) {
              unint64_t v44 = v45 >> 2;
            }
            if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v46 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v46 = v44;
            }
            if (v46)
            {
              if (v46 >> 61) {
                goto LABEL_79;
              }
              unsigned int v47 = (char *)operator new(8 * v46);
            }
            else
            {
              unsigned int v47 = 0;
            }
            int v50 = &v47[8 * v43];
            *(void *)int v50 = v28;
            int v31 = v50 + 8;
            if (v30 != v42)
            {
              do
              {
                uint64_t v51 = *--v30;
                *((void *)v50 - 1) = v51;
                v50 -= 8;
              }
              while (v30 != v42);
              uint64_t v30 = (void *)v27[1];
            }
            v27[1] = v50;
            v27[2] = v31;
            v27[3] = &v47[8 * v46];
            if (v30) {
              operator delete(v30);
            }
          }
          else
          {
            void *v30 = v28;
            int v31 = v30 + 1;
          }
          v27[2] = v31;
LABEL_69:
          unsigned int v53 = (char *)__p;
          for (uint64_t i = v60; i != v53; i -= 8)
          {
            uint64_t v54 = *((void *)i - 1);
            (*(void (**)(uint64_t, int *))(*(void *)v54 + 16))(v54, a2);
          }
          *((void *)a2 + 61) = v11;
          goto LABEL_15;
        }
      }
      else
      {
        int v25 = 1;
        while (v24 != -4096)
        {
          int v26 = v23 + v25++;
          uint64_t v23 = v26 & v22;
          uint64_t v24 = *(void *)(v21 + 16 * v23);
          if (v20 == v24) {
            goto LABEL_32;
          }
        }
      }
    }
    uint64_t v32 = *((void *)a2 + 61);
    unsigned int v34 = (void *)v18[4];
    unint64_t v33 = v18[5];
    if ((unint64_t)v34 < v33)
    {
      *unsigned int v34 = v32;
      uint64_t v35 = v34 + 1;
LABEL_61:
      v18[4] = (uint64_t)v35;
      goto LABEL_69;
    }
    char v36 = (void *)v18[3];
    uint64_t v37 = v34 - v36;
    unint64_t v38 = v37 + 1;
    if (!((unint64_t)(v37 + 1) >> 61))
    {
      uint64_t v39 = v33 - (void)v36;
      if (v39 >> 2 > v38) {
        unint64_t v38 = v39 >> 2;
      }
      if ((unint64_t)v39 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v40 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v40 = v38;
      }
      if (!v40)
      {
        uint64_t v41 = 0;
        goto LABEL_56;
      }
      if (!(v40 >> 61))
      {
        uint64_t v41 = (char *)operator new(8 * v40);
LABEL_56:
        uint64_t v48 = &v41[8 * v37];
        *(void *)uint64_t v48 = v32;
        uint64_t v35 = v48 + 8;
        if (v34 != v36)
        {
          do
          {
            uint64_t v49 = *--v34;
            *((void *)v48 - 1) = v49;
            v48 -= 8;
          }
          while (v34 != v36);
          unsigned int v34 = (void *)v18[3];
        }
        v18[3] = (uint64_t)v48;
        v18[4] = (uint64_t)v35;
        v18[5] = (uint64_t)&v41[8 * v40];
        if (v34) {
          operator delete(v34);
        }
        goto LABEL_61;
      }
LABEL_79:
      sub_1CB833614();
    }
LABEL_78:
    abort();
  }
  if (!*((unsigned char *)a2 + 24)) {
    *((unsigned char *)a2 + 24) = 1;
  }
  *((unsigned char *)a2 + 20) = 0;
  *(void *)(a2 + 3) = 0;
  int v4 = a2[2];
  if (!v4) {
    goto LABEL_14;
  }
  for (int j = 0; j != v4; ++j)
  {
    a2[3] = j;
    int v6 = *a2;
    if (*a2)
    {
      int v7 = 0;
      do
      {
        a2[4] = v7;
        *((unsigned char *)a2 + 20) = 0;
        uint64_t v9 = (char *)__p;
        for (k = v60; k != v9; k -= 8)
        {
          uint64_t v10 = *((void *)k - 1);
          (*(void (**)(uint64_t, int *))(*(void *)v10 + 16))(v10, a2);
        }
        ++v7;
      }
      while (v7 != v6);
    }
  }
  if (*((unsigned char *)a2 + 24)) {
LABEL_14:
  }
    *((unsigned char *)a2 + 24) = 0;
LABEL_15:
  if (__p)
  {
    uint64_t v60 = (char *)__p;
    operator delete(__p);
  }
}

uint64_t llvm::VPRecipeBase::insertBefore(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  *(void *)(a1 + 24) = *a3;
  uint64_t result = a1 + 24;
  *(void *)(result + 64) = a2;
  *(void *)(result + 8) = a3;
  *(void *)(v3 + 8) = result;
  *a3 = result;
  return result;
}

uint64_t llvm::VPRecipeBase::insertAfter(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 88);
  if (*(void *)(v2 + 200) == v2 + 200) {
    uint64_t v3 = (uint64_t **)(v2 + 208);
  }
  else {
    uint64_t v3 = (uint64_t **)(a2 + 32);
  }
  int v4 = *v3;
  uint64_t v5 = *v4;
  *(void *)(a1 + 24) = *v4;
  uint64_t result = a1 + 24;
  *(void *)(result + 64) = v2;
  *(void *)(result + 8) = v4;
  *(void *)(v5 + 8) = result;
  uint64_t *v4 = result;
  return result;
}

void *llvm::VPRecipeBase::removeFromParent(void *this)
{
  uint64_t v1 = this[3];
  uint64_t v2 = (void *)this[4];
  *uint64_t v2 = v1;
  *(void *)(v1 + 8) = v2;
  this[11] = 0;
  this[3] = 0;
  this[4] = 0;
  return this;
}

uint64_t **llvm::VPInstruction::generateInstruction(llvm::VPInstruction *this, llvm::VPTransformState *a2, unsigned int a3)
{
  v57[2] = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *((void *)a2 + 34);
  uint64_t v9 = (unsigned __int8 *)*((void *)this + 20);
  uint64_t v52 = v9;
  if (v9)
  {
    llvm::MetadataTracking::track((uint64_t)&v52, v9, 2);
    uint64_t v10 = (uint64_t)v52;
  }
  else
  {
    uint64_t v10 = 0;
  }
  uint64_t result = (uint64_t **)sub_1CB8461A4(v8, 0, v10);
  if (v52)
  {
    int v13 = *v52;
    if ((v13 - 4) > 0x1E)
    {
      if ((v13 - 3) >= 0xFFFFFFFE) {
        int v25 = v52;
      }
      else {
        int v25 = 0;
      }
      if ((v13 - 3) >= 0xFFFFFFFE)
      {
        unint64_t v26 = (unint64_t)(v25 + 8);
LABEL_29:
        unsigned int v53 = (const char *)&v52;
        uint64_t result = (uint64_t **)sub_1CC5FA668(v26 + 16, &v53);
        goto LABEL_8;
      }
      if (v13 == 3) {
        *((void *)v52 + 1) = 0;
      }
    }
    else if ((v52[1] & 0x7F) == 2 || *((_DWORD *)v52 + 3))
    {
      uint64_t v51 = *((void *)v52 + 2);
      if ((v51 & 4) != 0)
      {
        unint64_t v26 = v51 & 0xFFFFFFFFFFFFFFF8;
        if (v26) {
          goto LABEL_29;
        }
      }
    }
  }
LABEL_8:
  int v14 = *((unsigned __int8 *)this + 152);
  if ((v14 - 13) <= 0x11)
  {
    int v27 = llvm::VPTransformState::get(a2, **((llvm::VPValue ***)this + 6), a3);
    uint64_t v28 = llvm::VPTransformState::get(a2, *(llvm::VPValue **)(*((void *)this + 6) + 8), a3);
    uint64_t v29 = *((unsigned __int8 *)this + 152);
    __int16 v55 = 257;
    uint64_t Intrinsic = (uint64_t)sub_1CB844E98(v8, v29, (uint64_t)v27, (uint64_t)v28, (uint64_t)&v53, 0);
  }
  else
  {
    if (v14 == 77)
    {
      if (!a3)
      {
        uint64_t v15 = llvm::VPTransformState::get(a2, **((llvm::VPValue ***)this + 6), 0);
        BOOL v16 = llvm::VPTransformState::get(a2, *(llvm::VPValue **)(*((void *)this + 6) + 8), 0);
        __int16 v55 = 257;
        BOOL v17 = sub_1CB845F20(v8, 32, v15, (uint64_t)v16, (uint64_t)&v53);
        uint64_t v18 = *(void *)llvm::VPBlockBase::getPlan(*((llvm::VPBlockBase **)this + 11));
        if (!v18 || *(unsigned char *)(v18 + 8) != 1) {
          uint64_t v18 = **(void **)(v18 + 72);
        }
        do
        {
          uint64_t v18 = *(void *)(v18 + 200);
          if (v18) {
            BOOL v19 = *(unsigned char *)(v18 + 8) == 1;
          }
          else {
            BOOL v19 = 0;
          }
        }
        while (v19);
        v57[0] = v18;
        if (*(void *)(v18 + 200) == v18 + 200)
        {
          if (*(_DWORD *)(v18 + 80) == 1) {
            uint64_t v20 = **(void **)(v18 + 72);
          }
          else {
            uint64_t v20 = 0;
          }
          v57[0] = v20;
        }
        uint64_t v45 = (llvm::BasicBlock *)*((void *)a2 + 12);
        unint64_t v46 = (llvm::BasicBlock *)sub_1CD645138((_DWORD *)a2 + 26, v57)[1];
        unsigned int v47 = operator new(0xA0uLL);
        uint64_t v48 = 0;
        uint64_t v49 = (llvm::Instruction *)(v47 + 24);
        v47[29] = v47[29] & 0x38000000 | 3;
        do
        {
          int v50 = &v47[v48];
          *int v50 = 0;
          v50[1] = 0;
          v50[2] = 0;
          v50[3] = v49;
          v48 += 8;
        }
        while (v48 != 24);
        llvm::BranchInst::BranchInst((llvm::BranchInst *)(v47 + 24), v45, v46, v17, 0);
        __int16 v55 = 257;
        sub_1CB844E0C((uint64_t *)v8, v49, (uint64_t)&v53);
        llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
      }
      return result;
    }
    switch(*((unsigned char *)this + 152))
    {
      case 'E':
        uint64_t v37 = llvm::VPTransformState::get(a2, **((llvm::VPValue ***)this + 6), 0);
        if (a3) {
          uint64_t v37 = llvm::VPTransformState::get(a2, *(llvm::VPValue **)(*((void *)this + 6) + 8), a3 - 1);
        }
        unint64_t v38 = (void **)v37;
        if ((*(_DWORD *)(*(void *)v37 + 8) & 0xFE) == 0x12)
        {
          uint64_t v39 = llvm::VPTransformState::get(a2, *(llvm::VPValue **)(*((void *)this + 6) + 8), a3);
          __int16 v55 = 257;
          VectorSplice = llvm::IRBuilderBase::CreateVectorSplice((llvm::IRBuilderBase *)v8, v38, v39, -1, (const llvm::Twine *)&v53);
          uint64_t v41 = a2;
          unsigned int v42 = (char *)this + 96;
        }
        else
        {
          unsigned int v42 = (char *)this + 96;
          uint64_t v41 = a2;
          VectorSplice = (llvm::Instruction *)v38;
        }
        return (uint64_t **)sub_1CD8C9514((uint64_t)v41, v42, (uint64_t)VectorSplice, a3);
      case 'F':
        uint64_t v43 = llvm::VPTransformState::get(a2, **((llvm::VPValue ***)this + 6), a3);
        __int16 v55 = 257;
        uint64_t Intrinsic = (uint64_t)sub_1CC2427E8(v8, (uint64_t)v43, (uint64_t)&v53, v44);
        break;
      case 'G':
        uint64_t v32 = llvm::VPTransformState::get(a2, **((llvm::VPValue ***)this + 6), a3);
        unint64_t v33 = llvm::VPTransformState::get(a2, *(llvm::VPValue **)(*((void *)this + 6) + 8), a3);
        __int16 v55 = 257;
        uint64_t Intrinsic = (uint64_t)sub_1CB845F20(v8, 37, v32, (uint64_t)v33, (uint64_t)&v53);
        break;
      case 'H':
      case 'I':
        __break(1u);
        goto LABEL_57;
      case 'J':
        uint64_t v30 = **((void **)this + 6);
        unsigned int v53 = (const char *)a3;
        char v54 = 0;
        uint64_t v3 = llvm::VPTransformState::get((uint64_t)a2, v30, (unsigned int *)&v53);
        int v4 = llvm::VPTransformState::get(a2, *(llvm::VPValue **)(*((void *)this + 6) + 8), a3);
        uint64_t result = (uint64_t **)(**(void **)(v8 + 64) + 1888);
        uint64_t v12 = *(llvm::Type **)a2;
        if (HIDWORD(*(void *)a2) == 1) {
LABEL_57:
        }
          llvm::ScalableVectorType::get(result, v12);
        else {
          llvm::FixedVectorType::get((llvm::FixedVectorType *)result, v12);
        }
        v57[0] = v31;
        v57[1] = *(void *)v4;
        v56[0] = (uint64_t)v3;
        v56[1] = (uint64_t)v4;
        unsigned int v53 = "active.lane.mask";
        __int16 v55 = 259;
        uint64_t Intrinsic = llvm::IRBuilderBase::CreateIntrinsic((uint64_t *)v8, 153, (uint64_t)v57, 2, v56, 2, 0, (uint64_t)&v53);
        break;
      case 'K':
      case 'L':
        if (a3)
        {
          uint64_t Intrinsic = (uint64_t)llvm::VPTransformState::get(a2, (llvm::VPInstruction *)((char *)this + 96), 0);
        }
        else
        {
          BOOL v21 = v14 == 76;
          unsigned int v22 = (llvm::ConstantInt **)llvm::VPTransformState::get(a2, **((llvm::VPValue ***)this + 6), 0);
          StepForVF = llvm::createStepForVF((llvm::IRBuilderBase *)v8, *v22, *(void *)a2, *((unsigned int *)a2 + 2));
          unsigned int v53 = "index.next";
          __int16 v55 = 259;
          uint64_t Intrinsic = (uint64_t)sub_1CB844A3C(v8, v22, (uint64_t)StepForVF, (uint64_t)&v53, v21, 0);
        }
        break;
      default:
        unsigned int v34 = llvm::VPTransformState::get(a2, **((llvm::VPValue ***)this + 6), a3);
        uint64_t v35 = llvm::VPTransformState::get(a2, *(llvm::VPValue **)(*((void *)this + 6) + 8), a3);
        char v36 = llvm::VPTransformState::get(a2, *(llvm::VPValue **)(*((void *)this + 6) + 16), a3);
        __int16 v55 = 257;
        uint64_t Intrinsic = (uint64_t)llvm::IRBuilderBase::CreateSelect((llvm::IRBuilderBase *)v8, v34, v35, v36, (const llvm::Twine *)&v53, 0);
        break;
    }
  }
  VectorSplice = (llvm::Instruction *)Intrinsic;
  unsigned int v42 = (char *)this + 96;
  uint64_t v41 = a2;
  return (uint64_t **)sub_1CD8C9514((uint64_t)v41, v42, (uint64_t)VectorSplice, a3);
}

void llvm::VPlan::execute(llvm::VPlan *this, llvm::VPTransformState *a2)
{
  uint64_t v4 = *((void *)this + 23);
  uint64_t v5 = *((unsigned int *)this + 50);
  int v6 = (uint64_t *)(v4 + 16 * v5);
  if (*((_DWORD *)this + 48))
  {
    if (v5)
    {
      uint64_t v8 = 16 * v5;
      int v7 = (uint64_t *)*((void *)this + 23);
      while ((*v7 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v7 += 2;
        v8 -= 16;
        if (!v8) {
          goto LABEL_7;
        }
      }
    }
    else
    {
      int v7 = (uint64_t *)*((void *)this + 23);
    }
  }
  else
  {
LABEL_7:
    int v7 = (uint64_t *)(v4 + 16 * v5);
  }
  uint64_t v9 = (uint64_t *)(v4 + 16 * v5);
  while (v7 != v9)
  {
    uint64_t v10 = v7 + 2;
    uint64_t v11 = *v7;
    sub_1CD467E2C((uint64_t)a2 + 280, v7 + 1)[1] = v11;
    int v7 = v6;
    if (v10 != v6)
    {
      int v7 = v10;
      while ((*v7 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v7 += 2;
        if (v7 == v6)
        {
          int v7 = v6;
          break;
        }
      }
    }
  }
  *((void *)a2 + 10) = 0;
  uint64_t SingleSuccessor = llvm::BasicBlock::getSingleSuccessor(*((llvm::BasicBlock **)a2 + 11));
  uint64_t v13 = 0;
  *((void *)a2 + 12) = SingleSuccessor;
  uint64_t v14 = *((void *)a2 + 34);
  uint64_t v122 = *((void *)a2 + 11);
  uint64_t v15 = *(void *)(v122 + 40);
  if (v15) {
    uint64_t v16 = v15 - 24;
  }
  else {
    uint64_t v16 = 0;
  }
  if (*(unsigned __int8 *)(v16 + 16) - 29 >= 0xB) {
    uint64_t v16 = 0;
  }
  *(void *)(v14 + 48) = *(void *)(v16 + 40);
  *(void *)(v14 + 56) = v16 + 24;
  BOOL v17 = *(unsigned __int8 **)(v16 + 48);
  uint64_t v139 = v17;
  if (v17)
  {
    llvm::MetadataTracking::track((uint64_t)&v139, v17, 2);
    uint64_t v13 = (uint64_t)v139;
  }
  sub_1CB8461A4(v14, 0, v13);
  if (v139)
  {
    int v115 = *v139;
    if ((v115 - 4) > 0x1E)
    {
      if ((v115 - 3) >= 0xFFFFFFFE) {
        uint64_t v120 = v139;
      }
      else {
        uint64_t v120 = 0;
      }
      if ((v115 - 3) < 0xFFFFFFFE)
      {
        if (v115 == 3) {
          *((void *)v139 + 1) = 0;
        }
        goto LABEL_23;
      }
      unint64_t v117 = (unint64_t)(v120 + 8);
    }
    else
    {
      if ((v139[1] & 0x7F) != 2 && !*((_DWORD *)v139 + 3)) {
        goto LABEL_23;
      }
      uint64_t v116 = *((void *)v139 + 2);
      if ((v116 & 4) == 0) {
        goto LABEL_23;
      }
      unint64_t v117 = v116 & 0xFFFFFFFFFFFFFFF8;
      if (!v117) {
        goto LABEL_23;
      }
    }
    uint64_t v148 = &v139;
    sub_1CC5FA668(v117 + 16, &v148);
  }
LABEL_23:
  sub_1CD8DBFE4((uint64_t *)this, &v148);
  uint64_t v18 = v144;
  uint64_t v139 = v144;
  BOOL v19 = v149;
  if (v149 == v148)
  {
    BOOL v140 = v144;
    uint64_t v20 = v149;
  }
  else
  {
    unsigned int v118 = v150;
    uint64_t v18 = (unsigned __int8 *)malloc_type_malloc(8 * v150, 0x4065EBACuLL);
    if (!v18)
    {
      if (v118) {
        goto LABEL_236;
      }
      uint64_t v18 = (unsigned __int8 *)malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v18) {
        goto LABEL_236;
      }
    }
    BOOL v140 = v18;
    uint64_t v20 = v148;
    BOOL v19 = v149;
  }
  unsigned int v21 = v151;
  unsigned int v141 = v150;
  if (v19 == v20) {
    unsigned int v22 = v151;
  }
  else {
    unsigned int v22 = v150;
  }
  if (v22)
  {
    memmove(v18, v19, 8 * v22);
    unsigned int v21 = v151;
  }
  unsigned int v142 = v21;
  int v143 = v152;
  int64_t v146 = 0;
  uint64_t v147 = 0;
  __p = 0;
  sub_1CBF340A8(&__p, v153, v154, 0xAAAAAAAAAAAAAAABLL * ((v154 - (unsigned char *)v153) >> 3));
  uint64_t v23 = v135;
  uint64_t v130 = v135;
  uint64_t v24 = v156;
  if (v156 != v155)
  {
    unsigned int v119 = v157;
    uint64_t v23 = malloc_type_malloc(8 * v157, 0x4065EBACuLL);
    if (v23 || !v119 && (uint64_t v23 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) != 0)
    {
      uint64_t v131 = v23;
      int v25 = v155;
      uint64_t v24 = v156;
      goto LABEL_32;
    }
LABEL_236:
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  uint64_t v131 = v135;
  int v25 = v156;
LABEL_32:
  unsigned int v26 = v158;
  unsigned int v132 = v157;
  if (v24 == v25) {
    unsigned int v27 = v158;
  }
  else {
    unsigned int v27 = v157;
  }
  if (v27)
  {
    memmove(v23, v24, 8 * v27);
    unsigned int v26 = v158;
  }
  unsigned int v133 = v26;
  int v134 = v159;
  BOOL v137 = 0;
  uint64_t v138 = 0;
  uint64_t v136 = 0;
  sub_1CBF340A8(&v136, v160, v161, 0xAAAAAAAAAAAAAAABLL * ((v161 - (unsigned char *)v160) >> 3));
  while (1)
  {
    if (v146 - (unsigned char *)__p != v137 - v136) {
      goto LABEL_52;
    }
    if (__p == v146) {
      break;
    }
    uint64_t v28 = v136 + 8;
    uint64_t v29 = (char *)__p + 8;
    while (1)
    {
      uint64_t v30 = v29 - 8;
      if (*((void *)v29 - 1) != *((void *)v28 - 1)) {
        break;
      }
      int v31 = v28[8];
      if (v29[8]) {
        BOOL v32 = v31 == 0;
      }
      else {
        BOOL v32 = 1;
      }
      if (v32)
      {
        if ((v29[8] == 0) == (v31 != 0)) {
          break;
        }
      }
      else if (*(void *)v29 != *(void *)v28)
      {
        break;
      }
      v28 += 24;
      v29 += 24;
      if (v30 + 24 == v146) {
        goto LABEL_53;
      }
    }
LABEL_52:
    (*(void (**)(void, llvm::VPTransformState *))(**((void **)v146 - 3) + 16))(*((void *)v146 - 3), a2);
    sub_1CD8DC09C((char *)&v139);
  }
LABEL_53:
  if (v136)
  {
    BOOL v137 = v136;
    operator delete(v136);
  }
  if (v131 != v130) {
    free(v131);
  }
  if (__p)
  {
    int64_t v146 = (char *)__p;
    operator delete(__p);
  }
  if (v140 != v139) {
    free(v140);
  }
  if (v160)
  {
    int v161 = v160;
    operator delete(v160);
  }
  if (v156 != v155) {
    free(v156);
  }
  if (v153)
  {
    BOOL v154 = v153;
    operator delete(v153);
  }
  if (v149 != v148) {
    free(v149);
  }
  uint64_t v33 = *((unsigned int *)a2 + 46);
  if (v33)
  {
    unsigned int v34 = (unsigned __int8 ***)*((void *)a2 + 22);
    uint64_t v35 = &v34[v33];
    do
    {
      uint64_t v148 = *v34;
      uint64_t v36 = sub_1CD645138((_DWORD *)a2 + 26, &v148)[1];
      uint64_t v37 = *(void *)(v36 + 40);
      if (v37 == v36 + 40)
      {
        uint64_t v38 = 0;
      }
      else
      {
        if (v37) {
          uint64_t v39 = v37 - 24;
        }
        else {
          uint64_t v39 = 0;
        }
        if (*(unsigned __int8 *)(v39 + 16) - 29 >= 0xB) {
          uint64_t v38 = 0;
        }
        else {
          uint64_t v38 = v39;
        }
      }
      unint64_t v40 = v148;
      while (1)
      {
        uint64_t v41 = *((unsigned int *)v40 + 20);
        if (v41) {
          break;
        }
        unint64_t v40 = (unsigned __int8 **)v40[5];
        if (!v40) {
          goto LABEL_91;
        }
      }
      unsigned int v42 = 0;
      uint64_t v43 = (unsigned __int8 **)v40[9];
      unint64_t v44 = &v43[v41];
      do
      {
        for (uint64_t i = *v43; i && i[8] == 1; uint64_t i = (unsigned __int8 *)*((void *)i + 25))
          ;
        uint64_t v139 = i;
        unsigned int v47 = sub_1CD645138((_DWORD *)a2 + 26, &v139);
        llvm::Instruction::setSuccessor(v38, v42++, (llvm::BasicBlock *)v47[1]);
        ++v43;
      }
      while (v43 != v44);
LABEL_91:
      ++v34;
    }
    while (v34 != v35);
  }
  uint64_t v48 = *(void *)this;
  if (*(void *)this && *(unsigned char *)(v48 + 8) == 1)
  {
    do
    {
LABEL_96:
      uint64_t v48 = *(void *)(v48 + 208);
      if (v48) {
        BOOL v49 = *(unsigned char *)(v48 + 8) == 1;
      }
      else {
        BOOL v49 = 0;
      }
    }
    while (v49);
  }
  else if (*(_DWORD *)(v48 + 80) == 1)
  {
    uint64_t v48 = **(void **)(v48 + 72);
    if (*(unsigned char *)(v48 + 8) == 1) {
      goto LABEL_96;
    }
  }
  else
  {
    uint64_t v48 = 0;
  }
  uint64_t v148 = (unsigned __int8 **)v48;
  int64_t v121 = (_DWORD *)((char *)a2 + 104);
  uint64_t v50 = sub_1CD645138((_DWORD *)a2 + 26, &v148)[1];
  uint64_t v51 = *(unsigned __int8 **)this;
  if (*(void *)this) {
    BOOL v52 = *(unsigned char *)(*(void *)this + 8) == 1;
  }
  else {
    BOOL v52 = 0;
  }
  if (v52)
  {
    do
    {
LABEL_108:
      uint64_t v51 = (unsigned __int8 *)*((void *)v51 + 25);
      if (v51) {
        BOOL v53 = v51[8] == 1;
      }
      else {
        BOOL v53 = 0;
      }
    }
    while (v53);
  }
  else if (*((_DWORD *)v51 + 20) == 1)
  {
    uint64_t v51 = (unsigned __int8 *)**((void **)v51 + 9);
    if (v51[8] == 1) {
      goto LABEL_108;
    }
  }
  else
  {
    uint64_t v51 = 0;
  }
  uint64_t v139 = v51;
  char v54 = v51 + 200;
  uint64_t v55 = *((void *)v51 + 26);
  if ((unsigned __int8 *)v55 != v51 + 200)
  {
    uint64_t v56 = (unsigned __int8 *)*((void *)v51 + 26);
    while (1)
    {
      unsigned int v57 = v56 - 24;
      if (!v56) {
        unsigned int v57 = 0;
      }
      if (v57[8] - 13 > 7) {
        break;
      }
      uint64_t v56 = (unsigned __int8 *)*((void *)v56 + 1);
      if (v56 == v54)
      {
        uint64_t v56 = v54;
        break;
      }
    }
    if ((unsigned __int8 *)v55 != v56)
    {
      signed int v123 = v56;
      uint64_t v124 = v50;
      uint64_t v125 = a2;
      do
      {
        if (v55) {
          uint64_t v58 = v55 - 24;
        }
        else {
          uint64_t v58 = 0;
        }
        int v59 = 1;
        int v129 = 1;
        switch(*(unsigned char *)(v58 + 8))
        {
          case 0xE:
          case 0xF:
            goto LABEL_145;
          case 0x10:
            goto LABEL_204;
          case 0x11:
            uint64_t v60 = *(void *)(v58 + 16);
            uint64_t v61 = (llvm::VPValue *)(v60 & 0xFFFFFFFFFFFFFFF8);
            if ((v60 & 4) != 0) {
              uint64_t v61 = **(llvm::VPValue ***)v61;
            }
            unsigned int v62 = llvm::VPTransformState::get(a2, v61, 0);
            goto LABEL_186;
          case 0x12:
            uint64_t v63 = *(unsigned int *)(v58 + 120);
            if (!v63) {
              goto LABEL_204;
            }
            uint64_t v64 = *(void **)(v58 + 112);
            if (v55) {
              uint64_t v65 = (llvm::VPValue *)(v58 + 96);
            }
            else {
              uint64_t v65 = 0;
            }
            uint64_t v66 = 8 * v63;
            break;
          default:
            if (*(unsigned char *)(v58 + 161))
            {
              int v59 = 1;
              int v129 = 1;
            }
            else
            {
              int v59 = *((_DWORD *)a2 + 2);
              if (!v59) {
                goto LABEL_204;
              }
              int v129 = 0;
            }
LABEL_145:
            unsigned int v68 = 0;
            if (v55) {
              BOOL v69 = (llvm::VPValue *)(v58 + 96);
            }
            else {
              BOOL v69 = 0;
            }
            uint64_t v127 = v58;
            uint64_t v128 = v55;
            int v126 = v59;
            do
            {
              int v70 = llvm::VPTransformState::get(a2, v69, v68);
              unsigned int v71 = v68;
              if (v129) {
                unsigned int v71 = *((_DWORD *)a2 + 2) - 1;
              }
              uint64_t v72 = llvm::VPTransformState::get(a2, *(llvm::VPValue **)(*(void *)(v58 + 48) + 8), v71);
              int v73 = *((_DWORD *)v70 + 5);
              uint64_t v74 = v73 & 0x7FFFFFF;
              if ((v73 & 0x7FFFFFF) == *((_DWORD *)v70 + 15))
              {
                unsigned int v87 = v74 + (v74 >> 1);
                if (v87 <= 2) {
                  uint64_t v88 = 2;
                }
                else {
                  uint64_t v88 = v87;
                }
                *((_DWORD *)v70 + 15) = v88;
                if ((v73 & 0x40000000) != 0) {
                  uint64_t v89 = (uint64_t *)*((void *)v70 - 1);
                }
                else {
                  uint64_t v89 = (uint64_t *)((char *)v70 - 32 * v74);
                }
                int v90 = operator new(40 * v88);
                *((void *)v70 - 1) = v90;
                uint64_t v91 = v90;
                do
                {
                  *uint64_t v91 = 0;
                  v91[1] = 0;
                  v91[2] = 0;
                  v91[3] = v70;
                  v91 += 4;
                }
                while (v91 != &v90[4 * v88]);
                int v92 = *((_DWORD *)v70 + 5);
                if ((v92 & 0x40000000) != 0) {
                  uint64_t v93 = (uint64_t)v90;
                }
                else {
                  uint64_t v93 = (uint64_t)v70 - 32 * (v92 & 0x7FFFFFF);
                }
                sub_1CC5E4108((uint64_t)&v130, v89, &v89[4 * v74], v93);
                if (v74)
                {
                  memmove((void *)(v93 + 32 * v88), &v89[4 * v74], 8 * v74);
                  uint64_t v94 = 4 * v74;
                  do
                  {
                    int v95 = &v89[v94];
                    if (v89[v94 - 4])
                    {
                      *(void *)*(v95 - 2) = *(v95 - 3);
                      uint64_t v96 = *(v95 - 3);
                      if (v96) {
                        *(void *)(v96 + 16) = *(v95 - 2);
                      }
                    }
                    v94 -= 4;
                  }
                  while (v94 * 8);
                }
                operator delete(v89);
                int v73 = *((_DWORD *)v70 + 5);
                uint64_t v50 = v124;
                a2 = v125;
                uint64_t v58 = v127;
                uint64_t v55 = v128;
                int v59 = v126;
              }
              uint64_t v75 = (v73 + 1) & 0x7FFFFFF;
              *((_DWORD *)v70 + 5) = v73 & 0xF8000000 | (v73 + 1) & 0x7FFFFFF;
              if ((v73 & 0x40000000) != 0) {
                __int16 v76 = (char *)*((void *)v70 - 1);
              }
              else {
                __int16 v76 = (char *)v70 - 32 * v75;
              }
              uint64_t v77 = (v75 - 1);
              uint64_t v78 = &v76[32 * v77];
              if (*(void *)v78)
              {
                **((void **)v78 + 2) = *((void *)v78 + 1);
                uint64_t v86 = *((void *)v78 + 1);
                if (v86) {
                  *(void *)(v86 + 16) = *((void *)v78 + 2);
                }
              }
              *(void *)uint64_t v78 = v72;
              if (v72)
              {
                uint64_t v81 = *((void *)v72 + 1);
                unsigned int v80 = (char **)((char *)v72 + 8);
                uint64_t v79 = v81;
                int v82 = &v76[32 * v77];
                *((void *)v82 + 1) = v81;
                if (v81) {
                  *(void *)(v79 + 16) = v82 + 8;
                }
                *((void *)v82 + 2) = v80;
                *unsigned int v80 = v78;
              }
              int v83 = *((_DWORD *)v70 + 5);
              uint64_t v84 = v83 & 0x7FFFFFF;
              if ((v83 & 0x40000000) != 0) {
                BOOL v85 = (char *)*((void *)v70 - 1);
              }
              else {
                BOOL v85 = (char *)v70 - 32 * v84;
              }
              *(void *)&v85[32 * *((unsigned int *)v70 + 15) + 8 * (v84 - 1)] = v50;
              ++v68;
            }
            while (v68 != v59);
            goto LABEL_204;
        }
        while (1)
        {
          uint64_t v67 = *v64 ? *v64 - 40 : 0;
          if (((*(uint64_t (**)(uint64_t, llvm::VPValue *))(*(void *)v67 + 40))(v67, v65) & 1) == 0) {
            break;
          }
          ++v64;
          v66 -= 8;
          if (!v66) {
            goto LABEL_204;
          }
        }
        uint64_t v97 = llvm::VPTransformState::get(a2, v65, 0);
        unsigned int v62 = (llvm::Instruction *)*((void *)v97 - 4 * (*((_DWORD *)v97 + 5) & 0x7FFFFFF));
LABEL_186:
        int v98 = *((_DWORD *)v62 + 5);
        if ((v98 & 0x40000000) != 0) {
          uint64_t v99 = (char *)*((void *)v62 - 1);
        }
        else {
          uint64_t v99 = (char *)v62 - 32 * (v98 & 0x7FFFFFF);
        }
        *(void *)&v99[32 * *((unsigned int *)v62 + 15) + 8] = v50;
        int v100 = *((_DWORD *)v62 + 5);
        if ((v100 & 0x40000000) != 0) {
          uint64_t v101 = (char *)*((void *)v62 - 1);
        }
        else {
          uint64_t v101 = (char *)v62 - 32 * (v100 & 0x7FFFFFF);
        }
        int v102 = (llvm::Instruction *)*((void *)v101 + 4);
        uint64_t v103 = *(void *)(v50 + 40);
        if (v103) {
          uint64_t v104 = v103 - 24;
        }
        else {
          uint64_t v104 = 0;
        }
        if (*(unsigned __int8 *)(v104 + 16) - 29 >= 0xB) {
          uint64_t v105 = 0;
        }
        else {
          uint64_t v105 = v104;
        }
        if (*(void *)(*(void *)(v105 + 40) + 48) == v105 + 24)
        {
          int v107 = 0;
        }
        else
        {
          uint64_t v106 = *(void *)(v105 + 24);
          if (v106) {
            int v107 = (llvm::Instruction *)(v106 - 24);
          }
          else {
            int v107 = 0;
          }
        }
        llvm::Instruction::moveBefore(v102, v107);
LABEL_204:
        uint64_t v55 = *(void *)(v55 + 8);
      }
      while ((unsigned __int8 *)v55 != v123);
    }
  }
  if (!byte_1EBD0DAB0)
  {
    sub_1CD645138(v121, &v139);
    uint64_t v108 = *((void *)a2 + 33);
    uint64_t v109 = *(void *)(v108 + 24);
    int v110 = *(_DWORD *)(v108 + 40);
    if (v110)
    {
      unsigned int v111 = (v110 - 1) & ((v122 >> 4) ^ (v122 >> 9));
      uint64_t v112 = *(void *)(v109 + 16 * v111);
      if (v112 != v122)
      {
        int v113 = 1;
        do
        {
          if (v112 == -4096) {
            break;
          }
          unsigned int v114 = v111 + v113++;
          unsigned int v111 = v114 & (v110 - 1);
          uint64_t v112 = *(void *)(v109 + 16 * v111);
        }
        while (v112 != v122);
      }
    }
    *(unsigned char *)(v108 + 64) = 0;
    llvm::DominatorTreeBase<llvm::BasicBlock,false>::createChild();
  }
}

llvm::raw_ostream *llvm::VPlanPrinter::dump(llvm::VPlanPrinter *this)
{
  *((_DWORD *)this + 4) = 1;
  sub_1CD8EA564((uint64_t)this, 0);
  uint64_t v2 = *(llvm::raw_ostream **)this;
  uint64_t v3 = *(_OWORD **)(*(void *)this + 32);
  if (*(void *)(*(void *)this + 24) - (void)v3 > 0xFuLL)
  {
    *uint64_t v3 = *(_OWORD *)"digraph VPlan {\n";
    *((void *)v2 + 4) += 16;
  }
  else
  {
    llvm::raw_ostream::write(v2, "digraph VPlan {\n", 0x10uLL);
  }
  uint64_t v4 = *(llvm::raw_ostream **)this;
  uint64_t v5 = *(void **)(*(void *)this + 32);
  if (*(void *)(*(void *)this + 24) - (void)v5 > 0x38uLL)
  {
    qmemcpy(v5, "graph [labelloc=t, fontsize=30; label=\"Vectorization Plan", 57);
    *((void *)v4 + 4) += 57;
  }
  else
  {
    llvm::raw_ostream::write(v4, "graph [labelloc=t, fontsize=30; label=\"Vectorization Plan", 0x39uLL);
  }
  uint64_t v6 = *((void *)this + 1);
  if (*(char *)(v6 + 87) < 0)
  {
    if (!*(void *)(v6 + 72)) {
      goto LABEL_20;
    }
  }
  else if (!*(unsigned char *)(v6 + 87))
  {
    goto LABEL_20;
  }
  int v7 = *(llvm::raw_ostream **)this;
  uint64_t v8 = *(_WORD **)(*(void *)this + 32);
  if (*(void *)(*(void *)this + 24) - (void)v8 > 1uLL)
  {
    *uint64_t v8 = 28252;
    *((void *)v7 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(*(llvm::raw_ostream **)this, "\\n", 2uLL);
  }
  llvm::DOT::EscapeString((char *)(*((void *)this + 1) + 64), (uint64_t)&__p);
  if (v58 >= 0) {
    p_p = (const char *)&__p;
  }
  else {
    p_p = (const char *)__p;
  }
  if (v58 >= 0) {
    size_t v10 = HIBYTE(v58) & 0x7F;
  }
  else {
    size_t v10 = (size_t)v56;
  }
  llvm::raw_ostream::write(v7, p_p, v10);
  if (SHIBYTE(v58) < 0) {
    operator delete(__p);
  }
  uint64_t v6 = *((void *)this + 1);
LABEL_20:
  if (*(void *)(v6 + 120))
  {
    uint64_t v11 = *(llvm::raw_ostream **)this;
    uint64_t v12 = *(void *)(*(void *)this + 32);
    if ((unint64_t)(*(void *)(*(void *)this + 24) - v12) > 9)
    {
      *(_WORD *)(v12 + 8) = 28252;
      *(void *)uint64_t v12 = *(void *)", where:\\n";
      *((void *)v11 + 4) += 10;
    }
    else
    {
      llvm::raw_ostream::write(v11, ", where:\\n", 0xAuLL);
    }
    llvm::VPValue::print(*(llvm::VPValue **)(*((void *)this + 1) + 120), *(llvm::raw_ostream **)this, (llvm::VPlanPrinter *)((char *)this + 128));
    uint64_t v13 = *(llvm::raw_ostream **)this;
    uint64_t v14 = *(void **)(*(void *)this + 32);
    if (*(void *)(*(void *)this + 24) - (void)v14 > 0x15uLL)
    {
      qmemcpy(v14, " := BackedgeTakenCount", 22);
      *((void *)v13 + 4) += 22;
    }
    else
    {
      llvm::raw_ostream::write(v13, " := BackedgeTakenCount", 0x16uLL);
    }
  }
  uint64_t v15 = *(llvm::raw_ostream **)this;
  uint64_t v16 = *(void *)(*(void *)this + 32);
  if ((unint64_t)(*(void *)(*(void *)this + 24) - v16) > 2)
  {
    *(unsigned char *)(v16 + 2) = 10;
    *(_WORD *)uint64_t v16 = 23842;
    *((void *)v15 + 4) += 3;
  }
  else
  {
    llvm::raw_ostream::write(v15, "\"]\n", 3uLL);
  }
  BOOL v17 = *(llvm::raw_ostream **)this;
  uint64_t v18 = *(void **)(*(void *)this + 32);
  if (*(void *)(*(void *)this + 24) - (void)v18 > 0x30uLL)
  {
    qmemcpy(v18, "node [shape=rect, fontname=Courier, fontsize=30]\n", 49);
    *((void *)v17 + 4) += 49;
  }
  else
  {
    llvm::raw_ostream::write(v17, "node [shape=rect, fontname=Courier, fontsize=30]\n", 0x31uLL);
  }
  BOOL v19 = *(llvm::raw_ostream **)this;
  uint64_t v20 = *(void **)(*(void *)this + 32);
  if (*(void *)(*(void *)this + 24) - (void)v20 > 0x24uLL)
  {
    qmemcpy(v20, "edge [fontname=Courier, fontsize=30]\n", 37);
    *((void *)v19 + 4) += 37;
  }
  else
  {
    llvm::raw_ostream::write(v19, "edge [fontname=Courier, fontsize=30]\n", 0x25uLL);
  }
  unsigned int v21 = *(llvm::raw_ostream **)this;
  unsigned int v22 = *(void **)(*(void *)this + 32);
  if (*(void *)(*(void *)this + 24) - (void)v22 > 0xDuLL)
  {
    qmemcpy(v22, "compound=true\n", 14);
    *((void *)v21 + 4) += 14;
  }
  else
  {
    llvm::raw_ostream::write(v21, "compound=true\n", 0xEuLL);
  }
  sub_1CD8EA2C0(&__p, **((void **)this + 1));
  uint64_t v23 = v51;
  unint64_t v46 = v51;
  uint64_t v24 = v56;
  if (v56 == __p)
  {
    unsigned int v47 = v51;
    int v25 = v56;
  }
  else
  {
    unsigned int v39 = v57;
    uint64_t v23 = malloc_type_malloc(8 * v57, 0x4065EBACuLL);
    if (!v23)
    {
      if (v39) {
        goto LABEL_100;
      }
      uint64_t v23 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v23) {
        goto LABEL_100;
      }
    }
    unsigned int v47 = v23;
    int v25 = __p;
    uint64_t v24 = v56;
  }
  int v26 = v58;
  unsigned int v48 = v57;
  if (v24 == v25) {
    unsigned int v27 = v58;
  }
  else {
    unsigned int v27 = v57;
  }
  if (v27)
  {
    memmove(v23, v24, 8 * v27);
    int v26 = v58;
  }
  int v49 = v26;
  int v50 = v59;
  BOOL v53 = 0;
  uint64_t v54 = 0;
  BOOL v52 = 0;
  sub_1CBF340A8(&v52, v60, v61, 0xAAAAAAAAAAAAAAABLL * ((v61 - (unsigned char *)v60) >> 3));
  uint64_t v28 = v42;
  uint64_t v29 = v63;
  if (v63 != v62)
  {
    unsigned int v40 = v64;
    uint64_t v28 = malloc_type_malloc(8 * v64, 0x4065EBACuLL);
    if (v28 || !v40 && (uint64_t v28 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) != 0)
    {
      uint64_t v41 = v28;
      uint64_t v30 = v62;
      uint64_t v29 = v63;
      goto LABEL_42;
    }
LABEL_100:
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  uint64_t v41 = v42;
  uint64_t v30 = v63;
LABEL_42:
  if (v29 == v30) {
    unsigned int v31 = v65;
  }
  else {
    unsigned int v31 = v64;
  }
  if (v31) {
    memmove(v28, v29, 8 * v31);
  }
  unint64_t v44 = 0;
  uint64_t v45 = 0;
  uint64_t v43 = 0;
  sub_1CBF340A8(&v43, v66, v67, 0xAAAAAAAAAAAAAAABLL * ((v67 - (unsigned char *)v66) >> 3));
  while (1)
  {
    if ((char *)v53 - (unsigned char *)v52 != v44 - v43) {
      goto LABEL_62;
    }
    if (v52 == v53) {
      break;
    }
    BOOL v32 = v43 + 8;
    uint64_t v33 = (char *)v52 + 8;
    while (1)
    {
      unsigned int v34 = v33 - 8;
      if (*((void *)v33 - 1) != *((void *)v32 - 1)) {
        break;
      }
      int v35 = v32[8];
      if (v33[8]) {
        BOOL v36 = v35 == 0;
      }
      else {
        BOOL v36 = 1;
      }
      if (v36)
      {
        if ((v33[8] == 0) == (v35 != 0)) {
          break;
        }
      }
      else if (*(void *)v33 != *(void *)v32)
      {
        break;
      }
      v32 += 24;
      v33 += 24;
      if (v34 + 24 == (char *)v53) {
        goto LABEL_63;
      }
    }
LABEL_62:
    llvm::VPlanPrinter::dumpBlock(this, *(v53 - 3));
    sub_1CD8DC09C((char *)&v46);
  }
LABEL_63:
  if (v43)
  {
    unint64_t v44 = v43;
    operator delete(v43);
  }
  if (v41 != v42) {
    free(v41);
  }
  if (v52)
  {
    BOOL v53 = (const llvm::VPBlockBase **)v52;
    operator delete(v52);
  }
  if (v47 != v46) {
    free(v47);
  }
  if (v66)
  {
    uint64_t v67 = v66;
    operator delete(v66);
  }
  if (v63 != v62) {
    free(v63);
  }
  if (v60)
  {
    uint64_t v61 = v60;
    operator delete(v60);
  }
  if (v56 != __p) {
    free(v56);
  }
  uint64_t result = *(llvm::raw_ostream **)this;
  uint64_t v38 = *(_WORD **)(*(void *)this + 32);
  if (*(void *)(*(void *)this + 24) - (void)v38 <= 1uLL) {
    return llvm::raw_ostream::write(result, "}\n", 2uLL);
  }
  _WORD *v38 = 2685;
  *((void *)result + 4) += 2;
  return result;
}

uint64_t llvm::VPlanPrinter::getOrCreateName@<X0>(uint64_t this@<X0>, const llvm::VPBlockBase *a2@<X1>, uint64_t a3@<X8>)
{
  if (*((char *)a2 + 39) < 0)
  {
    if (*((void *)a2 + 3)) {
      goto LABEL_3;
    }
LABEL_6:
    this = sub_1CD8EA4E8(this, (uint64_t)a2);
    *(void *)(a3 + 16) = this;
    char v5 = 8;
    char v6 = 3;
    uint64_t v4 = "VPB";
    goto LABEL_4;
  }
  if (!*((unsigned char *)a2 + 39)) {
    goto LABEL_6;
  }
LABEL_3:
  uint64_t v4 = (char *)a2 + 16;
  char v5 = 1;
  char v6 = 4;
LABEL_4:
  *(void *)a3 = v4;
  *(unsigned char *)(a3 + 32) = v6;
  *(unsigned char *)(a3 + 33) = v5;
  return this;
}

llvm::raw_ostream *llvm::VPlanPrinter::drawEdge(uint64_t a1, const llvm::VPBlockBase *a2, const llvm::VPBlockBase *a3, int a4, uint64_t a5)
{
  size_t v10 = a2;
  if (a2)
  {
    size_t v10 = a2;
    if (*((unsigned char *)a2 + 8) == 1)
    {
      size_t v10 = a2;
      do
      {
        size_t v10 = (const llvm::VPBlockBase *)*((void *)v10 + 26);
        if (v10) {
          BOOL v11 = *((unsigned char *)v10 + 8) == 1;
        }
        else {
          BOOL v11 = 0;
        }
      }
      while (v11);
    }
  }
  uint64_t v12 = a3;
  if (a3)
  {
    uint64_t v12 = a3;
    if (*((unsigned char *)a3 + 8) == 1)
    {
      uint64_t v12 = a3;
      do
      {
        uint64_t v12 = (const llvm::VPBlockBase *)*((void *)v12 + 25);
        if (v12) {
          BOOL v13 = *((unsigned char *)v12 + 8) == 1;
        }
        else {
          BOOL v13 = 0;
        }
      }
      while (v13);
    }
  }
  uint64_t v14 = *(llvm::raw_ostream **)a1;
  char v15 = *(unsigned char *)(a1 + 47);
  int v16 = v15;
  if (v15 >= 0) {
    BOOL v17 = (const char *)(a1 + 24);
  }
  else {
    BOOL v17 = *(const char **)(a1 + 24);
  }
  size_t v18 = v15 & 0x7F;
  if (v16 >= 0) {
    size_t v19 = v18;
  }
  else {
    size_t v19 = *(void *)(a1 + 32);
  }
  llvm::raw_ostream::write(*(llvm::raw_ostream **)a1, v17, v19);
  UID = llvm::VPlanPrinter::getUID((llvm::VPlanPrinter *)a1, v10, (uint64_t)&v45);
  unsigned int v21 = llvm::Twine::printOneChild((llvm::raw_ostream *)UID, v14, v45, v46, v49);
  llvm::Twine::printOneChild(v21, v14, v47, v48, v50);
  unsigned int v22 = (_DWORD *)*((void *)v14 + 4);
  if (*((void *)v14 + 3) - (void)v22 > 3uLL)
  {
    *unsigned int v22 = 540945696;
    *((void *)v14 + 4) += 4;
  }
  else
  {
    llvm::raw_ostream::write(v14, " -> ", 4uLL);
  }
  uint64_t v23 = llvm::VPlanPrinter::getUID((llvm::VPlanPrinter *)a1, v12, (uint64_t)v42);
  uint64_t v24 = llvm::Twine::printOneChild((llvm::raw_ostream *)v23, v14, v42[0], v42[1], v43);
  int v25 = llvm::Twine::printOneChild(v24, v14, v42[2], v42[3], v44);
  int v26 = *(llvm::raw_ostream **)a1;
  uint64_t v27 = *(void *)(*(void *)a1 + 32);
  if ((unint64_t)(*(void *)(*(void *)a1 + 24) - v27) > 9)
  {
    *(_WORD *)(v27 + 8) = 8765;
    *(void *)uint64_t v27 = *(void *)" [ label=\"";
    *((void *)v26 + 4) += 10;
  }
  else
  {
    int v25 = llvm::raw_ostream::write(*(llvm::raw_ostream **)a1, " [ label=\"", 0xAuLL);
  }
  uint64_t v28 = llvm::Twine::printOneChild(v25, v26, *(void *)a5, *(void *)(a5 + 8), *(unsigned char *)(a5 + 32));
  llvm::Twine::printOneChild(v28, v26, *(void *)(a5 + 16), *(void *)(a5 + 24), *(unsigned char *)(a5 + 33));
  uint64_t v29 = (unsigned char *)*((void *)v26 + 4);
  if ((unint64_t)v29 >= *((void *)v26 + 3))
  {
    llvm::raw_ostream::write(v26, 34);
  }
  else
  {
    *((void *)v26 + 4) = v29 + 1;
    unsigned char *v29 = 34;
  }
  if (v10 != a2)
  {
    unsigned int v34 = *(llvm::raw_ostream **)a1;
    int v35 = *(_DWORD **)(*(void *)a1 + 32);
    if (*(void *)(*(void *)a1 + 24) - (void)v35 > 6uLL)
    {
      *(_DWORD *)((char *)v35 + 3) = 1030515041;
      _DWORD *v35 = 1635019808;
      *((void *)v34 + 4) += 7;
    }
    else
    {
      llvm::raw_ostream::write(*(llvm::raw_ostream **)a1, " ltail=", 7uLL);
    }
    BOOL v36 = llvm::VPlanPrinter::getUID((llvm::VPlanPrinter *)a1, a2, (uint64_t)&v45);
    uint64_t v37 = llvm::Twine::printOneChild((llvm::raw_ostream *)v36, v34, v45, v46, v49);
    llvm::Twine::printOneChild(v37, v34, v47, v48, v50);
  }
  if (v12 == a3)
  {
    if (a4)
    {
LABEL_31:
      uint64_t v30 = *(llvm::raw_ostream **)a1;
      unsigned int v31 = *(void **)(*(void *)a1 + 32);
      if (*(void *)(*(void *)a1 + 24) - (void)v31 > 0xDuLL)
      {
        qmemcpy(v31, "; splines=none", 14);
        *((void *)v30 + 4) += 14;
      }
      else
      {
        llvm::raw_ostream::write(v30, "; splines=none", 0xEuLL);
      }
    }
  }
  else
  {
    uint64_t v38 = *(llvm::raw_ostream **)a1;
    unsigned int v39 = *(_DWORD **)(*(void *)a1 + 32);
    if (*(void *)(*(void *)a1 + 24) - (void)v39 > 6uLL)
    {
      *(_DWORD *)((char *)v39 + 3) = 1029988709;
      *unsigned int v39 = 1701342240;
      *((void *)v38 + 4) += 7;
    }
    else
    {
      llvm::raw_ostream::write(*(llvm::raw_ostream **)a1, " lhead=", 7uLL);
    }
    unsigned int v40 = llvm::VPlanPrinter::getUID((llvm::VPlanPrinter *)a1, a3, (uint64_t)&v45);
    uint64_t v41 = llvm::Twine::printOneChild((llvm::raw_ostream *)v40, v38, v45, v46, v49);
    llvm::Twine::printOneChild(v41, v38, v47, v48, v50);
    if (a4) {
      goto LABEL_31;
    }
  }
  uint64_t result = *(llvm::raw_ostream **)a1;
  uint64_t v33 = *(_WORD **)(*(void *)a1 + 32);
  if (*(void *)(*(void *)a1 + 24) - (void)v33 <= 1uLL) {
    return llvm::raw_ostream::write(result, "]\n", 2uLL);
  }
  _WORD *v33 = 2653;
  *((void *)result + 4) += 2;
  return result;
}

void sub_1CD354FCC(uint64_t a1, const void *a2, size_t a3, const void *a4, size_t a5)
{
  uint64_t v9 = *(llvm::raw_ostream **)a1;
  char v10 = *(unsigned char *)(a1 + 47);
  int v11 = v10;
  size_t v12 = *(void *)(a1 + 32);
  char v15 = *(const char **)(a1 + 24);
  BOOL v13 = (const char *)(a1 + 24);
  uint64_t v14 = v15;
  if (v10 >= 0) {
    int v16 = v13;
  }
  else {
    int v16 = v14;
  }
  size_t v17 = v10 & 0x7F;
  if (v11 >= 0) {
    size_t v18 = v17;
  }
  else {
    size_t v18 = v12;
  }
  llvm::raw_ostream::write(v9, v16, v18);
  size_t v19 = (unsigned char *)*((void *)v9 + 4);
  if ((unint64_t)v19 < *((void *)v9 + 3))
  {
    *((void *)v9 + 4) = v19 + 1;
    *size_t v19 = 34;
    if (a2) {
      goto LABEL_9;
    }
LABEL_14:
    uint64_t v27 = 0;
    size_t v28 = 0;
    unint64_t v29 = 0;
    goto LABEL_20;
  }
  llvm::raw_ostream::write(v9, 34);
  if (!a2) {
    goto LABEL_14;
  }
LABEL_9:
  if (a3 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (a3 >= 0x17)
  {
    uint64_t v21 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a3 | 7) != 0x17) {
      uint64_t v21 = a3 | 7;
    }
    uint64_t v22 = v21 + 1;
    uint64_t v20 = operator new(v21 + 1);
    size_t v28 = a3;
    unint64_t v29 = v22 | 0x8000000000000000;
    uint64_t v27 = v20;
  }
  else
  {
    HIBYTE(v29) = a3;
    uint64_t v20 = &v27;
    if (!a3) {
      goto LABEL_19;
    }
  }
  memmove(v20, a2, a3);
LABEL_19:
  *((unsigned char *)v20 + a3) = 0;
LABEL_20:
  llvm::DOT::EscapeString((char *)&v27, (uint64_t)__p);
  if (v31 >= 0) {
    uint64_t v23 = __p;
  }
  else {
    uint64_t v23 = (void **)__p[0];
  }
  if (v31 >= 0) {
    size_t v24 = v31 & 0x7F;
  }
  else {
    size_t v24 = (size_t)__p[1];
  }
  llvm::raw_ostream::write(v9, (const char *)v23, v24);
  uint64_t v25 = *((void *)v9 + 4);
  if ((unint64_t)(*((void *)v9 + 3) - v25) > 2)
  {
    *(unsigned char *)(v25 + 2) = 34;
    *(_WORD *)uint64_t v25 = 27740;
    int v26 = (void *)(*((void *)v9 + 4) + 3);
    *((void *)v9 + 4) = v26;
  }
  else
  {
    llvm::raw_ostream::write(v9, "\\l\"", 3uLL);
    int v26 = (void *)*((void *)v9 + 4);
  }
  if (a5 <= *((void *)v9 + 3) - (void)v26)
  {
    if (a5)
    {
      memcpy(v26, a4, a5);
      *((void *)v9 + 4) += a5;
    }
  }
  else
  {
    llvm::raw_ostream::write(v9, (const char *)a4, a5);
  }
  if (v31 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v29) < 0) {
    operator delete(v27);
  }
}

unsigned char *llvm::VPlanIngredient::print(llvm::Value **this, llvm::raw_ostream *a2)
{
  uint64_t v3 = *this;
  if (*this) {
    BOOL v4 = *((unsigned __int8 *)*this + 16) >= 0x1Cu;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4)
  {
    if (*(unsigned char *)(*(void *)v3 + 8) != 7)
    {
      llvm::Value::printAsOperand(*this, a2, 0, 0);
      uint64_t v11 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v11) > 2)
      {
        *(unsigned char *)(v11 + 2) = 32;
        *(_WORD *)uint64_t v11 = 15648;
        *((void *)a2 + 4) += 3;
      }
      else
      {
        llvm::raw_ostream::write(a2, " = ", 3uLL);
      }
    }
    OpcodeName = llvm::Instruction::getOpcodeName((llvm::Instruction *)(*((unsigned __int8 *)v3 + 16) - 28));
    unint64_t v6 = strlen(OpcodeName);
    uint64_t result = (unsigned char *)*((void *)a2 + 4);
    if (v6 <= *((void *)a2 + 3) - (void)result)
    {
      if (v6)
      {
        memcpy(result, OpcodeName, v6);
        uint64_t result = (unsigned char *)(*((void *)a2 + 4) + v6);
        *((void *)a2 + 4) = result;
      }
    }
    else
    {
      llvm::raw_ostream::write(a2, OpcodeName, v6);
      uint64_t result = (unsigned char *)*((void *)a2 + 4);
    }
    if (*((unsigned char **)a2 + 3) == result)
    {
      uint64_t result = llvm::raw_ostream::write(a2, " ", 1uLL);
    }
    else
    {
      *uint64_t result = 32;
      ++*((void *)a2 + 4);
    }
    int v8 = *((_DWORD *)v3 + 5);
    uint64_t v9 = v8 & 0x7FFFFFF;
    if ((v8 & 0x7FFFFFF) != 0)
    {
      size_t v12 = (v8 & 0x40000000) != 0 ? (llvm::Value **)*((void *)v3 - 1) : (llvm::Value **)((char *)v3 - 32 * v9);
      uint64_t result = (unsigned char *)llvm::Value::printAsOperand(*v12, a2, 0, 0);
      if (v9 >= 2)
      {
        uint64_t v13 = 32;
        do
        {
          int v14 = *((_DWORD *)v3 + 5);
          if ((v14 & 0x40000000) != 0) {
            char v15 = (char *)*((void *)v3 - 1);
          }
          else {
            char v15 = (char *)v3 - 32 * (v14 & 0x7FFFFFF);
          }
          int v16 = *(llvm::Value **)&v15[v13];
          size_t v17 = (_WORD *)*((void *)a2 + 4);
          if (*((void *)a2 + 3) - (void)v17 > 1uLL)
          {
            _WORD *v17 = 8236;
            *((void *)a2 + 4) += 2;
          }
          else
          {
            llvm::raw_ostream::write(a2, ", ", 2uLL);
          }
          uint64_t result = (unsigned char *)llvm::Value::printAsOperand(v16, a2, 0, 0);
          v13 += 32;
        }
        while (32 * v9 != v13);
      }
    }
  }
  else
  {
    char v10 = *this;
    return (unsigned char *)llvm::Value::printAsOperand(v10, a2, 0, 0);
  }
  return result;
}

BOOL llvm::VPWidenIntOrFpInductionRecipe::isCanonical(llvm::VPWidenIntOrFpInductionRecipe *this)
{
  uint64_t v1 = *(void *)(**((void **)this + 6) + 40);
  if (*(_WORD *)(*(void *)(*((void *)this + 20) + 32) + 24)) {
    uint64_t v2 = 0;
  }
  else {
    uint64_t v2 = *(llvm::SCEV **)(*((void *)this + 20) + 32);
  }
  if (v1) {
    BOOL v3 = *(unsigned char *)(v1 + 16) == 16;
  }
  else {
    BOOL v3 = 0;
  }
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(unsigned int *)(v1 + 32);
  if (v4 > 0x40)
  {
    int v6 = 0;
    int64_t v7 = (unint64_t)(v4 + 63) >> 6;
    do
    {
      if (v7-- < 1) {
        break;
      }
      unint64_t v9 = *(void *)(*(void *)(v1 + 24) + 8 * v7);
      v6 += __clz(v9);
    }
    while (!v9);
    int v10 = v4 | 0xFFFFFFC0;
    if ((v4 & 0x3F) == 0) {
      int v10 = 0;
    }
    BOOL v5 = v6 + v10 == v4;
  }
  else
  {
    BOOL v5 = *(void *)(v1 + 24) == 0;
  }
  BOOL v11 = v5;
  return v11 && v2 != 0 && llvm::SCEV::isOne(v2);
}

void llvm::VPWidenCanonicalIVRecipe::execute(llvm::VPValue ***this, llvm::VPTransformState *a2)
{
  uint64_t v2 = a2;
  v42[1] = *MEMORY[0x1E4F143B8];
  VectorSplat = (unsigned __int8 *)llvm::VPTransformState::get(a2, *this[6], 0);
  uint64_t v5 = 0;
  unint64_t v29 = *(llvm::ConstantInt **)VectorSplat;
  uint64_t v6 = *(void *)(*((void *)v2 + 11) + 40);
  if (v6) {
    int64_t v7 = (uint64_t **)(v6 - 24);
  }
  else {
    int64_t v7 = 0;
  }
  if (*((unsigned __int8 *)v7 + 16) - 29 >= 0xB) {
    int64_t v7 = 0;
  }
  uint64_t v8 = **v7;
  v34[0] = v35;
  v34[1] = (void *)0x200000000;
  v35[6] = v8;
  v35[7] = &v41;
  v35[8] = v42;
  v35[9] = 0;
  int v36 = 0;
  __int16 v37 = 512;
  char v38 = 7;
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  uint64_t v41 = &unk_1F2616E88;
  v42[0] = &unk_1F2617008;
  v35[4] = v7[5];
  v35[5] = v7 + 3;
  unint64_t v9 = (unsigned __int8 *)v7[6];
  v30[0] = v9;
  if (v9)
  {
    llvm::MetadataTracking::track((uint64_t)v30, v9, 2);
    uint64_t v5 = v30[0];
  }
  sub_1CB8461A4((uint64_t)v34, 0, v5);
  if (v30[0])
  {
    int v24 = *(unsigned __int8 *)v30[0];
    if ((v24 - 4) > 0x1E)
    {
      if ((v24 - 3) >= 0xFFFFFFFE) {
        uint64_t v27 = v30[0];
      }
      else {
        uint64_t v27 = 0;
      }
      if ((v24 - 3) < 0xFFFFFFFE)
      {
        if (v24 == 3) {
          *(void *)(v30[0] + 8) = 0;
        }
        goto LABEL_9;
      }
      unint64_t v26 = v27 + 8;
    }
    else
    {
      if ((*(unsigned char *)(v30[0] + 1) & 0x7F) != 2 && !*(_DWORD *)(v30[0] + 12)) {
        goto LABEL_9;
      }
      uint64_t v25 = *(void *)(v30[0] + 16);
      if ((v25 & 4) == 0) {
        goto LABEL_9;
      }
      unint64_t v26 = v25 & 0xFFFFFFFFFFFFFFF8;
      if (!v26) {
        goto LABEL_9;
      }
    }
    v32[0] = v30;
    sub_1CC5FA668(v26 + 16, v32);
  }
LABEL_9:
  int v10 = *(llvm::Type **)v2;
  unint64_t v11 = *(void *)v2 & 0xFFFFFFFF00000000;
  if (v11 == 0x100000000 || v10 != 1)
  {
    v32[0] = "broadcast";
    __int16 v33 = 259;
    VectorSplat = (unsigned __int8 *)llvm::IRBuilderBase::CreateVectorSplat((uint64_t)v34, v10, VectorSplat, (uint64_t)v32);
  }
  uint64_t v12 = *((unsigned int *)v2 + 2);
  if (v12)
  {
    uint64_t v13 = 0;
    BOOL v16 = (v11 != 0x100000000 || v10 == 0) && v10 < 2;
    uint64_t v28 = *((unsigned int *)v2 + 2);
    do
    {
      StepForVF = (unsigned __int8 *)llvm::createStepForVF((llvm::IRBuilderBase *)v34, v29, (unint64_t)v10, v13);
      if (!v16)
      {
        __int16 v33 = 257;
        size_t v18 = v2;
        size_t v19 = llvm::IRBuilderBase::CreateVectorSplat((uint64_t)v34, v10, StepForVF, (uint64_t)v32);
        uint64_t v20 = *(llvm::Type ****)v19;
        __int16 v33 = 257;
        StepVector = llvm::IRBuilderBase::CreateStepVector((llvm::IRBuilderBase *)v34, v20, (const llvm::Twine *)v32);
        __int16 v31 = 257;
        uint64_t v22 = v19;
        uint64_t v2 = v18;
        uint64_t v12 = v28;
        StepForVF = (unsigned __int8 *)sub_1CB844A3C((uint64_t)v34, v22, (uint64_t)StepVector, (uint64_t)v30, 0, 0);
      }
      v32[0] = "vec.iv";
      __int16 v33 = 259;
      uint64_t v23 = sub_1CB844A3C((uint64_t)v34, VectorSplat, (uint64_t)StepForVF, (uint64_t)v32, 0, 0);
      sub_1CD8C9514((uint64_t)v2, this + 12, (uint64_t)v23, v13++);
    }
    while (v12 != v13);
  }
  if (v34[0] != v35) {
    free(v34[0]);
  }
}

uint64_t llvm::DomTreeBuilder::Calculate<llvm::DominatorTreeBase<llvm::VPBlockBase,false>>(uint64_t a1)
{
  return sub_1CD8EC5E8(a1, 0);
}

void llvm::VPInterleavedAccessInfo::visitRegion(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v10 = *(void *)(a2 + 200);
  unint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  sub_1CD8EDE88(&v11, &v10);
  uint64_t v8 = v11;
  int64_t v7 = v12;
  if (v12 != v11)
  {
    do
    {
      uint64_t v9 = *((void *)v7 - 1);
      v7 -= 8;
      llvm::VPInterleavedAccessInfo::visitBlock(a1, v9, a3, a4);
    }
    while (v7 != v8);
    int64_t v7 = v11;
  }
  if (v7)
  {
    uint64_t v12 = v7;
    operator delete(v7);
  }
}

unint64_t llvm::VPInterleavedAccessInfo::visitBlock(unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = result;
  if (!a2 || *(unsigned char *)(a2 + 8))
  {
    if (*(unsigned char *)(a2 + 8) != 1) {
      a2 = 0;
    }
    return llvm::VPInterleavedAccessInfo::visitRegion(result, a2);
  }
  else
  {
    uint64_t v6 = a2 + 200;
    uint64_t v7 = *(void *)(a2 + 208);
    if (v7 != a2 + 200)
    {
      uint64_t v8 = (uint64_t *)(a4 + 48);
      do
      {
        if (v7) {
          uint64_t v9 = v7 - 24;
        }
        else {
          uint64_t v9 = 0;
        }
        int v10 = *(unsigned __int8 *)(v9 + 8);
        if ((v10 - 14) < 4 || v10 == 20) {
          goto LABEL_13;
        }
        uint64_t v71 = v9;
        uint64_t v72 = 0;
        uint64_t v12 = *(void *)(v9 + 136);
        uint64_t v73 = v12;
        uint64_t result = sub_1CD3C8538(v8, &v73, &v72);
        if ((result & 1) == 0) {
          goto LABEL_13;
        }
        uint64_t v13 = *(void *)(v72 + 8);
        uint64_t v73 = v13;
        if (!v13) {
          goto LABEL_13;
        }
        uint64_t v14 = *(unsigned int *)(a3 + 16);
        if (!v14) {
          goto LABEL_20;
        }
        uint64_t v15 = *(void *)a3;
        LODWORD(v16) = (v14 - 1) & ((v13 >> 4) ^ (v13 >> 9));
        size_t v17 = (uint64_t *)(*(void *)a3 + 16 * v16);
        uint64_t v18 = *v17;
        if (*v17 != v13)
        {
          int v48 = 1;
          do
          {
            if (v18 == -4096) {
              goto LABEL_20;
            }
            int v49 = v16 + v48++;
            uint64_t v16 = v49 & (v14 - 1);
            uint64_t v18 = *(void *)(v15 + 16 * v16);
          }
          while (v18 != v13);
          size_t v17 = (uint64_t *)(v15 + 16 * v16);
        }
        if (v17 == (uint64_t *)(v15 + 16 * v14)) {
LABEL_20:
        }
          operator new();
        if (v12 == *(void *)(v13 + 40)) {
          *(void *)(sub_1CD3582B8(a3, &v73)[1] + 40) = v9;
        }
        uint64_t v19 = sub_1CD3582B8(a3, &v73)[1];
        sub_1CD3582B8(v5, &v71)[1] = v19;
        uint64_t v20 = sub_1CD3582B8(v5, &v71)[1];
        unsigned int v21 = sub_1CD4D5A00(v13, v12);
        signed int v22 = v21;
        int v23 = *(_DWORD *)v13;
        unint64_t v24 = *(unsigned char *)(v13 + 4) ? -v23 : v23;
        unint64_t v70 = v24;
        uint64_t result = sub_1CC18A180(v21, *(_DWORD *)(v20 + 32), (void (*)(uint64_t **__return_ptr, char *, uint64_t *, char *))llvm::APInt::sadd_ov, 0);
        signed int v25 = result;
        if (!HIDWORD(result) || (result - 0x7FFFFFFF) < 2) {
          goto LABEL_13;
        }
        unint64_t v28 = v20 + 8;
        uint64_t v27 = *(void *)(v20 + 8);
        uint64_t v29 = *(unsigned int *)(v20 + 24);
        BOOL v69 = (unsigned int *)v20;
        if (v29)
        {
          LODWORD(v30) = (v29 - 1) & (37 * result);
          __int16 v31 = (int *)(v27 + 16 * v30);
          int v32 = *v31;
          if (*v31 == result) {
            goto LABEL_38;
          }
          int v33 = 1;
          while (1)
          {
            unint64_t v28 = v20 + 8;
            if (v32 == 0x7FFFFFFF) {
              break;
            }
            int v34 = v30 + v33++;
            uint64_t v30 = v34 & (v29 - 1);
            int v32 = *(_DWORD *)(v27 + 16 * v30);
            if (v32 == result)
            {
              __int16 v31 = (int *)(v27 + 16 * v30);
              unint64_t v28 = v20 + 8;
              goto LABEL_38;
            }
          }
        }
        __int16 v31 = (int *)(v27 + 16 * v29);
LABEL_38:
        int v35 = (unsigned int *)v20;
        if ((int *)(v27 + 16 * v29) == v31)
        {
          uint64_t result = *(unsigned int *)(v20 + 36);
          if ((int)result >= v25)
          {
            if (*(_DWORD *)(v20 + 32) > v25)
            {
              unint64_t v36 = v28;
              uint64_t result = sub_1CC18A180(result, v25, (void (*)(uint64_t **__return_ptr, char *, uint64_t *, char *))llvm::APInt::ssub_ov, 0);
              if (!HIDWORD(result) || *v69 <= (uint64_t)(int)result) {
                goto LABEL_13;
              }
              unint64_t v28 = v36;
              void v69[8] = v25;
              uint64_t v27 = *((void *)v69 + 1);
              LODWORD(v29) = v69[6];
              int v35 = v69;
            }
LABEL_46:
            unsigned __int8 v37 = 63 - __clz(v70);
            if (*((unsigned __int8 *)v35 + 5) >= v37) {
              unsigned __int8 v38 = v37;
            }
            else {
              unsigned __int8 v38 = *((unsigned char *)v35 + 5);
            }
            *((unsigned char *)v35 + 5) = v38;
            uint64_t result = v28;
            if (!v29)
            {
              uint64_t v41 = 0;
              goto LABEL_61;
            }
            int v39 = v29 - 1;
            unsigned int v40 = (v29 - 1) & (37 * v25);
            uint64_t v41 = (signed int *)(v27 + 16 * v40);
            int v42 = *v41;
            if (*v41 != v25)
            {
              char v43 = 0;
              int v44 = 1;
              while (v42 != 0x7FFFFFFF)
              {
                if (v43) {
                  BOOL v45 = 0;
                }
                else {
                  BOOL v45 = v42 == 0x80000000;
                }
                if (v45) {
                  char v43 = v41;
                }
                unsigned int v46 = v40 + v44++;
                unsigned int v40 = v46 & v39;
                uint64_t v41 = (signed int *)(v27 + 16 * (v46 & v39));
                int v42 = *v41;
                if (*v41 == v25) {
                  goto LABEL_66;
                }
              }
              if (v43) {
                uint64_t v41 = v43;
              }
              int v35 = v69;
LABEL_61:
              unsigned int v47 = v35[4];
              if (4 * v47 + 4 < 3 * (int)v29)
              {
                if (v29 + ~v47 - v35[5] > v29 >> 3) {
                  goto LABEL_63;
                }
                uint64_t v60 = v35;
                uint64_t result = (unint64_t)sub_1CD358394((uint64_t *)result, v29);
                unsigned int v61 = v60[6];
                if (v61)
                {
                  uint64_t v62 = *((void *)v69 + 1);
                  unsigned int v63 = v61 - 1;
                  unsigned int v64 = (v61 - 1) & (37 * v25);
                  uint64_t v41 = (signed int *)(v62 + 16 * v64);
                  int v65 = *v41;
                  if (*v41 != v25)
                  {
                    uint64_t v56 = 0;
                    int v66 = 1;
                    while (v65 != 0x7FFFFFFF)
                    {
                      if (v56) {
                        BOOL v67 = 0;
                      }
                      else {
                        BOOL v67 = v65 == 0x80000000;
                      }
                      if (v67) {
                        uint64_t v56 = v41;
                      }
                      unsigned int v68 = v64 + v66++;
                      unsigned int v64 = v68 & v63;
                      uint64_t v41 = (signed int *)(v62 + 16 * (v68 & v63));
                      int v65 = *v41;
                      int v35 = v69;
                      if (*v41 == v25) {
                        goto LABEL_63;
                      }
                    }
                    goto LABEL_98;
                  }
                  goto LABEL_97;
                }
LABEL_96:
                uint64_t v41 = 0;
                goto LABEL_97;
              }
              char v50 = v35;
              uint64_t result = (unint64_t)sub_1CD358394((uint64_t *)result, 2 * (int)v29);
              unsigned int v51 = v50[6];
              if (!v51) {
                goto LABEL_96;
              }
              uint64_t v52 = *((void *)v69 + 1);
              unsigned int v53 = v51 - 1;
              unsigned int v54 = (v51 - 1) & (37 * v25);
              uint64_t v41 = (signed int *)(v52 + 16 * v54);
              int v55 = *v41;
              if (*v41 != v25)
              {
                uint64_t v56 = 0;
                int v57 = 1;
                while (v55 != 0x7FFFFFFF)
                {
                  if (v56) {
                    BOOL v58 = 0;
                  }
                  else {
                    BOOL v58 = v55 == 0x80000000;
                  }
                  if (v58) {
                    uint64_t v56 = v41;
                  }
                  unsigned int v59 = v54 + v57++;
                  unsigned int v54 = v59 & v53;
                  uint64_t v41 = (signed int *)(v52 + 16 * (v59 & v53));
                  int v55 = *v41;
                  int v35 = v69;
                  if (*v41 == v25) {
                    goto LABEL_63;
                  }
                }
LABEL_98:
                if (v56) {
                  uint64_t v41 = v56;
                }
              }
LABEL_97:
              int v35 = v69;
LABEL_63:
              ++v35[4];
              if (*v41 != 0x7FFFFFFF) {
                --v69[5];
              }
              *uint64_t v41 = v25;
              *((void *)v41 + 1) = 0;
            }
LABEL_66:
            *((void *)v41 + 1) = v9;
            goto LABEL_13;
          }
          if (*(_DWORD *)v20 > v22)
          {
            *(_DWORD *)(v20 + 36) = v25;
            goto LABEL_46;
          }
        }
LABEL_13:
        uint64_t v7 = *(void *)(v7 + 8);
      }
      while (v7 != v6);
    }
  }
  return result;
}

llvm::VPInterleavedAccessInfo *llvm::VPInterleavedAccessInfo::VPInterleavedAccessInfo(llvm::VPInterleavedAccessInfo *this, llvm::VPlan *a2, llvm::InterleavedAccessInfo *a3)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((_DWORD *)this + 4) = 0;
  v7[0] = 0;
  v7[1] = 0;
  int v8 = 0;
  uint64_t v4 = *(void *)a2;
  if (v4) {
    BOOL v5 = *(unsigned char *)(v4 + 8) == 1;
  }
  else {
    BOOL v5 = 0;
  }
  if (!v5)
  {
    if (*(_DWORD *)(v4 + 80) == 1) {
      uint64_t v4 = **(void **)(v4 + 72);
    }
    else {
      uint64_t v4 = 0;
    }
  }
  llvm::VPInterleavedAccessInfo::visitRegion((unint64_t)this, v4, (uint64_t)v7, (uint64_t)a3);
  MEMORY[0x1D25D9CD0](v7[0], 8);
  return this;
}

void *llvm::VPSlotTracker::assignSlot(llvm::VPSlotTracker *this, const llvm::VPValue *a2)
{
  uint64_t v4 = a2;
  int v2 = *((_DWORD *)this + 6);
  *((_DWORD *)this + 6) = v2 + 1;
  uint64_t result = sub_1CD40EB18((uint64_t)this, (uint64_t *)&v4);
  *((_DWORD *)result + 2) = v2;
  return result;
}

uint64_t llvm::vputils::getOrCreateVPValueForSCEVExpr(llvm::vputils *this, llvm::VPlan *a2, const llvm::SCEV *a3, llvm::ScalarEvolution *a4)
{
  uint64_t v4 = this;
  if (a2 && !*((_WORD *)a2 + 12))
  {
    uint64_t v8 = *((void *)a2 + 4);
  }
  else
  {
    if (!a2 || *((_WORD *)a2 + 12) != 14)
    {
      while (1)
      {
        uint64_t v5 = *(void *)v4;
        int v6 = *(unsigned __int8 *)(*(void *)v4 + 8);
        uint64_t v4 = (llvm::vputils *)(*(void *)v4 + 200);
        if (v5) {
          BOOL v7 = v6 == 1;
        }
        else {
          BOOL v7 = 0;
        }
        if (!v7) {
          operator new();
        }
      }
    }
    uint64_t v8 = *((void *)a2 - 1);
  }

  return sub_1CD8D2A38((uint64_t)this, v8);
}

void *sub_1CD355FEC(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = sub_1CD8D778C((uint64_t)a1, 1, 0, 0);
  *(void *)uint64_t v6 = &unk_1F264BF50;
  *(void *)(v6 + 40) = &unk_1F264BF90;
  *(void *)(v6 + 96) = &unk_1F264BF30;
  *(unsigned char *)(v6 + 104) = 0;
  *(void *)(v6 + 112) = v6 + 128;
  *(void *)(v6 + 120) = 0x100000000;
  *(void *)(v6 + 136) = 0;
  *(void *)(v6 + 144) = v6;
  sub_1CD486FFC((unint64_t *)(v6 + 16), v6 + 96);
  *a1 = &unk_1F264BF50;
  a1[5] = &unk_1F264BF90;
  a1[12] = &unk_1F264BFB0;
  a1[19] = a2;
  a1[20] = a3;
  return a1;
}

uint64_t sub_1CD3560EC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = v34;
  uint64_t v29 = v34;
  uint64_t v5 = *(const void **)(a1 + 8);
  if (v5 == *(const void **)a1)
  {
    uint64_t v30 = v34;
    uint64_t v6 = v5;
  }
  else
  {
    uint64_t v22 = *(unsigned int *)(a1 + 16);
    uint64_t v4 = malloc_type_malloc(8 * v22, 0x4065EBACuLL);
    if (!v4)
    {
      if (v22) {
        goto LABEL_49;
      }
      uint64_t v4 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v4) {
        goto LABEL_49;
      }
    }
    uint64_t v30 = v4;
    uint64_t v6 = *(const void **)a1;
    uint64_t v5 = *(const void **)(a1 + 8);
  }
  unsigned int v8 = *(_DWORD *)(a1 + 16);
  unsigned int v7 = *(_DWORD *)(a1 + 20);
  unsigned int v31 = v8;
  if (v5 == v6) {
    unsigned int v9 = v7;
  }
  else {
    unsigned int v9 = v8;
  }
  if (v9)
  {
    memmove(v4, v5, 8 * v9);
    unsigned int v7 = *(_DWORD *)(a1 + 20);
  }
  int v10 = *(_DWORD *)(a1 + 24);
  unsigned int v32 = v7;
  int v33 = v10;
  unint64_t v36 = 0;
  uint64_t v37 = 0;
  __p = 0;
  sub_1CBF340A8(&__p, *(unsigned char **)(a1 + 96), *(unsigned char **)(a1 + 104), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 104) - *(void *)(a1 + 96)) >> 3));
  unint64_t v11 = v25;
  uint64_t v12 = *(const void **)(a2 + 8);
  if (v12 != *(const void **)a2)
  {
    uint64_t v23 = *(unsigned int *)(a2 + 16);
    unint64_t v11 = malloc_type_malloc(8 * v23, 0x4065EBACuLL);
    if (v11 || !v23 && (unint64_t v11 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) != 0)
    {
      unint64_t v24 = v11;
      uint64_t v13 = *(const void **)a2;
      uint64_t v12 = *(const void **)(a2 + 8);
      goto LABEL_10;
    }
LABEL_49:
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  unint64_t v24 = v25;
  uint64_t v13 = *(const void **)(a2 + 8);
LABEL_10:
  if (v12 == v13) {
    unsigned int v14 = *(_DWORD *)(a2 + 20);
  }
  else {
    unsigned int v14 = *(_DWORD *)(a2 + 16);
  }
  if (v14) {
    memmove(v11, v12, 8 * v14);
  }
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  unint64_t v26 = 0;
  sub_1CBF340A8(&v26, *(unsigned char **)(a2 + 96), *(unsigned char **)(a2 + 104), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 104) - *(void *)(a2 + 96)) >> 3));
  for (uint64_t i = 0; ; ++i)
  {
    if (v36 - (unsigned char *)__p != v27 - v26) {
      goto LABEL_30;
    }
    if (__p == v36) {
      break;
    }
    uint64_t v16 = v26 + 8;
    size_t v17 = (char *)__p + 8;
    while (1)
    {
      uint64_t v18 = v17 - 8;
      if (*((void *)v17 - 1) != *((void *)v16 - 1)) {
        break;
      }
      int v19 = v16[8];
      if (v17[8]) {
        BOOL v20 = v19 == 0;
      }
      else {
        BOOL v20 = 1;
      }
      if (v20)
      {
        if ((v17[8] == 0) == (v19 != 0)) {
          break;
        }
      }
      else if (*(void *)v17 != *(void *)v16)
      {
        break;
      }
      v16 += 24;
      v17 += 24;
      if (v18 + 24 == v36) {
        goto LABEL_31;
      }
    }
LABEL_30:
    sub_1CD8DC09C((char *)&v29);
  }
LABEL_31:
  if (v26)
  {
    uint64_t v27 = v26;
    operator delete(v26);
  }
  if (v24 != v25) {
    free(v24);
  }
  if (__p)
  {
    unint64_t v36 = (char *)__p;
    operator delete(__p);
  }
  if (v30 != v29) {
    free(v30);
  }
  return i;
}

void sub_1CD35637C(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v29 = v33;
  unsigned int v7 = *(const void **)a1;
  uint64_t v6 = *(const void **)(a1 + 8);
  if (v6 == *(const void **)a1)
  {
    uint64_t v30 = v33;
    uint64_t v8 = *(unsigned int *)(a1 + 20);
    if (v8) {
      memmove(v33, v6, 8 * v8);
    }
  }
  else
  {
    uint64_t v30 = *(unsigned char **)(a1 + 8);
    *(void *)(a1 + 8) = v7;
    LODWORD(v8) = *(_DWORD *)(a1 + 20);
  }
  LODWORD(v31) = *(_DWORD *)(a1 + 16);
  HIDWORD(v31) = v8;
  int v32 = *(_DWORD *)(a1 + 24);
  *(void *)(a1 + 16) = 8;
  *(_DWORD *)(a1 + 24) = 0;
  unsigned int v9 = *(char **)(a1 + 96);
  __p = v9;
  long long v10 = *(_OWORD *)(a1 + 104);
  long long v35 = v10;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 96) = 0;
  unint64_t v11 = *(const void **)(a2 + 8);
  if (v11 == *(const void **)a2)
  {
    signed int v25 = v26;
    uint64_t v12 = *(unsigned int *)(a2 + 20);
    if (v12)
    {
      uint64_t v24 = v10;
      memmove(v26, v11, 8 * v12);
      *(void *)&long long v10 = v24;
    }
  }
  else
  {
    signed int v25 = *(unsigned char **)(a2 + 8);
    *(void *)(a2 + 8) = *(void *)a2;
  }
  *(void *)(a2 + 16) = 8;
  *(_DWORD *)(a2 + 24) = 0;
  uint64_t v13 = *(char **)(a2 + 96);
  long long v28 = *(_OWORD *)(a2 + 104);
  uint64_t v14 = v28;
  *(void *)(a2 + 96) = 0;
  *(void *)(a2 + 104) = 0;
  *(void *)(a2 + 112) = 0;
  uint64_t v15 = v14;
  uint64_t v16 = (char *)v10;
  uint64_t v27 = v13;
  while (1)
  {
    if (v16 - v9 != v15 - (void)v13) {
      goto LABEL_22;
    }
    if (v9 == v16) {
      break;
    }
    size_t v17 = v13 + 8;
    uint64_t v18 = v9 + 8;
    while (1)
    {
      int v19 = v18 - 8;
      if (*((void *)v18 - 1) != *((void *)v17 - 1)) {
        break;
      }
      int v20 = v17[8];
      if (v18[8]) {
        BOOL v21 = v20 == 0;
      }
      else {
        BOOL v21 = 1;
      }
      if (v21)
      {
        if ((v18[8] == 0) == (v20 != 0)) {
          break;
        }
      }
      else if (*(void *)v18 != *(void *)v17)
      {
        break;
      }
      v17 += 24;
      v18 += 24;
      if (v19 + 24 == v16) {
        goto LABEL_23;
      }
    }
LABEL_22:
    *a3++ = *((void *)v16 - 3);
    sub_1CD8DC09C((char *)&v29);
    uint64_t v13 = v27;
    uint64_t v15 = v28;
    unsigned int v9 = (char *)__p;
    uint64_t v16 = (char *)v35;
  }
LABEL_23:
  unint64_t v36 = v41;
  if (v30 == v29)
  {
    uint64_t v37 = v41;
    int v22 = HIDWORD(v31);
    if (HIDWORD(v31)) {
      memmove(v41, v30, 8 * HIDWORD(v31));
    }
  }
  else
  {
    uint64_t v37 = v30;
    uint64_t v30 = v29;
    int v22 = HIDWORD(v31);
  }
  int v38 = v31;
  int v39 = v22;
  int v40 = v32;
  uint64_t v31 = 8;
  int v32 = 0;
  int v42 = v9;
  char v43 = v16;
  uint64_t v23 = *((void *)&v35 + 1);
  long long v35 = 0uLL;
  __p = 0;
  uint64_t v44 = v23;
  BOOL v45 = a3;
  if (v13)
  {
    *(void *)&long long v28 = v13;
    operator delete(v13);
  }
  if (v25 != v26) {
    free(v25);
  }
  if (__p)
  {
    *(void *)&long long v35 = __p;
    operator delete(__p);
  }
  if (v30 != v29) {
    free(v30);
  }
  if (v42)
  {
    char v43 = v42;
    operator delete(v42);
  }
  if (v37 != v36) {
    free(v37);
  }
}

uint64_t sub_1CD356634(llvm::SmallPtrSetImplBase *a1, llvm::SmallPtrSetImplBase *a2, char **a3)
{
  v26[16] = *MEMORY[0x1E4F143B8];
  sub_1CD4BAE30((const void **)&v11, a1);
  sub_1CD4BAE30((const void **)&v7, a2);
  sub_1CD4BAAE4((uint64_t)&v23, (uint64_t)&v11);
  sub_1CD4BAAE4((uint64_t)&v19, (uint64_t)&v7);
  sub_1CD3567B0((uint64_t)&v23, (uint64_t)&v19, a3, (uint64_t)&v15);
  if (v21 != &v22) {
    free(v21);
  }
  if (v20 != v19) {
    free(v20);
  }
  if (v25 != v26) {
    free(v25);
  }
  if (v24 != v23) {
    free(v24);
  }
  uint64_t v5 = v18[16];
  if (v17 != v18) {
    free(v17);
  }
  if (v16 != v15) {
    free(v16);
  }
  if (v9 != &v10) {
    free(v9);
  }
  if (v8 != v7) {
    free(v8);
  }
  if (v13 != &v14) {
    free(v13);
  }
  if (v12 != v11) {
    free(v12);
  }
  return v5;
}

void sub_1CD3567B0(uint64_t a1@<X0>, uint64_t a2@<X1>, char **a3@<X2>, uint64_t a4@<X8>)
{
  v14[16] = *MEMORY[0x1E4F143B8];
  sub_1CD4BAAE4((uint64_t)&v11, a1);
  sub_1CD4BAAE4((uint64_t)&v7, a2);
  sub_1CD356898((llvm::SmallPtrSetImplBase *)&v11, (uint64_t)&v7, a3, a4);
  if (v9 != &v10) {
    free(v9);
  }
  if (v8 != v7) {
    free(v8);
  }
  if (v13 != v14) {
    free(v13);
  }
  if (v12 != v11) {
    free(v12);
  }
}

void **sub_1CD356898@<X0>(llvm::SmallPtrSetImplBase *a1@<X0>, uint64_t a2@<X1>, char **a3@<X2>, uint64_t a4@<X8>)
{
  v43[30] = *MEMORY[0x1E4F143B8];
  sub_1CD4BAE30((const void **)&v38, a1);
  sub_1CD4BAAE4((uint64_t)&v34, a2);
  sub_1CD356AFC((uint64_t)&v38, (uint64_t)&v34, (uint64_t)v42);
  if (v36 != &v37) {
    free(v36);
  }
  if (v35 != v34) {
    free(v35);
  }
  if (v40 != &v41) {
    free(v40);
  }
  if (v39 != v38) {
    free(v39);
  }
  sub_1CD4BAAE4((uint64_t)&v26, (uint64_t)v42);
  sub_1CD4BAAE4((uint64_t)&v22, (uint64_t)v43);
  sub_1CD356CB8((llvm::SmallPtrSetImplBase *)&v26, (uint64_t)&v22, a3, (uint64_t)&v30);
  if (v24 != &v25) {
    free(v24);
  }
  if (v23 != v22) {
    free(v23);
  }
  if (v28 != &v29) {
    free(v28);
  }
  if (v27 != v26) {
    free(v27);
  }
  sub_1CD4BAAE4((uint64_t)&v14, (uint64_t)a1);
  sub_1CD4BAAE4((uint64_t)&v10, (uint64_t)&v30);
  sub_1CD356E48((uint64_t)&v14, (uint64_t)&v10, (uint64_t)&v18);
  uint64_t v8 = v33[16];
  sub_1CD4BAAE4(a4, (uint64_t)&v18);
  *(void *)(a4 + 240) = v8;
  if (v20 != &v21) {
    free(v20);
  }
  if (v19 != v18) {
    free(v19);
  }
  if (v12 != &v13) {
    free(v12);
  }
  if (v11 != v10) {
    free(v11);
  }
  if (v16 != &v17) {
    free(v16);
  }
  if (v15 != v14) {
    free(v15);
  }
  if (v32 != v33) {
    free(v32);
  }
  if (v31 != v30) {
    free(v31);
  }
  return sub_1CD4B9AEC(v42);
}

void sub_1CD356AFC(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v24[16] = *MEMORY[0x1E4F143B8];
  sub_1CD4BAAE4((uint64_t)&v13, a1);
  sub_1CD4BAE30((const void **)&v21, (llvm::SmallPtrSetImplBase *)&v13);
  sub_1CD4BAAE4((uint64_t)&v17, (uint64_t)&v21);
  if (v23 != v24) {
    free(v23);
  }
  if (v22 != v21) {
    free(v22);
  }
  sub_1CD4BAAE4((uint64_t)&v5, a2);
  sub_1CD4BAE30((const void **)&v21, (llvm::SmallPtrSetImplBase *)&v5);
  sub_1CD4BAAE4((uint64_t)&v9, (uint64_t)&v21);
  if (v23 != v24) {
    free(v23);
  }
  if (v22 != v21) {
    free(v22);
  }
  sub_1CD4BAAE4(a3, (uint64_t)&v17);
  sub_1CD4BAAE4(a3 + 240, (uint64_t)&v9);
  if (v11 != &v12) {
    free(v11);
  }
  if (v10 != v9) {
    free(v10);
  }
  if (v7 != &v8) {
    free(v7);
  }
  if (v6 != v5) {
    free(v6);
  }
  if (v19 != &v20) {
    free(v19);
  }
  if (v18 != v17) {
    free(v18);
  }
  if (v15 != &v16) {
    free(v15);
  }
  if (v14 != v13) {
    free(v14);
  }
}

uint64_t sub_1CD356CB8@<X0>(llvm::SmallPtrSetImplBase *this@<X1>, uint64_t a2@<X2>, char **a3@<X3>, uint64_t a4@<X8>)
{
  while (1)
  {
    uint64_t v7 = *((unsigned int *)this + 26);
    uint64_t v8 = *((void *)this + 12);
    if (v7 != *(_DWORD *)(a2 + 104)) {
      goto LABEL_11;
    }
    if (!v7) {
      break;
    }
    unsigned int v9 = *(void **)(a2 + 96);
    uint64_t v10 = (void *)*((void *)this + 12);
    while (*v10 == *v9 && v10[1] == v9[1])
    {
      v10 += 2;
      v9 += 2;
      if (v10 == (void *)(v8 + 16 * v7)) {
        goto LABEL_30;
      }
    }
LABEL_11:
    uint64_t v12 = v8 + 16 * v7;
    uint64_t v14 = a3[1];
    unint64_t v13 = (unint64_t)a3[2];
    if ((unint64_t)v14 >= v13)
    {
      uint64_t v16 = *a3;
      uint64_t v17 = (v14 - *a3) >> 3;
      unint64_t v18 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        abort();
      }
      uint64_t v19 = v13 - (void)v16;
      if (v19 >> 2 > v18) {
        unint64_t v18 = v19 >> 2;
      }
      if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v20 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v20 = v18;
      }
      if (v20)
      {
        if (v20 >> 61) {
          sub_1CB833614();
        }
        uint64_t v21 = (char *)operator new(8 * v20);
      }
      else
      {
        uint64_t v21 = 0;
      }
      uint64_t v22 = &v21[8 * v17];
      *(void *)uint64_t v22 = *(void *)(v12 - 16);
      uint64_t v15 = v22 + 8;
      if (v14 != v16)
      {
        do
        {
          uint64_t v23 = *((void *)v14 - 1);
          v14 -= 8;
          *((void *)v22 - 1) = v23;
          v22 -= 8;
        }
        while (v14 != v16);
        uint64_t v14 = *a3;
      }
      *a3 = v22;
      a3[1] = v15;
      a3[2] = &v21[8 * v20];
      if (v14)
      {
        operator delete(v14);
        LODWORD(v7) = *((_DWORD *)this + 26);
      }
    }
    else
    {
      *(void *)uint64_t v14 = *(void *)(v12 - 16);
      uint64_t v15 = v14 + 8;
    }
    a3[1] = v15;
    *((_DWORD *)this + 26) = v7 - 1;
    if (v7 != 1) {
      sub_1CD8EDFA0(this);
    }
  }
LABEL_30:
  uint64_t result = sub_1CD4BAAE4(a4, (uint64_t)this);
  *(void *)(result + 240) = a3;
  return result;
}

void sub_1CD356E48(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v12[16] = *MEMORY[0x1E4F143B8];
  sub_1CD4BAAE4((uint64_t)&v9, a1);
  sub_1CD4BAAE4((uint64_t)&v5, a2);
  sub_1CD356F20((uint64_t)&v9, (uint64_t)&v5, a3);
  if (v7 != &v8) {
    free(v7);
  }
  if (v6 != v5) {
    free(v6);
  }
  if (v11 != v12) {
    free(v11);
  }
  if (v10 != v9) {
    free(v10);
  }
}

void sub_1CD356F20(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v12[16] = *MEMORY[0x1E4F143B8];
  sub_1CD4BAAE4((uint64_t)&v9, a1);
  sub_1CD4BAAE4((uint64_t)&v5, a2);
  sub_1CD4BAAE4(a3, (uint64_t)&v5);
  if (v7 != &v8) {
    free(v7);
  }
  if (v6 != v5) {
    free(v6);
  }
  if (v11 != v12) {
    free(v11);
  }
  if (v10 != v9) {
    free(v10);
  }
}

void *sub_1CD356FF4(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = *a3;
  uint64_t v6 = a1 + 24;
  uint64_t result = sub_1CD8EE940((uint64_t *)(a1 + 24), (void *)(*(void *)a1 + 8));
  result[4] = v5;
  uint64_t v8 = *(void *)(a1 + 8) - *(void *)a1;
  if (v8 != 8)
  {
    uint64_t v9 = v8 >> 3;
    uint64_t v10 = 1;
    do
    {
      uint64_t v13 = 0;
      uint64_t v13 = *(void *)(*(void *)a1 + 8 * v10);
      uint64_t result = sub_1CD8EF4B4((uint64_t *)(a2 + 24), &v13);
      if (!result[1])
      {
        uint64_t v11 = sub_1CD358250(v6, v13);
        if (*(void *)(a1 + 24) + 72 * *(unsigned int *)(a1 + 40) == v11) {
          uint64_t v12 = 0;
        }
        else {
          uint64_t v12 = *(void *)(v11 + 32);
        }
        sub_1CD358190(a1, v12, a2);
        sub_1CD8EF694(a2, v13);
      }
      ++v10;
    }
    while (v9 != v10);
  }
  return result;
}

uint64_t sub_1CD3570F4(uint64_t a1, void *a2, uint64_t a3, unsigned int (*a4)(uint64_t, uint64_t), int a5, _DWORD *a6)
{
  v50[64] = *MEMORY[0x1E4F143B8];
  int v42 = a2;
  int v48 = v50;
  v50[0] = a2;
  uint64_t v49 = 0x4000000001;
  uint64_t v11 = (uint64_t *)(a1 + 24);
  uint64_t v44 = 0;
  BOOL v45 = a2;
  if (sub_1CD8EE89C((uint64_t *)(a1 + 24), &v45, &v44)) {
    *((_DWORD *)sub_1CD8EE940(v11, &v42) + 3) = a5;
  }
  unsigned int v12 = v49;
  if (v49)
  {
    uint64_t v13 = &v47;
    while (1)
    {
      uint64_t v41 = 0;
      uint64_t v14 = *((void *)v48 + v12 - 1);
      LODWORD(v49) = v12 - 1;
      uint64_t v41 = v14;
      uint64_t v15 = sub_1CD8EE940(v11, &v41);
      if (!*((_DWORD *)v15 + 2)) {
        break;
      }
LABEL_6:
      unsigned int v12 = v49;
      if (!v49) {
        goto LABEL_50;
      }
    }
    int v38 = a6;
    int v39 = v13;
    a3 = (a3 + 1);
    *((_DWORD *)v15 + 4) = a3;
    *((_DWORD *)v15 + 2) = a3;
    uint64_t v16 = v41;
    v15[3] = v41;
    unint64_t v18 = *(uint64_t **)(a1 + 8);
    unint64_t v17 = *(void *)(a1 + 16);
    if ((unint64_t)v18 >= v17)
    {
      unint64_t v20 = *(uint64_t **)a1;
      uint64_t v21 = ((uint64_t)v18 - *(void *)a1) >> 3;
      unint64_t v22 = v21 + 1;
      if ((unint64_t)(v21 + 1) >> 61) {
        abort();
      }
      uint64_t v23 = v17 - (void)v20;
      if (v23 >> 2 > v22) {
        unint64_t v22 = v23 >> 2;
      }
      if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v24 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v24 = v22;
      }
      if (v24)
      {
        if (v24 >> 61) {
          sub_1CB833614();
        }
        uint64_t v25 = (char *)operator new(8 * v24);
      }
      else
      {
        uint64_t v25 = 0;
      }
      unint64_t v26 = (uint64_t *)&v25[8 * v21];
      *unint64_t v26 = v16;
      uint64_t v19 = v26 + 1;
      if (v18 == v20)
      {
        a6 = v38;
      }
      else
      {
        a6 = v38;
        do
        {
          uint64_t v27 = *--v18;
          *--unint64_t v26 = v27;
        }
        while (v18 != v20);
        unint64_t v18 = *(uint64_t **)a1;
      }
      *(void *)a1 = v26;
      *(void *)(a1 + 8) = v19;
      *(void *)(a1 + 16) = &v25[8 * v24];
      uint64_t v13 = v39;
      if (v18) {
        operator delete(v18);
      }
    }
    else
    {
      *unint64_t v18 = v16;
      uint64_t v19 = v18 + 1;
      a6 = v38;
    }
    *(void *)(a1 + 8) = v19;
    uint64_t v28 = *(void *)(a1 + 48);
    if (v28) {
      sub_1CD8EEC58(*(void *)(v28 + 8), v41, (uint64_t)&v45);
    }
    else {
      sub_1CD8EEE54(v41, (char **)&v45);
    }
    uint64_t v29 = v46;
    if (a6 && v46 >= 2uLL)
    {
      uint64_t v44 = a6;
      sub_1CD8EEF24((uint64_t)v45, (uint64_t *)v45 + v46, (uint64_t *)&v44, 126 - 2 * __clz(v46), 1);
      uint64_t v29 = v46;
    }
    uint64_t v30 = (uint64_t *)v45;
    if (!v29)
    {
LABEL_48:
      if (v30 != v13) {
        free(v30);
      }
      goto LABEL_6;
    }
    uint64_t v31 = 8 * v29;
    while (1)
    {
      uint64_t v40 = 0;
      uint64_t v40 = *v30;
      uint64_t v43 = v40;
      uint64_t v44 = 0;
      if (!sub_1CD8EE89C(v11, &v43, &v44)
        || v44 == (_DWORD *)(*(void *)(a1 + 24) + 72 * *(unsigned int *)(a1 + 40))
        || !v44[2])
      {
        break;
      }
      uint64_t v32 = v41;
      if (v40 != v41)
      {
        int v34 = v44 + 12;
        unint64_t v33 = v44[12];
        long long v35 = v44 + 10;
        if (v33 >= v44[13]) {
          goto LABEL_46;
        }
LABEL_40:
        *(void *)(*v35 + 8 * v33) = v32;
        ++*v34;
      }
LABEL_42:
      ++v30;
      v31 -= 8;
      if (!v31)
      {
        uint64_t v30 = (uint64_t *)v45;
        uint64_t v13 = v39;
        goto LABEL_48;
      }
    }
    if (!a4(v41, v40)) {
      goto LABEL_42;
    }
    unint64_t v36 = sub_1CD8EE940(v11, &v40);
    if (v49 >= (unint64_t)HIDWORD(v49)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)v48 + v49) = v40;
    int v34 = v36 + 12;
    unint64_t v33 = v36[12];
    LODWORD(v49) = v49 + 1;
    v36[3] = a3;
    long long v35 = v36 + 10;
    uint64_t v32 = v41;
    a6 = v38;
    if (v33 >= v36[13]) {
LABEL_46:
    }
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    goto LABEL_40;
  }
LABEL_50:
  if (v48 != v50) {
    free(v48);
  }
  return a3;
}

uint64_t *sub_1CD357500(uint64_t *result, uint64_t *a2, uint64_t *a3)
{
  if (result != a2)
  {
    uint64_t v4 = result;
    uint64_t v5 = result + 1;
    if (result + 1 != a2)
    {
      uint64_t v7 = 0;
      uint64_t v8 = result;
      do
      {
        uint64_t v10 = *v8;
        uint64_t v9 = v8[1];
        uint64_t v8 = v5;
        uint64_t result = (uint64_t *)sub_1CD8EF2D4(a3, v9, v10);
        if (result)
        {
          uint64_t v11 = *v8;
          uint64_t v12 = v7;
          while (1)
          {
            *(uint64_t *)((char *)v4 + v12 + 8) = *(uint64_t *)((char *)v4 + v12);
            if (!v12) {
              break;
            }
            uint64_t result = (uint64_t *)sub_1CD8EF2D4(a3, v11, *(uint64_t *)((char *)v4 + v12 - 8));
            v12 -= 8;
            if ((result & 1) == 0)
            {
              uint64_t v13 = (uint64_t *)((char *)v4 + v12 + 8);
              goto LABEL_10;
            }
          }
          uint64_t v13 = v4;
LABEL_10:
          *uint64_t v13 = v11;
        }
        uint64_t v5 = v8 + 1;
        v7 += 8;
      }
      while (v8 + 1 != a2);
    }
  }
  return result;
}

uint64_t *sub_1CD3575C8(uint64_t *result, uint64_t *a2, uint64_t *a3)
{
  if (result != a2)
  {
    uint64_t v4 = result;
    for (uint64_t i = result + 1; v4 + 1 != a2; uint64_t i = v4 + 1)
    {
      uint64_t v8 = *v4;
      uint64_t v7 = v4[1];
      uint64_t v4 = i;
      uint64_t result = (uint64_t *)sub_1CD8EF2D4(a3, v7, v8);
      if (result)
      {
        uint64_t v9 = *v4;
        uint64_t v10 = v4;
        do
        {
          uint64_t v11 = v10;
          uint64_t v12 = *--v10;
          uint64_t *v11 = v12;
          uint64_t result = (uint64_t *)sub_1CD8EF2D4(a3, v9, *(v11 - 2));
        }
        while ((result & 1) != 0);
        uint64_t *v10 = v9;
      }
    }
  }
  return result;
}

uint64_t sub_1CD357664(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  BOOL v8 = sub_1CD8EF2D4(a4, *a2, *a1);
  uint64_t result = sub_1CD8EF2D4(a4, *a3, *a2);
  if (v8)
  {
    uint64_t v10 = *a1;
    if (result)
    {
      *a1 = *a3;
      *a3 = v10;
      return 1;
    }
    *a1 = *a2;
    *a2 = v10;
    if (!sub_1CD8EF2D4(a4, *a3, v10)) {
      return 1;
    }
    uint64_t v11 = *a2;
    *a2 = *a3;
    *a3 = v11;
    return 2;
  }
  if (result)
  {
    uint64_t v12 = *a2;
    *a2 = *a3;
    *a3 = v12;
    if (!sub_1CD8EF2D4(a4, *a2, *a1)) {
      return 1;
    }
    uint64_t v13 = *a1;
    *a1 = *a2;
    *a2 = v13;
    return 2;
  }
  return result;
}

uint64_t *sub_1CD357754(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v4 = a2;
  uint64_t v6 = *a1;
  if (sub_1CD8EF2D4(a3, *a1, *(a2 - 1)))
  {
    uint64_t v7 = a1;
    do
    {
      uint64_t v8 = v7[1];
      ++v7;
    }
    while (!sub_1CD8EF2D4(a3, v6, v8));
  }
  else
  {
    uint64_t v14 = a1 + 1;
    do
    {
      uint64_t v7 = v14;
      if (v14 >= v4) {
        break;
      }
      ++v14;
    }
    while (!sub_1CD8EF2D4(a3, v6, *v7));
  }
  if (v7 < v4)
  {
    do
      uint64_t v9 = *--v4;
    while (sub_1CD8EF2D4(a3, v6, v9));
  }
  while (v7 < v4)
  {
    uint64_t v10 = *v7;
    *uint64_t v7 = *v4;
    uint64_t *v4 = v10;
    do
    {
      uint64_t v11 = v7[1];
      ++v7;
    }
    while (!sub_1CD8EF2D4(a3, v6, v11));
    do
      uint64_t v12 = *--v4;
    while (sub_1CD8EF2D4(a3, v6, v12));
  }
  if (v7 - 1 != a1) {
    *a1 = *(v7 - 1);
  }
  *(v7 - 1) = v6;
  return v7;
}

uint64_t *sub_1CD357864(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = *a1;
  while (sub_1CD8EF2D4(a3, a1[++v6], v7))
    ;
  uint64_t v9 = &a1[v6];
  uint64_t v10 = &a1[v6 - 1];
  if (v6 == 1)
  {
    do
    {
      if (v9 >= a2) {
        break;
      }
      uint64_t v12 = *--a2;
    }
    while (!sub_1CD8EF2D4(a3, v12, v7));
  }
  else
  {
    do
      uint64_t v11 = *--a2;
    while (!sub_1CD8EF2D4(a3, v11, v7));
  }
  if (v9 < a2)
  {
    uint64_t v13 = &a1[v6];
    uint64_t v14 = a2;
    do
    {
      uint64_t v15 = *v13;
      *uint64_t v13 = *v14;
      *uint64_t v14 = v15;
      do
      {
        uint64_t v16 = v13[1];
        ++v13;
      }
      while (sub_1CD8EF2D4(a3, v16, v7));
      do
        uint64_t v17 = *--v14;
      while (!sub_1CD8EF2D4(a3, v17, v7));
    }
    while (v13 < v14);
    uint64_t v10 = v13 - 1;
  }
  if (v10 != a1) {
    *a1 = *v10;
  }
  uint64_t *v10 = v7;
  return v10;
}

BOOL sub_1CD357980(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (sub_1CD8EF2D4(a3, *(a2 - 1), *a1))
      {
        uint64_t v16 = *a1;
        *a1 = *(a2 - 1);
        *(a2 - 1) = v16;
      }
      return 1;
    case 3:
      sub_1CD357664(a1, a1 + 1, a2 - 1, a3);
      return 1;
    case 4:
      sub_1CD357B4C(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      sub_1CD357C04(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return 1;
    default:
      uint64_t v8 = a1 + 2;
      sub_1CD357664(a1, a1 + 1, a1 + 2, a3);
      uint64_t v9 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      uint64_t v10 = 0;
      int v11 = 0;
      break;
  }
  while (1)
  {
    if (sub_1CD8EF2D4(a3, *v9, *v8))
    {
      uint64_t v12 = *v9;
      uint64_t v13 = v10;
      while (1)
      {
        uint64_t v14 = (char *)a1 + v13;
        *(uint64_t *)((char *)a1 + v13 + 24) = *(uint64_t *)((char *)a1 + v13 + 16);
        if (v13 == -16) {
          break;
        }
        v13 -= 8;
        if (!sub_1CD8EF2D4(a3, v12, *((void *)v14 + 1)))
        {
          uint64_t v15 = (uint64_t *)((char *)a1 + v13 + 24);
          goto LABEL_11;
        }
      }
      uint64_t v15 = a1;
LABEL_11:
      *uint64_t v15 = v12;
      if (++v11 == 8) {
        return v9 + 1 == a2;
      }
    }
    uint64_t v8 = v9;
    v10 += 8;
    BOOL result = 1;
    if (++v9 == a2) {
      return result;
    }
  }
}

BOOL sub_1CD357B4C(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  sub_1CD357664(a1, a2, a3, a5);
  BOOL result = sub_1CD8EF2D4(a5, *a4, *a3);
  if (result)
  {
    uint64_t v11 = *a3;
    *a3 = *a4;
    *a4 = v11;
    BOOL result = sub_1CD8EF2D4(a5, *a3, *a2);
    if (result)
    {
      uint64_t v12 = *a2;
      *a2 = *a3;
      *a3 = v12;
      BOOL result = sub_1CD8EF2D4(a5, *a2, *a1);
      if (result)
      {
        uint64_t v13 = *a1;
        *a1 = *a2;
        *a2 = v13;
      }
    }
  }
  return result;
}

BOOL sub_1CD357C04(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  sub_1CD357B4C(a1, a2, a3, a4, a6);
  BOOL result = sub_1CD8EF2D4(a6, *a5, *a4);
  if (result)
  {
    uint64_t v13 = *a4;
    *a4 = *a5;
    *a5 = v13;
    BOOL result = sub_1CD8EF2D4(a6, *a4, *a3);
    if (result)
    {
      uint64_t v14 = *a3;
      *a3 = *a4;
      *a4 = v14;
      BOOL result = sub_1CD8EF2D4(a6, *a3, *a2);
      if (result)
      {
        uint64_t v15 = *a2;
        *a2 = *a3;
        *a3 = v15;
        BOOL result = sub_1CD8EF2D4(a6, *a2, *a1);
        if (result)
        {
          uint64_t v16 = *a1;
          *a1 = *a2;
          *a2 = v16;
        }
      }
    }
  }
  return result;
}

uint64_t *sub_1CD357CE4(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  if (a1 != a2)
  {
    uint64_t v8 = (char *)a2 - (char *)a1;
    uint64_t v9 = a2 - a1;
    if ((char *)a2 - (char *)a1 >= 9)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      uint64_t v12 = &a1[v10];
      do
      {
        sub_1CD357E38((BOOL)a1, a4, v9, v12--);
        --v11;
      }
      while (v11);
    }
    uint64_t v13 = a2;
    if (a2 != a3)
    {
      uint64_t v14 = a2;
      do
      {
        if (sub_1CD8EF2D4(a4, *v14, *a1))
        {
          uint64_t v15 = *v14;
          *uint64_t v14 = *a1;
          *a1 = v15;
          sub_1CD357E38((BOOL)a1, a4, v9, a1);
        }
        ++v14;
      }
      while (v14 != a3);
      uint64_t v13 = a3;
    }
    if (v8 >= 9)
    {
      uint64_t v16 = a2 - 1;
      do
      {
        uint64_t v17 = *a1;
        unint64_t v18 = sub_1CD357F64(a1, a4, v9);
        if (v16 == v18)
        {
          *unint64_t v18 = v17;
        }
        else
        {
          *unint64_t v18 = *v16;
          uint64_t *v16 = v17;
          sub_1CD35801C((BOOL)a1, (uint64_t)(v18 + 1), a4, v18 + 1 - a1);
        }
        --v16;
      }
      while (v9-- > 2);
    }
    return v13;
  }
  return a3;
}

BOOL sub_1CD357E38(BOOL result, uint64_t *a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v4 = a3 - 2;
  if (a3 >= 2)
  {
    uint64_t v5 = a4;
    BOOL v6 = result;
    int64_t v7 = v4 >> 1;
    if ((uint64_t)(v4 >> 1) >= ((uint64_t)a4 - result) >> 3)
    {
      uint64_t v10 = ((uint64_t)a4 - result) >> 2;
      uint64_t v11 = v10 + 1;
      uint64_t v12 = (uint64_t *)(result + 8 * (v10 + 1));
      uint64_t v13 = v10 + 2;
      if (v10 + 2 < a3 && sub_1CD8EF2D4(a2, *v12, v12[1]))
      {
        ++v12;
        uint64_t v11 = v13;
      }
      BOOL result = sub_1CD8EF2D4(a2, *v12, *v5);
      if (!result)
      {
        uint64_t v14 = *v5;
        do
        {
          uint64_t v15 = v12;
          uint64_t *v5 = *v12;
          if (v7 < v11) {
            break;
          }
          uint64_t v16 = (2 * v11) | 1;
          uint64_t v12 = (uint64_t *)(v6 + 8 * v16);
          if (2 * v11 + 2 < a3 && sub_1CD8EF2D4(a2, *v12, v12[1]))
          {
            ++v12;
            uint64_t v16 = 2 * v11 + 2;
          }
          BOOL result = sub_1CD8EF2D4(a2, *v12, v14);
          uint64_t v5 = v15;
          uint64_t v11 = v16;
        }
        while (!result);
        *uint64_t v15 = v14;
      }
    }
  }
  return result;
}

uint64_t *sub_1CD357F64(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = a3 - 2;
  if (a3 < 2) {
    uint64_t v7 = a3 - 1;
  }
  uint64_t v8 = v7 >> 1;
  do
  {
    uint64_t v9 = &a1[v6 + 1];
    uint64_t v10 = (2 * v6) | 1;
    uint64_t v11 = 2 * v6 + 2;
    if (v11 < a3 && sub_1CD8EF2D4(a2, *v9, a1[v6 + 2]))
    {
      ++v9;
      uint64_t v10 = v11;
    }
    *a1 = *v9;
    a1 = v9;
    uint64_t v6 = v10;
  }
  while (v10 <= v8);
  return v9;
}

BOOL sub_1CD35801C(BOOL result, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  unint64_t v4 = a4 - 2;
  if (a4 >= 2)
  {
    BOOL v6 = result;
    unint64_t v7 = v4 >> 1;
    uint64_t v8 = (uint64_t *)(result + 8 * (v4 >> 1));
    uint64_t v9 = (uint64_t *)(a2 - 8);
    BOOL result = sub_1CD8EF2D4(a3, *v8, *(void *)(a2 - 8));
    if (result)
    {
      uint64_t v10 = *v9;
      do
      {
        uint64_t v11 = v8;
        *uint64_t v9 = *v8;
        if (!v7) {
          break;
        }
        unint64_t v7 = (v7 - 1) >> 1;
        uint64_t v8 = (uint64_t *)(v6 + 8 * v7);
        BOOL result = sub_1CD8EF2D4(a3, *v8, v10);
        uint64_t v9 = v11;
      }
      while (result);
      uint64_t *v11 = v10;
    }
  }
  return result;
}

uint64_t *sub_1CD3580C4(uint64_t *result, uint64_t *a2, uint64_t *a3)
{
  unint64_t v4 = result;
  result[1] = 0;
  uint64_t v5 = *((unsigned int *)result + 4);
  if (v5)
  {
    BOOL v6 = (void *)*result;
    uint64_t v7 = 16 * v5;
    do
    {
      void *v6 = -4096;
      v6 += 2;
      v7 -= 16;
    }
    while (v7);
  }
  if (a2 != a3)
  {
    uint64_t v8 = a2 + 1;
    do
    {
      if ((*(v8 - 1) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t v12 = 0;
        sub_1CD3C8538(v4, v8 - 1, &v12);
        uint64_t v10 = v12;
        void *v12 = *(v8 - 1);
        uint64_t v11 = *v8;
        *uint64_t v8 = 0;
        v10[1] = v11;
        ++*((_DWORD *)v4 + 2);
        BOOL result = sub_1CB9313C0(v8);
      }
      uint64_t v9 = v8 + 1;
      v8 += 2;
    }
    while (v9 != a3);
  }
  return result;
}

uint64_t sub_1CD358190(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v9 = 0;
  uint64_t v10 = a2;
  if (!sub_1CD3C8538((uint64_t *)(a3 + 24), &v10, &v9)
    || v9 == *(void *)(a3 + 24) + 16 * *(unsigned int *)(a3 + 40)
    || (uint64_t result = *(void *)(v9 + 8)) == 0)
  {
    uint64_t v7 = sub_1CD358250(a1 + 24, a2);
    if (*(void *)(a1 + 24) + 72 * *(unsigned int *)(a1 + 40) == v7) {
      uint64_t v8 = 0;
    }
    else {
      uint64_t v8 = *(void *)(v7 + 32);
    }
    sub_1CD358190(a1, v8, a3);
    sub_1CD8EF694(a3, a2);
  }
  return result;
}

uint64_t sub_1CD358250(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = 0;
  uint64_t v5 = a2;
  if (sub_1CD8EE89C((uint64_t *)a1, &v5, &v4)) {
    return v4;
  }
  else {
    return *(void *)a1 + 72 * *(unsigned int *)(a1 + 16);
  }
}

uint64_t *sub_1CD3582B8(uint64_t a1, uint64_t *a2)
{
  uint64_t v8 = 0;
  char v4 = sub_1CBB0BF40(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  uint64_t result = v8;
  if (v4) {
    return result;
  }
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
    goto LABEL_9;
  }
  if (v7 + ~v6 - *(_DWORD *)(a1 + 12) <= v7 >> 3)
  {
LABEL_9:
    sub_1CD24C20C(a1, v7);
    uint64_t v8 = 0;
    sub_1CBB0BF40(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
    uint64_t result = v8;
  }
  ++*(_DWORD *)(a1 + 8);
  if (*result != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  *uint64_t result = *a2;
  result[1] = 0;
  return result;
}

_DWORD *sub_1CD358394(uint64_t *a1, int a2)
{
  uint64_t v3 = *((unsigned int *)a1 + 4);
  char v4 = (int *)*a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *((_DWORD *)a1 + 4) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *a1 = (uint64_t)result;
  if (v4)
  {
    a1[1] = 0;
    uint64_t v10 = *((unsigned int *)a1 + 4);
    if (v10)
    {
      uint64_t v11 = 16 * v10;
      do
      {
        *uint64_t result = 0x7FFFFFFF;
        result += 4;
        v11 -= 16;
      }
      while (v11);
    }
    if (v3)
    {
      uint64_t v12 = v4;
      do
      {
        int v13 = *v12;
        if ((*v12 - 0x7FFFFFFF) >= 2)
        {
          int v14 = *((_DWORD *)a1 + 4) - 1;
          unsigned int v15 = v14 & (37 * v13);
          uint64_t v16 = *a1 + 16 * v15;
          int v17 = *(_DWORD *)v16;
          if (v13 != *(_DWORD *)v16)
          {
            uint64_t v18 = 0;
            int v19 = 1;
            while (v17 != 0x7FFFFFFF)
            {
              if (v18) {
                BOOL v20 = 0;
              }
              else {
                BOOL v20 = v17 == 0x80000000;
              }
              if (v20) {
                uint64_t v18 = v16;
              }
              unsigned int v21 = v15 + v19++;
              unsigned int v15 = v21 & v14;
              uint64_t v16 = *a1 + 16 * (v21 & v14);
              int v17 = *(_DWORD *)v16;
              if (v13 == *(_DWORD *)v16) {
                goto LABEL_12;
              }
            }
            if (v18) {
              uint64_t v16 = v18;
            }
          }
LABEL_12:
          *(_DWORD *)uint64_t v16 = v13;
          *(void *)(v16 + 8) = *((void *)v12 + 1);
          ++*((_DWORD *)a1 + 2);
        }
        v12 += 4;
      }
      while (v12 != &v4[4 * v3]);
    }
    JUMPOUT(0x1D25D9CD0);
  }
  a1[1] = 0;
  uint64_t v22 = *((unsigned int *)a1 + 4);
  if (v22)
  {
    uint64_t v23 = 16 * v22;
    do
    {
      *uint64_t result = 0x7FFFFFFF;
      result += 4;
      v23 -= 16;
    }
    while (v23);
  }
  return result;
}

void sub_1CD358530(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char v4 = (llvm::SmallPtrSetImplBase *)MEMORY[0x1F4188790](a1, a2, a3, a4);
  unint64_t v6 = v5;
  unsigned int v8 = v7;
  v108[24] = *MEMORY[0x1E4F143B8];
  sub_1CD8EFD88((const void **)&v30, v4);
  sub_1CD8EFD88((const void **)&v26, v8);
  sub_1CD8EFBD0((uint64_t)&v42, (uint64_t)&v30);
  sub_1CD8EFBD0((uint64_t)&v38, (uint64_t)&v26);
  sub_1CD8EFBD0((uint64_t)&v50, (uint64_t)&v42);
  sub_1CD8EFBD0((uint64_t)&v46, (uint64_t)&v38);
  sub_1CD8EFD88((const void **)&v85, (llvm::SmallPtrSetImplBase *)&v50);
  sub_1CD8EFBD0((uint64_t)&v81, (uint64_t)&v46);
  sub_1CD8EFBD0((uint64_t)&v34, (uint64_t)&v85);
  sub_1CD8EFD88((const void **)&v89, (llvm::SmallPtrSetImplBase *)&v34);
  sub_1CD8EFBD0((uint64_t)&v76, (uint64_t)&v89);
  if (v91 != v92) {
    free(v91);
  }
  if (v90 != v89) {
    free(v90);
  }
  sub_1CD8EFBD0((uint64_t)&v101, (uint64_t)&v81);
  sub_1CD8EFD88((const void **)&v89, (llvm::SmallPtrSetImplBase *)&v101);
  sub_1CD8EFBD0((uint64_t)&v105, (uint64_t)&v89);
  if (v91 != v92) {
    free(v91);
  }
  if (v90 != v89) {
    free(v90);
  }
  sub_1CD8EFBD0((uint64_t)&v89, (uint64_t)&v76);
  sub_1CD8EFBD0((uint64_t)&v93, (uint64_t)&v105);
  if (v107 != v108) {
    free(v107);
  }
  if (v106 != v105) {
    free(v106);
  }
  if (v103 != v104) {
    free(v103);
  }
  if (v102 != v101) {
    free(v102);
  }
  if (v78 != v79) {
    free(v78);
  }
  if (v77 != v76) {
    free(v77);
  }
  if (v36 != v37) {
    free(v36);
  }
  if (v35 != v34) {
    free(v35);
  }
  if (v83 != &v84) {
    free(v83);
  }
  if (v82 != v81) {
    free(v82);
  }
  if (v87 != &v88) {
    free(v87);
  }
  if (v86 != v85) {
    free(v86);
  }
  sub_1CD8EFBD0((uint64_t)&v71, (uint64_t)&v89);
  sub_1CD8EFBD0((uint64_t)&v66, (uint64_t)&v93);
  while (1)
  {
    unsigned int v9 = v74;
    if (v74 != v69) {
      goto LABEL_45;
    }
    if (!v74) {
      break;
    }
    uint64_t v10 = v68;
    uint64_t v11 = v73;
    while (*v11 == *v10)
    {
      if (v11[1] != v10[1] || v11[2] != v10[2]) {
        break;
      }
      v11 += 3;
      v10 += 3;
      if (v11 == (void *)((char *)v73 + 24 * v74)) {
        goto LABEL_64;
      }
    }
LABEL_45:
    int v13 = (char *)v73 + 24 * v74;
    unsigned int v15 = v6[1];
    unint64_t v14 = (unint64_t)v6[2];
    if ((unint64_t)v15 >= v14)
    {
      int v17 = *v6;
      uint64_t v18 = (v15 - *v6) >> 3;
      unint64_t v19 = v18 + 1;
      if ((unint64_t)(v18 + 1) >> 61) {
        abort();
      }
      uint64_t v20 = v14 - (void)v17;
      if (v20 >> 2 > v19) {
        unint64_t v19 = v20 >> 2;
      }
      if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v21 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v21 = v19;
      }
      if (v21)
      {
        if (v21 >> 61) {
          sub_1CB833614();
        }
        uint64_t v22 = (char *)operator new(8 * v21);
      }
      else
      {
        uint64_t v22 = 0;
      }
      uint64_t v23 = &v22[8 * v18];
      *(void *)uint64_t v23 = *((void *)v13 - 3);
      uint64_t v16 = v23 + 8;
      if (v15 != v17)
      {
        do
        {
          uint64_t v24 = *((void *)v15 - 1);
          v15 -= 8;
          *((void *)v23 - 1) = v24;
          v23 -= 8;
        }
        while (v15 != v17);
        unsigned int v15 = *v6;
      }
      void *v6 = v23;
      v6[1] = v16;
      unsigned char v6[2] = &v22[8 * v21];
      if (v15)
      {
        operator delete(v15);
        unsigned int v9 = v74;
      }
    }
    else
    {
      *(void *)unsigned int v15 = *((void *)v13 - 3);
      uint64_t v16 = v15 + 8;
    }
    v6[1] = v16;
    unsigned int v74 = v9 - 1;
    if (v9 != 1) {
      sub_1CD8EF984((uint64_t)&v71);
    }
  }
LABEL_64:
  sub_1CD8EFBD0((uint64_t)&v76, (uint64_t)&v71);
  unsigned int v80 = v6;
  if (v68 != &v70) {
    free(v68);
  }
  if (v67 != v66) {
    free(v67);
  }
  if (v73 != &v75) {
    free(v73);
  }
  if (v72 != v71) {
    free(v72);
  }
  sub_1CD8EFBD0((uint64_t)&v58, (uint64_t)&v50);
  sub_1CD8EFBD0((uint64_t)&v54, (uint64_t)&v76);
  sub_1CD8EFBD0((uint64_t)&v101, (uint64_t)&v58);
  sub_1CD8EFBD0((uint64_t)&v97, (uint64_t)&v54);
  sub_1CD8EFBD0((uint64_t)&v34, (uint64_t)&v101);
  sub_1CD8EFBD0((uint64_t)&v105, (uint64_t)&v97);
  sub_1CD8EFBD0((uint64_t)&v62, (uint64_t)&v105);
  if (v107 != v108) {
    free(v107);
  }
  if (v106 != v105) {
    free(v106);
  }
  if (v36 != v37) {
    free(v36);
  }
  if (v35 != v34) {
    free(v35);
  }
  if (v99 != &v100) {
    free(v99);
  }
  if (v98 != v97) {
    free(v98);
  }
  if (v103 != v104) {
    free(v103);
  }
  if (v102 != v101) {
    free(v102);
  }
  uint64_t v25 = v80;
  sub_1CD8EFBD0((uint64_t)&v34, (uint64_t)&v62);
  v37[24] = v25;
  if (v64 != &v65) {
    free(v64);
  }
  if (v63 != v62) {
    free(v63);
  }
  if (v56 != &v57) {
    free(v56);
  }
  if (v55 != v54) {
    free(v55);
  }
  if (v60 != &v61) {
    free(v60);
  }
  if (v59 != v58) {
    free(v59);
  }
  if (v78 != v79) {
    free(v78);
  }
  if (v77 != v76) {
    free(v77);
  }
  if (v95 != &v96) {
    free(v95);
  }
  if (v94 != v93) {
    free(v94);
  }
  if (v91 != v92) {
    free(v91);
  }
  if (v90 != v89) {
    free(v90);
  }
  if (v48 != &v49) {
    free(v48);
  }
  if (v47 != v46) {
    free(v47);
  }
  if (v52 != &v53) {
    free(v52);
  }
  if (v51 != v50) {
    free(v51);
  }
  if (v40 != &v41) {
    free(v40);
  }
  if (v39 != v38) {
    free(v39);
  }
  if (v44 != &v45) {
    free(v44);
  }
  if (v43 != v42) {
    free(v43);
  }
  if (v36 != v37) {
    free(v36);
  }
  if (v35 != v34) {
    free(v35);
  }
  if (v28 != &v29) {
    free(v28);
  }
  if (v27 != v26) {
    free(v27);
  }
  if (v32 != &v33) {
    free(v32);
  }
  if (v31 != v30) {
    free(v31);
  }
}

void **sub_1CD358D6C(uint64_t a1, uint64_t a2)
{
  v90[30] = *MEMORY[0x1E4F143B8];
  uint64_t v70 = *(uint64_t **)(a2 + 48);
  sub_1CD4B8CB4((uint64_t)v89, (uint64_t)v70);
  sub_1CD4BAE30((const void **)&v84, (llvm::SmallPtrSetImplBase *)v89);
  sub_1CD4BAE30((const void **)&v79, (llvm::SmallPtrSetImplBase *)v90);
  while (1)
  {
    if (v87 != v82) {
      goto LABEL_12;
    }
    if (!v87) {
      break;
    }
    char v4 = v81;
    unint64_t v5 = v86;
    while (*v5 == *v4 && v5[1] == v4[1])
    {
      v5 += 2;
      v4 += 2;
      if (v5 == (void *)((char *)v86 + 16 * v87)) {
        goto LABEL_111;
      }
    }
LABEL_12:
    uint64_t v7 = **((void **)v86 + 2 * v87 - 2);
    __int16 v76 = v78;
    uint64_t v77 = 0x400000000;
    uint64_t v8 = *(unsigned int *)(v7 + 56);
    if (!v8) {
      goto LABEL_22;
    }
    unsigned int v9 = *(uint64_t **)(v7 + 48);
    uint64_t v10 = 8 * v8;
    do
    {
      uint64_t v11 = *v9;
      if (sub_1CD8F0590(a2, v7, *v9) && sub_1CD359A90(a2, v11))
      {
        if (v77 >= (unint64_t)HIDWORD(v77)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v76 + v77) = v11;
        LODWORD(v77) = v77 + 1;
      }
      ++v9;
      v10 -= 8;
    }
    while (v10);
    if (!v77) {
      goto LABEL_22;
    }
    *(void *)(a1 + 128) += 152;
    uint64_t v12 = *(void *)(a1 + 48);
    if (((v12 + 7) & 0xFFFFFFFFFFFFFFF8) - v12 + 152 > *(void *)(a1 + 56) - v12)
    {
      unsigned int v62 = *(_DWORD *)(a1 + 72) >> 7;
      if (v62 >= 0x1E) {
        LOBYTE(v62) = 30;
      }
      uint64_t v63 = 4096 << v62;
      uint64_t v13 = (uint64_t)operator new(4096 << v62, (std::align_val_t)8uLL);
      unint64_t v64 = *(unsigned int *)(a1 + 72);
      if (v64 >= *(unsigned int *)(a1 + 76)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(a1 + 64) + 8 * v64) = v13;
      ++*(_DWORD *)(a1 + 72);
      *(void *)(a1 + 56) = v13 + v63;
    }
    else
    {
      uint64_t v13 = (v12 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    *(void *)(a1 + 48) = v13 + 152;
    sub_1CD8F0A08(v13, v7);
    uint64_t v14 = v77;
    if (v77)
    {
      int v17 = v76;
      size_t v18 = 8 * v77;
      unint64_t v19 = (char *)operator new(v18);
      uint64_t v20 = &v19[8 * v14];
      memmove(v19, v17, v18);
      unsigned int v16 = 0;
      unsigned int v72 = 0;
      uint64_t i = v20;
      uint64_t v71 = v13;
      while (1)
      {
        uint64_t v22 = i - 8;
        uint64_t v21 = *((void *)i - 1);
        uint64_t v74 = 0;
        uint64_t v75 = (void *)v21;
        if ((sub_1CD3C8538((uint64_t *)a1, &v75, &v74) & 1) != 0 && (uint64_t v23 = *(uint64_t **)(v74 + 8)) != 0)
        {
          do
          {
            uint64_t v24 = v23;
            uint64_t v23 = (uint64_t *)*v23;
          }
          while (v23);
          if (v24 != (uint64_t *)v13)
          {
            uint64_t *v24 = v13;
            ++v72;
            uint64_t v25 = (uint64_t *)v24[4];
            v16 += (unint64_t)(v24[6] - (void)v25) >> 3;
            uint64_t v26 = *v25;
            uint64_t v27 = *(unsigned int *)(v26 + 56);
            if (v27)
            {
              unsigned int v73 = v16;
              uint64_t v28 = *(void **)(v26 + 48);
              uint64_t v29 = &v28[v27];
              do
              {
                uint64_t v30 = (void *)*v28;
                uint64_t v74 = 0;
                uint64_t v75 = v30;
                int v31 = sub_1CD3C8538((uint64_t *)a1, &v75, &v74);
                uint64_t v32 = 0;
                if (v31) {
                  uint64_t v32 = *(uint64_t **)(v74 + 8);
                }
                if (v32 != v24)
                {
                  if (v22 >= v20)
                  {
                    uint64_t v33 = (v22 - v19) >> 3;
                    unint64_t v34 = v33 + 1;
                    if ((unint64_t)(v33 + 1) >> 61) {
                      goto LABEL_120;
                    }
                    if ((v20 - v19) >> 2 > v34) {
                      unint64_t v34 = (v20 - v19) >> 2;
                    }
                    if ((unint64_t)(v20 - v19) >= 0x7FFFFFFFFFFFFFF8) {
                      unint64_t v35 = 0x1FFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v35 = v34;
                    }
                    if (v35)
                    {
                      if (v35 >> 61) {
                        goto LABEL_121;
                      }
                      unint64_t v36 = (char *)operator new(8 * v35);
                    }
                    else
                    {
                      unint64_t v36 = 0;
                    }
                    uint64_t v37 = &v36[8 * v33];
                    *(void *)uint64_t v37 = v30;
                    int v38 = v37 + 8;
                    if (v22 != v19)
                    {
                      do
                      {
                        uint64_t v39 = *((void *)v22 - 1);
                        v22 -= 8;
                        *((void *)v37 - 1) = v39;
                        v37 -= 8;
                      }
                      while (v22 != v19);
                      uint64_t v22 = v19;
                    }
                    unint64_t v19 = v37;
                    uint64_t v20 = &v36[8 * v35];
                    if (v22) {
                      operator delete(v22);
                    }
                    uint64_t v22 = v38;
                  }
                  else
                  {
                    *(void *)uint64_t v22 = v30;
                    v22 += 8;
                  }
                }
                ++v28;
              }
              while (v28 != v29);
              uint64_t i = v22;
              goto LABEL_66;
            }
          }
        }
        else if (sub_1CD359A90(a2, v21))
        {
          uint64_t v74 = v21;
          if (v13)
          {
            sub_1CD550B40((uint64_t *)a1, &v74)[1] = v13;
          }
          else
          {
            uint64_t v75 = 0;
            if (sub_1CD3C8538((uint64_t *)a1, &v74, &v75))
            {
              *uint64_t v75 = -8192;
              *(int32x2_t *)(a1 + 8) = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
            }
          }
          ++v16;
          if (v21 != **(void **)(v13 + 32))
          {
            unsigned int v73 = v16;
            uint64_t v40 = *(unsigned int *)(v21 + 56);
            if (!v40)
            {
              i -= 8;
              goto LABEL_102;
            }
            uint64_t v41 = *(char **)(v21 + 48);
            uint64_t v42 = v22 - v19;
            uint64_t v43 = &v19[(v22 - v19) & 0xFFFFFFFFFFFFFFF8];
            if (v40 > (v20 - v22) >> 3)
            {
              uint64_t v44 = v42 >> 3;
              unint64_t v45 = (v42 >> 3) + v40;
              if (v45 >> 61) {
LABEL_120:
              }
                abort();
              if ((v20 - v19) >> 2 > v45) {
                unint64_t v45 = (v20 - v19) >> 2;
              }
              unint64_t v46 = 0x1FFFFFFFFFFFFFFFLL;
              if ((unint64_t)(v20 - v19) < 0x7FFFFFFFFFFFFFF8) {
                unint64_t v46 = v45;
              }
              unint64_t __src = v46;
              if (v46)
              {
                if (v46 >> 61) {
LABEL_121:
                }
                  sub_1CB833614();
                uint64_t v56 = v41;
                uint64_t v47 = (char *)operator new(8 * v46);
                uint64_t v41 = v56;
              }
              else
              {
                uint64_t v47 = 0;
              }
              uint64_t v57 = &v47[8 * v44];
              memcpy(v57, v41, 8 * v40);
              if ((unint64_t)v42 >= 8)
              {
                uint64_t v58 = 8 * v44;
                do
                {
                  *(void *)&v47[v58 - 8] = *(void *)&v19[v58 - 8];
                  v58 -= 8;
                }
                while (v58);
                uint64_t v57 = v47;
              }
              BOOL v67 = v57;
              unint64_t v59 = (v42 & 0xFFFFFFFFFFFFFFF8) + 8 * v40;
              uint64_t v60 = &v47[v59];
              size_t v61 = v22 - v43;
              if (v61) {
                memmove(&v47[v59], v43, v61);
              }
              uint64_t v20 = &v47[8 * __src];
              uint64_t i = &v60[v61];
              uint64_t v13 = v71;
              if (v19) {
                operator delete(v19);
              }
              unint64_t v19 = v67;
              goto LABEL_102;
            }
            int v48 = &v41[8 * v40];
            __srca = &v19[(v22 - v19) & 0xFFFFFFFFFFFFFFF8];
            uint64_t v49 = v22 - v43;
            if (v49 >> 3 >= v40)
            {
              unsigned int v51 = i - 8;
              goto LABEL_84;
            }
            int v66 = v41;
            char v50 = &v41[8 * (v49 >> 3)];
            memmove(i - 8, v50, v48 - v50);
            unsigned int v51 = &v22[v48 - v50];
            if (v49 >= 1)
            {
              int v48 = v50;
              uint64_t v41 = v66;
LABEL_84:
              uint64_t v52 = &v51[-8 * v40];
              for (uint64_t i = v51; v52 < v22; i += 8)
              {
                uint64_t v53 = *(void *)v52;
                v52 += 8;
                *(void *)uint64_t i = v53;
              }
              unsigned int v54 = &__srca[8 * v40];
              if (v51 != v54)
              {
                int v55 = v41;
                memmove(&v51[-8 * ((v51 - v54) >> 3)], __srca, v51 - v54);
                uint64_t v41 = v55;
              }
              unsigned int v16 = v73;
              if (v48 != v41) {
                memmove(__srca, v41, v48 - v41);
              }
              uint64_t v13 = v71;
              goto LABEL_103;
            }
            uint64_t i = &v22[v48 - v50];
LABEL_66:
            uint64_t v13 = v71;
LABEL_102:
            unsigned int v16 = v73;
            goto LABEL_103;
          }
        }
        i -= 8;
LABEL_103:
        if (v19 == i) {
          goto LABEL_30;
        }
      }
    }
    uint64_t i = 0;
    unsigned int v72 = 0;
    unsigned int v16 = 0;
LABEL_30:
    sub_1CD45A1D4(v13 + 8, v72);
    sub_1CD45A1D4(v13 + 32, v16);
    if (i) {
      operator delete(i);
    }
LABEL_22:
    if (v76 != v78) {
      free(v76);
    }
    if (--v87) {
      sub_1CD4BAD50(&v84);
    }
  }
LABEL_111:
  if (v81 != &v83) {
    free(v81);
  }
  if (v80 != v79) {
    free(v80);
  }
  if (v86 != &v88) {
    free(v86);
  }
  if (v85 != v84) {
    free(v85);
  }
  sub_1CD4B9AEC(v89);
  v89[0] = (void *)a1;
  return sub_1CD8F0680((uint64_t **)v89, *v70);
}

uint64_t sub_1CD3594B4(uint64_t a1, uint64_t a2)
{
  v6[5] = a2;
  uint64_t v3 = a1 + 48;
  uint64_t v2 = *(void *)(a1 + 48);
  v6[0] = 0;
  if (sub_1CD40EA84(v2, *(_DWORD *)(v3 + 16), a2, v6)) {
    BOOL v4 = v6[0] == *(void *)v3 + 16 * *(unsigned int *)(v3 + 16);
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    operator new();
  }
  return *(void *)(v6[0] + 8);
}

uint64_t sub_1CD35960C(uint64_t result, uint64_t a2, uint64_t a3)
{
  v16[4] = *MEMORY[0x1E4F143B8];
  *(void *)(result + 32) = a2;
  *(void *)(result + 40) = a2 + 200;
  uint64_t v3 = result + 32;
  uint64_t v4 = a3 + 40;
  uint64_t v5 = *(void *)(a3 + 48);
  if (v5 != a3 + 40)
  {
    uint64_t v6 = result;
    while (1)
    {
      uint64_t v7 = v5 ? v5 - 24 : 0;
      int v8 = *(unsigned __int8 *)(v7 + 16);
      uint64_t v9 = v8 == 30 ? v7 : 0;
      if (!v5 || v8 != 30) {
        break;
      }
      if ((*(_DWORD *)(v9 + 20) & 0x7FFFFFF) == 3) {
        uint64_t result = sub_1CD3599F8(v6, *(void *)(v9 - 96));
      }
      uint64_t v5 = *(void *)(v5 + 8);
      if (v5 == v4) {
        return result;
      }
    }
    if (v5 && v8 == 83) {
      operator new();
    }
    unsigned int v15 = 0;
    int v10 = *(_DWORD *)(v7 + 20);
    if ((v10 & 0x40000000) != 0)
    {
      uint64_t v12 = *(uint64_t **)(v7 - 8);
      uint64_t v11 = v10 & 0x7FFFFFF;
      if (!v11) {
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v11 = v10 & 0x7FFFFFF;
      uint64_t v12 = (uint64_t *)(v7 - 32 * v11);
      if (!v11) {
        goto LABEL_26;
      }
    }
    uint64_t v13 = 32 * v11;
    do
    {
      uint64_t v14 = sub_1CD3599F8(v6, *v12);
      if (v15 >= 4uLL) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      v16[v15] = v14;
      LODWORD(v11) = ++v15;
      v12 += 4;
      v13 -= 32;
    }
    while (v13);
    int v8 = *(unsigned __int8 *)(v7 + 16);
LABEL_26:
    sub_1CD8D0908(v3, (v8 - 28), (uint64_t)v16, v11, v7);
  }
  return result;
}

void sub_1CD3598B0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v15[8] = *MEMORY[0x1E4F143B8];
  unsigned int v14 = 0;
  if (a3)
  {
    uint64_t v4 = a3;
    while (1)
    {
      uint64_t v6 = *(void *)(v4 + 24);
      unsigned int v7 = *(unsigned __int8 *)(v6 + 16);
      BOOL v8 = v6 && v7 >= 0x1C;
      if (v8 && v7 - 29 <= 0xA) {
        break;
      }
      uint64_t v4 = *(void *)(v4 + 8);
      if (!v4)
      {
        a3 = 0;
        goto LABEL_26;
      }
    }
LABEL_14:
    uint64_t v10 = sub_1CD3594B4(a1, *(void *)(v6 + 40));
    if (v14 >= 8uLL) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    v15[v14] = v10;
    a3 = ++v14;
    while (1)
    {
      uint64_t v4 = *(void *)(v4 + 8);
      if (!v4) {
        break;
      }
      uint64_t v6 = *(void *)(v4 + 24);
      unsigned int v11 = *(unsigned __int8 *)(v6 + 16);
      if (v6) {
        BOOL v12 = v11 >= 0x1C;
      }
      else {
        BOOL v12 = 0;
      }
      if (v12 && v11 - 29 < 0xB) {
        goto LABEL_14;
      }
    }
  }
LABEL_26:
  sub_1CD8D8B34(a2, v15, a3);
}

uint64_t sub_1CD3599F8(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = a2;
  uint64_t v8 = a2;
  uint64_t v4 = (uint64_t *)(a1 + 72);
  uint64_t v9 = 0;
  if (sub_1CD3C8538((uint64_t *)(a1 + 72), &v8, &v9)
    && v9 != *(void *)(a1 + 72) + 16 * *(unsigned int *)(a1 + 88))
  {
    return *(void *)(v9 + 8);
  }
  uint64_t v5 = sub_1CD8D2A38(*(void *)(a1 + 16), a2);
  sub_1CD4F8350(v4, &v7)[1] = v5;
  return v5;
}

BOOL sub_1CD359A90(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = 0;
  uint64_t v8 = a2;
  if (sub_1CD3C8538((uint64_t *)(a1 + 24), &v8, &v7))
  {
    uint64_t v3 = v7;
    uint64_t v4 = *(void *)(a1 + 24);
    uint64_t v5 = *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v4 = *(void *)(a1 + 24);
    uint64_t v5 = *(unsigned int *)(a1 + 40);
    uint64_t v3 = v4 + 16 * v5;
  }
  return v3 != v4 + 16 * v5 && *(void *)(v3 + 8) != 0;
}

void sub_1CD359B0C(uint64_t **a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  uint64_t v42 = 0;
  uint64_t v43 = a2;
  if ((sub_1CD3C8538(v4, &v43, &v42) & 1) == 0) {
    return;
  }
  uint64_t v5 = *(void *)(v42 + 8);
  if (!v5) {
    return;
  }
  if (**(void **)(v5 + 32) != a2) {
    goto LABEL_58;
  }
  uint64_t v6 = *(void **)v5;
  if (*(void *)v5)
  {
    uint64_t v8 = (uint64_t *)v6[2];
    unint64_t v7 = v6[3];
    if ((unint64_t)v8 < v7)
    {
      *uint64_t v8 = v5;
      uint64_t v9 = v8 + 1;
LABEL_33:
      unsigned char v6[2] = v9;
      goto LABEL_41;
    }
    unsigned int v14 = (void *)v6[1];
    uint64_t v15 = v8 - v14;
    unint64_t v16 = v15 + 1;
    if (!((unint64_t)(v15 + 1) >> 61))
    {
      uint64_t v17 = v7 - (void)v14;
      if (v17 >> 2 > v16) {
        unint64_t v16 = v17 >> 2;
      }
      if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v18 = v16;
      }
      if (!v18)
      {
        unint64_t v19 = 0;
        goto LABEL_28;
      }
      if (!(v18 >> 61))
      {
        unint64_t v19 = (char *)operator new(8 * v18);
LABEL_28:
        uint64_t v26 = (uint64_t *)&v19[8 * v15];
        *uint64_t v26 = v5;
        uint64_t v9 = v26 + 1;
        if (v8 != v14)
        {
          do
          {
            uint64_t v27 = *--v8;
            *--uint64_t v26 = v27;
          }
          while (v8 != v14);
          uint64_t v8 = (uint64_t *)v6[1];
        }
        v6[1] = v26;
        unsigned char v6[2] = v9;
        uint64_t v6[3] = &v19[8 * v18];
        if (v8) {
          operator delete(v8);
        }
        goto LABEL_33;
      }
LABEL_57:
      sub_1CB833614();
    }
LABEL_56:
    abort();
  }
  uint64_t v10 = *a1;
  BOOL v12 = (uint64_t *)(*a1)[4];
  unint64_t v11 = v10[5];
  if ((unint64_t)v12 >= v11)
  {
    uint64_t v20 = (void *)v10[3];
    uint64_t v21 = v12 - v20;
    unint64_t v22 = v21 + 1;
    if ((unint64_t)(v21 + 1) >> 61) {
      goto LABEL_56;
    }
    uint64_t v23 = v11 - (void)v20;
    if (v23 >> 2 > v22) {
      unint64_t v22 = v23 >> 2;
    }
    if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v24 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v24 = v22;
    }
    if (v24)
    {
      if (v24 >> 61) {
        goto LABEL_57;
      }
      uint64_t v25 = (char *)operator new(8 * v24);
    }
    else
    {
      uint64_t v25 = 0;
    }
    uint64_t v28 = (uint64_t *)&v25[8 * v21];
    *uint64_t v28 = v5;
    uint64_t v13 = v28 + 1;
    if (v12 != v20)
    {
      do
      {
        uint64_t v29 = *--v12;
        *--uint64_t v28 = v29;
      }
      while (v12 != v20);
      BOOL v12 = (uint64_t *)v10[3];
    }
    void v10[3] = (uint64_t)v28;
    v10[4] = (uint64_t)v13;
    v10[5] = (uint64_t)&v25[8 * v24];
    if (v12) {
      operator delete(v12);
    }
  }
  else
  {
    uint64_t *v12 = v5;
    uint64_t v13 = v12 + 1;
  }
  v10[4] = (uint64_t)v13;
LABEL_41:
  uint64_t v30 = *(void *)(v5 + 32);
  uint64_t v31 = *(void *)(v5 + 40);
  uint64_t v32 = (void *)(v31 - 8);
  BOOL v33 = v30 + 8 == v31 || v30 + 8 >= (unint64_t)v32;
  if (!v33)
  {
    unint64_t v34 = v30 + 16;
    do
    {
      uint64_t v35 = *(void *)(v34 - 8);
      *(void *)(v34 - 8) = *v32;
      *v32-- = v35;
      BOOL v33 = v34 >= (unint64_t)v32;
      v34 += 8;
    }
    while (!v33);
  }
  unint64_t v36 = *(void *)(v5 + 8);
  uint64_t v37 = *(void *)(v5 + 16);
  int v38 = (void *)(v37 - 8);
  if (v36 != v37 && v36 < (unint64_t)v38)
  {
    unint64_t v40 = v36 + 8;
    do
    {
      uint64_t v41 = *(void *)(v40 - 8);
      *(void *)(v40 - 8) = *v38;
      *v38-- = v41;
      BOOL v33 = v40 >= (unint64_t)v38;
      v40 += 8;
    }
    while (!v33);
  }
  while (1)
  {
    uint64_t v5 = *(void *)v5;
    if (!v5) {
      break;
    }
LABEL_58:
    sub_1CD8F0B90(v5, a2);
  }
}

uint64_t llvm::VPlanPredicator::getOrCreateNotPredicate(llvm::VPlanPredicator *this, llvm::VPBasicBlock *a2, llvm::VPBasicBlock *a3)
{
  if (*((_DWORD *)a2 + 28) == 1) {
    uint64_t v3 = **((void **)a2 + 13);
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = (llvm::VPBasicBlock **)*((void *)a2 + 9);
  uint64_t v5 = *v4;
  if (*v4 != a3)
  {
    uint64_t v6 = v4 + 1;
    uint64_t v7 = 8 * *((unsigned int *)a2 + 20) - 8;
    do
    {
      uint64_t v8 = *v6++;
      v7 -= 8;
    }
    while (v8 != a3);
    if (v5 != a3)
    {
      unint64_t v11 = 0;
      sub_1CD8D06DC((uint64_t)this + 88, v3, &v11);
    }
  }
  if (*((_DWORD *)a2 + 40) == 1)
  {
    uint64_t v9 = **((void **)a2 + 19);
    if (v9) {
      sub_1CD8F0BF4((uint64_t)this + 88, v9, v3, 0);
    }
  }
  return v3;
}

BOOL llvm::VPlanPredicator::getEdgeTypeBetween(llvm::VPlanPredicator *this, llvm::VPBlockBase *a2, llvm::VPBlockBase *a3)
{
  uint64_t v3 = *((unsigned int *)a2 + 20);
  if (v3)
  {
    uint64_t v4 = 0;
    uint64_t v5 = 8 * v3;
    while (*(llvm::VPBlockBase **)(*((void *)a2 + 9) + 8 * v4) != a3)
    {
      ++v4;
      v5 -= 8;
      if (!v5) {
        return result;
      }
    }
    return v4 != 0;
  }
  return result;
}

BOOL sub_1CD359F9C(uint64_t a1, uint64_t *a2)
{
  uint64_t v10 = 0;
  uint64_t v11 = a1;
  if ((sub_1CD3C8538(a2, &v11, &v10) & 1) == 0) {
    return 0;
  }
  uint64_t v3 = *(void *)(v10 + 8);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = **(void **)(v3 + 32);
  uint64_t v5 = *(void **)(v4 + 48);
  uint64_t v6 = *(unsigned int *)(v4 + 56);
  if (v6)
  {
    uint64_t v7 = 8 * v6;
    uint64_t v8 = v5;
    while (*v8 != a1)
    {
      ++v8;
      v7 -= 8;
      if (!v7)
      {
        uint64_t v8 = &v5[v6];
        return v6 != v8 - v5;
      }
    }
  }
  else
  {
    uint64_t v8 = v5;
  }
  return v6 != v8 - v5;
}

llvm::VPlanPredicator *llvm::VPlanPredicator::VPlanPredicator(llvm::VPlanPredicator *this, llvm::VPlan *a2)
{
  *(void *)this = a2;
  *((void *)this + 1) = (char *)a2 + 352;
  *((void *)this + 2) = (char *)this + 32;
  *((void *)this + 3) = 0x100000000;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0;
  *((unsigned char *)this + 80) = 0;
  *(void *)((char *)this + 92) = 0;
  *(void *)((char *)this + 84) = 0;
  *((_DWORD *)this + 25) = 0;
  *((void *)this + 9) = *(void *)a2;
  sub_1CD8EC5E8((uint64_t)this + 16, 0);
  return this;
}

{
  *(void *)this = a2;
  *((void *)this + 1) = (char *)a2 + 352;
  *((void *)this + 2) = (char *)this + 32;
  *((void *)this + 3) = 0x100000000;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0;
  *((unsigned char *)this + 80) = 0;
  *(void *)((char *)this + 92) = 0;
  *(void *)((char *)this + 84) = 0;
  *((_DWORD *)this + 25) = 0;
  *((void *)this + 9) = *(void *)a2;
  sub_1CD8EC5E8((uint64_t)this + 16, 0);
  return this;
}

uint64_t llvm::VPlanSlp::markFailed(llvm::VPlanSlp *this)
{
  *((unsigned char *)this + 40) = 0;
  return 0;
}

void llvm::VPlanSlp::addCombined(uint64_t a1, char *__src, uint64_t a3, uint64_t a4)
{
  v27[4] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = &__src[8 * a3];
  if (a3)
  {
    uint64_t v8 = 8 * a3;
    uint64_t v9 = 8 * a3;
    uint64_t v10 = __src;
    while (1)
    {
      if (*v10) {
        uint64_t v11 = *v10 - 96;
      }
      else {
        uint64_t v11 = 0;
      }
      uint64_t v12 = *(void *)(v11 + 16);
      unint64_t v13 = v12 & 0xFFFFFFFFFFFFFFF8;
      if ((v12 & 4) != 0) {
        unint64_t v13 = **(void **)v13;
      }
      if (!*(void *)(v13 + 40)) {
        break;
      }
      ++v10;
      v9 -= 8;
      if (!v9)
      {
        unsigned int v14 = 0;
        uint64_t v15 = __src;
        do
        {
          if (*v15) {
            uint64_t v16 = *v15 - 96;
          }
          else {
            uint64_t v16 = 0;
          }
          uint64_t v17 = *(void *)(v16 + 16);
          unint64_t v18 = (void **)(v17 & 0xFFFFFFFFFFFFFFF8);
          if ((v17 & 4) != 0) {
            unint64_t v18 = (void **)**v18;
          }
          uint64_t v19 = *v18[5];
          if ((*(_DWORD *)(v19 + 8) & 0xFE) == 0x12) {
            uint64_t v19 = **(void **)(v19 + 16);
          }
          v14 += llvm::Type::getPrimitiveSizeInBits((llvm::Type *)v19);
          ++v15;
          v8 -= 8;
        }
        while (v8);
        goto LABEL_21;
      }
    }
  }
  else
  {
    unsigned int v14 = 0;
LABEL_21:
    unsigned int v20 = *(_DWORD *)(a1 + 44);
    if (v20 <= v14) {
      unsigned int v20 = v14;
    }
    *(_DWORD *)(a1 + 44) = v20;
  }
  v24[0] = v25;
  v24[1] = (void *)0x400000000;
  sub_1CD47792C((unsigned int *)v24, __src, v7);
  v26[0] = 0;
  if ((sub_1CD35BFC0(*(void *)a1, *(_DWORD *)(a1 + 16), (uint64_t)v24, v26) & 1) == 0)
  {
    int v21 = *(_DWORD *)(a1 + 8);
    unsigned int v22 = *(_DWORD *)(a1 + 16);
    if (4 * v21 + 4 >= 3 * v22)
    {
      v22 *= 2;
    }
    else if (v22 + ~v21 - *(_DWORD *)(a1 + 12) > v22 >> 3)
    {
      goto LABEL_30;
    }
    sub_1CD35C544(a1, v22);
    v26[0] = 0;
    sub_1CD35BFC0(*(void *)a1, *(_DWORD *)(a1 + 16), (uint64_t)v24, v26);
LABEL_30:
    uint64_t v23 = v26[0];
    ++*(_DWORD *)(a1 + 8);
    v26[0] = v27;
    v27[0] = -1;
    v26[1] = 0x400000001;
    if (*(_DWORD *)(v23 + 8) != 1 || **(void **)v23 != v27[0]) {
      --*(_DWORD *)(a1 + 12);
    }
    sub_1CD41C56C(v23, (uint64_t)v24);
    *(void *)(v23 + 48) = a4;
  }
  if (v24[0] != v25) {
    free(v24[0]);
  }
}

uint64_t llvm::VPlanSlp::areVectorizable(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v4 = a2;
  if (a3)
  {
    uint64_t v6 = 8 * a3;
    uint64_t v7 = a2;
    do
    {
      uint64_t v8 = *v7;
      if (!*v7 || *(unsigned char *)(v8 + 8) != 1) {
        return 0;
      }
      uint64_t v9 = *(void *)(v8 - 80);
      unint64_t v10 = v9 & 0xFFFFFFFFFFFFFFF8;
      if ((v9 & 4) != 0) {
        unint64_t v10 = **(void **)v10;
      }
      if (!*(void *)(v10 + 40)) {
        return 0;
      }
      ++v7;
      v6 -= 8;
    }
    while (v6);
  }
  if (*a2) {
    uint64_t v11 = *a2 - 96;
  }
  else {
    uint64_t v11 = 0;
  }
  uint64_t v12 = *(void *)(v11 + 16);
  unint64_t v13 = v12 & 0xFFFFFFFFFFFFFFF8;
  if ((v12 & 4) != 0) {
    unint64_t v13 = **(void **)v13;
  }
  uint64_t v14 = *(void *)(v13 + 40);
  int v15 = *(unsigned __int8 *)(v14 + 16);
  int PrimitiveSizeInBits = llvm::Type::getPrimitiveSizeInBits(*(llvm::Type **)v14);
  if (v16 == 1) {
  if (a3)
  }
  {
    uint64_t v18 = 8 * a3;
    uint64_t v19 = 8 * a3;
    unsigned int v20 = v4;
    while (1)
    {
      if (*v20) {
        uint64_t v21 = *v20 - 96;
      }
      else {
        uint64_t v21 = 0;
      }
      uint64_t v22 = *(void *)(v21 + 16);
      unint64_t v23 = v22 & 0xFFFFFFFFFFFFFFF8;
      if ((v22 & 4) != 0) {
        unint64_t v23 = **(void **)v23;
      }
      uint64_t v24 = *(void *)(v23 + 40);
      if (*(unsigned __int8 *)(v24 + 16) != v15) {
        return 0;
      }
      unint64_t v25 = llvm::Type::getPrimitiveSizeInBits(*(llvm::Type **)v24);
      if (v26 == 1)
      {
        unint64_t v63 = v25;
        unint64_t v25 = v63;
      }
      if (v25 != PrimitiveSizeInBits) {
        return 0;
      }
      ++v20;
      v19 -= 8;
      if (!v19)
      {
        uint64_t v27 = v4;
        while (1)
        {
          uint64_t v28 = *v27 ? *v27 - 96 : 0;
          if (*(void *)(v28 + 88) != *(void *)(a1 + 32)) {
            return 0;
          }
          ++v27;
          v18 -= 8;
          if (!v18)
          {
            uint64_t v29 = v4;
            do
            {
              uint64_t v30 = *(unsigned int *)(*v29 + 24);
              if (v30)
              {
                uint64_t v31 = *(void **)(*v29 + 16);
                uint64_t v32 = 8 * v30;
                for (uint64_t i = 8; v32 != i; i += 8)
                {
                  uint64_t v34 = v31[(unint64_t)i / 8];
                  if (*v31 != v34) {
                    return 0;
                  }
                }
              }
              ++v29;
            }
            while (v29 != &v4[a3]);
            goto LABEL_41;
          }
        }
      }
    }
  }
LABEL_41:
  if (v15 == 61)
  {
    if (a3)
    {
      uint64_t v56 = 8 * a3;
      uint64_t result = 1;
      while (1)
      {
        if (*v4) {
          uint64_t v57 = *v4 - 96;
        }
        else {
          uint64_t v57 = 0;
        }
        uint64_t v58 = *(void *)(v57 + 16);
        unint64_t v59 = v58 & 0xFFFFFFFFFFFFFFF8;
        if ((v58 & 4) != 0) {
          unint64_t v59 = **(void **)v59;
        }
        uint64_t v60 = *(void *)(v59 + 40);
        int v61 = *(unsigned __int8 *)(v60 + 16);
        if (v61 == 60 || v61 == 61)
        {
          __int16 v62 = *(_WORD *)(v60 + 18);
          if (v62 & 0x380) != 0 || (v62) {
            return 0;
          }
        }
        else if (v61 - 63) < 3 || (*(_WORD *)(v60 + 18))
        {
          return 0;
        }
        ++v4;
        v56 -= 8;
        if (!v56) {
          return result;
        }
      }
    }
    return 1;
  }
  if (v15 != 60) {
    return 1;
  }
  if (*v4) {
    uint64_t v35 = *v4 - 96;
  }
  else {
    uint64_t v35 = 0;
  }
  uint64_t v36 = *(void *)(v35 + 88);
  uint64_t v37 = v36 + 200;
  uint64_t v38 = *(void *)(v36 + 208);
  if (v38 != v37)
  {
    int v39 = 0;
    do
    {
      uint64_t v40 = v38 - 24;
      if (!v38) {
        uint64_t v40 = 0;
      }
      int v41 = *(unsigned __int8 *)(v40 + 8);
      BOOL v42 = v41 == 2;
      uint64_t v43 = v41 == 2 ? v40 : 0;
      if (!v38 || !v42) {
        break;
      }
      int v44 = *(unsigned __int8 *)(v43 + 152);
      if (v44 == 32)
      {
        if (a3)
        {
          uint64_t v45 = v43 + 96;
          uint64_t v46 = 8 * a3;
          uint64_t v47 = v4;
          while (*v47 != v45)
          {
            ++v47;
            v46 -= 8;
            if (!v46)
            {
              uint64_t v47 = &v4[a3];
              break;
            }
          }
        }
        else
        {
          uint64_t v47 = v4;
        }
        if (a3 != v47 - v4) {
          ++v39;
        }
      }
      if (a3 == v39) {
        break;
      }
      if (v39
        && ((v44 - 33) <= 0x28 && ((1 << (v44 - 33)) & 0x10000800001) != 0 || v44 == 5))
      {
        return 0;
      }
      uint64_t v38 = *(void *)(v38 + 8);
    }
    while (v38 != v37);
  }
  if (!a3) {
    return 1;
  }
  uint64_t v48 = 8 * a3;
  uint64_t result = 1;
  do
  {
    if (*v4) {
      uint64_t v50 = *v4 - 96;
    }
    else {
      uint64_t v50 = 0;
    }
    uint64_t v51 = *(void *)(v50 + 16);
    unint64_t v52 = v51 & 0xFFFFFFFFFFFFFFF8;
    if ((v51 & 4) != 0) {
      unint64_t v52 = **(void **)v52;
    }
    uint64_t v53 = *(void *)(v52 + 40);
    int v54 = *(unsigned __int8 *)(v53 + 16);
    if (v54 == 60 || v54 == 61)
    {
      __int16 v55 = *(_WORD *)(v53 + 18);
      if ((v55 & 0x380) != 0) {
        return 0;
      }
    }
    else
    {
      if ((v54 - 63) < 3) {
        return 0;
      }
      __int16 v55 = *(_WORD *)(v53 + 18);
    }
    if (v55) {
      return 0;
    }
    ++v4;
    v48 -= 8;
  }
  while (v48);
  return result;
}

uint64_t llvm::VPlanSlp::getBest(uint64_t a1, unsigned int a2, uint64_t a3, void *a4, uint64_t a5)
{
  v52[4] = *MEMORY[0x1E4F143B8];
  unsigned int v51 = 0;
  uint64_t v8 = a4[1];
  if (v8 == *a4) {
    uint64_t v9 = (unsigned int *)a4 + 5;
  }
  else {
    uint64_t v9 = (unsigned int *)(a4 + 2);
  }
  uint64_t v10 = *v9;
  if (v10)
  {
    uint64_t v11 = 8 * v10;
    for (uint64_t i = (unint64_t *)a4[1]; *i >= 0xFFFFFFFFFFFFFFFELL; ++i)
    {
      v11 -= 8;
      if (!v11) {
        return 0;
      }
    }
  }
  else
  {
    uint64_t i = (unint64_t *)a4[1];
  }
  unint64_t v13 = (unint64_t *)(v8 + 8 * v10);
  if (i == v13) {
    return 0;
  }
  uint64_t v14 = a2;
  if (a3) {
    uint64_t v15 = a3 - 96;
  }
  else {
    uint64_t v15 = 0;
  }
  unint64_t v16 = *i;
LABEL_15:
  if (v16) {
    uint64_t v17 = v16 - 96;
  }
  else {
    uint64_t v17 = 0;
  }
  if (sub_1CD35AA3C(v15, v17, a5))
  {
    if (v51 >= 4uLL) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    v52[v51++] = v16;
  }
  uint64_t v18 = i + 1;
  while (v18 != v13)
  {
    unint64_t v19 = *v18++;
    unint64_t v16 = v19;
    if (v19 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      uint64_t i = v18 - 1;
      goto LABEL_15;
    }
  }
  uint64_t v20 = v51;
  if (v51)
  {
    if (v51 == 1)
    {
      return v14;
    }
    else
    {
      uint64_t v49 = v14;
      uint64_t v50 = a4;
      unsigned int v22 = 0;
      uint64_t v23 = 0;
      int v24 = 1;
      while (1)
      {
        unint64_t v25 = v52;
        uint64_t v26 = 8 * v20;
        int v27 = -1;
        char v28 = 1;
        do
        {
          uint64_t v30 = *v25++;
          uint64_t v29 = v30;
          unsigned int v31 = sub_1CD35AB24(a3, v30, v24, a5);
          BOOL v33 = v27 == -1 || v27 == v31;
          v28 &= v33;
          if (v31 > v22)
          {
            uint64_t v23 = v29;
            unsigned int v22 = v31;
          }
          int v27 = v31;
          v26 -= 8;
        }
        while (v26);
        if ((v28 & 1) == 0) {
          break;
        }
        if (++v24 == 5) {
          break;
        }
        uint64_t v20 = v51;
      }
      uint64_t v35 = *v50;
      uint64_t v34 = v50[1];
      if (v34 == *v50)
      {
        uint64_t v36 = *((unsigned int *)v50 + 5);
        uint64_t v37 = (void *)(v34 + 8 * v36);
        uint64_t v20 = v49;
        if (v36)
        {
          uint64_t v38 = 0;
          while (*(void *)(v34 + v38) != v23)
          {
            v38 += 8;
            if (8 * v36 == v38) {
              goto LABEL_68;
            }
          }
          uint64_t v37 = (void *)(v34 + v38);
        }
LABEL_68:
        uint64_t v35 = v50[1];
      }
      else
      {
        uint64_t v39 = *((unsigned int *)v50 + 4);
        int v40 = v39 - 1;
        unsigned int v41 = (v39 - 1) & ((v23 >> 4) ^ (v23 >> 9));
        uint64_t v37 = (void *)(v34 + 8 * v41);
        uint64_t v42 = *v37;
        uint64_t v20 = v49;
        uint64_t v43 = 0;
        if (*v37 == -1)
        {
LABEL_61:
          if (v43) {
            uint64_t v37 = v43;
          }
          LODWORD(v36) = *((_DWORD *)v50 + 5);
          uint64_t v47 = (void *)(v34 + 8 * v39);
          if (*v37 != v23) {
            uint64_t v37 = v47;
          }
        }
        else
        {
          int v44 = 1;
          while (v42 != v23)
          {
            if (v43) {
              BOOL v45 = 0;
            }
            else {
              BOOL v45 = v42 == -2;
            }
            if (v45) {
              uint64_t v43 = v37;
            }
            unsigned int v46 = v41 + v44++;
            unsigned int v41 = v46 & v40;
            uint64_t v37 = (void *)(v34 + 8 * (v46 & v40));
            uint64_t v42 = *v37;
            if (*v37 == -1) {
              goto LABEL_61;
            }
          }
          LODWORD(v36) = *((_DWORD *)v50 + 5);
        }
      }
      if (v34 == v35) {
        unsigned int v48 = v36;
      }
      else {
        unsigned int v48 = *((_DWORD *)v50 + 4);
      }
      if (v37 != (void *)(v34 + 8 * v48))
      {
        *uint64_t v37 = -2;
        ++*((_DWORD *)v50 + 6);
      }
    }
  }
  return v20;
}

BOOL sub_1CD35AA3C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = *(unsigned __int8 *)(a1 + 152);
  if (v3 != *(unsigned __int8 *)(a2 + 152)) {
    return 0;
  }
  if ((v3 & 0xFE) != 0x20) {
    return 1;
  }
  uint64_t v12 = 0;
  uint64_t v7 = 0;
  if (sub_1CBB0BF40(*(void *)a3, *(_DWORD *)(a3 + 16), a1, &v12)) {
    uint64_t v7 = *(void *)(v12 + 8);
  }
  uint64_t v12 = 0;
  if ((sub_1CBB0BF40(*(void *)a3, *(_DWORD *)(a3 + 16), a2, &v12) & 1) == 0) {
    return 0;
  }
  BOOL result = 0;
  if (v7)
  {
    uint64_t v9 = *(void *)(v12 + 8);
    if (v9) {
      BOOL v10 = v7 == v9;
    }
    else {
      BOOL v10 = 0;
    }
    if (v10)
    {
      unsigned int v11 = sub_1CD35BD98(v7, a1) + 1;
      return v11 == sub_1CD35BD98(v7, a2);
    }
  }
  return result;
}

BOOL sub_1CD35AB24(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v4 = a1 - 96;
  if (!a1) {
    uint64_t v4 = 0;
  }
  if (*(unsigned char *)(a1 + 8) == 1) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = a2 - 96;
  if (!a2) {
    uint64_t v6 = 0;
  }
  if (*(unsigned char *)(a2 + 8) == 1) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  if (v5) {
    BOOL v8 = v7 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8) {
    return 0;
  }
  if (!a3) {
    return sub_1CD35AA3C(v5, v7, a4);
  }
  uint64_t v11 = *(unsigned int *)(v5 + 56);
  if (!v11) {
    return 0;
  }
  uint64_t v12 = 0;
  uint64_t v9 = 0;
  uint64_t v13 = (a3 - 1);
  do
  {
    uint64_t v14 = *(unsigned int *)(v7 + 56);
    if (v14)
    {
      uint64_t v15 = 0;
      uint64_t v16 = 8 * v14;
      do
      {
        uint64_t v9 = sub_1CD35AB24(*(void *)(*(void *)(v5 + 48) + 8 * v12), *(void *)(*(void *)(v7 + 48) + v15), v13, a4)+ v9;
        v15 += 8;
      }
      while (v16 != v15);
    }
    ++v12;
  }
  while (v12 != v11);
  return v9;
}

void llvm::VPlanSlp::reorderMultiNodeOps(llvm::VPlanSlp *this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = this;
  uint64_t v3 = (uint64_t)a2;
  v67[2] = *MEMORY[0x1E4F143B8];
  *a2 = a2 + 2;
  a2[1] = 0x400000000;
  uint64_t v65 = v67;
  uint64_t v66 = 0x400000000;
  unint64_t v4 = *((unsigned int *)this + 14);
  if (v4 < 5)
  {
    unsigned int v5 = 4;
  }
  else
  {
    sub_1CD35C864((uint64_t)a2, v4);
    LODWORD(v4) = *((_DWORD *)v2 + 14);
    unsigned int v5 = HIDWORD(v66);
  }
  if (v5 < v4) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  uint64_t v6 = *((void *)v2 + 6);
  __int16 v55 = (unint64_t *)v3;
  if (v4)
  {
    uint64_t v7 = 56 * v4;
    BOOL v8 = (uint64_t **)(v6 + 8);
    while (1)
    {
      uint64_t v9 = **v8;
      uint64_t v56 = &v58;
      uint64_t v58 = v9;
      uint64_t v57 = (void *)0x400000001;
      uint64_t v60 = *(v8 - 1);
      int v61 = &v63;
      uint64_t v62 = 0x400000000;
      sub_1CBB10328((uint64_t)&v61, (uint64_t)&v56);
      uint64_t v10 = *(unsigned int *)(v3 + 8);
      unint64_t v11 = *(void *)v3;
      if (v10 >= *(_DWORD *)(v3 + 12))
      {
        unint64_t v18 = v10 + 1;
        BOOL v19 = v11 + 56 * v10 > (unint64_t)&v60;
        if (v11 <= (unint64_t)&v60 && v19)
        {
          uint64_t v20 = (char *)&v60 - v11;
          sub_1CD35C864((uint64_t)v55, v18);
          unint64_t v11 = *v55;
          uint64_t v12 = &v20[*v55];
          uint64_t v3 = (uint64_t)v55;
          goto LABEL_10;
        }
        sub_1CD35C864(v3, v18);
        unint64_t v11 = *(void *)v3;
      }
      uint64_t v12 = (char *)&v60;
LABEL_10:
      uint64_t v13 = (void *)(v11 + 56 * *(unsigned int *)(v3 + 8));
      *uint64_t v13 = *(void *)v12;
      v13[2] = 0x400000000;
      v13[1] = v13 + 3;
      uint64_t v14 = (uint64_t)(v13 + 1);
      if (*((_DWORD *)v12 + 4)) {
        sub_1CD41C56C(v14, (uint64_t)(v12 + 8));
      }
      ++*(_DWORD *)(v3 + 8);
      if (v61 != &v63) {
        free(v61);
      }
      if (v56 != &v58) {
        free(v56);
      }
      uint64_t v15 = **v8;
      if (v15) {
        uint64_t v16 = v15 - 96;
      }
      else {
        uint64_t v16 = 0;
      }
      if (*(unsigned char *)(v16 + 152) == 32) {
        int v17 = 1;
      }
      else {
        int v17 = 2;
      }
      if (v66 >= (unint64_t)HIDWORD(v66)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      v65[v66] = v17;
      LODWORD(v66) = v66 + 1;
      v8 += 7;
      v7 -= 56;
      uint64_t v3 = (uint64_t)v55;
      if (!v7)
      {
        uint64_t v6 = *((void *)v2 + 6);
        break;
      }
    }
  }
  uint64_t v53 = *(unsigned int *)(v6 + 16);
  if (v53 < 2) {
    goto LABEL_91;
  }
  uint64_t v21 = 1;
  int v54 = v2;
  do
  {
    uint64_t v60 = v64;
    int v61 = v64;
    uint64_t v62 = 4;
    int v63 = 0;
    unsigned int v22 = *((_DWORD *)v2 + 14);
    if (!v22) {
      goto LABEL_88;
    }
    uint64_t v23 = *((void *)v2 + 6);
    uint64_t v24 = v23 + 56 * v22;
    do
    {
      uint64_t v56 = *(void **)v23;
      uint64_t v57 = v59;
      uint64_t v58 = 0x400000000;
      unint64_t v25 = v59;
      if (*(_DWORD *)(v23 + 16))
      {
        sub_1CBB10328((uint64_t)&v57, v23 + 8);
        unint64_t v25 = v57;
      }
      uint64_t v26 = *(void *)&v25[8 * v21];
      int v27 = (char *)v61;
      uint64_t v28 = HIDWORD(v62);
      if (v61 != v60)
      {
        unsigned int v32 = v62;
        goto LABEL_47;
      }
      if (!HIDWORD(v62))
      {
LABEL_44:
        unsigned int v32 = v62;
        if (HIDWORD(v62) < v62)
        {
          ++HIDWORD(v62);
          *((void *)v61 + v28) = v26;
          goto LABEL_68;
        }
LABEL_47:
        if (3 * v32 <= 4 * (HIDWORD(v62) - v63))
        {
          if (v32 >= 0x40) {
            v32 *= 2;
          }
          else {
            unsigned int v32 = 128;
          }
        }
        else if (v32 - HIDWORD(v62) >= v32 >> 3)
        {
          goto LABEL_49;
        }
        llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v60, v32);
        unsigned int v32 = v62;
        int v27 = (char *)v61;
LABEL_49:
        unsigned int v33 = v32 - 1;
        unsigned int v34 = (v32 - 1) & ((v26 >> 4) ^ (v26 >> 9));
        uint64_t v35 = &v27[8 * v34];
        uint64_t v36 = *(void *)v35;
        if (*(void *)v35 == -1)
        {
          uint64_t v37 = 0;
LABEL_61:
          if (v37) {
            unsigned int v41 = v37;
          }
          else {
            unsigned int v41 = v35;
          }
          if (*(void *)v41 != v26)
          {
            if (*(void *)v41 == -2) {
              --v63;
            }
            else {
              ++HIDWORD(v62);
            }
            *(void *)unsigned int v41 = v26;
          }
        }
        else
        {
          uint64_t v37 = 0;
          int v38 = 1;
          while (v36 != v26)
          {
            if (v37) {
              BOOL v39 = 0;
            }
            else {
              BOOL v39 = v36 == -2;
            }
            if (v39) {
              uint64_t v37 = v35;
            }
            unsigned int v40 = v34 + v38++;
            unsigned int v34 = v40 & v33;
            uint64_t v35 = &v27[8 * (v40 & v33)];
            uint64_t v36 = *(void *)v35;
            if (*(void *)v35 == -1) {
              goto LABEL_61;
            }
          }
        }
        goto LABEL_68;
      }
      uint64_t v29 = 0;
      uint64_t v30 = 8 * HIDWORD(v62);
      unsigned int v31 = v61;
      while (*v31 != v26)
      {
        if (*v31 == -2) {
          uint64_t v29 = v31;
        }
        ++v31;
        v30 -= 8;
        if (!v30)
        {
          if (!v29) {
            goto LABEL_44;
          }
          void *v29 = v26;
          --v63;
          break;
        }
      }
LABEL_68:
      uint64_t Best = (uint64_t)v57;
      if (v57 != v59) {
        free(v57);
      }
      v23 += 56;
    }
    while (v23 != v24);
    uint64_t v43 = *((unsigned int *)v2 + 14);
    if (v43)
    {
      uint64_t v44 = 0;
      uint64_t v45 = 0;
      uint64_t v46 = 0;
      uint64_t v47 = 56 * v43;
      do
      {
        unsigned int v48 = v65[v44];
        if (v48)
        {
          uint64_t Best = llvm::VPlanSlp::getBest(Best, v48, *(void *)(*(void *)(*v55 + v45 + 8) + 8 * (v21 - 1)), &v60, *((void *)v2 + 3));
          uint64_t v50 = *v55 + v45;
          if (v49)
          {
            unsigned int v51 = (_DWORD *)(*v55 + 56 * v46 + 16);
            unint64_t v52 = *(unsigned int *)(v50 + 16);
            if (v52 >= *(unsigned int *)(v50 + 20)) {
              goto LABEL_87;
            }
          }
          else
          {
            *((unsigned char *)v2 + 40) = 0;
            unint64_t v52 = *(unsigned int *)(v50 + 16);
            unsigned int v51 = (_DWORD *)(v50 + 16);
            if (v52 >= *(unsigned int *)(v50 + 20)) {
LABEL_87:
            }
              llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)(v50 + 8) + 8 * v52) = v49;
          ++*v51;
          uint64_t v2 = v54;
        }
        ++v46;
        v45 += 56;
        ++v44;
      }
      while (v47 != v45);
    }
LABEL_88:
    if (v61 != v60) {
      free(v61);
    }
    ++v21;
  }
  while (v21 != v53);
LABEL_91:
  if (v65 != (_DWORD *)v67) {
    free(v65);
  }
}

llvm *llvm::VPlanSlp::dumpBundle(llvm *a1, void *a2, uint64_t a3)
{
  unsigned int v5 = llvm::dbgs(a1);
  uint64_t v6 = *((void *)v5 + 4);
  if ((unint64_t)(*((void *)v5 + 3) - v6) <= 5)
  {
    unsigned int v5 = llvm::raw_ostream::write(v5, " Ops: ", 6uLL);
    if (!a3) {
      goto LABEL_3;
    }
    goto LABEL_8;
  }
  *(_WORD *)(v6 + 4) = 8250;
  *(_DWORD *)uint64_t v6 = 1936740128;
  *((void *)v5 + 4) += 6;
  if (a3)
  {
LABEL_8:
    for (uint64_t i = 8 * a3; i; i -= 8)
    {
      if (!*a2) {
        goto LABEL_13;
      }
      uint64_t v10 = *(void *)(*a2 - 80);
      unint64_t v11 = v10 & 0xFFFFFFFFFFFFFFF8;
      if ((v10 & 4) != 0) {
        unint64_t v11 = **(void **)v11;
      }
      uint64_t v12 = *(llvm::Value **)(v11 + 40);
      if (v12)
      {
        uint64_t v16 = llvm::dbgs(v5);
        llvm::Value::print(v12, v16, 0);
        uint64_t v17 = *((void *)v16 + 4);
        if ((unint64_t)(*((void *)v16 + 3) - v17) > 2)
        {
          *(unsigned char *)(v17 + 2) = 32;
          *(_WORD *)uint64_t v17 = 31776;
          *((void *)v16 + 4) += 3;
          goto LABEL_18;
        }
        unsigned int v5 = v16;
        uint64_t v14 = " | ";
        size_t v15 = 3;
      }
      else
      {
LABEL_13:
        unsigned int v5 = llvm::dbgs(v5);
        uint64_t v13 = *((void *)v5 + 4);
        if ((unint64_t)(*((void *)v5 + 3) - v13) > 0xA)
        {
          *(_DWORD *)(v13 + 7) = 545005682;
          *(void *)uint64_t v13 = *(void *)" nullptr | ";
          *((void *)v5 + 4) += 11;
          goto LABEL_18;
        }
        uint64_t v14 = " nullptr | ";
        size_t v15 = 11;
      }
      unsigned int v5 = llvm::raw_ostream::write(v5, v14, v15);
LABEL_18:
      ++a2;
    }
  }
LABEL_3:
  BOOL result = llvm::dbgs(v5);
  BOOL v8 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v8)
  {
    return llvm::raw_ostream::write(result, "\n", 1uLL);
  }
  else
  {
    *BOOL v8 = 10;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t llvm::VPlanSlp::buildGraph(uint64_t a1, unsigned char *a2, uint64_t a3)
{
  v62[4] = *MEMORY[0x1E4F143B8];
  uint64_t v57 = v59;
  uint64_t v58 = 0x400000000;
  sub_1CD47792C((unsigned int *)&v57, a2, &a2[8 * a3]);
  uint64_t v60 = 0;
  if (sub_1CD35BFC0(*(void *)a1, *(_DWORD *)(a1 + 16), (uint64_t)&v57, &v60)) {
    uint64_t v6 = v60;
  }
  else {
    uint64_t v6 = (void *)(*(void *)a1 + 56 * *(unsigned int *)(a1 + 16));
  }
  if (v57 != v59) {
    free(v57);
  }
  if (v6 != (void *)(*(void *)a1 + 56 * *(unsigned int *)(a1 + 16))) {
    return v6[6];
  }
  if ((llvm::VPlanSlp::areVectorizable(a1, a2, a3) & 1) == 0)
  {
    uint64_t v7 = 0;
    *(unsigned char *)(a1 + 40) = 0;
    return v7;
  }
  if (*(void *)a2) {
    uint64_t v8 = *(void *)a2 - 96;
  }
  else {
    uint64_t v8 = 0;
  }
  unsigned int v9 = *(unsigned __int8 *)(v8 + 152);
  uint64_t v10 = 8 * a3;
  if (a3)
  {
    uint64_t v11 = 8 * a3;
    uint64_t v12 = a2;
    while (1)
    {
      uint64_t v13 = *v12 ? *v12 - 96 : 0;
      if (v9 != *(unsigned __int8 *)(v13 + 152)) {
        break;
      }
      ++v12;
      v11 -= 8;
      if (!v11) {
        goto LABEL_19;
      }
    }
    unsigned int v14 = 0;
  }
  else
  {
LABEL_19:
    unsigned int v14 = v9;
  }
  size_t v15 = v62;
  uint64_t v60 = v62;
  uint64_t v61 = 0x400000000;
  uint64_t v56 = v62;
  unsigned int v55 = v14;
  if (v9 <= 0x1E && ((1 << v9) & 0x70066000) != 0)
  {
    int v54 = *(unsigned __int8 *)(a1 + 288);
    *(unsigned char *)(a1 + 288) = 1;
    sub_1CD35BC70(&v57, a2, a3);
    if (v58)
    {
      uint64_t v16 = (char *)v57;
      uint64_t v17 = (char *)v57 + 48 * v58;
      uint64_t v53 = a1 + 64;
      while (1)
      {
        uint64_t v18 = *((unsigned int *)v16 + 2);
        uint64_t v19 = **(void **)v16;
        uint64_t v20 = v19 ? v19 - 96 : 0;
        int v21 = *(unsigned __int8 *)(v20 + 152);
        if (v18) {
          break;
        }
LABEL_36:
        if (*(void *)a2) {
          uint64_t v25 = *(void *)a2 - 96;
        }
        else {
          uint64_t v25 = 0;
        }
        int v26 = *(unsigned __int8 *)(v25 + 152);
        if (a3)
        {
          uint64_t v27 = 8 * a3;
          uint64_t v28 = a2;
          do
          {
            uint64_t v29 = *v28 ? *v28 - 96 : 0;
            if (v26 != *(unsigned __int8 *)(v29 + 152)) {
              goto LABEL_53;
            }
            ++v28;
            v27 -= 8;
          }
          while (v27);
        }
        if (v21 != v26) {
          goto LABEL_53;
        }
        uint64_t v30 = llvm::VPlanSlp::buildGraph(a1, *(void *)v16, v18);
        if (v30) {
          uint64_t v31 = v30 + 96;
        }
        else {
          uint64_t v31 = 0;
        }
        if (v61 >= (unint64_t)HIDWORD(v61)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        v60[v61] = v31;
        LODWORD(v61) = v61 + 1;
        v16 += 48;
        if (v16 == v17) {
          goto LABEL_55;
        }
      }
      uint64_t v22 = 8 * v18;
      uint64_t v23 = *(uint64_t **)v16;
      while (1)
      {
        uint64_t v24 = *v23 ? *v23 - 96 : 0;
        if (v21 != *(unsigned __int8 *)(v24 + 152)) {
          break;
        }
        ++v23;
        v22 -= 8;
        if (!v22) {
          goto LABEL_36;
        }
      }
LABEL_53:
      operator new();
    }
LABEL_55:
    sub_1CD48219C((char **)&v57);
    if (!v54)
    {
      *(unsigned char *)(a1 + 288) = 0;
      llvm::VPlanSlp::reorderMultiNodeOps((llvm::VPlanSlp *)a1, &v57);
      uint64_t v32 = *(unsigned int *)(a1 + 56);
      if (v32)
      {
        uint64_t v33 = *(void *)(a1 + 48);
        uint64_t v34 = 56 * v32;
        do
        {
          uint64_t v35 = *(void **)(v33 + v34 - 48);
          if ((void *)(v33 + v34 - 32) != v35) {
            free(v35);
          }
          v34 -= 56;
        }
        while (v34);
      }
      *(_DWORD *)(a1 + 56) = 0;
      uint64_t v36 = (char *)v57;
      if (v58)
      {
        uint64_t v37 = (char *)v57 + 56 * v58;
        do
        {
          uint64_t v38 = llvm::VPlanSlp::buildGraph(a1, *((void *)v36 + 1), *((unsigned int *)v36 + 4));
          if (v38) {
            BOOL v39 = (llvm::VPValue *)(v38 + 96);
          }
          else {
            BOOL v39 = 0;
          }
          llvm::VPValue::replaceAllUsesWith(*(void *)v36 + 96, v39);
          if (v61)
          {
            unint64_t v40 = 0;
            uint64_t v41 = 8 * v61;
            do
            {
              if (*(void *)v36) {
                uint64_t v42 = *(void *)v36 + 96;
              }
              else {
                uint64_t v42 = 0;
              }
              if (v60[v40 / 8] == v42) {
                v60[v40 / 8] = v39;
              }
              v40 += 8;
            }
            while (v41 != v40);
          }
          if (*(void *)v36) {
            (*(void (**)(void))(**(void **)v36 + 8))(*(void *)v36);
          }
          *(void *)uint64_t v36 = v38;
          v36 += 56;
        }
        while (v36 != v37);
        uint64_t v36 = (char *)v57;
        if (v58)
        {
          uint64_t v43 = 56 * v58;
          do
          {
            uint64_t v44 = *(char **)&v36[v43 - 48];
            if (&v36[v43 - 32] != v44) {
              free(v44);
            }
            v43 -= 56;
          }
          while (v43);
          uint64_t v36 = (char *)v57;
        }
      }
      if (v36 != v59) {
        free(v36);
      }
    }
  }
  else if (v14 == 32)
  {
    if (!a3) {
      goto LABEL_106;
    }
    unsigned int v45 = 0;
    uint64_t v46 = a2;
    do
    {
      if (*v46) {
        uint64_t v47 = *v46 - 96;
      }
      else {
        uint64_t v47 = 0;
      }
      if (v45 >= HIDWORD(v61)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      v60[v45] = **(void **)(v47 + 48);
      unsigned int v45 = v61 + 1;
      LODWORD(v61) = v61 + 1;
      ++v46;
      v10 -= 8;
    }
    while (v10);
  }
  else
  {
    sub_1CD35BC70(&v57, a2, a3);
    if (v58)
    {
      unsigned int v48 = (char *)v57;
      uint64_t v49 = (char *)v57 + 48 * v58;
      do
      {
        uint64_t v50 = llvm::VPlanSlp::buildGraph(a1, *(void *)v48, *((unsigned int *)v48 + 2));
        if (v50) {
          uint64_t v51 = v50 + 96;
        }
        else {
          uint64_t v51 = 0;
        }
        if (v61 >= (unint64_t)HIDWORD(v61)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        v60[v61] = v51;
        LODWORD(v61) = v61 + 1;
        v48 += 48;
      }
      while (v48 != v49);
    }
    sub_1CD48219C((char **)&v57);
  }
  size_t v15 = v56;
LABEL_106:
  if (*(unsigned char *)(a1 + 40)) {
    operator new();
  }
  uint64_t v7 = 0;
  *(unsigned char *)(a1 + 40) = 0;
  if (v60 != v15) {
    free(v60);
  }
  return v7;
}

void sub_1CD35BC70(void *a1, void *a2, uint64_t a3)
{
  v10[4] = *MEMORY[0x1E4F143B8];
  *a1 = a1 + 2;
  a1[1] = 0x400000000;
  if (*a2) {
    uint64_t v6 = *a2 - 96;
  }
  else {
    uint64_t v6 = 0;
  }
  if (*(unsigned char *)(v6 + 152) == 33)
  {
    sub_1CD35BF00((uint64_t)v9, a2, a3, 0);
    sub_1CD35BE4C((uint64_t)a1, (unint64_t)v9);
    if (v9[0] != v10) {
      free(v9[0]);
    }
  }
  else
  {
    int v7 = *(_DWORD *)(v6 + 56);
    if (v7)
    {
      for (unsigned int i = 0; i != v7; ++i)
      {
        sub_1CD35BF00((uint64_t)v9, a2, a3, i);
        sub_1CD35BE4C((uint64_t)a1, (unint64_t)v9);
        if (v9[0] != v10) {
          free(v9[0]);
        }
      }
    }
  }
}

int *sub_1CD35BD98(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(int **)(a1 + 8);
  uint64_t v3 = *(unsigned int *)(a1 + 24);
  unint64_t v4 = &v2[4 * v3];
  if (*(_DWORD *)(a1 + 16))
  {
    if (v3)
    {
      uint64_t v5 = 16 * v3;
      uint64_t v6 = *(int **)(a1 + 8);
      while ((*v6 - 0x7FFFFFFF) <= 1)
      {
        v6 += 4;
        v5 -= 16;
        if (!v5) {
          goto LABEL_6;
        }
      }
    }
    else
    {
      uint64_t v6 = *(int **)(a1 + 8);
    }
  }
  else
  {
LABEL_6:
    uint64_t v6 = &v2[4 * v3];
  }
  int v7 = &v2[4 * v3];
  if (v6 != v7)
  {
    while (*((void *)v6 + 1) != a2)
    {
      uint64_t v2 = v6 + 4;
      while (v2 != v4)
      {
        int v8 = *v2;
        v2 += 4;
        if ((v8 - 0x7FFFFFFF) >= 2)
        {
          uint64_t v6 = v2 - 4;
          goto LABEL_15;
        }
      }
      uint64_t v6 = v4;
LABEL_15:
      if (v6 == v7) {
        return v2;
      }
    }
    return (int *)(*v6 - *(_DWORD *)(a1 + 32));
  }
  return v2;
}

void *sub_1CD35BE4C(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 8);
  unint64_t v5 = *(void *)a1;
  if (v4 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v7 = v4 + 1;
    unint64_t v8 = v5 + 48 * v4;
    if (v5 <= a2 && v8 > a2)
    {
      unint64_t v10 = a2 - v5;
      sub_1CC2917E4(a1, v7);
      unint64_t v5 = *(void *)a1;
      a2 = *(void *)a1 + v10;
    }
    else
    {
      sub_1CC2917E4(a1, v7);
      unint64_t v5 = *(void *)a1;
    }
  }
  BOOL result = (void *)(v5 + 48 * *(unsigned int *)(a1 + 8));
  *BOOL result = result + 2;
  result[1] = 0x400000000;
  if (*(_DWORD *)(a2 + 8)) {
    BOOL result = (void *)sub_1CD41C56C((uint64_t)result, a2);
  }
  ++*(_DWORD *)(a1 + 8);
  return result;
}

uint64_t sub_1CD35BF00(uint64_t result, void *a2, uint64_t a3, unsigned int a4)
{
  *(void *)BOOL result = result + 16;
  *(void *)(result + 8) = 0x400000000;
  if (a3)
  {
    unsigned int v5 = 0;
    uint64_t v6 = 8 * a3;
    do
    {
      if (*a2) {
        uint64_t v7 = *a2 - 96;
      }
      else {
        uint64_t v7 = 0;
      }
      if (v5 >= *(_DWORD *)(result + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)result + 8 * v5) = *(void *)(*(void *)(v7 + 48) + 8 * a4);
      unsigned int v5 = *(_DWORD *)(result + 8) + 1;
      *(_DWORD *)(result + 8) = v5;
      ++a2;
      v6 -= 8;
    }
    while (v6);
  }
  return result;
}

uint64_t sub_1CD35BFC0(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  v92[4] = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    __s2 = v92;
    v92[0] = -1;
    uint64_t v91 = 0x400000001;
    v89[0] = -2;
    uint64_t v7 = *(void **)a3;
    uint64_t v8 = *(unsigned int *)(a3 + 8);
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
    {
      uint64_t v83 = v7;
      int v84 = __cxa_guard_acquire(&qword_1EBCBE588);
      uint64_t v7 = v83;
      if (v84)
      {
        unint64_t v85 = llvm::hashing::detail::fixed_seed_override;
        if (!llvm::hashing::detail::fixed_seed_override) {
          unint64_t v85 = 0xFF51AFD7ED558CCDLL;
        }
        qword_1EBCBE580 = v85;
        __cxa_guard_release(&qword_1EBCBE588);
        uint64_t v7 = v83;
      }
    }
    unint64_t v9 = 8 * v8;
    if (v8 > 8)
    {
      unint64_t v12 = 0x9DDFEA08EB382D69
          * ((0x9DDFEA08EB382D69 * (qword_1EBCBE580 ^ 0xB492B66FBE98F273)) ^ ((0x9DDFEA08EB382D69
                                                                                 * (qword_1EBCBE580 ^ 0xB492B66FBE98F273)) >> 47) ^ 0xB492B66FBE98F273);
      uint64_t v13 = __ROR8__(qword_1EBCBE580 ^ 0xB492B66FBE98F273, 49);
      unint64_t v14 = qword_1EBCBE580 ^ ((unint64_t)qword_1EBCBE580 >> 47);
      unint64_t v15 = qword_1EBCBE580 ^ (((0x9DDFEA08EB382D69 * (v14 ^ (0xB492B66FBE98F273 * qword_1EBCBE580))) ^ qword_1EBCBE580) >> 47) ^ (0x9DDFEA08EB382D69 * (v14 ^ (0xB492B66FBE98F273 * qword_1EBCBE580)));
      uint64_t v16 = v7[6];
      uint64_t v17 = v7[7];
      uint64_t v18 = v7[1];
      uint64_t v19 = v13 + qword_1EBCBE580 + v18;
      uint64_t v20 = v7[5];
      unint64_t v21 = v20
          + v13
          - 0x4B6D499041670D8DLL * __ROR8__(v16 + qword_1EBCBE580 - 0x4B6D499041670D8DLL * qword_1EBCBE580, 42);
      uint64_t v22 = *v7 - 0x6D8ED9027DD26057 * qword_1EBCBE580;
      uint64_t v24 = v7[2];
      uint64_t v23 = v7[3];
      uint64_t v25 = v22 + v18 + v24;
      unint64_t v26 = 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * v15) ^ ((0x9DDFEA08EB382D69 * v15) >> 47));
      unint64_t v27 = (0xB492B66FBE98F273 * __ROR8__(v19, 37)) ^ v26;
      uint64_t v28 = __ROR8__(v25, 44) + v22 + __ROR8__(v27 + v14 + v22 + v23, 21);
      uint64_t v29 = __ROR8__(v14 - 0x622015F714C7D297 * (v12 ^ (v12 >> 47)), 33);
      uint64_t v30 = v9 & 0x7FFFFFFC0;
      unint64_t v31 = 0xB492B66FBE98F273 * v29;
      uint64_t v32 = v25 + v23;
      uint64_t v33 = v26 + v7[4] - 0x4B6D499041670D8DLL * v29;
      uint64_t v34 = v20 + v16 + v33;
      uint64_t v35 = __ROR8__(v34, 44) + v33 + __ROR8__(v21 + v24 + v17 + v33, 21);
      uint64_t v36 = v34 + v17;
      uint64_t v37 = v30 - 64;
      if (v30 == 64)
      {
        unint64_t v38 = v27;
      }
      else
      {
        BOOL v39 = v7 + 15;
        do
        {
          uint64_t v40 = *(v39 - 6);
          uint64_t v41 = __ROR8__(v21 + v31 + v32 + v40, 37);
          uint64_t v43 = *(v39 - 2);
          uint64_t v42 = *(v39 - 1);
          unint64_t v21 = v43 + v32 - 0x4B6D499041670D8DLL * __ROR8__(v28 + v21 + v42, 42);
          uint64_t v44 = v36 + v27;
          uint64_t v45 = *(v39 - 7) - 0x4B6D499041670D8DLL * v28;
          uint64_t v46 = *(v39 - 4);
          uint64_t v47 = *(v39 - 5);
          uint64_t v48 = v45 + v40 + v47;
          unint64_t v38 = (0xB492B66FBE98F273 * v41) ^ v35;
          unint64_t v31 = 0xB492B66FBE98F273 * __ROR8__(v44, 33);
          uint64_t v28 = __ROR8__(v48, 44) + v45 + __ROR8__(v38 + v36 + v45 + v46, 21);
          uint64_t v32 = v48 + v46;
          unint64_t v49 = v31 + v35 + *(v39 - 3);
          uint64_t v50 = *v39;
          v39 += 8;
          uint64_t v51 = __ROR8__(v21 + v47 + v49 + v50, 21);
          unint64_t v52 = v43 + v42 + v49;
          uint64_t v35 = __ROR8__(v52, 44) + v49 + v51;
          uint64_t v36 = v52 + v50;
          unint64_t v27 = v38;
          v37 -= 64;
        }
        while (v37);
      }
      if ((v8 & 7) != 0)
      {
        uint64_t v53 = &v7[v8];
        uint64_t v54 = *(v53 - 7);
        uint64_t v55 = *(v53 - 2);
        uint64_t v56 = *(v53 - 1);
        uint64_t v57 = v38 + v36;
        unint64_t v58 = (0xB492B66FBE98F273 * __ROR8__(v21 + v32 + v31 + v54, 37)) ^ v35;
        uint64_t v60 = *(v53 - 4);
        uint64_t v59 = *(v53 - 3);
        unint64_t v21 = v59 + v32 - 0x4B6D499041670D8DLL * __ROR8__(v21 + v28 + v55, 42);
        uint64_t v61 = v58 + v36;
        uint64_t v62 = *(v53 - 8) - 0x4B6D499041670D8DLL * v28;
        uint64_t v65 = v53 - 6;
        uint64_t v64 = *(v53 - 6);
        uint64_t v63 = v65[1];
        uint64_t v66 = v62 + v54 + v64;
        unint64_t v31 = 0xB492B66FBE98F273 * __ROR8__(v57, 33);
        uint64_t v28 = __ROR8__(v66, 44) + v62 + __ROR8__(v61 + v62 + v63, 21);
        uint64_t v32 = v66 + v63;
        unint64_t v67 = v31 + v35 + v60;
        unint64_t v68 = v59 + v55 + v67;
        uint64_t v35 = __ROR8__(v68, 44) + v67 + __ROR8__(v21 + v64 + v67 + v56, 21);
        uint64_t v36 = v68 + v56;
        unint64_t v38 = v58;
      }
      unint64_t v69 = 0x9DDFEA08EB382D69
          * (v35 ^ ((0x9DDFEA08EB382D69 * (v28 ^ v35)) >> 47) ^ (0x9DDFEA08EB382D69 * (v28 ^ v35)));
      uint64_t v70 = v31 - 0x5B6A4C820B386C68 * v8 - 0x622015F714C7D297 * (v69 ^ (v69 >> 47));
      unint64_t v71 = 0x9DDFEA08EB382D69
          * ((v38
            - 0x4B6D499041670D8DLL * (v21 ^ (v21 >> 47))
            - 0x622015F714C7D297
            * ((0x9DDFEA08EB382D69
              * (v36 ^ ((0x9DDFEA08EB382D69 * (v32 ^ v36)) >> 47) ^ (0x9DDFEA08EB382D69 * (v32 ^ v36)))) ^ ((0x9DDFEA08EB382D69 * (v36 ^ ((0x9DDFEA08EB382D69 * (v32 ^ v36)) >> 47) ^ (0x9DDFEA08EB382D69 * (v32 ^ v36)))) >> 47))) ^ v70);
      unint64_t v10 = 0x9DDFEA08EB382D69
          * ((0x9DDFEA08EB382D69 * (v70 ^ (v71 >> 47) ^ v71)) ^ ((0x9DDFEA08EB382D69 * (v70 ^ (v71 >> 47) ^ v71)) >> 47));
    }
    else
    {
      LODWORD(v10) = sub_1CBAE06B8(v7, v9, qword_1EBCBE580);
    }
    uint64_t v72 = 0;
    unsigned int v73 = (a2 - 1) & v10;
    uint64_t v74 = *(unsigned int *)(a3 + 8);
    unsigned int v87 = *(void **)a3;
    int v75 = v91;
    __int16 v76 = __s2;
    uint64_t __n = 8 * v91;
    for (int i = 1; ; ++i)
    {
      uint64_t v78 = a1 + 56 * v73;
      int v79 = *(_DWORD *)(v78 + 8);
      if (v74 == v79 && !memcmp(v87, *(const void **)v78, 8 * v74))
      {
        uint64_t v11 = 1;
        goto LABEL_27;
      }
      if (v79 == v75 && !memcmp(*(const void **)v78, v76, __n)) {
        break;
      }
      BOOL v80 = v79 == 1 && memcmp(*(const void **)v78, v89, 8uLL) == 0;
      if (v80 && v72 == 0) {
        uint64_t v72 = a1 + 56 * v73;
      }
      unsigned int v81 = v73 + i;
      unsigned int v73 = v81 & (a2 - 1);
    }
    uint64_t v11 = 0;
    if (v72) {
      uint64_t v78 = v72;
    }
LABEL_27:
    *a4 = v78;
    if (v76 != v92) {
      free(v76);
    }
  }
  else
  {
    uint64_t v11 = 0;
    *a4 = 0;
  }
  return v11;
}

void sub_1CD35C544(uint64_t a1, int a2)
{
  v20[4] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  *(void *)a1 = operator new(56 * v8, (std::align_val_t)8uLL);
  if (v4)
  {
    sub_1CD35C794(a1);
    __s2 = v20;
    v20[0] = -1;
    uint64_t v19 = 0x400000001;
    unint64_t v15 = v17;
    v17[0] = -2;
    uint64_t v16 = 0x400000001;
    if (v3)
    {
      uint64_t v9 = 56 * v3;
      uint64_t v10 = v4;
      do
      {
        uint64_t v11 = *(unsigned int *)(v10 + 8);
        if (v11 != v19 || (unint64_t v12 = *(void **)v10, memcmp(*(const void **)v10, __s2, 8 * v11)))
        {
          if (v11 != v16 || (unint64_t v12 = *(void **)v10, memcmp(*(const void **)v10, v15, 8 * v11)))
          {
            uint64_t v14 = 0;
            sub_1CD35BFC0(*(void *)a1, *(_DWORD *)(a1 + 16), v10, &v14);
            uint64_t v13 = v14;
            sub_1CD41C56C(v14, v10);
            *(void *)(v13 + 48) = *(void *)(v10 + 48);
            ++*(_DWORD *)(a1 + 8);
            unint64_t v12 = *(void **)v10;
          }
        }
        if ((void *)(v10 + 16) != v12) {
          free(v12);
        }
        v10 += 56;
        v9 -= 56;
      }
      while (v9);
      if (v15 != v17) {
        free(v15);
      }
    }
    if (__s2 != v20) {
      free(__s2);
    }
    JUMPOUT(0x1D25D9CD0);
  }

  sub_1CD35C794(a1);
}

void sub_1CD35C794(uint64_t a1)
{
  v6[4] = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = 0;
  uint64_t v4 = v6;
  v6[0] = -1;
  uint64_t v5 = 0x400000001;
  uint64_t v1 = *(unsigned int *)(a1 + 16);
  if (v1)
  {
    uint64_t v2 = *(void **)a1;
    uint64_t v3 = 56 * v1;
    do
    {
      *uint64_t v2 = v2 + 2;
      v2[1] = 0x400000000;
      if (v5) {
        uint64_t v2 = (void *)sub_1CBB10328((uint64_t)v2, (uint64_t)&v4);
      }
      v2 += 7;
      v3 -= 56;
    }
    while (v3);
    if (v4 != v6) {
      free(v4);
    }
  }
}

void sub_1CD35C864(uint64_t a1, unint64_t a2)
{
  if (HIDWORD(a2)) {
    sub_1CD0A88F0(a2);
  }
  uint64_t v3 = *(unsigned int *)(a1 + 12);
  if (v3 == -1) {
    sub_1CD0A89A8(0xFFFFFFFFuLL);
  }
  unint64_t v4 = (2 * v3) | 1;
  if (v4 <= a2) {
    unint64_t v4 = a2;
  }
  if (v4 >= 0xFFFFFFFF) {
    uint64_t v5 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v5 = v4;
  }
  unint64_t v6 = malloc_type_malloc(56 * v5, 0x4065EBACuLL);
  if (!v6) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  int v7 = v6;
  sub_1CD35C920((uint64_t *)a1, (uint64_t)v6);
  if (*(void *)a1 != a1 + 16) {
    free(*(void **)a1);
  }
  *(void *)a1 = v7;
  *(_DWORD *)(a1 + 12) = v5;
}

void sub_1CD35C920(uint64_t *a1, uint64_t a2)
{
  unsigned int v2 = *((_DWORD *)a1 + 2);
  if (v2)
  {
    uint64_t v4 = *a1 + 56 * v2;
    uint64_t v5 = a2 + 24;
    uint64_t v6 = *a1 + 8;
    do
    {
      uint64_t v7 = v6 - 8;
      *(void *)(v5 - 24) = *(void *)(v6 - 8);
      *(void *)(v5 - 16) = v5;
      *(void *)(v5 - 8) = 0x400000000;
      if (*(_DWORD *)(v6 + 8)) {
        sub_1CD41C56C(v5 - 16, v6);
      }
      v5 += 56;
      v6 += 56;
    }
    while (v7 + 56 != v4);
    uint64_t v8 = *((unsigned int *)a1 + 2);
    if (v8)
    {
      uint64_t v9 = *a1;
      uint64_t v10 = 56 * v8;
      do
      {
        uint64_t v11 = *(void **)(v9 + v10 - 48);
        if ((void *)(v9 + v10 - 32) != v11) {
          free(v11);
        }
        v10 -= 56;
      }
      while (v10);
    }
  }
}

void llvm::VPlanTransforms::VPInstructionsToVPRecipes(const llvm::Loop *a1, uint64_t *a2, uint64_t (*a3)(uint64_t, void *), uint64_t a4, uint64_t *a5, uint64_t a6)
{
  v65[3] = *MEMORY[0x1E4F143B8];
  uint64_t v61 = *(void **)(*(void *)*a2 + 200);
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  unint64_t v58 = 0;
  sub_1CD8EDE88(&v58, (uint64_t *)&v61);
  uint64_t v10 = v59;
  uint64_t v55 = v58;
  if (v59 != v58)
  {
    uint64_t v54 = a4;
    do
    {
      uint64_t v12 = *((void *)v10 - 1);
      v10 -= 8;
      uint64_t v11 = v12;
      if (*(_DWORD *)(v12 + 56) && *(_DWORD *)(v11 + 80))
      {
        if (*(unsigned char *)(v11 + 8) == 1)
        {
          do
          {
            uint64_t v11 = *(void *)(v11 + 200);
            if (v11) {
              BOOL v13 = *(unsigned char *)(v11 + 8) == 1;
            }
            else {
              BOOL v13 = 0;
            }
          }
          while (v13);
        }
        uint64_t v14 = v11 + 200;
        uint64_t v15 = *(void *)(v11 + 208);
        uint64_t v56 = v14;
        if (v15 != v14)
        {
          do
          {
            if (v15) {
              uint64_t v16 = v15 - 24;
            }
            else {
              uint64_t v16 = 0;
            }
            uint64_t v17 = *(void *)(v16 + 16);
            unint64_t v18 = v17 & 0xFFFFFFFFFFFFFFF8;
            if ((v17 & 4) != 0) {
              unint64_t v18 = **(void **)v18;
            }
            uint64_t v19 = *(void *)(v18 + 40);
            uint64_t v21 = *a5;
            uint64_t v20 = a5[1];
            if (v20 == *a5)
            {
              uint64_t v22 = *((unsigned int *)a5 + 5);
              uint64_t v23 = (void *)(v20 + 8 * v22);
              if (v22)
              {
                uint64_t v24 = 0;
                while (*(void *)(v20 + v24) != v19)
                {
                  v24 += 8;
                  if (8 * v22 == v24) {
                    goto LABEL_35;
                  }
                }
                uint64_t v23 = (void *)(v20 + v24);
              }
LABEL_35:
              uint64_t v21 = a5[1];
            }
            else
            {
              uint64_t v25 = *((unsigned int *)a5 + 4);
              int v26 = v25 - 1;
              unsigned int v27 = (v25 - 1) & ((v19 >> 4) ^ (v19 >> 9));
              uint64_t v23 = (void *)(v20 + 8 * v27);
              uint64_t v28 = *v23;
              if (*v23 == -1)
              {
                uint64_t v29 = 0;
LABEL_53:
                if (v29) {
                  uint64_t v23 = v29;
                }
                LODWORD(v22) = *((_DWORD *)a5 + 5);
                uint64_t v42 = (void *)(v20 + 8 * v25);
                if (*v23 != v19) {
                  uint64_t v23 = v42;
                }
              }
              else
              {
                uint64_t v29 = 0;
                int v30 = 1;
                while (v28 != v19)
                {
                  if (v29) {
                    BOOL v31 = 0;
                  }
                  else {
                    BOOL v31 = v28 == -2;
                  }
                  if (v31) {
                    uint64_t v29 = v23;
                  }
                  unsigned int v32 = v27 + v30++;
                  unsigned int v27 = v32 & v26;
                  uint64_t v23 = (void *)(v20 + 8 * (v32 & v26));
                  uint64_t v28 = *v23;
                  if (*v23 == -1) {
                    goto LABEL_53;
                  }
                }
                LODWORD(v22) = *((_DWORD *)a5 + 5);
              }
            }
            if (v20 == v21) {
              unsigned int v33 = v22;
            }
            else {
              unsigned int v33 = *((_DWORD *)a5 + 4);
            }
            uint64_t v57 = *(void *)(v15 + 8);
            if (v23 == (void *)(v20 + 8 * v33))
            {
              if (!v15 || *(unsigned char *)(v16 + 8) != 16)
              {
                int v39 = *(unsigned __int8 *)(v19 + 16);
                if (v19 && v39 == 60) {
                  operator new();
                }
                if (v19 && v39 == 61) {
                  operator new();
                }
                if (v19 && v39 == 62) {
                  operator new();
                }
                if (v19 && v39 == 84) {
                  operator new();
                }
                if (!v19 || v39 != 85) {
                  operator new();
                }
                unint64_t v43 = *(void *)(v19 - 96);
                uint64_t v44 = *(void *)(a6 + 104);
                unsigned int v45 = *(_DWORD *)(a6 + 120);
                if (!v45) {
                  goto LABEL_75;
                }
                unsigned int v46 = ((v43 >> 4) ^ (v43 >> 9)) & (v45 - 1);
                uint64_t v47 = v44 + 48 * v46;
                uint64_t v48 = *(void *)(v47 + 24);
                if (v48 != v43)
                {
                  int v49 = 1;
                  while (v48 != -4096)
                  {
                    unsigned int v50 = v46 + v49++;
                    unsigned int v46 = v50 & (v45 - 1);
                    uint64_t v47 = v44 + 48 * v46;
                    uint64_t v48 = *(void *)(v47 + 24);
                    if (v48 == v43) {
                      goto LABEL_76;
                    }
                  }
LABEL_75:
                  uint64_t v47 = v44 + 48 * v45;
                }
LABEL_76:
                if (v47 == v44 + 48 * v45 || (SCEVIter = *(const llvm::SCEV **)(v47 + 40)) == 0) {
                  SCEVIter = (const llvm::SCEV *)llvm::ScalarEvolution::createSCEVIter((llvm::ScalarEvolution *)a6, v43);
                }
                llvm::ScalarEvolution::getLoopDisposition((llvm::ScalarEvolution *)a6, SCEVIter, a1);
                operator new();
              }
              uint64_t v34 = *(void **)(v16 + 136);
              uint64_t v35 = a3(v54, v34);
              if (v35)
              {
                uint64_t v40 = v35;
                sub_1CD8D066C(*a2, *(void *)(v35 + 16));
                llvm::vputils::getOrCreateVPValueForSCEVExpr((llvm::vputils *)*a2, *(llvm::VPlan **)(v40 + 32), (const llvm::SCEV *)a6, v41);
                operator new();
              }
              uint64_t v36 = *a2;
              uint64_t v61 = v34;
              sub_1CD4F8350((uint64_t *)(v36 + 184), &v61)[1] = v16 + 96;
            }
            else
            {
              uint64_t v61 = &unk_1F264BF30;
              char v62 = 0;
              uint64_t v63 = v65;
              uint64_t v64 = 0x100000000;
              v65[1] = 0;
              v65[2] = 0;
              llvm::VPValue::replaceAllUsesWith(v18, (llvm::VPValue *)&v61);
              uint64_t v38 = *(void *)(v16 + 24);
              uint64_t v37 = *(void **)(v16 + 32);
              *uint64_t v37 = v38;
              *(void *)(v38 + 8) = v37;
              *(void *)(v16 + 24) = 0;
              *(void *)(v16 + 32) = 0;
              (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
              llvm::VPValue::~VPValue((llvm::VPValue *)&v61);
            }
            uint64_t v15 = v57;
          }
          while (v57 != v56);
        }
      }
    }
    while (v10 != v55);
    uint64_t v10 = v58;
  }
  if (v10)
  {
    uint64_t v59 = v10;
    operator delete(v10);
  }
}

uint64_t llvm::VPlanTransforms::sinkScalarOperands(void **this, llvm::VPlan *a2)
{
  v60[18] = *(void **)MEMORY[0x1E4F143B8];
  v57[0] = *this;
  sub_1CD8C916C((uint64_t *)v57, v55);
  v50[1] = 0;
  v50[0] = 0;
  int v51 = 0;
  uint64_t v54 = 0;
  uint64_t v52 = 0;
  uint64_t v53 = 0;
  sub_1CD8C91F4((llvm::SmallPtrSetImplBase *)v55, v57);
  sub_1CD8D5BDC((uint64_t)v46, (llvm::SmallPtrSetImplBase *)v57);
  sub_1CD8D5BDC((uint64_t)v42, (llvm::SmallPtrSetImplBase *)v59);
  while (1)
  {
    if (v48 - v47 != v44 - v43) {
      goto LABEL_20;
    }
    if (v47 == v48) {
      break;
    }
    uint64_t v2 = v43 + 16;
    uint64_t v3 = v47 + 16;
    while (1)
    {
      uint64_t v4 = v3 - 16;
      if (*(void *)(v3 - 16) != *(void *)(v2 - 16)) {
        break;
      }
      int v5 = *(unsigned __int8 *)(v2 + 8);
      if (*(unsigned char *)(v3 + 8)) {
        BOOL v6 = v5 == 0;
      }
      else {
        BOOL v6 = 1;
      }
      if (v6)
      {
        if ((*(unsigned char *)(v3 + 8) == 0) == (v5 != 0)) {
          break;
        }
      }
      else if (*(void *)(v3 - 8) != *(void *)(v2 - 8) || *(void *)v3 != *(void *)v2)
      {
        break;
      }
      v2 += 32;
      v3 += 32;
      if (v4 + 32 == v48) {
        goto LABEL_35;
      }
    }
LABEL_20:
    uint64_t v8 = *(void *)(v48 - 32);
    uint64_t v9 = v8 + 200;
    for (uint64_t i = *(void *)(v8 + 208); i != v9; uint64_t i = *(void *)(i + 8))
    {
      uint64_t v11 = i - 24;
      if (!i) {
        uint64_t v11 = 0;
      }
      int v12 = *(unsigned __int8 *)(v11 + 8);
      if (v12 == 5) {
        uint64_t v13 = v11;
      }
      else {
        uint64_t v13 = 0;
      }
      if (i)
      {
        if (v12 == 5)
        {
          if (*(unsigned char *)(v13 + 153))
          {
            uint64_t v14 = *(unsigned int *)(v13 + 56);
            if (v14)
            {
              uint64_t v15 = *(uint64_t **)(v13 + 48);
              uint64_t v16 = 8 * v14;
              do
              {
                uint64_t v17 = *v15++;
                v41[0] = *(void *)(v13 + 88);
                v41[1] = v17;
                sub_1CBF5F5F4(v50, v41);
                v16 -= 8;
              }
              while (v16);
            }
          }
        }
      }
    }
    sub_1CD8DAA80((uint64_t)v46);
  }
LABEL_35:
  sub_1CD8D55E4(&v45);
  sub_1CD8D55E4(v42);
  sub_1CD8D55E4(&v49);
  sub_1CD8D55E4(v46);
  sub_1CD8D55E4(v60);
  sub_1CD8D55E4(v59);
  sub_1CD8D55E4(&v58);
  sub_1CD8D55E4(v57);
  uint64_t v18 = v53;
  if (v52 == v53)
  {
    char v19 = 0;
  }
  else
  {
    char v19 = 0;
    do
    {
      uint64_t v21 = *(uint64_t **)(v18 - 16);
      uint64_t v20 = *(void *)(v18 - 8);
      sub_1CD8F2114((uint64_t)v50);
      uint64_t v22 = *(void *)(v20 + 48);
      if (v22
        && *(unsigned char *)(v22 + 8) == 5
        && !*(unsigned char *)(v22 + 152)
        && *(uint64_t **)(v22 + 88) != v21
        && (llvm::VPRecipeBase::mayHaveSideEffects((llvm::VPRecipeBase *)v22) & 1) == 0
        && (llvm::VPRecipeBase::mayReadFromMemory((llvm::VPRecipeBase *)v22) & 1) == 0
        && (llvm::VPRecipeBase::mayWriteToMemory((llvm::VPRecipeBase *)v22) & 1) == 0)
      {
        uint64_t v23 = *(unsigned int *)(v22 + 120);
        if (v23)
        {
          uint64_t v24 = *(uint64_t **)(v22 + 112);
          uint64_t v25 = &v24[v23];
          char v26 = 1;
          while (1)
          {
            uint64_t v27 = *v24;
            if (!*v24 || *(_DWORD *)(*v24 + 40) != 0) {
              break;
            }
            if (*(uint64_t **)(v27 + 48) == v21)
            {
              if (++v24 == v25)
              {
                if ((v26 & 1) == 0) {
LABEL_60:
                }
                  operator new();
                goto LABEL_61;
              }
            }
            else
            {
              if (*(unsigned char *)(v27 - 32) != 10 || **(void **)(v27 + 8) != v22 + 96) {
                break;
              }
              char v26 = 0;
              if (++v24 == v25) {
                goto LABEL_60;
              }
            }
          }
        }
        else
        {
LABEL_61:
          uint64_t v29 = v21 + 25;
          for (int j = (uint64_t *)v21[26]; j != v29; int j = (uint64_t *)j[1])
          {
            BOOL v31 = j - 3;
            if (!j) {
              BOOL v31 = 0;
            }
            if (*((unsigned __int8 *)v31 + 8) - 13 > 7)
            {
              uint64_t v29 = j;
              break;
            }
          }
          uint64_t v32 = *(void *)(v22 + 24);
          unsigned int v33 = *(void **)(v22 + 32);
          uint64_t v34 = v22 + 24;
          void *v33 = v32;
          *(void *)(v32 + 8) = v33;
          *(void *)uint64_t v34 = 0;
          *(void *)(v34 + 8) = 0;
          *(void *)(v34 + 64) = v21;
          uint64_t v35 = *v29;
          *(void *)uint64_t v34 = *v29;
          *(void *)(v34 + 8) = v29;
          *(void *)(v35 + 8) = v34;
          uint64_t *v29 = v34;
          uint64_t v36 = *(unsigned int *)(v34 + 32);
          if (v36)
          {
            uint64_t v37 = *(void ***)(v34 + 24);
            uint64_t v38 = 8 * v36;
            do
            {
              int v39 = *v37++;
              v57[0] = v21;
              v57[1] = v39;
              sub_1CBF5F5F4(v50, (uint64_t *)v57);
              v38 -= 8;
            }
            while (v38);
          }
          char v19 = 1;
        }
      }
      uint64_t v18 = v53;
    }
    while (v52 != v53);
  }
  sub_1CD456CB4(v50);
  sub_1CD8D55E4(&v56);
  sub_1CD8D55E4(v55);
  return v19 & 1;
}

uint64_t getPredicatedMask(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 200);
  if (v1) {
    BOOL v2 = *(unsigned char *)(v1 + 8) == 0;
  }
  else {
    BOOL v2 = 0;
  }
  if (!v2) {
    return 0;
  }
  uint64_t v3 = 2;
  uint64_t v4 = v1 + 200;
  do
  {
    uint64_t v4 = *(void *)(v4 + 8);
    --v3;
  }
  while (v4 != v1 + 200);
  if (v3) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v6 = *(void *)(v1 + 208);
  if (v6) {
    uint64_t v7 = v6 - 24;
  }
  else {
    uint64_t v7 = 0;
  }
  if (!*(unsigned char *)(v7 + 8)) {
    return **(void **)(v7 + 48);
  }
  return result;
}

uint64_t llvm::VPlanTransforms::mergeReplicateRegions(llvm::VPlanTransforms *this, llvm::VPlan *a2)
{
  v90[8] = *MEMORY[0x1E4F143B8];
  v77[0] = 0;
  v77[1] = 0;
  int v78 = 0;
  BOOL v80 = 0;
  unsigned int v81 = 0;
  int v79 = 0;
  uint64_t v74 = *(void *)this;
  sub_1CD8C916C(&v74, v75);
  sub_1CD8F12B8(&v82, (llvm::SmallPtrSetImplBase *)v75);
  sub_1CD8F2274(&v88, (uint64_t)&v82);
  sub_1CD8D55E4(&v87);
  sub_1CD8D55E4(&v86);
  sub_1CD8D55E4(&v85);
  sub_1CD8D55E4(&v82);
  sub_1CD8D55E4(&v76);
  sub_1CD8D55E4(v75);
  if (!v89) {
    goto LABEL_2;
  }
  uint64_t v3 = v88;
  uint64_t v4 = (char *)&v88[v89];
  int v5 = &v84;
  do
  {
    uint64_t v6 = *v3;
    v75[0] = *v3;
    if (v78)
    {
      unsigned int v7 = ((v6 >> 4) ^ (v6 >> 9)) & (v78 - 1);
      uint64_t v8 = *(void **)(v77[0] + 8 * v7);
      if (v6 == v8)
      {
LABEL_8:
        if (v7 != v78) {
          goto LABEL_40;
        }
      }
      else
      {
        int v26 = 1;
        while (v8 != (void *)-4096)
        {
          unsigned int v27 = v7 + v26++;
          unsigned int v7 = v27 & (v78 - 1);
          uint64_t v8 = *(void **)(v77[0] + 8 * v7);
          if (v6 == v8) {
            goto LABEL_8;
          }
        }
      }
    }
    if (*((_DWORD *)v6 + 20) == 1)
    {
      uint64_t v9 = **((void **)v6 + 9);
      if (v9)
      {
        if (!*(unsigned char *)(v9 + 8) && *(void *)(v9 + 200) == v9 + 200 && *(_DWORD *)(v9 + 80) == 1)
        {
          uint64_t v10 = **(void **)(v9 + 72);
          if (v10)
          {
            if (*(unsigned char *)(v10 + 8) == 1)
            {
              uint64_t v11 = 0;
              uint64_t v12 = *((void *)v6 + 25);
              if (v12 && !*(unsigned char *)(v12 + 8))
              {
                uint64_t v11 = 2;
                uint64_t v13 = v12 + 200;
                do
                {
                  uint64_t v13 = *(void *)(v13 + 8);
                  --v11;
                }
                while (v13 != v12 + 200);
                if (v11)
                {
                  uint64_t v11 = 0;
                }
                else
                {
                  uint64_t v14 = *(void *)(v12 + 208);
                  if (v14) {
                    uint64_t v15 = v14 - 24;
                  }
                  else {
                    uint64_t v15 = 0;
                  }
                  if (!*(unsigned char *)(v15 + 8)) {
                    uint64_t v11 = **(void **)(v15 + 48);
                  }
                }
              }
              uint64_t v16 = *(void *)(v10 + 200);
              if (!v16 || *(unsigned char *)(v16 + 8) != 0) {
                goto LABEL_35;
              }
              uint64_t v18 = 2;
              uint64_t v19 = v16 + 200;
              do
              {
                uint64_t v19 = *(void *)(v19 + 8);
                --v18;
              }
              while (v19 != v16 + 200);
              if (!v18)
              {
                uint64_t v20 = 0;
                uint64_t v24 = *(void *)(v16 + 208);
                if (v24) {
                  uint64_t v25 = v24 - 24;
                }
                else {
                  uint64_t v25 = 0;
                }
                if (!*(unsigned char *)(v25 + 8)) {
                  uint64_t v20 = **(void **)(v25 + 48);
                }
              }
              else
              {
LABEL_35:
                uint64_t v20 = 0;
              }
              if (v11)
              {
                if (v11 == v20)
                {
                  uint64_t v21 = sub_1CD35DEEC(v12);
                  uint64_t v22 = sub_1CD35DEEC(v16);
                  if (v21)
                  {
                    uint64_t v23 = v22;
                    if (v22)
                    {
                      uint64_t v28 = *(uint64_t **)(v21 + 200);
                      if (v28 != (uint64_t *)(v21 + 200))
                      {
                        uint64_t v29 = (uint64_t *)(v22 + 200);
                        do
                        {
                          int v30 = (uint64_t *)(v22 + 200);
                          if (*(uint64_t **)(v22 + 208) != v29)
                          {
                            int v30 = *(uint64_t **)(v22 + 208);
                            while (1)
                            {
                              BOOL v31 = v30 - 3;
                              if (!v30) {
                                BOOL v31 = 0;
                              }
                              if (*((unsigned __int8 *)v31 + 8) - 13 > 7) {
                                break;
                              }
                              int v30 = (uint64_t *)v30[1];
                              if (v30 == v29)
                              {
                                int v30 = (uint64_t *)(v22 + 200);
                                break;
                              }
                            }
                          }
                          uint64_t v32 = (uint64_t *)*v28;
                          unsigned int v33 = (uint64_t *)v28[1];
                          uint64_t *v33 = *v28;
                          v32[1] = (uint64_t)v33;
                          *uint64_t v28 = 0;
                          v28[1] = 0;
                          v28[8] = v22;
                          uint64_t v34 = *v30;
                          *uint64_t v28 = *v30;
                          v28[1] = (uint64_t)v30;
                          *(void *)(v34 + 8) = v28;
                          uint64_t *v30 = (uint64_t)v28;
                          uint64_t v28 = v32;
                        }
                        while (v32 != (uint64_t *)(v21 + 200));
                      }
                      if (*(_DWORD *)(v21 + 80) == 1) {
                        uint64_t v35 = **(void **)(v21 + 72);
                      }
                      else {
                        uint64_t v35 = 0;
                      }
                      if (*(_DWORD *)(v22 + 80) == 1) {
                        uint64_t v68 = **(void **)(v22 + 72);
                      }
                      else {
                        uint64_t v68 = 0;
                      }
                      uint64_t v36 = *(uint64_t **)(v35 + 200);
                      unint64_t v69 = (uint64_t *)(v35 + 200);
                      uint64_t v70 = v5;
                      if (v36 != (uint64_t *)(v35 + 200))
                      {
                        do
                        {
                          uint64_t v44 = *(v36 - 1);
                          unint64_t v45 = v44 & 0xFFFFFFFFFFFFFFF8;
                          if ((v44 & 4) != 0) {
                            unint64_t v45 = **(void **)v45;
                          }
                          unint64_t v71 = (uint64_t *)*v36;
                          uint64_t v72 = v36;
                          uint64_t v73 = *(void *)v36[3];
                          unsigned int v46 = *(unsigned char **)(v45 + 16);
                          uint64_t v47 = &v46[8 * *(unsigned int *)(v45 + 24)];
                          int v82 = v5;
                          uint64_t v83 = 0x600000000;
                          sub_1CD47792C((unsigned int *)&v82, v46, v47);
                          if (v83)
                          {
                            uint64_t v52 = (uint64_t *)v82;
                            uint64_t v53 = (uint64_t *)((char *)v82 + 8 * v83);
                            do
                            {
                              uint64_t v54 = *v52;
                              if (*v52) {
                                BOOL v55 = *(_DWORD *)(*v52 + 40) == 0;
                              }
                              else {
                                BOOL v55 = 0;
                              }
                              if (v55 && *(void *)(v54 + 48) == v23)
                              {
                                uint64_t v56 = *(unsigned int *)(v54 + 16);
                                if (v56)
                                {
                                  for (uint64_t i = 0; i != v56; ++i)
                                  {
                                    if (v45 == *(void *)(*(void *)(v54 + 8) + 8 * i)) {
                                      sub_1CD8D1BAC(v54, i, v73);
                                    }
                                  }
                                }
                              }
                              ++v52;
                            }
                            while (v52 != v53);
                          }
                          uint64_t v48 = *(uint64_t **)(v68 + 208);
                          uint64_t v49 = *v72;
                          unsigned int v50 = (uint64_t *)v72[1];
                          *unsigned int v50 = *v72;
                          *(void *)(v49 + 8) = v50;
                          *uint64_t v72 = 0;
                          v72[1] = 0;
                          v72[8] = v68;
                          uint64_t v51 = *v48;
                          *uint64_t v72 = *v48;
                          v72[1] = (uint64_t)v48;
                          *(void *)(v51 + 8) = v72;
                          *uint64_t v48 = (uint64_t)v72;
                          int v5 = v70;
                          if (v82 != v70) {
                            free(v82);
                          }
                          uint64_t v36 = v71;
                        }
                        while (v71 != v69);
                      }
                      uint64_t v37 = v75[0];
                      uint64_t v38 = *((unsigned int *)v75[0] + 14);
                      if (v38)
                      {
                        int v39 = (uint64_t *)*((void *)v75[0] + 6);
                        uint64_t v40 = 8 * v38;
                        do
                        {
                          uint64_t v41 = *v39++;
                          sub_1CD8D15BC(v41, (uint64_t)v37);
                          sub_1CD8D1784(v41, v9);
                          v40 -= 8;
                        }
                        while (v40);
                      }
                      sub_1CD8D15BC((uint64_t)v37, v9);
                      sub_1CD4C96F8((uint64_t)&v82, (uint64_t)v77, (uint64_t *)v75);
                      if (v84)
                      {
                        uint64_t v42 = v80;
                        if (v80 >= v81)
                        {
                          unint64_t v58 = v79;
                          uint64_t v59 = (v80 - v79) >> 3;
                          unint64_t v60 = v59 + 1;
                          if ((unint64_t)(v59 + 1) >> 61) {
                            abort();
                          }
                          uint64_t v61 = v81 - v79;
                          if ((v81 - v79) >> 2 > v60) {
                            unint64_t v60 = v61 >> 2;
                          }
                          if ((unint64_t)v61 >= 0x7FFFFFFFFFFFFFF8) {
                            unint64_t v62 = 0x1FFFFFFFFFFFFFFFLL;
                          }
                          else {
                            unint64_t v62 = v60;
                          }
                          if (v62)
                          {
                            if (v62 >> 61) {
                              sub_1CB833614();
                            }
                            uint64_t v63 = (char *)operator new(8 * v62);
                          }
                          else
                          {
                            uint64_t v63 = 0;
                          }
                          uint64_t v64 = &v63[8 * v59];
                          *(void *)uint64_t v64 = v37;
                          uint64_t v43 = v64 + 8;
                          if (v42 != v58)
                          {
                            do
                            {
                              uint64_t v65 = *((void *)v42 - 1);
                              v42 -= 8;
                              *((void *)v64 - 1) = v65;
                              v64 -= 8;
                            }
                            while (v42 != v58);
                            uint64_t v42 = v79;
                          }
                          int v79 = v64;
                          unsigned int v81 = &v63[8 * v62];
                          if (v42) {
                            operator delete(v42);
                          }
                        }
                        else
                        {
                          *(void *)BOOL v80 = v37;
                          uint64_t v43 = v42 + 8;
                        }
                        BOOL v80 = v43;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
LABEL_40:
    ++v3;
  }
  while (v3 != (void **)v4);
  uint64_t v66 = v79;
  unint64_t v67 = v80;
  while (v66 != v67)
  {
    if (*(void *)v66) {
      (*(void (**)(void))(**(void **)v66 + 8))(*(void *)v66);
    }
    v66 += 8;
  }
LABEL_2:
  if (v88 != v90) {
    free(v88);
  }
  sub_1CD456CB4(v77);
  return 0;
}

uint64_t sub_1CD35DEEC(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 80) != 2) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v3 = *(uint64_t **)(a1 + 72);
  uint64_t v5 = *v3;
  uint64_t v4 = v3[1];
  if (*(unsigned char *)(v5 + 8)) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = v5;
  }
  if (*(unsigned char *)(v4 + 8)) {
    uint64_t v4 = 0;
  }
  if (v6) {
    BOOL v7 = v4 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    uint64_t v8 = *(unsigned int *)(v6 + 80);
    uint64_t v9 = *(unsigned int *)(v4 + 80);
    if (v9 + v8 == 1)
    {
      if (v8 == 1) {
        uint64_t v10 = **(void **)(v6 + 72);
      }
      else {
        uint64_t v10 = 0;
      }
      if (v10 == v4) {
        return v5;
      }
      if (v9 == 1) {
        uint64_t v11 = **(void **)(v4 + 72);
      }
      else {
        uint64_t v11 = 0;
      }
      if (v11 == v6) {
        return v4;
      }
      else {
        return 0;
      }
    }
    return 0;
  }
  return result;
}

uint64_t *llvm::VPlanTransforms::removeRedundantInductionCasts(uint64_t *this, llvm::VPlan *a2)
{
  uint64_t v2 = *this;
  if (*this) {
    BOOL v3 = *(unsigned char *)(*this + 8) == 1;
  }
  else {
    BOOL v3 = 0;
  }
  if (!v3)
  {
    if (*(_DWORD *)(v2 + 80) != 1)
    {
      uint64_t v2 = 0;
      goto LABEL_13;
    }
    uint64_t v2 = **(void **)(v2 + 72);
    if (*(unsigned char *)(v2 + 8) != 1) {
      goto LABEL_13;
    }
  }
  do
  {
    uint64_t v2 = *(void *)(v2 + 200);
    if (v2) {
      BOOL v4 = *(unsigned char *)(v2 + 8) == 1;
    }
    else {
      BOOL v4 = 0;
    }
  }
  while (v4);
LABEL_13:
  uint64_t v5 = v2 + 200;
  uint64_t v6 = *(void *)(v2 + 208);
  if (v6 != v2 + 200)
  {
    uint64_t v7 = *(void *)(v2 + 208);
    while (1)
    {
      uint64_t v8 = v7 - 24;
      if (!v7) {
        uint64_t v8 = 0;
      }
      if (*(unsigned __int8 *)(v8 + 8) - 13 > 7) {
        break;
      }
      uint64_t v7 = *(void *)(v7 + 8);
      if (v7 == v5)
      {
        uint64_t v7 = v5;
        goto LABEL_20;
      }
    }
    while (1)
    {
LABEL_20:
      if (v6 == v7) {
        return this;
      }
      uint64_t v9 = v6 - 24;
      if (!v6) {
        uint64_t v9 = 0;
      }
      int v10 = *(unsigned __int8 *)(v9 + 8);
      if (v10 != 17) {
        uint64_t v9 = 0;
      }
      if (v6 && v10 == 17)
      {
        uint64_t v11 = *(void *)(v9 + 16);
        unint64_t v12 = v11 & 0xFFFFFFFFFFFFFFF8;
        if ((v11 & 4) != 0) {
          unint64_t v12 = **(void **)v12;
        }
        uint64_t v13 = *(void *)(v12 + 40);
        if (!v13 || *(unsigned char *)(v13 + 16) != 66) {
          break;
        }
      }
LABEL_31:
      uint64_t v6 = *(void *)(v6 + 8);
    }
    uint64_t v14 = *(void *)(v9 + 160);
    uint64_t v15 = (llvm::VPValue *)(v9 + 96);
    uint64_t v16 = *(unsigned int *)(v14 + 64);
    unint64_t v17 = v9 + 96;
    if (!v16) {
      goto LABEL_51;
    }
    uint64_t v18 = *(void *)(v14 + 56);
    uint64_t v19 = v18 + 8 * v16;
    unint64_t v17 = (unint64_t)v15;
LABEL_34:
    uint64_t v21 = *(void *)(v19 - 8);
    v19 -= 8;
    uint64_t v20 = v21;
    uint64_t v22 = *(void **)(v17 + 16);
    for (uint64_t i = 8 * *(unsigned int *)(v17 + 24); ; i -= 8)
    {
      uint64_t v24 = *v22 - 40;
      if (!*v22) {
        uint64_t v24 = 0;
      }
      unint64_t v25 = *(void *)(v24 + 16);
      if (v25 < 8) {
        goto LABEL_47;
      }
      unint64_t v26 = v25 & 0xFFFFFFFFFFFFFFF8;
      if ((v25 & 4) != 0)
      {
        if (v26) {
          break;
        }
      }
      if ((v25 & 4) != 0)
      {
        int v27 = *(_DWORD *)(v26 + 8);
LABEL_44:
        if (v27 != 1) {
          goto LABEL_47;
        }
        unint64_t v26 = **(void **)v26;
      }
      if (*(void *)(v26 + 40) == v20)
      {
        uint64_t v28 = *(void *)(*v22 - 24);
        unint64_t v17 = v28 & 0xFFFFFFFFFFFFFFF8;
        if ((v28 & 4) != 0) {
          unint64_t v17 = **(void **)v17;
        }
        if (v19 == v18)
        {
LABEL_51:
          this = (uint64_t *)llvm::VPValue::replaceAllUsesWith(v17, v15);
          goto LABEL_31;
        }
        goto LABEL_34;
      }
LABEL_47:
      ++v22;
    }
    int v27 = *(_DWORD *)(v26 + 8);
    if (!v27) {
      goto LABEL_47;
    }
    goto LABEL_44;
  }
  return this;
}

uint64_t llvm::VPlanTransforms::removeRedundantCanonicalIVs(llvm::VPlanTransforms *this, llvm::VPlan *a2)
{
  uint64_t result = sub_1CD8D082C((uint64_t *)this);
  uint64_t v4 = *(unsigned int *)(result + 120);
  if (!v4) {
    return result;
  }
  uint64_t v5 = *(uint64_t **)(result + 112);
  uint64_t v6 = 8 * v4;
  while (1)
  {
    uint64_t v7 = *v5;
    if (!*(_DWORD *)(*v5 + 40) && *(unsigned char *)(v7 - 32) == 8) {
      break;
    }
    ++v5;
    v6 -= 8;
    if (!v6) {
      return result;
    }
  }
  uint64_t v8 = *(void *)this;
  if (*(void *)this) {
    BOOL v9 = *(unsigned char *)(*(void *)this + 8) == 1;
  }
  else {
    BOOL v9 = 0;
  }
  if (!v9)
  {
    if (*(_DWORD *)(v8 + 80) != 1)
    {
      uint64_t v8 = 0;
      goto LABEL_19;
    }
    uint64_t v8 = **(void **)(v8 + 72);
    if (*(unsigned char *)(v8 + 8) != 1) {
      goto LABEL_19;
    }
  }
  do
  {
    uint64_t v8 = *(void *)(v8 + 200);
    if (v8) {
      BOOL v10 = *(unsigned char *)(v8 + 8) == 1;
    }
    else {
      BOOL v10 = 0;
    }
  }
  while (v10);
LABEL_19:
  uint64_t v11 = v8 + 200;
  uint64_t v12 = *(void *)(v8 + 208);
  if (v12 != v8 + 200)
  {
    uint64_t v13 = *(void *)(v8 + 208);
    while (1)
    {
      uint64_t v14 = v13 - 24;
      if (!v13) {
        uint64_t v14 = 0;
      }
      if (*(unsigned __int8 *)(v14 + 8) - 13 > 7) {
        break;
      }
      uint64_t v13 = *(void *)(v13 + 8);
      if (v13 == v11)
      {
        uint64_t v13 = v11;
        break;
      }
    }
    if (v12 != v13)
    {
      while (1)
      {
        uint64_t v15 = v12 - 24;
        if (!v12) {
          uint64_t v15 = 0;
        }
        int v16 = *(unsigned __int8 *)(v15 + 8);
        uint64_t v17 = v16 == 17 ? v15 : 0;
        if (v12)
        {
          if (v16 == 17)
          {
            uint64_t result = llvm::VPWidenIntOrFpInductionRecipe::isCanonical((llvm::VPWidenIntOrFpInductionRecipe *)v17);
            if (result)
            {
              uint64_t v19 = *(void *)(v17 + 16);
              unint64_t v20 = v19 & 0xFFFFFFFFFFFFFFF8;
              if ((v19 & 4) != 0) {
                unint64_t v20 = **(void **)v20;
              }
              uint64_t v21 = *(void *)(v20 + 40);
              if (!v21 || *(unsigned char *)(v21 + 16) != 66) {
                uint64_t v21 = *(void *)(v17 + 152);
              }
              if (*(void *)v21 == **(void **)(**(void **)(*(void *)(**(void **)(v7 + 8) + 48) + 48) + 40))
              {
                if (*(unsigned char *)(v17 + 169)) {
                  break;
                }
                uint64_t result = llvm::vputils::onlyFirstLaneUsed((llvm::vputils *)(v7 + 56), v18);
                if (result) {
                  break;
                }
              }
            }
          }
        }
        uint64_t v12 = *(void *)(v12 + 8);
        if (v12 == v13) {
          return result;
        }
      }
      llvm::VPValue::replaceAllUsesWith(v7 + 56, (llvm::VPValue *)(v17 + 96));
      uint64_t v23 = *(void *)(v7 - 16);
      uint64_t v22 = *(void **)(v7 - 8);
      *uint64_t v22 = v23;
      *(void *)(v23 + 8) = v22;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 8) = 0;
      uint64_t v24 = *(uint64_t (**)(uint64_t))(*(void *)(v7 - 40) + 8);
      return v24(v7 - 40);
    }
  }
  return result;
}

uint64_t llvm::VPlanTransforms::removeDeadRecipes(uint64_t this, llvm::VPlan *a2, llvm::Loop *a3)
{
  uint64_t v4 = *(void *)this;
  if (*(void *)this) {
    BOOL v5 = *(unsigned char *)(*(void *)this + 8) == 1;
  }
  else {
    BOOL v5 = 0;
  }
  if (!v5)
  {
    if (*(_DWORD *)(v4 + 80) != 1)
    {
      uint64_t v4 = 0;
      goto LABEL_13;
    }
    uint64_t v4 = **(void **)(v4 + 72);
    if (*(unsigned char *)(v4 + 8) != 1) {
      goto LABEL_13;
    }
  }
  do
  {
    uint64_t v4 = *(void *)(v4 + 200);
    if (v4) {
      BOOL v6 = *(unsigned char *)(v4 + 8) == 1;
    }
    else {
      BOOL v6 = 0;
    }
  }
  while (v6);
LABEL_13:
  BOOL v9 = *(void **)(v4 + 200);
  uint64_t v7 = (void *)(v4 + 200);
  uint64_t v8 = v9;
  if (v9 != v7)
  {
    do
    {
      BOOL v10 = (void *)*v8;
      this = llvm::VPRecipeBase::mayHaveSideEffects((llvm::VPRecipeBase *)(v8 - 3));
      if (this) {
        goto LABEL_33;
      }
      uint64_t v12 = v8 - 1;
      unint64_t v11 = *(v8 - 1);
      if (v11 >= 8)
      {
        uint64_t v13 = v8;
        if ((v11 & 4) == 0) {
          goto LABEL_19;
        }
        uint64_t v14 = *(unsigned int *)((v11 & 0xFFFFFFFFFFFFFFF8) + 8);
        if (v14)
        {
          uint64_t v12 = *(void **)(v11 & 0xFFFFFFFFFFFFFFF8);
          uint64_t v13 = &v12[v14];
LABEL_19:
          while (!*(_DWORD *)(*v12 + 24))
          {
            if (++v12 == v13) {
              goto LABEL_21;
            }
          }
          goto LABEL_33;
        }
      }
LABEL_21:
      int v15 = *((unsigned __int8 *)v8 - 16);
      if (v15 == 6)
      {
LABEL_32:
        uint64_t v20 = *v8;
        uint64_t v19 = (void *)v8[1];
        *uint64_t v19 = *v8;
        *(void *)(v20 + 8) = v19;
        *uint64_t v8 = 0;
        v8[1] = 0;
        this = (*(uint64_t (**)(void *))(*(v8 - 3) + 8))(v8 - 3);
        goto LABEL_33;
      }
      if (v15 == 17)
      {
        unint64_t v16 = v11 & 0xFFFFFFFFFFFFFFF8;
        unint64_t v17 = v11 & 0xFFFFFFFFFFFFFFF8;
        if ((v11 & 4) != 0) {
          unint64_t v17 = **(void **)v16;
        }
        if (*(unsigned char *)(*(void *)(v17 + 40) + 16) != 66) {
          goto LABEL_32;
        }
        if ((v11 & 4) == 0)
        {
LABEL_27:
          uint64_t v18 = *(void *)(v16 + 40);
          if (!v18) {
            goto LABEL_32;
          }
          goto LABEL_31;
        }
      }
      else
      {
        unint64_t v16 = v11 & 0xFFFFFFFFFFFFFFF8;
        if ((v11 & 4) == 0) {
          goto LABEL_27;
        }
      }
      uint64_t v18 = *(void *)(**(void **)v16 + 40);
      if (!v18) {
        goto LABEL_32;
      }
LABEL_31:
      this = sub_1CD35EBA4(v18, (uint64_t)a2);
      if ((this & 1) == 0) {
        goto LABEL_32;
      }
LABEL_33:
      uint64_t v8 = v10;
    }
    while (v10 != v7);
  }
  return this;
}

void llvm::VPlanTransforms::optimizeInductions(llvm::VPlanTransforms *this, llvm::VPlan *a2, llvm::ScalarEvolution *a3, llvm::ScalarEvolution *a4)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)this;
  if (*(void *)this) {
    BOOL v5 = *(unsigned char *)(*(void *)this + 8) == 1;
  }
  else {
    BOOL v5 = 0;
  }
  if (!v5)
  {
    if (*(_DWORD *)(v4 + 80) != 1)
    {
      uint64_t v4 = 0;
      goto LABEL_13;
    }
    uint64_t v4 = **(void **)(v4 + 72);
    if (*(unsigned char *)(v4 + 8) != 1) {
      goto LABEL_13;
    }
  }
  do
  {
    uint64_t v4 = *(void *)(v4 + 200);
    if (v4) {
      BOOL v6 = *(unsigned char *)(v4 + 8) == 1;
    }
    else {
      BOOL v6 = 0;
    }
  }
  while (v6);
LABEL_13:
  uint64_t v7 = *(void *)(v4 + 208);
  if (v7 != v4 + 200)
  {
    uint64_t v8 = *(void *)(v4 + 208);
    while (1)
    {
      uint64_t v9 = v8 - 24;
      if (!v8) {
        uint64_t v9 = 0;
      }
      if (*(unsigned __int8 *)(v9 + 8) - 13 > 7) {
        break;
      }
      uint64_t v8 = *(void *)(v8 + 8);
      if (v8 == v4 + 200)
      {
        uint64_t v8 = v4 + 200;
        break;
      }
    }
    while (v7 != v8)
    {
      uint64_t v10 = v7 - 24;
      if (!v7) {
        uint64_t v10 = 0;
      }
      int v11 = *(unsigned __int8 *)(v10 + 8);
      if (v11 == 17) {
        uint64_t v12 = v10;
      }
      else {
        uint64_t v12 = 0;
      }
      if (v7 && v11 == 17)
      {
        if (*(unsigned char *)(v12 + 168))
        {
          llvm::vputils::getOrCreateVPValueForSCEVExpr(this, *(llvm::VPlan **)(*(void *)(v12 + 160) + 32), a2, a4);
          operator new();
        }
      }
      uint64_t v7 = *(void *)(v7 + 8);
    }
  }
}

uint64_t llvm::VPlanTransforms::removeRedundantExpandSCEVRecipes(llvm::VPlanTransforms *this, llvm::VPlan *a2)
{
  int v19 = 0;
  v18[0] = 0;
  v18[1] = 0;
  for (uint64_t i = *(void *)this; i && *(unsigned char *)(i + 8) == 1; uint64_t i = *(void *)(i + 200))
    ;
  uint64_t v4 = i + 200;
  uint64_t v5 = *(void *)(i + 208);
  if (v5 == i + 200)
  {
    uint64_t v12 = 0;
  }
  else
  {
    do
    {
      uint64_t v6 = v5;
      uint64_t v5 = *(void *)(v5 + 8);
      uint64_t v7 = v6 - 24;
      if (!v6) {
        uint64_t v7 = 0;
      }
      int v8 = *(unsigned __int8 *)(v7 + 8);
      if (v8 == 1) {
        uint64_t v9 = (void *)v7;
      }
      else {
        uint64_t v9 = 0;
      }
      if (v6)
      {
        if (v8 == 1)
        {
          uint64_t v14 = v9[19];
          int v15 = v9 + 12;
          sub_1CD686DBC((uint64_t)v18, &v14, &v15, (uint64_t)&v16);
          if (!v17)
          {
            llvm::VPValue::replaceAllUsesWith((uint64_t)(v9 + 12), *(llvm::VPValue **)(v16 + 8));
            uint64_t v11 = v9[3];
            uint64_t v10 = (void *)v9[4];
            void *v10 = v11;
            *(void *)(v11 + 8) = v10;
            void v9[3] = 0;
            int v9[4] = 0;
            (*(void (**)(void *))(*v9 + 8))(v9);
          }
        }
      }
    }
    while (v5 != v4);
    uint64_t v12 = v18[0];
  }
  return MEMORY[0x1D25D9CD0](v12, 8);
}

uint64_t sub_1CD35EBA4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return 0;
  }
  uint64_t v4 = *(void *)(a2 + 56);
  uint64_t v3 = *(void *)(a2 + 64);
  uint64_t v5 = *(unsigned int *)(a2 + 72);
  uint64_t v6 = *(unsigned int *)(a2 + 76);
  int v7 = v5 - 1;
  while (1)
  {
    uint64_t v8 = *(void *)(v2 + 24);
    uint64_t v9 = *(void *)(v8 + 40);
    if (v3 == v4)
    {
      if (v6)
      {
        uint64_t v10 = 0;
        while (*(void *)(v3 + v10) != v9)
        {
          v10 += 8;
          if (8 * v6 == v10)
          {
            unsigned int v11 = v6;
            goto LABEL_23;
          }
        }
        uint64_t v20 = (void *)(v3 + v10);
        unsigned int v11 = v6;
        uint64_t v21 = v3;
      }
      else
      {
        unsigned int v11 = 0;
LABEL_23:
        uint64_t v21 = v3;
        uint64_t v20 = (void *)(v3 + 8 * v6);
      }
    }
    else
    {
      unsigned int v12 = v7 & ((v9 >> 4) ^ (v9 >> 9));
      uint64_t v13 = (void *)(v3 + 8 * v12);
      uint64_t v14 = *v13;
      if (*v13 == -1)
      {
        int v15 = 0;
LABEL_25:
        if (v15) {
          uint64_t v13 = v15;
        }
        uint64_t v19 = *v13;
      }
      else
      {
        int v15 = 0;
        int v16 = 1;
        while (v14 != v9)
        {
          if (v15) {
            BOOL v17 = 0;
          }
          else {
            BOOL v17 = v14 == -2;
          }
          if (v17) {
            int v15 = v13;
          }
          unsigned int v18 = v12 + v16++;
          unsigned int v12 = v18 & v7;
          uint64_t v13 = (void *)(v3 + 8 * (v18 & v7));
          uint64_t v14 = *v13;
          if (*v13 == -1) {
            goto LABEL_25;
          }
        }
        uint64_t v19 = *(void *)(v8 + 40);
      }
      uint64_t v20 = v19 == v9 ? v13 : (void *)(v3 + 8 * v5);
      unsigned int v11 = v6;
      uint64_t v21 = v4;
    }
    if (v3 != v21) {
      unsigned int v11 = v5;
    }
    if (v20 == (void *)(v3 + 8 * v11)
      || v8 && *(unsigned char *)(v8 + 16) == 83 && (*(_DWORD *)(v8 + 20) & 0x7FFFFFF) == 1 && (sub_1CD35EBA4() & 1) != 0)
    {
      return 1;
    }
    uint64_t v2 = *(void *)(v2 + 8);
    if (!v2) {
      return 0;
    }
  }
}

uint64_t sub_1CD35ED34(llvm::SmallPtrSetImplBase *a1, llvm::SmallPtrSetImplBase *a2)
{
  sub_1CD8D5BDC((uint64_t)v15, a1);
  sub_1CD8D5BDC((uint64_t)v11, a2);
  for (uint64_t i = 0; ; ++i)
  {
    if (v17 - v16 != v13 - v12) {
      goto LABEL_20;
    }
    if (v16 == v17) {
      break;
    }
    uint64_t v4 = v12 + 16;
    uint64_t v5 = v16 + 16;
    while (1)
    {
      uint64_t v6 = v5 - 16;
      if (*(void *)(v5 - 16) != *(void *)(v4 - 16)) {
        break;
      }
      int v7 = *(unsigned __int8 *)(v4 + 8);
      if (*(unsigned char *)(v5 + 8)) {
        BOOL v8 = v7 == 0;
      }
      else {
        BOOL v8 = 1;
      }
      if (v8)
      {
        if ((*(unsigned char *)(v5 + 8) == 0) == (v7 != 0)) {
          break;
        }
      }
      else if (*(void *)(v5 - 8) != *(void *)(v4 - 8) || *(void *)v5 != *(void *)v4)
      {
        break;
      }
      v4 += 32;
      v5 += 32;
      if (v6 + 32 == v17) {
        goto LABEL_21;
      }
    }
LABEL_20:
    sub_1CD8F24F0((uint64_t)v15);
  }
LABEL_21:
  sub_1CD8D55E4(&v14);
  sub_1CD8D55E4(v11);
  sub_1CD8D55E4(&v18);
  sub_1CD8D55E4(v15);
  return i;
}

void **sub_1CD35EE4C(uint64_t a1, uint64_t a2, void *a3)
{
  sub_1CD8D56DC(v16, a1);
  sub_1CD8D56DC(v12, a2);
  while (1)
  {
    if (v18 - v17 != v14 - v13) {
      goto LABEL_20;
    }
    if (v17 == v18) {
      break;
    }
    uint64_t v5 = v13 + 16;
    uint64_t v6 = v17 + 16;
    while (1)
    {
      uint64_t v7 = v6 - 16;
      if (*(void *)(v6 - 16) != *(void *)(v5 - 16)) {
        break;
      }
      int v8 = *(unsigned __int8 *)(v5 + 8);
      if (*(unsigned char *)(v6 + 8)) {
        BOOL v9 = v8 == 0;
      }
      else {
        BOOL v9 = 1;
      }
      if (v9)
      {
        if ((*(unsigned char *)(v6 + 8) == 0) == (v8 != 0)) {
          break;
        }
      }
      else if (*(void *)(v6 - 8) != *(void *)(v5 - 8) || *(void *)v6 != *(void *)v5)
      {
        break;
      }
      v5 += 32;
      v6 += 32;
      if (v7 + 32 == v18) {
        goto LABEL_21;
      }
    }
LABEL_20:
    *a3++ = *(void *)(v18 - 32);
    sub_1CD8F24F0((uint64_t)v16);
  }
LABEL_21:
  sub_1CD8D56DC(v20, (uint64_t)v16);
  v21[18] = a3;
  sub_1CD8D55E4(&v15);
  sub_1CD8D55E4(v12);
  sub_1CD8D55E4(&v19);
  sub_1CD8D55E4(v16);
  sub_1CD8D55E4(v21);
  return sub_1CD8D55E4(v20);
}

void sub_1CD35EF90(uint64_t a1)
{
  sub_1CD50D2CC((uint64_t)&v76, *(void *)(a1 + 200));
  __p = 0;
  uint64_t v72 = 0;
  memset(v71, 0, sizeof(v71));
  uint64_t v68 = &v71[2];
  unint64_t v69 = &v71[2];
  uint64_t v70 = 8;
  uint64_t v75 = 0;
  uint64_t v74 = 0;
  sub_1CD8EE138((uint64_t)&v76, (uint64_t)&v68, &v85);
  if (__p)
  {
    uint64_t v74 = __p;
    operator delete(__p);
  }
  if (v69 != v68) {
    free(v69);
  }
  if (v82)
  {
    uint64_t v83 = (char *)v82;
    operator delete(v82);
  }
  if (v77 != v76) {
    free(v77);
  }
  uint64_t v2 = v64;
  uint64_t v59 = v64;
  uint64_t v3 = __src;
  if (__src == v85)
  {
    unint64_t v60 = v64;
    uint64_t v4 = __src;
  }
  else
  {
    unsigned int v34 = v87;
    uint64_t v2 = malloc_type_malloc(8 * v87, 0x4065EBACuLL);
    if (!v2)
    {
      if (v34) {
        goto LABEL_135;
      }
      uint64_t v2 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v2) {
        goto LABEL_135;
      }
    }
    unint64_t v60 = v2;
    uint64_t v4 = v85;
    uint64_t v3 = __src;
  }
  unsigned int v5 = v88;
  unsigned int v61 = v87;
  if (v3 == v4) {
    unsigned int v6 = v88;
  }
  else {
    unsigned int v6 = v87;
  }
  if (v6)
  {
    memmove(v2, v3, 8 * v6);
    unsigned int v5 = v88;
  }
  unsigned int v62 = v5;
  int v63 = v89;
  uint64_t v66 = 0;
  uint64_t v67 = 0;
  uint64_t v65 = 0;
  sub_1CBF340A8(&v65, v90, v91, 0xAAAAAAAAAAAAAAABLL * ((v91 - (unsigned char *)v90) >> 3));
  uint64_t v7 = v55;
  unsigned int v50 = v55;
  int v8 = v93;
  if (v93 == v92)
  {
    uint64_t v51 = v55;
    BOOL v9 = v93;
  }
  else
  {
    unsigned int v35 = v94;
    uint64_t v7 = malloc_type_malloc(8 * v94, 0x4065EBACuLL);
    if (!v7)
    {
      if (v35) {
        goto LABEL_135;
      }
      uint64_t v7 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v7) {
        goto LABEL_135;
      }
    }
    uint64_t v51 = v7;
    BOOL v9 = v92;
    int v8 = v93;
  }
  unsigned int v10 = v95;
  unsigned int v52 = v94;
  if (v8 == v9) {
    unsigned int v11 = v95;
  }
  else {
    unsigned int v11 = v94;
  }
  if (v11)
  {
    memmove(v7, v8, 8 * v11);
    unsigned int v10 = v95;
  }
  unsigned int v53 = v10;
  int v54 = v96;
  uint64_t v57 = 0;
  uint64_t v58 = 0;
  uint64_t v56 = 0;
  sub_1CBF340A8(&v56, v97, v98, 0xAAAAAAAAAAAAAAABLL * ((v98 - (unsigned char *)v97) >> 3));
  while (1)
  {
    if (v66 - (unsigned char *)v65 != v57 - v56) {
      goto LABEL_38;
    }
    if (v65 == v66) {
      break;
    }
    uint64_t v12 = v56 + 8;
    uint64_t v13 = (char *)v65 + 8;
    while (1)
    {
      uint64_t v14 = v13 - 8;
      if (*((void *)v13 - 1) != *((void *)v12 - 1)) {
        break;
      }
      int v15 = v12[8];
      if (v13[8]) {
        BOOL v16 = v15 == 0;
      }
      else {
        BOOL v16 = 1;
      }
      if (v16)
      {
        if ((v13[8] == 0) == (v15 != 0)) {
          break;
        }
      }
      else if (*(void *)v13 != *(void *)v12)
      {
        break;
      }
      v12 += 24;
      v13 += 24;
      if (v14 + 24 == v66) {
        goto LABEL_39;
      }
    }
LABEL_38:
    sub_1CD8DC09C((char *)&v59);
  }
LABEL_39:
  if (v56)
  {
    uint64_t v57 = v56;
    operator delete(v56);
  }
  if (v51 != v50) {
    free(v51);
  }
  if (v65)
  {
    uint64_t v66 = (char *)v65;
    operator delete(v65);
  }
  if (v60 != v59) {
    free(v60);
  }
  if (v97)
  {
    int v98 = v97;
    operator delete(v97);
  }
  if (v93 != v92) {
    free(v93);
  }
  if (v90)
  {
    uint64_t v91 = v90;
    operator delete(v90);
  }
  if (__src != v85) {
    free(__src);
  }
  sub_1CD50D2CC((uint64_t)&v46, *(void *)(a1 + 200));
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  memset(v41, 0, sizeof(v41));
  uint64_t v38 = (char *)v41 + 8;
  int v39 = (char *)v41 + 8;
  uint64_t v40 = 8;
  uint64_t v44 = 0;
  uint64_t v45 = 0;
  sub_1CD8EE138((uint64_t)&v46, (uint64_t)&v38, &v85);
  if (v43)
  {
    uint64_t v44 = v43;
    operator delete(v43);
  }
  if (v39 != v38) {
    free(v39);
  }
  if (v48)
  {
    uint64_t v49 = v48;
    operator delete(v48);
  }
  if (v47 != v46) {
    free(v47);
  }
  uint64_t v17 = v81;
  __int16 v76 = v81;
  uint64_t v18 = __src;
  if (__src == v85)
  {
    uint64_t v77 = v81;
    uint64_t v19 = __src;
    goto LABEL_65;
  }
  unsigned int v36 = v87;
  uint64_t v17 = malloc_type_malloc(8 * v87, 0x4065EBACuLL);
  if (!v17 && (v36 || (uint64_t v17 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0)) {
LABEL_135:
  }
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  uint64_t v77 = v17;
  uint64_t v19 = v85;
  uint64_t v18 = __src;
LABEL_65:
  unsigned int v20 = v88;
  unsigned int v78 = v87;
  if (v18 == v19) {
    unsigned int v21 = v88;
  }
  else {
    unsigned int v21 = v87;
  }
  if (v21)
  {
    memmove(v17, v18, 8 * v21);
    unsigned int v20 = v88;
  }
  unsigned int v79 = v20;
  int v80 = v89;
  uint64_t v84 = 0;
  int v82 = 0;
  uint64_t v83 = 0;
  sub_1CBF340A8(&v82, v90, v91, 0xAAAAAAAAAAAAAAABLL * ((v91 - (unsigned char *)v90) >> 3));
  uint64_t v22 = &v71[2];
  uint64_t v68 = &v71[2];
  uint64_t v23 = v93;
  if (v93 == v92)
  {
    unint64_t v69 = &v71[2];
    uint64_t v24 = v93;
  }
  else
  {
    unsigned int v37 = v94;
    uint64_t v22 = malloc_type_malloc(8 * v94, 0x4065EBACuLL);
    if (!v22)
    {
      if (v37) {
        goto LABEL_135;
      }
      uint64_t v22 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v22) {
        goto LABEL_135;
      }
    }
    unint64_t v69 = v22;
    uint64_t v24 = v92;
    uint64_t v23 = v93;
  }
  unsigned int v25 = v95;
  LODWORD(v70) = v94;
  if (v23 == v24) {
    unsigned int v26 = v95;
  }
  else {
    unsigned int v26 = v94;
  }
  if (v26)
  {
    memmove(v22, v23, 8 * v26);
    unsigned int v25 = v95;
  }
  HIDWORD(v70) = v25;
  v71[0] = v96;
  uint64_t v75 = 0;
  __p = 0;
  uint64_t v74 = 0;
  sub_1CBF340A8(&__p, v97, v98, 0xAAAAAAAAAAAAAAABLL * ((v98 - (unsigned char *)v97) >> 3));
  while (2)
  {
    if (v83 - (unsigned char *)v82 != v74 - (unsigned char *)__p)
    {
LABEL_92:
      uint64_t v32 = *((void *)v83 - 3);
      if (v32) {
        BOOL v33 = *(unsigned char *)(v32 + 8) == 1;
      }
      else {
        BOOL v33 = 0;
      }
      if (v33) {
        sub_1CD35EF90();
      }
      sub_1CD8DC09C((char *)&v76);
      continue;
    }
    break;
  }
  if (v82 != v83)
  {
    int v27 = (char *)__p + 8;
    uint64_t v28 = (char *)v82 + 8;
    do
    {
      uint64_t v29 = v28 - 8;
      if (*((void *)v28 - 1) != *((void *)v27 - 1)) {
        goto LABEL_92;
      }
      int v30 = v27[8];
      if (v28[8]) {
        BOOL v31 = v30 == 0;
      }
      else {
        BOOL v31 = 1;
      }
      if (v31)
      {
        if ((v28[8] == 0) == (v30 != 0)) {
          goto LABEL_92;
        }
      }
      else if (*(void *)v28 != *(void *)v27)
      {
        goto LABEL_92;
      }
      v27 += 24;
      v28 += 24;
    }
    while (v29 + 24 != v83);
  }
  if (__p)
  {
    uint64_t v74 = __p;
    operator delete(__p);
  }
  if (v69 != v68) {
    free(v69);
  }
  if (v82)
  {
    uint64_t v83 = (char *)v82;
    operator delete(v82);
  }
  if (v77 != v76) {
    free(v77);
  }
  if (v97)
  {
    int v98 = v97;
    operator delete(v97);
  }
  if (v93 != v92) {
    free(v93);
  }
  if (v90)
  {
    uint64_t v91 = v90;
    operator delete(v90);
  }
  if (__src != v85) {
    free(__src);
  }
}

uint64_t llvm::VPlanVerifier::verifyPlanIsValid(llvm::VPlanVerifier *this, const llvm::VPlan *a2)
{
  sub_1CD364BD4((uint64_t)&v775, *(unsigned char **)this);
  uint64_t v2 = v870;
  v866 = v870;
  uint64_t v3 = __src;
  if (__src == v775)
  {
    v867 = v870;
    uint64_t v4 = __src;
  }
  else
  {
    unsigned int v320 = v777;
    uint64_t v2 = malloc_type_malloc(8 * v777, 0x4065EBACuLL);
    if (!v2)
    {
      if (v320) {
        goto LABEL_1474;
      }
      uint64_t v2 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v2) {
        goto LABEL_1474;
      }
    }
    v867 = v2;
    uint64_t v4 = v775;
    uint64_t v3 = __src;
  }
  unsigned int v5 = v778;
  LODWORD(v868) = v777;
  if (v3 == v4) {
    unsigned int v6 = v778;
  }
  else {
    unsigned int v6 = v777;
  }
  if (v6)
  {
    memmove(v2, v3, 8 * v6);
    unsigned int v5 = v778;
  }
  HIDWORD(v868) = v5;
  int v869 = v779;
  v872 = 0;
  long long v871 = 0uLL;
  sub_1CD31D500((char *)&v871, (uint64_t)v780, (uint64_t)v781, (v781 - (unsigned char *)v780) >> 5);
  v789 = v794;
  if (v867 == v866)
  {
    v790 = v794;
    int v7 = HIDWORD(v868);
    if (HIDWORD(v868)) {
      memmove(v794, v867, 8 * HIDWORD(v868));
    }
  }
  else
  {
    v790 = v867;
    v867 = v866;
    int v7 = HIDWORD(v868);
  }
  unsigned int v791 = v868;
  int v792 = v7;
  int v793 = v869;
  unint64_t v868 = 8;
  int v869 = 0;
  long long __p = v871;
  v796 = v872;
  v872 = 0;
  long long v871 = 0uLL;
  sub_1CD364DC8((uint64_t)&v911, (uint64_t)&v789);
  int v8 = (char *)__p;
  if ((void)__p)
  {
    for (uint64_t i = (char *)*((void *)&__p + 1); i != v8; i -= 32)
    {
      if (*(i - 8)) {
        *(i - 8) = 0;
      }
    }
    *((void *)&__p + 1) = v8;
    operator delete(v8);
  }
  if (v790 != v789) {
    free(v790);
  }
  unsigned int v10 = v885;
  v881 = v885;
  unsigned int v11 = v783;
  if (v783 == v782)
  {
    v882 = v885;
    uint64_t v12 = v783;
  }
  else
  {
    unsigned int v321 = v784;
    unsigned int v10 = malloc_type_malloc(8 * v784, 0x4065EBACuLL);
    if (!v10)
    {
      if (v321) {
        goto LABEL_1474;
      }
      unsigned int v10 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v10) {
        goto LABEL_1474;
      }
    }
    v882 = v10;
    uint64_t v12 = v782;
    unsigned int v11 = v783;
  }
  unsigned int v13 = v785;
  LODWORD(v883) = v784;
  if (v11 == v12) {
    unsigned int v14 = v785;
  }
  else {
    unsigned int v14 = v784;
  }
  if (v14)
  {
    memmove(v10, v11, 8 * v14);
    unsigned int v13 = v785;
  }
  HIDWORD(v883) = v13;
  int v884 = v786;
  v887 = 0;
  long long v886 = 0uLL;
  sub_1CD31D500((char *)&v886, (uint64_t)v787, (uint64_t)v788, (v788 - (unsigned char *)v787) >> 5);
  v789 = v794;
  if (v882 == v881)
  {
    v790 = v794;
    int v15 = HIDWORD(v883);
    if (HIDWORD(v883)) {
      memmove(v794, v882, 8 * HIDWORD(v883));
    }
  }
  else
  {
    v790 = v882;
    v882 = v881;
    int v15 = HIDWORD(v883);
  }
  unsigned int v791 = v883;
  int v792 = v15;
  int v793 = v884;
  uint64_t v883 = 8;
  int v884 = 0;
  long long __p = v886;
  v796 = v887;
  v887 = 0;
  long long v886 = 0uLL;
  sub_1CD364DC8((uint64_t)&v896, (uint64_t)&v789);
  BOOL v16 = (char *)__p;
  if ((void)__p)
  {
    for (int j = (char *)*((void *)&__p + 1); j != v16; j -= 32)
    {
      if (*(j - 8)) {
        *(j - 8) = 0;
      }
    }
    *((void *)&__p + 1) = v16;
    operator delete(v16);
  }
  if (v790 != v789) {
    free(v790);
  }
  v789 = v794;
  uint64_t v18 = v912;
  if (v912 == v911)
  {
    v790 = v794;
    unsigned int v19 = HIDWORD(v913);
    if (HIDWORD(v913)) {
      memmove(v794, v912, 8 * HIDWORD(v913));
    }
    uint64_t v18 = v794;
  }
  else
  {
    v790 = v912;
    v912 = v911;
    unsigned int v19 = HIDWORD(v913);
  }
  unsigned int v20 = v913;
  int v21 = v914;
  unsigned int v791 = v913;
  int v792 = v19;
  int v793 = v914;
  unint64_t v913 = 8;
  int v914 = 0;
  uint64_t v22 = *((void *)&v916 + 1);
  v708 = (void *)v916;
  long long __p = v916;
  uint64_t v23 = v917;
  v796 = v917;
  v917 = 0;
  long long v916 = 0uLL;
  v926 = v930;
  uint64_t v24 = v897;
  unsigned int v25 = v896;
  uint64_t v716 = v896;
  if (v897 == v896)
  {
    v927 = v930;
    unsigned int v26 = HIDWORD(v898);
    if (HIDWORD(v898))
    {
      int v27 = v18;
      unsigned int v28 = v20;
      int v29 = v21;
      int v30 = v23;
      uint64_t v31 = v22;
      memmove(v930, v897, 8 * HIDWORD(v898));
      uint64_t v18 = v27;
      uint64_t v22 = v31;
      uint64_t v23 = v30;
      int v21 = v29;
      unsigned int v20 = v28;
    }
    unsigned int v25 = v24;
    uint64_t v24 = v930;
  }
  else
  {
    v897 = v896;
    unsigned int v26 = HIDWORD(v898);
  }
  unsigned int v32 = v898;
  int v33 = v899;
  unint64_t v898 = 8;
  int v899 = 0;
  uint64_t v35 = *((void *)&v901 + 1);
  unsigned int v34 = (void *)v901;
  long long v931 = v901;
  unsigned int v36 = v902;
  v932 = v902;
  v902 = 0;
  long long v901 = 0uLL;
  v824 = v829;
  if (v18 == v794)
  {
    v825 = v829;
    if (v19)
    {
      unsigned int v37 = v20;
      int __dstd = v33;
      int v38 = v21;
      uint64_t v688 = v35;
      long long v696 = v34;
      int v39 = v23;
      unsigned int v680 = v32;
      uint64_t v40 = v25;
      uint64_t v41 = v22;
      uint64_t v42 = v36;
      memcpy(v829, v794, 8 * v19);
      unsigned int v36 = v42;
      uint64_t v22 = v41;
      unsigned int v25 = v40;
      unsigned int v32 = v680;
      uint64_t v23 = v39;
      uint64_t v35 = v688;
      unsigned int v34 = v696;
      int v21 = v38;
      int v33 = __dstd;
      unsigned int v20 = v37;
    }
  }
  else
  {
    v825 = v18;
  }
  unsigned int v826 = v20;
  int v827 = v19;
  int v828 = v21;
  v830 = v708;
  v831 = (unsigned char *)v22;
  v832 = v23;
  v833 = v838;
  if (v24 == v930)
  {
    v834 = v838;
    if (v26)
    {
      uint64_t v43 = v36;
      memcpy(v838, v930, 8 * v26);
      unsigned int v36 = v43;
    }
  }
  else
  {
    v834 = v24;
  }
  unsigned int v835 = v32;
  int v836 = v26;
  int v837 = v33;
  v839 = v34;
  v840 = (unsigned char *)v35;
  v841 = v36;
  if (v25 != v716) {
    free(v25);
  }
  uint64_t v44 = (char *)v886;
  if ((void)v886)
  {
    for (k = (char *)*((void *)&v886 + 1); k != v44; k -= 32)
    {
      if (*(k - 8)) {
        *(k - 8) = 0;
      }
    }
    *((void *)&v886 + 1) = v44;
    operator delete(v44);
  }
  if (v882 != v881) {
    free(v882);
  }
  unsigned int v46 = (char *)v916;
  if ((void)v916)
  {
    for (m = (char *)*((void *)&v916 + 1); m != v46; m -= 32)
    {
      if (*(m - 8)) {
        *(m - 8) = 0;
      }
    }
    *((void *)&v916 + 1) = v46;
    operator delete(v46);
  }
  if (v912 != v911) {
    free(v912);
  }
  uint64_t v48 = (char *)v871;
  if ((void)v871)
  {
    for (n = (char *)*((void *)&v871 + 1); n != v48; n -= 32)
    {
      if (*(n - 8)) {
        *(n - 8) = 0;
      }
    }
    *((void *)&v871 + 1) = v48;
    operator delete(v48);
  }
  if (v867 != v866) {
    free(v867);
  }
  unsigned int v50 = v885;
  v881 = v885;
  uint64_t v51 = v825;
  if (v825 == v824)
  {
    v882 = v885;
    unsigned int v52 = v825;
  }
  else
  {
    unsigned int v322 = v826;
    unsigned int v50 = malloc_type_malloc(8 * v826, 0x4065EBACuLL);
    if (!v50)
    {
      if (v322) {
        goto LABEL_1474;
      }
      unsigned int v50 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v50) {
        goto LABEL_1474;
      }
    }
    v882 = v50;
    unsigned int v52 = v824;
    uint64_t v51 = v825;
  }
  int v53 = v827;
  LODWORD(v883) = v826;
  if (v51 == v52) {
    unsigned int v54 = v827;
  }
  else {
    unsigned int v54 = v826;
  }
  if (v54)
  {
    memmove(v50, v51, 8 * v54);
    int v53 = v827;
  }
  HIDWORD(v883) = v53;
  int v884 = v828;
  v887 = 0;
  long long v886 = 0uLL;
  sub_1CD31D500((char *)&v886, (uint64_t)v830, (uint64_t)v831, (v831 - (unsigned char *)v830) >> 5);
  BOOL v55 = v855;
  v851 = v855;
  uint64_t v56 = v834;
  if (v834 == v833)
  {
    v852 = v855;
    uint64_t v57 = v834;
  }
  else
  {
    unsigned int v323 = v835;
    BOOL v55 = malloc_type_malloc(8 * v835, 0x4065EBACuLL);
    if (!v55)
    {
      if (v323) {
        goto LABEL_1474;
      }
      BOOL v55 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v55) {
        goto LABEL_1474;
      }
    }
    v852 = v55;
    uint64_t v57 = v833;
    uint64_t v56 = v834;
  }
  int v58 = v836;
  LODWORD(v853) = v835;
  if (v56 == v57) {
    unsigned int v59 = v836;
  }
  else {
    unsigned int v59 = v835;
  }
  if (v59)
  {
    memmove(v55, v56, 8 * v59);
    int v58 = v836;
  }
  HIDWORD(v853) = v58;
  int v854 = v837;
  v857 = 0;
  long long v856 = 0uLL;
  sub_1CD31D500((char *)&v856, (uint64_t)v839, (uint64_t)v840, (v840 - (unsigned char *)v839) >> 5);
  sub_1CD364ECC((uint64_t)&v896, (uint64_t)&v881, (uint64_t)&v851);
  unint64_t v60 = v729;
  v724 = v729;
  unsigned int v61 = v834;
  if (v834 == v833)
  {
    uint64_t v725 = v729;
    unsigned int v62 = v834;
  }
  else
  {
    unsigned int v324 = v835;
    unint64_t v60 = malloc_type_malloc(8 * v835, 0x4065EBACuLL);
    if (!v60)
    {
      if (v324) {
        goto LABEL_1474;
      }
      unint64_t v60 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v60) {
        goto LABEL_1474;
      }
    }
    uint64_t v725 = v60;
    unsigned int v62 = v833;
    unsigned int v61 = v834;
  }
  unsigned int v63 = v836;
  unsigned int v726 = v835;
  if (v61 == v62) {
    unsigned int v64 = v836;
  }
  else {
    unsigned int v64 = v835;
  }
  if (v64)
  {
    memmove(v60, v61, 8 * v64);
    unsigned int v63 = v836;
  }
  unsigned int v727 = v63;
  int v728 = v837;
  v731 = 0;
  uint64_t v732 = 0;
  v730 = 0;
  sub_1CD31D500((char *)&v730, (uint64_t)v839, (uint64_t)v840, (v840 - (unsigned char *)v839) >> 5);
  uint64_t v65 = v847;
  v842 = v847;
  uint64_t v66 = v834;
  if (v834 == v833)
  {
    v843 = v847;
    uint64_t v67 = v834;
  }
  else
  {
    unsigned int v325 = v835;
    uint64_t v65 = malloc_type_malloc(8 * v835, 0x4065EBACuLL);
    if (!v65)
    {
      if (v325) {
        goto LABEL_1474;
      }
      uint64_t v65 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v65) {
        goto LABEL_1474;
      }
    }
    v843 = v65;
    uint64_t v67 = v833;
    uint64_t v66 = v834;
  }
  int v68 = v836;
  unsigned int v844 = v835;
  if (v66 == v67) {
    unsigned int v69 = v836;
  }
  else {
    unsigned int v69 = v835;
  }
  if (v69)
  {
    memmove(v65, v66, 8 * v69);
    int v68 = v836;
  }
  int v845 = v68;
  int v846 = v837;
  uint64_t v850 = 0;
  v848 = 0;
  v849 = 0;
  sub_1CD31D500((char *)&v848, (uint64_t)v839, (uint64_t)v840, (v840 - (unsigned char *)v839) >> 5);
  sub_1CD364ECC((uint64_t)&v866, (uint64_t)&v724, (uint64_t)&v842);
  v926 = v930;
  uint64_t v70 = v897;
  if (v897 == v896)
  {
    v927 = v930;
    unsigned int v717 = HIDWORD(v898);
    if (HIDWORD(v898)) {
      memmove(v930, v897, 8 * HIDWORD(v898));
    }
    else {
      unsigned int v717 = 0;
    }
    uint64_t v70 = v930;
  }
  else
  {
    v927 = v897;
    v897 = v896;
    unsigned int v717 = HIDWORD(v898);
  }
  unsigned int v681 = v898;
  unint64_t v928 = __PAIR64__(v717, v898);
  int v669 = v899;
  int v929 = v899;
  unint64_t v898 = 8;
  int v899 = 0;
  int v674 = (void *)*((void *)&v901 + 1);
  uint64_t v660 = v901;
  long long v931 = v901;
  unint64_t v71 = v902;
  v902 = 0;
  long long v901 = 0uLL;
  unsigned int v689 = v71;
  v932 = v71;
  v933 = v938;
  uint64_t v72 = v904;
  if (v904 == v903)
  {
    v934 = v938;
    unsigned int v709 = HIDWORD(v905);
    if (HIDWORD(v905))
    {
      uint64_t v73 = v70;
      memmove(v938, v904, 8 * HIDWORD(v905));
      uint64_t v70 = v73;
    }
    else
    {
      unsigned int v709 = 0;
    }
    uint64_t v72 = v938;
  }
  else
  {
    v934 = v904;
    v904 = v903;
    unsigned int v709 = HIDWORD(v905);
  }
  unsigned int v664 = v905;
  int v935 = v905;
  unsigned int v936 = v709;
  int v650 = v906;
  int v937 = v906;
  unint64_t v905 = 8;
  int v906 = 0;
  uint64_t v653 = (uint64_t)v909;
  unsigned int v656 = v908;
  v939 = v908;
  v940 = v909;
  unsigned int v646 = v910;
  v941 = v910;
  v910 = 0;
  v908 = 0;
  v909 = 0;
  v911 = v915;
  uint64_t v74 = v867;
  if (v867 == v866)
  {
    v912 = v915;
    unsigned int v75 = HIDWORD(v868);
    if (HIDWORD(v868))
    {
      __int16 v76 = v70;
      uint64_t v77 = v72;
      memmove(v915, v867, 8 * HIDWORD(v868));
      uint64_t v72 = v77;
      unsigned int v78 = v75;
      uint64_t v70 = v76;
    }
    else
    {
      unsigned int v78 = 0;
    }
    uint64_t v74 = v915;
  }
  else
  {
    v912 = v867;
    v867 = v866;
    unsigned int v78 = HIDWORD(v868);
  }
  unsigned int v79 = v868;
  int v80 = v869;
  unint64_t v913 = __PAIR64__(v78, v868);
  int v914 = v869;
  unint64_t v868 = 8;
  int v869 = 0;
  uint64_t v81 = *((void *)&v871 + 1);
  uint64_t v631 = (void *)v871;
  long long v916 = v871;
  int v82 = v872;
  uint64_t v83 = v873;
  v872 = 0;
  long long v871 = 0uLL;
  uint64_t v642 = v82;
  v917 = v82;
  v918 = v922;
  uint64_t v84 = v874;
  uint64_t v614 = *((void *)&v916 + 1);
  if (v874 == v873)
  {
    v919 = v922;
    unsigned int v85 = HIDWORD(v875);
    if (HIDWORD(v875))
    {
      int v86 = v80;
      unsigned int v87 = v873;
      unsigned int v88 = v70;
      int v89 = v72;
      memmove(v922, v874, 8 * HIDWORD(v875));
      uint64_t v72 = v89;
      uint64_t v70 = v88;
      uint64_t v83 = v87;
      int v80 = v86;
      uint64_t v81 = v614;
    }
    int v634 = v922;
    char v638 = v84;
  }
  else
  {
    int v634 = v874;
    char v638 = v873;
    v919 = v874;
    v874 = v873;
    unsigned int v85 = HIDWORD(v875);
  }
  unsigned int v90 = v875;
  unint64_t v920 = __PAIR64__(v85, v875);
  int v628 = v876;
  int v921 = v876;
  unint64_t v875 = 8;
  int v876 = 0;
  uint64_t v621 = v879;
  uint64_t v624 = v878;
  v923 = v878;
  uint64_t v924 = v879;
  uint64_t v618 = v880;
  v925 = v880;
  v880 = 0;
  v878 = 0;
  uint64_t v879 = 0;
  v789 = v794;
  if (v70 == v930)
  {
    v790 = v794;
    if (v717)
    {
      uint64_t v91 = v74;
      int v92 = v83;
      uint64_t v93 = v72;
      memcpy(v794, v930, 8 * v717);
      uint64_t v72 = v93;
      uint64_t v83 = v92;
      uint64_t v74 = v91;
      uint64_t v81 = v614;
    }
  }
  else
  {
    v790 = v70;
  }
  unsigned int v791 = v681;
  int v792 = v717;
  int v793 = v669;
  *(void *)&long long __p = v660;
  *((void *)&__p + 1) = v674;
  v796 = v689;
  v797 = v802;
  if (v72 == v938)
  {
    v798 = v802;
    if (v709) {
      memcpy(v802, v938, 8 * v709);
    }
  }
  else
  {
    v798 = v72;
  }
  unsigned int v799 = v664;
  int v800 = v709;
  int v801 = v650;
  v803 = v656;
  v804 = (unsigned char *)v653;
  v805 = v646;
  v806 = v811;
  if (v74 == v915)
  {
    v807 = v811;
    if (v78) {
      memcpy(v811, v915, 8 * v78);
    }
  }
  else
  {
    v807 = v74;
  }
  unsigned int v808 = v79;
  int v809 = v78;
  int v810 = v80;
  v812 = v631;
  v813 = (unsigned char *)v81;
  v814 = v642;
  v815 = v820;
  if (v634 == v922)
  {
    v816 = v820;
    if (v85) {
      memcpy(v820, v922, 8 * v85);
    }
  }
  else
  {
    v816 = v634;
  }
  unsigned int v817 = v90;
  int v818 = v85;
  int v819 = v628;
  v821 = v624;
  v822 = (unsigned char *)v621;
  v823 = v618;
  if (v638 != v83)
  {
    free(v638);
    unsigned int v94 = (char *)v871;
    if ((void)v871)
    {
      for (iuint64_t i = (char *)*((void *)&v871 + 1); ii != v94; ii -= 32)
      {
        if (*(ii - 8)) {
          *(ii - 8) = 0;
        }
      }
      *((void *)&v871 + 1) = v94;
      operator delete(v94);
    }
  }
  if (v867 != v866) {
    free(v867);
  }
  int v96 = (char *)v848;
  if (v848)
  {
    for (jint j = v849; jj != v96; jj -= 32)
    {
      if (*(jj - 8)) {
        *(jj - 8) = 0;
      }
    }
    v849 = v96;
    operator delete(v96);
  }
  if (v843 != v842) {
    free(v843);
  }
  int v98 = v730;
  if (v730)
  {
    for (uint64_t kk = (uint64_t)v731; (unsigned char *)kk != v98; kk -= 32)
    {
      if (*(unsigned char *)(kk - 8)) {
        *(unsigned char *)(kk - 8) = 0;
      }
    }
    v731 = v98;
    operator delete(v98);
  }
  if (v725 != v724) {
    free(v725);
  }
  uint64_t v100 = (char *)v908;
  if (v908)
  {
    for (mm = v909; mm != v100; mm -= 32)
    {
      if (*(mm - 8)) {
        *(mm - 8) = 0;
      }
    }
    v909 = v100;
    operator delete(v100);
  }
  if (v904 != v903) {
    free(v904);
  }
  int v102 = (char *)v901;
  if ((void)v901)
  {
    for (nn = (char *)*((void *)&v901 + 1); nn != v102; nn -= 32)
    {
      if (*(nn - 8)) {
        *(nn - 8) = 0;
      }
    }
    *((void *)&v901 + 1) = v102;
    operator delete(v102);
  }
  if (v897 != v896) {
    free(v897);
  }
  uint64_t v104 = (char *)v856;
  if ((void)v856)
  {
    for (i1 = (char *)*((void *)&v856 + 1); i1 != v104; i1 -= 32)
    {
      if (*(i1 - 8)) {
        *(i1 - 8) = 0;
      }
    }
    *((void *)&v856 + 1) = v104;
    operator delete(v104);
  }
  if (v852 != v851) {
    free(v852);
  }
  uint64_t v106 = (char *)v886;
  if ((void)v886)
  {
    for (i2 = (char *)*((void *)&v886 + 1); i2 != v106; i2 -= 32)
    {
      if (*(i2 - 8)) {
        *(i2 - 8) = 0;
      }
    }
    *((void *)&v886 + 1) = v106;
    operator delete(v106);
  }
  if (v882 != v881) {
    free(v882);
  }
  uint64_t v108 = v885;
  v881 = v885;
  uint64_t v109 = v790;
  if (v790 == v789)
  {
    v882 = v885;
    int v110 = v790;
  }
  else
  {
    unsigned int v326 = v791;
    uint64_t v108 = malloc_type_malloc(8 * v791, 0x4065EBACuLL);
    if (!v108)
    {
      if (v326) {
        goto LABEL_1474;
      }
      uint64_t v108 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v108) {
        goto LABEL_1474;
      }
    }
    v882 = v108;
    int v110 = v789;
    uint64_t v109 = v790;
  }
  int v111 = v792;
  LODWORD(v883) = v791;
  if (v109 == v110) {
    unsigned int v112 = v792;
  }
  else {
    unsigned int v112 = v791;
  }
  if (v112)
  {
    memmove(v108, v109, 8 * v112);
    int v111 = v792;
  }
  HIDWORD(v883) = v111;
  int v884 = v793;
  v887 = 0;
  long long v886 = 0uLL;
  sub_1CD31D500((char *)&v886, __p, *((uint64_t *)&__p + 1), (uint64_t)(*((void *)&__p + 1) - __p) >> 5);
  int v113 = v892;
  v888 = v892;
  unsigned int v114 = v798;
  if (v798 == v797)
  {
    v889 = v892;
    int v115 = v798;
  }
  else
  {
    unsigned int v327 = v799;
    int v113 = malloc_type_malloc(8 * v799, 0x4065EBACuLL);
    if (!v113)
    {
      if (v327) {
        goto LABEL_1474;
      }
      int v113 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v113) {
        goto LABEL_1474;
      }
    }
    v889 = v113;
    int v115 = v797;
    unsigned int v114 = v798;
  }
  int v116 = v800;
  LODWORD(v890) = v799;
  if (v114 == v115) {
    unsigned int v117 = v800;
  }
  else {
    unsigned int v117 = v799;
  }
  if (v117)
  {
    memmove(v113, v114, 8 * v117);
    int v116 = v800;
  }
  HIDWORD(v890) = v116;
  int v891 = v801;
  v895 = 0;
  v893 = 0;
  v894 = 0;
  sub_1CD31D500((char *)&v893, (uint64_t)v803, (uint64_t)v804, (v804 - (unsigned char *)v803) >> 5);
  v911 = v915;
  unsigned int v118 = v882;
  if (v882 == v881)
  {
    v912 = v915;
    unsigned int v119 = HIDWORD(v883);
    if (HIDWORD(v883)) {
      memmove(v915, v882, 8 * HIDWORD(v883));
    }
    unsigned int v118 = v915;
  }
  else
  {
    v912 = v882;
    v882 = v881;
    unsigned int v119 = HIDWORD(v883);
  }
  unsigned int v690 = v883;
  unint64_t v913 = __PAIR64__(v119, v883);
  int v682 = v884;
  int v914 = v884;
  uint64_t v883 = 8;
  int v884 = 0;
  uint64_t v718 = *((void *)&v886 + 1);
  uint64_t v675 = (void *)v886;
  long long v916 = v886;
  uint64_t v120 = v887;
  v887 = 0;
  long long v886 = 0uLL;
  v710 = v120;
  v917 = v120;
  v918 = v922;
  int64_t v121 = v889;
  if (v889 == v888)
  {
    v919 = v922;
    unsigned int v122 = HIDWORD(v890);
    if (HIDWORD(v890)) {
      memmove(v922, v889, 8 * HIDWORD(v890));
    }
    int64_t v121 = v922;
  }
  else
  {
    v919 = v889;
    v889 = v888;
    unsigned int v122 = HIDWORD(v890);
  }
  unsigned int v670 = v890;
  unint64_t v920 = __PAIR64__(v122, v890);
  int __dst = v891;
  int v921 = v891;
  uint64_t v890 = 8;
  int v891 = 0;
  signed int v123 = v894;
  long long v697 = v893;
  v923 = v893;
  uint64_t v924 = (uint64_t)v894;
  uint64_t v124 = v895;
  v894 = 0;
  v895 = 0;
  v893 = 0;
  v925 = v124;
  if (v118 == v915)
  {
    if (v119) {
      memcpy(v930, v915, 8 * v119);
    }
    unsigned int v118 = v930;
  }
  *(void *)&long long v931 = v675;
  *((void *)&v931 + 1) = v718;
  v932 = v710;
  v933 = v938;
  if (v121 == v922)
  {
    v934 = v938;
    if (v122) {
      memcpy(v938, v922, 8 * v122);
    }
    int64_t v121 = v938;
  }
  else
  {
    v934 = v121;
  }
  int v935 = v670;
  unsigned int v936 = v122;
  int v937 = __dst;
  v939 = v697;
  v940 = v123;
  v941 = v124;
  v896 = v900;
  if (v118 == v930)
  {
    v897 = v900;
    if (v119) {
      memcpy(v900, v930, 8 * v119);
    }
  }
  else
  {
    v897 = v118;
  }
  unint64_t v898 = __PAIR64__(v119, v690);
  int v899 = v682;
  *(void *)&long long v901 = v675;
  *((void *)&v901 + 1) = v718;
  v902 = v710;
  v903 = v907;
  if (v121 == v938)
  {
    v904 = v907;
    if (v122) {
      memcpy(v907, v938, 8 * v122);
    }
  }
  else
  {
    v904 = v121;
  }
  unint64_t v905 = __PAIR64__(v122, v670);
  int v906 = __dst;
  v908 = v697;
  v909 = v123;
  v910 = v124;
  uint64_t v125 = v855;
  v851 = v855;
  int v126 = v807;
  if (v807 == v806)
  {
    v852 = v855;
    uint64_t v127 = v807;
  }
  else
  {
    unsigned int v328 = v808;
    uint64_t v125 = malloc_type_malloc(8 * v808, 0x4065EBACuLL);
    if (!v125)
    {
      if (v328) {
        goto LABEL_1474;
      }
      uint64_t v125 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v125) {
        goto LABEL_1474;
      }
    }
    v852 = v125;
    uint64_t v127 = v806;
    int v126 = v807;
  }
  LODWORD(v853) = v808;
  int v128 = v809;
  if (v126 == v127) {
    unsigned int v129 = v809;
  }
  else {
    unsigned int v129 = v808;
  }
  if (v129)
  {
    memmove(v125, v126, 8 * v129);
    int v128 = v809;
  }
  HIDWORD(v853) = v128;
  int v854 = v810;
  v857 = 0;
  long long v856 = 0uLL;
  sub_1CD31D500((char *)&v856, (uint64_t)v812, (uint64_t)v813, (v813 - (unsigned char *)v812) >> 5);
  uint64_t v130 = v862;
  v858 = v862;
  uint64_t v131 = v816;
  if (v816 == v815)
  {
    v859 = v862;
    unsigned int v132 = v816;
  }
  else
  {
    unsigned int v329 = v817;
    uint64_t v130 = malloc_type_malloc(8 * v817, 0x4065EBACuLL);
    if (!v130)
    {
      if (v329) {
        goto LABEL_1474;
      }
      uint64_t v130 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v130) {
        goto LABEL_1474;
      }
    }
    v859 = v130;
    unsigned int v132 = v815;
    uint64_t v131 = v816;
  }
  LODWORD(v860) = v817;
  int v133 = v818;
  if (v131 == v132) {
    unsigned int v134 = v818;
  }
  else {
    unsigned int v134 = v817;
  }
  if (v134)
  {
    memmove(v130, v131, 8 * v134);
    int v133 = v818;
  }
  HIDWORD(v860) = v133;
  int v861 = v819;
  v865 = 0;
  v863 = 0;
  v864 = 0;
  sub_1CD31D500((char *)&v863, (uint64_t)v821, (uint64_t)v822, (v822 - (unsigned char *)v821) >> 5);
  v911 = v915;
  int v135 = v852;
  if (v852 == v851)
  {
    v912 = v915;
    unsigned int v136 = HIDWORD(v853);
    if (HIDWORD(v853)) {
      memmove(v915, v852, 8 * HIDWORD(v853));
    }
    int v135 = v915;
  }
  else
  {
    v912 = v852;
    v852 = v851;
    unsigned int v136 = HIDWORD(v853);
  }
  unsigned int v137 = v853;
  int v138 = v854;
  unint64_t v913 = __PAIR64__(v136, v853);
  int v914 = v854;
  uint64_t v853 = 8;
  int v854 = 0;
  uint64_t v139 = (void *)v856;
  long long v916 = v856;
  uint64_t v719 = *((void *)&v856 + 1);
  BOOL v140 = v857;
  v857 = 0;
  long long v856 = 0uLL;
  v711 = v140;
  v917 = v140;
  v918 = v922;
  unsigned int v141 = v859;
  uint64_t v647 = v858;
  if (v859 == v858)
  {
    v919 = v922;
    unsigned int v142 = HIDWORD(v860);
    if (HIDWORD(v860))
    {
      int v143 = v135;
      unsigned int v144 = v137;
      int v145 = v859;
      memmove(v922, v859, 8 * HIDWORD(v860));
      int v135 = v143;
      uint64_t v643 = v145;
      unsigned int v137 = v144;
    }
    else
    {
      uint64_t v643 = v859;
    }
    unsigned int v141 = v922;
  }
  else
  {
    v919 = v859;
    v859 = v858;
    uint64_t v643 = v858;
    unsigned int v142 = HIDWORD(v860);
  }
  unsigned int __dsta = v860;
  unint64_t v920 = __PAIR64__(v142, v860);
  int v698 = v861;
  int v921 = v861;
  uint64_t v860 = 8;
  int v861 = 0;
  uint64_t v683 = (uint64_t)v864;
  uint64_t v691 = v863;
  v923 = v863;
  uint64_t v924 = (uint64_t)v864;
  int64_t v146 = v865;
  v864 = 0;
  v865 = 0;
  v863 = 0;
  int v676 = v146;
  v925 = v146;
  if (v135 == v915)
  {
    if (v136)
    {
      uint64_t v147 = v141;
      memcpy(v930, v915, 8 * v136);
      unsigned int v141 = v147;
    }
    int v135 = v930;
  }
  *(void *)&long long v931 = v139;
  *((void *)&v931 + 1) = v719;
  v932 = v711;
  v933 = v938;
  if (v141 == v922)
  {
    v934 = v938;
    if (v142)
    {
      uint64_t v148 = v135;
      memcpy(v938, v922, 8 * v142);
      int v135 = v148;
    }
    unsigned int v141 = v938;
  }
  else
  {
    v934 = v141;
  }
  int v935 = __dsta;
  unsigned int v936 = v142;
  int v937 = v698;
  v939 = v691;
  v940 = (char *)v683;
  v941 = v676;
  v866 = v870;
  if (v135 == v930)
  {
    v867 = v870;
    int v135 = v870;
    if (v136)
    {
      uint64_t v149 = v141;
      memcpy(v870, v930, 8 * v136);
      unsigned int v141 = v149;
      int v135 = v870;
    }
  }
  else
  {
    v867 = v135;
  }
  unint64_t v868 = __PAIR64__(v136, v137);
  int v869 = v138;
  *(void *)&long long v871 = v139;
  *((void *)&v871 + 1) = v719;
  v872 = v711;
  v873 = v877;
  uint64_t v654 = v139;
  if (v141 == v938)
  {
    v874 = v877;
    unsigned int v141 = v877;
    if (v142)
    {
      unsigned int v150 = v135;
      memcpy(v877, v938, 8 * v142);
      int v135 = v150;
      unsigned int v141 = v877;
    }
  }
  else
  {
    v874 = v141;
  }
  unint64_t v875 = __PAIR64__(v142, __dsta);
  int v876 = v698;
  v878 = v691;
  uint64_t v879 = v683;
  v880 = v676;
  v926 = v930;
  unsigned int v151 = v897;
  int v657 = v138;
  if (v897 == v896)
  {
    v927 = v930;
    unsigned int v152 = HIDWORD(v898);
    if (HIDWORD(v898))
    {
      int64_t v153 = v135;
      BOOL v154 = v141;
      memmove(v930, v897, 8 * HIDWORD(v898));
      unsigned int v141 = v154;
      int v135 = v153;
    }
    unsigned int v151 = v930;
  }
  else
  {
    v927 = v897;
    v897 = v896;
    unsigned int v152 = HIDWORD(v898);
  }
  unsigned int v155 = v898;
  int v156 = v899;
  unint64_t v928 = __PAIR64__(v152, v898);
  int v929 = v899;
  unint64_t v898 = 8;
  int v899 = 0;
  long long v157 = v901;
  long long v931 = v901;
  unsigned int v158 = v902;
  v902 = 0;
  long long v901 = 0uLL;
  v932 = v158;
  v933 = v938;
  int v159 = v904;
  unsigned int v639 = v155;
  int v635 = v156;
  uint64_t v625 = v158;
  if (v904 == v903)
  {
    v934 = v938;
    unsigned int v160 = HIDWORD(v905);
    if (HIDWORD(v905))
    {
      int v161 = v135;
      unsigned int v162 = v137;
      uint64_t v163 = v141;
      uint64_t v164 = v151;
      unsigned int v165 = HIDWORD(v905);
      memmove(v938, v904, 8 * HIDWORD(v905));
      unsigned int v160 = v165;
      unsigned int v151 = v164;
      unsigned int v141 = v163;
      unsigned int v137 = v162;
      int v135 = v161;
    }
    int v159 = v938;
  }
  else
  {
    v934 = v904;
    v904 = v903;
    unsigned int v160 = HIDWORD(v905);
  }
  unsigned int v622 = v905;
  int v935 = v905;
  unsigned int v651 = v160;
  unsigned int v936 = v160;
  int v619 = v906;
  int v937 = v906;
  unint64_t v905 = 8;
  int v906 = 0;
  uint64_t v610 = (uint64_t)v909;
  uint64_t v612 = v908;
  v939 = v908;
  v940 = v909;
  int v615 = v910;
  v941 = v910;
  v909 = 0;
  v910 = 0;
  v908 = 0;
  v911 = v915;
  unsigned int v661 = v137;
  if (v135 == v870)
  {
    v912 = v915;
    if (v136)
    {
      unint64_t v166 = v141;
      unint64_t v167 = v151;
      unsigned int v168 = v152;
      uint64_t v169 = v159;
      memcpy(v915, v870, 8 * v136);
      int v159 = v169;
      unsigned int v152 = v168;
      unsigned int v151 = v167;
      unsigned int v141 = v166;
    }
    int v135 = v915;
  }
  else
  {
    v912 = v135;
    v867 = v870;
  }
  unint64_t v913 = __PAIR64__(v136, v661);
  unsigned int v665 = v136;
  int v914 = v657;
  unint64_t v868 = 8;
  int v869 = 0;
  *(void *)&long long v916 = v654;
  *((void *)&v916 + 1) = v719;
  v872 = 0;
  long long v871 = 0uLL;
  v917 = v711;
  v918 = v922;
  if (v141 == v877)
  {
    v919 = v922;
    if (v142)
    {
      uint64_t v170 = v135;
      BOOL v171 = v151;
      BOOL v172 = v159;
      memcpy(v922, v877, 8 * v142);
      int v159 = v172;
      unsigned int v151 = v171;
      int v135 = v170;
    }
    unsigned int v141 = v922;
  }
  else
  {
    v919 = v141;
    v874 = v877;
  }
  unint64_t v920 = __PAIR64__(v142, __dsta);
  int v921 = v698;
  unint64_t v875 = 8;
  int v876 = 0;
  v923 = v691;
  uint64_t v924 = v683;
  v925 = v676;
  uint64_t v879 = 0;
  v880 = 0;
  v878 = 0;
  v740 = v745;
  if (v151 == v930)
  {
    v741 = v745;
    unsigned int v173 = v665;
    unsigned int v174 = v661;
    if (v152)
    {
      uint64_t v175 = v135;
      unsigned int v176 = v141;
      int v177 = v159;
      memcpy(v745, v930, 8 * v152);
      int v159 = v177;
      unsigned int v141 = v176;
      int v135 = v175;
    }
  }
  else
  {
    v741 = v151;
    unsigned int v173 = v665;
    unsigned int v174 = v661;
  }
  unsigned int v742 = v639;
  int v743 = v152;
  int v744 = v635;
  long long v746 = v157;
  v747 = v625;
  v748 = v753;
  if (v159 == v938)
  {
    v749 = v753;
    uint64_t v179 = v647;
    unsigned int v178 = v651;
    unsigned int v180 = v622;
    if (v651)
    {
      uint64_t v181 = v135;
      uint64_t v182 = v141;
      memcpy(v753, v938, 8 * v651);
      unsigned int v178 = v651;
      unsigned int v141 = v182;
      int v135 = v181;
    }
  }
  else
  {
    v749 = v159;
    uint64_t v179 = v647;
    unsigned int v178 = v651;
    unsigned int v180 = v622;
  }
  unsigned int v750 = v180;
  int v751 = v178;
  int v752 = v619;
  v754 = v612;
  v755 = (unsigned char *)v610;
  v756 = v615;
  v757 = v762;
  if (v135 == v915)
  {
    v758 = v762;
    int v183 = v657;
    uint64_t v184 = v654;
    if (v173)
    {
      unint64_t v185 = v141;
      memcpy(v762, v915, 8 * v173);
      unsigned int v141 = v185;
    }
  }
  else
  {
    v758 = v135;
    int v183 = v657;
    uint64_t v184 = v654;
  }
  unsigned int v759 = v174;
  int v760 = v173;
  int v761 = v183;
  v763 = v184;
  v764 = (unsigned char *)v719;
  v765 = v711;
  v766 = v771;
  if (v141 == v922)
  {
    v767 = v771;
    int v186 = v643;
    if (v142) {
      memcpy(v771, v922, 8 * v142);
    }
  }
  else
  {
    v767 = v141;
    int v186 = v643;
  }
  unsigned int v768 = __dsta;
  unsigned int v769 = v142;
  int v770 = v698;
  v772 = v691;
  v773 = (unsigned char *)v683;
  v774 = v676;
  if (v186 != v179)
  {
    free(v186);
    uint64_t v187 = (char *)v856;
    if ((void)v856)
    {
      for (i3 = (char *)*((void *)&v856 + 1); i3 != v187; i3 -= 32)
      {
        if (*(i3 - 8)) {
          *(i3 - 8) = 0;
        }
      }
      *((void *)&v856 + 1) = v187;
      operator delete(v187);
    }
  }
  if (v852 != v851) {
    free(v852);
  }
  uint64_t v189 = (char *)v908;
  if (v908)
  {
    for (i4 = v909; i4 != v189; i4 -= 32)
    {
      if (*(i4 - 8)) {
        *(i4 - 8) = 0;
      }
    }
    v909 = v189;
    operator delete(v189);
  }
  if (v904 != v903) {
    free(v904);
  }
  int v191 = (char *)v901;
  if ((void)v901)
  {
    for (i5 = (char *)*((void *)&v901 + 1); i5 != v191; i5 -= 32)
    {
      if (*(i5 - 8)) {
        *(i5 - 8) = 0;
      }
    }
    *((void *)&v901 + 1) = v191;
    operator delete(v191);
  }
  if (v897 != v896) {
    free(v897);
  }
  uint64_t v193 = (char *)v893;
  if (v893)
  {
    for (i6 = v894; i6 != v193; i6 -= 32)
    {
      if (*(i6 - 8)) {
        *(i6 - 8) = 0;
      }
    }
    v894 = v193;
    operator delete(v193);
  }
  if (v889 != v888) {
    free(v889);
  }
  int v195 = (char *)v886;
  if ((void)v886)
  {
    for (i7 = (char *)*((void *)&v886 + 1); i7 != v195; i7 -= 32)
    {
      if (*(i7 - 8)) {
        *(i7 - 8) = 0;
      }
    }
    *((void *)&v886 + 1) = v195;
    operator delete(v195);
  }
  if (v882 != v881) {
    free(v882);
  }
  uint64_t v197 = v821;
  if (v821)
  {
    for (uint64_t i8 = (uint64_t)v822; (unsigned char *)i8 != v197; i8 -= 32)
    {
      if (*(unsigned char *)(i8 - 8)) {
        *(unsigned char *)(i8 - 8) = 0;
      }
    }
    v822 = v197;
    operator delete(v197);
  }
  if (v816 != v815) {
    free(v816);
  }
  uint64_t v199 = v812;
  if (v812)
  {
    for (uint64_t i9 = (uint64_t)v813; (unsigned char *)i9 != v199; i9 -= 32)
    {
      if (*(unsigned char *)(i9 - 8)) {
        *(unsigned char *)(i9 - 8) = 0;
      }
    }
    v813 = v199;
    operator delete(v199);
  }
  if (v807 != v806) {
    free(v807);
  }
  int v201 = v803;
  if (v803)
  {
    for (uint64_t i10 = (uint64_t)v804; (unsigned char *)i10 != v201; i10 -= 32)
    {
      if (*(unsigned char *)(i10 - 8)) {
        *(unsigned char *)(i10 - 8) = 0;
      }
    }
    v804 = v201;
    operator delete(v201);
  }
  if (v798 != v797) {
    free(v798);
  }
  unsigned int v203 = (char *)__p;
  if ((void)__p)
  {
    for (i11 = (char *)*((void *)&__p + 1); i11 != v203; i11 -= 32)
    {
      if (*(i11 - 8)) {
        *(i11 - 8) = 0;
      }
    }
    *((void *)&__p + 1) = v203;
    operator delete(v203);
  }
  if (v790 != v789) {
    free(v790);
  }
  int v205 = v839;
  if (v839)
  {
    for (uint64_t i12 = (uint64_t)v840; (unsigned char *)i12 != v205; i12 -= 32)
    {
      if (*(unsigned char *)(i12 - 8)) {
        *(unsigned char *)(i12 - 8) = 0;
      }
    }
    v840 = v205;
    operator delete(v205);
  }
  if (v834 != v833) {
    free(v834);
  }
  uint64_t v207 = v830;
  if (v830)
  {
    for (uint64_t i13 = (uint64_t)v831; (unsigned char *)i13 != v207; i13 -= 32)
    {
      if (*(unsigned char *)(i13 - 8)) {
        *(unsigned char *)(i13 - 8) = 0;
      }
    }
    v831 = v207;
    operator delete(v207);
  }
  if (v825 != v824) {
    free(v825);
  }
  uint64_t v209 = v794;
  v789 = v794;
  int v210 = v741;
  if (v741 == v740)
  {
    v790 = v794;
    int v211 = v741;
  }
  else
  {
    unsigned int v330 = v742;
    uint64_t v209 = malloc_type_malloc(8 * v742, 0x4065EBACuLL);
    if (!v209)
    {
      if (v330) {
        goto LABEL_1474;
      }
      uint64_t v209 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v209) {
        goto LABEL_1474;
      }
    }
    v790 = v209;
    int v211 = v740;
    int v210 = v741;
  }
  int v212 = v743;
  unsigned int v791 = v742;
  if (v210 == v211) {
    unsigned int v213 = v743;
  }
  else {
    unsigned int v213 = v742;
  }
  if (v213)
  {
    memmove(v209, v210, 8 * v213);
    int v212 = v743;
  }
  int v792 = v212;
  int v793 = v744;
  v796 = 0;
  long long __p = 0uLL;
  sub_1CD31D500((char *)&__p, v746, *((uint64_t *)&v746 + 1), (uint64_t)(*((void *)&v746 + 1) - v746) >> 5);
  uint64_t v214 = v802;
  v797 = v802;
  int64_t v215 = v749;
  if (v749 == v748)
  {
    v798 = v802;
    uint64_t v216 = v749;
  }
  else
  {
    unsigned int v331 = v750;
    uint64_t v214 = malloc_type_malloc(8 * v750, 0x4065EBACuLL);
    if (!v214)
    {
      if (v331) {
        goto LABEL_1474;
      }
      uint64_t v214 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v214) {
        goto LABEL_1474;
      }
    }
    v798 = v214;
    uint64_t v216 = v748;
    int64_t v215 = v749;
  }
  int v217 = v751;
  unsigned int v799 = v750;
  if (v215 == v216) {
    unsigned int v218 = v751;
  }
  else {
    unsigned int v218 = v750;
  }
  if (v218)
  {
    memmove(v214, v215, 8 * v218);
    int v217 = v751;
  }
  int v800 = v217;
  int v801 = v752;
  v805 = 0;
  v803 = 0;
  v804 = 0;
  sub_1CD31D500((char *)&v803, (uint64_t)v754, (uint64_t)v755, (v755 - (unsigned char *)v754) >> 5);
  uint64_t v219 = v930;
  v926 = v930;
  BOOL v220 = v758;
  if (v758 == v757)
  {
    v927 = v930;
    int v221 = v758;
  }
  else
  {
    unsigned int v332 = v759;
    uint64_t v219 = malloc_type_malloc(8 * v759, 0x4065EBACuLL);
    if (!v219)
    {
      if (v332) {
        goto LABEL_1474;
      }
      uint64_t v219 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v219) {
        goto LABEL_1474;
      }
    }
    v927 = v219;
    int v221 = v757;
    BOOL v220 = v758;
  }
  LODWORD(v928) = v759;
  int v222 = v760;
  if (v220 == v221) {
    unsigned int v223 = v760;
  }
  else {
    unsigned int v223 = v759;
  }
  if (v223)
  {
    memmove(v219, v220, 8 * v223);
    int v222 = v760;
  }
  HIDWORD(v928) = v222;
  int v929 = v761;
  v932 = 0;
  long long v931 = 0uLL;
  sub_1CD31D500((char *)&v931, (uint64_t)v763, (uint64_t)v764, (v764 - (unsigned char *)v763) >> 5);
  BOOL v224 = v938;
  v933 = v938;
  long long v225 = v767;
  if (v767 == v766)
  {
    v934 = v938;
    int64_t v226 = v767;
  }
  else
  {
    unsigned int v333 = v768;
    BOOL v224 = malloc_type_malloc(8 * v768, 0x4065EBACuLL);
    if (!v224)
    {
      if (v333) {
        goto LABEL_1474;
      }
      BOOL v224 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v224) {
        goto LABEL_1474;
      }
    }
    v934 = v224;
    int64_t v226 = v766;
    long long v225 = v767;
  }
  int v935 = v768;
  unsigned int v227 = v769;
  if (v225 == v226) {
    unsigned int v228 = v769;
  }
  else {
    unsigned int v228 = v768;
  }
  if (v228)
  {
    memmove(v224, v225, 8 * v228);
    unsigned int v227 = v769;
  }
  unsigned int v936 = v227;
  int v937 = v770;
  v941 = 0;
  v939 = 0;
  v940 = 0;
  BOOL v229 = sub_1CD31D500((char *)&v939, (uint64_t)v772, (uint64_t)v773, (v773 - (unsigned char *)v772) >> 5);
  uint64_t v230 = *((void *)&__p + 1);
  uint64_t v231 = __p;
  while (1)
  {
LABEL_436:
    if (v230 - v231 == *((void *)&v931 + 1) - (void)v931)
    {
      if (v231 != v230)
      {
        uint64_t v232 = v931 + 16;
        uint64_t v233 = v231 + 16;
        do
        {
          uint64_t v234 = v233 - 16;
          if (*(void *)(v233 - 16) != *(void *)(v232 - 16)) {
            goto LABEL_454;
          }
          int v235 = *(unsigned __int8 *)(v232 + 8);
          if (*(unsigned char *)(v233 + 8)) {
            BOOL v236 = v235 == 0;
          }
          else {
            BOOL v236 = 1;
          }
          if (v236)
          {
            if ((*(unsigned char *)(v233 + 8) == 0) == (v235 != 0)) {
              goto LABEL_454;
            }
          }
          else if (*(void *)(v233 - 8) != *(void *)(v232 - 8) || *(void *)v233 != *(void *)v232)
          {
            goto LABEL_454;
          }
          v232 += 32;
          v233 += 32;
        }
        while (v234 + 32 != v230);
      }
      uint64_t v249 = (char *)v939;
      if (v939)
      {
        for (i14 = v940; i14 != v249; i14 -= 32)
        {
          if (*(i14 - 8)) {
            *(i14 - 8) = 0;
          }
        }
        v940 = v249;
        operator delete(v249);
      }
      if (v934 != v933) {
        free(v934);
      }
      uint64_t v251 = (char *)v931;
      if ((void)v931)
      {
        for (i15 = (char *)*((void *)&v931 + 1); i15 != v251; i15 -= 32)
        {
          if (*(i15 - 8)) {
            *(i15 - 8) = 0;
          }
        }
        *((void *)&v931 + 1) = v251;
        operator delete(v251);
      }
      if (v927 != v926) {
        free(v927);
      }
      uint64_t v253 = v803;
      if (v803)
      {
        for (uint64_t i16 = (uint64_t)v804; (unsigned char *)i16 != v253; i16 -= 32)
        {
          if (*(unsigned char *)(i16 - 8)) {
            *(unsigned char *)(i16 - 8) = 0;
          }
        }
        v804 = v253;
        operator delete(v253);
      }
      if (v798 != v797) {
        free(v798);
      }
      unsigned int v255 = (char *)__p;
      if ((void)__p)
      {
        for (i17 = (char *)*((void *)&__p + 1); i17 != v255; i17 -= 32)
        {
          if (*(i17 - 8)) {
            *(i17 - 8) = 0;
          }
        }
        *((void *)&__p + 1) = v255;
        operator delete(v255);
      }
      if (v790 != v789) {
        free(v790);
      }
      int v257 = v772;
      if (v772)
      {
        for (uint64_t i18 = (uint64_t)v773; (unsigned char *)i18 != v257; i18 -= 32)
        {
          if (*(unsigned char *)(i18 - 8)) {
            *(unsigned char *)(i18 - 8) = 0;
          }
        }
        v773 = v257;
        operator delete(v257);
      }
      if (v767 != v766) {
        free(v767);
      }
      uint64_t v259 = v763;
      if (v763)
      {
        for (uint64_t i19 = (uint64_t)v764; (unsigned char *)i19 != v259; i19 -= 32)
        {
          if (*(unsigned char *)(i19 - 8)) {
            *(unsigned char *)(i19 - 8) = 0;
          }
        }
        v764 = v259;
        operator delete(v259);
      }
      if (v758 != v757) {
        free(v758);
      }
      uint64_t v261 = v754;
      if (v754)
      {
        for (uint64_t i20 = (uint64_t)v755; (unsigned char *)i20 != v261; i20 -= 32)
        {
          if (*(unsigned char *)(i20 - 8)) {
            *(unsigned char *)(i20 - 8) = 0;
          }
        }
        v755 = v261;
        operator delete(v261);
      }
      if (v749 != v748) {
        free(v749);
      }
      BOOL v263 = (char *)v746;
      if ((void)v746)
      {
        for (i21 = (char *)*((void *)&v746 + 1); i21 != v263; i21 -= 32)
        {
          if (*(i21 - 8)) {
            *(i21 - 8) = 0;
          }
        }
        *((void *)&v746 + 1) = v263;
        operator delete(v263);
      }
      uint64_t v265 = (llvm *)v741;
      if (v741 != v740) {
        free(v741);
      }
      uint64_t v266 = *(void *)this;
      if (!*(void *)this || (uint64_t v267 = *(void *)this, *(unsigned char *)(v266 + 8) != 1))
      {
        if (*(_DWORD *)(v266 + 80) == 1) {
          uint64_t v267 = **(void **)(v266 + 72);
        }
        else {
          uint64_t v267 = 0;
        }
      }
      uint64_t v292 = *(void *)(v267 + 200);
      if (v292) {
        BOOL v293 = *(unsigned char *)(v292 + 8) == 0;
      }
      else {
        BOOL v293 = 0;
      }
      if (!v293)
      {
        int v294 = (llvm::raw_ostream *)llvm::errs(v265);
        uint64_t v295 = (void *)*((void *)v294 + 4);
        if (*((void *)v294 + 3) - (void)v295 <= 0x27uLL)
        {
          unsigned int v296 = "VPlan entry block is not a VPBasicBlock\n";
          size_t v297 = 40;
LABEL_716:
          llvm::raw_ostream::write(v294, v296, v297);
          goto LABEL_717;
        }
        uint64_t v314 = 0;
        qmemcpy(v295, "VPlan entry block is not a VPBasicBlock\n", 40);
        uint64_t v395 = *((void *)v294 + 4) + 40;
        goto LABEL_1327;
      }
      uint64_t v298 = *(void *)(v292 + 208);
      if (v298) {
        uint64_t v299 = v298 - 24;
      }
      else {
        uint64_t v299 = 0;
      }
      if (*(unsigned char *)(v299 + 8) != 14)
      {
        int v294 = (llvm::raw_ostream *)llvm::errs(v265);
        uint64_t v310 = (void *)*((void *)v294 + 4);
        if (*((void *)v294 + 3) - (void)v310 <= 0x45uLL)
        {
          unsigned int v296 = "VPlan vector loop header does not start with a VPCanonicalIVPHIRecipe\n";
          size_t v297 = 70;
          goto LABEL_716;
        }
        uint64_t v314 = 0;
        qmemcpy(v310, "VPlan vector loop header does not start with a VPCanonicalIVPHIRecipe\n", 70);
        uint64_t v395 = *((void *)v294 + 4) + 70;
LABEL_1327:
        *((void *)v294 + 4) = v395;
        goto LABEL_718;
      }
      uint64_t v300 = *(void *)(v267 + 208);
      if (!v300 || *(unsigned char *)(v300 + 8))
      {
        int v294 = (llvm::raw_ostream *)llvm::errs(v265);
        int v311 = (void *)*((void *)v294 + 4);
        if (*((void *)v294 + 3) - (void)v311 <= 0x26uLL)
        {
          unsigned int v296 = "VPlan exit block is not a VPBasicBlock\n";
          size_t v297 = 39;
          goto LABEL_716;
        }
        uint64_t v314 = 0;
        qmemcpy(v311, "VPlan exit block is not a VPBasicBlock\n", 39);
        uint64_t v395 = *((void *)v294 + 4) + 39;
        goto LABEL_1327;
      }
      uint64_t v301 = *(void *)(v300 + 200);
      if (v301 == v300 + 200)
      {
        int v294 = (llvm::raw_ostream *)llvm::errs(v265);
        uint64_t v313 = (void *)*((void *)v294 + 4);
        if (*((void *)v294 + 3) - (void)v313 <= 0x4DuLL)
        {
          unsigned int v296 = "VPlan vector loop exit must end with BranchOnCount VPInstruction but is empty\n";
          size_t v297 = 78;
          goto LABEL_716;
        }
        uint64_t v314 = 0;
        qmemcpy(v313, "VPlan vector loop exit must end with BranchOnCount VPInstruction but is empty\n", 78);
        uint64_t v395 = *((void *)v294 + 4) + 78;
        goto LABEL_1327;
      }
      if (!v301 || *(unsigned char *)(v301 - 16) != 2 || *(unsigned char *)(v301 + 128) != 77)
      {
        int v294 = (llvm::raw_ostream *)llvm::errs(v265);
        uint64_t v312 = (void *)*((void *)v294 + 4);
        if (*((void *)v294 + 3) - (void)v312 <= 0x40uLL)
        {
          unsigned int v296 = "VPlan vector loop exit must end with BranchOnCount VPInstruction\n";
          size_t v297 = 65;
          goto LABEL_716;
        }
        uint64_t v314 = 0;
        qmemcpy(v312, "VPlan vector loop exit must end with BranchOnCount VPInstruction\n", 65);
        uint64_t v395 = *((void *)v294 + 4) + 65;
        goto LABEL_1327;
      }
      sub_1CD364BD4((uint64_t)&v724, (unsigned char *)v266);
      uint64_t v302 = v900;
      v896 = v900;
      uint64_t v303 = v725;
      if (v725 == v724)
      {
        v897 = v900;
        uint64_t v304 = v725;
      }
      else
      {
        unsigned int v594 = v726;
        uint64_t v302 = malloc_type_malloc(8 * v726, 0x4065EBACuLL);
        if (!v302)
        {
          if (v594) {
            goto LABEL_1474;
          }
          uint64_t v302 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
          if (!v302) {
            goto LABEL_1474;
          }
        }
        v897 = v302;
        uint64_t v304 = v724;
        uint64_t v303 = v725;
      }
      unsigned int v305 = v727;
      LODWORD(v898) = v726;
      if (v303 == v304) {
        unsigned int v306 = v727;
      }
      else {
        unsigned int v306 = v726;
      }
      if (v306)
      {
        memmove(v302, v303, 8 * v306);
        unsigned int v305 = v727;
      }
      HIDWORD(v898) = v305;
      int v899 = v728;
      v902 = 0;
      long long v901 = 0uLL;
      sub_1CD31D500((char *)&v901, (uint64_t)v730, (uint64_t)v731, (v731 - (unsigned char *)v730) >> 5);
      v740 = v745;
      if (v897 == v896)
      {
        v741 = v745;
        int v307 = HIDWORD(v898);
        if (HIDWORD(v898)) {
          memmove(v745, v897, 8 * HIDWORD(v898));
        }
      }
      else
      {
        v741 = v897;
        v897 = v896;
        int v307 = HIDWORD(v898);
      }
      unsigned int v742 = v898;
      int v743 = v307;
      int v744 = v899;
      unint64_t v898 = 8;
      int v899 = 0;
      long long v746 = v901;
      v747 = v902;
      v902 = 0;
      long long v901 = 0uLL;
      sub_1CD364DC8((uint64_t)&v926, (uint64_t)&v740);
      uint64_t v308 = (char *)v746;
      if ((void)v746)
      {
        for (i22 = (char *)*((void *)&v746 + 1); i22 != v308; i22 -= 32)
        {
          if (*(i22 - 8)) {
            *(i22 - 8) = 0;
          }
        }
        *((void *)&v746 + 1) = v308;
        operator delete(v308);
      }
      if (v741 != v740) {
        free(v741);
      }
      uint64_t v334 = v870;
      v866 = v870;
      int v335 = v734;
      if (v734 == v733)
      {
        v867 = v870;
        uint64_t v336 = v734;
      }
      else
      {
        unsigned int v595 = v735;
        uint64_t v334 = malloc_type_malloc(8 * v735, 0x4065EBACuLL);
        if (!v334)
        {
          if (v595) {
            goto LABEL_1474;
          }
          uint64_t v334 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
          if (!v334) {
            goto LABEL_1474;
          }
        }
        v867 = v334;
        uint64_t v336 = v733;
        int v335 = v734;
      }
      unsigned int v337 = v736;
      LODWORD(v868) = v735;
      if (v335 == v336) {
        unsigned int v338 = v736;
      }
      else {
        unsigned int v338 = v735;
      }
      if (v338)
      {
        memmove(v334, v335, 8 * v338);
        unsigned int v337 = v736;
      }
      HIDWORD(v868) = v337;
      int v869 = v737;
      v872 = 0;
      long long v871 = 0uLL;
      sub_1CD31D500((char *)&v871, (uint64_t)v738, (uint64_t)v739, (v739 - (unsigned char *)v738) >> 5);
      v740 = v745;
      if (v867 == v866)
      {
        v741 = v745;
        int v339 = HIDWORD(v868);
        if (HIDWORD(v868)) {
          memmove(v745, v867, 8 * HIDWORD(v868));
        }
      }
      else
      {
        v741 = v867;
        v867 = v866;
        int v339 = HIDWORD(v868);
      }
      unsigned int v742 = v868;
      int v743 = v339;
      int v744 = v869;
      unint64_t v868 = 8;
      int v869 = 0;
      long long v746 = v871;
      v747 = v872;
      v872 = 0;
      long long v871 = 0uLL;
      sub_1CD364DC8((uint64_t)&v911, (uint64_t)&v740);
      uint64_t v340 = (char *)v746;
      if ((void)v746)
      {
        for (i23 = (char *)*((void *)&v746 + 1); i23 != v340; i23 -= 32)
        {
          if (*(i23 - 8)) {
            *(i23 - 8) = 0;
          }
        }
        *((void *)&v746 + 1) = v340;
        operator delete(v340);
      }
      if (v741 != v740) {
        free(v741);
      }
      v740 = v745;
      BOOL v342 = v927;
      if (v927 == v926)
      {
        v741 = v745;
        unsigned int v343 = HIDWORD(v928);
        if (HIDWORD(v928)) {
          memmove(v745, v927, 8 * HIDWORD(v928));
        }
        BOOL v342 = v745;
      }
      else
      {
        v741 = v927;
        v927 = v926;
        unsigned int v343 = HIDWORD(v928);
      }
      unsigned int v344 = v928;
      int v345 = v929;
      unsigned int v742 = v928;
      int v743 = v343;
      int v744 = v929;
      unint64_t v928 = 8;
      int v929 = 0;
      uint64_t v346 = *((void *)&v931 + 1);
      uint64_t v712 = (void *)v931;
      long long v746 = v931;
      int v347 = v932;
      v747 = v932;
      v932 = 0;
      long long v931 = 0uLL;
      v789 = v794;
      int v348 = v912;
      __int16 v349 = v911;
      v720 = v911;
      if (v912 == v911)
      {
        v790 = v794;
        unsigned int v350 = HIDWORD(v913);
        if (HIDWORD(v913))
        {
          uint64_t v351 = v342;
          unsigned int v352 = v344;
          int v353 = v345;
          uint64_t v354 = v347;
          uint64_t v355 = v346;
          memmove(v794, v912, 8 * HIDWORD(v913));
          BOOL v342 = v351;
          uint64_t v346 = v355;
          int v347 = v354;
          int v345 = v353;
          unsigned int v344 = v352;
        }
        __int16 v349 = v348;
        int v348 = v794;
      }
      else
      {
        v912 = v911;
        unsigned int v350 = HIDWORD(v913);
      }
      unsigned int v356 = v913;
      int v357 = v914;
      unint64_t v913 = 8;
      int v914 = 0;
      uint64_t v359 = *((void *)&v916 + 1);
      uint64_t v358 = (void *)v916;
      long long __p = v916;
      int v360 = v917;
      v796 = v917;
      v917 = 0;
      long long v916 = 0uLL;
      v824 = v829;
      if (v342 == v745)
      {
        v825 = v829;
        if (v343)
        {
          unsigned int v361 = v344;
          int __dste = v357;
          int v362 = v345;
          uint64_t v692 = v359;
          v699 = v358;
          uint64_t v363 = v347;
          unsigned int v684 = v356;
          uint64_t v364 = v349;
          uint64_t v365 = v346;
          uint64_t v366 = v360;
          memcpy(v829, v745, 8 * v343);
          int v360 = v366;
          uint64_t v346 = v365;
          __int16 v349 = v364;
          unsigned int v356 = v684;
          int v347 = v363;
          uint64_t v359 = v692;
          uint64_t v358 = v699;
          int v345 = v362;
          int v357 = __dste;
          unsigned int v344 = v361;
        }
      }
      else
      {
        v825 = v342;
      }
      unsigned int v826 = v344;
      int v827 = v343;
      int v828 = v345;
      v830 = v712;
      v831 = (unsigned char *)v346;
      v832 = v347;
      v833 = v838;
      if (v348 == v794)
      {
        v834 = v838;
        if (v350)
        {
          uint64_t v367 = v360;
          memcpy(v838, v794, 8 * v350);
          int v360 = v367;
        }
      }
      else
      {
        v834 = v348;
      }
      unsigned int v835 = v356;
      int v836 = v350;
      int v837 = v357;
      v839 = v358;
      v840 = (unsigned char *)v359;
      v841 = v360;
      if (v349 != v720) {
        free(v349);
      }
      int v368 = (char *)v871;
      if ((void)v871)
      {
        for (i24 = (char *)*((void *)&v871 + 1); i24 != v368; i24 -= 32)
        {
          if (*(i24 - 8)) {
            *(i24 - 8) = 0;
          }
        }
        *((void *)&v871 + 1) = v368;
        operator delete(v368);
      }
      if (v867 != v866) {
        free(v867);
      }
      uint64_t v370 = (char *)v931;
      if ((void)v931)
      {
        for (i25 = (char *)*((void *)&v931 + 1); i25 != v370; i25 -= 32)
        {
          if (*(i25 - 8)) {
            *(i25 - 8) = 0;
          }
        }
        *((void *)&v931 + 1) = v370;
        operator delete(v370);
      }
      if (v927 != v926) {
        free(v927);
      }
      uint64_t v372 = (char *)v901;
      if ((void)v901)
      {
        for (i26 = (char *)*((void *)&v901 + 1); i26 != v372; i26 -= 32)
        {
          if (*(i26 - 8)) {
            *(i26 - 8) = 0;
          }
        }
        *((void *)&v901 + 1) = v372;
        operator delete(v372);
      }
      if (v897 != v896) {
        free(v897);
      }
      uint64_t v374 = v870;
      v866 = v870;
      int v375 = v825;
      if (v825 == v824)
      {
        v867 = v870;
        int v376 = v825;
      }
      else
      {
        unsigned int v596 = v826;
        uint64_t v374 = malloc_type_malloc(8 * v826, 0x4065EBACuLL);
        if (!v374)
        {
          if (v596) {
            goto LABEL_1474;
          }
          uint64_t v374 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
          if (!v374) {
            goto LABEL_1474;
          }
        }
        v867 = v374;
        int v376 = v824;
        int v375 = v825;
      }
      int v377 = v827;
      LODWORD(v868) = v826;
      if (v375 == v376) {
        unsigned int v378 = v827;
      }
      else {
        unsigned int v378 = v826;
      }
      if (v378)
      {
        memmove(v374, v375, 8 * v378);
        int v377 = v827;
      }
      HIDWORD(v868) = v377;
      int v869 = v828;
      v872 = 0;
      long long v871 = 0uLL;
      sub_1CD31D500((char *)&v871, (uint64_t)v830, (uint64_t)v831, (v831 - (unsigned char *)v830) >> 5);
      uint64_t v379 = v885;
      v881 = v885;
      uint64_t v380 = v834;
      if (v834 == v833)
      {
        v882 = v885;
        uint64_t v381 = v834;
      }
      else
      {
        unsigned int v597 = v835;
        uint64_t v379 = malloc_type_malloc(8 * v835, 0x4065EBACuLL);
        if (!v379)
        {
          if (v597) {
            goto LABEL_1474;
          }
          uint64_t v379 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
          if (!v379) {
            goto LABEL_1474;
          }
        }
        v882 = v379;
        uint64_t v381 = v833;
        uint64_t v380 = v834;
      }
      int v382 = v836;
      LODWORD(v883) = v835;
      if (v380 == v381) {
        unsigned int v383 = v836;
      }
      else {
        unsigned int v383 = v835;
      }
      if (v383)
      {
        memmove(v379, v380, 8 * v383);
        int v382 = v836;
      }
      HIDWORD(v883) = v382;
      int v884 = v837;
      v887 = 0;
      long long v886 = 0uLL;
      sub_1CD31D500((char *)&v886, (uint64_t)v839, (uint64_t)v840, (v840 - (unsigned char *)v839) >> 5);
      sub_1CD36563C((uint64_t)&v911, (uint64_t)&v866, (uint64_t)&v881);
      unint64_t v384 = v855;
      v851 = v855;
      int v385 = v834;
      if (v834 == v833)
      {
        v852 = v855;
        uint64_t v386 = v834;
      }
      else
      {
        unsigned int v598 = v835;
        unint64_t v384 = malloc_type_malloc(8 * v835, 0x4065EBACuLL);
        if (!v384)
        {
          if (v598) {
            goto LABEL_1474;
          }
          unint64_t v384 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
          if (!v384) {
            goto LABEL_1474;
          }
        }
        v852 = v384;
        uint64_t v386 = v833;
        int v385 = v834;
      }
      int v387 = v836;
      LODWORD(v853) = v835;
      if (v385 == v386) {
        unsigned int v388 = v836;
      }
      else {
        unsigned int v388 = v835;
      }
      if (v388)
      {
        memmove(v384, v385, 8 * v388);
        int v387 = v836;
      }
      HIDWORD(v853) = v387;
      int v854 = v837;
      v857 = 0;
      long long v856 = 0uLL;
      sub_1CD31D500((char *)&v856, (uint64_t)v839, (uint64_t)v840, (v840 - (unsigned char *)v839) >> 5);
      uint64_t v389 = v847;
      v842 = v847;
      uint64_t v390 = v834;
      if (v834 == v833)
      {
        v843 = v847;
        uint64_t v391 = v834;
      }
      else
      {
        unsigned int v599 = v835;
        uint64_t v389 = malloc_type_malloc(8 * v835, 0x4065EBACuLL);
        if (!v389)
        {
          if (v599) {
            goto LABEL_1474;
          }
          uint64_t v389 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
          if (!v389) {
            goto LABEL_1474;
          }
        }
        v843 = v389;
        uint64_t v391 = v833;
        uint64_t v390 = v834;
      }
      int v392 = v836;
      unsigned int v844 = v835;
      if (v390 == v391) {
        unsigned int v393 = v836;
      }
      else {
        unsigned int v393 = v835;
      }
      if (v393)
      {
        memmove(v389, v390, 8 * v393);
        int v392 = v836;
      }
      int v845 = v392;
      int v846 = v837;
      uint64_t v850 = 0;
      v848 = 0;
      v849 = 0;
      sub_1CD31D500((char *)&v848, (uint64_t)v839, (uint64_t)v840, (v840 - (unsigned char *)v839) >> 5);
      sub_1CD36563C((uint64_t)&v896, (uint64_t)&v851, (uint64_t)&v842);
      v740 = v745;
      BOOL v394 = v912;
      if (v912 == v911)
      {
        v741 = v745;
        unsigned int v721 = HIDWORD(v913);
        if (HIDWORD(v913)) {
          memmove(v745, v912, 8 * HIDWORD(v913));
        }
        else {
          unsigned int v721 = 0;
        }
        BOOL v394 = v745;
      }
      else
      {
        v741 = v912;
        v912 = v911;
        unsigned int v721 = HIDWORD(v913);
      }
      unsigned int v662 = v913;
      unsigned int v742 = v913;
      int v743 = v721;
      int v655 = v914;
      int v744 = v914;
      unint64_t v913 = 8;
      int v914 = 0;
      uint64_t v648 = v916;
      long long v746 = v916;
      uint64_t v658 = *((void *)&v916 + 1);
      uint64_t v396 = v917;
      v917 = 0;
      long long v916 = 0uLL;
      uint64_t v666 = v396;
      v747 = v396;
      v748 = v753;
      int v397 = v919;
      if (v919 == v918)
      {
        v749 = v753;
        unsigned int v713 = HIDWORD(v920);
        if (HIDWORD(v920))
        {
          int v398 = v394;
          memmove(v753, v919, 8 * HIDWORD(v920));
          BOOL v394 = v398;
        }
        else
        {
          unsigned int v713 = 0;
        }
        int v397 = v753;
      }
      else
      {
        v749 = v919;
        v919 = v918;
        unsigned int v713 = HIDWORD(v920);
      }
      unsigned int v652 = v920;
      unsigned int v750 = v920;
      int v751 = v713;
      int v636 = v921;
      int v752 = v921;
      unint64_t v920 = 8;
      int v921 = 0;
      v754 = v923;
      v755 = (unsigned char *)v924;
      uint64_t v632 = v925;
      v756 = v925;
      v925 = 0;
      v923 = 0;
      uint64_t v924 = 0;
      v926 = v930;
      uint64_t v399 = v897;
      int64_t v640 = v755;
      unsigned int v644 = v754;
      if (v897 == v896)
      {
        v927 = v930;
        unsigned int v400 = HIDWORD(v898);
        if (HIDWORD(v898))
        {
          int v401 = v394;
          int v402 = v397;
          memmove(v930, v897, 8 * HIDWORD(v898));
          int v397 = v402;
          unsigned int v403 = v400;
          BOOL v394 = v401;
        }
        else
        {
          unsigned int v403 = 0;
        }
        uint64_t v399 = v930;
      }
      else
      {
        v927 = v897;
        v897 = v896;
        unsigned int v403 = HIDWORD(v898);
      }
      int v404 = v899;
      unsigned int v620 = v898;
      unint64_t v928 = __PAIR64__(v403, v898);
      int v929 = v899;
      unint64_t v898 = 8;
      int v899 = 0;
      uint64_t v629 = *((void *)&v901 + 1);
      uint64_t v623 = (void *)v901;
      long long v931 = v901;
      uint64_t v405 = v902;
      v902 = 0;
      long long v901 = 0uLL;
      v932 = v405;
      v933 = v938;
      uint64_t v406 = v904;
      uint64_t v693 = v903;
      unsigned int v616 = v403;
      uint64_t v626 = v405;
      if (v904 == v903)
      {
        v934 = v938;
        unsigned int v407 = HIDWORD(v905);
        if (HIDWORD(v905))
        {
          uint64_t v408 = v394;
          uint64_t v409 = v397;
          int v410 = v904;
          memmove(v938, v904, 8 * HIDWORD(v905));
          int v397 = v409;
          BOOL v394 = v408;
          uint64_t v685 = v410;
        }
        else
        {
          uint64_t v685 = v904;
        }
        uint64_t v406 = v938;
      }
      else
      {
        v934 = v904;
        v904 = v903;
        uint64_t v685 = v903;
        unsigned int v407 = HIDWORD(v905);
      }
      unsigned int v411 = v905;
      int v412 = v906;
      int v935 = v905;
      unsigned int v936 = v407;
      int v937 = v906;
      unint64_t v905 = 8;
      int v906 = 0;
      int v413 = v908;
      v939 = v908;
      unsigned int v677 = v909;
      v940 = v909;
      uint64_t v671 = v910;
      v941 = v910;
      v910 = 0;
      v908 = 0;
      v909 = 0;
      v789 = v794;
      if (v394 == v745)
      {
        v790 = v794;
        if (v721)
        {
          int v414 = v404;
          uint64_t v415 = v399;
          int v416 = v412;
          unint64_t v417 = v397;
          uint64_t v418 = v413;
          unsigned int v419 = v411;
          int v420 = v406;
          memcpy(v794, v745, 8 * v721);
          uint64_t v406 = v420;
          unsigned int v411 = v419;
          int v413 = v418;
          int v397 = v417;
          int v412 = v416;
          uint64_t v399 = v415;
          int v404 = v414;
          unsigned int v403 = v616;
        }
      }
      else
      {
        v790 = v394;
      }
      unsigned int v791 = v662;
      int v792 = v721;
      int v793 = v655;
      *(void *)&long long __p = v648;
      *((void *)&__p + 1) = v658;
      v796 = v666;
      v797 = v802;
      if (v397 == v753)
      {
        v798 = v802;
        if (v713)
        {
          BOOL v421 = v413;
          int v422 = v412;
          unsigned int v423 = v411;
          uint64_t v424 = v406;
          memcpy(v802, v753, 8 * v713);
          uint64_t v406 = v424;
          unsigned int v411 = v423;
          int v412 = v422;
          int v413 = v421;
        }
      }
      else
      {
        v798 = v397;
      }
      unsigned int v799 = v652;
      int v800 = v713;
      int v801 = v636;
      v803 = v644;
      v804 = v640;
      v805 = v632;
      v806 = v811;
      if (v399 == v930)
      {
        v807 = v811;
        if (v403)
        {
          unsigned int v425 = v406;
          memcpy(v811, v930, 8 * v403);
          uint64_t v406 = v425;
        }
      }
      else
      {
        v807 = v399;
      }
      unsigned int v808 = v620;
      int v809 = v403;
      int v810 = v404;
      v812 = v623;
      v813 = (unsigned char *)v629;
      v814 = v626;
      v815 = v820;
      if (v406 == v938)
      {
        v816 = v820;
        uint64_t v427 = (uint64_t)v677;
        int v426 = v685;
        uint64_t v428 = v671;
        if (v407) {
          memcpy(v820, v938, 8 * v407);
        }
      }
      else
      {
        v816 = v406;
        uint64_t v427 = (uint64_t)v677;
        int v426 = v685;
        uint64_t v428 = v671;
      }
      unsigned int v817 = v411;
      int v818 = v407;
      int v819 = v412;
      v821 = v413;
      v822 = (unsigned char *)v427;
      v823 = v428;
      if (v426 != v693)
      {
        free(v426);
        uint64_t v429 = (char *)v901;
        if ((void)v901)
        {
          for (i27 = (char *)*((void *)&v901 + 1); i27 != v429; i27 -= 32)
          {
            if (*(i27 - 8)) {
              *(i27 - 8) = 0;
            }
          }
          *((void *)&v901 + 1) = v429;
          operator delete(v429);
        }
      }
      if (v897 != v896) {
        free(v897);
      }
      int v431 = (char *)v848;
      if (v848)
      {
        for (i28 = v849; i28 != v431; i28 -= 32)
        {
          if (*(i28 - 8)) {
            *(i28 - 8) = 0;
          }
        }
        v849 = v431;
        operator delete(v431);
      }
      if (v843 != v842) {
        free(v843);
      }
      unsigned int v433 = (char *)v856;
      if ((void)v856)
      {
        for (i29 = (char *)*((void *)&v856 + 1); i29 != v433; i29 -= 32)
        {
          if (*(i29 - 8)) {
            *(i29 - 8) = 0;
          }
        }
        *((void *)&v856 + 1) = v433;
        operator delete(v433);
      }
      if (v852 != v851) {
        free(v852);
      }
      uint64_t v435 = (char *)v923;
      if (v923)
      {
        for (i30 = (char *)v924; i30 != v435; i30 -= 32)
        {
          if (*(i30 - 8)) {
            *(i30 - 8) = 0;
          }
        }
        uint64_t v924 = (uint64_t)v435;
        operator delete(v435);
      }
      if (v919 != v918) {
        free(v919);
      }
      uint64_t v437 = (char *)v916;
      if ((void)v916)
      {
        for (i31 = (char *)*((void *)&v916 + 1); i31 != v437; i31 -= 32)
        {
          if (*(i31 - 8)) {
            *(i31 - 8) = 0;
          }
        }
        *((void *)&v916 + 1) = v437;
        operator delete(v437);
      }
      if (v912 != v911) {
        free(v912);
      }
      uint64_t v439 = (char *)v886;
      if ((void)v886)
      {
        for (i32 = (char *)*((void *)&v886 + 1); i32 != v439; i32 -= 32)
        {
          if (*(i32 - 8)) {
            *(i32 - 8) = 0;
          }
        }
        *((void *)&v886 + 1) = v439;
        operator delete(v439);
      }
      if (v882 != v881) {
        free(v882);
      }
      uint64_t v441 = (char *)v871;
      if ((void)v871)
      {
        for (i33 = (char *)*((void *)&v871 + 1); i33 != v441; i33 -= 32)
        {
          if (*(i33 - 8)) {
            *(i33 - 8) = 0;
          }
        }
        *((void *)&v871 + 1) = v441;
        operator delete(v441);
      }
      if (v867 != v866) {
        free(v867);
      }
      uint64_t v443 = v885;
      v881 = v885;
      int v444 = v790;
      if (v790 == v789)
      {
        v882 = v885;
        uint64_t v445 = v790;
      }
      else
      {
        unsigned int v600 = v791;
        uint64_t v443 = malloc_type_malloc(8 * v791, 0x4065EBACuLL);
        if (!v443)
        {
          if (v600) {
            goto LABEL_1474;
          }
          uint64_t v443 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
          if (!v443) {
            goto LABEL_1474;
          }
        }
        v882 = v443;
        uint64_t v445 = v789;
        int v444 = v790;
      }
      int v446 = v792;
      LODWORD(v883) = v791;
      if (v444 == v445) {
        unsigned int v447 = v792;
      }
      else {
        unsigned int v447 = v791;
      }
      if (v447)
      {
        memmove(v443, v444, 8 * v447);
        int v446 = v792;
      }
      HIDWORD(v883) = v446;
      int v884 = v793;
      v887 = 0;
      long long v886 = 0uLL;
      sub_1CD31D500((char *)&v886, __p, *((uint64_t *)&__p + 1), (uint64_t)(*((void *)&__p + 1) - __p) >> 5);
      unsigned int v448 = v892;
      v888 = v892;
      uint64_t v449 = v798;
      if (v798 == v797)
      {
        v889 = v892;
        uint64_t v450 = v798;
      }
      else
      {
        unsigned int v601 = v799;
        unsigned int v448 = malloc_type_malloc(8 * v799, 0x4065EBACuLL);
        if (!v448)
        {
          if (v601) {
            goto LABEL_1474;
          }
          unsigned int v448 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
          if (!v448) {
            goto LABEL_1474;
          }
        }
        v889 = v448;
        uint64_t v450 = v797;
        uint64_t v449 = v798;
      }
      int v451 = v800;
      LODWORD(v890) = v799;
      if (v449 == v450) {
        unsigned int v452 = v800;
      }
      else {
        unsigned int v452 = v799;
      }
      if (v452)
      {
        memmove(v448, v449, 8 * v452);
        int v451 = v800;
      }
      HIDWORD(v890) = v451;
      int v891 = v801;
      v895 = 0;
      v893 = 0;
      v894 = 0;
      sub_1CD31D500((char *)&v893, (uint64_t)v803, (uint64_t)v804, (v804 - (unsigned char *)v803) >> 5);
      v926 = v930;
      int v453 = v882;
      if (v882 == v881)
      {
        v927 = v930;
        unsigned int v454 = HIDWORD(v883);
        if (HIDWORD(v883)) {
          memmove(v930, v882, 8 * HIDWORD(v883));
        }
        int v453 = v930;
      }
      else
      {
        v927 = v882;
        v882 = v881;
        unsigned int v454 = HIDWORD(v883);
      }
      unsigned int v455 = v883;
      int v456 = v884;
      unint64_t v928 = __PAIR64__(v454, v883);
      int v929 = v884;
      uint64_t v883 = 8;
      int v884 = 0;
      uint64_t v714 = *((void *)&v886 + 1);
      uint64_t v722 = v886;
      long long v931 = v886;
      uint64_t v457 = v887;
      v887 = 0;
      long long v886 = 0uLL;
      __dstb = v457;
      v932 = v457;
      v933 = v938;
      uint64_t v458 = v889;
      unsigned int v686 = v455;
      int v678 = v456;
      if (v889 == v888)
      {
        v934 = v938;
        unsigned int v459 = HIDWORD(v890);
        if (HIDWORD(v890)) {
          memmove(v938, v889, 8 * HIDWORD(v890));
        }
        uint64_t v458 = v938;
      }
      else
      {
        v934 = v889;
        v889 = v888;
        unsigned int v459 = HIDWORD(v890);
      }
      unsigned int v672 = v890;
      int v935 = v890;
      unsigned int v936 = v459;
      int v700 = v891;
      int v937 = v891;
      uint64_t v890 = 8;
      int v891 = 0;
      uint64_t v460 = (uint64_t)v894;
      v694 = v893;
      v939 = v893;
      v940 = v894;
      uint64_t v461 = v895;
      v894 = 0;
      v895 = 0;
      v893 = 0;
      v941 = v461;
      if (v453 == v930)
      {
        if (v454) {
          memcpy(v745, v930, 8 * v454);
        }
        int v453 = v745;
      }
      *(void *)&long long v746 = v722;
      *((void *)&v746 + 1) = v714;
      v747 = __dstb;
      v748 = v753;
      if (v458 == v938)
      {
        v749 = v753;
        unsigned int v462 = v686;
        if (v459) {
          memcpy(v753, v938, 8 * v459);
        }
        uint64_t v458 = v753;
      }
      else
      {
        v749 = v458;
        unsigned int v462 = v686;
      }
      unsigned int v750 = v672;
      int v751 = v459;
      int v752 = v700;
      v754 = v694;
      v755 = (unsigned char *)v460;
      v756 = v461;
      v896 = v900;
      if (v453 == v745)
      {
        v897 = v900;
        if (v454) {
          memcpy(v900, v745, 8 * v454);
        }
      }
      else
      {
        v897 = v453;
      }
      unint64_t v898 = __PAIR64__(v454, v462);
      int v899 = v678;
      *(void *)&long long v901 = v722;
      *((void *)&v901 + 1) = v714;
      v902 = __dstb;
      v903 = v907;
      if (v458 == v753)
      {
        v904 = v907;
        if (v459) {
          memcpy(v907, v753, 8 * v459);
        }
      }
      else
      {
        v904 = v458;
      }
      unint64_t v905 = __PAIR64__(v459, v672);
      int v906 = v700;
      v908 = v694;
      v909 = (char *)v460;
      v910 = v461;
      int v463 = v855;
      v851 = v855;
      uint64_t v464 = v807;
      if (v807 == v806)
      {
        v852 = v855;
        uint64_t v465 = v807;
      }
      else
      {
        unsigned int v602 = v808;
        int v463 = malloc_type_malloc(8 * v808, 0x4065EBACuLL);
        if (!v463)
        {
          if (v602) {
            goto LABEL_1474;
          }
          int v463 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
          if (!v463) {
            goto LABEL_1474;
          }
        }
        v852 = v463;
        uint64_t v465 = v806;
        uint64_t v464 = v807;
      }
      LODWORD(v853) = v808;
      int v466 = v809;
      if (v464 == v465) {
        unsigned int v467 = v809;
      }
      else {
        unsigned int v467 = v808;
      }
      if (v467)
      {
        memmove(v463, v464, 8 * v467);
        int v466 = v809;
      }
      HIDWORD(v853) = v466;
      int v854 = v810;
      v857 = 0;
      long long v856 = 0uLL;
      sub_1CD31D500((char *)&v856, (uint64_t)v812, (uint64_t)v813, (v813 - (unsigned char *)v812) >> 5);
      unint64_t v468 = v862;
      v858 = v862;
      uint64_t v469 = v816;
      if (v816 == v815)
      {
        v859 = v862;
        int v470 = v816;
      }
      else
      {
        unsigned int v603 = v817;
        unint64_t v468 = malloc_type_malloc(8 * v817, 0x4065EBACuLL);
        if (!v468)
        {
          if (v603) {
            goto LABEL_1474;
          }
          unint64_t v468 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
          if (!v468) {
            goto LABEL_1474;
          }
        }
        v859 = v468;
        int v470 = v815;
        uint64_t v469 = v816;
      }
      LODWORD(v860) = v817;
      int v471 = v818;
      if (v469 == v470) {
        unsigned int v472 = v818;
      }
      else {
        unsigned int v472 = v817;
      }
      if (v472)
      {
        memmove(v468, v469, 8 * v472);
        int v471 = v818;
      }
      HIDWORD(v860) = v471;
      int v861 = v819;
      v865 = 0;
      v863 = 0;
      v864 = 0;
      sub_1CD31D500((char *)&v863, (uint64_t)v821, (uint64_t)v822, (v822 - (unsigned char *)v821) >> 5);
      v926 = v930;
      uint64_t v473 = v852;
      if (v852 == v851)
      {
        v927 = v930;
        unsigned int v474 = HIDWORD(v853);
        if (HIDWORD(v853)) {
          memmove(v930, v852, 8 * HIDWORD(v853));
        }
        uint64_t v473 = v930;
      }
      else
      {
        v927 = v852;
        v852 = v851;
        unsigned int v474 = HIDWORD(v853);
      }
      unsigned int v475 = v853;
      int v476 = v854;
      unint64_t v928 = __PAIR64__(v474, v853);
      int v929 = v854;
      uint64_t v853 = 8;
      int v854 = 0;
      uint64_t v715 = *((void *)&v856 + 1);
      v723 = (void *)v856;
      long long v931 = v856;
      uint64_t v477 = v857;
      v857 = 0;
      long long v856 = 0uLL;
      __dstc = v477;
      v932 = v477;
      v933 = v938;
      unint64_t v478 = v859;
      unsigned __int8 v649 = v858;
      if (v859 == v858)
      {
        v934 = v938;
        unsigned int v479 = HIDWORD(v860);
        if (HIDWORD(v860))
        {
          uint64_t v480 = v473;
          memmove(v938, v859, 8 * HIDWORD(v860));
          uint64_t v473 = v480;
        }
        unsigned int v645 = v478;
        unsigned int v481 = v938;
      }
      else
      {
        unsigned int v481 = v859;
        v934 = v859;
        v859 = v858;
        unsigned int v645 = v858;
        unsigned int v479 = HIDWORD(v860);
      }
      unsigned int v701 = v860;
      int v935 = v860;
      unsigned int v936 = v479;
      int v695 = v861;
      int v937 = v861;
      uint64_t v860 = 8;
      int v861 = 0;
      uint64_t v679 = v864;
      __int16 v687 = v863;
      v939 = v863;
      v940 = v864;
      unsigned int v482 = v865;
      v864 = 0;
      v865 = 0;
      v863 = 0;
      int v673 = v482;
      v941 = v482;
      if (v473 == v930)
      {
        if (v474) {
          memcpy(v745, v930, 8 * v474);
        }
        uint64_t v473 = v745;
      }
      *(void *)&long long v746 = v723;
      *((void *)&v746 + 1) = v715;
      v747 = __dstc;
      v748 = v753;
      if (v481 == v938)
      {
        v749 = v753;
        if (v479)
        {
          char v483 = v473;
          memcpy(v753, v938, 8 * v479);
          uint64_t v473 = v483;
        }
        uint64_t v484 = v753;
      }
      else
      {
        uint64_t v484 = v481;
        v749 = v481;
      }
      unsigned int v750 = v701;
      int v751 = v479;
      int v752 = v695;
      v754 = v687;
      v755 = v679;
      v756 = v673;
      v866 = v870;
      if (v473 == v745)
      {
        v867 = v870;
        uint64_t v473 = v870;
        if (v474)
        {
          memcpy(v870, v745, 8 * v474);
          uint64_t v473 = v870;
        }
      }
      else
      {
        v867 = v473;
      }
      unint64_t v868 = __PAIR64__(v474, v475);
      int v869 = v476;
      *(void *)&long long v871 = v723;
      *((void *)&v871 + 1) = v715;
      v872 = __dstc;
      v873 = v877;
      unsigned int v667 = v474;
      if (v484 == v753)
      {
        v874 = v877;
        uint64_t v484 = v877;
        if (v479)
        {
          uint64_t v485 = v473;
          memcpy(v877, v753, 8 * v479);
          uint64_t v473 = v485;
          uint64_t v484 = v877;
        }
      }
      else
      {
        v874 = v484;
      }
      uint64_t v663 = v484;
      unint64_t v875 = __PAIR64__(v479, v701);
      int v876 = v695;
      v878 = v687;
      uint64_t v879 = (uint64_t)v679;
      v880 = v673;
      v926 = v930;
      uint64_t v486 = v897;
      if (v897 == v896)
      {
        v927 = v930;
        unsigned int v487 = HIDWORD(v898);
        if (HIDWORD(v898))
        {
          uint64_t v488 = v473;
          memmove(v930, v897, 8 * HIDWORD(v898));
          uint64_t v473 = v488;
        }
        uint64_t v486 = v930;
      }
      else
      {
        v927 = v897;
        v897 = v896;
        unsigned int v487 = HIDWORD(v898);
      }
      int v489 = v899;
      unsigned int v630 = v898;
      unint64_t v928 = __PAIR64__(v487, v898);
      int v929 = v899;
      unint64_t v898 = 8;
      int v899 = 0;
      long long v490 = v901;
      long long v931 = v901;
      uint64_t v491 = v902;
      v902 = 0;
      long long v901 = 0uLL;
      v932 = v491;
      v933 = v938;
      uint64_t v492 = v904;
      int v627 = v489;
      int v617 = v491;
      if (v904 == v903)
      {
        v934 = v938;
        unsigned int v493 = HIDWORD(v905);
        if (HIDWORD(v905))
        {
          int v494 = v473;
          uint64_t v495 = v486;
          memmove(v938, v904, 8 * HIDWORD(v905));
          uint64_t v486 = v495;
          uint64_t v473 = v494;
        }
        uint64_t v492 = v938;
      }
      else
      {
        v934 = v904;
        v904 = v903;
        unsigned int v493 = HIDWORD(v905);
      }
      unsigned int v659 = v475;
      unsigned int v641 = v905;
      int v935 = v905;
      unsigned int v936 = v493;
      int v637 = v906;
      int v937 = v906;
      unint64_t v905 = 8;
      int v906 = 0;
      uint64_t v611 = (uint64_t)v909;
      uint64_t v613 = v908;
      v939 = v908;
      v940 = v909;
      uint64_t v633 = v910;
      v941 = v910;
      v909 = 0;
      v910 = 0;
      v908 = 0;
      v911 = v915;
      if (v473 == v870)
      {
        v912 = v915;
        unsigned int v496 = v667;
        if (v667)
        {
          unint64_t v497 = v486;
          int v498 = v492;
          memcpy(v915, v870, 8 * v667);
          uint64_t v492 = v498;
          uint64_t v486 = v497;
        }
        uint64_t v473 = v915;
      }
      else
      {
        v912 = v473;
        v867 = v870;
        unsigned int v496 = v667;
      }
      unint64_t v913 = __PAIR64__(v496, v659);
      unsigned int v668 = v496;
      int v914 = v476;
      unint64_t v868 = 8;
      int v869 = 0;
      *(void *)&long long v916 = v723;
      *((void *)&v916 + 1) = v715;
      v872 = 0;
      long long v871 = 0uLL;
      v917 = __dstc;
      v918 = v922;
      if (v663 == v877)
      {
        v919 = v922;
        if (v479)
        {
          uint64_t v499 = v473;
          int v500 = v486;
          uint64_t v501 = v492;
          memcpy(v922, v877, 8 * v479);
          uint64_t v492 = v501;
          uint64_t v486 = v500;
          uint64_t v473 = v499;
        }
        uint64_t v663 = v922;
      }
      else
      {
        v919 = v663;
        v874 = v877;
      }
      unint64_t v920 = __PAIR64__(v479, v701);
      int v921 = v695;
      unint64_t v875 = 8;
      int v876 = 0;
      v923 = v687;
      uint64_t v924 = (uint64_t)v679;
      v925 = v673;
      uint64_t v879 = 0;
      v880 = 0;
      v878 = 0;
      v740 = v745;
      if (v486 == v930)
      {
        v741 = v745;
        if (v487)
        {
          uint64_t v502 = v473;
          uint64_t v503 = v492;
          memcpy(v745, v930, 8 * v487);
          uint64_t v492 = v503;
          uint64_t v473 = v502;
        }
      }
      else
      {
        v741 = v486;
      }
      unsigned int v742 = v630;
      int v743 = v487;
      int v744 = v627;
      long long v746 = v490;
      v747 = v617;
      v748 = v753;
      if (v492 == v938)
      {
        v749 = v753;
        unsigned int v504 = v641;
        int v505 = v637;
        unsigned int v506 = v633;
        if (v493)
        {
          unint64_t v507 = v473;
          memcpy(v753, v938, 8 * v493);
          uint64_t v473 = v507;
        }
      }
      else
      {
        v749 = v492;
        unsigned int v504 = v641;
        int v505 = v637;
        unsigned int v506 = v633;
      }
      unsigned int v750 = v504;
      int v751 = v493;
      int v752 = v505;
      v754 = v613;
      v755 = (unsigned char *)v611;
      v756 = v506;
      v757 = v762;
      if (v473 == v915)
      {
        v758 = v762;
        unsigned int v508 = v668;
        if (v668) {
          memcpy(v762, v915, 8 * v668);
        }
      }
      else
      {
        v758 = v473;
        unsigned int v508 = v668;
      }
      unsigned int v759 = v659;
      int v760 = v508;
      int v761 = v476;
      v763 = v723;
      v764 = (unsigned char *)v715;
      v765 = __dstc;
      v766 = v771;
      if (v663 == v922)
      {
        v767 = v771;
        uint64_t v510 = v645;
        unsigned int v509 = v649;
        if (v479) {
          memcpy(v771, v922, 8 * v479);
        }
      }
      else
      {
        v767 = v663;
        uint64_t v510 = v645;
        unsigned int v509 = v649;
      }
      unsigned int v768 = v701;
      unsigned int v769 = v479;
      int v770 = v695;
      v772 = v687;
      v773 = v679;
      v774 = v673;
      if (v510 != v509)
      {
        free(v510);
        uint64_t v511 = (char *)v856;
        if ((void)v856)
        {
          for (i34 = (char *)*((void *)&v856 + 1); i34 != v511; i34 -= 32)
          {
            if (*(i34 - 8)) {
              *(i34 - 8) = 0;
            }
          }
          *((void *)&v856 + 1) = v511;
          operator delete(v511);
        }
      }
      if (v852 != v851) {
        free(v852);
      }
      uint64_t v513 = (char *)v908;
      if (v908)
      {
        for (i35 = v909; i35 != v513; i35 -= 32)
        {
          if (*(i35 - 8)) {
            *(i35 - 8) = 0;
          }
        }
        v909 = v513;
        operator delete(v513);
      }
      if (v904 != v903) {
        free(v904);
      }
      uint64_t v515 = (char *)v901;
      if ((void)v901)
      {
        for (i36 = (char *)*((void *)&v901 + 1); i36 != v515; i36 -= 32)
        {
          if (*(i36 - 8)) {
            *(i36 - 8) = 0;
          }
        }
        *((void *)&v901 + 1) = v515;
        operator delete(v515);
      }
      if (v897 != v896) {
        free(v897);
      }
      uint64_t v517 = (char *)v893;
      if (v893)
      {
        for (i37 = v894; i37 != v517; i37 -= 32)
        {
          if (*(i37 - 8)) {
            *(i37 - 8) = 0;
          }
        }
        v894 = v517;
        operator delete(v517);
      }
      if (v889 != v888) {
        free(v889);
      }
      uint64_t v519 = (char *)v886;
      if ((void)v886)
      {
        for (i38 = (char *)*((void *)&v886 + 1); i38 != v519; i38 -= 32)
        {
          if (*(i38 - 8)) {
            *(i38 - 8) = 0;
          }
        }
        *((void *)&v886 + 1) = v519;
        operator delete(v519);
      }
      if (v882 != v881) {
        free(v882);
      }
      uint64_t v521 = v821;
      if (v821)
      {
        for (uint64_t i39 = (uint64_t)v822; (unsigned char *)i39 != v521; i39 -= 32)
        {
          if (*(unsigned char *)(i39 - 8)) {
            *(unsigned char *)(i39 - 8) = 0;
          }
        }
        v822 = v521;
        operator delete(v521);
      }
      if (v816 != v815) {
        free(v816);
      }
      uint64_t v523 = v812;
      if (v812)
      {
        for (uint64_t i40 = (uint64_t)v813; (unsigned char *)i40 != v523; i40 -= 32)
        {
          if (*(unsigned char *)(i40 - 8)) {
            *(unsigned char *)(i40 - 8) = 0;
          }
        }
        v813 = v523;
        operator delete(v523);
      }
      if (v807 != v806) {
        free(v807);
      }
      uint64_t v525 = v803;
      if (v803)
      {
        for (uint64_t i41 = (uint64_t)v804; (unsigned char *)i41 != v525; i41 -= 32)
        {
          if (*(unsigned char *)(i41 - 8)) {
            *(unsigned char *)(i41 - 8) = 0;
          }
        }
        v804 = v525;
        operator delete(v525);
      }
      if (v798 != v797) {
        free(v798);
      }
      unsigned int v527 = (char *)__p;
      if ((void)__p)
      {
        for (i42 = (char *)*((void *)&__p + 1); i42 != v527; i42 -= 32)
        {
          if (*(i42 - 8)) {
            *(i42 - 8) = 0;
          }
        }
        *((void *)&__p + 1) = v527;
        operator delete(v527);
      }
      if (v790 != v789) {
        free(v790);
      }
      uint64_t v529 = v839;
      if (v839)
      {
        for (uint64_t i43 = (uint64_t)v840; (unsigned char *)i43 != v529; i43 -= 32)
        {
          if (*(unsigned char *)(i43 - 8)) {
            *(unsigned char *)(i43 - 8) = 0;
          }
        }
        v840 = v529;
        operator delete(v529);
      }
      if (v834 != v833) {
        free(v834);
      }
      unint64_t v531 = v830;
      if (v830)
      {
        for (uint64_t i44 = (uint64_t)v831; (unsigned char *)i44 != v531; i44 -= 32)
        {
          if (*(unsigned char *)(i44 - 8)) {
            *(unsigned char *)(i44 - 8) = 0;
          }
        }
        v831 = v531;
        operator delete(v531);
      }
      if (v825 != v824) {
        free(v825);
      }
      uint64_t v533 = v738;
      if (v738)
      {
        for (uint64_t i45 = (uint64_t)v739; (unsigned char *)i45 != v533; i45 -= 32)
        {
          if (*(unsigned char *)(i45 - 8)) {
            *(unsigned char *)(i45 - 8) = 0;
          }
        }
        v739 = v533;
        operator delete(v533);
      }
      if (v734 != v733) {
        free(v734);
      }
      uint64_t v535 = v730;
      if (v730)
      {
        for (uint64_t i46 = (uint64_t)v731; (unsigned char *)i46 != v535; i46 -= 32)
        {
          if (*(unsigned char *)(i46 - 8)) {
            *(unsigned char *)(i46 - 8) = 0;
          }
        }
        v731 = v535;
        operator delete(v535);
      }
      if (v725 != v724) {
        free(v725);
      }
      int v537 = v794;
      v789 = v794;
      uint64_t v538 = v741;
      if (v741 == v740)
      {
        v790 = v794;
        char v539 = v741;
      }
      else
      {
        unsigned int v604 = v742;
        int v537 = malloc_type_malloc(8 * v742, 0x4065EBACuLL);
        if (!v537)
        {
          if (v604) {
            goto LABEL_1474;
          }
          int v537 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
          if (!v537) {
            goto LABEL_1474;
          }
        }
        v790 = v537;
        char v539 = v740;
        uint64_t v538 = v741;
      }
      int v540 = v743;
      unsigned int v791 = v742;
      if (v538 == v539) {
        unsigned int v541 = v743;
      }
      else {
        unsigned int v541 = v742;
      }
      if (v541)
      {
        memmove(v537, v538, 8 * v541);
        int v540 = v743;
      }
      int v792 = v540;
      int v793 = v744;
      v796 = 0;
      long long __p = 0uLL;
      sub_1CD31D500((char *)&__p, v746, *((uint64_t *)&v746 + 1), (uint64_t)(*((void *)&v746 + 1) - v746) >> 5);
      uint64_t v542 = v802;
      v797 = v802;
      int v543 = v749;
      if (v749 == v748)
      {
        v798 = v802;
        int v544 = v749;
      }
      else
      {
        unsigned int v605 = v750;
        uint64_t v542 = malloc_type_malloc(8 * v750, 0x4065EBACuLL);
        if (!v542)
        {
          if (v605) {
            goto LABEL_1474;
          }
          uint64_t v542 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
          if (!v542) {
            goto LABEL_1474;
          }
        }
        v798 = v542;
        int v544 = v748;
        int v543 = v749;
      }
      int v545 = v751;
      unsigned int v799 = v750;
      if (v543 == v544) {
        unsigned int v546 = v751;
      }
      else {
        unsigned int v546 = v750;
      }
      if (v546)
      {
        memmove(v542, v543, 8 * v546);
        int v545 = v751;
      }
      int v800 = v545;
      int v801 = v752;
      v805 = 0;
      v803 = 0;
      v804 = 0;
      sub_1CD31D500((char *)&v803, (uint64_t)v754, (uint64_t)v755, (v755 - (unsigned char *)v754) >> 5);
      int v547 = v930;
      v926 = v930;
      int v548 = v758;
      if (v758 == v757)
      {
        v927 = v930;
        uint64_t v549 = v758;
      }
      else
      {
        unsigned int v606 = v759;
        int v547 = malloc_type_malloc(8 * v759, 0x4065EBACuLL);
        if (!v547)
        {
          if (v606) {
            goto LABEL_1474;
          }
          int v547 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
          if (!v547) {
            goto LABEL_1474;
          }
        }
        v927 = v547;
        uint64_t v549 = v757;
        int v548 = v758;
      }
      LODWORD(v928) = v759;
      int v550 = v760;
      if (v548 == v549) {
        unsigned int v551 = v760;
      }
      else {
        unsigned int v551 = v759;
      }
      if (v551)
      {
        memmove(v547, v548, 8 * v551);
        int v550 = v760;
      }
      HIDWORD(v928) = v550;
      int v929 = v761;
      v932 = 0;
      long long v931 = 0uLL;
      sub_1CD31D500((char *)&v931, (uint64_t)v763, (uint64_t)v764, (v764 - (unsigned char *)v763) >> 5);
      int v552 = v938;
      v933 = v938;
      BOOL v553 = v767;
      if (v767 == v766)
      {
        v934 = v938;
        uint64_t v554 = v767;
LABEL_1199:
        int v935 = v768;
        unsigned int v555 = v769;
        if (v553 == v554) {
          unsigned int v556 = v769;
        }
        else {
          unsigned int v556 = v768;
        }
        if (v556)
        {
          memmove(v552, v553, 8 * v556);
          unsigned int v555 = v769;
        }
        unsigned int v936 = v555;
        int v937 = v770;
        v941 = 0;
        v939 = 0;
        v940 = 0;
        uint64_t v557 = sub_1CD31D500((char *)&v939, (uint64_t)v772, (uint64_t)v773, (v773 - (unsigned char *)v772) >> 5);
        uint64_t v558 = *((void *)&__p + 1);
        uint64_t v559 = __p;
        while (1)
        {
LABEL_1205:
          if (v558 - v559 == *((void *)&v931 + 1) - (void)v931)
          {
            if (v559 == v558)
            {
LABEL_1245:
              uint64_t v314 = 1;
              goto LABEL_1253;
            }
            uint64_t v560 = v931 + 16;
            uint64_t v561 = v559 + 16;
            while (1)
            {
              uint64_t v562 = v561 - 16;
              if (*(void *)(v561 - 16) != *(void *)(v560 - 16)) {
                break;
              }
              int v563 = *(unsigned __int8 *)(v560 + 8);
              if (*(unsigned char *)(v561 + 8)) {
                BOOL v564 = v563 == 0;
              }
              else {
                BOOL v564 = 1;
              }
              if (v564)
              {
                if ((*(unsigned char *)(v561 + 8) == 0) == (v563 != 0)) {
                  break;
                }
              }
              else if (*(void *)(v561 - 8) != *(void *)(v560 - 8) || *(void *)v561 != *(void *)v560)
              {
                break;
              }
              v560 += 32;
              v561 += 32;
              if (v562 + 32 == v558) {
                goto LABEL_1245;
              }
            }
          }
          uint64_t v566 = *(void *)(v558 - 32);
          if (*(_DWORD *)(*(void *)(v566 + 200) + 56)) {
            break;
          }
          if (*(_DWORD *)(*(void *)(v566 + 208) + 80))
          {
            unint64_t v573 = (llvm::raw_ostream *)llvm::errs((llvm *)v557);
            int v577 = (void *)*((void *)v573 + 4);
            if (*((void *)v573 + 3) - (void)v577 <= 0x20uLL)
            {
              int v575 = "region exit block has successors\n";
              size_t v576 = 33;
LABEL_1252:
              llvm::raw_ostream::write(v573, v575, v576);
              uint64_t v314 = 0;
LABEL_1253:
              uint64_t v578 = (char *)v939;
              if (v939)
              {
                for (i47 = v940; i47 != v578; i47 -= 32)
                {
                  if (*(i47 - 8)) {
                    *(i47 - 8) = 0;
                  }
                }
                v940 = v578;
                operator delete(v578);
              }
              if (v934 != v933) {
                free(v934);
              }
              uint64_t v580 = (char *)v931;
              if ((void)v931)
              {
                for (i48 = (char *)*((void *)&v931 + 1); i48 != v580; i48 -= 32)
                {
                  if (*(i48 - 8)) {
                    *(i48 - 8) = 0;
                  }
                }
                *((void *)&v931 + 1) = v580;
                operator delete(v580);
              }
              if (v927 != v926) {
                free(v927);
              }
              int v582 = v803;
              if (v803)
              {
                for (uint64_t i49 = (uint64_t)v804; (unsigned char *)i49 != v582; i49 -= 32)
                {
                  if (*(unsigned char *)(i49 - 8)) {
                    *(unsigned char *)(i49 - 8) = 0;
                  }
                }
                v804 = v582;
                operator delete(v582);
              }
              if (v798 != v797) {
                free(v798);
              }
              BOOL v584 = (char *)__p;
              if ((void)__p)
              {
                for (i50 = (char *)*((void *)&__p + 1); i50 != v584; i50 -= 32)
                {
                  if (*(i50 - 8)) {
                    *(i50 - 8) = 0;
                  }
                }
                *((void *)&__p + 1) = v584;
                operator delete(v584);
              }
              if (v790 != v789) {
                free(v790);
              }
              int v586 = v772;
              if (v772)
              {
                for (uint64_t i51 = (uint64_t)v773; (unsigned char *)i51 != v586; i51 -= 32)
                {
                  if (*(unsigned char *)(i51 - 8)) {
                    *(unsigned char *)(i51 - 8) = 0;
                  }
                }
                v773 = v586;
                operator delete(v586);
              }
              if (v767 != v766) {
                free(v767);
              }
              uint64_t v588 = v763;
              if (v763)
              {
                for (uint64_t i52 = (uint64_t)v764; (unsigned char *)i52 != v588; i52 -= 32)
                {
                  if (*(unsigned char *)(i52 - 8)) {
                    *(unsigned char *)(i52 - 8) = 0;
                  }
                }
                v764 = v588;
                operator delete(v588);
              }
              if (v758 != v757) {
                free(v758);
              }
              uint64_t v590 = v754;
              if (v754)
              {
                for (uint64_t i53 = (uint64_t)v755; (unsigned char *)i53 != v590; i53 -= 32)
                {
                  if (*(unsigned char *)(i53 - 8)) {
                    *(unsigned char *)(i53 - 8) = 0;
                  }
                }
                v755 = v590;
                operator delete(v590);
              }
              if (v749 != v748) {
                free(v749);
              }
              int v592 = (char *)v746;
              if ((void)v746)
              {
                for (i54 = (char *)*((void *)&v746 + 1); i54 != v592; i54 -= 32)
                {
                  if (*(i54 - 8)) {
                    *(i54 - 8) = 0;
                  }
                }
                *((void *)&v746 + 1) = v592;
                operator delete(v592);
              }
              if (v741 != v740) {
                free(v741);
              }
              goto LABEL_718;
            }
            uint64_t v314 = 0;
            qmemcpy(v577, "region exit block has successors\n", 33);
            uint64_t v608 = *((void *)v573 + 4) + 33;
LABEL_1390:
            *((void *)v573 + 4) = v608;
            goto LABEL_1253;
          }
          do
          {
            sub_1CD365374((llvm::SmallPtrSetImplBase *)&v789);
            uint64_t v558 = *((void *)&__p + 1);
            uint64_t v559 = __p;
            if (*((void *)&__p + 1) - (void)__p == v804 - (unsigned char *)v803)
            {
              if ((void)__p == *((void *)&__p + 1)) {
                goto LABEL_1205;
              }
              int v567 = (char *)v803 + 16;
              uint64_t v568 = __p + 16;
              while (1)
              {
                uint64_t v569 = v568 - 16;
                if (*(void *)(v568 - 16) != *((void *)v567 - 2)) {
                  break;
                }
                int v570 = v567[8];
                if (*(unsigned char *)(v568 + 8)) {
                  BOOL v571 = v570 == 0;
                }
                else {
                  BOOL v571 = 1;
                }
                if (v571)
                {
                  if ((*(unsigned char *)(v568 + 8) == 0) == (v570 != 0)) {
                    break;
                  }
                }
                else if (*(void *)(v568 - 8) != *((void *)v567 - 1) || *(void *)v568 != *(void *)v567)
                {
                  break;
                }
                v567 += 32;
                v568 += 32;
                if (v569 + 32 == *((void *)&__p + 1)) {
                  goto LABEL_1205;
                }
              }
            }
          }
          while (*(unsigned char *)(*(void *)(*((void *)&__p + 1) - 32) + 8) != 1);
        }
        unint64_t v573 = (llvm::raw_ostream *)llvm::errs((llvm *)v557);
        uint64_t v574 = (void *)*((void *)v573 + 4);
        if (*((void *)v573 + 3) - (void)v574 <= 0x23uLL)
        {
          int v575 = "region entry block has predecessors\n";
          size_t v576 = 36;
          goto LABEL_1252;
        }
        uint64_t v314 = 0;
        qmemcpy(v574, "region entry block has predecessors\n", 36);
        uint64_t v608 = *((void *)v573 + 4) + 36;
        goto LABEL_1390;
      }
      unsigned int v607 = v768;
      int v552 = malloc_type_malloc(8 * v768, 0x4065EBACuLL);
      if (v552 || !v607 && (int v552 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) != 0)
      {
        v934 = v552;
        uint64_t v554 = v766;
        BOOL v553 = v767;
        goto LABEL_1199;
      }
LABEL_1474:
      llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
    }
LABEL_454:
    uint64_t v238 = *(void *)(v230 - 32);
    uint64_t v239 = (void *)(v238 + 200);
    for (i55 = *(void **)(v238 + 208); ; i55 = (void *)i55[1])
    {
      if (i55 == v239) {
        goto LABEL_466;
      }
      int v241 = i55 - 3;
      if (!i55) {
        int v241 = 0;
      }
      if (*((unsigned __int8 *)v241 + 8) - 13 > 7) {
        break;
      }
    }
LABEL_465:
    if (i55 != v239) {
      break;
    }
    do
    {
LABEL_466:
      sub_1CD365374((llvm::SmallPtrSetImplBase *)&v789);
      uint64_t v230 = *((void *)&__p + 1);
      uint64_t v231 = __p;
      if (*((void *)&__p + 1) - (void)__p == v804 - (unsigned char *)v803)
      {
        if ((void)__p == *((void *)&__p + 1)) {
          goto LABEL_436;
        }
        uint64_t v243 = (char *)v803 + 16;
        uint64_t v244 = __p + 16;
        while (1)
        {
          uint64_t v245 = v244 - 16;
          if (*(void *)(v244 - 16) != *((void *)v243 - 2)) {
            break;
          }
          int v246 = v243[8];
          if (*(unsigned char *)(v244 + 8)) {
            BOOL v247 = v246 == 0;
          }
          else {
            BOOL v247 = 1;
          }
          if (v247)
          {
            if ((*(unsigned char *)(v244 + 8) == 0) == (v246 != 0)) {
              break;
            }
          }
          else if (*(void *)(v244 - 8) != *((void *)v243 - 1) || *(void *)v244 != *(void *)v243)
          {
            break;
          }
          v243 += 32;
          v244 += 32;
          if (v245 + 32 == *((void *)&__p + 1)) {
            goto LABEL_436;
          }
        }
      }
    }
    while (*(unsigned char *)(*(void *)(*((void *)&__p + 1) - 32) + 8));
  }
  if (i55) {
    uint64_t v242 = (unsigned __int8 *)(i55 - 3);
  }
  else {
    uint64_t v242 = 0;
  }
  if (v242[8] - 21 < 0xFFFFFFF9)
  {
    i55 = (void *)i55[1];
    goto LABEL_465;
  }
  uint64_t v268 = (llvm::raw_ostream *)llvm::errs((llvm *)v229);
  uint64_t v269 = (void *)*((void *)v268 + 4);
  if (*((void *)v268 + 3) - (void)v269 > 0x29uLL)
  {
    qmemcpy(v269, "Found phi-like recipe after non-phi recipe", 42);
    *((void *)v268 + 4) += 42;
  }
  else
  {
    uint64_t v268 = llvm::raw_ostream::write(v268, "Found phi-like recipe after non-phi recipe", 0x2AuLL);
  }
  int v270 = (llvm::raw_ostream *)llvm::errs(v268);
  uint64_t v271 = (_WORD *)*((void *)v270 + 4);
  if (*((void *)v270 + 3) - (void)v271 > 1uLL)
  {
    *uint64_t v271 = 8250;
    *((void *)v270 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(v270, ": ", 2uLL);
  }
  uint64_t v272 = (llvm *)llvm::VPDef::dump((llvm::VPDef *)v242);
  unint64_t v273 = (llvm::raw_ostream *)llvm::errs(v272);
  uint64_t v274 = *((void *)v273 + 4);
  if ((unint64_t)(*((void *)v273 + 3) - v274) > 5)
  {
    *(_WORD *)(v274 + 4) = 2674;
    *(_DWORD *)uint64_t v274 = 1702127201;
    *((void *)v273 + 4) += 6;
  }
  else
  {
    llvm::raw_ostream::write(v273, "after\n", 6uLL);
  }
  if (*i55) {
    int v275 = (llvm::VPDef *)(*i55 - 24);
  }
  else {
    int v275 = 0;
  }
  llvm::VPDef::dump(v275);
  uint64_t v276 = (char *)v939;
  if (v939)
  {
    for (i56 = v940; i56 != v276; i56 -= 32)
    {
      if (*(i56 - 8)) {
        *(i56 - 8) = 0;
      }
    }
    v940 = v276;
    operator delete(v276);
  }
  if (v934 != v933) {
    free(v934);
  }
  char v278 = (char *)v931;
  if ((void)v931)
  {
    for (i57 = (char *)*((void *)&v931 + 1); i57 != v278; i57 -= 32)
    {
      if (*(i57 - 8)) {
        *(i57 - 8) = 0;
      }
    }
    *((void *)&v931 + 1) = v278;
    operator delete(v278);
  }
  if (v927 != v926) {
    free(v927);
  }
  int v280 = v803;
  if (v803)
  {
    for (uint64_t i58 = (uint64_t)v804; (unsigned char *)i58 != v280; i58 -= 32)
    {
      if (*(unsigned char *)(i58 - 8)) {
        *(unsigned char *)(i58 - 8) = 0;
      }
    }
    v804 = v280;
    operator delete(v280);
  }
  if (v798 != v797) {
    free(v798);
  }
  uint64_t v282 = (char *)__p;
  if ((void)__p)
  {
    for (i59 = (char *)*((void *)&__p + 1); i59 != v282; i59 -= 32)
    {
      if (*(i59 - 8)) {
        *(i59 - 8) = 0;
      }
    }
    *((void *)&__p + 1) = v282;
    operator delete(v282);
  }
  if (v790 != v789) {
    free(v790);
  }
  uint64_t v284 = v772;
  if (v772)
  {
    for (uint64_t i60 = (uint64_t)v773; (unsigned char *)i60 != v284; i60 -= 32)
    {
      if (*(unsigned char *)(i60 - 8)) {
        *(unsigned char *)(i60 - 8) = 0;
      }
    }
    v773 = v284;
    operator delete(v284);
  }
  if (v767 != v766) {
    free(v767);
  }
  int v286 = v763;
  if (v763)
  {
    for (uint64_t i61 = (uint64_t)v764; (unsigned char *)i61 != v286; i61 -= 32)
    {
      if (*(unsigned char *)(i61 - 8)) {
        *(unsigned char *)(i61 - 8) = 0;
      }
    }
    v764 = v286;
    operator delete(v286);
  }
  if (v758 != v757) {
    free(v758);
  }
  uint64_t v288 = v754;
  if (v754)
  {
    for (uint64_t i62 = (uint64_t)v755; (unsigned char *)i62 != v288; i62 -= 32)
    {
      if (*(unsigned char *)(i62 - 8)) {
        *(unsigned char *)(i62 - 8) = 0;
      }
    }
    v755 = v288;
    operator delete(v288);
  }
  if (v749 != v748) {
    free(v749);
  }
  uint64_t v290 = (char *)v746;
  if ((void)v746)
  {
    for (i63 = (char *)*((void *)&v746 + 1); i63 != v290; i63 -= 32)
    {
      if (*(i63 - 8)) {
        *(i63 - 8) = 0;
      }
    }
    *((void *)&v746 + 1) = v290;
    operator delete(v290);
  }
  if (v741 != v740) {
    free(v741);
  }
LABEL_717:
  uint64_t v314 = 0;
LABEL_718:
  uint64_t v315 = v787;
  if (v787)
  {
    for (uint64_t i64 = (uint64_t)v788; (unsigned char *)i64 != v315; i64 -= 32)
    {
      if (*(unsigned char *)(i64 - 8)) {
        *(unsigned char *)(i64 - 8) = 0;
      }
    }
    v788 = v315;
    operator delete(v315);
  }
  if (v783 != v782) {
    free(v783);
  }
  unsigned int v317 = v780;
  if (v780)
  {
    for (uint64_t i65 = (uint64_t)v781; (unsigned char *)i65 != v317; i65 -= 32)
    {
      if (*(unsigned char *)(i65 - 8)) {
        *(unsigned char *)(i65 - 8) = 0;
      }
    }
    v781 = v317;
    operator delete(v317);
  }
  if (__src != v775) {
    free(__src);
  }
  return v314;
}

void sub_1CD364BD4(uint64_t a1, unsigned char *a2)
{
  unsigned int v10 = 0;
  uint64_t v11 = 0;
  BOOL v9 = 0;
  int v8 = a2;
  uint64_t v12 = a2;
  LOBYTE(v13) = 0;
  LOBYTE(v14) = 0;
  unsigned int v10 = sub_1CD31D6B8(&v9, (uint64_t)&v12);
  uint64_t v12 = v15;
  unsigned int v13 = v15;
  uint64_t v3 = v10;
  memmove(v15, &v8, 8uLL);
  uint64_t v4 = v3;
  unsigned int v5 = v9;
  uint64_t v6 = v11;
  *(void *)a1 = a1 + 32;
  *(void *)(a1 + 8) = a1 + 32;
  int v7 = v4;
  memcpy((void *)(a1 + 32), v15, 8uLL);
  *(_DWORD *)(a1 + 16) = 8;
  *(_DWORD *)(a1 + 20) = 1;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 96) = v5;
  *(void *)(a1 + 104) = v7;
  *(void *)(a1 + 112) = v6;
  *(void *)(a1 + 120) = a1 + 152;
  *(void *)(a1 + 128) = a1 + 152;
  *(void *)(a1 + 136) = 8;
  *(_DWORD *)(a1 + 144) = 0;
  *(void *)(a1 + 224) = 0;
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 216) = 0;
}

uint64_t sub_1CD364DC8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)(a2 + 8);
  if (v4 == *(void **)a2)
  {
    uint64_t v5 = *(unsigned int *)(a2 + 20);
    if (v5) {
      memmove(v13, v4, 8 * v5);
    }
    uint64_t v4 = v13;
  }
  else
  {
    *(void *)(a2 + 8) = *(void *)a2;
    LODWORD(v5) = *(_DWORD *)(a2 + 20);
  }
  int v6 = *(_DWORD *)(a2 + 16);
  int v7 = *(_DWORD *)(a2 + 24);
  *(void *)(a2 + 16) = 8;
  *(_DWORD *)(a2 + 24) = 0;
  uint64_t v8 = *(void *)(a2 + 96);
  uint64_t v9 = *(void *)(a2 + 104);
  v13[8] = v8;
  v13[9] = v9;
  uint64_t v10 = *(void *)(a2 + 112);
  v13[10] = v10;
  uint64_t v11 = (void *)(a1 + 32);
  *(void *)(a2 + 104) = 0;
  *(void *)(a2 + 112) = 0;
  *(void *)(a2 + 96) = 0;
  *(void *)a1 = a1 + 32;
  if (v4 == v13)
  {
    *(void *)(a1 + 8) = v11;
    if (v5) {
      memcpy(v11, v13, 8 * v5);
    }
  }
  else
  {
    *(void *)(a1 + 8) = v4;
  }
  *(_DWORD *)(a1 + 16) = v6;
  *(_DWORD *)(a1 + 20) = v5;
  *(_DWORD *)(a1 + 24) = v7;
  *(void *)(a1 + 96) = v8;
  *(void *)(a1 + 104) = v9;
  *(void *)(a1 + 112) = v10;
  return a1;
}

uint64_t sub_1CD364ECC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = v64;
  unsigned int v59 = v64;
  int v7 = *(const void **)(a2 + 8);
  if (v7 == *(const void **)a2)
  {
    unint64_t v60 = v64;
    uint64_t v8 = v7;
  }
  else
  {
    uint64_t v48 = *(unsigned int *)(a2 + 16);
    int v6 = malloc_type_malloc(8 * v48, 0x4065EBACuLL);
    if (!v6)
    {
      if (v48) {
        goto LABEL_94;
      }
      int v6 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v6) {
        goto LABEL_94;
      }
    }
    unint64_t v60 = v6;
    uint64_t v8 = *(const void **)a2;
    int v7 = *(const void **)(a2 + 8);
  }
  unsigned int v10 = *(_DWORD *)(a2 + 16);
  unsigned int v9 = *(_DWORD *)(a2 + 20);
  unsigned int v61 = v10;
  if (v7 == v8) {
    unsigned int v11 = v9;
  }
  else {
    unsigned int v11 = v10;
  }
  if (v11)
  {
    memmove(v6, v7, 8 * v11);
    unsigned int v9 = *(_DWORD *)(a2 + 20);
  }
  int v12 = *(_DWORD *)(a2 + 24);
  unsigned int v62 = v9;
  int v63 = v12;
  uint64_t v66 = 0;
  uint64_t v67 = 0;
  uint64_t v65 = 0;
  sub_1CD31D500((char *)&v65, *(void *)(a2 + 96), *(void *)(a2 + 104), (uint64_t)(*(void *)(a2 + 104) - *(void *)(a2 + 96)) >> 5);
  unsigned int v13 = v55;
  int v14 = *(const void **)(a3 + 8);
  if (v14 == *(const void **)a3)
  {
    uint64_t v51 = v55;
    int v15 = v14;
  }
  else
  {
    uint64_t v49 = *(unsigned int *)(a3 + 16);
    unsigned int v13 = malloc_type_malloc(8 * v49, 0x4065EBACuLL);
    if (!v13)
    {
      if (v49) {
        goto LABEL_94;
      }
      unsigned int v13 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v13) {
        goto LABEL_94;
      }
    }
    uint64_t v51 = v13;
    int v15 = *(const void **)a3;
    int v14 = *(const void **)(a3 + 8);
  }
  unsigned int v17 = *(_DWORD *)(a3 + 16);
  unsigned int v16 = *(_DWORD *)(a3 + 20);
  unsigned int v52 = v17;
  if (v14 == v15) {
    unsigned int v18 = v16;
  }
  else {
    unsigned int v18 = v17;
  }
  if (v18)
  {
    memmove(v13, v14, 8 * v18);
    unsigned int v16 = *(_DWORD *)(a3 + 20);
  }
  unsigned int v53 = v16;
  int v54 = *(_DWORD *)(a3 + 24);
  uint64_t v57 = 0;
  uint64_t v58 = 0;
  long long __p = 0;
  sub_1CD31D500((char *)&__p, *(void *)(a3 + 96), *(void *)(a3 + 104), (uint64_t)(*(void *)(a3 + 104) - *(void *)(a3 + 96)) >> 5);
  unsigned int v19 = v72;
  int v68 = v72;
  unsigned int v20 = v60;
  if (v60 == v59)
  {
    unsigned int v69 = v72;
    int v21 = v60;
  }
  else
  {
    unsigned int v50 = v61;
    unsigned int v19 = malloc_type_malloc(8 * v61, 0x4065EBACuLL);
    if (!v19)
    {
      if (v50) {
        goto LABEL_94;
      }
      unsigned int v19 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v19) {
        goto LABEL_94;
      }
    }
    unsigned int v69 = v19;
    int v21 = v59;
    unsigned int v20 = v60;
  }
  unsigned int v22 = v62;
  LODWORD(v70) = v61;
  if (v20 == v21) {
    unsigned int v23 = v62;
  }
  else {
    unsigned int v23 = v61;
  }
  if (v23)
  {
    memmove(v19, v20, 8 * v23);
    unsigned int v22 = v62;
  }
  HIDWORD(v70) = v22;
  int v71 = v63;
  uint64_t v74 = 0;
  long long v73 = 0uLL;
  sub_1CD31D500((char *)&v73, (uint64_t)v65, (uint64_t)v66, (v66 - (unsigned char *)v65) >> 5);
  uint64_t v24 = (void *)(a1 + 32);
  *(void *)a1 = a1 + 32;
  unsigned int v26 = v68;
  unsigned int v25 = v69;
  if (v69 == v68)
  {
    *(void *)(a1 + 8) = v24;
    int v27 = HIDWORD(v70);
    if (HIDWORD(v70)) {
      memmove(v24, v25, 8 * HIDWORD(v70));
    }
  }
  else
  {
    *(void *)(a1 + 8) = v69;
    unsigned int v69 = v26;
    unsigned int v25 = v26;
    int v27 = HIDWORD(v70);
  }
  int v28 = v71;
  *(_DWORD *)(a1 + 16) = v70;
  *(_DWORD *)(a1 + 20) = v27;
  *(_DWORD *)(a1 + 24) = v28;
  uint64_t v70 = 8;
  int v71 = 0;
  *(_OWORD *)(a1 + 96) = v73;
  *(void *)(a1 + 112) = v74;
  uint64_t v74 = 0;
  long long v73 = 0uLL;
  if (v25 != v26) {
    free(v25);
  }
  int v29 = (void *)(a1 + 160);
  *(void *)(a1 + 128) = a1 + 160;
  int v30 = v51;
  if (v51 != v55)
  {
    int v29 = malloc_type_malloc(8 * v52, 0x4065EBACuLL);
    if (v29 || !v52 && (int v29 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) != 0)
    {
      *(void *)(a1 + 136) = v29;
      uint64_t v31 = v55;
      int v30 = v51;
      goto LABEL_29;
    }
LABEL_94:
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  *(void *)(a1 + 136) = v29;
  uint64_t v31 = v51;
LABEL_29:
  unsigned int v32 = v53;
  *(_DWORD *)(a1 + 144) = v52;
  if (v30 == v31) {
    unsigned int v33 = v53;
  }
  else {
    unsigned int v33 = v52;
  }
  if (v33)
  {
    memmove(v29, v30, 8 * v33);
    unsigned int v32 = v53;
  }
  *(void *)(a1 + 224) = 0;
  *(_DWORD *)(a1 + 148) = v32;
  *(_DWORD *)(a1 + 152) = v54;
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 240) = 0;
  sub_1CD31D500((char *)(a1 + 224), (uint64_t)__p, (uint64_t)v57, (v57 - (unsigned char *)__p) >> 5);
  while (1)
  {
    uint64_t v35 = *(void *)(a1 + 96);
    uint64_t v34 = *(void *)(a1 + 104);
    uint64_t v36 = *(void *)(a1 + 224);
    if (v34 - v35 == *(void *)(a1 + 232) - v36)
    {
      if (v35 == v34) {
        break;
      }
      uint64_t v37 = v36 + 16;
      uint64_t v38 = v35 + 16;
      while (1)
      {
        uint64_t v39 = v38 - 16;
        if (*(void *)(v38 - 16) != *(void *)(v37 - 16)) {
          break;
        }
        int v40 = *(unsigned __int8 *)(v37 + 8);
        if (*(unsigned char *)(v38 + 8)) {
          BOOL v41 = v40 == 0;
        }
        else {
          BOOL v41 = 1;
        }
        if (v41)
        {
          if ((*(unsigned char *)(v38 + 8) == 0) == (v40 != 0)) {
            break;
          }
        }
        else if (*(void *)(v38 - 8) != *(void *)(v37 - 8) || *(void *)v38 != *(void *)v37)
        {
          break;
        }
        v37 += 32;
        v38 += 32;
        if (v39 + 32 == v34) {
          goto LABEL_55;
        }
      }
    }
    if (!*(unsigned char *)(*(void *)(v34 - 32) + 8)) {
      break;
    }
    sub_1CD365374((llvm::SmallPtrSetImplBase *)a1);
  }
LABEL_55:
  uint64_t v43 = __p;
  if (__p)
  {
    for (uint64_t i = (uint64_t)v57; (unsigned char *)i != v43; i -= 32)
    {
      if (*(unsigned char *)(i - 8)) {
        *(unsigned char *)(i - 8) = 0;
      }
    }
    uint64_t v57 = v43;
    operator delete(v43);
  }
  if (v51 != v55) {
    free(v51);
  }
  uint64_t v45 = v65;
  if (v65)
  {
    for (uint64_t j = (uint64_t)v66; (unsigned char *)j != v45; j -= 32)
    {
      if (*(unsigned char *)(j - 8)) {
        *(unsigned char *)(j - 8) = 0;
      }
    }
    uint64_t v66 = v45;
    operator delete(v45);
  }
  if (v60 != v59) {
    free(v60);
  }
  return a1;
}

void sub_1CD365374(llvm::SmallPtrSetImplBase *this)
{
  uint64_t v2 = (void **)((char *)this + 96);
  uint64_t v3 = *((void *)this + 13);
  do
  {
    uint64_t v4 = *(void *)(v3 - 32);
    if (!*(unsigned char *)(v3 - 8))
    {
      *(void *)(v3 - 24) = v4;
      *(void *)(v3 - 16) = 0;
      *(unsigned char *)(v3 - 8) = 1;
    }
    while (1)
    {
      if (v4)
      {
        uint64_t v5 = v4;
        while (!*(_DWORD *)(v5 + 80))
        {
          uint64_t v5 = *(void *)(v5 + 40);
          if (!v5)
          {
            uint64_t v5 = v4;
            break;
          }
        }
      }
      else
      {
        uint64_t v5 = 0;
      }
      uint64_t v6 = *(void *)(v3 - 24);
      uint64_t v7 = *(void *)(v3 - 16);
      if (v6 == v4)
      {
        BOOL v8 = *(unsigned char *)(v4 + 8) != 1 || v4 == 0;
        uint64_t v9 = *(unsigned int *)(v5 + 80);
        if (!v8) {
          uint64_t v9 = (v9 + 1);
        }
        if (v7 == v9) {
          break;
        }
      }
      *(void *)(v3 - 16) = v7 + 1;
      if (v6) {
        BOOL v10 = *(unsigned char *)(v6 + 8) == 1;
      }
      else {
        BOOL v10 = 0;
      }
      if (v10)
      {
        if (!v7)
        {
          unsigned int v11 = (uint64_t *)(v6 + 200);
          goto LABEL_27;
        }
        LODWORD(v7) = v7 - 1;
      }
      while (!*(_DWORD *)(v6 + 80))
        uint64_t v6 = *(void *)(v6 + 40);
      unsigned int v11 = (uint64_t *)(*(void *)(v6 + 72) + 8 * v7);
LABEL_27:
      uint64_t v12 = *v11;
      uint64_t v13 = *((void *)this + 1);
      uint64_t v14 = *((unsigned int *)this + 5);
      if (v13 != *(void *)this)
      {
        unsigned int v18 = *((_DWORD *)this + 4);
        goto LABEL_38;
      }
      if (v14)
      {
        int v15 = 0;
        uint64_t v16 = 8 * v14;
        unsigned int v17 = (void *)*((void *)this + 1);
        while (*v17 != v12)
        {
          if (*v17 == -2) {
            int v15 = v17;
          }
          ++v17;
          v16 -= 8;
          if (!v16)
          {
            if (!v15) {
              goto LABEL_35;
            }
            *int v15 = v12;
            --*((_DWORD *)this + 6);
            goto LABEL_70;
          }
        }
      }
      else
      {
LABEL_35:
        unsigned int v18 = *((_DWORD *)this + 4);
        if (v14 < v18)
        {
          *((_DWORD *)this + 5) = v14 + 1;
          *(void *)(v13 + 8 * v14) = v12;
LABEL_70:
          uint64_t v31 = v12;
          char v32 = 0;
          char v33 = 0;
          unint64_t v29 = *((void *)this + 13);
          if (v29 >= *((void *)this + 14))
          {
            int v30 = sub_1CD31D6B8(v2, (uint64_t)&v31);
          }
          else
          {
            *(void *)unint64_t v29 = v12;
            *(unsigned char *)(v29 + 8) = 0;
            int v30 = (char *)(v29 + 32);
            *(unsigned char *)(v29 + 24) = 0;
          }
          *((void *)this + 13) = v30;
          return;
        }
LABEL_38:
        if (3 * v18 <= 4 * ((int)v14 - *((_DWORD *)this + 6)))
        {
          if (v18 >= 0x40) {
            v18 *= 2;
          }
          else {
            unsigned int v18 = 128;
          }
LABEL_61:
          llvm::SmallPtrSetImplBase::Grow(this, v18);
          unsigned int v18 = *((_DWORD *)this + 4);
          uint64_t v13 = *((void *)this + 1);
          goto LABEL_40;
        }
        if (v18 - v14 < v18 >> 3) {
          goto LABEL_61;
        }
LABEL_40:
        unsigned int v19 = v18 - 1;
        unsigned int v20 = (v18 - 1) & ((v12 >> 4) ^ (v12 >> 9));
        int v21 = (void *)(v13 + 8 * v20);
        uint64_t v22 = *v21;
        if (*v21 == -1)
        {
          unsigned int v23 = 0;
LABEL_53:
          if (v23) {
            int v27 = v23;
          }
          else {
            int v27 = v21;
          }
          if (*v27 != v12)
          {
            if (*v27 == -2) {
              --*((_DWORD *)this + 6);
            }
            else {
              ++*((_DWORD *)this + 5);
            }
            *int v27 = v12;
            goto LABEL_70;
          }
        }
        else
        {
          unsigned int v23 = 0;
          int v24 = 1;
          while (v22 != v12)
          {
            if (v23) {
              BOOL v25 = 0;
            }
            else {
              BOOL v25 = v22 == -2;
            }
            if (v25) {
              unsigned int v23 = v21;
            }
            unsigned int v26 = v20 + v24++;
            unsigned int v20 = v26 & v19;
            int v21 = (void *)(v13 + 8 * (v26 & v19));
            uint64_t v22 = *v21;
            if (*v21 == -1) {
              goto LABEL_53;
            }
          }
        }
      }
    }
    uint64_t v28 = *((void *)this + 13);
    if (*(unsigned char *)(v28 - 8)) {
      *(unsigned char *)(v28 - 8) = 0;
    }
    uint64_t v3 = v28 - 32;
    *((void *)this + 13) = v28 - 32;
  }
  while (*((void *)this + 12) != v28 - 32);
}

uint64_t sub_1CD36563C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = v64;
  unsigned int v59 = v64;
  uint64_t v7 = *(const void **)(a2 + 8);
  if (v7 == *(const void **)a2)
  {
    unint64_t v60 = v64;
    BOOL v8 = v7;
  }
  else
  {
    uint64_t v48 = *(unsigned int *)(a2 + 16);
    uint64_t v6 = malloc_type_malloc(8 * v48, 0x4065EBACuLL);
    if (!v6)
    {
      if (v48) {
        goto LABEL_94;
      }
      uint64_t v6 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v6) {
        goto LABEL_94;
      }
    }
    unint64_t v60 = v6;
    BOOL v8 = *(const void **)a2;
    uint64_t v7 = *(const void **)(a2 + 8);
  }
  unsigned int v10 = *(_DWORD *)(a2 + 16);
  unsigned int v9 = *(_DWORD *)(a2 + 20);
  unsigned int v61 = v10;
  if (v7 == v8) {
    unsigned int v11 = v9;
  }
  else {
    unsigned int v11 = v10;
  }
  if (v11)
  {
    memmove(v6, v7, 8 * v11);
    unsigned int v9 = *(_DWORD *)(a2 + 20);
  }
  int v12 = *(_DWORD *)(a2 + 24);
  unsigned int v62 = v9;
  int v63 = v12;
  uint64_t v66 = 0;
  uint64_t v67 = 0;
  uint64_t v65 = 0;
  sub_1CD31D500((char *)&v65, *(void *)(a2 + 96), *(void *)(a2 + 104), (uint64_t)(*(void *)(a2 + 104) - *(void *)(a2 + 96)) >> 5);
  uint64_t v13 = v55;
  uint64_t v14 = *(const void **)(a3 + 8);
  if (v14 == *(const void **)a3)
  {
    uint64_t v51 = v55;
    int v15 = v14;
  }
  else
  {
    uint64_t v49 = *(unsigned int *)(a3 + 16);
    uint64_t v13 = malloc_type_malloc(8 * v49, 0x4065EBACuLL);
    if (!v13)
    {
      if (v49) {
        goto LABEL_94;
      }
      uint64_t v13 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v13) {
        goto LABEL_94;
      }
    }
    uint64_t v51 = v13;
    int v15 = *(const void **)a3;
    uint64_t v14 = *(const void **)(a3 + 8);
  }
  unsigned int v17 = *(_DWORD *)(a3 + 16);
  unsigned int v16 = *(_DWORD *)(a3 + 20);
  unsigned int v52 = v17;
  if (v14 == v15) {
    unsigned int v18 = v16;
  }
  else {
    unsigned int v18 = v17;
  }
  if (v18)
  {
    memmove(v13, v14, 8 * v18);
    unsigned int v16 = *(_DWORD *)(a3 + 20);
  }
  unsigned int v53 = v16;
  int v54 = *(_DWORD *)(a3 + 24);
  uint64_t v57 = 0;
  uint64_t v58 = 0;
  long long __p = 0;
  sub_1CD31D500((char *)&__p, *(void *)(a3 + 96), *(void *)(a3 + 104), (uint64_t)(*(void *)(a3 + 104) - *(void *)(a3 + 96)) >> 5);
  unsigned int v19 = v72;
  int v68 = v72;
  unsigned int v20 = v60;
  if (v60 == v59)
  {
    unsigned int v69 = v72;
    int v21 = v60;
  }
  else
  {
    unsigned int v50 = v61;
    unsigned int v19 = malloc_type_malloc(8 * v61, 0x4065EBACuLL);
    if (!v19)
    {
      if (v50) {
        goto LABEL_94;
      }
      unsigned int v19 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v19) {
        goto LABEL_94;
      }
    }
    unsigned int v69 = v19;
    int v21 = v59;
    unsigned int v20 = v60;
  }
  unsigned int v22 = v62;
  LODWORD(v70) = v61;
  if (v20 == v21) {
    unsigned int v23 = v62;
  }
  else {
    unsigned int v23 = v61;
  }
  if (v23)
  {
    memmove(v19, v20, 8 * v23);
    unsigned int v22 = v62;
  }
  HIDWORD(v70) = v22;
  int v71 = v63;
  uint64_t v74 = 0;
  long long v73 = 0uLL;
  sub_1CD31D500((char *)&v73, (uint64_t)v65, (uint64_t)v66, (v66 - (unsigned char *)v65) >> 5);
  int v24 = (void *)(a1 + 32);
  *(void *)a1 = a1 + 32;
  unsigned int v26 = v68;
  BOOL v25 = v69;
  if (v69 == v68)
  {
    *(void *)(a1 + 8) = v24;
    int v27 = HIDWORD(v70);
    if (HIDWORD(v70)) {
      memmove(v24, v25, 8 * HIDWORD(v70));
    }
  }
  else
  {
    *(void *)(a1 + 8) = v69;
    unsigned int v69 = v26;
    BOOL v25 = v26;
    int v27 = HIDWORD(v70);
  }
  int v28 = v71;
  *(_DWORD *)(a1 + 16) = v70;
  *(_DWORD *)(a1 + 20) = v27;
  *(_DWORD *)(a1 + 24) = v28;
  uint64_t v70 = 8;
  int v71 = 0;
  *(_OWORD *)(a1 + 96) = v73;
  *(void *)(a1 + 112) = v74;
  uint64_t v74 = 0;
  long long v73 = 0uLL;
  if (v25 != v26) {
    free(v25);
  }
  unint64_t v29 = (void *)(a1 + 160);
  *(void *)(a1 + 128) = a1 + 160;
  int v30 = v51;
  if (v51 != v55)
  {
    unint64_t v29 = malloc_type_malloc(8 * v52, 0x4065EBACuLL);
    if (v29 || !v52 && (unint64_t v29 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) != 0)
    {
      *(void *)(a1 + 136) = v29;
      uint64_t v31 = v55;
      int v30 = v51;
      goto LABEL_29;
    }
LABEL_94:
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  *(void *)(a1 + 136) = v29;
  uint64_t v31 = v51;
LABEL_29:
  unsigned int v32 = v53;
  *(_DWORD *)(a1 + 144) = v52;
  if (v30 == v31) {
    unsigned int v33 = v53;
  }
  else {
    unsigned int v33 = v52;
  }
  if (v33)
  {
    memmove(v29, v30, 8 * v33);
    unsigned int v32 = v53;
  }
  *(void *)(a1 + 224) = 0;
  *(_DWORD *)(a1 + 148) = v32;
  *(_DWORD *)(a1 + 152) = v54;
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 240) = 0;
  sub_1CD31D500((char *)(a1 + 224), (uint64_t)__p, (uint64_t)v57, (v57 - (unsigned char *)__p) >> 5);
  while (1)
  {
    uint64_t v35 = *(void *)(a1 + 96);
    uint64_t v34 = *(void *)(a1 + 104);
    uint64_t v36 = *(void *)(a1 + 224);
    if (v34 - v35 == *(void *)(a1 + 232) - v36)
    {
      if (v35 == v34) {
        break;
      }
      uint64_t v37 = v36 + 16;
      uint64_t v38 = v35 + 16;
      while (1)
      {
        uint64_t v39 = v38 - 16;
        if (*(void *)(v38 - 16) != *(void *)(v37 - 16)) {
          break;
        }
        int v40 = *(unsigned __int8 *)(v37 + 8);
        if (*(unsigned char *)(v38 + 8)) {
          BOOL v41 = v40 == 0;
        }
        else {
          BOOL v41 = 1;
        }
        if (v41)
        {
          if ((*(unsigned char *)(v38 + 8) == 0) == (v40 != 0)) {
            break;
          }
        }
        else if (*(void *)(v38 - 8) != *(void *)(v37 - 8) || *(void *)v38 != *(void *)v37)
        {
          break;
        }
        v37 += 32;
        v38 += 32;
        if (v39 + 32 == v34) {
          goto LABEL_55;
        }
      }
    }
    if (*(unsigned char *)(*(void *)(v34 - 32) + 8) == 1) {
      break;
    }
    sub_1CD365374((llvm::SmallPtrSetImplBase *)a1);
  }
LABEL_55:
  uint64_t v43 = __p;
  if (__p)
  {
    for (uint64_t i = (uint64_t)v57; (unsigned char *)i != v43; i -= 32)
    {
      if (*(unsigned char *)(i - 8)) {
        *(unsigned char *)(i - 8) = 0;
      }
    }
    uint64_t v57 = v43;
    operator delete(v43);
  }
  if (v51 != v55) {
    free(v51);
  }
  uint64_t v45 = v65;
  if (v65)
  {
    for (uint64_t j = (uint64_t)v66; (unsigned char *)j != v45; j -= 32)
    {
      if (*(unsigned char *)(j - 8)) {
        *(unsigned char *)(j - 8) = 0;
      }
    }
    uint64_t v66 = v45;
    operator delete(v45);
  }
  if (v60 != v59) {
    free(v60);
  }
  return a1;
}

uint64_t sub_1CD365AE8()
{
  char v3 = 0;
  uint64_t v4 = &v3;
  int v2 = 1;
  v1.n128_u64[0] = (unint64_t)"Verify VPlan H-CFG.";
  v1.n128_u64[1] = 19;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBD020E0, "vplan-verify-hcfg", &v4, &v2, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBD020E0, &dword_1CB82C000);
}

std::string *llvm::AsmLexer::ReturnError@<X0>(std::string *__str@<X2>, std::string *a2@<X0>, std::string::size_type a3@<X1>, uint64_t a4@<X8>)
{
  a2[2].__r_.__value_.__r.__words[2] = a3;
  uint64_t result = std::string::operator=(a2 + 3, __str);
  std::string::size_type v8 = a2[6].__r_.__value_.__r.__words[0] - a3;
  *(_DWORD *)a4 = 1;
  *(void *)(a4 + 8) = a3;
  *(void *)(a4 + 16) = v8;
  *(_DWORD *)(a4 + 32) = 64;
  *(void *)(a4 + 24) = 0;
  return result;
}

uint64_t llvm::AsmLexer::getNextChar(llvm::AsmLexer *this)
{
  __n128 v1 = (unsigned __int8 *)*((void *)this + 18);
  if (v1 == (unsigned __int8 *)(*((void *)this + 19) + *((void *)this + 20))) {
    return 0xFFFFFFFFLL;
  }
  *((void *)this + 18) = v1 + 1;
  return *v1;
}

uint64_t llvm::AsmLexer::peekNextChar(llvm::AsmLexer *this)
{
  __n128 v1 = (unsigned __int8 *)*((void *)this + 18);
  if (v1 == (unsigned __int8 *)(*((void *)this + 19) + *((void *)this + 20))) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *v1;
  }
}

void llvm::AsmLexer::LexHexFloatLiteral(std::string *this@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  data = (unsigned __int8 *)this[6].__r_.__value_.__l.__data_;
  int v6 = *data;
  if (v6 == 46)
  {
    uint64_t v7 = 0;
    do
    {
      std::string::size_type v8 = &data[v7 + 1];
      this[6].__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
      int v6 = *v8;
      ++v7;
    }
    while (word_1CFAC4A4C[*v8] != -1);
    data += v7;
    if (v7 != 1) {
      goto LABEL_7;
    }
  }
  if (a2)
  {
    std::string::pointer v9 = this[4].__r_.__value_.__l.__data_;
    __str.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x58uLL);
    *(_OWORD *)&__str.__r_.__value_.__r.__words[1] = xmmword_1CFB33B10;
    strcpy(__str.__r_.__value_.__l.__data_, "invalid hexadecimal floating-point constant: expected at least one significand digit");
  }
  else
  {
LABEL_7:
    if ((v6 | 0x20) == 0x70)
    {
      unsigned int v10 = data + 1;
      this[6].__r_.__value_.__r.__words[0] = (std::string::size_type)(data + 1);
      int v11 = data[1];
      if (v11 == 45 || v11 == 43)
      {
        unsigned int v10 = data + 2;
        this[6].__r_.__value_.__r.__words[0] = (std::string::size_type)(data + 2);
        int v11 = data[2];
      }
      if ((v11 - 48) <= 9)
      {
        uint64_t v12 = 0;
        uint64_t v13 = v10 + 1;
        do
        {
          this[6].__r_.__value_.__r.__words[0] = (std::string::size_type)&v13[v12];
          unsigned int v14 = v13[v12++] - 48;
        }
        while (v14 < 0xA);
        if (v12)
        {
          std::string::pointer v15 = this[4].__r_.__value_.__l.__data_;
          *(_DWORD *)a3 = 6;
          *(void *)(a3 + 8) = v15;
          *(void *)(a3 + 16) = v10 - (unsigned __int8 *)v15 + v12;
          *(_DWORD *)(a3 + 32) = 64;
          *(void *)(a3 + 24) = 0;
          return;
        }
      }
      std::string::pointer v9 = this[4].__r_.__value_.__l.__data_;
      __str.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x58uLL);
      *(_OWORD *)&__str.__r_.__value_.__r.__words[1] = xmmword_1CFB33B20;
      strcpy(__str.__r_.__value_.__l.__data_, "invalid hexadecimal floating-point constant: expected at least one exponent digit");
    }
    else
    {
      std::string::pointer v9 = this[4].__r_.__value_.__l.__data_;
      __str.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x48uLL);
      *(_OWORD *)&__str.__r_.__value_.__r.__words[1] = xmmword_1CFB29060;
      strcpy(__str.__r_.__value_.__l.__data_, "invalid hexadecimal floating-point constant: expected exponent part 'p'");
    }
  }
  this[2].__r_.__value_.__r.__words[2] = (std::string::size_type)v9;
  std::string::operator=(this + 3, &__str);
  std::string::size_type v16 = this[6].__r_.__value_.__r.__words[0] - (void)v9;
  *(_DWORD *)a3 = 1;
  *(void *)(a3 + 8) = v9;
  *(void *)(a3 + 16) = v16;
  *(_DWORD *)(a3 + 32) = 64;
  *(void *)(a3 + 24) = 0;
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
}

void llvm::AsmLexer::LexIdentifier(std::string *this@<X0>, uint64_t a2@<X8>)
{
  std::string::pointer data = this[6].__r_.__value_.__l.__data_;
  if (*(data - 1) != 46 || *data - 48 > 9) {
    goto LABEL_12;
  }
  char v3 = (unsigned __int8 *)(data + 1);
  do
  {
    this[6].__r_.__value_.__r.__words[0] = (std::string::size_type)v3;
    int v5 = *v3++;
    int v4 = v5;
  }
  while ((v5 - 48) < 0xA);
  std::string::pointer data = (std::string::pointer)(v3 - 1);
  if ((v4 & 0xFFFFFFDF) - 65 >= 0x1A)
  {
    if ((v4 - 36) <= 0x3B && ((1 << (v4 - 36)) & 0x800000008000401) != 0) {
      goto LABEL_12;
    }
    BOOL v18 = v4 == 35 && this[4].__r_.__value_.__s.__data_[10] != 0;
    if (this[4].__r_.__value_.__s.__data_[9]) {
      BOOL v19 = v4 == 64;
    }
    else {
      BOOL v19 = 0;
    }
    if (!v19 && !v18) {
      goto LABEL_7;
    }
  }
  if ((v4 | 0x20) == 0x65)
  {
LABEL_7:
    llvm::AsmLexer::LexFloatLiteral(this, a2);
    return;
  }
LABEL_12:
  int v7 = this[4].__r_.__value_.__s.__data_[9];
  int v8 = this[4].__r_.__value_.__s.__data_[10];
  for (uint64_t i = -(uint64_t)data; ; --i)
  {
    int v10 = *data;
    if ((v10 - 48) >= 0xA
      && (v10 & 0xFFFFFFDF) - 65 >= 0x1A
      && ((v10 - 36) > 0x3B || ((1 << (v10 - 36)) & 0x800000008000401) == 0))
    {
      BOOL v13 = v8 && v10 == 35;
      BOOL v14 = v13;
      BOOL v15 = v10 != 64 || v7 == 0;
      if (v15 && !v14) {
        break;
      }
    }
    this[6].__r_.__value_.__r.__words[0] = (std::string::size_type)++data;
  }
  std::string::pointer v16 = this[4].__r_.__value_.__l.__data_;
  if (data == v16 + 1 && *v16 == 46)
  {
    *(_DWORD *)a2 = 24;
    *(void *)(a2 + 8) = v16;
    *(_DWORD *)(a2 + 32) = 64;
    *(_OWORD *)(a2 + 16) = xmmword_1CD91D2E0;
  }
  else
  {
    *(_DWORD *)a2 = 2;
    *(void *)(a2 + 8) = v16;
    *(void *)(a2 + 16) = -i - (void)v16;
    *(_DWORD *)(a2 + 32) = 64;
    *(void *)(a2 + 24) = 0;
  }
}

void llvm::AsmLexer::LexDigit(std::string *this@<X0>, uint64_t a2@<X8>)
{
  int v4 = this[4].__r_.__value_.__s.__data_[13];
  if (!this[4].__r_.__value_.__s.__data_[13]) {
    goto LABEL_8;
  }
  std::string::pointer data = (unsigned __int8 *)this[6].__r_.__value_.__l.__data_;
  int v6 = data - 1;
  if (((char)*(data - 1) & 0x80000000) == 0 && (*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * *(data - 1) + 60) & 0x400) != 0)
  {
    if ((*(data - 1) & 0xFE) == 0x30) {
      unsigned int v17 = 0;
    }
    else {
      unsigned int v17 = data - 1;
    }
    if (*(data - 1) - 58 >= 0xFFFFFFF6) {
      int v6 = 0;
    }
    uint64_t v18 = *data;
    if (word_1CFAC4A4C[v18] != -1)
    {
      BOOL v19 = data + 1;
      while (1)
      {
        if (((char)v18 - 50) < 8) {
          goto LABEL_33;
        }
        if (((char)v18 - 48) >= 2) {
          break;
        }
LABEL_35:
        this[6].__r_.__value_.__r.__words[0] = (std::string::size_type)v19;
        int v20 = *v19++;
        LODWORD(v18) = v20;
        if (word_1CFAC4A4C[v20] == -1)
        {
          unsigned int v22 = v19 - 1;
          goto LABEL_54;
        }
      }
      if (!v6) {
        int v6 = v19 - 1;
      }
LABEL_33:
      if (!v17) {
        unsigned int v17 = v19 - 1;
      }
      goto LABEL_35;
    }
    unsigned int v22 = (unsigned __int8 *)this[6].__r_.__value_.__l.__data_;
LABEL_54:
    if (v18 == 46)
    {
      unint64_t v29 = v22 + 1;
      goto LABEL_120;
    }
    if (this[4].__r_.__value_.__s.__data_[12])
    {
      if ((int)v18 <= 103)
      {
        switch((int)v18)
        {
          case 'O':
          case 'Q':
          case 'T':
          case 'Y':
            goto LABEL_88;
          case 'P':
          case 'S':
          case 'U':
          case 'V':
          case 'W':
          case 'X':
            goto LABEL_99;
          case 'R':
            goto LABEL_65;
          default:
            if (v18 != 72) {
              goto LABEL_99;
            }
            goto LABEL_88;
        }
      }
      switch((int)v18)
      {
        case 'o':
        case 'q':
        case 't':
        case 'y':
          goto LABEL_88;
        case 'p':
        case 's':
        case 'u':
        case 'v':
        case 'w':
        case 'x':
          goto LABEL_99;
        case 'r':
LABEL_65:
          this[6].__r_.__value_.__r.__words[0] = (std::string::size_type)(v22 + 1);
          std::string::pointer v25 = this[4].__r_.__value_.__l.__data_;
          *(_DWORD *)a2 = 6;
          *(void *)(a2 + 8) = v25;
          *(void *)(a2 + 16) = v22 + 1 - (unsigned __int8 *)v25;
          goto LABEL_66;
        default:
          if (v18 != 104) {
            goto LABEL_99;
          }
          goto LABEL_88;
      }
    }
    if ((int)v18 > 103)
    {
      if ((int)v18 <= 112)
      {
        if (v18 != 104 && v18 != 111) {
          goto LABEL_99;
        }
      }
      else if (v18 != 113 && v18 != 121 && v18 != 116)
      {
        goto LABEL_99;
      }
    }
    else if ((int)v18 <= 80)
    {
      if (v18 != 72 && v18 != 79) {
        goto LABEL_99;
      }
    }
    else if (v18 != 81 && v18 != 84 && v18 != 89)
    {
LABEL_99:
      if (v6) {
        BOOL v30 = v6 + 1 == v22;
      }
      else {
        BOOL v30 = 0;
      }
      if ((!v30 || HIDWORD(this[4].__r_.__value_.__r.__words[2]) > 0xD || (*v6 | 0x20) != 0x64)
        && (!v17 || v17 + 1 != v22 || HIDWORD(this[4].__r_.__value_.__r.__words[2]) > 0xB || (*v17 | 0x20) != 0x62))
      {
        this[6].__r_.__value_.__r.__words[0] = (std::string::size_type)data;
        goto LABEL_4;
      }
LABEL_89:
      LODWORD(v39) = 128;
      operator new[]();
    }
LABEL_88:
    this[6].__r_.__value_.__r.__words[0] = (std::string::size_type)(v22 + 1);
    goto LABEL_89;
  }
LABEL_4:
  if (this[4].__r_.__value_.__s.__data_[16])
  {
    int v7 = data - 1;
    int v8 = data - 1;
    do
    {
      int v9 = *++v7;
      ++v8;
    }
    while ((unsigned __int16)word_1CFAC4A4C[v9] < 0x10u);
    this[6].__r_.__value_.__r.__words[0] = (std::string::size_type)v7;
    uint64_t v39 = &v8[-this[4].__r_.__value_.__r.__words[0]];
    operator new[]();
  }
LABEL_8:
  int v10 = (unsigned __int8 *)this[6].__r_.__value_.__l.__data_;
  if (this[4].__r_.__value_.__s.__data_[15])
  {
    int v11 = *(v10 - 1);
    if (v11 == 37)
    {
      if ((*v10 & 0xFE) == 0x30)
      {
        unsigned int v23 = (char *)(v10 + 1);
        do
        {
          this[6].__r_.__value_.__r.__words[0] = (std::string::size_type)v23;
          char v24 = *v23++;
        }
        while ((v24 & 0xFE) == 0x30);
      }
      operator new[]();
    }
    if (v11 == 36)
    {
      if (word_1CFAC4A4C[*v10] != -1)
      {
        uint64_t v12 = v10 + 1;
        do
        {
          this[6].__r_.__value_.__r.__words[0] = (std::string::size_type)v12;
          int v13 = *v12++;
        }
        while (word_1CFAC4A4C[v13] != -1);
      }
      operator new[]();
    }
  }
  int v14 = this[5].__r_.__value_.__s.__data_[0];
  if (this[5].__r_.__value_.__s.__data_[0] || *(v10 - 1) != 48 || (int v15 = *v10, v15 == 46))
  {
    std::string::pointer v16 = 0;
    while (1)
    {
      if ((*v10 - 48) >= 0xAu)
      {
        if (!v16) {
          std::string::pointer v16 = v10;
        }
        if (!v4) {
          goto LABEL_43;
        }
        if (word_1CFAC4A4C[*v10] == -1) {
          break;
        }
      }
      ++v10;
    }
    if ((*v10 & 0xDF) == 0x48)
    {
      this[6].__r_.__value_.__r.__words[0] = (std::string::size_type)v10;
      goto LABEL_48;
    }
LABEL_43:
    this[6].__r_.__value_.__r.__words[0] = (std::string::size_type)v16;
    if (v14)
    {
LABEL_47:
      int v10 = v16;
LABEL_48:
      uint64_t v39 = &v10[-this[4].__r_.__value_.__r.__words[0]];
      operator new[]();
    }
    int v21 = *v16;
    if (v21 == 101 || v21 == 69) {
      goto LABEL_121;
    }
    if (v21 != 46) {
      goto LABEL_47;
    }
    unint64_t v29 = v16 + 1;
LABEL_120:
    this[6].__r_.__value_.__r.__words[0] = (std::string::size_type)v29;
LABEL_121:
    llvm::AsmLexer::LexFloatLiteral(this, a2);
    return;
  }
  if (v4)
  {
    if ((v15 | 0x20) == 0x78) {
      goto LABEL_75;
    }
LABEL_118:
    LODWORD(v39) = 128;
    operator new[]();
  }
  if (*v10 > 0x61u)
  {
    if (v15 == 120) {
      goto LABEL_75;
    }
    if (v15 != 98) {
      goto LABEL_118;
    }
  }
  else if (v15 != 66)
  {
    if (v15 != 88) {
      goto LABEL_118;
    }
LABEL_75:
    uint64_t v26 = 0;
    do
    {
      int v27 = &v10[v26 + 1];
      this[6].__r_.__value_.__r.__words[0] = (std::string::size_type)v27;
      uint64_t v28 = *v27;
      ++v26;
    }
    while (word_1CFAC4A4C[v28] != -1);
    if (v28 == 46 || v28 == 112 || v28 == 80)
    {
      llvm::AsmLexer::LexHexFloatLiteral(this, v26 == 1, a2);
      return;
    }
    if (v26 != 1) {
      operator new[]();
    }
    __str.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x20uLL);
    *(_OWORD *)&__str.__r_.__value_.__r.__words[1] = xmmword_1CD96DBE0;
    strcpy(__str.__r_.__value_.__l.__data_, "invalid hexadecimal number");
    this[2].__r_.__value_.__r.__words[2] = (std::string::size_type)(v10 - 1);
    std::string::operator=(this + 3, &__str);
    uint64_t v35 = this[6].__r_.__value_.__r.__words[0] - (void)v10 + 1;
    *(_DWORD *)a2 = 1;
    *(void *)(a2 + 8) = v10 - 1;
    goto LABEL_129;
  }
  this[6].__r_.__value_.__r.__words[0] = (std::string::size_type)(v10 + 1);
  int v31 = v10[1];
  if ((v31 - 48) <= 9)
  {
    if ((v31 & 0xFE) == 0x30)
    {
      unsigned int v32 = v10 + 1;
      unsigned int v33 = (char *)(v10 + 2);
      do
      {
        this[6].__r_.__value_.__r.__words[0] = (std::string::size_type)v33;
        char v34 = *v33++;
        ++v32;
      }
      while ((v34 & 0xFE) == 0x30);
      operator new[]();
    }
    std::string::pointer v37 = this[4].__r_.__value_.__l.__data_;
    *((unsigned char *)&__str.__r_.__value_.__s + 23) = 21;
    strcpy((char *)&__str, "invalid binary number");
    this[2].__r_.__value_.__r.__words[2] = (std::string::size_type)v37;
    std::string::operator=(this + 3, &__str);
    uint64_t v35 = this[6].__r_.__value_.__r.__words[0] - (void)v37;
    *(_DWORD *)a2 = 1;
    *(void *)(a2 + 8) = v37;
LABEL_129:
    *(void *)(a2 + 16) = v35;
    *(void *)(a2 + 24) = 0;
    *(_DWORD *)(a2 + 32) = 64;
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    return;
  }
  this[6].__r_.__value_.__r.__words[0] = (std::string::size_type)v10;
  uint64_t v36 = (unsigned __int8 *)this[4].__r_.__value_.__l.__data_;
  *(_DWORD *)a2 = 4;
  *(void *)(a2 + 8) = v36;
  *(void *)(a2 + 16) = v10 - v36;
LABEL_66:
  *(_DWORD *)(a2 + 32) = 64;
  *(void *)(a2 + 24) = 0;
}

void sub_1CD366E90(char *a1, unsigned int __val)
{
  HIDWORD(v3) = __val;
  LODWORD(v3) = __val - 2;
  switch((v3 >> 1))
  {
    case 0u:
      a1[23] = 6;
      strcpy(a1, "binary");
      break;
    case 3u:
      a1[23] = 5;
      strcpy(a1, "octal");
      break;
    case 4u:
      a1[23] = 7;
      strcpy(a1, "decimal");
      break;
    case 7u:
      a1[23] = 11;
      strcpy(a1, "hexadecimal");
      break;
    default:
      std::to_string(&v5, __val);
      int v4 = std::string::insert(&v5, 0, "base-");
      *(std::string *)a1 = *v4;
      v4->__r_.__value_.__r.__words[0] = 0;
      v4->__r_.__value_.__l.__size_ = 0;
      v4->__r_.__value_.__r.__words[2] = 0;
      if (SHIBYTE(v5.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v5.__r_.__value_.__l.__data_);
      }
      break;
  }
}

uint64_t sub_1CD366FE8(uint64_t result, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4 = *((unsigned int *)a4 + 2);
  if (v4 >= 0x41)
  {
    int v6 = 0;
    int64_t v7 = (unint64_t)(v4 + 63) >> 6;
    do
    {
      if (v7-- < 1) {
        break;
      }
      unint64_t v9 = *(void *)(*a4 + 8 * v7);
      v6 += __clz(v9);
    }
    while (!v9);
    operator new[]();
  }
  uint64_t v5 = *a4;
  *(_DWORD *)uint64_t result = 4;
  *(void *)(result + 8) = a2;
  *(void *)(result + 16) = a3;
  *(_DWORD *)(result + 32) = v4;
  *(void *)(result + 24) = v5;
  return result;
}

BOOL llvm::AsmLexer::isAtStatementSeparator(llvm::AsmLexer *this, const char *a2)
{
  unint64_t v3 = *(const char **)(*((void *)this + 17) + 40);
  size_t v4 = strlen(v3);
  return strncmp(a2, v3, v4) == 0;
}

uint64_t llvm::AsmLexer::LexUntilEndOfLine(llvm::AsmLexer *this)
{
  uint64_t v2 = 0;
  uint64_t result = *((void *)this + 18);
  *((void *)this + 12) = result;
  while (1)
  {
    int v4 = *(unsigned __int8 *)(result + v2);
    BOOL v5 = v4 == 10 || v4 == 13;
    if (v5 || result + v2 == *((void *)this + 19) + *((void *)this + 20)) {
      break;
    }
    *((void *)this + 18) = result + v2++ + 1;
  }
  return result;
}

void llvm::AsmLexer::LexToken(std::string *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v77 = *MEMORY[0x1E4F143B8];
  std::string::pointer data = this[6].__r_.__value_.__l.__data_;
  std::string::size_type size = this[6].__r_.__value_.__l.__size_;
  this[4].__r_.__value_.__r.__words[0] = (std::string::size_type)data;
  if (data == (const char *)(size + this[6].__r_.__value_.__r.__words[2]))
  {
    unsigned int v6 = -1;
    goto LABEL_28;
  }
  this[6].__r_.__value_.__r.__words[0] = (std::string::size_type)(data + 1);
  unsigned int v6 = *(unsigned __int8 *)data;
  if (this[7].__r_.__value_.__s.__data_[2] || v6 != 35)
  {
LABEL_28:
    if (llvm::AsmLexer::isAtStartOfComment((llvm::AsmLexer *)this, data))
    {
      llvm::AsmLexer::LexLineComment((llvm::AsmLexer *)this, a2);
      return;
    }
    std::string::size_type v15 = this[5].__r_.__value_.__r.__words[2];
    std::string::pointer v16 = *(const char **)(v15 + 40);
    size_t v17 = strlen(v16);
    if (!strncmp(data, v16, v17))
    {
      this[6].__r_.__value_.__r.__words[0] = v17 + this[6].__r_.__value_.__r.__words[0] - 1;
      LOWORD(this[7].__r_.__value_.__l.__data_) = 257;
      size_t v19 = strlen(v16);
      *(_DWORD *)a2 = 9;
      *(void *)(a2 + 8) = data;
      *(void *)(a2 + 16) = v19;
      goto LABEL_34;
    }
    if (v6 != -1)
    {
      std::string::value_type v18 = this[7].__r_.__value_.__s.__data_[1];
      LOWORD(this[7].__r_.__value_.__l.__data_) = 0;
      switch(v6)
      {
        case 0u:
        case 9u:
        case 0x20u:
          this[7].__r_.__value_.__s.__data_[1] = v18;
          int v27 = (unsigned __int8 *)this[6].__r_.__value_.__l.__data_;
          for (int64_t i = v27 - (unsigned __int8 *)data; ; ++i)
          {
            int v29 = *v27++;
            if (v29 != 32 && v29 != 9) {
              break;
            }
            this[6].__r_.__value_.__r.__words[0] = (std::string::size_type)v27;
          }
          if (!this[4].__r_.__value_.__s.__data_[8])
          {
            *(_DWORD *)a2 = 11;
            goto LABEL_72;
          }
          (*(void (**)(std::string *))this->__r_.__value_.__l.__data_)(this);
          return;
        case 1u:
        case 2u:
        case 3u:
        case 4u:
        case 5u:
        case 6u:
        case 7u:
        case 8u:
        case 0xBu:
        case 0xCu:
        case 0xEu:
        case 0xFu:
        case 0x10u:
        case 0x11u:
        case 0x12u:
        case 0x13u:
        case 0x14u:
        case 0x15u:
        case 0x16u:
        case 0x17u:
        case 0x18u:
        case 0x19u:
        case 0x1Au:
        case 0x1Bu:
        case 0x1Cu:
        case 0x1Du:
        case 0x1Eu:
        case 0x1Fu:
        case 0x2Eu:
        case 0x3Bu:
        case 0x3Fu:
        case 0x41u:
        case 0x42u:
        case 0x43u:
        case 0x44u:
        case 0x45u:
        case 0x46u:
        case 0x47u:
        case 0x48u:
        case 0x49u:
        case 0x4Au:
        case 0x4Bu:
        case 0x4Cu:
        case 0x4Du:
        case 0x4Eu:
        case 0x4Fu:
        case 0x50u:
        case 0x51u:
        case 0x52u:
        case 0x53u:
        case 0x54u:
        case 0x55u:
        case 0x56u:
        case 0x57u:
        case 0x58u:
        case 0x59u:
        case 0x5Au:
LABEL_64:
          if (v6 <= 0x7F) {
            int v31 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v6 + 60) & 0x100;
          }
          else {
            int v31 = __maskrune(v6, 0x100uLL);
          }
          if (v31 || v6 == 46 || v6 == 95 || *(unsigned char *)(this[5].__r_.__value_.__r.__words[2] + 181) && v6 == 63) {
            goto LABEL_123;
          }
          std::string::pointer v53 = this[4].__r_.__value_.__l.__data_;
          __str.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x20uLL);
          *(_OWORD *)&__str.__r_.__value_.__r.__words[1] = xmmword_1CD96DBE0;
          strcpy(__str.__r_.__value_.__l.__data_, "invalid character in input");
          this[2].__r_.__value_.__r.__words[2] = (std::string::size_type)v53;
          std::string::operator=(this + 3, &__str);
          std::string::size_type v54 = this[6].__r_.__value_.__r.__words[0] - (void)v53;
          *(_DWORD *)a2 = 1;
          *(void *)(a2 + 8) = v53;
          *(void *)(a2 + 16) = v54;
          *(_DWORD *)(a2 + 32) = 64;
          *(void *)(a2 + 24) = 0;
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          return;
        case 0xAu:
          LOWORD(this[7].__r_.__value_.__l.__data_) = 257;
          int v26 = 9;
          goto LABEL_267;
        case 0xDu:
          LOWORD(this[7].__r_.__value_.__l.__data_) = 257;
          std::string::pointer v32 = this[6].__r_.__value_.__l.__data_;
          if (v32 != (std::string::pointer)(this[6].__r_.__value_.__l.__size_ + this[6].__r_.__value_.__r.__words[2])
            && *v32 == 10)
          {
            this[6].__r_.__value_.__r.__words[0] = (std::string::size_type)++v32;
          }
          *(_DWORD *)a2 = 9;
          int64_t i = v32 - data;
LABEL_72:
          *(void *)(a2 + 8) = data;
          *(void *)(a2 + 16) = i;
          goto LABEL_34;
        case 0x21u:
          std::string::pointer v33 = this[6].__r_.__value_.__l.__data_;
          if (*v33 == 61)
          {
            this[6].__r_.__value_.__r.__words[0] = (std::string::size_type)(v33 + 1);
            int v34 = 35;
            goto LABEL_139;
          }
          int v26 = 34;
          goto LABEL_267;
        case 0x22u:
          llvm::AsmLexer::LexQuote(this, a2);
          return;
        case 0x23u:
          if (*(unsigned char *)(v15 + 184)) {
            goto LABEL_123;
          }
          int v26 = 37;
          goto LABEL_267;
        case 0x24u:
          if (this[4].__r_.__value_.__s.__data_[15]
            && word_1CFAC4A4C[*(unsigned __int8 *)this[6].__r_.__value_.__l.__data_] != -1)
          {
            goto LABEL_32;
          }
          if (*(unsigned char *)(v15 + 182)) {
            goto LABEL_123;
          }
          int v26 = 26;
          goto LABEL_267;
        case 0x25u:
          if (this[4].__r_.__value_.__s.__data_[15] && (*this[6].__r_.__value_.__l.__data_ & 0xFE) == 0x30) {
            goto LABEL_32;
          }
          if (!*(unsigned char *)(v15 + 474)) {
            goto LABEL_266;
          }
          std::string::pointer v35 = this[6].__r_.__value_.__l.__data_;
          if (v35)
          {
            size_t v36 = strlen(this[6].__r_.__value_.__l.__data_);
            if (v36 >= 6)
            {
              if (*(_DWORD *)v35 != 1819042147 || *((_WORD *)v35 + 2) != 13873)
              {
                if (v36 < 7)
                {
                  char v38 = 0;
                  uint64_t v39 = 0;
                  uint64_t v40 = 0;
                  int v41 = 0;
                  BOOL v42 = 0;
                  char v43 = 1;
                  size_t v36 = 6;
                  BOOL v44 = 1;
                  goto LABEL_167;
                }
                if (*(_DWORD *)v35 == 1819042147 && *(_DWORD *)(v35 + 3) == 1768447852)
                {
                  uint64_t v72 = 0x800000000;
                  uint64_t v40 = 48;
                  goto LABEL_265;
                }
                BOOL v44 = 0;
                char v38 = 0;
                int v41 = 0;
                uint64_t v39 = 0;
                uint64_t v40 = 0;
LABEL_144:
                BOOL v42 = v41 != 0;
                if (!v44 && !v41 && *(_DWORD *)v35 == 1819042147 && *(_DWORD *)(v35 + 3) == 1869373292)
                {
                  uint64_t v72 = 0x800000000;
                  uint64_t v40 = 49;
                  goto LABEL_265;
                }
                BOOL v57 = v36 < 9;
                if (v36 >= 9 && !v41)
                {
                  if (*(void *)v35 == 0x685F6C6572707464 && v35[8] == 105)
                  {
                    uint64_t v72 = 0xA00000000;
                    uint64_t v40 = 50;
                    goto LABEL_265;
                  }
                  BOOL v57 = 0;
                }
                if (!v41 && !v57 && *(void *)v35 == 0x6C5F6C6572707464 && v35[8] == 111)
                {
                  uint64_t v72 = 0xA00000000;
                  uint64_t v40 = 51;
                  goto LABEL_265;
                }
                char v43 = 1;
                if (v36 >= 8 && !v41)
                {
                  if (*(void *)v35 == 0x707369645F746F67)
                  {
                    uint64_t v72 = 0x900000000;
                    uint64_t v40 = 53;
                    goto LABEL_265;
                  }
                  char v43 = 0;
                  int v41 = 0;
                  BOOL v42 = 0;
                }
LABEL_167:
                char v60 = v38 | v42;
                if ((v60 & 1) == 0)
                {
                  if (*(_DWORD *)v35 == 1601466215 && *((_WORD *)v35 + 2) == 26984)
                  {
                    uint64_t v72 = 0x700000000;
                    uint64_t v40 = 54;
                    goto LABEL_265;
                  }
                  if (*(_DWORD *)v35 == 1601466215 && *((_WORD *)v35 + 2) == 28524)
                  {
                    uint64_t v72 = 0x700000000;
                    uint64_t v40 = 55;
                    goto LABEL_265;
                  }
                }
                if ((v43 & 1) == 0)
                {
                  switch(*(void *)v35)
                  {
                    case 0x7473666F5F746F67:
                      uint64_t v72 = 0x900000000;
                      uint64_t v40 = 56;
                      goto LABEL_265;
                    case 0x656761705F746F67:
                      uint64_t v72 = 0x900000000;
                      uint64_t v40 = 57;
                      goto LABEL_265;
                    case 0x6C65727074746F67:
                      uint64_t v72 = 0x900000000;
                      uint64_t v40 = 58;
                      goto LABEL_265;
                  }
                }
                char v63 = v36 < 3 || v42;
                if ((v63 & 1) == 0 && *(_WORD *)v35 == 28519 && v35[2] == 116)
                {
                  uint64_t v72 = 0x400000000;
                  uint64_t v40 = 52;
                  goto LABEL_265;
                }
                if ((v60 & 1) == 0)
                {
                  if (*(_DWORD *)v35 == 1918857319 && *((_WORD *)v35 + 2) == 27749)
                  {
                    uint64_t v72 = 0x700000000;
                    uint64_t v40 = 59;
                    goto LABEL_265;
                  }
                  if (*(_DWORD *)v35 == 1751607656 && *((_WORD *)v35 + 2) == 29285)
                  {
                    uint64_t v72 = 0x700000000;
                    uint64_t v40 = 61;
                    goto LABEL_265;
                  }
                }
                if (!v44 && !v42 && *(_DWORD *)v35 == 1751607656 && *(_DWORD *)(v35 + 3) == 1953719656)
                {
                  uint64_t v72 = 0x800000000;
                  uint64_t v40 = 62;
                  goto LABEL_265;
                }
                char v68 = v36 < 2 || v42;
                if ((v68 & 1) == 0)
                {
                  if (*(_WORD *)v35 == 26984)
                  {
                    uint64_t v72 = 0x300000000;
                    uint64_t v40 = 60;
                    goto LABEL_265;
                  }
                  if (*(_WORD *)v35 == 28524)
                  {
                    uint64_t v72 = 0x300000000;
                    uint64_t v40 = 63;
                    goto LABEL_265;
                  }
                }
                if ((v63 & 1) == 0 && *(_WORD *)v35 == 25966 && v35[2] == 103)
                {
                  uint64_t v72 = 0x400000000;
                  uint64_t v40 = 64;
                  goto LABEL_265;
                }
                if ((v43 & 1) == 0)
                {
                  if (*(void *)v35 == 0x69685F6C65726370)
                  {
                    uint64_t v72 = 0x900000000;
                    uint64_t v40 = 65;
                    goto LABEL_265;
                  }
                  if (*(void *)v35 == 0x6F6C5F6C65726370)
                  {
                    uint64_t v72 = 0x900000000;
                    uint64_t v40 = 66;
                    goto LABEL_265;
                  }
                }
                if (v36 < 5) {
                  LOBYTE(v42) = 1;
                }
                if (!v42 && *(_DWORD *)v35 == 1735617652 && v35[4] == 100)
                {
                  uint64_t v72 = 0x600000000;
                  uint64_t v40 = 67;
                  goto LABEL_265;
                }
                if ((v60 & 1) == 0 && *(_DWORD *)v35 == 1819503732 && *((_WORD *)v35 + 2) == 28004)
                {
                  uint64_t v72 = 0x700000000;
                  uint64_t v40 = 68;
                  goto LABEL_265;
                }
                if (v43)
                {
                  if (v41)
                  {
                    uint64_t v72 = v39 & 0x700000000;
LABEL_265:
                    unint64_t v74 = v40 | v72;
                    if (v74 == 36) {
                      goto LABEL_266;
                    }
                    this[6].__r_.__value_.__r.__words[0] = (std::string::size_type)&v35[HIDWORD(v74) - 1];
                    *(_DWORD *)a2 = v74;
                    *(void *)(a2 + 8) = data;
                    *(void *)(a2 + 16) = HIDWORD(v74);
LABEL_34:
                    *(_DWORD *)(a2 + 32) = 64;
                    *(void *)(a2 + 24) = 0;
                    return;
                  }
                }
                else
                {
                  if (*(void *)v35 == 0x69685F6C65727074)
                  {
                    uint64_t v72 = 0x900000000;
                    uint64_t v40 = 69;
                    goto LABEL_265;
                  }
                  if (*(void *)v35 == 0x6F6C5F6C65727074)
                  {
                    uint64_t v72 = 0x900000000;
                    uint64_t v40 = 70;
                    goto LABEL_265;
                  }
                }
LABEL_266:
                int v26 = 36;
                goto LABEL_267;
              }
              char v38 = 0;
              uint64_t v39 = 0x700000000;
              int v41 = 1;
              uint64_t v40 = 47;
LABEL_143:
              BOOL v44 = v36 < 7;
              goto LABEL_144;
            }
          }
          else
          {
            size_t v36 = 0;
          }
          int v41 = 0;
          uint64_t v39 = 0;
          uint64_t v40 = 0;
          char v38 = 1;
          goto LABEL_143;
        case 0x26u:
          std::string::pointer v45 = this[6].__r_.__value_.__l.__data_;
          if (*v45 == 38)
          {
            this[6].__r_.__value_.__r.__words[0] = (std::string::size_type)(v45 + 1);
            int v34 = 33;
            goto LABEL_139;
          }
          int v26 = 32;
          goto LABEL_267;
        case 0x27u:
          llvm::AsmLexer::LexSingleQuote(this, a2);
          return;
        case 0x28u:
          int v26 = 17;
          goto LABEL_267;
        case 0x29u:
          int v26 = 18;
          goto LABEL_267;
        case 0x2Au:
          int v26 = 23;
          goto LABEL_267;
        case 0x2Bu:
          int v26 = 12;
          goto LABEL_267;
        case 0x2Cu:
          int v26 = 25;
          goto LABEL_267;
        case 0x2Du:
          std::string::pointer v46 = this[6].__r_.__value_.__l.__data_;
          if (*v46 == 62)
          {
            this[6].__r_.__value_.__r.__words[0] = (std::string::size_type)(v46 + 1);
            int v34 = 46;
            goto LABEL_139;
          }
          int v26 = 13;
          goto LABEL_267;
        case 0x2Fu:
          this[7].__r_.__value_.__s.__data_[1] = v18;
          llvm::AsmLexer::LexSlash(this, a2);
          return;
        case 0x30u:
        case 0x31u:
        case 0x32u:
        case 0x33u:
        case 0x34u:
        case 0x35u:
        case 0x36u:
        case 0x37u:
        case 0x38u:
        case 0x39u:
LABEL_32:
          llvm::AsmLexer::LexDigit(this, a2);
          return;
        case 0x3Au:
          int v26 = 10;
          goto LABEL_267;
        case 0x3Cu:
          std::string::pointer v47 = this[6].__r_.__value_.__l.__data_;
          int v48 = *v47;
          switch(v48)
          {
            case '>':
              this[6].__r_.__value_.__r.__words[0] = (std::string::size_type)(v47 + 1);
              int v34 = 41;
              goto LABEL_139;
            case '=':
              this[6].__r_.__value_.__r.__words[0] = (std::string::size_type)(v47 + 1);
              int v34 = 39;
              goto LABEL_139;
            case '<':
              this[6].__r_.__value_.__r.__words[0] = (std::string::size_type)(v47 + 1);
              int v34 = 40;
              goto LABEL_139;
          }
          int v26 = 38;
          goto LABEL_267;
        case 0x3Du:
          std::string::pointer v49 = this[6].__r_.__value_.__l.__data_;
          if (*v49 == 61)
          {
            this[6].__r_.__value_.__r.__words[0] = (std::string::size_type)(v49 + 1);
            int v34 = 28;
            goto LABEL_139;
          }
          int v26 = 27;
          goto LABEL_267;
        case 0x3Eu:
          std::string::pointer v50 = this[6].__r_.__value_.__l.__data_;
          int v51 = *v50;
          if (v51 == 61)
          {
            this[6].__r_.__value_.__r.__words[0] = (std::string::size_type)(v50 + 1);
            int v34 = 43;
          }
          else
          {
            if (v51 != 62)
            {
              int v26 = 42;
              goto LABEL_267;
            }
            this[6].__r_.__value_.__r.__words[0] = (std::string::size_type)(v50 + 1);
            int v34 = 44;
          }
LABEL_139:
          *(_DWORD *)a2 = v34;
          *(void *)(a2 + 8) = data;
          *(_DWORD *)(a2 + 32) = 64;
          long long v55 = xmmword_1CD91D2D0;
          goto LABEL_268;
        case 0x40u:
          if (*(unsigned char *)(v15 + 183))
          {
LABEL_123:
            llvm::AsmLexer::LexIdentifier(this, a2);
          }
          else
          {
            int v26 = 45;
LABEL_267:
            *(_DWORD *)a2 = v26;
            *(void *)(a2 + 8) = data;
            *(_DWORD *)(a2 + 32) = 64;
            long long v55 = xmmword_1CD91D2E0;
LABEL_268:
            *(_OWORD *)(a2 + 16) = v55;
          }
          return;
        case 0x5Bu:
          int v26 = 19;
          goto LABEL_267;
        case 0x5Cu:
          int v26 = 16;
          goto LABEL_267;
        case 0x5Du:
          int v26 = 20;
          goto LABEL_267;
        case 0x5Eu:
          int v26 = 31;
          goto LABEL_267;
        default:
          switch(v6)
          {
            case '{':
              int v26 = 21;
              goto LABEL_267;
            case '|':
              std::string::pointer v52 = this[6].__r_.__value_.__l.__data_;
              if (*v52 == 124)
              {
                this[6].__r_.__value_.__r.__words[0] = (std::string::size_type)(v52 + 1);
                int v34 = 30;
                goto LABEL_139;
              }
              int v26 = 29;
              break;
            case '}':
              int v26 = 22;
              goto LABEL_267;
            case '~':
              int v26 = 14;
              goto LABEL_267;
            default:
              goto LABEL_64;
          }
          goto LABEL_267;
      }
    }
    int v20 = this[7].__r_.__value_.__s.__data_[3];
    if (this[7].__r_.__value_.__s.__data_[1])
    {
      LOWORD(this[7].__r_.__value_.__l.__data_) = 0;
      if (!v20)
      {
LABEL_50:
        *(_DWORD *)a2 = 0;
        goto LABEL_51;
      }
      LOBYTE(v20) = 1;
    }
    else if (this[7].__r_.__value_.__s.__data_[3])
    {
      LOWORD(this[7].__r_.__value_.__l.__data_) = 257;
      *(_DWORD *)a2 = 9;
LABEL_51:
      *(_DWORD *)(a2 + 32) = 64;
      *(void *)(a2 + 16) = 0;
      *(void *)(a2 + 24) = 0;
      *(void *)(a2 + 8) = data;
      return;
    }
    this[7].__r_.__value_.__s.__data_[0] = v20;
    this[7].__r_.__value_.__s.__data_[1] = v20;
    goto LABEL_50;
  }
  if (!this[7].__r_.__value_.__s.__data_[1])
  {
    unsigned int v6 = 35;
    goto LABEL_28;
  }
  for (uint64_t j = 0; j != 80; j += 40)
  {
    int v8 = (char *)&__str + j;
    *((void *)v8 + 1) = 0;
    *((void *)v8 + 2) = 0;
    *((_DWORD *)v8 + 8) = 1;
    *((void *)v8 + 3) = 0;
  }
  uint64_t v9 = (*(uint64_t (**)(std::string *, std::string *, uint64_t, uint64_t))(this->__r_.__value_.__r.__words[0]
                                                                                 + 32))(this, &__str, 2, 1);
  if (this[7].__r_.__value_.__s.__data_[0]) {
    BOOL v10 = v9 == 2;
  }
  else {
    BOOL v10 = 0;
  }
  BOOL v11 = v10 && LODWORD(__str.__r_.__value_.__l.__data_) == 4;
  if (v11 && v76[0] == 3)
  {
    uint64_t v21 = 0;
    std::string::pointer v22 = this[4].__r_.__value_.__l.__data_;
    while (1)
    {
      this[6].__r_.__value_.__r.__words[0] = (std::string::size_type)&v22[v21];
      int v23 = v22[v21];
      BOOL v24 = v23 == 10 || v23 == 13;
      if (v24
        || &v22[v21] == (std::string::pointer)(this[6].__r_.__value_.__l.__size_ + this[6].__r_.__value_.__r.__words[2]))
      {
        break;
      }
      ++v21;
    }
    uint64_t v25 = this->__r_.__value_.__l.__size_;
    this[4].__r_.__value_.__s.__data_[11] = 0;
    sub_1CD45128C((uint64_t)&this->__r_.__value_.__l.__size_, v25, (unint64_t)v76);
    this[4].__r_.__value_.__s.__data_[11] = 0;
    sub_1CD45128C((uint64_t)&this->__r_.__value_.__l.__size_, this->__r_.__value_.__l.__size_, (unint64_t)&__str);
    int v12 = 0;
    *(_DWORD *)a2 = 8;
    *(void *)(a2 + 8) = v22;
    *(void *)(a2 + 16) = v21;
    *(_DWORD *)(a2 + 32) = 64;
    *(void *)(a2 + 24) = 0;
  }
  else if (*(unsigned char *)(this[5].__r_.__value_.__r.__words[2] + 65))
  {
    llvm::AsmLexer::LexLineComment((llvm::AsmLexer *)this, a2);
    int v12 = 0;
  }
  else
  {
    int v12 = 1;
  }
  for (uint64_t k = 0; k != -20; k -= 10)
  {
    if (v76[k + 8] >= 0x41u)
    {
      uint64_t v14 = *(void *)&v76[k + 6];
      if (v14) {
        MEMORY[0x1D25D9CB0](v14, 0x1000C8000313F17);
      }
    }
  }
  if (v12)
  {
    std::string::pointer data = this[4].__r_.__value_.__l.__data_;
    goto LABEL_28;
  }
}

BOOL sub_1CD367FF8(uint64_t a1, uint64_t a2)
{
  while (2)
  {
    BOOL result = 0;
    switch(*(unsigned char *)a2)
    {
      case 1:
      case 4:
        return result;
      case 2:
        uint64_t v6 = *(void *)(a2 + 16);
        if ((*(_DWORD *)(v6 + 8) & 0x1C00) == 0x800)
        {
          *(_DWORD *)(v6 + 8) |= 4u;
          BOOL v5 = (uint64_t *)(v6 + 24);
          goto LABEL_7;
        }
        return v6 == a1;
      case 3:
        BOOL v5 = (uint64_t *)(a2 + 16);
        goto LABEL_7;
      default:
        if ((sub_1CD367FF8(a1, *(void *)(a2 + 16)) & 1) == 0)
        {
          BOOL v5 = (uint64_t *)(a2 + 24);
LABEL_7:
          a2 = *v5;
          continue;
        }
        return 1;
    }
  }
}

uint64_t sub_1CD3695C8(uint64_t a1)
{
  return a1 + 40;
}

uint64_t sub_1CD3695D0(uint64_t a1)
{
  *(unsigned char *)(*(void *)(a1 + 872) + 104) = 1;
  return sub_1CD379E2C(a1);
}

void sub_1CD3695E0(uint64_t a1)
{
  *(unsigned char *)(*(void *)(a1 + 872) + 104) = 1;
  sub_1CD379E2C(a1);

  JUMPOUT(0x1D25D9CE0);
}

size_t **sub_1CD369624(uint64_t a1, unsigned __int8 *a2, size_t a3, size_t a4, size_t a5)
{
  BOOL result = sub_1CD8F49C0(a1 + 320, a2, a3);
  int v8 = *result;
  v8[1] = a4;
  v8[2] = a5;
  return result;
}

void sub_1CD369658(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v16[0] = a2;
  v16[1] = a3;
  v15[0] = a4;
  v15[1] = a5;
  BOOL v5 = (llvm::StringMapImpl *)(a1 + 808);
  llvm::StringRef::lower((llvm::StringRef *)v15, v13);
  if (v14 >= 0) {
    uint64_t v6 = (unsigned __int8 *)v13;
  }
  else {
    uint64_t v6 = (unsigned __int8 *)v13[0];
  }
  if (v14 >= 0) {
    size_t v7 = v14 & 0x7F;
  }
  else {
    size_t v7 = (size_t)v13[1];
  }
  int v8 = *(_DWORD *)sub_1CD379C2C(v5, v6, v7);
  llvm::StringRef::lower((llvm::StringRef *)v16, __p);
  if (v12 >= 0) {
    uint64_t v9 = (unsigned __int8 *)__p;
  }
  else {
    uint64_t v9 = (unsigned __int8 *)__p[0];
  }
  if (v12 >= 0) {
    size_t v10 = v12 & 0x7F;
  }
  else {
    size_t v10 = (size_t)__p[1];
  }
  *(_DWORD *)sub_1CD379C2C(v5, v9, v10) = v8;
  if (v12 < 0) {
    operator delete(__p[0]);
  }
  if (v14 < 0) {
    operator delete(v13[0]);
  }
}

uint64_t sub_1CD369720(uint64_t a1)
{
  return *(void *)(a1 + 240);
}

uint64_t sub_1CD369728(uint64_t a1)
{
  return *(void *)(a1 + 216);
}

uint64_t sub_1CD369730(uint64_t a1)
{
  return *(void *)(a1 + 224);
}

uint64_t sub_1CD369738(uint64_t a1)
{
  uint64_t result = *(unsigned int *)(a1 + 800);
  if (result == -1) {
    return *(unsigned int *)(*(void *)(a1 + 232) + 176);
  }
  return result;
}

uint64_t sub_1CD369758(uint64_t result, int a2)
{
  *(_DWORD *)(result + 800) = a2;
  return result;
}

BOOL sub_1CD369760(uint64_t a1, char a2, char a3)
{
  v65[64] = *MEMORY[0x1E4F143B8];
  *(_DWORD *)(a1 + 736) = 0;
  unint64_t v5 = a1 + 784;
  sub_1CB833A08(a1 + 776, *(void **)(a1 + 784));
  *(void *)(a1 + 776) = v5;
  *(void *)(a1 + 792) = 0;
  *(void *)(a1 + 784) = 0;
  if ((a2 & 1) == 0) {
    (*(void (**)(void, void, void))(**(void **)(a1 + 224) + 176))(*(void *)(a1 + 224), 0, *(void *)(*(void *)(a1 + 8) + 240));
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 184))(a1);
  *(unsigned char *)(a1 + 32) = 0;
  int v6 = *(_DWORD *)(a1 + 284);
  char v7 = *(unsigned char *)(a1 + 289);
  v64[0] = v65;
  v64[1] = (void *)0x400000000;
  if (*(unsigned char *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 48))(a1) + 1513))
  {
    uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1);
    uint64_t v9 = *(unsigned int *)(v8 + 120);
    if (v9) {
      unint64_t v5 = *(void *)(*(void *)(v8 + 112) + 32 * v9 - 32);
    }
    else {
      unint64_t v5 = 0;
    }
    if (!*(void *)(v5 + 8))
    {
      size_t v10 = (llvm::MCContext *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 48))(a1);
      v58[0] = "tmp";
      __int16 v60 = 259;
      uint64_t TempSymbol = llvm::MCContext::createTempSymbol(v10, (const llvm::Twine *)v58, 1);
      uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1);
      (*(void (**)(uint64_t, uint64_t, void))(*(void *)v12 + 192))(v12, TempSymbol, 0);
      *(void *)(v5 + 8) = TempSymbol;
    }
    uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 48))(a1);
    v58[0] = (char *)v5;
    sub_1CC61C590((void *)(v13 + 1520), v58);
  }
  (*(void (**)(void))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8));
  while (**(_DWORD **)(a1 + 48))
  {
    v58[0] = (char *)&v59;
    v58[1] = (char *)0x800000000;
    int v61 = -1;
    char v62 = 0;
    char v63 = v64;
    if ((*(unsigned int (**)(uint64_t, char **, void))(*(void *)a1 + 280))(a1, v58, 0))
    {
      if (!*(_DWORD *)(a1 + 24) && **(_DWORD **)(a1 + 48) == 1) {
        (*(void (**)(uint64_t))(*(void *)a1 + 184))(a1);
      }
      sub_1CD8F4AC0(a1);
      if (!*(unsigned char *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 107)) {
        (*(void (**)(uint64_t))(*(void *)a1 + 224))(a1);
      }
    }
    else
    {
      sub_1CD8F4AC0(a1);
    }
    sub_1CD381630(v58);
  }
  (*(void (**)(void))(**(void **)(a1 + 8) + 200))(*(void *)(a1 + 8));
  sub_1CD8F4AC0(a1);
  uint64_t v14 = *(void *)(a1 + 8);
  uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1);
  (*(void (**)(uint64_t, uint64_t))(*(void *)v14 + 176))(v14, v15);
  if (*(_DWORD *)(a1 + 284) != v6 || *(unsigned char *)(a1 + 289) != (v7 & 1))
  {
    uint64_t v16 = *(void *)(*(void *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 8) + 8);
    v58[0] = "unmatched .ifs or .elses";
    __int16 v60 = 259;
    (*(void (**)(uint64_t, uint64_t, char **, void, void))(*(void *)a1 + 176))(a1, v16, v58, 0, 0);
  }
  uint64_t v17 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 48))(a1);
  if (*(void *)(v17 + 1488))
  {
    uint64_t v18 = *(void *)(v17 + 1472);
    uint64_t v19 = *(unsigned int *)(v18 + 144);
    if (v19)
    {
      uint64_t v20 = 0;
      uint64_t v21 = 72 * v19;
      std::string::pointer v22 = (char *)(*(void *)(v18 + 136) + 23);
      do
      {
        if (*v22 < 0) {
          uint64_t v23 = *(void *)(v22 - 15);
        }
        else {
          uint64_t v23 = *v22;
        }
        if (v23) {
          BOOL v24 = 1;
        }
        else {
          BOOL v24 = v20 == 0;
        }
        if (!v24)
        {
          uint64_t v25 = *(void *)(*(void *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 8) + 8);
          unint64_t v5 = v5 & 0xFFFFFFFF00000000 | v20;
          v54[0] = "unassigned file number: ";
          unint64_t v55 = v5;
          __int16 v57 = 2051;
          v58[0] = (char *)v54;
          unsigned int v59 = " for .file directives";
          __int16 v60 = 770;
          (*(void (**)(uint64_t, uint64_t, char **, void, void))(*(void *)a1 + 176))(a1, v25, v58, 0, 0);
        }
        ++v20;
        v22 += 72;
        v21 -= 72;
      }
      while (v21);
    }
  }
  if ((a3 & 1) == 0)
  {
    if (*(unsigned char *)(*(void *)(a1 + 232) + 18))
    {
      uint64_t v26 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 48))(a1);
      uint64_t v27 = *(unsigned int *)(v26 + 1064);
      if (v27)
      {
        for (int64_t i = *(uint64_t **)(v26 + 1056); !*i || *i == -8; ++i)
          ;
      }
      else
      {
        int64_t i = *(uint64_t **)(v26 + 1056);
      }
      uint64_t v30 = *(void *)(v26 + 1056) + 8 * v27;
      if (i != (uint64_t *)v30)
      {
        uint64_t v31 = *i;
        do
        {
          uint64_t v32 = *(void *)(v31 + 8);
          if ((*(_DWORD *)(v32 + 8) & 1) != 0 && (*(_DWORD *)(v32 + 8) & 0x1C00) != 0x800 && *(void *)v32 <= 7uLL)
          {
            uint64_t v33 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
            if ((*(unsigned char *)v32 & 4) != 0)
            {
              size_t v36 = *(uint64_t **)(v32 - 8);
              uint64_t v37 = *v36;
              int v34 = v36 + 2;
              uint64_t v35 = v37;
            }
            else
            {
              int v34 = 0;
              uint64_t v35 = 0;
            }
            uint64_t v38 = *(void *)(*(void *)(v33 + 8) + 8);
            __int16 v57 = 1283;
            v54[0] = "assembler local symbol '";
            unint64_t v55 = (unint64_t)v34;
            uint64_t v56 = v35;
            v58[0] = (char *)v54;
            unsigned int v59 = "' not defined";
            __int16 v60 = 770;
            (*(void (**)(uint64_t, uint64_t, char **, void, void))(*(void *)a1 + 176))(a1, v38, v58, 0, 0);
          }
          do
          {
            uint64_t v39 = i[1];
            ++i;
            uint64_t v31 = v39;
            if (v39) {
              BOOL v40 = v31 == -8;
            }
            else {
              BOOL v40 = 1;
            }
          }
          while (v40);
        }
        while (i != (uint64_t *)v30);
      }
    }
    uint64_t v41 = *(unsigned int *)(a1 + 496);
    if (v41)
    {
      BOOL v42 = *(uint64_t **)(a1 + 488);
      uint64_t v43 = 56 * v41;
      do
      {
        uint64_t v44 = v42[6];
        unint64_t AssociatedFragment = *(void *)v44 & 0xFFFFFFFFFFFFFFF8;
        if (!AssociatedFragment && (*(_DWORD *)(v44 + 8) & 0x1C00) == 0x800)
        {
          *(_DWORD *)(v44 + 8) |= 4u;
          unint64_t AssociatedFragment = llvm::MCExpr::findAssociatedFragment(*(llvm::MCExpr **)(v44 + 24));
          *(void *)uint64_t v44 = *(void *)v44 & 7 | AssociatedFragment;
        }
        if (!AssociatedFragment)
        {
          long long v46 = *(_OWORD *)(v42 + 1);
          long long v47 = *(_OWORD *)(v42 + 3);
          *(_DWORD *)(a1 + 464) = *((_DWORD *)v42 + 10);
          *(_OWORD *)(a1 + 432) = v46;
          *(_OWORD *)(a1 + 448) = v47;
          uint64_t v48 = *v42;
          v58[0] = "directional label undefined";
          __int16 v60 = 259;
          (*(void (**)(uint64_t, uint64_t, char **, void, void))(*(void *)a1 + 176))(a1, v48, v58, 0, 0);
        }
        v42 += 7;
        v43 -= 56;
      }
      while (v43);
    }
    if (*(unsigned char *)(a1 + 32)) {
      goto LABEL_73;
    }
    std::string::pointer v49 = *(void **)(a1 + 224);
    uint64_t v50 = v49[2];
    if (v50)
    {
      (*(void (**)(void))(*(void *)v50 + 72))(v49[2]);
      std::string::pointer v49 = *(void **)(a1 + 224);
    }
    llvm::MCStreamer::Finish(v49, *(void *)(a1 + 136));
  }
  if (*(unsigned char *)(a1 + 32))
  {
LABEL_73:
    BOOL v51 = 1;
    goto LABEL_75;
  }
  BOOL v51 = *(unsigned char *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 48))(a1) + 1960) != 0;
LABEL_75:
  if (v64[0] != v65) {
    free(v64[0]);
  }
  return v51;
}

uint64_t sub_1CD36A054(uint64_t result, char a2)
{
  *(unsigned char *)(result + 805) = a2;
  *(unsigned char *)(result + 149) = a2;
  return result;
}

uint64_t sub_1CD36A060(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 805);
}

BOOL sub_1CD36A068(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4[0] = a2;
  v4[1] = a3;
  return sub_1CD8F4C48(a1 + 728, (uint64_t)v4);
}

uint64_t sub_1CD36A094(uint64_t a1, std::string *a2, _DWORD *a3, _DWORD *a4, void *a5, void *a6, void *a7, uint64_t *a8, uint64_t a9, uint64_t a10)
{
  v194[4] = *MEMORY[0x1E4F143B8];
  int v192 = v194;
  uint64_t v193 = 0x400000000;
  uint64_t v189 = v191;
  uint64_t v190 = 0x400000000;
  uint64_t v164 = &v166;
  long long v165 = xmmword_1CDB159A0;
  int v161 = &v163;
  long long v162 = xmmword_1CDB159A0;
  int v186 = (char *)&v188;
  uint64_t v187 = 0x400000000;
  int v183 = (char *)&v185;
  uint64_t v184 = 0x400000000;
  __base = v182;
  size_t __nel = 0x400000000;
  int v177 = v179;
  size_t v178 = 0x400000000;
  (*(void (**)(uint64_t))(*(void *)a1 + 184))(a1);
  uint64_t v148 = a4;
  if (**(_DWORD **)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 8))
  {
    unsigned int v149 = 0;
    uint64_t v24 = a10;
    unsigned int v142 = a6;
    while (1)
    {
      if ((**(_DWORD **)(a1 + 48) - 21) <= 1)
      {
        v167.__r_.__value_.__r.__words[0] = *(void *)(a1 + 136);
        (*(void (**)(uint64_t))(*(void *)a1 + 184))(a1);
        if (**(_DWORD **)(a1 + 48) == 9) {
          (*(void (**)(uint64_t))(*(void *)a1 + 184))(a1);
        }
        LODWORD(__p[0]) = 9;
        int __dst = (char *)(*(void *)(a1 + 136) - v167.__r_.__value_.__r.__words[0]);
        sub_1CD8F4680((uint64_t)&v177, (int *)__p, (uint64_t *)&v167, (uint64_t *)&__dst);
        goto LABEL_25;
      }
      v167.__r_.__value_.__r.__words[0] = (std::string::size_type)&v167.__r_.__value_.__r.__words[2];
      v167.__r_.__value_.__l.__size_ = 0x800000000;
      unsigned int v174 = -1;
      char v175 = 0;
      unsigned int v176 = &v177;
      if (((*(uint64_t (**)(uint64_t, std::string *, uint64_t))(*(void *)a1 + 280))(a1, &v167, v24) & 1) != 0
        || v175)
      {
        sub_1CD8F4AC0(a1);
        sub_1CD381630(&v167.__r_.__value_.__l.__data_);
        uint64_t v137 = 1;
        goto LABEL_301;
      }
      if (v174 != -1) {
        break;
      }
LABEL_24:
      sub_1CD381630(&v167.__r_.__value_.__l.__data_);
LABEL_25:
      if (!**(_DWORD **)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 8)) {
        goto LABEL_3;
      }
    }
    int v25 = v167.__r_.__value_.__r.__words[1];
    uint64_t v144 = *a8;
    unsigned int v145 = v174;
    if (LODWORD(v167.__r_.__value_.__r.__words[1]) == 1)
    {
LABEL_28:
      uint64_t v26 = *(unsigned __int16 **)(v144 + 48 * v145 + 32);
      a6 = v142;
      if (v26)
      {
        unsigned int v27 = -1;
        uint64_t v24 = a10;
        do
          ++v27;
        while (v26[v27]);
      }
      else
      {
        unsigned int v27 = 0;
        uint64_t v24 = a10;
      }
      sub_1CD8F4EFC((uint64_t)&__base, (uint64_t)__base + 4 * __nel, v26, &v26[v27]);
      goto LABEL_24;
    }
    uint64_t v28 = *a8 + 48 * v174;
    unsigned int v151 = (unsigned char *)(v28 + 4);
    int64_t v146 = (void *)(v28 + 40);
    uint64_t v147 = v28 + 8;
    uint64_t v29 = 2;
    uint64_t v30 = 1;
    while (1)
    {
      uint64_t v31 = *(_DWORD **)(v167.__r_.__value_.__r.__words[0] + 8 * v30);
      if ((*(unsigned int (**)(_DWORD *))(*(void *)v31 + 48))(v31))
      {
        if (((*(uint64_t (**)(_DWORD *))(*(void *)v31 + 96))(v31) & 1) == 0)
        {
          uint64_t v32 = *(void *)(a1 + 8);
          uint64_t v33 = (*(uint64_t (**)(_DWORD *))(*(void *)v31 + 56))(v31);
          if (((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v32 + 80))(v32, v33) & 1) == 0)
          {
            if (*v151 && v31[2] < *v151)
            {
              int v39 = (*(uint64_t (**)(_DWORD *))(*(void *)v31 + 56))(v31);
              if (__nel >= (unint64_t)HIDWORD(__nel)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((_DWORD *)__base + __nel) = v39;
              LODWORD(__nel) = __nel + 1;
            }
            goto LABEL_36;
          }
        }
      }
      uint64_t v34 = (*(uint64_t (**)(_DWORD *))(*(void *)v31 + 16))(v31);
      if (v35)
      {
        uint64_t v36 = v34;
        int v37 = v35;
        uint64_t v38 = (*(uint64_t (**)(_DWORD *))(*(void *)v31 + 24))(v31);
        if (v38)
        {
          uint64_t v40 = v38;
          char v41 = *((unsigned char *)v31 + 39);
          BOOL v42 = v41 < 0;
          if (v41 >= 0) {
            uint64_t v43 = (const char *)(v31 + 4);
          }
          else {
            uint64_t v43 = (const char *)*((void *)v31 + 2);
          }
          unint64_t __src = v43;
          size_t v44 = v41 & 0x7F;
          if (v42) {
            size_t v45 = *((void *)v31 + 3);
          }
          else {
            size_t v45 = v44;
          }
          if ((*(unsigned int (**)(_DWORD *))(*(void *)v31 + 40))(v31))
          {
            int v46 = (*(uint64_t (**)(_DWORD *))(*(void *)v31 + 104))(v31);
            long long v47 = "i";
            if (v46) {
              long long v47 = "r";
            }
            unint64_t __src = v47;
            size_t v45 = 1;
          }
          if (v30 == 1) {
            int v48 = (*(unsigned __int8 *)(v147 + 2) >> 4) & 1;
          }
          else {
            int v48 = 0;
          }
          char v49 = (*(uint64_t (**)(_DWORD *))(*(void *)v31 + 72))(v31);
          if (!v48)
          {
            char v55 = v49;
            if (v193 >= (unint64_t)HIDWORD(v193)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            v192[v193] = v40;
            LODWORD(v193) = v193 + 1;
            char v56 = (*(uint64_t (**)(_DWORD *))(*(void *)v31 + 96))(v31);
            if ((unint64_t)(v165 + 1) > *((void *)&v165 + 1)) {
              llvm::SmallVectorBase<unsigned long long>::grow_pod();
            }
            *((unsigned char *)v164 + v165) = v56;
            *(void *)&long long v165 = v165 + 1;
            if (!__src)
            {
              int __dst = 0;
              size_t v155 = 0;
              unint64_t v156 = 0;
LABEL_74:
              unint64_t v60 = sub_1CBFCD38C((uint64_t)&v186, (unint64_t)&__dst, 1);
              int v61 = &v186[24 * v187];
              long long v62 = *(_OWORD *)v60;
              *((void *)v61 + 2) = *(void *)(v60 + 16);
              *(_OWORD *)int v61 = v62;
              *(void *)(v60 + 8) = 0;
              *(void *)(v60 + 16) = 0;
              *(void *)unint64_t v60 = 0;
              LODWORD(v187) = v187 + 1;
              a4 = v148;
              if (SHIBYTE(v156) < 0) {
                operator delete(__dst);
              }
              if ((*(unsigned char *)(*v146 + v29) & 8) != 0) {
                int v63 = 3;
              }
              else {
                int v63 = 4;
              }
              sub_1CD8F4CA0((uint64_t)&v177, v63, v36, v37, 0, v55);
              goto LABEL_36;
            }
            if (v45 >= 0x7FFFFFFFFFFFFFF8) {
              abort();
            }
            if (v45 >= 0x17)
            {
              uint64_t v58 = (v45 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v45 | 7) != 0x17) {
                uint64_t v58 = v45 | 7;
              }
              uint64_t v59 = v58 + 1;
              p_dst = (char **)operator new(v58 + 1);
              size_t v155 = v45;
              unint64_t v156 = v59 | 0x8000000000000000;
              int __dst = (char *)p_dst;
            }
            else
            {
              HIBYTE(v156) = v45;
              p_dst = &__dst;
              if (!v45) {
                goto LABEL_73;
              }
            }
            memmove(p_dst, __src, v45);
LABEL_73:
            *((unsigned char *)p_dst + v45) = 0;
            goto LABEL_74;
          }
          char v50 = v49;
          if (v190 >= (unint64_t)HIDWORD(v190)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          v189[v190] = v40;
          LODWORD(v190) = v190 + 1;
          char v51 = (*(uint64_t (**)(_DWORD *))(*(void *)v31 + 96))(v31);
          if ((unint64_t)(v162 + 1) > *((void *)&v162 + 1)) {
            llvm::SmallVectorBase<unsigned long long>::grow_pod();
          }
          *((unsigned char *)v161 + v162) = v51;
          *(void *)&long long v162 = v162 + 1;
          __int16 v158 = 1283;
          int __dst = "=";
          unint64_t v156 = (unint64_t)__src;
          size_t v157 = v45;
          llvm::Twine::str((llvm::Twine *)&__dst, __p);
          unint64_t v52 = sub_1CBFCD38C((uint64_t)&v183, (unint64_t)__p, 1);
          std::string::pointer v53 = &v183[24 * v184];
          long long v54 = *(_OWORD *)v52;
          *((void *)v53 + 2) = *(void *)(v52 + 16);
          *(_OWORD *)std::string::pointer v53 = v54;
          *(void *)(v52 + 8) = 0;
          *(void *)(v52 + 16) = 0;
          *(void *)unint64_t v52 = 0;
          LODWORD(v184) = v184 + 1;
          if (v160 < 0) {
            operator delete(__p[0]);
          }
          ++v149;
          sub_1CD8F4CA0((uint64_t)&v177, 5, v36, v37, 0, v50);
          a4 = v148;
        }
      }
LABEL_36:
      ++v30;
      v29 += 6;
      if (v25 == v30) {
        goto LABEL_28;
      }
    }
  }
  unsigned int v149 = 0;
LABEL_3:
  *a3 = v190;
  *a4 = v193;
  unsigned int v13 = __nel;
  if (__nel >= 2)
  {
    qsort(__base, __nel, 4uLL, (int (__cdecl *)(const void *, const void *))sub_1CBC0DC50);
    unsigned int v13 = __nel;
  }
  uint64_t v14 = __base;
  uint64_t v15 = (char *)__base + 4 * v13;
  uint64_t v16 = (char *)__base;
  if (v13)
  {
    uint64_t v16 = (char *)__base - 4;
    uint64_t v17 = 4 * v13 - 4;
    while (v17)
    {
      int v18 = *((_DWORD *)v16 + 1);
      int v19 = *((_DWORD *)v16 + 2);
      v16 += 4;
      v17 -= 4;
      if (v18 == v19) {
        goto LABEL_9;
      }
    }
    uint64_t v20 = a6;
  }
  else
  {
LABEL_9:
    uint64_t v20 = a6;
    if (v16 != v15)
    {
      uint64_t v21 = v16 + 8;
      if (v16 + 8 != v15)
      {
        int v22 = *(_DWORD *)v16;
        do
        {
          int v23 = v22;
          int v22 = *(_DWORD *)v21;
          if (v23 != *(_DWORD *)v21)
          {
            *((_DWORD *)v16 + 1) = v22;
            v16 += 4;
          }
          v21 += 4;
        }
        while (v21 != v15);
      }
      uint64_t v15 = v16 + 4;
    }
  }
  LODWORD(__nel) = (unint64_t)(v15 - v14) >> 2;
  memset(&v167, 0, sizeof(v167));
  sub_1CD8F4D08((uint64_t)a7, __nel, &v167);
  if (SHIBYTE(v167.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v167.__r_.__value_.__l.__data_);
  }
  if (__nel)
  {
    uint64_t v79 = 0;
    uint64_t v80 = 0;
    uint64_t v81 = 24 * __nel;
    do
    {
      int v82 = (std::string *)(*a7 + v80);
      LODWORD(v167.__r_.__value_.__r.__words[1]) = 0;
      char v170 = 0;
      uint64_t v171 = 0;
      v167.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1F2646F30;
      std::string __str = v82;
      int v172 = 0;
      unsigned int v168 = 0;
      uint64_t v169 = 0;
      v167.__r_.__value_.__r.__words[2] = 0;
      (*(void (**)(uint64_t, std::string *, void))(*(void *)a9 + 40))(a9, &v167, *(unsigned int *)((char *)__base + v79));
      v167.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1F2646B98;
      if (v172 == 1 && v167.__r_.__value_.__r.__words[2]) {
        MEMORY[0x1D25D9CB0](v167.__r_.__value_.__r.__words[2], 0x1000C8077774924);
      }
      v80 += 24;
      v79 += 4;
    }
    while (v81 != v80);
  }
  if (*a3 | *v148)
  {
    unint64_t v64 = (*v148 + *a3);
    sub_1CD8F51D0((uint64_t)a5, v64);
    sub_1CD8F5258((uint64_t)v20, v64);
    LODWORD(v65) = *a3;
    if (*a3)
    {
      uint64_t v66 = 0;
      uint64_t v67 = 0;
      unint64_t v68 = 0;
      do
      {
        char v69 = *((unsigned char *)v161 + v68);
        uint64_t v70 = *a5 + v66;
        *(void *)uint64_t v70 = v189[v68];
        *(unsigned char *)(v70 + 8) = v69;
        std::string::operator=((std::string *)(*v20 + v67), (const std::string *)&v183[v67]);
        ++v68;
        unint64_t v65 = *a3;
        v67 += 24;
        v66 += 16;
      }
      while (v68 < v65);
    }
    if (*v148)
    {
      uint64_t v71 = 0;
      unint64_t v72 = 0;
      int v73 = v65;
      do
      {
        char v74 = *((unsigned char *)v164 + v72);
        uint64_t v75 = *a5 + 16 * (v73 + v72);
        *(void *)uint64_t v75 = v192[v72];
        *(unsigned char *)(v75 + 8) = v74;
        std::string::operator=((std::string *)(*v20 + 24 * (v73 + v72++)), (const std::string *)&v186[v71]);
        v71 += 24;
      }
      while (v72 < *v148);
    }
  }
  int __dst = 0;
  size_t v155 = 0;
  unint64_t v156 = 0;
  LODWORD(v167.__r_.__value_.__r.__words[1]) = 0;
  char v170 = 0;
  uint64_t v171 = 0;
  std::string __str = (std::string *)&__dst;
  int v172 = 0;
  v167.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1F2646F30;
  v167.__r_.__value_.__r.__words[2] = 0;
  unsigned int v168 = 0;
  uint64_t v169 = 0;
  uint64_t v76 = ***(void ***)(a1 + 240);
  uint64_t v77 = *(const void **)(v76 + 8);
  *(void *)int64_t v153 = *(void *)(v76 + 16);
  int v78 = v178;
  if (v178 >= 2)
  {
    qsort(v177, v178, 0x80uLL, (int (__cdecl *)(const void *, const void *))sub_1CD3816BC);
    int v78 = v178;
  }
  if (v78)
  {
    unsigned int v83 = 0;
    uint64_t v84 = (char *)v177;
    while (v84[20])
    {
LABEL_254:
      v84 += 128;
      if (v84 == (char *)v177 + 128 * (unint64_t)v178) {
        goto LABEL_102;
      }
    }
    int v85 = *(_DWORD *)v84;
    uint64_t v86 = *((void *)v84 + 1);
    unint64_t v87 = (v86 - v77);
    if (v86 != v77)
    {
      if (v87 <= v168 - (unsigned char *)v169)
      {
        memcpy(v169, v77, (v86 - v77));
        uint64_t v169 = (char *)v169 + v87;
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v167, (const char *)v77, (v86 - v77));
      }
    }
    switch(v85)
    {
      case 0:
        unsigned int v88 = v169;
        if ((unint64_t)(v168 - (unsigned char *)v169) > 5)
        {
          *((_WORD *)v169 + 2) = 28263;
          *unsigned int v88 = 1768710446;
          uint64_t v169 = (char *)v169 + 6;
        }
        else
        {
          llvm::raw_ostream::write((llvm::raw_ostream *)&v167, ".align", 6uLL);
        }
        if (*(unsigned char *)(*(void *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 48))(a1) + 152) + 339)) {
          goto LABEL_252;
        }
        uint64_t v89 = *((void *)v84 + 3);
        unsigned int v90 = v169;
        if (v169 >= v168)
        {
          llvm::raw_ostream::write((llvm::raw_ostream *)&v167, 32);
        }
        else
        {
          uint64_t v169 = (char *)v169 + 1;
          *unsigned int v90 = 32;
        }
        sub_1CD098D14((llvm::raw_ostream *)&v167, v89, 0, 0, 0);
        uint64_t v93 = 3;
        if (v89 >= 7) {
          uint64_t v93 = 4;
        }
        if (v89 < 4) {
          uint64_t v93 = 2;
        }
        goto LABEL_253;
      case 1:
        unsigned int v94 = v169;
        if ((unint64_t)(v168 - (unsigned char *)v169) <= 4)
        {
          unsigned int v95 = ".even";
          goto LABEL_135;
        }
        uint64_t v93 = 0;
        *((unsigned char *)v169 + 4) = 110;
        int v133 = 1702257966;
        goto LABEL_269;
      case 2:
        unsigned int v94 = v169;
        if ((unint64_t)(v168 - (unsigned char *)v169) <= 4)
        {
          unsigned int v95 = ".byte";
LABEL_135:
          size_t v96 = 5;
          goto LABEL_251;
        }
        uint64_t v93 = 0;
        *((unsigned char *)v169 + 4) = 101;
        int v133 = 1954112046;
LABEL_269:
        *unsigned int v94 = v133;
        uint64_t v108 = (char *)v169 + 5;
        goto LABEL_163;
      case 3:
        goto LABEL_124;
      case 4:
        if (!v84[120])
        {
          uint64_t v109 = v169;
          if (v169 >= v168)
          {
            llvm::raw_ostream::write((llvm::raw_ostream *)&v167, 36);
          }
          else
          {
            uint64_t v169 = (char *)v169 + 1;
            *uint64_t v109 = 36;
          }
          unsigned int v91 = v149 + 1;
          sub_1CD098D14((llvm::raw_ostream *)&v167, v149, 0, 0, 0);
          goto LABEL_128;
        }
LABEL_124:
        if ((unint64_t)(v168 - (unsigned char *)v169) > 1)
        {
          *(_WORD *)uint64_t v169 = 31524;
          uint64_t v169 = (char *)v169 + 2;
        }
        else
        {
          llvm::raw_ostream::write((llvm::raw_ostream *)&v167, "${", 2uLL);
        }
        unsigned int v91 = v149 + 1;
        sub_1CD098D14((llvm::raw_ostream *)&v167, v149, 0, 0, 0);
        int v92 = v169;
        if ((unint64_t)(v168 - (unsigned char *)v169) <= 2)
        {
          llvm::raw_ostream::write((llvm::raw_ostream *)&v167, ":P}", 3uLL);
LABEL_128:
          uint64_t v93 = 0;
          goto LABEL_129;
        }
        uint64_t v93 = 0;
        *((unsigned char *)v169 + 2) = 125;
        *int v92 = 20538;
        uint64_t v169 = (char *)v169 + 3;
LABEL_129:
        unsigned int v149 = v91;
        goto LABEL_253;
      case 5:
        if (!v84[120])
        {
          int v110 = v169;
          if (v169 >= v168)
          {
            llvm::raw_ostream::write((llvm::raw_ostream *)&v167, 36);
          }
          else
          {
            uint64_t v169 = (char *)v169 + 1;
            *int v110 = 36;
          }
          unsigned int v101 = v83 + 1;
          sub_1CD098D14((llvm::raw_ostream *)&v167, v83, 0, 0, 0);
          goto LABEL_238;
        }
        if ((unint64_t)(v168 - (unsigned char *)v169) > 1)
        {
          *(_WORD *)uint64_t v169 = 31524;
          uint64_t v169 = (char *)v169 + 2;
        }
        else
        {
          llvm::raw_ostream::write((llvm::raw_ostream *)&v167, "${", 2uLL);
        }
        unsigned int v101 = v83 + 1;
        sub_1CD098D14((llvm::raw_ostream *)&v167, v83, 0, 0, 0);
        int v102 = v169;
        if ((unint64_t)(v168 - (unsigned char *)v169) <= 2)
        {
          llvm::raw_ostream::write((llvm::raw_ostream *)&v167, ":P}", 3uLL);
LABEL_238:
          uint64_t v93 = 0;
          goto LABEL_239;
        }
        uint64_t v93 = 0;
        *((unsigned char *)v169 + 2) = 125;
        *int v102 = 20538;
        uint64_t v169 = (char *)v169 + 3;
LABEL_239:
        unsigned int v83 = v101;
        goto LABEL_253;
      case 6:
        uint64_t v93 = 0;
        uint64_t v103 = *((void *)v84 + 3);
        if (v103 > 63)
        {
          if (v103 <= 127)
          {
            if (v103 == 64)
            {
              uint64_t v104 = v169;
              if ((unint64_t)(v168 - (unsigned char *)v169) <= 9)
              {
                unsigned int v95 = "qword ptr ";
                goto LABEL_242;
              }
              uint64_t v93 = 0;
              *((_WORD *)v169 + 4) = 8306;
              unsigned int v134 = "qword ptr ";
            }
            else
            {
              if (v103 != 80) {
                goto LABEL_253;
              }
              uint64_t v104 = v169;
              if ((unint64_t)(v168 - (unsigned char *)v169) <= 9)
              {
                unsigned int v95 = "xword ptr ";
LABEL_242:
                size_t v96 = 10;
                goto LABEL_251;
              }
              uint64_t v93 = 0;
              *((_WORD *)v169 + 4) = 8306;
              unsigned int v134 = "xword ptr ";
            }
LABEL_288:
            *uint64_t v104 = *(void *)v134;
            uint64_t v108 = (char *)v169 + 10;
            goto LABEL_163;
          }
          if (v103 == 128)
          {
            unsigned int v129 = v169;
            if ((unint64_t)(v168 - (unsigned char *)v169) <= 0xB)
            {
              unsigned int v95 = "xmmword ptr ";
              goto LABEL_250;
            }
            uint64_t v93 = 0;
            *((_DWORD *)v169 + 2) = 544371824;
            int v135 = "xmmword ptr ";
          }
          else
          {
            if (v103 != 256) {
              goto LABEL_253;
            }
            unsigned int v129 = v169;
            if ((unint64_t)(v168 - (unsigned char *)v169) <= 0xB)
            {
              unsigned int v95 = "ymmword ptr ";
LABEL_250:
              size_t v96 = 12;
LABEL_251:
              llvm::raw_ostream::write((llvm::raw_ostream *)&v167, v95, v96);
LABEL_252:
              uint64_t v93 = 0;
              goto LABEL_253;
            }
            uint64_t v93 = 0;
            *((_DWORD *)v169 + 2) = 544371824;
            int v135 = "ymmword ptr ";
          }
          *unsigned int v129 = *(void *)v135;
          uint64_t v108 = (char *)v169 + 12;
          goto LABEL_163;
        }
        switch(v103)
        {
          case 8:
            uint64_t v130 = v169;
            if ((unint64_t)(v168 - (unsigned char *)v169) <= 8)
            {
              unsigned int v95 = "byte ptr ";
LABEL_247:
              size_t v96 = 9;
              goto LABEL_251;
            }
            uint64_t v93 = 0;
            *((unsigned char *)v169 + 8) = 32;
            unsigned int v136 = "byte ptr ";
            break;
          case 16:
            uint64_t v130 = v169;
            if ((unint64_t)(v168 - (unsigned char *)v169) <= 8)
            {
              unsigned int v95 = "word ptr ";
              goto LABEL_247;
            }
            uint64_t v93 = 0;
            *((unsigned char *)v169 + 8) = 32;
            unsigned int v136 = "word ptr ";
            break;
          case 32:
            uint64_t v104 = v169;
            if ((unint64_t)(v168 - (unsigned char *)v169) <= 9)
            {
              unsigned int v95 = "dword ptr ";
              goto LABEL_242;
            }
            uint64_t v93 = 0;
            *((_WORD *)v169 + 4) = 8306;
            unsigned int v134 = "dword ptr ";
            goto LABEL_288;
          default:
            goto LABEL_253;
        }
        void *v130 = *(void *)v136;
        uint64_t v108 = (char *)v169 + 9;
        goto LABEL_163;
      case 7:
        uint64_t v97 = *(void *)(*(void *)(a1 + 216) + 152);
        int v98 = *(const void **)(v97 + 104);
        size_t v99 = *(void *)(v97 + 112);
        uint64_t v100 = (char *)v169;
        if (v99 <= v168 - (unsigned char *)v169)
        {
          if (v99)
          {
            memcpy(v169, v98, v99);
            uint64_t v100 = (char *)v169 + v99;
            uint64_t v169 = (char *)v169 + v99;
          }
        }
        else
        {
          llvm::raw_ostream::write((llvm::raw_ostream *)&v167, (const char *)v98, v99);
          uint64_t v100 = (char *)v169;
        }
        unsigned int v95 = (const char *)*((void *)v84 + 4);
        unint64_t v107 = *((void *)v84 + 5);
        if (v107 > v168 - v100)
        {
          size_t v96 = *((void *)v84 + 5);
          goto LABEL_251;
        }
        if (!v107) {
          goto LABEL_252;
        }
        memcpy(v100, v95, *((void *)v84 + 5));
        uint64_t v93 = 0;
        uint64_t v108 = (char *)v169 + v107;
        goto LABEL_163;
      case 8:
        if ((unint64_t)(v168 - (unsigned char *)v169) <= 1)
        {
          unsigned int v95 = "\n\t";
          size_t v96 = 2;
          goto LABEL_251;
        }
        uint64_t v93 = 0;
        *(_WORD *)uint64_t v169 = 2314;
        uint64_t v108 = (char *)v169 + 2;
        goto LABEL_163;
      case 9:
        uint64_t v77 = (const void *)(v86 + *((unsigned int *)v84 + 4));
        goto LABEL_254;
      case 10:
        if (v84[48])
        {
          if (v168 == v169)
          {
            llvm::raw_ostream::write((llvm::raw_ostream *)&v167, "[", 1uLL);
          }
          else
          {
            *(unsigned char *)uint64_t v169 = 91;
            uint64_t v169 = (char *)v169 + 1;
          }
        }
        unint64_t v105 = *((void *)v84 + 9);
        if (v105)
        {
          uint64_t v106 = (const void *)*((void *)v84 + 8);
          if (v105 <= v168 - (unsigned char *)v169)
          {
            memcpy(v169, v106, *((void *)v84 + 9));
            uint64_t v169 = (char *)v169 + v105;
          }
          else
          {
            llvm::raw_ostream::write((llvm::raw_ostream *)&v167, (const char *)v106, *((void *)v84 + 9));
          }
        }
        if (*((void *)v84 + 11))
        {
          uint64_t v111 = *((void *)v84 + 9);
          if (v111) {
            size_t v112 = 3;
          }
          else {
            size_t v112 = 0;
          }
          int v113 = v169;
          if (v112 <= v168 - (unsigned char *)v169)
          {
            if (v111)
            {
              *((unsigned char *)v169 + 2) = 32;
              *int v113 = 11040;
              int v113 = (char *)v169 + 3;
              uint64_t v169 = (char *)v169 + 3;
            }
          }
          else
          {
            if (v111) {
              unsigned int v114 = " + ";
            }
            else {
              unsigned int v114 = "";
            }
            llvm::raw_ostream::write((llvm::raw_ostream *)&v167, v114, v112);
            int v113 = v169;
          }
          int v115 = (const void *)*((void *)v84 + 10);
          unint64_t v116 = *((void *)v84 + 11);
          if (v116 <= v168 - (unsigned char *)v113)
          {
            if (v116)
            {
              memcpy(v113, v115, *((void *)v84 + 11));
              uint64_t v169 = (char *)v169 + v116;
            }
          }
          else
          {
            llvm::raw_ostream::write((llvm::raw_ostream *)&v167, (const char *)v115, *((void *)v84 + 11));
          }
        }
        if (*((_DWORD *)v84 + 28) >= 2u)
        {
          unsigned int v117 = v169;
          if ((unint64_t)(v168 - (unsigned char *)v169) > 4)
          {
            *((unsigned char *)v169 + 4) = 36;
            *unsigned int v117 = 606087712;
            uint64_t v169 = (char *)v169 + 5;
          }
          else
          {
            llvm::raw_ostream::write((llvm::raw_ostream *)&v167, " * $$", 5uLL);
          }
          sub_1CD098D14((llvm::raw_ostream *)&v167, *((unsigned int *)v84 + 28), 0, 0, 0);
        }
        if (!*((void *)v84 + 13)) {
          goto LABEL_208;
        }
        if (*((void *)v84 + 9) || *((void *)v84 + 11))
        {
          unsigned int v118 = v169;
          if ((unint64_t)(v168 - (unsigned char *)v169) > 2)
          {
            *((unsigned char *)v169 + 2) = 32;
            *unsigned int v118 = 11040;
            uint64_t v169 = (char *)v169 + 3;
          }
          else
          {
            llvm::raw_ostream::write((llvm::raw_ostream *)&v167, " + ", 3uLL);
          }
        }
        uint64_t v120 = (const void *)*((void *)v84 + 12);
        size_t v119 = *((void *)v84 + 13);
        int64_t v121 = (char *)v177 + 128 * (unint64_t)v178;
        if (v84 == v121) {
          goto LABEL_202;
        }
        unsigned int v122 = v84;
        do
        {
          if (*((const void **)v122 + 1) == v120
            && v119 == *((_DWORD *)v122 + 4)
            && (*(_DWORD *)v122 - 3) < 2)
          {
            if (*(_DWORD *)v122 == 3)
            {
              if ((unint64_t)(v168 - (unsigned char *)v169) > 1)
              {
                *(_WORD *)uint64_t v169 = 31524;
                uint64_t v169 = (char *)v169 + 2;
              }
              else
              {
                llvm::raw_ostream::write((llvm::raw_ostream *)&v167, "${", 2uLL);
              }
              sub_1CD098D14((llvm::raw_ostream *)&v167, v149, 0, 0, 0);
              uint64_t v131 = v169;
              if ((unint64_t)(v168 - (unsigned char *)v169) > 2)
              {
                *((unsigned char *)v169 + 2) = 125;
                *uint64_t v131 = 20538;
                uint64_t v169 = (char *)v169 + 3;
              }
              else
              {
                llvm::raw_ostream::write((llvm::raw_ostream *)&v167, ":P}", 3uLL);
              }
              ++v149;
              v122[20] = 1;
            }
            else
            {
              unsigned int v132 = v169;
              if (v169 >= v168)
              {
                llvm::raw_ostream::write((llvm::raw_ostream *)&v167, 36);
              }
              else
              {
                uint64_t v169 = (char *)v169 + 1;
                unsigned char *v132 = 36;
              }
              sub_1CD098D14((llvm::raw_ostream *)&v167, v149, 0, 0, 0);
              v122[20] = 1;
              ++v149;
            }
            goto LABEL_208;
          }
          v122 += 128;
        }
        while (v122 != v121);
LABEL_202:
        signed int v123 = v169;
        if ((unint64_t)(v168 - (unsigned char *)v169) > 6)
        {
          *(_DWORD *)((char *)v169 + 3) = 544499059;
          *signed int v123 = 1936090735;
          uint64_t v124 = (char *)v169 + 7;
          uint64_t v169 = (char *)v169 + 7;
        }
        else
        {
          llvm::raw_ostream::write((llvm::raw_ostream *)&v167, "offset ", 7uLL);
          uint64_t v124 = (char *)v169;
        }
        if (v119 <= v168 - v124)
        {
          if (v119)
          {
            memcpy(v124, v120, v119);
            uint64_t v169 = (char *)v169 + v119;
          }
        }
        else
        {
          llvm::raw_ostream::write((llvm::raw_ostream *)&v167, (const char *)v120, v119);
        }
LABEL_208:
        uint64_t v125 = *((void *)v84 + 9);
        if (!*((void *)v84 + 7))
        {
          if (v125) {
            goto LABEL_221;
          }
          if (*((void *)v84 + 11)) {
            goto LABEL_221;
          }
          uint64_t v127 = *((void *)v84 + 13);
          if (v127) {
            goto LABEL_221;
          }
          goto LABEL_212;
        }
        int v126 = " + $$";
        if (!v125 && !*((void *)v84 + 11))
        {
          uint64_t v127 = *((void *)v84 + 13);
LABEL_212:
          if (v127) {
            int v126 = " + $$";
          }
          else {
            int v126 = "$$";
          }
        }
        size_t v128 = strlen(v126);
        if (v128 <= v168 - (unsigned char *)v169)
        {
          if (v128)
          {
            memcpy(v169, v126, v128);
            uint64_t v169 = (char *)v169 + v128;
          }
        }
        else
        {
          llvm::raw_ostream::write((llvm::raw_ostream *)&v167, v126, v128);
        }
        llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v167, *((void *)v84 + 7));
LABEL_221:
        if (!v84[48]) {
          goto LABEL_252;
        }
        if (v168 != v169)
        {
          uint64_t v93 = 0;
          *(unsigned char *)uint64_t v169 = 93;
          uint64_t v108 = (char *)v169 + 1;
LABEL_163:
          uint64_t v169 = v108;
LABEL_253:
          uint64_t v77 = (const void *)(v86 + *((unsigned int *)v84 + 4) + v93);
          goto LABEL_254;
        }
        unsigned int v95 = "]";
        size_t v96 = 1;
        goto LABEL_251;
      default:
        goto LABEL_252;
    }
  }
LABEL_102:
  if (v77 != *(const void **)v153)
  {
    if (*(void *)v153 - (void)v77 <= (unint64_t)(v168 - (unsigned char *)v169))
    {
      memcpy(v169, v77, *(void *)v153 - (void)v77);
      uint64_t v169 = (char *)v169 + *(void *)v153 - (void)v77;
    }
    else
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v167, (const char *)v77, *(void *)v153 - (void)v77);
    }
  }
  std::string::operator=(a2, __str);
  v167.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1F2646B98;
  if (v172 == 1 && v167.__r_.__value_.__r.__words[2]) {
    MEMORY[0x1D25D9CB0](v167.__r_.__value_.__r.__words[2], 0x1000C8077774924);
  }
  if (SHIBYTE(v156) < 0) {
    operator delete(__dst);
  }
  uint64_t v137 = 0;
LABEL_301:
  if (v177 != v179) {
    free(v177);
  }
  if (__base != v182) {
    free(__base);
  }
  sub_1CC076978((void **)&v183);
  sub_1CC076978((void **)&v186);
  if (v161 != &v163) {
    free(v161);
  }
  if (v164 != &v166) {
    free(v164);
  }
  if (v189 != (void *)v191) {
    free(v189);
  }
  if (v192 != v194) {
    free(v192);
  }
  return v137;
}

uint64_t sub_1CD36BAC8(uint64_t a1, char *a2, llvm::Twine *a3, unint64_t a4, unint64_t a5)
{
  sub_1CD8F4AC0(a1);
  v11[0] = a4;
  v11[1] = a5;
  llvm::SourceMgr::PrintMessage(*(llvm **)(a1 + 240), a2, 3, a3, v11, 1, 0, 0, 1u);
  return sub_1CD38170C(a1);
}

uint64_t sub_1CD36BB4C(uint64_t a1, char *a2, llvm::Twine *a3, uint64_t a4, uint64_t a5)
{
  sub_1CB906B78((uint64_t)v13, (uint64_t *)(*(void *)(a1 + 8) + 80));
  char v10 = v13[0];
  int v23 = (void **)v22;
  sub_1CB8338B8(&v23);
  if (v21 < 0) {
    operator delete(__p);
  }
  if (v19 < 0) {
    operator delete(v18);
  }
  if (v17 < 0) {
    operator delete(v16);
  }
  if (v15 < 0)
  {
    operator delete(v14);
    if ((v10 & 8) != 0) {
      return 0;
    }
  }
  else if ((v10 & 8) != 0)
  {
    return 0;
  }
  sub_1CB906B78((uint64_t)v13, (uint64_t *)(*(void *)(a1 + 8) + 80));
  char v12 = v13[0];
  int v23 = (void **)v22;
  sub_1CB8338B8(&v23);
  if (v21 < 0) {
    operator delete(__p);
  }
  if (v19 < 0) {
    operator delete(v18);
  }
  if (v17 < 0) {
    operator delete(v16);
  }
  if (v15 < 0)
  {
    operator delete(v14);
    if ((v12 & 4) == 0) {
      goto LABEL_19;
    }
  }
  else if ((v12 & 4) == 0)
  {
LABEL_19:
    v13[0] = a4;
    v13[1] = a5;
    llvm::SourceMgr::PrintMessage(*(llvm **)(a1 + 240), a2, 1, a3, v13, 1, 0, 0, 1u);
    sub_1CD38170C(a1);
    return 0;
  }
  return llvm::MCAsmParser::Error(a1, (uint64_t)a2, (uint64_t)a3, a4, a5);
}

uint64_t sub_1CD36BCF0(uint64_t a1, char *a2, llvm::Twine *a3, unint64_t a4, unint64_t a5)
{
  *(unsigned char *)(a1 + 32) = 1;
  v7[0] = a4;
  v7[1] = a5;
  llvm::SourceMgr::PrintMessage(*(llvm **)(a1 + 240), a2, 0, a3, v7, 1, 0, 0, 1u);
  sub_1CD38170C(a1);
  return 1;
}

uint64_t sub_1CD36BD58(uint64_t a1)
{
  uint64_t v2 = a1 + 40;
  if (**(_DWORD **)(a1 + 48) == 1)
  {
    uint64_t v3 = *(void *)(a1 + 104);
    __int16 v22 = 260;
    uint64_t v20 = a1 + 112;
    llvm::MCAsmParser::Error(a1, v3, (uint64_t)&v20, 0, 0);
  }
  if (**(_DWORD **)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 8) == 9
    && *(void *)(*(void *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 8) + 16)
    && **(unsigned char **)(*(void *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 8) + 8) != 10
    && **(unsigned char **)(*(void *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 8) + 8) != 13
    && *(unsigned char *)(*(void *)(a1 + 232) + 466))
  {
    uint64_t v4 = *(void *)(a1 + 224);
    uint64_t v5 = *(void *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 8);
    uint64_t v7 = *(void *)(v5 + 8);
    uint64_t v6 = *(void *)(v5 + 16);
    __int16 v22 = 261;
    uint64_t v20 = v7;
    uint64_t v21 = v6;
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v4 + 136))(v4, &v20);
  }
  while (1)
  {
    uint64_t result = sub_1CD8F38F8(v2);
    if (*(_DWORD *)result != 7) {
      break;
    }
    if (*(unsigned char *)(*(void *)(a1 + 232) + 466))
    {
      uint64_t v9 = *(void *)(a1 + 224);
      uint64_t v10 = *(void *)(result + 8);
      uint64_t v11 = *(void *)(result + 16);
      __int16 v22 = 261;
      uint64_t v20 = v10;
      uint64_t v21 = v11;
      (*(void (**)(uint64_t, uint64_t *))(*(void *)v9 + 136))(v9, &v20);
    }
  }
  if (!*(_DWORD *)result)
  {
    char v12 = *(uint64_t **)(a1 + 240);
    uint64_t v13 = *v12;
    uint64_t v14 = *v12 + 24 * (*(_DWORD *)(a1 + 280) - 1);
    uint64_t v15 = *(void *)(v14 + 16);
    if (v15)
    {
      int BufferContainingLoc = llvm::SourceMgr::FindBufferContainingLoc(*(uint64_t **)(a1 + 240), *(void *)(v14 + 16));
      *(_DWORD *)(a1 + 280) = BufferContainingLoc;
      uint64_t v17 = *(void *)(v13 + 24 * (BufferContainingLoc - 1));
      uint64_t v18 = *(void *)(v17 + 8);
      uint64_t v19 = *(void *)(v17 + 16) - v18;
      *(void *)(a1 + 192) = v18;
      *(void *)(a1 + 200) = v19;
      *(void *)(a1 + 184) = v15;
      *(void *)(a1 + 136) = 0;
      *(unsigned char *)(a1 + 211) = 1;
      return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 184))(a1);
    }
  }
  return result;
}

uint64_t sub_1CD36C014(_DWORD **a1, void *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  int v4 = *a1[6];
  if ((v4 - 2) < 2)
  {
    uint64_t v7 = *(void *)((*((uint64_t (**)(_DWORD **))*a1 + 5))(a1) + 8);
    if (*(_DWORD *)v7 == 2)
    {
      uint64_t v8 = *(void *)(v7 + 8);
      unint64_t v9 = *(void *)(v7 + 16);
    }
    else
    {
      uint64_t v8 = *(void *)(v7 + 8);
      unint64_t v11 = *(void *)(v7 + 16);
      unint64_t v12 = v11 - 1;
      unint64_t v13 = v11 != 0;
      if (v11) {
        ++v8;
      }
      if (v13 > v12) {
        unint64_t v12 = v11 != 0;
      }
      if (v11 < v12) {
        unint64_t v12 = v11;
      }
      unint64_t v9 = v12 - v13;
    }
    *a2 = v8;
    a2[1] = v9;
    (*((void (**)(_DWORD **))*a1 + 23))(a1);
    return 0;
  }
  else if (v4 == 45 || v4 == 26)
  {
    uint64_t v6 = *(void *)((*((uint64_t (**)(_DWORD **))*a1 + 5))(a1) + 96);
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    uint64_t v10 = 1;
    unsigned int v20 = 1;
    uint64_t v19 = 0;
    llvm::AsmLexer::peekTokens((uint64_t)(a1 + 5), (uint64_t)&v16, 1, 0);
    if (v16 == 4 || v16 == 2)
    {
      if (v6 + 1 == v17)
      {
        sub_1CD8F38F8((uint64_t)(a1 + 5));
        uint64_t v15 = *(void *)(*(void *)((*((uint64_t (**)(_DWORD **))*a1 + 5))(a1) + 8) + 16) + 1;
        *a2 = v6;
        a2[1] = v15;
        (*((void (**)(_DWORD **))*a1 + 23))(a1);
        uint64_t v10 = 0;
      }
      else
      {
        uint64_t v10 = 1;
      }
    }
    if (v20 >= 0x41 && v19) {
      MEMORY[0x1D25D9CB0](v19, 0x1000C8000313F17);
    }
  }
  else
  {
    return 1;
  }
  return v10;
}

uint64_t sub_1CD36C254(_DWORD **a1)
{
  uint64_t v2 = (uint64_t)(a1 + 5);
  uint64_t v3 = *(void *)(*(void *)((*((uint64_t (**)(_DWORD **))*a1 + 5))(a1) + 8) + 8);
  while (1)
  {
    int v4 = *a1[6];
    if (!v4 || v4 == 9) {
      break;
    }
    sub_1CD8F38F8(v2);
  }
  (*((void (**)(_DWORD **))*a1 + 5))(a1);
  return v3;
}

uint64_t sub_1CD36C304(llvm::MCAsmParser *a1, std::string *a2)
{
  int v4 = **(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)a1 + 40))(a1) + 8);
  v21[0] = "expected string";
  __int16 v22 = 259;
  llvm::MCAsmParser::check(a1, v4 != 3, (const llvm::Twine *)v21);
  if (v4 != 3) {
    return 1;
  }
  MEMORY[0x1D25D9630](a2, "");
  uint64_t v6 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)a1 + 40))(a1);
  unint64_t v7 = *(void *)(*(void *)(v6 + 8) + 16);
  unint64_t v8 = v7 != 0;
  if (v7) {
    uint64_t v9 = *(void *)(*(void *)(v6 + 8) + 8) + 1;
  }
  else {
    uint64_t v9 = *(void *)(*(void *)(v6 + 8) + 8);
  }
  if (v8 <= v7 - 1) {
    unint64_t v10 = v7 - 1;
  }
  else {
    unint64_t v10 = v7 != 0;
  }
  if (v7 < v10) {
    unint64_t v10 = *(void *)(*(void *)(v6 + 8) + 16);
  }
  unint64_t v11 = v10 - v8;
  if (v10 == v8)
  {
LABEL_46:
    (*(void (**)(llvm::MCAsmParser *))(*(void *)a1 + 184))(a1);
    return 0;
  }
  unsigned int v12 = 0;
  while (1)
  {
    unsigned int v13 = *(unsigned __int8 *)(v9 + v12);
    if (v13 != 92) {
      goto LABEL_45;
    }
    unsigned int v14 = v12 + 1;
    if (v12 + 1 == v11)
    {
      unsigned int v20 = "unexpected backslash at end of string";
      goto LABEL_49;
    }
    unsigned int v13 = *(unsigned __int8 *)(v9 + v14);
    if ((v13 | 0x20) == 0x78)
    {
      unint64_t v15 = v12 + 2;
      if (v11 <= v15 || (int v16 = (unsigned __int16)word_1CFAC4A4C[*(unsigned __int8 *)(v9 + v15)], v16 == 0xFFFF))
      {
        unsigned int v20 = "invalid hexadecimal escape sequence";
        goto LABEL_49;
      }
      LOBYTE(v13) = 0;
      do
      {
        unsigned int v12 = v15;
        LOBYTE(v13) = v16 + 16 * v13;
        unint64_t v15 = (v15 + 1);
        if (v11 <= v15) {
          break;
        }
        int v16 = (unsigned __int16)word_1CFAC4A4C[*(unsigned __int8 *)(v9 + v15)];
      }
      while (v16 != 0xFFFF);
      goto LABEL_45;
    }
    if ((v13 & 0xF8) != 0x30) {
      break;
    }
    v13 -= 48;
    unsigned int v17 = v12 + 2;
    if (v12 + 2 == v11) {
      goto LABEL_44;
    }
    int v18 = *(unsigned __int8 *)(v9 + v17);
    if ((v18 & 0xF8) != 0x30) {
      goto LABEL_44;
    }
    unsigned int v13 = v18 + 8 * v13 - 48;
    v12 += 3;
    if (v12 == v11)
    {
      unsigned int v14 = v17;
LABEL_44:
      unsigned int v12 = v14;
      goto LABEL_45;
    }
    int v19 = *(unsigned __int8 *)(v9 + v12);
    unsigned int v14 = v17;
    if ((v19 & 0xF8) != 0x30) {
      goto LABEL_44;
    }
    unsigned int v13 = v19 + 8 * v13 - 48;
    if (v13 > 0xFF)
    {
      unsigned int v20 = "invalid octal escape sequence (out of range)";
      goto LABEL_49;
    }
LABEL_45:
    std::string::push_back(a2, v13);
    if (++v12 == v11) {
      goto LABEL_46;
    }
  }
  if ((char)v13 <= 101)
  {
    if ((char)v13 != 34 && (char)v13 != 92)
    {
      if ((char)v13 != 98) {
        goto LABEL_50;
      }
      LOBYTE(v13) = 8;
    }
    goto LABEL_44;
  }
  if ((char)v13 <= 113)
  {
    if ((char)v13 == 102)
    {
      LOBYTE(v13) = 12;
    }
    else
    {
      if ((char)v13 != 110) {
        goto LABEL_50;
      }
      LOBYTE(v13) = 10;
    }
    goto LABEL_44;
  }
  if ((char)v13 == 114)
  {
    LOBYTE(v13) = 13;
    goto LABEL_44;
  }
  if ((char)v13 == 116)
  {
    LOBYTE(v13) = 9;
    goto LABEL_44;
  }
LABEL_50:
  unsigned int v20 = "invalid escape sequence (unrecognized character)";
LABEL_49:
  v21[0] = v20;
  __int16 v22 = 259;
  return llvm::MCAsmParser::TokError((uint64_t)a1, (uint64_t)v21, 0, 0);
}

BOOL sub_1CD36C60C(int *a1, uint64_t a2)
{
  uint64_t v4 = 0;
  uint64_t v5 = *(void *)(*(void *)((*(uint64_t (**)(int *))(*(void *)a1 + 40))(a1) + 8) + 8);
  while (1)
  {
    uint64_t v6 = *(unsigned __int8 *)(v5 + v4);
    if (v6 > 0x3E) {
      goto LABEL_6;
    }
    if (v6 == 33)
    {
      ++v4;
      goto LABEL_6;
    }
    if (((1 << v6) & 0x4000000000002401) != 0) {
      break;
    }
LABEL_6:
    ++v4;
  }
  if (v6 == 62)
  {
    sub_1CD37E0E4((uint64_t)a1, v5 + v4 + 1, a1[70]);
    (*(void (**)(int *))(*(void *)a1 + 184))(a1);
    memset(&v12, 0, sizeof(v12));
    unint64_t v7 = v4 - 1;
    if (v4 != 1)
    {
      uint64_t v8 = 0;
      uint64_t v9 = v5 + 1;
      do
      {
        if (*(unsigned char *)(v9 + v8) == 33) {
          uint64_t v10 = v8 + 1;
        }
        else {
          uint64_t v10 = v8;
        }
        std::string::push_back(&v12, *(unsigned char *)(v9 + v10));
        uint64_t v8 = v10 + 1;
      }
      while (v10 + 1 < v7);
    }
    if (*(char *)(a2 + 23) < 0) {
      operator delete(*(void **)a2);
    }
    *(std::string *)a2 = v12;
  }
  return v6 != 62;
}

uint64_t sub_1CD36C75C(uint64_t result)
{
  uint64_t v1 = result;
  for (i = result + 40; ; uint64_t result = sub_1CD8F38F8(i))
  {
    int v3 = **(_DWORD **)(v1 + 48);
    if (!v3) {
      break;
    }
    if (v3 == 9)
    {
      return sub_1CD8F38F8(i);
    }
  }
  return result;
}

uint64_t sub_1CD36C7C0(_DWORD **a1, unint64_t *a2, uint64_t a3)
{
  *a2 = 0;
  uint64_t v6 = 1;
  if (((*(uint64_t (**)(_DWORD *))(*(void *)a1[1] + 24))(a1[1]) & 1) != 0
    || (sub_1CD3817A0((uint64_t)a1, 1u, a2, a3) & 1) != 0)
  {
    return v6;
  }
  if (*a1[6] == 45)
  {
    (*((void (**)(_DWORD **))*a1 + 23))(a1);
    if (*a1[6] == 2)
    {
      uint64_t v7 = *(void *)((*((uint64_t (**)(_DWORD **))*a1 + 5))(a1) + 8);
      if (*(_DWORD *)v7 == 2)
      {
        uint64_t v8 = *(void *)(v7 + 8);
        uint64_t v9 = *(void *)(v7 + 16);
      }
      else
      {
        uint64_t v12 = v7 + 8;
        uint64_t v10 = *(void *)(v7 + 8);
        unint64_t v11 = *(void *)(v12 + 8);
        unint64_t v13 = v11 != 0;
        if (v11) {
          uint64_t v8 = v10 + 1;
        }
        else {
          uint64_t v8 = v10;
        }
        if (v13 <= v11 - 1) {
          unint64_t v14 = v11 - 1;
        }
        else {
          unint64_t v14 = v11 != 0;
        }
        if (v11 < v14) {
          unint64_t v14 = v11;
        }
        uint64_t v9 = v14 - v13;
      }
      uint64_t VariantKindForName = llvm::MCSymbolRefExpr::getVariantKindForName(v8, v9);
      if (VariantKindForName == 1)
      {
        uint64_t v24 = *(void *)((*((uint64_t (**)(_DWORD **))*a1 + 5))(a1) + 8);
        if (*(_DWORD *)v24 == 2)
        {
          uint64_t v25 = *(void *)(v24 + 8);
          unint64_t v26 = *(void *)(v24 + 16);
        }
        else
        {
          uint64_t v25 = *(void *)(v24 + 8);
          unint64_t v30 = *(void *)(v24 + 16);
          unint64_t v31 = v30 - 1;
          unint64_t v32 = v30 != 0;
          if (v30) {
            ++v25;
          }
          if (v32 > v31) {
            unint64_t v31 = v30 != 0;
          }
          if (v30 < v31) {
            unint64_t v31 = v30;
          }
          unint64_t v26 = v31 - v32;
        }
        __int16 v43 = 1283;
        uint64_t v40 = "invalid variant '";
        uint64_t v41 = v25;
        unint64_t v42 = v26;
        uint64_t v33 = "'";
      }
      else
      {
        uint64_t v16 = sub_1CD3819F4((uint64_t)a1, *a2, VariantKindForName);
        if (v16)
        {
          *a2 = v16;
          (*((void (**)(_DWORD **))*a1 + 23))(a1);
          goto LABEL_19;
        }
        uint64_t v27 = *(void *)((*((uint64_t (**)(_DWORD **))*a1 + 5))(a1) + 8);
        if (*(_DWORD *)v27 == 2)
        {
          uint64_t v28 = *(void *)(v27 + 8);
          unint64_t v29 = *(void *)(v27 + 16);
        }
        else
        {
          uint64_t v28 = *(void *)(v27 + 8);
          unint64_t v34 = *(void *)(v27 + 16);
          unint64_t v35 = v34 - 1;
          unint64_t v36 = v34 != 0;
          if (v34) {
            ++v28;
          }
          if (v36 > v35) {
            unint64_t v35 = v34 != 0;
          }
          if (v34 < v35) {
            unint64_t v35 = v34;
          }
          unint64_t v29 = v35 - v36;
        }
        __int16 v43 = 1283;
        uint64_t v40 = "invalid modifier '";
        uint64_t v41 = v28;
        unint64_t v42 = v29;
        uint64_t v33 = "' (no symbols present)";
      }
      v44[0] = &v40;
      v44[2] = v33;
      __int16 v23 = 770;
    }
    else
    {
      v44[0] = "unexpected symbol modifier following '@'";
      __int16 v23 = 259;
    }
    __int16 v45 = v23;
    return llvm::MCAsmParser::TokError((uint64_t)a1, (uint64_t)v44, 0, 0);
  }
LABEL_19:
  v44[0] = 0;
  if (llvm::MCExpr::evaluateAsAbsolute(*a2, v44, 0, 0, 0, 0))
  {
    uint64_t v17 = v44[0];
    uint64_t v18 = (*((uint64_t (**)(_DWORD **))*a1 + 6))(a1);
    uint64_t v19 = v18;
    *(void *)(v18 + 272) += 24;
    uint64_t v20 = *(void *)(v18 + 192);
    if (((v20 + 7) & 0xFFFFFFFFFFFFFFF8) - v20 + 24 > *(void *)(v18 + 200) - v20)
    {
      unsigned int v37 = *(_DWORD *)(v18 + 216) >> 7;
      if (v37 >= 0x1E) {
        LOBYTE(v37) = 30;
      }
      uint64_t v38 = 4096 << v37;
      unint64_t v21 = (unint64_t)operator new(4096 << v37, (std::align_val_t)8uLL);
      unsigned int v39 = *(_DWORD *)(v19 + 216);
      if (v39 >= *(_DWORD *)(v19 + 220)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(v19 + 208) + 8 * v39) = v21;
      ++*(_DWORD *)(v19 + 216);
      *(void *)(v19 + 200) = v21 + v38;
    }
    else
    {
      unint64_t v21 = (v20 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    *(void *)(v19 + 192) = v21 + 24;
    *(unsigned char *)unint64_t v21 = 1;
    *(_DWORD *)(v21 + 1) = *(unsigned __int8 *)(v21 + 4) << 24;
    *(void *)(v21 + 8) = 0;
    *(void *)(v21 + 16) = v17;
    *a2 = v21;
  }
  return 0;
}

uint64_t sub_1CD36CBBC(unsigned int **a1, unint64_t *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v174 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = (*((uint64_t (**)(unsigned int **))*a1 + 5))(a1);
  uint64_t v9 = *a1[6];
  uint64_t v10 = *(void *)(v8 + 96);
  uint64_t result = 1;
  switch((int)v9)
  {
    case 1:
      return result;
    case 2:
    case 3:
    case 23:
    case 26:
    case 45:
      long long v171 = 0uLL;
      if (!(*((unsigned int (**)(unsigned int **, long long *))*a1 + 24))(a1, &v171)
        || **(_DWORD **)((*((uint64_t (**)(unsigned int **))*a1 + 5))(a1) + 8) != 26
        && **(_DWORD **)((*((uint64_t (**)(unsigned int **))*a1 + 5))(a1) + 8) != 23)
      {
        uint64_t v164 = a2;
        if (*((unsigned char *)a1[29] + 429))
        {
          if (*a1[6] != 17)
          {
LABEL_17:
            uint64_t v19 = 0;
            uint64_t v20 = 0;
            unint64_t v21 = 0;
            __int16 v22 = 0;
            goto LABEL_18;
          }
          (*((void (**)(unsigned int **))*a1 + 23))(a1);
          long long __p = 0;
          size_t v166 = 0;
          (*((void (**)(unsigned int **, void **))*a1 + 24))(a1, &__p);
          *(void *)int v172 = "expected ')'";
          *(_WORD *)&v172[32] = 259;
          if (llvm::MCAsmParser::parseToken((llvm::MCAsmParser *)a1, 18, (llvm::Twine *)v172)) {
            return 1;
          }
        }
        else
        {
          if (v9 != 3)
          {
            v172[0] = 64;
            unint64_t v94 = llvm::StringRef::find((uint64_t *)&v171, v172, 1uLL, 0);
            if (v94 == -1)
            {
              uint64_t v20 = 0;
              unint64_t v21 = 0;
              uint64_t v19 = (void *)*((void *)&v171 + 1);
              __int16 v22 = (void *)v171;
            }
            else
            {
              __int16 v22 = (void *)v171;
              if (*((void *)&v171 + 1) >= v94) {
                uint64_t v19 = (void *)v94;
              }
              else {
                uint64_t v19 = (void *)*((void *)&v171 + 1);
              }
              if (*((void *)&v171 + 1) >= v94 + 1) {
                unint64_t v95 = v94 + 1;
              }
              else {
                unint64_t v95 = *((void *)&v171 + 1);
              }
              unint64_t v21 = (void *)(v171 + v95);
              uint64_t v20 = *((void *)&v171 + 1) - v95;
            }
LABEL_18:
            *a3 = v171 + *((void *)&v171 + 1);
            *(_OWORD *)__s1 = v171;
            size_t v23 = *((void *)&v171 + 1);
            if (!*((void *)&v171 + 1))
            {
              uint64_t v105 = *(void *)((*((uint64_t (**)(unsigned int **))*a1 + 5))(a1) + 96);
              uint64_t v125 = "expected a symbol reference";
              goto LABEL_146;
            }
            char v160 = a3;
            uint64_t v161 = v10;
            if (v20)
            {
              int VariantKindForName = llvm::MCSymbolRefExpr::getVariantKindForName((uint64_t)v21, v20);
              if (VariantKindForName != 1)
              {
                int v162 = VariantKindForName;
                __s1[0] = v22;
                __s1[1] = v19;
                size_t v23 = (size_t)v19;
                goto LABEL_91;
              }
              uint64_t v25 = a1[29];
              if (!*((unsigned char *)v25 + 180) || *((unsigned char *)v25 + 429))
              {
                __int16 v169 = 1283;
                long long __p = "invalid variant '";
                std::string v167 = v21;
                uint64_t v168 = v20;
                *(void *)int v172 = &__p;
                *(void *)&v172[16] = "'";
                *(_WORD *)&v172[32] = 770;
                uint64_t v126 = (uint64_t)a1;
                uint64_t v105 = (uint64_t)v21;
                return llvm::MCAsmParser::Error(v126, v105, (uint64_t)v172, 0, 0);
              }
            }
            int v162 = 0;
LABEL_91:
            uint64_t v82 = (*((uint64_t (**)(unsigned int **))*a1 + 6))(a1);
            p_p = __s1[0];
            uint64_t v163 = *(unsigned int *)(v82 + 1152);
            if (!v163) {
              goto LABEL_123;
            }
            int v84 = 0;
            if (v23)
            {
              size_t v85 = v23;
              uint64_t v86 = (unsigned __int8 *)__s1[0];
              do
              {
                int v87 = *v86++;
                int v84 = 33 * v84 + v87;
                --v85;
              }
              while (v85);
            }
            uint64_t v88 = *(void *)(v82 + 1144);
            uint64_t v89 = *(unsigned int *)(v82 + 1164);
            int v90 = 1;
            int v91 = v84;
            while (1)
            {
              uint64_t v92 = v91 & (v163 - 1);
              uint64_t v93 = *(void **)(v88 + 8 * v92);
              if (v93 != (void *)-8)
              {
                if (!v93) {
                  goto LABEL_123;
                }
                if (*(_DWORD *)(v88 + 8 * v163 + 8 + 4 * v92) == v84
                  && v23 == *v93
                  && (!v23 || !memcmp(p_p, (char *)v93 + v89, v23)))
                {
                  break;
                }
              }
              int v91 = v90 + v92;
              ++v90;
            }
            if (v92 == -1
              || (int)v92 == v163
              || (uint64_t Symbol = *(void *)(*(void *)(v88 + 8 * (int)v92) + 8)) == 0)
            {
LABEL_123:
              int v115 = (llvm::MCContext *)(*((uint64_t (**)(unsigned int **))*a1 + 6))(a1);
              unint64_t v116 = a1[29];
              int v117 = *((unsigned __int8 *)v116 + 80);
              if (*((unsigned char *)v116 + 80))
              {
                llvm::StringRef::upper((llvm::StringRef *)__s1, &__p);
                if (SHIBYTE(v167) >= 0) {
                  p_p = &__p;
                }
                else {
                  p_p = __p;
                }
                if (SHIBYTE(v167) >= 0) {
                  size_t v23 = HIBYTE(v167) & 0x7F;
                }
                else {
                  size_t v23 = v166;
                }
              }
              *(_WORD *)&v172[32] = 261;
              *(void *)int v172 = p_p;
              *(void *)&v172[8] = v23;
              uint64_t Symbol = llvm::MCContext::getOrCreateSymbol(v115, (unsigned __int8 ***)v172);
              if (v117 && SHIBYTE(v167) < 0) {
                operator delete(__p);
              }
            }
            if ((*(_DWORD *)(Symbol + 8) & 0x1C00) == 0x800)
            {
              unsigned int v118 = *(unsigned __int8 **)(Symbol + 24);
              int v119 = *v118;
              if (v119 == 4)
              {
                if ((*(uint64_t (**)(unsigned __int8 *))(*((void *)v118 - 1) + 48))(v118 - 8))
                {
                  if (v162)
                  {
                    uint64_t v105 = *v160;
                    uint64_t v125 = "unexpected modifier on variable reference";
                    goto LABEL_146;
                  }
                  unsigned int v118 = *(unsigned __int8 **)(Symbol + 24);
                  goto LABEL_140;
                }
              }
              else if (!v162 && v119 == 1)
              {
LABEL_140:
                uint64_t result = 0;
                *uint64_t v164 = (unint64_t)v118;
                return result;
              }
            }
            uint64_t v120 = (*((uint64_t (**)(unsigned int **))*a1 + 6))(a1);
            uint64_t v121 = v120;
            *(void *)(v120 + 272) += 24;
            uint64_t v122 = *(void *)(v120 + 192);
            if (((v122 + 7) & 0xFFFFFFFFFFFFFFF8) - v122 + 24 > *(void *)(v120 + 200) - v122)
            {
              unsigned int v127 = *(_DWORD *)(v120 + 216) >> 7;
              if (v127 >= 0x1E) {
                LOBYTE(v127) = 30;
              }
              uint64_t v128 = 4096 << v127;
              unint64_t v123 = (unint64_t)operator new(4096 << v127, (std::align_val_t)8uLL);
              unsigned int v129 = *(_DWORD *)(v121 + 216);
              if (v129 >= *(_DWORD *)(v121 + 220)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *(void *)(*(void *)(v121 + 208) + 8 * v129) = v123;
              ++*(_DWORD *)(v121 + 216);
              *(void *)(v121 + 200) = v123 + v128;
            }
            else
            {
              unint64_t v123 = (v122 + 7) & 0xFFFFFFFFFFFFFFF8;
            }
            uint64_t result = 0;
            *(void *)(v121 + 192) = v123 + 24;
            int v124 = v162 | (*(unsigned __int8 *)(*(void *)(v121 + 152) + 18) << 16);
            *(unsigned char *)unint64_t v123 = 2;
            *(_DWORD *)(v123 + 1) = v124 | (*(unsigned __int8 *)(v123 + 4) << 24);
            *(void *)(v123 + 8) = v161;
            *(void *)(v123 + 16) = Symbol;
            *uint64_t v164 = v123;
            return result;
          }
          if (*a1[6] != 45) {
            goto LABEL_17;
          }
          (*((void (**)(unsigned int **))*a1 + 23))(a1);
          uint64_t v29 = *(void *)((*((uint64_t (**)(unsigned int **))*a1 + 5))(a1) + 96);
          long long __p = 0;
          size_t v166 = 0;
          if ((*((unsigned int (**)(unsigned int **, void **))*a1 + 24))(a1, &__p))
          {
            *(void *)int v172 = "expected symbol variant after '@'";
            *(_WORD *)&v172[32] = 259;
            uint64_t v126 = (uint64_t)a1;
            uint64_t v105 = v29;
            return llvm::MCAsmParser::Error(v126, v105, (uint64_t)v172, 0, 0);
          }
        }
        uint64_t v19 = (void *)*((void *)&v171 + 1);
        __int16 v22 = (void *)v171;
        unint64_t v21 = __p;
        uint64_t v20 = v166;
        goto LABEL_18;
      }
      if ((**(_DWORD **)((*((uint64_t (**)(unsigned int **))*a1 + 5))(a1) + 8) != 26
         || !*((unsigned char *)a1[29] + 32))
        && (**(_DWORD **)((*((uint64_t (**)(unsigned int **))*a1 + 5))(a1) + 8) != 23
         || !*((unsigned char *)a1[29] + 34)))
      {
        *(void *)int v172 = "invalid token in expression";
        *(_WORD *)&v172[32] = 259;
        uint64_t v126 = (uint64_t)a1;
        uint64_t v105 = v10;
        return llvm::MCAsmParser::Error(v126, v105, (uint64_t)v172, 0, 0);
      }
      (*((void (**)(unsigned int **))*a1 + 23))(a1);
      uint64_t v12 = (llvm::MCContext *)a1[27];
      *(void *)int v172 = "tmp";
      *(_WORD *)&v172[32] = 259;
      uint64_t TempSymbol = llvm::MCContext::createTempSymbol(v12, (const llvm::Twine *)v172, 1);
      (*(void (**)(unsigned int *, uint64_t, void))(*(void *)a1[28] + 192))(a1[28], TempSymbol, 0);
      uint64_t v14 = (*((uint64_t (**)(unsigned int **))*a1 + 6))(a1);
      uint64_t v15 = v14;
      *(void *)(v14 + 272) += 24;
      uint64_t v16 = *(void *)(v14 + 192);
      if (((v16 + 7) & 0xFFFFFFFFFFFFFFF8) - v16 + 24 > *(void *)(v14 + 200) - v16)
      {
        unsigned int v130 = *(_DWORD *)(v14 + 216) >> 7;
        if (v130 >= 0x1E) {
          LOBYTE(v130) = 30;
        }
        uint64_t v131 = 4096 << v130;
        unint64_t v17 = (unint64_t)operator new(4096 << v130, (std::align_val_t)8uLL);
        unsigned int v132 = *(_DWORD *)(v15 + 216);
        if (v132 >= *(_DWORD *)(v15 + 220)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v15 + 208) + 8 * v132) = v17;
        ++*(_DWORD *)(v15 + 216);
        *(void *)(v15 + 200) = v17 + v131;
      }
      else
      {
        unint64_t v17 = (v16 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      uint64_t result = 0;
      *(void *)(v15 + 192) = v17 + 24;
      int v18 = *(unsigned __int8 *)(*(void *)(v15 + 152) + 18) << 16;
      *(unsigned char *)unint64_t v17 = 2;
      *(_DWORD *)(v17 + 1) = v18 | (*(unsigned __int8 *)(v17 + 4) << 24);
      *(void *)(v17 + 8) = 0;
      *(void *)(v17 + 16) = TempSymbol;
      *a2 = v17;
      *a3 = v10;
      return result;
    case 4:
      uint64_t v44 = *(void *)(*(void *)((*((uint64_t (**)(unsigned int **))*a1 + 5))(a1) + 8) + 8);
      uint64_t v45 = *(void *)((*((uint64_t (**)(unsigned int **))*a1 + 5))(a1) + 8);
      int v48 = *(uint64_t **)(v45 + 24);
      int v46 = (uint64_t *)(v45 + 24);
      long long v47 = v48;
      if (*((_DWORD *)v46 + 2) >= 0x41u) {
        int v46 = v47;
      }
      uint64_t v49 = *v46;
      uint64_t v50 = (*((uint64_t (**)(unsigned int **))*a1 + 6))(a1);
      uint64_t v51 = v50;
      *(void *)(v50 + 272) += 24;
      uint64_t v52 = *(void *)(v50 + 192);
      if (((v52 + 7) & 0xFFFFFFFFFFFFFFF8) - v52 + 24 > *(void *)(v50 + 200) - v52)
      {
        uint64_t v133 = v44;
        unsigned int v134 = *(_DWORD *)(v50 + 216) >> 7;
        if (v134 >= 0x1E) {
          LOBYTE(v134) = 30;
        }
        uint64_t v135 = 4096 << v134;
        unint64_t v53 = (unint64_t)operator new(4096 << v134, (std::align_val_t)8uLL);
        unsigned int v136 = *(_DWORD *)(v51 + 216);
        if (v136 >= *(_DWORD *)(v51 + 220)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v51 + 208) + 8 * v136) = v53;
        ++*(_DWORD *)(v51 + 216);
        *(void *)(v51 + 200) = v53 + v135;
        uint64_t v44 = v133;
      }
      else
      {
        unint64_t v53 = (v52 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(v51 + 192) = v53 + 24;
      *(unsigned char *)unint64_t v53 = 1;
      *(_DWORD *)(v53 + 1) = *(unsigned __int8 *)(v53 + 4) << 24;
      *(void *)(v53 + 8) = 0;
      *(void *)(v53 + 16) = v49;
      *a2 = v53;
      *a3 = *((void *)a1[6] + 1) + *((void *)a1[6] + 2);
      (*((void (**)(unsigned int **))*a1 + 23))(a1);
      if (*a1[6] != 2) {
        return 0;
      }
      uint64_t v54 = *(void *)((*((uint64_t (**)(unsigned int **))*a1 + 5))(a1) + 8);
      char v56 = *(unsigned char **)(v54 + 8);
      unint64_t v55 = *(void *)(v54 + 16);
      *(void *)&long long v171 = v56;
      *((void *)&v171 + 1) = v55;
      v172[0] = 64;
      unint64_t v57 = llvm::StringRef::find((uint64_t *)&v171, v172, 1uLL, 0);
      if (v57 == -1
        || (v55 >= v57 + 1 ? (unint64_t v58 = v57 + 1) : (unint64_t v58 = v55), v55 >= v57 ? (v59 = v57) : (v59 = v55), v55 <= v57))
      {
        int v63 = 0;
      }
      else
      {
        uint64_t v60 = v44;
        uint64_t v61 = v55 - v58;
        long long v62 = &v56[v58];
        int v63 = llvm::MCSymbolRefExpr::getVariantKindForName((uint64_t)&v56[v58], v55 - v58);
        if (v63 == 1)
        {
          __int16 v169 = 1283;
          long long __p = "invalid variant '";
          std::string v167 = v62;
          uint64_t v168 = v61;
          *(void *)int v172 = &__p;
          *(void *)&v172[16] = "'";
          __int16 v27 = 770;
          goto LABEL_26;
        }
        unint64_t v55 = v59;
        uint64_t v44 = v60;
      }
      if (v55 != 1) {
        return 0;
      }
      int v96 = *v56;
      if ((v96 | 4) != 0x66) {
        return 0;
      }
      int v97 = v63;
      uint64_t v98 = v44;
      uint64_t DirectionalLocalSymbol = llvm::MCContext::getDirectionalLocalSymbol((llvm::MCContext *)a1[27], v49, v96 == 98);
      uint64_t v100 = (*((uint64_t (**)(unsigned int **))*a1 + 6))(a1);
      uint64_t v101 = v100;
      *(void *)(v100 + 272) += 24;
      uint64_t v102 = *(void *)(v100 + 192);
      if (((v102 + 7) & 0xFFFFFFFFFFFFFFF8) - v102 + 24 > *(void *)(v100 + 200) - v102)
      {
        size_t v155 = v56;
        unsigned int v156 = *(_DWORD *)(v100 + 216) >> 7;
        if (v156 >= 0x1E) {
          LOBYTE(v156) = 30;
        }
        uint64_t v157 = 4096 << v156;
        unint64_t v103 = (unint64_t)operator new(4096 << v156, (std::align_val_t)8uLL);
        unsigned int v158 = *(_DWORD *)(v101 + 216);
        if (v158 >= *(_DWORD *)(v101 + 220)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v101 + 208) + 8 * v158) = v103;
        ++*(_DWORD *)(v101 + 216);
        *(void *)(v101 + 200) = v103 + v157;
        char v56 = v155;
      }
      else
      {
        unint64_t v103 = (v102 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(v101 + 192) = v103 + 24;
      int v104 = v97 | (*(unsigned __int8 *)(*(void *)(v101 + 152) + 18) << 16);
      *(unsigned char *)unint64_t v103 = 2;
      *(_DWORD *)(v103 + 1) = v104 | (*(unsigned __int8 *)(v103 + 4) << 24);
      *(void *)(v103 + 8) = 0;
      *(void *)(v103 + 16) = DirectionalLocalSymbol;
      *a2 = v103;
      uint64_t v105 = v98;
      if (*v56 != 98) {
        goto LABEL_118;
      }
      unint64_t AssociatedFragment = *(void *)DirectionalLocalSymbol & 0xFFFFFFFFFFFFFFF8;
      if (AssociatedFragment) {
        goto LABEL_118;
      }
      if ((*(_DWORD *)(DirectionalLocalSymbol + 8) & 0x1C00) == 0x800)
      {
        *(_DWORD *)(DirectionalLocalSymbol + 8) |= 4u;
        unint64_t AssociatedFragment = llvm::MCExpr::findAssociatedFragment(*(llvm::MCExpr **)(DirectionalLocalSymbol + 24));
        *(void *)uint64_t DirectionalLocalSymbol = *(void *)DirectionalLocalSymbol & 7 | AssociatedFragment;
      }
      uint64_t v105 = v98;
      if (AssociatedFragment)
      {
LABEL_118:
        *(void *)int v172 = v105;
        long long v107 = *((_OWORD *)a1 + 28);
        *(_OWORD *)&v172[8] = *((_OWORD *)a1 + 27);
        *(_OWORD *)&v172[24] = v107;
        *(void *)&v172[40] = a1[58];
        uint64_t v173 = DirectionalLocalSymbol;
        unsigned int v108 = *((_DWORD *)a1 + 124);
        uint64_t v109 = a1[61];
        if (v108 >= *((_DWORD *)a1 + 125))
        {
          BOOL v159 = &v109[14 * v108] > (unsigned int *)v172;
          if (v109 > (unsigned int *)v172 || !v159) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        int v110 = &v109[14 * *((unsigned int *)a1 + 124)];
        long long v111 = *(_OWORD *)v172;
        long long v112 = *(_OWORD *)&v172[16];
        long long v113 = *(_OWORD *)&v172[32];
        *((void *)v110 + 6) = v173;
        *((_OWORD *)v110 + 1) = v112;
        *((_OWORD *)v110 + 2) = v113;
        *(_OWORD *)int v110 = v111;
        ++*((_DWORD *)a1 + 124);
        goto LABEL_44;
      }
      uint64_t v125 = "directional label undefined";
LABEL_146:
      *(void *)int v172 = v125;
      *(_WORD *)&v172[32] = 259;
      uint64_t v126 = (uint64_t)a1;
      return llvm::MCAsmParser::Error(v126, v105, (uint64_t)v172, 0, 0);
    case 5:
      unint64_t v26 = "literal value out of range for directive";
      goto LABEL_25;
    case 6:
      uint64_t v67 = (*((uint64_t (**)(unsigned int **))*a1 + 5))(a1);
      llvm::APFloat::APFloat((uint64_t)v172, &unk_1CFB2E31C, *(unsigned __int8 **)(*(void *)(v67 + 8) + 8), *(void *)(*(void *)(v67 + 8) + 16));
      if (*(_UNKNOWN **)&v172[8] == &unk_1CFB2E344) {
        llvm::detail::DoubleAPFloat::bitcastToAPInt((llvm::detail::DoubleAPFloat *)&v172[8], (llvm::APInt *)&__p);
      }
      else {
        llvm::detail::IEEEFloat::bitcastToAPInt((uint64_t)&v172[8], (uint64_t)&__p);
      }
      if (v166 >= 0x41) {
        unint64_t v68 = (uint64_t *)__p;
      }
      else {
        unint64_t v68 = (uint64_t *)&__p;
      }
      uint64_t v69 = *v68;
      if (v166 >= 0x41 && __p) {
        MEMORY[0x1D25D9CB0]();
      }
      uint64_t v70 = (*((uint64_t (**)(unsigned int **))*a1 + 6))(a1);
      uint64_t v71 = v70;
      *(void *)(v70 + 272) += 24;
      uint64_t v72 = *(void *)(v70 + 192);
      if (((v72 + 7) & 0xFFFFFFFFFFFFFFF8) - v72 + 24 > *(void *)(v70 + 200) - v72)
      {
        unsigned int v137 = *(_DWORD *)(v70 + 216) >> 7;
        if (v137 >= 0x1E) {
          LOBYTE(v137) = 30;
        }
        uint64_t v138 = 4096 << v137;
        unint64_t v73 = (unint64_t)operator new(4096 << v137, (std::align_val_t)8uLL);
        unsigned int v139 = *(_DWORD *)(v71 + 216);
        if (v139 >= *(_DWORD *)(v71 + 220)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v71 + 208) + 8 * v139) = v73;
        ++*(_DWORD *)(v71 + 216);
        *(void *)(v71 + 200) = v73 + v138;
      }
      else
      {
        unint64_t v73 = (v72 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(v71 + 192) = v73 + 24;
      *(unsigned char *)unint64_t v73 = 1;
      *(_DWORD *)(v73 + 1) = *(unsigned __int8 *)(v73 + 4) << 24;
      *(void *)(v73 + 8) = 0;
      *(void *)(v73 + 16) = v69;
      *a2 = v73;
      *a3 = *((void *)a1[6] + 1) + *((void *)a1[6] + 2);
      (*((void (**)(unsigned int **))*a1 + 23))(a1);
      if (*(_UNKNOWN **)&v172[8] == &unk_1CFB2E344)
      {
        sub_1CB845718((uint64_t *)&v172[16]);
      }
      else if ((*(_DWORD *)(*(void *)&v172[8] + 8) - 64) <= 0xFFFFFF7F && *(void *)&v172[16])
      {
        MEMORY[0x1D25D9CB0](*(void *)&v172[16], 0x1000C8000313F17);
      }
      return 0;
    case 12:
      (*((void (**)(unsigned int **))*a1 + 23))(a1);
      if ((*((uint64_t (**)(unsigned int **, unint64_t *, uint64_t *, uint64_t))*a1 + 30))(a1, a2, a3, a4))return 1; {
      unint64_t v31 = *a2;
      }
      uint64_t v32 = (*((uint64_t (**)(unsigned int **))*a1 + 6))(a1);
      uint64_t v33 = v32;
      *(void *)(v32 + 272) += 24;
      uint64_t v34 = *(void *)(v32 + 192);
      if (((v34 + 7) & 0xFFFFFFFFFFFFFFF8) - v34 + 24 > *(void *)(v32 + 200) - v34)
      {
        unsigned int v143 = *(_DWORD *)(v32 + 216) >> 7;
        if (v143 >= 0x1E) {
          LOBYTE(v143) = 30;
        }
        uint64_t v144 = 4096 << v143;
        unint64_t v35 = (unint64_t)operator new(4096 << v143, (std::align_val_t)8uLL);
        unsigned int v145 = *(_DWORD *)(v33 + 216);
        if (v145 >= *(_DWORD *)(v33 + 220)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v33 + 208) + 8 * v145) = v35;
        ++*(_DWORD *)(v33 + 216);
        *(void *)(v33 + 200) = v35 + v144;
      }
      else
      {
        unint64_t v35 = (v34 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      uint64_t result = 0;
      *(void *)(v33 + 192) = v35 + 24;
      *(unsigned char *)unint64_t v35 = 3;
      int v36 = (*(unsigned __int8 *)(v35 + 4) << 24) | 3;
      goto LABEL_89;
    case 13:
      (*((void (**)(unsigned int **))*a1 + 23))(a1);
      if ((*((uint64_t (**)(unsigned int **, unint64_t *, uint64_t *, uint64_t))*a1 + 30))(a1, a2, a3, a4))return 1; {
      unint64_t v31 = *a2;
      }
      uint64_t v74 = (*((uint64_t (**)(unsigned int **))*a1 + 6))(a1);
      uint64_t v75 = v74;
      *(void *)(v74 + 272) += 24;
      uint64_t v76 = *(void *)(v74 + 192);
      if (((v76 + 7) & 0xFFFFFFFFFFFFFFF8) - v76 + 24 > *(void *)(v74 + 200) - v76)
      {
        unsigned int v149 = *(_DWORD *)(v74 + 216) >> 7;
        if (v149 >= 0x1E) {
          LOBYTE(v149) = 30;
        }
        uint64_t v150 = 4096 << v149;
        unint64_t v35 = (unint64_t)operator new(4096 << v149, (std::align_val_t)8uLL);
        unsigned int v151 = *(_DWORD *)(v75 + 216);
        if (v151 >= *(_DWORD *)(v75 + 220)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v75 + 208) + 8 * v151) = v35;
        ++*(_DWORD *)(v75 + 216);
        *(void *)(v75 + 200) = v35 + v150;
      }
      else
      {
        unint64_t v35 = (v76 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      uint64_t result = 0;
      *(void *)(v75 + 192) = v35 + 24;
      *(unsigned char *)unint64_t v35 = 3;
      int v77 = *(unsigned __int8 *)(v35 + 4);
      int v78 = 1;
      goto LABEL_88;
    case 14:
      (*((void (**)(unsigned int **))*a1 + 23))(a1);
      if ((*((uint64_t (**)(unsigned int **, unint64_t *, uint64_t *, uint64_t))*a1 + 30))(a1, a2, a3, a4))return 1; {
      unint64_t v31 = *a2;
      }
      uint64_t v79 = (*((uint64_t (**)(unsigned int **))*a1 + 6))(a1);
      uint64_t v80 = v79;
      *(void *)(v79 + 272) += 24;
      uint64_t v81 = *(void *)(v79 + 192);
      if (((v81 + 7) & 0xFFFFFFFFFFFFFFF8) - v81 + 24 > *(void *)(v79 + 200) - v81)
      {
        unsigned int v152 = *(_DWORD *)(v79 + 216) >> 7;
        if (v152 >= 0x1E) {
          LOBYTE(v152) = 30;
        }
        uint64_t v153 = 4096 << v152;
        unint64_t v35 = (unint64_t)operator new(4096 << v152, (std::align_val_t)8uLL);
        unsigned int v154 = *(_DWORD *)(v80 + 216);
        if (v154 >= *(_DWORD *)(v80 + 220)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v80 + 208) + 8 * v154) = v35;
        ++*(_DWORD *)(v80 + 216);
        *(void *)(v80 + 200) = v35 + v153;
      }
      else
      {
        unint64_t v35 = (v81 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      uint64_t result = 0;
      *(void *)(v80 + 192) = v35 + 24;
      *(unsigned char *)unint64_t v35 = 3;
      int v77 = *(unsigned __int8 *)(v35 + 4);
      int v78 = 2;
LABEL_88:
      int v36 = v78 | (v77 << 24);
      goto LABEL_89;
    case 17:
      (*((void (**)(unsigned int **))*a1 + 23))(a1);
      return sub_1CD3821A4((llvm::MCAsmParser *)a1, (uint64_t)a2, a3);
    case 19:
      if (!*((unsigned char *)a1[33] + 16))
      {
        unint64_t v26 = "brackets expression not supported on this target";
        goto LABEL_25;
      }
      (*((void (**)(unsigned int **))*a1 + 23))(a1);
      *(void *)int v172 = 0;
      if ((*((uint64_t (**)(unsigned int **, unint64_t *, unsigned char *))*a1 + 29))(a1, a2, v172)) {
        return 1;
      }
      uint64_t v30 = (*((uint64_t (**)(unsigned int **))*a1 + 5))(a1);
      *a3 = *(void *)(*(void *)(v30 + 8) + 8) + *(void *)(*(void *)(v30 + 8) + 16);
      *(void *)int v172 = "expected ']' in brackets expression";
      *(_WORD *)&v172[32] = 259;
      return llvm::MCAsmParser::parseToken((llvm::MCAsmParser *)a1, 20, (llvm::Twine *)v172);
    case 24:
      if (!*((unsigned char *)a1[29] + 33))
      {
        unint64_t v26 = "cannot use . as current PC";
        goto LABEL_25;
      }
      unsigned int v37 = (llvm::MCContext *)a1[27];
      *(void *)int v172 = "tmp";
      *(_WORD *)&v172[32] = 259;
      uint64_t v38 = llvm::MCContext::createTempSymbol(v37, (const llvm::Twine *)v172, 1);
      (*(void (**)(unsigned int *, uint64_t, void))(*(void *)a1[28] + 192))(a1[28], v38, 0);
      uint64_t v39 = (*((uint64_t (**)(unsigned int **))*a1 + 6))(a1);
      uint64_t v40 = v39;
      *(void *)(v39 + 272) += 24;
      uint64_t v41 = *(void *)(v39 + 192);
      if (((v41 + 7) & 0xFFFFFFFFFFFFFFF8) - v41 + 24 > *(void *)(v39 + 200) - v41)
      {
        unsigned int v140 = *(_DWORD *)(v39 + 216) >> 7;
        if (v140 >= 0x1E) {
          LOBYTE(v140) = 30;
        }
        uint64_t v141 = 4096 << v140;
        unint64_t v42 = (unint64_t)operator new(4096 << v140, (std::align_val_t)8uLL);
        unsigned int v142 = *(_DWORD *)(v40 + 216);
        if (v142 >= *(_DWORD *)(v40 + 220)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v40 + 208) + 8 * v142) = v42;
        ++*(_DWORD *)(v40 + 216);
        *(void *)(v40 + 200) = v42 + v141;
      }
      else
      {
        unint64_t v42 = (v41 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(v40 + 192) = v42 + 24;
      int v43 = *(unsigned __int8 *)(*(void *)(v40 + 152) + 18) << 16;
      *(unsigned char *)unint64_t v42 = 2;
      *(_DWORD *)(v42 + 1) = v43 | (*(unsigned __int8 *)(v42 + 4) << 24);
      *(void *)(v42 + 8) = 0;
      *(void *)(v42 + 16) = v38;
      *a2 = v42;
LABEL_44:
      *a3 = *((void *)a1[6] + 1) + *((void *)a1[6] + 2);
      (*((void (**)(unsigned int **))*a1 + 23))(a1);
      return 0;
    case 34:
      (*((void (**)(unsigned int **))*a1 + 23))(a1);
      if ((*((uint64_t (**)(unsigned int **, unint64_t *, uint64_t *, uint64_t))*a1 + 30))(a1, a2, a3, a4))return 1; {
      unint64_t v31 = *a2;
      }
      uint64_t v64 = (*((uint64_t (**)(unsigned int **))*a1 + 6))(a1);
      uint64_t v65 = v64;
      *(void *)(v64 + 272) += 24;
      uint64_t v66 = *(void *)(v64 + 192);
      if (((v66 + 7) & 0xFFFFFFFFFFFFFFF8) - v66 + 24 > *(void *)(v64 + 200) - v66)
      {
        unsigned int v146 = *(_DWORD *)(v64 + 216) >> 7;
        if (v146 >= 0x1E) {
          LOBYTE(v146) = 30;
        }
        uint64_t v147 = 4096 << v146;
        unint64_t v35 = (unint64_t)operator new(4096 << v146, (std::align_val_t)8uLL);
        unsigned int v148 = *(_DWORD *)(v65 + 216);
        if (v148 >= *(_DWORD *)(v65 + 220)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v65 + 208) + 8 * v148) = v35;
        ++*(_DWORD *)(v65 + 216);
        *(void *)(v65 + 200) = v35 + v147;
      }
      else
      {
        unint64_t v35 = (v66 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      uint64_t result = 0;
      *(void *)(v65 + 192) = v35 + 24;
      *(unsigned char *)unint64_t v35 = 3;
      int v36 = *(unsigned __int8 *)(v35 + 4) << 24;
LABEL_89:
      *(_DWORD *)(v35 + 1) = v36;
      *(void *)(v35 + 8) = v10;
      *(void *)(v35 + 16) = v31;
      *a2 = v35;
      return result;
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
      (*((void (**)(unsigned int **))*a1 + 23))(a1);
      if (*a1[6] == 17)
      {
        (*((void (**)(unsigned int **))*a1 + 23))(a1);
        if ((*((uint64_t (**)(unsigned int **, unint64_t *, uint64_t *))*a1 + 29))(a1, a2, a3)) {
          return 1;
        }
        *(void *)int v172 = "expected ')'";
        *(_WORD *)&v172[32] = 259;
        if (llvm::MCAsmParser::parseToken((llvm::MCAsmParser *)a1, 18, (llvm::Twine *)v172))
        {
          return 1;
        }
        else
        {
          uint64_t v28 = (*(uint64_t (**)(unsigned int *, unint64_t, uint64_t, unsigned int *))(*(void *)a1[1] + 184))(a1[1], *a2, v9, a1[27]);
          *a2 = v28;
          return v28 == 0;
        }
      }
      else
      {
        unint64_t v26 = "expected '(' after operator";
LABEL_25:
        *(void *)int v172 = v26;
        __int16 v27 = 259;
LABEL_26:
        *(_WORD *)&v172[32] = v27;
        return llvm::MCAsmParser::TokError((uint64_t)a1, (uint64_t)v172, 0, 0);
      }
    default:
      unint64_t v26 = "unknown token in expression";
      goto LABEL_25;
  }
}

uint64_t sub_1CD36E740(llvm::MCAsmParser *a1, unint64_t *a2, void *a3)
{
  *a2 = 0;
  if (sub_1CD3821A4(a1, (uint64_t)a2, a3)) {
    return 1;
  }

  return sub_1CD3817A0((uint64_t)a1, 1u, a2, (uint64_t)a3);
}

uint64_t sub_1CD36E7B0(void *a1, void *a2)
{
  uint64_t v14 = 0;
  uint64_t v4 = a1[17];
  *(void *)&long long v10 = 0;
  if ((*(uint64_t (**)(void *, uint64_t *, long long *))(*a1 + 232))(a1, &v14, &v10)) {
    return 1;
  }
  uint64_t v6 = v14;
  uint64_t v7 = (*(uint64_t (**)(void *))(*a1 + 56))(a1);
  uint64_t v8 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)v7 + 72))(v7);
  long long v10 = 0uLL;
  int v12 = 0;
  uint64_t v11 = 0;
  if (*(unsigned char *)v6 == 1)
  {
    uint64_t result = 0;
    *a2 = *(void *)(v6 + 16);
  }
  else
  {
    char v9 = llvm::MCExpr::evaluateAsRelocatableImpl(v6, (uint64_t)&v10, v8, 0, 0, 0, 0);
    *a2 = v11;
    if ((v9 & 1) != 0 && v10 == 0)
    {
      return 0;
    }
    else
    {
      *(void *)&long long v10 = "expected absolute expression";
      __int16 v13 = 259;
      return llvm::MCAsmParser::Error((uint64_t)a1, v4, (uint64_t)&v10, 0, 0);
    }
  }
  return result;
}

uint64_t sub_1CD36E90C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 805)) {
    return 0;
  }
  uint64_t v2 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1);
  uint64_t v3 = *(unsigned int *)(v2 + 120);
  if (v3)
  {
    if (*(void *)(*(void *)(v2 + 112) + 32 * v3 - 32)) {
      return 0;
    }
  }
  (*(void (**)(void, void, void))(**(void **)(a1 + 224) + 176))(*(void *)(a1 + 224), 0, *(void *)(*(void *)(a1 + 8) + 240));
  uint64_t v5 = *(void *)(*(void *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 8) + 8);
  uint64_t v6 = "expected section directive before assembly directive";
  __int16 v7 = 259;
  return llvm::MCAsmParser::Error(a1, v5, (uint64_t)&v6, 0, 0);
}

uint64_t sub_1CD36EA0C(llvm::MCAsmParser *a1, int a2, unint64_t *a3, void *a4)
{
  if (sub_1CD3821A4(a1, (uint64_t)a3, a4)) {
    return 1;
  }
  if (!a2) {
    return 0;
  }
  BOOL v8 = 1;
  while ((sub_1CD3817A0((uint64_t)a1, 1u, a3, (uint64_t)a4) & 1) == 0)
  {
    BOOL v8 = --a2 != 0;
    if (!a2) {
      break;
    }
    uint64_t v9 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)a1 + 40))(a1);
    *a4 = *(void *)(*(void *)(v9 + 8) + 8) + *(void *)(*(void *)(v9 + 8) + 16);
    uint64_t v11 = "expected ')'";
    __int16 v12 = 259;
    if (llvm::MCAsmParser::parseToken(a1, 18, (llvm::Twine *)&v11)) {
      break;
    }
  }
  return v8;
}

uint64_t sub_1CD36EB20(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  uint64_t v5 = *(void *)(a1 + 872);
  int v6 = **(_DWORD **)(v5 + 8);
  if (v6 == 9)
  {
    if (*(void *)(*(void *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 8) + 16)
      && **(unsigned char **)(*(void *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 8) + 8) != 13
      && **(unsigned char **)(*(void *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 8) + 8) != 10)
    {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  int v7 = **(_DWORD **)(v4 + 8);
  while (v6 == 11)
  {
    sub_1CD8F38F8(v5);
    uint64_t v5 = *(void *)(a1 + 872);
    int v6 = **(_DWORD **)(v5 + 8);
  }
  if (v6 == 9
    && (**(unsigned char **)(*(void *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 8) + 8) == 10
     || **(unsigned char **)(*(void *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 8) + 8) == 13))
  {
LABEL_12:
    (*(void (**)(void))(**(void **)(a1 + 880) + 152))(*(void *)(a1 + 880));
LABEL_13:
    sub_1CD36BD58(a1);
    return 0;
  }
  if (v7 != 11)
  {
    uint64_t v10 = *(void *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 8);
    long long v11 = *(_OWORD *)v10;
    uint64_t v40 = *(void *)(v10 + 16);
    long long v39 = v11;
    unsigned int v42 = *(_DWORD *)(v10 + 32);
    if (v42 > 0x40) {
      operator new[]();
    }
    uint64_t v41 = *(void *)(v10 + 24);
    uint64_t v12 = *((void *)&v39 + 1);
    uint64_t v37 = 0;
    unint64_t v38 = *((void *)&v39 + 1);
    int v36 = 0;
    if (sub_1CD36C014((_DWORD **)a1, &v36))
    {
      __int16 v22 = "The HLASM Label has to be an Identifier";
    }
    else
    {
      if (!(*(unsigned int (**)(void, long long *))(**(void **)(a1 + 8) + 136))(*(void *)(a1 + 8), &v39)|| (sub_1CD36E90C(a1) & 1) != 0)
      {
        int v14 = 1;
        goto LABEL_41;
      }
      while (1)
      {
        uint64_t v15 = *(void *)(a1 + 872);
        if (**(_DWORD **)(v15 + 8) != 11) {
          break;
        }
        sub_1CD8F38F8(v15);
      }
      if (**(_DWORD **)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 8) != 9)
      {
        uint64_t v16 = *(llvm::MCContext **)(a1 + 216);
        uint64_t v17 = *((void *)v16 + 19);
        int v18 = *(unsigned __int8 *)(v17 + 80);
        if (*(unsigned char *)(v17 + 80))
        {
          llvm::StringRef::upper((llvm::StringRef *)&v36, __p);
          uint64_t v19 = (void **)__p[0];
          if (v32 >= 0) {
            uint64_t v19 = __p;
          }
          uint64_t v20 = v32 & 0x7F;
          if (v32 < 0) {
            uint64_t v20 = (uint64_t)__p[1];
          }
        }
        else
        {
          uint64_t v19 = v36;
          uint64_t v20 = v37;
        }
        __int16 v35 = 261;
        uint64_t v33 = (unsigned __int8 **)v19;
        uint64_t v34 = v20;
        uint64_t v21 = llvm::MCContext::getOrCreateSymbol(v16, &v33);
        if (v18 && v32 < 0) {
          operator delete(__p[0]);
        }
        (*(void (**)(void, uint64_t))(**(void **)(a1 + 8) + 160))(*(void *)(a1 + 8), v21);
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 880) + 192))(*(void *)(a1 + 880), v21, v12);
        if (sub_1CD37ABFC((void *)a1)) {
          llvm::MCGenDwarfLabelEntry::Make(v21, *(void *)(a1 + 224), *(uint64_t **)(a1 + 240), &v38);
        }
        (*(void (**)(void, uint64_t))(**(void **)(a1 + 8) + 168))(*(void *)(a1 + 8), v21);
        int v14 = 0;
LABEL_41:
        if (v42 >= 0x41 && v41) {
          MEMORY[0x1D25D9CB0](v41, 0x1000C8000313F17);
        }
        if (v14)
        {
          sub_1CD36C75C(a1);
          return 1;
        }
        goto LABEL_46;
      }
      __int16 v22 = "Cannot have just a label for an HLASM inline asm statement";
    }
    uint64_t v33 = (unsigned __int8 **)v22;
    __int16 v35 = 259;
    int v14 = llvm::MCAsmParser::Error(a1, v12, (uint64_t)&v33, 0, 0);
    goto LABEL_41;
  }
LABEL_46:
  size_t v23 = *(uint64_t **)(*(void *)(a1 + 872) + 8);
  uint64_t v25 = *v23;
  uint64_t v24 = (char *)v23[1];
  uint64_t v26 = v23[2];
  unsigned int v27 = *((_DWORD *)v23 + 8);
  if (v27 > 0x40) {
    operator new[]();
  }
  uint64_t v28 = v23[3];
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  char v29 = sub_1CD36C014((_DWORD **)a1, &v33);
  if (v29)
  {
    *(void *)&long long v39 = "unexpected token at start of statement";
    LOWORD(v42) = 259;
    return llvm::MCAsmParser::Error(a1, (uint64_t)v24, (uint64_t)&v39, 0, 0);
  }
  else
  {
    while (1)
    {
      uint64_t v30 = *(void *)(a1 + 872);
      if (**(_DWORD **)(v30 + 8) != 11) {
        break;
      }
      sub_1CD8F38F8(v30);
    }
    *(void *)&long long v39 = v25;
    *((void *)&v39 + 1) = v24;
    uint64_t v40 = v26;
    unsigned int v42 = v27;
    uint64_t v41 = v28;
    return sub_1CD37CA70(a1, a2, (uint64_t)v33, v34, &v39, v24);
  }
}

void sub_1CD36F19C(uint64_t a1, uint64_t a2)
{
  v44[22] = *(void **)MEMORY[0x1E4F143B8];
  uint64_t v4 = (llvm::raw_ostream *)llvm::errs((llvm *)a1);
  uint64_t v5 = *(llvm::raw_ostream **)a1;
  int v6 = *(char **)(a1 + 8);
  unsigned int BufferContainingLoc = llvm::SourceMgr::FindBufferContainingLoc(*(uint64_t **)a1, (unint64_t)v6);
  int v8 = llvm::SourceMgr::FindBufferContainingLoc(*(uint64_t **)(a2 + 240), *(void *)(a2 + 456));
  if (*(void *)(a2 + 248)) {
    BOOL v9 = 0;
  }
  else {
    BOOL v9 = BufferContainingLoc >= 2;
  }
  if (v9) {
    llvm::SourceMgr::PrintIncludeStack(v5, *(char **)(*(void *)v5 + 24 * (BufferContainingLoc - 1) + 16), v4);
  }
  if (!*(void *)(a2 + 448) || BufferContainingLoc != v8)
  {
    uint64_t v10 = *(void (**)(uint64_t, uint64_t))(a2 + 248);
    if (v10)
    {
      uint64_t v11 = *(void *)(a2 + 256);
      v10(a1, v11);
    }
    else
    {
      uint64_t v15 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 48))(a2);
      llvm::MCContext::diagnose(v15, a1);
    }
    return;
  }
  size_t v12 = *(void *)(a2 + 440);
  if (v12 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  __int16 v13 = *(const void **)(a2 + 432);
  if (v12 >= 0x17)
  {
    uint64_t v16 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v12 | 7) != 0x17) {
      uint64_t v16 = v12 | 7;
    }
    uint64_t v17 = v16 + 1;
    p_dst = (void **)operator new(v16 + 1);
    std::string::size_type v33 = v12;
    int64_t v34 = v17 | 0x8000000000000000;
    int __dst = p_dst;
  }
  else
  {
    HIBYTE(v34) = *(void *)(a2 + 440);
    p_dst = (void **)&__dst;
    if (!v12) {
      goto LABEL_23;
    }
  }
  memmove(p_dst, v13, v12);
LABEL_23:
  *((unsigned char *)p_dst + v12) = 0;
  int LineAndColumn = llvm::SourceMgr::getLineAndColumn((uint64_t *)v5, v6, BufferContainingLoc);
  int v19 = ~llvm::SourceMgr::getLineAndColumn(*(uint64_t **)(a2 + 240), *(char **)(a2 + 456), BufferContainingLoc)+ LineAndColumn+ *(_DWORD *)(a2 + 448);
  if (v34 >= 0) {
    uint64_t v20 = (std::string::value_type *)&__dst;
  }
  else {
    uint64_t v20 = (std::string::value_type *)__dst;
  }
  if (v34 >= 0) {
    std::string::size_type v21 = HIBYTE(v34) & 0x7F;
  }
  else {
    std::string::size_type v21 = v33;
  }
  char v22 = *(unsigned char *)(a1 + 79);
  BOOL v23 = v22 < 0;
  if (v22 >= 0) {
    uint64_t v24 = (const std::string::value_type *)(a1 + 56);
  }
  else {
    uint64_t v24 = *(const std::string::value_type **)(a1 + 56);
  }
  std::string::size_type v25 = v22 & 0x7F;
  if (v23) {
    std::string::size_type v25 = *(void *)(a1 + 64);
  }
  char v26 = *(unsigned char *)(a1 + 103);
  BOOL v27 = v26 < 0;
  if (v26 >= 0) {
    uint64_t v28 = (const std::string::value_type *)(a1 + 80);
  }
  else {
    uint64_t v28 = *(const std::string::value_type **)(a1 + 80);
  }
  std::string::size_type v29 = v26 & 0x7F;
  if (v27) {
    std::string::size_type v29 = *(void *)(a1 + 88);
  }
  llvm::SMDiagnostic::SMDiagnostic((uint64_t)v35, *(void *)a1, *(void *)(a1 + 8), v20, v21, v19, *(_DWORD *)(a1 + 44), *(_DWORD *)(a1 + 48), v24, v25, v28, v29, *(unsigned char **)(a1 + 104), (uint64_t)(*(void *)(a1 + 112) - *(void *)(a1 + 104)) >> 3, 0, 0);
  uint64_t v30 = *(void (**)(uint64_t, void))(a2 + 248);
  if (v30)
  {
    v30(a1, *(void *)(a2 + 256));
  }
  else
  {
    unint64_t v31 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 48))(a2);
    llvm::MCContext::diagnose(v31, (uint64_t)v35);
  }
  sub_1CC1925A4(v44);
  if (__p)
  {
    int v43 = __p;
    operator delete(__p);
  }
  if (v41 < 0) {
    operator delete(v40);
  }
  if (v39 < 0) {
    operator delete(v38);
  }
  if (v37 < 0) {
    operator delete(v36);
  }
  if (SHIBYTE(v34) < 0) {
    operator delete(__dst);
  }
}

void sub_1CD36F544(uint64_t a1)
{
  sub_1CD379E2C(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD36F57C(void **a1, uint64_t a2, llvm::APInt *a3)
{
  uint64_t v796 = *MEMORY[0x1E4F143B8];
  int v7 = (int **)(a1 + 6);
  while (1)
  {
    int v8 = **v7;
    if (v8 != 11) {
      break;
    }
    ((void (*)(void **))(*a1)[23])(a1);
  }
  if (v8 == 9)
  {
    if (!*(void *)(*(void *)(((uint64_t (*)(void **))(*a1)[5])(a1) + 8) + 16)
      || **(unsigned char **)(*(void *)(((uint64_t (*)(void **))(*a1)[5])(a1) + 8) + 8) == 13
      || **(unsigned char **)(*(void *)(((uint64_t (*)(void **))(*a1)[5])(a1) + 8) + 8) == 10)
    {
      (*(void (**)(void *))(*a1[28] + 152))(a1[28]);
    }
    ((void (*)(void **))(*a1)[23])(a1);
    return 0;
  }
  uint64_t v10 = *(void *)(((uint64_t (*)(void **))(*a1)[5])(a1) + 8);
  long long v11 = *(_OWORD *)v10;
  uint64_t v727 = *(void *)(v10 + 16);
  long long v726 = v11;
  unsigned int v729 = *(_DWORD *)(v10 + 32);
  if (v729 > 0x40) {
    operator new[]();
  }
  unint64_t __src = *(void **)(v10 + 24);
  uint64_t v12 = *((void *)&v726 + 1);
  uint64_t v725 = (char *)*((void *)&v726 + 1);
  __n[0] = 0;
  __n[1] = 0;
  a1[34] = (void *)*((void *)&v726 + 1);
  int v13 = *(_DWORD *)a1[6];
  switch(v13)
  {
    case 21:
      ((void (*)(void **))(*a1)[23])(a1);
      int v14 = "{";
      goto LABEL_31;
    case 22:
      ((void (*)(void **))(*a1)[23])(a1);
      int v14 = "}";
      goto LABEL_31;
    case 23:
      if (!(*(unsigned int (**)(void *))(*a1[1] + 144))(a1[1])) {
        goto LABEL_26;
      }
      ((void (*)(void **))(*a1)[23])(a1);
      int v14 = "*";
LABEL_31:
      __n[0] = (size_t)v14;
      uint64_t v699 = -1;
      size_t v19 = 1;
      goto LABEL_32;
    case 24:
      ((void (*)(void **))(*a1)[23])(a1);
      int v14 = ".";
      goto LABEL_31;
    default:
      if (v13 == 4)
      {
        uint64_t v15 = *(void *)(((uint64_t (*)(void **))(*a1)[5])(a1) + 8);
        uint64_t v18 = *(void *)(v15 + 24);
        uint64_t v16 = v15 + 24;
        uint64_t v17 = v18;
        if (*(_DWORD *)(v16 + 8) >= 0x41u) {
          uint64_t v16 = v17;
        }
        uint64_t v699 = *(void *)v16;
        if ((*(void *)v16 & 0x8000000000000000) != 0)
        {
          if (*((unsigned char *)a1 + 289))
          {
            size_t v19 = 0;
            __n[0] = (size_t)"";
            goto LABEL_32;
          }
        }
        else
        {
          *(_OWORD *)uint64_t __n = *(_OWORD *)(*(void *)(((uint64_t (*)(void **))(*a1)[5])(a1) + 8) + 8);
          ((void (*)(void **))(*a1)[23])(a1);
          if (*(_DWORD *)a1[6] == 10 || *((unsigned char *)a1 + 289)) {
            goto LABEL_33;
          }
        }
        ((void (*)(void **))(*a1)[23])(a1);
        *(void *)int __dst = "unexpected token at start of statement";
        *(_WORD *)&__dst[32] = 259;
        uint64_t v114 = (uint64_t)a1;
        long long v113 = (char *)v12;
LABEL_279:
        uint64_t v53 = llvm::MCAsmParser::Error(v114, (uint64_t)v113, (uint64_t)__dst, 0, 0);
        goto LABEL_280;
      }
      if (v13 == 8)
      {
        sub_1CD37A050((uint64_t)a1, v12, a1[44] == a1[45]);
        goto LABEL_152;
      }
LABEL_26:
      if (((unsigned int (*)(void **, size_t *))(*a1)[24])(a1, __n))
      {
        if (*((unsigned char *)a1 + 289))
        {
          size_t v19 = 0;
          __n[0] = (size_t)"";
          uint64_t v699 = -1;
LABEL_32:
          __n[1] = v19;
          goto LABEL_33;
        }
        ((void (*)(void **))(*a1)[23])(a1);
        long long v113 = v725;
        *(void *)int __dst = "unexpected token at start of statement";
        *(_WORD *)&__dst[32] = 259;
        uint64_t v114 = (uint64_t)a1;
        goto LABEL_279;
      }
      uint64_t v699 = -1;
LABEL_33:
      long long v697 = a3;
      uint64_t v700 = a2;
      llvm::StringRef::lower((llvm::StringRef *)__n, __dst);
      int __s1 = __dst[23];
      long long __p = *(void **)__dst;
      if (__dst[23] >= 0) {
        uint64_t v20 = __dst;
      }
      else {
        uint64_t v20 = *(unsigned __int8 **)__dst;
      }
      if (__dst[23] >= 0) {
        size_t v21 = __dst[23] & 0x7F;
      }
      else {
        size_t v21 = *(void *)&__dst[8];
      }
      uint64_t v22 = *((unsigned int *)a1 + 204);
      uint64_t v715 = (llvm::MCAsmParser *)a1;
      uint64_t v695 = (uint64_t)(a1 + 5);
      if (v22)
      {
        int v23 = 0;
        if (v21)
        {
          size_t v24 = v21;
          std::string::size_type v25 = v20;
          do
          {
            int v26 = *v25++;
            int v23 = 33 * v23 + v26;
            --v24;
          }
          while (v24);
        }
        BOOL v27 = a1[101];
        int v28 = 1;
        int v29 = v23;
        while (1)
        {
          uint64_t v30 = v29 & (v22 - 1);
          unint64_t v31 = (void *)v27[v30];
          if (v31 != (void *)-8)
          {
            if (!v31)
            {
              uint64_t v32 = v22;
              goto LABEL_52;
            }
            if (*((_DWORD *)&v27[v22 + 1] + v30) == v23
              && v21 == *v31
              && (!v21 || !memcmp(v20, (char *)v31 + *((unsigned int *)v715 + 207), v21)))
            {
              break;
            }
          }
          int v29 = v28 + v30;
          ++v28;
        }
        uint64_t v32 = (int)v30;
        if (v30 == -1) {
          uint64_t v32 = v22;
        }
      }
      else
      {
        uint64_t v32 = 0;
        BOOL v27 = a1[101];
      }
LABEL_52:
      std::string::size_type v33 = &v27[v32];
      int64_t v34 = v715;
      if (__s1 < 0)
      {
        operator delete(__p);
        BOOL v27 = (void *)*((void *)v715 + 101);
        LODWORD(v22) = *((_DWORD *)v715 + 204);
      }
      if (v33 != &v27[v22])
      {
        int v35 = *(_DWORD *)(*v33 + 8);
        switch(v35)
        {
          case 'R':
          case 'S':
          case 'T':
          case 'U':
          case 'V':
          case 'W':
          case 'X':
            int v36 = (void *)((char *)v715 + 284);
            unint64_t v38 = (char *)*((void *)v715 + 38);
            unint64_t v37 = *((void *)v715 + 39);
            if ((unint64_t)v38 < v37)
            {
              *(void *)unint64_t v38 = *v36;
              char v39 = v38 + 8;
LABEL_150:
              *((void *)v34 + 38) = v39;
              *((_DWORD *)v34 + 71) = 1;
              if (*((unsigned char *)v34 + 289))
              {
LABEL_151:
                (*(void (**)(llvm::MCAsmParser *))(*(void *)v34 + 224))(v34);
                goto LABEL_152;
              }
              *(void *)int __dst = 0;
              if (((*(uint64_t (**)(llvm::MCAsmParser *, unsigned char *))(*(void *)v34 + 256))(v34, __dst) & 1) == 0
                && !llvm::MCAsmParser::parseEOL(v34))
              {
                switch(v35)
                {
                  case 'S':
                    BOOL v86 = *(void *)__dst == 0;
                    goto LABEL_253;
                  case 'T':
                    unint64_t v139 = ~*(void *)__dst;
                    goto LABEL_251;
                  case 'U':
                    BOOL v86 = *(void *)__dst > 0;
                    goto LABEL_253;
                  case 'V':
                    BOOL v86 = *(void *)__dst < 1;
                    goto LABEL_253;
                  case 'W':
                    unint64_t v139 = *(void *)__dst;
LABEL_251:
                    BOOL v86 = v139 >> 63;
LABEL_253:
                    *(void *)int __dst = v86;
                    break;
                  default:
                    break;
                }
LABEL_254:
                uint64_t v9 = 0;
                BOOL v128 = *(void *)__dst == 0;
                *((unsigned char *)v34 + 288) = *(void *)__dst != 0;
LABEL_255:
                *((unsigned char *)v34 + 289) = v128;
                goto LABEL_281;
              }
LABEL_217:
              uint64_t v9 = 1;
              goto LABEL_281;
            }
            uint64_t v45 = (unsigned char *)*((void *)v715 + 37);
            uint64_t v46 = (v38 - v45) >> 3;
            unint64_t v47 = v46 + 1;
            if (!((unint64_t)(v46 + 1) >> 61))
            {
              uint64_t v48 = v37 - (void)v45;
              if (v48 >> 2 > v47) {
                unint64_t v47 = v48 >> 2;
              }
              if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v49 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v49 = v47;
              }
              if (v49)
              {
                if (v49 >> 61) {
LABEL_1121:
                }
                  sub_1CB833614();
                uint64_t v50 = (char *)operator new(8 * v49);
              }
              else
              {
                uint64_t v50 = 0;
              }
              unsigned int v83 = &v50[8 * v46];
              *(void *)unsigned int v83 = *v36;
              char v39 = v83 + 8;
              if (v38 == v45)
              {
                int64_t v34 = v715;
              }
              else
              {
                int64_t v34 = v715;
                do
                {
                  int v84 = *((_DWORD *)v38 - 2);
                  v38 -= 8;
                  __int16 v85 = *((_WORD *)v38 + 2);
                  *((_DWORD *)v83 - 2) = v84;
                  v83 -= 8;
                  *((_WORD *)v83 + 2) = v85;
                }
                while (v38 != v45);
                unint64_t v38 = (char *)*((void *)v715 + 37);
              }
              *((void *)v34 + 37) = v83;
              *((void *)v34 + 38) = v39;
              *((void *)v34 + 39) = &v50[8 * v49];
              if (v38) {
                operator delete(v38);
              }
              goto LABEL_150;
            }
            break;
          case 'Y':
            uint64_t v92 = (uint64_t *)v715;
            char v93 = 1;
            goto LABEL_172;
          case 'Z':
            uint64_t v92 = (uint64_t *)v715;
            char v93 = 0;
LABEL_172:
            uint64_t v53 = sub_1CD37A1A8(v92, v93);
            goto LABEL_280;
          case '[':
            uint64_t v88 = v715;
            char v89 = 1;
            goto LABEL_165;
          case '\\':
            uint64_t v90 = (uint64_t)v715;
            int v91 = 1;
            goto LABEL_170;
          case ']':
            uint64_t v88 = v715;
            char v89 = 0;
LABEL_165:
            uint64_t v53 = sub_1CD37A34C(v88, v89);
            goto LABEL_280;
          case '^':
            uint64_t v90 = (uint64_t)v715;
            int v91 = 0;
LABEL_170:
            uint64_t v53 = sub_1CD37A61C(v90, v91);
            goto LABEL_280;
          case '_':
            uint64_t v51 = (uint64_t *)v715;
            int v52 = 1;
            goto LABEL_168;
          case 'a':
            uint64_t v51 = (uint64_t *)v715;
            int v52 = 0;
LABEL_168:
            uint64_t v53 = sub_1CD37A948(v51, v52);
            goto LABEL_280;
          case 'b':
            if ((*((_DWORD *)v715 + 71) - 1) >= 2)
            {
              long long v113 = v725;
              unsigned int v129 = "Encountered a .elseif that doesn't follow an .if or  an .elseif";
              goto LABEL_239;
            }
            *((_DWORD *)v715 + 71) = 2;
            uint64_t v87 = *((void *)v715 + 38);
            if (*((void *)v715 + 37) != v87 && *(unsigned char *)(v87 - 3) || *((unsigned char *)v715 + 288))
            {
              *((unsigned char *)v715 + 289) = 1;
              goto LABEL_151;
            }
            *(void *)int __dst = 0;
            if (((*(uint64_t (**)(llvm::MCAsmParser *, unsigned char *))(*(void *)v715 + 256))(v715, __dst) & 1) == 0
              && !llvm::MCAsmParser::parseEOL(v715))
            {
              goto LABEL_254;
            }
            goto LABEL_217;
          case 'c':
            unint64_t v123 = v725;
            if (llvm::MCAsmParser::parseEOL(v715)) {
              goto LABEL_217;
            }
            if ((*((_DWORD *)v715 + 71) - 1) >= 2)
            {
              uint64_t v147 = "Encountered a .else that doesn't follow  an .if or an .elseif";
              goto LABEL_277;
            }
            *((_DWORD *)v715 + 71) = 3;
            uint64_t v127 = *((void *)v715 + 38);
            if (*((void *)v715 + 37) != v127 && *(unsigned char *)(v127 - 3) || *((unsigned char *)v715 + 288))
            {
              uint64_t v9 = 0;
              BOOL v128 = 1;
              goto LABEL_255;
            }
            uint64_t v9 = 0;
            *((unsigned char *)v715 + 289) = 0;
            goto LABEL_281;
          case 'd':
            unint64_t v123 = v725;
            if (llvm::MCAsmParser::parseEOL(v715)) {
              goto LABEL_217;
            }
            if (*((_DWORD *)v715 + 71))
            {
              uint64_t v124 = *((void *)v715 + 38);
              if (*((void *)v715 + 37) != v124)
              {
                uint64_t v9 = 0;
                int v126 = *(_DWORD *)(v124 - 8);
                uint64_t v125 = v124 - 8;
                *((_WORD *)v715 + 144) = *(_WORD *)(v125 + 4);
                *((_DWORD *)v715 + 71) = v126;
                *((void *)v715 + 38) = v125;
                goto LABEL_281;
              }
            }
            uint64_t v147 = "Encountered a .endif that doesn't follow an .if or .else";
LABEL_277:
            *(void *)int __dst = v147;
            *(_WORD *)&__dst[32] = 259;
            uint64_t v114 = (uint64_t)v715;
            goto LABEL_278;
          default:
            goto LABEL_59;
        }
LABEL_1096:
        abort();
      }
      int v35 = 0;
LABEL_59:
      if (*((unsigned char *)v715 + 289)) {
        goto LABEL_151;
      }
      int v40 = **v7;
      if (v40 == 27)
      {
        if ((*(unsigned int (**)(void))(**((void **)v715 + 1) + 128))(*((void *)v715 + 1)))
        {
          (*(void (**)(llvm::MCAsmParser *))(*(void *)v715 + 184))(v715);
          uint64_t v53 = sub_1CD37B134(v715, (unsigned __int8 **)__n[0], __n[1], 2u);
LABEL_280:
          uint64_t v9 = v53;
          goto LABEL_281;
        }
      }
      else if (v40 == 10 {
             && (*(unsigned int (**)(void, long long *))(**((void **)v715 + 1) + 136))(*((void *)v715 + 1), &v726))
      }
      {
        if ((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 264))(v715)) {
          goto LABEL_217;
        }
        (*(void (**)(llvm::MCAsmParser *))(*(void *)v715 + 184))(v715);
        size_t v41 = __n[1];
        if (__n[1] != 1 || *(unsigned char *)__n[0] != 46)
        {
          if (v699 == -1)
          {
            if (v697 && *((unsigned char *)v715 + 805))
            {
              size_t v134 = __n[0];
              uint64_t v135 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 32))(v715);
              *(void *)int __dst = (*(uint64_t (**)(llvm::APInt *, size_t, size_t, uint64_t, char *, uint64_t))(*(void *)v697 + 24))(v697, v134, v41, v135, v725, 1);
              *(void *)&__dst[8] = v136;
              uint64_t v137 = *(void *)(a2 + 88);
              LODWORD(v730[0]) = 7;
              *(void *)v747 = __n[1];
              sub_1CD8F3874(v137, (int *)v730, (uint64_t *)&v725, (uint64_t *)v747, (long long *)__dst);
              *(_OWORD *)uint64_t __n = *(_OWORD *)__dst;
            }
            unsigned int v42 = (llvm::MCContext *)(*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 48))(v715);
            *(_WORD *)&__dst[32] = 261;
            *(void *)int __dst = __n[0];
            *(void *)&__dst[8] = __n[1];
            uint64_t Symbol = llvm::MCContext::getOrCreateSymbol(v42, (unsigned __int8 ***)__dst);
          }
          else
          {
            uint64_t Symbol = llvm::MCContext::createDirectionalLocalSymbol(*((llvm::MCContext **)v715 + 27), v699);
          }
          uint64_t v44 = Symbol;
          if (**(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8) == 37)
          {
            uint64_t v131 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 200))(v715);
            uint64_t v133 = v132;
            sub_1CD8F38F8(v695);
            *(_DWORD *)int __dst = 9;
            *(void *)&__dst[8] = v131;
            *(void *)&__dst[16] = v133;
            *(_DWORD *)&__dst[32] = 64;
            *(void *)&__dst[24] = 0;
            *((unsigned char *)v715 + 147) = 0;
            sub_1CD45128C((uint64_t)v7, *((void *)v715 + 6), (unint64_t)__dst);
            if (*(_DWORD *)&__dst[32] >= 0x41u)
            {
              if (*(void *)&__dst[24]) {
                MEMORY[0x1D25D9CB0](*(void *)&__dst[24], 0x1000C8000313F17);
              }
            }
          }
          if (**(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8) == 9) {
            (*(void (**)(llvm::MCAsmParser *))(*(void *)v715 + 184))(v715);
          }
          if (((*(uint64_t (**)(llvm::MCAsmParser *, size_t, size_t))(*(void *)v715 + 104))(v715, __n[0], __n[1]) & 1) == 0)
          {
            (*(void (**)(void, uint64_t))(**((void **)v715 + 1) + 160))(*((void *)v715 + 1), v44);
            if (!*(unsigned char *)(*((void *)v715 + 1) + 64)) {
              (*(void (**)(void, uint64_t, char *))(**((void **)v715 + 28) + 192))(*((void *)v715 + 28), v44, v725);
            }
            if (sub_1CD37ABFC(v715))
            {
              uint64_t v140 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
              uint64_t v141 = (uint64_t *)(*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 32))(v715);
              llvm::MCGenDwarfLabelEntry::Make(v44, v140, v141, (unint64_t *)&v725);
            }
            (*(void (**)(void, uint64_t))(**((void **)v715 + 1) + 168))(*((void *)v715 + 1), v44);
          }
          goto LABEL_152;
        }
        long long v113 = v725;
        unsigned int v129 = "invalid use of pseudo-symbol '.' as a label";
LABEL_239:
        *(void *)int __dst = v129;
        *(_WORD *)&__dst[32] = 259;
        uint64_t v114 = (uint64_t)v715;
        goto LABEL_279;
      }
      if (*((unsigned char *)v715 + 424))
      {
        uint64_t v55 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 48))(v715);
        size_t v54 = __n[1];
        uint64_t v56 = *(unsigned int *)(v55 + 1976);
        if (v56)
        {
          unint64_t v57 = (const void *)__n[0];
          int v58 = 0;
          if (__n[1])
          {
            size_t v59 = __n[1];
            uint64_t v60 = (unsigned __int8 *)__n[0];
            do
            {
              int v61 = *v60++;
              int v58 = 33 * v58 + v61;
              --v59;
            }
            while (v59);
          }
          unsigned int v62 = v56 - 1;
          uint64_t v63 = *(void *)(v55 + 1968);
          uint64_t v64 = v63 + 8 * v56 + 8;
          __pa = (void *)*(unsigned int *)(v55 + 1976);
          uint64_t __s1a = *(unsigned int *)(v55 + 1988);
          int v65 = 1;
          int v66 = v58;
          while (1)
          {
            uint64_t v67 = v66 & v62;
            unint64_t v68 = *(void **)(v63 + 8 * v67);
            if (v68 != (void *)-8)
            {
              if (!v68)
              {
                int64_t v34 = v715;
                goto LABEL_113;
              }
              if (*(_DWORD *)(v64 + 4 * v67) == v58 && v54 == *v68 && (!v54 || !memcmp(v57, (char *)v68 + __s1a, v54))) {
                break;
              }
            }
            int v66 = v65 + v67;
            ++v65;
          }
          int64_t v34 = v715;
          if (v67 != -1 && (void *)(int)v67 != __pa)
          {
            if (dword_1EBD0DC30 == (uint64_t)(*((void *)v715 + 45) - *((void *)v715 + 44)) >> 3)
            {
              sub_1CBF4C1CC((uint64_t)__dst);
              sub_1CBF435C4(__dst, (uint64_t)"macros cannot be nested more than ", 34);
              unsigned int v145 = (void *)std::ostream::operator<<();
              unsigned int v146 = sub_1CBF435C4(v145, (uint64_t)" levels deep.", 13);
              sub_1CBF435C4(v146, (uint64_t)" Use -asm-macro-max-nesting-depth to increase this limit.", 57);
              std::stringbuf::str();
              LOWORD(v748) = 260;
              *(void *)v747 = v730;
              uint64_t v9 = llvm::MCAsmParser::TokError((uint64_t)v715, (uint64_t)v747, 0, 0);
              if (SHIBYTE(v731[0]) < 0) {
                operator delete((void *)v730[0]);
              }
              sub_1CD45577C((uint64_t)__dst, MEMORY[0x1E4FBA418]);
              MEMORY[0x1D25D9C00](&v795);
            }
            else
            {
              int v115 = *(uint64_t **)(v63 + 8 * (int)v67);
              v744[1] = 0;
              v744[0] = 0;
              v745 = 0;
              uint64_t v9 = 1;
              if ((sub_1CD37D15C((uint64_t)v715, v115 + 1, (uint64_t *)v744) & 1) == 0)
              {
                *(void *)int __dst = &__dst[24];
                *(_OWORD *)&__dst[8] = xmmword_1CD96DBF0;
                unint64_t v116 = (char *)v115[3];
                size_t v117 = v115[4];
                *(_DWORD *)&v747[8] = 0;
                BYTE8(v748) = 0;
                unint64_t v749 = 0;
                int v751 = __dst;
                LODWORD(v750) = 0;
                *(void *)v747 = &unk_1F2646FA8;
                *(_OWORD *)&v747[16] = 0uLL;
                *(void *)&long long v748 = 0;
                uint64_t v118 = v115[5];
                uint64_t v119 = 0xAAAAAAAAAAAAAAABLL * ((v115[6] - v118) >> 4);
                uint64_t v120 = v744[0];
                unint64_t v121 = 0xAAAAAAAAAAAAAAABLL * (((char *)v744[1] - (char *)v744[0]) >> 3);
                uint64_t v122 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715);
                uint64_t v9 = sub_1CD37DA74((uint64_t)v715, (llvm::raw_ostream *)v747, v116, v117, v118, v119, (uint64_t)v120, v121, 1, *(void *)(*(void *)(v122 + 8) + 8));
                if ((v9 & 1) == 0)
                {
                  unsigned int v148 = (void *)v748;
                  if (*(void *)&v747[24] - (void)v748 > 9uLL)
                  {
                    *(_WORD *)(v748 + 8) = 2671;
                    *unsigned int v148 = *(void *)".endmacro\n";
                    *(void *)&long long v748 = v748 + 10;
                  }
                  else
                  {
                    llvm::raw_ostream::write((llvm::raw_ostream *)v747, ".endmacro\n", 0xAuLL);
                  }
                  unsigned int v149 = *(const void **)v751;
                  uint64_t v150 = (llvm::WritableMemoryBuffer *)*((void *)v751 + 1);
                  v730[0] = (size_t)"<instantiation>";
                  LOWORD(v731[2]) = 259;
                  sub_1CD0963EC(v150, v149, (const void ***)v730, (uint64_t)v786);
                  operator new();
                }
                *(void *)v747 = &unk_1F2646B98;
                if (v750 == 1 && *(void *)&v747[16]) {
                  MEMORY[0x1D25D9CB0](*(void *)&v747[16], 0x1000C8077774924);
                }
                if (*(unsigned char **)__dst != &__dst[24]) {
                  free(*(void **)__dst);
                }
              }
              *(void *)int __dst = v744;
              sub_1CD37EB34((void ***)__dst);
            }
            goto LABEL_281;
          }
        }
      }
      else
      {
        size_t v54 = __n[1];
      }
LABEL_113:
      if (v54 < 2 || *(unsigned char *)__n[0] != 46)
      {
        if (!*((unsigned char *)v34 + 805)) {
          goto LABEL_208;
        }
        switch(v54)
        {
          case 4uLL:
            if (*(_DWORD *)__n[0] == 1852143205 || *(_DWORD *)__n[0] == 1313166917)
            {
              uint64_t v130 = *(void *)(v700 + 88);
              *(_DWORD *)int __dst = 1;
              *(_DWORD *)v747 = 4;
              sub_1CD8F39B4(v130, (int *)__dst, (uint64_t *)&v725, (int *)v747);
            }
            break;
          case 6uLL:
            if (*(_DWORD *)__n[0] == 1835360095 && *(_WORD *)(__n[0] + 4) == 29801) {
              goto LABEL_202;
            }
            if (*(_DWORD *)__n[0] == 1296392031 && *(_WORD *)(__n[0] + 4) == 21577) {
              goto LABEL_202;
            }
            break;
          case 5uLL:
            BOOL v75 = *(_DWORD *)__n[0] == 1768777055 && *(unsigned char *)(__n[0] + 4) == 116;
            if (!v75 && (*(_DWORD *)__n[0] != 1229800799 || *(unsigned char *)(__n[0] + 4) != 84))
            {
              if ((*(_DWORD *)__n[0] != 1734962273 || *(unsigned char *)(__n[0] + 4) != 110)
                && (*(_DWORD *)__n[0] != 1195985985 || *(unsigned char *)(__n[0] + 4) != 78))
              {
                break;
              }
              *(void *)v747 = v725;
              v730[0] = 0;
              uint64_t v79 = *(char **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v34 + 40))(v34) + 96);
              *(void *)int __dst = 0;
              if ((*(uint64_t (**)(llvm::MCAsmParser *, size_t *, unsigned char *))(*(void *)v34 + 232))(v34, v730, __dst))goto LABEL_217; {
              if (*(unsigned char *)v730[0] == 1)
              }
              {
                unint64_t v80 = *(void *)(v730[0] + 16);
                uint8x8_t v81 = (uint8x8_t)vcnt_s8((int8x8_t)v80);
                v81.i16[0] = vaddlv_u8(v81);
                if (v81.u32[0] == 1)
                {
                  uint64_t v82 = *(void *)(v700 + 88);
                  *(_DWORD *)int __dst = 0;
                  *(_DWORD *)int v786 = 5;
                  LODWORD(v744[0]) = 63 - __clz(v80);
                  sub_1CD8F47BC(v82, (int *)__dst, (uint64_t *)v747, (int *)v786, (unsigned int *)v744);
                  goto LABEL_152;
                }
                unsigned int v151 = "literal value not a power of two greater then zero";
              }
              else
              {
                unsigned int v151 = "unexpected expression in align";
              }
              *(void *)int __dst = v151;
              *(_WORD *)&__dst[32] = 259;
              uint64_t v114 = (uint64_t)v715;
              goto LABEL_266;
            }
LABEL_202:
            *(void *)v747 = v725;
            v730[0] = v54;
            *(void *)int v786 = 0;
            uint64_t v79 = *(char **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v34 + 40))(v34) + 96);
            *(void *)int __dst = 0;
            if ((*(uint64_t (**)(llvm::MCAsmParser *, unsigned char *, unsigned char *))(*(void *)v34 + 232))(v34, v786, __dst))goto LABEL_217; {
            if (**(unsigned char **)v786 == 1)
            }
            {
              if ((unint64_t)(*(void *)(*(void *)v786 + 16) + 128) < 0x180)
              {
                uint64_t v110 = *(void *)(v700 + 88);
                *(_DWORD *)int __dst = 2;
                sub_1CD8F4680(v110, (int *)__dst, (uint64_t *)v747, (uint64_t *)v730);
                goto LABEL_152;
              }
              uint64_t v138 = "literal value out of range for directive";
            }
            else
            {
              uint64_t v138 = "unexpected expression in _emit";
            }
            *(void *)int __dst = v138;
            *(_WORD *)&__dst[32] = 259;
            uint64_t v114 = (uint64_t)v34;
LABEL_266:
            long long v113 = v79;
            goto LABEL_279;
          default:
            break;
        }
LABEL_208:
        if (((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v34 + 264))(v34) & 1) == 0)
        {
          long long v716 = v726;
          uint64_t v717 = v727;
          unsigned int v111 = v729;
          unsigned int v719 = v729;
          if (v729 > 0x40) {
            operator new[]();
          }
          long long v112 = __src;
          uint64_t v718 = __src;
          uint64_t v9 = sub_1CD37CA70((uint64_t)v715, v700, __n[0], __n[1], &v716, v725);
          if (v111 >= 0x41 && v112) {
            MEMORY[0x1D25D9CB0](v112, 0x1000C8000313F17);
          }
          goto LABEL_281;
        }
        goto LABEL_217;
      }
      uint64_t v69 = *((void *)v34 + 1);
      uint64_t v70 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v34 + 56))(v34);
      (*(void (**)(uint64_t, uint64_t))(*(void *)v69 + 176))(v69, v70);
      uint64_t v71 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v34 + 40))(v34);
      uint64_t v72 = v34;
      uint64_t v73 = *(void *)(*(void *)(v71 + 8) + 8);
      uint64_t v74 = *((void *)v72 + 1);
      uint64_t v721 = v727;
      long long v720 = v726;
      unsigned int v723 = v729;
      if (v729 > 0x40) {
        operator new[]();
      }
      uint64_t v722 = __src;
      int v94 = (*(uint64_t (**)(uint64_t, long long *))(*(void *)v74 + 64))(v74, &v720);
      int v95 = v94;
      if (v723 >= 0x41 && v722) {
        MEMORY[0x1D25D9CB0](v722, 0x1000C8000313F17);
      }
      int v96 = *((_DWORD *)v715 + 6);
      uint64_t v9 = v96 != 0;
      if (v96 || ((v95 ^ 1) & 1) != 0) {
        goto LABEL_281;
      }
      if (*(void *)(*(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8)
                     + 8) != v73)
        goto LABEL_217;
      if (*(void *)(*(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8)
                     + 8) != v73)
        goto LABEL_152;
      size_t v97 = __n[1];
      __s1b = (_WORD *)__n[0];
      uint64_t v98 = *((unsigned int *)v715 + 82);
      if (v98)
      {
        int v99 = 0;
        if (__n[1])
        {
          size_t v100 = __n[1];
          uint64_t v101 = (unsigned __int8 *)__n[0];
          do
          {
            int v102 = *v101++;
            int v99 = 33 * v99 + v102;
            --v100;
          }
          while (v100);
        }
        uint64_t v103 = *((void *)v715 + 40);
        int v104 = 1;
        int v105 = v99;
        while (1)
        {
          uint64_t v106 = v105 & (v98 - 1);
          long long v107 = *(void **)(v103 + 8 * v106);
          if (v107 != (void *)-8)
          {
            if (!v107) {
              goto LABEL_261;
            }
            if (*(_DWORD *)(v103 + 8 * v98 + 8 + 4 * v106) == v99
              && v97 == *v107
              && (!v97 || !memcmp(__s1b, (char *)v107 + *((unsigned int *)v715 + 85), v97)))
            {
              break;
            }
          }
          int v105 = v104 + v106;
          ++v104;
        }
        if (v106 != -1 && (int)v106 != v98)
        {
          uint64_t v142 = *(void *)(v103 + 8 * (int)v106);
          uint64_t v143 = *(void *)(v142 + 8);
          if (v143)
          {
            uint64_t v53 = (*(uint64_t (**)(uint64_t, _WORD *, size_t, char *))(v142 + 16))(v143, __s1b, v97, v725);
            goto LABEL_280;
          }
        }
      }
LABEL_261:
      switch(v35)
      {
        case 1:
        case 2:
          __int16 v169 = v715;
          unsigned int v170 = 0;
          goto LABEL_621;
        case 3:
          __int16 v169 = v715;
          unsigned int v170 = 1;
          goto LABEL_621;
        case 4:
          v747[0] = 0;
          goto LABEL_509;
        case 5:
        case 6:
          v747[0] = 1;
LABEL_509:
          uint64_t v163 = v715;
          *(void *)int __dst = v715;
          *(void *)&__dst[8] = v747;
          uint64_t v164 = (uint64_t (*)(uint64_t))sub_1CD37EBA8;
          goto LABEL_582;
        case 7:
        case 20:
          int v144 = 1;
          goto LABEL_305;
        case 8:
        case 10:
        case 11:
        case 18:
        case 24:
          int v144 = 2;
          goto LABEL_305;
        case 9:
          v730[0] = 0;
          *(void *)int v786 = 0;
          uint64_t v236 = *(void *)(*((void *)v715 + 6) + 8);
          *(void *)int __dst = 0;
          if ((*(uint64_t (**)(llvm::MCAsmParser *, size_t *, unsigned char *))(*(void *)v715 + 232))(v715, v730, __dst))goto LABEL_217; {
          *(void *)int __dst = "expected comma";
          }
          *(_WORD *)&__dst[32] = 259;
          if (llvm::MCAsmParser::parseToken(v715, 25, (llvm::Twine *)__dst)) {
            goto LABEL_217;
          }
          int v237 = **(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8);
          *(void *)int __dst = "expected relocation name";
          *(_WORD *)&__dst[32] = 259;
          llvm::MCAsmParser::check(v715, v237 != 2, (const llvm::Twine *)__dst);
          if (v237 != 2) {
            goto LABEL_217;
          }
          uint64_t v238 = *((void *)*v7 + 1);
          (*(void (**)(llvm::MCAsmParser *))(*(void *)v715 + 184))(v715);
          if (**((_DWORD **)v715 + 6) != 25) {
            goto LABEL_482;
          }
          (*(void (**)(llvm::MCAsmParser *))(*(void *)v715 + 184))(v715);
          uint64_t v239 = (char *)*((void *)v715 + 17);
          *(void *)int __dst = 0;
          if ((*(uint64_t (**)(llvm::MCAsmParser *, unsigned char *, unsigned char *))(*(void *)v715 + 232))(v715, v786, __dst))goto LABEL_217; {
          memset(v747, 0, 28);
          }
          if (!llvm::MCExpr::evaluateAsRelocatableImpl(*(uint64_t *)v786, (uint64_t)v747, 0, 0, 0, 0, 0))
          {
            *(void *)int __dst = "expression must be relocatable";
            *(_WORD *)&__dst[32] = 259;
            uint64_t v114 = (uint64_t)v715;
            long long v113 = v239;
            goto LABEL_279;
          }
LABEL_482:
          if (llvm::MCAsmParser::parseEOL(v715)) {
            goto LABEL_217;
          }
          uint64_t v240 = *(void *)(*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
          (*(void (**)(unsigned char *__return_ptr))(v240 + 1168))(__dst);
          if (!__dst[32]) {
            goto LABEL_152;
          }
          if (__dst[0]) {
            uint64_t v241 = v238;
          }
          else {
            uint64_t v241 = v236;
          }
          LOWORD(v748) = 260;
          *(void *)v747 = &__dst[8];
          uint64_t v9 = llvm::MCAsmParser::Error((uint64_t)v715, v241, (uint64_t)v747, 0, 0);
          if (__dst[32] && (__dst[31] & 0x80000000) != 0)
          {
            uint64_t v242 = *(char **)&__dst[8];
            goto LABEL_646;
          }
          goto LABEL_281;
        case 12:
        case 13:
        case 14:
        case 22:
          int v144 = 4;
          goto LABEL_305;
        case 15:
        case 16:
          int v144 = 8;
LABEL_305:
          *(_DWORD *)v747 = v144;
          uint64_t v163 = v715;
          *(void *)int __dst = v715;
          *(void *)&__dst[8] = v747;
          uint64_t v164 = sub_1CD37ED8C;
          goto LABEL_582;
        case 17:
          uint64_t v163 = v715;
          *(void *)int __dst = v715;
          uint64_t v164 = (uint64_t (*)(uint64_t))sub_1CD37EFBC;
          goto LABEL_582;
        case 19:
          *(_DWORD *)v747 = *(_DWORD *)(*(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 48))(v715)
                                                  + 152)
                                      + 8);
          *(void *)int __dst = v715;
          *(void *)&__dst[8] = v747;
          uint64_t v260 = sub_1CD37ED8C;
          uint64_t v163 = v715;
          goto LABEL_583;
        case 21:
        case 43:
          uint64_t v153 = &unk_1CFB2E31C;
          goto LABEL_298;
        case 23:
        case 41:
        case 42:
          uint64_t v153 = &unk_1CFB2E308;
LABEL_298:
          uint64_t v163 = v715;
          *(void *)int __dst = v715;
          *(void *)&__dst[8] = v153;
          uint64_t v164 = sub_1CD37F4FC;
          goto LABEL_582;
        case 25:
        case 32:
        case 77:
        case 78:
          *(void *)int __dst = __s1b;
          *(void *)&__dst[8] = v97;
          *(void *)&__dst[16] = " not currently supported for this target";
          __int16 v303 = 773;
          goto LABEL_871;
        case 26:
        case 31:
          long long v165 = v715;
          uint64_t v166 = (uint64_t)__s1b;
          uint64_t v167 = v97;
          uint64_t v168 = 2;
          goto LABEL_546;
        case 27:
          long long v165 = v715;
          uint64_t v166 = (uint64_t)__s1b;
          uint64_t v167 = v97;
          uint64_t v168 = 1;
          goto LABEL_546;
        case 28:
          uint64_t v233 = &unk_1CFB2E31C;
          goto LABEL_500;
        case 29:
          long long v165 = v715;
          uint64_t v166 = (uint64_t)__s1b;
          uint64_t v167 = v97;
          uint64_t v168 = 4;
LABEL_546:
          uint64_t v53 = sub_1CD37C308(v165, v166, v167, v168);
          goto LABEL_280;
        case 30:
          uint64_t v233 = &unk_1CFB2E308;
LABEL_500:
          uint64_t v53 = sub_1CD37C630(v715, (uint64_t)__s1b, v97, (uint64_t)v233);
          goto LABEL_280;
        case 33:
        case 39:
          uint64_t v157 = v715;
          uint64_t v158 = (uint64_t)__s1b;
          uint64_t v159 = v97;
          unsigned int v160 = 2;
          goto LABEL_548;
        case 34:
          uint64_t v157 = v715;
          uint64_t v158 = (uint64_t)__s1b;
          uint64_t v159 = v97;
          unsigned int v160 = 1;
          goto LABEL_548;
        case 35:
          uint64_t v157 = v715;
          uint64_t v158 = (uint64_t)__s1b;
          uint64_t v159 = v97;
          unsigned int v160 = 8;
          goto LABEL_548;
        case 36:
        case 38:
          uint64_t v157 = v715;
          uint64_t v158 = (uint64_t)__s1b;
          uint64_t v159 = v97;
          unsigned int v160 = 4;
          goto LABEL_548;
        case 37:
        case 40:
          uint64_t v157 = v715;
          uint64_t v158 = (uint64_t)__s1b;
          uint64_t v159 = v97;
          unsigned int v160 = 12;
LABEL_548:
          uint64_t v53 = sub_1CD37C8E4(v157, v158, v159, v160);
          goto LABEL_280;
        case 44:
          BOOL v229 = *(unsigned char *)(*(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 48))(v715)
                                      + 152)
                          + 339) == 0;
          unsigned int v228 = v715;
          goto LABEL_498;
        case 45:
          BOOL v229 = *(unsigned char *)(*(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 48))(v715)
                                      + 152)
                          + 339) == 0;
          unsigned int v228 = v715;
          goto LABEL_538;
        case 46:
          unsigned int v228 = v715;
          BOOL v229 = 0;
          goto LABEL_498;
        case 47:
          unsigned int v228 = v715;
          BOOL v229 = 0;
          goto LABEL_563;
        case 48:
          unsigned int v228 = v715;
          BOOL v229 = 0;
          goto LABEL_538;
        case 49:
          unsigned int v228 = v715;
          BOOL v229 = 1;
LABEL_498:
          uint64_t v246 = 1;
          goto LABEL_564;
        case 50:
          unsigned int v228 = v715;
          BOOL v229 = 1;
LABEL_563:
          uint64_t v246 = 2;
          goto LABEL_564;
        case 51:
          unsigned int v228 = v715;
          BOOL v229 = 1;
LABEL_538:
          uint64_t v246 = 4;
LABEL_564:
          uint64_t v53 = sub_1CD37B424(v228, v229, v246);
          goto LABEL_280;
        case 52:
          uint64_t v257 = *((void *)v715 + 17);
          if ((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 264))(v715)) {
            goto LABEL_217;
          }
          *(void *)v747 = 0;
          *(void *)int __dst = 0;
          if ((*(uint64_t (**)(llvm::MCAsmParser *, unsigned char *, unsigned char *))(*(void *)v715 + 232))(v715, v747, __dst))goto LABEL_217; {
          *(void *)int __dst = 0;
          }
          if (llvm::MCAsmParser::parseOptionalToken(v715, 25)
            && ((*(uint64_t (**)(llvm::MCAsmParser *, unsigned char *))(*(void *)v715 + 256))(v715, __dst) & 1) != 0)
          {
            goto LABEL_217;
          }
          if (llvm::MCAsmParser::parseEOL(v715)) {
            goto LABEL_217;
          }
          uint64_t v258 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
          (*(void (**)(uint64_t, void, void, uint64_t))(*(void *)v258 + 656))(v258, *(void *)v747, __dst[0], v257);
          goto LABEL_152;
        case 53:
          uint64_t v243 = *((void *)v715 + 17);
          if ((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 264))(v715)) {
            goto LABEL_217;
          }
          *(void *)v747 = 0;
          *(void *)int __dst = 0;
          if ((*(uint64_t (**)(llvm::MCAsmParser *, unsigned char *, unsigned char *))(*(void *)v715 + 232))(v715, v747, __dst))goto LABEL_217; {
          v730[0] = 1;
          }
          *(void *)int v786 = 0;
          if (llvm::MCAsmParser::parseOptionalToken(v715, 25))
          {
            uint64_t v244 = *(void *)(*(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715)
                                         + 8)
                             + 8);
            if ((*(uint64_t (**)(llvm::MCAsmParser *, size_t *))(*(void *)v715 + 256))(v715, v730)) {
              goto LABEL_217;
            }
            if (llvm::MCAsmParser::parseOptionalToken(v715, 25))
            {
              uint64_t v245 = *(void *)(*(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715)
                                           + 8)
                               + 8);
              if ((*(uint64_t (**)(llvm::MCAsmParser *, unsigned char *))(*(void *)v715 + 256))(v715, v786)) {
                goto LABEL_217;
              }
            }
            else
            {
              uint64_t v245 = 0;
            }
          }
          else
          {
            uint64_t v245 = 0;
            uint64_t v244 = 0;
          }
          if (llvm::MCAsmParser::parseEOL(v715)) {
            goto LABEL_217;
          }
          size_t v603 = v730[0];
          if ((v730[0] & 0x8000000000000000) != 0)
          {
            *(void *)int __dst = "'.fill' directive with negative size has no effect";
            *(_WORD *)&__dst[32] = 259;
            (*(void (**)(llvm::MCAsmParser *, uint64_t, unsigned char *, void, void))(*(void *)v715 + 168))(v715, v244, __dst, 0, 0);
          }
          else
          {
            if (v730[0] >= 9)
            {
              *(void *)int __dst = "'.fill' directive with size greater than 8 has been truncated to 8";
              *(_WORD *)&__dst[32] = 259;
              (*(void (**)(llvm::MCAsmParser *, uint64_t, unsigned char *, void, void))(*(void *)v715 + 168))(v715, v244, __dst, 0, 0);
              size_t v603 = 8;
              v730[0] = 8;
            }
            if (v603 >= 5 && *(_DWORD *)&v786[4])
            {
              *(void *)int __dst = "'.fill' directive pattern has been truncated to 32-bits";
              *(_WORD *)&__dst[32] = 259;
              (*(void (**)(llvm::MCAsmParser *, uint64_t, unsigned char *, void, void))(*(void *)v715 + 168))(v715, v245, __dst, 0, 0);
            }
            uint64_t v604 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
            (*(void (**)(uint64_t, void, size_t, void, uint64_t))(*(void *)v604 + 624))(v604, *(void *)v747, v730[0], *(void *)v786, v243);
          }
          goto LABEL_152;
        case 54:
          if (*((void *)v715 + 44) != *((void *)v715 + 45)) {
            goto LABEL_468;
          }
          int v280 = "unmatched '.endr' directive";
          goto LABEL_870;
        case 55:
          uint64_t v212 = *(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 96);
          if ((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 264))(v715)) {
            goto LABEL_217;
          }
          *(void *)v747 = 0;
          if (((*(uint64_t (**)(llvm::MCAsmParser *, unsigned char *))(*(void *)v715 + 256))(v715, v747) & 1) != 0
            || llvm::MCAsmParser::parseEOL(v715))
          {
            goto LABEL_217;
          }
          *(void *)int __dst = "invalid bundle alignment size (expected between 0 and 30)";
          *(_WORD *)&__dst[32] = 259;
          if (*(void *)v747 >= 0x1FuLL) {
            goto LABEL_1160;
          }
          uint64_t v213 = *(void *)(*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
          (*(void (**)(void))(v213 + 1208))();
          goto LABEL_152;
        case 56:
          if ((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 264))(v715)) {
            goto LABEL_217;
          }
          v730[0] = 0;
          v730[1] = 0;
          uint64_t v212 = *(void *)(*(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715)
                                       + 8)
                           + 8);
          BOOL v230 = llvm::MCAsmParser::parseOptionalToken(v715, 9);
          if (v230) {
            goto LABEL_461;
          }
          int v567 = (*(uint64_t (**)(llvm::MCAsmParser *, size_t *))(*(void *)v715 + 192))(v715, v730);
          *(void *)int __dst = "invalid option for '.bundle_lock' directive";
          *(_WORD *)&__dst[32] = 259;
          if (v567)
          {
LABEL_1160:
            int v248 = __dst;
            goto LABEL_1276;
          }
          if (v730[1] == 12)
          {
            BOOL v602 = *(void *)v730[0] == 0x6F745F6E67696C61 && *(_DWORD *)(v730[0] + 8) == 1684956511;
            *(void *)v747 = "invalid option for '.bundle_lock' directive";
            LOWORD(v748) = 259;
            if (v602)
            {
              if (!llvm::MCAsmParser::parseEOL(v715))
              {
LABEL_461:
                uint64_t v231 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
                (*(void (**)(uint64_t, BOOL))(*(void *)v231 + 1216))(v231, !v230);
                goto LABEL_152;
              }
              goto LABEL_217;
            }
          }
          else
          {
            *(void *)v747 = "invalid option for '.bundle_lock' directive";
            LOWORD(v748) = 259;
          }
LABEL_1275:
          int v248 = v747;
          goto LABEL_1276;
        case 57:
          if (((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 264))(v715) & 1) != 0
            || llvm::MCAsmParser::parseEOL(v715))
          {
            goto LABEL_217;
          }
          uint64_t v232 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
          (*(void (**)(uint64_t))(*(void *)v232 + 1224))(v232);
          goto LABEL_152;
        case 58:
          uint64_t v155 = *((void *)v715 + 17);
          if ((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 264))(v715)) {
            goto LABEL_217;
          }
          *(void *)v747 = 0;
          *(void *)int __dst = 0;
          if ((*(uint64_t (**)(llvm::MCAsmParser *, unsigned char *, unsigned char *))(*(void *)v715 + 232))(v715, v747, __dst))goto LABEL_217; {
          *(void *)int __dst = 0;
          }
          if (**(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8) != 25) {
            goto LABEL_571;
          }
          (*(void (**)(llvm::MCAsmParser *))(*(void *)v715 + 184))(v715);
          unsigned int v156 = *(uint64_t (**)(void))(*(void *)v715 + 256);
          goto LABEL_570;
        case 59:
          goto LABEL_475;
        case 60:
        case 61:
          int v171 = 9;
          goto LABEL_581;
        case 62:
          int v171 = 15;
          goto LABEL_581;
        case 63:
          int v171 = 17;
          goto LABEL_581;
        case 64:
          int v171 = 18;
          goto LABEL_581;
        case 65:
          int v171 = 20;
          goto LABEL_581;
        case 66:
          int v171 = 22;
          goto LABEL_581;
        case 67:
          int v171 = 24;
          goto LABEL_581;
        case 68:
          int v171 = 25;
          goto LABEL_581;
        case 69:
          int v171 = 26;
          goto LABEL_581;
        case 70:
          int v171 = 1;
LABEL_581:
          *(_DWORD *)v747 = v171;
          uint64_t v163 = v715;
          *(void *)int __dst = v715;
          *(void *)&__dst[8] = v747;
          uint64_t v164 = sub_1CD37FBD0;
LABEL_582:
          uint64_t v260 = v164;
          goto LABEL_583;
        case 71:
        case 72:
          uint64_t v161 = v715;
          int v162 = 0;
          goto LABEL_558;
        case 73:
          uint64_t v161 = v715;
          int v162 = 1;
LABEL_558:
          uint64_t v53 = sub_1CD37B9E4(v161, v162);
          goto LABEL_280;
        case 74:
          unint64_t v123 = *(char **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 96);
          uint64_t v359 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 200))(v715);
          uint64_t v361 = v360;
          if (llvm::MCAsmParser::parseEOL(v715)) {
            goto LABEL_217;
          }
          if (!v361)
          {
            uint64_t v283 = ".abort detected. Assembly stopping.";
            goto LABEL_776;
          }
          LOWORD(v748) = 1283;
          *(void *)v747 = ".abort '";
          *(void *)&v747[16] = v359;
          *(void *)&v747[24] = v361;
          *(void *)int __dst = v747;
          *(void *)&__dst[16] = "' detected. Assembly stopping.";
          __int16 v362 = 770;
          goto LABEL_1176;
        case 75:
          memset(v786, 0, 24);
          uint64_t v412 = *(void *)(*(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715)
                                       + 8)
                           + 8);
          int v413 = **(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8);
          *(void *)int __dst = "expected string in '.include' directive";
          *(_WORD *)&__dst[32] = 259;
          llvm::MCAsmParser::check(v715, v413 != 3, (const llvm::Twine *)__dst);
          if (v413 != 3
            || ((*(uint64_t (**)(llvm::MCAsmParser *, unsigned char *))(*(void *)v715 + 208))(v715, v786) & 1) != 0
            || (int v594 = **(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8),
                *(void *)v747 = "unexpected token in '.include' directive",
                LOWORD(v748) = 259,
                llvm::MCAsmParser::check(v715, v594 != 9, (const llvm::Twine *)v747),
                v594 != 9))
          {
            uint64_t v9 = 1;
            goto LABEL_857;
          }
          v730[0] = 0;
          v730[1] = 0;
          v731[0] = 0;
          int v595 = llvm::SourceMgr::AddIncludeFile(*((void **)v715 + 30), (uint64_t)v786, *((void *)v715 + 17), (std::string *)v730);
          int v596 = v595;
          uint64_t v9 = v595 == 0;
          if (v595)
          {
            *((_DWORD *)v715 + 70) = v595;
            uint64_t v597 = *(void *)(**((void **)v715 + 30) + 24 * (v595 - 1));
            uint64_t v598 = *(void *)(v597 + 8);
            uint64_t v599 = *(void *)(v597 + 16) - v598;
            *((void *)v715 + 24) = v598;
            *((void *)v715 + 25) = v599;
            *((void *)v715 + 23) = v598;
            *((void *)v715 + 17) = 0;
            *((unsigned char *)v715 + 211) = 1;
          }
          if (SHIBYTE(v731[0]) < 0) {
            operator delete((void *)v730[0]);
          }
          std::operator+<char>();
          unsigned int v600 = std::string::append(&v741, "'");
          unsigned int v601 = (const char *)v600->__r_.__value_.__r.__words[2];
          *(_OWORD *)int v744 = *(_OWORD *)&v600->__r_.__value_.__l.__data_;
          v745 = v601;
          v600->__r_.__value_.__l.__size_ = 0;
          v600->__r_.__value_.__r.__words[2] = 0;
          v600->__r_.__value_.__r.__words[0] = 0;
          LOWORD(v731[2]) = 260;
          v730[0] = (size_t)v744;
          if (!v596) {
            llvm::MCAsmParser::Error((uint64_t)v715, v412, (uint64_t)v730, 0, 0);
          }
          if (SHIBYTE(v745) < 0) {
            operator delete(v744[0]);
          }
          if ((SHIBYTE(v741.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_857;
          }
          uint64_t v367 = (void *)v741.__r_.__value_.__r.__words[0];
          goto LABEL_786;
        case 76:
          v730[0] = 0;
          v730[1] = 0;
          v731[0] = 0;
          uint64_t v380 = *(void *)(*(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715)
                                       + 8)
                           + 8);
          int v381 = **(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8);
          *(void *)int __dst = "expected string in '.incbin' directive";
          *(_WORD *)&__dst[32] = 259;
          llvm::MCAsmParser::check(v715, v381 != 3, (const llvm::Twine *)__dst);
          if (v381 != 3
            || ((*(uint64_t (**)(llvm::MCAsmParser *, size_t *))(*(void *)v715 + 208))(v715, v730) & 1) != 0)
          {
            goto LABEL_643;
          }
          v744[0] = 0;
          v741.__r_.__value_.__r.__words[0] = 0;
          if (llvm::MCAsmParser::parseOptionalToken(v715, 25))
          {
            if (**(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8) == 25)
            {
              uint64_t v382 = 0;
            }
            else
            {
              uint64_t v382 = *(void *)(*(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715)
                                           + 8)
                               + 8);
              if ((*(uint64_t (**)(llvm::MCAsmParser *, void **))(*(void *)v715 + 256))(v715, v744)) {
                goto LABEL_643;
              }
            }
            if (llvm::MCAsmParser::parseOptionalToken(v715, 25))
            {
              uint64_t v632 = *(void *)(*(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715)
                                           + 8)
                               + 8);
              *(void *)int __dst = 0;
              if ((*(uint64_t (**)(llvm::MCAsmParser *, std::string *, unsigned char *))(*(void *)v715 + 232))(v715, &v741, __dst))goto LABEL_643; {
LABEL_1336:
              }
              if (llvm::MCAsmParser::parseEOL(v715)) {
                goto LABEL_643;
              }
              uint64_t v633 = (char *)v744[0];
              *(void *)int __dst = "skip is negative";
              *(_WORD *)&__dst[32] = 259;
              if (((unint64_t)v744[0] & 0x8000000000000000) != 0)
              {
                llvm::MCAsmParser::Error((uint64_t)v715, v382, (uint64_t)__dst, 0, 0);
                goto LABEL_643;
              }
              uint64_t v669 = v741.__r_.__value_.__r.__words[0];
              memset(v747, 0, 24);
              int v670 = llvm::SourceMgr::AddIncludeFile(*((void **)v715 + 30), (uint64_t)v730, *((void *)v715 + 17), (std::string *)v747);
              if (!v670)
              {
                int v680 = 1;
                goto LABEL_1492;
              }
              uint64_t v671 = *(void *)(**((void **)v715 + 30) + 24 * (v670 - 1));
              uint64_t v672 = *(void *)(v671 + 8);
              unint64_t v673 = *(void *)(v671 + 16) - v672;
              if (v673 >= (unint64_t)v633) {
                int v674 = v633;
              }
              else {
                int v674 = (char *)v673;
              }
              unint64_t v675 = v673 - (void)v674;
              if (!v669)
              {
LABEL_1457:
                uint64_t v679 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
                (*(void (**)(uint64_t, char *, unint64_t))(*(void *)v679 + 488))(v679, &v674[v672], v675);
                int v680 = 0;
                goto LABEL_1492;
              }
              uint64_t v676 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
              unsigned int v677 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)v676 + 72))(v676);
              memset(__dst, 0, 28);
              if (*(unsigned char *)v669 == 1)
              {
                unint64_t v678 = *(void *)(v669 + 16);
                if ((v678 & 0x8000000000000000) == 0)
                {
LABEL_1455:
                  if (v675 >= v678) {
                    unint64_t v675 = v678;
                  }
                  goto LABEL_1457;
                }
              }
              else
              {
                if ((llvm::MCExpr::evaluateAsRelocatableImpl(v669, (uint64_t)__dst, v677, 0, 0, 0, 0) & 1) == 0
                  || *(_OWORD *)__dst != 0)
                {
                  *(void *)int __dst = "expected absolute expression";
                  *(_WORD *)&__dst[32] = 259;
                  int v686 = llvm::MCAsmParser::Error((uint64_t)v715, v632, (uint64_t)__dst, 0, 0);
LABEL_1491:
                  int v680 = v686;
LABEL_1492:
                  if ((v747[23] & 0x80000000) != 0) {
                    operator delete(*(void **)v747);
                  }
                  if (v680)
                  {
                    std::operator+<char>();
                    uint64_t v688 = std::string::append((std::string *)v786, "'");
                    std::string::size_type v689 = v688->__r_.__value_.__r.__words[2];
                    *(_OWORD *)v747 = *(_OWORD *)&v688->__r_.__value_.__l.__data_;
                    *(void *)&v747[16] = v689;
                    v688->__r_.__value_.__l.__size_ = 0;
                    v688->__r_.__value_.__r.__words[2] = 0;
                    v688->__r_.__value_.__r.__words[0] = 0;
                    *(_WORD *)&__dst[32] = 260;
                    *(void *)int __dst = v747;
                    uint64_t v9 = llvm::MCAsmParser::Error((uint64_t)v715, v380, (uint64_t)__dst, 0, 0);
                    if ((v747[23] & 0x80000000) != 0)
                    {
                      int v628 = *(void **)v747;
LABEL_1315:
                      operator delete(v628);
                    }
                    goto LABEL_1316;
                  }
                  uint64_t v9 = 0;
LABEL_644:
                  if ((SHIBYTE(v731[0]) & 0x80000000) == 0) {
                    goto LABEL_281;
                  }
                  uint64_t v242 = (char *)v730[0];
LABEL_646:
                  operator delete(v242);
                  goto LABEL_281;
                }
                unint64_t v678 = *(void *)&__dst[16];
                if ((*(void *)&__dst[16] & 0x8000000000000000) == 0) {
                  goto LABEL_1455;
                }
              }
              *(void *)int __dst = "negative count has no effect";
              *(_WORD *)&__dst[32] = 259;
              int v686 = (*(uint64_t (**)(llvm::MCAsmParser *, uint64_t, unsigned char *, void, void))(*(void *)v715 + 168))(v715, v632, __dst, 0, 0);
              goto LABEL_1491;
            }
          }
          else
          {
            uint64_t v382 = 0;
          }
          uint64_t v632 = 0;
          goto LABEL_1336;
        case 79:
          uint64_t v249 = v725;
          v730[0] = 0;
          BOOL v247 = *(char **)(*(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715)
                                      + 8)
                          + 8);
          *(void *)int __dst = 0;
          if ((*(uint64_t (**)(llvm::MCAsmParser *, size_t *, unsigned char *))(*(void *)v715 + 232))(v715, v730, __dst))goto LABEL_217; {
          uint64_t v250 = v730[0];
          }
          uint64_t v251 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
          uint64_t v252 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)v251 + 72))(v251);
          memset(__dst, 0, 28);
          if (*(unsigned char *)v250 == 1)
          {
            uint64_t v253 = *(void *)(v250 + 16);
          }
          else
          {
            if ((llvm::MCExpr::evaluateAsRelocatableImpl(v250, (uint64_t)__dst, v252, 0, 0, 0, 0) & 1) == 0
              || *(_OWORD *)__dst != 0)
            {
              LOWORD(v748) = 1283;
              *(void *)v747 = "unexpected token in '";
              *(void *)&v747[16] = __s1b;
              *(void *)&v747[24] = v97;
              *(void *)int __dst = v747;
              *(void *)&__dst[16] = "' directive";
              *(_WORD *)&__dst[32] = 770;
              uint64_t v114 = (uint64_t)v715;
              long long v113 = v247;
              goto LABEL_279;
            }
            uint64_t v253 = *(void *)&__dst[16];
          }
          *(void *)int __dst = "Count is negative";
          *(_WORD *)&__dst[32] = 259;
          if (v253 < 0)
          {
            int v248 = __dst;
            goto LABEL_517;
          }
          if (llvm::MCAsmParser::parseEOL(v715)) {
            goto LABEL_217;
          }
          unint64_t v488 = sub_1CD37FD94((uint64_t)v715, (uint64_t)v249);
          if (!v488) {
            goto LABEL_217;
          }
          unint64_t v489 = v488;
          *(void *)int __dst = &__dst[24];
          *(_OWORD *)&__dst[8] = xmmword_1CD96DBF0;
          *(_DWORD *)&v747[8] = 0;
          BYTE8(v748) = 0;
          unint64_t v749 = 0;
          int v751 = __dst;
          LODWORD(v750) = 0;
          *(void *)v747 = &unk_1F2646FA8;
          *(_OWORD *)&v747[16] = 0uLL;
          *(void *)&long long v748 = 0;
          uint64_t v490 = v253 + 1;
          do
          {
            uint64_t v9 = --v490 != 0;
            if (!v490) {
              sub_1CD380440((int)v715, (int)v249, (llvm::raw_ostream *)v747);
            }
            uint64_t v491 = *(char **)(v489 + 16);
            size_t v492 = *(void *)(v489 + 24);
            uint64_t v493 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715);
          }
          while ((sub_1CD37DA74((uint64_t)v715, (llvm::raw_ostream *)v747, v491, v492, 0, 0, 0, 0, 0, *(void *)(*(void *)(v493 + 8) + 8)) & 1) == 0);
          *(void *)v747 = &unk_1F2646B98;
          if (v750 == 1 && *(void *)&v747[16]) {
            MEMORY[0x1D25D9CB0](*(void *)&v747[16], 0x1000C8077774924);
          }
          uint64_t v302 = *(void **)__dst;
          if (*(unsigned char **)__dst == &__dst[24]) {
            goto LABEL_281;
          }
          goto LABEL_650;
        case 80:
          int v373 = v725;
          *(_OWORD *)v730 = 0u;
          memset(v731, 0, 26);
          memset(v786, 0, 24);
          uint64_t v374 = (*(uint64_t (**)(llvm::MCAsmParser *, size_t *))(*(void *)v715 + 192))(v715, v730);
          char v375 = v374;
          *(void *)v747 = "expected identifier in '.irp' directive";
          LOWORD(v748) = 259;
          llvm::MCAsmParser::check(v715, v374, (const llvm::Twine *)v747);
          if ((v375 & 1) != 0
            || (*(void *)int __dst = "expected comma",
                *(_WORD *)&__dst[32] = 259,
                llvm::MCAsmParser::parseToken(v715, 25, (llvm::Twine *)__dst))
            || (sub_1CD37D15C((uint64_t)v715, 0, (uint64_t *)v786) & 1) != 0
            || llvm::MCAsmParser::parseEOL(v715)
            || (unint64_t v559 = sub_1CD37FD94((uint64_t)v715, (uint64_t)v373)) == 0)
          {
            uint64_t v9 = 1;
          }
          else
          {
            *(void *)int __dst = &__dst[24];
            *(_OWORD *)&__dst[8] = xmmword_1CD96DBF0;
            *(_DWORD *)&v747[8] = 0;
            BYTE8(v748) = 0;
            unint64_t v749 = 0;
            int v751 = __dst;
            LODWORD(v750) = 0;
            *(void *)v747 = &unk_1F2646FA8;
            *(_OWORD *)&v747[16] = 0uLL;
            *(void *)&long long v748 = 0;
            uint64_t v561 = *(void *)&v786[8];
            uint64_t v560 = *(void *)v786;
            if (*(void *)v786 == *(void *)&v786[8]) {
LABEL_1155:
            }
              sub_1CD380440((int)v715, (int)v373, (llvm::raw_ostream *)v747);
            unint64_t v562 = v559;
            uint64_t v9 = 1;
            uint64_t v563 = *(void *)v786;
            while (1)
            {
              BOOL v564 = *(char **)(v562 + 16);
              size_t v565 = *(void *)(v562 + 24);
              uint64_t v566 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715);
              if (sub_1CD37DA74((uint64_t)v715, (llvm::raw_ostream *)v747, v564, v565, (uint64_t)v730, 1, v560, 1uLL, 1, *(void *)(*(void *)(v566 + 8) + 8)))break; {
              v563 += 24;
              }
              v560 += 24;
              if (v563 == v561) {
                goto LABEL_1155;
              }
            }
            *(void *)v747 = &unk_1F2646B98;
            if (v750 == 1 && *(void *)&v747[16]) {
              MEMORY[0x1D25D9CB0](*(void *)&v747[16], 0x1000C8077774924);
            }
            if (*(unsigned char **)__dst != &__dst[24]) {
              free(*(void **)__dst);
            }
          }
          uint64_t v371 = (void **)v786;
LABEL_796:
          *(void *)int __dst = v371;
          sub_1CD37EB34((void ***)__dst);
          *(void *)int __dst = v731;
          sub_1CCBB926C((void ***)__dst);
          goto LABEL_281;
        case 81:
          int v368 = v725;
          *(_OWORD *)v730 = 0u;
          memset(v731, 0, 26);
          v744[1] = 0;
          v744[0] = 0;
          v745 = 0;
          uint64_t v369 = (*(uint64_t (**)(llvm::MCAsmParser *, size_t *))(*(void *)v715 + 192))(v715, v730);
          char v370 = v369;
          *(void *)v747 = "expected identifier in '.irpc' directive";
          LOWORD(v748) = 259;
          llvm::MCAsmParser::check(v715, v369, (const llvm::Twine *)v747);
          if (v370) {
            goto LABEL_788;
          }
          *(void *)int __dst = "expected comma";
          *(_WORD *)&__dst[32] = 259;
          if (llvm::MCAsmParser::parseToken(v715, 25, (llvm::Twine *)__dst)
            || (sub_1CD37D15C((uint64_t)v715, 0, (uint64_t *)v744) & 1) != 0)
          {
            goto LABEL_788;
          }
          if ((void *)((char *)v744[1] - (char *)v744[0]) == (void *)24
            && *((void *)v744[0] + 1) - *(void *)v744[0] == 40)
          {
            if (llvm::MCAsmParser::parseEOL(v715))
            {
LABEL_788:
              uint64_t v9 = 1;
            }
            else
            {
              unint64_t v544 = sub_1CD37FD94((uint64_t)v715, (uint64_t)v368);
              if (v544)
              {
                unint64_t v545 = v544;
                unint64_t v546 = 0;
                *(void *)int __dst = &__dst[24];
                *(_OWORD *)&__dst[8] = xmmword_1CD96DBF0;
                *(_DWORD *)&v747[8] = 0;
                BYTE8(v748) = 0;
                unint64_t v749 = 0;
                int v751 = __dst;
                LODWORD(v750) = 0;
                *(void *)v747 = &unk_1F2646FA8;
                *(_OWORD *)&v747[16] = 0uLL;
                *(void *)&long long v748 = 0;
                uint64_t v547 = *(void *)(*(void *)v744[0] + 8);
                unint64_t v548 = *(void *)(*(void *)v744[0] + 16);
                do
                {
                  uint64_t v9 = v548 != v546;
                  if (v548 == v546) {
                    sub_1CD380440((int)v715, (int)v368, (llvm::raw_ostream *)v747);
                  }
                  unint64_t v549 = v546 + 1;
                  if (v548 >= v546) {
                    unint64_t v550 = v546;
                  }
                  else {
                    unint64_t v550 = v548;
                  }
                  if (v550 <= v549) {
                    unint64_t v551 = v546 + 1;
                  }
                  else {
                    unint64_t v551 = v550;
                  }
                  if (v548 < v551) {
                    unint64_t v551 = v548;
                  }
                  uint64_t v552 = v547 + v550;
                  unint64_t v553 = v551 - v550;
                  v787 = &v741.__r_.__value_.__s.__data_[16];
                  uint64_t v554 = operator new(0x28uLL);
                  *(_DWORD *)uint64_t v554 = 2;
                  v554[1] = v552;
                  v554[2] = v553;
                  *((_DWORD *)v554 + 8) = 64;
                  v554[3] = 0;
                  std::string::size_type v555 = (std::string::size_type)(v554 + 5);
                  v741.__r_.__value_.__r.__words[0] = (std::string::size_type)v554;
                  v741.__r_.__value_.__l.__size_ = (std::string::size_type)(v554 + 5);
                  v741.__r_.__value_.__r.__words[2] = (std::string::size_type)(v554 + 5);
                  memset(v786, 0, sizeof(v786));
                  sub_1CD8F3EEC((uint64_t)v786);
                  v741.__r_.__value_.__l.__size_ = v555;
                  unsigned int v556 = *(char **)(v545 + 16);
                  size_t v557 = *(void *)(v545 + 24);
                  uint64_t v558 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715);
                  LOBYTE(v556) = sub_1CD37DA74((uint64_t)v715, (llvm::raw_ostream *)v747, v556, v557, (uint64_t)v730, 1, (uint64_t)&v741, 1uLL, 1, *(void *)(*(void *)(v558 + 8) + 8));
                  *(void *)int v786 = &v741;
                  sub_1CCBB926C((void ***)v786);
                  unint64_t v546 = v549;
                }
                while ((v556 & 1) == 0);
                *(void *)v747 = &unk_1F2646B98;
                if (v750 == 1 && *(void *)&v747[16]) {
                  MEMORY[0x1D25D9CB0](*(void *)&v747[16], 0x1000C8077774924);
                }
                if (*(unsigned char **)__dst != &__dst[24]) {
                  free(*(void **)__dst);
                }
              }
              else
              {
                uint64_t v9 = 1;
              }
            }
          }
          else
          {
            *(void *)int __dst = "unexpected token in '.irpc' directive";
            *(_WORD *)&__dst[32] = 259;
            uint64_t v9 = llvm::MCAsmParser::TokError((uint64_t)v715, (uint64_t)__dst, 0, 0);
          }
          uint64_t v371 = v744;
          goto LABEL_796;
        case 101:
        case 102:
          uint64_t v155 = *((void *)v715 + 17);
          if ((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 264))(v715)) {
            goto LABEL_217;
          }
          *(void *)v747 = 0;
          *(void *)int __dst = 0;
          if ((*(uint64_t (**)(llvm::MCAsmParser *, unsigned char *, unsigned char *))(*(void *)v715 + 232))(v715, v747, __dst))goto LABEL_217; {
          *(void *)int __dst = 0;
          }
          if (llvm::MCAsmParser::parseOptionalToken(v715, 25))
          {
            unsigned int v156 = *(uint64_t (**)(void))(*(void *)v715 + 256);
LABEL_570:
            if (v156()) {
              goto LABEL_217;
            }
          }
LABEL_571:
          if (llvm::MCAsmParser::parseEOL(v715)) {
            goto LABEL_217;
          }
          uint64_t v273 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
          (*(void (**)(uint64_t, void, void, uint64_t))(*(void *)v273 + 616))(v273, *(void *)v747, *(void *)__dst, v155);
          goto LABEL_152;
        case 103:
          uint64_t v274 = v725;
          if (**(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8) == 4)
          {
            uint64_t v275 = *(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8);
            uint64_t v278 = *(void *)(v275 + 24);
            uint64_t v276 = v275 + 24;
            uint64_t v277 = v278;
            if (*(_DWORD *)(v276 + 8) >= 0x41u) {
              uint64_t v276 = v277;
            }
            uint64_t v279 = *(void *)v276;
            (*(void (**)(llvm::MCAsmParser *))(*(void *)v715 + 184))(v715);
            if (v279 < 0)
            {
              int v280 = "negative file number";
              goto LABEL_870;
            }
          }
          else
          {
            uint64_t v279 = -1;
          }
          v730[0] = 0;
          v730[1] = 0;
          v731[0] = 0;
          if ((*(uint64_t (**)(llvm::MCAsmParser *, size_t *))(*(void *)v715 + 208))(v715, v730))
          {
LABEL_643:
            uint64_t v9 = 1;
            goto LABEL_644;
          }
          memset(v786, 0, 24);
          if (**(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8) == 3)
          {
            *(void *)int __dst = "explicit path specified, but no file number";
            *(_WORD *)&__dst[32] = 259;
            llvm::MCAsmParser::check(v715, v279 == -1, (const llvm::Twine *)__dst);
            if (v279 == -1
              || ((*(uint64_t (**)(llvm::MCAsmParser *, unsigned char *))(*(void *)v715 + 208))(v715, v786) & 1) != 0)
            {
              uint64_t v9 = 1;
              goto LABEL_1316;
            }
            if (v786[23] >= 0) {
              unsigned int v472 = (size_t *)v786;
            }
            else {
              unsigned int v472 = *(size_t **)v786;
            }
            if (v786[23] >= 0) {
              size_t v473 = v786[23] & 0x7F;
            }
            else {
              size_t v473 = *(void *)&v786[8];
            }
            uint64_t v612 = v730;
            if (v731[0] < 0) {
              uint64_t v612 = (size_t *)v730[0];
            }
            size_t v613 = HIBYTE(v731[0]) & 0x7F;
            if (v731[0] < 0) {
              size_t v613 = v730[1];
            }
            __pb = (void *)v613;
            __s1e = v612;
          }
          else
          {
            __pb = 0;
            __s1e = 0;
            if (v731[0] >= 0) {
              unsigned int v472 = v730;
            }
            else {
              unsigned int v472 = (size_t *)v730[0];
            }
            if (v731[0] >= 0) {
              size_t v473 = HIBYTE(v731[0]) & 0x7F;
            }
            else {
              size_t v473 = v730[1];
            }
          }
          uint64_t v739 = 0;
          uint64_t v734 = 0;
          v744[1] = 0;
          v744[0] = 0;
          v745 = 0;
          if (!llvm::MCAsmParser::parseOptionalToken(v715, 9))
          {
            std::string::size_type v475 = 0;
            char v476 = 0;
            while (1)
            {
              v790[1] = 0;
              v790[0] = 0;
              int v484 = **(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8);
              *(void *)int __dst = "unexpected token in '.file' directive";
              *(_WORD *)&__dst[32] = 259;
              llvm::MCAsmParser::check(v715, v484 != 2, (const llvm::Twine *)__dst);
              if (v484 != 2
                || ((*(uint64_t (**)(llvm::MCAsmParser *, size_t *))(*(void *)v715 + 192))(v715, v790) & 1) != 0)
              {
LABEL_1072:
                uint64_t v9 = 1;
                goto LABEL_1313;
              }
              if (v790[1] == 6)
              {
                if (*(_DWORD *)v790[0] != 1920298867 || *(_WORD *)(v790[0] + 4) != 25955)
                {
LABEL_1326:
                  *(void *)int __dst = "unexpected token in '.file' directive";
                  *(_WORD *)&__dst[32] = 259;
                  uint64_t v631 = llvm::MCAsmParser::TokError((uint64_t)v715, (uint64_t)__dst, 0, 0);
LABEL_1327:
                  uint64_t v9 = v631;
LABEL_1313:
                  if (SHIBYTE(v745) < 0)
                  {
                    int v628 = v744[0];
                    goto LABEL_1315;
                  }
LABEL_1316:
                  if ((v786[23] & 0x80000000) != 0) {
                    operator delete(*(void **)v786);
                  }
                  goto LABEL_644;
                }
                *(void *)int __dst = "source specified, but no file number";
                *(_WORD *)&__dst[32] = 259;
                llvm::MCAsmParser::check(v715, v279 == -1, (const llvm::Twine *)__dst);
                if (v279 == -1) {
                  goto LABEL_1072;
                }
                int v487 = **(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8);
                *(void *)v747 = "unexpected token in '.file' directive";
                LOWORD(v748) = 259;
                llvm::MCAsmParser::check(v715, v487 != 3, (const llvm::Twine *)v747);
                if (v487 != 3) {
                  goto LABEL_1072;
                }
                uint64_t v9 = 1;
                char v476 = 1;
                if ((*(uint64_t (**)(llvm::MCAsmParser *, void **))(*(void *)v715 + 208))(v715, v744)) {
                  goto LABEL_1313;
                }
              }
              else
              {
                if (v790[1] != 3) {
                  goto LABEL_1326;
                }
                if (*(_WORD *)v790[0] != 25709 || *(unsigned char *)(v790[0] + 2) != 53) {
                  goto LABEL_1326;
                }
                *(void *)int __dst = "MD5 checksum specified, but no file number";
                *(_WORD *)&__dst[32] = 259;
                llvm::MCAsmParser::check(v715, v279 == -1, (const llvm::Twine *)__dst);
                if (v279 == -1) {
                  goto LABEL_1072;
                }
                uint64_t v9 = 1;
                std::string::size_type v475 = 1;
                if (sub_1CD37F168((uint64_t)v715, &v739, &v734)) {
                  goto LABEL_1313;
                }
              }
              if (llvm::MCAsmParser::parseOptionalToken(v715, 9)) {
                goto LABEL_1005;
              }
            }
          }
          if (v279 == -1)
          {
            if (*(unsigned char *)(*(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 48))(v715)
                                      + 152)
                          + 364))
            {
              uint64_t v542 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
              (*(void (**)(uint64_t, size_t *, size_t))(*(void *)v542 + 664))(v542, v472, v473);
            }
            goto LABEL_1312;
          }
          std::string::size_type v475 = 0;
          char v476 = 0;
LABEL_1005:
          uint64_t v477 = *((void *)v715 + 27);
          if (*(unsigned char *)(v477 + 1513))
          {
            uint64_t v614 = *(uint64_t **)(v477 + 1480);
            if (v614)
            {
              while (1)
              {
                int v615 = (uint64_t **)v614;
                if (!*((_DWORD *)v614 + 8)) {
                  break;
                }
                uint64_t v614 = (uint64_t *)*v614;
                if (!*v615) {
                  goto LABEL_1467;
                }
              }
              unsigned int v616 = (char *)v614;
            }
            else
            {
              int v615 = (uint64_t **)(v477 + 1480);
LABEL_1467:
              unsigned int v616 = (char *)operator new(0x228uLL);
              *((_DWORD *)v616 + 8) = 0;
              *(_OWORD *)(v616 + 56) = 0u;
              *(_OWORD *)(v616 + 72) = 0u;
              *(_OWORD *)(v616 + 88) = 0u;
              *(_OWORD *)(v616 + 104) = 0u;
              *(_OWORD *)(v616 + 120) = 0u;
              *(_OWORD *)(v616 + 136) = 0u;
              *(_OWORD *)(v616 + 168) = 0u;
              *(_OWORD *)(v616 + 184) = 0u;
              *(_OWORD *)(v616 + 200) = 0u;
              *(_OWORD *)(v616 + 216) = 0u;
              *(_OWORD *)(v616 + 232) = 0u;
              *(_OWORD *)(v616 + 248) = 0u;
              *((void *)v616 + 65) = 0;
              *(_OWORD *)(v616 + 264) = 0u;
              *(_OWORD *)(v616 + 280) = 0u;
              *(_OWORD *)(v616 + 40) = 0u;
              *(_OWORD *)(v616 + 296) = 0u;
              *(_OWORD *)(v616 + 312) = 0u;
              *(_OWORD *)(v616 + 328) = 0u;
              *(_OWORD *)(v616 + 344) = 0u;
              *(_OWORD *)(v616 + 360) = 0u;
              *(_OWORD *)(v616 + 376) = 0u;
              *(_OWORD *)(v616 + 392) = 0u;
              *(_OWORD *)(v616 + 408) = 0u;
              *(_OWORD *)(v616 + 424) = 0u;
              *(_OWORD *)(v616 + 440) = 0u;
              *(_OWORD *)(v616 + 456) = 0u;
              *(_OWORD *)(v616 + 472) = 0u;
              *(_OWORD *)(v616 + 152) = 0u;
              *(_OWORD *)(v616 + 488) = 0u;
              *(_OWORD *)(v616 + 504) = 0u;
              *((void *)v616 + 6) = v616 + 64;
              *((_DWORD *)v616 + 15) = 3;
              *((void *)v616 + 17) = v616 + 152;
              *((_DWORD *)v616 + 37) = 3;
              *((void *)v616 + 47) = 0;
              *((void *)v616 + 46) = 0;
              *((void *)v616 + 48) = 0x1000000000;
              *((_OWORD *)v616 + 25) = 0u;
              *((_OWORD *)v616 + 26) = 0u;
              *((_OWORD *)v616 + 27) = 0u;
              *(void *)(v616 + 445) = 0;
              v616[497] = 1;
              *((void *)v616 + 64) = 0;
              *((void *)v616 + 63) = 0;
              *((_DWORD *)v616 + 130) = 0;
              *((void *)v616 + 66) = 0;
              *((void *)v616 + 68) = 0;
              *((void *)v616 + 67) = 0;
              *(void *)unsigned int v616 = 0;
              *((void *)v616 + 1) = 0;
              *((void *)v616 + 2) = v615;
              *int v615 = (uint64_t *)v616;
              int v682 = (uint64_t *)v616;
              uint64_t v683 = **(void **)(v477 + 1472);
              if (v683)
              {
                *(void *)(v477 + 1472) = v683;
                int v682 = *v615;
              }
              sub_1CB8358B8(*(uint64_t **)(v477 + 1480), v682);
              ++*(void *)(v477 + 1488);
            }
            sub_1CD8F42AC((uint64_t)(v616 + 40));
            uint64_t v477 = *((void *)v715 + 27);
            *(unsigned char *)(v477 + 1513) = 0;
            if (v475) {
              goto LABEL_1007;
            }
          }
          else if (v475)
          {
LABEL_1007:
            uint64x2_t v478 = (uint64x2_t)vdupq_lane_s64(v739, 0);
            uint64x2_t v479 = (uint64x2_t)vdupq_lane_s64(v734, 0);
            *(int8x8_t *)v478.uint64_t i8 = vmovn_s16(vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v478, (uint64x2_t)xmmword_1CFB33B40), (int32x4_t)vshlq_u64(v478, (uint64x2_t)xmmword_1CFB33B30)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v478, (uint64x2_t)xmmword_1CFB33B60), (int32x4_t)vshlq_u64(v478, (uint64x2_t)xmmword_1CFB33B50))));
            int16x8_t v480 = vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v479, (uint64x2_t)xmmword_1CFB33B40), (int32x4_t)vshlq_u64(v479, (uint64x2_t)xmmword_1CFB33B30)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v479, (uint64x2_t)xmmword_1CFB33B60), (int32x4_t)vshlq_u64(v479, (uint64x2_t)xmmword_1CFB33B50)));
            int8x8_t v3 = vmovn_s16(v480);
            __int8 v481 = v478.i8[0];
            int8x8_t v702 = vext_s8(*(int8x8_t *)v478.i8, *(int8x8_t *)v480.i8, 1uLL);
            char v482 = 1;
LABEL_1284:
            if (v476)
            {
              if (SHIBYTE(v745) >= 0) {
                unsigned int v617 = HIBYTE(v745) & 0x7F;
              }
              else {
                unsigned int v617 = v744[1];
              }
              uint64_t v618 = (void *)sub_1CB906F34((uint64_t *)(v477 + 192), v617, 3);
              uint64_t v619 = (uint64_t)v618;
              if (SHIBYTE(v745) >= 0) {
                unsigned int v620 = v744;
              }
              else {
                unsigned int v620 = (void **)v744[0];
              }
              if (SHIBYTE(v745) >= 0) {
                size_t v621 = HIBYTE(v745) & 0x7F;
              }
              else {
                size_t v621 = (size_t)v744[1];
              }
              memcpy(v618, v620, v621);
              if (SHIBYTE(v745) >= 0) {
                std::string::size_type v475 = HIBYTE(v745) & 0x7F;
              }
              else {
                std::string::size_type v475 = (std::string::size_type)v744[1];
              }
              std::string::value_type v622 = 1;
            }
            else
            {
              std::string::value_type v622 = 0;
              uint64_t v619 = 0;
            }
            if (v279)
            {
              uint64_t v623 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
              LOBYTE(v783) = v481;
              HIBYTE(v783) = v702.i8[6];
              *(_WORD *)((char *)&v783 + 5) = v702.i16[2];
              *(_DWORD *)((char *)&v783 + 1) = v702.i32[0];
              int8x8_t v784 = v3;
              LOBYTE(v785) = v482;
              uint64_t v735 = v619;
              std::string::size_type v736 = v475;
              LOBYTE(v737) = v622;
              *(_DWORD *)((char *)&v737 + 1) = *(_DWORD *)v733;
              HIDWORD(v737) = *(_DWORD *)&v733[3];
              (*(void (**)(size_t *__return_ptr))(*(void *)v623 + 688))(v790);
              if (v790[1])
              {
                size_t v624 = v790[0];
                v790[0] = 0;
                size_t v732 = v624;
                sub_1CD4FB504((uint64_t *)&v732, (std::string *)v747);
                *(_WORD *)&__dst[32] = 260;
                *(void *)int __dst = v747;
                uint64_t v9 = llvm::MCAsmParser::Error((uint64_t)v715, (uint64_t)v274, (uint64_t)__dst, 0, 0);
                if ((v747[23] & 0x80000000) != 0) {
                  operator delete(*(void **)v747);
                }
                if (v732) {
                  (*(void (**)(size_t))(*(void *)v732 + 8))(v732);
                }
                if (v790[1])
                {
                  size_t v625 = v790[0];
                  v790[0] = 0;
                  if (v625) {
                    (*(void (**)(size_t))(*(void *)v625 + 8))(v625);
                  }
                }
                goto LABEL_1313;
              }
            }
            else
            {
              uint64_t v626 = *((void *)v715 + 27);
              if (*(unsigned __int16 *)(v626 + 1624) <= 4u) {
                *(_WORD *)(v626 + 1624) = 5;
              }
              uint64_t v627 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
              HIBYTE(v788[0]) = v702.i8[6];
              LOBYTE(v788[0]) = v481;
              *(_WORD *)((char *)v788 + 5) = v702.i16[2];
              *(_DWORD *)((char *)v788 + 1) = v702.i32[0];
              v788[1] = (uint64_t)v3;
              LOBYTE(v789) = v482;
              v741.__r_.__value_.__r.__words[0] = v619;
              v741.__r_.__value_.__l.__size_ = v475;
              v741.__r_.__value_.__s.__data_[16] = v622;
              *(_DWORD *)((char *)&v741.__r_.__value_.__r.__words[2] + 1) = *(_DWORD *)v733;
              HIDWORD(v741.__r_.__value_.__r.__words[2]) = *(_DWORD *)&v733[3];
              (*(void (**)(uint64_t, size_t *, void *, size_t *, size_t, uint64_t *, std::string *, void))(*(void *)v627 + 696))(v627, __s1e, __pb, v472, v473, v788, &v741, 0);
            }
            if (!*((unsigned char *)v715 + 806))
            {
              uint64_t v629 = (void *)(*((void *)v715 + 27) + 1480);
              do
              {
                uint64_t v630 = (uint64_t)v629;
                uint64_t v629 = (void *)*v629;
              }
              while (v629);
              if (v630 == *((void *)v715 + 27) + 1480 || *(_DWORD *)(v630 + 32)) {
                uint64_t v630 = *((void *)v715 + 27) + 1480;
              }
              if (*(_DWORD *)(v630 + 144) && *(unsigned __int8 *)(v630 + 497) != *(unsigned __int8 *)(v630 + 498))
              {
                *((unsigned char *)v715 + 806) = 1;
                *(void *)int __dst = "inconsistent use of MD5 checksums";
                *(_WORD *)&__dst[32] = 259;
                uint64_t v631 = (*(uint64_t (**)(llvm::MCAsmParser *, char *, unsigned char *, void, void))(*(void *)v715 + 168))(v715, v274, __dst, 0, 0);
                goto LABEL_1327;
              }
            }
LABEL_1312:
            uint64_t v9 = 0;
            goto LABEL_1313;
          }
          char v482 = 0;
          __int8 v481 = 0;
          int8x8_t v702 = v474;
          goto LABEL_1284;
        case 104:
          if (**(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8) == 4)
          {
            *(void *)int __dst = "unexpected token in '.line' directive";
            *(_WORD *)&__dst[32] = 259;
            if (llvm::MCAsmParser::parseIntToken(v715, (uint64_t *)v747, (const llvm::Twine *)__dst)) {
              goto LABEL_217;
            }
          }
          uint64_t v53 = llvm::MCAsmParser::parseEOL(v715);
          goto LABEL_280;
        case 105:
          *(void *)int v786 = 0;
          uint64_t v212 = *(void *)(*(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715)
                                       + 8)
                           + 8);
          *(void *)int __dst = "unexpected token in '.loc' directive";
          *(_WORD *)&__dst[32] = 259;
          if (llvm::MCAsmParser::parseIntToken(v715, (uint64_t *)v786, (const llvm::Twine *)__dst)) {
            goto LABEL_217;
          }
          uint64_t v383 = *(void *)v786;
          if (*(uint64_t *)v786 <= 0)
          {
            unsigned int v384 = *(unsigned __int16 *)(*((void *)v715 + 27) + 1624);
            *(void *)v747 = "file number less than one in '.loc' directive";
            LOWORD(v748) = 259;
            if (v384 <= 4) {
              goto LABEL_1275;
            }
          }
          int v385 = (uint64_t **)(*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 48))(v715);
          BOOL isValidDwarfFileNumber = llvm::MCContext::isValidDwarfFileNumber(v385, v383, 0);
          v730[0] = (size_t)"unassigned file number in '.loc' directive";
          LOWORD(v731[2]) = 259;
          if (!isValidDwarfFileNumber) {
            goto LABEL_1332;
          }
          if (**(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8) == 4)
          {
            uint64_t v387 = *(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8);
            uint64_t v390 = *(uint64_t **)(v387 + 24);
            unsigned int v388 = (uint64_t *)(v387 + 24);
            uint64_t v389 = v390;
            if (*((_DWORD *)v388 + 2) >= 0x41u) {
              unsigned int v388 = v389;
            }
            uint64_t v391 = *v388;
            if (*v388 < 0)
            {
              int v280 = "line number less than zero in '.loc' directive";
              goto LABEL_870;
            }
            (*(void (**)(llvm::MCAsmParser *))(*(void *)v715 + 184))(v715);
          }
          else
          {
            uint64_t v391 = 0;
          }
          if (**(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8) == 4)
          {
            uint64_t v606 = *(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8);
            uint64_t v609 = *(uint64_t **)(v606 + 24);
            unsigned int v607 = (uint64_t *)(v606 + 24);
            uint64_t v608 = v609;
            if (*((_DWORD *)v607 + 2) >= 0x41u) {
              unsigned int v607 = v608;
            }
            uint64_t v610 = *v607;
            if (*v607 < 0)
            {
              int v280 = "column position less than zero in '.loc' directive";
              goto LABEL_870;
            }
            (*(void (**)(llvm::MCAsmParser *))(*(void *)v715 + 184))(v715);
          }
          else
          {
            uint64_t v610 = 0;
          }
          LODWORD(v730[0]) = *(unsigned char *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 48))(v715)
                                      + 1506) & 1;
          LODWORD(v744[0]) = 0;
          *(void *)v747 = 0;
          *(void *)int __dst = v715;
          *(void *)&__dst[8] = v730;
          *(void *)&__dst[16] = v744;
          *(void *)&__dst[24] = v747;
          uint64_t v9 = llvm::MCAsmParser::parseMany(v715, sub_1CD3808E4, (uint64_t)__dst, 0);
          if ((v9 & 1) == 0)
          {
            uint64_t v611 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
            (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void, void, void))(*(void *)v611 + 712))(v611, v383, v391, v610, LODWORD(v730[0]), LODWORD(v744[0]), *(unsigned int *)v747);
          }
          goto LABEL_281;
        case 106:
          int v280 = "unsupported directive '.stabs'";
          goto LABEL_870;
        case 107:
          uint64_t v366 = *(void *)(*(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715)
                                       + 8)
                           + 8);
          v741.__r_.__value_.__r.__words[0] = 0;
          memset(v786, 0, 24);
          v744[1] = 0;
          v744[0] = 0;
          v745 = 0;
          uint64_t v735 = 0;
          *(void *)int __dst = "expected file number in '.cv_file' directive";
          *(_WORD *)&__dst[32] = 259;
          if (llvm::MCAsmParser::parseIntToken(v715, (uint64_t *)&v741, (const llvm::Twine *)__dst)) {
            goto LABEL_783;
          }
          *(void *)v747 = "file number less than one";
          LOWORD(v748) = 259;
          if ((uint64_t)v741.__r_.__value_.__l.__data_ <= 0)
          {
            llvm::MCAsmParser::Error((uint64_t)v715, v366, (uint64_t)v747, 0, 0);
LABEL_783:
            uint64_t v9 = 1;
            goto LABEL_784;
          }
          int v572 = **(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8);
          v730[0] = (size_t)"unexpected token in '.cv_file' directive";
          LOWORD(v731[2]) = 259;
          llvm::MCAsmParser::check(v715, v572 != 3, (const llvm::Twine *)v730);
          if (v572 != 3
            || ((*(uint64_t (**)(llvm::MCAsmParser *, unsigned char *))(*(void *)v715 + 208))(v715, v786) & 1) != 0)
          {
            goto LABEL_783;
          }
          if (llvm::MCAsmParser::parseOptionalToken(v715, 9))
          {
            unint64_t v573 = 0;
            uint64_t v574 = 0;
            char v575 = 0;
          }
          else
          {
            int v681 = **(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8);
            *(void *)int __dst = "unexpected token in '.cv_file' directive";
            *(_WORD *)&__dst[32] = 259;
            llvm::MCAsmParser::check(v715, v681 != 3, (const llvm::Twine *)__dst);
            if (v681 != 3) {
              goto LABEL_783;
            }
            if ((*(uint64_t (**)(llvm::MCAsmParser *, void **))(*(void *)v715 + 208))(v715, v744)) {
              goto LABEL_783;
            }
            *(void *)v747 = "expected checksum kind in '.cv_file' directive";
            LOWORD(v748) = 259;
            if (llvm::MCAsmParser::parseIntToken(v715, &v735, (const llvm::Twine *)v747)) {
              goto LABEL_783;
            }
            v730[0] = (size_t)"unexpected token in '.cv_file' directive";
            LOWORD(v731[2]) = 259;
            if (llvm::MCAsmParser::parseEOL(v715, (const llvm::Twine *)v730)) {
              goto LABEL_783;
            }
            char v575 = HIBYTE(v745);
            uint64_t v574 = (void **)v744[0];
            unint64_t v573 = v744[1];
          }
          int v576 = v575;
          if (v575 >= 0) {
            int v577 = v744;
          }
          else {
            int v577 = v574;
          }
          unint64_t v578 = v575 & 0x7F;
          if (v576 >= 0) {
            unint64_t v579 = v578;
          }
          else {
            unint64_t v579 = (unint64_t)v573;
          }
          memset(__dst, 0, 24);
          if (!v579) {
            goto LABEL_1206;
          }
          std::string::resize((std::string *)__dst, (v579 + 1) >> 1, 0);
          uint64_t v580 = *(unsigned char **)__dst;
          if (__dst[23] >= 0) {
            uint64_t v581 = __dst;
          }
          else {
            uint64_t v581 = *(unsigned char **)__dst;
          }
          if ((v579 & 1) == 0) {
            goto LABEL_1199;
          }
          int v582 = (unsigned __int16)word_1CFAC4A4C[*(unsigned __int8 *)v577];
          if (v582 != 0xFFFF)
          {
            if (__dst[23] >= 0) {
              uint64_t v580 = __dst;
            }
            unsigned char *v581 = v582;
            uint64_t v581 = v580 + 1;
            BOOL v583 = v744;
            if (v576 < 0) {
              BOOL v583 = v574;
            }
            int v577 = (void **)((char *)v583 + 1);
            --v579;
LABEL_1199:
            if (v579 >= 2)
            {
              unint64_t v584 = v579 >> 1;
              unint64_t v585 = (unsigned __int8 *)v577 + 1;
              do
              {
                int v586 = (unsigned __int16)word_1CFAC4A4C[*(v585 - 1)];
                int v587 = (unsigned __int16)word_1CFAC4A4C[*v585];
                if (v586 == 0xFFFF || v587 == 0xFFFF) {
                  break;
                }
                v585 += 2;
                *v581++ = v587 | (16 * v586);
                --v584;
              }
              while (v584);
            }
          }
LABEL_1206:
          if (SHIBYTE(v745) < 0) {
            operator delete(v744[0]);
          }
          v745 = *(const char **)&__dst[16];
          *(_OWORD *)int v744 = *(_OWORD *)__dst;
          if (__dst[23] >= 0) {
            unsigned int v589 = __dst[23] & 0x7F;
          }
          else {
            unsigned int v589 = *(_DWORD *)&__dst[8];
          }
          uint64_t v590 = (void *)sub_1CB906F34((uint64_t *)(*((void *)v715 + 27) + 192), v589, 0);
          if (SHIBYTE(v745) >= 0) {
            uint64_t v591 = v744;
          }
          else {
            uint64_t v591 = (void **)v744[0];
          }
          if (SHIBYTE(v745) >= 0) {
            size_t v592 = HIBYTE(v745) & 0x7F;
          }
          else {
            size_t v592 = (size_t)v744[1];
          }
          memcpy(v590, v591, v592);
          uint64_t v593 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
          if ((*(uint64_t (**)(void))(*(void *)v593 + 720))())
          {
            uint64_t v9 = 0;
          }
          else
          {
            *(void *)int __dst = "file number already allocated";
            *(_WORD *)&__dst[32] = 259;
            uint64_t v9 = llvm::MCAsmParser::Error((uint64_t)v715, v366, (uint64_t)__dst, 0, 0);
          }
LABEL_784:
          if (SHIBYTE(v745) < 0)
          {
            uint64_t v367 = v744[0];
LABEL_786:
            operator delete(v367);
          }
LABEL_857:
          if ((v786[23] & 0x80000000) == 0) {
            goto LABEL_281;
          }
          uint64_t v242 = *(char **)v786;
          goto LABEL_646;
        case 108:
          unint64_t v123 = *(char **)(*(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715)
                                      + 8)
                          + 8);
          *(void *)v747 = 0;
          if (sub_1CD380D30(v715, (uint64_t *)v747, (uint64_t)".cv_func_id", 11)) {
            goto LABEL_217;
          }
          *(void *)int __dst = "unexpected token in '.cv_func_id' directive";
          *(_WORD *)&__dst[32] = 259;
          if (llvm::MCAsmParser::parseEOL(v715, (const llvm::Twine *)__dst)) {
            goto LABEL_217;
          }
          uint64_t v282 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
          if (((*(uint64_t (**)(uint64_t, void))(*(void *)v282 + 728))(v282, *(unsigned int *)v747) & 1) == 0) {
            goto LABEL_592;
          }
          goto LABEL_152;
        case 109:
          unint64_t v123 = *(char **)(*(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715)
                                      + 8)
                          + 8);
          *(void *)v747 = 0;
          v730[0] = 0;
          *(void *)int v786 = 0;
          v744[0] = 0;
          if (sub_1CD380D30(v715, (uint64_t *)v747, (uint64_t)".cv_inline_site_id", 18)) {
            goto LABEL_217;
          }
          if (**(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8) != 2) {
            goto LABEL_1054;
          }
          uint64_t v209 = *(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8);
          if (*(_DWORD *)v209 == 2)
          {
            uint64_t v210 = *(void *)(v209 + 8);
            unint64_t v211 = *(void *)(v209 + 16);
          }
          else
          {
            uint64_t v210 = *(void *)(v209 + 8);
            unint64_t v494 = *(void *)(v209 + 16);
            unint64_t v495 = v494 - 1;
            unint64_t v496 = v494 != 0;
            if (v494) {
              ++v210;
            }
            if (v496 > v495) {
              unint64_t v495 = v494 != 0;
            }
            if (v494 < v495) {
              unint64_t v495 = v494;
            }
            unint64_t v211 = v495 - v496;
          }
          if (v211 == 6)
          {
            int v497 = *(_DWORD *)v210 ^ 0x68746977 | *(unsigned __int16 *)(v210 + 4) ^ 0x6E69;
            *(void *)int __dst = "expected 'within' identifier in '.cv_inline_site_id' directive";
            *(_WORD *)&__dst[32] = 259;
            llvm::MCAsmParser::check(v715, v497 != 0, (const llvm::Twine *)__dst);
            if (v497) {
              goto LABEL_217;
            }
            (*(void (**)(llvm::MCAsmParser *))(*(void *)v715 + 184))(v715);
            if (sub_1CD380D30(v715, (uint64_t *)v730, (uint64_t)".cv_inline_site_id", 18)) {
              goto LABEL_217;
            }
            if (**(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8) == 2)
            {
              uint64_t v498 = *(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8);
              if (*(_DWORD *)v498 == 2)
              {
                uint64_t v499 = *(void *)(v498 + 8);
                unint64_t v500 = *(void *)(v498 + 16);
              }
              else
              {
                uint64_t v499 = *(void *)(v498 + 8);
                unint64_t v634 = *(void *)(v498 + 16);
                unint64_t v635 = v634 - 1;
                unint64_t v636 = v634 != 0;
                if (v634) {
                  ++v499;
                }
                if (v636 > v635) {
                  unint64_t v635 = v634 != 0;
                }
                if (v634 < v635) {
                  unint64_t v635 = v634;
                }
                unint64_t v500 = v635 - v636;
              }
              if (v500 == 10)
              {
                uint64_t v637 = *(void *)v499 ^ 0x5F64656E696C6E69 | *(unsigned __int16 *)(v499 + 8) ^ 0x7461;
                *(void *)int __dst = "expected 'inlined_at' identifier in '.cv_inline_site_id' directive";
                *(_WORD *)&__dst[32] = 259;
                llvm::MCAsmParser::check(v715, v637 != 0, (const llvm::Twine *)__dst);
                if (v637) {
                  goto LABEL_217;
                }
                (*(void (**)(llvm::MCAsmParser *))(*(void *)v715 + 184))(v715);
                if (sub_1CD380E34((llvm::MCContext **)v715, (uint64_t *)v786, (uint64_t)".cv_inline_site_id", 18)) {
                  goto LABEL_217;
                }
                *(void *)int __dst = "expected line number after 'inlined_at'";
                *(_WORD *)&__dst[32] = 259;
                if (llvm::MCAsmParser::parseIntToken(v715, (uint64_t *)v744, (const llvm::Twine *)__dst)) {
                  goto LABEL_217;
                }
                if (**(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8) == 4)
                {
                  uint64_t v638 = *(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8);
                  unsigned int v641 = *(unsigned int **)(v638 + 24);
                  unsigned int v639 = (unsigned int *)(v638 + 24);
                  int64_t v640 = v641;
                  if (v639[2] >= 0x41) {
                    unsigned int v639 = v640;
                  }
                  uint64_t v642 = *v639;
                  (*(void (**)(llvm::MCAsmParser *))(*(void *)v715 + 184))(v715);
                }
                else
                {
                  uint64_t v642 = 0;
                }
                *(void *)int __dst = "unexpected token in '.cv_inline_site_id' directive";
                *(_WORD *)&__dst[32] = 259;
                if (llvm::MCAsmParser::parseEOL(v715, (const llvm::Twine *)__dst)) {
                  goto LABEL_217;
                }
                uint64_t v687 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
                if ((*(uint64_t (**)(uint64_t, void, void, void, void, uint64_t, char *))(*(void *)v687 + 736))(v687, *(unsigned int *)v747, LODWORD(v730[0]), *(unsigned int *)v786, LODWORD(v744[0]), v642, v123))goto LABEL_152; {
LABEL_592:
                }
                uint64_t v283 = "function id already allocated";
LABEL_776:
                *(void *)int __dst = v283;
                __int16 v362 = 259;
LABEL_1176:
                *(_WORD *)&__dst[32] = v362;
                uint64_t v114 = (uint64_t)v715;
LABEL_278:
                long long v113 = v123;
                goto LABEL_279;
              }
            }
            uint64_t v501 = "expected 'inlined_at' identifier in '.cv_inline_site_id' directive";
          }
          else
          {
LABEL_1054:
            uint64_t v501 = "expected 'within' identifier in '.cv_inline_site_id' directive";
          }
          *(void *)int __dst = v501;
          *(_WORD *)&__dst[32] = 259;
          uint64_t v9 = 1;
          llvm::MCAsmParser::check(v715, 1, (const llvm::Twine *)__dst);
          goto LABEL_281;
        case 110:
          (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715);
          *(void *)v747 = 0;
          v730[0] = 0;
          if ((sub_1CD380D30(v715, (uint64_t *)v747, (uint64_t)".cv_loc", 7) & 1) != 0
            || (sub_1CD380E34((llvm::MCContext **)v715, (uint64_t *)v730, (uint64_t)".cv_loc", 7) & 1) != 0)
          {
            goto LABEL_217;
          }
          if (**(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8) == 4)
          {
            uint64_t v204 = *(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8);
            uint64_t v207 = *(uint64_t **)(v204 + 24);
            int v205 = (uint64_t *)(v204 + 24);
            uint64_t v206 = v207;
            if (*((_DWORD *)v205 + 2) >= 0x41u) {
              int v205 = v206;
            }
            uint64_t v208 = *v205;
            if (*v205 < 0)
            {
              int v280 = "line number less than zero in '.cv_loc' directive";
              goto LABEL_870;
            }
            (*(void (**)(llvm::MCAsmParser *))(*(void *)v715 + 184))(v715);
          }
          else
          {
            uint64_t v208 = 0;
          }
          if (**(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8) == 4)
          {
            uint64_t v306 = *(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8);
            uint64_t v309 = *(uint64_t **)(v306 + 24);
            int v307 = (uint64_t *)(v306 + 24);
            uint64_t v308 = v309;
            if (*((_DWORD *)v307 + 2) >= 0x41u) {
              int v307 = v308;
            }
            uint64_t v310 = *v307;
            if (*v307 < 0)
            {
              int v280 = "column position less than zero in '.cv_loc' directive";
              goto LABEL_870;
            }
            (*(void (**)(llvm::MCAsmParser *))(*(void *)v715 + 184))(v715);
          }
          else
          {
            uint64_t v310 = 0;
          }
          LOBYTE(v744[0]) = 0;
          *(void *)int v786 = 0;
          *(void *)int __dst = v715;
          *(void *)&__dst[8] = v744;
          *(void *)&__dst[16] = v786;
          uint64_t v9 = llvm::MCAsmParser::parseMany(v715, sub_1CD380FC4, (uint64_t)__dst, 0);
          if ((v9 & 1) == 0)
          {
            uint64_t v315 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
            (*(void (**)(uint64_t, void, void, uint64_t, uint64_t, void, BOOL))(*(void *)v315 + 744))(v315, *(unsigned int *)v747, LODWORD(v730[0]), v208, v310, LOBYTE(v744[0]), *(void *)v786 != 0);
          }
          goto LABEL_281;
        case 111:
          v741.__r_.__value_.__r.__words[0] = 0;
          *(_OWORD *)int v786 = 0uLL;
          v744[1] = 0;
          v744[0] = 0;
          (*(void (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715);
          if (sub_1CD380D30(v715, (uint64_t *)&v741, (uint64_t)".cv_linetable", 13)) {
            goto LABEL_217;
          }
          *(void *)int __dst = "expected comma";
          *(_WORD *)&__dst[32] = 259;
          if (llvm::MCAsmParser::parseToken(v715, 25, (llvm::Twine *)__dst)) {
            goto LABEL_217;
          }
          uint64_t v212 = *(void *)(*(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715)
                                       + 8)
                           + 8);
          int v263 = (*(uint64_t (**)(llvm::MCAsmParser *, unsigned char *))(*(void *)v715 + 192))(v715, v786);
          *(void *)v747 = "expected identifier in directive";
          LOWORD(v748) = 259;
          if (v263) {
            goto LABEL_1275;
          }
          *(void *)int __dst = "expected comma";
          *(_WORD *)&__dst[32] = 259;
          if (llvm::MCAsmParser::parseToken(v715, 25, (llvm::Twine *)__dst)) {
            goto LABEL_217;
          }
          uint64_t v212 = *(void *)(*(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715)
                                       + 8)
                           + 8);
          int v264 = (*(uint64_t (**)(llvm::MCAsmParser *, void **))(*(void *)v715 + 192))(v715, v744);
          v730[0] = (size_t)"expected identifier in directive";
          LOWORD(v731[2]) = 259;
          if (!v264)
          {
            uint64_t v265 = v715;
            uint64_t v266 = (llvm::MCContext *)(*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 48))(v715);
            *(_WORD *)&__dst[32] = 261;
            *(_OWORD *)int __dst = *(_OWORD *)v786;
            llvm::MCContext::getOrCreateSymbol(v266, (unsigned __int8 ***)__dst);
            uint64_t v267 = (llvm::MCContext *)(*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v265 + 48))(v265);
            *(_WORD *)&__dst[32] = 261;
            *(void **)int __dst = v744[0];
            *(void **)&__dst[8] = v744[1];
            llvm::MCContext::getOrCreateSymbol(v267, (unsigned __int8 ***)__dst);
            uint64_t v268 = *(void *)(*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v265 + 56))(v265);
            (*(void (**)(void))(v268 + 752))();
            goto LABEL_152;
          }
LABEL_1332:
          int v248 = v730;
LABEL_1276:
          uint64_t v254 = (uint64_t)v715;
          uint64_t v255 = v212;
          goto LABEL_781;
        case 112:
          uint64_t v783 = 0;
          v790[0] = 0;
          uint64_t v739 = 0;
          uint64_t v735 = 0;
          std::string::size_type v736 = 0;
          v788[1] = 0;
          v788[0] = 0;
          (*(void (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715);
          if (sub_1CD380D30(v715, &v783, (uint64_t)".cv_inline_linetable", 20)) {
            goto LABEL_217;
          }
          BOOL v247 = *(char **)(*(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715)
                                      + 8)
                          + 8);
          *(void *)int __dst = "expected SourceField in '.cv_inline_linetable' directive";
          *(_WORD *)&__dst[32] = 259;
          if (llvm::MCAsmParser::parseIntToken(v715, (uint64_t *)v790, (const llvm::Twine *)__dst)) {
            goto LABEL_217;
          }
          *(void *)v747 = "File id less than zero in '.cv_inline_linetable' directive";
          LOWORD(v748) = 259;
          if ((uint64_t)v790[0] >= 1)
          {
            BOOL v247 = *(char **)(*(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715)
                                        + 8)
                            + 8);
            v730[0] = (size_t)"expected SourceLineNum in '.cv_inline_linetable' directive";
            LOWORD(v731[2]) = 259;
            if (llvm::MCAsmParser::parseIntToken(v715, &v739, (const llvm::Twine *)v730)) {
              goto LABEL_217;
            }
            *(void *)int v786 = "Line number less than zero in '.cv_inline_linetable' directive";
            LOWORD(v787) = 259;
            if (v739 < 0)
            {
              int v248 = v786;
            }
            else
            {
              BOOL v247 = *(char **)(*(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715)
                                          + 8)
                              + 8);
              char v643 = (*(uint64_t (**)(llvm::MCAsmParser *, uint64_t *))(*(void *)v715 + 192))(v715, &v735);
              v744[0] = "expected identifier in directive";
              __int16 v746 = 259;
              if (v643)
              {
                int v248 = v744;
              }
              else
              {
                BOOL v247 = *(char **)(*(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715)
                                            + 8)
                                + 8);
                int v662 = (*(uint64_t (**)(llvm::MCAsmParser *, uint64_t *))(*(void *)v715 + 192))(v715, v788);
                v741.__r_.__value_.__r.__words[0] = (std::string::size_type)"expected identifier in directive";
                __int16 v743 = 259;
                if (!v662)
                {
                  *(void *)int __dst = "Expected End of Statement";
                  *(_WORD *)&__dst[32] = 259;
                  if (!llvm::MCAsmParser::parseEOL(v715, (const llvm::Twine *)__dst))
                  {
                    unsigned int v664 = v715;
                    unsigned int v665 = (llvm::MCContext *)(*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 48))(v715);
                    *(_WORD *)&__dst[32] = 261;
                    *(void *)int __dst = v735;
                    *(void *)&__dst[8] = v736;
                    llvm::MCContext::getOrCreateSymbol(v665, (unsigned __int8 ***)__dst);
                    uint64_t v666 = (llvm::MCContext *)(*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v664 + 48))(v664);
                    *(_WORD *)&__dst[32] = 261;
                    *(void *)int __dst = v788[0];
                    *(void *)&__dst[8] = v788[1];
                    llvm::MCContext::getOrCreateSymbol(v666, (unsigned __int8 ***)__dst);
                    uint64_t v667 = *(void *)(*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v664 + 56))(v664);
                    (*(void (**)(void))(v667 + 760))();
                    goto LABEL_152;
                  }
                  goto LABEL_217;
                }
                int v248 = &v741;
              }
            }
          }
          else
          {
            int v248 = v747;
          }
LABEL_517:
          uint64_t v254 = (uint64_t)v715;
          uint64_t v255 = (uint64_t)v247;
          goto LABEL_781;
        case 113:
          if (**(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8) == 2)
          {
            uint64_t v395 = 0;
            uint64_t v396 = 0;
            int v397 = 0;
            do
            {
              uint64_t v398 = *(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 96);
              *(_OWORD *)v747 = 0uLL;
              if ((*(unsigned int (**)(llvm::MCAsmParser *, unsigned char *))(*(void *)v715 + 192))(v715, v747)) {
                goto LABEL_1010;
              }
              uint64_t v399 = v715;
              unsigned int v400 = (llvm::MCContext *)(*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 48))(v715);
              *(_WORD *)&__dst[32] = 261;
              *(_OWORD *)int __dst = *(_OWORD *)v747;
              uint64_t v401 = llvm::MCContext::getOrCreateSymbol(v400, (unsigned __int8 ***)__dst);
              uint64_t v398 = *(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v399 + 40))(v399) + 96);
              v730[0] = 0;
              v730[1] = 0;
              if ((*(unsigned int (**)(llvm::MCAsmParser *, size_t *))(*(void *)v399 + 192))(v399, v730))
              {
LABEL_1010:
                int v471 = "expected identifier in directive";
                goto LABEL_1348;
              }
              int v402 = (llvm::MCContext *)(*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 48))(v715);
              *(_WORD *)&__dst[32] = 261;
              *(void *)int __dst = v730[0];
              *(void *)&__dst[8] = v730[1];
              uint64_t v403 = llvm::MCContext::getOrCreateSymbol(v402, (unsigned __int8 ***)__dst);
              uint64_t v404 = v403;
              if (v396 >= v395)
              {
                uint64_t v405 = ((char *)v396 - v397) >> 4;
                unint64_t v406 = v405 + 1;
                if ((unint64_t)(v405 + 1) >> 60) {
                  goto LABEL_1096;
                }
                if (((char *)v395 - v397) >> 3 > v406) {
                  unint64_t v406 = ((char *)v395 - v397) >> 3;
                }
                if ((unint64_t)((char *)v395 - v397) >= 0x7FFFFFFFFFFFFFF0) {
                  unint64_t v407 = 0xFFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v407 = v406;
                }
                if (v407)
                {
                  if (v407 >> 60) {
                    goto LABEL_1121;
                  }
                  uint64_t v408 = (char *)operator new(16 * v407);
                }
                else
                {
                  uint64_t v408 = 0;
                }
                uint64_t v409 = (uint64_t *)&v408[16 * v405];
                *uint64_t v409 = v401;
                v409[1] = v404;
                if (v396 == (uint64_t *)v397)
                {
                  unsigned int v411 = v396;
                  int v397 = &v408[16 * v405];
                }
                else
                {
                  int v410 = &v408[16 * v405];
                  do
                  {
                    *((_OWORD *)v410 - 1) = *((_OWORD *)v396 - 1);
                    v410 -= 16;
                    v396 -= 2;
                  }
                  while (v396 != (uint64_t *)v397);
                  unsigned int v411 = (uint64_t *)v397;
                  int v397 = v410;
                }
                uint64_t v395 = (uint64_t *)&v408[16 * v407];
                uint64_t v396 = v409 + 2;
                if (v411) {
                  operator delete(v411);
                }
              }
              else
              {
                uint64_t *v396 = v401;
                v396[1] = v403;
                v396 += 2;
              }
            }
            while (**(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8) == 2);
          }
          else
          {
            int v397 = 0;
            uint64_t v398 = 0;
          }
          *(_OWORD *)v747 = 0uLL;
          *(void *)int __dst = "expected comma before def_range type in .cv_def_range directive";
          *(_WORD *)&__dst[32] = 259;
          if (llvm::MCAsmParser::parseToken(v715, 25, (llvm::Twine *)__dst)
            || ((*(uint64_t (**)(llvm::MCAsmParser *, unsigned char *))(*(void *)v715 + 192))(v715, v747) & 1) != 0)
          {
            int v471 = "expected def_range type in directive";
          }
          else
          {
            unint64_t __pc = *((unsigned int *)v715 + 212);
            if (__pc)
            {
              size_t v503 = *(void *)&v747[8];
              __s1f = *(const void **)v747;
              int v504 = 0;
              if (*(void *)&v747[8])
              {
                uint64_t v505 = *(void *)&v747[8];
                unsigned int v506 = *(unsigned __int8 **)v747;
                do
                {
                  int v507 = *v506++;
                  int v504 = 33 * v504 + v507;
                  --v505;
                }
                while (v505);
              }
              uint64_t v508 = *((void *)v715 + 105);
              int v509 = 1;
              int v510 = v504;
              while (1)
              {
                uint64_t v511 = v510 & (__pc - 1);
                uint64_t v512 = *(void **)(v508 + 8 * v511);
                if (v512 != (void *)-8)
                {
                  if (!v512) {
                    goto LABEL_1347;
                  }
                  if (*(_DWORD *)(v508 + 8 * __pc + 8 + 4 * v511) == v504
                    && v503 == *v512
                    && (!v503 || !memcmp(__s1f, (char *)v512 + *((unsigned int *)v715 + 215), v503)))
                  {
                    break;
                  }
                }
                int v510 = v509 + v511;
                ++v509;
              }
              if (v511 != -1 && (int)v511 != __pc)
              {
                switch(*(_DWORD *)(*(void *)(v508 + 8 * (int)v511) + 8))
                {
                  case 1:
                    v730[0] = 0;
                    *(void *)int __dst = "expected comma before register number in .cv_def_range directive";
                    *(_WORD *)&__dst[32] = 259;
                    if (llvm::MCAsmParser::parseToken(v715, 25, (llvm::Twine *)__dst)
                      || ((*(uint64_t (**)(llvm::MCAsmParser *, size_t *))(*(void *)v715 + 256))(v715, v730) & 1) != 0)
                    {
                      goto LABEL_1442;
                    }
                    uint64_t v663 = *(void *)(*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
                    (*(void (**)(void))(v663 + 792))();
                    goto LABEL_1438;
                  case 2:
                    v730[0] = 0;
                    *(void *)int __dst = "expected comma before offset in .cv_def_range directive";
                    *(_WORD *)&__dst[32] = 259;
                    if (llvm::MCAsmParser::parseToken(v715, 25, (llvm::Twine *)__dst)
                      || ((*(uint64_t (**)(llvm::MCAsmParser *, size_t *))(*(void *)v715 + 256))(v715, v730) & 1) != 0)
                    {
                      goto LABEL_1479;
                    }
                    uint64_t v668 = *(void *)(*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
                    (*(void (**)(void))(v668 + 800))();
                    goto LABEL_1438;
                  case 3:
                    v730[0] = 0;
                    *(void *)int v786 = 0;
                    *(void *)int __dst = "expected comma before register number in .cv_def_range directive";
                    *(_WORD *)&__dst[32] = 259;
                    if (llvm::MCAsmParser::parseToken(v715, 25, (llvm::Twine *)__dst)
                      || ((*(uint64_t (**)(llvm::MCAsmParser *, size_t *))(*(void *)v715 + 256))(v715, v730) & 1) != 0)
                    {
LABEL_1442:
                      int v471 = "expected register number";
                      goto LABEL_1348;
                    }
                    *(void *)int __dst = "expected comma before offset in .cv_def_range directive";
                    *(_WORD *)&__dst[32] = 259;
                    if (!llvm::MCAsmParser::parseToken(v715, 25, (llvm::Twine *)__dst)
                      && ((*(uint64_t (**)(llvm::MCAsmParser *, unsigned char *))(*(void *)v715 + 256))(v715, v786) & 1) == 0)
                    {
                      uint64_t v684 = *(void *)(*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
                      (*(void (**)(void))(v684 + 784))();
                      goto LABEL_1438;
                    }
LABEL_1479:
                    int v471 = "expected offset value";
                    goto LABEL_1348;
                  case 4:
                    v730[0] = 0;
                    *(void *)int v786 = 0;
                    v744[0] = 0;
                    *(void *)int __dst = "expected comma before register number in .cv_def_range directive";
                    *(_WORD *)&__dst[32] = 259;
                    if (llvm::MCAsmParser::parseToken(v715, 25, (llvm::Twine *)__dst)
                      || ((*(uint64_t (**)(llvm::MCAsmParser *, size_t *))(*(void *)v715 + 256))(v715, v730) & 1) != 0)
                    {
                      int v471 = "expected register value";
                      goto LABEL_1348;
                    }
                    *(void *)int __dst = "expected comma before flag value in .cv_def_range directive";
                    *(_WORD *)&__dst[32] = 259;
                    if (llvm::MCAsmParser::parseToken(v715, 25, (llvm::Twine *)__dst)
                      || ((*(uint64_t (**)(llvm::MCAsmParser *, unsigned char *))(*(void *)v715 + 256))(v715, v786) & 1) != 0)
                    {
                      int v471 = "expected flag value";
                      goto LABEL_1348;
                    }
                    *(void *)int __dst = "expected comma before base pointer offset in .cv_def_range directive";
                    *(_WORD *)&__dst[32] = 259;
                    if (llvm::MCAsmParser::parseToken(v715, 25, (llvm::Twine *)__dst)
                      || ((*(uint64_t (**)(llvm::MCAsmParser *, void **))(*(void *)v715 + 256))(v715, v744) & 1) != 0)
                    {
                      int v471 = "expected base pointer offset value";
                      goto LABEL_1348;
                    }
                    uint64_t v685 = *(void *)(*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
                    (*(void (**)(void))(v685 + 776))();
LABEL_1438:
                    uint64_t v9 = 1;
                    if (!v397) {
                      goto LABEL_281;
                    }
                    goto LABEL_1349;
                  default:
                    break;
                }
              }
            }
LABEL_1347:
            int v471 = "unexpected def_range type in .cv_def_range directive";
          }
LABEL_1348:
          *(void *)int __dst = v471;
          *(_WORD *)&__dst[32] = 259;
          uint64_t v9 = llvm::MCAsmParser::Error((uint64_t)v715, v398, (uint64_t)__dst, 0, 0);
          if (!v397) {
            goto LABEL_281;
          }
LABEL_1349:
          uint64_t v242 = v397;
          goto LABEL_646;
        case 114:
          uint64_t v256 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
          (*(void (**)(uint64_t))(*(void *)v256 + 808))(v256);
          goto LABEL_152;
        case 115:
          memset(__dst, 0, 24);
          if (((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 264))(v715) & 1) != 0
            || ((*(uint64_t (**)(llvm::MCAsmParser *, unsigned char *))(*(void *)v715 + 208))(v715, __dst) & 1) != 0)
          {
            goto LABEL_534;
          }
          CVContext = (llvm::CodeViewContext *)llvm::MCContext::getCVContext(*((llvm::MCContext **)v715 + 27));
          if (__dst[23] >= 0) {
            uint64_t v179 = __dst;
          }
          else {
            uint64_t v179 = *(unsigned __int8 **)__dst;
          }
          if (__dst[23] >= 0) {
            size_t v180 = __dst[23] & 0x7F;
          }
          else {
            size_t v180 = *(void *)&__dst[8];
          }
          llvm::CodeViewContext::addToStringTable(CVContext, v179, v180, (uint64_t)v747);
          uint64_t v181 = *(void *)(*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
          (*(void (**)(void))(v181 + 520))();
          goto LABEL_638;
        case 116:
          uint64_t v262 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
          (*(void (**)(uint64_t))(*(void *)v262 + 816))(v262);
          goto LABEL_152;
        case 117:
          *(void *)v747 = 0;
          *(void *)int __dst = "expected identifier in directive";
          *(_WORD *)&__dst[32] = 259;
          if (llvm::MCAsmParser::parseIntToken(v715, (uint64_t *)v747, (const llvm::Twine *)__dst)) {
            goto LABEL_217;
          }
          *(void *)int __dst = "Expected End of Statement";
          *(_WORD *)&__dst[32] = 259;
          if (llvm::MCAsmParser::parseEOL(v715, (const llvm::Twine *)__dst)) {
            goto LABEL_217;
          }
          uint64_t v372 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
          (*(void (**)(uint64_t, void))(*(void *)v372 + 824))(v372, *(unsigned int *)v747);
          goto LABEL_152;
        case 118:
          (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715);
          *(_OWORD *)v747 = 0uLL;
          if ((*(unsigned int (**)(llvm::MCAsmParser *, unsigned char *))(*(void *)v715 + 192))(v715, v747))
          {
            int v280 = "expected symbol name";
            goto LABEL_870;
          }
          if (llvm::MCAsmParser::parseEOL(v715)) {
            goto LABEL_217;
          }
          uint64_t v469 = (llvm::MCContext *)(*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 48))(v715);
          *(_WORD *)&__dst[32] = 261;
          *(_OWORD *)int __dst = *(_OWORD *)v747;
          llvm::MCContext::getOrCreateSymbol(v469, (unsigned __int8 ***)__dst);
          uint64_t v470 = *(void *)(*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
          (*(void (**)(void))(v470 + 832))();
          goto LABEL_152;
        case 119:
          *(_OWORD *)v747 = 0uLL;
          char v376 = 0;
          char v377 = 0;
          if (llvm::MCAsmParser::parseOptionalToken(v715, 9)) {
            goto LABEL_798;
          }
          while (2)
          {
            if ((*(unsigned int (**)(llvm::MCAsmParser *, unsigned char *))(*(void *)v715 + 192))(v715, v747))
            {
              int v280 = "expected .eh_frame or .debug_frame";
              goto LABEL_870;
            }
            if (*(void *)&v747[8] == 12)
            {
              BOOL v467 = **(void **)v747 == 0x665F67756265642ELL && *(_DWORD *)(*(void *)v747 + 8) == 1701667186;
            }
            else
            {
              if (*(void *)&v747[8] == 9
                && **(void **)v747 == 0x6D6172665F68652ELL
                && *(unsigned char *)(*(void *)v747 + 8) == 101)
              {
                char v377 = 1;
                goto LABEL_981;
              }
              BOOL v467 = 0;
            }
            v376 |= v467;
LABEL_981:
            if (!llvm::MCAsmParser::parseOptionalToken(v715, 9))
            {
              *(void *)int __dst = "expected comma";
              *(_WORD *)&__dst[32] = 259;
              uint64_t v9 = 1;
              if (llvm::MCAsmParser::parseToken(v715, 25, (llvm::Twine *)__dst)) {
                goto LABEL_281;
              }
              continue;
            }
            break;
          }
LABEL_798:
          uint64_t v378 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
          (*(void (**)(uint64_t, void, void))(*(void *)v378 + 864))(v378, v377 & 1, v376 & 1);
          goto LABEL_152;
        case 120:
          *(_OWORD *)v747 = 0uLL;
          if (llvm::MCAsmParser::parseOptionalToken(v715, 9)) {
            goto LABEL_778;
          }
          if (((*(uint64_t (**)(llvm::MCAsmParser *, unsigned char *))(*(void *)v715 + 192))(v715, v747) & 1) != 0
            || *(void *)&v747[8] != 6)
          {
            *(void *)int __dst = "unexpected token";
            *(_WORD *)&__dst[32] = 259;
            llvm::MCAsmParser::check(v715, 1, (const llvm::Twine *)__dst);
          }
          else
          {
            int v543 = **(_DWORD **)v747 ^ 0x706D6973 | *(unsigned __int16 *)(*(void *)v747 + 4) ^ 0x656C;
            *(void *)int __dst = "unexpected token";
            *(_WORD *)&__dst[32] = 259;
            llvm::MCAsmParser::check(v715, v543 != 0, (const llvm::Twine *)__dst);
            if (!v543 && !llvm::MCAsmParser::parseEOL(v715))
            {
LABEL_778:
              uint64_t v363 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
              llvm::MCStreamer::emitCFIStartProc(v363, *(void *)&v747[8] != 0, *((void *)v715 + 17));
              goto LABEL_152;
            }
          }
          goto LABEL_217;
        case 121:
          if (llvm::MCAsmParser::parseEOL(v715)) {
            goto LABEL_217;
          }
          int v392 = (llvm::MCStreamer *)(*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
          llvm::MCStreamer::emitCFIEndProc(v392);
          goto LABEL_152;
        case 122:
          *(void *)v747 = 0;
          v730[0] = 0;
          if (sub_1CD3811E4((void **)v715, v747, (uint64_t)v725)) {
            goto LABEL_217;
          }
          *(void *)int __dst = "expected comma";
          *(_WORD *)&__dst[32] = 259;
          if (llvm::MCAsmParser::parseToken(v715, 25, (llvm::Twine *)__dst)
            || ((*(uint64_t (**)(llvm::MCAsmParser *, size_t *))(*(void *)v715 + 256))(v715, v730) & 1) != 0
            || llvm::MCAsmParser::parseEOL(v715))
          {
            goto LABEL_217;
          }
          uint64_t v203 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
          (*(void (**)(uint64_t, void, size_t))(*(void *)v203 + 872))(v203, *(void *)v747, v730[0]);
          goto LABEL_152;
        case 123:
          *(void *)int __dst = 0;
          if (((*(uint64_t (**)(llvm::MCAsmParser *, unsigned char *))(*(void *)v715 + 256))(v715, __dst) & 1) != 0
            || llvm::MCAsmParser::parseEOL(v715))
          {
            goto LABEL_217;
          }
          uint64_t v202 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
          (*(void (**)(uint64_t, void))(*(void *)v202 + 880))(v202, *(void *)__dst);
          goto LABEL_152;
        case 124:
          *(void *)int __dst = 0;
          if (((*(uint64_t (**)(llvm::MCAsmParser *, unsigned char *))(*(void *)v715 + 256))(v715, __dst) & 1) != 0
            || llvm::MCAsmParser::parseEOL(v715))
          {
            goto LABEL_217;
          }
          uint64_t v227 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
          (*(void (**)(uint64_t, void))(*(void *)v227 + 968))(v227, *(void *)__dst);
          goto LABEL_152;
        case 125:
          *(void *)int __dst = 0;
          if ((sub_1CD3811E4((void **)v715, __dst, (uint64_t)v725) & 1) != 0 || llvm::MCAsmParser::parseEOL(v715)) {
            goto LABEL_217;
          }
          uint64_t v261 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
          (*(void (**)(uint64_t, void))(*(void *)v261 + 888))(v261, *(void *)__dst);
          goto LABEL_152;
        case 126:
          *(void *)v747 = 0;
          v730[0] = 0;
          *(void *)int v786 = 0;
          if (sub_1CD3811E4((void **)v715, v747, (uint64_t)v725)) {
            goto LABEL_217;
          }
          *(void *)int __dst = "expected comma";
          *(_WORD *)&__dst[32] = 259;
          if (llvm::MCAsmParser::parseToken(v715, 25, (llvm::Twine *)__dst)) {
            goto LABEL_217;
          }
          if ((*(uint64_t (**)(llvm::MCAsmParser *, size_t *))(*(void *)v715 + 256))(v715, v730)) {
            goto LABEL_217;
          }
          *(void *)int __dst = "expected comma";
          *(_WORD *)&__dst[32] = 259;
          if (llvm::MCAsmParser::parseToken(v715, 25, (llvm::Twine *)__dst)
            || ((*(uint64_t (**)(llvm::MCAsmParser *, unsigned char *))(*(void *)v715 + 256))(v715, v786) & 1) != 0
            || llvm::MCAsmParser::parseEOL(v715))
          {
            goto LABEL_217;
          }
          uint64_t v259 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
          (*(void (**)(uint64_t, void, size_t, void))(*(void *)v259 + 896))(v259, *(void *)v747, v730[0], *(void *)v786);
          goto LABEL_152;
        case 127:
          *(void *)v747 = 0;
          v730[0] = 0;
          if (sub_1CD3811E4((void **)v715, v747, (uint64_t)v725)) {
            goto LABEL_217;
          }
          *(void *)int __dst = "expected comma";
          *(_WORD *)&__dst[32] = 259;
          if (llvm::MCAsmParser::parseToken(v715, 25, (llvm::Twine *)__dst)
            || ((*(uint64_t (**)(llvm::MCAsmParser *, size_t *))(*(void *)v715 + 256))(v715, v730) & 1) != 0
            || llvm::MCAsmParser::parseEOL(v715))
          {
            goto LABEL_217;
          }
          uint64_t v290 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
          (*(void (**)(uint64_t, void, size_t))(*(void *)v290 + 904))(v290, *(void *)v747, v730[0]);
          goto LABEL_152;
        case 128:
          *(void *)v747 = 0;
          v730[0] = 0;
          if (sub_1CD3811E4((void **)v715, v747, (uint64_t)v725)) {
            goto LABEL_217;
          }
          *(void *)int __dst = "expected comma";
          *(_WORD *)&__dst[32] = 259;
          if (llvm::MCAsmParser::parseToken(v715, 25, (llvm::Twine *)__dst)
            || ((*(uint64_t (**)(llvm::MCAsmParser *, size_t *))(*(void *)v715 + 256))(v715, v730) & 1) != 0
            || llvm::MCAsmParser::parseEOL(v715))
          {
            goto LABEL_217;
          }
          uint64_t v281 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
          (*(void (**)(uint64_t, void, size_t))(*(void *)v281 + 960))(v281, *(void *)v747, v730[0]);
          goto LABEL_152;
        case 129:
          uint64_t v173 = v715;
          int v174 = 1;
          goto LABEL_456;
        case 130:
          uint64_t v173 = v715;
          int v174 = 0;
LABEL_456:
          uint64_t v53 = sub_1CD37BF1C(v173, v174);
          goto LABEL_280;
        case 131:
          if (llvm::MCAsmParser::parseEOL(v715)) {
            goto LABEL_217;
          }
          uint64_t v414 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
          (*(void (**)(uint64_t))(*(void *)v414 + 928))(v414);
          goto LABEL_152;
        case 132:
          if (llvm::MCAsmParser::parseEOL(v715)) {
            goto LABEL_217;
          }
          uint64_t v379 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
          (*(void (**)(uint64_t))(*(void *)v379 + 936))(v379);
          goto LABEL_152;
        case 133:
          *(void *)int __dst = 0;
          if ((sub_1CD3811E4((void **)v715, __dst, (uint64_t)v725) & 1) != 0 || llvm::MCAsmParser::parseEOL(v715)) {
            goto LABEL_217;
          }
          uint64_t v172 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
          (*(void (**)(uint64_t, void))(*(void *)v172 + 944))(v172, *(void *)__dst);
          goto LABEL_152;
        case 134:
          *(void *)int __dst = 0;
          if ((sub_1CD3811E4((void **)v715, __dst, (uint64_t)v725) & 1) != 0 || llvm::MCAsmParser::parseEOL(v715)) {
            goto LABEL_217;
          }
          uint64_t v214 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
          (*(void (**)(uint64_t, void))(*(void *)v214 + 952))(v214, *(void *)__dst);
          goto LABEL_152;
        case 135:
          memset(__dst, 0, 24);
          *(void *)v747 = 0;
          if ((*(uint64_t (**)(llvm::MCAsmParser *, unsigned char *))(*(void *)v715 + 256))(v715, v747)) {
            goto LABEL_534;
          }
          std::string::push_back((std::string *)__dst, v747[0]);
          if (**(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8) != 25) {
            goto LABEL_631;
          }
          do
          {
            (*(void (**)(llvm::MCAsmParser *))(*(void *)v715 + 184))(v715);
            if ((*(uint64_t (**)(llvm::MCAsmParser *, unsigned char *))(*(void *)v715 + 256))(v715, v747))
            {
LABEL_534:
              uint64_t v9 = 1;
              goto LABEL_639;
            }
            std::string::push_back((std::string *)__dst, v747[0]);
          }
          while (**(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8) == 25);
LABEL_631:
          uint64_t v299 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
          if (__dst[23] >= 0) {
            uint64_t v300 = __dst;
          }
          else {
            uint64_t v300 = *(unsigned char **)__dst;
          }
          if (__dst[23] >= 0) {
            uint64_t v301 = __dst[23] & 0x7F;
          }
          else {
            uint64_t v301 = *(void *)&__dst[8];
          }
          (*(void (**)(uint64_t, unsigned char *, uint64_t))(*(void *)v299 + 976))(v299, v300, v301);
LABEL_638:
          uint64_t v9 = 0;
LABEL_639:
          if ((__dst[23] & 0x80000000) == 0) {
            goto LABEL_281;
          }
          uint64_t v242 = *(char **)__dst;
          goto LABEL_646;
        case 136:
          *(void *)int __dst = 0;
          if ((sub_1CD3811E4((void **)v715, __dst, (uint64_t)v725) & 1) != 0 || llvm::MCAsmParser::parseEOL(v715)) {
            goto LABEL_217;
          }
          uint64_t v177 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
          (*(void (**)(uint64_t, void))(*(void *)v177 + 984))(v177, *(void *)__dst);
          goto LABEL_152;
        case 137:
          if (llvm::MCAsmParser::parseEOL(v715)) {
            goto LABEL_217;
          }
          uint64_t v393 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
          (*(void (**)(uint64_t))(*(void *)v393 + 1000))(v393);
          goto LABEL_152;
        case 138:
          *(void *)int __dst = 0;
          if ((sub_1CD3811E4((void **)v715, __dst, (uint64_t)v725) & 1) != 0 || llvm::MCAsmParser::parseEOL(v715)) {
            goto LABEL_217;
          }
          uint64_t v272 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
          (*(void (**)(uint64_t, void))(*(void *)v272 + 1008))(v272, *(void *)__dst);
          goto LABEL_152;
        case 139:
          uint64_t v288 = v725;
          *(void *)v747 = 0;
          v730[0] = 0;
          if (sub_1CD3811E4((void **)v715, v747, (uint64_t)v725)) {
            goto LABEL_217;
          }
          *(void *)int __dst = "expected comma";
          *(_WORD *)&__dst[32] = 259;
          if (llvm::MCAsmParser::parseToken(v715, 25, (llvm::Twine *)__dst)
            || (sub_1CD3811E4((void **)v715, v730, (uint64_t)v288) & 1) != 0
            || llvm::MCAsmParser::parseEOL(v715))
          {
            goto LABEL_217;
          }
          uint64_t v289 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
          (*(void (**)(uint64_t, void, size_t))(*(void *)v289 + 1016))(v289, *(void *)v747, v730[0]);
          goto LABEL_152;
        case 140:
          if (llvm::MCAsmParser::parseEOL(v715)) {
            goto LABEL_217;
          }
          uint64_t v394 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
          (*(void (**)(uint64_t))(*(void *)v394 + 1024))(v394);
          goto LABEL_152;
        case 142:
        case 143:
          if (llvm::MCAsmParser::parseEOL(v715)) {
            goto LABEL_217;
          }
          BOOL v314 = v97 == 10 && *(void *)__s1b == 0x5F736F7263616D2ELL && __s1b[4] == 28271;
          uint64_t v9 = 0;
          *((unsigned char *)v715 + 424) = *((unsigned char *)v715 + 424) & 0xFE | v314;
          goto LABEL_281;
        case 144:
        case 145:
          if (llvm::MCAsmParser::parseEOL(v715)) {
            goto LABEL_217;
          }
          BOOL v312 = v97 == 9 && *(void *)__s1b == 0x7263616D746C612ELL && *((unsigned char *)__s1b + 8) == 111;
          uint64_t v9 = 0;
          *((unsigned char *)v715 + 807) = v312;
          goto LABEL_281;
        case 146:
          __s1c = v725;
          v790[1] = 0;
          v790[0] = 0;
          if (!(*(unsigned int (**)(llvm::MCAsmParser *, size_t *))(*(void *)v715 + 192))(v715, v790))
          {
            if (**(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8) == 25) {
              (*(void (**)(llvm::MCAsmParser *))(*(void *)v715 + 184))(v715);
            }
            v788[1] = 0;
            v788[0] = 0;
            unint64_t v789 = 0;
            if (**(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8) == 9)
            {
LABEL_449:
              sub_1CD8F38F8(v695);
              v730[1] = 0;
              v731[0] = 0;
              LODWORD(v731[2]) = 1;
              v731[1] = 0;
              uint64_t v226 = *(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8);
              uint64_t v694 = *(void *)(v226 + 8);
              if (*(_DWORD *)(v226 + 32) > 0x40u) {
                operator new[]();
              }
              int v419 = 0;
              uint64_t v420 = (uint64_t)v715;
              uint64_t v421 = v695;
              while (1)
              {
                while (**v7 == 1)
                  sub_1CD8F38F8(v421);
                if (!**(_DWORD **)((*(uint64_t (**)(uint64_t))(*(void *)v420 + 40))(v420) + 8))
                {
                  *(void *)int __dst = "no matching '.endmacro' in definition";
                  *(_WORD *)&__dst[32] = 259;
                  uint64_t v9 = llvm::MCAsmParser::Error(v420, (uint64_t)__s1c, (uint64_t)__dst, 0, 0);
                  int v698 = 0;
                  unsigned int v701 = 1;
                  goto LABEL_942;
                }
                if (**(_DWORD **)((*(uint64_t (**)(uint64_t))(*(void *)v420 + 40))(v420) + 8) == 2)
                {
                  uint64_t v422 = *(void *)((*(uint64_t (**)(uint64_t))(*(void *)v420 + 40))(v420) + 8);
                  if (*(_DWORD *)v422 == 2)
                  {
                    unsigned int v423 = *(int **)(v422 + 8);
                    unint64_t v424 = *(void *)(v422 + 16);
                  }
                  else
                  {
                    unsigned int v423 = *(int **)(v422 + 8);
                    unint64_t v426 = *(void *)(v422 + 16);
                    unint64_t v427 = v426 - 1;
                    unint64_t v428 = v426 != 0;
                    if (v426) {
                      unsigned int v423 = (int *)((char *)v423 + 1);
                    }
                    if (v428 > v427) {
                      unint64_t v427 = v426 != 0;
                    }
                    if (v426 < v427) {
                      unint64_t v427 = v426;
                    }
                    unint64_t v424 = v427 - v428;
                  }
                  if (v424 == 5)
                  {
                    int v429 = *v423;
                    int v430 = *((unsigned __int8 *)v423 + 4);
                    if (v429 == 1684956462 && v430 == 109) {
                      goto LABEL_921;
                    }
                  }
                  uint64_t v432 = *(void *)((*(uint64_t (**)(uint64_t))(*(void *)v420 + 40))(v420) + 8);
                  if (*(_DWORD *)v432 == 2)
                  {
                    unsigned int v433 = *(uint64_t **)(v432 + 8);
                    unint64_t v434 = *(void *)(v432 + 16);
                  }
                  else
                  {
                    unsigned int v433 = *(uint64_t **)(v432 + 8);
                    unint64_t v435 = *(void *)(v432 + 16);
                    unint64_t v436 = v435 - 1;
                    unint64_t v437 = v435 != 0;
                    if (v435) {
                      unsigned int v433 = (uint64_t *)((char *)v433 + 1);
                    }
                    if (v437 > v436) {
                      unint64_t v436 = v435 != 0;
                    }
                    if (v435 < v436) {
                      unint64_t v436 = v435;
                    }
                    unint64_t v434 = v436 - v437;
                  }
                  if (v434 == 9
                    && ((uint64_t v438 = *v433, v439 = *((unsigned __int8 *)v433 + 8), v438 == 0x7263616D646E652ELL)
                      ? (BOOL v440 = v439 == 111)
                      : (BOOL v440 = 0),
                        v440))
                  {
LABEL_921:
                    if (!v419)
                    {
                      uint64_t v502 = *(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715)
                                       + 8);
                      *(_OWORD *)v730 = *(_OWORD *)v502;
                      v731[0] = *(void *)(v502 + 16);
                      unsigned int v701 = *(_DWORD *)(v502 + 32);
                      if (v701 > 0x40)
                      {
                        llvm::APInt::reallocate((uint64_t)&v731[1], v701);
                        unsigned int v701 = v731[2];
                        if (LODWORD(v731[2]) <= 0x40)
                        {
                          int v698 = *(llvm::APInt **)(v502 + 24);
                          v731[1] = v698;
                        }
                        else
                        {
                          int v698 = (llvm::APInt *)v731[1];
                          memcpy((void *)v731[1], *(const void **)(v502 + 24), (((unint64_t)LODWORD(v731[2]) + 63) >> 3) & 0x3FFFFFF8);
                        }
                      }
                      else
                      {
                        int v698 = *(llvm::APInt **)(v502 + 24);
                        v731[1] = v698;
                        LODWORD(v731[2]) = v701;
                      }
                      sub_1CD8F38F8(v695);
                      if (**(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715)
                                       + 8) == 9)
                      {
                        uint64_t v526 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 48))(v715);
                        uint64_t v527 = *(unsigned int *)(v526 + 1976);
                        if (v527)
                        {
                          size_t v528 = v790[1];
                          uint64_t v529 = (const void *)v790[0];
                          int v530 = 0;
                          if (v790[1])
                          {
                            size_t v531 = v790[1];
                            unint64_t v532 = (unsigned __int8 *)v790[0];
                            do
                            {
                              int v533 = *v532++;
                              int v530 = 33 * v530 + v533;
                              --v531;
                            }
                            while (v531);
                          }
                          uint64_t v534 = *(void *)(v526 + 1968);
                          uint64_t v535 = *(unsigned int *)(v526 + 1988);
                          int v536 = 1;
                          int v537 = v530;
                          while (1)
                          {
                            uint64_t v538 = v537 & (v527 - 1);
                            char v539 = *(void **)(v534 + 8 * v538);
                            if (v539 != (void *)-8)
                            {
                              if (!v539) {
                                goto LABEL_1375;
                              }
                              if (*(_DWORD *)(v534 + 8 * v527 + 8 + 4 * v538) == v530
                                && v528 == *v539
                                && (!v528 || !memcmp(v529, (char *)v539 + v535, v528)))
                              {
                                break;
                              }
                            }
                            int v537 = v536 + v538;
                            ++v536;
                          }
                          if (v538 != -1 && (int)v538 != v527)
                          {
                            LOWORD(v787) = 1283;
                            *(void *)int v786 = "macro '";
                            *(void *)&v786[16] = v529;
                            *(void *)&v786[24] = v528;
                            *(void *)int __dst = v786;
                            *(void *)&__dst[16] = "' is already defined";
                            *(_WORD *)&__dst[32] = 770;
                            uint64_t v571 = llvm::MCAsmParser::Error((uint64_t)v715, (uint64_t)__s1c, (uint64_t)__dst, 0, 0);
                            goto LABEL_1170;
                          }
                        }
LABEL_1375:
                        size_t v690 = v730[1] - v694;
                        if (-1431655765 * ((v788[1] - v788[0]) >> 4)) {
                          BOOL v644 = v730[1] == v694;
                        }
                        else {
                          BOOL v644 = 1;
                        }
                        if (!v644)
                        {
                          char v691 = 0;
                          int v696 = 0;
                          uint64_t v692 = v788[0] + 8;
                          uint64_t v693 = -1431655765 * ((v788[1] - v788[0]) >> 4);
                          uint64_t v645 = MEMORY[0x1E4F14390];
                          unint64_t v646 = v730[1] - v694;
                          uint64_t v647 = v694;
                          do
                          {
                            uint64_t v648 = 1;
                            while (1)
                            {
                              int v649 = *(unsigned __int8 *)(v647 + v648 - 1);
                              if (v646 != v648 && v649 == 92) {
                                break;
                              }
                              if (v646 != v648 && v649 == 36)
                              {
                                uint64_t v650 = *(unsigned __int8 *)(v647 + v648);
                                if (v650 == 36
                                  || v650 == 110
                                  || (*(_DWORD *)(v645 + 4 * v650 + 60) & 0x400) != 0)
                                {
                                  BOOL v75 = v650 == 36;
                                  int v651 = v696;
                                  if (!v75) {
                                    int v651 = 1;
                                  }
                                  int v696 = v651;
                                  unint64_t v652 = v648 + 1;
                                  goto LABEL_1414;
                                }
                              }
                              if (++v648 - v646 == 1) {
                                goto LABEL_1418;
                              }
                            }
                            LODWORD(v653) = v648;
                            do
                            {
                              uint64_t v654 = *(unsigned __int8 *)(v647 + v653);
                              if (*(char *)(v647 + v653) < 0) {
                                int v655 = __maskrune(*(unsigned __int8 *)(v647 + v653), 0x500uLL);
                              }
                              else {
                                int v655 = *(_DWORD *)(v645 + 4 * v654 + 60) & 0x500;
                              }
                              unint64_t v652 = v653;
                              if (!v655
                                && ((v654 - 36) > 0x3B
                                 || ((1 << (v654 - 36)) & 0x800000000000401) == 0))
                              {
                                break;
                              }
                              uint64_t v653 = (v653 + 1);
                            }
                            while (v646 != v653);
                            uint64_t v658 = (void *)v692;
                            uint64_t v657 = v693;
                            while (v648 - v652 + *v658
                                 || v648 != v652
                                 && memcmp((const void *)*(v658 - 1), (const void *)(v647 + v648), v652 - v648))
                            {
                              v658 += 6;
                              if (!--v657) {
                                goto LABEL_1411;
                              }
                            }
                            if (v657)
                            {
                              char v691 = 1;
                            }
                            else
                            {
LABEL_1411:
                              if (*(unsigned char *)(v647 + v648) == 40 && *(unsigned char *)(v647 + v648 + 1) == 41) {
                                unint64_t v652 = v648 + 2;
                              }
                            }
LABEL_1414:
                            if (v646 >= v652) {
                              unint64_t v659 = v652;
                            }
                            else {
                              unint64_t v659 = v646;
                            }
                            v647 += v659;
                            v646 -= v659;
                          }
                          while (v646);
LABEL_1418:
                          if (v691 & 1) == 0 && (v696)
                          {
                            *(void *)int __dst = "macro defined with named parameters which are not used in macro body, pos"
                                               "sible positional parameter found in body which will have no effect";
                            *(_WORD *)&__dst[32] = 259;
                            (*(void (**)(llvm::MCAsmParser *, char *, unsigned char *, void, void))(*(void *)v715 + 168))(v715, __s1c, __dst, 0, 0);
                          }
                        }
                        unint64_t v660 = v789;
                        *(_OWORD *)__s1g = *(_OWORD *)v788;
                        unint64_t v789 = 0;
                        v788[1] = 0;
                        v788[0] = 0;
                        *(_OWORD *)int __dst = *(_OWORD *)v790;
                        *(void *)&__dst[16] = v694;
                        *(void *)&__dst[24] = v690;
                        uint64_t v785 = 0;
                        uint64_t v783 = 0;
                        int8x8_t v784 = 0;
                        char v794 = 0;
                        *(void *)int v786 = &v783;
                        sub_1CCBB91F0((void ***)v786);
                        uint64_t v661 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 48))(v715);
                        *(_OWORD *)v747 = *(_OWORD *)__dst;
                        *(_OWORD *)&v747[16] = *(_OWORD *)&__dst[16];
                        long long v748 = *(_OWORD *)__s1g;
                        *(void *)&__dst[32] = 0;
                        *(void *)&__dst[40] = 0;
                        unint64_t v749 = v660;
                        uint64_t v750 = 0;
                        uint64_t v752 = 0;
                        int v751 = 0;
                        uint64_t v792 = 0;
                        memset(v793, 0, sizeof(v793));
                        LOBYTE(v753) = 0;
                        sub_1CD8F4368(v661, (unsigned __int8 *)v790[0], v790[1], (uint64_t)v747);
                        *(void *)int v786 = &v750;
                        sub_1CB8338B8((void ***)v786);
                        *(void *)int v786 = &v748;
                        sub_1CCBB91F0((void ***)v786);
                        *(void *)int v786 = v793;
                        sub_1CB8338B8((void ***)v786);
                        *(void *)int v786 = &__dst[32];
                        sub_1CCBB91F0((void ***)v786);
                        uint64_t v9 = 0;
                      }
                      else
                      {
                        if (LODWORD(v730[0]) == 2)
                        {
                          size_t v540 = v730[1];
                          unint64_t v541 = v731[0];
                        }
                        else
                        {
                          size_t v540 = v730[1];
                          unint64_t v568 = v731[0];
                          unint64_t v569 = v731[0] - 1;
                          unint64_t v570 = v731[0] != 0;
                          if (v731[0]) {
                            size_t v540 = v730[1] + 1;
                          }
                          if (v570 > v569) {
                            unint64_t v569 = v731[0] != 0;
                          }
                          if (v731[0] >= v569) {
                            unint64_t v568 = v569;
                          }
                          unint64_t v541 = v568 - v570;
                        }
                        LOWORD(v787) = 1283;
                        *(void *)int v786 = "unexpected token in '";
                        *(void *)&v786[16] = v540;
                        *(void *)&v786[24] = v541;
                        *(void *)int __dst = v786;
                        *(void *)&__dst[16] = "' directive";
                        *(_WORD *)&__dst[32] = 770;
                        uint64_t v571 = llvm::MCAsmParser::TokError((uint64_t)v715, (uint64_t)__dst, 0, 0);
LABEL_1170:
                        uint64_t v9 = v571;
                      }
LABEL_942:
                      if (v701 >= 0x41 && v698) {
                        MEMORY[0x1D25D9CB0](v698, 0x1000C8000313F17);
                      }
LABEL_654:
                      *(void *)int __dst = v788;
                      sub_1CCBB91F0((void ***)__dst);
                      goto LABEL_281;
                    }
                    --v419;
                  }
                  else
                  {
                    uint64_t v441 = *(void *)((*(uint64_t (**)(void))(*(void *)v715 + 40))() + 8);
                    if (*(_DWORD *)v441 == 2)
                    {
                      uint64_t v442 = *(int **)(v441 + 8);
                      unint64_t v443 = *(void *)(v441 + 16);
                    }
                    else
                    {
                      uint64_t v442 = *(int **)(v441 + 8);
                      unint64_t v444 = *(void *)(v441 + 16);
                      unint64_t v445 = v444 - 1;
                      unint64_t v446 = v444 != 0;
                      if (v444) {
                        uint64_t v442 = (int *)((char *)v442 + 1);
                      }
                      if (v446 > v445) {
                        unint64_t v445 = v444 != 0;
                      }
                      if (v444 < v445) {
                        unint64_t v445 = v444;
                      }
                      unint64_t v443 = v445 - v446;
                    }
                    if (v443 == 6)
                    {
                      int v447 = *v442;
                      int v448 = *((unsigned __int16 *)v442 + 2);
                      int v450 = v447 == 1667329326 && v448 == 28530;
                    }
                    else
                    {
                      int v450 = 0;
                    }
                    v419 += v450;
                  }
                  uint64_t v420 = (uint64_t)v715;
                  uint64_t v421 = v695;
                }
                else if (**v7 == 8)
                {
                  uint64_t v425 = (*(uint64_t (**)(uint64_t))(*(void *)v420 + 40))(v420);
                  sub_1CD37A050(v420, *(void *)(v425 + 96), 1);
                }
                (*(void (**)(uint64_t))(*(void *)v420 + 224))(v420);
              }
            }
            while (1)
            {
              if (v788[0] != v788[1] && *(unsigned char *)(v788[1] - 7))
              {
                uint64_t v483 = *((void *)v715 + 17);
                LOWORD(v731[2]) = 1283;
                v730[0] = (size_t)"vararg parameter '";
                v731[0] = *(void *)(v788[1] - 48);
                v731[1] = *(void *)(v788[1] - 40);
                *(void *)int __dst = v730;
                *(void *)&__dst[16] = "' should be the last parameter";
                *(_WORD *)&__dst[32] = 770;
                uint64_t v9 = llvm::MCAsmParser::Error((uint64_t)v715, v483, (uint64_t)__dst, 0, 0);
                goto LABEL_654;
              }
              memset(__dst, 0, 42);
              if ((*(unsigned int (**)(llvm::MCAsmParser *, unsigned char *))(*(void *)v715 + 192))(v715, __dst)) {
                break;
              }
              uint64_t v215 = v788[0];
              uint64_t v216 = v788[1];
              if (v788[0] != v788[1])
              {
                int v217 = *(const void **)__dst;
                size_t v218 = *(void *)&__dst[8];
                while (*(void *)(v215 + 8) != v218 || v218 && memcmp(*(const void **)v215, v217, v218))
                {
                  v215 += 48;
                  if (v215 == v216) {
                    goto LABEL_422;
                  }
                }
                __int16 v743 = 1283;
                v741.__r_.__value_.__r.__words[0] = (std::string::size_type)"macro '";
                v741.__r_.__value_.__r.__words[2] = v790[0];
                size_t v742 = v790[1];
                v744[0] = &v741;
                v745 = "' has multiple parameters named '";
                __int16 v297 = 770;
                __int16 v746 = 770;
                *(void *)int v786 = v744;
                *(void *)&v786[16] = v217;
                *(void *)&v786[24] = v218;
                LOWORD(v787) = 1282;
                v730[0] = (size_t)v786;
                v730[1] = v218;
                v731[0] = "'";
                goto LABEL_626;
              }
LABEL_422:
              uint64_t v219 = v715;
              if (**v7 == 10)
              {
                (*(void (**)(llvm::MCAsmParser *))(*(void *)v715 + 184))(v715);
                uint64_t v739 = 0;
                std::string::size_type v740 = 0;
                uint64_t v220 = *((void *)v715 + 17);
                if ((*(unsigned int (**)(llvm::MCAsmParser *, uint64_t *))(*(void *)v715 + 192))(v715, &v739))
                {
                  __int16 v743 = 1283;
                  v741.__r_.__value_.__r.__words[0] = (std::string::size_type)"missing parameter qualifier for '";
                  v741.__r_.__value_.__r.__words[2] = *(void *)__dst;
                  size_t v742 = *(void *)&__dst[8];
                  v744[0] = &v741;
                  v745 = "' in macro '";
                  __int16 v746 = 770;
                  *(void *)int v786 = v744;
                  *(_OWORD *)&v786[16] = *(_OWORD *)v790;
                  LOWORD(v787) = 1282;
                  v730[0] = (size_t)v786;
                  v731[0] = "'";
                  LOWORD(v731[2]) = 770;
LABEL_1057:
                  uint64_t v298 = llvm::MCAsmParser::Error((uint64_t)v715, v220, (uint64_t)v730, 0, 0);
                  goto LABEL_627;
                }
                if (v740 == 6)
                {
                  if (*(_DWORD *)v739 != 1634886006 || *(_WORD *)(v739 + 4) != 26482)
                  {
LABEL_1009:
                    __int16 v738 = 773;
                    uint64_t v735 = v739;
                    std::string::size_type v736 = v740;
                    int v737 = " is not a valid parameter qualifier for '";
                    v741.__r_.__value_.__r.__words[0] = (std::string::size_type)&v735;
                    v741.__r_.__value_.__r.__words[2] = *(void *)__dst;
                    size_t v742 = *(void *)&__dst[8];
                    __int16 v743 = 1282;
                    v744[0] = &v741;
                    v745 = "' in macro '";
                    __int16 v746 = 770;
                    *(void *)int v786 = v744;
                    *(_OWORD *)&v786[16] = *(_OWORD *)v790;
                    LOWORD(v787) = 1282;
                    v730[0] = (size_t)v786;
                    v731[0] = "'";
                    LOWORD(v731[2]) = 770;
                    goto LABEL_1057;
                  }
                  __dst[41] = 1;
                }
                else
                {
                  if (v740 != 3) {
                    goto LABEL_1009;
                  }
                  if (*(_WORD *)v739 != 25970 || *(unsigned char *)(v739 + 2) != 113) {
                    goto LABEL_1009;
                  }
                  __dst[40] = 1;
                }
                uint64_t v219 = v715;
              }
              if (**(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v219 + 40))(v219) + 8) == 27)
              {
                (*(void (**)(llvm::MCAsmParser *))(*(void *)v219 + 184))(v219);
                uint64_t v223 = *((void *)v219 + 17);
                if (sub_1CD37E168((uint64_t)v219, (uint64_t)&__dst[16], 0))
                {
                  uint64_t v9 = 1;
                  goto LABEL_653;
                }
                if (__dst[40])
                {
                  __int16 v743 = 1283;
                  v741.__r_.__value_.__r.__words[0] = (std::string::size_type)"pointless default value for required parameter '";
                  v741.__r_.__value_.__r.__words[2] = *(void *)__dst;
                  size_t v742 = *(void *)&__dst[8];
                  v744[0] = &v741;
                  v745 = "' in macro '";
                  __int16 v746 = 770;
                  *(void *)int v786 = v744;
                  *(_OWORD *)&v786[16] = *(_OWORD *)v790;
                  LOWORD(v787) = 1282;
                  v730[0] = (size_t)v786;
                  v731[0] = "'";
                  LOWORD(v731[2]) = 770;
                  (*(void (**)(llvm::MCAsmParser *, uint64_t, size_t *, void, void))(*(void *)v715
                                                                                                 + 168))(v715, v223, v730, 0, 0);
                }
              }
              uint64_t v224 = v788[1];
              if (v788[1] >= v789)
              {
                uint64_t v225 = sub_1CD381324(v788, (uint64_t)__dst);
              }
              else
              {
                *(_OWORD *)v788[1] = *(_OWORD *)__dst;
                *(void *)(v224 + 24) = 0;
                *(void *)(v224 + 32) = 0;
                *(void *)(v224 + 16) = 0;
                *(_OWORD *)(v224 + 16) = *(_OWORD *)&__dst[16];
                *(void *)(v224 + 32) = *(void *)&__dst[32];
                memset(&__dst[16], 0, 24);
                *(_WORD *)(v224 + 40) = *(_WORD *)&__dst[40];
                uint64_t v225 = v224 + 48;
              }
              v788[1] = v225;
              if (**(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8) == 25) {
                (*(void (**)(llvm::MCAsmParser *))(*(void *)v715 + 184))(v715);
              }
              v730[0] = (size_t)&__dst[16];
              sub_1CCBB926C((void ***)v730);
              if (**(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8) == 9) {
                goto LABEL_449;
              }
            }
            v730[0] = (size_t)"expected identifier in '.macro' directive";
            __int16 v297 = 259;
LABEL_626:
            LOWORD(v731[2]) = v297;
            uint64_t v298 = llvm::MCAsmParser::TokError((uint64_t)v715, (uint64_t)v730, 0, 0);
LABEL_627:
            uint64_t v9 = v298;
LABEL_653:
            v730[0] = (size_t)&__dst[16];
            sub_1CCBB926C((void ***)v730);
            goto LABEL_654;
          }
          int v280 = "expected identifier in '.macro' directive";
          goto LABEL_870;
        case 147:
          if (llvm::MCAsmParser::parseEOL(v715)) {
            goto LABEL_217;
          }
          uint64_t v353 = *((void *)v715 + 45);
          if (*((void *)v715 + 44) == v353) {
            goto LABEL_289;
          }
          uint64_t v355 = *((void *)v715 + 37);
          uint64_t v354 = *((void *)v715 + 38);
          if (*(void *)(*(void *)(v353 - 8) + 24) != (v354 - v355) >> 3)
          {
            unsigned int v356 = (int *)(v354 - 8);
            uint64_t v357 = (uint64_t)v356 - v355;
            do
            {
              int v358 = *v356;
              *((_WORD *)v715 + 144) = *((_WORD *)v356 + 2);
              *((_DWORD *)v715 + 71) = v358;
              *((void *)v715 + 38) = v356;
              BOOL v75 = *(void *)(*(void *)(v353 - 8) + 24) == v357 >> 3;
              v357 -= 8;
              v356 -= 2;
            }
            while (!v75);
          }
          goto LABEL_468;
        case 148:
        case 149:
          if (**(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8) == 9)
          {
            if (*((void *)v715 + 44) != *((void *)v715 + 45))
            {
LABEL_468:
              sub_1CD380760(v715);
              goto LABEL_152;
            }
LABEL_289:
            LOWORD(v748) = 1283;
            *(void *)v747 = "unexpected '";
            *(void *)&v747[16] = __s1b;
            *(void *)&v747[24] = v97;
            unsigned int v154 = "' in file, no current macro definition";
          }
          else
          {
            LOWORD(v748) = 1283;
            *(void *)v747 = "unexpected token in '";
            *(void *)&v747[16] = __s1b;
            *(void *)&v747[24] = v97;
            unsigned int v154 = "' directive";
          }
          *(void *)int __dst = v747;
          *(void *)&__dst[16] = v154;
          __int16 v303 = 770;
          goto LABEL_871;
        case 150:
          __s1d = v725;
          v730[0] = 0;
          v730[1] = 0;
          uint64_t v364 = *(void *)(*(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715)
                                       + 8)
                           + 8);
          char v365 = (*(uint64_t (**)(llvm::MCAsmParser *, size_t *))(*(void *)v715 + 192))(v715, v730);
          *(void *)int __dst = "expected identifier in '.purgem' directive";
          *(_WORD *)&__dst[32] = 259;
          if ((v365 & 1) == 0)
          {
            if (llvm::MCAsmParser::parseEOL(v715)) {
              goto LABEL_217;
            }
            uint64_t v452 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 48))(v715);
            size_t v453 = v730[1];
            uint64_t v454 = *(unsigned int *)(v452 + 1976);
            if (v454)
            {
              unsigned int v455 = (const void *)v730[0];
              int v456 = 0;
              if (v730[1])
              {
                size_t v457 = v730[1];
                uint64_t v458 = (unsigned __int8 *)v730[0];
                do
                {
                  int v459 = *v458++;
                  int v456 = 33 * v456 + v459;
                  --v457;
                }
                while (v457);
              }
              uint64_t v460 = *(void *)(v452 + 1968);
              uint64_t v461 = *(unsigned int *)(v452 + 1988);
              int v462 = 1;
              int v463 = v456;
              while (1)
              {
                uint64_t v464 = v463 & (v454 - 1);
                uint64_t v465 = *(void **)(v460 + 8 * v464);
                if (v465 != (void *)-8)
                {
                  if (!v465) {
                    goto LABEL_1478;
                  }
                  if (*(_DWORD *)(v460 + 8 * v454 + 8 + 4 * v464) == v456
                    && v453 == *v465
                    && (!v453 || !memcmp(v455, (char *)v465 + v461, v453)))
                  {
                    break;
                  }
                }
                int v463 = v462 + v464;
                ++v462;
              }
              if (v464 != -1 && (int)v464 != v454)
              {
                uint64_t v605 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 48))(v715);
                sub_1CD381458(v605 + 1968, (unsigned __int8 *)v730[0], v730[1]);
                goto LABEL_152;
              }
            }
            else
            {
              unsigned int v455 = (const void *)v730[0];
            }
LABEL_1478:
            LOWORD(v748) = 1283;
            *(void *)v747 = "macro '";
            *(void *)&v747[16] = v455;
            *(void *)&v747[24] = v453;
            *(void *)int __dst = v747;
            *(void *)&__dst[16] = "' is not defined";
            *(_WORD *)&__dst[32] = 770;
            uint64_t v114 = (uint64_t)v715;
            long long v113 = __s1d;
            goto LABEL_279;
          }
          int v248 = __dst;
          uint64_t v254 = (uint64_t)v715;
          uint64_t v255 = v364;
LABEL_781:
          llvm::MCAsmParser::Error(v254, v255, (uint64_t)v248, 0, 0);
          goto LABEL_217;
        case 151:
          char v175 = v715;
          char v176 = 1;
          goto LABEL_544;
        case 152:
          char v175 = v715;
          char v176 = 0;
LABEL_544:
          uint64_t v53 = sub_1CD37BE90(v175, v176);
          goto LABEL_280;
        case 153:
          uint64_t v269 = v725;
          uint64_t v270 = (uint64_t)v715;
          char v271 = 0;
          goto LABEL_574;
        case 154:
          uint64_t v269 = v725;
          uint64_t v270 = (uint64_t)v715;
          char v271 = 1;
LABEL_574:
          uint64_t v53 = sub_1CD37C184(v270, (uint64_t)v269, v271);
          goto LABEL_280;
        case 155:
          uint64_t v234 = v725;
          uint64_t v235 = *((void *)v715 + 38);
          if (*((void *)v715 + 37) != v235 && *(unsigned char *)(v235 - 3))
          {
LABEL_475:
            (*(void (**)(llvm::MCAsmParser *))(*(void *)v715 + 224))(v715);
            goto LABEL_152;
          }
          if (llvm::MCAsmParser::parseOptionalToken(v715, 9))
          {
            uint64_t v316 = ".warning directive invoked in source file";
            uint64_t v317 = 41;
          }
          else
          {
            if (**v7 != 3)
            {
              int v280 = ".warning argument must be a string";
LABEL_870:
              *(void *)int __dst = v280;
              __int16 v303 = 259;
LABEL_871:
              *(_WORD *)&__dst[32] = v303;
              uint64_t v53 = llvm::MCAsmParser::TokError((uint64_t)v715, (uint64_t)__dst, 0, 0);
              goto LABEL_280;
            }
            uint64_t v521 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715);
            unint64_t v522 = *(void *)(*(void *)(v521 + 8) + 16);
            unint64_t v523 = v522 != 0;
            if (v522) {
              uint64_t v316 = (const char *)(*(void *)(*(void *)(v521 + 8) + 8) + 1);
            }
            else {
              uint64_t v316 = *(const char **)(*(void *)(v521 + 8) + 8);
            }
            if (v523 <= v522 - 1) {
              unint64_t v524 = v522 - 1;
            }
            else {
              unint64_t v524 = v522 != 0;
            }
            if (v522 >= v524) {
              unint64_t v525 = v524;
            }
            else {
              unint64_t v525 = *(void *)(*(void *)(v521 + 8) + 16);
            }
            (*(void (**)(llvm::MCAsmParser *))(*(void *)v715 + 184))(v715);
            if (llvm::MCAsmParser::parseEOL(v715)) {
              goto LABEL_217;
            }
            uint64_t v317 = v525 - v523;
          }
          *(_WORD *)&__dst[32] = 261;
          *(void *)int __dst = v316;
          *(void *)&__dst[8] = v317;
          uint64_t v53 = (*(uint64_t (**)(llvm::MCAsmParser *, char *, unsigned char *, void, void))(*(void *)v715 + 168))(v715, v234, __dst, 0, 0);
          goto LABEL_280;
        case 156:
          int v348 = v725;
          __int16 v349 = *(int **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8);
          int v350 = *v349;
          unsigned int v352 = (unsigned char *)*((void *)v349 + 1);
          unint64_t v351 = *((void *)v349 + 2);
          if (v349[8] > 0x40) {
            operator new[]();
          }
          (*(void (**)(llvm::MCAsmParser *))(*(void *)v715 + 184))(v715);
          if (v350 == 3 && *v352 == 34)
          {
            BOOL v451 = llvm::MCAsmParser::parseEOL(v715);
            if (v451)
            {
              uint64_t v9 = 1;
            }
            else
            {
              uint64_t v513 = (llvm::raw_ostream *)llvm::outs((llvm *)v451);
              uint64_t v514 = v513;
              unint64_t v515 = v351 - 1;
              unint64_t v516 = v351 != 0;
              if (v351) {
                uint64_t v517 = v352 + 1;
              }
              else {
                uint64_t v517 = v352;
              }
              if (v516 > v515) {
                unint64_t v515 = v351 != 0;
              }
              if (v351 < v515) {
                unint64_t v515 = v351;
              }
              unint64_t v518 = v515 - v516;
              uint64_t v520 = *((void *)v513 + 3);
              uint64_t v519 = (unsigned char *)*((void *)v513 + 4);
              if (v515 - v516 <= v520 - (uint64_t)v519)
              {
                if (v515 != v516)
                {
                  memcpy(v519, v517, v515 - v516);
                  uint64_t v519 = (unsigned char *)(*((void *)v514 + 4) + v518);
                  *((void *)v514 + 4) = v519;
                }
              }
              else
              {
                llvm::raw_ostream::write(v514, (const char *)v517, v515 - v516);
                uint64_t v519 = (unsigned char *)*((void *)v514 + 4);
              }
              if ((unint64_t)v519 >= *((void *)v514 + 3))
              {
                llvm::raw_ostream::write(v514, 10);
                uint64_t v9 = 0;
              }
              else
              {
                uint64_t v9 = 0;
                *((void *)v514 + 4) = v519 + 1;
                *uint64_t v519 = 10;
              }
            }
          }
          else
          {
            *(void *)int __dst = "expected double quoted string after .print";
            *(_WORD *)&__dst[32] = 259;
            uint64_t v9 = llvm::MCAsmParser::Error((uint64_t)v715, (uint64_t)v348, (uint64_t)__dst, 0, 0);
          }
          goto LABEL_281;
        case 157:
          if (llvm::MCAsmParser::parseEOL(v715)) {
            goto LABEL_217;
          }
          uint64_t v347 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
          (*(void (**)(uint64_t))(*(void *)v347 + 1176))(v347);
          goto LABEL_152;
        case 158:
          *(_OWORD *)v747 = 0uLL;
          uint64_t v415 = (*(uint64_t (**)(llvm::MCAsmParser *, unsigned char *))(*(void *)v715 + 192))(v715, v747);
          char v416 = v415;
          *(void *)int __dst = "expected identifier";
          *(_WORD *)&__dst[32] = 259;
          llvm::MCAsmParser::check(v715, v415, (const llvm::Twine *)__dst);
          if ((v416 & 1) != 0 || llvm::MCAsmParser::parseEOL(v715)) {
            goto LABEL_217;
          }
          unint64_t v417 = (llvm::MCContext *)(*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 48))(v715);
          *(_WORD *)&__dst[32] = 261;
          *(_OWORD *)int __dst = *(_OWORD *)v747;
          llvm::MCContext::getOrCreateSymbol(v417, (unsigned __int8 ***)__dst);
          uint64_t v418 = *(void *)(*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
          (*(void (**)(void))(v418 + 1184))();
          goto LABEL_152;
        case 159:
          v730[0] = 0;
          *(void *)int v786 = 0;
          v744[0] = 0;
          v741.__r_.__value_.__r.__words[0] = 0;
          if (**(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8) == 4)
          {
            *(void *)int __dst = "unexpected token in '.pseudoprobe' directive";
            *(_WORD *)&__dst[32] = 259;
            if (llvm::MCAsmParser::parseIntToken(v715, (uint64_t *)v730, (const llvm::Twine *)__dst)) {
              goto LABEL_217;
            }
          }
          if (**(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8) == 4)
          {
            *(void *)int __dst = "unexpected token in '.pseudoprobe' directive";
            *(_WORD *)&__dst[32] = 259;
            if (llvm::MCAsmParser::parseIntToken(v715, (uint64_t *)v786, (const llvm::Twine *)__dst)) {
              goto LABEL_217;
            }
          }
          if (**(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8) == 4)
          {
            *(void *)int __dst = "unexpected token in '.pseudoprobe' directive";
            *(_WORD *)&__dst[32] = 259;
            if (llvm::MCAsmParser::parseIntToken(v715, (uint64_t *)v744, (const llvm::Twine *)__dst)) {
              goto LABEL_217;
            }
          }
          if (**(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8) == 4)
          {
            *(void *)int __dst = "unexpected token in '.pseudoprobe' directive";
            *(_WORD *)&__dst[32] = 259;
            if (llvm::MCAsmParser::parseIntToken(v715, (uint64_t *)&v741, (const llvm::Twine *)__dst)) {
              goto LABEL_217;
            }
          }
          *(void *)int __dst = &__dst[16];
          *(void *)&__dst[8] = 0x800000000;
          uint64_t v284 = v715;
          if (**(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8) != 45) {
            goto LABEL_647;
          }
          do
          {
            (*(void (**)(llvm::MCAsmParser *))(*(void *)v284 + 184))(v284);
            uint64_t v735 = 0;
            if (**(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v284 + 40))(v284) + 8) == 4)
            {
              *(void *)v747 = "unexpected token in '.pseudoprobe' directive";
              LOWORD(v748) = 259;
              if (llvm::MCAsmParser::parseIntToken(v284, &v735, (const llvm::Twine *)v747)) {
                goto LABEL_648;
              }
            }
            if (**(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v284 + 40))(v284) + 8) == 10) {
              (*(void (**)(llvm::MCAsmParser *))(*(void *)v284 + 184))(v284);
            }
            v788[0] = 0;
            uint64_t v285 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v284 + 40))(v284);
            uint64_t v286 = 0;
            if (**(_DWORD **)(v285 + 8) == 4)
            {
              *(void *)v747 = "unexpected token in '.pseudoprobe' directive";
              LOWORD(v748) = 259;
              if (llvm::MCAsmParser::parseIntToken(v715, v788, (const llvm::Twine *)v747)) {
                goto LABEL_648;
              }
              uint64_t v286 = LODWORD(v788[0]);
            }
            if (*(unsigned int *)&__dst[8] >= (unint64_t)*(unsigned int *)&__dst[12]) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            int v287 = (uint64_t *)(*(void *)__dst + 16 * *(unsigned int *)&__dst[8]);
            uint64_t *v287 = v735;
            v287[1] = v286;
            ++*(_DWORD *)&__dst[8];
            uint64_t v284 = v715;
          }
          while (**(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 40))(v715) + 8) == 45);
LABEL_647:
          if (llvm::MCAsmParser::parseEOL(v284))
          {
LABEL_648:
            uint64_t v9 = 1;
            goto LABEL_649;
          }
          uint64_t v305 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
          (*(void (**)(uint64_t, size_t, void, void *, std::string::size_type, unsigned char *))(*(void *)v305 + 1200))(v305, v730[0], *(void *)v786, v744[0], v741.__r_.__value_.__r.__words[0], __dst);
          uint64_t v9 = 0;
LABEL_649:
          uint64_t v302 = *(void **)__dst;
          if (*(unsigned char **)__dst != &__dst[16]) {
LABEL_650:
          }
            free(v302);
          goto LABEL_281;
        case 160:
          *(void *)int __dst = v715;
          *((_DWORD *)v715 + 184) = 0;
          sub_1CB833A08((uint64_t)v715 + 776, *((void **)v715 + 98));
          *((void *)v715 + 97) = (char *)v715 + 784;
          *((void *)v715 + 99) = 0;
          *((void *)v715 + 98) = 0;
          uint64_t v260 = (uint64_t (*)(uint64_t))sub_1CD381564;
          uint64_t v163 = v715;
LABEL_583:
          uint64_t v53 = llvm::MCAsmParser::parseMany(v163, v260, (uint64_t)__dst, 1);
          goto LABEL_280;
        case 161:
          __int16 v169 = v715;
          unsigned int v170 = 3;
LABEL_621:
          uint64_t v53 = sub_1CD37B35C(v169, v170);
          goto LABEL_280;
        case 162:
          uint64_t v182 = v715;
          (*(void (**)(llvm::MCAsmParser *))(*(void *)v715 + 184))(v715);
          memset(v786, 0, 24);
          break;
        case 163:
          if (llvm::MCAsmParser::parseEOL(v715)) {
            goto LABEL_217;
          }
          if (!**v7) {
            goto LABEL_152;
          }
          do
          {
            sub_1CD8F38F8(v695);
            uint64_t v9 = 0;
          }
          while (**v7);
          goto LABEL_281;
        default:
          long long v113 = v725;
          *(void *)int __dst = "unknown directive";
          *(_WORD *)&__dst[32] = 259;
          uint64_t v114 = (uint64_t)v715;
          goto LABEL_279;
      }
      do
      {
        uint64_t v183 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v182 + 184))(v182);
        uint64_t v185 = *(const void **)(v183 + 8);
        size_t v184 = *(void *)(v183 + 16);
        if (*(_DWORD *)(v183 + 32) > 0x40u) {
          operator new[]();
        }
        if (!*(_DWORD *)v183)
        {
          *(void *)int __dst = "flatbuffer injection directive in use, but didn't find flatbuffer injection data.\n";
          *(_WORD *)&__dst[32] = 259;
          uint64_t v182 = v715;
          llvm::MCAsmParser::Error((uint64_t)v715, (uint64_t)v185, (uint64_t)__dst, 0, 0);
          int v196 = 1;
          continue;
        }
        if (v184 > 0x7FFFFFFFFFFFFFF7) {
          goto LABEL_1096;
        }
        if (v184 >= 0x17)
        {
          uint64_t v187 = (v184 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v184 | 7) != 0x17) {
            uint64_t v187 = v184 | 7;
          }
          uint64_t v188 = v187 + 1;
          int v186 = operator new(v187 + 1);
          *(void *)&__dst[16] = v188 | 0x8000000000000000;
          *(void *)int __dst = v186;
          *(void *)&__dst[8] = v184;
        }
        else
        {
          __dst[23] = *(void *)(v183 + 16);
          int v186 = __dst;
          if (!v184) {
            goto LABEL_338;
          }
        }
        memmove(v186, v185, v184);
LABEL_338:
        v186[v184] = 0;
        if (__dst[23] >= 0) {
          int64_t v189 = __dst[23];
        }
        else {
          int64_t v189 = *(void *)&__dst[8];
        }
        if (__dst[23] >= 0) {
          uint64_t v190 = __dst;
        }
        else {
          uint64_t v190 = *(const std::string::value_type **)__dst;
        }
        int v191 = &v190[v189];
        if (v189 >= 15)
        {
          int64_t v192 = v189;
          uint64_t v193 = (std::string::value_type *)v190;
          do
          {
            int v194 = (const std::string::value_type *)memchr(v193, 46, v192 - 14);
            if (!v194) {
              break;
            }
            if (*(void *)v194 == 0x66756274616C662ELL && *(void *)(v194 + 7) == 0x646E655F72656666)
            {
              if (v194 != v191 && v194 - v190 != -1)
              {
                int v196 = 3;
                goto LABEL_374;
              }
              break;
            }
            uint64_t v193 = (std::string::value_type *)(v194 + 1);
            int64_t v192 = v191 - v193;
          }
          while (v191 - v193 >= 15);
        }
        if (v189 >= 2)
        {
          int64_t v197 = v189;
          int v198 = (std::string::value_type *)v190;
          do
          {
            uint64_t v199 = (char *)memchr(v198, 47, v197 - 1);
            if (!v199) {
              break;
            }
            if (*(_WORD *)v199 == 12079)
            {
              if (v199 == v191 || v199 - v190 == -1) {
                break;
              }
              std::string::basic_string((std::string *)v747, (const std::string *)__dst, v199 - v190 + 2, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)v730);
              if (v747[23] >= 0) {
                uint64_t v200 = v747;
              }
              else {
                uint64_t v200 = *(const std::string::value_type **)v747;
              }
              if (v747[23] >= 0) {
                std::string::size_type v201 = v747[23] & 0x7F;
              }
              else {
                std::string::size_type v201 = *(void *)&v747[8];
              }
              std::string::append((std::string *)v786, v200, v201);
              if ((v747[23] & 0x80000000) != 0) {
                operator delete(*(void **)v747);
              }
              goto LABEL_373;
            }
            int v198 = v199 + 1;
            int64_t v197 = v191 - v198;
          }
          while (v191 - v198 >= 2);
        }
        std::string::append((std::string *)v786, v190, v189);
LABEL_373:
        int v196 = 0;
LABEL_374:
        uint64_t v182 = v715;
        if ((__dst[23] & 0x80000000) != 0) {
          operator delete(*(void **)__dst);
        }
      }
      while (!v196);
      if (v196 != 3) {
        goto LABEL_759;
      }
      uint64_t v291 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)v715 + 56))(v715);
      uint64_t v292 = *(void *)(*(void *)(v291 + 112) + 32 * *(unsigned int *)(v291 + 120) - 32);
      BOOL v293 = (const char *)(v292 + 224);
      if (*(unsigned char *)(v292 + 239))
      {
        size_t v294 = 16;
        __dst[23] = 16;
        uint64_t v295 = __dst;
        char v296 = 1;
        goto LABEL_693;
      }
      size_t v304 = strlen(v293);
      if (v304 > 0x7FFFFFFFFFFFFFF7) {
        goto LABEL_1096;
      }
      size_t v294 = v304;
      if (v304 >= 0x17)
      {
        uint64_t v318 = (v304 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v304 | 7) != 0x17) {
          uint64_t v318 = v304 | 7;
        }
        uint64_t v319 = v318 + 1;
        uint64_t v295 = operator new(v318 + 1);
        char v296 = 0;
        *(void *)&__dst[16] = v319 | 0x8000000000000000;
        *(void *)int __dst = v295;
        *(void *)&__dst[8] = v294;
        goto LABEL_693;
      }
      __dst[23] = v304;
      uint64_t v295 = __dst;
      char v296 = 1;
      if (v304) {
LABEL_693:
      }
        memmove(v295, v293, v294);
      BOOL v320 = 0;
      v295[v294] = 0;
      char v321 = __dst[23];
      unint64_t v322 = *(void *)&__dst[8];
      if (__dst[23] >= 0) {
        uint64_t v323 = __dst[23] & 0x7F;
      }
      else {
        uint64_t v323 = *(void *)&__dst[8];
      }
      if (v323 != 16)
      {
        if ((__dst[23] & 0x80) != 0) {
          goto LABEL_707;
        }
LABEL_710:
        if (!v320) {
          goto LABEL_711;
        }
        goto LABEL_1008;
      }
      if ((__dst[23] & 0x80) != 0)
      {
        unsigned int v324 = *(unsigned char **)__dst;
      }
      else
      {
        unsigned int v324 = __dst;
        unint64_t v322 = __dst[23];
      }
      if (v322 >= 0x10) {
        size_t v325 = 16;
      }
      else {
        size_t v325 = v322;
      }
      BOOL v326 = memcmp(v324, "__GPU_METADATA_2", v325) == 0;
      BOOL v320 = v322 == 16 && v326;
      if ((v321 & 0x80) == 0) {
        goto LABEL_710;
      }
LABEL_707:
      operator delete(*(void **)__dst);
      if (v320) {
        goto LABEL_1008;
      }
LABEL_711:
      if ((v296 & 1) == 0)
      {
        uint64_t v328 = (v294 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v294 | 7) != 0x17) {
          uint64_t v328 = v294 | 7;
        }
        uint64_t v329 = v328 + 1;
        unsigned int v327 = operator new(v328 + 1);
        *(void *)&__dst[16] = v329 | 0x8000000000000000;
        *(void *)int __dst = v327;
        *(void *)&__dst[8] = v294;
        goto LABEL_717;
      }
      __dst[23] = v294;
      unsigned int v327 = __dst;
      if (v294) {
LABEL_717:
      }
        memmove(v327, v293, v294);
      BOOL v330 = 0;
      v327[v294] = 0;
      char v331 = __dst[23];
      unint64_t v332 = *(void *)&__dst[8];
      if (__dst[23] >= 0) {
        uint64_t v333 = __dst[23] & 0x7F;
      }
      else {
        uint64_t v333 = *(void *)&__dst[8];
      }
      if (v333 != 14)
      {
        if ((__dst[23] & 0x80) != 0) {
          goto LABEL_731;
        }
LABEL_734:
        if (!v330) {
          goto LABEL_735;
        }
LABEL_1008:
        *(_DWORD *)&v747[3] = 0x10000;
        *(_DWORD *)v747 = 256;
        *(void *)&v747[8] = 0x100010100000002;
        v747[16] = 1;
        *(void *)&v747[17] = 0;
        v747[25] = 0;
        HIBYTE(v749) = 15;
        strcpy((char *)&v748, "std::unique_ptr");
        uint64_t v756 = 0;
        uint64_t v754 = 0;
        uint64_t v755 = 0;
        uint64_t v752 = 0;
        int v753 = 0;
        uint64_t v750 = 0;
        int v751 = 0;
        __int16 v757 = 84;
        int v758 = 257;
        v761[0] = 0;
        *(void *)((char *)v761 + 5) = 0;
        uint64_t v759 = 0;
        uint64_t v760 = 0;
        long long v762 = 0u;
        long long v763 = 0u;
        long long v764 = 0u;
        int v765 = 1;
        v768[0] = 0;
        *(_DWORD *)((char *)v768 + 7) = 0;
        uint64_t v766 = 0;
        uint64_t v767 = 0;
        long long v769 = 0u;
        long long v770 = 0u;
        long long v771 = 0u;
        long long v772 = 0u;
        uint64_t v773 = 0;
        strcpy(v775, "\n");
        strcpy(v774, "_generated");
        uint64_t v779 = 0;
        v775[2] = 0;
        __int16 v776 = 0;
        int v777 = 0;
        uint64_t v778 = 0;
        uint64_t v780 = 1;
        uint64_t v781 = 0;
        __int16 v782 = 257;
        sub_1CD639970((uint64_t)__dst, (long long *)v747);
      }
      if ((__dst[23] & 0x80) != 0)
      {
        uint64_t v334 = *(unsigned char **)__dst;
      }
      else
      {
        uint64_t v334 = __dst;
        unint64_t v332 = __dst[23];
      }
      if (v332 >= 0xE) {
        size_t v335 = 14;
      }
      else {
        size_t v335 = v332;
      }
      BOOL v336 = memcmp(v334, "__GPU_METADATA", v335) == 0;
      BOOL v330 = v332 == 14 && v336;
      if ((v331 & 0x80) == 0) {
        goto LABEL_734;
      }
LABEL_731:
      operator delete(*(void **)__dst);
      if (v330) {
        goto LABEL_1008;
      }
LABEL_735:
      if ((v296 & 1) == 0)
      {
        uint64_t v338 = (v294 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v294 | 7) != 0x17) {
          uint64_t v338 = v294 | 7;
        }
        uint64_t v339 = v338 + 1;
        unsigned int v337 = operator new(v338 + 1);
        *(void *)&__dst[16] = v339 | 0x8000000000000000;
        *(void *)int __dst = v337;
        *(void *)&__dst[8] = v294;
        goto LABEL_741;
      }
      __dst[23] = v294;
      unsigned int v337 = __dst;
      if (v294) {
LABEL_741:
      }
        memmove(v337, v293, v294);
      BOOL v340 = 0;
      v337[v294] = 0;
      char v341 = __dst[23];
      unint64_t v342 = *(void *)&__dst[8];
      if (__dst[23] >= 0) {
        uint64_t v343 = __dst[23] & 0x7F;
      }
      else {
        uint64_t v343 = *(void *)&__dst[8];
      }
      if (v343 != 15)
      {
        if ((__dst[23] & 0x80) != 0) {
          goto LABEL_755;
        }
        goto LABEL_758;
      }
      if ((__dst[23] & 0x80) != 0)
      {
        unsigned int v344 = *(unsigned char **)__dst;
      }
      else
      {
        unsigned int v344 = __dst;
        unint64_t v342 = __dst[23];
      }
      if (v342 >= 0xF) {
        size_t v345 = 15;
      }
      else {
        size_t v345 = v342;
      }
      BOOL v346 = memcmp(v344, "__GPU_VIDMALIST", v345) == 0;
      BOOL v340 = v342 == 15 && v346;
      if ((v341 & 0x80) == 0)
      {
LABEL_758:
        if (v340) {
          goto LABEL_1008;
        }
        goto LABEL_759;
      }
LABEL_755:
      operator delete(*(void **)__dst);
      if (v340) {
        goto LABEL_1008;
      }
LABEL_759:
      if ((v786[23] & 0x80000000) != 0) {
        operator delete(*(void **)v786);
      }
LABEL_152:
      uint64_t v9 = 0;
LABEL_281:
      if (v729 >= 0x41 && __src) {
        MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
      }
      return v9;
  }
}

void *sub_1CD379C2C(llvm::StringMapImpl *a1, unsigned __int8 *a2, size_t __n)
{
  unsigned int v5 = *((_DWORD *)a1 + 2);
  if (!v5)
  {
    *((_DWORD *)a1 + 3) = 0;
    *((_DWORD *)a1 + 4) = 0;
    std::string::size_type v25 = malloc_type_calloc(0x11uLL, 0xCuLL, 0x6D9A4F0CuLL);
    if (!v25) {
      llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
    }
    v25[16] = 2;
    *(void *)a1 = v25;
    unsigned int v5 = 16;
    *((_DWORD *)a1 + 2) = 16;
  }
  int v6 = 0;
  if (__n)
  {
    size_t v7 = __n;
    int v8 = a2;
    do
    {
      int v9 = *v8++;
      int v6 = 33 * v6 + v9;
      --v7;
    }
    while (v7);
  }
  uint64_t v10 = *(void *)a1;
  unsigned int v11 = v5 - 1;
  uint64_t v12 = *(void *)a1 + 8 * v5 + 8;
  int v13 = -1;
  int v14 = 1;
  int v15 = v6;
  while (1)
  {
    uint64_t v16 = v15 & v11;
    uint64_t v17 = *(void **)(v10 + 8 * v16);
    if (!v17) {
      break;
    }
    if (v17 == (void *)-8)
    {
      if (v13 == -1) {
        int v13 = v15 & v11;
      }
    }
    else if (*(_DWORD *)(v12 + 4 * v16) == v6 {
           && __n == *v17
    }
           && (!__n || !memcmp(a2, (char *)v17 + *((unsigned int *)a1 + 5), __n)))
    {
      goto LABEL_20;
    }
    int v15 = v14 + v16;
    ++v14;
  }
  uint64_t v18 = v13;
  if (v13 == -1)
  {
    uint64_t v18 = v16;
    uint64_t v16 = v16;
  }
  else
  {
    uint64_t v16 = v13;
  }
  *(_DWORD *)(v12 + 4 * v18) = v6;
  uint64_t v17 = *(void **)(v10 + 8 * v16);
LABEL_20:
  if (v17 == (void *)-8)
  {
    --*((_DWORD *)a1 + 4);
  }
  else if (v17)
  {
    return v17 + 1;
  }
  size_t v19 = (char *)operator new(__n + 17, (std::align_val_t)8uLL);
  uint64_t v20 = v19;
  size_t v21 = v19 + 16;
  if (__n) {
    memcpy(v19 + 16, a2, __n);
  }
  v21[__n] = 0;
  *(void *)uint64_t v20 = __n;
  *((_DWORD *)v20 + 2) = 0;
  *(void *)(v10 + 8 * v16) = v20;
  ++*((_DWORD *)a1 + 3);
  for (uint64_t i = (void **)(*(void *)a1 + 8 * llvm::StringMapImpl::RehashTable(a1, v16)); ; ++i)
  {
    uint64_t v17 = *i;
    if (*i && v17 + 1 != 0) {
      break;
    }
  }
  return v17 + 1;
}

uint64_t sub_1CD379E2C(uint64_t a1)
{
  *(void *)a1 = &unk_1F264C460;
  *(void *)(*(void *)(a1 + 224) + 256) = 0;
  *(_OWORD *)(*(void *)(a1 + 240) + 48) = *(_OWORD *)(a1 + 248);
  if (*(_DWORD *)(a1 + 852))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 848);
    if (v2)
    {
      uint64_t v3 = 0;
      uint64_t v4 = 8 * v2;
      do
      {
        uint64_t v5 = *(void *)(*(void *)(a1 + 840) + v3);
        if (v5 != -8 && v5 != 0) {
          MEMORY[0x1D25D9CD0]();
        }
        v3 += 8;
      }
      while (v4 != v3);
    }
  }
  free(*(void **)(a1 + 840));
  if (*(_DWORD *)(a1 + 820))
  {
    uint64_t v7 = *(unsigned int *)(a1 + 816);
    if (v7)
    {
      uint64_t v8 = 0;
      uint64_t v9 = 8 * v7;
      do
      {
        uint64_t v10 = *(void *)(*(void *)(a1 + 808) + v8);
        if (v10 != -8 && v10 != 0) {
          MEMORY[0x1D25D9CD0]();
        }
        v8 += 8;
      }
      while (v9 != v8);
    }
  }
  free(*(void **)(a1 + 808));
  sub_1CB833A08(a1 + 776, *(void **)(a1 + 784));
  uint64_t v12 = *(void **)(a1 + 728);
  if (v12 != (void *)(a1 + 744)) {
    free(v12);
  }
  int v13 = *(void **)(a1 + 488);
  if (v13 != (void *)(a1 + 504)) {
    free(v13);
  }
  sub_1CD379FD8((void **)(a1 + 376));
  int v14 = *(void **)(a1 + 352);
  if (v14)
  {
    *(void *)(a1 + 360) = v14;
    operator delete(v14);
  }
  sub_1CD4AFD10(a1 + 320);
  int v15 = *(void **)(a1 + 296);
  if (v15)
  {
    *(void *)(a1 + 304) = v15;
    operator delete(v15);
  }
  uint64_t v16 = *(void *)(a1 + 264);
  *(void *)(a1 + 264) = 0;
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
  }
  llvm::MCAsmLexer::~MCAsmLexer((llvm::MCAsmLexer *)(a1 + 40));
  *(void *)a1 = &unk_1F264C690;
  sub_1CD8F6154((char **)(a1 + 16));
  return a1;
}

void **sub_1CD379FD8(void **a1)
{
  sub_1CD8F3728(a1);
  uint64_t v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  if (v2 != v3)
  {
    do
    {
      uint64_t v4 = *v2++;
      operator delete(v4);
    }
    while (v2 != v3);
    int v6 = a1[1];
    uint64_t v5 = a1[2];
    if (v5 != v6) {
      a1[2] = &v5[(v6 - v5 + 7) & 0xFFFFFFFFFFFFFFF8];
    }
  }
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

uint64_t sub_1CD37A050(uint64_t a1, uint64_t a2, int a3)
{
  (*(void (**)(uint64_t))(*(void *)a1 + 184))(a1);
  uint64_t v6 = *(void *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 8);
  uint64_t v9 = *(uint64_t **)(v6 + 24);
  uint64_t v7 = (uint64_t *)(v6 + 24);
  uint64_t v8 = v9;
  if (*((_DWORD *)v7 + 2) >= 0x41u) {
    uint64_t v7 = v8;
  }
  uint64_t v10 = *v7;
  (*(void (**)(uint64_t))(*(void *)a1 + 184))(a1);
  uint64_t v11 = *(void *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 8);
  uint64_t v12 = *(void *)(v11 + 8);
  uint64_t v13 = *(void *)(v11 + 16);
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 184))(a1);
  if (a3)
  {
    unint64_t v15 = v13 - 2;
    if (v13) {
      uint64_t v16 = v12 + 1;
    }
    else {
      uint64_t v16 = v12;
    }
    if (v13 - (unint64_t)(v13 != 0) < v15) {
      unint64_t v15 = v13 - (v13 != 0);
    }
    *(void *)(a1 + 432) = v16;
    *(void *)(a1 + 440) = v15;
    *(void *)(a1 + 448) = v10;
    *(void *)(a1 + 456) = a2;
    *(_DWORD *)(a1 + 464) = *(_DWORD *)(a1 + 280);
    if (!*(void *)(a1 + 480))
    {
      *(void *)(a1 + 472) = v16;
      *(void *)(a1 + 480) = v15;
    }
  }
  return result;
}

uint64_t sub_1CD37A1A8(uint64_t *a1, char a2)
{
  uint64_t v4 = (uint64_t *)((char *)a1 + 284);
  uint64_t v6 = (char *)a1[38];
  unint64_t v5 = a1[39];
  if ((unint64_t)v6 >= v5)
  {
    uint64_t v8 = (char *)a1[37];
    uint64_t v9 = (v6 - v8) >> 3;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61) {
      abort();
    }
    uint64_t v11 = v5 - (void)v8;
    if (v11 >> 2 > v10) {
      unint64_t v10 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      if (v12 >> 61) {
        sub_1CB833614();
      }
      uint64_t v13 = (char *)operator new(8 * v12);
    }
    else
    {
      uint64_t v13 = 0;
    }
    int v14 = &v13[8 * v9];
    *(void *)int v14 = *v4;
    uint64_t v7 = v14 + 8;
    if (v6 != v8)
    {
      do
      {
        int v15 = *((_DWORD *)v6 - 2);
        v6 -= 8;
        __int16 v16 = *((_WORD *)v6 + 2);
        *((_DWORD *)v14 - 2) = v15;
        v14 -= 8;
        *((_WORD *)v14 + 2) = v16;
      }
      while (v6 != v8);
      uint64_t v6 = (char *)a1[37];
    }
    a1[37] = (uint64_t)v14;
    a1[38] = (uint64_t)v7;
    a1[39] = (uint64_t)&v13[8 * v12];
    if (v6) {
      operator delete(v6);
    }
  }
  else
  {
    *(void *)uint64_t v6 = *v4;
    uint64_t v7 = v6 + 8;
  }
  a1[38] = (uint64_t)v7;
  *((_DWORD *)a1 + 71) = 1;
  uint64_t v17 = *a1;
  if (*((unsigned char *)a1 + 289))
  {
    (*(void (**)(uint64_t *))(v17 + 224))(a1);
    return 0;
  }
  else
  {
    (*(void (**)(uint64_t *))(v17 + 200))(a1);
    uint64_t v20 = v19;
    if (llvm::MCAsmParser::parseEOL((llvm::MCAsmParser *)a1))
    {
      return 1;
    }
    else
    {
      uint64_t result = 0;
      char v21 = (v20 == 0) ^ a2;
      *((unsigned char *)a1 + 288) = v21 ^ 1;
      *((unsigned char *)a1 + 289) = v21;
    }
  }
  return result;
}

uint64_t sub_1CD37A34C(unsigned char *a1, char a2)
{
  uint64_t v4 = a1 + 284;
  uint64_t v6 = (char *)*((void *)a1 + 38);
  unint64_t v5 = *((void *)a1 + 39);
  if ((unint64_t)v6 >= v5)
  {
    uint64_t v8 = (char *)*((void *)a1 + 37);
    uint64_t v9 = (v6 - v8) >> 3;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61) {
      abort();
    }
    uint64_t v11 = v5 - (void)v8;
    if (v11 >> 2 > v10) {
      unint64_t v10 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      if (v12 >> 61) {
        sub_1CB833614();
      }
      uint64_t v13 = (char *)operator new(8 * v12);
    }
    else
    {
      uint64_t v13 = 0;
    }
    int v14 = &v13[8 * v9];
    *(void *)int v14 = *v4;
    uint64_t v7 = v14 + 8;
    if (v6 != v8)
    {
      do
      {
        int v15 = *((_DWORD *)v6 - 2);
        v6 -= 8;
        __int16 v16 = *((_WORD *)v6 + 2);
        *((_DWORD *)v14 - 2) = v15;
        v14 -= 8;
        *((_WORD *)v14 + 2) = v16;
      }
      while (v6 != v8);
      uint64_t v6 = (char *)*((void *)a1 + 37);
    }
    *((void *)a1 + 37) = v14;
    *((void *)a1 + 38) = v7;
    *((void *)a1 + 39) = &v13[8 * v12];
    if (v6) {
      operator delete(v6);
    }
  }
  else
  {
    *(void *)uint64_t v6 = *v4;
    uint64_t v7 = v6 + 8;
  }
  *((void *)a1 + 38) = v7;
  *((_DWORD *)a1 + 71) = 1;
  if (a1[289])
  {
    (*(void (**)(unsigned char *))(*(void *)a1 + 224))(a1);
    return 0;
  }
  else
  {
    uint64_t v18 = *(void *)(*(void *)((*(uint64_t (**)(unsigned char *))(*(void *)a1 + 40))(a1) + 8) + 8);
    while (1)
    {
      unsigned int v19 = **((_DWORD **)a1 + 6);
      BOOL v20 = v19 > 0x19;
      int v21 = (1 << v19) & 0x2000201;
      if (!v20 && v21 != 0) {
        break;
      }
      sub_1CD8F38F8((uint64_t)(a1 + 40));
    }
    uint64_t v23 = *(void *)(*(void *)((*(uint64_t (**)(unsigned char *))(*(void *)a1 + 40))(a1) + 8) + 8) - v18;
    v33[0] = v18;
    v33[1] = v23;
    v34[0] = "expected comma";
    __int16 v35 = 259;
    if (llvm::MCAsmParser::parseToken((llvm::MCAsmParser *)a1, 25, (llvm::Twine *)v34)) {
      return 1;
    }
    v34[0] = (*(uint64_t (**)(unsigned char *))(*(void *)a1 + 200))(a1);
    v34[1] = v25;
    if (llvm::MCAsmParser::parseEOL((llvm::MCAsmParser *)a1))
    {
      return 1;
    }
    else
    {
      int v26 = (const void *)sub_1CD5A69D0(v33, " \t\n\v\f\r", 6);
      size_t v28 = v27;
      int v29 = (const void *)sub_1CD5A69D0(v34, " \t\n\v\f\r", 6);
      if (v28 == v30)
      {
        if (v28) {
          BOOL v31 = memcmp(v26, v29, v28) == 0;
        }
        else {
          BOOL v31 = 1;
        }
      }
      else
      {
        BOOL v31 = 0;
      }
      uint64_t result = 0;
      char v32 = v31 ^ a2;
      a1[288] = v32 ^ 1;
      a1[289] = v32;
    }
  }
  return result;
}

uint64_t sub_1CD37A61C(uint64_t a1, int a2)
{
  LODWORD(v2) = a2;
  if (**(_DWORD **)(a1 + 48) != 3) {
    goto LABEL_48;
  }
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  unint64_t v5 = *(void *)(*(void *)(v4 + 8) + 16);
  unint64_t v6 = v5 != 0;
  if (v5) {
    uint64_t v7 = (const void *)(*(void *)(*(void *)(v4 + 8) + 8) + 1);
  }
  else {
    uint64_t v7 = *(const void **)(*(void *)(v4 + 8) + 8);
  }
  if (v6 <= v5 - 1) {
    unint64_t v8 = v5 - 1;
  }
  else {
    unint64_t v8 = v5 != 0;
  }
  if (v5 >= v8) {
    unint64_t v9 = v8;
  }
  else {
    unint64_t v9 = *(void *)(*(void *)(v4 + 8) + 16);
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 184))(a1);
  if (**(_DWORD **)(a1 + 48) != 25)
  {
    if (v2) {
      std::string::size_type v33 = "expected comma after first string for '.ifeqs' directive";
    }
    else {
      std::string::size_type v33 = "expected comma after first string for '.ifnes' directive";
    }
    goto LABEL_54;
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 184))(a1);
  if (**(_DWORD **)(a1 + 48) != 3)
  {
LABEL_48:
    if (v2) {
      std::string::size_type v33 = "expected string parameter for '.ifeqs' directive";
    }
    else {
      std::string::size_type v33 = "expected string parameter for '.ifnes' directive";
    }
LABEL_54:
    unint64_t v37 = v33;
    __int16 v38 = 259;
    return llvm::MCAsmParser::TokError(a1, (uint64_t)&v37, 0, 0);
  }
  uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  unint64_t v11 = *(void *)(*(void *)(v10 + 8) + 16);
  unint64_t v12 = v11 != 0;
  if (v11) {
    uint64_t v13 = (const void *)(*(void *)(*(void *)(v10 + 8) + 8) + 1);
  }
  else {
    uint64_t v13 = *(const void **)(*(void *)(v10 + 8) + 8);
  }
  if (v12 <= v11 - 1) {
    unint64_t v14 = v11 - 1;
  }
  else {
    unint64_t v14 = v11 != 0;
  }
  if (v11 >= v14) {
    unint64_t v15 = v14;
  }
  else {
    unint64_t v15 = *(void *)(*(void *)(v10 + 8) + 16);
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 184))(a1);
  __int16 v16 = (void *)(a1 + 284);
  uint64_t v18 = *(char **)(a1 + 304);
  unint64_t v17 = *(void *)(a1 + 312);
  if ((unint64_t)v18 >= v17)
  {
    __int16 v35 = v7;
    int v36 = v13;
    unint64_t v34 = v9;
    BOOL v20 = *(char **)(a1 + 296);
    uint64_t v21 = (v18 - v20) >> 3;
    unint64_t v22 = v21 + 1;
    if ((unint64_t)(v21 + 1) >> 61) {
      abort();
    }
    char v23 = v2;
    uint64_t v24 = v17 - (void)v20;
    if (v24 >> 2 > v22) {
      unint64_t v22 = v24 >> 2;
    }
    if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v2 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v2 = v22;
    }
    if (v2)
    {
      if (v2 >> 61) {
        sub_1CB833614();
      }
      uint64_t v25 = (char *)operator new(8 * v2);
    }
    else
    {
      uint64_t v25 = 0;
    }
    int v26 = &v25[8 * v21];
    size_t v27 = &v25[8 * v2];
    *(void *)int v26 = *v16;
    unsigned int v19 = v26 + 8;
    LOBYTE(v2) = v23;
    if (v18 == v20)
    {
      uint64_t v7 = v35;
    }
    else
    {
      uint64_t v7 = v35;
      do
      {
        int v28 = *((_DWORD *)v18 - 2);
        v18 -= 8;
        __int16 v29 = *((_WORD *)v18 + 2);
        *((_DWORD *)v26 - 2) = v28;
        v26 -= 8;
        *((_WORD *)v26 + 2) = v29;
      }
      while (v18 != v20);
      uint64_t v18 = *(char **)(a1 + 296);
    }
    unint64_t v9 = v34;
    *(void *)(a1 + 296) = v26;
    *(void *)(a1 + 304) = v19;
    *(void *)(a1 + 312) = v27;
    uint64_t v13 = v36;
    if (v18) {
      operator delete(v18);
    }
  }
  else
  {
    *(void *)uint64_t v18 = *v16;
    unsigned int v19 = v18 + 8;
  }
  *(void *)(a1 + 304) = v19;
  *(_DWORD *)(a1 + 284) = 1;
  BOOL v30 = v9 - v6 == v15 - v12 && (v15 == v12 || memcmp(v7, v13, v9 - v6) == 0);
  uint64_t result = 0;
  char v32 = v30 ^ v2;
  *(unsigned char *)(a1 + 288) = v32 ^ 1;
  *(unsigned char *)(a1 + 289) = v32;
  return result;
}

uint64_t sub_1CD37A948(uint64_t *a1, int a2)
{
  uint64_t v4 = (uint64_t *)((char *)a1 + 284);
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  unint64_t v6 = (char *)a1[38];
  unint64_t v5 = a1[39];
  if ((unint64_t)v6 >= v5)
  {
    unint64_t v8 = (char *)a1[37];
    uint64_t v9 = (v6 - v8) >> 3;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61) {
      abort();
    }
    uint64_t v11 = v5 - (void)v8;
    if (v11 >> 2 > v10) {
      unint64_t v10 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      if (v12 >> 61) {
        sub_1CB833614();
      }
      uint64_t v13 = (char *)operator new(8 * v12);
    }
    else
    {
      uint64_t v13 = 0;
    }
    unint64_t v14 = &v13[8 * v9];
    *(void *)unint64_t v14 = *v4;
    uint64_t v7 = v14 + 8;
    if (v6 != v8)
    {
      do
      {
        int v15 = *((_DWORD *)v6 - 2);
        v6 -= 8;
        __int16 v16 = *((_WORD *)v6 + 2);
        *((_DWORD *)v14 - 2) = v15;
        v14 -= 8;
        *((_WORD *)v14 + 2) = v16;
      }
      while (v6 != v8);
      unint64_t v6 = (char *)a1[37];
    }
    a1[37] = (uint64_t)v14;
    a1[38] = (uint64_t)v7;
    a1[39] = (uint64_t)&v13[8 * v12];
    if (v6) {
      operator delete(v6);
    }
  }
  else
  {
    *(void *)unint64_t v6 = *v4;
    uint64_t v7 = v6 + 8;
  }
  a1[38] = (uint64_t)v7;
  *((_DWORD *)a1 + 71) = 1;
  uint64_t v17 = *a1;
  if (*((unsigned char *)a1 + 289))
  {
    (*(void (**)(uint64_t *))(v17 + 224))(a1);
    return 0;
  }
  else
  {
    uint64_t v19 = (*(uint64_t (**)(uint64_t *, uint64_t *))(v17 + 192))(a1, &v29);
    char v20 = v19;
    v27[0] = "expected identifier after '.ifdef'";
    __int16 v28 = 259;
    llvm::MCAsmParser::check((llvm::MCAsmParser *)a1, v19, (const llvm::Twine *)v27);
    if ((v20 & 1) != 0 || llvm::MCAsmParser::parseEOL((llvm::MCAsmParser *)a1))
    {
      return 1;
    }
    else
    {
      uint64_t v21 = (llvm::MCContext *)(*(uint64_t (**)(uint64_t *))(*a1 + 48))(a1);
      __int16 v28 = 261;
      v27[0] = v29;
      v27[1] = v30;
      unint64_t v22 = (unint64_t *)llvm::MCContext::lookupSymbol(v21, (const llvm::Twine *)v27);
      char v23 = v22;
      if (a2)
      {
        if (v22)
        {
          unint64_t AssociatedFragment = *v22 & 0xFFFFFFFFFFFFFFF8;
          if ((*v23 & 0xFFFFFFFFFFFFFFF8) == 0 && (v23[1] & 0x1C00) == 0x800)
          {
            unint64_t AssociatedFragment = llvm::MCExpr::findAssociatedFragment((llvm::MCExpr *)v23[3]);
            *char v23 = *v23 & 7 | AssociatedFragment;
          }
          BOOL v25 = AssociatedFragment != 0;
        }
        else
        {
          BOOL v25 = 0;
        }
      }
      else if (v22)
      {
        unint64_t v26 = *v22 & 0xFFFFFFFFFFFFFFF8;
        if ((*v23 & 0xFFFFFFFFFFFFFFF8) == 0 && (v23[1] & 0x1C00) == 0x800)
        {
          unint64_t v26 = llvm::MCExpr::findAssociatedFragment((llvm::MCExpr *)v23[3]);
          *char v23 = *v23 & 7 | v26;
        }
        BOOL v25 = v26 == 0;
      }
      else
      {
        BOOL v25 = 1;
      }
      *((unsigned char *)a1 + 288) = v25;
      uint64_t result = 0;
      *((unsigned char *)a1 + 289) = !v25;
    }
  }
  return result;
}

BOOL sub_1CD37ABFC(void *a1)
{
  v38[2] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (*(uint64_t (**)(void *))(*a1 + 48))(a1);
  int v3 = *(unsigned __int8 *)(v2 + 1513);
  if (*(unsigned char *)(v2 + 1513) && !*(_DWORD *)((*(uint64_t (**)(void *))(*a1 + 48))(a1) + 1516))
  {
    if (a1[60])
    {
      uint64_t v5 = (*(uint64_t (**)(void *))(*a1 + 48))(a1);
      uint64_t v6 = (*(uint64_t (**)(void *))(*a1 + 48))(a1);
      uint64_t v7 = *(void **)(v6 + 1272);
      size_t v8 = *(void *)(v6 + 1280);
      uint64_t v9 = (void *)a1[59];
      size_t v10 = a1[60];
      uint64_t v11 = *(uint64_t **)(v5 + 1480);
      if (v11)
      {
        while (1)
        {
          unint64_t v12 = (uint64_t **)v11;
          if (!*((_DWORD *)v11 + 8)) {
            break;
          }
          uint64_t v11 = (uint64_t *)*v11;
          if (!*v12) {
            goto LABEL_28;
          }
        }
        uint64_t v13 = (char *)v11;
      }
      else
      {
        unint64_t v12 = (uint64_t **)(v5 + 1480);
LABEL_28:
        uint64_t v13 = (char *)operator new(0x228uLL);
        *((_DWORD *)v13 + 8) = 0;
        *(_OWORD *)(v13 + 56) = 0u;
        *(_OWORD *)(v13 + 72) = 0u;
        *(_OWORD *)(v13 + 88) = 0u;
        *(_OWORD *)(v13 + 104) = 0u;
        *(_OWORD *)(v13 + 120) = 0u;
        *(_OWORD *)(v13 + 136) = 0u;
        *(_OWORD *)(v13 + 168) = 0u;
        *(_OWORD *)(v13 + 184) = 0u;
        *(_OWORD *)(v13 + 200) = 0u;
        *(_OWORD *)(v13 + 216) = 0u;
        *(_OWORD *)(v13 + 232) = 0u;
        *(_OWORD *)(v13 + 248) = 0u;
        *((void *)v13 + 65) = 0;
        *(_OWORD *)(v13 + 264) = 0u;
        *(_OWORD *)(v13 + 280) = 0u;
        *(_OWORD *)(v13 + 40) = 0u;
        *(_OWORD *)(v13 + 296) = 0u;
        *(_OWORD *)(v13 + 312) = 0u;
        *(_OWORD *)(v13 + 328) = 0u;
        *(_OWORD *)(v13 + 344) = 0u;
        *(_OWORD *)(v13 + 360) = 0u;
        *(_OWORD *)(v13 + 376) = 0u;
        *(_OWORD *)(v13 + 392) = 0u;
        *(_OWORD *)(v13 + 408) = 0u;
        *(_OWORD *)(v13 + 424) = 0u;
        *(_OWORD *)(v13 + 440) = 0u;
        *(_OWORD *)(v13 + 456) = 0u;
        *(_OWORD *)(v13 + 472) = 0u;
        *(_OWORD *)(v13 + 152) = 0u;
        *(_OWORD *)(v13 + 488) = 0u;
        *(_OWORD *)(v13 + 504) = 0u;
        *((void *)v13 + 6) = v13 + 64;
        *((_DWORD *)v13 + 15) = 3;
        *((void *)v13 + 17) = v13 + 152;
        *((_DWORD *)v13 + 37) = 3;
        *((void *)v13 + 47) = 0;
        *((void *)v13 + 46) = 0;
        *((void *)v13 + 48) = 0x1000000000;
        *((_OWORD *)v13 + 25) = 0u;
        *((_OWORD *)v13 + 26) = 0u;
        *((_OWORD *)v13 + 27) = 0u;
        *(void *)(v13 + 445) = 0;
        v13[497] = 1;
        *((void *)v13 + 64) = 0;
        *((void *)v13 + 63) = 0;
        *((_DWORD *)v13 + 130) = 0;
        *((void *)v13 + 66) = 0;
        *((void *)v13 + 68) = 0;
        *((void *)v13 + 67) = 0;
        *(void *)uint64_t v13 = 0;
        *((void *)v13 + 1) = 0;
        *((void *)v13 + 2) = v12;
        void *v12 = (uint64_t *)v13;
        char v32 = (uint64_t *)v13;
        uint64_t v33 = **(void **)(v5 + 1472);
        if (v33)
        {
          *(void *)(v5 + 1472) = v33;
          char v32 = *v12;
        }
        sub_1CB8358B8(*(uint64_t **)(v5 + 1480), v32);
        ++*(void *)(v5 + 1488);
      }
      LOBYTE(v36) = 0;
      char v37 = 0;
      v34.n128_u8[0] = 0;
      LOBYTE(v35) = 0;
      __n128 v4 = sub_1CCBB0D74((uint64_t)(v13 + 40), v7, v8, v9, v10, &v36, &v34);
    }
    uint64_t v14 = (*(uint64_t (**)(void *, __n128))(*a1 + 48))(a1, v4);
    uint64_t v15 = v14;
    __int16 v16 = *(uint64_t **)(v14 + 1480);
    if (v16)
    {
      while (1)
      {
        uint64_t v17 = (uint64_t **)v16;
        if (!*((_DWORD *)v16 + 8)) {
          break;
        }
        __int16 v16 = (uint64_t *)*v16;
        if (!*v17) {
          goto LABEL_24;
        }
      }
      uint64_t v18 = (char *)v16;
    }
    else
    {
      uint64_t v17 = (uint64_t **)(v14 + 1480);
LABEL_24:
      uint64_t v18 = (char *)operator new(0x228uLL);
      *((_DWORD *)v18 + 8) = 0;
      *(_OWORD *)(v18 + 56) = 0u;
      *(_OWORD *)(v18 + 72) = 0u;
      *(_OWORD *)(v18 + 88) = 0u;
      *(_OWORD *)(v18 + 104) = 0u;
      *(_OWORD *)(v18 + 120) = 0u;
      *(_OWORD *)(v18 + 136) = 0u;
      *(_OWORD *)(v18 + 168) = 0u;
      *(_OWORD *)(v18 + 184) = 0u;
      *(_OWORD *)(v18 + 200) = 0u;
      *(_OWORD *)(v18 + 216) = 0u;
      *(_OWORD *)(v18 + 232) = 0u;
      *(_OWORD *)(v18 + 248) = 0u;
      *((void *)v18 + 65) = 0;
      *(_OWORD *)(v18 + 264) = 0u;
      *(_OWORD *)(v18 + 280) = 0u;
      *(_OWORD *)(v18 + 40) = 0u;
      *(_OWORD *)(v18 + 296) = 0u;
      *(_OWORD *)(v18 + 312) = 0u;
      *(_OWORD *)(v18 + 328) = 0u;
      *(_OWORD *)(v18 + 344) = 0u;
      *(_OWORD *)(v18 + 360) = 0u;
      *(_OWORD *)(v18 + 376) = 0u;
      *(_OWORD *)(v18 + 392) = 0u;
      *(_OWORD *)(v18 + 408) = 0u;
      *(_OWORD *)(v18 + 424) = 0u;
      *(_OWORD *)(v18 + 440) = 0u;
      *(_OWORD *)(v18 + 456) = 0u;
      *(_OWORD *)(v18 + 472) = 0u;
      *(_OWORD *)(v18 + 152) = 0u;
      *(_OWORD *)(v18 + 488) = 0u;
      *(_OWORD *)(v18 + 504) = 0u;
      *((void *)v18 + 6) = v18 + 64;
      *((_DWORD *)v18 + 15) = 3;
      *((void *)v18 + 17) = v18 + 152;
      *((_DWORD *)v18 + 37) = 3;
      *((void *)v18 + 47) = 0;
      *((void *)v18 + 46) = 0;
      *((void *)v18 + 48) = 0x1000000000;
      *((_OWORD *)v18 + 25) = 0u;
      *((_OWORD *)v18 + 26) = 0u;
      *((_OWORD *)v18 + 27) = 0u;
      *(void *)(v18 + 445) = 0;
      v18[497] = 1;
      *((void *)v18 + 64) = 0;
      *((void *)v18 + 63) = 0;
      *((_DWORD *)v18 + 130) = 0;
      *((void *)v18 + 66) = 0;
      *((void *)v18 + 68) = 0;
      *((void *)v18 + 67) = 0;
      *(void *)uint64_t v18 = 0;
      *((void *)v18 + 1) = 0;
      *((void *)v18 + 2) = v17;
      void *v17 = (uint64_t *)v18;
      uint64_t v30 = (uint64_t *)v18;
      uint64_t v31 = **(void **)(v15 + 1472);
      if (v31)
      {
        *(void *)(v15 + 1472) = v31;
        uint64_t v30 = *v17;
      }
      sub_1CB8358B8(*(uint64_t **)(v15 + 1480), v30);
      ++*(void *)(v15 + 1488);
    }
    uint64_t v19 = (*(uint64_t (**)(void *))(*a1 + 48))(a1);
    uint64_t v20 = (*(uint64_t (**)(void *))(*a1 + 56))(a1);
    uint64_t v21 = (*(uint64_t (**)(void *))(*a1 + 48))(a1);
    uint64_t v22 = *(void *)(v21 + 1272);
    uint64_t v23 = *(void *)(v21 + 1280);
    char v24 = v18[447];
    BOOL v25 = v24 < 0;
    if (v24 >= 0) {
      unint64_t v26 = v18 + 424;
    }
    else {
      unint64_t v26 = (char *)*((void *)v18 + 53);
    }
    uint64_t v27 = v24 & 0x7F;
    if (v25) {
      uint64_t v28 = *((void *)v18 + 54);
    }
    else {
      uint64_t v28 = v27;
    }
    long long v36 = *(_OWORD *)(v18 + 452);
    char v37 = v18[468];
    __n128 v34 = *(__n128 *)(v18 + 472);
    uint64_t v35 = *((void *)v18 + 61);
    (*(void (**)(void *__return_ptr, uint64_t, void, uint64_t, uint64_t, char *, uint64_t, long long *, __n128 *, _DWORD))(*(void *)v20 + 688))(v38, v20, 0, v22, v23, v26, v28, &v36, &v34, 0);
    *(_DWORD *)(v19 + 1516) = v38[0];
  }
  return v3 != 0;
}

uint64_t sub_1CD37B134(llvm::MCAsmParser *a1, unsigned __int8 **a2, uint64_t a3, unsigned int a4)
{
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t v8 = *(void *)(*(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)a1 + 40))(a1) + 8) + 8);
  if (llvm::MCParserUtils::parseAssignmentExpression(a2, a3, (a4 & 0xFFFFFFFD) == 0, a1, &v14, &v13)) {
    return 1;
  }
  uint64_t v10 = v14;
  if (v14
    && ((*(uint64_t (**)(llvm::MCAsmParser *, unsigned __int8 **, uint64_t))(*(void *)a1 + 104))(a1, a2, a3) & 1) == 0)
  {
    if (a4 < 2)
    {
      (*(void (**)(void *, uint64_t, const llvm::MCExpr *))(**((void **)a1 + 28) + 280))(*((void **)a1 + 28), v10, v13);
      (*(void (**)(void))(**((void **)a1 + 28) + 304))();
    }
    else if (a4 == 3)
    {
      if (*(unsigned char *)v13 != 2)
      {
        uint64_t v11 = "expected identifier";
        __int16 v12 = 259;
        return llvm::MCAsmParser::Error((uint64_t)a1, v8, (uint64_t)&v11, 0, 0);
      }
      (*(void (**)(void *, uint64_t))(**((void **)a1 + 28) + 288))(*((void **)a1 + 28), v10);
    }
    else if (a4 == 2)
    {
      (*(void (**)(void *, uint64_t, const llvm::MCExpr *))(**((void **)a1 + 28) + 280))(*((void **)a1 + 28), v10, v13);
    }
  }
  return 0;
}

uint64_t sub_1CD37B35C(llvm::MCAsmParser *a1, unsigned int a2)
{
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v4 = (*(uint64_t (**)(llvm::MCAsmParser *, unsigned __int8 ***))(*(void *)a1 + 192))(a1, &v9);
  char v5 = v4;
  uint64_t v7 = "expected identifier";
  __int16 v8 = 259;
  llvm::MCAsmParser::check(a1, v4, (const llvm::Twine *)&v7);
  if (v5) {
    return 1;
  }
  uint64_t v11 = "expected comma";
  __int16 v12 = 259;
  if (llvm::MCAsmParser::parseToken(a1, 25, (llvm::Twine *)&v11)) {
    return 1;
  }
  else {
    return sub_1CD37B134(a1, v9, v10, a2);
  }
}

BOOL sub_1CD37B424(llvm::MCAsmParser *a1, int a2, uint64_t a3)
{
  uint64_t v6 = *(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)a1 + 40))(a1) + 96);
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  if ((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)a1 + 264))(a1)) {
    return 1;
  }
  uint64_t v27 = 0;
  if (a3 == 1
    && a2
    && **(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)a1 + 40))(a1) + 8) == 9)
  {
    v23[0] = "p2align directive with no operand(s) is ignored";
    __int16 v24 = 259;
    (*(void (**)(llvm::MCAsmParser *, uint64_t, void *, void, void))(*(void *)a1 + 168))(a1, v6, v23, 0, 0);
    return llvm::MCAsmParser::parseEOL(a1);
  }
  if ((*(uint64_t (**)(llvm::MCAsmParser *, uint64_t *))(*(void *)a1 + 256))(a1, &v27)) {
    return 1;
  }
  if (llvm::MCAsmParser::parseOptionalToken(a1, 25))
  {
    if (**(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)a1 + 40))(a1) + 8) == 25)
    {
      int v9 = 0;
    }
    else
    {
      uint64_t v7 = 1;
      if ((*(uint64_t (**)(llvm::MCAsmParser *, uint64_t *))(*(void *)a1 + 256))(a1, &v26)) {
        return v7;
      }
      int v9 = 1;
    }
    if (llvm::MCAsmParser::parseOptionalToken(a1, 25))
    {
      uint64_t v10 = *(void *)(*(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)a1 + 40))(a1) + 8)
                      + 8);
      if ((*(uint64_t (**)(llvm::MCAsmParser *, uint64_t *))(*(void *)a1 + 256))(a1, &v25)) {
        return 1;
      }
    }
    else
    {
      uint64_t v10 = 0;
    }
  }
  else
  {
    uint64_t v10 = 0;
    int v9 = 0;
  }
  if (!llvm::MCAsmParser::parseEOL(a1))
  {
    int8x8_t v11 = (int8x8_t)v27;
    if (a2)
    {
      if (v27 >= 32)
      {
        v23[0] = "invalid alignment value";
        __int16 v24 = 259;
        uint64_t v7 = llvm::MCAsmParser::Error((uint64_t)a1, v6, (uint64_t)v23, 0, 0);
        v11.i8[0] = 31;
      }
      else
      {
        uint64_t v7 = 0;
      }
      uint64_t v27 = 1 << v11.i8[0];
      if (!v10) {
        goto LABEL_34;
      }
    }
    else
    {
      if (!v27)
      {
        int8x8_t v11 = (int8x8_t)1;
        uint64_t v27 = 1;
      }
      uint8x8_t v12 = (uint8x8_t)vcnt_s8(v11);
      v12.i16[0] = vaddlv_u8(v12);
      if (v12.u32[0] == 1)
      {
        uint64_t v7 = 0;
      }
      else
      {
        v23[0] = "alignment must be a power of 2";
        __int16 v24 = 259;
        uint64_t v7 = llvm::MCAsmParser::Error((uint64_t)a1, v6, (uint64_t)v23, 0, 0);
        int8x8_t v11 = (int8x8_t)v27;
      }
      if (HIDWORD(*(void *)&v11))
      {
        v23[0] = "alignment must be smaller than 2**32";
        __int16 v24 = 259;
        uint64_t v7 = v7 | llvm::MCAsmParser::Error((uint64_t)a1, v6, (uint64_t)v23, 0, 0);
        if (!v10) {
          goto LABEL_34;
        }
      }
      else if (!v10)
      {
        goto LABEL_34;
      }
    }
    uint64_t v13 = v25;
    if (v25 <= 0)
    {
      v23[0] = "alignment directive can never be satisfied in this many bytes, ignoring maximum bytes expression";
      __int16 v24 = 259;
      int v22 = llvm::MCAsmParser::Error((uint64_t)a1, v10, (uint64_t)v23, 0, 0);
      uint64_t v13 = 0;
      uint64_t v7 = v7 | v22;
      uint64_t v25 = 0;
    }
    if (v13 >= v27)
    {
      v23[0] = "maximum bytes expression exceeds alignment and has no effect";
      __int16 v24 = 259;
      (*(void (**)(llvm::MCAsmParser *, uint64_t, void *, void, void))(*(void *)a1 + 168))(a1, v10, v23, 0, 0);
      uint64_t v25 = 0;
    }
LABEL_34:
    uint64_t v14 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)a1 + 56))(a1);
    uint64_t v15 = *(void *)(*(void *)(v14 + 112) + 32 * *(unsigned int *)(v14 + 120) - 32);
    int v16 = (*(uint64_t (**)(uint64_t))(*(void *)v15 + 8))(v15);
    if (v9)
    {
      if (a3 == 1 && v26 == *(_DWORD *)(*((void *)a1 + 22) + 340)) {
        char v18 = v16;
      }
      else {
        char v18 = 0;
      }
      if (v18)
      {
LABEL_42:
        uint64_t v19 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)a1 + 56))(a1);
        (*(void (**)(uint64_t, void, void, void))(*(void *)v19 + 648))(v19, v27, *(void *)(*((void *)a1 + 1) + 240), v25);
        return v7;
      }
    }
    else
    {
      if (a3 == 1) {
        int v20 = v16;
      }
      else {
        int v20 = 0;
      }
      if (v20 == 1) {
        goto LABEL_42;
      }
    }
    uint64_t v21 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)a1 + 56))(a1);
    (*(void (**)(uint64_t, void, uint64_t, uint64_t, void))(*(void *)v21 + 640))(v21, v27, v26, a3, v25);
    return v7;
  }
  return 1;
}

uint64_t sub_1CD37B9E4(llvm::MCAsmParser *a1, int a2)
{
  if ((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)a1 + 264))(a1)) {
    return 1;
  }
  uint64_t v5 = *(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)a1 + 40))(a1) + 96);
  uint64_t v21 = 0;
  int v22 = 0;
  if ((*(unsigned int (**)(llvm::MCAsmParser *, unsigned __int8 ***))(*(void *)a1 + 192))(a1, &v21))
  {
    v23[0] = (unsigned __int8 **)"expected identifier in directive";
    __int16 v24 = 259;
    return llvm::MCAsmParser::TokError((uint64_t)a1, (uint64_t)v23, 0, 0);
  }
  uint64_t v6 = (llvm::MCContext *)(*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)a1 + 48))(a1);
  __int16 v24 = 261;
  v23[0] = v21;
  v23[1] = v22;
  uint64_t Symbol = llvm::MCContext::getOrCreateSymbol(v6, v23);
  v23[0] = (unsigned __int8 **)"expected comma";
  __int16 v24 = 259;
  if (llvm::MCAsmParser::parseToken(a1, 25, (llvm::Twine *)v23)) {
    return 1;
  }
  uint64_t v20 = 0;
  uint64_t v8 = *(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)a1 + 40))(a1) + 96);
  if ((*(uint64_t (**)(llvm::MCAsmParser *, uint64_t *))(*(void *)a1 + 256))(a1, &v20)) {
    return 1;
  }
  int8x8_t v19 = 0;
  if (**(_DWORD **)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)a1 + 40))(a1) + 8) != 25) {
    goto LABEL_20;
  }
  (*(void (**)(llvm::MCAsmParser *))(*(void *)a1 + 184))(a1);
  uint64_t v9 = *(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)a1 + 40))(a1) + 96);
  if ((*(uint64_t (**)(llvm::MCAsmParser *, int8x8_t *))(*(void *)a1 + 256))(a1, &v19)) {
    return 1;
  }
  uint64_t v10 = *((void *)a1 + 22);
  int v11 = *(_DWORD *)(v10 + 356);
  if (a2 && !v11)
  {
    uint8x8_t v12 = "alignment not supported on this target";
LABEL_12:
    v23[0] = (unsigned __int8 **)v12;
    __int16 v24 = 259;
    uint64_t v13 = (uint64_t)a1;
    uint64_t v14 = v9;
    return llvm::MCAsmParser::Error(v13, v14, (uint64_t)v23, 0, 0);
  }
  if (a2)
  {
    if (v11 != 1) {
      goto LABEL_20;
    }
  }
  else if (!*(unsigned char *)(v10 + 354))
  {
    goto LABEL_20;
  }
  uint8x8_t v15 = (uint8x8_t)vcnt_s8(v19);
  v15.i16[0] = vaddlv_u8(v15);
  if (v15.u32[0] != 1)
  {
    uint8x8_t v12 = "alignment must be a power of 2";
    goto LABEL_12;
  }
  int8x8_t v19 = (int8x8_t)(63 - __clz(*(void *)&v19));
LABEL_20:
  if (llvm::MCAsmParser::parseEOL(a1)) {
    return 1;
  }
  if (v20 < 0)
  {
    v23[0] = (unsigned __int8 **)"size must be non-negative";
    __int16 v24 = 259;
    uint64_t v13 = (uint64_t)a1;
    uint64_t v14 = v8;
    return llvm::MCAsmParser::Error(v13, v14, (uint64_t)v23, 0, 0);
  }
  int v16 = *(_DWORD *)(Symbol + 8);
  if ((v16 & 2) != 0)
  {
    if ((*(_DWORD *)(Symbol + 8) & 0x1C00) == 0x800)
    {
      *(void *)(Symbol + 24) = 0;
      v16 &= 0xFFFFE3FF;
    }
    unint64_t AssociatedFragment = 0;
    *(void *)Symbol &= 7uLL;
    v16 &= ~2u;
    *(_DWORD *)(Symbol + 8) = v16;
  }
  else
  {
    unint64_t AssociatedFragment = *(void *)Symbol & 0xFFFFFFFFFFFFFFF8;
    if (AssociatedFragment) {
      goto LABEL_30;
    }
  }
  if ((v16 & 0x1C00) == 0x800)
  {
    *(_DWORD *)(Symbol + 8) = v16 | 4;
    unint64_t AssociatedFragment = llvm::MCExpr::findAssociatedFragment(*(llvm::MCExpr **)(Symbol + 24));
    *(void *)uint64_t Symbol = *(void *)Symbol & 7 | AssociatedFragment;
  }
LABEL_30:
  if (AssociatedFragment)
  {
    v23[0] = (unsigned __int8 **)"invalid symbol redefinition";
    __int16 v24 = 259;
    uint64_t v13 = (uint64_t)a1;
    uint64_t v14 = v5;
    return llvm::MCAsmParser::Error(v13, v14, (uint64_t)v23, 0, 0);
  }
  uint64_t v18 = *(void *)(*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)a1 + 56))(a1);
  if (a2) {
    (*(void (**)(void))(v18 + 464))();
  }
  else {
    (*(void (**)(void))(v18 + 456))();
  }
  return 0;
}

uint64_t sub_1CD37BE90(llvm::MCAsmParser *a1, char a2)
{
  char v5 = a2;
  if ((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)a1 + 264))(a1)) {
    return 1;
  }
  v4[0] = a1;
  v4[1] = &v5;
  return llvm::MCAsmParser::parseMany(a1, (uint64_t (*)(uint64_t))sub_1CD3807E8, (uint64_t)v4, 1);
}

uint64_t sub_1CD37BF1C(llvm::MCAsmParser *a1, int a2)
{
  unint64_t v17 = 0;
  if ((*(uint64_t (**)(llvm::MCAsmParser *, unint64_t *))(*(void *)a1 + 256))(a1, &v17)) {
    return 1;
  }
  if (v17 != 255)
  {
    uint8x8_t v15 = 0;
    int v16 = 0;
    if (v17 > 0xFF
      || (v17 & 0xD) != 0 && ((v17 & 0xF) <= 0xC ? (BOOL v5 = ((1 << (v17 & 0xF)) & 0x1D18) == 0) : (BOOL v5 = 1), v5))
    {
      v13[0] = "unsupported encoding.";
      __int16 v14 = 259;
      llvm::MCAsmParser::check(a1, 1, (const llvm::Twine *)v13);
    }
    else
    {
      unint64_t v6 = v17 & 0x60;
      v13[0] = "unsupported encoding.";
      __int16 v14 = 259;
      llvm::MCAsmParser::check(a1, v6 != 0, (const llvm::Twine *)v13);
      if (!v6)
      {
        v18[0] = (unsigned __int8 **)"expected comma";
        __int16 v19 = 259;
        if (!llvm::MCAsmParser::parseToken(a1, 25, (llvm::Twine *)v18))
        {
          uint64_t v7 = (*(uint64_t (**)(llvm::MCAsmParser *, unsigned __int8 ***))(*(void *)a1 + 192))(a1, &v15);
          char v8 = v7;
          int v11 = "expected identifier in directive";
          __int16 v12 = 259;
          llvm::MCAsmParser::check(a1, v7, (const llvm::Twine *)&v11);
          if ((v8 & 1) == 0 && !llvm::MCAsmParser::parseEOL(a1))
          {
            uint64_t v9 = (llvm::MCContext *)(*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)a1 + 48))(a1);
            __int16 v19 = 261;
            v18[0] = v15;
            v18[1] = v16;
            llvm::MCContext::getOrCreateSymbol(v9, v18);
            uint64_t v10 = *(void *)(*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)a1 + 56))(a1);
            if (a2) {
              (*(void (**)(void))(v10 + 912))();
            }
            else {
              (*(void (**)(void))(v10 + 920))();
            }
            return 0;
          }
        }
      }
    }
    return 1;
  }
  return 0;
}

uint64_t sub_1CD37C184(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v5 = *(void *)(a1 + 304);
  if (*(void *)(a1 + 296) == v5 || !*(unsigned char *)(v5 - 3))
  {
    if (a3)
    {
      int v7 = **(_DWORD **)(a1 + 48);
      if (v7 == 3)
      {
        uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        unint64_t v11 = *(void *)(*(void *)(v10 + 8) + 16);
        unint64_t v12 = v11 != 0;
        if (v11) {
          char v8 = (const char *)(*(void *)(*(void *)(v10 + 8) + 8) + 1);
        }
        else {
          char v8 = *(const char **)(*(void *)(v10 + 8) + 8);
        }
        if (v12 <= v11 - 1) {
          unint64_t v13 = v11 - 1;
        }
        else {
          unint64_t v13 = v11 != 0;
        }
        if (v11 < v13) {
          unint64_t v13 = *(void *)(*(void *)(v10 + 8) + 16);
        }
        uint64_t v9 = v13 - v12;
        (*(void (**)(uint64_t))(*(void *)a1 + 184))(a1);
      }
      else
      {
        if (v7 != 9)
        {
          v14[0] = ".error argument must be a string";
          __int16 v15 = 259;
          return llvm::MCAsmParser::TokError(a1, (uint64_t)v14, 0, 0);
        }
        char v8 = ".error directive invoked in source file";
        uint64_t v9 = 39;
      }
      __int16 v15 = 261;
      v14[0] = v8;
      v14[1] = v9;
    }
    else
    {
      v14[0] = ".err encountered";
      __int16 v15 = 259;
    }
    return llvm::MCAsmParser::Error(a1, a2, (uint64_t)v14, 0, 0);
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 224))(a1);
  return 0;
}

uint64_t sub_1CD37C308(llvm::MCAsmParser *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *((void *)a1 + 17);
  if ((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)a1 + 264))(a1)) {
    return 1;
  }
  uint64_t v19 = 0;
  if ((*(uint64_t (**)(llvm::MCAsmParser *, uint64_t *))(*(void *)a1 + 256))(a1, &v19)) {
    return 1;
  }
  if (v19 < 0)
  {
    v17[0] = "'";
    v17[2] = a2;
    void v17[3] = a3;
    __int16 v18 = 1283;
    v20[0] = v17;
    uint64_t v20[2] = "' directive with negative repeat count has no effect";
    __int16 v21 = 770;
    (*(void (**)(llvm::MCAsmParser *, uint64_t, void *, void, void))(*(void *)a1 + 168))(a1, v8, v20, 0, 0);
    return 0;
  }
  v20[0] = "expected comma";
  __int16 v21 = 259;
  if (llvm::MCAsmParser::parseToken(a1, 25, (llvm::Twine *)v20)) {
    return 1;
  }
  v17[0] = 0;
  uint64_t v10 = *(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)a1 + 40))(a1) + 96);
  v20[0] = 0;
  if ((*(uint64_t (**)(llvm::MCAsmParser *, void *, void *))(*(void *)a1 + 232))(a1, v17, v20)) {
    return 1;
  }
  if (*(unsigned char *)v17[0] != 1)
  {
    for (uint64_t i = v19; i; --i)
    {
      uint64_t v16 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)a1 + 56))(a1);
      (*(void (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)v16 + 512))(v16, v17[0], a4, v10);
    }
    return llvm::MCAsmParser::parseEOL(a1);
  }
  int64_t v11 = *(void *)(v17[0] + 16);
  if (0xFFFFFFFFFFFFFFFFLL >> (-8 * a4) >= v11
    || (uint64_t v12 = -1 << (8 * a4 - 1), v12 <= v11) && v11 <= ~v12)
  {
    for (uint64_t j = v19; j; --j)
    {
      uint64_t v14 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)a1 + 56))(a1);
      (*(void (**)(uint64_t, int64_t, uint64_t))(*(void *)v14 + 520))(v14, v11, a4);
    }
    return llvm::MCAsmParser::parseEOL(a1);
  }
  v20[0] = "literal value out of range for directive";
  __int16 v21 = 259;
  return llvm::MCAsmParser::Error((uint64_t)a1, v10, (uint64_t)v20, 0, 0);
}

uint64_t sub_1CD37C630(llvm::MCAsmParser *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = (_DWORD *)*((void *)a1 + 17);
  if ((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)a1 + 264))(a1)) {
    return 1;
  }
  uint64_t v23 = 0;
  if ((*(uint64_t (**)(llvm::MCAsmParser *, uint64_t *))(*(void *)a1 + 256))(a1, &v23)) {
    return 1;
  }
  if (v23 < 0)
  {
    v21[0] = "'";
    v21[2] = a2;
    uint64_t v21[3] = a3;
    __int16 v22 = 1283;
    __int16 v24 = (const char *)v21;
    uint64_t v26 = "' directive with negative repeat count has no effect";
    __int16 v27 = 770;
    (*(void (**)(llvm::MCAsmParser *, _DWORD *, const char **, void, void))(*(void *)a1 + 168))(a1, v8, &v24, 0, 0);
    return 0;
  }
  else
  {
    __int16 v24 = "expected comma";
    __int16 v27 = 259;
    uint64_t v9 = 1;
    if (!llvm::MCAsmParser::parseToken(a1, 25, (llvm::Twine *)&v24))
    {
      unsigned int v25 = 1;
      __int16 v24 = 0;
      if ((sub_1CD37F674((_DWORD **)a1, a4, (uint64_t)&v24) & 1) == 0 && !llvm::MCAsmParser::parseEOL(a1))
      {
        uint64_t v11 = v23;
        if (v23)
        {
          uint64_t v12 = 0;
          unsigned int v13 = v25;
          unint64_t v14 = ((unint64_t)v25 + 63) >> 6;
          __int16 v15 = v24;
          do
          {
            uint64_t v16 = (*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)a1 + 56))(a1);
            if (v13 >= 0x41)
            {
              int v17 = 0;
              uint64_t v18 = v14;
              do
              {
                if (v18-- < 1) {
                  break;
                }
                unint64_t v20 = *(void *)&v15[8 * v18];
                v17 += __clz(v20);
              }
              while (!v20);
            }
            (*(void (**)(uint64_t))(*(void *)v16 + 520))(v16);
            uint64_t v9 = 0;
            ++v12;
          }
          while (v12 != v11);
        }
        else
        {
          uint64_t v9 = 0;
        }
      }
      if (v25 >= 0x41 && v24) {
        MEMORY[0x1D25D9CB0](v24, 0x1000C8000313F17);
      }
    }
  }
  return v9;
}

uint64_t sub_1CD37C8E4(llvm::MCAsmParser *a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t v8 = *((void *)a1 + 17);
  if ((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)a1 + 264))(a1)) {
    return 1;
  }
  uint64_t v16 = 0;
  if (((*(uint64_t (**)(llvm::MCAsmParser *, uint64_t *))(*(void *)a1 + 256))(a1, &v16) & 1) != 0
    || llvm::MCAsmParser::parseEOL(a1))
  {
    return 1;
  }
  uint64_t v10 = v16;
  if (v16 < 0)
  {
    v12[0] = "'";
    v12[2] = a2;
    uint64_t v12[3] = a3;
    __int16 v13 = 1283;
    v14[0] = v12;
    uint64_t v14[2] = "' directive with negative repeat count has no effect";
    __int16 v15 = 770;
    (*(void (**)(llvm::MCAsmParser *, uint64_t, void *, void, void))(*(void *)a1 + 168))(a1, v8, v14, 0, 0);
    return 0;
  }
  if (!v16) {
    return 0;
  }
  do
  {
    uint64_t v11 = (llvm::MCStreamer *)(*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)a1 + 56))(a1);
    llvm::MCStreamer::emitFill(v11, (llvm::MCConstantExpr *)a4, 0);
    uint64_t result = 0;
    --v10;
  }
  while (v10);
  return result;
}

uint64_t sub_1CD37CA70(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, long long *a5, char *a6)
{
  v57[32] = *MEMORY[0x1E4F143B8];
  v42[0] = a3;
  v42[1] = a4;
  uint64_t v10 = __p;
  llvm::StringRef::lower((llvm::StringRef *)v42, __p);
  uint64_t v39 = *(void *)(a2 + 88);
  uint64_t v11 = *(void *)(a1 + 8);
  if (v41 >= 0)
  {
    uint64_t v12 = (void *)(v41 & 0x7F);
  }
  else
  {
    uint64_t v10 = (void **)__p[0];
    uint64_t v12 = __p[1];
  }
  long long v35 = *a5;
  uint64_t v36 = *((void *)a5 + 2);
  unsigned int v38 = *((_DWORD *)a5 + 8);
  if (v38 > 0x40) {
    operator new[]();
  }
  uint64_t v37 = *((void *)a5 + 3);
  char v13 = (*(uint64_t (**)(uint64_t, uint64_t *, void **, void *, long long *, uint64_t))(*(void *)v11 + 56))(v11, &v39, v10, v12, &v35, a2);
  char v14 = v13;
  if (v38 >= 0x41 && v37) {
    MEMORY[0x1D25D9CB0](v37, 0x1000C8000313F17);
  }
  *(unsigned char *)(a2 + 84) = v14;
  if (*(unsigned char *)(a1 + 33))
  {
    size_t v54 = &v55;
    uint64_t v55 = v57;
    long long v56 = xmmword_1CD96DBF0;
    int v47 = 0;
    char v51 = 0;
    uint64_t v52 = 0;
    int v53 = 0;
    uint64_t v46 = &unk_1F2646FA8;
    uint64_t v48 = 0;
    unint64_t v49 = 0;
    uint64_t v50 = 0;
    llvm::raw_ostream::write((llvm::raw_ostream *)&v46, "parsed instruction: [", 0x15uLL);
    if (*(_DWORD *)(a2 + 8))
    {
      uint64_t v24 = 0;
      int v25 = 0;
      do
      {
        if (v25)
        {
          if ((unint64_t)(v49 - v50) > 1)
          {
            *(_WORD *)uint64_t v50 = 8236;
            v50 += 2;
          }
          else
          {
            llvm::raw_ostream::write((llvm::raw_ostream *)&v46, ", ", 2uLL);
          }
        }
        (*(void (**)(void, void **))(**(void **)(*(void *)a2 + 8 * v24) + 120))(*(void *)(*(void *)a2 + 8 * v24), &v46);
        uint64_t v24 = (v25 + 1);
        int v25 = v24;
      }
      while (v24 != *(_DWORD *)(a2 + 8));
    }
    if (v49 == v50) {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v46, "]", 1uLL);
    }
    else {
      *v50++ = 93;
    }
    uint64_t v19 = *v54;
    uint64_t v18 = v54[1];
    __int16 v45 = 261;
    v44[0] = v19;
    v44[1] = v18;
    v43[0] = 0;
    v43[1] = 0;
    llvm::SourceMgr::PrintMessage(*(llvm **)(a1 + 240), a6, 3, (llvm::Twine *)v44, v43, 1, 0, 0, 1u);
    uint64_t v46 = &unk_1F2646B98;
    if (v53 == 1 && v48) {
      MEMORY[0x1D25D9CB0](v48, 0x1000C8077774924);
    }
    if (v55 != v57) {
      free(v55);
    }
  }
  if (*(_DWORD *)(a1 + 24)) {
    char v15 = 1;
  }
  else {
    char v15 = v14;
  }
  if (v15)
  {
    uint64_t v16 = 1;
  }
  else
  {
    if (sub_1CD37ABFC((void *)a1))
    {
      unint64_t v20 = (uint64_t *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 48))(a1) + 1520);
      uint64_t v21 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1);
      uint64_t v22 = *(unsigned int *)(v21 + 120);
      uint64_t v23 = v22 ? *(void **)(*(void *)(v21 + 112) + 32 * v22 - 32) : 0;
      uint64_t v55 = v23;
      uint64_t v46 = 0;
      if (sub_1CD420258(v20, &v55, &v46))
      {
        uint64_t v26 = *(uint64_t **)(a1 + 352);
        if (v26 == *(uint64_t **)(a1 + 360))
        {
          int v27 = *(_DWORD *)(a1 + 280);
          uint64_t v28 = a6;
        }
        else
        {
          uint64_t v29 = *v26;
          uint64_t v28 = *(char **)v29;
          int v27 = *(_DWORD *)(v29 + 8);
        }
        unint64_t LineAndColumn = llvm::SourceMgr::getLineAndColumn(*(uint64_t **)(a1 + 240), v28, v27);
        if (*(void *)(a1 + 440))
        {
          uint64_t v33 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1);
          LOBYTE(v46) = 0;
          LOBYTE(v48) = 0;
          LOBYTE(v55) = 0;
          BYTE8(v56) = 0;
          (*(void (**)(void *__return_ptr))(*(void *)v33 + 688))(v44);
          int v34 = v44[0];
          *(_DWORD *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 48))(a1) + 1516) = v34;
          unint64_t LineAndColumn = ~llvm::SourceMgr::getLineAndColumn(*(uint64_t **)(a1 + 240), *(char **)(a1 + 456), *(_DWORD *)(a1 + 464))+ *(_DWORD *)(a1 + 448)+ LineAndColumn;
        }
        uint64_t v31 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1);
        uint64_t v32 = *(unsigned int *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 48))(a1) + 1516);
        (*(void (**)(uint64_t, uint64_t, unint64_t, void, uint64_t, void, void))(*(void *)v31 + 712))(v31, v32, LineAndColumn, 0, 1, 0, 0);
      }
    }
    uint64_t v55 = 0;
    uint64_t v16 = (*(uint64_t (**)(void, char *, uint64_t, uint64_t, void, void **, void))(**(void **)(a1 + 8)
                                                                                               + 72))(*(void *)(a1 + 8), a6, a2 + 80, a2, *(void *)(a1 + 224), &v55, *(unsigned __int8 *)(*(void *)(a1 + 8) + 64));
  }
  if (v41 < 0) {
    operator delete(__p[0]);
  }
  return v16;
}

long long *sub_1CD37D0BC(long long *a1, long long *a2, uint64_t a3)
{
  uint64_t v4 = a1;
  if (a1 != a2)
  {
    do
    {
      long long v6 = *v4;
      *(void *)(a3 + 16) = *((void *)v4 + 2);
      *(_OWORD *)a3 = v6;
      if (*(_DWORD *)(a3 + 32) >= 0x41u)
      {
        uint64_t v7 = *(void *)(a3 + 24);
        if (v7) {
          MEMORY[0x1D25D9CB0](v7, 0x1000C8000313F17);
        }
      }
      *(void *)(a3 + 24) = *((void *)v4 + 3);
      *(_DWORD *)(a3 + 32) = *((_DWORD *)v4 + 8);
      *((_DWORD *)v4 + 8) = 0;
      a3 += 40;
      uint64_t v4 = (long long *)((char *)v4 + 40);
    }
    while (v4 != a2);
    return a2;
  }
  return v4;
}

uint64_t sub_1CD37D15C(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  v81[4] = *MEMORY[0x1E4F143B8];
  if (a2) {
    unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * ((a2[5] - a2[4]) >> 4);
  }
  else {
    LODWORD(v5) = 0;
  }
  uint64_t v79 = v81;
  uint64_t v80 = 0x400000000;
  uint64_t v6 = v5;
  sub_1CD8F3C00(a3, v5);
  sub_1CD8F3E70((uint64_t)&v79, v5);
  if (v5) {
    BOOL v58 = *(unsigned char *)(a2[5] - 7) != 0;
  }
  else {
    BOOL v58 = 0;
  }
  char v60 = 0;
  int v7 = 0;
  unsigned int v8 = v5 - 1;
  int v56 = v5;
  while (1)
  {
    uint64_t v9 = *(void *)(a1 + 136);
    long long v77 = 0u;
    memset(v78, 0, 26);
    if (**(_DWORD **)(a1 + 48) == 2)
    {
      *((void *)&v73 + 1) = 0;
      uint64_t v74 = 0;
      unsigned int v76 = 1;
      unint64_t __src = 0;
      (*(void (**)(uint64_t, long long *, uint64_t, uint64_t))(*(void *)(a1 + 40) + 32))(a1 + 40, &v73, 1, 1);
      int v10 = v73;
      if (v76 >= 0x41 && __src) {
        MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
      }
      if (v10 == 27)
      {
        if ((*(unsigned int (**)(uint64_t, long long *))(*(void *)a1 + 192))(a1, &v77))
        {
          uint64_t v48 = "invalid argument identifier for formal argument";
          goto LABEL_100;
        }
        if (**(_DWORD **)(a1 + 48) != 27)
        {
          *(void *)&long long v73 = "expected '=' after formal parameter identifier";
          LOWORD(v76) = 259;
          char v54 = llvm::MCAsmParser::TokError(a1, (uint64_t)&v73, 0, 0);
          goto LABEL_94;
        }
        (*(void (**)(uint64_t))(*(void *)a1 + 184))(a1);
        char v60 = 1;
      }
    }
    int v11 = v7 == v8 && v58;
    if ((v60 & 1) != 0 && !*((void *)&v77 + 1))
    {
      uint64_t v48 = "cannot mix positional and keyword arguments";
LABEL_100:
      *(void *)&long long v73 = v48;
      LOWORD(v76) = 259;
      uint64_t v53 = a1;
      uint64_t v50 = v9;
      goto LABEL_93;
    }
    uint64_t v57 = v9;
    uint64_t v12 = *(unsigned char **)(a1 + 136);
    uint64_t v72 = 0;
    if (!*(unsigned char *)(a1 + 807)) {
      goto LABEL_38;
    }
    int v13 = **(_DWORD **)(a1 + 48);
    if (v13 == 36)
    {
      v68[0] = 0;
      (*(void (**)(uint64_t))(*(void *)a1 + 184))(a1);
      if (((*(uint64_t (**)(uint64_t, void *, unsigned char **))(*(void *)a1 + 232))(a1, v68, &v72) & 1) == 0)
      {
        uint64_t v25 = v68[0];
        uint64_t v26 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1);
        int v27 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)v26 + 72))(v26);
        long long v73 = 0uLL;
        LODWORD(__src) = 0;
        uint64_t v74 = 0;
        if (*(unsigned char *)v25 == 1)
        {
          uint64_t v28 = *(char **)(v25 + 16);
        }
        else
        {
          if ((llvm::MCExpr::evaluateAsRelocatableImpl(v25, (uint64_t)&v73, v27, 0, 0, 0, 0) & 1) == 0
            || v73 != 0)
          {
            *(void *)&long long v73 = "expected absolute expression";
            LOWORD(v76) = 259;
            uint64_t v53 = a1;
            uint64_t v50 = (uint64_t)v12;
            goto LABEL_93;
          }
          uint64_t v28 = (char *)v74;
        }
        LODWORD(v73) = 4;
        *((void *)&v73 + 1) = v12;
        uint64_t v74 = (const char *)(v72 - v12);
        unsigned int v76 = 64;
        unint64_t __src = v28;
        goto LABEL_67;
      }
      goto LABEL_89;
    }
    char v14 = v12;
    if (v13 != 38)
    {
LABEL_38:
      if ((sub_1CD37E168(a1, (uint64_t)v78, v11) & 1) == 0) {
        goto LABEL_39;
      }
      char v49 = 1;
      goto LABEL_95;
    }
    while (1)
    {
      unsigned int v15 = *v14;
      if (v15 <= 0x20)
      {
        if (*v14) {
          BOOL v16 = v15 == 10;
        }
        else {
          BOOL v16 = 1;
        }
        if (v16 || v15 == 13) {
          goto LABEL_38;
        }
        goto LABEL_37;
      }
      if (v15 == 33)
      {
        ++v14;
        goto LABEL_37;
      }
      if (v15 == 62) {
        break;
      }
LABEL_37:
      ++v14;
    }
    uint64_t v29 = v14 + 1;
    uint64_t v72 = v14 + 1;
    sub_1CD37E0E4(a1, (unint64_t)(v14 + 1), *(_DWORD *)(a1 + 280));
    (*(void (**)(uint64_t))(*(void *)a1 + 184))(a1);
    LODWORD(v73) = 3;
    *((void *)&v73 + 1) = v12;
    uint64_t v74 = (const char *)(v29 - v12);
    unsigned int v76 = 64;
    unint64_t __src = 0;
LABEL_67:
    uint64_t v30 = v78[1];
    if (v78[1] >= v78[2])
    {
      uint64_t v33 = sub_1CD37E5E8(v78, (uint64_t)&v73);
    }
    else
    {
      long long v31 = v73;
      *((void *)v78[1] + 2) = v74;
      *(_OWORD *)uint64_t v30 = v31;
      unsigned int v32 = v76;
      *((_DWORD *)v30 + 8) = v76;
      if (v32 > 0x40) {
        operator new[]();
      }
      *((void *)v30 + 3) = __src;
      uint64_t v33 = v30 + 40;
    }
    v78[1] = v33;
    if (v76 >= 0x41 && __src) {
      MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
    }
LABEL_39:
    size_t v18 = *((void *)&v77 + 1);
    LODWORD(v19) = v7;
    if (*((void *)&v77 + 1)) {
      break;
    }
LABEL_46:
    if (v78[0] != v78[1])
    {
      uint64_t v22 = *a3;
      if (0xAAAAAAAAAAAAAAABLL * ((a3[1] - *a3) >> 3) <= v19)
      {
        sub_1CD8F3C00(a3, (v19 + 1));
        uint64_t v22 = *a3;
      }
      uint64_t v23 = (char **)(v22 + 24 * v19);
      if (v23 != v78) {
        sub_1CD37E798((uint64_t)v23, (uint64_t)v78[0], (uint64_t)v78[1], 0xCCCCCCCCCCCCCCCDLL * ((v78[1] - v78[0]) >> 3));
      }
      if (v80 <= v19) {
        sub_1CD8F3E70((uint64_t)&v79, (v19 + 1));
      }
      v79[v19] = *(void *)(a1 + 136);
    }
    int v24 = **(_DWORD **)(a1 + 48);
    if (v24 == 25)
    {
      (*(void (**)(uint64_t))(*(void *)a1 + 184))(a1);
    }
    else if (v24 == 9)
    {
      if (v56)
      {
        uint64_t v34 = 0;
        uint64_t v35 = 0;
        uint64_t v36 = 0;
        char v49 = 0;
        uint64_t v37 = 48 * v6;
        do
        {
          if (*(void *)(*a3 + v35) == *(void *)(*a3 + v35 + 8))
          {
            uint64_t v38 = a2[4];
            if (*(unsigned char *)(v38 + v36 + 40))
            {
              uint64_t v44 = v79[v34];
              if (!v44) {
                uint64_t v44 = *(void *)(a1 + 136);
              }
              __int16 v45 = (const void **)(v38 + v36);
              __int16 v64 = 1283;
              v61[0] = "missing value for required parameter '";
              unsigned int v62 = *v45;
              size_t v63 = (size_t)v45[1];
              v65[0] = v61;
              int v66 = "' in macro '";
              __int16 v67 = 770;
              uint64_t v47 = *a2;
              uint64_t v46 = a2[1];
              v68[0] = v65;
              uint64_t v69 = v47;
              uint64_t v70 = v46;
              __int16 v71 = 1282;
              *(void *)&long long v73 = v68;
              uint64_t v74 = "'";
              LOWORD(v76) = 770;
              llvm::MCAsmParser::Error(a1, v44, (uint64_t)&v73, 0, 0);
              uint64_t v38 = a2[4];
              char v49 = 1;
            }
            uint64_t v39 = v38 + v36;
            uint64_t v40 = *(void *)(v39 + 16);
            uint64_t v41 = *(void *)(v39 + 24);
            uint64_t v42 = v39 + 16;
            if (v40 != v41)
            {
              uint64_t v43 = *a3 + v35;
              if (v42 != v43) {
                sub_1CD37E798(v43, v40, v41, 0xCCCCCCCCCCCCCCCDLL * ((v41 - v40) >> 3));
              }
            }
          }
          v36 += 48;
          v35 += 24;
          ++v34;
        }
        while (v37 != v36);
        goto LABEL_95;
      }
LABEL_89:
      char v49 = 0;
      goto LABEL_95;
    }
    *(void *)&long long v73 = v78;
    sub_1CCBB926C((void ***)&v73);
    if (v8 < ++v7)
    {
      *(void *)&long long v77 = "too many positional arguments";
      LOWORD(v78[2]) = 259;
      char v49 = llvm::MCAsmParser::TokError(a1, (uint64_t)&v77, 0, 0);
      goto LABEL_96;
    }
  }
  if (v56)
  {
    uint64_t v19 = 0;
    unint64_t v20 = (const void *)v77;
    uint64_t v21 = (void *)(a2[4] + 8);
    while (*v21 != v18 || memcmp((const void *)*(v21 - 1), v20, v18))
    {
      ++v19;
      v21 += 6;
      if (v6 == v19) {
        goto LABEL_92;
      }
    }
    goto LABEL_46;
  }
  unint64_t v20 = (const void *)v77;
LABEL_92:
  __int16 v64 = 1283;
  v61[0] = "parameter named '";
  unsigned int v62 = v20;
  size_t v63 = v18;
  v65[0] = v61;
  int v66 = "' does not exist for macro '";
  __int16 v67 = 770;
  uint64_t v50 = v57;
  uint64_t v52 = *a2;
  uint64_t v51 = a2[1];
  v68[0] = v65;
  uint64_t v69 = v52;
  uint64_t v70 = v51;
  __int16 v71 = 1282;
  *(void *)&long long v73 = v68;
  uint64_t v74 = "'";
  LOWORD(v76) = 770;
  uint64_t v53 = a1;
LABEL_93:
  char v54 = llvm::MCAsmParser::Error(v53, v50, (uint64_t)&v73, 0, 0);
LABEL_94:
  char v49 = v54;
LABEL_95:
  *(void *)&long long v73 = v78;
  sub_1CCBB926C((void ***)&v73);
LABEL_96:
  if (v79 != v81) {
    free(v79);
  }
  return v49 & 1;
}

uint64_t sub_1CD37DA74(uint64_t a1, llvm::raw_ostream *this, char *a3, size_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unint64_t a8, char a9, uint64_t a10)
{
  int v10 = a6;
  size_t v11 = a4;
  uint64_t v14 = a1;
  if (a6) {
    BOOL v79 = *(unsigned char *)(a5 + 48 * a6 - 7) != 0;
  }
  else {
    BOOL v79 = 0;
  }
  if (*(unsigned char *)(a1 + 804)) {
    BOOL v15 = a6 == 0;
  }
  else {
    BOOL v15 = 0;
  }
  uint64_t v85 = a6;
  if (!v15 && a6 != a8)
  {
    v86.__r_.__value_.__r.__words[0] = (std::string::size_type)"Wrong number of arguments";
    __int16 v87 = 259;
    return llvm::MCAsmParser::Error(a1, a10, (uint64_t)&v86, 0, 0);
  }
  if (!a4) {
    return 0;
  }
  int v78 = a6 - 1;
  uint64_t v80 = (void *)(a5 + 8);
  int v84 = a6;
  do
  {
    size_t v17 = 0;
    if (v10) {
      BOOL v18 = 1;
    }
    else {
      BOOL v18 = *(unsigned char *)(v14 + 804) == 0;
    }
    char v19 = v18;
    size_t v20 = v11 - 1;
    while (1)
    {
      int v21 = a3[v17];
      if (v19) {
        break;
      }
      BOOL v22 = v21 != 36 || v20 == v17;
      char v23 = v22;
      if (v22)
      {
        if (v20 == v17)
        {
          size_t v17 = v11;
          goto LABEL_47;
        }
      }
      else
      {
        uint64_t v24 = a3[v17 + 1];
        if (v24 == 36 || v24 == 110 || (*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v24 + 60) & 0x400) != 0) {
          goto LABEL_47;
        }
      }
LABEL_38:
      ++v17;
    }
    if (v20 != v17 && v21 != 92) {
      goto LABEL_38;
    }
    BOOL v25 = v20 != v17 && v21 == 92;
    char v23 = !v25;
    if (!v25) {
      size_t v17 = v11;
    }
LABEL_47:
    if (v11 >= v17) {
      size_t v26 = v17;
    }
    else {
      size_t v26 = v11;
    }
    int v27 = (void *)*((void *)this + 4);
    if (v26 <= *((void *)this + 3) - (void)v27)
    {
      if (v26)
      {
        memcpy(v27, a3, v26);
        *((void *)this + 4) += v26;
      }
    }
    else
    {
      llvm::raw_ostream::write(this, a3, v26);
    }
    if (v23) {
      return 0;
    }
    size_t v28 = v17 + 1;
    if (v10 || !*(unsigned char *)(v14 + 804))
    {
      if (!a9 || (size_t v31 = (v17 + 2), v11 == v31) || a3[v28] != 64)
      {
        int v32 = v17 + 2;
        do
        {
          size_t v31 = (v32 - 1);
          uint64_t v33 = a3[v31];
          if (a3[v31] < 0)
          {
            if (__maskrune(a3[v31], 0x500uLL)) {
              goto LABEL_73;
            }
          }
          else if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v33 + 60) & 0x500) != 0)
          {
            goto LABEL_73;
          }
          if ((v33 - 36) > 0x3B || ((1 << (v33 - 36)) & 0x800000000000401) == 0) {
            break;
          }
LABEL_73:
          BOOL v15 = v11 == v32++;
        }
        while (!v15);
      }
      unint64_t v35 = v31 - v28;
      if (v31 - v28 == 1 && a3[v17 + 1] == 64)
      {
        unint64_t v36 = *(unsigned int *)(v14 + 428);
        uint64_t v37 = this;
LABEL_86:
        sub_1CD098D14(v37, v36, 0, 0, 0);
        goto LABEL_164;
      }
      if (v84)
      {
        uint64_t v38 = 0;
        uint64_t v39 = v80;
        while (*v39 != v35 || v31 != v28 && memcmp((const void *)*(v39 - 1), &a3[v17 + 1], v31 - v28))
        {
          v39 += 6;
          if (v85 == ++v38) {
            goto LABEL_97;
          }
        }
      }
      else
      {
        LODWORD(v38) = 0;
      }
      if (v38 == v84)
      {
LABEL_97:
        uint64_t v14 = a1;
        if (a3[v28] == 40 && a3[v17 + 2] == 41)
        {
          size_t v28 = v17 + 3;
          goto LABEL_165;
        }
        uint64_t v47 = (unsigned char *)*((void *)this + 4);
        if ((unint64_t)v47 >= *((void *)this + 3))
        {
          llvm::raw_ostream::write(this, 92);
        }
        else
        {
          *((void *)this + 4) = v47 + 1;
          *uint64_t v47 = 92;
        }
        BOOL v75 = (void *)*((void *)this + 4);
        if (v35 <= *((void *)this + 3) - (void)v75)
        {
          if (v31 == v28) {
            goto LABEL_165;
          }
          memcpy(v75, &a3[v17 + 1], v31 - v28);
          *((void *)this + 4) += v35;
        }
        else
        {
          llvm::raw_ostream::write(this, &a3[v17 + 1], v31 - v28);
        }
        goto LABEL_162;
      }
      int v48 = v38 == v78 && v79;
      char v49 = (int **)(a7 + 24 * v38);
      uint64_t v50 = *v49;
      uint64_t v51 = v49[1];
      uint64_t v14 = a1;
      if (*v49 == v51)
      {
LABEL_162:
        size_t v28 = v31;
        goto LABEL_165;
      }
      while (1)
      {
        if (*(unsigned char *)(v14 + 807))
        {
          uint64_t v52 = (unsigned __int8 *)*((void *)v50 + 1);
          int v53 = *v52;
          int v54 = *v50;
          if (v53 == 37)
          {
            if (v54 == 4)
            {
              uint64_t v55 = (unint64_t *)(v50 + 6);
              if (v50[8] >= 0x41) {
                uint64_t v55 = (unint64_t *)*v55;
              }
              llvm::raw_ostream::operator<<(this, *v55);
              goto LABEL_141;
            }
          }
          else if (v53 == 60)
          {
            if (v54 == 3)
            {
              unint64_t v56 = *((void *)v50 + 2);
              unint64_t v57 = v56 - 1;
              unint64_t v58 = v56 != 0;
              if (v56) {
                size_t v59 = v52 + 1;
              }
              else {
                size_t v59 = (unsigned __int8 *)*((void *)v50 + 1);
              }
              if (v58 > v57) {
                unint64_t v57 = v56 != 0;
              }
              if (v56 >= v57) {
                unint64_t v56 = v57;
              }
              memset(&v86, 0, sizeof(v86));
              unint64_t v60 = v56 - v58;
              if (v56 == v58)
              {
                std::string::size_type size = 0;
                std::string::size_type v62 = 0;
                char v63 = 0;
              }
              else
              {
                uint64_t v69 = 0;
                do
                {
                  if (v59[v69] == 33) {
                    uint64_t v70 = v69 + 1;
                  }
                  else {
                    uint64_t v70 = v69;
                  }
                  std::string::push_back(&v86, v59[v70]);
                  uint64_t v69 = v70 + 1;
                }
                while (v70 + 1 < v60);
                char v63 = HIBYTE(v86.__r_.__value_.__r.__words[2]);
                std::string::size_type size = v86.__r_.__value_.__l.__size_;
                std::string::size_type v62 = v86.__r_.__value_.__r.__words[0];
              }
              BOOL v71 = v63 < 0;
              if (v63 >= 0) {
                uint64_t v72 = &v86;
              }
              else {
                uint64_t v72 = (std::string *)v62;
              }
              size_t v73 = v63 & 0x7F;
              if (v71) {
                size_t v74 = size;
              }
              else {
                size_t v74 = v73;
              }
              llvm::raw_ostream::write(this, (const char *)v72, v74);
              uint64_t v14 = a1;
              if (SHIBYTE(v86.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v86.__r_.__value_.__l.__data_);
              }
              goto LABEL_141;
            }
LABEL_126:
            size_t v64 = *((void *)v50 + 2);
            int v65 = (void *)*((void *)this + 4);
            if (v64 <= *((void *)this + 3) - (void)v65)
            {
              if (!v64) {
                goto LABEL_141;
              }
LABEL_140:
              memcpy(v65, v52, v64);
              *((void *)this + 4) += v64;
              goto LABEL_141;
            }
LABEL_138:
            llvm::raw_ostream::write(this, (const char *)v52, v64);
            goto LABEL_141;
          }
        }
        else
        {
          int v54 = *v50;
        }
        if (((v54 == 3) & ~v48) == 0)
        {
          uint64_t v52 = (unsigned __int8 *)*((void *)v50 + 1);
          goto LABEL_126;
        }
        unint64_t v66 = *((void *)v50 + 2);
        unint64_t v67 = v66 != 0;
        if (v66) {
          uint64_t v52 = (unsigned __int8 *)(*((void *)v50 + 1) + 1);
        }
        else {
          uint64_t v52 = (unsigned __int8 *)*((void *)v50 + 1);
        }
        if (v67 <= v66 - 1) {
          unint64_t v68 = v66 - 1;
        }
        else {
          unint64_t v68 = v66 != 0;
        }
        if (v66 >= v68) {
          unint64_t v66 = v68;
        }
        size_t v64 = v66 - v67;
        int v65 = (void *)*((void *)this + 4);
        if (v66 - v67 > *((void *)this + 3) - (void)v65) {
          goto LABEL_138;
        }
        if (v66 != v67) {
          goto LABEL_140;
        }
LABEL_141:
        v50 += 10;
        if (v50 == v51) {
          goto LABEL_162;
        }
      }
    }
    int v29 = a3[v28];
    if (v29 == 110)
    {
      uint64_t v37 = this;
      unint64_t v36 = a8;
      goto LABEL_86;
    }
    if (v29 == 36)
    {
      uint64_t v30 = (unsigned char *)*((void *)this + 4);
      if ((unint64_t)v30 >= *((void *)this + 3))
      {
        llvm::raw_ostream::write(this, 36);
      }
      else
      {
        *((void *)this + 4) = v30 + 1;
        unsigned char *v30 = 36;
      }
    }
    else
    {
      unint64_t v40 = (v29 - 48);
      if (v40 < a8)
      {
        uint64_t v41 = (uint64_t *)(a7 + 24 * v40);
        uint64_t v42 = *v41;
        uint64_t v43 = v41[1];
        while (v42 != v43)
        {
          uint64_t v44 = *(const void **)(v42 + 8);
          unint64_t v45 = *(void *)(v42 + 16);
          uint64_t v46 = (void *)*((void *)this + 4);
          if (v45 <= *((void *)this + 3) - (void)v46)
          {
            if (v45)
            {
              memcpy(v46, v44, *(void *)(v42 + 16));
              *((void *)this + 4) += v45;
            }
          }
          else
          {
            llvm::raw_ostream::write(this, (const char *)v44, *(void *)(v42 + 16));
          }
          v42 += 40;
        }
      }
    }
LABEL_164:
    size_t v28 = v17 + 2;
LABEL_165:
    if (v11 >= v28) {
      size_t v76 = v28;
    }
    else {
      size_t v76 = v11;
    }
    a3 += v76;
    v11 -= v76;
    int v10 = v84;
  }
  while (v11);
  return 0;
}

uint64_t sub_1CD37E0E4(uint64_t result, unint64_t a2, int a3)
{
  uint64_t v4 = result;
  unint64_t v5 = *(void **)(result + 240);
  if (!a3)
  {
    uint64_t result = llvm::SourceMgr::FindBufferContainingLoc(*(uint64_t **)(result + 240), a2);
    a3 = result;
  }
  uint64_t v6 = *(void *)(*v5 + 24 * (a3 - 1));
  *(_DWORD *)(v4 + 280) = a3;
  unint64_t v7 = *(void *)(v6 + 8);
  unint64_t v8 = *(void *)(v6 + 16) - v7;
  *(void *)(v4 + 192) = v7;
  *(void *)(v4 + 200) = v8;
  if (a2) {
    unint64_t v9 = a2;
  }
  else {
    unint64_t v9 = v7;
  }
  *(void *)(v4 + 184) = v9;
  *(void *)(v4 + 136) = 0;
  *(unsigned char *)(v4 + 211) = 1;
  return result;
}

uint64_t sub_1CD37E168(uint64_t a1, uint64_t a2, int a3)
{
  if (a3)
  {
    if (**(_DWORD **)(a1 + 48) == 9) {
      return 0;
    }
    uint64_t v27 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 200))(a1);
    uint64_t v29 = v27;
    uint64_t v30 = v28;
    unint64_t v31 = *(void *)(a2 + 16);
    unint64_t v32 = *(void *)(a2 + 8);
    if (v32 >= v31)
    {
      unint64_t v35 = *(char **)a2;
      unint64_t v36 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v32 - *(void *)a2) >> 3);
      unint64_t v37 = v36 + 1;
      if (v36 + 1 > 0x666666666666666) {
        abort();
      }
      if (0x999999999999999ALL * ((uint64_t)(v31 - (void)v35) >> 3) > v37) {
        unint64_t v37 = 0x999999999999999ALL * ((uint64_t)(v31 - (void)v35) >> 3);
      }
      if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v31 - (void)v35) >> 3) >= 0x333333333333333) {
        unint64_t v38 = 0x666666666666666;
      }
      else {
        unint64_t v38 = v37;
      }
      uint64_t v46 = a2 + 16;
      if (v38 > 0x666666666666666) {
        sub_1CB833614();
      }
      uint64_t v39 = (char *)operator new(40 * v38);
      unint64_t v40 = &v39[40 * v36];
      *(_DWORD *)unint64_t v40 = 3;
      *((void *)v40 + 1) = v29;
      *((void *)v40 + 2) = v30;
      *((_DWORD *)v40 + 8) = 64;
      *((void *)v40 + 3) = 0;
      uint64_t v41 = v40;
      if ((char *)v32 != v35)
      {
        uint64_t v42 = 0;
        do
        {
          uint64_t v43 = &v40[v42];
          long long v44 = *(_OWORD *)(v32 + v42 - 40);
          *((void *)v43 - 3) = *(void *)(v32 + v42 - 24);
          *(_OWORD *)(v43 - 40) = v44;
          *((_DWORD *)v43 - 2) = *(_DWORD *)(v32 + v42 - 8);
          *((void *)v43 - 2) = *(void *)(v32 + v42 - 16);
          *(_DWORD *)(v32 + v42 - 8) = 0;
          v42 -= 40;
        }
        while ((char *)(v32 + v42) != v35);
        uint64_t v41 = &v40[v42];
      }
      uint64_t v33 = v40 + 40;
      *(void *)a2 = v41;
      *(void *)(a2 + 8) = v40 + 40;
      *(void *)(a2 + 16) = &v39[40 * v38];
      v45[2] = v32;
      v45[3] = v31;
      v45[0] = v35;
      v45[1] = v35;
      sub_1CD8F3EEC((uint64_t)v45);
    }
    else
    {
      *(_DWORD *)unint64_t v32 = 3;
      *(void *)(v32 + 8) = v27;
      *(void *)(v32 + 16) = v28;
      *(_DWORD *)(v32 + 32) = 64;
      uint64_t v33 = (char *)(v32 + 40);
      *(void *)(v32 + 24) = 0;
    }
    uint64_t result = 0;
    *(void *)(a2 + 8) = v33;
    return result;
  }
  int v6 = 0;
  *(unsigned char *)(a1 + 144) = *(unsigned char *)(a1 + 804);
  while (1)
  {
    while (1)
    {
      int v7 = **(_DWORD **)(a1 + 48);
      if (v7 == 27 || v7 == 0)
      {
        uint64_t v34 = "unexpected token in macro instantiation";
        goto LABEL_64;
      }
      if (v6) {
        break;
      }
      if (v7 == 25) {
        goto LABEL_45;
      }
      if (v7 == 11) {
        sub_1CD8F38F8(a1 + 40);
      }
      if (*(unsigned char *)(a1 + 804)
        || ((unsigned int v9 = **(_DWORD **)(a1 + 48), v10 = v9 > 0x2C, v11 = (1 << v9) & 0x1FCFF980F000, !v10)
          ? (BOOL v12 = v11 == 0)
          : (BOOL v12 = 1),
            v12))
      {
        if (v7 == 11) {
          goto LABEL_45;
        }
        int v7 = **(_DWORD **)(a1 + 48);
        break;
      }
      uint64_t v13 = *(void *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 8);
      unint64_t v14 = *(void *)(a2 + 8);
      if (v14 >= *(void *)(a2 + 16))
      {
        size_t v26 = sub_1CD37E5E8((char **)a2, v13);
      }
      else
      {
        long long v15 = *(_OWORD *)v13;
        *(void *)(v14 + 16) = *(void *)(v13 + 16);
        *(_OWORD *)unint64_t v14 = v15;
        unsigned int v16 = *(_DWORD *)(v13 + 32);
        *(_DWORD *)(v14 + 32) = v16;
        if (v16 > 0x40) {
          operator new[]();
        }
        *(void *)(v14 + 24) = *(void *)(v13 + 24);
        size_t v26 = (char *)(v14 + 40);
      }
      *(void *)(a2 + 8) = v26;
      sub_1CD8F38F8(a1 + 40);
      int v6 = 0;
      int v25 = 0;
      if (**(_DWORD **)(a1 + 48) == 11) {
        goto LABEL_39;
      }
    }
    if (v7 != 17) {
      break;
    }
    int v19 = 1;
LABEL_33:
    uint64_t v20 = *(void *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 8);
    unint64_t v21 = *(void *)(a2 + 8);
    if (v21 >= *(void *)(a2 + 16))
    {
      uint64_t v24 = sub_1CD37E5E8((char **)a2, v20);
    }
    else
    {
      long long v22 = *(_OWORD *)v20;
      *(void *)(v21 + 16) = *(void *)(v20 + 16);
      *(_OWORD *)unint64_t v21 = v22;
      unsigned int v23 = *(_DWORD *)(v20 + 32);
      *(_DWORD *)(v21 + 32) = v23;
      if (v23 > 0x40) {
        operator new[]();
      }
      *(void *)(v21 + 24) = *(void *)(v20 + 24);
      uint64_t v24 = (char *)(v21 + 40);
    }
    int v25 = v19 + v6;
    *(void *)(a2 + 8) = v24;
LABEL_39:
    sub_1CD8F38F8(a1 + 40);
    int v6 = v25;
  }
  if (v7 != 9)
  {
    int v18 = v7 == 18 && v6 != 0;
    int v19 = v18 << 31 >> 31;
    goto LABEL_33;
  }
  if (!v6)
  {
LABEL_45:
    uint64_t result = 0;
    goto LABEL_46;
  }
  uint64_t v34 = "unbalanced parentheses in macro argument";
LABEL_64:
  v45[0] = v34;
  LOWORD(v46) = 259;
  uint64_t result = llvm::MCAsmParser::TokError(a1, (uint64_t)v45, 0, 0);
LABEL_46:
  *(unsigned char *)(a1 + 144) = 1;
  return result;
}

char *sub_1CD37E5E8(char **a1, uint64_t a2)
{
  int v3 = *a1;
  uint64_t v2 = a1[1];
  unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * ((v2 - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x666666666666666) {
    abort();
  }
  if (0x999999999999999ALL * ((a1[2] - v3) >> 3) > v5) {
    unint64_t v5 = 0x999999999999999ALL * ((a1[2] - v3) >> 3);
  }
  if (0xCCCCCCCCCCCCCCCDLL * ((a1[2] - v3) >> 3) >= 0x333333333333333) {
    unint64_t v7 = 0x666666666666666;
  }
  else {
    unint64_t v7 = v5;
  }
  v18[4] = a1 + 2;
  if (v7 > 0x666666666666666) {
    sub_1CB833614();
  }
  unsigned int v9 = (char *)operator new(40 * v7);
  BOOL v10 = &v9[40 * v4];
  *(_OWORD *)BOOL v10 = *(_OWORD *)a2;
  *((void *)v10 + 2) = *(void *)(a2 + 16);
  unsigned int v11 = *(_DWORD *)(a2 + 32);
  *((_DWORD *)v10 + 8) = v11;
  if (v11 > 0x40) {
    operator new[]();
  }
  *((void *)v10 + 3) = *(void *)(a2 + 24);
  BOOL v12 = v10;
  if (v2 != v3)
  {
    uint64_t v13 = 0;
    do
    {
      unint64_t v14 = &v10[v13];
      long long v15 = *(_OWORD *)&v2[v13 - 40];
      *((void *)v14 - 3) = *(void *)&v2[v13 - 24];
      *(_OWORD *)(v14 - 40) = v15;
      *((_DWORD *)v14 - 2) = *(_DWORD *)&v2[v13 - 8];
      *((void *)v14 - 2) = *(void *)&v2[v13 - 16];
      *(_DWORD *)&v2[v13 - 8] = 0;
      v13 -= 40;
    }
    while (&v2[v13] != v3);
    BOOL v12 = &v10[v13];
  }
  *a1 = v12;
  a1[1] = v10 + 40;
  unsigned int v16 = a1[2];
  a1[2] = &v9[40 * v7];
  void v18[2] = v2;
  v18[3] = v16;
  v18[0] = v3;
  v18[1] = v3;
  sub_1CD8F3EEC((uint64_t)v18);
  return v10 + 40;
}

uint64_t sub_1CD37E798(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v8 = *(void **)a1;
  if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) < a4)
  {
    sub_1CD8F3F68((void **)a1);
    if (a4 > 0x666666666666666) {
      goto LABEL_30;
    }
    unint64_t v21 = 0x999999999999999ALL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3);
    if (v21 <= a4) {
      unint64_t v21 = a4;
    }
    unint64_t v22 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) >= 0x333333333333333
        ? 0x666666666666666
        : v21;
    if (v22 > 0x666666666666666) {
LABEL_30:
    }
      abort();
    uint64_t v23 = 5 * v22;
    uint64_t result = (uint64_t)operator new(40 * v22);
    uint64_t v24 = result;
    *(void *)a1 = result;
    *(void *)(a1 + 8) = result;
    *(void *)(a1 + 16) = result + 8 * v23;
    if (a2 != a3)
    {
      uint64_t v25 = a2 + 24;
      do
      {
        *(_OWORD *)uint64_t v24 = *(_OWORD *)(v25 - 24);
        *(void *)(v24 + 16) = *(void *)(v25 - 8);
        unsigned int v26 = *(_DWORD *)(v25 + 8);
        *(_DWORD *)(v24 + 32) = v26;
        if (v26 > 0x40) {
          operator new[]();
        }
        *(void *)(v24 + 24) = *(void *)v25;
        uint64_t v27 = v25 - 24;
        v24 += 40;
        v25 += 40;
      }
      while (v27 + 40 != a3);
    }
    *(void *)(a1 + 8) = v24;
  }
  else
  {
    unint64_t v9 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 8) - (void)v8) >> 3);
    if (v9 >= a4)
    {
      uint64_t result = sub_1CD37EA2C(a2, a3, (uint64_t)v8);
      uint64_t v19 = v18;
      uint64_t v20 = *(void *)(a1 + 8);
      if (v20 != v18)
      {
        do
        {
          if (*(_DWORD *)(v20 - 8) >= 0x41u)
          {
            uint64_t result = *(void *)(v20 - 16);
            if (result) {
              uint64_t result = MEMORY[0x1D25D9CB0](result, 0x1000C8000313F17);
            }
          }
          v20 -= 40;
        }
        while (v20 != v19);
      }
      *(void *)(a1 + 8) = v19;
    }
    else
    {
      uint64_t v10 = a2 + 8 * ((uint64_t)(*(void *)(a1 + 8) - (void)v8) >> 3);
      uint64_t result = sub_1CD37EA2C(a2, v10, (uint64_t)v8);
      uint64_t v12 = *(void *)(a1 + 8);
      if (v10 != a3)
      {
        uint64_t v13 = a2 + 40 * v9 + 24;
        unint64_t v14 = (unsigned int *)(v12 + 32);
        do
        {
          long long v15 = *(_OWORD *)(v13 - 24);
          *((void *)v14 - 2) = *(void *)(v13 - 8);
          *((_OWORD *)v14 - 2) = v15;
          unsigned int v16 = *(_DWORD *)(v13 + 8);
          *unint64_t v14 = v16;
          if (v16 > 0x40) {
            operator new[]();
          }
          *((void *)v14 - 1) = *(void *)v13;
          uint64_t v17 = v13 - 24;
          v13 += 40;
          v12 += 40;
          v14 += 10;
        }
        while (v17 + 40 != a3);
      }
      *(void *)(a1 + 8) = v12;
    }
  }
  return result;
}

uint64_t sub_1CD37EA2C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 == a2) {
    return a1;
  }
  uint64_t v5 = a2;
  uint64_t v6 = 0;
  do
  {
    uint64_t v7 = a3 + v6;
    uint64_t v8 = a1 + v6;
    long long v9 = *(_OWORD *)(a1 + v6);
    *(void *)(v7 + 16) = *(void *)(a1 + v6 + 16);
    *(_OWORD *)uint64_t v7 = v9;
    if (*(_DWORD *)(a3 + v6 + 32) > 0x40u || *(_DWORD *)(v8 + 32) > 0x40u)
    {
      if (v8 != v7)
      {
        uint64_t v10 = (void **)(v7 + 24);
        llvm::APInt::reallocate(v7 + 24, *(_DWORD *)(a1 + v6 + 32));
        uint64_t v11 = *(unsigned int *)(v7 + 32);
        if (v11 <= 0x40) {
          char *v10 = *(void **)(v8 + 24);
        }
        else {
          memcpy(*v10, *(const void **)(v8 + 24), ((unint64_t)(v11 + 63) >> 3) & 0x3FFFFFF8);
        }
      }
    }
    else
    {
      *(void *)(v7 + 24) = *(void *)(v8 + 24);
      *(_DWORD *)(v7 + 32) = *(_DWORD *)(v8 + 32);
    }
    v6 += 40;
  }
  while (a1 + v6 != v5);
  return v5;
}

void sub_1CD37EB34(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    unint64_t v4 = (void **)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        uint64_t v6 = v4;
        sub_1CCBB926C(&v6);
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1CD37EBA8(uint64_t *a1)
{
  uint64_t v2 = *a1;
  long long __p = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  if (((*(uint64_t (**)(uint64_t))(*(void *)v2 + 264))(v2) & 1) == 0)
  {
    while (((*(uint64_t (**)(uint64_t, void **))(*(void *)v2 + 208))(v2, &__p) & 1) == 0)
    {
      uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 56))(v2);
      if (v11 >= 0) {
        p_p = &__p;
      }
      else {
        p_p = __p;
      }
      if (v11 >= 0) {
        uint64_t v6 = HIBYTE(v11) & 0x7F;
      }
      else {
        uint64_t v6 = v10;
      }
      (*(void (**)(uint64_t, void *, uint64_t))(*(void *)v4 + 488))(v4, p_p, v6);
      if (*(unsigned char *)a1[1]) {
        goto LABEL_13;
      }
      if (**(_DWORD **)((*(uint64_t (**)(uint64_t))(*(void *)v2 + 40))(v2) + 8) != 3)
      {
        if (*(unsigned char *)a1[1])
        {
LABEL_13:
          uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 56))(v2);
          (*(void (**)(uint64_t, void *, uint64_t))(*(void *)v7 + 488))(v7, &unk_1CFB33B70, 1);
        }
        uint64_t v3 = 0;
        goto LABEL_15;
      }
    }
  }
  uint64_t v3 = 1;
LABEL_15:
  if (SHIBYTE(v11) < 0) {
    operator delete(__p);
  }
  return v3;
}

uint64_t sub_1CD37ED8C(uint64_t a1)
{
  uint64_t v2 = *(void *)a1;
  uint64_t v14 = 0;
  uint64_t v3 = *(void *)((*(uint64_t (**)(uint64_t))(*(void *)v2 + 40))(v2) + 96);
  if ((*(uint64_t (**)(uint64_t))(*(void *)v2 + 264))(v2)) {
    return 1;
  }
  v12[0] = 0;
  if ((*(uint64_t (**)(uint64_t, uint64_t *, void *))(*(void *)v2 + 232))(v2, &v14, v12)) {
    return 1;
  }
  if (*(unsigned char *)v14 == 1)
  {
    int64_t v5 = *(void *)(v14 + 16);
    unsigned int v6 = 8 * **(_DWORD **)(a1 + 8);
    if (v6 <= 0x3F && 0xFFFFFFFFFFFFFFFFLL >> (-8 * **(unsigned char **)(a1 + 8)) < v5)
    {
      uint64_t v8 = -1 << (v6 - 1);
      if (v8 > v5 || v5 > ~v8)
      {
        v12[0] = "out of range literal value";
        __int16 v13 = 259;
        return llvm::MCAsmParser::Error(v2, v3, (uint64_t)v12, 0, 0);
      }
    }
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 56))(v2);
    (*(void (**)(uint64_t, int64_t, void))(*(void *)v10 + 520))(v10, v5, **(unsigned int **)(a1 + 8));
  }
  else
  {
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 56))(v2);
    (*(void (**)(uint64_t, uint64_t, void, uint64_t))(*(void *)v11 + 512))(v11, v14, **(unsigned int **)(a1 + 8), v3);
  }
  return 0;
}

uint64_t sub_1CD37EFBC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if ((*(uint64_t (**)(uint64_t))(*(void *)*a1 + 264))(*a1)) {
    return 1;
  }
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  uint64_t v2 = sub_1CD37F168(v1, &v7, &v6);
  if ((v2 & 1) == 0)
  {
    uint64_t v3 = *(void (**)(void))(*(void *)(*(uint64_t (**)(uint64_t))(*(void *)v1 + 56))(v1) + 520);
    v3();
    uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)v1 + 56))(v1);
    (*(void (**)(void))(*(void *)v4 + 520))();
  }
  return v2;
}

uint64_t sub_1CD37F168(uint64_t a1, void *a2, void *a3)
{
  if (**(_DWORD **)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 8) == 4
    || **(_DWORD **)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 8) == 5)
  {
    (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    uint64_t v6 = *(void *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 8);
    unsigned int v10 = *(_DWORD *)(v6 + 32);
    if (v10 > 0x40) {
      operator new[]();
    }
    uint64_t v9 = *(void *)(v6 + 24);
    (*(void (**)(uint64_t))(*(void *)a1 + 184))(a1);
    uint64_t v7 = 0;
    *a2 = 0;
    *a3 = v9;
  }
  else
  {
    uint64_t v11 = "unknown token in expression";
    __int16 v12 = 259;
    return llvm::MCAsmParser::TokError(a1, (uint64_t)&v11, 0, 0);
  }
  return v7;
}

uint64_t sub_1CD37F4FC(uint64_t a1)
{
  uint64_t v2 = *(_DWORD ***)a1;
  uint64_t v3 = 1;
  unsigned int v14 = 1;
  __int16 v13 = 0;
  if (((*((uint64_t (**)(_DWORD **))*v2 + 33))(v2) & 1) == 0)
  {
    uint64_t v3 = sub_1CD37F674(v2, *(void *)(a1 + 8), (uint64_t)&v13);
    if (v3)
    {
      unsigned int v4 = v14;
    }
    else
    {
      uint64_t v5 = (*((uint64_t (**)(_DWORD **))*v2 + 7))(v2);
      unsigned int v4 = v14;
      if (v14 >= 0x41)
      {
        int v8 = 0;
        int64_t v9 = ((unint64_t)v14 + 63) >> 6;
        do
        {
          if (v9-- < 1) {
            break;
          }
          unint64_t v11 = v13[v9];
          v8 += __clz(v11);
        }
        while (!v11);
        unsigned int v12 = v14 | 0xFFFFFFC0;
        if ((v14 & 0x3F) == 0) {
          unsigned int v12 = 0;
        }
        if (v14 - v8 - v12 > 0x40) {
          uint64_t v6 = -1;
        }
        else {
          uint64_t v6 = *v13;
        }
      }
      else
      {
        uint64_t v6 = (uint64_t)v13;
      }
      (*(void (**)(uint64_t, uint64_t, void))(*(void *)v5 + 520))(v5, v6, v14 >> 3);
    }
    if (v4 >= 0x41 && v13) {
      MEMORY[0x1D25D9CB0](v13, 0x1000C8000313F17);
    }
  }
  return v3;
}

uint64_t sub_1CD37F674(_DWORD **a1, uint64_t a2, uint64_t a3)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  int v6 = **(_DWORD **)((*((uint64_t (**)(_DWORD **))*a1 + 5))(a1) + 8);
  if (v6 == 13 || (uint64_t v7 = (*((uint64_t (**)(_DWORD **))*a1 + 5))(a1), **(_DWORD **)(v7 + 8) == 12)) {
    uint64_t v7 = sub_1CD8F38F8((uint64_t)(a1 + 5));
  }
  switch(*a1[6])
  {
    case 1:
      __int16 v25 = 260;
      unint64_t v22 = (const char *)(a1 + 14);
      return llvm::MCAsmParser::TokError((uint64_t)a1, (uint64_t)&v22, 0, 0);
    case 2:
    case 4:
    case 6:
      if ((_UNKNOWN *)a2 == &unk_1CFB2E344) {
        llvm::detail::DoubleAPFloat::DoubleAPFloat(&v18, (uint64_t)&unk_1CFB2E344);
      }
      uint64_t v18 = a2;
      int v8 = *(_DWORD *)(a2 + 8);
      if ((v8 + 64) >= 0x80) {
        operator new[]();
      }
      char v21 = 3;
      int v20 = *(_DWORD *)(a2 + 4) - 1;
      if ((v8 - 64) < 0xFFFFFF80)
      {
        *(void *)uint64_t v7 = 0;
        bzero((void *)(v7 + 8), 8 * (((v8 + 64) >> 6) - 2) + 8);
      }
      else
      {
        uint64_t v19 = 0;
      }
      uint64_t v9 = *(void *)((*((uint64_t (**)(_DWORD **))*a1 + 5))(a1) + 8);
      unsigned int v10 = *(unsigned __int8 **)(v9 + 8);
      unint64_t v11 = *(unsigned __int8 **)(v9 + 16);
      v15[0] = v10;
      v15[1] = v11;
      if (**(_DWORD **)((*((uint64_t (**)(_DWORD **))*a1 + 5))(a1) + 8) != 2)
      {
        llvm::APFloat::convertFromString((uint64_t)v17, v10, (unint64_t)v11, 1, (llvm *)&v22);
        if ((v23 & 1) == 0 || !v22) {
          goto LABEL_11;
        }
        unsigned int v16 = (char *)v22;
        sub_1CD4515D0((void **)&v16);
        if (v16) {
          (*(void (**)(char *))(*(void *)v16 + 8))(v16);
        }
LABEL_32:
        unint64_t v22 = "invalid floating point literal";
        __int16 v25 = 259;
        uint64_t v12 = llvm::MCAsmParser::TokError((uint64_t)a1, (uint64_t)&v22, 0, 0);
        goto LABEL_20;
      }
      if (!llvm::StringRef::compare_insensitive(v15, "infinity", 8uLL)
        || !llvm::StringRef::compare_insensitive(v15, "inf", 3uLL))
      {
        if ((_UNKNOWN *)a2 == &unk_1CFB2E344) {
          llvm::detail::DoubleAPFloat::DoubleAPFloat(&v23, (uint64_t)&unk_1CFB2E344);
        }
        llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&v23, a2);
        sub_1CB87E790((uint64_t)&v22, 0);
        sub_1CB9190C0(&v18, (void **)&v23);
        unsigned int v14 = v23;
        if (v23 == (_DWORD *)&unk_1CFB2E344) {
          goto LABEL_49;
        }
LABEL_27:
        if ((v14[2] - 64) <= 0xFFFFFF7F && v24) {
          MEMORY[0x1D25D9CB0](v24, 0x1000C8000313F17);
        }
        goto LABEL_11;
      }
      if (llvm::StringRef::compare_insensitive(v15, "nan", 3uLL)) {
        goto LABEL_32;
      }
      sub_1CC56781C(a2, 0, (unsigned char *)0xFFFFFFFFFFFFFFFFLL, (uint64_t)&v22);
      sub_1CB9190C0(&v18, (void **)&v23);
      unsigned int v14 = v23;
      if (v23 != (_DWORD *)&unk_1CFB2E344) {
        goto LABEL_27;
      }
LABEL_49:
      sub_1CB845718(&v24);
LABEL_11:
      if (v6 == 13)
      {
        if ((_UNKNOWN *)v18 == &unk_1CFB2E344)
        {
          sub_1CBFC6FB8(v19);
          sub_1CBFC6FB8(v19 + 32);
        }
        else
        {
          v21 ^= 8u;
        }
      }
      (*((void (**)(_DWORD **))*a1 + 23))(a1);
      if ((_UNKNOWN *)v18 == &unk_1CFB2E344) {
        llvm::detail::DoubleAPFloat::bitcastToAPInt((llvm::detail::DoubleAPFloat *)&v18, (llvm::APInt *)&v22);
      }
      else {
        llvm::detail::IEEEFloat::bitcastToAPInt((uint64_t)&v18, (uint64_t)&v22);
      }
      if (*(_DWORD *)(a3 + 8) >= 0x41u && *(void *)a3) {
        MEMORY[0x1D25D9CB0](*(void *)a3, 0x1000C8000313F17);
      }
      uint64_t v12 = 0;
      *(void *)a3 = v22;
      *(_DWORD *)(a3 + 8) = v23;
LABEL_20:
      if ((_UNKNOWN *)v18 == &unk_1CFB2E344)
      {
        sub_1CB845718(&v19);
      }
      else if ((*(_DWORD *)(v18 + 8) - 64) <= 0xFFFFFF7F && v19)
      {
        MEMORY[0x1D25D9CB0](v19, 0x1000C8000313F17);
      }
      return v12;
    default:
      unint64_t v22 = "unexpected token in directive";
      __int16 v25 = 259;
      return llvm::MCAsmParser::TokError((uint64_t)a1, (uint64_t)&v22, 0, 0);
  }
}

uint64_t sub_1CD37FBD0(uint64_t a1)
{
  uint64_t v2 = *(void *)a1;
  uint64_t v12 = 0;
  __int16 v13 = 0;
  uint64_t v3 = *(void *)(*(void *)((*(uint64_t (**)(uint64_t))(*(void *)v2 + 40))(v2) + 8) + 8);
  if ((*(unsigned int (**)(uint64_t, unsigned __int8 ***))(*(void *)v2 + 192))(v2, &v12))
  {
    uint64_t v9 = "expected identifier";
    goto LABEL_10;
  }
  if (((*(uint64_t (**)(uint64_t, unsigned __int8 **, unsigned __int8 **))(*(void *)v2 + 104))(v2, v12, v13) & 1) == 0)
  {
    unsigned int v4 = (llvm::MCContext *)(*(uint64_t (**)(uint64_t))(*(void *)v2 + 48))(v2);
    __int16 v11 = 261;
    v10[0] = v12;
    v10[1] = v13;
    uint64_t Symbol = llvm::MCContext::getOrCreateSymbol(v4, v10);
    if (*(unsigned char *)(Symbol + 8))
    {
      uint64_t v9 = "non-local symbol required";
    }
    else
    {
      uint64_t v6 = Symbol;
      uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 56))(v2);
      if ((*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v7 + 304))(v7, v6, **(unsigned int **)(a1 + 8)))return 0; {
      uint64_t v9 = "unable to emit symbol attribute";
      }
    }
LABEL_10:
    v10[0] = (unsigned __int8 **)v9;
    __int16 v11 = 259;
    return llvm::MCAsmParser::Error(v2, v3, (uint64_t)v10, 0, 0);
  }
  return 0;
}

unint64_t sub_1CD37FD94(uint64_t a1, uint64_t a2)
{
  *((void *)&v58 + 1) = 0;
  uint64_t v59 = 0;
  unsigned int v61 = 1;
  int __dst = 0;
  uint64_t v4 = *(void *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 8);
  uint64_t v52 = *(void *)(v4 + 8);
  if (*(_DWORD *)(v4 + 32) > 0x40u) {
    operator new[]();
  }
  if (**(_DWORD **)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 8))
  {
    int v5 = 0;
    do
    {
      if (**(_DWORD **)(a1 + 48) == 2)
      {
        uint64_t v6 = *(void *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 8);
        if (*(_DWORD *)v6 == 2)
        {
          uint64_t v7 = *(_DWORD **)(v6 + 8);
          unint64_t v8 = *(void *)(v6 + 16);
        }
        else
        {
          uint64_t v7 = *(_DWORD **)(v6 + 8);
          unint64_t v9 = *(void *)(v6 + 16);
          unint64_t v10 = v9 - 1;
          unint64_t v11 = v9 != 0;
          if (v9) {
            uint64_t v7 = (_DWORD *)((char *)v7 + 1);
          }
          if (v11 > v10) {
            unint64_t v10 = v9 != 0;
          }
          if (v9 < v10) {
            unint64_t v10 = v9;
          }
          unint64_t v8 = v10 - v11;
        }
        if (v8 == 4 && *v7 == 1885696558) {
          goto LABEL_57;
        }
        uint64_t v12 = *(void *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 8);
        if (*(_DWORD *)v12 == 2)
        {
          __int16 v13 = *(int **)(v12 + 8);
          unint64_t v14 = *(void *)(v12 + 16);
        }
        else
        {
          __int16 v13 = *(int **)(v12 + 8);
          unint64_t v15 = *(void *)(v12 + 16);
          unint64_t v16 = v15 - 1;
          unint64_t v17 = v15 != 0;
          if (v15) {
            __int16 v13 = (int *)((char *)v13 + 1);
          }
          if (v17 > v16) {
            unint64_t v16 = v15 != 0;
          }
          if (v15 < v16) {
            unint64_t v16 = v15;
          }
          unint64_t v14 = v16 - v17;
        }
        if (v14 == 5)
        {
          int v18 = *v13;
          int v19 = *((unsigned __int8 *)v13 + 4);
          if (v18 == 1885696558 && v19 == 116) {
            goto LABEL_57;
          }
        }
        uint64_t v21 = *(void *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 8);
        if (*(_DWORD *)v21 == 2)
        {
          unint64_t v22 = *(_DWORD **)(v21 + 8);
          unint64_t v23 = *(void *)(v21 + 16);
        }
        else
        {
          unint64_t v22 = *(_DWORD **)(v21 + 8);
          unint64_t v24 = *(void *)(v21 + 16);
          unint64_t v25 = v24 - 1;
          unint64_t v26 = v24 != 0;
          if (v24) {
            unint64_t v22 = (_DWORD *)((char *)v22 + 1);
          }
          if (v26 > v25) {
            unint64_t v25 = v24 != 0;
          }
          if (v24 < v25) {
            unint64_t v25 = v24;
          }
          unint64_t v23 = v25 - v26;
        }
        if (v23 == 4 && *v22 == 1886546222) {
          goto LABEL_57;
        }
        uint64_t v27 = *(void *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 8);
        if (*(_DWORD *)v27 == 2)
        {
          uint64_t v28 = *(int **)(v27 + 8);
          unint64_t v29 = *(void *)(v27 + 16);
        }
        else
        {
          uint64_t v28 = *(int **)(v27 + 8);
          unint64_t v30 = *(void *)(v27 + 16);
          unint64_t v31 = v30 - 1;
          unint64_t v32 = v30 != 0;
          if (v30) {
            uint64_t v28 = (int *)((char *)v28 + 1);
          }
          if (v32 > v31) {
            unint64_t v31 = v30 != 0;
          }
          if (v30 < v31) {
            unint64_t v31 = v30;
          }
          unint64_t v29 = v31 - v32;
        }
        if (v29 == 5)
        {
          int v33 = *v28;
          int v34 = *((unsigned __int8 *)v28 + 4);
          if (v33 == 1886546222 && v34 == 99) {
LABEL_57:
          }
            ++v5;
        }
      }
      if (**(_DWORD **)(a1 + 48) == 2)
      {
        uint64_t v36 = *(void *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 8);
        if (*(_DWORD *)v36 == 2)
        {
          unint64_t v37 = *(int **)(v36 + 8);
          unint64_t v38 = *(void *)(v36 + 16);
        }
        else
        {
          unint64_t v37 = *(int **)(v36 + 8);
          unint64_t v39 = *(void *)(v36 + 16);
          unint64_t v40 = v39 - 1;
          unint64_t v41 = v39 != 0;
          if (v39) {
            unint64_t v37 = (int *)((char *)v37 + 1);
          }
          if (v41 > v40) {
            unint64_t v40 = v39 != 0;
          }
          if (v39 < v40) {
            unint64_t v40 = v39;
          }
          unint64_t v38 = v40 - v41;
        }
        if (v38 == 5)
        {
          int v42 = *v37;
          int v43 = *((unsigned __int8 *)v37 + 4);
          if (v42 == 1684956462 && v43 == 114)
          {
            if (!v5)
            {
              char v49 = *(long long **)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 8);
              long long v58 = *v49;
              uint64_t v59 = *((void *)v49 + 2);
              unsigned int v47 = *((_DWORD *)v49 + 8);
              if (v47 > 0x40)
              {
                llvm::APInt::reallocate((uint64_t)&__dst, *((_DWORD *)v49 + 8));
                unsigned int v47 = v61;
                if (v61 <= 0x40)
                {
                  unint64_t v45 = (void *)*((void *)v49 + 3);
                  int __dst = v45;
                }
                else
                {
                  unint64_t v45 = __dst;
                  memcpy(__dst, *((const void **)v49 + 3), (((unint64_t)v61 + 63) >> 3) & 0x3FFFFFF8);
                }
              }
              else
              {
                unint64_t v45 = (void *)*((void *)v49 + 3);
                int __dst = v45;
                unsigned int v61 = v47;
              }
              (*(void (**)(uint64_t))(*(void *)a1 + 184))(a1);
              if (**(_DWORD **)(a1 + 48) == 9)
              {
                *(void *)&long long v54 = v52;
                *((void *)&v54 + 1) = *((void *)&v58 + 1) - v52;
                long long v53 = 0uLL;
                long long v55 = 0uLL;
                uint64_t v56 = 0;
                sub_1CD8F3FF0((void *)(a1 + 376), &v53, &v54, &v55);
                std::string::size_type v62 = (void **)&v55;
                sub_1CCBB91F0(&v62);
                unint64_t v51 = *(void *)(a1 + 416) + *(void *)(a1 + 408) - 1;
                unint64_t v46 = *(void *)(*(void *)(a1 + 384) + 8 * (v51 / 0x2E)) + 88 * (v51 % 0x2E);
              }
              else
              {
                uint64_t v50 = *(void *)(*(void *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 8) + 8);
                *(void *)&long long v55 = "unexpected token in '.endr' directive";
                __int16 v57 = 259;
                (*(void (**)(uint64_t, uint64_t, long long *, void, void))(*(void *)a1 + 176))(a1, v50, &v55, 0, 0);
                unint64_t v46 = 0;
              }
              goto LABEL_78;
            }
            --v5;
          }
        }
      }
      (*(void (**)(uint64_t))(*(void *)a1 + 224))(a1);
    }
    while (**(_DWORD **)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 8));
  }
  *(void *)&long long v55 = "no matching '.endr' in definition";
  __int16 v57 = 259;
  (*(void (**)(uint64_t, uint64_t, long long *, void, void))(*(void *)a1 + 176))(a1, a2, &v55, 0, 0);
  unint64_t v45 = 0;
  unint64_t v46 = 0;
  unsigned int v47 = 1;
LABEL_78:
  if (v47 >= 0x41 && v45) {
    MEMORY[0x1D25D9CB0](v45, 0x1000C8000313F17);
  }
  return v46;
}

void sub_1CD380440(int a1, int a2, llvm::raw_ostream *this)
{
  void v10[3] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *((void *)this + 4);
  if ((unint64_t)(*((void *)this + 3) - v4) > 5)
  {
    *(_WORD *)(v4 + 4) = 2674;
    *(_DWORD *)uint64_t v4 = 1684956462;
    *((void *)this + 4) += 6;
  }
  else
  {
    llvm::raw_ostream::write(this, ".endr\n", 6uLL);
  }
  uint64_t v5 = *((void *)this + 8);
  uint64_t v6 = *(const void **)v5;
  uint64_t v7 = *(llvm::WritableMemoryBuffer **)(v5 + 8);
  unint64_t v8 = (const void **)"<instantiation>";
  __int16 v9 = 259;
  sub_1CD0963EC(v7, v6, &v8, (uint64_t)v10);
  operator new();
}

__n128 sub_1CD380700(uint64_t a1, uint64_t a2, long long *a3, long long *a4, long long *a5)
{
  uint64_t v5 = *((void *)a5 + 2);
  long long v6 = *a5;
  long long v7 = *a3;
  long long v8 = *a4;
  *(void *)a5 = 0;
  *((void *)a5 + 1) = 0;
  *((void *)a5 + 2) = 0;
  *(_OWORD *)a2 = v7;
  *(_OWORD *)(a2 + 16) = v8;
  *(_OWORD *)(a2 + 32) = v6;
  memset(v10, 0, sizeof(v10));
  *(void *)(a2 + 48) = v5;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 72) = 0;
  *(unsigned char *)(a2 + 80) = 0;
  unint64_t v11 = (void **)v10;
  sub_1CCBB91F0(&v11);
  return result;
}

uint64_t sub_1CD380760(void *a1)
{
  sub_1CD37E0E4((uint64_t)a1, *(void *)(*(void *)(a1[45] - 8) + 16), *(_DWORD *)(*(void *)(a1[45] - 8) + 8));
  (*(void (**)(void *))(*a1 + 184))(a1);
  uint64_t v2 = a1[45];
  uint64_t result = *(void *)(v2 - 8);
  if (result)
  {
    uint64_t result = MEMORY[0x1D25D9CE0](result, 0x1050C4073F788CFLL);
    uint64_t v2 = a1[45];
  }
  a1[45] = v2 - 8;
  return result;
}

uint64_t sub_1CD3807E8(uint64_t *a1)
{
  uint64_t v2 = *a1;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)v2 + 232))(v2, &v7, &v8);
  if ((v3 & 1) == 0)
  {
    int v4 = *(unsigned __int8 *)a1[1];
    uint64_t v5 = *(void *)(*(uint64_t (**)(uint64_t))(*(void *)v2 + 56))(v2);
    if (v4) {
      (*(void (**)(void))(v5 + 560))();
    }
    else {
      (*(void (**)(void))(v5 + 552))();
    }
  }
  return v3;
}

uint64_t sub_1CD3808E4(uint64_t a1)
{
  uint64_t v2 = *(void *)a1;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t v3 = *(void *)(*(void *)((*(uint64_t (**)(uint64_t))(*(void *)v2 + 40))(v2) + 8) + 8);
  if ((*(unsigned int (**)(uint64_t, uint64_t *))(*(void *)v2 + 192))(v2, &v19))
  {
    v17[0] = "unexpected token in '.loc' directive";
    __int16 v18 = 259;
    return llvm::MCAsmParser::TokError(v2, (uint64_t)v17, 0, 0);
  }
  switch(v20)
  {
    case 3:
      if (*(_WORD *)v19 != 29545 || *(unsigned char *)(v19 + 2) != 97) {
        goto LABEL_50;
      }
      uint64_t v3 = *(void *)(*(void *)((*(uint64_t (**)(uint64_t))(*(void *)v2 + 40))(v2) + 8) + 8);
      uint64_t v16 = 0;
      v17[0] = 0;
      if ((*(uint64_t (**)(uint64_t, uint64_t *, void *))(*(void *)v2 + 232))(v2, &v16, v17)) {
        return 1;
      }
      if (*(unsigned char *)v16 == 1)
      {
        int v5 = *(_DWORD *)(v16 + 16);
        if ((v5 & 0x80000000) == 0)
        {
          **(_DWORD **)(a1 + 16) = v5;
          return 0;
        }
        unint64_t v15 = "isa number less than zero";
      }
      else
      {
        unint64_t v15 = "isa number not a constant value";
      }
      goto LABEL_51;
    case 7:
      if (*(_DWORD *)v19 != 1935635305 || *(_DWORD *)(v19 + 3) != 1953330291) {
        goto LABEL_50;
      }
      uint64_t v3 = *(void *)(*(void *)((*(uint64_t (**)(uint64_t))(*(void *)v2 + 40))(v2) + 8) + 8);
      uint64_t v16 = 0;
      v17[0] = 0;
      if ((*(uint64_t (**)(uint64_t, uint64_t *, void *))(*(void *)v2 + 232))(v2, &v16, v17)) {
        return 1;
      }
      if (*(unsigned char *)v16 != 1)
      {
        unint64_t v15 = "is_stmt value not the constant value of 0 or 1";
        goto LABEL_51;
      }
      int v7 = *(_DWORD *)(v16 + 16);
      if (v7 != 1)
      {
        if (!v7)
        {
          uint64_t v8 = *(unsigned int **)(a1 + 8);
          unsigned int v9 = *v8 & 0xFFFFFFFE;
          goto LABEL_47;
        }
        unint64_t v15 = "is_stmt value not 0 or 1";
LABEL_51:
        v17[0] = v15;
        __int16 v18 = 259;
        return llvm::MCAsmParser::Error(v2, v3, (uint64_t)v17, 0, 0);
      }
      uint64_t v8 = *(unsigned int **)(a1 + 8);
      unsigned int v9 = *v8 | 1;
LABEL_47:
      *uint64_t v8 = v9;
      return 0;
    case 11:
      if (*(void *)v19 != 0x6C625F6369736162 || *(void *)(v19 + 3) != 0x6B636F6C625F6369) {
        goto LABEL_50;
      }
      uint64_t v8 = *(unsigned int **)(a1 + 8);
      unsigned int v9 = *v8 | 2;
      goto LABEL_47;
    case 12:
      if (*(void *)v19 != 0x6575676F6C6F7270 || *(_DWORD *)(v19 + 8) != 1684956511) {
        goto LABEL_50;
      }
      uint64_t v8 = *(unsigned int **)(a1 + 8);
      unsigned int v9 = *v8 | 4;
      goto LABEL_47;
    case 13:
      if (*(void *)v19 != 0x696D697263736964 || *(void *)(v19 + 5) != 0x726F74616E696D69) {
        goto LABEL_50;
      }
      return ((*(uint64_t (**)(uint64_t, void))(*(void *)v2 + 256))(v2, *(void *)(a1 + 24)) & 1) != 0;
    case 14:
      if (*(void *)v19 != 0x6575676F6C697065 || *(void *)(v19 + 6) != 0x6E696765625F6575) {
        goto LABEL_50;
      }
      uint64_t v8 = *(unsigned int **)(a1 + 8);
      unsigned int v9 = *v8 | 8;
      goto LABEL_47;
    default:
LABEL_50:
      unint64_t v15 = "unknown sub-directive in '.loc' directive";
      goto LABEL_51;
  }
}

uint64_t sub_1CD380D30(llvm::MCAsmParser *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(*(void *)((*(uint64_t (**)(llvm::MCAsmParser *))(*(void *)a1 + 40))(a1) + 8) + 8);
  __int16 v14 = 1283;
  v13[0] = "expected function id in '";
  unint64_t v13[2] = a3;
  void v13[3] = a4;
  v15[0] = v13;
  void v15[2] = "' directive";
  __int16 v16 = 770;
  if (llvm::MCAsmParser::parseIntToken(a1, a2, (const llvm::Twine *)v15)) {
    return 1;
  }
  unint64_t v10 = *a2;
  unint64_t v11 = "expected function id within range [0, UINT_MAX)";
  __int16 v12 = 259;
  if (v10 >= 0xFFFFFFFF)
  {
    llvm::MCAsmParser::Error((uint64_t)a1, v8, (uint64_t)&v11, 0, 0);
    return 1;
  }
  return 0;
}

uint64_t sub_1CD380E34(llvm::MCContext **a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(*(void *)((*((uint64_t (**)(llvm::MCContext **))*a1 + 5))(a1) + 8) + 8);
  __int16 v24 = 1283;
  v23[0] = "expected integer in '";
  v23[2] = a3;
  v23[3] = a4;
  v25[0] = v23;
  v25[2] = "' directive";
  __int16 v26 = 770;
  if (!llvm::MCAsmParser::parseIntToken((llvm::MCAsmParser *)a1, a2, (const llvm::Twine *)v25))
  {
    uint64_t v10 = *a2;
    __int16 v20 = 1283;
    v19[0] = "file number less than one in '";
    v19[2] = a3;
    v19[3] = a4;
    v21[0] = v19;
    v21[2] = "' directive";
    __int16 v22 = 770;
    if (v10 >= 1)
    {
      uint64_t CVContext = llvm::MCContext::getCVContext(a1[27]);
      uint64_t v13 = (*(_DWORD *)a2 - 1);
      BOOL v14 = *(_DWORD *)(CVContext + 56) <= v13
         || *(unsigned __int8 *)(*(void *)(CVContext + 48) + 32 * v13 + 4) == 0;
      __int16 v16 = 1283;
      v15[0] = "unassigned file number in '";
      void v15[2] = a3;
      v15[3] = a4;
      v17[0] = v15;
      v17[2] = "' directive";
      __int16 v18 = 770;
      if (!v14) {
        return 0;
      }
      unint64_t v11 = v17;
    }
    else
    {
      unint64_t v11 = v21;
    }
    llvm::MCAsmParser::Error((uint64_t)a1, v8, (uint64_t)v11, 0, 0);
  }
  return 1;
}

uint64_t sub_1CD380FC4(uint64_t a1)
{
  uint64_t v2 = *(void *)a1;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t v3 = *(void *)(*(void *)((*(uint64_t (**)(uint64_t))(*(void *)v2 + 40))(v2) + 8) + 8);
  if ((*(unsigned int (**)(uint64_t, _DWORD **))(*(void *)v2 + 192))(v2, &v13))
  {
    v11[0] = "unexpected token in '.cv_loc' directive";
    __int16 v12 = 259;
    return llvm::MCAsmParser::TokError(v2, (uint64_t)v11, 0, 0);
  }
  if (v14 == 7)
  {
    if (*v13 == 1935635305 && *(_DWORD *)((char *)v13 + 3) == 1953330291)
    {
      uint64_t v3 = *(void *)(*(void *)((*(uint64_t (**)(uint64_t))(*(void *)v2 + 40))(v2) + 8) + 8);
      uint64_t v10 = 0;
      v11[0] = 0;
      if ((*(uint64_t (**)(uint64_t, uint64_t *, void *))(*(void *)v2 + 232))(v2, &v10, v11)) {
        return 1;
      }
      int v7 = *(unint64_t **)(a1 + 16);
      *int v7 = -1;
      if (*(unsigned char *)v10 == 1)
      {
        unint64_t v8 = *(void *)(v10 + 16);
        *int v7 = v8;
        if (v8 < 2) {
          return 0;
        }
      }
      unsigned int v9 = "is_stmt value not 0 or 1";
      goto LABEL_23;
    }
  }
  else if (v14 == 12 && *(void *)v13 == 0x6575676F6C6F7270 && v13[2] == 1684956511)
  {
    uint64_t result = 0;
    **(unsigned char **)(a1 + 8) = 1;
    return result;
  }
  unsigned int v9 = "unknown sub-directive in '.cv_loc' directive";
LABEL_23:
  v11[0] = v9;
  __int16 v12 = 259;
  return llvm::MCAsmParser::Error(v2, v3, (uint64_t)v11, 0, 0);
}

uint64_t sub_1CD3811E4(void **a1, void *a2, uint64_t a3)
{
  uint64_t v10 = a3;
  unsigned int v9 = 0;
  if (**(_DWORD **)(((uint64_t (*)(void **))(*a1)[5])(a1) + 8) == 4)
  {
    int v5 = (uint64_t (*)(void **, void *))(*a1)[32];
    return v5(a1, a2);
  }
  else if ((*(uint64_t (**)(void *, unsigned int *, uint64_t *, uint64_t *))(*a1[1] + 32))(a1[1], &v9, &v10, &v10))
  {
    return 1;
  }
  else
  {
    uint64_t v7 = ((uint64_t (*)(void **))(*a1)[6])(a1);
    int DwarfRegNum = llvm::MCRegisterInfo::getDwarfRegNum(*(void *)(v7 + 160), v9, 1);
    uint64_t result = 0;
    *a2 = DwarfRegNum;
  }
  return result;
}

uint64_t sub_1CD381324(uint64_t *a1, uint64_t a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 4);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0x555555555555555) {
    abort();
  }
  if (0x5555555555555556 * ((a1[2] - *a1) >> 4) > v3) {
    unint64_t v3 = 0x5555555555555556 * ((a1[2] - *a1) >> 4);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v5 = 0x555555555555555;
  }
  else {
    unint64_t v5 = v3;
  }
  uint64_t v19 = a1 + 2;
  if (v5 > 0x555555555555555) {
    sub_1CB833614();
  }
  uint64_t v7 = 3 * v5;
  unint64_t v8 = (char *)operator new(48 * v5);
  unsigned int v9 = &v8[48 * v2];
  long long __p = v8;
  __int16 v16 = v9;
  long long v10 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)unsigned int v9 = *(_OWORD *)a2;
  *((_OWORD *)v9 + 1) = v10;
  *((void *)v9 + 4) = *(void *)(a2 + 32);
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *((_WORD *)v9 + 20) = *(_WORD *)(a2 + 40);
  unint64_t v17 = v9 + 48;
  __int16 v18 = &v8[16 * v7];
  sub_1CD8F4400(a1, &__p);
  uint64_t v11 = a1[1];
  __int16 v12 = v16;
  while (1)
  {
    uint64_t v13 = v17;
    if (v17 == v12) {
      break;
    }
    v17 -= 48;
    __int16 v20 = (void **)(v13 - 32);
    sub_1CCBB926C(&v20);
  }
  if (__p) {
    operator delete(__p);
  }
  return v11;
}

uint64_t sub_1CD381458(uint64_t a1, unsigned __int8 *__s1, size_t __n)
{
  uint64_t v3 = *(unsigned int *)(a1 + 8);
  if (!v3) {
    return 0;
  }
  int v7 = 0;
  if (__n)
  {
    size_t v8 = __n;
    unsigned int v9 = __s1;
    do
    {
      int v10 = *v9++;
      int v7 = 33 * v7 + v10;
      --v8;
    }
    while (v8);
  }
  uint64_t v11 = *(void *)a1;
  uint64_t v12 = *(void *)a1 + 8 * v3 + 8;
  int v13 = 1;
  int v14 = v7;
  while (1)
  {
    uint64_t v15 = v14 & (v3 - 1);
    __int16 v16 = *(void **)(v11 + 8 * v15);
    if (v16 != (void *)-8)
    {
      if (!v16) {
        return 0;
      }
      if (*(_DWORD *)(v12 + 4 * v15) == v7
        && __n == *v16
        && (!__n || !memcmp(__s1, (char *)v16 + *(unsigned int *)(a1 + 20), __n)))
      {
        break;
      }
    }
    int v14 = v13 + v15;
    ++v13;
  }
  if (v15 == -1 || (int)v15 == v3) {
    return 0;
  }
  sub_1CD8F4624((uint64_t *)a1, (size_t **)(v11 + 8 * (int)v15));
  return 1;
}

uint64_t sub_1CD381564(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v6 = 0uLL;
  uint64_t v2 = *(void *)(*(void *)((*(uint64_t (**)(uint64_t))(*(void *)v1 + 40))(v1) + 8) + 8);
  if ((*(unsigned int (**)(uint64_t, long long *))(*(void *)v1 + 192))(v1, &v6))
  {
    int v4 = "expected identifier";
    __int16 v5 = 259;
    return llvm::MCAsmParser::Error(v1, v2, (uint64_t)&v4, 0, 0);
  }
  else
  {
    sub_1CD69BAC0(v1 + 728, &v6);
    return 0;
  }
}

char **sub_1CD381630(char **a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 8 * v3;
    __int16 v5 = v2 - 8;
    do
    {
      uint64_t v6 = *(void *)&v5[v4];
      *(void *)&v5[v4] = 0;
      if (v6) {
        (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
      }
      v4 -= 8;
    }
    while (v4);
    uint64_t v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

uint64_t sub_1CD3816BC(unsigned int *a1, unsigned int *a2)
{
  unint64_t v2 = *((void *)a1 + 1);
  unint64_t v3 = *((void *)a2 + 1);
  if (v2 < v3) {
    return 0xFFFFFFFFLL;
  }
  if (v3 < v2) {
    return 1;
  }
  if (byte_1CFB33B72[*a1] > byte_1CFB33B72[*a2]) {
    return 0xFFFFFFFFLL;
  }
  return 1;
}

uint64_t sub_1CD38170C(uint64_t result)
{
  uint64_t v2 = *(void *)(result + 352);
  uint64_t v1 = *(void *)(result + 360);
  if (v1 != v2)
  {
    uint64_t v3 = result;
    do
    {
      uint64_t v4 = *(char ***)(v1 - 8);
      v1 -= 8;
      __int16 v5 = *v4;
      uint64_t v6 = "while in macro instantiation";
      __int16 v7 = 259;
      v8[0] = 0;
      v8[1] = 0;
      uint64_t result = llvm::SourceMgr::PrintMessage(*(llvm **)(v3 + 240), v5, 3, (llvm::Twine *)&v6, v8, 1, 0, 0, 1u);
    }
    while (v1 != v2);
  }
  return result;
}

uint64_t sub_1CD3817A0(uint64_t a1, unsigned int a2, unint64_t *a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a1 + 136);
  int v24 = 0;
  unsigned int v9 = sub_1CD381ECC(*(void *)(a1 + 232), *(unsigned char *)(a1 + 804), **(_DWORD **)(a1 + 48), &v24);
  if (v9 < a2) {
    return 0;
  }
  unsigned int v11 = v9;
  while (1)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 184))(a1);
    uint64_t v23 = 0;
    if ((*(unsigned int (**)(void, uint64_t *, uint64_t))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8), &v23, a4)|| v11 < sub_1CD381ECC(*(void *)(a1 + 232), *(unsigned char *)(a1 + 804), **(_DWORD **)(a1 + 48), &v22)&& sub_1CD3817A0(a1, v11 + 1, &v23, a4))
    {
      break;
    }
    int v12 = v24;
    unint64_t v13 = *a3;
    uint64_t v14 = v23;
    uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 48))(a1);
    uint64_t v16 = v15;
    *(void *)(v15 + 272) += 32;
    uint64_t v17 = *(void *)(v15 + 192);
    if (((v17 + 7) & 0xFFFFFFFFFFFFFFF8) - v17 + 32 > *(void *)(v15 + 200) - v17)
    {
      unsigned int v19 = *(_DWORD *)(v15 + 216) >> 7;
      if (v19 >= 0x1E) {
        LOBYTE(v19) = 30;
      }
      uint64_t v21 = 4096 << v19;
      unint64_t v18 = (unint64_t)operator new(4096 << v19, (std::align_val_t)8uLL);
      unint64_t v20 = *(unsigned int *)(v16 + 216);
      if (v20 >= *(unsigned int *)(v16 + 220)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(v16 + 208) + 8 * v20) = v18;
      ++*(_DWORD *)(v16 + 216);
      *(void *)(v16 + 200) = v18 + v21;
    }
    else
    {
      unint64_t v18 = (v17 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    *(void *)(v16 + 192) = v18 + 32;
    *(unsigned char *)unint64_t v18 = 0;
    *(_DWORD *)(v18 + 1) = v12 & 0xFFFFFF | (*(unsigned __int8 *)(v18 + 4) << 24);
    *(void *)(v18 + 8) = v8;
    *(void *)(v18 + 16) = v13;
    *(void *)(v18 + 24) = v14;
    *a3 = v18;
    int v24 = 0;
    unsigned int v11 = sub_1CD381ECC(*(void *)(a1 + 232), *(unsigned char *)(a1 + 804), **(_DWORD **)(a1 + 48), &v24);
    if (v11 < a2) {
      return 0;
    }
  }
  return 1;
}

uint64_t sub_1CD3819F4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, void))(**(void **)(a1 + 8) + 152))(*(void *)(a1 + 8), a2, a3, *(void *)(a1 + 216));
  if (!result)
  {
    switch(*(unsigned char *)a2)
    {
      case 1:
      case 4:
        return result;
      case 2:
        if (*(_WORD *)(a2 + 1))
        {
          uint64_t v24 = *(void *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) + 8);
          if (*(_DWORD *)v24 == 2)
          {
            uint64_t v25 = *(void *)(v24 + 8);
            unint64_t v26 = *(void *)(v24 + 16);
          }
          else
          {
            uint64_t v25 = *(void *)(v24 + 8);
            unint64_t v27 = *(void *)(v24 + 16);
            unint64_t v28 = v27 - 1;
            unint64_t v29 = v27 != 0;
            if (v27) {
              ++v25;
            }
            if (v29 > v28) {
              unint64_t v28 = v27 != 0;
            }
            if (v27 < v28) {
              unint64_t v28 = v27;
            }
            unint64_t v26 = v28 - v29;
          }
          __int16 v40 = 1283;
          v39[0] = "invalid variant on expression '";
          v39[2] = v25;
          v39[3] = v26;
          v41[0] = v39;
          uint64_t v41[2] = "' (already modified)";
          __int16 v42 = 770;
          llvm::MCAsmParser::TokError(a1, (uint64_t)v41, 0, 0);
          uint64_t result = a2;
        }
        else
        {
          uint64_t v14 = *(void *)(a2 + 16);
          uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 48))(a1);
          uint64_t v16 = v15;
          *(void *)(v15 + 272) += 24;
          uint64_t v17 = *(void *)(v15 + 192);
          if (((v17 + 7) & 0xFFFFFFFFFFFFFFF8) - v17 + 24 > *(void *)(v15 + 200) - v17)
          {
            unsigned int v30 = *(_DWORD *)(v15 + 216) >> 7;
            if (v30 >= 0x1E) {
              LOBYTE(v30) = 30;
            }
            uint64_t v31 = 4096 << v30;
            uint64_t result = (uint64_t)operator new(4096 << v30, (std::align_val_t)8uLL);
            unsigned int v32 = *(_DWORD *)(v16 + 216);
            if (v32 >= *(_DWORD *)(v16 + 220)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(*(void *)(v16 + 208) + 8 * v32) = result;
            ++*(_DWORD *)(v16 + 216);
            *(void *)(v16 + 200) = result + v31;
          }
          else
          {
            uint64_t result = (v17 + 7) & 0xFFFFFFFFFFFFFFF8;
          }
          *(void *)(v16 + 192) = result + 24;
          int v18 = a3 | (*(unsigned __int8 *)(*(void *)(v16 + 152) + 18) << 16);
          *(unsigned char *)uint64_t result = 2;
          *(_DWORD *)(result + 1) = v18 | (*(unsigned __int8 *)(result + 4) << 24);
          *(void *)(result + 8) = 0;
          *(void *)(result + 16) = v14;
        }
        break;
      case 3:
        uint64_t result = sub_1CD3819F4(a1, *(void *)(a2 + 16), a3);
        if (result)
        {
          uint64_t v19 = result;
          int v20 = *(_DWORD *)(a2 + 1) & 0xFFFFFF;
          uint64_t v21 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 48))(a1);
          uint64_t v22 = v21;
          *(void *)(v21 + 272) += 24;
          uint64_t v23 = *(void *)(v21 + 192);
          if (((v23 + 7) & 0xFFFFFFFFFFFFFFF8) - v23 + 24 > *(void *)(v21 + 200) - v23)
          {
            unsigned int v33 = *(_DWORD *)(v21 + 216) >> 7;
            if (v33 >= 0x1E) {
              LOBYTE(v33) = 30;
            }
            uint64_t v34 = 4096 << v33;
            uint64_t result = (uint64_t)operator new(4096 << v33, (std::align_val_t)8uLL);
            unsigned int v35 = *(_DWORD *)(v22 + 216);
            if (v35 >= *(_DWORD *)(v22 + 220)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(*(void *)(v22 + 208) + 8 * v35) = result;
            ++*(_DWORD *)(v22 + 216);
            *(void *)(v22 + 200) = result + v34;
          }
          else
          {
            uint64_t result = (v23 + 7) & 0xFFFFFFFFFFFFFFF8;
          }
          *(void *)(v22 + 192) = result + 24;
          *(unsigned char *)uint64_t result = 3;
          *(_DWORD *)(result + 1) = v20 | (*(unsigned __int8 *)(result + 4) << 24);
          *(void *)(result + 8) = 0;
          *(void *)(result + 16) = v19;
        }
        break;
      default:
        uint64_t v7 = sub_1CD3819F4(a1, *(void *)(a2 + 16), a3);
        uint64_t v8 = sub_1CD3819F4(a1, *(void *)(a2 + 24), a3);
        if (v7 | v8)
        {
          uint64_t v9 = v8;
          if (!v7) {
            uint64_t v7 = *(void *)(a2 + 16);
          }
          if (!v8) {
            uint64_t v9 = *(void *)(a2 + 24);
          }
          int v10 = *(_DWORD *)(a2 + 1) & 0xFFFFFF;
          uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 48))(a1);
          uint64_t v12 = v11;
          *(void *)(v11 + 272) += 32;
          uint64_t v13 = *(void *)(v11 + 192);
          if (((v13 + 7) & 0xFFFFFFFFFFFFFFF8) - v13 + 32 > *(void *)(v11 + 200) - v13)
          {
            unsigned int v36 = *(_DWORD *)(v11 + 216) >> 7;
            if (v36 >= 0x1E) {
              LOBYTE(v36) = 30;
            }
            uint64_t v37 = 4096 << v36;
            uint64_t result = (uint64_t)operator new(4096 << v36, (std::align_val_t)8uLL);
            unsigned int v38 = *(_DWORD *)(v12 + 216);
            if (v38 >= *(_DWORD *)(v12 + 220)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(*(void *)(v12 + 208) + 8 * v38) = result;
            ++*(_DWORD *)(v12 + 216);
            *(void *)(v12 + 200) = result + v37;
          }
          else
          {
            uint64_t result = (v13 + 7) & 0xFFFFFFFFFFFFFFF8;
          }
          *(void *)(v12 + 192) = result + 32;
          *(unsigned char *)uint64_t result = 0;
          *(_DWORD *)(result + 1) = v10 | (*(unsigned __int8 *)(result + 4) << 24);
          *(void *)(result + 8) = 0;
          *(void *)(result + 16) = v7;
          *(void *)(result + 24) = v9;
        }
        else
        {
          uint64_t result = 0;
        }
        break;
    }
  }
  return result;
}

uint64_t sub_1CD381ECC(uint64_t a1, char a2, int a3, int *a4)
{
  int v4 = *(unsigned __int8 *)(a1 + 472);
  if (a2)
  {
    uint64_t result = 0;
    uint64_t v6 = 1;
    int v7 = 6;
    switch(a3)
    {
      case 12:
        int v7 = 0;
        uint64_t v6 = 5;
        goto LABEL_44;
      case 13:
        uint64_t v6 = 5;
        goto LABEL_25;
      case 15:
        goto LABEL_6;
      case 23:
        goto LABEL_7;
      case 28:
        goto LABEL_8;
      case 29:
        uint64_t v6 = 2;
        goto LABEL_27;
      case 30:
        goto LABEL_29;
      case 31:
        uint64_t v6 = 2;
        goto LABEL_31;
      case 32:
        uint64_t v6 = 2;
        goto LABEL_33;
      case 33:
        goto LABEL_44;
      case 35:
      case 41:
        goto LABEL_5;
      case 36:
        goto LABEL_9;
      case 38:
        goto LABEL_10;
      case 39:
        goto LABEL_11;
      case 40:
        uint64_t v6 = 4;
        goto LABEL_38;
      case 42:
        goto LABEL_12;
      case 43:
        goto LABEL_13;
      case 44:
        if (v4) {
          int v7 = 17;
        }
        else {
          int v7 = 16;
        }
        goto LABEL_23;
      default:
        return result;
    }
  }
  else
  {
    uint64_t result = 0;
    uint64_t v6 = 2;
    int v7 = 6;
    switch(a3)
    {
      case 12:
        int v7 = 0;
LABEL_23:
        uint64_t v6 = 4;
        goto LABEL_44;
      case 13:
        uint64_t v6 = 4;
LABEL_25:
        int v7 = 18;
        goto LABEL_44;
      case 15:
LABEL_6:
        uint64_t v6 = 6;
        int v7 = 2;
        goto LABEL_44;
      case 23:
LABEL_7:
        uint64_t v6 = 6;
        int v7 = 11;
        goto LABEL_44;
      case 28:
LABEL_8:
        int v7 = 3;
        uint64_t v6 = 3;
        goto LABEL_44;
      case 29:
        uint64_t v6 = 5;
LABEL_27:
        int v7 = 13;
        goto LABEL_44;
      case 30:
        uint64_t v6 = 1;
LABEL_29:
        int v7 = 7;
        goto LABEL_44;
      case 31:
        uint64_t v6 = 5;
LABEL_31:
        int v7 = 19;
        goto LABEL_44;
      case 32:
        uint64_t v6 = 5;
LABEL_33:
        int v7 = 1;
        goto LABEL_44;
      case 33:
        goto LABEL_44;
      case 34:
        if (*(void *)(a1 + 56) == 1 && **(unsigned char **)(a1 + 48) == 64)
        {
          uint64_t result = 0;
        }
        else
        {
          uint64_t v6 = 5;
          int v7 = 14;
LABEL_44:
          *a4 = v7;
          uint64_t result = v6;
        }
        break;
      case 35:
      case 41:
LABEL_5:
        uint64_t v6 = 3;
        int v7 = 12;
        goto LABEL_44;
      case 36:
LABEL_9:
        uint64_t v6 = 6;
        int v7 = 10;
        goto LABEL_44;
      case 38:
LABEL_10:
        uint64_t v6 = 3;
        int v7 = 8;
        goto LABEL_44;
      case 39:
LABEL_11:
        uint64_t v6 = 3;
        int v7 = 9;
        goto LABEL_44;
      case 40:
        uint64_t v6 = 6;
LABEL_38:
        int v7 = 15;
        goto LABEL_44;
      case 42:
LABEL_12:
        uint64_t v6 = 3;
        int v7 = 4;
        goto LABEL_44;
      case 43:
LABEL_13:
        uint64_t v6 = 3;
        int v7 = 5;
        goto LABEL_44;
      case 44:
        if (v4) {
          int v7 = 17;
        }
        else {
          int v7 = 16;
        }
        uint64_t v6 = 6;
        goto LABEL_44;
      default:
        return result;
    }
  }
  return result;
}

BOOL sub_1CD3821A4(llvm::MCAsmParser *a1, uint64_t a2, void *a3)
{
  v6[0] = 0;
  if ((*(uint64_t (**)(llvm::MCAsmParser *, uint64_t, void *))(*(void *)a1 + 232))(a1, a2, v6)) {
    return 1;
  }
  *a3 = *(void *)(*((void *)a1 + 6) + 8) + *(void *)(*((void *)a1 + 6) + 16);
  v6[0] = "expected ')'";
  __int16 v7 = 259;
  return llvm::MCAsmParser::parseToken(a1, 18, (llvm::Twine *)v6);
}

void sub_1CD382240()
{
}

uint64_t sub_1CD382254(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = a2;
  (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(*(void *)a2 + 16))(a2, ".text", 5, a1, sub_1CD382990);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".data", 5, a1, sub_1CD382B60);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".bss", 4, a1, sub_1CD382B8C);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".section", 8, a1, sub_1CD382BB8);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".def", 4, a1, sub_1CD3835D0);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".scl", 4, a1, sub_1CD38372C);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".type", 5, a1, sub_1CD38388C);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".endef", 6, a1, sub_1CD3839EC);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".secrel32", 9, a1, sub_1CD383A98);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".symidx", 7, a1, sub_1CD383D2C);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".safeseh", 8, a1, sub_1CD383ECC);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".secidx", 7, a1, sub_1CD38406C);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t)))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), ".linkonce", 9, a1, sub_1CD38420C);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".rva", 4, a1, sub_1CD3843C4);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".weak", 5, a1, sub_1CD384698);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)()))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), ".cg_profile", 11, a1, llvm::MCAsmParserExtension::ParseDirectiveCGProfile);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".seh_proc", 9, a1, sub_1CD384960);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".seh_endproc", 12, a1, sub_1CD384B0C);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".seh_endfunclet", 15, a1, sub_1CD384BC0);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".seh_startchained", 17, a1, sub_1CD384C74);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".seh_endchained", 15, a1, sub_1CD384D28);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".seh_handler", 12, a1, sub_1CD384DDC);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".seh_handlerdata", 16, a1, sub_1CD385248);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".seh_stackalloc", 15, a1, sub_1CD3852F8);
  uint64_t v3 = *(uint64_t (**)(void))(**(void **)(a1 + 8) + 16);

  return v3();
}

uint64_t sub_1CD382990(uint64_t a1)
{
  return sub_1CD3829BC(a1, ".text", 5uLL, 1610612768, 2, (std::string::size_type)"", 0, 0);
}

uint64_t sub_1CD3829BC(uint64_t a1, std::string::value_type *a2, std::string::size_type a3, int a4, int a5, std::string::size_type a6, std::string::size_type a7, unsigned int a8)
{
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 9)
  {
    (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
    uint64_t v16 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    uint64_t v17 = (llvm::MCContext *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
    uint64_t COFFSection = llvm::MCContext::getCOFFSection(v17, a2, a3, a4, a5, a6, a7, a8, 0xFFFFFFFF, 0);
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)v16 + 168))(v16, COFFSection, 0);
    return 0;
  }
  else
  {
    int v20 = "unexpected token in section switching directive";
    __int16 v21 = 259;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)&v20, 0, 0);
  }
}

uint64_t sub_1CD382B60(uint64_t a1)
{
  return sub_1CD3829BC(a1, ".data", 5uLL, -1073741760, 19, (std::string::size_type)"", 0, 0);
}

uint64_t sub_1CD382B8C(uint64_t a1)
{
  return sub_1CD3829BC(a1, ".bss", 4uLL, -1073741696, 15, (std::string::size_type)"", 0, 0);
}

uint64_t sub_1CD382BB8(uint64_t a1)
{
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 2
    && **(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 3)
  {
    goto LABEL_87;
  }
  uint64_t v2 = *(void *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8);
  if (*(_DWORD *)v2 == 2)
  {
    uint64_t v3 = *(void *)(v2 + 8);
    std::string::size_type v4 = *(void *)(v2 + 16);
  }
  else
  {
    uint64_t v7 = v2 + 8;
    uint64_t v5 = *(void *)(v2 + 8);
    unint64_t v6 = *(void *)(v7 + 8);
    unint64_t v8 = v6 != 0;
    if (v6) {
      uint64_t v3 = v5 + 1;
    }
    else {
      uint64_t v3 = v5;
    }
    if (v8 <= v6 - 1) {
      unint64_t v9 = v6 - 1;
    }
    else {
      unint64_t v9 = v6 != 0;
    }
    if (v6 < v9) {
      unint64_t v9 = v6;
    }
    std::string::size_type v4 = v9 - v8;
  }
  unsigned int v10 = -1073741760;
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 25)
  {
LABEL_65:
    unsigned __int8 v41 = 0;
    std::string::size_type v39 = 0;
    std::string::size_type v40 = 0;
    if (**(_DWORD **)((*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8), v11, v12, v13)+ 8) != 25)
    {
LABEL_72:
      if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 9)
      {
        if (v10 >> 30 == 1) {
          int v33 = 4;
        }
        else {
          int v33 = 19;
        }
        if ((v10 & 0x20000000) != 0) {
          int v34 = 2;
        }
        else {
          int v34 = v33;
        }
        if ((v34 & 0xFFFFFFFE) == 2)
        {
          int v35 = *(_DWORD *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8)) + 48);
          if (v35 == 39 || v35 == 1) {
            v10 |= 0x20000u;
          }
        }
        sub_1CD3829BC(a1, (std::string::value_type *)v3, v4, v10, v34, v39, v40, v41);
        return 0;
      }
      uint64_t v37 = "unexpected token in directive";
LABEL_92:
      v42[0] = v37;
      __int16 v43 = 259;
      return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v42, 0, 0);
    }
    unsigned __int8 v41 = 2;
    (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
    if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 2)
    {
      uint64_t v37 = "expected comdat type such as 'discard' or 'largest' after protection bits";
      goto LABEL_92;
    }
    if (sub_1CD383298(a1, &v41)) {
      return 1;
    }
    if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 25)
    {
      uint64_t v37 = "expected comma in directive";
      goto LABEL_92;
    }
    (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
    if (!(*(unsigned int (**)(void, std::string::size_type *))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v39))
    {
      v10 |= 0x1000u;
      goto LABEL_72;
    }
LABEL_87:
    uint64_t v37 = "expected identifier in directive";
    goto LABEL_92;
  }
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 3)
  {
    uint64_t v37 = "expected string in directive";
    goto LABEL_92;
  }
  uint64_t v14 = *(void *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8);
  uint64_t v16 = *(void *)(v14 + 8);
  unint64_t v15 = *(void *)(v14 + 16);
  unint64_t v17 = v15 - 1;
  unint64_t v18 = v15 != 0;
  if (v18 > v15 - 1) {
    unint64_t v17 = v15 != 0;
  }
  if (v15 >= v17) {
    unint64_t v19 = v17;
  }
  else {
    unint64_t v19 = v15;
  }
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  unint64_t v20 = v19 - v18;
  if (v19 == v18)
  {
LABEL_52:
    unsigned int v22 = 8;
LABEL_53:
    if ((v22 & 5) == 1) {
      int v29 = ((int)(v22 << 30) >> 31) & 0x20000020 | (((v22 >> 3) & 1) << 6) | 0x80;
    }
    else {
      int v29 = ((int)(v22 << 30) >> 31) & 0x20000020 | (((v22 >> 3) & 1) << 6);
    }
    unsigned int v30 = v29 & 0xFFFFF7FF | (((v22 >> 5) & 1) << 11);
    if ((v22 & 0x100) != 0
      || v4 >= 6 && (*(_DWORD *)v3 == 1650811950 ? (BOOL v31 = *(unsigned __int16 *)(v3 + 4) == 26485) : (BOOL v31 = 0), v31))
    {
      v30 |= 0x2000000u;
    }
    unsigned int v10 = v30 | (v22 << 24) & 0xD0000000 ^ 0xC0000000;
    goto LABEL_65;
  }
  char v21 = 0;
  unsigned int v22 = 0;
  uint64_t v23 = (unsigned char *)(v16 + v18);
  uint64_t v11 = 28;
  uint64_t v12 = 2;
  uint64_t v13 = 6;
  while (1)
  {
    int v24 = (char)*v23;
    if (v24 > 99)
    {
      switch(*v23)
      {
        case 'n':
          unsigned int v22 = v22 & 0xFFFFFFDB | 0x20;
          goto LABEL_50;
        case 'o':
        case 'p':
        case 'q':
        case 't':
        case 'u':
        case 'v':
          goto LABEL_94;
        case 'r':
          char v21 = 0;
          if ((v22 & 2) != 0) {
            int v25 = 128;
          }
          else {
            int v25 = 136;
          }
          v22 |= (v25 | (v22 >> 3) & 4) ^ 4;
          goto LABEL_50;
        case 's':
          unsigned int v26 = v22 & 0xFFFFFF67;
          if ((v22 & 0x20) != 0) {
            int v27 = 24;
          }
          else {
            int v27 = 28;
          }
          unsigned int v22 = v27 | v26;
          goto LABEL_50;
        case 'w':
          v22 &= ~0x80u;
          char v21 = 1;
          goto LABEL_50;
        case 'x':
          if ((v22 & 0x20) != 0) {
            int v28 = 2;
          }
          else {
            int v28 = 6;
          }
          v22 |= v28;
          if ((v21 & 1) == 0) {
            v22 |= 0x80u;
          }
          goto LABEL_50;
        case 'y':
          v22 |= 0xC0u;
          goto LABEL_50;
        default:
          if (v24 != 100) {
            goto LABEL_94;
          }
          if (v22) {
            goto LABEL_93;
          }
          unsigned int v22 = v22 & 0xFFFFFF7F | ~(v22 >> 3) & 4 | 8;
          break;
      }
      goto LABEL_50;
    }
    if (v24 == 68)
    {
      v22 |= 0x100u;
      goto LABEL_50;
    }
    if (v24 != 97) {
      break;
    }
LABEL_50:
    ++v23;
    if (!--v20)
    {
      if (v22) {
        goto LABEL_53;
      }
      goto LABEL_52;
    }
  }
  if (v24 == 98)
  {
    if ((v22 & 8) != 0)
    {
LABEL_93:
      unsigned int v38 = "conflicting section flags 'b' and 'd'.";
      goto LABEL_95;
    }
    unsigned int v22 = v22 & 0xFFFFFFFA | 1;
    goto LABEL_50;
  }
LABEL_94:
  unsigned int v38 = "unknown flag";
LABEL_95:
  v42[0] = v38;
  __int16 v43 = 259;
  if ((llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v42, 0, 0) & 1) == 0) {
    goto LABEL_65;
  }
  return 1;
}

uint64_t sub_1CD383298(uint64_t a1, unsigned char *a2)
{
  uint64_t v4 = *(void *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8);
  if (*(_DWORD *)v4 == 2)
  {
    uint64_t v5 = *(void *)(v4 + 8);
    unint64_t v6 = *(void *)(v4 + 16);
  }
  else
  {
    uint64_t v5 = *(void *)(v4 + 8);
    unint64_t v7 = *(void *)(v4 + 16);
    unint64_t v8 = v7 - 1;
    unint64_t v9 = v7 != 0;
    if (v7) {
      ++v5;
    }
    if (v9 > v8) {
      unint64_t v8 = v7 != 0;
    }
    if (v7 < v8) {
      unint64_t v8 = v7;
    }
    unint64_t v6 = v8 - v9;
  }
  switch(v6)
  {
    case 6uLL:
      BOOL v10 = (*(_DWORD *)v5 ^ 0x6577656E | *(unsigned __int16 *)(v5 + 4) ^ 0x7473) == 0;
      unsigned int v11 = v10;
      LOBYTE(v12) = 7;
      goto LABEL_17;
    case 7uLL:
      int v13 = *(_DWORD *)v5 ^ 0x63736964 | *(_DWORD *)(v5 + 3) ^ 0x64726163;
      unsigned int v11 = v13 == 0;
      if (v13) {
        LOBYTE(v12) = 0;
      }
      else {
        LOBYTE(v12) = 2;
      }
      if (v13)
      {
        BOOL v10 = (*(_DWORD *)v5 ^ 0x6772616C | *(_DWORD *)(v5 + 3) ^ 0x74736567) == 0;
        unsigned int v11 = v10;
        LOBYTE(v12) = 6;
LABEL_17:
        if (!v10) {
          LOBYTE(v12) = 0;
        }
      }
      goto LABEL_47;
    case 8uLL:
      unint64_t v14 = bswap64(*(void *)v5);
      BOOL v15 = v14 >= 0x6F6E655F6F6E6C79;
      BOOL v16 = v14 > 0x6F6E655F6F6E6C79;
      int v17 = !v15;
      int v18 = v16 - v17;
      unsigned int v12 = 257;
      goto LABEL_44;
    case 9uLL:
      unint64_t v19 = bswap64(*(void *)v5);
      if (v19 == 0x73616D655F73697ALL)
      {
        int v18 = *(unsigned __int8 *)(v5 + 8) - 101;
      }
      else if (v19 < 0x73616D655F73697ALL)
      {
        int v18 = -1;
      }
      else
      {
        int v18 = 1;
      }
      unsigned int v12 = 259;
      goto LABEL_44;
    case 0xBuLL:
      unint64_t v20 = 0x6173736F63696174;
      unint64_t v21 = bswap64(*(void *)v5);
      if (v21 == 0x6173736F63696174
        && (unint64_t v20 = 0x6F63696174697665, v21 = bswap64(*(void *)(v5 + 3)), v21 == 0x6F63696174697665))
      {
        int v18 = 0;
      }
      else if (v21 < v20)
      {
        int v18 = -1;
      }
      else
      {
        int v18 = 1;
      }
      unsigned int v12 = 261;
      goto LABEL_44;
    case 0xDuLL:
      unint64_t v22 = 0x73616D655F636F6ELL;
      unint64_t v23 = bswap64(*(void *)v5);
      if (v23 == 0x73616D655F636F6ELL
        && (unint64_t v22 = 0x636F6E74656E7473, v23 = bswap64(*(void *)(v5 + 5)), v23 == 0x636F6E74656E7473))
      {
        int v18 = 0;
      }
      else if (v23 < v22)
      {
        int v18 = -1;
      }
      else
      {
        int v18 = 1;
      }
      unsigned int v12 = 260;
LABEL_44:
      if (v18) {
        unsigned int v12 = 0;
      }
      unsigned int v11 = v12 >> 8;
LABEL_47:
      if (v11) {
        char v24 = v12;
      }
      else {
        char v24 = 0;
      }
      *a2 = v24;
      if (!v24) {
        goto LABEL_53;
      }
      (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
      uint64_t result = 0;
      break;
    default:
      *a2 = 0;
LABEL_53:
      __int16 v27 = 1283;
      v26[0] = "unrecognized COMDAT type '";
      void v26[2] = v5;
      v26[3] = v6;
      v28[0] = v26;
      v28[2] = "'";
      __int16 v29 = 770;
      uint64_t result = llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v28, 0, 0);
      break;
  }
  return result;
}

uint64_t sub_1CD3835D0(uint64_t a1)
{
  unint64_t v7 = 0;
  unint64_t v8 = 0;
  if ((*(unsigned int (**)(void, unsigned __int8 ***))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v7))
  {
    v5[0] = (unsigned __int8 **)"expected identifier in directive";
    __int16 v6 = 259;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v5, 0, 0);
  }
  else
  {
    uint64_t v2 = (llvm::MCContext *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
    __int16 v6 = 261;
    v5[0] = v7;
    v5[1] = v8;
    llvm::MCContext::getOrCreateSymbol(v2, v5);
    uint64_t v3 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    (*(void (**)(void))(v3 + 320))();
    (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
    return 0;
  }
}

uint64_t sub_1CD38372C(uint64_t a1)
{
  uint64_t v6 = 0;
  if ((*(uint64_t (**)(void, uint64_t *))(**(void **)(a1 + 8) + 256))(*(void *)(a1 + 8), &v6)) {
    return 1;
  }
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 9)
  {
    (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
    uint64_t v3 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    (*(void (**)(void))(v3 + 328))();
    return 0;
  }
  else
  {
    uint64_t v4 = "unexpected token in directive";
    __int16 v5 = 259;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)&v4, 0, 0);
  }
}

uint64_t sub_1CD38388C(uint64_t a1)
{
  uint64_t v6 = 0;
  if ((*(uint64_t (**)(void, uint64_t *))(**(void **)(a1 + 8) + 256))(*(void *)(a1 + 8), &v6)) {
    return 1;
  }
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 9)
  {
    (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
    uint64_t v3 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    (*(void (**)(void))(v3 + 336))();
    return 0;
  }
  else
  {
    uint64_t v4 = "unexpected token in directive";
    __int16 v5 = 259;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)&v4, 0, 0);
  }
}

uint64_t sub_1CD3839EC(uint64_t a1)
{
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  uint64_t v2 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
  (*(void (**)(void))(v2 + 344))();
  return 0;
}

uint64_t sub_1CD383A98(uint64_t a1)
{
  unint64_t v8 = 0;
  unint64_t v9 = 0;
  if ((*(unsigned int (**)(void, unsigned __int8 ***))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v8))
  {
    __int16 v5 = "expected identifier in directive";
  }
  else
  {
    if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 12)
    {
      (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8));
      if ((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 256))()) {
        return 1;
      }
    }
    if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 9)
    {
      uint64_t v3 = (llvm::MCContext *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
      __int16 v7 = 261;
      v6[0] = v8;
      v6[1] = v9;
      llvm::MCContext::getOrCreateSymbol(v3, v6);
      (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
      uint64_t v4 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
      (*(void (**)(void))(v4 + 376))();
      return 0;
    }
    __int16 v5 = "unexpected token in directive";
  }
  v6[0] = (unsigned __int8 **)v5;
  __int16 v7 = 259;
  return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v6, 0, 0);
}

uint64_t sub_1CD383D2C(uint64_t a1)
{
  unint64_t v8 = 0;
  unint64_t v9 = 0;
  if ((*(unsigned int (**)(void, unsigned __int8 ***))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v8))
  {
    __int16 v5 = "expected identifier in directive";
LABEL_7:
    v6[0] = (unsigned __int8 **)v5;
    __int16 v7 = 259;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v6, 0, 0);
  }
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 9)
  {
    __int16 v5 = "unexpected token in directive";
    goto LABEL_7;
  }
  uint64_t v2 = (llvm::MCContext *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
  __int16 v7 = 261;
  v6[0] = v8;
  v6[1] = v9;
  llvm::MCContext::getOrCreateSymbol(v2, v6);
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  uint64_t v3 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
  (*(void (**)(void))(v3 + 360))();
  return 0;
}

uint64_t sub_1CD383ECC(uint64_t a1)
{
  unint64_t v8 = 0;
  unint64_t v9 = 0;
  if ((*(unsigned int (**)(void, unsigned __int8 ***))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v8))
  {
    __int16 v5 = "expected identifier in directive";
LABEL_7:
    v6[0] = (unsigned __int8 **)v5;
    __int16 v7 = 259;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v6, 0, 0);
  }
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 9)
  {
    __int16 v5 = "unexpected token in directive";
    goto LABEL_7;
  }
  uint64_t v2 = (llvm::MCContext *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
  __int16 v7 = 261;
  v6[0] = v8;
  v6[1] = v9;
  llvm::MCContext::getOrCreateSymbol(v2, v6);
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  uint64_t v3 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
  (*(void (**)(void))(v3 + 352))();
  return 0;
}

uint64_t sub_1CD38406C(uint64_t a1)
{
  unint64_t v8 = 0;
  unint64_t v9 = 0;
  if ((*(unsigned int (**)(void, unsigned __int8 ***))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v8))
  {
    __int16 v5 = "expected identifier in directive";
LABEL_7:
    v6[0] = (unsigned __int8 **)v5;
    __int16 v7 = 259;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v6, 0, 0);
  }
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 9)
  {
    __int16 v5 = "unexpected token in directive";
    goto LABEL_7;
  }
  uint64_t v2 = (llvm::MCContext *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
  __int16 v7 = 261;
  v6[0] = v8;
  v6[1] = v9;
  llvm::MCContext::getOrCreateSymbol(v2, v6);
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  uint64_t v3 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
  (*(void (**)(void))(v3 + 368))();
  return 0;
}

uint64_t sub_1CD38420C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned __int8 v17 = 2;
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 2
    && (sub_1CD383298(a1, &v17) & 1) != 0)
  {
    return 1;
  }
  uint64_t v7 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
  uint64_t v8 = *(unsigned int *)(v7 + 120);
  if (v8) {
    uint64_t v9 = *(void *)(*(void *)(v7 + 112) + 32 * v8 - 32);
  }
  else {
    uint64_t v9 = 0;
  }
  if (v17 == 5)
  {
    v15[0] = "cannot make section associative with .linkonce";
    __int16 v11 = 259;
LABEL_14:
    __int16 v16 = v11;
    return llvm::MCAsmParser::Error(*(void *)(a1 + 8), a4, (uint64_t)v15, 0, 0);
  }
  int v10 = *(_DWORD *)(v9 + 224);
  if ((v10 & 0x1000) != 0)
  {
    unsigned int v12 = "section '";
    long long v13 = *(_OWORD *)(v9 + 200);
    __int16 v14 = 1283;
    v15[0] = &v12;
    void v15[2] = "' is already linkonce";
    __int16 v11 = 770;
    goto LABEL_14;
  }
  *(_DWORD *)(v9 + 240) = v17;
  *(_DWORD *)(v9 + 224) = v10 | 0x1000;
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 9) {
    return 0;
  }
  v15[0] = "unexpected token in directive";
  __int16 v16 = 259;
  return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v15, 0, 0);
}

uint64_t sub_1CD3843C4(uint64_t a1)
{
  uint64_t v5 = a1;
  uint64_t result = llvm::MCAsmParser::parseMany(*(llvm::MCAsmParser **)(a1 + 8), (uint64_t (*)(uint64_t))sub_1CD384438, (uint64_t)&v5, 1);
  if (result)
  {
    uint64_t v3 = " in directive";
    __int16 v4 = 259;
    return llvm::MCAsmParser::addErrorSuffix(*(llvm::MCAsmParser **)(a1 + 8), (const llvm::Twine *)&v3);
  }
  return result;
}

uint64_t sub_1CD384438(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  if ((*(unsigned int (**)(void, unsigned __int8 ***))(**(void **)(v1 + 8) + 192))(*(void *)(v1 + 8), &v7))
  {
    v5[0] = (unsigned __int8 **)"expected identifier in directive";
    __int16 v6 = 259;
    return llvm::MCAsmParser::TokError(*(void *)(v1 + 8), (uint64_t)v5, 0, 0);
  }
  else if ((**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(v1 + 8) + 40))(*(void *)(v1 + 8)) + 8) == 12 {
          || **(_DWORD **)((*(uint64_t (**)(void))(**(void **)(v1 + 8) + 40))(*(void *)(v1 + 8)) + 8) == 13)
  }
         && ((*(uint64_t (**)(void))(**(void **)(v1 + 8) + 40))(*(void *)(v1 + 8)),
             ((*(uint64_t (**)(void))(**(void **)(v1 + 8) + 256))() & 1) != 0))
  {
    return 1;
  }
  else
  {
    uint64_t v3 = (llvm::MCContext *)(*(uint64_t (**)(void))(**(void **)(v1 + 8) + 48))(*(void *)(v1 + 8));
    __int16 v6 = 261;
    v5[0] = v7;
    v5[1] = v8;
    llvm::MCContext::getOrCreateSymbol(v3, v5);
    uint64_t v4 = *(void *)(*(uint64_t (**)(void))(**(void **)(v1 + 8) + 56))(*(void *)(v1 + 8));
    (*(void (**)(void))(v4 + 384))();
    return 0;
  }
}

uint64_t sub_1CD384698(uint64_t a1)
{
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 9)
  {
LABEL_2:
    (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
    return 0;
  }
  uint64_t v8 = 0;
  for (uint64_t i = 0;
        ((*(uint64_t (**)(void, unsigned __int8 ***))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v8) & 1) == 0;
        uint64_t i = 0)
  {
    uint64_t v3 = (llvm::MCContext *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
    __int16 v7 = 261;
    v6[0] = v8;
    v6[1] = i;
    llvm::MCContext::getOrCreateSymbol(v3, v6);
    uint64_t v4 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    (*(void (**)(void))(v4 + 304))();
    if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 9) {
      goto LABEL_2;
    }
    if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 25)
    {
      uint64_t v5 = "unexpected token in directive";
      goto LABEL_9;
    }
    (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
    uint64_t v8 = 0;
  }
  uint64_t v5 = "expected identifier in directive";
LABEL_9:
  v6[0] = (unsigned __int8 **)v5;
  __int16 v7 = 259;
  return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v6, 0, 0);
}

uint64_t sub_1CD384960(uint64_t a1)
{
  __int16 v7 = 0;
  uint64_t v8 = 0;
  if ((*(uint64_t (**)(void, unsigned __int8 ***))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v7))return 1; {
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 9)
  }
  {
    uint64_t v3 = (llvm::MCContext *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
    __int16 v6 = 261;
    v5[0] = v7;
    v5[1] = v8;
    llvm::MCContext::getOrCreateSymbol(v3, v5);
    (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
    uint64_t v4 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    (*(void (**)(void))(v4 + 1040))();
    return 0;
  }
  else
  {
    v5[0] = (unsigned __int8 **)"unexpected token in directive";
    __int16 v6 = 259;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v5, 0, 0);
  }
}

uint64_t sub_1CD384B0C(uint64_t a1)
{
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  uint64_t v2 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
  (*(void (**)(void))(v2 + 1048))();
  return 0;
}

uint64_t sub_1CD384BC0(uint64_t a1)
{
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  uint64_t v2 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
  (*(void (**)(void))(v2 + 1056))();
  return 0;
}

uint64_t sub_1CD384C74(uint64_t a1)
{
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  uint64_t v2 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
  (*(void (**)(void))(v2 + 1064))();
  return 0;
}

uint64_t sub_1CD384D28(uint64_t a1)
{
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  uint64_t v2 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
  (*(void (**)(void))(v2 + 1072))();
  return 0;
}

uint64_t sub_1CD384DDC(uint64_t a1)
{
  uint64_t v9 = 0;
  int v10 = 0;
  if (((*(uint64_t (**)(void, unsigned __int8 ***))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v9) & 1) == 0)
  {
    if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 25)
    {
      uint64_t v5 = "you must specify one or both of @unwind or @except";
LABEL_12:
      v7[0] = (unsigned __int8 **)v5;
      __int16 v8 = 259;
      return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v7, 0, 0);
    }
    (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
    __int16 v6 = 0;
    if ((sub_1CD385088(a1, (unsigned char *)&v6 + 1, &v6) & 1) == 0)
    {
      if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 25
        || ((*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8)),
            (sub_1CD385088(a1, (unsigned char *)&v6 + 1, &v6) & 1) == 0))
      {
        if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 9)
        {
          uint64_t v3 = (llvm::MCContext *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
          __int16 v8 = 261;
          v7[0] = v9;
          v7[1] = v10;
          llvm::MCContext::getOrCreateSymbol(v3, v7);
          (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
          uint64_t v4 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
          (*(void (**)(void))(v4 + 1136))();
          return 0;
        }
        uint64_t v5 = "unexpected token in directive";
        goto LABEL_12;
      }
    }
  }
  return 1;
}

uint64_t sub_1CD385088(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 45)
  {
    uint64_t v6 = *(void *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 96);
    (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
    if (!(*(unsigned int (**)(void, uint64_t *))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v12)
      && v13 == 6)
    {
      if (*(_DWORD *)v12 == 1769434741 && *(_WORD *)(v12 + 4) == 25710)
      {
        uint64_t result = 0;
        *a2 = 1;
        return result;
      }
      if (*(_DWORD *)v12 == 1701017701 && *(_WORD *)(v12 + 4) == 29808)
      {
        uint64_t result = 0;
        *a3 = 1;
        return result;
      }
    }
    v10[0] = "expected @unwind or @except";
    __int16 v11 = 259;
    return llvm::MCAsmParser::Error(*(void *)(a1 + 8), v6, (uint64_t)v10, 0, 0);
  }
  else
  {
    v10[0] = "a handler attribute must begin with '@'";
    __int16 v11 = 259;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v10, 0, 0);
  }
}

uint64_t sub_1CD385248(uint64_t a1)
{
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  uint64_t v2 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
  (*(void (**)(void))(v2 + 1144))();
  return 0;
}

uint64_t sub_1CD3852F8(uint64_t a1)
{
  uint64_t v6 = 0;
  if ((*(uint64_t (**)(void, uint64_t *))(**(void **)(a1 + 8) + 256))(*(void *)(a1 + 8), &v6)) {
    return 1;
  }
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 9)
  {
    (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
    uint64_t v3 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    (*(void (**)(void))(v3 + 1096))();
    return 0;
  }
  else
  {
    uint64_t v4 = "unexpected token in directive";
    __int16 v5 = 259;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)&v4, 0, 0);
  }
}

uint64_t sub_1CD385460(uint64_t a1)
{
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  uint64_t v2 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
  (*(void (**)(void))(v2 + 1128))();
  return 0;
}

void llvm::createCOFFMasmParser(llvm *this)
{
}

void sub_1CD385568()
{
}

uint64_t sub_1CD38557C(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = a2;
  (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(*(void *)a2 + 16))(a2, ".allocstack", 11, a1, sub_1CD385F2C);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".endprolog", 10, a1, sub_1CD38608C);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".cref", 5, a1, sub_1CD386114);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".list", 5, a1, sub_1CD386114);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".listall", 8, a1, sub_1CD386114);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".listif", 7, a1, sub_1CD386114);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".listmacro", 10, a1, sub_1CD386114);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".listmacroall", 13, a1, sub_1CD386114);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".nocref", 7, a1, sub_1CD386114);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".nolist", 7, a1, sub_1CD386114);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".nolistif", 9, a1, sub_1CD386114);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".nolistmacro", 12, a1, sub_1CD386114);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), "page", 4, a1, sub_1CD386114);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), "subtitle", 8, a1, sub_1CD386114);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".tfcond", 7, a1, sub_1CD386114);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), "title", 5, a1, sub_1CD386114);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t, uint64_t, uint64_t)))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), "alias", 5, a1, sub_1CD3861A0);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), "includelib", 10, a1, sub_1CD3864D4);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t)))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), "endp", 4, a1, sub_1CD3867AC);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t)))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), "proc", 4, a1, sub_1CD386984);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".386", 4, a1, sub_1CD386114);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".386p", 5, a1, sub_1CD386114);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".387", 4, a1, sub_1CD386114);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".486", 4, a1, sub_1CD386114);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".486p", 5, a1, sub_1CD386114);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".586", 4, a1, sub_1CD386114);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".586p", 5, a1, sub_1CD386114);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".686", 4, a1, sub_1CD386114);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".686p", 5, a1, sub_1CD386114);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".k3d", 4, a1, sub_1CD386114);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".mmx", 4, a1, sub_1CD386114);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".xmm", 4, a1, sub_1CD386114);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), "ends", 4, a1, sub_1CD386DA4);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), "segment", 7, a1, sub_1CD386E84);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".code", 5, a1, sub_1CD387218);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".data", 5, a1, sub_1CD3873C4);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".data?", 6, a1, sub_1CD3873E0);
  uint64_t v3 = *(uint64_t (**)(void))(**(void **)(a1 + 8) + 16);

  return v3();
}

uint64_t sub_1CD385F2C(uint64_t a1)
{
  uint64_t v8 = 0;
  uint64_t v2 = *(void *)(*(void *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8))
                             + 8)
                 + 8);
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 8) + 256))())
  {
    __int16 v5 = "expected integer size";
LABEL_7:
    uint64_t v6 = v5;
    __int16 v7 = 259;
    return llvm::MCAsmParser::Error(*(void *)(a1 + 8), v2, (uint64_t)&v6, 0, 0);
  }
  if ((v8 & 7) != 0)
  {
    __int16 v5 = "stack size must be a multiple of 8";
    goto LABEL_7;
  }
  uint64_t v3 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
  (*(void (**)(void))(v3 + 1096))();
  return 0;
}

uint64_t sub_1CD38608C(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
  (*(void (**)(void))(v1 + 1128))();
  return 0;
}

uint64_t sub_1CD386114(uint64_t a1)
{
  for (uint64_t i = *(void *)(a1 + 8);
        **(_DWORD **)((*(uint64_t (**)(uint64_t))(*(void *)i + 40))(i) + 8) != 9;
        uint64_t i = *(void *)(a1 + 8))
  {
    (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  }
  return 0;
}

uint64_t sub_1CD3861A0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v21[0] = 0;
  v21[1] = 0;
  uint64_t v22 = 0;
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v20 = 0;
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 38
    || (*(unsigned int (**)(void, void **))(**(void **)(a1 + 8) + 216))(*(void *)(a1 + 8), v21))
  {
    uint64_t v6 = *(void *)(*(void *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8))
                               + 8)
                   + 8);
    __int16 v7 = "expected <aliasName>";
LABEL_4:
    v17[0] = (unsigned __int8 **)v7;
    __int16 v18 = 259;
    uint64_t v8 = llvm::MCAsmParser::Error(*(void *)(a1 + 8), v6, (uint64_t)v17, 0, 0);
LABEL_5:
    uint64_t v9 = v8;
    goto LABEL_10;
  }
  int v10 = *(llvm::MCAsmParser **)(a1 + 8);
  v17[0] = (unsigned __int8 **)"unexpected token";
  __int16 v18 = 259;
  if (llvm::MCAsmParser::parseToken(v10, 27, (llvm::Twine *)v17))
  {
    __int16 v16 = 1283;
    v15[0] = " in ";
    void v15[2] = a2;
    v15[3] = a3;
    v17[0] = (unsigned __int8 **)v15;
    v17[2] = (unsigned __int8 **)" directive";
    __int16 v18 = 770;
    uint64_t v8 = llvm::MCAsmParser::addErrorSuffix(*(llvm::MCAsmParser **)(a1 + 8), (const llvm::Twine *)v17);
    goto LABEL_5;
  }
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 38
    || (*(unsigned int (**)(void, void **))(**(void **)(a1 + 8) + 216))(*(void *)(a1 + 8), __p))
  {
    uint64_t v6 = *(void *)(*(void *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8))
                               + 8)
                   + 8);
    __int16 v7 = "expected <actualName>";
    goto LABEL_4;
  }
  __int16 v11 = (llvm::MCContext *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
  __int16 v18 = 260;
  v17[0] = (unsigned __int8 **)v21;
  llvm::MCContext::getOrCreateSymbol(v11, v17);
  uint64_t v12 = (llvm::MCContext *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
  __int16 v18 = 260;
  v17[0] = (unsigned __int8 **)__p;
  llvm::MCContext::getOrCreateSymbol(v12, v17);
  uint64_t v13 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
  (*(void (**)(void))(v13 + 296))();
  uint64_t v9 = 0;
LABEL_10:
  if (SHIBYTE(v20) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v22) < 0) {
    operator delete(v21[0]);
  }
  return v9;
}

uint64_t sub_1CD3864D4(uint64_t a1)
{
  v14[0] = 0;
  v14[1] = 0;
  if ((*(unsigned int (**)(void, void *))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), v14))
  {
    uint64_t v12 = "expected identifier in includelib directive";
    __int16 v13 = 259;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)&v12, 0, 0);
  }
  else
  {
    uint64_t v3 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    __n128 v4 = sub_1CD6AD2C8(v3);
    uint64_t v5 = (*(uint64_t (**)(void, __n128))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8), v4);
    uint64_t v6 = (llvm::MCContext *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
    uint64_t COFFSection = llvm::MCContext::getCOFFSection(v6, ".drectve", 8uLL, 655360, 19, (std::string::size_type)"", 0, 0, 0xFFFFFFFF, 0);
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)v5 + 168))(v5, COFFSection, 0);
    uint64_t v8 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    (*(void (**)(void))(v8 + 488))();
    uint64_t v9 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    (*(void (**)(void))(v9 + 488))();
    uint64_t v10 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    (*(void (**)(void))(v10 + 488))();
    uint64_t v11 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    sub_1CCBC2468(v11);
    return 0;
  }
}

uint64_t sub_1CD3867AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __int16 v18 = 0;
  uint64_t v19 = 0;
  uint64_t v6 = *(void *)(*(void *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8))
                             + 8)
                 + 8);
  if ((*(unsigned int (**)(void, const void **))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v18))
  {
    v16[0] = "expected identifier for procedure end";
    __int16 v11 = 259;
LABEL_12:
    __int16 v17 = v11;
    uint64_t v12 = *(void *)(a1 + 8);
    uint64_t v13 = v6;
    return llvm::MCAsmParser::Error(v12, v13, (uint64_t)v16, 0, 0);
  }
  uint64_t v7 = *(void *)(a1 + 32);
  if (!v7)
  {
    v16[0] = "endp outside of procedure block";
    __int16 v17 = 259;
    uint64_t v12 = *(void *)(a1 + 8);
    uint64_t v13 = a4;
    return llvm::MCAsmParser::Error(v12, v13, (uint64_t)v16, 0, 0);
  }
  if (v7 != v19)
  {
    uint64_t v8 = *(const void **)(a1 + 24);
    goto LABEL_11;
  }
  uint64_t v8 = *(const void **)(a1 + 24);
  if (memcmp(v8, v18, *(void *)(a1 + 32)))
  {
LABEL_11:
    __int16 v15 = 1283;
    v14[0] = "endp does not match current procedure '";
    void v14[2] = v8;
    void v14[3] = v7;
    v16[0] = v14;
    void v16[2] = "'";
    __int16 v11 = 770;
    goto LABEL_12;
  }
  if (*(unsigned char *)(a1 + 40))
  {
    uint64_t v9 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    (*(void (**)(void))(v9 + 1048))();
  }
  uint64_t result = 0;
  *(void *)(a1 + 24) = "";
  *(void *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 40) = 0;
  return result;
}

uint64_t sub_1CD386984(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  long long v24 = 0uLL;
  if ((*(unsigned int (**)(void, long long *))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v24))
  {
    *(void *)&v22[0] = "expected identifier for procedure";
    __int16 v23 = 259;
    uint64_t v17 = *(void *)(a1 + 8);
    uint64_t v18 = a4;
    return llvm::MCAsmParser::Error(v17, v18, (uint64_t)v22, 0, 0);
  }
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 2)
  {
    uint64_t v6 = *(void *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8);
    uint64_t v7 = *(unsigned __int8 **)(v6 + 16);
    v21[0] = *(unsigned __int8 **)(v6 + 8);
    v21[1] = v7;
    uint64_t v8 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8));
    if (v7 == (unsigned __int8 *)4)
    {
      if (!llvm::StringRef::compare_insensitive(v21, "near", 4uLL))
      {
        (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
        (*(void (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8));
        (*(void (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8));
      }
    }
    else if (v7 == (unsigned __int8 *)3)
    {
      uint64_t v20 = *(void *)(*(void *)(v8 + 8) + 8);
      if (!llvm::StringRef::compare_insensitive(v21, "far", 3uLL))
      {
        (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
        *(void *)&v22[0] = "far procedure definitions not yet supported";
        __int16 v23 = 259;
        uint64_t v17 = *(void *)(a1 + 8);
        uint64_t v18 = v20;
        return llvm::MCAsmParser::Error(v17, v18, (uint64_t)v22, 0, 0);
      }
    }
  }
  uint64_t v9 = (llvm::MCContext *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
  __int16 v23 = 261;
  v22[0] = v24;
  uint64_t Symbol = llvm::MCContext::getOrCreateSymbol(v9, (unsigned __int8 ***)v22);
  *(_DWORD *)(Symbol + 8) |= 0x10u;
  *(_WORD *)(Symbol + 32) = 32;
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 2
    && (uint64_t v11 = *(void *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8),
        uint64_t v13 = *(void *)(v11 + 8),
        uint64_t v12 = *(void *)(v11 + 16),
        *(void *)&v22[0] = v13,
        *((void *)&v22[0] + 1) = v12,
        v12 == 5)
    && !llvm::StringRef::compare_insensitive((unsigned __int8 **)v22, "frame", 5uLL))
  {
    (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
    uint64_t v19 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    (*(void (**)(void))(v19 + 1040))();
    char v14 = 1;
  }
  else
  {
    char v14 = 0;
  }
  uint64_t v15 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v15 + 192))(v15, Symbol, a4);
  uint64_t result = 0;
  *(_OWORD *)(a1 + 24) = v24;
  *(unsigned char *)(a1 + 40) = v14;
  return result;
}

uint64_t sub_1CD386DA4(uint64_t a1)
{
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 2)
  {
    (*(void (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8));
    (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
    return 0;
  }
  else
  {
    uint64_t v3 = "expected identifier in directive";
    __int16 v4 = 259;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)&v3, 0, 0);
  }
}

uint64_t sub_1CD386E84(uint64_t a1)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 2)
  {
    uint64_t v2 = *(void *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8);
    if (*(_DWORD *)v2 == 2)
    {
      uint64_t v3 = *(char **)(v2 + 8);
      std::string::size_type v4 = *(void *)(v2 + 16);
    }
    else
    {
      uint64_t v7 = v2 + 8;
      uint64_t v5 = *(char **)(v2 + 8);
      unint64_t v6 = *(void *)(v7 + 8);
      unint64_t v8 = v6 != 0;
      if (v6) {
        uint64_t v3 = v5 + 1;
      }
      else {
        uint64_t v3 = v5;
      }
      if (v8 <= v6 - 1) {
        unint64_t v9 = v6 - 1;
      }
      else {
        unint64_t v9 = v6 != 0;
      }
      if (v6 < v9) {
        unint64_t v9 = v6;
      }
      std::string::size_type v4 = v9 - v8;
    }
    unsigned int v10 = -1073741760;
    uint64_t v11 = (llvm::raw_ostream *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
    unsigned int v30 = v32;
    long long v31 = xmmword_1CFB33B80;
    if (v4 == 5)
    {
      if (*(_DWORD *)v3 ^ 0x5845545F | v3[4] ^ 0x54) {
        unsigned int v10 = -1073741760;
      }
      else {
        unsigned int v10 = 1610612768;
      }
      if (!(*(_DWORD *)v3 ^ 0x5845545F | v3[4] ^ 0x54)) {
        uint64_t v3 = ".text";
      }
    }
    else if (v4 >= 6 && *(_DWORD *)v3 == 1480938591 && *((_WORD *)v3 + 2) == 9300)
    {
      int v22 = 0;
      char v26 = 0;
      uint64_t v27 = 0;
      __int16 v29 = &v30;
      int v28 = 0;
      unint64_t v21 = &unk_1F2646FA8;
      uint64_t v23 = 0;
      uint64_t v24 = 0;
      uint64_t v25 = 0;
      char v14 = llvm::Twine::printOneChild(v11, (llvm::raw_ostream *)&v21, (uint64_t)".text$", v12, 3);
      llvm::Twine::printOneChild(v14, (llvm::raw_ostream *)&v21, (uint64_t)(v3 + 6), v4 - 6, 5);
      unint64_t v21 = &unk_1F2646B98;
      if (v28 == 1 && v23) {
        MEMORY[0x1D25D9CB0](v23, 0x1000C8077774924);
      }
      unsigned int v10 = 1610612768;
      uint64_t v3 = (char *)v30;
      std::string::size_type v4 = v31;
    }
    int v15 = 19;
    if (v10 >> 30 == 1) {
      int v15 = 4;
    }
    if ((v10 & 0x20000000) != 0) {
      int v16 = 2;
    }
    else {
      int v16 = v15;
    }
    uint64_t v17 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    uint64_t v18 = (llvm::MCContext *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
    uint64_t COFFSection = llvm::MCContext::getCOFFSection(v18, v3, v4, v10, v16, (std::string::size_type)"", 0, 0, 0xFFFFFFFF, 0);
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)v17 + 168))(v17, COFFSection, 0);
    if (v30 != v32) {
      free(v30);
    }
    return 0;
  }
  else
  {
    unsigned int v30 = "expected identifier in directive";
    void v32[4] = 259;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)&v30, 0, 0);
  }
}

uint64_t sub_1CD387218(uint64_t a1)
{
  return sub_1CD387234(a1, ".text", 5uLL, 1610612768, 2);
}

uint64_t sub_1CD387234(uint64_t a1, std::string::value_type *a2, std::string::size_type a3, int a4, int a5)
{
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 9)
  {
    (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
    uint64_t v10 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    uint64_t v11 = (llvm::MCContext *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
    uint64_t COFFSection = llvm::MCContext::getCOFFSection(v11, a2, a3, a4, a5, (std::string::size_type)"", 0, 0, 0xFFFFFFFF, 0);
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)v10 + 168))(v10, COFFSection, 0);
    return 0;
  }
  else
  {
    char v14 = "unexpected token in section switching directive";
    __int16 v15 = 259;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)&v14, 0, 0);
  }
}

uint64_t sub_1CD3873C4(uint64_t a1)
{
  return sub_1CD387234(a1, ".data", 5uLL, -1073741760, 19);
}

uint64_t sub_1CD3873E0(uint64_t a1)
{
  return sub_1CD387234(a1, ".bss", 4uLL, -1073741696, 15);
}

void sub_1CD387400()
{
}

uint64_t sub_1CD387414(uint64_t result, uint64_t a2)
{
  *(void *)(result + 8) = a2;
  return result;
}

uint64_t getOSTypeFromPlatform(int a1)
{
  return dword_1CFB33BA0[a1 - 1];
}

void sub_1CD387434()
{
}

uint64_t sub_1CD387448(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = a2;
  (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(*(void *)a2 + 16))(a2, ".alt_entry", 10, a1, sub_1CD38893C);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".desc", 5, a1, sub_1CD388AFC);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t)))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), ".indirect_symbol", 16, a1, sub_1CD388D50);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".lsym", 5, a1, sub_1CD388FAC);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".subsections_via_symbols", 24, a1, sub_1CD389188);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t)))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), ".dump", 5, a1, sub_1CD389290);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t)))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), ".load", 5, a1, sub_1CD389290);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)()))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), ".section", 8, a1, sub_1CD389448);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".pushsection", 12, a1, sub_1CD389CD0);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".popsection", 11, a1, sub_1CD389D5C);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".previous", 9, a1, sub_1CD389DE4);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t, uint64_t, uint64_t, char *)))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), ".secure_log_unique", 18, a1, sub_1CD389EDC);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".secure_log_reset", 17, a1, sub_1CD38A408);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".tbss", 5, a1, sub_1CD38A4F0);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".zerofill", 9, a1, sub_1CD38A9C8);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".data_region", 12, a1, sub_1CD38B0E8);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".end_data_region", 16, a1, sub_1CD38B360);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".bss", 4, a1, sub_1CD38B468);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".const", 6, a1, sub_1CD38B6AC);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".const_data", 11, a1, sub_1CD38B6D4);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".constructor", 12, a1, sub_1CD38B6FC);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".cstring", 8, a1, sub_1CD38B724);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".data", 5, a1, sub_1CD38B74C);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".destructor", 11, a1, sub_1CD38B774);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".dyld", 5, a1, sub_1CD38B79C);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".fvmlib_init0", 13, a1, sub_1CD38B7C4);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".fvmlib_init1", 13, a1, sub_1CD38B7EC);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".lazy_symbol_pointer", 20, a1, sub_1CD38B814);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t, uint64_t, uint64_t)))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), ".linker_option", 14, a1, sub_1CD38B83C);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t, uint64_t, uint64_t)))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), ".dyld_lib", 9, a1, sub_1CD38BB20);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".literal16", 10, a1, sub_1CD38BD34);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".literal4", 9, a1, sub_1CD38BD5C);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".literal8", 9, a1, sub_1CD38BD84);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".mod_init_func", 14, a1, sub_1CD38BDAC);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".mod_term_func", 14, a1, sub_1CD38BDD4);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".non_lazy_symbol_pointer", 24, a1, sub_1CD38BDFC);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".thread_local_variable_pointer", 30, a1, sub_1CD38BE24);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".objc_cat_cls_meth", 18, a1, sub_1CD38BE4C);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".objc_cat_inst_meth", 19, a1, sub_1CD38BE74);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".objc_category", 14, a1, sub_1CD38BE9C);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".objc_class", 11, a1, sub_1CD38BEC4);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".objc_class_names", 17, a1, sub_1CD38BEEC);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".objc_class_vars", 16, a1, sub_1CD38BF14);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".objc_cls_meth", 14, a1, sub_1CD38BF3C);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".objc_cls_refs", 14, a1, sub_1CD38BF64);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".objc_inst_meth", 15, a1, sub_1CD38BF90);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".objc_instance_vars", 19, a1, sub_1CD38BFB8);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".objc_message_refs", 18, a1, sub_1CD38BFE0);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".objc_meta_class", 16, a1, sub_1CD38C00C);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".objc_meth_var_names", 20, a1, sub_1CD38C034);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".objc_meth_var_types", 20, a1, sub_1CD38C05C);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".objc_module_info", 17, a1, sub_1CD38C084);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".objc_protocol", 14, a1, sub_1CD38C0AC);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".objc_selector_strs", 19, a1, sub_1CD38C0D4);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".objc_string_object", 19, a1, sub_1CD38C0FC);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".objc_symbols", 13, a1, sub_1CD38C124);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".picsymbol_stub", 15, a1, sub_1CD38C14C);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".static_const", 13, a1, sub_1CD38C178);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".static_data", 12, a1, sub_1CD38C1A0);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".symbol_stub", 12, a1, sub_1CD38C1C8);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".tdata", 6, a1, sub_1CD38C1F4);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".text", 5, a1, sub_1CD38C21C);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".thread_init_func", 17, a1, sub_1CD38C244);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".tlv", 4, a1, sub_1CD38C26C);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".ident", 6, a1, sub_1CD38C294);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t, void *, uint64_t, uint64_t)))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), ".bridgeos_version_min", 21, a1, sub_1CD38C2D4);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t, void *, uint64_t, uint64_t)))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), ".watchos_version_min", 20, a1, sub_1CD38CED0);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t, void *, uint64_t, uint64_t)))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), ".tvos_version_min", 17, a1, sub_1CD38D0C4);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t, void *, uint64_t, uint64_t)))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), ".ios_version_min", 16, a1, sub_1CD38D0CC);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t, void *, uint64_t, uint64_t)))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), ".macosx_version_min", 19, a1, sub_1CD38D0D4);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t, void *, uint64_t, uint64_t)))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), ".build_version", 14, a1, sub_1CD38D0DC);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".ptrauth_abi_version", 20, a1, sub_1CD38D6CC);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".ptrauth_kernel_abi_version", 27, a1, sub_1CD38D818);
  uint64_t result = (*(uint64_t (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)()))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), ".cg_profile", 11, a1, llvm::MCAsmParserExtension::ParseDirectiveCGProfile);
  *(void *)(a1 + 24) = 0;
  return result;
}

uint64_t sub_1CD38893C(uint64_t a1)
{
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  if ((*(unsigned int (**)(void, unsigned __int8 ***))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v10))
  {
    uint64_t v7 = "expected identifier in directive";
LABEL_12:
    v8[0] = (unsigned __int8 **)v7;
    __int16 v9 = 259;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v8, 0, 0);
  }
  uint64_t v2 = (llvm::MCContext *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
  __int16 v9 = 261;
  v8[0] = v10;
  v8[1] = v11;
  uint64_t Symbol = llvm::MCContext::getOrCreateSymbol(v2, v8);
  unint64_t AssociatedFragment = *(void *)Symbol & 0xFFFFFFFFFFFFFFF8;
  if (!AssociatedFragment && (*(_DWORD *)(Symbol + 8) & 0x1C00) == 0x800)
  {
    *(_DWORD *)(Symbol + 8) |= 4u;
    unint64_t AssociatedFragment = llvm::MCExpr::findAssociatedFragment(*(llvm::MCExpr **)(Symbol + 24));
    *(void *)uint64_t Symbol = *(void *)Symbol & 7 | AssociatedFragment;
  }
  if (AssociatedFragment)
  {
    uint64_t v7 = ".alt_entry must preceed symbol definition";
    goto LABEL_12;
  }
  uint64_t v5 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
  if (((*(uint64_t (**)(void))(v5 + 304))() & 1) == 0)
  {
    uint64_t v7 = "unable to emit symbol attribute";
    goto LABEL_12;
  }
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  return 0;
}

uint64_t sub_1CD388AFC(uint64_t a1)
{
  unint64_t v8 = 0;
  __int16 v9 = 0;
  if ((*(unsigned int (**)(void, unsigned __int8 ***))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v8))
  {
    uint64_t v5 = "expected identifier in directive";
  }
  else
  {
    uint64_t v2 = (llvm::MCContext *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
    __int16 v7 = 261;
    v6[0] = v8;
    v6[1] = v9;
    llvm::MCContext::getOrCreateSymbol(v2, v6);
    if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 25)
    {
      (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
      if ((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 256))()) {
        return 1;
      }
      if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 9)
      {
        (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
        uint64_t v4 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
        (*(void (**)(void))(v4 + 312))();
        return 0;
      }
    }
    uint64_t v5 = "unexpected token in '.desc' directive";
  }
  v6[0] = (unsigned __int8 **)v5;
  __int16 v7 = 259;
  return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v6, 0, 0);
}

uint64_t sub_1CD388D50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
  int v7 = *(unsigned __int8 *)(*(void *)(*(void *)(v6 + 112) + 32 * *(unsigned int *)(v6 + 120) - 32) + 240);
  if ((v7 - 6) >= 3 && v7 != 20)
  {
    v15[0] = (unsigned __int8 **)"indirect symbol not in a symbol pointer or stub section";
    __int16 v16 = 259;
    return llvm::MCAsmParser::Error(*(void *)(a1 + 8), a4, (uint64_t)v15, 0, 0);
  }
  uint64_t v13 = 0;
  char v14 = 0;
  if ((*(unsigned int (**)(void, unsigned __int8 ***))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v13))
  {
    uint64_t v11 = "expected identifier in .indirect_symbol directive";
LABEL_15:
    v15[0] = (unsigned __int8 **)v11;
    __int16 v16 = 259;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v15, 0, 0);
  }
  __int16 v9 = (llvm::MCContext *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
  __int16 v16 = 261;
  v15[0] = v13;
  v15[1] = v14;
  if (*(unsigned char *)(llvm::MCContext::getOrCreateSymbol(v9, v15) + 8))
  {
    uint64_t v11 = "non-local symbol required in directive";
    goto LABEL_15;
  }
  uint64_t v10 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
  if ((*(uint64_t (**)(void))(v10 + 304))())
  {
    if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 9)
    {
      (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
      return 0;
    }
    uint64_t v11 = "unexpected token in '.indirect_symbol' directive";
    goto LABEL_15;
  }
  __int16 v16 = 1283;
  v15[0] = (unsigned __int8 **)"unable to emit indirect symbol attribute for: ";
  void v15[2] = v13;
  v15[3] = v14;
  return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v15, 0, 0);
}

uint64_t sub_1CD388FAC(uint64_t a1)
{
  unint64_t v8 = 0;
  __int16 v9 = 0;
  if ((*(unsigned int (**)(void, unsigned __int8 ***))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v8))
  {
    uint64_t v4 = "expected identifier in directive";
LABEL_10:
    v6[0] = (unsigned __int8 **)v4;
    __int16 v7 = 259;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v6, 0, 0);
  }
  uint64_t v2 = (llvm::MCContext *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
  __int16 v7 = 261;
  v6[0] = v8;
  v6[1] = v9;
  llvm::MCContext::getOrCreateSymbol(v2, v6);
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 25)
  {
LABEL_9:
    uint64_t v4 = "unexpected token in '.lsym' directive";
    goto LABEL_10;
  }
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  uint64_t v5 = 0;
  v6[0] = 0;
  if (((*(uint64_t (**)(void, uint64_t *, unsigned __int8 ***))(**(void **)(a1 + 8) + 232))(*(void *)(a1 + 8), &v5, v6) & 1) == 0)
  {
    if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 9)
    {
      (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
      uint64_t v4 = "directive '.lsym' is unsupported";
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  return 1;
}

uint64_t sub_1CD389188(uint64_t a1)
{
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 9)
  {
    (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
    uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 208))(v2, 1);
    return 0;
  }
  else
  {
    uint64_t v4 = "unexpected token in '.subsections_via_symbols' directive";
    __int16 v5 = 259;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)&v4, 0, 0);
  }
}

uint64_t sub_1CD389290(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v7 = a3 == 5 && *(_DWORD *)a2 == 1836409902 && *(unsigned char *)(a2 + 4) == 112;
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 3)
  {
    uint64_t v10 = "expected string in '.dump' or '.load' directive";
LABEL_18:
    v11[0] = v10;
    __int16 v12 = 259;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v11, 0, 0);
  }
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 9)
  {
    uint64_t v10 = "unexpected token in '.dump' or '.load' directive";
    goto LABEL_18;
  }
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  if (v7) {
    unint64_t v8 = "ignoring directive .dump for now";
  }
  else {
    unint64_t v8 = "ignoring directive .load for now";
  }
  v11[0] = v8;
  __int16 v12 = 259;
  return (*(uint64_t (**)(void, uint64_t, void *, void, void))(**(void **)(a1 + 8) + 168))(*(void *)(a1 + 8), a4, v11, 0, 0);
}

uint64_t sub_1CD38944C(uint64_t a1)
{
  uint64_t v2 = *(char **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 96);
  BOOL v75 = 0;
  unint64_t v76 = 0;
  if ((*(unsigned int (**)(void, const void **))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v75))
  {
    __p[0] = "expected identifier after '.section' directive";
    WORD4(v64) = 259;
    return llvm::MCAsmParser::Error(*(void *)(a1 + 8), (uint64_t)v2, (uint64_t)__p, 0, 0);
  }
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 25)
  {
    __p[0] = "unexpected token in '.section' directive";
    WORD4(v64) = 259;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)__p, 0, 0);
  }
  std::string::size_type v3 = v76;
  if (v76 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  uint64_t v4 = v75;
  if (v76 >= 0x17)
  {
    uint64_t v6 = (v76 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v76 | 7) != 0x17) {
      uint64_t v6 = v76 | 7;
    }
    uint64_t v7 = v6 + 1;
    p_dst = (std::string *)operator new(v6 + 1);
    __dst.__r_.__value_.__l.__size_ = v3;
    __dst.__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_10;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v76;
  p_dst = &__dst;
  if (v76) {
LABEL_10:
  }
    memmove(p_dst, v4, v3);
  p_dst->__r_.__value_.__s.__data_[v3] = 0;
  std::string::append(&__dst, ",");
  uint64_t v8 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8));
  __int16 v9 = (char *)(*(uint64_t (**)(uint64_t))(*(void *)v8 + 24))(v8);
  uint64_t v11 = v9;
  unint64_t v12 = v10;
  LOBYTE(v13) = *((unsigned char *)&__dst.__r_.__value_.__s + 23);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    if (!v10) {
      goto LABEL_37;
    }
    std::string::size_type size = __dst.__r_.__value_.__l.__size_;
    std::string::size_type v16 = (__dst.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
    __int16 v15 = (std::string *)__dst.__r_.__value_.__r.__words[0];
    std::string::size_type v13 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  }
  else
  {
    if (!v10) {
      goto LABEL_37;
    }
    std::string::size_type size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
    __int16 v15 = &__dst;
    std::string::size_type v16 = 22;
  }
  unint64_t v17 = v12;
  if (v15 <= (std::string *)v9 && (char *)&v15->__r_.__value_.__l.__data_ + size + 1 > v9)
  {
    sub_1CC028D80(__p, v9, &v9[v12], v12);
    if (v63 >= 0) {
      uint64_t v23 = __p;
    }
    else {
      uint64_t v23 = (void **)__p[0];
    }
    if (v63 >= 0) {
      std::string::size_type v24 = HIBYTE(v63) & 0x7F;
    }
    else {
      std::string::size_type v24 = (std::string::size_type)__p[1];
    }
    std::string::append(&__dst, (const std::string::value_type *)v23, v24);
    if (SHIBYTE(v63) < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    if (v16 - size < v12)
    {
      std::string::__grow_by(&__dst, v16, size + v12 - v16, size, size, 0, 0);
      __dst.__r_.__value_.__l.__size_ = size;
      LOBYTE(v13) = *((unsigned char *)&__dst.__r_.__value_.__s + 23);
    }
    BOOL v19 = (v13 & 0x80u) != 0;
    uint64_t v20 = &__dst;
    if (v19) {
      uint64_t v20 = (std::string *)__dst.__r_.__value_.__r.__words[0];
    }
    unint64_t v21 = (char *)v20 + size;
    do
    {
      char v22 = *v11++;
      *v21++ = v22;
      --v12;
    }
    while (v12);
    unsigned char *v21 = 0;
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      __dst.__r_.__value_.__l.__size_ = size + v17;
    }
    else {
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = (size + v17) & 0x7F;
    }
  }
LABEL_37:
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 9)
  {
    (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v25 = &__dst;
    }
    else {
      uint64_t v25 = (std::string *)__dst.__r_.__value_.__r.__words[0];
    }
    uint64_t v72 = 0;
    unint64_t v73 = 0;
    uint64_t v70 = 0;
    uint64_t v71 = 0;
    int v69 = 0;
    int v68 = 0;
    char v67 = 0;
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v26 = *((unsigned char *)&__dst.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      uint64_t v26 = __dst.__r_.__value_.__l.__size_;
    }
    llvm::MCSectionMachO::ParseSectionSpecifier((uint64_t)v25, v26, &v72, &v70, &v68, &v67, &v69, v56);
    if (v56[0])
    {
      uint64_t v66 = v56[0];
      v56[0] = 0;
      sub_1CD4FB504(&v66, &v60);
      WORD4(v64) = 260;
      __p[0] = &v60;
      uint64_t v40 = llvm::MCAsmParser::Error(*(void *)(a1 + 8), (uint64_t)v2, (uint64_t)__p, 0, 0);
      if (SHIBYTE(v60.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v60.__r_.__value_.__l.__data_);
      }
      if (v66) {
        (*(void (**)(uint64_t))(*(void *)v66 + 8))(v66);
      }
      if (v56[0]) {
        (*(void (**)(void))(*(void *)v56[0] + 8))(v56[0]);
      }
      goto LABEL_91;
    }
    uint64_t v27 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
    uint64_t v28 = v27;
    if (*(char *)(v27 + 47) < 0)
    {
      sub_1CB8BDF7C((uint64_t)__p, *(const void **)(v27 + 24), *(void *)(v27 + 32));
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)(v27 + 24);
      uint64_t v63 = *(void *)(v27 + 40);
    }
    long long v64 = *(_OWORD *)(v28 + 48);
    uint64_t v65 = *(void *)(v28 + 64);
    if ((v64 & 0xFFFFFFFD) == 0x15) {
      goto LABEL_83;
    }
    uint64_t v29 = v70;
    uint64_t v30 = v71;
    if (v71 == 12)
    {
      if (*(void *)v70 != 0x5F74736E6F635F5FLL || *(_DWORD *)(v70 + 8) != 1818324835) {
        goto LABEL_83;
      }
      unint64_t v35 = (unint64_t)"__const" & 0xFF;
      unint64_t v36 = (unint64_t)"__const" & 0xFFFFFFFFFFFFFF00;
      uint64_t v37 = 7;
      if (v2) {
        goto LABEL_74;
      }
    }
    else
    {
      if (v71 != 13) {
        goto LABEL_83;
      }
      if (*(void *)v70 == 0x6F63747865745F5FLL && *(void *)(v70 + 5) == 0x746E5F6C616F6374)
      {
        uint64_t v33 = "__text";
      }
      else
      {
        if (*(void *)v70 != 0x6F63617461645F5FLL || *(void *)(v70 + 5) != 0x746E5F6C616F6361) {
          goto LABEL_83;
        }
        uint64_t v33 = "__data";
      }
      unint64_t v35 = v33;
      unint64_t v36 = (unint64_t)v33 & 0xFFFFFFFFFFFFFF00;
      uint64_t v37 = 6;
      if (v2)
      {
LABEL_74:
        unint64_t v38 = strlen(v2);
        if (v38)
        {
          unsigned __int8 v41 = memchr(v2, 44, v38);
          if (v41)
          {
            uint64_t v42 = v41 - v2;
            goto LABEL_78;
          }
        }
LABEL_77:
        uint64_t v42 = -1;
LABEL_78:
        unint64_t v43 = v35 | v36;
        uint64_t v44 = v42 + 1;
        if (v38 > v42 + 1 && (unint64_t v45 = memchr(&v2[v44], 44, v38 - (v42 + 1))) != 0) {
          uint64_t v46 = v45 - v2;
        }
        else {
          uint64_t v46 = -1;
        }
        unsigned int v47 = &v2[v44];
        int v48 = &v2[v46];
        uint64_t v49 = *(void *)(a1 + 8);
        __int16 v59 = 1283;
        v56[0] = "section \"";
        uint64_t v57 = v29;
        uint64_t v58 = v30;
        v60.__r_.__value_.__r.__words[0] = (std::string::size_type)v56;
        v60.__r_.__value_.__r.__words[2] = (std::string::size_type)"\" is deprecated";
        __int16 v61 = 770;
        (*(void (**)(uint64_t, char *, std::string *, char *, char *))(*(void *)v49 + 168))(v49, v2, &v60, v47, &v2[v46]);
        uint64_t v50 = *(void *)(a1 + 8);
        __int16 v59 = 1283;
        v56[0] = "change section name to \"";
        uint64_t v57 = v43;
        uint64_t v58 = v37;
        v60.__r_.__value_.__r.__words[0] = (std::string::size_type)v56;
        v60.__r_.__value_.__r.__words[2] = (std::string::size_type)"\"";
        __int16 v61 = 770;
        (*(void (**)(uint64_t, char *, std::string *, char *, char *))(*(void *)v50 + 160))(v50, v2, &v60, v47, v48);
LABEL_83:
        if (v73 == 6)
        {
          if (*(_DWORD *)v72 ^ 0x45545F5F | *(unsigned __int16 *)(v72 + 4) ^ 0x5458) {
            int v51 = 19;
          }
          else {
            int v51 = 2;
          }
        }
        else
        {
          int v51 = 19;
        }
        uint64_t v52 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
        uint64_t v53 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
        size_t MachOSection = llvm::MCContext::getMachOSection(v53, v72, v73, v70, v71, v68, v69, v51, 0);
        (*(void (**)(uint64_t, size_t, void))(*(void *)v52 + 168))(v52, MachOSection, 0);
        if (SHIBYTE(v63) < 0) {
          operator delete(__p[0]);
        }
        uint64_t v40 = 0;
        goto LABEL_91;
      }
    }
    unint64_t v38 = 0;
    goto LABEL_77;
  }
  __p[0] = "unexpected token in '.section' directive";
  WORD4(v64) = 259;
  uint64_t v40 = llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)__p, 0, 0);
LABEL_91:
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  return v40;
}

uint64_t sub_1CD389CD0(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
  sub_1CD6AD2C8(v2);
  uint64_t v3 = sub_1CD38944C(a1);
  if (v3)
  {
    uint64_t v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    sub_1CCBC2468(v4);
  }
  return v3;
}

uint64_t sub_1CD389D5C(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
  if (sub_1CCBC2468(v2)) {
    return 0;
  }
  uint64_t v4 = ".popsection without corresponding .pushsection";
  __int16 v5 = 259;
  return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)&v4, 0, 0);
}

uint64_t sub_1CD389DE4(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
  uint64_t v3 = *(unsigned int *)(v2 + 120);
  if (v3 && (v4 = *(void *)(v2 + 112) + 32 * v3, (uint64_t v5 = *(void *)(v4 - 16)) != 0))
  {
    uint64_t v6 = *(void *)(v4 - 8);
    uint64_t v7 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 168))(v7, v5, v6);
    return 0;
  }
  else
  {
    __int16 v9 = ".previous without corresponding .section";
    __int16 v10 = 259;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)&v9, 0, 0);
  }
}

uint64_t sub_1CD389EDC(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v6 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 200))(*(void *)(a1 + 8));
  size_t v8 = v7;
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 9)
  {
    v34[0] = "unexpected token in '.secure_log_unique' directive";
    __int16 v35 = 259;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v34, 0, 0);
  }
  if (*(unsigned char *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8)) + 1264))
  {
    char v14 = ".secure_log_unique specified multiple times";
    goto LABEL_10;
  }
  uint64_t v9 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
  char v10 = *(unsigned char *)(v9 + 1255);
  int v11 = v10;
  uint64_t v12 = v10 & 0x7F;
  if (v11 >= 0) {
    uint64_t v13 = v12;
  }
  else {
    uint64_t v13 = *(void *)(v9 + 1240);
  }
  if (!v13)
  {
    char v14 = ".secure_log_unique used but AS_SECURE_LOG_FILE environment variable unset.";
LABEL_10:
    v34[0] = v14;
    __int16 v35 = 259;
    return llvm::MCAsmParser::Error(*(void *)(a1 + 8), (uint64_t)a4, (uint64_t)v34, 0, 0);
  }
  uint64_t v18 = *(llvm::raw_ostream **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8))
                              + 1256);
  if (!v18)
  {
    v33.__val_ = 0;
    v33.__cat_ = std::system_category();
    operator new();
  }
  BOOL v19 = (uint64_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8));
  int BufferContainingLoc = llvm::SourceMgr::FindBufferContainingLoc(v19, (unint64_t)a4);
  uint64_t v21 = *(void *)(*(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8))
                  + 24 * (BufferContainingLoc - 1));
  uint64_t v23 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)v21 + 16))(v21);
  size_t v24 = v22;
  uint64_t v25 = (unsigned char *)*((void *)v18 + 4);
  if (v22 <= *((void *)v18 + 3) - (void)v25)
  {
    if (v22)
    {
      memcpy(v25, v23, v22);
      uint64_t v25 = (unsigned char *)(*((void *)v18 + 4) + v24);
      *((void *)v18 + 4) = v25;
    }
  }
  else
  {
    llvm::raw_ostream::write(v18, (const char *)v23, v22);
    uint64_t v25 = (unsigned char *)*((void *)v18 + 4);
  }
  if (*((unsigned char **)v18 + 3) == v25)
  {
    llvm::raw_ostream::write(v18, ":", 1uLL);
  }
  else
  {
    *uint64_t v25 = 58;
    ++*((void *)v18 + 4);
  }
  uint64_t v26 = (uint64_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8));
  unsigned int LineAndColumn = llvm::SourceMgr::getLineAndColumn(v26, a4, BufferContainingLoc);
  uint64_t v28 = sub_1CD098D14(v18, LineAndColumn, 0, 0, 0);
  uint64_t v29 = (unsigned char *)*((void *)v18 + 4);
  if (*((unsigned char **)v18 + 3) == v29)
  {
    uint64_t v28 = llvm::raw_ostream::write(v18, ":", 1uLL);
  }
  else
  {
    unsigned char *v29 = 58;
    ++*((void *)v18 + 4);
  }
  uint64_t v30 = llvm::Twine::printOneChild(v28, v18, v6, v8, 5);
  llvm::Twine::printOneChild(v30, v18, (uint64_t)"\n", v31, 3);
  uint64_t v32 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
  uint64_t v16 = 0;
  *(unsigned char *)(v32 + 1264) = 1;
  return v16;
}

uint64_t sub_1CD38A408(uint64_t a1)
{
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 9)
  {
    (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
    uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
    uint64_t result = 0;
    *(unsigned char *)(v2 + 1264) = 0;
  }
  else
  {
    uint64_t v4 = "unexpected token in '.secure_log_reset' directive";
    __int16 v5 = 259;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)&v4, 0, 0);
  }
  return result;
}

uint64_t sub_1CD38A4F0(uint64_t a1)
{
  uint64_t v2 = *(void *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 96);
  uint64_t v13 = 0;
  char v14 = 0;
  if ((*(unsigned int (**)(void, unsigned __int8 ***))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v13))
  {
    char v10 = "expected identifier in directive";
LABEL_14:
    v11[0] = (unsigned __int8 **)v10;
    __int16 v12 = 259;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v11, 0, 0);
  }
  uint64_t v3 = (llvm::MCContext *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
  __int16 v12 = 261;
  v11[0] = v13;
  v11[1] = v14;
  uint64_t Symbol = llvm::MCContext::getOrCreateSymbol(v3, v11);
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 25)
  {
    char v10 = "unexpected token in directive";
    goto LABEL_14;
  }
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8));
  if ((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 256))()) {
    return 1;
  }
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 25)
  {
    (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
    (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8));
    if ((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 256))()) {
      return 1;
    }
  }
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 9)
  {
    char v10 = "unexpected token in '.tbss' directive";
    goto LABEL_14;
  }
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  unint64_t AssociatedFragment = *(void *)Symbol & 0xFFFFFFFFFFFFFFF8;
  if (!AssociatedFragment && (*(_DWORD *)(Symbol + 8) & 0x1C00) == 0x800)
  {
    *(_DWORD *)(Symbol + 8) |= 4u;
    unint64_t AssociatedFragment = llvm::MCExpr::findAssociatedFragment(*(llvm::MCExpr **)(Symbol + 24));
    *(void *)uint64_t Symbol = *(void *)Symbol & 7 | AssociatedFragment;
  }
  if (AssociatedFragment)
  {
    v11[0] = (unsigned __int8 **)"invalid symbol redefinition";
    __int16 v12 = 259;
    return llvm::MCAsmParser::Error(*(void *)(a1 + 8), v2, (uint64_t)v11, 0, 0);
  }
  else
  {
    uint64_t v7 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    uint64_t v8 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
    size_t MachOSection = llvm::MCContext::getMachOSection(v8, (uint64_t)"__DATA", 6uLL, (uint64_t)"__thread_bss", 12, 18, 0, 12, 0);
    (*(void (**)(uint64_t, size_t, uint64_t, void, uint64_t))(*(void *)v7 + 480))(v7, MachOSection, Symbol, 0, 1);
    return 0;
  }
}

uint64_t sub_1CD38A9C8(uint64_t a1)
{
  uint64_t v23 = 0;
  unint64_t v24 = 0;
  if ((*(unsigned int (**)(void, uint64_t *))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v23))
  {
    uint64_t v16 = "expected segment name after '.zerofill' directive";
    goto LABEL_23;
  }
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 25) {
    goto LABEL_18;
  }
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t v2 = *(void *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 96);
  if ((*(unsigned int (**)(void, uint64_t *))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v19))
  {
    uint64_t v16 = "expected section name after comma in '.zerofill' directive";
    goto LABEL_23;
  }
  int v3 = **(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8);
  uint64_t v4 = **(void **)(a1 + 8);
  if (v3 == 9)
  {
    uint64_t v5 = (*(uint64_t (**)(void))(v4 + 56))();
    uint64_t v6 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
    size_t MachOSection = llvm::MCContext::getMachOSection(v6, v23, v24, v19, v20, 1, 0, 15, 0);
    (*(void (**)(uint64_t, size_t, void, void, void, uint64_t))(*(void *)v5 + 472))(v5, MachOSection, 0, 0, 0, v2);
    return 0;
  }
  if (**(_DWORD **)((*(uint64_t (**)(void))(v4 + 40))() + 8) != 25) {
    goto LABEL_18;
  }
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  uint64_t v9 = *(void *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 96);
  unint64_t v17 = 0;
  uint64_t v18 = 0;
  if ((*(unsigned int (**)(void, unsigned __int8 ***))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v17))
  {
    uint64_t v16 = "expected identifier in directive";
    goto LABEL_23;
  }
  char v10 = (llvm::MCContext *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
  __int16 v22 = 261;
  v21[0] = v17;
  v21[1] = v18;
  uint64_t Symbol = llvm::MCContext::getOrCreateSymbol(v10, v21);
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 25)
  {
LABEL_18:
    uint64_t v16 = "unexpected token in directive";
LABEL_23:
    v21[0] = (unsigned __int8 **)v16;
    __int16 v22 = 259;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v21, 0, 0);
  }
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8));
  if ((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 256))()) {
    return 1;
  }
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 25)
  {
    (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
    (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8));
    if ((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 256))()) {
      return 1;
    }
  }
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 9)
  {
    uint64_t v16 = "unexpected token in '.zerofill' directive";
    goto LABEL_23;
  }
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  unint64_t AssociatedFragment = *(void *)Symbol & 0xFFFFFFFFFFFFFFF8;
  if (!AssociatedFragment && (*(_DWORD *)(Symbol + 8) & 0x1C00) == 0x800)
  {
    *(_DWORD *)(Symbol + 8) |= 4u;
    unint64_t AssociatedFragment = llvm::MCExpr::findAssociatedFragment(*(llvm::MCExpr **)(Symbol + 24));
    *(void *)uint64_t Symbol = *(void *)Symbol & 7 | AssociatedFragment;
  }
  if (!AssociatedFragment)
  {
    uint64_t v13 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    uint64_t v14 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
    size_t v15 = llvm::MCContext::getMachOSection(v14, v23, v24, v19, v20, 1, 0, 15, 0);
    (*(void (**)(uint64_t, size_t, uint64_t, void, uint64_t, uint64_t))(*(void *)v13 + 472))(v13, v15, Symbol, 0, 1, v2);
    return 0;
  }
  v21[0] = (unsigned __int8 **)"invalid symbol redefinition";
  __int16 v22 = 259;
  return llvm::MCAsmParser::Error(*(void *)(a1 + 8), v9, (uint64_t)v21, 0, 0);
}

uint64_t sub_1CD38B0E8(uint64_t a1)
{
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 9)
  {
    (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
    uint64_t v2 = *(void (**)(void))(*(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8))
                          + 232);
LABEL_15:
    v2();
    return 0;
  }
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t v3 = *(void *)(*(void *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8))
                             + 8)
                 + 8);
  if (!(*(unsigned int (**)(void, uint64_t *))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v8))
  {
    if (v9 == 4)
    {
      if (*(_DWORD *)v8 != 909210730 && *(_DWORD *)v8 != 842232938)
      {
LABEL_16:
        v6[0] = "unknown region type in '.data_region' directive";
        __int16 v7 = 259;
        return llvm::MCAsmParser::Error(*(void *)(a1 + 8), v3, (uint64_t)v6, 0, 0);
      }
    }
    else
    {
      if (v9 != 3) {
        goto LABEL_16;
      }
      if (*(_WORD *)v8 != 29802 || *(unsigned char *)(v8 + 2) != 56) {
        goto LABEL_16;
      }
    }
    (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
    uint64_t v2 = *(void (**)(void))(*(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8))
                          + 232);
    goto LABEL_15;
  }
  v6[0] = "expected region type after '.data_region' directive";
  __int16 v7 = 259;
  return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v6, 0, 0);
}

uint64_t sub_1CD38B360(uint64_t a1)
{
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 9)
  {
    (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
    uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 232))(v2, 4);
    return 0;
  }
  else
  {
    uint64_t v4 = "unexpected token in '.end_data_region' directive";
    __int16 v5 = 259;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)&v4, 0, 0);
  }
}

uint64_t sub_1CD38B468(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__DATA", 6uLL, (uint64_t)"__bss", 5, 0, 0, 0);
}

uint64_t sub_1CD38B490(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7, int a8)
{
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 9)
  {
    (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
    uint64_t v16 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    uint64_t v17 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
    if (a6 < 0) {
      int v18 = 2;
    }
    else {
      int v18 = 19;
    }
    size_t MachOSection = llvm::MCContext::getMachOSection(v17, a2, a3, a4, a5, a6, a8, v18, 0);
    (*(void (**)(uint64_t, size_t, void))(*(void *)v16 + 168))(v16, MachOSection, 0);
    if (a7)
    {
      uint64_t v20 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
      (*(void (**)(void))(v20 + 640))();
    }
    return 0;
  }
  else
  {
    __int16 v22 = "unexpected token in section switching directive";
    __int16 v23 = 259;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)&v22, 0, 0);
  }
}

uint64_t sub_1CD38B6AC(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__TEXT", 6uLL, (uint64_t)"__const", 7, 0, 0, 0);
}

uint64_t sub_1CD38B6D4(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__DATA", 6uLL, (uint64_t)"__const", 7, 0, 0, 0);
}

uint64_t sub_1CD38B6FC(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__TEXT", 6uLL, (uint64_t)"__constructor", 13, 0, 0, 0);
}

uint64_t sub_1CD38B724(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__TEXT", 6uLL, (uint64_t)"__cstring", 9, 2, 0, 0);
}

uint64_t sub_1CD38B74C(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__DATA", 6uLL, (uint64_t)"__data", 6, 0, 0, 0);
}

uint64_t sub_1CD38B774(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__TEXT", 6uLL, (uint64_t)"__destructor", 12, 0, 0, 0);
}

uint64_t sub_1CD38B79C(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__DATA", 6uLL, (uint64_t)"__dyld", 6, 0, 0, 0);
}

uint64_t sub_1CD38B7C4(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__TEXT", 6uLL, (uint64_t)"__fvmlib_init0", 14, 0, 0, 0);
}

uint64_t sub_1CD38B7EC(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__TEXT", 6uLL, (uint64_t)"__fvmlib_init1", 14, 0, 0, 0);
}

uint64_t sub_1CD38B814(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__DATA", 6uLL, (uint64_t)"__la_symbol_ptr", 15, 7, 4, 0);
}

uint64_t sub_1CD38B83C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v21[12] = *MEMORY[0x1E4F143B8];
  uint64_t v19 = v21;
  uint64_t v20 = 0x400000000;
  do
  {
    while (1)
    {
      if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 3)
      {
        v12[0] = "expected string in '";
        uint64_t v13 = a2;
        uint64_t v14 = a3;
        __int16 v15 = 1283;
        v16[0] = v12;
        uint64_t v17 = "' directive";
        __int16 v18 = 770;
        char v3 = llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v16, 0, 0);
        goto LABEL_19;
      }
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v11 = 0;
      if ((*(uint64_t (**)(void, void **))(**(void **)(a1 + 8) + 208))(*(void *)(a1 + 8), __p))
      {
        char v3 = 1;
LABEL_5:
        int v7 = 1;
        goto LABEL_6;
      }
      sub_1CD504070((uint64_t)&v19, (unint64_t)__p);
      if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 9)
      {
        int v7 = 3;
      }
      else
      {
        if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 25)
        {
          v12[0] = "unexpected token in '";
          uint64_t v13 = a2;
          uint64_t v14 = a3;
          __int16 v15 = 1283;
          v16[0] = v12;
          uint64_t v17 = "' directive";
          __int16 v18 = 770;
          char v3 = llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v16, 0, 0);
          goto LABEL_5;
        }
        (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
        int v7 = 0;
      }
LABEL_6:
      if (SHIBYTE(v11) < 0) {
        break;
      }
      if (v7) {
        goto LABEL_16;
      }
    }
    operator delete(__p[0]);
  }
  while (!v7);
LABEL_16:
  if (v7 == 3)
  {
    uint64_t v8 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    (*(void (**)(uint64_t, void *, void))(*(void *)v8 + 216))(v8, v19, v20);
    char v3 = 0;
  }
LABEL_19:
  sub_1CC076978((void **)&v19);
  return v3 & 1;
}

uint64_t sub_1CD38BB20(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 3)
  {
    long long __p = 0;
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    if ((*(uint64_t (**)(void, void **))(**(void **)(a1 + 8) + 208))(*(void *)(a1 + 8), &__p))
    {
      uint64_t v6 = 1;
    }
    else if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 9)
    {
      (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
      uint64_t v7 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
      if (v13 >= 0) {
        p_p = &__p;
      }
      else {
        p_p = __p;
      }
      if (v13 >= 0) {
        uint64_t v9 = HIBYTE(v13) & 0x7F;
      }
      else {
        uint64_t v9 = v12;
      }
      (*(void (**)(uint64_t, void *, uint64_t))(*(void *)v7 + 224))(v7, p_p, v9);
      uint64_t v6 = 0;
    }
    else
    {
      v16[0] = "unexpected token in '.dyld_lib' directive";
      __int16 v17 = 259;
      uint64_t v6 = llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v16, 0, 0);
    }
    if (SHIBYTE(v13) < 0) {
      operator delete(__p);
    }
  }
  else
  {
    long long __p = "expected string in '";
    uint64_t v13 = a2;
    uint64_t v14 = a3;
    __int16 v15 = 1283;
    v16[0] = &__p;
    void v16[2] = "' directive";
    __int16 v17 = 770;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v16, 0, 0);
  }
  return v6;
}

uint64_t sub_1CD38BD34(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__TEXT", 6uLL, (uint64_t)"__literal16", 11, 14, 16, 0);
}

uint64_t sub_1CD38BD5C(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__TEXT", 6uLL, (uint64_t)"__literal4", 10, 3, 4, 0);
}

uint64_t sub_1CD38BD84(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__TEXT", 6uLL, (uint64_t)"__literal8", 10, 4, 8, 0);
}

uint64_t sub_1CD38BDAC(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__DATA", 6uLL, (uint64_t)"__mod_init_func", 15, 9, 4, 0);
}

uint64_t sub_1CD38BDD4(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__DATA", 6uLL, (uint64_t)"__mod_term_func", 15, 10, 4, 0);
}

uint64_t sub_1CD38BDFC(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__DATA", 6uLL, (uint64_t)"__nl_symbol_ptr", 15, 6, 4, 0);
}

uint64_t sub_1CD38BE24(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__DATA", 6uLL, (uint64_t)"__thread_ptr", 12, 20, 4, 0);
}

uint64_t sub_1CD38BE4C(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__OBJC", 6uLL, (uint64_t)"__cat_cls_meth", 14, 0x10000000, 0, 0);
}

uint64_t sub_1CD38BE74(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__OBJC", 6uLL, (uint64_t)"__cat_inst_meth", 15, 0x10000000, 0, 0);
}

uint64_t sub_1CD38BE9C(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__OBJC", 6uLL, (uint64_t)"__category", 10, 0x10000000, 0, 0);
}

uint64_t sub_1CD38BEC4(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__OBJC", 6uLL, (uint64_t)"__class", 7, 0x10000000, 0, 0);
}

uint64_t sub_1CD38BEEC(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__TEXT", 6uLL, (uint64_t)"__cstring", 9, 2, 0, 0);
}

uint64_t sub_1CD38BF14(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__OBJC", 6uLL, (uint64_t)"__class_vars", 12, 0x10000000, 0, 0);
}

uint64_t sub_1CD38BF3C(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__OBJC", 6uLL, (uint64_t)"__cls_meth", 10, 0x10000000, 0, 0);
}

uint64_t sub_1CD38BF64(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__OBJC", 6uLL, (uint64_t)"__cls_refs", 10, 268435461, 4, 0);
}

uint64_t sub_1CD38BF90(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__OBJC", 6uLL, (uint64_t)"__inst_meth", 11, 0x10000000, 0, 0);
}

uint64_t sub_1CD38BFB8(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__OBJC", 6uLL, (uint64_t)"__instance_vars", 15, 0x10000000, 0, 0);
}

uint64_t sub_1CD38BFE0(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__OBJC", 6uLL, (uint64_t)"__message_refs", 14, 268435461, 4, 0);
}

uint64_t sub_1CD38C00C(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__OBJC", 6uLL, (uint64_t)"__meta_class", 12, 0x10000000, 0, 0);
}

uint64_t sub_1CD38C034(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__TEXT", 6uLL, (uint64_t)"__cstring", 9, 2, 0, 0);
}

uint64_t sub_1CD38C05C(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__TEXT", 6uLL, (uint64_t)"__cstring", 9, 2, 0, 0);
}

uint64_t sub_1CD38C084(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__OBJC", 6uLL, (uint64_t)"__module_info", 13, 0x10000000, 0, 0);
}

uint64_t sub_1CD38C0AC(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__OBJC", 6uLL, (uint64_t)"__protocol", 10, 0x10000000, 0, 0);
}

uint64_t sub_1CD38C0D4(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__OBJC", 6uLL, (uint64_t)"__selector_strs", 15, 2, 0, 0);
}

uint64_t sub_1CD38C0FC(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__OBJC", 6uLL, (uint64_t)"__string_object", 15, 0x10000000, 0, 0);
}

uint64_t sub_1CD38C124(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__OBJC", 6uLL, (uint64_t)"__symbols", 9, 0x10000000, 0, 0);
}

uint64_t sub_1CD38C14C(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__TEXT", 6uLL, (uint64_t)"__picsymbol_stub", 16, -2147483640, 0, 26);
}

uint64_t sub_1CD38C178(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__TEXT", 6uLL, (uint64_t)"__static_const", 14, 0, 0, 0);
}

uint64_t sub_1CD38C1A0(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__DATA", 6uLL, (uint64_t)"__static_data", 13, 0, 0, 0);
}

uint64_t sub_1CD38C1C8(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__TEXT", 6uLL, (uint64_t)"__symbol_stub", 13, -2147483640, 0, 16);
}

uint64_t sub_1CD38C1F4(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__DATA", 6uLL, (uint64_t)"__thread_data", 13, 17, 0, 0);
}

uint64_t sub_1CD38C21C(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__TEXT", 6uLL, (uint64_t)"__text", 6, 0x80000000, 0, 0);
}

uint64_t sub_1CD38C244(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__DATA", 6uLL, (uint64_t)"__thread_init", 13, 21, 0, 0);
}

uint64_t sub_1CD38C26C(uint64_t a1)
{
  return sub_1CD38B490(a1, (uint64_t)"__DATA", 6uLL, (uint64_t)"__thread_vars", 13, 19, 0, 0);
}

uint64_t sub_1CD38C294(uint64_t a1)
{
  return 0;
}

uint64_t sub_1CD38C2D4(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v20 = 0;
  unsigned int v19 = 0;
  if (sub_1CD38C468(a1, (_DWORD *)&v20 + 1, &v20, &v19)) {
    return 1;
  }
  unint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t v9 = 0;
  unint64_t v10 = 0;
  uint64_t v11 = *(void *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8);
  if (*(_DWORD *)v11 == 2)
  {
    if (*(void *)(v11 + 16) == 11
      && ((v12 = *(uint64_t **)(v11 + 8), uint64_t v13 = *v12, v14 = *(uint64_t *)((char *)v12 + 3), v13 == 0x737265765F6B6473)
        ? (BOOL v15 = v14 == 0x6E6F69737265765FLL)
        : (BOOL v15 = 0),
          v15))
    {
      if (sub_1CD38C608(a1, &v17)) {
        return 1;
      }
      unint64_t v10 = v17;
      uint64_t v9 = v18;
    }
    else
    {
      uint64_t v9 = 0;
      unint64_t v10 = 0;
    }
  }
  sub_1CD38C70C(a1, a2, a3, 0, 0, a4, 30);
  uint64_t v16 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
  (*(void (**)(uint64_t, uint64_t, void, void, void, unint64_t, uint64_t))(*(void *)v16 + 248))(v16, 5, HIDWORD(v20), v20, v19, v10, v9);
  return 0;
}

uint64_t sub_1CD38C468(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  if (sub_1CD38C8F8(a1, a2, a3, "OS")) {
    return 1;
  }
  *a4 = 0;
  uint64_t v7 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8));
  uint64_t result = 0;
  if (**(_DWORD **)(v7 + 8) != 9)
  {
    uint64_t v8 = *(void *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8);
    if (*(_DWORD *)v8 == 2
      && *(void *)(v8 + 16) == 11
      && ((uint64_t v9 = *(uint64_t **)(v8 + 8), v10 = *v9, v11 = *(uint64_t *)((char *)v9 + 3), v10 == 0x737265765F6B6473)
        ? (BOOL v12 = v11 == 0x6E6F69737265765FLL)
        : (BOOL v12 = 0),
          v12))
    {
      return 0;
    }
    else if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 25)
    {
      return sub_1CD38CCD8(a1, a4, "OS update");
    }
    else
    {
      uint64_t v13 = "invalid OS update specifier, comma expected";
      __int16 v14 = 259;
      return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)&v13, 0, 0);
    }
  }
  return result;
}

uint64_t sub_1CD38C608(uint64_t a1, unint64_t *a2)
{
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  uint64_t v8 = 0;
  if (sub_1CD38C8F8(a1, (_DWORD *)&v8 + 1, &v8, "SDK")) {
    return 1;
  }
  unint64_t v5 = HIDWORD(v8) | ((unint64_t)v8 << 32);
  *a2 = v5 | 0x8000000000000000;
  a2[1] = 0;
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 25) {
    return 0;
  }
  unsigned int v7 = 0;
  if (sub_1CD38CCD8(a1, &v7, "SDK subminor")) {
    return 1;
  }
  uint64_t result = 0;
  uint64_t v6 = v7 | 0x80000000;
  *a2 = v5 | 0x8000000000000000;
  a2[1] = v6;
  return result;
}

uint64_t sub_1CD38C70C(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
  if (*(_DWORD *)(result + 60) != a7)
  {
    BOOL v15 = (llvm::Triple *)(result + 24);
    if (a5)
    {
      v20[0] = 32;
      uint64_t v20[2] = a4;
      v20[3] = a5;
      __int16 v21 = 1287;
      __int16 v22 = a2;
      uint64_t v23 = a3;
      unint64_t v24 = v20;
      char v16 = 2;
      a2 = &v22;
      __int16 v25 = 517;
    }
    else
    {
      __int16 v21 = 257;
      __int16 v22 = a2;
      uint64_t v23 = a3;
      __int16 v25 = 261;
      char v16 = 5;
    }
    v26[0] = a2;
    v26[1] = a3;
    void v26[2] = " used while targeting ";
    char v27 = v16;
    char v28 = 3;
    uint64_t OSName = llvm::Triple::getOSName(v15);
    v29[0] = v26;
    v29[2] = OSName;
    uint64_t v29[3] = v18;
    __int16 v30 = 1282;
    uint64_t result = (*(uint64_t (**)(void, uint64_t, void *, void, void))(**(void **)(a1 + 8) + 168))(*(void *)(a1 + 8), a6, v29, 0, 0);
  }
  if (*(void *)(a1 + 24))
  {
    v29[0] = "overriding previous version directive";
    __int16 v30 = 259;
    (*(void (**)(void, uint64_t, void *, void, void))(**(void **)(a1 + 8) + 168))(*(void *)(a1 + 8), a6, v29, 0, 0);
    uint64_t v19 = *(void *)(a1 + 24);
    v29[0] = "previous definition is here";
    __int16 v30 = 259;
    uint64_t result = (*(uint64_t (**)(void, uint64_t, void *, void, void))(**(void **)(a1 + 8) + 160))(*(void *)(a1 + 8), v19, v29, 0, 0);
  }
  *(void *)(a1 + 24) = a6;
  return result;
}

uint64_t sub_1CD38C8F8(uint64_t a1, _DWORD *a2, _DWORD *a3, const char *a4)
{
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 4)
  {
    uint64_t v8 = *(void *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8);
    uint64_t v9 = (void *)(v8 + 24);
    if (*(_DWORD *)(v8 + 32) >= 0x41u) {
      uint64_t v9 = (void *)*v9;
    }
    uint64_t v10 = (void *)*v9;
    if ((unint64_t)(v10 - 0x2000) <= 0xFFFFFFFFFFFF0000)
    {
      int v18 = *(unsigned __int8 *)a4;
      if (*a4)
      {
        v26[0] = "invalid ";
        char v27 = a4;
        __int16 v28 = 771;
        char v19 = 2;
      }
      else
      {
        v26[0] = "invalid ";
        __int16 v28 = 259;
        char v19 = 3;
      }
      BOOL v23 = v18 == 0;
      unint64_t v24 = (const char *)v26;
      if (v23) {
        unint64_t v24 = "invalid ";
      }
      __int16 v25 = " major version number";
    }
    else
    {
      *a2 = v10;
      (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
      if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 25)
      {
        if (*a4)
        {
          uint64_t v29 = a4;
          __int16 v30 = " minor version number required, comma expected";
          __int16 v20 = 771;
        }
        else
        {
          uint64_t v29 = " minor version number required, comma expected";
          __int16 v20 = 259;
        }
        __int16 v31 = v20;
        return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)&v29, 0, 0);
      }
      (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
      if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 4)
      {
        uint64_t v11 = *(void *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8);
        BOOL v12 = (unint64_t *)(v11 + 24);
        if (*(_DWORD *)(v11 + 32) >= 0x41u) {
          BOOL v12 = (unint64_t *)*v12;
        }
        unint64_t v13 = *v12;
        if (v13 < 0x100)
        {
          *a3 = v13;
          (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
          return 0;
        }
        int v22 = *(unsigned __int8 *)a4;
        if (*a4)
        {
          v26[0] = "invalid ";
          char v27 = a4;
          __int16 v28 = 771;
          char v19 = 2;
        }
        else
        {
          v26[0] = "invalid ";
          __int16 v28 = 259;
          char v19 = 3;
        }
        BOOL v23 = v22 == 0;
        unint64_t v24 = (const char *)v26;
        if (v23) {
          unint64_t v24 = "invalid ";
        }
        __int16 v25 = " minor version number";
      }
      else
      {
        int v21 = *(unsigned __int8 *)a4;
        if (*a4)
        {
          v26[0] = "invalid ";
          char v27 = a4;
          __int16 v28 = 771;
          char v19 = 2;
        }
        else
        {
          v26[0] = "invalid ";
          __int16 v28 = 259;
          char v19 = 3;
        }
        BOOL v23 = v21 == 0;
        unint64_t v24 = (const char *)v26;
        if (v23) {
          unint64_t v24 = "invalid ";
        }
        __int16 v25 = " minor version number, integer expected";
      }
    }
    uint64_t v29 = v24;
    __int16 v30 = v25;
    LOBYTE(v31) = v19;
  }
  else
  {
    int v15 = *(unsigned __int8 *)a4;
    char v16 = "invalid ";
    if (*a4)
    {
      v26[0] = "invalid ";
      char v27 = a4;
      __int16 v28 = 771;
      char v17 = 2;
    }
    else
    {
      v26[0] = "invalid ";
      __int16 v28 = 259;
      char v17 = 3;
    }
    if (v15) {
      char v16 = (const char *)v26;
    }
    uint64_t v29 = v16;
    __int16 v30 = " major version number, integer expected";
    LOBYTE(v31) = v17;
  }
  HIBYTE(v31) = 3;
  return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)&v29, 0, 0);
}

uint64_t sub_1CD38CCD8(uint64_t a1, _DWORD *a2, unsigned char *a3)
{
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 4)
  {
    int v10 = *a3;
    uint64_t v11 = "invalid ";
    if (*a3)
    {
      v17[0] = "invalid ";
      int v18 = a3;
      __int16 v19 = 771;
      char v12 = 2;
    }
    else
    {
      v17[0] = "invalid ";
      __int16 v19 = 259;
      char v12 = 3;
    }
    if (v10) {
      uint64_t v11 = (const char *)v17;
    }
    __int16 v20 = v11;
    int v21 = " version number, integer expected";
    char v22 = v12;
    goto LABEL_19;
  }
  uint64_t v6 = *(void *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8);
  unsigned int v7 = (unint64_t *)(v6 + 24);
  if (*(_DWORD *)(v6 + 32) >= 0x41u) {
    unsigned int v7 = (unint64_t *)*v7;
  }
  unint64_t v8 = *v7;
  if (v8 >= 0x100)
  {
    int v13 = *a3;
    if (*a3)
    {
      v17[0] = "invalid ";
      int v18 = a3;
      __int16 v19 = 771;
      char v14 = 2;
    }
    else
    {
      v17[0] = "invalid ";
      __int16 v19 = 259;
      char v14 = 3;
    }
    BOOL v15 = v13 == 0;
    char v16 = (const char *)v17;
    if (v15) {
      char v16 = "invalid ";
    }
    __int16 v20 = v16;
    int v21 = " version number";
    char v22 = v14;
LABEL_19:
    char v23 = 3;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)&v20, 0, 0);
  }
  *a2 = v8;
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  return 0;
}

uint64_t sub_1CD38CED0(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  return sub_1CD38CED8(a1, a2, a3, a4, 3);
}

uint64_t sub_1CD38CED8(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v24 = 0;
  unsigned int v23 = 0;
  if (sub_1CD38C468(a1, (_DWORD *)&v24 + 1, &v24, &v23)) {
    return 1;
  }
  unint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v10 = *(void *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8);
  if (*(_DWORD *)v10 == 2 && *(void *)(v10 + 16) == 11)
  {
    uint64_t v11 = *(uint64_t **)(v10 + 8);
    uint64_t v12 = *v11;
    uint64_t v13 = *(uint64_t *)((char *)v11 + 3);
    BOOL v14 = v12 == 0x737265765F6B6473 && v13 == 0x6E6F69737265765FLL;
    if (v14 && (sub_1CD38C608(a1, &v21) & 1) != 0) {
      return 1;
    }
  }
  v19[0] = "unexpected token";
  __int16 v20 = 259;
  if (llvm::MCAsmParser::parseEOL(*(llvm::MCAsmParser **)(a1 + 8), (const llvm::Twine *)v19))
  {
    v17[0] = " in '";
    void v17[2] = a2;
    void v17[3] = a3;
    __int16 v18 = 1283;
    v19[0] = v17;
    v19[2] = "' directive";
    __int16 v20 = 770;
    return llvm::MCAsmParser::addErrorSuffix(*(llvm::MCAsmParser **)(a1 + 8), (const llvm::Twine *)v19);
  }
  else
  {
    sub_1CD38C70C(a1, a2, a3, 0, 0, a4, dword_1CFB33B90[(int)a5]);
    uint64_t v16 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    (*(void (**)(uint64_t, uint64_t, void, void, void, unint64_t, uint64_t))(*(void *)v16 + 240))(v16, a5, HIDWORD(v24), v24, v23, v21, v22);
    return 0;
  }
}

uint64_t sub_1CD38D0C4(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  return sub_1CD38CED8(a1, a2, a3, a4, 2);
}

uint64_t sub_1CD38D0CC(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  return sub_1CD38CED8(a1, a2, a3, a4, 0);
}

uint64_t sub_1CD38D0D4(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  return sub_1CD38CED8(a1, a2, a3, a4, 1);
}

uint64_t sub_1CD38D0DC(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  __int16 v35 = 0;
  uint64_t v36 = 0;
  uint64_t v8 = *(void *)(*(void *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8))
                             + 8)
                 + 8);
  if ((*(unsigned int (**)(void, unsigned __int16 **))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v35))
  {
    unint64_t v21 = "platform name expected";
LABEL_83:
    v33[0] = v21;
    __int16 v34 = 259;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v33, 0, 0);
  }
  unint64_t v9 = 0;
  BOOL v10 = 1;
  switch(v36)
  {
    case 3:
      if (*v35 ^ 0x6F69 | *((unsigned __int8 *)v35 + 2) ^ 0x73) {
        unint64_t v9 = 0;
      }
      else {
        unint64_t v9 = 0x100000002;
      }
      goto LABEL_40;
    case 4:
      if (*(_DWORD *)v35 != 1936684660)
      {
        uint64_t v11 = 0x10000000BLL;
        BOOL v12 = *(_DWORD *)v35 == 1936683640;
        goto LABEL_13;
      }
      unint64_t v9 = 0x100000003;
      break;
    case 5:
      if (*(_DWORD *)v35 == 1868783981 && *((unsigned char *)v35 + 4) == 115)
      {
        unint64_t v9 = 0x100000001;
      }
      else
      {
        uint64_t v11 = 0x10000000ELL;
        BOOL v12 = (*(_DWORD *)v35 ^ 0x6F706573 | *((unsigned __int8 *)v35 + 4) ^ 0x73) == 0;
LABEL_13:
        if (v12) {
          unint64_t v9 = v11;
        }
        else {
          unint64_t v9 = 0;
        }
      }
      break;
    case 7:
      if (*(_DWORD *)v35 != 1668571511 || *(_DWORD *)((char *)v35 + 3) != 1936681059) {
        goto LABEL_81;
      }
      unint64_t v9 = 0x100000004;
      break;
    case 8:
      if (*(void *)v35 != 0x736F656764697262) {
        goto LABEL_81;
      }
      unint64_t v9 = 0x100000005;
      break;
    case 9:
      if (*(void *)v35 != 0x696B726576697264 || *((unsigned char *)v35 + 8) != 116) {
        goto LABEL_39;
      }
      unint64_t v9 = 0x10000000ALL;
      break;
    case 11:
      if (*(void *)v35 != 0x6C6174614363616DLL || *(void *)((char *)v35 + 3) != 0x7473796C61746143)
      {
        unint64_t v9 = 0;
        goto LABEL_45;
      }
      unint64_t v9 = 0x100000006;
      break;
    case 12:
      if (*(void *)v35 == 0x6C756D6973736F69 && *((_DWORD *)v35 + 2) == 1919906913)
      {
        unint64_t v9 = 0x100000007;
      }
      else
      {
LABEL_39:
        unint64_t v9 = 0;
LABEL_40:
        BOOL v10 = HIDWORD(v9) == 0;
LABEL_41:
        if (v36 == 11 && v10)
        {
LABEL_45:
          if (!(*(void *)v35 ^ 0x616C756D69737278 | *(void *)((char *)v35 + 3) ^ 0x726F74616C756D69)) {
            unint64_t v9 = 0x10000000CLL;
          }
        }
      }
      break;
    case 13:
      if (*(void *)v35 != 0x756D6973736F7674 || *(void *)((char *)v35 + 5) != 0x726F74616C756D69) {
        goto LABEL_81;
      }
      unint64_t v9 = 0x100000008;
      break;
    case 16:
      if (*(void *)v35 != 0x73736F6863746177 || *((void *)v35 + 1) != 0x726F74616C756D69) {
        goto LABEL_81;
      }
      unint64_t v9 = 0x100000009;
      break;
    default:
      goto LABEL_41;
  }
  if ((v9 & 0x300000000) == 0 || !v9)
  {
LABEL_81:
    v33[0] = "unknown platform name";
    __int16 v34 = 259;
    return llvm::MCAsmParser::Error(*(void *)(a1 + 8), v8, (uint64_t)v33, 0, 0);
  }
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 25)
  {
    unint64_t v21 = "version number required, comma expected";
    goto LABEL_83;
  }
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  uint64_t v32 = 0;
  unsigned int v31 = 0;
  if (sub_1CD38C468(a1, (_DWORD *)&v32 + 1, &v32, &v31)) {
    return 1;
  }
  unint64_t v29 = 0;
  uint64_t v30 = 0;
  uint64_t v22 = *(void *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8);
  if (*(_DWORD *)v22 == 2 && *(void *)(v22 + 16) == 11)
  {
    unsigned int v23 = *(uint64_t **)(v22 + 8);
    uint64_t v24 = *v23;
    uint64_t v25 = *(uint64_t *)((char *)v23 + 3);
    BOOL v26 = v24 == 0x737265765F6B6473 && v25 == 0x6E6F69737265765FLL;
    if (v26 && (sub_1CD38C608(a1, &v29) & 1) != 0) {
      return 1;
    }
  }
  v33[0] = "unexpected token";
  __int16 v34 = 259;
  if (llvm::MCAsmParser::parseEOL(*(llvm::MCAsmParser **)(a1 + 8), (const llvm::Twine *)v33))
  {
    v33[0] = " in '.build_version' directive";
    __int16 v34 = 259;
    return llvm::MCAsmParser::addErrorSuffix(*(llvm::MCAsmParser **)(a1 + 8), (const llvm::Twine *)v33);
  }
  else
  {
    sub_1CD38C70C(a1, a2, a3, (uint64_t)v35, v36, a4, dword_1CFB33BA0[(int)v9 - 1]);
    uint64_t v28 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    (*(void (**)(uint64_t, unint64_t, void, void, void, unint64_t, uint64_t))(*(void *)v28 + 248))(v28, v9, HIDWORD(v32), v32, v31, v29, v30);
    return 0;
  }
}

uint64_t sub_1CD38D6CC(uint64_t a1)
{
  uint64_t v7 = 0;
  uint64_t v2 = *(llvm::MCAsmParser **)(a1 + 8);
  v5[0] = "expected integer version in '.ptrauth_abi_version' directive";
  __int16 v6 = 259;
  if (llvm::MCAsmParser::parseIntToken(v2, &v7, (const llvm::Twine *)v5)) {
    return 1;
  }
  if ((unint64_t)v7 < 0x40)
  {
    v5[0] = "unexpected token";
    __int16 v6 = 259;
    if (llvm::MCAsmParser::parseEOL(*(llvm::MCAsmParser **)(a1 + 8), (const llvm::Twine *)v5))
    {
      v5[0] = " in '.ptrauth_abi_version' directive";
      __int16 v6 = 259;
      return llvm::MCAsmParser::addErrorSuffix(*(llvm::MCAsmParser **)(a1 + 8), (const llvm::Twine *)v5);
    }
    else
    {
      uint64_t v4 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
      (*(void (**)(void))(v4 + 264))();
      return 0;
    }
  }
  else
  {
    v5[0] = "invalid ptrauth ABI version number";
    __int16 v6 = 259;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v5, 0, 0);
  }
}

uint64_t sub_1CD38D818(uint64_t a1)
{
  uint64_t v7 = 0;
  uint64_t v2 = *(llvm::MCAsmParser **)(a1 + 8);
  v5[0] = "expected integer version in '.ptrauth_kernel_abi_version' directive";
  __int16 v6 = 259;
  if (llvm::MCAsmParser::parseIntToken(v2, &v7, (const llvm::Twine *)v5)) {
    return 1;
  }
  if ((unint64_t)v7 < 0x40)
  {
    v5[0] = "unexpected token";
    __int16 v6 = 259;
    if (llvm::MCAsmParser::parseEOL(*(llvm::MCAsmParser **)(a1 + 8), (const llvm::Twine *)v5))
    {
      v5[0] = " in '.ptrauth_kernel_abi_version' directive";
      __int16 v6 = 259;
      return llvm::MCAsmParser::addErrorSuffix(*(llvm::MCAsmParser **)(a1 + 8), (const llvm::Twine *)v5);
    }
    else
    {
      uint64_t v4 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
      (*(void (**)(void))(v4 + 264))();
      return 0;
    }
  }
  else
  {
    v5[0] = "invalid ptrauth kernel ABI version number";
    __int16 v6 = 259;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v5, 0, 0);
  }
}

void sub_1CD38D96C()
{
}

uint64_t sub_1CD38D980(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = a2;
  (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(*(void *)a2 + 16))(a2, ".data", 5, a1, sub_1CD38E0D8);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".text", 5, a1, sub_1CD38E29C);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".bss", 4, a1, sub_1CD38E2B4);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".rodata", 7, a1, sub_1CD38E2CC);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".tdata", 6, a1, sub_1CD38E2E4);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".tbss", 5, a1, sub_1CD38E2FC);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".data.rel", 9, a1, sub_1CD38E314);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".data.rel.ro", 12, a1, sub_1CD38E32C);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".eh_frame", 9, a1, sub_1CD38E344);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t)))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), ".section", 8, a1, sub_1CD38E35C);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t)))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), ".pushsection", 12, a1, sub_1CD39089C);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".popsection", 11, a1, sub_1CD390934);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".size", 5, a1, sub_1CD3909BC);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".previous", 9, a1, sub_1CD390C00);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".type", 5, a1, sub_1CD390CF8);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".ident", 6, a1, sub_1CD3914A0);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".symver", 7, a1, sub_1CD39168C);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".version", 8, a1, sub_1CD3919E0);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".weakref", 8, a1, sub_1CD391E94);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".weak", 5, a1, sub_1CD3920B4);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".local", 6, a1, sub_1CD3920B4);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".protected", 10, a1, sub_1CD3920B4);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".internal", 9, a1, sub_1CD3920B4);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".hidden", 7, a1, sub_1CD3920B4);
  (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t (*)(uint64_t)))(**(void **)(a1 + 8)
                                                                                                  + 16))(*(void *)(a1 + 8), ".subsection", 11, a1, sub_1CD3924F8);
  char v3 = *(uint64_t (**)(void))(**(void **)(a1 + 8) + 16);

  return v3();
}

uint64_t sub_1CD38E0D8(uint64_t a1)
{
  return sub_1CD38E0F0(a1, (uint64_t)".data", 5, 1, 3);
}

uint64_t sub_1CD38E0F0(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  uint64_t v17 = 0;
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 9)
  {
    uint64_t v10 = *(void *)(a1 + 8);
    v18[0] = 0;
    if ((*(uint64_t (**)(uint64_t, uint64_t *, void *))(*(void *)v10 + 232))(v10, &v17, v18)) {
      return 1;
    }
  }
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  uint64_t v12 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
  uint64_t v13 = (llvm::MCContext *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
  __int16 v16 = 261;
  v15[0] = a2;
  v15[1] = a3;
  __int16 v19 = 257;
  uint64_t ELFSection = llvm::MCContext::getELFSection(v13, (const llvm::Twine *)v15, a4, a5, 0, (const llvm::Twine *)v18, 0, -1, 0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v12 + 168))(v12, ELFSection, v17);
  return 0;
}

uint64_t sub_1CD38E29C(uint64_t a1)
{
  return sub_1CD38E0F0(a1, (uint64_t)".text", 5, 1, 6);
}

uint64_t sub_1CD38E2B4(uint64_t a1)
{
  return sub_1CD38E0F0(a1, (uint64_t)".bss", 4, 8, 3);
}

uint64_t sub_1CD38E2CC(uint64_t a1)
{
  return sub_1CD38E0F0(a1, (uint64_t)".rodata", 7, 1, 2);
}

uint64_t sub_1CD38E2E4(uint64_t a1)
{
  return sub_1CD38E0F0(a1, (uint64_t)".tdata", 6, 1, 1027);
}

uint64_t sub_1CD38E2FC(uint64_t a1)
{
  return sub_1CD38E0F0(a1, (uint64_t)".tbss", 5, 8, 1027);
}

uint64_t sub_1CD38E314(uint64_t a1)
{
  return sub_1CD38E0F0(a1, (uint64_t)".data.rel", 9, 1, 3);
}

uint64_t sub_1CD38E32C(uint64_t a1)
{
  return sub_1CD38E0F0(a1, (uint64_t)".data.rel.ro", 12, 1, 3);
}

uint64_t sub_1CD38E344(uint64_t a1)
{
  return sub_1CD38E0F0(a1, (uint64_t)".eh_frame", 9, 1, 3);
}

uint64_t sub_1CD38E35C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1CD38E368(a1, 0, a4);
}

uint64_t sub_1CD38E368(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v208 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 96);
  int v7 = **(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8);
  uint64_t v8 = *(_DWORD **)(a1 + 8);
  if (v7 == 3)
  {
    uint64_t v9 = *(void *)((*(uint64_t (**)(_DWORD *))(*(void *)v8 + 40))(v8) + 8);
    if (*(_DWORD *)v9 == 2)
    {
      uint64_t v11 = *(void *)(v9 + 8);
      unint64_t v10 = *(void *)(v9 + 16);
    }
    else
    {
      uint64_t v28 = v9 + 8;
      uint64_t v26 = *(void *)(v9 + 8);
      unint64_t v27 = *(void *)(v28 + 8);
      unint64_t v29 = v27 != 0;
      if (v27) {
        uint64_t v11 = v26 + 1;
      }
      else {
        uint64_t v11 = v26;
      }
      if (v29 <= v27 - 1) {
        unint64_t v30 = v27 - 1;
      }
      else {
        unint64_t v30 = v27 != 0;
      }
      if (v27 < v30) {
        unint64_t v30 = v27;
      }
      unint64_t v10 = v30 - v29;
    }
    (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
    goto LABEL_40;
  }
  if (v8[6])
  {
LABEL_29:
    *(void *)&long long v203 = "expected identifier in directive";
    __int16 v205 = 259;
    return llvm::MCAsmParser::TokError((uint64_t)v8, (uint64_t)&v203, 0, 0);
  }
  int v12 = 0;
  unint64_t v10 = 0;
  uint64_t v11 = 0;
  while (1)
  {
    uint64_t v13 = *(void *)((*(uint64_t (**)(_DWORD *))(*(void *)v8 + 40))(v8) + 96);
    if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 25
      || **(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 9)
    {
      break;
    }
    int v14 = **(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8);
    uint64_t v15 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8));
    if (v14 == 3)
    {
      __int16 v16 = *(int **)(v15 + 8);
      int v17 = *v16;
      unint64_t v18 = *((void *)v16 + 2);
      if (v17 != 2)
      {
        unint64_t v19 = v18 - 1;
        unint64_t v20 = v18 != 0;
        if (v20 > v18 - 1) {
          unint64_t v19 = v18 != 0;
        }
        if (v18 >= v19) {
          LODWORD(v18) = v19;
        }
        LODWORD(v18) = v18 - v20;
      }
      LODWORD(v21) = v18 + 2;
    }
    else
    {
      int v22 = **(_DWORD **)(v15 + 8);
      uint64_t v23 = *(void *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8);
      if (v22 == 2)
      {
        unint64_t v21 = *(void *)(v23 + 16);
        if (*(_DWORD *)v23 != 2)
        {
          unint64_t v24 = v21 - 1;
          unint64_t v25 = v21 != 0;
          if (v25 > v21 - 1) {
            unint64_t v24 = v21 != 0;
          }
          if (v21 < v24) {
            LODWORD(v24) = v21;
          }
          LODWORD(v21) = v24 - v25;
        }
      }
      else
      {
        LODWORD(v21) = *(_DWORD *)(v23 + 16);
      }
    }
    (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
    unint64_t v10 = (v12 + v21);
    v12 += v21;
    if (v13 + v21 == *(void *)(*(void *)((*(uint64_t (**)(void))(**(void **)(a1 + 8)
                                                                                              + 40))(*(void *)(a1 + 8))
                                                          + 8)
                                              + 8))
    {
      uint64_t v8 = *(_DWORD **)(a1 + 8);
      uint64_t v11 = v6;
      if (!v8[6]) {
        continue;
      }
    }
    uint64_t v11 = v6;
    break;
  }
  if (!v12)
  {
    uint64_t v8 = *(_DWORD **)(a1 + 8);
    goto LABEL_29;
  }
LABEL_40:
  long long v202 = 0uLL;
  uint64_t v201 = 0;
  long long v200 = 0uLL;
  *(void *)int v198 = -1;
  uint64_t v199 = 0;
  if (v10 >= 7)
  {
    BOOL v37 = *(_DWORD *)v11 == 1685025326 && *(_DWORD *)(v11 + 3) == 1635017060;
    if (!v37 || v10 >= 8 && *(unsigned char *)(v11 + 7) != 46)
    {
      if (v10 != 8) {
        goto LABEL_76;
      }
      if (*(void *)v11 != 0x31617461646F722ELL)
      {
        if (*(_DWORD *)v11 != 2019914798 || *(unsigned char *)(v11 + 4) != 116)
        {
          if (*(_DWORD *)v11 != 1952539694 || *(unsigned char *)(v11 + 4) != 97)
          {
LABEL_93:
            if (*(_DWORD *)v11 != 1936941614 || *(unsigned char *)(v11 + 4) != 46)
            {
              if (v10 < 0xB)
              {
                if (v10 < 6)
                {
                  if (*(_DWORD *)v11 != 1935832110 || *(unsigned char *)(v11 + 4) != 115) {
                    goto LABEL_129;
                  }
                  goto LABEL_137;
                }
LABEL_119:
                BOOL v48 = *(_DWORD *)v11 == 1633973294 && *(_WORD *)(v11 + 4) == 24948;
                if (!v48 || v10 >= 7 && *(unsigned char *)(v11 + 6) != 46)
                {
                  BOOL v49 = *(_DWORD *)v11 == 1935832110 && *(unsigned char *)(v11 + 4) == 115;
                  if (!v49 || *(unsigned char *)(v11 + 5) != 46) {
                    goto LABEL_129;
                  }
                }
LABEL_137:
                int v40 = 1027;
                goto LABEL_144;
              }
              BOOL v45 = *(void *)v11 == 0x72615F74696E692ELL && *(void *)(v11 + 3) == 0x79617272615F7469;
              if (!v45 || v10 >= 0xC && *(unsigned char *)(v11 + 11) != 46)
              {
                BOOL v46 = *(void *)v11 == 0x72615F696E69662ELL && *(void *)(v11 + 3) == 0x79617272615F696ELL;
                if (!v46 || v10 >= 0xC && *(unsigned char *)(v11 + 11) != 46)
                {
                  if (v10 < 0xE) {
                    goto LABEL_119;
                  }
                  BOOL v47 = *(void *)v11 == 0x74696E696572702ELL && *(void *)(v11 + 6) == 0x79617272615F7469;
                  if (!v47 || v10 >= 0xF && *(unsigned char *)(v11 + 14) != 46) {
                    goto LABEL_119;
                  }
                }
              }
            }
            goto LABEL_143;
          }
          goto LABEL_130;
        }
LABEL_81:
        if (*(unsigned char *)(v11 + 5) == 46) {
          goto LABEL_82;
        }
LABEL_83:
        if (*(_DWORD *)v11 != 1952539694 || *(unsigned char *)(v11 + 4) != 97)
        {
LABEL_87:
          if (v10 != 6) {
            goto LABEL_93;
          }
          int v34 = *(unsigned __int16 *)(v11 + 4);
          BOOL v35 = *(_DWORD *)v11 == 1952539694;
          int v36 = 12641;
LABEL_89:
          if (!v35 || v34 != v36) {
            goto LABEL_93;
          }
LABEL_143:
          int v40 = 3;
          goto LABEL_144;
        }
LABEL_130:
        if (*(unsigned char *)(v11 + 5) == 46) {
          goto LABEL_143;
        }
        goto LABEL_87;
      }
    }
    int v40 = 2;
    goto LABEL_144;
  }
  if (v10 == 5)
  {
    if ((*(_DWORD *)v11 != 1852401198 || *(unsigned char *)(v11 + 4) != 105)
      && (*(_DWORD *)v11 != 1768843566 || *(unsigned char *)(v11 + 4) != 116)
      && (*(_DWORD *)v11 != 2019914798 || *(unsigned char *)(v11 + 4) != 116))
    {
      int v34 = *(unsigned __int8 *)(v11 + 4);
      BOOL v35 = *(_DWORD *)v11 == 1952539694;
      int v36 = 97;
      goto LABEL_89;
    }
LABEL_82:
    int v40 = 6;
    goto LABEL_144;
  }
  if (v10 >= 5)
  {
LABEL_76:
    if (*(_DWORD *)v11 != 2019914798 || *(unsigned char *)(v11 + 4) != 116) {
      goto LABEL_83;
    }
    goto LABEL_81;
  }
  if (v10 != 4)
  {
LABEL_129:
    int v40 = 0;
    goto LABEL_144;
  }
  if (*(_DWORD *)v11 == 1936941614) {
    int v40 = 3;
  }
  else {
    int v40 = 0;
  }
LABEL_144:
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 25) {
    goto LABEL_280;
  }
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  if (a2
    && **(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 3)
  {
    uint64_t v50 = *(void *)(a1 + 8);
    *(void *)&long long v203 = 0;
    if ((*(uint64_t (**)(uint64_t, uint64_t *, long long *))(*(void *)v50 + 232))(v50, &v199, &v203)) {
      return 1;
    }
    if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 25)
    {
      (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
      goto LABEL_150;
    }
LABEL_280:
    uint64_t v184 = a3;
    LOBYTE(v97) = 0;
    uint64_t v98 = 0;
    int v87 = 0;
    int v68 = 0;
    goto LABEL_336;
  }
LABEL_150:
  int v51 = **(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8);
  uint64_t v52 = **(void **)(a1 + 8);
  uint64_t v184 = a3;
  int v185 = v40;
  if (v51 != 3)
  {
    if (!*(unsigned char *)(*(void *)((*(uint64_t (**)(void))(v52 + 48))() + 152) + 336)
      || **(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 37)
    {
      int v99 = "expected string in directive";
      goto LABEL_344;
    }
    if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 37)
    {
      int v68 = 0;
      int v87 = 0;
      goto LABEL_224;
    }
    int v68 = 0;
    while (1)
    {
      (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
      if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 2) {
        break;
      }
      uint64_t v69 = *(void *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8);
      if (*(_DWORD *)v69 == 2)
      {
        uint64_t v70 = *(unsigned __int16 **)(v69 + 8);
        unint64_t v71 = *(void *)(v69 + 16);
      }
      else
      {
        uint64_t v70 = *(unsigned __int16 **)(v69 + 8);
        unint64_t v72 = *(void *)(v69 + 16);
        unint64_t v73 = v72 - 1;
        unint64_t v74 = v72 != 0;
        if (v72) {
          uint64_t v70 = (unsigned __int16 *)((char *)v70 + 1);
        }
        if (v74 > v73) {
          unint64_t v73 = v72 != 0;
        }
        if (v72 < v73) {
          unint64_t v73 = v72;
        }
        unint64_t v71 = v73 - v74;
      }
      switch(v71)
      {
        case 3uLL:
          int v80 = *v70;
          int v81 = *((unsigned __int8 *)v70 + 2);
          if (v80 != 27764 || v81 != 115) {
            goto LABEL_282;
          }
          int v79 = 1024;
          break;
        case 9uLL:
          uint64_t v83 = *(void *)v70;
          int v84 = *((unsigned __int8 *)v70 + 8);
          if (v83 != 0x74736E6963657865 || v84 != 114) {
            goto LABEL_282;
          }
          int v79 = 4;
          break;
        case 5uLL:
          if (*(_DWORD *)v70 == 1869376609 && *((unsigned char *)v70 + 4) == 99)
          {
            int v79 = 2;
          }
          else
          {
            int v76 = *(_DWORD *)v70;
            int v77 = *((unsigned __int8 *)v70 + 4);
            if (v76 != 1953067639 || v77 != 101) {
              goto LABEL_282;
            }
            int v79 = 1;
          }
          break;
        default:
          goto LABEL_282;
      }
      v68 |= v79;
      (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
      if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 25)
      {
        (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
        if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 37) {
          continue;
        }
      }
      goto LABEL_220;
    }
LABEL_282:
    int v99 = "unknown flag";
    goto LABEL_344;
  }
  uint64_t v53 = (*(uint64_t (**)(void))(v52 + 40))();
  unint64_t v54 = *(void *)(*(void *)(v53 + 8) + 16);
  unint64_t v55 = v54 != 0;
  if (v54) {
    uint64_t v56 = (unsigned char *)(*(void *)(*(void *)(v53 + 8) + 8) + 1);
  }
  else {
    uint64_t v56 = *(unsigned char **)(*(void *)(v53 + 8) + 8);
  }
  if (v55 <= v54 - 1) {
    unint64_t v57 = v54 - 1;
  }
  else {
    unint64_t v57 = v54 != 0;
  }
  if (v54 >= v57) {
    unint64_t v58 = v57;
  }
  else {
    unint64_t v58 = *(void *)(*(void *)(v53 + 8) + 16);
  }
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  uint64_t v59 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
  *(void *)&long long v203 = v56;
  *((void *)&v203 + 1) = v58 - v55;
  unsigned int v60 = sub_1CD0AF898((uint64_t)&v203);
  uint64_t v61 = *((void *)&v203 + 1);
  if (*((void *)&v203 + 1))
  {
    unint64_t v62 = 0;
    uint64_t v63 = (unsigned __int8 *)v203;
    while (1)
    {
      int v64 = *v63;
      if ((v64 - 48) >= 0xA)
      {
        if ((v64 - 97) >= 0x1A)
        {
          if ((v64 - 65) > 0x19) {
            break;
          }
          int v65 = -55;
        }
        else
        {
          int v65 = -87;
        }
      }
      else
      {
        int v65 = -48;
      }
      unsigned int v66 = v65 + v64;
      if (v66 >= v60) {
        break;
      }
      unint64_t v67 = v62 * v60 + v66;
      if (v67 / v60 < v62) {
        break;
      }
      ++v63;
      unint64_t v62 = v67;
      if (!--v61)
      {
        if (v67 >= 0x100000000) {
          int v68 = 0;
        }
        else {
          int v68 = v67;
        }
        if (!HIDWORD(v67)) {
          goto LABEL_220;
        }
        goto LABEL_219;
      }
    }
  }
  int v68 = 0;
LABEL_219:
  unint64_t v86 = v58 - v55;
  if (v58 != v55)
  {
    int v87 = 0;
    while (2)
    {
      int v95 = (char)*v56;
      if (v95 > 96)
      {
        switch(*v56)
        {
          case 'o':
            v68 |= 0x80u;
            goto LABEL_267;
          case 'p':
          case 'q':
          case 'r':
          case 't':
          case 'u':
          case 'v':
            goto LABEL_282;
          case 's':
LABEL_256:
            v68 |= 0x10000000u;
            goto LABEL_267;
          case 'w':
            v68 |= 1u;
            goto LABEL_267;
          case 'x':
            v68 |= 4u;
            goto LABEL_267;
          case 'y':
LABEL_257:
            v68 |= 0x20000000u;
            goto LABEL_267;
          default:
            switch(*v56)
            {
              case 'a':
                v68 |= 2u;
                goto LABEL_267;
              case 'c':
                goto LABEL_257;
              case 'd':
                goto LABEL_256;
              case 'e':
                v68 |= 0x80000000;
                goto LABEL_267;
              default:
                goto LABEL_282;
            }
        }
      }
      switch(*v56)
      {
        case 'M':
          v68 |= 0x10u;
          goto LABEL_267;
        case 'N':
        case 'O':
        case 'P':
        case 'Q':
          goto LABEL_282;
        case 'R':
          if (*(_DWORD *)(v59 + 60) == 14) {
            v68 |= 0x100000u;
          }
          else {
            v68 |= 0x200000u;
          }
          goto LABEL_267;
        case 'S':
          v68 |= 0x20u;
          goto LABEL_267;
        case 'T':
          v68 |= 0x400u;
          goto LABEL_267;
        default:
          if (v95 == 63)
          {
            int v87 = 1;
          }
          else
          {
            if (v95 != 71) {
              goto LABEL_282;
            }
            v68 |= 0x200u;
          }
LABEL_267:
          ++v56;
          if (!--v86) {
            goto LABEL_221;
          }
          continue;
      }
    }
  }
LABEL_220:
  int v87 = 0;
LABEL_221:
  if (v68 == -1) {
    goto LABEL_282;
  }
  if ((v68 & 0x200) != 0 && v87)
  {
    int v99 = "Section cannot specifiy a group name while also acting as a member of the last group";
    goto LABEL_344;
  }
LABEL_224:
  uint64_t v88 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8));
  if (**(_DWORD **)(v88 + 8) != 25) {
    goto LABEL_231;
  }
  uint64_t v89 = v88;
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  int v90 = **(_DWORD **)(v89 + 8);
  if (v90 != 3)
  {
    if (v90 != 36 && v90 != 45)
    {
      if (*(unsigned char *)(v89 + 105)) {
        size_t v100 = "expected '@<type>', '%<type>' or \"<type>\"";
      }
      else {
        size_t v100 = "expected '%<type>' or \"<type>\"";
      }
      goto LABEL_380;
    }
    (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
    if (**(_DWORD **)(v89 + 8) == 4)
    {
      long long v202 = *(_OWORD *)(*(void *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8))
                                   + 8)
                       + 8);
      (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
      goto LABEL_231;
    }
  }
  if (!(*(unsigned int (**)(void, long long *))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v202)) {
    goto LABEL_231;
  }
  size_t v100 = "expected identifier in directive";
LABEL_380:
  *(void *)&long long v203 = v100;
  __int16 v205 = 259;
  if (llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)&v203, 0, 0)) {
    return 1;
  }
LABEL_231:
  uint64_t v91 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8));
  if (!*((void *)&v202 + 1))
  {
    if ((v68 & 0x10) != 0)
    {
      int v99 = "Mergeable section must specify the type";
    }
    else
    {
      if ((v68 & 0x200) == 0)
      {
        if (**(_DWORD **)(v91 + 8) != 9) {
          goto LABEL_343;
        }
        goto LABEL_299;
      }
      int v99 = "Group section must specify the type";
    }
LABEL_344:
    *(void *)&long long v203 = v99;
    __int16 v205 = 259;
    uint64_t v8 = *(_DWORD **)(a1 + 8);
    return llvm::MCAsmParser::TokError((uint64_t)v8, (uint64_t)&v203, 0, 0);
  }
  if ((v68 & 0x10) == 0) {
    goto LABEL_236;
  }
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 25)
  {
    uint64_t v101 = "expected the entry size";
    goto LABEL_294;
  }
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  if ((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 256))()) {
    return 1;
  }
  if (v201 <= 0)
  {
    uint64_t v101 = "entry size must be positive";
LABEL_294:
    *(void *)&long long v203 = v101;
    __int16 v205 = 259;
    if (llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)&v203, 0, 0)) {
      return 1;
    }
  }
LABEL_236:
  if ((v68 & 0x200) == 0) {
    goto LABEL_299;
  }
  uint64_t v92 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8));
  if (**(_DWORD **)(v92 + 8) == 25)
  {
    uint64_t v93 = v92;
    (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
    uint64_t v94 = **(void **)(a1 + 8);
    if (**(_DWORD **)(v93 + 8) == 4)
    {
      long long v200 = *(_OWORD *)(*(void *)((*(uint64_t (**)(void))(v94 + 40))() + 8) + 8);
      (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
LABEL_270:
      if (**(_DWORD **)(v93 + 8) != 25) {
        goto LABEL_299;
      }
      (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
      long long v195 = 0uLL;
      if ((*(uint64_t (**)(void, long long *))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v195))
      {
        int v102 = "invalid linkage";
      }
      else
      {
        if (*((void *)&v195 + 1) == 6 && *(_DWORD *)v195 == 1684893539 && *(_WORD *)(v195 + 4) == 29793)
        {
          LOBYTE(v97) = 1;
          if ((v68 & 0x80) == 0) {
            goto LABEL_305;
          }
          goto LABEL_300;
        }
        int v102 = "Linkage must be 'comdat'";
      }
      goto LABEL_298;
    }
    if (!(*(unsigned int (**)(void))(v94 + 192))()) {
      goto LABEL_270;
    }
    int v102 = "invalid group name";
  }
  else
  {
    int v102 = "expected group name";
  }
LABEL_298:
  *(void *)&long long v203 = v102;
  __int16 v205 = 259;
  if (llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)&v203, 0, 0)) {
    return 1;
  }
LABEL_299:
  LOBYTE(v97) = 0;
  if ((v68 & 0x80) == 0)
  {
LABEL_305:
    uint64_t v98 = 0;
    goto LABEL_306;
  }
LABEL_300:
  uint64_t v103 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8));
  if (**(_DWORD **)(v103 + 8) != 25)
  {
    long long v113 = "expected linked-to symbol";
LABEL_325:
    *(void *)&long long v203 = v113;
    __int16 v205 = 259;
    uint64_t v98 = 0;
    if (llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)&v203, 0, 0)) {
      return 1;
    }
    goto LABEL_306;
  }
  uint64_t v104 = v103;
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  long long v195 = 0uLL;
  uint64_t v105 = *(void *)(v104 + 96);
  int v106 = (*(uint64_t (**)(void, long long *))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v195);
  uint64_t v107 = **(void **)(a1 + 8);
  if (v106)
  {
    uint64_t v108 = *(void *)((*(uint64_t (**)(void))(v107 + 40))() + 8);
    if (*(void *)(v108 + 16) == 1 && **(unsigned char **)(v108 + 8) == 48)
    {
      (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
      goto LABEL_305;
    }
    long long v113 = "invalid linked-to symbol";
    goto LABEL_325;
  }
  int v115 = (llvm::MCContext *)(*(uint64_t (**)(void))(v107 + 48))();
  __int16 v205 = 261;
  long long v203 = v195;
  uint64_t v116 = llvm::MCContext::lookupSymbol(v115, (const llvm::Twine *)&v203);
  if (v116 && (uint64_t v98 = v116, (*(_DWORD *)(v116 + 8) & 0x1C0) == 0x80))
  {
    uint64_t v117 = *(void *)v116;
    unint64_t AssociatedFragment = *(void *)v116 & 0xFFFFFFFFFFFFFFF8;
    if ((*(void *)v98 & 0xFFFFFFFFFFFFFFF8) == 0 && (*(_DWORD *)(v98 + 8) & 0x1C00) == 0x800)
    {
      *(_DWORD *)(v98 + 8) |= 4u;
      unint64_t AssociatedFragment = llvm::MCExpr::findAssociatedFragment(*(llvm::MCExpr **)(v98 + 24));
      uint64_t v117 = *(void *)v98 & 7 | AssociatedFragment;
      *(void *)uint64_t v98 = v117;
    }
    if (AssociatedFragment)
    {
      unint64_t v119 = v117 & 0xFFFFFFFFFFFFFFF8;
      if ((v117 & 0xFFFFFFFFFFFFFFF8) == 0 && (*(_DWORD *)(v98 + 8) & 0x1C00) == 0x800)
      {
        *(_DWORD *)(v98 + 8) |= 4u;
        unint64_t v119 = llvm::MCExpr::findAssociatedFragment(*(llvm::MCExpr **)(v98 + 24));
        *(void *)uint64_t v98 = *(void *)v98 & 7 | v119;
      }
      if ((_UNKNOWN *)v119 != llvm::MCSymbol::AbsolutePseudoFragment) {
        goto LABEL_306;
      }
    }
  }
  else
  {
    uint64_t v98 = 0;
  }
  __int16 v205 = 1283;
  *(void *)&long long v203 = "linked-to symbol is not in a section: ";
  long long v204 = v195;
  if (llvm::MCAsmParser::Error(*(void *)(a1 + 8), v105, (uint64_t)&v203, 0, 0)) {
    return 1;
  }
LABEL_306:
  int v40 = v68 | v185;
  uint64_t v109 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8));
  if (**(_DWORD **)(v109 + 8) != 25) {
    goto LABEL_336;
  }
  uint64_t v110 = v109;
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  long long v195 = 0uLL;
  if ((*(unsigned int (**)(void, long long *))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v195))
  {
    long long v112 = "expected identifier in directive";
    goto LABEL_322;
  }
  if (*((void *)&v195 + 1) != 6
    || (*(_DWORD *)v195 == 1902734965 ? (BOOL v111 = *(unsigned __int16 *)(v195 + 4) == 25973) : (BOOL v111 = 0), !v111))
  {
    long long v112 = "expected 'unique'";
    goto LABEL_322;
  }
  if (**(_DWORD **)(v110 + 8) != 25)
  {
    long long v112 = "expected commma";
    goto LABEL_322;
  }
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 8) + 256))()) {
    return 1;
  }
  if ((*(void *)v198 & 0x8000000000000000) != 0)
  {
    long long v112 = "unique id must be positive";
  }
  else
  {
    if (*(void *)v198 <= 0xFFFFFFFEuLL) {
      goto LABEL_336;
    }
    long long v112 = "unique id is too large";
  }
LABEL_322:
  *(void *)&long long v203 = v112;
  __int16 v205 = 259;
  if (llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)&v203, 0, 0)) {
    return 1;
  }
LABEL_336:
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 9)
  {
LABEL_343:
    int v99 = "unexpected token in directive";
    goto LABEL_344;
  }
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  if (*((void *)&v202 + 1))
  {
    switch(*((void *)&v202 + 1))
    {
      case 4:
        if (*(_DWORD *)v202 == 1702129518) {
          goto LABEL_355;
        }
        goto LABEL_480;
      case 6:
        if (*(_DWORD *)v202 == 1768058734 && *(_WORD *)(v202 + 4) == 29556) {
          goto LABEL_414;
        }
        if (*(_DWORD *)v202 != 1769434741 || *(_WORD *)(v202 + 4) != 25710) {
          goto LABEL_480;
        }
        LODWORD(v120) = 1879048193;
        goto LABEL_494;
      case 8:
        if (*(void *)v202 == 0x73746962676F7270) {
          goto LABEL_464;
        }
        goto LABEL_480;
      case 0xALL:
        if (*(void *)v202 == 0x7272615F74696E69 && *(_WORD *)(v202 + 8) == 31073) {
          goto LABEL_408;
        }
        if (*(void *)v202 == 0x7272615F696E6966 && *(_WORD *)(v202 + 8) == 31073) {
          goto LABEL_473;
        }
        goto LABEL_480;
      case 0xBLL:
        if (*(void *)v202 != 0x72646F5F6D766C6CLL || *(void *)(v202 + 3) != 0x62617472646F5F6DLL) {
          goto LABEL_480;
        }
        LODWORD(v120) = 1879002112;
        goto LABEL_494;
      case 0xCLL:
        if (*(void *)v202 != 0x6D79735F6D766C6CLL || *(_DWORD *)(v202 + 8) != 1953653104) {
          goto LABEL_480;
        }
        int v130 = 5;
        goto LABEL_438;
      case 0xDLL:
        if (*(void *)v202 == 0x5F74696E69657270 && *(void *)(v202 + 5) == 0x79617272615F7469) {
          goto LABEL_422;
        }
        goto LABEL_480;
      case 0x10:
        if (*(void *)v202 != 0x5F62625F6D766C6CLL || *(void *)(v202 + 8) != 0x70616D5F72646461) {
          goto LABEL_480;
        }
        LODWORD(v120) = 1879002120;
        goto LABEL_494;
      case 0x13:
        if (*(void *)v202 != 0x6E696C5F6D766C6CLL
          || *(void *)(v202 + 8) != 0x6974706F5F72656BLL
          || *(void *)(v202 + 11) != 0x736E6F6974706F5FLL)
        {
          goto LABEL_480;
        }
        LODWORD(v120) = 1879002113;
        goto LABEL_494;
      case 0x17:
        if (*(void *)v202 != 0x6C61635F6D766C6CLL
          || *(void *)(v202 + 8) != 0x5F68706172675F6CLL
          || *(void *)(v202 + 15) != 0x656C69666F72705FLL)
        {
          goto LABEL_480;
        }
        int v130 = 9;
LABEL_438:
        LODWORD(v120) = v130 | 0x6FFF4C00;
        goto LABEL_494;
      case 0x18:
        if (*(void *)v202 != 0x7065645F6D766C6CLL
          || *(void *)(v202 + 8) != 0x6C5F746E65646E65
          || *(void *)(v202 + 16) != 0x7365697261726269)
        {
          goto LABEL_480;
        }
        LODWORD(v120) = 1879002116;
        goto LABEL_494;
      default:
LABEL_480:
        long long v203 = v202;
        unsigned int v143 = sub_1CD0AF898((uint64_t)&v203);
        uint64_t v144 = *((void *)&v203 + 1);
        if (!*((void *)&v203 + 1)) {
          goto LABEL_493;
        }
        unint64_t v145 = 0;
        unsigned int v146 = (unsigned __int8 *)v203;
        break;
    }
    while (1)
    {
      int v147 = *v146;
      if ((v147 - 48) >= 0xA)
      {
        if ((v147 - 97) >= 0x1A)
        {
          if ((v147 - 65) > 0x19) {
            break;
          }
          int v148 = -55;
        }
        else
        {
          int v148 = -87;
        }
      }
      else
      {
        int v148 = -48;
      }
      unsigned int v149 = v148 + v147;
      if (v149 >= v143) {
        break;
      }
      unint64_t v120 = v145 * v143 + v149;
      if (v120 / v143 < v145) {
        break;
      }
      ++v146;
      unint64_t v145 = v145 * v143 + v149;
      if (!--v144)
      {
        if (!HIDWORD(v120)) {
          goto LABEL_494;
        }
        break;
      }
    }
LABEL_493:
    int v99 = "unknown section type";
    goto LABEL_344;
  }
  if (v10 < 5)
  {
    if (v10 == 4)
    {
      if (*(_DWORD *)v11 == 1936941614) {
        LODWORD(v120) = 8;
      }
      else {
        LODWORD(v120) = 1;
      }
      goto LABEL_494;
    }
LABEL_464:
    LODWORD(v120) = 1;
    goto LABEL_494;
  }
  if (*(_DWORD *)v11 == 1953459758 && *(unsigned char *)(v11 + 4) == 101)
  {
LABEL_355:
    LODWORD(v120) = 7;
    goto LABEL_494;
  }
  uint64_t v122 = v10;
  if (v10 >= 0xB)
  {
    BOOL v123 = *(void *)v11 == 0x72615F74696E692ELL && *(void *)(v11 + 3) == 0x79617272615F7469;
    if (v123 && (v10 < 0xC || *(unsigned char *)(v11 + 11) == 46))
    {
LABEL_408:
      LODWORD(v120) = 14;
      goto LABEL_494;
    }
    uint64_t v122 = 11;
  }
  if (*(_DWORD *)v11 == 1936941614 && *(unsigned char *)(v11 + 4) == 46)
  {
LABEL_414:
    LODWORD(v120) = 8;
    goto LABEL_494;
  }
  if (*(_DWORD *)v11 != 1935832110 || *(unsigned char *)(v11 + 4) != 115)
  {
    if (v10 < 0xB) {
      goto LABEL_464;
    }
    goto LABEL_449;
  }
  LODWORD(v120) = 8;
  if (v10 >= 6)
  {
    int v125 = *(unsigned __int8 *)(v11 + 5);
    LODWORD(v120) = v125 == 46 ? 8 : 1;
    if (v10 >= 0xB && v125 != 46)
    {
LABEL_449:
      BOOL v139 = *(void *)v11 == 0x72615F696E69662ELL && *(void *)(v11 + 3) == 0x79617272615F696ELL;
      if (v139 && (v10 < 0xC || *(unsigned char *)(v11 + v122) == 46))
      {
LABEL_473:
        LODWORD(v120) = 15;
        goto LABEL_494;
      }
      if (v10 >= 0xE)
      {
        BOOL v140 = *(void *)v11 == 0x74696E696572702ELL && *(void *)(v11 + 6) == 0x79617272615F7469;
        if (v140 && (v10 < 0xF || *(unsigned char *)(v11 + 14) == 46))
        {
LABEL_422:
          LODWORD(v120) = 16;
          goto LABEL_494;
        }
      }
      goto LABEL_464;
    }
  }
LABEL_494:
  if (v87)
  {
    uint64_t v150 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    uint64_t v151 = *(unsigned int *)(v150 + 120);
    if (v151)
    {
      uint64_t v152 = *(void *)(*(void *)(v150 + 112) + 32 * v151 - 32);
      if (v152)
      {
        uint64_t v153 = *(void *)(v152 + 240);
        unsigned int v154 = (unsigned char *)(v153 & 0xFFFFFFFFFFFFFFF8);
        if ((v153 & 0xFFFFFFFFFFFFFFF8) != 0)
        {
          if ((*v154 & 4) != 0)
          {
            uint64_t v157 = (uint64_t *)*((void *)v154 - 1);
            uint64_t v158 = *v157;
            uint64_t v155 = v157 + 2;
            uint64_t v156 = v158;
          }
          else
          {
            uint64_t v155 = 0;
            uint64_t v156 = 0;
          }
          *(void *)&long long v200 = v155;
          *((void *)&v200 + 1) = v156;
          unsigned int v97 = (v153 >> 2) & 1;
          v40 |= 0x200u;
        }
      }
    }
  }
  uint64_t v159 = (llvm::MCContext *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
  __int16 v205 = 261;
  *(void *)&long long v203 = v11;
  *((void *)&v203 + 1) = v10;
  __int16 v197 = 261;
  long long v195 = v200;
  uint64_t ELFSection = llvm::MCContext::getELFSection(v159, (const llvm::Twine *)&v203, v120, v40, v201, (const llvm::Twine *)&v195, v97, v198[0], (const llvm::MCSymbolELF *)v98);
  uint64_t v161 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v161 + 168))(v161, ELFSection, v199);
  if (*((void *)&v202 + 1) && *(_DWORD *)(ELFSection + 224) != v120)
  {
    int v162 = *(_DWORD *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8)) + 48);
    if (v162 == 42)
    {
      if (v10 == 9)
      {
        int v163 = *(unsigned __int8 *)(v11 + 8);
        BOOL v164 = *(void *)v11 == 0x6D6172665F68652ELL;
        int v165 = 101;
        goto LABEL_510;
      }
    }
    else if (v10 >= 7 && (v162 & 0xFFFFFFFC) == 0x10)
    {
      int v163 = *(_DWORD *)(v11 + 3);
      BOOL v164 = *(_DWORD *)v11 == 1650811950;
      int v165 = 1600615778;
LABEL_510:
      int v167 = !v164 || v163 != v165;
      if (v120 == 1 && !v167) {
        goto LABEL_518;
      }
    }
    __int16 v194 = 1283;
    v191[0] = "changed section type for ";
    uint64_t v192 = v11;
    unint64_t v193 = v10;
    *(void *)&long long v195 = v191;
    int v196 = ", expected: 0x";
    __int16 v197 = 770;
    unint64_t v176 = *(unsigned int *)(ELFSection + 224);
    if (v176)
    {
      uint64_t v177 = (char *)&v204 + 1;
      do
      {
        *--uint64_t v177 = a0123456789abcd_6[v176 & 0xF];
        BOOL v179 = v176 > 0xF;
        v176 >>= 4;
      }
      while (v179);
    }
    else
    {
      uint64_t v177 = (char *)&v204;
      LOBYTE(v204) = 48;
    }
    sub_1CC028D80(__p, v177, (char *)&v204 + 1, (char *)&v204 + 1 - v177);
    char v180 = v197;
    if (v197 == 1)
    {
      *(void *)&long long v203 = __p;
      long long v204 = v190;
      __int16 v205 = 260;
      int v206 = v188;
      __int16 v207 = v189;
    }
    else if ((_BYTE)v197)
    {
      if (HIBYTE(v197) != 1) {
        char v180 = 2;
      }
      uint64_t v182 = &v195;
      if (HIBYTE(v197) == 1) {
        uint64_t v182 = (long long *)v195;
      }
      *(void *)&long long v203 = v182;
      *((void *)&v203 + 1) = *((void *)&v195 + 1);
      *(void *)&long long v204 = __p;
      LOBYTE(v205) = v180;
      HIBYTE(v205) = 4;
    }
    else
    {
      __int16 v205 = 256;
    }
    llvm::MCAsmParser::Error(*(void *)(a1 + 8), v184, (uint64_t)&v203, 0, 0);
    if (v187 < 0) {
      operator delete(__p[0]);
    }
  }
LABEL_518:
  uint64_t v168 = v201;
  uint64_t v169 = *((void *)&v202 + 1);
  if (v68 || v201 || *((void *)&v202 + 1))
  {
    unint64_t v170 = *(unsigned int *)(ELFSection + 228);
    if (v170 == v40)
    {
      if (v68) {
        goto LABEL_526;
      }
    }
    else
    {
      __int16 v194 = 1283;
      v191[0] = "changed section flags for ";
      uint64_t v192 = v11;
      unint64_t v193 = v10;
      *(void *)&long long v195 = v191;
      int v196 = ", expected: 0x";
      __int16 v197 = 770;
      if (v170)
      {
        size_t v178 = (char *)&v204 + 1;
        do
        {
          *--size_t v178 = a0123456789abcd_6[v170 & 0xF];
          BOOL v179 = v170 > 0xF;
          v170 >>= 4;
        }
        while (v179);
      }
      else
      {
        size_t v178 = (char *)&v204;
        LOBYTE(v204) = 48;
      }
      sub_1CC028D80(__p, v178, (char *)&v204 + 1, (char *)&v204 + 1 - v178);
      char v181 = v197;
      if (v197 == 1)
      {
        *(void *)&long long v203 = __p;
        long long v204 = v190;
        __int16 v205 = 260;
        int v206 = v188;
        __int16 v207 = v189;
      }
      else if ((_BYTE)v197)
      {
        if (HIBYTE(v197) != 1) {
          char v181 = 2;
        }
        uint64_t v183 = &v195;
        if (HIBYTE(v197) == 1) {
          uint64_t v183 = (long long *)v195;
        }
        *(void *)&long long v203 = v183;
        *((void *)&v203 + 1) = *((void *)&v195 + 1);
        *(void *)&long long v204 = __p;
        LOBYTE(v205) = v181;
        HIBYTE(v205) = 4;
      }
      else
      {
        __int16 v205 = 256;
      }
      llvm::MCAsmParser::Error(*(void *)(a1 + 8), v184, (uint64_t)&v203, 0, 0);
      if (v187 < 0) {
        operator delete(__p[0]);
      }
      uint64_t v168 = v201;
      uint64_t v169 = *((void *)&v202 + 1);
      if (v68) {
        goto LABEL_526;
      }
    }
  }
  else
  {
    uint64_t v168 = 0;
  }
  if (v168 || v169)
  {
LABEL_526:
    uint64_t v171 = *(unsigned int *)(ELFSection + 236);
    if (v168 != v171)
    {
      __int16 v194 = 1283;
      v191[0] = "changed section entsize for ";
      uint64_t v192 = v11;
      unint64_t v193 = v10;
      *(void *)&long long v195 = v191;
      int v196 = ", expected: ";
      __int16 v197 = 770;
      *(void *)&long long v203 = &v195;
      *(void *)&long long v204 = v171;
      __int16 v205 = 2050;
      llvm::MCAsmParser::Error(*(void *)(a1 + 8), v184, (uint64_t)&v203, 0, 0);
    }
  }
  if (!*(unsigned char *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8)) + 1513)
    || (~*(_DWORD *)(ELFSection + 228) & 6) != 0)
  {
    return 0;
  }
  uint64_t v172 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
  *(void *)&long long v203 = ELFSection;
  uint64_t result = sub_1CC61C590((void *)(v172 + 1520), &v203);
  if (result)
  {
    if (*(unsigned __int16 *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8))
                             + 1624) <= 2u)
    {
      *(void *)&long long v203 = "DWARF2 only supports one section per compilation unit";
      __int16 v205 = 259;
      (*(void (**)(void, uint64_t, long long *, void, void))(**(void **)(a1 + 8) + 168))(*(void *)(a1 + 8), v184, &v203, 0, 0);
    }
    if (*(void *)(ELFSection + 8)) {
      return 0;
    }
    uint64_t v173 = (llvm::MCContext *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
    *(void *)&long long v203 = "tmp";
    __int16 v205 = 259;
    uint64_t TempSymbol = llvm::MCContext::createTempSymbol(v173, (const llvm::Twine *)&v203, 1);
    uint64_t v175 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)v175 + 192))(v175, TempSymbol, 0);
    uint64_t result = 0;
    *(void *)(ELFSection + 8) = TempSymbol;
  }
  return result;
}

uint64_t sub_1CD39089C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
  sub_1CD6AD2C8(v6);
  uint64_t v7 = sub_1CD38E368(a1, 1, a4);
  if (v7)
  {
    uint64_t v8 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    sub_1CCBC2468(v8);
  }
  return v7;
}

uint64_t sub_1CD390934(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
  if (sub_1CCBC2468(v2)) {
    return 0;
  }
  uint64_t v4 = ".popsection without corresponding .pushsection";
  __int16 v5 = 259;
  return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)&v4, 0, 0);
}

uint64_t sub_1CD3909BC(uint64_t a1)
{
  uint64_t v9 = 0;
  unint64_t v10 = 0;
  if ((*(unsigned int (**)(void, unsigned __int8 ***))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v9))
  {
    __int16 v5 = "expected identifier in directive";
  }
  else
  {
    uint64_t v2 = (llvm::MCContext *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
    __int16 v8 = 261;
    v7[0] = v9;
    v7[1] = v10;
    llvm::MCContext::getOrCreateSymbol(v2, v7);
    if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 25)
    {
      (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
      uint64_t v6 = 0;
      v7[0] = 0;
      if ((*(uint64_t (**)(void, uint64_t *, unsigned __int8 ***))(**(void **)(a1 + 8) + 232))(*(void *)(a1 + 8), &v6, v7))return 1; {
      if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 9)
      }
      {
        (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
        uint64_t v4 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
        (*(void (**)(void))(v4 + 424))();
        return 0;
      }
    }
    __int16 v5 = "unexpected token in directive";
  }
  v7[0] = (unsigned __int8 **)v5;
  __int16 v8 = 259;
  return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v7, 0, 0);
}

uint64_t sub_1CD390C00(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
  uint64_t v3 = *(unsigned int *)(v2 + 120);
  if (v3 && (v4 = *(void *)(v2 + 112) + 32 * v3, (uint64_t v5 = *(void *)(v4 - 16)) != 0))
  {
    uint64_t v6 = *(void *)(v4 - 8);
    uint64_t v7 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 168))(v7, v5, v6);
    return 0;
  }
  else
  {
    uint64_t v9 = ".previous without corresponding .section";
    __int16 v10 = 259;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)&v9, 0, 0);
  }
}

uint64_t sub_1CD390CF8(uint64_t a1)
{
  unint64_t v25 = 0;
  uint64_t v26 = 0;
  if ((*(unsigned int (**)(void, unsigned __int8 ***))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v25))
  {
    unint64_t v18 = "expected identifier in directive";
  }
  else
  {
    uint64_t v2 = (llvm::MCContext *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
    __int16 v24 = 261;
    v23[0] = v25;
    v23[1] = v26;
    llvm::MCContext::getOrCreateSymbol(v2, v23);
    if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 25) {
      (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
    }
    if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 2
      && **(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 37
      && **(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 36
      && **(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 3)
    {
      if (!*(unsigned char *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 105))
      {
        unint64_t v18 = "expected STT_<TYPE_IN_UPPER_CASE>, '#<type>', '%<type>' or \"<type>\"";
        goto LABEL_85;
      }
      if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 45)
      {
        unint64_t v18 = "expected STT_<TYPE_IN_UPPER_CASE>, '#<type>', '@<type>', '%<type>' or \"<type>\"";
        goto LABEL_85;
      }
    }
    if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 3
      && **(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 2)
    {
      (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
    }
    uint64_t v3 = *(void *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 96);
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    if ((*(unsigned int (**)(void, uint64_t *))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v21))
    {
      unint64_t v18 = "expected symbol type in directive";
    }
    else
    {
      switch(v22)
      {
        case 6:
          if (*(_DWORD *)v21 == 1701470831 && *(_WORD *)(v21 + 4) == 29795) {
            goto LABEL_73;
          }
          if (*(_DWORD *)v21 == 1835888483 && *(_WORD *)(v21 + 4) == 28271) {
            goto LABEL_76;
          }
          if (*(_DWORD *)v21 ^ 0x79746F6E | *(unsigned __int16 *)(v21 + 4) ^ 0x6570) {
            unint64_t v6 = 0;
          }
          else {
            unint64_t v6 = 0x100000007;
          }
          goto LABEL_78;
        case 7:
          if (*(_DWORD *)v21 != 1599362131 || *(_DWORD *)(v21 + 3) != 1397511263) {
            goto LABEL_83;
          }
          unint64_t v6 = 0x100000005;
          goto LABEL_78;
        case 8:
          unint64_t v6 = 0x100000002;
          if (*(void *)v21 != 0x434E55465F545453 && *(void *)v21 != 0x6E6F6974636E7566) {
            goto LABEL_83;
          }
          goto LABEL_78;
        case 10:
          if (*(void *)v21 == 0x454A424F5F545453 && *(_WORD *)(v21 + 8) == 21571)
          {
LABEL_73:
            unint64_t v6 = 0x100000004;
          }
          else if (*(void *)v21 == 0x656A626F5F736C74 && *(_WORD *)(v21 + 8) == 29795)
          {
            unint64_t v6 = 0x100000005;
          }
          else if (*(void *)v21 == 0x4D4D4F435F545453 && *(_WORD *)(v21 + 8) == 20047)
          {
LABEL_76:
            unint64_t v6 = 0x100000006;
          }
          else
          {
            if (*(void *)v21 != 0x59544F4E5F545453 || *(_WORD *)(v21 + 8) != 17744) {
              goto LABEL_83;
            }
            unint64_t v6 = 0x100000007;
          }
LABEL_78:
          if (!HIDWORD(v6) || !v6)
          {
LABEL_83:
            v23[0] = (unsigned __int8 **)"unsupported attribute in '.type' directive";
            __int16 v24 = 259;
            return llvm::MCAsmParser::Error(*(void *)(a1 + 8), v3, (uint64_t)v23, 0, 0);
          }
          if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 9)
          {
            (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
            uint64_t v19 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
            (*(void (**)(void))(v19 + 304))();
            return 0;
          }
          unint64_t v18 = "unexpected token in '.type' directive";
          break;
        case 13:
          uint64_t v12 = *(void *)(v21 + 5);
          BOOL v13 = *(void *)v21 == 0x5F554E475F545453;
          uint64_t v14 = 0x434E5546495F554ELL;
          goto LABEL_67;
        case 17:
          if (*(void *)v21 != 0x71696E755F756E67
            || *(void *)(v21 + 8) != 0x63656A626F5F6575
            || *(unsigned char *)(v21 + 16) != 116)
          {
            goto LABEL_83;
          }
          unint64_t v6 = 0x100000008;
          goto LABEL_78;
        case 21:
          uint64_t v12 = *(void *)(v21 + 13);
          BOOL v13 = *(void *)v21 == 0x69646E695F756E67 && *(void *)(v21 + 8) == 0x6E75665F74636572;
          uint64_t v14 = 0x6E6F6974636E7566;
LABEL_67:
          if (!v13 || v12 != v14) {
            goto LABEL_83;
          }
          unint64_t v6 = 0x100000003;
          goto LABEL_78;
        default:
          goto LABEL_83;
      }
    }
  }
LABEL_85:
  v23[0] = (unsigned __int8 **)v18;
  __int16 v24 = 259;
  return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v23, 0, 0);
}

uint64_t sub_1CD3914A0(uint64_t a1)
{
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 3
    && ((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)),
        (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8)),
        **(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 9))
  {
    (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
    uint64_t v2 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    (*(void (**)(void))(v2 + 680))();
    return 0;
  }
  else
  {
    uint64_t v4 = "unexpected token in '.ident' directive";
    __int16 v5 = 259;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)&v4, 0, 0);
  }
}

uint64_t sub_1CD39168C(uint64_t a1)
{
  unint64_t v18 = 0;
  uint64_t v19 = 0;
  __s = 0;
  size_t __n = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  if ((*(unsigned int (**)(void, unsigned __int8 ***))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v18))
  {
    goto LABEL_4;
  }
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 25)
  {
    uint64_t v3 = "expected a comma";
    goto LABEL_20;
  }
  char v2 = *(unsigned char *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 105);
  *(unsigned char *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 105) = 1;
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  *(unsigned char *)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 105) = v2;
  if ((*(unsigned int (**)(void, void **))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &__s))
  {
LABEL_4:
    uint64_t v3 = "expected identifier in directive";
  }
  else
  {
    if (__n)
    {
      uint64_t v4 = __s;
      __int16 v5 = memchr(__s, 64, __n);
      if (v5)
      {
        if (v5 - v4 != -1)
        {
          BOOL v6 = llvm::StringRef::find((uint64_t *)&__s, "@@@", 3uLL, 0) == -1;
          if (llvm::MCAsmParser::parseOptionalToken(*(llvm::MCAsmParser **)(a1 + 8), 25))
          {
            if (((*(uint64_t (**)(void, uint64_t *))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v14) & 1) != 0|| v15 != 6|| (*(_DWORD *)v14 == 1869440370 ? (BOOL v7 = *(unsigned __int16 *)(v14 + 4) == 25974) : (BOOL v7 = 0), !v7))
            {
              uint64_t v3 = "expected 'remove'";
              goto LABEL_20;
            }
            BOOL v6 = 0;
          }
          llvm::MCAsmParser::parseOptionalToken(*(llvm::MCAsmParser **)(a1 + 8), 9);
          uint64_t v8 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
          uint64_t v9 = (llvm::MCContext *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
          __int16 v13 = 261;
          v12[0] = v18;
          v12[1] = v19;
          uint64_t Symbol = llvm::MCContext::getOrCreateSymbol(v9, v12);
          (*(void (**)(uint64_t, uint64_t, void *, size_t, BOOL))(*(void *)v8 + 432))(v8, Symbol, __s, __n, v6);
          return 0;
        }
      }
    }
    uint64_t v3 = "expected a '@' in the name";
  }
LABEL_20:
  v12[0] = (unsigned __int8 **)v3;
  __int16 v13 = 259;
  return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v12, 0, 0);
}

uint64_t sub_1CD3919E0(uint64_t a1)
{
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 3)
  {
    (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8));
    (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
    char v2 = (llvm::MCContext *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
    uint64_t v15 = ".note";
    __int16 v16 = 259;
    __int16 v18 = 257;
    uint64_t ELFSection = llvm::MCContext::getELFSection(v2, (const llvm::Twine *)&v15, 7, 0, 0, (const llvm::Twine *)v17, 0, -1, 0);
    uint64_t v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    __n128 v5 = sub_1CD6AD2C8(v4);
    uint64_t v6 = (*(uint64_t (**)(void, __n128))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8), v5);
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)v6 + 168))(v6, ELFSection, 0);
    uint64_t v7 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    (*(void (**)(void))(v7 + 520))();
    uint64_t v8 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    (*(void (**)(void))(v8 + 520))();
    uint64_t v9 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    (*(void (**)(void))(v9 + 520))();
    uint64_t v10 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    (*(void (**)(void))(v10 + 488))();
    uint64_t v11 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    (*(void (**)(void))(v11 + 520))();
    uint64_t v12 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    (*(void (**)(void))(v12 + 640))();
    uint64_t v13 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    sub_1CCBC2468(v13);
    return 0;
  }
  else
  {
    v17[0] = "unexpected token in '.version' directive";
    __int16 v18 = 259;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v17, 0, 0);
  }
}

uint64_t sub_1CD391E94(uint64_t a1)
{
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  if ((*(unsigned int (**)(void, unsigned __int8 ***))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v12))
  {
    goto LABEL_6;
  }
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 25)
  {
    uint64_t v6 = "expected a comma";
    goto LABEL_8;
  }
  (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  if ((*(unsigned int (**)(void, unsigned __int8 ***))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v7))
  {
LABEL_6:
    uint64_t v6 = "expected identifier in directive";
LABEL_8:
    uint64_t v9 = (unsigned __int8 **)v6;
    __int16 v11 = 259;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)&v9, 0, 0);
  }
  char v2 = (llvm::MCContext *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
  __int16 v11 = 261;
  uint64_t v9 = v12;
  uint64_t v10 = v13;
  llvm::MCContext::getOrCreateSymbol(v2, &v9);
  uint64_t v3 = (llvm::MCContext *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
  __int16 v11 = 261;
  uint64_t v9 = v7;
  uint64_t v10 = v8;
  llvm::MCContext::getOrCreateSymbol(v3, &v9);
  uint64_t v4 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
  (*(void (**)(void))(v4 + 296))();
  return 0;
}

uint64_t sub_1CD3920B4(uint64_t a1)
{
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 9)
  {
LABEL_2:
    (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
    return 0;
  }
  uint64_t v10 = 0;
  __int16 v11 = 0;
  if ((*(uint64_t (**)(void, unsigned __int8 ***))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v10))
  {
LABEL_11:
    uint64_t v7 = "expected identifier in directive";
    goto LABEL_12;
  }
  while (1)
  {
    int v3 = (*(uint64_t (**)(void, unsigned __int8 **, unsigned __int8 **))(**(void **)(a1 + 8) + 104))(*(void *)(a1 + 8), v10, v11);
    uint64_t v4 = **(void **)(a1 + 8);
    if (v3)
    {
      if (**(_DWORD **)((*(uint64_t (**)(void))(v4 + 40))() + 8) == 9) {
        goto LABEL_2;
      }
      goto LABEL_10;
    }
    __n128 v5 = (llvm::MCContext *)(*(uint64_t (**)(void))(v4 + 48))();
    __int16 v9 = 261;
    v8[0] = v10;
    v8[1] = v11;
    llvm::MCContext::getOrCreateSymbol(v5, v8);
    uint64_t v6 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    (*(void (**)(void))(v6 + 304))();
    if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 9) {
      goto LABEL_2;
    }
    if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 25) {
      break;
    }
    (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
LABEL_10:
    uint64_t v10 = 0;
    __int16 v11 = 0;
    if ((*(uint64_t (**)(void, unsigned __int8 ***))(**(void **)(a1 + 8) + 192))(*(void *)(a1 + 8), &v10))goto LABEL_11; {
  }
    }
  uint64_t v7 = "unexpected token in directive";
LABEL_12:
  v8[0] = (unsigned __int8 **)v7;
  __int16 v9 = 259;
  return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v8, 0, 0);
}

uint64_t sub_1CD3924F8(uint64_t a1)
{
  uint64_t v8 = 0;
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) != 9)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    v6[0] = 0;
    if ((*(uint64_t (**)(uint64_t, uint64_t *, void *))(*(void *)v2 + 232))(v2, &v8, v6)) {
      return 1;
    }
  }
  if (**(_DWORD **)((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8)) + 8) == 9)
  {
    (*(void (**)(void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8));
    uint64_t v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
    uint64_t v5 = *(unsigned int *)(v4 + 120);
    if (v5) {
      (*(void (**)(uint64_t, void, uint64_t))(*(void *)v4 + 168))(v4, *(void *)(*(void *)(v4 + 112) + 32 * v5 - 32), v8);
    }
    return 0;
  }
  else
  {
    v6[0] = "unexpected token in directive";
    __int16 v7 = 259;
    return llvm::MCAsmParser::TokError(*(void *)(a1 + 8), (uint64_t)v6, 0, 0);
  }
}

uint64_t llvm::AsmToken::getLocRange(llvm::AsmToken *this)
{
  return *((void *)this + 1);
}

llvm::raw_ostream *llvm::AsmToken::dump(llvm::AsmToken *this, llvm::raw_ostream *a2)
{
  switch(*(_DWORD *)this)
  {
    case 0:
      uint64_t v4 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v4) <= 2)
      {
        uint64_t v5 = "Eof";
        goto LABEL_122;
      }
      *(unsigned char *)(v4 + 2) = 102;
      __int16 v35 = 28485;
      goto LABEL_234;
    case 1:
      uint64_t v6 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v6) <= 4)
      {
        uint64_t v5 = "error";
        goto LABEL_103;
      }
      *(unsigned char *)(v6 + 4) = 114;
      int v36 = 1869771365;
      goto LABEL_222;
    case 2:
      uint64_t v7 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v7) <= 0xB)
      {
        uint64_t v8 = "identifier: ";
        __int16 v9 = a2;
        size_t v10 = 12;
        goto LABEL_86;
      }
      *(_DWORD *)(v7 + 8) = 540701285;
      *(void *)uint64_t v7 = *(void *)"identifier: ";
      unint64_t v29 = (void *)(*((void *)a2 + 4) + 12);
      goto LABEL_213;
    case 3:
      __int16 v11 = (void *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v11 <= 7uLL)
      {
        uint64_t v8 = "string: ";
        __int16 v9 = a2;
        size_t v10 = 8;
        goto LABEL_86;
      }
      void *v11 = 0x203A676E69727473;
      unint64_t v29 = (void *)(*((void *)a2 + 4) + 8);
      goto LABEL_213;
    case 4:
      uint64_t v12 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v12) <= 4)
      {
        uint64_t v8 = "int: ";
        __int16 v9 = a2;
        size_t v10 = 5;
        goto LABEL_86;
      }
      *(unsigned char *)(v12 + 4) = 32;
      *(_DWORD *)uint64_t v12 = 980708969;
      unint64_t v29 = (void *)(*((void *)a2 + 4) + 5);
      goto LABEL_213;
    case 5:
      uint64_t v17 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v17) <= 5)
      {
        uint64_t v5 = "BigNum";
        goto LABEL_112;
      }
      *(_WORD *)(v17 + 4) = 28021;
      int v43 = 1315400002;
      goto LABEL_228;
    case 6:
      uint64_t v27 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v27) > 5)
      {
        *(_WORD *)(v27 + 4) = 8250;
        *(_DWORD *)uint64_t v27 = 1818322290;
        unint64_t v29 = (void *)(*((void *)a2 + 4) + 6);
LABEL_213:
        *((void *)a2 + 4) = v29;
        uint64_t v28 = a2;
      }
      else
      {
        uint64_t v8 = "real: ";
        __int16 v9 = a2;
        size_t v10 = 6;
LABEL_86:
        uint64_t v28 = llvm::raw_ostream::write(v9, v8, v10);
        unint64_t v29 = (void *)*((void *)v28 + 4);
      }
      uint64_t v5 = (const char *)*((void *)this + 1);
      unint64_t v30 = *((void *)this + 2);
      if (v30 > *((void *)v28 + 3) - (void)v29)
      {
        uint64_t v21 = v28;
        size_t v22 = *((void *)this + 2);
        goto LABEL_162;
      }
      if (v30)
      {
        memcpy(v29, v5, *((void *)this + 2));
        *((void *)v28 + 4) += v30;
      }
      goto LABEL_163;
    case 7:
      uint64_t v13 = (int *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v13 <= 6uLL)
      {
        uint64_t v5 = "Comment";
        goto LABEL_131;
      }
      *(int *)((char *)v13 + 3) = 1953391981;
      int v37 = 1835888451;
      goto LABEL_240;
    case 8:
      uint64_t v23 = (void *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v23 <= 0xCuLL)
      {
        uint64_t v5 = "HashDirective";
        goto LABEL_161;
      }
      BOOL v48 = "HashDirective";
      goto LABEL_258;
    case 9:
      uint64_t v14 = (void *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v14 <= 0xDuLL)
      {
        uint64_t v5 = "EndOfStatement";
        goto LABEL_155;
      }
      unint64_t v38 = "EndOfStatement";
      goto LABEL_254;
    case 0xA:
      uint64_t v6 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v6) <= 4)
      {
        uint64_t v5 = "Colon";
        goto LABEL_103;
      }
      *(unsigned char *)(v6 + 4) = 110;
      int v36 = 1869377347;
      goto LABEL_222;
    case 0xB:
      uint64_t v6 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v6) <= 4)
      {
        uint64_t v5 = "Space";
        goto LABEL_103;
      }
      *(unsigned char *)(v6 + 4) = 101;
      int v36 = 1667330131;
      goto LABEL_222;
    case 0xC:
      uint64_t v15 = (int *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v15 <= 3uLL)
      {
        uint64_t v5 = "Plus";
        goto LABEL_125;
      }
      int v39 = 1937075280;
      goto LABEL_236;
    case 0xD:
      uint64_t v6 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v6) <= 4)
      {
        uint64_t v5 = "Minus";
        goto LABEL_103;
      }
      *(unsigned char *)(v6 + 4) = 115;
      int v36 = 1970170189;
      goto LABEL_222;
    case 0xE:
      uint64_t v6 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v6) <= 4)
      {
        uint64_t v5 = "Tilde";
        goto LABEL_103;
      }
      *(unsigned char *)(v6 + 4) = 101;
      int v36 = 1684826452;
      goto LABEL_222;
    case 0xF:
      uint64_t v6 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v6) <= 4)
      {
        uint64_t v5 = "Slash";
        goto LABEL_103;
      }
      *(unsigned char *)(v6 + 4) = 104;
      int v36 = 1935764563;
      goto LABEL_222;
    case 0x10:
      uint64_t v16 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v16) <= 8)
      {
        uint64_t v5 = "BackSlash";
        goto LABEL_128;
      }
      char v40 = 104;
      unsigned __int8 v41 = "BackSlash";
      goto LABEL_238;
    case 0x11:
      uint64_t v17 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v17) <= 5)
      {
        uint64_t v5 = "LParen";
        goto LABEL_112;
      }
      *(_WORD *)(v17 + 4) = 28261;
      unsigned __int16 v42 = 20556;
      goto LABEL_218;
    case 0x12:
      uint64_t v17 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v17) <= 5)
      {
        uint64_t v5 = "RParen";
        goto LABEL_112;
      }
      *(_WORD *)(v17 + 4) = 28261;
      unsigned __int16 v42 = 20562;
LABEL_218:
      int v43 = v42 | 0x72610000;
      goto LABEL_228;
    case 0x13:
      uint64_t v6 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v6) <= 4)
      {
        uint64_t v5 = "LBrac";
        goto LABEL_103;
      }
      *(unsigned char *)(v6 + 4) = 99;
      unsigned __int16 v53 = 16972;
      goto LABEL_221;
    case 0x14:
      uint64_t v6 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v6) <= 4)
      {
        uint64_t v5 = "RBrac";
        goto LABEL_103;
      }
      *(unsigned char *)(v6 + 4) = 99;
      unsigned __int16 v53 = 16978;
LABEL_221:
      int v36 = v53 | 0x61720000;
      goto LABEL_222;
    case 0x15:
      uint64_t v17 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v17) <= 5)
      {
        uint64_t v5 = "LCurly";
        goto LABEL_112;
      }
      *(_WORD *)(v17 + 4) = 31084;
      unsigned __int16 v54 = 17228;
      goto LABEL_225;
    case 0x16:
      uint64_t v17 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v17) <= 5)
      {
        uint64_t v5 = "RCurly";
        goto LABEL_112;
      }
      *(_WORD *)(v17 + 4) = 31084;
      unsigned __int16 v54 = 17234;
LABEL_225:
      int v43 = v54 | 0x72750000;
      goto LABEL_228;
    case 0x17:
      uint64_t v15 = (int *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v15 <= 3uLL)
      {
        uint64_t v5 = "Star";
        goto LABEL_125;
      }
      int v39 = 1918989395;
      goto LABEL_236;
    case 0x18:
      uint64_t v4 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v4) <= 2)
      {
        uint64_t v5 = "Dot";
        goto LABEL_122;
      }
      *(unsigned char *)(v4 + 2) = 116;
      __int16 v35 = 28484;
      goto LABEL_234;
    case 0x19:
      uint64_t v6 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v6) <= 4)
      {
        uint64_t v5 = "Comma";
        goto LABEL_103;
      }
      *(unsigned char *)(v6 + 4) = 97;
      int v36 = 1835888451;
      goto LABEL_222;
    case 0x1A:
      uint64_t v17 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v17) <= 5)
      {
        uint64_t v5 = "Dollar";
        goto LABEL_112;
      }
      *(_WORD *)(v17 + 4) = 29281;
      int v43 = 1819045700;
      goto LABEL_228;
    case 0x1B:
      uint64_t v6 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v6) <= 4)
      {
        uint64_t v5 = "Equal";
        goto LABEL_103;
      }
      *(unsigned char *)(v6 + 4) = 108;
      int v36 = 1635086661;
      goto LABEL_222;
    case 0x1C:
      uint64_t v26 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v26) <= 9)
      {
        uint64_t v5 = "EqualEqual";
        goto LABEL_142;
      }
      __int16 v51 = 27745;
      uint64_t v52 = "EqualEqual";
      goto LABEL_247;
    case 0x1D:
      uint64_t v15 = (int *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v15 <= 3uLL)
      {
        uint64_t v5 = "Pipe";
        goto LABEL_125;
      }
      int v39 = 1701865808;
      goto LABEL_236;
    case 0x1E:
      uint64_t v19 = (uint64_t *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v19 <= 7uLL)
      {
        uint64_t v5 = "PipePipe";
        goto LABEL_119;
      }
      uint64_t v46 = 0x6570695065706950;
      goto LABEL_232;
    case 0x1F:
      uint64_t v6 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v6) <= 4)
      {
        uint64_t v5 = "Caret";
LABEL_103:
        uint64_t v21 = a2;
        size_t v22 = 5;
        goto LABEL_162;
      }
      *(unsigned char *)(v6 + 4) = 116;
      int v36 = 1701994819;
LABEL_222:
      *(_DWORD *)uint64_t v6 = v36;
      uint64_t v47 = *((void *)a2 + 4) + 5;
      goto LABEL_259;
    case 0x20:
      uint64_t v4 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v4) <= 2)
      {
        uint64_t v5 = "Amp";
LABEL_122:
        uint64_t v21 = a2;
        size_t v22 = 3;
        goto LABEL_162;
      }
      *(unsigned char *)(v4 + 2) = 112;
      __int16 v35 = 27969;
LABEL_234:
      *(_WORD *)uint64_t v4 = v35;
      uint64_t v47 = *((void *)a2 + 4) + 3;
      goto LABEL_259;
    case 0x21:
      uint64_t v17 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v17) <= 5)
      {
        uint64_t v5 = "AmpAmp";
LABEL_112:
        uint64_t v21 = a2;
        size_t v22 = 6;
        goto LABEL_162;
      }
      *(_WORD *)(v17 + 4) = 28781;
      int v43 = 1097887041;
LABEL_228:
      *(_DWORD *)uint64_t v17 = v43;
      uint64_t v47 = *((void *)a2 + 4) + 6;
      goto LABEL_259;
    case 0x22:
      uint64_t v13 = (int *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v13 <= 6uLL)
      {
        uint64_t v5 = "Exclaim";
        goto LABEL_131;
      }
      *(int *)((char *)v13 + 3) = 1835622764;
      int v37 = 1818458181;
      goto LABEL_240;
    case 0x23:
      uint64_t v18 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v18) <= 0xB)
      {
        uint64_t v5 = "ExclaimEqual";
        goto LABEL_136;
      }
      int v44 = 1818326385;
      BOOL v45 = "ExclaimEqual";
      goto LABEL_243;
    case 0x24:
      uint64_t v13 = (int *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v13 <= 6uLL)
      {
        uint64_t v5 = "Percent";
        goto LABEL_131;
      }
      *(int *)((char *)v13 + 3) = 1953391971;
      int v37 = 1668441424;
      goto LABEL_240;
    case 0x25:
      uint64_t v15 = (int *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v15 <= 3uLL)
      {
        uint64_t v5 = "Hash";
        goto LABEL_125;
      }
      int v39 = 1752392008;
      goto LABEL_236;
    case 0x26:
      uint64_t v15 = (int *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v15 <= 3uLL)
      {
        uint64_t v5 = "Less";
LABEL_125:
        uint64_t v21 = a2;
        size_t v22 = 4;
        goto LABEL_162;
      }
      int v39 = 1936942412;
LABEL_236:
      *uint64_t v15 = v39;
      uint64_t v47 = *((void *)a2 + 4) + 4;
      goto LABEL_259;
    case 0x27:
      uint64_t v16 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v16) <= 8)
      {
        uint64_t v5 = "LessEqual";
        goto LABEL_128;
      }
      char v40 = 108;
      unsigned __int8 v41 = "LessEqual";
      goto LABEL_238;
    case 0x28:
      uint64_t v19 = (uint64_t *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v19 <= 7uLL)
      {
        uint64_t v5 = "LessLess";
LABEL_119:
        uint64_t v21 = a2;
        size_t v22 = 8;
        goto LABEL_162;
      }
      uint64_t v46 = 0x7373654C7373654CLL;
LABEL_232:
      *uint64_t v19 = v46;
      uint64_t v47 = *((void *)a2 + 4) + 8;
      goto LABEL_259;
    case 0x29:
      uint64_t v20 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v20) <= 0xA)
      {
        uint64_t v5 = "LessGreater";
        uint64_t v21 = a2;
        size_t v22 = 11;
        goto LABEL_162;
      }
      *(_DWORD *)(v20 + 7) = 1919251553;
      *(void *)uint64_t v20 = *(void *)"LessGreater";
      uint64_t v47 = *((void *)a2 + 4) + 11;
      goto LABEL_259;
    case 0x2A:
      uint64_t v13 = (int *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v13 <= 6uLL)
      {
        uint64_t v5 = "Greater";
LABEL_131:
        uint64_t v21 = a2;
        size_t v22 = 7;
        goto LABEL_162;
      }
      *(int *)((char *)v13 + 3) = 1919251553;
      int v37 = 1634038343;
LABEL_240:
      *uint64_t v13 = v37;
      uint64_t v47 = *((void *)a2 + 4) + 7;
      goto LABEL_259;
    case 0x2B:
      uint64_t v18 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v18) <= 0xB)
      {
        uint64_t v5 = "GreaterEqual";
        goto LABEL_136;
      }
      int v44 = 1818326385;
      BOOL v45 = "GreaterEqual";
      goto LABEL_243;
    case 0x2C:
      uint64_t v14 = (void *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v14 <= 0xDuLL)
      {
        uint64_t v5 = "GreaterGreater";
        goto LABEL_155;
      }
      unint64_t v38 = "GreaterGreater";
      goto LABEL_254;
    case 0x2D:
      unsigned int v31 = (_WORD *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v31 <= 1uLL)
      {
        uint64_t v5 = "At";
        uint64_t v21 = a2;
        size_t v22 = 2;
        goto LABEL_162;
      }
      _WORD *v31 = 29761;
      uint64_t v47 = *((void *)a2 + 4) + 2;
      goto LABEL_259;
    case 0x2E:
      uint64_t v18 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v18) <= 0xB)
      {
        uint64_t v5 = "MinusGreater";
        goto LABEL_136;
      }
      int v44 = 1919251553;
      BOOL v45 = "MinusGreater";
      goto LABEL_243;
    case 0x2F:
      uint64_t v23 = (void *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v23 <= 0xCuLL)
      {
        uint64_t v5 = "PercentCall16";
        goto LABEL_161;
      }
      BOOL v48 = "PercentCall16";
      goto LABEL_258;
    case 0x30:
      uint64_t v14 = (void *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v14 <= 0xDuLL)
      {
        uint64_t v5 = "PercentCall_Hi";
        goto LABEL_155;
      }
      unint64_t v38 = "PercentCall_Hi";
      goto LABEL_254;
    case 0x31:
      uint64_t v14 = (void *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v14 <= 0xDuLL)
      {
        uint64_t v5 = "PercentCall_Lo";
        goto LABEL_155;
      }
      unint64_t v38 = "PercentCall_Lo";
      goto LABEL_254;
    case 0x32:
      __int16 v24 = (_OWORD *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v24 <= 0xFuLL)
      {
        uint64_t v5 = "PercentDtprel_Hi";
        goto LABEL_139;
      }
      BOOL v49 = "PercentDtprel_Hi";
      goto LABEL_245;
    case 0x33:
      __int16 v24 = (_OWORD *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v24 <= 0xFuLL)
      {
        uint64_t v5 = "PercentDtprel_Lo";
LABEL_139:
        uint64_t v21 = a2;
        size_t v22 = 16;
        goto LABEL_162;
      }
      BOOL v49 = "PercentDtprel_Lo";
LABEL_245:
      _OWORD *v24 = *(_OWORD *)v49;
      uint64_t v47 = *((void *)a2 + 4) + 16;
      goto LABEL_259;
    case 0x34:
      uint64_t v26 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v26) <= 9)
      {
        uint64_t v5 = "PercentGot";
        goto LABEL_142;
      }
      __int16 v51 = 29807;
      uint64_t v52 = "PercentGot";
      goto LABEL_247;
    case 0x35:
      unint64_t v25 = (void *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v25 <= 0xEuLL)
      {
        uint64_t v5 = "PercentGot_Disp";
        goto LABEL_158;
      }
      uint64_t v50 = "PercentGot_Disp";
      goto LABEL_256;
    case 0x36:
      uint64_t v23 = (void *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v23 <= 0xCuLL)
      {
        uint64_t v5 = "PercentGot_Hi";
        goto LABEL_161;
      }
      BOOL v48 = "PercentGot_Hi";
      goto LABEL_258;
    case 0x37:
      uint64_t v23 = (void *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v23 <= 0xCuLL)
      {
        uint64_t v5 = "PercentGot_Lo";
        goto LABEL_161;
      }
      BOOL v48 = "PercentGot_Lo";
      goto LABEL_258;
    case 0x38:
      unint64_t v25 = (void *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v25 <= 0xEuLL)
      {
        uint64_t v5 = "PercentGot_Ofst";
        goto LABEL_158;
      }
      uint64_t v50 = "PercentGot_Ofst";
      goto LABEL_256;
    case 0x39:
      unint64_t v25 = (void *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v25 <= 0xEuLL)
      {
        uint64_t v5 = "PercentGot_Page";
        goto LABEL_158;
      }
      uint64_t v50 = "PercentGot_Page";
      goto LABEL_256;
    case 0x3A:
      unint64_t v25 = (void *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v25 <= 0xEuLL)
      {
        uint64_t v5 = "PercentGottprel";
        goto LABEL_158;
      }
      uint64_t v50 = "PercentGottprel";
      goto LABEL_256;
    case 0x3B:
      uint64_t v23 = (void *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v23 <= 0xCuLL)
      {
        uint64_t v5 = "PercentGp_Rel";
        goto LABEL_161;
      }
      BOOL v48 = "PercentGp_Rel";
      goto LABEL_258;
    case 0x3C:
      uint64_t v16 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v16) <= 8)
      {
        uint64_t v5 = "PercentHi";
        goto LABEL_128;
      }
      char v40 = 105;
      unsigned __int8 v41 = "PercentHi";
      goto LABEL_238;
    case 0x3D:
      uint64_t v23 = (void *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v23 <= 0xCuLL)
      {
        uint64_t v5 = "PercentHigher";
        goto LABEL_161;
      }
      BOOL v48 = "PercentHigher";
      goto LABEL_258;
    case 0x3E:
      uint64_t v14 = (void *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v14 <= 0xDuLL)
      {
        uint64_t v5 = "PercentHighest";
LABEL_155:
        uint64_t v21 = a2;
        size_t v22 = 14;
        goto LABEL_162;
      }
      unint64_t v38 = "PercentHighest";
LABEL_254:
      *uint64_t v14 = *(void *)v38;
      *(void *)((char *)v14 + 6) = *(void *)(v38 + 6);
      uint64_t v47 = *((void *)a2 + 4) + 14;
      goto LABEL_259;
    case 0x3F:
      uint64_t v16 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v16) <= 8)
      {
        uint64_t v5 = "PercentLo";
LABEL_128:
        uint64_t v21 = a2;
        size_t v22 = 9;
        goto LABEL_162;
      }
      char v40 = 111;
      unsigned __int8 v41 = "PercentLo";
LABEL_238:
      *(unsigned char *)(v16 + 8) = v40;
      *(void *)uint64_t v16 = *(void *)v41;
      uint64_t v47 = *((void *)a2 + 4) + 9;
      goto LABEL_259;
    case 0x40:
      uint64_t v26 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v26) <= 9)
      {
        uint64_t v5 = "PercentNeg";
LABEL_142:
        uint64_t v21 = a2;
        size_t v22 = 10;
        goto LABEL_162;
      }
      __int16 v51 = 26469;
      uint64_t v52 = "PercentNeg";
LABEL_247:
      *(_WORD *)(v26 + 8) = v51;
      *(void *)uint64_t v26 = *(void *)v52;
      uint64_t v47 = *((void *)a2 + 4) + 10;
      goto LABEL_259;
    case 0x41:
      unint64_t v25 = (void *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v25 <= 0xEuLL)
      {
        uint64_t v5 = "PercentPcrel_Hi";
        goto LABEL_158;
      }
      uint64_t v50 = "PercentPcrel_Hi";
      goto LABEL_256;
    case 0x42:
      unint64_t v25 = (void *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v25 <= 0xEuLL)
      {
        uint64_t v5 = "PercentPcrel_Lo";
        goto LABEL_158;
      }
      uint64_t v50 = "PercentPcrel_Lo";
      goto LABEL_256;
    case 0x43:
      uint64_t v18 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v18) <= 0xB)
      {
        uint64_t v5 = "PercentTlsgd";
LABEL_136:
        uint64_t v21 = a2;
        size_t v22 = 12;
        goto LABEL_162;
      }
      int v44 = 1684501356;
      BOOL v45 = "PercentTlsgd";
LABEL_243:
      *(_DWORD *)(v18 + 8) = v44;
      *(void *)uint64_t v18 = *(void *)v45;
      uint64_t v47 = *((void *)a2 + 4) + 12;
      goto LABEL_259;
    case 0x44:
      uint64_t v23 = (void *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v23 <= 0xCuLL)
      {
        uint64_t v5 = "PercentTlsldm";
LABEL_161:
        uint64_t v21 = a2;
        size_t v22 = 13;
        goto LABEL_162;
      }
      BOOL v48 = "PercentTlsldm";
LABEL_258:
      *uint64_t v23 = *(void *)v48;
      *(void *)((char *)v23 + 5) = *(void *)(v48 + 5);
      uint64_t v47 = *((void *)a2 + 4) + 13;
      goto LABEL_259;
    case 0x45:
      unint64_t v25 = (void *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v25 <= 0xEuLL)
      {
        uint64_t v5 = "PercentTprel_Hi";
        goto LABEL_158;
      }
      uint64_t v50 = "PercentTprel_Hi";
      goto LABEL_256;
    case 0x46:
      unint64_t v25 = (void *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v25 > 0xEuLL)
      {
        uint64_t v50 = "PercentTprel_Lo";
LABEL_256:
        *unint64_t v25 = *(void *)v50;
        *(void *)((char *)v25 + 7) = *(void *)(v50 + 7);
        uint64_t v47 = *((void *)a2 + 4) + 15;
LABEL_259:
        *((void *)a2 + 4) = v47;
      }
      else
      {
        uint64_t v5 = "PercentTprel_Lo";
LABEL_158:
        uint64_t v21 = a2;
        size_t v22 = 15;
LABEL_162:
        llvm::raw_ostream::write(v21, v5, v22);
      }
LABEL_163:
      uint64_t v32 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v32) > 2)
      {
        *(unsigned char *)(v32 + 2) = 34;
        *(_WORD *)uint64_t v32 = 10272;
        *((void *)a2 + 4) += 3;
      }
      else
      {
        llvm::raw_ostream::write(a2, " (\"", 3uLL);
      }
      uint64_t result = llvm::raw_ostream::write_escaped(a2, *((char **)this + 1), *((void *)this + 2), 0);
      int v34 = (_WORD *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v34 > 1uLL)
      {
        *int v34 = 10530;
        *((void *)a2 + 4) += 2;
      }
      else
      {
        return llvm::raw_ostream::write(a2, "\")", 2uLL);
      }
      return result;
    default:
      goto LABEL_163;
  }
}