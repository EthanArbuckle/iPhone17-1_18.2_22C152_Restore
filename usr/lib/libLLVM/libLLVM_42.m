void sub_1CCC78C2C(uint64_t a1, _DWORD *a2)
{
  char *v4;
  char *v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  int64_t v12;
  char *v13;
  unint64_t v14;
  char *v15;
  char *v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  int v21;

  v4 = *(char **)(a1 + 16);
  if (v4 == *(char **)(a1 + 24))
  {
    v6 = *(char **)a1;
    v5 = *(char **)(a1 + 8);
    if ((unint64_t)v5 <= *(void *)a1)
    {
      if (v4 == v6) {
        v14 = 1;
      }
      else {
        v14 = (v4 - v6) >> 1;
      }
      if (v14 >> 62) {
        sub_1CB833614();
      }
      v15 = (char *)operator new(4 * v14);
      v16 = &v15[v14 & 0xFFFFFFFFFFFFFFFCLL];
      v18 = v4 - v5;
      v17 = v4 == v5;
      v4 = v16;
      if (!v17)
      {
        v4 = &v16[v18 & 0xFFFFFFFFFFFFFFFCLL];
        v19 = 4 * (v18 >> 2);
        v20 = &v15[v14 & 0xFFFFFFFFFFFFFFFCLL];
        do
        {
          v21 = *(_DWORD *)v5;
          v5 += 4;
          *(_DWORD *)v20 = v21;
          v20 += 4;
          v19 -= 4;
        }
        while (v19);
      }
      *(void *)a1 = v15;
      *(void *)(a1 + 8) = v16;
      *(void *)(a1 + 16) = v4;
      *(void *)(a1 + 24) = &v15[4 * v14];
      if (v6)
      {
        operator delete(v6);
        v4 = *(char **)(a1 + 16);
      }
    }
    else
    {
      v7 = (uint64_t)&v5[-*(void *)a1] >> 2;
      if (v7 >= -1) {
        v8 = v7 + 1;
      }
      else {
        v8 = v7 + 2;
      }
      v9 = -(v8 >> 1);
      v10 = v8 >> 1;
      v11 = &v5[-4 * v10];
      v12 = v4 - v5;
      if (v4 != v5)
      {
        memmove(&v5[-4 * v10], *(const void **)(a1 + 8), v4 - v5);
        v4 = *(char **)(a1 + 8);
      }
      v13 = &v4[4 * v9];
      v4 = &v11[v12];
      *(void *)(a1 + 8) = v13;
    }
  }
  *(_DWORD *)v4 = *a2;
  *(void *)(a1 + 16) = v4 + 4;
}

void sub_1CCC78D48()
{
}

void sub_1CCC78DF0(uint64_t a1)
{
  v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 48) = v2;
    operator delete(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

char **llvm::object::MetalValue::asInt@<X0>(char **this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  unsigned int v12 = a2;
  if (a2 >= 0x41)
  {
    v8 = std::generic_category();
    sub_1CD5E50F0(22, (uint64_t)v8, (uint64_t)"expecting maximum '64' bits, given '%u'", &v12);
  }
  v4 = this;
  if (a2 > (unint64_t)(8 * (void)this[1]))
  {
    v9 = std::generic_category();
    uint64_t v11 = 8 * (void)v4[1];
    sub_1CD6D929C(22, (uint64_t)v9, (uint64_t)"expecting '%u' bits, found '%zu'", (int *)&v12, &v11);
  }
  HIDWORD(v5) = a2;
  LODWORD(v5) = a2 - 8;
  switch((v5 >> 3))
  {
    case 0u:
      uint64_t v6 = **this;
      break;
    case 1u:
      uint64_t v6 = *(unsigned __int16 *)*this;
      break;
    case 3u:
      uint64_t v6 = *(unsigned int *)*this;
      break;
    case 7u:
      uint64_t v6 = *(void *)*this;
      break;
    default:
      v10 = std::generic_category();
      sub_1CD5E50F0(22, (uint64_t)v10, (uint64_t)"bit size '%u' is not supported", &v12);
  }
  unint64_t v7 = 0xFFFFFFFFFFFFFFFFLL >> -(char)a2;
  if (!a2) {
    unint64_t v7 = 0;
  }
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(_DWORD *)(a3 + 8) = a2;
  *(void *)a3 = v7 & v6;
  return this;
}

uint64_t llvm::object::MetalPipelineDescriptions::MetalPipelineDescriptions(uint64_t result, long long *a2, void *a3)
{
  uint64_t v3 = result;
  long long v5 = a2[1];
  long long v9 = *a2;
  long long v4 = v9;
  long long v10 = v5;
  *(_DWORD *)(result + 8) = 22;
  *(_OWORD *)(result + 16) = v4;
  *(_OWORD *)(result + 32) = v5;
  *(void *)result = &unk_1F2633A60;
  if (*(void *)(result + 24) <= 3uLL)
  {
    uint64_t v6 = std::generic_category();
    uint64_t v8 = 4;
    uint64_t v7 = *(void *)(v3 + 24);
    sub_1CD4F6FE0(5, (uint64_t)v6, (uint64_t)"expecting '%zu' bytes, found '%zu'", &v8, &v7);
  }
  if (!*a3) {
    *a3 = 0;
  }
  return result;
}

void sub_1CCC790B0()
{
}

int *llvm::object::MinidumpFile::getRawStream@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 72);
  uint64_t v6 = *(unsigned int *)(a1 + 88);
  result = sub_1CBF3C94C(v5, v6, a2);
  if ((int *)(v5 + 16 * v6) == result)
  {
    char v9 = 0;
    *(unsigned char *)a3 = 0;
  }
  else
  {
    uint64_t v8 = *(unsigned int *)(*(void *)(a1 + 56) + 12 * *((void *)result + 1) + 4);
    *(void *)a3 = *(void *)(a1 + 16) + *(unsigned int *)(*(void *)(a1 + 56) + 12 * *((void *)result + 1) + 8);
    *(void *)(a3 + 8) = v8;
    char v9 = 1;
  }
  *(unsigned char *)(a3 + 16) = v9;
  return result;
}

void llvm::object::MinidumpFile::getString(llvm::object::MinidumpFile *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  sub_1CCC793E4((uint64_t)&v22, *((void *)this + 2), *((void *)this + 3), a2);
  uint64_t v6 = v22;
  if (v23)
  {
    *(unsigned char *)(a3 + 24) |= 1u;
    *(void *)a3 = v6;
  }
  else
  {
    unint64_t v7 = *v22;
    if (v7) {
      operator new();
    }
    if (v7 > 1)
    {
      unint64_t v8 = a2 + 4;
      unint64_t v9 = v7 & 0xFFFFFFFE;
      unint64_t v10 = v9 + v8;
      if (__CFADD__(v9, v8) || (v10 >= v9 ? (BOOL v11 = v10 > *((void *)this + 3)) : (BOOL v11 = 1), v11)) {
        operator new();
      }
      unint64_t v12 = v7 >> 1;
      v13 = (__int16 *)(*((void *)this + 2) + v8);
      v18 = v21;
      uint64_t v20 = 32;
      if (v7 > 0x41)
      {
        unint64_t v19 = 0;
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      bzero(v21, v7 & 0xFFFFFFFE);
      unint64_t v19 = v12;
      uint64_t v14 = 2 * v12;
      v15 = v21;
      do
      {
        __int16 v16 = *v13++;
        *(_WORD *)v15 = v16;
        v15 += 2;
        v14 -= 2;
      }
      while (v14);
      memset(&__p, 0, sizeof(__p));
      if (!llvm::convertUTF16ToUTF8String(v21, v9, &__p)) {
        operator new();
      }
      *(unsigned char *)(a3 + 24) &= ~1u;
      *(std::string *)a3 = __p;
      if (v18 != v21) {
        free(v18);
      }
    }
    else
    {
      *(unsigned char *)(a3 + 24) &= ~1u;
      *(unsigned char *)(a3 + 23) = 0;
      *(unsigned char *)a3 = 0;
    }
  }
}

uint64_t sub_1CCC793E4(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  if (a4 > 0xFFFFFFFFFFFFFFFBLL || a4 + 4 > a3) {
    operator new();
  }
  uint64_t result = a2 + a4;
  *(unsigned char *)(a1 + 16) &= ~1u;
  *(void *)(a1 + 8) = 1;
  *(void *)a1 = a2 + a4;
  return result;
}

int *llvm::object::MinidumpFile::getMemoryInfoList@<X0>(llvm::object::MinidumpFile *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *((void *)this + 9);
  uint64_t v5 = *((unsigned int *)this + 22);
  uint64_t result = sub_1CBF3C94C(v4, v5, 16);
  if ((int *)(v4 + 16 * v5) == result) {
    operator new();
  }
  uint64_t v7 = *((void *)this + 7) + 12 * *((void *)result + 1);
  unint64_t v8 = *(unsigned int *)(v7 + 4);
  if (v8 < 0x10
    || ((unint64_t v9 = (unsigned int *)(*((void *)this + 2) + *(unsigned int *)(v7 + 8)),
         uint64_t v11 = *v9,
         uint64_t v10 = v9[1],
         unint64_t v12 = *((void *)v9 + 1) * v10,
         unint64_t v13 = v12 + v11,
         !__CFADD__(v12, v11))
      ? (char v14 = 0)
      : (char v14 = 1),
        v13 > v8 || (v14 & 1) != 0 || v13 < v12))
  {
    operator new();
  }
  *(unsigned char *)(a2 + 48) &= ~1u;
  *(void *)a2 = (char *)v9 + v11;
  *(void *)(a2 + 8) = v12;
  *(void *)(a2 + 16) = v10;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = v10;
  return result;
}

uint64_t llvm::object::MinidumpFile::getDataSlice@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v6 = a4 + a3;
  if (__CFADD__(a4, a3) || v6 < a4 || v6 > a2) {
    operator new();
  }
  uint64_t result = a1 + a3;
  *(unsigned char *)(a5 + 16) &= ~1u;
  *(void *)(a5 + 8) = a4;
  *(void *)a5 = result;
  return result;
}

unsigned int *llvm::object::MinidumpFile::getListStream<llvm::minidump::Module>@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 72);
  uint64_t v6 = *(unsigned int *)(a1 + 88);
  uint64_t v7 = sub_1CBF3C94C(v5, v6, a2);
  if ((int *)(v5 + 16 * v6) == v7) {
    operator new();
  }
  uint64_t v8 = *(void *)(a1 + 56) + 12 * *((void *)v7 + 1);
  unint64_t v9 = *(unsigned int *)(v8 + 4);
  uint64_t v10 = *(void *)(a1 + 16) + *(unsigned int *)(v8 + 8);
  sub_1CCC793E4((uint64_t)&v14, v10, v9, 0);
  uint64_t result = v14;
  if (v15)
  {
    *(unsigned char *)(a3 + 16) |= 1u;
  }
  else
  {
    uint64_t v12 = *v14;
    uint64_t v13 = 4;
    if (108 * (unint64_t)v12 + 4 < v9) {
      uint64_t v13 = 8;
    }
    if (v13 + 108 * (unint64_t)v12 > v9) {
      operator new();
    }
    uint64_t result = (unsigned int *)(v10 + v13);
    *(unsigned char *)(a3 + 16) &= ~1u;
    *(void *)(a3 + 8) = v12;
  }
  *(void *)a3 = result;
  return result;
}

unsigned int *llvm::object::MinidumpFile::getListStream<llvm::minidump::Thread>@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 72);
  uint64_t v6 = *(unsigned int *)(a1 + 88);
  uint64_t v7 = sub_1CBF3C94C(v5, v6, a2);
  if ((int *)(v5 + 16 * v6) == v7) {
    operator new();
  }
  uint64_t v8 = *(void *)(a1 + 56) + 12 * *((void *)v7 + 1);
  unint64_t v9 = *(unsigned int *)(v8 + 4);
  uint64_t v10 = *(void *)(a1 + 16) + *(unsigned int *)(v8 + 8);
  sub_1CCC793E4((uint64_t)&v14, v10, v9, 0);
  uint64_t result = v14;
  if (v15)
  {
    *(unsigned char *)(a3 + 16) |= 1u;
  }
  else
  {
    uint64_t v12 = *v14;
    uint64_t v13 = 4;
    if (((48 * v12) | 4uLL) < v9) {
      uint64_t v13 = 8;
    }
    if ((v13 & 0xFFFFFFC00000000FLL | (16 * ((3 * v12) & 0x3FFFFFFFFLL))) > v9) {
      operator new();
    }
    uint64_t result = (unsigned int *)(v10 + v13);
    *(unsigned char *)(a3 + 16) &= ~1u;
    *(void *)(a3 + 8) = v12;
  }
  *(void *)a3 = result;
  return result;
}

unsigned int *llvm::object::MinidumpFile::getListStream<llvm::minidump::MemoryDescriptor>@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 72);
  uint64_t v6 = *(unsigned int *)(a1 + 88);
  uint64_t v7 = sub_1CBF3C94C(v5, v6, a2);
  if ((int *)(v5 + 16 * v6) == v7) {
    operator new();
  }
  uint64_t v8 = *(void *)(a1 + 56) + 12 * *((void *)v7 + 1);
  unint64_t v9 = *(unsigned int *)(v8 + 4);
  uint64_t v10 = *(void *)(a1 + 16) + *(unsigned int *)(v8 + 8);
  sub_1CCC793E4((uint64_t)&v14, v10, v9, 0);
  uint64_t result = v14;
  if (v15)
  {
    *(unsigned char *)(a3 + 16) |= 1u;
  }
  else
  {
    uint64_t v12 = *v14;
    uint64_t v13 = 4;
    if (((16 * v12) | 4uLL) < v9) {
      uint64_t v13 = 8;
    }
    if ((v13 & 0xFFFFFFF00000000FLL | (16 * *v14)) > v9) {
      operator new();
    }
    uint64_t result = (unsigned int *)(v10 + v13);
    *(unsigned char *)(a3 + 16) &= ~1u;
    *(void *)(a3 + 8) = v12;
  }
  *(void *)a3 = result;
  return result;
}

void sub_1CCC79B04()
{
}

void llvm::ModuleSymbolTable::addModule(llvm::ModuleSymbolTable *this, llvm::Module *a2)
{
  if (!*(void *)this) {
    *(void *)this = a2;
  }
  uint64_t v3 = (char *)a2 + 24;
  uint64_t v4 = (void (*)(uint64_t *, void *, size_t, int))*((void *)a2 + 4);
  uint64_t v5 = (char *)a2 + 8;
  uint64_t v6 = (llvm::ModuleSymbolTable **)*((void *)a2 + 2);
  uint64_t v7 = (char *)a2 + 40;
  uint64_t v8 = (char *)*((void *)a2 + 6);
  unint64_t v9 = (char *)a2 + 56;
  uint64_t v10 = (char *)*((void *)a2 + 8);
  v26 = v4;
  v27 = v6;
  v28 = v8;
  v29 = v10;
  v30 = (char *)a2 + 24;
  v31 = (char *)a2 + 8;
  v32 = (char *)a2 + 40;
  v33 = (char *)a2 + 56;
  while ((char *)v4 != v3
       || v6 != (llvm::ModuleSymbolTable **)v5
       || v8 != v7
       || v10 != v9
       || v30 != v3
       || v31 != v5
       || v32 != v7
       || v33 != v9)
  {
    uint64_t v11 = sub_1CC4AD368((uint64_t)&v26);
    uint64_t v12 = v11;
    char v14 = (uint64_t *)*((void *)this + 14);
    unint64_t v13 = *((void *)this + 15);
    if ((unint64_t)v14 >= v13)
    {
      uint64_t v16 = (void *)*((void *)this + 13);
      uint64_t v17 = v14 - v16;
      unint64_t v18 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        abort();
      }
      uint64_t v19 = v13 - (void)v16;
      if (v19 >> 2 > v18) {
        unint64_t v18 = v19 >> 2;
      }
      if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v20 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v20 = v18;
      }
      if (v20)
      {
        if (v20 >> 61) {
          sub_1CB833614();
        }
        v21 = (char *)operator new(8 * v20);
      }
      else
      {
        v21 = 0;
      }
      v22 = (uint64_t *)&v21[8 * v17];
      uint64_t *v22 = v12;
      char v15 = v22 + 1;
      if (v14 != v16)
      {
        do
        {
          uint64_t v23 = *--v14;
          *--v22 = v23;
        }
        while (v14 != v16);
        char v14 = (uint64_t *)*((void *)this + 13);
      }
      *((void *)this + 13) = v22;
      *((void *)this + 14) = v15;
      *((void *)this + 15) = &v21[8 * v20];
      if (v14) {
        operator delete(v14);
      }
    }
    else
    {
      *char v14 = v11;
      char v15 = v14 + 1;
    }
    *((void *)this + 14) = v15;
    sub_1CC4AD1DC((uint64_t)&v26);
    uint64_t v4 = v26;
    uint64_t v6 = v27;
    uint64_t v8 = v28;
    uint64_t v10 = v29;
  }
  v25 = this;
  v26 = sub_1CCC7A780;
  v27 = &v25;
  v34 = &v26;
  sub_1CCC79D58((uint64_t)a2);
}

void sub_1CCC79D58(uint64_t a1)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  char v1 = *(unsigned char *)(a1 + 111);
  if (v1 >= 0) {
    uint64_t v2 = a1 + 88;
  }
  else {
    uint64_t v2 = *(void *)(a1 + 88);
  }
  if (v1 >= 0) {
    uint64_t v3 = v1 & 0x7F;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 96);
  }
  if (v3)
  {
    v44[0] = 0;
    v44[1] = 0;
    uint64_t v45 = 0;
    __int16 v55 = 260;
    v54[0] = (void **)(a1 + 216);
    llvm::Triple::Triple((llvm::Triple *)__p, (const llvm::Twine *)v54);
    uint64_t v5 = llvm::TargetRegistry::lookupTarget((std::string::size_type)__p, (uint64_t)v44);
    uint64_t v6 = (uint64_t)v5;
    if (v43 >= 0) {
      uint64_t v7 = __p;
    }
    else {
      uint64_t v7 = (void **)__p[0];
    }
    if (v43 >= 0) {
      uint64_t v8 = v43 & 0x7F;
    }
    else {
      uint64_t v8 = (uint64_t)__p[1];
    }
    uint64_t v9 = sub_1CD52142C((uint64_t)v5, (uint64_t)v7, v8);
    if (v9)
    {
      uint64_t v10 = v9;
      v32[0] = 4096;
      uint64_t v33 = 2;
      *(_OWORD *)v34 = 0u;
      *(_OWORD *)v35 = 0u;
      long long v36 = 0u;
      *(_OWORD *)v37 = 0u;
      *(_OWORD *)v38 = 0u;
      long long v39 = 0u;
      long long v40 = 0u;
      v41[0] = 0u;
      if (v43 >= 0) {
        uint64_t v11 = __p;
      }
      else {
        uint64_t v11 = (void **)__p[0];
      }
      if (v43 >= 0) {
        uint64_t v12 = v43 & 0x7F;
      }
      else {
        uint64_t v12 = (uint64_t)__p[1];
      }
      v41[1] = 0uLL;
      uint64_t v13 = sub_1CD5214A0(v6, v9, (uint64_t)v11, v12, (uint64_t)v32);
      if (v13)
      {
        char v14 = (llvm::MCStreamer *)v13;
        if (v43 >= 0) {
          char v15 = __p;
        }
        else {
          char v15 = (void **)__p[0];
        }
        if (v43 >= 0) {
          uint64_t v16 = v43 & 0x7F;
        }
        else {
          uint64_t v16 = (uint64_t)__p[1];
        }
        uint64_t v17 = sub_1CD452D6C(v6, (uint64_t)v15, v16, (uint64_t)"", 0, (uint64_t)"", 0);
        if (v17)
        {
          uint64_t v18 = v17;
          uint64_t v19 = *(uint64_t (**)(void))(v6 + 64);
          if (v19 && v19())
          {
            __int16 v55 = 261;
            v54[0] = (void **)"";
            v54[1] = 0;
            __str.__r_.__value_.__r.__words[0] = (std::string::size_type)v54;
            unint64_t v20 = sub_1CD096174((llvm::raw_ostream *)0x18, (uint64_t)&__str);
            *unint64_t v20 = &unk_1F2644E70;
            v20[1] = v2;
            v20[2] = v2 + v3;
            uint64_t v31 = 0;
            memset(v30, 0, sizeof(v30));
            v29 = v20;
            sub_1CD452CE0((uint64_t)v30, (uint64_t *)&v29, 0);
            uint64_t v21 = (uint64_t)v29;
            v29 = 0;
            if (v21) {
              (*(void (**)(uint64_t))(*(void *)v21 + 8))(v21);
            }
            llvm::MCContext::MCContext((uint64_t)v54, (long long *)__p, (uint64_t)v14, v10, v18, (uint64_t)v30, 0, 1, 0, 0);
            v22 = (std::string *)sub_1CD454E24(v6, (uint64_t)v54, 0, 0);
            v22[35].__r_.__value_.__l.__size_ = llvm::Module::getSDKVersion((llvm::Module *)a1);
            v22[35].__r_.__value_.__r.__words[2] = v23;
            v56 = v22;
            llvm::Module::getDarwinTargetVariantTriple((llvm::Module *)a1);
            if (v24)
            {
              __int16 v28 = 261;
              v27[0] = llvm::Module::getDarwinTargetVariantTriple((llvm::Module *)a1);
              v27[1] = v25;
              llvm::Triple::Triple((llvm::Triple *)&__str, (const llvm::Twine *)v27);
              sub_1CD6EC460(v22 + 36, &__str);
              if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__str.__r_.__value_.__l.__data_);
              }
            }
            llvm::MCStreamer::MCStreamer((llvm::MCStreamer *)&__str, (llvm::MCContext *)v54);
            __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1F2633C70;
            uint64_t v47 = a1;
            uint64_t v49 = 0;
            uint64_t v48 = 0;
            uint64_t v52 = 0;
            uint64_t v50 = 0x1000000000;
            uint64_t v51 = 0;
            int v53 = 0;
            v26 = *(void (**)(std::string *))(v6 + 200);
            if (v26) {
              v26(&__str);
            }
            llvm::createMCAsmParser((llvm *)v30, (llvm::SourceMgr *)v54, (llvm::MCContext *)&__str, v14, 0);
          }
          (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
        }
        (*(void (**)(llvm::MCStreamer *))(*(void *)v14 + 8))(v14);
      }
      v54[0] = (void **)v41 + 1;
      sub_1CB8338B8(v54);
      if (SHIBYTE(v39) < 0) {
        operator delete(v38[1]);
      }
      if (SHIBYTE(v38[0]) < 0) {
        operator delete(v37[0]);
      }
      if (SHIBYTE(v36) < 0) {
        operator delete(v35[1]);
      }
      if (SHIBYTE(v35[0]) < 0) {
        operator delete(v34[0]);
      }
      sub_1CD521E44(v10);
    }
    if (v43 < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v45) < 0) {
      operator delete(v44[0]);
    }
  }
}

void llvm::ModuleSymbolTable::printSymbolName(uint64_t a1, llvm::raw_ostream *a2, uint64_t a3)
{
  char v3 = a3;
  unint64_t v4 = a3 & 0xFFFFFFFFFFFFFFF8;
  if ((v3 & 4) != 0)
  {
    char v6 = *(unsigned char *)(v4 + 23);
    BOOL v7 = v6 < 0;
    uint64_t v8 = *(const char **)v4;
    if (v6 >= 0) {
      uint64_t v8 = (const char *)v4;
    }
    size_t v9 = v6 & 0x7F;
    if (v7) {
      size_t v10 = *(void *)(v4 + 8);
    }
    else {
      size_t v10 = v9;
    }
    llvm::raw_ostream::write(a2, v8, v10);
  }
  else
  {
    if ((*(_DWORD *)(v4 + 32) & 0x300) == 0x100)
    {
      uint64_t v13 = a1;
      unint64_t v11 = v4;
      uint64_t v12 = a2;
      sub_1CB8E509C(a2, "__imp_");
      a1 = v13;
      unint64_t v4 = v11;
      a2 = v12;
    }
    uint64_t v5 = (llvm::Mangler *)(a1 + 128);
    llvm::Mangler::getNameWithPrefix(v5, (char **)a2, (const llvm::GlobalValue *)v4, 0);
  }
}

uint64_t llvm::ModuleSymbolTable::getSymbolFlags(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (uint64_t ***)(a2 & 0xFFFFFFFFFFFFFFF8);
  if ((a2 & 4) != 0) {
    return *((unsigned int *)v2 + 6);
  }
  int v3 = *((_DWORD *)v2 + 8);
  int v4 = *((unsigned __int8 *)v2 + 16);
  if ((v3 & 0xF) == 1)
  {
    unsigned int v5 = 1;
  }
  else
  {
    if (*((unsigned char *)v2 + 16))
    {
      if (v4 == 3 && (*((_DWORD *)v2 + 5) & 0x7FFFFFF) == 0)
      {
        unsigned int v5 = 1;
        int v4 = 3;
        goto LABEL_15;
      }
    }
    else if ((v3 & 0x800000) == 0 && v2[9] == (uint64_t **)(v2 + 9))
    {
      BOOL v7 = v2 == 0;
      unsigned int v5 = 1;
      goto LABEL_18;
    }
    if ((v3 & 0x30) == 0x10) {
      unsigned int v5 = ((v3 & 0xFu) - 7 > 1) << 9;
    }
    else {
      unsigned int v5 = 0;
    }
  }
LABEL_15:
  BOOL v7 = v2 == 0;
  if (v2 && v4 == 3)
  {
    BOOL v7 = 0;
    unsigned int v5 = v5 & 0xFFFFFBFF | (((_BYTE)v2[10] & 1) << 10);
  }
LABEL_18:
  v43[0] = 0;
  v43[1] = 0;
  int v44 = 0;
  uint64_t v8 = sub_1CC5BE54C((uint64_t)v2, (uint64_t)v43);
  MEMORY[0x1D25D9CD0](v43[0], 8);
  if (v8 && (*(unsigned __int8 *)(v8 + 16) | 2) == 2) {
    v5 |= 0x800u;
  }
  if (*((unsigned char *)v2 + 16) == 1) {
    unsigned int v9 = v5 | 0x20;
  }
  else {
    unsigned int v9 = v5;
  }
  int v10 = *((_DWORD *)v2 + 8);
  int v11 = v10 & 0xF;
  if (v11 == 8) {
    v9 |= 0x80u;
  }
  if ((v11 - 7) >= 2) {
    v9 |= 2u;
  }
  if (v11 == 10) {
    uint64_t v6 = v9 | 0x10;
  }
  else {
    uint64_t v6 = v9;
  }
  if ((v10 & 0xE) == 2
    || (v10 & 0xE) == 4
    || llvm::GlobalValue::hasExternalWeakLinkage((llvm::GlobalValue *)v2))
  {
    uint64_t v6 = v6 | 4;
  }
  unsigned int v12 = v2 >> 4;
  if ((*((unsigned char *)v2 + 23) & 0x10) == 0) {
    goto LABEL_48;
  }
  uint64_t v13 = ***v2;
  uint64_t v14 = *(void *)(v13 + 152);
  uint64_t v15 = *(unsigned int *)(v13 + 168);
  if (!v15) {
    goto LABEL_42;
  }
  LODWORD(v16) = (v15 - 1) & (v12 ^ (v2 >> 9));
  uint64_t v17 = (uint64_t ****)(v14 + 16 * v16);
  uint64_t v18 = *v17;
  if (*v17 != v2)
  {
    int v19 = 1;
    while (v18 != (uint64_t ***)-4096)
    {
      int v20 = v16 + v19++;
      uint64_t v16 = v20 & (v15 - 1);
      uint64_t v18 = *(uint64_t ****)(v14 + 16 * v16);
      if (v18 == v2)
      {
        uint64_t v17 = (uint64_t ****)(v14 + 16 * v16);
        goto LABEL_43;
      }
    }
LABEL_42:
    uint64_t v17 = (uint64_t ****)(v14 + 16 * v15);
  }
LABEL_43:
  uint64_t v21 = v17[1];
  if ((unint64_t)*v21 >= 5)
  {
    int v22 = *((_DWORD *)v21 + 4);
    int v23 = *((unsigned __int8 *)v21 + 20);
    if (v22 == 1836477548 && v23 == 46) {
      return v6 | 0x80;
    }
  }
LABEL_48:
  char v25 = *((unsigned char *)v2 + 16) != 3 || v7;
  if ((v25 & 1) != 0 || (*((unsigned char *)v2 + 34) & 0x40) == 0) {
    return v6;
  }
  uint64_t v26 = ***v2;
  v43[0] = (uint64_t)v2;
  int v27 = *(_DWORD *)(v26 + 2520);
  if (v27)
  {
    uint64_t v28 = *(void *)(v26 + 2504);
    unsigned int v29 = (v27 - 1) & (v12 ^ (v2 >> 9));
    v30 = (uint64_t ****)(v28 + 24 * v29);
    uint64_t v31 = *v30;
    if (*v30 == v2) {
      goto LABEL_55;
    }
    v37 = 0;
    int v38 = 1;
    while (v31 != (uint64_t ***)-4096)
    {
      if (v37) {
        BOOL v39 = 0;
      }
      else {
        BOOL v39 = v31 == (uint64_t ***)-8192;
      }
      if (v39) {
        v37 = v30;
      }
      unsigned int v40 = v29 + v38++;
      unsigned int v29 = v40 & (v27 - 1);
      v30 = (uint64_t ****)(v28 + 24 * v29);
      uint64_t v31 = *v30;
      if (*v30 == v2) {
        goto LABEL_55;
      }
    }
    if (v37) {
      v41 = v37;
    }
    else {
      v41 = v30;
    }
  }
  else
  {
    v41 = 0;
  }
  v30 = (uint64_t ****)sub_1CC5BF31C(v26 + 2504, (uint64_t)v43, v43, v41);
  uint64_t v42 = v43[0];
  v30[1] = 0;
  v30[2] = 0;
  char *v30 = (uint64_t ***)v42;
LABEL_55:
  if (v30[2] == (uint64_t ***)13)
  {
    v32 = (unint64_t *)v30[1];
    unint64_t v33 = 0x6C6C766D2E6D6574;
    unint64_t v34 = bswap64(*v32);
    if (v34 == 0x6C6C766D2E6D6574
      && (unint64_t v33 = 0x6D65746164617461, v34 = bswap64(*(unint64_t *)((char *)v32 + 5)), v34 == 0x6D65746164617461))
    {
      int v35 = 0;
    }
    else if (v34 < v33)
    {
      int v35 = -1;
    }
    else
    {
      int v35 = 1;
    }
    if (v35) {
      return v6;
    }
    else {
      return v6 | 0x80;
    }
  }
  return v6;
}

void sub_1CCC7A780(uint64_t *a1, void *__src, size_t __len, int a4)
{
  uint64_t v7 = *a1;
  *(void *)(v7 + 88) = *(void *)(*a1 + 88) + 32;
  uint64_t v8 = *(void *)(v7 + 8);
  if (((v8 + 7) & 0xFFFFFFFFFFFFFFF8) - v8 + 32 > *(void *)(v7 + 16) - v8)
  {
    unsigned int v26 = *(_DWORD *)(v7 + 32) >> 7;
    if (v26 >= 0x1E) {
      LOBYTE(v26) = 30;
    }
    uint64_t v27 = 4096 << v26;
    unint64_t v9 = (unint64_t)operator new(4096 << v26, (std::align_val_t)8uLL);
    unsigned int v28 = *(_DWORD *)(v7 + 32);
    if (v28 >= *(_DWORD *)(v7 + 36)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(v7 + 24) + 8 * v28) = v9;
    ++*(_DWORD *)(v7 + 32);
    *(void *)(v7 + 16) = v9 + v27;
  }
  else
  {
    unint64_t v9 = (v8 + 7) & 0xFFFFFFFFFFFFFFF8;
  }
  *(void *)(v7 + 8) = v9 + 32;
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    goto LABEL_37;
  }
  if (__len >= 0x17)
  {
    size_t v11 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v11 = __len | 7;
    }
    size_t v12 = v11 + 1;
    p_dst = (long long *)operator new(v11 + 1);
    *((void *)&__dst + 1) = __len;
    unint64_t v30 = v12 | 0x8000000000000000;
    *(void *)&long long __dst = p_dst;
    goto LABEL_10;
  }
  HIBYTE(v30) = __len;
  p_dst = &__dst;
  if (__len) {
LABEL_10:
  }
    memmove(p_dst, __src, __len);
  *((unsigned char *)p_dst + __len) = 0;
  *(void *)(v9 + 16) = v30;
  *(_OWORD *)unint64_t v9 = __dst;
  unint64_t v30 = 0;
  long long __dst = 0uLL;
  *(_DWORD *)(v9 + 24) = a4;
  uint64_t v13 = v9 | 4;
  uint64_t v15 = *(uint64_t **)(v7 + 112);
  unint64_t v14 = *(void *)(v7 + 120);
  if ((unint64_t)v15 < v14)
  {
    uint64_t *v15 = v13;
    uint64_t v16 = v15 + 1;
    goto LABEL_28;
  }
  uint64_t v17 = *(void **)(v7 + 104);
  uint64_t v18 = v15 - v17;
  unint64_t v19 = v18 + 1;
  if ((unint64_t)(v18 + 1) >> 61) {
LABEL_37:
  }
    abort();
  uint64_t v20 = v14 - (void)v17;
  if (v20 >> 2 > v19) {
    unint64_t v19 = v20 >> 2;
  }
  if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v21 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v21 = v19;
  }
  if (v21)
  {
    if (v21 >> 61) {
      sub_1CB833614();
    }
    int v22 = (char *)operator new(8 * v21);
  }
  else
  {
    int v22 = 0;
  }
  int v23 = (uint64_t *)&v22[8 * v18];
  *int v23 = v13;
  uint64_t v16 = v23 + 1;
  if (v15 != v17)
  {
    do
    {
      uint64_t v24 = *--v15;
      *--int v23 = v24;
    }
    while (v15 != v17);
    uint64_t v15 = *(uint64_t **)(v7 + 104);
  }
  *(void *)(v7 + 104) = v23;
  *(void *)(v7 + 112) = v16;
  *(void *)(v7 + 120) = &v22[8 * v21];
  if (v15) {
    operator delete(v15);
  }
LABEL_28:
  *(void *)(v7 + 112) = v16;
  if (SHIBYTE(v30) < 0)
  {
    char v25 = (void *)__dst;
    operator delete(v25);
  }
}

uint64_t sub_1CCC7A9F0(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::RecordStreamer::flushSymverDirectives((llvm::RecordStreamer *)a2);
  uint64_t v5 = *(void *)(a2 + 280);
  uint64_t v6 = *(unsigned int *)(a2 + 288);
  if (v6)
  {
    for (i = *(uint64_t **)(a2 + 280); !*i || *i == -8; ++i)
      ;
  }
  else
  {
    i = *(uint64_t **)(a2 + 280);
  }
  unint64_t v9 = (uint64_t *)(v5 + 8 * v6);
  if (i != v9)
  {
    uint64_t v10 = *i;
    do
    {
      int v11 = *(_DWORD *)(v10 + 8) - 1;
      if (v11 > 5) {
        uint64_t v12 = 2048;
      }
      else {
        uint64_t v12 = dword_1CFB2C220[v11];
      }
      uint64_t result = (**(uint64_t (***)(void, uint64_t, void, uint64_t))a1)(*(void *)(*(void *)a1 + 8), v10 + 16, *(void *)v10, v12);
      do
      {
        uint64_t v13 = i[1];
        ++i;
        uint64_t v10 = v13;
        if (v13) {
          BOOL v14 = v10 == -8;
        }
        else {
          BOOL v14 = 1;
        }
      }
      while (v14);
    }
    while (i != v9);
  }
  return result;
}

uint64_t sub_1CCC7AAB0(uint64_t result, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 320))
  {
    uint64_t v2 = result;
    uint64_t v3 = *(unsigned int *)(a2 + 328);
    if (v3)
    {
      uint64_t v4 = 32 * v3;
      for (i = *(void **)(a2 + 312); (*i | 0x1000) == 0xFFFFFFFFFFFFF000; i += 4)
      {
        v4 -= 32;
        if (!v4) {
          return result;
        }
      }
    }
    else
    {
      i = *(void **)(a2 + 312);
    }
    uint64_t v6 = *(void *)(a2 + 312) + 32 * v3;
LABEL_9:
    if (i != (void *)v6)
    {
      uint64_t v7 = (uint64_t *)i[1];
      uint64_t v8 = (uint64_t *)i[2];
      while (v7 != v8)
      {
        if ((*(unsigned char *)*i & 4) != 0)
        {
          int v11 = *(uint64_t **)(*i - 8);
          uint64_t v12 = *v11;
          unint64_t v9 = v11 + 2;
          uint64_t v10 = v12;
        }
        else
        {
          unint64_t v9 = 0;
          uint64_t v10 = 0;
        }
        uint64_t v13 = *v7;
        uint64_t v14 = v7[1];
        v7 += 2;
        uint64_t result = (**(uint64_t (***)(void, void *, uint64_t, uint64_t, uint64_t))v2)(*(void *)(*(void *)v2 + 8), v9, v10, v13, v14);
      }
      while (1)
      {
        i += 4;
        if (i == (void *)v6) {
          break;
        }
        if ((*i | 0x1000) != 0xFFFFFFFFFFFFF000) {
          goto LABEL_9;
        }
      }
    }
  }
  return result;
}

uint64_t LLVMCreateBinary(void *a1, uint64_t a2, char **a3)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a1[1];
  uint64_t v6 = a1[2] - v5;
  uint64_t v7 = (*(uint64_t (**)(void *))(*a1 + 16))(a1);
  v19[0] = v5;
  v19[1] = v6;
  v19[2] = v7;
  v19[3] = v8;
  llvm::object::createBinary((uint64_t)v19, a2, 1, (uint64_t)&v20);
  char v9 = v21;
  if (v21)
  {
    uint64_t v13 = v20;
    uint64_t v20 = 0;
    uint64_t v17 = v13;
    sub_1CD4FB504(&v17, &v18);
    int v14 = SHIBYTE(v18.__r_.__value_.__r.__words[2]);
    uint64_t v15 = (void *)v18.__r_.__value_.__r.__words[0];
    if ((v18.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v16 = &v18;
    }
    else {
      uint64_t v16 = (std::string *)v18.__r_.__value_.__r.__words[0];
    }
    *a3 = strdup((const char *)v16);
    if (v14 < 0) {
      operator delete(v15);
    }
    if (v17) {
      (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
    }
    uint64_t v11 = 0;
    char v9 = v21;
    uint64_t v10 = v20;
  }
  else
  {
    uint64_t v10 = 0;
    uint64_t v11 = v20;
  }
  uint64_t v20 = 0;
  if (v9)
  {
    if (v10) {
LABEL_7:
    }
      (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  else if (v10)
  {
    goto LABEL_7;
  }
  return v11;
}

void *LLVMBinaryCopyMemoryBuffer(void *a1)
{
  uint64_t v1 = a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = a1[4];
  uint64_t v4 = a1[5];
  __int16 v7 = 261;
  v6[0] = v3;
  v6[1] = v4;
  uint64_t v8 = v6;
  uint64_t result = sub_1CD096174((llvm::raw_ostream *)0x18, (uint64_t)&v8);
  void *result = &unk_1F2644E70;
  result[1] = v1;
  result[2] = v1 + v2;
  return result;
}

uint64_t LLVMDisposeBinary(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t LLVMBinaryGetType(uint64_t a1)
{
  return dword_1CFB2C238[*(int *)(a1 + 8)];
}

std::string::size_type LLVMMachOUniversalBinaryCopyObjectForArch(uint64_t a1, const void *a2, size_t a3, char **a4)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  llvm::object::MachOUniversalBinary::getMachOObjectForArch(a1, a2, a3, (uint64_t)&v10);
  std::string::size_type result = v10.__r_.__value_.__r.__words[0];
  if (v10.__r_.__value_.__s.__data_[8])
  {
    std::string::size_type v9 = v10.__r_.__value_.__r.__words[0];
    sub_1CD4FB504((uint64_t *)&v9, &v10);
    int v6 = SHIBYTE(v10.__r_.__value_.__r.__words[2]);
    __int16 v7 = (void *)v10.__r_.__value_.__r.__words[0];
    if ((v10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v8 = &v10;
    }
    else {
      uint64_t v8 = (std::string *)v10.__r_.__value_.__r.__words[0];
    }
    *a4 = strdup((const char *)v8);
    if (v6 < 0) {
      operator delete(v7);
    }
    if (v9) {
      (*(void (**)(std::string::size_type))(*(void *)v9 + 8))(v9);
    }
    return 0;
  }
  return result;
}

uint64_t LLVMObjectFileCopySectionIterator(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 344))(a1);
  uint64_t v4 = v3;
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 352))(a1);
  if (v4 != v6 || v2 != v5) {
    operator new();
  }
  return 0;
}

BOOL LLVMObjectFileIsSectionIteratorAtEnd(uint64_t a1, void *a2)
{
  uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 352))(a1);
  return a2[1] == v4 && *a2 == v3;
}

uint64_t LLVMObjectFileCopySymbolIterator(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 48))(a1);
  if (v2 != (*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1)) {
    operator new();
  }
  return 0;
}

BOOL LLVMObjectFileIsSymbolIteratorAtEnd(uint64_t a1, void *a2)
{
  return *a2 == (*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1);
}

uint64_t LLVMCreateObjectFile(void *a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a1[1];
  uint64_t v3 = a1[2] - v2;
  uint64_t v4 = (*(uint64_t (**)(void *))(*a1 + 16))(a1);
  v10[0] = v2;
  v10[1] = v3;
  v10[2] = v4;
  v10[3] = v5;
  llvm::object::ObjectFile::createObjectFile((llvm::object *)v10, 0, 1, (uint64_t)&v11);
  if ((v12 & 1) == 0) {
    operator new();
  }
  __int16 v7 = v11;
  uint64_t v11 = 0;
  std::string::size_type v9 = v7;
  sub_1CD4515D0(&v9);
  if (v9) {
    (*(void (**)(void *))(*v9 + 8))(v9);
  }
  uint64_t v8 = v11;
  uint64_t v11 = 0;
  if (v12)
  {
    if (!v8) {
      goto LABEL_8;
    }
  }
  else if (!v8)
  {
    goto LABEL_8;
  }
  (*(void (**)(void *))(*v8 + 8))(v8);
LABEL_8:
  if (a1) {
    (*(void (**)(void *))(*a1 + 8))(a1);
  }
  return 0;
}

uint64_t *LLVMDisposeObjectFile(uint64_t *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = result[1];
    v1[1] = 0;
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    uint64_t v3 = *v1;
    *uint64_t v1 = 0;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
    JUMPOUT(0x1D25D9CE0);
  }
  return result;
}

void LLVMGetSections(void *a1)
{
}

uint64_t LLVMDisposeSectionIterator(uint64_t result)
{
  if (result) {
    JUMPOUT(0x1D25D9CE0);
  }
  return result;
}

BOOL LLVMIsSectionIteratorAtEnd(void *a1, void *a2)
{
  uint64_t v3 = (*(uint64_t (**)(void))(*(void *)*a1 + 352))(*a1);
  return a2[1] == v4 && *a2 == v3;
}

uint64_t LLVMMoveToNextSection(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 8) + 128))(*(void *)(a1 + 8), a1);
}

double LLVMMoveToContainingSection(_OWORD *a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  (*(void (**)(long long *__return_ptr))(**(void **)(a2 + 8) + 120))(&v20);
  if (v21)
  {
    memset(v19, 0, sizeof(v19));
    int v11 = 0;
    char v15 = 0;
    uint64_t v16 = 0;
    std::string v18 = v19;
    int v17 = 0;
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    uint64_t v4 = v20;
    *(void *)&long long v20 = 0;
    uint64_t v9 = v4;
    std::string v10 = &unk_1F2646F30;
    __int16 v8 = 257;
    llvm::logAllUnhandledErrors((llvm::raw_ostream *)&v9, (llvm::raw_ostream *)&v10, (uint64_t)v7);
    sub_1CC950BC0(&v9);
    __int16 v6 = 260;
    uint64_t v5 = v18;
    llvm::report_fatal_error((llvm *)&v5, (const llvm::Twine *)1);
  }
  double result = *(double *)&v20;
  *a1 = v20;
  return result;
}

void LLVMGetSymbols(void *a1)
{
}

uint64_t LLVMDisposeSymbolIterator(uint64_t result)
{
  if (result) {
    JUMPOUT(0x1D25D9CE0);
  }
  return result;
}

BOOL LLVMIsSymbolIteratorAtEnd(void *a1, void *a2)
{
  return *a2 == (*(uint64_t (**)(void))(*(void *)*a1 + 56))(*a1);
}

uint64_t LLVMMoveToNextSymbol(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8), a1);
}

uint64_t LLVMGetSectionName(uint64_t a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr, void, void))(**(void **)(a1 + 8) + 136))(&v3, *(void *)(a1 + 8), *(void *)a1);
  if (v4)
  {
    uint64_t v2 = v3;
    uint64_t v3 = 0;
    llvm::report_fatal_error(&v2);
  }
  return v3;
}

uint64_t LLVMGetSectionSize(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 160))(*(void *)(a1 + 8), *(void *)a1);
}

uint64_t LLVMGetSectionContents(uint64_t a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr, void, void))(**(void **)(a1 + 8) + 168))(&v3, *(void *)(a1 + 8), *(void *)a1);
  uint64_t result = v3;
  if (v4)
  {
    uint64_t v2 = v3;
    llvm::report_fatal_error(&v2);
  }
  return result;
}

uint64_t LLVMGetSectionAddress(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 144))(*(void *)(a1 + 8), *(void *)a1);
}

BOOL LLVMGetSectionContainsSymbol(void *a1, uint64_t *a2)
{
  return llvm::object::SectionRef::containsSymbol(a1, *a2, a2[1]);
}

void LLVMGetRelocations(uint64_t a1)
{
}

uint64_t LLVMDisposeRelocationIterator(uint64_t result)
{
  if (result) {
    JUMPOUT(0x1D25D9CE0);
  }
  return result;
}

BOOL LLVMIsRelocationIteratorAtEnd(uint64_t a1, void *a2)
{
  return *a2 == (*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 272))(*(void *)(a1 + 8), *(void *)a1);
}

uint64_t LLVMMoveToNextRelocation(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 8) + 288))(*(void *)(a1 + 8), a1);
}

uint64_t LLVMGetSymbolName(uint64_t a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr, void, void))(**(void **)(a1 + 8) + 72))(&v18, *(void *)(a1 + 8), *(void *)a1);
  if (v19)
  {
    memset(v17, 0, sizeof(v17));
    int v9 = 0;
    char v13 = 0;
    uint64_t v14 = 0;
    uint64_t v16 = v17;
    int v15 = 0;
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    uint64_t v2 = v18;
    uint64_t v18 = 0;
    uint64_t v7 = v2;
    __int16 v8 = &unk_1F2646F30;
    __int16 v6 = 257;
    llvm::logAllUnhandledErrors((llvm::raw_ostream *)&v7, (llvm::raw_ostream *)&v8, (uint64_t)v5);
    sub_1CC950BC0(&v7);
    __int16 v4 = 260;
    uint64_t v3 = v16;
    llvm::report_fatal_error((llvm *)&v3, (const llvm::Twine *)1);
  }
  return v18;
}

uint64_t LLVMGetSymbolAddress(uint64_t a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr, void, void))(**(void **)(a1 + 8) + 80))(&v18, *(void *)(a1 + 8), *(void *)a1);
  if (v19)
  {
    memset(v17, 0, sizeof(v17));
    int v9 = 0;
    char v13 = 0;
    uint64_t v14 = 0;
    uint64_t v16 = v17;
    int v15 = 0;
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    uint64_t v2 = v18;
    uint64_t v18 = 0;
    uint64_t v7 = v2;
    __int16 v8 = &unk_1F2646F30;
    __int16 v6 = 257;
    llvm::logAllUnhandledErrors((llvm::raw_ostream *)&v7, (llvm::raw_ostream *)&v8, (uint64_t)v5);
    sub_1CC950BC0(&v7);
    __int16 v4 = 260;
    uint64_t v3 = v16;
    llvm::report_fatal_error((llvm *)&v3, (const llvm::Twine *)1);
  }
  return v18;
}

uint64_t LLVMGetSymbolSize(uint64_t *a1)
{
  return sub_1CD6EC55C(a1[1], *a1);
}

uint64_t LLVMGetRelocationOffset(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 296))(*(void *)(a1 + 8), *(void *)a1);
}

void LLVMGetRelocationSymbol(uint64_t a1)
{
}

uint64_t LLVMGetRelocationType(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 312))(*(void *)(a1 + 8), *(void *)a1);
}

void *LLVMGetRelocationTypeName(uint64_t a1)
{
  size_t size = 0;
  uint64_t v6 = 0;
  __src = &v7;
  (*(void (**)(void, void, void **))(**(void **)(a1 + 8) + 320))(*(void *)(a1 + 8), *(void *)a1, &__src);
  size_t v1 = size;
  uint64_t v2 = malloc_type_malloc(size, 0x4065EBACuLL);
  if (!v2 && (v1 || (uint64_t v2 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0)) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  if (size) {
    memmove(v2, __src, size);
  }
  if (__src != &v7) {
    free(__src);
  }
  return v2;
}

char *LLVMGetRelocationValueString()
{
  return strdup("");
}

llvm::raw_ostream *llvm::object::operator<<(llvm::raw_ostream *this, void *a2)
{
  uint64_t v4 = *((void *)this + 4);
  if ((unint64_t)(*((void *)this + 3) - v4) > 0x10)
  {
    *(unsigned char *)(v4 + 16) = 123;
    *(_OWORD *)uint64_t v4 = *(_OWORD *)"SectionedAddress{";
    *((void *)this + 4) += 17;
  }
  else
  {
    llvm::raw_ostream::write(this, "SectionedAddress{", 0x11uLL);
  }
  v8[0] = *a2;
  v8[1] = 0;
  int v9 = 10;
  __int16 v10 = 1;
  char v11 = 1;
  llvm::raw_ostream::operator<<(this, (uint64_t)v8);
  if (a2[1] != -1)
  {
    uint64_t v5 = (_WORD *)*((void *)this + 4);
    if (*((void *)this + 3) - (void)v5 > 1uLL)
    {
      *uint64_t v5 = 8236;
      *((void *)this + 4) += 2;
    }
    else
    {
      llvm::raw_ostream::write(this, ", ", 2uLL);
    }
    sub_1CD098D14(this, a2[1], 0, 0, 0);
  }
  uint64_t v6 = (unsigned char *)*((void *)this + 4);
  if (*((unsigned char **)this + 3) == v6)
  {
    llvm::raw_ostream::write(this, "}", 1uLL);
  }
  else
  {
    *uint64_t v6 = 125;
    ++*((void *)this + 4);
  }
  return this;
}

__n128 llvm::object::ObjectFile::ObjectFile(uint64_t a1, int a2, long long *a3)
{
  long long v4 = *a3;
  __n128 result = (__n128)a3[1];
  *(_DWORD *)(a1 + 8) = a2;
  *(_OWORD *)(a1 + 16) = v4;
  *(__n128 *)(a1 + 32) = result;
  *(void *)a1 = &unk_1F2633AB0;
  return result;
}

BOOL llvm::object::SectionRef::containsSymbol(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  (*(void (**)(void *__return_ptr, uint64_t))(*(void *)a3 + 120))(v8, a3);
  if (v9)
  {
    uint64_t v7 = (void *)v8[0];
    v8[0] = 0;
    sub_1CD4515D0(&v7);
    if (v7) {
      (*(void (**)(void *))(*v7 + 8))(v7);
    }
  }
  else if (a1[1] == v8[1])
  {
    BOOL v4 = *a1 == v8[0];
    goto LABEL_5;
  }
  BOOL v4 = 0;
LABEL_5:
  if (v9)
  {
    uint64_t v5 = v8[0];
    v8[0] = 0;
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    }
  }
  return v4;
}

BOOL llvm::object::ObjectFile::isSectionBitcode(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  (*(void (**)(void *__return_ptr))(*(void *)a1 + 136))(v6);
  if (v7)
  {
    uint64_t v5 = (void *)v6[0];
    v6[0] = 0;
    sub_1CD4515D0(&v5);
    if (v5) {
      (*(void (**)(void *))(*v5 + 8))(v5);
    }
  }
  else if (v6[1] == 7)
  {
    BOOL v2 = *(_DWORD *)v6[0] == 1986817070 && *(_DWORD *)(v6[0] + 3) == 1667394934;
    goto LABEL_12;
  }
  BOOL v2 = 0;
LABEL_12:
  if (v7)
  {
    uint64_t v3 = v6[0];
    v6[0] = 0;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
  }
  return v2;
}

double llvm::object::ObjectFile::makeTriple@<D0>(llvm::object::ObjectFile *this@<X0>, llvm::Triple *a2@<X8>)
{
  *((_OWORD *)a2 + 1) = 0u;
  *((_OWORD *)a2 + 2) = 0u;
  *(_OWORD *)a2 = 0u;
  uint64_t v4 = (*(uint64_t (**)(llvm::object::ObjectFile *))(*(void *)this + 376))(this);
  int v5 = v4;
  ArchName = (char *)llvm::Triple::getArchName(v4, v4, 0);
  llvm::Triple::setArchName(a2, ArchName, v7);
  if ((v5 - 1) <= 1) {
    (*(void (**)(llvm::object::ObjectFile *, llvm::Triple *))(*(void *)this + 400))(this, a2);
  }
  int v9 = *((_DWORD *)this + 2);
  if ((v9 & 0xFFFFFFFC) == 0x10)
  {
    uint64_t v10 = a2;
    int v11 = 5;
LABEL_5:
    llvm::Triple::setObjectFormat(v10, v11);
    return result;
  }
  if (v9 != 9)
  {
    if ((v9 & 0xFFFFFFFE) != 0xA) {
      return result;
    }
    OSTypeName = llvm::Triple::getOSTypeName((llvm::Triple *)0x15);
    llvm::Triple::setOSName(a2, (uint64_t)OSTypeName, v13);
    uint64_t v10 = a2;
    int v11 = 9;
    goto LABEL_5;
  }
  if ((*(unsigned int (**)(llvm::object::ObjectFile *))(*(void *)this + 376))(this) == 39)
  {
    uint64_t v14 = "thumbv7-windows";
    __int16 v15 = 259;
    return llvm::Triple::setTriple(a2, (const llvm::Twine *)&v14);
  }
  return result;
}

void llvm::object::ObjectFile::createObjectFile(llvm::object *a1@<X0>, int a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    int v9 = a1;
    int v8 = a3;
    int v6 = llvm::identify_magic(*(unsigned __int8 **)a1, *((void *)a1 + 1));
    a3 = v8;
    a2 = v6;
    a1 = v9;
  }
  if ((a2 - 9) < 0xE)
  {
    long long v5 = *((_OWORD *)a1 + 1);
    v10[0] = *(_OWORD *)a1;
    v10[1] = v5;
    llvm::object::ObjectFile::createMachOObjectFile((uint64_t)v10);
  }
  switch(a2)
  {
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      long long v7 = *((_OWORD *)a1 + 1);
      v11[0] = *(_OWORD *)a1;
      v11[1] = v7;
      llvm::object::ObjectFile::createELFObjectFile((uint64_t)v11, a3, a4);
      break;
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
      __break(1u);
      JUMPOUT(0x1CCC7C440);
    case 27:
    case 28:
    case 29:
      llvm::object::ObjectFile::createCOFFObjectFile();
    case 31:
    case 32:
      llvm::object::ObjectFile::createXCOFFObjectFile();
    case 33:
      llvm::object::ObjectFile::createWasmObjectFile();
    case 37:
      llvm::object::ObjectFile::createMetalLibObjectFile();
    default:
      *(void *)&v13.__val_ = llvm::object::object_category(a1);
      llvm::errorCodeToError((llvm *)2, v13, (void *)a4);
      *(unsigned char *)(a4 + 8) |= 1u;
      break;
  }
}

void llvm::object::ObjectFile::createObjectFile(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  __int16 v17 = 261;
  uint64_t v13 = a1;
  uint64_t v14 = a2;
  sub_1CD096690((unsigned __int8 *)&v13, (llvm::WritableMemoryBuffer *)0xFFFFFFFFFFFFFFFFLL, 0, 0, 1, 0, (uint64_t)&v20);
  if ((uint64_t)v21.__cat_)
  {
    long long v5 = v20;
    if (v20)
    {
      *(void *)&v4.__val_ = *(void *)&v21.__val_;
      llvm::errorCodeToError(v20, v4, &v12);
      *(unsigned char *)(a3 + 16) |= 1u;
      *(void *)a3 = v12;
      return;
    }
  }
  else
  {
    std::system_category();
    long long v5 = v20;
  }
  uint64_t v6 = *((void *)v5 + 1);
  uint64_t v7 = *((void *)v5 + 2) - v6;
  uint64_t v8 = (*(uint64_t (**)(llvm *))(*(void *)v5 + 16))(v5);
  uint64_t v13 = v6;
  uint64_t v14 = v7;
  uint64_t v15 = v8;
  uint64_t v16 = v9;
  llvm::object::ObjectFile::createObjectFile((llvm::object *)&v13, 0, 1, (uint64_t)&v18);
  uint64_t v10 = v18;
  if (v19)
  {
    char v11 = *(unsigned char *)(a3 + 16);
    if (v18)
    {
      *(unsigned char *)(a3 + 16) = v11 | 1;
      *(void *)a3 = v10;
      (*(void (**)(llvm *))(*(void *)v5 + 8))(v5);
    }
    else
    {
      *(unsigned char *)(a3 + 16) = v11 & 0xFE;
      *(void *)a3 = 0;
      *(void *)(a3 + 8) = v5;
    }
  }
  else
  {
    *(unsigned char *)(a3 + 16) &= ~1u;
    *(void *)a3 = v10;
    *(void *)(a3 + 8) = v5;
  }
}

uint64_t llvm::object::ObjectFile::isReflectionSectionStrippable(uint64_t a1, unsigned int a2)
{
  return (a2 < 6) & (0x23u >> a2);
}

uint64_t llvm::OffloadBinary::create@<X0>(llvm::object *a1@<X0>, uint64_t a2@<X8>)
{
  if (*((void *)a1 + 1) > 0x47uLL)
  {
    if (**(_DWORD **)a1 == -1391395056) {
      operator new();
    }
    *(void *)&v8.__val_ = llvm::object::object_category(a1);
    uint64_t result = llvm::errorCodeToError((llvm *)3, v8, &v5);
    *(unsigned char *)(a2 + 8) |= 1u;
    uint64_t v4 = v5;
  }
  else
  {
    *(void *)&v7.__val_ = llvm::object::object_category(a1);
    uint64_t result = llvm::errorCodeToError((llvm *)3, v7, &v6);
    *(unsigned char *)(a2 + 8) |= 1u;
    uint64_t v4 = v6;
  }
  *(void *)a2 = v4;
  return result;
}

uint64_t llvm::getOffloadKind(unsigned __int16 *a1, uint64_t a2)
{
  switch(a2)
  {
    case 3:
      if (*a1 ^ 0x6968 | *((unsigned __int8 *)a1 + 2) ^ 0x70) {
        unsigned int v2 = 0;
      }
      else {
        unsigned int v2 = 65539;
      }
      break;
    case 4:
      if (*(_DWORD *)a1 == 1633973603) {
        unsigned int v2 = 65538;
      }
      else {
        unsigned int v2 = 0;
      }
      break;
    case 6:
      if (*(_DWORD *)a1 ^ 0x6E65706F | a1[2] ^ 0x706D) {
        unsigned int v2 = 0;
      }
      else {
        unsigned int v2 = 65537;
      }
      break;
    default:
      unsigned int v2 = 0;
      break;
  }
  if (v2 <= 0x10000) {
    LOWORD(v2) = 0;
  }
  return (unsigned __int16)v2;
}

const char *llvm::getOffloadKindName(int a1)
{
  if ((a1 - 1) > 2) {
    return "none";
  }
  else {
    return (&off_1E684F620)[(__int16)(a1 - 1)];
  }
}

uint64_t llvm::getImageKind(unsigned __int8 *a1, uint64_t a2)
{
  unsigned int v2 = 0;
  switch(a2)
  {
    case 1:
      int v3 = *a1;
      if (v3 == 115) {
        int v4 = 65541;
      }
      else {
        int v4 = 0;
      }
      if (v3 == 111) {
        unsigned int v2 = 65537;
      }
      else {
        unsigned int v2 = v4;
      }
      break;
    case 2:
      if (*(_WORD *)a1 == 25442) {
        unsigned int v2 = 65538;
      }
      else {
        unsigned int v2 = 0;
      }
      break;
    case 5:
      int v5 = *(_DWORD *)a1 ^ 0x69627563 | a1[4] ^ 0x6E;
      int v6 = 65539;
      goto LABEL_13;
    case 6:
      int v5 = *(_DWORD *)a1 ^ 0x62746166 | *((unsigned __int16 *)a1 + 2) ^ 0x6E69;
      int v6 = 65540;
LABEL_13:
      if (v5) {
        unsigned int v2 = 0;
      }
      else {
        unsigned int v2 = v6;
      }
      break;
    default:
      break;
  }
  if (v2 <= 0x10000) {
    LOWORD(v2) = 0;
  }
  return (unsigned __int16)v2;
}

const char *llvm::getImageKindName(int a1)
{
  if ((a1 - 1) > 4) {
    return "";
  }
  else {
    return (&off_1E684F638)[(__int16)(a1 - 1)];
  }
}

llvm::MCStreamer *llvm::RecordStreamer::RecordStreamer(llvm::RecordStreamer *this, llvm::MCContext *a2, const llvm::Module *a3)
{
  uint64_t result = llvm::MCStreamer::MCStreamer(this, a2);
  *(void *)uint64_t result = &unk_1F2633C70;
  *((void *)result + 34) = a3;
  *((void *)result + 35) = 0;
  *((void *)result + 36) = 0;
  *((void *)result + 37) = 0x1000000000;
  *((void *)result + 39) = 0;
  *((void *)result + 40) = 0;
  *((_DWORD *)result + 82) = 0;
  return result;
}

{
  llvm::MCStreamer *result;

  uint64_t result = llvm::MCStreamer::MCStreamer(this, a2);
  *(void *)uint64_t result = &unk_1F2633C70;
  *((void *)result + 34) = a3;
  *((void *)result + 35) = 0;
  *((void *)result + 36) = 0;
  *((void *)result + 37) = 0x1000000000;
  *((void *)result + 39) = 0;
  *((void *)result + 40) = 0;
  *((_DWORD *)result + 82) = 0;
  return result;
}

uint64_t llvm::RecordStreamer::flushSymverDirectives(llvm::RecordStreamer *this)
{
  v116[8] = *MEMORY[0x1E4F143B8];
  uint64_t v104 = 0;
  uint64_t v105 = 0;
  uint64_t v106 = 0x1000000000;
  v102[0] = 0;
  v102[1] = 0;
  int v103 = 0;
  v114 = (unsigned __int8 *)v116;
  long long v115 = xmmword_1CD96DBD0;
  unsigned int v2 = (void *)*((void *)this + 34);
  int v3 = (unsigned __int8 **)(v2 + 3);
  int v4 = (unsigned __int8 **)v2[4];
  int v5 = v2 + 1;
  int v6 = (void *)v2[2];
  std::error_code v7 = v2 + 5;
  std::error_code v8 = (void *)v2[6];
  uint64_t v9 = v2 + 7;
  uint64_t v10 = (void *)v2[8];
  v94 = v4;
  v95 = v6;
  v96 = v8;
  unint64_t v97 = (unint64_t)v10;
  v98 = v3;
  v99 = v5;
  v100 = v7;
  v101 = v9;
  while (v4 != v3 || v6 != v5 || v8 != v7 || v10 != v9 || v98 != v3 || v99 != v5 || v100 != v7 || v101 != v9)
  {
    uint64_t v11 = 0;
    uint64_t v112 = 0;
    uint64_t v108 = 0;
    uint64_t v110 = 0;
    *(void *)&v107[8] = 0;
    *(void *)v107 = sub_1CD6ED374;
    *(void *)&v107[16] = sub_1CD6ED390;
    v109 = sub_1CD6ED3AC;
    v111 = sub_1CD6ED3C8;
    do
    {
      uint64_t v12 = *(uint64_t (**)(void *))&v107[v11];
      uint64_t v13 = *(void *)&v107[v11 + 8];
      uint64_t v14 = (unsigned __int8 ***)((char *)&v94 + (v13 >> 1));
      if (v13) {
        uint64_t v12 = *(uint64_t (**)(void *))(*v14 + v12);
      }
      uint64_t v15 = (const llvm::GlobalValue *)v12(v14);
      size_t v16 = (size_t)v15;
      if (v15) {
        break;
      }
      BOOL v17 = v11 == 48;
      v11 += 16;
    }
    while (!v17);
    if ((*((unsigned char *)v15 + 23) & 0x10) != 0)
    {
      *(void *)&long long v115 = 0;
      uint64_t v22 = ***(void ***)v15;
      uint64_t v23 = *(void *)(v22 + 152);
      uint64_t v24 = *(unsigned int *)(v22 + 168);
      if (!v24) {
        goto LABEL_30;
      }
      LODWORD(v25) = (v24 - 1) & ((v15 >> 4) ^ (v15 >> 9));
      uint64_t v26 = v23 + 16 * v25;
      uint64_t v27 = *(const llvm::GlobalValue **)v26;
      if (*(const llvm::GlobalValue **)v26 != v15)
      {
        int v28 = 1;
        while (v27 != (const llvm::GlobalValue *)-4096)
        {
          int v29 = v25 + v28++;
          uint64_t v25 = v29 & (v24 - 1);
          uint64_t v27 = *(const llvm::GlobalValue **)(v23 + 16 * v25);
          if (v27 == v15)
          {
            uint64_t v26 = v23 + 16 * v25;
            goto LABEL_31;
          }
        }
LABEL_30:
        uint64_t v26 = v23 + 16 * v24;
      }
LABEL_31:
      if (*((void *)&v115 + 1) < (unint64_t)(**(void **)(v26 + 8) + 1)) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      *(_DWORD *)&v107[8] = 0;
      LOBYTE(v110) = 0;
      v111 = 0;
      *(void *)v107 = &unk_1F2646FA8;
      v113 = (void **)&v114;
      LODWORD(v112) = 0;
      uint64_t v108 = 0;
      v109 = 0;
      *(void *)&v107[16] = 0;
      llvm::Mangler::getNameWithPrefix((llvm::Mangler *)v102, (char **)v107, v15, 0);
      *(void *)v107 = &unk_1F2646B98;
      if (v112 == 1 && *(void *)&v107[16]) {
        MEMORY[0x1D25D9CB0](*(void *)&v107[16], 0x1000C8077774924);
      }
      (*sub_1CD3F4C18((uint64_t)&v104, v114, v115))[1] = v16;
    }
    uint64_t v18 = 0;
    uint64_t v112 = 0;
    uint64_t v108 = 0;
    uint64_t v110 = 0;
    *(void *)&v107[8] = 0;
    *(void *)v107 = sub_1CCC7D3D4;
    *(void *)&v107[16] = sub_1CCC7D3F8;
    v109 = sub_1CCC7D41C;
    v111 = sub_1CCC7D440;
    do
    {
      char v19 = *(uint64_t (**)(void *))&v107[v18];
      uint64_t v20 = *(void *)&v107[v18 + 8];
      std::error_code v21 = (unsigned __int8 ***)((char *)&v94 + (v20 >> 1));
      if (v20) {
        char v19 = *(uint64_t (**)(void *))(*v21 + v19);
      }
      if (v19(v21)) {
        break;
      }
      BOOL v17 = v18 == 48;
      v18 += 16;
    }
    while (!v17);
    int v4 = v94;
    int v6 = v95;
    std::error_code v8 = v96;
    uint64_t v10 = (void *)v97;
  }
  uint64_t v30 = *((void *)this + 39);
  uint64_t v31 = *((unsigned int *)this + 82);
  if (*((_DWORD *)this + 80))
  {
    if (v31)
    {
      uint64_t v33 = 32 * v31;
      uint64_t v32 = *((void *)this + 39);
      while ((*(void *)v32 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v32 += 32;
        v33 -= 32;
        if (!v33) {
          goto LABEL_43;
        }
      }
    }
    else
    {
      uint64_t v32 = *((void *)this + 39);
    }
  }
  else
  {
LABEL_43:
    uint64_t v32 = v30 + 32 * v31;
  }
  uint64_t v81 = v30 + 32 * v31;
  if (v32 != v81)
  {
    uint64_t v80 = v30 + 32 * v31;
    do
    {
      int v35 = *(unsigned char **)v32;
      int SymbolState = llvm::RecordStreamer::getSymbolState(this, *(const llvm::MCSymbol **)v32);
      int v37 = SymbolState - 1;
      v89 = v35;
      if (SymbolState - 1) < 6 && ((0x2Du >> v37))
      {
        uint64_t v38 = dword_1CFB2C30C[v37];
        if ((SymbolState - 2) < 3) {
          goto LABEL_87;
        }
        BOOL v90 = 0;
        int v39 = 0;
      }
      else
      {
        uint64_t v38 = 0;
        BOOL v90 = (SymbolState - 2) < 3;
        int v39 = 1;
      }
      if ((*v35 & 4) != 0)
      {
        uint64_t v42 = (void *)*((void *)v35 - 1);
        unint64_t v43 = *v42;
        unsigned int v40 = (unsigned __int8 *)(v42 + 2);
        unint64_t v41 = v43;
      }
      else
      {
        unsigned int v40 = 0;
        unint64_t v41 = 0;
      }
      uint64_t NamedValue = llvm::Module::getNamedValue(*((void *)this + 34), v40, v41);
      if (NamedValue) {
        goto LABEL_78;
      }
      int v78 = v39;
      if ((*v35 & 4) != 0)
      {
        unsigned int v45 = v105;
        if (v105)
        {
          uint64_t v49 = (size_t *)*((void *)v35 - 1);
          size_t v47 = *v49;
          v46 = (unsigned __int8 *)(v49 + 2);
          if (*v49)
          {
            uint64_t v50 = 0;
            int v48 = 0;
            do
              int v48 = 33 * v48 + v46[v50++];
            while (v47 != v50);
            char v85 = 0;
            goto LABEL_67;
          }
LABEL_59:
          int v48 = 0;
          char v85 = 1;
LABEL_67:
          unsigned int v51 = v45 - 1;
          uint64_t v52 = v104;
          uint64_t v79 = v45;
          uint64_t v87 = v104 + 8 * v45 + 8;
          uint64_t v82 = HIDWORD(v106);
          int v53 = 1;
          int v54 = v48;
          v84 = v46;
          unsigned int v83 = v51;
          while (1)
          {
            uint64_t v55 = v54 & v51;
            v56 = *(void **)(v52 + 8 * v55);
            if (v56 != (void *)-8)
            {
              if (!v56) {
                goto LABEL_99;
              }
              if (*(_DWORD *)(v87 + 4 * v55) == v48 && v47 == *v56)
              {
                if (v85) {
                  break;
                }
                int v57 = memcmp(v46, (char *)v56 + v82, v47);
                unsigned int v51 = v83;
                v46 = v84;
                if (!v57) {
                  break;
                }
              }
            }
            int v54 = v53 + v55;
            ++v53;
          }
          if (v55 == -1) {
            goto LABEL_99;
          }
          if ((int)v55 == v79) {
            goto LABEL_99;
          }
          uint64_t NamedValue = *(void *)(*(void *)(v52 + 8 * (int)v55) + 8);
          int v39 = v78;
          if (!NamedValue) {
            goto LABEL_99;
          }
LABEL_78:
          if (v39)
          {
            if ((*(_DWORD *)(NamedValue + 32) & 0xF) != 0)
            {
              if ((*(_DWORD *)(NamedValue + 32) & 0xFu) - 7 >= 2)
              {
                if ((*(_DWORD *)(NamedValue + 32) & 0xFu) - 2 > 8) {
                  uint64_t v38 = 0;
                }
                else {
                  uint64_t v38 = dword_1CFB2C324[(*(_DWORD *)(NamedValue + 32) & 0xF) - 2];
                }
              }
              else
              {
                uint64_t v38 = 16;
              }
            }
            else
            {
              uint64_t v38 = 9;
            }
          }
          if (v90)
          {
LABEL_87:
            int v58 = 1;
          }
          else
          {
            int v59 = *(_DWORD *)(NamedValue + 32);
            if ((v59 & 0xF) == 1)
            {
              BOOL v60 = 1;
            }
            else if (*(unsigned char *)(NamedValue + 16))
            {
              BOOL v60 = *(unsigned char *)(NamedValue + 16) == 3 && (*(_DWORD *)(NamedValue + 20) & 0x7FFFFFF) == 0;
            }
            else
            {
              BOOL v60 = (v59 & 0x800000) == 0;
              if (*(void *)(NamedValue + 72) != NamedValue + 72) {
                BOOL v60 = 0;
              }
            }
            int v58 = !v60;
          }
          BOOL v90 = v58;
        }
      }
      else
      {
        unsigned int v45 = v105;
        if (v105)
        {
          v46 = 0;
          size_t v47 = 0;
          goto LABEL_59;
        }
      }
LABEL_99:
      v61 = *(long long **)(v32 + 8);
      v62 = *(long long **)(v32 + 16);
      if (v61 != v62)
      {
        v64 = "@";
        if (v90) {
          v64 = "@@";
        }
        v88 = v64;
        do
        {
          long long v93 = *v61;
          unint64_t v65 = llvm::StringRef::find((uint64_t *)&v93, "@@@", 3uLL, 0);
          if (v65 == -1)
          {
            *(void *)v107 = &v108;
            *(_OWORD *)&v107[8] = xmmword_1CFAC3020;
            v66 = (void *)*((void *)&v93 + 1);
            v67 = (unsigned __int8 **)v93;
          }
          else
          {
            v66 = (void *)*((void *)&v93 + 1);
            v67 = (unsigned __int8 **)v93;
            if (*((void *)&v93 + 1) >= v65) {
              unint64_t v68 = v65;
            }
            else {
              unint64_t v68 = *((void *)&v93 + 1);
            }
            if (*((void *)&v93 + 1) >= v65 + 3) {
              unint64_t v69 = v65 + 3;
            }
            else {
              unint64_t v69 = *((void *)&v93 + 1);
            }
            *(void *)v107 = &v108;
            *(_OWORD *)&v107[8] = xmmword_1CFAC3020;
            if (*((void *)&v93 + 1) > v65 + 3 && *(unsigned char *)(v93 + v69) != 64)
            {
              __int16 v92 = 773;
              v91[0] = v93;
              v91[1] = v68;
              v91[2] = v88;
              v94 = (unsigned __int8 **)v91;
              v96 = (void *)(v93 + v69);
              unint64_t v97 = *((void *)&v93 + 1) - v69;
              LOWORD(v98) = 1282;
              llvm::Twine::toVector((uint64_t)&v94, (uint64_t)v107);
              v66 = *(void **)&v107[8];
              v67 = *(unsigned __int8 ***)v107;
              long long v93 = *(_OWORD *)v107;
            }
          }
          v70 = (llvm::MCContext *)*((void *)this + 1);
          LOWORD(v98) = 261;
          v94 = v67;
          v95 = v66;
          v71 = (const llvm::MCSymbol *)llvm::MCContext::getOrCreateSymbol(v70, &v94);
          uint64_t v72 = *((void *)this + 1);
          *(void *)(v72 + 272) += 24;
          uint64_t v73 = *(void *)(v72 + 192);
          if (((v73 + 7) & 0xFFFFFFFFFFFFFFF8) - v73 + 24 > *(void *)(v72 + 200) - v73)
          {
            unsigned int v76 = *(_DWORD *)(v72 + 216) >> 7;
            if (v76 >= 0x1E) {
              LOBYTE(v76) = 30;
            }
            uint64_t v86 = 4096 << v76;
            unint64_t v74 = (unint64_t)operator new(4096 << v76, (std::align_val_t)8uLL);
            unint64_t v77 = *(unsigned int *)(v72 + 216);
            if (v77 >= *(unsigned int *)(v72 + 220)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(*(void *)(v72 + 208) + 8 * v77) = v74;
            ++*(_DWORD *)(v72 + 216);
            *(void *)(v72 + 200) = v74 + v86;
          }
          else
          {
            unint64_t v74 = (v73 + 7) & 0xFFFFFFFFFFFFFFF8;
          }
          *(void *)(v72 + 192) = v74 + 24;
          int v75 = *(unsigned __int8 *)(*(void *)(v72 + 152) + 18) << 16;
          *(unsigned char *)unint64_t v74 = 2;
          *(_DWORD *)(v74 + 1) = v75 | (*(unsigned __int8 *)(v74 + 4) << 24);
          *(void *)(v74 + 8) = 0;
          *(void *)(v74 + 16) = v89;
          if (v90) {
            llvm::RecordStreamer::markDefined(this, v71);
          }
          llvm::MCStreamer::emitAssignment(this, v71, (const llvm::MCExpr **)v74);
          if (v38) {
            (*(void (**)(llvm::RecordStreamer *, const llvm::MCSymbol *, uint64_t))(*(void *)this + 304))(this, v71, v38);
          }
          if (*(uint64_t **)v107 != &v108) {
            free(*(void **)v107);
          }
          ++v61;
        }
        while (v61 != v62);
      }
      uint64_t v63 = v32 + 32;
      uint64_t v32 = v80;
      if (v63 != v80)
      {
        uint64_t v32 = v63;
        while ((*(void *)v32 | 0x1000) == 0xFFFFFFFFFFFFF000)
        {
          v32 += 32;
          if (v32 == v80)
          {
            uint64_t v32 = v80;
            break;
          }
        }
      }
    }
    while (v32 != v81);
  }
  if (v114 != (unsigned __int8 *)v116) {
    free(v114);
  }
  MEMORY[0x1D25D9CD0](v102[0], 8);
  return sub_1CD4AFD10((uint64_t)&v104);
}

BOOL sub_1CCC7D3D4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = a1[4];
  if (*a1 != v2) {
    *a1 = *(void *)(v1 + 8);
  }
  return v1 != v2;
}

BOOL sub_1CCC7D3F8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 40);
  if (v1 != v2) {
    *(void *)(a1 + 8) = *(void *)(v1 + 8);
  }
  return v1 != v2;
}

BOOL sub_1CCC7D41C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  uint64_t v2 = *(void *)(a1 + 48);
  if (v1 != v2) {
    *(void *)(a1 + 16) = *(void *)(v1 + 8);
  }
  return v1 != v2;
}

BOOL sub_1CCC7D440(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  uint64_t v2 = *(void *)(a1 + 56);
  if (v1 != v2) {
    *(void *)(a1 + 24) = *(void *)(v1 + 8);
  }
  return v1 != v2;
}

BOOL (*llvm::object::getRelocationResolver(_DWORD *a1))(uint64_t a1)
{
  int v2 = a1[2];
  if (v2 == 9)
  {
    int v3 = (*(uint64_t (**)(_DWORD *))(*(void *)a1 + 376))(a1);
    int v4 = sub_1CCC7DA8C;
    if (v3 <= 38)
    {
      if (v3 != 1)
      {
        if (v3 == 3) {
          return sub_1CCC7DAE0;
        }
        return 0;
      }
    }
    else if (v3 != 39)
    {
      if (v3 == 42) {
        return (BOOL (*)(uint64_t))v4;
      }
      if (v3 == 41) {
        return sub_1CCC7DAB0;
      }
      return 0;
    }
    return sub_1CCC7DAC8;
  }
  unsigned int v5 = v2 & 0xFFFFFFFC;
  if (v5 == 16)
  {
    if ((*(unsigned int (**)(_DWORD *))(*(void *)a1 + 376))(a1) == 42) {
      return sub_1CCC7E030;
    }
    else {
      return 0;
    }
  }
  else if (v5 == 12)
  {
    int v6 = (*(uint64_t (**)(_DWORD *))(*(void *)a1 + 360))(a1);
    int v7 = (*(uint64_t (**)(_DWORD *))(*(void *)a1 + 376))(a1);
    if (v6 != 8)
    {
      int v4 = sub_1CCC7DEEC;
      if (v7 <= 30)
      {
        switch(v7)
        {
          case 1:
          case 2:
            return sub_1CCC7DF40;
          case 7:
            return sub_1CCC7DF68;
          case 12:
            return sub_1CCC7E01C;
          case 16:
          case 17:
            return sub_1CCC7DFA8;
          case 20:
            return sub_1CCC7DFC4;
          case 21:
          case 22:
            return sub_1CCC7DF1C;
          default:
            return 0;
        }
      }
      if (v7 > 40)
      {
        if (v7 == 41) {
          return (BOOL (*)(uint64_t))v4;
        }
        if (v7 == 62) {
          return sub_1CCC7DF94;
        }
      }
      else
      {
        if (v7 == 31) {
          return (BOOL (*)(uint64_t))sub_1CCC7DD88;
        }
        if (v7 == 33) {
          return sub_1CCC7DFF0;
        }
      }
      return 0;
    }
    if (v7 <= 17)
    {
      if ((v7 - 3) < 2) {
        return (BOOL (*)(uint64_t))sub_1CCC7DBB0;
      }
      if ((v7 - 8) < 2) {
        return sub_1CCC7DC44;
      }
      return 0;
    }
    std::error_code v8 = sub_1CCC7DB04;
    switch(v7)
    {
      case 18:
      case 19:
        return (BOOL (*)(uint64_t))sub_1CCC7DC68;
      case 20:
      case 21:
      case 22:
      case 25:
      case 26:
      case 27:
      case 28:
      case 29:
      case 31:
      case 33:
      case 35:
        return 0;
      case 23:
      case 24:
        return (BOOL (*)(uint64_t))sub_1CCC7DCD0;
      case 30:
        return sub_1CCC7DD70;
      case 32:
        return (BOOL (*)(uint64_t))sub_1CCC7DD88;
      case 34:
        return (BOOL (*)(uint64_t))sub_1CCC7DD44;
      case 36:
        return sub_1CCC7DD20;
      default:
        if (v7 != 42) {
          return 0;
        }
        break;
    }
  }
  else
  {
    int v9 = (*(uint64_t (**)(_DWORD *))(*(void *)a1 + 376))(a1);
    int v4 = sub_1CCC7E044;
    if (v9 == 63) {
      return (BOOL (*)(uint64_t))v4;
    }
    if ((*(unsigned int (**)(_DWORD *, uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t)))(*(void *)a1 + 376))(a1, sub_1CCC7E060) == 64)return (BOOL (*)(uint64_t))sub_1CCC7E068; {
    else
    }
      return 0;
  }
  return (BOOL (*)(uint64_t))v8;
}

BOOL sub_1CCC7DA8C(uint64_t a1)
{
  return a1 == 11 || a1 == 1;
}

uint64_t sub_1CCC7DA9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1 == 11) {
    return (a4 + a3);
  }
  else {
    return a4 + a3;
  }
}

BOOL sub_1CCC7DAB0(uint64_t a1)
{
  return a1 == 11 || a1 == 6;
}

uint64_t sub_1CCC7DAC0(uint64_t a1, uint64_t a2, int a3, int a4)
{
  return (a4 + a3);
}

BOOL sub_1CCC7DAC8(uint64_t a1)
{
  return a1 == 15 || a1 == 1;
}

uint64_t sub_1CCC7DAD8(uint64_t a1, uint64_t a2, int a3, int a4)
{
  return (a4 + a3);
}

BOOL sub_1CCC7DAE0(uint64_t a1)
{
  return a1 == 8 || a1 == 14;
}

uint64_t sub_1CCC7DAF0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1 == 8) {
    return (a4 + a3);
  }
  else {
    return a4 + a3;
  }
}

uint64_t sub_1CCC7DB04(unint64_t a1)
{
  return (a1 < 0x19) & (0x1220C07u >> a1);
}

uint64_t sub_1CCC7DB20(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a1 <= 16)
  {
    switch(a1)
    {
      case 1:
        return a5 + a3;
      case 2:
        return a5 + a3 - a2;
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
        __break(1u);
        JUMPOUT(0x1CCC7DB80);
      case 10:
      case 11:
        return (a5 + a3);
      default:
        return a4;
    }
  }
  if (a1 == 24) {
    return a5 + a3 - a2;
  }
  else {
    return a5 + a3;
  }
}

uint64_t sub_1CCC7DBB0(uint64_t a1)
{
  return ((unint64_t)(a1 - 257) < 6) & (0x3Bu >> (a1 - 1));
}

uint64_t sub_1CCC7DBCC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  switch(a1)
  {
    case 258:
      uint64_t result = (a5 + a3);
      break;
    case 259:
      __break(1u);
      JUMPOUT(0x1CCC7DC2CLL);
    case 260:
      uint64_t result = a5 + a3 - a2;
      break;
    case 261:
      uint64_t result = (a5 + a3 - a2);
      break;
    case 262:
      uint64_t result = (unsigned __int16)(a5 + a3 - a2);
      break;
    default:
      uint64_t result = a5 + a3;
      break;
  }
  return result;
}

BOOL sub_1CCC7DC44(uint64_t a1)
{
  return (a1 & 0xFFFFFFFFFFFFFFFELL) == 2;
}

uint64_t sub_1CCC7DC54(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1 == 3) {
    return (a4 + a3);
  }
  else {
    return a4 + a3;
  }
}

BOOL sub_1CCC7DC68(unint64_t a1)
{
  BOOL result = 1;
  if (a1 > 0x29 || ((1 << a1) & 0x20000040004) == 0) {
    return a1 == 248;
  }
  return result;
}

uint64_t sub_1CCC7DCA4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = a5 + a3;
  uint64_t v6 = a5 + a3 - 0x8000;
  if (a1 != 41) {
    uint64_t v6 = a5 + a3 - a2;
  }
  if (a1 == 2) {
    uint64_t v5 = (a5 + a3);
  }
  if (a1 <= 40) {
    return v5;
  }
  else {
    return v6;
  }
}

uint64_t sub_1CCC7DCD0(unint64_t a1)
{
  return (a1 < 0x2D) & (0x104004000002uLL >> a1);
}

uint64_t sub_1CCC7DCF0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = a5 + a3;
  if (a1 != 38) {
    uint64_t v5 = a5 + a3 - a2;
  }
  uint64_t v6 = (a5 + a3);
  if (a1 != 1) {
    uint64_t v6 = (a5 + a3 - a2);
  }
  if (a1 <= 37) {
    return v6;
  }
  else {
    return v5;
  }
}

BOOL sub_1CCC7DD20(uint64_t a1)
{
  return a1 == 4 || a1 == 22;
}

uint64_t sub_1CCC7DD30(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a1 == 4) {
    return (a5 + a3);
  }
  else {
    return a5 + a3;
  }
}

uint64_t sub_1CCC7DD44(unint64_t a1)
{
  return (a1 < 0x37) & (0x40000100800008uLL >> a1);
}

uint64_t sub_1CCC7DD68(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return a5 + a3;
}

BOOL sub_1CCC7DD70(uint64_t a1)
{
  return a1 == 6 || a1 == 3;
}

uint64_t sub_1CCC7DD80(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return a5 + a3;
}

uint64_t sub_1CCC7DD88(unint64_t a1)
{
  return (a1 < 0x3A) & (0x23001FE00000007uLL >> a1);
}

unint64_t sub_1CCC7DDA8(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a1 <= 32)
  {
    uint64_t v6 = (a5 + a3);
    if (a1 != 1) {
      uint64_t v6 = a5 + a3;
    }
    if (a1) {
      return v6;
    }
    else {
      return a4;
    }
  }
  else
  {
    switch(a1)
    {
      case '""':
        return (unsigned __int16)(a5 + a3 + a4);
      case '#':
        return (a5 + a3 + a4);
      case '$':
        return a5 + a3 + a4;
      case '%':
        unsigned __int8 v5 = a4 - (a3 + a5);
        goto LABEL_10;
      case '&':
        return (unsigned __int16)(a4 - (a3 + a5));
      case '\'':
        return (a4 - (a3 + a5));
      case '(':
        return a4 - (a3 + a5);
      case ')':
      case '*':
      case '+':
      case ',':
      case '-':
      case '.':
      case '/':
      case '0':
      case '1':
      case '2':
      case '3':
      case '6':
      case '7':
      case '8':
        __break(1u);
        JUMPOUT(0x1CCC7DE88);
      case '4':
        uint64_t v8 = a4 & 0xC0;
        char v9 = a4 - (a3 + a5);
        goto LABEL_19;
      case '5':
        uint64_t v8 = a4 & 0xC0;
        char v9 = a5 + a3;
LABEL_19:
        unint64_t result = v8 & 0xFFFFFFFFFFFFFFC0 | v9 & 0x3F;
        break;
      case '9':
        unint64_t result = (a5 + a3 - a2);
        break;
      default:
        unsigned __int8 v5 = a5 + a3 + a4;
LABEL_10:
        unint64_t result = v5;
        break;
    }
  }
  return result;
}

BOOL sub_1CCC7DEEC(unint64_t a1)
{
  return a1 < 3;
}

uint64_t sub_1CCC7DEF8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1)
  {
    if (a1 == 2) {
      a4 += a3 - a2;
    }
    else {
      a4 += a3;
    }
  }
  return a4;
}

BOOL sub_1CCC7DF1C(uint64_t a1)
{
  return a1 == 1 || a1 == 26;
}

uint64_t sub_1CCC7DF2C(uint64_t a1, int a2, int a3, uint64_t a4, int a5)
{
  if (a1 == 1) {
    int v5 = 0;
  }
  else {
    int v5 = a2;
  }
  return (a3 - v5 + a5);
}

BOOL sub_1CCC7DF40(uint64_t a1)
{
  return (a1 & 0xFFFFFFFFFFFFFFFELL) == 2;
}

uint64_t sub_1CCC7DF50(uint64_t a1, int a2, int a3, int a4, int a5)
{
  if (a1 == 2) {
    int v5 = 0;
  }
  else {
    int v5 = a2;
  }
  return (a3 - v5 + a4 + a5);
}

BOOL sub_1CCC7DF68(uint64_t a1)
{
  return a1 == 4 || a1 == 1;
}

uint64_t sub_1CCC7DF78(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  int v5 = -1;
  if (a1 == 4) {
    int v5 = 0xFFFF;
  }
  return (a5 + a3) & v5;
}

BOOL sub_1CCC7DF94(uint64_t a1)
{
  return a1 == 4;
}

uint64_t sub_1CCC7DFA0(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  return (a5 + a3);
}

BOOL sub_1CCC7DFA8(uint64_t a1)
{
  return a1 == 2 || a1 == 39;
}

uint64_t sub_1CCC7DFBC(uint64_t a1, uint64_t a2, int a3, int a4)
{
  return (a4 + a3);
}

BOOL sub_1CCC7DFC4(uint64_t a1)
{
  return ((a1 - 1) & 0xFFFFFFFFFFFFFFFBLL) == 0;
}

uint64_t sub_1CCC7DFD4(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  int v5 = 0xFFFF;
  if (a1 == 1) {
    int v5 = -1;
  }
  return (a5 + a3) & v5;
}

BOOL sub_1CCC7DFF0(uint64_t a1)
{
  return a1 == 3 || a1 == 23;
}

uint64_t sub_1CCC7E000(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a1 == 23 || a1 == 3) {
    return a5 + a3;
  }
  return a4;
}

BOOL sub_1CCC7E01C(uint64_t a1)
{
  return a1 == 6;
}

uint64_t sub_1CCC7E028(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return a5 + a3;
}

BOOL sub_1CCC7E030(uint64_t a1)
{
  return a1 == 0;
}

uint64_t sub_1CCC7E03C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

uint64_t sub_1CCC7E044(unint64_t a1)
{
  return (a1 < 0x18) & (0x9027FFu >> a1);
}

uint64_t sub_1CCC7E060(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a4;
}

uint64_t sub_1CCC7E068(unint64_t a1)
{
  return (a1 < 0x18) & (0xDDE7FFu >> a1);
}

uint64_t sub_1CCC7E084(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a4;
}

uint64_t llvm::object::resolveRelocation(uint64_t (*a1)(void, void, void, void, void), void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = a4;
  uint64_t v8 = a1;
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  char v9 = (_DWORD *)a2[1];
  if (v9)
  {
    int v10 = v9[2];
    if ((v10 & 0xFFFFFFFC) != 0xC)
    {
LABEL_3:
      uint64_t v11 = 0;
LABEL_4:
      uint64_t v12 = (*(uint64_t (**)(void, void, uint64_t, uint64_t, uint64_t, uint64_t (*)(void, void, void, void, void)))(*(void *)a2[1] + 312))(a2[1], *a2, a3, a4, a5, v8);
      uint64_t v13 = (*(uint64_t (**)(void))(*(void *)a2[1] + 296))();
      return a1(v12, v13, a3, v5, v11);
    }
    if (v10 != 14)
    {
      if (v10 == 13)
      {
        uint64_t v18 = sub_1CD6DC760((uint64_t)v9, *a2);
      }
      else
      {
        if (v10 == 12)
        {
          size_t v16 = sub_1CD6D9704((uint64_t)v9, *a2);
LABEL_13:
          unsigned int v17 = *((_DWORD *)v16 + 1);
          goto LABEL_17;
        }
        uint64_t v18 = sub_1CD6E26E4((uint64_t)v9, *a2);
      }
      unsigned int v17 = bswap32(*((_DWORD *)v18 + 1));
LABEL_17:
      if (v17 != 4) {
        goto LABEL_3;
      }
      (*(void (**)(void **__return_ptr))(*(void *)a2[1] + 488))(&v33);
      if ((v34 & 1) == 0 || (char v19 = v33, v33 = 0, !v19))
      {
        uint64_t v27 = 0;
        goto LABEL_37;
      }
      if ((*(unsigned int (**)(void *, void *))(*v19 + 48))(v19, &llvm::ErrorList::ID))
      {
        uint64_t v20 = (uint64_t *)v19[1];
        std::error_code v21 = (uint64_t *)v19[2];
        if (v20 == v21)
        {
          uint64_t v22 = 0;
        }
        else
        {
          uint64_t v22 = 0;
          do
          {
            uint64_t v31 = v22;
            uint64_t v23 = *v20;
            *uint64_t v20 = 0;
            uint64_t v29 = v23;
            sub_1CCC7E4E4(&v30, &v29);
            sub_1CD451630(&v31, &v30, &v32);
            uint64_t v22 = v32;
            uint64_t v32 = 0;
            if (v30) {
              (*(void (**)(char *))(*(void *)v30 + 8))(v30);
            }
            uint64_t v24 = v29;
            uint64_t v29 = 0;
            if (v24) {
              (*(void (**)(uint64_t))(*(void *)v24 + 8))(v24);
            }
            if (v31) {
              (*(void (**)(char *))(*(void *)v31 + 8))(v31);
            }
            ++v20;
          }
          while (v20 != v21);
        }
        uint64_t v27 = v22;
        uint64_t v25 = *(void (**)(void))(*v19 + 8);
      }
      else
      {
        int v28 = v19;
        sub_1CCC7E4E4(&v27, &v28);
        if (!v28) {
          goto LABEL_37;
        }
        uint64_t v25 = *(void (**)(void))(*v28 + 8);
      }
      v25();
LABEL_37:
      uint64_t v11 = v33;
      if (v34)
      {
        uint64_t v33 = 0;
        if (v11) {
          (*(void (**)(void *))(*v11 + 8))(v11);
        }
      }
      if ((*(unsigned int (**)(_DWORD *))(*(void *)v9 + 376))(v9) != 31
        && (*(unsigned int (**)(_DWORD *))(*(void *)v9 + 376))(v9) != 32)
      {
        uint64_t v5 = 0;
      }
      goto LABEL_4;
    }
    size_t v16 = sub_1CD6DF6AC((uint64_t)v9, *a2);
    goto LABEL_13;
  }
  uint64_t v15 = *a2;

  return a1(0, 0, a3, a4, v15);
}

uint64_t sub_1CCC7E4E4(void *a1, void *a2)
{
  int v4 = (*(uint64_t (**)(void, void *))(*(void *)*a2 + 48))(*a2, &llvm::ErrorInfoBase::ID);
  uint64_t result = *a2;
  *a2 = 0;
  if (v4)
  {
    (*(void (**)(void *__return_ptr))(*(void *)result + 24))(v6);
    __int16 v8 = 260;
    int v7 = v6;
    llvm::report_fatal_error((llvm *)&v7, (const llvm::Twine *)1);
  }
  *a1 = result;
  return result;
}

__n128 llvm::object::SymbolicFile::SymbolicFile(uint64_t a1, int a2, uint64_t a3)
{
  __n128 result = *(__n128 *)a3;
  long long v4 = *(_OWORD *)(a3 + 16);
  *(_DWORD *)(a1 + 8) = a2;
  *(__n128 *)(a1 + 16) = result;
  *(_OWORD *)(a1 + 32) = v4;
  *(void *)a1 = &unk_1F2634190;
  return result;
}

void llvm::object::SymbolicFile::createSymbolicFile(uint64_t a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X2>, int a4@<W3>, uint64_t a5@<X8>)
{
  uint64_t v6 = (_OWORD *)a1;
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    int v19 = a4;
    a1 = llvm::identify_magic(*(unsigned __int8 **)a1, *(void *)(a1 + 8));
    a4 = v19;
    a2 = a1;
  }
  if (a2 - 3 >= 0x14)
  {
    if (a2 <= 0x25)
    {
      if (a2 == 1)
      {
        if (a3)
        {
          long long v15 = v6[1];
          v24[0] = *v6;
          v24[1] = v15;
          llvm::object::IRObjectFile::create(v24, (uint64_t)&v28);
LABEL_23:
          *(unsigned char *)(a5 + 8) = *(unsigned char *)(a5 + 8) & 0xFE | v28.n128_u8[8] & 1;
          unint64_t v16 = v28.n128_u64[0];
LABEL_24:
          *(void *)a5 = v16;
          return;
        }
      }
      else if (((1 << a2) & 0x23B8000000) != 0)
      {
        goto LABEL_4;
      }
    }
    *(void *)&v33.__val_ = llvm::object::object_category((llvm::object *)a1);
    llvm::errorCodeToError((llvm *)2, v33, &v25);
    *(unsigned char *)(a5 + 8) |= 1u;
    unint64_t v16 = v25;
    goto LABEL_24;
  }
LABEL_4:
  if (a2 == 9) {
    goto LABEL_5;
  }
  if (((1 << a2) & 0x23A07FFDE8) != 0)
  {
    long long v17 = v6[1];
    v23[0] = *v6;
    v23[1] = v17;
    llvm::object::ObjectFile::createObjectFile((llvm::object *)v23, a2, a4, (uint64_t)&v28);
    goto LABEL_23;
  }
  if (((1 << a2) & 0x8000010) == 0) {
    operator new();
  }
LABEL_5:
  long long v8 = v6[1];
  v22[0] = *v6;
  v22[1] = v8;
  llvm::object::ObjectFile::createObjectFile((llvm::object *)v22, a2, a4, (uint64_t)&v30);
  char v10 = v31;
  if (!a3 || (v31 & 1) != 0)
  {
    uint64_t v14 = 0;
    *(unsigned char *)(a5 + 8) = *(unsigned char *)(a5 + 8) & 0xFE | v31 & 1;
    *(void *)a5 = v30;
  }
  else
  {
    llvm::object::IRObjectFile::findBitcodeInObject(v30, v9, &v28);
    if (v29)
    {
      uint64_t v11 = (void *)v28.n128_u64[0];
      v28.n128_u64[0] = 0;
      std::error_code v21 = v11;
      sub_1CD4515D0(&v21);
      if (v21) {
        (*(void (**)(void *))(*v21 + 8))(v21);
      }
      *(unsigned char *)(a5 + 8) = *(unsigned char *)(a5 + 8) & 0xFE | v31 & 1;
      uint64_t v12 = v30;
      uint64_t v30 = 0;
    }
    else
    {
      long long v18 = v6[1];
      v20[0] = v28;
      v20[1] = v18;
      llvm::object::IRObjectFile::create(v20, (uint64_t)&v26);
      *(unsigned char *)(a5 + 8) = *(unsigned char *)(a5 + 8) & 0xFE | v27 & 1;
      uint64_t v12 = v26;
    }
    *(void *)a5 = v12;
    if (v29)
    {
      unint64_t v13 = v28.n128_u64[0];
      v28.n128_u64[0] = 0;
      if (v13) {
        (*(void (**)(unint64_t))(*(void *)v13 + 8))(v13);
      }
    }
    char v10 = v31;
    uint64_t v14 = v30;
  }
  uint64_t v30 = 0;
  if ((v10 & 1) == 0)
  {
    if (!v14) {
      return;
    }
    goto LABEL_17;
  }
  if (v14) {
LABEL_17:
  }
    (*(void (**)(__n128 *))(v14->n128_u64[0] + 8))(v14);
}

BOOL llvm::object::SymbolicFile::isSymbolicFile(unsigned int a1, uint64_t a2)
{
  BOOL result = 1;
  if (a1 - 3 >= 0x14)
  {
    if (a1 <= 0x25)
    {
      if (((1 << a1) & 0x23B8000000) != 0) {
        return result;
      }
      if (a1 == 1) {
        return a2 != 0;
      }
    }
    return 0;
  }
  return result;
}

uint64_t llvm::object::compareAddress(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 28);
  unsigned int v3 = *(_DWORD *)(a2 + 28);
  if (v2 == v3)
  {
    unint64_t v4 = *(void *)(a1 + 16);
    unint64_t v5 = *(void *)(a2 + 16);
    BOOL v6 = v4 == v5;
    if (v4 < v5) {
      unsigned int v7 = -1;
    }
    else {
      unsigned int v7 = 1;
    }
    if (v6) {
      return 0;
    }
    else {
      return v7;
    }
  }
  else if (v2 < v3)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    return 1;
  }
}

void *llvm::object::TapiFile::TapiFile(uint64_t a1, long long *a2, uint64_t a3, int a4)
{
  unint64_t v4 = (void *)a1;
  uint64_t v131 = *MEMORY[0x1E4F143B8];
  long long v6 = *a2;
  long long v5 = a2[1];
  *(_DWORD *)(a1 + 8) = 5;
  *(_OWORD *)(a1 + 16) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(void *)a1 = &unk_1F2634230;
  *(void *)(a1 + 48) = 0;
  v124 = (void **)(a1 + 48);
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(unsigned char *)(a1 + 72) = a4;
  uint64_t v7 = *(void *)(a3 + 344);
  uint64_t v8 = *(unsigned int *)(a3 + 360);
  uint64_t v9 = v7 + 32 * v8;
  if (*(_DWORD *)(a3 + 352))
  {
    if (v8)
    {
      uint64_t v10 = 32 * v8;
      uint64_t v11 = *(void *)(a3 + 344);
      while ((*(unsigned char *)v11 == 3 || !*(unsigned char *)v11) && !*(void *)(v11 + 16))
      {
        v11 += 32;
        v10 -= 32;
        if (!v10) {
          goto LABEL_8;
        }
      }
    }
    else
    {
      uint64_t v11 = *(void *)(a3 + 344);
    }
  }
  else
  {
LABEL_8:
    uint64_t v11 = v7 + 32 * v8;
  }
  uint64_t v12 = v7 + 32 * v8;
  if (v11 != v12)
  {
    unint64_t v13 = 0;
    int v14 = 1 << a4;
    uint64_t v123 = v7 + 32 * v8;
    int v122 = 1 << a4;
    do
    {
      long long v15 = *(uint64_t **)(v11 + 24);
      uint64_t v16 = *((unsigned int *)v15 + 6);
      if (v16)
      {
        int v17 = 0;
        long long v18 = (unsigned __int8 *)v15[2];
        uint64_t v19 = 8 * v16;
        do
        {
          int v20 = *v18;
          v18 += 8;
          int v21 = 1 << v20;
          if (v20 == 120) {
            int v22 = 0;
          }
          else {
            int v22 = v21;
          }
          v17 |= v22;
          v19 -= 8;
        }
        while (v19);
      }
      else
      {
        int v17 = 0;
      }
      if ((v17 & v14) == 0) {
        goto LABEL_88;
      }
      switch(*((unsigned char *)v15 + 72))
      {
        case 0:
          uint64_t v23 = *v15;
          uint64_t v24 = v15[1];
          if ((*((unsigned char *)v15 + 73) & 8) != 0) {
            int v25 = 3;
          }
          else {
            int v25 = 66;
          }
          if ((*((unsigned char *)v15 + 73) & 6) != 0) {
            int v26 = v25 | 4;
          }
          else {
            int v26 = v25;
          }
          unint64_t v27 = v4[8];
          if ((unint64_t)v13 >= v27)
          {
            std::error_code v33 = (char *)*v124;
            unint64_t v34 = 0xCCCCCCCCCCCCCCCDLL * ((v13 - (unsigned char *)*v124) >> 3);
            unint64_t v35 = v34 + 1;
            if (v34 + 1 > 0x666666666666666) {
              goto LABEL_179;
            }
            unint64_t v36 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v27 - (void)v33) >> 3);
            if (2 * v36 > v35) {
              unint64_t v35 = 2 * v36;
            }
            if (v36 >= 0x333333333333333) {
              unint64_t v37 = 0x666666666666666;
            }
            else {
              unint64_t v37 = v35;
            }
            if (v37 > 0x666666666666666) {
              goto LABEL_180;
            }
            uint64_t v38 = 5 * v37;
            int v39 = (char *)operator new(40 * v37);
            unsigned int v40 = &v39[40 * v34];
            *(void *)unsigned int v40 = 0;
            *((void *)v40 + 1) = 0;
            *((void *)v40 + 2) = v23;
            *((void *)v40 + 3) = v24;
            *((_DWORD *)v40 + 8) = v26;
            if (v13 != v33)
            {
              unint64_t v41 = &v39[40 * v34];
              uint64_t v12 = v123;
              do
              {
                long long v42 = *(_OWORD *)(v13 - 40);
                long long v43 = *(_OWORD *)(v13 - 24);
                int v44 = v41 - 40;
                *((_DWORD *)v41 - 2) = *((_DWORD *)v13 - 2);
                *(_OWORD *)(v41 - 24) = v43;
                *(_OWORD *)(v41 - 40) = v42;
                v13 -= 40;
                v41 -= 40;
              }
              while (v13 != v33);
              goto LABEL_82;
            }
            goto LABEL_81;
          }
          *(void *)unint64_t v13 = 0;
          *((void *)v13 + 1) = 0;
          goto LABEL_47;
        case 1:
          llvm::MachO::mapToPlatformSet(*(void *)(a3 + 96), *(unsigned int *)(a3 + 104), &v125);
          if (!v130)
          {
            v62 = v125;
            if (v126)
            {
              uint64_t v63 = 4 * v126;
              while (*v62 != 1)
              {
                ++v62;
                v63 -= 4;
                if (!v63) {
                  goto LABEL_102;
                }
              }
            }
            else
            {
LABEL_102:
              v62 = (char *)v125 + 4 * v126;
            }
            LODWORD(v62) = v62 != (_DWORD *)((char *)v125 + 4 * v126);
            v64 = v129;
            goto LABEL_113;
          }
          v64 = v129;
          if (!v129)
          {
            LODWORD(v62) = 0;
            goto LABEL_113;
          }
          v62 = v129;
          while (2)
          {
            int v65 = v62[7];
            if (v65 > 1) {
              goto LABEL_110;
            }
            if (v65 != 1)
            {
              v62 += 2;
LABEL_110:
              v62 = *(_DWORD **)v62;
              if (!v62) {
                goto LABEL_113;
              }
              continue;
            }
            break;
          }
          LODWORD(v62) = 1;
LABEL_113:
          if (a4) {
            int v66 = 0;
          }
          else {
            int v66 = (int)v62;
          }
          sub_1CB833A08((uint64_t)&v128, v64);
          if (v125 != &v127) {
            free(v125);
          }
          uint64_t v68 = *v15;
          uint64_t v67 = v15[1];
          if ((*((unsigned char *)v15 + 73) & 8) != 0) {
            int v69 = 3;
          }
          else {
            int v69 = 66;
          }
          if ((*((unsigned char *)v15 + 73) & 6) != 0) {
            int v70 = v69 | 4;
          }
          else {
            int v70 = v69;
          }
          unint64_t v72 = v4[7];
          unint64_t v71 = v4[8];
          if (v66)
          {
            if (v72 < v71)
            {
              *(void *)unint64_t v72 = ".objc_class_name_";
              *(void *)(v72 + 8) = 17;
              *(void *)(v72 + 16) = v68;
              *(void *)(v72 + 24) = v67;
              unint64_t v13 = (char *)(v72 + 40);
              *(_DWORD *)(v72 + 32) = v70;
              goto LABEL_87;
            }
            std::error_code v33 = (char *)*v124;
            unint64_t v74 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v72 - (void)*v124) >> 3);
            unint64_t v75 = v74 + 1;
            if (v74 + 1 > 0x666666666666666) {
              goto LABEL_179;
            }
            unint64_t v76 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v71 - (void)v33) >> 3);
            if (2 * v76 > v75) {
              unint64_t v75 = 2 * v76;
            }
            if (v76 >= 0x333333333333333) {
              unint64_t v77 = 0x666666666666666;
            }
            else {
              unint64_t v77 = v75;
            }
            if (v77 > 0x666666666666666) {
              goto LABEL_180;
            }
            uint64_t v78 = *v15;
            uint64_t v79 = v15[1];
            uint64_t v117 = 5 * v77;
            uint64_t v80 = (char *)operator new(40 * v77);
            uint64_t v81 = &v80[40 * v74];
            *(void *)uint64_t v81 = ".objc_class_name_";
            *((void *)v81 + 1) = 17;
            *((void *)v81 + 2) = v78;
            *((void *)v81 + 3) = v79;
            *((_DWORD *)v81 + 8) = v70;
            if ((char *)v72 == v33)
            {
              int v44 = &v80[40 * v74];
              uint64_t v12 = v123;
            }
            else
            {
              uint64_t v82 = &v80[40 * v74];
              uint64_t v12 = v123;
              do
              {
                long long v83 = *(_OWORD *)(v72 - 40);
                long long v84 = *(_OWORD *)(v72 - 24);
                int v44 = v82 - 40;
                *((_DWORD *)v82 - 2) = *(_DWORD *)(v72 - 8);
                *(_OWORD *)(v82 - 24) = v84;
                *(_OWORD *)(v82 - 40) = v83;
                v72 -= 40;
                v82 -= 40;
              }
              while ((char *)v72 != v33);
            }
            int v59 = &v80[8 * v117];
            unint64_t v13 = v81 + 40;
            goto LABEL_83;
          }
          if (v72 >= v71)
          {
            char v85 = *v124;
            unint64_t v86 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v72 - (void)*v124) >> 3);
            unint64_t v87 = v86 + 1;
            if (v86 + 1 > 0x666666666666666) {
              goto LABEL_179;
            }
            uint64_t v118 = v15[1];
            unint64_t v88 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v71 - (void)v85) >> 3);
            if (2 * v88 > v87) {
              unint64_t v87 = 2 * v88;
            }
            if (v88 >= 0x333333333333333) {
              unint64_t v89 = 0x666666666666666;
            }
            else {
              unint64_t v89 = v87;
            }
            if (v89 > 0x666666666666666) {
              goto LABEL_180;
            }
            uint64_t v90 = *v15;
            uint64_t v116 = 5 * v89;
            v91 = (char *)operator new(40 * v89);
            __int16 v92 = &v91[40 * v86];
            *(void *)__int16 v92 = "_OBJC_CLASS_$_";
            *((void *)v92 + 1) = 14;
            *((void *)v92 + 2) = v90;
            *((void *)v92 + 3) = v118;
            *((_DWORD *)v92 + 8) = v70;
            if ((void *)v72 == v85)
            {
              v96 = &v91[40 * v86];
              uint64_t v12 = v123;
            }
            else
            {
              long long v93 = &v91[40 * v86];
              uint64_t v12 = v123;
              do
              {
                long long v94 = *(_OWORD *)(v72 - 40);
                long long v95 = *(_OWORD *)(v72 - 24);
                v96 = v93 - 40;
                *((_DWORD *)v93 - 2) = *(_DWORD *)(v72 - 8);
                *(_OWORD *)(v93 - 24) = v95;
                *(_OWORD *)(v93 - 40) = v94;
                v72 -= 40;
                v93 -= 40;
              }
              while ((void *)v72 != v85);
            }
            uint64_t v73 = v92 + 40;
            v4[6] = v96;
            v4[7] = v92 + 40;
            v4[8] = &v91[8 * v116];
            if (v85) {
              operator delete(v85);
            }
          }
          else
          {
            *(void *)unint64_t v72 = "_OBJC_CLASS_$_";
            *(void *)(v72 + 8) = 14;
            *(void *)(v72 + 16) = v68;
            *(void *)(v72 + 24) = v67;
            uint64_t v73 = (char *)(v72 + 40);
            *(_DWORD *)(v72 + 32) = v70;
          }
          v4[7] = v73;
          uint64_t v98 = *v15;
          uint64_t v97 = v15[1];
          if ((*((unsigned char *)v15 + 73) & 8) != 0) {
            int v99 = 3;
          }
          else {
            int v99 = 66;
          }
          if ((*((unsigned char *)v15 + 73) & 6) != 0) {
            int v100 = v99 | 4;
          }
          else {
            int v100 = v99;
          }
          unint64_t v101 = v4[8];
          if ((unint64_t)v73 < v101)
          {
            *(void *)uint64_t v73 = "_OBJC_METACLASS_$_";
            *((void *)v73 + 1) = 18;
            *((void *)v73 + 2) = v98;
            *((void *)v73 + 3) = v97;
            unint64_t v13 = v73 + 40;
            *((_DWORD *)v73 + 8) = v100;
            int v14 = v122;
            goto LABEL_87;
          }
          v102 = (char *)*v124;
          unint64_t v103 = 0xCCCCCCCCCCCCCCCDLL * ((v73 - (unsigned char *)*v124) >> 3);
          unint64_t v104 = v103 + 1;
          if (v103 + 1 > 0x666666666666666) {
LABEL_179:
          }
            abort();
          unint64_t v105 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v101 - (void)v102) >> 3);
          if (2 * v105 > v104) {
            unint64_t v104 = 2 * v105;
          }
          if (v105 >= 0x333333333333333) {
            unint64_t v106 = 0x666666666666666;
          }
          else {
            unint64_t v106 = v104;
          }
          if (v106 > 0x666666666666666) {
LABEL_180:
          }
            sub_1CB833614();
          uint64_t v107 = 5 * v106;
          uint64_t v108 = (char *)operator new(40 * v106);
          v109 = &v108[40 * v103];
          *(void *)v109 = "_OBJC_METACLASS_$_";
          *((void *)v109 + 1) = 18;
          *((void *)v109 + 2) = v98;
          *((void *)v109 + 3) = v97;
          *((_DWORD *)v109 + 8) = v100;
          if (v73 == v102)
          {
            v113 = &v108[40 * v103];
            uint64_t v12 = v123;
          }
          else
          {
            uint64_t v110 = &v108[40 * v103];
            uint64_t v12 = v123;
            do
            {
              long long v111 = *(_OWORD *)(v73 - 40);
              long long v112 = *(_OWORD *)(v73 - 24);
              v113 = v110 - 40;
              *((_DWORD *)v110 - 2) = *((_DWORD *)v73 - 2);
              *(_OWORD *)(v110 - 24) = v112;
              *(_OWORD *)(v110 - 40) = v111;
              v73 -= 40;
              v110 -= 40;
            }
            while (v73 != v102);
          }
          v114 = &v108[8 * v107];
          unint64_t v13 = v109 + 40;
          unint64_t v4 = (void *)a1;
          *(void *)(a1 + 48) = v113;
          *(void *)(a1 + 56) = v109 + 40;
          *(void *)(a1 + 64) = v114;
          if (!v102) {
            goto LABEL_86;
          }
          BOOL v60 = v102;
          goto LABEL_85;
        case 2:
          uint64_t v23 = *v15;
          uint64_t v24 = v15[1];
          if ((*((unsigned char *)v15 + 73) & 8) != 0) {
            int v28 = 3;
          }
          else {
            int v28 = 66;
          }
          if ((*((unsigned char *)v15 + 73) & 6) != 0) {
            int v26 = v28 | 4;
          }
          else {
            int v26 = v28;
          }
          unint64_t v29 = v4[8];
          if ((unint64_t)v13 >= v29)
          {
            std::error_code v33 = (char *)*v124;
            unint64_t v45 = 0xCCCCCCCCCCCCCCCDLL * ((v13 - (unsigned char *)*v124) >> 3);
            unint64_t v46 = v45 + 1;
            if (v45 + 1 > 0x666666666666666) {
              goto LABEL_179;
            }
            unint64_t v47 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v29 - (void)v33) >> 3);
            if (2 * v47 > v46) {
              unint64_t v46 = 2 * v47;
            }
            if (v47 >= 0x333333333333333) {
              unint64_t v48 = 0x666666666666666;
            }
            else {
              unint64_t v48 = v46;
            }
            if (v48 > 0x666666666666666) {
              goto LABEL_180;
            }
            uint64_t v38 = 5 * v48;
            int v39 = (char *)operator new(40 * v48);
            unsigned int v40 = &v39[40 * v45];
            *(void *)unsigned int v40 = "_OBJC_EHTYPE_$_";
            *((void *)v40 + 1) = 15;
            *((void *)v40 + 2) = v23;
            *((void *)v40 + 3) = v24;
            *((_DWORD *)v40 + 8) = v26;
            if (v13 != v33)
            {
              uint64_t v49 = &v39[40 * v45];
              uint64_t v12 = v123;
              do
              {
                long long v50 = *(_OWORD *)(v13 - 40);
                long long v51 = *(_OWORD *)(v13 - 24);
                int v44 = v49 - 40;
                *((_DWORD *)v49 - 2) = *((_DWORD *)v13 - 2);
                *(_OWORD *)(v49 - 24) = v51;
                *(_OWORD *)(v49 - 40) = v50;
                v13 -= 40;
                v49 -= 40;
              }
              while (v13 != v33);
              goto LABEL_82;
            }
            goto LABEL_81;
          }
          *(void *)unint64_t v13 = "_OBJC_EHTYPE_$_";
          uint64_t v30 = 15;
          break;
        case 3:
          uint64_t v23 = *v15;
          uint64_t v24 = v15[1];
          if ((*((unsigned char *)v15 + 73) & 8) != 0) {
            int v31 = 3;
          }
          else {
            int v31 = 66;
          }
          if ((*((unsigned char *)v15 + 73) & 6) != 0) {
            int v26 = v31 | 4;
          }
          else {
            int v26 = v31;
          }
          unint64_t v32 = v4[8];
          if ((unint64_t)v13 >= v32)
          {
            std::error_code v33 = (char *)*v124;
            unint64_t v52 = 0xCCCCCCCCCCCCCCCDLL * ((v13 - (unsigned char *)*v124) >> 3);
            unint64_t v53 = v52 + 1;
            if (v52 + 1 > 0x666666666666666) {
              goto LABEL_179;
            }
            unint64_t v54 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v32 - (void)v33) >> 3);
            if (2 * v54 > v53) {
              unint64_t v53 = 2 * v54;
            }
            if (v54 >= 0x333333333333333) {
              unint64_t v55 = 0x666666666666666;
            }
            else {
              unint64_t v55 = v53;
            }
            if (v55 > 0x666666666666666) {
              goto LABEL_180;
            }
            uint64_t v38 = 5 * v55;
            int v39 = (char *)operator new(40 * v55);
            unsigned int v40 = &v39[40 * v52];
            *(void *)unsigned int v40 = "_OBJC_IVAR_$_";
            *((void *)v40 + 1) = 13;
            *((void *)v40 + 2) = v23;
            *((void *)v40 + 3) = v24;
            *((_DWORD *)v40 + 8) = v26;
            if (v13 != v33)
            {
              v56 = &v39[40 * v52];
              uint64_t v12 = v123;
              do
              {
                long long v57 = *(_OWORD *)(v13 - 40);
                long long v58 = *(_OWORD *)(v13 - 24);
                int v44 = v56 - 40;
                *((_DWORD *)v56 - 2) = *((_DWORD *)v13 - 2);
                *(_OWORD *)(v56 - 24) = v58;
                *(_OWORD *)(v56 - 40) = v57;
                v13 -= 40;
                v56 -= 40;
              }
              while (v13 != v33);
LABEL_82:
              int v59 = &v39[8 * v38];
              unint64_t v13 = v40 + 40;
              unint64_t v4 = (void *)a1;
LABEL_83:
              v4[6] = v44;
              v4[7] = v13;
              v4[8] = v59;
              if (v33)
              {
                BOOL v60 = v33;
LABEL_85:
                operator delete(v60);
              }
LABEL_86:
              int v14 = v122;
              goto LABEL_87;
            }
LABEL_81:
            int v44 = v40;
            uint64_t v12 = v123;
            goto LABEL_82;
          }
          *(void *)unint64_t v13 = "_OBJC_IVAR_$_";
          uint64_t v30 = 13;
          break;
        default:
          goto LABEL_88;
      }
      *((void *)v13 + 1) = v30;
LABEL_47:
      *((void *)v13 + 2) = v23;
      *((void *)v13 + 3) = v24;
      *((_DWORD *)v13 + 8) = v26;
      v13 += 40;
LABEL_87:
      v4[7] = v13;
LABEL_88:
      uint64_t v61 = v11 + 32;
      uint64_t v11 = v9;
      if (v61 != v9)
      {
        uint64_t v11 = v61;
        while ((*(unsigned char *)v11 == 3 || !*(unsigned char *)v11) && !*(void *)(v11 + 16))
        {
          v11 += 32;
          if (v11 == v9)
          {
            uint64_t v11 = v9;
            break;
          }
        }
      }
    }
    while (v11 != v12);
  }
  return v4;
}

void llvm::object::TapiFile::~TapiFile(llvm::object::TapiFile *this)
{
  *(void *)this = &unk_1F2634230;
  unsigned int v2 = (void *)*((void *)this + 6);
  if (v2)
  {
    *((void *)this + 7) = v2;
    operator delete(v2);
  }
}

{
  void *v2;

  *(void *)this = &unk_1F2634230;
  unsigned int v2 = (void *)*((void *)this + 6);
  if (v2)
  {
    *((void *)this + 7) = v2;
    operator delete(v2);
  }
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1F2634230;
  unsigned int v2 = (void *)*((void *)this + 6);
  if (v2)
  {
    *((void *)this + 7) = v2;
    operator delete(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

void llvm::object::TapiFile::moveSymbolNext(uint64_t a1, _DWORD *a2)
{
}

void *llvm::object::TapiFile::printSymbolName@<X0>(llvm::raw_ostream *this@<X1>, uint64_t a2@<X0>, unsigned int a3@<W2>, void *a4@<X8>)
{
  uint64_t v7 = *(void *)(a2 + 48);
  uint64_t v8 = v7 + 40 * a3;
  uint64_t v9 = *(const void **)v8;
  size_t v10 = *(void *)(v8 + 8);
  BOOL result = (void *)*((void *)this + 4);
  if (v10 <= *((void *)this + 3) - (void)result)
  {
    if (v10)
    {
      memcpy(result, v9, v10);
      BOOL result = (void *)(*((void *)this + 4) + v10);
      *((void *)this + 4) = result;
    }
  }
  else
  {
    this = llvm::raw_ostream::write(this, (const char *)v9, v10);
    BOOL result = (void *)*((void *)this + 4);
  }
  uint64_t v12 = v7 + 40 * a3;
  unint64_t v13 = *(const void **)(v12 + 16);
  size_t v14 = *(void *)(v12 + 24);
  if (v14 <= *((void *)this + 3) - (void)result)
  {
    if (v14)
    {
      BOOL result = memcpy(result, v13, v14);
      *((void *)this + 4) += v14;
    }
  }
  else
  {
    BOOL result = llvm::raw_ostream::write(this, (const char *)v13, v14);
  }
  *a4 = 0;
  return result;
}

uint64_t llvm::object::TapiFile::getSymbolFlags@<X0>(uint64_t result@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v3 = *(void *)(result + 48) + 40 * a2;
  *(unsigned char *)(a3 + 8) &= ~1u;
  *(_DWORD *)a3 = *(_DWORD *)(v3 + 32);
  return result;
}

uint64_t llvm::object::TapiFile::symbol_begin(llvm::object::TapiFile *this)
{
  return 0;
}

uint64_t llvm::object::TapiFile::symbol_end(llvm::object::TapiFile *this)
{
  return -858993459 * ((*((void *)this + 7) - *((void *)this + 6)) >> 3);
}

void llvm::object::TapiUniversal::ObjectForArch::getAsObjectFile(llvm::object::TapiUniversal::ObjectForArch *this)
{
}

char *sub_1CCC801D0(void **a1, uint64_t a2)
{
  uint64_t v3 = (char *)*a1;
  unsigned int v2 = (char *)a1[1];
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((v2 - (unsigned char *)*a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * (((unsigned char *)a1[2] - v3) >> 3) > v5) {
    unint64_t v5 = 0x5555555555555556 * (((unsigned char *)a1[2] - v3) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[2] - v3) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v5;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      sub_1CB833614();
    }
    uint64_t v9 = (char *)operator new(24 * v8);
  }
  else
  {
    uint64_t v9 = 0;
  }
  size_t v10 = &v9[24 * v4];
  *(_OWORD *)size_t v10 = *(_OWORD *)a2;
  *((void *)v10 + 2) = *(void *)(a2 + 16);
  uint64_t v11 = v10 + 24;
  if (v2 != v3)
  {
    do
    {
      long long v12 = *(_OWORD *)(v2 - 24);
      *(v10 - 8) = *(v2 - 8);
      *(_OWORD *)(v10 - 24) = v12;
      v10 -= 24;
      v2 -= 24;
    }
    while (v2 != v3);
    unsigned int v2 = (char *)*a1;
  }
  *a1 = v10;
  a1[1] = v11;
  a1[2] = &v9[24 * v8];
  if (v2) {
    operator delete(v2);
  }
  return v11;
}

void sub_1CCC802EC(uint64_t a1, char *a2)
{
  unint64_t v4 = *(char **)(a1 + 8);
  if (v4 != a2)
  {
    unint64_t v5 = v4 - 40;
    do
    {
      long long v6 = (char *)*((void *)v5 - 2);
      if (v5 != v6) {
        free(v6);
      }
      if (*(v5 - 17) < 0) {
        operator delete(*((void **)v5 - 5));
      }
      uint64_t v7 = v5 - 40;
      v5 -= 80;
    }
    while (v7 != a2);
  }
  *(void *)(a1 + 8) = a2;
}

__n128 llvm::object::Slice::Slice(__n128 *a1, unint64_t a2, unsigned __int32 a3, unsigned __int32 a4, __n128 *a5, unsigned __int32 a6)
{
  a1->n128_u64[0] = a2;
  a1->n128_u32[2] = a3;
  a1->n128_u32[3] = a4;
  __n128 result = *a5;
  a1[2].n128_u64[0] = a5[1].n128_u64[0];
  a1[1] = result;
  a5->n128_u64[1] = 0;
  a5[1].n128_u64[0] = 0;
  a5->n128_u64[0] = 0;
  a1[2].n128_u32[2] = a6;
  return result;
}

{
  __n128 result;

  a1->n128_u64[0] = a2;
  a1->n128_u32[2] = a3;
  a1->n128_u32[3] = a4;
  __n128 result = *a5;
  a1[2].n128_u64[0] = a5[1].n128_u64[0];
  a1[1] = result;
  a5->n128_u64[1] = 0;
  a5[1].n128_u64[0] = 0;
  a5->n128_u64[0] = 0;
  a1[2].n128_u32[2] = a6;
  return result;
}

{
  __n128 result;

  a1->n128_u64[0] = a2;
  a1->n128_u32[2] = a3;
  a1->n128_u32[3] = a4;
  __n128 result = *a5;
  a1[2].n128_u64[0] = a5[1].n128_u64[0];
  a1[1] = result;
  a5->n128_u64[1] = 0;
  a5[1].n128_u64[0] = 0;
  a5->n128_u64[0] = 0;
  a1[2].n128_u32[2] = a6;
  return result;
}

{
  __n128 result;

  a1->n128_u64[0] = a2;
  a1->n128_u32[2] = a3;
  a1->n128_u32[3] = a4;
  __n128 result = *a5;
  a1[2].n128_u64[0] = a5[1].n128_u64[0];
  a1[1] = result;
  a5->n128_u64[1] = 0;
  a5[1].n128_u64[0] = 0;
  a5->n128_u64[0] = 0;
  a1[2].n128_u32[2] = a6;
  return result;
}

{
  __n128 result;

  a1->n128_u64[0] = a2;
  a1->n128_u32[2] = a3;
  a1->n128_u32[3] = a4;
  __n128 result = *a5;
  a1[2].n128_u64[0] = a5[1].n128_u64[0];
  a1[1] = result;
  a5->n128_u64[1] = 0;
  a5[1].n128_u64[0] = 0;
  a5->n128_u64[0] = 0;
  a1[2].n128_u32[2] = a6;
  return result;
}

{
  __n128 result;

  a1->n128_u64[0] = a2;
  a1->n128_u32[2] = a3;
  a1->n128_u32[3] = a4;
  __n128 result = *a5;
  a1[2].n128_u64[0] = a5[1].n128_u64[0];
  a1[1] = result;
  a5->n128_u64[1] = 0;
  a5[1].n128_u64[0] = 0;
  a5->n128_u64[0] = 0;
  a1[2].n128_u32[2] = a6;
  return result;
}

llvm::object::Slice *llvm::object::Slice::Slice(llvm::object::Slice *this, const llvm::object::MachOObjectFile *a2, int a3)
{
  *(void *)this = a2;
  *((void *)this + 1) = *(void *)((char *)a2 + 52);
  llvm::object::MachOObjectFile::getArchTriple((llvm::Triple *)*((unsigned int *)a2 + 13), 0, *((_DWORD *)a2 + 14), 0, (llvm::Triple *)__p);
  ArchName = llvm::Triple::getArchName((llvm::Triple *)__p);
  if (v6 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  uint64_t v7 = ArchName;
  size_t v8 = v6;
  if (v6 >= 0x17)
  {
    uint64_t v10 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17) {
      uint64_t v10 = v6 | 7;
    }
    uint64_t v11 = v10 + 1;
    uint64_t v9 = (char *)operator new(v10 + 1);
    *((void *)this + 3) = v8;
    *((void *)this + 4) = v11 | 0x8000000000000000;
    *((void *)this + 2) = v9;
    goto LABEL_8;
  }
  uint64_t v9 = (char *)this + 16;
  *((unsigned char *)this + 39) = v6;
  if (v6) {
LABEL_8:
  }
    memmove(v9, v7, v8);
  v9[v8] = 0;
  if (v14 < 0) {
    operator delete(__p[0]);
  }
  *((_DWORD *)this + 10) = a3;
  return this;
}

llvm::object::Slice *llvm::object::Slice::Slice(llvm::object::Slice *this, const llvm::object::MachOObjectFile *a2)
{
  int v4 = sub_1CCC80538((uint64_t)a2);

  return llvm::object::Slice::Slice(this, a2, v4);
}

{
  int v4;
  uint64_t vars8;

  int v4 = sub_1CCC80538((uint64_t)a2);

  return llvm::object::Slice::Slice(this, a2, v4);
}

uint64_t sub_1CCC80538(uint64_t a1)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  int v2 = *(_DWORD *)(a1 + 52);
  uint64_t result = 12;
  if (v2 <= 16777222)
  {
    switch(v2)
    {
      case 7:
        return result;
      case 12:
        return 14;
      case 18:
        return result;
    }
  }
  else
  {
    if (v2 > 16777233)
    {
      if (v2 == 16777234) {
        return result;
      }
      int v4 = 33554444;
    }
    else
    {
      if (v2 == 16777223) {
        return result;
      }
      int v4 = 16777228;
    }
    if (v2 == v4) {
      return 14;
    }
  }
  uint64_t v5 = *(unsigned int *)(a1 + 136);
  if (v5)
  {
    uint64_t v6 = *(void *)(a1 + 128);
    uint64_t v7 = v6 + 16 * v5;
    unsigned int v8 = *(_DWORD *)(a1 + 8) & 0xFFFFFFFE;
    if (v8 == 18) {
      int v9 = 25;
    }
    else {
      int v9 = 1;
    }
    unsigned int v10 = 15;
    uint64_t v24 = v6 + 16 * v5;
    int v23 = v9;
    do
    {
      if (*(_DWORD *)(v6 + 8) == v9)
      {
        unsigned int v25 = v10;
        if (*(_DWORD *)(a1 + 60) == 1)
        {
          if (v8 == 18)
          {
            llvm::object::MachOObjectFile::getSegment64LoadCommand(a1, (unint64_t *)v6, (uint64_t)v28);
            int v11 = v31[3];
          }
          else
          {
            llvm::object::MachOObjectFile::getSegmentLoadCommand(a1, (unint64_t *)v6, (uint64_t)v28);
            int v11 = v30;
          }
          unsigned int v13 = v10;
          if (v11)
          {
            int v14 = 0;
            unsigned int v13 = 2;
            do
            {
              unsigned int v15 = *(_DWORD *)(a1 + 8) & 0xFFFFFFFE;
              BOOL v16 = v15 == 18;
              if (v15 == 18) {
                int v17 = 80;
              }
              else {
                int v17 = 68;
              }
              if (v16) {
                uint64_t v18 = 72;
              }
              else {
                uint64_t v18 = 56;
              }
              uint64_t v19 = (_OWORD *)(v18 + *(void *)v6 + (v17 * v14));
              if (v8 == 18)
              {
                sub_1CCC64584(a1, v19, (uint64_t)v28);
                int v20 = v31;
              }
              else
              {
                sub_1CCC644F0(a1, (unint64_t)v19, (uint64_t)v26);
                int v20 = (unsigned int *)&v27;
              }
              unsigned int v21 = *v20;
              if (v13 <= v21) {
                unsigned int v13 = v21;
              }
              ++v14;
            }
            while (v11 != v14);
          }
        }
        else
        {
          if (v8 == 18)
          {
            llvm::object::MachOObjectFile::getSegment64LoadCommand(a1, (unint64_t *)v6, (uint64_t)v28);
            unint64_t v12 = v29;
          }
          else
          {
            llvm::object::MachOObjectFile::getSegmentLoadCommand(a1, (unint64_t *)v6, (uint64_t)v28);
            unint64_t v12 = v29;
          }
          unsigned int v13 = __clz(__rbit64(v12));
        }
        if (v13 >= v25) {
          unsigned int v10 = v25;
        }
        else {
          unsigned int v10 = v13;
        }
        uint64_t v7 = v24;
        int v9 = v23;
      }
      v6 += 16;
    }
    while (v6 != v7);
  }
  else
  {
    unsigned int v10 = 15;
  }
  if (v10 >= 0xF) {
    unsigned int v22 = 15;
  }
  else {
    unsigned int v22 = v10;
  }
  if (v22 <= 2) {
    return 2;
  }
  else {
    return v22;
  }
}

uint64_t llvm::object::Slice::create@<X0>(llvm::object::Slice *this@<X0>, const llvm::object::Archive *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v186 = *MEMORY[0x1E4F143B8];
  v170[0] = 0;
  sub_1CD5DF400((uint64_t)this, v170, 1, (uint64_t)&v179);
  sub_1CD5E0680((uint64_t)&v164, (uint64_t)&v179);
  unint64_t v169 = v182;
  sub_1CD5E0680((uint64_t)&v160, (uint64_t)v183);
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  unint64_t v163 = v185;
  if (v169 <= 7 && v185 < 8)
  {
LABEL_127:
    uint64_t v87 = v161;
    uint64_t v161 = 0;
    if (v87) {
      (*(void (**)(uint64_t))(*(void *)v87 + 16))(v87);
    }
    uint64_t v88 = v165;
    uint64_t v165 = 0;
    if (v88) {
      (*(void (**)(uint64_t))(*(void *)v88 + 16))(v88);
    }
    uint64_t v89 = v184;
    uint64_t v184 = 0;
    if (v89) {
      (*(void (**)(uint64_t))(*(void *)v89 + 16))(v89);
    }
    uint64_t v90 = *((void *)&v179 + 1);
    *((void *)&v179 + 1) = 0;
    if (v90) {
      (*(void (**)(uint64_t))(*(void *)v90 + 16))(v90);
    }
    v91 = (const char *)v170[0];
    if (v170[0])
    {
      uint64_t v92 = *((void *)this + 4);
      uint64_t v93 = *((void *)this + 5);
      LOWORD(v181) = 261;
      *(void *)&long long v179 = v92;
      *((void *)&v179 + 1) = v93;
      v170[0] = 0;
      v164 = v91;
      sub_1CC226C78((uint64_t)&v179, 0, 0, (uint64_t *)&v164);
    }
    if (!(v8 | v7))
    {
      uint64_t v101 = *((void *)this + 4);
      uint64_t v102 = *((void *)this + 5);
      __int16 v168 = 1283;
      v164 = "empty archive with no architecture specification: ";
      uint64_t v166 = v101;
      uint64_t v167 = v102;
      *(void *)&long long v179 = &v164;
      *(void *)&long long v180 = " (can't determine architecture for it)";
      LOWORD(v181) = 770;
      unint64_t v103 = &v160;
      llvm::Twine::str((llvm::Twine *)&v179, &v160);
      if (v162 < 0) {
        unint64_t v103 = v160;
      }
      uint64_t __dst = 22;
      v157 = std::generic_category();
      v151 = v103;
      sub_1CD06481C();
    }
    if (v8)
    {
      if ((*(_DWORD *)(v8 + 8) & 0xFFFFFFFE) == 0x12) {
        int v99 = 3;
      }
      else {
        int v99 = 2;
      }
      llvm::object::Slice::Slice((llvm::object::Slice *)&v179, (const llvm::object::MachOObjectFile *)v8, v99);
      *(void *)&long long v179 = this;
      *(unsigned char *)(a3 + 48) &= ~1u;
      long long v100 = v180;
      *(_OWORD *)a3 = v179;
      *(_OWORD *)(a3 + 16) = v100;
      *(void *)(a3 + 32) = v181;
      *(_DWORD *)(a3 + 40) = v182;
    }
    else
    {
      llvm::object::Slice::create((llvm::object::Slice *)v7, 0, (uint64_t)&v179);
      if (v183[0])
      {
        unint64_t v106 = (const char *)*((void *)this + 4);
        uint64_t v107 = *((void *)this + 5);
        __int16 v168 = 261;
        v164 = v106;
        uint64_t v165 = v107;
        v160 = (void *)v179;
        sub_1CC226C78((uint64_t)&v164, 0, 0, (uint64_t *)&v160);
      }
      uint64_t v104 = v181;
      *(void *)&long long v179 = this;
      *(unsigned char *)(a3 + 48) &= ~1u;
      long long v105 = v180;
      *(_OWORD *)a3 = v179;
      *(_OWORD *)(a3 + 16) = v105;
      *(void *)(a3 + 32) = v104;
      long long v180 = 0uLL;
      uint64_t v181 = 0;
      *(_DWORD *)(a3 + 40) = v182;
      uint64_t v8 = 0;
    }
    goto LABEL_145;
  }
  uint64_t v8 = 0;
  uint64_t v7 = 0;
  while (1)
  {
    if (v166 == v162) {
      goto LABEL_127;
    }
    llvm::object::Archive::Child::getAsBinary((llvm::object::Archive::Child *)&v164, a2, (uint64_t)&v177);
    if (v178)
    {
      uint64_t v15 = *((void *)this + 4);
      BOOL v16 = (const std::error_category *)*((void *)this + 5);
      __int16 v159 = 261;
      uint64_t __dst = v15;
      v157 = v16;
      int v17 = (void *)v177;
      uint64_t v177 = 0;
      v151 = v17;
      sub_1CC226C78((uint64_t)&__dst, 0, 0, (uint64_t *)&v151);
    }
    uint64_t v10 = v177;
    int v11 = *(_DWORD *)(v177 + 8);
    if (v11 == 1)
    {
      unint64_t v12 = *(const char **)(v177 + 32);
      uint64_t v13 = *(void *)(v177 + 40);
      __int16 v155 = 1283;
      v151 = "archive member ";
      v153 = v12;
      uint64_t v154 = v13;
      uint64_t __dst = (uint64_t)&v151;
      *(void *)&long long v158 = " is a fat file (not allowed in an archive)";
      __int16 v159 = 770;
      llvm::Twine::str((llvm::Twine *)&__dst, v146);
      if (v147 >= 0) {
        int v14 = v146;
      }
      else {
        int v14 = (void **)v146[0];
      }
      uint64_t v142 = 22;
      v143 = std::generic_category();
      v139[0] = v14;
      sub_1CD06481C();
    }
    if ((v11 & 0xFFFFFFFC) == 0x10)
    {
      if (!v7)
      {
        if (!v8)
        {
          uint64_t v7 = 0;
          uint64_t v177 = 0;
          int v50 = 1;
          uint64_t v8 = v10;
          goto LABEL_62;
        }
        uint64_t v19 = *(unsigned int *)(v8 + 52);
        uint64_t v18 = *(unsigned int *)(v8 + 56);
        uint64_t v21 = *(unsigned int *)(v177 + 52);
        uint64_t v20 = *(unsigned int *)(v177 + 56);
        if (v19 != v21 || v18 != v20)
        {
          uint64_t v23 = *(void *)(v177 + 32);
          uint64_t v24 = *(void *)(v177 + 40);
          __int16 v123 = 1283;
          v120[0] = "archive member ";
          uint64_t v121 = v23;
          uint64_t v122 = v24;
          v124[0] = v120;
          v125 = " cputype (";
          __int16 v126 = 770;
          v127[0] = v124;
          unint64_t v128 = v116 & 0xFFFFFFFF00000000 | v21;
          __int16 v129 = 2050;
          v130[0] = v127;
          uint64_t v131 = ") and cpusubtype(";
          __int16 v132 = 770;
          v133[0] = v130;
          unint64_t v134 = v117 & 0xFFFFFFFF00000000 | v20;
          __int16 v135 = 2050;
          v136[0] = v133;
          v137 = ") does not match previous archive members cputype (";
          __int16 v138 = 770;
          v139[0] = v136;
          unint64_t v140 = v118 & 0xFFFFFFFF00000000 | v19;
          __int16 v141 = 2050;
          uint64_t v142 = (uint64_t)v139;
          v144 = ") and cpusubtype(";
          __int16 v145 = 770;
          v146[0] = &v142;
          int64_t v147 = v119 & 0xFFFFFFFF00000000 | v18;
          __int16 v148 = 2050;
          v151 = v146;
          v153 = ") (all members must match) ";
          __int16 v155 = 770;
          uint64_t __dst = (uint64_t)&v151;
          long long v158 = *(_OWORD *)(v8 + 32);
          __int16 v159 = 1282;
          llvm::Twine::str((llvm::Twine *)&__dst, __p);
          if (v150 >= 0) {
            unsigned int v25 = __p;
          }
          else {
            unsigned int v25 = (void **)__p[0];
          }
          int v26 = std::generic_category();
          uint64_t v171 = 22;
          v172 = v26;
          v175 = v25;
          sub_1CD06481C();
        }
        uint64_t v7 = 0;
        goto LABEL_51;
      }
      unint64_t v53 = *(const void **)(v177 + 32);
      if (!v53)
      {
        v157 = 0;
        uint64_t __dst = 0;
        p_dst = &__dst;
        *(void *)&long long v158 = 0;
        goto LABEL_93;
      }
      size_t v61 = *(void *)(v177 + 40);
      if (v61 > 0x7FFFFFFFFFFFFFF7) {
        goto LABEL_164;
      }
      if (v61 >= 0x17)
      {
        uint64_t v65 = (v61 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v61 | 7) != 0x17) {
          uint64_t v65 = v61 | 7;
        }
        uint64_t v108 = v65 + 1;
        int v66 = *(const void **)(v177 + 32);
        uint64_t v67 = (uint64_t *)operator new(v65 + 1);
        unint64_t v53 = v66;
        v62 = v67;
        *(void *)&long long v158 = v108 | 0x8000000000000000;
        uint64_t __dst = (uint64_t)v67;
        v157 = (const std::error_category *)v61;
      }
      else
      {
        BYTE7(v158) = *(void *)(v177 + 40);
        v62 = &__dst;
        if (!v61)
        {
LABEL_91:
          *((unsigned char *)v62 + v61) = 0;
          p_dst = &__dst;
          if (SBYTE7(v158) < 0) {
            p_dst = (uint64_t *)__dst;
          }
LABEL_93:
          v146[0] = p_dst;
          uint64_t v68 = *(const void **)(v7 + 32);
          if (!v68)
          {
            size_t v152 = 0;
            v151 = 0;
            int v69 = &v151;
            v153 = 0;
            goto LABEL_106;
          }
          size_t v70 = *(void *)(v7 + 40);
          if (v70 > 0x7FFFFFFFFFFFFFF7) {
            goto LABEL_164;
          }
          if (v70 >= 0x17)
          {
            uint64_t v72 = (v70 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v70 | 7) != 0x17) {
              uint64_t v72 = v70 | 7;
            }
            uint64_t v109 = v72 + 1;
            uint64_t v73 = *(const void **)(v7 + 32);
            unint64_t v74 = (void **)operator new(v72 + 1);
            uint64_t v68 = v73;
            unint64_t v71 = v74;
            v153 = (const char *)(v109 | 0x8000000000000000);
            v151 = v74;
            size_t v152 = v70;
          }
          else
          {
            HIBYTE(v153) = *(void *)(v7 + 40);
            unint64_t v71 = &v151;
            if (!v70)
            {
LABEL_103:
              *((unsigned char *)v71 + v70) = 0;
              if (SHIBYTE(v153) >= 0) {
                int v69 = &v151;
              }
              else {
                int v69 = v151;
              }
LABEL_106:
              uint64_t v142 = (uint64_t)v69;
              unint64_t v75 = std::generic_category();
              sub_1CD4F664C(22, (uint64_t)v75, (uint64_t)"archive member %s is a MachO, while previous archive member %s was an IR LLVM object", (uint64_t *)v146, &v142);
            }
          }
          memmove(v71, v68, v70);
          goto LABEL_103;
        }
      }
      memmove(v62, v53, v61);
      goto LABEL_91;
    }
    if (v11 != 3)
    {
      unint64_t v47 = *(const char **)(v177 + 32);
      uint64_t v48 = *(void *)(v177 + 40);
      __int16 v155 = 1283;
      v151 = "archive member ";
      v153 = v47;
      uint64_t v154 = v48;
      uint64_t __dst = (uint64_t)&v151;
      *(void *)&long long v158 = " is neither a MachO file or an LLVM IR file (not allowed in an archive)";
      __int16 v159 = 770;
      llvm::Twine::str((llvm::Twine *)&__dst, v146);
      if (v147 >= 0) {
        uint64_t v49 = v146;
      }
      else {
        uint64_t v49 = (void **)v146[0];
      }
      uint64_t v142 = 22;
      v143 = std::generic_category();
      v139[0] = v49;
      sub_1CD06481C();
    }
    if (v8)
    {
      int v59 = *(const void **)(v177 + 32);
      if (!v59)
      {
        v157 = 0;
        uint64_t __dst = 0;
        BOOL v60 = &__dst;
        *(void *)&long long v158 = 0;
        goto LABEL_113;
      }
      size_t v63 = *(void *)(v177 + 40);
      if (v63 > 0x7FFFFFFFFFFFFFF7) {
        goto LABEL_164;
      }
      if (v63 >= 0x17)
      {
        uint64_t v76 = (v63 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v63 | 7) != 0x17) {
          uint64_t v76 = v63 | 7;
        }
        uint64_t v110 = v76 + 1;
        unint64_t v77 = *(const void **)(v177 + 32);
        uint64_t v78 = (uint64_t *)operator new(v76 + 1);
        int v59 = v77;
        v64 = v78;
        *(void *)&long long v158 = v110 | 0x8000000000000000;
        uint64_t __dst = (uint64_t)v78;
        v157 = (const std::error_category *)v63;
      }
      else
      {
        BYTE7(v158) = *(void *)(v177 + 40);
        v64 = &__dst;
        if (!v63)
        {
LABEL_111:
          *((unsigned char *)v64 + v63) = 0;
          BOOL v60 = &__dst;
          if (SBYTE7(v158) < 0) {
            BOOL v60 = (uint64_t *)__dst;
          }
LABEL_113:
          v146[0] = v60;
          uint64_t v79 = *(const void **)(v8 + 32);
          if (!v79)
          {
            size_t v152 = 0;
            v151 = 0;
            uint64_t v80 = &v151;
            v153 = 0;
            goto LABEL_126;
          }
          size_t v81 = *(void *)(v8 + 40);
          if (v81 <= 0x7FFFFFFFFFFFFFF7)
          {
            if (v81 >= 0x17)
            {
              uint64_t v83 = (v81 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v81 | 7) != 0x17) {
                uint64_t v83 = v81 | 7;
              }
              uint64_t v111 = v83 + 1;
              long long v84 = *(const void **)(v8 + 32);
              char v85 = (void **)operator new(v83 + 1);
              uint64_t v79 = v84;
              uint64_t v82 = v85;
              v153 = (const char *)(v111 | 0x8000000000000000);
              v151 = v85;
              size_t v152 = v81;
            }
            else
            {
              HIBYTE(v153) = *(void *)(v8 + 40);
              uint64_t v82 = &v151;
              if (!v81)
              {
LABEL_123:
                *((unsigned char *)v82 + v81) = 0;
                if (SHIBYTE(v153) >= 0) {
                  uint64_t v80 = &v151;
                }
                else {
                  uint64_t v80 = v151;
                }
LABEL_126:
                uint64_t v142 = (uint64_t)v80;
                unint64_t v86 = std::generic_category();
                sub_1CD4F664C(22, (uint64_t)v86, (uint64_t)"archive member '%s' is an LLVM IR object, while previous archive member '%s' was a MachO", (uint64_t *)v146, &v142);
              }
            }
            memmove(v82, v79, v81);
            goto LABEL_123;
          }
LABEL_164:
          abort();
        }
      }
      memmove(v64, v59, v63);
      goto LABEL_111;
    }
    if (v7)
    {
      uint64_t v27 = **(void **)(v177 + 48);
      uint64_t v30 = *(void *)(v27 + 216);
      uint64_t v28 = v27 + 216;
      uint64_t v29 = v30;
      char v31 = *(unsigned char *)(v28 + 23);
      uint64_t v32 = v31 >= 0 ? v28 : v29;
      uint64_t v33 = *(void *)(v28 + 8);
      uint64_t v34 = v31 >= 0 ? v31 & 0x7F : v33;
      sub_1CCC8182C((uint64_t)&v175, v32, v34);
      uint64_t v35 = **(void **)(v7 + 48);
      uint64_t v38 = *(void *)(v35 + 216);
      uint64_t v36 = v35 + 216;
      uint64_t v37 = v38;
      char v39 = *(unsigned char *)(v36 + 23);
      uint64_t v40 = v39 >= 0 ? v36 : v37;
      uint64_t v41 = *(void *)(v36 + 8);
      uint64_t v42 = v39 >= 0 ? v39 & 0x7F : v41;
      sub_1CCC8182C((uint64_t)&v173, v40, v42);
      if (v176)
      {
        long long v51 = v175;
        v175 = 0;
        *(unsigned char *)(a3 + 48) |= 1u;
        *(void *)a3 = v51;
        uint64_t v43 = v112;
        uint64_t v44 = v113;
        uint64_t v45 = v115;
        uint64_t v46 = v114;
      }
      else
      {
        uint64_t v43 = v112;
        uint64_t v44 = v113;
        uint64_t v46 = v114;
        uint64_t v45 = v115;
        if ((v174 & 1) == 0)
        {
          if (v175 != v173)
          {
            uint64_t v55 = *(void *)(v10 + 32);
            uint64_t v56 = *(void *)(v10 + 40);
            __int16 v123 = 1283;
            v120[0] = "archive member ";
            uint64_t v121 = v55;
            uint64_t v122 = v56;
            v124[0] = v120;
            v125 = " cputype (";
            __int16 v126 = 770;
            v127[0] = v124;
            unint64_t v128 = v114 & 0xFFFFFFFF00000000 | v175;
            __int16 v129 = 2050;
            v130[0] = v127;
            uint64_t v131 = ") and cpusubtype(";
            __int16 v132 = 770;
            v133[0] = v130;
            unint64_t v134 = v115 & 0xFFFFFFFF00000000 | HIDWORD(v175);
            __int16 v135 = 2050;
            v136[0] = v133;
            v137 = ") does not match previous archive members cputype (";
            __int16 v138 = 770;
            v139[0] = v136;
            unint64_t v140 = v113 & 0xFFFFFFFF00000000 | v173;
            __int16 v141 = 2050;
            uint64_t v142 = (uint64_t)v139;
            v144 = ") and cpusubtype(";
            __int16 v145 = 770;
            v146[0] = &v142;
            int64_t v147 = v112 & 0xFFFFFFFF00000000 | HIDWORD(v173);
            __int16 v148 = 2050;
            v151 = v146;
            v153 = ") (all members must match) ";
            __int16 v155 = 770;
            uint64_t __dst = (uint64_t)&v151;
            long long v158 = *(_OWORD *)(v7 + 32);
            __int16 v159 = 1282;
            llvm::Twine::str((llvm::Twine *)&__dst, __p);
            if (v150 >= 0) {
              long long v57 = __p;
            }
            else {
              long long v57 = (void **)__p[0];
            }
            long long v58 = std::generic_category();
            uint64_t v171 = 22;
            v172 = v58;
            v170[1] = v57;
            sub_1CD06481C();
          }
          uint64_t v8 = 0;
LABEL_51:
          int v50 = 1;
          goto LABEL_62;
        }
        unint64_t v52 = v173;
        v173 = 0;
        *(unsigned char *)(a3 + 48) |= 1u;
        *(void *)a3 = v52;
      }
      uint64_t v114 = v46;
      uint64_t v115 = v45;
      uint64_t v112 = v43;
      uint64_t v113 = v44;
      if ((v174 & 1) != 0 && v173) {
        (*((void (**)(void **))*v173 + 1))(v173);
      }
      if ((v176 & 1) != 0 && v175) {
        (*((void (**)(void **))*v175 + 1))(v175);
      }
      uint64_t v8 = 0;
      int v50 = 0;
    }
    else
    {
      uint64_t v8 = 0;
      uint64_t v177 = 0;
      int v50 = 1;
      uint64_t v7 = v10;
    }
LABEL_62:
    if (v178)
    {
      if (!v177) {
        goto LABEL_67;
      }
    }
    else if (!v177)
    {
      goto LABEL_67;
    }
    (*(void (**)(void))(*(void *)v177 + 8))();
LABEL_67:
    if (!v50) {
      break;
    }
    sub_1CD5DF480((uint64_t)&v164);
    if (v169 <= 7 && v163 < 8) {
      goto LABEL_127;
    }
  }
  uint64_t v94 = v161;
  uint64_t v161 = 0;
  if (v94) {
    (*(void (**)(uint64_t))(*(void *)v94 + 16))(v94);
  }
  uint64_t v95 = v165;
  uint64_t v165 = 0;
  if (v95) {
    (*(void (**)(uint64_t))(*(void *)v95 + 16))(v95);
  }
  uint64_t v96 = v184;
  uint64_t v184 = 0;
  if (v96) {
    (*(void (**)(uint64_t))(*(void *)v96 + 16))(v96);
  }
  uint64_t v97 = *((void *)&v179 + 1);
  *((void *)&v179 + 1) = 0;
  if (v97) {
    (*(void (**)(uint64_t))(*(void *)v97 + 16))(v97);
  }
LABEL_145:
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  uint64_t result = v170[0];
  if (v170[0]) {
    return (*(uint64_t (**)(void))(*(void *)v170[0] + 8))(v170[0]);
  }
  return result;
}

void sub_1CCC8182C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  __int16 v10 = 261;
  v9[0] = a2;
  v9[1] = a3;
  llvm::Triple::Triple((llvm::Triple *)__p, (const llvm::Twine *)v9);
  llvm::MachO::getCPUType((uint64_t)__p, (uint64_t)&v15);
  llvm::MachO::getCPUSubType((uint64_t)__p, (uint64_t)&v13);
  if (v16)
  {
    uint64_t v6 = v15;
    char v7 = v14;
    if (v14) {
      unint64_t v8 = v13;
    }
    else {
      unint64_t v8 = v13;
    }
    *(unsigned char *)(a1 + 8) |= 1u;
    *(void *)a1 = v6;
    if ((v7 & 1) != 0 && v8) {
      (*(void (**)(unint64_t))(*(void *)v8 + 8))(v8);
    }
  }
  else
  {
    if (v14)
    {
      unint64_t v4 = v13;
      char v5 = *(unsigned char *)(a1 + 8) | 1;
    }
    else
    {
      unint64_t v4 = v15 | ((unint64_t)v13 << 32);
      char v5 = *(unsigned char *)(a1 + 8) & 0xFE;
    }
    *(unsigned char *)(a1 + 8) = v5;
    *(void *)a1 = v4;
  }
  if (v12 < 0) {
    operator delete(__p[0]);
  }
}

void llvm::object::Slice::create(llvm::object::Slice *this@<X0>, const llvm::object::IRObjectFile *a2@<X1>, uint64_t a3@<X8>)
{
  int v3 = (int)a2;
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = **((void **)this + 6);
  uint64_t v9 = *(void *)(v6 + 216);
  uint64_t v7 = v6 + 216;
  uint64_t v8 = v9;
  char v10 = *(unsigned char *)(v7 + 23);
  if (v10 >= 0) {
    uint64_t v11 = v7;
  }
  else {
    uint64_t v11 = v8;
  }
  uint64_t v12 = *(void *)(v7 + 8);
  if (v10 >= 0) {
    uint64_t v13 = v10 & 0x7F;
  }
  else {
    uint64_t v13 = v12;
  }
  sub_1CCC8182C((uint64_t)&v29, v11, v13);
  if (v30)
  {
    uint64_t v21 = v29;
    *(unsigned char *)(a3 + 48) |= 1u;
    *(void *)a3 = v21;
    return;
  }
  int v14 = v29;
  int v15 = HIDWORD(v29);
  llvm::object::MachOObjectFile::getArchTriple((llvm::Triple *)v29, 0, HIDWORD(v29), 0, (llvm::Triple *)__p);
  ArchName = llvm::Triple::getArchName((llvm::Triple *)__p);
  if (v17 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  uint64_t v18 = ArchName;
  size_t v19 = v17;
  if (v17 >= 0x17)
  {
    uint64_t v22 = (v17 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v17 | 7) != 0x17) {
      uint64_t v22 = v17 | 7;
    }
    uint64_t v23 = v22 + 1;
    p_dst = operator new(v22 + 1);
    *(void *)&long long v28 = v19;
    *((void *)&v28 + 1) = v23 | 0x8000000000000000;
    uint64_t __dst = p_dst;
  }
  else
  {
    HIBYTE(v28) = v17;
    p_dst = &__dst;
    if (!v17) {
      goto LABEL_17;
    }
  }
  memmove(p_dst, v18, v19);
LABEL_17:
  *((unsigned char *)p_dst + v19) = 0;
  if (v26 < 0) {
    operator delete(__p[0]);
  }
  uint64_t v24 = v28;
  *(void *)(a3 + 16) = __dst;
  *(void *)(a3 + 24) = v24;
  *(void *)(a3 + 31) = *(void *)((char *)&v28 + 7);
  LOBYTE(v24) = HIBYTE(v28);
  *(unsigned char *)(a3 + 48) &= ~1u;
  *(void *)a3 = this;
  *(_DWORD *)(a3 + 8) = v14;
  *(_DWORD *)(a3 + 12) = v15;
  *(unsigned char *)(a3 + 39) = v24;
  *(_DWORD *)(a3 + 40) = v3;
  if (v30)
  {
    if (v29) {
      (*(void (**)(uint64_t))(*(void *)v29 + 8))(v29);
    }
  }
}

void llvm::object::writeUniversalBinaryToStream(const char **this@<X2>, uint64_t a2@<X0>, uint64_t a3@<X1>, void *a4@<X8>)
{
  v76[5] = *MEMORY[0x1E4F143B8];
  *(_DWORD *)uint64_t v45 = -889275714;
  unsigned int v46 = a3;
  unint64_t v74 = (int8x16_t *)v76;
  uint64_t v75 = 0x200000000;
  uint64_t v58 = 20 * a3 + 8;
  if (!a3)
  {
    char v73 = 0;
    *(void *)&long long v70 = v71;
    *((void *)&v70 + 1) = 0x200000000;
    goto LABEL_36;
  }
  unsigned int v8 = 0;
  uint64_t v9 = a2 + 24;
  uint64_t v10 = 48 * a3;
  do
  {
    int v11 = *(_DWORD *)(v9 + 16);
    unint64_t v12 = (v58 + (1 << v11) - 1) & -(1 << v11);
    uint64_t v58 = v12;
    if (HIDWORD(v12))
    {
      v49[0] = "fat file too large to be created because the offset field in struct fat_arch is only 32-bits and the offset ";
      v49[2] = &v58;
      __int16 v50 = 3075;
      v51[0] = v49;
      v51[2] = " for ";
      __int16 v52 = 770;
      uint64_t v15 = *(void *)(v9 - 24);
      unint64_t v53 = v51;
      long long v54 = *(_OWORD *)(v15 + 32);
      __int16 v55 = 1282;
      v56[0] = &v53;
      v56[2] = " for architecture ";
      __int16 v57 = 770;
      char v16 = (const void **)(v9 - 8);
      if (*(char *)(v9 + 15) < 0)
      {
        if (*(void *)v9)
        {
          sub_1CB8BDF7C((uint64_t)v47, *v16, *(void *)v9);
          goto LABEL_21;
        }
      }
      else if (*(unsigned char *)(v9 + 15))
      {
        long long v17 = *(_OWORD *)v16;
        uint64_t v48 = *(void *)(v9 + 8);
        *(_OWORD *)unint64_t v47 = v17;
        goto LABEL_21;
      }
      uint64_t v18 = *(unsigned int *)(v9 - 16);
      __p[0] = "unknown(";
      uint64_t v60 = v18;
      __int16 v61 = 2051;
      v62 = __p;
      v64 = (void **)",";
      __int16 v65 = 770;
      size_t v19 = (const char *)(*(_DWORD *)(v9 - 12) & 0xFFFFFF);
      v66[0] = &v62;
      uint64_t v67 = v19;
      __int16 v68 = 2050;
      *(void *)&long long v70 = v66;
      v71[0] = ")";
      __int16 v72 = 770;
      llvm::Twine::str((llvm::Twine *)&v70, v47);
LABEL_21:
      char v20 = v57;
      if (v57 == 1)
      {
        uint64_t v23 = v47;
        v62 = v47;
        __int16 v65 = 260;
        char v21 = 4;
        uint64_t v24 = v63;
      }
      else
      {
        if (!(_BYTE)v57)
        {
          char v21 = 0;
          __int16 v65 = 256;
          char v22 = 1;
          goto LABEL_29;
        }
        unsigned int v25 = (void **)v56[0];
        char v21 = 2;
        if (HIBYTE(v57) != 1)
        {
          char v20 = 2;
          unsigned int v25 = (void **)v56;
        }
        v62 = v25;
        size_t v63 = (void **)v56[1];
        uint64_t v24 = v47;
        v64 = v47;
        LOBYTE(v65) = v20;
        HIBYTE(v65) = 4;
        uint64_t v23 = (void **)&v62;
      }
      v66[0] = v23;
      v66[1] = v24;
      uint64_t v67 = "exceeds that.";
      char v22 = 3;
LABEL_29:
      LOBYTE(v68) = v21;
      HIBYTE(v68) = v22;
      char v26 = __p;
      llvm::Twine::str((llvm::Twine *)v66, __p);
      if (v60 < 0) {
        char v26 = (void **)__p[0];
      }
      uint64_t v27 = std::generic_category();
      *(void *)&long long v70 = 22;
      *((void *)&v70 + 1) = v27;
      int v69 = v26;
      sub_1CD06481C();
    }
    *(void *)&long long v70 = *(void *)(v9 - 16);
    DWORD2(v70) = v12;
    HIDWORD(v70) = *(void *)(*(void *)(v9 - 24) + 24);
    LODWORD(v71[0]) = v11;
    uint64_t v58 = v12 + HIDWORD(v70);
    if (v8 >= HIDWORD(v75))
    {
      if (v74 > (int8x16_t *)&v70 || (char *)v74 + 20 * v8 <= (char *)&v70) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v13 = &v74->i8[20 * v75];
    long long v14 = v70;
    *((_DWORD *)v13 + 4) = v71[0];
    *(_OWORD *)uint64_t v13 = v14;
    unsigned int v8 = v75 + 1;
    LODWORD(v75) = v75 + 1;
    v9 += 48;
    v10 -= 48;
  }
  while (v10);
  char v73 = 0;
  *(void *)&long long v70 = v71;
  *((void *)&v70 + 1) = 0x200000000;
  if (v8)
  {
    if (v74 == (int8x16_t *)v76)
    {
      if (v8 >= 3) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy((void *)v70, v74, 20 * v8);
      DWORD2(v70) = v8;
    }
    else
    {
      *(void *)&long long v70 = v74;
      *((void *)&v70 + 1) = __PAIR64__(HIDWORD(v75), v8);
      unint64_t v74 = (int8x16_t *)v76;
      HIDWORD(v75) = 0;
    }
    LODWORD(v75) = 0;
  }
LABEL_36:
  if (v74 != (int8x16_t *)v76) {
    free(v74);
  }
  if (v73)
  {
    *a4 = v70;
  }
  else
  {
    unint64_t v74 = (int8x16_t *)v76;
    uint64_t v75 = 0x200000000;
    if (DWORD2(v70))
    {
      if (DWORD2(v70) >= 3) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v74, (const void *)v70, 20 * DWORD2(v70));
      LODWORD(v75) = DWORD2(v70);
    }
    *(_DWORD *)uint64_t v45 = -1095041334;
    unsigned int v46 = bswap32(a3);
    llvm::raw_ostream::write((llvm::raw_ostream *)this, v45, 8uLL);
    long long v28 = (const char *)v74;
    if (v75)
    {
      uint64_t v29 = (int8x16_t *)((char *)v74 + 20 * v75);
      char v30 = v74;
      do
      {
        int8x16_t *v30 = vrev32q_s8(*v30);
        v30[1].i32[0] = bswap32(v30[1].u32[0]);
        char v30 = (int8x16_t *)((char *)v30 + 20);
      }
      while (v30 != v29);
      size_t v31 = 20 * v75;
    }
    else
    {
      size_t v31 = 0;
    }
    llvm::raw_ostream::write((llvm::raw_ostream *)this, v28, v31);
    uint64_t v32 = v74;
    if (v75)
    {
      uint64_t v33 = (int8x16_t *)((char *)v74 + 20 * v75);
      uint64_t v34 = v74;
      do
      {
        *uint64_t v34 = vrev32q_s8(*v34);
        v34[1].i32[0] = bswap32(v34[1].u32[0]);
        uint64_t v34 = (int8x16_t *)((char *)v34 + 20);
      }
      while (v34 != v33);
    }
    if (a3)
    {
      uint64_t v35 = 0;
      int v36 = 20 * v75 + 8;
      do
      {
        uint64_t v37 = *(void *)(a2 + 48 * v35);
        char v39 = *(const char **)(v37 + 16);
        size_t v38 = *(void *)(v37 + 24);
        size_t v40 = (v32->i32[5 * v35 + 2] - v36);
        if (v40 >= 0x50)
        {
          do
          {
            int v44 = v40;
            if (v40 >= 0x4F) {
              size_t v40 = 79;
            }
            else {
              size_t v40 = v40;
            }
            int v43 = v40;
            llvm::raw_ostream::write((llvm::raw_ostream *)this, "", v40);
            LODWORD(v40) = v44 - v43;
          }
          while (v44 != v43);
        }
        else
        {
          llvm::raw_ostream::write((llvm::raw_ostream *)this, "", v40);
        }
        llvm::raw_ostream::write((llvm::raw_ostream *)this, v39, v38);
        uint64_t v32 = v74;
        int v36 = v38 + v74->i32[5 * v35++ + 2];
      }
      while (v35 != a3);
    }
    uint64_t v41 = this[2];
    if (this[4] != v41)
    {
      this[4] = v41;
      llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)this, v41);
      uint64_t v32 = v74;
    }
    *a4 = 0;
    if (v32 != (int8x16_t *)v76) {
      free(v32);
    }
    uint64_t v42 = v70;
    if (v73)
    {
      *(void *)&long long v70 = 0;
      if (v42) {
        (*(void (**)(uint64_t))(*(void *)v42 + 8))(v42);
      }
    }
    else if ((void *)v70 != v71)
    {
      free((void *)v70);
    }
  }
}

uint64_t *llvm::object::writeUniversalBinary@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, char **a5@<X8>)
{
  uint64_t v5 = a4;
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v10 = a1 + 48 * a2;
    uint64_t v11 = a1 + 16;
    while (1)
    {
      long long v28 = *(_OWORD *)(v11 - 16);
      if (*(char *)(v11 + 23) < 0)
      {
        sub_1CB8BDF7C((uint64_t)&__p, *(const void **)v11, *(void *)(v11 + 8));
      }
      else
      {
        long long v12 = *(_OWORD *)v11;
        uint64_t v30 = *(void *)(v11 + 16);
        long long __p = v12;
      }
      uint64_t v13 = v11 - 16;
      int v31 = *(_DWORD *)(v11 + 24);
      uint64_t v15 = *(void *)(v28 + 32);
      uint64_t v14 = *(void *)(v28 + 40);
      LOWORD(v33) = 261;
      v32[0] = v15;
      v32[1] = v14;
      int v16 = llvm::sys::fs::access((unsigned __int8 *)v32, 2);
      if (SHIBYTE(v30) < 0) {
        operator delete((void *)__p);
      }
      if (!v16) {
        break;
      }
      v11 += 48;
      if (v13 + 48 == v10)
      {
        uint64_t v17 = 438;
        goto LABEL_13;
      }
    }
    uint64_t v17 = 511;
LABEL_13:
    uint64_t v5 = a4;
  }
  else
  {
    uint64_t v17 = 438;
  }
  LOWORD(v30) = 773;
  *(void *)&long long v28 = a3;
  *((void *)&v28 + 1) = v5;
  *(void *)&long long __p = ".temp-universal-%%%%%%";
  llvm::sys::fs::TempFile::create((uint64_t)&v28, v17, 0, (uint64_t)v32);
  if (v34)
  {
    uint64_t v18 = v32[0];
    v32[0] = 0;
    *a5 = (char *)v18;
  }
  else
  {
    llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)&v28, v33, 0, 0, 0);
    llvm::object::writeUniversalBinaryToStream((const char **)&v28, a1, a2, v23);
    char v21 = (char *)v23[0];
    if (v23[0])
    {
      llvm::sys::fs::TempFile::discard((llvm::sys::fs::TempFile *)v32, &v27);
      if (v27)
      {
        unsigned int v25 = v27;
        char v26 = v21;
        uint64_t v27 = 0;
        sub_1CD5E5368(&v26, &v25, a5);
        if (v25) {
          (*(void (**)(char *))(*(void *)v25 + 8))(v25);
        }
        if (v26) {
          (*(void (**)(char *))(*(void *)v26 + 8))(v26);
        }
        if (v27) {
          (*(void (**)(char *))(*(void *)v27 + 8))(v27);
        }
      }
      else
      {
        *a5 = v21;
      }
    }
    else
    {
      __int16 v24 = 261;
      v23[0] = a3;
      v23[1] = v5;
      llvm::sys::fs::TempFile::keep((llvm::sys::fs::TempFile *)v32, (const llvm::Twine *)v23, v20, a5);
    }
    llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)&v28);
  }
  return sub_1CCC1A4A0(v32);
}

uint64_t sub_1CCC8251C(uint64_t *a1, long long *a2)
{
  unint64_t v4 = a1[2];
  unint64_t v5 = a1[1];
  if (v5 >= v4)
  {
    unint64_t v10 = 0x8E38E38E38E38E39 * ((uint64_t)(v5 - *a1) >> 3);
    if (v10 + 1 > 0x38E38E38E38E38ELL) {
      abort();
    }
    unint64_t v11 = 0x8E38E38E38E38E39 * ((uint64_t)(v4 - *a1) >> 3);
    uint64_t v12 = 2 * v11;
    if (2 * v11 <= v10 + 1) {
      uint64_t v12 = v10 + 1;
    }
    if (v11 >= 0x1C71C71C71C71C7) {
      unint64_t v13 = 0x38E38E38E38E38ELL;
    }
    else {
      unint64_t v13 = v12;
    }
    v18[4] = a1 + 2;
    if (v13 > 0x38E38E38E38E38ELL) {
      sub_1CB833614();
    }
    uint64_t v14 = 9 * v13;
    uint64_t v15 = (char *)operator new(72 * v13);
    int v16 = &v15[72 * v10];
    v18[0] = v15;
    v18[1] = v16;
    v18[3] = &v15[8 * v14];
    long long v17 = a2[1];
    *(_OWORD *)int v16 = *a2;
    *((_OWORD *)v16 + 1) = v17;
    *((_OWORD *)v16 + 2) = a2[2];
    *((void *)v16 + 7) = 0;
    *((void *)v16 + 8) = 0;
    *((void *)v16 + 6) = 0;
    sub_1CC6A8A48((void *)v16 + 6, *((const void **)a2 + 6), *((void *)a2 + 7), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)a2 + 7) - *((void *)a2 + 6)) >> 3));
    v18[2] = v16 + 72;
    sub_1CD6F2C24(a1, v18);
    uint64_t v9 = a1[1];
    uint64_t result = sub_1CD6F2CC8((uint64_t)v18);
  }
  else
  {
    long long v6 = *a2;
    long long v7 = a2[2];
    *(_OWORD *)(v5 + 16) = a2[1];
    *(_OWORD *)(v5 + 32) = v7;
    *(_OWORD *)unint64_t v5 = v6;
    *(void *)(v5 + 56) = 0;
    *(void *)(v5 + 64) = 0;
    *(void *)(v5 + 48) = 0;
    uint64_t result = (uint64_t)sub_1CC6A8A48((void *)(v5 + 48), *((const void **)a2 + 6), *((void *)a2 + 7), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)a2 + 7) - *((void *)a2 + 6)) >> 3));
    uint64_t v9 = v5 + 72;
  }
  a1[1] = v9;
  return result;
}

void llvm::object::WasmObjectFile::parseTypeSection(void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  unint64_t v6 = sub_1CCC8505C(a2);
  if (HIDWORD(v6))
  {
LABEL_59:
    int v36 = "LEB is outside Varuint32 range";
    goto LABEL_58;
  }
  int v7 = v6;
  size_t v38 = a1 + 35;
  sub_1CD6F1944((uint64_t)(a1 + 35), v6);
  unsigned int v8 = &v42;
  uint64_t v9 = "invalid signature type";
  while (v7)
  {
    size_t v40 = v8;
    uint64_t v41 = 0x100000000;
    int v43 = v45;
    uint64_t v44 = 0x400000000;
    char v45[4] = 0;
    unint64_t v10 = *(unsigned char **)(a2 + 8);
    if (v10 == *(unsigned char **)(a2 + 16)) {
      goto LABEL_57;
    }
    *(void *)(a2 + 8) = v10 + 1;
    if (*v10 != 96) {
      operator new();
    }
    unint64_t v11 = sub_1CCC8505C(a2);
    if (HIDWORD(v11)) {
      goto LABEL_59;
    }
    int v12 = v11;
    if (v11 > HIDWORD(v44)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    if (v11)
    {
      while (1)
      {
        size_t v19 = *(unsigned __int8 **)(a2 + 8);
        if (v19 == *(unsigned __int8 **)(a2 + 16)) {
          break;
        }
        *(void *)(a2 + 8) = v19 + 1;
        if (v44 >= (unint64_t)HIDWORD(v44)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((_DWORD *)v43 + v44) = *v19;
        LODWORD(v44) = v44 + 1;
        if (!--v12) {
          goto LABEL_10;
        }
      }
LABEL_57:
      int v36 = "EOF while reading uint8";
LABEL_58:
      llvm::report_fatal_error((llvm *)v36, (const llvm::Twine *)1);
    }
LABEL_10:
    unint64_t v13 = sub_1CCC8505C(a2);
    if (HIDWORD(v13)) {
      goto LABEL_59;
    }
    int v14 = v13;
    if (v13)
    {
      do
      {
        char v20 = *(unsigned __int8 **)(a2 + 8);
        if (v20 == *(unsigned __int8 **)(a2 + 16)) {
          goto LABEL_57;
        }
        *(void *)(a2 + 8) = v20 + 1;
        if (v41 >= (unint64_t)HIDWORD(v41)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((_DWORD *)v40 + v41) = *v20;
        LODWORD(v41) = v41 + 1;
      }
      while (--v14);
    }
    char v39 = v8;
    unint64_t v15 = a1[36];
    unint64_t v16 = a1[37];
    if (v15 < v16)
    {
      long long v17 = v9;
      uint64_t v18 = sub_1CD6BF68C(v15, &v40) + 64;
      goto LABEL_46;
    }
    uint64_t v21 = (uint64_t)(v15 - *v38) >> 6;
    if ((unint64_t)(v21 + 1) >> 58) {
      abort();
    }
    long long v17 = v9;
    uint64_t v22 = v16 - *v38;
    uint64_t v23 = v22 >> 5;
    if (v22 >> 5 <= (unint64_t)(v21 + 1)) {
      uint64_t v23 = v21 + 1;
    }
    if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFC0) {
      unint64_t v24 = 0x3FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v24 = v23;
    }
    uint64_t v37 = a3;
    if (v24)
    {
      if (v24 >> 58) {
        sub_1CB833614();
      }
      unsigned int v25 = (char *)operator new(v24 << 6);
    }
    else
    {
      unsigned int v25 = 0;
    }
    uint64_t v26 = (uint64_t)&v25[64 * v21];
    uint64_t v27 = &v25[64 * v24];
    uint64_t v28 = sub_1CD6BF68C(v26, &v40);
    uint64_t v18 = v28 + 64;
    uint64_t v29 = (char *)a1[35];
    uint64_t v30 = (char *)a1[36];
    if (v30 == v29)
    {
      a1[35] = v28;
      a1[36] = v18;
      a1[37] = v27;
LABEL_52:
      a3 = v37;
      if (v30) {
        goto LABEL_45;
      }
      goto LABEL_46;
    }
    do
    {
      v30 -= 64;
      uint64_t v28 = sub_1CD6BF68C(v28 - 64, v30);
    }
    while (v30 != v29);
    uint64_t v30 = (char *)a1[35];
    int v31 = (char *)a1[36];
    a1[35] = v28;
    a1[36] = v18;
    a1[37] = v27;
    if (v31 == v30) {
      goto LABEL_52;
    }
    uint64_t v32 = v31 - 24;
    a3 = v37;
    do
    {
      int v33 = (char *)*((void *)v32 - 2);
      if (v32 != v33) {
        free(v33);
      }
      char v34 = (char *)*((void *)v32 - 5);
      if (v32 - 24 != v34) {
        free(v34);
      }
      uint64_t v35 = v32 - 40;
      v32 -= 64;
    }
    while (v35 != v30);
    if (v30) {
LABEL_45:
    }
      operator delete(v30);
LABEL_46:
    a1[36] = v18;
    uint64_t v9 = v17;
    unsigned int v8 = v39;
    if (v43 != v45) {
      free(v43);
    }
    if (v40 != v39) {
      free(v40);
    }
    --v7;
  }
  if (*(void *)(a2 + 8) != *(void *)(a2 + 16)) {
    operator new();
  }
  *a3 = 0;
}

void llvm::object::WasmObjectFile::parseImportSection(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v3 = a2;
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  unint64_t v5 = sub_1CCC8505C(a2);
  if (HIDWORD(v5))
  {
LABEL_50:
    uint64_t v44 = "LEB is outside Varuint32 range";
    goto LABEL_51;
  }
  int v6 = v5;
  uint64_t v8 = *(void *)(a1 + 280);
  uint64_t v7 = *(void *)(a1 + 288);
  __int16 v50 = (uint64_t **)(a1 + 400);
  sub_1CD6F1A48(a1 + 400, v5);
  if (v6)
  {
    int v9 = 0;
    uint64_t v10 = 0;
    unint64_t v46 = (unint64_t)(v7 - v8) >> 6;
    uint64_t v48 = v3;
    int v49 = v6;
    uint64_t v47 = a1;
    while (1)
    {
      uint64_t v11 = ((uint64_t (*)(uint64_t))loc_1CCC837F8)(v3);
      uint64_t v13 = v12;
      uint64_t v53 = ((uint64_t (*)(uint64_t))loc_1CCC837F8)(v3);
      unint64_t v15 = *(char **)(v3 + 8);
      unint64_t v16 = *(char **)(v3 + 16);
      if (v15 == v16)
      {
LABEL_49:
        uint64_t v44 = "EOF while reading uint8";
        goto LABEL_51;
      }
      long long v17 = v15 + 1;
      *(void *)(v3 + 8) = v15 + 1;
      char v18 = *v15;
      uint64_t v52 = v14;
      switch(*v15)
      {
        case 0:
          ++*(_DWORD *)(a1 + 680);
          unint64_t v19 = sub_1CCC8505C(v3);
          if (HIDWORD(v19)) {
            goto LABEL_50;
          }
          if (v19 >= v46) {
            operator new();
          }
          int v20 = v19;
          int v21 = BYTE1(v19);
          uint64_t v10 = WORD1(v19);
          goto LABEL_21;
        case 1:
          sub_1CCC8451C(v54, v3);
          unsigned int v22 = v54[0];
          int v20 = LOBYTE(v54[0]);
          *(_OWORD *)__int16 v55 = *(_OWORD *)((char *)v54 + 4);
          *(_OWORD *)&v55[12] = v54[1];
          ++*(_DWORD *)(a1 + 676);
          if ((v20 - 111) >= 2) {
            operator new();
          }
          int v21 = BYTE1(v22);
          uint64_t v10 = HIWORD(v22);
          goto LABEL_21;
        case 2:
          sub_1CCC844AC((uint64_t)v54, v3);
          int v20 = LOBYTE(v54[0]);
          int v21 = BYTE1(v54[0]);
          uint64_t v10 = WORD1(v54[0]);
          *(_OWORD *)__int16 v55 = *(_OWORD *)((char *)v54 + 4);
          *(_DWORD *)&v55[16] = DWORD1(v54[1]);
          if ((v54[0] & 4) != 0) {
            *(unsigned char *)(a1 + 591) = 1;
          }
          goto LABEL_21;
        case 3:
          ++*(_DWORD *)(a1 + 672);
          if (v17 == v16) {
            goto LABEL_49;
          }
          *(void *)(v3 + 8) = v15 + 2;
          int v23 = v15[1];
          unint64_t v24 = sub_1CCC850EC(v3);
          if (v24 >= 2)
          {
            uint64_t v44 = "LEB is outside Varuint1 range";
LABEL_51:
            llvm::report_fatal_error((llvm *)v44, (const llvm::Twine *)1);
          }
          int v21 = v24;
          int v20 = v23;
LABEL_21:
          uint64_t v27 = *(uint64_t **)(a1 + 408);
          unint64_t v26 = *(void *)(a1 + 416);
          if ((unint64_t)v27 >= v26)
          {
            uint64_t v29 = v10;
            uint64_t v30 = *v50;
            unint64_t v31 = 0x8E38E38E38E38E39 * (v27 - *v50);
            unint64_t v32 = v31 + 1;
            if (v31 + 1 > 0x38E38E38E38E38ELL) {
              abort();
            }
            unint64_t v33 = 0x8E38E38E38E38E39 * ((uint64_t)(v26 - (void)v30) >> 3);
            if (2 * v33 > v32) {
              unint64_t v32 = 2 * v33;
            }
            if (v33 >= 0x1C71C71C71C71C7) {
              unint64_t v32 = 0x38E38E38E38E38ELL;
            }
            unint64_t v51 = v32;
            if (v32)
            {
              if (v32 > 0x38E38E38E38E38ELL) {
                sub_1CB833614();
              }
              int v34 = v21;
              int v35 = v9;
              int v36 = v20;
              uint64_t v37 = (char *)operator new(72 * v32);
              int v20 = v36;
              int v9 = v35;
              int v21 = v34;
            }
            else
            {
              uint64_t v37 = 0;
            }
            size_t v38 = &v37[72 * v31];
            *(void *)size_t v38 = v11;
            *((void *)v38 + 1) = v13;
            *((void *)v38 + 2) = v53;
            *((void *)v38 + 3) = v52;
            v38[32] = v18;
            uint64_t v10 = v29;
            *((_DWORD *)v38 + 10) = (v21 << 8) | (v29 << 16) | v20;
            *(_OWORD *)(v38 + 44) = *(_OWORD *)v55;
            *(_OWORD *)(v38 + 56) = *(_OWORD *)&v55[12];
            char v39 = v38;
            if (v27 == v30)
            {
              a1 = v47;
              uint64_t v3 = v48;
              unint64_t v40 = v51;
            }
            else
            {
              a1 = v47;
              unint64_t v40 = v51;
              do
              {
                *(_OWORD *)(v39 - 72) = *(_OWORD *)(v27 - 9);
                long long v41 = *(_OWORD *)(v27 - 7);
                long long v42 = *(_OWORD *)(v27 - 5);
                long long v43 = *(_OWORD *)(v27 - 3);
                *((void *)v39 - 1) = *(v27 - 1);
                *(_OWORD *)(v39 - 24) = v43;
                *(_OWORD *)(v39 - 40) = v42;
                *(_OWORD *)(v39 - 56) = v41;
                v39 -= 72;
                v27 -= 9;
              }
              while (v27 != v30);
              uint64_t v27 = *v50;
              uint64_t v3 = v48;
            }
            uint64_t v28 = v38 + 72;
            *(void *)(a1 + 400) = v39;
            *(void *)(a1 + 408) = v38 + 72;
            *(void *)(a1 + 416) = &v37[72 * v40];
            if (v27) {
              operator delete(v27);
            }
            int v6 = v49;
          }
          else
          {
            *uint64_t v27 = v11;
            v27[1] = v13;
            v27[2] = v53;
            v27[3] = v52;
            *((unsigned char *)v27 + 32) = v18;
            *((_DWORD *)v27 + 10) = (v21 << 8) | (v10 << 16) | v20;
            *(_OWORD *)((char *)v27 + 44) = *(_OWORD *)v55;
            *(_OWORD *)(v27 + 7) = *(_OWORD *)&v55[12];
            uint64_t v28 = v27 + 9;
          }
          *(void *)(a1 + 408) = v28;
          if (++v9 == v6) {
            goto LABEL_41;
          }
          break;
        case 4:
          ++*(_DWORD *)(a1 + 684);
          if (v17 == v16) {
            goto LABEL_49;
          }
          *(void *)(v3 + 8) = v15 + 2;
          if (v15[1]) {
            operator new();
          }
          unint64_t v25 = sub_1CCC8505C(v3);
          if (HIDWORD(v25)) {
            goto LABEL_50;
          }
          if (v25 >= v46) {
            operator new();
          }
          int v20 = v25;
          int v21 = BYTE1(v25);
          uint64_t v10 = WORD1(v25);
          goto LABEL_21;
        default:
          operator new();
      }
    }
  }
LABEL_41:
  if (*(void *)(v3 + 8) != *(void *)(v3 + 16)) {
    operator new();
  }
  *a3 = 0;
}

void llvm::object::WasmObjectFile::parseTableSection(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)(a1 + 704) = 954437177 * ((*(void *)(a1 + 80) - *(void *)(a1 + 72)) >> 3);
  unint64_t v5 = sub_1CCC8505C(a2);
  if (HIDWORD(v5)) {
    llvm::report_fatal_error((llvm *)"LEB is outside Varuint32 range", (const llvm::Twine *)1);
  }
  int v6 = v5;
  sub_1CD6F1BDC(a1 + 304, v5);
  for (; v6; --v6)
  {
    sub_1CCC8451C(v25, a2);
    *(_OWORD *)&v26[4] = v25[0];
    *(_OWORD *)&v26[20] = v25[1];
    uint64_t v7 = *(char **)(a1 + 304);
    uint64_t v8 = *(char **)(a1 + 312);
    uint64_t v9 = (v8 - v7) / 56;
    int v10 = *(_DWORD *)(a1 + 676) + v9;
    unint64_t v11 = *(void *)(a1 + 320);
    if ((unint64_t)v8 >= v11)
    {
      unint64_t v14 = v9 + 1;
      if ((unint64_t)(v9 + 1) > 0x492492492492492) {
        abort();
      }
      unint64_t v15 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v11 - (void)v7) >> 3);
      if (2 * v15 > v14) {
        unint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x249249249249249) {
        unint64_t v16 = 0x492492492492492;
      }
      else {
        unint64_t v16 = v14;
      }
      if (v16)
      {
        if (v16 > 0x492492492492492) {
          sub_1CB833614();
        }
        long long v17 = (char *)operator new(56 * v16);
      }
      else
      {
        long long v17 = 0;
      }
      char v18 = &v17[56 * v9];
      *(_DWORD *)char v18 = v10;
      long long v19 = *(_OWORD *)&v26[16];
      *(_OWORD *)(v18 + 4) = *(_OWORD *)v26;
      *(_OWORD *)(v18 + 20) = v19;
      *((_DWORD *)v18 + 9) = *(_DWORD *)&v26[32];
      *((void *)v18 + 5) = 0;
      *((void *)v18 + 6) = 0;
      int v20 = v18;
      if (v8 != v7)
      {
        do
        {
          long long v21 = *(_OWORD *)(v8 - 56);
          long long v22 = *(_OWORD *)(v8 - 40);
          long long v23 = *(_OWORD *)(v8 - 24);
          *((void *)v20 - 1) = *((void *)v8 - 1);
          *(_OWORD *)(v20 - 24) = v23;
          *(_OWORD *)(v20 - 40) = v22;
          *(_OWORD *)(v20 - 56) = v21;
          v20 -= 56;
          v8 -= 56;
        }
        while (v8 != v7);
        uint64_t v8 = *(char **)(a1 + 304);
      }
      uint64_t v13 = v18 + 56;
      *(void *)(a1 + 304) = v20;
      *(void *)(a1 + 312) = v18 + 56;
      *(void *)(a1 + 320) = &v17[56 * v16];
      if (v8) {
        operator delete(v8);
      }
    }
    else
    {
      *(_DWORD *)uint64_t v8 = v10;
      long long v12 = *(_OWORD *)&v26[16];
      *(_OWORD *)(v8 + 4) = *(_OWORD *)v26;
      *(_OWORD *)(v8 + 20) = v12;
      *((_DWORD *)v8 + 9) = *(_DWORD *)&v26[32];
      uint64_t v13 = v8 + 56;
      *((void *)v8 + 5) = 0;
      *((void *)v8 + 6) = 0;
    }
    *(void *)(a1 + 312) = v13;
    if (*((unsigned __int8 *)v13 - 48) - 111 >= 2) {
      operator new();
    }
  }
  if (*(void *)(a2 + 8) != *(void *)(a2 + 16)) {
    operator new();
  }
  *a3 = 0;
}

void llvm::object::WasmObjectFile::parseDataSection(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  *(_DWORD *)(a1 + 692) = 954437177 * ((*(void *)(a1 + 80) - *(void *)(a1 + 72)) >> 3);
  unint64_t v6 = sub_1CCC8505C(a2);
  if (HIDWORD(v6)) {
    goto LABEL_38;
  }
  int v7 = v6;
  if (*(unsigned char *)(a1 + 504) && *(void *)(a1 + 496) != v6) {
    operator new();
  }
  uint64_t v8 = (void *)(a1 + 472);
  sub_1CD6F1F24(a1 + 472, v6);
  if (v7)
  {
    while (1)
    {
      memset(&v35[8], 0, 48);
      unint64_t v9 = sub_1CCC8505C(a2);
      if (HIDWORD(v9)) {
        break;
      }
      char v10 = v9;
      DWORD2(v33) = v9;
      if ((v9 & 2) != 0)
      {
        unint64_t v11 = sub_1CCC8505C(a2);
        if (HIDWORD(v11)) {
          break;
        }
      }
      else
      {
        LODWORD(v11) = 0;
      }
      HIDWORD(v33) = v11;
      if (v10)
      {
        LOBYTE(v34) = 0;
        BYTE8(v34) = 65;
        *(_DWORD *)int v35 = 0;
      }
      else
      {
        sub_1CCC846D8((uint64_t)a3, (uint64_t)&v34, a2);
        if (*a3) {
          return;
        }
      }
      unint64_t v12 = sub_1CCC8505C(a2);
      if (HIDWORD(v12)) {
        break;
      }
      uint64_t v13 = *(void *)(a2 + 8);
      if (*(void *)(a2 + 16) - v13 < v12) {
        operator new();
      }
      *(void *)&v35[24] = *(void *)(a2 + 8);
      *(void *)&v35[32] = v12;
      *(void *)&v35[56] = 0;
      LODWORD(v36) = -1;
      LODWORD(v33) = v13 - *(_DWORD *)a2;
      *(void *)(a2 + 8) = v13 + v12;
      unint64_t v15 = *(_OWORD **)(a1 + 480);
      unint64_t v14 = *(void *)(a1 + 488);
      if ((unint64_t)v15 >= v14)
      {
        long long v17 = (_OWORD *)*v8;
        uint64_t v18 = 0x4EC4EC4EC4EC4EC5 * (((uint64_t)v15 - *v8) >> 3);
        unint64_t v19 = v18 + 1;
        if ((unint64_t)(v18 + 1) > 0x276276276276276) {
          abort();
        }
        unint64_t v20 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v14 - (void)v17) >> 3);
        if (2 * v20 > v19) {
          unint64_t v19 = 2 * v20;
        }
        if (v20 >= 0x13B13B13B13B13BLL) {
          unint64_t v21 = 0x276276276276276;
        }
        else {
          unint64_t v21 = v19;
        }
        if (v21)
        {
          if (v21 > 0x276276276276276) {
            sub_1CB833614();
          }
          long long v22 = (char *)operator new(104 * v21);
        }
        else
        {
          long long v22 = 0;
        }
        long long v23 = *(_OWORD *)&v35[48];
        unint64_t v24 = &v22[104 * v18];
        *((_OWORD *)v24 + 4) = *(_OWORD *)&v35[32];
        *((_OWORD *)v24 + 5) = v23;
        *((void *)v24 + 12) = v36;
        long long v25 = v34;
        *(_OWORD *)unint64_t v24 = v33;
        *((_OWORD *)v24 + 1) = v25;
        long long v26 = *(_OWORD *)&v35[16];
        *((_OWORD *)v24 + 2) = *(_OWORD *)v35;
        *((_OWORD *)v24 + 3) = v26;
        uint64_t v27 = v24;
        if (v15 != v17)
        {
          do
          {
            long long v28 = *(_OWORD *)((char *)v15 - 104);
            long long v29 = *(_OWORD *)((char *)v15 - 88);
            *(_OWORD *)(v27 - 72) = *(_OWORD *)((char *)v15 - 72);
            *(_OWORD *)(v27 - 88) = v29;
            *(_OWORD *)(v27 - 104) = v28;
            long long v30 = *(_OWORD *)((char *)v15 - 56);
            long long v31 = *(_OWORD *)((char *)v15 - 40);
            long long v32 = *(_OWORD *)((char *)v15 - 24);
            *((void *)v27 - 1) = *((void *)v15 - 1);
            *(_OWORD *)(v27 - 24) = v32;
            *(_OWORD *)(v27 - 40) = v31;
            *(_OWORD *)(v27 - 56) = v30;
            v27 -= 104;
            unint64_t v15 = (_OWORD *)((char *)v15 - 104);
          }
          while (v15 != v17);
          unint64_t v15 = (_OWORD *)*v8;
        }
        unint64_t v16 = v24 + 104;
        *(void *)(a1 + 472) = v27;
        *(void *)(a1 + 480) = v24 + 104;
        *(void *)(a1 + 488) = &v22[104 * v21];
        if (v15) {
          operator delete(v15);
        }
      }
      else
      {
        v15[3] = *(_OWORD *)&v35[16];
        v15[4] = *(_OWORD *)&v35[32];
        v15[5] = *(_OWORD *)&v35[48];
        *((void *)v15 + 12) = v36;
        _OWORD *v15 = v33;
        v15[1] = v34;
        v15[2] = *(_OWORD *)v35;
        unint64_t v16 = (char *)v15 + 104;
      }
      *(void *)(a1 + 480) = v16;
      if (!--v7) {
        goto LABEL_33;
      }
    }
LABEL_38:
    llvm::report_fatal_error((llvm *)"LEB is outside Varuint32 range", (const llvm::Twine *)1);
  }
LABEL_33:
  if (*(void *)(a2 + 8) != *(void *)(a2 + 16)) {
    operator new();
  }
  *a3 = 0;
}

BOOL llvm::object::WasmObjectFile::isValidFunctionIndex(llvm::object::WasmObjectFile *this, unsigned int a2)
{
  return (unint64_t)*((unsigned int *)this + 170)
       + ((uint64_t)(*((void *)this + 65) - *((void *)this + 64)) >> 7) > a2;
}

BOOL llvm::object::WasmObjectFile::isDefinedFunctionIndex(llvm::object::WasmObjectFile *this, unsigned int a2)
{
  uint64_t v2 = *((unsigned int *)this + 170);
  return v2 <= a2
      && v2 + ((uint64_t)(*((void *)this + 65) - *((void *)this + 64)) >> 7) > (unint64_t)a2;
}

unint64_t llvm::object::WasmObjectFile::getDefinedFunction(llvm::object::WasmObjectFile *this, int a2)
{
  return *((void *)this + 64) + ((unint64_t)(a2 - *((_DWORD *)this + 170)) << 7);
}

{
  return *((void *)this + 64) + ((unint64_t)(a2 - *((_DWORD *)this + 170)) << 7);
}

BOOL llvm::object::WasmObjectFile::isValidGlobalIndex(llvm::object::WasmObjectFile *this, unsigned int a2)
{
  return (unint64_t)*((unsigned int *)this + 168)
       + ((uint64_t)(*((void *)this + 45) - *((void *)this + 44)) >> 6) > a2;
}

BOOL llvm::object::WasmObjectFile::isValidFunctionSymbol(llvm::object::WasmObjectFile *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 67);
  return a2 < (unint64_t)((*((void *)this + 68) - v2) >> 5)
      && *(unsigned char *)(*(void *)(v2 + 32 * a2) + 16) == 0;
}

BOOL llvm::object::WasmObjectFile::isDefinedGlobalIndex(llvm::object::WasmObjectFile *this, unsigned int a2)
{
  uint64_t v2 = *((unsigned int *)this + 168);
  return v2 <= a2
      && v2 + ((uint64_t)(*((void *)this + 45) - *((void *)this + 44)) >> 6) > (unint64_t)a2;
}

BOOL llvm::object::WasmObjectFile::isValidTableNumber(llvm::object::WasmObjectFile *this, unsigned int a2)
{
  return (unint64_t)*((unsigned int *)this + 169)
       + 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)this + 39) - *((void *)this + 38)) >> 3) > a2;
}

BOOL llvm::object::WasmObjectFile::isDefinedTableNumber(llvm::object::WasmObjectFile *this, unsigned int a2)
{
  uint64_t v2 = *((unsigned int *)this + 169);
  return v2 <= a2
      && v2 + 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)this + 39) - *((void *)this + 38)) >> 3) > (unint64_t)a2;
}

BOOL llvm::object::WasmObjectFile::isValidTagIndex(llvm::object::WasmObjectFile *this, unsigned int a2)
{
  return (unint64_t)*((unsigned int *)this + 171)
       - 0x5555555555555555 * ((uint64_t)(*((void *)this + 48) - *((void *)this + 47)) >> 3) > a2;
}

BOOL llvm::object::WasmObjectFile::isDefinedTagIndex(llvm::object::WasmObjectFile *this, unsigned int a2)
{
  uint64_t v2 = *((unsigned int *)this + 171);
  return v2 <= a2
      && v2 - 0x5555555555555555 * ((uint64_t)(*((void *)this + 48) - *((void *)this + 47)) >> 3) > (unint64_t)a2;
}

unint64_t *sub_1CCC83A48(unint64_t *result, char *a2)
{
  uint64_t v3 = result;
  unint64_t v4 = result[2];
  unint64_t v5 = result[1];
  unint64_t v6 = v5;
  if (v5 >= v4)
  {
    unint64_t v9 = *result;
    uint64_t v10 = (uint64_t)(v5 - *result) >> 5;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 59) {
      abort();
    }
    uint64_t v12 = v4 - v9;
    if (v12 >> 4 > v11) {
      unint64_t v11 = v12 >> 4;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v13 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    long long v25 = result + 2;
    if (v13)
    {
      if (v13 >> 59) {
        sub_1CB833614();
      }
      unint64_t v14 = (char *)operator new(32 * v13);
    }
    else
    {
      unint64_t v14 = 0;
    }
    unint64_t v15 = &v14[32 * v10];
    char *v15 = *a2;
    unint64_t v16 = v15 + 8;
    if (a2[31] < 0)
    {
      sub_1CB8BDF7C((uint64_t)v16, *((const void **)a2 + 1), *((void *)a2 + 2));
      unint64_t v9 = *v3;
      unint64_t v6 = v3[1];
    }
    else
    {
      *unint64_t v16 = *(_OWORD *)(a2 + 8);
      *((void *)v15 + 3) = *((void *)a2 + 3);
    }
    if (v6 == v9)
    {
      int64x2_t v17 = vdupq_n_s64(v9);
      unint64_t v18 = (unint64_t)v15;
    }
    else
    {
      unint64_t v18 = (unint64_t)v15;
      do
      {
        char v19 = *(unsigned char *)(v6 - 32);
        v6 -= 32;
        *(unsigned char *)(v18 - 32) = v19;
        v18 -= 32;
        long long v20 = *(_OWORD *)(v6 + 8);
        *(void *)(v18 + 24) = *(void *)(v6 + 24);
        *(_OWORD *)(v18 + 8) = v20;
        *(void *)(v6 + 16) = 0;
        *(void *)(v6 + 24) = 0;
        *(void *)(v6 + 8) = 0;
      }
      while (v6 != v9);
      int64x2_t v17 = *(int64x2_t *)v3;
    }
    unint64_t v8 = (unint64_t)(v15 + 32);
    *uint64_t v3 = v18;
    v3[1] = (unint64_t)(v15 + 32);
    int64x2_t v23 = v17;
    unint64_t v21 = v3[2];
    v3[2] = (unint64_t)&v14[32 * v13];
    unint64_t v24 = v21;
    uint64_t v22 = v17.i64[0];
    uint64_t result = (unint64_t *)sub_1CD4FF274((uint64_t)&v22);
  }
  else
  {
    *(unsigned char *)unint64_t v5 = *a2;
    if (a2[31] < 0)
    {
      uint64_t result = (unint64_t *)sub_1CB8BDF7C(v5 + 8, *((const void **)a2 + 1), *((void *)a2 + 2));
    }
    else
    {
      long long v7 = *(_OWORD *)(a2 + 8);
      *(void *)(v5 + 24) = *((void *)a2 + 3);
      *(_OWORD *)(v5 + 8) = v7;
    }
    unint64_t v8 = v5 + 32;
  }
  v3[1] = v8;
  return result;
}

void llvm::object::WasmObjectFile::parseRelocSection(void *a1@<X0>, uint64_t a2@<X3>, void *a3@<X8>)
{
  uint64_t v3 = a2;
  unint64_t v6 = sub_1CCC8505C(a2);
  if (HIDWORD(v6)) {
    goto LABEL_88;
  }
  unint64_t v7 = v6;
  uint64_t v8 = a1[9];
  if (0x8E38E38E38E38E39 * ((a1[10] - v8) >> 3) <= v6) {
    operator new();
  }
  uint64_t v48 = a3;
  unint64_t v9 = sub_1CCC8505C(v3);
  if (HIDWORD(v9))
  {
LABEL_88:
    uint64_t v47 = "LEB is outside Varuint32 range";
LABEL_89:
    llvm::report_fatal_error((llvm *)v47, (const llvm::Twine *)1);
  }
  int v10 = v9;
  if (v9)
  {
    LODWORD(v11) = 0;
    uint64_t v12 = v8 + 72 * v7;
    unint64_t v13 = *(unsigned int *)(v12 + 40);
    unint64_t v14 = (char **)(v12 + 56);
    uint64_t v52 = (void *)(v12 + 48);
    uint64_t v53 = (void *)(v12 + 64);
    unint64_t v49 = v13;
    uint64_t v50 = v3;
    while (2)
    {
      unsigned int v15 = v11;
      unint64_t v16 = sub_1CCC8505C(v3);
      if (!HIDWORD(v16))
      {
        int v17 = v16;
        unint64_t v18 = sub_1CCC8505C(v3);
        if (!HIDWORD(v18))
        {
          unint64_t v11 = v18;
          if (v15 > v18) {
            operator new();
          }
          unint64_t v19 = sub_1CCC8505C(v3);
          if (!HIDWORD(v19))
          {
            int v20 = v19;
            switch(v17)
            {
              case 0:
              case 1:
              case 2:
              case 12:
              case 18:
              case 19:
              case 24:
                uint64_t v21 = a1[67];
                if (v19 < (a1[68] - v21) >> 5 && !*(unsigned char *)(*(void *)(v21 + 32 * v19) + 16)) {
                  goto LABEL_13;
                }
                goto LABEL_75;
              case 3:
              case 4:
              case 5:
              case 11:
              case 21:
              case 23:
                uint64_t v23 = a1[67];
                if (v19 < (a1[68] - v23) >> 5 && *(unsigned char *)(*(void *)(v23 + 32 * v19) + 16) == 1) {
                  goto LABEL_16;
                }
                goto LABEL_82;
              case 6:
                if (v19 >= (uint64_t)(a1[36] - a1[35]) >> 6) {
                  operator new();
                }
                goto LABEL_13;
              case 7:
                uint64_t v40 = a1[67];
                if (v19 >= (a1[68] - v40) >> 5 || *(unsigned __int8 *)(*(void *)(v40 + 32 * v19) + 16) >= 3u) {
                  goto LABEL_83;
                }
                goto LABEL_13;
              case 8:
                uint64_t v41 = a1[67];
                if (v19 >= (a1[68] - v41) >> 5 || *(unsigned char *)(*(void *)(v41 + 32 * v19) + 16)) {
                  goto LABEL_75;
                }
                goto LABEL_16;
              case 9:
                uint64_t v42 = a1[67];
                if (v19 >= (a1[68] - v42) >> 5 || *(unsigned char *)(*(void *)(v42 + 32 * v19) + 16) != 3) {
                  operator new();
                }
LABEL_16:
                uint64_t v22 = sub_1CCC850EC(v3);
                if (v22 == (int)v22) {
                  goto LABEL_21;
                }
                uint64_t v47 = "LEB is outside Varint32 range";
                goto LABEL_89;
              case 10:
                uint64_t v43 = a1[67];
                if (v19 >= (a1[68] - v43) >> 5 || *(unsigned char *)(*(void *)(v43 + 32 * v19) + 16) != 4) {
                  operator new();
                }
                goto LABEL_13;
              case 13:
                uint64_t v44 = a1[67];
                if (v19 >= (a1[68] - v44) >> 5 || *(unsigned char *)(*(void *)(v44 + 32 * v19) + 16) != 2) {
LABEL_83:
                }
                  operator new();
                goto LABEL_13;
              case 14:
              case 15:
              case 16:
              case 17:
              case 25:
                uint64_t v24 = a1[67];
                if (v19 >= (a1[68] - v24) >> 5 || *(unsigned char *)(*(void *)(v24 + 32 * v19) + 16) != 1) {
LABEL_82:
                }
                  operator new();
                goto LABEL_20;
              case 20:
                uint64_t v45 = a1[67];
                if (v19 >= (a1[68] - v45) >> 5 || *(unsigned char *)(*(void *)(v45 + 32 * v19) + 16) != 5) {
                  operator new();
                }
LABEL_13:
                uint64_t v22 = 0;
                goto LABEL_21;
              case 22:
                uint64_t v46 = a1[67];
                if (v19 >= (a1[68] - v46) >> 5 || *(unsigned char *)(*(void *)(v46 + 32 * v19) + 16)) {
LABEL_75:
                }
                  operator new();
LABEL_20:
                uint64_t v22 = sub_1CCC850EC(v3);
LABEL_21:
                if ((v17 - 14) > 3u) {
                  uint64_t v25 = 5;
                }
                else {
                  uint64_t v25 = qword_1CFB2C348[(char)(v17 - 14)];
                }
                if (v17 <= 0x17u && ((1 << v17) & 0x802324) != 0) {
                  uint64_t v25 = 4;
                }
                if (v17 <= 0x16u && ((1 << v17) & 0x490000) != 0) {
                  uint64_t v25 = 8;
                }
                if (v25 + v11 > v13) {
                  operator new();
                }
                long long v26 = *v14;
                if ((unint64_t)*v14 >= *v53)
                {
                  int v51 = v10;
                  long long v28 = a1;
                  long long v29 = (char *)*v52;
                  unint64_t v30 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v26[-*v52] >> 3);
                  unint64_t v31 = v30 + 1;
                  if (v30 + 1 > 0xAAAAAAAAAAAAAAALL) {
                    abort();
                  }
                  if (0x5555555555555556 * ((uint64_t)(*v53 - (void)v29) >> 3) > v31) {
                    unint64_t v31 = 0x5555555555555556 * ((uint64_t)(*v53 - (void)v29) >> 3);
                  }
                  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*v53 - (void)v29) >> 3) >= 0x555555555555555) {
                    unint64_t v32 = 0xAAAAAAAAAAAAAAALL;
                  }
                  else {
                    unint64_t v32 = v31;
                  }
                  if (v32)
                  {
                    if (v32 > 0xAAAAAAAAAAAAAAALL) {
                      sub_1CB833614();
                    }
                    int v33 = v20;
                    uint64_t v34 = v22;
                    int v35 = (char *)operator new(24 * v32);
                    uint64_t v22 = v34;
                    int v20 = v33;
                  }
                  else
                  {
                    int v35 = 0;
                  }
                  uint64_t v36 = &v35[24 * v30];
                  *uint64_t v36 = v17;
                  *(_WORD *)(v36 + 1) = 0;
                  v36[3] = 0;
                  *((_DWORD *)v36 + 1) = v20;
                  *((void *)v36 + 1) = v11;
                  *((void *)v36 + 2) = v22;
                  uint64_t v37 = v36;
                  a1 = v28;
                  if (v26 == v29)
                  {
                    uint64_t v3 = v50;
                    size_t v38 = (char **)v52;
                  }
                  else
                  {
                    size_t v38 = (char **)v52;
                    do
                    {
                      long long v39 = *(_OWORD *)(v26 - 24);
                      *((void *)v37 - 1) = *((void *)v26 - 1);
                      *(_OWORD *)(v37 - 24) = v39;
                      v37 -= 24;
                      v26 -= 24;
                    }
                    while (v26 != v29);
                    long long v26 = (char *)*v52;
                    uint64_t v3 = v50;
                  }
                  *size_t v38 = v37;
                  uint64_t v27 = v36 + 24;
                  *unint64_t v14 = v36 + 24;
                  *uint64_t v53 = &v35[24 * v32];
                  unint64_t v13 = v49;
                  if (v26) {
                    operator delete(v26);
                  }
                  int v10 = v51;
                }
                else
                {
                  *long long v26 = v17;
                  *(_WORD *)(v26 + 1) = 0;
                  v26[3] = 0;
                  *((_DWORD *)v26 + 1) = v20;
                  uint64_t v27 = v26 + 24;
                  *((void *)v26 + 1) = v11;
                  *((void *)v26 + 2) = v22;
                }
                *unint64_t v14 = v27;
                if (!--v10) {
                  goto LABEL_76;
                }
                continue;
              default:
                operator new();
            }
          }
        }
      }
      goto LABEL_88;
    }
  }
LABEL_76:
  if (*(void *)(v3 + 8) != *(void *)(v3 + 16)) {
    operator new();
  }
  *uint64_t v48 = 0;
}

BOOL llvm::object::WasmObjectFile::isValidTableSymbol(llvm::object::WasmObjectFile *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 67);
  return a2 < (unint64_t)((*((void *)this + 68) - v2) >> 5)
      && *(unsigned char *)(*(void *)(v2 + 32 * a2) + 16) == 5;
}

BOOL llvm::object::WasmObjectFile::isValidGlobalSymbol(llvm::object::WasmObjectFile *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 67);
  return a2 < (unint64_t)((*((void *)this + 68) - v2) >> 5)
      && *(unsigned char *)(*(void *)(v2 + 32 * a2) + 16) == 2;
}

BOOL llvm::object::WasmObjectFile::isValidDataSymbol(llvm::object::WasmObjectFile *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 67);
  return a2 < (unint64_t)((*((void *)this + 68) - v2) >> 5)
      && *(unsigned char *)(*(void *)(v2 + 32 * a2) + 16) == 1;
}

BOOL llvm::object::WasmObjectFile::isValidTagSymbol(llvm::object::WasmObjectFile *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 67);
  return a2 < (unint64_t)((*((void *)this + 68) - v2) >> 5)
      && *(unsigned char *)(*(void *)(v2 + 32 * a2) + 16) == 4;
}

BOOL llvm::object::WasmObjectFile::isValidSectionSymbol(llvm::object::WasmObjectFile *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 67);
  return a2 < (unint64_t)((*((void *)this + 68) - v2) >> 5)
      && *(unsigned char *)(*(void *)(v2 + 32 * a2) + 16) == 3;
}

uint64_t sub_1CCC844AC(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = sub_1CCC8505C(a2);
  if (HIDWORD(v4)) {
    llvm::report_fatal_error((llvm *)"LEB is outside Varuint32 range", (const llvm::Twine *)1);
  }
  char v5 = v4;
  *(unsigned char *)a1 = v4;
  uint64_t result = sub_1CCC8505C(a2);
  *(void *)(a1 + 8) = result;
  if (v5)
  {
    uint64_t result = sub_1CCC8505C(a2);
    *(void *)(a1 + 16) = result;
  }
  return result;
}

uint64_t sub_1CCC8451C(unsigned char *a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned char **)(a2 + 8);
  if (v2 == *(unsigned char **)(a2 + 16)) {
    llvm::report_fatal_error((llvm *)"EOF while reading uint8", (const llvm::Twine *)1);
  }
  *(void *)(a2 + 8) = v2 + 1;
  *a1 = *v2;
  uint64_t v3 = (uint64_t)(a1 + 8);

  return sub_1CCC844AC(v3, a2);
}

uint64_t sub_1CCC8456C(uint64_t *a1, uint64_t a2)
{
  unint64_t v4 = a1[2];
  unint64_t v5 = a1[1];
  if (v5 >= v4)
  {
    uint64_t v12 = (uint64_t)(v5 - *a1) >> 7;
    if ((unint64_t)(v12 + 1) >> 57) {
      abort();
    }
    uint64_t v13 = v4 - *a1;
    uint64_t v14 = v13 >> 6;
    if (v13 >> 6 <= (unint64_t)(v12 + 1)) {
      uint64_t v14 = v12 + 1;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFF80) {
      unint64_t v15 = 0x1FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v15 = v14;
    }
    v21[4] = a1 + 2;
    if (v15)
    {
      if (v15 >> 57) {
        sub_1CB833614();
      }
      unint64_t v16 = (char *)operator new(v15 << 7);
    }
    else
    {
      unint64_t v16 = 0;
    }
    int v17 = &v16[128 * v12];
    v21[0] = v16;
    v21[1] = v17;
    v21[3] = &v16[128 * v15];
    unint64_t v18 = *(const void **)(a2 + 8);
    *(void *)int v17 = *(void *)a2;
    *((void *)v17 + 2) = 0;
    *((void *)v17 + 3) = 0;
    *((void *)v17 + 1) = 0;
    sub_1CBFCBA2C((void *)v17 + 1, v18, *(void *)(a2 + 16), (uint64_t)(*(void *)(a2 + 16) - (void)v18) >> 3);
    long long v19 = *(_OWORD *)(a2 + 80);
    *((_OWORD *)v17 + 4) = *(_OWORD *)(a2 + 64);
    *((_OWORD *)v17 + 5) = v19;
    *((_OWORD *)v17 + 6) = *(_OWORD *)(a2 + 96);
    *(_OWORD *)(v17 + 108) = *(_OWORD *)(a2 + 108);
    long long v20 = *(_OWORD *)(a2 + 48);
    *((_OWORD *)v17 + 2) = *(_OWORD *)(a2 + 32);
    *((_OWORD *)v17 + 3) = v20;
    v21[2] = v17 + 128;
    sub_1CD6F2E54(a1, v21);
    uint64_t v11 = a1[1];
    uint64_t result = sub_1CD6F2F04((uint64_t)v21);
  }
  else
  {
    *(void *)unint64_t v5 = *(void *)a2;
    *(void *)(v5 + 16) = 0;
    *(void *)(v5 + 24) = 0;
    *(void *)(v5 + 8) = 0;
    uint64_t result = (uint64_t)sub_1CBFCBA2C((void *)(v5 + 8), *(const void **)(a2 + 8), *(void *)(a2 + 16), (uint64_t)(*(void *)(a2 + 16) - *(void *)(a2 + 8)) >> 3);
    long long v7 = *(_OWORD *)(a2 + 48);
    *(_OWORD *)(v5 + 32) = *(_OWORD *)(a2 + 32);
    *(_OWORD *)(v5 + 48) = v7;
    long long v8 = *(_OWORD *)(a2 + 64);
    long long v9 = *(_OWORD *)(a2 + 80);
    long long v10 = *(_OWORD *)(a2 + 96);
    *(_OWORD *)(v5 + 108) = *(_OWORD *)(a2 + 108);
    *(_OWORD *)(v5 + 80) = v9;
    *(_OWORD *)(v5 + 96) = v10;
    *(_OWORD *)(v5 + 64) = v8;
    uint64_t v11 = v5 + 128;
  }
  a1[1] = v11;
  return result;
}

uint64_t sub_1CCC846D8(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned __int8 **)(a3 + 8);
  *(unsigned char *)a2 = 0;
  unint64_t v4 = *(void *)(a3 + 16);
  if (v3 == (unsigned __int8 *)v4) {
    goto LABEL_39;
  }
  long long v7 = (void *)result;
  long long v8 = (int *)(v3 + 1);
  *(void *)(a3 + 8) = v3 + 1;
  int v9 = *v3;
  *(unsigned char *)(a2 + 8) = v9;
  switch(v9)
  {
    case 'A':
      uint64_t result = sub_1CCC850EC(a3);
      if (result == (int)result) {
        goto LABEL_14;
      }
      long long v10 = "LEB is outside Varint32 range";
      goto LABEL_40;
    case 'B':
      uint64_t result = sub_1CCC850EC(a3);
      *(void *)(a2 + 16) = result;
      goto LABEL_16;
    case 'C':
      if ((unint64_t)(v3 + 5) > v4) {
        goto LABEL_41;
      }
      int v11 = *v8;
      *(void *)(a3 + 8) = v3 + 5;
      *(_DWORD *)(a2 + 16) = v11;
      goto LABEL_16;
    case 'D':
      if ((unint64_t)(v3 + 9) > v4)
      {
LABEL_41:
        long long v10 = "EOF while reading float64";
LABEL_40:
        llvm::report_fatal_error((llvm *)v10, (const llvm::Twine *)1);
      }
      uint64_t v12 = *(void *)v8;
      *(void *)(a3 + 8) = v3 + 9;
      *(void *)(a2 + 16) = v12;
      goto LABEL_16;
    default:
      if (v9 == 35)
      {
        uint64_t result = sub_1CCC8505C(a3);
LABEL_14:
        *(_DWORD *)(a2 + 16) = result;
      }
      else
      {
        if (v9 != 208) {
          goto LABEL_19;
        }
        uint64_t result = sub_1CCC8505C(a3);
        if (result != 111) {
          operator new();
        }
      }
LABEL_16:
      unint64_t v4 = *(void *)(a3 + 16);
      if (*(unsigned char *)a2) {
        goto LABEL_20;
      }
      uint64_t v13 = *(unsigned char **)(a3 + 8);
      if (v13 == (unsigned char *)v4)
      {
LABEL_39:
        long long v10 = "EOF while reading uint8";
        goto LABEL_40;
      }
      *(void *)(a3 + 8) = v13 + 1;
      if (*v13 == 11) {
        goto LABEL_37;
      }
LABEL_19:
      *(unsigned char *)a2 = 1;
LABEL_20:
      *(void *)(a3 + 8) = v3;
      if (v3 == (unsigned __int8 *)v4) {
        goto LABEL_39;
      }
      uint64_t v14 = v3;
      while (1)
      {
        *(void *)(a3 + 8) = v14 + 1;
        uint64_t v15 = *v14;
        if (*v14 <= 0x69u) {
          break;
        }
        BOOL v16 = (v15 - 106) > 0x14 || ((1 << (v15 - 106)) & 0x1C0007) == 0;
        ++v14;
        if (!v16) {
          goto LABEL_32;
        }
        if (v15 != 208) {
          goto LABEL_38;
        }
LABEL_31:
        uint64_t result = sub_1CCC8505C(a3);
        uint64_t v14 = *(unsigned __int8 **)(a3 + 8);
        unint64_t v4 = *(void *)(a3 + 16);
LABEL_32:
        if (v14 == (unsigned __int8 *)v4) {
          goto LABEL_39;
        }
      }
      if ((v15 - 65) < 4 || v15 == 35) {
        goto LABEL_31;
      }
      if (v15 != 11)
      {
LABEL_38:
        int v17 = "invalid opcode in init_expr: ";
        uint64_t v18 = v15;
        __int16 v19 = 2051;
        operator new();
      }
      *(void *)(a2 + 24) = v3;
      *(void *)(a2 + 32) = v14 + 1 - v3;
LABEL_37:
      *long long v7 = 0;
      return result;
  }
}

unint64_t llvm::object::WasmObjectFile::getDefinedGlobal(llvm::object::WasmObjectFile *this, int a2)
{
  return *((void *)this + 44) + ((unint64_t)(a2 - *((_DWORD *)this + 168)) << 6);
}

uint64_t llvm::object::WasmObjectFile::getDefinedTag(llvm::object::WasmObjectFile *this, int a2)
{
  return *((void *)this + 47) + 24 * (a2 - *((_DWORD *)this + 171));
}

uint64_t sub_1CCC849A4(uint64_t *a1, long long *a2)
{
  unint64_t v4 = a1[2];
  unint64_t v5 = a1[1];
  if (v5 >= v4)
  {
    unint64_t v11 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v5 - *a1) >> 4);
    if (v11 + 1 > 0x333333333333333) {
      abort();
    }
    unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v4 - *a1) >> 4);
    uint64_t v13 = 2 * v12;
    if (2 * v12 <= v11 + 1) {
      uint64_t v13 = v11 + 1;
    }
    if (v12 >= 0x199999999999999) {
      unint64_t v14 = 0x333333333333333;
    }
    else {
      unint64_t v14 = v13;
    }
    v20[4] = a1 + 2;
    if (v14 > 0x333333333333333) {
      sub_1CB833614();
    }
    uint64_t v15 = 5 * v14;
    BOOL v16 = (char *)operator new(80 * v14);
    int v17 = &v16[80 * v11];
    v20[0] = v16;
    v20[1] = v17;
    v20[3] = &v16[16 * v15];
    long long v18 = a2[1];
    *(_OWORD *)int v17 = *a2;
    *((_OWORD *)v17 + 1) = v18;
    *((_OWORD *)v17 + 2) = a2[2];
    __int16 v19 = (const void *)*((void *)a2 + 7);
    *((void *)v17 + 6) = *((void *)a2 + 6);
    *((void *)v17 + 8) = 0;
    *((void *)v17 + 9) = 0;
    *((void *)v17 + 7) = 0;
    sub_1CBA85A80((void *)v17 + 7, v19, *((void *)a2 + 8), (uint64_t)(*((void *)a2 + 8) - (void)v19) >> 2);
    _OWORD v20[2] = v17 + 80;
    sub_1CD6F2F68(a1, v20);
    uint64_t v10 = a1[1];
    uint64_t result = sub_1CD6F3008((uint64_t)v20);
  }
  else
  {
    long long v6 = *a2;
    long long v7 = a2[1];
    long long v8 = a2[2];
    *(void *)(v5 + 48) = *((void *)a2 + 6);
    *(_OWORD *)(v5 + 16) = v7;
    *(_OWORD *)(v5 + 32) = v8;
    *(_OWORD *)unint64_t v5 = v6;
    *(void *)(v5 + 64) = 0;
    *(void *)(v5 + 72) = 0;
    *(void *)(v5 + 56) = 0;
    uint64_t result = (uint64_t)sub_1CBA85A80((void *)(v5 + 56), *((const void **)a2 + 7), *((void *)a2 + 8), (uint64_t)(*((void *)a2 + 8) - *((void *)a2 + 7)) >> 2);
    uint64_t v10 = v5 + 80;
  }
  a1[1] = v10;
  return result;
}

uint64_t llvm::object::WasmObjectFile::getHeader(llvm::object::WasmObjectFile *this)
{
  return (uint64_t)this + 48;
}

uint64_t llvm::object::WasmObjectFile::getWasmSymbol(uint64_t a1, uint64_t a2)
{
  return *(void *)(a1 + 536) + 32 * *(unsigned int *)(a2 + 4);
}

uint64_t llvm::object::WasmObjectFile::getWasmSymbol(uint64_t a1, void *a2)
{
  return *(void *)(a1 + 536) + 32 * HIDWORD(*a2);
}

uint64_t llvm::object::WasmObjectFile::getSymbolValueImpl(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = *(void *)(*(void *)(a1 + 536) + ((a2 >> 27) & 0x1FFFFFFFE0));
  int v4 = *(unsigned __int8 *)(v3 + 16);
  if (((1 << v4) & 0x35) != 0) {
    return *(unsigned int *)(v3 + 96);
  }
  uint64_t result = 0;
  if (v4 == 1)
  {
    unsigned int v6 = *(_DWORD *)(v3 + 96);
    uint64_t v7 = *(void *)(a1 + 472);
    if (*(unsigned char *)(v7 + 104 * v6 + 24) == 65) {
      uint64_t v8 = *(int *)(v7 + 104 * v6 + 32);
    }
    else {
      uint64_t v8 = *(void *)(v7 + 104 * v6 + 32);
    }
    return *(void *)(v3 + 104) + v8;
  }
  return result;
}

uint64_t llvm::object::WasmObjectFile::getSymbolSectionIdImpl(unsigned int *a1, uint64_t a2)
{
  switch(*(unsigned char *)(*(void *)a2 + 16))
  {
    case 1:
      uint64_t v2 = a1 + 173;
      break;
    case 2:
      uint64_t v2 = a1 + 175;
      break;
    case 3:
      uint64_t v2 = (unsigned int *)(*(void *)a2 + 96);
      break;
    case 4:
      uint64_t v2 = a1 + 174;
      break;
    case 5:
      uint64_t v2 = a1 + 176;
      break;
    default:
      uint64_t v2 = a1 + 172;
      break;
  }
  return *v2;
}

uint64_t llvm::object::WasmObjectFile::getSymbolSectionId(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 536) + ((a2 >> 27) & 0x1FFFFFFFE0));
  switch(*(unsigned char *)(v2 + 16))
  {
    case 1:
      uint64_t v3 = (unsigned int *)(a1 + 692);
      break;
    case 2:
      uint64_t v3 = (unsigned int *)(a1 + 700);
      break;
    case 3:
      uint64_t v3 = (unsigned int *)(v2 + 96);
      break;
    case 4:
      uint64_t v3 = (unsigned int *)(a1 + 696);
      break;
    case 5:
      uint64_t v3 = (unsigned int *)(a1 + 704);
      break;
    default:
      uint64_t v3 = (unsigned int *)(a1 + 688);
      break;
  }
  return *v3;
}

uint64_t llvm::object::WasmObjectFile::getWasmSection(uint64_t a1, unsigned int a2)
{
  return *(void *)(a1 + 72) + 72 * a2;
}

uint64_t llvm::object::WasmObjectFile::getWasmRelocation(uint64_t a1, uint64_t a2)
{
  return *(void *)(*(void *)(a1 + 72) + 72 * a2 + 48) + 24 * HIDWORD(a2);
}

uint64_t llvm::object::WasmObjectFile::isSharedObject(llvm::object::WasmObjectFile *this)
{
  return *((unsigned __int8 *)this + 589);
}

uint64_t llvm::object::WasmObjectFile::getWasmSection(uint64_t a1, unsigned int *a2)
{
  return *(void *)(a1 + 72) + 72 * *a2;
}

uint64_t llvm::object::WasmObjectFile::getWasmRelocation(uint64_t a1, void *a2)
{
  return *(void *)(*(void *)(a1 + 72) + 72 * *a2 + 48) + 24 * HIDWORD(*a2);
}

uint64_t llvm::object::WasmSectionOrderChecker::getSectionOrder(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t result = a2;
  switch((int)a2)
  {
    case 0:
      if (a4 != 8)
      {
        if (a4 == 7)
        {
          if (*(_DWORD *)a3 == 1802398060 && *(_DWORD *)(a3 + 3) == 1735289195)
          {
            unint64_t v6 = 0x10000000FLL;
            goto LABEL_45;
          }
        }
        else if (a4 == 6)
        {
          BOOL v5 = (*(_DWORD *)a3 ^ 0x696C7964 | *(unsigned __int16 *)(a3 + 4) ^ 0x6B6E) == 0;
          goto LABEL_16;
        }
        unint64_t v6 = 0;
        goto LABEL_24;
      }
      BOOL v5 = *(void *)a3 == 0x302E6B6E696C7964;
LABEL_16:
      if (v5) {
        unint64_t v6 = 0x10000000ELL;
      }
      else {
        unint64_t v6 = 0;
      }
LABEL_24:
      unint64_t v8 = HIDWORD(v6);
      if (a4 < 6 || v8)
      {
        if (a4 == 4 && !v8)
        {
          uint64_t v10 = 0x100000011;
          BOOL v11 = *(_DWORD *)a3 == 1701667182;
          goto LABEL_42;
        }
      }
      else if (*(_DWORD *)a3 == 1869374834 && *(_WORD *)(a3 + 4) == 11875)
      {
        unint64_t v6 = 0x100000010;
        goto LABEL_45;
      }
      if (a4 == 9 && !v8)
      {
        uint64_t v12 = *(void *)a3 ^ 0x72656375646F7270 | *(unsigned __int8 *)(a3 + 8) ^ 0x73;
        uint64_t v10 = 0x100000012;
LABEL_41:
        BOOL v11 = v12 == 0;
LABEL_42:
        if (v11) {
          unint64_t v6 = v10;
        }
        goto LABEL_45;
      }
      if (a4 == 15 && !v8)
      {
        uint64_t v12 = *(void *)a3 ^ 0x665F746567726174 | *(void *)(a3 + 7) ^ 0x7365727574616566;
        uint64_t v10 = 0x100000013;
        goto LABEL_41;
      }
LABEL_45:
      if ((v6 & 0x300000000) != 0) {
        return v6;
      }
      else {
        return 0;
      }
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return result;
    case 6:
      return 7;
    case 7:
      return 8;
    case 8:
      return 9;
    case 9:
      return 10;
    case 10:
      return 12;
    case 11:
      return 13;
    case 12:
      return 11;
    case 13:
      return 6;
    default:
      return 0;
  }
}

void sub_1CCC84FB4()
{
}

uint64_t sub_1CCC8505C(uint64_t a1)
{
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  unsigned int v4 = 0;
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v7 = "malformed uleb128, extends past end";
  do
  {
    if (v5 + v2 == v6) {
      goto LABEL_9;
    }
    char v8 = *(unsigned char *)(v5 + v2);
    uint64_t v9 = v8 & 0x7F;
    if (v4 >= 0x40 && (v8 & 0x7F) != 0 || (unint64_t)(v9 << v4) >> v4 != v9)
    {
      uint64_t v7 = "uleb128 too big for uint64";
LABEL_9:
      llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
    }
    v3 += v9 << v4;
    v4 += 7;
    ++v2;
  }
  while (v8 < 0);
  *(void *)(a1 + 8) = v5 + v2;
  return v3;
}

uint64_t sub_1CCC850EC(uint64_t a1)
{
  uint64_t v1 = 0;
  uint64_t v2 = 0;
  unsigned int v3 = 0;
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = "malformed sleb128, extends past end";
  do
  {
    if (v4 + v1 == *(void *)(a1 + 16)) {
      goto LABEL_14;
    }
    char v6 = *(unsigned char *)(v4 + v1);
    uint64_t v7 = v6 & 0x7F;
    if (v3 >= 0x40)
    {
      if (((v2 >> 63) & 0x7F) != v7) {
        goto LABEL_13;
      }
    }
    else if (v3 == 63 && v7 != 127 && v7 != 0)
    {
LABEL_13:
      uint64_t v5 = "sleb128 too big for int64";
LABEL_14:
      llvm::report_fatal_error((llvm *)v5, (const llvm::Twine *)1);
    }
    v2 |= v7 << v3;
    v3 += 7;
    ++v1;
  }
  while (v6 < 0);
  BOOL v9 = (v6 & 0x40) == 0 || v3 > 0x3F;
  uint64_t v10 = -1 << v3;
  if (v9) {
    uint64_t v10 = 0;
  }
  *(void *)(a1 + 8) = v4 + v1;
  return v2 | v10;
}

void sub_1CCC851B4(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        char v6 = (void *)*((void *)v4 - 15);
        if (v6)
        {
          *((void *)v4 - 14) = v6;
          operator delete(v6);
        }
        v4 -= 128;
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1CCC85240(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        char v6 = (void *)*((void *)v4 - 3);
        if (v6)
        {
          *((void *)v4 - 2) = v6;
          operator delete(v6);
        }
        v4 -= 80;
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1CCC852CC(uint64_t a1, char *a2)
{
  uint64_t v4 = *(char **)(a1 + 8);
  if (v4 != a2)
  {
    uint64_t v5 = v4 - 24;
    do
    {
      char v6 = (char *)*((void *)v5 - 2);
      if (v5 != v6) {
        free(v6);
      }
      uint64_t v7 = (char *)*((void *)v5 - 5);
      if (v5 - 24 != v7) {
        free(v7);
      }
      char v8 = v5 - 40;
      v5 -= 64;
    }
    while (v8 != a2);
  }
  *(void *)(a1 + 8) = a2;
}

void sub_1CCC85340(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        char v6 = (void *)*((void *)v4 - 3);
        if (v6)
        {
          *((void *)v4 - 2) = v6;
          operator delete(v6);
        }
        v4 -= 72;
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1CCC853CC()
{
}

void sub_1CCC85448()
{
}

void sub_1CCC854B0()
{
}

char *sub_1CCC85518(void **a1, uint64_t a2)
{
  unsigned int v3 = (char *)*a1;
  uint64_t v2 = (char *)a1[1];
  unint64_t v4 = 0xEEEEEEEEEEEEEEEFLL * ((v2 - (unsigned char *)*a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x222222222222222) {
    abort();
  }
  if (0xDDDDDDDDDDDDDDDELL * (((unsigned char *)a1[2] - v3) >> 3) > v5) {
    unint64_t v5 = 0xDDDDDDDDDDDDDDDELL * (((unsigned char *)a1[2] - v3) >> 3);
  }
  if (0xEEEEEEEEEEEEEEEFLL * (((unsigned char *)a1[2] - v3) >> 3) >= 0x111111111111111) {
    unint64_t v8 = 0x222222222222222;
  }
  else {
    unint64_t v8 = v5;
  }
  if (v8)
  {
    if (v8 > 0x222222222222222) {
      sub_1CB833614();
    }
    BOOL v9 = (char *)operator new(120 * v8);
  }
  else
  {
    BOOL v9 = 0;
  }
  long long v10 = *(_OWORD *)(a2 + 80);
  BOOL v11 = &v9[120 * v4];
  *((_OWORD *)v11 + 4) = *(_OWORD *)(a2 + 64);
  *((_OWORD *)v11 + 5) = v10;
  *((_OWORD *)v11 + 6) = *(_OWORD *)(a2 + 96);
  *((void *)v11 + 14) = *(void *)(a2 + 112);
  long long v12 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)BOOL v11 = *(_OWORD *)a2;
  *((_OWORD *)v11 + 1) = v12;
  long long v13 = *(_OWORD *)(a2 + 32);
  long long v14 = *(_OWORD *)(a2 + 48);
  uint64_t v15 = v11 + 120;
  *((_OWORD *)v11 + 2) = v13;
  *((_OWORD *)v11 + 3) = v14;
  if (v2 != v3)
  {
    do
    {
      long long v16 = *(_OWORD *)(v2 - 120);
      long long v17 = *(_OWORD *)(v2 - 104);
      long long v18 = *(_OWORD *)(v2 - 88);
      *(_OWORD *)(v11 - 72) = *(_OWORD *)(v2 - 72);
      *(_OWORD *)(v11 - 88) = v18;
      *(_OWORD *)(v11 - 104) = v17;
      *(_OWORD *)(v11 - 120) = v16;
      long long v19 = *(_OWORD *)(v2 - 56);
      long long v20 = *(_OWORD *)(v2 - 40);
      long long v21 = *(_OWORD *)(v2 - 24);
      *((void *)v11 - 1) = *((void *)v2 - 1);
      *(_OWORD *)(v11 - 24) = v21;
      *(_OWORD *)(v11 - 40) = v20;
      *(_OWORD *)(v11 - 56) = v19;
      v11 -= 120;
      v2 -= 120;
    }
    while (v2 != v3);
    uint64_t v2 = (char *)*a1;
  }
  *a1 = v11;
  a1[1] = v15;
  a1[2] = &v9[120 * v8];
  if (v2) {
    operator delete(v2);
  }
  return v15;
}

char *sub_1CCC8567C(char **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v5 = *a1;
  char v6 = a1[1];
  uint64_t v7 = (v6 - *a1) >> 5;
  unint64_t v8 = v7 + 1;
  if ((unint64_t)(v7 + 1) >> 59) {
    abort();
  }
  uint64_t v10 = a1[2] - v5;
  if (v10 >> 4 > v8) {
    unint64_t v8 = v10 >> 4;
  }
  if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v11 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v11 = v8;
  }
  if (v11 >> 59) {
    sub_1CB833614();
  }
  long long v16 = (char *)operator new(32 * v11);
  long long v17 = &v16[32 * v7];
  *(void *)long long v17 = a2;
  *((void *)v17 + 1) = a3;
  *((void *)v17 + 2) = a4;
  *((void *)v17 + 3) = a5;
  long long v18 = v17 + 32;
  if (v6 == v5)
  {
    long long v19 = &v16[32 * v7];
  }
  else
  {
    do
    {
      long long v19 = v17 - 32;
      long long v20 = *((_OWORD *)v6 - 1);
      *((_OWORD *)v17 - 2) = *((_OWORD *)v6 - 2);
      *((_OWORD *)v17 - 1) = v20;
      v6 -= 32;
      v17 -= 32;
    }
    while (v6 != v5);
  }
  *a1 = v19;
  a1[1] = v18;
  a1[2] = &v16[32 * v11];
  if (v5) {
    operator delete(v5);
  }
  return v18;
}

void sub_1CCC8577C()
{
}

void sub_1CCC857E4()
{
}

char *sub_1CCC8584C(void **a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = 0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[1] - (unsigned char *)*a1) >> 4);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0x555555555555555) {
    abort();
  }
  if (0x5555555555555556 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 4) > v4) {
    unint64_t v4 = 0x5555555555555556 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 4);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v8 = 0x555555555555555;
  }
  else {
    unint64_t v8 = v4;
  }
  if (v8)
  {
    if (v8 > 0x555555555555555) {
      sub_1CB833614();
    }
    BOOL v9 = (char *)operator new(48 * v8);
  }
  else
  {
    BOOL v9 = 0;
  }
  uint64_t v10 = &v9[48 * v3];
  *(_OWORD *)uint64_t v10 = *(_OWORD *)a2;
  unint64_t v11 = &v9[48 * v8];
  *((void *)v10 + 2) = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_OWORD *)(v10 + 24) = *(_OWORD *)a3;
  *((void *)v10 + 5) = *(void *)(a3 + 16);
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)a3 = 0;
  long long v12 = v10 + 48;
  long long v13 = (char *)*a1;
  long long v14 = (char *)a1[1];
  if (v14 == *a1)
  {
    *a1 = v10;
    a1[1] = v12;
    a1[2] = v11;
  }
  else
  {
    do
    {
      long long v15 = *((_OWORD *)v14 - 3);
      *((void *)v10 - 4) = *((void *)v14 - 4);
      *((_OWORD *)v10 - 3) = v15;
      *((void *)v14 - 5) = 0;
      *((void *)v14 - 4) = 0;
      *((void *)v14 - 6) = 0;
      long long v16 = *(_OWORD *)(v14 - 24);
      *((void *)v10 - 1) = *((void *)v14 - 1);
      *(_OWORD *)(v10 - 24) = v16;
      v10 -= 48;
      *((void *)v14 - 2) = 0;
      *((void *)v14 - 1) = 0;
      *((void *)v14 - 3) = 0;
      v14 -= 48;
    }
    while (v14 != v13);
    long long v14 = (char *)*a1;
    uint64_t v17 = (uint64_t)a1[1];
    *a1 = v10;
    a1[1] = v12;
    a1[2] = v11;
    while ((char *)v17 != v14)
      uint64_t v17 = sub_1CD3C4FA4(v17 - 48);
  }
  if (v14) {
    operator delete(v14);
  }
  return v12;
}

void sub_1CCC859CC()
{
}

void sub_1CCC85A34()
{
}

_OWORD *sub_1CCC85A9C(void **a1, _OWORD *a2)
{
  unint64_t v3 = (char *)*a1;
  uint64_t v2 = (char *)a1[1];
  uint64_t v4 = (v2 - (unsigned char *)*a1) >> 6;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 58) {
    abort();
  }
  uint64_t v8 = (unsigned char *)a1[2] - v3;
  if (v8 >> 5 > v5) {
    unint64_t v5 = v8 >> 5;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFC0) {
    unint64_t v9 = 0x3FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  if (v9)
  {
    if (v9 >> 58) {
      sub_1CB833614();
    }
    uint64_t v10 = (char *)operator new(v9 << 6);
  }
  else
  {
    uint64_t v10 = 0;
  }
  unint64_t v11 = &v10[64 * v4];
  long long v12 = a2[1];
  *(_OWORD *)unint64_t v11 = *a2;
  *((_OWORD *)v11 + 1) = v12;
  long long v13 = a2[3];
  *((_OWORD *)v11 + 2) = a2[2];
  *((_OWORD *)v11 + 3) = v13;
  long long v14 = v11 + 64;
  if (v2 != v3)
  {
    do
    {
      long long v15 = *((_OWORD *)v2 - 4);
      long long v16 = *((_OWORD *)v2 - 3);
      long long v17 = *((_OWORD *)v2 - 1);
      *((_OWORD *)v11 - 2) = *((_OWORD *)v2 - 2);
      *((_OWORD *)v11 - 1) = v17;
      *((_OWORD *)v11 - 4) = v15;
      *((_OWORD *)v11 - 3) = v16;
      v11 -= 64;
      v2 -= 64;
    }
    while (v2 != v3);
    uint64_t v2 = (char *)*a1;
  }
  *a1 = v11;
  a1[1] = v14;
  a1[2] = &v10[64 * v9];
  if (v2) {
    operator delete(v2);
  }
  return v14;
}

void sub_1CCC85B90()
{
}

void sub_1CCC85BF8()
{
}

uint64_t llvm::getMachineType(uint64_t a1, uint64_t a2)
{
  v14[0] = a1;
  v14[1] = a2;
  llvm::StringRef::lower((llvm::StringRef *)v14, v12);
  if (v13 >= 0) {
    uint64_t v2 = v12;
  }
  else {
    uint64_t v2 = (void **)v12[0];
  }
  unint64_t v3 = (void *)(v13 & 0x7F);
  if (v13 < 0) {
    unint64_t v3 = v12[1];
  }
  if (v3 == (void *)5)
  {
    if (*(_DWORD *)v2 == 912551265 && *((unsigned char *)v2 + 4) == 52) {
      goto LABEL_39;
    }
    BOOL v8 = (*(_DWORD *)v2 ^ 0x366D7261 | *((unsigned __int8 *)v2 + 4) ^ 0x34) == 0;
    uint64_t v9 = 43620;
LABEL_28:
    unint64_t v10 = v9 & 0xFFFF0000FFFFFFFFLL | 0x100000000;
    if (v8) {
      unint64_t v5 = v10;
    }
    else {
      unint64_t v5 = 0;
    }
    if (v13 < 0) {
      goto LABEL_32;
    }
    goto LABEL_35;
  }
  if (v3 == (void *)4)
  {
    BOOL v8 = *(_DWORD *)v2 == 909652841;
    uint64_t v9 = 332;
    goto LABEL_28;
  }
  if (v3 != (void *)3)
  {
    unint64_t v5 = 0;
    goto LABEL_34;
  }
  if (*(_WORD *)v2 == 13944 && *((unsigned char *)v2 + 2) == 52)
  {
LABEL_39:
    unint64_t v5 = 0x100008664;
    if ((v13 & 0x80000000) == 0) {
      goto LABEL_35;
    }
LABEL_32:
    operator delete(v12[0]);
    goto LABEL_35;
  }
  unint64_t v5 = 0x10000014CLL;
  if (*(_WORD *)v2 == 14456 && *((unsigned char *)v2 + 2) == 54)
  {
LABEL_34:
    if ((v13 & 0x80000000) == 0) {
      goto LABEL_35;
    }
    goto LABEL_32;
  }
  if (*(unsigned __int16 *)v2 ^ 0x7261 | *((unsigned __int8 *)v2 + 2) ^ 0x6D) {
    unint64_t v5 = 0;
  }
  else {
    unint64_t v5 = 0x1000001C4;
  }
  if (v13 < 0) {
    goto LABEL_32;
  }
LABEL_35:
  if (v5 <= 0x100000000) {
    return 0x100000000;
  }
  else {
    return v5;
  }
}

const char *llvm::machineToStr(int a1)
{
  if (a1 > 34403)
  {
    if (a1 == 34404) {
      return "x64";
    }
    else {
      return "arm64";
    }
  }
  else if (a1 == 332)
  {
    return "x86";
  }
  else
  {
    return "arm";
  }
}

uint64_t llvm::object::WindowsResource::WindowsResource(uint64_t result, long long *a2)
{
  long long v2 = *a2;
  long long v3 = a2[1];
  *(_DWORD *)(result + 8) = 7;
  *(_OWORD *)(result + 16) = v2;
  *(_OWORD *)(result + 32) = v3;
  *(void *)uint64_t result = &unk_1F2634468;
  *(void *)(result + 48) = &unk_1F2632A10;
  uint64_t v4 = *(void *)(result + 16);
  unint64_t v5 = *(void *)(result + 24);
  uint64_t v6 = 32;
  if (v5 < 0x20) {
    uint64_t v6 = *(void *)(result + 24);
  }
  uint64_t v7 = v4 + v6;
  *(_DWORD *)(result + 56) = 1;
  *(void *)(result + 64) = v7;
  *(void *)(result + 72) = v4 + v5 - v7;
  return result;
}

{
  long long v2;
  long long v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;

  long long v3 = *a2;
  long long v2 = a2[1];
  *(_DWORD *)(result + 8) = 7;
  *(_OWORD *)(result + 16) = v3;
  *(_OWORD *)(result + 32) = v2;
  *(void *)uint64_t result = &unk_1F2634468;
  *(void *)(result + 48) = &unk_1F2632A10;
  uint64_t v4 = *(void *)(result + 16);
  unint64_t v5 = *(void *)(result + 24);
  uint64_t v6 = 32;
  if (v5 < 0x20) {
    uint64_t v6 = *(void *)(result + 24);
  }
  uint64_t v7 = v4 + v6;
  *(_DWORD *)(result + 56) = 1;
  *(void *)(result + 64) = v7;
  *(void *)(result + 72) = v4 + v5 - v7;
  return result;
}

void llvm::object::WindowsResource::getHeadEntry(llvm::object::WindowsResource *this@<X0>, uint64_t a2@<X8>)
{
  if (*((void *)this + 9) <= 0x17uLL) {
    operator new();
  }
  llvm::BinaryStreamRef::BinaryStreamRef((uint64_t)v5, (uint64_t)this + 48);
  llvm::object::ResourceEntryRef::create((uint64_t)v5, (uint64_t)this, a2);
  uint64_t v4 = v6;
  if (v6)
  {
    if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void *llvm::object::ResourceEntryRef::create@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 8);
  v15[0] = *(void *)a1;
  v15[1] = (uint64_t)v4;
  if (v4)
  {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    long long v5 = *(_OWORD *)(a1 + 32);
    long long v16 = *(_OWORD *)(a1 + 16);
    long long v17 = v5;
    llvm::object::ResourceEntryRef::ResourceEntryRef((uint64_t)v18, v15, a2);
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  else
  {
    long long v6 = *(_OWORD *)(a1 + 32);
    long long v16 = *(_OWORD *)(a1 + 16);
    long long v17 = v6;
    llvm::object::ResourceEntryRef::ResourceEntryRef((uint64_t)v18, v15, a2);
  }
  llvm::object::ResourceEntryRef::loadNext((llvm::object::ResourceEntryRef *)v18, &v14);
  uint64_t v7 = v14;
  if (v14)
  {
    *(unsigned char *)(a3 + 152) |= 1u;
    *(void *)a3 = v7;
  }
  else
  {
    *(unsigned char *)(a3 + 152) &= ~1u;
    uint64_t v9 = v18[1];
    uint64_t v8 = v18[2];
    *(void *)a3 = &unk_1F2632A58;
    *(void *)(a3 + 8) = v9;
    *(void *)(a3 + 16) = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
    *(_OWORD *)(a3 + 24) = v19;
    *(_OWORD *)(a3 + 40) = v20;
    long long v10 = v25;
    long long v11 = v26;
    long long v12 = v23;
    *(_OWORD *)(a3 + 96) = v24;
    *(_OWORD *)(a3 + 112) = v10;
    *(void *)(a3 + 56) = v21;
    *(_OWORD *)(a3 + 128) = v11;
    *(void *)(a3 + 144) = v27;
    *(_OWORD *)(a3 + 64) = v22;
    *(_OWORD *)(a3 + 80) = v12;
  }
  return sub_1CCC22DBC(v18);
}

uint64_t llvm::object::ResourceEntryRef::ResourceEntryRef(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = *a2;
  long long v6 = (std::__shared_weak_count *)a2[1];
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  long long v8 = *((_OWORD *)a2 + 1);
  long long v9 = *((_OWORD *)a2 + 2);
  *(void *)a1 = &unk_1F2632A58;
  *(void *)(a1 + 8) = v5;
  *(void *)(a1 + 16) = v6;
  if (v6)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    *(_OWORD *)(a1 + 24) = v8;
    *(_OWORD *)(a1 + 40) = v9;
    *(void *)(a1 + 56) = 0;
    if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  else
  {
    *(_OWORD *)(a1 + 24) = v8;
    *(_OWORD *)(a1 + 40) = v9;
    *(void *)(a1 + 56) = 0;
  }
  *(void *)(a1 + 64) = a3;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 128) = 0;
  return a1;
}

uint64_t llvm::object::ResourceEntryRef::loadNext@<X0>(llvm::object::ResourceEntryRef *this@<X0>, void *a2@<X8>)
{
  long long v10 = 0;
  uint64_t v11 = 0;
  uint64_t result = llvm::BinaryStreamReader::readBytes((uint64_t)this, 8u, a2);
  if (!*a2)
  {
    uint64_t v5 = v10;
    *a2 = 0;
    if (v5[1] <= 0x1F)
    {
      uint64_t v6 = *((void *)this + 8);
      long long v8 = *(unsigned int **)(v6 + 32);
      uint64_t v7 = *(void *)(v6 + 40);
      __int16 v13 = 773;
      long long v10 = v8;
      uint64_t v11 = v7;
      long long v12 = ": header size too small";
      operator new();
    }
    uint64_t result = sub_1CCC864FC(a2, (uint64_t)this, (_WORD *)this + 48, (void *)this + 10, (BOOL *)this + 72);
    if (!*a2)
    {
      uint64_t result = sub_1CCC864FC(a2, (uint64_t)this, (_WORD *)this + 60, (void *)this + 13, (BOOL *)this + 98);
      if (!*a2)
      {
        uint64_t result = llvm::BinaryStreamReader::skip(this, ((*((void *)this + 7) + 3) & 0xFFFFFFFC) - *((void *)this + 7), a2);
        if (!*a2)
        {
          long long v10 = 0;
          uint64_t v11 = 0;
          uint64_t result = llvm::BinaryStreamReader::readBytes((uint64_t)this, 0x10u, a2);
          if (!*a2)
          {
            *((void *)this + 16) = v10;
            *a2 = 0;
            uint64_t v9 = *v5;
            long long v10 = 0;
            uint64_t v11 = 0;
            if (v9)
            {
              uint64_t result = llvm::BinaryStreamReader::readBytes((uint64_t)this, v9, a2);
              if (*a2) {
                return result;
              }
              *((void *)this + 17) = v10;
              *((void *)this + 18) = v9;
            }
            else
            {
              *((void *)this + 17) = 0;
              *((void *)this + 18) = 0;
            }
            *a2 = 0;
            uint64_t result = llvm::BinaryStreamReader::skip(this, ((*((void *)this + 7) + 3) & 0xFFFFFFFC) - *((void *)this + 7), a2);
            if (!*a2) {
              *a2 = 0;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t llvm::object::ResourceEntryRef::moveNext@<X0>(uint64_t this@<X0>, BOOL *a2@<X1>, void *a3@<X8>)
{
  uint64_t v4 = (llvm::object::ResourceEntryRef *)this;
  if (*(unsigned char *)(this + 48))
  {
    uint64_t v6 = *(void *)(this + 40);
  }
  else
  {
    this = *(void *)(this + 24);
    if (this)
    {
      this = (*(uint64_t (**)(uint64_t))(*(void *)this + 40))(this);
      uint64_t v6 = this - *((void *)v4 + 4);
    }
    else
    {
      uint64_t v6 = 0;
    }
  }
  if (v6 == *((void *)v4 + 7))
  {
    *a2 = 1;
  }
  else
  {
    this = llvm::object::ResourceEntryRef::loadNext(v4, a3);
    if (*a3) {
      return this;
    }
  }
  *a3 = 0;
  return this;
}

uint64_t sub_1CCC864FC(void *a1, uint64_t a2, _WORD *a3, void *a4, BOOL *a5)
{
  unsigned __int16 v12 = 0;
  uint64_t result = sub_1CD6C7F64(a2, &v12, a1);
  if (!*a1)
  {
    BOOL v11 = v12 == 0xFFFF;
    *a5 = v12 != 0xFFFF;
    if (v11)
    {
      uint64_t result = sub_1CD6C7F64(a2, a3, a1);
    }
    else
    {
      *(void *)(a2 + 56) -= 2;
      uint64_t result = llvm::BinaryStreamReader::readWideString(a2, a4, a1);
    }
    if (!*a1) {
      *a1 = 0;
    }
  }
  return result;
}

double llvm::object::WindowsResourceParser::WindowsResourceParser(llvm::object::WindowsResourceParser *this, char a2)
{
  *(unsigned char *)this = 0;
  *((_DWORD *)this + 1) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 2) = (char *)this + 24;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = (char *)this + 48;
  double result = 0.0;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((void *)this + 18) = 0;
  *((unsigned char *)this + 152) = a2;
  return result;
}

{
  double result;

  *(unsigned char *)this = 0;
  *((_DWORD *)this + 1) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 2) = (char *)this + 24;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = (char *)this + 48;
  double result = 0.0;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((void *)this + 18) = 0;
  *((unsigned char *)this + 152) = a2;
  return result;
}

uint64_t llvm::object::WindowsResourceParser::TreeNode::TreeNode(uint64_t this, int a2)
{
  *(unsigned char *)this = 0;
  *(_DWORD *)(this + 4) = a2;
  *(void *)(this + 24) = 0;
  *(void *)(this + 16) = this + 24;
  *(void *)(this + 56) = 0;
  *(void *)(this + 64) = 0;
  *(void *)(this + 48) = 0;
  *(void *)(this + 32) = 0;
  *(void *)(this + 40) = this + 48;
  return this;
}

{
  *(unsigned char *)this = 0;
  *(_DWORD *)(this + 4) = a2;
  *(void *)(this + 24) = 0;
  *(void *)(this + 16) = this + 24;
  *(void *)(this + 56) = 0;
  *(void *)(this + 64) = 0;
  *(void *)(this + 48) = 0;
  *(void *)(this + 32) = 0;
  *(void *)(this + 40) = this + 48;
  return this;
}

llvm::raw_ostream *llvm::object::printResourceTypeName(llvm::raw_ostream *this, llvm::raw_ostream *a2, llvm::raw_ostream *a3)
{
  unsigned int v4 = this;
  switch((int)this)
  {
    case 1:
      uint64_t v5 = (void *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v5 <= 0xCuLL)
      {
        uint64_t v6 = "CURSOR (ID 1)";
        goto LABEL_12;
      }
      long long v19 = "CURSOR (ID 1)";
      goto LABEL_63;
    case 2:
      uint64_t v5 = (void *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v5 <= 0xCuLL)
      {
        uint64_t v6 = "BITMAP (ID 2)";
        goto LABEL_12;
      }
      long long v19 = "BITMAP (ID 2)";
      goto LABEL_63;
    case 3:
      uint64_t v7 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v7) <= 0xA)
      {
        uint64_t v6 = "ICON (ID 3)";
        goto LABEL_45;
      }
      int v20 = 691216452;
      uint64_t v21 = "ICON (ID 3)";
      goto LABEL_80;
    case 4:
      uint64_t v7 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v7) <= 0xA)
      {
        uint64_t v6 = "MENU (ID 4)";
        goto LABEL_45;
      }
      int v20 = 691281988;
      uint64_t v21 = "MENU (ID 4)";
      goto LABEL_80;
    case 5:
      uint64_t v5 = (void *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v5 <= 0xCuLL)
      {
        uint64_t v6 = "DIALOG (ID 5)";
LABEL_12:
        long long v8 = a2;
        size_t v9 = 13;
        goto LABEL_55;
      }
      long long v19 = "DIALOG (ID 5)";
LABEL_63:
      *uint64_t v5 = *(void *)v19;
      *(void *)((char *)v5 + 5) = *(void *)(v19 + 5);
      uint64_t v22 = *((void *)a2 + 4) + 13;
      goto LABEL_86;
    case 6:
      uint64_t v10 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v10) <= 0x11)
      {
        uint64_t v6 = "STRINGTABLE (ID 6)";
        goto LABEL_40;
      }
      __int16 v23 = 10550;
      long long v24 = "STRINGTABLE (ID 6)";
      goto LABEL_77;
    case 7:
      BOOL v11 = (void *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v11 <= 0xDuLL)
      {
        uint64_t v6 = "FONTDIR (ID 7)";
        goto LABEL_23;
      }
      long long v25 = "FONTDIR (ID 7)";
      goto LABEL_69;
    case 8:
      uint64_t v7 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v7) <= 0xA)
      {
        uint64_t v6 = "FONT (ID 8)";
        goto LABEL_45;
      }
      int v20 = 691544132;
      uint64_t v21 = "FONT (ID 8)";
      goto LABEL_80;
    case 9:
      uint64_t v10 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v10) <= 0x11)
      {
        uint64_t v6 = "ACCELERATOR (ID 9)";
        goto LABEL_40;
      }
      __int16 v23 = 10553;
      long long v24 = "ACCELERATOR (ID 9)";
      goto LABEL_77;
    case 10:
      BOOL v11 = (void *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v11 <= 0xDuLL)
      {
        uint64_t v6 = "RCDATA (ID 10)";
LABEL_23:
        long long v8 = a2;
        size_t v9 = 14;
        goto LABEL_55;
      }
      long long v25 = "RCDATA (ID 10)";
LABEL_69:
      *BOOL v11 = *(void *)v25;
      *(void *)((char *)v11 + 6) = *(void *)(v25 + 6);
      uint64_t v22 = *((void *)a2 + 4) + 14;
      goto LABEL_86;
    case 11:
      uint64_t v12 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v12) <= 0x13)
      {
        uint64_t v6 = "MESSAGETABLE (ID 11)";
        goto LABEL_28;
      }
      int v26 = 691089696;
      uint64_t v27 = "MESSAGETABLE (ID 11)";
      goto LABEL_72;
    case 12:
      uint64_t v12 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v12) <= 0x13)
      {
        uint64_t v6 = "GROUP_CURSOR (ID 12)";
LABEL_28:
        long long v8 = a2;
        size_t v9 = 20;
        goto LABEL_55;
      }
      int v26 = 691155232;
      uint64_t v27 = "GROUP_CURSOR (ID 12)";
LABEL_72:
      *(_DWORD *)(v12 + 16) = v26;
      *(_OWORD *)uint64_t v12 = *(_OWORD *)v27;
      uint64_t v22 = *((void *)a2 + 4) + 20;
      goto LABEL_86;
    case 14:
      uint64_t v10 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v10) <= 0x11)
      {
        uint64_t v6 = "GROUP_ICON (ID 14)";
        goto LABEL_40;
      }
      __int16 v23 = 10548;
      long long v24 = "GROUP_ICON (ID 14)";
      goto LABEL_77;
    case 16:
      uint64_t v14 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v14) <= 0x12)
      {
        uint64_t v6 = "VERSIONINFO (ID 16)";
        long long v8 = a2;
        size_t v9 = 19;
        goto LABEL_55;
      }
      *(_DWORD *)(v14 + 15) = 691417376;
      *(_OWORD *)uint64_t v14 = *(_OWORD *)"VERSIONINFO (ID 16)";
      uint64_t v22 = *((void *)a2 + 4) + 19;
      goto LABEL_86;
    case 17:
      uint64_t v10 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v10) <= 0x11)
      {
        uint64_t v6 = "DLGINCLUDE (ID 17)";
LABEL_40:
        long long v8 = a2;
        size_t v9 = 18;
        goto LABEL_55;
      }
      __int16 v23 = 10551;
      long long v24 = "DLGINCLUDE (ID 17)";
LABEL_77:
      *(_WORD *)(v10 + 16) = v23;
      *(_OWORD *)uint64_t v10 = *(_OWORD *)v24;
      uint64_t v22 = *((void *)a2 + 4) + 18;
      goto LABEL_86;
    case 19:
      long long v15 = (_OWORD *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v15 <= 0xFuLL)
      {
        uint64_t v6 = "PLUGPLAY (ID 19)";
        goto LABEL_54;
      }
      long long v28 = "PLUGPLAY (ID 19)";
      goto LABEL_85;
    case 20:
      uint64_t v7 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v7) <= 0xA)
      {
        uint64_t v6 = "VXD (ID 20)";
LABEL_45:
        long long v8 = a2;
        size_t v9 = 11;
        goto LABEL_55;
      }
      int v20 = 691024416;
      uint64_t v21 = "VXD (ID 20)";
LABEL_80:
      *(_DWORD *)(v7 + 7) = v20;
      *(void *)uint64_t v7 = *(void *)v21;
      uint64_t v22 = *((void *)a2 + 4) + 11;
      goto LABEL_86;
    case 21:
      uint64_t v16 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v16) <= 0x10)
      {
        uint64_t v6 = "ANICURSOR (ID 21)";
        long long v8 = a2;
        size_t v9 = 17;
        goto LABEL_55;
      }
      *(unsigned char *)(v16 + 16) = 41;
      *(_OWORD *)uint64_t v16 = *(_OWORD *)"ANICURSOR (ID 21)";
      uint64_t v22 = *((void *)a2 + 4) + 17;
      goto LABEL_86;
    case 22:
      long long v17 = (void *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v17 <= 0xEuLL)
      {
        uint64_t v6 = "ANIICON (ID 22)";
        long long v8 = a2;
        size_t v9 = 15;
        goto LABEL_55;
      }
      qmemcpy(v17, "ANIICON (ID 22)", 15);
      uint64_t v22 = *((void *)a2 + 4) + 15;
      goto LABEL_86;
    case 23:
      uint64_t v18 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v18) <= 0xB)
      {
        uint64_t v6 = "HTML (ID 23)";
        long long v8 = a2;
        size_t v9 = 12;
        goto LABEL_55;
      }
      *(_DWORD *)(v18 + 8) = 691221024;
      *(void *)uint64_t v18 = *(void *)"HTML (ID 23)";
      uint64_t v22 = *((void *)a2 + 4) + 12;
      goto LABEL_86;
    case 24:
      long long v15 = (_OWORD *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v15 > 0xFuLL)
      {
        long long v28 = "MANIFEST (ID 24)";
LABEL_85:
        _OWORD *v15 = *(_OWORD *)v28;
        uint64_t v22 = *((void *)a2 + 4) + 16;
LABEL_86:
        *((void *)a2 + 4) = v22;
      }
      else
      {
        uint64_t v6 = "MANIFEST (ID 24)";
LABEL_54:
        long long v8 = a2;
        size_t v9 = 16;
LABEL_55:
        return llvm::raw_ostream::write(v8, v6, v9);
      }
      return this;
    default:
      uint64_t v13 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v13) > 2)
      {
        *(unsigned char *)(v13 + 2) = 32;
        *(_WORD *)uint64_t v13 = 17481;
        *((void *)a2 + 4) += 3;
      }
      else
      {
        llvm::raw_ostream::write(a2, "ID ", 3uLL);
      }
      return sub_1CD098D14(a2, v4, 0, 0, 0);
  }
}

void llvm::object::WindowsResourceParser::cleanUpManifests(void *a1, int64x2_t *a2)
{
  uint64_t v2 = a1[3];
  if (v2)
  {
    uint64_t v5 = a1 + 3;
    do
    {
      unsigned int v6 = *(_DWORD *)(v2 + 32);
      BOOL v7 = v6 >= 0x18;
      if (v6 >= 0x18) {
        long long v8 = (uint64_t *)v2;
      }
      else {
        long long v8 = (uint64_t *)(v2 + 8);
      }
      if (v7) {
        uint64_t v5 = (void *)v2;
      }
      uint64_t v2 = *v8;
    }
    while (*v8);
    if (v5 != a1 + 3 && *((_DWORD *)v5 + 8) <= 0x18u)
    {
      uint64_t v9 = v5[5];
      uint64_t v12 = *(void *)(v9 + 24);
      uint64_t v10 = v9 + 24;
      uint64_t v11 = v12;
      if (v12)
      {
        uint64_t v13 = v10;
        do
        {
          int v14 = *(_DWORD *)(v11 + 32);
          BOOL v15 = v14 == 0;
          if (v14) {
            uint64_t v16 = (uint64_t *)v11;
          }
          else {
            uint64_t v16 = (uint64_t *)(v11 + 8);
          }
          if (!v15) {
            uint64_t v13 = v11;
          }
          uint64_t v11 = *v16;
        }
        while (*v16);
        if (v13 != v10 && *(_DWORD *)(v13 + 32) <= 1u)
        {
          long long v17 = *(void **)(v13 + 40);
          unint64_t v18 = v17[4];
          if (v18 >= 2)
          {
            long long v19 = v17 + 3;
            int v20 = v17 + 3;
            do
            {
              uint64_t v21 = v20;
              int v20 = (void *)*v20;
            }
            while (v20);
            if (v21 == v19) {
              goto LABEL_27;
            }
            if (*((_DWORD *)v21 + 8)) {
              goto LABEL_27;
            }
            uint64_t v43 = v21[5];
            if (!*(unsigned char *)v43) {
              goto LABEL_27;
            }
            unsigned int v44 = *(_DWORD *)(v43 + 8);
            uint64_t v45 = (void *)v21[1];
            if (v45)
            {
              do
              {
                uint64_t v46 = v45;
                uint64_t v45 = (void *)*v45;
              }
              while (v45);
            }
            else
            {
              uint64_t v53 = v21;
              do
              {
                uint64_t v46 = (void *)v53[2];
                BOOL v15 = *v46 == (void)v53;
                uint64_t v53 = v46;
              }
              while (!v15);
            }
            if ((void *)v17[2] == v21) {
              v17[2] = v46;
            }
            v17[4] = v18 - 1;
            sub_1CB91F7C8((uint64_t *)v17[3], v21);
            sub_1CCC8AF78(v21 + 5);
            operator delete(v21);
            uint64_t v54 = a1[11];
            uint64_t v55 = a1[10] + 24 * v44;
            uint64_t v56 = v55 + 24;
            if (v55 + 24 != v54)
            {
              do
              {
                __int16 v57 = *(void **)(v56 - 24);
                if (v57)
                {
                  *(void *)(v56 - 16) = v57;
                  operator delete(v57);
                  *(void *)(v56 - 16) = 0;
                  *(void *)(v56 - 8) = 0;
                }
                *(_OWORD *)(v56 - 24) = *(_OWORD *)v56;
                *(void *)(v56 - 8) = *(void *)(v56 + 16);
                *(void *)uint64_t v56 = 0;
                *(void *)(v56 + 8) = 0;
                *(void *)(v56 + 16) = 0;
                v56 += 24;
                v55 += 24;
              }
              while (v56 != v54);
              uint64_t v54 = a1[11];
            }
            if (v54 != v55)
            {
              uint64_t v58 = v54;
              do
              {
                uint64_t v60 = *(void **)(v58 - 24);
                v58 -= 24;
                int v59 = v60;
                if (v60)
                {
                  *(void *)(v54 - 16) = v59;
                  operator delete(v59);
                }
                uint64_t v54 = v58;
              }
              while (v58 != v55);
            }
            a1[11] = v55;
            llvm::object::WindowsResourceParser::TreeNode::shiftDataIndexDown((uint64_t)a1, v44);
            if (v17[4] >= 2uLL)
            {
LABEL_27:
              uint64_t v22 = v17[2];
              __int16 v23 = (void *)v17[3];
              uint64_t v24 = *(unsigned int *)(v22 + 32);
              uint64_t v25 = *(void *)(v22 + 40);
              if (v23)
              {
                uint64_t v26 = v17[3];
                do
                {
                  uint64_t v27 = v26;
                  uint64_t v26 = *(void *)(v26 + 8);
                }
                while (v26);
              }
              else
              {
                long long v28 = v17 + 3;
                do
                {
                  uint64_t v27 = v28[2];
                  BOOL v15 = *(void *)v27 == (void)v28;
                  long long v28 = (void *)v27;
                }
                while (v15);
              }
              uint64_t v29 = *(unsigned int *)(v27 + 32);
              if (v23)
              {
                do
                {
                  unint64_t v30 = v23;
                  __int16 v23 = (void *)v23[1];
                }
                while (v23);
              }
              else
              {
                do
                {
                  unint64_t v30 = (void *)v19[2];
                  BOOL v15 = *v30 == (void)v19;
                  long long v19 = v30;
                }
                while (v15);
              }
              uint64_t v31 = v30[5];
              v61[0] = "duplicate non-default manifests with languages ";
              v61[2] = v24;
              __int16 v62 = 2051;
              v63[0] = v61;
              v63[2] = " in ";
              __int16 v64 = 770;
              uint64_t v32 = a1[16];
              uint64_t v33 = v32 + 24 * *(unsigned int *)(v25 + 72);
              v65[0] = v63;
              v65[2] = v33;
              __int16 v66 = 1026;
              v67[0] = v65;
              v67[2] = " and ";
              __int16 v68 = 770;
              v69[0] = v67;
              v69[2] = v29;
              __int16 v70 = 2050;
              v71[0] = v69;
              void v71[2] = " in ";
              __int16 v72 = 770;
              uint64_t v34 = v32 + 24 * *(unsigned int *)(v31 + 72);
              v73[0] = v71;
              v73[2] = v34;
              __int16 v74 = 1026;
              llvm::Twine::str((llvm::Twine *)v73, &v75);
              unint64_t v35 = a2[1].u64[0];
              unint64_t v36 = a2->u64[1];
              if (v36 >= v35)
              {
                uint64_t v38 = a2->i64[0];
                unint64_t v39 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v36 - a2->i64[0]) >> 3);
                unint64_t v40 = v39 + 1;
                if (v39 + 1 > 0xAAAAAAAAAAAAAAALL) {
                  abort();
                }
                if (0x5555555555555556 * ((uint64_t)(v35 - v38) >> 3) > v40) {
                  unint64_t v40 = 0x5555555555555556 * ((uint64_t)(v35 - v38) >> 3);
                }
                if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v35 - v38) >> 3) >= 0x555555555555555) {
                  unint64_t v41 = 0xAAAAAAAAAAAAAAALL;
                }
                else {
                  unint64_t v41 = v40;
                }
                uint64_t v80 = a2 + 1;
                if (v41)
                {
                  if (v41 > 0xAAAAAAAAAAAAAAALL) {
                    sub_1CB833614();
                  }
                  uint64_t v42 = (char *)operator new(24 * v41);
                }
                else
                {
                  uint64_t v42 = 0;
                }
                uint64_t v47 = &v42[24 * v39];
                *(_OWORD *)uint64_t v47 = v75;
                *((void *)v47 + 2) = v76;
                uint64_t v76 = 0;
                long long v75 = 0uLL;
                if (v36 == v38)
                {
                  int64x2_t v50 = vdupq_n_s64(v36);
                  uint64_t v48 = &v42[24 * v39];
                }
                else
                {
                  uint64_t v48 = &v42[24 * v39];
                  do
                  {
                    long long v49 = *(_OWORD *)(v36 - 24);
                    *((void *)v48 - 1) = *(void *)(v36 - 8);
                    *(_OWORD *)(v48 - 24) = v49;
                    v48 -= 24;
                    *(void *)(v36 - 16) = 0;
                    *(void *)(v36 - 8) = 0;
                    *(void *)(v36 - 24) = 0;
                    v36 -= 24;
                  }
                  while (v36 != v38);
                  int64x2_t v50 = *a2;
                  unint64_t v35 = a2[1].u64[0];
                }
                int v51 = v47 + 24;
                a2->i64[0] = (uint64_t)v48;
                a2->i64[1] = (uint64_t)(v47 + 24);
                int64x2_t v78 = v50;
                a2[1].i64[0] = (uint64_t)&v42[24 * v41];
                unint64_t v79 = v35;
                uint64_t v77 = v50.i64[0];
                sub_1CBF4EE0C((uint64_t)&v77);
                int v52 = SHIBYTE(v76);
                a2->i64[1] = (uint64_t)v51;
                if (v52 < 0) {
                  operator delete((void *)v75);
                }
              }
              else
              {
                long long v37 = v75;
                *(void *)(v36 + 16) = v76;
                *(_OWORD *)unint64_t v36 = v37;
                a2->i64[1] = v36 + 24;
              }
            }
          }
        }
      }
    }
  }
}

uint64_t llvm::object::WindowsResourceParser::TreeNode::shiftDataIndexDown(uint64_t this, unsigned int a2)
{
  uint64_t v3 = this;
  if (*(unsigned char *)this && (unsigned int v4 = *(_DWORD *)(this + 8), v4 >= a2))
  {
    *(_DWORD *)(this + 8) = v4 - 1;
  }
  else
  {
    uint64_t v5 = *(void **)(this + 16);
    unsigned int v6 = (void *)(this + 24);
    if (v5 != (void *)(this + 24))
    {
      do
      {
        this = llvm::object::WindowsResourceParser::TreeNode::shiftDataIndexDown((llvm::object::WindowsResourceParser::TreeNode *)v5[5], a2);
        BOOL v7 = (void *)v5[1];
        if (v7)
        {
          do
          {
            long long v8 = v7;
            BOOL v7 = (void *)*v7;
          }
          while (v7);
        }
        else
        {
          do
          {
            long long v8 = (void *)v5[2];
            BOOL v9 = *v8 == (void)v5;
            uint64_t v5 = v8;
          }
          while (!v9);
        }
        uint64_t v5 = v8;
      }
      while (v8 != v6);
    }
    uint64_t v10 = *(void **)(v3 + 40);
    uint64_t v11 = (void *)(v3 + 48);
    if (v10 != v11)
    {
      do
      {
        this = llvm::object::WindowsResourceParser::TreeNode::shiftDataIndexDown((llvm::object::WindowsResourceParser::TreeNode *)v10[7], a2);
        uint64_t v12 = (void *)v10[1];
        if (v12)
        {
          do
          {
            uint64_t v13 = v12;
            uint64_t v12 = (void *)*v12;
          }
          while (v12);
        }
        else
        {
          do
          {
            uint64_t v13 = (void *)v10[2];
            BOOL v9 = *v13 == (void)v10;
            uint64_t v10 = v13;
          }
          while (!v9);
        }
        uint64_t v10 = v13;
      }
      while (v13 != v11);
    }
  }
  return this;
}

BOOL llvm::object::WindowsResourceParser::shouldIgnoreDuplicate(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 152)) {
    BOOL v2 = *(unsigned char *)(a2 + 72) == 0;
  }
  else {
    BOOL v2 = 0;
  }
  return v2
      && *(_WORD *)(a2 + 96) == 24
      && *(unsigned char *)(a2 + 98) == 0
      && *(_WORD *)(a2 + 120) == 1
      && *(_WORD *)(*(void *)(a2 + 128) + 6) == 0;
}

BOOL llvm::object::WindowsResourceParser::shouldIgnoreDuplicate(uint64_t a1, uint64_t *a2)
{
  if (*(unsigned char *)(a1 + 152)
    && (uint64_t v2 = *a2, a2[1] - *a2 == 96)
    && !*(unsigned char *)v2
    && *(_DWORD *)(v2 + 24) == 24
    && !*(unsigned char *)(v2 + 32)
    && *(_DWORD *)(v2 + 56) == 1
    && !*(unsigned char *)(v2 + 64))
  {
    return *(_DWORD *)(v2 + 88) == 0;
  }
  else
  {
    return 0;
  }
}

void *llvm::object::WindowsResourceParser::parse@<X0>(size_t *this@<X1>, int64x2_t *a2@<X0>, void *a3@<X8>)
{
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  llvm::object::WindowsResource::getHeadEntry((llvm::object::WindowsResource *)this, (uint64_t)v49);
  if ((v60 & 1) == 0)
  {
    v32[0] = &unk_1F2632A58;
    v32[1] = v49[1];
    __int16 v32[2] = v50;
    if (v50) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v50 + 8), 1uLL, memory_order_relaxed);
    }
    long long v33 = v51;
    long long v34 = v52;
    uint64_t v35 = v53;
    *(_OWORD *)uint64_t v38 = v56;
    *(_OWORD *)unint64_t v39 = v57;
    long long v40 = v58;
    uint64_t v41 = v59;
    long long v36 = v54;
    long long v37 = v55;
    size_t v6 = this[5];
    if (v6 >= 0x7FFFFFFFFFFFFFF8) {
      goto LABEL_49;
    }
    uint64_t v8 = a2[8].i64[0];
    uint64_t v7 = a2[8].i64[1];
    BOOL v9 = (const void *)this[4];
    if (v6 >= 0x17)
    {
      uint64_t v12 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v6 | 7) != 0x17) {
        uint64_t v12 = v6 | 7;
      }
      uint64_t v13 = v12 + 1;
      p_dst = (long long *)operator new(v12 + 1);
      *((void *)&__dst + 1) = v6;
      int64_t v48 = v13 | 0x8000000000000000;
      *(void *)&long long __dst = p_dst;
    }
    else
    {
      HIBYTE(v48) = v6;
      p_dst = &__dst;
      if (!v6) {
        goto LABEL_15;
      }
    }
    memmove(p_dst, v9, v6);
LABEL_15:
    *((unsigned char *)p_dst + v6) = 0;
    unint64_t v14 = a2[9].u64[0];
    unint64_t v15 = a2[8].u64[1];
    if (v15 < v14)
    {
      *(_OWORD *)unint64_t v15 = __dst;
      *(void *)(v15 + 16) = v48;
      a2[8].i64[1] = v15 + 24;
      goto LABEL_34;
    }
    uint64_t v16 = a2[8].i64[0];
    unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v15 - v16) >> 3);
    unint64_t v18 = v17 + 1;
    if (v17 + 1 <= 0xAAAAAAAAAAAAAAALL)
    {
      if (0x5555555555555556 * ((uint64_t)(v14 - v16) >> 3) > v18) {
        unint64_t v18 = 0x5555555555555556 * ((uint64_t)(v14 - v16) >> 3);
      }
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v14 - v16) >> 3) >= 0x555555555555555) {
        unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v19 = v18;
      }
      uint64_t v46 = &a2[9];
      if (v19)
      {
        if (v19 > 0xAAAAAAAAAAAAAAALL) {
          sub_1CB833614();
        }
        int v20 = (char *)operator new(24 * v19);
      }
      else
      {
        int v20 = 0;
      }
      uint64_t v21 = &v20[8 * ((uint64_t)(v15 - v16) >> 3)];
      *(_OWORD *)uint64_t v21 = __dst;
      *((void *)v21 + 2) = v48;
      int64_t v48 = 0;
      long long __dst = 0uLL;
      if (v15 == v16)
      {
        BOOL v25 = 0;
        int64x2_t v24 = vdupq_n_s64(v15);
        uint64_t v22 = &v20[24 * v17];
      }
      else
      {
        uint64_t v22 = &v20[8 * ((uint64_t)(v15 - v16) >> 3)];
        do
        {
          long long v23 = *(_OWORD *)(v15 - 24);
          *((void *)v22 - 1) = *(void *)(v15 - 8);
          *(_OWORD *)(v22 - 24) = v23;
          v22 -= 24;
          *(void *)(v15 - 16) = 0;
          *(void *)(v15 - 8) = 0;
          *(void *)(v15 - 24) = 0;
          v15 -= 24;
        }
        while (v15 != v16);
        int64x2_t v24 = a2[8];
        unint64_t v14 = a2[9].u64[0];
        BOOL v25 = v48 < 0;
      }
      uint64_t v26 = v21 + 24;
      a2[8].i64[0] = (uint64_t)v22;
      a2[8].i64[1] = (uint64_t)(v21 + 24);
      int64x2_t v44 = v24;
      a2[9].i64[0] = (uint64_t)&v20[24 * v19];
      unint64_t v45 = v14;
      uint64_t v43 = v24.i64[0];
      sub_1CBF4EE0C((uint64_t)&v43);
      a2[8].i64[1] = (uint64_t)v26;
      if (v25) {
        operator delete((void *)__dst);
      }
LABEL_34:
      BOOL v31 = 0;
      unint64_t v30 = 0;
      if (BYTE8(v36)) {
        uint64_t v27 = (llvm::object::WindowsResourceParser::TreeNode *)llvm::object::WindowsResourceParser::TreeNode::addNameChild((uint64_t)a2, (char *)v37, *((uint64_t *)&v37 + 1));
      }
      else {
        uint64_t v27 = (llvm::object::WindowsResourceParser::TreeNode *)llvm::object::WindowsResourceParser::TreeNode::addIDChild((llvm::object::WindowsResourceParser::TreeNode *)a2, LOWORD(v38[0]));
      }
      if (BYTE2(v38[0])) {
        long long v28 = (llvm::object::WindowsResourceParser::TreeNode *)llvm::object::WindowsResourceParser::TreeNode::addNameChild((uint64_t)v27, (char *)v38[1], *(uint64_t *)v39);
      }
      else {
        long long v28 = (llvm::object::WindowsResourceParser::TreeNode *)llvm::object::WindowsResourceParser::TreeNode::addIDChild(v27, LOWORD(v39[2]));
      }
      llvm::object::WindowsResourceParser::TreeNode::addLanguageNode(v28, (uint64_t)v32, -1431655765 * ((unint64_t)(v7 - v8) >> 3), (int64x2_t *)a2[5].i64, &v30);
    }
LABEL_49:
    abort();
  }
  uint64_t v11 = (void *)v49[0];
  v49[0] = 0;
  if (v11
    && (*(unsigned int (**)(void *, void *))(*v11 + 48))(v11, &llvm::object::GenericBinaryError::ID))
  {
    uint64_t v42 = v11;
    sub_1CD4515D0(&v42);
    if (v42) {
      (*(void (**)(void *))(*v42 + 8))(v42);
    }
    *a3 = 0;
  }
  else
  {
    *a3 = v11;
  }
  if ((v60 & 1) == 0) {
    return sub_1CCC22DBC(v49);
  }
  double result = (void *)v49[0];
  v49[0] = 0;
  if (result) {
    return (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
  }
  return result;
}

void llvm::object::WindowsResourceParser::TreeNode::addEntry(llvm::object::WindowsResourceParser::TreeNode *a1, uint64_t a2, unsigned int a3, void *a4, uint64_t a5, llvm::object::WindowsResourceParser::TreeNode **a6)
{
  uint64_t v10 = (llvm::object::WindowsResourceParser::TreeNode *)llvm::object::WindowsResourceParser::TreeNode::addTypeNode(a1, a2);
  uint64_t v11 = (llvm::object::WindowsResourceParser::TreeNode *)llvm::object::WindowsResourceParser::TreeNode::addNameNode(v10, a2);

  llvm::object::WindowsResourceParser::TreeNode::addLanguageNode(v11, a2, a3, a4, a6);
}

void llvm::object::WindowsResourceParser::parse(llvm::object::ResourceSectionRef *this@<X1>, int64x2_t *a2@<X0>, const void *a3@<X2>, size_t a4@<X3>, uint64_t a5@<X4>, uint64_t *a6@<X8>)
{
  BOOL v9 = this;
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  llvm::object::ResourceSectionRef::getTableAtOffset(this, 0, (uint64_t)&v43);
  if (v44)
  {
    *a6 = v43;
    return;
  }
  if (a4 >= 0x7FFFFFFFFFFFFFF8) {
    goto LABEL_35;
  }
  uint64_t v12 = v43;
  uint64_t v14 = a2[8].i64[0];
  uint64_t v13 = a2[8].i64[1];
  uint64_t v36 = v13;
  if (a4 >= 0x17)
  {
    uint64_t v16 = (a4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a4 | 7) != 0x17) {
      uint64_t v16 = a4 | 7;
    }
    unint64_t v17 = v9;
    uint64_t v18 = v43;
    unint64_t v19 = a6;
    uint64_t v20 = a5;
    uint64_t v21 = a2[8].i64[0];
    uint64_t v22 = v16 + 1;
    p_dst = (long long *)operator new(v16 + 1);
    unint64_t v23 = v22 | 0x8000000000000000;
    uint64_t v14 = v21;
    a5 = v20;
    a6 = v19;
    uint64_t v12 = v18;
    BOOL v9 = v17;
    uint64_t v13 = v36;
    *((void *)&__dst + 1) = a4;
    unint64_t v38 = v23;
    *(void *)&long long __dst = p_dst;
    goto LABEL_10;
  }
  HIBYTE(v38) = a4;
  p_dst = &__dst;
  if (a4) {
LABEL_10:
  }
    memmove(p_dst, a3, a4);
  *((unsigned char *)p_dst + a4) = 0;
  unint64_t v24 = a2[9].u64[0];
  unint64_t v25 = a2[8].u64[1];
  if (v25 >= v24)
  {
    uint64_t v35 = v14;
    uint64_t v27 = a2[8].i64[0];
    unint64_t v28 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v25 - v27) >> 3) + 1;
    if (v28 <= 0xAAAAAAAAAAAAAAALL)
    {
      if (0x5555555555555556 * ((uint64_t)(v24 - v27) >> 3) > v28) {
        unint64_t v28 = 0x5555555555555556 * ((uint64_t)(v24 - v27) >> 3);
      }
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - v27) >> 3) >= 0x555555555555555) {
        unint64_t v29 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v29 = v28;
      }
      uint64_t v42 = a2 + 9;
      if (v29)
      {
        if (v29 > 0xAAAAAAAAAAAAAAALL) {
          sub_1CB833614();
        }
        unint64_t v30 = (char *)operator new(24 * v29);
      }
      else
      {
        unint64_t v30 = 0;
      }
      BOOL v31 = &v30[8 * ((uint64_t)(v25 - v27) >> 3)];
      *(_OWORD *)BOOL v31 = __dst;
      *((void *)v31 + 2) = v38;
      if (v25 == v27)
      {
        int64x2_t v34 = vdupq_n_s64(v25);
        uint64_t v32 = &v30[8 * ((uint64_t)(v25 - v27) >> 3)];
      }
      else
      {
        uint64_t v32 = &v30[8 * ((uint64_t)(v25 - v27) >> 3)];
        do
        {
          long long v33 = *(_OWORD *)(v25 - 24);
          *((void *)v32 - 1) = *(void *)(v25 - 8);
          *(_OWORD *)(v32 - 24) = v33;
          v32 -= 24;
          *(void *)(v25 - 16) = 0;
          *(void *)(v25 - 8) = 0;
          *(void *)(v25 - 24) = 0;
          v25 -= 24;
        }
        while (v25 != v27);
        int64x2_t v34 = a2[8];
        unint64_t v24 = a2[9].u64[0];
      }
      uint64_t v13 = v36;
      unint64_t v26 = (unint64_t)(v31 + 24);
      a2[8].i64[0] = (uint64_t)v32;
      a2[8].i64[1] = (uint64_t)(v31 + 24);
      int64x2_t v40 = v34;
      a2[9].i64[0] = (uint64_t)&v30[24 * v29];
      unint64_t v41 = v24;
      long long __p = (void *)v34.i64[0];
      sub_1CBF4EE0C((uint64_t)&__p);
      uint64_t v14 = v35;
      goto LABEL_29;
    }
LABEL_35:
    abort();
  }
  *(_OWORD *)unint64_t v25 = __dst;
  *(void *)(v25 + 16) = v38;
  unint64_t v26 = v25 + 24;
LABEL_29:
  a2[8].i64[1] = v26;
  long long __p = 0;
  int64x2_t v40 = 0uLL;
  llvm::object::WindowsResourceParser::addChildren((llvm::object *)a2, (llvm::object::WindowsResourceParser::TreeNode *)a2, v9, v12, -1431655765 * ((unint64_t)(v13 - v14) >> 3), &__p, a5, a6);
  if (__p) {
    operator delete(__p);
  }
  if (v44)
  {
    if (v43) {
      (*(void (**)(uint64_t))(*(void *)v43 + 8))(v43);
    }
  }
}

llvm::object *llvm::object::WindowsResourceParser::addChildren@<X0>(llvm::object *result@<X0>, llvm::object::WindowsResourceParser::TreeNode *a2@<X1>, llvm::object *a3@<X2>, uint64_t a4@<X3>, unsigned int a5@<W4>, void *a6@<X5>, uint64_t a7@<X6>, uint64_t *a8@<X8>)
{
  uint64_t v8 = a8;
  uint64_t v81 = *MEMORY[0x1E4F143B8];
  if (*(unsigned __int16 *)(a4 + 14) + *(unsigned __int16 *)(a4 + 12))
  {
    uint64_t v9 = a7;
    uint64_t v10 = a6;
    unsigned int v13 = 0;
    __int16 v70 = result;
    while (1)
    {
      double result = (llvm::object *)llvm::object::ResourceSectionRef::getTableEntry(a3, a4, v13, (uint64_t)&v76);
      if (v77) {
        break;
      }
      uint64_t v14 = v76;
      unsigned int v15 = v76[1];
      if ((v15 & 0x80000000) == 0)
      {
        if (*(_WORD *)(a4 + 12))
        {
          atomic_ullong v16 = llvm::object::object_category(result);
          uint64_t v78 = 3;
          atomic_ullong v79 = v16;
          v73[1] = (llvm::object::WindowsResourceParser::TreeNode *)"unexpected string key for data object";
          sub_1CD06481C();
        }
        double result = (llvm::object *)llvm::object::ResourceSectionRef::getDataEntryAtOffset(a3, v15, (uint64_t)&v74);
        if ((v75 & 1) == 0)
        {
          v73[0] = 0;
          unsigned int v26 = *v14;
          unint64_t v28 = (unsigned char *)v10[1];
          unint64_t v27 = v10[2];
          if ((unint64_t)v28 >= v27)
          {
            unint64_t v41 = (unsigned char *)*v10;
            uint64_t v42 = (uint64_t)&v28[-*v10] >> 5;
            unint64_t v43 = v42 + 1;
            if ((unint64_t)(v42 + 1) >> 59) {
LABEL_85:
            }
              abort();
            uint64_t v44 = v27 - (void)v41;
            if (v44 >> 4 > v43) {
              unint64_t v43 = v44 >> 4;
            }
            if ((unint64_t)v44 >= 0x7FFFFFFFFFFFFFE0) {
              unint64_t v45 = 0x7FFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v45 = v43;
            }
            if (v45)
            {
              if (v45 >> 59) {
LABEL_86:
              }
                sub_1CB833614();
              uint64_t v46 = (char *)operator new(32 * v45);
            }
            else
            {
              uint64_t v46 = 0;
            }
            long long v57 = &v46[32 * v42];
            *long long v57 = 0;
            *((void *)v57 + 1) = 0;
            *((void *)v57 + 2) = 0;
            *((_DWORD *)v57 + 6) = v26;
            long long v58 = v57;
            if (v28 != v41)
            {
              do
              {
                long long v59 = *((_OWORD *)v28 - 2);
                *(_OWORD *)(v58 - 20) = *(_OWORD *)(v28 - 20);
                *((_OWORD *)v58 - 2) = v59;
                v58 -= 32;
                v28 -= 32;
              }
              while (v28 != v41);
              unint64_t v28 = (unsigned char *)*v10;
            }
            unint64_t v29 = v57 + 32;
            void *v10 = v58;
            v10[1] = v57 + 32;
            _OWORD v10[2] = &v46[32 * v45];
            if (v28) {
              operator delete(v28);
            }
          }
          else
          {
            unsigned char *v28 = 0;
            *((void *)v28 + 1) = 0;
            *((void *)v28 + 2) = 0;
            unint64_t v29 = v28 + 32;
            *((_DWORD *)v28 + 6) = v26;
          }
          v10[1] = v29;
          llvm::object::WindowsResourceParser::TreeNode::addDataChild(a2, *v14, *(_WORD *)(a4 + 8), *(_WORD *)(a4 + 10), *(_DWORD *)a4, a5, -1431655765 * ((*((void *)v70 + 11) - *((void *)v70 + 10)) >> 3), v73);
        }
        char v17 = 0;
        uint64_t v18 = v74;
        goto LABEL_11;
      }
      if (v13 >= *(unsigned __int16 *)(a4 + 12))
      {
        uint64_t v30 = llvm::object::WindowsResourceParser::TreeNode::addIDChild(a2, *v76);
        unsigned int v31 = *v14;
        long long v33 = (unsigned char *)v10[1];
        unint64_t v32 = v10[2];
        if ((unint64_t)v33 >= v32)
        {
          uint64_t v35 = (unsigned char *)*v10;
          uint64_t v36 = (uint64_t)&v33[-*v10] >> 5;
          unint64_t v37 = v36 + 1;
          if ((unint64_t)(v36 + 1) >> 59) {
            goto LABEL_85;
          }
          uint64_t v38 = v32 - (void)v35;
          if (v38 >> 4 > v37) {
            unint64_t v37 = v38 >> 4;
          }
          if ((unint64_t)v38 >= 0x7FFFFFFFFFFFFFE0) {
            unint64_t v39 = 0x7FFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v39 = v37;
          }
          if (v39)
          {
            if (v39 >> 59) {
              goto LABEL_86;
            }
            uint64_t v24 = v30;
            int64x2_t v40 = (char *)operator new(32 * v39);
          }
          else
          {
            uint64_t v24 = v30;
            int64x2_t v40 = 0;
          }
          long long v52 = &v40[32 * v36];
          *long long v52 = 0;
          *((void *)v52 + 1) = 0;
          *((void *)v52 + 2) = 0;
          *((_DWORD *)v52 + 6) = v31;
          uint64_t v53 = v52;
          if (v33 == v35)
          {
            uint64_t v9 = a7;
            long long v55 = (char **)a6;
          }
          else
          {
            uint64_t v9 = a7;
            do
            {
              long long v54 = *((_OWORD *)v33 - 2);
              *(_OWORD *)(v53 - 20) = *(_OWORD *)(v33 - 20);
              *((_OWORD *)v53 - 2) = v54;
              v53 -= 32;
              v33 -= 32;
            }
            while (v33 != v35);
            long long v55 = (char **)a6;
            long long v33 = (unsigned char *)*a6;
          }
          int64x2_t v34 = v52 + 32;
          *long long v55 = v53;
          v55[1] = v52 + 32;
          v55[2] = &v40[32 * v39];
          if (v33) {
            operator delete(v33);
          }
          uint64_t v8 = a8;
        }
        else
        {
          uint64_t v24 = v30;
          unsigned char *v33 = 0;
          *((void *)v33 + 1) = 0;
          *((void *)v33 + 2) = 0;
          int64x2_t v34 = v33 + 32;
          *((_DWORD *)v33 + 6) = v31;
        }
        long long v56 = v70;
        a6[1] = v34;
      }
      else
      {
        double result = (llvm::object *)llvm::object::ResourceSectionRef::getDirStringAtOffset(a3, *v76 & 0x7FFFFFFF, (uint64_t)&v78);
        if (v80)
        {
          char v17 = 0;
          uint64_t v18 = v78;
          goto LABEL_11;
        }
        uint64_t v20 = v78;
        uint64_t v19 = v79;
        uint64_t v21 = llvm::object::WindowsResourceParser::TreeNode::addNameChild((uint64_t)a2, (char *)v78, v79);
        unint64_t v23 = (void *)v10[1];
        unint64_t v22 = v10[2];
        if ((unint64_t)v23 >= v22)
        {
          uint64_t v47 = (void *)*v10;
          uint64_t v48 = ((uint64_t)v23 - *v10) >> 5;
          unint64_t v49 = v48 + 1;
          if ((unint64_t)(v48 + 1) >> 59) {
            goto LABEL_85;
          }
          uint64_t v50 = v22 - (void)v47;
          if (v50 >> 4 > v49) {
            unint64_t v49 = v50 >> 4;
          }
          if ((unint64_t)v50 >= 0x7FFFFFFFFFFFFFE0) {
            unint64_t v49 = 0x7FFFFFFFFFFFFFFLL;
          }
          unint64_t v66 = v49;
          if (v49)
          {
            if (v49 >> 59) {
              goto LABEL_86;
            }
            uint64_t v24 = v21;
            long long v51 = (char *)operator new(32 * v49);
          }
          else
          {
            uint64_t v24 = v21;
            long long v51 = 0;
          }
          char v60 = &v51[32 * v48];
          *char v60 = 1;
          *((void *)v60 + 1) = v20;
          *((void *)v60 + 2) = v19;
          uint64_t v61 = v60;
          if (v23 == v47)
          {
            uint64_t v8 = a8;
            __int16 v64 = (char **)a6;
            unint64_t v62 = v66;
          }
          else
          {
            uint64_t v8 = a8;
            unint64_t v62 = v66;
            do
            {
              long long v63 = *((_OWORD *)v23 - 2);
              *(_OWORD *)(v61 - 20) = *(_OWORD *)((char *)v23 - 20);
              *((_OWORD *)v61 - 2) = v63;
              v61 -= 32;
              v23 -= 4;
            }
            while (v23 != v47);
            __int16 v64 = (char **)a6;
            unint64_t v23 = (void *)*a6;
          }
          unint64_t v25 = v60 + 32;
          uint64_t *v64 = v61;
          v64[1] = v60 + 32;
          v64[2] = &v51[32 * v62];
          uint64_t v9 = a7;
          if (v23) {
            operator delete(v23);
          }
        }
        else
        {
          uint64_t v24 = v21;
          *(unsigned char *)unint64_t v23 = 1;
          unint64_t v25 = v23 + 4;
          v23[1] = v20;
          _OWORD v23[2] = v19;
          uint64_t v8 = a8;
        }
        long long v56 = v70;
        a6[1] = v25;
      }
      double result = (llvm::object *)llvm::object::ResourceSectionRef::getTableAtOffset(a3, v14[1] & 0x7FFFFFFF, (uint64_t)&v78);
      if (v79)
      {
        char v17 = 0;
        uint64_t *v8 = v78;
        uint64_t v10 = a6;
      }
      else
      {
        uint64_t v65 = v24;
        uint64_t v10 = a6;
        double result = (llvm::object *)llvm::object::WindowsResourceParser::addChildren(v56, v65, a3, v78, a5, a6, v9);
        if (*v8)
        {
          char v17 = 0;
        }
        else
        {
          a6[1] -= 32;
          char v17 = 1;
        }
      }
LABEL_12:
      if (v77)
      {
        double result = (llvm::object *)v76;
        if (v76) {
          double result = (llvm::object *)(*(uint64_t (**)(unsigned int *))(*(void *)v76 + 8))(v76);
        }
      }
      if ((v17 & 1) == 0) {
        return result;
      }
      if (++v13 >= *(unsigned __int16 *)(a4 + 14) + *(unsigned __int16 *)(a4 + 12)) {
        goto LABEL_2;
      }
    }
    char v17 = 0;
    uint64_t v18 = (uint64_t)v76;
    uint64_t v76 = 0;
LABEL_11:
    uint64_t *v8 = v18;
    goto LABEL_12;
  }
LABEL_2:
  uint64_t *v8 = 0;
  return result;
}

uint64_t llvm::object::WindowsResourceParser::printTree(llvm::object::WindowsResourceParser *this, llvm::raw_ostream *a2)
{
  v3[0] = &unk_1F26454D8;
  v3[1] = a2;
  int v4 = 0;
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  int v7 = 0;
  return llvm::object::WindowsResourceParser::TreeNode::print(this, (uint64_t)v3, (uint64_t)"Resource Tree", 13);
}

uint64_t llvm::object::WindowsResourceParser::TreeNode::print(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v25 = &unk_1F2618960;
  uint64_t v26 = a2;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 232))(a2, a3, a4);
  uint64_t v6 = (void *)a1[5];
  if (v6 != a1 + 6)
  {
    do
    {
      char v7 = *((unsigned char *)v6 + 55);
      int v8 = v7;
      if (v7 >= 0) {
        uint64_t v9 = v6 + 4;
      }
      else {
        uint64_t v9 = (void *)v6[4];
      }
      uint64_t v10 = v7 & 0x7F;
      if (v8 >= 0) {
        uint64_t v11 = v10;
      }
      else {
        uint64_t v11 = v6[5];
      }
      llvm::object::WindowsResourceParser::TreeNode::print(v6[7], a2, v9, v11);
      uint64_t v12 = (void *)v6[1];
      if (v12)
      {
        do
        {
          unsigned int v13 = v12;
          uint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          unsigned int v13 = (void *)v6[2];
          BOOL v14 = *v13 == (void)v6;
          uint64_t v6 = v13;
        }
        while (!v14);
      }
      uint64_t v6 = v13;
    }
    while (v13 != a1 + 6);
  }
  unsigned int v15 = (unsigned int *)a1[2];
  atomic_ullong v16 = (unsigned int *)(a1 + 3);
  if (v15 != (unsigned int *)(a1 + 3))
  {
    do
    {
      uint64_t v17 = *((void *)v15 + 5);
      sub_1CD6F2998(v15 + 8, (uint64_t)__p);
      if (v24 >= 0) {
        uint64_t v18 = __p;
      }
      else {
        uint64_t v18 = (void **)__p[0];
      }
      if (v24 >= 0) {
        uint64_t v19 = (void *)(v24 & 0x7F);
      }
      else {
        uint64_t v19 = __p[1];
      }
      llvm::object::WindowsResourceParser::TreeNode::print(v17, a2, v18, v19);
      if (v24 < 0) {
        operator delete(__p[0]);
      }
      uint64_t v20 = (unsigned int *)*((void *)v15 + 1);
      if (v20)
      {
        do
        {
          uint64_t v21 = v20;
          uint64_t v20 = *(unsigned int **)v20;
        }
        while (v20);
      }
      else
      {
        do
        {
          uint64_t v21 = (unsigned int *)*((void *)v15 + 2);
          BOOL v14 = *(void *)v21 == (void)v15;
          unsigned int v15 = v21;
        }
        while (!v14);
      }
      unsigned int v15 = v21;
    }
    while (v21 != v16);
  }
  unint64_t v25 = &unk_1F2618960;
  uint64_t result = v26;
  if (v26) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v26 + 240))(v26);
  }
  return result;
}

uint64_t llvm::object::WindowsResourceParser::TreeNode::addTypeNode(llvm::object::WindowsResourceParser::TreeNode *a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 72)) {
    return llvm::object::WindowsResourceParser::TreeNode::addNameChild((uint64_t)a1, *(char **)(a2 + 80), *(void *)(a2 + 88));
  }
  else {
    return llvm::object::WindowsResourceParser::TreeNode::addIDChild(a1, *(unsigned __int16 *)(a2 + 96));
  }
}

uint64_t llvm::object::WindowsResourceParser::TreeNode::addNameNode(llvm::object::WindowsResourceParser::TreeNode *a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 98)) {
    return llvm::object::WindowsResourceParser::TreeNode::addNameChild((uint64_t)a1, *(char **)(a2 + 104), *(void *)(a2 + 112));
  }
  else {
    return llvm::object::WindowsResourceParser::TreeNode::addIDChild(a1, *(unsigned __int16 *)(a2 + 120));
  }
}

void llvm::object::WindowsResourceParser::TreeNode::addLanguageNode(llvm::object::WindowsResourceParser::TreeNode *a1, uint64_t a2, unsigned int a3, void *a4, llvm::object::WindowsResourceParser::TreeNode **a5)
{
}

uint64_t llvm::object::WindowsResourceParser::TreeNode::addNameChild(uint64_t a1, char *__src, uint64_t a3)
{
  memset(&__p, 0, sizeof(__p));
  llvm::convertUTF16ToUTF8String(__src, 2 * a3, &__p);
  uint64_t v6 = *(void *)(a1 + 48);
  uint64_t v5 = a1 + 48;
  uint64_t v4 = v6;
  if (!v6) {
    goto LABEL_41;
  }
  std::string::size_type v7 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  int v8 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
  uint64_t v9 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
     ? &__p
     : (std::string *)__p.__r_.__value_.__r.__words[0];
  std::string::size_type size = __p.__r_.__value_.__l.__size_;
  std::string::size_type v10 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
      ? *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F
      : __p.__r_.__value_.__l.__size_;
  uint64_t v11 = v5;
  do
  {
    if (*(char *)(v4 + 55) < 0)
    {
      uint64_t v12 = *(const void **)(v4 + 32);
      size_t v13 = *(void *)(v4 + 40);
    }
    else
    {
      uint64_t v12 = (const void *)(v4 + 32);
      size_t v13 = *(unsigned __int8 *)(v4 + 55);
    }
    if (v10 >= v13) {
      size_t v14 = v13;
    }
    else {
      size_t v14 = v10;
    }
    int v15 = memcmp(v12, v9, v14);
    BOOL v16 = v13 < v10;
    if (v15) {
      BOOL v16 = v15 < 0;
    }
    BOOL v17 = !v16;
    if (v16) {
      uint64_t v18 = (uint64_t *)(v4 + 8);
    }
    else {
      uint64_t v18 = (uint64_t *)v4;
    }
    if (v17) {
      uint64_t v11 = v4;
    }
    uint64_t v4 = *v18;
  }
  while (*v18);
  if (v11 == v5) {
    goto LABEL_41;
  }
  char v19 = *(unsigned char *)(v11 + 55);
  if (v19 >= 0) {
    uint64_t v20 = (const void *)(v11 + 32);
  }
  else {
    uint64_t v20 = *(const void **)(v11 + 32);
  }
  if (v19 >= 0) {
    size_t v21 = v19 & 0x7F;
  }
  else {
    size_t v21 = *(void *)(v11 + 40);
  }
  if (v8 >= 0) {
    std::string::size_type v22 = v7;
  }
  else {
    std::string::size_type v22 = size;
  }
  if (v21 >= v22) {
    size_t v23 = v22;
  }
  else {
    size_t v23 = v21;
  }
  int v24 = memcmp(v9, v20, v23);
  BOOL v25 = v22 < v21;
  if (v24) {
    BOOL v25 = v24 < 0;
  }
  if (v25) {
LABEL_41:
  }
    operator new();
  uint64_t v27 = *(void *)(v11 + 56);
  if ((v8 & 0x80) != 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v27;
}

uint64_t llvm::object::WindowsResourceParser::TreeNode::addIDChild(llvm::object::WindowsResourceParser::TreeNode *this, unsigned int a2)
{
  uint64_t v4 = (char *)*((void *)this + 3);
  uint64_t v2 = (char *)this + 24;
  uint64_t v3 = v4;
  if (!v4) {
    goto LABEL_12;
  }
  uint64_t v5 = v2;
  do
  {
    unsigned int v6 = *((_DWORD *)v3 + 8);
    BOOL v7 = v6 >= a2;
    if (v6 >= a2) {
      int v8 = (char **)v3;
    }
    else {
      int v8 = (char **)(v3 + 8);
    }
    if (v7) {
      uint64_t v5 = v3;
    }
    uint64_t v3 = *v8;
  }
  while (*v8);
  if (v5 == v2 || *((_DWORD *)v5 + 8) > a2) {
LABEL_12:
  }
    operator new();
  return *((void *)v5 + 5);
}

void llvm::object::WindowsResourceParser::TreeNode::addDataChild(llvm::object::WindowsResourceParser::TreeNode *this, unsigned int a2, unsigned __int16 a3, unsigned __int16 a4, unsigned int a5, unsigned int a6, unsigned int a7, llvm::object::WindowsResourceParser::TreeNode **a8)
{
}

uint64_t llvm::object::WindowsResourceParser::TreeNode::TreeNode(uint64_t this, __int16 a2, __int16 a3, int a4, int a5, int a6)
{
  *(unsigned char *)this = 1;
  *(_DWORD *)(this + 8) = a6;
  *(void *)(this + 24) = 0;
  *(void *)(this + 16) = this + 24;
  *(void *)(this + 56) = 0;
  *(void *)(this + 48) = 0;
  *(void *)(this + 32) = 0;
  *(void *)(this + 40) = this + 48;
  *(_WORD *)(this + 64) = a2;
  *(_WORD *)(this + 66) = a3;
  *(_DWORD *)(this + 68) = a4;
  *(_DWORD *)(this + 72) = a5;
  return this;
}

{
  *(unsigned char *)this = 1;
  *(_DWORD *)(this + 8) = a6;
  *(void *)(this + 24) = 0;
  *(void *)(this + 16) = this + 24;
  *(void *)(this + 56) = 0;
  *(void *)(this + 48) = 0;
  *(void *)(this + 32) = 0;
  *(void *)(this + 40) = this + 48;
  *(_WORD *)(this + 64) = a2;
  *(_WORD *)(this + 66) = a3;
  *(_DWORD *)(this + 68) = a4;
  *(_DWORD *)(this + 72) = a5;
  return this;
}

void llvm::object::WindowsResourceParser::TreeNode::createStringNode(llvm::object::WindowsResourceParser::TreeNode *this)
{
}

void llvm::object::WindowsResourceParser::TreeNode::createIDNode(llvm::object::WindowsResourceParser::TreeNode *this)
{
}

void llvm::object::WindowsResourceParser::TreeNode::createDataNode(llvm::object::WindowsResourceParser::TreeNode *this)
{
}

uint64_t llvm::object::WindowsResourceParser::TreeNode::getTreeSize(llvm::object::WindowsResourceParser::TreeNode *this)
{
  int v1 = 8 * (*((_DWORD *)this + 14) + *((_DWORD *)this + 8));
  if (*(unsigned char *)this) {
    return (v1 + 16);
  }
  uint64_t v2 = (v1 + 16);
  uint64_t v4 = (char *)*((void *)this + 5);
  uint64_t v5 = (char *)this + 48;
  if (v4 != (char *)this + 48)
  {
    do
    {
      int TreeSize = llvm::object::WindowsResourceParser::TreeNode::getTreeSize(*((llvm::object::WindowsResourceParser::TreeNode **)v4
                                                                            + 7));
      BOOL v7 = (char *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          int v8 = v7;
          BOOL v7 = *(char **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          int v8 = (char *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          uint64_t v4 = v8;
        }
        while (!v9);
      }
      uint64_t v2 = (TreeSize + v2);
      uint64_t v4 = v8;
    }
    while (v8 != v5);
  }
  std::string::size_type v10 = (char *)*((void *)this + 2);
  uint64_t v11 = (char *)this + 24;
  if (v10 != v11)
  {
    do
    {
      int v12 = llvm::object::WindowsResourceParser::TreeNode::getTreeSize(*((llvm::object::WindowsResourceParser::TreeNode **)v10
                                                                       + 5));
      size_t v13 = (char *)*((void *)v10 + 1);
      if (v13)
      {
        do
        {
          size_t v14 = v13;
          size_t v13 = *(char **)v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          size_t v14 = (char *)*((void *)v10 + 2);
          BOOL v9 = *(void *)v14 == (void)v10;
          std::string::size_type v10 = v14;
        }
        while (!v9);
      }
      uint64_t v2 = (v12 + v2);
      std::string::size_type v10 = v14;
    }
    while (v14 != v11);
  }
  return v2;
}

uint64_t *llvm::object::WindowsResourceCOFFWriter::WindowsResourceCOFFWriter(uint64_t *a1, int a2, void *a3)
{
  *a1 = 0;
  a1[2] = 0;
  *((_DWORD *)a1 + 6) = a2;
  a1[4] = (uint64_t)a3;
  uint64_t v4 = a3[10];
  unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * ((a3[11] - v4) >> 3);
  a1[5] = v4;
  a1[6] = v5;
  uint64_t v6 = a3[13];
  unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * ((a3[14] - v6) >> 3);
  a1[11] = v6;
  a1[12] = v7;
  *(_OWORD *)(a1 + 13) = 0u;
  *(_OWORD *)(a1 + 15) = 0u;
  *(_OWORD *)(a1 + 17) = 0u;
  *(_OWORD *)(a1 + 19) = 0u;
  a1[21] = 0;
  a1[7] = 100;
  llvm::object::WindowsResourceCOFFWriter::performSectionOneLayout((llvm::object::WindowsResourceCOFFWriter *)a1);
  llvm::object::WindowsResourceCOFFWriter::performSectionTwoLayout((llvm::object::WindowsResourceCOFFWriter *)a1);
  uint64_t v9 = a1[6];
  uint64_t v8 = a1[7];
  *((_DWORD *)a1 + 16) = v8;
  std::string::size_type v10 = (llvm::WritableMemoryBuffer *)(v8 + 18 * v9 + 94);
  a1[7] = (uint64_t)v10;
  size_t v14 = (const void **)"internal .obj file created from .res files";
  __int16 v15 = 259;
  llvm::WritableMemoryBuffer::getNewUninitMemBuffer(v10, &v14, &v16);
  uint64_t v11 = v16;
  if (v16) {
    bzero(*(void **)(v16 + 8), (size_t)v10);
  }
  uint64_t v12 = *a1;
  *a1 = v11;
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
  }
  return a1;
}

void llvm::object::WindowsResourceCOFFWriter::performFileLayout(llvm::object::WindowsResourceCOFFWriter *this)
{
  *((void *)this + 7) = 100;
  llvm::object::WindowsResourceCOFFWriter::performSectionOneLayout(this);
  llvm::object::WindowsResourceCOFFWriter::performSectionTwoLayout(this);
  uint64_t v3 = *((void *)this + 6);
  uint64_t v2 = *((void *)this + 7);
  *((_DWORD *)this + 16) = v2;
  *((void *)this + 7) = v2 + 18 * v3 + 94;
}

void llvm::object::WindowsResourceCOFFWriter::performSectionOneLayout(llvm::object::WindowsResourceCOFFWriter *this)
{
  uint64_t v2 = *((void *)this + 7);
  *((_DWORD *)this + 18) = v2;
  int TreeSize = llvm::object::WindowsResourceParser::TreeNode::getTreeSize(*((llvm::object::WindowsResourceParser::TreeNode **)this
                                                                        + 4));
  *((_DWORD *)this + 17) = TreeSize;
  uint64_t v4 = *((void *)this + 12);
  if (v4)
  {
    int v5 = 0;
    uint64_t v6 = (int *)*((void *)this + 11);
    unint64_t v7 = &v6[6 * v4];
    uint64_t v8 = (char *)*((void *)this + 14);
    do
    {
      unint64_t v9 = *((void *)this + 15);
      if ((unint64_t)v8 >= v9)
      {
        uint64_t v11 = (char *)*((void *)this + 13);
        uint64_t v12 = (v8 - v11) >> 2;
        unint64_t v13 = v12 + 1;
        if ((unint64_t)(v12 + 1) >> 62) {
          abort();
        }
        uint64_t v14 = v9 - (void)v11;
        if (v14 >> 1 > v13) {
          unint64_t v13 = v14 >> 1;
        }
        if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v15 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v15 = v13;
        }
        if (v15)
        {
          if (v15 >> 62) {
            sub_1CB833614();
          }
          uint64_t v16 = (char *)operator new(4 * v15);
        }
        else
        {
          uint64_t v16 = 0;
        }
        BOOL v17 = &v16[4 * v12];
        *(_DWORD *)BOOL v17 = TreeSize;
        std::string::size_type v10 = v17 + 4;
        while (v8 != v11)
        {
          int v18 = *((_DWORD *)v8 - 1);
          v8 -= 4;
          *((_DWORD *)v17 - 1) = v18;
          v17 -= 4;
        }
        *((void *)this + 13) = v17;
        *((void *)this + 14) = v10;
        *((void *)this + 15) = &v16[4 * v15];
        if (v11) {
          operator delete(v11);
        }
      }
      else
      {
        *(_DWORD *)uint64_t v8 = TreeSize;
        std::string::size_type v10 = v8 + 4;
      }
      *((void *)this + 14) = v10;
      int v19 = v6[2];
      int v20 = *v6;
      v6 += 6;
      unsigned int v21 = ((v19 - v20) & 0xFFFFFFFE) + 2;
      TreeSize += v21;
      v5 += v21;
      uint64_t v8 = v10;
    }
    while (v6 != v7);
    int TreeSize = *((_DWORD *)this + 17);
    uint64_t v2 = *((void *)this + 7);
    LODWORD(v4) = (v5 + 3) & 0xFFFFFFFC;
  }
  uint64_t v22 = (v4 + TreeSize);
  *((_DWORD *)this + 17) = v22;
  *((_DWORD *)this + 19) = v22 + v2;
  *((void *)this + 7) = (v2 + v22 + 10 * *((void *)this + 6) + 7) & 0xFFFFFFFFFFFFFFF8;
}

void llvm::object::WindowsResourceCOFFWriter::performSectionTwoLayout(llvm::object::WindowsResourceCOFFWriter *this)
{
  uint64_t v3 = *((void *)this + 6);
  uint64_t v2 = *((void *)this + 7);
  *((_DWORD *)this + 20) = 0;
  *((_DWORD *)this + 21) = v2;
  if (v3)
  {
    LODWORD(v4) = 0;
    int v5 = (int *)*((void *)this + 5);
    uint64_t v6 = &v5[6 * v3];
    unint64_t v7 = (char *)*((void *)this + 17);
    do
    {
      unint64_t v8 = *((void *)this + 18);
      if ((unint64_t)v7 >= v8)
      {
        std::string::size_type v10 = (char *)*((void *)this + 16);
        uint64_t v11 = (v7 - v10) >> 2;
        unint64_t v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 62) {
          abort();
        }
        uint64_t v13 = v8 - (void)v10;
        if (v13 >> 1 > v12) {
          unint64_t v12 = v13 >> 1;
        }
        if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v14 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v14 = v12;
        }
        if (v14)
        {
          if (v14 >> 62) {
            sub_1CB833614();
          }
          unint64_t v15 = (char *)operator new(4 * v14);
        }
        else
        {
          unint64_t v15 = 0;
        }
        uint64_t v16 = &v15[4 * v11];
        *(_DWORD *)uint64_t v16 = v4;
        unint64_t v9 = v16 + 4;
        while (v7 != v10)
        {
          int v17 = *((_DWORD *)v7 - 1);
          v7 -= 4;
          *((_DWORD *)v16 - 1) = v17;
          v16 -= 4;
        }
        *((void *)this + 16) = v16;
        *((void *)this + 17) = v9;
        *((void *)this + 18) = &v15[4 * v14];
        if (v10) {
          operator delete(v10);
        }
      }
      else
      {
        *(_DWORD *)unint64_t v7 = v4;
        unint64_t v9 = v7 + 4;
      }
      *((void *)this + 17) = v9;
      int v18 = v5[2];
      int v19 = *v5;
      v5 += 6;
      uint64_t v4 = ((v18 - v19 + 7) & 0xFFFFFFF8) + *((_DWORD *)this + 20);
      *((_DWORD *)this + 20) = v4;
      unint64_t v7 = v9;
    }
    while (v5 != v6);
    uint64_t v2 = *((void *)this + 7);
    uint64_t v20 = v4 + 7;
  }
  else
  {
    uint64_t v20 = 7;
  }
  *((void *)this + 7) = (v20 + v2) & 0xFFFFFFFFFFFFFFF8;
}

void llvm::object::WindowsResourceCOFFWriter::write(llvm::object::WindowsResourceCOFFWriter *this@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t v5 = *(void *)(*(void *)this + 8);
  *((void *)this + 1) = v5;
  *(_WORD *)uint64_t v5 = *((_DWORD *)this + 6);
  *(_WORD *)(v5 + 2) = 2;
  *(_DWORD *)(v5 + 4) = a2;
  *(_DWORD *)(v5 + 8) = *((_DWORD *)this + 16);
  *(_DWORD *)(v5 + 12) = *((_DWORD *)this + 12) + 5;
  *(_DWORD *)(v5 + 16) = 0x1000000;
  uint64_t v6 = *((void *)this + 1);
  uint64_t v7 = *((void *)this + 2) + 20;
  *((void *)this + 2) = v7;
  uint64_t v8 = v6 + v7;
  *(void *)uint64_t v8 = 0x313024637273722ELL;
  *(void *)(v8 + 8) = 0;
  *(_DWORD *)(v8 + 16) = *((_DWORD *)this + 17);
  *(_DWORD *)(v8 + 20) = *((_DWORD *)this + 18);
  *(_DWORD *)(v8 + 24) = *((_DWORD *)this + 19);
  *(_DWORD *)(v8 + 28) = 0;
  *(_WORD *)(v8 + 32) = *((void *)this + 6);
  *(_WORD *)(v8 + 34) = 0;
  *(_DWORD *)(v8 + 36) += 1073741888;
  uint64_t v9 = *((void *)this + 1);
  uint64_t v10 = *((void *)this + 2) + 40;
  *((void *)this + 2) = v10;
  uint64_t v11 = v9 + v10;
  *(void *)uint64_t v11 = 0x323024637273722ELL;
  *(void *)(v11 + 8) = 0;
  *(_DWORD *)(v11 + 16) = *((_DWORD *)this + 20);
  *(_DWORD *)(v11 + 20) = *((_DWORD *)this + 21);
  *(void *)(v11 + 24) = 0;
  *(void *)(v11 + 32) = 0x4000004000000000;
  *((void *)this + 2) += 40;
  llvm::object::WindowsResourceCOFFWriter::writeDirectoryTree(this);
  llvm::object::WindowsResourceCOFFWriter::writeDirectoryStringTable(this);
  llvm::object::WindowsResourceCOFFWriter::writeFirstSectionRelocations((uint64_t)this);
  *((void *)this + 2) = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  llvm::object::WindowsResourceCOFFWriter::writeSecondSection(this);
  llvm::object::WindowsResourceCOFFWriter::writeSymbolTable(this);
  *(_DWORD *)(*((void *)this + 1) + *((void *)this + 2)) = 0;
  uint64_t v12 = *(void *)this;
  *(void *)this = 0;
  *a3 = v12;
}

uint64_t llvm::object::WindowsResourceCOFFWriter::writeCOFFHeader(uint64_t this, int a2)
{
  uint64_t v2 = *(void *)(this + 8);
  *(_WORD *)uint64_t v2 = *(_DWORD *)(this + 24);
  *(_WORD *)(v2 + 2) = 2;
  *(_DWORD *)(v2 + 4) = a2;
  *(_DWORD *)(v2 + 8) = *(_DWORD *)(this + 64);
  *(_DWORD *)(v2 + 12) = *(_DWORD *)(this + 48) + 5;
  *(_DWORD *)(v2 + 16) = 0x1000000;
  return this;
}

uint64_t llvm::object::WindowsResourceCOFFWriter::writeFirstSectionHeader(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 8);
  uint64_t v2 = *(void *)(this + 16) + 20;
  *(void *)(this + 16) = v2;
  uint64_t v3 = v1 + v2;
  *(void *)uint64_t v3 = 0x313024637273722ELL;
  *(void *)(v3 + 8) = 0;
  *(_DWORD *)(v3 + 16) = *(_DWORD *)(this + 68);
  *(_DWORD *)(v3 + 20) = *(_DWORD *)(this + 72);
  *(_DWORD *)(v3 + 24) = *(_DWORD *)(this + 76);
  *(_DWORD *)(v3 + 28) = 0;
  *(_WORD *)(v3 + 32) = *(void *)(this + 48);
  *(_WORD *)(v3 + 34) = 0;
  *(_DWORD *)(v3 + 36) += 1073741888;
  return this;
}

uint64_t llvm::object::WindowsResourceCOFFWriter::writeSecondSectionHeader(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 8);
  uint64_t v2 = *(void *)(this + 16) + 40;
  *(void *)(this + 16) = v2;
  uint64_t v3 = v1 + v2;
  *(void *)uint64_t v3 = 0x323024637273722ELL;
  *(void *)(v3 + 8) = 0;
  *(_DWORD *)(v3 + 16) = *(_DWORD *)(this + 80);
  *(_DWORD *)(v3 + 20) = *(_DWORD *)(this + 84);
  *(void *)(v3 + 24) = 0;
  *(void *)(v3 + 32) = 0x4000004000000000;
  return this;
}

uint64_t llvm::object::WindowsResourceCOFFWriter::writeFirstSection(llvm::object::WindowsResourceCOFFWriter *this)
{
  *((void *)this + 2) += 40;
  llvm::object::WindowsResourceCOFFWriter::writeDirectoryTree(this);
  llvm::object::WindowsResourceCOFFWriter::writeDirectoryStringTable(this);
  uint64_t result = llvm::object::WindowsResourceCOFFWriter::writeFirstSectionRelocations((uint64_t)this);
  *((void *)this + 2) = (*((void *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  return result;
}

void *llvm::object::WindowsResourceCOFFWriter::writeSecondSection(void *this)
{
  uint64_t v1 = (uint64_t)this;
  uint64_t v2 = this[6];
  if (v2)
  {
    uint64_t v3 = this[2];
    uint64_t v4 = 24 * v2;
    uint64_t v5 = (void *)(this[5] + 8);
    do
    {
      uint64_t v6 = (const void *)*(v5 - 1);
      if ((const void *)*v5 == v6)
      {
        uint64_t v7 = (unsigned char *)*(v5 - 1);
      }
      else
      {
        this = memmove((void *)(*(void *)(v1 + 8) + v3), v6, *v5 - (void)v6);
        uint64_t v6 = (const void *)*(v5 - 1);
        uint64_t v7 = (unsigned char *)*v5;
        uint64_t v3 = *(void *)(v1 + 16);
      }
      v3 += (v7 - (unsigned char *)v6 + 7) & 0xFFFFFFFFFFFFFFF8;
      *(void *)(v1 + 16) = v3;
      v5 += 3;
      v4 -= 24;
    }
    while (v4);
  }
  else
  {
    uint64_t v3 = this[2];
  }
  *(void *)(v1 + 16) = (v3 + 7) & 0xFFFFFFFFFFFFFFF8;
  return this;
}

void llvm::object::WindowsResourceCOFFWriter::writeSymbolTable(llvm::object::WindowsResourceCOFFWriter *this)
{
  v34[1] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *((void *)this + 1) + *((void *)this + 2);
  *(void *)uint64_t v1 = 0x30302E7461656640;
  *(void *)(v1 + 8) = 0xFFFF00000011;
  *(_WORD *)(v1 + 16) = 3;
  uint64_t v2 = *((void *)this + 1);
  uint64_t v3 = *((void *)this + 2) + 18;
  *((void *)this + 2) = v3;
  uint64_t v4 = v2 + v3;
  *(void *)uint64_t v4 = 0x313024637273722ELL;
  *(void *)(v4 + 8) = 0x100000000;
  *(_WORD *)(v4 + 16) = 259;
  uint64_t v5 = *((void *)this + 1);
  uint64_t v6 = *((void *)this + 2) + 18;
  *((void *)this + 2) = v6;
  uint64_t v7 = v5 + v6;
  *(_DWORD *)uint64_t v7 = *((_DWORD *)this + 17);
  *(_WORD *)(v7 + 4) = *((void *)this + 6);
  *(void *)(v7 + 6) = 0;
  *(unsigned char *)(v7 + 14) = 0;
  uint64_t v8 = *((void *)this + 1);
  uint64_t v9 = *((void *)this + 2) + 18;
  *((void *)this + 2) = v9;
  uint64_t v10 = v8 + v9;
  *(void *)uint64_t v10 = 0x323024637273722ELL;
  *(void *)(v10 + 8) = 0x200000000;
  *(_WORD *)(v10 + 16) = 259;
  uint64_t v11 = *((void *)this + 1);
  uint64_t v12 = *((void *)this + 2) + 18;
  *((void *)this + 2) = v12;
  uint64_t v13 = v11 + v12;
  *(_DWORD *)uint64_t v13 = *((_DWORD *)this + 20);
  *(void *)(v13 + 4) = 0;
  *(_DWORD *)(v13 + 11) = 0;
  *((void *)this + 2) += 18;
  if (*((void *)this + 6))
  {
    uint64_t v15 = 0;
    unsigned int v16 = 1;
    do
    {
      v19[0] = "$R{0:X-6}";
      v19[1] = 9;
      v19[2] = &v22;
      void v19[3] = 1;
      uint64_t v20 = &unk_1F2619290;
      int v21 = (v16 - 1) & 0xFFFFFF;
      uint64_t v22 = &v20;
      size_t v23 = &unk_1F2646FA8;
      unint64_t v32 = v34;
      long long v33 = xmmword_1CD96EEC0;
      int v24 = 0;
      char v28 = 0;
      uint64_t v29 = 0;
      unsigned int v31 = (void **)&v32;
      int v30 = 0;
      uint64_t v26 = 0;
      uint64_t v27 = 0;
      uint64_t v25 = 0;
      sub_1CD862C68((uint64_t)v19, (llvm::raw_ostream *)&v23);
      size_t v23 = &unk_1F2646B98;
      if (v30 == 1 && v25) {
        MEMORY[0x1D25D9CB0](v25, 0x1000C8077774924);
      }
      uint64_t v17 = *((void *)this + 1) + *((void *)this + 2);
      memcpy((void *)v17, v32, v33);
      *(_DWORD *)(v17 + 8) = *(_DWORD *)(*((void *)this + 16) + 4 * v15);
      *(_DWORD *)(v17 + 12) = 2;
      *(_WORD *)(v17 + 16) = 3;
      *((void *)this + 2) += 18;
      if (v32 != v34) {
        free(v32);
      }
      uint64_t v15 = v16;
    }
    while (*((void *)this + 6) > (unint64_t)v16++);
  }
}

uint64_t llvm::object::WindowsResourceCOFFWriter::writeStringTable(uint64_t this)
{
  *(_DWORD *)(*(void *)(this + 8) + *(void *)(this + 16)) = 0;
  return this;
}

void llvm::object::WindowsResourceCOFFWriter::writeDirectoryTree(llvm::object::WindowsResourceCOFFWriter *this)
{
  long long v56 = 0u;
  long long v57 = 0u;
  *(_OWORD *)std::string __p = 0u;
  uint64_t v54 = *((void *)this + 4);
  sub_1CCC8B17C((uint64_t)__p, &v54);
  uint64_t v2 = *((void *)&v57 + 1);
  if (*((void *)&v57 + 1))
  {
    int v3 = 0;
    uint64_t v4 = 0;
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    int v7 = 8 * (*(_DWORD *)(*((void *)this + 4) + 56) + *(_DWORD *)(*((void *)this + 4) + 32)) + 16;
    do
    {
      uint64_t v8 = (char *)__p[1];
      uint64_t v9 = v57;
      uint64_t v10 = *(void *)(*(void *)((char *)__p[1] + (((unint64_t)v57 >> 6) & 0x3FFFFFFFFFFFFF8))
                      + 8 * (v57 & 0x1FF));
      *(void *)&long long v57 = v57 + 1;
      *((void *)&v57 + 1) = v2 - 1;
      if ((unint64_t)v57 >= 0x400)
      {
        operator delete(*(void **)__p[1]);
        __p[1] = v8 + 8;
        *(void *)&long long v57 = v9 - 511;
      }
      uint64_t v11 = *((void *)this + 1) + *((void *)this + 2);
      *(_DWORD *)uint64_t v11 = *(_DWORD *)(v10 + 68);
      *(_DWORD *)(v11 + 4) = 0;
      *(_WORD *)(v11 + 8) = *(_WORD *)(v10 + 64);
      *(_WORD *)(v11 + 10) = *(_WORD *)(v10 + 66);
      *(_WORD *)(v11 + 12) = *(void *)(v10 + 56);
      *(_WORD *)(v11 + 14) = *(void *)(v10 + 32);
      uint64_t v12 = *((void *)this + 2) + 16;
      *((void *)this + 2) = v12;
      v3 += 16;
      uint64_t v13 = *(void **)(v10 + 40);
      uint64_t v53 = v10;
      unint64_t v14 = (void *)(v10 + 48);
      if (v13 != (void *)(v10 + 48))
      {
        do
        {
          uint64_t v15 = (unsigned int *)(*((void *)this + 1) + v12);
          unsigned int *v15 = *(_DWORD *)(*((void *)this + 13) + 4 * *(unsigned int *)(v13[7] + 4)) | 0x80000000;
          if (*(unsigned char *)v13[7])
          {
            v15[1] = v7;
            v7 += 16;
            uint64_t v16 = v13[7];
            if (v5 >= v4)
            {
              uint64_t v17 = (v5 - v6) >> 3;
              unint64_t v18 = v17 + 1;
              if ((unint64_t)(v17 + 1) >> 61) {
LABEL_81:
              }
                abort();
              if ((v4 - v6) >> 2 > v18) {
                unint64_t v18 = (v4 - v6) >> 2;
              }
              if ((unint64_t)(v4 - v6) >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v19 = v18;
              }
              if (v19)
              {
                if (v19 >> 61) {
LABEL_82:
                }
                  sub_1CB833614();
                uint64_t v20 = (char *)operator new(8 * v19);
              }
              else
              {
                uint64_t v20 = 0;
              }
              int v21 = &v20[8 * v17];
              *(void *)int v21 = v16;
              uint64_t v22 = v21 + 8;
              if (v5 != v6)
              {
                do
                {
                  uint64_t v23 = *((void *)v5 - 1);
                  v5 -= 8;
                  *((void *)v21 - 1) = v23;
                  v21 -= 8;
                }
                while (v5 != v6);
                uint64_t v5 = v6;
              }
              uint64_t v6 = v21;
              uint64_t v4 = &v20[8 * v19];
              if (v5) {
                operator delete(v5);
              }
              uint64_t v5 = v22;
            }
            else
            {
              *(void *)uint64_t v5 = v16;
              v5 += 8;
            }
          }
          else
          {
            v15[1] = v7 ^ 0x80000000;
            v7 += 8 * (*(_DWORD *)(v13[7] + 32) + *(_DWORD *)(v13[7] + 56)) + 16;
            uint64_t v54 = v13[7];
            sub_1CCC8B17C((uint64_t)__p, &v54);
          }
          uint64_t v12 = *((void *)this + 2) + 8;
          *((void *)this + 2) = v12;
          int v24 = (void *)v13[1];
          if (v24)
          {
            do
            {
              uint64_t v25 = v24;
              int v24 = (void *)*v24;
            }
            while (v24);
          }
          else
          {
            do
            {
              uint64_t v25 = (void *)v13[2];
              BOOL v26 = *v25 == (void)v13;
              uint64_t v13 = v25;
            }
            while (!v26);
          }
          v3 += 8;
          uint64_t v13 = v25;
        }
        while (v25 != v14);
      }
      uint64_t v27 = *(void **)(v53 + 16);
      if (v27 != (void *)(v53 + 24))
      {
        do
        {
          char v28 = (_DWORD *)(*((void *)this + 1) + v12);
          _DWORD *v28 = *((_DWORD *)v27 + 8);
          if (*(unsigned char *)v27[5])
          {
            v28[1] = v7;
            v7 += 16;
            uint64_t v29 = v27[5];
            if (v5 >= v4)
            {
              uint64_t v30 = (v5 - v6) >> 3;
              unint64_t v31 = v30 + 1;
              if ((unint64_t)(v30 + 1) >> 61) {
                goto LABEL_81;
              }
              if ((v4 - v6) >> 2 > v31) {
                unint64_t v31 = (v4 - v6) >> 2;
              }
              if ((unint64_t)(v4 - v6) >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v32 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v32 = v31;
              }
              if (v32)
              {
                if (v32 >> 61) {
                  goto LABEL_82;
                }
                long long v33 = (char *)operator new(8 * v32);
              }
              else
              {
                long long v33 = 0;
              }
              int64x2_t v34 = &v33[8 * v30];
              *(void *)int64x2_t v34 = v29;
              uint64_t v35 = v34 + 8;
              if (v5 != v6)
              {
                do
                {
                  uint64_t v36 = *((void *)v5 - 1);
                  v5 -= 8;
                  *((void *)v34 - 1) = v36;
                  v34 -= 8;
                }
                while (v5 != v6);
                uint64_t v5 = v6;
              }
              uint64_t v6 = v34;
              uint64_t v4 = &v33[8 * v32];
              if (v5) {
                operator delete(v5);
              }
              uint64_t v5 = v35;
            }
            else
            {
              *(void *)uint64_t v5 = v29;
              v5 += 8;
            }
          }
          else
          {
            v28[1] = v7 ^ 0x80000000;
            v7 += 8 * (*(_DWORD *)(v27[5] + 32) + *(_DWORD *)(v27[5] + 56)) + 16;
            uint64_t v54 = v27[5];
            sub_1CCC8B17C((uint64_t)__p, &v54);
          }
          uint64_t v12 = *((void *)this + 2) + 8;
          *((void *)this + 2) = v12;
          unint64_t v37 = (void *)v27[1];
          if (v37)
          {
            do
            {
              uint64_t v38 = v37;
              unint64_t v37 = (void *)*v37;
            }
            while (v37);
          }
          else
          {
            do
            {
              uint64_t v38 = (void *)v27[2];
              BOOL v26 = *v38 == (void)v27;
              uint64_t v27 = v38;
            }
            while (!v26);
          }
          v3 += 8;
          uint64_t v27 = v38;
        }
        while (v38 != (void *)(v53 + 24));
      }
      uint64_t v2 = *((void *)&v57 + 1);
    }
    while (*((void *)&v57 + 1));
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v5 = 0;
    int v3 = 0;
  }
  uint64_t v39 = *((void *)this + 19);
  unint64_t v40 = *((void *)this + 6);
  unint64_t v41 = (*((void *)this + 20) - v39) >> 2;
  if (v40 <= v41)
  {
    if (v40 < v41) {
      *((void *)this + 20) = v39 + 4 * v40;
    }
  }
  else
  {
    sub_1CBF2A8C4((char **)this + 19, v40 - v41);
  }
  if (v6 != v5)
  {
    uint64_t v42 = *((void *)this + 2);
    unint64_t v43 = v6;
    do
    {
      uint64_t v44 = *(void *)v43;
      v43 += 8;
      uint64_t v45 = *((void *)this + 1) + v42;
      *(_DWORD *)(*((void *)this + 19) + 4 * *(unsigned int *)(v44 + 8)) = v3;
      *(_DWORD *)uint64_t v45 = 0;
      uint64_t v46 = (_DWORD *)(*((void *)this + 5) + 24 * *(unsigned int *)(v44 + 8));
      LODWORD(v46) = v46[2] - *v46;
      *(void *)(v45 + 8) = 0;
      *(_DWORD *)(v45 + 4) = v46;
      uint64_t v42 = *((void *)this + 2) + 16;
      *((void *)this + 2) = v42;
      v3 += 16;
    }
    while (v43 != v5);
  }
  if (v6) {
    operator delete(v6);
  }
  uint64_t v47 = (void **)__p[1];
  uint64_t v48 = (void **)v56;
  unint64_t v49 = v56 - (unint64_t)__p[1];
  if ((unint64_t)v56 - (unint64_t)__p[1] >= 0x11)
  {
    do
    {
      uint64_t v50 = *v47++;
      operator delete(v50);
      v49 -= 8;
    }
    while (v49 > 0x10);
  }
  while (v47 != v48)
  {
    long long v51 = *v47++;
    operator delete(v51);
  }
  long long v52 = __p[0];
  if (__p[0])
  {
    operator delete(v52);
  }
}

void *llvm::object::WindowsResourceCOFFWriter::writeDirectoryStringTable(void *this)
{
  uint64_t v1 = (uint64_t)this;
  uint64_t v2 = this[12];
  if (v2)
  {
    LODWORD(v3) = 0;
    uint64_t v4 = this[2];
    uint64_t v5 = 24 * v2;
    uint64_t v6 = (const void **)(this[11] + 8);
    do
    {
      unint64_t v7 = (unsigned char *)*v6 - (unsigned char *)*(v6 - 1);
      *(_WORD *)(*(void *)(v1 + 8) + v4) = v7 >> 1;
      uint64_t v8 = *(void *)(v1 + 16) + 2;
      *(void *)(v1 + 16) = v8;
      uint64_t v9 = *(v6 - 1);
      if (*v6 != v9)
      {
        this = memmove((void *)(*(void *)(v1 + 8) + v8), v9, (unsigned char *)*v6 - (unsigned char *)v9);
        uint64_t v8 = *(void *)(v1 + 16);
      }
      uint64_t v4 = v8 + (v7 & 0x1FFFE);
      *(void *)(v1 + 16) = v4;
      unint64_t v3 = v3 + (v7 & 0x1FFFE) + 2;
      v6 += 3;
      v5 -= 24;
    }
    while (v5);
  }
  else
  {
    unint64_t v3 = 0;
    uint64_t v4 = this[2];
  }
  *(void *)(v1 + 16) = v4 - v3 + ((v3 + 3) & 0x1FFFFFFFCLL);
  return this;
}

uint64_t llvm::object::WindowsResourceCOFFWriter::writeFirstSectionRelocations(uint64_t this)
{
  if (*(void *)(this + 48))
  {
    unint64_t v1 = 0;
    int v2 = 5;
    uint64_t v3 = *(void *)(this + 16);
    do
    {
      uint64_t v4 = *(void *)(this + 8) + v3;
      *(_DWORD *)uint64_t v4 = *(_DWORD *)(*(void *)(this + 152) + 4 * v1);
      *(_DWORD *)(v4 + 4) = v2;
      int v5 = *(_DWORD *)(this + 24);
      if (v5 > 34403)
      {
        if (v5 != 34404)
        {
LABEL_8:
          *(_WORD *)(v4 + 8) = 2;
          goto LABEL_9;
        }
        *(_WORD *)(v4 + 8) = 3;
      }
      else
      {
        if (v5 != 332) {
          goto LABEL_8;
        }
        *(_WORD *)(v4 + 8) = 7;
      }
LABEL_9:
      uint64_t v3 = *(void *)(this + 16) + 10;
      *(void *)(this + 16) = v3;
      unint64_t v1 = (v2 - 4);
      ++v2;
    }
    while (*(void *)(this + 48) > v1);
  }
  return this;
}

uint64_t llvm::object::writeWindowsResourceCOFF@<X0>(int a1@<W0>, void *a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  llvm::object::WindowsResourceCOFFWriter::WindowsResourceCOFFWriter(v7, a1, a2);
  llvm::object::WindowsResourceCOFFWriter::write((llvm::object::WindowsResourceCOFFWriter *)v7, a3, (void *)a4);
  *(unsigned char *)(a4 + 8) &= ~1u;
  if (__p)
  {
    uint64_t v13 = __p;
    operator delete(__p);
  }
  if (v10)
  {
    uint64_t v11 = v10;
    operator delete(v10);
  }
  if (v8)
  {
    uint64_t v9 = v8;
    operator delete(v8);
  }
  uint64_t result = v7[0];
  v7[0] = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_1CCC8ABB4(uint64_t a1, llvm::raw_ostream *a2, llvm::raw_ostream *a3, int a4)
{
  if (*(unsigned char *)a1)
  {
    memset(&__p, 0, sizeof(__p));
    if (!llvm::convertUTF16ToUTF8String(*(char **)(a1 + 8), 2 * *(void *)(a1 + 16), &__p)) {
      MEMORY[0x1D25D9630](&__p, "(failed conversion from UTF16)");
    }
    uint64_t v10 = (unsigned char *)*((void *)a2 + 4);
    if ((unint64_t)v10 >= *((void *)a2 + 3))
    {
      llvm::raw_ostream::write(a2, 34);
    }
    else
    {
      *((void *)a2 + 4) = v10 + 1;
      unsigned char *v10 = 34;
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      size_t size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      size_t size = __p.__r_.__value_.__l.__size_;
    }
    llvm::raw_ostream::write(a2, (const char *)p_p, size);
    uint64_t v13 = (unsigned char *)*((void *)a2 + 4);
    if ((unint64_t)v13 >= *((void *)a2 + 3))
    {
      llvm::raw_ostream::write(a2, 34);
    }
    else
    {
      *((void *)a2 + 4) = v13 + 1;
      unsigned char *v13 = 34;
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  else if (a3)
  {
    uint64_t v6 = (llvm::raw_ostream *)*(unsigned __int16 *)(a1 + 24);
    llvm::object::printResourceTypeName(v6, a2, a3);
  }
  else
  {
    if (a4)
    {
      uint64_t v7 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v7) > 2)
      {
        *(unsigned char *)(v7 + 2) = 32;
        *(_WORD *)uint64_t v7 = 17481;
        *((void *)a2 + 4) += 3;
      }
      else
      {
        llvm::raw_ostream::write(a2, "ID ", 3uLL);
      }
      unint64_t v8 = *(unsigned int *)(a1 + 24);
      uint64_t v9 = a2;
    }
    else
    {
      unint64_t v8 = *(unsigned int *)(a1 + 24);
      uint64_t v9 = a2;
    }
    sub_1CD098D14(v9, v8, 0, 0, 0);
  }
}

uint64_t sub_1CCC8AD5C(uint64_t a1)
{
  *(void *)a1 = &unk_1F2633568;
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

void sub_1CCC8ADAC(uint64_t a1)
{
  *(void *)a1 = &unk_1F2633568;
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }

  JUMPOUT(0x1D25D9CE0);
}

char *sub_1CCC8AE1C(char **a1, uint64_t a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * ((a1[2] - *a1) >> 3) > v3) {
    unint64_t v3 = 0x5555555555555556 * ((a1[2] - *a1) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 3) >= 0x555555555555555) {
    unint64_t v5 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v5 = v3;
  }
  if (v5 > 0xAAAAAAAAAAAAAAALL) {
    sub_1CB833614();
  }
  uint64_t v7 = (char *)operator new(24 * v5);
  unint64_t v8 = &v7[24 * v2];
  *(_OWORD *)unint64_t v8 = *(_OWORD *)a2;
  *((void *)v8 + 2) = *(void *)(a2 + 16);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  uint64_t v9 = *a1;
  uint64_t v10 = a1[1];
  if (v10 == *a1)
  {
    unint64_t v14 = v8 + 24;
    *a1 = v8;
    a1[1] = v8 + 24;
    a1[2] = &v7[24 * v5];
    if (!v10) {
      return v14;
    }
    goto LABEL_17;
  }
  uint64_t v11 = &v7[24 * v2];
  do
  {
    long long v12 = *(_OWORD *)(v10 - 24);
    v10 -= 24;
    *(_OWORD *)(v11 - 24) = v12;
    v11 -= 24;
    *((void *)v11 + 2) = *((void *)v10 + 2);
    *(void *)uint64_t v10 = 0;
    *((void *)v10 + 1) = 0;
    *((void *)v10 + 2) = 0;
  }
  while (v10 != v9);
  uint64_t v10 = *a1;
  uint64_t v13 = a1[1];
  unint64_t v14 = v8 + 24;
  *a1 = v11;
  a1[1] = v8 + 24;
  a1[2] = &v7[24 * v5];
  if (v13 != v10)
  {
    uint64_t v15 = v13;
    do
    {
      uint64_t v17 = (void *)*((void *)v15 - 3);
      v15 -= 24;
      uint64_t v16 = v17;
      if (v17)
      {
        *((void *)v13 - 2) = v16;
        operator delete(v16);
      }
      uint64_t v13 = v15;
    }
    while (v15 != v10);
  }
  if (v10) {
LABEL_17:
  }
    operator delete(v10);
  return v14;
}

uint64_t *sub_1CCC8AF78(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_1CCC8AFE0(*(char **)(v1 + 48));
    sub_1CCC8B044(*(void **)(v1 + 24));
    JUMPOUT(0x1D25D9CE0);
  }
  return result;
}

void sub_1CCC8AFE0(char *a1)
{
  if (a1)
  {
    sub_1CCC8AFE0(*(void *)a1);
    sub_1CCC8AFE0(*((void *)a1 + 1));
    sub_1CCC8AF78(a1 + 56);
    if (a1[55] < 0) {
      operator delete(*((void **)a1 + 4));
    }
    operator delete(a1);
  }
}

void sub_1CCC8B044(void *a1)
{
  if (a1)
  {
    sub_1CCC8B044(*a1);
    sub_1CCC8B044(a1[1]);
    sub_1CCC8AF78(a1 + 5);
    operator delete(a1);
  }
}

uint64_t **sub_1CCC8B098(uint64_t **a1, unsigned int a2, int a3, uint64_t **a4)
{
  unint64_t v8 = a1 + 1;
  uint64_t v7 = a1[1];
  if (v7)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v7;
        unsigned int v10 = *((_DWORD *)v7 + 8);
        if (v10 <= a2) {
          break;
        }
        uint64_t v7 = *v9;
        unint64_t v8 = v9;
        if (!*v9) {
          goto LABEL_9;
        }
      }
      if (v10 >= a2) {
        break;
      }
      uint64_t v7 = v9[1];
      if (!v7)
      {
        unint64_t v8 = v9 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v9 = a1 + 1;
LABEL_9:
    uint64_t v11 = (uint64_t *)v9;
    uint64_t v9 = (uint64_t **)operator new(0x30uLL);
    *((_DWORD *)v9 + 8) = a3;
    long long v12 = *a4;
    *a4 = 0;
    v9[5] = v12;
    char *v9 = 0;
    v9[1] = 0;
    v9[2] = v11;
    char *v8 = (uint64_t *)v9;
    uint64_t v13 = (uint64_t *)**a1;
    unint64_t v14 = (uint64_t *)v9;
    if (v13)
    {
      *a1 = v13;
      unint64_t v14 = *v8;
    }
    sub_1CB8358B8(a1[1], v14);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v9;
}

void sub_1CCC8B17C(uint64_t a1, void *a2)
{
  uint64_t v4 = *(char **)(a1 + 8);
  unint64_t v5 = *(char **)(a1 + 16);
  uint64_t v6 = v5 - v4;
  if (v5 == v4) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = ((v5 - v4) << 6) - 1;
  }
  unint64_t v9 = *(void *)(a1 + 32);
  uint64_t v8 = *(void *)(a1 + 40);
  unint64_t v10 = v8 + v9;
  if (v7 == v8 + v9)
  {
    if (v9 >= 0x200)
    {
      *(void *)(a1 + 32) = v9 - 512;
      uint64_t v13 = *(void *)v4;
      uint64_t v11 = v4 + 8;
      uint64_t v12 = v13;
      *(void *)(a1 + 8) = v11;
      if (v5 != *(char **)(a1 + 24))
      {
LABEL_33:
        *(void *)unint64_t v5 = v12;
        goto LABEL_34;
      }
      unint64_t v14 = *(char **)a1;
      if ((unint64_t)v11 > *(void *)a1)
      {
        uint64_t v15 = (uint64_t)&v11[-*(void *)a1] >> 3;
        if (v15 >= -1) {
          uint64_t v16 = v15 + 1;
        }
        else {
          uint64_t v16 = v15 + 2;
        }
        uint64_t v17 = -(v16 >> 1);
        uint64_t v18 = v16 >> 1;
        unint64_t v19 = &v11[-8 * v18];
        int64_t v20 = v5 - v11;
        if (v5 != v11)
        {
          memmove(&v11[-8 * v18], v11, v5 - v11);
          unint64_t v5 = *(char **)(a1 + 8);
        }
        int v21 = &v5[8 * v17];
        unint64_t v5 = &v19[v20];
        *(void *)(a1 + 8) = v21;
        *(void *)(a1 + 16) = &v19[v20];
        goto LABEL_33;
      }
      if (v5 == v14) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (v5 - v14) >> 2;
      }
      if (!(v33 >> 61))
      {
        int64x2_t v34 = (char *)operator new(8 * v33);
        uint64_t v35 = &v34[8 * (v33 >> 2)];
        uint64_t v37 = v5 - v11;
        BOOL v36 = v5 == v11;
        unint64_t v5 = v35;
        if (!v36)
        {
          unint64_t v5 = &v35[v37 & 0xFFFFFFFFFFFFFFF8];
          uint64_t v38 = 8 * (v37 >> 3);
          uint64_t v39 = &v34[8 * (v33 >> 2)];
          do
          {
            uint64_t v40 = *(void *)v11;
            v11 += 8;
            *(void *)uint64_t v39 = v40;
            v39 += 8;
            v38 -= 8;
          }
          while (v38);
        }
        *(void *)a1 = v34;
        *(void *)(a1 + 8) = v35;
        *(void *)(a1 + 16) = v5;
        *(void *)(a1 + 24) = &v34[8 * v33];
        if (v14)
        {
          operator delete(v14);
          unint64_t v5 = *(char **)(a1 + 16);
        }
        goto LABEL_33;
      }
      goto LABEL_95;
    }
    uint64_t v22 = *(char **)(a1 + 24);
    uint64_t v23 = *(char **)a1;
    uint64_t v24 = (uint64_t)&v22[-*(void *)a1];
    if (v6 < (unint64_t)v24)
    {
      uint64_t v25 = operator new(0x1000uLL);
      BOOL v26 = v25;
      if (v22 != v5)
      {
        *(void *)unint64_t v5 = v25;
LABEL_34:
        *(void *)(a1 + 16) += 8;
LABEL_35:
        uint64_t v4 = *(char **)(a1 + 8);
        uint64_t v8 = *(void *)(a1 + 40);
        unint64_t v10 = *(void *)(a1 + 32) + v8;
        goto LABEL_36;
      }
      if (v4 == v23)
      {
        if (v5 == v4) {
          unint64_t v59 = 1;
        }
        else {
          unint64_t v59 = (v22 - v4) >> 2;
        }
        if (v59 >> 61) {
          goto LABEL_95;
        }
        char v60 = (char *)operator new(8 * v59);
        unint64_t v41 = &v60[(2 * v59 + 6) & 0xFFFFFFFFFFFFFFF8];
        uint64_t v61 = v41;
        if (v5 != v4)
        {
          uint64_t v61 = &v41[v6 & 0xFFFFFFFFFFFFFFF8];
          uint64_t v62 = 8 * (v6 >> 3);
          long long v63 = &v60[(2 * v59 + 6) & 0xFFFFFFFFFFFFFFF8];
          __int16 v64 = v4;
          do
          {
            uint64_t v65 = *(void *)v64;
            v64 += 8;
            *(void *)long long v63 = v65;
            v63 += 8;
            v62 -= 8;
          }
          while (v62);
        }
        *(void *)a1 = v60;
        *(void *)(a1 + 8) = v41;
        *(void *)(a1 + 16) = v61;
        *(void *)(a1 + 24) = &v60[8 * v59];
        if (v4)
        {
          operator delete(v4);
          unint64_t v41 = *(char **)(a1 + 8);
        }
      }
      else
      {
        unint64_t v41 = v4;
      }
      *((void *)v41 - 1) = v26;
      unint64_t v66 = *(char **)(a1 + 8);
      uint64_t v67 = *(char **)(a1 + 16);
      *(void *)(a1 + 8) = v66 - 8;
      uint64_t v68 = *((void *)v66 - 1);
      *(void *)(a1 + 8) = v66;
      if (v67 == *(char **)(a1 + 24))
      {
        int v69 = *(char **)a1;
        if ((unint64_t)v66 <= *(void *)a1)
        {
          if (v67 == v69) {
            unint64_t v76 = 1;
          }
          else {
            unint64_t v76 = (v67 - v69) >> 2;
          }
          if (v76 >> 61) {
            goto LABEL_95;
          }
          char v77 = (char *)operator new(8 * v76);
          uint64_t v78 = &v77[8 * (v76 >> 2)];
          uint64_t v79 = v67 - v66;
          BOOL v36 = v67 == v66;
          uint64_t v67 = v78;
          if (!v36)
          {
            uint64_t v67 = &v78[v79 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v80 = 8 * (v79 >> 3);
            uint64_t v81 = &v77[8 * (v76 >> 2)];
            do
            {
              uint64_t v82 = *(void *)v66;
              v66 += 8;
              *(void *)uint64_t v81 = v82;
              v81 += 8;
              v80 -= 8;
            }
            while (v80);
          }
          *(void *)a1 = v77;
          *(void *)(a1 + 8) = v78;
          *(void *)(a1 + 16) = v67;
          *(void *)(a1 + 24) = &v77[8 * v76];
          if (v69)
          {
            operator delete(v69);
            uint64_t v67 = *(char **)(a1 + 16);
          }
        }
        else
        {
          uint64_t v70 = (uint64_t)&v66[-*(void *)a1] >> 3;
          if (v70 >= -1) {
            uint64_t v71 = v70 + 1;
          }
          else {
            uint64_t v71 = v70 + 2;
          }
          uint64_t v72 = -(v71 >> 1);
          uint64_t v73 = v71 >> 1;
          uint64_t v74 = &v66[-8 * v73];
          size_t v75 = v67 - v66;
          if (v75)
          {
            memmove(&v66[-8 * v73], v66, v75);
            unint64_t v66 = *(char **)(a1 + 8);
          }
          uint64_t v67 = &v74[v75];
          *(void *)(a1 + 8) = &v66[8 * v72];
          *(void *)(a1 + 16) = v67;
        }
      }
      *(void *)uint64_t v67 = v68;
      goto LABEL_34;
    }
    uint64_t v27 = v24 >> 2;
    if (v22 == v23) {
      unint64_t v28 = 1;
    }
    else {
      unint64_t v28 = v27;
    }
    if (v28 >> 61) {
LABEL_95:
    }
      sub_1CB833614();
    uint64_t v29 = (char *)operator new(8 * v28);
    uint64_t v30 = &v29[v6];
    unint64_t v31 = &v29[8 * v28];
    unint64_t v32 = operator new(0x1000uLL);
    if (v28 == v6 >> 3)
    {
      if (v6 < 1)
      {
        if (v5 == v4) {
          unint64_t v42 = 1;
        }
        else {
          unint64_t v42 = v6 >> 2;
        }
        if (v42 >> 61) {
          goto LABEL_95;
        }
        unint64_t v43 = (char *)operator new(8 * v42);
        uint64_t v30 = &v43[8 * (v42 >> 2)];
        unint64_t v31 = &v43[8 * v42];
        operator delete(v29);
        uint64_t v4 = *(char **)(a1 + 8);
        unint64_t v5 = *(char **)(a1 + 16);
        uint64_t v29 = v43;
      }
      else
      {
        v30 -= (4 * v28 + 4) & 0xFFFFFFFFFFFFFFF8;
      }
    }
    *(void *)uint64_t v30 = v32;
    uint64_t v44 = v30 + 8;
    if (v5 == v4)
    {
      long long v57 = v30;
      uint64_t v45 = v30 + 8;
LABEL_66:
      long long v58 = *(char **)a1;
      *(void *)a1 = v29;
      *(void *)(a1 + 8) = v57;
      *(void *)(a1 + 16) = v45;
      *(void *)(a1 + 24) = v31;
      if (v58) {
        operator delete(v58);
      }
      goto LABEL_35;
    }
    while (1)
    {
      if (v30 == v29)
      {
        if (v44 < v31)
        {
          uint64_t v47 = (v31 - v44) >> 3;
          if (v47 >= -1) {
            unint64_t v48 = v47 + 1;
          }
          else {
            unint64_t v48 = v47 + 2;
          }
          uint64_t v45 = &v44[8 * (v48 >> 1)];
          uint64_t v46 = &v30[8 * (v48 >> 1)];
          if (v44 == v30) {
            uint64_t v30 = v44;
          }
          else {
            memmove(&v30[8 * (v48 >> 1)], v30, v44 - v30);
          }
          goto LABEL_62;
        }
        if (v31 == v30) {
          unint64_t v49 = 1;
        }
        else {
          unint64_t v49 = (v31 - v30) >> 2;
        }
        if (v49 >> 61) {
          goto LABEL_95;
        }
        uint64_t v50 = (char *)operator new(8 * v49);
        uint64_t v29 = v50;
        uint64_t v46 = &v50[(2 * v49 + 6) & 0xFFFFFFFFFFFFFFF8];
        uint64_t v45 = v46;
        uint64_t v51 = v44 - v30;
        if (v44 != v30)
        {
          uint64_t v45 = &v46[v51 & 0xFFFFFFFFFFFFFFF8];
          uint64_t v52 = 8 * (v51 >> 3);
          uint64_t v53 = &v50[(2 * v49 + 6) & 0xFFFFFFFFFFFFFFF8];
          uint64_t v54 = v30;
          do
          {
            uint64_t v55 = *(void *)v54;
            v54 += 8;
            *(void *)uint64_t v53 = v55;
            v53 += 8;
            v52 -= 8;
          }
          while (v52);
        }
        unint64_t v31 = &v50[8 * v49];
        operator delete(v30);
      }
      else
      {
        uint64_t v45 = v44;
        uint64_t v46 = v30;
      }
      uint64_t v30 = v29;
LABEL_62:
      uint64_t v29 = v30;
      uint64_t v56 = *((void *)v5 - 1);
      v5 -= 8;
      *((void *)v46 - 1) = v56;
      long long v57 = v46 - 8;
      uint64_t v44 = v45;
      uint64_t v30 = v57;
      if (v5 == *(char **)(a1 + 8)) {
        goto LABEL_66;
      }
    }
  }
LABEL_36:
  *(void *)(*(void *)&v4[(v10 >> 6) & 0x3FFFFFFFFFFFFF8] + 8 * (v10 & 0x1FF)) = *a2;
  *(void *)(a1 + 40) = v8 + 1;
}

void *llvm::object::XCOFFSectionHeader<llvm::object::XCOFFSectionHeader32>::getName(void *a1)
{
  return a1;
}

uint64_t llvm::object::XCOFFSectionHeader<llvm::object::XCOFFSectionHeader32>::getSectionType(uint64_t a1)
{
  return (unsigned __int16)bswap32(*(_DWORD *)(a1 + 36));
}

BOOL llvm::object::XCOFFSectionHeader<llvm::object::XCOFFSectionHeader32>::isReservedSectionType(uint64_t a1)
{
  return (*(unsigned char *)(a1 + 39) & 7) != 0;
}

void *llvm::object::XCOFFSectionHeader<llvm::object::XCOFFSectionHeader64>::getName(void *a1)
{
  return a1;
}

uint64_t llvm::object::XCOFFSectionHeader<llvm::object::XCOFFSectionHeader64>::getSectionType(uint64_t a1)
{
  return (unsigned __int16)bswap32(*(_DWORD *)(a1 + 64));
}

BOOL llvm::object::XCOFFSectionHeader<llvm::object::XCOFFSectionHeader64>::isReservedSectionType(uint64_t a1)
{
  return (*(unsigned char *)(a1 + 67) & 7) != 0;
}

uint64_t llvm::object::XCOFFRelocation<llvm::support::detail::packed_endian_specific_integral<unsigned int,(llvm::support::endianness)0,1ul,1ul>>::isRelocationSigned(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 8) >> 7;
}

uint64_t llvm::object::XCOFFRelocation<llvm::support::detail::packed_endian_specific_integral<unsigned int,(llvm::support::endianness)0,1ul,1ul>>::isFixupIndicated(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 8) >> 6) & 1;
}

uint64_t llvm::object::XCOFFRelocation<llvm::support::detail::packed_endian_specific_integral<unsigned int,(llvm::support::endianness)0,1ul,1ul>>::getRelocatedLength(uint64_t a1)
{
  return (*(unsigned char *)(a1 + 8) & 0x3Fu) + 1;
}

uint64_t llvm::object::XCOFFRelocation<llvm::support::detail::packed_endian_specific_integral<unsigned long long,(llvm::support::endianness)0,1ul,1ul>>::isRelocationSigned(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 12) >> 7;
}

uint64_t llvm::object::XCOFFRelocation<llvm::support::detail::packed_endian_specific_integral<unsigned long long,(llvm::support::endianness)0,1ul,1ul>>::isFixupIndicated(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 12) >> 6) & 1;
}

uint64_t llvm::object::XCOFFRelocation<llvm::support::detail::packed_endian_specific_integral<unsigned long long,(llvm::support::endianness)0,1ul,1ul>>::getRelocatedLength(uint64_t a1)
{
  return (*(unsigned char *)(a1 + 12) & 0x3Fu) + 1;
}

uint64_t llvm::object::XCOFFObjectFile::getAdvancedSymbolEntryAddress(llvm::object::XCOFFObjectFile *this, unsigned int a2)
{
  return (uint64_t)this + 18 * a2;
}

uint64_t llvm::object::XCOFFObjectFile::getSymbolAuxType(llvm::object::XCOFFObjectFile *this, uint64_t a2)
{
  return a2 + 17;
}

uint64_t llvm::object::XCOFFObjectFile::checkSectionAddress(uint64_t this, unint64_t a2, unint64_t a3)
{
  unint64_t v3 = a2 - a3;
  if (a2 < a3) {
    goto LABEL_7;
  }
  unint64_t v4 = 40;
  if (*(_DWORD *)(this + 8) == 11) {
    unint64_t v4 = 72;
  }
  if (v3 >= v4 * (unint64_t)(bswap32(*(unsigned __int16 *)(*(void *)(this + 48) + 2)) >> 16))
  {
LABEL_7:
    unint64_t v5 = "Section header outside of section header table.";
    goto LABEL_9;
  }
  if (v3 % v4)
  {
    unint64_t v5 = "Section header pointer does not point to a valid section header.";
LABEL_9:
    llvm::report_fatal_error((llvm *)v5, (const llvm::Twine *)1);
  }
  return this;
}

uint64_t llvm::object::XCOFFObjectFile::getSectionHeaderSize(llvm::object::XCOFFObjectFile *this)
{
  if (*((_DWORD *)this + 2) == 11) {
    return 72;
  }
  else {
    return 40;
  }
}

uint64_t llvm::object::XCOFFObjectFile::getNumberOfSections(llvm::object::XCOFFObjectFile *this)
{
  return bswap32(*(unsigned __int16 *)(*((void *)this + 6) + 2)) >> 16;
}

uint64_t llvm::object::XCOFFObjectFile::toSection32(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t llvm::object::XCOFFObjectFile::toSection64(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t llvm::object::XCOFFObjectFile::toSymbolRef@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  a3[1] = 0;
  a3[2] = 0;
  *a3 = result;
  uint64_t v3 = 1;
  if (*(_DWORD *)(result + 8) == 11) {
    uint64_t v3 = 2;
  }
  a3[v3] = a2;
  return result;
}

uint64_t llvm::object::XCOFFObjectFile::fileHeader32(llvm::object::XCOFFObjectFile *this)
{
  return *((void *)this + 6);
}

uint64_t llvm::object::XCOFFObjectFile::fileHeader64(llvm::object::XCOFFObjectFile *this)
{
  return *((void *)this + 6);
}

uint64_t llvm::object::XCOFFObjectFile::auxiliaryHeader32(llvm::object::XCOFFObjectFile *this)
{
  return *((void *)this + 7);
}

uint64_t llvm::object::XCOFFObjectFile::auxiliaryHeader64(llvm::object::XCOFFObjectFile *this)
{
  return *((void *)this + 7);
}

uint64_t llvm::object::XCOFFObjectFile::sectionHeaderTable32(llvm::object::XCOFFObjectFile *this)
{
  return *((void *)this + 8);
}

uint64_t llvm::object::XCOFFObjectFile::sectionHeaderTable64(llvm::object::XCOFFObjectFile *this)
{
  return *((void *)this + 8);
}

uint64_t llvm::object::XCOFFObjectFile::getStringTable(llvm::object::XCOFFObjectFile *this)
{
  return *((void *)this + 11);
}

unsigned char *llvm::object::XCOFFObjectFile::getCFileName@<X0>(unsigned int *__s@<X1>, size_t a2@<X0>, uint64_t a3@<X8>)
{
  if (*__s)
  {
    uint64_t result = memchr(__s, 0, 8uLL);
    uint64_t v6 = result - (unsigned char *)__s;
    *(unsigned char *)(a3 + 16) &= ~1u;
    if (!result) {
      uint64_t v6 = 8;
    }
    *(void *)a3 = __s;
    *(void *)(a3 + 8) = v6;
  }
  else
  {
    unsigned int v7 = bswap32(__s[1]);
    return (unsigned char *)llvm::object::XCOFFObjectFile::getStringTableEntry(a2, v7, a3);
  }
  return result;
}

void *llvm::object::XCOFFObjectFile::getSymbolAlignment(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  v10[1] = 0;
  _OWORD v10[2] = 0;
  v10[0] = a1;
  uint64_t v2 = 1;
  if (*(_DWORD *)(a1 + 8) == 11)
  {
    uint64_t v2 = 2;
    uint64_t v3 = a2;
  }
  else
  {
    uint64_t v3 = 0;
  }
  if (*(_DWORD *)(a1 + 8) == 11) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = a2;
  }
  v10[v2] = a2;
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = v3;
  }
  int v6 = *(unsigned __int8 *)(v5 + 16);
  if (v6 != 2 && v6 != 111 && v6 != 107) {
    return 0;
  }
  llvm::object::XCOFFSymbolRef::getXCOFFCsectAuxRef((llvm::object::XCOFFSymbolRef *)v10, (uint64_t)v11);
  if (v12)
  {
    unint64_t v9 = (void *)v11[0];
    sub_1CD4515D0(&v9);
    uint64_t result = v9;
    if (v9)
    {
      (*(void (**)(void *))(*v9 + 8))(v9);
      return 0;
    }
  }
  else
  {
    uint64_t v8 = v11[0];
    if (!v11[0]) {
      uint64_t v8 = v11[1];
    }
    return (void *)(1 << (*(unsigned char *)(v8 + 10) >> 3));
  }
  return result;
}

BOOL llvm::object::XCOFFSymbolRef::isCsectSymbol(llvm::object::XCOFFSymbolRef *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (!v1) {
    uint64_t v1 = *((void *)this + 2);
  }
  int v2 = *(unsigned __int8 *)(v1 + 16);
  BOOL result = 1;
  if (v2 != 2 && v2 != 107) {
    return v2 == 111;
  }
  return result;
}

void *llvm::object::XCOFFObjectFile::getCommonSymbolSizeImpl(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  v9[1] = 0;
  v9[2] = 0;
  v9[0] = a1;
  uint64_t v2 = 1;
  if (*(_DWORD *)(a1 + 8) == 11)
  {
    uint64_t v2 = 2;
    uint64_t v3 = a2;
  }
  else
  {
    uint64_t v3 = 0;
  }
  if (*(_DWORD *)(a1 + 8) == 11) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = a2;
  }
  v9[v2] = a2;
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = v3;
  }
  int v6 = *(unsigned __int8 *)(v5 + 16);
  if (v6 == 2 || v6 == 111 || (BOOL result = 0, v6 == 107))
  {
    llvm::object::XCOFFSymbolRef::getXCOFFCsectAuxRef((llvm::object::XCOFFSymbolRef *)v9, (uint64_t)&v10);
    if (v12)
    {
      uint64_t v8 = v10;
      sub_1CD4515D0(&v8);
      BOOL result = v8;
      if (v8)
      {
        (*(void (**)(void *))(*v8 + 8))(v8);
        return 0;
      }
    }
    else if (v10)
    {
      return (void *)bswap32(*(_DWORD *)v10);
    }
    else
    {
      return (void *)bswap64(v11[3] | ((unint64_t)*v11 << 32));
    }
  }
  return result;
}

uint64_t llvm::object::XCOFFSymbolRef::isFunction(llvm::object::XCOFFSymbolRef *this)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 1);
  if (v2) {
    uint64_t v3 = (unsigned __int8 *)(v2 + 16);
  }
  else {
    uint64_t v3 = (unsigned __int8 *)(*((void *)this + 2) + 16);
  }
  int v4 = *v3;
  if (v4 != 2 && v4 != 111 && v4 != 107) {
    return 0;
  }
  if (!v2) {
    uint64_t v2 = *((void *)this + 2);
  }
  if ((*(_WORD *)(v2 + 14) & 0x2000) != 0) {
    return 1;
  }
  llvm::object::XCOFFSymbolRef::getXCOFFCsectAuxRef(this, (uint64_t)&v14);
  if (v16)
  {
    uint64_t v11 = v14;
    sub_1CD4515D0(&v11);
    uint64_t result = (uint64_t)v11;
    if (!v11) {
      return result;
    }
    goto LABEL_22;
  }
  int v6 = v14;
  if (v14) {
    unsigned int v7 = v14;
  }
  else {
    unsigned int v7 = v15;
  }
  if ((*((unsigned char *)v7 + 10) & 7) != 2) {
    return 0;
  }
  if (!v14) {
    int v6 = v15;
  }
  if (*((unsigned char *)v6 + 11)) {
    return 0;
  }
  uint64_t v8 = *((void *)this + 1);
  if (!v8) {
    uint64_t v8 = *((void *)this + 2);
  }
  llvm::object::XCOFFObjectFile::getSectionByNum(*(void *)this, (int)bswap32(*(unsigned __int16 *)(v8 + 12)) >> 16, (uint64_t)&v12);
  if (v13)
  {
    unint64_t v10 = v12;
    sub_1CD4515D0(&v10);
    uint64_t result = (uint64_t)v10;
    if (!v10) {
      return result;
    }
LABEL_22:
    (*(void (**)(uint64_t))(*(void *)result + 8))(result);
    return 0;
  }
  uint64_t v9 = 36;
  if (*(_DWORD *)(*(void *)this + 8) == 11) {
    uint64_t v9 = 64;
  }
  return (*((unsigned __int8 *)v12 + v9 + 3) >> 5) & 1;
}

BOOL llvm::object::XCOFFObjectFile::is64Bit(llvm::object::XCOFFObjectFile *this)
{
  return *((_DWORD *)this + 2) == 11;
}

BOOL llvm::object::XCOFFObjectFile::isReservedSectionNumber(llvm::object::XCOFFObjectFile *this)
{
  return (this + 2) < 3;
}

uint64_t llvm::object::XCOFFObjectFile::getSectionNameInternal(uint64_t a1, uint64_t a2)
{
  return a2;
}

llvm::object *llvm::object::XCOFFObjectFile::getLoaderSectionAddress@<X0>(llvm::object *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *((void *)this + 8);
  uint64_t v4 = *((void *)this + 6);
  if (*((_DWORD *)this + 2) == 11)
  {
    unsigned int v5 = *(unsigned __int16 *)(v4 + 2);
    if (v5)
    {
      uint64_t v6 = v3 + 32;
      uint64_t v7 = 72 * __rev16(v5);
      while (*(unsigned __int16 *)(v6 + 34) << 16 != 0x100000)
      {
        v6 += 72;
        v7 -= 72;
        if (!v7) {
          goto LABEL_17;
        }
      }
      unint64_t v11 = bswap64(*(void *)v6);
      unint64_t v33 = v11;
      unint64_t v12 = bswap64(*(void *)(v6 - 8));
      goto LABEL_14;
    }
LABEL_17:
    *(unsigned char *)(a2 + 8) &= ~1u;
    *(void *)a2 = 0;
    return this;
  }
  unsigned int v8 = *(unsigned __int16 *)(v4 + 2);
  if (!v8) {
    goto LABEL_17;
  }
  uint64_t v9 = v3 + 20;
  uint64_t v10 = 40 * __rev16(v8);
  while (*(unsigned __int16 *)(v9 + 18) << 16 != 0x100000)
  {
    v9 += 40;
    v10 -= 40;
    if (!v10) {
      goto LABEL_17;
    }
  }
  unint64_t v11 = bswap32(*(_DWORD *)v9);
  unint64_t v33 = v11;
  unint64_t v12 = bswap32(*(_DWORD *)(v9 - 4));
LABEL_14:
  unint64_t v32 = v12;
  if (!v12) {
    goto LABEL_17;
  }
  unint64_t v13 = *((void *)this + 2) + v11;
  long long v14 = *((_OWORD *)this + 2);
  v30[0] = *((_OWORD *)this + 1);
  v30[1] = v14;
  this = sub_1CCC207AC((llvm::object *)v30, v13, v12, &v31);
  if (v31)
  {
    uint64_t v17 = v31;
    uint64_t v31 = 0;
    sub_1CD4FB504(&v17, &v18);
    uint64_t v15 = std::string::append(&v18, ": loader section with offset 0x");
    std::string::size_type v16 = v15->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
    std::string::size_type v20 = v16;
    v15->__r_.__value_.__l.__size_ = 0;
    v15->__r_.__value_.__r.__words[2] = 0;
    v15->__r_.__value_.__r.__words[0] = 0;
    v21[0] = __p;
    v21[2] = &v33;
    __int16 v22 = 3588;
    v23[0] = v21;
    _OWORD v23[2] = " and size 0x";
    __int16 v24 = 770;
    v25[0] = v23;
    _OWORD v25[2] = &v32;
    __int16 v26 = 3586;
    uint64_t v27 = v25;
    unint64_t v28 = " goes past the end of the file";
    __int16 v29 = 770;
    operator new();
  }
  *(unsigned char *)(a2 + 8) &= ~1u;
  *(void *)a2 = v13;
  return this;
}

uint64_t llvm::object::XCOFFObjectFile::sections64(llvm::object::XCOFFObjectFile *this)
{
  return *((void *)this + 8);
}

uint64_t llvm::object::XCOFFObjectFile::sections32(llvm::object::XCOFFObjectFile *this)
{
  return *((void *)this + 8);
}

uint64_t llvm::object::XCOFFObjectFile::getSectionFlags(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 36;
  if (*(_DWORD *)(a1 + 8) == 11) {
    uint64_t v2 = 64;
  }
  return bswap32(*(_DWORD *)(a2 + v2));
}

uint64_t llvm::object::XCOFFObjectFile::getRelocationSymbol(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) == 11)
  {
    unsigned int v2 = bswap32(*(_DWORD *)(a2 + 8));
    unsigned int v3 = bswap32(*(_DWORD *)(*(void *)(a1 + 48) + 20));
  }
  else
  {
    unsigned int v2 = bswap32(*(_DWORD *)(a2 + 4));
    int v4 = bswap32(*(_DWORD *)(*(void *)(a1 + 48) + 12));
    unsigned int v3 = v4 & ~(v4 >> 31);
  }
  if (v2 >= v3) {
    return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1);
  }
  else {
    return *(void *)(a1 + 72) + 18 * v2;
  }
}

uint64_t llvm::object::XCOFFObjectFile::getNumberOfSymbolTableEntries64(llvm::object::XCOFFObjectFile *this)
{
  return bswap32(*(_DWORD *)(*((void *)this + 6) + 20));
}

uint64_t llvm::object::XCOFFObjectFile::getLogicalNumberOfSymbolTableEntries32(llvm::object::XCOFFObjectFile *this)
{
  int v1 = bswap32(*(_DWORD *)(*((void *)this + 6) + 12));
  return v1 & ~(v1 >> 31);
}

uint64_t llvm::object::XCOFFObjectFile::getSymbolEntryAddressByIndex(llvm::object::XCOFFObjectFile *this, unsigned int a2)
{
  return *((void *)this + 9) + 18 * a2;
}

uint64_t llvm::object::XCOFFObjectFile::symbol_end(llvm::object::XCOFFObjectFile *this)
{
  uint64_t v1 = *((void *)this + 6);
  if (*((_DWORD *)this + 2) == 11)
  {
    unsigned int v2 = bswap32(*(_DWORD *)(v1 + 20));
  }
  else
  {
    int v3 = bswap32(*(_DWORD *)(v1 + 12));
    unsigned int v2 = v3 & ~(v3 >> 31);
  }
  return *((void *)this + 9) + 18 * v2;
}

uint64_t llvm::object::XCOFFObjectFile::getNumberOfSymbolTableEntries(llvm::object::XCOFFObjectFile *this)
{
  uint64_t v1 = *((void *)this + 6);
  if (*((_DWORD *)this + 2) == 11) {
    return bswap32(*(_DWORD *)(v1 + 20));
  }
  int v3 = bswap32(*(_DWORD *)(v1 + 12));
  return v3 & ~(v3 >> 31);
}

uint64_t llvm::object::XCOFFObjectFile::getSectionHeaderTableAddress(llvm::object::XCOFFObjectFile *this)
{
  return *((void *)this + 8);
}

uint64_t llvm::object::XCOFFObjectFile::getFileHeaderSize(llvm::object::XCOFFObjectFile *this)
{
  if (*((_DWORD *)this + 2) == 11) {
    return 24;
  }
  else {
    return 20;
  }
}

llvm::object *llvm::object::XCOFFObjectFile::getRawData@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, const std::string::value_type *a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v35 = a3;
  long long v9 = *(_OWORD *)(a1 + 32);
  v33[0] = *(_OWORD *)(a1 + 16);
  v33[1] = v9;
  uint64_t result = sub_1CCC207AC((llvm::object *)v33, a2, a3, &v34);
  if (v34)
  {
    uint64_t v18 = v34;
    uint64_t v34 = 0;
    sub_1CD4FB504(&v18, &v19);
    unint64_t v11 = std::string::append(&v19, ": ");
    std::string::size_type v12 = v11->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v20.__r_.__value_.__l.__data_ = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    v20.__r_.__value_.__r.__words[2] = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    unint64_t v13 = std::string::append(&v20, a4);
    std::string::size_type v14 = v13->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v21.__r_.__value_.__l.__data_ = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    v21.__r_.__value_.__r.__words[2] = v14;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    uint64_t v15 = std::string::append(&v21, " data with offset 0x");
    std::string::size_type v16 = v15->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
    std::string::size_type v23 = v16;
    v15->__r_.__value_.__l.__size_ = 0;
    v15->__r_.__value_.__r.__words[2] = 0;
    v15->__r_.__value_.__r.__words[0] = 0;
    unint64_t v17 = a2;
    v24[0] = __p;
    _OWORD v24[2] = &v17;
    __int16 v25 = 3588;
    v26[0] = v24;
    v26[2] = " and size 0x";
    __int16 v27 = 770;
    v28[0] = v26;
    v28[2] = &v35;
    __int16 v29 = 3586;
    uint64_t v30 = v28;
    uint64_t v31 = " goes past the end of the file";
    __int16 v32 = 770;
    operator new();
  }
  *(unsigned char *)(a5 + 16) &= ~1u;
  *(void *)a5 = a2;
  *(void *)(a5 + 8) = a3;
  return result;
}

uint64_t llvm::object::XCOFFObjectFile::getMagic(llvm::object::XCOFFObjectFile *this)
{
  return bswap32(**((unsigned __int16 **)this + 6)) >> 16;
}

uint64_t llvm::object::XCOFFObjectFile::getSymbolSectionName@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a2 + 8);
  if (!v4) {
    uint64_t v4 = *(void *)(a2 + 16);
  }
  int v5 = bswap32(*(unsigned __int16 *)(v4 + 12));
  int v6 = v5 >> 16;
  if (!(v5 >> 16))
  {
    *(unsigned char *)(a3 + 16) &= ~1u;
    uint64_t v7 = "N_UNDEF";
    goto LABEL_8;
  }
  if (v6 == -1)
  {
    *(unsigned char *)(a3 + 16) &= ~1u;
    uint64_t v7 = "N_ABS";
    uint64_t v8 = 5;
    goto LABEL_10;
  }
  if (v6 == -2)
  {
    *(unsigned char *)(a3 + 16) &= ~1u;
    uint64_t v7 = "N_DEBUG";
LABEL_8:
    uint64_t v8 = 7;
LABEL_10:
    *(void *)a3 = v7;
    *(void *)(a3 + 8) = v8;
    return result;
  }
  uint64_t result = llvm::object::XCOFFObjectFile::getSectionByNum(result, SHIWORD(v5), (uint64_t)&__s);
  if (v12)
  {
    long long v9 = __s;
    *(unsigned char *)(a3 + 16) |= 1u;
  }
  else
  {
    long long v9 = __s;
    uint64_t result = (uint64_t)memchr(__s, 0, 8uLL);
    uint64_t v10 = result - (void)v9;
    if (!result) {
      uint64_t v10 = 8;
    }
    *(unsigned char *)(a3 + 16) &= ~1u;
    *(void *)(a3 + 8) = v10;
  }
  *(void *)a3 = v9;
  return result;
}

uint64_t llvm::object::XCOFFObjectFile::getSymbolSectionID(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 8);
  BOOL v3 = v2 == 11;
  if (v2 == 11) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = a2;
  }
  if (v3) {
    uint64_t v5 = a2;
  }
  else {
    uint64_t v5 = 0;
  }
  if (!v4) {
    uint64_t v4 = v5;
  }
  return ((int)bswap32(*(unsigned __int16 *)(v4 + 12)) >> 16);
}

uint64_t llvm::object::XCOFFObjectFile::getTimeStamp(llvm::object::XCOFFObjectFile *this)
{
  return bswap32(*(_DWORD *)(*((void *)this + 6) + 4));
}

uint64_t llvm::object::XCOFFObjectFile::getOptionalHeaderSize(llvm::object::XCOFFObjectFile *this)
{
  return bswap32(*(unsigned __int16 *)(*((void *)this + 6) + 16)) >> 16;
}

uint64_t llvm::object::XCOFFObjectFile::getSymbolTableOffset32(llvm::object::XCOFFObjectFile *this)
{
  return bswap32(*(_DWORD *)(*((void *)this + 6) + 8));
}

uint64_t llvm::object::XCOFFObjectFile::getRawNumberOfSymbolTableEntries32(llvm::object::XCOFFObjectFile *this)
{
  return bswap32(*(_DWORD *)(*((void *)this + 6) + 12));
}

unint64_t llvm::object::XCOFFObjectFile::getSymbolTableOffset64(llvm::object::XCOFFObjectFile *this)
{
  return bswap64(*(void *)(*((void *)this + 6) + 8));
}

uint64_t llvm::object::XCOFFObjectFile::getEndOfSymbolTableAddress(llvm::object::XCOFFObjectFile *this)
{
  uint64_t v1 = *((void *)this + 6);
  if (*((_DWORD *)this + 2) == 11)
  {
    unsigned int v2 = bswap32(*(_DWORD *)(v1 + 20));
  }
  else
  {
    int v3 = bswap32(*(_DWORD *)(v1 + 12));
    unsigned int v2 = v3 & ~(v3 >> 31);
  }
  return *((void *)this + 9) + 18 * v2;
}

uint64_t llvm::object::XCOFFObjectFile::checkSymbolEntryPointer(uint64_t this, unint64_t a2)
{
  unint64_t v2 = *(void *)(this + 72);
  if (v2 > a2
    || ((uint64_t v3 = *(void *)(this + 48), *(_DWORD *)(this + 8) != 11)
      ? (int v5 = bswap32(*(_DWORD *)(v3 + 12)), v4 = v5 & ~(v5 >> 31))
      : (unsigned int v4 = bswap32(*(_DWORD *)(v3 + 20))),
        v2 + 18 * v4 <= a2))
  {
    int v6 = "Symbol table entry is outside of symbol table.";
    goto LABEL_10;
  }
  if (__ROR8__(0x8E38E38E38E38E39 * (a2 - v2), 1) >= 0xE38E38E38E38E39uLL)
  {
    int v6 = "Symbol table entry position is not valid inside of symbol table.";
LABEL_10:
    llvm::report_fatal_error((llvm *)v6, (const llvm::Twine *)1);
  }
  return this;
}

unint64_t llvm::object::XCOFFObjectFile::getSymbolIndex(llvm::object::XCOFFObjectFile *this, uint64_t a2)
{
  return (a2 - *((void *)this + 9)) / 0x12uLL;
}

void *llvm::object::XCOFFObjectFile::getSymbolSize(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  v10[1] = 0;
  _OWORD v10[2] = 0;
  v10[0] = a1;
  uint64_t v2 = 1;
  if (*(_DWORD *)(a1 + 8) == 11)
  {
    uint64_t v2 = 2;
    uint64_t v3 = a2;
  }
  else
  {
    uint64_t v3 = 0;
  }
  if (*(_DWORD *)(a1 + 8) == 11) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = a2;
  }
  v10[v2] = a2;
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = v3;
  }
  int v6 = *(unsigned __int8 *)(v5 + 16);
  if (v6 == 2 || v6 == 111 || (uint64_t result = 0, v6 == 107))
  {
    llvm::object::XCOFFSymbolRef::getXCOFFCsectAuxRef((llvm::object::XCOFFSymbolRef *)v10, (uint64_t)&v11);
    if (v13)
    {
      long long v9 = v11;
      sub_1CD4515D0(&v9);
      uint64_t result = v9;
      if (!v9) {
        return result;
      }
      (*(void (**)(void *))(*v9 + 8))(v9);
    }
    else
    {
      if (v11) {
        uint64_t v8 = v11;
      }
      else {
        uint64_t v8 = v12;
      }
      if ((*((unsigned char *)v8 + 10) & 5) == 1)
      {
        if (v11) {
          return (void *)bswap32(*(_DWORD *)v11);
        }
        else {
          return (void *)bswap64(v12[3] | ((unint64_t)*v12 << 32));
        }
      }
    }
    return 0;
  }
  return result;
}

uint64_t llvm::object::XCOFFObjectFile::getSymbolNameByIndex(llvm::object::XCOFFObjectFile *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 6);
  if (*((_DWORD *)this + 2) == 11)
  {
    unsigned int v3 = bswap32(*(_DWORD *)(v2 + 20));
  }
  else
  {
    int v4 = bswap32(*(_DWORD *)(v2 + 12));
    unsigned int v3 = v4 & ~(v4 >> 31);
  }
  if (v3 <= a2)
  {
    v7[0] = "symbol index ";
    v7[2] = a2;
    __int16 v8 = 2051;
    v9[0] = v7;
    v9[2] = " exceeds symbol count ";
    __int16 v10 = 770;
    unint64_t v11 = v9;
    uint64_t v12 = v3;
    __int16 v13 = 2050;
    operator new();
  }
  uint64_t v5 = *(uint64_t (**)(void))(*(void *)this + 72);

  return v5();
}

uint64_t llvm::object::XCOFFObjectFile::getFlags(llvm::object::XCOFFObjectFile *this)
{
  return bswap32(*(unsigned __int16 *)(*((void *)this + 6) + 18)) >> 16;
}

double llvm::object::XCOFFObjectFile::XCOFFObjectFile(uint64_t a1, int a2, long long *a3)
{
  long long v4 = *a3;
  long long v3 = a3[1];
  *(_DWORD *)(a1 + 8) = a2;
  *(_OWORD *)(a1 + 16) = v4;
  *(_OWORD *)(a1 + 32) = v3;
  *(void *)a1 = &unk_1F26344E0;
  *(void *)(a1 + 88) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_DWORD *)(a1 + 80) = 0;
  return result;
}

{
  long long v3;
  long long v4;
  double result;

  long long v4 = *a3;
  long long v3 = a3[1];
  *(_DWORD *)(a1 + 8) = a2;
  *(_OWORD *)(a1 + 16) = v4;
  *(_OWORD *)(a1 + 32) = v3;
  *(void *)a1 = &unk_1F26344E0;
  *(void *)(a1 + 88) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_DWORD *)(a1 + 80) = 0;
  return result;
}

llvm::object *llvm::object::XCOFFObjectFile::parseStringTable@<X0>(llvm::object::XCOFFObjectFile *this@<X0>, const llvm::object::XCOFFObjectFile *a2@<X1>, uint64_t a3@<X8>)
{
  int v6 = (char *)this + 16;
  uint64_t v5 = *((void *)this + 2);
  uint64_t v30 = a2;
  long long v7 = *((_OWORD *)this + 2);
  v29[0] = *((_OWORD *)this + 1);
  v29[1] = v7;
  double result = sub_1CCC207AC((llvm::object *)v29, (unint64_t)a2 + v5, 4uLL, &v25);
  if ((void)v25)
  {
    unint64_t v28 = (void *)v25;
    *(void *)&long long v25 = 0;
    sub_1CD4515D0(&v28);
    if (v28) {
      (*(void (**)(void *))(*v28 + 8))(v28);
    }
    *(unsigned char *)(a3 + 16) &= ~1u;
    *(_DWORD *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    double result = (llvm::object *)v25;
    if ((void)v25) {
      return (llvm::object *)(*(uint64_t (**)(void))(*(void *)v25 + 8))(v25);
    }
  }
  else
  {
    long long v9 = (unsigned int *)((char *)a2 + *(void *)v6);
    unint64_t v10 = bswap32(*v9);
    if (v10 > 4)
    {
      long long v11 = *((_OWORD *)v6 + 1);
      long long v25 = *(_OWORD *)v6;
      long long v26 = v11;
      double result = sub_1CCC207AC((llvm::object *)&v25, (unint64_t)v9, v10, v23);
      if (v23[0])
      {
        uint64_t v15 = v23[0];
        sub_1CD4FB504(&v15, &v16);
        uint64_t v12 = std::string::append(&v16, ": string table with offset 0x");
        std::string::size_type v13 = v12->__r_.__value_.__r.__words[2];
        *(_OWORD *)std::string __p = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
        std::string::size_type v18 = v13;
        v12->__r_.__value_.__l.__size_ = 0;
        v12->__r_.__value_.__r.__words[2] = 0;
        v12->__r_.__value_.__r.__words[0] = 0;
        v19[0] = __p;
        v19[2] = &v30;
        __int16 v20 = 3588;
        v21[0] = v19;
        v21[2] = " and size 0x";
        __int16 v22 = 770;
        unint64_t v14 = v10;
        v23[0] = v21;
        _OWORD v23[2] = &v14;
        __int16 v24 = 3586;
        *(void *)&long long v25 = v23;
        *(void *)&long long v26 = " goes past the end of the file";
        __int16 v27 = 770;
        operator new();
      }
      if (*((unsigned char *)v9 + (v10 - 1)))
      {
        *(void *)&v31.__val_ = llvm::object::object_category(result);
        double result = (llvm::object *)llvm::errorCodeToError((llvm *)5, v31, (void *)a3);
        *(unsigned char *)(a3 + 16) |= 1u;
      }
      else
      {
        *(unsigned char *)(a3 + 16) &= ~1u;
        *(_DWORD *)a3 = v10;
        *(void *)(a3 + 8) = v9;
      }
    }
    else
    {
      *(unsigned char *)(a3 + 16) &= ~1u;
      *(_DWORD *)a3 = 4;
      *(void *)(a3 + 8) = 0;
    }
  }
  return result;
}

llvm::object *llvm::object::XCOFFObjectFile::getImportFileTable@<X0>(llvm::object::XCOFFObjectFile *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  double result = llvm::object::XCOFFObjectFile::getLoaderSectionAddress(this, (uint64_t)&v30);
  if (v31)
  {
    uint64_t v6 = v30;
    *(unsigned char *)(a2 + 16) |= 1u;
    *(void *)a2 = v6;
  }
  else if (v30)
  {
    if (*((_DWORD *)this + 2) == 11) {
      unint64_t v5 = bswap64(*(void *)(v30 + 24));
    }
    else {
      unint64_t v5 = (int)bswap32(*(_DWORD *)(v30 + 20));
    }
    unint64_t v7 = bswap32(*(_DWORD *)(v30 + 12));
    unint64_t v29 = v7;
    long long v8 = *((_OWORD *)this + 2);
    long long v26 = *((_OWORD *)this + 1);
    long long v27 = v8;
    long long v9 = (char *)(v5 + v30);
    double result = sub_1CCC207AC((llvm::object *)&v26, v5 + v30, v7, v23);
    if (v23[0])
    {
      uint64_t v13 = v23[0];
      sub_1CD4FB504(&v13, &v14);
      unint64_t v10 = std::string::append(&v14, ": import file table with offset 0x");
      std::string::size_type v11 = v10->__r_.__value_.__r.__words[2];
      *(_OWORD *)std::string __p = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
      std::string::size_type v16 = v11;
      v10->__r_.__value_.__l.__size_ = 0;
      v10->__r_.__value_.__r.__words[2] = 0;
      v10->__r_.__value_.__r.__words[0] = 0;
      uint64_t v12 = v9;
      v17[0] = __p;
      std::string::size_type v18 = (void **)&v12;
      __int16 v19 = 3588;
      v20[0] = v17;
      std::string v21 = " and size 0x";
      __int16 v22 = 770;
      v23[0] = v20;
      __int16 v24 = &v29;
      __int16 v25 = 3586;
      *(void *)&long long v26 = v23;
      *(void *)&long long v27 = " goes past the end of the file";
      __int16 v28 = 770;
      operator new();
    }
    if (v9[v7 - 1])
    {
      __p[0] = v9;
      v17[0] = ": import file name table with offset 0x";
      std::string::size_type v18 = __p;
      __int16 v19 = 3587;
      v20[0] = v17;
      std::string v21 = " and size 0x";
      __int16 v22 = 770;
      v23[0] = v20;
      __int16 v24 = &v29;
      __int16 v25 = 3586;
      *(void *)&long long v26 = v23;
      *(void *)&long long v27 = " must end with a null terminator";
      __int16 v28 = 770;
      operator new();
    }
    *(unsigned char *)(a2 + 16) &= ~1u;
    *(void *)a2 = v9;
    *(void *)(a2 + 8) = v7;
  }
  else
  {
    *(unsigned char *)(a2 + 16) &= ~1u;
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
  }
  return result;
}

void llvm::object::XCOFFObjectFile::create()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

BOOL llvm::object::doesXCOFFTracebackTableBegin(_DWORD *a1, unint64_t a2)
{
  return a2 >= 4 && *a1 == 0;
}

void llvm::object::TBVectorExt::create(unsigned __int16 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  void v9[4] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = 0;
  llvm::object::TBVectorExt::TBVectorExt((uint64_t)&v7, a1, a2, &v6);
  long long v4 = v6;
  char v5 = *(unsigned char *)(a3 + 64);
  if (v6)
  {
    *(unsigned char *)(a3 + 64) = v5 | 1;
    *(void *)a3 = v4;
  }
  else
  {
    *(unsigned char *)(a3 + 64) = v5 & 0xFE;
    *(_WORD *)a3 = v7;
    *(void *)(a3 + 8) = a3 + 32;
    *(_OWORD *)(a3 + 16) = xmmword_1CDC7F9D0;
    if (v8[1]) {
      sub_1CC1B8518(a3 + 8, (uint64_t)v8);
    }
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t llvm::object::TBVectorExt::TBVectorExt(uint64_t a1, unsigned __int16 *a2, uint64_t a3, void **a4)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = a1 + 32;
  uint64_t v6 = a1 + 8;
  *(_OWORD *)(a1 + 16) = xmmword_1CDC7F9D0;
  unsigned int v7 = bswap32(*a2);
  *(_WORD *)a1 = HIWORD(v7);
  llvm::XCOFF::parseVectorParmsType((llvm::XCOFF *)bswap32(*(_DWORD *)(a2 + 1)), (v7 >> 17) & 0x7F, (uint64_t)v11);
  if (v13)
  {
    long long v9 = v11[0];
    *a4 = v11[0];
    if (!v9) {
LABEL_10:
    }
      *a4 = 0;
  }
  else
  {
    sub_1CC223970(v6, (uint64_t)v11);
    long long v8 = v11[0];
    if (v13)
    {
      v11[0] = 0;
      if (v8) {
        (*(void (**)(void *))(*(void *)v8 + 8))(v8);
      }
    }
    else if (v11[0] != &v12)
    {
      free(v11[0]);
    }
    if (!*a4) {
      goto LABEL_10;
    }
  }
  return a1;
}

uint64_t llvm::object::TBVectorExt::getNumberOfVRSaved(llvm::object::TBVectorExt *this)
{
  return *(unsigned __int16 *)this >> 10;
}

uint64_t llvm::object::TBVectorExt::isVRSavedOnStack(llvm::object::TBVectorExt *this)
{
  return (*(unsigned __int16 *)this >> 9) & 1;
}

uint64_t llvm::object::TBVectorExt::hasVarArgs(llvm::object::TBVectorExt *this)
{
  return HIBYTE(*(unsigned __int16 *)this) & 1;
}

uint64_t llvm::object::TBVectorExt::getNumberOfVectorParms(llvm::object::TBVectorExt *this)
{
  return *(unsigned __int8 *)this >> 1;
}

uint64_t llvm::object::TBVectorExt::hasVMXInstruction(llvm::object::TBVectorExt *this)
{
  return *(_WORD *)this & 1;
}

void llvm::object::XCOFFTracebackTable::create(llvm::object::XCOFFTracebackTable *this@<X0>, unsigned __int8 *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  unint64_t v10 = 0;
  llvm::object::XCOFFTracebackTable::XCOFFTracebackTable(&v11, (int *)this, (uint64_t *)a2, &v10);
  char v5 = v10;
  char v6 = *(unsigned char *)(a3 + 264);
  if (v10)
  {
    *(unsigned char *)(a3 + 264) = v6 | 1;
    *(void *)a3 = v5;
  }
  else
  {
    *(unsigned char *)(a3 + 264) = v6 & 0xFE;
    *(void *)a3 = v11;
    *(unsigned char *)(a3 + 8) = 0;
    *(unsigned char *)(a3 + 64) = 0;
    if (v14)
    {
      *(void *)(a3 + 8) = a3 + 32;
      *(_OWORD *)(a3 + 16) = xmmword_1CDC7F9D0;
      if (v12[1]) {
        sub_1CC1B8518(a3 + 8, (uint64_t)v12);
      }
      *(unsigned char *)(a3 + 64) = 1;
    }
    *(unsigned char *)(a3 + 96) = 0;
    *(_OWORD *)(a3 + 72) = v15;
    *(void *)(a3 + 88) = v16;
    *(unsigned char *)(a3 + 144) = 0;
    if (v21)
    {
      *(void *)(a3 + 96) = a3 + 112;
      *(void *)(a3 + 104) = 0x800000000;
      if (&v11 != (int **)a3)
      {
        unsigned int v7 = v18;
        if (v18)
        {
          if (__src == v20)
          {
            if (v18 >= 9) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            memcpy((void *)(a3 + 112), __src, 4 * v18);
            *(_DWORD *)(a3 + 104) = v7;
          }
          else
          {
            *(void *)(a3 + 96) = __src;
            int v9 = v19;
            *(_DWORD *)(a3 + 104) = v7;
            *(_DWORD *)(a3 + 108) = v9;
            __src = v20;
            int v19 = 0;
          }
          unsigned int v18 = 0;
        }
      }
      *(unsigned char *)(a3 + 144) = 1;
    }
    *(_OWORD *)(a3 + 152) = v22[0];
    *(_OWORD *)(a3 + 162) = *(_OWORD *)((char *)v22 + 10);
    *(unsigned char *)(a3 + 184) = 0;
    *(unsigned char *)(a3 + 248) = 0;
    if (v26)
    {
      __int16 v8 = v23;
      *(void *)(a3 + 192) = a3 + 216;
      *(_WORD *)(a3 + 184) = v8;
      *(_OWORD *)(a3 + 200) = xmmword_1CDC7F9D0;
      if (v24[1]) {
        sub_1CC1B8518(a3 + 192, (uint64_t)v24);
      }
      *(unsigned char *)(a3 + 248) = 1;
    }
    *(_WORD *)(a3 + 256) = v27;
  }
  if (v26)
  {
    if (v24[0] != &v25) {
      free(v24[0]);
    }
    char v26 = 0;
  }
  if (v21)
  {
    if (__src != v20) {
      free(__src);
    }
    char v21 = 0;
  }
  if (v14)
  {
    if (v12[0] != &v13) {
      free(v12[0]);
    }
  }
}

int **llvm::object::XCOFFTracebackTable::XCOFFTracebackTable(int **a1, int *a2, uint64_t *a3, void **a4)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  *a1 = a2;
  *((unsigned char *)a1 + 8) = 0;
  uint64_t v7 = (uint64_t)(a1 + 1);
  *((unsigned char *)a1 + 64) = 0;
  *((unsigned char *)a1 + 72) = 0;
  *((unsigned char *)a1 + 76) = 0;
  *((unsigned char *)a1 + 80) = 0;
  *((unsigned char *)a1 + 84) = 0;
  *((unsigned char *)a1 + 88) = 0;
  *((unsigned char *)a1 + 92) = 0;
  *((unsigned char *)a1 + 96) = 0;
  uint64_t v8 = (uint64_t)(a1 + 12);
  *((unsigned char *)a1 + 144) = 0;
  *((unsigned char *)a1 + 152) = 0;
  *((unsigned char *)a1 + 168) = 0;
  *((_WORD *)a1 + 88) = 0;
  *((unsigned char *)a1 + 184) = 0;
  *((unsigned char *)a1 + 248) = 0;
  *((_WORD *)a1 + 128) = 0;
  uint64_t v9 = *a3;
  v49[0] = a2;
  v49[1] = v9;
  __int16 v50 = 0;
  uint64_t v47 = 0;
  unint64_t v48 = 0;
  sub_1CD833894((uint64_t)v49, (unint64_t *)&v47, &v48);
  unint64_t v10 = 0;
  unsigned int v11 = (*a1)[1];
  int v12 = -(v11 >> 25);
  if (v48 || BYTE2(v11) == v12)
  {
    if (v48) {
      goto LABEL_5;
    }
  }
  else
  {
    unint64_t v10 = (llvm::XCOFF *)sub_1CD8337FC((uint64_t)v49, (unint64_t *)&v47, &v48);
    if (v48) {
      goto LABEL_5;
    }
  }
  if ((*((unsigned char *)*a1 + 2) & 0x20) != 0)
  {
    int v20 = sub_1CD8337FC((uint64_t)v49, (unint64_t *)&v47, &v48);
    int v21 = *((unsigned __int8 *)a1 + 76);
    *((_DWORD *)a1 + 18) = v20;
    if (!v21) {
      *((unsigned char *)a1 + 76) = 1;
    }
  }
LABEL_5:
  uint64_t v13 = v48;
  if (v48) {
    goto LABEL_71;
  }
  if (**a1 < 0)
  {
    int v22 = sub_1CD8337FC((uint64_t)v49, (unint64_t *)&v47, &v48);
    int v23 = *((unsigned __int8 *)a1 + 84);
    *((_DWORD *)a1 + 20) = v22;
    if (!v23) {
      *((unsigned char *)a1 + 84) = 1;
    }
  }
  uint64_t v13 = v48;
  if (v48) {
    goto LABEL_71;
  }
  int v14 = **a1;
  if ((v14 & 0x80000) != 0)
  {
    unsigned int v24 = sub_1CD8337FC((uint64_t)v49, (unint64_t *)&v47, &v48);
    if (!*((unsigned char *)a1 + 92)) {
      *((unsigned char *)a1 + 92) = 1;
    }
    *((_DWORD *)a1 + 22) = v24;
    uint64_t v13 = v48;
    if (v48) {
      goto LABEL_71;
    }
    uint64_t v51 = &v53;
    uint64_t v52 = (void *)0x800000000;
    if (v24 >= 9) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    BOOL v28 = 1;
    if (v24)
    {
      int v29 = 1;
      do
      {
        unsigned int v45 = v29;
        int v30 = sub_1CD8337FC((uint64_t)v49, (unint64_t *)&v47, &v48);
        if (v52 >= (unint64_t)HIDWORD(v52)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((_DWORD *)v51 + v52) = v30;
        LODWORD(v52) = v52 + 1;
        BOOL v28 = v48 == 0;
        if (!*((unsigned char *)a1 + 92)) {
          break;
        }
        int v29 = v45 + 1;
      }
      while (v45 < *((_DWORD *)a1 + 22) && v48 == 0);
    }
    if (v28) {
      sub_1CD5CAC7C(v8, (uint64_t)&v51);
    }
    if (v51 != &v53) {
      free(v51);
    }
    uint64_t v13 = v48;
    if (v48) {
      goto LABEL_71;
    }
    if ((**a1 & 0x40000000) == 0) {
      goto LABEL_10;
    }
  }
  else if ((v14 & 0x40000000) == 0)
  {
    goto LABEL_10;
  }
  unsigned int v32 = sub_1CD833674((uint64_t)v49, (unint64_t *)&v47, &v48);
  uint64_t v13 = v48;
  if (v48) {
    goto LABEL_71;
  }
  unint64_t Bytes = llvm::DataExtractor::getBytes(v49, (unint64_t *)&v47, v32, &v48);
  int v40 = *((unsigned __int8 *)a1 + 168);
  a1[19] = (int *)Bytes;
  a1[20] = v41;
  if (!v40) {
    *((unsigned char *)a1 + 168) = 1;
  }
LABEL_10:
  uint64_t v13 = v48;
  if (v48) {
    goto LABEL_71;
  }
  if ((*((unsigned char *)*a1 + 3) & 0x20) != 0)
  {
    char v15 = sub_1CD05EA24(v49, (unint64_t *)&v47, &v48);
    int v16 = *((unsigned __int8 *)a1 + 177);
    *((unsigned char *)a1 + 176) = v15;
    if (!v16) {
      *((unsigned char *)a1 + 177) = 1;
    }
  }
  uint64_t v13 = v48;
  if (v48) {
    goto LABEL_71;
  }
  if ((*((unsigned char *)*a1 + 5) & 0x40) != 0)
  {
    uint64_t v34 = (unsigned __int16 *)llvm::DataExtractor::getBytes(v49, (unint64_t *)&v47, 6, &v48);
    uint64_t v13 = v48;
    if (!v48)
    {
      llvm::object::TBVectorExt::create(v34, v35, (uint64_t)&v51);
      char v36 = v57;
      char v46 = v57;
      if (v57)
      {
        unsigned int v18 = 0;
        unint64_t v42 = v51;
        uint64_t v51 = 0;
        *a4 = v42;
        char v43 = v36;
      }
      else
      {
        int v37 = *((unsigned __int8 *)a1 + 248);
        *((_WORD *)a1 + 92) = (_WORD)v51;
        uint64_t v38 = (uint64_t)(a1 + 24);
        if (v37)
        {
          sub_1CC223970(v38, (uint64_t)&v52);
        }
        else
        {
          a1[24] = (int *)(a1 + 27);
          *(_OWORD *)(a1 + 25) = xmmword_1CDC7F9D0;
          if (v53) {
            sub_1CC223970(v38, (uint64_t)&v52);
          }
          *((unsigned char *)a1 + 248) = 1;
        }
        unsigned int v18 = *((_WORD *)a1 + 92) >> 1;
        char v43 = v57;
        char v36 = v46;
      }
      if (v43)
      {
        uint64_t v44 = v51;
        uint64_t v51 = 0;
        if (!v44) {
          goto LABEL_93;
        }
        (*(void (**)(void *))(*(void *)v44 + 8))(v44);
      }
      else
      {
        if (v52 == &v55) {
          goto LABEL_93;
        }
        free(v52);
      }
      char v36 = v46;
LABEL_93:
      unint64_t v17 = v48;
      if (v36) {
        goto LABEL_37;
      }
      goto LABEL_17;
    }
LABEL_71:
    *a4 = v13;
LABEL_72:
    *a3 = v47;
    goto LABEL_73;
  }
  unint64_t v17 = 0;
  unsigned int v18 = 0;
LABEL_17:
  if (v17 || BYTE2(v11) == v12) {
    goto LABEL_48;
  }
  unsigned int v19 = v11 >> 25;
  if ((*((unsigned char *)*a1 + 5) & 0x40) != 0) {
    llvm::XCOFF::parseParmsTypeWithVecInfo(v10, BYTE2(v11), v19, v18, (uint64_t)&v51);
  }
  else {
    llvm::XCOFF::parseParmsType(v10, BYTE2(v11), v19, (uint64_t)&v51);
  }
  if ((v56 & 1) == 0)
  {
    if (*((unsigned char *)a1 + 64))
    {
      sub_1CC223970(v7, (uint64_t)&v51);
    }
    else
    {
      a1[1] = (int *)(a1 + 4);
      *((_OWORD *)a1 + 1) = xmmword_1CDC7F9D0;
      if (v52) {
        sub_1CC223970(v7, (uint64_t)&v51);
      }
      *((unsigned char *)a1 + 64) = 1;
    }
    uint64_t v25 = v51;
    if (v56)
    {
      uint64_t v51 = 0;
      if (v25) {
        (*(void (**)(void *))(*(void *)v25 + 8))(v25);
      }
    }
    else if (v51 != &v54)
    {
      free(v51);
    }
    unint64_t v17 = v48;
LABEL_48:
    if (!v17 && (*((unsigned char *)*a1 + 5) & 0x80) != 0)
    {
      char v26 = sub_1CD05EA24(v49, (unint64_t *)&v47, &v48);
      int v27 = *((unsigned __int8 *)a1 + 257);
      *((unsigned char *)a1 + 256) = v26;
      if (!v27) {
        *((unsigned char *)a1 + 257) = 1;
      }
    }
    uint64_t v13 = v48;
    if (!v48) {
      goto LABEL_72;
    }
    goto LABEL_71;
  }
  *a4 = v51;
  unint64_t v17 = v48;
LABEL_37:
  if (v17) {
    (*(void (**)(void *))(*(void *)v17 + 8))(v17);
  }
LABEL_73:
  if (!*a4) {
    *a4 = 0;
  }
  return a1;
}

uint64_t llvm::object::XCOFFTracebackTable::getNumberOfFixedParms(llvm::object::XCOFFTracebackTable *this)
{
  return *(unsigned __int8 *)(*(void *)this + 6);
}

uint64_t llvm::object::XCOFFTracebackTable::getNumberOfFPParms(llvm::object::XCOFFTracebackTable *this)
{
  return *(_DWORD *)(*(void *)this + 4) >> 25;
}

uint64_t llvm::object::XCOFFTracebackTable::hasTraceBackTableOffset(llvm::object::XCOFFTracebackTable *this)
{
  return (*(unsigned __int8 *)(*(void *)this + 2) >> 5) & 1;
}

uint64_t llvm::object::XCOFFTracebackTable::isInterruptHandler(llvm::object::XCOFFTracebackTable *this)
{
  return **(_DWORD **)this >> 31;
}

uint64_t llvm::object::XCOFFTracebackTable::hasControlledStorage(llvm::object::XCOFFTracebackTable *this)
{
  return (*(unsigned __int8 *)(*(void *)this + 2) >> 3) & 1;
}

uint64_t llvm::object::XCOFFTracebackTable::isFuncNamePresent(llvm::object::XCOFFTracebackTable *this)
{
  return (*(unsigned __int8 *)(*(void *)this + 3) >> 6) & 1;
}

uint64_t llvm::object::XCOFFTracebackTable::isAllocaUsed(llvm::object::XCOFFTracebackTable *this)
{
  return (*(unsigned __int8 *)(*(void *)this + 3) >> 5) & 1;
}

uint64_t llvm::object::XCOFFTracebackTable::hasVectorInfo(llvm::object::XCOFFTracebackTable *this)
{
  return (*(unsigned __int8 *)(*(void *)this + 5) >> 6) & 1;
}

uint64_t llvm::object::XCOFFTracebackTable::hasExtensionTable(llvm::object::XCOFFTracebackTable *this)
{
  return *(unsigned __int8 *)(*(void *)this + 5) >> 7;
}

uint64_t llvm::object::XCOFFTracebackTable::getVersion(llvm::object::XCOFFTracebackTable *this)
{
  return **(unsigned __int8 **)this;
}

uint64_t llvm::object::XCOFFTracebackTable::getLanguageID(llvm::object::XCOFFTracebackTable *this)
{
  return *(unsigned __int8 *)(*(void *)this + 1);
}

uint64_t llvm::object::XCOFFTracebackTable::isGlobalLinkage(llvm::object::XCOFFTracebackTable *this)
{
  return *(unsigned __int8 *)(*(void *)this + 2) >> 7;
}

uint64_t llvm::object::XCOFFTracebackTable::isOutOfLineEpilogOrPrologue(llvm::object::XCOFFTracebackTable *this)
{
  return (*(unsigned __int8 *)(*(void *)this + 2) >> 6) & 1;
}

uint64_t llvm::object::XCOFFTracebackTable::isInternalProcedure(llvm::object::XCOFFTracebackTable *this)
{
  return (*(unsigned __int8 *)(*(void *)this + 2) >> 4) & 1;
}

uint64_t llvm::object::XCOFFTracebackTable::isTOCless(llvm::object::XCOFFTracebackTable *this)
{
  return (*(unsigned __int8 *)(*(void *)this + 2) >> 2) & 1;
}

uint64_t llvm::object::XCOFFTracebackTable::isFloatingPointPresent(llvm::object::XCOFFTracebackTable *this)
{
  return (*(unsigned __int8 *)(*(void *)this + 2) >> 1) & 1;
}

uint64_t llvm::object::XCOFFTracebackTable::isFloatingPointOperationLogOrAbortEnabled(llvm::object::XCOFFTracebackTable *this)
{
  return *(unsigned char *)(*(void *)this + 2) & 1;
}

uint64_t llvm::object::XCOFFTracebackTable::getOnConditionDirective(llvm::object::XCOFFTracebackTable *this)
{
  return (**(_DWORD **)this >> 26) & 7;
}

uint64_t llvm::object::XCOFFTracebackTable::isCRSaved(llvm::object::XCOFFTracebackTable *this)
{
  return (*(unsigned __int8 *)(*(void *)this + 3) >> 1) & 1;
}

uint64_t llvm::object::XCOFFTracebackTable::isLRSaved(llvm::object::XCOFFTracebackTable *this)
{
  return *(unsigned char *)(*(void *)this + 3) & 1;
}

uint64_t llvm::object::XCOFFTracebackTable::isBackChainStored(llvm::object::XCOFFTracebackTable *this)
{
  return *(unsigned __int8 *)(*(void *)this + 4) >> 7;
}

uint64_t llvm::object::XCOFFTracebackTable::isFixup(llvm::object::XCOFFTracebackTable *this)
{
  return (*(unsigned __int8 *)(*(void *)this + 4) >> 6) & 1;
}

uint64_t llvm::object::XCOFFTracebackTable::getNumOfFPRsSaved(llvm::object::XCOFFTracebackTable *this)
{
  return *(_DWORD *)(*(void *)this + 4) & 0x3F;
}

uint64_t llvm::object::XCOFFTracebackTable::getNumOfGPRsSaved(llvm::object::XCOFFTracebackTable *this)
{
  return (*(_DWORD *)(*(void *)this + 4) >> 8) & 0x3F;
}

uint64_t llvm::object::XCOFFTracebackTable::hasParmsOnStack(llvm::object::XCOFFTracebackTable *this)
{
  return *(unsigned char *)(*(void *)this + 7) & 1;
}

double llvm::opt::Arg::Arg(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(void *)(a1 + 16) = a7;
  *(void *)(a1 + 24) = a4;
  *(void *)(a1 + 32) = a5;
  *(_DWORD *)(a1 + 40) = a6;
  *(unsigned char *)(a1 + 44) &= 0xFCu;
  *(void *)(a1 + 48) = a1 + 64;
  *(void *)&double result = 0x200000000;
  *(void *)(a1 + 56) = 0x200000000;
  *(void *)(a1 + 80) = 0;
  return result;
}

{
  double result;

  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(void *)(a1 + 16) = a7;
  *(void *)(a1 + 24) = a4;
  *(void *)(a1 + 32) = a5;
  *(_DWORD *)(a1 + 40) = a6;
  *(unsigned char *)(a1 + 44) &= 0xFCu;
  *(void *)(a1 + 48) = a1 + 64;
  *(void *)&double result = 0x200000000;
  *(void *)(a1 + 56) = 0x200000000;
  *(void *)(a1 + 80) = 0;
  return result;
}

double llvm::opt::Arg::Arg(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(void *)(a1 + 16) = a8;
  *(void *)(a1 + 24) = a4;
  *(void *)(a1 + 32) = a5;
  *(_DWORD *)(a1 + 40) = a6;
  *(unsigned char *)(a1 + 44) &= 0xFCu;
  *(void *)(a1 + 64) = a7;
  *(void *)(a1 + 48) = a1 + 64;
  *(void *)(a1 + 80) = 0;
  *(void *)&double result = 0x200000001;
  *(void *)(a1 + 56) = 0x200000001;
  return result;
}

{
  double result;

  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(void *)(a1 + 16) = a8;
  *(void *)(a1 + 24) = a4;
  *(void *)(a1 + 32) = a5;
  *(_DWORD *)(a1 + 40) = a6;
  *(unsigned char *)(a1 + 44) &= 0xFCu;
  *(void *)(a1 + 64) = a7;
  *(void *)(a1 + 48) = a1 + 64;
  *(void *)(a1 + 80) = 0;
  *(void *)&double result = 0x200000001;
  *(void *)(a1 + 56) = 0x200000001;
  return result;
}

void llvm::opt::Arg::~Arg(llvm::opt::Arg *this)
{
  if ((*((unsigned char *)this + 44) & 2) != 0)
  {
    uint64_t v4 = *((unsigned int *)this + 14);
    if (v4)
    {
      uint64_t v5 = 0;
      uint64_t v6 = 8 * v4;
      do
      {
        uint64_t v7 = *(void *)(*((void *)this + 6) + v5);
        if (v7) {
          MEMORY[0x1D25D9CB0](v7, 0x1000C8077774924);
        }
        v5 += 8;
      }
      while (v6 != v5);
    }
  }
  uint64_t v2 = (llvm::opt::Arg *)*((void *)this + 10);
  *((void *)this + 10) = 0;
  if (v2)
  {
    llvm::opt::Arg::~Arg(v2);
    MEMORY[0x1D25D9CE0]();
  }
  long long v3 = (char *)*((void *)this + 6);
  if (v3 != (char *)this + 64) {
    free(v3);
  }
}

void llvm::opt::Arg::render(uint64_t a1, llvm::raw_ostream *a2, unsigned int *a3)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  int v6 = *(_DWORD *)(*(void *)a1 + 40);
  if ((v6 & 4) != 0)
  {
LABEL_7:
    uint64_t v11 = *(unsigned int *)(a1 + 40);
    int v12 = *(const void **)(a1 + 24);
    uint64_t v13 = *(void ***)(a1 + 32);
    int v14 = *(const char ***)(a1 + 48);
    char v15 = (char *)*v14;
    if (*v14) {
      int v16 = (void **)strlen(*v14);
    }
    else {
      int v16 = 0;
    }
    uint64_t JoinedArgString = llvm::opt::ArgList::GetOrMakeJoinedArgString(a2, v11, v12, v13, (void **)v15, v16);
    unsigned int v18 = a3[2];
    if (v18 >= a3[3]) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)a3 + 8 * v18) = JoinedArgString;
    ++a3[2];
    uint64_t v19 = *(void *)(a1 + 48);
    int v20 = (unsigned char *)(v19 + 8);
    int v21 = (unsigned char *)(v19 + 8 * *(unsigned int *)(a1 + 56));
LABEL_11:
    sub_1CB935BDC(a3, v20, v21);
  }
  else if ((v6 & 8) != 0)
  {
LABEL_4:
    uint64_t v7 = *(void **)(a1 + 24);
    uint64_t v8 = *(void *)(a1 + 32);
    v44[4] = 261;
    unint64_t v42 = v7;
    *(void *)&long long v43 = v8;
    uint64_t v9 = sub_1CCC8E7F0(a2, (void ***)&v42);
    unsigned int v10 = a3[2];
    if (v10 >= a3[3]) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)a3 + 8 * v10) = v9;
    ++a3[2];
    sub_1CB935BDC(a3, *(unsigned char **)(a1 + 48), (unsigned char *)(*(void *)(a1 + 48) + 8 * *(unsigned int *)(a1 + 56)));
  }
  else
  {
    switch(*(unsigned char *)(*(void *)a1 + 36))
    {
      case 3:
      case 5:
      case 6:
      case 7:
      case 8:
      case 0xA:
      case 0xB:
        goto LABEL_4;
      case 4:
      case 0xC:
        goto LABEL_7;
      case 9:
        unint64_t v41 = &v42;
        unint64_t v42 = v44;
        long long v43 = xmmword_1CD96DBF0;
        int v34 = 0;
        char v38 = 0;
        uint64_t v39 = 0;
        int v40 = 0;
        unint64_t v33 = &unk_1F2646FA8;
        uint64_t v35 = 0;
        unint64_t v36 = 0;
        int v37 = 0;
        size_t v22 = *(void *)(a1 + 32);
        if (v22) {
          llvm::raw_ostream::write((llvm::raw_ostream *)&v33, *(const char **)(a1 + 24), v22);
        }
        uint64_t v23 = *(unsigned int *)(a1 + 56);
        if (v23)
        {
          uint64_t v24 = 0;
          uint64_t v25 = 8 * v23;
          do
          {
            if (v24)
            {
              char v26 = v37;
              if ((unint64_t)v37 >= v36)
              {
                llvm::raw_ostream::write((llvm::raw_ostream *)&v33, 44);
              }
              else
              {
                ++v37;
                *char v26 = 44;
              }
            }
            sub_1CB8E509C((llvm::raw_ostream *)&v33, *(char **)(*(void *)(a1 + 48) + v24));
            v24 += 8;
          }
          while (v25 != v24);
        }
        BOOL v28 = (void **)*v41;
        int v27 = (void **)v41[1];
        __int16 v32 = 261;
        v31[0] = v28;
        v31[1] = v27;
        uint64_t v29 = sub_1CCC8E7F0(a2, v31);
        unsigned int v30 = a3[2];
        if (v30 >= a3[3]) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)a3 + 8 * v30) = v29;
        ++a3[2];
        llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v33);
        if (v42 != v44) {
          free(v42);
        }
        break;
      default:
        int v20 = *(unsigned char **)(a1 + 48);
        int v21 = &v20[8 * *(unsigned int *)(a1 + 56)];
        goto LABEL_11;
    }
  }
}

uint64_t sub_1CCC8E7F0(llvm::raw_ostream *a1, void ***a2)
{
  v22[32] = *MEMORY[0x1E4F143B8];
  int v20 = v22;
  long long v21 = xmmword_1CD96DBF0;
  char v4 = *((unsigned char *)a2 + 32);
  if (*((unsigned char *)a2 + 33) == 1)
  {
    size_t v5 = 0;
    int v6 = 0;
    switch(*((unsigned char *)a2 + 32))
    {
      case 1:
        break;
      case 3:
        int v6 = *a2;
        if (*a2) {
          size_t v5 = strlen((const char *)*a2);
        }
        else {
          size_t v5 = 0;
        }
        break;
      case 4:
        char v10 = *((unsigned char *)*a2 + 23);
        if (v10 >= 0) {
          int v6 = *a2;
        }
        else {
          int v6 = **a2;
        }
        if (v10 >= 0) {
          size_t v5 = v10 & 0x7F;
        }
        else {
          size_t v5 = (size_t)(*a2)[1];
        }
        break;
      case 5:
        int v6 = *a2;
        size_t v5 = (size_t)a2[1];
        break;
      default:
        goto LABEL_9;
    }
  }
  else
  {
LABEL_9:
    int v12 = 0;
    char v16 = 0;
    uint64_t v17 = 0;
    uint64_t v19 = &v20;
    int v18 = 0;
    uint64_t v11 = &unk_1F2646FA8;
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    uint64_t v9 = llvm::Twine::printOneChild(a1, (llvm::raw_ostream *)&v11, (uint64_t)*a2, (size_t)a2[1], v4);
    llvm::Twine::printOneChild(v9, (llvm::raw_ostream *)&v11, (uint64_t)a2[2], (size_t)a2[3], *((unsigned char *)a2 + 33));
    uint64_t v11 = &unk_1F2646B98;
    if (v18 == 1 && v13) {
      MEMORY[0x1D25D9CB0](v13, 0x1000C8077774924);
    }
    int v6 = v20;
    size_t v5 = v21;
  }
  uint64_t v7 = (*(uint64_t (**)(llvm::raw_ostream *, void *, size_t))(*(void *)a1 + 16))(a1, v6, v5);
  if (v20 != v22) {
    free(v20);
  }
  return v7;
}

unint64_t llvm::opt::ArgList::append(llvm::opt::ArgList *this, llvm::opt::Arg *a2)
{
  unsigned int v3 = *((_DWORD *)this + 4);
  if (v3 >= *((_DWORD *)this + 5)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*((void *)this + 1) + 8 * v3) = a2;
  ++*((_DWORD *)this + 4);
  unint64_t result = sub_1CCC8EAFC((uint64_t *)a2);
  if (result)
  {
    unint64_t v6 = result;
    uint64_t v7 = v5;
    do
    {
      LODWORD(v13[0]) = *(_DWORD *)(v6 + 32);
      *(void *)((char *)v13 + 4) = 0xFFFFFFFFLL;
      uint64_t v11 = v13[0];
      int v12 = 0;
      unint64_t result = sub_1CCC8FC8C((uint64_t)this + 152, &v11, (uint64_t *)((char *)&v11 + 4), (uint64_t)v13);
      uint64_t v8 = v13[0];
      int v9 = *((_DWORD *)this + 4);
      int v10 = v9 - 1;
      if ((v9 - 1) >= *(_DWORD *)(v13[0] + 4)) {
        int v10 = *(_DWORD *)(v13[0] + 4);
      }
      *(_DWORD *)(v13[0] + 4) = v10;
      *(_DWORD *)(v8 + 8) = v9;
      if (!*(_WORD *)(v6 + 44)) {
        break;
      }
      unint64_t v6 = *v7 + ((unint64_t)(*(unsigned __int16 *)(v6 + 44) - 1) << 6);
    }
    while (*v7);
  }
  return result;
}

uint64_t sub_1CCC8EAFC(uint64_t *a1)
{
  uint64_t result = *a1;
  if (*(_WORD *)(result + 46))
  {
    unsigned int v3 = (uint64_t *)a1[1];
    uint64_t v4 = *v3;
    v5[0] = *v3 + ((unint64_t)(*(unsigned __int16 *)(result + 46) - 1) << 6);
    v5[1] = v3;
    if (v4) {
      return sub_1CCC8EAFC(v5);
    }
  }
  return result;
}

double sub_1CCC8EB50@<D0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  int v14 = a2;
  unint64_t Range = llvm::opt::ArgList::getRange(a1, &v14, 1);
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = v7 + 8 * HIDWORD(Range);
  *(void *)&long long v12 = v7 + 8 * Range;
  *((void *)&v12 + 1) = v8;
  LODWORD(v13) = a2;
  sub_1CCC8FC30((uint64_t)&v12);
  *(void *)&long long v10 = v8;
  *((void *)&v10 + 1) = v8;
  LODWORD(v11) = a2;
  sub_1CCC8FC30((uint64_t)&v10);
  *(_OWORD *)a3 = v12;
  *(void *)(a3 + 16) = v13;
  double result = *(double *)&v10;
  *(_OWORD *)(a3 + 24) = v10;
  *(void *)(a3 + 40) = v11;
  return result;
}

unint64_t llvm::opt::ArgList::getRange(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  uint64_t v3 = 0;
  if (!a3) {
    goto LABEL_11;
  }
  uint64_t v4 = &a2[a3];
  uint64_t v5 = *(void *)(a1 + 152);
  unsigned int v6 = *(_DWORD *)(a1 + 168);
  unsigned int v7 = v6 - 1;
  unsigned int v8 = -1;
  do
  {
    if (v6)
    {
      unsigned int v9 = (37 * *a2) & v7;
      long long v10 = (int *)(v5 + 12 * v9);
      int v11 = *v10;
      if (*a2 == *v10)
      {
LABEL_13:
        if (v10 != (int *)(v5 + 12 * v6))
        {
          unsigned int v15 = v10[2];
          if (v10[1] < v8) {
            unsigned int v8 = v10[1];
          }
          if (v3 <= v15) {
            uint64_t v3 = v15;
          }
          else {
            uint64_t v3 = v3;
          }
        }
      }
      else
      {
        int v12 = 1;
        while (v11 != -1)
        {
          unsigned int v13 = v9 + v12++;
          unsigned int v9 = v13 & v7;
          long long v10 = (int *)(v5 + 12 * v9);
          int v11 = *v10;
          if (*a2 == *v10) {
            goto LABEL_13;
          }
        }
      }
    }
    ++a2;
  }
  while (a2 != v4);
  if (v8 == -1) {
LABEL_11:
  }
    unsigned int v8 = 0;
  return v8 | (unint64_t)(v3 << 32);
}

uint64_t llvm::opt::ArgList::hasFlag(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v5 = a2;
  unsigned int v6 = (void *)sub_1CCC8ECF8(a1, a2, a3);
  if (!v6) {
    return a4;
  }

  return llvm::opt::Option::matches(v6, v5);
}

uint64_t sub_1CCC8ECF8(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v21 = __PAIR64__(a3, a2);
  unint64_t Range = llvm::opt::ArgList::getRange(a1, &v21, 2);
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = v7 + 8 * HIDWORD(Range);
  *(void *)&long long v21 = v7 + 8 * Range;
  *((void *)&v21 + 1) = v8;
  unint64_t v22 = __PAIR64__(a3, a2);
  sub_1CCC8FD24((uint64_t)&v21);
  v18[0] = v8;
  v18[1] = v8;
  unsigned int v19 = a2;
  unsigned int v20 = a3;
  sub_1CCC8FD24((uint64_t)v18);
  long long v16 = v21;
  unint64_t v17 = v22;
  uint64_t v9 = v18[0];
  long long v10 = (uint64_t *)v21;
  if ((void)v21 == v18[0]) {
    return 0;
  }
  do
  {
    uint64_t v14 = *v10;
    unsigned int v13 = v10 + 1;
    uint64_t v11 = v14;
    uint64_t v15 = *(void *)(v14 + 16);
    if (!v15) {
      uint64_t v15 = v11;
    }
    *(unsigned char *)(v15 + 44) |= 1u;
    *(void *)&long long v16 = v13;
    sub_1CCC8FD24((uint64_t)&v16);
    long long v10 = (uint64_t *)v16;
  }
  while ((void)v16 != v9);
  return v11;
}

const char *llvm::opt::ArgList::getLastArgValue(uint64_t a1, int a2, const char *a3)
{
  sub_1CCC8EB50(a1, a2, (uint64_t)&v14);
  long long v12 = v14;
  uint64_t v4 = v16;
  uint64_t v13 = v15;
  uint64_t v5 = (uint64_t *)v14;
  if ((void)v14 != v16)
  {
    do
    {
      uint64_t v9 = *v5;
      uint64_t v7 = v5 + 1;
      uint64_t v8 = v9;
      uint64_t v10 = *(void *)(v9 + 16);
      if (!v10) {
        uint64_t v10 = v8;
      }
      *(unsigned char *)(v10 + 44) |= 1u;
      *(void *)&long long v12 = v7;
      sub_1CCC8FC30((uint64_t)&v12);
      uint64_t v5 = (uint64_t *)v12;
    }
    while ((void)v12 != v4);
    uint64_t v11 = *(const char ***)(v8 + 48);
    a3 = *v11;
    if (*v11) {
      strlen(*v11);
    }
  }
  return a3;
}

void llvm::opt::ArgList::getAllArgValues(uint64_t a1@<X0>, unsigned int a2@<W1>, void *a3@<X8>)
{
  v16[16] = *MEMORY[0x1E4F143B8];
  long long v14 = v16;
  uint64_t v15 = 0x1000000000;
  llvm::opt::ArgList::AddAllArgValues(a1, (unsigned int *)&v14, a2, 0, 0);
  uint64_t v4 = (const char **)v14;
  uint64_t v5 = v15;
  a3[1] = 0;
  a3[2] = 0;
  *a3 = 0;
  if (!v5) {
    goto LABEL_13;
  }
  unsigned int v6 = operator new(24 * v5);
  *a3 = v6;
  a3[2] = &v6[3 * v5];
  uint64_t v7 = 8 * v5;
  do
  {
    uint64_t v8 = *v4;
    size_t v9 = strlen(*v4);
    if (v9 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    size_t v10 = v9;
    if (v9 >= 0x17)
    {
      uint64_t v12 = (v9 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v9 | 7) != 0x17) {
        uint64_t v12 = v9 | 7;
      }
      uint64_t v13 = v12 + 1;
      uint64_t v11 = operator new(v12 + 1);
      v6[1] = v10;
      void v6[2] = v13 | 0x8000000000000000;
      *unsigned int v6 = v11;
LABEL_10:
      memmove(v11, v8, v10);
      goto LABEL_11;
    }
    *((unsigned char *)v6 + 23) = v9;
    uint64_t v11 = v6;
    if (v9) {
      goto LABEL_10;
    }
LABEL_11:
    *((unsigned char *)v11 + v10) = 0;
    ++v4;
    v6 += 3;
    v7 -= 8;
  }
  while (v7);
  a3[1] = v6;
  uint64_t v4 = (const char **)v14;
LABEL_13:
  if (v4 != v16) {
    free(v4);
  }
}

void llvm::opt::ArgList::AddAllArgValues(uint64_t a1, unsigned int *a2, unsigned int a3, unsigned int a4, int a5)
{
  sub_1CCC8F340(v10, a1, a3, a4, a5);
  v9[0] = v10[0];
  v9[1] = v10[1];
  uint64_t v6 = v11;
  while (*(void *)&v9[0] != v6)
  {
    uint64_t v7 = **(void **)&v9[0];
    uint64_t v8 = *(void *)(**(void **)&v9[0] + 16);
    if (!v8) {
      uint64_t v8 = **(void **)&v9[0];
    }
    *(unsigned char *)(v8 + 44) |= 1u;
    sub_1CB935BDC(a2, *(unsigned char **)(v7 + 48), (unsigned char *)(*(void *)(v7 + 48) + 8 * *(unsigned int *)(v7 + 56)));
    *(void *)&v9[0] += 8;
    sub_1CCC8FD9C((uint64_t)v9);
  }
}

void llvm::opt::ArgList::addOptInFlag(llvm::raw_ostream *a1, unsigned int *a2, unsigned int a3, unsigned int a4)
{
  uint64_t v6 = a3;
  uint64_t v7 = (void *)sub_1CCC8ECF8((uint64_t)a1, a3, a4);
  if (v7)
  {
    uint64_t v8 = (uint64_t)v7;
    if (llvm::opt::Option::matches(v7, v6))
    {
      llvm::opt::Arg::render(v8, a1, a2);
    }
  }
}

void llvm::opt::ArgList::AddAllArgsExcept(uint64_t a1, unsigned int *a2, unsigned int *a3, uint64_t a4, unsigned int *a5, uint64_t a6)
{
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 8 * v10;
    for (i = *(void **)(a1 + 8); !*i; ++i)
    {
      v11 -= 8;
      if (!v11) {
        return;
      }
    }
  }
  else
  {
    i = *(void **)(a1 + 8);
  }
  uint64_t v13 = *(void *)(a1 + 8) + 8 * v10;
  if (i != (void *)v13)
  {
    long long v14 = (void *)*i;
    uint64_t v22 = 4 * a6;
LABEL_6:
    if (a6)
    {
      uint64_t v21 = v22;
      unsigned int v20 = a5;
      while ((llvm::opt::Option::matches(v14, *v20) & 1) == 0)
      {
        ++v20;
        v21 -= 4;
        if (!v21) {
          goto LABEL_7;
        }
      }
    }
    else
    {
LABEL_7:
      if (a4)
      {
        uint64_t v15 = 4 * a4;
        uint64_t v16 = a3;
        while (!llvm::opt::Option::matches(v14, *v16))
        {
          ++v16;
          v15 -= 4;
          if (!v15) {
            goto LABEL_11;
          }
        }
        unsigned int v19 = (void *)v14[2];
        if (!v19) {
          unsigned int v19 = v14;
        }
        *((unsigned char *)v19 + 44) |= 1u;
        llvm::opt::Arg::render((uint64_t)v14, (llvm::raw_ostream *)a1, a2);
      }
    }
LABEL_11:
    unint64_t v17 = i + 1;
    while (v17 != (void *)v13)
    {
      int v18 = (void *)*v17++;
      long long v14 = v18;
      if (v18)
      {
        i = v17 - 1;
        goto LABEL_6;
      }
    }
  }
}

void llvm::opt::ArgList::AddAllArgs(llvm::raw_ostream *a1, unsigned int *a2, unsigned int a3, unsigned int a4, int a5)
{
  sub_1CCC8F340(v12, (uint64_t)a1, a3, a4, a5);
  v11[0] = v12[0];
  v11[1] = v12[1];
  for (uint64_t i = v13; *(void *)&v11[0] != i; uint64_t i = v10)
  {
    uint64_t v10 = i;
    uint64_t v8 = **(void **)&v11[0];
    uint64_t v9 = *(void *)(**(void **)&v11[0] + 16);
    if (!v9) {
      uint64_t v9 = **(void **)&v11[0];
    }
    *(unsigned char *)(v9 + 44) |= 1u;
    llvm::opt::Arg::render(v8, a1, a2);
    *(void *)&v11[0] += 8;
    sub_1CCC8FD9C((uint64_t)v11);
  }
}

double sub_1CCC8F340(_OWORD *a1, uint64_t a2, unsigned int a3, unsigned int a4, int a5)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  v20[0] = a3;
  v20[1] = a4;
  void v20[2] = a5;
  unint64_t Range = llvm::opt::ArgList::getRange(a2, v20, 3);
  uint64_t v11 = *(void *)(a2 + 8);
  uint64_t v12 = v11 + 8 * HIDWORD(Range);
  *(void *)&long long v18 = v11 + 8 * Range;
  *((void *)&v18 + 1) = v12;
  *(void *)&long long v19 = __PAIR64__(a4, a3);
  DWORD2(v19) = a5;
  sub_1CCC8FD9C((uint64_t)&v18);
  *(void *)&long long v16 = v12;
  *((void *)&v16 + 1) = v12;
  *(void *)&long long v17 = __PAIR64__(a4, a3);
  DWORD2(v17) = a5;
  sub_1CCC8FD9C((uint64_t)&v16);
  long long v13 = v19;
  *a1 = v18;
  a1[1] = v13;
  double result = *(double *)&v16;
  long long v15 = v17;
  a1[2] = v16;
  a1[3] = v15;
  return result;
}

void llvm::opt::ArgList::ClaimAllArgs(uint64_t a1, int a2)
{
  sub_1CCC8EB50(a1, a2, (uint64_t)&v7);
  long long v5 = v7;
  uint64_t v2 = v9;
  uint64_t v6 = v8;
  while ((void)v5 != v2)
  {
    uint64_t v3 = v5 + 8;
    uint64_t v4 = *(void *)v5;
    if (*(void *)(*(void *)v5 + 16)) {
      uint64_t v4 = *(void *)(*(void *)v5 + 16);
    }
    *(unsigned char *)(v4 + 44) |= 1u;
    *(void *)&long long v5 = v3;
    sub_1CCC8FC30((uint64_t)&v5);
  }
}

uint64_t llvm::opt::ArgList::GetOrMakeJoinedArgString(llvm::raw_ostream *a1, uint64_t a2, const void *a3, void **a4, void **a5, void **a6)
{
  uint64_t v11 = (const char *)(**(uint64_t (***)(llvm::raw_ostream *))a1)(a1);
  uint64_t v12 = v11;
  if (v11) {
    size_t v13 = strlen(v11);
  }
  else {
    size_t v13 = 0;
  }
  if ((void **)v13 != (void **)((char *)a4 + (void)a6) || v13 < (unint64_t)a4) {
    goto LABEL_16;
  }
  if (a4)
  {
    if (memcmp(v12, a3, (size_t)a4) || v13 < (unint64_t)a6) {
      goto LABEL_16;
    }
  }
  else if (v13 < (unint64_t)a6)
  {
LABEL_16:
    v16[0] = (void **)a3;
    v16[1] = a4;
    v16[2] = a5;
    v16[3] = a6;
    __int16 v17 = 1285;
    return sub_1CCC8E7F0(a1, v16);
  }
  if (a6 && memcmp((const void *)(&v12[v13] - (const char *)a6), a5, (size_t)a6)) {
    goto LABEL_16;
  }
  return (uint64_t)v12;
}

uint64_t llvm::opt::InputArgList::releaseMemory(uint64_t this)
{
  uint64_t v1 = *(unsigned int *)(this + 16);
  if (v1)
  {
    uint64_t v2 = 8 * v1;
    for (uint64_t i = *(uint64_t **)(this + 8); !*i; ++i)
    {
      v2 -= 8;
      if (!v2) {
        return this;
      }
    }
  }
  else
  {
    uint64_t i = *(uint64_t **)(this + 8);
  }
  uint64_t v4 = *(void *)(this + 8) + 8 * v1;
  if (i != (uint64_t *)v4)
  {
    this = *i;
LABEL_6:
    if (this)
    {
      llvm::opt::Arg::~Arg((llvm::opt::Arg *)this);
      this = MEMORY[0x1D25D9CE0]();
    }
    long long v5 = i + 1;
    while (v5 != (uint64_t *)v4)
    {
      uint64_t v6 = *v5++;
      this = v6;
      if (v6)
      {
        uint64_t i = v5 - 1;
        goto LABEL_6;
      }
    }
  }
  return this;
}

llvm::opt::InputArgList *llvm::opt::InputArgList::InputArgList(llvm::opt::InputArgList *this, const char **a2, const char **a3)
{
  *((void *)this + 2) = 0x1000000000;
  *((void *)this + 19) = 0;
  *((void *)this + 20) = 0;
  *((_DWORD *)this + 42) = 0;
  *(void *)this = &unk_1F26346A0;
  *((void *)this + 1) = (char *)this + 24;
  *((void *)this + 22) = (char *)this + 192;
  *((void *)this + 23) = 0x1000000000;
  *((void *)this + 40) = (char *)this + 320;
  *((void *)this + 41) = (char *)this + 320;
  *((void *)this + 42) = 0;
  *((_DWORD *)this + 86) = (unint64_t)((char *)a3 - (char *)a2) >> 3;
  sub_1CB935BDC((unsigned int *)this + 44, a2, a3);
  return this;
}

{
  *((void *)this + 2) = 0x1000000000;
  *((void *)this + 19) = 0;
  *((void *)this + 20) = 0;
  *((_DWORD *)this + 42) = 0;
  *(void *)this = &unk_1F26346A0;
  *((void *)this + 1) = (char *)this + 24;
  *((void *)this + 22) = (char *)this + 192;
  *((void *)this + 23) = 0x1000000000;
  *((void *)this + 40) = (char *)this + 320;
  *((void *)this + 41) = (char *)this + 320;
  *((void *)this + 42) = 0;
  *((_DWORD *)this + 86) = (unint64_t)((char *)a3 - (char *)a2) >> 3;
  sub_1CB935BDC((unsigned int *)this + 44, a2, a3);
  return this;
}

uint64_t llvm::opt::InputArgList::MakeIndex(uint64_t a1, const void *a2, size_t a3)
{
  if (a3 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  uint64_t v6 = *(unsigned int *)(a1 + 184);
  uint64_t v7 = a1 + 320;
  if (a3 >= 0x17)
  {
    uint64_t v9 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a3 | 7) != 0x17) {
      uint64_t v9 = a3 | 7;
    }
    uint64_t v10 = v9 + 1;
    p_dst = (long long *)operator new(v9 + 1);
    *((void *)&__dst + 1) = a3;
    unint64_t v17 = v10 | 0x8000000000000000;
    *(void *)&long long __dst = p_dst;
    goto LABEL_8;
  }
  HIBYTE(v17) = a3;
  p_dst = &__dst;
  if (a3) {
LABEL_8:
  }
    memmove(p_dst, a2, a3);
  *((unsigned char *)p_dst + a3) = 0;
  uint64_t v11 = (char *)operator new(0x28uLL);
  uint64_t v12 = v11 + 16;
  *((_OWORD *)v11 + 1) = __dst;
  *((void *)v11 + 4) = v17;
  uint64_t v13 = *(void *)(a1 + 320);
  *(void *)uint64_t v11 = v13;
  *((void *)v11 + 1) = v7;
  *(void *)(v13 + 8) = v11;
  *(void *)(a1 + 320) = v11;
  ++*(void *)(a1 + 336);
  if (v11[39] < 0) {
    uint64_t v12 = (void *)*v12;
  }
  unsigned int v14 = *(_DWORD *)(a1 + 184);
  if (v14 >= *(_DWORD *)(a1 + 188)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)(a1 + 176) + 8 * v14) = v12;
  ++*(_DWORD *)(a1 + 184);
  return v6;
}

uint64_t llvm::opt::InputArgList::MakeIndex(uint64_t a1, const void *a2, size_t a3, const void *a4, size_t a5)
{
  uint64_t Index = llvm::opt::InputArgList::MakeIndex(a1, a2, a3);
  llvm::opt::InputArgList::MakeIndex(a1, a4, a5);
  return Index;
}

uint64_t llvm::opt::InputArgList::MakeArgStringRef(uint64_t a1, const void *a2, size_t a3)
{
  return *(void *)(*(void *)(a1 + 176) + 8 * llvm::opt::InputArgList::MakeIndex(a1, a2, a3));
}

uint64_t sub_1CCC8F874(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 176) + 8 * a2);
}

double llvm::opt::DerivedArgList::DerivedArgList(llvm::opt::DerivedArgList *this, const llvm::opt::InputArgList *a2)
{
  *(void *)&double result = 0x1000000000;
  *((void *)this + 2) = 0x1000000000;
  *((void *)this + 19) = 0;
  *((void *)this + 20) = 0;
  *((_DWORD *)this + 42) = 0;
  *(void *)this = &unk_1F26346C8;
  *((void *)this + 1) = (char *)this + 24;
  *((void *)this + 22) = a2;
  *((void *)this + 23) = (char *)this + 200;
  *((void *)this + 24) = 0x1000000000;
  return result;
}

{
  double result;

  *(void *)&double result = 0x1000000000;
  *((void *)this + 2) = 0x1000000000;
  *((void *)this + 19) = 0;
  *((void *)this + 20) = 0;
  *((_DWORD *)this + 42) = 0;
  *(void *)this = &unk_1F26346C8;
  *((void *)this + 1) = (char *)this + 24;
  *((void *)this + 22) = a2;
  *((void *)this + 23) = (char *)this + 200;
  *((void *)this + 24) = 0x1000000000;
  return result;
}

uint64_t llvm::opt::DerivedArgList::MakeArgStringRef(uint64_t a1, void **a2, void **a3)
{
  uint64_t v3 = *(llvm::raw_ostream **)(a1 + 176);
  __int16 v6 = 261;
  v5[0] = a2;
  v5[1] = a3;
  return sub_1CCC8E7F0(v3, v5);
}

void sub_1CCC8F8F8()
{
}

void llvm::opt::DerivedArgList::MakePositionalArg(uint64_t *a1, uint64_t a2, void ****a3, uint64_t a4, const void *a5, size_t a6)
{
  llvm::opt::InputArgList::MakeIndex(a1[22], a5, a6);
  if (**a3) {
    uint64_t v8 = (void **)strlen((const char *)**a3);
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t v9 = (void **)a3[1];
  if (v9) {
    uint64_t v10 = (void **)strlen((const char *)a3[1]);
  }
  else {
    uint64_t v10 = 0;
  }
  v11[0] = **a3;
  v11[1] = v8;
  _OWORD v11[2] = v9;
  v11[3] = v10;
  __int16 v12 = 1285;
  sub_1CCC8E7F0((llvm::raw_ostream *)a1, v11);
  operator new();
}

void sub_1CCC8FB3C()
{
}

uint64_t sub_1CCC8FC18(uint64_t a1)
{
  return *(unsigned int *)(a1 + 344);
}

uint64_t sub_1CCC8FC20(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(*(void *)(a1 + 176) + 176) + 8 * a2);
}

uint64_t sub_1CCC8FC30(uint64_t result)
{
  uint64_t v1 = *(uint64_t **)result;
  uint64_t v2 = *(uint64_t **)(result + 8);
  if (*(uint64_t **)result != v2)
  {
    uint64_t v3 = result;
    do
    {
      double result = *v1;
      if (*v1)
      {
        uint64_t v4 = *(unsigned int *)(v3 + 16);
        if (v4)
        {
          double result = llvm::opt::Option::matches((void *)result, v4);
          if (result) {
            return result;
          }
          uint64_t v1 = *(uint64_t **)v3;
          uint64_t v2 = *(uint64_t **)(v3 + 8);
        }
      }
      *(void *)uint64_t v3 = ++v1;
    }
    while (v1 != v2);
  }
  return result;
}

uint64_t sub_1CCC8FC8C@<X0>(uint64_t a1@<X0>, _DWORD *a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  __int16 v12 = 0;
  uint64_t result = sub_1CC39AB68((uint64_t *)a1, a2, &v12);
  uint64_t v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CC39AC08(a1, (uint64_t)a2, a2, v12);
    uint64_t v9 = (_DWORD *)result;
    *(_DWORD *)uint64_t result = *a2;
    *(void *)(result + 4) = *a3;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a1 + 12 * *(unsigned int *)(a1 + 16);
  *(void *)a4 = v9;
  *(void *)(a4 + 8) = v11;
  *(unsigned char *)(a4 + 16) = v10;
  return result;
}

uint64_t sub_1CCC8FD24(uint64_t result)
{
  uint64_t v1 = *(void ***)result;
  uint64_t v2 = *(void ***)(result + 8);
  if (*(void ***)result != v2)
  {
    uint64_t v3 = result;
    do
    {
      uint64_t v4 = *v1;
      if (*v1)
      {
        for (uint64_t i = 16; i != 24; i += 4)
        {
          uint64_t v6 = *(unsigned int *)(v3 + i);
          if (!v6) {
            break;
          }
          uint64_t result = llvm::opt::Option::matches(v4, v6);
          if (result) {
            return result;
          }
        }
        uint64_t v1 = *(void ***)v3;
        uint64_t v2 = *(void ***)(v3 + 8);
      }
      *(void *)uint64_t v3 = ++v1;
    }
    while (v1 != v2);
  }
  return result;
}

uint64_t sub_1CCC8FD9C(uint64_t result)
{
  uint64_t v1 = *(void ***)result;
  uint64_t v2 = *(void ***)(result + 8);
  if (*(void ***)result != v2)
  {
    uint64_t v3 = result;
    do
    {
      uint64_t v4 = *v1;
      if (*v1)
      {
        for (uint64_t i = 16; i != 28; i += 4)
        {
          uint64_t v6 = *(unsigned int *)(v3 + i);
          if (!v6) {
            break;
          }
          uint64_t result = llvm::opt::Option::matches(v4, v6);
          if (result) {
            return result;
          }
        }
        uint64_t v1 = *(void ***)v3;
        uint64_t v2 = *(void ***)(v3 + 8);
      }
      *(void *)uint64_t v3 = ++v1;
    }
    while (v1 != v2);
  }
  return result;
}

void *llvm::opt::Option::Option(void *result, uint64_t a2, uint64_t a3)
{
  llvm::object *result = a2;
  result[1] = a3;
  return result;
}

{
  llvm::object *result = a2;
  result[1] = a3;
  return result;
}

uint64_t llvm::opt::Option::matches(void *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v2 = (uint64_t *)a1[1];
  if (*(_WORD *)(*a1 + 46))
  {
    uint64_t v4 = *v2;
    v10[0] = *v2 + ((unint64_t)(*(unsigned __int16 *)(*a1 + 46) - 1) << 6);
    v10[1] = v2;
    if (v4)
    {
      a2 = a2;
      uint64_t v8 = v10;
      return llvm::opt::Option::matches(v8, a2);
    }
  }
  if (*(_DWORD *)(v3 + 32) == a2) {
    return 1;
  }
  uint64_t v5 = *(unsigned __int16 *)(v3 + 44);
  if (v5)
  {
    uint64_t v7 = *v2;
    v9[0] = *v2 + ((unint64_t)(v5 - 1) << 6);
    v9[1] = v2;
    if (v7)
    {
      a2 = a2;
      uint64_t v8 = v9;
      return llvm::opt::Option::matches(v8, a2);
    }
  }
  return 0;
}

size_t llvm::opt::Option::acceptInternal@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, unsigned int *a4@<X4>, void *a5@<X8>)
{
  switch(*(unsigned char *)(*(void *)a1 + 36))
  {
    case 4:
      uint64_t v10 = *a4;
      goto LABEL_3;
    case 5:
      __break(1u);
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    case 6:
      uint64_t v13 = (const char *)(**(uint64_t (***)(uint64_t, void))a2)(a2, *a4);
      size_t result = strlen(v13);
      if (a3 != result) {
        break;
      }
      unsigned int v14 = *a4 + 2;
      goto LABEL_8;
    case 7:
      unsigned int v20 = (const char *)(**(uint64_t (***)(uint64_t, void))a2)(a2, *a4);
      size_t result = strlen(v20);
      if (a3 == result)
      {
        ++*a4;
        operator new();
      }
      break;
    case 8:
      operator new();
    case 9:
      (**(void (***)(uint64_t, void))a2)(a2, *a4);
      ++*a4;
      operator new();
    case 0xA:
      unint64_t v17 = (const char *)(**(uint64_t (***)(uint64_t, void))a2)(a2, *a4);
      size_t result = strlen(v17);
      if (a3 == result)
      {
        unsigned int v18 = *(unsigned __int8 *)(*(void *)a1 + 37) + *a4 + 1;
        *a4 = v18;
        size_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8))(a2);
        if (v18 <= result)
        {
          (**(void (***)(uint64_t, void))a2)(a2, *a4 - *(unsigned __int8 *)(*(void *)a1 + 37));
          operator new();
        }
      }
      break;
    case 0xB:
      long long v15 = (const char *)(**(uint64_t (***)(uint64_t, void))a2)(a2, *a4);
      size_t v16 = strlen(v15);
      uint64_t v10 = *a4;
      if (a3 != v16)
      {
LABEL_3:
        (**(void (***)(uint64_t, uint64_t))a2)(a2, v10);
        ++*a4;
        operator new();
      }
      unsigned int v14 = v10 + 2;
LABEL_8:
      *a4 = v14;
      size_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8))(a2);
      if (v14 <= result)
      {
        size_t result = (**(uint64_t (***)(uint64_t, void))a2)(a2, *a4 - 1);
        if (result)
        {
          (**(void (***)(uint64_t, void))a2)(a2, *a4 - 1);
          operator new();
        }
      }
      return result;
    case 0xC:
      unsigned int v19 = *a4 + 2;
      *a4 = v19;
      size_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8))(a2);
      if (v19 <= result)
      {
        size_t result = (**(uint64_t (***)(uint64_t, void))a2)(a2, *a4 - 1);
        if (result)
        {
          (**(void (***)(uint64_t, void))a2)(a2, *a4 - 2);
          (**(void (***)(uint64_t, void))a2)(a2, *a4 - 1);
          operator new();
        }
      }
      return result;
    default:
      uint64_t v11 = (const char *)(**(uint64_t (***)(uint64_t, void))a2)(a2, *a4);
      size_t result = strlen(v11);
      if (a3 == result)
      {
        ++*a4;
        operator new();
      }
      return result;
  }
  *a5 = 0;
  return result;
}

uint64_t **llvm::opt::Option::accept@<X0>(uint64_t *a1@<X0>, llvm::raw_ostream *a2@<X1>, uint64_t a3@<X3>, int a4@<W4>, unsigned int *a5@<X5>, void *a6@<X8>)
{
  if (a4 && *(unsigned char *)(*a1 + 36) == 3) {
    operator new();
  }
  size_t result = (uint64_t **)llvm::opt::Option::acceptInternal((uint64_t)a1, (uint64_t)a2, a3, a5, &v22);
  uint64_t v10 = v22;
  if (v22)
  {
    size_t result = (uint64_t **)sub_1CCC8EAFC(a1);
    if (*(_DWORD *)(*a1 + 32) != *((_DWORD *)result + 8))
    {
      uint64_t v11 = result;
      uint64_t v12 = **result;
      if (v12) {
        size_t v13 = strlen((const char *)**result);
      }
      else {
        size_t v13 = 0;
      }
      __int16 v20 = 261;
      v19[0] = v12;
      v19[1] = v13;
      uint64_t v14 = (uint64_t)v11[1];
      if (v14) {
        size_t v15 = strlen((const char *)v11[1]);
      }
      else {
        size_t v15 = 0;
      }
      __int16 v18 = 261;
      v17[0] = v14;
      v17[1] = v15;
      sub_1CB8F1E58(v19, v17, (uint64_t)v21);
      size_t v16 = (const char *)sub_1CCC8E7F0(a2, v21);
      if (v16) {
        strlen(v16);
      }
      operator new();
    }
  }
  *a6 = v10;
  return result;
}

_DWORD *llvm::opt::OptSpecifier::OptSpecifier(_DWORD *result, uint64_t a2)
{
  llvm::object *result = *(_DWORD *)(*(void *)a2 + 32);
  return result;
}

{
  llvm::object *result = *(_DWORD *)(*(void *)a2 + 32);
  return result;
}

uint64_t *llvm::opt::OptTable::OptTable(uint64_t *a1, const void *a2, unint64_t a3, char a4)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_1CCC91C70(a1, a2, (uint64_t)a2 + 64 * a3, a3);
  *((unsigned char *)a1 + 24) = a4;
  *((unsigned char *)a1 + 25) = 0;
  a1[7] = 0;
  a1[4] = 0;
  a1[5] = 0;
  *((_DWORD *)a1 + 12) = 0;
  a1[8] = 0;
  a1[9] = 0x800000000;
  a1[11] = 0;
  uint64_t v6 = *a1;
  unint64_t v7 = a1[1] - *a1;
  unint64_t v8 = v7 >> 6;
  a1[12] = 0;
  a1[13] = 0;
  if ((v7 >> 6))
  {
    uint64_t v9 = 0;
    uint64_t v10 = (v7 >> 6);
    uint64_t v11 = v6 + 32;
    do
    {
      int v12 = *(unsigned __int8 *)(v11 + 4);
      if (*(unsigned char *)(v11 + 4))
      {
        if (v12 == 2)
        {
          *((_DWORD *)a1 + 11) = *(_DWORD *)v11;
        }
        else
        {
          if (v12 != 1)
          {
            *((_DWORD *)a1 + 12) = v9;
            goto LABEL_11;
          }
          *((_DWORD *)a1 + 10) = *(_DWORD *)v11;
        }
      }
      ++v9;
      v11 += 64;
    }
    while (v10 != v9);
  }
  LODWORD(v9) = 0;
LABEL_11:
  if (v9 == v8)
  {
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t i = 0;
  }
  else
  {
    do
    {
      size_t v13 = *(char ***)(*a1 + ((unint64_t)v9 << 6));
      if (v13)
      {
        uint64_t v14 = *v13;
        if (*v13)
        {
          size_t v15 = v13 + 1;
          do
          {
            size_t v16 = strlen(v14);
            sub_1CC0D7F54((llvm::StringMapImpl *)(a1 + 7), (unsigned __int8 *)v14, v16);
            unint64_t v17 = *v15++;
            uint64_t v14 = v17;
          }
          while (v17);
        }
      }
      LODWORD(v9) = v9 + 1;
    }
    while (v9 != v8);
    uint64_t v18 = a1[7];
    uint64_t v19 = *((unsigned int *)a1 + 16);
    if (v19)
    {
      for (uint64_t i = (void *)a1[7]; !*i || *i == -8; ++i)
        ;
    }
    else
    {
      uint64_t v19 = 0;
      uint64_t i = (void *)a1[7];
    }
  }
  uint64_t v22 = (void *)(v18 + 8 * v19);
  if (i != v22)
  {
    uint64_t v23 = (void *)*i;
    do
    {
      uint64_t v26 = *v23;
      uint64_t v24 = (std::string::value_type *)(v23 + 1);
      for (uint64_t j = v26; j; --j)
      {
        std::string::value_type v27 = *v24;
        char v28 = *((unsigned char *)a1 + 111);
        BOOL v29 = v28 < 0;
        if (v28 >= 0) {
          unsigned int v30 = (char *)(a1 + 11);
        }
        else {
          unsigned int v30 = (char *)a1[11];
        }
        size_t v31 = v28 & 0x7F;
        if (v29) {
          size_t v32 = a1[12];
        }
        else {
          size_t v32 = v31;
        }
        unint64_t v33 = (char *)memchr(v30, *v24, v32);
        if (v33) {
          int v34 = v33;
        }
        else {
          int v34 = &v30[v32];
        }
        if (v34 - v30 == v32) {
          std::string::push_back((std::string *)(a1 + 11), v27);
        }
        ++v24;
      }
      do
      {
        uint64_t v35 = (void *)i[1];
        ++i;
        uint64_t v23 = v35;
        if (v35) {
          BOOL v36 = v23 + 1 == 0;
        }
        else {
          BOOL v36 = 1;
        }
      }
      while (v36);
    }
    while (i != v22);
  }
  return a1;
}

void llvm::opt::OptTable::~OptTable(void **this)
{
  if (*((char *)this + 111) < 0) {
    operator delete(this[11]);
  }
  sub_1CC0D7CD8((uint64_t)(this + 7));
  uint64_t v2 = *this;
  if (*this)
  {
    this[1] = v2;
    operator delete(v2);
  }
}

unint64_t llvm::opt::OptTable::getOption(void *a1, int a2)
{
  if (a2) {
    return *a1 + ((unint64_t)(a2 - 1) << 6);
  }
  else {
    return 0;
  }
}

uint64_t sub_1CCC90F58(uint64_t result, char *__s, char *a3, size_t a4)
{
  if (result)
  {
    unint64_t v7 = (const char **)result;
    if (__s) {
      size_t v8 = strlen(__s);
    }
    else {
      size_t v8 = 0;
    }
    uint64_t v9 = *v7;
    if (*v7)
    {
      if (a4 >= a4 - v8) {
        size_t v10 = a4 - v8;
      }
      else {
        size_t v10 = a4;
      }
      uint64_t v11 = v7 + 1;
      while (a4 < v8 || v8 && memcmp(&a3[a4 - v8], __s, v8) || v10 != strlen(v9) || v10 && memcmp(a3, v9, v10))
      {
        int v12 = *v11++;
        uint64_t v9 = v12;
        if (!v12) {
          return 0;
        }
      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_1CCC91038(unint64_t *a1, uint64_t a2)
{
  unint64_t v3 = a1[1];
  if (v3 >= a1[2])
  {
    uint64_t result = sub_1CBF64E70(a1, a2);
  }
  else
  {
    if (*(char *)(a2 + 23) < 0)
    {
      sub_1CB8BDF7C(a1[1], *(const void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      long long v4 = *(_OWORD *)a2;
      *(void *)(v3 + 16) = *(void *)(a2 + 16);
      *(_OWORD *)unint64_t v3 = v4;
    }
    uint64_t result = v3 + 24;
  }
  a1[1] = result;
  return result;
}

BOOL llvm::opt::OptTable::addValues(llvm::opt::OptTable *this, char *__s, const char *a3)
{
  unint64_t v3 = *((unsigned int *)this + 12);
  unint64_t v4 = (uint64_t)(*((void *)this + 1) - *(void *)this) >> 6;
  if (v4 <= v3)
  {
    return 0;
  }
  else
  {
    unint64_t v7 = *(void *)this + (v3 << 6);
    BOOL v8 = 1;
    while (1)
    {
      size_t v9 = __s ? strlen(__s) : 0;
      if (sub_1CCC90F58(*(void *)v7, *(char **)(v7 + 8), __s, v9)) {
        break;
      }
      BOOL v8 = ++v3 < v4;
      v7 += 64;
      if (v4 == v3) {
        return 0;
      }
    }
    *(void *)(v7 + 56) = a3;
  }
  return v8;
}

uint64_t sub_1CCC91148(size_t **a1, int a2, unsigned char *__s1, size_t a4)
{
  if (a4 != 1 || *__s1 != 45)
  {
    uint64_t i = a1;
    if (a2)
    {
      for (uint64_t i = a1; !*i || *i + 1 == 0; ++i)
        ;
    }
    BOOL v8 = &a1[a2];
    if (i != v8)
    {
      size_t v9 = *i;
      do
      {
        size_t v12 = *v9;
        size_t v10 = v9 + 1;
        size_t v11 = v12;
        if (a4 >= v12)
        {
          if (!v11) {
            return 0;
          }
          uint64_t result = memcmp(__s1, v10, v11);
          if (!result) {
            return result;
          }
        }
        do
        {
          uint64_t v14 = i[1];
          ++i;
          size_t v9 = v14;
          if (v14) {
            BOOL v15 = v9 + 1 == 0;
          }
          else {
            BOOL v15 = 1;
          }
        }
        while (v15);
      }
      while (i != v8);
    }
  }
  return 1;
}

uint64_t sub_1CCC911FC(uint64_t a1, char *a2, size_t a3, int a4)
{
  unint64_t v4 = **(const char ***)a1;
  if (!v4) {
    return 0;
  }
  for (uint64_t i = (const char **)(*(void *)a1 + 8); ; ++i)
  {
    size_t v10 = strlen(v4);
    if (a3 < v10) {
      goto LABEL_14;
    }
    size_t v11 = v10;
    if (v10)
    {
      if (memcmp(a2, v4, v10)) {
        goto LABEL_14;
      }
    }
    size_t v12 = a3 >= v11 ? v11 : a3;
    size_t v13 = &a2[v12];
    size_t v14 = a3 - v12;
    v21[0] = (unsigned __int8 *)&a2[v12];
    v21[1] = (unsigned __int8 *)(a3 - v12);
    BOOL v15 = *(char **)(a1 + 8);
    if (a4) {
      break;
    }
    if (!v15) {
      goto LABEL_22;
    }
    size_t v16 = strlen(*(const char **)(a1 + 8));
    if (v14 >= v16 && (!v16 || !memcmp(v13, v15, v16)))
    {
LABEL_20:
      int v19 = strlen(v15);
      return (v19 + v11);
    }
LABEL_14:
    unint64_t v17 = *i;
    unint64_t v4 = v17;
    if (!v17) {
      return 0;
    }
  }
  if (v15)
  {
    size_t v18 = strlen(*(const char **)(a1 + 8));
    if (llvm::StringRef::startswith_insensitive(v21, (unsigned __int8 *)v15, v18)) {
      goto LABEL_20;
    }
    goto LABEL_14;
  }
  if (!llvm::StringRef::startswith_insensitive(v21, 0, 0)) {
    goto LABEL_14;
  }
LABEL_22:
  int v19 = 0;
  return (v19 + v11);
}

void sub_1CCC91334()
{
}

uint64_t **llvm::opt::OptTable::ParseOneArg@<X0>(llvm::opt::OptTable *this@<X0>, const llvm::opt::ArgList *a2@<X1>, unsigned int *a3@<X2>, int a4@<W3>, int a5@<W4>, void *a6@<X8>)
{
  unsigned int v10 = *a3;
  size_t v11 = (const char *)(**(uint64_t (***)(const llvm::opt::ArgList *, void))a2)(a2, *a3);
  size_t v12 = (char *)v11;
  unint64_t v48 = v11;
  if (v11) {
    size_t v13 = strlen(v11);
  }
  else {
    size_t v13 = 0;
  }
  if (sub_1CCC91148(*((size_t ***)this + 7), *((_DWORD *)this + 16), v12, v13)) {
    goto LABEL_44;
  }
  unsigned int v42 = v10;
  uint64_t v14 = *((unsigned int *)this + 12);
  uint64_t v15 = *((void *)this + 1);
  uint64_t v16 = *(void *)this + (v14 << 6);
  uint64_t v17 = (v15 - *(void *)this) >> 6;
  char v46 = v12;
  long long v43 = a6;
  if (v12) {
    size_t v18 = strlen(v12);
  }
  else {
    size_t v18 = 0;
  }
  uint64_t v47 = (llvm::opt::OptTable *)v18;
  char v19 = *((unsigned char *)this + 111);
  if (v19 >= 0) {
    __int16 v20 = (unsigned __int8 *)this + 88;
  }
  else {
    __int16 v20 = (unsigned __int8 *)*((void *)this + 11);
  }
  if (v19 >= 0) {
    uint64_t v21 = v19 & 0x7F;
  }
  else {
    uint64_t v21 = *((void *)this + 12);
  }
  unint64_t first_not_of = llvm::StringRef::find_first_not_of(&v46, v20, v21, 0);
  if (first_not_of >= v18) {
    size_t v23 = v18;
  }
  else {
    size_t v23 = first_not_of;
  }
  if (v17 != v14)
  {
    uint64_t v24 = &v12[v23];
    unint64_t v25 = (v15 - v16) >> 6;
    do
    {
      unint64_t v26 = v16 + (v25 >> 1 << 6);
      BOOL v27 = sub_1CCC91CF4(*(char **)(v26 + 8), v24);
      if (v27) {
        v25 += ~(v25 >> 1);
      }
      else {
        v25 >>= 1;
      }
      if (v27) {
        uint64_t v16 = v26 + 64;
      }
    }
    while (v25);
  }
  if (v16 == v15)
  {
LABEL_43:
    if (*v12 != 47)
    {
      int v40 = *((_DWORD *)this + 11);
      if (v40)
      {
        unint64_t v41 = *(void *)this + ((unint64_t)(v40 - 1) << 6);
      }
      else
      {
        this = 0;
        unint64_t v41 = 0;
      }
      char v46 = (char *)v41;
      uint64_t v47 = this;
      ++*a3;
LABEL_47:
      sub_1CCC91334();
    }
LABEL_44:
    int v38 = *((_DWORD *)this + 10);
    if (v38)
    {
      unint64_t v39 = *(void *)this + ((unint64_t)(v38 - 1) << 6);
    }
    else
    {
      this = 0;
      unint64_t v39 = 0;
    }
    char v46 = (char *)v39;
    uint64_t v47 = this;
    ++*a3;
    goto LABEL_47;
  }
  while (1)
  {
    int v28 = *((unsigned __int8 *)this + 24);
    v16 += 64;
    while (1)
    {
      size_t v29 = v12 ? strlen(v12) : 0;
      unsigned int v30 = sub_1CCC911FC(v16 - 64, v12, v29, v28 != 0);
      if (v30) {
        break;
      }
      BOOL v32 = v16 == v15;
      v16 += 64;
      if (v32) {
        goto LABEL_43;
      }
    }
    int v31 = *(_DWORD *)(v16 - 24);
    BOOL v32 = (v31 & a4) != 0 || a4 == 0;
    char v46 = (char *)(v16 - 64);
    uint64_t v47 = this;
    int v33 = v31 & a5;
    if (v32 && v33 == 0)
    {
      unsigned int v35 = v30;
      (**(void (***)(const llvm::opt::ArgList *, void))a2)(a2, *a3);
      uint64_t result = llvm::opt::Option::accept((uint64_t *)&v46, a2, v35, 0, a3, v43);
      if (*v43) {
        return result;
      }
      unsigned int v37 = *a3;
      *long long v43 = 0;
      if (v42 != v37) {
        return result;
      }
    }
    if (v16 == v15) {
      goto LABEL_43;
    }
  }
}

llvm::opt::Arg *llvm::opt::OptTable::ParseArgs@<X0>(llvm::opt::OptTable *a1@<X0>, const char **a2@<X1>, uint64_t a3@<X2>, unsigned int *a4@<X3>, _DWORD *a5@<X4>, int a6@<W5>, int a7@<W6>, llvm::opt::InputArgList *a8@<X8>)
{
  unsigned int v12 = a3;
  uint64_t result = llvm::opt::InputArgList::InputArgList(a8, a2, &a2[a3]);
  *a5 = 0;
  *a4 = 0;
  unsigned int v21 = 0;
  if (v12)
  {
    unsigned int v16 = 0;
    do
    {
      uint64_t v17 = *(unsigned char **)(*((void *)a8 + 22) + 8 * v16);
      if (v17)
      {
        if (*v17)
        {
          if (*((unsigned char *)a1 + 25)) {
            uint64_t result = (llvm::opt::Arg *)llvm::opt::OptTable::parseOneArgGrouped(a1, a8, &v21, &v20);
          }
          else {
            uint64_t result = (llvm::opt::Arg *)llvm::opt::OptTable::ParseOneArg(a1, a8, &v21, a6, a7, &v20);
          }
          size_t v18 = v20;
          if (v20)
          {
            __int16 v20 = 0;
            llvm::opt::ArgList::append(a8, v18);
            uint64_t result = v20;
            __int16 v20 = 0;
            if (result)
            {
              llvm::opt::Arg::~Arg(result);
              uint64_t result = (llvm::opt::Arg *)MEMORY[0x1D25D9CE0]();
            }
            int v19 = 0;
          }
          else
          {
            *a4 = v16;
            *a5 = v21 + ~v16;
            int v19 = 3;
          }
          unsigned int v16 = v21;
        }
        else
        {
          unsigned int v21 = ++v16;
          int v19 = 2;
        }
        if (v19 == 3) {
          return result;
        }
      }
      else
      {
        unsigned int v21 = ++v16;
      }
    }
    while (v16 < v12);
  }
  return result;
}

void llvm::opt::OptTable::parseArgs(const char **a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, int a4@<W3>, uint64_t **a5@<X4>, void (*a6)(uint64_t, void **, std::string::size_type)@<X5>, uint64_t a7@<X6>, llvm::opt::InputArgList *a8@<X8>)
{
  char v57 = (const char **)v59;
  uint64_t v58 = 0;
  llvm::cl::expandResponseFiles(a2, a3, a1[4], a5, (unsigned int *)&v57);
  uint64_t v56 = 0;
  llvm::opt::OptTable::ParseArgs((llvm::opt::OptTable *)a1, v57, v58, (unsigned int *)&v56 + 1, &v56, 0, 0, a8);
  if (v56)
  {
    if (**(unsigned char **)(*((void *)a8 + 22) + 8 * HIDWORD(v56)))
    {
      *(void *)&long long v49 = *(void *)(*((void *)a8 + 22) + 8 * HIDWORD(v56));
      __int16 v50 = ": missing argument";
      __int16 v13 = 771;
    }
    else
    {
      *(void *)&long long v49 = ": missing argument";
      __int16 v13 = 259;
    }
    __int16 v52 = v13;
    llvm::Twine::str((llvm::Twine *)&v49, &v53);
    uint64_t v14 = v55 >= 0 ? (void **)&v53 : v53;
    std::string::size_type v15 = v55 >= 0 ? HIBYTE(v55) & 0x7F : v54;
    a6(a7, v14, v15);
    if (SHIBYTE(v55) < 0) {
      operator delete(v53);
    }
  }
  uint64_t v53 = 0;
  std::string::size_type v54 = 0;
  uint64_t v55 = 0;
  sub_1CCC8EB50((uint64_t)a8, a4, (uint64_t)&v49);
  long long v47 = v49;
  uint64_t v16 = v51;
  unint64_t v48 = v50;
  uint64_t v17 = (llvm::opt::Arg **)v49;
  if ((void)v49 != v51)
  {
    while (1)
    {
      size_t v18 = *v17;
      llvm::opt::Arg::getAsString(*v17, a8, &v46);
      if ((v46.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v19 = &v46;
      }
      else {
        int v19 = (std::string *)v46.__r_.__value_.__r.__words[0];
      }
      if ((v46.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        size_t size = *((unsigned char *)&v46.__r_.__value_.__s + 23) & 0x7F;
      }
      else {
        size_t size = v46.__r_.__value_.__l.__size_;
      }
      if (llvm::opt::OptTable::findNearest((uint64_t)a1, (std::string::value_type *)v19, size, (uint64_t)&v53, 0, 0, 4u) < 2)
      {
        llvm::opt::Arg::getAsString(v18, a8, &v40);
        int v28 = std::string::insert(&v40, 0, "unknown argument '");
        std::string::size_type v29 = v28->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v41.__r_.__value_.__l.__data_ = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
        v41.__r_.__value_.__r.__words[2] = v29;
        v28->__r_.__value_.__l.__size_ = 0;
        v28->__r_.__value_.__r.__words[2] = 0;
        v28->__r_.__value_.__r.__words[0] = 0;
        unsigned int v30 = std::string::append(&v41, "', did you mean '");
        std::string::size_type v31 = v30->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v42.__r_.__value_.__l.__data_ = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
        v42.__r_.__value_.__r.__words[2] = v31;
        v30->__r_.__value_.__l.__size_ = 0;
        v30->__r_.__value_.__r.__words[2] = 0;
        v30->__r_.__value_.__r.__words[0] = 0;
        if (v55 >= 0) {
          BOOL v32 = (const std::string::value_type *)&v53;
        }
        else {
          BOOL v32 = (const std::string::value_type *)v53;
        }
        if (v55 >= 0) {
          std::string::size_type v33 = HIBYTE(v55) & 0x7F;
        }
        else {
          std::string::size_type v33 = v54;
        }
        int v34 = std::string::append(&v42, v32, v33);
        std::string::size_type v35 = v34->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v43.__r_.__value_.__l.__data_ = *(_OWORD *)&v34->__r_.__value_.__l.__data_;
        v43.__r_.__value_.__r.__words[2] = v35;
        v34->__r_.__value_.__l.__size_ = 0;
        v34->__r_.__value_.__r.__words[2] = 0;
        v34->__r_.__value_.__r.__words[0] = 0;
        BOOL v36 = std::string::append(&v43, "'?");
        std::string::size_type v37 = v36->__r_.__value_.__r.__words[2];
        *(_OWORD *)std::string __p = *(_OWORD *)&v36->__r_.__value_.__l.__data_;
        uint64_t v45 = v37;
        v36->__r_.__value_.__l.__size_ = 0;
        v36->__r_.__value_.__r.__words[2] = 0;
        v36->__r_.__value_.__r.__words[0] = 0;
        if (v45 >= 0) {
          int v38 = __p;
        }
        else {
          int v38 = (void **)__p[0];
        }
        if (v45 >= 0) {
          unint64_t v39 = (void *)(HIBYTE(v45) & 0x7F);
        }
        else {
          unint64_t v39 = __p[1];
        }
        a6(a7, v38, (std::string::size_type)v39);
        if (SHIBYTE(v45) < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v43.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v42.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v41.__r_.__value_.__l.__data_);
        }
        if ((SHIBYTE(v40.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_56;
        }
        BOOL v27 = (void *)v40.__r_.__value_.__r.__words[0];
      }
      else
      {
        llvm::opt::Arg::getAsString(v18, a8, &v42);
        unsigned int v21 = std::string::insert(&v42, 0, "unknown argument '");
        std::string::size_type v22 = v21->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v43.__r_.__value_.__l.__data_ = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
        v43.__r_.__value_.__r.__words[2] = v22;
        v21->__r_.__value_.__l.__size_ = 0;
        v21->__r_.__value_.__r.__words[2] = 0;
        v21->__r_.__value_.__r.__words[0] = 0;
        size_t v23 = std::string::append(&v43, "'");
        std::string::size_type v24 = v23->__r_.__value_.__r.__words[2];
        *(_OWORD *)std::string __p = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
        uint64_t v45 = v24;
        v23->__r_.__value_.__l.__size_ = 0;
        v23->__r_.__value_.__r.__words[2] = 0;
        v23->__r_.__value_.__r.__words[0] = 0;
        if (v45 >= 0) {
          unint64_t v25 = __p;
        }
        else {
          unint64_t v25 = (void **)__p[0];
        }
        if (v45 >= 0) {
          unint64_t v26 = (void *)(HIBYTE(v45) & 0x7F);
        }
        else {
          unint64_t v26 = __p[1];
        }
        a6(a7, v25, (std::string::size_type)v26);
        if (SHIBYTE(v45) < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v43.__r_.__value_.__l.__data_);
        }
        if ((SHIBYTE(v42.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_56;
        }
        BOOL v27 = (void *)v42.__r_.__value_.__r.__words[0];
      }
      operator delete(v27);
LABEL_56:
      if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v46.__r_.__value_.__l.__data_);
      }
      *(void *)&long long v47 = v47 + 8;
      sub_1CCC8FC30((uint64_t)&v47);
      uint64_t v17 = (llvm::opt::Arg **)v47;
      if ((void)v47 == v16)
      {
        if (SHIBYTE(v55) < 0) {
          operator delete(v53);
        }
        break;
      }
    }
  }
  if (v57 != (const char **)v59) {
    free(v57);
  }
}

void *sub_1CCC91C70(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >> 58) {
      abort();
    }
    unint64_t v7 = result;
    uint64_t result = operator new(a4 << 6);
    BOOL v8 = result;
    *unint64_t v7 = result;
    v7[1] = result;
    v7[2] = &result[8 * a4];
    size_t v9 = a3 - (void)a2;
    if (v9) {
      uint64_t result = memcpy(result, a2, v9);
    }
    v7[1] = (char *)v8 + v9;
  }
  return result;
}

BOOL sub_1CCC91CF4(char *a1, char *a2)
{
  __darwin_ct_rune_t v4 = __tolower(*a1);
  __darwin_ct_rune_t v5 = __tolower(*a2);
  __darwin_ct_rune_t v6 = v4 << 24;
  int v7 = (char)v4;
  if ((char)v4 == (char)v5)
  {
    BOOL v8 = a2 + 1;
    size_t v9 = a1 + 1;
    while (v6)
    {
      __darwin_ct_rune_t v10 = *v9++;
      __darwin_ct_rune_t v11 = __tolower(v10);
      __darwin_ct_rune_t v12 = *v8++;
      __darwin_ct_rune_t v5 = __tolower(v12);
      __darwin_ct_rune_t v6 = v11 << 24;
      int v7 = (char)v11;
      if ((char)v11 != (char)v5) {
        goto LABEL_5;
      }
    }
    return 0;
  }
LABEL_5:
  if (!v6) {
    return 0;
  }
  return !(v5 << 24) || v7 < (char)v5;
}

void sub_1CCC91D94(char *a1)
{
  if (a1)
  {
    sub_1CCC91D94(*(void *)a1);
    sub_1CCC91D94(*((void *)a1 + 1));
    uint64_t v2 = *((void *)a1 + 7);
    if (v2)
    {
      uint64_t v3 = *((void *)a1 + 8);
      __darwin_ct_rune_t v4 = (void *)*((void *)a1 + 7);
      if (v3 != v2)
      {
        do
        {
          if (*(char *)(v3 - 17) < 0) {
            operator delete(*(void **)(v3 - 40));
          }
          v3 -= 40;
        }
        while (v3 != v2);
        __darwin_ct_rune_t v4 = (void *)*((void *)a1 + 7);
      }
      *((void *)a1 + 8) = v2;
      operator delete(v4);
    }
    if (a1[55] < 0) {
      operator delete(*((void **)a1 + 4));
    }
    operator delete(a1);
  }
}

char *sub_1CCC91E38()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::AlwaysInlinerPass]";
  v10[1] = 73;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x49) {
    uint64_t v1 = 73;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_31[v1];
  unint64_t v3 = 73 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

char *sub_1CCC91EF4()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::GlobalDCEPass]";
  v10[1] = 69;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x45) {
    uint64_t v1 = 69;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_50[v1];
  unint64_t v3 = 69 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

char *sub_1CCC91FB0()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::GlobalOptPass]";
  v10[1] = 69;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x45) {
    uint64_t v1 = 69;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_51[v1];
  unint64_t v3 = 69 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

char *sub_1CCC9206C()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::InternalizePass]";
  v10[1] = 71;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x47) {
    uint64_t v1 = 71;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_60[v1];
  unint64_t v3 = 71 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

char *sub_1CCC92128()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::PostOrderFunctionAttrsPass]";
  v10[1] = 82;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x52) {
    uint64_t v1 = 82;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_111[v1];
  unint64_t v3 = 82 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

char *sub_1CCC921E4()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::ADCEPass]";
  v10[1] = 64;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x40) {
    uint64_t v1 = 64;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_143[v1];
  unint64_t v3 = 64 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

char *sub_1CCC922A0()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::AlignmentFromAssumptionsPass]";
  v10[1] = 84;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x54) {
    uint64_t v1 = 84;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_148[v1];
  unint64_t v3 = 84 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

char *sub_1CCC9235C()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::AnnotationRemarksPass]";
  v10[1] = 77;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x4D) {
    uint64_t v1 = 77;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_149[v1];
  unint64_t v3 = 77 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

char *sub_1CCC92418()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::BDCEPass]";
  v10[1] = 64;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x40) {
    uint64_t v1 = 64;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_150[v1];
  unint64_t v3 = 64 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

char *sub_1CCC924D4()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::CorrelatedValuePropagationPass]";
  v10[1] = 86;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x56) {
    uint64_t v1 = 86;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_159[v1];
  unint64_t v3 = 86 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

char *sub_1CCC92590()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::DSEPass]";
  v10[1] = 63;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x3F) {
    uint64_t v1 = 63;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_163[v1];
  unint64_t v3 = v1 ^ 0x3F;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

char *sub_1CCC9264C()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::InstCombinePass]";
  v10[1] = 71;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x47) {
    uint64_t v1 = 71;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_175[v1];
  unint64_t v3 = 71 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

char *sub_1CCC92708()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::InstSimplifyPass]";
  v10[1] = 72;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x48) {
    uint64_t v1 = 72;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_177[v1];
  unint64_t v3 = 72 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

char *sub_1CCC927C4()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::LowerExpectIntrinsicPass]";
  v10[1] = 80;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x50) {
    uint64_t v1 = 80;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_184[v1];
  unint64_t v3 = 80 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

char *sub_1CCC92880()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::LowerConstantIntrinsicsPass]";
  v10[1] = 83;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x53) {
    uint64_t v1 = 83;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_186[v1];
  unint64_t v3 = 83 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

char *sub_1CCC9293C()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::LoopSimplifyPass]";
  v10[1] = 72;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x48) {
    uint64_t v1 = 72;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_190[v1];
  unint64_t v3 = 72 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

char *sub_1CCC929F8()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::LoopSinkPass]";
  v10[1] = 68;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x44) {
    uint64_t v1 = 68;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_191[v1];
  unint64_t v3 = 68 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

char *sub_1CCC92AB4()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::PromotePass]";
  v10[1] = 67;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x43) {
    uint64_t v1 = 67;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_194[v1];
  unint64_t v3 = 67 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

char *sub_1CCC92B70()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::MemCpyOptPass]";
  v10[1] = 69;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x45) {
    uint64_t v1 = 69;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_195[v1];
  unint64_t v3 = 69 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

char *sub_1CCC92C2C()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::LCSSAPass]";
  v10[1] = 65;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x41) {
    uint64_t v1 = 65;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_202[v1];
  unint64_t v3 = 65 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

char *sub_1CCC92CE8()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::LoopLoadEliminationPass]";
  v10[1] = 79;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x4F) {
    uint64_t v1 = 79;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_204[v1];
  unint64_t v3 = 79 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

char *sub_1CCC92DA4()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::ReassociatePass]";
  v10[1] = 71;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x47) {
    uint64_t v1 = 71;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_240[v1];
  unint64_t v3 = 71 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

char *sub_1CCC92E60()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::SCCPPass]";
  v10[1] = 64;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x40) {
    uint64_t v1 = 64;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_246[v1];
  unint64_t v3 = 64 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

char *sub_1CCC92F1C()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::SpeculativeExecutionPass]";
  v10[1] = 80;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x50) {
    uint64_t v1 = 80;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_250[v1];
  unint64_t v3 = 80 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

char *sub_1CCC92FD8()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::SROAPass]";
  v10[1] = 64;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x40) {
    uint64_t v1 = 64;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_251[v1];
  unint64_t v3 = 64 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

char *sub_1CCC93094()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::TailCallElimPass]";
  v10[1] = 72;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x48) {
    uint64_t v1 = 72;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_254[v1];
  unint64_t v3 = 72 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

char *sub_1CCC93150()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::LoopInstSimplifyPass]";
  v10[1] = 76;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x4C) {
    uint64_t v1 = 76;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_278[v1];
  unint64_t v3 = 76 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

char *sub_1CCC9320C()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::LoopRotatePass]";
  v10[1] = 70;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x46) {
    uint64_t v1 = 70;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_279[v1];
  unint64_t v3 = 70 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

char *sub_1CCC932C8()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::LoopDeletionPass]";
  v10[1] = 72;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x48) {
    uint64_t v1 = 72;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_281[v1];
  unint64_t v3 = 72 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

char *sub_1CCC93384()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::LoopSimplifyCFGPass]";
  v10[1] = 75;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x4B) {
    uint64_t v1 = 75;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_282[v1];
  unint64_t v3 = 75 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

char *sub_1CCC93440()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::IndVarSimplifyPass]";
  v10[1] = 74;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x4A) {
    uint64_t v1 = 74;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_284[v1];
  unint64_t v3 = 74 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

void *llvm::PassBuilder::registerFunctionAnalyses(uint64_t a1, _DWORD *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  v9[0] = &llvm::AAManager::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::AAManager::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::AssumptionAnalysis::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::BlockFrequencyAnalysis::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::BranchProbabilityAnalysis::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::CycleAnalysis::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::DominatorTreeAnalysis::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::PostDominatorTreeAnalysis::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::DemandedBitsAnalysis::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::DominanceFrontierAnalysis::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::FunctionPropertiesAnalysis::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::LoopAnalysis::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::LazyValueAnalysis::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::DependenceAnalysis::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::InlineSizeEstimatorAnalysis::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::MemoryDependenceAnalysis::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::MemorySSAAnalysis::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::PhiValuesAnalysis::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::RegionInfoAnalysis::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &unk_1EA61DEF8;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::OptimizationRemarkEmitterAnalysis::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::ScalarEvolutionAnalysis::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::ShouldNotRunFunctionPassesAnalysis::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::ShouldRunExtraVectorPasses::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::StackSafetyAnalysis::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::TargetLibraryAnalysis::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::TargetIRAnalysis::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::VerifierAnalysis::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::PassInstrumentationAnalysis::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::DivergenceAnalysis::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::GPUFunctionAnalysis::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::BasicAA::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::CFLAndersAA::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::CFLSteensAA::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::objcarc::ObjCARCAA::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::SCEVAA::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::ScopedNoAliasAA::Key;
  if (!sub_1CC6D91C0(a2, v9)[1]) {
    operator new();
  }
  v9[0] = &llvm::TypeBasedAA::Key;
  uint64_t result = sub_1CC6D91C0(a2, v9);
  if (!result[1]) {
    operator new();
  }
  uint64_t v5 = *(unsigned int *)(a1 + 1592);
  if (v5)
  {
    uint64_t v6 = *(void *)(a1 + 1584);
    uint64_t v7 = 32 * v5;
    BOOL v8 = (void *)(v6 + 24);
    do
    {
      if (!*v8) {
        sub_1CB920400();
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, _DWORD *))(*(void *)*v8 + 48))(*v8, a2);
      v8 += 4;
      v7 -= 32;
    }
    while (v7);
  }
  return result;
}

void sub_1CCC94C2C(uint64_t *a1, uint64_t a2)
{
  unint64_t v4 = a1[2];
  unint64_t v5 = a1[1];
  if (v5 >= v4)
  {
    unint64_t v7 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v5 - *a1) >> 3);
    unint64_t v8 = v7 + 1;
    if (v7 + 1 > 0x666666666666666) {
      abort();
    }
    unint64_t v9 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v4 - *a1) >> 3);
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x333333333333333) {
      unint64_t v8 = 0x666666666666666;
    }
    unsigned int v21 = a1 + 2;
    if (v8 > 0x666666666666666) {
      sub_1CB833614();
    }
    uint64_t v10 = 5 * v8;
    __darwin_ct_rune_t v11 = (char *)operator new(40 * v8);
    __darwin_ct_rune_t v12 = &v11[40 * v7];
    std::string __p = v11;
    size_t v18 = v12;
    long long v13 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)__darwin_ct_rune_t v12 = *(_OWORD *)a2;
    *((_OWORD *)v12 + 1) = v13;
    *((void *)v12 + 4) = *(void *)(a2 + 32);
    *(void *)(a2 + 16) = 0;
    *(void *)(a2 + 24) = 0;
    *(void *)(a2 + 32) = 0;
    int v19 = v12 + 40;
    __int16 v20 = &v11[8 * v10];
    sub_1CD4AE5F0(a1, &__p);
    uint64_t v6 = a1[1];
    std::string::size_type v15 = v18;
    uint64_t v14 = v19;
    if (v19 != v18)
    {
      do
      {
        uint64_t v16 = v14 - 40;
        std::string::size_type v22 = (void **)(v14 - 24);
        sub_1CCCBB47C(&v22);
        uint64_t v14 = v16;
      }
      while (v16 != v15);
    }
    if (__p) {
      operator delete(__p);
    }
  }
  else
  {
    *(_OWORD *)unint64_t v5 = *(_OWORD *)a2;
    *(void *)(v5 + 24) = 0;
    *(void *)(v5 + 32) = 0;
    *(void *)(v5 + 16) = 0;
    *(_OWORD *)(v5 + 16) = *(_OWORD *)(a2 + 16);
    *(void *)(v5 + 32) = *(void *)(a2 + 32);
    uint64_t v6 = v5 + 40;
    *(void *)(a2 + 16) = 0;
    *(void *)(a2 + 24) = 0;
    *(void *)(a2 + 32) = 0;
  }
  a1[1] = v6;
}

void llvm::PassBuilder::parseModulePass(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = MEMORY[0x1F4188790](a1, a2, a3, a4);
  unint64_t v7 = (uint64_t *)v5;
  unint64_t v9 = v8;
  uint64_t v10 = v4;
  __darwin_ct_rune_t v12 = v11;
  uint64_t v644 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = *(void *)(v4 + 1264);
  uint64_t v14 = *(unsigned int *)(v4 + 1272);
  if (*(void *)(v5 + 16) == *(void *)(v5 + 24))
  {
    if (v14)
    {
      std::string v41 = (uint64_t *)(v13 + 24);
      uint64_t v42 = 32 * v14;
      while (!sub_1CCC9EB34(*v41, *v7, v7[1], (uint64_t)v9, v7[2], 0xCCCCCCCCCCCCCCCDLL * ((v7[3] - v7[2]) >> 3)))
      {
        v41 += 4;
        v42 -= 32;
        if (!v42) {
          goto LABEL_43;
        }
      }
      goto LABEL_2016;
    }
LABEL_43:
    uint64_t v44 = *v7;
    unint64_t v43 = v7[1];
    BOOL v45 = sub_1CCC9EE68(*v7, v43);
    if (v45)
    {
      v600[0] = &v600[2];
      v600[1] = (void *)0x300000000;
      if ((llvm::Regex::match((uint64_t)&unk_1EBCEF410, (char *)v44, v43, (uint64_t)v600, 0) & 1) == 0)
      {
        *(void *)&long long v639 = "unknown default pipeline alias '{0}'";
        *((void *)&v639 + 1) = 36;
        v640 = &v643;
        uint64_t v641 = 1;
        v642[0] = &unk_1F2635860;
        v642[1] = v7;
        *(void *)&long long v643 = v642;
        sub_1CD465B2C((uint64_t)&v639, &__p);
        llvm::inconvertibleErrorCode(v127);
        operator new();
      }
      std::string v46 = v600[0];
      if (*((void *)v600[0] + 5) != 2)
      {
        unint64_t v48 = 0;
        LOBYTE(v49) = 0;
        goto LABEL_227;
      }
      long long v47 = (_WORD *)*((void *)v600[0] + 4);
      switch(*v47)
      {
        case 0x304F:
          uint64_t v114 = &llvm::OptimizationLevel::O0;
          break;
        case 0x314F:
          uint64_t v114 = &llvm::OptimizationLevel::O1;
          break;
        case 0x324F:
          uint64_t v114 = &llvm::OptimizationLevel::O2;
          break;
        case 0x334F:
          uint64_t v114 = &llvm::OptimizationLevel::O3;
          break;
        case 0x734F:
          uint64_t v114 = &llvm::OptimizationLevel::Os;
          break;
        default:
          BOOL v19 = *v47 == 31311;
          unint64_t v48 = (unint64_t)v19 << 25;
          if (v19) {
            LOBYTE(v49) = 2;
          }
          else {
            LOBYTE(v49) = 0;
          }
LABEL_227:
          unsigned int v128 = v49 | (v48 << 8);
          unint64_t v129 = v48 >> 24;
          if (!(v129 | v128))
          {
            uint64_t v130 = (unsigned __int16 *)*((void *)v600[0] + 2);
            uint64_t v131 = *((void *)v600[0] + 3);
            if (v131 == 3)
            {
              int v136 = *v130;
              int v133 = *((unsigned __int8 *)v130 + 2);
              BOOL v134 = v136 == 29804;
              int v135 = 111;
            }
            else
            {
              if (v131 != 7)
              {
                unint64_t v138 = v128 | ((unint64_t)v129 << 32);
LABEL_260:
                llvm::PassBuilder::buildO0DefaultPipeline((char *)v10, v138, &v597);
              }
              int v132 = *(_DWORD *)v130;
              int v133 = *(_DWORD *)((char *)v130 + 3);
              BOOL v134 = v132 == 1852401780;
              int v135 = 1869900910;
            }
            if (!v134 || v133 != v135)
            {
              unint64_t v138 = v128 | ((unint64_t)v129 << 32);
              goto LABEL_260;
            }
          }
          BOOL v141 = (v129 != 2 || v128 != 2) && v128 > 1;
          *(unsigned char *)(v10 + 9) = v141;
          *(unsigned char *)(v10 + 10) = v141;
          v143 = (uint64_t *)v46[2];
          uint64_t v142 = v46[3];
          switch(v142)
          {
            case 16:
              uint64_t v151 = *v143;
              uint64_t v152 = v143[1];
              if (v151 == 0x2D6F746C6E696874 && v152 == 0x6B6E696C2D657270) {
                llvm::PassBuilder::buildThinLTOPreLinkDefaultPipeline(&v597);
              }
              break;
            case 12:
              uint64_t v148 = *v143;
              int v149 = *((_DWORD *)v143 + 2);
              if (v148 == 0x2D6572702D6F746CLL && v149 == 1802398060) {
                llvm::PassBuilder::buildPerModuleDefaultPipeline(&v597);
              }
              break;
            case 7:
              if (*(_DWORD *)v143 == 1634100580 && *(_DWORD *)((char *)v143 + 3) == 1953264993) {
                llvm::PassBuilder::buildPerModuleDefaultPipeline(&v597);
              }
              int v145 = *(_DWORD *)v143;
              int v146 = *(_DWORD *)((char *)v143 + 3);
              if (v145 == 1852401780 && v146 == 1869900910) {
                llvm::PassBuilder::buildThinLTODefaultPipeline(&v597);
              }
              break;
          }
          llvm::PassBuilder::buildLTODefaultPipeline(&v597);
      }
      uint64_t v49 = *v114;
      unint64_t v48 = (unint64_t)*v114 >> 8;
      goto LABEL_227;
    }
    if (v43 == 18)
    {
      if (*(void *)v44 == 0x3C65726975716572
        && *(void *)(v44 + 8) == 0x706172676C6C6163
        && *(_WORD *)(v44 + 16) == 15976)
      {
        sub_1CD7072C4();
      }
      if (*(void *)v44 == 0x6164696C61766E69
        && *(void *)(v44 + 8) == 0x66697265763C6574
        && *(_WORD *)(v44 + 16) == 15993)
      {
        sub_1CD70797C();
      }
      if (*(void *)v44 == 0x6C672D7265776F6CLL
        && *(void *)(v44 + 8) == 0x6F74642D6C61626FLL
        && *(_WORD *)(v44 + 16) == 29554)
      {
        sub_1CD709148();
      }
      if (*(void *)v44 == 0x74732D746E697270
        && *(void *)(v44 + 8) == 0x656661732D6B6361
        && *(_WORD *)(v44 + 16) == 31092)
      {
        v600[0] = llvm::dbgs((llvm *)v45);
        sub_1CD709AE0();
      }
      if (*(void *)v44 == 0x636E75662D6F7072
        && *(void *)(v44 + 8) == 0x7474612D6E6F6974
        && *(_WORD *)(v44 + 16) == 29554)
      {
        sub_1CD709F30();
      }
      if (*(void *)v44 == 0x6F7270656C6F6877
        && *(void *)(v44 + 8) == 0x697665646D617267
        && *(_WORD *)(v44 + 16) == 29810)
      {
        v600[0] = 0;
        v600[1] = 0;
        LOBYTE(v600[2]) = 1;
        sub_1CD70A5C8();
      }
LABEL_108:
      int v64 = 0;
      int v65 = 0;
LABEL_109:
      int v66 = 0;
      int v67 = 0;
      int v68 = 0;
      int v69 = 0;
      int v70 = 0;
      int v71 = 0;
      int v72 = 0;
      int v73 = 0;
      int v74 = 0;
      int v75 = 0;
      int v76 = 0;
      int v77 = 0;
      int v78 = 0;
      uint64_t v575 = 0;
      int v79 = 0;
      int v80 = 0;
      int v81 = 0;
      int v82 = 0;
      int v576 = 0;
    }
    else
    {
      int v64 = 0;
      int v65 = 0;
      int v66 = 0;
      int v67 = 0;
      int v68 = 0;
      int v69 = 0;
      int v70 = 0;
      int v71 = 0;
      int v72 = 0;
      int v73 = 0;
      int v74 = 0;
      int v75 = 0;
      int v76 = 0;
      int v77 = 0;
      int v78 = 0;
      int v576 = 0;
      int v79 = 0;
      int v80 = 0;
      int v81 = 0;
      int v82 = 0;
      uint64_t v575 = 0;
      switch(v43)
      {
        case 5uLL:
          if (*(_DWORD *)v44 == 1852404336 && *(unsigned char *)(v44 + 4) == 116)
          {
            v600[0] = llvm::dbgs(0);
            v600[1] = 0;
            *(_WORD *)((char *)&v600[3] + 7) = 0;
            sub_1CD709890();
          }
          if (*(_DWORD *)v44 == 1769108595 && *(unsigned char *)(v44 + 4) == 112)
          {
            LOBYTE(v600[0]) = 1;
            sub_1CD70A08C();
          }
          if (*(_DWORD *)v44 == 1634952804 && *(unsigned char *)(v44 + 4) == 110)
          {
            long long v639 = 0uLL;
            v640 = 0;
            memset(v600, 0, 24);
            sub_1CD70A65C();
          }
          int v65 = 0;
          int v66 = 0;
          int v67 = 0;
          int v68 = 0;
          int v69 = 0;
          int v70 = 0;
          int v71 = 0;
          int v72 = 0;
          int v73 = 0;
          int v74 = 0;
          int v75 = 0;
          int v76 = 0;
          int v77 = 0;
          int v78 = 0;
          uint64_t v575 = 0;
          int v79 = 0;
          int v80 = 0;
          int v81 = 0;
          int v82 = 0;
          int v576 = 0;
          int v64 = 1;
          break;
        case 6uLL:
          if (*(_DWORD *)v44 == 1668509801 && *(_WORD *)(v44 + 4) == 28771) {
            sub_1CD708FB4();
          }
          BOOL v249 = *(_DWORD *)v44 == 1769104758 && *(_WORD *)(v44 + 4) == 31078;
          int v65 = 1;
          if (v249)
          {
            LOBYTE(v600[0]) = 1;
            sub_1CD69E654();
          }
          int v64 = 0;
          goto LABEL_109;
        case 7uLL:
        case 0x10uLL:
        case 0x12uLL:
        case 0x1EuLL:
        case 0x21uLL:
          break;
        case 8uLL:
          if (*(void *)v44 == 0x7966696775626564) {
            sub_1CD708568();
          }
          int v64 = 0;
          int v65 = 0;
          int v67 = 0;
          int v68 = 0;
          int v69 = 0;
          int v70 = 0;
          int v71 = 0;
          int v72 = 0;
          int v73 = 0;
          int v74 = 0;
          int v75 = 0;
          int v76 = 0;
          int v77 = 0;
          int v78 = 0;
          uint64_t v575 = 0;
          int v79 = 0;
          int v80 = 0;
          int v81 = 0;
          int v82 = 0;
          int v576 = 0;
          int v66 = 1;
          break;
        case 9uLL:
          if (*(void *)v44 == 0x63646C61626F6C67 && *(unsigned char *)(v44 + 8) == 101)
          {
            int v617 = 0;
            int v611 = 0;
            int v607 = 0;
            int v603 = 0;
            memset(v601, 0, sizeof(v601));
            memset(&v600[3], 0, 208);
            v600[0] = &v600[4];
            v600[1] = &v600[4];
            v600[2] = (void *)32;
            int v602 = 0;
            long long v604 = 0u;
            long long v605 = 0u;
            int v606 = 1065353216;
            long long v608 = 0u;
            long long v609 = 0u;
            int v610 = 1065353216;
            v613[0] = 0;
            uint64_t v612 = 0;
            v613[1] = 0;
            v615 = 0;
            uint64_t v614 = 0;
            int v616 = 0;
            sub_1CCC9EF80();
          }
          if (*(void *)v44 == 0x706F6C61626F6C67 && *(unsigned char *)(v44 + 8) == 116) {
            sub_1CCC9F04C();
          }
          if (*(void *)v44 == 0x6F72707274736E69 && *(unsigned char *)(v44 + 8) == 102)
          {
            memset(&v600[1], 0, 24);
            LOBYTE(v601[0]) = 0;
            LODWORD(v600[0]) = 0;
            memset(&v600[5], 0, 48);
            memset(&v600[14], 0, 28);
            memset(&v600[18], 0, 72);
            memset(&v601[1], 0, 32);
            sub_1CD708E40();
          }
          if (*(void *)v44 == 0x6E7566656772656DLL && *(unsigned char *)(v44 + 8) == 99) {
            sub_1CD7092E8();
          }
          if (*(void *)v44 == 0x636C2D746E697270 && *(unsigned char *)(v44 + 8) == 103)
          {
            v600[0] = llvm::dbgs(0);
            sub_1CD709948();
          }
          int v64 = 0;
          int v65 = 0;
          int v66 = 0;
          int v67 = 0;
          int v68 = 0;
          int v69 = 0;
          int v70 = 0;
          int v71 = 0;
          int v72 = 0;
          int v73 = 0;
          int v74 = 0;
          int v75 = 0;
          int v76 = 0;
          int v77 = 0;
          int v78 = 0;
          uint64_t v575 = 0;
          int v79 = 0;
          int v80 = 0;
          int v81 = 0;
          int v82 = 0;
          int v576 = 1;
          break;
        case 0xAuLL:
          if (*(void *)v44 == 0x7475626972747461 && *(_WORD *)(v44 + 8) == 29295) {
            sub_1CD707F2C();
          }
          if (*(void *)v44 == 0x6F2D706D6E65706FLL && *(_WORD *)(v44 + 8) == 29808) {
            sub_1CD708038();
          }
          if (*(void *)v44 == 0x69666F72702D6763 && *(_WORD *)(v44 + 8) == 25964) {
            sub_1CD7081C4();
          }
          if (*(void *)v44 == 0x72656D74736E6F63 && *(_WORD *)(v44 + 8) == 25959) {
            sub_1CD7082CC();
          }
          if (*(void *)v44 == 0x7261652D6F726F63 && *(_WORD *)(v44 + 8) == 31084) {
            sub_1CD708350();
          }
          if (*(void *)v44 == 0x7474616563726F66 && *(_WORD *)(v44 + 8) == 29554) {
            sub_1CD708778();
          }
          if (*(void *)v44 == 0x7474617265666E69 && *(_WORD *)(v44 + 8) == 29554) {
            sub_1CD708A10();
          }
          if (*(void *)v44 == 0x6E696C74756F7269 && *(_WORD *)(v44 + 8) == 29285) {
            sub_1CD70903C();
          }
          int v64 = 0;
          int v65 = 0;
          int v66 = 0;
          int v67 = 0;
          int v68 = 0;
          int v69 = 0;
          int v70 = 0;
          int v71 = 0;
          int v72 = 0;
          int v73 = 0;
          int v74 = 0;
          int v75 = 0;
          int v76 = 0;
          int v77 = 0;
          uint64_t v575 = 0;
          int v79 = 0;
          int v80 = 0;
          int v81 = 0;
          int v82 = 0;
          int v576 = 0;
          int v78 = 1;
          break;
        case 0xBuLL:
          if (*(void *)v44 == 0x6567726164616564 && *(void *)(v44 + 3) == 0x6D696C6567726164)
          {
            v600[0] = &v600[1];
            v600[1] = 0;
            v600[4] = 0;
            v600[5] = 0;
            v600[2] = 0;
            v600[3] = &v600[4];
            memset(&v600[7], 0, 17);
            v600[6] = &v600[7];
            sub_1CD708458();
          }
          if (*(void *)v44 == 0x70736C61626F6C67 && *(void *)(v44 + 3) == 0x74696C70736C6162) {
            sub_1CD708908();
          }
          if (*(void *)v44 == 0x6C616E7265746E69 && *(void *)(v44 + 3) == 0x657A696C616E7265)
          {
            llvm::InternalizePass::InternalizePass((llvm::InternalizePass *)&v639);
            operator new();
          }
          if (*(void *)v44 == 0x616E65726174656DLL && *(void *)(v44 + 3) == 0x72656D616E657261) {
            sub_1CD709264();
          }
          if (*(void *)v44 == 0x646F6D2D6E61736DLL && *(void *)(v44 + 3) == 0x656C75646F6D2D6ELL)
          {
            llvm::MemorySanitizerOptions::MemorySanitizerOptions((uint64_t)&v579, 0, 0, 0, 0);
            v600[0] = v579;
            LODWORD(v600[1]) = v580;
            sub_1CD70A734();
          }
          if (*(void *)v44 == 0x646F6D2D6E617374 && *(void *)(v44 + 3) == 0x656C75646F6D2D6ELL) {
            sub_1CD70A898();
          }
          int v64 = 0;
          int v65 = 0;
          int v66 = 0;
          int v67 = 0;
          int v68 = 0;
          int v69 = 0;
          int v70 = 0;
          int v71 = 0;
          int v72 = 0;
          int v73 = 0;
          int v74 = 0;
          int v75 = 0;
          int v76 = 0;
          int v77 = 0;
          int v78 = 0;
          uint64_t v575 = 0;
          int v79 = 0;
          int v80 = 0;
          int v82 = 0;
          int v576 = 0;
          int v81 = 1;
          break;
        case 0xCuLL:
          if (*(void *)v44 == 0x3C65726975716572 && *(_DWORD *)(v44 + 8) == 1046963052) {
            sub_1CD7074D4();
          }
          if (*(void *)v44 == 0x73646C6F63746F68 && *(_DWORD *)(v44 + 8) == 1953066096) {
            sub_1CD70898C();
          }
          if (*(void *)v44 == 0x6F6D2D706F2D6F6ELL && *(_DWORD *)(v44 + 8) == 1701606756) {
            operator new();
          }
          if (*(void *)v44 == 0x702D6F6475657370 && *(_DWORD *)(v44 + 8) == 1700949874)
          {
            v600[0] = *(void **)v10;
            sub_1CD70A19C();
          }
          if (*(void *)v44 == 0x7274702D74666F73 && *(_DWORD *)(v44 + 8) == 1752462689) {
            sub_1CD70A224();
          }
          int v64 = 0;
          int v65 = 0;
          int v66 = 0;
          int v67 = 0;
          int v68 = 0;
          int v69 = 0;
          int v70 = 0;
          int v71 = 0;
          int v72 = 0;
          int v73 = 0;
          int v74 = 0;
          int v75 = 0;
          int v77 = 0;
          int v78 = 0;
          uint64_t v575 = 0;
          int v79 = 0;
          int v80 = 0;
          int v81 = 0;
          int v82 = 0;
          int v576 = 0;
          int v76 = 1;
          break;
        case 0xDuLL:
          if (*(void *)v44 == 0x692D737961776C61 && *(void *)(v44 + 5) == 0x656E696C6E692D73)
          {
            LOBYTE(v600[0]) = 1;
            sub_1CCC9EEF0();
          }
          if (*(void *)v44 == 0x73642D73736F7263 && *(void *)(v44 + 5) == 0x6966632D6F73642DLL) {
            sub_1CD7083D4();
          }
          if (*(void *)v44 == 0x6C6C61632D746F64 && *(void *)(v44 + 5) == 0x68706172676C6C61) {
            sub_1CD7085EC();
          }
          if (*(void *)v44 == 0x74736E692D6F6770 && *(void *)(v44 + 5) == 0x6E65672D7274736ELL)
          {
            LOBYTE(v600[0]) = 0;
            sub_1CD709598();
          }
          if (*(void *)v44 == 0x74736E692D6F6770 && *(void *)(v44 + 5) == 0x6573752D7274736ELL)
          {
            char v590 = 0;
            LOBYTE(v589) = 0;
            char v588 = 0;
            LOBYTE(v587) = 0;
            uint64_t v586 = 0;
            llvm::PGOInstrumentationUse::PGOInstrumentationUse((uint64_t)v600, &v589, &v587, 0, &v586);
            sub_1CD709624();
          }
          if (*(void *)v44 == 0x636C2D746E697270 && *(void *)(v44 + 5) == 0x746F642D67636C2DLL)
          {
            v600[0] = llvm::dbgs(0);
            sub_1CD7099D0();
          }
          if (*(void *)v44 == 0x692D656C75646F6DLL && *(void *)(v44 + 5) == 0x656E696C6E692D65)
          {
            llvm::getInlineParams(dword_1EBD039A0, (uint64_t)&v600[1]);
            v600[0] = 0;
            HIDWORD(v600[9]) = 0;
            sub_1CD70A7D4();
          }
          if (*(void *)v44 == 0x6D2D766F636E6173 && *(void *)(v44 + 5) == 0x656C75646F6D2D76)
          {
            long long v577 = 0uLL;
            int v578 = 0;
            long long v639 = 0uLL;
            v640 = 0;
            v597 = 0;
            uint64_t v598 = 0;
            uint64_t v599 = 0;
            sub_1CD71993C((uint64_t)v600, &v577, &v639, &v597);
            sub_1CD70A91C();
          }
          int v64 = 0;
          int v65 = 0;
          int v66 = 0;
          int v67 = 0;
          int v68 = 0;
          int v69 = 0;
          int v70 = 0;
          int v71 = 0;
          int v72 = 0;
          int v73 = 0;
          int v74 = 0;
          int v75 = 0;
          int v76 = 0;
          int v77 = 0;
          int v78 = 0;
          uint64_t v575 = 0;
          int v79 = 0;
          int v81 = 0;
          int v82 = 0;
          int v576 = 0;
          int v80 = 1;
          break;
        case 0xEuLL:
          if (*(void *)v44 == 0x65642D6B63656863 && *(void *)(v44 + 6) == 0x7966696775626564) {
            sub_1CD708248();
          }
          if (*(void *)v44 == 0x2D74636172747865 && *(void *)(v44 + 6) == 0x736B636F6C622D74) {
            sub_1CD7086F4();
          }
          if (*(void *)v44 == 0x64726F7274736E69 && *(void *)(v44 + 6) == 0x656C696672656472) {
            sub_1CD708DBC();
          }
          if (*(void *)v44 == 0x7079747265776F6CLL && *(void *)(v44 + 6) == 0x7374736574657079)
          {
            LOBYTE(v600[0]) = 1;
            v600[1] = 0;
            v600[2] = 0;
            LOBYTE(v600[3]) = 1;
            sub_1CD7091CC();
          }
          if (*(void *)v44 == 0x6C6163692D6F6770 && *(void *)(v44 + 6) == 0x6D6F72702D6C6C61)
          {
            LOWORD(v600[0]) = 0;
            sub_1CD7094F8();
          }
          if (*(void *)v44 == 0x702D656C706D6173 && *(void *)(v44 + 6) == 0x656C69666F72702DLL)
          {
            char v585 = 0;
            LOBYTE(v584) = 0;
            char v583 = 0;
            LOBYTE(v582) = 0;
            uint64_t v581 = 0;
            sub_1CD7198AC((uint64_t)v600, &v584, &v582, 0);
            sub_1CD709FB8();
          }
          if (*(void *)v44 == 0x6F6E2D7069727473 && *(void *)(v44 + 6) == 0x67756265646E6F6ELL)
          {
            LOBYTE(v600[0]) = 1;
            sub_1CD70A3B0();
          }
          if (*(void *)v44 == 0x6C61632D77656976 && *(void *)(v44 + 6) == 0x68706172676C6C61) {
            sub_1CD70A544();
          }
          if (*(void *)v44 == 0x2D666F72706D656DLL && *(void *)(v44 + 6) == 0x656C75646F6D2D66) {
            sub_1CD70A9F0();
          }
          int v64 = 0;
          int v65 = 0;
          int v66 = 0;
          int v68 = 0;
          int v69 = 0;
          int v70 = 0;
          int v71 = 0;
          int v72 = 0;
          int v73 = 0;
          int v74 = 0;
          int v75 = 0;
          int v76 = 0;
          int v77 = 0;
          int v78 = 0;
          uint64_t v575 = 0;
          int v79 = 0;
          int v80 = 0;
          int v81 = 0;
          int v82 = 0;
          int v576 = 0;
          int v67 = 1;
          break;
        case 0xFuLL:
          if (*(void *)v44 == 0x6164696C61766E69 && *(void *)(v44 + 7) == 0x3E67636C3C657461) {
            sub_1CD707558();
          }
          if (*(void *)v44 == 0x3C65726975716572 && *(void *)(v44 + 7) == 0x3E7966697265763CLL) {
            sub_1CD7078F8();
          }
          if (*(void *)v44 == 0x6E6F6974636E7566 && *(void *)(v44 + 7) == 0x74726F706D692D6ELL) {
            sub_1CD708800();
          }
          if (*(void *)v44 == 0x2D72656E696C6E69 && *(void *)(v44 + 7) == 0x726570706172772DLL)
          {
            llvm::getInlineParams(dword_1EBD039A0, (uint64_t)v592);
            v250 = v592;
            int v251 = 1;
LABEL_1223:
            llvm::ModuleInlinerWrapperPass::ModuleInlinerWrapperPass((uint64_t)v600, (uint64_t)v250, v251, 0, 0);
          }
          if (*(void *)v44 == 0x6164696C61766E69 && *(void *)(v44 + 7) == 0x3E6C6C613C657461) {
            sub_1CD708F30();
          }
          if (*(void *)v44 == 0x6372612D636A626FLL && *(void *)(v44 + 7) == 0x6D696C6570612D63) {
            sub_1CD7093F0();
          }
          if (*(void *)v44 == 0x2D6C616974726170 && *(void *)(v44 + 7) == 0x72656E696C6E692DLL) {
            sub_1CD709474();
          }
          if (*(void *)v44 == 0x61632D746E697270 && *(void *)(v44 + 7) == 0x68706172676C6C61)
          {
            v600[0] = llvm::dbgs(0);
            sub_1CD709808();
          }
          if (*(void *)v44 == 0x2D65746972776572 && *(void *)(v44 + 7) == 0x736C6F626D79732DLL)
          {
            v600[0] = v600;
            v600[1] = v600;
            v600[2] = 0;
            llvm::RewriteSymbolPass::loadAndParseMapFiles((llvm::RewriteSymbolPass *)v600);
            sub_1CD709DF0();
          }
          if (*(void *)v44 == 0x632D6E6F73696F70 && *(void *)(v44 + 7) == 0x676E696B63656863) {
            sub_1CD70AA74();
          }
          int v64 = 0;
          int v65 = 0;
          int v66 = 0;
          int v67 = 0;
          int v68 = 0;
          int v69 = 0;
          int v70 = 0;
          int v71 = 0;
          int v73 = 0;
          int v74 = 0;
          int v75 = 0;
          int v76 = 0;
          int v77 = 0;
          int v78 = 0;
          uint64_t v575 = 0;
          int v79 = 0;
          int v80 = 0;
          int v81 = 0;
          int v82 = 0;
          int v576 = 0;
          int v72 = 1;
          break;
        case 0x11uLL:
          if (*(void *)v44 == 0x6176612D6D696C65
            && *(void *)(v44 + 8) == 0x72657478652D6C69
            && *(unsigned char *)(v44 + 16) == 110)
          {
            sub_1CD708670();
          }
          if (*(void *)v44 == 0x6F6E612D656D616ELL
            && *(void *)(v44 + 8) == 0x6C61626F6C672D6ELL
            && *(unsigned char *)(v44 + 16) == 115)
          {
            sub_1CD70936C();
          }
          int v64 = 0;
          int v65 = 0;
          int v66 = 0;
          int v67 = 0;
          int v68 = 0;
          int v69 = 0;
          int v70 = 0;
          int v71 = 0;
          int v72 = 0;
          int v73 = 0;
          int v74 = 0;
          int v75 = 0;
          int v76 = 0;
          int v77 = 0;
          int v78 = 0;
          uint64_t v575 = 0;
          int v79 = 0;
          int v80 = 0;
          int v81 = 0;
          int v576 = 0;
          int v82 = 1;
          break;
        case 0x13uLL:
          if (*(void *)v44 == 0x3C65726975716572
            && *(void *)(v44 + 8) == 0x2D736C61626F6C67
            && *(void *)(v44 + 11) == 0x3E61612D736C6162)
          {
            sub_1CD707E20();
          }
          if (*(void *)v44 == 0x697461746F6E6E61
            && *(void *)(v44 + 8) == 0x646174656D326E6FLL
            && *(void *)(v44 + 11) == 0x617461646174656DLL)
          {
            sub_1CD707FB0();
          }
          if (*(void *)v44 == 0x72692D746E697270
            && *(void *)(v44 + 8) == 0x72616C696D69732DLL
            && *(void *)(v44 + 11) == 0x79746972616C696DLL)
          {
            v600[0] = llvm::dbgs(0);
            sub_1CD7090C0();
          }
          if (*(void *)v44 == 0x7475706D6F636572
            && *(void *)(v44 + 8) == 0x6C61626F6C672D65
            && *(void *)(v44 + 11) == 0x6161736C61626F6CLL)
          {
            sub_1CD709C64();
          }
          if (*(void *)v44 == 0x65642D7069727473
            && *(void *)(v44 + 8) == 0x6C6365642D677562
            && *(void *)(v44 + 11) == 0x6572616C6365642DLL)
          {
            sub_1CD70A32C();
          }
          if (*(void *)v44 == 0x702D6F6475657370
            && *(void *)(v44 + 8) == 0x6470752D65626F72
            && *(void *)(v44 + 11) == 0x6574616470752D65)
          {
            sub_1CD70AAF8();
          }
          int v64 = 0;
          int v65 = 0;
          int v66 = 0;
          int v67 = 0;
          int v68 = 0;
          int v69 = 0;
          int v70 = 0;
          int v71 = 0;
          int v72 = 0;
          int v73 = 0;
          int v74 = 0;
          int v75 = 0;
          int v76 = 0;
          int v77 = 0;
          int v78 = 0;
          uint64_t v575 = 0;
          int v80 = 0;
          int v81 = 0;
          int v82 = 0;
          int v576 = 0;
          int v79 = 1;
          break;
        case 0x14uLL:
          if (*(void *)v44 == 0x6163696E6F6E6163
            && *(void *)(v44 + 8) == 0x696C612D657A696CLL
            && *(_DWORD *)(v44 + 16) == 1936028513)
          {
            sub_1CD708140();
          }
          int v64 = 0;
          int v65 = 0;
          int v66 = 0;
          int v67 = 0;
          int v69 = 0;
          int v70 = 0;
          int v71 = 0;
          int v72 = 0;
          int v73 = 0;
          int v74 = 0;
          int v75 = 0;
          int v76 = 0;
          int v77 = 0;
          int v78 = 0;
          uint64_t v575 = 0;
          int v79 = 0;
          int v80 = 0;
          int v81 = 0;
          int v82 = 0;
          int v576 = 0;
          int v68 = 1;
          break;
        case 0x15uLL:
          if (*(void *)v44 == 0x6164696C61766E69
            && *(void *)(v44 + 8) == 0x676C6C61633C6574
            && *(void *)(v44 + 13) == 0x3E68706172676C6CLL)
          {
            sub_1CD707348();
          }
          if (*(void *)v44 == 0x3C65726975716572
            && *(void *)(v44 + 8) == 0x6F6D2D706F2D6F6ELL
            && *(void *)(v44 + 13) == 0x3E656C75646F6D2DLL)
          {
            operator new();
          }
          if (*(void *)v44 == 0x3C65726975716572
            && *(void *)(v44 + 8) == 0x61732D6B63617473
            && *(void *)(v44 + 13) == 0x3E7974656661732DLL)
          {
            sub_1CD7077F0();
          }
          if (*(void *)v44 == 0x6E693C746E697270
            && *(void *)(v44 + 8) == 0x7664612D656E696CLL
            && *(void *)(v44 + 13) == 0x3E726F7369766461)
          {
            v600[0] = llvm::dbgs(0);
            sub_1CD708C58();
          }
          if (*(void *)v44 == 0x672D747265736E69
            && *(void *)(v44 + 8) == 0x666F72702D766F63
            && *(void *)(v44 + 13) == 0x676E696C69666F72)
          {
            llvm::GCOVOptions::getDefault((uint64_t)&v639);
            sub_1CD692AA4(v600, (uint64_t)&v639);
            sub_1CD708CE0();
          }
          if (*(void *)v44 == 0x75662D746E697270
            && *(void *)(v44 + 8) == 0x672D6E6F6974636ELL
            && *(void *)(v44 + 13) == 0x7370756F72672D6ELL)
          {
            v600[0] = llvm::dbgs(0);
            sub_1CD7096F8();
          }
          if (*(void *)v44 == 0x72702D746E697270
            && *(void *)(v44 + 8) == 0x75732D656C69666FLL
            && *(void *)(v44 + 13) == 0x7972616D6D75732DLL)
          {
            v600[0] = llvm::dbgs(0);
            sub_1CD709780();
          }
          if (*(void *)v44 == 0x6D2D7A6F2D636373
            && *(void *)(v44 + 8) == 0x6E692D656C75646FLL
            && *(void *)(v44 + 13) == 0x72656E696C6E692DLL)
          {
            llvm::PassBuilder::buildInlinerPipeline((llvm *)0x200000002, v10, 0, (uint64_t)v600);
          }
          if (*(void *)v44 == 0x65642D7069727473
            && *(void *)(v44 + 8) == 0x67756265642D6461
            && *(void *)(v44 + 13) == 0x6F666E692D677562)
          {
            sub_1CD70A118();
          }
          if (*(void *)v44 == 0x65642D7069727473
            && *(void *)(v44 + 8) == 0x6F746F72702D6461
            && *(void *)(v44 + 13) == 0x73657079746F746FLL)
          {
            sub_1CD70A2A8();
          }
          int v64 = 0;
          int v65 = 0;
          int v66 = 0;
          int v67 = 0;
          int v68 = 0;
          int v69 = 0;
          int v70 = 0;
          int v71 = 0;
          int v72 = 0;
          int v73 = 0;
          int v75 = 0;
          int v76 = 0;
          int v77 = 0;
          int v78 = 0;
          uint64_t v575 = 0;
          int v79 = 0;
          int v80 = 0;
          int v81 = 0;
          int v82 = 0;
          int v576 = 0;
          int v74 = 1;
          break;
        case 0x16uLL:
          if (*(void *)v44 == 0x3C65726975716572
            && *(void *)(v44 + 8) == 0x6C696D69732D7269
            && *(void *)(v44 + 14) == 0x3E79746972616C69)
          {
            sub_1CD707D18();
          }
          if (*(void *)v44 == 0x6164696C61766E69
            && *(void *)(v44 + 8) == 0x61626F6C673C6574
            && *(void *)(v44 + 14) == 0x3E61612D736C6162)
          {
            sub_1CD707EA8();
          }
          int v64 = 0;
          int v65 = 0;
          int v66 = 0;
          int v67 = 0;
          int v68 = 0;
          int v70 = 0;
          int v71 = 0;
          int v72 = 0;
          int v73 = 0;
          int v74 = 0;
          int v75 = 0;
          int v76 = 0;
          int v77 = 0;
          int v78 = 0;
          uint64_t v575 = 0;
          int v79 = 0;
          int v80 = 0;
          int v81 = 0;
          int v82 = 0;
          int v576 = 0;
          int v69 = 1;
          break;
        case 0x17uLL:
          if (*(void *)v44 == 0x3C65726975716572
            && *(void *)(v44 + 8) == 0x732D656C75646F6DLL
            && *(void *)(v44 + 15) == 0x3E7972616D6D7573)
          {
            sub_1CD7075DC();
          }
          if (*(void *)v44 == 0x3C65726975716572
            && *(void *)(v44 + 8) == 0x612D656E696C6E69
            && *(void *)(v44 + 15) == 0x3E726F7369766461)
          {
            sub_1CD707C10();
          }
          if (*(void *)v44 == 0x6E6F6974636E7566
            && *(void *)(v44 + 8) == 0x6C6169636570732DLL
            && *(void *)(v44 + 15) == 0x6E6F6974617A696CLL)
          {
            sub_1CD708884();
          }
          if (*(void *)v44 == 0x6F6D3C746E697270
            && *(void *)(v44 + 8) == 0x6265642D656C7564
            && *(void *)(v44 + 15) == 0x3E6F666E69677562)
          {
            v600[0] = &v600[2];
            v600[1] = (void *)0x800000000;
            v600[10] = &v600[12];
            v600[11] = (void *)0x800000000;
            v600[20] = &v600[22];
            v600[21] = (void *)0x800000000;
            v601[1] = &v601[3];
            v601[2] = (void *)0x800000000;
            *((void *)&v604 + 1) = (char *)&v605 + 8;
            *(void *)&long long v605 = 0x800000000;
            v613[0] = &v616;
            v613[1] = &v616;
            uint64_t v614 = 32;
            LODWORD(v615) = 0;
            v625 = llvm::dbgs(0);
            sub_1CD709B68();
          }
          int v64 = 0;
          int v65 = 0;
          int v66 = 0;
          int v67 = 0;
          int v68 = 0;
          int v69 = 0;
          int v70 = 0;
          int v71 = 0;
          int v72 = 0;
          int v73 = 0;
          int v74 = 0;
          int v75 = 0;
          int v76 = 0;
          int v78 = 0;
          uint64_t v575 = 0;
          int v79 = 0;
          int v80 = 0;
          int v81 = 0;
          int v82 = 0;
          int v576 = 0;
          int v77 = 1;
          break;
        case 0x18uLL:
          if (*(void *)v44 == 0x3C65726975716572
            && *(void *)(v44 + 8) == 0x6E6F6974636E7566
            && *(void *)(v44 + 16) == 0x3E7370756F72672DLL)
          {
            sub_1CD7073CC();
          }
          if (*(void *)v44 == 0x6164696C61766E69
            && *(void *)(v44 + 8) == 0x706F2D6F6E3C6574
            && *(void *)(v44 + 16) == 0x3E656C75646F6D2DLL)
          {
            operator new();
          }
          if (*(void *)v44 == 0x3C65726975716572
            && *(void *)(v44 + 8) == 0x2D656C69666F7270
            && *(void *)(v44 + 16) == 0x3E7972616D6D7573)
          {
            sub_1CD7076E4();
          }
          if (*(void *)v44 == 0x6164696C61766E69
            && *(void *)(v44 + 8) == 0x6B636174733C6574
            && *(void *)(v44 + 16) == 0x3E7974656661732DLL)
          {
            sub_1CD707874();
          }
          if (*(void *)v44 == 0x3C65726975716572
            && *(void *)(v44 + 8) == 0x6F6C672D6E617361
            && *(void *)(v44 + 16) == 0x3E646D2D736C6162)
          {
            sub_1CD707B08();
          }
          if (*(void *)v44 == 0x762D64656C6C6163
            && *(void *)(v44 + 8) == 0x6F72702D65756C61
            && *(void *)(v44 + 16) == 0x6E6F697461676170)
          {
            sub_1CD7080BC();
          }
          int v64 = 0;
          int v65 = 0;
          int v66 = 0;
          int v67 = 0;
          int v68 = 0;
          int v69 = 0;
          int v70 = 0;
          int v71 = 0;
          int v72 = 0;
          int v73 = 0;
          int v74 = 0;
          int v76 = 0;
          int v77 = 0;
          int v78 = 0;
          uint64_t v575 = 0;
          int v79 = 0;
          int v80 = 0;
          int v81 = 0;
          int v82 = 0;
          int v576 = 0;
          int v75 = 1;
          break;
        case 0x19uLL:
          if (*(void *)v44 == 0x6164696C61766E69
            && *(void *)(v44 + 8) == 0x69732D72693C6574
            && *(void *)(v44 + 16) == 0x79746972616C696DLL
            && *(unsigned char *)(v44 + 24) == 62)
          {
            sub_1CD707D9C();
          }
          int v64 = 0;
          int v65 = 0;
          int v66 = 0;
          int v67 = 0;
          int v68 = 0;
          int v69 = 0;
          int v70 = 0;
          int v71 = 0;
          int v72 = 0;
          int v73 = 0;
          int v74 = 0;
          int v75 = 0;
          int v76 = 0;
          int v77 = 0;
          int v78 = 0;
          int v79 = 0;
          int v80 = 0;
          int v81 = 0;
          int v82 = 0;
          uint64_t v575 = 0x100000000;
          int v576 = 0;
          break;
        case 0x1AuLL:
          if (*(void *)v44 == 0x6164696C61766E69
            && *(void *)(v44 + 8) == 0x6C75646F6D3C6574
            && *(void *)(v44 + 16) == 0x72616D6D75732D65
            && *(_WORD *)(v44 + 24) == 15993)
          {
            sub_1CD707660();
          }
          if (*(void *)v44 == 0x6164696C61766E69
            && *(void *)(v44 + 8) == 0x6E696C6E693C6574
            && *(void *)(v44 + 16) == 0x6F73697664612D65
            && *(_WORD *)(v44 + 24) == 15986)
          {
            sub_1CD707C94();
          }
          if (*(void *)v44 == 0x6B6F6F6C2D6C6572
            && *(void *)(v44 + 8) == 0x656C6261742D7075
            && *(void *)(v44 + 16) == 0x747265766E6F632DLL
            && *(_WORD *)(v44 + 24) == 29285)
          {
            sub_1CD709CE8();
          }
          if (*(void *)v44 == 0x2D65746972776572
            && *(void *)(v44 + 8) == 0x696F706574617473
            && *(void *)(v44 + 16) == 0x2D726F662D73746ELL
            && *(_WORD *)(v44 + 24) == 25447)
          {
            sub_1CD709D6C();
          }
          int v64 = 0;
          int v65 = 0;
          int v66 = 0;
          int v67 = 0;
          int v68 = 0;
          int v69 = 0;
          int v70 = 0;
          int v72 = 0;
          int v73 = 0;
          int v74 = 0;
          int v75 = 0;
          int v76 = 0;
          int v77 = 0;
          int v78 = 0;
          uint64_t v575 = 0;
          int v79 = 0;
          int v80 = 0;
          int v81 = 0;
          int v82 = 0;
          int v576 = 0;
          int v71 = 1;
          break;
        case 0x1BuLL:
          if (*(void *)v44 == 0x6164696C61766E69
            && *(void *)(v44 + 8) == 0x74636E75663C6574
            && *(void *)(v44 + 16) == 0x756F72672D6E6F69
            && *(void *)(v44 + 19) == 0x3E7370756F72672DLL)
          {
            sub_1CD707450();
          }
          if (*(void *)v44 == 0x6164696C61766E69
            && *(void *)(v44 + 8) == 0x69666F72703C6574
            && *(void *)(v44 + 16) == 0x616D6D75732D656CLL
            && *(void *)(v44 + 19) == 0x3E7972616D6D7573)
          {
            sub_1CD70776C();
          }
          if (*(void *)v44 == 0x6164696C61766E69
            && *(void *)(v44 + 8) == 0x2D6E6173613C6574
            && *(void *)(v44 + 16) == 0x2D736C61626F6C67
            && *(void *)(v44 + 19) == 0x3E646D2D736C6162)
          {
            sub_1CD707B8C();
          }
          int v64 = 0;
          int v65 = 0;
          int v66 = 0;
          int v67 = 0;
          int v68 = 0;
          int v69 = 0;
          int v70 = 0;
          int v71 = 0;
          int v72 = 0;
          int v74 = 0;
          int v75 = 0;
          int v76 = 0;
          int v77 = 0;
          int v78 = 0;
          uint64_t v575 = 0;
          int v79 = 0;
          int v80 = 0;
          int v81 = 0;
          int v82 = 0;
          int v576 = 0;
          int v73 = 1;
          break;
        case 0x1CuLL:
          if (*(void *)v44 == 0x6F6E2D7069727473
            && *(void *)(v44 + 8) == 0x626174656E696C6ELL
            && *(void *)(v44 + 16) == 0x67756265642D656CLL
            && *(_DWORD *)(v44 + 24) == 1868983913)
          {
            sub_1CD70A43C();
          }
          if (*(void *)v44 == 0x69746568746E7973
            && *(void *)(v44 + 8) == 0x73746E756F632D63
            && *(void *)(v44 + 16) == 0x616761706F72702DLL
            && *(_DWORD *)(v44 + 24) == 1852795252)
          {
            sub_1CD70A4C0();
          }
          int v64 = 0;
          int v65 = 0;
          int v66 = 0;
          int v67 = 0;
          int v68 = 0;
          int v69 = 0;
          int v70 = 0;
          int v71 = 0;
          int v72 = 0;
          int v73 = 0;
          int v74 = 0;
          int v75 = 0;
          int v76 = 0;
          int v77 = 0;
          int v78 = 0;
          int v576 = 0;
          int v79 = 0;
          int v80 = 0;
          int v81 = 0;
          int v82 = 0;
          uint64_t v575 = 1;
          break;
        case 0x1DuLL:
          if (*(void *)v44 == 0x3C65726975716572
            && *(void *)(v44 + 8) == 0x736E692D73736170
            && *(void *)(v44 + 16) == 0x61746E656D757274
            && *(void *)(v44 + 21) == 0x3E6E6F697461746ELL)
          {
            sub_1CD707A00();
          }
          int v64 = 0;
          int v65 = 0;
          int v66 = 0;
          int v67 = 0;
          int v68 = 0;
          int v69 = 0;
          int v71 = 0;
          int v72 = 0;
          int v73 = 0;
          int v74 = 0;
          int v75 = 0;
          int v76 = 0;
          int v77 = 0;
          int v78 = 0;
          uint64_t v575 = 0;
          int v79 = 0;
          int v80 = 0;
          int v81 = 0;
          int v82 = 0;
          int v576 = 0;
          int v70 = 1;
          break;
        case 0x1FuLL:
          if (*(void *)v44 == 0x756D2D746E697270
            && *(void *)(v44 + 8) == 0x78652D65622D7473
            && *(void *)(v44 + 16) == 0x632D646574756365
            && *(void *)(v44 + 23) == 0x73747865746E6F63)
          {
            v600[0] = llvm::dbgs(0);
            sub_1CD709A58();
          }
          goto LABEL_108;
        case 0x20uLL:
          if (*(void *)v44 == 0x6164696C61766E69
            && *(void *)(v44 + 8) == 0x2D737361703C6574
            && *(void *)(v44 + 16) == 0x656D757274736E69
            && *(void *)(v44 + 24) == 0x3E6E6F697461746ELL)
          {
            sub_1CD707A84();
          }
          goto LABEL_108;
        case 0x22uLL:
          if (memcmp((const void *)v44, "inliner-wrapper-no-mandatory-first", 0x22uLL)) {
            goto LABEL_108;
          }
          llvm::getInlineParams(dword_1EBD039A0, (uint64_t)v591);
          v250 = v591;
          int v251 = 0;
          goto LABEL_1223;
        default:
          int v576 = 0;
          int v79 = 0;
          int v80 = 0;
          int v81 = 0;
          int v82 = 0;
          uint64_t v575 = 0;
          break;
      }
    }
    int v574 = v78;
    int v83 = v70;
    int v562 = v73;
    int v563 = v77;
    int v565 = v65;
    int v566 = v74;
    int v561 = v75;
    int v567 = v79;
    int v568 = v66;
    int v84 = v76;
    int v570 = v80;
    int v571 = v69;
    int v564 = v82;
    int v572 = v81;
    int v573 = v67;
    int v569 = v68;
    if (sub_1CCC9F0D4((char *)v44, v43, "loop-extract", 0xCuLL))
    {
      sub_1CCC9F164((int)v600, (uint64_t (*)(char *, size_t))sub_1CCC9F23C, (char *)v44, v43, "loop-extract", 0xCuLL);
      if (((uint64_t)v600[1] & 1) == 0)
      {
        if (LOBYTE(v600[0])) {
          int v85 = 1;
        }
        else {
          int v85 = -1;
        }
        LODWORD(v639) = v85;
        sub_1CD70AB7C();
      }
      goto LABEL_210;
    }
    if (!sub_1CCC9F0D4((char *)v44, v43, "hwasan", 6uLL))
    {
      if (!sub_1CCC9F0D4((char *)v44, v43, "asan-module", 0xBuLL))
      {
        if (v84)
        {
          if (*(void *)v44 == 0x6F6D6F7270677261 && *(_DWORD *)(v44 + 8) == 1852795252) {
            operator new();
          }
        }
        if (v72)
        {
          if (*(void *)v44 == 0x6164696C61766E69 && *(void *)(v44 + 7) == 0x3E6C6C613C657461) {
            operator new();
          }
        }
        if (v573)
        {
          BOOL v111 = *(void *)v44 == 0x6E6F6974636E7566 && *(void *)(v44 + 6) == 0x73727474612D6E6FLL;
          int v112 = v572;
          int v113 = v574;
          if (v111) {
            operator new();
          }
          int v560 = 0;
        }
        else
        {
          int v113 = v574;
          if (v43 == 16)
          {
            if (*(void *)v44 == 0x7475626972747461 && *(void *)(v44 + 8) == 0x63637367632D726FLL) {
              operator new();
            }
            BOOL v116 = *(void *)v44 == 0x6F2D706D6E65706FLL && *(void *)(v44 + 8) == 0x63637367632D7470;
            int v112 = v572;
            if (v116) {
              operator new();
            }
            int v560 = 1;
          }
          else
          {
            int v560 = 0;
            int v112 = v572;
          }
        }
        if (v113)
        {
          if (*(void *)v44 == 0x6C70732D6F726F63 && *(_WORD *)(v44 + 8) == 29801) {
            operator new();
          }
        }
        if (v112)
        {
          if (*(void *)v44 == 0x67632D706F2D6F6ELL && *(void *)(v44 + 3) == 0x63637367632D706FLL) {
            operator new();
          }
          BOOL v119 = sub_1CCC9F0D4((char *)v44, v43, "inline", 6uLL);
          if (!v119)
          {
            int v120 = 0;
            int v121 = 0;
            int v122 = v571;
            int v123 = v72;
            int v124 = v84;
            if (!v72) {
              goto LABEL_993;
            }
            goto LABEL_989;
          }
LABEL_209:
          sub_1CCC9F164((int)v600, (uint64_t (*)(char *, size_t))sub_1CCC9F264, (char *)v44, v43, "inline", 6uLL);
          if (((uint64_t)v600[1] & 1) == 0) {
            operator new();
          }
          goto LABEL_210;
        }
        BOOL v119 = sub_1CCC9F0D4((char *)v44, v43, "inline", 6uLL);
        if (v119) {
          goto LABEL_209;
        }
        if (v43 == 4)
        {
          int v122 = v571;
          int v123 = v72;
          if (*(_DWORD *)v44 == 1701012577) {
            operator new();
          }
          int v124 = v84;
          int v120 = 0;
          int v121 = 1;
          if (!v72)
          {
LABEL_993:
            if (v71)
            {
              BOOL v344 = *(void *)v44 == 0x6E656D6E67696C61 && *(void *)(v44 + 8) == 0x612D6D6F72662D74;
              BOOL v345 = v344 && *(void *)(v44 + 16) == 0x6F6974706D757373;
              if (v345 && *(_WORD *)(v44 + 24) == 29550) {
                operator new();
              }
            }
            if (v43 == 18)
            {
              BOOL v347 = *(void *)v44 == 0x697461746F6E6E61 && *(void *)(v44 + 8) == 0x72616D65722D6E6FLL;
              if (v347 && *(_WORD *)(v44 + 16) == 29547) {
                operator new();
              }
            }
            if (v121 && *(_DWORD *)v44 == 1701012578) {
              operator new();
            }
            if (v123)
            {
              if (*(void *)v44 == 0x632D73646E756F62 && *(void *)(v44 + 7) == 0x676E696B63656863) {
                operator new();
              }
            }
            if (v560)
            {
              if (*(void *)v44 == 0x72632D6B61657262 && *(void *)(v44 + 8) == 0x73656764652D7469) {
                operator new();
              }
            }
            if (v43 == 18)
            {
              BOOL v351 = *(void *)v44 == 0x657469736C6C6163 && *(void *)(v44 + 8) == 0x697474696C70732DLL;
              if (v351 && *(_WORD *)(v44 + 16) == 26478) {
                operator new();
              }
            }
            if (v574)
            {
              if (*(void *)v44 == 0x696F6874736E6F63 && *(_WORD *)(v44 + 8) == 29811)
              {
                bzero(v600, 0x15D8uLL);
                v600[16] = &v600[18];
                HIDWORD(v600[17]) = 8;
                long long v632 = 0u;
                int v633 = 0;
                long long v634 = 0u;
                memset(v635, 0, sizeof(v635));
                uint64_t v636 = 0;
                uint64_t v638 = 0;
                uint64_t v637 = 0;
                sub_1CD70AE20((uint64_t)&v639, (uint64_t)v600, v378, v379);
              }
            }
            if (v122)
            {
              if (*(void *)v44 == 0x69617274736E6F63
                && *(void *)(v44 + 8) == 0x696D696C652D746ELL
                && *(void *)(v44 + 14) == 0x6E6F6974616E696DLL)
              {
                operator new();
              }
            }
            else if (v43 == 3)
            {
              if (*(_WORD *)v44 == 26723 && *(unsigned char *)(v44 + 2) == 114)
              {
                sub_1CCAE03E4();
                operator new();
              }
              int v357 = 1;
LABEL_1057:
              if (v574)
              {
                if (*(void *)v44 == 0x696C652D6F726F63 && *(_WORD *)(v44 + 8) == 25956) {
                  operator new();
                }
              }
              if (v124)
              {
                if (*(void *)v44 == 0x656C632D6F726F63 && *(_DWORD *)(v44 + 8) == 1886744161) {
                  operator new();
                }
              }
              if (v122)
              {
                BOOL v360 = *(void *)v44 == 0x74616C6572726F63 && *(void *)(v44 + 8) == 0x61706F72702D6465;
                if (v360 && *(void *)(v44 + 14) == 0x6E6F697461676170) {
                  operator new();
                }
              }
              if (v357)
              {
                if (*(_WORD *)v44 == 25444 && *(unsigned char *)(v44 + 2) == 101) {
                  operator new();
                }
              }
              if (v43 == 18)
              {
                BOOL v363 = *(void *)v44 == 0x706D756A2D616664 && *(void *)(v44 + 8) == 0x696461657268742DLL;
                if (v363 && *(_WORD *)(v44 + 16) == 26478) {
                  operator new();
                }
              }
              if (v570)
              {
                if (*(void *)v44 == 0x2D6D65722D766964 && *(void *)(v44 + 5) == 0x73726961702D6D65) {
                  operator new();
                }
              }
              if (v357)
              {
                if (*(_WORD *)v44 == 29540 && *(unsigned char *)(v44 + 2) == 101) {
                  operator new();
                }
              }
              if (v120)
              {
                if (*(_DWORD *)v44 == 762605412 && *(_DWORD *)(v44 + 3) == 1734763309) {
                  operator new();
                }
              }
              if (v124)
              {
                if (*(void *)v44 == 0x2D6766632D746F64 && *(_DWORD *)(v44 + 8) == 2037149295) {
                  operator new();
                }
              }
              if (v120)
              {
                if (*(_DWORD *)v44 == 762605412 && *(_DWORD *)(v44 + 3) == 1836016685) {
                  operator new();
                }
              }
              if (v124)
              {
                if (*(void *)v44 == 0x2D6D6F642D746F64 && *(_DWORD *)(v44 + 8) == 2037149295) {
                  operator new();
                }
              }
              if (v123)
              {
                if (*(void *)v44 == 0x657272692D786966 && *(void *)(v44 + 7) == 0x656C626963756465) {
                  operator new();
                }
              }
              if (v574)
              {
                if (*(void *)v44 == 0x636E657474616C66 && *(_WORD *)(v44 + 8) == 26470) {
                  operator new();
                }
              }
              if (v569)
              {
                if (*(void *)v44 == 0x6175672D656B616DLL
                  && *(void *)(v44 + 8) == 0x6C7078652D736472
                  && *(_DWORD *)(v44 + 16) == 1953063785)
                {
                  operator new();
                }
              }
              else if (v576)
              {
                if (*(void *)v44 == 0x73696F682D6E7667 && *(unsigned char *)(v44 + 8) == 116) {
                  operator new();
                }
              }
              int v381 = v120;
              if (v568 && *(void *)v44 == 0x6B6E69732D6E7667) {
                operator new();
              }
              if (v574)
              {
                if (*(void *)v44 == 0x726F776F6C6C6568 && *(_WORD *)(v44 + 8) == 25708) {
                  operator new();
                }
              }
              if (v569)
              {
                if (*(void *)v44 == 0x64612D7265666E69
                  && *(void *)(v44 + 8) == 0x70732D7373657264
                  && *(_DWORD *)(v44 + 16) == 1936024417)
                {
                  operator new();
                }
              }
              else if (v572)
              {
                if (*(void *)v44 == 0x626D6F6374736E69 && *(void *)(v44 + 3) == 0x656E69626D6F6374)
                {
                  v600[0] = &v600[2];
                  v600[1] = (void *)0x10000000000;
                  long long v626 = 0u;
                  int v627 = 0;
                  uint64_t v628 = 1;
                  uint64_t v386 = 262;
                  int64x2_t v387 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
                  do
                  {
                    *(int64x2_t *)&v600[v386] = v387;
                    v386 += 2;
                  }
                  while (v386 != 278);
                  v629 = v631;
                  uint64_t v630 = 0x1000000000;
                  v631[32] = dword_1EBD09170;
                  sub_1CD70AEFC();
                }
              }
              else if (v576)
              {
                if (*(void *)v44 == 0x6E756F6374736E69 && *(unsigned char *)(v44 + 8) == 116) {
                  operator new();
                }
              }
              if (v84)
              {
                if (*(void *)v44 == 0x706D697374736E69 && *(_DWORD *)(v44 + 8) == 2036754796) {
                  operator new();
                }
              }
              if (v72)
              {
                if (*(void *)v44 == 0x6164696C61766E69 && *(void *)(v44 + 7) == 0x3E6C6C613C657461) {
                  operator new();
                }
              }
              if (v121 && *(_DWORD *)v44 == 1701016169) {
                operator new();
              }
              if (v576)
              {
                if (*(void *)v44 == 0x6E693274616F6C66 && *(unsigned char *)(v44 + 8) == 116)
                {
                  memset(&v600[18], 0, 56);
                  v600[6] = (void *)1;
                  memset(v600, 0, 48);
                  *(int64x2_t *)&v600[13] = vdupq_n_s64(0xFFFFFFFFFFFFF000);
                  v600[15] = &v600[17];
                  *(_OWORD *)&v600[16] = 0x800000000uLL;
                  memset(&v600[26], 0, 24);
                  v600[25] = &v600[26];
                  memset(v601, 0, 56);
                  sub_1CD70AFCC();
                }
              }
              else if (v573)
              {
                if (*(void *)v44 == 0x75662D706F2D6F6ELL && *(void *)(v44 + 6) == 0x6E6F6974636E7566) {
                  operator new();
                }
              }
              if (v567)
              {
                BOOL v393 = *(void *)v44 == 0x736C6C616362696CLL && *(void *)(v44 + 8) == 0x776B6E697268732DLL;
                if (v393 && *(void *)(v44 + 11) == 0x706172776B6E6972) {
                  operator new();
                }
              }
              if (v121 && *(_DWORD *)v44 == 1953393004) {
                operator new();
              }
              if (v567)
              {
                BOOL v395 = *(void *)v44 == 0x742D7463656A6E69 && *(void *)(v44 + 8) == 0x697070616D2D696CLL;
                if (v395 && *(void *)(v44 + 11) == 0x73676E697070616DLL) {
                  operator new();
                }
              }
              if (v576)
              {
                if (*(void *)v44 == 0x656D616E74736E69 && *(unsigned char *)(v44 + 8) == 114) {
                  operator new();
                }
              }
              else if (v572)
              {
                if (*(void *)v44 == 0x6F74617265776F6CLL && *(void *)(v44 + 3) == 0x63696D6F74617265) {
                  operator new();
                }
              }
              if (v84)
              {
                if (*(void *)v44 == 0x78652D7265776F6CLL && *(_DWORD *)(v44 + 8) == 1952671088) {
                  operator new();
                }
              }
              if (v566)
              {
                BOOL v400 = *(void *)v44 == 0x75672D7265776F6CLL && *(void *)(v44 + 8) == 0x72746E692D647261;
                if (v400 && *(void *)(v44 + 13) == 0x6369736E6972746ELL) {
                  operator new();
                }
              }
              if (HIDWORD(v575))
              {
                if (*(void *)v44 == 0x6F632D7265776F6CLL
                  && *(void *)(v44 + 8) == 0x692D746E6174736ELL
                  && *(void *)(v44 + 16) == 0x6369736E6972746ELL
                  && *(unsigned char *)(v44 + 24) == 115)
                {
                  operator new();
                }
                if (*(void *)v44 == 0x69772D7265776F6CLL
                  && *(void *)(v44 + 8) == 0x2D656C62616E6564
                  && *(void *)(v44 + 16) == 0x6F697469646E6F63
                  && *(unsigned char *)(v44 + 24) == 110)
                {
                  operator new();
                }
              }
              if (v573)
              {
                if (*(void *)v44 == 0x69772D6472617567 && *(void *)(v44 + 6) == 0x676E696E65646977) {
                  operator new();
                }
              }
              if (v566)
              {
                BOOL v409 = *(void *)v44 == 0x6F74732D64616F6CLL && *(void *)(v44 + 8) == 0x6F746365762D6572;
                if (v409 && *(void *)(v44 + 13) == 0x72657A69726F7463) {
                  operator new();
                }
              }
              if (v570)
              {
                if (*(void *)v44 == 0x6D69732D706F6F6CLL && *(void *)(v44 + 5) == 0x7966696C706D6973) {
                  operator new();
                }
              }
              if (v576)
              {
                if (*(void *)v44 == 0x6E69732D706F6F6CLL && *(unsigned char *)(v44 + 8) == 107) {
                  operator new();
                }
              }
              else if (v572)
              {
                if (*(void *)v44 == 0x766E697265776F6CLL && *(void *)(v44 + 3) == 0x656B6F766E697265) {
                  operator new();
                }
                if (*(void *)v44 == 0x6977737265776F6CLL && *(void *)(v44 + 3) == 0x6863746977737265) {
                  operator new();
                }
              }
              if (v120)
              {
                if (*(_DWORD *)v44 == 846030189 && *(_DWORD *)(v44 + 3) == 1734701618) {
                  operator new();
                }
              }
              if (v576)
              {
                if (*(void *)v44 == 0x706F7970636D656DLL && *(unsigned char *)(v44 + 8) == 116) {
                  operator new();
                }
              }
              if (v574)
              {
                if (*(void *)v44 == 0x6D6369656772656DLL && *(_WORD *)(v44 + 8) == 29552) {
                  operator new();
                }
              }
              if (v572)
              {
                if (*(void *)v44 == 0x746572656772656DLL && *(void *)(v44 + 3) == 0x6E72757465726567) {
                  operator new();
                }
              }
              if (v560)
              {
                if (*(void *)v44 == 0x6165722D7972616ELL && *(void *)(v44 + 8) == 0x65746169636F7373)
                {
                  memset(v600, 0, 72);
                  sub_1CD70B08C();
                }
              }
              if (v565)
              {
                if (*(_DWORD *)v44 == 1735877998 && *(_WORD *)(v44 + 4) == 28278) {
                  operator new();
                }
              }
              else if (v573)
              {
                if (*(void *)v44 == 0x7268742D706D756ALL && *(void *)(v44 + 6) == 0x676E696461657268)
                {
                  memset(&v600[5], 0, 18);
                  v600[8] = &v600[10];
                  v600[9] = (void *)0x1000000000;
                  v600[28] = 0;
                  v600[27] = 0;
                  v600[26] = &v600[27];
                  LOBYTE(v601[1]) = byte_1EBD0B538;
                  HIDWORD(v601[0]) = dword_1EBD0B478;
                  sub_1CD70B154();
                }
              }
              if (HIDWORD(v575))
              {
                BOOL v422 = *(void *)v44 == 0x6C6C616974726170 && *(void *)(v44 + 8) == 0x656E696C6E692D79;
                BOOL v423 = v422 && *(void *)(v44 + 16) == 0x6C6C616362696C2DLL;
                if (v423 && *(unsigned char *)(v44 + 24) == 115) {
                  operator new();
                }
              }
              if (v64)
              {
                if (*(_DWORD *)v44 == 1936941932 && *(unsigned char *)(v44 + 4) == 97) {
                  operator new();
                }
              }
              else if (v43 == 18)
              {
                if (*(void *)v44 == 0x7461642D706F6F6CLL
                  && *(void *)(v44 + 8) == 0x7465666572702D61
                  && *(_WORD *)(v44 + 16) == 26723)
                {
                  operator new();
                }
              }
              else if (v573)
              {
                if (*(void *)v44 == 0x616F6C2D706F6F6CLL && *(void *)(v44 + 6) == 0x6D696C652D64616FLL) {
                  operator new();
                }
              }
              else if (v572)
              {
                if (*(void *)v44 == 0x7375662D706F6F6CLL && *(void *)(v44 + 3) == 0x6E6F697375662D70) {
                  operator new();
                }
              }
              if (v72)
              {
                if (*(void *)v44 == 0x7369642D706F6F6CLL && *(void *)(v44 + 7) == 0x6574756269727473) {
                  operator new();
                }
                if (*(void *)v44 == 0x7265762D706F6F6CLL && *(void *)(v44 + 7) == 0x676E696E6F697372) {
                  operator new();
                }
              }
              if (v568 && *(void *)v44 == 0x6372612D636A626FLL) {
                operator new();
              }
              if (v564)
              {
                BOOL v432 = *(void *)v44 == 0x6372612D636A626FLL && *(void *)(v44 + 8) == 0x636172746E6F632DLL;
                if (v432 && *(unsigned char *)(v44 + 16) == 116) {
                  operator new();
                }
              }
              if (v72)
              {
                if (*(void *)v44 == 0x6372612D636A626FLL && *(void *)(v44 + 7) == 0x646E617078652D63) {
                  operator new();
                }
              }
              if (v570)
              {
                if (*(void *)v44 == 0x6F6D656D2D6F6770 && *(void *)(v44 + 5) == 0x74706F2D706F6D65) {
                  operator new();
                }
              }
              if (v64)
              {
                if (*(_DWORD *)v44 == 1852404336 && *(unsigned char *)(v44 + 4) == 116)
                {
                  llvm::dbgs((llvm *)v119);
                  operator new();
                }
              }
              else if (v43 == 18)
              {
                if (*(void *)v44 == 0x73613C746E697270
                  && *(void *)(v44 + 8) == 0x6E6F6974706D7573
                  && *(_WORD *)(v44 + 16) == 15987)
                {
                  llvm::dbgs((llvm *)v119);
                  operator new();
                }
                if (*(void *)v44 == 0x72623C746E697270
                  && *(void *)(v44 + 8) == 0x6F72702D68636E61
                  && *(_WORD *)(v44 + 16) == 15970)
                {
                  llvm::dbgs((llvm *)v119);
                  operator new();
                }
              }
              else if (v564)
              {
                if (*(void *)v44 == 0x6C623C746E697270
                  && *(void *)(v44 + 8) == 0x716572662D6B636FLL
                  && *(unsigned char *)(v44 + 16) == 62)
                {
                  llvm::dbgs((llvm *)v119);
                  operator new();
                }
                if (*(void *)v44 == 0x6F633C746E697270
                  && *(void *)(v44 + 8) == 0x6C65646F6D2D7473
                  && *(unsigned char *)(v44 + 16) == 62)
                {
                  llvm::dbgs((llvm *)v119);
                  operator new();
                }
              }
              if (v570)
              {
                if (*(void *)v44 == 0x79633C746E697270 && *(void *)(v44 + 5) == 0x3E73656C6379633CLL)
                {
                  llvm::dbgs((llvm *)v119);
                  operator new();
                }
              }
              if (v576)
              {
                if (*(void *)v44 == 0x61643C746E697270 && *(unsigned char *)(v44 + 8) == 62)
                {
                  llvm::dbgs((llvm *)v119);
                  operator new();
                }
              }
              else if (v564)
              {
                if (*(void *)v44 == 0x69643C746E697270
                  && *(void *)(v44 + 8) == 0x65636E6567726576
                  && *(unsigned char *)(v44 + 16) == 62)
                {
                  llvm::dbgs((llvm *)v119);
                  operator new();
                }
              }
              else if (v573)
              {
                if (*(void *)v44 == 0x6F643C746E697270 && *(void *)(v44 + 6) == 0x3E656572746D6F64)
                {
                  llvm::dbgs((llvm *)v119);
                  operator new();
                }
              }
              else if (v43 == 18)
              {
                if (*(void *)v44 == 0x6F703C746E697270
                  && *(void *)(v44 + 8) == 0x6572746D6F647473
                  && *(_WORD *)(v44 + 16) == 15973)
                {
                  llvm::dbgs((llvm *)v119);
                  operator new();
                }
                if (*(void *)v44 == 0x6F643C746E697270
                  && *(void *)(v44 + 8) == 0x6569746E6F72666DLL
                  && *(_WORD *)(v44 + 16) == 15986)
                {
                  llvm::dbgs((llvm *)v119);
                  operator new();
                }
                if (*(void *)v44 == 0x6E693C746E697270
                  && *(void *)(v44 + 8) == 0x736F632D656E696CLL
                  && *(_WORD *)(v44 + 16) == 15988)
                {
                  llvm::dbgs((llvm *)v119);
                  operator new();
                }
              }
              else if (v571)
              {
                if (*(void *)v44 == 0x65643C746E697270
                  && *(void *)(v44 + 8) == 0x7A697261656E696CLL
                  && *(void *)(v44 + 14) == 0x3E6E6F6974617A69)
                {
                  llvm::dbgs((llvm *)v119);
                  operator new();
                }
                if (*(void *)v44 == 0x75663C746E697270
                  && *(void *)(v44 + 8) == 0x65706F72702D636ELL
                  && *(void *)(v44 + 14) == 0x3E73656974726570)
                {
                  llvm::dbgs((llvm *)v119);
                  operator new();
                }
              }
              else if (v569)
              {
                BOOL v460 = *(void *)v44 == 0x65643C746E697270 && *(void *)(v44 + 8) == 0x622D6465646E616DLL;
                if (v460 && *(_DWORD *)(v44 + 16) == 1047753833)
                {
                  llvm::dbgs((llvm *)v119);
                  operator new();
                }
              }
              if (v83)
              {
                BOOL v462 = *(void *)v44 == 0x6E693C746E697270 && *(void *)(v44 + 8) == 0x69732D72656E696CLL;
                BOOL v463 = v462 && *(void *)(v44 + 16) == 0x6D697473652D657ALL;
                if (v463 && *(void *)(v44 + 21) == 0x3E726F74616D6974)
                {
                  llvm::dbgs((llvm *)v119);
                  operator new();
                }
              }
              if (v575)
              {
                BOOL v465 = *(void *)v44 == 0x70673C746E697270 && *(void *)(v44 + 8) == 0x6974636E75662D75;
                BOOL v466 = v465 && *(void *)(v44 + 16) == 0x796C616E612D6E6FLL;
                if (v466 && *(_DWORD *)(v44 + 24) == 1047751027)
                {
                  llvm::dbgs((llvm *)v119);
                  operator new();
                }
              }
              if (v84)
              {
                if (*(void *)v44 == 0x6F6C3C746E697270 && *(_DWORD *)(v44 + 8) == 1047752815)
                {
                  llvm::dbgs((llvm *)v119);
                  operator new();
                }
              }
              if (v560)
              {
                if (*(void *)v44 == 0x656D3C746E697270 && *(void *)(v44 + 8) == 0x3E61737379726F6DLL)
                {
                  llvm::dbgs((llvm *)v119);
                  operator new();
                }
              }
              if (v563)
              {
                BOOL v470 = *(void *)v44 == 0x656D3C746E697270 && *(void *)(v44 + 8) == 0x2D61737379726F6DLL;
                if (v470 && *(void *)(v44 + 15) == 0x3E72656B6C61772DLL)
                {
                  llvm::dbgs((llvm *)v119);
                  operator new();
                }
              }
              if (v564)
              {
                if (*(void *)v44 == 0x68703C746E697270
                  && *(void *)(v44 + 8) == 0x7365756C61762D69
                  && *(unsigned char *)(v44 + 16) == 62)
                {
                  llvm::dbgs((llvm *)v119);
                  operator new();
                }
              }
              else if (v573)
              {
                if (*(void *)v44 == 0x65723C746E697270 && *(void *)(v44 + 6) == 0x3E736E6F69676572)
                {
                  llvm::dbgs((llvm *)v119);
                  operator new();
                }
              }
              if (v563)
              {
                BOOL v475 = *(void *)v44 == 0x63733C746E697270 && *(void *)(v44 + 8) == 0x6F76652D72616C61;
                if (v475 && *(void *)(v44 + 15) == 0x3E6E6F6974756C6FLL)
                {
                  llvm::dbgs((llvm *)v119);
                  operator new();
                }
              }
              if (HIDWORD(v575))
              {
                BOOL v477 = *(void *)v44 == 0x74733C746E697270 && *(void *)(v44 + 8) == 0x656661732D6B6361;
                BOOL v478 = v477 && *(void *)(v44 + 16) == 0x6C61636F6C2D7974;
                if (v478 && *(unsigned char *)(v44 + 24) == 62)
                {
                  llvm::dbgs((llvm *)v119);
                  operator new();
                }
              }
              if (v560)
              {
                if (*(void *)v44 == 0x6C612D746E697270 && *(void *)(v44 + 8) == 0x737465732D736169)
                {
                  llvm::dbgs((llvm *)v119);
                  operator new();
                }
              }
              if (v567)
              {
                BOOL v481 = *(void *)v44 == 0x72702D746E697270 && *(void *)(v44 + 8) == 0x6965746163696465;
                if (v481 && *(void *)(v44 + 11) == 0x6F666E6965746163)
                {
                  llvm::dbgs((llvm *)v119);
                  operator new();
                }
              }
              if (v564)
              {
                BOOL v483 = *(void *)v44 == 0x756D2D746E697270 && *(void *)(v44 + 8) == 0x7475636578657473;
                if (v483 && *(unsigned char *)(v44 + 16) == 101)
                {
                  llvm::dbgs((llvm *)v119);
                  operator new();
                }
              }
              if (v72)
              {
                if (*(void *)v44 == 0x656D2D746E697270 && *(void *)(v44 + 7) == 0x7366657265646D65)
                {
                  llvm::dbgs((llvm *)v119);
                  operator new();
                }
              }
              if (v572)
              {
                if (*(void *)v44 == 0x69636F7373616572 && *(void *)(v44 + 3) == 0x65746169636F7373)
                {
                  bzero(v600, 0x230uLL);
                  for (uint64_t i = 15; i != 69; i += 3)
                  {
                    v521 = &v600[i];
                    *v521 = 0;
                    v521[1] = 0;
                    *((_DWORD *)v521 + 4) = 0;
                  }
                  sub_1CD70B298();
                }
              }
              if (v563)
              {
                BOOL v487 = *(void *)v44 == 0x6E61646E75646572 && *(void *)(v44 + 8) == 0x6E692D6762642D74;
                if (v487 && *(void *)(v44 + 15) == 0x6D696C652D74736ELL) {
                  operator new();
                }
              }
              if (v120)
              {
                if (*(_DWORD *)v44 == 845636978 && *(_DWORD *)(v44 + 3) == 1835363634) {
                  operator new();
                }
              }
              if (v562)
              {
                BOOL v490 = *(void *)v44 == 0x7A6972616C616373 && *(void *)(v44 + 8) == 0x64656B73616D2D65;
                BOOL v491 = v490 && *(void *)(v44 + 16) == 0x746E692D6D656D2DLL;
                if (v491 && *(void *)(v44 + 19) == 0x6E6972746E692D6DLL) {
                  operator new();
                }
              }
              if (v574)
              {
                if (*(void *)v44 == 0x7A6972616C616373 && *(_WORD *)(v44 + 8) == 29285) {
                  operator new();
                }
              }
              if (v43 == 30)
              {
                BOOL v494 = *(void *)v44 == 0x6574617261706573 && *(void *)(v44 + 8) == 0x6F2D74736E6F632DLL;
                BOOL v495 = v494 && *(void *)(v44 + 16) == 0x72662D7465736666;
                if (v495 && *(void *)(v44 + 22) == 0x7065672D6D6F7266) {
                  operator new();
                }
              }
              if (v121)
              {
                if (*(_DWORD *)v44 == 1885561715) {
                  operator new();
                }
                if (*(_DWORD *)v44 == 1802398067) {
                  operator new();
                }
              }
              if (v573)
              {
                if (*(void *)v44 == 0x746365762D706C73 && *(void *)(v44 + 6) == 0x72657A69726F7463)
                {
                  memset(v600, 0, 168);
                  sub_1CD70B32C();
                }
              }
              if (v121 && *(_DWORD *)v44 == 1920167027) {
                operator new();
              }
              if (v566)
              {
                BOOL v498 = *(void *)v44 == 0x74616C7563657073 && *(void *)(v44 + 8) == 0x636578652D657669;
                if (v498 && *(void *)(v44 + 13) == 0x6E6F697475636578) {
                  operator new();
                }
              }
              if (v121 && *(_DWORD *)v44 == 1634693747)
              {
                bzero(v600, 0x2C0uLL);
                v600[6] = &v600[8];
                HIDWORD(v600[7]) = 16;
                v600[24] = &v600[26];
                HIDWORD(v600[25]) = 8;
                *(_OWORD *)v613 = 0u;
                LODWORD(v614) = 0;
                v615 = v618;
                int v617 = 16;
                memset(&v618[128], 0, 44);
                v619 = v621;
                int v620 = 2;
                v621[1] = 0u;
                int v622 = 0;
                v623 = &v625;
                int v624 = 2;
                sub_1CD70B47C();
              }
              if (v43 == 18)
              {
                if (*(void *)v44 == 0x63672D7069727473
                  && *(void *)(v44 + 8) == 0x7461636F6C65722DLL
                  && *(_WORD *)(v44 + 16) == 29541)
                {
                  operator new();
                }
              }
              else if (v573)
              {
                if (*(void *)v44 == 0x7275746375727473 && *(void *)(v44 + 6) == 0x676663657A697275) {
                  operator new();
                }
              }
              if (v84)
              {
                if (*(void *)v44 == 0x6C6C61636C696174 && *(_DWORD *)(v44 + 8) == 1835625573) {
                  operator new();
                }
              }
              if (v560)
              {
                if (*(void *)v44 == 0x6F6C2D7966696E75 && *(void *)(v44 + 8) == 0x73746978652D706FLL) {
                  operator new();
                }
              }
              if (v573)
              {
                if (*(void *)v44 == 0x632D726F74636576 && *(void *)(v44 + 6) == 0x656E69626D6F632DLL) {
                  operator new();
                }
              }
              else if (v565)
              {
                if (*(_DWORD *)v44 == 1769104758 && *(_WORD *)(v44 + 4) == 31078) {
                  operator new();
                }
              }
              if (v72)
              {
                if (*(void *)v44 == 0x643C796669726576 && *(void *)(v44 + 7) == 0x3E656572746D6F64) {
                  operator new();
                }
              }
              if (v570)
              {
                if (*(void *)v44 == 0x6C3C796669726576 && *(void *)(v44 + 5) == 0x3E73706F6F6C3C79) {
                  operator new();
                }
              }
              if (v564)
              {
                BOOL v509 = *(void *)v44 == 0x6D3C796669726576 && *(void *)(v44 + 8) == 0x61737379726F6D65;
                if (v509 && *(unsigned char *)(v44 + 16) == 62) {
                  operator new();
                }
              }
              if (v72)
              {
                if (*(void *)v44 == 0x723C796669726576 && *(void *)(v44 + 7) == 0x3E736E6F69676572) {
                  operator new();
                }
              }
              if (v569)
              {
                BOOL v512 = *(void *)v44 == 0x733C796669726576 && *(void *)(v44 + 8) == 0x746E696F70656661;
                if (v512 && *(_DWORD *)(v44 + 16) == 1047685421) {
                  operator new();
                }
              }
              if (v561)
              {
                BOOL v514 = *(void *)v44 == 0x733C796669726576 && *(void *)(v44 + 8) == 0x76652D72616C6163;
                if (v514 && *(void *)(v44 + 16) == 0x3E6E6F6974756C6FLL) {
                  operator new();
                }
              }
              if (v568 && *(void *)v44 == 0x6766632D77656976) {
                operator new();
              }
              if (v570)
              {
                if (*(void *)v44 == 0x6766632D77656976 && *(void *)(v44 + 5) == 0x796C6E6F2D676663) {
                  operator new();
                }
              }
              if (v568 && *(void *)v44 == 0x7473696F68736C74)
              {
                memset(v600, 0, 64);
                sub_1CD70B53C();
              }
              if (v564)
              {
                BOOL v517 = *(void *)v44 == 0x726F66736E617274 && *(void *)(v44 + 8) == 0x6E696E7261772D6DLL;
                if (v517 && *(unsigned char *)(v44 + 16) == 103) {
                  operator new();
                }
              }
              if (v121 && *(_DWORD *)v44 == 1851880308) {
                operator new();
              }
              if (v120)
              {
                if (*(_DWORD *)v44 == 1886217581 && *(_DWORD *)(v44 + 3) == 1718579824) {
                  operator new();
                }
              }
              if (sub_1CCC9F0D4((char *)v44, v43, "early-cse", 9uLL))
              {
                sub_1CCC9F164((int)v600, (uint64_t (*)(char *, size_t))sub_1CCC9F28C, (char *)v44, v43, "early-cse", 9uLL);
                if (((uint64_t)v600[1] & 1) == 0) {
                  operator new();
                }
              }
              else if (sub_1CCC9F0D4((char *)v44, v43, "ee-instrument", 0xDuLL))
              {
                sub_1CCC9F164((int)v600, (uint64_t (*)(char *, size_t))sub_1CCC9F2B4, (char *)v44, v43, "ee-instrument", 0xDuLL);
                if (((uint64_t)v600[1] & 1) == 0) {
                  operator new();
                }
              }
              else if (sub_1CCC9F0D4((char *)v44, v43, "lower-matrix-intrinsics", 0x17uLL))
              {
                sub_1CCC9F164((int)v600, (uint64_t (*)(char *, size_t))sub_1CCC9F2DC, (char *)v44, v43, "lower-matrix-intrinsics", 0x17uLL);
                if (((uint64_t)v600[1] & 1) == 0) {
                  operator new();
                }
              }
              else if (sub_1CCC9F0D4((char *)v44, v43, "loop-unroll", 0xBuLL))
              {
                sub_1CCC9F304((unint64_t)v600, (void *)v44, v43, v522);
                if (((uint64_t)v600[4] & 1) == 0) {
                  operator new();
                }
              }
              else if (sub_1CCC9F0D4((char *)v44, v43, "msan", 4uLL))
              {
                sub_1CCC9F844((uint64_t)v600, (_DWORD *)v44, v43);
                if (((uint64_t)v600[2] & 1) == 0) {
                  operator new();
                }
              }
              else if (sub_1CCC9F0D4((char *)v44, v43, "simplifycfg", 0xBuLL))
              {
                sub_1CCC9FBCC((unint64_t)v600, (void *)v44, v43);
                if (((uint64_t)v600[3] & 1) == 0)
                {
                  long long v639 = *(_OWORD *)v600;
                  v640 = (long long *)v600[2];
                  sub_1CCEDA240((uint64_t)&v639);
                  operator new();
                }
              }
              else if (sub_1CCC9F0D4((char *)v44, v43, "loop-vectorize", 0xEuLL))
              {
                sub_1CCCA0278((unint64_t)v600, (void *)v44, v43);
                if (((uint64_t)v600[1] & 1) == 0) {
                  operator new();
                }
              }
              else
              {
                if (!sub_1CCC9F0D4((char *)v44, v43, "mldst-motion", 0xCuLL))
                {
                  if (sub_1CCC9F0D4((char *)v44, v43, "gvn", 3uLL))
                  {
                    sub_1CCCA07D0((unint64_t)&v639, (unsigned char *)v44, v43);
                    if ((v640 & 1) == 0)
                    {
                      sub_1CD719FAC((uint64_t)v600, v639, SWORD4(v639));
                      sub_1CD70B614();
                    }
                  }
                  else
                  {
                    BOOL v523 = sub_1CCC9F0D4((char *)v44, v43, "print<stack-lifetime>", 0x15uLL);
                    if (v523)
                    {
                      v524 = (llvm *)sub_1CCCA0B9C((unint64_t)v600, (void *)v44, v43);
                      if (((uint64_t)v600[1] & 1) == 0)
                      {
                        llvm::dbgs(v524);
                        operator new();
                      }
                      goto LABEL_210;
                    }
                    if (v84)
                    {
                      if (*(void *)v44 == 0x616C662D706F6F6CLL && *(_DWORD *)(v44 + 8) == 1852142708) {
                        sub_1CD70B7B4();
                      }
                    }
                    if (v560)
                    {
                      if (*(void *)v44 == 0x746E692D706F6F6CLL && *(void *)(v44 + 8) == 0x65676E6168637265) {
                        sub_1CD70B8D8();
                      }
                    }
                    if (v567)
                    {
                      BOOL v527 = *(void *)v44 == 0x726E752D706F6F6CLL && *(void *)(v44 + 8) == 0x2D646E612D6C6C6FLL;
                      if (v527 && *(void *)(v44 + 11) == 0x6D616A2D646E612DLL)
                      {
                        LODWORD(__p) = 2;
                        sub_1CD70B9FC();
                      }
                    }
                    if (v573)
                    {
                      if (*(void *)v44 == 0x6F6C2D706F2D6F6ELL && *(void *)(v44 + 6) == 0x7473656E706F6F6CLL) {
                        sub_1CCCA0E44();
                      }
                    }
                    if (v84)
                    {
                      if (*(void *)v44 == 0x72662D6E6F6E6163 && *(_DWORD *)(v44 + 8) == 1702520165) {
                        sub_1CD70BB40();
                      }
                    }
                    if (v381)
                    {
                      if (*(_DWORD *)v44 == 762605412 && *(_DWORD *)(v44 + 3) == 1734632493) {
                        sub_1CD70BBC4();
                      }
                    }
                    if (v72)
                    {
                      if (*(void *)v44 == 0x6164696C61766E69 && *(void *)(v44 + 7) == 0x3E6C6C613C657461) {
                        sub_1CD70BC48();
                      }
                    }
                    if (v574)
                    {
                      if (*(void *)v44 == 0x6964692D706F6F6CLL && *(_WORD *)(v44 + 8) == 28015) {
                        sub_1CD70BCCC();
                      }
                    }
                    if (v564)
                    {
                      if (*(void *)v44 == 0x736E692D706F6F6CLL
                        && *(void *)(v44 + 8) == 0x66696C706D697374
                        && *(unsigned char *)(v44 + 16) == 121)
                      {
                        sub_1CD70BD50();
                      }
                    }
                    else if (v572)
                    {
                      if (*(void *)v44 == 0x746F722D706F6F6CLL && *(void *)(v44 + 3) == 0x657461746F722D70)
                      {
                        LOWORD(__p) = 1;
                        sub_1CD70BDD4();
                      }
                    }
                    if (v574)
                    {
                      if (*(void *)v44 == 0x6F6C2D706F2D6F6ELL && *(_WORD *)(v44 + 8) == 28783) {
                        operator new();
                      }
                    }
                    if (v64)
                    {
                      if (*(_DWORD *)v44 == 1852404336 && *(unsigned char *)(v44 + 4) == 116)
                      {
                        long long v639 = (unint64_t)llvm::dbgs((llvm *)v523);
                        HIBYTE(v641) = 0;
                        sub_1CD70BE90();
                      }
                    }
                    if (v570)
                    {
                      if (*(void *)v44 == 0x6C65642D706F6F6CLL && *(void *)(v44 + 5) == 0x6E6F6974656C6564) {
                        sub_1CD70BF40();
                      }
                    }
                    if (v560)
                    {
                      if (*(void *)v44 == 0x6D69732D706F6F6CLL && *(void *)(v44 + 8) == 0x6766637966696C70) {
                        sub_1CD70BFC4();
                      }
                    }
                    if (v572)
                    {
                      if (*(void *)v44 == 0x6465722D706F6F6CLL && *(void *)(v44 + 3) == 0x6563756465722D70) {
                        sub_1CD70C048();
                      }
                    }
                    if (v381)
                    {
                      if (*(_DWORD *)v44 == 1986293353 && *(_DWORD *)(v44 + 3) == 1936875894)
                      {
                        LOBYTE(__p) = 1;
                        sub_1CD70C0CC();
                      }
                    }
                    if (v560)
                    {
                      if (*(void *)v44 == 0x726E752D706F6F6CLL && *(void *)(v44 + 8) == 0x6C6C75662D6C6C6FLL)
                      {
                        LODWORD(__p) = 2;
                        WORD2(__p) = 0;
                        sub_1CD70C15C();
                      }
                    }
                    if (v564)
                    {
                      BOOL v544 = *(void *)v44 == 0x63612D746E697270 && *(void *)(v44 + 8) == 0x666E692D73736563;
                      if (v544 && *(unsigned char *)(v44 + 16) == 111)
                      {
                        std::string __p = llvm::dbgs((llvm *)v523);
                        sub_1CD70C1E8();
                      }
                    }
                    if (v574)
                    {
                      if (*(void *)v44 == 0x64643C746E697270 && *(_WORD *)(v44 + 8) == 15975)
                      {
                        std::string __p = llvm::dbgs((llvm *)v523);
                        sub_1CD70C274();
                      }
                    }
                    if (v72)
                    {
                      if (*(void *)v44 == 0x76693C746E697270 && *(void *)(v44 + 7) == 0x3E73726573752D76)
                      {
                        std::string __p = llvm::dbgs((llvm *)v523);
                        sub_1CD70C300();
                      }
                      if (*(void *)v44 == 0x6F6C3C746E697270 && *(void *)(v44 + 7) == 0x3E7473656E706F6FLL)
                      {
                        std::string __p = llvm::dbgs((llvm *)v523);
                        sub_1CD70C38C();
                      }
                    }
                    if (v571)
                    {
                      BOOL v549 = *(void *)v44 == 0x6F6C3C746E697270 && *(void *)(v44 + 8) == 0x65686361632D706FLL;
                      if (v549 && *(void *)(v44 + 14) == 0x3E74736F632D6568)
                      {
                        std::string __p = llvm::dbgs((llvm *)v523);
                        sub_1CD70C418();
                      }
                    }
                    if (v560)
                    {
                      if (*(void *)v44 == 0x6572702D706F6F6CLL && *(void *)(v44 + 8) == 0x6E6F697461636964) {
                        sub_1CD70C4A4();
                      }
                    }
                    if (v573)
                    {
                      if (*(void *)v44 == 0x69772D6472617567 && *(void *)(v44 + 6) == 0x676E696E65646977) {
                        sub_1CD70C528();
                      }
                    }
                    if (v560)
                    {
                      if (*(void *)v44 == 0x756F622D706F6F6CLL && *(void *)(v44 + 8) == 0x74696C70732D646ELL) {
                        sub_1CD70C5AC();
                      }
                    }
                    if (v572)
                    {
                      if (*(void *)v44 == 0x7265722D706F6F6CLL && *(void *)(v44 + 3) == 0x6C6C6F7265722D70) {
                        sub_1CD70C630();
                      }
                    }
                    else if (v569)
                    {
                      BOOL v555 = *(void *)v44 == 0x7265762D706F6F6CLL && *(void *)(v44 + 8) == 0x2D676E696E6F6973;
                      if (v555 && *(_DWORD *)(v44 + 16) == 1835231596) {
                        sub_1CD70C6B4();
                      }
                    }
                    if (sub_1CCC9F0D4((char *)v44, v43, "simple-loop-unswitch", 0x14uLL))
                    {
                      sub_1CCCA0FD8((unint64_t)&v639, v44, v43);
                      if ((BYTE8(v639) & 1) == 0)
                      {
                        LOWORD(v595) = v639 & 0x101;
                        sub_1CD70C738();
                      }
                    }
                    else if (sub_1CCC9F0D4((char *)v44, v43, "licm", 4uLL))
                    {
                      sub_1CCCA12F0((unint64_t)&v639, (unsigned char *)v44, v43, "licm", 4uLL);
                      if ((v640 & 1) == 0)
                      {
                        std::string __p = (void *)v639;
                        LODWORD(v594) = DWORD2(v639);
                        sub_1CD70C7C8();
                      }
                    }
                    else
                    {
                      if (!sub_1CCC9F0D4((char *)v44, v43, "lnicm", 5uLL))
                      {
                        uint64_t v557 = *(unsigned int *)(v10 + 1192);
                        if (v557)
                        {
                          v558 = (uint64_t *)(*(void *)(v10 + 1184) + 24);
                          uint64_t v559 = 32 * v557;
                          while (!sub_1CCC9EB34(*v558, *v7, v7[1], (uint64_t)v9, v7[2], 0xCCCCCCCCCCCCCCCDLL * ((v7[3] - v7[2]) >> 3)))
                          {
                            v558 += 4;
                            v559 -= 32;
                            if (!v559) {
                              goto LABEL_2206;
                            }
                          }
                          goto LABEL_2016;
                        }
LABEL_2206:
                        uint64_t v94 = "unknown module pass '{0}'";
                        uint64_t v95 = 25;
                        goto LABEL_134;
                      }
                      sub_1CCCA12F0((unint64_t)&v639, (unsigned char *)v44, v43, "lnicm", 5uLL);
                      if ((v640 & 1) == 0)
                      {
                        std::string __p = (void *)v639;
                        LODWORD(v594) = DWORD2(v639);
                        sub_1CD70C888();
                      }
                    }
                  }
                  v125 = (void *)v639;
                  goto LABEL_211;
                }
                sub_1CCC9F164((int)v600, (uint64_t (*)(char *, size_t))sub_1CCCA05B8, (char *)v44, v43, "mldst-motion", 0xCuLL);
                if (((uint64_t)v600[1] & 1) == 0) {
                  operator new();
                }
              }
LABEL_210:
              v125 = v600[0];
LABEL_211:
              *__darwin_ct_rune_t v12 = v125;
              return;
            }
            int v357 = 0;
            goto LABEL_1057;
          }
        }
        else
        {
          int v121 = v573;
          int v122 = v571;
          int v124 = v84;
          if (v43 != 7)
          {
            int v123 = v72;
            if (v43 == 18)
            {
              if (*(void *)v44 == 0x637369642D646461
                && *(void *)(v44 + 8) == 0x6F74616E696D6972
                && *(_WORD *)(v44 + 16) == 29554)
              {
                operator new();
              }
            }
            else if (v571)
            {
              if (*(void *)v44 == 0x6973736572676761
                && *(void *)(v44 + 8) == 0x6374736E692D6576
                && *(void *)(v44 + 14) == 0x656E69626D6F6374)
              {
                operator new();
              }
            }
            else
            {
              if (!v573)
              {
                int v120 = 0;
                if (!v72) {
                  goto LABEL_993;
                }
                goto LABEL_989;
              }
              if (*(void *)v44 == 0x622D656D75737361 && *(void *)(v44 + 6) == 0x7265646C6975622DLL) {
                operator new();
              }
            }
            int v120 = 0;
            int v121 = 0;
            if (!v72) {
              goto LABEL_993;
            }
            goto LABEL_989;
          }
          BOOL v126 = *(_DWORD *)v44 == 1697472865 && *(_DWORD *)(v44 + 3) == 1818326629;
          int v123 = v72;
          if (v126)
          {
            memset(v600, 0, 104);
            sub_1CD70AD5C();
          }
          int v121 = 0;
          int v120 = 1;
          if (!v72) {
            goto LABEL_993;
          }
        }
LABEL_989:
        if (*(void *)v44 == 0x732D656D75737361 && *(void *)(v44 + 7) == 0x7966696C706D6973) {
          operator new();
        }
        goto LABEL_993;
      }
      if (v43 >= 0xB)
      {
        if (*(void *)v44 != 0x646F6D2D6E617361 || *(void *)(v44 + 3) != 0x656C75646F6D2D6ELL) {
          goto LABEL_310;
        }
        v44 += 11;
        v43 -= 11;
      }
      if (!v43) {
        goto LABEL_312;
      }
LABEL_310:
      if (*(unsigned char *)v44 == 60)
      {
        if (v43 == 1) {
          goto LABEL_312;
        }
        v332 = (char *)(v44 + 1);
        if (*(unsigned char *)(v44 + v43 - 1) == 62)
        {
          if (v43 - 1 >= v43 - 2) {
            v43 -= 2;
          }
          else {
            --v43;
          }
          std::string __p = (void *)(v44 + 1);
          unint64_t v594 = v43;
          if (v43)
          {
            ++v44;
LABEL_959:
            while (1)
            {
              LOBYTE(v600[0]) = 59;
              unint64_t v333 = llvm::StringRef::find((uint64_t *)&__p, (char *)v600, 1uLL, 0);
              unint64_t v334 = v43 >= v333 ? v333 : v43;
              uint64_t v335 = v43 >= v333 + 1 ? v333 + 1 : v43;
              v336 = &v332[v335];
              unint64_t v337 = v43 - v335;
              v338 = v333 == -1 ? (char *)v44 : v332;
              if (v333 == -1)
              {
                unint64_t v334 = v43;
                v332 = 0;
              }
              else
              {
                v332 = v336;
              }
              v595 = v338;
              unint64_t v596 = v334;
              unint64_t v43 = v333 == -1 ? 0 : v337;
              std::string __p = v332;
              unint64_t v594 = v43;
              if (v334 != 6) {
                break;
              }
              int v339 = *(_DWORD *)v338;
              int v340 = *((unsigned __int16 *)v338 + 2);
              if (v339 != 1852990827 || v340 != 27749) {
                break;
              }
              uint64_t v44 = (uint64_t)v332;
              if (!v43)
              {
                uint64_t v160 = 0x100000001;
LABEL_982:
                v600[0] = (void *)v160;
                v600[1] = (void *)0x100000001;
                sub_1CD70ACC4();
              }
            }
            v375 = "invalid AddressSanitizer pass parameter '{0}' ";
            uint64_t v376 = 46;
LABEL_1147:
            v600[0] = (void *)v375;
            v600[1] = (void *)v376;
            v600[2] = &v600[6];
            v600[3] = (void *)1;
            v600[4] = &unk_1F2617F90;
            v600[5] = &v595;
            v600[6] = &v600[4];
            sub_1CD465B2C((uint64_t)v600, &v597);
            llvm::inconvertibleErrorCode(v377);
            operator new();
          }
LABEL_312:
          uint64_t v160 = 0x100000000;
          goto LABEL_982;
        }
        ++v44;
        --v43;
      }
      else
      {
        v332 = (char *)v44;
      }
      std::string __p = (void *)v44;
      unint64_t v594 = v43;
      goto LABEL_959;
    }
    if (v43 >= 6)
    {
      if (*(_DWORD *)v44 != 1935767400 || *(_WORD *)(v44 + 4) != 28257) {
        goto LABEL_299;
      }
      v44 += 6;
      v43 -= 6;
    }
    if (!v43)
    {
LABEL_301:
      unsigned __int8 v157 = 0;
      __int16 v158 = 0;
LABEL_955:
      BYTE2(v600[0]) = 0;
      LOWORD(v600[0]) = v157 | (unsigned __int16)(v158 << 8);
      sub_1CD70AC1C();
    }
LABEL_299:
    if (*(unsigned char *)v44 == 60)
    {
      if (v43 == 1) {
        goto LABEL_301;
      }
      v319 = (char *)(v44 + 1);
      if (*(unsigned char *)(v44 + v43 - 1) == 62)
      {
        if (v43 - 1 >= v43 - 2) {
          v43 -= 2;
        }
        else {
          --v43;
        }
        std::string __p = (void *)(v44 + 1);
        unint64_t v594 = v43;
        if (!v43) {
          goto LABEL_301;
        }
        ++v44;
LABEL_924:
        __int16 v158 = 0;
        unsigned __int8 v157 = 0;
        while (1)
        {
          LOBYTE(v600[0]) = 59;
          unint64_t v320 = llvm::StringRef::find((uint64_t *)&__p, (char *)v600, 1uLL, 0);
          if (v43 >= v320) {
            unint64_t v321 = v320;
          }
          else {
            unint64_t v321 = v43;
          }
          if (v43 >= v320 + 1) {
            unint64_t v322 = v320 + 1;
          }
          else {
            unint64_t v322 = v43;
          }
          v323 = &v319[v322];
          unint64_t v324 = v43 - v322;
          if (v320 == -1) {
            v325 = (char *)v44;
          }
          else {
            v325 = v319;
          }
          if (v320 == -1)
          {
            unint64_t v321 = v43;
            v319 = 0;
          }
          else
          {
            v319 = v323;
          }
          v595 = v325;
          unint64_t v596 = v321;
          if (v320 == -1) {
            unint64_t v43 = 0;
          }
          else {
            unint64_t v43 = v324;
          }
          std::string __p = v319;
          unint64_t v594 = v43;
          if (v321 == 6)
          {
            int v329 = *(_DWORD *)v325;
            int v330 = *((unsigned __int16 *)v325 + 2);
            if (v329 != 1852990827 || v330 != 27749)
            {
LABEL_1146:
              v375 = "invalid HWAddressSanitizer pass parameter '{0}' ";
              uint64_t v376 = 48;
              goto LABEL_1147;
            }
            unsigned __int8 v157 = 1;
          }
          else
          {
            if (v321 != 7) {
              goto LABEL_1146;
            }
            int v326 = *(_DWORD *)v325;
            int v327 = *(_DWORD *)(v325 + 3);
            if (v326 != 1868785010 || v327 != 1919252079) {
              goto LABEL_1146;
            }
            __int16 v158 = 1;
          }
          uint64_t v44 = (uint64_t)v319;
          if (!v43) {
            goto LABEL_955;
          }
        }
      }
      ++v44;
      --v43;
    }
    else
    {
      v319 = (char *)v44;
    }
    std::string __p = (void *)v44;
    unint64_t v594 = v43;
    goto LABEL_924;
  }
  if (v14)
  {
    std::string::size_type v15 = (uint64_t *)(v13 + 24);
    uint64_t v16 = 32 * v14;
    while (!sub_1CCC9EB34(*v15, *v7, v7[1], (uint64_t)v9, v7[2], 0xCCCCCCCCCCCCCCCDLL * ((v7[3] - v7[2]) >> 3)))
    {
      v15 += 4;
      v16 -= 32;
      if (!v16) {
        goto LABEL_6;
      }
    }
    goto LABEL_2016;
  }
LABEL_6:
  uint64_t v17 = *v7;
  int64_t v18 = v7[1];
  if (v18 > 7)
  {
    if (v18 == 8)
    {
      if (*(void *)v17 != 0x6E6F6974636E7566)
      {
LABEL_128:
        unint64_t v90 = sub_1CCC9ECD8((_DWORD *)v17, v18, v5, v6);
        if (HIDWORD(v90))
        {
          int v98 = v90;
          v640 = 0;
          long long v99 = 0uLL;
          long long v639 = 0u;
          uint64_t v100 = v7[2];
          uint64_t v101 = v7[3] - v100;
          if (v101)
          {
            uint64_t v102 = 40 * (v101 / 40);
            do
            {
              llvm::PassBuilder::parseModulePass(v10, &v639, v100);
              if (*v12) {
                goto LABEL_142;
              }
              v100 += 40;
              v102 -= 40;
            }
            while (v102);
            long long v99 = v639;
            uint64_t v101 = (uint64_t)v640;
          }
          *__darwin_ct_rune_t v12 = 0;
          LODWORD(v600[0]) = v98;
          *(_OWORD *)&v600[1] = v99;
          v600[3] = (void *)v101;
          v640 = 0;
          long long v639 = 0uLL;
          sub_1CD7071E4();
        }
        uint64_t v91 = *(unsigned int *)(v10 + 1192);
        if (v91)
        {
          uint64_t v92 = (uint64_t *)(*(void *)(v10 + 1184) + 24);
          uint64_t v93 = 32 * v91;
          while (!sub_1CCC9EB34(*v92, *v7, v7[1], (uint64_t)v9, v7[2], 0xCCCCCCCCCCCCCCCDLL * ((v7[3] - v7[2]) >> 3)))
          {
            v92 += 4;
            v93 -= 32;
            if (!v93) {
              goto LABEL_133;
            }
          }
LABEL_2016:
          *__darwin_ct_rune_t v12 = 0;
          return;
        }
LABEL_133:
        uint64_t v94 = "invalid use of '{0}' pass as module pipeline";
        uint64_t v95 = 44;
LABEL_134:
        v600[0] = (void *)v94;
        v600[1] = (void *)v95;
        v600[2] = &v600[6];
        v600[3] = (void *)1;
        v600[4] = &unk_1F2635860;
        v600[5] = v7;
        v600[6] = &v600[4];
        sub_1CD465B2C((uint64_t)v600, &v639);
        v597 = (void *)llvm::inconvertibleErrorCode(v96);
        uint64_t v598 = v97;
        sub_1CCC9EDCC();
      }
    }
    else
    {
      if (v18 != 19) {
        goto LABEL_128;
      }
      BOOL v50 = *(void *)v17 == 0x6E6F6974636E7566 && *(void *)(v17 + 8) == 0x692D72656761653CLL;
      if (!v50 || *(void *)(v17 + 11) != 0x3E766E692D726567) {
        goto LABEL_128;
      }
    }
    memset(v600, 0, 24);
    uint64_t v106 = v7[2];
    uint64_t v107 = v7[3] - v106;
    if (!v107)
    {
LABEL_161:
      *__darwin_ct_rune_t v12 = 0;
      sub_1CCC9EC34();
    }
    uint64_t v108 = 40 * (v107 / 40);
    while (1)
    {
      llvm::PassBuilder::parseFunctionPass(v10, (uint64_t)v600, v106, (uint64_t)v6);
      if (*v12) {
        break;
      }
      v106 += 40;
      v108 -= 40;
      if (!v108) {
        goto LABEL_161;
      }
    }
    *(void *)&long long v639 = v600;
    sub_1CCCB67B8((void ***)&v639);
  }
  else if (v18 == 5)
  {
    if (*(_DWORD *)v17 != 1668507491 || *(unsigned char *)(v17 + 4) != 99) {
      goto LABEL_128;
    }
    memset(v600, 0, 24);
    uint64_t v87 = v7[2];
    uint64_t v88 = v7[3] - v87;
    if (!v88)
    {
LABEL_125:
      *__darwin_ct_rune_t v12 = 0;
      sub_1CD66B7E4();
    }
    uint64_t v89 = 40 * (v88 / 40);
    while (1)
    {
      llvm::PassBuilder::parseCGSCCPass(v10, (uint64_t)v600, v87, (uint64_t)v6);
      if (*v12) {
        break;
      }
      v87 += 40;
      v89 -= 40;
      if (!v89) {
        goto LABEL_125;
      }
    }
    *(void *)&long long v639 = v600;
    sub_1CC947208((void ***)&v639);
  }
  else
  {
    if (v18 != 6) {
      goto LABEL_128;
    }
    BOOL v19 = *(_DWORD *)v17 == 1969516397 && *(_WORD *)(v17 + 4) == 25964;
    if (!v19) {
      goto LABEL_128;
    }
    long long v639 = 0uLL;
    v640 = 0;
    uint64_t v20 = v7[2];
    uint64_t v21 = v7[3] - v20;
    if (v21)
    {
      uint64_t v22 = 40 * (v21 / 40);
      while (1)
      {
        llvm::PassBuilder::parseModulePass(v10, &v639, v20);
        if (*v12) {
          break;
        }
        v20 += 40;
        v22 -= 40;
        if (!v22)
        {
          std::string::size_type v24 = (uint64_t *)*((void *)&v639 + 1);
          size_t v23 = (uint64_t *)v639;
          *__darwin_ct_rune_t v12 = 0;
          if (v23 != v24)
          {
            unint64_t v25 = v9 + 2;
            unint64_t v26 = v9[1];
            do
            {
              if ((unint64_t)v26 >= *v25)
              {
                uint64_t v28 = (v26 - *v9) >> 3;
                if ((unint64_t)(v28 + 1) >> 61) {
                  abort();
                }
                uint64_t v29 = *v25 - (void)*v9;
                uint64_t v30 = v29 >> 2;
                if (v29 >> 2 <= (unint64_t)(v28 + 1)) {
                  uint64_t v30 = v28 + 1;
                }
                if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v31 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v31 = v30;
                }
                v600[4] = v9 + 2;
                if (v31)
                {
                  if (v31 >> 61) {
                    sub_1CB833614();
                  }
                  BOOL v32 = (char *)operator new(8 * v31);
                }
                else
                {
                  BOOL v32 = 0;
                }
                std::string::size_type v33 = &v32[8 * v28];
                int v34 = &v32[8 * v31];
                v600[3] = v34;
                uint64_t v35 = *v23;
                *size_t v23 = 0;
                *(void *)std::string::size_type v33 = v35;
                unint64_t v26 = v33 + 8;
                v600[2] = v33 + 8;
                std::string::size_type v37 = *v9;
                BOOL v36 = v9[1];
                if (v36 == *v9)
                {
                  int64x2_t v39 = vdupq_n_s64((unint64_t)v36);
                }
                else
                {
                  do
                  {
                    uint64_t v38 = *((void *)v36 - 1);
                    v36 -= 8;
                    *(void *)BOOL v36 = 0;
                    *((void *)v33 - 1) = v38;
                    v33 -= 8;
                  }
                  while (v36 != v37);
                  int64x2_t v39 = *(int64x2_t *)v9;
                  int v34 = (char *)v600[3];
                  unint64_t v26 = (char *)v600[2];
                }
                char *v9 = v33;
                v9[1] = v26;
                *(int64x2_t *)&v600[1] = v39;
                std::string v40 = v9[2];
                void v9[2] = v34;
                v600[3] = v40;
                v600[0] = (void *)v39.i64[0];
                sub_1CC9473BC((uint64_t)v600);
              }
              else
              {
                uint64_t v27 = *v23;
                *size_t v23 = 0;
                *(void *)unint64_t v26 = v27;
                v26 += 8;
              }
              v9[1] = v26;
              ++v23;
            }
            while (v23 != v24);
          }
          goto LABEL_141;
        }
      }
    }
    else
    {
LABEL_141:
      *__darwin_ct_rune_t v12 = 0;
    }
LABEL_142:
    v600[0] = &v639;
    sub_1CCB7AA60((void ***)v600);
  }
}

uint64_t sub_1CCC9EB34(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v8[0] = a2;
  v8[1] = a3;
  v7[0] = a5;
  v7[1] = a6;
  if (!a1)
  {
    sub_1CB920400();
    sub_1CCC9EB94();
  }
  return (*(uint64_t (**)(uint64_t, void *, uint64_t, void *))(*(void *)a1 + 48))(a1, v8, a4, v7);
}

void sub_1CCC9EB94()
{
}

void sub_1CCC9EC34()
{
}

uint64_t sub_1CCC9ECD8(_DWORD *a1, unint64_t a2, uint64_t a3, unint64_t *a4)
{
  unint64_t v6 = a2 - 7;
  if (a2 >= 7)
  {
    uint64_t v18 = v4;
    uint64_t v19 = v5;
    BOOL v10 = *a1 == 1701864818 && *(_DWORD *)((char *)a1 + 3) == 1014260069;
    if (v10 && a2 >= 8 && *((unsigned char *)a1 + a2 - 1) == 62)
    {
      unint64_t v15 = 0;
      uint64_t v16 = (char *)a1 + 7;
      if (v6 >= a2 - 8) {
        unint64_t v6 = a2 - 8;
      }
      unint64_t v17 = v6;
      int v11 = llvm::consumeSignedInteger((llvm *)&v16, 0, &v15, a4);
      if (v17) {
        int v12 = 1;
      }
      else {
        int v12 = v11;
      }
      if (v15 != (int)v15) {
        int v12 = 1;
      }
      if (v12) {
        int v8 = 0;
      }
      else {
        int v8 = v15;
      }
      if (v8 < 1) {
        int v12 = 1;
      }
      unsigned int v9 = v8 & 0xFFFFFF00;
      int v8 = v8;
      BOOL v13 = v12 == 0;
      if (v12)
      {
        unsigned int v9 = 0;
        int v8 = 0;
      }
      uint64_t v7 = 0x100000000;
      if (!v13) {
        uint64_t v7 = 0;
      }
    }
    else
    {
      uint64_t v7 = 0;
      int v8 = 0;
      unsigned int v9 = 0;
    }
  }
  else
  {
    uint64_t v7 = 0;
    int v8 = 0;
    unsigned int v9 = 0;
  }
  return v7 | v9 | v8;
}

void sub_1CCC9EDCC()
{
}

BOOL sub_1CCC9EE68(uint64_t a1, unint64_t a2)
{
  if (a2 >= 7)
  {
    if (*(_DWORD *)a1 == 1634100580 && *(_DWORD *)(a1 + 3) == 1953264993) {
      return 1;
    }
    if (*(_DWORD *)a1 == 1852401780 && *(_DWORD *)(a1 + 3) == 1869900910) {
      return 1;
    }
  }
  else if (a2 < 3)
  {
    return 0;
  }
  return *(_WORD *)a1 == 29804 && *(unsigned char *)(a1 + 2) == 111;
}

void sub_1CCC9EEF0()
{
}

void sub_1CCC9EF80()
{
}

void sub_1CCC9F04C()
{
}

BOOL sub_1CCC9F0D4(char *__s1, size_t a2, void *__s2, size_t __n)
{
  if (a2 < __n) {
    return 0;
  }
  if (__n && memcmp(__s1, __s2, __n)) {
    return 0;
  }
  if (a2 > __n)
  {
    if (__s1[__n] == 60) {
      return __s1[a2 - 1] == 62;
    }
    return 0;
  }
  return 1;
}

uint64_t sub_1CCC9F164(int a1, uint64_t (*a2)(char *, size_t), char *__s1, size_t a4, void *__s2, size_t __n)
{
  size_t v6 = a4;
  int v8 = a2;
  if (a4 >= __n)
  {
    if (!__n || (v10 = memcmp(__s1, __s2, __n), int v8 = a2, !v10))
    {
      if (v6 >= __n) {
        size_t v11 = __n;
      }
      else {
        size_t v11 = v6;
      }
      __s1 += v11;
      v6 -= v11;
    }
  }
  if (v6 && *__s1 == 60)
  {
    if (v6 == 1)
    {
      size_t v6 = 0;
    }
    else
    {
      size_t v12 = v6 - 2;
      if (v6 - 1 < v6 - 2) {
        size_t v12 = v6 - 1;
      }
      if (__s1[v6 - 1] == 62) {
        size_t v6 = v12;
      }
      else {
        --v6;
      }
    }
    ++__s1;
  }

  return v8(__s1, v6);
}

uint64_t sub_1CCC9F23C@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return sub_1CCCB6950(a3, a1, a2, "single", 6uLL, (uint64_t)"LoopExtractor", 13);
}

uint64_t sub_1CCC9F264@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return sub_1CCCB6950(a3, a1, a2, "only-mandatory", 0xEuLL, (uint64_t)"InlinerPass", 11);
}

uint64_t sub_1CCC9F28C@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return sub_1CCCB6950(a3, a1, a2, "memssa", 6uLL, (uint64_t)"EarlyCSE", 8);
}

uint64_t sub_1CCC9F2B4@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return sub_1CCCB6950(a3, a1, a2, "post-inline", 0xBuLL, (uint64_t)"EntryExitInstrumenter", 21);
}

uint64_t sub_1CCC9F2DC@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return sub_1CCCB6950(a3, a1, a2, "minimal", 7uLL, (uint64_t)"LowerMatrixIntrinsics", 21);
}

unint64_t sub_1CCC9F304@<X0>(unint64_t result@<X0>, void *a2@<X1>, unint64_t a3@<X2>, unint64_t a4@<X8>)
{
  unint64_t v4 = a3;
  uint64_t v5 = (unsigned __int8 *)a2;
  unint64_t v6 = result;
  if (a3 >= 0xB)
  {
    if (*a2 != 0x726E752D706F6F6CLL || *(void *)((char *)a2 + 3) != 0x6C6C6F726E752D70) {
      goto LABEL_9;
    }
    LODWORD(a4) = 11;
    uint64_t v5 = (unsigned __int8 *)a2 + 11;
    unint64_t v4 = a3 - 11;
  }
  if (!v4) {
    goto LABEL_17;
  }
LABEL_9:
  LODWORD(a4) = *v5;
  if (a4 != 60)
  {
    uint64_t v8 = (uint64_t)v5;
LABEL_20:
    BOOL v50 = v5;
    unint64_t v51 = v4;
    goto LABEL_21;
  }
  a4 = v4 - 1;
  if (v4 == 1) {
    goto LABEL_17;
  }
  uint64_t v8 = (uint64_t)(v5 + 1);
  if (v5[v4 - 1] != 62)
  {
    ++v5;
    --v4;
    goto LABEL_20;
  }
  if (a4 >= v4 - 2) {
    v4 -= 2;
  }
  else {
    --v4;
  }
  BOOL v50 = v5 + 1;
  unint64_t v51 = v4;
  if (v4)
  {
    ++v5;
LABEL_21:
    LOBYTE(v12) = 0;
    char v11 = 0;
    char v10 = 0;
    char v9 = 0;
    uint64_t v37 = 0;
    uint64_t v38 = 0;
    uint64_t v36 = 0;
    int v13 = 2;
    unsigned int v39 = a4;
    uint64_t v40 = 0;
    while (1)
    {
      unint64_t v48 = 0;
      unint64_t v49 = 0;
      LOBYTE(v41) = 59;
      uint64_t result = llvm::StringRef::find((uint64_t *)&v50, (char *)&v41, 1uLL, 0);
      if (v4 >= result) {
        unint64_t v15 = result;
      }
      else {
        unint64_t v15 = v4;
      }
      if (v4 >= result + 1) {
        unint64_t v16 = result + 1;
      }
      else {
        unint64_t v16 = v4;
      }
      uint64_t v17 = v8 + v16;
      unint64_t v18 = v4 - v16;
      if (result == -1) {
        uint64_t v19 = v5;
      }
      else {
        uint64_t v19 = (unsigned __int8 *)v8;
      }
      if (result == -1) {
        unint64_t v20 = v4;
      }
      else {
        unint64_t v20 = v15;
      }
      if (result == -1) {
        uint64_t v8 = 0;
      }
      else {
        uint64_t v8 = v17;
      }
      unint64_t v48 = v19;
      unint64_t v49 = v20;
      if (result == -1) {
        unint64_t v4 = 0;
      }
      else {
        unint64_t v4 = v18;
      }
      BOOL v50 = (unsigned __int8 *)v8;
      unint64_t v51 = v4;
      if (v20 == 2)
      {
        switch(*(_WORD *)v19)
        {
          case 0x304F:
            int v13 = 0;
            break;
          case 0x314F:
            int v13 = 1;
            break;
          case 0x324F:
            int v13 = 2;
            break;
          case 0x334F:
            int v13 = 3;
            break;
          default:
            goto LABEL_99;
        }
        goto LABEL_97;
      }
      if (v20 >= 0x10)
      {
        if (*(void *)v19 == 0x726E752D6C6C7566 && *((void *)v19 + 1) == 0x3D78616D2D6C6C6FLL)
        {
          unint64_t v48 = v19 + 16;
          unint64_t v49 = v20 - 16;
          v52[0] = 0;
          std::string v41 = (const char *)(v19 + 16);
          uint64_t v42 = v20 - 16;
          uint64_t result = llvm::consumeSignedInteger((llvm *)&v41, 0, v52, v14);
          if (result) {
            goto LABEL_99;
          }
          if (v42) {
            goto LABEL_99;
          }
          unint64_t v12 = v52[0];
          if (v12 != (int)v12) {
            goto LABEL_99;
          }
          unsigned int v39 = LODWORD(v52[0]) >> 8;
          LOBYTE(v40) = 1;
          goto LABEL_97;
        }
      }
      else if (v20 < 3)
      {
        goto LABEL_57;
      }
      if (*(_WORD *)v19 != 28526 || v19[2] != 45)
      {
LABEL_57:
        char v23 = 1;
        goto LABEL_61;
      }
      char v23 = 0;
      v19 += 3;
      v20 -= 3;
      unint64_t v48 = v19;
      unint64_t v49 = v20;
LABEL_61:
      switch(v20)
      {
        case 0xFuLL:
          uint64_t v29 = *(void *)v19;
          uint64_t v30 = *(void *)(v19 + 7);
          if (v29 != 0x2D656C69666F7270 || v30 != 0x676E696C6565702DLL)
          {
LABEL_99:
            std::string v41 = "invalid LoopUnrollPass parameter '{0}' ";
            uint64_t v42 = 39;
            unint64_t v43 = &v46;
            uint64_t v44 = 1;
            v45[0] = &unk_1F2617F90;
            v45[1] = &v48;
            std::string v46 = v45;
            sub_1CD465B2C((uint64_t)&v41, &__p);
            llvm::inconvertibleErrorCode(v35);
            operator new();
          }
          BYTE4(v40) = 1;
          char v11 = v23;
          break;
        case 0xAuLL:
          uint64_t v32 = *(void *)v19;
          int v33 = *((unsigned __int16 *)v19 + 4);
          if (v32 != 0x756F627265707075 || v33 != 25710) {
            goto LABEL_99;
          }
          char v10 = 1;
          char v9 = v23;
          break;
        case 7uLL:
          if (*(_DWORD *)v19 == 1953653104 && *(_DWORD *)(v19 + 3) == 1818323316)
          {
            LOBYTE(v37) = v23;
            BYTE4(v37) = 1;
          }
          else if (*(_DWORD *)v19 == 1818584432 && *(_DWORD *)(v19 + 3) == 1735289196)
          {
            LOBYTE(v36) = v23;
            BYTE4(v36) = 1;
          }
          else
          {
            int v26 = *(_DWORD *)v19;
            int v27 = *(_DWORD *)(v19 + 3);
            if (v26 != 1953396082 || v27 != 1701669236) {
              goto LABEL_99;
            }
            LOBYTE(v38) = v23;
            BYTE4(v38) = 1;
          }
          break;
        default:
          goto LABEL_99;
      }
LABEL_97:
      uint64_t v5 = (unsigned __int8 *)v8;
      if (!v4) {
        goto LABEL_98;
      }
    }
  }
LABEL_17:
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  char v9 = 0;
  char v10 = 0;
  char v11 = 0;
  uint64_t v40 = 0;
  LOBYTE(v12) = 0;
  uint64_t v38 = 0;
  unsigned int v39 = a4;
  int v13 = 2;
LABEL_98:
  *(unsigned char *)(v6 + 32) &= ~1u;
  *(unsigned char *)unint64_t v6 = v37;
  *(unsigned char *)(v6 + 1) = BYTE4(v37);
  *(unsigned char *)(v6 + 2) = v36;
  *(unsigned char *)(v6 + 3) = BYTE4(v36);
  *(unsigned char *)(v6 + 4) = v38;
  *(unsigned char *)(v6 + 5) = BYTE4(v38);
  *(unsigned char *)(v6 + 6) = v9;
  *(unsigned char *)(v6 + 7) = v10;
  *(unsigned char *)(v6 + 8) = v11;
  *(unsigned char *)(v6 + 9) = BYTE4(v40);
  *(_DWORD *)(v6 + 12) = v12 | (v39 << 8);
  *(unsigned char *)(v6 + 16) = v40;
  *(_DWORD *)(v6 + 20) = v13;
  *(_WORD *)(v6 + 24) = 0;
  return result;
}

unint64_t sub_1CCC9F844(uint64_t a1, _DWORD *a2, unint64_t a3)
{
  unint64_t v3 = a3;
  uint64_t v4 = (uint64_t)a2;
  if (a3 >= 4)
  {
    unint64_t v6 = a2;
    if (*a2 != 1851880301) {
      goto LABEL_6;
    }
    uint64_t v4 = (uint64_t)(a2 + 1);
    unint64_t v3 = a3 - 4;
  }
  if (!v3) {
    goto LABEL_15;
  }
  unint64_t v6 = (unsigned char *)v4;
LABEL_6:
  if (*v6 == 60)
  {
    uint64_t v4 = (uint64_t)(v6 + 1);
    if (v3 == 1)
    {
      unint64_t v3 = 0;
    }
    else
    {
      int v7 = v6[v3 - 1];
      unint64_t v8 = v3 - 2;
      if (v3 - 1 < v3 - 2) {
        unint64_t v8 = v3 - 1;
      }
      if (v7 == 62) {
        unint64_t v3 = v8;
      }
      else {
        --v3;
      }
    }
  }
  else
  {
    uint64_t v4 = (uint64_t)v6;
  }
LABEL_15:
  uint64_t v40 = v4;
  unint64_t v41 = v3;
  for (unint64_t result = llvm::MemorySanitizerOptions::MemorySanitizerOptions((uint64_t)&v38, 0, 0, 0, 0); v3; LOBYTE(v38) = 1)
  {
    while (1)
    {
      uint64_t v36 = 0;
      unint64_t v37 = 0;
      LOBYTE(v29) = 59;
      unint64_t result = llvm::StringRef::find(&v40, (char *)&v29, 1uLL, 0);
      unint64_t v11 = v3 >= result ? result : v3;
      uint64_t v12 = v3 >= result + 1 ? result + 1 : v3;
      uint64_t v13 = v4 + v12;
      unint64_t v14 = v3 - v12;
      uint64_t v15 = v4;
      if (result == -1)
      {
        unint64_t v11 = v3;
        uint64_t v4 = 0;
      }
      else
      {
        uint64_t v4 = v13;
      }
      uint64_t v36 = v15;
      unint64_t v37 = v11;
      unint64_t v3 = result == -1 ? 0 : v14;
      uint64_t v40 = v4;
      unint64_t v41 = v3;
      if (v11 == 6) {
        break;
      }
      if (v11 == 7)
      {
        int v16 = *(_DWORD *)v15;
        int v17 = *(_DWORD *)(v15 + 3);
        if (v16 != 1868785010 || v17 != 1919252079) {
          goto LABEL_63;
        }
        LOBYTE(v39) = 1;
        if (!v3) {
          goto LABEL_62;
        }
      }
      else if (v11 >= 0xE)
      {
        if (*(void *)v15 != 0x726F2D6B63617274 || *(void *)(v15 + 6) != 0x3D736E696769726FLL) {
          goto LABEL_63;
        }
        uint64_t v36 = v15 + 14;
        unint64_t v37 = v11 - 14;
        v42[0] = 0;
        uint64_t v29 = (const char *)(v15 + 14);
        uint64_t v30 = v11 - 14;
        unint64_t result = llvm::consumeSignedInteger((llvm *)&v29, 0, v42, v10);
        if ((result & 1) != 0 || v30 || v42[0] != SLODWORD(v42[0]))
        {
          int v26 = "invalid argument to MemorySanitizer pass track-origins parameter: '{0}' ";
          uint64_t v27 = 72;
LABEL_65:
          uint64_t v29 = v26;
          uint64_t v30 = v27;
          unint64_t v31 = &v34;
          uint64_t v32 = 1;
          v33[0] = &unk_1F2617F90;
          v33[1] = &v36;
          int v34 = v33;
          sub_1CD465B2C((uint64_t)&v29, &__p);
          llvm::inconvertibleErrorCode(v28);
          operator new();
        }
        HIDWORD(v38) = v42[0];
        if (!v3) {
          goto LABEL_62;
        }
      }
      else
      {
        if (v11 != 12) {
          goto LABEL_63;
        }
        uint64_t v22 = *(void *)v15;
        int v23 = *(_DWORD *)(v15 + 8);
        if (v22 != 0x68632D7265676165 || v23 != 1936417637) {
          goto LABEL_63;
        }
        BYTE1(v39) = 1;
        if (!v3) {
          goto LABEL_62;
        }
      }
    }
    int v19 = *(_DWORD *)v15;
    int v20 = *(unsigned __int16 *)(v15 + 4);
    if (v19 != 1852990827 || v20 != 27749)
    {
LABEL_63:
      int v26 = "invalid MemorySanitizer pass parameter '{0}' ";
      uint64_t v27 = 45;
      goto LABEL_65;
    }
  }
LABEL_62:
  *(unsigned char *)(a1 + 16) &= ~1u;
  *(void *)a1 = v38;
  *(_DWORD *)(a1 + 8) = v39;
  return result;
}

unint64_t sub_1CCC9FBCC(unint64_t result, void *a2, unint64_t a3)
{
  unint64_t v3 = a3;
  uint64_t v4 = a2;
  unint64_t v5 = result;
  if (a3 >= 0xB)
  {
    if (*a2 != 0x7966696C706D6973 || *(void *)((char *)a2 + 3) != 0x6766637966696C70) {
      goto LABEL_9;
    }
    uint64_t v4 = (char *)a2 + 11;
    unint64_t v3 = a3 - 11;
  }
  if (!v3) {
    goto LABEL_17;
  }
LABEL_9:
  if (*v4 != 60)
  {
    uint64_t v7 = (uint64_t)v4;
LABEL_22:
    int v69 = v4;
    unint64_t v70 = v3;
LABEL_23:
    char v9 = 0;
    uint64_t v56 = 0;
    char v8 = 0;
    char v55 = 0;
    LODWORD(v11) = 1;
    char v10 = *(unsigned char *)(result + 24);
    char v12 = 1;
    while (2)
    {
      int v67 = 0;
      unint64_t v68 = 0;
      LOBYTE(v57) = 59;
      unint64_t result = llvm::StringRef::find((uint64_t *)&v69, (char *)&v57, 1uLL, 0);
      if (v3 >= result) {
        unint64_t v13 = result;
      }
      else {
        unint64_t v13 = v3;
      }
      if (v3 >= result + 1) {
        unint64_t v14 = result + 1;
      }
      else {
        unint64_t v14 = v3;
      }
      uint64_t v15 = v7 + v14;
      unint64_t v16 = v3 - v14;
      if (result == -1) {
        int v17 = v4;
      }
      else {
        int v17 = (unsigned char *)v7;
      }
      if (result == -1) {
        unint64_t v18 = v3;
      }
      else {
        unint64_t v18 = v13;
      }
      if (result == -1) {
        uint64_t v7 = 0;
      }
      else {
        uint64_t v7 = v15;
      }
      int v67 = v17;
      unint64_t v68 = v18;
      if (result == -1) {
        unint64_t v3 = 0;
      }
      else {
        unint64_t v3 = v16;
      }
      int v69 = (unsigned char *)v7;
      unint64_t v70 = v3;
      if (v18 >= 3 && (*(_WORD *)v17 == 28526 ? (BOOL v19 = v17[2] == 45) : (BOOL v19 = 0), v19))
      {
        v17 += 3;
        int v67 = v17;
        unint64_t v68 = v18 - 3;
        char v20 = 1;
        v18 -= 3;
      }
      else
      {
        char v20 = 0;
      }
      char v21 = v20 ^ 1;
      switch(v18)
      {
        case 0xAuLL:
          uint64_t v22 = *(void *)v17;
          int v23 = *((unsigned __int16 *)v17 + 4);
          if (v22 != 0x6F6F6C2D7065656BLL || v23 != 29552) {
            goto LABEL_121;
          }
          char v12 = v20 ^ 1;
          goto LABEL_118;
        case 0x10uLL:
          uint64_t v31 = *(void *)v17;
          uint64_t v30 = *((void *)v17 + 1);
          if (v31 != 0x742D686374697773 || v30 != 0x70756B6F6F6C2D6FLL) {
            goto LABEL_121;
          }
          char v8 = v20 ^ 1;
          goto LABEL_118;
        case 0x11uLL:
          uint64_t v33 = *(void *)v17;
          uint64_t v34 = *((void *)v17 + 1);
          int v35 = v17[16];
          if (v33 != 0x6D6F632D6B6E6973 || v34 != 0x74736E692D6E6F6DLL || v35 != 115) {
            goto LABEL_121;
          }
          char v9 = v21;
          goto LABEL_118;
        case 0x12uLL:
          uint64_t v38 = *(void *)v17;
          uint64_t v39 = *((void *)v17 + 1);
          int v40 = *((unsigned __int16 *)v17 + 8);
          if (v38 != 0x6F632D7473696F68 || v39 != 0x736E692D6E6F6D6DLL || v40 != 29556) {
            goto LABEL_121;
          }
          LOBYTE(v56) = v21;
          goto LABEL_118;
        case 0x13uLL:
          uint64_t v43 = *(void *)v17;
          uint64_t v44 = *((void *)v17 + 1);
          uint64_t v45 = *(void *)(v17 + 11);
          if (v43 != 0x2D64726177726F66 || v44 != 0x632D686374697773 || v45 != 0x646E6F632D686374) {
            goto LABEL_121;
          }
          char v55 = v21;
          goto LABEL_118;
        case 0x14uLL:
          uint64_t v48 = *(void *)v17;
          uint64_t v49 = *((void *)v17 + 1);
          int v50 = *((_DWORD *)v17 + 4);
          if (v48 != 0x722D686374697773 || v49 != 0x2D6F742D65676E61 || v50 != 1886217065) {
            goto LABEL_121;
          }
          BYTE4(v56) = v21;
          goto LABEL_118;
        default:
          unint64_t v25 = v18 - 21;
          if (v18 < 0x15) {
            char v26 = 1;
          }
          else {
            char v26 = v20;
          }
          if ((v26 & 1) != 0
            || (*(void *)v17 == 0x6E692D73756E6F62
              ? (BOOL v27 = *((void *)v17 + 1) == 0x73657268742D7473)
              : (BOOL v27 = 0),
                v27 ? (BOOL v28 = *(void *)(v17 + 13) == 0x3D646C6F68736572) : (BOOL v28 = 0),
                !v28))
          {
LABEL_121:
            char v57 = "invalid SimplifyCFG pass parameter '{0}' ";
            uint64_t v58 = 41;
            unint64_t v59 = &v63;
            uint64_t v60 = 1;
            uint64_t v61 = &unk_1F2617F90;
            uint64_t v62 = &v67;
            long long v63 = &v61;
            sub_1CD465B2C((uint64_t)&v57, __p);
            llvm::inconvertibleErrorCode(v54);
            operator new();
          }
          int v67 = v17 + 21;
          unint64_t v68 = v25;
          unsigned int v66 = 1;
          unint64_t v65 = 0;
          unint64_t result = llvm::StringRef::getAsInteger((llvm::StringRef *)&v67, 0, (llvm::APInt *)&v65);
          char v29 = result;
          if (result)
          {
            char v57 = "invalid argument to SimplifyCFG pass bonus-threshold parameter: '{0}' ";
            uint64_t v58 = 70;
            unint64_t v59 = &v63;
            uint64_t v60 = 1;
            uint64_t v61 = &unk_1F2617F90;
            uint64_t v62 = &v67;
            long long v63 = &v61;
            sub_1CD465B2C((uint64_t)&v57, __p);
            llvm::inconvertibleErrorCode(v53);
            operator new();
          }
          if (v66 > 0x40) {
            uint64_t v11 = *(void *)v65;
          }
          else {
            uint64_t v11 = (uint64_t)(v65 << -(char)v66) >> -(char)v66;
          }
          if (v66 >= 0x41)
          {
            unint64_t result = v65;
            if (v65) {
              unint64_t result = MEMORY[0x1D25D9CB0](v65, 0x1000C8000313F17);
            }
          }
          if (v29) {
            return result;
          }
LABEL_118:
          uint64_t v4 = (unsigned char *)v7;
          if (!v3) {
            goto LABEL_18;
          }
          continue;
      }
    }
  }
  if (v3 == 1) {
    goto LABEL_17;
  }
  uint64_t v7 = (uint64_t)(v4 + 1);
  if (v4[v3 - 1] != 62)
  {
    ++v4;
    --v3;
    goto LABEL_22;
  }
  if (v3 - 1 >= v3 - 2) {
    v3 -= 2;
  }
  else {
    --v3;
  }
  int v69 = v4 + 1;
  unint64_t v70 = v3;
  if (v3)
  {
    ++v4;
    goto LABEL_23;
  }
LABEL_17:
  char v55 = 0;
  uint64_t v56 = 0;
  char v8 = 0;
  char v9 = 0;
  char v10 = *(unsigned char *)(result + 24);
  LODWORD(v11) = 1;
  char v12 = 1;
LABEL_18:
  *(unsigned char *)(v5 + 24) = v10 & 0xFE;
  *(_DWORD *)unint64_t v5 = v11;
  *(unsigned char *)(v5 + 4) = v55;
  *(unsigned char *)(v5 + 5) = BYTE4(v56);
  *(unsigned char *)(v5 + 6) = v8;
  *(unsigned char *)(v5 + 7) = v12;
  *(unsigned char *)(v5 + 8) = v56;
  *(unsigned char *)(v5 + 9) = v9;
  *(_WORD *)(v5 + 10) = 257;
  *(void *)(v5 + 16) = 0;
  return result;
}

unint64_t sub_1CCCA0278(unint64_t result, void *a2, unint64_t a3)
{
  unint64_t v3 = a3;
  uint64_t v4 = a2;
  unint64_t v28 = result;
  if (a3 >= 0xE)
  {
    if (*a2 != 0x6365762D706F6F6CLL || *(void *)((char *)a2 + 6) != 0x657A69726F746365) {
      goto LABEL_9;
    }
    uint64_t v4 = (char *)a2 + 14;
    unint64_t v3 = a3 - 14;
  }
  if (!v3) {
    goto LABEL_17;
  }
LABEL_9:
  if (*v4 != 60)
  {
    uint64_t v6 = (uint64_t)v4;
LABEL_21:
    int v35 = v4;
    unint64_t v36 = v3;
    goto LABEL_22;
  }
  if (v3 == 1) {
    goto LABEL_17;
  }
  uint64_t v6 = (uint64_t)(v4 + 1);
  if (v4[v3 - 1] != 62)
  {
    ++v4;
    --v3;
    goto LABEL_21;
  }
  if (v3 - 1 >= v3 - 2) {
    v3 -= 2;
  }
  else {
    --v3;
  }
  int v35 = v4 + 1;
  unint64_t v36 = v3;
  if (v3)
  {
    ++v4;
LABEL_22:
    __int16 v8 = 0;
    unsigned __int8 v7 = 0;
    while (1)
    {
      LOBYTE(v29[0]) = 59;
      unint64_t result = llvm::StringRef::find((uint64_t *)&v35, (char *)v29, 1uLL, 0);
      if (v3 >= result) {
        unint64_t v9 = result;
      }
      else {
        unint64_t v9 = v3;
      }
      if (v3 >= result + 1) {
        unint64_t v10 = result + 1;
      }
      else {
        unint64_t v10 = v3;
      }
      uint64_t v11 = v6 + v10;
      unint64_t v12 = v3 - v10;
      if (result == -1) {
        unint64_t v13 = v4;
      }
      else {
        unint64_t v13 = (unsigned char *)v6;
      }
      if (result == -1) {
        unint64_t v14 = v3;
      }
      else {
        unint64_t v14 = v9;
      }
      if (result == -1) {
        uint64_t v6 = 0;
      }
      else {
        uint64_t v6 = v11;
      }
      uint64_t v33 = v13;
      unint64_t v34 = v14;
      if (result == -1) {
        unint64_t v3 = 0;
      }
      else {
        unint64_t v3 = v12;
      }
      int v35 = (unsigned char *)v6;
      unint64_t v36 = v3;
      if (v14 >= 3 && (*(_WORD *)v13 == 28526 ? (BOOL v15 = v13[2] == 45) : (BOOL v15 = 0), v15))
      {
        __int16 v16 = 0;
        v13 += 3;
        uint64_t v33 = v13;
        unint64_t v34 = v14 - 3;
        v14 -= 3;
      }
      else
      {
        __int16 v16 = 1;
      }
      if (v14 == 21)
      {
        uint64_t v22 = *(void *)v13;
        uint64_t v23 = *((void *)v13 + 1);
        uint64_t v24 = *(void *)(v13 + 13);
        if (v22 != 0x7A69726F74636576 || v23 != 0x646563726F662D65 || v24 != 0x796C6E6F2D646563)
        {
LABEL_70:
          v29[0] = "invalid LoopVectorize parameter '{0}' ";
          v29[1] = 38;
          _OWORD v29[2] = &v31;
          v29[3] = 1;
          v30[0] = &unk_1F2617F90;
          v30[1] = &v33;
          uint64_t v31 = v30;
          sub_1CD465B2C((uint64_t)v29, &__p);
          llvm::inconvertibleErrorCode(v27);
          operator new();
        }
        __int16 v8 = v16;
      }
      else
      {
        if (v14 != 22) {
          goto LABEL_70;
        }
        uint64_t v17 = *(void *)v13;
        uint64_t v18 = *((void *)v13 + 1);
        uint64_t v19 = *(void *)(v13 + 14);
        BOOL v20 = v17 == 0x61656C7265746E69 && v18 == 0x6563726F662D6576;
        if (!v20 || v19 != 0x796C6E6F2D646563) {
          goto LABEL_70;
        }
        unsigned __int8 v7 = v16;
      }
      uint64_t v4 = (unsigned char *)v6;
      if (!v3) {
        goto LABEL_18;
      }
    }
  }
LABEL_17:
  unsigned __int8 v7 = 0;
  __int16 v8 = 0;
LABEL_18:
  *(unsigned char *)(v28 + 8) &= ~1u;
  *(_WORD *)unint64_t v28 = v7 | (unsigned __int16)(v8 << 8);
  return result;
}

unint64_t sub_1CCCA05B8@<X0>(unint64_t result@<X0>, unint64_t a2@<X1>, BOOL *a3@<X8>)
{
  unint64_t v24 = result;
  unint64_t v25 = a2;
  if (a2)
  {
    unint64_t v4 = a2;
    uint64_t v5 = result;
    do
    {
      LOBYTE(v18[0]) = 59;
      unint64_t result = llvm::StringRef::find((uint64_t *)&v24, (char *)v18, 1uLL, 0);
      if (v4 >= result) {
        unint64_t v6 = result;
      }
      else {
        unint64_t v6 = v4;
      }
      if (v4 >= result + 1) {
        unint64_t v7 = result + 1;
      }
      else {
        unint64_t v7 = v4;
      }
      uint64_t v8 = v5 + v7;
      unint64_t v9 = v4 - v7;
      unint64_t v10 = (unsigned __int16 *)v5;
      if (result == -1) {
        unint64_t v11 = v4;
      }
      else {
        unint64_t v11 = v6;
      }
      if (result == -1) {
        uint64_t v5 = 0;
      }
      else {
        uint64_t v5 = v8;
      }
      uint64_t v22 = v10;
      unint64_t v23 = v11;
      if (result == -1) {
        unint64_t v4 = 0;
      }
      else {
        unint64_t v4 = v9;
      }
      unint64_t v24 = v5;
      unint64_t v25 = v4;
      if (v11 >= 3)
      {
        int v12 = *v10 ^ 0x6F6E | *((unsigned __int8 *)v10 + 2) ^ 0x2D;
        if (!v12)
        {
          unint64_t v10 = (unsigned __int16 *)((char *)v10 + 3);
          uint64_t v22 = v10;
          unint64_t v23 = v11 - 3;
          v11 -= 3;
        }
        if (v11 == 15)
        {
          uint64_t v13 = *(void *)v10;
          uint64_t v14 = *(void *)((char *)v10 + 7);
          if (v13 == 0x6F662D74696C7073 && v14 == 0x62622D7265746F6FLL) {
            continue;
          }
        }
      }
      v18[0] = "invalid MergedLoadStoreMotion pass parameter '{0}' ";
      v18[1] = 51;
      void v18[2] = &v20;
      void v18[3] = 1;
      v19[0] = &unk_1F2617F90;
      v19[1] = &v22;
      BOOL v20 = v19;
      sub_1CD465B2C((uint64_t)v18, &__p);
      llvm::inconvertibleErrorCode(v17);
      operator new();
    }
    while (v4);
    BOOL v16 = v12 != 0;
  }
  else
  {
    BOOL v16 = 0;
  }
  a3[8] &= ~1u;
  *a3 = v16;
  return result;
}

unint64_t sub_1CCCA07D0(unint64_t result, unsigned char *a2, unint64_t a3)
{
  unint64_t v3 = a3;
  unint64_t v4 = a2;
  unint64_t v5 = result;
  if (a3 >= 3)
  {
    if (*(_WORD *)a2 != 30311 || a2[2] != 110) {
      goto LABEL_9;
    }
    unint64_t v4 = a2 + 3;
    unint64_t v3 = a3 - 3;
  }
  if (!v3) {
    goto LABEL_17;
  }
LABEL_9:
  if (*v4 != 60)
  {
    uint64_t v7 = (uint64_t)v4;
LABEL_21:
    unint64_t v41 = v4;
    unint64_t v42 = v3;
    goto LABEL_22;
  }
  if (v3 == 1) {
    goto LABEL_17;
  }
  uint64_t v7 = (uint64_t)(v4 + 1);
  if (v4[v3 - 1] != 62)
  {
    ++v4;
    --v3;
    goto LABEL_21;
  }
  if (v3 - 1 >= v3 - 2) {
    v3 -= 2;
  }
  else {
    --v3;
  }
  unint64_t v41 = v4 + 1;
  unint64_t v42 = v3;
  if (v3)
  {
    ++v4;
LABEL_22:
    char v12 = 0;
    char v11 = 0;
    char v10 = 0;
    char v9 = 0;
    uint64_t v34 = 0;
    char v8 = 0;
    char v33 = 0;
    while (1)
    {
      LOBYTE(v35[0]) = 59;
      unint64_t result = llvm::StringRef::find((uint64_t *)&v41, (char *)v35, 1uLL, 0);
      if (v3 >= result) {
        unint64_t v13 = result;
      }
      else {
        unint64_t v13 = v3;
      }
      if (v3 >= result + 1) {
        unint64_t v14 = result + 1;
      }
      else {
        unint64_t v14 = v3;
      }
      uint64_t v15 = v7 + v14;
      unint64_t v16 = v3 - v14;
      if (result == -1) {
        uint64_t v17 = (unsigned __int16 *)v4;
      }
      else {
        uint64_t v17 = (unsigned __int16 *)v7;
      }
      if (result == -1) {
        uint64_t v18 = v3;
      }
      else {
        uint64_t v18 = v13;
      }
      if (result == -1) {
        uint64_t v7 = 0;
      }
      else {
        uint64_t v7 = v15;
      }
      uint64_t v39 = v17;
      uint64_t v40 = v18;
      if (result == -1) {
        unint64_t v3 = 0;
      }
      else {
        unint64_t v3 = v16;
      }
      unint64_t v41 = (unsigned char *)v7;
      unint64_t v42 = v3;
      if ((unint64_t)v18 >= 3 && (*v17 == 28526 ? (BOOL v19 = *((unsigned char *)v17 + 2) == 45) : (BOOL v19 = 0), v19))
      {
        char v20 = 0;
        uint64_t v17 = (unsigned __int16 *)((char *)v17 + 3);
        uint64_t v39 = v17;
        uint64_t v40 = v18 - 3;
        v18 -= 3;
      }
      else
      {
        char v20 = 1;
      }
      if (v18 > 7)
      {
        if (v18 == 8)
        {
          if (*(void *)v17 != 0x6572702D64616F6CLL) {
            goto LABEL_78;
          }
          BYTE4(v34) = 1;
          char v8 = v20;
        }
        else
        {
          if (v18 != 23
            || ((uint64_t v24 = *(void *)v17,
                 uint64_t v25 = *((void *)v17 + 1),
                 uint64_t v26 = *(void *)((char *)v17 + 15),
                 v24 == 0x61622D74696C7073)
              ? (BOOL v27 = v25 == 0x6C2D656764656B63)
              : (BOOL v27 = 0),
                v27 ? (BOOL v28 = v26 == 0x6572702D64616F6CLL) : (BOOL v28 = 0),
                !v28))
          {
LABEL_78:
            v35[0] = "invalid GVN pass parameter '{0}' ";
            v35[1] = 33;
            v35[2] = &v37;
            v35[3] = 1;
            v36[0] = &unk_1F2617F90;
            v36[1] = &v39;
            unint64_t v37 = v36;
            sub_1CD465B2C((uint64_t)v35, &__p);
            llvm::inconvertibleErrorCode(v32);
            operator new();
          }
          char v10 = 1;
          char v9 = v20;
        }
      }
      else if (v18 == 3)
      {
        int v29 = *v17;
        int v30 = *((unsigned __int8 *)v17 + 2);
        if (v29 != 29296 || v30 != 101) {
          goto LABEL_78;
        }
        char v33 = v20;
        LOBYTE(v34) = 1;
      }
      else
      {
        if (v18 != 6) {
          goto LABEL_78;
        }
        int v21 = *(_DWORD *)v17;
        int v22 = v17[2];
        if (v21 != 1684890989 || v22 != 28773) {
          goto LABEL_78;
        }
        char v12 = 1;
        char v11 = v20;
      }
      unint64_t v4 = (unsigned char *)v7;
      if (!v3) {
        goto LABEL_18;
      }
    }
  }
LABEL_17:
  char v33 = 0;
  uint64_t v34 = 0;
  char v8 = 0;
  char v9 = 0;
  char v10 = 0;
  char v11 = 0;
  char v12 = 0;
LABEL_18:
  *(unsigned char *)(v5 + 16) &= ~1u;
  *(unsigned char *)unint64_t v5 = v33;
  *(unsigned char *)(v5 + 1) = v34;
  *(unsigned char *)(v5 + 2) = v8;
  *(unsigned char *)(v5 + 3) = BYTE4(v34);
  *(_WORD *)(v5 + 4) = 0;
  *(unsigned char *)(v5 + 6) = v9;
  *(unsigned char *)(v5 + 7) = v10;
  *(unsigned char *)(v5 + 8) = v11;
  *(unsigned char *)(v5 + 9) = v12;
  return result;
}

unint64_t sub_1CCCA0B9C(unint64_t result, void *a2, unint64_t a3)
{
  unint64_t v3 = a3;
  unint64_t v4 = a2;
  unint64_t v5 = result;
  if (a3 >= 0x15)
  {
    if (*a2 != 0x74733C746E697270
      || a2[1] != 0x6566696C2D6B6361
      || *(void *)((char *)a2 + 13) != 0x3E656D6974656669)
    {
      goto LABEL_12;
    }
    unint64_t v4 = (char *)a2 + 21;
    unint64_t v3 = a3 - 21;
  }
  if (!v3) {
    goto LABEL_20;
  }
LABEL_12:
  if (*v4 != 60)
  {
    uint64_t v8 = (uint64_t)v4;
    goto LABEL_23;
  }
  if (v3 == 1)
  {
LABEL_20:
    int v9 = 0;
    goto LABEL_50;
  }
  uint64_t v8 = (uint64_t)(v4 + 1);
  if (v4[v3 - 1] == 62)
  {
    if (v3 - 1 >= v3 - 2) {
      v3 -= 2;
    }
    else {
      --v3;
    }
    uint64_t v24 = v4 + 1;
    unint64_t v25 = v3;
    if (v3)
    {
      ++v4;
      goto LABEL_24;
    }
    goto LABEL_20;
  }
  ++v4;
  --v3;
LABEL_23:
  uint64_t v24 = v4;
  unint64_t v25 = v3;
  do
  {
LABEL_24:
    LOBYTE(v19[0]) = 59;
    unint64_t result = llvm::StringRef::find((uint64_t *)&v24, (char *)v19, 1uLL, 0);
    if (v3 >= result) {
      unint64_t v10 = result;
    }
    else {
      unint64_t v10 = v3;
    }
    if (v3 >= result + 1) {
      unint64_t v11 = result + 1;
    }
    else {
      unint64_t v11 = v3;
    }
    uint64_t v12 = v8 + v11;
    unint64_t v13 = v3 - v11;
    if (result == -1) {
      unint64_t v14 = (unsigned __int16 *)v4;
    }
    else {
      unint64_t v14 = (unsigned __int16 *)v8;
    }
    if (result == -1)
    {
      unint64_t v10 = v3;
      uint64_t v8 = 0;
    }
    else
    {
      uint64_t v8 = v12;
    }
    v23[0] = v14;
    v23[1] = v10;
    if (result == -1) {
      unint64_t v3 = 0;
    }
    else {
      unint64_t v3 = v13;
    }
    uint64_t v24 = (unsigned char *)v8;
    unint64_t v25 = v3;
    if (v10 == 4)
    {
      if (*(_DWORD *)v14 != 1953723757) {
        goto LABEL_51;
      }
      int v9 = 1;
    }
    else
    {
      if (v10 != 3
        || ((v15 = *v14, int v16 = *((unsigned __int8 *)v14 + 2), v15 == 24941) ? (v17 = v16 == 121) : (v17 = 0), !v17))
      {
LABEL_51:
        v19[0] = "invalid StackLifetime parameter '{0}' ";
        v19[1] = 38;
        void v19[2] = &v21;
        void v19[3] = 1;
        v20[0] = &unk_1F2617F90;
        v20[1] = v23;
        int v21 = v20;
        sub_1CD465B2C((uint64_t)v19, &__p);
        llvm::inconvertibleErrorCode(v18);
        operator new();
      }
      int v9 = 0;
    }
    unint64_t v4 = (unsigned char *)v8;
  }
  while (v3);
LABEL_50:
  *(unsigned char *)(v5 + 8) &= ~1u;
  *(_DWORD *)unint64_t v5 = v9;
  return result;
}

void sub_1CCCA0E44()
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  v0[0] = v1;
  v0[1] = (void *)0x600000000;
  v1[12] = 0;
  long long v2 = 0u;
  long long v3 = 0u;
  long long v4 = 0u;
  sub_1CCCAEC10((uint64_t)v0);
}

unint64_t sub_1CCCA0FD8(unint64_t result, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = a3;
  long long v4 = (unsigned char *)a2;
  unint64_t v25 = result;
  if (a3 >= 0x14)
  {
    if (*(void *)a2 != 0x6C2D656C706D6973
      || *(void *)(a2 + 8) != 0x77736E752D706F6FLL
      || *(_DWORD *)(a2 + 16) != 1751348329)
    {
      goto LABEL_12;
    }
    long long v4 = (unsigned char *)(a2 + 20);
    unint64_t v3 = a3 - 20;
  }
  if (!v3) {
    goto LABEL_20;
  }
LABEL_12:
  if (*v4 != 60)
  {
    uint64_t v7 = (uint64_t)v4;
LABEL_24:
    uint64_t v32 = v4;
    unint64_t v33 = v3;
    goto LABEL_25;
  }
  if (v3 == 1) {
    goto LABEL_20;
  }
  uint64_t v7 = (uint64_t)(v4 + 1);
  if (v4[v3 - 1] != 62)
  {
    ++v4;
    --v3;
    goto LABEL_24;
  }
  if (v3 - 1 >= v3 - 2) {
    v3 -= 2;
  }
  else {
    --v3;
  }
  uint64_t v32 = v4 + 1;
  unint64_t v33 = v3;
  if (v3)
  {
    ++v4;
LABEL_25:
    unsigned __int8 v8 = 0;
    __int16 v9 = 1;
    while (1)
    {
      LOBYTE(v26[0]) = 59;
      unint64_t result = llvm::StringRef::find((uint64_t *)&v32, (char *)v26, 1uLL, 0);
      if (v3 >= result) {
        unint64_t v10 = result;
      }
      else {
        unint64_t v10 = v3;
      }
      if (v3 >= result + 1) {
        unint64_t v11 = result + 1;
      }
      else {
        unint64_t v11 = v3;
      }
      uint64_t v12 = v7 + v11;
      unint64_t v13 = v3 - v11;
      if (result == -1) {
        unint64_t v14 = v4;
      }
      else {
        unint64_t v14 = (unsigned char *)v7;
      }
      if (result == -1) {
        unint64_t v15 = v3;
      }
      else {
        unint64_t v15 = v10;
      }
      if (result == -1) {
        uint64_t v7 = 0;
      }
      else {
        uint64_t v7 = v12;
      }
      int v30 = v14;
      unint64_t v31 = v15;
      if (result == -1) {
        unint64_t v3 = 0;
      }
      else {
        unint64_t v3 = v13;
      }
      uint64_t v32 = (unsigned char *)v7;
      unint64_t v33 = v3;
      if (v15 >= 3 && (*(_WORD *)v14 == 28526 ? (BOOL v16 = v14[2] == 45) : (BOOL v16 = 0), v16))
      {
        __int16 v17 = 0;
        v14 += 3;
        int v30 = v14;
        unint64_t v31 = v15 - 3;
        v15 -= 3;
      }
      else
      {
        __int16 v17 = 1;
      }
      if (v15 == 7)
      {
        int v21 = *(_DWORD *)v14;
        int v22 = *(_DWORD *)(v14 + 3);
        BOOL v23 = v21 == 1986622068 && v22 == 1818323318;
        __int16 v9 = v17;
        if (!v23)
        {
LABEL_65:
          v26[0] = "invalid LoopUnswitch pass parameter '{0}' ";
          v26[1] = 42;
          v26[2] = &v28;
          v26[3] = 1;
          v27[0] = &unk_1F2617F90;
          v27[1] = &v30;
          BOOL v28 = v27;
          sub_1CD465B2C((uint64_t)v26, &__p);
          llvm::inconvertibleErrorCode(v24);
          operator new();
        }
      }
      else
      {
        if (v15 != 10) {
          goto LABEL_65;
        }
        uint64_t v18 = *(void *)v14;
        int v19 = *((unsigned __int16 *)v14 + 4);
        BOOL v20 = v18 == 0x69766972746E6F6ELL && v19 == 27745;
        unsigned __int8 v8 = v17;
        if (!v20) {
          goto LABEL_65;
        }
      }
      long long v4 = (unsigned char *)v7;
      if (!v3) {
        goto LABEL_21;
      }
    }
  }
LABEL_20:
  unsigned __int8 v8 = 0;
  __int16 v9 = 1;
LABEL_21:
  *(unsigned char *)(v25 + 8) &= ~1u;
  *(_WORD *)unint64_t v25 = v8 | (unsigned __int16)(v9 << 8);
  return result;
}

unint64_t sub_1CCCA12F0(unint64_t result, unsigned char *__s1, size_t a3, void *__s2, size_t __n)
{
  unint64_t v5 = a3;
  unint64_t v6 = __s1;
  uint64_t v7 = result;
  if (a3 >= __n)
  {
    if (!__n || (unint64_t result = memcmp(__s1, __s2, __n), !result))
    {
      if (v5 >= __n) {
        size_t v9 = __n;
      }
      else {
        size_t v9 = v5;
      }
      v6 += v9;
      v5 -= v9;
    }
  }
  if (!v5) {
    goto LABEL_17;
  }
  if (*v6 != 60)
  {
    uint64_t v10 = (uint64_t)v6;
    goto LABEL_21;
  }
  if (v5 == 1)
  {
LABEL_17:
    int v11 = dword_1EBD0B5F8;
    int v12 = dword_1EBD0B6B8;
    goto LABEL_18;
  }
  uint64_t v10 = (uint64_t)(v6 + 1);
  if (v6[v5 - 1] == 62)
  {
    if (v5 - 1 >= v5 - 2) {
      v5 -= 2;
    }
    else {
      --v5;
    }
    uint64_t v32 = v6 + 1;
    unint64_t v33 = v5;
    int v11 = dword_1EBD0B5F8;
    int v12 = dword_1EBD0B6B8;
    if (v5)
    {
      int v25 = dword_1EBD0B5F8;
      ++v6;
      goto LABEL_22;
    }
LABEL_18:
    BOOL v13 = 1;
    goto LABEL_51;
  }
  ++v6;
  --v5;
LABEL_21:
  uint64_t v32 = v6;
  unint64_t v33 = v5;
  int v25 = dword_1EBD0B5F8;
  int v12 = dword_1EBD0B6B8;
  do
  {
LABEL_22:
    LOBYTE(v26[0]) = 59;
    unint64_t result = llvm::StringRef::find((uint64_t *)&v32, (char *)v26, 1uLL, 0);
    if (v5 >= result) {
      unint64_t v14 = result;
    }
    else {
      unint64_t v14 = v5;
    }
    if (v5 >= result + 1) {
      unint64_t v15 = result + 1;
    }
    else {
      unint64_t v15 = v5;
    }
    uint64_t v16 = v10 + v15;
    unint64_t v17 = v5 - v15;
    if (result == -1) {
      uint64_t v18 = (unsigned __int16 *)v6;
    }
    else {
      uint64_t v18 = (unsigned __int16 *)v10;
    }
    if (result == -1) {
      unint64_t v19 = v5;
    }
    else {
      unint64_t v19 = v14;
    }
    if (result == -1) {
      uint64_t v10 = 0;
    }
    else {
      uint64_t v10 = v16;
    }
    int v30 = v18;
    unint64_t v31 = v19;
    if (result == -1) {
      unint64_t v5 = 0;
    }
    else {
      unint64_t v5 = v17;
    }
    uint64_t v32 = (unsigned char *)v10;
    unint64_t v33 = v5;
    if (v19 < 3) {
      goto LABEL_52;
    }
    int v20 = *v18 ^ 0x6F6E | *((unsigned __int8 *)v18 + 2) ^ 0x2D;
    if (!v20)
    {
      uint64_t v18 = (unsigned __int16 *)((char *)v18 + 3);
      int v30 = v18;
      unint64_t v31 = v19 - 3;
      v19 -= 3;
    }
    if (v19 != 16
      || ((v22 = *(void *)v18, uint64_t v21 = *((void *)v18 + 1), v22 == 0x657073776F6C6C61)
        ? (BOOL v23 = v21 == 0x6E6F6974616C7563)
        : (BOOL v23 = 0),
          !v23))
    {
LABEL_52:
      v26[0] = "invalid LICM pass parameter '{0}' ";
      v26[1] = 34;
      v26[2] = &v28;
      v26[3] = 1;
      v27[0] = &unk_1F2617F90;
      v27[1] = &v30;
      BOOL v28 = v27;
      sub_1CD465B2C((uint64_t)v26, &__p);
      llvm::inconvertibleErrorCode(v24);
      operator new();
    }
    unint64_t v6 = (unsigned char *)v10;
  }
  while (v5);
  BOOL v13 = v20 != 0;
  int v11 = v25;
LABEL_51:
  *(unsigned char *)(v7 + 16) &= ~1u;
  *(_DWORD *)uint64_t v7 = v11;
  *(_DWORD *)(v7 + 4) = v12;
  *(unsigned char *)(v7 + 8) = v13;
  return result;
}

void llvm::PassBuilder::parseCGSCCPass(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = MEMORY[0x1F4188790](a1, a2, a3, a4);
  uint64_t v7 = (uint64_t *)v5;
  size_t v9 = v8;
  uint64_t v10 = v4;
  int v12 = v11;
  uint64_t v365 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = *(void *)(v5 + 16);
  uint64_t v14 = *(void *)(v5 + 24);
  uint64_t v16 = *(void *)v5;
  size_t v15 = *(void *)(v5 + 8);
  if (v13 == v14)
  {
    if (v15 == 20)
    {
      if (*(void *)v16 == 0x3C65726975716572
        && *(void *)(v16 + 8) == 0x67632D706F2D6F6ELL
        && *(_DWORD *)(v16 + 16) == 1046700915)
      {
        operator new();
      }
LABEL_42:
      int v39 = 0;
      int v40 = 0;
      int v41 = 0;
      int v42 = 0;
      int v43 = 0;
      int v44 = 0;
      int v45 = 0;
      int v46 = 0;
      int v47 = 0;
      int v48 = 0;
    }
    else
    {
      int v39 = 0;
      int v40 = 0;
      int v41 = 0;
      int v42 = 0;
      int v43 = 0;
      int v44 = 0;
      int v45 = 0;
      int v46 = 0;
      int v47 = 0;
      int v48 = 0;
      switch(v15)
      {
        case 0xAuLL:
          if (*(void *)v16 == 0x6C70732D6F726F63 && *(_WORD *)(v16 + 8) == 29801)
          {
            LOBYTE(v322[0]) = 0;
            sub_1CD70D13C();
          }
          int v39 = 0;
          int v40 = 0;
          int v41 = 0;
          int v42 = 0;
          int v43 = 0;
          int v44 = 0;
          int v45 = 0;
          int v46 = 0;
          int v47 = 0;
          int v48 = 1;
          break;
        case 0xBuLL:
          if (*(void *)v16 == 0x67632D706F2D6F6ELL && *(void *)(v16 + 3) == 0x63637367632D706FLL) {
            operator new();
          }
          int v40 = 0;
          int v41 = 0;
          int v42 = 0;
          int v43 = 0;
          int v44 = 0;
          int v45 = 0;
          int v46 = 0;
          int v47 = 0;
          int v48 = 0;
          int v39 = 1;
          break;
        case 0xCuLL:
          if (*(void *)v16 == 0x6F6D6F7270677261 && *(_DWORD *)(v16 + 8) == 1852795252)
          {
            LODWORD(v322[0]) = 3;
            sub_1CD70CE88();
          }
          int v39 = 0;
          int v40 = 0;
          int v42 = 0;
          int v43 = 0;
          int v44 = 0;
          int v45 = 0;
          int v46 = 0;
          int v47 = 0;
          int v48 = 0;
          int v41 = 1;
          break;
        case 0xEuLL:
          if (*(void *)v16 == 0x6E6F6974636E7566 && *(void *)(v16 + 6) == 0x73727474612D6E6FLL) {
            sub_1CD70CFAC();
          }
          int v39 = 0;
          int v41 = 0;
          int v42 = 0;
          int v43 = 0;
          int v44 = 0;
          int v45 = 0;
          int v46 = 0;
          int v47 = 0;
          int v48 = 0;
          int v40 = 1;
          break;
        case 0xFuLL:
          if (*(void *)v16 == 0x6164696C61766E69 && *(void *)(v16 + 7) == 0x3E6C6C613C657461) {
            sub_1CD70CF28();
          }
          int v39 = 0;
          int v40 = 0;
          int v41 = 0;
          int v42 = 0;
          int v43 = 0;
          int v44 = 0;
          int v45 = 0;
          int v47 = 0;
          int v48 = 0;
          int v46 = 1;
          break;
        case 0x10uLL:
          if (*(void *)v16 == 0x7475626972747461 && *(void *)(v16 + 8) == 0x63637367632D726FLL) {
            sub_1CD70D034();
          }
          if (*(void *)v16 == 0x6F2D706D6E65706FLL && *(void *)(v16 + 8) == 0x63637367632D7470) {
            sub_1CD70D0B8();
          }
          int v39 = 0;
          int v40 = 0;
          int v41 = 0;
          int v42 = 0;
          int v43 = 0;
          int v44 = 0;
          int v45 = 0;
          int v46 = 0;
          int v48 = 0;
          int v47 = 1;
          break;
        case 0x12uLL:
          if (*(void *)v16 == 0x3C65726975716572
            && *(void *)(v16 + 8) == 0x786F72702D6D6166
            && *(_WORD *)(v16 + 16) == 15993)
          {
            sub_1CD70CC78();
          }
          int v39 = 0;
          int v40 = 0;
          int v41 = 0;
          int v42 = 0;
          int v44 = 0;
          int v45 = 0;
          int v46 = 0;
          int v47 = 0;
          int v48 = 0;
          int v43 = 1;
          break;
        case 0x15uLL:
          if (*(void *)v16 == 0x6164696C61766E69
            && *(void *)(v16 + 8) == 0x702D6D61663C6574
            && *(void *)(v16 + 13) == 0x3E79786F72702D6DLL)
          {
            sub_1CD70CCFC();
          }
          int v39 = 0;
          int v40 = 0;
          int v41 = 0;
          int v42 = 0;
          int v43 = 0;
          int v44 = 0;
          int v46 = 0;
          int v47 = 0;
          int v48 = 0;
          int v45 = 1;
          break;
        case 0x17uLL:
          if (*(void *)v16 == 0x6164696C61766E69
            && *(void *)(v16 + 8) == 0x706F2D6F6E3C6574
            && *(void *)(v16 + 15) == 0x3E63637367632D70)
          {
            operator new();
          }
          int v39 = 0;
          int v40 = 0;
          int v41 = 0;
          int v42 = 0;
          int v43 = 0;
          int v45 = 0;
          int v46 = 0;
          int v47 = 0;
          int v48 = 0;
          int v44 = 1;
          break;
        case 0x1DuLL:
          if (*(void *)v16 == 0x3C65726975716572
            && *(void *)(v16 + 8) == 0x736E692D73736170
            && *(void *)(v16 + 16) == 0x61746E656D757274
            && *(void *)(v16 + 21) == 0x3E6E6F697461746ELL)
          {
            sub_1CD70CD80();
          }
          int v39 = 0;
          int v40 = 0;
          int v41 = 0;
          int v43 = 0;
          int v44 = 0;
          int v45 = 0;
          int v46 = 0;
          int v47 = 0;
          int v48 = 0;
          int v42 = 1;
          break;
        case 0x20uLL:
          if (*(void *)v16 == 0x6164696C61766E69
            && *(void *)(v16 + 8) == 0x2D737361703C6574
            && *(void *)(v16 + 16) == 0x656D757274736E69
            && *(void *)(v16 + 24) == 0x3E6E6F697461746ELL)
          {
            sub_1CD70CE04();
          }
          goto LABEL_42;
        default:
          break;
      }
    }
    int v314 = v44;
    int v315 = v42;
    int v316 = v41;
    int v317 = v40;
    unsigned int v318 = v48;
    int v319 = v47;
    if (sub_1CCC9F0D4((char *)v16, v15, "inline", 6uLL))
    {
      sub_1CCC9F164((int)v322, (uint64_t (*)(char *, size_t))sub_1CCC9F264, (char *)v16, v15, "inline", 6uLL);
      if (((uint64_t)v322[1] & 1) == 0)
      {
        *(void *)&long long v362 = 0;
        BYTE8(v362) = v322[0];
        sub_1CD66B36C();
      }
      goto LABEL_45;
    }
    if (v15 == 7)
    {
      BOOL v65 = *(_DWORD *)v16 == 1697472865 && *(_DWORD *)(v16 + 3) == 1818326629;
      int v67 = v317;
      unsigned int v66 = (llvm *)v318;
      int v68 = v319;
      if (v65)
      {
        long long v325 = 0u;
        memset(v326, 0, 24);
        long long v323 = 0u;
        long long v324 = 0u;
        memset(v322, 0, sizeof(v322));
        sub_1CD70D1C8();
      }
      int v69 = v45;
    }
    else
    {
      int v67 = v317;
      unsigned int v66 = (llvm *)v318;
      int v68 = v319;
      int v69 = v45;
      if (v15 == 4)
      {
        int v71 = v316;
        if (*(_DWORD *)v16 == 1701012577) {
          operator new();
        }
        int v72 = 1;
        if (!v43)
        {
LABEL_103:
          if (v15 == 22)
          {
            BOOL v75 = *(void *)v16 == 0x6973736572676761 && *(void *)(v16 + 8) == 0x6374736E692D6576;
            if (v75 && *(void *)(v16 + 14) == 0x656E69626D6F6374) {
              operator new();
            }
          }
          if (v67)
          {
            if (*(void *)v16 == 0x622D656D75737361 && *(void *)(v16 + 6) == 0x7265646C6975622DLL) {
              operator new();
            }
          }
          if (v46)
          {
            if (*(void *)v16 == 0x732D656D75737361 && *(void *)(v16 + 7) == 0x7966696C706D6973) {
              operator new();
            }
          }
          if (v15 == 26)
          {
            BOOL v79 = *(void *)v16 == 0x6E656D6E67696C61 && *(void *)(v16 + 8) == 0x612D6D6F72662D74;
            BOOL v80 = v79 && *(void *)(v16 + 16) == 0x6F6974706D757373;
            if (v80 && *(_WORD *)(v16 + 24) == 29550) {
              operator new();
            }
          }
          if (v43)
          {
            BOOL v82 = *(void *)v16 == 0x697461746F6E6E61 && *(void *)(v16 + 8) == 0x72616D65722D6E6FLL;
            if (v82 && *(_WORD *)(v16 + 16) == 29547) {
              operator new();
            }
          }
          if (v72 && *(_DWORD *)v16 == 1701012578) {
            operator new();
          }
          if (v46)
          {
            if (*(void *)v16 == 0x632D73646E756F62 && *(void *)(v16 + 7) == 0x676E696B63656863) {
              operator new();
            }
          }
          if (v68)
          {
            if (*(void *)v16 == 0x72632D6B61657262 && *(void *)(v16 + 8) == 0x73656764652D7469) {
              operator new();
            }
          }
          if (v43)
          {
            BOOL v86 = *(void *)v16 == 0x657469736C6C6163 && *(void *)(v16 + 8) == 0x697474696C70732DLL;
            if (v86 && *(_WORD *)(v16 + 16) == 26478) {
              operator new();
            }
          }
          if (v66)
          {
            if (*(void *)v16 == 0x696F6874736E6F63 && *(_WORD *)(v16 + 8) == 29811)
            {
              bzero(v322, 0x15D8uLL);
              *(void *)&long long v327 = &v328;
              HIDWORD(v327) = 8;
              long long v355 = 0u;
              int v356 = 0;
              long long v357 = 0u;
              memset(v358, 0, sizeof(v358));
              uint64_t v359 = 0;
              uint64_t v361 = 0;
              uint64_t v360 = 0;
              sub_1CD70D28C((uint64_t)&v362, (uint64_t)v322, v257, v258);
            }
          }
          if (v15 == 22)
          {
            if (*(void *)v16 == 0x69617274736E6F63
              && *(void *)(v16 + 8) == 0x696D696C652D746ELL
              && *(void *)(v16 + 14) == 0x6E6F6974616E696DLL)
            {
              operator new();
            }
          }
          else if (v15 == 3)
          {
            if (*(_WORD *)v16 == 26723 && *(unsigned char *)(v16 + 2) == 114)
            {
              sub_1CCAE03E4();
              operator new();
            }
            int v92 = 1;
            if (!v66)
            {
LABEL_188:
              if (v71)
              {
                if (*(void *)v16 == 0x656C632D6F726F63 && *(_DWORD *)(v16 + 8) == 1886744161) {
                  operator new();
                }
              }
              if (v15 == 22)
              {
                BOOL v95 = *(void *)v16 == 0x74616C6572726F63 && *(void *)(v16 + 8) == 0x61706F72702D6465;
                if (v95 && *(void *)(v16 + 14) == 0x6E6F697461676170) {
                  operator new();
                }
              }
              if (v92)
              {
                if (*(_WORD *)v16 == 25444 && *(unsigned char *)(v16 + 2) == 101) {
                  operator new();
                }
              }
              if (v43)
              {
                BOOL v98 = *(void *)v16 == 0x706D756A2D616664 && *(void *)(v16 + 8) == 0x696461657268742DLL;
                if (v98 && *(_WORD *)(v16 + 16) == 26478) {
                  operator new();
                }
              }
              if (v15 == 13 && *(void *)v16 == 0x2D6D65722D766964 && *(void *)(v16 + 5) == 0x73726961702D6D65) {
                operator new();
              }
              if (v92)
              {
                if (*(_WORD *)v16 == 29540 && *(unsigned char *)(v16 + 2) == 101) {
                  operator new();
                }
              }
              if (v15 == 7 && *(_DWORD *)v16 == 762605412 && *(_DWORD *)(v16 + 3) == 1734763309) {
                operator new();
              }
              if (v71)
              {
                if (*(void *)v16 == 0x2D6766632D746F64 && *(_DWORD *)(v16 + 8) == 2037149295) {
                  operator new();
                }
              }
              if (v15 == 7 && *(_DWORD *)v16 == 762605412 && *(_DWORD *)(v16 + 3) == 1836016685) {
                operator new();
              }
              if (v71)
              {
                if (*(void *)v16 == 0x2D6D6F642D746F64 && *(_DWORD *)(v16 + 8) == 2037149295) {
                  operator new();
                }
              }
              if (v46)
              {
                if (*(void *)v16 == 0x657272692D786966 && *(void *)(v16 + 7) == 0x656C626963756465) {
                  operator new();
                }
              }
              if (v66)
              {
                if (*(void *)v16 == 0x636E657474616C66 && *(_WORD *)(v16 + 8) == 26470) {
                  operator new();
                }
              }
              switch(v15)
              {
                case 0x14uLL:
                  if (*(void *)v16 == 0x6175672D656B616DLL
                    && *(void *)(v16 + 8) == 0x6C7078652D736472
                    && *(_DWORD *)(v16 + 16) == 1953063785)
                  {
                    operator new();
                  }
LABEL_272:
                  int v111 = 0;
                  int v112 = 0;
                  if (!v66) {
                    goto LABEL_277;
                  }
                  break;
                case 8uLL:
                  if (*(void *)v16 == 0x6B6E69732D6E7667) {
                    operator new();
                  }
                  int v112 = 0;
                  int v111 = 1;
                  if (!v66) {
                    goto LABEL_277;
                  }
                  break;
                case 9uLL:
                  if (*(void *)v16 == 0x73696F682D6E7667 && *(unsigned char *)(v16 + 8) == 116) {
                    operator new();
                  }
                  int v111 = 0;
                  int v112 = 1;
                  if (!v66)
                  {
LABEL_277:
                    if (v15 == 20)
                    {
                      BOOL v114 = *(void *)v16 == 0x64612D7265666E69 && *(void *)(v16 + 8) == 0x70732D7373657264;
                      if (v114 && *(_DWORD *)(v16 + 16) == 1936024417) {
                        operator new();
                      }
                    }
                    if (v39)
                    {
                      if (*(void *)v16 == 0x626D6F6374736E69 && *(void *)(v16 + 3) == 0x656E69626D6F6374)
                      {
                        v322[0] = &v322[2];
                        v322[1] = (void *)0x10000000000;
                        v349[86] = 0u;
                        int v350 = 0;
                        uint64_t v351 = 1;
                        uint64_t v270 = 262;
                        int64x2_t v271 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
                        do
                        {
                          *(int64x2_t *)&v322[v270] = v271;
                          v270 += 2;
                        }
                        while (v270 != 278);
                        v352 = v354;
                        uint64_t v353 = 0x1000000000;
                        v354[32] = dword_1EBD09170;
                        sub_1CD70D368();
                      }
                    }
                    if (v112)
                    {
                      if (*(void *)v16 == 0x6E756F6374736E69 && *(unsigned char *)(v16 + 8) == 116) {
                        operator new();
                      }
                    }
                    if (v71)
                    {
                      if (*(void *)v16 == 0x706D697374736E69 && *(_DWORD *)(v16 + 8) == 2036754796) {
                        operator new();
                      }
                    }
                    if (v46)
                    {
                      if (*(void *)v16 == 0x6164696C61766E69 && *(void *)(v16 + 7) == 0x3E6C6C613C657461) {
                        operator new();
                      }
                    }
                    if (v72 && *(_DWORD *)v16 == 1701016169) {
                      operator new();
                    }
                    if (v112)
                    {
                      if (*(void *)v16 == 0x6E693274616F6C66 && *(unsigned char *)(v16 + 8) == 116)
                      {
                        long long v334 = 0uLL;
                        v331 = 0;
                        long long v329 = 0u;
                        long long v330 = 0u;
                        long long v328 = 0u;
                        long long v323 = 0u;
                        memset(v322, 0, sizeof(v322));
                        *(void *)&long long v324 = 1;
                        *(int64x2_t *)((char *)&v326[1] + 8) = vdupq_n_s64(0xFFFFFFFFFFFFF000);
                        *((void *)&v326[2] + 1) = (char *)&v327 + 8;
                        long long v327 = 0x800000000uLL;
                        long long v333 = 0uLL;
                        v332 = &v333;
                        long long v335 = 0uLL;
                        long long v337 = 0uLL;
                        long long v336 = 0uLL;
                        sub_1CD70D438();
                      }
                    }
                    if (v67)
                    {
                      if (*(void *)v16 == 0x75662D706F2D6F6ELL && *(void *)(v16 + 6) == 0x6E6F6974636E7566) {
                        operator new();
                      }
                    }
                    if (v15 == 19)
                    {
                      BOOL v122 = *(void *)v16 == 0x736C6C616362696CLL && *(void *)(v16 + 8) == 0x776B6E697268732DLL;
                      if (v122 && *(void *)(v16 + 11) == 0x706172776B6E6972) {
                        operator new();
                      }
                    }
                    if (v72 && *(_DWORD *)v16 == 1953393004) {
                      operator new();
                    }
                    if (v15 == 19)
                    {
                      BOOL v124 = *(void *)v16 == 0x742D7463656A6E69 && *(void *)(v16 + 8) == 0x697070616D2D696CLL;
                      if (v124 && *(void *)(v16 + 11) == 0x73676E697070616DLL) {
                        operator new();
                      }
                    }
                    if (v112)
                    {
                      if (*(void *)v16 == 0x656D616E74736E69 && *(unsigned char *)(v16 + 8) == 114) {
                        operator new();
                      }
                    }
                    if (v39)
                    {
                      if (*(void *)v16 == 0x6F74617265776F6CLL && *(void *)(v16 + 3) == 0x63696D6F74617265) {
                        operator new();
                      }
                    }
                    if (v71)
                    {
                      if (*(void *)v16 == 0x78652D7265776F6CLL && *(_DWORD *)(v16 + 8) == 1952671088) {
                        operator new();
                      }
                    }
                    if (v69)
                    {
                      BOOL v129 = *(void *)v16 == 0x75672D7265776F6CLL && *(void *)(v16 + 8) == 0x72746E692D647261;
                      if (v129 && *(void *)(v16 + 13) == 0x6369736E6972746ELL) {
                        operator new();
                      }
                    }
                    if (v15 == 25)
                    {
                      if (*(void *)v16 == 0x6F632D7265776F6CLL
                        && *(void *)(v16 + 8) == 0x692D746E6174736ELL
                        && *(void *)(v16 + 16) == 0x6369736E6972746ELL
                        && *(unsigned char *)(v16 + 24) == 115)
                      {
                        operator new();
                      }
                      if (*(void *)v16 == 0x69772D7265776F6CLL
                        && *(void *)(v16 + 8) == 0x2D656C62616E6564
                        && *(void *)(v16 + 16) == 0x6F697469646E6F63
                        && *(unsigned char *)(v16 + 24) == 110)
                      {
                        operator new();
                      }
                    }
                    if (v67)
                    {
                      if (*(void *)v16 == 0x69772D6472617567 && *(void *)(v16 + 6) == 0x676E696E65646977) {
                        operator new();
                      }
                    }
                    if (v69)
                    {
                      BOOL v138 = *(void *)v16 == 0x6F74732D64616F6CLL && *(void *)(v16 + 8) == 0x6F746365762D6572;
                      if (v138 && *(void *)(v16 + 13) == 0x72657A69726F7463) {
                        operator new();
                      }
                    }
                    if (v15 == 13
                      && *(void *)v16 == 0x6D69732D706F6F6CLL
                      && *(void *)(v16 + 5) == 0x7966696C706D6973)
                    {
                      operator new();
                    }
                    if (v112)
                    {
                      if (*(void *)v16 == 0x6E69732D706F6F6CLL && *(unsigned char *)(v16 + 8) == 107) {
                        operator new();
                      }
                    }
                    if (v39)
                    {
                      if (*(void *)v16 == 0x766E697265776F6CLL && *(void *)(v16 + 3) == 0x656B6F766E697265) {
                        operator new();
                      }
                      if (*(void *)v16 == 0x6977737265776F6CLL && *(void *)(v16 + 3) == 0x6863746977737265) {
                        operator new();
                      }
                    }
                    if (v15 == 7 && *(_DWORD *)v16 == 846030189 && *(_DWORD *)(v16 + 3) == 1734701618) {
                      operator new();
                    }
                    if (v112)
                    {
                      if (*(void *)v16 == 0x706F7970636D656DLL && *(unsigned char *)(v16 + 8) == 116) {
                        operator new();
                      }
                    }
                    if (v66)
                    {
                      if (*(void *)v16 == 0x6D6369656772656DLL && *(_WORD *)(v16 + 8) == 29552) {
                        operator new();
                      }
                    }
                    if (v39)
                    {
                      if (*(void *)v16 == 0x746572656772656DLL && *(void *)(v16 + 3) == 0x6E72757465726567) {
                        operator new();
                      }
                    }
                    if (v68)
                    {
                      if (*(void *)v16 == 0x6165722D7972616ELL && *(void *)(v16 + 8) == 0x65746169636F7373)
                      {
                        *(void *)&long long v325 = 0;
                        long long v323 = 0u;
                        long long v324 = 0u;
                        memset(v322, 0, sizeof(v322));
                        sub_1CD70D4F8();
                      }
                    }
                    if (v15 == 6 && *(_DWORD *)v16 == 1735877998 && *(_WORD *)(v16 + 4) == 28278) {
                      operator new();
                    }
                    if (v67)
                    {
                      if (*(void *)v16 == 0x7268742D706D756ALL && *(void *)(v16 + 6) == 0x676E696461657268)
                      {
                        *((void *)&v323 + 1) = 0;
                        *(void *)&long long v324 = 0;
                        WORD4(v324) = 0;
                        *(void *)&long long v325 = v326;
                        *((void *)&v325 + 1) = 0x1000000000;
                        *((void *)&v333 + 1) = 0;
                        *(void *)&long long v334 = 0;
                        *(void *)&long long v333 = (char *)&v333 + 8;
                        LOBYTE(v335) = byte_1EBD0B538;
                        HIDWORD(v334) = dword_1EBD0B478;
                        sub_1CD70D5C0();
                      }
                    }
                    if (v15 == 25)
                    {
                      if (*(void *)v16 == 0x6C6C616974726170
                        && *(void *)(v16 + 8) == 0x656E696C6E692D79
                        && *(void *)(v16 + 16) == 0x6C6C616362696C2DLL
                        && *(unsigned char *)(v16 + 24) == 115)
                      {
                        operator new();
                      }
                    }
                    else if (v15 == 5)
                    {
                      if (*(_DWORD *)v16 == 1936941932 && *(unsigned char *)(v16 + 4) == 97) {
                        operator new();
                      }
                      int v173 = 1;
LABEL_542:
                      if (v43)
                      {
                        BOOL v174 = *(void *)v16 == 0x7461642D706F6F6CLL && *(void *)(v16 + 8) == 0x7465666572702D61;
                        if (v174 && *(_WORD *)(v16 + 16) == 26723) {
                          operator new();
                        }
                      }
                      if (v67)
                      {
                        if (*(void *)v16 == 0x616F6C2D706F6F6CLL && *(void *)(v16 + 6) == 0x6D696C652D64616FLL) {
                          operator new();
                        }
                      }
                      if (v39)
                      {
                        if (*(void *)v16 == 0x7375662D706F6F6CLL && *(void *)(v16 + 3) == 0x6E6F697375662D70) {
                          operator new();
                        }
                      }
                      if (v46)
                      {
                        if (*(void *)v16 == 0x7369642D706F6F6CLL && *(void *)(v16 + 7) == 0x6574756269727473) {
                          operator new();
                        }
                        if (*(void *)v16 == 0x7265762D706F6F6CLL && *(void *)(v16 + 7) == 0x676E696E6F697372) {
                          operator new();
                        }
                      }
                      if (v111 && *(void *)v16 == 0x6372612D636A626FLL) {
                        operator new();
                      }
                      if (v15 == 17)
                      {
                        BOOL v180 = *(void *)v16 == 0x6372612D636A626FLL && *(void *)(v16 + 8) == 0x636172746E6F632DLL;
                        if (v180 && *(unsigned char *)(v16 + 16) == 116) {
                          operator new();
                        }
                      }
                      if (v46)
                      {
                        if (*(void *)v16 == 0x6372612D636A626FLL && *(void *)(v16 + 7) == 0x646E617078652D63) {
                          operator new();
                        }
                      }
                      if (v15 == 13
                        && *(void *)v16 == 0x6F6D656D2D6F6770
                        && *(void *)(v16 + 5) == 0x74706F2D706F6D65)
                      {
                        operator new();
                      }
                      if (v173)
                      {
                        if (*(_DWORD *)v16 == 1852404336 && *(unsigned char *)(v16 + 4) == 116)
                        {
                          llvm::dbgs(v66);
                          operator new();
                        }
                      }
                      if (v43)
                      {
                        BOOL v185 = *(void *)v16 == 0x73613C746E697270 && *(void *)(v16 + 8) == 0x6E6F6974706D7573;
                        if (v185 && *(_WORD *)(v16 + 16) == 15987)
                        {
                          llvm::dbgs(v66);
                          operator new();
                        }
                      }
                      if (v15 == 17)
                      {
                        BOOL v187 = *(void *)v16 == 0x6C623C746E697270 && *(void *)(v16 + 8) == 0x716572662D6B636FLL;
                        if (v187 && *(unsigned char *)(v16 + 16) == 62)
                        {
                          llvm::dbgs(v66);
                          operator new();
                        }
                      }
                      if (v43)
                      {
                        BOOL v189 = *(void *)v16 == 0x72623C746E697270 && *(void *)(v16 + 8) == 0x6F72702D68636E61;
                        if (v189 && *(_WORD *)(v16 + 16) == 15970)
                        {
                          llvm::dbgs(v66);
                          operator new();
                        }
                      }
                      if (v15 == 17)
                      {
                        if (*(void *)v16 == 0x6F633C746E697270
                          && *(void *)(v16 + 8) == 0x6C65646F6D2D7473
                          && *(unsigned char *)(v16 + 16) == 62)
                        {
                          llvm::dbgs(v66);
                          operator new();
                        }
                      }
                      else if (v15 == 13 {
                             && *(void *)v16 == 0x79633C746E697270
                      }
                             && *(void *)(v16 + 5) == 0x3E73656C6379633CLL)
                      {
                        llvm::dbgs(v66);
                        operator new();
                      }
                      if (v112)
                      {
                        if (*(void *)v16 == 0x61643C746E697270 && *(unsigned char *)(v16 + 8) == 62)
                        {
                          llvm::dbgs(v66);
                          operator new();
                        }
                      }
                      if (v15 == 17)
                      {
                        BOOL v195 = *(void *)v16 == 0x69643C746E697270 && *(void *)(v16 + 8) == 0x65636E6567726576;
                        if (v195 && *(unsigned char *)(v16 + 16) == 62)
                        {
                          llvm::dbgs(v66);
                          operator new();
                        }
                      }
                      if (v67)
                      {
                        if (*(void *)v16 == 0x6F643C746E697270 && *(void *)(v16 + 6) == 0x3E656572746D6F64)
                        {
                          llvm::dbgs(v66);
                          operator new();
                        }
                      }
                      if (v43)
                      {
                        BOOL v198 = *(void *)v16 == 0x6F703C746E697270 && *(void *)(v16 + 8) == 0x6572746D6F647473;
                        if (v198 && *(_WORD *)(v16 + 16) == 15973)
                        {
                          llvm::dbgs(v66);
                          operator new();
                        }
                      }
                      if (v15 == 22)
                      {
                        if (*(void *)v16 == 0x65643C746E697270
                          && *(void *)(v16 + 8) == 0x7A697261656E696CLL
                          && *(void *)(v16 + 14) == 0x3E6E6F6974617A69)
                        {
                          llvm::dbgs(v66);
                          operator new();
                        }
                      }
                      else if (v15 == 20)
                      {
                        BOOL v202 = *(void *)v16 == 0x65643C746E697270 && *(void *)(v16 + 8) == 0x622D6465646E616DLL;
                        if (v202 && *(_DWORD *)(v16 + 16) == 1047753833)
                        {
                          llvm::dbgs(v66);
                          operator new();
                        }
                      }
                      if (v43)
                      {
                        BOOL v204 = *(void *)v16 == 0x6F643C746E697270 && *(void *)(v16 + 8) == 0x6569746E6F72666DLL;
                        if (v204 && *(_WORD *)(v16 + 16) == 15986)
                        {
                          llvm::dbgs(v66);
                          operator new();
                        }
                      }
                      if (v15 == 22)
                      {
                        BOOL v206 = *(void *)v16 == 0x75663C746E697270 && *(void *)(v16 + 8) == 0x65706F72702D636ELL;
                        if (v206 && *(void *)(v16 + 14) == 0x3E73656974726570)
                        {
                          llvm::dbgs(v66);
                          operator new();
                        }
                      }
                      if (v43)
                      {
                        BOOL v208 = *(void *)v16 == 0x6E693C746E697270 && *(void *)(v16 + 8) == 0x736F632D656E696CLL;
                        if (v208 && *(_WORD *)(v16 + 16) == 15988)
                        {
                          llvm::dbgs(v66);
                          operator new();
                        }
                      }
                      if (v315)
                      {
                        BOOL v210 = *(void *)v16 == 0x6E693C746E697270 && *(void *)(v16 + 8) == 0x69732D72656E696CLL;
                        BOOL v211 = v210 && *(void *)(v16 + 16) == 0x6D697473652D657ALL;
                        if (v211 && *(void *)(v16 + 21) == 0x3E726F74616D6974)
                        {
                          llvm::dbgs(v66);
                          operator new();
                        }
                      }
                      if (v15 == 28)
                      {
                        BOOL v213 = *(void *)v16 == 0x70673C746E697270 && *(void *)(v16 + 8) == 0x6974636E75662D75;
                        BOOL v214 = v213 && *(void *)(v16 + 16) == 0x796C616E612D6E6FLL;
                        if (v214 && *(_DWORD *)(v16 + 24) == 1047751027)
                        {
                          llvm::dbgs(v66);
                          operator new();
                        }
                      }
                      if (v71)
                      {
                        if (*(void *)v16 == 0x6F6C3C746E697270 && *(_DWORD *)(v16 + 8) == 1047752815)
                        {
                          llvm::dbgs(v66);
                          operator new();
                        }
                      }
                      if (v68)
                      {
                        if (*(void *)v16 == 0x656D3C746E697270 && *(void *)(v16 + 8) == 0x3E61737379726F6DLL)
                        {
                          llvm::dbgs(v66);
                          operator new();
                        }
                      }
                      if (v314)
                      {
                        BOOL v218 = *(void *)v16 == 0x656D3C746E697270 && *(void *)(v16 + 8) == 0x2D61737379726F6DLL;
                        if (v218 && *(void *)(v16 + 15) == 0x3E72656B6C61772DLL)
                        {
                          llvm::dbgs(v66);
                          operator new();
                        }
                      }
                      if (v15 == 17)
                      {
                        BOOL v220 = *(void *)v16 == 0x68703C746E697270 && *(void *)(v16 + 8) == 0x7365756C61762D69;
                        if (v220 && *(unsigned char *)(v16 + 16) == 62)
                        {
                          llvm::dbgs(v66);
                          operator new();
                        }
                      }
                      if (v67)
                      {
                        if (*(void *)v16 == 0x65723C746E697270 && *(void *)(v16 + 6) == 0x3E736E6F69676572)
                        {
                          llvm::dbgs(v66);
                          operator new();
                        }
                      }
                      if (v314)
                      {
                        BOOL v223 = *(void *)v16 == 0x63733C746E697270 && *(void *)(v16 + 8) == 0x6F76652D72616C61;
                        if (v223 && *(void *)(v16 + 15) == 0x3E6E6F6974756C6FLL)
                        {
                          llvm::dbgs(v66);
                          operator new();
                        }
                      }
                      if (v15 == 25)
                      {
                        BOOL v225 = *(void *)v16 == 0x74733C746E697270 && *(void *)(v16 + 8) == 0x656661732D6B6361;
                        BOOL v226 = v225 && *(void *)(v16 + 16) == 0x6C61636F6C2D7974;
                        if (v226 && *(unsigned char *)(v16 + 24) == 62)
                        {
                          llvm::dbgs(v66);
                          operator new();
                        }
                      }
                      if (v68)
                      {
                        if (*(void *)v16 == 0x6C612D746E697270 && *(void *)(v16 + 8) == 0x737465732D736169)
                        {
                          llvm::dbgs(v66);
                          operator new();
                        }
                      }
                      if (v15 == 19)
                      {
                        if (*(void *)v16 == 0x72702D746E697270
                          && *(void *)(v16 + 8) == 0x6965746163696465
                          && *(void *)(v16 + 11) == 0x6F666E6965746163)
                        {
                          llvm::dbgs(v66);
                          operator new();
                        }
                      }
                      else if (v15 == 17)
                      {
                        BOOL v231 = *(void *)v16 == 0x756D2D746E697270 && *(void *)(v16 + 8) == 0x7475636578657473;
                        if (v231 && *(unsigned char *)(v16 + 16) == 101)
                        {
                          llvm::dbgs(v66);
                          operator new();
                        }
                      }
                      if (v46)
                      {
                        if (*(void *)v16 == 0x656D2D746E697270 && *(void *)(v16 + 7) == 0x7366657265646D65)
                        {
                          llvm::dbgs(v66);
                          operator new();
                        }
                      }
                      if (v39)
                      {
                        if (*(void *)v16 == 0x69636F7373616572 && *(void *)(v16 + 3) == 0x65746169636F7373)
                        {
                          bzero(v322, 0x230uLL);
                          for (uint64_t i = 15; i != 69; i += 3)
                          {
                            v274 = &v322[i];
                            *v274 = 0;
                            v274[1] = 0;
                            *((_DWORD *)v274 + 4) = 0;
                          }
                          sub_1CD70D704();
                        }
                      }
                      if (v314)
                      {
                        BOOL v235 = *(void *)v16 == 0x6E61646E75646572 && *(void *)(v16 + 8) == 0x6E692D6762642D74;
                        if (v235 && *(void *)(v16 + 15) == 0x6D696C652D74736ELL) {
                          operator new();
                        }
                      }
                      if (v15 == 7)
                      {
                        if (*(_DWORD *)v16 == 845636978 && *(_DWORD *)(v16 + 3) == 1835363634) {
                          operator new();
                        }
                      }
                      else if (v15 == 27)
                      {
                        BOOL v238 = *(void *)v16 == 0x7A6972616C616373 && *(void *)(v16 + 8) == 0x64656B73616D2D65;
                        BOOL v239 = v238 && *(void *)(v16 + 16) == 0x746E692D6D656D2DLL;
                        if (v239 && *(void *)(v16 + 19) == 0x6E6972746E692D6DLL) {
                          operator new();
                        }
                      }
                      if (v66)
                      {
                        if (*(void *)v16 == 0x7A6972616C616373 && *(_WORD *)(v16 + 8) == 29285) {
                          operator new();
                        }
                      }
                      if (v15 == 30)
                      {
                        BOOL v242 = *(void *)v16 == 0x6574617261706573 && *(void *)(v16 + 8) == 0x6F2D74736E6F632DLL;
                        BOOL v243 = v242 && *(void *)(v16 + 16) == 0x72662D7465736666;
                        if (v243 && *(void *)(v16 + 22) == 0x7065672D6D6F7266) {
                          operator new();
                        }
                      }
                      if (v72)
                      {
                        if (*(_DWORD *)v16 == 1885561715) {
                          operator new();
                        }
                        if (*(_DWORD *)v16 == 1802398067) {
                          operator new();
                        }
                      }
                      if (v67)
                      {
                        if (*(void *)v16 == 0x746365762D706C73 && *(void *)(v16 + 6) == 0x72657A69726F7463)
                        {
                          *(void *)&long long v329 = 0;
                          long long v327 = 0u;
                          long long v328 = 0u;
                          long long v325 = 0u;
                          memset(v326, 0, sizeof(v326));
                          long long v323 = 0u;
                          long long v324 = 0u;
                          memset(v322, 0, sizeof(v322));
                          sub_1CD70D798();
                        }
                      }
                      if (v72 && *(_DWORD *)v16 == 1920167027) {
                        operator new();
                      }
                      if (v69)
                      {
                        BOOL v246 = *(void *)v16 == 0x74616C7563657073 && *(void *)(v16 + 8) == 0x636578652D657669;
                        if (v246 && *(void *)(v16 + 13) == 0x6E6F697475636578) {
                          operator new();
                        }
                      }
                      if (v72 && *(_DWORD *)v16 == 1634693747)
                      {
                        bzero(v322, 0x2C0uLL);
                        *(void *)&long long v324 = &v325;
                        HIDWORD(v324) = 16;
                        v331 = &v333;
                        HIDWORD(v332) = 8;
                        long long v338 = 0u;
                        int v339 = 0;
                        int v340 = v342;
                        int v341 = 16;
                        memset(&v342[128], 0, 44);
                        v343 = v345;
                        int v344 = 2;
                        v345[1] = 0u;
                        int v346 = 0;
                        BOOL v347 = v349;
                        int v348 = 2;
                        sub_1CD70D8E8();
                      }
                      if (v43)
                      {
                        BOOL v248 = *(void *)v16 == 0x63672D7069727473 && *(void *)(v16 + 8) == 0x7461636F6C65722DLL;
                        if (v248 && *(_WORD *)(v16 + 16) == 29541) {
                          operator new();
                        }
                      }
                      if (v67)
                      {
                        if (*(void *)v16 == 0x7275746375727473 && *(void *)(v16 + 6) == 0x676663657A697275) {
                          operator new();
                        }
                      }
                      if (v71)
                      {
                        if (*(void *)v16 == 0x6C6C61636C696174 && *(_DWORD *)(v16 + 8) == 1835625573) {
                          operator new();
                        }
                      }
                      if (v68)
                      {
                        if (*(void *)v16 == 0x6F6C2D7966696E75 && *(void *)(v16 + 8) == 0x73746978652D706FLL) {
                          operator new();
                        }
                      }
                      if (v67)
                      {
                        if (*(void *)v16 == 0x632D726F74636576 && *(void *)(v16 + 6) == 0x656E69626D6F632DLL) {
                          operator new();
                        }
                      }
                      if (v15 == 6 && *(_DWORD *)v16 == 1769104758 && *(_WORD *)(v16 + 4) == 31078) {
                        operator new();
                      }
                      if (v46)
                      {
                        if (*(void *)v16 == 0x643C796669726576 && *(void *)(v16 + 7) == 0x3E656572746D6F64) {
                          operator new();
                        }
                      }
                      if (v15 == 13)
                      {
                        if (*(void *)v16 == 0x6C3C796669726576 && *(void *)(v16 + 5) == 0x3E73706F6F6C3C79) {
                          operator new();
                        }
                      }
                      else if (v15 == 17)
                      {
                        BOOL v259 = *(void *)v16 == 0x6D3C796669726576 && *(void *)(v16 + 8) == 0x61737379726F6D65;
                        if (v259 && *(unsigned char *)(v16 + 16) == 62) {
                          operator new();
                        }
                      }
                      if (v46)
                      {
                        if (*(void *)v16 == 0x723C796669726576 && *(void *)(v16 + 7) == 0x3E736E6F69676572) {
                          operator new();
                        }
                      }
                      if (v15 == 20)
                      {
                        if (*(void *)v16 == 0x733C796669726576
                          && *(void *)(v16 + 8) == 0x746E696F70656661
                          && *(_DWORD *)(v16 + 16) == 1047685421)
                        {
                          operator new();
                        }
                      }
                      else if (v15 == 24)
                      {
                        BOOL v264 = *(void *)v16 == 0x733C796669726576 && *(void *)(v16 + 8) == 0x76652D72616C6163;
                        if (v264 && *(void *)(v16 + 16) == 0x3E6E6F6974756C6FLL) {
                          operator new();
                        }
                      }
                      if (v111 && *(void *)v16 == 0x6766632D77656976) {
                        operator new();
                      }
                      if (v15 == 13
                        && *(void *)v16 == 0x6766632D77656976
                        && *(void *)(v16 + 5) == 0x796C6E6F2D676663)
                      {
                        operator new();
                      }
                      if (v111 && *(void *)v16 == 0x7473696F68736C74)
                      {
                        long long v323 = 0u;
                        long long v324 = 0u;
                        memset(v322, 0, sizeof(v322));
                        sub_1CD70D9A8();
                      }
                      if (v15 == 17)
                      {
                        BOOL v267 = *(void *)v16 == 0x726F66736E617274 && *(void *)(v16 + 8) == 0x6E696E7261772D6DLL;
                        if (v267 && *(unsigned char *)(v16 + 16) == 103) {
                          operator new();
                        }
                      }
                      if (v72 && *(_DWORD *)v16 == 1851880308) {
                        operator new();
                      }
                      if (v15 == 7 && *(_DWORD *)v16 == 1886217581 && *(_DWORD *)(v16 + 3) == 1718579824) {
                        operator new();
                      }
                      if (sub_1CCC9F0D4((char *)v16, v15, "early-cse", 9uLL))
                      {
                        sub_1CCC9F164((int)v322, (uint64_t (*)(char *, size_t))sub_1CCC9F28C, (char *)v16, v15, "early-cse", 9uLL);
                        if (((uint64_t)v322[1] & 1) == 0) {
                          operator new();
                        }
                      }
                      else if (sub_1CCC9F0D4((char *)v16, v15, "ee-instrument", 0xDuLL))
                      {
                        sub_1CCC9F164((int)v322, (uint64_t (*)(char *, size_t))sub_1CCC9F2B4, (char *)v16, v15, "ee-instrument", 0xDuLL);
                        if (((uint64_t)v322[1] & 1) == 0) {
                          operator new();
                        }
                      }
                      else if (sub_1CCC9F0D4((char *)v16, v15, "lower-matrix-intrinsics", 0x17uLL))
                      {
                        sub_1CCC9F164((int)v322, (uint64_t (*)(char *, size_t))sub_1CCC9F2DC, (char *)v16, v15, "lower-matrix-intrinsics", 0x17uLL);
                        if (((uint64_t)v322[1] & 1) == 0) {
                          operator new();
                        }
                      }
                      else if (sub_1CCC9F0D4((char *)v16, v15, "loop-unroll", 0xBuLL))
                      {
                        sub_1CCC9F304((unint64_t)v322, (void *)v16, v15, v272);
                        if ((v323 & 1) == 0) {
                          operator new();
                        }
                      }
                      else if (sub_1CCC9F0D4((char *)v16, v15, "msan", 4uLL))
                      {
                        sub_1CCC9F844((uint64_t)v322, (_DWORD *)v16, v15);
                        if (((uint64_t)v322[2] & 1) == 0) {
                          operator new();
                        }
                      }
                      else if (sub_1CCC9F0D4((char *)v16, v15, "simplifycfg", 0xBuLL))
                      {
                        sub_1CCC9FBCC((unint64_t)v322, (void *)v16, v15);
                        if (((uint64_t)v322[3] & 1) == 0)
                        {
                          long long v362 = *(_OWORD *)v322;
                          BOOL v363 = v322[2];
                          sub_1CCEDA240((uint64_t)&v362);
                          operator new();
                        }
                      }
                      else if (sub_1CCC9F0D4((char *)v16, v15, "loop-vectorize", 0xEuLL))
                      {
                        sub_1CCCA0278((unint64_t)v322, (void *)v16, v15);
                        if (((uint64_t)v322[1] & 1) == 0) {
                          operator new();
                        }
                      }
                      else
                      {
                        if (!sub_1CCC9F0D4((char *)v16, v15, "mldst-motion", 0xCuLL))
                        {
                          if (sub_1CCC9F0D4((char *)v16, v15, "gvn", 3uLL))
                          {
                            sub_1CCCA07D0((unint64_t)&v362, (unsigned char *)v16, v15);
                            if ((v363 & 1) == 0)
                            {
                              sub_1CD719FAC((uint64_t)v322, v362, SWORD4(v362));
                              sub_1CD70DA80();
                            }
                          }
                          else
                          {
                            BOOL v275 = sub_1CCC9F0D4((char *)v16, v15, "print<stack-lifetime>", 0x15uLL);
                            if (v275)
                            {
                              v276 = (llvm *)sub_1CCCA0B9C((unint64_t)v322, (void *)v16, v15);
                              if (((uint64_t)v322[1] & 1) == 0)
                              {
                                llvm::dbgs(v276);
                                operator new();
                              }
                              goto LABEL_45;
                            }
                            if (v316)
                            {
                              if (*(void *)v16 == 0x616C662D706F6F6CLL && *(_DWORD *)(v16 + 8) == 1852142708) {
                                sub_1CD70B7B4();
                              }
                            }
                            if (v319)
                            {
                              if (*(void *)v16 == 0x746E692D706F6F6CLL
                                && *(void *)(v16 + 8) == 0x65676E6168637265)
                              {
                                sub_1CD70B8D8();
                              }
                            }
                            if (v15 == 19)
                            {
                              BOOL v279 = *(void *)v16 == 0x726E752D706F6F6CLL
                                  && *(void *)(v16 + 8) == 0x2D646E612D6C6C6FLL;
                              if (v279 && *(void *)(v16 + 11) == 0x6D616A2D646E612DLL) {
                                sub_1CD70B9FC();
                              }
                            }
                            if (v317)
                            {
                              if (*(void *)v16 == 0x6F6C2D706F2D6F6ELL
                                && *(void *)(v16 + 6) == 0x7473656E706F6F6CLL)
                              {
                                sub_1CCCA0E44();
                              }
                            }
                            if (v316)
                            {
                              if (*(void *)v16 == 0x72662D6E6F6E6163 && *(_DWORD *)(v16 + 8) == 1702520165) {
                                sub_1CD70BB40();
                              }
                            }
                            if (v15 == 7 && *(_DWORD *)v16 == 762605412 && *(_DWORD *)(v16 + 3) == 1734632493) {
                              sub_1CD70BBC4();
                            }
                            if (v46)
                            {
                              if (*(void *)v16 == 0x6164696C61766E69
                                && *(void *)(v16 + 7) == 0x3E6C6C613C657461)
                              {
                                sub_1CD70BC48();
                              }
                            }
                            if (v318)
                            {
                              if (*(void *)v16 == 0x6964692D706F6F6CLL && *(_WORD *)(v16 + 8) == 28015) {
                                sub_1CD70BCCC();
                              }
                            }
                            if (v15 == 17)
                            {
                              BOOL v286 = *(void *)v16 == 0x736E692D706F6F6CLL
                                  && *(void *)(v16 + 8) == 0x66696C706D697374;
                              if (v286 && *(unsigned char *)(v16 + 16) == 121) {
                                sub_1CD70BD50();
                              }
                            }
                            if (v39)
                            {
                              if (*(void *)v16 == 0x746F722D706F6F6CLL
                                && *(void *)(v16 + 3) == 0x657461746F722D70)
                              {
                                sub_1CD70BDD4();
                              }
                            }
                            if (v318)
                            {
                              if (*(void *)v16 == 0x6F6C2D706F2D6F6ELL && *(_WORD *)(v16 + 8) == 28783) {
                                operator new();
                              }
                            }
                            if (v173)
                            {
                              if (*(_DWORD *)v16 == 1852404336 && *(unsigned char *)(v16 + 4) == 116)
                              {
                                long long v362 = (unint64_t)llvm::dbgs((llvm *)v275);
                                char v364 = 0;
                                sub_1CD70BE90();
                              }
                            }
                            if (v15 == 13
                              && *(void *)v16 == 0x6C65642D706F6F6CLL
                              && *(void *)(v16 + 5) == 0x6E6F6974656C6564)
                            {
                              sub_1CD70BF40();
                            }
                            if (v319)
                            {
                              if (*(void *)v16 == 0x6D69732D706F6F6CLL
                                && *(void *)(v16 + 8) == 0x6766637966696C70)
                              {
                                sub_1CD70BFC4();
                              }
                            }
                            if (v39)
                            {
                              if (*(void *)v16 == 0x6465722D706F6F6CLL
                                && *(void *)(v16 + 3) == 0x6563756465722D70)
                              {
                                sub_1CD70C048();
                              }
                            }
                            if (v15 == 7 && *(_DWORD *)v16 == 1986293353 && *(_DWORD *)(v16 + 3) == 1936875894) {
                              sub_1CD70C0CC();
                            }
                            if (v319)
                            {
                              if (*(void *)v16 == 0x726E752D706F6F6CLL
                                && *(void *)(v16 + 8) == 0x6C6C75662D6C6C6FLL)
                              {
                                sub_1CD70C15C();
                              }
                            }
                            if (v15 == 17)
                            {
                              BOOL v296 = *(void *)v16 == 0x63612D746E697270
                                  && *(void *)(v16 + 8) == 0x666E692D73736563;
                              if (v296 && *(unsigned char *)(v16 + 16) == 111)
                              {
                                llvm::dbgs((llvm *)v275);
                                sub_1CD70C1E8();
                              }
                            }
                            if (v318)
                            {
                              if (*(void *)v16 == 0x64643C746E697270 && *(_WORD *)(v16 + 8) == 15975)
                              {
                                llvm::dbgs((llvm *)v275);
                                sub_1CD70C274();
                              }
                            }
                            if (v46)
                            {
                              if (*(void *)v16 == 0x76693C746E697270
                                && *(void *)(v16 + 7) == 0x3E73726573752D76)
                              {
                                llvm::dbgs((llvm *)v275);
                                sub_1CD70C300();
                              }
                              if (*(void *)v16 == 0x6F6C3C746E697270
                                && *(void *)(v16 + 7) == 0x3E7473656E706F6FLL)
                              {
                                llvm::dbgs((llvm *)v275);
                                sub_1CD70C38C();
                              }
                            }
                            if (v15 == 22)
                            {
                              BOOL v301 = *(void *)v16 == 0x6F6C3C746E697270
                                  && *(void *)(v16 + 8) == 0x65686361632D706FLL;
                              if (v301 && *(void *)(v16 + 14) == 0x3E74736F632D6568)
                              {
                                llvm::dbgs((llvm *)v275);
                                sub_1CD70C418();
                              }
                            }
                            if (v319)
                            {
                              if (*(void *)v16 == 0x6572702D706F6F6CLL
                                && *(void *)(v16 + 8) == 0x6E6F697461636964)
                              {
                                sub_1CD70C4A4();
                              }
                            }
                            if (v317)
                            {
                              if (*(void *)v16 == 0x69772D6472617567
                                && *(void *)(v16 + 6) == 0x676E696E65646977)
                              {
                                sub_1CD70C528();
                              }
                            }
                            if (v319)
                            {
                              if (*(void *)v16 == 0x756F622D706F6F6CLL
                                && *(void *)(v16 + 8) == 0x74696C70732D646ELL)
                              {
                                sub_1CD70C5AC();
                              }
                            }
                            if (v39)
                            {
                              if (*(void *)v16 == 0x7265722D706F6F6CLL
                                && *(void *)(v16 + 3) == 0x6C6C6F7265722D70)
                              {
                                sub_1CD70C630();
                              }
                            }
                            if (v15 == 20)
                            {
                              BOOL v307 = *(void *)v16 == 0x7265762D706F6F6CLL
                                  && *(void *)(v16 + 8) == 0x2D676E696E6F6973;
                              if (v307 && *(_DWORD *)(v16 + 16) == 1835231596) {
                                sub_1CD70C6B4();
                              }
                            }
                            if (sub_1CCC9F0D4((char *)v16, v15, "simple-loop-unswitch", 0x14uLL))
                            {
                              sub_1CCCA0FD8((unint64_t)&v362, v16, v15);
                              if ((BYTE8(v362) & 1) == 0)
                              {
                                LOWORD(v321) = v362 & 0x101;
                                sub_1CD70C738();
                              }
                            }
                            else if (sub_1CCC9F0D4((char *)v16, v15, "licm", 4uLL))
                            {
                              sub_1CCCA12F0((unint64_t)&v362, (unsigned char *)v16, v15, "licm", 4uLL);
                              if ((v363 & 1) == 0) {
                                sub_1CD70C7C8();
                              }
                            }
                            else
                            {
                              if (!sub_1CCC9F0D4((char *)v16, v15, "lnicm", 5uLL))
                              {
                                uint64_t v309 = *(unsigned int *)(v10 + 1512);
                                if (!v309)
                                {
LABEL_1306:
                                  v322[0] = "unknown cgscc pass '{0}'";
                                  v322[1] = (void *)24;
                                  v322[2] = &v324;
                                  v322[3] = (void *)1;
                                  *(void *)&long long v323 = &unk_1F2635860;
                                  *((void *)&v323 + 1) = v7;
                                  *(void *)&long long v324 = &v323;
                                  sub_1CD465B2C((uint64_t)v322, &v362);
                                  __p[0] = (void *)llvm::inconvertibleErrorCode(v312);
                                  __p[1] = v313;
                                  sub_1CCC9EDCC();
                                }
                                v310 = (uint64_t *)(*(void *)(v10 + 1504) + 24);
                                uint64_t v311 = 32 * v309;
                                while (!sub_1CCCA7810(*v310, *v7, v7[1], (uint64_t)v9, v7[2], 0xCCCCCCCCCCCCCCCDLL * ((v7[3] - v7[2]) >> 3)))
                                {
                                  v310 += 4;
                                  v311 -= 32;
                                  if (!v311) {
                                    goto LABEL_1306;
                                  }
                                }
                                goto LABEL_1128;
                              }
                              sub_1CCCA12F0((unint64_t)&v362, (unsigned char *)v16, v15, "lnicm", 5uLL);
                              if ((v363 & 1) == 0) {
                                sub_1CD70C888();
                              }
                            }
                          }
                          uint64_t v49 = (void *)v362;
                          goto LABEL_46;
                        }
                        sub_1CCC9F164((int)v322, (uint64_t (*)(char *, size_t))sub_1CCCA05B8, (char *)v16, v15, "mldst-motion", 0xCuLL);
                        if (((uint64_t)v322[1] & 1) == 0) {
                          operator new();
                        }
                      }
LABEL_45:
                      uint64_t v49 = v322[0];
LABEL_46:
                      *int v12 = v49;
                      return;
                    }
                    int v173 = 0;
                    goto LABEL_542;
                  }
                  break;
                default:
                  goto LABEL_272;
              }
              if (*(void *)v16 == 0x726F776F6C6C6568 && *(_WORD *)(v16 + 8) == 25708) {
                operator new();
              }
              goto LABEL_277;
            }
LABEL_184:
            if (*(void *)v16 == 0x696C652D6F726F63 && *(_WORD *)(v16 + 8) == 25956) {
              operator new();
            }
            goto LABEL_188;
          }
          int v92 = 0;
          if (!v66) {
            goto LABEL_188;
          }
          goto LABEL_184;
        }
LABEL_96:
        if (*(void *)v16 == 0x637369642D646461
          && *(void *)(v16 + 8) == 0x6F74616E696D6972
          && *(_WORD *)(v16 + 16) == 29554)
        {
          operator new();
        }
        goto LABEL_103;
      }
    }
    int v72 = 0;
    int v71 = v316;
    if (!v43) {
      goto LABEL_103;
    }
    goto LABEL_96;
  }
  if (v15 == 19)
  {
    if (*(void *)v16 != 0x6E6F6974636E7566
      || *(void *)(v16 + 8) != 0x692D72656761653CLL
      || *(void *)(v16 + 11) != 0x3E766E692D726567)
    {
      goto LABEL_66;
    }
  }
  else
  {
    if (v15 != 8)
    {
      if (v15 == 5 && *(_DWORD *)v16 == 1668507491 && *(unsigned char *)(v16 + 4) == 99)
      {
        long long v362 = 0uLL;
        BOOL v363 = 0;
        uint64_t v18 = 40 * ((v14 - v13) / 40);
        while (1)
        {
          llvm::PassBuilder::parseCGSCCPass(v10, &v362, v13);
          if (*v12) {
            goto LABEL_78;
          }
          v13 += 40;
          v18 -= 40;
          if (!v18)
          {
            int v20 = (uint64_t *)*((void *)&v362 + 1);
            unint64_t v19 = (uint64_t *)v362;
            *int v12 = 0;
            if (v19 != v20)
            {
              uint64_t v21 = v9 + 2;
              uint64_t v22 = v9[1];
              do
              {
                if ((unint64_t)v22 >= *v21)
                {
                  uint64_t v24 = (v22 - *v9) >> 3;
                  if ((unint64_t)(v24 + 1) >> 61) {
                    abort();
                  }
                  uint64_t v25 = *v21 - (void)*v9;
                  uint64_t v26 = v25 >> 2;
                  if (v25 >> 2 <= (unint64_t)(v24 + 1)) {
                    uint64_t v26 = v24 + 1;
                  }
                  if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v27 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v27 = v26;
                  }
                  *(void *)&long long v323 = v9 + 2;
                  if (v27)
                  {
                    if (v27 >> 61) {
                      sub_1CB833614();
                    }
                    BOOL v28 = (char *)operator new(8 * v27);
                  }
                  else
                  {
                    BOOL v28 = 0;
                  }
                  int v29 = &v28[8 * v24];
                  int v30 = &v28[8 * v27];
                  v322[3] = v30;
                  uint64_t v31 = *v19;
                  *unint64_t v19 = 0;
                  *(void *)int v29 = v31;
                  uint64_t v22 = v29 + 8;
                  v322[2] = v29 + 8;
                  unint64_t v33 = *v9;
                  uint64_t v32 = v9[1];
                  if (v32 == *v9)
                  {
                    int64x2_t v35 = vdupq_n_s64((unint64_t)v32);
                  }
                  else
                  {
                    do
                    {
                      uint64_t v34 = *((void *)v32 - 1);
                      v32 -= 8;
                      *(void *)uint64_t v32 = 0;
                      *((void *)v29 - 1) = v34;
                      v29 -= 8;
                    }
                    while (v32 != v33);
                    int64x2_t v35 = *(int64x2_t *)v9;
                    int v30 = (char *)v322[3];
                    uint64_t v22 = (char *)v322[2];
                  }
                  char *v9 = v29;
                  v9[1] = v22;
                  *(int64x2_t *)&v322[1] = v35;
                  unint64_t v36 = v9[2];
                  void v9[2] = v30;
                  v322[3] = v36;
                  v322[0] = (void *)v35.i64[0];
                  sub_1CC9470AC((uint64_t)v322);
                }
                else
                {
                  uint64_t v23 = *v19;
                  *unint64_t v19 = 0;
                  *(void *)uint64_t v22 = v23;
                  v22 += 8;
                }
                v9[1] = v22;
                ++v19;
              }
              while (v19 != v20);
            }
            *int v12 = 0;
            goto LABEL_78;
          }
        }
      }
LABEL_66:
      unint64_t v54 = sub_1CCC9ECD8(*(_DWORD **)v5, *(void *)(v5 + 8), v5, v6);
      if (!HIDWORD(v54))
      {
        if (!((unint64_t)sub_1CCCA771C((_DWORD *)v16, v15, v55, v56) >> 32))
        {
          uint64_t v57 = *(unsigned int *)(v10 + 1512);
          if (!v57)
          {
LABEL_72:
            v322[0] = "invalid use of '{0}' pass as cgscc pipeline";
            v322[1] = (void *)43;
            v322[2] = &v324;
            v322[3] = (void *)1;
            *(void *)&long long v323 = &unk_1F2635860;
            *((void *)&v323 + 1) = v7;
            *(void *)&long long v324 = &v323;
            sub_1CD465B2C((uint64_t)v322, __p);
            llvm::inconvertibleErrorCode(v60);
            operator new();
          }
          uint64_t v58 = (uint64_t *)(*(void *)(v10 + 1504) + 24);
          uint64_t v59 = 32 * v57;
          while (!sub_1CCCA7810(*v58, *v7, v7[1], (uint64_t)v9, v7[2], 0xCCCCCCCCCCCCCCCDLL * ((v7[3] - v7[2]) >> 3)))
          {
            v58 += 4;
            v59 -= 32;
            if (!v59) {
              goto LABEL_72;
            }
          }
LABEL_1128:
          *int v12 = 0;
          return;
        }
        memset(v322, 0, 24);
        uint64_t v70 = 40 * ((v14 - v13) / 40);
        while (1)
        {
          llvm::PassBuilder::parseCGSCCPass(v10, v322, v13);
          if (*v12) {
            break;
          }
          v13 += 40;
          v70 -= 40;
          if (!v70)
          {
            *int v12 = 0;
            sub_1CD66B878();
          }
        }
        *(void *)&long long v362 = v322;
        int v64 = (void **)&v362;
LABEL_90:
        sub_1CC947208((void ***)v64);
        return;
      }
      int v61 = v54;
      long long v362 = 0uLL;
      BOOL v363 = 0;
      uint64_t v62 = 40 * ((v14 - v13) / 40);
      while (1)
      {
        llvm::PassBuilder::parseCGSCCPass(v10, &v362, v13);
        if (*v12) {
          break;
        }
        v13 += 40;
        v62 -= 40;
        if (!v62)
        {
          long long v63 = v363;
          *int v12 = 0;
          LODWORD(v322[0]) = v61;
          *(_OWORD *)&v322[1] = v362;
          v322[3] = v63;
          long long v362 = 0uLL;
          BOOL v363 = 0;
          sub_1CD70CAF8();
        }
      }
LABEL_78:
      v322[0] = &v362;
      int v64 = v322;
      goto LABEL_90;
    }
    if (*(void *)v16 != 0x6E6F6974636E7566) {
      goto LABEL_66;
    }
  }
  memset(v322, 0, 24);
  uint64_t v53 = 40 * ((v14 - v13) / 40);
  while (1)
  {
    llvm::PassBuilder::parseFunctionPass(v10, (uint64_t)v322, v13, (uint64_t)v6);
    if (*v12) {
      break;
    }
    v13 += 40;
    v53 -= 40;
    if (!v53)
    {
      *int v12 = 0;
      sub_1CD70CA4C();
    }
  }
  *(void *)&long long v362 = v322;
  sub_1CCCB67B8((void ***)&v362);
}

uint64_t sub_1CCCA771C(_DWORD *a1, unint64_t a2, uint64_t a3, unint64_t *a4)
{
  unint64_t v6 = a2 - 7;
  if (a2 >= 7)
  {
    uint64_t v18 = v4;
    uint64_t v19 = v5;
    BOOL v10 = *a1 == 1769366884 && *(_DWORD *)((char *)a1 + 3) == 1014264425;
    if (v10 && a2 >= 8 && *((unsigned char *)a1 + a2 - 1) == 62)
    {
      unint64_t v15 = 0;
      uint64_t v16 = (char *)a1 + 7;
      if (v6 >= a2 - 8) {
        unint64_t v6 = a2 - 8;
      }
      unint64_t v17 = v6;
      int v11 = llvm::consumeSignedInteger((llvm *)&v16, 0, &v15, a4);
      if (v17) {
        int v12 = 1;
      }
      else {
        int v12 = v11;
      }
      if (v15 != (int)v15) {
        int v12 = 1;
      }
      if (v12) {
        int v8 = 0;
      }
      else {
        int v8 = v15;
      }
      if (v8 < 0) {
        int v12 = 1;
      }
      unsigned int v9 = v8 & 0xFFFFFF00;
      int v8 = v8;
      BOOL v13 = v12 == 0;
      if (v12)
      {
        unsigned int v9 = 0;
        int v8 = 0;
      }
      uint64_t v7 = 0x100000000;
      if (!v13) {
        uint64_t v7 = 0;
      }
    }
    else
    {
      uint64_t v7 = 0;
      int v8 = 0;
      unsigned int v9 = 0;
    }
  }
  else
  {
    uint64_t v7 = 0;
    int v8 = 0;
    unsigned int v9 = 0;
  }
  return v7 | v9 | v8;
}

uint64_t sub_1CCCA7810(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v8[0] = a2;
  v8[1] = a3;
  v7[0] = a5;
  v7[1] = a6;
  if (a1) {
    return (*(uint64_t (**)(uint64_t, void *, uint64_t, void *))(*(void *)a1 + 48))(a1, v8, a4, v7);
  }
  sub_1CB920400();
  return llvm::PassBuilder::parseFunctionPass();
}

void llvm::PassBuilder::parseFunctionPass(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = MEMORY[0x1F4188790](a1, a2, a3, a4);
  uint64_t v7 = v5;
  unsigned int v9 = v8;
  uint64_t v10 = v4;
  int v12 = v11;
  uint64_t v522 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = v5[2];
  uint64_t v14 = (_DWORD *)v5[3];
  uint64_t v16 = (void *)*v5;
  size_t v15 = v5[1];
  if ((_DWORD *)v13 == v14)
  {
    if (v15 == 11)
    {
      if (*v16 == 0x3C65726975716572 && *(void *)((char *)v16 + 3) == 0x3E61613C65726975) {
        sub_1CD70DFA0();
      }
      if (*v16 == 0x3C65726975716572 && *(void *)((char *)v16 + 3) == 0x3E61643C65726975) {
        sub_1CD70EC00();
      }
      int v38 = 0;
      BOOL v39 = 0;
      int v40 = 0;
      int v470 = 0;
      int v41 = 0;
      int v42 = 0;
      int v43 = 0;
      int v44 = 0;
      int v45 = 0;
      int v46 = 0;
      int v47 = 0;
      int v48 = 0;
      goto LABEL_371;
    }
    char v49 = 0;
    int v45 = 0;
    int v50 = 0;
    switch(v15)
    {
      case 0xEuLL:
        if (*v16 == 0x6164696C61766E69 && *(void *)((char *)v16 + 6) == 0x3E61613C65746164) {
          sub_1CD70E024();
        }
        if (*v16 == 0x3C65726975716572 && *(void *)((char *)v16 + 6) == 0x3E73706F6F6C3C65) {
          sub_1CD70E9F0();
        }
        if (*v16 == 0x6164696C61766E69 && *(void *)((char *)v16 + 6) == 0x3E61643C65746164) {
          sub_1CD70EC84();
        }
        int v38 = 0;
        BOOL v39 = 0;
        int v40 = 0;
        int v470 = 0;
        int v41 = 0;
        int v42 = 0;
        int v43 = 0;
        int v45 = 0;
        int v46 = 0;
        int v47 = 0;
        int v48 = 0;
        int v44 = 1;
        goto LABEL_371;
      case 0xFuLL:
        if (*v16 == 0x3C65726975716572 && *(void *)((char *)v16 + 7) == 0x3E73656C6379633CLL) {
          sub_1CD70E3C0();
        }
        if (*v16 == 0x3C65726975716572 && *(void *)((char *)v16 + 7) == 0x3E7065646D656D3CLL) {
          sub_1CD70EE10();
        }
        int v38 = 0;
        BOOL v39 = 0;
        int v40 = 0;
        int v470 = 0;
        int v42 = 0;
        int v43 = 0;
        int v44 = 0;
        int v45 = 0;
        int v46 = 0;
        int v47 = 0;
        int v48 = 0;
        int v41 = 1;
        goto LABEL_371;
      case 0x10uLL:
        if (*v16 == 0x3C65726975716572 && v16[1] == 0x3E656572746D6F64) {
          sub_1CD70E4C8();
        }
        char v49 = 0;
        int v50 = 0;
        int v45 = 1;
        goto LABEL_249;
      case 0x11uLL:
        if (*v16 == 0x6164696C61766E69 && v16[1] == 0x73706F6F6C3C6574 && *((unsigned char *)v16 + 16) == 62) {
          sub_1CD70EA74();
        }
        int v48 = 0;
        int v47 = 0;
        int v46 = 0;
        int v45 = 0;
        int v42 = 0;
        int v50 = 0;
        BOOL v39 = 0;
        int v40 = 1;
        goto LABEL_337;
      case 0x12uLL:
        if (*v16 == 0x6164696C61766E69 && v16[1] == 0x656C6379633C6574 && *((_WORD *)v16 + 8) == 15987) {
          sub_1CD70E444();
        }
        int v45 = 0;
        int v50 = 0;
        char v49 = 1;
        goto LABEL_249;
      case 0x13uLL:
        if (*v16 == 0x3C65726975716572
          && v16[1] == 0x72662D6B636F6C62
          && *(void *)((char *)v16 + 11) == 0x3E716572662D6B63)
        {
          sub_1CD70E1B0();
        }
        if (*v16 == 0x6164696C61766E69
          && v16[1] == 0x72746D6F643C6574
          && *(void *)((char *)v16 + 11) == 0x3E656572746D6F64)
        {
          sub_1CD70E54C();
        }
        if (*v16 == 0x3C65726975716572
          && v16[1] == 0x756C61762D696870
          && *(void *)((char *)v16 + 11) == 0x3E7365756C61762DLL)
        {
          sub_1CD70F020();
        }
        if (*v16 == 0x6164696C61766E69
          && v16[1] == 0x6F696765723C6574
          && *(void *)((char *)v16 + 11) == 0x3E736E6F69676572)
        {
          sub_1CD70F1AC();
        }
        int v48 = 0;
        int v47 = 0;
        int v46 = 0;
        int v45 = 0;
        int v50 = 0;
        int v40 = 0;
        BOOL v39 = 0;
        int v42 = 1;
        goto LABEL_337;
      case 0x14uLL:
        if (*v16 == 0x3C65726975716572 && v16[1] == 0x6974706D75737361 && *((_DWORD *)v16 + 4) == 1047752303) {
          sub_1CD70E0A8();
        }
        if (*v16 == 0x3C65726975716572 && v16[1] == 0x702D68636E617262 && *((_DWORD *)v16 + 4) == 1046638450) {
          sub_1CD70E2B8();
        }
        if (*v16 == 0x3C65726975716572 && v16[1] == 0x746D6F6474736F70 && *((_DWORD *)v16 + 4) == 1046832498) {
          sub_1CD70E5D0();
        }
        if (*v16 == 0x3C65726975716572 && v16[1] == 0x746E6F72666D6F64 && *((_DWORD *)v16 + 4) == 1047684457) {
          sub_1CD70E7E0();
        }
        int v38 = 0;
        BOOL v39 = 0;
        int v40 = 0;
        int v470 = 0;
        int v41 = 0;
        int v42 = 0;
        int v44 = 0;
        int v45 = 0;
        int v46 = 0;
        int v47 = 0;
        int v48 = 0;
        int v43 = 1;
        goto LABEL_371;
      case 0x16uLL:
        if (*v16 == 0x6164696C61766E69
          && v16[1] == 0x6B636F6C623C6574
          && *(void *)((char *)v16 + 14) == 0x3E716572662D6B63)
        {
          sub_1CD70E234();
        }
        if (*v16 == 0x3C65726975716572
          && v16[1] == 0x6465646E616D6564
          && *(void *)((char *)v16 + 14) == 0x3E737469622D6465)
        {
          sub_1CD70E6D8();
        }
        if (*v16 == 0x6164696C61766E69
          && v16[1] == 0x762D6968703C6574
          && *(void *)((char *)v16 + 14) == 0x3E7365756C61762DLL)
        {
          sub_1CD70F0A4();
        }
        if (*v16 == 0x3C65726975716572
          && v16[1] == 0x696C746567726174
          && *(void *)((char *)v16 + 14) == 0x3E6F666E6962696CLL)
        {
          sub_1CD70F758();
        }
        int v70 = 0;
        int v48 = 0;
        int v71 = 0;
        int v47 = 0;
        int v46 = 0;
        int v45 = 0;
        int v44 = 0;
        int v43 = 0;
        int v42 = 0;
        int v41 = 0;
        int v470 = 0;
        int v40 = 0;
        BOOL v39 = 0;
        int v38 = 0;
        BOOL v105 = 0;
        int v106 = 1;
        goto LABEL_416;
      case 0x17uLL:
        if (*v16 == 0x6164696C61766E69
          && v16[1] == 0x6D757373613C6574
          && *(void *)((char *)v16 + 15) == 0x3E736E6F6974706DLL)
        {
          sub_1CD70E12C();
        }
        if (*v16 == 0x6164696C61766E69
          && v16[1] == 0x636E6172623C6574
          && *(void *)((char *)v16 + 15) == 0x3E626F72702D6863)
        {
          sub_1CD70E33C();
        }
        if (*v16 == 0x6164696C61766E69
          && v16[1] == 0x6474736F703C6574
          && *(void *)((char *)v16 + 15) == 0x3E656572746D6F64)
        {
          sub_1CD70E654();
        }
        if (*v16 == 0x6164696C61766E69
          && v16[1] == 0x72666D6F643C6574
          && *(void *)((char *)v16 + 15) == 0x3E726569746E6F72)
        {
          sub_1CD70E864();
        }
        if (*v16 == 0x3C65726975716572
          && v16[1] == 0x75662D706F2D6F6ELL
          && *(void *)((char *)v16 + 15) == 0x3E6E6F6974636E75)
        {
          operator new();
        }
        int v48 = 0;
        int v47 = 0;
        int v46 = 0;
        int v42 = 0;
        int v50 = 0;
        int v40 = 0;
        BOOL v39 = 0;
        int v45 = 1;
        goto LABEL_337;
      case 0x18uLL:
        if (*v16 == 0x3C65726975716572 && v16[1] == 0x6F72702D636E7566 && v16[2] == 0x3E73656974726570) {
          sub_1CD70E8E8();
        }
        if (*v16 == 0x3C65726975716572 && v16[1] == 0x6C61762D797A616CLL && v16[2] == 0x3E6F666E692D6575) {
          sub_1CD70EAF8();
        }
        char v49 = 0;
        int v45 = 0;
        int v50 = 1;
        goto LABEL_249;
      case 0x19uLL:
        if (*v16 == 0x6164696C61766E69
          && v16[1] == 0x6E616D65643C6574
          && v16[2] == 0x737469622D646564
          && *((unsigned char *)v16 + 24) == 62)
        {
          sub_1CD70E75C();
        }
        if (*v16 == 0x3C65726975716572
          && v16[1] == 0x652D72616C616373
          && v16[2] == 0x6E6F6974756C6F76
          && *((unsigned char *)v16 + 24) == 62)
        {
          sub_1CD70F338();
        }
        int v38 = 0;
        BOOL v39 = 0;
        int v40 = 0;
        int v470 = 0;
        int v41 = 0;
        int v42 = 0;
        int v43 = 0;
        int v44 = 0;
        int v45 = 0;
        int v46 = 0;
        int v47 = 0;
        int v48 = 0;
        int v70 = 0;
        int v71 = 1;
        goto LABEL_404;
      case 0x1BuLL:
        if (*v16 == 0x6164696C61766E69
          && v16[1] == 0x2D636E75663C6574
          && v16[2] == 0x69747265706F7270
          && *(void *)((char *)v16 + 19) == 0x3E73656974726570)
        {
          sub_1CD70E96C();
        }
        if (*v16 == 0x6164696C61766E69
          && v16[1] == 0x2D797A616C3C6574
          && v16[2] == 0x6E692D65756C6176
          && *(void *)((char *)v16 + 19) == 0x3E6F666E692D6575)
        {
          sub_1CD70EB7C();
        }
        int v47 = 0;
        int v46 = 0;
        int v45 = 0;
        int v42 = 0;
        int v50 = 0;
        int v40 = 0;
        BOOL v39 = 0;
        int v48 = 1;
        goto LABEL_337;
      default:
LABEL_249:
        if (v15 == 34)
        {
          if (!memcmp((const void *)*v5, "invalidate<inliner-size-estimator>", 0x22uLL)) {
            sub_1CD70ED8C();
          }
        }
        else
        {
          if (v15 != 31)
          {
            if ((v49 & 1) == 0)
            {
              int v47 = 0;
              goto LABEL_322;
            }
LABEL_268:
            if (*v16 == 0x6164696C61766E69 && v16[1] == 0x65646D656D3C6574 && *((_WORD *)v16 + 8) == 15984) {
              sub_1CD70EE94();
            }
            if (*v16 == 0x3C65726975716572 && v16[1] == 0x737379726F6D656DLL && *((_WORD *)v16 + 8) == 15969) {
              sub_1CD70EF18();
            }
            int v47 = 1;
LABEL_322:
            BOOL v39 = v15 == 21;
            if (v15 == 21)
            {
              BOOL v132 = *v16 == 0x6164696C61766E69 && v16[1] == 0x726F6D656D3C6574;
              if (v132 && *(void *)((char *)v16 + 13) == 0x3E61737379726F6DLL) {
                sub_1CD70EF9C();
              }
            }
            if (!v45)
            {
              int v48 = 0;
              int v46 = 0;
              int v42 = 0;
              int v40 = 0;
              goto LABEL_337;
            }
LABEL_331:
            if (*v16 == 0x3C65726975716572 && v16[1] == 0x3E736E6F69676572) {
              sub_1CD70F128();
            }
            int v48 = 0;
            int v45 = 0;
            int v42 = 0;
            int v40 = 0;
            int v46 = 1;
LABEL_337:
            if (v15 == 26)
            {
              if (*v16 == 0x6164696C61766E69
                && v16[1] == 0x706F2D6F6E3C6574
                && v16[2] == 0x6F6974636E75662DLL
                && *((_WORD *)v16 + 12) == 15982)
              {
                operator new();
              }
              int v38 = 1;
              int v138 = v50;
              goto LABEL_359;
            }
            if (!v50)
            {
              int v38 = 0;
              int v138 = 0;
              goto LABEL_359;
            }
LABEL_350:
            if (*v16 == 0x3C65726975716572 && v16[1] == 0x616D65722D74706FLL && v16[2] == 0x3E74696D652D6B72) {
              sub_1CD70F230();
            }
            int v38 = 0;
            int v138 = 1;
LABEL_359:
            int v470 = v138;
            if (v48)
            {
              BOOL v141 = *v16 == 0x6164696C61766E69 && v16[1] == 0x722D74706F3C6574;
              BOOL v142 = v141 && v16[2] == 0x6D652D6B72616D65;
              if (v142 && *(void *)((char *)v16 + 19) == 0x3E74696D652D6B72) {
                sub_1CD70F2B4();
              }
            }
            int v41 = 0;
            int v43 = 0;
            int v44 = 0;
LABEL_371:
            switch(v15)
            {
              case 0x2AuLL:
                int v458 = v38;
                int v472 = v45;
                BOOL v474 = v39;
                int v461 = v48;
                int v464 = v47;
                int v467 = v41;
                uint64_t v477 = 42;
                int v147 = v42;
                int v148 = v44;
                int v149 = v43;
                int v150 = v40;
                int v151 = v46;
                if (!memcmp(v16, "invalidate<should-not-run-function-passes>", 0x2AuLL)) {
                  sub_1CD70F4C4();
                }
                if (!memcmp(v16, "invalidate<should-run-extra-vector-passes>", 0x2AuLL)) {
                  sub_1CD70F5CC();
                }
                break;
              case 0x27uLL:
                int v458 = v38;
                int v472 = v45;
                BOOL v474 = v39;
                int v461 = v48;
                int v464 = v47;
                int v467 = v41;
                uint64_t v477 = 39;
                int v147 = v42;
                int v148 = v44;
                int v149 = v43;
                int v150 = v40;
                int v151 = v46;
                if (!memcmp(v16, "require<should-not-run-function-passes>", 0x27uLL)) {
                  sub_1CD70F440();
                }
                if (!memcmp(v16, "require<should-run-extra-vector-passes>", 0x27uLL)) {
                  sub_1CD70F548();
                }
                break;
              case 0x1CuLL:
                if (*v16 == 0x6164696C61766E69
                  && v16[1] == 0x616C6163733C6574
                  && v16[2] == 0x74756C6F76652D72
                  && *((_DWORD *)v16 + 6) == 1047424873)
                {
                  sub_1CD70F3BC();
                }
                int v71 = 0;
                int v70 = 1;
                if (!v48) {
                  goto LABEL_404;
                }
                goto LABEL_394;
              default:
                int v71 = 0;
                int v70 = 0;
                if (v48)
                {
LABEL_394:
                  if (*v16 == 0x3C65726975716572
                    && v16[1] == 0x61732D6B63617473
                    && v16[2] == 0x636F6C2D79746566
                    && *(void *)((char *)v16 + 19) == 0x3E6C61636F6C2D79)
                  {
                    sub_1CD70F650();
                  }
                }
LABEL_404:
                BOOL v105 = v15 == 30;
                if (v15 == 30)
                {
                  BOOL v155 = *v16 == 0x6164696C61766E69 && v16[1] == 0x6B636174733C6574;
                  BOOL v156 = v155 && v16[2] == 0x2D7974656661732DLL;
                  if (v156 && *(void *)((char *)v16 + 22) == 0x3E6C61636F6C2D79) {
                    sub_1CD70F6D4();
                  }
                }
                int v106 = 0;
LABEL_416:
                if (v71)
                {
                  if (*v16 == 0x6164696C61766E69
                    && v16[1] == 0x65677261743C6574
                    && v16[2] == 0x6F666E6962696C74
                    && *((unsigned char *)v16 + 24) == 62)
                  {
                    sub_1CD70F7DC();
                  }
                }
                else if (v40)
                {
                  BOOL v161 = *v16 == 0x3C65726975716572 && v16[1] == 0x7269746567726174;
                  if (v161 && *((unsigned char *)v16 + 16) == 62) {
                    sub_1CD70F860();
                  }
                }
                if (v43)
                {
                  BOOL v163 = *v16 == 0x6164696C61766E69 && v16[1] == 0x65677261743C6574;
                  if (v163 && *((_DWORD *)v16 + 4) == 1047685492) {
                    sub_1CD70F8E4();
                  }
                }
                if (v41)
                {
                  if (*v16 == 0x3C65726975716572 && *(void *)((char *)v16 + 7) == 0x3E7966697265763CLL) {
                    sub_1CD70F968();
                  }
                }
                if (v47)
                {
                  BOOL v166 = *v16 == 0x6164696C61766E69 && v16[1] == 0x66697265763C6574;
                  if (v166 && *((_WORD *)v16 + 8) == 15993) {
                    sub_1CD70F9EC();
                  }
                }
                if (v15 == 29)
                {
                  if (*v16 == 0x3C65726975716572
                    && v16[1] == 0x736E692D73736170
                    && v16[2] == 0x61746E656D757274
                    && *(void *)((char *)v16 + 21) == 0x3E6E6F697461746ELL)
                  {
                    sub_1CD70FA70();
                  }
                }
                else if (v15 == 32)
                {
                  BOOL v171 = *v16 == 0x6164696C61766E69 && v16[1] == 0x2D737361703C6574;
                  BOOL v172 = v171 && v16[2] == 0x656D757274736E69;
                  if (v172 && v16[3] == 0x3E6E6F697461746ELL) {
                    sub_1CD70FAF4();
                  }
                }
                if (v42)
                {
                  BOOL v174 = *v16 == 0x3C65726975716572 && v16[1] == 0x6E65677265766964;
                  if (v174 && *(void *)((char *)v16 + 11) == 0x3E65636E65677265) {
                    sub_1CD70FB78();
                  }
                }
                if (v106)
                {
                  BOOL v176 = *v16 == 0x6164696C61766E69 && v16[1] == 0x72657669643C6574;
                  if (v176 && *(void *)((char *)v16 + 14) == 0x3E65636E65677265) {
                    sub_1CD70FBFC();
                  }
                }
                if (v105)
                {
                  if (*v16 == 0x3C65726975716572
                    && v16[1] == 0x636E75662D757067
                    && v16[2] == 0x616E612D6E6F6974
                    && *(void *)((char *)v16 + 22) == 0x3E736973796C616ELL)
                  {
                    sub_1CD70FC80();
                  }
                }
                else if (v15 == 33)
                {
                  int v462 = v106;
                  int v465 = v44;
                  uint64_t v468 = v10;
                  v457 = v9;
                  v459 = v12;
                  int v456 = v42;
                  int v455 = v40;
                  int v181 = v46;
                  int v473 = v45;
                  BOOL v475 = v39;
                  int v182 = v43;
                  int v183 = v41;
                  int v184 = v47;
                  int v185 = v48;
                  int v186 = v70;
                  int v187 = v38;
                  int v188 = memcmp(v16, "invalidate<gpu-function-analysis>", 0x21uLL);
                  int v38 = v187;
                  int v70 = v186;
                  int v48 = v185;
                  int v47 = v184;
                  int v106 = v462;
                  int v44 = v465;
                  int v41 = v183;
                  int v42 = v456;
                  size_t v15 = 33;
                  unsigned int v9 = v457;
                  int v12 = v459;
                  uint64_t v10 = v468;
                  int v43 = v182;
                  int v45 = v473;
                  BOOL v39 = v475;
                  int v46 = v181;
                  int v40 = v455;
                  if (!v188) {
                    sub_1CD70FD04();
                  }
                }
                else if (v40)
                {
                  BOOL v189 = *v16 == 0x3C65726975716572 && v16[1] == 0x61612D6369736162;
                  if (v189 && *((unsigned char *)v16 + 16) == 62) {
                    sub_1CD70FD88();
                  }
                }
                if (v43)
                {
                  BOOL v191 = *v16 == 0x6164696C61766E69 && v16[1] == 0x63697361623C6574;
                  if (v191 && *((_DWORD *)v16 + 4) == 1046569261) {
                    sub_1CD70FE0C();
                  }
                }
                if (v106)
                {
                  BOOL v193 = *v16 == 0x3C65726975716572 && v16[1] == 0x65646E612D6C6663;
                  if (v193 && *(void *)((char *)v16 + 14) == 0x3E61612D73726564) {
                    sub_1CD70FE90();
                  }
                }
                if (v71)
                {
                  BOOL v195 = *v16 == 0x6164696C61766E69 && v16[1] == 0x612D6C66633C6574;
                  BOOL v196 = v195 && v16[2] == 0x61612D737265646ELL;
                  if (v196 && *((unsigned char *)v16 + 24) == 62) {
                    sub_1CD70FF14();
                  }
                }
                if (v106)
                {
                  BOOL v198 = *v16 == 0x3C65726975716572 && v16[1] == 0x656574732D6C6663;
                  if (v198 && *(void *)((char *)v16 + 14) == 0x3E61612D736E6565) {
                    sub_1CD70FF98();
                  }
                }
                if (v71)
                {
                  BOOL v200 = *v16 == 0x6164696C61766E69 && v16[1] == 0x732D6C66633C6574;
                  BOOL v201 = v200 && v16[2] == 0x61612D736E656574;
                  if (v201 && *((unsigned char *)v16 + 24) == 62) {
                    sub_1CD71001C();
                  }
                }
                if (v43)
                {
                  BOOL v203 = *v16 == 0x3C65726975716572 && v16[1] == 0x6372612D636A626FLL;
                  if (v203 && *((_DWORD *)v16 + 4) == 1046569261) {
                    sub_1CD7100A0();
                  }
                }
                if (v45)
                {
                  BOOL v205 = *v16 == 0x6164696C61766E69 && v16[1] == 0x2D636A626F3C6574;
                  if (v205 && *(void *)((char *)v16 + 15) == 0x3E61612D6372612DLL) {
                    sub_1CD710124();
                  }
                }
                if (v46)
                {
                  if (*v16 == 0x3C65726975716572 && v16[1] == 0x3E61612D76656373) {
                    sub_1CD7101A8();
                  }
                }
                if (v42)
                {
                  BOOL v208 = *v16 == 0x6164696C61766E69 && v16[1] == 0x2D766563733C6574;
                  if (v208 && *(void *)((char *)v16 + 11) == 0x3E61612D76656373) {
                    sub_1CD71022C();
                  }
                }
                if (v38)
                {
                  if (*v16 == 0x3C65726975716572
                    && v16[1] == 0x6E2D6465706F6373
                    && v16[2] == 0x612D7361696C616FLL
                    && *((_WORD *)v16 + 12) == 15969)
                  {
                    sub_1CD7102B0();
                  }
                }
                else if (v15 == 29)
                {
                  if (*v16 == 0x6164696C61766E69
                    && v16[1] == 0x65706F63733C6574
                    && v16[2] == 0x61696C616F6E2D64
                    && *(void *)((char *)v16 + 21) == 0x3E61612D7361696CLL)
                  {
                    sub_1CD710334();
                  }
                }
                else if (v15 == 13)
                {
                  if (*v16 == 0x3C65726975716572 && *(void *)((char *)v16 + 5) == 0x3E616162743C6572) {
                    sub_1CD7103B8();
                  }
                  uint64_t v217 = 1;
LABEL_630:
                  if (v46)
                  {
                    if (*v16 == 0x6164696C61766E69 && v16[1] == 0x3E616162743C6574) {
                      sub_1CD71043C();
                    }
                  }
                  if (v15 == 7)
                  {
                    if (*(_DWORD *)v16 == 1697472865 && *(_DWORD *)((char *)v16 + 3) == 1818326629)
                    {
                      memset(v484, 0, 40);
                      long long v482 = 0u;
                      long long v483 = 0u;
                      memset(v481, 0, sizeof(v481));
                      sub_1CD7104C0();
                    }
                  }
                  else if (v15 == 4)
                  {
                    if (*(_DWORD *)v16 == 1701012577) {
                      sub_1CD7105C0();
                    }
                    int v220 = 1;
                    if (!v47)
                    {
LABEL_654:
                      if (v106)
                      {
                        BOOL v223 = *v16 == 0x6973736572676761 && v16[1] == 0x6374736E692D6576;
                        if (v223 && *(void *)((char *)v16 + 14) == 0x656E69626D6F6374) {
                          sub_1CD7106C8();
                        }
                      }
                      if (v44)
                      {
                        if (*v16 == 0x622D656D75737361 && *(void *)((char *)v16 + 6) == 0x7265646C6975622DLL) {
                          sub_1CD71074C();
                        }
                      }
                      if (v41)
                      {
                        if (*v16 == 0x732D656D75737361 && *(void *)((char *)v16 + 7) == 0x7966696C706D6973) {
                          sub_1CD7107D0();
                        }
                      }
                      else if (v38)
                      {
                        BOOL v227 = *v16 == 0x6E656D6E67696C61 && v16[1] == 0x612D6D6F72662D74;
                        BOOL v228 = v227 && v16[2] == 0x6F6974706D757373;
                        if (v228 && *((_WORD *)v16 + 12) == 29550)
                        {
                          v481[0] = 0;
                          v481[1] = 0;
                          sub_1CD710854();
                        }
                      }
                      if (v47)
                      {
                        BOOL v230 = *v16 == 0x697461746F6E6E61 && v16[1] == 0x72616D65722D6E6FLL;
                        if (v230 && *((_WORD *)v16 + 8) == 29547) {
                          sub_1CD7108F8();
                        }
                      }
                      if (v220 && *(_DWORD *)v16 == 1701012578) {
                        sub_1CD71097C();
                      }
                      if (v41)
                      {
                        if (*v16 == 0x632D73646E756F62 && *(void *)((char *)v16 + 7) == 0x676E696B63656863) {
                          sub_1CD710A00();
                        }
                      }
                      if (v46)
                      {
                        if (*v16 == 0x72632D6B61657262 && v16[1] == 0x73656764652D7469) {
                          sub_1CD710A84();
                        }
                      }
                      if (v47)
                      {
                        BOOL v234 = *v16 == 0x657469736C6C6163 && v16[1] == 0x697474696C70732DLL;
                        if (v234 && *((_WORD *)v16 + 8) == 26478) {
                          sub_1CD710B08();
                        }
                      }
                      if (v15 == 10 && *v16 == 0x696F6874736E6F63 && *((_WORD *)v16 + 4) == 29811)
                      {
                        bzero(v481, 0x15D8uLL);
                        *(void *)&long long v485 = &v486;
                        HIDWORD(v485) = 8;
                        long long v513 = 0u;
                        int v514 = 0;
                        long long v515 = 0u;
                        memset(v516, 0, sizeof(v516));
                        uint64_t v517 = 0;
                        uint64_t v519 = 0;
                        uint64_t v518 = 0;
                        sub_1CD710B8C((uint64_t)v9, (uint64_t)v481, v367, v368);
                      }
                      if (v106)
                      {
                        BOOL v237 = *v16 == 0x69617274736E6F63 && v16[1] == 0x696D696C652D746ELL;
                        if (v237 && *(void *)((char *)v16 + 14) == 0x6E6F6974616E696DLL) {
                          sub_1CD710C98();
                        }
                      }
                      switch(v15)
                      {
                        case 3uLL:
                          if (*(_WORD *)v16 == 26723 && *((unsigned char *)v16 + 2) == 114)
                          {
                            sub_1CCAE03E4();
                            sub_1CD710D1C();
                          }
                          break;
                        case 0xAuLL:
                          if (*v16 == 0x696C652D6F726F63 && *((_WORD *)v16 + 4) == 25956) {
                            sub_1CD710DA0();
                          }
                          break;
                        case 0xCuLL:
                          if (*v16 == 0x656C632D6F726F63 && *((_DWORD *)v16 + 2) == 1886744161) {
                            sub_1CD710E24();
                          }
                          int v242 = 1;
LABEL_747:
                          if (v106)
                          {
                            BOOL v243 = *v16 == 0x74616C6572726F63 && v16[1] == 0x61706F72702D6465;
                            if (v243 && *(void *)((char *)v16 + 14) == 0x6E6F697461676170) {
                              sub_1CD710EA8();
                            }
                          }
                          if (v15 == 3 && *(_WORD *)v16 == 25444 && *((unsigned char *)v16 + 2) == 101) {
                            sub_1CD710F2C();
                          }
                          if (v47)
                          {
                            BOOL v246 = *v16 == 0x706D756A2D616664 && v16[1] == 0x696461657268742DLL;
                            if (v246 && *((_WORD *)v16 + 8) == 26478) {
                              sub_1CD710FB0();
                            }
                          }
                          if (v217)
                          {
                            if (*v16 == 0x2D6D65722D766964 && *(void *)((char *)v16 + 5) == 0x73726961702D6D65) {
                              sub_1CD711034();
                            }
                          }
                          if (v15 == 3)
                          {
                            if (*(_WORD *)v16 == 29540 && *((unsigned char *)v16 + 2) == 101) {
                              sub_1CD7110B8();
                            }
                          }
                          else if (v15 == 7 {
                                 && *(_DWORD *)v16 == 762605412
                          }
                                 && *(_DWORD *)((char *)v16 + 3) == 1734763309)
                          {
                            sub_1CD71113C();
                          }
                          if (v242)
                          {
                            if (*v16 == 0x2D6766632D746F64 && *((_DWORD *)v16 + 2) == 2037149295) {
                              sub_1CD7111C0();
                            }
                          }
                          if (v15 == 7 && *(_DWORD *)v16 == 762605412 && *(_DWORD *)((char *)v16 + 3) == 1836016685) {
                            sub_1CD711244();
                          }
                          if (v242)
                          {
                            if (*v16 == 0x2D6D6F642D746F64 && *((_DWORD *)v16 + 2) == 2037149295) {
                              sub_1CD7112C8();
                            }
                          }
                          if (v41)
                          {
                            if (*v16 == 0x657272692D786966 && *(void *)((char *)v16 + 7) == 0x656C626963756465) {
                              sub_1CD71134C();
                            }
                          }
                          else if (v15 == 10 && *v16 == 0x636E657474616C66 && *((_WORD *)v16 + 4) == 26470)
                          {
                            sub_1CD7113D0();
                          }
                          if (v43)
                          {
                            BOOL v256 = *v16 == 0x6175672D656B616DLL && v16[1] == 0x6C7078652D736472;
                            if (v256 && *((_DWORD *)v16 + 4) == 1953063785) {
                              sub_1CD711454();
                            }
                          }
                          if (v15 == 9)
                          {
                            if (*v16 == 0x73696F682D6E7667 && *((unsigned char *)v16 + 8) == 116) {
                              sub_1CD7114D8();
                            }
                          }
                          else
                          {
                            if (v15 == 8)
                            {
                              if (*v16 == 0x6B6E69732D6E7667) {
                                sub_1CD71155C();
                              }
                              int v259 = 1;
LABEL_836:
                              if (v43)
                              {
                                BOOL v261 = *v16 == 0x64612D7265666E69 && v16[1] == 0x70732D7373657264;
                                if (v261 && *((_DWORD *)v16 + 4) == 1936024417)
                                {
                                  LODWORD(v481[0]) = -1;
                                  sub_1CD711664();
                                }
                              }
                              if (v15 == 11)
                              {
                                if (*v16 == 0x626D6F6374736E69
                                  && *(void *)((char *)v16 + 3) == 0x656E69626D6F6374)
                                {
                                  v481[0] = &v481[2];
                                  v481[1] = (void *)0x10000000000;
                                  v507[86] = 0u;
                                  int v508 = 0;
                                  uint64_t v509 = 1;
                                  uint64_t v264 = 262;
                                  int64x2_t v265 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
                                  do
                                  {
                                    *(int64x2_t *)&v481[v264] = v265;
                                    v264 += 2;
                                  }
                                  while (v264 != 278);
                                  v510 = v512;
                                  uint64_t v511 = 0x1000000000;
                                  v512[32] = dword_1EBD09170;
                                  sub_1CCCAD42C();
                                }
                              }
                              else if (v15 == 9 && *v16 == 0x6E756F6374736E69 && *((unsigned char *)v16 + 8) == 116)
                              {
                                sub_1CD711704();
                              }
                              if (v242)
                              {
                                if (*v16 == 0x706D697374736E69 && *((_DWORD *)v16 + 2) == 2036754796) {
                                  sub_1CD711788();
                                }
                              }
                              if (v41)
                              {
                                if (*v16 == 0x6164696C61766E69
                                  && *(void *)((char *)v16 + 7) == 0x3E6C6C613C657461)
                                {
                                  sub_1CD71180C();
                                }
                              }
                              if (v220 && *(_DWORD *)v16 == 1701016169) {
                                sub_1CD711890();
                              }
                              if (v15 == 9 && *v16 == 0x6E693274616F6C66 && *((unsigned char *)v16 + 8) == 116)
                              {
                                long long v492 = 0uLL;
                                v489 = 0;
                                long long v487 = 0u;
                                long long v488 = 0u;
                                long long v486 = 0u;
                                long long v482 = 0u;
                                memset(v481, 0, sizeof(v481));
                                *(void *)&long long v483 = 1;
                                *(int64x2_t *)((char *)&v484[2] + 8) = vdupq_n_s64(0xFFFFFFFFFFFFF000);
                                *((void *)&v484[3] + 1) = (char *)&v485 + 8;
                                long long v485 = 0x800000000uLL;
                                long long v491 = 0uLL;
                                BOOL v490 = &v491;
                                long long v493 = 0uLL;
                                long long v495 = 0uLL;
                                long long v494 = 0uLL;
                                sub_1CD711914();
                              }
                              if (v44)
                              {
                                if (*v16 == 0x75662D706F2D6F6ELL
                                  && *(void *)((char *)v16 + 6) == 0x6E6F6974636E7566)
                                {
                                  operator new();
                                }
                              }
                              if (v42)
                              {
                                BOOL v271 = *v16 == 0x736C6C616362696CLL && v16[1] == 0x776B6E697268732DLL;
                                if (v271 && *(void *)((char *)v16 + 11) == 0x706172776B6E6972) {
                                  sub_1CD711A04();
                                }
                              }
                              if (v220 && *(_DWORD *)v16 == 1953393004) {
                                sub_1CD711A88();
                              }
                              if (v42)
                              {
                                BOOL v273 = *v16 == 0x742D7463656A6E69 && v16[1] == 0x697070616D2D696CLL;
                                if (v273 && *(void *)((char *)v16 + 11) == 0x73676E697070616DLL) {
                                  sub_1CD711B0C();
                                }
                              }
                              if (v15 == 9)
                              {
                                if (*v16 == 0x656D616E74736E69 && *((unsigned char *)v16 + 8) == 114) {
                                  sub_1CD711B90();
                                }
                              }
                              else if (v15 == 11 {
                                     && *v16 == 0x6F74617265776F6CLL
                              }
                                     && *(void *)((char *)v16 + 3) == 0x63696D6F74617265)
                              {
                                sub_1CD711C14();
                              }
                              if (v242)
                              {
                                if (*v16 == 0x78652D7265776F6CLL && *((_DWORD *)v16 + 2) == 1952671088) {
                                  sub_1CD711C98();
                                }
                              }
                              if (v39)
                              {
                                if (*v16 == 0x75672D7265776F6CLL
                                  && v16[1] == 0x72746E692D647261
                                  && *(void *)((char *)v16 + 13) == 0x6369736E6972746ELL)
                                {
                                  sub_1CD711D20();
                                }
                              }
                              else if (v71)
                              {
                                if (*v16 == 0x6F632D7265776F6CLL
                                  && v16[1] == 0x692D746E6174736ELL
                                  && v16[2] == 0x6369736E6972746ELL
                                  && *((unsigned char *)v16 + 24) == 115)
                                {
                                  sub_1CD711DA4();
                                }
                                if (*v16 == 0x69772D7265776F6CLL
                                  && v16[1] == 0x2D656C62616E6564
                                  && v16[2] == 0x6F697469646E6F63
                                  && *((unsigned char *)v16 + 24) == 110)
                                {
                                  sub_1CD711E2C();
                                }
                              }
                              if (v44)
                              {
                                if (*v16 == 0x69772D6472617567
                                  && *(void *)((char *)v16 + 6) == 0x676E696E65646977)
                                {
                                  sub_1CD711EB0();
                                }
                              }
                              if (v39)
                              {
                                BOOL v287 = *v16 == 0x6F74732D64616F6CLL && v16[1] == 0x6F746365762D6572;
                                if (v287 && *(void *)((char *)v16 + 13) == 0x72657A69726F7463) {
                                  sub_1CD711F34();
                                }
                              }
                              if (v217)
                              {
                                if (*v16 == 0x6D69732D706F6F6CLL
                                  && *(void *)((char *)v16 + 5) == 0x7966696C706D6973)
                                {
                                  sub_1CD711FB8();
                                }
                              }
                              switch(v15)
                              {
                                case 9uLL:
                                  if (*v16 == 0x6E69732D706F6F6CLL && *((unsigned char *)v16 + 8) == 107) {
                                    sub_1CD712040();
                                  }
                                  if (*v16 == 0x706F7970636D656DLL && *((unsigned char *)v16 + 8) == 116)
                                  {
                                    long long v482 = 0u;
                                    memset(v481, 0, sizeof(v481));
                                    sub_1CD712250();
                                  }
                                  break;
                                case 0xBuLL:
                                  if (*v16 == 0x766E697265776F6CLL
                                    && *(void *)((char *)v16 + 3) == 0x656B6F766E697265)
                                  {
                                    sub_1CD7120C4();
                                  }
                                  if (*v16 == 0x6977737265776F6CLL
                                    && *(void *)((char *)v16 + 3) == 0x6863746977737265)
                                  {
                                    sub_1CD712148();
                                  }
                                  if (*v16 == 0x746572656772656DLL
                                    && *(void *)((char *)v16 + 3) == 0x6E72757465726567)
                                  {
                                    sub_1CD712380();
                                  }
                                  break;
                                case 7uLL:
                                  if (*(_DWORD *)v16 == 846030189 && *(_DWORD *)((char *)v16 + 3) == 1734701618) {
                                    sub_1CD7121CC();
                                  }
                                  break;
                                default:
                                  if (v15 == 10 && *v16 == 0x6D6369656772656DLL && *((_WORD *)v16 + 4) == 29552) {
                                    sub_1CD7122FC();
                                  }
                                  break;
                              }
                              if (v46)
                              {
                                if (*v16 == 0x6165722D7972616ELL && v16[1] == 0x65746169636F7373)
                                {
                                  *(void *)&v484[0] = 0;
                                  long long v482 = 0u;
                                  long long v483 = 0u;
                                  memset(v481, 0, sizeof(v481));
                                  sub_1CD712404();
                                }
                              }
                              if (v15 == 6 && *(_DWORD *)v16 == 1735877998 && *((_WORD *)v16 + 2) == 28278) {
                                sub_1CD712518();
                              }
                              if (v44)
                              {
                                if (*v16 == 0x7268742D706D756ALL
                                  && *(void *)((char *)v16 + 6) == 0x676E696461657268)
                                {
                                  *((void *)&v482 + 1) = 0;
                                  *(void *)&long long v483 = 0;
                                  WORD4(v483) = 0;
                                  *(void *)&v484[0] = &v484[1];
                                  *((void *)&v484[0] + 1) = 0x1000000000;
                                  *((void *)&v491 + 1) = 0;
                                  *(void *)&long long v492 = 0;
                                  *(void *)&long long v491 = (char *)&v491 + 8;
                                  LOBYTE(v493) = byte_1EBD0B538;
                                  HIDWORD(v492) = dword_1EBD0B478;
                                  sub_1CD71259C();
                                }
                              }
                              if (v71)
                              {
                                if (*v16 == 0x6C6C616974726170
                                  && v16[1] == 0x656E696C6E692D79
                                  && v16[2] == 0x6C6C616362696C2DLL
                                  && *((unsigned char *)v16 + 24) == 115)
                                {
                                  sub_1CD712714();
                                }
                              }
                              else if (v15 == 5)
                              {
                                if (*(_DWORD *)v16 == 1936941932 && *((unsigned char *)v16 + 4) == 97) {
                                  sub_1CD712798();
                                }
                                int v476 = 1;
LABEL_1079:
                                if (v47)
                                {
                                  BOOL v307 = *v16 == 0x7461642D706F6F6CLL && v16[1] == 0x7465666572702D61;
                                  if (v307 && *((_WORD *)v16 + 8) == 26723) {
                                    sub_1CD712820();
                                  }
                                }
                                if (v44)
                                {
                                  if (*v16 == 0x616F6C2D706F6F6CLL
                                    && *(void *)((char *)v16 + 6) == 0x6D696C652D64616FLL)
                                  {
                                    sub_1CD7128A4();
                                  }
                                }
                                if (v15 == 11)
                                {
                                  if (*v16 == 0x7375662D706F6F6CLL
                                    && *(void *)((char *)v16 + 3) == 0x6E6F697375662D70)
                                  {
                                    sub_1CD71292C();
                                  }
                                }
                                else if (v41)
                                {
                                  if (*v16 == 0x7369642D706F6F6CLL
                                    && *(void *)((char *)v16 + 7) == 0x6574756269727473)
                                  {
                                    sub_1CD7129B0();
                                  }
                                  if (*v16 == 0x7265762D706F6F6CLL
                                    && *(void *)((char *)v16 + 7) == 0x676E696E6F697372)
                                  {
                                    sub_1CD712A34();
                                  }
                                }
                                if (v259 && *v16 == 0x6372612D636A626FLL) {
                                  sub_1CD712AB8();
                                }
                                if (v40)
                                {
                                  if (*v16 == 0x6372612D636A626FLL
                                    && v16[1] == 0x636172746E6F632DLL
                                    && *((unsigned char *)v16 + 16) == 116)
                                  {
                                    sub_1CD712B3C();
                                  }
                                }
                                else if (v41)
                                {
                                  if (*v16 == 0x6372612D636A626FLL
                                    && *(void *)((char *)v16 + 7) == 0x646E617078652D63)
                                  {
                                    sub_1CD712BC0();
                                  }
                                }
                                if (v217)
                                {
                                  if (*v16 == 0x6F6D656D2D6F6770
                                    && *(void *)((char *)v16 + 5) == 0x74706F2D706F6D65)
                                  {
                                    sub_1CD712C44();
                                  }
                                }
                                if (v476)
                                {
                                  if (*(_DWORD *)v16 == 1852404336 && *((unsigned char *)v16 + 4) == 116)
                                  {
                                    v481[0] = llvm::dbgs((llvm *)v217);
                                    v481[1] = 0;
                                    HIBYTE(v481[3]) = 0;
                                    sub_1CD712CC8();
                                  }
                                }
                                if (v47)
                                {
                                  BOOL v318 = *v16 == 0x73613C746E697270 && v16[1] == 0x6E6F6974706D7573;
                                  if (v318 && *((_WORD *)v16 + 8) == 15987)
                                  {
                                    v481[0] = llvm::dbgs((llvm *)v217);
                                    sub_1CD712D70();
                                  }
                                }
                                if (v40)
                                {
                                  BOOL v320 = *v16 == 0x6C623C746E697270 && v16[1] == 0x716572662D6B636FLL;
                                  if (v320 && *((unsigned char *)v16 + 16) == 62)
                                  {
                                    v481[0] = llvm::dbgs((llvm *)v217);
                                    sub_1CD712DF8();
                                  }
                                }
                                if (v47)
                                {
                                  BOOL v322 = *v16 == 0x72623C746E697270 && v16[1] == 0x6F72702D68636E61;
                                  if (v322 && *((_WORD *)v16 + 8) == 15970)
                                  {
                                    v481[0] = llvm::dbgs((llvm *)v217);
                                    sub_1CD712E80();
                                  }
                                }
                                if (v40)
                                {
                                  BOOL v324 = *v16 == 0x6F633C746E697270 && v16[1] == 0x6C65646F6D2D7473;
                                  if (v324 && *((unsigned char *)v16 + 16) == 62)
                                  {
                                    v481[0] = llvm::dbgs((llvm *)v217);
                                    sub_1CD712F08();
                                  }
                                }
                                if (v217)
                                {
                                  if (*v16 == 0x79633C746E697270
                                    && *(void *)((char *)v16 + 5) == 0x3E73656C6379633CLL)
                                  {
                                    v481[0] = llvm::dbgs((llvm *)v217);
                                    sub_1CD712F90();
                                  }
                                }
                                if (v15 == 9)
                                {
                                  if (*v16 == 0x61643C746E697270 && *((unsigned char *)v16 + 8) == 62)
                                  {
                                    v481[0] = llvm::dbgs((llvm *)v217);
                                    sub_1CD713018();
                                  }
                                }
                                else if (v40)
                                {
                                  BOOL v328 = *v16 == 0x69643C746E697270 && v16[1] == 0x65636E6567726576;
                                  if (v328 && *((unsigned char *)v16 + 16) == 62)
                                  {
                                    v481[0] = llvm::dbgs((llvm *)v217);
                                    sub_1CD7130A0();
                                  }
                                }
                                if (v44)
                                {
                                  if (*v16 == 0x6F643C746E697270
                                    && *(void *)((char *)v16 + 6) == 0x3E656572746D6F64)
                                  {
                                    v481[0] = llvm::dbgs((llvm *)v217);
                                    sub_1CD713128();
                                  }
                                }
                                if (v47)
                                {
                                  BOOL v331 = *v16 == 0x6F703C746E697270 && v16[1] == 0x6572746D6F647473;
                                  if (v331 && *((_WORD *)v16 + 8) == 15973)
                                  {
                                    v481[0] = llvm::dbgs((llvm *)v217);
                                    sub_1CD7131B0();
                                  }
                                }
                                if (v106)
                                {
                                  BOOL v333 = *v16 == 0x65643C746E697270 && v16[1] == 0x7A697261656E696CLL;
                                  if (v333 && *(void *)((char *)v16 + 14) == 0x3E6E6F6974617A69)
                                  {
                                    v481[0] = llvm::dbgs((llvm *)v217);
                                    sub_1CD713238();
                                  }
                                }
                                if (v43)
                                {
                                  BOOL v335 = *v16 == 0x65643C746E697270 && v16[1] == 0x622D6465646E616DLL;
                                  if (v335 && *((_DWORD *)v16 + 4) == 1047753833)
                                  {
                                    v481[0] = llvm::dbgs((llvm *)v217);
                                    sub_1CD7132C0();
                                  }
                                }
                                if (v47)
                                {
                                  BOOL v337 = *v16 == 0x6F643C746E697270 && v16[1] == 0x6569746E6F72666DLL;
                                  if (v337 && *((_WORD *)v16 + 8) == 15986)
                                  {
                                    v481[0] = llvm::dbgs((llvm *)v217);
                                    sub_1CD713348();
                                  }
                                }
                                if (v106)
                                {
                                  BOOL v339 = *v16 == 0x75663C746E697270 && v16[1] == 0x65706F72702D636ELL;
                                  if (v339 && *(void *)((char *)v16 + 14) == 0x3E73656974726570)
                                  {
                                    v481[0] = llvm::dbgs((llvm *)v217);
                                    sub_1CD7133D0();
                                  }
                                }
                                if (v47)
                                {
                                  BOOL v341 = *v16 == 0x6E693C746E697270 && v16[1] == 0x736F632D656E696CLL;
                                  if (v341 && *((_WORD *)v16 + 8) == 15988)
                                  {
                                    v481[0] = llvm::dbgs((llvm *)v217);
                                    sub_1CD713458();
                                  }
                                }
                                if (v15 == 29)
                                {
                                  BOOL v343 = *v16 == 0x6E693C746E697270 && v16[1] == 0x69732D72656E696CLL;
                                  BOOL v344 = v343 && v16[2] == 0x6D697473652D657ALL;
                                  if (v344 && *(void *)((char *)v16 + 21) == 0x3E726F74616D6974)
                                  {
                                    v481[0] = llvm::dbgs((llvm *)v217);
                                    sub_1CD7134E0();
                                  }
                                }
                                if (v70)
                                {
                                  BOOL v346 = *v16 == 0x70673C746E697270 && v16[1] == 0x6974636E75662D75;
                                  BOOL v347 = v346 && v16[2] == 0x796C616E612D6E6FLL;
                                  if (v347 && *((_DWORD *)v16 + 6) == 1047751027)
                                  {
                                    v481[0] = llvm::dbgs((llvm *)v217);
                                    sub_1CD713568();
                                  }
                                }
                                if (v242)
                                {
                                  if (*v16 == 0x6F6C3C746E697270 && *((_DWORD *)v16 + 2) == 1047752815)
                                  {
                                    v481[0] = llvm::dbgs((llvm *)v217);
                                    sub_1CD7135F0();
                                  }
                                }
                                if (v46)
                                {
                                  if (*v16 == 0x656D3C746E697270 && v16[1] == 0x3E61737379726F6DLL)
                                  {
                                    v481[0] = llvm::dbgs((llvm *)v217);
                                    sub_1CD713678();
                                  }
                                }
                                if (v45)
                                {
                                  BOOL v351 = *v16 == 0x656D3C746E697270 && v16[1] == 0x2D61737379726F6DLL;
                                  if (v351 && *(void *)((char *)v16 + 15) == 0x3E72656B6C61772DLL)
                                  {
                                    v481[0] = llvm::dbgs((llvm *)v217);
                                    sub_1CD713700();
                                  }
                                }
                                if (v40)
                                {
                                  BOOL v353 = *v16 == 0x68703C746E697270 && v16[1] == 0x7365756C61762D69;
                                  if (v353 && *((unsigned char *)v16 + 16) == 62)
                                  {
                                    v481[0] = llvm::dbgs((llvm *)v217);
                                    sub_1CD713788();
                                  }
                                }
                                if (v44)
                                {
                                  if (*v16 == 0x65723C746E697270
                                    && *(void *)((char *)v16 + 6) == 0x3E736E6F69676572)
                                  {
                                    v481[0] = llvm::dbgs((llvm *)v217);
                                    sub_1CD713810();
                                  }
                                }
                                if (v45)
                                {
                                  BOOL v356 = *v16 == 0x63733C746E697270 && v16[1] == 0x6F76652D72616C61;
                                  if (v356 && *(void *)((char *)v16 + 15) == 0x3E6E6F6974756C6FLL)
                                  {
                                    v481[0] = llvm::dbgs((llvm *)v217);
                                    sub_1CD713898();
                                  }
                                }
                                if (v71)
                                {
                                  BOOL v358 = *v16 == 0x74733C746E697270 && v16[1] == 0x656661732D6B6361;
                                  BOOL v359 = v358 && v16[2] == 0x6C61636F6C2D7974;
                                  if (v359 && *((unsigned char *)v16 + 24) == 62)
                                  {
                                    v481[0] = llvm::dbgs((llvm *)v217);
                                    sub_1CD713920();
                                  }
                                }
                                if (v46)
                                {
                                  if (*v16 == 0x6C612D746E697270 && v16[1] == 0x737465732D736169)
                                  {
                                    v481[0] = llvm::dbgs((llvm *)v217);
                                    sub_1CD7139A8();
                                  }
                                }
                                if (v42)
                                {
                                  BOOL v362 = *v16 == 0x72702D746E697270 && v16[1] == 0x6965746163696465;
                                  if (v362 && *(void *)((char *)v16 + 11) == 0x6F666E6965746163)
                                  {
                                    v481[0] = llvm::dbgs((llvm *)v217);
                                    sub_1CD713A30();
                                  }
                                }
                                if (v40)
                                {
                                  if (*v16 == 0x756D2D746E697270
                                    && v16[1] == 0x7475636578657473
                                    && *((unsigned char *)v16 + 16) == 101)
                                  {
                                    v481[0] = llvm::dbgs((llvm *)v217);
                                    sub_1CD713AB8();
                                  }
                                }
                                else if (v41)
                                {
                                  if (*v16 == 0x656D2D746E697270
                                    && *(void *)((char *)v16 + 7) == 0x7366657265646D65)
                                  {
                                    v481[0] = llvm::dbgs((llvm *)v217);
                                    sub_1CD713B40();
                                  }
                                }
                                else if (v15 == 11 {
                                       && *v16 == 0x69636F7373616572
                                }
                                       && *(void *)((char *)v16 + 3) == 0x65746169636F7373)
                                {
                                  bzero(v481, 0x230uLL);
                                  for (uint64_t i = 15; i != 69; i += 3)
                                  {
                                    v411 = &v481[i];
                                    *v411 = 0;
                                    v411[1] = 0;
                                    *((_DWORD *)v411 + 4) = 0;
                                  }
                                  sub_1CD713BC8();
                                }
                                if (v45)
                                {
                                  BOOL v370 = *v16 == 0x6E61646E75646572 && v16[1] == 0x6E692D6762642D74;
                                  if (v370 && *(void *)((char *)v16 + 15) == 0x6D696C652D74736ELL) {
                                    sub_1CD713C8C();
                                  }
                                }
                                if (v15 == 7
                                  && *(_DWORD *)v16 == 845636978
                                  && *(_DWORD *)((char *)v16 + 3) == 1835363634)
                                {
                                  sub_1CD713D10();
                                }
                                if (v48)
                                {
                                  BOOL v373 = *v16 == 0x7A6972616C616373 && v16[1] == 0x64656B73616D2D65;
                                  BOOL v374 = v373 && v16[2] == 0x746E692D6D656D2DLL;
                                  if (v374 && *(void *)((char *)v16 + 19) == 0x6E6972746E692D6DLL) {
                                    sub_1CD713D94();
                                  }
                                }
                                if (v15 == 10)
                                {
                                  if (*v16 == 0x7A6972616C616373 && *((_WORD *)v16 + 4) == 29285)
                                  {
                                    LODWORD(v481[0]) = 0;
                                    sub_1CD713E18();
                                  }
                                }
                                else if (v105)
                                {
                                  BOOL v377 = *v16 == 0x6574617261706573 && v16[1] == 0x6F2D74736E6F632DLL;
                                  BOOL v378 = v377 && v16[2] == 0x72662D7465736666;
                                  if (v378 && *(void *)((char *)v16 + 22) == 0x7065672D6D6F7266)
                                  {
                                    LOBYTE(v481[0]) = 0;
                                    sub_1CD713EB8();
                                  }
                                }
                                if (v220)
                                {
                                  if (*(_DWORD *)v16 == 1885561715) {
                                    sub_1CD713F44();
                                  }
                                  if (*(_DWORD *)v16 == 1802398067) {
                                    sub_1CD713FC8();
                                  }
                                }
                                if (v44)
                                {
                                  if (*v16 == 0x746365762D706C73
                                    && *(void *)((char *)v16 + 6) == 0x72657A69726F7463)
                                  {
                                    *(void *)&long long v487 = 0;
                                    long long v485 = 0u;
                                    long long v486 = 0u;
                                    memset(v484, 0, sizeof(v484));
                                    long long v482 = 0u;
                                    long long v483 = 0u;
                                    memset(v481, 0, sizeof(v481));
                                    sub_1CD71404C();
                                  }
                                }
                                if (v220 && *(_DWORD *)v16 == 1920167027) {
                                  sub_1CD71420C();
                                }
                                if (v39)
                                {
                                  BOOL v381 = *v16 == 0x74616C7563657073 && v16[1] == 0x636578652D657669;
                                  if (v381 && *(void *)((char *)v16 + 13) == 0x6E6F697475636578)
                                  {
                                    LOBYTE(v481[0]) = byte_1EBD0BFB8;
                                    v481[1] = 0;
                                    sub_1CD714290();
                                  }
                                }
                                if (v220 && *(_DWORD *)v16 == 1634693747)
                                {
                                  bzero(v481, 0x2C0uLL);
                                  *(void *)&long long v483 = v484;
                                  HIDWORD(v483) = 16;
                                  v489 = &v491;
                                  HIDWORD(v490) = 8;
                                  long long v496 = 0u;
                                  int v497 = 0;
                                  BOOL v498 = v500;
                                  int v499 = 16;
                                  memset(&v500[128], 0, 44);
                                  v501 = v503;
                                  int v502 = 2;
                                  v503[1] = 0u;
                                  int v504 = 0;
                                  v505 = v507;
                                  int v506 = 2;
                                  sub_1CD71432C();
                                }
                                if (v47)
                                {
                                  BOOL v383 = *v16 == 0x63672D7069727473 && v16[1] == 0x7461636F6C65722DLL;
                                  if (v383 && *((_WORD *)v16 + 8) == 29541) {
                                    sub_1CD71441C();
                                  }
                                }
                                if (v44)
                                {
                                  if (*v16 == 0x7275746375727473
                                    && *(void *)((char *)v16 + 6) == 0x676663657A697275)
                                  {
                                    sub_1CD7144A0();
                                  }
                                }
                                if (v242)
                                {
                                  if (*v16 == 0x6C6C61636C696174 && *((_DWORD *)v16 + 2) == 1835625573) {
                                    sub_1CD714524();
                                  }
                                }
                                if (v46)
                                {
                                  if (*v16 == 0x6F6C2D7966696E75 && v16[1] == 0x73746978652D706FLL) {
                                    sub_1CD7145AC();
                                  }
                                }
                                if (v44)
                                {
                                  if (*v16 == 0x632D726F74636576
                                    && *(void *)((char *)v16 + 6) == 0x656E69626D6F632DLL)
                                  {
                                    LOBYTE(v481[0]) = 0;
                                    sub_1CD714630();
                                  }
                                }
                                if (v15 == 6)
                                {
                                  if (*(_DWORD *)v16 == 1769104758 && *((_WORD *)v16 + 2) == 31078)
                                  {
                                    LOBYTE(v481[0]) = 1;
                                    sub_1CD7146BC();
                                  }
                                }
                                else if (v41)
                                {
                                  if (*v16 == 0x643C796669726576
                                    && *(void *)((char *)v16 + 7) == 0x3E656572746D6F64)
                                  {
                                    sub_1CD714748();
                                  }
                                }
                                if (v217)
                                {
                                  if (*v16 == 0x6C3C796669726576
                                    && *(void *)((char *)v16 + 5) == 0x3E73706F6F6C3C79)
                                  {
                                    sub_1CD7147CC();
                                  }
                                }
                                if (v40)
                                {
                                  if (*v16 == 0x6D3C796669726576
                                    && v16[1] == 0x61737379726F6D65
                                    && *((unsigned char *)v16 + 16) == 62)
                                  {
                                    sub_1CD714850();
                                  }
                                }
                                else if (v41)
                                {
                                  if (*v16 == 0x723C796669726576
                                    && *(void *)((char *)v16 + 7) == 0x3E736E6F69676572)
                                  {
                                    sub_1CD7148D4();
                                  }
                                }
                                if (v43)
                                {
                                  BOOL v395 = *v16 == 0x733C796669726576 && v16[1] == 0x746E696F70656661;
                                  if (v395 && *((_DWORD *)v16 + 4) == 1047685421) {
                                    sub_1CD714958();
                                  }
                                }
                                if (v470)
                                {
                                  BOOL v397 = *v16 == 0x733C796669726576 && v16[1] == 0x76652D72616C6163;
                                  if (v397 && v16[2] == 0x3E6E6F6974756C6FLL) {
                                    sub_1CD7149DC();
                                  }
                                }
                                if (v259 && *v16 == 0x6766632D77656976) {
                                  sub_1CD714A60();
                                }
                                if (v217)
                                {
                                  if (*v16 == 0x6766632D77656976
                                    && *(void *)((char *)v16 + 5) == 0x796C6E6F2D676663)
                                  {
                                    sub_1CD714AE4();
                                  }
                                }
                                if (v259 && *v16 == 0x7473696F68736C74)
                                {
                                  long long v482 = 0u;
                                  long long v483 = 0u;
                                  memset(v481, 0, sizeof(v481));
                                  sub_1CD714B68();
                                }
                                if (v40)
                                {
                                  BOOL v400 = *v16 == 0x726F66736E617274 && v16[1] == 0x6E696E7261772D6DLL;
                                  if (v400 && *((unsigned char *)v16 + 16) == 103) {
                                    sub_1CD714C90();
                                  }
                                }
                                if (v220 && *(_DWORD *)v16 == 1851880308) {
                                  sub_1CD714D14();
                                }
                                int v402 = v217;
                                int v463 = v106;
                                int v466 = v44;
                                int v469 = v41;
                                int v403 = v42;
                                int v460 = v43;
                                int v471 = v46;
                                if (v15 == 7
                                  && *(_DWORD *)v16 == 1886217581
                                  && *(_DWORD *)((char *)v16 + 3) == 1718579824)
                                {
                                  sub_1CD714D98();
                                }
                                if (sub_1CCC9F0D4((char *)v16, v15, "early-cse", 9uLL))
                                {
                                  sub_1CCC9F164((int)v481, (uint64_t (*)(char *, size_t))sub_1CCC9F28C, (char *)v16, v15, "early-cse", 9uLL);
                                  if (((uint64_t)v481[1] & 1) == 0)
                                  {
                                    v520[0] = v481[0];
                                    sub_1CD714E1C();
                                  }
                                }
                                else if (sub_1CCC9F0D4((char *)v16, v15, "ee-instrument", 0xDuLL))
                                {
                                  sub_1CCC9F164((int)v481, (uint64_t (*)(char *, size_t))sub_1CCC9F2B4, (char *)v16, v15, "ee-instrument", 0xDuLL);
                                  if (((uint64_t)v481[1] & 1) == 0)
                                  {
                                    v520[0] = v481[0];
                                    sub_1CD714EAC();
                                  }
                                }
                                else if (sub_1CCC9F0D4((char *)v16, v15, "lower-matrix-intrinsics", 0x17uLL))
                                {
                                  sub_1CCC9F164((int)v481, (uint64_t (*)(char *, size_t))sub_1CCC9F2DC, (char *)v16, v15, "lower-matrix-intrinsics", 0x17uLL);
                                  if (((uint64_t)v481[1] & 1) == 0)
                                  {
                                    v520[0] = v481[0];
                                    sub_1CD714F38();
                                  }
                                }
                                else if (sub_1CCC9F0D4((char *)v16, v15, "loop-unroll", 0xBuLL))
                                {
                                  sub_1CCC9F304((unint64_t)v481, v16, v15, v409);
                                  if ((v482 & 1) == 0)
                                  {
                                    *(_OWORD *)v520 = *(_OWORD *)v481;
                                    *(_OWORD *)&v520[12] = *(_OWORD *)((char *)&v481[1] + 4);
                                    sub_1CD714FC4();
                                  }
                                }
                                else if (sub_1CCC9F0D4((char *)v16, v15, "msan", 4uLL))
                                {
                                  sub_1CCC9F844((uint64_t)v481, v16, v15);
                                  if (((uint64_t)v481[2] & 1) == 0)
                                  {
                                    *(void **)v520 = v481[0];
                                    *(_DWORD *)&v520[8] = v481[1];
                                    sub_1CD715064();
                                  }
                                }
                                else
                                {
                                  if (!sub_1CCC9F0D4((char *)v16, v15, "simplifycfg", 0xBuLL))
                                  {
                                    if (sub_1CCC9F0D4((char *)v16, v15, "loop-vectorize", 0xEuLL))
                                    {
                                      sub_1CCCA0278((unint64_t)v520, v16, v15);
                                      if ((v520[8] & 1) == 0)
                                      {
                                        LOBYTE(v481[0]) = v520[0] & 1 | (byte_1EBD0D7B0 == 0);
                                        int v424 = HIBYTE(*(unsigned __int16 *)v520) & 1;
                                        if (!byte_1EBD0D870) {
                                          LOBYTE(v424) = 1;
                                        }
                                        BYTE1(v481[0]) = v424;
                                        sub_1CD715104();
                                      }
                                    }
                                    else
                                    {
                                      if (sub_1CCC9F0D4((char *)v16, v15, "mldst-motion", 0xCuLL))
                                      {
                                        sub_1CCC9F164((int)v481, (uint64_t (*)(char *, size_t))sub_1CCCA05B8, (char *)v16, v15, "mldst-motion", 0xCuLL);
                                        if (((uint64_t)v481[1] & 1) == 0)
                                        {
                                          v520[0] = v481[0];
                                          sub_1CD7151BC();
                                        }
                                        goto LABEL_1692;
                                      }
                                      if (sub_1CCC9F0D4((char *)v16, v15, "gvn", 3uLL))
                                      {
                                        sub_1CCCA07D0((unint64_t)v520, v16, v15);
                                        if ((v520[16] & 1) == 0)
                                        {
                                          sub_1CD719FAC((uint64_t)v481, *(uint64_t *)v520, *(__int16 *)&v520[8]);
                                          sub_1CD715248();
                                        }
                                      }
                                      else
                                      {
                                        BOOL v413 = sub_1CCC9F0D4((char *)v16, v15, "print<stack-lifetime>", 0x15uLL);
                                        if (v413)
                                        {
                                          v414 = (llvm *)sub_1CCCA0B9C((unint64_t)v481, v16, v15);
                                          if (((uint64_t)v481[1] & 1) == 0)
                                          {
                                            uint64_t v415 = LODWORD(v481[0]);
                                            v416 = llvm::dbgs(v414);
                                            *(void *)v520 = v415;
                                            *(void *)&v520[8] = v416;
                                            sub_1CD71533C();
                                          }
                                          goto LABEL_1692;
                                        }
                                        if (v242)
                                        {
                                          if (*v16 == 0x616C662D706F6F6CLL && *((_DWORD *)v16 + 2) == 1852142708) {
                                            sub_1CD70B7B4();
                                          }
                                        }
                                        if (v471)
                                        {
                                          if (*v16 == 0x746E692D706F6F6CLL && v16[1] == 0x65676E6168637265) {
                                            sub_1CD70B8D8();
                                          }
                                        }
                                        if (v403)
                                        {
                                          BOOL v419 = *v16 == 0x726E752D706F6F6CLL && v16[1] == 0x2D646E612D6C6C6FLL;
                                          if (v419 && *(void *)((char *)v16 + 11) == 0x6D616A2D646E612DLL)
                                          {
                                            LODWORD(__p) = 2;
                                            sub_1CD70B9FC();
                                          }
                                        }
                                        if (v466)
                                        {
                                          if (*v16 == 0x6F6C2D706F2D6F6ELL
                                            && *(void *)((char *)v16 + 6) == 0x7473656E706F6F6CLL)
                                          {
                                            sub_1CCCA0E44();
                                          }
                                        }
                                        if (v242)
                                        {
                                          if (*v16 == 0x72662D6E6F6E6163 && *((_DWORD *)v16 + 2) == 1702520165) {
                                            sub_1CD70BB40();
                                          }
                                        }
                                        if (v15 == 7)
                                        {
                                          if (*(_DWORD *)v16 == 762605412 && *(_DWORD *)((char *)v16 + 3) == 1734632493) {
                                            sub_1CD70BBC4();
                                          }
                                        }
                                        else if (v469)
                                        {
                                          if (*v16 == 0x6164696C61766E69
                                            && *(void *)((char *)v16 + 7) == 0x3E6C6C613C657461)
                                          {
                                            sub_1CD70BC48();
                                          }
                                        }
                                        else if (v15 == 10)
                                        {
                                          if (*v16 == 0x6964692D706F6F6CLL && *((_WORD *)v16 + 4) == 28015) {
                                            sub_1CD70BCCC();
                                          }
                                          if (*v16 == 0x6F6C2D706F2D6F6ELL && *((_WORD *)v16 + 4) == 28783) {
                                            operator new();
                                          }
                                        }
                                        else if (v40)
                                        {
                                          if (*v16 == 0x736E692D706F6F6CLL
                                            && v16[1] == 0x66696C706D697374
                                            && *((unsigned char *)v16 + 16) == 121)
                                          {
                                            sub_1CD70BD50();
                                          }
                                        }
                                        else if (v15 == 11 {
                                               && *v16 == 0x746F722D706F6F6CLL
                                        }
                                               && *(void *)((char *)v16 + 3) == 0x657461746F722D70)
                                        {
                                          LOWORD(__p) = 1;
                                          sub_1CD70BDD4();
                                        }
                                        if (v476)
                                        {
                                          if (*(_DWORD *)v16 == 1852404336 && *((unsigned char *)v16 + 4) == 116)
                                          {
                                            *(_OWORD *)v520 = (unint64_t)llvm::dbgs((llvm *)v413);
                                            v520[31] = 0;
                                            sub_1CD70BE90();
                                          }
                                        }
                                        if (v402)
                                        {
                                          if (*v16 == 0x6C65642D706F6F6CLL
                                            && *(void *)((char *)v16 + 5) == 0x6E6F6974656C6564)
                                          {
                                            sub_1CD70BF40();
                                          }
                                        }
                                        if (v471)
                                        {
                                          if (*v16 == 0x6D69732D706F6F6CLL && v16[1] == 0x6766637966696C70) {
                                            sub_1CD70BFC4();
                                          }
                                        }
                                        if (v15 == 11)
                                        {
                                          if (*v16 == 0x6465722D706F6F6CLL
                                            && *(void *)((char *)v16 + 3) == 0x6563756465722D70)
                                          {
                                            sub_1CD70C048();
                                          }
                                        }
                                        else if (v15 == 7 {
                                               && *(_DWORD *)v16 == 1986293353
                                        }
                                               && *(_DWORD *)((char *)v16 + 3) == 1936875894)
                                        {
                                          LOBYTE(__p) = 1;
                                          sub_1CD70C0CC();
                                        }
                                        if (v471)
                                        {
                                          if (*v16 == 0x726E752D706F6F6CLL && v16[1] == 0x6C6C75662D6C6C6FLL)
                                          {
                                            LODWORD(__p) = 2;
                                            WORD2(__p) = 0;
                                            sub_1CD70C15C();
                                          }
                                        }
                                        if (v40)
                                        {
                                          if (*v16 == 0x63612D746E697270
                                            && v16[1] == 0x666E692D73736563
                                            && *((unsigned char *)v16 + 16) == 111)
                                          {
                                            std::string __p = llvm::dbgs((llvm *)v413);
                                            sub_1CD70C1E8();
                                          }
                                        }
                                        else if (v15 == 10)
                                        {
                                          if (*v16 == 0x64643C746E697270 && *((_WORD *)v16 + 4) == 15975)
                                          {
                                            std::string __p = llvm::dbgs((llvm *)v413);
                                            sub_1CD70C274();
                                          }
                                        }
                                        else if (v469)
                                        {
                                          if (*v16 == 0x76693C746E697270
                                            && *(void *)((char *)v16 + 7) == 0x3E73726573752D76)
                                          {
                                            std::string __p = llvm::dbgs((llvm *)v413);
                                            sub_1CD70C300();
                                          }
                                          if (*v16 == 0x6F6C3C746E697270
                                            && *(void *)((char *)v16 + 7) == 0x3E7473656E706F6FLL)
                                          {
                                            std::string __p = llvm::dbgs((llvm *)v413);
                                            sub_1CD70C38C();
                                          }
                                        }
                                        if (v463)
                                        {
                                          BOOL v442 = *v16 == 0x6F6C3C746E697270 && v16[1] == 0x65686361632D706FLL;
                                          if (v442 && *(void *)((char *)v16 + 14) == 0x3E74736F632D6568)
                                          {
                                            std::string __p = llvm::dbgs((llvm *)v413);
                                            sub_1CD70C418();
                                          }
                                        }
                                        if (v471)
                                        {
                                          if (*v16 == 0x6572702D706F6F6CLL && v16[1] == 0x6E6F697461636964) {
                                            sub_1CD70C4A4();
                                          }
                                        }
                                        if (v466)
                                        {
                                          if (*v16 == 0x69772D6472617567
                                            && *(void *)((char *)v16 + 6) == 0x676E696E65646977)
                                          {
                                            sub_1CD70C528();
                                          }
                                        }
                                        if (v471)
                                        {
                                          if (*v16 == 0x756F622D706F6F6CLL && v16[1] == 0x74696C70732D646ELL) {
                                            sub_1CD70C5AC();
                                          }
                                        }
                                        if (v15 == 11
                                          && *v16 == 0x7265722D706F6F6CLL
                                          && *(void *)((char *)v16 + 3) == 0x6C6C6F7265722D70)
                                        {
                                          sub_1CD70C630();
                                        }
                                        if (v460)
                                        {
                                          BOOL v448 = *v16 == 0x7265762D706F6F6CLL && v16[1] == 0x2D676E696E6F6973;
                                          if (v448 && *((_DWORD *)v16 + 4) == 1835231596) {
                                            sub_1CD70C6B4();
                                          }
                                        }
                                        if (sub_1CCC9F0D4((char *)v16, v15, "simple-loop-unswitch", 0x14uLL))
                                        {
                                          sub_1CCCA0FD8((unint64_t)v520, (uint64_t)v16, v15);
                                          if ((v520[8] & 1) == 0)
                                          {
                                            LOWORD(v480) = *(_WORD *)v520 & 0x101;
                                            sub_1CD70C738();
                                          }
                                        }
                                        else if (sub_1CCC9F0D4((char *)v16, v15, "licm", 4uLL))
                                        {
                                          sub_1CCCA12F0((unint64_t)v520, v16, v15, "licm", 4uLL);
                                          if ((v520[16] & 1) == 0)
                                          {
                                            std::string __p = *(void **)v520;
                                            LODWORD(v479) = *(_DWORD *)&v520[8];
                                            sub_1CD70C7C8();
                                          }
                                        }
                                        else
                                        {
                                          if (!sub_1CCC9F0D4((char *)v16, v15, "lnicm", 5uLL))
                                          {
                                            uint64_t v450 = *(unsigned int *)(v10 + 1672);
                                            if (!v450)
                                            {
LABEL_1881:
                                              v481[0] = "unknown function pass '{0}'";
                                              v481[1] = (void *)27;
                                              v481[2] = &v483;
                                              v481[3] = (void *)1;
                                              *(void *)&long long v482 = &unk_1F2635860;
                                              *((void *)&v482 + 1) = v7;
                                              *(void *)&long long v483 = &v482;
                                              sub_1CD465B2C((uint64_t)v481, v520);
                                              std::string __p = (void *)llvm::inconvertibleErrorCode(v453);
                                              uint64_t v479 = v454;
                                              sub_1CCC9EDCC();
                                            }
                                            v451 = (uint64_t *)(*(void *)(v10 + 1664) + 24);
                                            uint64_t v452 = 32 * v450;
                                            while (!sub_1CCCAD3CC(*v451, *v7, v7[1], (uint64_t)v9, v7[2], 0xCCCCCCCCCCCCCCCDLL * ((v7[3] - v7[2]) >> 3)))
                                            {
                                              v451 += 4;
                                              v452 -= 32;
                                              if (!v452) {
                                                goto LABEL_1881;
                                              }
                                            }
LABEL_1585:
                                            *int v12 = 0;
                                            return;
                                          }
                                          sub_1CCCA12F0((unint64_t)v520, v16, v15, "lnicm", 5uLL);
                                          if ((v520[16] & 1) == 0)
                                          {
                                            std::string __p = *(void **)v520;
                                            LODWORD(v479) = *(_DWORD *)&v520[8];
                                            sub_1CD70C888();
                                          }
                                        }
                                      }
                                    }
                                    v412 = *(void **)v520;
LABEL_1693:
                                    *int v12 = v412;
                                    return;
                                  }
                                  sub_1CCC9FBCC((unint64_t)v481, v16, v15);
                                  if (((uint64_t)v481[3] & 1) == 0)
                                  {
                                    *(_OWORD *)v520 = *(_OWORD *)v481;
                                    *(void **)&v520[16] = v481[2];
                                    sub_1CCEDA240((uint64_t)v520);
                                    sub_1CCCAD52C();
                                  }
                                }
LABEL_1692:
                                v412 = v481[0];
                                goto LABEL_1693;
                              }
                              int v476 = 0;
                              goto LABEL_1079;
                            }
                            if (v15 == 10 && *v16 == 0x726F776F6C6C6568 && *((_WORD *)v16 + 4) == 25708) {
                              sub_1CD7115E0();
                            }
                          }
                          int v259 = 0;
                          goto LABEL_836;
                      }
                      int v242 = 0;
                      goto LABEL_747;
                    }
LABEL_647:
                    if (*v16 == 0x637369642D646461 && v16[1] == 0x6F74616E696D6972 && *((_WORD *)v16 + 8) == 29554) {
                      sub_1CD710644();
                    }
                    goto LABEL_654;
                  }
                  int v220 = 0;
                  if (!v47) {
                    goto LABEL_654;
                  }
                  goto LABEL_647;
                }
                uint64_t v217 = 0;
                goto LABEL_630;
            }
            int v71 = 0;
            int v70 = 0;
            int v46 = v151;
            int v40 = v150;
            int v43 = v149;
            int v44 = v148;
            int v42 = v147;
            size_t v15 = v477;
            int v47 = v464;
            int v41 = v467;
            int v45 = v472;
            BOOL v39 = v474;
            int v48 = v461;
            int v38 = v458;
            if (v461) {
              goto LABEL_394;
            }
            goto LABEL_404;
          }
          if (*v16 == 0x3C65726975716572
            && v16[1] == 0x2D72656E696C6E69
            && v16[2] == 0x7473652D657A6973
            && *(void *)((char *)v16 + 23) == 0x3E726F74616D6974)
          {
            sub_1CD70ED08();
          }
        }
        if ((v49 & 1) == 0)
        {
          if ((v45 & 1) == 0)
          {
            int v48 = 0;
            int v47 = 0;
            int v46 = 0;
            int v45 = 0;
            int v42 = 0;
            int v40 = 0;
            BOOL v39 = 0;
            int v38 = 0;
            int v138 = 0;
            if ((v50 & 1) == 0) {
              goto LABEL_359;
            }
            goto LABEL_350;
          }
          int v47 = 0;
          BOOL v39 = 0;
          goto LABEL_331;
        }
        goto LABEL_268;
    }
  }
  if (v15 == 4)
  {
    if (*(_DWORD *)v16 != 1886351212) {
      goto LABEL_58;
    }
  }
  else
  {
    if (v15 != 9)
    {
      if (v15 == 8 && *v16 == 0x6E6F6974636E7566)
      {
        memset(v520, 0, 24);
        uint64_t v17 = 40 * (((uint64_t)v14 - v13) / 40);
        while (1)
        {
          llvm::PassBuilder::parseFunctionPass(v10, v520, v13);
          if (*v12) {
            goto LABEL_69;
          }
          v13 += 40;
          v17 -= 40;
          if (!v17)
          {
            uint64_t v19 = *(uint64_t **)&v520[8];
            uint64_t v18 = *(uint64_t **)v520;
            *int v12 = 0;
            if (v18 != v19)
            {
              int v20 = v9 + 2;
              uint64_t v21 = v9[1];
              do
              {
                if ((unint64_t)v21 >= *v20)
                {
                  uint64_t v23 = (v21 - *v9) >> 3;
                  if ((unint64_t)(v23 + 1) >> 61) {
                    abort();
                  }
                  uint64_t v24 = *v20 - (void)*v9;
                  uint64_t v25 = v24 >> 2;
                  if (v24 >> 2 <= (unint64_t)(v23 + 1)) {
                    uint64_t v25 = v23 + 1;
                  }
                  if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v26 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v26 = v25;
                  }
                  *(void *)&long long v482 = v9 + 2;
                  if (v26)
                  {
                    if (v26 >> 61) {
                      sub_1CB833614();
                    }
                    unint64_t v27 = (char *)operator new(8 * v26);
                  }
                  else
                  {
                    unint64_t v27 = 0;
                  }
                  BOOL v28 = &v27[8 * v23];
                  int v29 = &v27[8 * v26];
                  v481[3] = v29;
                  uint64_t v30 = *v18;
                  uint64_t *v18 = 0;
                  *(void *)BOOL v28 = v30;
                  uint64_t v21 = v28 + 8;
                  v481[2] = v28 + 8;
                  uint64_t v32 = *v9;
                  uint64_t v31 = v9[1];
                  if (v31 == *v9)
                  {
                    int64x2_t v34 = vdupq_n_s64((unint64_t)v31);
                  }
                  else
                  {
                    do
                    {
                      uint64_t v33 = *((void *)v31 - 1);
                      v31 -= 8;
                      *(void *)uint64_t v31 = 0;
                      *((void *)v28 - 1) = v33;
                      v28 -= 8;
                    }
                    while (v31 != v32);
                    int64x2_t v34 = *(int64x2_t *)v9;
                    int v29 = (char *)v481[3];
                    uint64_t v21 = (char *)v481[2];
                  }
                  char *v9 = v28;
                  v9[1] = v21;
                  *(int64x2_t *)&v481[1] = v34;
                  int64x2_t v35 = v9[2];
                  void v9[2] = v29;
                  v481[3] = v35;
                  v481[0] = (void *)v34.i64[0];
                  sub_1CCCB76EC((uint64_t)v481);
                }
                else
                {
                  uint64_t v22 = *v18;
                  uint64_t *v18 = 0;
                  *(void *)uint64_t v21 = v22;
                  v21 += 8;
                }
                v9[1] = v21;
                ++v18;
              }
              while (v18 != v19);
            }
            *int v12 = 0;
            goto LABEL_69;
          }
        }
      }
      goto LABEL_58;
    }
    if (*v16 != 0x73736D2D706F6F6CLL || *((unsigned char *)v16 + 8) != 97)
    {
LABEL_58:
      unint64_t v55 = sub_1CCC9ECD8((_DWORD *)*v5, v5[1], (uint64_t)v5, v6);
      if (HIDWORD(v55))
      {
        int v60 = v55;
        memset(v520, 0, 24);
        uint64_t v61 = 40 * (((uint64_t)v14 - v13) / 40);
        while (1)
        {
          llvm::PassBuilder::parseFunctionPass(v10, v520, v13);
          if (*v12) {
            break;
          }
          v13 += 40;
          v61 -= 40;
          if (!v61)
          {
            uint64_t v62 = *(void **)&v520[16];
            *int v12 = 0;
            LODWORD(v481[0]) = v60;
            *(_OWORD *)&v481[1] = *(_OWORD *)v520;
            v481[3] = v62;
            memset(v520, 0, 24);
            sub_1CD70DEC0();
          }
        }
LABEL_69:
        v481[0] = v520;
        sub_1CCCB67B8((void ***)v481);
        return;
      }
      uint64_t v56 = *(unsigned int *)(v10 + 1672);
      if (!v56)
      {
LABEL_63:
        v481[0] = "invalid use of '{0}' pass as function pipeline";
        v481[1] = (void *)46;
        v481[2] = &v483;
        v481[3] = (void *)1;
        *(void *)&long long v482 = &unk_1F2635860;
        *((void *)&v482 + 1) = v7;
        *(void *)&long long v483 = &v482;
        sub_1CD465B2C((uint64_t)v481, &__p);
        llvm::inconvertibleErrorCode(v59);
        operator new();
      }
      uint64_t v57 = (uint64_t *)(*(void *)(v10 + 1664) + 24);
      uint64_t v58 = 32 * v56;
      while (!sub_1CCCAD3CC(*v57, *v7, v7[1], (uint64_t)v9, v7[2], 0xCCCCCCCCCCCCCCCDLL * ((v7[3] - v7[2]) >> 3)))
      {
        v57 += 4;
        v58 -= 32;
        if (!v58) {
          goto LABEL_63;
        }
      }
      goto LABEL_1585;
    }
  }
  v481[0] = &v481[2];
  v481[1] = (void *)0x600000000;
  LODWORD(v484[0]) = 0;
  memset((char *)v484 + 8, 0, 48);
  uint64_t v63 = 40 * (((uint64_t)v14 - v13) / 40);
  while (1)
  {
    llvm::PassBuilder::parseLoopPass(v10, (uint64_t)v481, v13, v6, v12);
    if (*v12) {
      break;
    }
    v13 += 40;
    v63 -= 40;
    if (!v63)
    {
      *int v12 = 0;
      uint64_t v296 = v7[2];
      uint64_t v297 = v7[3];
      if (v296 != v297)
      {
        do
        {
          *(_OWORD *)v520 = *(_OWORD *)v296;
          *(void *)&v520[24] = 0;
          uint64_t v521 = 0;
          *(void *)&v520[16] = 0;
          sub_1CCCBDF0C(&v520[16], *(_OWORD **)(v296 + 16), *(_OWORD **)(v296 + 24), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v296 + 24) - *(void *)(v296 + 16)) >> 3));
          if (*(void *)&v520[8] == 4)
          {
            int v298 = **(_DWORD **)v520;
            std::string __p = &v520[16];
            sub_1CCCBB47C((void ***)&__p);
            if (v298 == 1835231596) {
              break;
            }
          }
          else
          {
            std::string __p = &v520[16];
            sub_1CCCBB47C((void ***)&__p);
          }
          v296 += 40;
        }
        while (v296 != v297);
        uint64_t v405 = v7[2];
        for (uint64_t j = v7[3]; v405 != j; v405 += 40)
        {
          *(_OWORD *)v520 = *(_OWORD *)v405;
          *(void *)&v520[24] = 0;
          uint64_t v521 = 0;
          *(void *)&v520[16] = 0;
          sub_1CCCBDF0C(&v520[16], *(_OWORD **)(v405 + 16), *(_OWORD **)(v405 + 24), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v405 + 24) - *(void *)(v405 + 16)) >> 3));
          if (*(void *)&v520[8] == 16)
          {
            BOOL v408 = **(void **)v520 != 0x6572702D706F6F6CLL
                || *(void *)(*(void *)v520 + 8) != 0x6E6F697461636964;
            std::string __p = &v520[16];
            sub_1CCCBB47C((void ***)&__p);
            if (!v408) {
              break;
            }
          }
          else
          {
            std::string __p = &v520[16];
            sub_1CCCBB47C((void ***)&__p);
          }
        }
      }
      sub_1CD70DDA8();
    }
  }
  *(void *)v520 = &v484[2];
  sub_1CCCB7490((void ***)v520);
  *(void *)v520 = (char *)v484 + 8;
  sub_1CCCB7538((void ***)v520);
  if (v481[0] != &v481[2]) {
    free(v481[0]);
  }
}

uint64_t sub_1CCCAD3CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v8[0] = a2;
  v8[1] = a3;
  v7[0] = a5;
  v7[1] = a6;
  if (!a1)
  {
    sub_1CB920400();
    sub_1CCCAD42C();
  }
  return (*(uint64_t (**)(uint64_t, void *, uint64_t, void *))(*(void *)a1 + 48))(a1, v8, a4, v7);
}

void sub_1CCCAD42C()
{
  sub_1CCCC1134();
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  sub_1CCCC111C();
}

void sub_1CCCAD52C()
{
}

void llvm::PassBuilder::parseLoopPass(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t *a4@<X3>, void **a5@<X8>)
{
  uint64_t v110 = *MEMORY[0x1E4F143B8];
  long long v97 = *(_OWORD *)a3;
  uint64_t v9 = *(void *)(a3 + 16);
  uint64_t v10 = *(void *)(a3 + 24);
  if (v9 == v10)
  {
    switch(*((void *)&v97 + 1))
    {
      case 5:
        if (*(_DWORD *)v97 == 1852404336 && *(unsigned char *)(v97 + 4) == 116)
        {
          BOOL v98 = llvm::dbgs((llvm *)a1);
          v99[0] = 0;
          HIBYTE(v100) = 0;
          sub_1CD716040();
        }
        return;
      case 7:
        if (*(_DWORD *)v97 == 762605412 && *(_DWORD *)(v97 + 3) == 1734632493) {
          sub_1CD715D28();
        }
        if (*(_DWORD *)v97 == 1986293353 && *(_DWORD *)(v97 + 3) == 1936875894)
        {
          LOBYTE(v98) = 1;
          sub_1CD7162D0();
        }
        return;
      case 0xALL:
        if (*(void *)v97 == 0x6964692D706F6F6CLL && *(_WORD *)(v97 + 8) == 28015) {
          sub_1CD715E58();
        }
        if (*(void *)v97 == 0x6F6C2D706F2D6F6ELL && *(_WORD *)(v97 + 8) == 28783)
        {
          int v90 = *(_DWORD *)(a2 + 64);
          int v91 = v90 + 1;
          uint64_t v92 = *(unsigned int *)(a2 + 8);
          if ((v90 + 1) <= v92 << 6)
          {
            *(_DWORD *)(a2 + 64) = v91;
          }
          else
          {
            if ((v90 & 0x3F) != 0) {
              *(void *)(*(void *)a2 + 8 * v92 - 8) &= ~(-1 << (v90 & 0x3F));
            }
            *(_DWORD *)(a2 + 64) = v91;
            unsigned int v93 = v90 + 64;
            if (v92 != v93 >> 6)
            {
              uint64_t v94 = v93 >> 6;
              if (v92 > v94)
              {
                *(_DWORD *)(a2 + 8) = v94;
                LODWORD(v92) = v93 >> 6;
              }
              else
              {
                if (v94 > *(_DWORD *)(a2 + 12)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                if (v94 != v92) {
                  bzero((void *)(*(void *)a2 + 8 * v92), 8 * (v94 - v92));
                }
                LODWORD(v92) = v94;
                *(_DWORD *)(a2 + 8) = v94;
                int v91 = *(_DWORD *)(a2 + 64);
              }
            }
            int v95 = v91 & 0x3F;
            if (v95) {
              *(void *)(*(void *)a2 + 8 * v92 - 8) &= ~(-1 << v95);
            }
          }
          operator new();
        }
        if (*(void *)v97 == 0x64643C746E697270 && *(_WORD *)(v97 + 8) == 15975)
        {
          BOOL v98 = llvm::dbgs((llvm *)a1);
          sub_1CD7164D0();
        }
        return;
      case 0xBLL:
        if (*(void *)v97 == 0x746F722D706F6F6CLL && *(void *)(v97 + 3) == 0x657461746F722D70)
        {
          LOWORD(v98) = 1;
          sub_1CD715F8C();
        }
        if (*(void *)v97 == 0x6465722D706F6F6CLL && *(void *)(v97 + 3) == 0x6563756465722D70) {
          sub_1CD716238();
        }
        if (*(void *)v97 == 0x7265722D706F6F6CLL && *(void *)(v97 + 3) == 0x6C6C6F7265722D70) {
          sub_1CD716918();
        }
        return;
      case 0xCLL:
        if (*(void *)v97 == 0x616C662D706F6F6CLL && *(_DWORD *)(v97 + 8) == 1852142708) {
          sub_1CD715620(a2);
        }
        if (*(void *)v97 == 0x3C65726975716572 && *(_DWORD *)(v97 + 8) == 1046963300) {
          sub_1CD715900();
        }
        if (*(void *)v97 == 0x72662D6E6F6E6163 && *(_DWORD *)(v97 + 8) == 1702520165) {
          sub_1CD715C90();
        }
        return;
      case 0xDLL:
        if (*(void *)v97 == 0x6C65642D706F6F6CLL && *(void *)(v97 + 5) == 0x6E6F6974656C6564) {
          sub_1CD716100();
        }
        return;
      case 0xELL:
        if (*(void *)v97 == 0x6F6C2D706F2D6F6ELL && *(void *)(v97 + 6) == 0x7473656E706F6F6CLL) {
          sub_1CCCAEC10(a2);
        }
        if (*(void *)v97 == 0x69772D6472617567 && *(void *)(v97 + 6) == 0x676E696E65646977) {
          sub_1CD7167E8();
        }
        return;
      case 0xFLL:
        if (*(void *)v97 == 0x6164696C61766E69 && *(void *)(v97 + 7) == 0x3E6764643C657461) {
          sub_1CD715998();
        }
        if (*(void *)v97 == 0x6164696C61766E69 && *(void *)(v97 + 7) == 0x3E6C6C613C657461) {
          sub_1CD715DC0();
        }
        if (*(void *)v97 == 0x76693C746E697270 && *(void *)(v97 + 7) == 0x3E73726573752D76)
        {
          BOOL v98 = llvm::dbgs((llvm *)a1);
          sub_1CD716570();
        }
        if (*(void *)v97 == 0x6F6C3C746E697270 && *(void *)(v97 + 7) == 0x3E7473656E706F6FLL)
        {
          BOOL v98 = llvm::dbgs((llvm *)a1);
          sub_1CD716610();
        }
        return;
      case 0x10:
        if (*(void *)v97 == 0x746E692D706F6F6CLL && *(void *)(v97 + 8) == 0x65676E6168637265) {
          sub_1CD7156A8(a2);
        }
        if (*(void *)v97 == 0x6D69732D706F6F6CLL && *(void *)(v97 + 8) == 0x6766637966696C70) {
          sub_1CD71619C();
        }
        if (*(void *)v97 == 0x726E752D706F6F6CLL && *(void *)(v97 + 8) == 0x6C6C75662D6C6C6FLL)
        {
          LODWORD(v98) = 2;
          WORD2(v98) = 0;
          sub_1CD716384();
        }
        if (*(void *)v97 == 0x6572702D706F6F6CLL && *(void *)(v97 + 8) == 0x6E6F697461636964) {
          sub_1CD716750();
        }
        if (*(void *)v97 == 0x756F622D706F6F6CLL && *(void *)(v97 + 8) == 0x74696C70732D646ELL) {
          sub_1CD716880();
        }
        return;
      case 0x11:
        if (*(void *)v97 == 0x3C65726975716572
          && *(void *)(v97 + 8) == 0x73726573752D7669
          && *(unsigned char *)(v97 + 16) == 62)
        {
          sub_1CD715A30();
        }
        if (*(void *)v97 == 0x736E692D706F6F6CLL
          && *(void *)(v97 + 8) == 0x66696C706D697374
          && *(unsigned char *)(v97 + 16) == 121)
        {
          sub_1CD715EF0();
        }
        if (*(void *)v97 == 0x63612D746E697270
          && *(void *)(v97 + 8) == 0x666E692D73736563
          && *(unsigned char *)(v97 + 16) == 111)
        {
          BOOL v98 = llvm::dbgs((llvm *)a1);
          sub_1CD716430();
        }
        return;
      case 0x13:
        if (*(void *)v97 == 0x726E752D706F6F6CLL
          && *(void *)(v97 + 8) == 0x2D646E612D6C6C6FLL
          && *(void *)(v97 + 11) == 0x6D616A2D646E612DLL)
        {
          LODWORD(v98) = 2;
          sub_1CD715730(a2);
        }
        if (*(void *)v97 == 0x3C65726975716572
          && *(void *)(v97 + 8) == 0x6F6C2D706F2D6F6ELL
          && *(void *)(v97 + 11) == 0x3E706F6F6C2D706FLL)
        {
          int v28 = *(_DWORD *)(a2 + 64);
          int v29 = v28 + 1;
          uint64_t v30 = *(unsigned int *)(a2 + 8);
          if ((v28 + 1) <= v30 << 6)
          {
            *(_DWORD *)(a2 + 64) = v29;
          }
          else
          {
            if ((v28 & 0x3F) != 0) {
              *(void *)(*(void *)a2 + 8 * v30 - 8) &= ~(-1 << (v28 & 0x3F));
            }
            *(_DWORD *)(a2 + 64) = v29;
            unsigned int v31 = v28 + 64;
            if (v30 != v31 >> 6)
            {
              uint64_t v32 = v31 >> 6;
              if (v30 > v32)
              {
                *(_DWORD *)(a2 + 8) = v32;
                LODWORD(v30) = v31 >> 6;
              }
              else
              {
                if (v32 > *(_DWORD *)(a2 + 12)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                if (v32 != v30) {
                  bzero((void *)(*(void *)a2 + 8 * v30), 8 * (v32 - v30));
                }
                LODWORD(v30) = v32;
                *(_DWORD *)(a2 + 8) = v32;
                int v29 = *(_DWORD *)(a2 + 64);
              }
            }
            int v33 = v29 & 0x3F;
            if (v33) {
              *(void *)(*(void *)a2 + 8 * v30 - 8) &= ~(-1 << v33);
            }
          }
          operator new();
        }
        return;
      case 0x14:
        if (*(void *)v97 == 0x3C65726975716572
          && *(void *)(v97 + 8) == 0x692D737365636361
          && *(_DWORD *)(v97 + 16) == 1047488110)
        {
          sub_1CD7157D0();
        }
        if (*(void *)v97 == 0x6164696C61766E69
          && *(void *)(v97 + 8) == 0x73752D76693C6574
          && *(_DWORD *)(v97 + 16) == 1047753317)
        {
          sub_1CD715AC8();
        }
        if (*(void *)v97 == 0x7265762D706F6F6CLL
          && *(void *)(v97 + 8) == 0x2D676E696E6F6973
          && *(_DWORD *)(v97 + 16) == 1835231596)
        {
          sub_1CD7169B0();
        }
        return;
      case 0x16:
        if (*(void *)v97 == 0x6164696C61766E69
          && *(void *)(v97 + 8) == 0x706F2D6F6E3C6574
          && *(void *)(v97 + 14) == 0x3E706F6F6C2D706FLL)
        {
          int v84 = *(_DWORD *)(a2 + 64);
          int v85 = v84 + 1;
          uint64_t v86 = *(unsigned int *)(a2 + 8);
          if ((v84 + 1) <= v86 << 6)
          {
            *(_DWORD *)(a2 + 64) = v85;
          }
          else
          {
            if ((v84 & 0x3F) != 0) {
              *(void *)(*(void *)a2 + 8 * v86 - 8) &= ~(-1 << (v84 & 0x3F));
            }
            *(_DWORD *)(a2 + 64) = v85;
            unsigned int v87 = v84 + 64;
            if (v86 != v87 >> 6)
            {
              uint64_t v88 = v87 >> 6;
              if (v86 > v88)
              {
                *(_DWORD *)(a2 + 8) = v88;
                LODWORD(v86) = v87 >> 6;
              }
              else
              {
                if (v88 > *(_DWORD *)(a2 + 12)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                if (v88 != v86) {
                  bzero((void *)(*(void *)a2 + 8 * v86), 8 * (v88 - v86));
                }
                LODWORD(v86) = v88;
                *(_DWORD *)(a2 + 8) = v88;
                int v85 = *(_DWORD *)(a2 + 64);
              }
            }
            int v89 = v85 & 0x3F;
            if (v89) {
              *(void *)(*(void *)a2 + 8 * v86 - 8) &= ~(-1 << v89);
            }
          }
          operator new();
        }
        if (*(void *)v97 == 0x6F6C3C746E697270
          && *(void *)(v97 + 8) == 0x65686361632D706FLL
          && *(void *)(v97 + 14) == 0x3E74736F632D6568)
        {
          BOOL v98 = llvm::dbgs((llvm *)a1);
          sub_1CD7166B0();
        }
        return;
      case 0x17:
        if (*(void *)v97 == 0x6164696C61766E69
          && *(void *)(v97 + 8) == 0x73656363613C6574
          && *(void *)(v97 + 15) == 0x3E6F666E692D7373)
        {
          sub_1CD715868();
        }
        return;
      case 0x1DLL:
        if (*(void *)v97 == 0x3C65726975716572
          && *(void *)(v97 + 8) == 0x736E692D73736170
          && *(void *)(v97 + 16) == 0x61746E656D757274
          && *(void *)(v97 + 21) == 0x3E6E6F697461746ELL)
        {
          sub_1CD715B60();
        }
        return;
      case 0x20:
        if (*(void *)v97 == 0x6164696C61766E69
          && *(void *)(v97 + 8) == 0x2D737361703C6574
          && *(void *)(v97 + 16) == 0x656D757274736E69
          && *(void *)(v97 + 24) == 0x3E6E6F697461746ELL)
        {
          sub_1CD715BF8();
        }
        return;
      default:
        break;
    }
    if (sub_1CCC9F0D4((char *)v97, *((size_t *)&v97 + 1), "simple-loop-unswitch", 0x14uLL))
    {
      sub_1CCCA0FD8((unint64_t)&v98, v97, *((unint64_t *)&v97 + 1));
      if (((uint64_t)v99[0] & 1) == 0)
      {
        LOWORD(v106) = (unsigned __int16)v98 & 0x101;
        sub_1CD716A48();
      }
    }
    else if (sub_1CCC9F0D4((char *)v97, *((size_t *)&v97 + 1), "licm", 4uLL))
    {
      sub_1CCCA12F0((unint64_t)&v98, (unsigned char *)v97, *((size_t *)&v97 + 1), "licm", 4uLL);
      if (((uint64_t)v99[1] & 1) == 0)
      {
        int v106 = (void **)v98;
        LODWORD(v107) = v99[0];
        sub_1CD716AF8();
      }
    }
    else
    {
      if (!sub_1CCC9F0D4((char *)v97, *((size_t *)&v97 + 1), "lnicm", 5uLL))
      {
        uint64_t v79 = *(unsigned int *)(a1 + 1832);
        if (!v79)
        {
LABEL_269:
          BOOL v98 = "unknown loop pass '{0}'";
          v99[0] = (void *)23;
          v99[1] = v103;
          uint64_t v100 = 1;
          uint64_t v101 = &unk_1F2617F90;
          uint64_t v102 = &v97;
          v103[0] = &v101;
          sub_1CD465B2C((uint64_t)&v98, &v106);
          __p[0] = (void *)llvm::inconvertibleErrorCode(v82);
          __p[1] = v83;
          sub_1CCC9EDCC();
        }
        BOOL v80 = (uint64_t *)(*(void *)(a1 + 1824) + 24);
        uint64_t v81 = 32 * v79;
        while (!sub_1CCCAEBB0(*v80, v97, *((uint64_t *)&v97 + 1), a2, *(void *)(a3 + 16), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a3 + 24) - *(void *)(a3 + 16)) >> 3)))
        {
          v80 += 4;
          v81 -= 32;
          if (!v81) {
            goto LABEL_269;
          }
        }
        goto LABEL_300;
      }
      sub_1CCCA12F0((unint64_t)&v98, (unsigned char *)v97, *((size_t *)&v97 + 1), "lnicm", 5uLL);
      if (((uint64_t)v99[1] & 1) == 0)
      {
        int v106 = (void **)v98;
        LODWORD(v107) = v99[0];
        sub_1CD716BAC(a2);
      }
    }
    *a5 = v98;
    return;
  }
  if (*((void *)&v97 + 1) == 4 && *(_DWORD *)v97 == 1886351212)
  {
    uint64_t v18 = &v99[1];
    BOOL v98 = &v99[1];
    v99[0] = (void *)0x600000000;
    int v104 = 0;
    memset(v105, 0, sizeof(v105));
    uint64_t v21 = 40 * ((v10 - v9) / 40);
    while (1)
    {
      llvm::PassBuilder::parseLoopPass(a1, &v98, v9);
      if (*a5) {
        break;
      }
      v9 += 40;
      v21 -= 40;
      if (!v21)
      {
        *a5 = 0;
        sub_1CD7153D4();
      }
    }
    int v106 = (void **)&v105[1] + 1;
    sub_1CCCB7490(&v106);
    int v106 = (void **)v105;
    sub_1CCCB7538(&v106);
    int v20 = (void **)v98;
  }
  else
  {
    unint64_t v11 = sub_1CCC9ECD8((_DWORD *)v97, *((unint64_t *)&v97 + 1), a3, a4);
    if (!HIDWORD(v11))
    {
      uint64_t v12 = *(unsigned int *)(a1 + 1832);
      if (!v12)
      {
LABEL_9:
        BOOL v98 = "invalid use of '{0}' pass as loop pipeline";
        v99[0] = (void *)42;
        v99[1] = v103;
        uint64_t v100 = 1;
        uint64_t v101 = &unk_1F2617F90;
        uint64_t v102 = &v97;
        v103[0] = &v101;
        sub_1CD465B2C((uint64_t)&v98, __p);
        llvm::inconvertibleErrorCode(v15);
        operator new();
      }
      uint64_t v13 = (uint64_t *)(*(void *)(a1 + 1824) + 24);
      uint64_t v14 = 32 * v12;
      while (!sub_1CCCAEBB0(*v13, v97, *((uint64_t *)&v97 + 1), a2, *(void *)(a3 + 16), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a3 + 24) - *(void *)(a3 + 16)) >> 3)))
      {
        v13 += 4;
        v14 -= 32;
        if (!v14) {
          goto LABEL_9;
        }
      }
LABEL_300:
      *a5 = 0;
      return;
    }
    int v17 = v11;
    uint64_t v18 = (void **)v108;
    int v106 = (void **)v108;
    uint64_t v107 = 0x600000000;
    v108[12] = 0;
    memset(v109, 0, sizeof(v109));
    uint64_t v19 = 40 * ((v10 - v9) / 40);
    while (1)
    {
      llvm::PassBuilder::parseLoopPass(a1, &v106, v9);
      if (*a5) {
        break;
      }
      v9 += 40;
      v19 -= 40;
      if (!v19)
      {
        *a5 = 0;
        LODWORD(v98) = v17;
        sub_1CD71A098((uint64_t)v99, (uint64_t)&v106);
        sub_1CD7154E4();
      }
    }
    BOOL v98 = (char *)&v109[1] + 8;
    sub_1CCCB7490((void ***)&v98);
    BOOL v98 = v109;
    sub_1CCCB7538((void ***)&v98);
    int v20 = v106;
  }
  if (v20 != v18) {
    free(v20);
  }
}

uint64_t sub_1CCCAEBB0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v9[0] = a2;
  v9[1] = a3;
  v8[0] = a5;
  v8[1] = a6;
  if (!a1)
  {
    sub_1CB920400();
    sub_1CCCAEC10(v7);
  }
  return (*(uint64_t (**)(uint64_t, void *, uint64_t, void *))(*(void *)a1 + 48))(a1, v9, a4, v8);
}

void sub_1CCCAEC10(uint64_t a1)
{
}

uint64_t sub_1CCCAF058(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t *a4)
{
  unsigned int v4 = a4;
  if (a2 == 19)
  {
    if (*(void *)a1 == 0x6E6F6974636E7566
      && *(void *)(a1 + 8) == 0x692D72656761653CLL
      && *(void *)(a1 + 11) == 0x3E766E692D726567)
    {
      return 1;
    }
  }
  else if (a2 == 8)
  {
    if (*(void *)a1 == 0x6E6F6974636E7566) {
      return 1;
    }
  }
  else if (a2 == 5 && *(_DWORD *)a1 == 1668507491 && *(unsigned char *)(a1 + 4) == 99)
  {
    return 1;
  }
  if ((unint64_t)sub_1CCC9ECD8((_DWORD *)a1, a2, a3, a4) >> 32
    || (unint64_t)sub_1CCCA771C((_DWORD *)a1, a2, v11, v12) >> 32)
  {
    return 1;
  }
  switch(a2)
  {
    case 0xAuLL:
      int v13 = *(unsigned __int16 *)(a1 + 8);
      BOOL v14 = *(void *)a1 == 0x6C70732D6F726F63;
      int v15 = 29801;
      goto LABEL_26;
    case 0xBuLL:
      uint64_t v16 = *(void *)(a1 + 3);
      BOOL v17 = *(void *)a1 == 0x67632D706F2D6F6ELL;
      uint64_t v18 = 0x63637367632D706FLL;
      goto LABEL_34;
    case 0xCuLL:
      int v13 = *(_DWORD *)(a1 + 8);
      BOOL v14 = *(void *)a1 == 0x6F6D6F7270677261;
      int v15 = 1852795252;
LABEL_26:
      if (!v14 || v13 != v15) {
        goto LABEL_88;
      }
      return 1;
    case 0xEuLL:
      uint64_t v16 = *(void *)(a1 + 6);
      BOOL v17 = *(void *)a1 == 0x6E6F6974636E7566;
      uint64_t v18 = 0x73727474612D6E6FLL;
      goto LABEL_34;
    case 0xFuLL:
      uint64_t v16 = *(void *)(a1 + 7);
      BOOL v17 = *(void *)a1 == 0x6164696C61766E69;
      uint64_t v18 = 0x3E6C6C613C657461;
LABEL_34:
      if (!v17 || v16 != v18) {
        goto LABEL_88;
      }
      return 1;
    case 0x10uLL:
      if (*(void *)a1 == 0x7475626972747461 && *(void *)(a1 + 8) == 0x63637367632D726FLL) {
        return 1;
      }
      uint64_t v22 = *(void *)(a1 + 8);
      uint64_t v23 = 0x63637367632D7470;
      BOOL v24 = *(void *)a1 == 0x6F2D706D6E65706FLL;
      goto LABEL_67;
    case 0x12uLL:
      int v25 = *(unsigned __int16 *)(a1 + 16);
      BOOL v26 = *(void *)a1 == 0x3C65726975716572 && *(void *)(a1 + 8) == 0x786F72702D6D6166;
      int v27 = 15993;
      goto LABEL_53;
    case 0x14uLL:
      int v25 = *(_DWORD *)(a1 + 16);
      BOOL v26 = *(void *)a1 == 0x3C65726975716572 && *(void *)(a1 + 8) == 0x67632D706F2D6F6ELL;
      int v27 = 1046700915;
LABEL_53:
      if (!v26 || v25 != v27) {
        goto LABEL_88;
      }
      return 1;
    case 0x15uLL:
      uint64_t v22 = *(void *)(a1 + 13);
      BOOL v24 = *(void *)a1 == 0x6164696C61766E69 && *(void *)(a1 + 8) == 0x702D6D61663C6574;
      uint64_t v23 = 0x3E79786F72702D6DLL;
      goto LABEL_67;
    case 0x17uLL:
      uint64_t v22 = *(void *)(a1 + 15);
      BOOL v24 = *(void *)a1 == 0x6164696C61766E69 && *(void *)(a1 + 8) == 0x706F2D6F6E3C6574;
      uint64_t v23 = 0x3E63637367632D70;
LABEL_67:
      if (!v24 || v22 != v23) {
        goto LABEL_88;
      }
      return 1;
    case 0x1DuLL:
      uint64_t v30 = *(void *)(a1 + 16);
      uint64_t v31 = *(void *)(a1 + 21);
      BOOL v32 = *(void *)a1 == 0x3C65726975716572 && *(void *)(a1 + 8) == 0x736E692D73736170;
      uint64_t v33 = 0x61746E656D757274;
      goto LABEL_81;
    case 0x20uLL:
      uint64_t v30 = *(void *)(a1 + 16);
      uint64_t v31 = *(void *)(a1 + 24);
      BOOL v32 = *(void *)a1 == 0x6164696C61766E69 && *(void *)(a1 + 8) == 0x2D737361703C6574;
      uint64_t v33 = 0x656D757274736E69;
LABEL_81:
      if (!v32 || v30 != v33 || v31 != 0x3E6E6F697461746ELL) {
        goto LABEL_88;
      }
      return 1;
    default:
LABEL_88:
      if (sub_1CCC9F0D4((char *)a1, a2, "inline", 6uLL)) {
        return 1;
      }
      if (!v4) {
        return 0;
      }
      memset(v39, 0, sizeof(v39));
      unint64_t v36 = (uint64_t *)(a3 + 24);
      uint64_t v37 = 32 * v4;
      break;
  }
  do
  {
    if (sub_1CCCA7810(*v36, a1, a2, (uint64_t)v39, 0, 0))
    {
      int v40 = (void **)v39;
      sub_1CC947208(&v40);
      return 1;
    }
    v36 += 4;
    v37 -= 32;
  }
  while (v37);
  int v40 = (void **)v39;
  sub_1CC947208(&v40);
  return 0;
}

uint64_t sub_1CCCAF560(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t *a4)
{
  unsigned int v4 = a4;
  if (a2 == 8)
  {
    if (*(void *)a1 == 0x6E6F6974636E7566) {
      return 1;
    }
    goto LABEL_15;
  }
  if (a2 != 4)
  {
    if (a2 == 9)
    {
      BOOL v27 = *(void *)a1 == 0x73736D2D706F6F6CLL && *(unsigned char *)(a1 + 8) == 97;
      int v11 = 1;
      if (v27) {
        return 1;
      }
      goto LABEL_16;
    }
    if (a2 == 19)
    {
      BOOL v9 = *(void *)a1 == 0x6E6F6974636E7566
        && *(void *)(a1 + 8) == 0x692D72656761653CLL
        && *(void *)(a1 + 11) == 0x3E766E692D726567;
      int v10 = 1;
      if (v9) {
        return 1;
      }
      int v11 = 0;
      goto LABEL_17;
    }
LABEL_15:
    int v11 = 0;
LABEL_16:
    int v10 = 0;
LABEL_17:
    int v12 = 0;
    goto LABEL_18;
  }
  int v12 = 1;
  if (*(_DWORD *)a1 == 1886351212) {
    return 1;
  }
  int v11 = 0;
  int v10 = 0;
LABEL_18:
  if ((unint64_t)sub_1CCC9ECD8((_DWORD *)a1, a2, a3, a4) >> 32) {
    return 1;
  }
  switch(a2)
  {
    case 0xBuLL:
      if (*(void *)a1 == 0x3C65726975716572 && *(void *)(a1 + 3) == 0x3E61613C65726975) {
        return 1;
      }
      goto LABEL_34;
    case 0x17uLL:
      BOOL v44 = *(void *)a1 == 0x6164696C61766E69
         && *(void *)(a1 + 8) == 0x6D757373613C6574
         && *(void *)(a1 + 15) == 0x3E736E6F6974706DLL;
      int v16 = 1;
      if (v44) {
        return 1;
      }
      goto LABEL_35;
    case 0x14uLL:
      BOOL v42 = *(void *)a1 == 0x3C65726975716572
         && *(void *)(a1 + 8) == 0x6974706D75737361
         && *(_DWORD *)(a1 + 16) == 1047752303;
      int v17 = 1;
      if (v42) {
        return 1;
      }
      int v16 = 0;
      int v15 = 0;
      if (!v10) {
        goto LABEL_44;
      }
      goto LABEL_37;
  }
  if (a2 != 14)
  {
LABEL_34:
    int v16 = 0;
LABEL_35:
    int v15 = 0;
    goto LABEL_36;
  }
  BOOL v14 = *(void *)a1 == 0x6164696C61766E69 && *(void *)(a1 + 6) == 0x3E61613C65746164;
  int v15 = 1;
  if (v14) {
    return 1;
  }
  int v16 = 0;
LABEL_36:
  int v17 = 0;
  if (!v10) {
    goto LABEL_44;
  }
LABEL_37:
  if (*(void *)a1 == 0x3C65726975716572
    && *(void *)(a1 + 8) == 0x72662D6B636F6C62
    && *(void *)(a1 + 11) == 0x3E716572662D6B63)
  {
    return 1;
  }
LABEL_44:
  if (a2 == 22)
  {
    BOOL v20 = *(void *)a1 == 0x6164696C61766E69 && *(void *)(a1 + 8) == 0x6B636F6C623C6574;
    if (v20 && *(void *)(a1 + 14) == 0x3E716572662D6B63) {
      return 1;
    }
  }
  if (v17)
  {
    BOOL v22 = *(void *)a1 == 0x3C65726975716572 && *(void *)(a1 + 8) == 0x702D68636E617262;
    if (v22 && *(_DWORD *)(a1 + 16) == 1046638450) {
      return 1;
    }
  }
  if (v16)
  {
    BOOL v24 = *(void *)a1 == 0x6164696C61766E69 && *(void *)(a1 + 8) == 0x636E6172623C6574;
    if (v24 && *(void *)(a1 + 15) == 0x3E626F72702D6863) {
      return 1;
    }
  }
  if (a2 == 15)
  {
    if (*(void *)a1 == 0x3C65726975716572 && *(void *)(a1 + 7) == 0x3E73656C6379633CLL) {
      return 1;
    }
    goto LABEL_93;
  }
  if (a2 == 16)
  {
    BOOL v55 = *(void *)a1 == 0x3C65726975716572 && *(void *)(a1 + 8) == 0x3E656572746D6F64;
    int v31 = 1;
    if (v55) {
      return 1;
    }
    goto LABEL_94;
  }
  if (a2 != 18)
  {
LABEL_93:
    int v31 = 0;
LABEL_94:
    int v30 = 0;
    goto LABEL_95;
  }
  BOOL v29 = *(void *)a1 == 0x6164696C61766E69
     && *(void *)(a1 + 8) == 0x656C6379633C6574
     && *(_WORD *)(a1 + 16) == 15987;
  int v30 = 1;
  if (v29) {
    return 1;
  }
  int v31 = 0;
LABEL_95:
  if (v10)
  {
    BOOL v32 = *(void *)a1 == 0x6164696C61766E69 && *(void *)(a1 + 8) == 0x72746D6F643C6574;
    if (v32 && *(void *)(a1 + 11) == 0x3E656572746D6F64) {
      return 1;
    }
  }
  if (v17)
  {
    BOOL v34 = *(void *)a1 == 0x3C65726975716572 && *(void *)(a1 + 8) == 0x746D6F6474736F70;
    if (v34 && *(_DWORD *)(a1 + 16) == 1046832498) {
      return 1;
    }
  }
  if (v16)
  {
    BOOL v36 = *(void *)a1 == 0x6164696C61766E69 && *(void *)(a1 + 8) == 0x6474736F703C6574;
    if (v36 && *(void *)(a1 + 15) == 0x3E656572746D6F64) {
      return 1;
    }
  }
  if (a2 == 22)
  {
    if (*(void *)a1 == 0x3C65726975716572
      && *(void *)(a1 + 8) == 0x6465646E616D6564
      && *(void *)(a1 + 14) == 0x3E737469622D6465)
    {
      return 1;
    }
    int v354 = v31;
    int v355 = v30;
    int v40 = v15;
    goto LABEL_159;
  }
  int v354 = v31;
  int v355 = v30;
  int v40 = v15;
  if (a2 != 25)
  {
LABEL_159:
    int v353 = 0;
    goto LABEL_160;
  }
  BOOL v47 = *(void *)a1 == 0x6164696C61766E69
     && *(void *)(a1 + 8) == 0x6E616D65643C6574
     && *(void *)(a1 + 16) == 0x737469622D646564
     && *(unsigned char *)(a1 + 24) == 62;
  int v353 = 1;
  uint64_t result = 1;
  if (v47) {
    return result;
  }
LABEL_160:
  if (v17)
  {
    BOOL v49 = *(void *)a1 == 0x3C65726975716572 && *(void *)(a1 + 8) == 0x746E6F72666D6F64;
    if (v49 && *(_DWORD *)(a1 + 16) == 1047684457) {
      return 1;
    }
  }
  if (v16)
  {
    BOOL v51 = *(void *)a1 == 0x6164696C61766E69 && *(void *)(a1 + 8) == 0x72666D6F643C6574;
    if (v51 && *(void *)(a1 + 15) == 0x3E726569746E6F72) {
      return 1;
    }
  }
  if (a2 == 24)
  {
    if (*(void *)a1 == 0x3C65726975716572
      && *(void *)(a1 + 8) == 0x6F72702D636E7566
      && *(void *)(a1 + 16) == 0x3E73656974726570)
    {
      return 1;
    }
    goto LABEL_205;
  }
  if (a2 != 27)
  {
LABEL_205:
    int v352 = 0;
    goto LABEL_206;
  }
  BOOL v58 = *(void *)a1 == 0x6164696C61766E69
     && *(void *)(a1 + 8) == 0x2D636E75663C6574
     && *(void *)(a1 + 16) == 0x69747265706F7270
     && *(void *)(a1 + 19) == 0x3E73656974726570;
  int v352 = 1;
  uint64_t result = 1;
  if (v58) {
    return result;
  }
LABEL_206:
  if (v40)
  {
    if (*(void *)a1 == 0x3C65726975716572 && *(void *)(a1 + 6) == 0x3E73706F6F6C3C65) {
      return 1;
    }
  }
  if (a2 == 17)
  {
    if (*(void *)a1 == 0x6164696C61766E69
      && *(void *)(a1 + 8) == 0x73706F6F6C3C6574
      && *(unsigned char *)(a1 + 16) == 62)
    {
      return 1;
    }
  }
  else if (a2 == 24)
  {
    BOOL v62 = *(void *)a1 == 0x3C65726975716572 && *(void *)(a1 + 8) == 0x6C61762D797A616CLL;
    if (v62 && *(void *)(a1 + 16) == 0x3E6F666E692D6575) {
      return 1;
    }
  }
  if (v352)
  {
    BOOL v64 = *(void *)a1 == 0x6164696C61766E69 && *(void *)(a1 + 8) == 0x2D797A616C3C6574;
    BOOL v65 = v64 && *(void *)(a1 + 16) == 0x6E692D65756C6176;
    if (v65 && *(void *)(a1 + 19) == 0x3E6F666E692D6575) {
      return 1;
    }
  }
  if (a2 == 11 && *(void *)a1 == 0x3C65726975716572 && *(void *)(a1 + 3) == 0x3E61643C65726975) {
    return 1;
  }
  if (v40)
  {
    if (*(void *)a1 == 0x6164696C61766E69 && *(void *)(a1 + 6) == 0x3E61643C65746164) {
      return 1;
    }
  }
  if (a2 == 34)
  {
    int v349 = v40;
    int v72 = memcmp((const void *)a1, "invalidate<inliner-size-estimator>", 0x22uLL);
    int v40 = v349;
    if (!v72) {
      return 1;
    }
  }
  else if (a2 == 31)
  {
    if (*(void *)a1 == 0x3C65726975716572
      && *(void *)(a1 + 8) == 0x2D72656E696C6E69
      && *(void *)(a1 + 16) == 0x7473652D657A6973
      && *(void *)(a1 + 23) == 0x3E726F74616D6974)
    {
      return 1;
    }
  }
  else if (a2 == 15 && *(void *)a1 == 0x3C65726975716572 && *(void *)(a1 + 7) == 0x3E7065646D656D3CLL)
  {
    return 1;
  }
  if (v355)
  {
    BOOL v74 = *(void *)a1 == 0x6164696C61766E69 && *(void *)(a1 + 8) == 0x65646D656D3C6574;
    if (v74 && *(_WORD *)(a1 + 16) == 15984) {
      return 1;
    }
    BOOL v76 = *(void *)a1 == 0x3C65726975716572 && *(void *)(a1 + 8) == 0x737379726F6D656DLL;
    if (v76 && *(_WORD *)(a1 + 16) == 15969) {
      return 1;
    }
  }
  if (a2 == 21)
  {
    BOOL v78 = *(void *)a1 == 0x6164696C61766E69 && *(void *)(a1 + 8) == 0x726F6D656D3C6574;
    if (v78 && *(void *)(a1 + 13) == 0x3E61737379726F6DLL) {
      return 1;
    }
  }
  if (v10)
  {
    BOOL v80 = *(void *)a1 == 0x3C65726975716572 && *(void *)(a1 + 8) == 0x756C61762D696870;
    if (v80 && *(void *)(a1 + 11) == 0x3E7365756C61762DLL) {
      return 1;
    }
  }
  if (a2 == 22)
  {
    BOOL v82 = *(void *)a1 == 0x6164696C61766E69 && *(void *)(a1 + 8) == 0x762D6968703C6574;
    if (v82 && *(void *)(a1 + 14) == 0x3E7365756C61762DLL) {
      return 1;
    }
  }
  if (v354)
  {
    if (*(void *)a1 == 0x3C65726975716572 && *(void *)(a1 + 8) == 0x3E736E6F69676572) {
      return 1;
    }
  }
  if (v10)
  {
    BOOL v85 = *(void *)a1 == 0x6164696C61766E69 && *(void *)(a1 + 8) == 0x6F696765723C6574;
    if (v85 && *(void *)(a1 + 11) == 0x3E736E6F69676572) {
      return 1;
    }
  }
  if (v16)
  {
    BOOL v87 = *(void *)a1 == 0x3C65726975716572 && *(void *)(a1 + 8) == 0x75662D706F2D6F6ELL;
    if (v87 && *(void *)(a1 + 15) == 0x3E6E6F6974636E75) {
      return 1;
    }
  }
  if (a2 == 26)
  {
    if (*(void *)a1 == 0x6164696C61766E69
      && *(void *)(a1 + 8) == 0x706F2D6F6E3C6574
      && *(void *)(a1 + 16) == 0x6F6974636E75662DLL
      && *(_WORD *)(a1 + 24) == 15982)
    {
      return 1;
    }
  }
  else if (a2 == 24)
  {
    BOOL v92 = *(void *)a1 == 0x3C65726975716572 && *(void *)(a1 + 8) == 0x616D65722D74706FLL;
    if (v92 && *(void *)(a1 + 16) == 0x3E74696D652D6B72) {
      return 1;
    }
  }
  if (v352)
  {
    BOOL v94 = *(void *)a1 == 0x6164696C61766E69 && *(void *)(a1 + 8) == 0x722D74706F3C6574;
    BOOL v95 = v94 && *(void *)(a1 + 16) == 0x6D652D6B72616D65;
    if (v95 && *(void *)(a1 + 19) == 0x3E74696D652D6B72) {
      return 1;
    }
  }
  if (v353)
  {
    BOOL v97 = *(void *)a1 == 0x3C65726975716572 && *(void *)(a1 + 8) == 0x652D72616C616373;
    BOOL v98 = v97 && *(void *)(a1 + 16) == 0x6E6F6974756C6F76;
    if (v98 && *(unsigned char *)(a1 + 24) == 62) {
      return 1;
    }
  }
  if (a2 == 28)
  {
    if (*(void *)a1 == 0x6164696C61766E69
      && *(void *)(a1 + 8) == 0x616C6163733C6574
      && *(void *)(a1 + 16) == 0x74756C6F76652D72
      && *(_DWORD *)(a1 + 24) == 1047424873)
    {
      return 1;
    }
  }
  else
  {
    if (a2 == 42)
    {
      int v350 = v40;
      if (!memcmp((const void *)a1, "invalidate<should-not-run-function-passes>", 0x2AuLL)) {
        return 1;
      }
      unint64_t v103 = "invalidate<should-run-extra-vector-passes>";
      int v104 = (const void *)a1;
      size_t v105 = 42;
    }
    else
    {
      if (a2 != 39) {
        goto LABEL_394;
      }
      int v350 = v40;
      if (!memcmp((const void *)a1, "require<should-not-run-function-passes>", 0x27uLL)) {
        return 1;
      }
      unint64_t v103 = "require<should-run-extra-vector-passes>";
      int v104 = (const void *)a1;
      size_t v105 = 39;
    }
    int v106 = memcmp(v104, v103, v105);
    int v40 = v350;
    if (!v106) {
      return 1;
    }
  }
LABEL_394:
  if (v352)
  {
    BOOL v107 = *(void *)a1 == 0x3C65726975716572 && *(void *)(a1 + 8) == 0x61732D6B63617473;
    BOOL v108 = v107 && *(void *)(a1 + 16) == 0x636F6C2D79746566;
    if (v108 && *(void *)(a1 + 19) == 0x3E6C61636F6C2D79) {
      return 1;
    }
  }
  if (a2 == 30)
  {
    if (*(void *)a1 == 0x6164696C61766E69
      && *(void *)(a1 + 8) == 0x6B636174733C6574
      && *(void *)(a1 + 16) == 0x2D7974656661732DLL
      && *(void *)(a1 + 22) == 0x3E6C61636F6C2D79)
    {
      return 1;
    }
  }
  else if (a2 == 22)
  {
    BOOL v113 = *(void *)a1 == 0x3C65726975716572 && *(void *)(a1 + 8) == 0x696C746567726174;
    if (v113 && *(void *)(a1 + 14) == 0x3E6F666E6962696CLL) {
      return 1;
    }
  }
  int v351 = v40;
  if (v353)
  {
    BOOL v115 = *(void *)a1 == 0x6164696C61766E69 && *(void *)(a1 + 8) == 0x65677261743C6574;
    BOOL v116 = v115 && *(void *)(a1 + 16) == 0x6F666E6962696C74;
    if (v116 && *(unsigned char *)(a1 + 24) == 62) {
      return 1;
    }
  }
  if (a2 == 17)
  {
    BOOL v118 = *(void *)a1 == 0x3C65726975716572 && *(void *)(a1 + 8) == 0x7269746567726174;
    if (v118 && *(unsigned char *)(a1 + 16) == 62) {
      return 1;
    }
  }
  if (v17)
  {
    BOOL v120 = *(void *)a1 == 0x6164696C61766E69 && *(void *)(a1 + 8) == 0x65677261743C6574;
    if (v120 && *(_DWORD *)(a1 + 16) == 1047685492) {
      return 1;
    }
  }
  if (a2 == 15 && *(void *)a1 == 0x3C65726975716572 && *(void *)(a1 + 7) == 0x3E7966697265763CLL) {
    return 1;
  }
  if (v355)
  {
    BOOL v123 = *(void *)a1 == 0x6164696C61766E69 && *(void *)(a1 + 8) == 0x66697265763C6574;
    if (v123 && *(_WORD *)(a1 + 16) == 15993) {
      return 1;
    }
  }
  if (a2 == 29)
  {
    uint64_t v125 = *(void *)(a1 + 16);
    uint64_t v126 = *(void *)(a1 + 21);
    BOOL v127 = *(void *)a1 == 0x3C65726975716572 && *(void *)(a1 + 8) == 0x736E692D73736170;
    uint64_t v128 = 0x61746E656D757274;
  }
  else
  {
    if (a2 != 32) {
      goto LABEL_483;
    }
    uint64_t v125 = *(void *)(a1 + 16);
    uint64_t v126 = *(void *)(a1 + 24);
    BOOL v127 = *(void *)a1 == 0x6164696C61766E69 && *(void *)(a1 + 8) == 0x2D737361703C6574;
    uint64_t v128 = 0x656D757274736E69;
  }
  if (v127 && v125 == v128 && v126 == 0x3E6E6F697461746ELL) {
    return 1;
  }
LABEL_483:
  if (v10)
  {
    BOOL v131 = *(void *)a1 == 0x3C65726975716572 && *(void *)(a1 + 8) == 0x6E65677265766964;
    if (v131 && *(void *)(a1 + 11) == 0x3E65636E65677265) {
      return 1;
    }
  }
  switch(a2)
  {
    case 0x16uLL:
      if (*(void *)a1 == 0x6164696C61766E69
        && *(void *)(a1 + 8) == 0x72657669643C6574
        && *(void *)(a1 + 14) == 0x3E65636E65677265)
      {
        return 1;
      }
      break;
    case 0x1EuLL:
      if (*(void *)a1 == 0x3C65726975716572
        && *(void *)(a1 + 8) == 0x636E75662D757067
        && *(void *)(a1 + 16) == 0x616E612D6E6F6974
        && *(void *)(a1 + 22) == 0x3E736973796C616ELL)
      {
        return 1;
      }
      break;
    case 0x21uLL:
      if (!memcmp((const void *)a1, "invalidate<gpu-function-analysis>", 0x21uLL)) {
        return 1;
      }
      break;
    case 0x11uLL:
      BOOL v138 = *(void *)a1 == 0x3C65726975716572 && *(void *)(a1 + 8) == 0x61612D6369736162;
      if (v138 && *(unsigned char *)(a1 + 16) == 62) {
        return 1;
      }
      break;
  }
  if (v17)
  {
    BOOL v140 = *(void *)a1 == 0x6164696C61766E69 && *(void *)(a1 + 8) == 0x63697361623C6574;
    if (v140 && *(_DWORD *)(a1 + 16) == 1046569261) {
      return 1;
    }
  }
  if (a2 == 22)
  {
    BOOL v142 = *(void *)a1 == 0x3C65726975716572 && *(void *)(a1 + 8) == 0x65646E612D6C6663;
    if (v142 && *(void *)(a1 + 14) == 0x3E61612D73726564) {
      return 1;
    }
  }
  if (v353)
  {
    BOOL v144 = *(void *)a1 == 0x6164696C61766E69 && *(void *)(a1 + 8) == 0x612D6C66633C6574;
    BOOL v145 = v144 && *(void *)(a1 + 16) == 0x61612D737265646ELL;
    if (v145 && *(unsigned char *)(a1 + 24) == 62) {
      return 1;
    }
  }
  if (a2 == 22)
  {
    BOOL v147 = *(void *)a1 == 0x3C65726975716572 && *(void *)(a1 + 8) == 0x656574732D6C6663;
    if (v147 && *(void *)(a1 + 14) == 0x3E61612D736E6565) {
      return 1;
    }
  }
  if (v353)
  {
    BOOL v149 = *(void *)a1 == 0x6164696C61766E69 && *(void *)(a1 + 8) == 0x732D6C66633C6574;
    BOOL v150 = v149 && *(void *)(a1 + 16) == 0x61612D736E656574;
    if (v150 && *(unsigned char *)(a1 + 24) == 62) {
      return 1;
    }
  }
  if (v17)
  {
    BOOL v152 = *(void *)a1 == 0x3C65726975716572 && *(void *)(a1 + 8) == 0x6372612D636A626FLL;
    if (v152 && *(_DWORD *)(a1 + 16) == 1046569261) {
      return 1;
    }
  }
  if (v16)
  {
    BOOL v154 = *(void *)a1 == 0x6164696C61766E69 && *(void *)(a1 + 8) == 0x2D636A626F3C6574;
    if (v154 && *(void *)(a1 + 15) == 0x3E61612D6372612DLL) {
      return 1;
    }
  }
  if (v354)
  {
    if (*(void *)a1 == 0x3C65726975716572 && *(void *)(a1 + 8) == 0x3E61612D76656373) {
      return 1;
    }
  }
  if (v10)
  {
    BOOL v157 = *(void *)a1 == 0x6164696C61766E69 && *(void *)(a1 + 8) == 0x2D766563733C6574;
    if (v157 && *(void *)(a1 + 11) == 0x3E61612D76656373) {
      return 1;
    }
  }
  if (a2 == 26)
  {
    if (*(void *)a1 == 0x3C65726975716572
      && *(void *)(a1 + 8) == 0x6E2D6465706F6373
      && *(void *)(a1 + 16) == 0x612D7361696C616FLL
      && *(_WORD *)(a1 + 24) == 15969)
    {
      return 1;
    }
    goto LABEL_633;
  }
  if (a2 == 29)
  {
    if (*(void *)a1 == 0x6164696C61766E69
      && *(void *)(a1 + 8) == 0x65706F63733C6574
      && *(void *)(a1 + 16) == 0x61696C616F6E2D64
      && *(void *)(a1 + 21) == 0x3E61612D7361696CLL)
    {
      return 1;
    }
    goto LABEL_633;
  }
  if (a2 != 13)
  {
LABEL_633:
    int v166 = 0;
    goto LABEL_634;
  }
  BOOL v165 = *(void *)a1 == 0x3C65726975716572 && *(void *)(a1 + 5) == 0x3E616162743C6572;
  int v166 = 1;
  uint64_t result = 1;
  if (v165) {
    return result;
  }
LABEL_634:
  if (v354)
  {
    if (*(void *)a1 == 0x6164696C61766E69 && *(void *)(a1 + 8) == 0x3E616162743C6574) {
      return 1;
    }
  }
  if (a2 == 7 && *(_DWORD *)a1 == 1697472865 && *(_DWORD *)(a1 + 3) == 1818326629) {
    return 1;
  }
  if (v12 && *(_DWORD *)a1 == 1701012577) {
    return 1;
  }
  if (v355)
  {
    BOOL v169 = *(void *)a1 == 0x637369642D646461 && *(void *)(a1 + 8) == 0x6F74616E696D6972;
    if (v169 && *(_WORD *)(a1 + 16) == 29554) {
      return 1;
    }
  }
  if (a2 == 22)
  {
    BOOL v171 = *(void *)a1 == 0x6973736572676761 && *(void *)(a1 + 8) == 0x6374736E692D6576;
    if (v171 && *(void *)(a1 + 14) == 0x656E69626D6F6374) {
      return 1;
    }
  }
  if (v351)
  {
    if (*(void *)a1 == 0x622D656D75737361 && *(void *)(a1 + 6) == 0x7265646C6975622DLL) {
      return 1;
    }
  }
  if (a2 == 15)
  {
    if (*(void *)a1 == 0x732D656D75737361 && *(void *)(a1 + 7) == 0x7966696C706D6973) {
      return 1;
    }
  }
  else if (a2 == 26)
  {
    BOOL v175 = *(void *)a1 == 0x6E656D6E67696C61 && *(void *)(a1 + 8) == 0x612D6D6F72662D74;
    BOOL v176 = v175 && *(void *)(a1 + 16) == 0x6F6974706D757373;
    if (v176 && *(_WORD *)(a1 + 24) == 29550) {
      return 1;
    }
  }
  if (v355)
  {
    BOOL v178 = *(void *)a1 == 0x697461746F6E6E61 && *(void *)(a1 + 8) == 0x72616D65722D6E6FLL;
    if (v178 && *(_WORD *)(a1 + 16) == 29547) {
      return 1;
    }
  }
  if (v12 && *(_DWORD *)a1 == 1701012578) {
    return 1;
  }
  if (a2 == 15 && *(void *)a1 == 0x632D73646E756F62 && *(void *)(a1 + 7) == 0x676E696B63656863) {
    return 1;
  }
  if (v354)
  {
    if (*(void *)a1 == 0x72632D6B61657262 && *(void *)(a1 + 8) == 0x73656764652D7469) {
      return 1;
    }
  }
  if (v355)
  {
    BOOL v182 = *(void *)a1 == 0x657469736C6C6163 && *(void *)(a1 + 8) == 0x697474696C70732DLL;
    if (v182 && *(_WORD *)(a1 + 16) == 26478) {
      return 1;
    }
  }
  switch(a2)
  {
    case 0xAuLL:
      if (*(void *)a1 == 0x696F6874736E6F63 && *(_WORD *)(a1 + 8) == 29811) {
        return 1;
      }
      if (*(void *)a1 == 0x696C652D6F726F63 && *(_WORD *)(a1 + 8) == 25956) {
        return 1;
      }
      goto LABEL_752;
    case 0x16uLL:
      if (*(void *)a1 == 0x69617274736E6F63
        && *(void *)(a1 + 8) == 0x696D696C652D746ELL
        && *(void *)(a1 + 14) == 0x6E6F6974616E696DLL)
      {
        return 1;
      }
      BOOL v188 = *(void *)a1 == 0x74616C6572726F63 && *(void *)(a1 + 8) == 0x61706F72702D6465;
      if (v188 && *(void *)(a1 + 14) == 0x6E6F697461676170) {
        return 1;
      }
      goto LABEL_752;
    case 0xCuLL:
      BOOL v202 = *(void *)a1 == 0x656C632D6F726F63 && *(_DWORD *)(a1 + 8) == 1886744161;
      uint64_t result = 1;
      if (v202) {
        return result;
      }
      goto LABEL_753;
  }
  if (a2 != 3)
  {
LABEL_752:
    LODWORD(result) = 0;
LABEL_753:
    int v192 = 0;
    goto LABEL_754;
  }
  if (*(_WORD *)a1 == 26723 && *(unsigned char *)(a1 + 2) == 114) {
    return 1;
  }
  BOOL v191 = *(_WORD *)a1 == 25444 && *(unsigned char *)(a1 + 2) == 101;
  int v192 = 1;
  if (v191) {
    return 1;
  }
  LODWORD(result) = 0;
LABEL_754:
  if (v355)
  {
    BOOL v193 = *(void *)a1 == 0x706D756A2D616664 && *(void *)(a1 + 8) == 0x696461657268742DLL;
    if (v193 && *(_WORD *)(a1 + 16) == 26478) {
      return 1;
    }
  }
  if (v166)
  {
    if (*(void *)a1 == 0x2D6D65722D766964 && *(void *)(a1 + 5) == 0x73726961702D6D65) {
      return 1;
    }
  }
  if (v192)
  {
    if (*(_WORD *)a1 == 29540 && *(unsigned char *)(a1 + 2) == 101) {
      return 1;
    }
  }
  if (a2 == 7 && *(_DWORD *)a1 == 762605412 && *(_DWORD *)(a1 + 3) == 1734763309) {
    return 1;
  }
  if (result)
  {
    if (*(void *)a1 == 0x2D6766632D746F64 && *(_DWORD *)(a1 + 8) == 2037149295) {
      return 1;
    }
  }
  if (a2 == 7 && *(_DWORD *)a1 == 762605412 && *(_DWORD *)(a1 + 3) == 1836016685) {
    return 1;
  }
  if (result)
  {
    if (*(void *)a1 == 0x2D6D6F642D746F64 && *(_DWORD *)(a1 + 8) == 2037149295) {
      return 1;
    }
  }
  if (a2 == 15)
  {
    if (*(void *)a1 == 0x657272692D786966 && *(void *)(a1 + 7) == 0x656C626963756465) {
      return 1;
    }
  }
  else if (a2 == 10 && *(void *)a1 == 0x636E657474616C66 && *(_WORD *)(a1 + 8) == 26470)
  {
    return 1;
  }
  if (v17)
  {
    BOOL v204 = *(void *)a1 == 0x6175672D656B616DLL && *(void *)(a1 + 8) == 0x6C7078652D736472;
    if (v204 && *(_DWORD *)(a1 + 16) == 1953063785) {
      return 1;
    }
  }
  if (v11)
  {
    if (*(void *)a1 == 0x73696F682D6E7667 && *(unsigned char *)(a1 + 8) == 116) {
      return 1;
    }
  }
  if (a2 == 8)
  {
    if (*(void *)a1 == 0x6B6E69732D6E7667) {
      return 1;
    }
  }
  else if (a2 == 10 && *(void *)a1 == 0x726F776F6C6C6568 && *(_WORD *)(a1 + 8) == 25708)
  {
    return 1;
  }
  if (v17)
  {
    BOOL v208 = *(void *)a1 == 0x64612D7265666E69 && *(void *)(a1 + 8) == 0x70732D7373657264;
    if (v208 && *(_DWORD *)(a1 + 16) == 1936024417) {
      return 1;
    }
  }
  if (a2 == 11 && *(void *)a1 == 0x626D6F6374736E69 && *(void *)(a1 + 3) == 0x656E69626D6F6374) {
    return 1;
  }
  if (v11)
  {
    if (*(void *)a1 == 0x6E756F6374736E69 && *(unsigned char *)(a1 + 8) == 116) {
      return 1;
    }
  }
  if (result)
  {
    if (*(void *)a1 == 0x706D697374736E69 && *(_DWORD *)(a1 + 8) == 2036754796) {
      return 1;
    }
  }
  if (a2 == 15 && *(void *)a1 == 0x6164696C61766E69 && *(void *)(a1 + 7) == 0x3E6C6C613C657461) {
    return 1;
  }
  if (v12 && *(_DWORD *)a1 == 1701016169) {
    return 1;
  }
  if (v11)
  {
    if (*(void *)a1 == 0x6E693274616F6C66 && *(unsigned char *)(a1 + 8) == 116) {
      return 1;
    }
  }
  if (v351)
  {
    if (*(void *)a1 == 0x75662D706F2D6F6ELL && *(void *)(a1 + 6) == 0x6E6F6974636E7566) {
      return 1;
    }
  }
  if (v10)
  {
    BOOL v216 = *(void *)a1 == 0x736C6C616362696CLL && *(void *)(a1 + 8) == 0x776B6E697268732DLL;
    if (v216 && *(void *)(a1 + 11) == 0x706172776B6E6972) {
      return 1;
    }
  }
  if (v12 && *(_DWORD *)a1 == 1953393004) {
    return 1;
  }
  if (v10)
  {
    BOOL v218 = *(void *)a1 == 0x742D7463656A6E69 && *(void *)(a1 + 8) == 0x697070616D2D696CLL;
    if (v218 && *(void *)(a1 + 11) == 0x73676E697070616DLL) {
      return 1;
    }
  }
  if (v11)
  {
    if (*(void *)a1 == 0x656D616E74736E69 && *(unsigned char *)(a1 + 8) == 114) {
      return 1;
    }
  }
  if (a2 == 11 && *(void *)a1 == 0x6F74617265776F6CLL && *(void *)(a1 + 3) == 0x63696D6F74617265) {
    return 1;
  }
  if (result)
  {
    if (*(void *)a1 == 0x78652D7265776F6CLL && *(_DWORD *)(a1 + 8) == 1952671088) {
      return 1;
    }
  }
  if (a2 == 21)
  {
    BOOL v223 = *(void *)a1 == 0x75672D7265776F6CLL && *(void *)(a1 + 8) == 0x72746E692D647261;
    if (v223 && *(void *)(a1 + 13) == 0x6369736E6972746ELL) {
      return 1;
    }
  }
  if (v353)
  {
    BOOL v225 = *(void *)a1 == 0x6F632D7265776F6CLL && *(void *)(a1 + 8) == 0x692D746E6174736ELL;
    BOOL v226 = v225 && *(void *)(a1 + 16) == 0x6369736E6972746ELL;
    if (v226 && *(unsigned char *)(a1 + 24) == 115) {
      return 1;
    }
    BOOL v228 = *(void *)a1 == 0x69772D7265776F6CLL && *(void *)(a1 + 8) == 0x2D656C62616E6564;
    BOOL v229 = v228 && *(void *)(a1 + 16) == 0x6F697469646E6F63;
    if (v229 && *(unsigned char *)(a1 + 24) == 110) {
      return 1;
    }
  }
  if (v351)
  {
    if (*(void *)a1 == 0x69772D6472617567 && *(void *)(a1 + 6) == 0x676E696E65646977) {
      return 1;
    }
  }
  if (a2 == 21)
  {
    BOOL v232 = *(void *)a1 == 0x6F74732D64616F6CLL && *(void *)(a1 + 8) == 0x6F746365762D6572;
    if (v232 && *(void *)(a1 + 13) == 0x72657A69726F7463) {
      return 1;
    }
  }
  if (v166)
  {
    if (*(void *)a1 == 0x6D69732D706F6F6CLL && *(void *)(a1 + 5) == 0x7966696C706D6973) {
      return 1;
    }
  }
  if (v11)
  {
    if (*(void *)a1 == 0x6E69732D706F6F6CLL && *(unsigned char *)(a1 + 8) == 107) {
      return 1;
    }
  }
  if (a2 == 11)
  {
    if (*(void *)a1 == 0x766E697265776F6CLL && *(void *)(a1 + 3) == 0x656B6F766E697265) {
      return 1;
    }
    if (*(void *)a1 == 0x6977737265776F6CLL && *(void *)(a1 + 3) == 0x6863746977737265) {
      return 1;
    }
  }
  else if (a2 == 7 && *(_DWORD *)a1 == 846030189 && *(_DWORD *)(a1 + 3) == 1734701618)
  {
    return 1;
  }
  if (v11)
  {
    if (*(void *)a1 == 0x706F7970636D656DLL && *(unsigned char *)(a1 + 8) == 116) {
      return 1;
    }
  }
  if (a2 == 10)
  {
    if (*(void *)a1 == 0x6D6369656772656DLL && *(_WORD *)(a1 + 8) == 29552) {
      return 1;
    }
  }
  else if (a2 == 11 && *(void *)a1 == 0x746572656772656DLL && *(void *)(a1 + 3) == 0x6E72757465726567)
  {
    return 1;
  }
  if (v354)
  {
    if (*(void *)a1 == 0x6165722D7972616ELL && *(void *)(a1 + 8) == 0x65746169636F7373) {
      return 1;
    }
  }
  if (a2 == 6 && *(_DWORD *)a1 == 1735877998 && *(_WORD *)(a1 + 4) == 28278) {
    return 1;
  }
  if (v351)
  {
    if (*(void *)a1 == 0x7268742D706D756ALL && *(void *)(a1 + 6) == 0x676E696461657268) {
      return 1;
    }
  }
  if (v353)
  {
    BOOL v245 = *(void *)a1 == 0x6C6C616974726170 && *(void *)(a1 + 8) == 0x656E696C6E692D79;
    BOOL v246 = v245 && *(void *)(a1 + 16) == 0x6C6C616362696C2DLL;
    if (v246 && *(unsigned char *)(a1 + 24) == 115) {
      return 1;
    }
  }
  if (a2 == 5 && *(_DWORD *)a1 == 1936941932 && *(unsigned char *)(a1 + 4) == 97) {
    return 1;
  }
  if (v355)
  {
    BOOL v249 = *(void *)a1 == 0x7461642D706F6F6CLL && *(void *)(a1 + 8) == 0x7465666572702D61;
    if (v249 && *(_WORD *)(a1 + 16) == 26723) {
      return 1;
    }
  }
  if (v351)
  {
    if (*(void *)a1 == 0x616F6C2D706F6F6CLL && *(void *)(a1 + 6) == 0x6D696C652D64616FLL) {
      return 1;
    }
  }
  switch(a2)
  {
    case 0xBuLL:
      uint64_t v252 = *(void *)(a1 + 3);
      BOOL v253 = *(void *)a1 == 0x7375662D706F6F6CLL;
      uint64_t v254 = 0x6E6F697375662D70;
      goto LABEL_1035;
    case 0xFuLL:
      if (*(void *)a1 == 0x7369642D706F6F6CLL && *(void *)(a1 + 7) == 0x6574756269727473) {
        return 1;
      }
      if (*(void *)a1 == 0x7265762D706F6F6CLL && *(void *)(a1 + 7) == 0x676E696E6F697372) {
        return 1;
      }
      uint64_t v252 = *(void *)(a1 + 7);
      BOOL v253 = *(void *)a1 == 0x6372612D636A626FLL;
      uint64_t v254 = 0x646E617078652D63;
LABEL_1035:
      if (v253 && v252 == v254) {
        return 1;
      }
      break;
    case 8uLL:
      if (*(void *)a1 == 0x6372612D636A626FLL) {
        return 1;
      }
      break;
    case 0x11uLL:
      BOOL v288 = *(void *)a1 == 0x6372612D636A626FLL && *(void *)(a1 + 8) == 0x636172746E6F632DLL;
      if (v288 && *(unsigned char *)(a1 + 16) == 116) {
        return 1;
      }
      break;
  }
  if (v166)
  {
    if (*(void *)a1 == 0x6F6D656D2D6F6770 && *(void *)(a1 + 5) == 0x74706F2D706F6D65) {
      return 1;
    }
  }
  if (a2 == 5 && *(_DWORD *)a1 == 1852404336 && *(unsigned char *)(a1 + 4) == 116) {
    return 1;
  }
  if (v355)
  {
    BOOL v258 = *(void *)a1 == 0x73613C746E697270 && *(void *)(a1 + 8) == 0x6E6F6974706D7573;
    if (v258 && *(_WORD *)(a1 + 16) == 15987) {
      return 1;
    }
  }
  if (a2 == 17)
  {
    BOOL v260 = *(void *)a1 == 0x6C623C746E697270 && *(void *)(a1 + 8) == 0x716572662D6B636FLL;
    if (v260 && *(unsigned char *)(a1 + 16) == 62) {
      return 1;
    }
  }
  if (v355)
  {
    BOOL v262 = *(void *)a1 == 0x72623C746E697270 && *(void *)(a1 + 8) == 0x6F72702D68636E61;
    if (v262 && *(_WORD *)(a1 + 16) == 15970) {
      return 1;
    }
  }
  if (a2 == 17)
  {
    BOOL v264 = *(void *)a1 == 0x6F633C746E697270 && *(void *)(a1 + 8) == 0x6C65646F6D2D7473;
    if (v264 && *(unsigned char *)(a1 + 16) == 62) {
      return 1;
    }
  }
  if (v166)
  {
    if (*(void *)a1 == 0x79633C746E697270 && *(void *)(a1 + 5) == 0x3E73656C6379633CLL) {
      return 1;
    }
  }
  if (v11)
  {
    if (*(void *)a1 == 0x61643C746E697270 && *(unsigned char *)(a1 + 8) == 62) {
      return 1;
    }
  }
  if (a2 == 17)
  {
    BOOL v268 = *(void *)a1 == 0x69643C746E697270 && *(void *)(a1 + 8) == 0x65636E6567726576;
    if (v268 && *(unsigned char *)(a1 + 16) == 62) {
      return 1;
    }
  }
  if (v351)
  {
    if (*(void *)a1 == 0x6F643C746E697270 && *(void *)(a1 + 6) == 0x3E656572746D6F64) {
      return 1;
    }
  }
  if (v355)
  {
    BOOL v271 = *(void *)a1 == 0x6F703C746E697270 && *(void *)(a1 + 8) == 0x6572746D6F647473;
    if (v271 && *(_WORD *)(a1 + 16) == 15973) {
      return 1;
    }
  }
  if (a2 == 22)
  {
    BOOL v273 = *(void *)a1 == 0x65643C746E697270 && *(void *)(a1 + 8) == 0x7A697261656E696CLL;
    if (v273 && *(void *)(a1 + 14) == 0x3E6E6F6974617A69) {
      return 1;
    }
  }
  if (v17)
  {
    BOOL v275 = *(void *)a1 == 0x65643C746E697270 && *(void *)(a1 + 8) == 0x622D6465646E616DLL;
    if (v275 && *(_DWORD *)(a1 + 16) == 1047753833) {
      return 1;
    }
  }
  if (v355)
  {
    BOOL v277 = *(void *)a1 == 0x6F643C746E697270 && *(void *)(a1 + 8) == 0x6569746E6F72666DLL;
    if (v277 && *(_WORD *)(a1 + 16) == 15986) {
      return 1;
    }
  }
  if (a2 == 22)
  {
    BOOL v279 = *(void *)a1 == 0x75663C746E697270 && *(void *)(a1 + 8) == 0x65706F72702D636ELL;
    if (v279 && *(void *)(a1 + 14) == 0x3E73656974726570) {
      return 1;
    }
  }
  if (v355)
  {
    BOOL v281 = *(void *)a1 == 0x6E693C746E697270 && *(void *)(a1 + 8) == 0x736F632D656E696CLL;
    if (v281 && *(_WORD *)(a1 + 16) == 15988) {
      return 1;
    }
  }
  if (a2 == 29)
  {
    if (*(void *)a1 == 0x6E693C746E697270
      && *(void *)(a1 + 8) == 0x69732D72656E696CLL
      && *(void *)(a1 + 16) == 0x6D697473652D657ALL
      && *(void *)(a1 + 21) == 0x3E726F74616D6974)
    {
      return 1;
    }
  }
  else if (a2 == 28)
  {
    BOOL v290 = *(void *)a1 == 0x70673C746E697270 && *(void *)(a1 + 8) == 0x6974636E75662D75;
    BOOL v291 = v290 && *(void *)(a1 + 16) == 0x796C616E612D6E6FLL;
    if (v291 && *(_DWORD *)(a1 + 24) == 1047751027) {
      return 1;
    }
  }
  if (result)
  {
    if (*(void *)a1 == 0x6F6C3C746E697270 && *(_DWORD *)(a1 + 8) == 1047752815) {
      return 1;
    }
  }
  if (v354)
  {
    if (*(void *)a1 == 0x656D3C746E697270 && *(void *)(a1 + 8) == 0x3E61737379726F6DLL) {
      return 1;
    }
  }
  if (v16)
  {
    BOOL v295 = *(void *)a1 == 0x656D3C746E697270 && *(void *)(a1 + 8) == 0x2D61737379726F6DLL;
    if (v295 && *(void *)(a1 + 15) == 0x3E72656B6C61772DLL) {
      return 1;
    }
  }
  if (a2 == 17)
  {
    BOOL v297 = *(void *)a1 == 0x68703C746E697270 && *(void *)(a1 + 8) == 0x7365756C61762D69;
    if (v297 && *(unsigned char *)(a1 + 16) == 62) {
      return 1;
    }
  }
  if (v351)
  {
    if (*(void *)a1 == 0x65723C746E697270 && *(void *)(a1 + 6) == 0x3E736E6F69676572) {
      return 1;
    }
  }
  if (v16)
  {
    BOOL v300 = *(void *)a1 == 0x63733C746E697270 && *(void *)(a1 + 8) == 0x6F76652D72616C61;
    if (v300 && *(void *)(a1 + 15) == 0x3E6E6F6974756C6FLL) {
      return 1;
    }
  }
  if (v353)
  {
    BOOL v302 = *(void *)a1 == 0x74733C746E697270 && *(void *)(a1 + 8) == 0x656661732D6B6361;
    BOOL v303 = v302 && *(void *)(a1 + 16) == 0x6C61636F6C2D7974;
    if (v303 && *(unsigned char *)(a1 + 24) == 62) {
      return 1;
    }
  }
  if (v354)
  {
    if (*(void *)a1 == 0x6C612D746E697270 && *(void *)(a1 + 8) == 0x737465732D736169) {
      return 1;
    }
  }
  if (v10)
  {
    BOOL v306 = *(void *)a1 == 0x72702D746E697270 && *(void *)(a1 + 8) == 0x6965746163696465;
    if (v306 && *(void *)(a1 + 11) == 0x6F666E6965746163) {
      return 1;
    }
  }
  switch(a2)
  {
    case 0x11uLL:
      if (*(void *)a1 == 0x756D2D746E697270
        && *(void *)(a1 + 8) == 0x7475636578657473
        && *(unsigned char *)(a1 + 16) == 101)
      {
        return 1;
      }
      break;
    case 0xFuLL:
      uint64_t v310 = *(void *)(a1 + 7);
      BOOL v311 = *(void *)a1 == 0x656D2D746E697270;
      uint64_t v312 = 0x7366657265646D65;
      goto LABEL_1276;
    case 0xBuLL:
      uint64_t v310 = *(void *)(a1 + 3);
      BOOL v311 = *(void *)a1 == 0x69636F7373616572;
      uint64_t v312 = 0x65746169636F7373;
LABEL_1276:
      if (v311 && v310 == v312) {
        return 1;
      }
      break;
  }
  if (v16)
  {
    BOOL v314 = *(void *)a1 == 0x6E61646E75646572 && *(void *)(a1 + 8) == 0x6E692D6762642D74;
    if (v314 && *(void *)(a1 + 15) == 0x6D696C652D74736ELL) {
      return 1;
    }
  }
  if (a2 == 7 && *(_DWORD *)a1 == 845636978 && *(_DWORD *)(a1 + 3) == 1835363634) {
    return 1;
  }
  if (v352)
  {
    BOOL v317 = *(void *)a1 == 0x7A6972616C616373 && *(void *)(a1 + 8) == 0x64656B73616D2D65;
    BOOL v318 = v317 && *(void *)(a1 + 16) == 0x746E692D6D656D2DLL;
    if (v318 && *(void *)(a1 + 19) == 0x6E6972746E692D6DLL) {
      return 1;
    }
  }
  if (a2 == 10)
  {
    if (*(void *)a1 == 0x7A6972616C616373 && *(_WORD *)(a1 + 8) == 29285) {
      return 1;
    }
  }
  else if (a2 == 30)
  {
    BOOL v321 = *(void *)a1 == 0x6574617261706573 && *(void *)(a1 + 8) == 0x6F2D74736E6F632DLL;
    BOOL v322 = v321 && *(void *)(a1 + 16) == 0x72662D7465736666;
    if (v322 && *(void *)(a1 + 22) == 0x7065672D6D6F7266) {
      return 1;
    }
  }
  if (v12 && (*(_DWORD *)a1 == 1885561715 || *(_DWORD *)a1 == 1802398067)) {
    return 1;
  }
  if (v351)
  {
    if (*(void *)a1 == 0x746365762D706C73 && *(void *)(a1 + 6) == 0x72657A69726F7463) {
      return 1;
    }
  }
  if (v12 && *(_DWORD *)a1 == 1920167027) {
    return 1;
  }
  if (a2 == 21)
  {
    BOOL v325 = *(void *)a1 == 0x74616C7563657073 && *(void *)(a1 + 8) == 0x636578652D657669;
    if (v325 && *(void *)(a1 + 13) == 0x6E6F697475636578) {
      return 1;
    }
  }
  if (v12 && *(_DWORD *)a1 == 1634693747) {
    return 1;
  }
  if (v355)
  {
    BOOL v327 = *(void *)a1 == 0x63672D7069727473 && *(void *)(a1 + 8) == 0x7461636F6C65722DLL;
    if (v327 && *(_WORD *)(a1 + 16) == 29541) {
      return 1;
    }
  }
  if (v351)
  {
    if (*(void *)a1 == 0x7275746375727473 && *(void *)(a1 + 6) == 0x676663657A697275) {
      return 1;
    }
  }
  if (result)
  {
    if (*(void *)a1 == 0x6C6C61636C696174 && *(_DWORD *)(a1 + 8) == 1835625573) {
      return 1;
    }
  }
  if (v354)
  {
    if (*(void *)a1 == 0x6F6C2D7966696E75 && *(void *)(a1 + 8) == 0x73746978652D706FLL) {
      return 1;
    }
  }
  if (v351)
  {
    if (*(void *)a1 == 0x632D726F74636576 && *(void *)(a1 + 6) == 0x656E69626D6F632DLL) {
      return 1;
    }
  }
  if (a2 == 6)
  {
    if (*(_DWORD *)a1 == 1769104758 && *(_WORD *)(a1 + 4) == 31078) {
      return 1;
    }
  }
  else if (a2 == 15 && *(void *)a1 == 0x643C796669726576 && *(void *)(a1 + 7) == 0x3E656572746D6F64)
  {
    return 1;
  }
  if (v166)
  {
    if (*(void *)a1 == 0x6C3C796669726576 && *(void *)(a1 + 5) == 0x3E73706F6F6C3C79) {
      return 1;
    }
  }
  if (a2 == 17)
  {
    if (*(void *)a1 == 0x6D3C796669726576
      && *(void *)(a1 + 8) == 0x61737379726F6D65
      && *(unsigned char *)(a1 + 16) == 62)
    {
      return 1;
    }
  }
  else if (a2 == 15 && *(void *)a1 == 0x723C796669726576 && *(void *)(a1 + 7) == 0x3E736E6F69676572)
  {
    return 1;
  }
  if (v17)
  {
    BOOL v339 = *(void *)a1 == 0x733C796669726576 && *(void *)(a1 + 8) == 0x746E696F70656661;
    if (v339 && *(_DWORD *)(a1 + 16) == 1047685421) {
      return 1;
    }
  }
  if (a2 == 24)
  {
    if (*(void *)a1 == 0x733C796669726576
      && *(void *)(a1 + 8) == 0x76652D72616C6163
      && *(void *)(a1 + 16) == 0x3E6E6F6974756C6FLL)
    {
      return 1;
    }
  }
  else if (a2 == 8 && *(void *)a1 == 0x6766632D77656976)
  {
    return 1;
  }
  if (v166)
  {
    if (*(void *)a1 == 0x6766632D77656976 && *(void *)(a1 + 5) == 0x796C6E6F2D676663) {
      return 1;
    }
  }
  if (a2 == 8)
  {
    if (*(void *)a1 == 0x7473696F68736C74) {
      return 1;
    }
  }
  else if (a2 == 17)
  {
    BOOL v344 = *(void *)a1 == 0x726F66736E617274 && *(void *)(a1 + 8) == 0x6E696E7261772D6DLL;
    if (v344 && *(unsigned char *)(a1 + 16) == 103) {
      return 1;
    }
  }
  if (v12 && *(_DWORD *)a1 == 1851880308) {
    return 1;
  }
  if (a2 == 7 && *(_DWORD *)a1 == 1886217581 && *(_DWORD *)(a1 + 3) == 1718579824) {
    return 1;
  }
  if (sub_1CCC9F0D4((char *)a1, a2, "early-cse", 9uLL)
    || sub_1CCC9F0D4((char *)a1, a2, "ee-instrument", 0xDuLL)
    || sub_1CCC9F0D4((char *)a1, a2, "lower-matrix-intrinsics", 0x17uLL)
    || sub_1CCC9F0D4((char *)a1, a2, "loop-unroll", 0xBuLL)
    || sub_1CCC9F0D4((char *)a1, a2, "msan", 4uLL)
    || sub_1CCC9F0D4((char *)a1, a2, "simplifycfg", 0xBuLL)
    || sub_1CCC9F0D4((char *)a1, a2, "loop-vectorize", 0xEuLL)
    || sub_1CCC9F0D4((char *)a1, a2, "mldst-motion", 0xCuLL)
    || sub_1CCC9F0D4((char *)a1, a2, "gvn", 3uLL)
    || sub_1CCC9F0D4((char *)a1, a2, "print<stack-lifetime>", 0x15uLL))
  {
    return 1;
  }
  if (v4)
  {
    memset(v356, 0, sizeof(v356));
    BOOL v347 = (uint64_t *)(a3 + 24);
    uint64_t v348 = 32 * v4;
    while (!sub_1CCCAD3CC(*v347, a1, a2, (uint64_t)v356, 0, 0))
    {
      v347 += 4;
      v348 -= 32;
      if (!v348)
      {
        long long v357 = (void **)v356;
        sub_1CCCB67B8(&v357);
        return 0;
      }
    }
    long long v357 = (void **)v356;
    sub_1CCCB67B8(&v357);
    return 1;
  }
  return 0;
}

uint64_t sub_1CCCB2974(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t *a4)
{
  *(unsigned char *)a4 = 0;
  if ((unint64_t)sub_1CCC9ECD8((_DWORD *)a1, a2, a3, a4) >> 32) {
    return 1;
  }
  switch(a2)
  {
    case 4uLL:
      if (*(_DWORD *)a1 != 1835231596) {
        goto LABEL_156;
      }
      *(unsigned char *)a4 = 1;
      return 1;
    case 5uLL:
      int v8 = *(unsigned __int8 *)(a1 + 4);
      BOOL v9 = *(_DWORD *)a1 == 1852404336;
      int v10 = 116;
      goto LABEL_34;
    case 7uLL:
      if (*(_DWORD *)a1 == 762605412 && *(_DWORD *)(a1 + 3) == 1734632493) {
        return 1;
      }
      int v8 = *(_DWORD *)(a1 + 3);
      BOOL v9 = *(_DWORD *)a1 == 1986293353;
      int v10 = 1936875894;
      goto LABEL_34;
    case 0xAuLL:
      if (*(void *)a1 == 0x6964692D706F6F6CLL && *(_WORD *)(a1 + 8) == 28015) {
        return 1;
      }
      if (*(void *)a1 == 0x6F6C2D706F2D6F6ELL && *(_WORD *)(a1 + 8) == 28783) {
        return 1;
      }
      int v8 = *(unsigned __int16 *)(a1 + 8);
      BOOL v9 = *(void *)a1 == 0x64643C746E697270;
      int v10 = 15975;
      goto LABEL_34;
    case 0xBuLL:
      if (*(void *)a1 == 0x746F722D706F6F6CLL && *(void *)(a1 + 3) == 0x657461746F722D70) {
        return 1;
      }
      if (*(void *)a1 == 0x6465722D706F6F6CLL && *(void *)(a1 + 3) == 0x6563756465722D70) {
        return 1;
      }
      uint64_t v16 = *(void *)(a1 + 3);
      BOOL v17 = *(void *)a1 == 0x7265722D706F6F6CLL;
      uint64_t v18 = 0x6C6C6F7265722D70;
      goto LABEL_68;
    case 0xCuLL:
      if (*(void *)a1 == 0x3C65726975716572 && *(_DWORD *)(a1 + 8) == 1046963300) {
        return 1;
      }
      int v8 = *(_DWORD *)(a1 + 8);
      BOOL v9 = *(void *)a1 == 0x72662D6E6F6E6163;
      int v10 = 1702520165;
LABEL_34:
      if (!v9 || v8 != v10) {
        goto LABEL_156;
      }
      return 1;
    case 0xDuLL:
      uint64_t v16 = *(void *)(a1 + 5);
      BOOL v17 = *(void *)a1 == 0x6C65642D706F6F6CLL;
      uint64_t v18 = 0x6E6F6974656C6564;
      goto LABEL_68;
    case 0xEuLL:
      uint64_t v16 = *(void *)(a1 + 6);
      BOOL v17 = *(void *)a1 == 0x69772D6472617567;
      uint64_t v18 = 0x676E696E65646977;
      goto LABEL_68;
    case 0xFuLL:
      if (*(void *)a1 == 0x6164696C61766E69 && *(void *)(a1 + 7) == 0x3E6764643C657461) {
        return 1;
      }
      if (*(void *)a1 == 0x6164696C61766E69 && *(void *)(a1 + 7) == 0x3E6C6C613C657461) {
        return 1;
      }
      if (*(void *)a1 == 0x76693C746E697270 && *(void *)(a1 + 7) == 0x3E73726573752D76) {
        return 1;
      }
      uint64_t v16 = *(void *)(a1 + 7);
      BOOL v17 = *(void *)a1 == 0x6F6C3C746E697270;
      uint64_t v18 = 0x3E7473656E706F6FLL;
      goto LABEL_68;
    case 0x10uLL:
      if (*(void *)a1 == 0x6D69732D706F6F6CLL && *(void *)(a1 + 8) == 0x6766637966696C70) {
        return 1;
      }
      if (*(void *)a1 == 0x726E752D706F6F6CLL && *(void *)(a1 + 8) == 0x6C6C75662D6C6C6FLL) {
        return 1;
      }
      if (*(void *)a1 == 0x6572702D706F6F6CLL && *(void *)(a1 + 8) == 0x6E6F697461636964) {
        return 1;
      }
      uint64_t v16 = *(void *)(a1 + 8);
      BOOL v17 = *(void *)a1 == 0x756F622D706F6F6CLL;
      uint64_t v18 = 0x74696C70732D646ELL;
LABEL_68:
      if (!v17 || v16 != v18) {
        goto LABEL_156;
      }
      return 1;
    case 0x11uLL:
      if (*(void *)a1 == 0x3C65726975716572
        && *(void *)(a1 + 8) == 0x73726573752D7669
        && *(unsigned char *)(a1 + 16) == 62)
      {
        return 1;
      }
      BOOL v30 = *(void *)a1 == 0x736E692D706F6F6CLL && *(void *)(a1 + 8) == 0x66696C706D697374;
      if (v30 && *(unsigned char *)(a1 + 16) == 121) {
        return 1;
      }
      int v32 = *(unsigned __int8 *)(a1 + 16);
      BOOL v33 = *(void *)a1 == 0x63612D746E697270 && *(void *)(a1 + 8) == 0x666E692D73736563;
      int v34 = 111;
      goto LABEL_114;
    case 0x13uLL:
      uint64_t v35 = *(void *)(a1 + 11);
      BOOL v36 = *(void *)a1 == 0x3C65726975716572 && *(void *)(a1 + 8) == 0x6F6C2D706F2D6F6ELL;
      uint64_t v37 = 0x3E706F6F6C2D706FLL;
      goto LABEL_135;
    case 0x14uLL:
      if (*(void *)a1 == 0x3C65726975716572
        && *(void *)(a1 + 8) == 0x692D737365636361
        && *(_DWORD *)(a1 + 16) == 1047488110)
      {
        return 1;
      }
      BOOL v40 = *(void *)a1 == 0x6164696C61766E69 && *(void *)(a1 + 8) == 0x73752D76693C6574;
      if (v40 && *(_DWORD *)(a1 + 16) == 1047753317) {
        return 1;
      }
      int v32 = *(_DWORD *)(a1 + 16);
      BOOL v33 = *(void *)a1 == 0x7265762D706F6F6CLL && *(void *)(a1 + 8) == 0x2D676E696E6F6973;
      int v34 = 1835231596;
LABEL_114:
      if (!v33 || v32 != v34) {
        goto LABEL_156;
      }
      return 1;
    case 0x16uLL:
      if (*(void *)a1 == 0x6164696C61766E69
        && *(void *)(a1 + 8) == 0x706F2D6F6E3C6574
        && *(void *)(a1 + 14) == 0x3E706F6F6C2D706FLL)
      {
        return 1;
      }
      uint64_t v35 = *(void *)(a1 + 14);
      BOOL v36 = *(void *)a1 == 0x6F6C3C746E697270 && *(void *)(a1 + 8) == 0x65686361632D706FLL;
      uint64_t v37 = 0x3E74736F632D6568;
      goto LABEL_135;
    case 0x17uLL:
      uint64_t v35 = *(void *)(a1 + 15);
      BOOL v36 = *(void *)a1 == 0x6164696C61766E69 && *(void *)(a1 + 8) == 0x73656363613C6574;
      uint64_t v37 = 0x3E6F666E692D7373;
LABEL_135:
      if (!v36 || v35 != v37) {
        goto LABEL_156;
      }
      return 1;
    case 0x1DuLL:
      uint64_t v46 = *(void *)(a1 + 16);
      uint64_t v47 = *(void *)(a1 + 21);
      BOOL v48 = *(void *)a1 == 0x3C65726975716572 && *(void *)(a1 + 8) == 0x736E692D73736170;
      uint64_t v49 = 0x61746E656D757274;
      goto LABEL_149;
    case 0x20uLL:
      uint64_t v46 = *(void *)(a1 + 16);
      uint64_t v47 = *(void *)(a1 + 24);
      BOOL v48 = *(void *)a1 == 0x6164696C61766E69 && *(void *)(a1 + 8) == 0x2D737361703C6574;
      uint64_t v49 = 0x656D757274736E69;
LABEL_149:
      if (!v48 || v46 != v49 || v47 != 0x3E6E6F697461746ELL) {
        goto LABEL_156;
      }
      return 1;
    default:
LABEL_156:
      if (sub_1CCC9F0D4((char *)a1, a2, "simple-loop-unswitch", 0x14uLL)
        || sub_1CCC9F0D4((char *)a1, a2, "licm", 4uLL)
        || sub_1CCC9F0D4((char *)a1, a2, "lnicm", 5uLL))
      {
        return 1;
      }
      uint64_t v53 = *(void *)a3;
      unsigned int v54 = *(_DWORD *)(a3 + 8);
      uint64_t result = sub_1CCCC0C78(a1, a2, v53, v54);
      break;
  }
  return result;
}

void llvm::PassBuilder::parsePassPipeline(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, void *a5@<X8>)
{
  v28[0] = a3;
  v28[1] = a4;
  llvm::PassBuilder::parsePipelineText(a3, a4, (uint64_t)&v25);
  int v8 = v27;
  if (!v27 || (uint64_t v9 = (uint64_t)v25, v10 = v26, v25 == v26))
  {
    int v15 = (void **)"invalid pipeline '{0}'";
    uint64_t v16 = 22;
    BOOL v17 = v21;
    uint64_t v18 = 1;
    uint64_t v19 = &unk_1F2617F90;
    BOOL v20 = (long long *)v28;
    v21[0] = &v19;
    sub_1CD465B2C((uint64_t)&v15, __p);
    llvm::inconvertibleErrorCode(v13);
    operator new();
  }
  long long v23 = *v25;
  if ((sub_1CCCAF058(v23, *((unint64_t *)&v23 + 1), *(void *)(a1 + 1504), (unint64_t *)*(unsigned int *)(a1 + 1512)) & 1) == 0)
  {
    int v15 = (void **)"unknown cgscc pass '{0}' in pipeline '{1}'";
    uint64_t v16 = 42;
    BOOL v17 = v22;
    uint64_t v18 = 2;
    uint64_t v19 = &unk_1F2617F90;
    BOOL v20 = &v23;
    v21[0] = &unk_1F2617F90;
    v21[1] = v28;
    v22[0] = &v19;
    v22[1] = v21;
    sub_1CD465B2C((uint64_t)&v15, __p);
    llvm::inconvertibleErrorCode(v14);
    operator new();
  }
  uint64_t v12 = 40 * (((uint64_t)v10 - v9) / 40);
  while (1)
  {
    llvm::PassBuilder::parseCGSCCPass(a1, a2, v9, v11);
    if (*a5) {
      break;
    }
    v9 += 40;
    v12 -= 40;
    if (!v12)
    {
      *a5 = 0;
      break;
    }
  }
  if (v8)
  {
    int v15 = (void **)&v25;
    sub_1CCCBB47C(&v15);
  }
}

{
  int v8;
  uint64_t v9;
  long long *v10;
  uint64_t v11;
  uint64_t v12;
  llvm *v13;
  llvm *v14;
  void **v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  void *v19;
  long long *v20;
  void v21[2];
  void v22[2];
  long long v23;
  void *__p[2];
  long long *v25;
  long long *v26;
  unsigned __int8 v27;
  void v28[2];

  v28[0] = a3;
  v28[1] = a4;
  llvm::PassBuilder::parsePipelineText(a3, a4, (uint64_t)&v25);
  int v8 = v27;
  if (!v27 || (uint64_t v9 = (uint64_t)v25, v10 = v26, v25 == v26))
  {
    int v15 = (void **)"invalid pipeline '{0}'";
    uint64_t v16 = 22;
    BOOL v17 = v21;
    uint64_t v18 = 1;
    uint64_t v19 = &unk_1F2617F90;
    BOOL v20 = (long long *)v28;
    v21[0] = &v19;
    sub_1CD465B2C((uint64_t)&v15, __p);
    llvm::inconvertibleErrorCode(v13);
    operator new();
  }
  long long v23 = *v25;
  if ((sub_1CCCAF560(v23, *((unint64_t *)&v23 + 1), *(void *)(a1 + 1664), (unint64_t *)*(unsigned int *)(a1 + 1672)) & 1) == 0)
  {
    int v15 = (void **)"unknown function pass '{0}' in pipeline '{1}'";
    uint64_t v16 = 45;
    BOOL v17 = v22;
    uint64_t v18 = 2;
    uint64_t v19 = &unk_1F2617F90;
    BOOL v20 = &v23;
    v21[0] = &unk_1F2617F90;
    v21[1] = v28;
    v22[0] = &v19;
    v22[1] = v21;
    sub_1CD465B2C((uint64_t)&v15, __p);
    llvm::inconvertibleErrorCode(v14);
    operator new();
  }
  uint64_t v12 = 40 * (((uint64_t)v10 - v9) / 40);
  while (1)
  {
    llvm::PassBuilder::parseFunctionPass(a1, a2, v9, v11);
    if (*a5) {
      break;
    }
    v9 += 40;
    v12 -= 40;
    if (!v12)
    {
      *a5 = 0;
      break;
    }
  }
  if (v8)
  {
    int v15 = (void **)&v25;
    sub_1CCCBB47C(&v15);
  }
}

void llvm::PassBuilder::parsePassPipeline(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, void **a5@<X8>)
{
  v20[0] = a3;
  v20[1] = a4;
  llvm::PassBuilder::parsePipelineText(a3, a4, (uint64_t)&v17);
  int v9 = v19;
  if (!v19 || (uint64_t v10 = v17, v17 == v18))
  {
    v13[0] = (void **)"invalid pipeline '{0}'";
    v13[1] = (void **)22;
    v13[2] = (void **)&v15;
    void v13[3] = (void **)1;
    v14[0] = &unk_1F2617F90;
    v14[1] = v20;
    int v15 = v14;
    sub_1CD465B2C((uint64_t)v13, &__p);
    llvm::inconvertibleErrorCode(v12);
    operator new();
  }
  uint64_t v11 = 40 * ((v18 - v17) / 40);
  while (1)
  {
    llvm::PassBuilder::parseLoopPass(a1, a2, v10, v8, a5);
    if (*a5) {
      break;
    }
    v10 += 40;
    v11 -= 40;
    if (!v11)
    {
      *a5 = 0;
      break;
    }
  }
  if (v9)
  {
    v13[0] = (void **)&v17;
    sub_1CCCBB47C(v13);
  }
}

uint64_t llvm::PassBuilder::isAAPassName(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = 0;
  switch(a3)
  {
    case 4:
      return *(_DWORD *)a2 == 1633772148;
    case 7:
      int v4 = *(_DWORD *)(a2 + 3);
      BOOL v5 = *(_DWORD *)a2 == 1986356083;
      int v6 = 1633758582;
      return v5 && v4 == v6;
    case 8:
      return *(void *)a2 == 0x61612D6369736162;
    case 10:
      int v4 = *(unsigned __int16 *)(a2 + 8);
      BOOL v5 = *(void *)a2 == 0x2D736C61626F6C67;
      int v6 = 24929;
      return v5 && v4 == v6;
    case 11:
      uint64_t v8 = *(void *)(a2 + 3);
      BOOL v9 = *(void *)a2 == 0x6372612D636A626FLL;
      uint64_t v10 = 0x2D6372612D63;
      goto LABEL_19;
    case 13:
      if (*(void *)a2 == 0x65646E612D6C6663 && *(void *)(a2 + 5) == 0x61612D737265646ELL) {
        return 1;
      }
      uint64_t v8 = *(void *)(a2 + 5);
      BOOL v9 = *(void *)a2 == 0x656574732D6C6663;
      uint64_t v10 = 0x2D736E656574;
LABEL_19:
      uint64_t v12 = v10 & 0xFFFFFFFFFFFFLL | 0x6161000000000000;
      return v9 && v8 == v12;
    case 17:
      return *(void *)a2 == 0x6E2D6465706F6373
          && *(void *)(a2 + 8) == 0x612D7361696C616FLL
          && *(unsigned char *)(a2 + 16) == 97;
    default:
      return result;
  }
}

uint64_t llvm::PassBuilder::isAnalysisPassName(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  switch(a3)
  {
    case 2:
      if (*a2 == 24929) {
        goto LABEL_214;
      }
      int v3 = *a2;
      int v4 = 24932;
      goto LABEL_10;
    case 3:
      int v5 = 103;
      if (*a2 == 25452 && *((unsigned char *)a2 + 2) == 103) {
        goto LABEL_214;
      }
      int v7 = *((unsigned __int8 *)a2 + 2);
      BOOL v8 = *a2 == 25700;
      return v8 && v7 == v5;
    case 4:
      int v3 = *(_DWORD *)a2;
      int v4 = 1633772148;
LABEL_10:
      if (v3 == v4) {
        goto LABEL_214;
      }
      goto LABEL_213;
    case 5:
      int v9 = *((unsigned __int8 *)a2 + 4);
      BOOL v10 = *(_DWORD *)a2 == 1886351212;
      int v11 = 115;
      return v10 && v9 == v11;
    case 6:
      if (*(_DWORD *)a2 == 1769104758 && a2[2] == 31078) {
        goto LABEL_214;
      }
      if (*(_DWORD *)a2 == 1818458467 && a2[2] == 29541) {
        goto LABEL_214;
      }
      int v14 = a2[2];
      BOOL v15 = *(_DWORD *)a2 == 1684890989;
      int v16 = 28773;
      goto LABEL_93;
    case 7:
      if (*(_DWORD *)a2 == 1953328996 && *(_DWORD *)((char *)a2 + 3) == 1701147252) {
        goto LABEL_214;
      }
      if (*(_DWORD *)a2 == 1768383858 && *(_DWORD *)((char *)a2 + 3) == 1936617321) {
        goto LABEL_214;
      }
      int v9 = *(_DWORD *)((char *)a2 + 3);
      BOOL v10 = *(_DWORD *)a2 == 1986356083;
      int v11 = 1633758582;
      return v10 && v9 == v11;
    case 8:
      if (*(void *)a2 == 0x7269746567726174 || *(void *)a2 == 0x61612D6369736162) {
        goto LABEL_214;
      }
      return *(void *)a2 == 0x73726573752D7669;
    case 9:
      if (*(void *)a2 == 0x706172676C6C6163 && *((unsigned char *)a2 + 8) == 104) {
        goto LABEL_214;
      }
      if (*(void *)a2 == 0x786F72702D6D6166 && *((unsigned char *)a2 + 8) == 121) {
        goto LABEL_214;
      }
      int v14 = *((unsigned __int8 *)a2 + 8);
      BOOL v15 = *(void *)a2 == 0x737379726F6D656DLL;
      int v16 = 97;
      goto LABEL_93;
    case 10:
      if (*(void *)a2 == 0x2D736C61626F6C67 && a2[4] == 24929) {
        goto LABEL_214;
      }
      if (*(void *)a2 == 0x72662D6B636F6C62 && a2[4] == 29029) {
        goto LABEL_214;
      }
      if (*(void *)a2 == 0x756C61762D696870 && a2[4] == 29541) {
        goto LABEL_214;
      }
      if (*(void *)a2 == 0x6E65677265766964 && a2[4] == 25955) {
        goto LABEL_214;
      }
      int v14 = a2[4];
      BOOL v15 = *(void *)a2 == 0x6F6C2D706F2D6F6ELL;
      int v16 = 28783;
      goto LABEL_93;
    case 11:
      if (*(void *)a2 == 0x67632D706F2D6F6ELL && *(void *)((char *)a2 + 3) == 0x63637367632D706FLL) {
        goto LABEL_214;
      }
      if (*(void *)a2 == 0x6974706D75737361 && *(void *)((char *)a2 + 3) == 0x736E6F6974706D75) {
        goto LABEL_214;
      }
      if (*(void *)a2 == 0x702D68636E617262 && *(void *)((char *)a2 + 3) == 0x626F72702D68636ELL) {
        goto LABEL_214;
      }
      if (*(void *)a2 == 0x746D6F6474736F70 && *(void *)((char *)a2 + 3) == 0x656572746D6F6474) {
        goto LABEL_214;
      }
      if (*(void *)a2 == 0x746E6F72666D6F64 && *(void *)((char *)a2 + 3) == 0x726569746E6F7266) {
        goto LABEL_214;
      }
      if (*(void *)a2 == 0x6372612D636A626FLL && *(void *)((char *)a2 + 3) == 0x61612D6372612D63) {
        goto LABEL_214;
      }
      uint64_t v32 = *(void *)((char *)a2 + 3);
      BOOL v33 = *(void *)a2 == 0x692D737365636361;
      uint64_t v34 = 0x6F666E692D737365;
      goto LABEL_148;
    case 12:
      if (*(void *)a2 == 0x6F6D2D706F2D6F6ELL && *((_DWORD *)a2 + 2) == 1701606756) {
        goto LABEL_214;
      }
      int v14 = *((_DWORD *)a2 + 2);
      BOOL v15 = *(void *)a2 == 0x61732D6B63617473;
      int v16 = 2037671270;
LABEL_93:
      if (!v15 || v14 != v16) {
        goto LABEL_213;
      }
      goto LABEL_214;
    case 13:
      if (*(void *)a2 == 0x6C696D69732D7269 && *(void *)((char *)a2 + 5) == 0x79746972616C696DLL) {
        goto LABEL_214;
      }
      if (*(void *)a2 == 0x6465646E616D6564 && *(void *)((char *)a2 + 5) == 0x737469622D646564) {
        goto LABEL_214;
      }
      if (*(void *)a2 == 0x696C746567726174 && *(void *)((char *)a2 + 5) == 0x6F666E6962696C74) {
        goto LABEL_214;
      }
      if (*(void *)a2 == 0x65646E612D6C6663 && *(void *)((char *)a2 + 5) == 0x61612D737265646ELL) {
        goto LABEL_214;
      }
      uint64_t v32 = *(void *)((char *)a2 + 5);
      BOOL v33 = *(void *)a2 == 0x656574732D6C6663;
      uint64_t v34 = 0x61612D736E656574;
      goto LABEL_148;
    case 14:
      if (*(void *)a2 == 0x732D656C75646F6DLL && *(void *)(a2 + 3) == 0x7972616D6D75732DLL) {
        goto LABEL_214;
      }
      if (*(void *)a2 == 0x612D656E696C6E69 && *(void *)(a2 + 3) == 0x726F73697664612DLL) {
        goto LABEL_214;
      }
      uint64_t v32 = *(void *)(a2 + 3);
      BOOL v33 = *(void *)a2 == 0x75662D706F2D6F6ELL;
      unsigned int v43 = 1668183398;
LABEL_147:
      uint64_t v34 = v43 | 0x6E6F697400000000;
      goto LABEL_148;
    case 15:
      if (*(void *)a2 == 0x6E6F6974636E7566 && *(void *)((char *)a2 + 7) == 0x7370756F72672D6ELL) {
        goto LABEL_214;
      }
      if (*(void *)a2 == 0x2D656C69666F7270 && *(void *)((char *)a2 + 7) == 0x7972616D6D75732DLL) {
        goto LABEL_214;
      }
      if (*(void *)a2 == 0x6F6C672D6E617361 && *(void *)((char *)a2 + 7) == 0x646D2D736C61626FLL) {
        goto LABEL_214;
      }
      if (*(void *)a2 == 0x6F72702D636E7566 && *(void *)((char *)a2 + 7) == 0x736569747265706FLL) {
        goto LABEL_214;
      }
      if (*(void *)a2 == 0x6C61762D797A616CLL && *(void *)((char *)a2 + 7) == 0x6F666E692D65756CLL) {
        goto LABEL_214;
      }
      uint64_t v32 = *(void *)((char *)a2 + 7);
      BOOL v33 = *(void *)a2 == 0x616D65722D74706FLL;
      uint64_t v34 = 0x74696D652D6B7261;
LABEL_148:
      if (!v33 || v32 != v34) {
        goto LABEL_213;
      }
      goto LABEL_214;
    case 16:
      uint64_t v32 = *((void *)a2 + 1);
      BOOL v33 = *(void *)a2 == 0x652D72616C616373;
      unsigned int v43 = 1970040694;
      goto LABEL_147;
    case 17:
      int v50 = *((unsigned __int8 *)a2 + 16);
      BOOL v51 = *(void *)a2 == 0x6E2D6465706F6373 && *((void *)a2 + 1) == 0x612D7361696C616FLL;
      int v52 = 97;
      goto LABEL_162;
    case 18:
      int v50 = a2[8];
      BOOL v51 = *(void *)a2 == 0x61732D6B63617473 && *((void *)a2 + 1) == 0x636F6C2D79746566;
      int v52 = 27745;
LABEL_162:
      if (!v51 || v50 != v52) {
        goto LABEL_213;
      }
      goto LABEL_214;
    case 20:
      int v7 = *((_DWORD *)a2 + 4);
      BOOL v8 = *(void *)a2 == 0x736E692D73736170 && *((void *)a2 + 1) == 0x61746E656D757274;
      int v5 = 1852795252;
      return v8 && v7 == v5;
    case 21:
      return *(void *)a2 == 0x636E75662D757067
          && *((void *)a2 + 1) == 0x616E612D6E6F6974
          && *(void *)((char *)a2 + 13) == 0x736973796C616E61;
    case 22:
      if (*(void *)a2 != 0x2D72656E696C6E69
        || *((void *)a2 + 1) != 0x7473652D657A6973
        || *(void *)(a2 + 7) != 0x726F74616D697473)
      {
        goto LABEL_213;
      }
      goto LABEL_214;
    case 30:
      if (*(void *)a2 != 0x6E2D646C756F6873
        || *((void *)a2 + 1) != 0x662D6E75722D746FLL
        || *((void *)a2 + 2) != 0x2D6E6F6974636E75
        || *(void *)(a2 + 11) != 0x7365737361702D6ELL)
      {
        BOOL v61 = *(void *)a2 == 0x722D646C756F6873 && *((void *)a2 + 1) == 0x61727478652D6E75;
        BOOL v62 = v61 && *((void *)a2 + 2) == 0x2D726F746365762DLL;
        if (!v62 || *(void *)(a2 + 11) != 0x7365737361702D72) {
          goto LABEL_213;
        }
      }
LABEL_214:
      uint64_t result = 1;
      break;
    default:
LABEL_213:
      uint64_t result = 0;
      break;
  }
  return result;
}

llvm::raw_ostream *llvm::PassBuilder::printPassNames(llvm::PassBuilder *this, llvm::raw_ostream *a2)
{
  int v3 = (void *)*((void *)a2 + 4);
  if (*((void *)a2 + 3) - (void)v3 > 0xEuLL)
  {
    qmemcpy(v3, "Module passes:\n", 15);
    *((void *)a2 + 4) += 15;
  }
  else
  {
    llvm::raw_ostream::write(a2, "Module passes:\n", 0xFuLL);
  }
  sub_1CCCB6410("always-inline", 0xDuLL, a2);
  sub_1CCCB6410("attributor", 0xAuLL, a2);
  sub_1CCCB6410("annotation2metadata", 0x13uLL, a2);
  sub_1CCCB6410("openmp-opt", 0xAuLL, a2);
  sub_1CCCB6410("called-value-propagation", 0x18uLL, a2);
  sub_1CCCB6410("canonicalize-aliases", 0x14uLL, a2);
  sub_1CCCB6410("cg-profile", 0xAuLL, a2);
  sub_1CCCB6410("check-debugify", 0xEuLL, a2);
  sub_1CCCB6410("constmerge", 0xAuLL, a2);
  sub_1CCCB6410("coro-early", 0xAuLL, a2);
  sub_1CCCB6410("cross-dso-cfi", 0xDuLL, a2);
  sub_1CCCB6410("deadargelim", 0xBuLL, a2);
  sub_1CCCB6410("debugify", 8uLL, a2);
  sub_1CCCB6410("dot-callgraph", 0xDuLL, a2);
  sub_1CCCB6410("elim-avail-extern", 0x11uLL, a2);
  sub_1CCCB6410("extract-blocks", 0xEuLL, a2);
  sub_1CCCB6410("forceattrs", 0xAuLL, a2);
  sub_1CCCB6410("function-import", 0xFuLL, a2);
  sub_1CCCB6410("function-specialization", 0x17uLL, a2);
  sub_1CCCB6410("globaldce", 9uLL, a2);
  sub_1CCCB6410("globalopt", 9uLL, a2);
  sub_1CCCB6410("globalsplit", 0xBuLL, a2);
  sub_1CCCB6410("hotcoldsplit", 0xCuLL, a2);
  sub_1CCCB6410("inferattrs", 0xAuLL, a2);
  sub_1CCCB6410("inliner-wrapper", 0xFuLL, a2);
  sub_1CCCB6410("print<inline-advisor>", 0x15uLL, a2);
  sub_1CCCB6410("inliner-wrapper-no-mandatory-first", 0x22uLL, a2);
  sub_1CCCB6410("insert-gcov-profiling", 0x15uLL, a2);
  sub_1CCCB6410("instrorderfile", 0xEuLL, a2);
  sub_1CCCB6410("instrprof", 9uLL, a2);
  sub_1CCCB6410("internalize", 0xBuLL, a2);
  sub_1CCCB6410("invalidate<all>", 0xFuLL, a2);
  sub_1CCCB6410("ipsccp", 6uLL, a2);
  sub_1CCCB6410("iroutliner", 0xAuLL, a2);
  sub_1CCCB6410("print-ir-similarity", 0x13uLL, a2);
  sub_1CCCB6410("lower-global-dtors", 0x12uLL, a2);
  sub_1CCCB6410("lowertypetests", 0xEuLL, a2);
  sub_1CCCB6410("metarenamer", 0xBuLL, a2);
  sub_1CCCB6410("mergefunc", 9uLL, a2);
  sub_1CCCB6410("name-anon-globals", 0x11uLL, a2);
  sub_1CCCB6410("no-op-module", 0xCuLL, a2);
  sub_1CCCB6410("objc-arc-apelim", 0xFuLL, a2);
  sub_1CCCB6410("partial-inliner", 0xFuLL, a2);
  sub_1CCCB6410("pgo-icall-prom", 0xEuLL, a2);
  sub_1CCCB6410("pgo-instr-gen", 0xDuLL, a2);
  sub_1CCCB6410("pgo-instr-use", 0xDuLL, a2);
  sub_1CCCB6410("print-function-groups", 0x15uLL, a2);
  sub_1CCCB6410("print-profile-summary", 0x15uLL, a2);
  sub_1CCCB6410("print-callgraph", 0xFuLL, a2);
  sub_1CCCB6410("print", 5uLL, a2);
  sub_1CCCB6410("print-lcg", 9uLL, a2);
  sub_1CCCB6410("print-lcg-dot", 0xDuLL, a2);
  sub_1CCCB6410("print-must-be-executed-contexts", 0x1FuLL, a2);
  sub_1CCCB6410("print-stack-safety", 0x12uLL, a2);
  sub_1CCCB6410("print<module-debuginfo>", 0x17uLL, a2);
  sub_1CCCB6410("recompute-globalsaa", 0x13uLL, a2);
  sub_1CCCB6410("rel-lookup-table-converter", 0x1AuLL, a2);
  sub_1CCCB6410("rewrite-statepoints-for-gc", 0x1AuLL, a2);
  sub_1CCCB6410("rewrite-symbols", 0xFuLL, a2);
  sub_1CCCB6410("rpo-function-attrs", 0x12uLL, a2);
  sub_1CCCB6410("sample-profile", 0xEuLL, a2);
  sub_1CCCB6410("scc-oz-module-inliner", 0x15uLL, a2);
  sub_1CCCB6410("strip", 5uLL, a2);
  sub_1CCCB6410("strip-dead-debug-info", 0x15uLL, a2);
  sub_1CCCB6410("pseudo-probe", 0xCuLL, a2);
  sub_1CCCB6410("soft-ptrauth", 0xCuLL, a2);
  sub_1CCCB6410("strip-dead-prototypes", 0x15uLL, a2);
  sub_1CCCB6410("strip-debug-declare", 0x13uLL, a2);
  sub_1CCCB6410("strip-nondebug", 0xEuLL, a2);
  sub_1CCCB6410("strip-nonlinetable-debuginfo", 0x1CuLL, a2);
  sub_1CCCB6410("synthetic-counts-propagation", 0x1CuLL, a2);
  sub_1CCCB6410("verify", 6uLL, a2);
  sub_1CCCB6410("view-callgraph", 0xEuLL, a2);
  sub_1CCCB6410("wholeprogramdevirt", 0x12uLL, a2);
  sub_1CCCB6410("dfsan", 5uLL, a2);
  sub_1CCCB6410("msan-module", 0xBuLL, a2);
  sub_1CCCB6410("module-inline", 0xDuLL, a2);
  sub_1CCCB6410("tsan-module", 0xBuLL, a2);
  sub_1CCCB6410("sancov-module", 0xDuLL, a2);
  sub_1CCCB6410("memprof-module", 0xEuLL, a2);
  sub_1CCCB6410("poison-checking", 0xFuLL, a2);
  sub_1CCCB6410("pseudo-probe-update", 0x13uLL, a2);
  int v4 = (void *)*((void *)a2 + 4);
  if (*((void *)a2 + 3) - (void)v4 > 0x1AuLL)
  {
    qmemcpy(v4, "Module passes with params:\n", 27);
    *((void *)a2 + 4) += 27;
  }
  else
  {
    llvm::raw_ostream::write(a2, "Module passes with params:\n", 0x1BuLL);
  }
  sub_1CCCB6514("loop-extract", 0xCuLL, "single", 6uLL, a2);
  sub_1CCCB6514("hwasan", 6uLL, "kernel;recover", 0xEuLL, a2);
  sub_1CCCB6514("asan-module", 0xBuLL, "kernel", 6uLL, a2);
  uint64_t v5 = *((void *)a2 + 4);
  if ((unint64_t)(*((void *)a2 + 3) - v5) > 0x10)
  {
    *(unsigned char *)(v5 + 16) = 10;
    *(_OWORD *)uint64_t v5 = *(_OWORD *)"Module analyses:\n";
    *((void *)a2 + 4) += 17;
  }
  else
  {
    llvm::raw_ostream::write(a2, "Module analyses:\n", 0x11uLL);
  }
  sub_1CCCB6410("callgraph", 9uLL, a2);
  sub_1CCCB6410("function-groups", 0xFuLL, a2);
  sub_1CCCB6410("lcg", 3uLL, a2);
  sub_1CCCB6410("module-summary", 0xEuLL, a2);
  sub_1CCCB6410("no-op-module", 0xCuLL, a2);
  sub_1CCCB6410("profile-summary", 0xFuLL, a2);
  sub_1CCCB6410("stack-safety", 0xCuLL, a2);
  sub_1CCCB6410("verify", 6uLL, a2);
  sub_1CCCB6410("pass-instrumentation", 0x14uLL, a2);
  sub_1CCCB6410("asan-globals-md", 0xFuLL, a2);
  sub_1CCCB6410("inline-advisor", 0xEuLL, a2);
  sub_1CCCB6410("ir-similarity", 0xDuLL, a2);
  sub_1CCCB6410("globals-aa", 0xAuLL, a2);
  int v6 = (void *)*((void *)a2 + 4);
  if (*((void *)a2 + 3) - (void)v6 > 0x16uLL)
  {
    qmemcpy(v6, "Module alias analyses:\n", 23);
    *((void *)a2 + 4) += 23;
  }
  else
  {
    llvm::raw_ostream::write(a2, "Module alias analyses:\n", 0x17uLL);
  }
  sub_1CCCB6410("globals-aa", 0xAuLL, a2);
  int v7 = (void *)*((void *)a2 + 4);
  if (*((void *)a2 + 3) - (void)v7 > 0xDuLL)
  {
    qmemcpy(v7, "CGSCC passes:\n", 14);
    *((void *)a2 + 4) += 14;
  }
  else
  {
    llvm::raw_ostream::write(a2, "CGSCC passes:\n", 0xEuLL);
  }
  sub_1CCCB6410("argpromotion", 0xCuLL, a2);
  sub_1CCCB6410("invalidate<all>", 0xFuLL, a2);
  sub_1CCCB6410("function-attrs", 0xEuLL, a2);
  sub_1CCCB6410("attributor-cgscc", 0x10uLL, a2);
  sub_1CCCB6410("openmp-opt-cgscc", 0x10uLL, a2);
  sub_1CCCB6410("coro-split", 0xAuLL, a2);
  sub_1CCCB6410("no-op-cgscc", 0xBuLL, a2);
  BOOL v8 = (void *)*((void *)a2 + 4);
  if (*((void *)a2 + 3) - (void)v8 > 0x19uLL)
  {
    qmemcpy(v8, "CGSCC passes with params:\n", 26);
    *((void *)a2 + 4) += 26;
  }
  else
  {
    llvm::raw_ostream::write(a2, "CGSCC passes with params:\n", 0x1AuLL);
  }
  sub_1CCCB6514("inline", 6uLL, "only-mandatory", 0xEuLL, a2);
  int v9 = (_OWORD *)*((void *)a2 + 4);
  if (*((void *)a2 + 3) - (void)v9 > 0xFuLL)
  {
    _OWORD *v9 = *(_OWORD *)"CGSCC analyses:\n";
    *((void *)a2 + 4) += 16;
  }
  else
  {
    llvm::raw_ostream::write(a2, "CGSCC analyses:\n", 0x10uLL);
  }
  sub_1CCCB6410("no-op-cgscc", 0xBuLL, a2);
  sub_1CCCB6410("fam-proxy", 9uLL, a2);
  sub_1CCCB6410("pass-instrumentation", 0x14uLL, a2);
  uint64_t v10 = *((void *)a2 + 4);
  if ((unint64_t)(*((void *)a2 + 3) - v10) > 0x10)
  {
    *(unsigned char *)(v10 + 16) = 10;
    *(_OWORD *)uint64_t v10 = *(_OWORD *)"Function passes:\n";
    *((void *)a2 + 4) += 17;
  }
  else
  {
    llvm::raw_ostream::write(a2, "Function passes:\n", 0x11uLL);
  }
  sub_1CCCB6410("aa-eval", 7uLL, a2);
  sub_1CCCB6410("adce", 4uLL, a2);
  sub_1CCCB6410("add-discriminators", 0x12uLL, a2);
  sub_1CCCB6410("aggressive-instcombine", 0x16uLL, a2);
  sub_1CCCB6410("assume-builder", 0xEuLL, a2);
  sub_1CCCB6410("assume-simplify", 0xFuLL, a2);
  sub_1CCCB6410("alignment-from-assumptions", 0x1AuLL, a2);
  sub_1CCCB6410("annotation-remarks", 0x12uLL, a2);
  sub_1CCCB6410("bdce", 4uLL, a2);
  sub_1CCCB6410("bounds-checking", 0xFuLL, a2);
  sub_1CCCB6410("break-crit-edges", 0x10uLL, a2);
  sub_1CCCB6410("callsite-splitting", 0x12uLL, a2);
  sub_1CCCB6410("consthoist", 0xAuLL, a2);
  sub_1CCCB6410("constraint-elimination", 0x16uLL, a2);
  sub_1CCCB6410("chr", 3uLL, a2);
  sub_1CCCB6410("coro-elide", 0xAuLL, a2);
  sub_1CCCB6410("coro-cleanup", 0xCuLL, a2);
  sub_1CCCB6410("correlated-propagation", 0x16uLL, a2);
  sub_1CCCB6410("dce", 3uLL, a2);
  sub_1CCCB6410("dfa-jump-threading", 0x12uLL, a2);
  sub_1CCCB6410("div-rem-pairs", 0xDuLL, a2);
  sub_1CCCB6410("dse", 3uLL, a2);
  sub_1CCCB6410("dot-cfg", 7uLL, a2);
  sub_1CCCB6410("dot-cfg-only", 0xCuLL, a2);
  sub_1CCCB6410("dot-dom", 7uLL, a2);
  sub_1CCCB6410("dot-dom-only", 0xCuLL, a2);
  sub_1CCCB6410("fix-irreducible", 0xFuLL, a2);
  sub_1CCCB6410("flattencfg", 0xAuLL, a2);
  sub_1CCCB6410("make-guards-explicit", 0x14uLL, a2);
  sub_1CCCB6410("gvn-hoist", 9uLL, a2);
  sub_1CCCB6410("gvn-sink", 8uLL, a2);
  sub_1CCCB6410("helloworld", 0xAuLL, a2);
  sub_1CCCB6410("infer-address-spaces", 0x14uLL, a2);
  sub_1CCCB6410("instcombine", 0xBuLL, a2);
  sub_1CCCB6410("instcount", 9uLL, a2);
  sub_1CCCB6410("instsimplify", 0xCuLL, a2);
  sub_1CCCB6410("invalidate<all>", 0xFuLL, a2);
  sub_1CCCB6410("irce", 4uLL, a2);
  sub_1CCCB6410("float2int", 9uLL, a2);
  sub_1CCCB6410("no-op-function", 0xEuLL, a2);
  sub_1CCCB6410("libcalls-shrinkwrap", 0x13uLL, a2);
  sub_1CCCB6410("lint", 4uLL, a2);
  sub_1CCCB6410("inject-tli-mappings", 0x13uLL, a2);
  sub_1CCCB6410("instnamer", 9uLL, a2);
  sub_1CCCB6410("loweratomic", 0xBuLL, a2);
  sub_1CCCB6410("lower-expect", 0xCuLL, a2);
  sub_1CCCB6410("lower-guard-intrinsic", 0x15uLL, a2);
  sub_1CCCB6410("lower-constant-intrinsics", 0x19uLL, a2);
  sub_1CCCB6410("lower-widenable-condition", 0x19uLL, a2);
  sub_1CCCB6410("guard-widening", 0xEuLL, a2);
  sub_1CCCB6410("load-store-vectorizer", 0x15uLL, a2);
  sub_1CCCB6410("loop-simplify", 0xDuLL, a2);
  sub_1CCCB6410("loop-sink", 9uLL, a2);
  sub_1CCCB6410("lowerinvoke", 0xBuLL, a2);
  sub_1CCCB6410("lowerswitch", 0xBuLL, a2);
  sub_1CCCB6410("mem2reg", 7uLL, a2);
  sub_1CCCB6410("memcpyopt", 9uLL, a2);
  sub_1CCCB6410("mergeicmps", 0xAuLL, a2);
  sub_1CCCB6410("mergereturn", 0xBuLL, a2);
  sub_1CCCB6410("nary-reassociate", 0x10uLL, a2);
  sub_1CCCB6410("newgvn", 6uLL, a2);
  sub_1CCCB6410("jump-threading", 0xEuLL, a2);
  sub_1CCCB6410("partially-inline-libcalls", 0x19uLL, a2);
  sub_1CCCB6410("lcssa", 5uLL, a2);
  sub_1CCCB6410("loop-data-prefetch", 0x12uLL, a2);
  sub_1CCCB6410("loop-load-elim", 0xEuLL, a2);
  sub_1CCCB6410("loop-fusion", 0xBuLL, a2);
  sub_1CCCB6410("loop-distribute", 0xFuLL, a2);
  sub_1CCCB6410("loop-versioning", 0xFuLL, a2);
  sub_1CCCB6410("objc-arc", 8uLL, a2);
  sub_1CCCB6410("objc-arc-contract", 0x11uLL, a2);
  sub_1CCCB6410("objc-arc-expand", 0xFuLL, a2);
  sub_1CCCB6410("pgo-memop-opt", 0xDuLL, a2);
  sub_1CCCB6410("print", 5uLL, a2);
  sub_1CCCB6410("print<assumptions>", 0x12uLL, a2);
  sub_1CCCB6410("print<block-freq>", 0x11uLL, a2);
  sub_1CCCB6410("print<branch-prob>", 0x12uLL, a2);
  sub_1CCCB6410("print<cost-model>", 0x11uLL, a2);
  sub_1CCCB6410("print<cycles>", 0xDuLL, a2);
  sub_1CCCB6410("print<da>", 9uLL, a2);
  sub_1CCCB6410("print<divergence>", 0x11uLL, a2);
  sub_1CCCB6410("print<domtree>", 0xEuLL, a2);
  sub_1CCCB6410("print<postdomtree>", 0x12uLL, a2);
  sub_1CCCB6410("print<delinearization>", 0x16uLL, a2);
  sub_1CCCB6410("print<demanded-bits>", 0x14uLL, a2);
  sub_1CCCB6410("print<domfrontier>", 0x12uLL, a2);
  sub_1CCCB6410("print<func-properties>", 0x16uLL, a2);
  sub_1CCCB6410("print<inline-cost>", 0x12uLL, a2);
  sub_1CCCB6410("print<inliner-size-estimator>", 0x1DuLL, a2);
  sub_1CCCB6410("print<gpu-function-analysis>", 0x1CuLL, a2);
  sub_1CCCB6410("print<loops>", 0xCuLL, a2);
  sub_1CCCB6410("print<memoryssa>", 0x10uLL, a2);
  sub_1CCCB6410("print<memoryssa-walker>", 0x17uLL, a2);
  sub_1CCCB6410("print<phi-values>", 0x11uLL, a2);
  sub_1CCCB6410("print<regions>", 0xEuLL, a2);
  sub_1CCCB6410("print<scalar-evolution>", 0x17uLL, a2);
  sub_1CCCB6410("print<stack-safety-local>", 0x19uLL, a2);
  sub_1CCCB6410("print-alias-sets", 0x10uLL, a2);
  sub_1CCCB6410("print-predicateinfo", 0x13uLL, a2);
  sub_1CCCB6410("print-mustexecute", 0x11uLL, a2);
  sub_1CCCB6410("print-memderefs", 0xFuLL, a2);
  sub_1CCCB6410("reassociate", 0xBuLL, a2);
  sub_1CCCB6410("redundant-dbg-inst-elim", 0x17uLL, a2);
  sub_1CCCB6410("reg2mem", 7uLL, a2);
  sub_1CCCB6410("scalarize-masked-mem-intrin", 0x1BuLL, a2);
  sub_1CCCB6410("scalarizer", 0xAuLL, a2);
  sub_1CCCB6410("separate-const-offset-from-gep", 0x1EuLL, a2);
  sub_1CCCB6410("sccp", 4uLL, a2);
  sub_1CCCB6410("sink", 4uLL, a2);
  sub_1CCCB6410("slp-vectorizer", 0xEuLL, a2);
  sub_1CCCB6410("slsr", 4uLL, a2);
  sub_1CCCB6410("speculative-execution", 0x15uLL, a2);
  sub_1CCCB6410("sroa", 4uLL, a2);
  sub_1CCCB6410("strip-gc-relocates", 0x12uLL, a2);
  sub_1CCCB6410("structurizecfg", 0xEuLL, a2);
  sub_1CCCB6410("tailcallelim", 0xCuLL, a2);
  sub_1CCCB6410("unify-loop-exits", 0x10uLL, a2);
  sub_1CCCB6410("vector-combine", 0xEuLL, a2);
  sub_1CCCB6410("verify", 6uLL, a2);
  sub_1CCCB6410("verify<domtree>", 0xFuLL, a2);
  sub_1CCCB6410("verify<loops>", 0xDuLL, a2);
  sub_1CCCB6410("verify<memoryssa>", 0x11uLL, a2);
  sub_1CCCB6410("verify<regions>", 0xFuLL, a2);
  sub_1CCCB6410("verify<safepoint-ir>", 0x14uLL, a2);
  sub_1CCCB6410("verify<scalar-evolution>", 0x18uLL, a2);
  sub_1CCCB6410("view-cfg", 8uLL, a2);
  sub_1CCCB6410("view-cfg-only", 0xDuLL, a2);
  sub_1CCCB6410("tlshoist", 8uLL, a2);
  sub_1CCCB6410("transform-warning", 0x11uLL, a2);
  sub_1CCCB6410("tsan", 4uLL, a2);
  sub_1CCCB6410("memprof", 7uLL, a2);
  int v11 = (void *)*((void *)a2 + 4);
  if (*((void *)a2 + 3) - (void)v11 > 0x1CuLL)
  {
    qmemcpy(v11, "Function passes with params:\n", 29);
    *((void *)a2 + 4) += 29;
  }
  else
  {
    llvm::raw_ostream::write(a2, "Function passes with params:\n", 0x1DuLL);
  }
  sub_1CCCB6514("early-cse", 9uLL, "memssa", 6uLL, a2);
  sub_1CCCB6514("ee-instrument", 0xDuLL, "post-inline", 0xBuLL, a2);
  sub_1CCCB6514("lower-matrix-intrinsics", 0x17uLL, "minimal", 7uLL, a2);
  sub_1CCCB6514("loop-unroll", 0xBuLL, "O0;O1;O2;O3;full-unroll-max=N;no-partial;partial;no-peeling;peeling;no-profile-peeling;profile-peeling;no-runtime;ru"
    "ntime;no-upperbound;upperbound",
    0x92uLL,
    a2);
  sub_1CCCB6514("msan", 4uLL, "recover;kernel;eager-checks;track-origins=N", 0x2BuLL, a2);
  sub_1CCCB6514("simplifycfg", 0xBuLL, "no-forward-switch-cond;forward-switch-cond;no-switch-range-to-icmp;switch-range-to-icmp;no-switch-to-lookup;switch-t"
    "o-lookup;no-keep-loops;keep-loops;no-hoist-common-insts;hoist-common-insts;no-sink-common-insts;sink-common-insts;bo"
    "nus-inst-threshold=N",
    0xFCuLL,
    a2);
  sub_1CCCB6514("loop-vectorize", 0xEuLL, "no-interleave-forced-only;interleave-forced-only;no-vectorize-forced-only;vectorize-forced-only",
    0x5FuLL,
    a2);
  sub_1CCCB6514("mldst-motion", 0xCuLL, "no-split-footer-bb;split-footer-bb", 0x22uLL, a2);
  sub_1CCCB6514("gvn", 3uLL, "no-pre;pre;no-load-pre;load-pre;no-split-backedge-load-pre;split-backedge-load-pre;no-memdep;memdep",
    0x63uLL,
    a2);
  sub_1CCCB6514("print<stack-lifetime>", 0x15uLL, "may;must", 8uLL, a2);
  uint64_t v12 = *((void *)a2 + 4);
  if ((unint64_t)(*((void *)a2 + 3) - v12) > 0x12)
  {
    *(_DWORD *)(v12 + 15) = 171602789;
    *(_OWORD *)uint64_t v12 = *(_OWORD *)"Function analyses:\n";
    *((void *)a2 + 4) += 19;
  }
  else
  {
    llvm::raw_ostream::write(a2, "Function analyses:\n", 0x13uLL);
  }
  sub_1CCCB6410("aa", 2uLL, a2);
  sub_1CCCB6410("assumptions", 0xBuLL, a2);
  sub_1CCCB6410("block-freq", 0xAuLL, a2);
  sub_1CCCB6410("branch-prob", 0xBuLL, a2);
  sub_1CCCB6410("cycles", 6uLL, a2);
  sub_1CCCB6410("domtree", 7uLL, a2);
  sub_1CCCB6410("postdomtree", 0xBuLL, a2);
  sub_1CCCB6410("demanded-bits", 0xDuLL, a2);
  sub_1CCCB6410("domfrontier", 0xBuLL, a2);
  sub_1CCCB6410("func-properties", 0xFuLL, a2);
  sub_1CCCB6410("loops", 5uLL, a2);
  sub_1CCCB6410("lazy-value-info", 0xFuLL, a2);
  sub_1CCCB6410("da", 2uLL, a2);
  sub_1CCCB6410("inliner-size-estimator", 0x16uLL, a2);
  sub_1CCCB6410("memdep", 6uLL, a2);
  sub_1CCCB6410("memoryssa", 9uLL, a2);
  sub_1CCCB6410("phi-values", 0xAuLL, a2);
  sub_1CCCB6410("regions", 7uLL, a2);
  sub_1CCCB6410("no-op-function", 0xEuLL, a2);
  sub_1CCCB6410("opt-remark-emit", 0xFuLL, a2);
  sub_1CCCB6410("scalar-evolution", 0x10uLL, a2);
  sub_1CCCB6410("should-not-run-function-passes", 0x1EuLL, a2);
  sub_1CCCB6410("should-run-extra-vector-passes", 0x1EuLL, a2);
  sub_1CCCB6410("stack-safety-local", 0x12uLL, a2);
  sub_1CCCB6410("targetlibinfo", 0xDuLL, a2);
  sub_1CCCB6410("targetir", 8uLL, a2);
  sub_1CCCB6410("verify", 6uLL, a2);
  sub_1CCCB6410("pass-instrumentation", 0x14uLL, a2);
  sub_1CCCB6410("divergence", 0xAuLL, a2);
  sub_1CCCB6410("gpu-function-analysis", 0x15uLL, a2);
  sub_1CCCB6410("basic-aa", 8uLL, a2);
  sub_1CCCB6410("cfl-anders-aa", 0xDuLL, a2);
  sub_1CCCB6410("cfl-steens-aa", 0xDuLL, a2);
  sub_1CCCB6410("objc-arc-aa", 0xBuLL, a2);
  sub_1CCCB6410("scev-aa", 7uLL, a2);
  sub_1CCCB6410("scoped-noalias-aa", 0x11uLL, a2);
  sub_1CCCB6410("tbaa", 4uLL, a2);
  int v13 = (void *)*((void *)a2 + 4);
  if (*((void *)a2 + 3) - (void)v13 > 0x18uLL)
  {
    qmemcpy(v13, "Function alias analyses:\n", 25);
    *((void *)a2 + 4) += 25;
  }
  else
  {
    llvm::raw_ostream::write(a2, "Function alias analyses:\n", 0x19uLL);
  }
  sub_1CCCB6410("basic-aa", 8uLL, a2);
  sub_1CCCB6410("cfl-anders-aa", 0xDuLL, a2);
  sub_1CCCB6410("cfl-steens-aa", 0xDuLL, a2);
  sub_1CCCB6410("objc-arc-aa", 0xBuLL, a2);
  sub_1CCCB6410("scev-aa", 7uLL, a2);
  sub_1CCCB6410("scoped-noalias-aa", 0x11uLL, a2);
  sub_1CCCB6410("tbaa", 4uLL, a2);
  uint64_t v14 = *((void *)a2 + 4);
  if ((unint64_t)(*((void *)a2 + 3) - v14) > 0x10)
  {
    *(unsigned char *)(v14 + 16) = 10;
    *(_OWORD *)uint64_t v14 = *(_OWORD *)"LoopNest passes:\n";
    *((void *)a2 + 4) += 17;
  }
  else
  {
    llvm::raw_ostream::write(a2, "LoopNest passes:\n", 0x11uLL);
  }
  sub_1CCCB6410("loop-flatten", 0xCuLL, a2);
  sub_1CCCB6410("loop-interchange", 0x10uLL, a2);
  sub_1CCCB6410("loop-unroll-and-jam", 0x13uLL, a2);
  sub_1CCCB6410("no-op-loopnest", 0xEuLL, a2);
  BOOL v15 = (void *)*((void *)a2 + 4);
  if (*((void *)a2 + 3) - (void)v15 > 0xCuLL)
  {
    qmemcpy(v15, "Loop passes:\n", 13);
    *((void *)a2 + 4) += 13;
  }
  else
  {
    llvm::raw_ostream::write(a2, "Loop passes:\n", 0xDuLL);
  }
  sub_1CCCB6410("canon-freeze", 0xCuLL, a2);
  sub_1CCCB6410("dot-ddg", 7uLL, a2);
  sub_1CCCB6410("invalidate<all>", 0xFuLL, a2);
  sub_1CCCB6410("loop-idiom", 0xAuLL, a2);
  sub_1CCCB6410("loop-instsimplify", 0x11uLL, a2);
  sub_1CCCB6410("loop-rotate", 0xBuLL, a2);
  sub_1CCCB6410("no-op-loop", 0xAuLL, a2);
  sub_1CCCB6410("print", 5uLL, a2);
  sub_1CCCB6410("loop-deletion", 0xDuLL, a2);
  sub_1CCCB6410("loop-simplifycfg", 0x10uLL, a2);
  sub_1CCCB6410("loop-reduce", 0xBuLL, a2);
  sub_1CCCB6410("indvars", 7uLL, a2);
  sub_1CCCB6410("loop-unroll-full", 0x10uLL, a2);
  sub_1CCCB6410("print-access-info", 0x11uLL, a2);
  sub_1CCCB6410("print<ddg>", 0xAuLL, a2);
  sub_1CCCB6410("print<iv-users>", 0xFuLL, a2);
  sub_1CCCB6410("print<loopnest>", 0xFuLL, a2);
  sub_1CCCB6410("print<loop-cache-cost>", 0x16uLL, a2);
  sub_1CCCB6410("loop-predication", 0x10uLL, a2);
  sub_1CCCB6410("guard-widening", 0xEuLL, a2);
  sub_1CCCB6410("loop-bound-split", 0x10uLL, a2);
  sub_1CCCB6410("loop-reroll", 0xBuLL, a2);
  sub_1CCCB6410("loop-versioning-licm", 0x14uLL, a2);
  int v16 = (void *)*((void *)a2 + 4);
  if (*((void *)a2 + 3) - (void)v16 > 0x18uLL)
  {
    qmemcpy(v16, "Loop passes with params:\n", 25);
    *((void *)a2 + 4) += 25;
  }
  else
  {
    llvm::raw_ostream::write(a2, "Loop passes with params:\n", 0x19uLL);
  }
  sub_1CCCB6514("simple-loop-unswitch", 0x14uLL, "nontrivial;no-nontrivial;trivial;no-trivial", 0x2BuLL, a2);
  sub_1CCCB6514("licm", 4uLL, "allowspeculation", 0x10uLL, a2);
  sub_1CCCB6514("lnicm", 5uLL, "allowspeculation", 0x10uLL, a2);
  uint64_t v17 = (void *)*((void *)a2 + 4);
  if (*((void *)a2 + 3) - (void)v17 > 0xEuLL)
  {
    qmemcpy(v17, "Loop analyses:\n", 15);
    *((void *)a2 + 4) += 15;
  }
  else
  {
    llvm::raw_ostream::write(a2, "Loop analyses:\n", 0xFuLL);
  }
  sub_1CCCB6410("no-op-loop", 0xAuLL, a2);
  sub_1CCCB6410("access-info", 0xBuLL, a2);
  sub_1CCCB6410("ddg", 3uLL, a2);
  sub_1CCCB6410("iv-users", 8uLL, a2);

  return sub_1CCCB6410("pass-instrumentation", 0x14uLL, a2);
}

llvm::raw_ostream *sub_1CCCB6410(const void *a1, size_t a2, llvm::raw_ostream *this)
{
  int v6 = (_WORD *)*((void *)this + 4);
  if (*((void *)this + 3) - (void)v6 > 1uLL)
  {
    *int v6 = 8224;
    uint64_t result = (llvm::raw_ostream *)(*((void *)this + 4) + 2);
    *((void *)this + 4) = result;
  }
  else
  {
    llvm::raw_ostream::write(this, "  ", 2uLL);
    uint64_t result = (llvm::raw_ostream *)*((void *)this + 4);
  }
  if (a2 <= *((void *)this + 3) - (void)result)
  {
    if (a2)
    {
      memcpy(result, a1, a2);
      uint64_t result = (llvm::raw_ostream *)(*((void *)this + 4) + a2);
      *((void *)this + 4) = result;
    }
  }
  else
  {
    llvm::raw_ostream::write(this, (const char *)a1, a2);
    uint64_t result = (llvm::raw_ostream *)*((void *)this + 4);
  }
  if (*((llvm::raw_ostream **)this + 3) == result)
  {
    return llvm::raw_ostream::write(this, "\n", 1uLL);
  }
  else
  {
    *(unsigned char *)uint64_t result = 10;
    ++*((void *)this + 4);
  }
  return result;
}

llvm::raw_ostream *sub_1CCCB6514(const void *a1, size_t a2, const void *a3, size_t a4, llvm::raw_ostream *this)
{
  uint64_t v10 = (_WORD *)*((void *)this + 4);
  if (*((void *)this + 3) - (void)v10 > 1uLL)
  {
    _WORD *v10 = 8224;
    int v11 = (unsigned char *)(*((void *)this + 4) + 2);
    *((void *)this + 4) = v11;
  }
  else
  {
    llvm::raw_ostream::write(this, "  ", 2uLL);
    int v11 = (unsigned char *)*((void *)this + 4);
  }
  if (a2 <= *((void *)this + 3) - (void)v11)
  {
    if (a2)
    {
      memcpy(v11, a1, a2);
      int v11 = (unsigned char *)(*((void *)this + 4) + a2);
      *((void *)this + 4) = v11;
    }
  }
  else
  {
    llvm::raw_ostream::write(this, (const char *)a1, a2);
    int v11 = (unsigned char *)*((void *)this + 4);
  }
  if (*((unsigned char **)this + 3) == v11)
  {
    llvm::raw_ostream::write(this, "<", 1uLL);
    uint64_t result = (llvm::raw_ostream *)*((void *)this + 4);
  }
  else
  {
    *int v11 = 60;
    uint64_t result = (llvm::raw_ostream *)(*((void *)this + 4) + 1);
    *((void *)this + 4) = result;
  }
  if (a4 <= *((void *)this + 3) - (void)result)
  {
    if (a4)
    {
      memcpy(result, a3, a4);
      uint64_t result = (llvm::raw_ostream *)(*((void *)this + 4) + a4);
      *((void *)this + 4) = result;
    }
  }
  else
  {
    llvm::raw_ostream::write(this, (const char *)a3, a4);
    uint64_t result = (llvm::raw_ostream *)*((void *)this + 4);
  }
  if (*((void *)this + 3) - (void)result > 1uLL)
  {
    *(_WORD *)uint64_t result = 2622;
    *((void *)this + 4) += 2;
  }
  else
  {
    return llvm::raw_ostream::write(this, ">\n", 2uLL);
  }
  return result;
}

uint64_t llvm::PassBuilder::registerParseTopLevelPipelineCallback(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 1352);
  unint64_t v5 = *(void *)(a1 + 1344);
  if (v4 >= *(_DWORD *)(a1 + 1356))
  {
    BOOL v8 = (unint64_t *)(a1 + 1344);
    unint64_t v9 = v4 + 1;
    unint64_t v10 = v5 + 32 * v4;
    if (v5 <= a2 && v10 > a2)
    {
      unint64_t v12 = a2 - v5;
      sub_1CCCC0D9C(a1 + 1344, v9);
      unint64_t v5 = *v8;
      a2 = *v8 + v12;
    }
    else
    {
      sub_1CCCC0D9C(a1 + 1344, v9);
      unint64_t v5 = *v8;
    }
  }
  unint64_t v6 = v5 + 32 * *(unsigned int *)(a1 + 1352);
  uint64_t result = *(void *)(a2 + 24);
  if (result)
  {
    if (result == a2)
    {
      *(void *)(v6 + 24) = v6;
      uint64_t result = (*(uint64_t (**)(void, unint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), v6);
    }
    else
    {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 16))(result);
      *(void *)(v6 + 24) = result;
    }
  }
  else
  {
    *(void *)(v6 + 24) = 0;
  }
  ++*(_DWORD *)(a1 + 1352);
  return result;
}

void sub_1CCCB67B8(void ***a1)
{
  uint64_t v1 = *a1;
  long long v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = *--v4;
        uint64_t v6 = v7;
        *uint64_t v4 = 0;
        if (v7) {
          (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
        }
      }
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1CCCB6860(uint64_t result)
{
  uint64_t v1 = *(void **)(result + 408);
  if (v1 != *(void **)(result + 400))
  {
    uint64_t v6 = result;
    free(v1);
    uint64_t result = v6;
  }
  long long v2 = *(void **)(result + 320);
  if (v2 != (void *)(result + 336))
  {
    uint64_t v7 = result;
    free(v2);
    uint64_t result = v7;
  }
  int v3 = *(void **)(result + 240);
  if (v3 != (void *)(result + 256))
  {
    uint64_t v8 = result;
    free(v3);
    uint64_t result = v8;
  }
  uint64_t v4 = *(void **)(result + 160);
  if (v4 != (void *)(result + 176))
  {
    uint64_t v9 = result;
    free(v4);
    uint64_t result = v9;
  }
  unint64_t v5 = *(void **)(result + 80);
  if (v5 != (void *)(result + 96))
  {
    uint64_t v10 = result;
    free(v5);
    uint64_t result = v10;
  }
  if (*(void *)result != result + 16)
  {
    uint64_t v11 = result;
    free(*(void **)result);
    return v11;
  }
  return result;
}

uint64_t sub_1CCCB6950(uint64_t result, uint64_t a2, unint64_t a3, const void *a4, size_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = (char *)result;
  uint64_t v27 = a2;
  unint64_t v28 = a3;
  v26[0] = a6;
  v26[1] = a7;
  if (a3)
  {
    unint64_t v10 = a3;
    uint64_t v11 = a2;
    do
    {
      LOBYTE(v20[0]) = 59;
      unint64_t v12 = llvm::StringRef::find(&v27, (char *)v20, 1uLL, 0);
      if (v10 >= v12) {
        unint64_t v13 = v12;
      }
      else {
        unint64_t v13 = v10;
      }
      if (v10 >= v12 + 1) {
        unint64_t v14 = v12 + 1;
      }
      else {
        unint64_t v14 = v10;
      }
      uint64_t v15 = v11 + v14;
      unint64_t v16 = v10 - v14;
      BOOL v17 = v12 == -1;
      uint64_t result = v11;
      if (v17)
      {
        unint64_t v13 = v10;
        uint64_t v11 = 0;
      }
      else
      {
        uint64_t v11 = v15;
      }
      v25[0] = result;
      v25[1] = v13;
      if (v17) {
        unint64_t v10 = 0;
      }
      else {
        unint64_t v10 = v16;
      }
      uint64_t v27 = v11;
      unint64_t v28 = v10;
      if (v13 == a5)
      {
        if (!a5) {
          continue;
        }
        uint64_t result = memcmp((const void *)result, a4, a5);
        if (!result) {
          continue;
        }
      }
      v20[0] = "invalid {1} pass parameter '{0}' ";
      v20[1] = 33;
      void v20[2] = v23;
      _DWORD v20[3] = 2;
      v21[0] = &unk_1F2617F90;
      v21[1] = v25;
      v22[0] = &unk_1F2617F90;
      v22[1] = v26;
      v23[0] = v21;
      v23[1] = v22;
      sub_1CD465B2C((uint64_t)v20, &__p);
      llvm::inconvertibleErrorCode(v19);
      operator new();
    }
    while (v10);
    char v18 = 1;
  }
  else
  {
    char v18 = 0;
  }
  v7[8] &= ~1u;
  *uint64_t v7 = v18;
  return result;
}

void sub_1CCCB6B44(void ***a1)
{
  uint64_t v1 = *a1;
  long long v2 = (char **)**a1;
  if (v2)
  {
    uint64_t v4 = (char **)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = v4 - 675;
        sub_1CD719C14(v4 - 674);
        uint64_t v4 = v6;
      }
      while (v6 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1CCCB6BE0(void ***a1)
{
  uint64_t v1 = *a1;
  long long v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = v4 - 32;
        uint64_t v7 = (void **)(v4 - 24);
        sub_1CCCB6C5C(&v7);
        uint64_t v4 = v6;
      }
      while (v6 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1CCCB6C5C(void ***a1)
{
  uint64_t v1 = *a1;
  long long v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = (char *)*((void *)v4 - 21);
        v4 -= 168;
        uint64_t v6 = v7;
        if (v4 + 16 != v7) {
          free(v6);
        }
      }
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1CCCB6CE8(void ***a1)
{
  uint64_t v1 = *a1;
  long long v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        if (*((_DWORD *)v4 - 2) >= 0x41u)
        {
          uint64_t v6 = *((void *)v4 - 2);
          if (v6) {
            MEMORY[0x1D25D9CB0](v6, 0x1000C8000313F17);
          }
        }
        if (*((_DWORD *)v4 - 6) >= 0x41u)
        {
          uint64_t v7 = *((void *)v4 - 4);
          if (v7) {
            MEMORY[0x1D25D9CB0](v7, 0x1000C8000313F17);
          }
        }
        v4 -= 40;
      }
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *sub_1CCCB6DC0(void *a1)
{
  for (uint64_t i = 66; i != 12; i -= 3)
  {
    sub_1CCCB6E34((uint64_t)&a1[i]);
    MEMORY[0x1D25D9CD0](a1[i], 8);
  }
  sub_1CCCB7040(a1 + 6);
  MEMORY[0x1D25D9CD0](a1[3], 8);
  MEMORY[0x1D25D9CD0](*a1, 8);
  return a1;
}

uint64_t sub_1CCCB6E34(uint64_t result)
{
  unsigned int v1 = *(_DWORD *)(result + 16);
  if (v1)
  {
    long long v2 = *(void **)result;
    uint64_t v3 = *(void *)result + 72 * v1;
    do
    {
      uint64_t v4 = v2[1];
      if ((*v2 != -4096 || v4 != -4096) && (*v2 != -8192 || v4 != -8192))
      {
        uint64_t v5 = v2[7];
        if (v5 && v5 != -8192 && v5 != -4096)
        {
          unint64_t v6 = v2[5] & 0xFFFFFFFFFFFFFFF8;
          *(void *)unint64_t v6 = v2[6];
          uint64_t v7 = (unint64_t *)v2[6];
          if (v7)
          {
            *uint64_t v7 = *v7 & 7 | v6;
          }
          else
          {
            uint64_t v8 = v2[7];
            uint64_t v9 = ***(int32x2_t ****)v8;
            unint64_t v10 = (unint64_t)v9[303];
            if (v10 <= v6)
            {
              uint64_t v11 = v9[305].u32[0];
              if (v10 + 16 * v11 > v6)
              {
                unsigned int v12 = v11 - 1;
                LODWORD(v13) = v12 & ((v8 >> 4) ^ (v8 >> 9));
                unint64_t v14 = (uint64_t *)(v10 + 16 * v13);
                uint64_t v15 = *v14;
                if (v8 == *v14)
                {
LABEL_20:
                  *unint64_t v14 = -8192;
                  v9[304] = vadd_s32(v9[304], (int32x2_t)0x1FFFFFFFFLL);
                  uint64_t v8 = v2[7];
                }
                else
                {
                  int v16 = 1;
                  while (v15 != -4096)
                  {
                    int v17 = v13 + v16++;
                    uint64_t v13 = v17 & v12;
                    uint64_t v15 = *(void *)(v10 + 16 * v13);
                    if (v8 == v15)
                    {
                      unint64_t v14 = (uint64_t *)(v10 + 16 * v13);
                      goto LABEL_20;
                    }
                  }
                }
                *(unsigned char *)(v8 + 17) &= ~1u;
              }
            }
          }
        }
        uint64_t v18 = v2[4];
        if (v18 && v18 != -8192 && v18 != -4096)
        {
          unint64_t v19 = v2[2] & 0xFFFFFFFFFFFFFFF8;
          *(void *)unint64_t v19 = v2[3];
          BOOL v20 = (unint64_t *)v2[3];
          if (v20)
          {
            *BOOL v20 = *v20 & 7 | v19;
          }
          else
          {
            uint64_t v21 = v2[4];
            BOOL v22 = ***(int32x2_t ****)v21;
            unint64_t v23 = (unint64_t)v22[303];
            if (v23 <= v19)
            {
              uint64_t v24 = v22[305].u32[0];
              if (v23 + 16 * v24 > v19)
              {
                unsigned int v25 = v24 - 1;
                LODWORD(v26) = v25 & ((v21 >> 4) ^ (v21 >> 9));
                uint64_t v27 = (uint64_t *)(v23 + 16 * v26);
                uint64_t v28 = *v27;
                if (v21 == *v27)
                {
LABEL_34:
                  *uint64_t v27 = -8192;
                  v22[304] = vadd_s32(v22[304], (int32x2_t)0x1FFFFFFFFLL);
                  uint64_t v21 = v2[4];
                }
                else
                {
                  int v29 = 1;
                  while (v28 != -4096)
                  {
                    int v30 = v26 + v29++;
                    uint64_t v26 = v30 & v25;
                    uint64_t v28 = *(void *)(v23 + 16 * v26);
                    if (v21 == v28)
                    {
                      uint64_t v27 = (uint64_t *)(v23 + 16 * v26);
                      goto LABEL_34;
                    }
                  }
                }
                *(unsigned char *)(v21 + 17) &= ~1u;
              }
            }
          }
        }
      }
      v2 += 9;
    }
    while (v2 != (void *)v3);
  }
  return result;
}

void *sub_1CCCB7040(void *a1)
{
  return a1;
}

uint64_t sub_1CCCB7078(uint64_t a1)
{
  long long v2 = *(void ***)(a1 + 8);
  uint64_t v3 = *(void ***)(a1 + 16);
  *(void *)(a1 + 40) = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = *(void ***)(a1 + 16);
      long long v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v10 = 256;
LABEL_12:
    *(void *)(a1 + 32) = v10;
    goto LABEL_4;
  }
  if (v5 == 2)
  {
    uint64_t v10 = 512;
    goto LABEL_12;
  }
LABEL_4:
  if (v2 != v3)
  {
    do
    {
      unint64_t v6 = *v2++;
      operator delete(v6);
    }
    while (v2 != v3);
    uint64_t v8 = *(void *)(a1 + 8);
    uint64_t v7 = *(void *)(a1 + 16);
    if (v7 != v8) {
      *(void *)(a1 + 16) = v7 + ((v8 - v7 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1CCCB7148(uint64_t a1)
{
  long long v2 = *(void **)(a1 + 672);
  if (v2 != (void *)(a1 + 688)) {
    free(v2);
  }
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 648), 8);
  uint64_t v3 = *(void **)(a1 + 616);
  if (v3 != (void *)(a1 + 632)) {
    free(v3);
  }
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 592), 8);
  unint64_t v4 = *(void **)(a1 + 568);
  if (v4)
  {
    *(void *)(a1 + 576) = v4;
    operator delete(v4);
  }
  unint64_t v5 = *(void **)(a1 + 424);
  if (v5 != (void *)(a1 + 440)) {
    free(v5);
  }
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 400), 8);
  sub_1CC0BDE04((char **)(a1 + 192));
  unint64_t v6 = *(void **)(a1 + 48);
  if (v6 != (void *)(a1 + 64)) {
    free(v6);
  }
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 24), 8);
  return a1;
}

void sub_1CCCB7218(void ***a1)
{
  unsigned int v1 = *a1;
  long long v2 = (char *)**a1;
  if (v2)
  {
    unint64_t v4 = (char *)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        unint64_t v6 = (char *)*((void *)v4 - 18);
        if (v4 - 128 != v6) {
          free(v6);
        }
        v4 -= 152;
      }
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1CCCB72A8(uint64_t a1)
{
  long long v2 = *(void **)(a1 + 696);
  if (v2 != (void *)(a1 + 712)) {
    free(v2);
  }
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 664), 8);
  uint64_t v3 = *(void **)(a1 + 584);
  if (v3 != (void *)(a1 + 600)) {
    free(v3);
  }
  unint64_t v4 = *(void **)(a1 + 504);
  if (v4 != (void *)(a1 + 520)) {
    free(v4);
  }
  if ((*(unsigned char *)(a1 + 432) & 1) == 0) {
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 440), 8);
  }
  sub_1CBFFBA64(a1 + 336);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 312), 8);
  llvm::GVNPass::ValueTable::~ValueTable((llvm::GVNPass::ValueTable *)(a1 + 128));
  sub_1CC189978((void *)(a1 + 48));
  return a1;
}

void sub_1CCCB735C(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
}

uint64_t sub_1CCCB7368()
{
  return 1;
}

char *sub_1CCCB7370()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::PassManager<Loop, LoopAnalysisManager, LoopSt"
                    "andardAnalysisResults &, LPMUpdater &>]";
  v10[1] = 139;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x8B) {
    uint64_t v1 = 139;
  }
  else {
    uint64_t v1 = v0;
  }
  long long v2 = &aStringrefLlvmG_19[v1];
  unint64_t v3 = 139 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

void **sub_1CCCB742C(void **a1)
{
  unint64_t v3 = a1 + 12;
  sub_1CCCB7490(&v3);
  unint64_t v3 = a1 + 9;
  sub_1CCCB7538(&v3);
  if (*a1 != a1 + 2) {
    free(*a1);
  }
  return a1;
}

void sub_1CCCB7490(void ***a1)
{
  uint64_t v1 = *a1;
  long long v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = *--v4;
        uint64_t v6 = v7;
        *uint64_t v4 = 0;
        if (v7) {
          (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
        }
      }
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1CCCB7538(void ***a1)
{
  uint64_t v1 = *a1;
  long long v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = *--v4;
        uint64_t v6 = v7;
        *uint64_t v4 = 0;
        if (v7) {
          (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
        }
      }
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

char *sub_1CCCB75E0(char **a1, void *a2)
{
  uint64_t v2 = (a1[1] - *a1) >> 3;
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 61) {
    abort();
  }
  uint64_t v6 = a1[2] - *a1;
  if (v6 >> 2 > v3) {
    unint64_t v3 = v6 >> 2;
  }
  if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v7 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v7 = v3;
  }
  uint64_t v21 = a1 + 2;
  if (v7)
  {
    if (v7 >> 61) {
      sub_1CB833614();
    }
    uint64_t v8 = (char *)operator new(8 * v7);
  }
  else
  {
    uint64_t v8 = 0;
  }
  uint64_t v9 = &v8[8 * v2];
  uint64_t v10 = &v8[8 * v7];
  *(void *)uint64_t v9 = *a2;
  uint64_t v11 = v9 + 8;
  *a2 = 0;
  v19.i64[1] = (uint64_t)(v9 + 8);
  BOOL v20 = v10;
  uint64_t v13 = *a1;
  unsigned int v12 = a1[1];
  if (v12 == *a1)
  {
    int64x2_t v15 = vdupq_n_s64((unint64_t)v12);
  }
  else
  {
    do
    {
      uint64_t v14 = *((void *)v12 - 1);
      v12 -= 8;
      *(void *)unsigned int v12 = 0;
      *((void *)v9 - 1) = v14;
      v9 -= 8;
    }
    while (v12 != v13);
    int64x2_t v15 = *(int64x2_t *)a1;
    uint64_t v11 = (char *)v19.i64[1];
    uint64_t v10 = v20;
  }
  *a1 = v9;
  a1[1] = v11;
  int64x2_t v19 = v15;
  int v16 = a1[2];
  a1[2] = v10;
  BOOL v20 = v16;
  uint64_t v18 = v15.i64[0];
  sub_1CCCB76EC((uint64_t)&v18);
  return v11;
}

uint64_t sub_1CCCB76EC(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    uint64_t v4 = *(void *)(i - 8);
    *(void *)(i - 8) = 0;
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1CCCB7768()
{
}

uint64_t sub_1CCCB7774()
{
  return 0;
}

void sub_1CCCB777C()
{
}

uint64_t sub_1CCCB7788()
{
  return 0;
}

void sub_1CCCB7790(uint64_t a1, llvm::Module *a2)
{
  llvm::CallGraph::CallGraph((llvm::CallGraph *)&v2, a2);
}

void sub_1CCCB7824(void *a1)
{
  *a1 = &unk_1F2634720;
  llvm::CallGraph::~CallGraph((llvm::CallGraph *)(a1 + 1));

  JUMPOUT(0x1D25D9CE0);
}

BOOL sub_1CCCB7888(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return llvm::CallGraph::invalidate(a1 + 8, a2, a3);
}

void sub_1CCCB7890()
{
}

void sub_1CCCB78FC()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_1CCCB79B8()
{
}

uint64_t sub_1CCCB79E4(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 616);
  if (v2 != (void *)(a1 + 632)) {
    free(v2);
  }
  if ((*(unsigned char *)(a1 + 576) & 1) == 0) {
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 584), 8);
  }
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 552), 8);
  uint64_t v3 = *(void **)(a1 + 408);
  if (v3 != (void *)(a1 + 424)) {
    free(v3);
  }
  sub_1CCCB7ABC(a1 + 312);
  sub_1CBFFBA64(a1 + 312);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 288), 8);
  sub_1CCCB7C68(a1 + 192);
  sub_1CBFFBA64(a1 + 192);
  sub_1CCCB7DD0(a1 + 120);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 96), 8);
  sub_1CCCB7E18(a1);

  return sub_1CBFFBA64(a1);
}

uint64_t sub_1CCCB7ABC(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 24);
  if (v1)
  {
    uint64_t v2 = *(void **)(a1 + 16);
    uint64_t v3 = &v2[v1];
    do
    {
      uint64_t v4 = *(void *)(a1 + 16);
      uint64_t v5 = *v2;
      if (*v2 == *(void *)(v4 + 8 * *(unsigned int *)(a1 + 24) - 8))
      {
        unint64_t v7 = *(void *)a1;
      }
      else
      {
        uint64_t v6 = (((unint64_t)v2 - v4) >> 10) & 0x1FFFFFF;
        if (v6 >= 0x1E) {
          LOBYTE(v6) = 30;
        }
        unint64_t v7 = v5 + (4096 << v6);
      }
      for (unint64_t i = ((v5 + 7) & 0xFFFFFFFFFFFFFFF8) + 128; i <= v7; i += 128)
      {
        if ((*(unsigned char *)(i - 72) & 1) == 0)
        {
          uint64_t v11 = a1;
          unsigned int v12 = v2;
          uint64_t v13 = v3;
          MEMORY[0x1D25D9CD0](*(void *)(i - 64), 8);
          uint64_t v3 = v13;
          uint64_t v2 = v12;
          a1 = v11;
        }
        if (i - 104 != *(void *)(i - 120))
        {
          uint64_t v14 = a1;
          int64x2_t v15 = v2;
          int v16 = v3;
          free(*(void **)(i - 120));
          uint64_t v3 = v16;
          uint64_t v2 = v15;
          a1 = v14;
        }
      }
      ++v2;
    }
    while (v2 != v3);
  }
  uint64_t v9 = *(unsigned int *)(a1 + 72);
  if (v9)
  {
    int v17 = *(void **)(a1 + 64);
    uint64_t v18 = &v17[2 * v9];
    do
    {
      uint64_t v19 = a1;
      unint64_t v20 = *v17 + v17[1];
      for (unint64_t j = ((*v17 + 7) & 0xFFFFFFFFFFFFFFF8) + 128; j <= v20; j += 128)
      {
        if ((*(unsigned char *)(j - 72) & 1) == 0) {
          MEMORY[0x1D25D9CD0](*(void *)(j - 64), 8);
        }
        BOOL v22 = *(void **)(j - 120);
        if ((void *)(j - 104) != v22) {
          free(v22);
        }
      }
      v17 += 2;
      a1 = v19;
    }
    while (v17 != v18);
  }

  return sub_1CBFFBB10(a1);
}

uint64_t sub_1CCCB7C68(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 24);
  if (v1)
  {
    uint64_t v4 = *(void **)(a1 + 16);
    uint64_t v5 = &v4[v1];
    do
    {
      uint64_t v6 = *(void *)(a1 + 16);
      uint64_t v7 = *v4;
      if (*v4 == *(void *)(v6 + 8 * *(unsigned int *)(a1 + 24) - 8))
      {
        unint64_t v8 = *(void *)a1;
      }
      else
      {
        uint64_t v12 = (((unint64_t)v4 - v6) >> 10) & 0x1FFFFFF;
        if (v12 >= 0x1E) {
          LOBYTE(v12) = 30;
        }
        unint64_t v8 = v7 + (4096 << v12);
      }
      unint64_t v9 = (v7 + 7) & 0xFFFFFFFFFFFFFFF8;
      if (v9 + 32 <= v8)
      {
        unint64_t v10 = v9 + 24;
        do
        {
          if (v10 != *(void *)(v10 - 16))
          {
            uint64_t v13 = a1;
            uint64_t v14 = v4;
            int64x2_t v15 = v5;
            free(*(void **)(v10 - 16));
            uint64_t v5 = v15;
            uint64_t v4 = v14;
            a1 = v13;
          }
          unint64_t v11 = v10 + 40;
          v10 += 32;
        }
        while (v11 <= v8);
      }
      ++v4;
    }
    while (v4 != v5);
  }
  uint64_t v2 = *(unsigned int *)(a1 + 72);
  if (v2)
  {
    int v16 = *(void **)(a1 + 64);
    int v17 = &v16[2 * v2];
    do
    {
      uint64_t v18 = a1;
      unint64_t v19 = (*v16 + 7) & 0xFFFFFFFFFFFFFFF8;
      unint64_t v20 = *v16 + v16[1];
      if (v19 + 32 <= v20)
      {
        uint64_t v21 = (void *)(v19 + 24);
        do
        {
          BOOL v22 = (void *)*(v21 - 2);
          if (v21 != v22) {
            free(v22);
          }
          unint64_t v23 = (unint64_t)(v21 + 5);
          v21 += 4;
        }
        while (v23 <= v20);
      }
      v16 += 2;
      a1 = v18;
    }
    while (v16 != v17);
  }

  return sub_1CBFFBB10(a1);
}

uint64_t sub_1CCCB7DD0(uint64_t a1)
{
  if (*(void *)a1 != a1 + 16) {
    free(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1CCCB7E18(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 24);
  if (v2)
  {
    uint64_t v5 = *(uint64_t **)(a1 + 16);
    uint64_t v6 = &v5[v2];
    do
    {
      uint64_t v7 = *(void *)(a1 + 16);
      uint64_t v8 = *v5;
      if (*v5 == *(void *)(v7 + 8 * *(unsigned int *)(a1 + 24) - 8))
      {
        unint64_t v10 = *(void *)a1;
      }
      else
      {
        uint64_t v9 = (((unint64_t)v5 - v7) >> 10) & 0x1FFFFFF;
        if (v9 >= 0x1E) {
          LOBYTE(v9) = 30;
        }
        unint64_t v10 = v8 + (4096 << v9);
      }
      for (unint64_t i = ((v8 + 7) & 0xFFFFFFFFFFFFFFF8) + 104; i <= v10; i += 104)
      {
        if (*(unsigned char *)(i - 8))
        {
          MEMORY[0x1D25D9CD0](*(void *)(i - 32), 8);
          uint64_t v12 = *(void **)(i - 80);
          if ((void *)(i - 64) != v12) {
            free(v12);
          }
          *(unsigned char *)(i - 8) = 0;
        }
      }
      ++v5;
    }
    while (v5 != v6);
  }
  uint64_t v3 = *(unsigned int *)(a1 + 72);
  if (v3)
  {
    uint64_t v13 = *(void **)(a1 + 64);
    uint64_t v14 = &v13[2 * v3];
    do
    {
      unint64_t v15 = *v13 + v13[1];
      for (unint64_t j = ((*v13 + 7) & 0xFFFFFFFFFFFFFFF8) + 104; j <= v15; j += 104)
      {
        if (*(unsigned char *)(j - 8))
        {
          sub_1CCCB7DD0(j - 80);
          *(unsigned char *)(j - 8) = 0;
        }
      }
      v13 += 2;
    }
    while (v13 != v14);
  }

  return sub_1CBFFBB10(a1);
}

void sub_1CCCB7F70()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_1CCCB8030()
{
}

void sub_1CCCB8044()
{
}

const char *sub_1CCCB809C()
{
  return "NoOpModuleAnalysis";
}

void sub_1CCCB80B0()
{
}

BOOL sub_1CCCB80C4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v18[0] = (void **)a3;
  v18[1] = (void **)&unk_1EA61DEE8;
  uint64_t v4 = *(void *)(a3 + 48);
  uint64_t v3 = *(void *)(a3 + 56);
  if (v3 == v4)
  {
    uint64_t v5 = *(unsigned int *)(a3 + 68);
    uint64_t v6 = (void **)(v3 + 8 * v5);
    if (v5)
    {
      uint64_t v7 = 0;
      while (*(_UNKNOWN **)(v3 + v7) != &unk_1EA61DEE8)
      {
        v7 += 8;
        if (8 * v5 == v7) {
          goto LABEL_19;
        }
      }
      uint64_t v6 = (void **)(v3 + v7);
    }
LABEL_19:
    uint64_t v4 = *(void *)(a3 + 56);
  }
  else
  {
    uint64_t v8 = *(unsigned int *)(a3 + 64);
    int v9 = v8 - 1;
    unsigned int v10 = (v8 - 1) & ((&unk_1EA61DEE8 >> 4) ^ (&unk_1EA61DEE8 >> 9));
    uint64_t v6 = (void **)(v3 + 8 * v10);
    unint64_t v11 = *v6;
    if (*v6 == (void *)-1)
    {
      uint64_t v12 = 0;
LABEL_21:
      if (v12) {
        uint64_t v6 = v12;
      }
      if (*v6 != &unk_1EA61DEE8)
      {
        LODWORD(v5) = *(_DWORD *)(a3 + 68);
        uint64_t v6 = (void **)(v3 + 8 * v8);
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v12 = 0;
      int v13 = 1;
      while (v11 != &unk_1EA61DEE8)
      {
        if (v12) {
          BOOL v14 = 0;
        }
        else {
          BOOL v14 = v11 == (void *)-2;
        }
        if (v14) {
          uint64_t v12 = v6;
        }
        unsigned int v15 = v10 + v13++;
        unsigned int v10 = v15 & v9;
        uint64_t v6 = (void **)(v3 + 8 * (v15 & v9));
        unint64_t v11 = *v6;
        if (*v6 == (void *)-1) {
          goto LABEL_21;
        }
      }
    }
    LODWORD(v5) = *(_DWORD *)(a3 + 68);
  }
LABEL_26:
  if (v3 == v4) {
    unsigned int v16 = v5;
  }
  else {
    unsigned int v16 = *(_DWORD *)(a3 + 64);
  }
  BOOL v19 = v6 != (void **)(v3 + 8 * v16);
  return !sub_1CBF75724(v18) && !sub_1CBFA10B0((uint64_t)v18);
}

void sub_1CCCB81FC(uint64_t a1, unint64_t a2)
{
  long long v2 = a2;
  char v3 = 0;
  char v4 = 0;
  char v5 = 0;
  char v6 = 0;
  int v7 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  int v10 = 0;
  llvm::ProfileSummaryInfo::refresh((uint64_t)&v2);
  operator new();
}

void sub_1CCCB8300(void *a1)
{
  *a1 = &unk_1F26348D8;
  MEMORY[0x1D25D9CD0](a1[8], 8);
  uint64_t v2 = a1[2];
  a1[2] = 0;
  if (v2) {
    sub_1CC025ED8((uint64_t)(a1 + 2), v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CCCB8380()
{
  return 0;
}

void sub_1CCCB8388()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_1CCCB8444()
{
}

void sub_1CCCB84A0()
{
}

uint64_t sub_1CCCB84B4()
{
  return 0;
}

void sub_1CCCB84BC()
{
}

void *sub_1CCCB854C(void *a1)
{
  *a1 = &unk_1F2634A38;
  MEMORY[0x1D25D9CD0](a1[1], 8);
  return a1;
}

void sub_1CCCB8598(void *a1)
{
  *a1 = &unk_1F2634A38;
  MEMORY[0x1D25D9CD0](a1[1], 8);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCCB8604()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_1CCCB86C0()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void *sub_1CCCB877C(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  char v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD71B548(a1, v4, &v4[2 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      void *result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

void sub_1CCCB884C()
{
}

void sub_1CCCB8860()
{
}

const char *sub_1CCCB88B8()
{
  return "NoOpCGSCCAnalysis";
}

void sub_1CCCB88CC()
{
}

BOOL sub_1CCCB88E0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v18[0] = (void **)a3;
  v18[1] = (void **)&unk_1EA61DEF0;
  uint64_t v4 = *(void *)(a3 + 48);
  uint64_t v3 = *(void *)(a3 + 56);
  if (v3 == v4)
  {
    uint64_t v5 = *(unsigned int *)(a3 + 68);
    unint64_t v6 = (void **)(v3 + 8 * v5);
    if (v5)
    {
      uint64_t v7 = 0;
      while (*(_UNKNOWN **)(v3 + v7) != &unk_1EA61DEF0)
      {
        v7 += 8;
        if (8 * v5 == v7) {
          goto LABEL_19;
        }
      }
      unint64_t v6 = (void **)(v3 + v7);
    }
LABEL_19:
    uint64_t v4 = *(void *)(a3 + 56);
  }
  else
  {
    uint64_t v8 = *(unsigned int *)(a3 + 64);
    int v9 = v8 - 1;
    unsigned int v10 = (v8 - 1) & ((&unk_1EA61DEF0 >> 4) ^ (&unk_1EA61DEF0 >> 9));
    unint64_t v6 = (void **)(v3 + 8 * v10);
    uint64_t v11 = *v6;
    if (*v6 == (void *)-1)
    {
      uint64_t v12 = 0;
LABEL_21:
      if (v12) {
        unint64_t v6 = v12;
      }
      if (*v6 != &unk_1EA61DEF0)
      {
        LODWORD(v5) = *(_DWORD *)(a3 + 68);
        unint64_t v6 = (void **)(v3 + 8 * v8);
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v12 = 0;
      int v13 = 1;
      while (v11 != &unk_1EA61DEF0)
      {
        if (v12) {
          BOOL v14 = 0;
        }
        else {
          BOOL v14 = v11 == (void *)-2;
        }
        if (v14) {
          uint64_t v12 = v6;
        }
        unsigned int v15 = v10 + v13++;
        unsigned int v10 = v15 & v9;
        unint64_t v6 = (void **)(v3 + 8 * (v15 & v9));
        uint64_t v11 = *v6;
        if (*v6 == (void *)-1) {
          goto LABEL_21;
        }
      }
    }
    LODWORD(v5) = *(_DWORD *)(a3 + 68);
  }
LABEL_26:
  if (v3 == v4) {
    unsigned int v16 = v5;
  }
  else {
    unsigned int v16 = *(_DWORD *)(a3 + 64);
  }
  BOOL v19 = v6 != (void **)(v3 + 8 * v16);
  return !sub_1CBF75724(v18) && !sub_1CD46D7A4((uint64_t)v18);
}

void sub_1CCCB8A18()
{
}

void sub_1CCCB8AA8()
{
}

uint64_t sub_1CCCB8ABC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return llvm::FunctionAnalysisManagerCGSCCProxy::Result::invalidate(a1 + 8, a2, a3);
}

void sub_1CCCB8AC4()
{
}

void sub_1CCCB8B20()
{
}

uint64_t sub_1CCCB8B34()
{
  return 0;
}

void sub_1CCCB8B3C()
{
  llvm::BlockFrequencyAnalysis::run(&v0);
}

void sub_1CCCB8BAC(void *a1)
{
  uint64_t v2 = a1[1];
  *a1 = &unk_1F2634CA0;
  a1[1] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

BOOL sub_1CCCB8C38(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return llvm::BlockFrequencyInfo::invalidate(a1 + 8, a2, a3);
}

void sub_1CCCB8C40()
{
  uint64_t v1 = *MEMORY[0x1E4F143B8];
  llvm::BranchProbabilityAnalysis::run((uint64_t)v0);
}

uint64_t sub_1CCCB8D0C(uint64_t result, uint64_t a2)
{
  *(void *)uint64_t result = 0;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  *(void *)(result + 32) = 0;
  *(_DWORD *)(result + 40) = 0;
  *(void *)(result + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = 0;
  *(_DWORD *)(result + 32) = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a2 + 32) = 0;
  int v2 = *(_DWORD *)(result + 36);
  *(_DWORD *)(result + 36) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a2 + 36) = v2;
  int v3 = *(_DWORD *)(result + 40);
  *(_DWORD *)(result + 40) = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a2 + 40) = v3;
  uint64_t v4 = *(void *)(a2 + 48);
  *(void *)(result + 72) = 1;
  uint64_t v5 = result + 72;
  *(void *)(result + 56) = 0;
  *(void *)(result + 64) = 0;
  *(void *)(result + 48) = v4;
  for (uint64_t i = 80; i != 144; i += 16)
    *(void *)(result + i) = -4096;
  int v7 = *(_DWORD *)(a2 + 72);
  *(_DWORD *)(a2 + 72) = *(_DWORD *)(result + 72) & 0xFFFFFFFE | v7 & 1;
  int v8 = *(_DWORD *)(result + 76);
  *(_DWORD *)(result + 72) = v7 & 0xFFFFFFFE | *(_DWORD *)(result + 72) & 1;
  *(_DWORD *)(result + 76) = *(_DWORD *)(a2 + 76);
  *(_DWORD *)(a2 + 76) = v8;
  int v9 = *(_DWORD *)(result + 72);
  int v10 = *(_DWORD *)(a2 + 72);
  if (v9)
  {
    int v9 = *(_DWORD *)(a2 + 72);
    uint64_t v11 = a2 + 72;
    if ((v10 & 1) == 0) {
      goto LABEL_7;
    }
    uint64_t v16 = 0;
    while (1)
    {
      uint64_t v17 = result + v16;
      uint64_t v18 = a2 + v16;
      uint64_t v19 = *(void *)(result + v16 + 80);
      uint64_t v20 = *(void *)(a2 + v16 + 80);
      if (v19 == -4096 || v19 == -8192 || v20 == -4096 || v20 == -8192)
      {
        *(void *)(v17 + 80) = v20;
        *(void *)(v18 + 80) = v19;
        if ((v19 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          uint64_t v22 = a2 + v16;
          uint64_t v23 = result + v16;
          goto LABEL_27;
        }
        if ((v20 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          uint64_t v22 = result + v16;
          uint64_t v23 = a2 + v16;
LABEL_27:
          *(_DWORD *)(v22 + 88) = *(_DWORD *)(v23 + 88);
        }
      }
      else
      {
        int v21 = *(_DWORD *)(result + v16 + 88);
        *(void *)(v17 + 80) = v20;
        *(_DWORD *)(result + v16 + 88) = *(_DWORD *)(a2 + v16 + 88);
        *(void *)(v18 + 80) = v19;
        *(_DWORD *)(a2 + v16 + 88) = v21;
      }
      v16 += 16;
      if (v16 == 64) {
        goto LABEL_12;
      }
    }
  }
  uint64_t v11 = result + 72;
  uint64_t v5 = a2 + 72;
  if ((v10 & 1) == 0)
  {
    uint64_t v12 = *(void *)(result + 80);
    *(void *)(result + 80) = *(void *)(a2 + 80);
    *(void *)(a2 + 80) = v12;
    LODWORD(v12) = *(_DWORD *)(result + 88);
    *(_DWORD *)(result + 88) = *(_DWORD *)(a2 + 88);
    *(_DWORD *)(a2 + 88) = v12;
    goto LABEL_12;
  }
LABEL_7:
  uint64_t v13 = 0;
  long long v24 = *(_OWORD *)(v11 + 8);
  *(_DWORD *)uint64_t v11 = v9 | 1;
  do
  {
    uint64_t v14 = *(void *)(v5 + v13 + 8);
    *(void *)(v11 + v13 + 8) = v14;
    if ((v14 | 0x1000) != 0xFFFFFFFFFFFFF000) {
      *(_DWORD *)(v11 + v13 + 16) = *(_DWORD *)(v5 + v13 + 16);
    }
    v13 += 16;
  }
  while (v13 != 64);
  *(_DWORD *)v5 &= ~1u;
  *(_OWORD *)(v5 + 8) = v24;
LABEL_12:
  *(void *)(result + 144) = 1;
  for (uint64_t j = 152; j != 248; j += 24)
    *(_OWORD *)(result + j) = xmmword_1CFAC30D0;
  return result;
}

void sub_1CCCB8F28(void *a1)
{
  *a1 = &unk_1F2634CF8;
  sub_1CBF8AF10((uint64_t)(a1 + 1));

  JUMPOUT(0x1D25D9CE0);
}

BOOL sub_1CCCB8F8C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return llvm::BranchProbabilityInfo::invalidate(a1 + 8, a2, a3);
}

void sub_1CCCB8F94()
{
}

void sub_1CCCB9084(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  v2[0] = v3;
  v2[1] = (void *)0x400000000;
  int v8 = 0;
  v3[4] = 0;
  v3[5] = 0;
  int v4 = 0;
  char v7 = 0;
  uint64_t v5 = 0;
  uint64_t v6 = a2;
  sub_1CC5A46F8((uint64_t)v2, 0);
  operator new();
}

void *sub_1CCCB91B0(void *a1)
{
  *a1 = &unk_1F2634DA8;
  sub_1CBF8FF88(a1 + 7);
  int v2 = (void *)a1[1];
  if (v2 != a1 + 3) {
    free(v2);
  }
  return a1;
}

void sub_1CCCB9208(void *a1)
{
  *a1 = &unk_1F2634DA8;
  sub_1CBF8FF88(a1 + 7);
  int v2 = (void *)a1[1];
  if (v2 != a1 + 3) {
    free(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

BOOL sub_1CCCB9280(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return llvm::PostDominatorTree::invalidate(a1 + 8, a2, a3);
}

void sub_1CCCB9288()
{
}

void sub_1CCCB9638(void *a1)
{
  *a1 = &unk_1F2634E00;
  int v2 = (void *)a1[45];
  if (v2 != (void *)a1[44]) {
    free(v2);
  }
  sub_1CBFD5898((uint64_t)(a1 + 41));
  MEMORY[0x1D25D9CD0](a1[41], 8);
  int v3 = (void *)a1[6];
  if (v3 != (void *)a1[5]) {
    free(v3);
  }

  JUMPOUT(0x1D25D9CE0);
}

BOOL sub_1CCCB96D8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v18[0] = (void **)a3;
  v18[1] = (void **)&llvm::DemandedBitsAnalysis::Key;
  uint64_t v4 = *(void *)(a3 + 48);
  uint64_t v3 = *(void *)(a3 + 56);
  if (v3 == v4)
  {
    uint64_t v5 = *(unsigned int *)(a3 + 68);
    uint64_t v6 = (void **)(v3 + 8 * v5);
    if (v5)
    {
      uint64_t v7 = 0;
      while (*(_UNKNOWN **)(v3 + v7) != &llvm::DemandedBitsAnalysis::Key)
      {
        v7 += 8;
        if (8 * v5 == v7) {
          goto LABEL_6;
        }
      }
      uint64_t v6 = (void **)(v3 + v7);
    }
LABEL_6:
    uint64_t v4 = *(void *)(a3 + 56);
  }
  else
  {
    uint64_t v10 = *(unsigned int *)(a3 + 64);
    int v11 = v10 - 1;
    unsigned int v12 = (v10 - 1) & ((&llvm::DemandedBitsAnalysis::Key >> 4) ^ (&llvm::DemandedBitsAnalysis::Key >> 9));
    uint64_t v6 = (void **)(v3 + 8 * v12);
    uint64_t v13 = *v6;
    if (*v6 == (void *)-1)
    {
      uint64_t v14 = 0;
LABEL_26:
      if (v14) {
        uint64_t v6 = v14;
      }
      if (*v6 != &llvm::DemandedBitsAnalysis::Key)
      {
        LODWORD(v5) = *(_DWORD *)(a3 + 68);
        uint64_t v6 = (void **)(v3 + 8 * v10);
        goto LABEL_7;
      }
    }
    else
    {
      uint64_t v14 = 0;
      int v15 = 1;
      while (v13 != &llvm::DemandedBitsAnalysis::Key)
      {
        if (v14) {
          BOOL v16 = 0;
        }
        else {
          BOOL v16 = v13 == (void *)-2;
        }
        if (v16) {
          uint64_t v14 = v6;
        }
        unsigned int v17 = v12 + v15++;
        unsigned int v12 = v17 & v11;
        uint64_t v6 = (void **)(v3 + 8 * (v17 & v11));
        uint64_t v13 = *v6;
        if (*v6 == (void *)-1) {
          goto LABEL_26;
        }
      }
    }
    LODWORD(v5) = *(_DWORD *)(a3 + 68);
  }
LABEL_7:
  if (v3 == v4) {
    unsigned int v8 = v5;
  }
  else {
    unsigned int v8 = *(_DWORD *)(a3 + 64);
  }
  BOOL v19 = v6 != (void **)(v3 + 8 * v8);
  return !sub_1CBF75724(v18) && !sub_1CBF7593C((uint64_t)v18);
}

void sub_1CCCB9810()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

uint64_t sub_1CCCB98E8(uint64_t a1)
{
  *(void *)a1 = &unk_1F2634E58;
  int v2 = *(void **)(a1 + 32);
  if (v2 != (void *)(a1 + 48)) {
    free(v2);
  }
  sub_1CD486DF0(a1 + 8, *(void **)(a1 + 16));
  return a1;
}

void sub_1CCCB9948(uint64_t a1)
{
  *(void *)a1 = &unk_1F2634E58;
  int v2 = *(void **)(a1 + 32);
  if (v2 != (void *)(a1 + 48)) {
    free(v2);
  }
  sub_1CD486DF0(a1 + 8, *(void **)(a1 + 16));

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCCB99C8()
{
}

void sub_1CCCB9AA8(void *a1)
{
  *a1 = &unk_1F2634F08;
  llvm::LazyValueInfo::releaseMemory(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

BOOL sub_1CCCB9B0C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return llvm::LazyValueInfo::invalidate(a1 + 8, a2, a3);
}

void sub_1CCCB9B14()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  llvm::MemoryDependenceAnalysis::run();
}

uint64_t sub_1CCCB9BE0(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(void *)a1 = *(void *)a2;
  *(void *)a2 = 0;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a2 + 8) = 0;
  int v4 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a2 + 12) = v4;
  int v5 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 16) = v5;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = 0;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a2 + 32) = 0;
  int v6 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a2 + 36) = v6;
  int v7 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a2 + 40) = v7;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = 0;
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_DWORD *)(a2 + 56) = 0;
  int v8 = *(_DWORD *)(a1 + 60);
  *(_DWORD *)(a1 + 60) = *(_DWORD *)(a2 + 60);
  *(_DWORD *)(a2 + 60) = v8;
  int v9 = *(_DWORD *)(a1 + 64);
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 64);
  *(_DWORD *)(a2 + 64) = v9;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 88) = 0;
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  *(void *)(a2 + 72) = 0;
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a2 + 80);
  *(_DWORD *)(a2 + 80) = 0;
  int v10 = *(_DWORD *)(a1 + 84);
  *(_DWORD *)(a1 + 84) = *(_DWORD *)(a2 + 84);
  *(_DWORD *)(a2 + 84) = v10;
  int v11 = *(_DWORD *)(a1 + 88);
  *(_DWORD *)(a1 + 88) = *(_DWORD *)(a2 + 88);
  *(_DWORD *)(a2 + 88) = v11;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 112) = 0;
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  *(void *)(a2 + 96) = 0;
  *(_DWORD *)(a1 + 104) = *(_DWORD *)(a2 + 104);
  *(_DWORD *)(a2 + 104) = 0;
  int v12 = *(_DWORD *)(a1 + 108);
  *(_DWORD *)(a1 + 108) = *(_DWORD *)(a2 + 108);
  *(_DWORD *)(a2 + 108) = v12;
  int v13 = *(_DWORD *)(a1 + 112);
  *(_DWORD *)(a1 + 112) = *(_DWORD *)(a2 + 112);
  *(_DWORD *)(a2 + 112) = v13;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  *(_DWORD *)(a1 + 136) = 0;
  *(void *)(a1 + 120) = *(void *)(a2 + 120);
  *(void *)(a2 + 120) = 0;
  *(_DWORD *)(a1 + 128) = *(_DWORD *)(a2 + 128);
  *(_DWORD *)(a2 + 128) = 0;
  int v14 = *(_DWORD *)(a1 + 132);
  *(_DWORD *)(a1 + 132) = *(_DWORD *)(a2 + 132);
  *(_DWORD *)(a2 + 132) = v14;
  int v15 = *(_DWORD *)(a1 + 136);
  *(_DWORD *)(a1 + 136) = *(_DWORD *)(a2 + 136);
  *(_DWORD *)(a2 + 136) = v15;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = 0;
  *(_DWORD *)(a1 + 160) = 0;
  *(void *)(a1 + 144) = *(void *)(a2 + 144);
  *(void *)(a2 + 144) = 0;
  *(_DWORD *)(a1 + 152) = *(_DWORD *)(a2 + 152);
  *(_DWORD *)(a2 + 152) = 0;
  int v16 = *(_DWORD *)(a1 + 156);
  *(_DWORD *)(a1 + 156) = *(_DWORD *)(a2 + 156);
  *(_DWORD *)(a2 + 156) = v16;
  int v17 = *(_DWORD *)(a1 + 160);
  *(_DWORD *)(a1 + 160) = *(_DWORD *)(a2 + 160);
  *(_DWORD *)(a2 + 160) = v17;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = 0;
  *(_DWORD *)(a1 + 184) = 0;
  *(void *)(a1 + 168) = *(void *)(a2 + 168);
  *(void *)(a2 + 168) = 0;
  *(_DWORD *)(a1 + 176) = *(_DWORD *)(a2 + 176);
  *(_DWORD *)(a2 + 176) = 0;
  int v18 = *(_DWORD *)(a1 + 180);
  *(_DWORD *)(a1 + 180) = *(_DWORD *)(a2 + 180);
  *(_DWORD *)(a2 + 180) = v18;
  int v19 = *(_DWORD *)(a1 + 184);
  *(_DWORD *)(a1 + 184) = *(_DWORD *)(a2 + 184);
  *(_DWORD *)(a2 + 184) = v19;
  long long v20 = *(_OWORD *)(a2 + 208);
  uint64_t v21 = *(void *)(a2 + 224);
  *(_OWORD *)(a1 + 192) = *(_OWORD *)(a2 + 192);
  *(_OWORD *)(a1 + 208) = v20;
  *(_DWORD *)(a1 + 248) = 0;
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 240) = 0;
  *(void *)(a1 + 224) = v21;
  *(void *)(a1 + 232) = *(void *)(a2 + 232);
  *(void *)(a2 + 232) = 0;
  *(_DWORD *)(a1 + 240) = *(_DWORD *)(a2 + 240);
  *(_DWORD *)(a2 + 240) = 0;
  LODWORD(v21) = *(_DWORD *)(a1 + 244);
  *(_DWORD *)(a1 + 244) = *(_DWORD *)(a2 + 244);
  *(_DWORD *)(a2 + 244) = v21;
  LODWORD(v21) = *(_DWORD *)(a1 + 248);
  *(_DWORD *)(a1 + 248) = *(_DWORD *)(a2 + 248);
  *(_DWORD *)(a2 + 248) = v21;
  *(void *)(a1 + 256) = 0;
  *(void *)(a1 + 264) = 0;
  *(_DWORD *)(a1 + 272) = 0;
  *(void *)(a1 + 256) = *(void *)(a2 + 256);
  *(void *)(a2 + 256) = 0;
  *(_DWORD *)(a1 + 264) = *(_DWORD *)(a2 + 264);
  *(_DWORD *)(a2 + 264) = 0;
  LODWORD(v21) = *(_DWORD *)(a1 + 268);
  *(_DWORD *)(a1 + 268) = *(_DWORD *)(a2 + 268);
  *(_DWORD *)(a2 + 268) = v21;
  LODWORD(v21) = *(_DWORD *)(a1 + 272);
  *(_DWORD *)(a1 + 272) = *(_DWORD *)(a2 + 272);
  *(_DWORD *)(a2 + 272) = v21;
  sub_1CC056A04(a1 + 280, a2 + 280);
  *(_DWORD *)(a1 + 376) = *(_DWORD *)(a2 + 376);
  *(void *)(a1 + 384) = 0;
  *(void *)(a1 + 392) = 0;
  *(_DWORD *)(a1 + 400) = 0;
  *(void *)(a1 + 384) = *(void *)(a2 + 384);
  *(void *)(a2 + 384) = 0;
  *(_DWORD *)(a1 + 392) = *(_DWORD *)(a2 + 392);
  *(_DWORD *)(a2 + 392) = 0;
  int v22 = *(_DWORD *)(a1 + 396);
  *(_DWORD *)(a1 + 396) = *(_DWORD *)(a2 + 396);
  *(_DWORD *)(a2 + 396) = v22;
  int v23 = *(_DWORD *)(a1 + 400);
  *(_DWORD *)(a1 + 400) = *(_DWORD *)(a2 + 400);
  *(_DWORD *)(a2 + 400) = v23;
  return a1;
}

void sub_1CCCB9EEC(void *a1)
{
  *a1 = &unk_1F2635010;
  sub_1CC0A20B8((uint64_t)(a1 + 1));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CCCB9F50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  return llvm::MemoryDependenceResults::invalidate(a1 + 8, a2, a3, a4);
}

void sub_1CCCB9F58()
{
}

void *sub_1CCCB9FC8(void *a1)
{
  int v2 = (llvm::MemorySSA *)a1[1];
  *a1 = &unk_1F2635068;
  a1[1] = 0;
  if (v2)
  {
    llvm::MemorySSA::~MemorySSA(v2);
    MEMORY[0x1D25D9CE0]();
  }
  return a1;
}

void sub_1CCCBA028(void *a1)
{
  int v2 = (llvm::MemorySSA *)a1[1];
  *a1 = &unk_1F2635068;
  a1[1] = 0;
  if (v2)
  {
    llvm::MemorySSA::~MemorySSA(v2);
    MEMORY[0x1D25D9CE0]();
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CCCBA0A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  return llvm::MemorySSAAnalysis::Result::invalidate(a1 + 8, a2, a3, a4);
}

void sub_1CCCBA0B0()
{
}

void sub_1CCCBA284(void *a1)
{
  *a1 = &unk_1F26350C0;
  sub_1CC0CEA4C(a1 + 11);
  MEMORY[0x1D25D9CD0](a1[11], 8);
  sub_1CC0CE968((uint64_t)(a1 + 8));
  MEMORY[0x1D25D9CD0](a1[8], 8);
  sub_1CC0CE8F0((uint64_t)(a1 + 5));
  MEMORY[0x1D25D9CD0](a1[5], 8);
  MEMORY[0x1D25D9CD0](a1[2], 8);

  JUMPOUT(0x1D25D9CE0);
}

BOOL sub_1CCCBA328(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return llvm::PhiValues::invalidate(a1 + 8, a2, a3);
}

void sub_1CCCBA330()
{
}

void sub_1CCCBA414()
{
}

void sub_1CCCBA428()
{
}

const char *sub_1CCCBA480()
{
  return "NoOpFunctionAnalysis";
}

void sub_1CCCBA494()
{
}

BOOL sub_1CCCBA4A8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v18[0] = (void **)a3;
  v18[1] = (void **)&unk_1EA61DEF8;
  uint64_t v4 = *(void *)(a3 + 48);
  uint64_t v3 = *(void *)(a3 + 56);
  if (v3 == v4)
  {
    uint64_t v5 = *(unsigned int *)(a3 + 68);
    int v6 = (void **)(v3 + 8 * v5);
    if (v5)
    {
      uint64_t v7 = 0;
      while (*(_UNKNOWN **)(v3 + v7) != &unk_1EA61DEF8)
      {
        v7 += 8;
        if (8 * v5 == v7) {
          goto LABEL_19;
        }
      }
      int v6 = (void **)(v3 + v7);
    }
LABEL_19:
    uint64_t v4 = *(void *)(a3 + 56);
  }
  else
  {
    uint64_t v8 = *(unsigned int *)(a3 + 64);
    int v9 = v8 - 1;
    unsigned int v10 = (v8 - 1) & ((&unk_1EA61DEF8 >> 4) ^ (&unk_1EA61DEF8 >> 9));
    int v6 = (void **)(v3 + 8 * v10);
    int v11 = *v6;
    if (*v6 == (void *)-1)
    {
      int v12 = 0;
LABEL_21:
      if (v12) {
        int v6 = v12;
      }
      if (*v6 != &unk_1EA61DEF8)
      {
        LODWORD(v5) = *(_DWORD *)(a3 + 68);
        int v6 = (void **)(v3 + 8 * v8);
        goto LABEL_26;
      }
    }
    else
    {
      int v12 = 0;
      int v13 = 1;
      while (v11 != &unk_1EA61DEF8)
      {
        if (v12) {
          BOOL v14 = 0;
        }
        else {
          BOOL v14 = v11 == (void *)-2;
        }
        if (v14) {
          int v12 = v6;
        }
        unsigned int v15 = v10 + v13++;
        unsigned int v10 = v15 & v9;
        int v6 = (void **)(v3 + 8 * (v15 & v9));
        int v11 = *v6;
        if (*v6 == (void *)-1) {
          goto LABEL_21;
        }
      }
    }
    LODWORD(v5) = *(_DWORD *)(a3 + 68);
  }
LABEL_26:
  if (v3 == v4) {
    unsigned int v16 = v5;
  }
  else {
    unsigned int v16 = *(_DWORD *)(a3 + 64);
  }
  BOOL v19 = v6 != (void **)(v3 + 8 * v16);
  return !sub_1CBF75724(v18) && !sub_1CBF7593C((uint64_t)v18);
}

void sub_1CCCBA5E0(uint64_t a1, uint64_t a2)
{
  llvm::OptimizationRemarkEmitterAnalysis::run(a2, &v2);
  operator new();
}

void *sub_1CCCBA6C8(void *a1)
{
  *a1 = &unk_1F26351C8;
  long long v2 = (uint64_t *)a1[3];
  a1[3] = 0;
  if (v2)
  {
    uint64_t v3 = *v2;
    uint64_t *v2 = 0;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
    MEMORY[0x1D25D9CE0](v2, 0x20C4093837F09);
  }
  return a1;
}

void sub_1CCCBA75C(void *a1)
{
  *a1 = &unk_1F26351C8;
  uint64_t v1 = (uint64_t *)a1[3];
  a1[3] = 0;
  if (v1)
  {
    uint64_t v2 = *v1;
    *uint64_t v1 = 0;
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    MEMORY[0x1D25D9CE0](v1, 0x20C4093837F09);
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CCCBA810(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  return llvm::OptimizationRemarkEmitter::invalidate(a1 + 8, a2, a3, a4);
}

void sub_1CCCBA818()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_1CCCBA930()
{
}

void sub_1CCCBAA10(void *a1)
{
  *a1 = &unk_1F2635430;
  uint64_t v1 = (void *)a1[22];
  if (v1 != (void *)a1[21])
  {
    uint64_t v3 = a1;
    free(v1);
    a1 = v3;
  }
  uint64_t v2 = (void *)a1[10];
  if (v2 != (void *)a1[9]) {
    free(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

BOOL sub_1CCCBAAA8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  return llvm::BasicAAResult::invalidate(a1 + 8, a2, a3, a4);
}

void sub_1CCCBAAB0()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_1CCCBAB6C()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_1CCCBAC28()
{
}

void sub_1CCCBAC80()
{
}

uint64_t sub_1CCCBAC94()
{
  return 0;
}

void sub_1CCCBAC9C()
{
}

void sub_1CCCBACF4()
{
}

uint64_t sub_1CCCBAD08()
{
  return 0;
}

uint64_t *sub_1CCCBAD10(uint64_t a1, uint64_t *a2)
{
  uint64_t v8 = 0;
  char v4 = sub_1CD71B3FC(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  uint64_t result = v8;
  if (v4) {
    return result;
  }
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
    goto LABEL_9;
  }
  if (v7 + ~v6 - *(_DWORD *)(a1 + 12) <= v7 >> 3)
  {
LABEL_9:
    sub_1CCCBADF0(a1, v7);
    uint64_t v8 = 0;
    sub_1CD71B3FC(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
    uint64_t result = v8;
  }
  ++*(_DWORD *)(a1 + 8);
  if (*result != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  uint64_t *result = *a2;
  result[1] = 0;
  return result;
}

void *sub_1CCCBADF0(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  char v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD71CDE0(a1, v4, &v4[2 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      void *result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

void sub_1CCCBAEC0()
{
}

void sub_1CCCBAED4()
{
}

const char *sub_1CCCBAF2C()
{
  return "NoOpLoopAnalysis";
}

void sub_1CCCBAF40()
{
}

BOOL sub_1CCCBAF54(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v18[0] = (void **)a3;
  v18[1] = (void **)&unk_1EA61DF00;
  uint64_t v4 = *(void *)(a3 + 48);
  uint64_t v3 = *(void *)(a3 + 56);
  if (v3 == v4)
  {
    uint64_t v5 = *(unsigned int *)(a3 + 68);
    unint64_t v6 = (void **)(v3 + 8 * v5);
    if (v5)
    {
      uint64_t v7 = 0;
      while (*(_UNKNOWN **)(v3 + v7) != &unk_1EA61DF00)
      {
        v7 += 8;
        if (8 * v5 == v7) {
          goto LABEL_19;
        }
      }
      unint64_t v6 = (void **)(v3 + v7);
    }
LABEL_19:
    uint64_t v4 = *(void *)(a3 + 56);
  }
  else
  {
    uint64_t v8 = *(unsigned int *)(a3 + 64);
    int v9 = v8 - 1;
    unsigned int v10 = (v8 - 1) & ((&unk_1EA61DF00 >> 4) ^ (&unk_1EA61DF00 >> 9));
    unint64_t v6 = (void **)(v3 + 8 * v10);
    uint64_t v11 = *v6;
    if (*v6 == (void *)-1)
    {
      int v12 = 0;
LABEL_21:
      if (v12) {
        unint64_t v6 = v12;
      }
      if (*v6 != &unk_1EA61DF00)
      {
        LODWORD(v5) = *(_DWORD *)(a3 + 68);
        unint64_t v6 = (void **)(v3 + 8 * v8);
        goto LABEL_26;
      }
    }
    else
    {
      int v12 = 0;
      int v13 = 1;
      while (v11 != &unk_1EA61DF00)
      {
        if (v12) {
          BOOL v14 = 0;
        }
        else {
          BOOL v14 = v11 == (void *)-2;
        }
        if (v14) {
          int v12 = v6;
        }
        unsigned int v15 = v10 + v13++;
        unsigned int v10 = v15 & v9;
        unint64_t v6 = (void **)(v3 + 8 * (v15 & v9));
        uint64_t v11 = *v6;
        if (*v6 == (void *)-1) {
          goto LABEL_21;
        }
      }
    }
    LODWORD(v5) = *(_DWORD *)(a3 + 68);
  }
LABEL_26:
  if (v3 == v4) {
    unsigned int v16 = v5;
  }
  else {
    unsigned int v16 = *(_DWORD *)(a3 + 64);
  }
  BOOL v19 = v6 != (void **)(v3 + 8 * v16);
  return !sub_1CBF75724(v18) && !sub_1CD71CECC((uint64_t)v18);
}

void sub_1CCCBB08C()
{
}

void sub_1CCCBB2A0(void *a1)
{
  *a1 = &unk_1F26356F0;
  sub_1CC078A80(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCCBB304(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
}

void sub_1CCCBB374()
{
}

void sub_1CCCBB404()
{
}

void sub_1CCCBB460()
{
}

uint64_t sub_1CCCBB474()
{
  return 0;
}

void sub_1CCCBB47C(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        unint64_t v6 = v4 - 40;
        uint64_t v7 = v4 - 24;
        sub_1CCCBB47C(&v7);
        uint64_t v4 = v6;
      }
      while (v6 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1CCCBB518(uint64_t a1)
{
  *(void *)a1 = &unk_1F263A910;
  uint64_t v3 = (void **)(a1 + 8);
  sub_1CCCB67B8(&v3);
  return MEMORY[0x1D25D9CE0](a1, 0xA1C4030951706);
}

void sub_1CCCBB584()
{
}

uint64_t sub_1CCCBB590()
{
  return 1;
}

char *sub_1CCCBB598()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::PassManager<Function>]";
  v10[1] = 77;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x4D) {
    uint64_t v1 = 77;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_295[v1];
  unint64_t v3 = 77 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

void sub_1CCCBB654(void *a1)
{
  uint64_t v2 = a1[1];
  *a1 = &unk_1F2639E10;
  a1[1] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCCBB6E0()
{
}

uint64_t sub_1CCCBB6EC()
{
  return 1;
}

char *sub_1CCCBB6F4()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::ModuleToFunctionPassAdaptor]";
  v10[1] = 83;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x53) {
    uint64_t v1 = 83;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_296[v1];
  unint64_t v3 = 83 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

uint64_t sub_1CCCBB7B0(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)(result + 296))
    {
      sub_1CD71D764();
      uint64_t v1 = 0;
      operator new();
    }
  }
  return result;
}

uint64_t sub_1CCCBB8DC(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)(result + 440))
    {
      sub_1CD71D764();
      uint64_t v1 = 0;
      operator new();
    }
  }
  return result;
}

void sub_1CCCBBA14()
{
}

void sub_1CCCBBA28()
{
}

llvm::raw_ostream *sub_1CCCBBA98(uint64_t a1, llvm::raw_ostream *a2, uint64_t (*a3)(uint64_t, const char *, uint64_t), uint64_t a4)
{
  uint64_t v5 = (const void *)a3(a4, "NoOpModuleAnalysis", 18);
  size_t v7 = v6;
  uint64_t v8 = (void *)*((void *)a2 + 4);
  if (*((void *)a2 + 3) - (void)v8 > 7uLL)
  {
    void *v8 = 0x3C65726975716572;
    uint64_t result = (llvm::raw_ostream *)(*((void *)a2 + 4) + 8);
    *((void *)a2 + 4) = result;
  }
  else
  {
    llvm::raw_ostream::write(a2, "require<", 8uLL);
    uint64_t result = (llvm::raw_ostream *)*((void *)a2 + 4);
  }
  if (v7 <= *((void *)a2 + 3) - (void)result)
  {
    if (v7)
    {
      memcpy(result, v5, v7);
      uint64_t result = (llvm::raw_ostream *)(*((void *)a2 + 4) + v7);
      *((void *)a2 + 4) = result;
    }
  }
  else
  {
    llvm::raw_ostream::write(a2, (const char *)v5, v7);
    uint64_t result = (llvm::raw_ostream *)*((void *)a2 + 4);
  }
  if (*((llvm::raw_ostream **)a2 + 3) == result)
  {
    return llvm::raw_ostream::write(a2, ">", 1uLL);
  }
  else
  {
    *(unsigned char *)uint64_t result = 62;
    ++*((void *)a2 + 4);
  }
  return result;
}

char *sub_1CCCBBBC0()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::RequireAnalysisPass<(anonymous namespace)::No"
                    "OpModuleAnalysis, llvm::Module, llvm::AnalysisManager<Module>>]";
  v10[1] = 163;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0xA3) {
    uint64_t v1 = 163;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_307[v1];
  unint64_t v3 = 163 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

uint64_t sub_1CCCBBC7C()
{
  return 1;
}

void sub_1CCCBBC88()
{
}

void sub_1CCCBBC9C(uint64_t a1@<X8>)
{
  *(void *)(a1 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
  *(void *)a1 = a1 + 32;
  *(void *)(a1 + 8) = a1 + 32;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v2 = a1 + 80;
  *(void *)(a1 + 48) = v2;
  *(void *)(a1 + 56) = v2;
  *(void *)(a1 + 64) = 2;
  *(_DWORD *)(a1 + 72) = 0;
  *(void *)(a1 + 16) = 0x100000002;
  sub_1CBFA16F4((uint64_t *)a1, (uint64_t)&unk_1EA61DEE8);
}

llvm::raw_ostream *sub_1CCCBBCE8(uint64_t a1, llvm::raw_ostream *a2, uint64_t (*a3)(uint64_t, const char *, uint64_t), uint64_t a4)
{
  uint64_t v5 = (const void *)a3(a4, "NoOpModuleAnalysis", 18);
  size_t v7 = v6;
  uint64_t v8 = *((void *)a2 + 4);
  if ((unint64_t)(*((void *)a2 + 3) - v8) > 0xA)
  {
    *(_DWORD *)(v8 + 7) = 1013281889;
    *(void *)uint64_t v8 = *(void *)"invalidate<";
    uint64_t result = (llvm::raw_ostream *)(*((void *)a2 + 4) + 11);
    *((void *)a2 + 4) = result;
  }
  else
  {
    llvm::raw_ostream::write(a2, "invalidate<", 0xBuLL);
    uint64_t result = (llvm::raw_ostream *)*((void *)a2 + 4);
  }
  if (v7 <= *((void *)a2 + 3) - (void)result)
  {
    if (v7)
    {
      memcpy(result, v5, v7);
      uint64_t result = (llvm::raw_ostream *)(*((void *)a2 + 4) + v7);
      *((void *)a2 + 4) = result;
    }
  }
  else
  {
    llvm::raw_ostream::write(a2, (const char *)v5, v7);
    uint64_t result = (llvm::raw_ostream *)*((void *)a2 + 4);
  }
  if (*((llvm::raw_ostream **)a2 + 3) == result)
  {
    return llvm::raw_ostream::write(a2, ">", 1uLL);
  }
  else
  {
    *(unsigned char *)uint64_t result = 62;
    ++*((void *)a2 + 4);
  }
  return result;
}

char *sub_1CCCBBE18()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::InvalidateAnalysisPass<(anonymous namespace):"
                    ":NoOpModuleAnalysis>]";
  v10[1] = 121;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x79) {
    uint64_t v1 = 121;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_308[v1];
  unint64_t v3 = 121 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

uint64_t sub_1CCCBBED4()
{
  return 0;
}

void sub_1CCCBBEDC()
{
}

void sub_1CCCBBEF0()
{
}

uint64_t sub_1CCCBBEFC()
{
  return 1;
}

uint64_t sub_1CCCBBF04(uint64_t a1)
{
  *(void *)a1 = &unk_1F263B0D0;
  uint64_t v2 = a1 + 8;
  sub_1CB833A08(a1 + 56, *(void **)(a1 + 64));
  sub_1CB833A08(a1 + 32, *(void **)(a1 + 40));
  sub_1CB833A08(v2, *(void **)(a1 + 16));
  return a1;
}

uint64_t sub_1CCCBBF6C(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = (void *)(a1 + 32);
  *(void *)a1 = v4;
  uint64_t v6 = *a2;
  uint64_t v5 = a2[1];
  if (v5 == *a2)
  {
    *(void *)(a1 + 8) = v4;
    uint64_t v7 = *((unsigned int *)a2 + 5);
    if (v7) {
      memmove(v4, (const void *)a2[1], 8 * v7);
    }
  }
  else
  {
    *(void *)(a1 + 8) = v5;
    a2[1] = v6;
  }
  *(void *)(a1 + 16) = a2[2];
  *(_DWORD *)(a1 + 24) = *((_DWORD *)a2 + 6);
  a2[2] = 32;
  *((_DWORD *)a2 + 6) = 0;
  *(void *)(a1 + 288) = 0;
  *(void *)(a1 + 296) = 0;
  *(_DWORD *)(a1 + 304) = 0;
  *(void *)(a1 + 288) = a2[36];
  a2[36] = 0;
  *(_DWORD *)(a1 + 296) = *((_DWORD *)a2 + 74);
  *((_DWORD *)a2 + 74) = 0;
  int v8 = *(_DWORD *)(a1 + 300);
  *(_DWORD *)(a1 + 300) = *((_DWORD *)a2 + 75);
  *((_DWORD *)a2 + 75) = v8;
  int v9 = *(_DWORD *)(a1 + 304);
  *(_DWORD *)(a1 + 304) = *((_DWORD *)a2 + 76);
  *((_DWORD *)a2 + 76) = v9;
  sub_1CCCBC0C4(a1 + 312, a2 + 39);
  sub_1CCCBC0C4(a1 + 352, a2 + 44);
  *(void *)(a1 + 392) = 0;
  *(void *)(a1 + 400) = 0;
  *(_DWORD *)(a1 + 408) = 0;
  *(void *)(a1 + 392) = a2[49];
  a2[49] = 0;
  *(_DWORD *)(a1 + 400) = *((_DWORD *)a2 + 100);
  *((_DWORD *)a2 + 100) = 0;
  int v10 = *(_DWORD *)(a1 + 404);
  *(_DWORD *)(a1 + 404) = *((_DWORD *)a2 + 101);
  *((_DWORD *)a2 + 101) = v10;
  int v11 = *(_DWORD *)(a1 + 408);
  *(_DWORD *)(a1 + 408) = *((_DWORD *)a2 + 102);
  *((_DWORD *)a2 + 102) = v11;
  *(void *)(a1 + 416) = 0;
  *(void *)(a1 + 424) = 0;
  *(_DWORD *)(a1 + 432) = 0;
  *(void *)(a1 + 416) = a2[52];
  a2[52] = 0;
  *(_DWORD *)(a1 + 424) = *((_DWORD *)a2 + 106);
  *((_DWORD *)a2 + 106) = 0;
  int v12 = *(_DWORD *)(a1 + 428);
  *(_DWORD *)(a1 + 428) = *((_DWORD *)a2 + 107);
  *((_DWORD *)a2 + 107) = v12;
  int v13 = *(_DWORD *)(a1 + 432);
  *(_DWORD *)(a1 + 432) = *((_DWORD *)a2 + 108);
  *((_DWORD *)a2 + 108) = v13;
  return a1;
}

uint64_t sub_1CCCBC0C4(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a2 = 0;
  *(void *)uint64_t result = v2;
  *(void *)(result + 8) = a2[1];
  a2[1] = 0;
  uint64_t v5 = a2[2];
  unint64_t v3 = a2 + 2;
  uint64_t v4 = v5;
  *(void *)(result + 16) = v5;
  uint64_t v6 = v3[1];
  *(void *)(result + 24) = v6;
  *(_DWORD *)(result + 32) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    unint64_t v7 = *(void *)(v4 + 8);
    unint64_t v8 = *(void *)(result + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        v7 %= v8;
      }
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(void *)(v2 + 8 * v7) = result + 16;
    *unint64_t v3 = 0;
    v3[1] = 0;
  }
  return result;
}

void sub_1CCCBC138(void *a1)
{
  *a1 = &unk_1F263A9D0;
  sub_1CC91FD7C((uint64_t)(a1 + 1));

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCCBC19C(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

uint64_t sub_1CCCBC1A8()
{
  return 0;
}

void sub_1CCCBC1B0()
{
}

void sub_1CCCBC1C4()
{
}

uint64_t sub_1CCCBC1D0()
{
  return 0;
}

uint64_t sub_1CCCBC1D8(uint64_t a1)
{
  *(void *)a1 = &unk_1F263A990;
  unint64_t v3 = (void **)(a1 + 136);
  sub_1CCB7AA60(&v3);
  unint64_t v3 = (void **)(a1 + 112);
  sub_1CCB7AA60(&v3);
  unint64_t v3 = (void **)(a1 + 88);
  sub_1CC947208(&v3);
  return a1;
}

void *sub_1CCCBC250(void *a1)
{
  *a1 = &unk_1F2636050;
  sub_1CC0D7CD8((uint64_t)(a1 + 6));
  uint64_t v2 = (void *)a1[5];
  if (v2 == a1 + 2)
  {
    (*(void (**)(void *))(a1[2] + 32))(a1 + 2);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_1CCCBC2F8(void *a1)
{
  *a1 = &unk_1F2636050;
  sub_1CC0D7CD8((uint64_t)(a1 + 6));
  uint64_t v2 = (void *)a1[5];
  if (v2 == a1 + 2)
  {
    (*(void (**)(void *))(a1[2] + 32))(a1 + 2);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCCBC3C0()
{
}

uint64_t sub_1CCCBC3CC()
{
  return 0;
}

void sub_1CCCBC3D8()
{
}

double sub_1CCCBC3EC@<D0>(uint64_t a1@<X8>)
{
  *(void *)(a1 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
  *(void *)a1 = a1 + 32;
  *(void *)(a1 + 8) = a1 + 32;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 48) = a1 + 80;
  *(void *)(a1 + 56) = a1 + 80;
  *(void *)(a1 + 64) = 2;
  *(_DWORD *)(a1 + 72) = 0;
  *(void *)&double result = 0x100000002;
  *(void *)(a1 + 16) = 0x100000002;
  return result;
}

llvm::raw_ostream *sub_1CCCBC42C(uint64_t a1, llvm::raw_ostream *a2, uint64_t (*a3)(uint64_t, const char *, uint64_t), uint64_t a4)
{
  uint64_t v6 = (const void *)a3(a4, "NoOpModulePass", 14);
  size_t v7 = v5;
  double result = (llvm::raw_ostream *)*((void *)a2 + 4);
  if (v5 <= *((void *)a2 + 3) - (void)result)
  {
    if (v5)
    {
      double result = (llvm::raw_ostream *)memcpy(result, v6, v5);
      *((void *)a2 + 4) += v7;
    }
  }
  else
  {
    return llvm::raw_ostream::write(a2, (const char *)v6, v5);
  }
  return result;
}

const char *sub_1CCCBC4C0()
{
  return "NoOpModulePass";
}

uint64_t sub_1CCCBC4D0()
{
  return 0;
}

void sub_1CCCBC4D8()
{
}

uint64_t sub_1CCCBC4E4()
{
  return 0;
}

void sub_1CCCBC4F0()
{
}

double sub_1CCCBC504@<D0>(uint64_t a1@<X8>)
{
  *(void *)(a1 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
  *(void *)a1 = a1 + 32;
  *(void *)(a1 + 8) = a1 + 32;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 48) = a1 + 80;
  *(void *)(a1 + 56) = a1 + 80;
  *(void *)(a1 + 64) = 2;
  *(_DWORD *)(a1 + 72) = 0;
  *(void *)&double result = 0x100000002;
  *(void *)(a1 + 16) = 0x100000002;
  return result;
}

llvm::raw_ostream *sub_1CCCBC544(uint64_t a1, llvm::raw_ostream *a2, uint64_t (*a3)(uint64_t, const char *, uint64_t), uint64_t a4)
{
  uint64_t v6 = (const void *)a3(a4, "NoOpCGSCCPass", 13);
  size_t v7 = v5;
  double result = (llvm::raw_ostream *)*((void *)a2 + 4);
  if (v5 <= *((void *)a2 + 3) - (void)result)
  {
    if (v5)
    {
      double result = (llvm::raw_ostream *)memcpy(result, v6, v5);
      *((void *)a2 + 4) += v7;
    }
  }
  else
  {
    return llvm::raw_ostream::write(a2, (const char *)v6, v5);
  }
  return result;
}

const char *sub_1CCCBC5D8()
{
  return "NoOpCGSCCPass";
}

uint64_t sub_1CCCBC5E8()
{
  return 0;
}

void sub_1CCCBC5F0()
{
}

uint64_t sub_1CCCBC5FC()
{
  return 0;
}

void sub_1CCCBC604()
{
}

uint64_t sub_1CCCBC610()
{
  return 0;
}

void sub_1CCCBC618()
{
}

uint64_t sub_1CCCBC624()
{
  return 1;
}

void sub_1CCCBC62C()
{
}

uint64_t sub_1CCCBC638()
{
  return 0;
}

void sub_1CCCBC640()
{
}

uint64_t sub_1CCCBC64C()
{
  return 0;
}

void sub_1CCCBC654()
{
}

uint64_t sub_1CCCBC660()
{
  return 0;
}

uint64_t sub_1CCCBC668(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a1 + 16;
  *(void *)(a1 + 8) = 0x10000000000;
  if (*(_DWORD *)(a2 + 8)) {
    sub_1CBA6E388(a1, (const void **)a2);
  }
  *(_DWORD *)(a1 + 2080) = 0;
  *(_OWORD *)(a1 + 2064) = 0u;
  *(void *)(a1 + 2064) = *(void *)(a2 + 2064);
  *(void *)(a2 + 2064) = 0;
  *(_DWORD *)(a1 + 2072) = *(_DWORD *)(a2 + 2072);
  *(_DWORD *)(a2 + 2072) = 0;
  int v4 = *(_DWORD *)(a1 + 2076);
  *(_DWORD *)(a1 + 2076) = *(_DWORD *)(a2 + 2076);
  *(_DWORD *)(a2 + 2076) = v4;
  int v5 = *(_DWORD *)(a1 + 2080);
  *(_DWORD *)(a1 + 2080) = *(_DWORD *)(a2 + 2080);
  *(_DWORD *)(a2 + 2080) = v5;
  *(void *)(a1 + 2088) = 1;
  uint64_t v6 = 2096;
  int64x2_t v7 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  do
  {
    *(int64x2_t *)(a1 + v6) = v7;
    v6 += 16;
  }
  while (v6 != 2224);
  sub_1CCCBC76C((unsigned int *)(a1 + 2088), (unsigned int *)(a2 + 2088));
  *(void *)(a1 + 2224) = a1 + 2240;
  *(void *)(a1 + 2232) = 0x1000000000;
  if (*(_DWORD *)(a2 + 2232)) {
    sub_1CBA6E388(a1 + 2224, (const void **)(a2 + 2224));
  }
  return a1;
}

__n128 sub_1CCCBC76C(unsigned int *a1, unsigned int *a2)
{
  unsigned int v2 = *a2;
  *a2 = *a1 & 0xFFFFFFFE | *a2 & 1;
  unsigned int v3 = a1[1];
  *a1 = v2 & 0xFFFFFFFE | *a1 & 1;
  a1[1] = a2[1];
  a2[1] = v3;
  unsigned int v4 = *a2;
  if (*a1)
  {
    if (v4)
    {
      uint64_t v5 = 0;
      uint64_t v6 = (int *)(a1 + 2);
      int64x2_t v7 = (int *)(a2 + 2);
      do
      {
        uint64_t v8 = *(void *)&v6[v5];
        *(void *)&v6[v5] = *(void *)&v7[v5];
        *(void *)&v7[v5] = v8;
        v5 += 2;
      }
      while (v5 != 32);
      return result;
    }
    int v10 = a2;
  }
  else
  {
    if ((v4 & 1) == 0)
    {
      uint64_t v9 = *((void *)a1 + 1);
      *((void *)a1 + 1) = *((void *)a2 + 1);
      *((void *)a2 + 1) = v9;
      LODWORD(v9) = a1[4];
      a1[4] = a2[4];
      a2[4] = v9;
      return result;
    }
    unsigned int v4 = *a1;
    int v10 = a1;
    a1 = a2;
  }
  __n128 v13 = *(__n128 *)(v10 + 2);
  unsigned int *v10 = v4 | 1;
  for (uint64_t i = 2; i != 34; i += 2)
    *(void *)&v10[i] = *(void *)&a1[i];
  *a1 &= ~1u;
  __n128 result = v13;
  *(__n128 *)(a1 + 2) = v13;
  return result;
}

void sub_1CCCBC858(uint64_t a1)
{
  *(void *)a1 = &unk_1F2639F10;
  unsigned int v2 = *(void **)(a1 + 2232);
  if (v2 != (void *)(a1 + 2248)) {
    free(v2);
  }
  if ((*(unsigned char *)(a1 + 2096) & 1) == 0) {
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 2104), 8);
  }
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 2072), 8);
  unsigned int v3 = *(void **)(a1 + 8);
  if (v3 != (void *)(a1 + 24)) {
    free(v3);
  }

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCCBC90C()
{
}

uint64_t sub_1CCCBC918()
{
  return 0;
}

void sub_1CCCBC920()
{
}

uint64_t sub_1CCCBC92C()
{
  return 0;
}

void sub_1CCCBC938()
{
}

double sub_1CCCBC94C@<D0>(uint64_t a1@<X8>)
{
  *(void *)(a1 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
  *(void *)a1 = a1 + 32;
  *(void *)(a1 + 8) = a1 + 32;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 48) = a1 + 80;
  *(void *)(a1 + 56) = a1 + 80;
  *(void *)(a1 + 64) = 2;
  *(_DWORD *)(a1 + 72) = 0;
  *(void *)&double result = 0x100000002;
  *(void *)(a1 + 16) = 0x100000002;
  return result;
}

llvm::raw_ostream *sub_1CCCBC98C(uint64_t a1, llvm::raw_ostream *a2, uint64_t (*a3)(uint64_t, const char *, uint64_t), uint64_t a4)
{
  uint64_t v6 = (const void *)a3(a4, "NoOpFunctionPass", 16);
  size_t v7 = v5;
  double result = (llvm::raw_ostream *)*((void *)a2 + 4);
  if (v5 <= *((void *)a2 + 3) - (void)result)
  {
    if (v5)
    {
      double result = (llvm::raw_ostream *)memcpy(result, v6, v5);
      *((void *)a2 + 4) += v7;
    }
  }
  else
  {
    return llvm::raw_ostream::write(a2, (const char *)v6, v5);
  }
  return result;
}

const char *sub_1CCCBCA20()
{
  return "NoOpFunctionPass";
}

uint64_t sub_1CCCBCA30()
{
  return 0;
}

double sub_1CCCBCA38@<D0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  return llvm::LowerExpectIntrinsicPass::run(a1, a2);
}

uint64_t sub_1CCCBCA44()
{
  return 0;
}

void sub_1CCCBCA4C()
{
}

uint64_t sub_1CCCBCA58()
{
  return 0;
}

void sub_1CCCBCA60()
{
}

uint64_t sub_1CCCBCA6C()
{
  return 0;
}

void sub_1CCCBCA74()
{
}

uint64_t sub_1CCCBCA80()
{
  return 0;
}

void sub_1CCCBCA88()
{
}

uint64_t sub_1CCCBCA94()
{
  return 0;
}

void sub_1CCCBCA9C()
{
}

uint64_t sub_1CCCBCAA8()
{
  return 0;
}

uint64_t sub_1CCCBCAB0(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(void *)a1 = *(void *)a2;
  *(void *)a2 = 0;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a2 + 8) = 0;
  int v4 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a2 + 12) = v4;
  int v5 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 16) = v5;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = 0;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a2 + 32) = 0;
  int v6 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a2 + 36) = v6;
  int v7 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a2 + 40) = v7;
  sub_1CD72C77C(a1 + 48, a2 + 48);
  for (uint64_t i = 0; i != 432; i += 24)
  {
    uint64_t v9 = a1 + i;
    uint64_t v10 = a2 + i;
    *(void *)(v9 + 120) = 0;
    *(void *)(v9 + 128) = 0;
    *(_DWORD *)(v9 + 136) = 0;
    *(void *)(v9 + 120) = *(void *)(a2 + i + 120);
    *(void *)(v10 + 120) = 0;
    *(_DWORD *)(v9 + 128) = *(_DWORD *)(a2 + i + 128);
    *(_DWORD *)(v10 + 128) = 0;
    int v11 = *(_DWORD *)(a1 + i + 132);
    *(_DWORD *)(v9 + 132) = *(_DWORD *)(a2 + i + 132);
    *(_DWORD *)(v10 + 132) = v11;
    int v12 = *(_DWORD *)(a1 + i + 136);
    *(_DWORD *)(v9 + 136) = *(_DWORD *)(a2 + i + 136);
    *(_DWORD *)(v10 + 136) = v12;
  }
  *(unsigned char *)(a1 + 552) = *(unsigned char *)(a2 + 552);
  return a1;
}

void sub_1CCCBCBC4(int32x2_t *a1@<X0>, llvm::Function *a2@<X1>, uint64_t a3@<X8>)
{
}

uint64_t sub_1CCCBCBD0()
{
  return 0;
}

void sub_1CCCBCBD8()
{
}

uint64_t sub_1CCCBCBE4()
{
  return 0;
}

void sub_1CCCBCBEC()
{
}

uint64_t sub_1CCCBCBF8()
{
  return 0;
}

uint64_t sub_1CCCBCC00(uint64_t result, uint64_t a2)
{
  *(void *)double result = 0;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(void *)double result = *(void *)a2;
  *(void *)a2 = 0;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a2 + 8) = 0;
  *(void *)(result + 24) = result + 40;
  int v2 = *(_DWORD *)(result + 12);
  *(_DWORD *)(result + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a2 + 12) = v2;
  int v3 = *(_DWORD *)(result + 16);
  *(_DWORD *)(result + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 16) = v3;
  *(void *)(result + 32) = 0x1000000000;
  if (*(_DWORD *)(a2 + 32))
  {
    uint64_t v4 = result;
    sub_1CD41C56C(result + 24, a2 + 24);
    return v4;
  }
  return result;
}

void *sub_1CCCBCC94(void *result, void *a2, unint64_t *a3)
{
  if (result != a2)
  {
    unint64_t v3 = (unint64_t)(a3 + 1);
    do
    {
      *a3 = 4;
      a3[1] = 0;
      unint64_t v4 = result[2];
      a3[2] = v4;
      if (v4 != -8192 && v4 != -4096 && v4 != 0)
      {
        unint64_t v6 = *result & 0xFFFFFFFFFFFFFFF8;
        a3[1] = *(void *)v6;
        *(void *)unint64_t v6 = a3;
        *a3 = v6 | 4;
        int v7 = (uint64_t *)a3[1];
        if (v7) {
          *int v7 = *v7 & 7 | v3;
        }
      }
      result += 3;
      a3 += 3;
      v3 += 24;
    }
    while (result != a2);
    return a2;
  }
  return result;
}

void sub_1CCCBCD18()
{
}

uint64_t sub_1CCCBCD24()
{
  return 0;
}

void sub_1CCCBCD2C()
{
}

uint64_t sub_1CCCBCD38()
{
  return 0;
}

void sub_1CCCBCD40()
{
}

uint64_t sub_1CCCBCD4C()
{
  return 0;
}

char *sub_1CCCBCD54()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::EarlyCSEPass]";
  v10[1] = 68;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x44) {
    uint64_t v1 = 68;
  }
  else {
    uint64_t v1 = v0;
  }
  int v2 = &aStringrefLlvmG_325[v1];
  unint64_t v3 = 68 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  double result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

void sub_1CCCBCE10()
{
}

void sub_1CCCBCE24()
{
}

uint64_t sub_1CCCBCE30()
{
  return 0;
}

char *sub_1CCCBCE38()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::SimplifyCFGPass]";
  v10[1] = 71;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x47) {
    uint64_t v1 = 71;
  }
  else {
    uint64_t v1 = v0;
  }
  int v2 = &aStringrefLlvmG_329[v1];
  unint64_t v3 = 71 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  double result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

void sub_1CCCBCEF4(uint64_t a1)
{
}

uint64_t sub_1CCCBCF00()
{
  return 0;
}

char *sub_1CCCBCF08()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::MergedLoadStoreMotionPass]";
  v10[1] = 81;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x51) {
    uint64_t v1 = 81;
  }
  else {
    uint64_t v1 = v0;
  }
  int v2 = &aStringrefLlvmG_331[v1];
  unint64_t v3 = 81 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  double result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

unsigned int *sub_1CCCBCFC4(unsigned int *result, unsigned int *a2)
{
  unsigned int v2 = *a2;
  *a2 = *result & 0xFFFFFFFE | *a2 & 1;
  int v3 = result[1];
  char *result = v2 & 0xFFFFFFFE | *result & 1;
  result[1] = a2[1];
  a2[1] = v3;
  unsigned int v4 = *a2;
  if (*result)
  {
    if ((v4 & 1) == 0)
    {
      unint64_t v6 = a2;
      goto LABEL_7;
    }
    uint64_t v9 = 0;
    while (1)
    {
      uint64_t v10 = (int *)&result[v9];
      int v11 = (int *)&a2[v9];
      uint64_t v12 = *(void *)&result[v9 + 2];
      uint64_t v13 = *(void *)&a2[v9 + 2];
      if (v12 == -4096 || v12 == -8192 || v13 == -4096 || v13 == -8192)
      {
        *((void *)v10 + 1) = v13;
        *((void *)v11 + 1) = v12;
        if ((v12 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          unsigned int v15 = (int *)&a2[v9];
          unsigned int v16 = (int *)&result[v9];
          goto LABEL_22;
        }
        if ((v13 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          unsigned int v15 = (int *)&result[v9];
          unsigned int v16 = (int *)&a2[v9];
LABEL_22:
          v15[4] = v16[4];
        }
      }
      else
      {
        int v14 = result[v9 + 4];
        *((void *)v10 + 1) = v13;
        result[v9 + 4] = a2[v9 + 4];
        *((void *)v11 + 1) = v12;
        a2[v9 + 4] = v14;
      }
      v9 += 4;
      if (v9 == 16) {
        return result;
      }
    }
  }
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = *((void *)result + 1);
    *((void *)result + 1) = *((void *)a2 + 1);
    *((void *)a2 + 1) = v5;
    LODWORD(v5) = result[4];
    result[4] = a2[4];
    a2[4] = v5;
    return result;
  }
  unsigned int v4 = *result;
  unint64_t v6 = result;
  double result = a2;
LABEL_7:
  uint64_t v7 = 0;
  long long v17 = *(_OWORD *)(v6 + 2);
  *unint64_t v6 = v4 | 1;
  do
  {
    uint64_t v8 = *(void *)&result[v7 + 2];
    *(void *)&v6[v7 + 2] = v8;
    if ((v8 | 0x1000) != 0xFFFFFFFFFFFFF000) {
      v6[v7 + 4] = result[v7 + 4];
    }
    v7 += 4;
  }
  while (v7 != 16);
  *result &= ~1u;
  *(_OWORD *)(result + 2) = v17;
  return result;
}

void sub_1CCCBD144()
{
}

uint64_t sub_1CCCBD150()
{
  return 0;
}

char *sub_1CCCBD158()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::GVNPass]";
  v10[1] = 63;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x3F) {
    uint64_t v1 = 63;
  }
  else {
    uint64_t v1 = v0;
  }
  unsigned int v2 = &aStringrefLlvmG_332[v1];
  unint64_t v3 = v1 ^ 0x3F;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  double result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

uint64_t sub_1CCCBD214(uint64_t a1)
{
  *(void *)a1 = &unk_1F263A2D0;
  uint64_t v4 = (void **)(a1 + 16);
  sub_1CCCB67B8(&v4);
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

uint64_t sub_1CCCBD29C(uint64_t a1)
{
  *(void *)a1 = &unk_1F263A2D0;
  uint64_t v4 = (void **)(a1 + 16);
  sub_1CCCB67B8(&v4);
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return MEMORY[0x1D25D9CE0](a1, 0x10A1C409957A1C6);
}

void sub_1CCCBD338()
{
}

uint64_t sub_1CCCBD344()
{
  return 1;
}

char *sub_1CCCBD34C()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::FunctionToLoopPassAdaptor]";
  v10[1] = 81;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x51) {
    uint64_t v1 = 81;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_333[v1];
  unint64_t v3 = 81 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  double result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

void sub_1CCCBD408(uint64_t a1@<X1>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
}

uint64_t sub_1CCCBD414()
{
  return 0;
}

void sub_1CCCBD41C(uint64_t a1, llvm *a2, uint64_t a3, uint64_t a4)
{
}

uint64_t sub_1CCCBD428()
{
  return 0;
}

void sub_1CCCBD434()
{
}

double sub_1CCCBD448@<D0>(uint64_t a1@<X8>)
{
  *(void *)(a1 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
  *(void *)a1 = a1 + 32;
  *(void *)(a1 + 8) = a1 + 32;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 48) = a1 + 80;
  *(void *)(a1 + 56) = a1 + 80;
  *(void *)(a1 + 64) = 2;
  *(_DWORD *)(a1 + 72) = 0;
  *(void *)&double result = 0x100000002;
  *(void *)(a1 + 16) = 0x100000002;
  return result;
}

llvm::raw_ostream *sub_1CCCBD488(uint64_t a1, llvm::raw_ostream *a2, uint64_t (*a3)(uint64_t, const char *, uint64_t), uint64_t a4)
{
  unint64_t v6 = (const void *)a3(a4, "NoOpLoopPass", 12);
  size_t v7 = v5;
  double result = (llvm::raw_ostream *)*((void *)a2 + 4);
  if (v5 <= *((void *)a2 + 3) - (void)result)
  {
    if (v5)
    {
      double result = (llvm::raw_ostream *)memcpy(result, v6, v5);
      *((void *)a2 + 4) += v7;
    }
  }
  else
  {
    return llvm::raw_ostream::write(a2, (const char *)v6, v5);
  }
  return result;
}

const char *sub_1CCCBD51C()
{
  return "NoOpLoopPass";
}

uint64_t sub_1CCCBD52C()
{
  return 0;
}

void sub_1CCCBD534(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_1CCCBD540()
{
  return 0;
}

void sub_1CCCBD548(const llvm::Loop *a1@<X1>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
}

uint64_t sub_1CCCBD554()
{
  return 0;
}

void sub_1CCCBD55C(uint64_t a1, llvm::Loop *a2, uint64_t a3, void *a4)
{
}

uint64_t sub_1CCCBD568()
{
  return 0;
}

void sub_1CCCBD570(uint64_t a1, llvm::Loop *a2, uint64_t a3, uint64_t a4)
{
}

uint64_t sub_1CCCBD57C()
{
  return 0;
}

char *sub_1CCCBD584()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::SimpleLoopUnswitchPass]";
  v10[1] = 78;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x4E) {
    uint64_t v1 = 78;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_334[v1];
  unint64_t v3 = 78 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  double result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

void sub_1CCCBD640(uint64_t a1, llvm *a2, uint64_t a3, uint64_t a4)
{
}

uint64_t sub_1CCCBD64C()
{
  return 0;
}

char *sub_1CCCBD654()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::LICMPass]";
  v10[1] = 64;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x40) {
    uint64_t v1 = 64;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_335[v1];
  unint64_t v3 = 64 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  double result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

void sub_1CCCBD710()
{
}

uint64_t sub_1CCCBD71C()
{
  return 1;
}

char *sub_1CCCBD724()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::CGSCCToFunctionPassAdaptor]";
  v10[1] = 82;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x52) {
    uint64_t v1 = 82;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_336[v1];
  unint64_t v3 = 82 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  double result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

uint64_t sub_1CCCBD7E0(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)(result + 296))
    {
      sub_1CD66E2D8();
      uint64_t v1 = 0;
      operator new();
    }
  }
  return result;
}

uint64_t sub_1CCCBD90C(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)(result + 440))
    {
      sub_1CD66E2D8();
      uint64_t v1 = 0;
      operator new();
    }
  }
  return result;
}

void sub_1CCCBDA44()
{
}

void sub_1CCCBDA58()
{
}

llvm::raw_ostream *sub_1CCCBDAC8(uint64_t a1, llvm::raw_ostream *a2, uint64_t (*a3)(uint64_t, const char *, uint64_t), uint64_t a4)
{
  size_t v5 = (const void *)a3(a4, "NoOpCGSCCAnalysis", 17);
  size_t v7 = v6;
  uint64_t v8 = (void *)*((void *)a2 + 4);
  if (*((void *)a2 + 3) - (void)v8 > 7uLL)
  {
    void *v8 = 0x3C65726975716572;
    double result = (llvm::raw_ostream *)(*((void *)a2 + 4) + 8);
    *((void *)a2 + 4) = result;
  }
  else
  {
    llvm::raw_ostream::write(a2, "require<", 8uLL);
    double result = (llvm::raw_ostream *)*((void *)a2 + 4);
  }
  if (v7 <= *((void *)a2 + 3) - (void)result)
  {
    if (v7)
    {
      memcpy(result, v5, v7);
      double result = (llvm::raw_ostream *)(*((void *)a2 + 4) + v7);
      *((void *)a2 + 4) = result;
    }
  }
  else
  {
    llvm::raw_ostream::write(a2, (const char *)v5, v7);
    double result = (llvm::raw_ostream *)*((void *)a2 + 4);
  }
  if (*((llvm::raw_ostream **)a2 + 3) == result)
  {
    return llvm::raw_ostream::write(a2, ">", 1uLL);
  }
  else
  {
    *(unsigned char *)double result = 62;
    ++*((void *)a2 + 4);
  }
  return result;
}

char *sub_1CCCBDBF0()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::RequireAnalysisPass<(anonymous namespace)::No"
                    "OpCGSCCAnalysis, llvm::LazyCallGraph::SCC, llvm::AnalysisManager<LazyCallGraph::SCC, LazyCallGraph &"
                    ">, llvm::LazyCallGraph &, llvm::CGSCCUpdateResult &>]";
  v10[1] = 253;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0xFD) {
    uint64_t v1 = 253;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_338[v1];
  unint64_t v3 = 253 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  double result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

uint64_t sub_1CCCBDCAC()
{
  return 0;
}

void sub_1CCCBDCB8()
{
}

void sub_1CCCBDCCC(uint64_t a1@<X8>)
{
  *(void *)(a1 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
  *(void *)a1 = a1 + 32;
  *(void *)(a1 + 8) = a1 + 32;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v2 = a1 + 80;
  *(void *)(a1 + 48) = v2;
  *(void *)(a1 + 56) = v2;
  *(void *)(a1 + 64) = 2;
  *(_DWORD *)(a1 + 72) = 0;
  *(void *)(a1 + 16) = 0x100000002;
  sub_1CBFA16F4((uint64_t *)a1, (uint64_t)&unk_1EA61DEF0);
}

llvm::raw_ostream *sub_1CCCBDD18(uint64_t a1, llvm::raw_ostream *a2, uint64_t (*a3)(uint64_t, const char *, uint64_t), uint64_t a4)
{
  size_t v5 = (const void *)a3(a4, "NoOpCGSCCAnalysis", 17);
  size_t v7 = v6;
  uint64_t v8 = *((void *)a2 + 4);
  if ((unint64_t)(*((void *)a2 + 3) - v8) > 0xA)
  {
    *(_DWORD *)(v8 + 7) = 1013281889;
    *(void *)uint64_t v8 = *(void *)"invalidate<";
    double result = (llvm::raw_ostream *)(*((void *)a2 + 4) + 11);
    *((void *)a2 + 4) = result;
  }
  else
  {
    llvm::raw_ostream::write(a2, "invalidate<", 0xBuLL);
    double result = (llvm::raw_ostream *)*((void *)a2 + 4);
  }
  if (v7 <= *((void *)a2 + 3) - (void)result)
  {
    if (v7)
    {
      memcpy(result, v5, v7);
      double result = (llvm::raw_ostream *)(*((void *)a2 + 4) + v7);
      *((void *)a2 + 4) = result;
    }
  }
  else
  {
    llvm::raw_ostream::write(a2, (const char *)v5, v7);
    double result = (llvm::raw_ostream *)*((void *)a2 + 4);
  }
  if (*((llvm::raw_ostream **)a2 + 3) == result)
  {
    return llvm::raw_ostream::write(a2, ">", 1uLL);
  }
  else
  {
    *(unsigned char *)double result = 62;
    ++*((void *)a2 + 4);
  }
  return result;
}

char *sub_1CCCBDE48()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::InvalidateAnalysisPass<(anonymous namespace):"
                    ":NoOpCGSCCAnalysis>]";
  v10[1] = 120;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x78) {
    uint64_t v1 = 120;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_339[v1];
  unint64_t v3 = 120 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  double result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

uint64_t sub_1CCCBDF04()
{
  return 0;
}

void *sub_1CCCBDF0C(void *result, _OWORD *a2, _OWORD *a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >= 0x666666666666667) {
      abort();
    }
    unint64_t v6 = result;
    uint64_t v7 = 5 * a4;
    double result = operator new(40 * a4);
    uint64_t v8 = result;
    *unint64_t v6 = result;
    v6[1] = result;
    for (void v6[2] = &result[v7]; a2 != a3; a2 = (_OWORD *)((char *)a2 + 40))
    {
      *(_OWORD *)uint64_t v8 = *a2;
      void v8[2] = 0;
      v8[3] = 0;
      v8[4] = 0;
      double result = (void *)sub_1CCCBDF0C(v8 + 2);
      v8 += 5;
    }
    v6[1] = v8;
  }
  return result;
}

uint64_t sub_1CCCBDFC8(uint64_t a1)
{
  if (*(void *)a1 && *(_DWORD *)(*(void *)a1 + 296))
  {
    sub_1CCCBB598();
    uint64_t v2 = 0;
    operator new();
  }
  return 1;
}

uint64_t sub_1CCCBE0F8(uint64_t result)
{
  if (*(void *)result)
  {
    if (*(_DWORD *)(*(void *)result + 440))
    {
      sub_1CCCBB598();
      uint64_t v1 = 0;
      operator new();
    }
  }
  return result;
}

void sub_1CCCBE22C(uint64_t a1@<X8>)
{
  *(void *)(a1 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
  *(void *)a1 = a1 + 32;
  *(void *)(a1 + 8) = a1 + 32;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v2 = a1 + 80;
  *(void *)(a1 + 48) = v2;
  *(void *)(a1 + 56) = v2;
  *(void *)(a1 + 64) = 2;
  *(_DWORD *)(a1 + 72) = 0;
  *(void *)(a1 + 16) = 0x100000002;
  sub_1CBFA16F4((uint64_t *)a1, (uint64_t)&llvm::AAManager::Key);
}

uint64_t sub_1CCCBE27C()
{
  return 0;
}

char *sub_1CCCBE284()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::InvalidateAnalysisPass<llvm::AAManager>]";
  v10[1] = 95;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x5F) {
    uint64_t v1 = 95;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_345[v1];
  unint64_t v3 = 95 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  double result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

void sub_1CCCBE344()
{
}

void sub_1CCCBE358()
{
}

llvm::raw_ostream *sub_1CCCBE3C8(uint64_t a1, llvm::raw_ostream *a2, uint64_t (*a3)(uint64_t, const char *, uint64_t), uint64_t a4)
{
  size_t v5 = (const void *)a3(a4, "NoOpFunctionAnalysis", 20);
  size_t v7 = v6;
  uint64_t v8 = (void *)*((void *)a2 + 4);
  if (*((void *)a2 + 3) - (void)v8 > 7uLL)
  {
    void *v8 = 0x3C65726975716572;
    double result = (llvm::raw_ostream *)(*((void *)a2 + 4) + 8);
    *((void *)a2 + 4) = result;
  }
  else
  {
    llvm::raw_ostream::write(a2, "require<", 8uLL);
    double result = (llvm::raw_ostream *)*((void *)a2 + 4);
  }
  if (v7 <= *((void *)a2 + 3) - (void)result)
  {
    if (v7)
    {
      memcpy(result, v5, v7);
      double result = (llvm::raw_ostream *)(*((void *)a2 + 4) + v7);
      *((void *)a2 + 4) = result;
    }
  }
  else
  {
    llvm::raw_ostream::write(a2, (const char *)v5, v7);
    double result = (llvm::raw_ostream *)*((void *)a2 + 4);
  }
  if (*((llvm::raw_ostream **)a2 + 3) == result)
  {
    return llvm::raw_ostream::write(a2, ">", 1uLL);
  }
  else
  {
    *(unsigned char *)double result = 62;
    ++*((void *)a2 + 4);
  }
  return result;
}

char *sub_1CCCBE4F0()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::RequireAnalysisPass<(anonymous namespace)::No"
                    "OpFunctionAnalysis, llvm::Function, llvm::AnalysisManager<Function>>]";
  v10[1] = 169;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0xA9) {
    uint64_t v1 = 169;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_380[v1];
  unint64_t v3 = 169 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  double result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

uint64_t sub_1CCCBE5AC()
{
  return 1;
}

void sub_1CCCBE5B8()
{
}

void sub_1CCCBE5CC(uint64_t a1@<X8>)
{
  *(void *)(a1 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
  *(void *)a1 = a1 + 32;
  *(void *)(a1 + 8) = a1 + 32;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v2 = a1 + 80;
  *(void *)(a1 + 48) = v2;
  *(void *)(a1 + 56) = v2;
  *(void *)(a1 + 64) = 2;
  *(_DWORD *)(a1 + 72) = 0;
  *(void *)(a1 + 16) = 0x100000002;
  sub_1CBFA16F4((uint64_t *)a1, (uint64_t)&unk_1EA61DEF8);
}

llvm::raw_ostream *sub_1CCCBE618(uint64_t a1, llvm::raw_ostream *a2, uint64_t (*a3)(uint64_t, const char *, uint64_t), uint64_t a4)
{
  size_t v5 = (const void *)a3(a4, "NoOpFunctionAnalysis", 20);
  size_t v7 = v6;
  uint64_t v8 = *((void *)a2 + 4);
  if ((unint64_t)(*((void *)a2 + 3) - v8) > 0xA)
  {
    *(_DWORD *)(v8 + 7) = 1013281889;
    *(void *)uint64_t v8 = *(void *)"invalidate<";
    double result = (llvm::raw_ostream *)(*((void *)a2 + 4) + 11);
    *((void *)a2 + 4) = result;
  }
  else
  {
    llvm::raw_ostream::write(a2, "invalidate<", 0xBuLL);
    double result = (llvm::raw_ostream *)*((void *)a2 + 4);
  }
  if (v7 <= *((void *)a2 + 3) - (void)result)
  {
    if (v7)
    {
      memcpy(result, v5, v7);
      double result = (llvm::raw_ostream *)(*((void *)a2 + 4) + v7);
      *((void *)a2 + 4) = result;
    }
  }
  else
  {
    llvm::raw_ostream::write(a2, (const char *)v5, v7);
    double result = (llvm::raw_ostream *)*((void *)a2 + 4);
  }
  if (*((llvm::raw_ostream **)a2 + 3) == result)
  {
    return llvm::raw_ostream::write(a2, ">", 1uLL);
  }
  else
  {
    *(unsigned char *)double result = 62;
    ++*((void *)a2 + 4);
  }
  return result;
}

char *sub_1CCCBE748()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::InvalidateAnalysisPass<(anonymous namespace):"
                    ":NoOpFunctionAnalysis>]";
  v10[1] = 123;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x7B) {
    uint64_t v1 = 123;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_381[v1];
  unint64_t v3 = 123 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  double result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

uint64_t sub_1CCCBE804()
{
  return 0;
}

void sub_1CCCBE80C()
{
}

uint64_t sub_1CCCBE880()
{
  return 1;
}

char *sub_1CCCBE888()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::RequireAnalysisPass<llvm::OptimizationRemarkE"
                    "mitterAnalysis, llvm::Function, llvm::AnalysisManager<Function>>]";
  v10[1] = 165;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0xA5) {
    uint64_t v1 = 165;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_382[v1];
  unint64_t v3 = 165 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  double result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

char *sub_1CCCBE944(char **a1, void *a2)
{
  uint64_t v2 = (a1[1] - *a1) >> 3;
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 61) {
    abort();
  }
  uint64_t v6 = a1[2] - *a1;
  if (v6 >> 2 > v3) {
    unint64_t v3 = v6 >> 2;
  }
  if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v7 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v7 = v3;
  }
  uint64_t v21 = a1 + 2;
  if (v7)
  {
    if (v7 >> 61) {
      sub_1CB833614();
    }
    uint64_t v8 = (char *)operator new(8 * v7);
  }
  else
  {
    uint64_t v8 = 0;
  }
  uint64_t v9 = &v8[8 * v2];
  uint64_t v10 = &v8[8 * v7];
  *(void *)uint64_t v9 = *a2;
  int v11 = v9 + 8;
  *a2 = 0;
  v19.i64[1] = (uint64_t)(v9 + 8);
  long long v20 = v10;
  uint64_t v13 = *a1;
  uint64_t v12 = a1[1];
  if (v12 == *a1)
  {
    int64x2_t v15 = vdupq_n_s64((unint64_t)v12);
  }
  else
  {
    do
    {
      uint64_t v14 = *((void *)v12 - 1);
      v12 -= 8;
      *(void *)uint64_t v12 = 0;
      *((void *)v9 - 1) = v14;
      v9 -= 8;
    }
    while (v12 != v13);
    int64x2_t v15 = *(int64x2_t *)a1;
    int v11 = (char *)v19.i64[1];
    uint64_t v10 = v20;
  }
  *a1 = v9;
  a1[1] = v11;
  int64x2_t v19 = v15;
  unsigned int v16 = a1[2];
  a1[2] = v10;
  long long v20 = v16;
  uint64_t v18 = v15.i64[0];
  sub_1CCCBEA50((uint64_t)&v18);
  return v11;
}

uint64_t sub_1CCCBEA50(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    uint64_t v4 = *(void *)(i - 8);
    *(void *)(i - 8) = 0;
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1CCCBEACC(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)(result + 296))
    {
      sub_1CCCB7370();
      uint64_t v1 = 0;
      operator new();
    }
  }
  return result;
}

uint64_t sub_1CCCBEBF8(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)(result + 440))
    {
      sub_1CCCB7370();
      uint64_t v1 = 0;
      operator new();
    }
  }
  return result;
}

char *sub_1CCCBED2C(char **a1, void *a2)
{
  uint64_t v2 = (a1[1] - *a1) >> 3;
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 61) {
    abort();
  }
  uint64_t v6 = a1[2] - *a1;
  if (v6 >> 2 > v3) {
    unint64_t v3 = v6 >> 2;
  }
  if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v7 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v7 = v3;
  }
  uint64_t v21 = a1 + 2;
  if (v7)
  {
    if (v7 >> 61) {
      sub_1CB833614();
    }
    uint64_t v8 = (char *)operator new(8 * v7);
  }
  else
  {
    uint64_t v8 = 0;
  }
  uint64_t v9 = &v8[8 * v2];
  uint64_t v10 = &v8[8 * v7];
  *(void *)uint64_t v9 = *a2;
  int v11 = v9 + 8;
  *a2 = 0;
  v19.i64[1] = (uint64_t)(v9 + 8);
  long long v20 = v10;
  uint64_t v13 = *a1;
  uint64_t v12 = a1[1];
  if (v12 == *a1)
  {
    int64x2_t v15 = vdupq_n_s64((unint64_t)v12);
  }
  else
  {
    do
    {
      uint64_t v14 = *((void *)v12 - 1);
      v12 -= 8;
      *(void *)uint64_t v12 = 0;
      *((void *)v9 - 1) = v14;
      v9 -= 8;
    }
    while (v12 != v13);
    int64x2_t v15 = *(int64x2_t *)a1;
    int v11 = (char *)v19.i64[1];
    uint64_t v10 = v20;
  }
  *a1 = v9;
  a1[1] = v11;
  int64x2_t v19 = v15;
  unsigned int v16 = a1[2];
  a1[2] = v10;
  long long v20 = v16;
  uint64_t v18 = v15.i64[0];
  sub_1CCCBEE38((uint64_t)&v18);
  return v11;
}

uint64_t sub_1CCCBEE38(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    uint64_t v4 = *(void *)(i - 8);
    *(void *)(i - 8) = 0;
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1CCCBEEB8()
{
}

double sub_1CCCBEECC@<D0>(uint64_t a1@<X8>)
{
  *(void *)(a1 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
  *(void *)a1 = a1 + 32;
  *(void *)(a1 + 8) = a1 + 32;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 48) = a1 + 80;
  *(void *)(a1 + 56) = a1 + 80;
  *(void *)(a1 + 64) = 2;
  *(_DWORD *)(a1 + 72) = 0;
  *(void *)&double result = 0x100000002;
  *(void *)(a1 + 16) = 0x100000002;
  return result;
}

llvm::raw_ostream *sub_1CCCBEF0C(uint64_t a1, llvm::raw_ostream *a2, uint64_t (*a3)(uint64_t, const char *, uint64_t), uint64_t a4)
{
  uint64_t v6 = (const void *)a3(a4, "NoOpLoopNestPass", 16);
  size_t v7 = v5;
  double result = (llvm::raw_ostream *)*((void *)a2 + 4);
  if (v5 <= *((void *)a2 + 3) - (void)result)
  {
    if (v5)
    {
      double result = (llvm::raw_ostream *)memcpy(result, v6, v5);
      *((void *)a2 + 4) += v7;
    }
  }
  else
  {
    return llvm::raw_ostream::write(a2, (const char *)v6, v5);
  }
  return result;
}

const char *sub_1CCCBEFA0()
{
  return "NoOpLoopNestPass";
}

uint64_t sub_1CCCBEFB0()
{
  return 0;
}

void sub_1CCCBEFBC()
{
}

void sub_1CCCBEFD0()
{
}

llvm::raw_ostream *sub_1CCCBF040(uint64_t a1, llvm::raw_ostream *a2, uint64_t (*a3)(uint64_t, const char *, uint64_t), uint64_t a4)
{
  size_t v5 = (const void *)a3(a4, "NoOpLoopAnalysis", 16);
  size_t v7 = v6;
  uint64_t v8 = (void *)*((void *)a2 + 4);
  if (*((void *)a2 + 3) - (void)v8 > 7uLL)
  {
    void *v8 = 0x3C65726975716572;
    double result = (llvm::raw_ostream *)(*((void *)a2 + 4) + 8);
    *((void *)a2 + 4) = result;
  }
  else
  {
    llvm::raw_ostream::write(a2, "require<", 8uLL);
    double result = (llvm::raw_ostream *)*((void *)a2 + 4);
  }
  if (v7 <= *((void *)a2 + 3) - (void)result)
  {
    if (v7)
    {
      memcpy(result, v5, v7);
      double result = (llvm::raw_ostream *)(*((void *)a2 + 4) + v7);
      *((void *)a2 + 4) = result;
    }
  }
  else
  {
    llvm::raw_ostream::write(a2, (const char *)v5, v7);
    double result = (llvm::raw_ostream *)*((void *)a2 + 4);
  }
  if (*((llvm::raw_ostream **)a2 + 3) == result)
  {
    return llvm::raw_ostream::write(a2, ">", 1uLL);
  }
  else
  {
    *(unsigned char *)double result = 62;
    ++*((void *)a2 + 4);
  }
  return result;
}

char *sub_1CCCBF168()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::RequireAnalysisPass<(anonymous namespace)::No"
                    "OpLoopAnalysis, llvm::Loop, llvm::AnalysisManager<Loop, LoopStandardAnalysisResults &>, llvm::LoopSt"
                    "andardAnalysisResults &, llvm::LPMUpdater &>]";
  v10[1] = 245;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0xF5) {
    uint64_t v1 = 245;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_417[v1];
  unint64_t v3 = 245 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  double result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

uint64_t sub_1CCCBF224()
{
  return 0;
}

void sub_1CCCBF230()
{
}

void sub_1CCCBF244(uint64_t a1@<X8>)
{
  *(void *)(a1 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
  *(void *)a1 = a1 + 32;
  *(void *)(a1 + 8) = a1 + 32;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v2 = a1 + 80;
  *(void *)(a1 + 48) = v2;
  *(void *)(a1 + 56) = v2;
  *(void *)(a1 + 64) = 2;
  *(_DWORD *)(a1 + 72) = 0;
  *(void *)(a1 + 16) = 0x100000002;
  sub_1CBFA16F4((uint64_t *)a1, (uint64_t)&unk_1EA61DF00);
}

llvm::raw_ostream *sub_1CCCBF290(uint64_t a1, llvm::raw_ostream *a2, uint64_t (*a3)(uint64_t, const char *, uint64_t), uint64_t a4)
{
  size_t v5 = (const void *)a3(a4, "NoOpLoopAnalysis", 16);
  size_t v7 = v6;
  uint64_t v8 = *((void *)a2 + 4);
  if ((unint64_t)(*((void *)a2 + 3) - v8) > 0xA)
  {
    *(_DWORD *)(v8 + 7) = 1013281889;
    *(void *)uint64_t v8 = *(void *)"invalidate<";
    double result = (llvm::raw_ostream *)(*((void *)a2 + 4) + 11);
    *((void *)a2 + 4) = result;
  }
  else
  {
    llvm::raw_ostream::write(a2, "invalidate<", 0xBuLL);
    double result = (llvm::raw_ostream *)*((void *)a2 + 4);
  }
  if (v7 <= *((void *)a2 + 3) - (void)result)
  {
    if (v7)
    {
      memcpy(result, v5, v7);
      double result = (llvm::raw_ostream *)(*((void *)a2 + 4) + v7);
      *((void *)a2 + 4) = result;
    }
  }
  else
  {
    llvm::raw_ostream::write(a2, (const char *)v5, v7);
    double result = (llvm::raw_ostream *)*((void *)a2 + 4);
  }
  if (*((llvm::raw_ostream **)a2 + 3) == result)
  {
    return llvm::raw_ostream::write(a2, ">", 1uLL);
  }
  else
  {
    *(unsigned char *)double result = 62;
    ++*((void *)a2 + 4);
  }
  return result;
}

char *sub_1CCCBF3C0()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::InvalidateAnalysisPass<(anonymous namespace):"
                    ":NoOpLoopAnalysis>]";
  v10[1] = 119;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x77) {
    uint64_t v1 = 119;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_418[v1];
  unint64_t v3 = 119 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  double result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

uint64_t sub_1CCCBF47C()
{
  return 0;
}

void sub_1CCCBF484()
{
}

void sub_1CCCBF50C()
{
}

unint64_t *sub_1CCCBF570(uint64_t a1)
{
  uint64_t v4 = &llvm::GlobalsAA::Key;
  unint64_t v3 = &llvm::AAManager::Key;
  uint64_t v1 = sub_1CCCBF76C((_DWORD *)(a1 + 8), &v4) + 1;
  double result = (unint64_t *)sub_1CCCBF5D8(v1, &v3);
  if ((result & 1) == 0) {
    return sub_1CCCBF660(v1, (uint64_t)v3);
  }
  return result;
}

BOOL sub_1CCCBF5D8(unint64_t *a1, void *a2)
{
  unint64_t v2 = *a1;
  if ((*a1 & 4) != 0)
  {
    uint64_t v4 = *(unint64_t **)(v2 & 0xFFFFFFFFFFFFFFF8);
    unint64_t v3 = &v4[*(unsigned int *)((v2 & 0xFFFFFFFFFFFFFFF8) + 8)];
  }
  else
  {
    unint64_t v3 = &a1[v2 > 7];
    uint64_t v4 = a1;
  }
  if (v4 != v3)
  {
    while (*v4 != *a2)
    {
      if (++v4 == v3)
      {
        uint64_t v4 = v3;
        break;
      }
    }
  }
  if ((v2 & 4) != 0) {
    uint64_t v5 = *(void *)(v2 & 0xFFFFFFFFFFFFFFF8) + 8 * *(unsigned int *)((v2 & 0xFFFFFFFFFFFFFFF8) + 8);
  }
  else {
    uint64_t v5 = (uint64_t)&a1[v2 > 7];
  }
  return v4 != (unint64_t *)v5;
}

unint64_t *sub_1CCCBF660(unint64_t *result, uint64_t a2)
{
  unint64_t v2 = *result;
  if (*result > 7)
  {
    if ((v2 & 4) == 0) {
      operator new();
    }
    unint64_t v3 = v2 & 0xFFFFFFFFFFFFFFF8;
    unsigned int v4 = *(_DWORD *)((v2 & 0xFFFFFFFFFFFFFFF8) + 8);
    if (v4 >= *(_DWORD *)(v3 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)v3 + 8 * v4) = a2;
    ++*(_DWORD *)(v3 + 8);
  }
  else
  {
    unint64_t *result = a2 & 0xFFFFFFFFFFFFFFFBLL;
  }
  return result;
}

void *sub_1CCCBF76C(_DWORD *a1, void *a2)
{
  unint64_t v7 = 0;
  char v4 = sub_1CBFA5BF8((uint64_t)a1, a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CCCBF7CC(a1, (uint64_t)a2, a2, v7);
    *uint64_t v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

void *sub_1CCCBF7CC(_DWORD *a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *a1 >> 1;
  if (*a1) {
    uint64_t v7 = 2;
  }
  else {
    uint64_t v7 = a1[4];
  }
  if (4 * v6 + 4 >= (3 * v7))
  {
    uint64_t v7 = (2 * v7);
  }
  else if ((int)v7 + ~v6 - a1[1] > v7 >> 3)
  {
    goto LABEL_6;
  }
  sub_1CCCBF890((uint64_t)a1, v7);
  uint64_t v9 = 0;
  sub_1CBFA5BF8((uint64_t)a1, a3, &v9);
  a4 = v9;
LABEL_6:
  *a1 += 2;
  if (*a4 != -4096) {
    --a1[1];
  }
  return a4;
}

uint64_t sub_1CCCBF890(uint64_t a1, uint64_t a2)
{
  void v27[4] = *MEMORY[0x1E4F143B8];
  if (a2 >= 3)
  {
    unint64_t v11 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v12 = v11 | (v11 >> 2) | ((v11 | (v11 >> 2)) >> 4);
    int v13 = ((v12 | (v12 >> 8)) >> 16) | v12 | (v12 >> 8);
    if ((v13 + 1) > 0x40) {
      a2 = (v13 + 1);
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    uint64_t v14 = *(void **)(a1 + 8);
    uint64_t v26 = a1;
    uint64_t v15 = *(unsigned int *)(a1 + 16);
    if (a2 > 2)
    {
      uint64_t v21 = a2;
      *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
      *(void *)(v26 + 16) = v21;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CCCBFA78(v26, v14, &v14[2 * v15]);
    JUMPOUT(0x1D25D9CD0);
  }
  char v2 = 0;
  uint64_t v3 = a1 + 8;
  char v4 = v27;
  uint64_t v5 = 1;
  int v6 = (void *)(a1 + 8);
  do
  {
    char v7 = v2;
    if ((*v6 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      *char v4 = *v6;
      uint64_t v10 = v6[1];
      uint64_t v9 = v6 + 1;
      v4[1] = v10;
      void *v9 = 0;
      uint64_t v22 = a2;
      int v23 = v4 + 2;
      uint64_t v24 = v5;
      uint64_t v25 = a1;
      sub_1CBFA5CA8(v9);
      char v4 = v23;
      uint64_t v5 = v24;
      a2 = v22;
      a1 = v25;
    }
    int v6 = (void *)(v3 + 16 * v5);
    char v2 = 1;
    uint64_t v5 = 2;
  }
  while ((v7 & 1) == 0);
  if (a2 > 2)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v16 = a2;
    uint64_t v17 = a1;
    uint64_t v18 = v4;
    int64x2_t v19 = operator new(16 * a2, (std::align_val_t)8uLL);
    char v4 = v18;
    long long v20 = v19;
    a1 = v17;
    *(void *)(v17 + 8) = v20;
    *(void *)(v17 + 16) = v16;
  }
  return sub_1CCCBFA78(a1, v27, v4);
}

uint64_t sub_1CCCBFA78(uint64_t result, void *a2, void *a3)
{
  int v3 = *(_DWORD *)result;
  *(void *)double result = *(_DWORD *)result & 1;
  if (v3)
  {
    char v4 = (void *)(result + 8);
    uint64_t v5 = (void *)(result + 40);
  }
  else
  {
    uint64_t v6 = *(unsigned int *)(result + 16);
    if (!v6) {
      goto LABEL_4;
    }
    char v4 = *(void **)(result + 8);
    uint64_t v5 = &v4[2 * v6];
  }
  do
  {
    *char v4 = -4096;
    v4 += 2;
  }
  while (v4 != v5);
LABEL_4:
  if (a2 != a3)
  {
    char v7 = a2 + 1;
    do
    {
      uint64_t v8 = (_DWORD *)result;
      if ((*(v7 - 1) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        unint64_t v12 = 0;
        sub_1CBFA5BF8(result, v7 - 1, &v12);
        uint64_t v9 = v12;
        *unint64_t v12 = *(v7 - 1);
        v9[1] = *v7;
        *char v7 = 0;
        *v8 += 2;
        sub_1CBFA5CA8(v7);
      }
      uint64_t v10 = v7 + 1;
      v7 += 2;
      double result = (uint64_t)v8;
    }
    while (v10 != a3);
  }
  return result;
}

void sub_1CCCBFB64()
{
}

void sub_1CCCBFD94()
{
}

void sub_1CCCBFFC4()
{
}

void sub_1CCCC01F4(uint64_t a1)
{
  v2[12] = *MEMORY[0x1E4F143B8];
  v2[0] = *(void *)(a1 + 8);
  v2[1] = 1;
  for (uint64_t i = 2; i != 6; i += 2)
    v2[i] = -4096;
  operator new();
}

void *sub_1CCCC033C(void *result, unsigned int *a2)
{
  char v2 = (unsigned int *)result;
  unsigned int v3 = *a2;
  *a2 = *(_DWORD *)result & 0xFFFFFFFE | *a2 & 1;
  unsigned int v4 = *((_DWORD *)result + 1);
  *(_DWORD *)double result = v3 & 0xFFFFFFFE | *(_DWORD *)result & 1;
  *((_DWORD *)result + 1) = a2[1];
  a2[1] = v4;
  unsigned int v5 = *a2;
  if (*(_DWORD *)result)
  {
    if ((v5 & 1) == 0)
    {
      char v7 = a2;
      goto LABEL_7;
    }
    char v17 = 0;
    uint64_t v18 = 0;
    int64x2_t v19 = result + 1;
    long long v20 = (int *)(a2 + 2);
    while (1)
    {
      char v21 = v17;
      double result = &v19[2 * v18];
      uint64_t v22 = (uint64_t *)&v20[4 * v18];
      uint64_t v23 = *result;
      uint64_t v24 = *v22;
      if (*result != -4096 && v23 != -8192 && v24 != -4096 && v24 != -8192) {
        break;
      }
      unint64_t *result = v24;
      uint64_t *v22 = v23;
      if ((v23 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t v28 = result[1];
        uint64_t v25 = result + 1;
        v22[1] = v28;
        void *v25 = 0;
        goto LABEL_22;
      }
      if ((v24 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t v27 = v22[1];
        uint64_t v26 = v22 + 1;
        result[1] = v27;
        *uint64_t v26 = 0;
        uint64_t v25 = v26;
        goto LABEL_22;
      }
LABEL_23:
      char v17 = 1;
      uint64_t v18 = 1;
      if (v21) {
        return result;
      }
    }
    long long v29 = *(_OWORD *)result;
    result[1] = 0;
    unint64_t *result = v24;
    sub_1CB9138A0(result + 1, v22 + 1);
    uint64_t *v22 = v23;
    sub_1CB9138A0(v22 + 1, (uint64_t *)&v29 + 1);
    uint64_t v25 = (void *)&v29 + 1;
LABEL_22:
    double result = sub_1CBFA5CA8(v25);
    goto LABEL_23;
  }
  if ((v5 & 1) == 0)
  {
    uint64_t v6 = result[1];
    result[1] = *((void *)a2 + 1);
    *((void *)a2 + 1) = v6;
    LODWORD(v6) = *((_DWORD *)result + 4);
    *((_DWORD *)result + 4) = a2[4];
    a2[4] = v6;
    return result;
  }
  unsigned int v5 = *(_DWORD *)result;
  char v7 = (unsigned int *)result;
  char v2 = a2;
LABEL_7:
  char v8 = 0;
  uint64_t v9 = 0;
  uint64_t v10 = v7 + 2;
  long long v29 = *(_OWORD *)(v7 + 2);
  *char v7 = v5 | 1;
  unint64_t v11 = v2 + 2;
  do
  {
    char v12 = v8;
    int v13 = &v10[2 * v9];
    double result = &v11[v9];
    uint64_t v14 = *result;
    void *v13 = *result;
    if ((v14 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v16 = result[1];
      uint64_t v15 = result + 1;
      v13[1] = v16;
      void *v15 = 0;
      double result = sub_1CBFA5CA8(v15);
    }
    char v8 = 1;
    uint64_t v9 = 1;
  }
  while ((v12 & 1) == 0);
  *v2 &= ~1u;
  *unint64_t v11 = v29;
  return result;
}

void sub_1CCCC053C(uint64_t a1)
{
  *(void *)a1 = &unk_1F2639B58;
  sub_1CCCC05A8((int *)(a1 + 16));

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCCC05A0()
{
}

int *sub_1CCCC05A8(int *result)
{
  int v1 = *result;
  if (*result)
  {
    char v2 = result + 2;
    uint64_t v3 = 2;
  }
  else
  {
    uint64_t v3 = result[4];
    if (!v3) {
      goto LABEL_7;
    }
    char v2 = (int *)*((void *)result + 1);
  }
  unsigned int v4 = v2 + 2;
  uint64_t v5 = 16 * v3;
  do
  {
    uint64_t v6 = *(v4 - 1);
    if (v6 != -4096 && v6 != -8192)
    {
      uint64_t v9 = result;
      uint64_t v7 = v5;
      char v8 = v4;
      sub_1CBFA5CA8(v4);
      uint64_t v5 = v7;
      unsigned int v4 = v8;
      double result = v9;
    }
    v4 += 2;
    v5 -= 16;
  }
  while (v5);
  int v1 = *result;
LABEL_7:
  if ((v1 & 1) == 0)
  {
    uint64_t v10 = result;
    MEMORY[0x1D25D9CD0](*((void *)result + 1), 8);
    return v10;
  }
  return result;
}

void sub_1CCCC064C()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_1CCCC0764(uint64_t a1)
{
  v2[12] = *MEMORY[0x1E4F143B8];
  v2[0] = *(void *)(a1 + 8);
  v2[1] = 1;
  for (uint64_t i = 2; i != 6; i += 2)
    v2[i] = -4096;
  operator new();
}

void sub_1CCCC08AC(uint64_t a1)
{
  *(void *)a1 = &unk_1F2639C08;
  sub_1CCCC05A8((int *)(a1 + 16));

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCCC0910()
{
}

void sub_1CCCC0918()
{
}

void sub_1CCCC09A0(void *a1)
{
  *a1 = &unk_1F2639C60;
  uint64_t v1 = a1[1];
  if (v1)
  {
    uint64_t v2 = a1[1];
    sub_1CC0799B4((_DWORD *)(v1 + 48));
    sub_1CC079A08((_DWORD *)(v2 + 24));
  }

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCCC0A2C()
{
}

void sub_1CCCC0A34()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

uint64_t sub_1CCCC0B4C(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  if (!a4) {
    return 0;
  }
  memset(v9, 0, sizeof(v9));
  uint64_t v6 = (uint64_t *)(a3 + 24);
  uint64_t v7 = 32 * a4;
  while (!sub_1CCC9EB34(*v6, a1, a2, (uint64_t)v9, 0, 0))
  {
    v6 += 4;
    v7 -= 32;
    if (!v7)
    {
      uint64_t v10 = (void **)v9;
      sub_1CCB7AA60(&v10);
      return 0;
    }
  }
  uint64_t v10 = (void **)v9;
  sub_1CCB7AA60(&v10);
  return 1;
}

void *sub_1CCCC0BF8(void *a1, uint64_t a2, unint64_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a3)
  {
    if (a3 >= 0x666666666666667) {
      abort();
    }
    uint64_t v6 = 5 * a3;
    uint64_t v7 = (char *)operator new(40 * a3);
    *a1 = v7;
    a1[1] = v7;
    a1[2] = &v7[8 * v6];
    sub_1CD73C0E8(a1, a2, a2 + 8 * v6);
  }
  return a1;
}

uint64_t sub_1CCCC0C78(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a4)
  {
    v13[0] = v14;
    v13[1] = (void *)0x600000000;
    v14[12] = 0;
    memset(v15, 0, sizeof(v15));
    uint64_t v6 = (uint64_t *)(a3 + 24);
    uint64_t v7 = 32 * a4 - 32;
    do
    {
      uint64_t v8 = *v6;
      v6 += 4;
      char v9 = sub_1CCCAEBB0(v8, a1, a2, (uint64_t)v13, 0, 0);
      if (v9) {
        break;
      }
      uint64_t v10 = v7;
      v7 -= 32;
    }
    while (v10);
    char v12 = (void **)&v15[1] + 1;
    sub_1CCCB7490(&v12);
    char v12 = (void **)v15;
    sub_1CCCB7538(&v12);
    if (v13[0] == v14)
    {
      if (v9) {
        return 1;
      }
    }
    else
    {
      free(v13[0]);
      if (v9) {
        return 1;
      }
    }
  }
  return 0;
}

void sub_1CCCC0D9C(uint64_t a1, unint64_t a2)
{
  if (HIDWORD(a2)) {
    sub_1CD0A88F0(a2);
  }
  uint64_t v3 = *(unsigned int *)(a1 + 12);
  if (v3 == -1) {
    sub_1CD0A89A8(0xFFFFFFFFuLL);
  }
  unint64_t v4 = (2 * v3) | 1;
  if (v4 <= a2) {
    unint64_t v4 = a2;
  }
  if (v4 >= 0xFFFFFFFF) {
    uint64_t v5 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v5 = v4;
  }
  uint64_t v6 = malloc_type_malloc(32 * v5, 0x4065EBACuLL);
  if (!v6) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  uint64_t v7 = v6;
  uint64_t v8 = *(void **)a1;
  uint64_t v9 = *(unsigned int *)(a1 + 8);
  if (v9)
  {
    uint64_t v10 = 32 * v9;
    unint64_t v11 = v6;
    do
    {
      char v12 = (void *)v8[3];
      if (v12)
      {
        if (v8 == v12)
        {
          v11[3] = v11;
          (*(void (**)(void, void *))(*(void *)v8[3] + 24))(v8[3], v11);
        }
        else
        {
          v11[3] = v12;
          v8[3] = 0;
        }
      }
      else
      {
        v11[3] = 0;
      }
      v8 += 4;
      v11 += 4;
      v10 -= 32;
    }
    while (v10);
    uint64_t v8 = *(void **)a1;
    uint64_t v13 = *(unsigned int *)(a1 + 8);
    if (v13)
    {
      uint64_t v14 = 4 * v13;
      uint64_t v15 = v8 - 4;
      do
      {
        uint64_t v16 = (void *)v15[v14 + 3];
        if (&v15[v14] == v16)
        {
          (*(void (**)(void *))(v15[v14] + 32))(&v15[v14]);
        }
        else if (v16)
        {
          (*(void (**)(void *))(*v16 + 40))(v16);
        }
        v14 -= 4;
      }
      while (v14 * 8);
      uint64_t v8 = *(void **)a1;
    }
  }
  if (v8 != (void *)(a1 + 16)) {
    free(v8);
  }
  *(void *)a1 = v7;
  *(_DWORD *)(a1 + 12) = v5;
}

void sub_1CCCC0F4C()
{
  operator new();
}

void sub_1CCCC0F74()
{
  operator new();
}

void sub_1CCCC0FB4(uint64_t a1@<X8>)
{
  *(void *)(v1 + 8) = a1;
}

uint64_t sub_1CCCC0FC0@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  *a2 = result;
  *(void *)(v2 + 8) = a2 + 1;
  return result;
}

void sub_1CCCC0FCC()
{
  operator new();
}

char *sub_1CCCC0FF8(uint64_t a1, ...)
{
  va_start(va, a1);
  return sub_1CCCB75E0(v1, (uint64_t *)va);
}

void sub_1CCCC1010()
{
  operator new();
}

uint64_t sub_1CCCC1060(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t result = a10;
  *(void *)(v10 + 80) = a1;
  return result;
}

char *sub_1CCCC1074(uint64_t a1, ...)
{
  va_start(va, a1);
  return sub_1CC9472B0(v1, (uint64_t *)va);
}

void sub_1CCCC108C()
{
  operator new();
}

uint64_t sub_1CCCC10C8(uint64_t a1, int a2)
{
  return sub_1CB8F8DF4(v2, a2, 0);
}

char *sub_1CCCC10E0(uint64_t a1, ...)
{
  va_start(va, a1);
  return sub_1CCCBE944((char **)(v1 + 72), (uint64_t *)va);
}

uint64_t sub_1CCCC10F8@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  *a2 = result;
  *(void *)(v2 + 80) = a2 + 1;
  return result;
}

void sub_1CCCC1104()
{
  operator new();
}

void sub_1CCCC111C()
{
  operator new();
}

uint64_t sub_1CCCC1140(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t result = a10;
  *(void *)(v10 + 104) = a1;
  return result;
}

uint64_t sub_1CCCC1154()
{
  return 24;
}

char *sub_1CCCC1164(uint64_t a1, ...)
{
  va_start(va, a1);
  return sub_1CC946FA0(v1, (uint64_t *)va);
}

__n128 sub_1CCCC117C()
{
  *(void *)uint64_t v0 = 0;
  *(void *)(v0 + 8) = 0;
  __n128 result = *(__n128 *)(v0 + 24);
  *(void *)(v0 + 16) = 0;
  *(void *)(v0 + 24) = 0;
  *(void *)(v0 + 32) = 0;
  *(void *)(v0 + 40) = 0;
  return result;
}

__n128 sub_1CCCC11AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, long long a9, uint64_t a10, __n128 a11, uint64_t a12)
{
  *(void *)(a1 + 24) = a10;
  *(_OWORD *)(a1 + 8) = a9;
  __n128 result = a11;
  *(void *)(a1 + 48) = a12;
  *(__n128 *)(a1 + 32) = a11;
  return result;
}

uint64_t sub_1CCCC11EC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t result = a9;
  *(void *)(v9 + 8) = a1;
  return result;
}

uint64_t sub_1CCCC1200(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  uint64_t result = a13;
  *(void *)(v13 + 8) = a1;
  return result;
}

uint64_t sub_1CCCC1214(uint64_t a1)
{
  uint64_t result = *(void *)(v2 - 24);
  *(void *)(v1 + 8) = a1;
  *(void *)(v2 - 24) = 0;
  return result;
}

void sub_1CCCC1250(uint64_t a1@<X8>)
{
  *(void *)(v1 + 8) = a1;
  *(void *)(v2 - 24) = 0;
}

void sub_1CCCC125C(uint64_t a1@<X8>)
{
  *(void *)(v1 + 8) = a1;
}

void sub_1CCCC1268(uint64_t a1@<X8>)
{
  *(void *)(v1 + 8) = a1;
}

uint64_t sub_1CCCC1274(uint64_t a1)
{
  uint64_t result = *(void *)(v2 - 40);
  *(void *)(v1 + 8) = a1;
  *(void *)(v2 - 40) = 0;
  return result;
}

void sub_1CCCC1288()
{
  operator new();
}

uint64_t sub_1CCCC12A0()
{
  return 32;
}

void sub_1CCCC12B0()
{
  operator new();
}

uint64_t sub_1CCCC12C8()
{
  return v0 + 8;
}

uint64_t sub_1CCCC12D4(uint64_t result)
{
  *(void *)(result + 24) = *(void *)(v1 + 16);
  *(void *)(result + 31) = *(void *)(v1 + 23);
  return result;
}

void sub_1CCCC12EC(void *a1@<X8>)
{
  *a1 = v2;
  *(void *)(v1 + 8) = a1 + 1;
  *(void *)(v3 - 40) = 0;
}

uint64_t sub_1CCCC130C@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  *a2 = result;
  *(void *)(v2 + 104) = a2 + 1;
  return result;
}

uint64_t sub_1CCCC1318(uint64_t a1)
{
  return sub_1CD73A068(a1, 1);
}

uint64_t sub_1CCCC1330()
{
  return 40;
}

uint64_t sub_1CCCC1340()
{
  return 48;
}

char *sub_1CCCC1350(uint64_t a1, ...)
{
  va_start(va, a1);
  return sub_1CCCBED2C((char **)(v1 + 96), (uint64_t *)va);
}

__n128 sub_1CCCC1368(uint64_t a1)
{
  __n128 result = *v1;
  *(__n128 *)(a1 + 8) = *v1;
  *(void *)(a1 + 24) = v1[1].n128_u64[0];
  return result;
}

uint64_t sub_1CCCC137C(uint64_t result, __n128 a2, __n128 a3)
{
  *(__n128 *)(result + 8) = a2;
  *(__n128 *)(result + 24) = a3;
  return result;
}

uint64_t sub_1CCCC1388(uint64_t a1)
{
  uint64_t result = *(void *)(v2 - 40);
  *(void *)(v1 + 8) = a1;
  *(void *)(v2 - 40) = 0;
  return result;
}

void sub_1CCCC13B4()
{
}

void **LLVMRunPasses(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  MEMORY[0x1F4188790](a1, a2, a3, a4);
  uint64_t v5 = v4;
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  int v7 = *v6;
  int v8 = v6[1];
  v56[0] = (char *)v57;
  v56[1] = (char *)0x400000000;
  v57[16] = v58;
  v57[17] = 0x400000000;
  v58[16] = v59;
  v58[17] = 0x400000000;
  unsigned char v59[16] = v60;
  v59[17] = 0x400000000;
  v60[16] = v61;
  v60[17] = 0x400000000;
  v61[16] = v62;
  v61[17] = 0x400000000;
  v62[16] = v63;
  v62[17] = 0x400000000;
  v63[16] = v64;
  v63[17] = 0x400000000;
  v64[16] = v65;
  v64[17] = 0x400000000;
  v65[8] = 0u;
  int v66 = 0;
  int v67 = 32;
  long long v51 = *(_OWORD *)(v6 + 4);
  int v52 = *((_DWORD *)v6 + 5);
  v49[0] = 0;
  char v50 = 0;
  llvm::PassBuilder::PassBuilder((uint64_t)v55, v9, &v51, (uint64_t)v49, (uint64_t)v56);
  if (v50)
  {
    sub_1CD69E9BC((uint64_t)v49);
    char v50 = 0;
  }
  v41[0] = 0;
  v41[1] = 0;
  int v42 = 0;
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  int v45 = 0;
  uint64_t v46 = 0;
  uint64_t v47 = 0;
  int v48 = 0;
  v33[0] = 0;
  v33[1] = 0;
  int v34 = 0;
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  unsigned int v37 = 0;
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  int v40 = 0;
  v25[0] = 0;
  v25[1] = 0;
  int v26 = 0;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  int v29 = 0;
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  int v32 = 0;
  v18[0] = 0;
  v18[1] = 0;
  int v19 = 0;
  v20[0] = 0;
  v20[1] = 0;
  int v21 = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  int v24 = 0;
  llvm::PassBuilder::registerLoopAnalyses((uint64_t)v55, (uint64_t)v41);
  llvm::PassBuilder::registerFunctionAnalyses((uint64_t)v55, v33);
  llvm::PassBuilder::registerCGSCCAnalyses((uint64_t)v55, (uint64_t)v25);
  llvm::PassBuilder::registerModuleAnalyses((uint64_t)v55, v18);
  llvm::PassBuilder::crossRegisterProxies((uint64_t)v55, (uint64_t)v41, v33, (uint64_t)v25, v18);
  llvm::StandardInstrumentations::StandardInstrumentations((uint64_t)v54, v7 != 0, v8 != 0, 0);
  llvm::StandardInstrumentations::registerCallbacks((uint64_t)v54, (uint64_t)v56, v33);
  memset(v17, 0, sizeof(v17));
  if (v8)
  {
    LOBYTE(v53) = 1;
    sub_1CD69E654();
  }
  if (v5) {
    size_t v10 = strlen(v5);
  }
  else {
    size_t v10 = 0;
  }
  llvm::PassBuilder::parsePassPipeline(v55, (uint64_t)v17, (uint64_t)v5, v10, &v53);
  unint64_t v11 = v53;
  if (!v53) {
    llvm::PassManager<llvm::Module,llvm::AnalysisManager<llvm::Module>>::run();
  }
  uint64_t v53 = (void **)v17;
  sub_1CCB7AA60(&v53);
  sub_1CD69FC40((uint64_t)v54);
  MEMORY[0x1D25D9CD0](v22, 8);
  sub_1CC5C4BBC(v20);
  sub_1CC5C4C3C((unsigned int *)v18);
  MEMORY[0x1D25D9CD0](v18[0], 8);
  sub_1CCB7ACBC(v25);
  MEMORY[0x1D25D9CD0](v38, 8);
  uint64_t v12 = v35;
  if (v37)
  {
    uint64_t v14 = 32 * v37;
    uint64_t v15 = (uint64_t *)(v35 + 8);
    do
    {
      uint64_t v16 = *(v15 - 1);
      if (v16 != -4096 && v16 != -8192) {
        sub_1CBF5408C(v15);
      }
      v15 += 4;
      v14 -= 32;
    }
    while (v14);
    uint64_t v12 = v35;
  }
  MEMORY[0x1D25D9CD0](v12, 8);
  sub_1CBF54128((unsigned int *)v33);
  MEMORY[0x1D25D9CD0](v33[0], 8);
  sub_1CCB7AD88(v41);
  sub_1CD69F0B8((uint64_t)v55);
  sub_1CD69FE9C(v56);
  return v11;
}

void LLVMCreatePassBuilderOptions()
{
}

uint64_t LLVMPassBuilderOptionsSetVerifyEach(uint64_t result, int a2)
{
  *(unsigned char *)(result + 1) = a2 != 0;
  return result;
}

BOOL *LLVMPassBuilderOptionsSetDebugLogging(BOOL *result, int a2)
{
  unint64_t *result = a2 != 0;
  return result;
}

uint64_t LLVMPassBuilderOptionsSetLoopInterleaving(uint64_t result, int a2)
{
  *(unsigned char *)(result + 4) = a2 != 0;
  return result;
}

uint64_t LLVMPassBuilderOptionsSetLoopVectorization(uint64_t result, int a2)
{
  *(unsigned char *)(result + 5) = a2 != 0;
  return result;
}

uint64_t LLVMPassBuilderOptionsSetSLPVectorization(uint64_t result, int a2)
{
  *(unsigned char *)(result + 6) = a2 != 0;
  return result;
}

uint64_t LLVMPassBuilderOptionsSetLoopUnrolling(uint64_t result, int a2)
{
  *(unsigned char *)(result + 7) = a2 != 0;
  return result;
}

uint64_t LLVMPassBuilderOptionsSetForgetAllSCEVInLoopUnroll(uint64_t result, int a2)
{
  *(unsigned char *)(result + 8) = a2 != 0;
  return result;
}

uint64_t LLVMPassBuilderOptionsSetLicmMssaOptCap(uint64_t result, int a2)
{
  *(_DWORD *)(result + 12) = a2;
  return result;
}

uint64_t LLVMPassBuilderOptionsSetLicmMssaNoAccForPromotionCap(uint64_t result, int a2)
{
  *(_DWORD *)(result + 16) = a2;
  return result;
}

uint64_t LLVMPassBuilderOptionsSetCallGraphProfile(uint64_t result, int a2)
{
  *(unsigned char *)(result + 20) = a2 != 0;
  return result;
}

uint64_t LLVMPassBuilderOptionsSetMergeFunctions(uint64_t result, int a2)
{
  *(unsigned char *)(result + 21) = a2 != 0;
  return result;
}

uint64_t LLVMDisposePassBuilderOptions(uint64_t result)
{
  if (result) {
    JUMPOUT(0x1D25D9CE0);
  }
  return result;
}

double llvm::PipelineTuningOptions::PipelineTuningOptions(llvm::PipelineTuningOptions *this)
{
  *(void *)&double result = 16777473;
  *(_DWORD *)this = 16777473;
  *((unsigned char *)this + 4) = byte_1EBD0B778;
  int v2 = dword_1EBD0B6B8;
  *((_DWORD *)this + 2) = dword_1EBD0B5F8;
  *((_DWORD *)this + 3) = v2;
  *((unsigned char *)this + 16) = 1;
  *((unsigned char *)this + 17) = byte_1EBD0A598;
  *((unsigned char *)this + 18) = byte_1EBD0A4D8;
  return result;
}

{
  double result;
  int v2;

  *(void *)&double result = 16777473;
  *(_DWORD *)this = 16777473;
  *((unsigned char *)this + 4) = byte_1EBD0B778;
  int v2 = dword_1EBD0B6B8;
  *((_DWORD *)this + 2) = dword_1EBD0B5F8;
  *((_DWORD *)this + 3) = v2;
  *((unsigned char *)this + 16) = 1;
  *((unsigned char *)this + 17) = byte_1EBD0A598;
  *((unsigned char *)this + 18) = byte_1EBD0A4D8;
  return result;
}

void llvm::PassBuilder::buildO1FunctionSimplificationPipeline(uint64_t a1@<X8>)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 16) = 0;
  *(_OWORD *)a1 = 0u;
  bzero(v1, 0x2C0uLL);
  v1[6] = v3;
  int v2 = 16;
  v3[16] = v5;
  v5[12] = 0u;
  int v4 = 8;
  int v6 = 0;
  int v7 = v9;
  int v8 = 16;
  memset(&v9[128], 0, 44);
  size_t v10 = v12;
  int v11 = 2;
  v12[1] = 0u;
  int v13 = 0;
  uint64_t v14 = &v16;
  int v15 = 2;
  sub_1CD71432C();
}

void llvm::PassBuilder::buildFunctionSimplificationPipeline(int a1@<W1>, uint64_t a2@<X8>)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (a1 == 1)
  {
    llvm::PassBuilder::buildO1FunctionSimplificationPipeline(a2);
  }
  *(void *)(a2 + 16) = 0;
  *(_OWORD *)a2 = 0u;
  bzero(v2, 0x2C0uLL);
  v2[6] = v4;
  int v3 = 16;
  v4[16] = &v6;
  long long v7 = 0u;
  int v5 = 8;
  int v8 = 0;
  uint64_t v9 = v11;
  int v10 = 16;
  memset(&v11[128], 0, 44);
  uint64_t v12 = v14;
  int v13 = 2;
  v14[1] = 0u;
  int v15 = 0;
  uint64_t v16 = &v18;
  int v17 = 2;
  sub_1CD71432C();
}

void llvm::PassBuilder::addRequiredLTOPreLinkPasses()
{
}

void llvm::PassBuilder::addPGOInstrPasses(uint64_t a1, uint64_t a2, uint64_t a3, char a4, char a5, uint64_t a6, uint64_t a7, uint64_t *a8)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if ((a5 & 1) == 0 && !byte_1EBD080D8)
  {
    if (HIDWORD(a3)) {
      int v11 = dword_1EBD08198;
    }
    else {
      int v11 = 325;
    }
    v18[0] = dword_1EBD08198;
    v18[1] = v11;
    char v19 = 1;
    char v20 = 0;
    char v21 = 0;
    char v22 = 0;
    char v23 = 0;
    char v24 = 0;
    char v25 = 0;
    char v26 = 0;
    char v27 = 0;
    char v28 = 0;
    char v29 = 0;
    char v30 = 0;
    char v31 = 0;
    int v32 = 0;
    char v33 = 0;
    char v34 = 1;
    llvm::ModuleInlinerWrapperPass::ModuleInlinerWrapperPass((uint64_t)&v35, (uint64_t)v18, 1, 0, 0);
  }
  if (a4)
  {
    v36[0] = a5;
    sub_1CD709598();
  }
  if (*(char *)(a6 + 23) < 0)
  {
    sub_1CB8BDF7C((uint64_t)v16, *(const void **)a6, *(void *)(a6 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v16 = *(_OWORD *)a6;
    uint64_t v17 = *(void *)(a6 + 16);
  }
  if (*(char *)(a7 + 23) < 0)
  {
    sub_1CB8BDF7C((uint64_t)__p, *(const void **)a7, *(void *)(a7 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a7;
    uint64_t v15 = *(void *)(a7 + 16);
  }
  uint64_t v12 = *a8;
  uint64_t v13 = v12;
  if (v12) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v12 + 8), 1u, memory_order_relaxed);
  }
  llvm::PGOInstrumentationUse::PGOInstrumentationUse((uint64_t)v36, (long long *)v16, (long long *)__p, a5, &v13);
  sub_1CD709624();
}

void llvm::PassBuilder::buildModuleSimplificationPipeline(uint64_t a1@<X0>, int a2@<W2>, void *a3@<X8>)
{
  a3[2] = 0;
  *a3 = 0;
  a3[1] = 0;
  if (!*(unsigned char *)(a1 + 128)) {
    goto LABEL_12;
  }
  if (a2 != 2 && *(unsigned char *)(a1 + 113)) {
    sub_1CD70A19C();
  }
  if (*(_DWORD *)(a1 + 104) == 3) {
    BOOL v4 = a2 != 2 || byte_1EBD08498 == 0;
  }
  else {
LABEL_12:
  }
    BOOL v4 = 0;
  if (a2 == 2 && !v4) {
    sub_1CD7094F8();
  }
  sub_1CD708A10();
}

void sub_1CCCC4480()
{
}

void llvm::PassBuilder::buildLTODefaultPipeline(void *a1@<X8>)
{
  uint64_t v1 = *MEMORY[0x1E4F143B8];
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_1CD707FB0();
}

void sub_1CCCC5A20()
{
  operator new();
}

uint64_t sub_1CCCC5A4C@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>, __n128 a3@<Q0>)
{
  *(__n128 *)(result + 8) = a3;
  *(void *)(result + 24) = a2;
  return result;
}

uint64_t sub_1CCCC5A6C()
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  int v4 = 0;
  int v3 = &v4;
  int v2 = 1;
  *(void *)&long long v1 = "Enable ML policy for inliner. Currently trained for -Oz only";
  *((void *)&v1 + 1) = 60;
  v5.n128_u64[0] = (unint64_t)v6;
  v6[0] = "default";
  v6[1] = 7;
  int v8 = "Heuristics-based inliner version.";
  uint64_t v9 = 33;
  int v10 = "development";
  uint64_t v11 = 11;
  int v12 = 2;
  uint64_t v13 = "Use development mode (runtime-loadable model).";
  uint64_t v14 = 46;
  int v7 = 0;
  uint64_t v15 = "release";
  uint64_t v16 = 7;
  int v17 = 1;
  uint64_t v18 = "Use release mode (AOT-compiled model).";
  uint64_t v19 = 38;
  v5.n128_u64[1] = 0x400000003;
  sub_1CD73F540(&v3, &v2, &v1, (uint64_t)&v5);
  if ((void *)v5.n128_u64[0] != v6) {
    free((void *)v5.n128_u64[0]);
  }
  __cxa_atexit((void (*)(void *))sub_1CD73C18C, &qword_1EBCEF960, &dword_1CB82C000);
  LOBYTE(v2) = 0;
  *(void *)&long long v1 = &v2;
  LODWORD(v3) = 1;
  int v4 = 1;
  v5.n128_u64[0] = (unint64_t)"Run synthetic function entry count generation pass";
  v5.n128_u64[1] = 50;
  sub_1CD462280((llvm::cl::Option *)&unk_1EBCEF420, "enable-npm-synthetic-counts", (unsigned char **)&v1, &v3, &v4, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCEF420, &dword_1CB82C000);
  LOBYTE(v4) = 1;
  *(void *)&long long v1 = &v4;
  LODWORD(v3) = 1;
  v5.n128_u64[0] = (unint64_t)"Enable inline deferral during PGO";
  v5.n128_u64[1] = 33;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBCEF4E0, "enable-npm-pgo-inline-deferral", (unsigned char **)&v1, &v3, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCEF4E0, &dword_1CB82C000);
  LOBYTE(v2) = 0;
  *(void *)&long long v1 = &v2;
  LODWORD(v3) = 1;
  int v4 = 1;
  v5.n128_u64[0] = (unint64_t)"Enable memory profiler";
  v5.n128_u64[1] = 22;
  sub_1CD73FA30((char **)&v1, &v3, &v4, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCEF5A0, &dword_1CB82C000);
  LOBYTE(v4) = 0;
  *(void *)&long long v1 = &v4;
  LODWORD(v3) = 1;
  v5.n128_u64[0] = (unint64_t)"Enable module inliner";
  v5.n128_u64[1] = 21;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBCEF660, "enable-module-inliner", (unsigned char **)&v1, &v3, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCEF660, &dword_1CB82C000);
  LOBYTE(v2) = 1;
  *(void *)&long long v1 = &v2;
  LODWORD(v3) = 1;
  int v4 = 1;
  v5.n128_u64[0] = (unint64_t)"Perform mandatory inlinings module-wide, before performing inlining.";
  v5.n128_u64[1] = 68;
  sub_1CD462280((llvm::cl::Option *)&unk_1EBCEF720, "mandatory-inlining-first", (unsigned char **)&v1, &v3, &v4, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCEF720, &dword_1CB82C000);
  LOBYTE(v2) = 1;
  *(void *)&long long v1 = &v2;
  LODWORD(v3) = 1;
  int v4 = 1;
  v5.n128_u64[0] = (unint64_t)"Enable non-trivial loop unswitching for -O3";
  v5.n128_u64[1] = 43;
  sub_1CD462280((llvm::cl::Option *)&unk_1EBCEF7E0, "enable-npm-O3-nontrivial-unswitch", (unsigned char **)&v1, &v3, &v4, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCEF7E0, &dword_1CB82C000);
  LOBYTE(v4) = 1;
  *(void *)&long long v1 = &v4;
  LODWORD(v3) = 1;
  v5.n128_u64[0] = (unint64_t)"Eagerly invalidate more analyses in default pipelines";
  v5.n128_u64[1] = 53;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBD0A458, "eagerly-invalidate-analyses", (unsigned char **)&v1, &v3, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBD0A458, &dword_1CB82C000);
  LOBYTE(v4) = 0;
  *(void *)&long long v1 = &v4;
  LODWORD(v3) = 1;
  v5.n128_u64[0] = (unint64_t)"Prevent running the simplification pipeline on a function more than once in the cas"
                                     "e that SCC mutations cause a function to be visited multiple times as long as the f"
                                     "unction has not been changed";
  v5.n128_u64[1] = 194;
  sub_1CD73FBC8((char **)&v1, &v3, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCEF8A0, &dword_1CB82C000);
  LOBYTE(v4) = 0;
  *(void *)&long long v1 = &v4;
  LODWORD(v3) = 1;
  v5.n128_u64[0] = (unint64_t)"Enable function merging as part of the optimization pipeline";
  v5.n128_u64[1] = 60;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBD0A518, "enable-merge-functions", (unsigned char **)&v1, &v3, &v5);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBD0A518, &dword_1CB82C000);
}

void llvm::IRChangedPrinter::~IRChangedPrinter(llvm::IRChangedPrinter *this)
{
  *(void *)this = &unk_1F263BCD0;
  long long v1 = (void **)((char *)this + 8);
  sub_1CB8338B8(&v1);
}

{
  void **v1;

  *(void *)this = &unk_1F263BCD0;
  long long v1 = (void **)((char *)this + 8);
  sub_1CB8338B8(&v1);
}

{
  void **v2;

  *(void *)this = &unk_1F263BCD0;
  int v2 = (void **)((char *)this + 8);
  sub_1CB8338B8(&v2);
  MEMORY[0x1D25D9CE0](this, 0x10A1C400037C305);
}

void llvm::IRChangedPrinter::registerCallbacks()
{
  if ((dword_1EBD0A718 - 1) <= 1) {
    llvm::ChangeReporter<std::string>::registerRequiredCallbacks();
  }
}

void sub_1CCCC5F10(llvm::raw_ostream *a1, uint64_t *a2)
{
  if (*a2) {
    (*(void (**)(uint64_t *__return_ptr))(*(void *)*a2 + 16))(&v50);
  }
  else {
    uint64_t v50 = 0;
  }
  int v4 = sub_1CCCC6C48(&v50);
  uint64_t v5 = v50;
  uint64_t v50 = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  if (v4)
  {
    uint64_t v6 = *a2;
    if (byte_1EBD06DE0)
    {
      if (v6) {
        (*(void (**)(uint64_t *__return_ptr))(*(void *)v6 + 16))(&v49);
      }
      else {
        uint64_t v49 = 0;
      }
      uint64_t v23 = sub_1CCCC6404(&v49, 0);
      uint64_t v24 = v49;
      uint64_t v49 = 0;
      if (v24) {
        (*(void (**)(uint64_t))(*(void *)v24 + 8))(v24);
      }
      char v25 = a1;
      char v26 = (const std::string *)v23;
      goto LABEL_24;
    }
    int v7 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v6 + 24))(v6);
    uint64_t v8 = *a2;
    if (v7 == &llvm::Any::TypeId<llvm::Module const*>::Id)
    {
      (*(void (**)(uint64_t))(*(void *)v8 + 24))(v8);
      char v26 = *(const std::string **)(*a2 + 8);
      char v25 = a1;
LABEL_24:
      sub_1CCCC7124(v25, v26);
      return;
    }
    uint64_t v9 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v8 + 24))(v8);
    uint64_t v10 = *a2;
    if (v9 == &llvm::Any::TypeId<llvm::Function const*>::Id)
    {
      (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
      sub_1CCCCF678(a1, *(llvm::Value **)(*a2 + 8));
      return;
    }
    uint64_t v11 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v10 + 24))(v10);
    uint64_t v12 = *a2;
    if (v11 != &llvm::Any::TypeId<llvm::LazyCallGraph::SCC const*>::Id)
    {
      (*(void (**)(uint64_t))(*(void *)v12 + 24))(v12);
      (*(void (**)(void))(*(void *)*a2 + 24))();
      uint64_t v13 = *(void *)(*a2 + 8);
      uint64_t v14 = *(uint64_t ****)(**(void **)(v13 + 32) + 56);
      if ((*((unsigned char *)v14 + 23) & 0x10) == 0)
      {
        std::string::size_type v47 = 0;
        uint64_t v46 = &byte_1CFBCE98E;
        goto LABEL_55;
      }
      uint64_t v15 = ***v14;
      uint64_t v16 = *(void *)(v15 + 152);
      uint64_t v17 = *(unsigned int *)(v15 + 168);
      if (v17)
      {
        LODWORD(v18) = (v17 - 1) & ((v14 >> 4) ^ (v14 >> 9));
        uint64_t v19 = (uint64_t ****)(v16 + 16 * v18);
        uint64_t v20 = *v19;
        if (*v19 == v14)
        {
LABEL_54:
          int v45 = v19[1];
          std::string::size_type v48 = (std::string::size_type)*v45;
          uint64_t v46 = (const std::string::value_type *)(v45 + 2);
          std::string::size_type v47 = v48;
LABEL_55:
          if (llvm::isFunctionInPrintList(v46, v47))
          {
            char v52 = 0;
            LOBYTE(__p) = 0;
            llvm::printLoop((llvm::Value ***)v13, a1, (uint64_t)&__p);
            if (v52 < 0) {
              operator delete(__p);
            }
          }
          return;
        }
        int v21 = 1;
        while (v20 != (uint64_t ***)-4096)
        {
          int v22 = v18 + v21++;
          uint64_t v18 = v22 & (v17 - 1);
          uint64_t v20 = *(uint64_t ****)(v16 + 16 * v18);
          if (v20 == v14)
          {
            uint64_t v19 = (uint64_t ****)(v16 + 16 * v18);
            goto LABEL_54;
          }
        }
      }
      uint64_t v19 = (uint64_t ****)(v16 + 16 * v17);
      goto LABEL_54;
    }
    (*(void (**)(uint64_t))(*(void *)v12 + 24))(v12);
    uint64_t v27 = *(void *)(*a2 + 8);
    uint64_t v28 = *(unsigned int *)(v27 + 16);
    if (!v28) {
      return;
    }
    uint64_t v29 = *(void *)(v27 + 8);
    uint64_t v30 = v29 + 8 * v28;
    do
    {
      char v31 = *(uint64_t ****)(*(void *)v29 + 8);
      if (v31) {
        BOOL v32 = *((unsigned char *)v31 + 16) == 3;
      }
      else {
        BOOL v32 = 0;
      }
      if (v32)
      {
        if ((*((_DWORD *)v31 + 5) & 0x7FFFFFF) != 0) {
          goto LABEL_39;
        }
      }
      else if (*((unsigned char *)v31 + 16) || v31[9] != (uint64_t **)(v31 + 9) || (*((unsigned char *)v31 + 34) & 0x80) != 0)
      {
LABEL_39:
        if ((*((unsigned char *)v31 + 23) & 0x10) != 0)
        {
          uint64_t v33 = ***v31;
          uint64_t v34 = *(void *)(v33 + 152);
          uint64_t v35 = *(unsigned int *)(v33 + 168);
          if (!v35) {
            goto LABEL_46;
          }
          LODWORD(v36) = (v35 - 1) & ((v31 >> 4) ^ (v31 >> 9));
          uint64_t v37 = (uint64_t ****)(v34 + 16 * v36);
          uint64_t v38 = *v37;
          if (*v37 != v31)
          {
            int v39 = 1;
            while (v38 != (uint64_t ***)-4096)
            {
              int v40 = v36 + v39++;
              uint64_t v36 = v40 & (v35 - 1);
              uint64_t v38 = *(uint64_t ****)(v34 + 16 * v36);
              if (v38 == v31)
              {
                uint64_t v37 = (uint64_t ****)(v34 + 16 * v36);
                goto LABEL_47;
              }
            }
LABEL_46:
            uint64_t v37 = (uint64_t ****)(v34 + 16 * v35);
          }
LABEL_47:
          int v41 = v37[1];
          std::string::size_type v44 = (std::string::size_type)*v41;
          int v42 = (const std::string::value_type *)(v41 + 2);
          std::string::size_type v43 = v44;
        }
        else
        {
          std::string::size_type v43 = 0;
          int v42 = &byte_1CFBCE98E;
        }
        if (llvm::isFunctionInPrintList(v42, v43)) {
          llvm::Function::print((const llvm::Module **)v31, a1, 0, 0, 0);
        }
      }
      v29 += 8;
    }
    while (v29 != v30);
  }
}

void llvm::PrintIRInstrumentation::~PrintIRInstrumentation(void **this)
{
}

{
  sub_1CD7485C0(this + 1);
}

uint64_t sub_1CCCC6404(void *a1, char a2)
{
  int v4 = (void *)(*(uint64_t (**)(void))(*(void *)*a1 + 24))(*a1);
  uint64_t v5 = *a1;
  if (v4 == &llvm::Any::TypeId<llvm::Module const*>::Id)
  {
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
    uint64_t v19 = *a1 + 8;
    return *(void *)v19;
  }
  uint64_t v6 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 24))(v5);
  uint64_t v7 = *a1;
  if (v6 != &llvm::Any::TypeId<llvm::Function const*>::Id)
  {
    uint64_t v8 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v7 + 24))(v7);
    uint64_t v9 = *a1;
    if (v8 != &llvm::Any::TypeId<llvm::LazyCallGraph::SCC const*>::Id)
    {
      (*(void (**)(uint64_t))(*(void *)v9 + 24))(v9);
      (*(void (**)(void))(*(void *)*a1 + 24))();
      uint64_t v10 = *(uint64_t ****)(**(void **)(*(void *)(*a1 + 8) + 32) + 56);
      if (a2) {
        goto LABEL_50;
      }
      if ((*((unsigned char *)v10 + 23) & 0x10) != 0)
      {
        uint64_t v11 = ***v10;
        uint64_t v12 = *(void *)(v11 + 152);
        uint64_t v13 = *(unsigned int *)(v11 + 168);
        if (v13)
        {
          LODWORD(v14) = (v13 - 1) & ((v10 >> 4) ^ (v10 >> 9));
          uint64_t v15 = (uint64_t ****)(v12 + 16 * v14);
          uint64_t v16 = *v15;
          if (*v15 != v10)
          {
            int v17 = 1;
            while (v16 != (uint64_t ***)-4096)
            {
              int v18 = v14 + v17++;
              uint64_t v14 = v18 & (v13 - 1);
              uint64_t v16 = *(uint64_t ****)(v12 + 16 * v14);
              if (v16 == v10) {
                goto LABEL_20;
              }
            }
            goto LABEL_47;
          }
LABEL_48:
          int v42 = v15[1];
          std::string::size_type v45 = (std::string::size_type)*v42;
          std::string::size_type v43 = (const std::string::value_type *)(v42 + 2);
          std::string::size_type v44 = v45;
          goto LABEL_49;
        }
        goto LABEL_47;
      }
      goto LABEL_53;
    }
    (*(void (**)(uint64_t))(*(void *)v9 + 24))(v9);
    uint64_t v24 = *(void *)(*a1 + 8);
    uint64_t v25 = *(unsigned int *)(v24 + 16);
    if (!v25) {
      return 0;
    }
    uint64_t v26 = *(void *)(v24 + 8);
    uint64_t v27 = v26 + 8 * v25;
    while (1)
    {
      uint64_t v28 = *(uint64_t ****)(*(void *)v26 + 8);
      if (a2)
      {
LABEL_46:
        uint64_t v19 = (uint64_t)(v28 + 5);
        return *(void *)v19;
      }
      if (v28 && *((unsigned char *)v28 + 16) == 3)
      {
        if ((*((_DWORD *)v28 + 5) & 0x7FFFFFF) == 0) {
          goto LABEL_43;
        }
      }
      else if (!*((unsigned char *)v28 + 16) && v28[9] == (uint64_t **)(v28 + 9) && (*((unsigned char *)v28 + 34) & 0x80) == 0)
      {
        goto LABEL_43;
      }
      if ((*((unsigned char *)v28 + 23) & 0x10) != 0) {
        break;
      }
      std::string::size_type v40 = 0;
      int v39 = &byte_1CFBCE98E;
LABEL_42:
      if (llvm::isFunctionInPrintList(v39, v40)) {
        goto LABEL_46;
      }
LABEL_43:
      v26 += 8;
      if (v26 == v27) {
        return 0;
      }
    }
    uint64_t v30 = ***v28;
    uint64_t v31 = *(void *)(v30 + 152);
    uint64_t v32 = *(unsigned int *)(v30 + 168);
    if (v32)
    {
      LODWORD(v33) = (v32 - 1) & ((v28 >> 4) ^ (v28 >> 9));
      uint64_t v34 = (uint64_t ****)(v31 + 16 * v33);
      uint64_t v35 = *v34;
      if (*v34 == v28)
      {
LABEL_41:
        uint64_t v38 = v34[1];
        std::string::size_type v41 = (std::string::size_type)*v38;
        int v39 = (const std::string::value_type *)(v38 + 2);
        std::string::size_type v40 = v41;
        goto LABEL_42;
      }
      int v36 = 1;
      while (v35 != (uint64_t ***)-4096)
      {
        int v37 = v33 + v36++;
        uint64_t v33 = v37 & (v32 - 1);
        uint64_t v35 = *(uint64_t ****)(v31 + 16 * v33);
        if (v35 == v28)
        {
          uint64_t v34 = (uint64_t ****)(v31 + 16 * v33);
          goto LABEL_41;
        }
      }
    }
    uint64_t v34 = (uint64_t ****)(v31 + 16 * v32);
    goto LABEL_41;
  }
  (*(void (**)(uint64_t))(*(void *)v7 + 24))(v7);
  uint64_t v10 = *(uint64_t ****)(*a1 + 8);
  if (a2) {
    goto LABEL_50;
  }
  if ((*((unsigned char *)v10 + 23) & 0x10) != 0)
  {
    uint64_t v20 = ***v10;
    uint64_t v12 = *(void *)(v20 + 152);
    uint64_t v13 = *(unsigned int *)(v20 + 168);
    if (v13)
    {
      LODWORD(v14) = (v13 - 1) & ((v10 >> 4) ^ (v10 >> 9));
      uint64_t v15 = (uint64_t ****)(v12 + 16 * v14);
      int v21 = *v15;
      if (*v15 != v10)
      {
        int v22 = 1;
        while (v21 != (uint64_t ***)-4096)
        {
          int v23 = v14 + v22++;
          uint64_t v14 = v23 & (v13 - 1);
          int v21 = *(uint64_t ****)(v12 + 16 * v14);
          if (v21 == v10)
          {
LABEL_20:
            uint64_t v15 = (uint64_t ****)(v12 + 16 * v14);
            goto LABEL_48;
          }
        }
        goto LABEL_47;
      }
      goto LABEL_48;
    }
LABEL_47:
    uint64_t v15 = (uint64_t ****)(v12 + 16 * v13);
    goto LABEL_48;
  }
LABEL_53:
  std::string::size_type v44 = 0;
  std::string::size_type v43 = &byte_1CFBCE98E;
LABEL_49:
  if (!llvm::isFunctionInPrintList(v43, v44)) {
    return 0;
  }
LABEL_50:
  uint64_t v19 = (uint64_t)(v10 + 5);
  return *(void *)v19;
}

llvm::raw_ostream *sub_1CCCC67F8(char *a1, uint64_t *a2)
{
  double result = (llvm::raw_ostream *)(*(uint64_t (**)(void))(*(void *)*a2 + 24))();
  if (result == (llvm::raw_ostream *)&llvm::Any::TypeId<llvm::Module const*>::Id)
  {
    a1[23] = 8;
    strcpy(a1, "[module]");
    return result;
  }
  uint64_t v5 = (void *)(*(uint64_t (**)(void))(*(void *)*a2 + 24))();
  uint64_t v6 = *a2;
  if (v5 == &llvm::Any::TypeId<llvm::Function const*>::Id)
  {
    double result = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(void *)v6 + 24))(v6);
    uint64_t v10 = *(uint64_t ****)(*a2 + 8);
    if ((*((unsigned char *)v10 + 23) & 0x10) == 0)
    {
      size_t v20 = 0;
      a1[23] = 0;
      goto LABEL_24;
    }
    uint64_t v11 = ***v10;
    uint64_t v12 = *(void *)(v11 + 152);
    uint64_t v13 = *(unsigned int *)(v11 + 168);
    if (v13)
    {
      LODWORD(v14) = (v13 - 1) & ((v10 >> 4) ^ (v10 >> 9));
      uint64_t v15 = (uint64_t ****)(v12 + 16 * v14);
      uint64_t v16 = *v15;
      if (*v15 == v10)
      {
LABEL_16:
        uint64_t v19 = (unint64_t *)v15[1];
        unint64_t v22 = *v19;
        int v21 = v19 + 2;
        size_t v20 = v22;
        if (v22 >= 0x7FFFFFFFFFFFFFF8) {
          abort();
        }
        if (v20 >= 0x17)
        {
          uint64_t v23 = (v20 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v20 | 7) != 0x17) {
            uint64_t v23 = v20 | 7;
          }
          uint64_t v24 = v23 + 1;
          uint64_t v25 = (char *)operator new(v23 + 1);
          *((void *)a1 + sub_1CD7485C0(this + 1) = v20;
          *((void *)a1 + 2) = v24 | 0x8000000000000000;
          *(void *)a1 = v25;
          a1 = v25;
        }
        else
        {
          a1[23] = v20;
          if (!v20) {
            goto LABEL_24;
          }
        }
        double result = (llvm::raw_ostream *)memmove(a1, v21, v20);
LABEL_24:
        a1[v20] = 0;
        return result;
      }
      int v17 = 1;
      while (v16 != (uint64_t ***)-4096)
      {
        int v18 = v14 + v17++;
        uint64_t v14 = v18 & (v13 - 1);
        uint64_t v16 = *(uint64_t ****)(v12 + 16 * v14);
        if (v16 == v10)
        {
          uint64_t v15 = (uint64_t ****)(v12 + 16 * v14);
          goto LABEL_16;
        }
      }
    }
    uint64_t v15 = (uint64_t ****)(v12 + 16 * v13);
    goto LABEL_16;
  }
  uint64_t v7 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v6 + 24))(v6);
  uint64_t v8 = *a2;
  if (v7 != &llvm::Any::TypeId<llvm::LazyCallGraph::SCC const*>::Id)
  {
    (*(void (**)(uint64_t))(*(void *)v8 + 24))(v8);
    (*(void (**)(void))(*(void *)*a2 + 24))();
    llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::print();
  }
  (*(void (**)(uint64_t))(*(void *)v8 + 24))(v8);
  uint64_t v9 = *(void *)(*a2 + 8);

  return sub_1CC945F34(v9, a1);
}

void llvm::PrintIRInstrumentation::popModuleDesc(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
}

uint64_t sub_1CCCC6BBC(char *a1, size_t a2)
{
  int v4 = operator new(0x50uLL);
  v7[1] = (uint64_t)(v4 + 5);
  void v7[2] = (uint64_t)(v4 + 5);
  v4[2] = xmmword_1E684F7B8;
  v4[3] = *(_OWORD *)&off_1E684F7C8;
  v4[4] = xmmword_1E684F7D8;
  *int v4 = xmmword_1E684F798;
  v4[1] = *(_OWORD *)&off_1E684F7A8;
  v7[0] = (uint64_t)v4;
  uint64_t isSpecialPass = llvm::isSpecialPass(a1, a2, v7);
  operator delete(v4);
  return isSpecialPass;
}

uint64_t sub_1CCCC6C48(void *a1)
{
  int v2 = (void *)(*(uint64_t (**)(void))(*(void *)*a1 + 24))(*a1);
  uint64_t v3 = *a1;
  if (v2 == &llvm::Any::TypeId<llvm::Module const*>::Id)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
    uint64_t v9 = *(void *)(*a1 + 8);
    uint64_t v10 = v9 + 24;
    uint64_t v11 = *(void *)(v9 + 32);
    if (v11 == v9 + 24) {
      goto LABEL_45;
    }
    std::string::size_type v12 = 1;
    uint64_t v13 = "*";
    while (1)
    {
      uint64_t v14 = (uint64_t ***)(v11 - 56);
      if (!v11) {
        uint64_t v14 = 0;
      }
      if ((*((unsigned char *)v14 + 23) & 0x10) != 0) {
        break;
      }
      std::string::size_type v25 = 0;
      uint64_t v24 = &byte_1CFBCE98E;
LABEL_18:
      if (llvm::isFunctionInPrintList(v24, v25)) {
        return 1;
      }
      uint64_t v11 = *(void *)(v11 + 8);
      if (v11 == v10) {
        goto LABEL_49;
      }
    }
    uint64_t v15 = ***v14;
    uint64_t v16 = *(void *)(v15 + 152);
    uint64_t v17 = *(unsigned int *)(v15 + 168);
    if (v17)
    {
      LODWORD(v18) = (v17 - 1) & ((v14 >> 4) ^ (v14 >> 9));
      uint64_t v19 = (uint64_t ****)(v16 + 16 * v18);
      size_t v20 = *v19;
      if (*v19 == v14)
      {
LABEL_17:
        uint64_t v23 = v19[1];
        std::string::size_type v26 = (std::string::size_type)*v23;
        uint64_t v24 = (const std::string::value_type *)(v23 + 2);
        std::string::size_type v25 = v26;
        goto LABEL_18;
      }
      int v21 = 1;
      while (v20 != (uint64_t ***)-4096)
      {
        int v22 = v18 + v21++;
        uint64_t v18 = v22 & (v17 - 1);
        size_t v20 = *(uint64_t ****)(v16 + 16 * v18);
        if (v20 == v14)
        {
          uint64_t v19 = (uint64_t ****)(v16 + 16 * v18);
          goto LABEL_17;
        }
      }
    }
    uint64_t v19 = (uint64_t ****)(v16 + 16 * v17);
    goto LABEL_17;
  }
  int v4 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v3 + 24))(v3);
  uint64_t v5 = *a1;
  if (v4 == &llvm::Any::TypeId<llvm::Function const*>::Id)
  {
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
    uint64_t v8 = (uint64_t ****)(*a1 + 8);
LABEL_23:
    uint64_t v27 = *v8;
    if ((*((unsigned char *)v27 + 23) & 0x10) == 0)
    {
      std::string::size_type v12 = 0;
      uint64_t v13 = &byte_1CFBCE98E;
      goto LABEL_49;
    }
    uint64_t v28 = ***v27;
    uint64_t v29 = *(void *)(v28 + 152);
    uint64_t v30 = *(unsigned int *)(v28 + 168);
    if (v30)
    {
      LODWORD(v3sub_1CD7485C0(this + 1) = (v30 - 1) & ((v27 >> 4) ^ (v27 >> 9));
      uint64_t v32 = (uint64_t ****)(v29 + 16 * v31);
      uint64_t v33 = *v32;
      if (*v32 == v27)
      {
LABEL_48:
        unsigned int v54 = v32[1];
        std::string::size_type v55 = (std::string::size_type)*v54;
        uint64_t v13 = (const std::string::value_type *)(v54 + 2);
        std::string::size_type v12 = v55;
        goto LABEL_49;
      }
      int v34 = 1;
      while (v33 != (uint64_t ***)-4096)
      {
        int v35 = v31 + v34++;
        uint64_t v31 = v35 & (v30 - 1);
        uint64_t v33 = *(uint64_t ****)(v29 + 16 * v31);
        if (v33 == v27)
        {
          uint64_t v32 = (uint64_t ****)(v29 + 16 * v31);
          goto LABEL_48;
        }
      }
    }
    uint64_t v32 = (uint64_t ****)(v29 + 16 * v30);
    goto LABEL_48;
  }
  uint64_t v6 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 24))(v5);
  uint64_t v7 = *a1;
  if (v6 != &llvm::Any::TypeId<llvm::LazyCallGraph::SCC const*>::Id)
  {
    (*(void (**)(uint64_t))(*(void *)v7 + 24))(v7);
    (*(void (**)(void))(*(void *)*a1 + 24))();
    uint64_t v8 = (uint64_t ****)(**(void **)(*(void *)(*a1 + 8) + 32) + 56);
    goto LABEL_23;
  }
  (*(void (**)(uint64_t))(*(void *)v7 + 24))(v7);
  uint64_t v36 = *(void *)(*a1 + 8);
  uint64_t v37 = *(unsigned int *)(v36 + 16);
  if (v37)
  {
    uint64_t v38 = *(void *)(v36 + 8);
    uint64_t v39 = v38 + 8 * v37;
    uint64_t v13 = "*";
    std::string::size_type v12 = 1;
    while (1)
    {
      std::string::size_type v40 = *(uint64_t ****)(*(void *)v38 + 8);
      if ((*((unsigned char *)v40 + 23) & 0x10) == 0)
      {
        std::string::size_type v51 = 0;
        uint64_t v50 = &byte_1CFBCE98E;
        goto LABEL_41;
      }
      uint64_t v41 = ***v40;
      uint64_t v42 = *(void *)(v41 + 152);
      uint64_t v43 = *(unsigned int *)(v41 + 168);
      if (!v43) {
        goto LABEL_39;
      }
      LODWORD(v44) = (v43 - 1) & ((v40 >> 4) ^ (v40 >> 9));
      std::string::size_type v45 = (uint64_t ****)(v42 + 16 * v44);
      uint64_t v46 = *v45;
      if (*v45 != v40) {
        break;
      }
LABEL_40:
      uint64_t v49 = v45[1];
      std::string::size_type v52 = (std::string::size_type)*v49;
      uint64_t v50 = (const std::string::value_type *)(v49 + 2);
      std::string::size_type v51 = v52;
LABEL_41:
      if (llvm::isFunctionInPrintList(v50, v51)) {
        return 1;
      }
      v38 += 8;
      if (v38 == v39) {
        goto LABEL_49;
      }
    }
    int v47 = 1;
    while (v46 != (uint64_t ***)-4096)
    {
      int v48 = v44 + v47++;
      uint64_t v44 = v48 & (v43 - 1);
      uint64_t v46 = *(uint64_t ****)(v42 + 16 * v44);
      if (v46 == v40)
      {
        std::string::size_type v45 = (uint64_t ****)(v42 + 16 * v44);
        goto LABEL_40;
      }
    }
LABEL_39:
    std::string::size_type v45 = (uint64_t ****)(v42 + 16 * v43);
    goto LABEL_40;
  }
LABEL_45:
  uint64_t v13 = "*";
  std::string::size_type v12 = 1;
LABEL_49:

  return llvm::isFunctionInPrintList(v13, v12);
}

size_t sub_1CCCC7084(void *a1, char *__s, uint64_t a3, uint64_t a4)
{
  if (__s) {
    size_t result = strlen(__s);
  }
  else {
    size_t result = 0;
  }
  *a1 = __s;
  a1[1] = result;
  a1[8] = a1 + 4;
  a1[2] = a1 + 8;
  a1[3] = 2;
  a1[4] = &unk_1F2617F90;
  a1[5] = a3;
  a1[6] = &unk_1F2619560;
  a1[7] = a4;
  a1[9] = a1 + 6;
  return result;
}

void sub_1CCCC7124(llvm::raw_ostream *a1, const std::string *a2)
{
  if ((llvm::isFunctionInPrintList("*", 1uLL) & 1) != 0 || byte_1EBD06DE0)
  {
    llvm::Module::print(a2, a1, 0, 0, 0);
  }
  else
  {
    int v4 = a2 + 1;
    for (std::string::size_type i = a2[1].__r_.__value_.__l.__size_; (const std::string *)i != v4; std::string::size_type i = *(void *)(i + 8))
    {
      if (i) {
        uint64_t v6 = (llvm::Value *)(i - 56);
      }
      else {
        uint64_t v6 = 0;
      }
      sub_1CCCCF678(a1, v6);
    }
  }
}

uint64_t llvm::OptNoneInstrumentation::shouldRun(unsigned char *a1, const void *a2, size_t a3, void *a4)
{
  if (!*a4) {
    return 1;
  }
  uint64_t v8 = (void *)(*(uint64_t (**)(void))(*(void *)*a4 + 24))(*a4);
  uint64_t v9 = *a4;
  if (v8 == &llvm::Any::TypeId<llvm::Function const*>::Id)
  {
    uint64_t v10 = (llvm *)(*(uint64_t (**)(uint64_t))(*(void *)v9 + 24))(v9);
    uint64_t v11 = (llvm::Value **)(*a4 + 8);
  }
  else
  {
    if (!v9
      || (_UNKNOWN *)(*(uint64_t (**)(uint64_t))(*(void *)v9 + 24))(v9) != &llvm::Any::TypeId<llvm::Loop const*>::Id)
    {
      return 1;
    }
    uint64_t v10 = (llvm *)(*(uint64_t (**)(void))(*(void *)*a4 + 24))();
    uint64_t v11 = (llvm::Value **)(**(void **)(*(void *)(*a4 + 8) + 32) + 56);
  }
  std::string::size_type v12 = *v11;
  if (!v12) {
    return 1;
  }
  uint64_t v13 = *((void *)v12 + 14);
  if (!v13 || (*(unsigned char *)(v13 + 17) & 8) == 0) {
    return 1;
  }
  uint64_t v23 = v12;
  if (*a1)
  {
    uint64_t v15 = (llvm::raw_ostream *)llvm::errs(v10);
    uint64_t v16 = sub_1CB8E509C(v15, "Skipping pass ");
    uint64_t v17 = (void *)*((void *)v16 + 4);
    if (a3 <= *((void *)v16 + 3) - (void)v17)
    {
      if (a3)
      {
        memcpy(v17, a2, a3);
        *((void *)v16 + 4) += a3;
      }
    }
    else
    {
      llvm::raw_ostream::write(v16, (const char *)a2, a3);
    }
    uint64_t v18 = sub_1CB8E509C(v16, " on ");
    Name = llvm::Value::getName(v23);
    size_t v21 = v19;
    int v22 = (void *)*((void *)v18 + 4);
    if (v19 <= *((void *)v18 + 3) - (void)v22)
    {
      if (v19)
      {
        memcpy(v22, Name, v19);
        *((void *)v18 + 4) += v21;
      }
    }
    else
    {
      llvm::raw_ostream::write(v18, Name, v19);
    }
    sub_1CB8E509C(v18, " due to optnone attribute\n");
  }
  return 0;
}

void llvm::PrintPassInstrumentation::registerCallbacks(unsigned char *a1, uint64_t a2)
{
  if (*a1)
  {
    uint64_t v4 = 0;
    uint64_t v5 = 0;
    v170 = 0;
    uint64_t v171 = 0;
    uint64_t v172 = 0;
    if (!a1[1])
    {
      sub_1CD741C88((uint64_t)&v170, "PassManager");
      sub_1CD741C88((uint64_t)&v170, "PassAdaptor");
      uint64_t v5 = v170;
      uint64_t v4 = v171;
    }
    long long v168 = (unint64_t)a1;
    long long v169 = 0uLL;
    sub_1CC0C53B4((void *)&v168 + 1, v5, v4, (v4 - (uint64_t)v5) >> 4);
    uint64_t v7 = *(unsigned int *)(a2 + 152);
    uint64_t v6 = *(unsigned int *)(a2 + 156);
    if (v7 >= v6)
    {
      if (v6 == -1) {
        goto LABEL_193;
      }
      unint64_t v34 = (2 * v6) | 1;
      if (v34 >= 0xFFFFFFFF) {
        uint64_t v35 = 0xFFFFFFFFLL;
      }
      else {
        uint64_t v35 = v34;
      }
      uint64_t v36 = (char *)malloc_type_malloc(32 * v35, 0x4065EBACuLL);
      if (!v36) {
        goto LABEL_194;
      }
      uint64_t v37 = v36;
      uint64_t v38 = &v36[32 * *(unsigned int *)(a2 + 152)];
      long long v150 = v169;
      long long v158 = v168;
      long long v169 = 0uLL;
      *((void *)&v168 + sub_1CD7485C0(this + 1) = 0;
      *((void *)v38 + 3) = 0;
      uint64_t v39 = operator new(0x20uLL, (std::align_val_t)8uLL);
      *(void *)uint64_t v38 = v39;
      *(_OWORD *)(v38 + 8) = xmmword_1CFB2C4A0;
      *uint64_t v39 = v158;
      v39[1] = v150;
      *((void *)v38 + 3) = (char *)off_1EC7DFA88 + 4;
      std::string::size_type v40 = *(void **)(a2 + 144);
      uint64_t v41 = *(unsigned int *)(a2 + 152);
      if (v41)
      {
        uint64_t v42 = 32 * v41;
        uint64_t v43 = v37;
        do
        {
          *((void *)v43 + 3) = 0;
          uint64_t v44 = v40[3];
          *((void *)v43 + 3) = v44;
          if (v40[3] >= 8uLL)
          {
            if ((v44 & 2) != 0 && (v44 & 4) != 0)
            {
              (*(void (**)(char *, void *))((v44 & 0xFFFFFFFFFFFFFFF8) + 8))(v43, v40);
            }
            else
            {
              long long v45 = *(_OWORD *)v40;
              *((void *)v43 + 2) = v40[2];
              *(_OWORD *)uint64_t v43 = v45;
            }
            v40[3] = 0;
          }
          v40 += 4;
          v43 += 32;
          v42 -= 32;
        }
        while (v42);
        std::string::size_type v40 = *(void **)(a2 + 144);
        uint64_t v46 = *(unsigned int *)(a2 + 152);
        if (v46)
        {
          uint64_t v47 = 32 * v46;
          int v48 = (char *)(v40 - 4);
          do
          {
            sub_1CD500E14(&v48[v47]);
            v47 -= 32;
          }
          while (v47);
          std::string::size_type v40 = *(void **)(a2 + 144);
        }
      }
      if (v40 != (void *)(a2 + 160)) {
        free(v40);
      }
      *(void *)(a2 + 144) = v37;
      *(_DWORD *)(a2 + 156) = v35;
    }
    else
    {
      uint64_t v8 = *(void *)(a2 + 144) + 32 * v7;
      long long v146 = v169;
      long long v154 = v168;
      long long v169 = 0uLL;
      *((void *)&v168 + sub_1CD7485C0(this + 1) = 0;
      *(void *)(v8 + 24) = 0;
      uint64_t v9 = operator new(0x20uLL, (std::align_val_t)8uLL);
      *(void *)uint64_t v8 = v9;
      *(_OWORD *)(v8 + 8) = xmmword_1CFB2C4A0;
      _OWORD *v9 = v154;
      v9[1] = v146;
      *(void *)(v8 + 24) = (char *)off_1EC7DFA88 + 4;
    }
    ++*(_DWORD *)(a2 + 152);
    long long v166 = (unint64_t)a1;
    long long v167 = 0uLL;
    sub_1CC0C53B4((void *)&v166 + 1, v5, v4, (v4 - (uint64_t)v5) >> 4);
    uint64_t v10 = *(unsigned int *)(a2 + 296);
    uint64_t v11 = *(unsigned int *)(a2 + 300);
    if (v10 >= v11)
    {
      if (v11 == -1) {
        goto LABEL_193;
      }
      unint64_t v49 = (2 * v11) | 1;
      if (v49 >= 0xFFFFFFFF) {
        uint64_t v50 = 0xFFFFFFFFLL;
      }
      else {
        uint64_t v50 = v49;
      }
      std::string::size_type v51 = (char *)malloc_type_malloc(32 * v50, 0x4065EBACuLL);
      if (!v51) {
        goto LABEL_194;
      }
      std::string::size_type v52 = v51;
      uint64_t v53 = &v51[32 * *(unsigned int *)(a2 + 296)];
      long long v151 = v167;
      long long v159 = v166;
      long long v167 = 0uLL;
      *((void *)&v166 + sub_1CD7485C0(this + 1) = 0;
      *((void *)v53 + 3) = 0;
      unsigned int v54 = operator new(0x20uLL, (std::align_val_t)8uLL);
      *(void *)uint64_t v53 = v54;
      *(_OWORD *)(v53 + 8) = xmmword_1CFB2C4A0;
      *unsigned int v54 = v159;
      v54[1] = v151;
      *((void *)v53 + 3) = (char *)&off_1EC7DFAA0 + 4;
      std::string::size_type v55 = *(void **)(a2 + 288);
      uint64_t v56 = *(unsigned int *)(a2 + 296);
      if (v56)
      {
        uint64_t v57 = 32 * v56;
        BOOL v58 = v52;
        do
        {
          *((void *)v58 + 3) = 0;
          uint64_t v59 = v55[3];
          *((void *)v58 + 3) = v59;
          if (v55[3] >= 8uLL)
          {
            if ((v59 & 2) != 0 && (v59 & 4) != 0)
            {
              (*(void (**)(char *, void *))((v59 & 0xFFFFFFFFFFFFFFF8) + 8))(v58, v55);
            }
            else
            {
              long long v60 = *(_OWORD *)v55;
              *((void *)v58 + 2) = v55[2];
              *(_OWORD *)BOOL v58 = v60;
            }
            v55[3] = 0;
          }
          v55 += 4;
          v58 += 32;
          v57 -= 32;
        }
        while (v57);
        std::string::size_type v55 = *(void **)(a2 + 288);
        uint64_t v61 = *(unsigned int *)(a2 + 296);
        if (v61)
        {
          uint64_t v62 = 32 * v61;
          uint64_t v63 = (char *)(v55 - 4);
          do
          {
            sub_1CD500E14(&v63[v62]);
            v62 -= 32;
          }
          while (v62);
          std::string::size_type v55 = *(void **)(a2 + 288);
        }
      }
      if (v55 != (void *)(a2 + 304)) {
        free(v55);
      }
      *(void *)(a2 + 288) = v52;
      *(_DWORD *)(a2 + 300) = v50;
    }
    else
    {
      uint64_t v12 = *(void *)(a2 + 288) + 32 * v10;
      long long v147 = v167;
      long long v155 = v166;
      long long v167 = 0uLL;
      *((void *)&v166 + sub_1CD7485C0(this + 1) = 0;
      *(void *)(v12 + 24) = 0;
      uint64_t v13 = operator new(0x20uLL, (std::align_val_t)8uLL);
      *(void *)uint64_t v12 = v13;
      *(_OWORD *)(v12 + 8) = xmmword_1CFB2C4A0;
      _OWORD *v13 = v155;
      v13[1] = v147;
      *(void *)(v12 + 24) = (char *)&off_1EC7DFAA0 + 4;
    }
    ++*(_DWORD *)(a2 + 296);
    long long v164 = (unint64_t)a1;
    long long v165 = 0uLL;
    sub_1CC0C53B4((void *)&v164 + 1, v5, v4, (v4 - (uint64_t)v5) >> 4);
    uint64_t v14 = *(unsigned int *)(a2 + 440);
    uint64_t v15 = *(unsigned int *)(a2 + 444);
    if (v14 >= v15)
    {
      if (v15 == -1) {
        goto LABEL_193;
      }
      unint64_t v64 = (2 * v15) | 1;
      if (v64 >= 0xFFFFFFFF) {
        uint64_t v65 = 0xFFFFFFFFLL;
      }
      else {
        uint64_t v65 = v64;
      }
      int v66 = (char *)malloc_type_malloc(32 * v65, 0x4065EBACuLL);
      if (!v66) {
        goto LABEL_194;
      }
      int v67 = v66;
      uint64_t v68 = &v66[32 * *(unsigned int *)(a2 + 440)];
      long long v152 = v165;
      long long v160 = v164;
      long long v165 = 0uLL;
      *((void *)&v164 + sub_1CD7485C0(this + 1) = 0;
      *((void *)v68 + 3) = 0;
      int v69 = operator new(0x20uLL, (std::align_val_t)8uLL);
      *(void *)uint64_t v68 = v69;
      *(_OWORD *)(v68 + 8) = xmmword_1CFB2C4A0;
      *int v69 = v160;
      v69[1] = v152;
      *((void *)v68 + 3) = (char *)&off_1EC7DFAB8 + 4;
      int v70 = *(void **)(a2 + 432);
      uint64_t v71 = *(unsigned int *)(a2 + 440);
      if (v71)
      {
        uint64_t v72 = 32 * v71;
        int v73 = v67;
        do
        {
          *((void *)v73 + 3) = 0;
          uint64_t v74 = v70[3];
          *((void *)v73 + 3) = v74;
          if (v70[3] >= 8uLL)
          {
            if ((v74 & 2) != 0 && (v74 & 4) != 0)
            {
              (*(void (**)(char *, void *))((v74 & 0xFFFFFFFFFFFFFFF8) + 8))(v73, v70);
            }
            else
            {
              long long v75 = *(_OWORD *)v70;
              *((void *)v73 + 2) = v70[2];
              *(_OWORD *)int v73 = v75;
            }
            v70[3] = 0;
          }
          v70 += 4;
          v73 += 32;
          v72 -= 32;
        }
        while (v72);
        int v70 = *(void **)(a2 + 432);
        uint64_t v76 = *(unsigned int *)(a2 + 440);
        if (v76)
        {
          uint64_t v77 = 32 * v76;
          BOOL v78 = (char *)(v70 - 4);
          do
          {
            sub_1CD500E14(&v78[v77]);
            v77 -= 32;
          }
          while (v77);
          int v70 = *(void **)(a2 + 432);
        }
      }
      if (v70 != (void *)(a2 + 448)) {
        free(v70);
      }
      *(void *)(a2 + 432) = v67;
      *(_DWORD *)(a2 + 444) = v65;
    }
    else
    {
      uint64_t v16 = *(void *)(a2 + 432) + 32 * v14;
      long long v148 = v165;
      long long v156 = v164;
      long long v165 = 0uLL;
      *((void *)&v164 + sub_1CD7485C0(this + 1) = 0;
      *(void *)(v16 + 24) = 0;
      uint64_t v17 = operator new(0x20uLL, (std::align_val_t)8uLL);
      *(void *)uint64_t v16 = v17;
      *(_OWORD *)(v16 + 8) = xmmword_1CFB2C4A0;
      *uint64_t v17 = v156;
      v17[1] = v148;
      *(void *)(v16 + 24) = (char *)&off_1EC7DFAB8 + 4;
    }
    ++*(_DWORD *)(a2 + 440);
    long long v162 = (unint64_t)a1;
    long long v163 = 0uLL;
    sub_1CC0C53B4((void *)&v162 + 1, v5, v4, (v4 - (uint64_t)v5) >> 4);
    uint64_t v18 = *(unsigned int *)(a2 + 584);
    uint64_t v19 = *(unsigned int *)(a2 + 588);
    if (v18 >= v19)
    {
      if (v19 == -1) {
        goto LABEL_193;
      }
      unint64_t v79 = (2 * v19) | 1;
      if (v79 >= 0xFFFFFFFF) {
        uint64_t v80 = 0xFFFFFFFFLL;
      }
      else {
        uint64_t v80 = v79;
      }
      uint64_t v81 = (char *)malloc_type_malloc(32 * v80, 0x4065EBACuLL);
      if (!v81) {
        goto LABEL_194;
      }
      BOOL v82 = v81;
      int v83 = &v81[32 * *(unsigned int *)(a2 + 584)];
      long long v153 = v163;
      long long v161 = v162;
      long long v163 = 0uLL;
      *((void *)&v162 + sub_1CD7485C0(this + 1) = 0;
      *((void *)v83 + 3) = 0;
      int v84 = operator new(0x20uLL, (std::align_val_t)8uLL);
      *(void *)int v83 = v84;
      *(_OWORD *)(v83 + 8) = xmmword_1CFB2C4A0;
      _OWORD *v84 = v161;
      v84[1] = v153;
      *((void *)v83 + 3) = (char *)off_1EC7DFAD0 + 4;
      BOOL v85 = *(void **)(a2 + 576);
      uint64_t v86 = *(unsigned int *)(a2 + 584);
      if (v86)
      {
        uint64_t v87 = 32 * v86;
        uint64_t v88 = v82;
        do
        {
          *((void *)v88 + 3) = 0;
          uint64_t v89 = v85[3];
          *((void *)v88 + 3) = v89;
          if (v85[3] >= 8uLL)
          {
            if ((v89 & 2) != 0 && (v89 & 4) != 0)
            {
              (*(void (**)(char *, void *))((v89 & 0xFFFFFFFFFFFFFFF8) + 8))(v88, v85);
            }
            else
            {
              long long v90 = *(_OWORD *)v85;
              *((void *)v88 + 2) = v85[2];
              *(_OWORD *)uint64_t v88 = v90;
            }
            v85[3] = 0;
          }
          v85 += 4;
          v88 += 32;
          v87 -= 32;
        }
        while (v87);
        BOOL v85 = *(void **)(a2 + 576);
        uint64_t v91 = *(unsigned int *)(a2 + 584);
        if (v91)
        {
          uint64_t v92 = 32 * v91;
          unsigned int v93 = (char *)(v85 - 4);
          do
          {
            sub_1CD500E14(&v93[v92]);
            v92 -= 32;
          }
          while (v92);
          BOOL v85 = *(void **)(a2 + 576);
        }
      }
      if (v85 != (void *)(a2 + 592)) {
        free(v85);
      }
      *(void *)(a2 + 576) = v82;
      *(_DWORD *)(a2 + 588) = v80;
    }
    else
    {
      uint64_t v20 = *(void *)(a2 + 576) + 32 * v18;
      long long v149 = v163;
      long long v157 = v162;
      long long v163 = 0uLL;
      *((void *)&v162 + sub_1CD7485C0(this + 1) = 0;
      *(void *)(v20 + 24) = 0;
      size_t v21 = operator new(0x20uLL, (std::align_val_t)8uLL);
      *(void *)uint64_t v20 = v21;
      *(_OWORD *)(v20 + 8) = xmmword_1CFB2C4A0;
      _OWORD *v21 = v157;
      v21[1] = v149;
      *(void *)(v20 + 24) = (char *)off_1EC7DFAD0 + 4;
    }
    ++*(_DWORD *)(a2 + 584);
    if (a1[2]) {
      goto LABEL_22;
    }
    uint64_t v22 = *(unsigned int *)(a2 + 728);
    uint64_t v23 = *(unsigned int *)(a2 + 732);
    if (v22 >= v23)
    {
      if (v23 == -1) {
        goto LABEL_193;
      }
      if (((2 * v23) | 1uLL) >= 0xFFFFFFFF) {
        uint64_t v94 = 0xFFFFFFFFLL;
      }
      else {
        uint64_t v94 = (2 * v23) | 1;
      }
      BOOL v95 = (char *)malloc_type_malloc(32 * v94, 0x4065EBACuLL);
      if (!v95) {
        goto LABEL_194;
      }
      uint64_t v96 = v95;
      uint64_t v97 = *(unsigned int *)(a2 + 728);
      BOOL v98 = &v95[32 * v97];
      *(void *)BOOL v98 = a1;
      *((void *)v98 + 3) = (char *)off_1EC7DFAE8 + 2;
      long long v99 = *(void **)(a2 + 720);
      if (v97)
      {
        uint64_t v100 = 32 * v97;
        uint64_t v101 = v95;
        do
        {
          *((void *)v101 + 3) = 0;
          uint64_t v102 = v99[3];
          *((void *)v101 + 3) = v102;
          if (v99[3] >= 8uLL)
          {
            if ((v102 & 2) != 0 && (v102 & 4) != 0)
            {
              (*(void (**)(char *, void *))((v102 & 0xFFFFFFFFFFFFFFF8) + 8))(v101, v99);
            }
            else
            {
              long long v103 = *(_OWORD *)v99;
              *((void *)v101 + 2) = v99[2];
              *(_OWORD *)uint64_t v101 = v103;
            }
            v99[3] = 0;
          }
          v99 += 4;
          v101 += 32;
          v100 -= 32;
        }
        while (v100);
        long long v99 = *(void **)(a2 + 720);
        uint64_t v104 = *(unsigned int *)(a2 + 728);
        if (v104)
        {
          uint64_t v105 = 32 * v104;
          int v106 = (char *)(v99 - 4);
          do
          {
            sub_1CD500E14(&v106[v105]);
            v105 -= 32;
          }
          while (v105);
          long long v99 = *(void **)(a2 + 720);
        }
      }
      if (v99 != (void *)(a2 + 736)) {
        free(v99);
      }
      *(void *)(a2 + 720) = v96;
      *(_DWORD *)(a2 + 732) = v94;
      LODWORD(v22) = *(_DWORD *)(a2 + 728);
    }
    else
    {
      uint64_t v24 = (void *)(*(void *)(a2 + 720) + 32 * v22);
      *uint64_t v24 = a1;
      v24[3] = (char *)off_1EC7DFAE8 + 2;
    }
    *(_DWORD *)(a2 + 728) = v22 + 1;
    uint64_t v25 = *(unsigned int *)(a2 + 872);
    uint64_t v26 = *(unsigned int *)(a2 + 876);
    if (v25 >= v26)
    {
      if (v26 == -1) {
        goto LABEL_193;
      }
      if (((2 * v26) | 1uLL) >= 0xFFFFFFFF) {
        uint64_t v107 = 0xFFFFFFFFLL;
      }
      else {
        uint64_t v107 = (2 * v26) | 1;
      }
      BOOL v108 = (char *)malloc_type_malloc(32 * v107, 0x4065EBACuLL);
      if (!v108) {
        goto LABEL_194;
      }
      uint64_t v109 = v108;
      uint64_t v110 = *(unsigned int *)(a2 + 872);
      int v111 = &v108[32 * v110];
      *(void *)int v111 = a1;
      *((void *)v111 + 3) = (char *)off_1EC7DFAF0 + 2;
      int v112 = *(void **)(a2 + 864);
      if (v110)
      {
        uint64_t v113 = 32 * v110;
        BOOL v114 = v108;
        do
        {
          *((void *)v114 + 3) = 0;
          uint64_t v115 = v112[3];
          *((void *)v114 + 3) = v115;
          if (v112[3] >= 8uLL)
          {
            if ((v115 & 2) != 0 && (v115 & 4) != 0)
            {
              (*(void (**)(char *, void *))((v115 & 0xFFFFFFFFFFFFFFF8) + 8))(v114, v112);
            }
            else
            {
              long long v116 = *(_OWORD *)v112;
              *((void *)v114 + 2) = v112[2];
              *(_OWORD *)BOOL v114 = v116;
            }
            v112[3] = 0;
          }
          v112 += 4;
          v114 += 32;
          v113 -= 32;
        }
        while (v113);
        int v112 = *(void **)(a2 + 864);
        uint64_t v117 = *(unsigned int *)(a2 + 872);
        if (v117)
        {
          uint64_t v118 = 32 * v117;
          BOOL v119 = (char *)(v112 - 4);
          do
          {
            sub_1CD500E14(&v119[v118]);
            v118 -= 32;
          }
          while (v118);
          int v112 = *(void **)(a2 + 864);
        }
      }
      if (v112 != (void *)(a2 + 880)) {
        free(v112);
      }
      *(void *)(a2 + 864) = v109;
      *(_DWORD *)(a2 + 876) = v107;
      LODWORD(v25) = *(_DWORD *)(a2 + 872);
    }
    else
    {
      uint64_t v27 = (void *)(*(void *)(a2 + 864) + 32 * v25);
      *uint64_t v27 = a1;
      v27[3] = (char *)off_1EC7DFAF0 + 2;
    }
    *(_DWORD *)(a2 + 872) = v25 + 1;
    uint64_t v28 = *(unsigned int *)(a2 + 1016);
    uint64_t v29 = *(unsigned int *)(a2 + 1020);
    if (v28 >= v29)
    {
      if (v29 == -1) {
        goto LABEL_193;
      }
      if (((2 * v29) | 1uLL) >= 0xFFFFFFFF) {
        uint64_t v120 = 0xFFFFFFFFLL;
      }
      else {
        uint64_t v120 = (2 * v29) | 1;
      }
      int v121 = (char *)malloc_type_malloc(32 * v120, 0x4065EBACuLL);
      if (!v121) {
        goto LABEL_194;
      }
      BOOL v122 = v121;
      uint64_t v123 = *(unsigned int *)(a2 + 1016);
      BOOL v124 = &v121[32 * v123];
      *(void *)BOOL v124 = a1;
      *((void *)v124 + 3) = (char *)off_1EC7DFAF8 + 2;
      uint64_t v125 = *(void **)(a2 + 1008);
      if (v123)
      {
        uint64_t v126 = 32 * v123;
        BOOL v127 = v121;
        do
        {
          *((void *)v127 + 3) = 0;
          uint64_t v128 = v125[3];
          *((void *)v127 + 3) = v128;
          if (v125[3] >= 8uLL)
          {
            if ((v128 & 2) != 0 && (v128 & 4) != 0)
            {
              (*(void (**)(char *, void *))((v128 & 0xFFFFFFFFFFFFFFF8) + 8))(v127, v125);
            }
            else
            {
              long long v129 = *(_OWORD *)v125;
              *((void *)v127 + 2) = v125[2];
              *(_OWORD *)BOOL v127 = v129;
            }
            v125[3] = 0;
          }
          v125 += 4;
          v127 += 32;
          v126 -= 32;
        }
        while (v126);
        uint64_t v125 = *(void **)(a2 + 1008);
        uint64_t v130 = *(unsigned int *)(a2 + 1016);
        if (v130)
        {
          uint64_t v131 = 32 * v130;
          BOOL v132 = (char *)(v125 - 4);
          do
          {
            sub_1CD500E14(&v132[v131]);
            v131 -= 32;
          }
          while (v131);
          uint64_t v125 = *(void **)(a2 + 1008);
        }
      }
      if (v125 != (void *)(a2 + 1024)) {
        free(v125);
      }
      *(void *)(a2 + 1008) = v122;
      *(_DWORD *)(a2 + 1020) = v120;
      LODWORD(v28) = *(_DWORD *)(a2 + 1016);
    }
    else
    {
      uint64_t v30 = (void *)(*(void *)(a2 + 1008) + 32 * v28);
      void *v30 = a1;
      v30[3] = (char *)off_1EC7DFAF8 + 2;
    }
    *(_DWORD *)(a2 + 1016) = v28 + 1;
    uint64_t v31 = *(unsigned int *)(a2 + 1160);
    uint64_t v32 = *(unsigned int *)(a2 + 1164);
    if (v31 < v32)
    {
      uint64_t v33 = (void *)(*(void *)(a2 + 1152) + 32 * v31);
      void *v33 = a1;
      v33[3] = (char *)off_1EC7DFB00 + 2;
LABEL_21:
      *(_DWORD *)(a2 + 1160) = v31 + 1;
LABEL_22:
      if (v5) {
        operator delete(v5);
      }
      return;
    }
    if (v32 != -1)
    {
      if (((2 * v32) | 1uLL) >= 0xFFFFFFFF) {
        uint64_t v133 = 0xFFFFFFFFLL;
      }
      else {
        uint64_t v133 = (2 * v32) | 1;
      }
      BOOL v134 = (char *)malloc_type_malloc(32 * v133, 0x4065EBACuLL);
      if (v134)
      {
        int v135 = v134;
        uint64_t v136 = *(unsigned int *)(a2 + 1160);
        v137 = &v134[32 * v136];
        *(void *)v137 = a1;
        *((void *)v137 + 3) = (char *)off_1EC7DFB00 + 2;
        BOOL v138 = *(void **)(a2 + 1152);
        if (v136)
        {
          uint64_t v139 = 32 * v136;
          BOOL v140 = v134;
          do
          {
            *((void *)v140 + 3) = 0;
            uint64_t v141 = v138[3];
            *((void *)v140 + 3) = v141;
            if (v138[3] >= 8uLL)
            {
              if ((v141 & 2) != 0 && (v141 & 4) != 0)
              {
                (*(void (**)(char *, void *))((v141 & 0xFFFFFFFFFFFFFFF8) + 8))(v140, v138);
              }
              else
              {
                long long v142 = *(_OWORD *)v138;
                *((void *)v140 + 2) = v138[2];
                *(_OWORD *)BOOL v140 = v142;
              }
              v138[3] = 0;
            }
            v138 += 4;
            v140 += 32;
            v139 -= 32;
          }
          while (v139);
          BOOL v138 = *(void **)(a2 + 1152);
          uint64_t v143 = *(unsigned int *)(a2 + 1160);
          if (v143)
          {
            uint64_t v144 = 32 * v143;
            BOOL v145 = (char *)(v138 - 4);
            do
            {
              sub_1CD500E14(&v145[v144]);
              v144 -= 32;
            }
            while (v144);
            BOOL v138 = *(void **)(a2 + 1152);
          }
        }
        if (v138 != (void *)(a2 + 1168)) {
          free(v138);
        }
        *(void *)(a2 + 1152) = v135;
        *(_DWORD *)(a2 + 1164) = v133;
        LODWORD(v3sub_1CD7485C0(this + 1) = *(_DWORD *)(a2 + 1160);
        goto LABEL_21;
      }
LABEL_194:
      llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
    }
LABEL_193:
    sub_1CD0A89A8(0xFFFFFFFFuLL);
  }
}

llvm::raw_ostream *sub_1CCCC80D4(llvm::raw_ostream *this, unint64_t a2)
{
  uint64_t v3 = this;
  if ((*(unsigned char *)(a2 + 23) & 0x10) != 0)
  {
    uint64_t v10 = ***(void ***)a2;
    uint64_t v11 = *(void *)(v10 + 152);
    uint64_t v12 = *(unsigned int *)(v10 + 168);
    if (v12)
    {
      LODWORD(v13) = (v12 - 1) & ((a2 >> 4) ^ (a2 >> 9));
      uint64_t v14 = (uint64_t *)(v11 + 16 * v13);
      uint64_t v15 = *v14;
      if (*v14 == a2)
      {
LABEL_28:
        uint64_t v24 = (size_t *)v14[1];
        size_t v27 = *v24;
        uint64_t v25 = v24 + 2;
        size_t v26 = v27;
        uint64_t v28 = (unsigned char *)*((void *)this + 4);
        if (v27 <= *((void *)v3 + 3) - (void)v28)
        {
          if (v26)
          {
            memcpy(v28, v25, v26);
            uint64_t v28 = (unsigned char *)(*((void *)v3 + 4) + v26);
            *((void *)v3 + 4) = v28;
          }
        }
        else
        {
          llvm::raw_ostream::write(v3, (const char *)v25, v26);
          uint64_t v28 = (unsigned char *)*((void *)v3 + 4);
        }
        if (*((unsigned char **)v3 + 3) == v28) {
          goto LABEL_39;
        }
        unsigned char *v28 = 60;
LABEL_47:
        uint64_t v32 = *((void *)v3 + 4) + 1;
        goto LABEL_48;
      }
      int v16 = 1;
      while (v15 != -4096)
      {
        int v17 = v13 + v16++;
        uint64_t v13 = v17 & (v12 - 1);
        uint64_t v15 = *(void *)(v11 + 16 * v13);
        if (v15 == a2)
        {
          uint64_t v14 = (uint64_t *)(v11 + 16 * v13);
          goto LABEL_28;
        }
      }
    }
    uint64_t v14 = (uint64_t *)(v11 + 16 * v12);
    goto LABEL_28;
  }
  uint64_t v4 = *(void *)(a2 + 56);
  if (v4)
  {
    uint64_t v5 = *(void *)(v4 + 80);
    uint64_t v6 = v5 - 24;
    if (!v5) {
      uint64_t v6 = 0;
    }
    if (v6 == a2)
    {
      uint64_t v21 = *((void *)this + 4);
      if ((unint64_t)(*((void *)this + 3) - v21) > 4)
      {
        *(unsigned char *)(v21 + 4) = 121;
        *(_DWORD *)uint64_t v21 = 1920233061;
        uint64_t v22 = (unsigned char *)(*((void *)this + 4) + 5);
        *((void *)this + 4) = v22;
      }
      else
      {
        llvm::raw_ostream::write(this, "entry", 5uLL);
        uint64_t v22 = (unsigned char *)*((void *)v3 + 4);
      }
      uint64_t v23 = (unsigned char *)*((void *)v3 + 3);
    }
    else
    {
      uint64_t v7 = v4 + 72;
      if (v5 == v7)
      {
        unint64_t v8 = 0;
      }
      else
      {
        LODWORD(v8) = 0;
        do
        {
          uint64_t v9 = v5 - 24;
          if (!v5) {
            uint64_t v9 = 0;
          }
          if (v9 == a2) {
            unint64_t v8 = v8;
          }
          else {
            unint64_t v8 = (v8 + 1);
          }
          if (v9 == a2) {
            break;
          }
          uint64_t v5 = *(void *)(v5 + 8);
        }
        while (v5 != v7);
      }
      uint64_t v29 = (void *)*((void *)this + 4);
      if (*((void *)this + 3) - (void)v29 > 7uLL)
      {
        void *v29 = 0x5F64656D616E6E75;
        *((void *)this + 4) += 8;
      }
      else
      {
        llvm::raw_ostream::write(this, "unnamed_", 8uLL);
      }
      sub_1CD098D14(v3, v8, 0, 0, 0);
      uint64_t v23 = (unsigned char *)*((void *)v3 + 3);
      uint64_t v22 = (unsigned char *)*((void *)v3 + 4);
    }
    if (v23 == v22)
    {
LABEL_39:
      uint64_t v19 = "<";
      this = v3;
      size_t v20 = 1;
      goto LABEL_40;
    }
    unsigned char *v22 = 60;
    goto LABEL_47;
  }
  uint64_t v18 = (_OWORD *)*((void *)this + 4);
  if (*((void *)this + 3) - (void)v18 <= 0xFuLL)
  {
    uint64_t v19 = "unnamed_removed<";
    size_t v20 = 16;
LABEL_40:
    llvm::raw_ostream::write(this, v19, v20);
    goto LABEL_41;
  }
  _OWORD *v18 = *(_OWORD *)"unnamed_removed<";
  uint64_t v32 = *((void *)this + 4) + 16;
LABEL_48:
  *((void *)v3 + 4) = v32;
LABEL_41:
  size_t result = llvm::write_hex(v3, a2, 3, 0, 0);
  uint64_t v31 = (unsigned char *)*((void *)v3 + 4);
  if (*((unsigned char **)v3 + 3) == v31)
  {
    return llvm::raw_ostream::write(v3, ">", 1uLL);
  }
  else
  {
    unsigned char *v31 = 62;
    ++*((void *)v3 + 4);
  }
  return result;
}

void llvm::InLineChangePrinter::~InLineChangePrinter(llvm::InLineChangePrinter *this)
{
  *(void *)this = &unk_1F263BD80;
  long long v1 = (void **)((char *)this + 8);
  sub_1CCCD3A40(&v1);
}

{
  void **v1;

  *(void *)this = &unk_1F263BD80;
  long long v1 = (void **)((char *)this + 8);
  sub_1CCCD3A40(&v1);
}

{
  void **v1;
  uint64_t vars8;

  *(void *)this = &unk_1F263BD80;
  long long v1 = (void **)((char *)this + 8);
  sub_1CCCD3A40(&v1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t llvm::IRComparer<llvm::EmptyData>::analyzeIR(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    (*(void (**)(uint64_t *__return_ptr))(*(void *)v2 + 16))(&v5);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v3 = sub_1CCCC8588(&v5);
  uint64_t result = v5;
  uint64_t v5 = 0;
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  if (!v3)
  {
    (*(void (**)(void))(*(void *)*a1 + 24))();
    (*(void (**)(void))(*(void *)*a1 + 24))();
    llvm::IRComparer<llvm::EmptyData>::generateFunctionData();
  }
  if (*(void *)(v3 + 32) != v3 + 24) {
    llvm::IRComparer<llvm::EmptyData>::generateFunctionData();
  }
  return result;
}

void *llvm::IRComparer<llvm::EmptyData>::IRComparer(void *result, uint64_t a2, uint64_t a3)
{
  llvm::raw_ostream *result = a2;
  result[1] = a3;
  return result;
}

{
  llvm::raw_ostream *result = a2;
  result[1] = a3;
  return result;
}

uint64_t sub_1CCCC8588(uint64_t *a1)
{
  uint64_t result = *a1;
  if (result)
  {
    uint64_t v3 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
    uint64_t result = *a1;
    if (v3 == &llvm::Any::TypeId<llvm::Module const*>::Id)
    {
      (*(void (**)(uint64_t))(*(void *)result + 24))(result);
      uint64_t v4 = *a1 + 8;
    }
    else
    {
      if (!result) {
        return result;
      }
      if ((_UNKNOWN *)(*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result) != &llvm::Any::TypeId<llvm::LazyCallGraph::SCC const*>::Id) {
        return 0;
      }
      (*(void (**)(void))(*(void *)*a1 + 24))();
      uint64_t v4 = *(void *)(**(void **)(*(void *)(*a1 + 8) + 8) + 8) + 40;
    }
    return *(void *)v4;
  }
  return result;
}

void llvm::InLineChangePrinter::registerCallbacks()
{
  if ((dword_1EBD0A718 - 3) <= 3) {
    llvm::ChangeReporter<llvm::IRDataT<llvm::EmptyData>>::registerRequiredCallbacks();
  }
}

uint64_t llvm::ChangeReporter<std::string>::ChangeReporter(uint64_t result, char a2)
{
  *(void *)uint64_t result = &unk_1F263BCD0;
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  *(unsigned char *)(result + 32) = 1;
  *(unsigned char *)(result + 33) = a2;
  return result;
}

uint64_t llvm::ChangeReporter<std::string>::~ChangeReporter(uint64_t a1)
{
  *(void *)a1 = &unk_1F263BCD0;
  uint64_t v3 = (void **)(a1 + 8);
  sub_1CB8338B8(&v3);
  return a1;
}

uint64_t sub_1CCCC8744(void *a1, char *a2, size_t a3)
{
  if (sub_1CCCC6BBC(a2, a3)) {
    return 0;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCEFBC0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EBCEFBC0))
  {
    uint64_t v24 = qword_1EBCEFDC8;
    uint64_t v25 = unk_1EBCEFDD0;
    xmmword_1EBCEFC18 = 0u;
    *(_OWORD *)algn_1EBCEFC28 = 0u;
    for (dword_1EBCEFC38 = 1065353216; v24 != v25; v24 += 24)
      sub_1CC619C24((uint64_t)&xmmword_1EBCEFC18, v24, v24);
    __cxa_atexit((void (*)(void *))sub_1CC619C20, &xmmword_1EBCEFC18, &dword_1CB82C000);
    __cxa_guard_release(&qword_1EBCEFBC0);
  }
  if (qword_1EBCEFC30)
  {
    if (!a2)
    {
      long long __dst = 0;
      size_t v27 = 0;
      unint64_t v28 = 0;
      goto LABEL_16;
    }
    if (a3 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    if (a3 >= 0x17)
    {
      uint64_t v8 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((a3 | 7) != 0x17) {
        uint64_t v8 = a3 | 7;
      }
      uint64_t v9 = v8 + 1;
      p_dst = (void **)operator new(v8 + 1);
      size_t v27 = a3;
      unint64_t v28 = v9 | 0x8000000000000000;
      long long __dst = p_dst;
    }
    else
    {
      HIBYTE(v28) = a3;
      p_dst = (void **)&__dst;
      if (!a3) {
        goto LABEL_15;
      }
    }
    memmove(p_dst, a2, a3);
LABEL_15:
    *((unsigned char *)p_dst + a3) = 0;
LABEL_16:
    uint64_t v10 = sub_1CC619FE0(&xmmword_1EBCEFC18, (uint64_t)&__dst);
    if (SHIBYTE(v28) < 0) {
      operator delete(__dst);
    }
    if (!v10) {
      return 0;
    }
  }
  if (!*a1
    || (_UNKNOWN *)(*(uint64_t (**)(void))(*(void *)*a1 + 24))(*a1) != &llvm::Any::TypeId<llvm::Function const*>::Id)
  {
    return 1;
  }
  (*(void (**)(void))(*(void *)*a1 + 24))();
  uint64_t v11 = *(uint64_t ****)(*a1 + 8);
  if ((*((unsigned char *)v11 + 23) & 0x10) == 0)
  {
    std::string::size_type v22 = 0;
    uint64_t v21 = &byte_1CFBCE98E;
    return llvm::isFunctionInPrintList(v21, v22);
  }
  uint64_t v12 = ***v11;
  uint64_t v13 = *(void *)(v12 + 152);
  uint64_t v14 = *(unsigned int *)(v12 + 168);
  if (!v14) {
    goto LABEL_29;
  }
  LODWORD(v15) = (v14 - 1) & ((v11 >> 4) ^ (v11 >> 9));
  int v16 = (uint64_t ****)(v13 + 16 * v15);
  int v17 = *v16;
  if (*v16 != v11)
  {
    int v18 = 1;
    while (v17 != (uint64_t ***)-4096)
    {
      int v19 = v15 + v18++;
      uint64_t v15 = v19 & (v14 - 1);
      int v17 = *(uint64_t ****)(v13 + 16 * v15);
      if (v17 == v11)
      {
        int v16 = (uint64_t ****)(v13 + 16 * v15);
        goto LABEL_30;
      }
    }
LABEL_29:
    int v16 = (uint64_t ****)(v13 + 16 * v14);
  }
LABEL_30:
  size_t v20 = v16[1];
  std::string::size_type v23 = (std::string::size_type)*v20;
  uint64_t v21 = (const std::string::value_type *)(v20 + 2);
  std::string::size_type v22 = v23;
  return llvm::isFunctionInPrintList(v21, v22);
}

uint64_t llvm::TextChangeReporter<std::string>::TextChangeReporter(uint64_t a1, char a2)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(unsigned char *)(a1 + 32) = 1;
  *(unsigned char *)(a1 + 33) = a2;
  *(void *)a1 = &unk_1F263BD28;
  *(void *)(a1 + 40) = llvm::dbgs((llvm *)a1);
  return a1;
}

uint64_t llvm::BlockDataT<llvm::EmptyData>::operator==(uint64_t a1, uint64_t a2)
{
  char v2 = *(unsigned char *)(a1 + 47);
  if (v2 >= 0) {
    uint64_t v3 = v2 & 0x7F;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  char v4 = *(unsigned char *)(a2 + 47);
  int v5 = v4;
  uint64_t v6 = v4 & 0x7F;
  if (v5 < 0) {
    uint64_t v6 = *(void *)(a2 + 32);
  }
  if (v3 != v6) {
    return 0;
  }
  uint64_t v7 = (const void **)(a1 + 24);
  uint64_t v10 = *(unsigned __int8 **)(a2 + 24);
  uint64_t v8 = (unsigned __int8 *)(a2 + 24);
  uint64_t v9 = v10;
  if (v5 < 0) {
    uint64_t v8 = v9;
  }
  if ((*(unsigned char *)(a1 + 47) & 0x80) != 0) {
    return memcmp(*v7, v8, *(void *)(a1 + 32)) == 0;
  }
  if ((v2 & 0x7F) == 0) {
    return 1;
  }
  uint64_t v11 = (v2 & 0x7F) - 1;
  do
  {
    int v13 = *(unsigned __int8 *)v7;
    uint64_t v7 = (const void **)((char *)v7 + 1);
    int v12 = v13;
    int v15 = *v8++;
    int v14 = v15;
    BOOL v17 = v11-- != 0;
    uint64_t result = v12 == v14;
  }
  while (v12 == v14 && v17);
  return result;
}

uint64_t llvm::BlockDataT<llvm::EmptyData>::operator!=(uint64_t a1, uint64_t a2)
{
  char v2 = *(unsigned char *)(a1 + 47);
  if (v2 >= 0) {
    uint64_t v3 = v2 & 0x7F;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  char v4 = *(unsigned char *)(a2 + 47);
  int v5 = v4;
  uint64_t v6 = v4 & 0x7F;
  if (v5 < 0) {
    uint64_t v6 = *(void *)(a2 + 32);
  }
  if (v3 != v6) {
    return 1;
  }
  uint64_t v7 = (const void **)(a1 + 24);
  uint64_t v10 = *(unsigned __int8 **)(a2 + 24);
  uint64_t v8 = (unsigned __int8 *)(a2 + 24);
  uint64_t v9 = v10;
  if (v5 < 0) {
    uint64_t v8 = v9;
  }
  if ((*(unsigned char *)(a1 + 47) & 0x80) != 0) {
    return memcmp(*v7, v8, *(void *)(a1 + 32)) != 0;
  }
  if ((v2 & 0x7F) == 0) {
    return 0;
  }
  uint64_t v11 = (v2 & 0x7F) - 1;
  do
  {
    int v13 = *(unsigned __int8 *)v7;
    uint64_t v7 = (const void **)((char *)v7 + 1);
    int v12 = v13;
    int v14 = *v8++;
    uint64_t result = v12 != v14;
  }
  while (v12 == v14 && v11-- != 0);
  return result;
}

char *llvm::BlockDataT<llvm::EmptyData>::getLabel(char *result)
{
  if (result[23] < 0) {
    return *(char **)result;
  }
  return result;
}

uint64_t llvm::BlockDataT<llvm::EmptyData>::getBody(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t v1 = a1 + 24;
  uint64_t v2 = v3;
  if (*(char *)(v1 + 23) >= 0) {
    return v1;
  }
  return v2;
}

uint64_t llvm::BlockDataT<llvm::EmptyData>::getData(uint64_t a1)
{
  return a1 + 48;
}

uint64_t llvm::FuncDataT<llvm::EmptyData>::FuncDataT(uint64_t a1, long long *a2)
{
  *(_OWORD *)(a1 + 28) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 44) = 64;
  uint64_t v3 = a1 + 56;
  if (*((char *)a2 + 23) < 0)
  {
    sub_1CB8BDF7C(v3, *(const void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *(void *)(v3 + 16) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v3 = v4;
  }
  return a1;
}

{
  uint64_t v3;
  long long v4;

  *(_OWORD *)(a1 + 28) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 44) = 64;
  uint64_t v3 = a1 + 56;
  if (*((char *)a2 + 23) < 0)
  {
    sub_1CB8BDF7C(v3, *(const void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *(void *)(v3 + 16) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v3 = v4;
  }
  return a1;
}

char *llvm::FuncDataT<llvm::EmptyData>::getEntryBlockName@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[79] < 0) {
    return (char *)sub_1CB8BDF7C(a2, *((const void **)result + 7), *((void *)result + 8));
  }
  *(_OWORD *)a2 = *(_OWORD *)(result + 56);
  *(void *)(a2 + 16) = *((void *)result + 9);
  return result;
}

uint64_t llvm::ChangeReporter<llvm::IRDataT<llvm::EmptyData>>::ChangeReporter(uint64_t result, char a2)
{
  *(void *)uint64_t result = &unk_1F263BD80;
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  *(unsigned char *)(result + 32) = 1;
  *(unsigned char *)(result + 33) = a2;
  return result;
}

uint64_t llvm::ChangeReporter<llvm::IRDataT<llvm::EmptyData>>::~ChangeReporter(uint64_t a1)
{
  *(void *)a1 = &unk_1F263BD80;
  uint64_t v3 = (void **)(a1 + 8);
  sub_1CCCD3A40(&v3);
  return a1;
}

void llvm::ChangeReporter<llvm::IRDataT<llvm::EmptyData>>::handleInvalidatedPass(unsigned char *a1)
{
  if (a1[33]) {
    (*(void (**)(unsigned char *))(*(void *)a1 + 48))(a1);
  }

  sub_1CD7445CC((uint64_t)(a1 + 8));
}

uint64_t llvm::TextChangeReporter<llvm::IRDataT<llvm::EmptyData>>::TextChangeReporter(uint64_t a1, char a2)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(unsigned char *)(a1 + 32) = 1;
  *(unsigned char *)(a1 + 33) = a2;
  *(void *)a1 = &unk_1F263BDD8;
  *(void *)(a1 + 40) = llvm::dbgs((llvm *)a1);
  return a1;
}

int64x2_t *sub_1CCCC8E38(int64x2_t *result, void *__src, size_t __len)
{
  int v5 = result;
  unint64_t v6 = result[1].u64[0];
  uint64_t v7 = (void *)result->i64[1];
  if ((unint64_t)v7 < v6)
  {
    if (__len <= 0x7FFFFFFFFFFFFFF7)
    {
      if (__len >= 0x17)
      {
        size_t v9 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((__len | 7) != 0x17) {
          size_t v9 = __len | 7;
        }
        size_t v10 = v9 + 1;
        uint64_t v8 = operator new(v9 + 1);
        v7[1] = __len;
        void v7[2] = v10 | 0x8000000000000000;
        *uint64_t v7 = v8;
      }
      else
      {
        *((unsigned char *)v7 + 23) = __len;
        uint64_t v8 = v7;
        if (!__len) {
          goto LABEL_10;
        }
      }
      uint64_t result = (int64x2_t *)memmove(v8, __src, __len);
LABEL_10:
      *((unsigned char *)v8 + __len) = 0;
      uint64_t v11 = (char *)(v7 + 3);
      goto LABEL_11;
    }
LABEL_35:
    abort();
  }
  unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - result->i64[0]) >> 3);
  if (v12 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_35;
  }
  unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v6 - result->i64[0]) >> 3);
  uint64_t v14 = 2 * v13;
  if (2 * v13 <= v12 + 1) {
    uint64_t v14 = v12 + 1;
  }
  unint64_t v15 = v13 >= 0x555555555555555 ? 0xAAAAAAAAAAAAAAALL : v14;
  uint64_t v31 = result + 1;
  if (v15)
  {
    if (v15 > 0xAAAAAAAAAAAAAAALL) {
      sub_1CB833614();
    }
    int v16 = (char *)operator new(24 * v15);
  }
  else
  {
    int v16 = 0;
  }
  BOOL v17 = &v16[24 * v12];
  v29.i64[0] = (uint64_t)v17;
  v29.i64[1] = (uint64_t)v17;
  uint64_t v30 = &v16[24 * v15];
  if (__len > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_35;
  }
  if (__len >= 0x17)
  {
    size_t v18 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v18 = __len | 7;
    }
    size_t v19 = v18 + 1;
    size_t v20 = (char *)operator new(v18 + 1);
    *((void *)v17 + sub_1CD7485C0(this + 1) = __len;
    *((void *)v17 + 2) = v19 | 0x8000000000000000;
    *(void *)BOOL v17 = v20;
    BOOL v17 = v20;
  }
  else
  {
    v17[23] = __len;
    if (!__len) {
      goto LABEL_29;
    }
  }
  memmove(v17, __src, __len);
LABEL_29:
  v17[__len] = 0;
  uint64_t v22 = v5->i64[0];
  unint64_t v21 = v5->u64[1];
  uint64_t v23 = v29.i64[1];
  uint64_t v24 = v29.i64[0];
  if (v21 == v5->i64[0])
  {
    int64x2_t v26 = vdupq_n_s64(v21);
  }
  else
  {
    do
    {
      long long v25 = *(_OWORD *)(v21 - 24);
      *(void *)(v24 - 8) = *(void *)(v21 - 8);
      *(_OWORD *)(v24 - 24) = v25;
      v24 -= 24;
      *(void *)(v21 - 16) = 0;
      *(void *)(v21 - 8) = 0;
      *(void *)(v21 - 24) = 0;
      v21 -= 24;
    }
    while (v21 != v22);
    int64x2_t v26 = *v5;
  }
  uint64_t v11 = (char *)(v23 + 24);
  v5->i64[0] = v24;
  v5->i64[1] = v23 + 24;
  int64x2_t v29 = v26;
  size_t v27 = (char *)v5[1].i64[0];
  v5[1].i64[0] = (uint64_t)v30;
  uint64_t v30 = v27;
  uint64_t v28 = v26.i64[0];
  uint64_t result = (int64x2_t *)sub_1CBF4EE0C((uint64_t)&v28);
LABEL_11:
  v5->i64[1] = (uint64_t)v11;
  return result;
}

llvm::DCData *llvm::DCData::DCData(llvm::DCData *this, const llvm::BasicBlock *a2)
{
  v149[3] = *MEMORY[0x1E4F143B8];
  *(void *)this = 0;
  *((void *)this + sub_1CD7485C0(this + 1) = 0;
  *((void *)this + 2) = 0x2000000000;
  uint64_t v3 = (const llvm::BasicBlock *)*((void *)a2 + 5);
  if (v3 == (const llvm::BasicBlock *)((char *)a2 + 40)) {
    return this;
  }
  BOOL v4 = v3 == 0;
  if (v3) {
    int v5 = (const llvm::BasicBlock *)((char *)v3 - 24);
  }
  else {
    int v5 = 0;
  }
  int v6 = *((unsigned __int8 *)v5 + 16);
  if ((v6 - 40) >= 0xFFFFFFF5) {
    uint64_t v7 = v5;
  }
  else {
    uint64_t v7 = 0;
  }
  int v8 = *((unsigned __int8 *)v7 + 16);
  if ((v6 - 40) < 0xFFFFFFF5) {
    BOOL v4 = 1;
  }
  if (v8 == 30 && !v4)
  {
    if ((*((_DWORD *)v7 + 5) & 0x7FFFFFF) == 1)
    {
      uint64_t v31 = (uint64_t ***)*((void *)v7 - 4);
      if ((*((unsigned char *)v31 + 23) & 0x10) == 0)
      {
        size_t v97 = 0;
        HIBYTE(v140) = 0;
        p_dst = (void **)&__dst;
        goto LABEL_152;
      }
      uint64_t v32 = ***v31;
      uint64_t v33 = *(void *)(v32 + 152);
      uint64_t v34 = *(unsigned int *)(v32 + 168);
      if (v34)
      {
        LODWORD(v35) = (v34 - 1) & ((v31 >> 4) ^ (v31 >> 9));
        uint64_t v36 = (uint64_t ****)(v33 + 16 * v35);
        uint64_t v37 = *v36;
        if (*v36 == v31)
        {
LABEL_144:
          uint64_t v96 = (unint64_t *)v36[1];
          unint64_t v99 = *v96;
          BOOL v98 = v96 + 2;
          size_t v97 = v99;
          if (v99 > 0x7FFFFFFFFFFFFFF7) {
            goto LABEL_206;
          }
          if (v97 >= 0x17)
          {
            uint64_t v101 = (v97 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v97 | 7) != 0x17) {
              uint64_t v101 = v97 | 7;
            }
            uint64_t v102 = v101 + 1;
            p_dst = (void **)operator new(v101 + 1);
            std::string::size_type v139 = v97;
            int64_t v140 = v102 | 0x8000000000000000;
            long long __dst = p_dst;
          }
          else
          {
            HIBYTE(v140) = v97;
            p_dst = (void **)&__dst;
            if (!v97) {
              goto LABEL_152;
            }
          }
          memmove(p_dst, v98, v97);
LABEL_152:
          *((unsigned char *)p_dst + v97) = 0;
          if (v140 >= 0) {
            long long v103 = (const std::string::value_type *)&__dst;
          }
          else {
            long long v103 = (const std::string::value_type *)__dst;
          }
          if (v140 >= 0) {
            std::string::size_type v104 = HIBYTE(v140) & 0x7F;
          }
          else {
            std::string::size_type v104 = v139;
          }
          uint64_t v105 = "";
          int v106 = this;
          std::string::size_type v107 = 0;
          goto LABEL_199;
        }
        int v38 = 1;
        while (v37 != (uint64_t ***)-4096)
        {
          int v39 = v35 + v38++;
          uint64_t v35 = v39 & (v34 - 1);
          uint64_t v37 = *(uint64_t ****)(v33 + 16 * v35);
          if (v37 == v31)
          {
            uint64_t v36 = (uint64_t ****)(v33 + 16 * v35);
            goto LABEL_144;
          }
        }
      }
      uint64_t v36 = (uint64_t ****)(v33 + 16 * v34);
      goto LABEL_144;
    }
    uint64_t v42 = (uint64_t ***)*((void *)v7 - 4);
    if ((*((unsigned char *)v42 + 23) & 0x10) == 0)
    {
      size_t v109 = 0;
      HIBYTE(v140) = 0;
      int v112 = (void **)&__dst;
      goto LABEL_168;
    }
    uint64_t v43 = ***v42;
    uint64_t v44 = *(void *)(v43 + 152);
    uint64_t v45 = *(unsigned int *)(v43 + 168);
    if (v45)
    {
      LODWORD(v46) = (v45 - 1) & ((v42 >> 4) ^ (v42 >> 9));
      uint64_t v47 = (uint64_t ****)(v44 + 16 * v46);
      int v48 = *v47;
      if (*v47 == v42) {
        goto LABEL_160;
      }
      int v49 = 1;
      while (v48 != (uint64_t ***)-4096)
      {
        int v50 = v46 + v49++;
        uint64_t v46 = v50 & (v45 - 1);
        int v48 = *(uint64_t ****)(v44 + 16 * v46);
        if (v48 == v42)
        {
          uint64_t v47 = (uint64_t ****)(v44 + 16 * v46);
          goto LABEL_160;
        }
      }
    }
    uint64_t v47 = (uint64_t ****)(v44 + 16 * v45);
LABEL_160:
    BOOL v108 = (unint64_t *)v47[1];
    unint64_t v111 = *v108;
    uint64_t v110 = v108 + 2;
    size_t v109 = v111;
    if (v111 > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_206;
    }
    if (v109 >= 0x17)
    {
      uint64_t v113 = (v109 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v109 | 7) != 0x17) {
        uint64_t v113 = v109 | 7;
      }
      uint64_t v114 = v113 + 1;
      int v112 = (void **)operator new(v113 + 1);
      std::string::size_type v139 = v109;
      int64_t v140 = v114 | 0x8000000000000000;
      long long __dst = v112;
    }
    else
    {
      HIBYTE(v140) = v109;
      int v112 = (void **)&__dst;
      if (!v109)
      {
LABEL_168:
        *((unsigned char *)v112 + v109) = 0;
        if (v140 >= 0) {
          uint64_t v115 = (const std::string::value_type *)&__dst;
        }
        else {
          uint64_t v115 = (const std::string::value_type *)__dst;
        }
        if (v140 >= 0) {
          std::string::size_type v116 = HIBYTE(v140) & 0x7F;
        }
        else {
          std::string::size_type v116 = v139;
        }
        sub_1CD744B24(this, v115, v116, "true", 4uLL);
        if (SHIBYTE(v140) < 0) {
          operator delete(__dst);
        }
        uint64_t v117 = (uint64_t ***)*((void *)v7 - 8);
        if ((*((unsigned char *)v117 + 23) & 0x10) == 0)
        {
          size_t v127 = 0;
          HIBYTE(v140) = 0;
          uint64_t v130 = (void **)&__dst;
          goto LABEL_192;
        }
        uint64_t v118 = ***v117;
        uint64_t v119 = *(void *)(v118 + 152);
        uint64_t v120 = *(unsigned int *)(v118 + 168);
        if (v120)
        {
          LODWORD(v12sub_1CD7485C0(this + 1) = (v120 - 1) & ((v117 >> 4) ^ (v117 >> 9));
          BOOL v122 = (uint64_t ****)(v119 + 16 * v121);
          uint64_t v123 = *v122;
          if (*v122 == v117)
          {
LABEL_184:
            uint64_t v126 = (unint64_t *)v122[1];
            unint64_t v129 = *v126;
            uint64_t v128 = v126 + 2;
            size_t v127 = v129;
            if (v129 > 0x7FFFFFFFFFFFFFF7) {
              goto LABEL_206;
            }
            if (v127 >= 0x17)
            {
              uint64_t v131 = (v127 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v127 | 7) != 0x17) {
                uint64_t v131 = v127 | 7;
              }
              uint64_t v132 = v131 + 1;
              uint64_t v130 = (void **)operator new(v131 + 1);
              std::string::size_type v139 = v127;
              int64_t v140 = v132 | 0x8000000000000000;
              long long __dst = v130;
            }
            else
            {
              HIBYTE(v140) = v127;
              uint64_t v130 = (void **)&__dst;
              if (!v127) {
                goto LABEL_192;
              }
            }
            memmove(v130, v128, v127);
LABEL_192:
            *((unsigned char *)v130 + v127) = 0;
            if (v140 >= 0) {
              long long v103 = (const std::string::value_type *)&__dst;
            }
            else {
              long long v103 = (const std::string::value_type *)__dst;
            }
            if (v140 >= 0) {
              std::string::size_type v104 = HIBYTE(v140) & 0x7F;
            }
            else {
              std::string::size_type v104 = v139;
            }
            uint64_t v105 = "false";
            int v106 = this;
            std::string::size_type v107 = 5;
LABEL_199:
            sub_1CD744B24(v106, v103, v104, v105, v107);
            if (SHIBYTE(v140) < 0) {
              operator delete(__dst);
            }
            return this;
          }
          int v124 = 1;
          while (v123 != (uint64_t ***)-4096)
          {
            int v125 = v121 + v124++;
            uint64_t v121 = v125 & (v120 - 1);
            uint64_t v123 = *(uint64_t ****)(v119 + 16 * v121);
            if (v123 == v117)
            {
              BOOL v122 = (uint64_t ****)(v119 + 16 * v121);
              goto LABEL_184;
            }
          }
        }
        BOOL v122 = (uint64_t ****)(v119 + 16 * v120);
        goto LABEL_184;
      }
    }
    memmove(v112, v110, v109);
    goto LABEL_168;
  }
  char v9 = v8 != 31 || v4;
  if ((v9 & 1) == 0)
  {
    int v40 = *((_DWORD *)v7 + 5);
    if ((v40 & 0x40000000) != 0) {
      uint64_t v41 = *((void *)v7 - 1);
    }
    else {
      uint64_t v41 = (uint64_t)v7 - 32 * (v40 & 0x7FFFFFF);
    }
    std::string::size_type v51 = *(uint64_t ****)(v41 + 32);
    if ((*((unsigned char *)v51 + 23) & 0x10) == 0)
    {
      size_t v61 = 0;
      HIBYTE(v140) = 0;
      unint64_t v64 = (void **)&__dst;
      goto LABEL_90;
    }
    uint64_t v52 = ***v51;
    uint64_t v53 = *(void *)(v52 + 152);
    uint64_t v54 = *(unsigned int *)(v52 + 168);
    if (v54)
    {
      LODWORD(v55) = (v54 - 1) & ((v51 >> 4) ^ (v51 >> 9));
      uint64_t v56 = (uint64_t ****)(v53 + 16 * v55);
      uint64_t v57 = *v56;
      if (*v56 == v51) {
        goto LABEL_82;
      }
      int v58 = 1;
      while (v57 != (uint64_t ***)-4096)
      {
        int v59 = v55 + v58++;
        uint64_t v55 = v59 & (v54 - 1);
        uint64_t v57 = *(uint64_t ****)(v53 + 16 * v55);
        if (v57 == v51)
        {
          uint64_t v56 = (uint64_t ****)(v53 + 16 * v55);
          goto LABEL_82;
        }
      }
    }
    uint64_t v56 = (uint64_t ****)(v53 + 16 * v54);
LABEL_82:
    long long v60 = (unint64_t *)v56[1];
    unint64_t v63 = *v60;
    uint64_t v62 = v60 + 2;
    size_t v61 = v63;
    if (v63 <= 0x7FFFFFFFFFFFFFF7)
    {
      if (v61 >= 0x17)
      {
        uint64_t v65 = (v61 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v61 | 7) != 0x17) {
          uint64_t v65 = v61 | 7;
        }
        uint64_t v66 = v65 + 1;
        unint64_t v64 = (void **)operator new(v65 + 1);
        std::string::size_type v139 = v61;
        int64_t v140 = v66 | 0x8000000000000000;
        long long __dst = v64;
      }
      else
      {
        HIBYTE(v140) = v61;
        unint64_t v64 = (void **)&__dst;
        if (!v61) {
          goto LABEL_90;
        }
      }
      memmove(v64, v62, v61);
LABEL_90:
      *((unsigned char *)v64 + v6sub_1CD7485C0(this + 1) = 0;
      if (v140 >= 0) {
        int v67 = (const std::string::value_type *)&__dst;
      }
      else {
        int v67 = (const std::string::value_type *)__dst;
      }
      if (v140 >= 0) {
        std::string::size_type v68 = HIBYTE(v140) & 0x7F;
      }
      else {
        std::string::size_type v68 = v139;
      }
      sub_1CD744B24(this, v67, v68, "default", 7uLL);
      if (SHIBYTE(v140) < 0) {
        operator delete(__dst);
      }
      uint64_t v134 = ((*((_DWORD *)v7 + 5) >> 1) & 0x3FFFFFFu) - 1;
      if (((*((_DWORD *)v7 + 5) >> 1) & 0x3FFFFFF) == 1) {
        return this;
      }
      uint64_t v69 = 0;
      while (1)
      {
        int v70 = *((_DWORD *)v7 + 5);
        if ((v70 & 0x40000000) != 0) {
          uint64_t v71 = *((void *)v7 - 1);
        }
        else {
          uint64_t v71 = (uint64_t)v7 - 32 * (v70 & 0x7FFFFFF);
        }
        uint64_t v72 = *(void *)(v71 + 32 * (2 * v69 + 2));
        unsigned int v73 = *(_DWORD *)(v72 + 32);
        if (v73 > 0x40) {
          uint64_t v74 = **(void **)(v72 + 24);
        }
        else {
          uint64_t v74 = (uint64_t)(*(void *)(v72 + 24) << -(char)v73) >> -(char)v73;
        }
        v135[0] = "{0}";
        v135[1] = 3;
        v135[2] = &v137;
        v135[3] = 1;
        v136[0] = &unk_1F263C1A0;
        v136[1] = v74;
        long long v147 = (std::string::value_type *)v149;
        long long v148 = xmmword_1CFB28E20;
        LODWORD(v139) = 0;
        char v143 = 0;
        uint64_t v144 = 0;
        v137 = v136;
        long long __dst = (void **)&unk_1F2646FA8;
        long long v146 = (void **)&v147;
        int v145 = 0;
        uint64_t v141 = 0;
        uint64_t v142 = 0;
        int64_t v140 = 0;
        sub_1CD862C68((uint64_t)v135, (llvm::raw_ostream *)&__dst);
        long long __dst = (void **)&unk_1F2646B98;
        if (v145 == 1 && v140) {
          MEMORY[0x1D25D9CB0](v140, 0x1000C8077774924);
        }
        int v75 = *((_DWORD *)v7 + 5);
        if ((v75 & 0x40000000) != 0) {
          uint64_t v76 = *((void *)v7 - 1);
        }
        else {
          uint64_t v76 = (uint64_t)v7 - 32 * (v75 & 0x7FFFFFF);
        }
        uint64_t v77 = (2 * v69 + 3);
        if (v69 == 4294967294) {
          uint64_t v77 = 1;
        }
        BOOL v78 = *(uint64_t ****)(v76 + 32 * v77);
        if ((*((unsigned char *)v78 + 23) & 0x10) == 0)
        {
          size_t v88 = 0;
          HIBYTE(v140) = 0;
          uint64_t v91 = (void **)&__dst;
          goto LABEL_128;
        }
        uint64_t v79 = ***v78;
        uint64_t v80 = *(void *)(v79 + 152);
        uint64_t v81 = *(unsigned int *)(v79 + 168);
        if (!v81) {
          goto LABEL_119;
        }
        LODWORD(v82) = (v81 - 1) & ((v78 >> 4) ^ (v78 >> 9));
        int v83 = (uint64_t ****)(v80 + 16 * v82);
        int v84 = *v83;
        if (*v83 != v78) {
          break;
        }
LABEL_120:
        uint64_t v87 = (unint64_t *)v83[1];
        unint64_t v90 = *v87;
        uint64_t v89 = v87 + 2;
        size_t v88 = v90;
        if (v90 > 0x7FFFFFFFFFFFFFF7) {
          goto LABEL_206;
        }
        if (v88 >= 0x17)
        {
          uint64_t v92 = (v88 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v88 | 7) != 0x17) {
            uint64_t v92 = v88 | 7;
          }
          uint64_t v93 = v92 + 1;
          uint64_t v91 = (void **)operator new(v92 + 1);
          std::string::size_type v139 = v88;
          int64_t v140 = v93 | 0x8000000000000000;
          long long __dst = v91;
        }
        else
        {
          HIBYTE(v140) = v88;
          uint64_t v91 = (void **)&__dst;
          if (!v88) {
            goto LABEL_128;
          }
        }
        memmove(v91, v89, v88);
LABEL_128:
        *((unsigned char *)v91 + v88) = 0;
        if (v140 >= 0) {
          uint64_t v94 = (const std::string::value_type *)&__dst;
        }
        else {
          uint64_t v94 = (const std::string::value_type *)__dst;
        }
        if (v140 >= 0) {
          std::string::size_type v95 = HIBYTE(v140) & 0x7F;
        }
        else {
          std::string::size_type v95 = v139;
        }
        sub_1CD744B24(this, v94, v95, v147, v148);
        if (SHIBYTE(v140) < 0) {
          operator delete(__dst);
        }
        if (v147 != (std::string::value_type *)v149) {
          free(v147);
        }
        if (++v69 == v134) {
          return this;
        }
      }
      int v85 = 1;
      while (v84 != (uint64_t ***)-4096)
      {
        int v86 = v82 + v85++;
        uint64_t v82 = v86 & (v81 - 1);
        int v84 = *(uint64_t ****)(v80 + 16 * v82);
        if (v84 == v78)
        {
          int v83 = (uint64_t ****)(v80 + 16 * v82);
          goto LABEL_120;
        }
      }
LABEL_119:
      int v83 = (uint64_t ****)(v80 + 16 * v81);
      goto LABEL_120;
    }
LABEL_206:
    abort();
  }
  if ((v6 - 29) >= 0xB) {
    size_t v10 = 0;
  }
  else {
    size_t v10 = v5;
  }
  if ((v6 - 29) <= 0xA)
  {
    if (v6 != 30)
    {
      int v11 = 2;
      switch(*((unsigned char *)v5 + 16))
      {
        case 0x1E:
          __break(1u);
          goto LABEL_208;
        case 0x1F:
          int v11 = (*((_DWORD *)v5 + 5) >> 1) & 0x3FFFFFF;
          goto LABEL_64;
        case 0x20:
        case 0x26:
LABEL_208:
          int v11 = (*((_DWORD *)v5 + 5) & 0x7FFFFFF) - 1;
          goto LABEL_64;
        case 0x21:
          goto LABEL_24;
        case 0x24:
          int v11 = *((_WORD *)v5 + 9) & 1;
          goto LABEL_64;
        case 0x25:
          int v11 = 1;
          goto LABEL_24;
        case 0x27:
          int v11 = *((_DWORD *)v5 + 20) + 1;
LABEL_64:
          if (!v11) {
            return this;
          }
          goto LABEL_24;
        default:
          return this;
      }
    }
    if ((*((_DWORD *)v5 + 5) & 0x7FFFFFF) == 3) {
      int v11 = 2;
    }
    else {
      int v11 = 1;
    }
LABEL_24:
    unsigned int v12 = 0;
    while (1)
    {
      uint64_t Successor = llvm::Instruction::getSuccessor(v10, v12);
      if ((*(unsigned char *)(Successor + 23) & 0x10) == 0)
      {
        size_t v23 = 0;
        HIBYTE(v140) = 0;
        int64x2_t v26 = (void **)&__dst;
        goto LABEL_41;
      }
      uint64_t v14 = ***(void ***)Successor;
      uint64_t v15 = *(void *)(v14 + 152);
      uint64_t v16 = *(unsigned int *)(v14 + 168);
      if (!v16) {
        goto LABEL_32;
      }
      LODWORD(v17) = (v16 - 1) & ((Successor >> 4) ^ (Successor >> 9));
      size_t v18 = (uint64_t *)(v15 + 16 * v17);
      uint64_t v19 = *v18;
      if (*v18 != Successor) {
        break;
      }
LABEL_33:
      uint64_t v22 = (unint64_t *)v18[1];
      unint64_t v25 = *v22;
      uint64_t v24 = v22 + 2;
      size_t v23 = v25;
      if (v25 > 0x7FFFFFFFFFFFFFF7) {
        goto LABEL_206;
      }
      if (v23 >= 0x17)
      {
        uint64_t v27 = (v23 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v23 | 7) != 0x17) {
          uint64_t v27 = v23 | 7;
        }
        uint64_t v28 = v27 + 1;
        int64x2_t v26 = (void **)operator new(v27 + 1);
        std::string::size_type v139 = v23;
        int64_t v140 = v28 | 0x8000000000000000;
        long long __dst = v26;
      }
      else
      {
        HIBYTE(v140) = v23;
        int64x2_t v26 = (void **)&__dst;
        if (!v23) {
          goto LABEL_41;
        }
      }
      memmove(v26, v24, v23);
LABEL_41:
      *((unsigned char *)v26 + v23) = 0;
      if (v140 >= 0) {
        int64x2_t v29 = (const std::string::value_type *)&__dst;
      }
      else {
        int64x2_t v29 = (const std::string::value_type *)__dst;
      }
      if (v140 >= 0) {
        std::string::size_type v30 = HIBYTE(v140) & 0x7F;
      }
      else {
        std::string::size_type v30 = v139;
      }
      sub_1CD744B24(this, v29, v30, "", 0);
      if (SHIBYTE(v140) < 0) {
        operator delete(__dst);
      }
      if (v11 == ++v12) {
        return this;
      }
    }
    int v20 = 1;
    while (v19 != -4096)
    {
      int v21 = v17 + v20++;
      uint64_t v17 = v21 & (v16 - 1);
      uint64_t v19 = *(void *)(v15 + 16 * v17);
      if (v19 == Successor)
      {
        size_t v18 = (uint64_t *)(v15 + 16 * v17);
        goto LABEL_33;
      }
    }
LABEL_32:
    size_t v18 = (uint64_t *)(v15 + 16 * v16);
    goto LABEL_33;
  }
  return this;
}

uint64_t llvm::DotCfgChangeReporter::DotCfgChangeReporter(uint64_t this, char a2)
{
  *(void *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  *(void *)(this + 24) = 0;
  *(unsigned char *)(this + 32) = 1;
  *(unsigned char *)(this + 33) = a2;
  *(void *)this = &unk_1F263BE30;
  *(_DWORD *)(this + 36) = 0;
  *(void *)(this + 40) = 0;
  return this;
}

{
  *(void *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  *(void *)(this + 24) = 0;
  *(unsigned char *)(this + 32) = 1;
  *(unsigned char *)(this + 33) = a2;
  *(void *)this = &unk_1F263BE30;
  *(_DWORD *)(this + 36) = 0;
  *(void *)(this + 40) = 0;
  return this;
}

void llvm::DotCfgChangeReporter::handleFunctionCompare(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char *a6, size_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, __int16 a12, char a13, uint64_t a14, uint64_t a15)
{
  uint64_t v872 = *MEMORY[0x1E4F143B8];
  v800[0] = a2;
  v800[1] = a3;
  v799[0] = a4;
  v799[1] = a5;
  v798[0] = a9;
  v798[1] = a10;
  v854 = &v856;
  long long v855 = xmmword_1CD96EEC0;
  v851 = &v853;
  uint64_t v17 = a1 + 36;
  long long v852 = xmmword_1CD96EEC0;
  if (a11)
  {
    __src = "{0}_{1}";
    *(void *)&__leuint64_t n = 7;
    *((void *)&__len + sub_1CD7485C0(this + 1) = &v843;
    uint64_t v838 = 2;
    v839 = &unk_1F2617FC0;
    uint64_t v840 = a1 + 36;
    v841 = &unk_1F2617FC0;
    v842 = &a13;
    v843 = &v839;
    v844 = &v841;
    *(void *)v819 = &v819[24];
    *(_OWORD *)&v819[8] = xmmword_1CD96EEC0;
    *(_DWORD *)&v828[8] = 0;
    v829 = 0;
    v831 = v819;
    LODWORD(v830) = 0;
    *(void *)v828 = &unk_1F2646FA8;
    memset(&v828[16], 0, 25);
    sub_1CD862C68((uint64_t)&__src, (llvm::raw_ostream *)v828);
    *(void *)v828 = &unk_1F2646B98;
    if (v830 == 1 && *(void *)&v828[16]) {
      MEMORY[0x1D25D9CB0](*(void *)&v828[16], 0x1000C8077774924);
    }
    sub_1CC1B8518((uint64_t)&v854, (uint64_t)v819);
    if (*(unsigned char **)v819 != &v819[24]) {
      free(*(void **)v819);
    }
    __src = "{0}.{1}";
    *(void *)&__leuint64_t n = 7;
    *((void *)&__len + sub_1CD7485C0(this + 1) = &v843;
    uint64_t v838 = 2;
    v839 = &unk_1F2617FC0;
    uint64_t v840 = v17;
    v841 = &unk_1F2617FC0;
    v842 = &a13;
    v843 = &v839;
    v844 = &v841;
    *(void *)v819 = &v819[24];
    *(_OWORD *)&v819[8] = xmmword_1CD96EEC0;
    *(_DWORD *)&v828[8] = 0;
    v829 = 0;
    v831 = v819;
    LODWORD(v830) = 0;
    *(void *)v828 = &unk_1F2646FA8;
    memset(&v828[16], 0, 25);
    sub_1CD862C68((uint64_t)&__src, (llvm::raw_ostream *)v828);
    *(void *)v828 = &unk_1F2646B98;
    if (v830 != 1) {
      goto LABEL_12;
    }
    uint64_t v18 = *(void *)&v828[16];
    if (!*(void *)&v828[16]) {
      goto LABEL_12;
    }
LABEL_603:
    MEMORY[0x1D25D9CB0](v18, 0x1000C8077774924);
    goto LABEL_12;
  }
  *(void *)v828 = "{0}";
  *(void *)&v828[8] = 3;
  *(void *)&v828[16] = &v829;
  *(void *)&v828[24] = 1;
  *(void *)&v828[32] = &unk_1F2617FC0;
  *(void *)&v828[40] = a1 + 36;
  v829 = &v828[32];
  *(void *)v819 = &v819[24];
  *(_OWORD *)&v819[8] = xmmword_1CD96EEC0;
  LODWORD(__len) = 0;
  LOBYTE(v840) = 0;
  v841 = 0;
  v843 = (void **)v819;
  LODWORD(v842) = 0;
  __src = &unk_1F2646FA8;
  *((void *)&__len + sub_1CD7485C0(this + 1) = 0;
  v839 = 0;
  uint64_t v838 = 0;
  sub_1CD862C68((uint64_t)v828, (llvm::raw_ostream *)&__src);
  __src = &unk_1F2646B98;
  if (v842 == 1 && *((void *)&__len + 1)) {
    MEMORY[0x1D25D9CB0](*((void *)&__len + 1), 0x1000C8077774924);
  }
  sub_1CC1B8518((uint64_t)&v854, (uint64_t)v819);
  if (*(unsigned char **)v819 != &v819[24]) {
    free(*(void **)v819);
  }
  *(void *)v828 = "{0}";
  *(void *)&v828[8] = 3;
  *(void *)&v828[16] = &v829;
  *(void *)&v828[24] = 1;
  *(void *)&v828[32] = &unk_1F2617FC0;
  *(void *)&v828[40] = v17;
  v829 = &v828[32];
  *(void *)v819 = &v819[24];
  *(_OWORD *)&v819[8] = xmmword_1CD96EEC0;
  LODWORD(__len) = 0;
  LOBYTE(v840) = 0;
  v841 = 0;
  v843 = (void **)v819;
  LODWORD(v842) = 0;
  __src = &unk_1F2646FA8;
  *((void *)&__len + sub_1CD7485C0(this + 1) = 0;
  v839 = 0;
  uint64_t v838 = 0;
  sub_1CD862C68((uint64_t)v828, (llvm::raw_ostream *)&__src);
  __src = &unk_1F2646B98;
  if (v842 == 1)
  {
    uint64_t v18 = *((void *)&__len + 1);
    if (*((void *)&__len + 1)) {
      goto LABEL_603;
    }
  }
LABEL_12:
  sub_1CC1B8518((uint64_t)&v851, (uint64_t)v819);
  if (*(unsigned char **)v819 != &v819[24]) {
    free(*(void **)v819);
  }
  v848 = v850;
  long long v849 = xmmword_1CFAC3020;
  __src = "cfgdot-%%%%%%.dot";
  LOWORD(v839) = 259;
  llvm::sys::fs::createUniquePath((uint64_t)&__src, &v848, 1);
  LOWORD(v839) = 261;
  __src = v848;
  *(void *)&__leuint64_t n = v849;
  llvm::Twine::str((llvm::Twine *)&__src, &v795);
  *(void *)v828 = "diff_{0}.pdf";
  *(void *)&v828[8] = 12;
  *(void *)&v828[16] = &v829;
  *(void *)&v828[24] = 1;
  *(void *)&v828[32] = &unk_1F263C228;
  *(void *)&v828[40] = &v854;
  v829 = &v828[32];
  v845 = v847;
  long long v846 = xmmword_1CFB28E20;
  LODWORD(__len) = 0;
  LOBYTE(v840) = 0;
  v841 = 0;
  v843 = &v845;
  LODWORD(v842) = 0;
  __src = &unk_1F2646FA8;
  *((void *)&__len + sub_1CD7485C0(this + 1) = 0;
  v839 = 0;
  uint64_t v838 = 0;
  sub_1CD862C68((uint64_t)v828, (llvm::raw_ostream *)&__src);
  __src = &unk_1F2646B98;
  if (v842 == 1 && *((void *)&__len + 1)) {
    MEMORY[0x1D25D9CB0](*((void *)&__len + 1), 0x1000C8077774924);
  }
  __src = &v838;
  __leuint64_t n = xmmword_1CFB2C4B0;
  sub_1CCCCF208(&v857, a6, a7);
  *(std::string *)&v828[8] = v857;
  std::string::size_type v19 = v857.__r_.__value_.__r.__words[2];
  memset(&v857, 0, sizeof(v857));
  *(void *)v819 = "{0}.{1}{2}{3}{4}";
  *(void *)&v819[8] = 16;
  *(void *)&v819[16] = v827;
  *(void *)&v819[24] = 5;
  *(void *)&long long v820 = &unk_1F263C228;
  *((void *)&v820 + sub_1CD7485C0(this + 1) = &v851;
  v821[0] = &unk_1F2617F90;
  v821[1] = v799;
  long long __p = *(_OWORD *)&v828[8];
  v822 = &unk_1F2619700;
  std::string::size_type v824 = v19;
  v825[0] = &unk_1F2617F90;
  v825[1] = v798;
  v826[0] = &unk_1F2617F90;
  v826[1] = v800;
  v827[0] = &v820;
  v827[1] = v821;
  v827[2] = &v822;
  v827[3] = v825;
  v827[4] = v826;
  *(void *)v828 = &v828[24];
  *(_OWORD *)&v828[8] = xmmword_1CFB2C4B0;
  *(_DWORD *)&v864[8] = 0;
  char v865 = 0;
  uint64_t v866 = 0;
  v868 = (long long *)v828;
  int v867 = 0;
  *(void *)v864 = &unk_1F2646FA8;
  memset(&v864[16], 0, 24);
  sub_1CD862C68((uint64_t)v819, (llvm::raw_ostream *)v864);
  *(void *)v864 = &unk_1F2646B98;
  if (v867 == 1 && *(void *)&v864[16]) {
    MEMORY[0x1D25D9CB0](*(void *)&v864[16], 0x1000C8077774924);
  }
  sub_1CC1B8518((uint64_t)&__src, (uint64_t)v828);
  if (*(unsigned char **)v828 != &v828[24]) {
    free(*(void **)v828);
  }
  v822 = &unk_1F2619700;
  if (SHIBYTE(v824) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v857.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v857.__r_.__value_.__l.__data_);
  }
  int v20 = __src;
  size_t v21 = __len;
  memset(v828, 0, 44);
  *(_DWORD *)&v828[44] = 16;
  uint64_t v22 = &v830;
  if (__src)
  {
    if ((unint64_t)__len > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_1423;
    }
    if ((unint64_t)__len >= 0x17)
    {
      uint64_t v23 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
      if (((unint64_t)__len | 7) != 0x17) {
        uint64_t v23 = __len | 7;
      }
      uint64_t v24 = v23 + 1;
      uint64_t v22 = operator new(v23 + 1);
      unint64_t v832 = v24 | 0x8000000000000000;
      v830 = v22;
      v831 = (unsigned char *)v21;
    }
    else
    {
      HIBYTE(v832) = __len;
      if (!(void)__len) {
        goto LABEL_32;
      }
    }
    memmove(v22, v20, v21);
LABEL_32:
    *((unsigned char *)v22 + v2sub_1CD7485C0(this + 1) = 0;
    goto LABEL_33;
  }
  v830 = 0;
  v831 = 0;
  unint64_t v832 = 0;
LABEL_33:
  uint64_t v834 = 0;
  uint64_t v833 = 0;
  uint64_t v835 = 0x2000000000;
  *(_OWORD *)&v857.__r_.__value_.__l.__data_ = 0uLL;
  v857.__r_.__value_.__r.__words[2] = 0x1800000000;
  uint64_t v25 = *(unsigned int *)(a14 + 32);
  uint64_t v734 = a14;
  int64x2_t v26 = *(uint64_t **)(a14 + 24);
  if (v25)
  {
    while (!*v26 || *v26 == -8)
      ++v26;
  }
  uint64_t v759 = *(void *)(a14 + 24) + 8 * v25;
  if (v26 != (uint64_t *)v759)
  {
    uint64_t v27 = *v26;
    do
    {
      size_t v28 = *(void *)v27;
      if (byte_1EBD0A987 >= 0) {
        uint64_t v29 = byte_1EBD0A987 & 0x7F;
      }
      else {
        uint64_t v29 = unk_1EBD0A978;
      }
      if (byte_1EBD0A987 >= 0) {
        std::string::size_type v30 = &qword_1EBD0A970;
      }
      else {
        std::string::size_type v30 = (uint64_t *)qword_1EBD0A970;
      }
      uint64_t v775 = v27 + 88;
      sub_1CCCCFA04((uint64_t)v828, (unsigned __int8 *)(v27 + 88), v28, v27 + 8, (uint64_t)v30, v29);
      uint64_t v33 = *(std::string::size_type ***)(v27 + 56);
      uint64_t v32 = v27 + 56;
      uint64_t v31 = v33;
      uint64_t v34 = *(unsigned int *)(v32 + 8);
      if (v34)
      {
        for (std::string::size_type i = v31; ; ++i)
        {
          BOOL v36 = !*i || *i + 1 == 0;
          if (!v36) {
            break;
          }
        }
      }
      else
      {
        std::string::size_type i = v31;
      }
      uint64_t v37 = &v31[v34];
      while (i != v37)
      {
        *(_WORD *)&v864[32] = 773;
        *(void *)v864 = v775;
        *(void *)&v864[8] = v28;
        *(void *)&v864[16] = " ";
        int v39 = *i + 4;
        std::string::size_type v38 = **i;
        if (v38 > 0x7FFFFFFFFFFFFFF7) {
          goto LABEL_1423;
        }
        if (v38 >= 0x17)
        {
          uint64_t v41 = (v38 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v38 | 7) != 0x17) {
            uint64_t v41 = v38 | 7;
          }
          uint64_t v42 = v41 + 1;
          p_dst = (std::string *)operator new(v41 + 1);
          __dst.__r_.__value_.__r.__words[2] = v42 | 0x8000000000000000;
          __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
          __dst.__r_.__value_.__l.__size_ = v38;
LABEL_60:
          memmove(p_dst, v39, v38);
          goto LABEL_61;
        }
        *((unsigned char *)&__dst.__r_.__value_.__s + 23) = **i;
        p_dst = &__dst;
        if (v38) {
          goto LABEL_60;
        }
LABEL_61:
        p_dst->__r_.__value_.__s.__data_[v38] = 0;
        char v43 = v864[32];
        if (v864[32] == 1)
        {
          *(void *)v819 = &__dst;
          *(_OWORD *)&v819[16] = *(_OWORD *)&v806.__r_.__value_.__l.__data_;
          LOWORD(v820) = 260;
          *(_DWORD *)((char *)&v820 + 2) = v804;
          WORD3(v820) = WORD2(v804);
        }
        else if (v864[32])
        {
          if (v864[33] != 1) {
            char v43 = 2;
          }
          uint64_t v44 = v864;
          if (v864[33] == 1) {
            uint64_t v44 = *(unsigned char **)v864;
          }
          *(void *)v819 = v44;
          *(void *)&v819[8] = *(void *)&v864[8];
          *(void *)&v819[16] = &__dst;
          LOBYTE(v820) = v43;
          BYTE1(v820) = 4;
        }
        else
        {
          LOWORD(v820) = 256;
        }
        llvm::Twine::str((llvm::Twine *)v819, &v869);
        uint64_t v45 = std::string::append((std::string *)&v869, " ");
        std::string::size_type v46 = v45->__r_.__value_.__r.__words[2];
        *(_OWORD *)&__str.__r_.__value_.__l.__data_ = *(_OWORD *)&v45->__r_.__value_.__l.__data_;
        __str.__r_.__value_.__r.__words[2] = v46;
        v45->__r_.__value_.__l.__size_ = 0;
        v45->__r_.__value_.__r.__words[2] = 0;
        v45->__r_.__value_.__r.__words[0] = 0;
        uint64_t v47 = sub_1CD746CCC(v32, (unsigned __int8 *)*i + 32, **i);
        if (!v47)
        {
          std::string::size_type size = 0;
          std::string::size_type v50 = 0;
          char v51 = 0;
          memset(&v871, 0, sizeof(v871));
          goto LABEL_81;
        }
        std::string::size_type v52 = v48;
        if (v48 > 0x7FFFFFFFFFFFFFF7) {
          goto LABEL_1423;
        }
        uint64_t v53 = (const void *)v47;
        if (v48 >= 0x17)
        {
          uint64_t v55 = (v48 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v48 | 7) != 0x17) {
            uint64_t v55 = v48 | 7;
          }
          uint64_t v56 = v55 + 1;
          uint64_t v54 = operator new(v55 + 1);
          v871.__r_.__value_.__l.__size_ = v52;
          v871.__r_.__value_.__r.__words[2] = v56 | 0x8000000000000000;
          v871.__r_.__value_.__r.__words[0] = (std::string::size_type)v54;
        }
        else
        {
          *((unsigned char *)&v871.__r_.__value_.__s + 23) = v48;
          uint64_t v54 = &v871;
          if (!v48) {
            goto LABEL_80;
          }
        }
        memmove(v54, v53, v52);
LABEL_80:
        *((unsigned char *)v54 + v52) = 0;
        char v51 = HIBYTE(v871.__r_.__value_.__r.__words[2]);
        std::string::size_type size = v871.__r_.__value_.__l.__size_;
        std::string::size_type v50 = v871.__r_.__value_.__r.__words[0];
LABEL_81:
        BOOL v57 = v51 < 0;
        if (v51 >= 0) {
          int v58 = &v871;
        }
        else {
          int v58 = (std::string *)v50;
        }
        std::string::size_type v59 = v51 & 0x7F;
        if (v57) {
          std::string::size_type v60 = size;
        }
        else {
          std::string::size_type v60 = v59;
        }
        size_t v61 = std::string::append(&__str, (const std::string::value_type *)v58, v60);
        std::string::size_type v62 = v61->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v811.__r_.__value_.__l.__data_ = *(_OWORD *)&v61->__r_.__value_.__l.__data_;
        v811.__r_.__value_.__r.__words[2] = v62;
        v61->__r_.__value_.__l.__size_ = 0;
        v61->__r_.__value_.__r.__words[2] = 0;
        v61->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v871.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v871.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__str.__r_.__value_.__l.__data_);
        }
        if (SBYTE7(v870) < 0) {
          operator delete((void *)v869);
        }
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        if ((v811.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          unint64_t v63 = &v811;
        }
        else {
          unint64_t v63 = (std::string *)v811.__r_.__value_.__r.__words[0];
        }
        if ((v811.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          size_t v64 = *((unsigned char *)&v811.__r_.__value_.__s + 23) & 0x7F;
        }
        else {
          size_t v64 = v811.__r_.__value_.__l.__size_;
        }
        v786 = v63;
        *(void *)&long long v787 = v64;
        uint64_t v65 = (uint64_t *)qword_1EBD0A970;
        if (byte_1EBD0A987 >= 0) {
          uint64_t v65 = &qword_1EBD0A970;
        }
        unint64_t v66 = byte_1EBD0A987 & 0x7F;
        if (byte_1EBD0A987 < 0) {
          unint64_t v66 = unk_1EBD0A978;
        }
        *((void *)&v787 + sub_1CD7485C0(this + 1) = v65;
        unint64_t v788 = v66;
        sub_1CD4F3918((uint64_t)&v857, (unsigned __int8 *)v63, v64, (long long *)((char *)&v787 + 8));
        if (SHIBYTE(v811.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v811.__r_.__value_.__l.__data_);
        }
        do
        {
          std::string::size_type v68 = i[1];
          ++i;
          int v67 = v68;
          if (v68) {
            BOOL v69 = v67 + 1 == 0;
          }
          else {
            BOOL v69 = 1;
          }
        }
        while (v69);
      }
      do
      {
        uint64_t v70 = v26[1];
        ++v26;
        uint64_t v27 = v70;
        if (v70) {
          BOOL v71 = v27 == -8;
        }
        else {
          BOOL v71 = 1;
        }
      }
      while (v71);
    }
    while (v26 != (uint64_t *)v759);
  }
  uint64_t v732 = a15;
  uint64_t v72 = *(unsigned int *)(a15 + 32);
  if (v72)
  {
    for (uint64_t j = *(size_t ***)(a15 + 24); !*j || *j + 1 == 0; ++j)
      ;
  }
  else
  {
    uint64_t j = *(size_t ***)(a15 + 24);
  }
  uint64_t v740 = *(void *)(a15 + 24) + 8 * v72;
  if (j != (size_t **)v740)
  {
    long long v103 = *j;
    do
    {
      __s1 = v103 + 11;
      size_t v104 = *v103;
      __uint64_t n = *v103;
      uint64_t v777 = (uint64_t)(v103 + 1);
      uint64_t v105 = *(unsigned int *)&v828[32];
      if (!*(_DWORD *)&v828[32]) {
        goto LABEL_226;
      }
      int v106 = 0;
      if (v104)
      {
        size_t v107 = *v103;
        BOOL v108 = (unsigned __int8 *)(v103 + 11);
        do
        {
          int v109 = *v108++;
          int v106 = 33 * v106 + v109;
          --v107;
        }
        while (v107);
      }
      int v110 = *(_DWORD *)&v828[32] - 1;
      uint64_t v111 = *(void *)&v828[24];
      uint64_t v112 = *(void *)&v828[24] + 8 * *(unsigned int *)&v828[32] + 8;
      uint64_t v113 = *(unsigned int *)&v828[44];
      int v114 = 1;
      int v115 = v106;
      while (1)
      {
        uint64_t v116 = v115 & v110;
        uint64_t v117 = *(void **)(v111 + 8 * v116);
        if (v117 != (void *)-8)
        {
          if (!v117) {
            goto LABEL_226;
          }
          if (*(_DWORD *)(v112 + 4 * v116) == v106 && v104 == *v117)
          {
            if (!v104)
            {
              if (v116 == -1 || (int)v116 == v105) {
                goto LABEL_226;
              }
              int v119 = 0;
LABEL_203:
              int v760 = -1;
              int v123 = 1;
              int v124 = v119;
              while (1)
              {
                uint64_t v125 = v124 & v110;
                uint64_t v126 = *(void *)(v111 + 8 * v125);
                if (!v126) {
                  break;
                }
                if (v126 == -8)
                {
                  if (v760 == -1) {
                    int v127 = v124 & v110;
                  }
                  else {
                    int v127 = v760;
                  }
                  int v760 = v127;
                }
                else if (*(_DWORD *)(v112 + 4 * v125) == v119 {
                       && __n == *(void *)v126
                }
                       && (!__n || !memcmp(__s1, (const void *)(v126 + v113), __n)))
                {
                  goto LABEL_219;
                }
                int v124 = v123 + v125;
                ++v123;
              }
              uint64_t v128 = v760;
              if (v760 == -1)
              {
                uint64_t v128 = v125;
                uint64_t v125 = v125;
              }
              else
              {
                uint64_t v125 = v760;
              }
              *(_DWORD *)(v112 + 4 * v128) = v119;
              uint64_t v126 = *(void *)(v111 + 8 * v125);
LABEL_219:
              if (v126)
              {
                if (v126 == -8)
                {
                  --*(_DWORD *)&v828[40];
                  goto LABEL_220;
                }
              }
              else
              {
LABEL_220:
                unint64_t v129 = (char *)operator new(__n + 17, (std::align_val_t)8uLL);
                size_t v130 = __n;
                uint64_t v131 = v129;
                uint64_t v132 = v129 + 16;
                if (__n)
                {
                  memcpy(v129 + 16, __s1, __n);
                  size_t v130 = __n;
                }
                v132[v130] = 0;
                *(void *)uint64_t v131 = v130;
                *((_DWORD *)v131 + 2) = 0;
                *(void *)(v111 + 8 * v125) = v131;
                ++*(_DWORD *)&v828[36];
                unsigned int v133 = llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)&v828[24], v125);
                for (k = (uint64_t *)(*(void *)&v828[24] + 8 * v133); ; ++k)
                {
                  uint64_t v126 = *k;
                  if (*k && v126 != -8) {
                    break;
                  }
                }
              }
              BOOL v193 = (void *)(*(void *)v828 + 120 * *(unsigned int *)(v126 + 8));
              v193[3] = v777;
              v194 = (uint64_t *)qword_1EBD0AB40;
              if (byte_1EBD0AB57 >= 0) {
                v194 = &qword_1EBD0AB40;
              }
              uint64_t v195 = byte_1EBD0AB57 & 0x7F;
              if (byte_1EBD0AB57 < 0) {
                uint64_t v195 = unk_1EBD0AB48;
              }
              v193[4] = v194;
              v193[5] = v195;
              goto LABEL_233;
            }
            int v118 = memcmp(__s1, (char *)v117 + v113, __n);
            size_t v104 = __n;
            if (!v118) {
              break;
            }
          }
        }
        int v115 = v114 + v116;
        ++v114;
      }
      if (v116 != -1 && (int)v116 != v105)
      {
        int v119 = 0;
        size_t v120 = __n;
        uint64_t v121 = (unsigned __int8 *)(v103 + 11);
        do
        {
          int v122 = *v121++;
          int v119 = 33 * v119 + v122;
          --v120;
        }
        while (v120);
        goto LABEL_203;
      }
LABEL_226:
      if (byte_1EBD0AA6F >= 0) {
        uint64_t v135 = byte_1EBD0AA6F & 0x7F;
      }
      else {
        uint64_t v135 = unk_1EBD0AA60;
      }
      if (byte_1EBD0AA6F >= 0) {
        uint64_t v136 = &qword_1EBD0AA58;
      }
      else {
        uint64_t v136 = (uint64_t *)qword_1EBD0AA58;
      }
      sub_1CCCCFA04((uint64_t)v828, (unsigned __int8 *)__s1, v104, v777, (uint64_t)v136, v135);
LABEL_233:
      size_t v139 = v103[7];
      uint64_t v138 = (uint64_t)(v103 + 7);
      v137 = (std::string::size_type **)v139;
      uint64_t v140 = *(unsigned int *)(v138 + 8);
      if (v140)
      {
        uint64_t v141 = v137;
        size_t v142 = __n;
        while (!*v141 || *v141 + 1 == 0)
          ++v141;
      }
      else
      {
        uint64_t v141 = v137;
        size_t v142 = __n;
      }
      uint64_t v144 = &v137[v140];
      size_t v746 = (size_t)v144;
      while (2)
      {
        if (v141 != v144)
        {
          *(_WORD *)&v864[32] = 773;
          *(void *)v864 = __s1;
          *(void *)&v864[8] = v142;
          *(void *)&v864[16] = " ";
          long long v146 = *v141 + 4;
          std::string::size_type v145 = **v141;
          if (v145 > 0x7FFFFFFFFFFFFFF7) {
            goto LABEL_1423;
          }
          if (v145 >= 0x17)
          {
            uint64_t v148 = (v145 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v145 | 7) != 0x17) {
              uint64_t v148 = v145 | 7;
            }
            uint64_t v149 = v148 + 1;
            long long v147 = operator new(v148 + 1);
            v871.__r_.__value_.__l.__size_ = v145;
            v871.__r_.__value_.__r.__words[2] = v149 | 0x8000000000000000;
            v871.__r_.__value_.__r.__words[0] = (std::string::size_type)v147;
          }
          else
          {
            *((unsigned char *)&v871.__r_.__value_.__s + 23) = **v141;
            long long v147 = &v871;
            if (!v145)
            {
LABEL_252:
              v147[v145] = 0;
              char v150 = v864[32];
              if (v864[32] == 1)
              {
                *(void *)v819 = &v871;
                *(_OWORD *)&v819[16] = v804;
                LOWORD(v820) = 260;
                *(_DWORD *)((char *)&v820 + 2) = v802;
                WORD3(v820) = WORD2(v802);
              }
              else if (v864[32])
              {
                if (v864[33] != 1) {
                  char v150 = 2;
                }
                long long v151 = v864;
                if (v864[33] == 1) {
                  long long v151 = *(unsigned char **)v864;
                }
                *(void *)v819 = v151;
                *(void *)&v819[8] = *(void *)&v864[8];
                *(void *)&v819[16] = &v871;
                LOBYTE(v820) = v150;
                BYTE1(v820) = 4;
              }
              else
              {
                LOWORD(v820) = 256;
              }
              llvm::Twine::str((llvm::Twine *)v819, &__dst);
              long long v152 = std::string::append(&__dst, " ");
              std::string::size_type v153 = v152->__r_.__value_.__r.__words[2];
              long long v869 = *(_OWORD *)&v152->__r_.__value_.__l.__data_;
              *(void *)&long long v870 = v153;
              v152->__r_.__value_.__l.__size_ = 0;
              v152->__r_.__value_.__r.__words[2] = 0;
              v152->__r_.__value_.__r.__words[0] = 0;
              uint64_t v154 = sub_1CD746CCC(v138, (unsigned __int8 *)*v141 + 32, **v141);
              if (!v154)
              {
                std::string::size_type v156 = 0;
                std::string::size_type v157 = 0;
                char v158 = 0;
                memset(&v806, 0, sizeof(v806));
                goto LABEL_272;
              }
              std::string::size_type v159 = v155;
              if (v155 > 0x7FFFFFFFFFFFFFF7) {
                goto LABEL_1423;
              }
              long long v160 = (const void *)v154;
              if (v155 >= 0x17)
              {
                uint64_t v162 = (v155 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v155 | 7) != 0x17) {
                  uint64_t v162 = v155 | 7;
                }
                uint64_t v163 = v162 + 1;
                long long v161 = operator new(v162 + 1);
                v806.__r_.__value_.__r.__words[2] = v163 | 0x8000000000000000;
                v806.__r_.__value_.__r.__words[0] = (std::string::size_type)v161;
                v806.__r_.__value_.__l.__size_ = v159;
              }
              else
              {
                *((unsigned char *)&v806.__r_.__value_.__s + 23) = v155;
                long long v161 = &v806;
                if (!v155) {
                  goto LABEL_271;
                }
              }
              memmove(v161, v160, v159);
LABEL_271:
              *((unsigned char *)v161 + v159) = 0;
              char v158 = HIBYTE(v806.__r_.__value_.__r.__words[2]);
              std::string::size_type v156 = v806.__r_.__value_.__l.__size_;
              std::string::size_type v157 = v806.__r_.__value_.__r.__words[0];
LABEL_272:
              BOOL v164 = v158 < 0;
              if (v158 >= 0) {
                long long v165 = &v806;
              }
              else {
                long long v165 = (std::string *)v157;
              }
              std::string::size_type v166 = v158 & 0x7F;
              if (v164) {
                std::string::size_type v167 = v156;
              }
              else {
                std::string::size_type v167 = v166;
              }
              long long v168 = std::string::append((std::string *)&v869, (const std::string::value_type *)v165, v167);
              std::string::size_type v169 = v168->__r_.__value_.__r.__words[2];
              *(_OWORD *)&__str.__r_.__value_.__l.__data_ = *(_OWORD *)&v168->__r_.__value_.__l.__data_;
              __str.__r_.__value_.__r.__words[2] = v169;
              v168->__r_.__value_.__l.__size_ = 0;
              v168->__r_.__value_.__r.__words[2] = 0;
              v168->__r_.__value_.__r.__words[0] = 0;
              if (SHIBYTE(v806.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v806.__r_.__value_.__l.__data_);
              }
              if (SBYTE7(v870) < 0) {
                operator delete((void *)v869);
              }
              if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__dst.__r_.__value_.__l.__data_);
              }
              if (SHIBYTE(v871.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v871.__r_.__value_.__l.__data_);
              }
              p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
              if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                p_str = &__str;
              }
              v778 = p_str;
              if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                size_t v171 = *((unsigned char *)&__str.__r_.__value_.__s + 23) & 0x7F;
              }
              else {
                size_t v171 = __str.__r_.__value_.__l.__size_;
              }
              uint64_t v750 = LODWORD(v857.__r_.__value_.__r.__words[1]);
              if (!LODWORD(v857.__r_.__value_.__r.__words[1])) {
                goto LABEL_312;
              }
              int v172 = 0;
              if (v171)
              {
                size_t v173 = v171;
                do
                {
                  int v174 = p_str->__r_.__value_.__s.__data_[0];
                  p_str = (std::string *)((char *)p_str + 1);
                  int v172 = 33 * v172 + v174;
                  --v173;
                }
                while (v173);
              }
              int v175 = LODWORD(v857.__r_.__value_.__r.__words[1]) - 1;
              std::string::size_type v176 = v857.__r_.__value_.__r.__words[0];
              std::string::size_type v177 = v857.__r_.__value_.__r.__words[0] + 8 * LODWORD(v857.__r_.__value_.__r.__words[1]) + 8;
              uint64_t v761 = HIDWORD(v857.__r_.__value_.__r.__words[2]);
              int v178 = 1;
              int v179 = v172;
              while (1)
              {
                uint64_t v180 = v179 & v175;
                int v181 = *(void **)(v176 + 8 * v180);
                if (v181 != (void *)-8)
                {
                  if (!v181) {
                    goto LABEL_312;
                  }
                  if (*(_DWORD *)(v177 + 4 * v180) == v172
                    && v171 == *v181
                    && (!v171 || !memcmp(v778, (char *)v181 + v761, v171)))
                  {
                    break;
                  }
                }
                int v179 = v178 + v180;
                ++v178;
              }
              if (v180 == -1 || (int)v180 == v750)
              {
LABEL_312:
                v811.__r_.__value_.__r.__words[0] = (std::string::size_type)v778;
                v811.__r_.__value_.__l.__size_ = v171;
                int v185 = (uint64_t *)qword_1EBD0AA58;
                if (byte_1EBD0AA6F >= 0) {
                  int v185 = &qword_1EBD0AA58;
                }
                uint64_t v186 = byte_1EBD0AA6F & 0x7F;
                if (byte_1EBD0AA6F < 0) {
                  uint64_t v186 = unk_1EBD0AA60;
                }
                v811.__r_.__value_.__r.__words[2] = (std::string::size_type)v185;
                uint64_t v812 = v186;
                sub_1CD4F3918((uint64_t)&v857, (unsigned __int8 *)v778, v171, &v811.__r_.__value_.__r.__words[2]);
              }
              else
              {
                if (byte_1EBD0AB57 >= 0) {
                  BOOL v182 = &qword_1EBD0AB40;
                }
                else {
                  BOOL v182 = (uint64_t *)qword_1EBD0AB40;
                }
                if (byte_1EBD0AB57 >= 0) {
                  size_t v183 = byte_1EBD0AB57 & 0x7F;
                }
                else {
                  size_t v183 = unk_1EBD0AB48;
                }
                int v184 = *sub_1CD6ECD1C((uint64_t)&v857, (unsigned __int8 *)v778, v171);
                v184[1] = (size_t)v182;
                v184[2] = v183;
              }
              size_t v142 = __n;
              if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
              {
                operator delete(__str.__r_.__value_.__l.__data_);
                size_t v142 = __n;
              }
              do
              {
                BOOL v188 = v141[1];
                ++v141;
                int v187 = v188;
                if (v188) {
                  BOOL v189 = v187 + 1 == 0;
                }
                else {
                  BOOL v189 = 1;
                }
              }
              while (v189);
              uint64_t v144 = (std::string::size_type **)v746;
              continue;
            }
          }
          memmove(v147, v146, v145);
          goto LABEL_252;
        }
        break;
      }
      do
      {
        v190 = j[1];
        ++j;
        long long v103 = v190;
        if (v190) {
          BOOL v191 = v103 + 1 == 0;
        }
        else {
          BOOL v191 = 1;
        }
      }
      while (v191);
    }
    while (j != (size_t **)v740);
  }
  if (LODWORD(v857.__r_.__value_.__r.__words[1]))
  {
    for (m = (unint64_t **)v857.__r_.__value_.__r.__words[0]; !*m || *m + 1 == 0; ++m)
      ;
  }
  else
  {
    m = (unint64_t **)v857.__r_.__value_.__r.__words[0];
  }
  std::string::size_type v738 = v857.__r_.__value_.__r.__words[0] + 8 * LODWORD(v857.__r_.__value_.__r.__words[1]);
  if (m == (unint64_t **)v738) {
    goto LABEL_123;
  }
  v197 = *m;
  do
  {
    unint64_t v198 = *v197;
    *(void *)&long long v802 = v197 + 3;
    *((void *)&v802 + sub_1CD7485C0(this + 1) = v198;
    __str.__r_.__value_.__s.__data_[0] = 32;
    unint64_t v199 = llvm::StringRef::rfind((uint64_t *)&v802, &__str, 1uLL);
    if (v199 == -1)
    {
      BOOL v200 = 0;
      size_t v201 = 0;
      *(_OWORD *)v819 = v802;
    }
    else
    {
      if (v198 >= v199) {
        unint64_t v202 = v199;
      }
      else {
        unint64_t v202 = v198;
      }
      if (v198 >= v199 + 1) {
        unint64_t v203 = v199 + 1;
      }
      else {
        unint64_t v203 = v198;
      }
      BOOL v200 = (char *)v197 + v203 + 24;
      size_t v201 = v198 - v203;
      *(void *)v819 = v197 + 3;
      *(void *)&v819[8] = v202;
    }
    *(void *)&v819[16] = v200;
    *(void *)&v819[24] = v201;
    __str.__r_.__value_.__s.__data_[0] = 32;
    unint64_t v204 = llvm::StringRef::find((uint64_t *)v819, (char *)&__str, 1uLL, 0);
    if (v204 == -1)
    {
      __na = 0;
      size_t v205 = 0;
      size_t v206 = *(void *)&v819[8];
      v762 = *(unsigned __int8 **)v819;
    }
    else
    {
      if (*(void *)&v819[8] >= v204) {
        size_t v206 = v204;
      }
      else {
        size_t v206 = *(void *)&v819[8];
      }
      if (*(void *)&v819[8] >= v204 + 1) {
        unint64_t v207 = v204 + 1;
      }
      else {
        unint64_t v207 = *(void *)&v819[8];
      }
      v762 = *(unsigned __int8 **)v819;
      __na = (unsigned __int8 *)(*(void *)v819 + v207);
      size_t v205 = *(void *)&v819[8] - v207;
    }
    size_t v779 = v205;
    unsigned int v208 = *(_DWORD *)&v828[32];
    if (!*(_DWORD *)&v828[32])
    {
      *(void *)&v828[32] = 0;
      *(_DWORD *)&v828[40] = 0;
      BOOL v227 = malloc_type_calloc(0x11uLL, 0xCuLL, 0x6D9A4F0CuLL);
      if (!v227) {
        goto LABEL_1438;
      }
      v227[16] = 2;
      *(void *)&v828[24] = v227;
      unsigned int v208 = 16;
      *(_DWORD *)&v828[32] = 16;
    }
    int v209 = 0;
    if (v206)
    {
      size_t v210 = v206;
      BOOL v211 = v762;
      do
      {
        int v212 = *v211++;
        int v209 = 33 * v209 + v212;
        --v210;
      }
      while (v210);
    }
    v743 = v200;
    size_t v747 = v201;
    unsigned int v213 = v208 - 1;
    BOOL v214 = *(void **)&v828[24];
    uint64_t v215 = *(void *)&v828[24] + 8 * v208 + 8;
    __s1a = (char *)*(unsigned int *)&v828[44];
    int v751 = -1;
    int v216 = 1;
    int v217 = v209;
    while (1)
    {
      uint64_t v218 = v217 & v213;
      uint64_t v219 = v214[v218];
      if (!v219) {
        break;
      }
      if (v219 == -8)
      {
        if (v751 == -1) {
          int v220 = v217 & v213;
        }
        else {
          int v220 = v751;
        }
        int v751 = v220;
      }
      else if (*(_DWORD *)(v215 + 4 * v218) == v209 {
             && v206 == *(void *)v219
      }
             && (!v206 || !memcmp(v762, &__s1a[v219], v206)))
      {
        goto LABEL_389;
      }
      int v217 = v216 + v218;
      ++v216;
    }
    uint64_t v221 = v751;
    if (v751 == -1)
    {
      uint64_t v221 = v218;
      uint64_t v218 = v218;
    }
    else
    {
      uint64_t v218 = v751;
    }
    *(_DWORD *)(v215 + 4 * v22sub_1CD7485C0(this + 1) = v209;
    uint64_t v219 = v214[v218];
LABEL_389:
    if (v219)
    {
      if (v219 != -8)
      {
        size_t v229 = v779;
        goto LABEL_402;
      }
      --*(_DWORD *)&v828[40];
    }
    v222 = (char *)operator new(v206 + 17, (std::align_val_t)8uLL);
    BOOL v223 = v222;
    v224 = v222 + 16;
    if (v206) {
      memcpy(v222 + 16, v762, v206);
    }
    v224[v206] = 0;
    *(void *)BOOL v223 = v206;
    *((_DWORD *)v223 + 2) = 0;
    v214[v218] = v223;
    ++*(_DWORD *)&v828[36];
    unsigned int v225 = llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)&v828[24], v218);
    BOOL v214 = *(void **)&v828[24];
    for (uint64_t n = 8 * v225; ; n += 8)
    {
      uint64_t v219 = *(void *)(*(void *)&v828[24] + n);
      BOOL v228 = !v219 || v219 == -8;
      size_t v229 = v779;
      if (!v228) {
        break;
      }
    }
LABEL_402:
    unsigned int v230 = *(_DWORD *)(v219 + 8);
    uint64_t v231 = *(void *)v828;
    unsigned int v232 = *(_DWORD *)&v828[32];
    if (!*(_DWORD *)&v828[32])
    {
      *(void *)&v828[32] = 0;
      *(_DWORD *)&v828[40] = 0;
      uint64_t v252 = malloc_type_calloc(0x11uLL, 0xCuLL, 0x6D9A4F0CuLL);
      if (!v252) {
        goto LABEL_1438;
      }
      BOOL v214 = v252;
      v252[16] = 2;
      *(void *)&v828[24] = v252;
      unsigned int v232 = 16;
      *(_DWORD *)&v828[32] = 16;
      size_t v229 = v779;
    }
    unsigned int v752 = v230;
    uint64_t v741 = v231;
    int v233 = 0;
    if (v229)
    {
      BOOL v234 = __na;
      do
      {
        int v235 = *v234++;
        int v233 = 33 * v233 + v235;
        --v229;
      }
      while (v229);
    }
    unsigned int v236 = v232 - 1;
    uint64_t v237 = (uint64_t)&v214[v232 + 1];
    uint64_t v763 = *(unsigned int *)&v828[44];
    int v238 = -1;
    int v239 = 1;
    int v240 = v233;
    size_t v241 = v779;
    while (1)
    {
      uint64_t v242 = v240 & v236;
      uint64_t v243 = v214[v242];
      if (!v243) {
        break;
      }
      if (v243 == -8)
      {
        if (v238 == -1) {
          int v238 = v240 & v236;
        }
      }
      else if (*(_DWORD *)(v237 + 4 * v242) == v233 && v241 == *(void *)v243)
      {
        if (!v241) {
          goto LABEL_421;
        }
        int v244 = memcmp(__na, (const void *)(v243 + v763), v241);
        size_t v241 = v779;
        if (!v244) {
          goto LABEL_421;
        }
      }
      int v240 = v239 + v242;
      ++v239;
    }
    uint64_t v245 = v238;
    if (v238 == -1)
    {
      uint64_t v245 = v242;
      uint64_t v242 = v242;
    }
    else
    {
      uint64_t v242 = v238;
    }
    *(_DWORD *)(v237 + 4 * v245) = v233;
    uint64_t v243 = v214[v242];
LABEL_421:
    if (!v243) {
      goto LABEL_422;
    }
    if (v243 == -8)
    {
      --*(_DWORD *)&v828[40];
      size_t v241 = v779;
LABEL_422:
      BOOL v246 = (char *)operator new(v241 + 17, (std::align_val_t)8uLL);
      size_t v247 = v779;
      BOOL v248 = v246;
      BOOL v249 = v246 + 16;
      if (v779)
      {
        memcpy(v246 + 16, __na, v779);
        size_t v247 = v779;
      }
      v249[v247] = 0;
      *(void *)BOOL v248 = v247;
      *((_DWORD *)v248 + 2) = 0;
      v214[v242] = v248;
      ++*(_DWORD *)&v828[36];
      unsigned int v250 = llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)&v828[24], v242);
      for (istd::string::size_type i = (uint64_t *)(*(void *)&v828[24] + 8 * v250); ; ++ii)
      {
        uint64_t v243 = *ii;
        if (*ii && v243 != -8) {
          break;
        }
      }
    }
    unsigned int __s1b = *(_DWORD *)(v243 + 8);
    v764 = (uint64_t *)v197[1];
    size_t __nb = v197[2];
    uint64_t v780 = v834;
    if (!v834) {
      goto LABEL_513;
    }
    size_t v254 = *(void *)&v819[8];
    v255 = *(unsigned __int8 **)v819;
    int v256 = 0;
    if (*(void *)&v819[8])
    {
      uint64_t v257 = *(void *)&v819[8];
      BOOL v258 = *(unsigned __int8 **)v819;
      do
      {
        int v259 = *v258++;
        int v256 = 33 * v256 + v259;
        --v257;
      }
      while (v257);
    }
    unsigned int v260 = v834 - 1;
    uint64_t v261 = v833;
    uint64_t v262 = v833 + 8 * v834 + 8;
    uint64_t v263 = HIDWORD(v835);
    int v264 = 1;
    int v265 = v256;
    while (1)
    {
      uint64_t v266 = v265 & v260;
      BOOL v267 = *(void **)(v261 + 8 * v266);
      if (v267 == (void *)-8) {
        goto LABEL_445;
      }
      if (!v267) {
        goto LABEL_513;
      }
      if (*(_DWORD *)(v262 + 4 * v266) != v256 || v254 != *v267) {
        goto LABEL_445;
      }
      if (!v254) {
        break;
      }
      if (!memcmp(v255, (char *)v267 + v263, v254))
      {
        if (v266 != -1 && (int)v266 != v780)
        {
          int v268 = 0;
          size_t v269 = v254;
          uint64_t v270 = v255;
          do
          {
            int v271 = *v270++;
            int v268 = 33 * v268 + v271;
            --v269;
          }
          while (v269);
          goto LABEL_450;
        }
LABEL_513:
        BOOL v290 = v743;
        if (!v743)
        {
          long long v869 = 0uLL;
          *(void *)&long long v870 = 0;
          std::string::size_type v289 = v747;
          size_t v306 = __nb;
          BOOL v307 = v764;
          goto LABEL_524;
        }
        std::string::size_type v289 = v747;
        if (v747 <= 0x7FFFFFFFFFFFFFF7)
        {
          if (v747 >= 0x17)
          {
            uint64_t v311 = (v747 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v747 | 7) != 0x17) {
              uint64_t v311 = v747 | 7;
            }
            uint64_t v312 = v311 + 1;
            uint64_t v310 = (long long *)operator new(v311 + 1);
            *((void *)&v869 + sub_1CD7485C0(this + 1) = v747;
            *(void *)&long long v870 = v312 | 0x8000000000000000;
            *(void *)&long long v869 = v310;
            size_t v306 = __nb;
            BOOL v307 = v764;
          }
          else
          {
            BYTE7(v870) = v747;
            uint64_t v310 = &v869;
            size_t v306 = __nb;
            BOOL v307 = v764;
            if (!v747) {
              goto LABEL_523;
            }
          }
          memmove(v310, v743, v747);
LABEL_523:
          *((unsigned char *)v310 + v747) = 0;
LABEL_524:
          sub_1CCCCFE58((uint64_t)&__str, (uint64_t)&v869, v307, v306);
          *(_OWORD *)v864 = *(_OWORD *)v819;
          *(std::string *)&v864[16] = __str;
          sub_1CCCCF758((llvm::StringMapImpl *)&v833, *(unsigned __int8 **)v819, *(size_t *)&v819[8], (uint64_t)&v864[16]);
          if ((v864[39] & 0x80000000) != 0) {
            operator delete(*(void **)&v864[16]);
          }
          unsigned int data = __s1b;
          if (SBYTE7(v870) < 0)
          {
            uint64_t v309 = (void *)v869;
LABEL_528:
            operator delete(v309);
          }
          goto LABEL_529;
        }
LABEL_1423:
        abort();
      }
LABEL_445:
      int v265 = v264 + v266;
      ++v264;
    }
    if (v266 == -1 || (int)v266 == v780) {
      goto LABEL_513;
    }
    int v268 = 0;
LABEL_450:
    int v272 = 1;
    for (juint64_t j = v268; ; juint64_t j = v274 + v272++)
    {
      uint64_t v274 = jj & v260;
      BOOL v275 = *(void **)(v261 + 8 * v274);
      if (v275 != (void *)-8)
      {
        if (!v275) {
          goto LABEL_460;
        }
        if (*(_DWORD *)(v262 + 4 * v274) == v268
          && v254 == *v275
          && (!v254 || !memcmp(v255, (char *)v275 + v263, v254)))
        {
          break;
        }
      }
    }
    if (v274 != -1) {
      uint64_t v780 = (int)v274;
    }
LABEL_460:
    uint64_t v276 = *(void *)(v261 + 8 * v780);
    BOOL v279 = *(const void **)(v276 + 8);
    uint64_t v277 = v276 + 8;
    v278 = v279;
    char v280 = *(unsigned char *)(v277 + 23);
    if (v280 >= 0) {
      BOOL v281 = (const void *)v277;
    }
    else {
      BOOL v281 = v278;
    }
    if (!v281)
    {
      memset(&v806, 0, sizeof(v806));
      goto LABEL_477;
    }
    std::string::size_type v282 = *(void *)(v277 + 8);
    int v283 = v280;
    std::string::size_type v284 = v280 & 0x7F;
    if (v283 >= 0) {
      std::string::size_type v285 = v284;
    }
    else {
      std::string::size_type v285 = v282;
    }
    if (v285 > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_1423;
    }
    if (v285 >= 0x17)
    {
      uint64_t v287 = (v285 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v285 | 7) != 0x17) {
        uint64_t v287 = v285 | 7;
      }
      uint64_t v288 = v287 + 1;
      BOOL v286 = operator new(v287 + 1);
      v806.__r_.__value_.__r.__words[2] = v288 | 0x8000000000000000;
      v806.__r_.__value_.__r.__words[0] = (std::string::size_type)v286;
      v806.__r_.__value_.__l.__size_ = v285;
    }
    else
    {
      *((unsigned char *)&v806.__r_.__value_.__s + 23) = v285;
      BOOL v286 = &v806;
      if (!v285) {
        goto LABEL_476;
      }
    }
    memmove(v286, v281, v285);
LABEL_476:
    *((unsigned char *)v286 + v285) = 0;
LABEL_477:
    BOOL v290 = v743;
    std::string::size_type v289 = v747;
    BOOL v291 = std::string::append(&v806, " ");
    std::string::size_type v292 = v291->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v871.__r_.__value_.__l.__data_ = *(_OWORD *)&v291->__r_.__value_.__l.__data_;
    v871.__r_.__value_.__r.__words[2] = v292;
    v291->__r_.__value_.__l.__size_ = 0;
    v291->__r_.__value_.__r.__words[2] = 0;
    v291->__r_.__value_.__r.__words[0] = 0;
    if (!v743)
    {
      std::string::size_type v293 = 0;
      v294 = 0;
      char v295 = 0;
      long long v804 = 0uLL;
      unint64_t v805 = 0;
      goto LABEL_488;
    }
    if (v747 > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_1423;
    }
    if (v747 >= 0x17)
    {
      uint64_t v297 = (v747 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v747 | 7) != 0x17) {
        uint64_t v297 = v747 | 7;
      }
      uint64_t v298 = v297 + 1;
      uint64_t v296 = (long long *)operator new(v297 + 1);
      unint64_t v805 = v298 | 0x8000000000000000;
      *(void *)&long long v804 = v296;
      *((void *)&v804 + sub_1CD7485C0(this + 1) = v747;
    }
    else
    {
      HIBYTE(v805) = v747;
      uint64_t v296 = &v804;
      if (!v747) {
        goto LABEL_487;
      }
    }
    memmove(v296, v743, v747);
LABEL_487:
    *((unsigned char *)v296 + v747) = 0;
    char v295 = HIBYTE(v805);
    std::string::size_type v293 = *((void *)&v804 + 1);
    v294 = (const std::string::value_type *)v804;
LABEL_488:
    BOOL v299 = v295 < 0;
    if (v295 >= 0) {
      BOOL v300 = (const std::string::value_type *)&v804;
    }
    else {
      BOOL v300 = v294;
    }
    std::string::size_type v301 = v295 & 0x7F;
    if (v299) {
      std::string::size_type v302 = v293;
    }
    else {
      std::string::size_type v302 = v301;
    }
    BOOL v303 = std::string::append(&v871, v300, v302);
    std::string::size_type v304 = v303->__r_.__value_.__r.__words[2];
    *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = *(_OWORD *)&v303->__r_.__value_.__l.__data_;
    __dst.__r_.__value_.__r.__words[2] = v304;
    v303->__r_.__value_.__l.__size_ = 0;
    v303->__r_.__value_.__r.__words[2] = 0;
    v303->__r_.__value_.__r.__words[0] = 0;
    sub_1CCCCFE58((uint64_t)&__str, (uint64_t)&__dst, v764, __nb);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    unsigned int data = __s1b;
    if (SHIBYTE(v805) < 0) {
      operator delete((void *)v804);
    }
    if (SHIBYTE(v871.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v871.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v806.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v806.__r_.__value_.__l.__data_);
    }
    if (byte_1EBD0AB57 >= 0) {
      size_t v306 = byte_1EBD0AB57 & 0x7F;
    }
    else {
      size_t v306 = unk_1EBD0AB48;
    }
    if (byte_1EBD0AB57 >= 0) {
      BOOL v307 = &qword_1EBD0AB40;
    }
    else {
      BOOL v307 = (uint64_t *)qword_1EBD0AB40;
    }
    v308 = sub_1CD5D600C((uint64_t)&v833, *(unsigned __int8 **)v819, *(size_t *)&v819[8]);
    std::string::operator=((std::string *)(*v308 + 1), &__str);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    {
      uint64_t v309 = (void *)__str.__r_.__value_.__r.__words[0];
      goto LABEL_528;
    }
LABEL_529:
    LODWORD(v806.__r_.__value_.__l.__data_) = data;
    if (!v290)
    {
      char v313 = 0;
      std::string::size_type v314 = 0;
      memset(&__str, 0, sizeof(__str));
      goto LABEL_540;
    }
    if (v289 > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_1423;
    }
    if (v289 >= 0x17)
    {
      uint64_t v316 = (v289 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v289 | 7) != 0x17) {
        uint64_t v316 = v289 | 7;
      }
      uint64_t v317 = v316 + 1;
      int v315 = operator new(v316 + 1);
      __str.__r_.__value_.__r.__words[2] = v317 | 0x8000000000000000;
      __str.__r_.__value_.__r.__words[0] = (std::string::size_type)v315;
      __str.__r_.__value_.__l.__size_ = v289;
    }
    else
    {
      *((unsigned char *)&__str.__r_.__value_.__s + 23) = v289;
      int v315 = &__str;
      if (!v289) {
        goto LABEL_539;
      }
    }
    memmove(v315, v290, v289);
LABEL_539:
    *((unsigned char *)v315 + v289) = 0;
    std::string::size_type v314 = __str.__r_.__value_.__r.__words[0];
    char v313 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    unsigned int data = v806.__r_.__value_.__l.__data_;
LABEL_540:
    v871.__r_.__value_.__r.__words[0] = __str.__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v871.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&__str.__r_.__value_.__r.__words[1] + 7);
    BOOL v318 = sub_1CD747030((uint64_t **)(v741 + 120 * v752 + 48), data, &v806);
    int v319 = v318;
    if (v318[63] < 0) {
      operator delete(*((void **)v318 + 5));
    }
    std::string::size_type v320 = v871.__r_.__value_.__r.__words[0];
    *((void *)v319 + 5) = v314;
    *((void *)v319 + 6) = v320;
    *(void *)(v319 + 55) = *(std::string::size_type *)((char *)v871.__r_.__value_.__r.__words + 7);
    v319[63] = v313;
    *((void *)v319 + 8) = v307;
    *((void *)v319 + 9) = v306;
    do
    {
      BOOL v321 = m[1];
      ++m;
      v197 = v321;
      if (v321) {
        BOOL v322 = v197 + 1 == 0;
      }
      else {
        BOOL v322 = 1;
      }
    }
    while (v322);
  }
  while (m != (unint64_t **)v738);
LABEL_123:
  int v75 = *(void **)v828;
  for (kk = *(void **)&v828[8]; v75 != kk; v75 += 15)
  {
    uint64_t v76 = (void *)v75[6];
    if (v76 != v75 + 7)
    {
      do
      {
        *(_DWORD *)v819 = *((_DWORD *)v76 + 8);
        if (*((char *)v76 + 63) < 0)
        {
          sub_1CB8BDF7C((uint64_t)&v819[8], (const void *)v76[5], v76[6]);
        }
        else
        {
          *(_OWORD *)&v819[8] = *(_OWORD *)(v76 + 5);
          *(void *)&v819[24] = v76[7];
        }
        long long v820 = *((_OWORD *)v76 + 4);
        BOOL v78 = (char *)v75[10];
        unint64_t v77 = v75[11];
        if ((unint64_t)v78 >= v77)
        {
          uint64_t v80 = (char *)v75[9];
          uint64_t v81 = (v78 - v80) >> 2;
          unint64_t v82 = v81 + 1;
          if ((unint64_t)(v81 + 1) >> 62) {
            goto LABEL_1423;
          }
          uint64_t v83 = v77 - (void)v80;
          if (v83 >> 1 > v82) {
            unint64_t v82 = v83 >> 1;
          }
          if ((unint64_t)v83 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v84 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v84 = v82;
          }
          if (v84)
          {
            if (v84 >> 62) {
              goto LABEL_1434;
            }
            int v85 = (char *)operator new(4 * v84);
          }
          else
          {
            int v85 = 0;
          }
          int v86 = &v85[4 * v81];
          *(_DWORD *)int v86 = *(_DWORD *)v819;
          uint64_t v79 = v86 + 4;
          while (v78 != v80)
          {
            int v87 = *((_DWORD *)v78 - 1);
            v78 -= 4;
            *((_DWORD *)v86 - sub_1CD7485C0(this + 1) = v87;
            v86 -= 4;
          }
          v75[9] = v86;
          v75[10] = v79;
          v75[11] = &v85[4 * v84];
          if (v80) {
            operator delete(v80);
          }
        }
        else
        {
          *(_DWORD *)BOOL v78 = *(_DWORD *)v819;
          uint64_t v79 = v78 + 4;
        }
        v75[10] = v79;
        uint64_t v89 = (char *)v75[13];
        unint64_t v88 = v75[14];
        if ((unint64_t)v89 >= v88)
        {
          uint64_t v91 = (char *)v75[12];
          uint64_t v92 = (v89 - v91) >> 2;
          unint64_t v93 = v92 + 1;
          if ((unint64_t)(v92 + 1) >> 62) {
            goto LABEL_1423;
          }
          uint64_t v94 = v88 - (void)v91;
          if (v94 >> 1 > v93) {
            unint64_t v93 = v94 >> 1;
          }
          if ((unint64_t)v94 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v95 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v95 = v93;
          }
          if (v95)
          {
            if (v95 >> 62) {
LABEL_1434:
            }
              sub_1CB833614();
            uint64_t v96 = (char *)operator new(4 * v95);
          }
          else
          {
            uint64_t v96 = 0;
          }
          size_t v97 = &v96[4 * v92];
          *(_DWORD *)size_t v97 = *(_DWORD *)v819;
          unint64_t v90 = v97 + 4;
          while (v89 != v91)
          {
            int v98 = *((_DWORD *)v89 - 1);
            v89 -= 4;
            *((_DWORD *)v97 - sub_1CD7485C0(this + 1) = v98;
            v97 -= 4;
          }
          v75[12] = v97;
          v75[13] = v90;
          v75[14] = &v96[4 * v95];
          if (v91) {
            operator delete(v91);
          }
        }
        else
        {
          *(_DWORD *)uint64_t v89 = *(_DWORD *)v819;
          unint64_t v90 = v89 + 4;
        }
        v75[13] = v90;
        if ((v819[31] & 0x80000000) != 0) {
          operator delete(*(void **)&v819[8]);
        }
        unint64_t v99 = (void *)v76[1];
        if (v99)
        {
          do
          {
            uint64_t v100 = v99;
            unint64_t v99 = (void *)*v99;
          }
          while (v99);
        }
        else
        {
          do
          {
            uint64_t v100 = (void *)v76[2];
            BOOL v36 = *v100 == (void)v76;
            uint64_t v76 = v100;
          }
          while (!v36);
        }
        uint64_t v76 = v100;
      }
      while (v100 != v75 + 7);
    }
  }
  sub_1CD4AFD10((uint64_t)&v857);
  if (*(char *)(v732 + 79) < 0)
  {
    sub_1CB8BDF7C((uint64_t)v793, *(const void **)(v732 + 56), *(void *)(v732 + 64));
  }
  else
  {
    *(_OWORD *)v793 = *(_OWORD *)(v732 + 56);
    uint64_t v794 = *(void *)(v732 + 72);
  }
  unint64_t v323 = HIBYTE(v794);
  char v324 = HIBYTE(v794);
  BOOL v325 = v793[1];
  size_t v326 = HIBYTE(v794) & 0x7F;
  if (v794 >= 0) {
    unint64_t v327 = HIBYTE(v794) & 0x7F;
  }
  else {
    unint64_t v327 = (unint64_t)v793[1];
  }
  if (v794 < 0) {
    unint64_t v323 = (unint64_t)v793[1];
  }
  if (!(v327 | v323))
  {
    if (*(char *)(v734 + 79) < 0)
    {
      sub_1CB8BDF7C((uint64_t)v819, *(const void **)(v734 + 56), *(void *)(v734 + 64));
      if ((v794 & 0x8000000000000000) == 0)
      {
LABEL_563:
        uint64_t v794 = *(void *)&v819[16];
        *(_OWORD *)v793 = *(_OWORD *)v819;
        char v324 = v819[23];
        BOOL v325 = *(void **)&v819[8];
        size_t v326 = v819[23] & 0x7F;
        goto LABEL_564;
      }
    }
    else
    {
      *(_OWORD *)v819 = *(_OWORD *)(v734 + 56);
      *(void *)&v819[16] = *(void *)(v734 + 72);
      if ((v794 & 0x8000000000000000) == 0) {
        goto LABEL_563;
      }
    }
    operator delete(v793[0]);
    goto LABEL_563;
  }
LABEL_564:
  BOOL v328 = __src;
  size_t v329 = __len;
  BOOL v330 = v324 < 0;
  BOOL v331 = v793;
  if (v330) {
    BOOL v331 = (void **)v793[0];
  }
  v781 = v331;
  if (v330) {
    size_t v332 = (size_t)v325;
  }
  else {
    size_t v332 = v326;
  }
  unsigned int v333 = *(_DWORD *)&v828[32];
  if (!*(_DWORD *)&v828[32])
  {
    *(void *)&v828[32] = 0;
    *(_DWORD *)&v828[40] = 0;
    int v354 = malloc_type_calloc(0x11uLL, 0xCuLL, 0x6D9A4F0CuLL);
    if (v354)
    {
      v354[16] = 2;
      *(void *)&v828[24] = v354;
      unsigned int v333 = 16;
      *(_DWORD *)&v828[32] = 16;
      goto LABEL_570;
    }
LABEL_1438:
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
LABEL_570:
  size_t __nc = (size_t)v328;
  int v334 = 0;
  if (v332)
  {
    size_t v335 = v332;
    long long v336 = v781;
    do
    {
      int v337 = *(unsigned __int8 *)v336;
      long long v336 = (void **)((char *)v336 + 1);
      int v334 = 33 * v334 + v337;
      --v335;
    }
    while (v335);
  }
  size_t v765 = v329;
  unsigned int v338 = v333 - 1;
  uint64_t v339 = *(void *)&v828[24];
  uint64_t v340 = *(void *)&v828[24] + 8 * v333 + 8;
  uint64_t v341 = *(unsigned int *)&v828[44];
  int v342 = -1;
  int v343 = 1;
  int v344 = v334;
  while (1)
  {
    uint64_t v345 = v344 & v338;
    uint64_t v346 = *(void *)(v339 + 8 * v345);
    if (!v346) {
      break;
    }
    if (v346 == -8)
    {
      if (v342 == -1) {
        int v342 = v344 & v338;
      }
    }
    else if (*(_DWORD *)(v340 + 4 * v345) == v334 {
           && v332 == *(void *)v346
    }
           && (!v332 || !memcmp(v781, (const void *)(v346 + v341), v332)))
    {
      goto LABEL_588;
    }
    int v344 = v343 + v345;
    ++v343;
  }
  uint64_t v347 = v342;
  if (v342 == -1)
  {
    uint64_t v347 = v345;
    uint64_t v345 = v345;
  }
  else
  {
    uint64_t v345 = v342;
  }
  *(_DWORD *)(v340 + 4 * v347) = v334;
  uint64_t v346 = *(void *)(v339 + 8 * v345);
LABEL_588:
  if (v346)
  {
    if (v346 == -8)
    {
      --*(_DWORD *)&v828[40];
      goto LABEL_589;
    }
    int v351 = (const void *)__nc;
  }
  else
  {
LABEL_589:
    uint64_t v348 = (char *)operator new(v332 + 17, (std::align_val_t)8uLL);
    int v349 = v348;
    int v350 = v348 + 16;
    int v351 = (const void *)__nc;
    if (v332) {
      memcpy(v348 + 16, v781, v332);
    }
    v350[v332] = 0;
    *(void *)int v349 = v332;
    *((_DWORD *)v349 + 2) = 0;
    *(void *)(v339 + 8 * v345) = v349;
    ++*(_DWORD *)&v828[36];
    unsigned int v352 = llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)&v828[24], v345);
    for (mm = (uint64_t *)(*(void *)&v828[24] + 8 * v352); ; ++mm)
    {
      uint64_t v346 = *mm;
      if (*mm && v346 != -8) {
        break;
      }
    }
  }
  int v748 = *(_DWORD *)(v346 + 8);
  if (!v351)
  {
    long long v804 = 0uLL;
    unint64_t v805 = 0;
    LOBYTE(v786) = 0;
    goto LABEL_621;
  }
  if (v765 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_1423;
  }
  if (v765 >= 0x17)
  {
    uint64_t v357 = (v765 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v765 | 7) != 0x17) {
      uint64_t v357 = v765 | 7;
    }
    uint64_t v358 = v357 + 1;
    BOOL v356 = (long long *)operator new(v357 + 1);
    unint64_t v805 = v358 | 0x8000000000000000;
    *(void *)&long long v804 = v356;
    *((void *)&v804 + sub_1CD7485C0(this + 1) = v765;
    goto LABEL_618;
  }
  HIBYTE(v805) = v765;
  BOOL v356 = &v804;
  if (v765) {
LABEL_618:
  }
    memmove(v356, v351, v765);
  *((unsigned char *)v356 + v765) = 0;
  LOBYTE(v786) = 0;
  if (SHIBYTE(v805) < 0)
  {
    BOOL v359 = (void *)v804;
    sub_1CB8BDF7C((uint64_t)&v787, (const void *)v804, *((unint64_t *)&v804 + 1));
    uint64_t v792 = 0;
    long long v791 = 0u;
    long long v790 = 0u;
    long long v789 = 0u;
    operator delete(v359);
  }
  else
  {
LABEL_621:
    long long v787 = v804;
    unint64_t v788 = v805;
    long long v789 = 0u;
    long long v790 = 0u;
    long long v791 = 0u;
    uint64_t v792 = 0;
  }
  uint64_t v803 = 0;
  *((void *)&v802 + sub_1CD7485C0(this + 1) = 0;
  *(void *)&long long v802 = (char *)&v802 + 8;
  uint64_t v360 = *(void *)v828;
  v744 = *(void **)&v828[8];
  if (*(void *)v828 == *(void *)&v828[8])
  {
    int v361 = -1;
    goto LABEL_624;
  }
  size_t v521 = 0;
  int v361 = -1;
  long long v522 = 0uLL;
  while (2)
  {
    size_t __nf = v521;
    if (*(_DWORD *)(v360 + 8) == v748) {
      int v361 = v521;
    }
    size_t v523 = *(void *)(v360 + 40);
    if (byte_1EBD0AB57 >= 0) {
      v524 = &qword_1EBD0AB40;
    }
    else {
      v524 = (uint64_t *)qword_1EBD0AB40;
    }
    uint64_t v525 = byte_1EBD0AB57 & 0x7F;
    if (byte_1EBD0AB57 < 0) {
      uint64_t v525 = unk_1EBD0AB48;
    }
    int v784 = v361;
    if (v523 == v525)
    {
      if (!v523 || (v526 = memcmp(*(const void **)(v360 + 32), v524, v523), long long v522 = 0uLL, !v526))
      {
        uint64_t v527 = 0;
        long long v869 = v522;
        long long v870 = v522;
        char v528 = 1;
        do
        {
          char v529 = v528;
          uint64_t v530 = *(void *)(v360 + 8 * v527 + 16);
          v533 = *(unsigned char **)(v530 + 24);
          uint64_t v531 = v530 + 24;
          v532 = v533;
          char v534 = *(unsigned char *)(v531 + 23);
          int v535 = v534;
          if (v534 >= 0) {
            v532 = (unsigned char *)v531;
          }
          uint64_t v536 = *(void *)(v531 + 8);
          uint64_t v537 = v534 & 0x7F;
          if (v535 >= 0) {
            uint64_t v536 = v537;
          }
          BOOL v538 = *v532 != 10 || v536 == 0;
          uint64_t v539 = !v538;
          if (!v538) {
            ++v532;
          }
          unint64_t v540 = v536 - v539;
          if (v540)
          {
            unint64_t v541 = 0;
            while (v532[v541] != 10)
            {
              if (v540 == ++v541) {
                goto LABEL_969;
              }
            }
          }
          else
          {
LABEL_969:
            unint64_t v541 = -1;
          }
          char v528 = 0;
          v542 = &v869 + v527;
          BOOL v543 = v540 > v541;
          if (v540 < v541) {
            unint64_t v541 = v540;
          }
          BOOL v544 = &v532[v541];
          uint64_t v545 = v543;
          if (v543) {
            ++v544;
          }
          *(void *)v542 = v544;
          *((void *)v542 + sub_1CD7485C0(this + 1) = v540 - v541 - v545;
          uint64_t v527 = 1;
        }
        while ((v529 & 1) != 0);
        v857.__r_.__value_.__r.__words[0] = (std::string::size_type)"<FONT COLOR=\"{0}\">%l</FONT><BR align=\"left\"/>";
        v857.__r_.__value_.__l.__size_ = 45;
        v857.__r_.__value_.__r.__words[2] = (std::string::size_type)&v861;
        uint64_t v858 = 1;
        v859 = &unk_1F263C030;
        v860 = &BeforeColour;
        v861 = &v859;
        *(void *)v819 = &v819[24];
        *(_OWORD *)&v819[8] = xmmword_1CFB2C4C0;
        *(_DWORD *)&v864[8] = 0;
        char v865 = 0;
        uint64_t v866 = 0;
        *(void *)v864 = &unk_1F2646FA8;
        v868 = (long long *)v819;
        int v867 = 0;
        memset(&v864[16], 0, 24);
        sub_1CD862C68((uint64_t)&v857, (llvm::raw_ostream *)v864);
        *(void *)v864 = &unk_1F2646B98;
        if (v867 == 1 && *(void *)&v864[16]) {
          MEMORY[0x1D25D9CB0](*(void *)&v864[16], 0x1000C8077774924);
        }
        v811.__r_.__value_.__r.__words[0] = (std::string::size_type)"<FONT COLOR=\"{0}\">%l</FONT><BR align=\"left\"/>";
        v811.__r_.__value_.__l.__size_ = 45;
        v811.__r_.__value_.__r.__words[2] = (std::string::size_type)&v815;
        uint64_t v812 = 1;
        v813 = &unk_1F263C030;
        v814 = &AfterColour;
        v815 = &v813;
        *(void *)v864 = &v864[24];
        *(_OWORD *)&v864[8] = xmmword_1CFB2C4C0;
        LODWORD(v857.__r_.__value_.__r.__words[1]) = 0;
        LOBYTE(v860) = 0;
        v861 = 0;
        v857.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1F2646FA8;
        v863 = v864;
        int v862 = 0;
        uint64_t v858 = 0;
        v859 = 0;
        v857.__r_.__value_.__r.__words[2] = 0;
        sub_1CD862C68((uint64_t)&v811, (llvm::raw_ostream *)&v857);
        v857.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1F2646B98;
        if (v862 == 1 && v857.__r_.__value_.__r.__words[2]) {
          MEMORY[0x1D25D9CB0](v857.__r_.__value_.__r.__words[2], 0x1000C8077774924);
        }
        __str.__r_.__value_.__r.__words[0] = (std::string::size_type)"<FONT COLOR=\"{0}\">%l</FONT><BR align=\"left\"/>";
        __str.__r_.__value_.__l.__size_ = 45;
        __str.__r_.__value_.__r.__words[2] = (std::string::size_type)&v810;
        uint64_t v808 = 1;
        v809[0] = &unk_1F263C030;
        v809[1] = &CommonColour;
        v810 = v809;
        v857.__r_.__value_.__r.__words[0] = (std::string::size_type)&v858;
        *(_OWORD *)&v857.__r_.__value_.__r.__words[1] = xmmword_1CFB2C4C0;
        LODWORD(v811.__r_.__value_.__r.__words[1]) = 0;
        LOBYTE(v814) = 0;
        v815 = 0;
        v811.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1F2646FA8;
        v817 = &v857;
        int v816 = 0;
        uint64_t v812 = 0;
        v813 = 0;
        v811.__r_.__value_.__r.__words[2] = 0;
        sub_1CD862C68((uint64_t)&__str, (llvm::raw_ostream *)&v811);
        v811.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1F2646B98;
        if (v816 == 1 && v811.__r_.__value_.__r.__words[2]) {
          MEMORY[0x1D25D9CB0](v811.__r_.__value_.__r.__words[2], 0x1000C8077774924);
        }
        uint64_t v546 = *(void *)(v360 + 16);
        char v547 = *(unsigned char *)(v546 + 23);
        if (v547 >= 0) {
          v548 = *(const void **)(v360 + 16);
        }
        else {
          v548 = *(const void **)v546;
        }
        if (!v548)
        {
          memset(&v811, 0, sizeof(v811));
          goto LABEL_1104;
        }
        int v571 = v547;
        std::string::size_type v572 = *(void *)(v546 + 8);
        std::string::size_type v573 = v547 & 0x7F;
        if (v571 >= 0) {
          std::string::size_type v574 = v573;
        }
        else {
          std::string::size_type v574 = v572;
        }
        if (v574 > 0x7FFFFFFFFFFFFFF7) {
          goto LABEL_1423;
        }
        if (v574 >= 0x17)
        {
          uint64_t v606 = (v574 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v574 | 7) != 0x17) {
            uint64_t v606 = v574 | 7;
          }
          uint64_t v607 = v606 + 1;
          uint64_t v575 = operator new(v606 + 1);
          v811.__r_.__value_.__r.__words[2] = v607 | 0x8000000000000000;
          v811.__r_.__value_.__r.__words[0] = (std::string::size_type)v575;
          v811.__r_.__value_.__l.__size_ = v574;
        }
        else
        {
          *((unsigned char *)&v811.__r_.__value_.__s + 23) = v574;
          uint64_t v575 = &v811;
          if (!v574) {
            goto LABEL_1103;
          }
        }
        memmove(v575, v548, v574);
LABEL_1103:
        *((unsigned char *)v575 + v574) = 0;
LABEL_1104:
        sub_1CCCCF208(&v871, (char *)v869, *((size_t *)&v869 + 1));
        if ((v871.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          long long v608 = &v871;
        }
        else {
          long long v608 = (std::string *)v871.__r_.__value_.__r.__words[0];
        }
        if ((v871.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v609 = *((unsigned char *)&v871.__r_.__value_.__s + 23) & 0x7F;
        }
        else {
          uint64_t v609 = v871.__r_.__value_.__l.__size_;
        }
        sub_1CCCCF208(&v806, (char *)v870, *((size_t *)&v870 + 1));
        if ((v806.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          int v611 = &v806;
        }
        else {
          int v611 = (std::string *)v806.__r_.__value_.__r.__words[0];
        }
        if ((v806.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v612 = *((unsigned char *)&v806.__r_.__value_.__s + 23) & 0x7F;
        }
        else {
          uint64_t v612 = v806.__r_.__value_.__l.__size_;
        }
        sub_1CCCD027C((uint64_t)&__dst, (uint64_t)v608, v609, (uint64_t)v611, v612, *(uint64_t *)v819, *(uint64_t *)&v819[8], v610, *(uint64_t *)v864, *(uint64_t *)&v864[8], (uint64_t)v857.__r_.__value_.__l.__data_, v857.__r_.__value_.__l.__size_);
        v613 = std::string::insert(&__dst, 0, ":\n<BR align=\"left\"/>");
        std::string::size_type v614 = v613->__r_.__value_.__r.__words[2];
        *(_OWORD *)&__str.__r_.__value_.__l.__data_ = *(_OWORD *)&v613->__r_.__value_.__l.__data_;
        __str.__r_.__value_.__r.__words[2] = v614;
        v613->__r_.__value_.__l.__size_ = 0;
        v613->__r_.__value_.__r.__words[2] = 0;
        v613->__r_.__value_.__r.__words[0] = 0;
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          v615 = &__str;
        }
        else {
          v615 = (std::string *)__str.__r_.__value_.__r.__words[0];
        }
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v616 = *((unsigned char *)&__str.__r_.__value_.__s + 23) & 0x7F;
        }
        else {
          std::string::size_type v616 = __str.__r_.__value_.__l.__size_;
        }
        std::string::append(&v811, (const std::string::value_type *)v615, v616);
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__str.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v806.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v806.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v871.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v871.__r_.__value_.__l.__data_);
        }
        llvm::Regex::Regex();
      }
    }
    uint64_t v549 = *(void *)(v360 + 16);
    v552 = *(char **)(v549 + 24);
    uint64_t v550 = v549 + 24;
    v551 = v552;
    char v553 = *(unsigned char *)(v550 + 23);
    if (v553 >= 0) {
      v554 = (char *)v550;
    }
    else {
      v554 = v551;
    }
    size_t v555 = *(void *)(v550 + 8);
    if (v553 >= 0) {
      size_t v556 = v553 & 0x7F;
    }
    else {
      size_t v556 = v555;
    }
    sub_1CCCCF208((std::string *)v819, v554, v556);
    uint64_t v557 = *(unsigned char **)v819;
    if (v819[23] >= 0) {
      uint64_t v557 = v819;
    }
    uint64_t v558 = v819[23] & 0x7F;
    if (v819[23] < 0) {
      uint64_t v558 = *(void *)&v819[8];
    }
    BOOL v559 = *v557 != 10 || v558 == 0;
    uint64_t v560 = !v559;
    if (v559) {
      int v561 = v557;
    }
    else {
      int v561 = v557 + 1;
    }
    size_t v562 = v558 - v560;
    if (v558 == v560)
    {
      size_t v563 = 0;
LABEL_1016:
      unint64_t v565 = -1;
    }
    else
    {
      unint64_t v564 = 0;
      while (v561[v564] != 58)
      {
        if (v562 == ++v564)
        {
          unint64_t v564 = -1;
          break;
        }
      }
      unint64_t v565 = 0;
      if (v562 >= v564) {
        size_t v563 = v564;
      }
      else {
        size_t v563 = v562;
      }
      while (v561[v565] != 10)
      {
        if (v562 == ++v565) {
          goto LABEL_1016;
        }
      }
    }
    if (v562 >= v565) {
      unint64_t v566 = v565;
    }
    else {
      unint64_t v566 = v562;
    }
    if (v562 <= v565) {
      int v567 = &v561[v566];
    }
    else {
      int v567 = &v561[v566 + 1];
    }
    int v568 = *(const void **)(v360 + 32);
    BOOL __s1d = v562 > v565;
    unint64_t v767 = v566;
    if (!v568)
    {
      memset(&__str, 0, sizeof(__str));
      goto LABEL_1041;
    }
    std::string::size_type v569 = *(void *)(v360 + 40);
    if (v569 > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_1423;
    }
    if (v569 >= 0x17)
    {
      uint64_t v576 = (v569 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v569 | 7) != 0x17) {
        uint64_t v576 = v569 | 7;
      }
      uint64_t v725 = v576 + 1;
      long long v577 = *(const void **)(v360 + 32);
      int v578 = (std::string *)operator new(v576 + 1);
      int v568 = v577;
      int v570 = v578;
      __str.__r_.__value_.__r.__words[2] = v725 | 0x8000000000000000;
      __str.__r_.__value_.__r.__words[0] = (std::string::size_type)v578;
      __str.__r_.__value_.__l.__size_ = v569;
    }
    else
    {
      *((unsigned char *)&__str.__r_.__value_.__s + 23) = *(void *)(v360 + 40);
      int v570 = &__str;
      if (!v569) {
        goto LABEL_1040;
      }
    }
    memmove(v570, v568, v569);
LABEL_1040:
    v570->__r_.__value_.__s.__data_[v569] = 0;
LABEL_1041:
    v579 = std::string::insert(&__str, 0, "<FONT COLOR=\"");
    std::string::size_type v580 = v579->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v811.__r_.__value_.__l.__data_ = *(_OWORD *)&v579->__r_.__value_.__l.__data_;
    v811.__r_.__value_.__r.__words[2] = v580;
    v579->__r_.__value_.__l.__size_ = 0;
    v579->__r_.__value_.__r.__words[2] = 0;
    v579->__r_.__value_.__r.__words[0] = 0;
    uint64_t v581 = std::string::append(&v811, "\">");
    std::string::size_type v582 = v581->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v857.__r_.__value_.__l.__data_ = *(_OWORD *)&v581->__r_.__value_.__l.__data_;
    v857.__r_.__value_.__r.__words[2] = v582;
    v581->__r_.__value_.__l.__size_ = 0;
    v581->__r_.__value_.__r.__words[2] = 0;
    v581->__r_.__value_.__r.__words[0] = 0;
    if (v563 > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_1423;
    }
    if (v563 >= 0x17)
    {
      uint64_t v584 = (v563 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v563 | 7) != 0x17) {
        uint64_t v584 = v563 | 7;
      }
      uint64_t v585 = v584 + 1;
      char v583 = (long long *)operator new(v584 + 1);
      *((void *)&v869 + sub_1CD7485C0(this + 1) = v563;
      *(void *)&long long v870 = v585 | 0x8000000000000000;
      *(void *)&long long v869 = v583;
      goto LABEL_1048;
    }
    BYTE7(v870) = v563;
    char v583 = &v869;
    if (v563) {
LABEL_1048:
    }
      memmove(v583, v561, v563);
    *((unsigned char *)v583 + v563) = 0;
    if ((SBYTE7(v870) & 0x80u) == 0) {
      uint64_t v586 = (const std::string::value_type *)&v869;
    }
    else {
      uint64_t v586 = (const std::string::value_type *)v869;
    }
    if ((SBYTE7(v870) & 0x80u) == 0) {
      std::string::size_type v587 = BYTE7(v870) & 0x7F;
    }
    else {
      std::string::size_type v587 = *((void *)&v869 + 1);
    }
    char v588 = std::string::append(&v857, v586, v587);
    std::string::size_type v589 = v588->__r_.__value_.__r.__words[2];
    *(_OWORD *)v864 = *(_OWORD *)&v588->__r_.__value_.__l.__data_;
    *(void *)&v864[16] = v589;
    v588->__r_.__value_.__l.__size_ = 0;
    v588->__r_.__value_.__r.__words[2] = 0;
    v588->__r_.__value_.__r.__words[0] = 0;
    char v590 = std::string::append((std::string *)v864, ":");
    std::string::size_type v591 = v590->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v801.__r_.__value_.__l.__data_ = *(_OWORD *)&v590->__r_.__value_.__l.__data_;
    v801.__r_.__value_.__r.__words[2] = v591;
    v590->__r_.__value_.__l.__size_ = 0;
    v590->__r_.__value_.__r.__words[2] = 0;
    v590->__r_.__value_.__r.__words[0] = 0;
    if ((v864[23] & 0x80000000) != 0) {
      operator delete(*(void **)v864);
    }
    if (SBYTE7(v870) < 0) {
      operator delete((void *)v869);
    }
    if (SHIBYTE(v857.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v857.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v811.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v811.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    unint64_t v592 = v562 - v767 - __s1d;
    if (v592)
    {
      while (1)
      {
        std::string::append(&v801, "<BR align=\"left\"/>");
        unint64_t v593 = 0;
        while (v567[v593] != 10)
        {
          if (v592 == ++v593)
          {
            unint64_t v593 = -1;
            break;
          }
        }
        size_t v594 = v592 >= v593 ? v593 : v592;
        if (v567) {
          break;
        }
        std::string::size_type v596 = 0;
        v597 = 0;
        char v598 = 0;
        memset(v864, 0, 24);
LABEL_1084:
        int v601 = v598;
        if (v598 >= 0) {
          int v602 = v864;
        }
        else {
          int v602 = v597;
        }
        std::string::size_type v603 = v598 & 0x7F;
        if (v601 >= 0) {
          std::string::size_type v604 = v603;
        }
        else {
          std::string::size_type v604 = v596;
        }
        std::string::append(&v801, v602, v604);
        if ((v864[23] & 0x80000000) != 0) {
          operator delete(*(void **)v864);
        }
        if (v592 >= v594 + 1) {
          unint64_t v605 = v594 + 1;
        }
        else {
          unint64_t v605 = v592;
        }
        v567 += v605;
        v592 -= v605;
        if (!v592) {
          goto LABEL_1096;
        }
      }
      if (v594 > 0x7FFFFFFFFFFFFFF7) {
        goto LABEL_1423;
      }
      if (v594 >= 0x17)
      {
        uint64_t v599 = (v594 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v594 | 7) != 0x17) {
          uint64_t v599 = v594 | 7;
        }
        uint64_t v600 = v599 + 1;
        v595 = operator new(v599 + 1);
        *(void *)&v864[16] = v600 | 0x8000000000000000;
        *(void *)v864 = v595;
        *(void *)&v864[8] = v594;
      }
      else
      {
        v864[23] = v594;
        v595 = v864;
        if (!v594) {
          goto LABEL_1083;
        }
      }
      memmove(v595, v567, v594);
LABEL_1083:
      v595[v594] = 0;
      char v598 = v864[23];
      std::string::size_type v596 = *(void *)&v864[8];
      v597 = *(const std::string::value_type **)v864;
      goto LABEL_1084;
    }
LABEL_1096:
    std::string::append(&v801, "<BR align=\"left\"/></FONT>");
    if ((v819[23] & 0x80000000) != 0) {
      operator delete(*(void **)v819);
    }
    *(_OWORD *)v819 = *(_OWORD *)(v360 + 32);
    uint64_t v617 = *((void *)&v789 + 1);
    if (*((void *)&v789 + 1) >= (unint64_t)v790)
    {
      uint64_t v619 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*((void *)&v789 + 1) - v789) >> 4);
      unint64_t v620 = v619 + 1;
      if ((unint64_t)(v619 + 1) > 0x1745D1745D1745DLL) {
        goto LABEL_1423;
      }
      if (0x5D1745D1745D1746 * ((uint64_t)(v790 - v789) >> 4) > v620) {
        unint64_t v620 = 0x5D1745D1745D1746 * ((uint64_t)(v790 - v789) >> 4);
      }
      if ((unint64_t)(0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v790 - v789) >> 4)) >= 0xBA2E8BA2E8BA2ELL) {
        unint64_t v621 = 0x1745D1745D1745DLL;
      }
      else {
        unint64_t v621 = v620;
      }
      if (v621)
      {
        if (v621 > 0x1745D1745D1745DLL) {
          goto LABEL_1434;
        }
        int v622 = (char *)operator new(176 * v621);
      }
      else
      {
        int v622 = 0;
      }
      uint64_t v623 = (uint64_t)&v622[176 * v619];
      int v624 = &v622[176 * v621];
      sub_1CCCD0098(v623, (uint64_t)&v801, v819);
      uint64_t v618 = v623 + 176;
      v625 = (char *)*((void *)&v789 + 1);
      long long v626 = (char *)v789;
      if (*((void *)&v789 + 1) == (void)v789)
      {
        *(void *)&long long v789 = v623;
        *((void *)&v789 + sub_1CD7485C0(this + 1) = v623 + 176;
        *(void *)&long long v790 = v624;
      }
      else
      {
        uint64_t v627 = 0;
        long long v628 = 0uLL;
        do
        {
          *(_OWORD *)(v623 + v627 - 176) = *(_OWORD *)&v625[v627 - 176];
          v629 = (_OWORD *)(v623 + v627 - 160);
          uint64_t v630 = (const void **)&v625[v627 - 160];
          if (v625[v627 - 137] < 0)
          {
            sub_1CB8BDF7C((uint64_t)v629, *v630, *(void *)&v625[v627 - 152]);
            long long v628 = 0uLL;
          }
          else
          {
            long long v631 = *(_OWORD *)v630;
            *(void *)(v623 + v627 - 144) = *(void *)&v625[v627 - 144];
            _OWORD *v629 = v631;
          }
          uint64_t v632 = v623 + v627;
          int v633 = &v625[v627];
          *(void *)(v632 - 120) = 0;
          *(_OWORD *)(v632 - 136) = v628;
          *(_OWORD *)(v632 - 136) = *(_OWORD *)&v625[v627 - 136];
          *(void *)(v632 - 120) = *(void *)&v625[v627 - 120];
          *((void *)v633 - 15) = 0;
          *(_OWORD *)(v633 - 136) = v628;
          *(void *)(v632 - 96) = 0;
          *(_OWORD *)(v632 - 112) = v628;
          *(_OWORD *)(v632 - 112) = *(_OWORD *)&v625[v627 - 112];
          *(void *)(v632 - 96) = *(void *)&v625[v627 - 96];
          uint64_t v634 = *(void *)&v625[v627 - 88];
          *((_OWORD *)v633 - 7) = v628;
          *((_OWORD *)v633 - 6) = v628;
          *(void *)(v632 - 88) = v634;
          *(void *)(v632 - 80) = *(void *)&v625[v627 - 80];
          *((void *)v633 - 10) = 0;
          uint64_t v635 = *(void *)&v625[v627 - 72];
          *(void *)(v623 + v627 - 72) = v635;
          uint64_t v636 = *(void *)&v625[v627 - 64];
          *(void *)(v632 - 64) = v636;
          *(_DWORD *)(v632 - 56) = *(_DWORD *)&v625[v627 - 56];
          if (v636)
          {
            unint64_t v637 = *(void *)(v635 + 8);
            unint64_t v638 = *(void *)(v632 - 80);
            if ((v638 & (v638 - 1)) != 0)
            {
              if (v637 >= v638) {
                v637 %= v638;
              }
            }
            else
            {
              v637 &= v638 - 1;
            }
            *(void *)(v634 + 8 * v637) = v623 + v627 - 72;
            *(void *)&v625[v627 - 72] = 0;
            *(void *)&v625[v627 - 64] = 0;
          }
          uint64_t v639 = *((void *)v633 - 6);
          *((void *)v633 - 6) = 0;
          *(void *)(v632 - 48) = v639;
          *(void *)(v632 - 40) = *((void *)v633 - 5);
          *((void *)v633 - 5) = 0;
          uint64_t v642 = *((void *)v633 - 4);
          v640 = v633 - 32;
          uint64_t v641 = v642;
          *(void *)(v632 - 32) = v642;
          uint64_t v643 = v632 - 32;
          uint64_t v644 = *((void *)v640 + 1);
          *(void *)(v632 - 24) = v644;
          *(_DWORD *)(v632 - 16) = *((_DWORD *)v640 + 4);
          if (v644)
          {
            unint64_t v645 = *(void *)(v641 + 8);
            unint64_t v646 = *(void *)(v632 - 40);
            if ((v646 & (v646 - 1)) != 0)
            {
              if (v645 >= v646) {
                v645 %= v646;
              }
            }
            else
            {
              v645 &= v646 - 1;
            }
            *(void *)(v639 + 8 * v645) = v643;
            *(void *)v640 = 0;
            *((void *)v640 + sub_1CD7485C0(this + 1) = 0;
          }
          *(unsigned char *)(v623 + v627 - 8) = v625[v627 - 8];
          v627 -= 176;
        }
        while (&v625[v627] != v626);
        uint64_t v647 = *((void *)&v789 + 1);
        v625 = (char *)v789;
        *(void *)&long long v789 = v623 + v627;
        *((void *)&v789 + sub_1CD7485C0(this + 1) = v623 + 176;
        *(void *)&long long v790 = v624;
        while ((char *)v647 != v625)
        {
          v647 -= 176;
          sub_1CCCD0188(v647);
        }
      }
      if (v625) {
        operator delete(v625);
      }
    }
    else
    {
      sub_1CCCD0098(*((uint64_t *)&v789 + 1), (uint64_t)&v801, v819);
      uint64_t v618 = v617 + 176;
    }
    *((void *)&v789 + sub_1CD7485C0(this + 1) = v618;
    if (SHIBYTE(v801.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v801.__r_.__value_.__l.__data_);
    }
    sub_1CD7471EC((uint64_t *)&v802, *(_DWORD *)(v360 + 8), *(unsigned int *)(v360 + 8) | (__nf << 32));
    v360 += 120;
    size_t v521 = (__nf + 1);
    int v361 = v784;
    long long v522 = 0uLL;
    if ((void *)v360 != v744) {
      continue;
    }
    break;
  }
LABEL_624:
  unsigned int v362 = v361;
  LOBYTE(v786) = 1;
  uint64_t v364 = *((void *)&v789 + 1);
  unint64_t prime = v789;
  if ((void)v789 != *((void *)&v789 + 1))
  {
    uint64_t v365 = (unint64_t *)v791;
    do
    {
      if ((unint64_t)v365 >= *((void *)&v791 + 1))
      {
        uint64_t v367 = (unint64_t *)*((void *)&v790 + 1);
        uint64_t v368 = ((uint64_t)v365 - *((void *)&v790 + 1)) >> 3;
        unint64_t v369 = v368 + 1;
        if ((unint64_t)(v368 + 1) >> 61) {
          goto LABEL_1423;
        }
        uint64_t v370 = *((void *)&v791 + 1) - *((void *)&v790 + 1);
        if ((uint64_t)(*((void *)&v791 + 1) - *((void *)&v790 + 1)) >> 2 > v369) {
          unint64_t v369 = v370 >> 2;
        }
        if ((unint64_t)v370 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v371 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v371 = v369;
        }
        if (v371)
        {
          if (v371 >> 61) {
            goto LABEL_1434;
          }
          v372 = (char *)operator new(8 * v371);
        }
        else
        {
          v372 = 0;
        }
        BOOL v373 = (unint64_t *)&v372[8 * v368];
        *BOOL v373 = prime;
        v366 = v373 + 1;
        if (v365 != v367)
        {
          do
          {
            unint64_t v374 = *--v365;
            *--BOOL v373 = v374;
          }
          while (v365 != v367);
          uint64_t v365 = v367;
        }
        *((void *)&v790 + sub_1CD7485C0(this + 1) = v373;
        *(void *)&long long v791 = v366;
        *((void *)&v791 + sub_1CD7485C0(this + 1) = &v372[8 * v371];
        if (v365) {
          operator delete(v365);
        }
      }
      else
      {
        *uint64_t v365 = prime;
        v366 = v365 + 1;
      }
      *(void *)&long long v791 = v366;
      prime += 176;
      uint64_t v365 = v366;
    }
    while (prime != v364);
  }
  uint64_t v792 = *(void *)(*((void *)&v790 + 1) + 8 * v362);
  v375 = (_OWORD *)v802;
  if ((long long *)v802 != (long long *)((char *)&v802 + 8))
  {
    while (2)
    {
      unsigned int v376 = *((_DWORD *)v375 + 7);
      v723 = v375;
      unsigned int v735 = *((_DWORD *)v375 + 8);
      uint64_t v377 = *(void *)v828 + 120 * v376;
      uint64_t v733 = v789;
      BOOL v378 = *(unsigned int **)(v377 + 96);
      v736 = *(unsigned int **)(v377 + 104);
      v737 = (uint64_t **)v377;
      if (v378 != v736)
      {
        uint64_t v379 = *(void *)v828 + 120 * v376;
        v729 = (unsigned int *)(v379 + 8);
        uint64_t v380 = v789 + 176 * v735;
        v739 = (size_t *)(v380 + 56);
        v726 = (void **)(v380 + 88);
        v727 = (uint64_t *)(v380 + 40);
        v742 = (unint64_t *)(v380 + 96);
        __nd = (unint64_t *)(v380 + 112);
        v782 = (uint64_t *)(v380 + 48);
        v731 = (float *)(v380 + 120);
        v724 = (void *)(v380 + 104);
        v728 = (uint64_t **)(v379 + 56);
        do
        {
          unsigned int v381 = *v378;
          *(_OWORD *)v766 = *(_OWORD *)(sub_1CD7472A4(*v728, *v378) + 3);
          v382 = *v737;
          uint64_t v383 = **v737;
          uint64_t v384 = *(void *)(v383 + 120 * *v729 + 16);
          char v385 = *(unsigned char *)(v384 + 23);
          if (v385 >= 0) {
            uint64_t v386 = *(const void **)(v383 + 120 * *v729 + 16);
          }
          else {
            uint64_t v386 = *(const void **)v384;
          }
          if (!v386)
          {
            memset(&v857, 0, sizeof(v857));
            goto LABEL_664;
          }
          int v387 = v385;
          std::string::size_type v388 = *(void *)(v384 + 8);
          std::string::size_type v389 = v385 & 0x7F;
          if (v387 >= 0) {
            std::string::size_type v390 = v389;
          }
          else {
            std::string::size_type v390 = v388;
          }
          if (v390 > 0x7FFFFFFFFFFFFFF7) {
            goto LABEL_1423;
          }
          if (v390 >= 0x17)
          {
            uint64_t v392 = (v390 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v390 | 7) != 0x17) {
              uint64_t v392 = v390 | 7;
            }
            uint64_t v393 = v392 + 1;
            v391 = operator new(v392 + 1);
            v857.__r_.__value_.__r.__words[2] = v393 | 0x8000000000000000;
            v857.__r_.__value_.__r.__words[0] = (std::string::size_type)v391;
            v857.__r_.__value_.__l.__size_ = v390;
          }
          else
          {
            *((unsigned char *)&v857.__r_.__value_.__s + 23) = v390;
            v391 = &v857;
            if (!v390) {
              goto LABEL_663;
            }
          }
          memmove(v391, v386, v390);
LABEL_663:
          *((unsigned char *)v391 + v390) = 0;
LABEL_664:
          v394 = std::string::append(&v857, " ");
          std::string::size_type v395 = v394->__r_.__value_.__r.__words[2];
          *(_OWORD *)v864 = *(_OWORD *)&v394->__r_.__value_.__l.__data_;
          *(void *)&v864[16] = v395;
          v394->__r_.__value_.__l.__size_ = 0;
          v394->__r_.__value_.__r.__words[2] = 0;
          v394->__r_.__value_.__r.__words[0] = 0;
          uint64_t v396 = *(void *)(*v382 + 120 * v381 + 16);
          char v397 = *(unsigned char *)(v396 + 23);
          if (v397 >= 0) {
            v398 = *(const void **)(*v382 + 120 * v381 + 16);
          }
          else {
            v398 = *(const void **)v396;
          }
          if (!v398)
          {
            std::string::size_type v404 = 0;
            std::string::size_type v405 = 0;
            char v406 = 0;
            memset(&v811, 0, sizeof(v811));
            goto LABEL_681;
          }
          int v399 = v397;
          std::string::size_type v400 = *(void *)(v396 + 8);
          std::string::size_type v401 = v397 & 0x7F;
          if (v399 >= 0) {
            std::string::size_type v402 = v401;
          }
          else {
            std::string::size_type v402 = v400;
          }
          if (v402 > 0x7FFFFFFFFFFFFFF7) {
            goto LABEL_1423;
          }
          if (v402 >= 0x17)
          {
            uint64_t v407 = (v402 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v402 | 7) != 0x17) {
              uint64_t v407 = v402 | 7;
            }
            uint64_t v408 = v407 + 1;
            int v403 = operator new(v407 + 1);
            v811.__r_.__value_.__r.__words[2] = v408 | 0x8000000000000000;
            v811.__r_.__value_.__r.__words[0] = (std::string::size_type)v403;
            v811.__r_.__value_.__l.__size_ = v402;
          }
          else
          {
            *((unsigned char *)&v811.__r_.__value_.__s + 23) = v402;
            int v403 = &v811;
            if (!v402) {
              goto LABEL_680;
            }
          }
          memmove(v403, v398, v402);
LABEL_680:
          *((unsigned char *)v403 + v402) = 0;
          char v406 = HIBYTE(v811.__r_.__value_.__r.__words[2]);
          std::string::size_type v404 = v811.__r_.__value_.__l.__size_;
          std::string::size_type v405 = v811.__r_.__value_.__r.__words[0];
LABEL_681:
          BOOL v409 = v406 < 0;
          if (v406 >= 0) {
            v410 = &v811;
          }
          else {
            v410 = (std::string *)v405;
          }
          std::string::size_type v411 = v406 & 0x7F;
          if (v409) {
            std::string::size_type v412 = v404;
          }
          else {
            std::string::size_type v412 = v411;
          }
          BOOL v413 = std::string::append((std::string *)v864, (const std::string::value_type *)v410, v412);
          *(std::string *)v819 = *v413;
          v413->__r_.__value_.__r.__words[0] = 0;
          v413->__r_.__value_.__l.__size_ = 0;
          v413->__r_.__value_.__r.__words[2] = 0;
          if (SHIBYTE(v811.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v811.__r_.__value_.__l.__data_);
          }
          if ((v864[23] & 0x80000000) != 0) {
            operator delete(*(void **)v864);
          }
          if (SHIBYTE(v857.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v857.__r_.__value_.__l.__data_);
          }
          int v414 = v819[23];
          if (v819[23] >= 0) {
            uint64_t v415 = v819;
          }
          else {
            uint64_t v415 = *(unsigned __int8 **)v819;
          }
          if (v819[23] >= 0) {
            size_t v416 = v819[23] & 0x7F;
          }
          else {
            size_t v416 = *(void *)&v819[8];
          }
          uint64_t v417 = *((unsigned int *)v382 + 22);
          size_t v749 = (size_t)v378;
          uint64_t v753 = v383;
          unsigned int __s1c = v381;
          v730 = *(void **)v819;
          if (v417)
          {
            int v745 = v819[23];
            int v418 = 0;
            if (v416)
            {
              size_t v419 = v416;
              v420 = v415;
              do
              {
                int v421 = *v420++;
                int v418 = 33 * v418 + v421;
                --v419;
              }
              while (v419);
            }
            uint64_t v422 = v382[10];
            int v423 = 1;
            int v424 = v418;
            while (1)
            {
              uint64_t v425 = v424 & (v417 - 1);
              v426 = *(void **)(v422 + 8 * v425);
              if (v426 != (void *)-8)
              {
                if (!v426) {
                  goto LABEL_713;
                }
                if (*(_DWORD *)(v422 + 8 * v417 + 8 + 4 * v425) == v418
                  && v416 == *v426
                  && (!v416 || !memcmp(v415, (char *)v426 + *((unsigned int *)v382 + 25), v416)))
                {
                  break;
                }
              }
              int v424 = v423 + v425;
              ++v423;
            }
            if (v425 != -1) {
              uint64_t v417 = (int)v425;
            }
LABEL_713:
            int v414 = v745;
          }
          else
          {
            uint64_t v417 = 0;
            uint64_t v422 = v382[10];
          }
          uint64_t v427 = *(void *)(v422 + 8 * v417);
          uint64_t v430 = *(void *)(v427 + 8);
          uint64_t v428 = v427 + 8;
          uint64_t v429 = v430;
          char v431 = *(unsigned char *)(v428 + 23);
          size_t v432 = *(void *)(v428 + 8);
          if (v414 < 0) {
            operator delete(v730);
          }
          if (v431 < 0) {
            uint64_t v428 = v429;
          }
          unsigned int v433 = *(_DWORD *)(v753 + 120 * __s1c + 8);
          uint64_t v434 = v789;
          *(_OWORD *)v864 = *(_OWORD *)v766;
          if (!v428)
          {
            memset(v819, 0, 24);
            goto LABEL_731;
          }
          if (v431 >= 0) {
            size_t v432 = v431 & 0x7F;
          }
          if (v432 > 0x7FFFFFFFFFFFFFF7) {
            goto LABEL_1423;
          }
          if (v432 >= 0x17)
          {
            uint64_t v436 = (v432 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v432 | 7) != 0x17) {
              uint64_t v436 = v432 | 7;
            }
            size_t v416 = v436 + 1;
            v435 = operator new(v436 + 1);
            *(void *)&v819[16] = v416 | 0x8000000000000000;
            *(void *)v819 = v435;
            *(void *)&v819[8] = v432;
          }
          else
          {
            v819[23] = v432;
            v435 = v819;
            if (!v432) {
              goto LABEL_730;
            }
          }
          memmove(v435, (const void *)v428, v432);
LABEL_730:
          v435[v432] = 0;
LABEL_731:
          unint64_t prime = v434 + 176 * v433;
          uint64_t v437 = *v782;
          if (*v782 < *v739)
          {
            sub_1CCCD0D28(*v782, (uint64_t)v819, v434 + 176 * v433, v864);
            v438 = (void *)(v437 + 48);
            v439 = (void **)v782;
            v440 = v726;
            goto LABEL_752;
          }
          unint64_t v441 = 0xAAAAAAAAAAAAAAABLL * ((v437 - *v727) >> 4);
          unint64_t v442 = v441 + 1;
          if (v441 + 1 > 0x555555555555555) {
            goto LABEL_1423;
          }
          if (0x5555555555555556 * ((uint64_t)(*v739 - *v727) >> 4) > v442) {
            unint64_t v442 = 0x5555555555555556 * ((uint64_t)(*v739 - *v727) >> 4);
          }
          if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*v739 - *v727) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
            unint64_t v443 = 0x555555555555555;
          }
          else {
            unint64_t v443 = v442;
          }
          if (v443)
          {
            v439 = (void **)v782;
            if (v443 > 0x555555555555555) {
              goto LABEL_1434;
            }
            v444 = operator new(48 * v443);
          }
          else
          {
            v444 = 0;
            v439 = (void **)v782;
          }
          uint64_t v445 = (uint64_t)v444 + 48 * v441;
          size_t v416 = (size_t)v444 + 48 * v443;
          sub_1CCCD0D28(v445, (uint64_t)v819, prime, v864);
          v438 = (void *)(v445 + 48);
          v446 = (void **)*v439;
          v447 = (void **)*v727;
          if (*v439 == (void *)*v727)
          {
            uint64_t *v727 = v445;
            *v439 = v438;
            size_t *v739 = v416;
LABEL_797:
            v440 = v726;
            if (v446) {
              goto LABEL_751;
            }
            goto LABEL_752;
          }
          do
          {
            *(_OWORD *)(v445 - 48) = *((_OWORD *)v446 - 3);
            long long v448 = *((_OWORD *)v446 - 2);
            *(void *)(v445 - 16) = *(v446 - 2);
            *(_OWORD *)(v445 - 32) = v448;
            *(v446 - 3) = 0;
            *(v446 - 2) = 0;
            *(v446 - 4) = 0;
            *(void *)(v445 - 8) = *(v446 - 1);
            v445 -= 48;
            v446 -= 6;
          }
          while (v446 != v447);
          v446 = (void **)*v727;
          v449 = (void **)*v439;
          uint64_t *v727 = v445;
          *v439 = v438;
          size_t *v739 = v416;
          if (v449 == v446) {
            goto LABEL_797;
          }
          v440 = v726;
          do
          {
            if (*((char *)v449 - 9) < 0) {
              operator delete(*(v449 - 4));
            }
            v449 -= 6;
          }
          while (v449 != v446);
          if (v446) {
LABEL_751:
          }
            operator delete(v446);
LABEL_752:
          *v439 = v438;
          if ((v819[23] & 0x80000000) != 0) {
            operator delete(*(void **)v819);
          }
          unint64_t v450 = 0x9DDFEA08EB382D69 * (((((prime >> 3) & 0x3FFFFFF) << 6) | 8) ^ HIDWORD(prime));
          unint64_t v451 = 0x9DDFEA08EB382D69 * (HIDWORD(prime) ^ (v450 >> 47) ^ v450);
          unint64_t v452 = 0x9DDFEA08EB382D69 * (v451 ^ (v451 >> 47));
          unint64_t v453 = *v742;
          if (*v742)
          {
            uint8x8_t v454 = (uint8x8_t)vcnt_s8((int8x8_t)v453);
            v454.i16[0] = vaddlv_u8(v454);
            if (v454.u32[0] > 1uLL)
            {
              size_t v416 = 0x9DDFEA08EB382D69 * (v451 ^ (v451 >> 47));
              if (v452 >= v453) {
                size_t v416 = v452 % v453;
              }
            }
            else
            {
              size_t v416 = (v453 - 1) & v452;
            }
            int v455 = (void *)*((void *)*v440 + v416);
            if (v455)
            {
              for (nuint64_t n = (void *)*v455; nn; nuint64_t n = (void *)*nn)
              {
                unint64_t v457 = nn[1];
                if (v457 == v452)
                {
                  if (nn[2] == prime) {
                    goto LABEL_829;
                  }
                }
                else
                {
                  if (v454.u32[0] > 1uLL)
                  {
                    if (v457 >= v453) {
                      v457 %= v453;
                    }
                  }
                  else
                  {
                    v457 &= v453 - 1;
                  }
                  if (v457 != v416) {
                    break;
                  }
                }
              }
            }
          }
          int v458 = operator new(0x18uLL);
          *int v458 = 0;
          v458[1] = v452;
          v458[2] = prime;
          float v459 = (float)(*__nd + 1);
          float v460 = *v731;
          if (!v453 || (float)(v460 * (float)v453) < v459)
          {
            BOOL v461 = (v453 & (v453 - 1)) != 0;
            if (v453 < 3) {
              BOOL v461 = 1;
            }
            unint64_t v462 = v461 | (2 * v453);
            unint64_t v463 = vcvtps_u32_f32(v459 / v460);
            if (v462 <= v463) {
              unint64_t prime = v463;
            }
            else {
              unint64_t prime = v462;
            }
            if (prime == 1)
            {
              unint64_t prime = 2;
            }
            else if ((prime & (prime - 1)) != 0)
            {
              unint64_t prime = std::__next_prime(prime);
            }
            unint64_t v453 = *v742;
            if (prime <= *v742)
            {
              if (prime < *v742)
              {
                unint64_t v470 = vcvtps_u32_f32((float)*__nd / *v731);
                if (v453 < 3
                  || (uint8x8_t v471 = (uint8x8_t)vcnt_s8((int8x8_t)v453), v471.i16[0] = vaddlv_u8(v471), v471.u32[0] > 1uLL))
                {
                  unint64_t v470 = std::__next_prime(v470);
                }
                else
                {
                  uint64_t v472 = 1 << -(char)__clz(v470 - 1);
                  if (v470 >= 2) {
                    unint64_t v470 = v472;
                  }
                }
                if (prime <= v470) {
                  unint64_t prime = v470;
                }
                if (prime >= v453)
                {
                  unint64_t v453 = *v742;
                }
                else
                {
                  if (prime) {
                    goto LABEL_782;
                  }
                  uint64_t v477 = *v440;
                  *v440 = 0;
                  if (v477) {
                    operator delete(v477);
                  }
                  unint64_t v453 = 0;
                  v440[1] = 0;
                }
              }
            }
            else
            {
LABEL_782:
              if (prime >> 61) {
                goto LABEL_1434;
              }
              int v464 = operator new(8 * prime);
              int v465 = *v440;
              *v440 = v464;
              if (v465) {
                operator delete(v465);
              }
              uint64_t v466 = 0;
              v440[1] = (void *)prime;
              do
                *((void *)*v440 + v466++) = 0;
              while (prime != v466);
              int v467 = (void *)*v724;
              if (*v724)
              {
                unint64_t v468 = v467[1];
                uint8x8_t v469 = (uint8x8_t)vcnt_s8((int8x8_t)prime);
                v469.i16[0] = vaddlv_u8(v469);
                if (v469.u32[0] > 1uLL)
                {
                  if (v468 >= prime) {
                    v468 %= prime;
                  }
                }
                else
                {
                  v468 &= prime - 1;
                }
                *((void *)*v440 + v468) = v724;
                int v473 = (void *)*v467;
                if (*v467)
                {
                  do
                  {
                    unint64_t v474 = v473[1];
                    if (v469.u32[0] > 1uLL)
                    {
                      if (v474 >= prime) {
                        v474 %= prime;
                      }
                    }
                    else
                    {
                      v474 &= prime - 1;
                    }
                    if (v474 != v468)
                    {
                      if (!*((void *)*v440 + v474))
                      {
                        *((void *)*v440 + v474) = v467;
                        goto LABEL_810;
                      }
                      *int v467 = *v473;
                      *int v473 = **((void **)*v440 + v474);
                      **((void **)*v440 + v474) = v473;
                      int v473 = v467;
                    }
                    unint64_t v474 = v468;
LABEL_810:
                    int v467 = v473;
                    int v473 = (void *)*v473;
                    unint64_t v468 = v474;
                  }
                  while (v473);
                }
              }
              unint64_t v453 = prime;
            }
            if ((v453 & (v453 - 1)) != 0)
            {
              if (v452 >= v453) {
                size_t v416 = v452 % v453;
              }
              else {
                size_t v416 = v452;
              }
            }
            else
            {
              size_t v416 = (v453 - 1) & v452;
            }
          }
          BOOL v475 = (void *)*((void *)*v440 + v416);
          if (v475)
          {
            *int v458 = *v475;
          }
          else
          {
            *int v458 = *v724;
            void *v724 = v458;
            *((void *)*v440 + v416) = v724;
            if (!*v458) {
              goto LABEL_828;
            }
            unint64_t v476 = *(void *)(*v458 + 8);
            if ((v453 & (v453 - 1)) != 0)
            {
              if (v476 >= v453) {
                v476 %= v453;
              }
            }
            else
            {
              v476 &= v453 - 1;
            }
            BOOL v475 = (char *)*v440 + 8 * v476;
          }
          *BOOL v475 = v458;
LABEL_828:
          ++*__nd;
LABEL_829:
          BOOL v378 = (unsigned int *)(v749 + 4);
        }
        while ((unsigned int *)(v749 + 4) != v736);
      }
      uint64_t v478 = v733 + 176 * v735;
      *(unsigned char *)(v478 + 168) = 1;
      uint64_t v479 = *(void *)(v478 + 40);
      size_t __ne = *(void *)(v478 + 48);
      if (v479 == __ne)
      {
LABEL_926:
        long long v515 = v723;
        v516 = (void *)*((void *)v723 + 1);
        if (v516)
        {
          do
          {
            uint64_t v517 = v516;
            v516 = (void *)*v516;
          }
          while (v516);
        }
        else
        {
          do
          {
            uint64_t v517 = (_OWORD *)*((void *)v515 + 2);
            BOOL v36 = *(void *)v517 == (void)v515;
            long long v515 = v517;
          }
          while (!v36);
        }
        v375 = v517;
        if (v517 == (long long *)((char *)&v802 + 8)) {
          goto LABEL_932;
        }
        continue;
      }
      break;
    }
    uint64_t v480 = v733 + 176 * v735;
    BOOL v481 = (void **)(v480 + 128);
    long long v482 = (unint64_t *)(v480 + 136);
    long long v483 = (unint64_t *)(v480 + 152);
    v783 = (float *)(v480 + 160);
    v484 = (void *)(v480 + 144);
    while (2)
    {
      unint64_t v485 = *(void *)(v479 + 40);
      unint64_t v486 = 0x9DDFEA08EB382D69 * (((8 * v485) + 8) ^ HIDWORD(v485));
      unint64_t v487 = 0x9DDFEA08EB382D69 * (HIDWORD(v485) ^ (v486 >> 47) ^ v486);
      unint64_t v488 = 0x9DDFEA08EB382D69 * (v487 ^ (v487 >> 47));
      unint64_t v489 = *v482;
      if (*v482)
      {
        uint8x8_t v490 = (uint8x8_t)vcnt_s8((int8x8_t)v489);
        v490.i16[0] = vaddlv_u8(v490);
        if (v490.u32[0] > 1uLL)
        {
          unint64_t prime = 0x9DDFEA08EB382D69 * (v487 ^ (v487 >> 47));
          if (v488 >= v489) {
            unint64_t prime = v488 % v489;
          }
        }
        else
        {
          unint64_t prime = v488 & (v489 - 1);
        }
        long long v491 = (void *)*((void *)*v481 + prime);
        if (v491)
        {
          for (i1 = (void *)*v491; i1; i1 = (void *)*i1)
          {
            unint64_t v493 = i1[1];
            if (v493 == v488)
            {
              if (i1[2] == v485) {
                goto LABEL_915;
              }
            }
            else
            {
              if (v490.u32[0] > 1uLL)
              {
                if (v493 >= v489) {
                  v493 %= v489;
                }
              }
              else
              {
                v493 &= v489 - 1;
              }
              if (v493 != prime) {
                break;
              }
            }
          }
        }
      }
      long long v494 = operator new(0x20uLL);
      *long long v494 = 0;
      v494[1] = v488;
      v494[2] = v485;
      v494[3] = v479;
      float v495 = (float)(*v483 + 1);
      float v496 = *v783;
      if (!v489 || (float)(v496 * (float)v489) < v495)
      {
        BOOL v497 = (v489 & (v489 - 1)) != 0;
        if (v489 < 3) {
          BOOL v497 = 1;
        }
        unint64_t v498 = v497 | (2 * v489);
        unint64_t v499 = vcvtps_u32_f32(v495 / v496);
        if (v498 <= v499) {
          int8x8_t v500 = (int8x8_t)v499;
        }
        else {
          int8x8_t v500 = (int8x8_t)v498;
        }
        if (*(void *)&v500 == 1)
        {
          int8x8_t v500 = (int8x8_t)2;
        }
        else if ((*(void *)&v500 & (*(void *)&v500 - 1)) != 0)
        {
          int8x8_t v500 = (int8x8_t)std::__next_prime(*(void *)&v500);
        }
        unint64_t v489 = *v482;
        if (*(void *)&v500 <= *v482)
        {
          if (*(void *)&v500 < *v482)
          {
            unint64_t v507 = vcvtps_u32_f32((float)*v483 / *v783);
            if (v489 < 3
              || (uint8x8_t v508 = (uint8x8_t)vcnt_s8((int8x8_t)v489), v508.i16[0] = vaddlv_u8(v508), v508.u32[0] > 1uLL))
            {
              unint64_t v507 = std::__next_prime(v507);
            }
            else
            {
              uint64_t v509 = 1 << -(char)__clz(v507 - 1);
              if (v507 >= 2) {
                unint64_t v507 = v509;
              }
            }
            if (*(void *)&v500 <= v507) {
              int8x8_t v500 = (int8x8_t)v507;
            }
            if (*(void *)&v500 >= v489)
            {
              unint64_t v489 = *v482;
            }
            else
            {
              if (v500) {
                goto LABEL_871;
              }
              int v514 = *v481;
              *BOOL v481 = 0;
              if (v514) {
                operator delete(v514);
              }
              unint64_t v489 = 0;
              v481[1] = 0;
            }
          }
        }
        else
        {
LABEL_871:
          if (*(void *)&v500 >> 61) {
            goto LABEL_1434;
          }
          v501 = operator new(8 * *(void *)&v500);
          int v502 = *v481;
          *BOOL v481 = v501;
          if (v502) {
            operator delete(v502);
          }
          uint64_t v503 = 0;
          v481[1] = (void *)v500;
          do
            *((void *)*v481 + v503++) = 0;
          while (*(void *)&v500 != v503);
          int v504 = (void *)*v484;
          if (*v484)
          {
            unint64_t v505 = v504[1];
            uint8x8_t v506 = (uint8x8_t)vcnt_s8(v500);
            v506.i16[0] = vaddlv_u8(v506);
            if (v506.u32[0] > 1uLL)
            {
              if (v505 >= *(void *)&v500) {
                v505 %= *(void *)&v500;
              }
            }
            else
            {
              v505 &= *(void *)&v500 - 1;
            }
            *((void *)*v481 + v505) = v484;
            v510 = (void *)*v504;
            if (*v504)
            {
              while (2)
              {
                unint64_t v511 = v510[1];
                if (v506.u32[0] > 1uLL)
                {
                  if (v511 >= *(void *)&v500) {
                    v511 %= *(void *)&v500;
                  }
                }
                else
                {
                  v511 &= *(void *)&v500 - 1;
                }
                if (v511 == v505)
                {
LABEL_895:
                  unint64_t v511 = v505;
                }
                else
                {
                  if (*((void *)*v481 + v511))
                  {
                    *int v504 = *v510;
                    void *v510 = **((void **)*v481 + v511);
                    **((void **)*v481 + v51sub_1CD7485C0(this + 1) = v510;
                    v510 = v504;
                    goto LABEL_895;
                  }
                  *((void *)*v481 + v51sub_1CD7485C0(this + 1) = v504;
                }
                int v504 = v510;
                v510 = (void *)*v510;
                unint64_t v505 = v511;
                if (!v510) {
                  break;
                }
                continue;
              }
            }
          }
          unint64_t v489 = (unint64_t)v500;
        }
        if ((v489 & (v489 - 1)) != 0)
        {
          if (v488 >= v489) {
            unint64_t prime = v488 % v489;
          }
          else {
            unint64_t prime = v488;
          }
        }
        else
        {
          unint64_t prime = (v489 - 1) & v488;
        }
      }
      BOOL v512 = (void *)*((void *)*v481 + prime);
      if (v512)
      {
        *long long v494 = *v512;
        goto LABEL_913;
      }
      *long long v494 = *v484;
      void *v484 = v494;
      *((void *)*v481 + prime) = v484;
      if (*v494)
      {
        unint64_t v513 = *(void *)(*v494 + 8);
        if ((v489 & (v489 - 1)) != 0)
        {
          if (v513 >= v489) {
            v513 %= v489;
          }
        }
        else
        {
          v513 &= v489 - 1;
        }
        BOOL v512 = (char *)*v481 + 8 * v513;
LABEL_913:
        *BOOL v512 = v494;
      }
      ++*v483;
LABEL_915:
      v479 += 48;
      if (v479 == __ne) {
        goto LABEL_926;
      }
      continue;
    }
  }
LABEL_932:
  sub_1CD40B1BC(*((void **)&v802 + 1));
  if (v797 >= 0) {
    uint64_t v518 = &v795;
  }
  else {
    uint64_t v518 = v795;
  }
  if (v797 >= 0) {
    uint64_t v519 = v797 & 0x7F;
  }
  else {
    uint64_t v519 = v796;
  }
  LODWORD(v806.__r_.__value_.__l.__data_) = 0;
  v806.__r_.__value_.__l.__size_ = (std::string::size_type)std::system_category();
  v520 = (llvm *)llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)v819, v518, v519, (uint64_t)&v806);
  if (!LODWORD(v806.__r_.__value_.__l.__data_))
  {
    *(void *)&long long v804 = &v786;
    LOWORD(v859) = 257;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v819;
    __dst.__r_.__value_.__l.__size_ = (std::string::size_type)&v804;
    LOWORD(__dst.__r_.__value_.__r.__words[2]) = 1;
    llvm::Twine::str((llvm::Twine *)&v857, &v871);
    if (*(char *)(v804 + 31) < 0)
    {
      sub_1CB8BDF7C((uint64_t)v864, *(const void **)(v804 + 8), *(void *)(v804 + 16));
    }
    else
    {
      long long v654 = *(_OWORD *)(v804 + 8);
      *(void *)&v864[16] = *(void *)(v804 + 24);
      *(_OWORD *)v864 = v654;
    }
    std::string::size_type v655 = *((unsigned char *)&v871.__r_.__value_.__s + 23) & 0x7F;
    if ((v871.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v655 = v871.__r_.__value_.__l.__size_;
    }
    if (v655)
    {
      v659 = (void *)v820;
      if (*(void *)&v819[24] - (void)v820 > 8uLL)
      {
        *(unsigned char *)(v820 + 8) = 34;
        void *v659 = *(void *)"digraph \"";
        *(void *)&long long v820 = v820 + 9;
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)v819, "digraph \"", 9uLL);
      }
      v660 = &v871;
    }
    else
    {
      uint64_t v656 = *(void *)&v864[8];
      if (v864[23] >= 0) {
        uint64_t v656 = v864[23] & 0x7F;
      }
      v657 = (_OWORD *)v820;
      unint64_t v658 = *(void *)&v819[24] - v820;
      if (!v656)
      {
        if (v658 > 0x11)
        {
          *(_WORD *)(v820 + 16) = 2683;
          _OWORD *v657 = *(_OWORD *)"digraph unnamed {\n";
          *(void *)&long long v820 = v820 + 18;
        }
        else
        {
          llvm::raw_ostream::write((llvm::raw_ostream *)v819, "digraph unnamed {\n", 0x12uLL);
        }
        goto LABEL_1214;
      }
      if (v658 > 8)
      {
        *(unsigned char *)(v820 + 8) = 34;
        *(void *)v657 = *(void *)"digraph \"";
        *(void *)&long long v820 = v820 + 9;
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)v819, "digraph \"", 9uLL);
      }
      v660 = (std::string *)v864;
    }
    llvm::DOT::EscapeString((char *)v660, (uint64_t)&v811);
    if ((v811.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      v661 = &v811;
    }
    else {
      v661 = (std::string *)v811.__r_.__value_.__r.__words[0];
    }
    if ((v811.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      size_t v662 = *((unsigned char *)&v811.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      size_t v662 = v811.__r_.__value_.__l.__size_;
    }
    llvm::raw_ostream::write((llvm::raw_ostream *)v819, (const char *)v661, v662);
    if (*(void *)&v819[24] - (void)v820 > 3uLL)
    {
      *(_DWORD *)long long v820 = 175841314;
      *(void *)&long long v820 = v820 + 4;
    }
    else
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)v819, "\" {\n", 4uLL);
    }
    if (SHIBYTE(v811.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v811.__r_.__value_.__l.__data_);
    }
LABEL_1214:
    std::string::size_type v663 = *((unsigned char *)&v871.__r_.__value_.__s + 23) & 0x7F;
    if ((v871.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v663 = v871.__r_.__value_.__l.__size_;
    }
    if (v663)
    {
      if (*(void *)&v819[24] - (void)v820 > 7uLL)
      {
        *(void *)long long v820 = 0x223D6C6562616C09;
        *(void *)&long long v820 = v820 + 8;
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)v819, "\tlabel=\"", 8uLL);
      }
      v665 = &v871;
      goto LABEL_1226;
    }
    uint64_t v664 = v864[23] & 0x7F;
    if (v864[23] < 0) {
      uint64_t v664 = *(void *)&v864[8];
    }
    if (v664)
    {
      if (*(void *)&v819[24] - (void)v820 > 7uLL)
      {
        *(void *)long long v820 = 0x223D6C6562616C09;
        *(void *)&long long v820 = v820 + 8;
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)v819, "\tlabel=\"", 8uLL);
      }
      v665 = (std::string *)v864;
LABEL_1226:
      llvm::DOT::EscapeString((char *)v665, (uint64_t)&v811);
      if ((v811.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        v666 = &v811;
      }
      else {
        v666 = (std::string *)v811.__r_.__value_.__r.__words[0];
      }
      if ((v811.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        size_t v667 = *((unsigned char *)&v811.__r_.__value_.__s + 23) & 0x7F;
      }
      else {
        size_t v667 = v811.__r_.__value_.__l.__size_;
      }
      llvm::raw_ostream::write((llvm::raw_ostream *)v819, (const char *)v666, v667);
      v668 = (_WORD *)v820;
      if (*(void *)&v819[24] - (void)v820 > 2uLL)
      {
        *(unsigned char *)(v820 + 2) = 10;
        _WORD *v668 = 15138;
        *(void *)&long long v820 = v820 + 3;
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)v819, "\";\n", 3uLL);
      }
      if (SHIBYTE(v811.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v811.__r_.__value_.__l.__data_);
      }
    }
    *((unsigned char *)&v811.__r_.__value_.__s + 23) = 18;
    strcpy((char *)&v811, "\tsize=\"190, 190\";\n");
    llvm::raw_ostream::write((llvm::raw_ostream *)v819, (const char *)&v811, 0x12uLL);
    if (SHIBYTE(v811.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v811.__r_.__value_.__l.__data_);
    }
    if (*(void *)&v819[24] == (void)v820)
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)v819, "\n", 1uLL);
    }
    else
    {
      *(unsigned char *)long long v820 = 10;
      *(void *)&long long v820 = v820 + 1;
    }
    if ((v864[23] & 0x80000000) != 0) {
      operator delete(*(void **)v864);
    }
    v669 = *(void ****)(v804 + 56);
    v785 = *(void ****)(v804 + 64);
    if (v669 == v785)
    {
LABEL_1243:
      if (*(void *)&v819[24] - (void)v820 > 1uLL)
      {
        *(_WORD *)long long v820 = 2685;
        *(void *)&long long v820 = v820 + 2;
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)v819, "}\n", 2uLL);
      }
      if (SHIBYTE(v871.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v871.__r_.__value_.__l.__data_);
      }
      if ((void)v820 != *(void *)&v819[16])
      {
        *(void *)&long long v820 = *(void *)&v819[16];
        llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)v819, *(const char **)&v819[16]);
      }
      llvm::raw_fd_ostream::close((llvm::raw_fd_ostream *)v819);
      goto LABEL_1250;
    }
    while (2)
    {
      v689 = *v669;
      sub_1CCCD1070(&__str, **v669, (size_t)(*v669)[1]);
      v690 = (_DWORD *)v820;
      if (*(void *)&v819[24] - (void)v820 > 4uLL)
      {
        *(unsigned char *)(v820 + 4) = 101;
        _DWORD *v690 = 1685016073;
        *(void *)&long long v820 = v820 + 5;
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)v819, "\tNode", 5uLL);
      }
      llvm::write_hex((llvm::raw_ostream *)v819, (unint64_t)v689, 3, 0, 0);
      if (*(void *)&v819[24] - (void)v820 > 7uLL)
      {
        *(void *)long long v820 = 0x3D65706168735B20;
        uint64_t v691 = v820 + 8;
        *(void *)&long long v820 = v820 + 8;
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)v819, " [shape=", 8uLL);
        uint64_t v691 = v820;
      }
      if ((unint64_t)(*(void *)&v819[24] - v691) > 4)
      {
        *(unsigned char *)(v691 + 4) = 44;
        *(_DWORD *)uint64_t v691 = 1701736302;
        *(void *)&long long v820 = v820 + 5;
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)v819, "none,", 5uLL);
      }
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        size_t v692 = *((unsigned char *)&__str.__r_.__value_.__s + 23) & 0x7F;
      }
      else {
        size_t v692 = __str.__r_.__value_.__l.__size_;
      }
      if (v692)
      {
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          v693 = &__str;
        }
        else {
          v693 = (std::string *)__str.__r_.__value_.__r.__words[0];
        }
        llvm::raw_ostream::write((llvm::raw_ostream *)v819, (const char *)v693, v692);
        if (*(void *)&v819[24] == (void)v820)
        {
          llvm::raw_ostream::write((llvm::raw_ostream *)v819, ",", 1uLL);
        }
        else
        {
          *(unsigned char *)long long v820 = 44;
          *(void *)&long long v820 = v820 + 1;
        }
      }
      v694 = (_DWORD *)v820;
      if (*(void *)&v819[24] - (void)v820 > 5uLL)
      {
        *(_WORD *)(v820 + 4) = 15724;
        _DWORD *v694 = 1700946284;
        *(void *)&long long v820 = v820 + 6;
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)v819, "label=", 6uLL);
      }
      v695 = v689 + 13;
      int v696 = -1;
      v697 = v689 + 13;
      do
      {
        v697 = (void *)*v697;
        unsigned int v698 = v696 + 1;
        if (!v697) {
          break;
        }
        BOOL v36 = v696++ == 63;
      }
      while (!v36);
      if (v698 <= 1) {
        unsigned int v699 = 1;
      }
      else {
        unsigned int v699 = v698;
      }
      if (v697) {
        unint64_t v700 = v699 + 1;
      }
      else {
        unint64_t v700 = v699;
      }
      v701 = (void *)v820;
      if (*(void *)&v819[24] - (void)v820 > 0x30uLL)
      {
        *(unsigned char *)(v820 + 48) = 34;
        qmemcpy(v701, "<<table border=\"0\" cellborder=\"1\" cellspacing=\"0", 48);
        v702 = (void *)(v820 + 49);
        *(void *)&long long v820 = v820 + 49;
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)v819, "<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\"", 0x31uLL);
        v702 = (void *)v820;
      }
      if (*(void *)&v819[24] - (void)v702 > 0x2EuLL)
      {
        qmemcpy(v702, " cellpadding=\"0\"><tr><td align=\"text\" colspan=\"", 47);
        *(void *)&long long v820 = v820 + 47;
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)v819, " cellpadding=\"0\"><tr><td align=\"text\" colspan=\"", 0x2FuLL);
      }
      sub_1CD098D14((llvm::raw_ostream *)v819, v700, 0, 0, 0);
      if (*(void *)&v819[24] - (void)v820 > 1uLL)
      {
        *(_WORD *)long long v820 = 15906;
        *(void *)&long long v820 = v820 + 2;
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)v819, "\">", 2uLL);
      }
      if (*((char *)v689 + 39) < 0)
      {
        sub_1CB8BDF7C((uint64_t)v864, v689[2], (unint64_t)v689[3]);
      }
      else
      {
        *(_OWORD *)v864 = *((_OWORD *)v689 + 1);
        *(void *)&v864[16] = v689[4];
      }
      if (v864[23] >= 0) {
        v703 = v864;
      }
      else {
        v703 = *(const char **)v864;
      }
      if (v864[23] >= 0) {
        size_t v704 = v864[23] & 0x7F;
      }
      else {
        size_t v704 = *(void *)&v864[8];
      }
      llvm::raw_ostream::write((llvm::raw_ostream *)v819, v703, v704);
      v705 = (_DWORD *)v820;
      if (*(void *)&v819[24] - (void)v820 > 4uLL)
      {
        *(unsigned char *)(v820 + 4) = 62;
        _DWORD *v705 = 1685335868;
        *(void *)&long long v820 = v820 + 5;
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)v819, "</td>", 5uLL);
      }
      if ((v864[23] & 0x80000000) != 0) {
        operator delete(*(void **)v864);
      }
      v706 = (void *)*v695;
      long long v869 = 0uLL;
      *(void *)&long long v870 = 0;
      *(_DWORD *)&v864[8] = 0;
      char v865 = 0;
      uint64_t v866 = 0;
      *(void *)v864 = &unk_1F2646F30;
      v868 = &v869;
      int v867 = 0;
      memset(&v864[16], 0, 24);
      llvm::raw_ostream::write((llvm::raw_ostream *)v864, "</tr><tr>", 9uLL);
      if (v706)
      {
        unint64_t v707 = 0;
        char v708 = 0;
        do
        {
          sub_1CCCD1168((uint64_t)&v811, (int8x8_t *)v689, v706[2]);
          std::string::size_type v709 = *((unsigned char *)&v811.__r_.__value_.__s + 23) & 0x7F;
          if ((v811.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            std::string::size_type v709 = v811.__r_.__value_.__l.__size_;
          }
          if (v709)
          {
            uint64_t v710 = *(void *)&v864[32];
            if (*(void *)&v864[24] - *(void *)&v864[32] > 0x16uLL)
            {
              **(_OWORD **)&v864[32] = *(_OWORD *)"<td colspan=\"1\" port=\"s";
              *(void *)(v710 + 15) = *(void *)" port=\"s";
              *(void *)&v864[32] += 23;
            }
            else
            {
              llvm::raw_ostream::write((llvm::raw_ostream *)v864, "<td colspan=\"1\" port=\"s", 0x17uLL);
            }
            sub_1CD098D14((llvm::raw_ostream *)v864, v707, 0, 0, 0);
            if (*(void *)&v864[24] - *(void *)&v864[32] > 1uLL)
            {
              **(_WORD **)&v864[32] = 15906;
              *(void *)&v864[32] += 2;
            }
            else
            {
              llvm::raw_ostream::write((llvm::raw_ostream *)v864, "\">", 2uLL);
            }
            if ((v811.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              v711 = &v811;
            }
            else {
              v711 = (std::string *)v811.__r_.__value_.__r.__words[0];
            }
            if ((v811.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              size_t v712 = *((unsigned char *)&v811.__r_.__value_.__s + 23) & 0x7F;
            }
            else {
              size_t v712 = v811.__r_.__value_.__l.__size_;
            }
            llvm::raw_ostream::write((llvm::raw_ostream *)v864, (const char *)v711, v712);
            v713 = *(_DWORD **)&v864[32];
            if (*(void *)&v864[24] - *(void *)&v864[32] > 4uLL)
            {
              *(unsigned char *)(*(void *)&v864[32] + 4) = 62;
              _DWORD *v713 = 1685335868;
              *(void *)&v864[32] += 5;
            }
            else
            {
              llvm::raw_ostream::write((llvm::raw_ostream *)v864, "</td>", 5uLL);
            }
            char v708 = 1;
          }
          if (SHIBYTE(v811.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v811.__r_.__value_.__l.__data_);
          }
          v706 = (void *)*v706;
          if (!v706) {
            break;
          }
          BOOL v36 = v707++ == 63;
        }
        while (!v36);
        if (((v706 != 0) & v708) != 0)
        {
          uint64_t v714 = *(void *)&v864[32];
          if (*(void *)&v864[24] - *(void *)&v864[32] > 0x2BuLL)
          {
            **(_OWORD **)&v864[32] = *(_OWORD *)"<td colspan=\"1\" port=\"s64\">truncated...</td>";
            qmemcpy((void *)(v714 + 16), "port=\"s64\">truncated...</td>", 28);
            *(void *)&v864[32] += 44;
          }
          else
          {
            llvm::raw_ostream::write((llvm::raw_ostream *)v864, "<td colspan=\"1\" port=\"s64\">truncated...</td>", 0x2CuLL);
          }
          goto LABEL_1385;
        }
        if (v708)
        {
LABEL_1385:
          char v715 = *((unsigned char *)v868 + 23);
          if (v715 >= 0) {
            v716 = (const char *)v868;
          }
          else {
            v716 = *(const char **)v868;
          }
          if (v715 >= 0) {
            size_t v717 = v715 & 0x7F;
          }
          else {
            size_t v717 = *((void *)v868 + 1);
          }
          llvm::raw_ostream::write((llvm::raw_ostream *)v819, v716, v717);
        }
      }
      uint64_t v718 = v820;
      if (*(void *)&v819[24] - (void)v820 > 0xDuLL)
      {
        *(void *)long long v820 = *(void *)"</tr></table>>";
        *(void *)(v718 + 6) = *(void *)"/table>>";
        uint64_t v719 = v820 + 14;
        *(void *)&long long v820 = v820 + 14;
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)v819, "</tr></table>>", 0xEuLL);
        uint64_t v719 = v820;
      }
      if ((unint64_t)(*(void *)&v819[24] - v719) > 2)
      {
        *(unsigned char *)(v719 + 2) = 10;
        *(_WORD *)uint64_t v719 = 15197;
        *(void *)&long long v820 = v820 + 3;
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)v819, "];\n", 3uLL);
      }
      v720 = (void *)*v695;
      if (*v695)
      {
        int v721 = 0;
        do
        {
          sub_1CCCD0DD8((llvm::raw_ostream **)&__dst, (int8x8_t *)v689, v721, (uint64_t)v720);
          v720 = (void *)*v720;
          if (v721 == 63) {
            break;
          }
          ++v721;
        }
        while (v720);
        for (; v720; v720 = (void *)*v720)
          sub_1CCCD0DD8((llvm::raw_ostream **)&__dst, (int8x8_t *)v689, 64, (uint64_t)v720);
      }
      *(void *)v864 = &unk_1F2646B98;
      if (v867 == 1 && *(void *)&v864[16]) {
        MEMORY[0x1D25D9CB0](*(void *)&v864[16], 0x1000C8077774924);
      }
      if (SBYTE7(v870) < 0) {
        operator delete((void *)v869);
      }
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
      if (++v669 == v785) {
        goto LABEL_1243;
      }
      continue;
    }
  }
  v648 = (llvm::raw_ostream *)llvm::errs(v520);
  v649 = v648;
  v650 = (_DWORD *)*((void *)v648 + 4);
  if (*((void *)v648 + 3) - (void)v650 > 6uLL)
  {
    *(_DWORD *)((char *)v650 + 3) = 540701295;
    _DWORD *v650 = 1869771333;
    *((void *)v648 + 4) += 7;
  }
  else
  {
    llvm::raw_ostream::write(v648, "Error: ", 7uLL);
  }
  std::error_code::message((std::string *)v864, (const std::error_code *)&v806);
  if (v864[23] >= 0) {
    v651 = v864;
  }
  else {
    v651 = *(const char **)v864;
  }
  if (v864[23] >= 0) {
    size_t v652 = v864[23] & 0x7F;
  }
  else {
    size_t v652 = *(void *)&v864[8];
  }
  llvm::raw_ostream::write(v649, v651, v652);
  v653 = (unsigned char *)*((void *)v649 + 4);
  if (*((unsigned char **)v649 + 3) == v653)
  {
    llvm::raw_ostream::write(v649, "\n", 1uLL);
  }
  else
  {
    unsigned char *v653 = 10;
    ++*((void *)v649 + 4);
  }
  if ((v864[23] & 0x80000000) != 0) {
    operator delete(*(void **)v864);
  }
LABEL_1250:
  llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)v819);
  v670 = *(llvm::raw_ostream **)(a1 + 40);
  if (v797 >= 0) {
    v671 = &v795;
  }
  else {
    v671 = (void **)v795;
  }
  if (v797 >= 0) {
    uint64_t v672 = v797 & 0x7F;
  }
  else {
    uint64_t v672 = v796;
  }
  llvm::DotCfgChangeReporter::genHTML((uint64_t)__src, __len, v671, v672, (uint64_t)v845, v846, (uint64_t)v819);
  if (v819[23] >= 0) {
    v673 = v819;
  }
  else {
    v673 = *(const char **)v819;
  }
  if (v819[23] >= 0) {
    size_t v674 = v819[23] & 0x7F;
  }
  else {
    size_t v674 = *(void *)&v819[8];
  }
  llvm::raw_ostream::write(v670, v673, v674);
  if ((v819[23] & 0x80000000) != 0) {
    operator delete(*(void **)v819);
  }
  LOWORD(v820) = 260;
  *(void *)v819 = &v795;
  v675 = (llvm *)llvm::sys::fs::remove((llvm::sys::fs *)v819, (const llvm::Twine *)1);
  *(void *)v864 = v675;
  *(void *)&v864[8] = v676;
  if (v675)
  {
    v677 = (llvm::raw_ostream *)llvm::errs(v675);
    v678 = v677;
    v679 = (_DWORD *)*((void *)v677 + 4);
    if (*((void *)v677 + 3) - (void)v679 > 6uLL)
    {
      *(_DWORD *)((char *)v679 + 3) = 540701295;
      _DWORD *v679 = 1869771333;
      *((void *)v677 + 4) += 7;
    }
    else
    {
      llvm::raw_ostream::write(v677, "Error: ", 7uLL);
    }
    std::error_code::message((std::string *)v819, (const std::error_code *)v864);
    v680 = v819[23] >= 0 ? v819 : *(const char **)v819;
    size_t v681 = v819[23] >= 0 ? v819[23] & 0x7F : *(void *)&v819[8];
    llvm::raw_ostream::write(v678, v680, v681);
    v682 = (unsigned char *)*((void *)v678 + 4);
    if (*((unsigned char **)v678 + 3) == v682)
    {
      llvm::raw_ostream::write(v678, "\n", 1uLL);
    }
    else
    {
      unsigned char *v682 = 10;
      ++*((void *)v678 + 4);
    }
    if ((v819[23] & 0x80000000) != 0) {
      operator delete(*(void **)v819);
    }
  }
  if (*((void *)&v790 + 1))
  {
    *(void *)&long long v791 = *((void *)&v790 + 1);
    operator delete(*((void **)&v790 + 1));
  }
  uint64_t v683 = v789;
  if ((void)v789)
  {
    uint64_t v684 = *((void *)&v789 + 1);
    v685 = (void *)v789;
    if (*((void *)&v789 + 1) != (void)v789)
    {
      do
      {
        v684 -= 176;
        sub_1CCCD0188(v684);
      }
      while (v684 != v683);
      v685 = (void *)v789;
    }
    *((void *)&v789 + sub_1CD7485C0(this + 1) = v683;
    operator delete(v685);
  }
  if (SHIBYTE(v788) < 0) {
    operator delete((void *)v787);
  }
  if (SHIBYTE(v794) < 0) {
    operator delete(v793[0]);
  }
  sub_1CCB7ABD0((uint64_t)&v833);
  if (SHIBYTE(v832) < 0) {
    operator delete(v830);
  }
  sub_1CC3724DC((uint64_t)&v828[24]);
  v686 = *(void **)v828;
  if (*(void *)v828)
  {
    v687 = *(void **)&v828[8];
    v688 = *(void **)v828;
    if (*(void *)&v828[8] != *(void *)v828)
    {
      do
      {
        v687 -= 15;
        sub_1CCCD0044(v687);
      }
      while (v687 != v686);
      v688 = *(void **)v828;
    }
    *(void *)&v828[8] = v686;
    operator delete(v688);
  }
  if (__src != &v838) {
    free(__src);
  }
  if (v845 != v847) {
    free(v845);
  }
  if (v797 < 0) {
    operator delete(v795);
  }
  if (v848 != v850) {
    free(v848);
  }
  if (v851 != &v853) {
    free(v851);
  }
  if (v854 != &v856) {
    free(v854);
  }
}

void sub_1CCCCF208(std::string *this, char *__src, size_t a3)
{
  size_t v3 = a3;
  *(_OWORD *)&this->__r_.__value_.__l.__data_ = 0uLL;
  this->__r_.__value_.__r.__words[2] = 0;
  if (a3) {
    goto LABEL_2;
  }
LABEL_5:
  unint64_t v6 = -1;
  while (1)
  {
    if (v3 >= v6) {
      size_t v7 = v6;
    }
    else {
      size_t v7 = v3;
    }
    if (!__src)
    {
      std::string::size_type v9 = 0;
      size_t v10 = 0;
      char v11 = 0;
      std::string __dst = 0;
      size_t v22 = 0;
      unint64_t v23 = 0;
      goto LABEL_20;
    }
    if (v7 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    if (v7 >= 0x17)
    {
      uint64_t v12 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v7 | 7) != 0x17) {
        uint64_t v12 = v7 | 7;
      }
      uint64_t v13 = v12 + 1;
      p_dst = (void **)operator new(v12 + 1);
      size_t v22 = v7;
      unint64_t v23 = v13 | 0x8000000000000000;
      std::string __dst = p_dst;
    }
    else
    {
      HIBYTE(v23) = v7;
      p_dst = (void **)&__dst;
      if (!v7) {
        goto LABEL_19;
      }
    }
    memmove(p_dst, __src, v7);
LABEL_19:
    *((unsigned char *)p_dst + v7) = 0;
    char v11 = HIBYTE(v23);
    size_t v10 = (const std::string::value_type *)__dst;
    std::string::size_type v9 = v22;
LABEL_20:
    int v14 = v11;
    if (v11 >= 0) {
      uint64_t v15 = (const std::string::value_type *)&__dst;
    }
    else {
      uint64_t v15 = v10;
    }
    std::string::size_type v16 = v11 & 0x7F;
    if (v14 >= 0) {
      std::string::size_type v17 = v16;
    }
    else {
      std::string::size_type v17 = v9;
    }
    std::string::append(this, v15, v17);
    if (SHIBYTE(v23) < 0) {
      operator delete(__dst);
    }
    if (v3 <= v6) {
      break;
    }
    uint64_t v18 = &__src[v7];
    int v19 = *v18;
    __src = v18 + 1;
    if (v19 == 60) {
      int v20 = "&lt;";
    }
    else {
      int v20 = "&gt;";
    }
    std::string::append(this, v20);
    v3 += ~v7;
    if (!v3) {
      goto LABEL_5;
    }
LABEL_2:
    unint64_t v6 = 0;
    while ((__src[v6] & 0xFD) != 0x3C)
    {
      if (v3 == ++v6) {
        goto LABEL_5;
      }
    }
  }
}

int64x2_t *sub_1CCCCF394(uint64_t *a1, int64x2_t *a2)
{
  uint64_t v4 = *a1;
  if (v4) {
    (*(void (**)(int64x2_t **__return_ptr))(*(void *)v4 + 16))(&v12);
  }
  else {
    uint64_t v12 = 0;
  }
  uint64_t v5 = sub_1CCCC8588((uint64_t *)&v12);
  uint64_t result = v12;
  uint64_t v12 = 0;
  if (result) {
    uint64_t result = (int64x2_t *)(*(uint64_t (**)(int64x2_t *))(result->i64[0] + 8))(result);
  }
  if (v5)
  {
    uint64_t v7 = v5 + 24;
    for (uint64_t i = *(void *)(v5 + 32); i != v7; uint64_t i = *(void *)(i + 8))
    {
      if (i) {
        std::string::size_type v9 = (llvm::Value *)(i - 56);
      }
      else {
        std::string::size_type v9 = 0;
      }
      uint64_t result = sub_1CD7496F8(a2, v9);
    }
  }
  else
  {
    size_t v10 = (void *)(*(uint64_t (**)(void))(*(void *)*a1 + 24))();
    (*(void (**)(void))(*(void *)*a1 + 24))();
    if (v10 == &llvm::Any::TypeId<llvm::Function const*>::Id) {
      char v11 = (llvm::Value **)(*a1 + 8);
    }
    else {
      char v11 = (llvm::Value **)(**(void **)(*(void *)(*a1 + 8) + 32) + 56);
    }
    return sub_1CD7496F8(a2, *v11);
  }
  return result;
}

__n128 sub_1CCCCF4FC(uint64_t a1, char *__s, uint64_t a3, __n128 *a4, uint64_t a5)
{
  if (__s) {
    size_t v10 = strlen(__s);
  }
  else {
    size_t v10 = 0;
  }
  unint64_t v11 = a4[1].n128_u64[0];
  __n128 result = *a4;
  a4->n128_u64[1] = 0;
  a4[1].n128_u64[0] = 0;
  a4->n128_u64[0] = 0;
  *(void *)a1 = __s;
  *(void *)(a1 + 8) = v10;
  *(void *)(a1 + 96) = a1 + 32;
  *(void *)(a1 + 16) = a1 + 96;
  *(void *)(a1 + 24) = 3;
  *(void *)(a1 + 32) = &unk_1F2617FC0;
  *(void *)(a1 + 40) = a3;
  *(void *)(a1 + 48) = &unk_1F2619700;
  *(__n128 *)(a1 + 56) = result;
  *(void *)(a1 + 72) = v11;
  *(void *)(a1 + 80) = &unk_1F2619560;
  *(void *)(a1 + 88) = a5;
  *(void *)(a1 + 104) = a1 + 48;
  *(void *)(a1 + 112) = a1 + 80;
  return result;
}

__n128 sub_1CCCCF5EC(uint64_t a1, uint64_t a2, __n128 *a3)
{
  unint64_t v3 = a3[1].n128_u64[0];
  __n128 result = *a3;
  a3->n128_u64[1] = 0;
  a3[1].n128_u64[0] = 0;
  a3->n128_u64[0] = 0;
  *(void *)a1 = "  <a>{0}. {1} invalidated</a><br/>\n";
  *(void *)(a1 + 8) = 35;
  *(void *)(a1 + 80) = a1 + 32;
  *(void *)(a1 + 16) = a1 + 80;
  *(void *)(a1 + 24) = 2;
  *(void *)(a1 + 32) = &unk_1F2617FC0;
  *(void *)(a1 + 40) = a2;
  *(void *)(a1 + 48) = &unk_1F2619700;
  *(__n128 *)(a1 + 56) = result;
  *(void *)(a1 + 72) = v3;
  *(void *)(a1 + 88) = a1 + 48;
  return result;
}

void sub_1CCCCF678(llvm::raw_ostream *a1, llvm::Value *a2)
{
  if ((*((unsigned char *)a2 + 23) & 0x10) != 0)
  {
    uint64_t v4 = ***(void ***)a2;
    uint64_t v5 = *(void *)(v4 + 152);
    uint64_t v6 = *(unsigned int *)(v4 + 168);
    if (v6)
    {
      LODWORD(v7) = (v6 - 1) & ((a2 >> 4) ^ (a2 >> 9));
      int v8 = (llvm::Value **)(v5 + 16 * v7);
      std::string::size_type v9 = *v8;
      if (*v8 == a2)
      {
LABEL_9:
        uint64_t v12 = v8[1];
        std::string::size_type v15 = *(void *)v12;
        uint64_t v13 = (char *)v12 + 16;
        std::string::size_type v14 = v15;
        goto LABEL_10;
      }
      int v10 = 1;
      while (v9 != (llvm::Value *)-4096)
      {
        int v11 = v7 + v10++;
        uint64_t v7 = v11 & (v6 - 1);
        std::string::size_type v9 = *(llvm::Value **)(v5 + 16 * v7);
        if (v9 == a2)
        {
          int v8 = (llvm::Value **)(v5 + 16 * v7);
          goto LABEL_9;
        }
      }
    }
    int v8 = (llvm::Value **)(v5 + 16 * v6);
    goto LABEL_9;
  }
  std::string::size_type v14 = 0;
  uint64_t v13 = &byte_1CFBCE98E;
LABEL_10:
  if (llvm::isFunctionInPrintList(v13, v14))
  {
    llvm::Value::print(a2, a1, 0);
  }
}

void *sub_1CCCCF758(llvm::StringMapImpl *a1, unsigned __int8 *a2, size_t __n, uint64_t a4)
{
  unsigned int v7 = *((_DWORD *)a1 + 2);
  if (!v7)
  {
    *((_DWORD *)a1 + 3) = 0;
    *((_DWORD *)a1 + 4) = 0;
    uint64_t v27 = malloc_type_calloc(0x11uLL, 0xCuLL, 0x6D9A4F0CuLL);
    if (!v27) {
      llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
    }
    v27[16] = 2;
    *(void *)a1 = v27;
    unsigned int v7 = 16;
    *((_DWORD *)a1 + 2) = 16;
  }
  uint64_t v28 = a4;
  int v8 = 0;
  if (__n)
  {
    size_t v9 = __n;
    int v10 = a2;
    do
    {
      int v11 = *v10++;
      int v8 = 33 * v8 + v11;
      --v9;
    }
    while (v9);
  }
  uint64_t v12 = *(void *)a1;
  unsigned int v13 = v7 - 1;
  uint64_t v14 = *(void *)a1 + 8 * v7 + 8;
  int v15 = -1;
  int v16 = 1;
  int v17 = v8;
  while (1)
  {
    uint64_t v18 = v17 & v13;
    int v19 = *(void **)(v12 + 8 * v18);
    if (!v19) {
      break;
    }
    if (v19 == (void *)-8)
    {
      if (v15 == -1) {
        int v15 = v17 & v13;
      }
    }
    else if (*(_DWORD *)(v14 + 4 * v18) == v8 {
           && __n == *v19
    }
           && (!__n || !memcmp(a2, (char *)v19 + *((unsigned int *)a1 + 5), __n)))
    {
      goto LABEL_17;
    }
    int v17 = v16 + v18;
    ++v16;
  }
  uint64_t v20 = v15;
  if (v15 == -1)
  {
    uint64_t v20 = v18;
    uint64_t v18 = v18;
  }
  else
  {
    uint64_t v18 = v15;
  }
  *(_DWORD *)(v14 + 4 * v20) = v8;
  int v19 = *(void **)(v12 + 8 * v18);
LABEL_17:
  uint64_t i = (void *)(v12 + 8 * v18);
  if (v19)
  {
    if (v19 != (void *)-8) {
      return i;
    }
    --*((_DWORD *)a1 + 4);
  }
  size_t v22 = (char *)operator new(__n + 33, (std::align_val_t)8uLL);
  unint64_t v23 = v22;
  uint64_t v24 = v22 + 32;
  if (__n) {
    memcpy(v22 + 32, a2, __n);
  }
  v24[__n] = 0;
  *(void *)unint64_t v23 = __n;
  *(_OWORD *)(v23 + 8) = *(_OWORD *)v28;
  *((void *)v23 + 3) = *(void *)(v28 + 16);
  *(void *)(v28 + 8) = 0;
  *(void *)(v28 + 16) = 0;
  *(void *)uint64_t v28 = 0;
  void *i = v23;
  ++*((_DWORD *)a1 + 3);
  for (uint64_t i = (void *)(*(void *)a1 + 8 * llvm::StringMapImpl::RehashTable(a1, v18));
        !*i || *i == -8;
  return i;
}

void *sub_1CCCCF980(void *a1, uint64_t *a2)
{
  if (*((char *)a2 + 23) >= 0) {
    unint64_t v3 = a2;
  }
  else {
    unint64_t v3 = (uint64_t *)*a2;
  }
  *a1 = v3;
  char v4 = *((unsigned char *)a2 + 23);
  int v5 = v4;
  uint64_t v6 = v4 & 0x7F;
  if (v5 < 0) {
    uint64_t v6 = a2[1];
  }
  a1[1] = v6;
  uint64_t v7 = (uint64_t)(a1 + 2);
  if (*((char *)a2 + 47) < 0)
  {
    sub_1CB8BDF7C(v7, (const void *)a2[3], a2[4]);
  }
  else
  {
    long long v8 = *(_OWORD *)(a2 + 3);
    *(void *)(v7 + 16) = a2[5];
    *(_OWORD *)uint64_t v7 = v8;
  }
  return a1;
}

void sub_1CCCCFA04(uint64_t a1, unsigned __int8 *a2, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v11 = *(void **)a1;
  int v10 = *(void **)(a1 + 8);
  unint64_t v12 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)v10 - *(void *)a1) >> 3);
  unint64_t v13 = *(void *)(a1 + 16);
  int v51 = v12;
  if ((unint64_t)v10 >= v13)
  {
    unint64_t v15 = v12 + 1;
    if (v12 + 1 > 0x222222222222222) {
      abort();
    }
    unint64_t v16 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v13 - (void)v11) >> 3);
    if (2 * v16 > v15) {
      unint64_t v15 = 2 * v16;
    }
    if (v16 >= 0x111111111111111) {
      unint64_t v17 = 0x222222222222222;
    }
    else {
      unint64_t v17 = v15;
    }
    if (v17 > 0x222222222222222) {
      sub_1CB833614();
    }
    uint64_t v18 = 120 * v17;
    int v19 = (char *)operator new(120 * v17);
    uint64_t v20 = &v19[120 * v12];
    *(void *)uint64_t v20 = a1;
    *((_DWORD *)v20 + 2) = v12;
    *((void *)v20 + 2) = a4;
    *((void *)v20 + 3) = 0;
    *((void *)v20 + 4) = a5;
    *((void *)v20 + 5) = a6;
    *((void *)v20 + 8) = 0;
    *((void *)v20 + 7) = 0;
    *((void *)v20 + 6) = v20 + 56;
    uint64_t v14 = v20 + 120;
    *(_OWORD *)(v20 + 72) = 0u;
    *(_OWORD *)(v20 + 88) = 0u;
    *(_OWORD *)(v20 + 104) = 0u;
    if (v10 == v11)
    {
      *(void *)a1 = v20;
      *(void *)(a1 + 8) = v14;
      *(void *)(a1 + 16) = &v19[v18];
    }
    else
    {
      int v49 = &v19[v18];
      std::string::size_type v50 = v20 + 120;
      size_t v21 = v10;
      size_t v22 = &v19[120 * v12];
      do
      {
        uint64_t v23 = *(v21 - 15);
        v21 -= 15;
        *((void *)v22 - 15) = v23;
        v22 -= 120;
        *((_DWORD *)v20 - 28) = *((_DWORD *)v21 + 2);
        *((void *)v20 - 13) = v21[2];
        *((void *)v20 - 12) = v21[3];
        long long v24 = *((_OWORD *)v21 + 2);
        *((void *)v20 - 8) = 0;
        *((void *)v20 - 9) = v20 - 64;
        *(_OWORD *)(v20 - 88) = v24;
        *((void *)v20 - 7) = 0;
        uint64_t v25 = (void *)v21[6];
        if (v25 != v21 + 7)
        {
          do
          {
            sub_1CD746D2C((void **)v20 - 9, (uint64_t *)v20 - 8, *((_DWORD *)v25 + 8), (uint64_t)(v25 + 4));
            int64x2_t v26 = (void *)v25[1];
            if (v26)
            {
              do
              {
                uint64_t v27 = v26;
                int64x2_t v26 = (void *)*v26;
              }
              while (v26);
            }
            else
            {
              do
              {
                uint64_t v27 = (void *)v25[2];
                BOOL v28 = *v27 == (void)v25;
                uint64_t v25 = v27;
              }
              while (!v28);
            }
            uint64_t v25 = v27;
          }
          while (v27 != v21 + 7);
        }
        *((void *)v20 - 5) = 0;
        *((void *)v20 - 4) = 0;
        *((void *)v20 - 6) = 0;
        sub_1CBA85A80((void *)v20 - 6, (const void *)*(v10 - 6), *(v10 - 5), (uint64_t)(*(v10 - 5) - *(v10 - 6)) >> 2);
        *((void *)v20 - 3) = 0;
        *((void *)v20 - 2) = 0;
        uint64_t v29 = v20 - 24;
        *((void *)v29 + 2) = 0;
        sub_1CBA85A80(v29, (const void *)*(v10 - 3), *(v10 - 2), (uint64_t)(*(v10 - 2) - *(v10 - 3)) >> 2);
        int v10 = v21;
        uint64_t v20 = v22;
      }
      while (v21 != v11);
      uint64_t v14 = v50;
      int v10 = *(void **)a1;
      std::string::size_type v30 = *(void **)(a1 + 8);
      *(void *)a1 = v22;
      *(void *)(a1 + 8) = v50;
      *(void *)(a1 + 16) = v49;
      while (v30 != v10)
      {
        v30 -= 15;
        sub_1CCCD0044(v30);
      }
    }
    if (v10) {
      operator delete(v10);
    }
  }
  else
  {
    void *v10 = a1;
    *((_DWORD *)v10 + 2) = v12;
    uint64_t v10[2] = a4;
    void v10[3] = 0;
    void v10[4] = a5;
    v10[5] = a6;
    v10[8] = 0;
    v10[7] = 0;
    v10[6] = v10 + 7;
    uint64_t v14 = (char *)(v10 + 15);
    *(_OWORD *)(v10 + 9) = 0u;
    *(_OWORD *)(v10 + 1sub_1CD7485C0(this + 1) = 0u;
    *(_OWORD *)(v10 + 13) = 0u;
  }
  *(void *)(a1 + 8) = v14;
  unsigned int v31 = *(_DWORD *)(a1 + 32);
  if (!v31)
  {
    *(_DWORD *)(a1 + 36) = 0;
    *(_DWORD *)(a1 + 40) = 0;
    uint64_t v45 = malloc_type_calloc(0x11uLL, 0xCuLL, 0x6D9A4F0CuLL);
    if (!v45) {
      llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
    }
    v45[16] = 2;
    *(void *)(a1 + 24) = v45;
    unsigned int v31 = 16;
    *(_DWORD *)(a1 + 32) = 16;
  }
  size_t v32 = a3;
  if (a3)
  {
    int v33 = 0;
    uint64_t v34 = a2;
    do
    {
      int v35 = *v34++;
      int v33 = 33 * v33 + v35;
      --v32;
    }
    while (v32);
  }
  else
  {
    int v33 = 0;
  }
  uint64_t v36 = *(void *)(a1 + 24);
  unsigned int v37 = v31 - 1;
  uint64_t v38 = v36 + 8 * v31 + 8;
  int v39 = -1;
  int v40 = 1;
  int v41 = v33;
  while (1)
  {
    uint64_t v42 = v41 & v37;
    char v43 = *(void **)(v36 + 8 * v42);
    if (!v43) {
      break;
    }
    if (v43 == (void *)-8)
    {
      if (v39 == -1) {
        int v39 = v41 & v37;
      }
    }
    else if (*(_DWORD *)(v38 + 4 * v42) == v33 {
           && a3 == *v43
    }
           && (!a3 || !memcmp(a2, (char *)v43 + *(unsigned int *)(a1 + 44), a3)))
    {
      goto LABEL_45;
    }
    int v41 = v40 + v42;
    ++v40;
  }
  uint64_t v44 = v39;
  if (v39 == -1)
  {
    uint64_t v44 = v42;
    uint64_t v42 = v42;
  }
  else
  {
    uint64_t v42 = v39;
  }
  *(_DWORD *)(v38 + 4 * v44) = v33;
  char v43 = *(void **)(v36 + 8 * v42);
LABEL_45:
  if (v43)
  {
    if (v43 != (void *)-8) {
      return;
    }
    --*(_DWORD *)(a1 + 40);
  }
  std::string::size_type v46 = (char *)operator new(a3 + 17, (std::align_val_t)8uLL);
  uint64_t v47 = v46;
  unint64_t v48 = v46 + 16;
  if (a3) {
    memcpy(v46 + 16, a2, a3);
  }
  v48[a3] = 0;
  *(void *)uint64_t v47 = a3;
  *(void *)(v36 + 8 * v42) = v47;
  *((_DWORD *)v47 + 2) = v51;
  ++*(_DWORD *)(a1 + 36);

  llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)(a1 + 24), v42);
}

void sub_1CCCCFE58(uint64_t a1, uint64_t a2, void *__src, size_t __len)
{
  if ((*(char *)(a2 + 23) & 0x80000000) == 0)
  {
    if (*(unsigned char *)(a2 + 23)) {
      goto LABEL_3;
    }
LABEL_9:
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(void *)(a1 + 16) = *(void *)(a2 + 16);
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    *(void *)a2 = 0;
    return;
  }
  if (!*(void *)(a2 + 8)) {
    goto LABEL_9;
  }
LABEL_3:
  if (__src)
  {
    if (__len >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    if (__len >= 0x17)
    {
      size_t v9 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((__len | 7) != 0x17) {
        size_t v9 = __len | 7;
      }
      size_t v10 = v9 + 1;
      p_dst = (std::string *)operator new(v9 + 1);
      __dst.__r_.__value_.__l.__size_ = __len;
      __dst.__r_.__value_.__r.__words[2] = v10 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = __len;
      p_dst = &__dst;
      if (!__len) {
        goto LABEL_15;
      }
    }
    memmove(p_dst, __src, __len);
LABEL_15:
    p_dst->__r_.__value_.__s.__data_[__len] = 0;
    goto LABEL_16;
  }
  memset(&__dst, 0, sizeof(__dst));
LABEL_16:
  int v11 = std::string::insert(&__dst, 0, "<FONT COLOR=\"");
  std::string::size_type v12 = v11->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v24.__r_.__value_.__l.__data_ = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  v24.__r_.__value_.__r.__words[2] = v12;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  unint64_t v13 = std::string::append(&v24, "\">");
  std::string::size_type v14 = v13->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v25.__r_.__value_.__l.__data_ = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
  v25.__r_.__value_.__r.__words[2] = v14;
  v13->__r_.__value_.__l.__size_ = 0;
  v13->__r_.__value_.__r.__words[2] = 0;
  v13->__r_.__value_.__r.__words[0] = 0;
  char v15 = *(unsigned char *)(a2 + 23);
  BOOL v16 = v15 < 0;
  if (v15 >= 0) {
    unint64_t v17 = (const std::string::value_type *)a2;
  }
  else {
    unint64_t v17 = *(const std::string::value_type **)a2;
  }
  std::string::size_type v18 = v15 & 0x7F;
  if (v16) {
    std::string::size_type v19 = *(void *)(a2 + 8);
  }
  else {
    std::string::size_type v19 = v18;
  }
  uint64_t v20 = std::string::append(&v25, v17, v19);
  std::string::size_type v21 = v20->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v26.__r_.__value_.__l.__data_ = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
  v26.__r_.__value_.__r.__words[2] = v21;
  v20->__r_.__value_.__l.__size_ = 0;
  v20->__r_.__value_.__r.__words[2] = 0;
  v20->__r_.__value_.__r.__words[0] = 0;
  size_t v22 = std::string::append(&v26, "</FONT>");
  *(std::string *)a1 = *v22;
  v22->__r_.__value_.__r.__words[0] = 0;
  v22->__r_.__value_.__l.__size_ = 0;
  v22->__r_.__value_.__r.__words[2] = 0;
  if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v26.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v25.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v24.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
}

void sub_1CCCD0044(void *a1)
{
  uint64_t v2 = (void *)a1[12];
  if (v2)
  {
    a1[13] = v2;
    operator delete(v2);
  }
  unint64_t v3 = (void *)a1[9];
  if (v3)
  {
    a1[10] = v3;
    operator delete(v3);
  }
  char v4 = (char *)a1[7];

  sub_1CD746FD4(v4);
}

void sub_1CCCD0098(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_1CB8BDF7C((uint64_t)__p, *(const void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    uint64_t v8 = *(void *)(a2 + 16);
  }
  *(_OWORD *)a1 = *a3;
  int v5 = (_OWORD *)(a1 + 16);
  if (SHIBYTE(v8) < 0)
  {
    sub_1CB8BDF7C((uint64_t)v5, __p[0], (unint64_t)__p[1]);
    int v6 = SHIBYTE(v8);
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
    *(_OWORD *)(a1 + 72) = 0u;
    *(_OWORD *)(a1 + 88) = 0u;
    *(_OWORD *)(a1 + 104) = 0u;
    *(_DWORD *)(a1 + 120) = 1065353216;
    *(_OWORD *)(a1 + 128) = 0u;
    *(_OWORD *)(a1 + 144) = 0u;
    *(_DWORD *)(a1 + 160) = 1065353216;
    *(unsigned char *)(a1 + 168) = 0;
    if (v6 < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    *int v5 = *(_OWORD *)__p;
    *(void *)(a1 + 32) = v8;
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
    *(_OWORD *)(a1 + 72) = 0u;
    *(_OWORD *)(a1 + 88) = 0u;
    *(_OWORD *)(a1 + 104) = 0u;
    *(_DWORD *)(a1 + 120) = 1065353216;
    *(_OWORD *)(a1 + 128) = 0u;
    *(_OWORD *)(a1 + 144) = 0u;
    *(_DWORD *)(a1 + 160) = 1065353216;
    *(unsigned char *)(a1 + 168) = 0;
  }
}

void sub_1CCCD0188(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 144);
  if (v2)
  {
    do
    {
      unint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  char v4 = *(void **)(a1 + 128);
  *(void *)(a1 + 128) = 0;
  if (v4) {
    operator delete(v4);
  }
  int v5 = *(void **)(a1 + 104);
  if (v5)
  {
    do
    {
      int v6 = (void *)*v5;
      operator delete(v5);
      int v5 = v6;
    }
    while (v6);
  }
  uint64_t v7 = *(void **)(a1 + 88);
  *(void *)(a1 + 88) = 0;
  if (v7) {
    operator delete(v7);
  }
  uint64_t v8 = *(void **)(a1 + 64);
  if (v8)
  {
    *(void *)(a1 + 72) = v8;
    operator delete(v8);
  }
  uint64_t v9 = *(void *)(a1 + 40);
  if (v9)
  {
    uint64_t v10 = *(void *)(a1 + 48);
    int v11 = *(void **)(a1 + 40);
    if (v10 != v9)
    {
      do
      {
        if (*(char *)(v10 - 9) < 0) {
          operator delete(*(void **)(v10 - 32));
        }
        v10 -= 48;
      }
      while (v10 != v9);
      int v11 = *(void **)(a1 + 40);
    }
    *(void *)(a1 + 48) = v9;
    operator delete(v11);
  }
  if (*(char *)(a1 + 39) < 0)
  {
    std::string::size_type v12 = *(void **)(a1 + 16);
    operator delete(v12);
  }
}

void sub_1CCCD027C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  v100[3] = *MEMORY[0x1E4F143B8];
  v53[0] = a6;
  v53[1] = a7;
  v52[0] = a9;
  v52[1] = a10;
  v51[0] = a11;
  v51[1] = a12;
  uint64_t v99 = a2;
  v100[0] = a3;
  v100[1] = a4;
  v100[2] = a5;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCEFBC8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EBCEFBC8))
  {
    unk_1EBCEFC80 = 0;
    *(_OWORD *)&qword_1EBCEFC70 = 0u;
    *(_OWORD *)&qword_1EBCEFC60 = 0u;
    unk_1EBCEFC50 = 0u;
    *(_OWORD *)&qword_1EBCEFC40 = 0u;
    __cxa_atexit((void (*)(void *))sub_1CCCD3C54, 0, &dword_1CB82C000);
    __cxa_guard_release(&qword_1EBCEFBC8);
  }
  uint64_t v13 = 0;
  std::string::size_type v14 = v100;
  for (uint64_t i = &dword_1EA618210; ; ++i)
  {
    if (*i == -1)
    {
      unint64_t v95 = &v97;
      long long v96 = xmmword_1CFB2C4B0;
      int v87 = "tmpdiff";
      LOWORD(v90) = 259;
      uint64_t v16 = sub_1CD0E51FC((uint64_t *)&v87, (long long *)"txt", 3, i, &v95, 1, 0);
      if (v16)
      {
        unint64_t v17 = (char *)operator new(0x28uLL);
        *(void *)a1 = v17;
        *(_OWORD *)(a1 + 8) = xmmword_1CFAC3CC0;
        strcpy(v17, "Unable to create temporary file.");
      }
      else
      {
        LOWORD(v90) = 261;
        int v87 = v95;
        *(void *)&long long v88 = v96;
        llvm::Twine::str((llvm::Twine *)&v87, v80);
        std::string::size_type v18 = (void **)((char *)&unk_1EBCEFBB8 + v13 + 136);
        if (*((char *)&unk_1EBCEFBB8 + v13 + 159) < 0) {
          operator delete(*v18);
        }
        *(_OWORD *)std::string::size_type v18 = *(_OWORD *)v80;
        *(void *)((char *)&unk_1EBCEFBB8 + v13 + 152) = *(void *)&v80[16];
      }
      if (v95 != &v97) {
        free(v95);
      }
      if (v16) {
        break;
      }
    }
    if (v13 == 48)
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCEFBD0, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EBCEFBD0))
      {
        if (byte_1EBCEFEB7 >= 0) {
          size_t v44 = byte_1EBCEFEB7 & 0x7F;
        }
        else {
          size_t v44 = qword_1EBCEFEA8;
        }
        if (byte_1EBCEFEB7 >= 0) {
          uint64_t v45 = &qword_1EBCEFEA0;
        }
        else {
          uint64_t v45 = (uint64_t *)qword_1EBCEFEA0;
        }
        llvm::sys::findProgramByName(v45, v44, 0, 0, (std::string *)&qword_1EBCEFBF8);
        __cxa_atexit((void (*)(void *))sub_1CD745040, &qword_1EBCEFBF8, &dword_1CB82C000);
        __cxa_guard_release(&qword_1EBCEFBD0);
      }
      if (byte_1EBCEFC10)
      {
        size_t v22 = (char *)operator new(0x20uLL);
        *(void *)a1 = v22;
        *(_OWORD *)(a1 + 8) = xmmword_1CDB15B60;
        strcpy(v22, "Unable to find diff executable.");
        return;
      }
      *(void *)uint64_t v80 = "--old-line-format={0}";
      *(void *)&v80[8] = 21;
      *(void *)&v80[16] = &v84;
      uint64_t v81 = 1;
      unint64_t v82 = &unk_1F2617F90;
      uint64_t v83 = v53;
      unint64_t v84 = &v82;
      unint64_t v95 = &v97;
      long long v96 = xmmword_1CFAC3020;
      LODWORD(v88) = 0;
      char v91 = 0;
      uint64_t v92 = 0;
      uint64_t v94 = &v95;
      int v93 = 0;
      int v87 = &unk_1F2646FA8;
      *((void *)&v88 + sub_1CD7485C0(this + 1) = 0;
      uint64_t v90 = 0;
      uint64_t v89 = 0;
      sub_1CD862C68((uint64_t)v80, (llvm::raw_ostream *)&v87);
      int v87 = &unk_1F2646B98;
      if (v93 == 1 && *((void *)&v88 + 1)) {
        MEMORY[0x1D25D9CB0](*((void *)&v88 + 1), 0x1000C8077774924);
      }
      size_t v64 = "--new-line-format={0}";
      uint64_t v65 = 21;
      unint64_t v66 = &v70;
      uint64_t v67 = 1;
      std::string::size_type v68 = (const char *)&unk_1F2617F90;
      uint64_t v69 = (uint64_t)v52;
      uint64_t v70 = &v68;
      int v87 = &v89;
      long long v88 = xmmword_1CFAC3020;
      *(_DWORD *)&v80[8] = 0;
      LOBYTE(v83) = 0;
      unint64_t v84 = 0;
      int v86 = &v87;
      int v85 = 0;
      *(void *)uint64_t v80 = &unk_1F2646FA8;
      *(void *)&v80[16] = 0;
      uint64_t v81 = 0;
      unint64_t v82 = 0;
      sub_1CD862C68((uint64_t)&v64, (llvm::raw_ostream *)v80);
      *(void *)uint64_t v80 = &unk_1F2646B98;
      if (v85 == 1 && *(void *)&v80[16]) {
        MEMORY[0x1D25D9CB0](*(void *)&v80[16], 0x1000C8077774924);
      }
      *(void *)&long long v57 = "--unchanged-line-format={0}";
      *((void *)&v57 + sub_1CD7485C0(this + 1) = 27;
      int v58 = &v62;
      uint64_t v59 = 1;
      std::string::size_type v60 = &unk_1F2617F90;
      size_t v61 = v51;
      std::string::size_type v62 = &v60;
      *(void *)uint64_t v80 = &v81;
      *(_OWORD *)&v80[8] = xmmword_1CFAC3020;
      LODWORD(v65) = 0;
      LOBYTE(v69) = 0;
      uint64_t v70 = 0;
      uint64_t v72 = v80;
      LODWORD(v7sub_1CD7485C0(this + 1) = 0;
      size_t v64 = (const char *)&unk_1F2646FA8;
      unint64_t v66 = 0;
      uint64_t v67 = 0;
      std::string::size_type v68 = 0;
      sub_1CD862C68((uint64_t)&v57, (llvm::raw_ostream *)&v64);
      size_t v64 = (const char *)&unk_1F2646B98;
      if (v71 == 1 && v66) {
        MEMORY[0x1D25D9CB0](v66, 0x1000C8077774924);
      }
      std::string v24 = &qword_1EBCEFEA0;
      if (byte_1EBCEFEB7 < 0) {
        std::string v24 = (uint64_t *)qword_1EBCEFEA0;
      }
      uint64_t v25 = byte_1EBCEFEB7 & 0x7F;
      if (byte_1EBCEFEB7 < 0) {
        uint64_t v25 = qword_1EBCEFEA8;
      }
      size_t v64 = (const char *)v24;
      uint64_t v65 = v25;
      unint64_t v66 = (const char ***)"-w";
      uint64_t v67 = 2;
      std::string::size_type v68 = "-d";
      uint64_t v69 = 2;
      uint64_t v70 = (const char **)v95;
      uint64_t v71 = v96;
      uint64_t v72 = v87;
      uint64_t v73 = v88;
      uint64_t v74 = *(void *)v80;
      uint64_t v75 = *(void *)&v80[8];
      if (byte_1EBCEFC57 >= 0) {
        std::string v26 = &qword_1EBCEFC40;
      }
      else {
        std::string v26 = (uint64_t *)qword_1EBCEFC40;
      }
      uint64_t v27 = byte_1EBCEFC57 & 0x7F;
      if (byte_1EBCEFC57 < 0) {
        uint64_t v27 = qword_1EBCEFC48;
      }
      uint64_t v76 = v26;
      uint64_t v77 = v27;
      if (byte_1EBCEFC6F >= 0) {
        BOOL v28 = &qword_1EBCEFC58;
      }
      else {
        BOOL v28 = (uint64_t *)qword_1EBCEFC58;
      }
      uint64_t v29 = byte_1EBCEFC6F & 0x7F;
      if (byte_1EBCEFC6F < 0) {
        uint64_t v29 = qword_1EBCEFC60;
      }
      BOOL v78 = v28;
      uint64_t v79 = v29;
      LOBYTE(v57) = 0;
      LOBYTE(v58) = 0;
      if (byte_1EBCEFC87 >= 0) {
        std::string::size_type v30 = &qword_1EBCEFC70;
      }
      else {
        std::string::size_type v30 = (uint64_t *)qword_1EBCEFC70;
      }
      uint64_t v31 = byte_1EBCEFC87 & 0x7F;
      if (byte_1EBCEFC87 < 0) {
        uint64_t v31 = qword_1EBCEFC78;
      }
      uint64_t v59 = (uint64_t)v30;
      std::string::size_type v60 = (void *)v31;
      LOBYTE(v6sub_1CD7485C0(this + 1) = 1;
      LOBYTE(v62) = 0;
      char v63 = 0;
      if (byte_1EBCEFC0F >= 0) {
        std::string::size_type v32 = byte_1EBCEFC0F & 0x7F;
      }
      else {
        std::string::size_type v32 = unk_1EBCEFC00;
      }
      LOBYTE(v49) = 0;
      if (byte_1EBCEFC0F >= 0) {
        int v33 = &qword_1EBCEFBF8;
      }
      else {
        int v33 = (uint64_t *)qword_1EBCEFBF8;
      }
      char v50 = 0;
      if ((llvm::sys::ExecuteAndWait(v33, v32, (uint64_t)&v64, 8, &v49, &v57, 3, 0, 0, 0, 0, 0) & 0x80000000) != 0)
      {
        uint64_t v38 = (char *)operator new(0x20uLL);
        *(void *)a1 = v38;
        *(_OWORD *)(a1 + 8) = xmmword_1CDB15B50;
        strcpy(v38, "Error executing system diff.");
      }
      else
      {
        *(void *)((char *)v56 + 7) = 0;
        v56[0] = 0;
        __int16 v48 = 260;
        std::string::size_type v46 = &qword_1EBCEFC70;
        sub_1CD096690((unsigned __int8 *)&v46, (llvm::WritableMemoryBuffer *)0xFFFFFFFFFFFFFFFFLL, 0, 0, 1, 0, (uint64_t)&v54);
        if ((v55 & 1) != 0 || !v54)
        {
          LOBYTE(v34) = 0;
          int v39 = 0;
          strcpy((char *)a1, "Unable to read result.");
          *(unsigned char *)(a1 + 23) = 22;
        }
        else
        {
          uint64_t v34 = (unsigned char *)v54[1];
          if (v34)
          {
            int v35 = (unsigned char *)v54[2];
            size_t v36 = v35 - v34;
            if ((unint64_t)(v35 - v34) >= 0x7FFFFFFFFFFFFFF8) {
              abort();
            }
            if (v36 >= 0x17)
            {
              uint64_t v40 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v36 | 7) != 0x17) {
                uint64_t v40 = v36 | 7;
              }
              uint64_t v41 = v40 + 1;
              unsigned int v37 = (uint64_t **)operator new(v40 + 1);
              *(void *)&long long v47 = v36;
              *((void *)&v47 + sub_1CD7485C0(this + 1) = v41 | 0x8000000000000000;
              std::string::size_type v46 = (uint64_t *)v37;
            }
            else
            {
              HIBYTE(v47) = (_BYTE)v35 - (_BYTE)v34;
              unsigned int v37 = &v46;
              if (v35 == v34)
              {
LABEL_69:
                *((unsigned char *)v37 + v36) = 0;
                int v39 = v46;
                LOBYTE(v34) = HIBYTE(v47);
                goto LABEL_70;
              }
            }
            memmove(v37, v34, v36);
            goto LABEL_69;
          }
          int v39 = 0;
          std::string::size_type v46 = 0;
          long long v47 = 0uLL;
LABEL_70:
          uint64_t v42 = 0;
          v56[0] = v47;
          *(void *)((char *)v56 + 7) = *(void *)((char *)&v47 + 7);
          while (1)
          {
            __int16 v48 = 260;
            std::string::size_type v46 = (uint64_t *)((char *)&unk_1EBCEFBB8 + v42 + 136);
            if (llvm::sys::fs::remove((llvm::sys::fs *)&v46, (const llvm::Twine *)1)) {
              break;
            }
            v42 += 24;
            if (v42 == 72)
            {
              *(void *)a1 = v39;
              *(void *)(a1 + 8) = v56[0];
              *(void *)(a1 + 15) = *(void *)((char *)v56 + 7);
              *(unsigned char *)(a1 + 23) = (_BYTE)v34;
              v56[0] = 0;
              *(void *)((char *)v56 + 7) = 0;
              LOBYTE(v34) = 0;
              int v39 = 0;
              goto LABEL_74;
            }
          }
          char v43 = (char *)operator new(0x28uLL);
          *(void *)a1 = v43;
          *(_OWORD *)(a1 + 8) = xmmword_1CFAC3CC0;
          strcpy(v43, "Unable to remove temporary file.");
        }
LABEL_74:
        if ((v55 & 1) == 0 && v54) {
          (*(void (**)(void *))(*v54 + 8))(v54);
        }
        if ((v34 & 0x80) != 0) {
          operator delete(v39);
        }
      }
      if (*(uint64_t **)v80 != &v81) {
        free(*(void **)v80);
      }
      if (v87 != &v89) {
        free(v87);
      }
      if (v95 != &v97) {
        free(v95);
      }
      return;
    }
    LOWORD(__dst) = 260;
    unint64_t v95 = (char *)&unk_1EBCEFBB8 + v13 + 136;
    if (llvm::sys::fs::openFile((unsigned __int8 *)&v95, i, 0, 2, 0, 438))
    {
      std::string::size_type v21 = (char *)operator new(0x30uLL);
      *(void *)a1 = v21;
      *(_OWORD *)(a1 + 8) = xmmword_1CD96D860;
      strcpy(v21, "Unable to open temporary file for writing.");
      return;
    }
    llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)&v95, *i, 1, 0, 0);
    if (*i == -1)
    {
      uint64_t v23 = (char *)operator new(0x20uLL);
      *(void *)a1 = v23;
      *(_OWORD *)(a1 + 8) = xmmword_1CDB15B60;
      strcpy(v23, "Error opening file for writing.");
      llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)&v95);
      return;
    }
    std::string::size_type v19 = (const void *)*(v14 - 1);
    size_t v20 = *v14;
    if (*v14 <= v97 - (uint64_t)__dst)
    {
      if (v20)
      {
        memcpy(__dst, v19, *v14);
        std::string __dst = (char *)__dst + v20;
      }
    }
    else
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v95, (const char *)v19, *v14);
    }
    llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)&v95);
    v13 += 24;
    v14 += 2;
  }
}

void sub_1CCCD0D28(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  uint64_t v7 = *(void **)a2;
  unint64_t v6 = *(void *)(a2 + 8);
  *(_DWORD *)uint64_t v10 = *(_DWORD *)(a2 + 16);
  *(_DWORD *)&void v10[3] = *(_DWORD *)(a2 + 19);
  int v8 = *(char *)(a2 + 23);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_OWORD *)a1 = *a4;
  uint64_t v9 = a1 + 16;
  if (v8 < 0)
  {
    sub_1CB8BDF7C(v9, v7, v6);
    *(void *)(a1 + 40) = a3;
    operator delete(v7);
  }
  else
  {
    *(void *)(a1 + 16) = v7;
    *(void *)(a1 + 24) = v6;
    *(_DWORD *)(a1 + 32) = *(_DWORD *)v10;
    *(_DWORD *)(a1 + 35) = *(_DWORD *)&v10[3];
    *(unsigned char *)(a1 + 39) = v8;
    *(void *)(a1 + 40) = a3;
  }
}

void sub_1CCCD0DD8(llvm::raw_ostream **a1, int8x8_t *a2, int a3, uint64_t a4)
{
  unint64_t v4 = *(void *)(a4 + 16);
  if (v4)
  {
    LODWORD(v6) = a3;
    sub_1CCCD1168((uint64_t)&__p, a2, *(void *)(a4 + 16));
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (size) {
      unint64_t v6 = v6;
    }
    else {
      unint64_t v6 = 0xFFFFFFFFLL;
    }
    uint64_t v10 = sub_1CCCD11D4(a2, *(void *)(a4 + 16));
    sub_1CCCD1070(&__p, *(void **)v10, *(void *)(v10 + 8));
    if ((int)v6 <= 64)
    {
      int v11 = *a1;
      uint64_t v12 = *((void *)*a1 + 4);
      if ((unint64_t)(*((void *)*a1 + 3) - v12) > 4)
      {
        *(unsigned char *)(v12 + 4) = 101;
        *(_DWORD *)uint64_t v12 = 1685016073;
        *((void *)v11 + 4) += 5;
      }
      else
      {
        int v11 = llvm::raw_ostream::write(v11, "\tNode", 5uLL);
      }
      llvm::write_hex(v11, (unint64_t)a2, 3, 0, 0);
      if ((v6 & 0x80000000) == 0)
      {
        uint64_t v13 = *a1;
        std::string::size_type v14 = (_WORD *)*((void *)*a1 + 4);
        if (*((void *)*a1 + 3) - (void)v14 > 1uLL)
        {
          *std::string::size_type v14 = 29498;
          *((void *)v13 + 4) += 2;
        }
        else
        {
          uint64_t v13 = llvm::raw_ostream::write(v13, ":s", 2uLL);
        }
        sub_1CD098D14(v13, v6, 0, 0, 0);
      }
      char v15 = *a1;
      uint64_t v16 = (void *)*((void *)*a1 + 4);
      if (*((void *)*a1 + 3) - (void)v16 > 7uLL)
      {
        *uint64_t v16 = 0x65646F4E203E2D20;
        *((void *)v15 + 4) += 8;
      }
      else
      {
        char v15 = llvm::raw_ostream::write(v15, " -> Node", 8uLL);
      }
      llvm::write_hex(v15, v4, 3, 0, 0);
      int v17 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        size_t v18 = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
      }
      else {
        size_t v18 = __p.__r_.__value_.__l.__size_;
      }
      if (v18)
      {
        std::string::size_type v19 = *a1;
        size_t v20 = (unsigned char *)*((void *)*a1 + 4);
        if (*((unsigned char **)*a1 + 3) == v20)
        {
          std::string::size_type v19 = llvm::raw_ostream::write(v19, "[", 1uLL);
        }
        else
        {
          *size_t v20 = 91;
          ++*((void *)v19 + 4);
        }
        if (v17 >= 0) {
          p_p = &__p;
        }
        else {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        size_t v22 = llvm::raw_ostream::write(v19, (const char *)p_p, v18);
        uint64_t v23 = (unsigned char *)*((void *)v22 + 4);
        if (*((unsigned char **)v22 + 3) == v23)
        {
          llvm::raw_ostream::write(v22, "]", 1uLL);
        }
        else
        {
          *uint64_t v23 = 93;
          ++*((void *)v22 + 4);
        }
      }
      std::string v24 = *a1;
      uint64_t v25 = (_WORD *)*((void *)*a1 + 4);
      if (*((void *)*a1 + 3) - (void)v25 > 1uLL)
      {
        _WORD *v25 = 2619;
        *((void *)v24 + 4) += 2;
      }
      else
      {
        llvm::raw_ostream::write(v24, ";\n", 2uLL);
      }
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
}

void sub_1CCCD1070(std::string *a1, void *__src, size_t __len)
{
  if (!__src)
  {
    memset(&__dst, 0, sizeof(__dst));
    goto LABEL_12;
  }
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    p_dst = (std::string *)operator new(v7 + 1);
    __dst.__r_.__value_.__l.__size_ = __len;
    __dst.__r_.__value_.__r.__words[2] = v8 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
  }
  else
  {
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = __len;
    p_dst = &__dst;
    if (!__len) {
      goto LABEL_11;
    }
  }
  memmove(p_dst, __src, __len);
LABEL_11:
  p_dst->__r_.__value_.__s.__data_[__len] = 0;
LABEL_12:
  uint64_t v9 = std::string::insert(&__dst, 0, "color=");
  *a1 = *v9;
  v9->__r_.__value_.__r.__words[0] = 0;
  v9->__r_.__value_.__l.__size_ = 0;
  v9->__r_.__value_.__r.__words[2] = 0;
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
}

void *sub_1CCCD1168(uint64_t a1, int8x8_t *a2, unint64_t a3)
{
  __n128 result = (void *)sub_1CCCD11D4(a2, a3);
  if (*((char *)result + 39) < 0)
  {
    unint64_t v6 = (const void *)result[2];
    unint64_t v7 = result[3];
    return sub_1CB8BDF7C(a1, v6, v7);
  }
  else
  {
    long long v5 = *((_OWORD *)result + 1);
    *(void *)(a1 + 16) = result[4];
    *(_OWORD *)a1 = v5;
  }
  return result;
}

uint64_t sub_1CCCD11D4(int8x8_t *a1, unint64_t a2)
{
  unint64_t v2 = 0x9DDFEA08EB382D69 * (((((a2 >> 3) & 0x3FFFFFF) << 6) | 8) ^ HIDWORD(a2));
  unint64_t v3 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v2 >> 47) ^ v2);
  unint64_t v4 = 0x9DDFEA08EB382D69 * (v3 ^ (v3 >> 47));
  int8x8_t v5 = a1[17];
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v5);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = v4;
    if (v4 >= *(void *)&v5) {
      unint64_t v7 = v4 % *(void *)&v5;
    }
  }
  else
  {
    unint64_t v7 = (*(void *)&v5 - 1) & v4;
  }
  size_t v8 = *(void **)(*(void *)&a1[16] + 8 * v7);
  do
  {
    do
      size_t v8 = (void *)*v8;
    while (v4 != v8[1]);
  }
  while (v8[2] != a2);
  return v8[3];
}

void sub_1CCCD127C(uint64_t a1, unsigned int a2)
{
  if (a2)
  {
    uint64_t v2 = a1;
    uint64_t v3 = a1 + 40 * a2;
    do
    {
      unint64_t v4 = *(unsigned __int8 **)v2;
      size_t v5 = *(void *)(v2 + 8);
      int v6 = *(_DWORD *)(v2 + 16);
      *(void *)&long long v10 = *(void *)v2;
      *((void *)&v10 + sub_1CD7485C0(this + 1) = v5;
      long long v11 = *(_OWORD *)(v2 + 24);
      uint64_t v12 = &unk_1F263BFF0;
      char v14 = 1;
      int v13 = v6;
      if (qword_1EBD0A748 >= HIDWORD(qword_1EBD0A748))
      {
        if (qword_1EBD0A740 <= (unint64_t)&v10
          && qword_1EBD0A740 + 48 * (unint64_t)qword_1EBD0A748 > (unint64_t)&v10)
        {
          sub_1CD747808();
        }
        sub_1CD747808();
      }
      uint64_t v7 = qword_1EBD0A740 + 48 * qword_1EBD0A748;
      long long v8 = v11;
      *(_OWORD *)uint64_t v7 = v10;
      *(_OWORD *)(v7 + 16) = v8;
      *(void *)(v7 + 32) = &unk_1F263C010;
      int v9 = v13;
      *(unsigned char *)(v7 + 44) = v14;
      *(_DWORD *)(v7 + 40) = v9;
      *(void *)(v7 + 32) = &unk_1F263BFF0;
      LODWORD(qword_1EBD0A748) = qword_1EBD0A748 + 1;
      llvm::cl::AddLiteralOption(qword_1EBD0A738, v4, v5);
      v2 += 40;
    }
    while (v2 != v3);
  }
}

uint64_t sub_1CCCD1414(llvm **a1, char *a2, size_t a3, uint64_t *a4)
{
  uint64_t v6 = *a4;
  *a4 = 0;
  uint64_t v7 = *a1;
  if (v6) {
    (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v6 + 16))(&v9, v6);
  }
  else {
    uint64_t v9 = 0;
  }
  llvm::PrintIRInstrumentation::printBeforePass(v7, a2, a3, (uint64_t)&v9);
  uint64_t result = v9;
  uint64_t v9 = 0;
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  if (v6) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  return result;
}

uint64_t sub_1CCCD14FC(llvm **a1, void *a2, size_t a3, uint64_t *a4)
{
  uint64_t v6 = *a4;
  *a4 = 0;
  uint64_t v7 = *a1;
  if (v6) {
    (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v6 + 16))(&v9, v6);
  }
  else {
    uint64_t v9 = 0;
  }
  llvm::PrintIRInstrumentation::printAfterPass(v7, a2, a3, &v9);
  uint64_t result = v9;
  uint64_t v9 = 0;
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  if (v6) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  return result;
}

void sub_1CCCD15E4(uint64_t **a1, unsigned __int8 *a2, size_t a3)
{
}

uint64_t sub_1CCCD15EC(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result != a2)
  {
    uint64_t v5 = result;
    do
    {
      *(void *)(a3 + 24) = 0;
      uint64_t v6 = *(void *)(v5 + 24);
      *(void *)(a3 + 24) = v6;
      if (*(void *)(v5 + 24) >= 8uLL)
      {
        if ((v6 & 2) != 0 && (v6 & 4) != 0)
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))((v6 & 0xFFFFFFFFFFFFFFF8) + 8))(a3, v5);
        }
        else
        {
          long long v7 = *(_OWORD *)v5;
          *(void *)(a3 + 16) = *(void *)(v5 + 16);
          *(_OWORD *)a3 = v7;
        }
        *(void *)(v5 + 24) = 0;
      }
      v5 += 32;
      a3 += 32;
    }
    while (v5 != a2);
  }
  return result;
}

uint64_t sub_1CCCD1684(unsigned char **a1, const void *a2, size_t a3, uint64_t *a4)
{
  uint64_t v6 = *a4;
  *a4 = 0;
  long long v7 = *a1;
  if (v6) {
    (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v6 + 16))(&v11, v6);
  }
  else {
    uint64_t v11 = 0;
  }
  shouldRuuint64_t n = llvm::OptNoneInstrumentation::shouldRun(v7, a2, a3, &v11);
  uint64_t v9 = v11;
  uint64_t v11 = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  return shouldRun;
}

BOOL sub_1CCCD1774(uint64_t a1, void *a2, size_t a3, uint64_t *a4)
{
  uint64_t v6 = *a4;
  *a4 = 0;
  if (sub_1CCCC6BBC((char *)a2, a3))
  {
    BOOL v7 = 1;
  }
  else
  {
    if (!atomic_load_explicit(&llvm::OptBisector, memory_order_acquire)) {
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&llvm::OptBisector, (void *(*)(void))sub_1CD5CC960, (void (*)(void *))sub_1CD5CC9B4);
    }
    uint64_t v9 = (llvm *)llvm::OptBisector;
    if (v6) {
      (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v6 + 16))(&v13, v6);
    }
    else {
      uint64_t v13 = 0;
    }
    sub_1CCCC67F8((char *)__p, &v13);
    if (v15 >= 0) {
      long long v10 = __p;
    }
    else {
      long long v10 = (void **)__p[0];
    }
    if (v15 >= 0) {
      size_t v11 = v15 & 0x7F;
    }
    else {
      size_t v11 = (size_t)__p[1];
    }
    BOOL v7 = llvm::OptBisect::checkPass(v9, a2, a3, v10, v11);
    if (v15 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v12 = v13;
    uint64_t v13 = 0;
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    }
  }
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  return v7;
}

char *sub_1CCCD18F8(char **a1, const char *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  uint64_t v4 = (v3 - *a1) >> 4;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 60) {
    abort();
  }
  uint64_t v7 = a1[2] - v2;
  if (v7 >> 3 > v5) {
    unint64_t v5 = v7 >> 3;
  }
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v8 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v8 = v5;
  }
  if (v8 >> 60) {
    sub_1CB833614();
  }
  long long v10 = (char *)operator new(16 * v8);
  size_t v11 = (const char **)&v10[16 * v4];
  uint64_t v12 = &v10[16 * v8];
  *size_t v11 = a2;
  v11[1] = (const char *)strlen(a2);
  uint64_t v13 = (char *)(v11 + 2);
  if (v3 == v2)
  {
    char v14 = v11;
  }
  else
  {
    do
    {
      char v14 = v11 - 2;
      *((_OWORD *)v11 - sub_1CD7485C0(this + 1) = *((_OWORD *)v3 - 1);
      v3 -= 16;
      v11 -= 2;
    }
    while (v3 != v2);
  }
  *a1 = (char *)v14;
  a1[1] = v13;
  a1[2] = v12;
  if (v2) {
    operator delete(v2);
  }
  return v13;
}

uint64_t sub_1CCCD19EC(llvm::PrintPassInstrumentation **a1, const void *a2, size_t a3, uint64_t *a4)
{
  uint64_t v6 = *a4;
  *a4 = 0;
  uint64_t v7 = llvm::PrintPassInstrumentation::print(*a1);
  unint64_t v8 = v7;
  uint64_t v9 = (void *)*((void *)v7 + 4);
  if (*((void *)v7 + 3) - (void)v9 > 0xEuLL)
  {
    qmemcpy(v9, "Skipping pass: ", 15);
    long long v10 = (_DWORD *)(*((void *)v7 + 4) + 15);
    *((void *)v8 + 4) = v10;
  }
  else
  {
    llvm::raw_ostream::write(v7, "Skipping pass: ", 0xFuLL);
    long long v10 = (_DWORD *)*((void *)v8 + 4);
  }
  if (a3 <= *((void *)v8 + 3) - (void)v10)
  {
    if (a3)
    {
      memcpy(v10, a2, a3);
      long long v10 = (_DWORD *)(*((void *)v8 + 4) + a3);
      *((void *)v8 + 4) = v10;
    }
  }
  else
  {
    llvm::raw_ostream::write(v8, (const char *)a2, a3);
    long long v10 = (_DWORD *)*((void *)v8 + 4);
  }
  if (*((void *)v8 + 3) - (void)v10 > 3uLL)
  {
    _DWORD *v10 = 544108320;
    *((void *)v8 + 4) += 4;
    if (v6) {
      goto LABEL_9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v8, " on ", 4uLL);
    if (v6)
    {
LABEL_9:
      (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v6 + 16))(&v15, v6);
      goto LABEL_13;
    }
  }
  uint64_t v15 = 0;
LABEL_13:
  sub_1CCCC67F8((char *)__p, &v15);
  if (v17 >= 0) {
    size_t v11 = __p;
  }
  else {
    size_t v11 = (void **)__p[0];
  }
  if (v17 >= 0) {
    size_t v12 = v17 & 0x7F;
  }
  else {
    size_t v12 = (size_t)__p[1];
  }
  llvm::raw_ostream::write(v8, (const char *)v11, v12);
  uint64_t v13 = (unsigned char *)*((void *)v8 + 4);
  if (*((unsigned char **)v8 + 3) == v13)
  {
    llvm::raw_ostream::write(v8, "\n", 1uLL);
  }
  else
  {
    unsigned char *v13 = 10;
    ++*((void *)v8 + 4);
  }
  if (v17 < 0) {
    operator delete(__p[0]);
  }
  uint64_t result = v15;
  uint64_t v15 = 0;
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  if (v6) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  return result;
}

__n128 sub_1CCCD1C18(void *a1, uint64_t a2)
{
  *a1 = *(void *)a2;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  __n128 result = *(__n128 *)(a2 + 8);
  *(__n128 *)(a1 + sub_1CD7485C0(this + 1) = result;
  a1[3] = *(void *)(a2 + 24);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  return result;
}

void sub_1CCCD1C40(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
}

uint64_t sub_1CCCD1C58(uint64_t a1, char *__s, size_t __n, uint64_t *a4)
{
  uint64_t v6 = *a4;
  *a4 = 0;
  uint64_t v7 = *(llvm::PrintPassInstrumentation **)a1;
  uint64_t result = llvm::isSpecialPass(__s, __n, (uint64_t *)(a1 + 8));
  if (result)
  {
    if (!v6) {
      return result;
    }
    return (*(uint64_t (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v9 = llvm::PrintPassInstrumentation::print(v7);
  long long v10 = v9;
  size_t v11 = (void *)*((void *)v9 + 4);
  if (*((void *)v9 + 3) - (void)v11 > 0xDuLL)
  {
    qmemcpy(v11, "Running pass: ", 14);
    size_t v12 = (_DWORD *)(*((void *)v9 + 4) + 14);
    *((void *)v10 + 4) = v12;
  }
  else
  {
    llvm::raw_ostream::write(v9, "Running pass: ", 0xEuLL);
    size_t v12 = (_DWORD *)*((void *)v10 + 4);
  }
  if (__n <= *((void *)v10 + 3) - (void)v12)
  {
    if (__n)
    {
      memcpy(v12, __s, __n);
      size_t v12 = (_DWORD *)(*((void *)v10 + 4) + __n);
      *((void *)v10 + 4) = v12;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, __s, __n);
    size_t v12 = (_DWORD *)*((void *)v10 + 4);
  }
  if (*((void *)v10 + 3) - (void)v12 > 3uLL)
  {
    *size_t v12 = 544108320;
    *((void *)v10 + 4) += 4;
    if (v6) {
      goto LABEL_13;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, " on ", 4uLL);
    if (v6)
    {
LABEL_13:
      (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v6 + 16))(&v16, v6);
      goto LABEL_17;
    }
  }
  uint64_t v16 = 0;
LABEL_17:
  sub_1CCCC67F8((char *)__p, &v16);
  if (v18 >= 0) {
    uint64_t v13 = __p;
  }
  else {
    uint64_t v13 = (void **)__p[0];
  }
  if (v18 >= 0) {
    size_t v14 = v18 & 0x7F;
  }
  else {
    size_t v14 = (size_t)__p[1];
  }
  llvm::raw_ostream::write(v10, (const char *)v13, v14);
  uint64_t v15 = (unsigned char *)*((void *)v10 + 4);
  if (*((unsigned char **)v10 + 3) == v15)
  {
    llvm::raw_ostream::write(v10, "\n", 1uLL);
  }
  else
  {
    unsigned char *v15 = 10;
    ++*((void *)v10 + 4);
  }
  if (v18 < 0) {
    operator delete(__p[0]);
  }
  uint64_t result = v16;
  uint64_t v16 = 0;
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  *((_DWORD *)v7 + 1) += 2;
  if (v6) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  return result;
}

__n128 sub_1CCCD1EB8(void *a1, uint64_t a2)
{
  *a1 = *(void *)a2;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  __n128 result = *(__n128 *)(a2 + 8);
  *(__n128 *)(a1 + sub_1CD7485C0(this + 1) = result;
  a1[3] = *(void *)(a2 + 24);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  return result;
}

void sub_1CCCD1EE0(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
}

uint64_t sub_1CCCD1EF8(uint64_t *a1, char *__s, size_t __n, uint64_t *a4)
{
  uint64_t v5 = *a4;
  *a4 = 0;
  uint64_t result = llvm::isSpecialPass(__s, __n, a1 + 1);
  if ((result & 1) == 0) {
    *(_DWORD *)(*a1 + 4) -= 2;
  }
  if (v5)
  {
    uint64_t v7 = *(uint64_t (**)(uint64_t))(*(void *)v5 + 8);
    return v7(v5);
  }
  return result;
}

__n128 sub_1CCCD1F8C(void *a1, uint64_t a2)
{
  *a1 = *(void *)a2;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  __n128 result = *(__n128 *)(a2 + 8);
  *(__n128 *)(a1 + sub_1CD7485C0(this + 1) = result;
  a1[3] = *(void *)(a2 + 24);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  return result;
}

void sub_1CCCD1FB4(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
}

void sub_1CCCD1FCC()
{
  sub_1CD7487AC(&v0);
}

__n128 sub_1CCCD2064(void *a1, uint64_t a2)
{
  *a1 = *(void *)a2;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  __n128 result = *(__n128 *)(a2 + 8);
  *(__n128 *)(a1 + sub_1CD7485C0(this + 1) = result;
  a1[3] = *(void *)(a2 + 24);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  return result;
}

void sub_1CCCD208C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
}

uint64_t sub_1CCCD20A4(llvm::PrintPassInstrumentation **a1, const void *a2, size_t a3, uint64_t *a4)
{
  uint64_t v6 = *a4;
  *a4 = 0;
  uint64_t v7 = *a1;
  unint64_t v8 = llvm::PrintPassInstrumentation::print(*a1);
  uint64_t v9 = v8;
  uint64_t v10 = *((void *)v8 + 4);
  if ((unint64_t)(*((void *)v8 + 3) - v10) > 0x11)
  {
    *(_WORD *)(v10 + 16) = 8250;
    *(_OWORD *)uint64_t v10 = *(_OWORD *)"Running analysis: ";
    size_t v11 = (_DWORD *)(*((void *)v8 + 4) + 18);
    *((void *)v9 + 4) = v11;
  }
  else
  {
    llvm::raw_ostream::write(v8, "Running analysis: ", 0x12uLL);
    size_t v11 = (_DWORD *)*((void *)v9 + 4);
  }
  if (a3 <= *((void *)v9 + 3) - (void)v11)
  {
    if (a3)
    {
      memcpy(v11, a2, a3);
      size_t v11 = (_DWORD *)(*((void *)v9 + 4) + a3);
      *((void *)v9 + 4) = v11;
    }
  }
  else
  {
    llvm::raw_ostream::write(v9, (const char *)a2, a3);
    size_t v11 = (_DWORD *)*((void *)v9 + 4);
  }
  if (*((void *)v9 + 3) - (void)v11 > 3uLL)
  {
    *size_t v11 = 544108320;
    *((void *)v9 + 4) += 4;
    if (v6) {
      goto LABEL_9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v9, " on ", 4uLL);
    if (v6)
    {
LABEL_9:
      (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v6 + 16))(&v16, v6);
      goto LABEL_13;
    }
  }
  uint64_t v16 = 0;
LABEL_13:
  sub_1CCCC67F8((char *)__p, &v16);
  if (v18 >= 0) {
    size_t v12 = __p;
  }
  else {
    size_t v12 = (void **)__p[0];
  }
  if (v18 >= 0) {
    size_t v13 = v18 & 0x7F;
  }
  else {
    size_t v13 = (size_t)__p[1];
  }
  llvm::raw_ostream::write(v9, (const char *)v12, v13);
  size_t v14 = (unsigned char *)*((void *)v9 + 4);
  if (*((unsigned char **)v9 + 3) == v14)
  {
    llvm::raw_ostream::write(v9, "\n", 1uLL);
  }
  else
  {
    *size_t v14 = 10;
    ++*((void *)v9 + 4);
  }
  if (v18 < 0) {
    operator delete(__p[0]);
  }
  uint64_t result = v16;
  uint64_t v16 = 0;
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  *((_DWORD *)v7 + 1) += 2;
  if (v6) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  return result;
}

uint64_t sub_1CCCD22E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t result = *a4;
  *a4 = 0;
  *(_DWORD *)(*(void *)a1 + 4) -= 2;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1CCCD2330(llvm::PrintPassInstrumentation **a1, const void *a2, size_t a3, uint64_t *a4)
{
  uint64_t v6 = *a4;
  *a4 = 0;
  uint64_t v7 = llvm::PrintPassInstrumentation::print(*a1);
  unint64_t v8 = v7;
  uint64_t v9 = (void *)*((void *)v7 + 4);
  if (*((void *)v7 + 3) - (void)v9 > 0x16uLL)
  {
    qmemcpy(v9, "Invalidating analysis: ", 23);
    uint64_t v10 = (_DWORD *)(*((void *)v7 + 4) + 23);
    *((void *)v8 + 4) = v10;
  }
  else
  {
    llvm::raw_ostream::write(v7, "Invalidating analysis: ", 0x17uLL);
    uint64_t v10 = (_DWORD *)*((void *)v8 + 4);
  }
  if (a3 <= *((void *)v8 + 3) - (void)v10)
  {
    if (a3)
    {
      memcpy(v10, a2, a3);
      uint64_t v10 = (_DWORD *)(*((void *)v8 + 4) + a3);
      *((void *)v8 + 4) = v10;
    }
  }
  else
  {
    llvm::raw_ostream::write(v8, (const char *)a2, a3);
    uint64_t v10 = (_DWORD *)*((void *)v8 + 4);
  }
  if (*((void *)v8 + 3) - (void)v10 > 3uLL)
  {
    _DWORD *v10 = 544108320;
    *((void *)v8 + 4) += 4;
    if (v6) {
      goto LABEL_9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v8, " on ", 4uLL);
    if (v6)
    {
LABEL_9:
      (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v6 + 16))(&v15, v6);
      goto LABEL_13;
    }
  }
  uint64_t v15 = 0;
LABEL_13:
  sub_1CCCC67F8((char *)__p, &v15);
  if (v17 >= 0) {
    size_t v11 = __p;
  }
  else {
    size_t v11 = (void **)__p[0];
  }
  if (v17 >= 0) {
    size_t v12 = v17 & 0x7F;
  }
  else {
    size_t v12 = (size_t)__p[1];
  }
  llvm::raw_ostream::write(v8, (const char *)v11, v12);
  size_t v13 = (unsigned char *)*((void *)v8 + 4);
  if (*((unsigned char **)v8 + 3) == v13)
  {
    llvm::raw_ostream::write(v8, "\n", 1uLL);
  }
  else
  {
    unsigned char *v13 = 10;
    ++*((void *)v8 + 4);
  }
  if (v17 < 0) {
    operator delete(__p[0]);
  }
  uint64_t result = v15;
  uint64_t v15 = 0;
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  if (v6) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  return result;
}

llvm::raw_ostream *sub_1CCCD255C(llvm::PrintPassInstrumentation **a1, const void *a2, size_t a3)
{
  uint64_t v5 = llvm::PrintPassInstrumentation::print(*a1);
  uint64_t v6 = v5;
  uint64_t v7 = (void *)*((void *)v5 + 4);
  if (*((void *)v5 + 3) - (void)v7 > 0x22uLL)
  {
    qmemcpy(v7, "Clearing all analysis results for: ", 35);
    uint64_t result = (llvm::raw_ostream *)(*((void *)v5 + 4) + 35);
    *((void *)v6 + 4) = result;
  }
  else
  {
    llvm::raw_ostream::write(v5, "Clearing all analysis results for: ", 0x23uLL);
    uint64_t result = (llvm::raw_ostream *)*((void *)v6 + 4);
  }
  if (a3 <= *((void *)v6 + 3) - (void)result)
  {
    if (a3)
    {
      memcpy(result, a2, a3);
      uint64_t result = (llvm::raw_ostream *)(*((void *)v6 + 4) + a3);
      *((void *)v6 + 4) = result;
    }
  }
  else
  {
    llvm::raw_ostream::write(v6, (const char *)a2, a3);
    uint64_t result = (llvm::raw_ostream *)*((void *)v6 + 4);
  }
  if (*((llvm::raw_ostream **)v6 + 3) == result)
  {
    return llvm::raw_ostream::write(v6, "\n", 1uLL);
  }
  else
  {
    *(unsigned char *)uint64_t result = 10;
    ++*((void *)v6 + 4);
  }
  return result;
}

_DWORD *sub_1CCCD267C(_DWORD *result, int a2)
{
  uint64_t v2 = result;
  if (a2)
  {
    unint64_t v3 = (4 * a2 / 3u + 1) | ((unint64_t)(4 * a2 / 3u + 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    LODWORD(v4) = (((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8)) + 1;
    result[4] = v4;
    uint64_t result = operator new(40 * v4, (std::align_val_t)8uLL);
    *(void *)uint64_t v2 = result;
    *((void *)v2 + sub_1CD7485C0(this + 1) = 0;
    uint64_t v5 = v2[4];
    if (v5)
    {
      uint64_t v6 = 40 * v5;
      do
      {
        *(void *)uint64_t result = 0x7FFFFFFFFFFFFFFFLL;
        result += 10;
        v6 -= 40;
      }
      while (v6);
    }
  }
  else
  {
    *(void *)uint64_t result = 0;
    *((void *)result + sub_1CD7485C0(this + 1) = 0;
    result[4] = 0;
  }
  return result;
}

void sub_1CCCD2718()
{
}

void sub_1CCCD2814(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4 = *a4;
  *a4 = 0;
  if (v4)
  {
    if ((_UNKNOWN *)(*(uint64_t (**)(uint64_t))(*(void *)v4 + 24))(v4) == &llvm::Any::TypeId<llvm::Function const*>::Id)
    {
      (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
      llvm::AnalysisManager<llvm::Function>::getResultImpl();
    }
    uint64_t v5 = *(void (**)(uint64_t))(*(void *)v4 + 8);
    v5(v4);
  }
}

void sub_1CCCD28F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v5 = *a4;
  *a4 = 0;
  if (v5)
  {
    if ((_UNKNOWN *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 24))(v5) == &llvm::Any::TypeId<llvm::Function const*>::Id
      && (sub_1CBFA534C(a5, (uint64_t)&llvm::CFGAnalyses::SetKey)
       || sub_1CBFA534C(a5, (uint64_t)&llvm::AllAnalysesOn<llvm::Function>::SetKey)))
    {
      (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
      llvm::AnalysisManager<llvm::Function>::getCachedResultImpl();
    }
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
}

uint64_t sub_1CCCD2B64(unsigned char **a1, uint64_t a2, size_t a3, uint64_t **a4)
{
  uint64_t v6 = *a4;
  *a4 = 0;
  uint64_t v7 = *a1;
  uint64_t result = sub_1CCCC6BBC((char *)a2, a3);
  if ((result & 1) != 0
    || a3 == 12 && (*(void *)a2 == 0x7265696669726556 ? (BOOL v9 = *(_DWORD *)(a2 + 8) == 1936941392) : (BOOL v9 = 0), v9))
  {
    if (!v6) {
      return result;
    }
    goto LABEL_20;
  }
  if (!v6) {
    return result;
  }
  if ((_UNKNOWN *)(*(uint64_t (**)(uint64_t *))(*v6 + 24))(v6) != &llvm::Any::TypeId<llvm::Function const*>::Id
    && (_UNKNOWN *)(*(uint64_t (**)(uint64_t *))(*v6 + 24))(v6) != &llvm::Any::TypeId<llvm::Loop const*>::Id)
  {
    if ((_UNKNOWN *)(*(uint64_t (**)(uint64_t *))(*v6 + 24))(v6) != &llvm::Any::TypeId<llvm::Module const*>::Id
      && (_UNKNOWN *)(*(uint64_t (**)(uint64_t *))(*v6 + 24))(v6) != &llvm::Any::TypeId<llvm::LazyCallGraph::SCC const*>::Id)
    {
      goto LABEL_20;
    }
    uint64_t v10 = (void *)(*(uint64_t (**)(uint64_t *))(*v6 + 24))(v6);
    size_t v11 = (llvm *)(*(uint64_t (**)(uint64_t *))(*v6 + 24))(v6);
    if (v10 == &llvm::Any::TypeId<llvm::LazyCallGraph::SCC const*>::Id) {
      size_t v13 = (uint64_t *)(*(void *)(**(void **)(v6[1] + 8) + 8) + 40);
    }
    else {
      size_t v13 = v6 + 1;
    }
    uint64_t v14 = *v13;
    if (*v7)
    {
      std::string::size_type v32 = llvm::dbgs(v11);
      int v33 = v32;
      uint64_t v34 = *((void *)v32 + 4);
      if ((unint64_t)(*((void *)v32 + 3) - v34) > 0x10)
      {
        *(unsigned char *)(v34 + 16) = 32;
        *(_OWORD *)uint64_t v34 = *(_OWORD *)"Verifying module ";
        int v35 = (unsigned char *)(*((void *)v32 + 4) + 17);
        *((void *)v33 + 4) = v35;
      }
      else
      {
        llvm::raw_ostream::write(v32, "Verifying module ", 0x11uLL);
        int v35 = (unsigned char *)*((void *)v33 + 4);
      }
      char v36 = *(unsigned char *)(v14 + 191);
      if (v36 >= 0) {
        unsigned int v37 = (const void *)(v14 + 168);
      }
      else {
        unsigned int v37 = *(const void **)(v14 + 168);
      }
      if (v36 >= 0) {
        size_t v38 = v36 & 0x7F;
      }
      else {
        size_t v38 = *(void *)(v14 + 176);
      }
      if (v38 <= *((void *)v33 + 3) - (void)v35)
      {
        if (v38)
        {
          memcpy(v35, v37, v38);
          int v35 = (unsigned char *)(*((void *)v33 + 4) + v38);
          *((void *)v33 + 4) = v35;
        }
      }
      else
      {
        llvm::raw_ostream::write(v33, (const char *)v37, v38);
        int v35 = (unsigned char *)*((void *)v33 + 4);
      }
      if (*((unsigned char **)v33 + 3) == v35)
      {
        llvm::raw_ostream::write(v33, "\n", 1uLL);
      }
      else
      {
        *int v35 = 10;
        ++*((void *)v33 + 4);
      }
    }
    if (!llvm::verifyModule((llvm *)v14, 0, 0, v12)) {
      goto LABEL_20;
    }
    size_t v44 = "Broken module found, compilation aborted!";
LABEL_65:
    llvm::report_fatal_error((llvm *)v44, (const llvm::Twine *)1);
  }
  uint64_t v16 = (void *)(*(uint64_t (**)(uint64_t *))(*v6 + 24))(v6);
  char v17 = (llvm *)(*(uint64_t (**)(uint64_t *))(*v6 + 24))(v6);
  if (v16 == &llvm::Any::TypeId<llvm::Loop const*>::Id) {
    std::string::size_type v19 = (uint64_t ****)(**(void **)(v6[1] + 32) + 56);
  }
  else {
    std::string::size_type v19 = (uint64_t ****)(v6 + 1);
  }
  size_t v20 = *v19;
  if (*v7)
  {
    std::string::size_type v21 = llvm::dbgs(v17);
    size_t v22 = v21;
    uint64_t v23 = *((void *)v21 + 4);
    if ((unint64_t)(*((void *)v21 + 3) - v23) > 0x12)
    {
      *(_DWORD *)(v23 + 15) = 544108393;
      *(_OWORD *)uint64_t v23 = *(_OWORD *)"Verifying function ";
      *((void *)v21 + 4) += 19;
    }
    else
    {
      llvm::raw_ostream::write(v21, "Verifying function ", 0x13uLL);
    }
    if ((*((unsigned char *)v20 + 23) & 0x10) == 0) {
      goto LABEL_53;
    }
    uint64_t v24 = ***v20;
    uint64_t v25 = *(void *)(v24 + 152);
    uint64_t v26 = *(unsigned int *)(v24 + 168);
    if (v26)
    {
      LODWORD(v27) = (v26 - 1) & ((v20 >> 4) ^ (v20 >> 9));
      BOOL v28 = (uint64_t ****)(v25 + 16 * v27);
      uint64_t v29 = *v28;
      if (*v28 == v20)
      {
LABEL_51:
        int v39 = (size_t *)v28[1];
        size_t v42 = *v39;
        uint64_t v40 = v39 + 2;
        size_t v41 = v42;
        char v43 = (unsigned char *)*((void *)v22 + 4);
        if (v42 <= *((void *)v22 + 3) - (void)v43)
        {
          if (v41)
          {
            memcpy(v43, v40, v41);
            char v43 = (unsigned char *)(*((void *)v22 + 4) + v41);
            *((void *)v22 + 4) = v43;
          }
          goto LABEL_56;
        }
        llvm::raw_ostream::write(v22, (const char *)v40, v41);
LABEL_53:
        char v43 = (unsigned char *)*((void *)v22 + 4);
LABEL_56:
        if (*((unsigned char **)v22 + 3) == v43)
        {
          llvm::raw_ostream::write(v22, "\n", 1uLL);
        }
        else
        {
          *char v43 = 10;
          ++*((void *)v22 + 4);
        }
        goto LABEL_58;
      }
      int v30 = 1;
      while (v29 != (uint64_t ***)-4096)
      {
        int v31 = v27 + v30++;
        uint64_t v27 = v31 & (v26 - 1);
        uint64_t v29 = *(uint64_t ****)(v25 + 16 * v27);
        if (v29 == v20)
        {
          BOOL v28 = (uint64_t ****)(v25 + 16 * v27);
          goto LABEL_51;
        }
      }
    }
    BOOL v28 = (uint64_t ****)(v25 + 16 * v26);
    goto LABEL_51;
  }
LABEL_58:
  if (llvm::verifyFunction(v20, 0, v18))
  {
    size_t v44 = "Broken function found, compilation aborted!";
    goto LABEL_65;
  }
LABEL_20:
  uint64_t v15 = *(uint64_t (**)(uint64_t *))(*v6 + 8);

  return v15(v6);
}

void sub_1CCCD30A8()
{
}

__n128 sub_1CCCD30BC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1F263C158;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1CCCD3110(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F263C158;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1CCCD3148(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = *a2;
  uint64_t v9 = *(void *)(a1 + 16);
  char v10 = *(unsigned char *)(v9 + 23);
  if (v10 >= 0) {
    size_t v11 = *(const void **)(a1 + 16);
  }
  else {
    size_t v11 = *(const void **)v9;
  }
  if (v10 >= 0) {
    size_t v12 = v10 & 0x7F;
  }
  else {
    size_t v12 = *(void *)(v9 + 8);
  }
  llvm::InLineChangePrinter::handleFunctionCompare(*(void *)(a1 + 8), v11, v12, a4, (uint64_t)a5, a6, a7, a8, v13, v14, v8, a4, a5);
}

void sub_1CCCD3198(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *a1;
  if (a2)
  {
    uint64_t v6 = *(const char **)(a2 + 24);
    uint64_t v4 = a2 + 24;
    uint64_t v5 = v6;
    char v7 = *(unsigned char *)(v4 + 23);
    int v8 = v7;
    if (v7 >= 0) {
      uint64_t v9 = (const char *)v4;
    }
    else {
      uint64_t v9 = v5;
    }
    uint64_t v10 = v7 & 0x7F;
    if (v8 >= 0) {
      uint64_t v11 = v10;
    }
    else {
      uint64_t v11 = *(void *)(v4 + 8);
    }
    if (a3) {
      goto LABEL_9;
    }
LABEL_16:
    char v17 = "\n";
    uint64_t v19 = 1;
    goto LABEL_17;
  }
  uint64_t v9 = "\n";
  uint64_t v11 = 1;
  if (!a3) {
    goto LABEL_16;
  }
LABEL_9:
  uint64_t v14 = *(const char **)(a3 + 24);
  uint64_t v12 = a3 + 24;
  uint64_t v13 = v14;
  char v15 = *(unsigned char *)(v12 + 23);
  int v16 = v15;
  if (v15 >= 0) {
    char v17 = (const char *)v12;
  }
  else {
    char v17 = v13;
  }
  uint64_t v18 = v15 & 0x7F;
  if (v16 >= 0) {
    uint64_t v19 = v18;
  }
  else {
    uint64_t v19 = *(void *)(v12 + 8);
  }
LABEL_17:
  BOOL v20 = *(unsigned char *)(v3 + 48) == 0;
  if (*(unsigned char *)(v3 + 48)) {
    std::string::size_type v21 = "\x1B[31m-%l\x1B[0m\n";
  }
  else {
    std::string::size_type v21 = "-%l\n";
  }
  if (*(unsigned char *)(v3 + 48)) {
    size_t v22 = 13;
  }
  else {
    size_t v22 = 4;
  }
  char v39 = v22;
  if (v20) {
    uint64_t v23 = "+%l\n";
  }
  else {
    uint64_t v23 = "\x1B[32m+%l\x1B[0m\n";
  }
  memcpy(__dst, v21, v22);
  *((unsigned char *)__dst + v22) = 0;
  char v37 = v22;
  memcpy(v36, v23, v22);
  *((unsigned char *)v36 + v22) = 0;
  char v35 = 4;
  strcpy((char *)v34, " %l\n");
  uint64_t v25 = *(llvm::raw_ostream **)(v3 + 40);
  if (v39 >= 0) {
    uint64_t v26 = __dst;
  }
  else {
    uint64_t v26 = (void **)__dst[0];
  }
  if (v39 >= 0) {
    uint64_t v27 = v39 & 0x7F;
  }
  else {
    uint64_t v27 = (uint64_t)__dst[1];
  }
  BOOL v28 = (void **)v36[0];
  if (v37 >= 0) {
    BOOL v28 = v36;
  }
  uint64_t v29 = v37 & 0x7F;
  if (v37 < 0) {
    uint64_t v29 = (uint64_t)v36[1];
  }
  sub_1CCCD027C((uint64_t)__p, (uint64_t)v9, v11, (uint64_t)v17, v19, (uint64_t)v26, v27, v24, (uint64_t)v28, v29, (uint64_t)v34, 4);
  if (v33 >= 0) {
    int v30 = __p;
  }
  else {
    int v30 = (void **)__p[0];
  }
  if (v33 >= 0) {
    size_t v31 = v33 & 0x7F;
  }
  else {
    size_t v31 = (size_t)__p[1];
  }
  llvm::raw_ostream::write(v25, (const char *)v30, v31);
  if (v33 < 0) {
    operator delete(__p[0]);
  }
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  if (v37 < 0) {
    operator delete(v36[0]);
  }
  if (v39 < 0) {
    operator delete(__dst[0]);
  }
}

void sub_1CCCD3394(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    uint64_t v4 = (void **)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = v4 - 7;
        sub_1CD7472E8((uint64_t)(v4 - 4));
        char v7 = v6;
        sub_1CB8338B8(&v7);
        uint64_t v4 = v6;
      }
      while (v6 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

llvm::StringMapImpl *sub_1CCCD3414(llvm::StringMapImpl *this, uint64_t *a2)
{
  *(void *)this = 0;
  *((void *)this + sub_1CD7485C0(this + 1) = 0;
  *((void *)this + 2) = 0x2000000000;
  if (*((_DWORD *)a2 + 3))
  {
    llvm::StringMapImpl::init(this, *((_DWORD *)a2 + 2));
    uint64_t v4 = *(void *)this;
    uint64_t v5 = *((unsigned int *)this + 2);
    uint64_t v6 = *a2;
    *(void *)((char *)this + 12) = *(uint64_t *)((char *)a2 + 12);
    if (v5)
    {
      uint64_t v7 = 0;
      uint64_t v18 = v4 + 8 * v5 + 8;
      uint64_t v8 = v6 + 8 * v5 + 8;
      do
      {
        uint64_t v9 = *(void *)(*a2 + 8 * v7);
        if (v9) {
          BOOL v10 = v9 == -8;
        }
        else {
          BOOL v10 = 1;
        }
        if (v10)
        {
          *(void *)(*(void *)this + 8 * v7) = v9;
        }
        else
        {
          size_t v11 = *(void *)v9;
          uint64_t v12 = operator new(*(void *)v9 + 33, (std::align_val_t)8uLL);
          uint64_t v13 = v12;
          uint64_t v14 = (char *)(v12 + 4);
          if (v11) {
            memcpy(v12 + 4, (const void *)(v9 + 32), v11);
          }
          v14[v11] = 0;
          size_t *v13 = v11;
          char v15 = v13 + 1;
          if (*(char *)(v9 + 31) < 0)
          {
            sub_1CB8BDF7C((uint64_t)v15, *(const void **)(v9 + 8), *(void *)(v9 + 16));
          }
          else
          {
            long long v16 = *(_OWORD *)(v9 + 8);
            void v13[3] = *(void *)(v9 + 24);
            _OWORD *v15 = v16;
          }
          *(void *)(*(void *)this + 8 * v7) = v13;
          *(_DWORD *)(v18 + 4 * v7) = *(_DWORD *)(v8 + 4 * v7);
        }
        ++v7;
      }
      while (v5 != v7);
    }
  }
  return this;
}

void sub_1CCCD355C()
{
}

void *sub_1CCCD3570(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1F263C258;
  result[1] = v3;
  return result;
}

uint64_t sub_1CCCD35B8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F263C258;
  a2[1] = v2;
  return result;
}

void sub_1CCCD35E4(uint64_t a1, char *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  llvm::DotCfgChangeReporter::handleFunctionCompare(*(void *)(a1 + 8), (uint64_t)"", 0, (uint64_t)" ", 1, "Initial IR", 0xAuLL, a8, (uint64_t)"", 0, *a2, v8, *a3, a4, a5);
}

void sub_1CCCD3648()
{
}

__n128 sub_1CCCD365C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1F263C2A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1CCCD36B0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F263C2A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1CCCD36E8(uint64_t a1, char *a2, int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = *a2;
  int v9 = *a3;
  uint64_t v10 = *(void *)(a1 + 16);
  char v11 = *(unsigned char *)(v10 + 23);
  if (v11 >= 0) {
    uint64_t v12 = *(void *)(a1 + 16);
  }
  else {
    uint64_t v12 = *(void *)v10;
  }
  if (v11 >= 0) {
    uint64_t v13 = v11 & 0x7F;
  }
  else {
    uint64_t v13 = *(void *)(v10 + 8);
  }
  llvm::DotCfgChangeReporter::handleFunctionCompare(*(void *)(a1 + 8), v12, v13, (uint64_t)" Pass ", 6, **(char ***)(a1 + 24), *(void *)(*(void *)(a1 + 24) + 8), a8, (uint64_t)" on ", 4, v8, v14, v9, a4, a5);
}

char *sub_1CCCD3764(int64x2_t *a1)
{
  uint64_t v2 = a1->i64[0];
  unint64_t v1 = a1->u64[1];
  uint64_t v3 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v1 - a1->i64[0]) >> 3);
  unint64_t v4 = v3 + 1;
  if ((unint64_t)(v3 + 1) > 0x492492492492492) {
    abort();
  }
  uint64_t v6 = a1[1].i64[0];
  if (0xDB6DB6DB6DB6DB6ELL * ((v6 - v2) >> 3) > v4) {
    unint64_t v4 = 0xDB6DB6DB6DB6DB6ELL * ((v6 - v2) >> 3);
  }
  if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((v6 - v2) >> 3)) >= 0x249249249249249) {
    unint64_t v7 = 0x492492492492492;
  }
  else {
    unint64_t v7 = v4;
  }
  BOOL v20 = a1 + 1;
  if (v7)
  {
    if (v7 > 0x492492492492492) {
      sub_1CB833614();
    }
    char v8 = (char *)operator new(56 * v7);
  }
  else
  {
    char v8 = 0;
  }
  int v9 = &v8[56 * v3];
  *((_OWORD *)v9 + sub_1CD7485C0(this + 1) = 0u;
  *((_OWORD *)v9 + 2) = 0u;
  *((void *)v9 + 6) = 0;
  *(_OWORD *)int v9 = 0u;
  *((_DWORD *)v9 + 1sub_1CD7485C0(this + 1) = 88;
  if (v1 == v2)
  {
    int64x2_t v10 = vdupq_n_s64(v1);
    char v11 = &v8[56 * v3];
  }
  else
  {
    uint64_t v12 = 0;
    do
    {
      uint64_t v13 = &v9[v12];
      uint64_t v14 = v1 + v12;
      *((void *)v13 - 6) = 0;
      *((void *)v13 - 5) = 0;
      *(_OWORD *)(v13 - 56) = *(_OWORD *)(v1 + v12 - 56);
      *((void *)v13 - 5) = *(void *)(v1 + v12 - 40);
      *(void *)(v14 - 48) = 0;
      *(void *)(v14 - 40) = 0;
      *(void *)(v14 - 56) = 0;
      *((void *)v13 - 4) = *(void *)(v1 + v12 - 32);
      *(_OWORD *)(v13 - 24) = *(_OWORD *)(v1 + v12 - 24);
      *(void *)(v14 - 32) = 0;
      *(void *)(v14 - 24) = 0;
      *(_DWORD *)(v14 - 16) = 0;
      v12 -= 56;
    }
    while (v1 + v12 != v2);
    int64x2_t v10 = *a1;
    uint64_t v6 = a1[1].i64[0];
    char v11 = &v9[v12];
  }
  char v15 = v9 + 56;
  a1->i64[0] = (uint64_t)v11;
  a1->i64[1] = (uint64_t)(v9 + 56);
  int64x2_t v18 = v10;
  a1[1].i64[0] = (uint64_t)&v8[56 * v7];
  uint64_t v19 = v6;
  uint64_t v17 = v10.i64[0];
  sub_1CD74A3E4((uint64_t)&v17);
  return v15;
}

void *sub_1CCCD38F8(int64x2_t *a1)
{
  uint64_t v2 = a1->i64[0];
  unint64_t v1 = a1->u64[1];
  unint64_t v3 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v1 - a1->i64[0]) >> 3);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  uint64_t v6 = a1[1].i64[0];
  if (0x5555555555555556 * ((v6 - v2) >> 3) > v4) {
    unint64_t v4 = 0x5555555555555556 * ((v6 - v2) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v2) >> 3) >= 0x555555555555555) {
    unint64_t v7 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v7 = v4;
  }
  int64x2_t v18 = a1 + 1;
  if (v7)
  {
    if (v7 > 0xAAAAAAAAAAAAAAALL) {
      sub_1CB833614();
    }
    char v8 = (char *)operator new(24 * v7);
  }
  else
  {
    char v8 = 0;
  }
  int v9 = &v8[24 * v3];
  *(void *)int v9 = 0;
  *((void *)v9 + sub_1CD7485C0(this + 1) = 0;
  *((void *)v9 + 2) = 0;
  if (v1 == v2)
  {
    int64x2_t v12 = vdupq_n_s64(v1);
    int64x2_t v10 = &v8[24 * v3];
  }
  else
  {
    int64x2_t v10 = &v8[24 * v3];
    do
    {
      long long v11 = *(_OWORD *)(v1 - 24);
      *((void *)v10 - sub_1CD7485C0(this + 1) = *(void *)(v1 - 8);
      *(_OWORD *)(v10 - 24) = v11;
      v10 -= 24;
      *(void *)(v1 - 16) = 0;
      *(void *)(v1 - 8) = 0;
      *(void *)(v1 - 24) = 0;
      v1 -= 24;
    }
    while (v1 != v2);
    int64x2_t v12 = *a1;
    uint64_t v6 = a1[1].i64[0];
  }
  uint64_t v13 = v9 + 24;
  a1->i64[0] = (uint64_t)v10;
  a1->i64[1] = (uint64_t)(v9 + 24);
  int64x2_t v16 = v12;
  a1[1].i64[0] = (uint64_t)&v8[24 * v7];
  uint64_t v17 = v6;
  uint64_t v15 = v12.i64[0];
  sub_1CBF4EE0C((uint64_t)&v15);
  return v13;
}

void sub_1CCCD3A40(void ***a1)
{
  unint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    unint64_t v4 = (void **)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = v4 - 7;
        sub_1CD746938((uint64_t)(v4 - 4));
        unint64_t v7 = v6;
        sub_1CB8338B8(&v7);
        unint64_t v4 = v6;
      }
      while (v6 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

char *sub_1CCCD3AC0(int64x2_t *a1)
{
  uint64_t v2 = a1->i64[0];
  unint64_t v1 = a1->u64[1];
  uint64_t v3 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v1 - a1->i64[0]) >> 3);
  unint64_t v4 = v3 + 1;
  if ((unint64_t)(v3 + 1) > 0x492492492492492) {
    abort();
  }
  uint64_t v6 = a1[1].i64[0];
  if (0xDB6DB6DB6DB6DB6ELL * ((v6 - v2) >> 3) > v4) {
    unint64_t v4 = 0xDB6DB6DB6DB6DB6ELL * ((v6 - v2) >> 3);
  }
  if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((v6 - v2) >> 3)) >= 0x249249249249249) {
    unint64_t v7 = 0x492492492492492;
  }
  else {
    unint64_t v7 = v4;
  }
  BOOL v20 = a1 + 1;
  if (v7)
  {
    if (v7 > 0x492492492492492) {
      sub_1CB833614();
    }
    char v8 = (char *)operator new(56 * v7);
  }
  else
  {
    char v8 = 0;
  }
  int v9 = &v8[56 * v3];
  *((_OWORD *)v9 + sub_1CD7485C0(this + 1) = 0u;
  *((_OWORD *)v9 + 2) = 0u;
  *((void *)v9 + 6) = 0;
  *(_OWORD *)int v9 = 0u;
  *((_DWORD *)v9 + 1sub_1CD7485C0(this + 1) = 88;
  if (v1 == v2)
  {
    int64x2_t v10 = vdupq_n_s64(v1);
    long long v11 = &v8[56 * v3];
  }
  else
  {
    uint64_t v12 = 0;
    do
    {
      uint64_t v13 = &v9[v12];
      uint64_t v14 = v1 + v12;
      *((void *)v13 - 6) = 0;
      *((void *)v13 - 5) = 0;
      *(_OWORD *)(v13 - 56) = *(_OWORD *)(v1 + v12 - 56);
      *((void *)v13 - 5) = *(void *)(v1 + v12 - 40);
      *(void *)(v14 - 48) = 0;
      *(void *)(v14 - 40) = 0;
      *(void *)(v14 - 56) = 0;
      *((void *)v13 - 4) = *(void *)(v1 + v12 - 32);
      *(_OWORD *)(v13 - 24) = *(_OWORD *)(v1 + v12 - 24);
      *(void *)(v14 - 32) = 0;
      *(void *)(v14 - 24) = 0;
      *(_DWORD *)(v14 - 16) = 0;
      v12 -= 56;
    }
    while (v1 + v12 != v2);
    int64x2_t v10 = *a1;
    uint64_t v6 = a1[1].i64[0];
    long long v11 = &v9[v12];
  }
  uint64_t v15 = v9 + 56;
  a1->i64[0] = (uint64_t)v11;
  a1->i64[1] = (uint64_t)(v9 + 56);
  int64x2_t v18 = v10;
  a1[1].i64[0] = (uint64_t)&v8[56 * v7];
  uint64_t v19 = v6;
  uint64_t v17 = v10.i64[0];
  sub_1CD74B1CC((uint64_t)&v17);
  return v15;
}

void sub_1CCCD3C54()
{
  for (uint64_t i = 0; i != -72; i -= 24)
  {
    if (*((char *)&unk_1EBCEFBB8 + i + 207) < 0) {
      operator delete(*(void **)((char *)&unk_1EBCEFBB8 + i + 184));
    }
  }
}

void sub_1CCCD3C9C()
{
  v6[20] = *MEMORY[0x1E4F143B8];
  LODWORD(v4[0]) = 1;
  LOBYTE(vsub_1CD7485C0(this + 1) = 0;
  v5[0] = &v1;
  sub_1CD747494(v4, (char **)v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &llvm::PreservedCFGCheckerInstrumentation::VerifyPreservedCFG, &dword_1CB82C000);
  v4[0] = "Print changed IRs";
  v4[1] = 17;
  int v2 = 1;
  int v3 = 1;
  int v0 = 0;
  unint64_t v1 = &v0;
  v5[0] = v6;
  v5[1] = (void *)0x400000000;
  llvm::SmallVectorBase<unsigned int>::grow_pod();
}

BOOL llvm::GCOVFile::readGCNO(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  int v3 = *(_DWORD **)(v2 + 8);
  unint64_t v4 = *(void *)(v2 + 16) - (void)v3;
  if (v4 >= 4) {
    size_t v5 = 4;
  }
  else {
    size_t v5 = v4;
  }
  if (v4 < 4) {
    goto LABEL_7;
  }
  if (*v3 == 1869505383)
  {
    char v13 = 0;
  }
  else
  {
    if (*v3 != 1734569583)
    {
LABEL_7:
      char v8 = (llvm::raw_ostream *)llvm::errs((llvm *)a1);
      int v9 = v8;
      uint64_t v10 = *((void *)v8 + 4);
      if ((unint64_t)(*((void *)v8 + 3) - v10) > 0x11)
      {
        *(_WORD *)(v10 + 16) = 8250;
        *(_OWORD *)uint64_t v10 = *(_OWORD *)"unexpected magic: ";
        long long v11 = (unsigned char *)(*((void *)v8 + 4) + 18);
        *((void *)v8 + 4) = v11;
      }
      else
      {
        llvm::raw_ostream::write(v8, "unexpected magic: ", 0x12uLL);
        long long v11 = (unsigned char *)*((void *)v9 + 4);
      }
      if (v5 <= *((void *)v9 + 3) - (void)v11)
      {
        if (v5)
        {
          memcpy(v11, v3, v5);
          long long v11 = (unsigned char *)(*((void *)v9 + 4) + v5);
          *((void *)v9 + 4) = v11;
        }
      }
      else
      {
        llvm::raw_ostream::write(v9, (const char *)v3, v5);
        long long v11 = (unsigned char *)*((void *)v9 + 4);
      }
      if (*((unsigned char **)v9 + 3) == v11)
      {
        llvm::raw_ostream::write(v9, "\n", 1uLL);
        return 0;
      }
      else
      {
        BOOL result = 0;
        *long long v11 = 10;
        ++*((void *)v9 + 4);
      }
      return result;
    }
    char v13 = 1;
  }
  *(void *)a2 = (char *)v3 + v5;
  *(void *)(a2 + 8) = v4 - v5;
  *(unsigned char *)(a2 + 16) = v13;
  *(unsigned char *)(a2 + 17) = 0;
  uint64_t v14 = (int *)(a1 + 60);
  int v15 = sub_1CD74BAA8(a2, (int *)(a1 + 60));
  BOOL result = 0;
  if (!v15) {
    return result;
  }
  int64x2_t v16 = (_DWORD *)(a2 + 24);
  *(_DWORD *)(a1 + 64) = sub_1CD8337FC(a2, (unint64_t *)(a2 + 24), (void *)(a2 + 32));
  int v17 = *(_DWORD *)(a1 + 60);
  if (v17 > 3)
  {
    BOOL result = sub_1CCCD4F00(a2, (unint64_t *)(a1 + 72));
    if (!result) {
      return result;
    }
    int v17 = *v14;
  }
  if (v17 >= 3) {
    sub_1CD8337FC(a2, (unint64_t *)(a2 + 24), (void *)(a2 + 32));
  }
  int v22 = 0;
  int v18 = sub_1CD8337FC(a2, (unint64_t *)(a2 + 24), (void *)(a2 + 32));
  if (v18)
  {
    int v19 = v18;
    while (1)
    {
      BOOL result = sub_1CD74BCB0((unint64_t *)a2, &v22);
      if (!result) {
        break;
      }
      if (v19 == 0x1000000) {
        operator new();
      }
      if (*v14 <= 4) {
        int v20 = 4 * v22;
      }
      else {
        int v20 = v22;
      }
      unint64_t v21 = (v20 + *v16);
      if (v21 < *(void *)v16) {
        return 0;
      }
      llvm::DataExtractor::skip(a2, (unint64_t *)(a2 + 24), v21 - *(void *)v16);
      int v19 = sub_1CD8337FC(a2, (unint64_t *)(a2 + 24), (void *)(a2 + 32));
      if (!v19) {
        goto LABEL_35;
      }
    }
  }
  else
  {
LABEL_35:
    BOOL result = 1;
    *(unsigned char *)(a1 + 56) = 1;
  }
  return result;
}

BOOL sub_1CCCD4F00(uint64_t a1, unint64_t *a2)
{
  unsigned int v14 = 0;
  BOOL v4 = sub_1CD74BCB0((unint64_t *)a1, &v14);
  BOOL result = 0;
  if (v4 && v14)
  {
    uint64_t v6 = (unint64_t *)(a1 + 24);
    if (*(int *)(a1 + 48) < 5)
    {
      unint64_t Bytes = llvm::DataExtractor::getBytes((void *)a1, v6, 4 * v14, (void *)(a1 + 32));
      unint64_t v11 = v10;
      v13[0] = Bytes;
      v13[1] = v10;
      char v15 = 0;
      unint64_t v12 = llvm::StringRef::find(v13, &v15, 1uLL, 0);
      if (v11 >= v12) {
        unint64_t v9 = v12;
      }
      else {
        unint64_t v9 = v11;
      }
      if (v12 == -1) {
        unint64_t v9 = v11;
      }
    }
    else
    {
      unint64_t Bytes = llvm::DataExtractor::getBytes((void *)a1, v6, v14, (void *)(a1 + 32));
      unint64_t v9 = v7 - 1;
      if (v7 < v7 - 1) {
        unint64_t v9 = v7;
      }
    }
    *a2 = Bytes;
    a2[1] = v9;
    return *(void *)(a1 + 32) == 0;
  }
  return result;
}

void sub_1CCCD4FDC(uint64_t a1, char *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 8);
  unint64_t v5 = *(void *)a1;
  if (v4 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v8 = v4 + 1;
    unint64_t v9 = v5 + 8 * v4;
    if (v5 <= (unint64_t)a2 && v9 > (unint64_t)a2)
    {
      unint64_t v11 = &a2[-v5];
      sub_1CCCD9FB0(a1, v8);
      unint64_t v5 = *(void *)a1;
      a2 = &v11[*(void *)a1];
    }
    else
    {
      sub_1CCCD9FB0(a1, v8);
      unint64_t v5 = *(void *)a1;
    }
  }
  uint64_t v6 = *(unsigned int *)(a1 + 8);
  uint64_t v7 = *(void *)a2;
  *(void *)a2 = 0;
  *(void *)(v5 + 8 * v6) = v7;
  *(_DWORD *)(a1 + 8) = v6 + 1;
}

uint64_t llvm::GCOVArc::onTree(llvm::GCOVArc *this)
{
  return *((_DWORD *)this + 4) & 1;
}

void sub_1CCCD5070(uint64_t a1, char *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 8);
  unint64_t v5 = *(void *)a1;
  if (v4 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v8 = v4 + 1;
    unint64_t v9 = v5 + 8 * v4;
    if (v5 <= (unint64_t)a2 && v9 > (unint64_t)a2)
    {
      unint64_t v11 = &a2[-v5];
      sub_1CCCDA100(a1, v8);
      unint64_t v5 = *(void *)a1;
      a2 = &v11[*(void *)a1];
    }
    else
    {
      sub_1CCCDA100(a1, v8);
      unint64_t v5 = *(void *)a1;
    }
  }
  uint64_t v6 = *(unsigned int *)(a1 + 8);
  uint64_t v7 = *(void *)a2;
  *(void *)a2 = 0;
  *(void *)(v5 + 8 * v6) = v7;
  *(_DWORD *)(a1 + 8) = v6 + 1;
}

uint64_t llvm::GCOVFile::readGCDA(_DWORD *a1, unint64_t *a2)
{
  uint64_t result = sub_1CD74BD90((uint64_t)a2);
  if (!result) {
    return result;
  }
  int v56 = 0;
  int v5 = sub_1CD74BAA8((uint64_t)a2, &v56);
  uint64_t result = 0;
  if (!v5) {
    return result;
  }
  if (a1[15] != v56)
  {
    uint64_t v6 = (llvm::raw_ostream *)llvm::errs(0);
    uint64_t v7 = v6;
    unint64_t v8 = (void *)*((void *)v6 + 4);
    if (*((void *)v6 + 3) - (void)v8 > 0x1BuLL)
    {
      uint64_t result = 0;
      qmemcpy(v8, "GCOV versions do not match.\n", 28);
      *((void *)v7 + 4) += 28;
      return result;
    }
    unint64_t v9 = "GCOV versions do not match.\n";
    size_t v10 = 28;
    goto LABEL_7;
  }
  unsigned int v55 = 0;
  BOOL v11 = sub_1CD74BCB0(a2, &v55);
  uint64_t result = 0;
  if (!v11) {
    return result;
  }
  if (a1[16] != v55)
  {
    unint64_t v12 = (llvm::raw_ostream *)llvm::errs(0);
    char v13 = v12;
    unsigned int v14 = (void *)*((void *)v12 + 4);
    if (*((void *)v12 + 3) - (void)v14 > 0x1CuLL)
    {
      qmemcpy(v14, "file checksums do not match: ", 29);
      *((void *)v12 + 4) += 29;
    }
    else
    {
      llvm::raw_ostream::write(v12, "file checksums do not match: ", 0x1DuLL);
    }
    sub_1CD098D14(v13, a1[16], 0, 0, 0);
    char v15 = (_DWORD *)*((void *)v13 + 4);
    if (*((void *)v13 + 3) - (void)v15 > 3uLL)
    {
      _DWORD *v15 = 540877088;
      *((void *)v13 + 4) += 4;
    }
    else
    {
      llvm::raw_ostream::write(v13, " != ", 4uLL);
    }
    sub_1CD098D14(v13, v55, 0, 0, 0);
    int64x2_t v16 = (unsigned char *)*((void *)v13 + 4);
    if (*((unsigned char **)v13 + 3) != v16)
    {
      uint64_t result = 0;
      *int64x2_t v16 = 10;
      ++*((void *)v13 + 4);
      return result;
    }
    unint64_t v9 = "\n";
    uint64_t v6 = v13;
    size_t v10 = 1;
LABEL_7:
    llvm::raw_ostream::write(v6, v9, v10);
    return 0;
  }
  uint64_t v54 = 0;
  int v17 = (int *)(a2 + 3);
  unsigned int v53 = 0;
  int v18 = sub_1CD8337FC((uint64_t)a2, a2 + 3, a2 + 4);
  uint64_t v19 = 1;
  if (!v18) {
    return v19;
  }
  int v20 = v18;
  uint64_t v21 = 0;
  uint64_t v45 = a1 + 64;
  std::string::size_type v46 = (uint64_t *)(a1 + 60);
  while (1)
  {
    BOOL v22 = sub_1CD74BCB0(a2, &v54);
    if (!v22) {
      return 0;
    }
    int v23 = *v17;
    switch(v20)
    {
      case -1560281088:
        if (v54)
        {
          sub_1CD74BCB0(a2, (_DWORD *)&v54 + 1);
          sub_1CD74BCB0(a2, (_DWORD *)&v54 + 1);
          sub_1CD74BCB0(a2, v45);
        }
        ++a1[65];
        goto LABEL_38;
      case 16777216:
        if (!v54) {
          goto LABEL_64;
        }
        if (v54 == 1 || !sub_1CD74BCB0(a2, &v53)) {
          return 0;
        }
        uint64_t v32 = *v46;
        if (!*v46) {
          goto LABEL_57;
        }
        char v33 = (uint64_t *)(a1 + 60);
        do
        {
          unsigned int v34 = *(_DWORD *)(v32 + 32);
          BOOL v35 = v34 >= v53;
          if (v34 >= v53) {
            char v36 = (uint64_t *)v32;
          }
          else {
            char v36 = (uint64_t *)(v32 + 8);
          }
          if (v35) {
            char v33 = (uint64_t *)v32;
          }
          uint64_t v32 = *v36;
        }
        while (*v36);
        if (v33 == v46 || v53 < *((_DWORD *)v33 + 8)) {
LABEL_57:
        }
          char v33 = (uint64_t *)(a1 + 60);
        unsigned int v51 = 0;
        unsigned int v52 = 0;
        BOOL v37 = sub_1CD74BCB0(a2, &v52);
        if ((int)a1[15] >= 1) {
          BOOL v37 = sub_1CD74BCB0(a2, &v51);
        }
        if (v33 != v46)
        {
          uint64_t v21 = v33[5];
          if (v52 != *(_DWORD *)(v21 + 12) || v51 != *(_DWORD *)(v21 + 16))
          {
            size_t v38 = (llvm::raw_ostream *)llvm::errs((llvm *)v37);
            size_t v42 = *(const void **)(v21 + 40);
            unint64_t v43 = *(void *)(v21 + 48);
            size_t v44 = (void *)*((void *)v38 + 4);
            if (v43 <= *((void *)v38 + 3) - (void)v44)
            {
              if (v43)
              {
                memcpy(v44, v42, *(void *)(v21 + 48));
                *((void *)v38 + 4) += v43;
              }
            }
            else
            {
              llvm::raw_ostream::write(v38, (const char *)v42, *(void *)(v21 + 48));
            }
            long long v47 = &unk_1F263C308;
            __int16 v48 = ": checksum mismatch, (%u, %u) != (%u, %u)\n";
            unint64_t v49 = __PAIR64__(v51, v52);
            uint64_t v50 = *(void *)(v21 + 12);
            goto LABEL_81;
          }
        }
        goto LABEL_38;
      case -1593835520:
        sub_1CD74BCB0(a2, v45);
        sub_1CD74BCB0(a2, (_DWORD *)&v54 + 1);
        if (v54 == 9) {
          sub_1CD74BCB0(a2, v45);
        }
        goto LABEL_38;
    }
    if (v20 == 27328512 && v21) {
      break;
    }
LABEL_38:
    if ((int)a1[15] <= 4) {
      int v30 = 4 * v54;
    }
    else {
      int v30 = v54;
    }
    unint64_t v31 = (v30 + v23);
    if (v31 < *(void *)v17) {
      return 0;
    }
    llvm::DataExtractor::skip((BOOL)a2, a2 + 3, v31 - *(void *)v17);
LABEL_64:
    int v20 = sub_1CD8337FC((uint64_t)a2, a2 + 3, a2 + 4);
    if (!v20) {
      return 1;
    }
  }
  uint64_t v24 = *(unsigned int *)(v21 + 112);
  if ((int)a1[15] <= 4) {
    char v25 = 1;
  }
  else {
    char v25 = 3;
  }
  uint64_t v26 = (v24 << v25);
  if (v54 != v26)
  {
    size_t v38 = (llvm::raw_ostream *)llvm::errs((llvm *)v22);
    char v39 = *(const void **)(v21 + 40);
    unint64_t v40 = *(void *)(v21 + 48);
    size_t v41 = (void *)*((void *)v38 + 4);
    if (v40 <= *((void *)v38 + 3) - (void)v41)
    {
      if (v40)
      {
        memcpy(v41, v39, *(void *)(v21 + 48));
        *((void *)v38 + 4) += v40;
      }
    }
    else
    {
      llvm::raw_ostream::write(v38, (const char *)v39, *(void *)(v21 + 48));
    }
    long long v47 = &unk_1F26088E8;
    __int16 v48 = ": GCOV_TAG_COUNTER_ARCS mismatch, got %u, expected %u\n";
    unint64_t v49 = v54 | (unint64_t)(v26 << 32);
LABEL_81:
    llvm::raw_ostream::operator<<(v38, (uint64_t)&v47);
    return 0;
  }
  if (!v24)
  {
LABEL_33:
    if (*(_DWORD *)(v21 + 96) >= 2u) {
      operator new();
    }
    goto LABEL_38;
  }
  uint64_t v27 = *(void *)(v21 + 104);
  uint64_t v28 = 8 * v24;
  while (sub_1CD74BE04(a2, (unint64_t *)(*(void *)v27 + 24)))
  {
    uint64_t v29 = *(void **)v27;
    v27 += 8;
    *(void *)(*v29 + 8) += v29[3];
    v28 -= 8;
    if (!v28) {
      goto LABEL_33;
    }
  }
  return 0;
}

uint64_t llvm::GCOVFunction::propagateCounts(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = a1 + 136;
  uint64_t v6 = *(void *)(a1 + 136);
  uint64_t v24 = 0;
  char v8 = sub_1CC091A20(v6, *(_DWORD *)(v7 + 16), a2, &v24);
  uint64_t result = 0;
  if (v8) {
    return result;
  }
  unsigned int v10 = *(_DWORD *)(v7 + 16);
  int v11 = *(_DWORD *)(a1 + 144);
  if (4 * v11 + 4 >= 3 * v10)
  {
    v10 *= 2;
    goto LABEL_31;
  }
  if (v10 + ~v11 - *(_DWORD *)(a1 + 148) <= v10 >> 3)
  {
LABEL_31:
    sub_1CC091AB4(v7, v10);
    uint64_t v24 = 0;
    sub_1CC091A20(*(void *)(a1 + 136), *(_DWORD *)(a1 + 152), a2, &v24);
  }
  unint64_t v12 = v24;
  ++*(_DWORD *)(a1 + 144);
  if (*v12 != -4096) {
    --*(_DWORD *)(a1 + 148);
  }
  *unint64_t v12 = a2;
  uint64_t v13 = *(unsigned int *)(a2 + 24);
  if (v13)
  {
    uint64_t v14 = 0;
    char v15 = *(uint64_t **)(a2 + 16);
    uint64_t v16 = 8 * v13;
    do
    {
      uint64_t v17 = *v15;
      if (*v15 != a3)
      {
        if (*(unsigned char *)(v17 + 16)) {
          uint64_t v18 = llvm::GCOVFunction::propagateCounts((llvm::GCOVFunction *)a1, *(const llvm::GCOVBlock **)v17, (llvm::GCOVArc *)v17);
        }
        else {
          uint64_t v18 = *(void *)(v17 + 24);
        }
        v14 += v18;
      }
      ++v15;
      v16 -= 8;
    }
    while (v16);
  }
  else
  {
    uint64_t v14 = 0;
  }
  uint64_t v19 = *(unsigned int *)(a2 + 56);
  if (v19)
  {
    int v20 = *(uint64_t **)(a2 + 48);
    uint64_t v21 = 8 * v19;
    do
    {
      uint64_t v22 = *v20;
      if (*v20 != a3)
      {
        if (*(unsigned char *)(v22 + 16)) {
          uint64_t v23 = llvm::GCOVFunction::propagateCounts((llvm::GCOVFunction *)a1, *(const llvm::GCOVBlock **)(v22 + 8), (llvm::GCOVArc *)v22);
        }
        else {
          uint64_t v23 = *(void *)(v22 + 24);
        }
        v14 -= v23;
      }
      ++v20;
      v21 -= 8;
    }
    while (v21);
  }
  if (v14 >= 0) {
    uint64_t result = v14;
  }
  else {
    uint64_t result = -v14;
  }
  if (a3) {
    *(void *)(a3 + 24) = result;
  }
  return result;
}

llvm::raw_ostream *llvm::GCOVFile::print(llvm::raw_ostream *this, llvm::raw_ostream *a2)
{
  uint64_t v2 = *((unsigned int *)this + 24);
  if (v2)
  {
    uint64_t v4 = (llvm::GCOVFunction **)*((void *)this + 11);
    uint64_t v5 = 8 * v2;
    do
    {
      uint64_t v6 = *v4++;
      this = llvm::GCOVFunction::print(v6, a2);
      v5 -= 8;
    }
    while (v5);
  }
  return this;
}

llvm::raw_ostream *llvm::GCOVFunction::print(llvm::GCOVFunction *this, llvm::raw_ostream *a2)
{
  uint64_t v4 = *((void *)a2 + 4);
  if ((unint64_t)(*((void *)a2 + 3) - v4) > 5)
  {
    *(_WORD *)(v4 + 4) = 8253;
    *(_DWORD *)uint64_t v4 = 1027423549;
    uint64_t v5 = (_WORD *)(*((void *)a2 + 4) + 6);
    *((void *)a2 + 4) = v5;
  }
  else
  {
    llvm::raw_ostream::write(a2, "===== ", 6uLL);
    uint64_t v5 = (_WORD *)*((void *)a2 + 4);
  }
  uint64_t v6 = (const void *)*((void *)this + 5);
  unint64_t v7 = *((void *)this + 6);
  if (v7 <= *((void *)a2 + 3) - (void)v5)
  {
    if (v7)
    {
      memcpy(v5, v6, *((void *)this + 6));
      uint64_t v5 = (_WORD *)(*((void *)a2 + 4) + v7);
      *((void *)a2 + 4) = v5;
    }
  }
  else
  {
    llvm::raw_ostream::write(a2, (const char *)v6, *((void *)this + 6));
    uint64_t v5 = (_WORD *)*((void *)a2 + 4);
  }
  if (*((void *)a2 + 3) - (void)v5 > 1uLL)
  {
    *uint64_t v5 = 10272;
    *((void *)a2 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(a2, " (", 2uLL);
  }
  sub_1CD098D14(a2, *((unsigned int *)this + 2), 0, 0, 0);
  char v8 = (_DWORD *)*((void *)a2 + 4);
  if (*((void *)a2 + 3) - (void)v8 > 3uLL)
  {
    _DWORD *v8 = 541073449;
    unint64_t v9 = (unsigned char *)(*((void *)a2 + 4) + 4);
    *((void *)a2 + 4) = v9;
  }
  else
  {
    llvm::raw_ostream::write(a2, ") @ ", 4uLL);
    unint64_t v9 = (unsigned char *)*((void *)a2 + 4);
  }
  uint64_t v10 = **(void **)this + 24 * *((unsigned int *)this + 20);
  char v11 = *(unsigned char *)(v10 + 23);
  if (v11 >= 0) {
    unint64_t v12 = (const void *)(**(void **)this + 24 * *((unsigned int *)this + 20));
  }
  else {
    unint64_t v12 = *(const void **)v10;
  }
  if (v11 >= 0) {
    size_t v13 = v11 & 0x7F;
  }
  else {
    size_t v13 = *(void *)(v10 + 8);
  }
  if (v13 <= *((void *)a2 + 3) - (void)v9)
  {
    if (v13)
    {
      memcpy(v9, v12, v13);
      unint64_t v9 = (unsigned char *)(*((void *)a2 + 4) + v13);
      *((void *)a2 + 4) = v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(a2, (const char *)v12, v13);
    unint64_t v9 = (unsigned char *)*((void *)a2 + 4);
  }
  if (*((unsigned char **)a2 + 3) == v9)
  {
    llvm::raw_ostream::write(a2, ":", 1uLL);
  }
  else
  {
    unsigned char *v9 = 58;
    ++*((void *)a2 + 4);
  }
  uint64_t result = sub_1CD098D14(a2, *((unsigned int *)this + 5), 0, 0, 0);
  char v15 = (unsigned char *)*((void *)a2 + 4);
  if (*((unsigned char **)a2 + 3) == v15)
  {
    uint64_t result = llvm::raw_ostream::write(a2, "\n", 1uLL);
  }
  else
  {
    unsigned char *v15 = 10;
    ++*((void *)a2 + 4);
  }
  uint64_t v16 = *((unsigned int *)this + 24);
  if (v16)
  {
    uint64_t v17 = (llvm::GCOVBlock **)*((void *)this + 11);
    uint64_t v18 = 8 * v16;
    do
    {
      uint64_t v19 = *v17++;
      uint64_t result = llvm::GCOVBlock::print(v19, a2);
      v18 -= 8;
    }
    while (v18);
  }
  return result;
}

llvm *llvm::GCOVFile::dump(llvm::GCOVFunction ***this)
{
  uint64_t result = llvm::dbgs((llvm *)this);
  uint64_t v3 = *((unsigned int *)this + 24);
  if (v3)
  {
    uint64_t v4 = result;
    uint64_t v5 = this[11];
    uint64_t v6 = 8 * v3;
    do
    {
      unint64_t v7 = *v5++;
      uint64_t result = llvm::GCOVFunction::print(v7, v4);
      v6 -= 8;
    }
    while (v6);
  }
  return result;
}

void *llvm::GCOVFunction::getName(llvm::GCOVFunction *this, char a2, uint64_t a3, uint64_t a4, int *a5)
{
  if (a2)
  {
    uint64_t v6 = (uint64_t *)((char *)this + 64);
    unint64_t v7 = (void **)((char *)this + 56);
    if (!*((void *)this + 8))
    {
      size_t v8 = *((void *)this + 6);
      if (v8 >= 2)
      {
        unint64_t v9 = (llvm *)*((void *)this + 5);
        if (*(_WORD *)v9 == 23135)
        {
          LODWORD(v19) = 0;
          uint64_t v10 = llvm::itaniumDemangle(v9, 0, 0, &v19, a5);
          if (!v19)
          {
            uint64_t v14 = (char *)v10;
            if (v10)
            {
              size_t v15 = strlen(v10);
              size_t v16 = v15;
              *((void *)this + 8) = 0;
              if (*((void *)this + 9) < v15) {
                llvm::SmallVectorBase<unsigned long long>::grow_pod();
              }
              size_t v17 = 0;
              uint64_t v18 = 0;
              if (v15)
              {
                memcpy(*v7, v14, v15);
                uint64_t v18 = *v6;
                size_t v17 = v16;
              }
            }
            else
            {
              size_t v17 = 0;
              uint64_t v18 = 0;
            }
            *uint64_t v6 = v18 + v17;
            free(v14);
            return *v7;
          }
          size_t v8 = *((void *)this + 6);
        }
      }
      uint64_t v11 = 0;
      unint64_t v12 = (const void *)*((void *)this + 5);
      *((void *)this + 8) = 0;
      if (*((void *)this + 9) < v8) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      if (v8)
      {
        memcpy(*v7, v12, v8);
        uint64_t v11 = *v6;
      }
      *uint64_t v6 = v11 + v8;
    }
    return *v7;
  }
  return (void *)*((void *)this + 5);
}

uint64_t llvm::GCOVFunction::getFilename(llvm::GCOVFunction *this)
{
  unint64_t v1 = (char *)(**(void **)this + 24 * *((unsigned int *)this + 20));
  if (v1[23] >= 0) {
    return **(void **)this + 24 * *((unsigned int *)this + 20);
  }
  else {
    return *(void *)v1;
  }
}

uint64_t llvm::GCOVFunction::getEntryCount(llvm::GCOVFunction *this)
{
  return *(void *)(**((void **)this + 11) + 8);
}

uint64_t llvm::GCOVFunction::getExitBlock(llvm::GCOVFunction *this)
{
  uint64_t v1 = *((void *)this + 11);
  if (*(int *)(*(void *)this + 60) > 1) {
    uint64_t v2 = v1 + 8;
  }
  else {
    uint64_t v2 = v1 + 8 * *((unsigned int *)this + 24) - 8;
  }
  return *(void *)v2;
}

llvm::raw_ostream *llvm::GCOVBlock::print(llvm::GCOVBlock *this, llvm::raw_ostream *a2)
{
  uint64_t v4 = (void *)*((void *)a2 + 4);
  if (*((void *)a2 + 3) - (void)v4 > 7uLL)
  {
    *uint64_t v4 = 0x203A206B636F6C42;
    *((void *)a2 + 4) += 8;
  }
  else
  {
    llvm::raw_ostream::write(a2, "Block : ", 8uLL);
  }
  sub_1CD098D14(a2, *(unsigned int *)this, 0, 0, 0);
  uint64_t v5 = *((void *)a2 + 4);
  if ((unint64_t)(*((void *)a2 + 3) - v5) > 0xA)
  {
    *(_DWORD *)(v5 + 7) = 540680306;
    *(void *)uint64_t v5 = *(void *)" Counter : ";
    *((void *)a2 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(a2, " Counter : ", 0xBuLL);
  }
  uint64_t result = sub_1CD098D14(a2, *((void *)this + 1), 0, 0, 0);
  unint64_t v7 = (unsigned char *)*((void *)a2 + 4);
  if (*((unsigned char **)a2 + 3) == v7)
  {
    uint64_t result = llvm::raw_ostream::write(a2, "\n", 1uLL);
  }
  else
  {
    *unint64_t v7 = 10;
    ++*((void *)a2 + 4);
  }
  if (*((_DWORD *)this + 6))
  {
    size_t v8 = (_OWORD *)*((void *)a2 + 4);
    if (*((void *)a2 + 3) - (void)v8 > 0xFuLL)
    {
      _OWORD *v8 = *(_OWORD *)"\tSource Edges : ";
      *((void *)a2 + 4) += 16;
    }
    else
    {
      uint64_t result = llvm::raw_ostream::write(a2, "\tSource Edges : ", 0x10uLL);
    }
    uint64_t v9 = *((unsigned int *)this + 6);
    if (v9)
    {
      uint64_t v10 = (unsigned int ***)*((void *)this + 2);
      uint64_t v11 = 8 * v9;
      do
      {
        uint64_t v12 = (uint64_t)*v10;
        sub_1CD098D14(a2, ***v10, 0, 0, 0);
        size_t v13 = (_WORD *)*((void *)a2 + 4);
        if (*((void *)a2 + 3) - (void)v13 > 1uLL)
        {
          _WORD *v13 = 10272;
          *((void *)a2 + 4) += 2;
        }
        else
        {
          llvm::raw_ostream::write(a2, " (", 2uLL);
        }
        uint64_t result = sub_1CD098D14(a2, *(void *)(v12 + 24), 0, 0, 0);
        uint64_t v14 = *((void *)a2 + 4);
        if ((unint64_t)(*((void *)a2 + 3) - v14) > 2)
        {
          *(unsigned char *)(v14 + 2) = 32;
          *(_WORD *)uint64_t v14 = 11305;
          *((void *)a2 + 4) += 3;
        }
        else
        {
          uint64_t result = llvm::raw_ostream::write(a2, "), ", 3uLL);
        }
        ++v10;
        v11 -= 8;
      }
      while (v11);
    }
    size_t v15 = (unsigned char *)*((void *)a2 + 4);
    if (*((unsigned char **)a2 + 3) == v15)
    {
      uint64_t result = llvm::raw_ostream::write(a2, "\n", 1uLL);
    }
    else
    {
      unsigned char *v15 = 10;
      ++*((void *)a2 + 4);
    }
  }
  if (*((_DWORD *)this + 14))
  {
    size_t v16 = (void *)*((void *)a2 + 4);
    if (*((void *)a2 + 3) - (void)v16 > 0x14uLL)
    {
      qmemcpy(v16, "\tDestination Edges : ", 21);
      *((void *)a2 + 4) += 21;
    }
    else
    {
      uint64_t result = llvm::raw_ostream::write(a2, "\tDestination Edges : ", 0x15uLL);
    }
    uint64_t v17 = *((unsigned int *)this + 14);
    if (v17)
    {
      uint64_t v18 = 8 * v17;
      unint64_t v19 = (uint64_t *)*((void *)this + 6);
      do
      {
        uint64_t v20 = *v19;
        if (*(unsigned char *)(*v19 + 16))
        {
          uint64_t v21 = (unsigned char *)*((void *)a2 + 4);
          if ((unint64_t)v21 >= *((void *)a2 + 3))
          {
            llvm::raw_ostream::write(a2, 42);
          }
          else
          {
            *((void *)a2 + 4) = v21 + 1;
            unsigned char *v21 = 42;
          }
        }
        sub_1CD098D14(a2, **(unsigned int **)(v20 + 8), 0, 0, 0);
        uint64_t v22 = (_WORD *)*((void *)a2 + 4);
        if (*((void *)a2 + 3) - (void)v22 > 1uLL)
        {
          _WORD *v22 = 10272;
          *((void *)a2 + 4) += 2;
        }
        else
        {
          llvm::raw_ostream::write(a2, " (", 2uLL);
        }
        uint64_t result = sub_1CD098D14(a2, *(void *)(v20 + 24), 0, 0, 0);
        uint64_t v23 = *((void *)a2 + 4);
        if ((unint64_t)(*((void *)a2 + 3) - v23) > 2)
        {
          *(unsigned char *)(v23 + 2) = 32;
          *(_WORD *)uint64_t v23 = 11305;
          *((void *)a2 + 4) += 3;
        }
        else
        {
          uint64_t result = llvm::raw_ostream::write(a2, "), ", 3uLL);
        }
        ++v19;
        v18 -= 8;
      }
      while (v18);
    }
    uint64_t v24 = (unsigned char *)*((void *)a2 + 4);
    if (*((unsigned char **)a2 + 3) == v24)
    {
      uint64_t result = llvm::raw_ostream::write(a2, "\n", 1uLL);
    }
    else
    {
      *uint64_t v24 = 10;
      ++*((void *)a2 + 4);
    }
  }
  if (*((_DWORD *)this + 22))
  {
    uint64_t v25 = *((void *)a2 + 4);
    if ((unint64_t)(*((void *)a2 + 3) - v25) > 8)
    {
      *(unsigned char *)(v25 + 8) = 32;
      *(void *)uint64_t v25 = *(void *)"\tLines : ";
      *((void *)a2 + 4) += 9;
    }
    else
    {
      uint64_t result = llvm::raw_ostream::write(a2, "\tLines : ", 9uLL);
    }
    uint64_t v26 = *((unsigned int *)this + 22);
    if (v26)
    {
      uint64_t v27 = (unsigned int *)*((void *)this + 10);
      uint64_t v28 = 4 * v26;
      do
      {
        uint64_t result = sub_1CD098D14(a2, *v27, 0, 0, 0);
        uint64_t v29 = (unsigned char *)*((void *)a2 + 4);
        if (*((unsigned char **)a2 + 3) == v29)
        {
          uint64_t result = llvm::raw_ostream::write(a2, ",", 1uLL);
        }
        else
        {
          unsigned char *v29 = 44;
          ++*((void *)a2 + 4);
        }
        ++v27;
        v28 -= 4;
      }
      while (v28);
    }
    int v30 = (unsigned char *)*((void *)a2 + 4);
    if (*((unsigned char **)a2 + 3) == v30)
    {
      return llvm::raw_ostream::write(a2, "\n", 1uLL);
    }
    else
    {
      unsigned char *v30 = 10;
      ++*((void *)a2 + 4);
    }
  }
  return result;
}

llvm::raw_ostream *llvm::GCOVFunction::dump(llvm::GCOVFunction *this)
{
  uint64_t v2 = llvm::dbgs(this);

  return llvm::GCOVFunction::print(this, v2);
}

llvm::raw_ostream *llvm::GCOVBlock::dump(llvm::GCOVBlock *this)
{
  uint64_t v2 = llvm::dbgs(this);

  return llvm::GCOVBlock::print(this, v2);
}

unint64_t llvm::GCOVBlock::augmentOneCycle(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)a2;
  *(void *)(a2 + 8) = *(void *)a2;
  unint64_t v5 = *(void *)(a2 + 16);
  if ((unint64_t)v4 >= v5)
  {
    uint64_t v7 = v5 - (void)v4;
    uint64_t v8 = v7 >> 3;
    if ((unint64_t)(v7 >> 3) <= 1) {
      uint64_t v8 = 1;
    }
    if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v9 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v9 = v8;
    }
    if (v9 >> 60) {
LABEL_45:
    }
      sub_1CB833614();
    uint64_t v10 = operator new(16 * v9);
    uint64_t v11 = &v10[2 * v9];
    void *v10 = a1;
    v10[1] = 0;
    uint64_t v6 = v10 + 2;
    *(void *)a2 = v10;
    *(void *)(a2 + 8) = v10 + 2;
    *(void *)(a2 + 16) = v11;
    if (v4) {
      operator delete(v4);
    }
  }
  else
  {
    *uint64_t v4 = a1;
    v4[1] = 0;
    uint64_t v6 = v4 + 2;
  }
  *(void *)(a2 + 8) = v6;
  *(void *)(a1 + 120) = 1;
  while (1)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v12 = *(v6 - 2);
        uint64_t v14 = *(v6 - 1);
        size_t v13 = v6 - 2;
        if (v14 != *(_DWORD *)(v12 + 56)) {
          break;
        }
        *(unsigned char *)(v12 + 112) = 0;
        *(void *)(a2 + 8) = v13;
        v6 -= 2;
        if (*(void **)a2 == v13) {
          return 0;
        }
      }
      *(v6 - sub_1CD7485C0(this + 1) = v14 + 1;
      uint64_t v15 = *(void *)(*(void *)(v12 + 48) + 8 * v14);
      uint64_t v16 = *(void *)(v15 + 32);
      if (v16)
      {
        uint64_t v17 = *(void *)(v15 + 8);
        if (v17 != v12 && *(unsigned char *)(v17 + 112) != 0) {
          break;
        }
      }
    }
    if (*(void *)(v17 + 120)) {
      break;
    }
    *(void *)(v17 + 120) = v15;
    unint64_t v19 = *(void *)(a2 + 16);
    if ((unint64_t)v6 >= v19)
    {
      uint64_t v20 = *(void **)a2;
      uint64_t v21 = ((uint64_t)v6 - *(void *)a2) >> 4;
      unint64_t v22 = v21 + 1;
      if ((unint64_t)(v21 + 1) >> 60) {
        abort();
      }
      uint64_t v23 = v19 - (void)v20;
      if (v23 >> 3 > v22) {
        unint64_t v22 = v23 >> 3;
      }
      if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v24 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v24 = v22;
      }
      if (v24 >> 60) {
        goto LABEL_45;
      }
      uint64_t v25 = (char *)operator new(16 * v24);
      uint64_t v26 = &v25[16 * v21];
      *(void *)uint64_t v26 = v17;
      *((void *)v26 + sub_1CD7485C0(this + 1) = 0;
      if (v6 == v20)
      {
        uint64_t v28 = &v25[16 * v21];
      }
      else
      {
        uint64_t v27 = &v25[16 * v21];
        do
        {
          uint64_t v28 = v27 - 16;
          *((_OWORD *)v27 - sub_1CD7485C0(this + 1) = *((_OWORD *)v6 - 1);
          v6 -= 2;
          v27 -= 16;
        }
        while (v6 != v20);
      }
      uint64_t v6 = v26 + 16;
      *(void *)a2 = v28;
      *(void *)(a2 + 8) = v26 + 16;
      *(void *)(a2 + 16) = &v25[16 * v24];
      if (v20) {
        operator delete(v20);
      }
    }
    else
    {
      *uint64_t v6 = v17;
      v6[1] = 0;
      v6 += 2;
    }
    *(void *)(a2 + 8) = v6;
  }
  unint64_t result = *(void *)(v15 + 32);
  uint64_t v30 = v12;
  do
  {
    unint64_t v31 = *(uint64_t **)(v30 + 120);
    if (v31[4] < result) {
      unint64_t result = v31[4];
    }
    uint64_t v30 = *v31;
  }
  while (v30 != v17);
  *(void *)(v15 + 32) = v16 - result;
  do
  {
    uint64_t v32 = *(uint64_t **)(v12 + 120);
    v32[4] -= result;
    uint64_t v12 = *v32;
  }
  while (v12 != v17);
  return result;
}

uint64_t llvm::GCOVBlock::getCyclesCount(uint64_t a1)
{
  memset(__p, 0, sizeof(__p));
  uint64_t v1 = *(unsigned int *)(a1 + 8);
  if (!v1) {
    return 0;
  }
  uint64_t v3 = 0;
  uint64_t v4 = *(uint64_t **)a1;
  uint64_t v5 = *(void *)a1 + 8 * v1;
  do
  {
    uint64_t v6 = v4;
    do
    {
      uint64_t v7 = *v6++;
      *(unsigned char *)(v7 + 112) = 1;
      *(void *)(v7 + 120) = 0;
    }
    while (v6 != (uint64_t *)v5);
    while (1)
    {
      if (*(unsigned char *)(*v4 + 112))
      {
        unint64_t v8 = llvm::GCOVBlock::augmentOneCycle(*v4, (uint64_t)__p);
        if (v8) {
          break;
        }
      }
      if (++v4 == (uint64_t *)v5) {
        goto LABEL_10;
      }
    }
    v3 += v8;
    uint64_t v4 = *(uint64_t **)a1;
    uint64_t v9 = *(unsigned int *)(a1 + 8);
    uint64_t v5 = *(void *)a1 + 8 * v9;
  }
  while (v9);
LABEL_10:
  if (__p[0]) {
    operator delete(__p[0]);
  }
  return v3;
}

void llvm::gcovOneInput(char *is_absolute, char *a2, char *a3, const void *a4, size_t a5, const void *a6, size_t a7, int *a8)
{
  uint64_t v453 = *MEMORY[0x1E4F143B8];
  uint64_t v427 = is_absolute;
  uint64_t v428 = 0;
  uint64_t v429 = 0;
  uint64_t v430 = 0;
  unint64_t v8 = *(uint64_t **)a8;
  uint64_t v9 = (uint64_t *)*((void *)a8 + 1);
  if (*(uint64_t **)a8 != v9)
  {
    uint64_t v422 = (uint64_t *)*((void *)a8 + 1);
    while (1)
    {
      char v10 = *((unsigned char *)v8 + 23);
      BOOL v11 = v10 < 0;
      if (v10 >= 0) {
        uint64_t v12 = v8;
      }
      else {
        uint64_t v12 = (uint64_t *)*v8;
      }
      uint64_t v13 = v10 & 0x7F;
      if (v11) {
        uint64_t v14 = v8[1];
      }
      else {
        uint64_t v14 = v13;
      }
      uint64_t v15 = v429;
      if (v429 < v430)
      {
        *(void *)uint64_t v429 = v12;
        *((void *)v15 + sub_1CD7485C0(this + 1) = v14;
        *(_OWORD *)(v15 + 40) = 0u;
        *((void *)v15 + 2) = v15 + 40;
        uint64_t v16 = v15 + 96;
        *(_OWORD *)(v15 + 24) = 0u;
        *(_OWORD *)(v15 + 56) = 0u;
        *(_OWORD *)(v15 + 72) = 0u;
        v15[88] = 0;
        goto LABEL_28;
      }
      uint64_t v17 = (char *)v428;
      unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((v429 - (unsigned char *)v428) >> 5) + 1;
      if (v18 > 0x2AAAAAAAAAAAAAALL) {
        goto LABEL_663;
      }
      if (0x5555555555555556 * ((v430 - (unsigned char *)v428) >> 5) > v18) {
        unint64_t v18 = 0x5555555555555556 * ((v430 - (unsigned char *)v428) >> 5);
      }
      if (0xAAAAAAAAAAAAAAABLL * ((v430 - (unsigned char *)v428) >> 5) >= 0x155555555555555) {
        unint64_t v19 = 0x2AAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v19 = v18;
      }
      if (v19 > 0x2AAAAAAAAAAAAAALL) {
LABEL_662:
      }
        sub_1CB833614();
      uint64_t v20 = 3 * v19;
      is_absolute = (char *)operator new(96 * v19);
      uint64_t v21 = &is_absolute[32 * ((v429 - (unsigned char *)v428) >> 5)];
      *(void *)uint64_t v21 = v12;
      *((void *)v21 + sub_1CD7485C0(this + 1) = v14;
      *(_OWORD *)(v21 + 40) = 0u;
      unint64_t v22 = &is_absolute[32 * v20];
      *((void *)v21 + 2) = v21 + 40;
      uint64_t v16 = v21 + 96;
      *(_OWORD *)(v21 + 24) = 0u;
      *(_OWORD *)(v21 + 56) = 0u;
      *(_OWORD *)(v21 + 72) = 0u;
      v21[88] = 0;
      if (v15 == v17) {
        break;
      }
      uint64_t v23 = 0;
      do
      {
        unint64_t v24 = &v21[v23];
        uint64_t v25 = &v15[v23];
        long long v26 = *(_OWORD *)&v15[v23 - 96];
        uint64_t v27 = &v21[v23 - 56];
        *(void *)&v21[v23 - 80] = v27;
        is_absolute = &v21[v23 - 80];
        *((_OWORD *)is_absolute - sub_1CD7485C0(this + 1) = v26;
        *((void *)is_absolute + sub_1CD7485C0(this + 1) = 0;
        *((void *)is_absolute + 2) = 0;
        if (*(void *)&v15[v23 - 72]) {
          is_absolute = (char *)sub_1CC1B8518((uint64_t)is_absolute, (uint64_t)(v25 - 80));
        }
        *(void *)uint64_t v27 = 0;
        *(void *)&v21[v23 - 48] = 0;
        *(void *)&v21[v23 - 40] = 0;
        *(_OWORD *)uint64_t v27 = *(_OWORD *)(v25 - 56);
        *((void *)v24 - 5) = *((void *)v25 - 5);
        *((void *)v25 - 7) = 0;
        *((void *)v25 - 6) = 0;
        *((void *)v25 - 5) = 0;
        *((void *)v24 - 4) = 0;
        *((void *)v24 - 3) = 0;
        *((void *)v24 - 2) = 0;
        *((_OWORD *)v24 - 2) = *((_OWORD *)v25 - 2);
        *((void *)v24 - 2) = *((void *)v25 - 2);
        *((void *)v25 - 4) = 0;
        *((void *)v25 - 3) = 0;
        *((void *)v25 - 2) = 0;
        *(v24 - 8) = *(v25 - 8);
        v23 -= 96;
      }
      while (&v15[v23] != v17);
      uint64_t v15 = (char *)v428;
      uint64_t v28 = v429;
      uint64_t v428 = &v21[v23];
      uint64_t v429 = v21 + 96;
      uint64_t v430 = v22;
      if (v28 == v15)
      {
        uint64_t v9 = v422;
LABEL_56:
        if (v15) {
          goto LABEL_27;
        }
        goto LABEL_28;
      }
      uint64_t v9 = v422;
      do
      {
        v28 -= 96;
        sub_1CCCD93D0(v28);
      }
      while (v28 != v15);
      if (v15) {
LABEL_27:
      }
        operator delete(v15);
LABEL_28:
      uint64_t v29 = 0;
      uint64_t v429 = v16;
      unint64_t v31 = (const void *)*((void *)v16 - 12);
      size_t v30 = *((void *)v16 - 11);
      uint64_t v32 = (char **)(v16 - 80);
      *((void *)v16 - 9) = 0;
      if (*((void *)v16 - 8) < v30) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      if (v30)
      {
        is_absolute = (char *)memcpy(*((void **)v16 - 10), v31, v30);
        uint64_t v29 = *((void *)v16 - 9);
      }
      *((void *)v16 - 9) = v29 + v30;
      char v33 = v427[39];
      if (v33 < 0)
      {
        if (*((void *)v427 + 3))
        {
LABEL_35:
          if (v33 >= 0) {
            unsigned int v34 = (unsigned __int8 *)(v427 + 16);
          }
          else {
            unsigned int v34 = (unsigned __int8 *)*((void *)v427 + 2);
          }
          if (v33 >= 0) {
            size_t v35 = v427[39];
          }
          else {
            size_t v35 = *((void *)v427 + 3);
          }
          is_absolute = (char *)llvm::sys::path::replace_path_prefix((const void **)v16 - 10, v34, v35, "", 0, 0);
          if (is_absolute)
          {
            uint64_t v36 = *((void *)v16 - 9);
            if (v36)
            {
              is_absolute = *v32;
              if (**v32 == 47)
              {
                if (v36 != 1)
                {
                  is_absolute = (char *)memmove(is_absolute, is_absolute + 1, v36 - 1);
                  uint64_t v36 = *((void *)v16 - 9);
                }
                size_t v40 = v36 - 1;
              }
              else
              {
                uint64_t v37 = 0;
                char v39 = (const void *)*((void *)v16 - 12);
                size_t v38 = *((void *)v16 - 11);
                *((void *)v16 - 9) = 0;
                if (*((void *)v16 - 8) < v38) {
                  llvm::SmallVectorBase<unsigned long long>::grow_pod();
                }
                if (v38)
                {
                  is_absolute = (char *)memcpy(*((void **)v16 - 10), v39, v38);
                  uint64_t v37 = *((void *)v16 - 9);
                }
                size_t v40 = v37 + v38;
              }
              *((void *)v16 - 9) = v40;
            }
          }
        }
      }
      else if (v427[39])
      {
        goto LABEL_35;
      }
      if (v427[10])
      {
        LOWORD(v445) = 261;
        *(_OWORD *)&v443.__r_.__value_.__l.__data_ = *((_OWORD *)v16 - 5);
        is_absolute = (char *)llvm::sys::path::is_absolute((const char **)&v443.__r_.__value_.__l.__data_, 0);
        if (is_absolute) {
          *(v16 - 8) = 1;
        }
      }
      v8 += 3;
      if (v8 == v9) {
        goto LABEL_63;
      }
    }
    uint64_t v428 = v21;
    uint64_t v430 = &is_absolute[32 * v20];
    goto LABEL_56;
  }
LABEL_63:
  CyclesCount = (llvm *)llvm::outs((llvm *)is_absolute);
  std::string::size_type v405 = CyclesCount;
  uint64_t v45 = a8[24];
  if (v45)
  {
    std::string::size_type v46 = (llvm::GCOVFunction **)*((void *)a8 + 11);
    std::string::size_type v404 = &v46[v45];
    while (1)
    {
      uint64_t v408 = v46;
      long long v47 = *v46;
      Name = llvm::GCOVFunction::getName(*v46, v427[8], v42, v43, v44);
      size_t v433 = v48;
      long long v434 = 0u;
      long long v435 = 0u;
      uint64_t v436 = 0;
      unsigned int v49 = *((_DWORD *)v47 + 20);
      uint64_t v50 = (char *)v428;
      unint64_t v51 = *((unsigned int *)v47 + 5);
      unsigned int v52 = (char *)v428 + 96 * v49;
      unsigned int v55 = (char *)*((void *)v52 + 5);
      uint64_t v54 = v52 + 40;
      unsigned int v53 = v55;
      int v56 = (char **)(v54 + 8);
      long long v57 = (char *)*((void *)v54 + 1);
      int v58 = (char *)(v57 - v55);
      unint64_t v59 = 0xAAAAAAAAAAAAAAABLL * ((v57 - v55) >> 3);
      if (v59 <= v51) {
        break;
      }
LABEL_93:
      unint64_t v82 = &v53[24 * v51];
      int v85 = (llvm::GCOVFunction **)*((void *)v82 + 1);
      uint64_t v83 = v82 + 8;
      unint64_t v84 = v85;
      unint64_t v86 = v83[1];
      if ((unint64_t)v85 >= v86)
      {
        long long v88 = (llvm::GCOVFunction ***)&v53[24 * v51];
        uint64_t v89 = *v88;
        uint64_t v90 = v84 - *v88;
        unint64_t v91 = v90 + 1;
        if ((unint64_t)(v90 + 1) >> 61) {
          goto LABEL_663;
        }
        uint64_t v92 = v86 - (void)v89;
        if (v92 >> 2 > v91) {
          unint64_t v91 = v92 >> 2;
        }
        if ((unint64_t)v92 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v93 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v93 = v91;
        }
        if (v93)
        {
          if (v93 >> 61) {
            goto LABEL_662;
          }
          uint64_t v94 = (char *)operator new(8 * v93);
        }
        else
        {
          uint64_t v94 = 0;
        }
        unint64_t v95 = (llvm::GCOVFunction **)&v94[8 * v90];
        void *v95 = v47;
        int v87 = v95 + 1;
        if (v84 != v89)
        {
          do
          {
            long long v96 = *--v84;
            *--unint64_t v95 = v96;
          }
          while (v84 != v89);
          unint64_t v84 = *v88;
        }
        char *v88 = v95;
        *uint64_t v83 = v87;
        v83[1] = &v94[8 * v93];
        if (v84) {
          operator delete(v84);
        }
      }
      else
      {
        _OWORD *v84 = v47;
        int v87 = v84 + 1;
      }
      *uint64_t v83 = v87;
      v443.__r_.__value_.__r.__words[0] = (std::string::size_type)&v443.__r_.__value_.__r.__words[2];
      v443.__r_.__value_.__l.__size_ = 0x1000000000;
      long long v448 = 0;
      uint64_t v449 = 0;
      v447 = &v448;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p.__r_.__value_.__r.__words[2];
      __p.__r_.__value_.__l.__size_ = 0x1000000000;
      v442[0] = 0;
      v442[1] = 0;
      unint64_t v441 = v442;
      uint64_t v97 = *((unsigned int *)v47 + 24);
      if (v97)
      {
        int v98 = (uint64_t *)*((void *)v47 + 11);
        uint64_t v99 = &v98[v97];
        uint64_t v100 = &v50[96 * v49];
        uint64_t v101 = (char **)(v100 + 64);
        uint64_t v102 = (char **)(v100 + 72);
        v410 = (char **)(v100 + 80);
        int v414 = (char **)(v100 + 72);
        int v418 = v99;
        do
        {
          uint64_t v103 = *v98;
          uint64_t v104 = *(unsigned int *)(*v98 + 88);
          if (v104)
          {
            int v424 = v98;
            uint64_t v105 = *(unsigned int **)(v103 + 80);
            if (v104 != 1)
            {
              size_t v107 = v105 + 1;
              unsigned int v106 = *v105;
              uint64_t v108 = 4 * v104 - 4;
              int v109 = v105 + 1;
              do
              {
                unsigned int v111 = *v109++;
                unsigned int v110 = v111;
                BOOL v112 = v106 >= v111;
                if (v106 <= v111) {
                  unsigned int v106 = v110;
                }
                if (!v112) {
                  uint64_t v105 = v107;
                }
                size_t v107 = v109;
                v108 -= 4;
              }
              while (v108);
            }
            unint64_t v113 = *v105;
            int v114 = *v102;
            int v115 = *v101;
            unint64_t v116 = 0xCCCCCCCCCCCCCCCDLL * ((*v102 - *v101) >> 3);
            if (v116 <= v113)
            {
              unint64_t v117 = (v113 + 1);
              unint64_t v118 = v117 - v116;
              if (v117 <= v116)
              {
                if (v117 < v116)
                {
                  uint64_t v141 = &v115[40 * v117];
                  while (v114 != v141)
                  {
                    char v143 = (char *)*((void *)v114 - 5);
                    v114 -= 40;
                    size_t v142 = v143;
                    if (v114 + 16 != v143) {
                      free(v142);
                    }
                  }
                  long long *v102 = v141;
                }
              }
              else if (0xCCCCCCCCCCCCCCCDLL * ((*v410 - v114) >> 3) >= v118)
              {
                uint64_t v144 = &v114[40 * v118];
                uint64_t v145 = 40 * v117 - 8 * ((*v102 - *v101) >> 3);
                long long v146 = v114 + 16;
                do
                {
                  *long long v146 = 0;
                  v146[1] = 0;
                  v146[2] = 0;
                  *(v146 - 2) = v146;
                  *(v146 - sub_1CD7485C0(this + 1) = 0x100000000;
                  v146 += 5;
                  v145 -= 40;
                }
                while (v145);
                long long *v102 = v144;
              }
              else
              {
                unint64_t v119 = 0xCCCCCCCCCCCCCCCDLL * ((*v410 - v115) >> 3);
                uint64_t v120 = 2 * v119;
                if (2 * v119 <= v117) {
                  uint64_t v120 = v117;
                }
                if (v119 >= 0x333333333333333) {
                  unint64_t v121 = 0x666666666666666;
                }
                else {
                  unint64_t v121 = v120;
                }
                if (v121 > 0x666666666666666) {
                  goto LABEL_662;
                }
                int v122 = (char *)operator new(40 * v121);
                int v123 = &v122[40 * v116];
                int v124 = &v122[40 * v117];
                uint64_t v125 = v123 + 16;
                uint64_t v126 = 40 * v117 - 40 * v116;
                do
                {
                  void *v125 = 0;
                  v125[1] = 0;
                  v125[2] = 0;
                  *(v125 - 2) = v125;
                  *(v125 - sub_1CD7485C0(this + 1) = 0x100000000;
                  v125 += 5;
                  v126 -= 40;
                }
                while (v126);
                int v127 = *v102;
                uint64_t v128 = *v101;
                if (*v102 == *v101)
                {
                  char *v101 = v123;
                  long long *v102 = v124;
                  std::string *v410 = &v122[40 * v121];
                }
                else
                {
                  char v406 = v124;
                  uint64_t v407 = &v122[40 * v121];
                  uint64_t v129 = 0;
                  do
                  {
                    size_t v130 = &v127[v129];
                    uint64_t v131 = &v123[v129];
                    *(void *)&v123[v129 - 40] = &v123[v129 - 24];
                    uint64_t v132 = (void **)&v123[v129 - 40];
                    *(void *)&v123[v129 - 32] = 0x100000000;
                    if (v123 != v127)
                    {
                      unsigned int v133 = *((_DWORD *)v130 - 8);
                      if (v133)
                      {
                        uint64_t v134 = (void *)*((void *)v130 - 5);
                        uint64_t v135 = &v127[v129];
                        uint64_t v136 = (uint64_t)&v127[v129 - 24];
                        if ((void *)v136 == v134)
                        {
                          if (v133 >= 2) {
                            llvm::SmallVectorBase<unsigned int>::grow_pod();
                          }
                          memcpy(*v132, *((const void **)v130 - 5), 8 * *((unsigned int *)v130 - 8));
                          *((_DWORD *)v131 - 8) = v133;
                        }
                        else
                        {
                          *uint64_t v132 = v134;
                          *((_DWORD *)v131 - 8) = v133;
                          *((_DWORD *)v131 - 7) = *((_DWORD *)v135 - 7);
                          *((void *)v130 - 5) = v136;
                          *((_DWORD *)v135 - 7) = 0;
                        }
                        *((_DWORD *)v130 - 8) = 0;
                      }
                    }
                    uint64_t v137 = *((void *)v130 - 2);
                    *(v131 - 8) = *(v130 - 8);
                    *((void *)v131 - 2) = v137;
                    v129 -= 40;
                  }
                  while (&v127[v129] != v128);
                  int v127 = *v101;
                  uint64_t v138 = *v414;
                  char *v101 = &v123[v129];
                  llvm *v414 = v406;
                  std::string *v410 = v407;
                  while (v138 != v127)
                  {
                    uint64_t v140 = (char *)*((void *)v138 - 5);
                    v138 -= 40;
                    size_t v139 = v140;
                    if (v138 + 16 != v140) {
                      free(v139);
                    }
                  }
                }
                if (v127) {
                  operator delete(v127);
                }
              }
            }
            uint64_t v147 = *(unsigned int *)(v103 + 88);
            uint64_t v149 = *((void *)&v434 + 1);
            uint64_t v148 = v434;
            if (v147)
            {
              char v150 = *(int **)(v103 + 80);
              uint64_t v151 = 4 * v147;
              do
              {
                v451.__val_ = 0;
                unsigned int v152 = *v150;
                v451.__val_ = *v150;
                std::string::size_type v153 = *v101;
                unint64_t v154 = sub_1CB8F4B90((uint64_t)&v443, (unsigned int *)&v451);
                uint64_t v155 = *(void *)(v103 + 8);
                if (v155)
                {
                  v149 += ((unint64_t)sub_1CB8F4B90((uint64_t)&__p, (unsigned int *)&v451) >> 32) & 1;
                  uint64_t v155 = *(void *)(v103 + 8);
                }
                std::string::size_type v156 = &v153[40 * v152];
                v156[32] = 1;
                *((void *)v156 + 3) += v155;
                unint64_t v157 = *((unsigned int *)v156 + 2);
                if (v157 >= *((unsigned int *)v156 + 3)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                *(void *)(*(void *)v156 + 8 * v157) = v103;
                v148 += HIDWORD(v154) & 1;
                ++*((_DWORD *)v156 + 2);
                ++v150;
                v151 -= 4;
              }
              while (v151);
            }
            *(void *)&long long v434 = v148;
            *((void *)&v434 + sub_1CD7485C0(this + 1) = v149;
            int v98 = v424;
            uint64_t v102 = v414;
          }
          ++v98;
        }
        while (v98 != v418);
        char v158 = (void *)v442[0];
      }
      else
      {
        char v158 = 0;
      }
      sub_1CB833A08((uint64_t)&v441, v158);
      if ((std::string::size_type *)__p.__r_.__value_.__l.__data_ != &__p.__r_.__value_.__r.__words[2]) {
        free(__p.__r_.__value_.__l.__data_);
      }
      sub_1CB833A08((uint64_t)&v447, v448);
      CyclesCount = (llvm *)v443.__r_.__value_.__r.__words[0];
      if ((std::string::size_type *)v443.__r_.__value_.__l.__data_ != &v443.__r_.__value_.__r.__words[2]) {
        free(v443.__r_.__value_.__l.__data_);
      }
      if (v427[3] && !v427[11])
      {
        uint64_t v159 = *((void *)v405 + 4);
        if ((unint64_t)(*((void *)v405 + 3) - v159) > 9)
        {
          *(_WORD *)(v159 + 8) = 10016;
          *(void *)uint64_t v159 = *(void *)"Function '";
          long long v160 = (_WORD *)(*((void *)v405 + 4) + 10);
          *((void *)v405 + 4) = v160;
        }
        else
        {
          llvm::raw_ostream::write(v405, "Function '", 0xAuLL);
          long long v160 = (_WORD *)*((void *)v405 + 4);
        }
        size_t v161 = v433;
        if (v433 <= *((void *)v405 + 3) - (void)v160)
        {
          if (v433)
          {
            memcpy(v160, Name, v433);
            long long v160 = (_WORD *)(*((void *)v405 + 4) + v161);
            *((void *)v405 + 4) = v160;
          }
        }
        else
        {
          llvm::raw_ostream::write(v405, (const char *)Name, v433);
          long long v160 = (_WORD *)*((void *)v405 + 4);
        }
        if (*((void *)v405 + 3) - (void)v160 > 1uLL)
        {
          _WORD *v160 = 2599;
          *((void *)v405 + 4) += 2;
        }
        else
        {
          llvm::raw_ostream::write(v405, "'\n", 2uLL);
        }
        CyclesCount = sub_1CCCD91DC((uint64_t)&v427, &Name, v405);
        uint64_t v162 = (unsigned char *)*((void *)v405 + 4);
        if ((unint64_t)v162 >= *((void *)v405 + 3))
        {
          CyclesCount = llvm::raw_ostream::write(v405, 10);
        }
        else
        {
          *((void *)v405 + 4) = v162 + 1;
          *uint64_t v162 = 10;
        }
      }
      std::string::size_type v46 = v408 + 1;
      if (v408 + 1 == v404) {
        goto LABEL_191;
      }
    }
    int v423 = (char *)v428;
    unint64_t v60 = (v51 + 1);
    unint64_t v61 = v60 - v59;
    if (v60 <= v59)
    {
      uint64_t v50 = (char *)v428;
      if (v60 < v59)
      {
        BOOL v78 = &v53[24 * v60];
        if (v57 != v78)
        {
          uint64_t v79 = (char *)*((void *)v54 + 1);
          do
          {
            uint64_t v81 = (void *)*((void *)v79 - 3);
            v79 -= 24;
            uint64_t v80 = v81;
            if (v81)
            {
              *((void *)v57 - 2) = v80;
              operator delete(v80);
            }
            long long v57 = v79;
          }
          while (v79 != v78);
        }
        unint64_t *v56 = v78;
      }
      goto LABEL_92;
    }
    std::string::size_type v62 = (char *)v428 + 96 * v49;
    uint64_t v65 = *((void *)v62 + 7);
    size_t v64 = v62 + 56;
    uint64_t v63 = v65;
    if (0xAAAAAAAAAAAAAAABLL * ((v65 - (uint64_t)v57) >> 3) >= v61)
    {
      bzero(v57, 24 * ((24 * v61 - 24) / 0x18) + 24);
      unint64_t *v56 = &v57[24 * ((24 * v61 - 24) / 0x18) + 24];
      uint64_t v50 = v423;
    }
    else
    {
      BOOL v413 = v64;
      unsigned int v417 = *((_DWORD *)v47 + 20);
      unint64_t v66 = 0xAAAAAAAAAAAAAAABLL * ((v63 - (uint64_t)v53) >> 3);
      if (2 * v66 > v60) {
        unint64_t v60 = 2 * v66;
      }
      if (v66 >= 0x555555555555555) {
        unint64_t v60 = 0xAAAAAAAAAAAAAAALL;
      }
      if (v60 > 0xAAAAAAAAAAAAAAALL) {
        goto LABEL_662;
      }
      uint64_t v67 = 3 * v60;
      std::string::size_type v68 = operator new(24 * v60);
      uint64_t v69 = (char *)v68 + 24 * v59;
      uint64_t v70 = (char *)v68 + 8 * v67;
      size_t v71 = 24 * ((24 * v61 - 24) / 0x18) + 24;
      bzero(v69, v71);
      uint64_t v72 = &v58[(void)v68 + v71];
      if (v57 != v53)
      {
        do
        {
          long long v73 = *(_OWORD *)(v57 - 24);
          v57 -= 24;
          *(_OWORD *)(v69 - 24) = v73;
          v69 -= 24;
          *((void *)v69 + 2) = *((void *)v57 + 2);
          *(void *)long long v57 = 0;
          *((void *)v57 + sub_1CD7485C0(this + 1) = 0;
          *((void *)v57 + 2) = 0;
        }
        while (v57 != v53);
        long long v57 = *(char **)v54;
        uint64_t v74 = *v56;
        *(void *)uint64_t v54 = v69;
        unint64_t *v56 = v72;
        *(void *)BOOL v413 = v70;
        unsigned int v49 = v417;
        uint64_t v50 = v423;
        if (v74 != v57)
        {
          uint64_t v75 = v74;
          do
          {
            uint64_t v77 = (void *)*((void *)v75 - 3);
            v75 -= 24;
            uint64_t v76 = v77;
            if (v77)
            {
              *((void *)v74 - 2) = v76;
              operator delete(v76);
            }
            uint64_t v74 = v75;
          }
          while (v75 != v57);
        }
        if (!v57) {
          goto LABEL_92;
        }
        goto LABEL_91;
      }
      *(void *)uint64_t v54 = v69;
      unint64_t *v56 = v72;
      unsigned int v49 = v417;
      *(void *)BOOL v413 = v70;
      uint64_t v50 = v423;
      if (v57) {
LABEL_91:
      }
        operator delete(v57);
    }
LABEL_92:
    LODWORD(v5sub_1CD7485C0(this + 1) = *((_DWORD *)v47 + 5);
    unsigned int v53 = *(char **)v54;
    goto LABEL_93;
  }
LABEL_191:
  BOOL v164 = (char *)v428;
  uint64_t v163 = v429;
  if (v428 != v429)
  {
    std::string::size_type v411 = v429;
    while (v164[88])
    {
LABEL_486:
      v164 += 96;
      if (v164 == v163) {
        goto LABEL_536;
      }
    }
    size_t v165 = *((void *)v164 + 3);
    Name = (void *)*((void *)v164 + 2);
    size_t v433 = v165;
    uint64_t v166 = *((void *)v164 + 8);
    uint64_t v167 = *((void *)v164 + 9);
    uint64_t v415 = (void **)v164;
    long long v168 = v427;
    if (v166 == v167)
    {
      uint64_t v174 = 0;
      uint64_t v205 = 0;
      uint64_t v172 = 0;
      uint64_t v171 = 0;
      uint64_t v170 = 0;
    }
    else
    {
      uint64_t v169 = 0;
      uint64_t v170 = 0;
      uint64_t v171 = 0;
      uint64_t v172 = 0;
      uint64_t v173 = 0;
      uint64_t v174 = 0;
      do
      {
        uint64_t v175 = *(unsigned int *)(v166 + 8);
        if (v175)
        {
          uint64_t v176 = 0;
          std::string::size_type v177 = *(void **)v166;
          uint64_t v178 = *(void *)v166 + 8 * v175;
          int v179 = *(void **)v166;
          do
          {
            uint64_t v180 = (_DWORD *)*v179;
            if (*(_DWORD *)*v179)
            {
              uint64_t v181 = v180[6];
              if (v181)
              {
                uint64_t v182 = *((void *)v180 + 2);
                uint64_t v183 = v182 + 8 * v181;
                do
                {
                  uint64_t v184 = 8 * v175;
                  int v185 = v177;
                  while (*v185 != **(void **)v182)
                  {
                    ++v185;
                    v184 -= 8;
                    if (!v184)
                    {
                      int v185 = (void *)v178;
                      break;
                    }
                  }
                  if (v175 == v185 - v177) {
                    v176 += *(void *)(*(void *)v182 + 24);
                  }
                  v182 += 8;
                }
                while (v182 != v183);
              }
            }
            else
            {
              uint64_t v186 = v180[14];
              if (v186)
              {
                int v187 = (uint64_t *)*((void *)v180 + 6);
                uint64_t v188 = 8 * v186;
                do
                {
                  uint64_t v189 = *v187++;
                  v176 += *(void *)(v189 + 24);
                  v188 -= 8;
                }
                while (v188);
              }
            }
            uint64_t v190 = v180[14];
            if (v190)
            {
              BOOL v191 = (uint64_t *)*((void *)v180 + 6);
              uint64_t v192 = 8 * v190;
              do
              {
                uint64_t v193 = *v191++;
                *(void *)(v193 + 32) = *(void *)(v193 + 24);
                v192 -= 8;
              }
              while (v192);
            }
            ++v179;
          }
          while (v179 != (void *)v178);
        }
        else
        {
          uint64_t v176 = 0;
        }
        CyclesCount = (llvm *)llvm::GCOVBlock::getCyclesCount(v166);
        v194 = (char *)CyclesCount + v176;
        *(void *)(v166 + 24) = (char *)CyclesCount + v176;
        if (*(unsigned char *)(v166 + 32)) {
          BOOL v195 = v194 == 0;
        }
        else {
          BOOL v195 = 1;
        }
        if (!v195) {
          ++v171;
        }
        if (v168[1] && (uint64_t v196 = *(unsigned int *)(v166 + 8), v196))
        {
          v197 = *(void **)v166;
          uint64_t v198 = *(void *)v166 + 8 * v196;
          uint64_t v199 = v194 != 0;
          do
          {
            uint64_t v200 = *v197;
            if (v169 != *(_DWORD *)(*(void *)(*v197 + 80) + 4 * *(unsigned int *)(*v197 + 88) - 4)) {
              goto LABEL_234;
            }
            uint64_t v201 = *(unsigned int *)(v200 + 56);
            if (!v201) {
              goto LABEL_234;
            }
            unsigned int v202 = 0;
            unint64_t v203 = *(uint64_t **)(v200 + 48);
            uint64_t v204 = 8 * v201;
            uint64_t v205 = v173;
            do
            {
              uint64_t v206 = *v203++;
              if (*(void *)(v206 + 24)) {
                ++v202;
              }
              v205 += v199;
              v204 -= 8;
            }
            while (v204);
            if (v201 > 1)
            {
              v172 += v201;
              v174 += v202;
            }
            else
            {
LABEL_234:
              uint64_t v205 = v173;
            }
            ++v197;
            uint64_t v173 = v205;
          }
          while (v197 != (void *)v198);
        }
        else
        {
          uint64_t v205 = v173;
        }
        v170 += *(unsigned __int8 *)(v166 + 32);
        ++v169;
        v166 += 40;
        uint64_t v173 = v205;
      }
      while (v166 != v167);
    }
    *(void *)&long long v434 = v170;
    *((void *)&v434 + sub_1CD7485C0(this + 1) = v171;
    *(void *)&long long v435 = v172;
    *((void *)&v435 + sub_1CD7485C0(this + 1) = v205;
    uint64_t v436 = v174;
    BOOL v164 = (char *)v415;
    unsigned int v208 = *v415;
    std::string::size_type v207 = (std::string::size_type)v415[1];
    if (v168[9])
    {
      if (v207 > 0x7FFFFFFFFFFFFFF7) {
        goto LABEL_663;
      }
      if (v207 >= 0x17)
      {
        uint64_t v216 = (v207 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v207 | 7) != 0x17) {
          uint64_t v216 = v207 | 7;
        }
        uint64_t v217 = v216 + 1;
        p_dst = operator new(v216 + 1);
        __dst.__r_.__value_.__l.__size_ = v207;
        __dst.__r_.__value_.__r.__words[2] = v217 | 0x8000000000000000;
        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
      }
      else
      {
        *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v415[1];
        p_dst = &__dst;
        if (!v207) {
          goto LABEL_270;
        }
      }
      CyclesCount = (llvm *)memmove(p_dst, v208, v207);
LABEL_270:
      *((unsigned char *)p_dst + v207) = 0;
LABEL_306:
      unsigned int v236 = v427;
      if (!v427[11])
      {
        uint64_t v237 = v405;
        uint64_t v238 = *((void *)v405 + 4);
        if ((unint64_t)(*((void *)v405 + 3) - v238) > 5)
        {
          *(_WORD *)(v238 + 4) = 10016;
          *(_DWORD *)uint64_t v238 = 1701603654;
          int v239 = (_WORD *)(*((void *)v405 + 4) + 6);
          *((void *)v405 + 4) = v239;
        }
        else
        {
          llvm::raw_ostream::write(v405, "File '", 6uLL);
          int v239 = (_WORD *)*((void *)v405 + 4);
        }
        size_t v240 = v433;
        if (v433 <= *((void *)v405 + 3) - (void)v239)
        {
          if (v433)
          {
            memcpy(v239, Name, v433);
            uint64_t v237 = v405;
            int v239 = (_WORD *)(*((void *)v405 + 4) + v240);
            *((void *)v405 + 4) = v239;
          }
          else
          {
            uint64_t v237 = v405;
          }
        }
        else
        {
          llvm::raw_ostream::write(v405, (const char *)Name, v433);
          int v239 = (_WORD *)*((void *)v405 + 4);
        }
        if (*((void *)v237 + 3) - (void)v239 > 1uLL)
        {
          *int v239 = 2599;
          *((void *)v237 + 4) += 2;
          unsigned int v236 = v427;
        }
        else
        {
          llvm::raw_ostream::write(v237, "'\n", 2uLL);
        }
        CyclesCount = sub_1CCCD91DC((uint64_t)&v427, &Name, v237);
        if (!v236[9] && !v236[6])
        {
          uint64_t v241 = *((void *)v237 + 4);
          if ((unint64_t)(*((void *)v237 + 3) - v241) > 9)
          {
            *(_WORD *)(v241 + 8) = 10016;
            *(void *)uint64_t v241 = *(void *)"Creating '";
            *((void *)v237 + 4) += 10;
          }
          else
          {
            llvm::raw_ostream::write(v237, "Creating '", 0xAuLL);
          }
          if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v242 = &__dst;
          }
          else {
            uint64_t v242 = (std::string *)__dst.__r_.__value_.__r.__words[0];
          }
          if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            size_t size = *((unsigned char *)&__dst.__r_.__value_.__s + 23) & 0x7F;
          }
          else {
            size_t size = __dst.__r_.__value_.__l.__size_;
          }
          CyclesCount = llvm::raw_ostream::write(v237, (const char *)v242, size);
          int v244 = (_WORD *)*((void *)v237 + 4);
          if (*((void *)v237 + 3) - (void)v244 > 1uLL)
          {
            *int v244 = 2599;
            *((void *)v237 + 4) += 2;
          }
          else
          {
            CyclesCount = llvm::raw_ostream::write(v237, "'\n", 2uLL);
          }
        }
        uint64_t v245 = (unsigned char *)*((void *)v237 + 4);
        if ((unint64_t)v245 >= *((void *)v237 + 3))
        {
          CyclesCount = llvm::raw_ostream::write(v237, 10);
        }
        else
        {
          *((void *)v237 + 4) = v245 + 1;
          *uint64_t v245 = 10;
        }
      }
      if (v236[9] || v236[6]) {
        goto LABEL_483;
      }
      v443.__r_.__value_.__s.__data_[0] = 0;
      LOBYTE(v449) = 0;
      if (v236[11]) {
        goto LABEL_334;
      }
      v451.__val_ = 0;
      v451.__cat_ = std::system_category();
      if ((_BYTE)v449)
      {
        llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)&v443);
        LOBYTE(v449) = 0;
      }
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        unsigned int v333 = &__dst;
      }
      else {
        unsigned int v333 = (std::string *)__dst.__r_.__value_.__r.__words[0];
      }
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v334 = *((unsigned char *)&__dst.__r_.__value_.__s + 23) & 0x7F;
      }
      else {
        uint64_t v334 = __dst.__r_.__value_.__l.__size_;
      }
      CyclesCount = (llvm *)llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)&v443, v333, v334, (uint64_t)&v451, 3);
      LOBYTE(v449) = 1;
      if (v451.__val_)
      {
        size_t v335 = (llvm::raw_ostream *)llvm::errs(CyclesCount);
        std::error_code::message(&__p, &v451);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_p = &__p;
        }
        else {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          size_t v337 = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
        }
        else {
          size_t v337 = __p.__r_.__value_.__l.__size_;
        }
        CyclesCount = llvm::raw_ostream::write(v335, (const char *)p_p, v337);
        unsigned int v338 = (unsigned char *)*((void *)v335 + 4);
        if ((unint64_t)v338 >= *((void *)v335 + 3))
        {
          CyclesCount = llvm::raw_ostream::write(v335, 10);
        }
        else
        {
          *((void *)v335 + 4) = v338 + 1;
          unsigned char *v338 = 10;
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
LABEL_481:
        if ((_BYTE)v449) {
          llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)&v443);
        }
LABEL_483:
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        uint64_t v163 = v411;
        goto LABEL_486;
      }
      if (v236[11]) {
LABEL_334:
      }
        BOOL v246 = (llvm::raw_ostream *)llvm::outs(CyclesCount);
      else {
        BOOL v246 = (llvm::raw_ostream *)&v443;
      }
      if (v236[6])
      {
        *(_OWORD *)&v437.__r_.__value_.__l.__data_ = 0uLL;
LABEL_337:
        v437.__r_.__value_.__r.__words[2] = 0;
LABEL_344:
        int v256 = (void *)*((void *)v246 + 4);
        if (*((void *)v246 + 3) - (void)v256 > 0x16uLL)
        {
          qmemcpy(v256, "        -:    0:Source:", 23);
          *((void *)v246 + 4) += 23;
        }
        else
        {
          llvm::raw_ostream::write(v246, "        -:    0:Source:", 0x17uLL);
        }
        llvm::raw_ostream::write(v246, (const char *)v415[2], (size_t)v415[3]);
        uint64_t v257 = (unsigned char *)*((void *)v246 + 4);
        if ((unint64_t)v257 >= *((void *)v246 + 3))
        {
          llvm::raw_ostream::write(v246, 10);
        }
        else
        {
          *((void *)v246 + 4) = v257 + 1;
          *uint64_t v257 = 10;
        }
        BOOL v258 = (void *)*((void *)v246 + 4);
        if (*((void *)v246 + 3) - (void)v258 > 0x15uLL)
        {
          qmemcpy(v258, "        -:    0:Graph:", 22);
          int v259 = (unsigned char *)(*((void *)v246 + 4) + 22);
          *((void *)v246 + 4) = v259;
        }
        else
        {
          llvm::raw_ostream::write(v246, "        -:    0:Graph:", 0x16uLL);
          int v259 = (unsigned char *)*((void *)v246 + 4);
        }
        if (a5 <= *((void *)v246 + 3) - (void)v259)
        {
          if (a5)
          {
            memcpy(v259, a4, a5);
            int v259 = (unsigned char *)(*((void *)v246 + 4) + a5);
            *((void *)v246 + 4) = v259;
          }
        }
        else
        {
          llvm::raw_ostream::write(v246, (const char *)a4, a5);
          int v259 = (unsigned char *)*((void *)v246 + 4);
        }
        if ((unint64_t)v259 >= *((void *)v246 + 3))
        {
          llvm::raw_ostream::write(v246, 10);
        }
        else
        {
          *((void *)v246 + 4) = v259 + 1;
          *int v259 = 10;
        }
        unsigned int v260 = (void *)*((void *)v246 + 4);
        if (*((void *)v246 + 3) - (void)v260 > 0x14uLL)
        {
          qmemcpy(v260, "        -:    0:Data:", 21);
          uint64_t v261 = (unsigned char *)(*((void *)v246 + 4) + 21);
          *((void *)v246 + 4) = v261;
        }
        else
        {
          llvm::raw_ostream::write(v246, "        -:    0:Data:", 0x15uLL);
          uint64_t v261 = (unsigned char *)*((void *)v246 + 4);
        }
        if (a7 <= *((void *)v246 + 3) - (void)v261)
        {
          if (a7)
          {
            memcpy(v261, a6, a7);
            uint64_t v261 = (unsigned char *)(*((void *)v246 + 4) + a7);
            *((void *)v246 + 4) = v261;
          }
        }
        else
        {
          llvm::raw_ostream::write(v246, (const char *)a6, a7);
          uint64_t v261 = (unsigned char *)*((void *)v246 + 4);
        }
        if ((unint64_t)v261 >= *((void *)v246 + 3))
        {
          llvm::raw_ostream::write(v246, 10);
        }
        else
        {
          *((void *)v246 + 4) = v261 + 1;
          *uint64_t v261 = 10;
        }
        uint64_t v262 = (void *)*((void *)v246 + 4);
        if (*((void *)v246 + 3) - (void)v262 > 0x14uLL)
        {
          qmemcpy(v262, "        -:    0:Runs:", 21);
          *((void *)v246 + 4) += 21;
        }
        else
        {
          llvm::raw_ostream::write(v246, "        -:    0:Runs:", 0x15uLL);
        }
        sub_1CD098D14(v246, a8[64], 0, 0, 0);
        uint64_t v266 = (unsigned char *)*((void *)v246 + 4);
        if ((unint64_t)v266 >= *((void *)v246 + 3))
        {
          llvm::raw_ostream::write(v246, 10);
        }
        else
        {
          *((void *)v246 + 4) = v266 + 1;
          *uint64_t v266 = 10;
        }
        if (a8[15] <= 3)
        {
          BOOL v267 = (void *)*((void *)v246 + 4);
          if (*((void *)v246 + 3) - (void)v267 > 0x18uLL)
          {
            qmemcpy(v267, "        -:    0:Programs:", 25);
            *((void *)v246 + 4) += 25;
          }
          else
          {
            llvm::raw_ostream::write(v246, "        -:    0:Programs:", 0x19uLL);
          }
          sub_1CD098D14(v246, a8[65], 0, 0, 0);
          int v268 = (unsigned char *)*((void *)v246 + 4);
          if ((unint64_t)v268 >= *((void *)v246 + 3))
          {
            llvm::raw_ostream::write(v246, 10);
          }
          else
          {
            *((void *)v246 + 4) = v268 + 1;
            *int v268 = 10;
          }
        }
        if (v437.__r_.__value_.__r.__words[2])
        {
          unint64_t v269 = 1;
          while (v269 >= 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)v164 + 9) - *((void *)v164 + 8)) >> 3))
          {
            BOOL v303 = (void *)*((void *)v246 + 4);
            if (*((void *)v246 + 3) - (void)v303 > 9uLL)
            {
              qmemcpy(v303, "        -:", 10);
              *((void *)v246 + 4) += 10;
            }
            else
            {
              llvm::raw_ostream::write(v246, "        -:", 0xAuLL);
            }
            sub_1CCCD9844((uint64_t)&v437, v246, v269);
LABEL_473:
            ++v269;
            BOOL v164 = (char *)v415;
            if (!v437.__r_.__value_.__r.__words[2]) {
              goto LABEL_479;
            }
          }
          uint64_t v419 = *((void *)v164 + 8);
          unint64_t v425 = v269;
          uint64_t v270 = v427;
          if (v427[1])
          {
            int v271 = v415[5];
            if (v269 < 0xAAAAAAAAAAAAAAABLL * (((unsigned char *)v415[6] - v271) >> 3))
            {
              int v272 = (unsigned int ***)&v271[24 * v269];
              uint64_t v274 = *v272;
              BOOL v273 = v272[1];
              if (v274 != v273)
              {
                BOOL v275 = v273;
                do
                {
                  uint64_t v276 = *v274;
                  uint64_t v277 = (uint64_t *)*((void *)*v274 + 11);
                  BOOL v279 = v277 + 1;
                  v278 = (_DWORD *)*v277;
                  uint64_t v280 = (*v274)[24];
                  if (*(int *)(*(void *)*v274 + 60) < 2) {
                    BOOL v279 = &v277[v280 - 1];
                  }
                  uint64_t v281 = *v279;
                  uint64_t v282 = *(unsigned int *)(v281 + 24);
                  if (v282)
                  {
                    uint64_t v283 = 0;
                    std::string::size_type v284 = *(uint64_t **)(v281 + 16);
                    uint64_t v285 = 8 * v282;
                    do
                    {
                      uint64_t v286 = *v284++;
                      v283 += *(void *)(v286 + 24);
                      v285 -= 8;
                    }
                    while (v285);
                  }
                  else
                  {
                    uint64_t v283 = 0;
                  }
                  unsigned int v287 = 0;
                  if (v280)
                  {
                    uint64_t v288 = 8 * v280;
                    do
                    {
                      BOOL v289 = *v277 == v281 || *(_DWORD *)*v277 == 0;
                      if (!v289 && *(void *)(*v277 + 8)) {
                        ++v287;
                      }
                      ++v277;
                      v288 -= 8;
                    }
                    while (v288);
                  }
                  unint64_t v290 = *((void *)v278 + 1);
                  uint64_t v291 = *((void *)v246 + 4);
                  if ((unint64_t)(*((void *)v246 + 3) - v291) > 8)
                  {
                    *(unsigned char *)(v291 + 8) = 32;
                    *(void *)uint64_t v291 = *(void *)"function ";
                    *((void *)v246 + 4) += 9;
                  }
                  else
                  {
                    llvm::raw_ostream::write(v246, "function ", 9uLL);
                  }
                  std::string::size_type v293 = llvm::GCOVFunction::getName((llvm::GCOVFunction *)v276, v270[8], v263, v264, v265);
                  size_t v294 = v292;
                  char v295 = (void *)*((void *)v246 + 4);
                  if (v292 <= *((void *)v246 + 3) - (void)v295)
                  {
                    if (v292)
                    {
                      memcpy(v295, v293, v292);
                      char v295 = (void *)(*((void *)v246 + 4) + v294);
                      *((void *)v246 + 4) = v295;
                    }
                  }
                  else
                  {
                    llvm::raw_ostream::write(v246, (const char *)v293, v292);
                    char v295 = (void *)*((void *)v246 + 4);
                  }
                  if (*((void *)v246 + 3) - (void)v295 > 7uLL)
                  {
                    *char v295 = 0x2064656C6C616320;
                    *((void *)v246 + 4) += 8;
                  }
                  else
                  {
                    llvm::raw_ostream::write(v246, " called ", 8uLL);
                  }
                  sub_1CD098D14(v246, v290, 0, 0, 0);
                  uint64_t v296 = *((void *)v246 + 4);
                  if ((unint64_t)(*((void *)v246 + 3) - v296) > 9)
                  {
                    *(_WORD *)(v296 + 8) = 8292;
                    *(void *)uint64_t v296 = *(void *)" returned ";
                    *((void *)v246 + 4) += 10;
                  }
                  else
                  {
                    llvm::raw_ostream::write(v246, " returned ", 0xAuLL);
                  }
                  unint64_t v297 = 0;
                  if (v290 && v283)
                  {
                    if (100 * v283 >= v290) {
                      unint64_t v297 = (100 * v283 / v290);
                    }
                    else {
                      unint64_t v297 = 1;
                    }
                  }
                  sub_1CD098D14(v246, v297, 0, 0, 0);
                  uint64_t v298 = *((void *)v246 + 4);
                  if ((unint64_t)(*((void *)v246 + 3) - v298) > 0x11)
                  {
                    *(_WORD *)(v298 + 16) = 8292;
                    *(_OWORD *)uint64_t v298 = *(_OWORD *)"% blocks executed ";
                    *((void *)v246 + 4) += 18;
                  }
                  else
                  {
                    llvm::raw_ostream::write(v246, "% blocks executed ", 0x12uLL);
                  }
                  unint64_t v299 = 0;
                  if (v287)
                  {
                    unint64_t v300 = v276[24] - 2;
                    unint64_t v269 = v425;
                    if (v300)
                    {
                      unint64_t v301 = 100 * v287;
                      if (v301 >= v300) {
                        unint64_t v299 = (v301 / v300);
                      }
                      else {
                        unint64_t v299 = 1;
                      }
                    }
                  }
                  else
                  {
                    unint64_t v269 = v425;
                  }
                  sub_1CD098D14(v246, v299, 0, 0, 0);
                  std::string::size_type v302 = (_WORD *)*((void *)v246 + 4);
                  if (*((void *)v246 + 3) - (void)v302 > 1uLL)
                  {
                    *std::string::size_type v302 = 2597;
                    *((void *)v246 + 4) += 2;
                  }
                  else
                  {
                    llvm::raw_ostream::write(v246, "%\n", 2uLL);
                  }
                  ++v274;
                }
                while (v274 != v275);
              }
            }
          }
          if (*(unsigned char *)(v419 + 40 * v269 + 32))
          {
            std::string::size_type v304 = *(void *)(v419 + 40 * v269 + 24);
            if (v304)
            {
              __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1F25FF808;
              __p.__r_.__value_.__l.__size_ = (std::string::size_type)"%9llu:";
              __p.__r_.__value_.__r.__words[2] = v304;
              llvm::raw_ostream::operator<<(v246, (uint64_t)&__p);
              goto LABEL_444;
            }
            uint64_t v305 = *((void *)v246 + 4);
            if ((unint64_t)(*((void *)v246 + 3) - v305) <= 9)
            {
              size_t v306 = v246;
              BOOL v307 = "    #####:";
LABEL_443:
              llvm::raw_ostream::write(v306, v307, 0xAuLL);
LABEL_444:
              v308 = (uint64_t **)(v419 + 40 * v269);
              sub_1CCCD9844((uint64_t)&v437, v246, v269);
              uint64_t v309 = *((unsigned int *)v308 + 2);
              if (v309)
              {
                int v310 = 0;
                unsigned int v311 = 0;
                uint64_t v312 = *v308;
                uint64_t v313 = (uint64_t)&(*v308)[v309];
                do
                {
                  uint64_t v314 = *v312;
                  if (v269 == *(_DWORD *)(*(void *)(*v312 + 80) + 4 * *(unsigned int *)(*v312 + 88) - 4))
                  {
                    if (*v270)
                    {
                      std::string::size_type v315 = *(void *)(v314 + 8);
                      if (v315)
                      {
                        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1F25FF808;
                        __p.__r_.__value_.__l.__size_ = (std::string::size_type)"%9llu:";
                        __p.__r_.__value_.__r.__words[2] = v315;
                        llvm::raw_ostream::operator<<(v246, (uint64_t)&__p);
                      }
                      else
                      {
                        uint64_t v316 = *((void *)v246 + 4);
                        if ((unint64_t)(*((void *)v246 + 3) - v316) > 9)
                        {
                          *(_WORD *)(v316 + 8) = 14884;
                          *(void *)uint64_t v316 = *(void *)"    $$$$$:";
                          *((void *)v246 + 4) += 10;
                        }
                        else
                        {
                          llvm::raw_ostream::write(v246, "    $$$$$:", 0xAuLL);
                        }
                      }
                      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1F2608AD8;
                      __p.__r_.__value_.__l.__size_ = (std::string::size_type)"%5u-block %2u\n";
                      __p.__r_.__value_.__r.__words[2] = v269;
                      int v439 = v310;
                      llvm::raw_ostream::operator<<(v246, (uint64_t)&__p);
                      ++v310;
                    }
                    if (v270[1])
                    {
                      uint64_t v317 = *(unsigned int *)(v314 + 56);
                      if (v317 < 2)
                      {
                        if (v317 == 1 && v270[5] != 0)
                        {
                          size_t v329 = *(const std::error_category **)(**(void **)(v314 + 48) + 24);
                          __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1F25FED10;
                          __p.__r_.__value_.__l.__size_ = (std::string::size_type)"unconditional %2u ";
                          __p.__r_.__value_.__r.__words[2] = v311;
                          BOOL v330 = llvm::raw_ostream::operator<<(v246, (uint64_t)&__p);
                          *(void *)&v451.__val_ = v270;
                          v451.__cat_ = v329;
                          unint64_t v452 = v329;
                          sub_1CCCD99B0(v330, (unint64_t *)&v451);
                          BOOL v331 = (unsigned char *)*((void *)v246 + 4);
                          if ((unint64_t)v331 >= *((void *)v246 + 3))
                          {
                            llvm::raw_ostream::write(v246, 10);
                          }
                          else
                          {
                            *((void *)v246 + 4) = v331 + 1;
                            unsigned char *v331 = 10;
                          }
                          ++v311;
                        }
                      }
                      else
                      {
                        int v420 = v310;
                        BOOL v318 = 0;
                        int v319 = *(uint64_t **)(v314 + 48);
                        uint64_t v320 = 8 * v317;
                        uint64_t v321 = 8 * v317;
                        BOOL v322 = v319;
                        do
                        {
                          uint64_t v323 = *v322++;
                          BOOL v318 = (const std::error_category *)((char *)v318 + *(void *)(v323 + 24));
                          v321 -= 8;
                        }
                        while (v321);
                        do
                        {
                          uint64_t v324 = *v319;
                          __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1F25FED10;
                          __p.__r_.__value_.__l.__size_ = (std::string::size_type)"branch %2u ";
                          __p.__r_.__value_.__r.__words[2] = v311;
                          BOOL v325 = llvm::raw_ostream::operator<<(v246, (uint64_t)&__p);
                          size_t v326 = *(const std::error_category **)(v324 + 24);
                          *(void *)&v451.__val_ = v270;
                          v451.__cat_ = v326;
                          unint64_t v452 = v318;
                          sub_1CCCD99B0(v325, (unint64_t *)&v451);
                          unint64_t v327 = (unsigned char *)*((void *)v246 + 4);
                          if ((unint64_t)v327 >= *((void *)v246 + 3))
                          {
                            llvm::raw_ostream::write(v246, 10);
                          }
                          else
                          {
                            *((void *)v246 + 4) = v327 + 1;
                            *unint64_t v327 = 10;
                          }
                          ++v319;
                          ++v311;
                          v320 -= 8;
                        }
                        while (v320);
                        unint64_t v269 = v425;
                        int v310 = v420;
                      }
                    }
                  }
                  ++v312;
                }
                while (v312 != (uint64_t *)v313);
              }
              goto LABEL_473;
            }
            *(_WORD *)(v305 + 8) = 14883;
            uint64_t v332 = *(void *)"    #####:";
          }
          else
          {
            uint64_t v305 = *((void *)v246 + 4);
            if ((unint64_t)(*((void *)v246 + 3) - v305) <= 9)
            {
              size_t v306 = v246;
              BOOL v307 = "        -:";
              goto LABEL_443;
            }
            *(_WORD *)(v305 + 8) = 14893;
            uint64_t v332 = 0x2020202020202020;
          }
          *(void *)uint64_t v305 = v332;
          *((void *)v246 + 4) += 10;
          goto LABEL_444;
        }
LABEL_479:
        CyclesCount = (llvm *)v437.__r_.__value_.__r.__words[0];
        if (v437.__r_.__value_.__r.__words[0]) {
          CyclesCount = (llvm *)(*(uint64_t (**)(std::string::size_type))(*(void *)v437.__r_.__value_.__l.__data_
        }
                                                                                  + 8))(v437.__r_.__value_.__r.__words[0]);
        goto LABEL_481;
      }
      BOOL v248 = *v415;
      std::string::size_type v247 = (std::string::size_type)v415[1];
      memset(&v437, 0, sizeof(v437));
      __int16 v440 = 261;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v248;
      __p.__r_.__value_.__l.__size_ = v247;
      llvm::MemoryBuffer::getFileOrSTDIN((llvm::MemoryBuffer *)&__p, 0, 0, (uint64_t)&v451);
      if (v452)
      {
        std::string::size_type v251 = *(void *)&v451.__val_;
        std::error_code v450 = v451;
        if (v451.__val_)
        {
          uint64_t v252 = (llvm::raw_ostream *)llvm::errs(v249);
          BOOL v253 = (_WORD *)*((void *)v252 + 4);
          if (v247 <= *((void *)v252 + 3) - (void)v253)
          {
            if (v247)
            {
              memcpy(v253, v248, v247);
              BOOL v253 = (_WORD *)(*((void *)v252 + 4) + v247);
              *((void *)v252 + 4) = v253;
            }
          }
          else
          {
            llvm::raw_ostream::write(v252, (const char *)v248, v247);
            BOOL v253 = (_WORD *)*((void *)v252 + 4);
          }
          if (*((void *)v252 + 3) - (void)v253 > 1uLL)
          {
            *BOOL v253 = 8250;
            *((void *)v252 + 4) += 2;
          }
          else
          {
            llvm::raw_ostream::write(v252, ": ", 2uLL);
          }
          std::error_code::message(&__p, &v450);
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v339 = &__p;
          }
          else {
            uint64_t v339 = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            size_t v340 = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
          }
          else {
            size_t v340 = __p.__r_.__value_.__l.__size_;
          }
          llvm::raw_ostream::write(v252, (const char *)v339, v340);
          uint64_t v341 = (unsigned char *)*((void *)v252 + 4);
          if (*((unsigned char **)v252 + 3) == v341)
          {
            llvm::raw_ostream::write(v252, "\n", 1uLL);
          }
          else
          {
            *uint64_t v341 = 10;
            ++*((void *)v252 + 4);
          }
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          v437.__r_.__value_.__l.__size_ = (std::string::size_type)"";
          goto LABEL_337;
        }
      }
      else
      {
        unsigned int v250 = std::system_category();
        *(void *)&v450.__val_ = 0;
        v450.__cat_ = v250;
        std::string::size_type v251 = *(void *)&v451.__val_;
      }
      std::string::size_type v254 = *(void *)(v251 + 8);
      std::string::size_type v255 = *(void *)(v251 + 16) - v254;
      v437.__r_.__value_.__r.__words[0] = v251;
      v437.__r_.__value_.__l.__size_ = v254;
      v437.__r_.__value_.__r.__words[2] = v255;
      goto LABEL_344;
    }
    memset(&__dst, 0, sizeof(__dst));
    if (v168[7] && ((char *)v207 != a3 || a3 && memcmp(v208, a2, (size_t)a3)))
    {
      sub_1CCCD94EC(&v443, a2, a3, v168[4]);
      size_t v210 = std::string::append(&v443, "##");
      std::string::size_type v211 = v210->__r_.__value_.__r.__words[0];
      __p.__r_.__value_.__r.__words[0] = v210->__r_.__value_.__l.__size_;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v210->__r_.__value_.__r.__words[1] + 7);
      char v212 = HIBYTE(v210->__r_.__value_.__r.__words[2]);
      v210->__r_.__value_.__l.__size_ = 0;
      v210->__r_.__value_.__r.__words[2] = 0;
      v210->__r_.__value_.__r.__words[0] = 0;
      __dst.__r_.__value_.__r.__words[0] = v211;
      *(std::string::size_type *)((char *)&__dst.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 7);
      __dst.__r_.__value_.__l.__size_ = __p.__r_.__value_.__r.__words[0];
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v212;
      if (SHIBYTE(v443.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v443.__r_.__value_.__l.__data_);
      }
    }
    sub_1CCCD94EC(&v443, (char *)v208, (char *)v207, v168[4]);
    if ((v443.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unsigned int v213 = &v443;
    }
    else {
      unsigned int v213 = (std::string *)v443.__r_.__value_.__r.__words[0];
    }
    if ((v443.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v214 = *((unsigned char *)&v443.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      std::string::size_type v214 = v443.__r_.__value_.__l.__size_;
    }
    std::string::append(&__dst, (const std::string::value_type *)v213, v214);
    if (SHIBYTE(v443.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v443.__r_.__value_.__l.__data_);
    }
    if (!v168[12])
    {
LABEL_305:
      CyclesCount = (llvm *)std::string::append(&__dst, ".gcov");
      goto LABEL_306;
    }
    *(_OWORD *)&v443.__r_.__value_.__l.__data_ = xmmword_1CFAC4320;
    v443.__r_.__value_.__r.__words[2] = 0;
    if (!v208)
    {
      std::string::size_type v218 = 0;
      std::string::size_type v219 = 0;
      char v220 = 0;
      memset(&__p, 0, sizeof(__p));
      goto LABEL_277;
    }
    if (v207 > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_663;
    }
    if (v207 >= 0x17)
    {
      uint64_t v221 = (v207 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v207 | 7) != 0x17) {
        uint64_t v221 = v207 | 7;
      }
      uint64_t v222 = v221 + 1;
      uint64_t v215 = (std::string *)operator new(v221 + 1);
      __p.__r_.__value_.__l.__size_ = v207;
      __p.__r_.__value_.__r.__words[2] = v222 | 0x8000000000000000;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v215;
    }
    else
    {
      *((unsigned char *)&__p.__r_.__value_.__s + 23) = v207;
      uint64_t v215 = &__p;
      if (!v207) {
        goto LABEL_276;
      }
    }
    memmove(v215, v208, v207);
LABEL_276:
    v215->__r_.__value_.__s.__data_[v207] = 0;
    char v220 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    std::string::size_type v218 = __p.__r_.__value_.__l.__size_;
    std::string::size_type v219 = __p.__r_.__value_.__r.__words[0];
LABEL_277:
    int v223 = v220;
    if (v220 >= 0) {
      v224 = (int *)&__p;
    }
    else {
      v224 = (int *)v219;
    }
    size_t v225 = v220 & 0x7F;
    if (v223 >= 0) {
      size_t v226 = v225;
    }
    else {
      size_t v226 = v218;
    }
    llvm::MD5::update((int *)&v443, v224, v226);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    llvm::MD5::final((int *)&v443, &v450.__val_);
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v439;
    *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = xmmword_1CDC7F9D0;
    sub_1CC223B30((unsigned __int8 *)&v450, 16, 1, &__p);
    std::string::size_type v227 = __p.__r_.__value_.__l.__size_;
    if (__p.__r_.__value_.__l.__size_ > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_663;
    }
    BOOL v228 = (const void *)__p.__r_.__value_.__r.__words[0];
    if (__p.__r_.__value_.__l.__size_ >= 0x17)
    {
      std::string::size_type v230 = (__p.__r_.__value_.__l.__size_ & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((__p.__r_.__value_.__l.__size_ | 7) != 0x17) {
        std::string::size_type v230 = __p.__r_.__value_.__l.__size_ | 7;
      }
      std::string::size_type v231 = v230 + 1;
      size_t v229 = operator new(v230 + 1);
      v437.__r_.__value_.__l.__size_ = v227;
      v437.__r_.__value_.__r.__words[2] = v231 | 0x8000000000000000;
      v437.__r_.__value_.__r.__words[0] = (std::string::size_type)v229;
    }
    else
    {
      *((unsigned char *)&v437.__r_.__value_.__s + 23) = __p.__r_.__value_.__s.__data_[8];
      size_t v229 = &v437;
      if (!__p.__r_.__value_.__l.__size_) {
        goto LABEL_293;
      }
    }
    memmove(v229, v228, v227);
LABEL_293:
    *((unsigned char *)v229 + v227) = 0;
    unsigned int v232 = std::string::insert(&v437, 0, "##");
    int v233 = (const std::error_category *)v232->__r_.__value_.__r.__words[2];
    std::error_code v451 = *(std::error_code *)&v232->__r_.__value_.__l.__data_;
    unint64_t v452 = v233;
    v232->__r_.__value_.__l.__size_ = 0;
    v232->__r_.__value_.__r.__words[2] = 0;
    v232->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v452) >= 0) {
      BOOL v234 = &v451;
    }
    else {
      BOOL v234 = *(std::error_code **)&v451.__val_;
    }
    if (SHIBYTE(v452) >= 0) {
      cat = (const std::error_category *)(HIBYTE(v452) & 0x7F);
    }
    else {
      cat = v451.__cat_;
    }
    std::string::append(&__dst, (const std::string::value_type *)v234, (std::string::size_type)cat);
    if (SHIBYTE(v452) < 0) {
      operator delete(*(void **)&v451.__val_);
    }
    if (SHIBYTE(v437.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v437.__r_.__value_.__l.__data_);
    }
    if ((int *)__p.__r_.__value_.__l.__data_ != &v439) {
      free(__p.__r_.__value_.__l.__data_);
    }
    goto LABEL_305;
  }
LABEL_536:
  if (v427[6] && !v427[9])
  {
    size_t v444 = 0;
    v443.__r_.__value_.__r.__words[0] = (std::string::size_type)a2;
    *(_OWORD *)&v443.__r_.__value_.__r.__words[1] = (unint64_t)a3;
    uint64_t v445 = a3;
    int v446 = 0;
    llvm::sys::path::reverse_iterator::operator++((uint64_t)&v443);
    std::string::size_type v344 = v444;
    if (v444 > 0x7FFFFFFFFFFFFFF7) {
LABEL_663:
    }
      abort();
    uint64_t v345 = (const void *)v443.__r_.__value_.__r.__words[2];
    if (v444 >= 0x17)
    {
      size_t v347 = (v444 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v444 | 7) != 0x17) {
        size_t v347 = v444 | 7;
      }
      size_t v348 = v347 + 1;
      uint64_t v346 = (std::string *)operator new(v347 + 1);
      __p.__r_.__value_.__l.__size_ = v344;
      __p.__r_.__value_.__r.__words[2] = v348 | 0x8000000000000000;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v346;
    }
    else
    {
      *((unsigned char *)&__p.__r_.__value_.__s + 23) = v444;
      uint64_t v346 = &__p;
      if (!v444) {
        goto LABEL_552;
      }
    }
    memmove(v346, v345, v344);
LABEL_552:
    v346->__r_.__value_.__s.__data_[v344] = 0;
    v451.__val_ = 0;
    v451.__cat_ = std::system_category();
    int v349 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      size_t v350 = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      size_t v350 = __p.__r_.__value_.__l.__size_;
    }
    sub_1CB907098((uint64_t)&Name, v350 + 5);
    if ((SBYTE7(v434) & 0x80u) == 0) {
      p_Name = &Name;
    }
    else {
      p_Name = (void **)Name;
    }
    if (v350)
    {
      if (v349 >= 0) {
        unsigned int v352 = &__p;
      }
      else {
        unsigned int v352 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(p_Name, v352, v350);
    }
    strcpy((char *)p_Name + v350, ".gcov");
    if ((SBYTE7(v434) & 0x80u) == 0) {
      int v353 = &Name;
    }
    else {
      int v353 = (void **)Name;
    }
    if ((SBYTE7(v434) & 0x80u) == 0) {
      uint64_t v354 = BYTE7(v434) & 0x7F;
    }
    else {
      uint64_t v354 = v433;
    }
    int v355 = (llvm *)llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)&v443, v353, v354, (uint64_t)&v451, 3);
    if (SBYTE7(v434) < 0) {
      operator delete(Name);
    }
    int v409 = v349;
    if (v451.__val_)
    {
      uint64_t v393 = (llvm::raw_ostream *)llvm::errs(v355);
      std::error_code::message((std::string *)&Name, &v451);
      if ((SBYTE7(v434) & 0x80u) == 0) {
        v394 = (const char *)&Name;
      }
      else {
        v394 = (const char *)Name;
      }
      if ((SBYTE7(v434) & 0x80u) == 0) {
        size_t v395 = BYTE7(v434) & 0x7F;
      }
      else {
        size_t v395 = v433;
      }
      llvm::raw_ostream::write(v393, v394, v395);
      uint64_t v396 = (unsigned char *)*((void *)v393 + 4);
      if ((unint64_t)v396 >= *((void *)v393 + 3))
      {
        llvm::raw_ostream::write(v393, 10);
      }
      else
      {
        *((void *)v393 + 4) = v396 + 1;
        *uint64_t v396 = 10;
      }
      if (SBYTE7(v434) < 0) {
        operator delete(Name);
      }
    }
    else
    {
      int v421 = (const void **)v428;
      std::string::size_type v412 = (const void **)v429;
      if (v428 != v429)
      {
        BOOL v356 = v427;
        do
        {
          uint64_t v357 = v445;
          if (v444 - (unint64_t)v445 > 4)
          {
            *((unsigned char *)v445 + 4) = 58;
            *uint64_t v357 = 1701603686;
            uint64_t v358 = (char *)v445 + 5;
            uint64_t v445 = (char *)v445 + 5;
          }
          else
          {
            llvm::raw_ostream::write((llvm::raw_ostream *)&v443, "file:", 5uLL);
            uint64_t v358 = v445;
          }
          BOOL v359 = *v421;
          size_t v360 = (size_t)v421[1];
          if (v360 <= v444 - (unint64_t)v358)
          {
            if (v360)
            {
              memcpy(v358, v359, (size_t)v421[1]);
              uint64_t v358 = (char *)v445 + v360;
              uint64_t v445 = (char *)v445 + v360;
            }
          }
          else
          {
            llvm::raw_ostream::write((llvm::raw_ostream *)&v443, (const char *)v359, (size_t)v421[1]);
            uint64_t v358 = v445;
          }
          if ((unint64_t)v358 >= v444)
          {
            llvm::raw_ostream::write((llvm::raw_ostream *)&v443, 10);
          }
          else
          {
            uint64_t v445 = v358 + 1;
            *uint64_t v358 = 10;
          }
          int v361 = (uint64_t **)v421[5];
          unsigned int v362 = (uint64_t **)v421[6];
          while (v361 != v362)
          {
            BOOL v363 = *v361;
            uint64_t v364 = v361[1];
            while (v363 != v364)
            {
              uint64_t v365 = *v363;
              v366 = v445;
              if (v444 - (unint64_t)v445 > 8)
              {
                *((unsigned char *)v445 + 8) = 58;
                void *v366 = *(void *)"function:";
                uint64_t v445 = (char *)v445 + 9;
              }
              else
              {
                llvm::raw_ostream::write((llvm::raw_ostream *)&v443, "function:", 9uLL);
              }
              sub_1CD098D14((llvm::raw_ostream *)&v443, *(unsigned int *)(v365 + 20), 0, 0, 0);
              uint64_t v367 = v445;
              if ((unint64_t)v445 >= v444)
              {
                llvm::raw_ostream::write((llvm::raw_ostream *)&v443, 44);
              }
              else
              {
                uint64_t v445 = (char *)v445 + 1;
                *uint64_t v367 = 44;
              }
              sub_1CD098D14((llvm::raw_ostream *)&v443, *(void *)(**(void **)(v365 + 88) + 8), 0, 0, 0);
              unint64_t v371 = v445;
              if ((unint64_t)v445 >= v444)
              {
                llvm::raw_ostream::write((llvm::raw_ostream *)&v443, 44);
              }
              else
              {
                uint64_t v445 = (char *)v445 + 1;
                *unint64_t v371 = 44;
              }
              BOOL v373 = llvm::GCOVFunction::getName((llvm::GCOVFunction *)v365, v356[8], v368, v369, v370);
              size_t v374 = v372;
              v375 = (char *)v445;
              if (v372 <= v444 - (unint64_t)v445)
              {
                if (v372)
                {
                  memcpy(v445, v373, v372);
                  v375 = (char *)v445 + v374;
                  uint64_t v445 = (char *)v445 + v374;
                }
              }
              else
              {
                llvm::raw_ostream::write((llvm::raw_ostream *)&v443, (const char *)v373, v372);
                v375 = (char *)v445;
              }
              if ((unint64_t)v375 >= v444)
              {
                llvm::raw_ostream::write((llvm::raw_ostream *)&v443, 10);
              }
              else
              {
                uint64_t v445 = v375 + 1;
                char *v375 = 10;
              }
              ++v363;
            }
            v361 += 3;
          }
          unint64_t v416 = 0xCCCCCCCCCCCCCCCDLL * (((unsigned char *)v421[9] - (unsigned char *)v421[8]) >> 3);
          if (v416 >= 2)
          {
            for (unint64_t i = 1; i != v416; ++i)
            {
              uint64_t v377 = v421[8];
              BOOL v378 = (uint64_t **)&v377[5 * i];
              if (*((_DWORD *)v378 + 2))
              {
                uint64_t v379 = v445;
                if (v444 - (unint64_t)v445 > 6)
                {
                  *(_DWORD *)((char *)v445 + 3) = 980708981;
                  *uint64_t v379 = 1970234220;
                  uint64_t v445 = (char *)v445 + 7;
                }
                else
                {
                  llvm::raw_ostream::write((llvm::raw_ostream *)&v443, "lcount:", 7uLL);
                }
                sub_1CD098D14((llvm::raw_ostream *)&v443, i, 0, 0, 0);
                uint64_t v380 = v445;
                if ((unint64_t)v445 >= v444)
                {
                  llvm::raw_ostream::write((llvm::raw_ostream *)&v443, 44);
                }
                else
                {
                  uint64_t v445 = (char *)v445 + 1;
                  *uint64_t v380 = 44;
                }
                sub_1CD098D14((llvm::raw_ostream *)&v443, v377[5 * i + 3], 0, 0, 0);
                unsigned int v381 = v445;
                if ((unint64_t)v445 >= v444)
                {
                  llvm::raw_ostream::write((llvm::raw_ostream *)&v443, 10);
                }
                else
                {
                  uint64_t v445 = (char *)v445 + 1;
                  *unsigned int v381 = 10;
                }
                if (v356[1])
                {
                  uint64_t v382 = *((unsigned int *)v378 + 2);
                  if (v382)
                  {
                    uint64_t v383 = *v378;
                    uint64_t v426 = (uint64_t)&(*v378)[v382];
                    do
                    {
                      uint64_t v384 = *v383;
                      uint64_t v385 = *(unsigned int *)(*v383 + 56);
                      if (v385 >= 2
                        && i == *(_DWORD *)(*(void *)(v384 + 80) + 4 * *(unsigned int *)(v384 + 88) - 4))
                      {
                        uint64_t v386 = *(void *)(v384 + 48);
                        uint64_t v387 = 8 * v385;
                        do
                        {
                          if (*(void *)(v384 + 8))
                          {
                            if (*(void *)(*(void *)v386 + 24)) {
                              std::string::size_type v388 = "taken";
                            }
                            else {
                              std::string::size_type v388 = "nottaken";
                            }
                          }
                          else
                          {
                            std::string::size_type v388 = "notexec";
                          }
                          std::string::size_type v389 = v445;
                          if (v444 - (unint64_t)v445 > 6)
                          {
                            *(_DWORD *)((char *)v445 + 3) = 979919726;
                            *std::string::size_type v389 = 1851880034;
                            uint64_t v445 = (char *)v445 + 7;
                          }
                          else
                          {
                            llvm::raw_ostream::write((llvm::raw_ostream *)&v443, "branch:", 7uLL);
                          }
                          sub_1CD098D14((llvm::raw_ostream *)&v443, i, 0, 0, 0);
                          std::string::size_type v390 = v445;
                          if ((unint64_t)v445 >= v444)
                          {
                            llvm::raw_ostream::write((llvm::raw_ostream *)&v443, 44);
                          }
                          else
                          {
                            uint64_t v445 = (char *)v445 + 1;
                            *std::string::size_type v390 = 44;
                          }
                          size_t v391 = strlen(v388);
                          uint64_t v392 = (char *)v445;
                          if (v391 <= v444 - (unint64_t)v445)
                          {
                            if (v391)
                            {
                              memcpy(v445, v388, v391);
                              uint64_t v392 = (char *)v445 + v391;
                              uint64_t v445 = (char *)v445 + v391;
                            }
                          }
                          else
                          {
                            llvm::raw_ostream::write((llvm::raw_ostream *)&v443, v388, v391);
                            uint64_t v392 = (char *)v445;
                          }
                          if ((unint64_t)v392 >= v444)
                          {
                            llvm::raw_ostream::write((llvm::raw_ostream *)&v443, 10);
                          }
                          else
                          {
                            uint64_t v445 = v392 + 1;
                            *uint64_t v392 = 10;
                          }
                          v386 += 8;
                          v387 -= 8;
                        }
                        while (v387);
                      }
                      ++v383;
                    }
                    while (v383 != (uint64_t *)v426);
                  }
                }
              }
            }
          }
          v421 += 12;
        }
        while (v421 != v412);
      }
    }
    llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)&v443);
    if (v409 < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  int v342 = (char *)v428;
  if (v428)
  {
    int v343 = v429;
    if (v429 != v428)
    {
      do
      {
        v343 -= 96;
        sub_1CCCD93D0(v343);
      }
      while (v343 != v342);
      int v342 = (char *)v428;
    }
    operator delete(v342);
  }
}

llvm::raw_ostream *sub_1CCCD91DC(uint64_t a1, void *a2, llvm::raw_ostream *a3)
{
  double v6 = (double)(unint64_t)a2[3] * 100.0;
  unint64_t v7 = a2[2];
  uint64_t v16 = &unk_1F263C2E8;
  uint64_t v17 = "Lines executed:%.2f%% of %llu\n";
  double v18 = v6 / (double)v7;
  unint64_t v19 = v7;
  unint64_t result = llvm::raw_ostream::operator<<(a3, (uint64_t)&v16);
  if (*(unsigned char *)(*(void *)a1 + 1))
  {
    unint64_t v9 = a2[4];
    if (v9)
    {
      double v10 = (double)(unint64_t)a2[5] * 100.0;
      uint64_t v16 = &unk_1F263C2E8;
      uint64_t v17 = "Branches executed:%.2f%% of %llu\n";
      double v18 = v10 / (double)v9;
      unint64_t v19 = v9;
      BOOL v11 = llvm::raw_ostream::operator<<(a3, (uint64_t)&v16);
      double v12 = (double)(unint64_t)a2[6] * 100.0;
      unint64_t v13 = a2[4];
      uint64_t v16 = &unk_1F263C2E8;
      uint64_t v17 = "Taken at least once:%.2f%% of %llu\n";
      double v18 = v12 / (double)v13;
      unint64_t v19 = v13;
      unint64_t result = llvm::raw_ostream::operator<<(v11, (uint64_t)&v16);
    }
    else
    {
      uint64_t v14 = *((void *)a3 + 4);
      if ((unint64_t)(*((void *)a3 + 3) - v14) > 0xB)
      {
        *(_DWORD *)(v14 + 8) = 175334760;
        *(void *)uint64_t v14 = *(void *)"No branches\n";
        *((void *)a3 + 4) += 12;
      }
      else
      {
        unint64_t result = llvm::raw_ostream::write(a3, "No branches\n", 0xCuLL);
      }
    }
    uint64_t v15 = *((void *)a3 + 4);
    if ((unint64_t)(*((void *)a3 + 3) - v15) > 8)
    {
      *(unsigned char *)(v15 + 8) = 10;
      *(void *)uint64_t v15 = *(void *)"No calls\n";
      *((void *)a3 + 4) += 9;
    }
    else
    {
      return llvm::raw_ostream::write(a3, "No calls\n", 9uLL);
    }
  }
  return result;
}

void sub_1CCCD93D0(void *a1)
{
  uint64_t v2 = a1[8];
  if (v2)
  {
    uint64_t v3 = a1[9];
    uint64_t v4 = (void *)a1[8];
    if (v3 != v2)
    {
      do
      {
        double v6 = *(void **)(v3 - 40);
        v3 -= 40;
        uint64_t v5 = v6;
        if ((void *)(v3 + 16) != v6) {
          free(v5);
        }
      }
      while (v3 != v2);
      uint64_t v4 = (void *)a1[8];
    }
    a1[9] = v2;
    operator delete(v4);
  }
  unint64_t v7 = (void **)(a1 + 5);
  uint64_t v8 = a1[5];
  if (v8)
  {
    uint64_t v9 = a1[6];
    double v10 = (void *)a1[5];
    if (v9 != v8)
    {
      uint64_t v11 = a1[6];
      do
      {
        unint64_t v13 = *(void **)(v11 - 24);
        v11 -= 24;
        double v12 = v13;
        if (v13)
        {
          *(void *)(v9 - 16) = v12;
          operator delete(v12);
        }
        uint64_t v9 = v11;
      }
      while (v11 != v8);
      double v10 = *v7;
    }
    a1[6] = v8;
    operator delete(v10);
  }
  uint64_t v14 = (void **)a1[2];
  if (v14 != v7)
  {
    free(v14);
  }
}

uint64_t sub_1CCCD94AC(uint64_t a1, char *__str, size_t __size)
{
  return snprintf(__str, __size, *(const char **)(a1 + 8), *(void *)(a1 + 16), *(void *)(a1 + 24));
}

void sub_1CCCD94EC(unsigned char *__dst, char *__src, char *a3, char a4)
{
  uint64_t v4 = a3;
  uint64_t v5 = __src;
  double v6 = __dst;
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if ((a4 & 1) == 0)
  {
    __srca[1] = 0;
    __len[0] = 0;
    uint64_t v23 = __src;
    __srca[0] = a3;
    __len[1] = (size_t)a3;
    int v26 = 0;
    llvm::sys::path::reverse_iterator::operator++((uint64_t)&v23);
    unint64_t v13 = __srca[1];
    if (!__srca[1])
    {
      *double v6 = 0;
      v6[1] = 0;
      void v6[2] = 0;
      return;
    }
    size_t v14 = __len[0];
    if (__len[0] > 0x7FFFFFFFFFFFFFF7) {
LABEL_52:
    }
      abort();
    if (__len[0] >= 0x17)
    {
      size_t v17 = (__len[0] & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((__len[0] | 7) != 0x17) {
        size_t v17 = __len[0] | 7;
      }
      size_t v18 = v17 + 1;
      unint64_t v19 = operator new(v17 + 1);
      v6[1] = v14;
      void v6[2] = v18 | 0x8000000000000000;
      *double v6 = v19;
      double v6 = v19;
    }
    else
    {
      *((unsigned char *)v6 + 23) = __len[0];
      if (!v14) {
        goto LABEL_43;
      }
    }
    memmove(v6, v13, v14);
LABEL_43:
    *((unsigned char *)v6 + v14) = 0;
    return;
  }
  uint64_t v23 = __len;
  *(_OWORD *)__srca = xmmword_1CD96DBF0;
  size_t v7 = 0;
  if (!a3)
  {
    __dst[23] = 0;
    goto LABEL_48;
  }
  uint64_t v8 = &a3[(void)__src];
  uint64_t v9 = __src;
  double v10 = __src;
  do
  {
    if (*v10 != 47) {
      goto LABEL_20;
    }
    if (v5 - v9 == 2)
    {
      if (*v9 == 46 && v9[1] == 46)
      {
        if (__srca[1] < (void *)(v7 + 2)) {
          llvm::SmallVectorBase<unsigned long long>::grow_pod();
        }
        *(_WORD *)((char *)v23 + v7) = 9054;
        uint64_t v11 = 2;
        goto LABEL_18;
      }
    }
    else if (v5 - v9 == 1 && *v9 == 46)
    {
      goto LABEL_19;
    }
    double v12 = __srca[1];
    if (v9 < v10)
    {
      if (__srca[1] < (void *)(&v5[v7] - v9)) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      memcpy((char *)v23 + v7, v9, v5 - v9);
      double v12 = __srca[1];
      size_t v7 = (size_t)&v5[(unint64_t)((char *)__srca[0] - (char *)v9)];
      __srca[0] = (void *)v7;
    }
    if (v7 + 1 > (unint64_t)v12) {
      llvm::SmallVectorBase<unsigned long long>::grow_pod();
    }
    *((unsigned char *)v23 + v7) = 35;
    uint64_t v11 = 1;
LABEL_18:
    size_t v7 = (size_t)__srca[0] + v11;
    __srca[0] = (char *)__srca[0] + v11;
LABEL_19:
    uint64_t v9 = v10 + 1;
LABEL_20:
    ++v10;
    ++v5;
    --v4;
  }
  while (v4);
  if (v9 < v8)
  {
    uint64_t v15 = v8 - v9;
    if (__srca[1] < (void *)(v8 - v9 + v7)) {
      llvm::SmallVectorBase<unsigned long long>::grow_pod();
    }
    memcpy((char *)v23 + v7, v9, v8 - v9);
    size_t v7 = (size_t)__srca[0] + v15;
    __srca[0] = (char *)__srca[0] + v15;
  }
  if (v7 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_52;
  }
  uint64_t v16 = v23;
  if (v7 >= 0x17)
  {
    uint64_t v20 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v20 = v7 | 7;
    }
    uint64_t v21 = v20 + 1;
    unint64_t v22 = operator new(v20 + 1);
    v6[1] = v7;
    void v6[2] = v21 | 0x8000000000000000;
    *double v6 = v22;
    double v6 = v22;
  }
  else
  {
    *((unsigned char *)v6 + 23) = v7;
    if (!v7) {
      goto LABEL_48;
    }
  }
  memmove(v6, v16, v7);
LABEL_48:
  *((unsigned char *)v6 + v7) = 0;
  if (v23 != __len) {
    free(v23);
  }
}

llvm::raw_ostream *sub_1CCCD9844(uint64_t a1, llvm::raw_ostream *a2, unsigned int a3)
{
  size_t v5 = *(void *)(a1 + 16);
  if (v5)
  {
    size_t v7 = (const char **)(a1 + 8);
    unint64_t v8 = llvm::StringRef::find((uint64_t *)(a1 + 8), "\n", 1uLL, 0);
    if (v8 == -1)
    {
      double v12 = 0;
      size_t v13 = 0;
      double v10 = *v7;
    }
    else
    {
      if (v5 >= v8) {
        size_t v9 = v8;
      }
      else {
        size_t v9 = v5;
      }
      double v10 = *v7;
      if (v5 >= v8 + 1) {
        size_t v11 = v8 + 1;
      }
      else {
        size_t v11 = v5;
      }
      double v12 = &v10[v11];
      size_t v13 = v5 - v11;
      size_t v5 = v9;
    }
    *(void *)(a1 + 8) = v12;
    *(void *)(a1 + 16) = v13;
  }
  else
  {
    double v10 = "/*EOF*/";
    size_t v5 = 7;
  }
  v15[0] = &unk_1F25FED10;
  v15[1] = "%5u:";
  uint64_t v15[2] = a3;
  llvm::raw_ostream::operator<<(a2, (uint64_t)v15);
  unint64_t result = (llvm::raw_ostream *)*((void *)a2 + 4);
  if (v5 <= *((void *)a2 + 3) - (void)result)
  {
    if (v5)
    {
      memcpy(result, v10, v5);
      unint64_t result = (llvm::raw_ostream *)(*((void *)a2 + 4) + v5);
      *((void *)a2 + 4) = result;
    }
  }
  else
  {
    llvm::raw_ostream::write(a2, v10, v5);
    unint64_t result = (llvm::raw_ostream *)*((void *)a2 + 4);
  }
  if (*((llvm::raw_ostream **)a2 + 3) == result) {
    return llvm::raw_ostream::write(a2, "\n", 1uLL);
  }
  *(unsigned char *)unint64_t result = 10;
  ++*((void *)a2 + 4);
  return result;
}

llvm::raw_ostream *sub_1CCCD99B0(llvm::raw_ostream *this, unint64_t *a2)
{
  uint64_t v2 = this;
  if (!a2[2])
  {
    double v6 = (void *)*((void *)this + 4);
    if (*((void *)this + 3) - (void)v6 <= 0xDuLL)
    {
      size_t v7 = "never executed";
      size_t v8 = 14;
LABEL_21:
      llvm::raw_ostream::write(this, v7, v8);
      return v2;
    }
    qmemcpy(v6, "never executed", 14);
    uint64_t v15 = *((void *)this + 4) + 14;
LABEL_27:
    *((void *)v2 + 4) = v15;
    return v2;
  }
  uint64_t v4 = *((void *)this + 4);
  unint64_t v5 = *((void *)this + 3) - v4;
  if (!*(unsigned char *)(*a2 + 2))
  {
    if (v5 > 5)
    {
      *(_WORD *)(v4 + 4) = 8302;
      *(_DWORD *)uint64_t v4 = 1701536116;
      *((void *)this + 4) += 6;
    }
    else
    {
      llvm::raw_ostream::write(this, "taken ", 6uLL);
    }
    unint64_t v9 = a2[1];
    if (v9)
    {
      unint64_t v10 = a2[2];
      if (v9 == v10)
      {
        unint64_t v11 = 100;
      }
      else
      {
        unint64_t v12 = (100 * v9 + (v10 >> 1)) / v10;
        if ((_BYTE)v12)
        {
          if (v12 == 100) {
            unint64_t v11 = 99;
          }
          else {
            unint64_t v11 = v12;
          }
        }
        else
        {
          unint64_t v11 = 1;
        }
      }
    }
    else
    {
      unint64_t v11 = 0;
    }
    sub_1CD098D14(v2, v11, 0, 0, 0);
    size_t v13 = (unsigned char *)*((void *)v2 + 4);
    if (*((unsigned char **)v2 + 3) == v13)
    {
      size_t v7 = "%";
      this = v2;
      size_t v8 = 1;
      goto LABEL_21;
    }
    unsigned char *v13 = 37;
    uint64_t v15 = *((void *)v2 + 4) + 1;
    goto LABEL_27;
  }
  if (v5 > 5)
  {
    *(_WORD *)(v4 + 4) = 8302;
    *(_DWORD *)uint64_t v4 = 1701536116;
    *((void *)this + 4) += 6;
  }
  else
  {
    llvm::raw_ostream::write(this, "taken ", 6uLL);
  }
  sub_1CD098D14(v2, a2[1], 0, 0, 0);
  return v2;
}

char **sub_1CCCD9B78(char **a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 8 * v3;
    unint64_t v5 = v2 - 8;
    do
    {
      uint64_t v6 = *(void *)&v5[v4];
      *(void *)&v5[v4] = 0;
      if (v6) {
        MEMORY[0x1D25D9CE0](v6, 0x1020C40992E6479);
      }
      v4 -= 8;
    }
    while (v4);
    uint64_t v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

char **sub_1CCCD9BF4(char **a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 8 * v3;
    unint64_t v5 = v2 - 8;
    do
    {
      uint64_t v6 = *(void **)&v5[v4];
      *(void *)&v5[v4] = 0;
      if (v6)
      {
        size_t v7 = (void *)v6[10];
        if (v7 != v6 + 12) {
          free(v7);
        }
        size_t v8 = (void *)v6[6];
        if (v8 != v6 + 8) {
          free(v8);
        }
        unint64_t v9 = (void *)v6[2];
        if (v9 != v6 + 4) {
          free(v9);
        }
        MEMORY[0x1D25D9CE0](v6, 0x10A0C400EDE5EBALL);
      }
      v4 -= 8;
    }
    while (v4);
    uint64_t v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

void sub_1CCCD9CB0(uint64_t a1, unint64_t a2)
{
  if (HIDWORD(a2)) {
    sub_1CD0A88F0(a2);
  }
  uint64_t v3 = *(unsigned int *)(a1 + 12);
  if (v3 == -1) {
    sub_1CD0A89A8(0xFFFFFFFFuLL);
  }
  unint64_t v4 = (2 * v3) | 1;
  if (v4 <= a2) {
    unint64_t v4 = a2;
  }
  if (v4 >= 0xFFFFFFFF) {
    uint64_t v5 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v5 = v4;
  }
  uint64_t v6 = malloc_type_malloc(8 * v5, 0x4065EBACuLL);
  if (!v6) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  size_t v7 = v6;
  size_t v8 = *(uint64_t **)a1;
  uint64_t v9 = *(unsigned int *)(a1 + 8);
  if (v9)
  {
    uint64_t v10 = 8 * v9;
    uint64_t v11 = 8 * v9;
    unint64_t v12 = v7;
    do
    {
      uint64_t v13 = *v8;
      *v8++ = 0;
      *v12++ = v13;
      v11 -= 8;
    }
    while (v11);
    uint64_t v14 = *(void *)a1 - 8;
    do
    {
      uint64_t v15 = *(void *)(v14 + v10);
      *(void *)(v14 + v10) = 0;
      if (v15)
      {
        MEMORY[0x1D25D9CD0](*(void *)(v15 + 136), 8);
        sub_1CCCD9B78((char **)(v15 + 120));
        sub_1CCCD9B78((char **)(v15 + 104));
        sub_1CCCD9BF4((char **)(v15 + 88));
        uint64_t v16 = *(void **)(v15 + 56);
        if (v16 != (void *)(v15 + 80)) {
          free(v16);
        }
        MEMORY[0x1D25D9CE0](v15, 0x10F0C408FF3F95ELL);
      }
      v10 -= 8;
    }
    while (v10);
    size_t v8 = *(uint64_t **)a1;
  }
  if (v8 != (uint64_t *)(a1 + 16)) {
    free(v8);
  }
  *(void *)a1 = v7;
  *(_DWORD *)(a1 + 12) = v5;
}

uint64_t sub_1CCCD9DFC(int64x2_t *a1, const void *a2, size_t a3)
{
  unint64_t v3 = 0xAAAAAAAAAAAAAAABLL * ((a1->i64[1] - a1->i64[0]) >> 3);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_24;
  }
  if (0x5555555555555556 * ((a1[1].i64[0] - a1->i64[0]) >> 3) > v4) {
    unint64_t v4 = 0x5555555555555556 * ((a1[1].i64[0] - a1->i64[0]) >> 3);
  }
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[1].i64[0] - a1->i64[0]) >> 3) >= 0x555555555555555 ? 0xAAAAAAAAAAAAAAALL : v4;
  int v26 = a1 + 1;
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      sub_1CB833614();
    }
    uint64_t v9 = (char *)operator new(24 * v8);
  }
  else
  {
    uint64_t v9 = 0;
  }
  uint64_t v10 = &v9[24 * v3];
  v24.i64[0] = (uint64_t)v10;
  v24.i64[1] = (uint64_t)v10;
  uint64_t v25 = &v9[24 * v8];
  if (a3 >= 0x7FFFFFFFFFFFFFF8) {
LABEL_24:
  }
    abort();
  if (a3 >= 0x17)
  {
    uint64_t v11 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a3 | 7) != 0x17) {
      uint64_t v11 = a3 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v13 = (char *)operator new(v11 + 1);
    *((void *)v10 + sub_1CD7485C0(this + 1) = a3;
    *((void *)v10 + 2) = v12 | 0x8000000000000000;
    *(void *)uint64_t v10 = v13;
    uint64_t v10 = v13;
    goto LABEL_18;
  }
  v10[23] = a3;
  if (a3) {
LABEL_18:
  }
    memmove(v10, a2, a3);
  v10[a3] = 0;
  uint64_t v15 = a1->i64[0];
  unint64_t v14 = a1->u64[1];
  uint64_t v16 = v24.i64[1];
  uint64_t v17 = v24.i64[0];
  if (v14 == a1->i64[0])
  {
    int64x2_t v19 = vdupq_n_s64(v14);
  }
  else
  {
    do
    {
      long long v18 = *(_OWORD *)(v14 - 24);
      *(void *)(v17 - 8) = *(void *)(v14 - 8);
      *(_OWORD *)(v17 - 24) = v18;
      v17 -= 24;
      *(void *)(v14 - 16) = 0;
      *(void *)(v14 - 8) = 0;
      *(void *)(v14 - 24) = 0;
      v14 -= 24;
    }
    while (v14 != v15);
    int64x2_t v19 = *a1;
  }
  uint64_t v20 = v16 + 24;
  a1->i64[0] = v17;
  a1->i64[1] = v16 + 24;
  int64x2_t v24 = v19;
  uint64_t v21 = (char *)a1[1].i64[0];
  a1[1].i64[0] = (uint64_t)v25;
  uint64_t v25 = v21;
  uint64_t v23 = v19.i64[0];
  sub_1CBF4EE0C((uint64_t)&v23);
  return v20;
}

void sub_1CCCD9FB0(uint64_t a1, unint64_t a2)
{
  if (HIDWORD(a2)) {
    sub_1CD0A88F0(a2);
  }
  uint64_t v3 = *(unsigned int *)(a1 + 12);
  if (v3 == -1) {
    sub_1CD0A89A8(0xFFFFFFFFuLL);
  }
  unint64_t v4 = (2 * v3) | 1;
  if (v4 <= a2) {
    unint64_t v4 = a2;
  }
  if (v4 >= 0xFFFFFFFF) {
    uint64_t v5 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v5 = v4;
  }
  uint64_t v6 = malloc_type_malloc(8 * v5, 0x4065EBACuLL);
  if (!v6) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  size_t v7 = v6;
  unint64_t v8 = *(uint64_t **)a1;
  uint64_t v9 = *(unsigned int *)(a1 + 8);
  if (v9)
  {
    uint64_t v10 = 8 * v9;
    uint64_t v11 = 8 * v9;
    uint64_t v12 = v7;
    do
    {
      uint64_t v13 = *v8;
      *v8++ = 0;
      *v12++ = v13;
      v11 -= 8;
    }
    while (v11);
    uint64_t v14 = *(void *)a1 - 8;
    do
    {
      uint64_t v15 = *(void **)(v14 + v10);
      *(void *)(v14 + v10) = 0;
      if (v15)
      {
        uint64_t v16 = (void *)v15[10];
        if (v16 != v15 + 12) {
          free(v16);
        }
        uint64_t v17 = (void *)v15[6];
        if (v17 != v15 + 8) {
          free(v17);
        }
        long long v18 = (void *)v15[2];
        if (v18 != v15 + 4) {
          free(v18);
        }
        MEMORY[0x1D25D9CE0](v15, 0x10A0C400EDE5EBALL);
      }
      v10 -= 8;
    }
    while (v10);
    unint64_t v8 = *(uint64_t **)a1;
  }
  if (v8 != (uint64_t *)(a1 + 16)) {
    free(v8);
  }
  *(void *)a1 = v7;
  *(_DWORD *)(a1 + 12) = v5;
}

void sub_1CCCDA100(uint64_t a1, unint64_t a2)
{
  if (HIDWORD(a2)) {
    sub_1CD0A88F0(a2);
  }
  uint64_t v3 = *(unsigned int *)(a1 + 12);
  if (v3 == -1) {
    sub_1CD0A89A8(0xFFFFFFFFuLL);
  }
  unint64_t v4 = (2 * v3) | 1;
  if (v4 <= a2) {
    unint64_t v4 = a2;
  }
  if (v4 >= 0xFFFFFFFF) {
    uint64_t v5 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v5 = v4;
  }
  uint64_t v6 = malloc_type_malloc(8 * v5, 0x4065EBACuLL);
  if (!v6) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  size_t v7 = v6;
  unint64_t v8 = *(uint64_t **)a1;
  uint64_t v9 = *(unsigned int *)(a1 + 8);
  if (v9)
  {
    uint64_t v10 = 8 * v9;
    uint64_t v11 = 8 * v9;
    uint64_t v12 = v7;
    do
    {
      uint64_t v13 = *v8;
      *v8++ = 0;
      *v12++ = v13;
      v11 -= 8;
    }
    while (v11);
    uint64_t v14 = *(void *)a1 - 8;
    do
    {
      uint64_t v15 = *(void *)(v14 + v10);
      *(void *)(v14 + v10) = 0;
      if (v15) {
        MEMORY[0x1D25D9CE0](v15, 0x1020C40992E6479);
      }
      v10 -= 8;
    }
    while (v10);
    unint64_t v8 = *(uint64_t **)a1;
  }
  if (v8 != (uint64_t *)(a1 + 16)) {
    free(v8);
  }
  *(void *)a1 = v7;
  *(_DWORD *)(a1 + 12) = v5;
}

uint64_t sub_1CCCDA210(uint64_t a1, char *__str, size_t __size)
{
  return snprintf(__str, __size, *(const char **)(a1 + 8), *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 20), *(unsigned int *)(a1 + 24), *(unsigned int *)(a1 + 28));
}

uint64_t llvm::instrprof_category(llvm *this)
{
  if (!atomic_load_explicit(&qword_1EA61DF08, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1EA61DF08, (void *(*)(void))sub_1CCCDE3CC, (void (*)(void *))sub_1CCCDE414);
  }
  return qword_1EA61DF08;
}

_DWORD *llvm::SoftInstrProfErrors::addError(_DWORD *result, int a2)
{
  if (a2)
  {
    if (!*result) {
      llvm::raw_ostream *result = a2;
    }
    switch(a2)
    {
      case 16:
        uint64_t v2 = result + 2;
        break;
      case 17:
        uint64_t v2 = result + 3;
        break;
      case 18:
        uint64_t v2 = result + 4;
        break;
      default:
        uint64_t v2 = result + 1;
        break;
    }
    ++*v2;
  }
  return result;
}

void sub_1CCCDA318(uint64_t a1, int a2, uint64_t a3)
{
  v25[0] = 0;
  v25[1] = 0;
  uint64_t v26 = 0;
  int v17 = 0;
  char v21 = 0;
  uint64_t v22 = 0;
  int64x2_t v24 = v25;
  int v23 = 0;
  uint64_t v16 = &unk_1F2646F30;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  switch(a2)
  {
    case 0:
      uint64_t v5 = "success";
      size_t v6 = 7;
      goto LABEL_28;
    case 1:
      uint64_t v5 = "end of File";
      size_t v6 = 11;
      goto LABEL_28;
    case 2:
      uint64_t v5 = "unrecognized instrumentation profile encoding format";
      size_t v6 = 52;
      goto LABEL_28;
    case 3:
      uint64_t v5 = "invalid instrumentation profile data (bad magic)";
      size_t v6 = 48;
      goto LABEL_28;
    case 4:
      uint64_t v5 = "invalid instrumentation profile data (file header is corrupt)";
      goto LABEL_20;
    case 5:
      uint64_t v5 = "unsupported instrumentation profile format version";
      size_t v6 = 50;
      goto LABEL_28;
    case 6:
      uint64_t v5 = "unsupported instrumentation profile hash type";
      size_t v6 = 45;
      goto LABEL_28;
    case 7:
      uint64_t v5 = "too much profile data";
      size_t v6 = 21;
      goto LABEL_28;
    case 8:
      uint64_t v5 = "truncated profile data";
      goto LABEL_26;
    case 9:
      uint64_t v5 = "malformed instrumentation profile data";
      goto LABEL_16;
    case 10:
      uint64_t v5 = "debug info for correlation is required";
      goto LABEL_16;
    case 11:
      uint64_t v5 = "debug info for correlation is not necessary";
      size_t v6 = 43;
      goto LABEL_28;
    case 12:
      uint64_t v5 = "unable to correlate profile";
      size_t v6 = 27;
      goto LABEL_28;
    case 13:
      uint64_t v5 = "no profile data available for function";
LABEL_16:
      size_t v6 = 38;
      goto LABEL_28;
    case 14:
      uint64_t v5 = "invalid profile created. Please file a bug at: https://github.com/llvm/llvm-project/issues/ and include the p"
           "rofraw files that caused this error.";
      size_t v6 = 145;
      goto LABEL_28;
    case 15:
      uint64_t v5 = "function control flow change detected (hash mismatch)";
      size_t v6 = 53;
      goto LABEL_28;
    case 16:
      uint64_t v5 = "function basic block count change detected (counter mismatch)";
LABEL_20:
      size_t v6 = 61;
      goto LABEL_28;
    case 17:
      uint64_t v5 = "counter overflow";
      size_t v6 = 16;
      goto LABEL_28;
    case 18:
      uint64_t v5 = "function value site count change detected (counter mismatch)";
      size_t v6 = 60;
      goto LABEL_28;
    case 19:
      uint64_t v5 = "failed to compress data (zlib)";
      size_t v6 = 30;
      goto LABEL_28;
    case 20:
      uint64_t v5 = "failed to uncompress data (zlib)";
      size_t v6 = 32;
      goto LABEL_28;
    case 21:
      uint64_t v5 = "empty raw profile file";
LABEL_26:
      size_t v6 = 22;
      goto LABEL_28;
    case 22:
      uint64_t v5 = "profile uses zlib compression but the profile reader was built without zlib support";
      size_t v6 = 83;
LABEL_28:
      llvm::raw_ostream::write((llvm::raw_ostream *)&v16, v5, v6);
      break;
    default:
      break;
  }
  char v7 = *(unsigned char *)(a3 + 23);
  int v8 = v7;
  uint64_t v9 = v7 & 0x7F;
  if (v8 < 0) {
    uint64_t v9 = *(void *)(a3 + 8);
  }
  if (v9)
  {
    if ((unint64_t)(v19 - (void)v20) > 1) {
      *v20++ = 8250;
    }
    else {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v16, ": ", 2uLL);
    }
    char v10 = *(unsigned char *)(a3 + 23);
    BOOL v11 = v10 < 0;
    if (v10 >= 0) {
      uint64_t v12 = (const char *)a3;
    }
    else {
      uint64_t v12 = *(const char **)a3;
    }
    size_t v13 = v10 & 0x7F;
    if (v11) {
      size_t v14 = *(void *)(a3 + 8);
    }
    else {
      size_t v14 = v13;
    }
    llvm::raw_ostream::write((llvm::raw_ostream *)&v16, v12, v14);
  }
  if (*((char *)v24 + 23) < 0)
  {
    sub_1CB8BDF7C(a1, *v24, (unint64_t)v24[1]);
  }
  else
  {
    long long v15 = *(_OWORD *)v24;
    *(void *)(a1 + 16) = v24[2];
    *(_OWORD *)a1 = v15;
  }
  uint64_t v16 = &unk_1F2646B98;
  if (v23 == 1 && v18) {
    MEMORY[0x1D25D9CB0](v18, 0x1000C8077774924);
  }
  if (SHIBYTE(v26) < 0) {
    operator delete(v25[0]);
  }
}

void llvm::getPGOFuncName(llvm *this@<X0>, const llvm::Function *a2@<X1>, std::string *a3@<X8>)
{
  if (a2)
  {
    Metaunsigned int data = llvm::Value::getMetadata((uint64_t)this, "PGOFuncName", 0xBuLL);
    if (Metadata)
    {
      size_t v6 = *(unint64_t **)(*(void *)(Metadata - 8 * *(unsigned int *)(Metadata + 8)) + 8);
      unint64_t v9 = *v6;
      int v8 = (char *)(v6 + 3);
      size_t v7 = v9;
      if (v9 <= 0x7FFFFFFFFFFFFFF7)
      {
        if (v7 < 0x17)
        {
          *((unsigned char *)&a3->__r_.__value_.__s + 23) = v7;
          if (!v7) {
            goto LABEL_33;
          }
          goto LABEL_32;
        }
        goto LABEL_29;
      }
      goto LABEL_71;
    }
    if ((*((unsigned char *)this + 23) & 0x10) == 0)
    {
      uint64_t v19 = 0;
      uint64_t v20 = &byte_1CFBCE98E;
LABEL_16:
      if (v19) {
        BOOL v22 = *v20 == 1;
      }
      else {
        BOOL v22 = 0;
      }
      uint64_t v23 = v22;
      if (v22) {
        int v8 = v20 + 1;
      }
      else {
        int v8 = v20;
      }
      size_t v7 = v19 - v23;
      if ((unint64_t)(v19 - v23) <= 0x7FFFFFFFFFFFFFF7)
      {
        if (v7 < 0x17)
        {
          *((unsigned char *)&a3->__r_.__value_.__s + 23) = v7;
          if (v19 == v23) {
            goto LABEL_33;
          }
          goto LABEL_32;
        }
LABEL_29:
        uint64_t v24 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v7 | 7) != 0x17) {
          uint64_t v24 = v7 | 7;
        }
        uint64_t v25 = v24 + 1;
        uint64_t v26 = (std::string *)operator new(v24 + 1);
        a3->__r_.__value_.__l.__size_ = v7;
        a3->__r_.__value_.__r.__words[2] = v25 | 0x8000000000000000;
        a3->__r_.__value_.__r.__words[0] = (std::string::size_type)v26;
        a3 = v26;
LABEL_32:
        memmove(a3, v8, v7);
LABEL_33:
        a3->__r_.__value_.__s.__data_[v7] = 0;
        return;
      }
LABEL_71:
      abort();
    }
    uint64_t v10 = ***(void ***)this;
    uint64_t v11 = *(void *)(v10 + 152);
    uint64_t v12 = *(unsigned int *)(v10 + 168);
    if (v12)
    {
      LODWORD(v13) = (v12 - 1) & ((this >> 4) ^ (this >> 9));
      uint64_t v14 = v11 + 16 * v13;
      long long v15 = *(llvm **)v14;
      if (*(llvm **)v14 == this)
      {
LABEL_15:
        uint64_t v18 = *(void **)(v14 + 8);
        uint64_t v21 = *v18;
        uint64_t v20 = (char *)(v18 + 2);
        uint64_t v19 = v21;
        goto LABEL_16;
      }
      int v16 = 1;
      while (v15 != (llvm *)-4096)
      {
        int v17 = v13 + v16++;
        uint64_t v13 = v17 & (v12 - 1);
        long long v15 = *(llvm **)(v11 + 16 * v13);
        if (v15 == this)
        {
          uint64_t v14 = v11 + 16 * v13;
          goto LABEL_15;
        }
      }
    }
    uint64_t v14 = v11 + 16 * v12;
    goto LABEL_15;
  }
  uint64_t v27 = *((void *)this + 5);
  size_t v30 = *(const std::string::value_type **)(v27 + 192);
  uint64_t v28 = v27 + 192;
  uint64_t v29 = v30;
  char v31 = *(unsigned char *)(v28 + 23);
  if (v31 >= 0) {
    uint64_t v32 = (const std::string::value_type *)v28;
  }
  else {
    uint64_t v32 = v29;
  }
  std::string::size_type v33 = *(void *)(v28 + 8);
  if (v31 >= 0) {
    std::string::size_type v34 = v31 & 0x7F;
  }
  else {
    std::string::size_type v34 = v33;
  }
  int v35 = dword_1EBCF0218;
  if (dword_1EBCF0218 <= (byte_1EBCF0158 - 1)) {
    int v35 = byte_1EBCF0158 - 1;
  }
  if (v35)
  {
    if (v34)
    {
      uint64_t v37 = 0;
      LODWORD(v36) = 0;
      do
      {
        if (v32[v37] == 47) {
          std::string::size_type v36 = (v37 + 1);
        }
        else {
          std::string::size_type v36 = v36;
        }
        v35 -= v32[v37] == 47;
        if (v35) {
          BOOL v38 = v34 - 1 == v37;
        }
        else {
          BOOL v38 = 1;
        }
        ++v37;
      }
      while (!v38);
    }
    else
    {
      std::string::size_type v36 = 0;
    }
    if (v34 < v36) {
      std::string::size_type v36 = v34;
    }
    v32 += v36;
    v34 -= v36;
  }
  if ((*((unsigned char *)this + 23) & 0x10) == 0)
  {
    uint64_t v49 = 0;
    size_t v48 = &byte_1CFBCE98E;
    goto LABEL_66;
  }
  uint64_t v39 = ***(void ***)this;
  uint64_t v40 = *(void *)(v39 + 152);
  uint64_t v41 = *(unsigned int *)(v39 + 168);
  if (!v41) {
    goto LABEL_64;
  }
  LODWORD(v42) = (v41 - 1) & ((this >> 4) ^ (this >> 9));
  uint64_t v43 = v40 + 16 * v42;
  size_t v44 = *(llvm **)v43;
  if (*(llvm **)v43 != this)
  {
    int v45 = 1;
    while (v44 != (llvm *)-4096)
    {
      int v46 = v42 + v45++;
      uint64_t v42 = v46 & (v41 - 1);
      size_t v44 = *(llvm **)(v40 + 16 * v42);
      if (v44 == this)
      {
        uint64_t v43 = v40 + 16 * v42;
        goto LABEL_65;
      }
    }
LABEL_64:
    uint64_t v43 = v40 + 16 * v41;
  }
LABEL_65:
  long long v47 = *(void **)(v43 + 8);
  uint64_t v50 = *v47;
  size_t v48 = (const std::string::value_type *)(v47 + 2);
  uint64_t v49 = v50;
LABEL_66:
  int v51 = *((_DWORD *)this + 8) & 0xF;

  llvm::GlobalValue::getGlobalIdentifier(v48, v49, v51, v32, v34, a3);
}

uint64_t llvm::getPGOFuncNameMetadata(llvm *this, const llvm::Function *a2)
{
  return llvm::Value::getMetadata((uint64_t)this, "PGOFuncName", 0xBuLL);
}

char *llvm::getFuncNameWithoutPrefix(char *__s1, size_t a2, void *__s2, size_t __n)
{
  uint64_t v5 = __s1;
  if (__n - 1 < a2)
  {
    int v7 = memcmp(__s1, __s2, __n);
    if (a2 >= __n + 1) {
      size_t v8 = __n + 1;
    }
    else {
      size_t v8 = a2;
    }
    if (!v7) {
      v5 += v8;
    }
  }
  return v5;
}

std::string *llvm::getPGOFuncNameVarName@<X0>(std::string::value_type *__s@<X0>, std::string::size_type __n@<X1>, int a3@<W2>, std::string *a4@<X8>)
{
  *((unsigned char *)&a4->__r_.__value_.__s + 23) = 8;
  strcpy((char *)a4, "__profn_");
  unint64_t result = std::string::append(a4, __s, __n);
  if ((a3 - 7) <= 1)
  {
    std::string::size_type size = HIBYTE(a4->__r_.__value_.__r.__words[2]);
    char v8 = size;
    std::string::size_type v9 = a4->__r_.__value_.__r.__words[0];
    if ((size & 0x80u) == 0) {
      uint64_t v10 = (unsigned __int8 *)a4;
    }
    else {
      uint64_t v10 = (unsigned __int8 *)a4->__r_.__value_.__r.__words[0];
    }
    if ((size & 0x80u) != 0) {
      std::string::size_type size = a4->__r_.__value_.__l.__size_;
    }
    if (size)
    {
      uint64_t v11 = &v10[size];
      uint64_t v12 = v10;
      while (2)
      {
        for (uint64_t i = 0; i != 7; ++i)
        {
          if (*v12 == asc_1CFC18A02[i])
          {
            if (v12 != v11)
            {
              uint64_t v14 = (unsigned __int8 *)(v12 - v10);
              if (v14 != (unsigned __int8 *)-1)
              {
                while (2)
                {
                  if (v8 >= 0) {
                    std::string::size_type v9 = (std::string::size_type)a4;
                  }
                  v14[v9] = 95;
                  long long v15 = v14 + 1;
                  unint64_t v16 = HIBYTE(a4->__r_.__value_.__r.__words[2]);
                  char v8 = v16;
                  std::string::size_type v9 = a4->__r_.__value_.__r.__words[0];
                  if ((v16 & 0x80u) == 0) {
                    std::string::size_type v17 = (std::string::size_type)a4;
                  }
                  else {
                    std::string::size_type v17 = a4->__r_.__value_.__r.__words[0];
                  }
                  if ((v16 & 0x80u) != 0) {
                    unint64_t v16 = a4->__r_.__value_.__l.__size_;
                  }
                  if (v16 > (unint64_t)v15)
                  {
                    uint64_t v18 = (unsigned __int8 *)(v17 + v16);
                    uint64_t v19 = &v15[v17];
LABEL_25:
                    uint64_t v20 = 0;
                    while (*v19 != asc_1CFC18A02[v20])
                    {
                      if (++v20 == 7)
                      {
                        if (++v19 != v18) {
                          goto LABEL_25;
                        }
                        return result;
                      }
                    }
                    if (v19 != v18)
                    {
                      uint64_t v14 = &v19[-v17];
                      if (v14 != (unsigned __int8 *)-1) {
                        continue;
                      }
                    }
                  }
                  break;
                }
              }
            }
            return result;
          }
        }
        if (++v12 != v11) {
          continue;
        }
        break;
      }
    }
  }
  return result;
}

uint64_t sub_1CCCDAB7C(void *__s, char *a2)
{
  uint64_t v2 = __s;
  if (*((char *)__s + 23) < 0)
  {
    uint64_t v2 = (void *)*__s;
    uint64_t v3 = __s[1];
  }
  else
  {
    uint64_t v3 = *((unsigned __int8 *)__s + 23);
  }
  char v4 = a2[23];
  BOOL v5 = v4 < 0;
  if (v4 >= 0) {
    size_t v6 = a2;
  }
  else {
    size_t v6 = *(char **)a2;
  }
  int64_t v7 = v4 & 0x7F;
  if (v5) {
    int64_t v8 = *((void *)a2 + 1);
  }
  else {
    int64_t v8 = v7;
  }
  if (!v8) {
    return 0;
  }
  std::string::size_type v9 = (char *)v2 + v3;
  if (v3 >= v8)
  {
    int v12 = *v6;
    uint64_t v13 = v2;
    do
    {
      uint64_t v14 = v3 - v8;
      if (v14 == -1) {
        break;
      }
      long long v15 = (char *)memchr(v13, v12, v14 + 1);
      if (!v15) {
        break;
      }
      uint64_t v10 = v15;
      if (!memcmp(v15, v6, v8)) {
        goto LABEL_13;
      }
      uint64_t v13 = v10 + 1;
      uint64_t v3 = v9 - (v10 + 1);
    }
    while (v3 >= v8);
  }
  uint64_t v10 = v9;
LABEL_13:
  if (v10 == v9) {
    return -1;
  }
  else {
    return v10 - (char *)v2;
  }
}

void llvm::collectPGOFuncNameStrings(std::string *a1@<X0>, uint64_t a2@<X1>, std::string *a3@<X3>, void *a4@<X8>)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  sub_1CD4FB688(a1, &a1[a2], "\x01", 1uLL, &__p);
  uint64_t v6 = 0;
  int v7 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  unint64_t v9 = size;
  do
  {
    BOOL v10 = v9 > 0x7F;
    __s[v6++] = v9 & 0x7F | ((v9 > 0x7F) << 7);
    v9 >>= 7;
  }
  while (v10);
  if (v7 >= 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  __s[v6] = 0;
  std::string::append(a3, __s, v6 + 1);
  std::string::append(a3, (const std::string::value_type *)p_p, size);
  *a4 = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void llvm::readPGOFuncNameStrings(char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  BOOL v5 = a1;
  v32[16] = *MEMORY[0x1E4F143B8];
  int v7 = &a1[a2];
  do
  {
    if (v5 >= v7)
    {
      *a4 = 0;
      return;
    }
    int v8 = 0;
    unsigned int v9 = 0;
    BOOL v10 = v5;
    uint64_t v11 = 0;
    while (v10)
    {
      char v12 = *v10;
      uint64_t v13 = *v10 & 0x7F;
      if (v9 >= 0x40 && (*v10 & 0x7F) != 0 || (unint64_t)(v13 << v9) >> v9 != v13)
      {
        uint64_t v11 = 0;
        goto LABEL_12;
      }
      v11 += v13 << v9;
      v9 += 7;
      ++v10;
      if ((v12 & 0x80) == 0) {
        goto LABEL_12;
      }
    }
    uint64_t v11 = 0;
    LODWORD(v10) = 0;
LABEL_12:
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    unsigned int v16 = 0;
    std::string::size_type v17 = &v5[v10 - v5];
    int v18 = (int)v17;
    do
    {
      if (!&v17[v14]) {
        goto LABEL_22;
      }
      char v19 = v17[v14];
      uint64_t v20 = v19 & 0x7F;
      if (v16 >= 0x40 && (v19 & 0x7F) != 0)
      {
        int v8 = v17 + v14;
LABEL_22:
        uint64_t v21 = &v17[v8 - v17];
        size_t v30 = v32;
        long long v31 = xmmword_1CFAC3020;
        goto LABEL_23;
      }
      if ((unint64_t)(v20 << v16) >> v16 != v20)
      {
        int v8 = v18;
        goto LABEL_22;
      }
      v15 += v20 << v16;
      v16 += 7;
      ++v18;
      ++v14;
    }
    while (v19 < 0);
    size_t v30 = v32;
    long long v31 = xmmword_1CFAC3020;
    if (v15) {
      operator new();
    }
    uint64_t v21 = &v17[v14];
LABEL_23:
    *(void *)&long long v26 = v21;
    *((void *)&v26 + sub_1CD7485C0(this + 1) = v11;
    BOOL v5 = &v21[v11];
    uint64_t v27 = v29;
    uint64_t v28 = 0;
    llvm::StringRef::split(&v26, (uint64_t)&v27, "\x01", 1uLL, -1, 1);
    if (v28)
    {
      BOOL v22 = (char *)v27;
      uint64_t v23 = (char *)v27 + 16 * v28;
      while (1)
      {
        sub_1CD74C38C(a3, *(unsigned __int8 **)v22, *((void *)v22 + 1), a4);
        if (*a4) {
          break;
        }
        v22 += 16;
        if (v22 == v23) {
          goto LABEL_27;
        }
      }
      int v25 = 1;
    }
    else
    {
LABEL_27:
      if (v5 < v7)
      {
        uint64_t v24 = (unsigned char *)(&v7[-v11] - v21);
        while (!*v5)
        {
          ++v5;
          if (!--v24)
          {
            int v25 = 0;
            BOOL v5 = v7;
            goto LABEL_33;
          }
        }
      }
      int v25 = 0;
    }
LABEL_33:
    if (v27 != v29) {
      free(v27);
    }
    if (v30 != v32) {
      free(v30);
    }
  }
  while (!v25);
}

double llvm::InstrProfRecord::accumulateCounts(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(uint64_t **)a1;
  uint64_t v2 = *(uint64_t **)(a1 + 8);
  BOOL v4 = v2 == *(uint64_t **)a1;
  *(void *)a2 += ((uint64_t)v2 - *(void *)a1) >> 3;
  if (v4)
  {
    double v7 = 0.0;
  }
  else
  {
    unint64_t v5 = 0;
    do
    {
      uint64_t v6 = *v3++;
      v5 += v6;
    }
    while (v3 != v2);
    double v7 = (double)v5;
  }
  uint64_t v8 = 0;
  char v9 = 1;
  *(double *)(a2 + 8) = v7 + *(double *)(a2 + 8);
  do
  {
    char v10 = v9;
    uint64_t v11 = *(void *)(a1 + 24);
    if (v11)
    {
      if (v10) {
        uint64_t v12 = 0;
      }
      else {
        uint64_t v12 = 24;
      }
      uint64_t v13 = *(void *)(v11 + v12);
      uint64_t v14 = 32;
      if (v10) {
        uint64_t v14 = 8;
      }
      uint64_t v15 = -1431655765 * ((unint64_t)(*(void *)(v11 + v14) - v13) >> 3);
      if (v15)
      {
        for (uint64_t i = 0; i != v15; ++i)
        {
          if (v10) {
            uint64_t v17 = 0;
          }
          else {
            uint64_t v17 = 24;
          }
          if (*(void *)(*(void *)(*(void *)(a1 + 24) + v17) + 24 * i + 16)) {
            operator new[]();
          }
        }
      }
    }
    char v9 = 0;
    uint64_t v18 = a2 + 8 * v8;
    double result = *(double *)(v18 + 16) + (double)0;
    *(double *)(v18 + 16) = result;
    uint64_t v8 = 1;
  }
  while ((v10 & 1) != 0);
  return result;
}

uint64_t sub_1CCCDB1F0@<X0>(uint64_t result@<X0>, int a2@<W1>, unsigned int a3@<W2>, void *a4@<X3>, void *a5@<X8>)
{
  if (a2) {
    uint64_t v5 = 24;
  }
  else {
    uint64_t v5 = 0;
  }
  if (*(void *)(*(void *)(*(void *)(result + 24) + v5) + 24 * a3 + 16)) {
    operator new[]();
  }
  if (a4) {
    *a4 = 0;
  }
  *a5 = 0;
  return result;
}

double llvm::InstrProfValueSiteRecord::overlap(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  sub_1CCCDE170(*(uint64_t **)(a1 + 8), (uint64_t *)a1, *(void *)(a1 + 16));
  sub_1CCCDE170(*(uint64_t **)(a2 + 8), (uint64_t *)a2, *(void *)(a2 + 16));
  char v10 = *(void **)(a1 + 8);
  uint64_t v11 = *(void **)(a2 + 8);
  double v12 = 0.0;
  BOOL v13 = v10 == (void *)a1 || v11 == (void *)a2;
  double v14 = 0.0;
  if (!v13)
  {
    uint64_t v17 = a4 + 8 * a3;
    uint64_t v18 = (double *)(v17 + 16);
    char v19 = (double *)(v17 + 48);
    uint64_t v20 = a5 + 8 * a3;
    uint64_t v21 = (double *)(v20 + 16);
    BOOL v22 = (double *)(v20 + 48);
    do
    {
      unint64_t v23 = v11[2];
      while (1)
      {
        unint64_t v24 = v10[2];
        if (v24 == v23) {
          break;
        }
        if (v24 >= v23) {
          goto LABEL_25;
        }
        char v10 = (void *)v10[1];
        if (v10 == (void *)a1) {
          goto LABEL_6;
        }
      }
      double v25 = *v19;
      double v26 = 0.0;
      BOOL v27 = *v18 < 1.0 || v25 < 1.0;
      double v28 = 0.0;
      if (!v27)
      {
        double v28 = (double)(unint64_t)v10[3] / *v18;
        double v29 = (double)(unint64_t)v11[3] / v25;
        if (v29 < v28) {
          double v28 = v29;
        }
      }
      double v30 = *v22;
      if (*v21 >= 1.0 && v30 >= 1.0)
      {
        double v26 = (double)(unint64_t)v10[3] / *v21;
        double v32 = (double)(unint64_t)v11[3] / v30;
        if (v32 < v26) {
          double v26 = v32;
        }
      }
      double v12 = v12 + v28;
      double v14 = v14 + v26;
      char v10 = (void *)v10[1];
LABEL_25:
      if (v10 == (void *)a1) {
        break;
      }
      uint64_t v11 = (void *)v11[1];
    }
    while (v11 != (void *)a2);
  }
LABEL_6:
  *(double *)(a4 + 8 * a3 + 80) = v12 + *(double *)(a4 + 8 * a3 + 80);
  uint64_t v15 = a5 + 8 * a3;
  double result = v14 + *(double *)(v15 + 80);
  *(double *)(v15 + 80) = result;
  return result;
}

void llvm::InstrProfRecord::overlapValueProfData(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *(void *)(a1 + 24);
  if (v5)
  {
    uint64_t v7 = 32;
    if (!a2) {
      uint64_t v7 = 8;
    }
    uint64_t v8 = 24;
    if (!a2) {
      uint64_t v8 = 0;
    }
    uint64_t v9 = -1431655765 * ((*(void *)(v5 + v7) - *(void *)(v5 + v8)) >> 3);
    if (v9)
    {
      BOOL v13 = (void *)sub_1CD74C670(a1, a2);
      uint64_t v14 = *(void *)(a3 + 24);
      if (v14)
      {
        uint64_t v15 = 24;
        if (!a2) {
          uint64_t v15 = 0;
        }
        uint64_t v16 = *(void *)(v14 + v15);
      }
      else
      {
        uint64_t v16 = 0;
      }
      uint64_t v17 = 0;
      do
      {
        llvm::InstrProfValueSiteRecord::overlap(*v13 + v17, v16 + v17, a2, a4, a5);
        v17 += 24;
        --v9;
      }
      while (v9);
    }
  }
}

void llvm::InstrProfRecord::overlap(void *a1, uint64_t *a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  llvm::InstrProfRecord::accumulateCounts((uint64_t)a1, a4);
  if (a1[1] - *a1 != a2[1] - *a2) {
    goto LABEL_26;
  }
  char v10 = (void *)a1[3];
  uint64_t v11 = (void *)a2[3];
  if (v10)
  {
    int v12 = -1431655765 * ((v10[1] - *v10) >> 3);
    if (!v11)
    {
      if (v12) {
        goto LABEL_26;
      }
      int v14 = 0;
      int v13 = -1431655765 * ((v10[4] - v10[3]) >> 3);
      goto LABEL_11;
    }
    if (v12 != -1431655765 * ((v11[1] - *v11) >> 3)) {
      goto LABEL_26;
    }
    int v13 = -1431655765 * ((v10[4] - v10[3]) >> 3);
LABEL_8:
    int v14 = -1431655765 * ((v11[4] - v11[3]) >> 3);
LABEL_11:
    if (v13 == v14) {
      goto LABEL_12;
    }
    goto LABEL_26;
  }
  if (!v11)
  {
LABEL_12:
    llvm::InstrProfRecord::overlapValueProfData((uint64_t)a1, 0, (uint64_t)a2, a3, a4);
    llvm::InstrProfRecord::overlapValueProfData((uint64_t)a1, 1u, (uint64_t)a2, a3, a4);
    uint64_t v15 = *a2;
    uint64_t v16 = a2[1];
    unint64_t v17 = (v16 - *a2) >> 3;
    if (v16 == *a2)
    {
      unint64_t v19 = 0;
      double v24 = 0.0;
    }
    else
    {
      uint64_t v18 = 0;
      unint64_t v19 = 0;
      double v20 = *(double *)(a3 + 8);
      double v21 = *(double *)(a3 + 40);
      BOOL v22 = v20 < 1.0;
      if (v21 < 1.0) {
        BOOL v22 = 1;
      }
      if (v17 <= 1) {
        uint64_t v23 = 1;
      }
      else {
        uint64_t v23 = (v16 - *a2) >> 3;
      }
      double v24 = 0.0;
      do
      {
        unint64_t v25 = *(void *)(v15 + 8 * v18);
        double v26 = 0.0;
        if (!v22)
        {
          double v26 = (double)*(unint64_t *)(*a1 + 8 * v18) / v20;
          if ((double)v25 / v21 < v26) {
            double v26 = (double)v25 / v21;
          }
        }
        double v24 = v24 + v26;
        if (v25 > v19) {
          unint64_t v19 = *(void *)(v15 + 8 * v18);
        }
        ++v18;
      }
      while (v23 != v18);
    }
    *(double *)(a3 + 72) = v24 + *(double *)(a3 + 72);
    ++*(void *)(a3 + 64);
    if (v19 >= a5)
    {
      if (v16 == v15)
      {
        double v32 = 0.0;
      }
      else
      {
        uint64_t v27 = 0;
        double v28 = *(double *)(a4 + 8);
        double v29 = *(double *)(a4 + 40);
        BOOL v30 = v28 < 1.0;
        if (v29 < 1.0) {
          BOOL v30 = 1;
        }
        if (v17 <= 1) {
          uint64_t v31 = 1;
        }
        else {
          uint64_t v31 = v17;
        }
        double v32 = 0.0;
        do
        {
          double v33 = 0.0;
          if (!v30)
          {
            double v33 = (double)*(unint64_t *)(*a1 + 8 * v27) / v28;
            if ((double)*(unint64_t *)(v15 + 8 * v27) / v29 < v33) {
              double v33 = (double)*(unint64_t *)(v15 + 8 * v27) / v29;
            }
          }
          double v32 = v32 + v33;
          ++v27;
        }
        while (v31 != v27);
      }
      *(double *)(a4 + 72) = v32;
      *(void *)(a4 + 64) = v17;
      *(unsigned char *)(a4 + 208) = 1;
    }
    return;
  }
  int v13 = -1431655765 * ((v11[1] - *v11) >> 3);
  if (!v13) {
    goto LABEL_8;
  }
LABEL_26:

  llvm::OverlapStats::addOneMismatch(a3, a4 + 32);
}

uint64_t llvm::OverlapStats::addOneMismatch(uint64_t result, uint64_t a2)
{
  uint64_t v2 = 0;
  ++*(void *)(result + 96);
  *(double *)(result + 104) = *(double *)(result + 104) + *(double *)(a2 + 8) / *(double *)(result + 40);
  char v3 = 1;
  do
  {
    char v4 = v3;
    uint64_t v5 = result + 8 * v2;
    double v6 = *(double *)(v5 + 48);
    if (v6 >= 1.0) {
      *(double *)(v5 + 112) = *(double *)(v5 + 112) + *(double *)(a2 + 8 * v2 + 16) / v6;
    }
    char v3 = 0;
    uint64_t v2 = 1;
  }
  while ((v4 & 1) != 0);
  return result;
}

void *llvm::InstrProfValueSiteRecord::merge(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t (*a4)(uint64_t, uint64_t), uint64_t a5)
{
  sub_1CCCDE170(*(uint64_t **)(a1 + 8), (uint64_t *)a1, *(void *)(a1 + 16));
  double result = sub_1CCCDE170(*(uint64_t **)(a2 + 8), (uint64_t *)a2, *(void *)(a2 + 16));
  uint64_t v11 = *(void **)(a2 + 8);
  if (v11 != (void *)a2)
  {
    int v12 = *(void **)(a1 + 8);
    int v13 = __clz(a3);
    do
    {
      int v14 = v11 + 2;
      uint64_t v15 = (void *)a1;
      if (v12 != (void *)a1)
      {
        unint64_t v16 = *v14;
        while (1)
        {
          unint64_t v17 = v12[2];
          if (v17 >= v16) {
            break;
          }
          int v12 = (void *)v12[1];
          if (v12 == (void *)a1)
          {
            uint64_t v15 = (void *)a1;
            goto LABEL_16;
          }
        }
        if (v17 == v16)
        {
          unint64_t v18 = v11[3];
          unint64_t v19 = v12[3];
          unsigned int v20 = __clz(v18) + v13;
          if (v20 >= 0x40)
          {
            unint64_t v21 = v18 * a3;
            goto LABEL_12;
          }
          if (v20 != 63
            || (unint64_t v25 = (v18 >> 1) * a3, (v25 & 0x8000000000000000) != 0)
            || (unint64_t v21 = 2 * v25, (v18 & 1) != 0)
            && (v21 + a3 >= v21 ? (BOOL v26 = v21 + a3 >= a3) : (BOOL v26 = 0), v21 += a3, !v26))
          {
            v12[3] = -1;
            goto LABEL_27;
          }
LABEL_12:
          uint64_t v22 = v21 + v19;
          BOOL v23 = v21 + v19 >= v19 && v21 + v19 >= v21;
          if (!v23) {
            uint64_t v22 = -1;
          }
          v12[3] = v22;
          if (!v23) {
LABEL_27:
          }
            double result = (void *)a4(a5, 17);
          uint64_t v15 = (void *)v12[1];
          goto LABEL_17;
        }
        uint64_t v15 = v12;
      }
LABEL_16:
      double result = operator new(0x20uLL);
      void *result = 0;
      result[1] = 0;
      *((_OWORD *)result + sub_1CD7485C0(this + 1) = *(_OWORD *)v14;
      uint64_t v24 = *v15;
      *(void *)(v24 + 8) = result;
      void *result = v24;
      void *v15 = result;
      result[1] = v15;
      ++*(void *)(a1 + 16);
LABEL_17:
      uint64_t v11 = (void *)v11[1];
      int v12 = v15;
    }
    while (v11 != (void *)a2);
  }
  return result;
}

uint64_t llvm::InstrProfValueSiteRecord::scale(uint64_t result, unint64_t a2, unint64_t a3, uint64_t (*a4)(uint64_t, uint64_t), uint64_t a5)
{
  uint64_t v5 = *(void *)(result + 8);
  if (v5 != result)
  {
    uint64_t v10 = result;
    int v11 = __clz(a2);
    unint64_t v12 = 0xFFFFFFFFFFFFFFFFLL / a3;
    do
    {
      unint64_t v13 = *(void *)(v5 + 24);
      unsigned int v14 = __clz(v13) + v11;
      if (v14 < 0x40)
      {
        if (v14 != 63 || (unint64_t v16 = (v13 >> 1) * a2, (v16 & 0x8000000000000000) != 0))
        {
          *(void *)(v5 + 24) = v12;
LABEL_14:
          double result = a4(a5, 17);
          goto LABEL_15;
        }
        unint64_t v15 = 2 * v16;
        if (v13)
        {
          unint64_t v17 = v15 + a2;
          BOOL v18 = v15 + a2 >= v15 && v15 + a2 >= a2;
          if (!v18) {
            unint64_t v17 = -1;
          }
          *(void *)(v5 + 24) = v17 / a3;
          if (v18) {
            goto LABEL_15;
          }
          goto LABEL_14;
        }
      }
      else
      {
        unint64_t v15 = v13 * a2;
      }
      *(void *)(v5 + 24) = v15 / a3;
LABEL_15:
      uint64_t v5 = *(void *)(v5 + 8);
    }
    while (v5 != v10);
  }
  return result;
}

void *llvm::InstrProfRecord::mergeValueProfData(void *result, int a2, uint64_t a3, unint64_t a4, uint64_t (*a5)(uint64_t, uint64_t), uint64_t a6)
{
  uint64_t v9 = (void *)result[3];
  if (v9)
  {
    if (!a2)
    {
      LODWORD(v10) = -1431655765 * ((v9[1] - *v9) >> 3);
      unint64_t v12 = (void *)(a3 + 24);
      int v11 = *(void **)(a3 + 24);
      if (!v11) {
        goto LABEL_11;
      }
      goto LABEL_9;
    }
    LODWORD(v10) = -1431655765 * ((v9[4] - v9[3]) >> 3);
  }
  else
  {
    LODWORD(v10) = 0;
  }
  unint64_t v12 = (void *)(a3 + 24);
  int v11 = *(void **)(a3 + 24);
  if (!v11) {
    goto LABEL_11;
  }
  if (!a2)
  {
LABEL_9:
    unint64_t v13 = v11 + 1;
    goto LABEL_10;
  }
  unint64_t v13 = v11 + 4;
  v11 += 3;
LABEL_10:
  LODWORD(v1sub_1CD7485C0(this + 1) = -1431655765 * ((*v13 - *v11) >> 3);
LABEL_11:
  if (v10 == v11)
  {
    if (v10)
    {
      unsigned int v14 = (void *)sub_1CD74C670((uint64_t)result, a2);
      if (*v12)
      {
        uint64_t v15 = 24;
        if (!a2) {
          uint64_t v15 = 0;
        }
        uint64_t v16 = *(void *)(*v12 + v15);
      }
      else
      {
        uint64_t v16 = 0;
      }
      uint64_t v17 = 0;
      uint64_t v10 = v10;
      BOOL v18 = a5;
      do
      {
        double result = llvm::InstrProfValueSiteRecord::merge(*v14 + v17, v16 + v17, a4, v18, a6);
        BOOL v18 = a5;
        v17 += 24;
        --v10;
      }
      while (v10);
    }
  }
  else
  {
    return (void *)a5(a6, 18);
  }
  return result;
}

void *llvm::InstrProfRecord::merge(uint64_t *a1, void *a2, unint64_t a3, uint64_t (*a4)(uint64_t, uint64_t), uint64_t a5)
{
  double v6 = a4;
  unint64_t v7 = (a1[1] - *a1) >> 3;
  uint64_t v8 = a2[1];
  if (v7 == (v8 - *a2) >> 3)
  {
    if (v8 != *a2)
    {
      uint64_t v12 = 0;
      int v13 = __clz(a3);
      if (v7 <= 1) {
        uint64_t v14 = 1;
      }
      else {
        uint64_t v14 = (a1[1] - *a1) >> 3;
      }
      while (1)
      {
        unint64_t v15 = *(void *)(*a2 + 8 * v12);
        uint64_t v16 = *a1;
        unint64_t v17 = *(void *)(*a1 + 8 * v12);
        unsigned int v18 = __clz(v15) + v13;
        if (v18 >= 0x40) {
          break;
        }
        if (v18 == 63)
        {
          unint64_t v22 = (v15 >> 1) * a3;
          if ((v22 & 0x8000000000000000) == 0)
          {
            unint64_t v19 = 2 * v22;
            if ((v15 & 1) == 0) {
              goto LABEL_8;
            }
            BOOL v23 = v19 + a3 >= v19 && v19 + a3 >= a3;
            v19 += a3;
            if (v23) {
              goto LABEL_8;
            }
          }
        }
        *(void *)(v16 + 8 * v12) = -1;
LABEL_20:
        a4(a5, 17);
        double v6 = a4;
LABEL_21:
        if (v14 == ++v12) {
          goto LABEL_22;
        }
      }
      unint64_t v19 = v15 * a3;
LABEL_8:
      uint64_t v20 = v19 + v17;
      BOOL v21 = v19 + v17 >= v17 && v19 + v17 >= v19;
      if (!v21) {
        uint64_t v20 = -1;
      }
      *(void *)(v16 + 8 * v12) = v20;
      if (v21) {
        goto LABEL_21;
      }
      goto LABEL_20;
    }
LABEL_22:
    llvm::InstrProfRecord::mergeValueProfData(a1, 0, (uint64_t)a2, a3, v6, a5);
    return llvm::InstrProfRecord::mergeValueProfData(a1, 1, (uint64_t)a2, a3, a4, a5);
  }
  else
  {
    return (void *)a4(a5, 16);
  }
}

uint64_t llvm::InstrProfRecord::scaleValueProfData(uint64_t result, int a2, unint64_t a3, unint64_t a4, uint64_t (*a5)(uint64_t, uint64_t), uint64_t a6)
{
  uint64_t v6 = *(void *)(result + 24);
  if (v6)
  {
    uint64_t v7 = 32;
    if (!a2) {
      uint64_t v7 = 8;
    }
    uint64_t v8 = 24;
    if (!a2) {
      uint64_t v8 = 0;
    }
    uint64_t v9 = *(void *)(v6 + v8);
    uint64_t v10 = *(void *)(v6 + v7) - v9;
    if (v10)
    {
      uint64_t v15 = 24 * (v10 / 24);
      do
      {
        double result = llvm::InstrProfValueSiteRecord::scale(v9, a3, a4, a5, a6);
        v9 += 24;
        v15 -= 24;
      }
      while (v15);
    }
  }
  return result;
}

uint64_t llvm::InstrProfRecord::scale(unint64_t **a1, unint64_t a2, unint64_t a3, uint64_t (*a4)(uint64_t, uint64_t), uint64_t a5)
{
  uint64_t v10 = *a1;
  int v11 = a1[1];
  if (*a1 != v11)
  {
    int v12 = __clz(a2);
    do
    {
      unint64_t v13 = *v10;
      unsigned int v14 = __clz(*v10) + v12;
      if (v14 < 0x40)
      {
        if (v14 != 63 || (unint64_t v16 = (v13 >> 1) * a2, (v16 & 0x8000000000000000) != 0))
        {
          unint64_t *v10 = 0xFFFFFFFFFFFFFFFFLL / a3;
LABEL_14:
          a4(a5, 17);
          goto LABEL_15;
        }
        unint64_t v15 = 2 * v16;
        if (v13)
        {
          unint64_t v17 = v15 + a2;
          BOOL v18 = v15 + a2 >= v15 && v15 + a2 >= a2;
          if (!v18) {
            unint64_t v17 = -1;
          }
          unint64_t *v10 = v17 / a3;
          if (v18) {
            goto LABEL_15;
          }
          goto LABEL_14;
        }
      }
      else
      {
        unint64_t v15 = v13 * a2;
      }
      unint64_t *v10 = v15 / a3;
LABEL_15:
      ++v10;
    }
    while (v10 != v11);
  }
  llvm::InstrProfRecord::scaleValueProfData((uint64_t)a1, 0, a2, a3, a4, a5);

  return llvm::InstrProfRecord::scaleValueProfData((uint64_t)a1, 1, a2, a3, a4, a5);
}

unint64_t llvm::InstrProfRecord::remapValue(llvm::InstrProfRecord *this, unint64_t a2, int a3, llvm::InstrProfSymtab *a4)
{
  if (!a3 && a4) {
    return llvm::InstrProfSymtab::getFunctionHashFromAddress(a4, a2);
  }
  else {
    return a2;
  }
}

uint64_t *llvm::InstrProfRecord::addValueData(uint64_t a1, int a2, int a3, long long *a4, unsigned int a5, llvm::InstrProfSymtab *this)
{
  BOOL v23 = a4;
  if (a5)
  {
    if (a2) {
      BOOL v14 = 1;
    }
    else {
      BOOL v14 = this == 0;
    }
    int v15 = !v14;
    uint64_t v16 = a5;
    unint64_t v17 = (unint64_t *)a4;
    uint64_t v18 = a5;
    do
    {
      unint64_t FunctionHashFromAddress = *v17;
      if (v15) {
        unint64_t FunctionHashFromAddress = llvm::InstrProfSymtab::getFunctionHashFromAddress(this, FunctionHashFromAddress);
      }
      *unint64_t v17 = FunctionHashFromAddress;
      v17 += 2;
      --v18;
    }
    while (v18);
    uint64_t v20 = sub_1CD74C670(a1, a2);
    unint64_t v22 = &a4[v16];
    BOOL v21 = *(void **)(v20 + 8);
    if ((unint64_t)v21 >= *(void *)(v20 + 16))
    {
      double result = sub_1CCCDE638((uint64_t **)v20, &v23, &v22);
    }
    else
    {
      sub_1CCCDE7C4(v20 + 16, v21, &v23, &v22);
      double result = v21 + 3;
    }
    *(void *)(v20 + 8) = result;
  }
  else
  {
    uint64_t v8 = sub_1CD74C670(a1, a2);
    uint64_t v9 = v8;
    uint64_t v10 = *(void **)(v8 + 8);
    if ((unint64_t)v10 >= *(void *)(v8 + 16))
    {
      double result = sub_1CCCDE4C8((uint64_t **)v8);
    }
    else
    {
      void *v10 = v10;
      v10[1] = v10;
      double result = v10 + 3;
      uint64_t v10[2] = 0;
    }
    *(void *)(v9 + 8) = result;
  }
  return result;
}

uint64_t llvm::getValueProfDataSize(uint64_t *a1)
{
  uint64_t v2 = 0;
  uint64_t v3 = *a1;
  char v4 = 1;
  uint64_t v5 = 8;
  do
  {
    char v6 = v4;
    int v7 = ((uint64_t (*)(uint64_t, uint64_t))a1[2])(v3, v2);
    if (v7) {
      uint64_t v5 = ((v7 + 15) & 0xFFFFFFF8) + v5 + 16 * ((unsigned int (*)(uint64_t, uint64_t))a1[3])(v3, v2);
    }
    char v4 = 0;
    uint64_t v2 = 1;
  }
  while ((v6 & 1) != 0);
  return v5;
}

_DWORD *llvm::serializeValueProfRecordFrom(_DWORD *result, uint64_t *a2, uint64_t a3, unsigned int a4)
{
  uint64_t v4 = *a2;
  uint64_t *result = a3;
  result[1] = a4;
  if (a4)
  {
    uint64_t v7 = 0;
    uint64_t v8 = (char *)result + ((a4 + 15) & 0xFFFFFFF8);
    uint64_t v9 = a4;
    uint64_t v10 = result + 2;
    do
    {
      unsigned int v11 = ((uint64_t (*)(uint64_t, uint64_t, uint64_t))a2[4])(v4, a3, v7);
      *((unsigned char *)v10 + v7) = v11;
      double result = (_DWORD *)((uint64_t (*)(uint64_t, char *, uint64_t, uint64_t))a2[6])(v4, v8, a3, v7);
      v8 += 16 * v11;
      ++v7;
    }
    while (v9 != v7);
  }
  return result;
}

unsigned int *llvm::serializeValueProfDataFrom(void *a1, unsigned int *a2)
{
  if (a2)
  {
    uint64_t v3 = a2;
    unsigned int v4 = *a2;
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t v6 = *a1;
    char v7 = 1;
    unsigned int v4 = 8;
    do
    {
      char v8 = v7;
      int v9 = ((uint64_t (*)(uint64_t, uint64_t))a1[2])(v6, v5);
      if (v9) {
        v4 += ((v9 + 15) & 0xFFFFFFF8) + 16 * ((uint64_t (*)(uint64_t, uint64_t))a1[3])(v6, v5);
      }
      char v7 = 0;
      uint64_t v5 = 1;
    }
    while ((v8 & 1) != 0);
    uint64_t v3 = (unsigned int *)((uint64_t (*)(void))a1[7])(v4);
  }
  *uint64_t v3 = v4;
  uint64_t v10 = 0;
  v3[1] = ((uint64_t (*)(void))a1[1])(*a1);
  unsigned int v11 = v3 + 2;
  char v12 = 1;
  do
  {
    char v13 = v12;
    unsigned int v14 = ((uint64_t (*)(void, uint64_t))a1[2])(*a1, v10);
    if (v14)
    {
      uint64_t v15 = 0;
      uint64_t v16 = *a1;
      *unsigned int v11 = v10;
      v11[1] = v14;
      unint64_t v17 = (char *)v11 + ((v14 + 15) & 0xFFFFFFF8);
      uint64_t v18 = v14;
      do
      {
        unsigned int v19 = ((uint64_t (*)(uint64_t, uint64_t, uint64_t))a1[4])(v16, v10, v15);
        *((unsigned char *)v11 + v15 + 8) = v19;
        ((void (*)(uint64_t, char *, uint64_t, uint64_t))a1[6])(v16, v17, v10, v15);
        v17 += 16 * v19;
        ++v15;
      }
      while (v18 != v15);
      int v20 = v11[1];
      if (v20)
      {
        int v21 = 0;
        unint64_t v22 = (unsigned __int8 *)(v11 + 2);
        uint64_t v23 = v11[1];
        do
        {
          int v24 = *v22++;
          v21 += v24;
          --v23;
        }
        while (v23);
      }
      else
      {
        int v21 = 0;
      }
      unsigned int v11 = (_DWORD *)((char *)v11 + 16 * v21 + ((v20 + 15) & 0xFFFFFFF8));
    }
    char v12 = 0;
    uint64_t v10 = 1;
  }
  while ((v13 & 1) != 0);
  return v3;
}

uint64_t llvm::getNumValueKindsInstrProf(llvm *this, const void *a2)
{
  uint64_t v2 = (void *)*((void *)this + 3);
  if (!v2) {
    return 0;
  }
  if (v2[4] == v2[3]) {
    return v2[1] != *v2;
  }
  return (v2[1] != *v2) + 1;
}

uint64_t llvm::getNumValueSitesInstrProf(llvm *this, const void *a2)
{
  uint64_t v2 = *((void *)this + 3);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = 32;
  if (!a2) {
    uint64_t v3 = 8;
  }
  uint64_t v4 = 24;
  if (!a2) {
    uint64_t v4 = 0;
  }
  return -1431655765 * ((*(void *)(v2 + v3) - *(void *)(v2 + v4)) >> 3);
}

uint64_t llvm::getNumValueDataInstrProf(llvm *this, const void *a2)
{
  uint64_t v2 = *((void *)this + 3);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = 8;
  if (a2) {
    uint64_t v3 = 32;
  }
  uint64_t v4 = 24;
  if (!a2) {
    uint64_t v4 = 0;
  }
  uint64_t v5 = *(void *)(v2 + v4);
  uint64_t v6 = *(void *)(v2 + v3) - v5;
  if (!v6) {
    return 0;
  }
  LODWORD(result) = 0;
  uint64_t v8 = 24 * (v6 / 24);
  int v9 = (int *)(v5 + 16);
  do
  {
    int v10 = *v9;
    v9 += 6;
    uint64_t result = (result + v10);
    v8 -= 24;
  }
  while (v8);
  return result;
}

uint64_t llvm::getNumValueDataForSiteInstrProf(llvm *this, const void *a2, unsigned int a3)
{
  if (a2) {
    uint64_t v3 = 24;
  }
  else {
    uint64_t v3 = 0;
  }
  return *(unsigned int *)(*(void *)(*((void *)this + 3) + v3) + 24 * a3 + 16);
}

__n128 llvm::getValueForSiteInstrProf(uint64_t a1, uint64_t a2, int a3, unsigned int a4)
{
  uint64_t v4 = *(void *)(a1 + 24);
  if (v4)
  {
    uint64_t v5 = 24;
    if (!a3) {
      uint64_t v5 = 0;
    }
    uint64_t v4 = *(void *)(v4 + v5);
  }
  uint64_t v6 = v4 + 24 * a4;
  char v7 = *(__n128 **)(v6 + 8);
  if (v7 != (__n128 *)v6)
  {
    unsigned int v8 = 0;
    do
    {
      __n128 result = v7[1];
      *(__n128 *)(a2 + 16 * v8++) = result;
      char v7 = (__n128 *)v7->n128_u64[1];
    }
    while (v7 != (__n128 *)v6);
  }
  return result;
}

void llvm::allocValueProfDataInstrProf(llvm *this)
{
  uint64_t v2 = operator new((size_t)this);
  void *v2 = 0;

  bzero(v2, (size_t)this);
}

uint64_t llvm::ValueProfData::getSize(llvm *this)
{
  uint64_t v2 = 0;
  uint64_t v3 = (uint64_t (*)(llvm *, const void *))off_1EC7DFB80[0];
  uint64_t v4 = (unsigned int (*)(llvm *, const void *))off_1EC7DFB88;
  char v5 = 1;
  uint64_t v6 = 8;
  do
  {
    char v7 = v5;
    int v8 = v3(this, (const void *)v2);
    if (v8) {
      uint64_t v6 = ((v8 + 15) & 0xFFFFFFF8) + v6 + 16 * v4(this, (const void *)v2);
    }
    char v5 = 0;
    uint64_t v2 = 1;
  }
  while ((v7 & 1) != 0);
  return v6;
}

unsigned int *llvm::ValueProfData::serializeFrom@<X0>(uint64_t a1@<X0>, unsigned int **a2@<X8>)
{
  qword_1EC7DFB70 = a1;
  __n128 result = llvm::serializeValueProfDataFrom(&qword_1EC7DFB70, 0);
  *a2 = result;
  return result;
}

unsigned int *llvm::ValueProfData::swapBytesFromHost(unsigned int *result, int a2)
{
  if (a2 != 1)
  {
    uint64_t v2 = result;
    unsigned int v3 = result[1];
    if (v3)
    {
      unsigned int v5 = 0;
      result += 2;
      do
      {
        unsigned int v6 = result[1];
        if (v6)
        {
          int v7 = 0;
          int v8 = (unsigned __int8 *)(result + 2);
          uint64_t v9 = result[1];
          do
          {
            int v10 = *v8++;
            v7 += v10;
            --v9;
          }
          while (v9);
        }
        else
        {
          int v7 = 0;
        }
        unsigned int v11 = (unsigned int *)((char *)&result[4 * v7] + ((v6 + 15) & 0xFFFFFFF8));
        llvm::ValueProfRecord::swapBytes(result, 1, a2);
        ++v5;
        unsigned int v3 = v2[1];
        __n128 result = v11;
      }
      while (v5 < v3);
    }
    unsigned int *v2 = bswap32(*v2);
    v2[1] = bswap32(v3);
  }
  return result;
}

uint64_t llvm::getValueProfDataFromInst(uint64_t a1, int a2, unsigned int a3, uint64_t a4, _DWORD *a5, void *a6, char a7)
{
  if ((*(unsigned char *)(a1 + 23) & 0x20) == 0) {
    return 0;
  }
  uint64_t v14 = ***(void ***)a1;
  uint64_t v54 = a1;
  int v15 = *(_DWORD *)(v14 + 2496);
  if (!v15)
  {
    unsigned int v52 = 0;
LABEL_59:
    unsigned int v19 = sub_1CC609054(v14 + 2480, (uint64_t)&v54, &v54, v52);
    uint64_t v53 = v54;
    void v19[3] = 0;
    void v19[4] = 0;
    *unsigned int v19 = v53;
    v19[1] = v19 + 3;
    void v19[2] = 0x100000000;
    goto LABEL_12;
  }
  uint64_t v16 = *(void *)(v14 + 2480);
  int v17 = v15 - 1;
  unsigned int v18 = v17 & ((a1 >> 4) ^ (a1 >> 9));
  unsigned int v19 = (void *)(v16 + 40 * v18);
  uint64_t v20 = *v19;
  if (*v19 != a1)
  {
    int v21 = 0;
    int v22 = 1;
    while (v20 != -4096)
    {
      if (v21) {
        BOOL v23 = 0;
      }
      else {
        BOOL v23 = v20 == -8192;
      }
      if (v23) {
        int v21 = v19;
      }
      unsigned int v24 = v18 + v22++;
      unsigned int v18 = v24 & v17;
      unsigned int v19 = (void *)(v16 + 40 * v18);
      uint64_t v20 = *v19;
      if (*v19 == a1) {
        goto LABEL_12;
      }
    }
    if (v21) {
      unsigned int v52 = v21;
    }
    else {
      unsigned int v52 = v19;
    }
    goto LABEL_59;
  }
LABEL_12:
  uint64_t v25 = *((unsigned int *)v19 + 4);
  if (v25)
  {
    BOOL v26 = (void *)(v19[1] + 8);
    uint64_t v27 = 16 * v25;
    while (*((_DWORD *)v26 - 2) != 2)
    {
      uint64_t result = 0;
      v26 += 2;
      v27 -= 16;
      if (!v27) {
        return result;
      }
    }
    uint64_t v29 = *v26;
    if (v29)
    {
      uint64_t v30 = *(unsigned int *)(v29 + 8);
      if (v30 >= 5)
      {
        uint64_t v31 = (void *)(v29 - 8 * v30);
        if (*v31)
        {
          uint64_t v32 = *(void *)(*v31 + 8);
          if (*(void *)v32 == 2 && *(_WORD *)(v32 + 24) == 20566)
          {
            uint64_t v33 = v31[1];
            if (*(unsigned char *)v33 == 1)
            {
              uint64_t v34 = *(void *)(v33 + 128);
              if (*(unsigned char *)(v34 + 16) == 16)
              {
                int v35 = (void *)(v34 + 24);
                if (*(_DWORD *)(v34 + 32) >= 0x41u) {
                  int v35 = (void *)*v35;
                }
                if (*v35 == a2)
                {
                  uint64_t v36 = v31[2];
                  if (*(unsigned char *)v36 == 1)
                  {
                    uint64_t v37 = *(void *)(v36 + 128);
                    if (*(unsigned char *)(v37 + 16) == 16)
                    {
                      BOOL v38 = (void *)(v37 + 24);
                      if (*(_DWORD *)(v37 + 32) >= 0x41u) {
                        BOOL v38 = (void *)*v38;
                      }
                      *a6 = *v38;
                      *a5 = 0;
                      if (!a3) {
                        return 1;
                      }
                      unint64_t v39 = 0;
                      unsigned int v40 = 5;
                      while (1)
                      {
                        uint64_t v41 = v29 - 8 * *(unsigned int *)(v29 + 8);
                        uint64_t v42 = *(void *)(v41 + 8 * (v40 - 2));
                        if (*(unsigned char *)v42 == 1)
                        {
                          uint64_t v43 = *(void *)(v42 + 128);
                          if (*(unsigned char *)(v43 + 16) != 16) {
                            uint64_t v43 = 0;
                          }
                        }
                        else
                        {
                          uint64_t v43 = 0;
                        }
                        uint64_t v44 = *(void *)(v41 + 8 * (v40 - 1));
                        if (*(unsigned char *)v44 != 1) {
                          break;
                        }
                        uint64_t result = 0;
                        uint64_t v45 = *(void *)(v44 + 128);
                        if (*(unsigned char *)(v45 + 16) == 16) {
                          uint64_t v46 = v45;
                        }
                        else {
                          uint64_t v46 = 0;
                        }
                        if (v43 && v46)
                        {
                          long long v47 = (void *)(v46 + 24);
                          if (*(_DWORD *)(v46 + 32) >= 0x41u) {
                            long long v47 = (void *)*v47;
                          }
                          size_t v48 = (void *)*v47;
                          if ((a7 & 1) != 0 || v48 != (void *)-1)
                          {
                            uint64_t v49 = (void *)(v43 + 24);
                            if (*(_DWORD *)(v43 + 32) >= 0x41u) {
                              uint64_t v49 = (void *)*v49;
                            }
                            uint64_t v50 = (void *)*v49;
                            int v51 = (void *)(a4 + 16 * v39);
                            *int v51 = v50;
                            v51[1] = v48;
                            *a5 = ++v39;
                          }
                          uint64_t result = 1;
                          if (v40 < v30)
                          {
                            v40 += 2;
                            if (v39 < a3) {
                              continue;
                            }
                          }
                        }
                        return result;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return 0;
}

uint64_t llvm::canRenameComdatFunc(llvm *this, const llvm::Function *a2, const llvm::Module *a3)
{
  if ((*((unsigned char *)this + 23) & 0x10) == 0) {
    return 0;
  }
  int v3 = (int)a2;
  uint64_t v5 = ***(void ***)this;
  uint64_t v6 = *(void *)(v5 + 152);
  uint64_t v7 = *(unsigned int *)(v5 + 168);
  if (v7)
  {
    LODWORD(v8) = (v7 - 1) & ((this >> 4) ^ (this >> 9));
    uint64_t v9 = v6 + 16 * v8;
    int v10 = *(llvm **)v9;
    if (*(llvm **)v9 == this) {
      goto LABEL_9;
    }
    int v11 = 1;
    while (v10 != (llvm *)-4096)
    {
      int v12 = v8 + v11++;
      uint64_t v8 = v12 & (v7 - 1);
      int v10 = *(llvm **)(v6 + 16 * v8);
      if (v10 == this)
      {
        uint64_t v9 = v6 + 16 * v8;
        goto LABEL_9;
      }
    }
  }
  uint64_t v9 = v6 + 16 * v7;
LABEL_9:
  if (!**(void **)(v9 + 8)) {
    return 0;
  }
  uint64_t result = llvm::needsComdatForCounter(this, *((const llvm::Function **)this + 5), a3);
  if (result)
  {
    if (!v3
      || (hasAddressTakeuint64_t n = llvm::Function::hasAddressTaken(this, 0, 0, 1, 0, 0),
          uint64_t result = 0,
          (hasAddressTaken & 1) == 0))
    {
      unsigned int v15 = *((_DWORD *)this + 8) & 0xF;
      BOOL v16 = v15 > 8;
      unsigned int v17 = (0x18Eu >> v15) & 1;
      if (v16) {
        return 0;
      }
      else {
        return v17;
      }
    }
  }
  return result;
}

llvm::Twine *llvm::OverlapStats::accumulateCounts@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, uint64_t *a5@<X8>)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  llvm::vfs::getRealFileSystem(&v14);
  __int16 v13 = 260;
  v12[0] = a2;
  llvm::InstrProfReader::create((llvm::InstrProfReader *)v12, v14, (uint64_t)&v15);
  uint64_t v10 = v15;
  if (v16)
  {
    if (!v15) {
      llvm::InstrProfReader::accumulateCounts(0, (void *)a1, a4);
    }
  }
  else
  {
    llvm::InstrProfReader::accumulateCounts(v15, (void *)a1, a4);
    if (v10)
    {
      (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
      uint64_t v10 = 0;
    }
  }
  uint64_t result = v14;
  if (v14 && atomic_fetch_add((atomic_uint *volatile)v14 + 2, 0xFFFFFFFF) == 1) {
    uint64_t result = (llvm::Twine *)(*(uint64_t (**)(llvm::Twine *))(*(void *)result + 8))(result);
  }
  if (!v10)
  {
    llvm::vfs::getRealFileSystem(&v14);
    __int16 v13 = 260;
    v12[0] = a3;
    llvm::InstrProfReader::create((llvm::InstrProfReader *)v12, v14, (uint64_t)&v15);
    uint64_t v10 = v15;
    if (v16)
    {
      if (!v15) {
        llvm::InstrProfReader::accumulateCounts(0, (void *)(a1 + 32), a4);
      }
    }
    else
    {
      llvm::InstrProfReader::accumulateCounts(v15, (void *)(a1 + 32), a4);
      if (v10)
      {
        (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
        uint64_t v10 = 0;
      }
    }
    uint64_t result = v14;
    if (v14 && atomic_fetch_add((atomic_uint *volatile)v14 + 2, 0xFFFFFFFF) == 1) {
      uint64_t result = (llvm::Twine *)(*(uint64_t (**)(llvm::Twine *))(*(void *)result + 8))(result);
    }
    if (!v10)
    {
      *(void *)(a1 + 168) = a2;
      *(void *)(a1 + 176) = a3;
      *(unsigned char *)(a1 + 208) = 1;
    }
  }
  *a5 = v10;
  return result;
}

uint64_t llvm::OverlapStats::addOneUnique(uint64_t result, uint64_t a2)
{
  uint64_t v2 = 0;
  ++*(void *)(result + 128);
  *(double *)(result + 136) = *(double *)(result + 136) + *(double *)(a2 + 8) / *(double *)(result + 40);
  char v3 = 1;
  do
  {
    char v4 = v3;
    uint64_t v5 = result + 8 * v2;
    double v6 = *(double *)(v5 + 48);
    if (v6 >= 1.0) {
      *(double *)(v5 + 144) = *(double *)(v5 + 144) + *(double *)(a2 + 8 * v2 + 16) / v6;
    }
    char v3 = 0;
    uint64_t v2 = 1;
  }
  while ((v4 & 1) != 0);
  return result;
}

llvm::raw_ostream *llvm::OverlapStats::dump(llvm::raw_ostream *this, llvm::raw_fd_ostream *a2)
{
  uint64_t v95 = *MEMORY[0x1E4F143B8];
  if (!*((unsigned char *)this + 208)) {
    return this;
  }
  uint64_t v3 = (uint64_t)this;
  int v4 = *((_DWORD *)this + 40);
  if (v4) {
    uint64_t v5 = "edge counters";
  }
  else {
    uint64_t v5 = "functions";
  }
  double v6 = (_OWORD *)*((void *)a2 + 4);
  int v87 = (uint64_t *)((char *)a2 + 32);
  unint64_t v7 = *((void *)a2 + 3) - (void)v6;
  if (v4)
  {
    if (v7 > 0xF)
    {
      *double v6 = *(_OWORD *)"Function level:\n";
      uint64_t v8 = *v87 + 16;
      *int v87 = v8;
    }
    else
    {
      llvm::raw_ostream::write(a2, "Function level:\n", 0x10uLL);
      uint64_t v8 = *((void *)a2 + 4);
    }
    if ((unint64_t)(*((void *)a2 + 3) - v8) > 0xB)
    {
      *(_DWORD *)(v8 + 8) = 540700271;
      *(void *)uint64_t v8 = *(void *)"  Function: ";
      uint64_t v9 = (_DWORD *)(*v87 + 12);
      *int v87 = (uint64_t)v9;
    }
    else
    {
      llvm::raw_ostream::write(a2, "  Function: ", 0xCuLL);
      uint64_t v9 = (_DWORD *)*((void *)a2 + 4);
    }
    uint64_t v10 = *(const void **)(v3 + 184);
    unint64_t v11 = *(void *)(v3 + 192);
    if (v11 <= *((void *)a2 + 3) - (void)v9)
    {
      if (v11)
      {
        memcpy(v9, v10, *(void *)(v3 + 192));
        uint64_t v9 = (_DWORD *)(*v87 + v11);
        *int v87 = (uint64_t)v9;
      }
    }
    else
    {
      llvm::raw_ostream::write(a2, (const char *)v10, *(void *)(v3 + 192));
      uint64_t v9 = (_DWORD *)*((void *)a2 + 4);
    }
    if (*((void *)a2 + 3) - (void)v9 > 6uLL)
    {
      *(_DWORD *)((char *)v9 + 3) = 1030255457;
      _DWORD *v9 = 1632118816;
      *v87 += 7;
    }
    else
    {
      llvm::raw_ostream::write(a2, " (Hash=", 7uLL);
    }
    sub_1CD098D14(a2, *(void *)(v3 + 200), 0, 0, 0);
    uint64_t v25 = (_WORD *)*((void *)a2 + 4);
    if (*((void *)a2 + 3) - (void)v25 <= 1uLL)
    {
      int v22 = ")\n";
      BOOL v23 = a2;
      size_t v24 = 2;
      goto LABEL_36;
    }
    _WORD *v25 = 2601;
    int v85 = v87;
    uint64_t v86 = *v87 + 2;
LABEL_193:
    *int v85 = v86;
    goto LABEL_37;
  }
  if (v7 > 0x2C)
  {
    qmemcpy(v6, "Profile overlap infomation for base_profile: ", 45);
    *v87 += 45;
  }
  else
  {
    llvm::raw_ostream::write(a2, "Profile overlap infomation for base_profile: ", 0x2DuLL);
  }
  uint64_t v12 = *(void *)(v3 + 168);
  char v13 = *(unsigned char *)(v12 + 23);
  if (v13 >= 0) {
    uint64_t v14 = *(const char **)(v3 + 168);
  }
  else {
    uint64_t v14 = *(const char **)v12;
  }
  if (v13 >= 0) {
    size_t v15 = v13 & 0x7F;
  }
  else {
    size_t v15 = *(void *)(v12 + 8);
  }
  llvm::raw_ostream::write(a2, v14, v15);
  uint64_t v16 = *((void *)a2 + 4);
  if ((unint64_t)(*((void *)a2 + 3) - v16) > 0x12)
  {
    *(_DWORD *)(v16 + 15) = 540697964;
    *(_OWORD *)uint64_t v16 = *(_OWORD *)" and test_profile: ";
    *v87 += 19;
  }
  else
  {
    llvm::raw_ostream::write(a2, " and test_profile: ", 0x13uLL);
  }
  uint64_t v17 = *(void *)(v3 + 176);
  char v18 = *(unsigned char *)(v17 + 23);
  if (v18 >= 0) {
    unsigned int v19 = *(const char **)(v3 + 176);
  }
  else {
    unsigned int v19 = *(const char **)v17;
  }
  if (v18 >= 0) {
    size_t v20 = v18 & 0x7F;
  }
  else {
    size_t v20 = *(void *)(v17 + 8);
  }
  llvm::raw_ostream::write(a2, v19, v20);
  int v21 = (_OWORD *)*((void *)a2 + 4);
  if (*((void *)a2 + 3) - (void)v21 > 0xFuLL)
  {
    _OWORD *v21 = *(_OWORD *)"\nProgram level:\n";
    int v85 = v87;
    uint64_t v86 = *v87 + 16;
    goto LABEL_193;
  }
  int v22 = "\nProgram level:\n";
  BOOL v23 = a2;
  size_t v24 = 16;
LABEL_36:
  llvm::raw_ostream::write(v23, v22, v24);
LABEL_37:
  BOOL v26 = (_DWORD *)*((void *)a2 + 4);
  if (*((void *)a2 + 3) - (void)v26 > 6uLL)
  {
    *(_DWORD *)((char *)v26 + 3) = 543584032;
    *BOOL v26 = 539172896;
    uint64_t v27 = (void *)(*v87 + 7);
    *int v87 = (uint64_t)v27;
  }
  else
  {
    llvm::raw_ostream::write(a2, "  # of ", 7uLL);
    uint64_t v27 = (void *)*((void *)a2 + 4);
  }
  if (v4) {
    size_t v28 = 13;
  }
  else {
    size_t v28 = 9;
  }
  if (v28 <= *((void *)a2 + 3) - (void)v27)
  {
    memcpy(v27, v5, v28);
    size_t v29 = *v87 + v28;
    *int v87 = v29;
  }
  else
  {
    llvm::raw_ostream::write(a2, v5, v28);
    size_t v29 = *((void *)a2 + 4);
  }
  if (*((void *)a2 + 3) - v29 > 9)
  {
    *(_WORD *)(v29 + 8) = 8250;
    *(void *)size_t v29 = *(void *)" overlap: ";
    *v87 += 10;
  }
  else
  {
    llvm::raw_ostream::write(a2, " overlap: ", 0xAuLL);
  }
  sub_1CD098D14(a2, *(void *)(v3 + 64), 0, 0, 0);
  uint64_t v30 = (unsigned char *)*((void *)a2 + 4);
  if (*((unsigned char **)a2 + 3) == v30)
  {
    llvm::raw_ostream::write(a2, "\n", 1uLL);
    uint64_t v31 = (_DWORD *)*((void *)a2 + 4);
  }
  else
  {
    unsigned char *v30 = 10;
    uint64_t v31 = (_DWORD *)(*v87 + 1);
    *int v87 = (uint64_t)v31;
  }
  if (*(void *)(v3 + 96))
  {
    if (*((void *)a2 + 3) - (void)v31 > 6uLL)
    {
      *(_DWORD *)((char *)v31 + 3) = 543584032;
      _DWORD *v31 = 539172896;
      uint64_t v32 = (void *)(*v87 + 7);
      *int v87 = (uint64_t)v32;
    }
    else
    {
      llvm::raw_ostream::write(a2, "  # of ", 7uLL);
      uint64_t v32 = (void *)*((void *)a2 + 4);
    }
    if (v28 <= *((void *)a2 + 3) - (void)v32)
    {
      memcpy(v32, v5, v28);
      size_t v33 = *v87 + v28;
      *int v87 = v33;
    }
    else
    {
      llvm::raw_ostream::write(a2, v5, v28);
      size_t v33 = *((void *)a2 + 4);
    }
    if (*((void *)a2 + 3) - v33 > 0xA)
    {
      *(_DWORD *)(v33 + 7) = 540698723;
      *(void *)size_t v33 = *(void *)" mismatch: ";
      *v87 += 11;
    }
    else
    {
      llvm::raw_ostream::write(a2, " mismatch: ", 0xBuLL);
    }
    sub_1CD098D14(a2, *(void *)(v3 + 96), 0, 0, 0);
    uint64_t v34 = (unsigned char *)*((void *)a2 + 4);
    if (*((unsigned char **)a2 + 3) == v34)
    {
      llvm::raw_ostream::write(a2, "\n", 1uLL);
      uint64_t v31 = (_DWORD *)*((void *)a2 + 4);
    }
    else
    {
      *uint64_t v34 = 10;
      uint64_t v31 = (_DWORD *)(*v87 + 1);
      *int v87 = (uint64_t)v31;
    }
  }
  if (*(void *)(v3 + 128))
  {
    if (*((void *)a2 + 3) - (void)v31 > 6uLL)
    {
      *(_DWORD *)((char *)v31 + 3) = 543584032;
      _DWORD *v31 = 539172896;
      int v35 = (void *)(*v87 + 7);
      *int v87 = (uint64_t)v35;
    }
    else
    {
      llvm::raw_ostream::write(a2, "  # of ", 7uLL);
      int v35 = (void *)*((void *)a2 + 4);
    }
    if (v28 <= *((void *)a2 + 3) - (void)v35)
    {
      memcpy(v35, v5, v28);
      uint64_t v36 = (void *)(*v87 + v28);
      *int v87 = (uint64_t)v36;
    }
    else
    {
      llvm::raw_ostream::write(a2, v5, v28);
      uint64_t v36 = (void *)*((void *)a2 + 4);
    }
    if (*((void *)a2 + 3) - (void)v36 > 0x16uLL)
    {
      qmemcpy(v36, " only in test_profile: ", 23);
      *v87 += 23;
    }
    else
    {
      llvm::raw_ostream::write(a2, " only in test_profile: ", 0x17uLL);
    }
    sub_1CD098D14(a2, *(void *)(v3 + 128), 0, 0, 0);
    uint64_t v37 = (unsigned char *)*((void *)a2 + 4);
    if (*((unsigned char **)a2 + 3) == v37)
    {
      llvm::raw_ostream::write(a2, "\n", 1uLL);
      uint64_t v31 = (_DWORD *)*((void *)a2 + 4);
    }
    else
    {
      *uint64_t v37 = 10;
      uint64_t v31 = (_DWORD *)(*v87 + 1);
      *int v87 = (uint64_t)v31;
    }
  }
  if (*((void *)a2 + 3) - (void)v31 > 0x17uLL)
  {
    qmemcpy(v31, "  Edge profile overlap: ", 24);
    *v87 += 24;
  }
  else
  {
    llvm::raw_ostream::write(a2, "  Edge profile overlap: ", 0x18uLL);
  }
  double v38 = *(double *)(v3 + 72) * 100.0;
  unint64_t v91 = &unk_1F25F6490;
  uint64_t v92 = "%.3f%%";
  double v93 = v38;
  llvm::raw_ostream::operator<<(a2, (uint64_t)&v91);
  unint64_t v39 = (unsigned char *)*((void *)a2 + 4);
  if (*((unsigned char **)a2 + 3) == v39)
  {
    llvm::raw_ostream::write(a2, "\n", 1uLL);
    unsigned int v40 = (char *)*((void *)a2 + 4);
  }
  else
  {
    *unint64_t v39 = 10;
    unsigned int v40 = (char *)(*v87 + 1);
    *int v87 = (uint64_t)v40;
  }
  if (*(void *)(v3 + 96))
  {
    if (*((void *)a2 + 3) - (void)v40 > 0x25uLL)
    {
      qmemcpy(v40, "  Mismatched count percentage (Edge): ", 38);
      *v87 += 38;
    }
    else
    {
      llvm::raw_ostream::write(a2, "  Mismatched count percentage (Edge): ", 0x26uLL);
    }
    double v41 = *(double *)(v3 + 104) * 100.0;
    unint64_t v91 = &unk_1F25F6490;
    uint64_t v92 = "%.3f%%";
    double v93 = v41;
    llvm::raw_ostream::operator<<(a2, (uint64_t)&v91);
    uint64_t v42 = (unsigned char *)*((void *)a2 + 4);
    if (*((unsigned char **)a2 + 3) == v42)
    {
      llvm::raw_ostream::write(a2, "\n", 1uLL);
      unsigned int v40 = (char *)*((void *)a2 + 4);
    }
    else
    {
      *uint64_t v42 = 10;
      unsigned int v40 = (char *)(*v87 + 1);
      *int v87 = (uint64_t)v40;
    }
  }
  if (*(void *)(v3 + 128))
  {
    if (*((void *)a2 + 3) - (void)v40 > 0x32uLL)
    {
      qmemcpy(v40, "  Percentage of Edge profile only in test_profile: ", 51);
      *v87 += 51;
    }
    else
    {
      llvm::raw_ostream::write(a2, "  Percentage of Edge profile only in test_profile: ", 0x33uLL);
    }
    double v43 = *(double *)(v3 + 136) * 100.0;
    unint64_t v91 = &unk_1F25F6490;
    uint64_t v92 = "%.3f%%";
    double v93 = v43;
    llvm::raw_ostream::operator<<(a2, (uint64_t)&v91);
    uint64_t v44 = (unsigned char *)*((void *)a2 + 4);
    if (*((unsigned char **)a2 + 3) == v44)
    {
      llvm::raw_ostream::write(a2, "\n", 1uLL);
      unsigned int v40 = (char *)*((void *)a2 + 4);
    }
    else
    {
      *uint64_t v44 = 10;
      unsigned int v40 = (char *)(*v87 + 1);
      *int v87 = (uint64_t)v40;
    }
  }
  if (*((void *)a2 + 3) - (void)v40 > 0x1EuLL)
  {
    qmemcpy(v40, "  Edge profile base count sum: ", 31);
    *v87 += 31;
  }
  else
  {
    llvm::raw_ostream::write(a2, "  Edge profile base count sum: ", 0x1FuLL);
  }
  double v45 = *(double *)(v3 + 8);
  unint64_t v91 = &unk_1F25F6490;
  uint64_t v92 = "%.0f";
  double v93 = v45;
  llvm::raw_ostream::operator<<(a2, (uint64_t)&v91);
  uint64_t v46 = (unsigned char *)*((void *)a2 + 4);
  if (*((unsigned char **)a2 + 3) == v46)
  {
    llvm::raw_ostream::write(a2, "\n", 1uLL);
    long long v47 = (void *)*((void *)a2 + 4);
  }
  else
  {
    unsigned char *v46 = 10;
    long long v47 = (void *)(*v87 + 1);
    *int v87 = (uint64_t)v47;
  }
  if (*((void *)a2 + 3) - (void)v47 > 0x1EuLL)
  {
    qmemcpy(v47, "  Edge profile test count sum: ", 31);
    *v87 += 31;
  }
  else
  {
    llvm::raw_ostream::write(a2, "  Edge profile test count sum: ", 0x1FuLL);
  }
  uint64_t v48 = *(void *)(v3 + 40);
  long long v88 = &unk_1F25F6490;
  uint64_t v89 = "%.0f";
  uint64_t v90 = v48;
  this = llvm::raw_ostream::operator<<(a2, (uint64_t)&v88);
  uint64_t v49 = (unsigned char *)*((void *)a2 + 4);
  if (*((unsigned char **)a2 + 3) == v49)
  {
    this = llvm::raw_ostream::write(a2, "\n", 1uLL);
  }
  else
  {
    *uint64_t v49 = 10;
    ++*v87;
  }
  uint64_t v50 = 0;
  char v51 = 1;
  do
  {
    char v52 = v51;
    uint64_t v53 = v3 + 8 * v50;
    double v55 = *(double *)(v53 + 16);
    uint64_t v54 = (double *)(v53 + 16);
    if (v55 >= 1.0 || *(double *)(v3 + 8 * v50 + 48) >= 1.0)
    {
      *(_DWORD *)&__s[15] = 0;
      if (v51) {
        int v56 = "IndirectCall";
      }
      else {
        int v56 = "MemOP";
      }
      *(_OWORD *)__s = *(_OWORD *)v56;
      long long v57 = (_WORD *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v57 > 1uLL)
      {
        *long long v57 = 8224;
        int v58 = (_WORD *)(*v87 + 2);
        *int v87 = (uint64_t)v58;
      }
      else
      {
        llvm::raw_ostream::write(a2, "  ", 2uLL);
        int v58 = (_WORD *)*((void *)a2 + 4);
      }
      size_t v59 = strlen(__s);
      size_t v60 = v59;
      if (v59 <= *((void *)a2 + 3) - (void)v58)
      {
        if (v59)
        {
          memcpy(v58, __s, v59);
          int v58 = (_WORD *)(*v87 + v60);
          *int v87 = (uint64_t)v58;
        }
      }
      else
      {
        llvm::raw_ostream::write(a2, __s, v59);
        int v58 = (_WORD *)*((void *)a2 + 4);
      }
      if (*((void *)a2 + 3) - (void)v58 > 0x11uLL)
      {
        v58[8] = 8250;
        *(_OWORD *)int v58 = *(_OWORD *)" profile overlap: ";
        *v87 += 18;
      }
      else
      {
        llvm::raw_ostream::write(a2, " profile overlap: ", 0x12uLL);
      }
      double v61 = *(double *)(v3 + 8 * v50 + 80) * 100.0;
      unint64_t v91 = &unk_1F25F6490;
      uint64_t v92 = "%.3f%%";
      double v93 = v61;
      llvm::raw_ostream::operator<<(a2, (uint64_t)&v91);
      std::string::size_type v62 = (unsigned char *)*((void *)a2 + 4);
      if (*((unsigned char **)a2 + 3) == v62)
      {
        llvm::raw_ostream::write(a2, "\n", 1uLL);
        uint64_t v63 = (_OWORD *)*((void *)a2 + 4);
      }
      else
      {
        unsigned char *v62 = 10;
        uint64_t v63 = (_OWORD *)(*v87 + 1);
        *int v87 = (uint64_t)v63;
      }
      if (*(void *)(v3 + 96))
      {
        if (*((void *)a2 + 3) - (void)v63 > 0x1EuLL)
        {
          qmemcpy(v63, "  Mismatched count percentage (", 31);
          size_t v64 = (unsigned char *)(*v87 + 31);
          *int v87 = (uint64_t)v64;
        }
        else
        {
          llvm::raw_ostream::write(a2, "  Mismatched count percentage (", 0x1FuLL);
          size_t v64 = (unsigned char *)*((void *)a2 + 4);
        }
        size_t v65 = strlen(__s);
        size_t v66 = v65;
        if (v65 <= *((void *)a2 + 3) - (void)v64)
        {
          if (v65)
          {
            memcpy(v64, __s, v65);
            size_t v64 = (unsigned char *)(*v87 + v66);
            *int v87 = (uint64_t)v64;
          }
        }
        else
        {
          llvm::raw_ostream::write(a2, __s, v65);
          size_t v64 = (unsigned char *)*((void *)a2 + 4);
        }
        if (*((void *)a2 + 3) - (void)v64 > 2uLL)
        {
          v64[2] = 32;
          *(_WORD *)size_t v64 = 14889;
          *v87 += 3;
        }
        else
        {
          llvm::raw_ostream::write(a2, "): ", 3uLL);
        }
        double v67 = *(double *)(v3 + 8 * v50 + 112) * 100.0;
        unint64_t v91 = &unk_1F25F6490;
        uint64_t v92 = "%.3f%%";
        double v93 = v67;
        llvm::raw_ostream::operator<<(a2, (uint64_t)&v91);
        std::string::size_type v68 = (unsigned char *)*((void *)a2 + 4);
        if (*((unsigned char **)a2 + 3) == v68)
        {
          llvm::raw_ostream::write(a2, "\n", 1uLL);
          uint64_t v63 = (_OWORD *)*((void *)a2 + 4);
        }
        else
        {
          *std::string::size_type v68 = 10;
          uint64_t v63 = (_OWORD *)(*v87 + 1);
          *int v87 = (uint64_t)v63;
        }
      }
      if (*(void *)(v3 + 128))
      {
        if (*((void *)a2 + 3) - (void)v63 > 0xFuLL)
        {
          *uint64_t v63 = *(_OWORD *)"  Percentage of ";
          uint64_t v69 = (void *)(*v87 + 16);
          *int v87 = (uint64_t)v69;
        }
        else
        {
          llvm::raw_ostream::write(a2, "  Percentage of ", 0x10uLL);
          uint64_t v69 = (void *)*((void *)a2 + 4);
        }
        size_t v70 = strlen(__s);
        size_t v71 = v70;
        if (v70 <= *((void *)a2 + 3) - (void)v69)
        {
          if (v70)
          {
            memcpy(v69, __s, v70);
            uint64_t v69 = (void *)(*v87 + v71);
            *int v87 = (uint64_t)v69;
          }
        }
        else
        {
          llvm::raw_ostream::write(a2, __s, v70);
          uint64_t v69 = (void *)*((void *)a2 + 4);
        }
        if (*((void *)a2 + 3) - (void)v69 > 0x1EuLL)
        {
          qmemcpy(v69, " profile only in test_profile: ", 31);
          *v87 += 31;
        }
        else
        {
          llvm::raw_ostream::write(a2, " profile only in test_profile: ", 0x1FuLL);
        }
        double v72 = *(double *)(v3 + 8 * v50 + 144) * 100.0;
        unint64_t v91 = &unk_1F25F6490;
        uint64_t v92 = "%.3f%%";
        double v93 = v72;
        llvm::raw_ostream::operator<<(a2, (uint64_t)&v91);
        long long v73 = (unsigned char *)*((void *)a2 + 4);
        if (*((unsigned char **)a2 + 3) == v73)
        {
          llvm::raw_ostream::write(a2, "\n", 1uLL);
          uint64_t v63 = (_OWORD *)*((void *)a2 + 4);
        }
        else
        {
          *long long v73 = 10;
          uint64_t v63 = (_OWORD *)(*v87 + 1);
          *int v87 = (uint64_t)v63;
        }
      }
      if (*((void *)a2 + 3) - (void)v63 > 1uLL)
      {
        *(_WORD *)uint64_t v63 = 8224;
        uint64_t v74 = (void *)(*v87 + 2);
        *int v87 = (uint64_t)v74;
      }
      else
      {
        llvm::raw_ostream::write(a2, "  ", 2uLL);
        uint64_t v74 = (void *)*((void *)a2 + 4);
      }
      size_t v75 = strlen(__s);
      size_t v76 = v75;
      if (v75 <= *((void *)a2 + 3) - (void)v74)
      {
        if (v75)
        {
          memcpy(v74, __s, v75);
          uint64_t v74 = (void *)(*v87 + v76);
          *int v87 = (uint64_t)v74;
        }
      }
      else
      {
        llvm::raw_ostream::write(a2, __s, v75);
        uint64_t v74 = (void *)*((void *)a2 + 4);
      }
      if (*((void *)a2 + 3) - (void)v74 > 0x18uLL)
      {
        qmemcpy(v74, " profile base count sum: ", 25);
        *v87 += 25;
      }
      else
      {
        llvm::raw_ostream::write(a2, " profile base count sum: ", 0x19uLL);
      }
      double v77 = *v54;
      unint64_t v91 = &unk_1F25F6490;
      uint64_t v92 = "%.0f";
      double v93 = v77;
      llvm::raw_ostream::operator<<(a2, (uint64_t)&v91);
      BOOL v78 = (unsigned char *)*((void *)a2 + 4);
      if (*((unsigned char **)a2 + 3) == v78)
      {
        llvm::raw_ostream::write(a2, "\n", 1uLL);
        uint64_t v79 = (_WORD *)*((void *)a2 + 4);
      }
      else
      {
        *BOOL v78 = 10;
        uint64_t v79 = (_WORD *)(*v87 + 1);
        *int v87 = (uint64_t)v79;
      }
      if (*((void *)a2 + 3) - (void)v79 > 1uLL)
      {
        *uint64_t v79 = 8224;
        uint64_t v80 = (void *)(*v87 + 2);
        *int v87 = (uint64_t)v80;
      }
      else
      {
        llvm::raw_ostream::write(a2, "  ", 2uLL);
        uint64_t v80 = (void *)*((void *)a2 + 4);
      }
      size_t v81 = strlen(__s);
      size_t v82 = v81;
      if (v81 <= *((void *)a2 + 3) - (void)v80)
      {
        if (v81)
        {
          memcpy(v80, __s, v81);
          uint64_t v80 = (void *)(*v87 + v82);
          *int v87 = (uint64_t)v80;
        }
      }
      else
      {
        llvm::raw_ostream::write(a2, __s, v81);
        uint64_t v80 = (void *)*((void *)a2 + 4);
      }
      if (*((void *)a2 + 3) - (void)v80 > 0x18uLL)
      {
        qmemcpy(v80, " profile test count sum: ", 25);
        *v87 += 25;
      }
      else
      {
        llvm::raw_ostream::write(a2, " profile test count sum: ", 0x19uLL);
      }
      uint64_t v83 = *(void *)(v3 + 8 * v50 + 48);
      long long v88 = &unk_1F25F6490;
      uint64_t v89 = "%.0f";
      uint64_t v90 = v83;
      this = llvm::raw_ostream::operator<<(a2, (uint64_t)&v88);
      unint64_t v84 = (unsigned char *)*((void *)a2 + 4);
      if (*((unsigned char **)a2 + 3) == v84)
      {
        this = llvm::raw_ostream::write(a2, "\n", 1uLL);
      }
      else
      {
        unsigned char *v84 = 10;
        ++*v87;
      }
    }
    char v51 = 0;
    uint64_t v50 = 1;
  }
  while ((v52 & 1) != 0);
  return this;
}

void sub_1CCCDE0CC()
{
}

uint64_t *sub_1CCCDE170(uint64_t *result, uint64_t *a2, unint64_t a3)
{
  if (a3 >= 2)
  {
    if (a3 == 2)
    {
      int v4 = (uint64_t *)*a2;
      if (*(void *)(*a2 + 16) < (unint64_t)result[2])
      {
        uint64_t v5 = *v4;
        *(void *)(v5 + 8) = v4[1];
        *(void *)v4[1] = v5;
        uint64_t v6 = *result;
        *(void *)(v6 + 8) = v4;
        *int v4 = v6;
        llvm::Twine *result = (uint64_t)v4;
        v4[1] = (uint64_t)result;
        return v4;
      }
    }
    else
    {
      unint64_t v8 = a3 >> 1;
      unint64_t v9 = (a3 >> 1) + 1;
      uint64_t v10 = result;
      do
      {
        uint64_t v10 = (uint64_t *)v10[1];
        --v9;
      }
      while (v9 > 1);
      unint64_t v11 = (uint64_t *)sub_1CCCDE170(result, v10, a3 >> 1);
      uint64_t result = (uint64_t *)sub_1CCCDE170(v10, a2, a3 - v8);
      unint64_t v12 = v11[2];
      if (result[2] >= v12)
      {
        uint64_t v14 = (uint64_t *)v11[1];
        uint64_t i = result;
        uint64_t result = v11;
      }
      else
      {
        for (uint64_t i = (uint64_t *)result[1]; i != a2; uint64_t i = (uint64_t *)i[1])
        {
          if (i[2] >= v12) {
            goto LABEL_14;
          }
        }
        uint64_t i = a2;
LABEL_14:
        uint64_t v15 = *i;
        uint64_t v16 = *result;
        *(void *)(v16 + 8) = *(void *)(*i + 8);
        **(void **)(v15 + 8) = v16;
        uint64_t v17 = *v11;
        uint64_t v14 = (uint64_t *)v11[1];
        *(void *)(v17 + 8) = result;
        llvm::Twine *result = v17;
        *unint64_t v11 = v15;
        *(void *)(v15 + 8) = v11;
      }
      if (v14 != i && i != a2)
      {
        char v18 = i;
        do
        {
          unint64_t v19 = v14[2];
          if (i[2] >= v19)
          {
            uint64_t v14 = (uint64_t *)v14[1];
          }
          else
          {
            for (uint64_t j = (uint64_t *)i[1]; j != a2; uint64_t j = (uint64_t *)j[1])
            {
              if (j[2] >= v19) {
                goto LABEL_25;
              }
            }
            uint64_t j = a2;
LABEL_25:
            uint64_t v21 = *j;
            uint64_t v22 = *i;
            *(void *)(v22 + 8) = *(void *)(*j + 8);
            **(void **)(v21 + 8) = v22;
            if (v18 == i) {
              char v18 = j;
            }
            uint64_t v24 = *v14;
            BOOL v23 = (uint64_t *)v14[1];
            *(void *)(v24 + 8) = i;
            uint64_t *i = v24;
            *uint64_t v14 = v21;
            *(void *)(v21 + 8) = v14;
            uint64_t v14 = v23;
            uint64_t i = j;
          }
        }
        while (v14 != v18 && i != a2);
      }
    }
  }
  return result;
}

void *sub_1CCCDE33C(void *result, void *a2)
{
  uint64_t v2 = (void *)result[2];
  if (v2 != a2)
  {
    int v4 = result;
    do
    {
      uint64_t v5 = v2 - 3;
      void v4[2] = v2 - 3;
      if (*(v2 - 1))
      {
        uint64_t v6 = *(v2 - 3);
        uint64_t result = (void *)*(v2 - 2);
        uint64_t v7 = *result;
        *(void *)(v7 + 8) = *(void *)(v6 + 8);
        **(void **)(v6 + 8) = v7;
        *(v2 - sub_1CD7485C0(this + 1) = 0;
        if (result != v5)
        {
          do
          {
            unint64_t v8 = (void *)result[1];
            operator delete(result);
            uint64_t result = v8;
          }
          while (v8 != v5);
          uint64_t v5 = (void *)v4[2];
        }
      }
      uint64_t v2 = v5;
    }
    while (v5 != a2);
  }
  return result;
}

void sub_1CCCDE3CC()
{
}

uint64_t sub_1CCCDE414(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1CCCDE444(std::error_category *a1)
{
  std::error_category::~error_category(a1);

  JUMPOUT(0x1D25D9CE0);
}

const char *sub_1CCCDE47C()
{
  return "llvm.instrprof";
}

void sub_1CCCDE488(int a1@<W1>, uint64_t a2@<X8>)
{
  char v3 = 0;
  LOBYTE(__p) = 0;
  sub_1CCCDA318(a2, a1, (uint64_t)&__p);
  if (v3 < 0) {
    operator delete(__p);
  }
}

uint64_t *sub_1CCCDE4C8(uint64_t **a1)
{
  uint64_t v2 = *a1;
  uint64_t v1 = a1[1];
  unint64_t v3 = 0xAAAAAAAAAAAAAAABLL * (v1 - *a1);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * (a1[2] - v2) > v4) {
    unint64_t v4 = 0x5555555555555556 * (a1[2] - v2);
  }
  if (0xAAAAAAAAAAAAAAABLL * (a1[2] - v2) >= 0x555555555555555) {
    unint64_t v6 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v6 = v4;
  }
  if (v6)
  {
    if (v6 > 0xAAAAAAAAAAAAAAALL) {
      sub_1CB833614();
    }
    uint64_t v7 = (char *)operator new(24 * v6);
  }
  else
  {
    uint64_t v7 = 0;
  }
  unint64_t v8 = (uint64_t *)&v7[24 * v3];
  unint64_t v9 = (uint64_t *)&v7[24 * v6];
  uint64_t *v8 = (uint64_t)v8;
  v8[1] = (uint64_t)v8;
  void v8[2] = 0;
  uint64_t v10 = v8 + 3;
  if (v1 == v2)
  {
    *a1 = v8;
    a1[1] = v10;
    a1[2] = v9;
    if (!v1) {
      return v10;
    }
    goto LABEL_19;
  }
  do
  {
    v1 -= 3;
    unint64_t v8 = sub_1CD46E850(v8 - 3, v1);
  }
  while (v1 != v2);
  uint64_t v1 = *a1;
  unint64_t v11 = a1[1];
  *a1 = v8;
  a1[1] = v10;
  a1[2] = v9;
  if (v11 != v1)
  {
    do
    {
      unint64_t v12 = v11 - 3;
      if (*(v11 - 1))
      {
        uint64_t v14 = *(v11 - 3);
        char v13 = (uint64_t *)*(v11 - 2);
        uint64_t v15 = *v13;
        *(void *)(v15 + 8) = *(void *)(v14 + 8);
        **(void **)(v14 + 8) = v15;
        *(v11 - sub_1CD7485C0(this + 1) = 0;
        if (v13 != v12)
        {
          do
          {
            uint64_t v16 = (uint64_t *)v13[1];
            operator delete(v13);
            char v13 = v16;
          }
          while (v16 != v12);
        }
      }
      unint64_t v11 = v12;
    }
    while (v12 != v1);
  }
  if (v1) {
LABEL_19:
  }
    operator delete(v1);
  return v10;
}

uint64_t *sub_1CCCDE638(uint64_t **a1, long long **a2, long long **a3)
{
  unint64_t v3 = 0xAAAAAAAAAAAAAAABLL * (a1[1] - *a1);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  uint64_t v8 = (uint64_t)(a1 + 2);
  if (0x5555555555555556 * (a1[2] - *a1) > v4) {
    unint64_t v4 = 0x5555555555555556 * (a1[2] - *a1);
  }
  if (0xAAAAAAAAAAAAAAABLL * (a1[2] - *a1) >= 0x555555555555555) {
    unint64_t v9 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v9 = v4;
  }
  if (v9)
  {
    if (v9 > 0xAAAAAAAAAAAAAAALL) {
      sub_1CB833614();
    }
    uint64_t v10 = (char *)operator new(24 * v9);
  }
  else
  {
    uint64_t v10 = 0;
  }
  unint64_t v11 = (uint64_t *)&v10[24 * v3];
  unint64_t v12 = &v10[24 * v9];
  sub_1CCCDE7C4(v8, v11, a2, a3);
  char v13 = v11 + 3;
  uint64_t v15 = *a1;
  uint64_t v14 = a1[1];
  if (v14 == *a1)
  {
    *a1 = v11;
    a1[1] = v13;
    a1[2] = (uint64_t *)v12;
    if (!v14) {
      return v13;
    }
    goto LABEL_19;
  }
  do
  {
    v11 -= 3;
    v14 -= 3;
    sub_1CD46E850(v11, v14);
  }
  while (v14 != v15);
  uint64_t v14 = *a1;
  uint64_t v16 = a1[1];
  *a1 = v11;
  a1[1] = v13;
  a1[2] = (uint64_t *)v12;
  if (v16 != v14)
  {
    do
    {
      uint64_t v17 = v16 - 3;
      if (*(v16 - 1))
      {
        uint64_t v19 = *(v16 - 3);
        char v18 = (uint64_t *)*(v16 - 2);
        uint64_t v20 = *v18;
        *(void *)(v20 + 8) = *(void *)(v19 + 8);
        **(void **)(v19 + 8) = v20;
        *(v16 - sub_1CD7485C0(this + 1) = 0;
        if (v18 != v17)
        {
          do
          {
            uint64_t v21 = (uint64_t *)v18[1];
            operator delete(v18);
            char v18 = v21;
          }
          while (v21 != v17);
        }
      }
      uint64_t v16 = v17;
    }
    while (v17 != v14);
  }
  if (v14) {
LABEL_19:
  }
    operator delete(v14);
  return v13;
}

double sub_1CCCDE7C4(uint64_t a1, void *a2, long long **a3, long long **a4)
{
  unint64_t v4 = *a3;
  uint64_t v5 = *a4;
  *a2 = a2;
  a2[1] = a2;
  a2[2] = 0;
  if (v4 != v5)
  {
    uint64_t v7 = 1;
    uint64_t v8 = a2;
    do
    {
      unint64_t v9 = operator new(0x20uLL);
      long long v10 = *v4++;
      double result = *(double *)&v10;
      v9[1] = v10;
      *(void *)unint64_t v9 = v8;
      *((void *)v9 + sub_1CD7485C0(this + 1) = a2;
      *((void *)v8 + sub_1CD7485C0(this + 1) = v9;
      *a2 = v9;
      a2[2] = v7++;
      uint64_t v8 = v9;
    }
    while (v4 != v5);
  }
  return result;
}

void sub_1CCCDE844()
{
}

void sub_1CCCDE8E8()
{
}

uint64_t sub_1CCCDE980()
{
  LOBYTE(vsub_1CD7485C0(this + 1) = 1;
  unint64_t v3 = &v1;
  int v2 = 1;
  v4.n128_u64[0] = (unint64_t)"Use full module build paths in the profile counter names for static functions.";
  v4.n128_u64[1] = 78;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBCF00D8, "static-func-full-module-prefix", (unsigned char **)&v3, &v2, &v4);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF00D8, &dword_1CB82C000);
  int v1 = 1;
  int v2 = 0;
  unint64_t v3 = &v2;
  v4.n128_u64[0] = (unint64_t)"Strip specified level of directory name from source path in the profile counter nam"
                                     "e for static functions.";
  v4.n128_u64[1] = 106;
  sub_1CD74D720(&v3, &v1, (long long *)&v4);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &qword_1EBCF0198, &dword_1CB82C000);
  v4.n128_u64[0] = (unint64_t)"Enable name/filename string compression";
  v4.n128_u64[1] = 39;
  LOBYTE(v2) = 1;
  unint64_t v3 = &v2;
  sub_1CD41D15C((uint64_t)&llvm::DoInstrProfNameCompression, "enable-name-compression", &v4, (unsigned char **)&v3);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &llvm::DoInstrProfNameCompression, &dword_1CB82C000);
}

double getCountersSection@<D0>(const llvm::object::ObjectFile *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (*(uint64_t (**)(const llvm::object::ObjectFile *))(*(void *)a1 + 344))(a1);
  uint64_t v6 = v5;
  uint64_t v7 = (*(uint64_t (**)(const llvm::object::ObjectFile *))(*(void *)a1 + 352))(a1);
  *(void *)&long long v16 = v4;
  *((void *)&v16 + sub_1CD7485C0(this + 1) = v6;
  if (v6 == v8 && v4 == v7) {
LABEL_21:
  }
    operator new();
  uint64_t v10 = v7;
  uint64_t v11 = v8;
  while (1)
  {
    (*(void (**)(void *__return_ptr, uint64_t, uint64_t))(*(void *)v6 + 136))(v17, v6, v4);
    if (v18)
    {
      uint64_t v13 = v17[0];
      v17[0] = 0;
      if (v13) {
        (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
      }
      goto LABEL_16;
    }
    if (v17[1] == 15
      && *(void *)v17[0] == 0x705F6D766C6C5F5FLL
      && *(void *)(v17[0] + 7) == 0x73746E635F667270)
    {
      break;
    }
LABEL_16:
    (*(void (**)(void, long long *))(**((void **)&v16 + 1) + 128))(*((void *)&v16 + 1), &v16);
    uint64_t v6 = *((void *)&v16 + 1);
    uint64_t v4 = v16;
    if (*((void *)&v16 + 1) == v11 && (void)v16 == v10) {
      goto LABEL_21;
    }
  }
  *(unsigned char *)(a2 + 16) &= ~1u;
  double result = *(double *)&v16;
  *(_OWORD *)a2 = v16;
  return result;
}

void llvm::InstrProfCorrelator::Context::get(llvm::object::ObjectFile *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  getCountersSection(a1, (uint64_t)&v4);
  if ((v5 & 1) == 0 || (uint64_t v3 = v4) == 0) {
    operator new();
  }
  *(unsigned char *)(a2 + 8) |= 1u;
  *(void *)a2 = v3;
}

void llvm::InstrProfCorrelator::get(void **a1@<X0>, size_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3 = (void **)a2;
  uint64_t v4 = a1;
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  llvm::object::MachOObjectFile::findDsymObjectMembers(a1, a2, (uint64_t)&v20);
  uint64_t v6 = v20;
  if (v22)
  {
    uint64_t v20 = 0;
    if (v6)
    {
      *(unsigned char *)(a3 + 8) |= 1u;
      *(void *)a3 = v6;
      goto LABEL_7;
    }
  }
  if (v6 != v21)
  {
    if (0xAAAAAAAAAAAAAAABLL * ((v21 - v6) >> 3) >= 2) {
      operator new();
    }
    char v8 = *(unsigned char *)(v6 + 23);
    if (v8 >= 0) {
      uint64_t v4 = (void **)v6;
    }
    else {
      uint64_t v4 = *(void ***)v6;
    }
    if (v8 >= 0) {
      uint64_t v3 = (void **)(v8 & 0x7F);
    }
    else {
      uint64_t v3 = *(void ***)(v6 + 8);
    }
  }
  __int16 v15 = 261;
  v14[0] = v4;
  v14[1] = v3;
  sub_1CD096690((unsigned __int8 *)v14, (llvm::WritableMemoryBuffer *)0xFFFFFFFFFFFFFFFFLL, 0, 0, 1, 0, (uint64_t)v16);
  sub_1CD66FAB4((uint64_t)v16, v9, (uint64_t)&v18);
  if ((v17 & 1) == 0)
  {
    uint64_t v10 = v16[0];
    v16[0] = 0;
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
    }
  }
  uint64_t v11 = v18;
  if ((v19 & 1) != 0 && (char v18 = 0, v11))
  {
    *(unsigned char *)(a3 + 8) |= 1u;
    *(void *)a3 = v11;
  }
  else
  {
    char v18 = 0;
    uint64_t v13 = v11;
    llvm::InstrProfCorrelator::get(&v13, a3);
    if (v13) {
      (*(void (**)(void *))(*v13 + 8))(v13);
    }
  }
  unint64_t v12 = v18;
  char v18 = 0;
  if ((v19 & 1) == 0)
  {
    if (!v12) {
      goto LABEL_7;
    }
    goto LABEL_28;
  }
  if (v12) {
LABEL_28:
  }
    (*(void (**)(void *))(*v12 + 8))(v12);
LABEL_7:
  if (v22)
  {
    uint64_t v7 = v20;
    uint64_t v20 = 0;
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
    }
  }
  else
  {
    v14[0] = (void **)&v20;
    sub_1CB8338B8(v14);
  }
}

uint64_t llvm::InstrProfCorrelator::get@<X0>(void **a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *a1;
  uint64_t v5 = v4[2] - v4[1];
  v18[0] = v4[1];
  v18[1] = v5;
  _DWORD v18[2] = (*(uint64_t (**)(void *))(*v4 + 16))(v4);
  void v18[3] = v6;
  llvm::object::createBinary((uint64_t)v18, 0, 1, (uint64_t)&v23);
  uint64_t v7 = v23;
  if ((v24 & 1) == 0)
  {
    if (v23 && (*((_DWORD *)v23 + 2) - 24) >= 0xFFFFFFF1)
    {
      char v8 = *a1;
      *a1 = 0;
      char v17 = v8;
      llvm::InstrProfCorrelator::Context::get(v7, (uint64_t)&v21);
      if (v17) {
        (*(void (**)(void *))(*v17 + 8))(v17);
      }
      if (v22)
      {
        uint64_t v9 = v21;
        uint64_t v21 = 0;
        if (v9)
        {
          *(unsigned char *)(a2 + 8) |= 1u;
          *(void *)a2 = v9;
          sub_1CCCDFA5C((uint64_t)&v21);
          goto LABEL_25;
        }
      }
      llvm::object::ObjectFile::makeTriple(v7, (llvm::Triple *)&v14);
      int v10 = sub_1CD0BDF24(v16);
      if (v10 == 32)
      {
        uint64_t v21 = 0;
        unsigned int v12 = *((_DWORD *)v7 + 2) & 0xFFFFFFFC;
        if (v12 == 16 || v12 == 12)
        {
          char v20 = 0;
          LOBYTE(__p) = 0;
          size_t v28 = &unk_1F26187D0;
          size_t v29 = llvm::WithColor::defaultErrorHandler;
          uint64_t v30 = &v28;
          uint64_t v25 = &unk_1F26187D0;
          BOOL v26 = llvm::WithColor::defaultWarningHandler;
          uint64_t v27 = &v25;
          llvm::DWARFContext::create();
        }
LABEL_20:
        operator new();
      }
      if (v10 == 64)
      {
        uint64_t v21 = 0;
        unsigned int v11 = *((_DWORD *)v7 + 2) & 0xFFFFFFFC;
        if (v11 == 16 || v11 == 12)
        {
          char v20 = 0;
          LOBYTE(__p) = 0;
          size_t v28 = &unk_1F26187D0;
          size_t v29 = llvm::WithColor::defaultErrorHandler;
          uint64_t v30 = &v28;
          uint64_t v25 = &unk_1F26187D0;
          BOOL v26 = llvm::WithColor::defaultWarningHandler;
          uint64_t v27 = &v25;
          llvm::DWARFContext::create();
        }
        goto LABEL_20;
      }
      if (v15 < 0) {
        operator delete(v14);
      }
      sub_1CCCDFA5C((uint64_t)&v21);
    }
LABEL_24:
    operator new();
  }
  uint64_t v23 = 0;
  if (!v7) {
    goto LABEL_24;
  }
  *(unsigned char *)(a2 + 8) |= 1u;
  *(void *)a2 = v7;
LABEL_25:
  uint64_t result = (uint64_t)v23;
  uint64_t v23 = 0;
  if (v24)
  {
    if (!result) {
      return result;
    }
  }
  else if (!result)
  {
    return result;
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
}

uint64_t llvm::InstrProfCorrelator::getDataSize(llvm::InstrProfCorrelator *this)
{
  int v1 = *((_DWORD *)this + 16);
  if (this && !v1)
  {
    uint64_t v2 = 40;
    return (*((void *)this + 10) - *((void *)this + 9)) / v2;
  }
  uint64_t v3 = 0;
  if (this && v1 == 1)
  {
    uint64_t v2 = 48;
    return (*((void *)this + 10) - *((void *)this + 9)) / v2;
  }
  return v3;
}

double llvm::InstrProfCorrelatorImpl<unsigned int>::InstrProfCorrelatorImpl(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a2 = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)(a1 + 64) = 0;
  *(void *)a1 = &unk_1F263C478;
  *(void *)(a1 + 8) = v2;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 100) = 0u;
  return result;
}

double llvm::InstrProfCorrelatorImpl<unsigned long long>::InstrProfCorrelatorImpl(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a2 = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)(a1 + 64) = 1;
  *(void *)a1 = &unk_1F263C3F0;
  *(void *)(a1 + 8) = v2;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 100) = 0u;
  return result;
}

BOOL llvm::InstrProfCorrelatorImpl<unsigned int>::classof(uint64_t a1)
{
  return *(_DWORD *)(a1 + 64) == 0;
}

BOOL llvm::InstrProfCorrelatorImpl<unsigned long long>::classof(uint64_t a1)
{
  return *(_DWORD *)(a1 + 64) == 1;
}

uint64_t **sub_1CCCDF9D4(uint64_t **result)
{
  int v1 = *result;
  llvm::Twine *result = 0;
  if (v1)
  {
    uint64_t v2 = *v1;
    *int v1 = 0;
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    JUMPOUT(0x1D25D9CE0);
  }
  return result;
}

uint64_t sub_1CCCDFA5C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8))
  {
    uint64_t v2 = *(uint64_t **)a1;
    *(void *)a1 = 0;
    if (v2) {
      (*(void (**)(uint64_t *))(*v2 + 8))(v2);
    }
  }
  else
  {
    sub_1CCCDF9D4((uint64_t **)a1);
  }
  return a1;
}

void sub_1CCCDFAC4(uint64_t a1@<X0>, void *a2@<X8>)
{
  (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
  if (*(void *)(a1 + 72) == *(void *)(a1 + 80)
    || (v4 = *(std::string **)(a1 + 40), uint64_t v5 = *(std::string **)(a1 + 48), v4 == v5))
  {
    operator new();
  }
  llvm::collectPGOFuncNameStrings(v4, 0xAAAAAAAAAAAAAAABLL * (((char *)v5 - (char *)v4) >> 3), (std::string *)(a1 + 16), a2);
  sub_1CD4AF204((void *)(a1 + 96));
  uint64_t v6 = *(void *)(a1 + 40);
  for (uint64_t i = *(void *)(a1 + 48); i != v6; i -= 24)
  {
    if (*(char *)(i - 1) < 0) {
      operator delete(*(void **)(i - 24));
    }
  }
  *(void *)(a1 + 48) = v6;
}

uint64_t sub_1CCCDFBF0(void *a1)
{
  *a1 = &unk_1F263C3C0;
  uint64_t v2 = a1[15];
  a1[15] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *a1 = &unk_1F263C3F0;
  MEMORY[0x1D25D9CD0](a1[12], 8);
  uint64_t v3 = (void *)a1[9];
  if (v3)
  {
    a1[10] = v3;
    operator delete(v3);
  }

  return sub_1CCCDFE78((uint64_t)a1);
}

void sub_1CCCDFCA8(void *a1)
{
  *a1 = &unk_1F263C3C0;
  uint64_t v2 = a1[15];
  a1[15] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *a1 = &unk_1F263C3F0;
  MEMORY[0x1D25D9CD0](a1[12], 8);
  uint64_t v3 = (void *)a1[9];
  if (v3)
  {
    a1[10] = v3;
    operator delete(v3);
  }
  sub_1CCCDFE78((uint64_t)a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCCDFD74(void *a1)
{
  uint64_t v2 = a1[15];
  llvm::DWARFContext::parseNormalUnits(v2);
  uint64_t v3 = *(unsigned int *)(v2 + 24);
  if (v3)
  {
    uint64_t v4 = *(llvm::DWARFUnit ***)(v2 + 16);
    uint64_t v5 = &v4[v3];
    do
    {
      uint64_t v6 = *v4;
      llvm::DWARFUnit::extractDIEsIfNeeded(*v4, 0);
      uint64_t v7 = *((void *)v6 + 36);
      uint64_t v8 = *((void *)v6 + 37);
      if (v7 != v8)
      {
        uint64_t v9 = v7;
        do
        {
          sub_1CCCDFEF8(a1, *v4, v7);
          v9 += 24;
          v7 += 24;
        }
        while (v9 != v8);
      }
      ++v4;
    }
    while (v4 != v5);
  }
  uint64_t v10 = a1[15];
  llvm::DWARFContext::parseDWOUnits(v10, 0);
  uint64_t v11 = *(unsigned int *)(v10 + 248);
  if (v11)
  {
    unsigned int v12 = *(llvm::DWARFUnit ***)(v10 + 240);
    uint64_t v13 = &v12[v11];
    do
    {
      uint64_t v14 = *v12;
      llvm::DWARFUnit::extractDIEsIfNeeded(*v12, 0);
      uint64_t v15 = *((void *)v14 + 36);
      uint64_t v16 = *((void *)v14 + 37);
      if (v15 != v16)
      {
        uint64_t v17 = v15;
        do
        {
          sub_1CCCDFEF8(a1, *v12, v15);
          v17 += 24;
          v15 += 24;
        }
        while (v17 != v16);
      }
      ++v12;
    }
    while (v12 != v13);
  }
}

uint64_t sub_1CCCDFE78(uint64_t a1)
{
  *(void *)a1 = &unk_1F263C420;
  uint64_t v3 = (void **)(a1 + 40);
  sub_1CB8338B8(&v3);
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  sub_1CCCDF9D4((uint64_t **)(a1 + 8));
  return a1;
}

void sub_1CCCDFEF8(void *a1, llvm::DWARFUnit *a2, uint64_t a3)
{
  uint64_t v132 = *MEMORY[0x1E4F143B8];
  BOOL v112 = a2;
  uint64_t v113 = a3;
  if (!a2) {
    return;
  }
  if (!a3) {
    return;
  }
  unsigned int v3 = *(_DWORD *)(a3 + 8);
  if (v3 == -1) {
    return;
  }
  uint64_t v4 = *((void *)a2 + 36);
  if (!v4) {
    return;
  }
  uint64_t v5 = *(void *)(a3 + 16);
  if (!v5) {
    return;
  }
  if (*(_WORD *)(v5 + 4) != 52) {
    return;
  }
  uint64_t v6 = *(void *)(v4 + 24 * v3 + 16);
  if (!v6) {
    return;
  }
  if (*(_WORD *)(v6 + 4) != 46) {
    return;
  }
  if (!*(unsigned char *)(v5 + 7)) {
    return;
  }
  ShortName = (const char *)llvm::DWARFDie::getShortName((llvm::DWARFDie *)&v112);
  if (!ShortName) {
    return;
  }
  uint64_t v9 = ShortName;
  if (strlen(ShortName) < 8 || *(void *)v9 != 0x5F63666F72705F5FLL) {
    return;
  }
  llvm::DWARFDie::getLocations(&v112, (llvm::dwarf *)2, (uint64_t)&v125);
  if (v127)
  {
    uint64_t v53 = v125;
    uint64_t v125 = 0;
    *(void *)&long long __dst = v53;
    sub_1CD4515D0((void **)&__dst);
    if ((void)__dst) {
      (*(void (**)(void))(*(void *)__dst + 8))(__dst);
    }
    goto LABEL_127;
  }
  uint64_t v10 = v125;
  uint64_t v11 = v126;
  if (v125 == v126)
  {
LABEL_127:
    int v105 = 0;
    unint64_t v103 = 0;
    unsigned __int8 v108 = 0;
    goto LABEL_32;
  }
  unsigned int v12 = v112;
  char v13 = *((unsigned char *)v112 + 34);
  while (1)
  {
    uint64_t v14 = *((void *)v10 + 4);
    uint64_t v15 = *((void *)v10 + 5);
    char v16 = (*(uint64_t (**)(void))(**(void **)(a1[15] + 520) + 40))(*(void *)(a1[15] + 520));
    *(void *)&long long __s = v14;
    *((void *)&__s + sub_1CD7485C0(this + 1) = v15;
    char v121 = v16;
    char v122 = v13;
    char v123 = v13;
    __int16 v124 = 0;
    sub_1CC6A2264((uint64_t)v128, &__s, 0);
    sub_1CC6A2264((uint64_t)&__dst, &__s, *((unint64_t *)&__s + 1));
    if (*(_OWORD *)v128 != __dst) {
      break;
    }
LABEL_28:
    uint64_t v10 = (llvm::DWARFUnit *)((char *)v10 + 64);
    if (v10 == v11) {
      goto LABEL_127;
    }
  }
  while (v128[16] == 161)
  {
    llvm::DWARFUnit::getAddrOffsetSectionItem((uint64_t)v12, (int)v130, (uint64_t)&v114);
    if (v116)
    {
      double v55 = v114;
      goto LABEL_31;
    }
LABEL_23:
    sub_1CC6A144C((unint64_t *)v128);
    if (*(void *)v128 == (void)__dst && *(void *)&v128[8] == *((void *)&__dst + 1)) {
      goto LABEL_28;
    }
  }
  if (v128[16] != 3) {
    goto LABEL_23;
  }
  double v55 = v130;
LABEL_31:
  unsigned __int8 v108 = v55;
  unint64_t v103 = (unint64_t)v55 & 0xFFFFFFFFFFFFFF00;
  int v105 = 1;
LABEL_32:
  if (v127)
  {
    char v18 = v125;
    uint64_t v125 = 0;
    if (v18) {
      (*(void (**)(llvm::DWARFUnit *))(*(void *)v18 + 8))(v18);
    }
  }
  else
  {
    *(void *)uint64_t v128 = &v125;
    sub_1CC683E70((void ***)v128);
  }
  char v19 = v112;
  if (v112)
  {
    uint64_t v20 = v113;
    if (v113)
    {
      unsigned int v21 = *(_DWORD *)(v113 + 8);
      if (v21 == -1)
      {
        char v19 = 0;
        goto LABEL_37;
      }
      uint64_t v20 = *((void *)v112 + 36) + 24 * v21;
    }
    else
    {
      char v19 = 0;
    }
  }
  else
  {
LABEL_37:
    uint64_t v20 = 0;
  }
  uint64_t v125 = v19;
  uint64_t v126 = (llvm::DWARFUnit *)v20;
  llvm::DWARFDie::find(&v125, 17, v128);
  if (v131)
  {
    llvm::DWARFFormValue::getAsSectionedAddress(v128, (uint64_t)&__dst);
    unint64_t v54 = __dst;
    if (!(_BYTE)v118) {
      unint64_t v54 = 0;
    }
    unint64_t v96 = v54;
    uint64_t v97 = v118;
  }
  else
  {
    unint64_t v96 = 0;
    uint64_t v97 = 0;
  }
  LastChild = v112;
  if (v112)
  {
    uint64_t v23 = v113;
    if (!v113)
    {
      uint64_t v24 = 0;
      FirstChild = 0;
      LastChild = 0;
      goto LABEL_49;
    }
    FirstChild = (llvm::DWARFUnit *)llvm::DWARFUnit::getFirstChild((uint64_t)v112, v113);
    uint64_t v24 = v56;
    LastChild = (llvm::DWARFUnit *)llvm::DWARFUnit::getLastChild((uint64_t)LastChild, v23);
    uint64_t v26 = v57;
  }
  else
  {
    uint64_t v24 = 0;
    FirstChild = 0;
LABEL_49:
    uint64_t v26 = 0;
  }
  uint64_t v125 = FirstChild;
  uint64_t v126 = (llvm::DWARFUnit *)v24;
  if (v24 != v26 || FirstChild != LastChild)
  {
    int v27 = 0;
    unint64_t AsUnsignedConstant = 0;
    uint64_t v100 = 0;
    char v106 = 0;
    char v104 = 0;
    unsigned int v98 = 0;
    uint64_t v37 = LastChild;
    uint64_t v38 = v26;
    while (1)
    {
      uint64_t v39 = *(void *)(v24 + 16);
      if (!v39 || *(_WORD *)(v39 + 4) != 24576)
      {
        if (!FirstChild) {
          goto LABEL_73;
        }
        goto LABEL_70;
      }
      uint64_t v101 = FirstChild;
      uint64_t v102 = v24;
      llvm::DWARFDie::find(&v125, 3, v128);
      llvm::DWARFDie::find(&v125, 28, &__dst);
      if (v131)
      {
        if (v119) {
          break;
        }
      }
LABEL_120:
      FirstChild = v101;
      uint64_t v24 = v102;
      uint64_t v37 = LastChild;
      uint64_t v38 = v26;
      if (!v101) {
        goto LABEL_73;
      }
LABEL_70:
      unsigned int v40 = *(_DWORD *)(v24 + 12);
      if (v40)
      {
        uint64_t v24 = *((void *)FirstChild + 36) + 24 * v40;
        goto LABEL_74;
      }
      FirstChild = 0;
LABEL_73:
      uint64_t v24 = 0;
LABEL_74:
      uint64_t v125 = FirstChild;
      uint64_t v126 = (llvm::DWARFUnit *)v24;
      if (v24 == v38 && FirstChild == v37) {
        goto LABEL_53;
      }
    }
    llvm::DWARFFormValue::getAsCString((llvm *)v128, (uint64_t)&__s);
    double v41 = (char *)__s;
    if (BYTE8(__s))
    {
      *(void *)&long long __s = 0;
      if (v41)
      {
        unsigned int v111 = v41;
        sub_1CD4515D0((void **)&v111);
        uint64_t v46 = v111;
        if (!v111) {
          goto LABEL_117;
        }
        goto LABEL_123;
      }
    }
    else if ((void)__s)
    {
      size_t v42 = strlen((const char *)__s);
LABEL_84:
      if (llvm::InstrProfCorrelator::FunctionNameAttributeName[0]) {
        size_t v43 = strlen(llvm::InstrProfCorrelator::FunctionNameAttributeName[0]);
      }
      else {
        size_t v43 = 0;
      }
      if (v43 >= v42) {
        size_t v44 = v42;
      }
      else {
        size_t v44 = v43;
      }
      if (v44 && memcmp(v41, llvm::InstrProfCorrelator::FunctionNameAttributeName[0], v44) || v42 != v43)
      {
        if (llvm::InstrProfCorrelator::CFGHashAttributeName[0]) {
          size_t v45 = strlen(llvm::InstrProfCorrelator::CFGHashAttributeName[0]);
        }
        else {
          size_t v45 = 0;
        }
        if (v45 >= v42) {
          size_t v47 = v42;
        }
        else {
          size_t v47 = v45;
        }
        if ((!v47 || !memcmp(v41, llvm::InstrProfCorrelator::CFGHashAttributeName[0], v47)) && v42 == v45)
        {
          unint64_t AsUnsignedConstant = llvm::DWARFFormValue::getAsUnsignedConstant((llvm::DWARFFormValue *)&__dst);
          char v106 = v51;
        }
        else
        {
          if (llvm::InstrProfCorrelator::NumCountersAttributeName) {
            size_t v48 = strlen(llvm::InstrProfCorrelator::NumCountersAttributeName);
          }
          else {
            size_t v48 = 0;
          }
          if (v48 >= v42) {
            size_t v49 = v42;
          }
          else {
            size_t v49 = v48;
          }
          if ((!v49 || !memcmp(v41, llvm::InstrProfCorrelator::NumCountersAttributeName, v49)) && v42 == v48)
          {
            unsigned int v98 = llvm::DWARFFormValue::getAsUnsignedConstant((llvm::DWARFFormValue *)&__dst);
            char v104 = v52;
          }
        }
        goto LABEL_117;
      }
      llvm::DWARFFormValue::getAsCString((llvm *)&__dst, (uint64_t)&v114);
      if ((v115 & 1) == 0)
      {
        int v27 = 1;
        uint64_t v100 = v114;
        goto LABEL_117;
      }
      if (!v114 || (unsigned int v110 = v114, sub_1CD4515D0((void **)&v110), (v46 = v110) == 0))
      {
LABEL_117:
        if (BYTE8(__s))
        {
          uint64_t v50 = __s;
          *(void *)&long long __s = 0;
          if (v50) {
            (*(void (**)(uint64_t))(*(void *)v50 + 8))(v50);
          }
        }
        goto LABEL_120;
      }
LABEL_123:
      (*(void (**)(char *))(*(void *)v46 + 8))(v46);
      goto LABEL_117;
    }
    size_t v42 = 0;
    goto LABEL_84;
  }
  unsigned int v98 = 0;
  unint64_t AsUnsignedConstant = 0;
  char v104 = 0;
  char v106 = 0;
  uint64_t v100 = 0;
  int v27 = 0;
LABEL_53:
  if (v106) {
    BOOL v28 = v27 == 0;
  }
  else {
    BOOL v28 = 1;
  }
  int v29 = v105;
  if (v28) {
    int v29 = 0;
  }
  if (v29 != 1 || !v104) {
    return;
  }
  unint64_t v30 = v108 | v103;
  uint64_t v31 = a1[1];
  unint64_t v33 = *(void *)(v31 + 8);
  unint64_t v32 = *(void *)(v31 + 16);
  uint64_t v34 = (llvm::DWARFUnit *)(v30 - v33);
  if (v30 < v33 || v30 >= v32) {
    return;
  }
  size_t v36 = v100 ? strlen(v100) : 0;
  uint64_t v125 = v34;
  sub_1CD4ADCD0((uint64_t)(a1 + 12), (uint64_t *)&v125, (uint64_t)v128);
  if (!v128[16]) {
    return;
  }
  if (v97) {
    unint64_t v58 = v96;
  }
  else {
    unint64_t v58 = 0;
  }
  *(_OWORD *)uint64_t v128 = xmmword_1CFAC4320;
  *(void *)&v128[16] = 0;
  llvm::MD5::update((int *)v128, (int *)v100, v36);
  llvm::MD5::final((int *)v128, (int *)&__dst);
  unint64_t v59 = __dst;
  unint64_t v60 = bswap64(__dst);
  if (*(unsigned char *)(a1[1] + 24)) {
    unint64_t v59 = v60;
  }
  unint64_t v107 = v59;
  unint64_t v61 = bswap64(AsUnsignedConstant);
  if (*(unsigned char *)(a1[1] + 24)) {
    unint64_t v62 = v61;
  }
  else {
    unint64_t v62 = AsUnsignedConstant;
  }
  unint64_t v63 = bswap64((unint64_t)v125);
  if (*(unsigned char *)(a1[1] + 24)) {
    size_t v64 = (llvm::DWARFUnit *)v63;
  }
  else {
    size_t v64 = v125;
  }
  unint64_t v65 = bswap64(v58);
  if (*(unsigned char *)(a1[1] + 24)) {
    unint64_t v66 = v65;
  }
  else {
    unint64_t v66 = v58;
  }
  unsigned int v67 = bswap32(v98);
  if (!*(unsigned char *)(a1[1] + 24)) {
    unsigned int v67 = v98;
  }
  unsigned int v109 = v67;
  uint64_t v69 = (char *)a1[10];
  unint64_t v68 = a1[11];
  if ((unint64_t)v69 < v68)
  {
    *(void *)uint64_t v69 = v107;
    *((void *)v69 + sub_1CD7485C0(this + 1) = v62;
    *((void *)v69 + 2) = v64;
    *((void *)v69 + 3) = v66;
    *((void *)v69 + 4) = 0;
    size_t v70 = v69 + 48;
    *((void *)v69 + 5) = v67;
    goto LABEL_167;
  }
  size_t v71 = (char *)a1[9];
  unint64_t v72 = 0xAAAAAAAAAAAAAAABLL * ((v69 - v71) >> 4) + 1;
  if (v72 > 0x555555555555555) {
    goto LABEL_197;
  }
  unint64_t v73 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v68 - (void)v71) >> 4);
  if (2 * v73 > v72) {
    unint64_t v72 = 2 * v73;
  }
  if (v73 >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v74 = 0x555555555555555;
  }
  else {
    unint64_t v74 = v72;
  }
  if (!v74)
  {
    size_t v75 = 0;
    goto LABEL_162;
  }
  if (v74 > 0x555555555555555) {
    goto LABEL_198;
  }
  size_t v75 = (char *)operator new(48 * v74);
LABEL_162:
  size_t v76 = &v75[16 * ((v69 - v71) >> 4)];
  *(void *)size_t v76 = v107;
  *((void *)v76 + sub_1CD7485C0(this + 1) = v62;
  *((void *)v76 + 2) = v64;
  *((void *)v76 + 3) = v66;
  double v77 = &v75[48 * v74];
  *((void *)v76 + 4) = 0;
  *((void *)v76 + 5) = v109;
  size_t v70 = v76 + 48;
  if (v69 != v71)
  {
    do
    {
      long long v78 = *((_OWORD *)v69 - 3);
      long long v79 = *((_OWORD *)v69 - 1);
      *((_OWORD *)v76 - 2) = *((_OWORD *)v69 - 2);
      *((_OWORD *)v76 - sub_1CD7485C0(this + 1) = v79;
      *((_OWORD *)v76 - 3) = v78;
      v76 -= 48;
      v69 -= 48;
    }
    while (v69 != v71);
    uint64_t v69 = (char *)a1[9];
  }
  a1[9] = v76;
  a1[10] = v70;
  a1[11] = v77;
  if (v69) {
    operator delete(v69);
  }
LABEL_167:
  a1[10] = v70;
  if (!v100)
  {
    long long __dst = 0uLL;
    int64_t v118 = 0;
    goto LABEL_178;
  }
  if (v36 >= 0x7FFFFFFFFFFFFFF8) {
LABEL_197:
  }
    abort();
  if (v36 >= 0x17)
  {
    uint64_t v81 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v36 | 7) != 0x17) {
      uint64_t v81 = v36 | 7;
    }
    uint64_t v82 = v81 + 1;
    p_dst = (long long *)operator new(v81 + 1);
    *((void *)&__dst + sub_1CD7485C0(this + 1) = v36;
    int64_t v118 = v82 | 0x8000000000000000;
    *(void *)&long long __dst = p_dst;
    goto LABEL_176;
  }
  HIBYTE(v118) = v36;
  p_dst = &__dst;
  if (v36) {
LABEL_176:
  }
    memmove(p_dst, v100, v36);
  *((unsigned char *)p_dst + v36) = 0;
LABEL_178:
  unint64_t v83 = a1[7];
  unint64_t v84 = a1[6];
  if (v84 < v83)
  {
    *(_OWORD *)unint64_t v84 = __dst;
    *(void *)(v84 + 16) = v118;
    a1[6] = v84 + 24;
    return;
  }
  uint64_t v85 = a1[5];
  unint64_t v86 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v84 - v85) >> 3);
  unint64_t v87 = v86 + 1;
  if (v86 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_197;
  }
  if (0x5555555555555556 * ((uint64_t)(v83 - v85) >> 3) > v87) {
    unint64_t v87 = 0x5555555555555556 * ((uint64_t)(v83 - v85) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v83 - v85) >> 3) >= 0x555555555555555) {
    unint64_t v88 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v88 = v87;
  }
  size_t v130 = (char *)(a1 + 7);
  if (v88)
  {
    if (v88 <= 0xAAAAAAAAAAAAAAALL)
    {
      uint64_t v89 = (char *)operator new(24 * v88);
      goto LABEL_190;
    }
LABEL_198:
    sub_1CB833614();
  }
  uint64_t v89 = 0;
LABEL_190:
  uint64_t v90 = &v89[8 * ((uint64_t)(v84 - v85) >> 3)];
  *(_OWORD *)uint64_t v90 = __dst;
  *((void *)v90 + 2) = v118;
  int64_t v118 = 0;
  long long __dst = 0uLL;
  if (v84 == v85)
  {
    BOOL v94 = 0;
    int64x2_t v93 = vdupq_n_s64(v84);
    unint64_t v91 = &v89[24 * v86];
  }
  else
  {
    unint64_t v91 = &v89[8 * ((uint64_t)(v84 - v85) >> 3)];
    do
    {
      long long v92 = *(_OWORD *)(v84 - 24);
      *((void *)v91 - sub_1CD7485C0(this + 1) = *(void *)(v84 - 8);
      *(_OWORD *)(v91 - 24) = v92;
      v91 -= 24;
      *(void *)(v84 - 16) = 0;
      *(void *)(v84 - 8) = 0;
      *(void *)(v84 - 24) = 0;
      v84 -= 24;
    }
    while (v84 != v85);
    int64x2_t v93 = *(int64x2_t *)(a1 + 5);
    unint64_t v83 = a1[7];
    BOOL v94 = v118 < 0;
  }
  uint64_t v95 = v90 + 24;
  a1[5] = v91;
  a1[6] = v90 + 24;
  *(int64x2_t *)&v128[8] = v93;
  a1[7] = &v89[24 * v88];
  unint64_t v129 = v83;
  *(void *)uint64_t v128 = v93.i64[0];
  sub_1CBF4EE0C((uint64_t)v128);
  a1[6] = v95;
  if (v94) {
    operator delete((void *)__dst);
  }
}

void sub_1CCCE096C(uint64_t a1@<X0>, void *a2@<X8>)
{
  (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
  if (*(void *)(a1 + 72) == *(void *)(a1 + 80)
    || (v4 = *(std::string **)(a1 + 40), uint64_t v5 = *(std::string **)(a1 + 48), v4 == v5))
  {
    operator new();
  }
  llvm::collectPGOFuncNameStrings(v4, 0xAAAAAAAAAAAAAAABLL * (((char *)v5 - (char *)v4) >> 3), (std::string *)(a1 + 16), a2);
  sub_1CBB2A024((void *)(a1 + 96));
  uint64_t v6 = *(void *)(a1 + 40);
  for (uint64_t i = *(void *)(a1 + 48); i != v6; i -= 24)
  {
    if (*(char *)(i - 1) < 0) {
      operator delete(*(void **)(i - 24));
    }
  }
  *(void *)(a1 + 48) = v6;
}

uint64_t sub_1CCCE0A98(void *a1)
{
  *a1 = &unk_1F263C448;
  uint64_t v2 = a1[15];
  a1[15] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *a1 = &unk_1F263C478;
  MEMORY[0x1D25D9CD0](a1[12], 4);
  unsigned int v3 = (void *)a1[9];
  if (v3)
  {
    a1[10] = v3;
    operator delete(v3);
  }

  return sub_1CCCDFE78((uint64_t)a1);
}

void sub_1CCCE0B50(void *a1)
{
  *a1 = &unk_1F263C448;
  uint64_t v2 = a1[15];
  a1[15] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *a1 = &unk_1F263C478;
  MEMORY[0x1D25D9CD0](a1[12], 4);
  unsigned int v3 = (void *)a1[9];
  if (v3)
  {
    a1[10] = v3;
    operator delete(v3);
  }
  sub_1CCCDFE78((uint64_t)a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCCE0C1C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 120);
  llvm::DWARFContext::parseNormalUnits(v2);
  uint64_t v3 = *(unsigned int *)(v2 + 24);
  if (v3)
  {
    uint64_t v4 = *(llvm::DWARFUnit ***)(v2 + 16);
    uint64_t v5 = &v4[v3];
    do
    {
      uint64_t v6 = *v4;
      llvm::DWARFUnit::extractDIEsIfNeeded(*v4, 0);
      uint64_t v7 = *((void *)v6 + 36);
      uint64_t v8 = *((void *)v6 + 37);
      if (v7 != v8)
      {
        uint64_t v9 = v7;
        do
        {
          sub_1CCCE0D28(a1, *v4, v7);
          v9 += 24;
          v7 += 24;
        }
        while (v9 != v8);
      }
      ++v4;
    }
    while (v4 != v5);
  }
  uint64_t v10 = *(void *)(a1 + 120);
  llvm::DWARFContext::parseDWOUnits(v10, 0);
  uint64_t v11 = *(unsigned int *)(v10 + 248);
  if (v11)
  {
    unsigned int v12 = *(llvm::DWARFUnit ***)(v10 + 240);
    char v13 = &v12[v11];
    do
    {
      uint64_t v14 = *v12;
      llvm::DWARFUnit::extractDIEsIfNeeded(*v12, 0);
      uint64_t v15 = *((void *)v14 + 36);
      uint64_t v16 = *((void *)v14 + 37);
      if (v15 != v16)
      {
        uint64_t v17 = v15;
        do
        {
          sub_1CCCE0D28(a1, *v12, v15);
          v17 += 24;
          v15 += 24;
        }
        while (v17 != v16);
      }
      ++v12;
    }
    while (v12 != v13);
  }
}

void sub_1CCCE0D28(uint64_t a1, llvm::DWARFUnit *a2, uint64_t a3)
{
  uint64_t v143 = *MEMORY[0x1E4F143B8];
  char v123 = a2;
  uint64_t v124 = a3;
  if (!a2) {
    return;
  }
  if (!a3) {
    return;
  }
  unsigned int v3 = *(_DWORD *)(a3 + 8);
  if (v3 == -1) {
    return;
  }
  uint64_t v4 = *((void *)a2 + 36);
  if (!v4) {
    return;
  }
  uint64_t v5 = *(void *)(a3 + 16);
  if (!v5) {
    return;
  }
  if (*(_WORD *)(v5 + 4) != 52) {
    return;
  }
  uint64_t v6 = *(void *)(v4 + 24 * v3 + 16);
  if (!v6) {
    return;
  }
  if (*(_WORD *)(v6 + 4) != 46) {
    return;
  }
  if (!*(unsigned char *)(v5 + 7)) {
    return;
  }
  ShortName = (const char *)llvm::DWARFDie::getShortName((llvm::DWARFDie *)&v123);
  if (!ShortName) {
    return;
  }
  uint64_t v9 = ShortName;
  if (strlen(ShortName) < 8 || *(void *)v9 != 0x5F63666F72705F5FLL) {
    return;
  }
  llvm::DWARFDie::getLocations(&v123, (llvm::dwarf *)2, (uint64_t)&v136);
  if (v138)
  {
    uint64_t v82 = v136;
    uint64_t v136 = 0;
    *(void *)&long long __dst = v82;
    sub_1CD4515D0((void **)&__dst);
    if ((void)__dst) {
      (*(void (**)(void))(*(void *)__dst + 8))(__dst);
    }
    goto LABEL_171;
  }
  uint64_t v10 = v136;
  uint64_t v11 = v137;
  if (v136 == v137)
  {
LABEL_171:
    int v115 = 0;
    unint64_t v113 = 0;
    unsigned __int8 v119 = 0;
    goto LABEL_32;
  }
  unsigned int v12 = v123;
  char v13 = *((unsigned char *)v123 + 34);
  while (1)
  {
    uint64_t v14 = *((void *)v10 + 4);
    uint64_t v15 = *((void *)v10 + 5);
    char v16 = (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 120) + 520) + 40))(*(void *)(*(void *)(a1 + 120) + 520));
    *(void *)&long long v131 = v14;
    *((void *)&v131 + sub_1CD7485C0(this + 1) = v15;
    char v132 = v16;
    char v133 = v13;
    char v134 = v13;
    __int16 v135 = 0;
    sub_1CC6A2264((uint64_t)v139, &v131, 0);
    sub_1CC6A2264((uint64_t)&__dst, &v131, *((unint64_t *)&v131 + 1));
    if (*(_OWORD *)v139 != __dst) {
      break;
    }
LABEL_28:
    uint64_t v10 = (llvm::DWARFUnit *)((char *)v10 + 64);
    if (v10 == v11) {
      goto LABEL_171;
    }
  }
  while (v139[16] == 161)
  {
    llvm::DWARFUnit::getAddrOffsetSectionItem((uint64_t)v12, (int)v141, (uint64_t)&v125);
    if (v127)
    {
      unint64_t v84 = v125;
      goto LABEL_31;
    }
LABEL_23:
    sub_1CC6A144C((unint64_t *)v139);
    if (*(void *)v139 == (void)__dst && *(void *)&v139[8] == *((void *)&__dst + 1)) {
      goto LABEL_28;
    }
  }
  if (v139[16] != 3) {
    goto LABEL_23;
  }
  unint64_t v84 = v141;
LABEL_31:
  unsigned __int8 v119 = v84;
  unint64_t v113 = (unint64_t)v84 & 0xFFFFFFFFFFFFFF00;
  int v115 = 1;
LABEL_32:
  if (v138)
  {
    char v18 = v136;
    uint64_t v136 = 0;
    if (v18) {
      (*(void (**)(llvm::DWARFUnit *))(*(void *)v18 + 8))(v18);
    }
  }
  else
  {
    *(void *)size_t v139 = &v136;
    sub_1CC683E70((void ***)v139);
  }
  char v19 = v123;
  if (v123)
  {
    uint64_t v20 = v124;
    if (v124)
    {
      unsigned int v21 = *(_DWORD *)(v124 + 8);
      if (v21 == -1)
      {
        char v19 = 0;
        goto LABEL_37;
      }
      uint64_t v20 = *((void *)v123 + 36) + 24 * v21;
    }
    else
    {
      char v19 = 0;
    }
  }
  else
  {
LABEL_37:
    uint64_t v20 = 0;
  }
  uint64_t v136 = v19;
  uint64_t v137 = (llvm::DWARFUnit *)v20;
  llvm::DWARFDie::find(&v136, 17, v139);
  if (v142)
  {
    llvm::DWARFFormValue::getAsSectionedAddress(v139, (uint64_t)&__dst);
    unsigned int v83 = __dst;
    uint64_t v110 = v129;
    if (!(_BYTE)v129) {
      unsigned int v83 = 0;
    }
    unsigned int v109 = v83;
  }
  else
  {
    unsigned int v109 = 0;
    uint64_t v110 = 0;
  }
  char v22 = v123;
  if (v123)
  {
    uint64_t LastChild = v124;
    if (!v124)
    {
      uint64_t v24 = 0;
      FirstChild = 0;
      goto LABEL_49;
    }
    FirstChild = (llvm::DWARFUnit *)llvm::DWARFUnit::getFirstChild((uint64_t)v123, v124);
    uint64_t v24 = v105;
    uint64_t LastChild = llvm::DWARFUnit::getLastChild((uint64_t)v22, LastChild);
    uint64_t v26 = v106;
  }
  else
  {
    uint64_t v24 = 0;
    FirstChild = 0;
    uint64_t LastChild = 0;
LABEL_49:
    uint64_t v26 = 0;
  }
  uint64_t v136 = FirstChild;
  uint64_t v137 = (llvm::DWARFUnit *)v24;
  if (v24 != v26 || FirstChild != (llvm::DWARFUnit *)LastChild)
  {
    int v27 = 0;
    char v116 = 0;
    long long __s = 0;
    unsigned int v111 = 0;
    unint64_t AsUnsignedConstant = 0;
    char v114 = 0;
    int v35 = (llvm::DWARFUnit *)LastChild;
    uint64_t v36 = v26;
    while (1)
    {
      uint64_t v37 = *(void *)(v24 + 16);
      if (!v37 || *(_WORD *)(v37 + 4) != 24576)
      {
        if (!FirstChild) {
          goto LABEL_73;
        }
        goto LABEL_70;
      }
      unint64_t v107 = FirstChild;
      uint64_t v108 = v24;
      llvm::DWARFDie::find(&v136, 3, v139);
      llvm::DWARFDie::find(&v136, 28, &__dst);
      if (v142)
      {
        if (v130) {
          break;
        }
      }
LABEL_120:
      FirstChild = v107;
      uint64_t v24 = v108;
      int v35 = (llvm::DWARFUnit *)LastChild;
      uint64_t v36 = v26;
      if (!v107) {
        goto LABEL_73;
      }
LABEL_70:
      unsigned int v38 = *(_DWORD *)(v24 + 12);
      if (v38)
      {
        uint64_t v24 = *((void *)FirstChild + 36) + 24 * v38;
        goto LABEL_74;
      }
      FirstChild = 0;
LABEL_73:
      uint64_t v24 = 0;
LABEL_74:
      uint64_t v136 = FirstChild;
      uint64_t v137 = (llvm::DWARFUnit *)v24;
      if (v24 == v36 && FirstChild == v35) {
        goto LABEL_53;
      }
    }
    llvm::DWARFFormValue::getAsCString((llvm *)v139, (uint64_t)&v131);
    uint64_t v39 = (char *)v131;
    if (BYTE8(v131))
    {
      *(void *)&long long v131 = 0;
      if (v39)
      {
        char v122 = v39;
        sub_1CD4515D0((void **)&v122);
        size_t v44 = v122;
        if (!v122) {
          goto LABEL_117;
        }
        goto LABEL_123;
      }
    }
    else if ((void)v131)
    {
      size_t v40 = strlen((const char *)v131);
LABEL_84:
      if (llvm::InstrProfCorrelator::FunctionNameAttributeName[0]) {
        size_t v41 = strlen(llvm::InstrProfCorrelator::FunctionNameAttributeName[0]);
      }
      else {
        size_t v41 = 0;
      }
      if (v41 >= v40) {
        size_t v42 = v40;
      }
      else {
        size_t v42 = v41;
      }
      if (v42 && memcmp(v39, llvm::InstrProfCorrelator::FunctionNameAttributeName[0], v42) || v40 != v41)
      {
        if (llvm::InstrProfCorrelator::CFGHashAttributeName[0]) {
          size_t v43 = strlen(llvm::InstrProfCorrelator::CFGHashAttributeName[0]);
        }
        else {
          size_t v43 = 0;
        }
        if (v43 >= v40) {
          size_t v45 = v40;
        }
        else {
          size_t v45 = v43;
        }
        if ((!v45 || !memcmp(v39, llvm::InstrProfCorrelator::CFGHashAttributeName[0], v45)) && v40 == v43)
        {
          unint64_t AsUnsignedConstant = llvm::DWARFFormValue::getAsUnsignedConstant((llvm::DWARFFormValue *)&__dst);
          char v116 = v49;
        }
        else
        {
          if (llvm::InstrProfCorrelator::NumCountersAttributeName) {
            size_t v46 = strlen(llvm::InstrProfCorrelator::NumCountersAttributeName);
          }
          else {
            size_t v46 = 0;
          }
          if (v46 >= v40) {
            size_t v47 = v40;
          }
          else {
            size_t v47 = v46;
          }
          if ((!v47 || !memcmp(v39, llvm::InstrProfCorrelator::NumCountersAttributeName, v47)) && v40 == v46)
          {
            unsigned int v111 = llvm::DWARFFormValue::getAsUnsignedConstant((llvm::DWARFFormValue *)&__dst);
            char v114 = v50;
          }
        }
        goto LABEL_117;
      }
      llvm::DWARFFormValue::getAsCString((llvm *)&__dst, (uint64_t)&v125);
      if ((v126 & 1) == 0)
      {
        int v27 = 1;
        long long __s = v125;
        goto LABEL_117;
      }
      if (!v125 || (v121 = v125, sub_1CD4515D0((void **)&v121), (size_t v44 = v121) == 0))
      {
LABEL_117:
        if (BYTE8(v131))
        {
          uint64_t v48 = v131;
          *(void *)&long long v131 = 0;
          if (v48) {
            (*(void (**)(uint64_t))(*(void *)v48 + 8))(v48);
          }
        }
        goto LABEL_120;
      }
LABEL_123:
      (*(void (**)(char *))(*(void *)v44 + 8))(v44);
      goto LABEL_117;
    }
    size_t v40 = 0;
    goto LABEL_84;
  }
  unsigned int v111 = 0;
  unint64_t AsUnsignedConstant = 0;
  char v114 = 0;
  char v116 = 0;
  long long __s = 0;
  int v27 = 0;
LABEL_53:
  if (v116) {
    BOOL v28 = v27 == 0;
  }
  else {
    BOOL v28 = 1;
  }
  int v29 = v115;
  if (v28) {
    int v29 = 0;
  }
  if (v29 != 1 || !v114) {
    return;
  }
  unint64_t v30 = v119 | v113;
  uint64_t v31 = *(void *)(a1 + 8);
  unint64_t v33 = *(void *)(v31 + 8);
  unint64_t v32 = *(void *)(v31 + 16);
  if (v30 < v33 || v30 >= v32) {
    return;
  }
  if (__s) {
    size_t v120 = strlen(__s);
  }
  else {
    size_t v120 = 0;
  }
  int v51 = v30 - v33;
  if (v110) {
    unsigned int v52 = v109;
  }
  else {
    unsigned int v52 = 0;
  }
  LODWORD(v136) = v51;
  uint64_t v53 = *(void *)(a1 + 96);
  int v54 = *(_DWORD *)(a1 + 112);
  if (!v54)
  {
    unint64_t v63 = 0;
    goto LABEL_144;
  }
  int v55 = v54 - 1;
  unsigned int v56 = v55 & (37 * v51);
  uint64_t v57 = (int *)(v53 + 4 * v56);
  int v58 = *v57;
  if (*v57 == v51) {
    return;
  }
  unint64_t v59 = 0;
  int v60 = 1;
  while (v58 != -1)
  {
    if (v59) {
      BOOL v61 = 0;
    }
    else {
      BOOL v61 = v58 == -2;
    }
    if (v61) {
      unint64_t v59 = v57;
    }
    unsigned int v62 = v56 + v60++;
    unsigned int v56 = v62 & v55;
    uint64_t v57 = (int *)(v53 + 4 * v56);
    int v58 = *v57;
    if (*v57 == v51) {
      return;
    }
  }
  if (v59) {
    unint64_t v63 = v59;
  }
  else {
    unint64_t v63 = v57;
  }
LABEL_144:
  size_t v64 = sub_1CBB29C30(a1 + 96, (uint64_t)&v136, &v136, v63);
  int *v64 = (int)v136;
  *(_OWORD *)size_t v139 = xmmword_1CFAC4320;
  *(void *)&v139[16] = 0;
  llvm::MD5::update((int *)v139, (int *)__s, v120);
  llvm::MD5::final((int *)v139, (int *)&__dst);
  unint64_t v65 = bswap64(__dst);
  if (*(unsigned char *)(*(void *)(a1 + 8) + 24)) {
    unint64_t v66 = v65;
  }
  else {
    unint64_t v66 = __dst;
  }
  unint64_t v67 = bswap64(AsUnsignedConstant);
  if (*(unsigned char *)(*(void *)(a1 + 8) + 24)) {
    unint64_t v68 = v67;
  }
  else {
    unint64_t v68 = AsUnsignedConstant;
  }
  unsigned int v69 = bswap32(v136);
  if (*(unsigned char *)(*(void *)(a1 + 8) + 24)) {
    unsigned int v70 = v69;
  }
  else {
    unsigned int v70 = v136;
  }
  unsigned int v71 = bswap32(v52);
  if (*(unsigned char *)(*(void *)(a1 + 8) + 24)) {
    unsigned int v72 = v71;
  }
  else {
    unsigned int v72 = v52;
  }
  unsigned int v73 = bswap32(v111);
  if (!*(unsigned char *)(*(void *)(a1 + 8) + 24)) {
    unsigned int v73 = v111;
  }
  unsigned int v117 = v73;
  size_t v75 = *(char **)(a1 + 80);
  unint64_t v74 = *(void *)(a1 + 88);
  if ((unint64_t)v75 < v74)
  {
    *(void *)size_t v75 = v66;
    *((void *)v75 + sub_1CD7485C0(this + 1) = v68;
    *((_DWORD *)v75 + 4) = v70;
    *((_DWORD *)v75 + 5) = v72;
    *((_DWORD *)v75 + 6) = 0;
    *((_DWORD *)v75 + 7) = v73;
    size_t v76 = v75 + 40;
    *((_DWORD *)v75 + 8) = 0;
    goto LABEL_181;
  }
  double v77 = *(unsigned char **)(a1 + 72);
  unint64_t v78 = 0xCCCCCCCCCCCCCCCDLL * ((v75 - v77) >> 3) + 1;
  if (v78 > 0x666666666666666) {
    goto LABEL_212;
  }
  unint64_t v79 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v74 - (void)v77) >> 3);
  if (2 * v79 > v78) {
    unint64_t v78 = 2 * v79;
  }
  if (v79 >= 0x333333333333333) {
    unint64_t v80 = 0x666666666666666;
  }
  else {
    unint64_t v80 = v78;
  }
  if (!v80)
  {
    uint64_t v81 = 0;
    goto LABEL_176;
  }
  if (v80 > 0x666666666666666) {
    goto LABEL_213;
  }
  uint64_t v81 = (char *)operator new(40 * v80);
LABEL_176:
  uint64_t v85 = &v81[8 * ((v75 - v77) >> 3)];
  *(void *)uint64_t v85 = v66;
  *((void *)v85 + sub_1CD7485C0(this + 1) = v68;
  *((_DWORD *)v85 + 4) = v70;
  *((_DWORD *)v85 + 5) = v72;
  unint64_t v86 = &v81[40 * v80];
  *((_DWORD *)v85 + 6) = 0;
  *(void *)(v85 + 28) = v117;
  size_t v76 = v85 + 40;
  if (v75 != v77)
  {
    do
    {
      long long v87 = *(_OWORD *)(v75 - 40);
      long long v88 = *(_OWORD *)(v75 - 24);
      *((void *)v85 - sub_1CD7485C0(this + 1) = *((void *)v75 - 1);
      *(_OWORD *)(v85 - 24) = v88;
      *(_OWORD *)(v85 - 40) = v87;
      v85 -= 40;
      v75 -= 40;
    }
    while (v75 != v77);
    size_t v75 = *(char **)(a1 + 72);
  }
  *(void *)(a1 + 72) = v85;
  *(void *)(a1 + 80) = v76;
  *(void *)(a1 + 88) = v86;
  if (v75) {
    operator delete(v75);
  }
LABEL_181:
  *(void *)(a1 + 80) = v76;
  if (!__s)
  {
    long long __dst = 0uLL;
    int64_t v129 = 0;
    goto LABEL_192;
  }
  if (v120 >= 0x7FFFFFFFFFFFFFF8) {
LABEL_212:
  }
    abort();
  if (v120 >= 0x17)
  {
    uint64_t v90 = (v120 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v120 | 7) != 0x17) {
      uint64_t v90 = v120 | 7;
    }
    uint64_t v91 = v90 + 1;
    p_dst = (long long *)operator new(v90 + 1);
    *((void *)&__dst + sub_1CD7485C0(this + 1) = v120;
    int64_t v129 = v91 | 0x8000000000000000;
    *(void *)&long long __dst = p_dst;
    goto LABEL_190;
  }
  HIBYTE(v129) = v120;
  p_dst = &__dst;
  if (v120) {
LABEL_190:
  }
    memmove(p_dst, __s, v120);
  *((unsigned char *)p_dst + v120) = 0;
LABEL_192:
  unint64_t v92 = *(void *)(a1 + 56);
  unint64_t v93 = *(void *)(a1 + 48);
  if (v93 < v92)
  {
    *(_OWORD *)unint64_t v93 = __dst;
    *(void *)(v93 + 16) = v129;
    *(void *)(a1 + 48) = v93 + 24;
    return;
  }
  uint64_t v94 = *(void *)(a1 + 40);
  unint64_t v95 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v93 - v94) >> 3);
  unint64_t v96 = v95 + 1;
  if (v95 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_212;
  }
  if (0x5555555555555556 * ((uint64_t)(v92 - v94) >> 3) > v96) {
    unint64_t v96 = 0x5555555555555556 * ((uint64_t)(v92 - v94) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v92 - v94) >> 3) >= 0x555555555555555) {
    unint64_t v97 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v97 = v96;
  }
  uint64_t v141 = (char *)(a1 + 56);
  if (!v97)
  {
    unsigned int v98 = 0;
    goto LABEL_204;
  }
  if (v97 > 0xAAAAAAAAAAAAAAALL) {
LABEL_213:
  }
    sub_1CB833614();
  unsigned int v98 = (char *)operator new(24 * v97);
LABEL_204:
  uint64_t v99 = &v98[8 * ((uint64_t)(v93 - v94) >> 3)];
  *(_OWORD *)uint64_t v99 = __dst;
  *((void *)v99 + 2) = v129;
  int64_t v129 = 0;
  long long __dst = 0uLL;
  if (v93 == v94)
  {
    BOOL v103 = 0;
    int64x2_t v102 = vdupq_n_s64(v93);
    uint64_t v100 = &v98[24 * v95];
  }
  else
  {
    uint64_t v100 = &v98[8 * ((uint64_t)(v93 - v94) >> 3)];
    do
    {
      long long v101 = *(_OWORD *)(v93 - 24);
      *((void *)v100 - sub_1CD7485C0(this + 1) = *(void *)(v93 - 8);
      *(_OWORD *)(v100 - 24) = v101;
      v100 -= 24;
      *(void *)(v93 - 16) = 0;
      *(void *)(v93 - 8) = 0;
      *(void *)(v93 - 24) = 0;
      v93 -= 24;
    }
    while (v93 != v94);
    int64x2_t v102 = *(int64x2_t *)(a1 + 40);
    unint64_t v92 = *(void *)(a1 + 56);
    BOOL v103 = v129 < 0;
  }
  char v104 = v99 + 24;
  *(void *)(a1 + 40) = v100;
  *(void *)(a1 + 48) = v99 + 24;
  *(int64x2_t *)&v139[8] = v102;
  *(void *)(a1 + 56) = &v98[24 * v97];
  unint64_t v140 = v92;
  *(void *)size_t v139 = v102.i64[0];
  sub_1CBF4EE0C((uint64_t)v139);
  *(void *)(a1 + 48) = v104;
  if (v103) {
    operator delete((void *)__dst);
  }
}

llvm *llvm::InstrProfReader::create@<X0>(llvm::InstrProfReader *this@<X0>, const llvm::Twine *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  double result = sub_1CCCE1918(this, (uint64_t)a2, (uint64_t)&v9);
  uint64_t v7 = v9;
  if ((v10 & 1) == 0 || !v9)
  {
    uint64_t v8 = v9;
    llvm::InstrProfReader::create((uint64_t)&v8);
  }
  *(unsigned char *)(a3 + 8) |= 1u;
  *(void *)a3 = v7;
  return result;
}

llvm *sub_1CCCE1918@<X0>(llvm::Twine *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  llvm::Twine::str(a1, &__s1);
  uint64_t v6 = v15;
  if ((v15 & 0x80u) == 0) {
    uint64_t v7 = v15 & 0x7F;
  }
  else {
    uint64_t v7 = v14;
  }
  if (v7 == 1
    && ((v15 & 0x80) != 0 ? (void **)(p_s1 = __s1, uint64_t v6 = v14) : (p_s1 = (void **)&__s1),
        (int v9 = memcmp(p_s1, "-", v6 != 0), v6 == 1) && !v9))
  {
    llvm::MemoryBuffer::getSTDIN((uint64_t)&v16);
  }
  else
  {
    llvm::vfs::FileSystem::getBufferForFile(a2, (uint64_t)a1, -1, 1, 0, 0, (uint64_t)&v16);
  }
  if ((char)v15 < 0) {
    operator delete(__s1);
  }
  if ((uint64_t)v17.__cat_)
  {
    double result = v16;
    if (v16)
    {
      *(void *)&v10.__val_ = *(void *)&v17.__val_;
      llvm::errorCodeToError(v16, v10, &v12);
      *(unsigned char *)(a3 + 8) |= 1u;
      double result = v12;
      goto LABEL_17;
    }
  }
  else
  {
    std::system_category();
    double result = v16;
  }
  *(unsigned char *)(a3 + 8) &= ~1u;
  char v16 = 0;
LABEL_17:
  *(void *)a3 = result;
  if (((uint64_t)v17.__cat_ & 1) == 0)
  {
    double result = v16;
    char v16 = 0;
    if (result) {
      return (llvm *)(*(uint64_t (**)(llvm *))(*(void *)result + 8))(result);
    }
  }
  return result;
}

void llvm::InstrProfReader::create(uint64_t a1)
{
  int v1 = *(unsigned __int8 **)(*(void *)a1 + 8);
  unint64_t v2 = *(void *)(*(void *)a1 + 16) - (void)v1;
  if (!v2) {
    operator new();
  }
  if (v2 < 8)
  {
LABEL_3:
    if (v2 >= 8) {
      unint64_t v2 = 8;
    }
    while (1)
    {
      int v3 = *v1;
      unsigned int v4 = v3 - 32;
      unsigned int v5 = v3 - 9;
      if (v4 >= 0x5F && v5 >= 5) {
        operator new();
      }
      ++v1;
      if (!--v2) {
        operator new();
      }
    }
  }
  uint64_t v7 = *(void *)v1;
  if (*(void *)v1 <= (int64_t)0x8172666F72706CFELL)
  {
    if (v7 != 0x8152666F72706CFFLL)
    {
      if (v7 == 0x8169666F72706CFFLL) {
        operator new();
      }
      goto LABEL_3;
    }
  }
  else
  {
    if (v7 == 0x8172666F72706CFFLL) {
      goto LABEL_17;
    }
    if (v7 != 0xFF6C70726F665281)
    {
      if (v7 != 0xFF6C70726F667281) {
        goto LABEL_3;
      }
LABEL_17:
      operator new();
    }
  }
  operator new();
}

BOOL llvm::IndexedInstrProfReader::hasFormat(uint64_t a1)
{
  int v1 = *(void **)(a1 + 8);
  return *(void *)(a1 + 16) - (void)v1 >= 8uLL && *v1 == 0x8169666F72706CFFLL;
}

BOOL llvm::RawInstrProfReader<unsigned long long>::hasFormat(uint64_t a1)
{
  int v1 = *(uint64_t **)(a1 + 8);
  if (*(void *)(a1 + 16) - (void)v1 < 8uLL) {
    return 0;
  }
  uint64_t v3 = *v1;
  return v3 == 0xFF6C70726F667281 || v3 == 0x8172666F72706CFFLL;
}

uint64_t llvm::RawInstrProfReader<unsigned long long>::RawInstrProfReader(uint64_t result, uint64_t *a2, uint64_t a3)
{
  *(_DWORD *)(result + 8) = 0;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(void *)double result = &unk_1F263C520;
  uint64_t v3 = *a2;
  *a2 = 0;
  *(void *)(result + 48) = v3;
  if (a3)
  {
    if (*(_DWORD *)(a3 + 64) == 1) {
      uint64_t v4 = a3;
    }
    else {
      uint64_t v4 = 0;
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  *(void *)(result + 56) = v4;
  return result;
}

{
  uint64_t v3;
  uint64_t v4;

  *(_DWORD *)(result + 8) = 0;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(void *)double result = &unk_1F263C520;
  uint64_t v3 = *a2;
  *a2 = 0;
  *(void *)(result + 48) = v3;
  if (a3)
  {
    if (*(_DWORD *)(a3 + 64) == 1) {
      uint64_t v4 = a3;
    }
    else {
      uint64_t v4 = 0;
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  *(void *)(result + 56) = v4;
  return result;
}

BOOL llvm::RawInstrProfReader<unsigned int>::hasFormat(uint64_t a1)
{
  int v1 = *(uint64_t **)(a1 + 8);
  if (*(void *)(a1 + 16) - (void)v1 < 8uLL) {
    return 0;
  }
  uint64_t v3 = *v1;
  return v3 == 0xFF6C70726F665281 || v3 == 0x8152666F72706CFFLL;
}

uint64_t llvm::RawInstrProfReader<unsigned int>::RawInstrProfReader(uint64_t result, uint64_t *a2, uint64_t a3)
{
  *(_DWORD *)(result + 8) = 0;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(void *)double result = &unk_1F263C4A8;
  uint64_t v3 = *a2;
  *a2 = 0;
  *(void *)(result + 48) = v3;
  if (a3)
  {
    if (*(_DWORD *)(a3 + 64)) {
      uint64_t v4 = 0;
    }
    else {
      uint64_t v4 = a3;
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  *(void *)(result + 56) = v4;
  return result;
}

{
  uint64_t v3;
  uint64_t v4;

  *(_DWORD *)(result + 8) = 0;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(void *)double result = &unk_1F263C4A8;
  uint64_t v3 = *a2;
  *a2 = 0;
  *(void *)(result + 48) = v3;
  if (a3)
  {
    if (*(_DWORD *)(a3 + 64)) {
      uint64_t v4 = 0;
    }
    else {
      uint64_t v4 = a3;
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  *(void *)(result + 56) = v4;
  return result;
}

BOOL llvm::TextInstrProfReader::hasFormat(uint64_t a1)
{
  int v1 = *(unsigned __int8 **)(a1 + 8);
  unint64_t v2 = *(void *)(a1 + 16) - (void)v1;
  if (v2 >= 8) {
    unint64_t v2 = 8;
  }
  if (!v2) {
    return 1;
  }
  unint64_t v3 = v2 - 1;
  do
  {
    int v4 = *v1++;
    unsigned int v5 = v4 - 9;
    BOOL result = (v4 - 32) < 0x5F || v5 < 5;
  }
  while (result && v3-- != 0);
  return result;
}

void llvm::IndexedInstrProfReader::create(uint64_t a1)
{
  int v1 = *(void **)(*(void *)a1 + 8);
  if (*(void *)(*(void *)a1 + 16) - (void)v1 >= 8uLL && *v1 == 0x8169666F72706CFFLL) {
    operator new();
  }
  operator new();
}

void llvm::TextInstrProfReader::readHeader(llvm::TextInstrProfReader *this)
{
}

void llvm::TextInstrProfReader::readValueProfileData(llvm::TextInstrProfReader *this@<X0>, llvm::InstrProfRecord *a2@<X1>, void *a3@<X8>)
{
  uint64_t v89 = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)this + 88))
  {
    uint64_t v5 = *((void *)this + 14);
    if (v5)
    {
      unint64_t v6 = 0;
      uint64_t v7 = (char *)this + 56;
      uint64_t v8 = (uint64_t *)((char *)this + 104);
      int v9 = (unsigned __int8 *)*((void *)this + 13);
      unint64_t v79 = a3;
      unsigned int v83 = (uint64_t *)((char *)this + 104);
      while (1)
      {
        int v10 = *v9;
        if ((v10 - 48) >= 0xA)
        {
          if ((v10 - 97) >= 0x1A)
          {
            a3 = v79;
            uint64_t v8 = (uint64_t *)((char *)this + 104);
            if ((v10 - 65) > 0x19) {
              break;
            }
            int v11 = -55;
          }
          else
          {
            int v11 = -87;
            a3 = v79;
            uint64_t v8 = (uint64_t *)((char *)this + 104);
          }
        }
        else
        {
          int v11 = -48;
        }
        unsigned int v12 = v11 + v10;
        if (v12 > 9) {
          break;
        }
        unint64_t v13 = 10 * v6 + v12;
        if (v6 > v13 / 0xA) {
          break;
        }
        ++v9;
        unint64_t v6 = v13;
        if (!--v5)
        {
          if (v13 >= 0x100000000) {
            uint64_t v14 = 0x100000000;
          }
          else {
            uint64_t v14 = v13;
          }
          if (HIDWORD(v13)) {
            break;
          }
          if ((v14 - 3) <= 0xFFFFFFFD)
          {
            __p[0].__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x28uLL);
            *(_OWORD *)&__p[0].__r_.__value_.__r.__words[1] = xmmword_1CFAC3CC0;
            strcpy(__p[0].__r_.__value_.__l.__data_, "number of value kinds is invalid");
          }
          else
          {
            llvm::line_iterator::advance((uint64_t)this + 56);
            int v15 = 0;
            unsigned int v16 = 0;
            while (1)
            {
              if (!*((unsigned char *)this + 88)) {
                goto LABEL_173;
              }
              uint64_t v17 = *((void *)this + 14);
              if (!v17) {
                goto LABEL_164;
              }
              unint64_t v18 = 0;
              char v19 = (unsigned __int8 *)*v8;
              do
              {
                int v20 = *v19;
                if ((v20 - 48) >= 0xA)
                {
                  if ((v20 - 97) >= 0x1A)
                  {
                    a3 = v79;
                    uint64_t v8 = v83;
                    unsigned int v16 = 0;
                    if ((v20 - 65) > 0x19) {
                      goto LABEL_164;
                    }
                    int v21 = -55;
                  }
                  else
                  {
                    int v21 = -87;
                    a3 = v79;
                    uint64_t v8 = v83;
                    unsigned int v16 = 0;
                  }
                }
                else
                {
                  int v21 = -48;
                }
                unsigned int v22 = v21 + v20;
                if (v22 > 9) {
                  goto LABEL_164;
                }
                unint64_t v23 = 10 * v18 + v22;
                if (v18 > v23 / 0xA) {
                  goto LABEL_164;
                }
                ++v19;
                unint64_t v18 = v23;
                --v17;
              }
              while (v17);
              unsigned int v24 = v23 >= 0x100000000 ? 0 : v23;
              if (HIDWORD(v23)) {
                goto LABEL_164;
              }
              llvm::line_iterator::advance((uint64_t)v7);
              if (v24 >= 2)
              {
                *((unsigned char *)&__p[0].__r_.__value_.__s + 23) = 21;
                strcpy((char *)__p, "value kind is invalid");
                goto LABEL_165;
              }
              if (!*((unsigned char *)this + 88)) {
                goto LABEL_173;
              }
              uint64_t v25 = *((void *)this + 14);
              if (!v25) {
                goto LABEL_164;
              }
              unint64_t v26 = 0;
              int v27 = (unsigned __int8 *)*v8;
              do
              {
                int v28 = *v27;
                if ((v28 - 48) >= 0xA)
                {
                  if ((v28 - 97) >= 0x1A)
                  {
                    a3 = v79;
                    uint64_t v8 = v83;
                    unsigned int v16 = 0;
                    if ((v28 - 65) > 0x19) {
                      goto LABEL_164;
                    }
                    int v29 = -55;
                  }
                  else
                  {
                    int v29 = -87;
                    a3 = v79;
                    uint64_t v8 = v83;
                    unsigned int v16 = 0;
                  }
                }
                else
                {
                  int v29 = -48;
                }
                unsigned int v30 = v29 + v28;
                if (v30 > 9) {
                  goto LABEL_164;
                }
                unint64_t v31 = 10 * v26 + v30;
                if (v26 > v31 / 0xA) {
                  goto LABEL_164;
                }
                ++v27;
                unint64_t v26 = v31;
                --v25;
              }
              while (v25);
              unsigned int v32 = v31 >= 0x100000000 ? 0 : v31;
              if (HIDWORD(v31)) {
                goto LABEL_164;
              }
              llvm::line_iterator::advance((uint64_t)v7);
              if (v32) {
                break;
              }
LABEL_56:
              if (++v15 == v14)
              {
                sub_1CD74DADC((uint64_t)this, a3);
                return;
              }
            }
            unint64_t v33 = (unint64_t *)sub_1CD74C670((uint64_t)a2, v15);
            sub_1CD74D628(v33, v32);
            int v80 = 0;
            uint64_t v82 = v7;
            uint64_t v76 = v14;
            unsigned int v77 = v32;
            int v75 = v15;
            int v84 = v24;
            while (2)
            {
              if (!*((unsigned char *)this + 88))
              {
LABEL_173:
                *((unsigned char *)&__p[0].__r_.__value_.__s + 23) = 0;
                __p[0].__r_.__value_.__s.__data_[0] = 0;
                unsigned int v72 = a3;
                unsigned int v73 = this;
                int v74 = 8;
                goto LABEL_166;
              }
              uint64_t v34 = *((void *)this + 14);
              if (v34)
              {
                unint64_t v35 = 0;
                uint64_t v36 = (unsigned __int8 *)*v8;
                do
                {
                  int v37 = *v36;
                  if ((v37 - 48) >= 0xA)
                  {
                    if ((v37 - 97) >= 0x1A)
                    {
                      a3 = v79;
                      uint64_t v8 = v83;
                      unsigned int v16 = 0;
                      if ((v37 - 65) > 0x19) {
                        goto LABEL_164;
                      }
                      int v38 = -55;
                    }
                    else
                    {
                      int v38 = -87;
                      a3 = v79;
                      uint64_t v8 = v83;
                      unsigned int v16 = 0;
                    }
                  }
                  else
                  {
                    int v38 = -48;
                  }
                  unsigned int v39 = v38 + v37;
                  if (v39 > 9) {
                    goto LABEL_164;
                  }
                  unint64_t v40 = 10 * v35 + v39;
                  if (v35 > v40 / 0xA) {
                    goto LABEL_164;
                  }
                  ++v36;
                  unint64_t v35 = v40;
                  --v34;
                }
                while (v34);
                if (v40 < 0x100000000) {
                  unsigned int v16 = v40;
                }
                if (HIDWORD(v40)) {
                  break;
                }
                llvm::line_iterator::advance((uint64_t)v7);
                if (!v16)
                {
                  size_t v43 = 0;
LABEL_146:
                  llvm::InstrProfRecord::addValueData((uint64_t)a2, v84, v80, v43, v16, 0);
                  BOOL v85 = 0;
                  a3 = v79;
                  unsigned int v16 = 0;
                  goto LABEL_154;
                }
                unsigned int v41 = 0;
                unint64_t v86 = 0;
                size_t v42 = 0;
                size_t v43 = 0;
                BOOL v44 = 1;
                unsigned int v81 = v16;
LABEL_77:
                BOOL v85 = v44;
                if (*((unsigned char *)this + 88))
                {
                  __p[0].__r_.__value_.__s.__data_[0] = 58;
                  unint64_t v45 = llvm::StringRef::rfind(v8, __p, 1uLL);
                  if (v45 == -1)
                  {
                    unint64_t v51 = 0;
                    char v50 = 0;
                    size_t v47 = (unsigned __int8 *)*((void *)this + 13);
                    size_t v48 = *((void *)this + 14);
                  }
                  else
                  {
                    size_t v47 = (unsigned __int8 *)*((void *)this + 13);
                    unint64_t v46 = *((void *)this + 14);
                    if (v46 >= v45) {
                      size_t v48 = v45;
                    }
                    else {
                      size_t v48 = *((void *)this + 14);
                    }
                    if (v46 >= v45 + 1) {
                      unint64_t v49 = v45 + 1;
                    }
                    else {
                      unint64_t v49 = *((void *)this + 14);
                    }
                    char v50 = &v47[v49];
                    unint64_t v51 = v46 - v49;
                  }
                  if (v84)
                  {
                    if (v48)
                    {
                      unint64_t v52 = 0;
                      while (1)
                      {
                        int v53 = *v47;
                        if ((v53 - 48) >= 0xA)
                        {
                          if ((v53 - 97) >= 0x1A)
                          {
                            if ((v53 - 65) > 0x19) {
                              break;
                            }
                            int v54 = -55;
                          }
                          else
                          {
                            int v54 = -87;
                          }
                        }
                        else
                        {
                          int v54 = -48;
                        }
                        unsigned int v55 = v54 + v53;
                        if (v55 > 9) {
                          break;
                        }
                        unint64_t v56 = 10 * v52 + v55;
                        if (v52 > v56 / 0xA) {
                          break;
                        }
                        ++v47;
                        unint64_t v52 = 10 * v52 + v55;
                        if (!--v48) {
                          goto LABEL_110;
                        }
                      }
                    }
                    *((unsigned char *)&__p[0].__r_.__value_.__s + 23) = 0;
                    __p[0].__r_.__value_.__s.__data_[0] = 0;
                    a3 = v79;
                    sub_1CD74DA30(__p, (uint64_t)this, 9, v79);
                    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(__p[0].__r_.__value_.__l.__data_);
                    }
LABEL_152:
                    uint64_t v7 = v82;
                    uint64_t v8 = v83;
                  }
                  else
                  {
                    if (v48 == 21
                      && (*(void *)v47 == 0x7265747845202A2ALL
                        ? (BOOL v57 = *((void *)v47 + 1) == 0x626D7953206C616ELL)
                        : (BOOL v57 = 0),
                          v57 ? (BOOL v58 = *(void *)(v47 + 13) == 0x2A2A206C6F626D79) : (BOOL v58 = 0),
                          v58))
                    {
                      unint64_t v56 = 0;
                    }
                    else
                    {
                      sub_1CD74C38C(*((void *)this + 5), v47, v48, v79);
                      if (*v79)
                      {
                        a3 = v79;
                        goto LABEL_152;
                      }
                      *(_OWORD *)&__p[0].__r_.__value_.__l.__data_ = xmmword_1CFAC4320;
                      __p[0].__r_.__value_.__r.__words[2] = 0;
                      llvm::MD5::update((int *)__p, (int *)v47, v48);
                      llvm::MD5::final((int *)__p, (int *)&v87);
                      unint64_t v56 = v87;
                    }
LABEL_110:
                    if (v51)
                    {
                      unint64_t v59 = 0;
                      while (1)
                      {
                        int v60 = *v50;
                        if ((v60 - 48) >= 0xA)
                        {
                          if ((v60 - 97) >= 0x1A)
                          {
                            if ((v60 - 65) > 0x19) {
                              break;
                            }
                            int v61 = -55;
                          }
                          else
                          {
                            int v61 = -87;
                          }
                        }
                        else
                        {
                          int v61 = -48;
                        }
                        unsigned int v62 = v61 + v60;
                        if (v62 > 9) {
                          break;
                        }
                        unint64_t v63 = 10 * v59 + v62;
                        if (v59 > v63 / 0xA) {
                          break;
                        }
                        ++v50;
                        unint64_t v59 = 10 * v59 + v62;
                        if (!--v51)
                        {
                          if (v42 >= v86)
                          {
                            uint64_t v65 = v42 - v43;
                            unint64_t v66 = v65 + 1;
                            unsigned int v16 = v81;
                            if ((unint64_t)(v65 + 1) >> 60) {
                              abort();
                            }
                            if (((char *)v86 - (char *)v43) >> 3 > v66) {
                              unint64_t v66 = ((char *)v86 - (char *)v43) >> 3;
                            }
                            if ((unint64_t)((char *)v86 - (char *)v43) >= 0x7FFFFFFFFFFFFFF0) {
                              unint64_t v67 = 0xFFFFFFFFFFFFFFFLL;
                            }
                            else {
                              unint64_t v67 = v66;
                            }
                            if (v67)
                            {
                              if (v67 >> 60) {
                                sub_1CB833614();
                              }
                              unint64_t v68 = (char *)operator new(16 * v67);
                            }
                            else
                            {
                              unint64_t v68 = 0;
                            }
                            unsigned int v69 = (unint64_t *)&v68[16 * v65];
                            *unsigned int v69 = v56;
                            v69[1] = v63;
                            if (v42 == v43)
                            {
                              size_t v43 = (long long *)&v68[16 * v65];
                              uint64_t v7 = v82;
                              uint64_t v8 = v83;
                            }
                            else
                            {
                              unsigned int v70 = (long long *)&v68[16 * v65];
                              uint64_t v7 = v82;
                              uint64_t v8 = v83;
                              do
                                *--unsigned int v70 = *--v42;
                              while (v42 != v43);
                              size_t v42 = v43;
                              size_t v43 = v70;
                            }
                            unint64_t v86 = (long long *)&v68[16 * v67];
                            size_t v64 = (long long *)(v69 + 2);
                            if (v42) {
                              operator delete(v42);
                            }
                          }
                          else
                          {
                            *(void *)size_t v42 = v56;
                            *((void *)v42 + sub_1CD7485C0(this + 1) = v63;
                            size_t v64 = v42 + 1;
                            uint64_t v7 = v82;
                            uint64_t v8 = v83;
                            unsigned int v16 = v81;
                          }
                          llvm::line_iterator::advance((uint64_t)v7);
                          ++v41;
                          size_t v42 = v64;
                          BOOL v44 = v41 < v16;
                          if (v41 != v16) {
                            goto LABEL_77;
                          }
                          goto LABEL_146;
                        }
                      }
                    }
                    *((unsigned char *)&__p[0].__r_.__value_.__s + 23) = 0;
                    __p[0].__r_.__value_.__s.__data_[0] = 0;
                    a3 = v79;
                    sub_1CD74DA30(__p, (uint64_t)this, 9, v79);
                    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(__p[0].__r_.__value_.__l.__data_);
                    }
                    uint64_t v7 = v82;
                    uint64_t v8 = v83;
                  }
                  unsigned int v16 = 0;
LABEL_154:
                  unsigned int v71 = v77;
                  if (v43) {
LABEL_155:
                  }
                    operator delete(v43);
                }
                else
                {
                  *((unsigned char *)&__p[0].__r_.__value_.__s + 23) = 0;
                  __p[0].__r_.__value_.__s.__data_[0] = 0;
                  a3 = v79;
                  sub_1CD74DA30(__p, (uint64_t)this, 8, v79);
                  unsigned int v71 = v77;
                  if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(__p[0].__r_.__value_.__l.__data_);
                  }
                  unsigned int v16 = 0;
                  if (v43) {
                    goto LABEL_155;
                  }
                }
                if (v85) {
                  return;
                }
                ++v80;
                uint64_t v14 = v76;
                int v15 = v75;
                if (v80 != v71) {
                  continue;
                }
                goto LABEL_56;
              }
              break;
            }
LABEL_164:
            *((unsigned char *)&__p[0].__r_.__value_.__s + 23) = 0;
            __p[0].__r_.__value_.__s.__data_[0] = 0;
          }
LABEL_165:
          unsigned int v72 = a3;
          unsigned int v73 = this;
          int v74 = 9;
LABEL_166:
          sub_1CD74DA30(__p, (uint64_t)v73, v74, v72);
          if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p[0].__r_.__value_.__l.__data_);
          }
          return;
        }
      }
    }
  }

  sub_1CD74DADC((uint64_t)this, a3);
}

void llvm::TextInstrProfReader::readNextRecord(uint64_t a1@<X0>, llvm::InstrProfRecord *a2@<X1>, void *a3@<X8>)
{
  if (*(unsigned char *)(a1 + 88))
  {
    while (1)
    {
      size_t v6 = *(void *)(a1 + 112);
      if (v6)
      {
        uint64_t v7 = *(unsigned __int8 **)(a1 + 104);
        if (*v7 != 35) {
          break;
        }
      }
      llvm::line_iterator::advance(a1 + 56);
      if (!*(unsigned char *)(a1 + 88)) {
        goto LABEL_5;
      }
    }
    llvm::line_iterator::advance(a1 + 56);
    *((void *)a2 + 4) = v7;
    *((void *)a2 + 5) = v6;
    sub_1CD74C38C(*(void *)(a1 + 40), v7, v6, &__p);
    if (__p.__r_.__value_.__r.__words[0]) {
      goto LABEL_76;
    }
    if (*(unsigned char *)(a1 + 88))
    {
      std::string::size_type v11 = *(void *)(a1 + 104);
      std::string::size_type v12 = *(void *)(a1 + 112);
      llvm::line_iterator::advance(a1 + 56);
      __p.__r_.__value_.__r.__words[0] = v11;
      __p.__r_.__value_.__l.__size_ = v12;
      unsigned int v13 = sub_1CD0AF898((uint64_t)&__p);
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
      if (__p.__r_.__value_.__l.__size_)
      {
        unint64_t v15 = 0;
        unsigned int v16 = (unsigned __int8 *)__p.__r_.__value_.__r.__words[0];
        while (1)
        {
          int v17 = *v16;
          if ((v17 - 48) >= 0xA)
          {
            if ((v17 - 97) >= 0x1A)
            {
              if ((v17 - 65) > 0x19) {
                break;
              }
              int v18 = -55;
            }
            else
            {
              int v18 = -87;
            }
          }
          else
          {
            int v18 = -48;
          }
          unsigned int v19 = v18 + v17;
          if (v19 >= v13) {
            break;
          }
          unint64_t v20 = v15 * v13 + v19;
          if (v20 / v13 < v15) {
            break;
          }
          ++v16;
          unint64_t v15 = v20;
          if (!--size)
          {
            *((void *)a2 + 6) = v20;
            if (!*(unsigned char *)(a1 + 88)) {
              goto LABEL_24;
            }
            int v21 = *(unsigned __int8 **)(a1 + 104);
            uint64_t v22 = *(void *)(a1 + 112);
            llvm::line_iterator::advance(a1 + 56);
            if (v22)
            {
              unint64_t v23 = 0;
              while (1)
              {
                int v24 = *v21;
                if ((v24 - 48) >= 0xA)
                {
                  if ((v24 - 97) >= 0x1A)
                  {
                    if ((v24 - 65) > 0x19) {
                      break;
                    }
                    int v25 = -55;
                  }
                  else
                  {
                    int v25 = -87;
                  }
                }
                else
                {
                  int v25 = -48;
                }
                unsigned int v26 = v25 + v24;
                if (v26 > 9) {
                  break;
                }
                unint64_t v27 = 10 * v23 + v26;
                if (v23 > v27 / 0xA) {
                  break;
                }
                ++v21;
                unint64_t v23 = 10 * v23 + v26;
                if (!--v22)
                {
                  if (v27)
                  {
                    *((void *)a2 + sub_1CD7485C0(this + 1) = *(void *)a2;
                    int v28 = (void **)*((void *)a2 + 3);
                    *((void *)a2 + 3) = 0;
                    if (v28)
                    {
                      int v29 = sub_1CD698204(v28);
                      MEMORY[0x1D25D9CE0](v29, 0x20C40A759441BLL);
                    }
                    sub_1CBF7ACFC((uint64_t)a2, v27);
                    uint64_t v30 = 0;
                    unint64_t v49 = v27;
                    while (1)
                    {
                      if (!*(unsigned char *)(a1 + 88)) {
                        goto LABEL_24;
                      }
                      unint64_t v31 = *(unsigned __int8 **)(a1 + 104);
                      uint64_t v32 = *(void *)(a1 + 112);
                      llvm::line_iterator::advance(a1 + 56);
                      if (!v32) {
                        break;
                      }
                      unint64_t v33 = 0;
                      do
                      {
                        int v34 = *v31;
                        if ((v34 - 48) >= 0xA)
                        {
                          if ((v34 - 97) >= 0x1A)
                          {
                            if ((v34 - 65) > 0x19) {
                              goto LABEL_77;
                            }
                            int v35 = -55;
                          }
                          else
                          {
                            int v35 = -87;
                          }
                        }
                        else
                        {
                          int v35 = -48;
                        }
                        unsigned int v36 = v35 + v34;
                        if (v36 > 9) {
                          goto LABEL_77;
                        }
                        unint64_t v37 = 10 * v33 + v36;
                        if (v33 > v37 / 0xA) {
                          goto LABEL_77;
                        }
                        ++v31;
                        unint64_t v33 = 10 * v33 + v36;
                        --v32;
                      }
                      while (v32);
                      unsigned int v39 = (unint64_t *)*((void *)a2 + 1);
                      unint64_t v38 = *((void *)a2 + 2);
                      if ((unint64_t)v39 >= v38)
                      {
                        unsigned int v41 = *(unint64_t **)a2;
                        uint64_t v42 = ((uint64_t)v39 - *(void *)a2) >> 3;
                        unint64_t v43 = v42 + 1;
                        if ((unint64_t)(v42 + 1) >> 61) {
                          abort();
                        }
                        uint64_t v44 = v38 - (void)v41;
                        if (v44 >> 2 > v43) {
                          unint64_t v43 = v44 >> 2;
                        }
                        if ((unint64_t)v44 >= 0x7FFFFFFFFFFFFFF8) {
                          unint64_t v45 = 0x1FFFFFFFFFFFFFFFLL;
                        }
                        else {
                          unint64_t v45 = v43;
                        }
                        if (v45)
                        {
                          if (v45 >> 61) {
                            sub_1CB833614();
                          }
                          unint64_t v46 = (char *)operator new(8 * v45);
                        }
                        else
                        {
                          unint64_t v46 = 0;
                        }
                        size_t v47 = (unint64_t *)&v46[8 * v42];
                        *size_t v47 = v37;
                        unint64_t v40 = v47 + 1;
                        while (v39 != v41)
                        {
                          unint64_t v48 = *--v39;
                          *--size_t v47 = v48;
                        }
                        *(void *)a2 = v47;
                        *((void *)a2 + sub_1CD7485C0(this + 1) = v40;
                        *((void *)a2 + 2) = &v46[8 * v45];
                        if (v41) {
                          operator delete(v41);
                        }
                        unint64_t v27 = v49;
                      }
                      else
                      {
                        *unsigned int v39 = v37;
                        unint64_t v40 = v39 + 1;
                      }
                      *((void *)a2 + sub_1CD7485C0(this + 1) = v40;
                      if (++v30 == v27)
                      {
                        llvm::TextInstrProfReader::readValueProfileData((llvm::TextInstrProfReader *)a1, a2, &__p);
                        if (!__p.__r_.__value_.__r.__words[0])
                        {
                          sub_1CD74DADC(a1, a3);
                          return;
                        }
LABEL_76:
                        sub_1CD74DB30(a1, &__p.__r_.__value_.__l.__data_);
                      }
                    }
LABEL_77:
                    *((unsigned char *)&__p.__r_.__value_.__s + 23) = 16;
                    strcpy((char *)&__p, "count is invalid");
                  }
                  else
                  {
                    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x20uLL);
                    *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = xmmword_1CD96DBE0;
                    strcpy(__p.__r_.__value_.__l.__data_, "number of counters is zero");
                  }
                  goto LABEL_80;
                }
              }
            }
            __p.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x30uLL);
            *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = xmmword_1CFB1B7C0;
            strcpy(__p.__r_.__value_.__l.__data_, "number of counters is not a valid integer");
            goto LABEL_80;
          }
        }
      }
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x28uLL);
      *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = xmmword_1CFAC3CE0;
      strcpy(__p.__r_.__value_.__l.__data_, "function hash is not a valid integer");
LABEL_80:
      uint64_t v8 = a3;
      uint64_t v9 = a1;
      int v10 = 9;
    }
    else
    {
LABEL_24:
      *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
      __p.__r_.__value_.__s.__data_[0] = 0;
      uint64_t v8 = a3;
      uint64_t v9 = a1;
      int v10 = 8;
    }
  }
  else
  {
LABEL_5:
    *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
    __p.__r_.__value_.__s.__data_[0] = 0;
    uint64_t v8 = a3;
    uint64_t v9 = a1;
    int v10 = 1;
  }
  sub_1CD74DA30(&__p, v9, v10, v8);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void llvm::RawInstrProfReader<unsigned int>::readHeader(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 48);
  unint64_t v3 = *(uint64_t **)(v2 + 8);
  unint64_t v4 = *(void *)(v2 + 16) - (void)v3;
  if (v4 >= 8 && ((uint64_t v5 = *v3, *v3 != 0x8152666F72706CFFLL) ? (v6 = v5 == 0xFF6C70726F665281) : (v6 = 1), v6))
  {
    if (v4 > 0x57)
    {
      *(unsigned char *)(a1 + 64) = v5 != 0xFF6C70726F665281;
      llvm::RawInstrProfReader<unsigned int>::readHeader();
    }
    *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
    __p.__r_.__value_.__s.__data_[0] = 0;
    int v7 = 4;
  }
  else
  {
    *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
    __p.__r_.__value_.__s.__data_[0] = 0;
    int v7 = 3;
  }
  sub_1CD74DA30(&__p, a1, v7, a2);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void llvm::RawInstrProfReader<unsigned int>::readHeader(uint64_t a1@<X0>, int8x16_t *a2@<X1>, void *a3@<X8>)
{
  unint64_t v3 = (int8x16_t *)a1;
  unint64_t v5 = a2->u64[1];
  unint64_t v6 = bswap64(v5);
  if (*(unsigned char *)(a1 + 64)) {
    unint64_t v5 = v6;
  }
  *(void *)(a1 + 72) = v5;
  if ((v5 & 0xFFFFFFFFFFFFFFLL) == 8)
  {
    if (!(*(unsigned int (**)(uint64_t))(*(void *)a1 + 64))(a1) || v3[3].i64[1])
    {
      if (((*(uint64_t (**)(int8x16_t *))(v3->i64[0] + 64))(v3) & 1) == 0 && v3[3].i64[1])
      {
        *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
        __p.__r_.__value_.__s.__data_[0] = 0;
        uint64_t v8 = a3;
        a1 = (uint64_t)v3;
        int v9 = 11;
      }
      else
      {
        unint64_t v10 = a2[1].u64[0];
        int v11 = v3[4].u8[0];
        unint64_t v12 = bswap64(v10);
        if (v3[4].i8[0]) {
          unint64_t v10 = v12;
        }
        v3[10].i64[0] = v10;
        if ((v10 & 7) == 0)
        {
          BOOL v13 = v11 == 0;
          int32x2_t v14 = vdup_n_s32(v11 == 0);
          v15.i64[0] = v14.u32[0];
          v15.i64[1] = v14.u32[1];
          v3[5] = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v15, 0x3FuLL)), a2[4], vrev64q_s8(a2[4]));
          unint64_t v16 = bswap64(a2[1].u64[1]);
          if (v11) {
            unint64_t v17 = v16;
          }
          else {
            unint64_t v17 = a2[1].u64[1];
          }
          unint64_t v18 = bswap64(a2[2].u64[0]);
          if (v13) {
            unint64_t v19 = a2[2].u64[0];
          }
          else {
            unint64_t v19 = v18;
          }
          unint64_t v20 = bswap64(a2[2].u64[1]);
          if (v13) {
            unint64_t v21 = a2[2].u64[1];
          }
          else {
            unint64_t v21 = v20;
          }
          int v22 = (*(uint64_t (**)(int8x16_t *))(v3->i64[0] + 72))(v3);
          char v23 = 3;
          if (v22) {
            char v23 = 0;
          }
          unint64_t v24 = v21 << v23;
          unint64_t v25 = bswap64(a2[3].u64[0]);
          if (!v3[4].i8[0]) {
            unint64_t v25 = a2[3].u64[0];
          }
          unint64_t v26 = bswap64(a2[3].u64[1]);
          if (v3[4].i8[0]) {
            unint64_t v27 = v26;
          }
          else {
            unint64_t v27 = a2[3].u64[1];
          }
          unint64_t v28 = a2[5].u64[0];
          int v29 = bswap64(v28);
          if (v3[4].i8[0]) {
            LODWORD(v28) = v29;
          }
          v3[9].i32[2] = v28;
          uint64_t v30 = v3[10].i64[0];
          uint64_t v31 = v30 + 88;
          uint64_t v32 = v19 + 40 * v17 + v30 + 88;
          unint64_t v33 = v25 + v24 + v32;
          int v34 = &a2->i8[(-(int)v27 & 7) + v27 + v33];
          unint64_t v35 = *(void *)(v3[3].i64[0] + 16);
          if ((unint64_t)v34 <= v35)
          {
            uint64_t v36 = v3[3].i64[1];
            if (v36)
            {
              uint64_t v38 = *(void *)(v36 + 72);
              uint64_t v39 = *(void *)(v36 + 80) - v38;
              if (!v39) {
                uint64_t v38 = 0;
              }
              v3[6].i64[0] = v38;
              v3[6].i64[1] = v38 + v39;
              unint64_t v40 = (void *)(v36 + 16);
              if (*(char *)(v36 + 39) < 0) {
                unint64_t v40 = (void *)*v40;
              }
              v3[8].i64[0] = (uint64_t)v40;
              if (*(char *)(v36 + 39) < 0) {
                uint64_t v41 = *(void *)(v36 + 24);
              }
              else {
                uint64_t v41 = *(unsigned __int8 *)(v36 + 39);
              }
              unint64_t v37 = (char *)v40 + v41;
            }
            else
            {
              v3[6].i64[0] = (uint64_t)a2->i64 + v31;
              v3[6].i64[1] = (uint64_t)&a2->i64[5 * v17] + v31;
              v3[8].i64[0] = (uint64_t)a2->i64 + v33;
              unint64_t v37 = &a2->i8[v33 + v27];
            }
            v3[10].i64[1] = (uint64_t)&a2[5].i64[1];
            uint64_t v42 = &a2->i8[v32];
            v3[7].i64[0] = (uint64_t)v42;
            v3[7].i64[1] = (uint64_t)&v42[v24];
            v3[8].i64[1] = (uint64_t)v37;
            v3[9].i64[0] = (uint64_t)v34;
            if ((unint64_t)&a2[5].u64[1] + v30 <= v35) {
              operator new();
            }
          }
        }
        *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
        __p.__r_.__value_.__s.__data_[0] = 0;
        uint64_t v8 = a3;
        a1 = (uint64_t)v3;
        int v9 = 4;
      }
    }
    else
    {
      *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
      __p.__r_.__value_.__s.__data_[0] = 0;
      uint64_t v8 = a3;
      a1 = (uint64_t)v3;
      int v9 = 10;
    }
  }
  else
  {
    *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
    __p.__r_.__value_.__s.__data_[0] = 0;
    uint64_t v8 = a3;
    int v9 = 5;
  }
  sub_1CD74DA30(&__p, a1, v9, v8);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void llvm::RawInstrProfReader<unsigned int>::readNextRecord(uint64_t a1, void *a2)
{
  unint64_t v4 = *(unint64_t **)(a1 + 96);
  if (v4 == *(unint64_t **)(a1 + 104)) {
    llvm::RawInstrProfReader<unsigned int>::readNextHeader();
  }
  unint64_t v5 = *v4;
  uint64_t v6 = *(void *)(a1 + 40);
  unint64_t v7 = bswap64(v5);
  if (*(unsigned char *)(a1 + 64)) {
    unint64_t v8 = v7;
  }
  else {
    unint64_t v8 = v5;
  }
  sub_1CD5DF87C(*(uint64_t **)(a1 + 40));
  int v9 = *(void **)(v6 + 56);
  unint64_t v10 = *(void **)(v6 + 64);
  if (v10 != v9)
  {
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * (v10 - v9);
    do
    {
      unint64_t v12 = v11 >> 1;
      BOOL v13 = &v9[3 * (v11 >> 1)];
      unint64_t v15 = *v13;
      int32x2_t v14 = v13 + 3;
      v11 += ~(v11 >> 1);
      if (v15 < v8) {
        int v9 = v14;
      }
      else {
        unint64_t v11 = v12;
      }
    }
    while (v11);
  }
  if (v9 == v10 || *v9 != v8)
  {
    uint64_t v16 = 0;
    uint64_t v17 = 0;
  }
  else
  {
    uint64_t v17 = v9[1];
    uint64_t v16 = v9[2];
  }
  a2[4] = v17;
  a2[5] = v16;
  sub_1CD74DADC(a1, &v20);
  if (!v20)
  {
    unint64_t v18 = *(void *)(*(void *)(a1 + 96) + 8);
    unint64_t v19 = bswap64(v18);
    if (*(unsigned char *)(a1 + 64)) {
      unint64_t v18 = v19;
    }
    a2[6] = v18;
    sub_1CD74DADC(a1, &v20);
    if (!v20) {
      llvm::RawInstrProfReader<unsigned int>::readRawCounts();
    }
  }
  sub_1CD74DB30(a1, &v20);
}

BOOL llvm::RawInstrProfReader<unsigned int>::atEnd(uint64_t a1)
{
  return *(void *)(a1 + 96) == *(void *)(a1 + 104);
}

void llvm::RawInstrProfReader<unsigned int>::readNextHeader(uint64_t a1, void *a2)
{
  unint64_t v2 = *(void *)(*(void *)(a1 + 48) + 16);
  if ((void *)v2 != a2)
  {
    char v3 = (char)a2;
    do
    {
      if (*(unsigned char *)a2)
      {
        if ((unint64_t)(a2 + 11) > v2) {
          operator new();
        }
        if ((v3 & 7) != 0) {
          operator new();
        }
        unint64_t v4 = 0x8152666F72706CFFLL;
        if (!*(unsigned char *)(a1 + 64)) {
          unint64_t v4 = 0xFF6C70726F665281;
        }
        if (*a2 == v4)
        {
          llvm::RawInstrProfReader<unsigned int>::readHeader();
        }
        operator new();
      }
      a2 = (void *)((char *)a2 + 1);
      ++v3;
    }
    while (a2 != (void *)v2);
  }
  operator new();
}

uint64_t llvm::RawInstrProfReader<unsigned int>::getNextHeaderPos(uint64_t a1)
{
  return *(void *)(a1 + 144);
}

void llvm::RawInstrProfReader<unsigned int>::readName(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = *(void *)(a1 + 40);
  unint64_t v7 = bswap64(**(void **)(a1 + 96));
  if (*(unsigned char *)(a1 + 64)) {
    unint64_t v8 = v7;
  }
  else {
    unint64_t v8 = **(void **)(a1 + 96);
  }
  sub_1CD5DF87C(*(uint64_t **)(a1 + 40));
  int v9 = *(void **)(v6 + 56);
  unint64_t v10 = *(void **)(v6 + 64);
  if (v10 != v9)
  {
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * (v10 - v9);
    do
    {
      unint64_t v12 = v11 >> 1;
      BOOL v13 = &v9[3 * (v11 >> 1)];
      unint64_t v15 = *v13;
      int32x2_t v14 = v13 + 3;
      v11 += ~(v11 >> 1);
      if (v15 < v8) {
        int v9 = v14;
      }
      else {
        unint64_t v11 = v12;
      }
    }
    while (v11);
  }
  if (v9 == v10 || *v9 != v8)
  {
    uint64_t v16 = 0;
    uint64_t v17 = 0;
  }
  else
  {
    uint64_t v17 = v9[1];
    uint64_t v16 = v9[2];
  }
  *(void *)(a2 + 32) = v17;
  *(void *)(a2 + 40) = v16;

  sub_1CD74DADC(a1, a3);
}

void llvm::RawInstrProfReader<unsigned int>::readFuncHash(uint64_t a1@<X0>, void *a2@<X8>, uint64_t a3@<X1>)
{
  unint64_t v3 = *(void *)(*(void *)(a1 + 96) + 8);
  unint64_t v4 = bswap64(v3);
  if (*(unsigned char *)(a1 + 64)) {
    unint64_t v3 = v4;
  }
  *(void *)(a3 + 48) = v3;
  sub_1CD74DADC(a1, a2);
}

void llvm::RawInstrProfReader<unsigned int>::readRawCounts(uint64_t a1@<X0>, char **a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 96);
  unsigned int v6 = *(_DWORD *)(v5 + 28);
  unsigned int v7 = bswap32(v6);
  if (*(unsigned char *)(a1 + 64)) {
    unint64_t v8 = v7;
  }
  else {
    unint64_t v8 = v6;
  }
  if (!v8)
  {
    __str.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x20uLL);
    *(_OWORD *)&__str.__r_.__value_.__r.__words[1] = xmmword_1CD96DBE0;
    strcpy(__str.__r_.__value_.__l.__data_, "number of counters is zero");
    sub_1CD74DA30(&__str, a1, 9, a3);
    if ((SHIBYTE(__str.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
    int v9 = (void *)__str.__r_.__value_.__r.__words[0];
    goto LABEL_21;
  }
  LODWORD(v5) = *(_DWORD *)(v5 + 16);
  unsigned int v10 = bswap32(v5);
  if (*(unsigned char *)(a1 + 64)) {
    uint64_t v5 = v10;
  }
  else {
    uint64_t v5 = v5;
  }
  uint64_t v11 = v5 - *(void *)(a1 + 80);
  v51[0] = v11;
  if (v11 < 0)
  {
    v46[0] = "counter offset ";
    size_t v47 = (const char *)v51;
    __int16 v48 = 2819;
    __str.__r_.__value_.__r.__words[0] = (std::string::size_type)v46;
    __str.__r_.__value_.__r.__words[2] = (std::string::size_type)" is negative";
    __int16 v50 = 770;
    llvm::Twine::str((llvm::Twine *)&__str, &v43);
    sub_1CD74DA30(&v43, a1, 9, a3);
    if ((SHIBYTE(v43.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
    int v9 = (void *)v43.__r_.__value_.__r.__words[0];
    goto LABEL_21;
  }
  uint64_t v13 = *(void *)(a1 + 112);
  uint64_t v12 = *(void *)(a1 + 120);
  if (v11 >= v12 - v13)
  {
    v43.__r_.__value_.__r.__words[0] = (std::string::size_type)"counter offset ";
    v43.__r_.__value_.__r.__words[2] = (std::string::size_type)v51;
    __int16 v44 = 2819;
    v46[0] = &v43;
    size_t v47 = " is greater than the maximum counter offset ";
    __int16 v48 = 770;
    uint64_t v42 = ~v13 + v12;
    __str.__r_.__value_.__r.__words[0] = (std::string::size_type)v46;
    __str.__r_.__value_.__r.__words[2] = (std::string::size_type)&v42;
    __int16 v18 = 2818;
    goto LABEL_19;
  }
  uint64_t v15 = v12 - v13 - v11;
  int v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 72))(a1);
  uint64_t v17 = 8;
  if (v16) {
    uint64_t v17 = 1;
  }
  uint64_t v42 = v15 / v17;
  if (v15 / v17 >= (unint64_t)v8)
  {
    uint64_t v41 = a3;
    a2[1] = *a2;
    sub_1CBF7ACFC((uint64_t)a2, v8);
    int v19 = 0;
    while (1)
    {
      uint64_t v20 = *(void *)(a1 + 112) + v11;
      if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 72))(a1)) {
        char v21 = 0;
      }
      else {
        char v21 = 3;
      }
      uint64_t v22 = (v19 << v21);
      if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 72))(a1))
      {
        unint64_t v23 = *(unsigned char *)(v20 + v22) == 0;
        unint64_t v25 = (unint64_t *)a2[1];
        unint64_t v24 = (unint64_t)a2[2];
        if ((unint64_t)v25 >= v24)
        {
          unint64_t v26 = (unint64_t *)*a2;
          uint64_t v27 = ((char *)v25 - *a2) >> 3;
          unint64_t v28 = v27 + 1;
          if ((unint64_t)(v27 + 1) >> 61) {
            goto LABEL_64;
          }
          uint64_t v29 = v24 - (void)v26;
          if (v29 >> 2 > v28) {
            unint64_t v28 = v29 >> 2;
          }
          if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v30 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v30 = v28;
          }
          if (v30)
          {
            if (v30 >> 61) {
              goto LABEL_65;
            }
            uint64_t v31 = (char *)operator new(8 * v30);
          }
          else
          {
            uint64_t v31 = 0;
          }
          uint64_t v38 = &v31[8 * v27];
          *(void *)uint64_t v38 = v23;
          int v34 = v38 + 8;
          while (v25 != v26)
          {
            uint64_t v39 = *--v25;
            *((void *)v38 - sub_1CD7485C0(this + 1) = v39;
            v38 -= 8;
          }
LABEL_60:
          *a2 = v38;
          a2[1] = v34;
          a2[2] = &v31[8 * v30];
          if (v26) {
            operator delete(v26);
          }
          goto LABEL_62;
        }
      }
      else
      {
        unint64_t v32 = bswap64(*(void *)(v20 + v22));
        if (*(unsigned char *)(a1 + 64)) {
          unint64_t v23 = v32;
        }
        else {
          unint64_t v23 = *(void *)(v20 + v22);
        }
        unint64_t v25 = (unint64_t *)a2[1];
        unint64_t v33 = (unint64_t)a2[2];
        if ((unint64_t)v25 >= v33)
        {
          unint64_t v26 = (unint64_t *)*a2;
          uint64_t v35 = ((char *)v25 - *a2) >> 3;
          unint64_t v36 = v35 + 1;
          if ((unint64_t)(v35 + 1) >> 61) {
LABEL_64:
          }
            abort();
          uint64_t v37 = v33 - (void)v26;
          if (v37 >> 2 > v36) {
            unint64_t v36 = v37 >> 2;
          }
          if ((unint64_t)v37 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v30 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v30 = v36;
          }
          if (v30)
          {
            if (v30 >> 61) {
LABEL_65:
            }
              sub_1CB833614();
            uint64_t v31 = (char *)operator new(8 * v30);
          }
          else
          {
            uint64_t v31 = 0;
          }
          uint64_t v38 = &v31[8 * v35];
          *(void *)uint64_t v38 = v23;
          int v34 = v38 + 8;
          while (v25 != v26)
          {
            uint64_t v40 = *--v25;
            *((void *)v38 - sub_1CD7485C0(this + 1) = v40;
            v38 -= 8;
          }
          goto LABEL_60;
        }
      }
      unint64_t *v25 = v23;
      int v34 = (char *)(v25 + 1);
LABEL_62:
      a2[1] = v34;
      if (++v19 == v8)
      {
        sub_1CD74DADC(a1, v41);
        return;
      }
    }
  }
  v43.__r_.__value_.__r.__words[0] = (std::string::size_type)"number of counters ";
  v43.__r_.__value_.__r.__words[2] = v8;
  __int16 v44 = 2051;
  v46[0] = &v43;
  size_t v47 = " is greater than the maximum number of counters ";
  __int16 v48 = 770;
  __str.__r_.__value_.__r.__words[0] = (std::string::size_type)v46;
  __str.__r_.__value_.__r.__words[2] = (std::string::size_type)&v42;
  __int16 v18 = 3074;
LABEL_19:
  __int16 v50 = v18;
  llvm::Twine::str((llvm::Twine *)&__str, &__p);
  sub_1CD74DA30(&__p, a1, 9, a3);
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    return;
  }
  int v9 = (void *)__p.__r_.__value_.__r.__words[0];
LABEL_21:
  operator delete(v9);
}

void llvm::RawInstrProfReader<unsigned int>::readValueProfilingData(uint64_t a1@<X0>, llvm::InstrProfRecord *a2@<X1>, llvm::ValueProfData **a3@<X8>)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  unsigned int v6 = (void **)*((void *)a2 + 3);
  *((void *)a2 + 3) = 0;
  if (v6)
  {
    unsigned int v7 = sub_1CD698204(v6);
    MEMORY[0x1D25D9CE0](v7, 0x20C40A759441BLL);
  }
  uint64_t v8 = 0;
  int v9 = 0;
  *(_DWORD *)(a1 + 156) = 0;
  char v10 = 1;
  do
  {
    char v11 = v10;
    if (*(_WORD *)(*(void *)(a1 + 96) + 2 * v8 + 32)) {
      ++v9;
    }
    uint64_t v8 = 1;
    char v10 = 0;
  }
  while ((v11 & 1) != 0);
  if (v9)
  {
    llvm::ValueProfData::getValueProfData(*(unsigned int **)(a1 + 144), *(void *)(*(void *)(a1 + 48) + 16), *(unsigned char *)(a1 + 64) == 0, (uint64_t)&v16);
    char v12 = v17;
    if (v17)
    {
      uint64_t v13 = v16;
      *a3 = v16;
      if (v13) {
        return;
      }
      int32x2_t v14 = 0;
    }
    else
    {
      *a3 = 0;
      int32x2_t v14 = v16;
    }
    llvm::ValueProfData::deserializeTo(v14, a2, *(llvm::InstrProfSymtab **)(a1 + 40));
    *(_DWORD *)(a1 + 156) = *(_DWORD *)v14;
    sub_1CD74DADC(a1, a3);
    if (v12)
    {
      uint64_t v15 = *(void (**)(llvm::ValueProfData *))(*(void *)v14 + 8);
      v15(v14);
    }
    else
    {
      operator delete(v14);
    }
  }
  else
  {
    sub_1CD74DADC(a1, a3);
  }
}

uint64_t llvm::RawInstrProfReader<unsigned int>::advanceData(uint64_t result)
{
  if (!*(void *)(result + 56)) {
    *(void *)(result + 80) -= 40;
  }
  *(void *)(result + 96) += 40;
  *(void *)(result + 144) += *(unsigned int *)(result + 156);
  return result;
}

void llvm::RawInstrProfReader<unsigned int>::printBinaryIds(llvm::raw_ostream *this@<X1>, uint64_t a2@<X0>, void *a3@<X8>)
{
  if (*(void *)(a2 + 160))
  {
    uint64_t v5 = (void *)*((void *)this + 4);
    if (*((void *)this + 3) - (void)v5 > 0xCuLL)
    {
      qmemcpy(v5, "Binary IDs: \n", 13);
      *((void *)this + 4) += 13;
    }
    else
    {
      llvm::raw_ostream::write(this, "Binary IDs: \n", 0xDuLL);
    }
    unsigned int v6 = *(unint64_t **)(a2 + 168);
    unsigned int v7 = (unint64_t *)((char *)v6 + *(void *)(a2 + 160));
    while (v6 < v7)
    {
      if ((unint64_t)((char *)v7 - (char *)v6) <= 7) {
        operator new();
      }
      unint64_t v8 = bswap64(*v6);
      if (*(unsigned char *)(a2 + 64)) {
        unint64_t v9 = v8;
      }
      else {
        unint64_t v9 = *v6;
      }
      if ((char *)v7 - (char *)v6 < v9 + 8) {
        operator new();
      }
      char v10 = v6 + 1;
      if ((unint64_t)(v6 + 1) > *(void *)(*(void *)(a2 + 48) + 16)) {
        operator new();
      }
      if (v9)
      {
        char v11 = (unsigned __int8 *)(v6 + 1);
        unint64_t v12 = v9;
        do
        {
          v16[0] = &unk_1F260ED30;
          unsigned int v13 = *v11++;
          v16[1] = "%02x";
          void v16[2] = v13;
          llvm::raw_ostream::operator<<(this, (uint64_t)v16);
          --v12;
        }
        while (v12);
      }
      int32x2_t v14 = (unsigned char *)*((void *)this + 4);
      if (*((unsigned char **)this + 3) == v14)
      {
        llvm::raw_ostream::write(this, "\n", 1uLL);
      }
      else
      {
        *int32x2_t v14 = 10;
        ++*((void *)this + 4);
      }
      unsigned int v6 = (unint64_t *)((char *)v10 + ((v9 + 7) & 0xFFFFFFFFFFFFFFF8));
      if ((unint64_t)v6 > *(void *)(*(void *)(a2 + 48) + 16)) {
        operator new();
      }
    }
    sub_1CD74DADC(a2, a3);
  }
  else
  {
    sub_1CD74DADC(a2, a3);
  }
}

uint64_t llvm::RawInstrProfReader<unsigned int>::isIRLevelProfile(uint64_t a1)
{
  return *(unsigned char *)(a1 + 79) & 1;
}

uint64_t llvm::RawInstrProfReader<unsigned int>::hasCSIRLevelProfile(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 79) >> 1) & 1;
}

uint64_t llvm::RawInstrProfReader<unsigned int>::instrEntryBBEnabled(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 79) >> 2) & 1;
}

uint64_t llvm::RawInstrProfReader<unsigned int>::useDebugInfoCorrelate(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 79) >> 3) & 1;
}

uint64_t llvm::RawInstrProfReader<unsigned int>::hasSingleByteCoverage(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 79) >> 4) & 1;
}

uint64_t llvm::RawInstrProfReader<unsigned int>::functionEntryOnly(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 79) >> 5) & 1;
}

uint64_t llvm::RawInstrProfReader<unsigned int>::getProfileKind(uint64_t a1)
{
  return (*(void *)(a1 + 72) >> 54) & 8 | (*(void *)(a1 + 72) >> 55) & 2 | HIBYTE(*(void *)(a1 + 72)) & 0x74;
}

uint64_t llvm::RawInstrProfReader<unsigned int>::getSymtab(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

void llvm::RawInstrProfReader<unsigned int>::createSymtab(uint64_t a1@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  llvm::readPGOFuncNameStrings(*(char **)(a1 + 128), *(void *)(a1 + 136) - *(void *)(a1 + 128), (uint64_t)a2, &v24);
  if (v24) {
    sub_1CD74DB30(a1, &v24);
  }
  unint64_t v23 = a3;
  unsigned int v7 = *(uint64_t **)(a1 + 96);
  for (uint64_t i = *(uint64_t **)(a1 + 104); v7 != i; v7 += 5)
  {
    unsigned int v8 = *((_DWORD *)v7 + 5);
    unsigned int v9 = bswap32(v8);
    if (*(unsigned char *)(a1 + 64)) {
      uint64_t v10 = v9;
    }
    else {
      uint64_t v10 = v8;
    }
    if (v10)
    {
      uint64_t v11 = *v7;
      unsigned int v13 = (char *)a2[14];
      unint64_t v12 = a2[15];
      if ((unint64_t)v13 >= v12)
      {
        uint64_t v15 = (char *)a2[13];
        uint64_t v16 = (v13 - v15) >> 4;
        unint64_t v17 = v16 + 1;
        if ((unint64_t)(v16 + 1) >> 60) {
          abort();
        }
        uint64_t v18 = v12 - (void)v15;
        if (v18 >> 3 > v17) {
          unint64_t v17 = v18 >> 3;
        }
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v19 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v19 = v17;
        }
        if (v19)
        {
          if (v19 >> 60) {
            sub_1CB833614();
          }
          uint64_t v20 = (char *)operator new(16 * v19);
        }
        else
        {
          uint64_t v20 = 0;
        }
        char v21 = &v20[16 * v16];
        *(void *)char v21 = v10;
        *((void *)v21 + sub_1CD7485C0(this + 1) = v11;
        uint64_t v22 = v21;
        if (v13 != v15)
        {
          do
          {
            *((_OWORD *)v22 - sub_1CD7485C0(this + 1) = *((_OWORD *)v13 - 1);
            v22 -= 16;
            v13 -= 16;
          }
          while (v13 != v15);
          unsigned int v13 = (char *)a2[13];
        }
        int32x2_t v14 = v21 + 16;
        a2[13] = v22;
        a2[14] = v21 + 16;
        a2[15] = &v20[16 * v19];
        if (v13) {
          operator delete(v13);
        }
      }
      else
      {
        *(void *)unsigned int v13 = v10;
        *((void *)v13 + sub_1CD7485C0(this + 1) = v11;
        int32x2_t v14 = v13 + 16;
      }
      a2[14] = v14;
      uint64_t i = *(uint64_t **)(a1 + 104);
    }
  }
  sub_1CD74DADC(a1, v23);
}

uint64_t llvm::RawInstrProfReader<unsigned int>::getCounterTypeSize(uint64_t a1)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 72))(a1)) {
    return 1;
  }
  else {
    return 8;
  }
}

uint64_t llvm::RawInstrProfReader<unsigned int>::getNumPaddingBytes(uint64_t a1, int a2)
{
  return -a2 & 7;
}

BOOL llvm::RawInstrProfReader<unsigned int>::getDataEndianness(uint64_t a1)
{
  return *(unsigned char *)(a1 + 64) == 0;
}

uint64_t llvm::RawInstrProfReader<unsigned int>::getName(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  unint64_t v3 = bswap64(a2);
  if (*(unsigned char *)(a1 + 64)) {
    unint64_t v4 = v3;
  }
  else {
    unint64_t v4 = a2;
  }
  sub_1CD5DF87C(*(uint64_t **)(a1 + 40));
  uint64_t v5 = *(void **)(v2 + 56);
  unsigned int v6 = *(void **)(v2 + 64);
  if (v6 != v5)
  {
    unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * (v6 - v5);
    do
    {
      unint64_t v8 = v7 >> 1;
      unsigned int v9 = &v5[3 * (v7 >> 1)];
      unint64_t v11 = *v9;
      uint64_t v10 = v9 + 3;
      v7 += ~(v7 >> 1);
      if (v11 < v4) {
        uint64_t v5 = v10;
      }
      else {
        unint64_t v7 = v8;
      }
    }
    while (v7);
  }
  if (v5 == v6 || *v5 != v4) {
    return 0;
  }
  else {
    return v5[1];
  }
}

void llvm::RawInstrProfReader<unsigned long long>::readHeader(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 48);
  unint64_t v3 = *(uint64_t **)(v2 + 8);
  unint64_t v4 = *(void *)(v2 + 16) - (void)v3;
  if (v4 >= 8 && ((uint64_t v5 = *v3, *v3 != 0x8172666F72706CFFLL) ? (v6 = v5 == 0xFF6C70726F667281) : (v6 = 1), v6))
  {
    if (v4 > 0x57)
    {
      *(unsigned char *)(a1 + 64) = v5 != 0xFF6C70726F667281;
      llvm::RawInstrProfReader<unsigned long long>::readHeader();
    }
    *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
    __p.__r_.__value_.__s.__data_[0] = 0;
    int v7 = 4;
  }
  else
  {
    *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
    __p.__r_.__value_.__s.__data_[0] = 0;
    int v7 = 3;
  }
  sub_1CD74DA30(&__p, a1, v7, a2);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void llvm::RawInstrProfReader<unsigned long long>::readHeader(uint64_t a1@<X0>, int8x16_t *a2@<X1>, void *a3@<X8>)
{
  unint64_t v3 = (int8x16_t *)a1;
  unint64_t v5 = a2->u64[1];
  unint64_t v6 = bswap64(v5);
  if (*(unsigned char *)(a1 + 64)) {
    unint64_t v5 = v6;
  }
  *(void *)(a1 + 72) = v5;
  if ((v5 & 0xFFFFFFFFFFFFFFLL) == 8)
  {
    if (!(*(unsigned int (**)(uint64_t))(*(void *)a1 + 64))(a1) || v3[3].i64[1])
    {
      if (((*(uint64_t (**)(int8x16_t *))(v3->i64[0] + 64))(v3) & 1) == 0 && v3[3].i64[1])
      {
        *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
        __p.__r_.__value_.__s.__data_[0] = 0;
        unint64_t v8 = a3;
        a1 = (uint64_t)v3;
        int v9 = 11;
      }
      else
      {
        unint64_t v10 = a2[1].u64[0];
        int v11 = v3[4].u8[0];
        unint64_t v12 = bswap64(v10);
        if (v3[4].i8[0]) {
          unint64_t v10 = v12;
        }
        v3[10].i64[0] = v10;
        if ((v10 & 7) == 0)
        {
          BOOL v13 = v11 == 0;
          int32x2_t v14 = vdup_n_s32(v11 == 0);
          v15.i64[0] = v14.u32[0];
          v15.i64[1] = v14.u32[1];
          v3[5] = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v15, 0x3FuLL)), a2[4], vrev64q_s8(a2[4]));
          unint64_t v16 = bswap64(a2[1].u64[1]);
          if (v11) {
            unint64_t v17 = v16;
          }
          else {
            unint64_t v17 = a2[1].u64[1];
          }
          unint64_t v18 = bswap64(a2[2].u64[0]);
          if (v13) {
            unint64_t v19 = a2[2].u64[0];
          }
          else {
            unint64_t v19 = v18;
          }
          unint64_t v20 = bswap64(a2[2].u64[1]);
          if (v13) {
            unint64_t v21 = a2[2].u64[1];
          }
          else {
            unint64_t v21 = v20;
          }
          int v22 = (*(uint64_t (**)(int8x16_t *))(v3->i64[0] + 72))(v3);
          char v23 = 3;
          if (v22) {
            char v23 = 0;
          }
          unint64_t v24 = v21 << v23;
          unint64_t v25 = bswap64(a2[3].u64[0]);
          if (!v3[4].i8[0]) {
            unint64_t v25 = a2[3].u64[0];
          }
          unint64_t v26 = bswap64(a2[3].u64[1]);
          if (v3[4].i8[0]) {
            unint64_t v27 = v26;
          }
          else {
            unint64_t v27 = a2[3].u64[1];
          }
          unint64_t v28 = a2[5].u64[0];
          int v29 = bswap64(v28);
          if (v3[4].i8[0]) {
            LODWORD(v28) = v29;
          }
          v3[9].i32[2] = v28;
          uint64_t v30 = v3[10].i64[0];
          uint64_t v31 = v30 + 88;
          uint64_t v32 = v19 + 48 * v17 + v30 + 88;
          unint64_t v33 = v25 + v24 + v32;
          int v34 = &a2->i8[(-(int)v27 & 7) + v27 + v33];
          unint64_t v35 = *(void *)(v3[3].i64[0] + 16);
          if ((unint64_t)v34 <= v35)
          {
            uint64_t v36 = v3[3].i64[1];
            if (v36)
            {
              uint64_t v38 = *(void *)(v36 + 72);
              uint64_t v39 = *(void *)(v36 + 80) - v38;
              if (!v39) {
                uint64_t v38 = 0;
              }
              v3[6].i64[0] = v38;
              v3[6].i64[1] = v38 + v39;
              uint64_t v40 = (void *)(v36 + 16);
              if (*(char *)(v36 + 39) < 0) {
                uint64_t v40 = (void *)*v40;
              }
              v3[8].i64[0] = (uint64_t)v40;
              if (*(char *)(v36 + 39) < 0) {
                uint64_t v41 = *(void *)(v36 + 24);
              }
              else {
                uint64_t v41 = *(unsigned __int8 *)(v36 + 39);
              }
              uint64_t v37 = (char *)v40 + v41;
            }
            else
            {
              v3[6].i64[0] = (uint64_t)a2->i64 + v31;
              v3[6].i64[1] = (uint64_t)a2[3 * v17].i64 + v31;
              v3[8].i64[0] = (uint64_t)a2->i64 + v33;
              uint64_t v37 = &a2->i8[v33 + v27];
            }
            v3[10].i64[1] = (uint64_t)&a2[5].i64[1];
            uint64_t v42 = &a2->i8[v32];
            v3[7].i64[0] = (uint64_t)v42;
            v3[7].i64[1] = (uint64_t)&v42[v24];
            v3[8].i64[1] = (uint64_t)v37;
            v3[9].i64[0] = (uint64_t)v34;
            if ((unint64_t)&a2[5].u64[1] + v30 <= v35) {
              operator new();
            }
          }
        }
        *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
        __p.__r_.__value_.__s.__data_[0] = 0;
        unint64_t v8 = a3;
        a1 = (uint64_t)v3;
        int v9 = 4;
      }
    }
    else
    {
      *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
      __p.__r_.__value_.__s.__data_[0] = 0;
      unint64_t v8 = a3;
      a1 = (uint64_t)v3;
      int v9 = 10;
    }
  }
  else
  {
    *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
    __p.__r_.__value_.__s.__data_[0] = 0;
    unint64_t v8 = a3;
    int v9 = 5;
  }
  sub_1CD74DA30(&__p, a1, v9, v8);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void llvm::RawInstrProfReader<unsigned long long>::readNextRecord(uint64_t a1, void *a2)
{
  unint64_t v4 = *(unint64_t **)(a1 + 96);
  if (v4 == *(unint64_t **)(a1 + 104)) {
    llvm::RawInstrProfReader<unsigned long long>::readNextHeader();
  }
  unint64_t v5 = *v4;
  uint64_t v6 = *(void *)(a1 + 40);
  unint64_t v7 = bswap64(v5);
  if (*(unsigned char *)(a1 + 64)) {
    unint64_t v8 = v7;
  }
  else {
    unint64_t v8 = v5;
  }
  sub_1CD5DF87C(*(uint64_t **)(a1 + 40));
  int v9 = *(void **)(v6 + 56);
  unint64_t v10 = *(void **)(v6 + 64);
  if (v10 != v9)
  {
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * (v10 - v9);
    do
    {
      unint64_t v12 = v11 >> 1;
      BOOL v13 = &v9[3 * (v11 >> 1)];
      unint64_t v15 = *v13;
      int32x2_t v14 = v13 + 3;
      v11 += ~(v11 >> 1);
      if (v15 < v8) {
        int v9 = v14;
      }
      else {
        unint64_t v11 = v12;
      }
    }
    while (v11);
  }
  if (v9 == v10 || *v9 != v8)
  {
    uint64_t v16 = 0;
    uint64_t v17 = 0;
  }
  else
  {
    uint64_t v17 = v9[1];
    uint64_t v16 = v9[2];
  }
  a2[4] = v17;
  a2[5] = v16;
  sub_1CD74DADC(a1, &v20);
  if (!v20)
  {
    unint64_t v18 = *(void *)(*(void *)(a1 + 96) + 8);
    unint64_t v19 = bswap64(v18);
    if (*(unsigned char *)(a1 + 64)) {
      unint64_t v18 = v19;
    }
    a2[6] = v18;
    sub_1CD74DADC(a1, &v20);
    if (!v20) {
      llvm::RawInstrProfReader<unsigned long long>::readRawCounts();
    }
  }
  sub_1CD74DB30(a1, &v20);
}

BOOL llvm::RawInstrProfReader<unsigned long long>::atEnd(uint64_t a1)
{
  return *(void *)(a1 + 96) == *(void *)(a1 + 104);
}

void llvm::RawInstrProfReader<unsigned long long>::readNextHeader(uint64_t a1, void *a2)
{
  unint64_t v2 = *(void *)(*(void *)(a1 + 48) + 16);
  if ((void *)v2 != a2)
  {
    char v3 = (char)a2;
    do
    {
      if (*(unsigned char *)a2)
      {
        if ((unint64_t)(a2 + 11) > v2) {
          operator new();
        }
        if ((v3 & 7) != 0) {
          operator new();
        }
        unint64_t v4 = 0x8172666F72706CFFLL;
        if (!*(unsigned char *)(a1 + 64)) {
          unint64_t v4 = 0xFF6C70726F667281;
        }
        if (*a2 == v4)
        {
          llvm::RawInstrProfReader<unsigned long long>::readHeader();
        }
        operator new();
      }
      a2 = (void *)((char *)a2 + 1);
      ++v3;
    }
    while (a2 != (void *)v2);
  }
  operator new();
}

uint64_t llvm::RawInstrProfReader<unsigned long long>::getNextHeaderPos(uint64_t a1)
{
  return *(void *)(a1 + 144);
}

void llvm::RawInstrProfReader<unsigned long long>::readName(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = *(void *)(a1 + 40);
  unint64_t v7 = bswap64(**(void **)(a1 + 96));
  if (*(unsigned char *)(a1 + 64)) {
    unint64_t v8 = v7;
  }
  else {
    unint64_t v8 = **(void **)(a1 + 96);
  }
  sub_1CD5DF87C(*(uint64_t **)(a1 + 40));
  int v9 = *(void **)(v6 + 56);
  unint64_t v10 = *(void **)(v6 + 64);
  if (v10 != v9)
  {
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * (v10 - v9);
    do
    {
      unint64_t v12 = v11 >> 1;
      BOOL v13 = &v9[3 * (v11 >> 1)];
      unint64_t v15 = *v13;
      int32x2_t v14 = v13 + 3;
      v11 += ~(v11 >> 1);
      if (v15 < v8) {
        int v9 = v14;
      }
      else {
        unint64_t v11 = v12;
      }
    }
    while (v11);
  }
  if (v9 == v10 || *v9 != v8)
  {
    uint64_t v16 = 0;
    uint64_t v17 = 0;
  }
  else
  {
    uint64_t v17 = v9[1];
    uint64_t v16 = v9[2];
  }
  *(void *)(a2 + 32) = v17;
  *(void *)(a2 + 40) = v16;

  sub_1CD74DADC(a1, a3);
}

void llvm::RawInstrProfReader<unsigned long long>::readFuncHash(uint64_t a1@<X0>, void *a2@<X8>, uint64_t a3@<X1>)
{
  unint64_t v3 = *(void *)(*(void *)(a1 + 96) + 8);
  unint64_t v4 = bswap64(v3);
  if (*(unsigned char *)(a1 + 64)) {
    unint64_t v3 = v4;
  }
  *(void *)(a3 + 48) = v3;
  sub_1CD74DADC(a1, a2);
}

void llvm::RawInstrProfReader<unsigned long long>::readRawCounts(uint64_t a1@<X0>, char **a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 96);
  unsigned int v6 = *(_DWORD *)(v5 + 40);
  unsigned int v7 = bswap32(v6);
  if (*(unsigned char *)(a1 + 64)) {
    unint64_t v8 = v7;
  }
  else {
    unint64_t v8 = v6;
  }
  if (!v8)
  {
    __str.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x20uLL);
    *(_OWORD *)&__str.__r_.__value_.__r.__words[1] = xmmword_1CD96DBE0;
    strcpy(__str.__r_.__value_.__l.__data_, "number of counters is zero");
    sub_1CD74DA30(&__str, a1, 9, a3);
    if ((SHIBYTE(__str.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
    int v9 = (void *)__str.__r_.__value_.__r.__words[0];
    goto LABEL_20;
  }
  unint64_t v10 = *(void *)(v5 + 16);
  unint64_t v11 = bswap64(v10);
  if (*(unsigned char *)(a1 + 64)) {
    unint64_t v10 = v11;
  }
  uint64_t v12 = v10 - *(void *)(a1 + 80);
  v52[0] = v12;
  if (v12 < 0)
  {
    v47[0] = "counter offset ";
    __int16 v48 = (const char *)v52;
    __int16 v49 = 2819;
    __str.__r_.__value_.__r.__words[0] = (std::string::size_type)v47;
    __str.__r_.__value_.__r.__words[2] = (std::string::size_type)" is negative";
    __int16 v51 = 770;
    llvm::Twine::str((llvm::Twine *)&__str, &v44);
    sub_1CD74DA30(&v44, a1, 9, a3);
    if ((SHIBYTE(v44.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
    int v9 = (void *)v44.__r_.__value_.__r.__words[0];
    goto LABEL_20;
  }
  uint64_t v14 = *(void *)(a1 + 112);
  uint64_t v13 = *(void *)(a1 + 120);
  if (v12 >= v13 - v14)
  {
    v44.__r_.__value_.__r.__words[0] = (std::string::size_type)"counter offset ";
    v44.__r_.__value_.__r.__words[2] = (std::string::size_type)v52;
    __int16 v45 = 2819;
    v47[0] = &v44;
    __int16 v48 = " is greater than the maximum counter offset ";
    __int16 v49 = 770;
    uint64_t v43 = ~v14 + v13;
    __str.__r_.__value_.__r.__words[0] = (std::string::size_type)v47;
    __str.__r_.__value_.__r.__words[2] = (std::string::size_type)&v43;
    __int16 v19 = 2818;
    goto LABEL_18;
  }
  uint64_t v16 = v13 - v14 - v12;
  int v17 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 72))(a1);
  uint64_t v18 = 8;
  if (v17) {
    uint64_t v18 = 1;
  }
  uint64_t v43 = v16 / v18;
  if (v16 / v18 >= (unint64_t)v8)
  {
    uint64_t v42 = a3;
    a2[1] = *a2;
    sub_1CBF7ACFC((uint64_t)a2, v8);
    int v20 = 0;
    while (1)
    {
      uint64_t v21 = *(void *)(a1 + 112) + v12;
      if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 72))(a1)) {
        char v22 = 0;
      }
      else {
        char v22 = 3;
      }
      uint64_t v23 = (v20 << v22);
      if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 72))(a1))
      {
        unint64_t v24 = *(unsigned char *)(v21 + v23) == 0;
        unint64_t v26 = (unint64_t *)a2[1];
        unint64_t v25 = (unint64_t)a2[2];
        if ((unint64_t)v26 >= v25)
        {
          unint64_t v27 = (unint64_t *)*a2;
          uint64_t v28 = ((char *)v26 - *a2) >> 3;
          unint64_t v29 = v28 + 1;
          if ((unint64_t)(v28 + 1) >> 61) {
            goto LABEL_63;
          }
          uint64_t v30 = v25 - (void)v27;
          if (v30 >> 2 > v29) {
            unint64_t v29 = v30 >> 2;
          }
          if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v31 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v31 = v29;
          }
          if (v31)
          {
            if (v31 >> 61) {
              goto LABEL_64;
            }
            uint64_t v32 = (char *)operator new(8 * v31);
          }
          else
          {
            uint64_t v32 = 0;
          }
          uint64_t v39 = &v32[8 * v28];
          *(void *)uint64_t v39 = v24;
          unint64_t v35 = v39 + 8;
          while (v26 != v27)
          {
            uint64_t v40 = *--v26;
            *((void *)v39 - sub_1CD7485C0(this + 1) = v40;
            v39 -= 8;
          }
LABEL_59:
          *a2 = v39;
          a2[1] = v35;
          a2[2] = &v32[8 * v31];
          if (v27) {
            operator delete(v27);
          }
          goto LABEL_61;
        }
      }
      else
      {
        unint64_t v33 = bswap64(*(void *)(v21 + v23));
        if (*(unsigned char *)(a1 + 64)) {
          unint64_t v24 = v33;
        }
        else {
          unint64_t v24 = *(void *)(v21 + v23);
        }
        unint64_t v26 = (unint64_t *)a2[1];
        unint64_t v34 = (unint64_t)a2[2];
        if ((unint64_t)v26 >= v34)
        {
          unint64_t v27 = (unint64_t *)*a2;
          uint64_t v36 = ((char *)v26 - *a2) >> 3;
          unint64_t v37 = v36 + 1;
          if ((unint64_t)(v36 + 1) >> 61) {
LABEL_63:
          }
            abort();
          uint64_t v38 = v34 - (void)v27;
          if (v38 >> 2 > v37) {
            unint64_t v37 = v38 >> 2;
          }
          if ((unint64_t)v38 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v31 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v31 = v37;
          }
          if (v31)
          {
            if (v31 >> 61) {
LABEL_64:
            }
              sub_1CB833614();
            uint64_t v32 = (char *)operator new(8 * v31);
          }
          else
          {
            uint64_t v32 = 0;
          }
          uint64_t v39 = &v32[8 * v36];
          *(void *)uint64_t v39 = v24;
          unint64_t v35 = v39 + 8;
          while (v26 != v27)
          {
            uint64_t v41 = *--v26;
            *((void *)v39 - sub_1CD7485C0(this + 1) = v41;
            v39 -= 8;
          }
          goto LABEL_59;
        }
      }
      *unint64_t v26 = v24;
      unint64_t v35 = (char *)(v26 + 1);
LABEL_61:
      a2[1] = v35;
      if (++v20 == v8)
      {
        sub_1CD74DADC(a1, v42);
        return;
      }
    }
  }
  v44.__r_.__value_.__r.__words[0] = (std::string::size_type)"number of counters ";
  v44.__r_.__value_.__r.__words[2] = v8;
  __int16 v45 = 2051;
  v47[0] = &v44;
  __int16 v48 = " is greater than the maximum number of counters ";
  __int16 v49 = 770;
  __str.__r_.__value_.__r.__words[0] = (std::string::size_type)v47;
  __str.__r_.__value_.__r.__words[2] = (std::string::size_type)&v43;
  __int16 v19 = 3074;
LABEL_18:
  __int16 v51 = v19;
  llvm::Twine::str((llvm::Twine *)&__str, &__p);
  sub_1CD74DA30(&__p, a1, 9, a3);
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    return;
  }
  int v9 = (void *)__p.__r_.__value_.__r.__words[0];
LABEL_20:
  operator delete(v9);
}

void llvm::RawInstrProfReader<unsigned long long>::readValueProfilingData(uint64_t a1@<X0>, llvm::InstrProfRecord *a2@<X1>, llvm::ValueProfData **a3@<X8>)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  unsigned int v6 = (void **)*((void *)a2 + 3);
  *((void *)a2 + 3) = 0;
  if (v6)
  {
    unsigned int v7 = sub_1CD698204(v6);
    MEMORY[0x1D25D9CE0](v7, 0x20C40A759441BLL);
  }
  uint64_t v8 = 0;
  int v9 = 0;
  *(_DWORD *)(a1 + 156) = 0;
  char v10 = 1;
  do
  {
    char v11 = v10;
    if (*(_WORD *)(*(void *)(a1 + 96) + 2 * v8 + 44)) {
      ++v9;
    }
    uint64_t v8 = 1;
    char v10 = 0;
  }
  while ((v11 & 1) != 0);
  if (v9)
  {
    llvm::ValueProfData::getValueProfData(*(unsigned int **)(a1 + 144), *(void *)(*(void *)(a1 + 48) + 16), *(unsigned char *)(a1 + 64) == 0, (uint64_t)&v16);
    char v12 = v17;
    if (v17)
    {
      uint64_t v13 = v16;
      *a3 = v16;
      if (v13) {
        return;
      }
      uint64_t v14 = 0;
    }
    else
    {
      *a3 = 0;
      uint64_t v14 = v16;
    }
    llvm::ValueProfData::deserializeTo(v14, a2, *(llvm::InstrProfSymtab **)(a1 + 40));
    *(_DWORD *)(a1 + 156) = *(_DWORD *)v14;
    sub_1CD74DADC(a1, a3);
    if (v12)
    {
      unint64_t v15 = *(void (**)(llvm::ValueProfData *))(*(void *)v14 + 8);
      v15(v14);
    }
    else
    {
      operator delete(v14);
    }
  }
  else
  {
    sub_1CD74DADC(a1, a3);
  }
}

uint64_t llvm::RawInstrProfReader<unsigned long long>::advanceData(uint64_t result)
{
  if (!*(void *)(result + 56)) {
    *(void *)(result + 80) -= 48;
  }
  *(void *)(result + 96) += 48;
  *(void *)(result + 144) += *(unsigned int *)(result + 156);
  return result;
}

void llvm::RawInstrProfReader<unsigned long long>::printBinaryIds(llvm::raw_ostream *this@<X1>, uint64_t a2@<X0>, void *a3@<X8>)
{
  if (*(void *)(a2 + 160))
  {
    uint64_t v5 = (void *)*((void *)this + 4);
    if (*((void *)this + 3) - (void)v5 > 0xCuLL)
    {
      qmemcpy(v5, "Binary IDs: \n", 13);
      *((void *)this + 4) += 13;
    }
    else
    {
      llvm::raw_ostream::write(this, "Binary IDs: \n", 0xDuLL);
    }
    unsigned int v6 = *(unint64_t **)(a2 + 168);
    unsigned int v7 = (unint64_t *)((char *)v6 + *(void *)(a2 + 160));
    while (v6 < v7)
    {
      if ((unint64_t)((char *)v7 - (char *)v6) <= 7) {
        operator new();
      }
      unint64_t v8 = bswap64(*v6);
      if (*(unsigned char *)(a2 + 64)) {
        unint64_t v9 = v8;
      }
      else {
        unint64_t v9 = *v6;
      }
      if ((char *)v7 - (char *)v6 < v9 + 8) {
        operator new();
      }
      char v10 = v6 + 1;
      if ((unint64_t)(v6 + 1) > *(void *)(*(void *)(a2 + 48) + 16)) {
        operator new();
      }
      if (v9)
      {
        char v11 = (unsigned __int8 *)(v6 + 1);
        unint64_t v12 = v9;
        do
        {
          v16[0] = &unk_1F260ED30;
          unsigned int v13 = *v11++;
          v16[1] = "%02x";
          void v16[2] = v13;
          llvm::raw_ostream::operator<<(this, (uint64_t)v16);
          --v12;
        }
        while (v12);
      }
      uint64_t v14 = (unsigned char *)*((void *)this + 4);
      if (*((unsigned char **)this + 3) == v14)
      {
        llvm::raw_ostream::write(this, "\n", 1uLL);
      }
      else
      {
        *uint64_t v14 = 10;
        ++*((void *)this + 4);
      }
      unsigned int v6 = (unint64_t *)((char *)v10 + ((v9 + 7) & 0xFFFFFFFFFFFFFFF8));
      if ((unint64_t)v6 > *(void *)(*(void *)(a2 + 48) + 16)) {
        operator new();
      }
    }
    sub_1CD74DADC(a2, a3);
  }
  else
  {
    sub_1CD74DADC(a2, a3);
  }
}

uint64_t llvm::RawInstrProfReader<unsigned long long>::isIRLevelProfile(uint64_t a1)
{
  return *(unsigned char *)(a1 + 79) & 1;
}

uint64_t llvm::RawInstrProfReader<unsigned long long>::hasCSIRLevelProfile(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 79) >> 1) & 1;
}

uint64_t llvm::RawInstrProfReader<unsigned long long>::instrEntryBBEnabled(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 79) >> 2) & 1;
}

uint64_t llvm::RawInstrProfReader<unsigned long long>::useDebugInfoCorrelate(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 79) >> 3) & 1;
}

uint64_t llvm::RawInstrProfReader<unsigned long long>::hasSingleByteCoverage(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 79) >> 4) & 1;
}

uint64_t llvm::RawInstrProfReader<unsigned long long>::functionEntryOnly(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 79) >> 5) & 1;
}

uint64_t llvm::RawInstrProfReader<unsigned long long>::getProfileKind(uint64_t a1)
{
  return (*(void *)(a1 + 72) >> 54) & 8 | (*(void *)(a1 + 72) >> 55) & 2 | HIBYTE(*(void *)(a1 + 72)) & 0x74;
}

uint64_t llvm::RawInstrProfReader<unsigned long long>::getSymtab(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

void llvm::RawInstrProfReader<unsigned long long>::createSymtab(uint64_t a1@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  llvm::readPGOFuncNameStrings(*(char **)(a1 + 128), *(void *)(a1 + 136) - *(void *)(a1 + 128), (uint64_t)a2, &v23);
  if (v23) {
    sub_1CD74DB30(a1, &v23);
  }
  char v22 = a3;
  unsigned int v7 = *(unint64_t **)(a1 + 96);
  for (uint64_t i = *(unint64_t **)(a1 + 104); v7 != i; v7 += 6)
  {
    unint64_t v8 = bswap64(v7[3]);
    if (*(unsigned char *)(a1 + 64)) {
      unint64_t v9 = v8;
    }
    else {
      unint64_t v9 = v7[3];
    }
    if (v9)
    {
      unint64_t v10 = *v7;
      unint64_t v12 = (unint64_t *)a2[14];
      unint64_t v11 = a2[15];
      if ((unint64_t)v12 >= v11)
      {
        uint64_t v14 = (char *)a2[13];
        uint64_t v15 = ((char *)v12 - v14) >> 4;
        unint64_t v16 = v15 + 1;
        if ((unint64_t)(v15 + 1) >> 60) {
          abort();
        }
        uint64_t v17 = v11 - (void)v14;
        if (v17 >> 3 > v16) {
          unint64_t v16 = v17 >> 3;
        }
        if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v18 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v18 = v16;
        }
        if (v18)
        {
          if (v18 >> 60) {
            sub_1CB833614();
          }
          __int16 v19 = (char *)operator new(16 * v18);
        }
        else
        {
          __int16 v19 = 0;
        }
        int v20 = (unint64_t *)&v19[16 * v15];
        *int v20 = v9;
        v20[1] = v10;
        uint64_t v21 = v20;
        if (v12 != (unint64_t *)v14)
        {
          do
          {
            *((_OWORD *)v21 - sub_1CD7485C0(this + 1) = *((_OWORD *)v12 - 1);
            v21 -= 2;
            v12 -= 2;
          }
          while (v12 != (unint64_t *)v14);
          unint64_t v12 = (unint64_t *)a2[13];
        }
        unsigned int v13 = v20 + 2;
        a2[13] = v21;
        a2[14] = v20 + 2;
        a2[15] = &v19[16 * v18];
        if (v12) {
          operator delete(v12);
        }
      }
      else
      {
        *unint64_t v12 = v9;
        v12[1] = v10;
        unsigned int v13 = v12 + 2;
      }
      a2[14] = v13;
      uint64_t i = *(unint64_t **)(a1 + 104);
    }
  }
  sub_1CD74DADC(a1, v22);
}

uint64_t llvm::RawInstrProfReader<unsigned long long>::getCounterTypeSize(uint64_t a1)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 72))(a1)) {
    return 1;
  }
  else {
    return 8;
  }
}

uint64_t llvm::RawInstrProfReader<unsigned long long>::getNumPaddingBytes(uint64_t a1, int a2)
{
  return -a2 & 7;
}

BOOL llvm::RawInstrProfReader<unsigned long long>::getDataEndianness(uint64_t a1)
{
  return *(unsigned char *)(a1 + 64) == 0;
}

uint64_t llvm::RawInstrProfReader<unsigned long long>::getName(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  unint64_t v3 = bswap64(a2);
  if (*(unsigned char *)(a1 + 64)) {
    unint64_t v4 = v3;
  }
  else {
    unint64_t v4 = a2;
  }
  sub_1CD5DF87C(*(uint64_t **)(a1 + 40));
  uint64_t v5 = *(void **)(v2 + 56);
  unsigned int v6 = *(void **)(v2 + 64);
  if (v6 != v5)
  {
    unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * (v6 - v5);
    do
    {
      unint64_t v8 = v7 >> 1;
      unint64_t v9 = &v5[3 * (v7 >> 1)];
      unint64_t v11 = *v9;
      unint64_t v10 = v9 + 3;
      v7 += ~(v7 >> 1);
      if (v11 < v4) {
        uint64_t v5 = v10;
      }
      else {
        unint64_t v7 = v8;
      }
    }
    while (v7);
  }
  if (v5 == v6 || *v5 != v4) {
    return 0;
  }
  else {
    return v5[1];
  }
}

uint64_t llvm::InstrProfLookupTrait::ComputeHash(uint64_t a1, int *a2, size_t a3)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  long long v5 = xmmword_1CFAC4320;
  uint64_t v6 = 0;
  llvm::MD5::update((int *)&v5, a2, a3);
  llvm::MD5::final((int *)&v5, v4);
  return *(void *)v4;
}

void llvm::IndexedInstrProfReader::readSummary(uint64_t a1, int a2, _DWORD *a3)
{
  if (a2 >= 4)
  {
    size_t v4 = (24 * a3[2] + 8 * *a3 + 16);
    long long v5 = operator new(v4);
    bzero(v5, v4);
    if (v4)
    {
      uint64_t v6 = v4 >> 3;
      if (v4 >> 3 <= 1) {
        uint64_t v6 = 1;
      }
      memcpy(v5, a3, 8 * v6);
    }
    unint64_t v7 = v5[1];
    if (v7)
    {
      uint64_t v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      unint64_t v11 = 0;
      unint64_t v12 = 0;
      do
      {
        unsigned int v13 = &v5[3 * v8 + 2 + *v5];
        int v16 = *v13;
        uint64_t v14 = v13 + 2;
        int v15 = v16;
        if (v12 >= v10)
        {
          unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((v12 - v11) >> 3) + 1;
          if (v17 > 0xAAAAAAAAAAAAAAALL) {
            abort();
          }
          if (0x5555555555555556 * ((v10 - v11) >> 3) > v17) {
            unint64_t v17 = 0x5555555555555556 * ((v10 - v11) >> 3);
          }
          if (0xAAAAAAAAAAAAAAABLL * ((v10 - v11) >> 3) >= 0x555555555555555) {
            unint64_t v17 = 0xAAAAAAAAAAAAAAALL;
          }
          if (v17 > 0xAAAAAAAAAAAAAAALL) {
            sub_1CB833614();
          }
          uint64_t v18 = 3 * v17;
          __int16 v19 = (char *)operator new(24 * v17);
          int v20 = &v19[8 * ((v12 - v11) >> 3)];
          *(_DWORD *)int v20 = v15;
          *(_OWORD *)(v20 + 8) = *v14;
          if (v12 == v11)
          {
            char v22 = &v19[8 * ((v12 - v11) >> 3)];
          }
          else
          {
            uint64_t v21 = &v19[8 * ((v12 - v11) >> 3)];
            do
            {
              char v22 = v21 - 24;
              long long v23 = *(_OWORD *)(v12 - 24);
              *((void *)v21 - sub_1CD7485C0(this + 1) = *((void *)v12 - 1);
              *(_OWORD *)(v21 - 24) = v23;
              v12 -= 24;
              v21 -= 24;
            }
            while (v12 != v11);
          }
          unint64_t v10 = &v19[8 * v18];
          unint64_t v12 = v20 + 24;
          if (v11)
          {
            operator delete(v11);
            unint64_t v7 = v5[1];
          }
          unint64_t v11 = v22;
        }
        else
        {
          *(_DWORD *)unint64_t v12 = v15;
          *(_OWORD *)(v12 + 8) = *v14;
          v12 += 24;
        }
        uint64_t v8 = ++v9;
      }
      while (v7 > v9);
    }
    operator new();
  }
  unint64_t v24 = operator new(0x40uLL);
  *unint64_t v24 = xmmword_1CFB2C580;
  v24[1] = unk_1CFB2C590;
  _OWORD v24[2] = xmmword_1CFB2C5A0;
  v24[3] = unk_1CFB2C5B0;
  unint64_t v25 = v26;
  v26[0] = 0;
  v26[1] = 0;
  void v26[2] = v24;
  v26[3] = v24 + 4;
  void v26[4] = v24 + 4;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  llvm::InstrProfSummaryBuilder::getSummary((llvm::InstrProfSummaryBuilder *)&v25);
}

uint64_t llvm::IndexedInstrProfReader::getSymtab(llvm::IndexedInstrProfReader *this)
{
  if (!*((void *)this + 5)) {
    operator new();
  }
  return *((void *)this + 5);
}

char **llvm::IndexedInstrProfReader::getMemProfRecord@<X0>(llvm::IndexedInstrProfReader *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v29[8] = *MEMORY[0x1E4F143B8];
  uint64_t v22 = a2;
  size_t v4 = (void *)*((void *)this + 34);
  if (!v4) {
    operator new();
  }
  uint64_t v5 = *(void *)(v4[2] + 8 * ((*v4 - 1) & a2));
  if (!v5 || (uint64_t v6 = (_WORD *)(v4[3] + v5), v7 = (unsigned __int16)*v6, !*v6))
  {
LABEL_8:
    long long v23 = "memprof record not found for hash ";
    unint64_t v25 = &v22;
    __int16 v26 = 3075;
    operator new();
  }
  uint64_t v8 = (uint64_t *)(v6 + 1);
  while (1)
  {
    uint64_t v10 = *v8;
    uint64_t v9 = v8[1];
    uint64_t v11 = v8[2];
    unint64_t v12 = v8 + 3;
    if (v10 == a2 && *v12 == a2) {
      break;
    }
    uint64_t v8 = (void *)((char *)v12 + v11 + v9);
    if (!--v7) {
      goto LABEL_8;
    }
  }
  uint64_t v21 = 0;
  char v20 = 0;
  v19[0] = this;
  v19[1] = &v21;
  void v19[2] = &v20;
  llvm::memprof::IndexedMemProfRecord::deserialize((uint64_t)(v4 + 4), (void *)((char *)v12 + v9), (uint64_t)&v23);
  uint64_t v13 = (uint64_t)(v4 + 26);
  sub_1CCCE8890((uint64_t)(v4 + 26), (uint64_t)&v23);
  sub_1CCCE8BEC((uint64_t)(v4 + 49), (uint64_t)&v27);
  uint64_t v14 = (char *)v27;
  if (v28)
  {
    unint64_t v15 = (unint64_t)v28 << 6;
    do
    {
      int v16 = *(char **)&v14[v15 - 64];
      if (&v14[v15 - 48] != v16) {
        free(v16);
      }
      v15 -= 64;
    }
    while (v15);
    uint64_t v14 = (char *)v27;
  }
  if (v14 != (char *)v29) {
    free(v14);
  }
  sub_1CD74EA50(&v23);
  sub_1CCCE7108(&v23, v13, (void (*)(void *__return_ptr, uint64_t, uint64_t))sub_1CCCE8EA0, (uint64_t)v19);
  if (v20) {
    operator new();
  }
  *(unsigned char *)(a3 + 264) &= ~1u;
  *(void *)a3 = a3 + 16;
  *(void *)(a3 + 8) = 0x100000000;
  if (v24) {
    sub_1CCCE8F44(a3, (uint64_t)&v23);
  }
  *(void *)(a3 + 184) = a3 + 200;
  uint64_t v17 = a3 + 184;
  *(void *)(v17 + 8) = 0x100000000;
  if (v28) {
    sub_1CCCE92C8(v17, (uint64_t)&v27);
  }
  sub_1CD4D68AC((char **)&v27);
  return sub_1CD74EA50(&v23);
}

uint64_t llvm::IndexedInstrProfReader::getFunctionCounts@<X0>(uint64_t a1@<X0>, uint64_t a2@<X3>, char **a3@<X4>, void *a4@<X8>)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  llvm::IndexedInstrProfReader::getInstrProfRecord(a1, a2, (uint64_t)&v9);
  if (v11)
  {
    uint64_t v8 = v9;
    uint64_t v9 = 0;
    if (v8) {
      sub_1CD74DB30(a1, &v8);
    }
  }
  if (&v9 != a3) {
    sub_1CBFAFDE4(a3, v9, v10, (v10 - v9) >> 3);
  }
  sub_1CD74DADC(a1, a4);
  return sub_1CCB496A4((uint64_t)&v9);
}

uint64_t llvm::InstrProfReader::accumulateCounts(uint64_t a1, void *a2, int a3)
{
  uint64_t v9 = a1;
  memset(v10, 0, sizeof(v10));
  sub_1CCCE80B8((uint64_t)&v9);
  memset(v8, 0, sizeof(v8));
  if (v9)
  {
    uint64_t v6 = 0;
    do
    {
      if (!(*(unsigned int (**)(uint64_t))(*(void *)a1 + 40))(a1)
        || a3 == (v11 & 0x10) >> 4)
      {
        llvm::InstrProfRecord::accumulateCounts((uint64_t)v10, (uint64_t)a2);
        ++v6;
      }
      sub_1CCCE80B8((uint64_t)&v9);
    }
    while (v9);
  }
  else
  {
    uint64_t v6 = 0;
  }
  sub_1CD69825C((uint64_t)v8 + 8);
  uint64_t result = sub_1CD69825C((uint64_t)v10);
  *a2 = v6;
  return result;
}

uint64_t sub_1CCCE6B90(void *a1)
{
  *a1 = &unk_1F263C598;
  uint64_t v2 = a1[6];
  a1[6] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }

  return sub_1CD74ECAC((uint64_t)a1);
}

void sub_1CCCE6C10(void *a1)
{
  *a1 = &unk_1F263C598;
  uint64_t v2 = a1[6];
  a1[6] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  sub_1CD74ECAC((uint64_t)a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CCCE6CA4(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 120) >> 1) & 1;
}

uint64_t sub_1CCCE6CB0(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 120) >> 3) & 1;
}

uint64_t sub_1CCCE6CBC(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 120) >> 2) & 1;
}

uint64_t sub_1CCCE6CC8(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 120) >> 4) & 1;
}

uint64_t sub_1CCCE6CD4(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 120) >> 5) & 1;
}

uint64_t sub_1CCCE6CE0(uint64_t a1)
{
  return *(unsigned int *)(a1 + 120);
}

uint64_t sub_1CCCE6CE8(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

uint64_t sub_1CCCE6CF0(void *a1)
{
  *a1 = &unk_1F263C4A8;
  uint64_t v2 = a1[6];
  a1[6] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }

  return sub_1CD74ECAC((uint64_t)a1);
}

void sub_1CCCE6D70(void *a1)
{
  *a1 = &unk_1F263C4A8;
  uint64_t v2 = a1[6];
  a1[6] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  sub_1CD74ECAC((uint64_t)a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CCCE6E04(void *a1)
{
  *a1 = &unk_1F263C520;
  uint64_t v2 = a1[6];
  a1[6] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }

  return sub_1CD74ECAC((uint64_t)a1);
}

void sub_1CCCE6E84(void *a1)
{
  *a1 = &unk_1F263C520;
  uint64_t v2 = a1[6];
  a1[6] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  sub_1CD74ECAC((uint64_t)a1);

  JUMPOUT(0x1D25D9CE0);
}

char **sub_1CCCE6F18(char **result, uint64_t *a2)
{
  uint64_t v2 = *result;
  llvm *result = 0;
  if (v2)
  {
    if ((*(unsigned int (**)(char *, void *))(*(void *)v2 + 48))(v2, &llvm::ErrorList::ID))
    {
      uint64_t v10 = 0;
      size_t v4 = (uint64_t *)*((void *)v2 + 1);
      uint64_t v5 = (uint64_t *)*((void *)v2 + 2);
      if (v4 != v5)
      {
        uint64_t v6 = 0;
        do
        {
          uint64_t v13 = v6;
          uint64_t v7 = *v4;
          *size_t v4 = 0;
          uint64_t v11 = v7;
          sub_1CD74E8F8(&v12, &v11, a2);
          sub_1CD451630(&v13, &v12, &v14);
          uint64_t v6 = v14;
          uint64_t v14 = 0;
          if (v12) {
            (*(void (**)(char *))(*(void *)v12 + 8))(v12);
          }
          uint64_t v8 = v11;
          uint64_t v11 = 0;
          if (v8) {
            (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
          }
          if (v13) {
            (*(void (**)(char *))(*(void *)v13 + 8))(v13);
          }
          ++v4;
        }
        while (v4 != v5);
        uint64_t v10 = v6;
      }
      return (char **)(*(uint64_t (**)(char *))(*(void *)v2 + 8))(v2);
    }
    else
    {
      uint64_t v14 = v2;
      sub_1CD74E8F8(&v10, &v14, a2);
      uint64_t result = (char **)v14;
      if (v14)
      {
        uint64_t v9 = *(uint64_t (**)(void))(*(void *)v14 + 8);
        return (char **)v9();
      }
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  return result;
}

void *sub_1CCCE7108(void *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t, uint64_t), uint64_t a4)
{
  void (*v22)(void *__return_ptr, uint64_t, uint64_t);
  uint64_t v23;
  void *v24;
  uint64_t v25;
  void v26[7];

  v26[6] = *MEMORY[0x1E4F143B8];
  uint64_t v22 = a3;
  long long v23 = a4;
  *a1 = a1 + 2;
  a1[1] = 0x100000000;
  a1[23] = a1 + 25;
  uint64_t v6 = (uint64_t)(a1 + 23);
  a1[24] = 0x100000000;
  unsigned int v7 = *(_DWORD *)(a2 + 8);
  if (v7)
  {
    uint64_t v8 = *(void *)a2;
    uint64_t v9 = 168 * v7;
    do
    {
      sub_1CCCE7294((uint64_t)a1, v8, (uint64_t)&v22);
      v8 += 168;
      v9 -= 168;
    }
    while (v9);
  }
  uint64_t v10 = *(unsigned int *)(a2 + 192);
  if (v10)
  {
    uint64_t v11 = *(void *)(a2 + 184);
    uint64_t v12 = v11 + (v10 << 6);
    do
    {
      uint64_t v13 = *(uint64_t **)v11;
      uint64_t v14 = *(unsigned int *)(v11 + 8);
      int v24 = v26;
      unint64_t v25 = 0x200000000;
      if (v14)
      {
        uint64_t v15 = 8 * v14;
        do
        {
          uint64_t v16 = *v13++;
          v22(v21, v23, v16);
          unint64_t v17 = sub_1CCCE7938((uint64_t)&v24, (unint64_t)v21, 1);
          int v18 = v25;
          __int16 v19 = (char *)v24 + 24 * v25;
          *(void *)__int16 v19 = *(void *)v17;
          *((void *)v19 + sub_1CD7485C0(this + 1) = *(void *)(v17 + 8);
          v19[16] = *(unsigned char *)(v17 + 16);
          LODWORD(v25) = v18 + 1;
          v15 -= 8;
        }
        while (v15);
      }
      sub_1CCCE7310(v6, (unint64_t)&v24);
      if (v24 != v26) {
        free(v24);
      }
      v11 += 64;
    }
    while (v11 != v12);
  }
  return a1;
}

uint64_t sub_1CCCE7294(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v4 = *(_DWORD *)(a1 + 8);
  if (v4 >= *(_DWORD *)(a1 + 12))
  {
    return sub_1CCCE73B8(a1, a2, a3);
  }
  else
  {
    sub_1CCCE7820(*(void *)a1 + 168 * v4, a2, *(void (**)(void *__return_ptr, uint64_t, uint64_t))a3, *(void *)(a3 + 8));
    unsigned int v5 = *(_DWORD *)(a1 + 8) + 1;
    *(_DWORD *)(a1 + 8) = v5;
    return *(void *)a1 + 168 * v5 - 168;
  }
}

void *sub_1CCCE7310(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 8);
  unint64_t v5 = *(void *)a1;
  if (v4 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v7 = v4 + 1;
    unint64_t v8 = v5 + (v4 << 6);
    if (v5 <= a2 && v8 > a2)
    {
      unint64_t v10 = a2 - v5;
      sub_1CCCE79A4(a1, v7);
      unint64_t v5 = *(void *)a1;
      a2 = *(void *)a1 + v10;
    }
    else
    {
      sub_1CCCE79A4(a1, v7);
      unint64_t v5 = *(void *)a1;
    }
  }
  uint64_t result = (void *)(v5 + ((unint64_t)*(unsigned int *)(a1 + 8) << 6));
  void *result = result + 2;
  result[1] = 0x200000000;
  if (*(_DWORD *)(a2 + 8)) {
    uint64_t result = (void *)sub_1CCCE7B08((uint64_t)result, (uint64_t *)a2);
  }
  ++*(_DWORD *)(a1 + 8);
  return result;
}

uint64_t sub_1CCCE73B8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(a1 + 12);
  if (v3 == -1) {
    sub_1CD0A89A8(0xFFFFFFFFuLL);
  }
  unint64_t v7 = (2 * v3) | 1;
  if (v7 >= 0xFFFFFFFF) {
    uint64_t v8 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v8 = v7;
  }
  uint64_t v9 = malloc_type_malloc(168 * v8, 0x4065EBACuLL);
  if (!v9) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  uint64_t v10 = (uint64_t)v9;
  sub_1CCCE7820((uint64_t)v9 + 168 * *(unsigned int *)(a1 + 8), a2, *(void (**)(void *__return_ptr, uint64_t, uint64_t))a3, *(void *)(a3 + 8));
  sub_1CCCE7494(a1, v10);
  if (*(void *)a1 != a1 + 16) {
    free(*(void **)a1);
  }
  *(void *)a1 = v10;
  unsigned int v11 = *(_DWORD *)(a1 + 8) + 1;
  *(_DWORD *)(a1 + 8) = v11;
  *(_DWORD *)(a1 + 12) = v8;
  return v10 + 168 * v11 - 168;
}

void sub_1CCCE7494(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2)
  {
    uint64_t v5 = *(void *)a1;
    uint64_t v6 = 168 * v2;
    do
    {
      *(void *)a2 = a2 + 16;
      *(void *)(a2 + 8) = 0x200000000;
      if (*(_DWORD *)(v5 + 8)) {
        sub_1CCCE7570(a2, v5);
      }
      long long v7 = *(_OWORD *)(v5 + 64);
      long long v8 = *(_OWORD *)(v5 + 96);
      *(_OWORD *)(a2 + 80) = *(_OWORD *)(v5 + 80);
      *(_OWORD *)(a2 + 96) = v8;
      *(_OWORD *)(a2 + 64) = v7;
      long long v9 = *(_OWORD *)(v5 + 112);
      long long v10 = *(_OWORD *)(v5 + 128);
      long long v11 = *(_OWORD *)(v5 + 144);
      *(void *)(a2 + 160) = *(void *)(v5 + 160);
      *(_OWORD *)(a2 + 128) = v10;
      *(_OWORD *)(a2 + 144) = v11;
      *(_OWORD *)(a2 + 112) = v9;
      v5 += 168;
      a2 += 168;
      v6 -= 168;
    }
    while (v6);
    unsigned int v12 = *(_DWORD *)(a1 + 8);
    if (v12)
    {
      uint64_t v13 = *(void *)a1;
      uint64_t v14 = 168 * v12;
      do
      {
        uint64_t v15 = *(void **)(v13 + v14 - 168);
        if ((void *)(v13 + v14 - 152) != v15) {
          free(v15);
        }
        v14 -= 168;
      }
      while (v14);
    }
  }
}

uint64_t sub_1CCCE7570(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(void *)a2;
    if (*(void *)a2 == a2 + 16)
    {
      unint64_t v5 = *(unsigned int *)(a2 + 8);
      uint64_t v6 = *(unsigned int *)(a1 + 8);
      if (v6 >= v5)
      {
        if (v5)
        {
          long long v9 = *(char **)a1;
          uint64_t v10 = v4 + 24 * v5;
          do
          {
            *(void *)long long v9 = *(void *)v4;
            *((void *)v9 + sub_1CD7485C0(this + 1) = *(void *)(v4 + 8);
            v9[16] = *(unsigned char *)(v4 + 16);
            v4 += 24;
            v9 += 24;
          }
          while (v4 != v10);
        }
      }
      else
      {
        if (*(_DWORD *)(a1 + 12) >= v5)
        {
          long long v8 = *(char **)a1;
          if (v6)
          {
            uint64_t v11 = 0;
            do
            {
              unsigned int v12 = &v8[v11];
              uint64_t v13 = v4 + v11;
              *(void *)unsigned int v12 = *(void *)(v4 + v11);
              *((void *)v12 + sub_1CD7485C0(this + 1) = *(void *)(v4 + v11 + 8);
              v12[16] = *(unsigned char *)(v4 + v11 + 16);
              v11 += 24;
            }
            while (v13 + 24 != v4 + 24 * v6);
          }
          else
          {
            uint64_t v6 = 0;
          }
          unint64_t v7 = v5;
        }
        else
        {
          *(_DWORD *)(a1 + 8) = 0;
          sub_1CCCE7730((char **)a1, v5);
          uint64_t v6 = 0;
          uint64_t v4 = *(void *)a2;
          unint64_t v7 = *(unsigned int *)(a2 + 8);
          long long v8 = *(char **)a1;
        }
        if (v6 != v7)
        {
          uint64_t v14 = 3 * v6;
          uint64_t v15 = v4 + 24 * v7;
          uint64_t v16 = &v8[8 * v14];
          uint64_t v17 = v4 + 8 * v14;
          do
          {
            *(void *)uint64_t v16 = *(void *)v17;
            *((void *)v16 + sub_1CD7485C0(this + 1) = *(void *)(v17 + 8);
            v16[16] = *(unsigned char *)(v17 + 16);
            v17 += 24;
            v16 += 24;
          }
          while (v17 != v15);
        }
      }
      *(_DWORD *)(a1 + 8) = v5;
      *(_DWORD *)(a2 + 8) = 0;
    }
    else
    {
      sub_1CCCE76E0(a1, a2);
    }
  }
  return a1;
}

double sub_1CCCE76E0(uint64_t a1, uint64_t a2)
{
  unint64_t v5 = (void *)(a1 + 16);
  uint64_t v4 = *(void **)a1;
  if (v4 != v5) {
    free(v4);
  }
  *(void *)a1 = *(void *)a2;
  double result = *(double *)(a2 + 8);
  *(double *)(a1 + 8) = result;
  *(void *)a2 = a2 + 16;
  *(void *)(a2 + 8) = 0;
  return result;
}

void sub_1CCCE7730(char **a1, unint64_t a2)
{
  if (HIDWORD(a2)) {
    sub_1CD0A88F0(a2);
  }
  uint64_t v3 = *((unsigned int *)a1 + 3);
  if (v3 == -1) {
    sub_1CD0A89A8(0xFFFFFFFFuLL);
  }
  unint64_t v4 = (2 * v3) | 1;
  if (v4 <= a2) {
    unint64_t v4 = a2;
  }
  if (v4 >= 0xFFFFFFFF) {
    uint64_t v5 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v5 = v4;
  }
  uint64_t v6 = (char *)malloc_type_malloc(24 * v5, 0x4065EBACuLL);
  if (!v6) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  unint64_t v7 = v6;
  long long v8 = *a1;
  int v9 = *((_DWORD *)a1 + 2);
  if (v9)
  {
    uint64_t v10 = &v8[24 * v9];
    uint64_t v11 = v7;
    unsigned int v12 = *a1;
    do
    {
      *uint64_t v11 = *(void *)v12;
      v11[1] = *((void *)v12 + 1);
      *((unsigned char *)v11 + 16) = v12[16];
      v12 += 24;
      v11 += 3;
    }
    while (v12 != v10);
  }
  if (v8 != (char *)(a1 + 2)) {
    free(v8);
  }
  *a1 = v7;
  *((_DWORD *)a1 + 3) = v5;
}

uint64_t sub_1CCCE7820(uint64_t a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t, uint64_t), uint64_t a4)
{
  *(void *)a1 = a1 + 16;
  *(void *)(a1 + 8) = 0x200000000;
  *(_DWORD *)(a1 + 64) = 0;
  uint64_t v6 = a1 + 64;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  uint64_t v7 = *(unsigned int *)(a2 + 8);
  if (v7)
  {
    uint64_t v10 = *(uint64_t **)a2;
    uint64_t v11 = 8 * v7;
    do
    {
      uint64_t v12 = *v10++;
      a3(v22, a4, v12);
      unint64_t v13 = sub_1CCCE7938(a1, (unint64_t)v22, 1);
      unsigned int v14 = *(_DWORD *)(a1 + 8);
      uint64_t v15 = *(void *)a1 + 24 * v14;
      *(void *)uint64_t v15 = *(void *)v13;
      *(void *)(v15 + 8) = *(void *)(v13 + 8);
      *(unsigned char *)(v15 + 16) = *(unsigned char *)(v13 + 16);
      *(_DWORD *)(a1 + 8) = v14 + 1;
      v11 -= 8;
    }
    while (v11);
  }
  long long v16 = *(_OWORD *)(a2 + 64);
  long long v17 = *(_OWORD *)(a2 + 96);
  *(_OWORD *)(v6 + 16) = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(v6 + 32) = v17;
  *(_OWORD *)uint64_t v6 = v16;
  long long v18 = *(_OWORD *)(a2 + 112);
  long long v19 = *(_OWORD *)(a2 + 128);
  long long v20 = *(_OWORD *)(a2 + 144);
  *(void *)(v6 + 96) = *(void *)(a2 + 160);
  *(_OWORD *)(v6 + 64) = v19;
  *(_OWORD *)(v6 + 80) = v20;
  *(_OWORD *)(v6 + 48) = v18;
  return a1;
}

unint64_t sub_1CCCE7938(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(unsigned int *)(a1 + 8);
  unint64_t v5 = v4 + a3;
  if (v4 + a3 > (unint64_t)*(unsigned int *)(a1 + 12))
  {
    unint64_t v7 = *(void *)a1 + 24 * v4;
    if (*(void *)a1 <= a2 && v7 > a2)
    {
      unint64_t v9 = a2 - *(void *)a1;
      sub_1CCCE7730((char **)a1, v5);
      return *(void *)a1 + v9;
    }
    else
    {
      sub_1CCCE7730((char **)a1, v5);
    }
  }
  return a2;
}

void sub_1CCCE79A4(uint64_t a1, unint64_t a2)
{
  if (HIDWORD(a2)) {
    sub_1CD0A88F0(a2);
  }
  uint64_t v3 = *(unsigned int *)(a1 + 12);
  if (v3 == -1) {
    sub_1CD0A89A8(0xFFFFFFFFuLL);
  }
  unint64_t v4 = (2 * v3) | 1;
  if (v4 <= a2) {
    unint64_t v4 = a2;
  }
  if (v4 >= 0xFFFFFFFF) {
    uint64_t v5 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v5 = v4;
  }
  uint64_t v6 = malloc_type_malloc(v5 << 6, 0x4065EBACuLL);
  if (!v6) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  unint64_t v7 = v6;
  sub_1CCCE7A5C(a1, v6);
  if (*(void *)a1 != a1 + 16) {
    free(*(void **)a1);
  }
  *(void *)a1 = v7;
  *(_DWORD *)(a1 + 12) = v5;
}

void sub_1CCCE7A5C(uint64_t a1, void *a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2)
  {
    uint64_t v5 = *(void *)a1;
    uint64_t v6 = v2 << 6;
    do
    {
      *a2 = a2 + 2;
      a2[1] = 0x200000000;
      if (*(_DWORD *)(v5 + 8)) {
        sub_1CCCE7570((uint64_t)a2, v5);
      }
      v5 += 64;
      a2 += 8;
      v6 -= 64;
    }
    while (v6);
    uint64_t v7 = *(unsigned int *)(a1 + 8);
    if (v7)
    {
      uint64_t v8 = *(void *)a1;
      uint64_t v9 = v7 << 6;
      do
      {
        uint64_t v10 = *(void **)(v8 + v9 - 64);
        if ((void *)(v8 + v9 - 48) != v10) {
          free(v10);
        }
        v9 -= 64;
      }
      while (v9);
    }
  }
}

uint64_t sub_1CCCE7B08(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    unint64_t v4 = *((unsigned int *)a2 + 2);
    uint64_t v5 = *(unsigned int *)(a1 + 8);
    if (v5 >= v4)
    {
      if (v4)
      {
        uint64_t v9 = *a2;
        uint64_t v10 = *a2 + 24 * v4;
        uint64_t v11 = *(char **)a1;
        do
        {
          *(void *)uint64_t v11 = *(void *)v9;
          *((void *)v11 + sub_1CD7485C0(this + 1) = *(void *)(v9 + 8);
          v11[16] = *(unsigned char *)(v9 + 16);
          v9 += 24;
          v11 += 24;
        }
        while (v9 != v10);
      }
    }
    else
    {
      if (*(_DWORD *)(a1 + 12) >= v4)
      {
        uint64_t v6 = *a2;
        uint64_t v8 = *(char **)a1;
        if (v5)
        {
          uint64_t v12 = 0;
          do
          {
            unint64_t v13 = &v8[v12];
            uint64_t v14 = v6 + v12;
            *(void *)unint64_t v13 = *(void *)(v6 + v12);
            *((void *)v13 + sub_1CD7485C0(this + 1) = *(void *)(v6 + v12 + 8);
            v13[16] = *(unsigned char *)(v6 + v12 + 16);
            v12 += 24;
          }
          while (v14 + 24 != v6 + 24 * v5);
        }
        else
        {
          uint64_t v5 = 0;
        }
        unint64_t v7 = v4;
      }
      else
      {
        *(_DWORD *)(a1 + 8) = 0;
        sub_1CCCE7730((char **)a1, v4);
        uint64_t v5 = 0;
        uint64_t v6 = *a2;
        unint64_t v7 = *((unsigned int *)a2 + 2);
        uint64_t v8 = *(char **)a1;
      }
      if (v5 != v7)
      {
        uint64_t v15 = 3 * v5;
        uint64_t v16 = v6 + 24 * v7;
        long long v17 = &v8[8 * v15];
        uint64_t v18 = v6 + 8 * v15;
        do
        {
          *(void *)long long v17 = *(void *)v18;
          *((void *)v17 + sub_1CD7485C0(this + 1) = *(void *)(v18 + 8);
          v17[16] = *(unsigned char *)(v18 + 16);
          v18 += 24;
          v17 += 24;
        }
        while (v18 != v16);
      }
    }
    *(_DWORD *)(a1 + 8) = v4;
  }
  return a1;
}

void *sub_1CCCE7C5C(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >= 0xAAAAAAAAAAAAAABLL) {
      abort();
    }
    uint64_t v6 = result;
    uint64_t v7 = 3 * a4;
    double result = operator new(24 * a4);
    *uint64_t v6 = result;
    v6[1] = result;
    void v6[2] = &result[v7];
    while (a2 != a3)
    {
      uint64_t v8 = sub_1CCCE7CE0(result, a2);
      a2 += 24;
      double result = v8 + 3;
    }
    v6[1] = result;
  }
  return result;
}

void *sub_1CCCE7CE0(void *a1, uint64_t a2)
{
  *a1 = a1;
  a1[1] = a1;
  a1[2] = 0;
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 != a2)
  {
    uint64_t v5 = 1;
    uint64_t v6 = a1;
    do
    {
      uint64_t v7 = operator new(0x20uLL);
      *uint64_t v7 = 0;
      v7[1] = 0;
      *((_OWORD *)v7 + sub_1CD7485C0(this + 1) = *(_OWORD *)(v3 + 16);
      *uint64_t v7 = v6;
      v7[1] = a1;
      v6[1] = v7;
      *a1 = v7;
      a1[2] = v5;
      uint64_t v3 = *(void *)(v3 + 8);
      ++v5;
      uint64_t v6 = v7;
    }
    while (v3 != a2);
  }
  return a1;
}

void *sub_1CCCE7D6C(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v6 = a2;
  uint64_t v7 = result;
  uint64_t v8 = (void *)*result;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(result[2] - *result) >> 3) < a4)
  {
    sub_1CD74EC70((void **)result);
    if (a4 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_34;
    }
    unint64_t v17 = 0x5555555555555556 * ((uint64_t)(v7[2] - *v7) >> 3);
    if (v17 <= a4) {
      unint64_t v17 = a4;
    }
    unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7[2] - *v7) >> 3) >= 0x555555555555555 ? 0xAAAAAAAAAAAAAAALL : v17;
    if (v18 > 0xAAAAAAAAAAAAAAALL) {
LABEL_34:
    }
      abort();
    uint64_t v19 = 3 * v18;
    double result = operator new(24 * v18);
    *uint64_t v7 = result;
    v7[1] = result;
    void v7[2] = &result[v19];
    while (v6 != a3)
    {
      long long v20 = sub_1CCCE7CE0(result, v6);
      v6 += 24;
      double result = v20 + 3;
    }
    v7[1] = result;
  }
  else
  {
    uint64_t v9 = (void *)result[1];
    if (0xAAAAAAAAAAAAAAABLL * (v9 - v8) >= a4)
    {
      if (a2 == a3)
      {
        uint64_t v16 = (void *)*result;
      }
      else
      {
        uint64_t v15 = a2;
        uint64_t v16 = (void *)*result;
        do
        {
          if ((void *)v6 != v8) {
            sub_1CCCE7F84(v8, *(void *)(v6 + 8), v15);
          }
          v6 += 24;
          v8 += 3;
          v16 += 3;
          v15 += 24;
        }
        while (v6 != a3);
      }
      return sub_1CCB49618(v7, v16);
    }
    else
    {
      uint64_t v10 = a2 + 8 * (v9 - v8);
      if (v9 != v8)
      {
        uint64_t v11 = 8 * (v9 - v8);
        uint64_t v12 = a2;
        do
        {
          if ((void *)v6 != v8) {
            double result = sub_1CCCE7F84(v8, *(void *)(v6 + 8), v12);
          }
          v6 += 24;
          v8 += 3;
          v12 += 24;
          v11 -= 24;
        }
        while (v11);
        uint64_t v8 = (void *)v7[1];
      }
      unint64_t v13 = v8;
      if (v10 != a3)
      {
        unint64_t v13 = v8;
        double result = v8;
        do
        {
          uint64_t v14 = sub_1CCCE7CE0(result, v10);
          v10 += 24;
          double result = v14 + 3;
          v13 += 3;
        }
        while (v10 != a3);
      }
      v7[1] = v13;
    }
  }
  return result;
}

_OWORD *sub_1CCCE7F84(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  double result = (_OWORD *)a1[1];
  if (a2 != a3 && result != (_OWORD *)a1)
  {
    do
    {
      result[1] = *(_OWORD *)(v4 + 16);
      uint64_t v4 = *(void *)(v4 + 8);
      double result = (_OWORD *)*((void *)result + 1);
    }
    while (v4 != a3 && result != (_OWORD *)a1);
  }
  if (result == (_OWORD *)a1)
  {
    if (v4 != a3)
    {
      double result = operator new(0x20uLL);
      uint64_t v11 = result;
      *(void *)double result = 0;
      *((void *)result + sub_1CD7485C0(this + 1) = 0;
      result[1] = *(_OWORD *)(v4 + 16);
      uint64_t v12 = *(void *)(v4 + 8);
      uint64_t v13 = 1;
      if (v12 != a3)
      {
        uint64_t v14 = result;
        do
        {
          double result = operator new(0x20uLL);
          *(void *)double result = v14;
          *((void *)result + sub_1CD7485C0(this + 1) = 0;
          result[1] = *(_OWORD *)(v12 + 16);
          *((void *)v14 + sub_1CD7485C0(this + 1) = result;
          ++v13;
          uint64_t v12 = *(void *)(v12 + 8);
          uint64_t v14 = result;
        }
        while (v12 != a3);
      }
      uint64_t v15 = *a1;
      *(void *)(v15 + 8) = v11;
      *uint64_t v11 = v15;
      *a1 = result;
      *((void *)result + sub_1CD7485C0(this + 1) = a1;
      a1[2] += v13;
    }
  }
  else
  {
    uint64_t v8 = *a1;
    uint64_t v9 = *(void *)result;
    *(void *)(v9 + 8) = *(void *)(*a1 + 8);
    **(void **)(v8 + 8) = v9;
    do
    {
      uint64_t v10 = (_OWORD *)*((void *)result + 1);
      --a1[2];
      operator delete(result);
      double result = v10;
    }
    while (v10 != (_OWORD *)a1);
  }
  return result;
}

void *sub_1CCCE80B8(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  double result = (*(void *(**)(void **__return_ptr))(**(void **)a1 + 24))(&v6);
  if (v6)
  {
    uint64_t v5 = v6;
    uint64_t v6 = 0;
    sub_1CD5DD9F0(&v5);
    if (v5) {
      (*(void (**)(void *))(*v5 + 8))(v5);
    }
    memset(v4, 0, sizeof(v4));
    *(void *)a1 = 0;
    sub_1CD6981A8(v2, (__n128 *)&v4[0].n128_i8[8]);
    *(__n128 *)(a1 + 40) = *(__n128 *)((char *)&v4[2] + 8);
    *(void *)(a1 + 56) = v4[3].n128_u64[1];
    sub_1CD69825C((uint64_t)&v4[0].n128_i64[1]);
    double result = v6;
    if (v6) {
      return (void *)(*(uint64_t (**)(void *))(*v6 + 8))(v6);
    }
  }
  return result;
}

uint64_t sub_1CCCE81C8(void *a1)
{
  *a1 = &unk_1F263C610;
  uint64_t v2 = a1[35];
  a1[35] = 0;
  if (v2) {
    MEMORY[0x1D25D9CE0](v2, 0x1050C40D4AB5518);
  }
  uint64_t v3 = a1[34];
  a1[34] = 0;
  if (v3)
  {
    sub_1CD74EA04(v3 + 32);
    MEMORY[0x1D25D9CE0](v3, 0x10D0C40A40D4147);
  }
  uint64_t v4 = (void *)a1[12];
  if (v4 != a1 + 14) {
    free(v4);
  }
  uint64_t v5 = a1[11];
  a1[11] = 0;
  if (v5) {
    sub_1CC025ED8((uint64_t)(a1 + 11), v5);
  }
  uint64_t v6 = a1[10];
  a1[10] = 0;
  if (v6) {
    sub_1CC025ED8((uint64_t)(a1 + 10), v6);
  }
  uint64_t v7 = a1[9];
  a1[9] = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  uint64_t v8 = a1[8];
  a1[8] = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  uint64_t v9 = a1[7];
  a1[7] = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  uint64_t v10 = a1[6];
  a1[6] = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }

  return sub_1CD74ECAC((uint64_t)a1);
}

uint64_t sub_1CCCE8360(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, long long *a5)
{
  uint64_t v5 = 0x6DB6DB6DB6DB6DB7 * ((a1[1] - *a1) >> 3);
  unint64_t v6 = v5 + 1;
  if ((unint64_t)(v5 + 1) > 0x492492492492492) {
    abort();
  }
  if (0xDB6DB6DB6DB6DB6ELL * ((a1[2] - *a1) >> 3) > v6) {
    unint64_t v6 = 0xDB6DB6DB6DB6DB6ELL * ((a1[2] - *a1) >> 3);
  }
  if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((a1[2] - *a1) >> 3)) >= 0x249249249249249) {
    unint64_t v8 = 0x492492492492492;
  }
  else {
    unint64_t v8 = v6;
  }
  __int16 v26 = a1 + 2;
  if (v8 > 0x492492492492492) {
    sub_1CB833614();
  }
  uint64_t v13 = 56 * v8;
  uint64_t v14 = (char *)operator new(56 * v8);
  uint64_t v15 = &v14[56 * v5];
  std::string __p = v14;
  long long v23 = v15;
  uint64_t v16 = *((void *)a5 + 2);
  long long v17 = *a5;
  *((void *)a5 + sub_1CD7485C0(this + 1) = 0;
  *((void *)a5 + 2) = 0;
  *(void *)a5 = 0;
  *(_OWORD *)uint64_t v15 = v17;
  *((void *)v15 + 2) = v16;
  *((void *)v15 + 3) = 0;
  *((void *)v15 + 4) = a2;
  *((void *)v15 + 5) = a3;
  *((void *)v15 + 6) = a4;
  uint64_t v24 = (uint64_t)(v15 + 56);
  unint64_t v25 = &v14[v13];
  sub_1CD74ED24(a1, &__p);
  uint64_t v18 = a1[1];
  long long v20 = v23;
  for (uint64_t i = v24; (char *)i != v20; uint64_t i = sub_1CD69825C(i - 56))
    ;
  if (__p) {
    operator delete(__p);
  }
  return v18;
}

void sub_1CCCE84BC(void *a1)
{
  sub_1CCCE8578(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCCE84F4(void ***a1)
{
  int v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        uint64_t v4 = sub_1CD69825C(v4 - 56);
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *sub_1CCCE8578(void *a1)
{
  uint64_t v2 = a1[1];
  *a1 = &unk_1F263C700;
  a1[1] = 0;
  if (v2)
  {
    uint64_t v4 = (void **)(v2 + 32);
    sub_1CCCE84F4(&v4);
    MEMORY[0x1D25D9CE0](v2, 0x1070C4099022D8ELL);
  }
  return a1;
}

void *sub_1CCCE85F0(void *result, void **a2)
{
  uint64_t v2 = result;
  uint64_t v3 = *a2;
  if (*a2)
  {
    *a2 = 0;
    if ((*(unsigned int (**)(void *, void *))(*v3 + 48))(v3, &llvm::ErrorList::ID))
    {
      void *v2 = 0;
      uint64_t v4 = (char **)v3[1];
      uint64_t v5 = (char **)v3[2];
      if (v4 != v5)
      {
        unint64_t v6 = 0;
        do
        {
          uint64_t v16 = v6;
          uint64_t v7 = *v4;
          *uint64_t v4 = 0;
          if ((*(unsigned int (**)(char *, void *))(*(void *)v7 + 48))(v7, &llvm::InstrProfError::ID))
          {
            int v8 = *((_DWORD *)v7 + 2);
            BOOL v9 = v8 == 13;
            if (v8 == 13) {
              uint64_t v10 = 0;
            }
            else {
              uint64_t v10 = v7;
            }
            uint64_t v15 = v10;
            if (v9) {
              (*(void (**)(char *))(*(void *)v7 + 8))(v7);
            }
          }
          else
          {
            uint64_t v15 = v7;
          }
          sub_1CD451630(&v16, &v15, &v17);
          unint64_t v6 = v17;
          void *v2 = v17;
          long long v17 = 0;
          if (v15) {
            (*(void (**)(char *))(*(void *)v15 + 8))(v15);
          }
          if (v16) {
            (*(void (**)(char *))(*(void *)v16 + 8))(v16);
          }
          ++v4;
        }
        while (v4 != v5);
      }
      return (void *)(*(uint64_t (**)(void *))(*v3 + 8))(v3);
    }
    else
    {
      double result = (void *)(*(uint64_t (**)(void *, void *))(*v3 + 48))(v3, &llvm::InstrProfError::ID);
      if (result)
      {
        int v11 = *((_DWORD *)v3 + 2);
        BOOL v12 = v11 == 13;
        if (v11 == 13) {
          uint64_t v13 = 0;
        }
        else {
          uint64_t v13 = v3;
        }
        void *v2 = v13;
        if (v12)
        {
          uint64_t v14 = *(uint64_t (**)(void *))(*v3 + 8);
          return (void *)v14(v3);
        }
      }
      else
      {
        void *v2 = v3;
      }
    }
  }
  else
  {
    void *result = 0;
  }
  return result;
}

void sub_1CCCE8854()
{
}

uint64_t sub_1CCCE8868(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 24))();
}

uint64_t sub_1CCCE8890(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(char **)a2;
    if (*(void *)a2 == a2 + 16)
    {
      unsigned int v5 = *(_DWORD *)(a2 + 8);
      uint64_t v6 = *(unsigned int *)(a1 + 8);
      if (v6 >= v5)
      {
        uint64_t v14 = *(char **)a1;
        if (v5)
        {
          uint64_t v15 = &v4[168 * v5];
          do
          {
            sub_1CD41C56C((uint64_t)v14, (uint64_t)v4);
            long long v17 = *((_OWORD *)v4 + 5);
            long long v16 = *((_OWORD *)v4 + 6);
            *((_OWORD *)v14 + 4) = *((_OWORD *)v4 + 4);
            *((_OWORD *)v14 + 5) = v17;
            *((_OWORD *)v14 + 6) = v16;
            long long v19 = *((_OWORD *)v4 + 8);
            long long v18 = *((_OWORD *)v4 + 9);
            long long v20 = *((_OWORD *)v4 + 7);
            *((void *)v14 + 20) = *((void *)v4 + 20);
            *((_OWORD *)v14 + 8) = v19;
            *((_OWORD *)v14 + 9) = v18;
            *((_OWORD *)v14 + 7) = v20;
            v14 += 168;
            v4 += 168;
          }
          while (v4 != v15);
          uint64_t v21 = v14;
          LODWORD(v6) = *(_DWORD *)(a1 + 8);
          uint64_t v14 = *(char **)a1;
        }
        else
        {
          uint64_t v21 = *(char **)a1;
        }
        uint64_t v22 = &v14[168 * v6];
        while (v22 != v21)
        {
          uint64_t v24 = (char *)*((void *)v22 - 21);
          v22 -= 168;
          long long v23 = v24;
          if (v22 + 16 != v24) {
            free(v23);
          }
        }
        *(_DWORD *)(a1 + 8) = v5;
        unsigned int v25 = *(_DWORD *)(a2 + 8);
        if (v25)
        {
          __int16 v26 = *(char **)a2;
          uint64_t v27 = 168 * v25;
          do
          {
            unsigned int v28 = *(char **)&v26[v27 - 168];
            if (&v26[v27 - 152] != v28) {
              free(v28);
            }
            v27 -= 168;
          }
          while (v27);
        }
      }
      else
      {
        if (*(_DWORD *)(a1 + 12) < v5)
        {
          if (v6)
          {
            long long v29 = *(char **)a1;
            uint64_t v30 = 168 * v6;
            do
            {
              unint64_t v31 = *(char **)&v29[v30 - 168];
              if (&v29[v30 - 152] != v31) {
                free(v31);
              }
              v30 -= 168;
            }
            while (v30);
          }
          *(_DWORD *)(a1 + 8) = 0;
          sub_1CD74F738();
        }
        if (v6)
        {
          uint64_t v7 = &v4[168 * v6];
          uint64_t v8 = *(void *)a1;
          do
          {
            sub_1CD41C56C(v8, (uint64_t)v4);
            long long v10 = *((_OWORD *)v4 + 5);
            long long v9 = *((_OWORD *)v4 + 6);
            *(_OWORD *)(v8 + 64) = *((_OWORD *)v4 + 4);
            *(_OWORD *)(v8 + 80) = v10;
            *(_OWORD *)(v8 + 96) = v9;
            long long v12 = *((_OWORD *)v4 + 8);
            long long v11 = *((_OWORD *)v4 + 9);
            long long v13 = *((_OWORD *)v4 + 7);
            *(void *)(v8 + 160) = *((void *)v4 + 20);
            *(_OWORD *)(v8 + 128) = v12;
            *(_OWORD *)(v8 + 144) = v11;
            *(_OWORD *)(v8 + 112) = v13;
            v4 += 168;
            v8 += 168;
          }
          while (v4 != v7);
        }
        else
        {
          uint64_t v6 = 0;
        }
        uint64_t v32 = *(char **)a2;
        uint64_t v33 = *(unsigned int *)(a2 + 8);
        if (v6 != v33)
        {
          unint64_t v34 = *(char **)a1;
          uint64_t v35 = 168 * v6;
          uint64_t v36 = 168 * v33;
          do
          {
            unint64_t v37 = &v34[v35];
            uint64_t v38 = &v32[v35];
            *(void *)unint64_t v37 = &v34[v35 + 16];
            *((void *)v37 + sub_1CD7485C0(this + 1) = 0x600000000;
            if (*(_DWORD *)&v32[v35 + 8]) {
              sub_1CD41C56C((uint64_t)&v34[v35], (uint64_t)&v32[v35]);
            }
            v32 += 168;
            long long v39 = *((_OWORD *)v38 + 4);
            long long v40 = *((_OWORD *)v38 + 6);
            *((_OWORD *)v37 + 5) = *((_OWORD *)v38 + 5);
            *((_OWORD *)v37 + 6) = v40;
            *((_OWORD *)v37 + 4) = v39;
            long long v41 = *((_OWORD *)v38 + 7);
            long long v42 = *((_OWORD *)v38 + 8);
            long long v43 = *((_OWORD *)v38 + 9);
            *((void *)v37 + 20) = *((void *)v38 + 20);
            *((_OWORD *)v37 + 8) = v42;
            *((_OWORD *)v37 + 9) = v43;
            *((_OWORD *)v37 + 7) = v41;
            v34 += 168;
            v36 -= 168;
          }
          while (v35 != v36);
          uint64_t v32 = *(char **)a2;
        }
        *(_DWORD *)(a1 + 8) = v5;
        unsigned int v44 = *(_DWORD *)(a2 + 8);
        if (v44)
        {
          uint64_t v45 = 168 * v44;
          do
          {
            unint64_t v46 = *(char **)&v32[v45 - 168];
            if (&v32[v45 - 152] != v46) {
              free(v46);
            }
            v45 -= 168;
          }
          while (v45);
        }
      }
      *(_DWORD *)(a2 + 8) = 0;
    }
    else
    {
      sub_1CCCE8B5C((char **)a1, (char **)a2);
    }
  }
  return a1;
}

double sub_1CCCE8B5C(char **a1, char **a2)
{
  uint64_t v4 = *a1;
  unsigned int v5 = *((_DWORD *)a1 + 2);
  if (v5)
  {
    uint64_t v6 = 168 * v5;
    do
    {
      uint64_t v7 = *(char **)&v4[v6 - 168];
      if (&v4[v6 - 152] != v7) {
        free(v7);
      }
      v6 -= 168;
    }
    while (v6);
    uint64_t v4 = *a1;
  }
  if (v4 != (char *)(a1 + 2)) {
    free(v4);
  }
  *a1 = *a2;
  double result = *((double *)a2 + 1);
  *((double *)a1 + sub_1CD7485C0(this + 1) = result;
  *a2 = (char *)(a2 + 2);
  a2[1] = 0;
  return result;
}

uint64_t sub_1CCCE8BEC(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(char **)a2;
    if (*(void *)a2 == a2 + 16)
    {
      uint64_t v5 = *(unsigned int *)(a2 + 8);
      uint64_t v6 = *(unsigned int *)(a1 + 8);
      if (v6 >= v5)
      {
        long long v9 = *(char **)a1;
        if (v5)
        {
          uint64_t v10 = 0;
          do
          {
            sub_1CD41C56C((uint64_t)&v9[v10], (uint64_t)&v4[v10]);
            v10 += 64;
          }
          while (v5 << 6 != v10);
          uint64_t v6 = *(unsigned int *)(a1 + 8);
          long long v11 = &v9[v10];
          long long v9 = *(char **)a1;
        }
        else
        {
          long long v11 = *(char **)a1;
        }
        long long v12 = &v9[64 * v6];
        while (v12 != v11)
        {
          uint64_t v14 = (char *)*((void *)v12 - 8);
          v12 -= 64;
          long long v13 = v14;
          if (v12 + 16 != v14) {
            free(v13);
          }
        }
        *(_DWORD *)(a1 + 8) = v5;
        uint64_t v15 = *(unsigned int *)(a2 + 8);
        if (v15)
        {
          long long v16 = *(char **)a2;
          uint64_t v17 = v15 << 6;
          do
          {
            long long v18 = *(char **)&v16[v17 - 64];
            if (&v16[v17 - 48] != v18) {
              free(v18);
            }
            v17 -= 64;
          }
          while (v17);
        }
      }
      else
      {
        if (*(_DWORD *)(a1 + 12) < v5)
        {
          if (v6)
          {
            long long v19 = *(char **)a1;
            uint64_t v20 = v6 << 6;
            do
            {
              uint64_t v21 = *(char **)&v19[v20 - 64];
              if (&v19[v20 - 48] != v21) {
                free(v21);
              }
              v20 -= 64;
            }
            while (v20);
          }
          *(_DWORD *)(a1 + 8) = 0;
          sub_1CD74FA34();
        }
        if (v6)
        {
          uint64_t v7 = *(void *)a1;
          uint64_t v8 = v6 << 6;
          do
          {
            sub_1CD41C56C(v7, (uint64_t)v4);
            v4 += 64;
            v7 += 64;
            v8 -= 64;
          }
          while (v8);
        }
        else
        {
          uint64_t v6 = 0;
        }
        uint64_t v22 = *(char **)a2;
        uint64_t v23 = *(unsigned int *)(a2 + 8);
        if (v6 != v23)
        {
          uint64_t v24 = *(char **)a1;
          uint64_t v25 = v6 << 6;
          uint64_t v26 = v23 << 6;
          do
          {
            uint64_t v27 = &v24[v25];
            *(void *)uint64_t v27 = &v24[v25 + 16];
            *((void *)v27 + sub_1CD7485C0(this + 1) = 0x600000000;
            if (*(_DWORD *)&v22[v25 + 8]) {
              sub_1CD41C56C((uint64_t)v27, (uint64_t)&v22[v25]);
            }
            v24 += 64;
            v26 -= 64;
            v22 += 64;
          }
          while (v25 != v26);
          uint64_t v22 = *(char **)a2;
        }
        *(_DWORD *)(a1 + 8) = v5;
        uint64_t v28 = *(unsigned int *)(a2 + 8);
        if (v28)
        {
          uint64_t v29 = v28 << 6;
          do
          {
            uint64_t v30 = *(char **)&v22[v29 - 64];
            if (&v22[v29 - 48] != v30) {
              free(v30);
            }
            v29 -= 64;
          }
          while (v29);
        }
      }
      *(_DWORD *)(a2 + 8) = 0;
    }
    else
    {
      sub_1CCCE8E14((char **)a1, (char **)a2);
    }
  }
  return a1;
}

double sub_1CCCE8E14(char **a1, char **a2)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *((unsigned int *)a1 + 2);
  if (v5)
  {
    uint64_t v6 = v5 << 6;
    do
    {
      uint64_t v7 = *(char **)&v4[v6 - 64];
      if (&v4[v6 - 48] != v7) {
        free(v7);
      }
      v6 -= 64;
    }
    while (v6);
    uint64_t v4 = *a1;
  }
  if (v4 != (char *)(a1 + 2)) {
    free(v4);
  }
  *a1 = *a2;
  double result = *((double *)a2 + 1);
  *((double *)a1 + sub_1CD7485C0(this + 1) = result;
  *a2 = (char *)(a2 + 2);
  a2[1] = 0;
  return result;
}

double sub_1CCCE8EA0@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3 = *(void **)(*(void *)a1 + 280);
  uint64_t v4 = *(void *)(v3[2] + 8 * ((*v3 - 1) & a2));
  if (v4 && (uint64_t v5 = (_WORD *)(v3[3] + v4), v6 = (unsigned __int16)*v5, *v5))
  {
    uint64_t v7 = (uint64_t *)(v5 + 1);
    while (1)
    {
      uint64_t v9 = *v7;
      uint64_t v8 = v7[1];
      uint64_t v10 = v7[2];
      long long v11 = v7 + 3;
      if (v9 == a2 && *v11 == a2) {
        break;
      }
      uint64_t v7 = (void *)((char *)v11 + v10 + v8);
      if (!--v6) {
        goto LABEL_7;
      }
    }
    long long v13 = (double *)((char *)v11 + v8);
    uint64_t v14 = *(void *)((char *)v11 + v8);
    char v15 = (_BYTE)v13[2] & 1;
    *(void *)a3 = v14;
    double result = v13[1];
    *(double *)(a3 + 8) = result;
    *(unsigned char *)(a3 + 16) = v15;
  }
  else
  {
LABEL_7:
    long long v12 = *(unsigned char **)(a1 + 16);
    **(void **)(a1 + 8) = a2;
    *long long v12 = 1;
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(unsigned char *)(a3 + 16) = 0;
  }
  return result;
}

uint64_t sub_1CCCE8F44(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(char **)a2;
    if (*(void *)a2 != a2 + 16)
    {
      sub_1CCCE8B5C((char **)a1, (char **)a2);
      return a1;
    }
    unint64_t v5 = *(unsigned int *)(a2 + 8);
    uint64_t v6 = *(unsigned int *)(a1 + 8);
    if (v6 >= v5)
    {
      uint64_t v10 = *(char **)a1;
      if (v5)
      {
        long long v11 = &v4[168 * v5];
        do
        {
          sub_1CCCE7570((uint64_t)v10, (uint64_t)v4);
          long long v13 = *((_OWORD *)v4 + 5);
          long long v12 = *((_OWORD *)v4 + 6);
          *((_OWORD *)v10 + 4) = *((_OWORD *)v4 + 4);
          *((_OWORD *)v10 + 5) = v13;
          *((_OWORD *)v10 + 6) = v12;
          long long v15 = *((_OWORD *)v4 + 8);
          long long v14 = *((_OWORD *)v4 + 9);
          long long v16 = *((_OWORD *)v4 + 7);
          *((void *)v10 + 20) = *((void *)v4 + 20);
          *((_OWORD *)v10 + 8) = v15;
          *((_OWORD *)v10 + 9) = v14;
          *((_OWORD *)v10 + 7) = v16;
          v10 += 168;
          v4 += 168;
        }
        while (v4 != v11);
        uint64_t v17 = v10;
        LODWORD(v6) = *(_DWORD *)(a1 + 8);
        uint64_t v10 = *(char **)a1;
      }
      else
      {
        uint64_t v17 = *(char **)a1;
      }
      long long v40 = &v10[168 * v6];
      while (v40 != v17)
      {
        long long v42 = (char *)*((void *)v40 - 21);
        v40 -= 168;
        long long v41 = v42;
        if (v40 + 16 != v42) {
          free(v41);
        }
      }
      *(_DWORD *)(a1 + 8) = v5;
      unsigned int v43 = *(_DWORD *)(a2 + 8);
      if (v43)
      {
        unsigned int v44 = *(char **)a2;
        uint64_t v45 = 168 * v43;
        do
        {
          unint64_t v46 = *(char **)&v44[v45 - 168];
          if (&v44[v45 - 152] != v46) {
            free(v46);
          }
          v45 -= 168;
        }
        while (v45);
      }
      goto LABEL_43;
    }
    if (*(_DWORD *)(a1 + 12) >= v5)
    {
      if (v6)
      {
        long long v18 = &v4[168 * v6];
        long long v19 = *(char **)a1;
        do
        {
          sub_1CCCE7570((uint64_t)v19, (uint64_t)v4);
          long long v21 = *((_OWORD *)v4 + 5);
          long long v20 = *((_OWORD *)v4 + 6);
          *((_OWORD *)v19 + 4) = *((_OWORD *)v4 + 4);
          *((_OWORD *)v19 + 5) = v21;
          *((_OWORD *)v19 + 6) = v20;
          long long v23 = *((_OWORD *)v4 + 8);
          long long v22 = *((_OWORD *)v4 + 9);
          long long v24 = *((_OWORD *)v4 + 7);
          *((void *)v19 + 20) = *((void *)v4 + 20);
          *((_OWORD *)v19 + 8) = v23;
          *((_OWORD *)v19 + 9) = v22;
          *((_OWORD *)v19 + 7) = v24;
          v4 += 168;
          v19 += 168;
        }
        while (v4 != v18);
        goto LABEL_21;
      }
    }
    else
    {
      if (v6)
      {
        uint64_t v7 = *(char **)a1;
        uint64_t v8 = 168 * v6;
        do
        {
          uint64_t v9 = *(char **)&v7[v8 - 168];
          if (&v7[v8 - 152] != v9) {
            free(v9);
          }
          v8 -= 168;
        }
        while (v8);
      }
      *(_DWORD *)(a1 + 8) = 0;
      sub_1CCCE920C(a1, v5);
    }
    uint64_t v6 = 0;
LABEL_21:
    uint64_t v25 = *(char **)a2;
    uint64_t v26 = *(unsigned int *)(a2 + 8);
    if (v6 != v26)
    {
      uint64_t v27 = *(char **)a1;
      uint64_t v28 = 168 * v6;
      uint64_t v29 = 168 * v26;
      do
      {
        uint64_t v30 = &v27[v28];
        unint64_t v31 = &v25[v28];
        *(void *)uint64_t v30 = &v27[v28 + 16];
        *((void *)v30 + sub_1CD7485C0(this + 1) = 0x200000000;
        if (*(_DWORD *)&v25[v28 + 8]) {
          sub_1CCCE7570((uint64_t)&v27[v28], (uint64_t)&v25[v28]);
        }
        v25 += 168;
        long long v32 = *((_OWORD *)v31 + 4);
        long long v33 = *((_OWORD *)v31 + 6);
        *((_OWORD *)v30 + 5) = *((_OWORD *)v31 + 5);
        *((_OWORD *)v30 + 6) = v33;
        *((_OWORD *)v30 + 4) = v32;
        long long v34 = *((_OWORD *)v31 + 7);
        long long v35 = *((_OWORD *)v31 + 8);
        long long v36 = *((_OWORD *)v31 + 9);
        *((void *)v30 + 20) = *((void *)v31 + 20);
        *((_OWORD *)v30 + 8) = v35;
        *((_OWORD *)v30 + 9) = v36;
        *((_OWORD *)v30 + 7) = v34;
        v27 += 168;
        v29 -= 168;
      }
      while (v28 != v29);
      uint64_t v25 = *(char **)a2;
    }
    *(_DWORD *)(a1 + 8) = v5;
    unsigned int v37 = *(_DWORD *)(a2 + 8);
    if (v37)
    {
      uint64_t v38 = 168 * v37;
      do
      {
        long long v39 = *(char **)&v25[v38 - 168];
        if (&v25[v38 - 152] != v39) {
          free(v39);
        }
        v38 -= 168;
      }
      while (v38);
    }
LABEL_43:
    *(_DWORD *)(a2 + 8) = 0;
  }
  return a1;
}

void sub_1CCCE920C(uint64_t a1, unint64_t a2)
{
  if (HIDWORD(a2)) {
    sub_1CD0A88F0(a2);
  }
  uint64_t v3 = *(unsigned int *)(a1 + 12);
  if (v3 == -1) {
    sub_1CD0A89A8(0xFFFFFFFFuLL);
  }
  unint64_t v4 = (2 * v3) | 1;
  if (v4 <= a2) {
    unint64_t v4 = a2;
  }
  if (v4 >= 0xFFFFFFFF) {
    uint64_t v5 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v5 = v4;
  }
  uint64_t v6 = malloc_type_malloc(168 * v5, 0x4065EBACuLL);
  if (!v6) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  uint64_t v7 = v6;
  sub_1CCCE7494(a1, (uint64_t)v6);
  if (*(void *)a1 != a1 + 16) {
    free(*(void **)a1);
  }
  *(void *)a1 = v7;
  *(_DWORD *)(a1 + 12) = v5;
}

uint64_t sub_1CCCE92C8(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    unint64_t v4 = *(char **)a2;
    if (*(void *)a2 != a2 + 16)
    {
      sub_1CCCE8E14((char **)a1, (char **)a2);
      return a1;
    }
    unint64_t v5 = *(unsigned int *)(a2 + 8);
    uint64_t v6 = *(unsigned int *)(a1 + 8);
    if (v6 >= v5)
    {
      uint64_t v10 = *(char **)a1;
      if (v5)
      {
        uint64_t v11 = 0;
        do
        {
          sub_1CCCE7570((uint64_t)&v10[v11], (uint64_t)&v4[v11]);
          v11 += 64;
        }
        while (v5 << 6 != v11);
        uint64_t v6 = *(unsigned int *)(a1 + 8);
        long long v12 = &v10[v11];
        uint64_t v10 = *(char **)a1;
      }
      else
      {
        long long v12 = *(char **)a1;
      }
      long long v24 = &v10[64 * v6];
      while (v24 != v12)
      {
        uint64_t v26 = (char *)*((void *)v24 - 8);
        v24 -= 64;
        uint64_t v25 = v26;
        if (v24 + 16 != v26) {
          free(v25);
        }
      }
      *(_DWORD *)(a1 + 8) = v5;
      uint64_t v27 = *(unsigned int *)(a2 + 8);
      if (v27)
      {
        uint64_t v28 = *(char **)a2;
        uint64_t v29 = v27 << 6;
        do
        {
          uint64_t v30 = *(char **)&v28[v29 - 64];
          if (&v28[v29 - 48] != v30) {
            free(v30);
          }
          v29 -= 64;
        }
        while (v29);
      }
      goto LABEL_43;
    }
    if (*(_DWORD *)(a1 + 12) >= v5)
    {
      if (v6)
      {
        long long v13 = *(char **)a1;
        uint64_t v14 = v6 << 6;
        do
        {
          sub_1CCCE7570((uint64_t)v13, (uint64_t)v4);
          v4 += 64;
          v13 += 64;
          v14 -= 64;
        }
        while (v14);
        goto LABEL_21;
      }
    }
    else
    {
      if (v6)
      {
        uint64_t v7 = *(char **)a1;
        uint64_t v8 = v6 << 6;
        do
        {
          uint64_t v9 = *(char **)&v7[v8 - 64];
          if (&v7[v8 - 48] != v9) {
            free(v9);
          }
          v8 -= 64;
        }
        while (v8);
      }
      *(_DWORD *)(a1 + 8) = 0;
      sub_1CCCE79A4(a1, v5);
    }
    uint64_t v6 = 0;
LABEL_21:
    long long v15 = *(char **)a2;
    uint64_t v16 = *(unsigned int *)(a2 + 8);
    if (v6 != v16)
    {
      uint64_t v17 = *(char **)a1;
      uint64_t v18 = v6 << 6;
      uint64_t v19 = v16 << 6;
      do
      {
        long long v20 = &v17[v18];
        *(void *)long long v20 = &v17[v18 + 16];
        *((void *)v20 + sub_1CD7485C0(this + 1) = 0x200000000;
        if (*(_DWORD *)&v15[v18 + 8]) {
          sub_1CCCE7570((uint64_t)v20, (uint64_t)&v15[v18]);
        }
        v17 += 64;
        v19 -= 64;
        v15 += 64;
      }
      while (v18 != v19);
      long long v15 = *(char **)a2;
    }
    *(_DWORD *)(a1 + 8) = v5;
    uint64_t v21 = *(unsigned int *)(a2 + 8);
    if (v21)
    {
      uint64_t v22 = v21 << 6;
      do
      {
        long long v23 = *(char **)&v15[v22 - 64];
        if (&v15[v22 - 48] != v23) {
          free(v23);
        }
        v22 -= 64;
      }
      while (v22);
    }
LABEL_43:
    *(_DWORD *)(a2 + 8) = 0;
  }
  return a1;
}

void llvm::InstrProfWriter::InstrProfWriter(llvm::InstrProfWriter *this, char a2)
{
  *(unsigned char *)this = a2;
  *((void *)this + sub_1CD7485C0(this + 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0xB000000000;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *(_OWORD *)((char *)this + 92) = 0u;
  *((void *)this + 15) = 0;
  *((void *)this + 16) = 0;
  *((void *)this + 14) = 0;
  *((_DWORD *)this + 34) = 0;
  operator new();
}

{
  *(unsigned char *)this = a2;
  *((void *)this + sub_1CD7485C0(this + 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0xB000000000;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *(_OWORD *)((char *)this + 92) = 0u;
  *((void *)this + 15) = 0;
  *((void *)this + 16) = 0;
  *((void *)this + 14) = 0;
  *((_DWORD *)this + 34) = 0;
  operator new();
}

void llvm::InstrProfWriter::~InstrProfWriter(llvm::InstrProfWriter *this)
{
  uint64_t v2 = *((void *)this + 18);
  if (v2) {
    MEMORY[0x1D25D9CE0](v2, 0x1020C40F89CB87BLL);
  }
  uint64_t v3 = (void *)*((void *)this + 14);
  if (v3)
  {
    *((void *)this + 15) = v3;
    operator delete(v3);
  }
  MEMORY[0x1D25D9CD0](*((void *)this + 11), 8);
  long long v13 = (void **)((char *)this + 64);
  sub_1CCCED5F0(&v13);
  MEMORY[0x1D25D9CD0](*((void *)this + 5), 8);
  if (*((_DWORD *)this + 5))
  {
    uint64_t v4 = *((unsigned int *)this + 4);
    if (v4)
    {
      uint64_t v5 = 0;
      while (1)
      {
        uint64_t v6 = *(void *)(*((void *)this + 1) + 8 * v5);
        if (v6 != -8 && v6 != 0) {
          break;
        }
LABEL_24:
        if (++v5 == v4) {
          goto LABEL_25;
        }
      }
      int v8 = *(_DWORD *)(v6 + 8);
      if (v8)
      {
        uint64_t v10 = v6 + 16;
        uint64_t v9 = 4;
      }
      else
      {
        uint64_t v9 = *(unsigned int *)(v6 + 24);
        if (!v9)
        {
LABEL_21:
          if ((v8 & 1) == 0) {
            MEMORY[0x1D25D9CD0](*(void *)(v6 + 16), 8);
          }
          MEMORY[0x1D25D9CD0](v6, 8);
          goto LABEL_24;
        }
        uint64_t v10 = *(void *)(v6 + 16);
      }
      uint64_t v11 = 40 * v9;
      uint64_t v12 = v10 + 8;
      do
      {
        if (*(void *)(v12 - 8) <= 0xFFFFFFFFFFFFFFFDLL) {
          uint64_t v12 = sub_1CD69825C(v12);
        }
        v12 += 40;
        v11 -= 40;
      }
      while (v11);
      int v8 = *(_DWORD *)(v6 + 8);
      goto LABEL_21;
    }
  }
LABEL_25:
  free(*((void **)this + 1));
}

uint64_t llvm::InstrProfWriter::setValueProfDataEndianness(uint64_t result, int a2)
{
  **(_DWORD **)(result + 144) = a2;
  return result;
}

unsigned char *llvm::InstrProfWriter::setOutputSparse(unsigned char *this, char a2)
{
  *this = a2;
  return this;
}

void *llvm::InstrProfWriter::addRecord(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  return llvm::InstrProfWriter::addRecord(a1, *(unsigned __int8 **)(a2 + 32), *(void *)(a2 + 40), *(void *)(a2 + 48), (__n128 *)a2, a3, a4, a5);
}

void *llvm::InstrProfWriter::addRecord(uint64_t a1, unsigned __int8 *a2, size_t a3, uint64_t a4, __n128 *a5, unint64_t a6, uint64_t a7, uint64_t a8)
{
  v33[0] = a7;
  v33[1] = a8;
  uint64_t v11 = *sub_1CCCED85C((llvm::StringMapImpl *)(a1 + 8), a2, a3) + 8;
  uint64_t v29 = (void *)a4;
  memset(v30, 0, sizeof(v30));
  memset(v28, 0, sizeof(v28));
  sub_1CCCEDA74((uint64_t)&v31, v11, (uint64_t *)&v29, (uint64_t)v30);
  uint64_t v12 = v31;
  int v13 = v32;
  sub_1CD69825C((uint64_t)v30);
  sub_1CD69825C((uint64_t)v28);
  uint64_t v29 = v33;
  if (v13)
  {
    double result = (void *)sub_1CD6981A8(v12 + 8, a5);
    if (a6 >= 2) {
      double result = (void *)llvm::InstrProfRecord::scale((unint64_t **)(v12 + 8), a6, 1uLL, (uint64_t (*)(uint64_t, uint64_t))sub_1CCCEDF58, (uint64_t)&v29);
    }
  }
  else
  {
    double result = llvm::InstrProfRecord::merge((uint64_t *)(v12 + 8), a5, a6, (uint64_t (*)(uint64_t, uint64_t))sub_1CCCEDF58, (uint64_t)&v29);
  }
  char v15 = 1;
  do
  {
    char v16 = v15;
    uint64_t v17 = *(void *)(v12 + 32);
    if (v17)
    {
      uint64_t v18 = (v16 & 1) != 0 ? 8 : 32;
      uint64_t v19 = (v16 & 1) != 0 ? 0 : 24;
      uint64_t v20 = *(void *)(v17 + v19);
      for (uint64_t i = *(void *)(v17 + v18); v20 != i; v20 += 24)
      {
        double result = sub_1CCCED690(*(uint64_t **)(v20 + 8), (uint64_t *)v20, *(void *)(v20 + 16));
        unint64_t v22 = *(void *)(v20 + 16);
        if (v22 >= 0x100)
        {
          if (v22 >= 0x1FE)
          {
            double result = *(void **)(v20 + 8);
            for (unint64_t j = 256; j > 1; --j)
              double result = (void *)result[1];
          }
          else
          {
            unint64_t v23 = v22 - 255;
            double result = (void *)v20;
            do
            {
              double result = (void *)*result;
              --v23;
            }
            while (v23);
          }
          if (result != (void *)v20)
          {
            uint64_t v25 = *(void *)v20;
            uint64_t v26 = (void *)*result;
            v26[1] = *(void *)(*(void *)v20 + 8);
            **(void **)(v25 + 8) = v26;
            do
            {
              uint64_t v27 = (void *)result[1];
              --*(void *)(v20 + 16);
              operator delete(result);
              double result = v27;
            }
            while (v27 != (void *)v20);
          }
        }
      }
    }
    char v15 = 0;
  }
  while ((v16 & 1) != 0);
  return result;
}

void llvm::InstrProfWriter::overlapRecord(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(_OWORD *)long long v36 = *(_OWORD *)(a2 + 32);
  uint64_t v27 = *(void *)(a2 + 48);
  uint64_t v29 = a4 + 32;
  llvm::InstrProfRecord::accumulateCounts(a2, a4 + 32);
  uint64_t v6 = a1[4];
  if (!v6) {
    goto LABEL_17;
  }
  int v7 = 0;
  if (v36[1])
  {
    uint64_t v8 = v36[1];
    uint64_t v9 = (unsigned __int8 *)v36[0];
    do
    {
      int v10 = *v9++;
      int v7 = 33 * v7 + v10;
      --v8;
    }
    while (v8);
  }
  uint64_t v11 = *((void *)a1 + 1);
  int v12 = 1;
  int v13 = v7;
  while (1)
  {
    uint64_t v14 = v13 & (v6 - 1);
    char v15 = *(void **)(v11 + 8 * v14);
    if (v15 != (void *)-8)
    {
      if (!v15) {
        goto LABEL_17;
      }
      if (*(_DWORD *)(v11 + 8 * v6 + 8 + 4 * v14) == v7
        && v36[1] == *v15
        && (!v36[1] || !memcmp((const void *)v36[0], (char *)v15 + a1[7], v36[1])))
      {
        break;
      }
    }
    int v13 = v12 + v14;
    ++v12;
  }
  if (v14 == -1 || (int)v14 == v6)
  {
LABEL_17:
    llvm::OverlapStats::addOneUnique(a3, v29);
  }
  else if (*(double *)(a4 + 40) >= 1.0)
  {
    uint64_t v16 = *sub_1CCCED85C((llvm::StringMapImpl *)(a1 + 2), (unsigned __int8 *)v36[0], v36[1]) + 8;
    uint64_t v32 = v27;
    memset(v33, 0, sizeof(v33));
    memset(v31, 0, sizeof(v31));
    sub_1CCCEDA74((uint64_t)&v34, v16, &v32, (uint64_t)v33);
    uint64_t v17 = v34;
    int v18 = v35;
    sub_1CD69825C((uint64_t)v33);
    sub_1CD69825C((uint64_t)v31);
    if (v18)
    {
      llvm::OverlapStats::addOneMismatch(a3, v29);
    }
    else
    {
      unint64_t v19 = *(void *)a5;
      char v20 = *(unsigned char *)(a5 + 31);
      int v21 = v20;
      size_t v22 = v20 & 0x7F;
      if (v21 >= 0) {
        size_t v23 = v22;
      }
      else {
        size_t v23 = *(void *)(a5 + 16);
      }
      if (v23)
      {
        if (v21 >= 0) {
          long long v24 = (char *)(a5 + 8);
        }
        else {
          long long v24 = *(char **)(a5 + 8);
        }
        if (llvm::StringRef::find(v36, v24, v23, 0) != -1) {
          unint64_t v19 = 0;
        }
      }
      llvm::InstrProfRecord::overlap((void *)(v17 + 8), (uint64_t *)a2, a3, a4, v19);
    }
  }
  else
  {
    ++*(void *)(a3 + 64);
  }
}

void *llvm::InstrProfWriter::addMemProfRecord(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v33[8] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (void *)(a1 + 40);
  uint64_t v29 = a2;
  sub_1CD74F480(v30, a3);
  uint64_t v5 = sub_1CCCEE018(v4, &v29, (uint64_t)v30);
  char v7 = v6;
  uint64_t v8 = (char *)v31;
  if (v32)
  {
    unint64_t v9 = (unint64_t)v32 << 6;
    do
    {
      int v10 = *(char **)&v8[v9 - 64];
      if (&v8[v9 - 48] != v10) {
        free(v10);
      }
      v9 -= 64;
    }
    while (v9);
    uint64_t v8 = (char *)v31;
  }
  if (v8 != (char *)v33) {
    free(v8);
  }
  double result = sub_1CD74EA50(v30);
  if (!v7)
  {
    uint64_t v12 = *(void *)a3;
    uint64_t v13 = *(unsigned int *)(a3 + 8);
    uint64_t v14 = *(unsigned int *)(v5 + 16);
    if (v14 + v13 > (unint64_t)*(unsigned int *)(v5 + 20)) {
      sub_1CD74F738();
    }
    if (v13)
    {
      uint64_t v15 = 0;
      uint64_t v16 = *(void *)(v5 + 8) + 168 * v14;
      do
      {
        uint64_t v17 = v16 + v15;
        uint64_t v18 = v12 + v15;
        *(void *)uint64_t v17 = v16 + v15 + 16;
        *(void *)(v17 + 8) = 0x600000000;
        if (*(_DWORD *)(v12 + v15 + 8)) {
          double result = (void *)llvm::DirectedGraph<llvm::DDGNode,llvm::DDGEdge>::operator=(v16 + v15, v12 + v15);
        }
        v15 += 168;
        long long v19 = *(_OWORD *)(v18 + 64);
        long long v20 = *(_OWORD *)(v18 + 96);
        *(_OWORD *)(v17 + 80) = *(_OWORD *)(v18 + 80);
        *(_OWORD *)(v17 + 96) = v20;
        *(_OWORD *)(v17 + 64) = v19;
        long long v21 = *(_OWORD *)(v18 + 112);
        long long v22 = *(_OWORD *)(v18 + 128);
        long long v23 = *(_OWORD *)(v18 + 144);
        *(void *)(v17 + 160) = *(void *)(v18 + 160);
        *(_OWORD *)(v17 + 128) = v22;
        *(_OWORD *)(v17 + 144) = v23;
        *(_OWORD *)(v17 + 112) = v21;
      }
      while (168 * v13 != v15);
      LODWORD(v14) = *(_DWORD *)(v5 + 16);
    }
    *(_DWORD *)(v5 + 16) = v14 + v13;
    uint64_t v24 = *(void *)(a3 + 184);
    uint64_t v25 = *(unsigned int *)(a3 + 192);
    uint64_t v26 = *(unsigned int *)(v5 + 200);
    if (v26 + v25 > (unint64_t)*(unsigned int *)(v5 + 204)) {
      sub_1CD74FA34();
    }
    if (v25)
    {
      uint64_t v27 = 0;
      uint64_t v28 = *(void *)(v5 + 192) + (v26 << 6);
      do
      {
        double result = (void *)(v28 + v27);
        void *result = v28 + v27 + 16;
        result[1] = 0x600000000;
        if (*(_DWORD *)(v24 + v27 + 8)) {
          double result = (void *)llvm::DirectedGraph<llvm::DDGNode,llvm::DDGEdge>::operator=((uint64_t)result, v24 + v27);
        }
        v27 += 64;
      }
      while (v25 << 6 != v27);
      LODWORD(v26) = *(_DWORD *)(v5 + 200);
    }
    *(_DWORD *)(v5 + 200) = v26 + v25;
  }
  return result;
}

uint64_t llvm::InstrProfWriter::addMemProfFrame(void *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6 = *a3;
  int v8 = *((_DWORD *)a3 + 2);
  int v7 = *((_DWORD *)a3 + 3);
  char v9 = *((unsigned char *)a3 + 16);
  uint64_t v30 = a2;
  int v31 = 0;
  sub_1CC48C3BC((uint64_t)(a1 + 11), &v30, &v31, (uint64_t)&v28);
  if (v29)
  {
    int v10 = (uint64_t *)a1[14];
    uint64_t v11 = (uint64_t *)a1[15];
    uint64_t v12 = (char *)v11 - (char *)v10;
    *(_DWORD *)(v28 + 8) = (unint64_t)((char *)v11 - (char *)v10) >> 5;
    unint64_t v13 = a1[16];
    if ((unint64_t)v11 >= v13)
    {
      uint64_t v19 = v12 >> 5;
      unint64_t v20 = (v12 >> 5) + 1;
      if (v20 >> 59) {
        abort();
      }
      uint64_t v21 = v13 - (void)v10;
      if (v21 >> 4 > v20) {
        unint64_t v20 = v21 >> 4;
      }
      if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFE0) {
        unint64_t v22 = 0x7FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v22 = v20;
      }
      if (v22 >> 59) {
        sub_1CB833614();
      }
      long long v23 = (char *)operator new(32 * v22);
      uint64_t v24 = &v23[32 * v19];
      *(void *)uint64_t v24 = a2;
      *((void *)v24 + sub_1CD7485C0(this + 1) = v6;
      *((_DWORD *)v24 + 4) = v8;
      *((_DWORD *)v24 + 5) = v7;
      v24[24] = v9;
      uint64_t v14 = v24 + 32;
      if (v11 != v10)
      {
        uint64_t v25 = 0;
        do
        {
          uint64_t v26 = &v24[v25 * 8];
          *((_OWORD *)v26 - 2) = *(_OWORD *)&v11[v25 - 4];
          *((void *)v26 - 2) = v11[v25 - 2];
          *(v26 - 8) = v11[v25 - 1];
          v25 -= 4;
        }
        while (&v11[v25] != v10);
        v24 += v25 * 8;
      }
      a1[14] = v24;
      a1[15] = v14;
      a1[16] = &v23[32 * v22];
      if (v10) {
        operator delete(v10);
      }
    }
    else
    {
      *uint64_t v11 = a2;
      v11[1] = v6;
      *((_DWORD *)v11 + 4) = v8;
      *((_DWORD *)v11 + 5) = v7;
      uint64_t v14 = (char *)(v11 + 4);
      *((unsigned char *)v11 + 24) = v9;
    }
    a1[15] = v14;
  }
  else
  {
    uint64_t v15 = a1[14];
    uint64_t v16 = *(unsigned int *)(v28 + 8);
    uint64_t v17 = v15 + 32 * v16;
    if (*a3 != *(void *)(v17 + 8)
      || *((_DWORD *)a3 + 2) != *(_DWORD *)(v17 + 16)
      || (uint64_t v18 = v15 + 32 * v16, *((_DWORD *)a3 + 3) != *(_DWORD *)(v18 + 20))
      || *((unsigned __int8 *)a3 + 16) != *(unsigned __int8 *)(v18 + 24))
    {
      operator new();
    }
  }
  return 1;
}

uint64_t llvm::InstrProfWriter::mergeRecordsFromWriter(int64x2_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(unsigned int *)(a2 + 16);
  int v8 = *(uint64_t **)(a2 + 8);
  if (v7)
  {
    while (!*v8 || *v8 == -8)
      ++v8;
  }
  uint64_t v10 = *(void *)(a2 + 8) + 8 * v7;
  if (v8 != (uint64_t *)v10)
  {
    uint64_t v11 = *v8;
    do
    {
      unsigned int v12 = *(_DWORD *)(v11 + 8);
      if (v12 > 1)
      {
        if (v12)
        {
          uint64_t v15 = (unint64_t *)(v11 + 16);
          uint64_t v17 = (unint64_t *)(v11 + 176);
        }
        else
        {
          uint64_t v15 = *(unint64_t **)(v11 + 16);
          unsigned int v16 = *(_DWORD *)(v11 + 24);
          if (!v16)
          {
            unsigned int v20 = 0;
            uint64_t v18 = *(unint64_t **)(v11 + 16);
            uint64_t v19 = v18;
            goto LABEL_26;
          }
          uint64_t v17 = &v15[5 * v16];
        }
        uint64_t v18 = v15;
        while (*v18 >= 0xFFFFFFFFFFFFFFFELL)
        {
          v18 += 5;
          if (v18 == v17)
          {
            uint64_t v18 = v17;
            break;
          }
        }
        uint64_t v15 = v17;
        if (*(_DWORD *)(v11 + 8))
        {
LABEL_25:
          uint64_t v19 = (unint64_t *)(v11 + 16);
          unsigned int v20 = 4;
          goto LABEL_26;
        }
      }
      else
      {
        if (v12)
        {
          uint64_t v13 = v11 + 16;
          unsigned int v14 = 4;
        }
        else
        {
          uint64_t v13 = *(void *)(v11 + 16);
          unsigned int v14 = *(_DWORD *)(v11 + 24);
        }
        uint64_t v18 = (unint64_t *)(v13 + 40 * v14);
        uint64_t v15 = v18;
        if (v12) {
          goto LABEL_25;
        }
      }
      uint64_t v19 = *(unint64_t **)(v11 + 16);
      unsigned int v20 = *(_DWORD *)(v11 + 24);
LABEL_26:
      uint64_t v21 = &v19[5 * v20];
      while (v18 != v21)
      {
        unint64_t v22 = (__n128 *)(v18 + 1);
        uint64_t v24 = *v18;
        long long v23 = v18 + 5;
        llvm::InstrProfWriter::addRecord((uint64_t)a1, (unsigned __int8 *)(v11 + 176), *(void *)v11, v24, v22, 1uLL, a3, a4);
        while (v23 != v15)
        {
          unint64_t v25 = *v23;
          v23 += 5;
          if (v25 <= 0xFFFFFFFFFFFFFFFDLL)
          {
            uint64_t v18 = v23 - 5;
            goto LABEL_32;
          }
        }
        uint64_t v18 = v15;
LABEL_32:
        ;
      }
      do
      {
        uint64_t v26 = v8[1];
        ++v8;
        uint64_t v11 = v26;
        if (v26) {
          BOOL v27 = v11 == -8;
        }
        else {
          BOOL v27 = 1;
        }
      }
      while (v27);
    }
    while (v8 != (uint64_t *)v10);
  }
  int64_t v28 = *(void *)(a2 + 120) - *(void *)(a2 + 112);
  sub_1CCCEE3C4(&a1[5].i64[1], v28 >> 5);
  char v29 = (unsigned char *)a1[7].i64[0];
  if (v28 >> 5 > (unint64_t)((a1[8].i64[0] - (uint64_t)v29) >> 5))
  {
    if (v28 < 0) {
      goto LABEL_68;
    }
    uint64_t v30 = (unsigned char *)a1[7].i64[1];
    int v31 = (char *)operator new(v28);
    unsigned int v32 = &v31[v30 - v29];
    long long v33 = v32;
    if (v30 != v29)
    {
      uint64_t v34 = 0;
      do
      {
        unsigned __int8 v35 = &v32[v34];
        *((_OWORD *)v35 - 2) = *(_OWORD *)&v30[v34 - 32];
        *((void *)v35 - 2) = *(void *)&v30[v34 - 16];
        *(v35 - 8) = v30[v34 - 8];
        v34 -= 32;
      }
      while (&v30[v34] != v29);
      long long v33 = &v32[v34];
    }
    a1[7].i64[0] = (uint64_t)v33;
    a1[7].i64[1] = (uint64_t)v32;
    a1[8].i64[0] = (uint64_t)&v31[32 * (v28 >> 5)];
    if (v29) {
      operator delete(v29);
    }
  }
  unsigned int v37 = *(uint64_t **)(a2 + 112);
  long long v36 = *(uint64_t **)(a2 + 120);
  while (v37 != v36)
  {
    uint64_t v39 = *v37;
    uint64_t v38 = v37 + 1;
    uint64_t result = llvm::InstrProfWriter::addMemProfFrame(a1, v39, v38);
    if ((result & 1) == 0) {
      return result;
    }
    unsigned int v37 = v38 + 3;
  }
  int64_t v41 = *(void *)(a2 + 72) - *(void *)(a2 + 64);
  unint64_t v42 = 0xF0F0F0F0F0F0F0F1 * (v41 >> 4);
  uint64_t result = (uint64_t)sub_1CCCEE3C4(&a1[2].i64[1], -252645135 * (v41 >> 4));
  uint64_t v43 = a1[5].i64[0];
  unint64_t v44 = a1[4].u64[0];
  if (0xF0F0F0F0F0F0F0F1 * ((uint64_t)(v43 - v44) >> 4) < v42)
  {
    if (v42 < 0xF0F0F0F0F0F0F1)
    {
      uint64_t v45 = a1[4].i64[1];
      unsigned int v62 = a1 + 5;
      unint64_t v46 = (char *)operator new(v41);
      size_t v47 = &v46[16 * (v41 >> 4)];
      __int16 v48 = &v46[v45 - v44];
      if (v45 == v44)
      {
        int64x2_t v54 = vdupq_n_s64(v44);
        unsigned int v55 = &v46[v45 - v44];
      }
      else
      {
        uint64_t v49 = 0;
        do
        {
          __int16 v50 = &v48[v49];
          uint64_t v51 = v45 + v49;
          *(void *)&v48[v49 - 272] = *(void *)(v45 + v49 - 272);
          unint64_t v52 = &v48[v49 - 264];
          *(void *)unint64_t v52 = &v48[v49 - 248];
          *(void *)&v48[v49 - 256] = 0x100000000;
          if (*(_DWORD *)(v45 + v49 - 256)) {
            sub_1CCCE8890((uint64_t)v52, v51 - 264);
          }
          *((void *)v50 - 10) = v50 - 64;
          uint64_t v53 = (uint64_t)(v50 - 80);
          *(void *)(v53 + 8) = 0x100000000;
          if (*(_DWORD *)(v51 - 72)) {
            sub_1CCCE8BEC(v53, v45 + v49 - 80);
          }
          v49 -= 272;
        }
        while (v45 + v49 != v44);
        int64x2_t v54 = a1[4];
        uint64_t v43 = a1[5].i64[0];
        unsigned int v55 = &v48[v49];
      }
      a1[4].i64[0] = (uint64_t)v55;
      a1[4].i64[1] = (uint64_t)v48;
      int64x2_t v60 = v54;
      a1[5].i64[0] = (uint64_t)v47;
      uint64_t v61 = v43;
      uint64_t v59 = v54.i64[0];
      uint64_t result = sub_1CCCEE35C((uint64_t)&v59);
      goto LABEL_64;
    }
LABEL_68:
    abort();
  }
LABEL_64:
  unint64_t v56 = *(uint64_t **)(a2 + 64);
  BOOL v57 = *(uint64_t **)(a2 + 72);
  while (v56 != v57)
  {
    uint64_t result = (uint64_t)llvm::InstrProfWriter::addMemProfRecord((uint64_t)a1, *v56, (uint64_t)(v56 + 1));
    v56 += 34;
  }
  return result;
}

uint64_t llvm::InstrProfWriter::shouldEncodeData(unsigned char *a1, uint64_t a2)
{
  if (!*a1) {
    return 1;
  }
  int v2 = *(_DWORD *)a2;
  if (*(_DWORD *)a2 > 1u)
  {
    if (v2)
    {
      uint64_t v4 = (unint64_t *)(a2 + 8);
      int v8 = (unint64_t *)(a2 + 168);
    }
    else
    {
      uint64_t v4 = *(unint64_t **)(a2 + 8);
      unsigned int v9 = *(_DWORD *)(a2 + 16);
      if (!v9)
      {
        int v2 = 0;
        unsigned int v5 = 0;
        uint64_t v7 = *(unint64_t **)(a2 + 8);
        int v8 = v7;
        goto LABEL_16;
      }
      int v8 = &v4[5 * v9];
    }
    int v2 = *(_DWORD *)a2 & 1;
    while (*v4 >= 0xFFFFFFFFFFFFFFFELL)
    {
      v4 += 5;
      if (v4 == v8)
      {
        uint64_t v4 = v8;
        break;
      }
    }
    uint64_t v7 = v4;
    uint64_t v4 = *(unint64_t **)(a2 + 8);
    unsigned int v5 = *(_DWORD *)(a2 + 16);
    goto LABEL_16;
  }
  uint64_t v3 = a2 + 8;
  uint64_t v4 = *(unint64_t **)(a2 + 8);
  unsigned int v5 = *(_DWORD *)(a2 + 16);
  if (v2)
  {
    unsigned int v6 = 4;
  }
  else
  {
    uint64_t v3 = *(void *)(a2 + 8);
    unsigned int v6 = *(_DWORD *)(a2 + 16);
  }
  uint64_t v7 = (unint64_t *)(v3 + 40 * v6);
  int v8 = v7;
LABEL_16:
  BOOL v10 = v2 == 0;
  if (v2) {
    uint64_t v11 = (unint64_t *)(a2 + 8);
  }
  else {
    uint64_t v11 = v4;
  }
  if (v10) {
    unsigned int v12 = v5;
  }
  else {
    unsigned int v12 = 4;
  }
  uint64_t v13 = &v11[5 * v12];
LABEL_23:
  while (v7 != v13)
  {
    for (uint64_t i = (void *)v7[1]; i != (void *)v7[2]; ++i)
    {
      if (*i) {
        return 1;
      }
    }
    uint64_t v15 = v7 + 5;
    while (v15 != v8)
    {
      unint64_t v16 = *v15;
      v15 += 5;
      if (v16 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        uint64_t v7 = v15 - 5;
        goto LABEL_23;
      }
    }
    uint64_t v7 = v8;
  }
  return 0;
}

void llvm::InstrProfWriter::writeImpl(uint64_t a1, uint64_t a2)
{
  uint64_t v151 = *MEMORY[0x1E4F143B8];
  uint64_t v144 = 0;
  uint64_t v145 = 0;
  long long v146 = v148;
  uint64_t v147 = 0x400000000;
  v148[4] = v149;
  v148[5] = 0;
  v149[0] = 0;
  v149[1] = 0;
  long long v143 = xmmword_1CFB2C510;
  uint64_t v3 = (char *)malloc_type_calloc(0x40uLL, 0x18uLL, 0x6D9A4F0CuLL);
  if (!v3) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  char v150 = v3;
  uint64_t v4 = operator new(0x40uLL);
  void v4[2] = xmmword_1CFB2C5A0;
  v4[3] = unk_1CFB2C5B0;
  *uint64_t v4 = xmmword_1CFB2C580;
  v4[1] = unk_1CFB2C590;
  char v133 = v134;
  v134[0] = 0;
  v134[1] = 0;
  v134[2] = v4;
  v134[3] = v4 + 4;
  v134[4] = v4 + 4;
  long long v135 = 0u;
  long long v136 = 0u;
  long long v137 = 0u;
  long long v138 = 0u;
  uint64_t v5 = *(void *)(a1 + 144);
  *(void *)(v5 + 8) = &v133;
  unsigned int v6 = operator new(0x40uLL);
  *unsigned int v6 = xmmword_1CFB2C580;
  v6[1] = unk_1CFB2C590;
  void v6[2] = xmmword_1CFB2C5A0;
  void v6[3] = unk_1CFB2C5B0;
  char v127 = v128;
  v128[0] = 0;
  v128[1] = 0;
  v128[2] = v6;
  v128[3] = v6 + 4;
  v128[4] = v6 + 4;
  long long v129 = 0u;
  long long v130 = 0u;
  long long v131 = 0u;
  long long v132 = 0u;
  *(void *)(v5 + 16) = &v127;
  uint64_t v7 = *(unsigned int *)(a1 + 16);
  uint64_t v115 = a1;
  int v8 = *(void **)(a1 + 8);
  if (v7)
  {
    while (!*v8 || *v8 == -8)
      ++v8;
  }
  uint64_t v9 = *(void *)(a1 + 8) + 8 * v7;
  if (v8 != (void *)v9)
  {
    uint64_t v21 = (void *)*v8;
    do
    {
      unint64_t v22 = v21 + 1;
      if (llvm::InstrProfWriter::shouldEncodeData((unsigned char *)a1, (uint64_t)(v21 + 1)))
      {
        size_t v25 = *v21;
        long long v23 = (int *)(v21 + 22);
        size_t v24 = v25;
        uint64_t v26 = v143;
        ++*((void *)&v143 + 1);
        if (3 * (uint64_t)v143 <= (unint64_t)(4 * *((void *)&v143 + 1)))
        {
          sub_1CCCEE410((uint64_t *)&v143, 2 * v143);
          uint64_t v26 = v143;
        }
        BOOL v27 = v150;
        v149[0] += 40;
        if (((unint64_t)(v144 + 7) & 0xFFFFFFFFFFFFFFF8) - (unint64_t)v144 + 40 > v145 - v144)
        {
          unsigned int v33 = v147 >> 7;
          if (v147 >> 7 >= 0x1E) {
            LOBYTE(v33) = 30;
          }
          uint64_t v34 = 4096 << v33;
          int64_t v28 = operator new(4096 << v33, (std::align_val_t)8uLL);
          if (v147 >= (unint64_t)HIDWORD(v147)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          v146[v147] = v28;
          LODWORD(v147) = v147 + 1;
          uint64_t v145 = (char *)v28 + v34;
        }
        else
        {
          int64_t v28 = (void *)((unint64_t)(v144 + 7) & 0xFFFFFFFFFFFFFFF8);
        }
        uint64_t v144 = (char *)(v28 + 5);
        void *v28 = v23;
        v28[1] = v24;
        _OWORD v28[2] = v22;
        v28[3] = 0;
        *(_OWORD *)unint64_t v140 = xmmword_1CFAC4320;
        *(void *)&v141[0] = 0;
        llvm::MD5::update((int *)v140, v23, v24);
        llvm::MD5::final((int *)v140, (int *)v139);
        uint64_t v29 = *(void *)v139;
        void v28[4] = *(void *)v139;
        uint64_t v30 = &v27[24 * (v29 & (v26 - 1))];
        v28[3] = *((void *)v30 + 2);
        ++*((_DWORD *)v30 + 2);
        *((void *)v30 + 2) = v28;
      }
      do
      {
        int v31 = (void *)v8[1];
        ++v8;
        uint64_t v21 = v31;
        if (v31) {
          BOOL v32 = v21 + 1 == 0;
        }
        else {
          BOOL v32 = 1;
        }
      }
      while (v32);
    }
    while (v8 != (void *)v9);
  }
  uint64_t v10 = 0;
  int v11 = *(_DWORD *)(a1 + 136);
  uint64_t v12 = 8;
  if ((v11 & 2) != 0) {
    uint64_t v12 = 0x100000000000008;
  }
  v124[0] = 0x8169666F72706CFFLL;
  v124[1] = v12 & 0xFDFFFFFFFFFFFFFFLL | ((((unint64_t)(v11 & 8) >> 3) & 1) << 57) | ((unint64_t)(v11 & 0x74) << 56);
  long long v125 = 0u;
  long long v126 = 0u;
  do
  {
    uint64_t v13 = (void *)v124[v10];
    unsigned int v14 = *(llvm::raw_ostream **)(a2 + 16);
    unint64_t v15 = bswap64((unint64_t)v13);
    if ((*(_DWORD *)(a2 + 24) - 1) >= 2) {
      uint64_t v13 = (void *)v15;
    }
    v140[0] = v13;
    llvm::raw_ostream::write(v14, (const char *)v140, 8uLL);
    ++v10;
  }
  while (v10 != 4);
  (*(uint64_t (**)(void))(**(void **)(a2 + 8) + 80))(*(void *)(a2 + 8));
  unint64_t v16 = *(llvm::raw_ostream **)(a2 + 16);
  v140[0] = 0;
  llvm::raw_ostream::write(v16, (const char *)v140, 8uLL);
  (*(uint64_t (**)(void))(**(void **)(a2 + 8) + 80))(*(void *)(a2 + 8));
  uint64_t v17 = *(llvm::raw_ostream **)(a2 + 16);
  v140[0] = 0;
  llvm::raw_ostream::write(v17, (const char *)v140, 8uLL);
  (*(uint64_t (**)(void))(**(void **)(a2 + 8) + 80))(*(void *)(a2 + 8));
  int v18 = 56;
  do
  {
    uint64_t v19 = *(llvm::raw_ostream **)(a2 + 16);
    v140[0] = 0;
    llvm::raw_ostream::write(v19, (const char *)v140, 8uLL);
    --v18;
  }
  while (v18);
  if ((*(unsigned char *)(a1 + 136) & 8) != 0)
  {
    (*(void (**)(void))(**(void **)(a2 + 8) + 80))(*(void *)(a2 + 8));
    int v35 = 56;
    do
    {
      long long v36 = *(llvm::raw_ostream **)(a2 + 16);
      v140[0] = 0;
      llvm::raw_ostream::write(v36, (const char *)v140, 8uLL);
      --v35;
    }
    while (v35);
  }
  if (*((void *)&v143 + 1) >= 3uLL)
  {
    unint64_t v38 = (4 * *((void *)&v143 + 1) / 6uLL) | (4 * *((void *)&v143 + 1) / 3uLL) | (((4
                                                                                           * *((void *)&v143 + 1)
                                                                                           / 6uLL) | (4 * *((void *)&v143 + 1) / 3uLL)) >> 2);
    unint64_t v39 = v38 | (v38 >> 4) | ((v38 | (v38 >> 4)) >> 8);
    size_t v37 = (((v39 | (v39 >> 16)) >> 32) | v39 | (v39 >> 16)) + 1;
  }
  else
  {
    size_t v37 = 1;
  }
  long long v40 = *(llvm::raw_ostream **)(a2 + 8);
  int64_t v41 = *(int **)(v115 + 144);
  if (v37 != (void)v143)
  {
    sub_1CCCEE410((uint64_t *)&v143, v37);
    size_t v37 = v143;
  }
  if (!v37)
  {
LABEL_113:
    uint64_t v92 = (*(uint64_t (**)(llvm::raw_ostream *))(*(void *)v40 + 80))(v40);
    uint64_t v93 = *((void *)v40 + 4);
    uint64_t v94 = *((void *)v40 + 2);
    uint64_t v95 = v93 - v94 + v92;
    unint64_t v96 = (v95 + 7) & 0xFFFFFFFFFFFFFFF8;
    if (v96 != v95)
    {
      unint64_t v97 = v92 + v93 - v94 - v96;
      do
      {
        LOBYTE(v140[0]) = 0;
        llvm::raw_ostream::write(v40, (const char *)v140, 1uLL);
      }
      while (!__CFADD__(v97++, 1));
    }
    v140[0] = (void *)v143;
    uint64_t v99 = llvm::raw_ostream::write(v40, (const char *)v140, 8uLL);
    v140[0] = *((void **)&v143 + 1);
    llvm::raw_ostream::write(v99, (const char *)v140, 8uLL);
    if ((void)v143)
    {
      uint64_t v100 = 0;
      unint64_t v101 = 0;
      do
      {
        v140[0] = *(void **)&v150[v100];
        llvm::raw_ostream::write(v40, (const char *)v140, 8uLL);
        ++v101;
        v100 += 24;
      }
      while (v101 < (unint64_t)v143);
    }
    if ((*(unsigned char *)(v115 + 136) & 0x40) != 0)
    {
      (*(uint64_t (**)(void))(**(void **)(a2 + 8) + 80))(*(void *)(a2 + 8));
      int64x2_t v102 = *(llvm::raw_ostream **)(a2 + 16);
      v140[0] = 0;
      llvm::raw_ostream::write(v102, (const char *)v140, 8uLL);
      BOOL v103 = *(llvm::raw_ostream **)(a2 + 16);
      v140[0] = 0;
      llvm::raw_ostream::write(v103, (const char *)v140, 8uLL);
      char v104 = *(llvm::raw_ostream **)(a2 + 16);
      v140[0] = 0;
      llvm::raw_ostream::write(v104, (const char *)v140, 8uLL);
      v140[0] = v141;
      v141[0] = xmmword_1CDF53750;
      v141[1] = xmmword_1CFB2C520;
      v141[2] = xmmword_1CFB2C530;
      v141[3] = xmmword_1CFB2C540;
      v141[4] = xmmword_1CFB2C550;
      v141[5] = xmmword_1CFB2C560;
      v141[6] = xmmword_1CF96C190;
      v141[7] = xmmword_1CFAC4720;
      v141[8] = xmmword_1CFB2C570;
      uint64_t v105 = 19;
      uint64_t v142 = 19;
      v140[1] = (void *)0x1400000013;
      uint64_t v106 = *(llvm::raw_ostream **)(a2 + 16);
      if ((*(_DWORD *)(a2 + 24) - 1) >= 2) {
        uint64_t v105 = 0x1300000000000000;
      }
      *(void *)size_t v139 = v105;
      llvm::raw_ostream::write(v106, v139, 8uLL);
      if (LODWORD(v140[1]))
      {
        unint64_t v107 = (unint64_t *)v140[0];
        uint64_t v108 = 8 * LODWORD(v140[1]);
        do
        {
          unint64_t v110 = *v107++;
          unint64_t v109 = v110;
          unsigned int v111 = *(llvm::raw_ostream **)(a2 + 16);
          unint64_t v112 = bswap64(v110);
          if ((*(_DWORD *)(a2 + 24) - 1) >= 2) {
            unint64_t v109 = v112;
          }
          *(void *)size_t v139 = v109;
          llvm::raw_ostream::write(v111, v139, 8uLL);
          v108 -= 8;
        }
        while (v108);
      }
      operator new();
    }
    unint64_t v113 = operator new(0x1C0uLL);
    _OWORD *v113 = 0u;
    v113[1] = 0u;
    v113[2] = 0u;
    v113[3] = 0u;
    v113[4] = 0u;
    v113[5] = 0u;
    v113[6] = 0u;
    v113[7] = 0u;
    v113[8] = 0u;
    v113[9] = 0u;
    v113[10] = 0u;
    v113[11] = 0u;
    v113[12] = 0u;
    v113[13] = 0u;
    v113[14] = 0u;
    v113[15] = 0u;
    v113[16] = 0u;
    v113[17] = 0u;
    v113[18] = 0u;
    v113[19] = 0u;
    v113[20] = 0u;
    v113[21] = 0u;
    v113[22] = 0u;
    v113[23] = 0u;
    v113[24] = 0u;
    v113[25] = 0u;
    v113[26] = 0u;
    v113[27] = 0u;
    llvm::InstrProfSummaryBuilder::getSummary((llvm::InstrProfSummaryBuilder *)&v133);
  }
  uint64_t v42 = 0;
  unsigned int v117 = v41;
  while (1)
  {
    uint64_t v116 = v42;
    uint64_t v43 = &v150[24 * v42];
    uint64_t v45 = *((void *)v43 + 2);
    unint64_t v44 = (uint64_t *)(v43 + 16);
    if (v45)
    {
      unint64_t v46 = &v150[24 * v42];
      *(void *)unint64_t v46 = (*(uint64_t (**)(llvm::raw_ostream *))(*(void *)v40 + 80))(v40)
                     + *((void *)v40 + 4)
                     - *((void *)v40 + 2);
      LOWORD(v140[0]) = *((_DWORD *)v46 + 2);
      llvm::raw_ostream::write(v40, (const char *)v140, 2uLL);
      uint64_t v47 = *v44;
      if (v47) {
        break;
      }
    }
LABEL_112:
    uint64_t v42 = v116 + 1;
    if (v116 + 1 >= (unint64_t)v143) {
      goto LABEL_113;
    }
  }
LABEL_52:
  uint64_t v119 = v47;
  v140[0] = *(void **)(v47 + 32);
  int64x2_t v54 = llvm::raw_ostream::write(v40, (const char *)v140, 8uLL);
  unint64_t v56 = *(void **)(v47 + 8);
  unsigned int v55 = *(int **)(v47 + 16);
  v140[0] = v56;
  llvm::raw_ostream::write(v54, (const char *)v140, 8uLL);
  int v57 = *v55;
  size_t v118 = (size_t)v56;
  if (*v55 > 1)
  {
    if (v57)
    {
      int64x2_t v60 = (unint64_t *)(v55 + 2);
      unsigned int v62 = (unint64_t *)(v55 + 42);
    }
    else
    {
      int64x2_t v60 = (unint64_t *)*((void *)v55 + 1);
      unsigned int v61 = v55[4];
      if (!v61)
      {
        unsigned int v48 = 0;
        uint64_t v49 = (unint64_t *)*((void *)v55 + 1);
        __int16 v50 = v49;
        goto LABEL_68;
      }
      unsigned int v62 = &v60[5 * v61];
    }
    uint64_t v49 = v60;
    do
    {
      if (*v49 < 0xFFFFFFFFFFFFFFFELL) {
        goto LABEL_63;
      }
      v49 += 5;
    }
    while (v49 != v62);
    uint64_t v49 = v62;
LABEL_63:
    int64x2_t v60 = v62;
    if (*v55) {
      goto LABEL_67;
    }
  }
  else
  {
    if (v57)
    {
      BOOL v58 = v55 + 2;
      unsigned int v59 = 4;
    }
    else
    {
      BOOL v58 = (int *)*((void *)v55 + 1);
      unsigned int v59 = v55[4];
    }
    uint64_t v49 = (unint64_t *)&v58[10 * v59];
    int64x2_t v60 = v49;
    if (v57)
    {
LABEL_67:
      __int16 v50 = (unint64_t *)(v55 + 2);
      unsigned int v48 = 4;
LABEL_68:
      size_t v120 = &v50[5 * v48];
      if (v49 == v120)
      {
        unint64_t v63 = 0;
      }
      else
      {
        unint64_t v63 = 0;
        do
        {
          char v123 = v63;
          uint64_t v64 = 0;
          unint64_t v122 = v49[1];
          unint64_t v121 = v49[2];
          uint64_t v65 = (uint64_t (*)(llvm *, const void *))off_1EC7DFB80[0];
          unint64_t v66 = (uint64_t (*)(llvm *, const void *))off_1EC7DFB88;
          char v67 = 1;
          unsigned int v68 = 8;
          do
          {
            char v69 = v67;
            int v70 = v65((llvm *)(v49 + 1), (const void *)v64);
            if (v70) {
              v68 += ((v70 + 15) & 0xFFFFFFF8) + 16 * v66((llvm *)(v49 + 1), (const void *)v64);
            }
            char v67 = 0;
            uint64_t v64 = 1;
          }
          while ((v69 & 1) != 0);
          unint64_t v63 = &v123[v121 - v122 + 16 + v68];
          unsigned int v71 = v49 + 5;
          while (v71 != v60)
          {
            unint64_t v72 = *v71;
            v71 += 5;
            if (v72 <= 0xFFFFFFFFFFFFFFFDLL)
            {
              uint64_t v49 = v71 - 5;
              goto LABEL_79;
            }
          }
          uint64_t v49 = v60;
LABEL_79:
          ;
        }
        while (v49 != v120);
      }
      v140[0] = v63;
      unsigned int v73 = llvm::raw_ostream::write(v40, (const char *)v140, 8uLL);
      llvm::raw_ostream::write(v73, *(const char **)v119, v118);
      int v74 = *(int **)(v119 + 16);
      int v75 = *v74;
      if (*v74 > 1)
      {
        uint64_t v76 = v117;
        if (v75)
        {
          unint64_t v79 = (unint64_t *)(v74 + 2);
          unsigned int v81 = (unint64_t *)(v74 + 42);
        }
        else
        {
          unint64_t v79 = (unint64_t *)*((void *)v74 + 1);
          unsigned int v80 = v74[4];
          if (!v80)
          {
            unsigned int v51 = 0;
            unint64_t v52 = v79;
            uint64_t v53 = v79;
LABEL_98:
            uint64_t v82 = &v53[5 * v51];
            while (1)
            {
              if (v52 == v82)
              {
                uint64_t v47 = *(void *)(v119 + 24);
                if (!v47) {
                  goto LABEL_112;
                }
                goto LABEL_52;
              }
              if ((*v52 & 0x1000000000000000) != 0) {
                unsigned int v83 = (uint64_t ***)(v76 + 4);
              }
              else {
                unsigned int v83 = (uint64_t ***)(v76 + 2);
              }
              llvm::InstrProfSummaryBuilder::addRecord(*v83, (uint64_t)(v52 + 1));
              v140[0] = (void *)*v52;
              int v84 = llvm::raw_ostream::write(v40, (const char *)v140, 8uLL);
              v140[0] = (void *)((uint64_t)(v52[2] - v52[1]) >> 3);
              llvm::raw_ostream::write(v84, (const char *)v140, 8uLL);
              BOOL v85 = (void **)v52[1];
              unint64_t v86 = (void **)v52[2];
              while (v85 != v86)
              {
                unint64_t v87 = *v85++;
                v140[0] = v87;
                llvm::raw_ostream::write(v40, (const char *)v140, 8uLL);
              }
              qword_1EC7DFB70 = (uint64_t)(v52 + 1);
              long long v88 = llvm::serializeValueProfDataFrom(&qword_1EC7DFB70, 0);
              size_t v89 = *v88;
              llvm::ValueProfData::swapBytesFromHost(v88, *v76);
              llvm::raw_ostream::write(v40, (const char *)v88, v89);
              operator delete(v88);
              uint64_t v90 = v52 + 5;
              while (2)
              {
                if (v90 == v79)
                {
                  unint64_t v52 = v79;
                }
                else
                {
                  unint64_t v91 = *v90;
                  v90 += 5;
                  if (v91 > 0xFFFFFFFFFFFFFFFDLL) {
                    continue;
                  }
                  unint64_t v52 = v90 - 5;
                }
                break;
              }
            }
          }
          unsigned int v81 = &v79[5 * v80];
        }
        unint64_t v52 = v79;
        do
        {
          if (*v52 < 0xFFFFFFFFFFFFFFFELL) {
            goto LABEL_93;
          }
          v52 += 5;
        }
        while (v52 != v81);
        unint64_t v52 = v81;
LABEL_93:
        unint64_t v79 = v81;
        if (*v74) {
          goto LABEL_97;
        }
      }
      else
      {
        uint64_t v76 = v117;
        if (v75)
        {
          unsigned int v77 = v74 + 2;
          unsigned int v78 = 4;
        }
        else
        {
          unsigned int v77 = (int *)*((void *)v74 + 1);
          unsigned int v78 = v74[4];
        }
        unint64_t v52 = (unint64_t *)&v77[10 * v78];
        unint64_t v79 = v52;
        if (v75)
        {
LABEL_97:
          uint64_t v53 = (unint64_t *)(v74 + 2);
          unsigned int v51 = 4;
          goto LABEL_98;
        }
      }
      uint64_t v53 = (unint64_t *)*((void *)v74 + 1);
      unsigned int v51 = v74[4];
      goto LABEL_98;
    }
  }
  __int16 v50 = (unint64_t *)*((void *)v55 + 1);
  unsigned int v48 = v55[4];
  goto LABEL_68;
}

std::string *sub_1CCCEC1E4(std::string *result, uint64_t a2, int a3)
{
  std::string::size_type size = (llvm::raw_fd_ostream *)result->__r_.__value_.__l.__size_;
  if (result->__r_.__value_.__s.__data_[0])
  {
    unsigned int v6 = result;
    uint64_t v7 = (*(uint64_t (**)(std::string::size_type))(*(void *)size + 80))(result->__r_.__value_.__l.__size_);
    uint64_t v8 = 0;
    uint64_t v25 = *((void *)size + 2);
    uint64_t v9 = v7 + *((void *)size + 4);
    do
    {
      uint64_t v10 = a2 + 24 * v8;
      llvm::raw_fd_ostream::seek(size, *(void *)v10);
      int v12 = *(_DWORD *)(v10 + 16);
      int v11 = (int *)(v10 + 16);
      if (v12 >= 1)
      {
        uint64_t v13 = 0;
        do
        {
          unint64_t v14 = *(void *)(*(void *)(a2 + 24 * v8 + 8) + 8 * v13);
          unint64_t v15 = (llvm::raw_ostream *)v6->__r_.__value_.__r.__words[2];
          unint64_t v16 = bswap64(v14);
          if ((LODWORD(v6[1].__r_.__value_.__l.__data_) - 1) >= 2) {
            unint64_t v14 = v16;
          }
          *(void *)long long __s = v14;
          llvm::raw_ostream::write(v15, __s, 8uLL);
          ++v13;
        }
        while (v13 < *v11);
      }
      ++v8;
    }
    while (v8 != a3);
    return (std::string *)llvm::raw_fd_ostream::seek(size, v9 - v25);
  }
  else
  {
    uint64_t v17 = 0;
    int v18 = (std::string *)*((void *)size + 8);
    do
    {
      uint64_t v20 = a2 + 24 * v17;
      int v22 = *(_DWORD *)(v20 + 16);
      uint64_t v21 = (int *)(v20 + 16);
      if (v22 >= 1)
      {
        uint64_t v23 = 0;
        size_t v24 = (void *)(a2 + 24 * v17);
        do
        {
          *(void *)long long __s = 0;
          *(void *)long long __s = *(void *)(v24[1] + 8 * v23);
          uint64_t result = std::string::replace(v18, *v24 + 8 * v23++, 8uLL, __s, 8uLL);
        }
        while (v23 < *v21);
      }
      ++v17;
    }
    while (v17 != a3);
  }
  return result;
}

double sub_1CCCEC380(uint64_t a1, void *a2)
{
  *(void *)(a1 + 32) = a2[7];
  *(void *)(a1 + 40) = a2[5];
  *(void *)(a1 + 48) = a2[6];
  *(void *)(a1 + 56) = a2[4];
  uint64_t v3 = a2[1];
  uint64_t v2 = a2[2];
  uint64_t v4 = a2[8];
  v5.i64[0] = v4;
  v5.i64[1] = HIDWORD(v4);
  int8x16_t v6 = vextq_s8(v5, v5, 8uLL);
  *(int8x16_t *)(a1 + 16) = v6;
  uint64_t v8 = v2 - v3;
  BOOL v7 = v8 == 0;
  unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 3);
  *(void *)a1 = 6;
  *(void *)(a1 + 8) = v9;
  if (!v7)
  {
    uint64_t v10 = (_OWORD *)(a1 + 72);
    int v11 = (long long *)(v3 + 8);
    unsigned int v12 = 1;
    do
    {
      *((void *)v10 - sub_1CD7485C0(this + 1) = *((unsigned int *)v11 - 2);
      long long v13 = *v11;
      int v11 = (long long *)((char *)v11 + 24);
      v6.i64[0] = v13;
      _OWORD *v10 = v13;
      uint64_t v10 = (_OWORD *)((char *)v10 + 24);
    }
    while (v9 > v12++);
  }
  return *(double *)v6.i64;
}

void llvm::InstrProfWriter::validateRecord(const llvm::InstrProfRecord *a1@<X1>, void *a2@<X8>)
{
  char v4 = 1;
  do
  {
    char v5 = v4;
    uint64_t v6 = *((void *)a1 + 3);
    if (v6)
    {
      if (v5) {
        uint64_t v7 = 0;
      }
      else {
        uint64_t v7 = 24;
      }
      uint64_t v8 = *(void *)(v6 + v7);
      uint64_t v9 = 32;
      if (v5) {
        uint64_t v9 = 8;
      }
      uint64_t v10 = -1431655765 * ((unint64_t)(*(void *)(v6 + v9) - v8) >> 3);
      if (v10)
      {
        for (uint64_t i = 0; i != v10; ++i)
        {
          if (v5) {
            uint64_t v12 = 0;
          }
          else {
            uint64_t v12 = 24;
          }
          if (*(void *)(*(void *)(*((void *)a1 + 3) + v12) + 24 * i + 16)) {
            operator new[]();
          }
        }
      }
    }
    char v4 = 0;
  }
  while ((v5 & 1) != 0);
  *a2 = 0;
}

void llvm::InstrProfWriter::write(llvm::InstrProfWriter *this, llvm::raw_fd_ostream *a2)
{
  v2[0] = 1;
  uint64_t v3 = a2;
  char v4 = a2;
  int v5 = 1;
  llvm::InstrProfWriter::writeImpl((uint64_t)this, (uint64_t)v2);
}

void llvm::InstrProfWriter::writeBuffer(llvm::InstrProfWriter *this)
{
  v14[6] = *MEMORY[0x1E4F143B8];
  memset(v14, 0, 24);
  int v6 = 0;
  char v10 = 0;
  uint64_t v11 = 0;
  long long v13 = v14;
  int v12 = 0;
  int v5 = &unk_1F2646F30;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  v1[0] = 0;
  uint64_t v2 = &v5;
  uint64_t v3 = &v5;
  int v4 = 1;
  llvm::InstrProfWriter::writeImpl((uint64_t)this, (uint64_t)v1);
}

llvm::raw_ostream *llvm::InstrProfWriter::writeRecordInText(const void *a1, size_t a2, unint64_t a3, unint64_t **a4, uint64_t *a5, llvm::raw_ostream *a6)
{
  uint64_t v11 = (unsigned char *)*((void *)a6 + 4);
  if (a2 <= *((void *)a6 + 3) - (void)v11)
  {
    if (a2)
    {
      memcpy(v11, a1, a2);
      uint64_t v11 = (unsigned char *)(*((void *)a6 + 4) + a2);
      *((void *)a6 + 4) = v11;
    }
  }
  else
  {
    llvm::raw_ostream::write(a6, (const char *)a1, a2);
    uint64_t v11 = (unsigned char *)*((void *)a6 + 4);
  }
  if (*((unsigned char **)a6 + 3) == v11)
  {
    llvm::raw_ostream::write(a6, "\n", 1uLL);
    int v12 = (void *)*((void *)a6 + 4);
  }
  else
  {
    *uint64_t v11 = 10;
    int v12 = (void *)(*((void *)a6 + 4) + 1);
    *((void *)a6 + 4) = v12;
  }
  if (*((void *)a6 + 3) - (void)v12 > 0xCuLL)
  {
    qmemcpy(v12, "# Func Hash:\n", 13);
    *((void *)a6 + 4) += 13;
  }
  else
  {
    llvm::raw_ostream::write(a6, "# Func Hash:\n", 0xDuLL);
  }
  sub_1CD098D14(a6, a3, 0, 0, 0);
  long long v13 = (unsigned char *)*((void *)a6 + 4);
  if (*((unsigned char **)a6 + 3) == v13)
  {
    llvm::raw_ostream::write(a6, "\n", 1uLL);
    unint64_t v14 = (_OWORD *)*((void *)a6 + 4);
  }
  else
  {
    unsigned char *v13 = 10;
    unint64_t v14 = (_OWORD *)(*((void *)a6 + 4) + 1);
    *((void *)a6 + 4) = v14;
  }
  if (*((void *)a6 + 3) - (void)v14 > 0xFuLL)
  {
    *unint64_t v14 = *(_OWORD *)"# Num Counters:\n";
    *((void *)a6 + 4) += 16;
  }
  else
  {
    llvm::raw_ostream::write(a6, "# Num Counters:\n", 0x10uLL);
  }
  uint64_t result = sub_1CD098D14(a6, a4[1] - *a4, 0, 0, 0);
  unint64_t v16 = (unsigned char *)*((void *)a6 + 4);
  if (*((unsigned char **)a6 + 3) == v16)
  {
    uint64_t result = llvm::raw_ostream::write(a6, "\n", 1uLL);
    uint64_t v17 = *((void *)a6 + 4);
  }
  else
  {
    *unint64_t v16 = 10;
    uint64_t v17 = *((void *)a6 + 4) + 1;
    *((void *)a6 + 4) = v17;
  }
  if ((unint64_t)(*((void *)a6 + 3) - v17) > 0x11)
  {
    *(_WORD *)(v17 + 16) = 2618;
    *(_OWORD *)uint64_t v17 = *(_OWORD *)"# Counter Values:\n";
    *((void *)a6 + 4) += 18;
  }
  else
  {
    uint64_t result = llvm::raw_ostream::write(a6, "# Counter Values:\n", 0x12uLL);
  }
  int v18 = *a4;
  uint64_t v19 = a4[1];
  if (*a4 != v19)
  {
    do
    {
      uint64_t result = sub_1CD098D14(a6, *v18, 0, 0, 0);
      uint64_t v20 = (unsigned char *)*((void *)a6 + 4);
      if (*((unsigned char **)a6 + 3) == v20)
      {
        uint64_t result = llvm::raw_ostream::write(a6, "\n", 1uLL);
      }
      else
      {
        *uint64_t v20 = 10;
        ++*((void *)a6 + 4);
      }
      ++v18;
    }
    while (v18 != v19);
  }
  uint64_t v21 = a4[3];
  if (!v21)
  {
    uint64_t v26 = *((void *)a6 + 4);
LABEL_35:
    uint64_t v33 = *((void *)a6 + 3);
    goto LABEL_113;
  }
  unint64_t v22 = *v21;
  unint64_t v23 = v21[1];
  unint64_t v24 = v21[3];
  unint64_t v25 = v21[4];
  uint64_t v26 = *((void *)a6 + 4);
  if (v23 == v22 && v25 == v24) {
    goto LABEL_35;
  }
  if ((unint64_t)(*((void *)a6 + 3) - v26) > 0x12)
  {
    *(_DWORD *)(v26 + 15) = 171602788;
    *(_OWORD *)uint64_t v26 = *(_OWORD *)"# Num Value Kinds:\n";
    *((void *)a6 + 4) += 19;
  }
  else
  {
    llvm::raw_ostream::write(a6, "# Num Value Kinds:\n", 0x13uLL);
  }
  int64_t v28 = a4[3];
  if (v28)
  {
    unint64_t v29 = *v28;
    unint64_t v30 = v28[1];
    BOOL v31 = v28[4] != v28[3];
    if (v30 == v29) {
      unint64_t v32 = v31;
    }
    else {
      unint64_t v32 = v31 + 1;
    }
  }
  else
  {
    unint64_t v32 = 0;
  }
  uint64_t result = sub_1CD098D14(a6, v32, 0, 0, 0);
  uint64_t v34 = (unsigned char *)*((void *)a6 + 4);
  if (*((unsigned char **)a6 + 3) == v34)
  {
    uint64_t result = llvm::raw_ostream::write(a6, "\n", 1uLL);
  }
  else
  {
    *uint64_t v34 = 10;
    ++*((void *)a6 + 4);
  }
  unint64_t v35 = 0;
  char v36 = 1;
  unsigned int v71 = a4;
  do
  {
    char v37 = v36;
    unint64_t v38 = a4[3];
    if (v38)
    {
      if (v37) {
        uint64_t v39 = 0;
      }
      else {
        uint64_t v39 = 3;
      }
      unint64_t v40 = v38[v39];
      uint64_t v41 = 4;
      if (v37) {
        uint64_t v41 = 1;
      }
      unint64_t v72 = -1431655765 * ((v38[v41] - v40) >> 3);
      if (v72)
      {
        uint64_t v42 = (void *)*((void *)a6 + 4);
        if (*((void *)a6 + 3) - (void)v42 > 0xDuLL)
        {
          qmemcpy(v42, "# ValueKind = ", 14);
          uint64_t v43 = (_WORD *)(*((void *)a6 + 4) + 14);
          *((void *)a6 + 4) = v43;
        }
        else
        {
          llvm::raw_ostream::write(a6, "# ValueKind = ", 0xEuLL);
          uint64_t v43 = (_WORD *)*((void *)a6 + 4);
        }
        unint64_t v44 = off_1E684F8A8[v35];
        size_t v45 = strlen(v44);
        size_t v46 = v45;
        if (v45 <= *((void *)a6 + 3) - (void)v43)
        {
          if (v45)
          {
            memcpy(v43, v44, v45);
            uint64_t v43 = (_WORD *)(*((void *)a6 + 4) + v46);
            *((void *)a6 + 4) = v43;
          }
        }
        else
        {
          llvm::raw_ostream::write(a6, v44, v45);
          uint64_t v43 = (_WORD *)*((void *)a6 + 4);
        }
        if (*((void *)a6 + 3) - (void)v43 > 1uLL)
        {
          *uint64_t v43 = 2618;
          *((void *)a6 + 4) += 2;
        }
        else
        {
          llvm::raw_ostream::write(a6, ":\n", 2uLL);
        }
        sub_1CD098D14(a6, v35, 0, 0, 0);
        uint64_t v47 = (unsigned char *)*((void *)a6 + 4);
        if (*((unsigned char **)a6 + 3) == v47)
        {
          llvm::raw_ostream::write(a6, "\n", 1uLL);
          uint64_t v48 = *((void *)a6 + 4);
        }
        else
        {
          *uint64_t v47 = 10;
          uint64_t v48 = *((void *)a6 + 4) + 1;
          *((void *)a6 + 4) = v48;
        }
        if ((unint64_t)(*((void *)a6 + 3) - v48) > 0x10)
        {
          *(unsigned char *)(v48 + 16) = 10;
          *(_OWORD *)uint64_t v48 = *(_OWORD *)"# NumValueSites:\n";
          *((void *)a6 + 4) += 17;
        }
        else
        {
          llvm::raw_ostream::write(a6, "# NumValueSites:\n", 0x11uLL);
        }
        sub_1CD098D14(a6, v72, 0, 0, 0);
        uint64_t v49 = (unsigned char *)*((void *)a6 + 4);
        if (*((unsigned char **)a6 + 3) == v49)
        {
          llvm::raw_ostream::write(a6, "\n", 1uLL);
        }
        else
        {
          *uint64_t v49 = 10;
          ++*((void *)a6 + 4);
        }
        uint64_t v50 = 0;
        while (1)
        {
          if (v37) {
            uint64_t v51 = 0;
          }
          else {
            uint64_t v51 = 3;
          }
          unint64_t v52 = *(unsigned int *)(a4[3][v51] + 24 * v50 + 16);
          uint64_t result = sub_1CD098D14(a6, v52, 0, 0, 0);
          uint64_t v53 = (unsigned char *)*((void *)a6 + 4);
          if (*((unsigned char **)a6 + 3) == v53)
          {
            uint64_t result = llvm::raw_ostream::write(a6, "\n", 1uLL);
          }
          else
          {
            *uint64_t v53 = 10;
            ++*((void *)a6 + 4);
          }
          if (v37) {
            uint64_t v54 = 0;
          }
          else {
            uint64_t v54 = 3;
          }
          if (*(void *)(a4[3][v54] + 24 * v50 + 16)) {
            operator new[]();
          }
          if (v52) {
            break;
          }
LABEL_101:
          if (++v50 == v72) {
            goto LABEL_104;
          }
        }
        uint64_t v55 = 0;
        while (1)
        {
          unint64_t v56 = *(void *)(16 * v55);
          if (v37)
          {
            sub_1CD5DF87C(a5);
            unsigned int v59 = (void *)a5[7];
            int64x2_t v60 = (void *)a5[8];
            if (v60 != v59)
            {
              unint64_t v61 = 0xAAAAAAAAAAAAAAABLL * (v60 - v59);
              do
              {
                unint64_t v62 = v61 >> 1;
                unint64_t v63 = &v59[3 * (v61 >> 1)];
                unint64_t v65 = *v63;
                uint64_t v64 = v63 + 3;
                v61 += ~(v61 >> 1);
                if (v65 < v56) {
                  unsigned int v59 = v64;
                }
                else {
                  unint64_t v61 = v62;
                }
              }
              while (v61);
            }
            if (v59 == v60 || *v59 != v56)
            {
              size_t v66 = 0;
              char v67 = 0;
            }
            else
            {
              char v67 = (const char *)v59[1];
              size_t v66 = v59[2];
            }
            if (v66) {
              unsigned int v68 = v67;
            }
            else {
              unsigned int v68 = "** External Symbol **";
            }
            if (v66) {
              size_t v69 = v66;
            }
            else {
              size_t v69 = 21;
            }
            int v70 = (void *)*((void *)a6 + 4);
            if (v69 <= *((void *)a6 + 3) - (void)v70)
            {
              memcpy(v70, v68, v69);
              int v57 = (unsigned char *)(*((void *)a6 + 4) + v69);
              *((void *)a6 + 4) = v57;
            }
            else
            {
              llvm::raw_ostream::write(a6, v68, v69);
              int v57 = (unsigned char *)*((void *)a6 + 4);
            }
            if (*((unsigned char **)a6 + 3) != v57)
            {
LABEL_99:
              *int v57 = 58;
              ++*((void *)a6 + 4);
              goto LABEL_75;
            }
          }
          else
          {
            sub_1CD098D14(a6, *(void *)(16 * v55), 0, 0, 0);
            int v57 = (unsigned char *)*((void *)a6 + 4);
            if (*((unsigned char **)a6 + 3) != v57) {
              goto LABEL_99;
            }
          }
          llvm::raw_ostream::write(a6, ":", 1uLL);
LABEL_75:
          sub_1CD098D14(a6, *(void *)(16 * v55 + 8), 0, 0, 0);
          BOOL v58 = (unsigned char *)*((void *)a6 + 4);
          if (*((unsigned char **)a6 + 3) == v58)
          {
            llvm::raw_ostream::write(a6, "\n", 1uLL);
          }
          else
          {
            *BOOL v58 = 10;
            ++*((void *)a6 + 4);
          }
          if (++v55 == v52)
          {
            a4 = v71;
            uint64_t result = (llvm::raw_ostream *)MEMORY[0x1D25D9CB0](0, 0x1000C80451B5BE8);
            goto LABEL_101;
          }
        }
      }
    }
LABEL_104:
    char v36 = 0;
    unint64_t v35 = 1;
  }
  while ((v37 & 1) != 0);
  uint64_t v33 = *((void *)a6 + 3);
  uint64_t v26 = *((void *)a6 + 4);
LABEL_113:
  if (v33 == v26)
  {
    return llvm::raw_ostream::write(a6, "\n", 1uLL);
  }
  else
  {
    *(unsigned char *)uint64_t v26 = 10;
    ++*((void *)a6 + 4);
  }
  return result;
}

void *llvm::InstrProfWriter::writeText@<X0>(llvm::InstrProfWriter *this@<X0>, llvm::raw_fd_ostream *a2@<X1>, void *a3@<X8>)
{
  v62[28] = *MEMORY[0x1E4F143B8];
  int v6 = *((_DWORD *)this + 34);
  if ((v6 & 8) != 0)
  {
    uint64_t v11 = (void *)*((void *)a2 + 4);
    if (*((void *)a2 + 3) - (void)v11 <= 0x27uLL)
    {
      uint64_t v8 = "# CSIR level Instrumentation Flag\n:csir\n";
      uint64_t v9 = a2;
      size_t v10 = 40;
      goto LABEL_7;
    }
    qmemcpy(v11, "# CSIR level Instrumentation Flag\n:csir\n", 40);
    uint64_t v50 = *((void *)a2 + 4) + 40;
LABEL_81:
    *((void *)a2 + 4) = v50;
    goto LABEL_8;
  }
  if ((v6 & 2) != 0)
  {
    uint64_t v7 = (void *)*((void *)a2 + 4);
    if (*((void *)a2 + 3) - (void)v7 <= 0x23uLL)
    {
      uint64_t v8 = "# IR level Instrumentation Flag\n:ir\n";
      uint64_t v9 = a2;
      size_t v10 = 36;
LABEL_7:
      llvm::raw_ostream::write(v9, v8, v10);
      goto LABEL_8;
    }
    qmemcpy(v7, "# IR level Instrumentation Flag\n:ir\n", 36);
    uint64_t v50 = *((void *)a2 + 4) + 36;
    goto LABEL_81;
  }
LABEL_8:
  if ((*((unsigned char *)this + 136) & 4) != 0)
  {
    int v12 = (void *)*((void *)a2 + 4);
    if (*((void *)a2 + 3) - (void)v12 > 0x39uLL)
    {
      qmemcpy(v12, "# Always instrument the function entry block\n:entry_first\n", 58);
      *((void *)a2 + 4) += 58;
    }
    else
    {
      llvm::raw_ostream::write(a2, "# Always instrument the function entry block\n:entry_first\n", 0x3AuLL);
    }
  }
  memset(v54, 0, sizeof(v54));
  int v55 = 8;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  memset(v59, 0, sizeof(v59));
  int64x2_t v60 = v62;
  uint64_t v61 = 0x400000000;
  uint64_t v13 = *((unsigned int *)this + 4);
  if (v13)
  {
    for (uint64_t i = (uint64_t *)*((void *)this + 1); !*i || *i == -8; ++i)
      ;
  }
  else
  {
    uint64_t i = (uint64_t *)*((void *)this + 1);
  }
  uint64_t v15 = *((void *)this + 1) + 8 * v13;
  unint64_t v16 = (char *)v62;
  uint64_t v17 = v62;
  if (i == (uint64_t *)v15)
  {
LABEL_61:
    uint64_t v41 = 0;
    goto LABEL_63;
  }
  uint64_t v18 = *i;
  do
  {
    if (!llvm::InstrProfWriter::shouldEncodeData(this, v18 + 8)) {
      goto LABEL_16;
    }
    sub_1CD74C38C((uint64_t)v54, (unsigned __int8 *)(v18 + 176), *(void *)v18, a3);
    if (*a3) {
      goto LABEL_71;
    }
    unsigned int v21 = *(_DWORD *)(v18 + 8);
    if (v21 <= 1)
    {
      if (v21)
      {
        uint64_t v22 = v18 + 16;
        unsigned int v23 = 4;
      }
      else
      {
        uint64_t v22 = *(void *)(v18 + 16);
        unsigned int v23 = *(_DWORD *)(v18 + 24);
      }
      BOOL v27 = (unint64_t *)(v22 + 40 * v23);
      unint64_t v24 = v27;
      if (!v21) {
        goto LABEL_35;
      }
LABEL_38:
      int64_t v28 = (unint64_t *)(v18 + 16);
      unsigned int v29 = 4;
      goto LABEL_39;
    }
    if (v21)
    {
      unint64_t v24 = (unint64_t *)(v18 + 16);
      uint64_t v26 = (unint64_t *)(v18 + 176);
      goto LABEL_30;
    }
    unint64_t v24 = *(unint64_t **)(v18 + 16);
    unsigned int v25 = *(_DWORD *)(v18 + 24);
    if (v25)
    {
      uint64_t v26 = &v24[5 * v25];
LABEL_30:
      BOOL v27 = v24;
      while (*v27 >= 0xFFFFFFFFFFFFFFFELL)
      {
        v27 += 5;
        if (v27 == v26)
        {
          BOOL v27 = v26;
          break;
        }
      }
      unint64_t v24 = v26;
      if ((*(_DWORD *)(v18 + 8) & 1) == 0)
      {
LABEL_35:
        int64_t v28 = *(unint64_t **)(v18 + 16);
        unsigned int v29 = *(_DWORD *)(v18 + 24);
        goto LABEL_39;
      }
      goto LABEL_38;
    }
    unsigned int v29 = 0;
    BOOL v27 = *(unint64_t **)(v18 + 16);
    int64_t v28 = v27;
LABEL_39:
    unint64_t v30 = &v28[5 * v29];
LABEL_40:
    while (v27 != v30)
    {
      size_t v31 = *(void *)v18;
      v52[0] = v18 + 176;
      v52[1] = v31;
      void v52[2] = *v27;
      sub_1CD74F1DC(v53, (uint64_t)(v27 + 1));
      unint64_t v32 = (char *)v60;
      if (v61 >= HIDWORD(v61))
      {
        unint64_t v39 = v61 + 1;
        if (v60 <= v52 && (char *)v60 + 56 * v61 > (char *)v52)
        {
          int64_t v51 = (char *)v52 - (unsigned char *)v60;
          sub_1CCCEE6A4((char **)&v60, v39);
          unint64_t v32 = (char *)v60;
          uint64_t v33 = (char *)v60 + v51;
        }
        else
        {
          sub_1CCCEE6A4((char **)&v60, v39);
          uint64_t v33 = (char *)v52;
          unint64_t v32 = (char *)v60;
        }
      }
      else
      {
        uint64_t v33 = (char *)v52;
      }
      uint64_t v34 = &v32[56 * v61];
      *(_OWORD *)uint64_t v34 = *(_OWORD *)v33;
      uint64_t v35 = *((void *)v33 + 2);
      *((_OWORD *)v34 + 2) = 0u;
      *((void *)v34 + 2) = v35;
      *((void *)v34 + 3) = 0;
      *(_OWORD *)(v34 + 24) = *(_OWORD *)(v33 + 24);
      *((void *)v34 + 5) = *((void *)v33 + 5);
      *(_OWORD *)(v33 + 24) = 0u;
      uint64_t v36 = *((void *)v33 + 6);
      *(_OWORD *)(v33 + 40) = 0u;
      *((void *)v34 + 6) = v36;
      LODWORD(v6sub_1CD7485C0(this + 1) = v61 + 1;
      sub_1CD69825C((uint64_t)v53);
      char v37 = v27 + 5;
      while (v37 != v24)
      {
        unint64_t v38 = *v37;
        v37 += 5;
        if (v38 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          BOOL v27 = v37 - 5;
          goto LABEL_40;
        }
      }
      BOOL v27 = v24;
    }
    do
    {
LABEL_16:
      uint64_t v19 = i[1];
      ++i;
      uint64_t v18 = v19;
      if (v19) {
        BOOL v20 = v18 == -8;
      }
      else {
        BOOL v20 = 1;
      }
    }
    while (v20);
  }
  while (i != (uint64_t *)v15);
  uint64_t v17 = v60;
  unint64_t v16 = (char *)v60 + 56 * v61;
  if (!v61) {
    goto LABEL_61;
  }
  uint64_t v41 = (unsigned char *)(126 - 2 * __clz(v61));
LABEL_63:
  sub_1CCCEE7E4((uint64_t)v17, (uint64_t)v16, v41, 1);
  if (!v61) {
    goto LABEL_70;
  }
  uint64_t v42 = (char *)v60;
  uint64_t v43 = (char *)v60 + 56 * v61;
  do
  {
    llvm::InstrProfWriter::writeRecordInText(*(const void **)v42, *((void *)v42 + 1), *((void *)v42 + 2), (unint64_t **)v42 + 3, (uint64_t *)v54, a2);
    v42 += 56;
  }
  while (v42 != v43);
  if (v61)
  {
    unint64_t v44 = (const llvm::InstrProfRecord *)((char *)v60 + 24);
    uint64_t v45 = 56 * v61;
    while (1)
    {
      llvm::InstrProfWriter::validateRecord(v44, a3);
      if (*a3) {
        break;
      }
      unint64_t v44 = (const llvm::InstrProfRecord *)((char *)v44 + 56);
      v45 -= 56;
      if (!v45) {
        goto LABEL_70;
      }
    }
  }
  else
  {
LABEL_70:
    *a3 = 0;
  }
LABEL_71:
  size_t v46 = v60;
  if (v61)
  {
    uint64_t v47 = (char *)v60 - 32;
    uint64_t v48 = 56 * v61;
    do
    {
      sub_1CD69825C((uint64_t)&v47[v48]);
      v48 -= 56;
    }
    while (v48);
    size_t v46 = v60;
  }
  if (v46 != v62) {
    free(v46);
  }
  return sub_1CD5DF60C(v54);
}

void sub_1CCCED5F0(void ***a1)
{
  int v1 = *a1;
  uint64_t v2 = (char **)**a1;
  if (v2)
  {
    int v4 = (char **)v1[1];
    int v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        int v6 = v4 - 34;
        uint64_t v7 = v4 - 33;
        sub_1CD4D68AC(v4 - 10);
        sub_1CD74EA50(v7);
        int v4 = v6;
      }
      while (v6 != v2);
      int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t *sub_1CCCED690(uint64_t *result, uint64_t *a2, unint64_t a3)
{
  if (a3 >= 2)
  {
    if (a3 == 2)
    {
      int v4 = (uint64_t *)*a2;
      if (*(void *)(*a2 + 24) > (unint64_t)result[3])
      {
        uint64_t v5 = *v4;
        *(void *)(v5 + 8) = v4[1];
        *(void *)v4[1] = v5;
        uint64_t v6 = *result;
        *(void *)(v6 + 8) = v4;
        *int v4 = v6;
        llvm::raw_ostream *result = (uint64_t)v4;
        v4[1] = (uint64_t)result;
        return v4;
      }
    }
    else
    {
      unint64_t v8 = a3 >> 1;
      unint64_t v9 = (a3 >> 1) + 1;
      size_t v10 = result;
      do
      {
        size_t v10 = (uint64_t *)v10[1];
        --v9;
      }
      while (v9 > 1);
      uint64_t v11 = (uint64_t *)sub_1CCCED690(result, v10, a3 >> 1);
      uint64_t result = (uint64_t *)sub_1CCCED690(v10, a2, a3 - v8);
      unint64_t v12 = v11[3];
      if (result[3] <= v12)
      {
        unint64_t v14 = (uint64_t *)v11[1];
        uint64_t i = result;
        uint64_t result = v11;
      }
      else
      {
        for (uint64_t i = (uint64_t *)result[1]; i != a2; uint64_t i = (uint64_t *)i[1])
        {
          if (i[3] <= v12) {
            goto LABEL_14;
          }
        }
        uint64_t i = a2;
LABEL_14:
        uint64_t v15 = *i;
        uint64_t v16 = *result;
        *(void *)(v16 + 8) = *(void *)(*i + 8);
        **(void **)(v15 + 8) = v16;
        uint64_t v17 = *v11;
        unint64_t v14 = (uint64_t *)v11[1];
        *(void *)(v17 + 8) = result;
        llvm::raw_ostream *result = v17;
        *uint64_t v11 = v15;
        *(void *)(v15 + 8) = v11;
      }
      if (v14 != i && i != a2)
      {
        uint64_t v18 = i;
        do
        {
          unint64_t v19 = v14[3];
          if (i[3] <= v19)
          {
            unint64_t v14 = (uint64_t *)v14[1];
          }
          else
          {
            for (unint64_t j = (uint64_t *)i[1]; j != a2; unint64_t j = (uint64_t *)j[1])
            {
              if (j[3] <= v19) {
                goto LABEL_25;
              }
            }
            unint64_t j = a2;
LABEL_25:
            uint64_t v21 = *j;
            uint64_t v22 = *i;
            *(void *)(v22 + 8) = *(void *)(*j + 8);
            **(void **)(v21 + 8) = v22;
            if (v18 == i) {
              uint64_t v18 = j;
            }
            uint64_t v24 = *v14;
            unsigned int v23 = (uint64_t *)v14[1];
            *(void *)(v24 + 8) = i;
            uint64_t *i = v24;
            *unint64_t v14 = v21;
            *(void *)(v21 + 8) = v14;
            unint64_t v14 = v23;
            uint64_t i = j;
          }
        }
        while (v14 != v18 && i != a2);
      }
    }
  }
  return result;
}

void *sub_1CCCED85C(llvm::StringMapImpl *a1, unsigned __int8 *a2, size_t __n)
{
  unsigned int v5 = *((_DWORD *)a1 + 2);
  if (!v5)
  {
    *((_DWORD *)a1 + 3) = 0;
    *((_DWORD *)a1 + 4) = 0;
    uint64_t v26 = malloc_type_calloc(0x11uLL, 0xCuLL, 0x6D9A4F0CuLL);
    if (!v26) {
      llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
    }
    v26[16] = 2;
    *(void *)a1 = v26;
    unsigned int v5 = 16;
    *((_DWORD *)a1 + 2) = 16;
  }
  int v6 = 0;
  if (__n)
  {
    size_t v7 = __n;
    unint64_t v8 = a2;
    do
    {
      int v9 = *v8++;
      int v6 = 33 * v6 + v9;
      --v7;
    }
    while (v7);
  }
  uint64_t v10 = *(void *)a1;
  unsigned int v11 = v5 - 1;
  uint64_t v12 = *(void *)a1 + 8 * v5 + 8;
  int v13 = -1;
  int v14 = 1;
  int v15 = v6;
  while (1)
  {
    uint64_t v16 = v15 & v11;
    uint64_t v17 = *(void **)(v10 + 8 * v16);
    if (!v17) {
      break;
    }
    if (v17 == (void *)-8)
    {
      if (v13 == -1) {
        int v13 = v15 & v11;
      }
    }
    else if (*(_DWORD *)(v12 + 4 * v16) == v6 {
           && __n == *v17
    }
           && (!__n || !memcmp(a2, (char *)v17 + *((unsigned int *)a1 + 5), __n)))
    {
      goto LABEL_20;
    }
    int v15 = v14 + v16;
    ++v14;
  }
  uint64_t v18 = v13;
  if (v13 == -1)
  {
    uint64_t v18 = v16;
    uint64_t v16 = v16;
  }
  else
  {
    uint64_t v16 = v13;
  }
  *(_DWORD *)(v12 + 4 * v18) = v6;
  uint64_t v17 = *(void **)(v10 + 8 * v16);
LABEL_20:
  unint64_t j = (void *)(v10 + 8 * v16);
  if (v17 == (void *)-8)
  {
    --*((_DWORD *)a1 + 4);
  }
  else if (v17)
  {
    return j;
  }
  uint64_t v21 = operator new(__n + 177, (std::align_val_t)8uLL);
  uint64_t v22 = v21;
  unsigned int v23 = (char *)(v21 + 22);
  if (__n) {
    memcpy(v21 + 22, a2, __n);
  }
  v23[__n] = 0;
  void *v22 = __n;
  v22[1] = 1;
  for (uint64_t i = 2; i != 22; i += 5)
    v22[i] = -1;
  *unint64_t j = v22;
  ++*((_DWORD *)a1 + 3);
  for (unint64_t j = (void *)(*(void *)a1 + 8 * llvm::StringMapImpl::RehashTable(a1, v16));
        !*j || *j == -8;
  return j;
}

uint64_t sub_1CCCEDA74(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v20 = 0;
  uint64_t result = sub_1CCCEDBE0(a2, *a3, &v20);
  uint64_t v9 = v20;
  unsigned int v10 = *(_DWORD *)a2;
  if (result)
  {
    if (v10)
    {
      uint64_t v11 = a2 + 8;
      unsigned int v12 = 4;
    }
    else
    {
      uint64_t v11 = *(void *)(a2 + 8);
      unsigned int v12 = *(_DWORD *)(a2 + 16);
    }
    char v15 = 0;
    uint64_t v16 = v11 + 40 * v12;
    goto LABEL_17;
  }
  unsigned int v13 = v10 >> 1;
  if (v10) {
    unsigned int v14 = 4;
  }
  else {
    unsigned int v14 = *(_DWORD *)(a2 + 16);
  }
  if (4 * v13 + 4 >= 3 * v14)
  {
    v14 *= 2;
    goto LABEL_19;
  }
  if (v14 + ~v13 - *(_DWORD *)(a2 + 4) <= v14 >> 3)
  {
LABEL_19:
    sub_1CCCEDC90(a2, v14);
    uint64_t v20 = 0;
    uint64_t result = sub_1CCCEDBE0(a2, *a3, &v20);
    uint64_t v9 = v20;
  }
  *(_DWORD *)a2 += 2;
  if (*(void *)v9 != -1) {
    --*(_DWORD *)(a2 + 4);
  }
  *(void *)uint64_t v9 = *a3;
  *(void *)(v9 + 8) = 0;
  *(_OWORD *)(v9 + 16) = 0u;
  *(_OWORD *)(v9 + 8) = *(_OWORD *)a4;
  *(void *)(v9 + 24) = *(void *)(a4 + 16);
  uint64_t v17 = *(void *)(a4 + 24);
  *(_OWORD *)a4 = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  *(void *)(v9 + 32) = v17;
  uint64_t v18 = a2 + 8;
  if (*(unsigned char *)a2)
  {
    unsigned int v19 = 4;
  }
  else
  {
    uint64_t v18 = *(void *)(a2 + 8);
    unsigned int v19 = *(_DWORD *)(a2 + 16);
  }
  uint64_t v16 = v18 + 40 * v19;
  char v15 = 1;
LABEL_17:
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v16;
  *(unsigned char *)(a1 + 16) = v15;
  return result;
}

uint64_t sub_1CCCEDBE0(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 4;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      size_t v7 = 0;
      uint64_t result = 0;
      goto LABEL_7;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = (v4 - 1) & (37 * a2);
  size_t v7 = (void *)(v3 + 40 * v6);
  uint64_t v8 = *v7;
  if (*v7 == a2)
  {
    uint64_t result = 1;
  }
  else
  {
    unsigned int v10 = 0;
    int v11 = 1;
    uint64_t result = 1;
    while (v8 != -1)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -2;
      }
      if (v12) {
        unsigned int v10 = v7;
      }
      unsigned int v13 = v6 + v11++;
      unsigned int v6 = v13 & v5;
      size_t v7 = (void *)(v3 + 40 * (v13 & v5));
      uint64_t v8 = *v7;
      if (*v7 == a2) {
        goto LABEL_7;
      }
    }
    uint64_t result = 0;
    if (v10) {
      size_t v7 = v10;
    }
  }
LABEL_7:
  *a3 = v7;
  return result;
}

uint64_t sub_1CCCEDC90(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = a2;
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (a2 >= 5)
  {
    unint64_t v4 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v5 = v4 | (v4 >> 2) | ((v4 | (v4 >> 2)) >> 4);
    int v6 = ((v5 | (v5 >> 8)) >> 16) | v5 | (v5 >> 8);
    if ((v6 + 1) > 0x40) {
      unsigned int v2 = v6 + 1;
    }
    else {
      unsigned int v2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    uint64_t v7 = *(void *)(a1 + 8);
    unsigned int v8 = *(_DWORD *)(a1 + 16);
    if (v2 > 4)
    {
      *(void *)(a1 + 8) = operator new(40 * v2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v2;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CCCEDE68(a1, v7, v7 + 40 * v8);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v9 = 0;
  unsigned int v10 = v17;
  do
  {
    uint64_t v11 = a1 + v9;
    unint64_t v12 = *(void *)(a1 + v9 + 8);
    if (v12 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      *(void *)unsigned int v10 = v12;
      *((void *)v10 + sub_1CD7485C0(this + 1) = 0;
      *((_OWORD *)v10 + sub_1CD7485C0(this + 1) = 0u;
      long long v14 = *(_OWORD *)(v11 + 16);
      uint64_t v13 = v11 + 16;
      *(_OWORD *)(v10 + 8) = v14;
      *((void *)v10 + 3) = *(void *)(v13 + 16);
      uint64_t v15 = *(void *)(v13 + 24);
      *(_OWORD *)uint64_t v13 = 0u;
      *(_OWORD *)(v13 + 16) = 0u;
      *((void *)v10 + 4) = v15;
      v10 += 40;
      sub_1CD69825C(v13);
    }
    v9 += 40;
  }
  while (v9 != 160);
  if (v2 > 4)
  {
    *(_DWORD *)a1 &= ~1u;
    *(void *)(a1 + 8) = operator new(40 * v2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v2;
  }
  return sub_1CCCEDE68(a1, (uint64_t)v17, (uint64_t)v10);
}

uint64_t sub_1CCCEDE68(uint64_t result, uint64_t a2, uint64_t a3)
{
  unint64_t v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    unsigned int v8 = (void *)(result + 8);
    uint64_t v9 = (void *)(result + 168);
  }
  else
  {
    unsigned int v7 = *(_DWORD *)(result + 16);
    if (!v7) {
      goto LABEL_10;
    }
    unsigned int v8 = *(void **)(result + 8);
    uint64_t v9 = &v8[5 * v7];
  }
  do
  {
    void *v8 = -1;
    v8 += 5;
  }
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    uint64_t v10 = *(void *)a2;
    if (*(void *)a2 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      uint64_t v13 = 0;
      sub_1CCCEDBE0((uint64_t)v5, v10, &v13);
      uint64_t v11 = v13;
      void *v13 = *(void *)a2;
      v11[1] = 0;
      *((_OWORD *)v11 + sub_1CD7485C0(this + 1) = 0u;
      *(_OWORD *)(v11 + sub_1CD7485C0(this + 1) = *(_OWORD *)(a2 + 8);
      v11[3] = *(void *)(a2 + 24);
      uint64_t v12 = *(void *)(a2 + 32);
      *(_OWORD *)(a2 + 8) = 0u;
      *(_OWORD *)(a2 + 24) = 0u;
      v11[4] = v12;
      *v5 += 2;
      uint64_t result = sub_1CD69825C(a2 + 8);
    }
    a2 += 40;
  }
  return result;
}

void sub_1CCCEDF58()
{
}

uint64_t sub_1CCCEE018(void *a1, void *a2, uint64_t a3)
{
  uint64_t v10 = *a2;
  int v11 = 0;
  sub_1CC48C3BC((uint64_t)a1, &v10, &v11, (uint64_t)v12);
  int v6 = (int64x2_t *)(a1 + 3);
  if (!v13) {
    return v6->i64[0] + 272 * *((unsigned int *)v12[0] + 2);
  }
  unsigned int v7 = (void *)a1[4];
  *((_DWORD *)v12[0] + 2) = -252645135 * (((unint64_t)v7 - a1[3]) >> 4);
  v12[0] = a2;
  uint64_t v10 = a3;
  if ((unint64_t)v7 >= a1[5])
  {
    unsigned int v8 = sub_1CCCEE154(v6, (uint64_t)&std::piecewise_construct, v12, &v10);
  }
  else
  {
    *unsigned int v7 = *a2;
    v7[1] = v7 + 3;
    void v7[2] = 0x100000000;
    if (*(_DWORD *)(a3 + 8)) {
      sub_1CCCE8890((uint64_t)(v7 + 1), a3);
    }
    v7[24] = v7 + 26;
    v7[25] = 0x100000000;
    if (*(_DWORD *)(a3 + 192)) {
      sub_1CCCE8BEC((uint64_t)(v7 + 24), a3 + 184);
    }
    unsigned int v8 = v7 + 34;
  }
  a1[4] = v8;
  return (uint64_t)(v8 - 34);
}

void *sub_1CCCEE154(int64x2_t *a1, uint64_t a2, void **a3, uint64_t *a4)
{
  unint64_t v4 = 0xF0F0F0F0F0F0F0F1 * ((a1->i64[1] - a1->i64[0]) >> 4);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xF0F0F0F0F0F0F0) {
    abort();
  }
  if (0xE1E1E1E1E1E1E1E2 * ((a1[1].i64[0] - a1->i64[0]) >> 4) > v5) {
    unint64_t v5 = 0xE1E1E1E1E1E1E1E2 * ((a1[1].i64[0] - a1->i64[0]) >> 4);
  }
  if (0xF0F0F0F0F0F0F0F1 * ((a1[1].i64[0] - a1->i64[0]) >> 4) >= 0x78787878787878) {
    unint64_t v9 = 0xF0F0F0F0F0F0F0;
  }
  else {
    unint64_t v9 = v5;
  }
  unint64_t v30 = a1 + 1;
  if (v9)
  {
    if (v9 > 0xF0F0F0F0F0F0F0) {
      sub_1CB833614();
    }
    uint64_t v10 = (char *)operator new(272 * v9);
  }
  else
  {
    uint64_t v10 = 0;
  }
  int v11 = &v10[272 * v4];
  BOOL v27 = v10;
  v28.i64[0] = (uint64_t)v11;
  uint64_t v12 = &v10[272 * v9];
  unsigned int v29 = v12;
  uint64_t v13 = *a4;
  *(void *)int v11 = **a3;
  *((void *)v11 + sub_1CD7485C0(this + 1) = v11 + 24;
  *((void *)v11 + 2) = 0x100000000;
  if (*(_DWORD *)(v13 + 8)) {
    sub_1CCCE8890((uint64_t)(v11 + 8), v13);
  }
  long long v14 = &v10[272 * v4];
  *((void *)v14 + 24) = v14 + 208;
  uint64_t v15 = (uint64_t)(v14 + 192);
  *(void *)(v15 + 8) = 0x100000000;
  if (*(_DWORD *)(v13 + 192)) {
    sub_1CCCE8BEC(v15, v13 + 184);
  }
  uint64_t v16 = v11 + 272;
  v28.i64[1] = (uint64_t)(v11 + 272);
  uint64_t v18 = a1->i64[0];
  unint64_t v17 = a1->u64[1];
  if (v17 == a1->i64[0])
  {
    int64x2_t v24 = vdupq_n_s64(v17);
  }
  else
  {
    uint64_t v19 = 0;
    do
    {
      uint64_t v20 = &v11[v19];
      unint64_t v21 = v17 + v19;
      *(void *)&v11[v19 - 272] = *(void *)(v17 + v19 - 272);
      uint64_t v22 = &v11[v19 - 264];
      *(void *)uint64_t v22 = &v11[v19 - 248];
      *(void *)&v11[v19 - 256] = 0x100000000;
      if (*(_DWORD *)(v17 + v19 - 256)) {
        sub_1CCCE8890((uint64_t)v22, v21 - 264);
      }
      *((void *)v20 - 10) = v20 - 64;
      uint64_t v23 = (uint64_t)(v20 - 80);
      *(void *)(v23 + 8) = 0x100000000;
      if (*(_DWORD *)(v21 - 72)) {
        sub_1CCCE8BEC(v23, v17 + v19 - 80);
      }
      v19 -= 272;
    }
    while (v17 + v19 != v18);
    int64x2_t v24 = *a1;
    v11 += v19;
    uint64_t v16 = (void *)v28.i64[1];
    uint64_t v12 = v29;
  }
  a1->i64[0] = (uint64_t)v11;
  a1->i64[1] = (uint64_t)v16;
  int64x2_t v28 = v24;
  unsigned int v25 = (char *)a1[1].i64[0];
  a1[1].i64[0] = (uint64_t)v12;
  unsigned int v29 = v25;
  BOOL v27 = (char *)v24.i64[0];
  sub_1CCCEE35C((uint64_t)&v27);
  return v16;
}

uint64_t sub_1CCCEE35C(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 272;
    unint64_t v4 = (char **)(i - 264);
    sub_1CD4D68AC((char **)(i - 80));
    sub_1CD74EA50(v4);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *sub_1CCCEE3C4(void *result, int a2)
{
  if (a2)
  {
    unint64_t v2 = (4 * a2 / 3u + 1) | ((unint64_t)(4 * a2 / 3u + 1) >> 1);
    unint64_t v3 = v2 | (v2 >> 2) | ((v2 | (v2 >> 2)) >> 4);
    unsigned int v4 = ((v3 | (v3 >> 8)) >> 16) | v3 | (v3 >> 8);
    if (*((_DWORD *)result + 4) <= v4) {
      return sub_1CD541698((uint64_t)result, v4 + 1);
    }
  }
  return result;
}

void sub_1CCCEE410(uint64_t *a1, size_t count)
{
  unsigned int v4 = malloc_type_calloc(count, 0x18uLL, 0x6D9A4F0CuLL);
  if (!v4 && (count || (unsigned int v4 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0)) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  uint64_t v5 = *a1;
  int v6 = (void *)a1[14];
  if (*a1)
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = v6[3 * v7 + 2];
      if (v8)
      {
        do
        {
          uint64_t v9 = *(void *)(v8 + 24);
          size_t v10 = (size_t)v4 + 24 * (*(void *)(v8 + 32) & (count - 1));
          *(void *)(v8 + 24) = *(void *)(v10 + 16);
          ++*(_DWORD *)(v10 + 8);
          *(void *)(v10 + 16) = v8;
          uint64_t v8 = v9;
        }
        while (v9);
      }
      ++v7;
    }
    while (v7 != v5);
  }
  free(v6);
  *a1 = count;
  a1[14] = (uint64_t)v4;
}

void sub_1CCCEE4EC(uint64_t *a1, size_t count)
{
  unsigned int v4 = malloc_type_calloc(count, 0x18uLL, 0x6D9A4F0CuLL);
  if (!v4 && (count || (unsigned int v4 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0)) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  uint64_t v5 = *a1;
  int v6 = (void *)a1[14];
  if (*a1)
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = v6[3 * v7 + 2];
      if (v8)
      {
        do
        {
          uint64_t v9 = *(void *)(v8 + 272);
          size_t v10 = (size_t)v4 + 24 * (*(void *)(v8 + 280) & (count - 1));
          *(void *)(v8 + 272) = *(void *)(v10 + 16);
          ++*(_DWORD *)(v10 + 8);
          *(void *)(v10 + 16) = v8;
          uint64_t v8 = v9;
        }
        while (v9);
      }
      ++v7;
    }
    while (v7 != v5);
  }
  free(v6);
  *a1 = count;
  a1[14] = (uint64_t)v4;
}

void sub_1CCCEE5C8(uint64_t *a1, size_t count)
{
  unsigned int v4 = malloc_type_calloc(count, 0x18uLL, 0x6D9A4F0CuLL);
  if (!v4 && (count || (unsigned int v4 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0)) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  uint64_t v5 = *a1;
  int v6 = (void *)a1[14];
  if (*a1)
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = v6[3 * v7 + 2];
      if (v8)
      {
        do
        {
          uint64_t v9 = *(void *)(v8 + 32);
          size_t v10 = (size_t)v4 + 24 * (*(void *)(v8 + 40) & (count - 1));
          *(void *)(v8 + 32) = *(void *)(v10 + 16);
          ++*(_DWORD *)(v10 + 8);
          *(void *)(v10 + 16) = v8;
          uint64_t v8 = v9;
        }
        while (v9);
      }
      ++v7;
    }
    while (v7 != v5);
  }
  free(v6);
  *a1 = count;
  a1[14] = (uint64_t)v4;
}

void sub_1CCCEE6A4(char **a1, unint64_t a2)
{
  if (HIDWORD(a2)) {
    sub_1CD0A88F0(a2);
  }
  uint64_t v3 = *((unsigned int *)a1 + 3);
  if (v3 == -1) {
    sub_1CD0A89A8(0xFFFFFFFFuLL);
  }
  unint64_t v4 = (2 * v3) | 1;
  if (v4 <= a2) {
    unint64_t v4 = a2;
  }
  if (v4 >= 0xFFFFFFFF) {
    uint64_t v5 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v5 = v4;
  }
  int v6 = (char *)malloc_type_malloc(56 * v5, 0x4065EBACuLL);
  if (!v6) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  uint64_t v7 = v6;
  uint64_t v8 = *a1;
  int v9 = *((_DWORD *)a1 + 2);
  if (v9)
  {
    size_t v10 = &v8[56 * v9];
    int v11 = v7;
    do
    {
      *int v11 = *(_OWORD *)v8;
      uint64_t v12 = *((void *)v8 + 2);
      _OWORD v11[2] = 0uLL;
      *((void *)v11 + 2) = v12;
      *((void *)v11 + 3) = 0;
      *(_OWORD *)((char *)v11 + 24) = *(_OWORD *)(v8 + 24);
      *((void *)v11 + 5) = *((void *)v8 + 5);
      *(_OWORD *)(v8 + 24) = 0uLL;
      uint64_t v13 = *((void *)v8 + 6);
      *(_OWORD *)(v8 + 40) = 0uLL;
      *((void *)v11 + 6) = v13;
      v8 += 56;
      int v11 = (_OWORD *)((char *)v11 + 56);
    }
    while (v8 != v10);
    uint64_t v8 = *a1;
    uint64_t v14 = *((unsigned int *)a1 + 2);
    if (v14)
    {
      uint64_t v15 = v8 - 32;
      uint64_t v16 = 56 * v14;
      do
      {
        sub_1CD69825C((uint64_t)&v15[v16]);
        v16 -= 56;
      }
      while (v16);
      uint64_t v8 = *a1;
    }
  }
  if (v8 != (char *)(a1 + 2)) {
    free(v8);
  }
  *a1 = v7;
  *((_DWORD *)a1 + 3) = v5;
}

uint64_t sub_1CCCEE7E4(uint64_t result, uint64_t a2, unsigned char *a3, int a4)
{
  LODWORD(v116) = a4;
  uint64_t v7 = result;
  unsigned int v117 = &v124;
  size_t v118 = (_OWORD *)a2;
  while (2)
  {
    unint64_t v8 = (unint64_t)v118;
    int v9 = (_OWORD *)((char *)v118 - 56);
    uint64_t v112 = (uint64_t)v118 - 168;
    uint64_t v113 = (uint64_t)(v118 - 7);
    unsigned int v111 = (void *)v118 - 5;
    unint64_t v10 = v7;
    char v114 = (_OWORD *)((char *)v118 - 56);
    while (1)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v7 = v10;
          uint64_t v11 = v8 - v10;
          uint64_t v12 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v8 - v10) >> 3);
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0:
              case 1:
                return result;
              case 2:
                uint64_t result = sub_1CCCEFD24((uint64_t)v9, v111, v7, (void *)(v7 + 16));
                if (result)
                {
                  *(_OWORD *)char v123 = *(_OWORD *)v7;
                  *(_OWORD *)uint64_t v7 = *v9;
                  _OWORD *v9 = *(_OWORD *)v123;
                  long long v90 = *(_OWORD *)(v7 + 24);
                  size_t v89 = (void *)(v7 + 24);
                  *(void *)char v123 = *(v89 - 1);
                  uint64_t v91 = *(void *)v123;
                  unint64_t v92 = v89[3];
                  v124.n128_u64[0] = v89[2];
                  *(_OWORD *)&v123[8] = v90;
                  void *v89 = 0;
                  v89[1] = 0;
                  v89[2] = 0;
                  v89[3] = 0;
                  v124.n128_u64[1] = v92;
                  uint64_t v93 = (uint64_t)v118;
                  *(v89 - sub_1CD7485C0(this + 1) = *((void *)v118 - 5);
                  sub_1CD6981A8((uint64_t)v89, (__n128 *)(v93 - 32));
                  *(void *)(v93 - 40) = v91;
                  sub_1CD6981A8(v93 - 32, (__n128 *)&v123[8]);
                  uint64_t result = sub_1CD69825C((uint64_t)&v123[8]);
                }
                break;
              case 3:
                uint64_t result = sub_1CCCEF7B8(v7, v7 + 56, (uint64_t)v9);
                break;
              case 4:
                uint64_t result = sub_1CCCEFDF0(v7, v7 + 56, v7 + 112, (uint64_t)v9);
                break;
              case 5:
                uint64_t result = sub_1CCCEF550(v7, v7 + 56, v7 + 112, v7 + 168, (uint64_t)v9);
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v11 <= 1343)
          {
            if (v116)
            {
              if (v7 != v8)
              {
                uint64_t v94 = v7 + 56;
                if ((_OWORD *)(v7 + 56) != v118)
                {
                  uint64_t v95 = 0;
                  unint64_t v96 = (__n128 *)v7;
                  do
                  {
                    unint64_t v97 = (_OWORD *)v94;
                    uint64_t result = sub_1CCCEFD24(v94, &v96[4].n128_u64[1], (uint64_t)v96, (__n128 *)v96[1].n128_u64);
                    if (result)
                    {
                      *(_OWORD *)char v123 = *v97;
                      *(void *)&v123[16] = v96[4].n128_u64[1];
                      __n128 v124 = v96[5];
                      v96[5].n128_u64[0] = 0;
                      v96[5].n128_u64[1] = 0;
                      unint64_t v98 = v96[6].n128_u64[0];
                      unint64_t v99 = v96[6].n128_u64[1];
                      v96[6].n128_u64[0] = 0;
                      v96[6].n128_u64[1] = 0;
                      uint64_t v100 = v95;
                      unint64_t v125 = v98;
                      unint64_t v126 = v99;
                      while (1)
                      {
                        uint64_t v101 = v7 + v100;
                        *(_OWORD *)(v101 + 56) = *(_OWORD *)(v7 + v100);
                        *(void *)(v101 + 72) = *(void *)(v7 + v100 + 16);
                        int64x2_t v102 = (__n128 *)(v7 + v100 + 24);
                        sub_1CD6981A8(v7 + v100 + 80, v102);
                        if (!v100) {
                          break;
                        }
                        v100 -= 56;
                        if (!sub_1CCCEFD24((uint64_t)v123, &v123[16], v101 - 56, (void *)(v101 - 40)))
                        {
                          uint64_t v103 = v7 + v100 + 56;
                          goto LABEL_105;
                        }
                      }
                      uint64_t v103 = v7;
LABEL_105:
                      *(_OWORD *)uint64_t v103 = *(_OWORD *)v123;
                      *(void *)(v103 + 16) = *(void *)&v123[16];
                      sub_1CD6981A8((uint64_t)v102, &v124);
                      uint64_t result = sub_1CD69825C((uint64_t)&v124);
                    }
                    uint64_t v94 = (uint64_t)v97 + 56;
                    v95 += 56;
                    unint64_t v96 = (__n128 *)v97;
                  }
                  while ((_OWORD *)((char *)v97 + 56) != v118);
                }
              }
            }
            else if (v7 != v8)
            {
              uint64_t v104 = v7 + 56;
              if ((_OWORD *)(v7 + 56) != v118)
              {
                uint64_t v105 = v7 - 56;
                do
                {
                  uint64_t v106 = (_OWORD *)v104;
                  uint64_t result = sub_1CCCEFD24(v104, (void *)(v7 + 72), v7, (void *)(v7 + 16));
                  if (result)
                  {
                    *(_OWORD *)char v123 = *v106;
                    *(void *)&v123[16] = *(void *)(v7 + 72);
                    __n128 v124 = *(__n128 *)(v7 + 80);
                    *(void *)(v7 + 80) = 0;
                    *(void *)(v7 + 88) = 0;
                    unint64_t v107 = *(void *)(v7 + 96);
                    unint64_t v108 = *(void *)(v7 + 104);
                    *(void *)(v7 + 96) = 0;
                    *(void *)(v7 + 104) = 0;
                    uint64_t v109 = v105;
                    unint64_t v125 = v107;
                    unint64_t v126 = v108;
                    do
                    {
                      *(_OWORD *)(v109 + 112) = *(_OWORD *)(v109 + 56);
                      *(void *)(v109 + 128) = *(void *)(v109 + 72);
                      sub_1CD6981A8(v109 + 136, (__n128 *)(v109 + 80));
                      BOOL v110 = sub_1CCCEFD24((uint64_t)v123, &v123[16], v109, (void *)(v109 + 16));
                      v109 -= 56;
                    }
                    while (v110);
                    *(_OWORD *)(v109 + 112) = *(_OWORD *)v123;
                    *(void *)(v109 + 128) = *(void *)&v123[16];
                    sub_1CD6981A8(v109 + 136, &v124);
                    uint64_t result = sub_1CD69825C((uint64_t)&v124);
                  }
                  uint64_t v104 = (uint64_t)v106 + 56;
                  v105 += 56;
                  uint64_t v7 = (uint64_t)v106;
                }
                while ((_OWORD *)((char *)v106 + 56) != v118);
              }
            }
            return result;
          }
          if (!a3)
          {
            if (v7 != v8)
            {
              int64_t v55 = (unint64_t)(v12 - 2) >> 1;
              unsigned int v117 = (__n128 *)&v123[16];
              long long v56 = &v124;
              int64_t v57 = v55;
              do
              {
                int64_t v58 = v57;
                if (v55 >= v57)
                {
                  uint64_t v59 = (2 * v57) | 1;
                  uint64_t v60 = v7 + 56 * v59;
                  if (2 * v57 + 2 < v12
                    && sub_1CCCEFD24(v7 + 56 * v59, (void *)(v7 + 56 * v59 + 16), v60 + 56, (void *)(v60 + 72)))
                  {
                    v60 += 56;
                    uint64_t v59 = 2 * v58 + 2;
                  }
                  uint64_t v61 = v7 + 56 * v58;
                  if (!sub_1CCCEFD24(v60, (void *)(v60 + 16), v61, (void *)(v61 + 16)))
                  {
                    uint64_t v116 = v56;
                    *(_OWORD *)char v123 = *(_OWORD *)v61;
                    *(void *)&v123[16] = *(void *)(v7 + 56 * v58 + 16);
                    uint64_t v62 = v7 + 56 * v58;
                    __n128 v124 = *(__n128 *)(v62 + 24);
                    unint64_t v125 = *(void *)(v62 + 40);
                    *(_OWORD *)(v62 + 24) = 0u;
                    unint64_t v63 = *(void *)(v62 + 48);
                    *(_OWORD *)(v62 + 40) = 0u;
                    unint64_t v126 = v63;
                    do
                    {
                      uint64_t v64 = v60;
                      *(_OWORD *)uint64_t v61 = *(_OWORD *)v60;
                      *(void *)(v61 + 16) = *(void *)(v60 + 16);
                      uint64_t v65 = v60 + 24;
                      sub_1CD6981A8(v61 + 24, (__n128 *)(v60 + 24));
                      if (v55 < v59) {
                        break;
                      }
                      uint64_t v66 = (2 * v59) | 1;
                      uint64_t v60 = v7 + 56 * v66;
                      uint64_t v67 = 2 * v59 + 2;
                      if (v67 < v12
                        && sub_1CCCEFD24(v7 + 56 * v66, (void *)(v7 + 56 * v66 + 16), v60 + 56, (void *)(v60 + 72)))
                      {
                        v60 += 56;
                        uint64_t v66 = v67;
                      }
                      uint64_t v61 = v64;
                      uint64_t v59 = v66;
                    }
                    while (!sub_1CCCEFD24(v60, (void *)(v60 + 16), (uint64_t)v123, v117));
                    *(_OWORD *)uint64_t v64 = *(_OWORD *)v123;
                    *(void *)(v64 + 16) = *(void *)&v123[16];
                    long long v56 = v116;
                    sub_1CD6981A8(v65, v116);
                    sub_1CD69825C((uint64_t)v116);
                  }
                }
                int64_t v57 = v58 - 1;
              }
              while (v58);
              unsigned int v68 = (__n128 *)&v120;
              uint64_t v116 = (__n128 *)(v7 + 24);
              unsigned int v117 = (__n128 *)&v120;
              uint64_t v115 = &v123[16];
              do
              {
                uint64_t v69 = 0;
                long long v70 = *(_OWORD *)v7;
                uint64_t v71 = *(void *)(v7 + 16);
                v68->n128_u64[0] = 0;
                v68->n128_u64[1] = 0;
                v68[1].n128_u64[0] = 0;
                long long v120 = *(_OWORD *)(v7 + 24);
                uint64_t v72 = (uint64_t)v118;
                *(void *)&v119[16] = v71;
                uint64_t v73 = *(void *)(v7 + 48);
                uint64_t v121 = *(void *)(v7 + 40);
                int v74 = v116;
                v116->n128_u64[1] = 0;
                v74[1].n128_u64[0] = 0;
                v74->n128_u64[0] = 0;
                *(void *)(v7 + 48) = 0;
                uint64_t v122 = v73;
                uint64_t v75 = v7;
                *(_OWORD *)uint64_t v119 = v70;
                do
                {
                  uint64_t v76 = v75 + 56 * (v69 + 1);
                  uint64_t v77 = (2 * v69) | 1;
                  uint64_t v78 = 2 * v69 + 2;
                  if (v78 < v12
                    && sub_1CCCEFD24(v76, (void *)(v75 + 56 * (v69 + 1) + 16), v76 + 56, (void *)(v76 + 72)))
                  {
                    v76 += 56;
                    uint64_t v77 = v78;
                  }
                  *(_OWORD *)uint64_t v75 = *(_OWORD *)v76;
                  *(void *)(v75 + 16) = *(void *)(v76 + 16);
                  sub_1CD6981A8(v75 + 24, (__n128 *)(v76 + 24));
                  uint64_t v75 = v76;
                  uint64_t v69 = v77;
                }
                while (v77 <= (uint64_t)((unint64_t)(v12 - 2) >> 1));
                unint64_t v79 = (_OWORD *)(v72 - 56);
                size_t v118 = (_OWORD *)(v72 - 56);
                if (v76 == v72 - 56)
                {
                  *(_OWORD *)uint64_t v76 = *(_OWORD *)v119;
                  *(void *)(v76 + 16) = *(void *)&v119[16];
                  unsigned int v68 = v117;
                  sub_1CD6981A8(v76 + 24, v117);
                }
                else
                {
                  *(_OWORD *)uint64_t v76 = *v79;
                  *(void *)(v76 + 16) = *(void *)(v72 - 40);
                  sub_1CD6981A8(v76 + 24, (__n128 *)(v72 - 32));
                  *unint64_t v79 = *(_OWORD *)v119;
                  *(void *)(v72 - 40) = *(void *)&v119[16];
                  uint64_t v80 = v72 - 32;
                  unsigned int v68 = v117;
                  sub_1CD6981A8(v80, v117);
                  uint64_t v81 = v76 - v7 + 56;
                  uint64_t v82 = v115;
                  if (v81 >= 57)
                  {
                    unint64_t v83 = (v81 / 0x38uLL - 2) >> 1;
                    uint64_t v84 = v7 + 56 * v83;
                    if (sub_1CCCEFD24(v84, (void *)(v84 + 16), v76, (void *)(v76 + 16)))
                    {
                      *(_OWORD *)char v123 = *(_OWORD *)v76;
                      *(void *)&v123[16] = *(void *)(v76 + 16);
                      unint64_t v125 = 0;
                      __n128 v124 = 0uLL;
                      __n128 v124 = *(__n128 *)(v76 + 24);
                      unint64_t v125 = *(void *)(v76 + 40);
                      *(void *)(v76 + 24) = 0;
                      *(void *)(v76 + 32) = 0;
                      *(void *)(v76 + 40) = 0;
                      unint64_t v85 = *(void *)(v76 + 48);
                      *(void *)(v76 + 48) = 0;
                      unint64_t v126 = v85;
                      do
                      {
                        uint64_t v86 = v84;
                        *(_OWORD *)uint64_t v76 = *(_OWORD *)v84;
                        *(void *)(v76 + 16) = *(void *)(v84 + 16);
                        uint64_t v87 = v84 + 24;
                        sub_1CD6981A8(v76 + 24, (__n128 *)(v84 + 24));
                        if (!v83) {
                          break;
                        }
                        unint64_t v83 = (v83 - 1) >> 1;
                        uint64_t v84 = v7 + 56 * v83;
                        uint64_t v76 = v86;
                      }
                      while (sub_1CCCEFD24(v84, (void *)(v84 + 16), (uint64_t)v123, v82));
                      *(_OWORD *)uint64_t v86 = *(_OWORD *)v123;
                      *(void *)(v86 + 16) = *(void *)&v123[16];
                      sub_1CD6981A8(v87, &v124);
                      sub_1CD69825C((uint64_t)&v124);
                    }
                  }
                }
                uint64_t result = sub_1CD69825C((uint64_t)v68);
              }
              while (v12-- > 2);
            }
            return result;
          }
          uint64_t v13 = (_OWORD *)(v7 + 56 * ((unint64_t)v12 >> 1));
          if ((unint64_t)v11 >= 0x1C01)
          {
            sub_1CCCEF7B8(v7, v7 + 56 * ((unint64_t)v12 >> 1), (uint64_t)v9);
            uint64_t v14 = 56 * ((unint64_t)v12 >> 1);
            uint64_t v15 = v7 + v14;
            sub_1CCCEF7B8(v7 + 56, v7 + v14 - 56, v113);
            sub_1CCCEF7B8(v7 + 112, v7 + 56 + v14, v112);
            sub_1CCCEF7B8(v7 + v14 - 56, (uint64_t)v13, v7 + 56 + v14);
            *(_OWORD *)char v123 = *(_OWORD *)v7;
            *(_OWORD *)uint64_t v7 = *v13;
            _OWORD *v13 = *(_OWORD *)v123;
            long long v16 = *(_OWORD *)(v7 + 24);
            uint64_t v17 = *(void *)(v7 + 16);
            unint64_t v18 = *(void *)(v7 + 48);
            v124.n128_u64[0] = *(void *)(v7 + 40);
            *(void *)char v123 = v17;
            *(_OWORD *)&v123[8] = v16;
            *(void *)(v7 + 24) = 0;
            *(void *)(v7 + 32) = 0;
            *(void *)(v7 + 40) = 0;
            *(void *)(v7 + 48) = 0;
            v124.n128_u64[1] = v18;
            *(void *)(v7 + 16) = *(void *)(v15 + 16);
            uint64_t v19 = v15 + 24;
            sub_1CD6981A8(v7 + 24, (__n128 *)(v15 + 24));
            *(void *)(v15 + 16) = v17;
            unint64_t v8 = (unint64_t)v118;
            sub_1CD6981A8(v19, (__n128 *)&v123[8]);
            sub_1CD69825C((uint64_t)&v123[8]);
          }
          else
          {
            sub_1CCCEF7B8(v7 + 56 * ((unint64_t)v12 >> 1), v7, (uint64_t)v9);
          }
          uint64_t v115 = a3 - 1;
          if ((v116 & 1) != 0 || sub_1CCCEFD24(v7 - 56, (void *)(v7 - 40), v7, (void *)(v7 + 16))) {
            break;
          }
          *(_OWORD *)char v123 = *(_OWORD *)v7;
          *(void *)&v123[16] = *(void *)(v7 + 16);
          unint64_t v39 = v117;
          v117->n128_u64[0] = 0;
          v39->n128_u64[1] = 0;
          v39[1].n128_u64[0] = 0;
          __n128 v40 = *(__n128 *)(v7 + 24);
          unint64_t v41 = *(void *)(v7 + 48);
          unint64_t v125 = *(void *)(v7 + 40);
          __n128 v124 = v40;
          *(void *)(v7 + 24) = 0;
          *(void *)(v7 + 32) = 0;
          *(void *)(v7 + 40) = 0;
          *(void *)(v7 + 48) = 0;
          unint64_t v126 = v41;
          if (sub_1CCCEFD24((uint64_t)v123, &v123[16], (uint64_t)v9, v111))
          {
            unint64_t v42 = v7;
            do
            {
              unint64_t v10 = v42 + 56;
              BOOL v43 = sub_1CCCEFD24((uint64_t)v123, &v123[16], v42 + 56, (void *)(v42 + 72));
              unint64_t v42 = v10;
            }
            while (!v43);
          }
          else
          {
            unint64_t v44 = (void *)(v7 + 72);
            do
            {
              unint64_t v10 = (unint64_t)(v44 - 2);
              if ((unint64_t)(v44 - 2) >= v8) {
                break;
              }
              BOOL v45 = sub_1CCCEFD24((uint64_t)v123, &v123[16], (uint64_t)(v44 - 2), v44);
              v44 += 7;
            }
            while (!v45);
          }
          unint64_t v46 = v8;
          if (v10 < v8)
          {
            unint64_t v47 = v8;
            do
            {
              unint64_t v46 = v47 - 56;
              BOOL v48 = sub_1CCCEFD24((uint64_t)v123, &v123[16], v47 - 56, (void *)(v47 - 40));
              unint64_t v47 = v46;
            }
            while (v48);
          }
          while (v10 < v46)
          {
            *(_OWORD *)uint64_t v119 = *(_OWORD *)v10;
            *(_OWORD *)unint64_t v10 = *(_OWORD *)v46;
            *(_OWORD *)unint64_t v46 = *(_OWORD *)v119;
            long long v49 = *(_OWORD *)(v10 + 24);
            uint64_t v50 = *(void *)(v10 + 16);
            uint64_t v51 = *(void *)(v10 + 48);
            *(void *)&long long v120 = *(void *)(v10 + 40);
            *(void *)uint64_t v119 = v50;
            *(_OWORD *)&v119[8] = v49;
            *(void *)(v10 + 24) = 0;
            *(void *)(v10 + 32) = 0;
            *(void *)(v10 + 40) = 0;
            *(void *)(v10 + 48) = 0;
            *((void *)&v120 + sub_1CD7485C0(this + 1) = v51;
            *(void *)(v10 + 16) = *(void *)(v46 + 16);
            sub_1CD6981A8(v10 + 24, (__n128 *)(v46 + 24));
            *(void *)(v46 + 16) = v50;
            sub_1CD6981A8(v46 + 24, (__n128 *)&v119[8]);
            sub_1CD69825C((uint64_t)&v119[8]);
            do
            {
              unint64_t v52 = (void *)(v10 + 72);
              v10 += 56;
            }
            while (!sub_1CCCEFD24((uint64_t)v123, &v123[16], v10, v52));
            do
            {
              uint64_t v53 = (void *)(v46 - 40);
              v46 -= 56;
            }
            while (sub_1CCCEFD24((uint64_t)v123, &v123[16], v46, v53));
          }
          uint64_t v54 = (_OWORD *)(v10 - 56);
          if (v10 - 56 != v7)
          {
            *(_OWORD *)uint64_t v7 = *v54;
            *(void *)(v7 + 16) = *(void *)(v10 - 40);
            sub_1CD6981A8(v7 + 24, (__n128 *)(v10 - 32));
          }
          *uint64_t v54 = *(_OWORD *)v123;
          *(void *)(v10 - 40) = *(void *)&v123[16];
          sub_1CD6981A8(v10 - 32, v117);
          uint64_t result = sub_1CD69825C((uint64_t)v117);
          LODWORD(v116) = 0;
          a3 = v115;
        }
        uint64_t v20 = 0;
        long long v21 = *(_OWORD *)v7;
        uint64_t v22 = *(void *)(v7 + 16);
        uint64_t v23 = v117;
        v117->n128_u64[0] = 0;
        v23->n128_u64[1] = 0;
        v23[1].n128_u64[0] = 0;
        __n128 v124 = *(__n128 *)(v7 + 24);
        *(void *)&v123[16] = v22;
        unint64_t v24 = *(void *)(v7 + 48);
        unint64_t v125 = *(void *)(v7 + 40);
        *(void *)(v7 + 24) = 0;
        *(void *)(v7 + 32) = 0;
        *(void *)(v7 + 40) = 0;
        *(void *)(v7 + 48) = 0;
        unint64_t v126 = v24;
        *(_OWORD *)char v123 = v21;
        do
        {
          BOOL v25 = sub_1CCCEFD24(v7 + v20 + 56, (void *)(v7 + v20 + 72), (uint64_t)v123, &v123[16]);
          v20 += 56;
        }
        while (v25);
        unint64_t v26 = v7 + v20;
        unint64_t v27 = v8;
        if (v20 == 56)
        {
          while (v26 < v8)
          {
            unint64_t v30 = v8 - 56;
            BOOL v28 = sub_1CCCEFD24(v8 - 56, (void *)(v8 - 40), (uint64_t)v123, &v123[16]);
            v8 -= 56;
            if (v28) {
              goto LABEL_20;
            }
          }
          unint64_t v30 = v8;
        }
        else
        {
          do
          {
            unint64_t v30 = v27 - 56;
            BOOL v29 = sub_1CCCEFD24(v27 - 56, (void *)(v27 - 40), (uint64_t)v123, &v123[16]);
            unint64_t v27 = v30;
          }
          while (!v29);
        }
LABEL_20:
        unint64_t v10 = v7 + v20;
        if (v26 < v30)
        {
          unint64_t v31 = v30;
          do
          {
            *(_OWORD *)uint64_t v119 = *(_OWORD *)v10;
            *(_OWORD *)unint64_t v10 = *(_OWORD *)v31;
            *(_OWORD *)unint64_t v31 = *(_OWORD *)v119;
            long long v32 = *(_OWORD *)(v10 + 24);
            uint64_t v33 = *(void *)(v10 + 16);
            uint64_t v34 = *(void *)(v10 + 48);
            *(void *)&long long v120 = *(void *)(v10 + 40);
            *(void *)uint64_t v119 = v33;
            *(_OWORD *)&v119[8] = v32;
            *(void *)(v10 + 24) = 0;
            *(void *)(v10 + 32) = 0;
            *(void *)(v10 + 40) = 0;
            *(void *)(v10 + 48) = 0;
            *((void *)&v120 + sub_1CD7485C0(this + 1) = v34;
            *(void *)(v10 + 16) = *(void *)(v31 + 16);
            sub_1CD6981A8(v10 + 24, (__n128 *)(v31 + 24));
            *(void *)(v31 + 16) = v33;
            sub_1CD6981A8(v31 + 24, (__n128 *)&v119[8]);
            sub_1CD69825C((uint64_t)&v119[8]);
            do
            {
              uint64_t v35 = (void *)(v10 + 72);
              v10 += 56;
            }
            while (sub_1CCCEFD24(v10, v35, (uint64_t)v123, &v123[16]));
            do
            {
              uint64_t v36 = (void *)(v31 - 40);
              v31 -= 56;
            }
            while (!sub_1CCCEFD24(v31, v36, (uint64_t)v123, &v123[16]));
          }
          while (v10 < v31);
        }
        char v37 = (_OWORD *)(v10 - 56);
        if (v10 - 56 != v7)
        {
          *(_OWORD *)uint64_t v7 = *v37;
          *(void *)(v7 + 16) = *(void *)(v10 - 40);
          sub_1CD6981A8(v7 + 24, (__n128 *)(v10 - 32));
        }
        *char v37 = *(_OWORD *)v123;
        *(void *)(v10 - 40) = *(void *)&v123[16];
        sub_1CD6981A8(v10 - 32, v117);
        sub_1CD69825C((uint64_t)v117);
        BOOL v4 = v26 >= v30;
        unint64_t v8 = (unint64_t)v118;
        int v9 = v114;
        a3 = v115;
        if (v4) {
          break;
        }
LABEL_32:
        uint64_t result = sub_1CCCEE7E4(v7, v10 - 56, v115, v116 & 1);
        LODWORD(v116) = 0;
      }
      BOOL v38 = sub_1CCCEFA7C(v7, v10 - 56);
      uint64_t result = sub_1CCCEFA7C(v10, (uint64_t)v118);
      if (result) {
        break;
      }
      if (!v38) {
        goto LABEL_32;
      }
    }
    size_t v118 = (_OWORD *)(v10 - 56);
    if (!v38) {
      continue;
    }
    return result;
  }
}

uint64_t sub_1CCCEF550(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  sub_1CCCEFDF0(a1, a2, a3, a4);
  uint64_t result = sub_1CCCEFD24(a5, (void *)(a5 + 16), a4, (void *)(a4 + 16));
  if (result)
  {
    long long v11 = *(_OWORD *)a4;
    *(_OWORD *)a4 = *(_OWORD *)a5;
    *(_OWORD *)a5 = v11;
    uint64_t v12 = *(void *)(a4 + 16);
    __n128 v29 = *(__n128 *)(a4 + 24);
    *(void *)(a4 + 24) = 0;
    uint64_t v13 = *(void *)(a4 + 40);
    uint64_t v14 = *(void *)(a4 + 48);
    *(void *)(a4 + 40) = 0;
    *(void *)(a4 + 48) = 0;
    *(void *)(a4 + 32) = 0;
    uint64_t v30 = v13;
    uint64_t v31 = v14;
    *(void *)(a4 + 16) = *(void *)(a5 + 16);
    sub_1CD6981A8(a4 + 24, (__n128 *)(a5 + 24));
    *(void *)(a5 + 16) = v12;
    sub_1CD6981A8(a5 + 24, &v29);
    sub_1CD69825C((uint64_t)&v29);
    uint64_t result = sub_1CCCEFD24(a4, (void *)(a4 + 16), a3, (void *)(a3 + 16));
    if (result)
    {
      long long v15 = *(_OWORD *)a3;
      *(_OWORD *)a3 = *(_OWORD *)a4;
      *(_OWORD *)a4 = v15;
      uint64_t v16 = *(void *)(a3 + 16);
      __n128 v29 = *(__n128 *)(a3 + 24);
      *(void *)(a3 + 24) = 0;
      uint64_t v17 = *(void *)(a3 + 40);
      uint64_t v18 = *(void *)(a3 + 48);
      *(void *)(a3 + 40) = 0;
      *(void *)(a3 + 48) = 0;
      *(void *)(a3 + 32) = 0;
      uint64_t v30 = v17;
      uint64_t v31 = v18;
      *(void *)(a3 + 16) = *(void *)(a4 + 16);
      sub_1CD6981A8(a3 + 24, (__n128 *)(a4 + 24));
      *(void *)(a4 + 16) = v16;
      sub_1CD6981A8(a4 + 24, &v29);
      sub_1CD69825C((uint64_t)&v29);
      uint64_t result = sub_1CCCEFD24(a3, (void *)(a3 + 16), a2, (void *)(a2 + 16));
      if (result)
      {
        long long v19 = *(_OWORD *)a2;
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *(_OWORD *)a3 = v19;
        uint64_t v20 = *(void *)(a2 + 16);
        __n128 v29 = *(__n128 *)(a2 + 24);
        *(void *)(a2 + 24) = 0;
        uint64_t v21 = *(void *)(a2 + 40);
        uint64_t v22 = *(void *)(a2 + 48);
        *(void *)(a2 + 40) = 0;
        *(void *)(a2 + 48) = 0;
        *(void *)(a2 + 32) = 0;
        uint64_t v30 = v21;
        uint64_t v31 = v22;
        *(void *)(a2 + 16) = *(void *)(a3 + 16);
        sub_1CD6981A8(a2 + 24, (__n128 *)(a3 + 24));
        *(void *)(a3 + 16) = v20;
        sub_1CD6981A8(a3 + 24, &v29);
        sub_1CD69825C((uint64_t)&v29);
        uint64_t result = sub_1CCCEFD24(a2, (void *)(a2 + 16), a1, (void *)(a1 + 16));
        if (result)
        {
          long long v23 = *(_OWORD *)a1;
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(_OWORD *)a2 = v23;
          __n128 v25 = *(__n128 *)(a1 + 24);
          unint64_t v24 = (void *)(a1 + 24);
          uint64_t v26 = *(v24 - 1);
          __n128 v29 = v25;
          *unint64_t v24 = 0;
          v24[1] = 0;
          uint64_t v27 = v24[2];
          uint64_t v28 = v24[3];
          _OWORD v24[2] = 0;
          v24[3] = 0;
          uint64_t v30 = v27;
          uint64_t v31 = v28;
          *(v24 - sub_1CD7485C0(this + 1) = *(void *)(a2 + 16);
          sub_1CD6981A8((uint64_t)v24, (__n128 *)(a2 + 24));
          *(void *)(a2 + 16) = v26;
          sub_1CD6981A8(a2 + 24, &v29);
          return sub_1CD69825C((uint64_t)&v29);
        }
      }
    }
  }
  return result;
}

uint64_t sub_1CCCEF7B8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = (void *)(a2 + 16);
  uint64_t v7 = (void *)(a1 + 16);
  BOOL v8 = sub_1CCCEFD24(a2, (void *)(a2 + 16), a1, (void *)(a1 + 16));
  uint64_t result = sub_1CCCEFD24(a3, (void *)(a3 + 16), a2, v6);
  int v10 = result;
  if (v8)
  {
    long long v11 = (void *)(a1 + 24);
    if (v10)
    {
      long long v12 = *(_OWORD *)a1;
      *(_OWORD *)a1 = *(_OWORD *)a3;
      *(_OWORD *)a3 = v12;
      uint64_t v13 = *(void *)(a1 + 16);
      __n128 v35 = *(__n128 *)(a1 + 24);
      uint64_t v14 = *(void *)(a1 + 40);
      uint64_t v15 = *(void *)(a1 + 48);
      *(void *)(a1 + 32) = 0;
      *(void *)(a1 + 40) = 0;
      *long long v11 = 0;
      *(void *)(a1 + 48) = 0;
      uint64_t v36 = v14;
      uint64_t v37 = v15;
      *(void *)(a1 + 16) = *(void *)(a3 + 16);
      sub_1CD6981A8((uint64_t)v11, (__n128 *)(a3 + 24));
      *(void *)(a3 + 16) = v13;
      sub_1CD6981A8(a3 + 24, &v35);
      return sub_1CD69825C((uint64_t)&v35);
    }
    long long v27 = *(_OWORD *)a1;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_OWORD *)a2 = v27;
    uint64_t v28 = *(void *)(a1 + 16);
    __n128 v35 = *(__n128 *)(a1 + 24);
    uint64_t v29 = *(void *)(a1 + 40);
    uint64_t v30 = *(void *)(a1 + 48);
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 40) = 0;
    *long long v11 = 0;
    *(void *)(a1 + 48) = 0;
    uint64_t v36 = v29;
    uint64_t v37 = v30;
    *(void *)(a1 + 16) = *(void *)(a2 + 16);
    sub_1CD6981A8((uint64_t)v11, (__n128 *)(a2 + 24));
    *(void *)(a2 + 16) = v28;
    sub_1CD6981A8(a2 + 24, &v35);
    sub_1CD69825C((uint64_t)&v35);
    uint64_t result = sub_1CCCEFD24(a3, (void *)(a3 + 16), a2, v6);
    if (result)
    {
      long long v31 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)a3 = v31;
      uint64_t v32 = *(void *)(a2 + 16);
      __n128 v35 = *(__n128 *)(a2 + 24);
      uint64_t v33 = *(void *)(a2 + 40);
      uint64_t v34 = *(void *)(a2 + 48);
      *(void *)(a2 + 32) = 0;
      *(void *)(a2 + 40) = 0;
      *(void *)(a2 + 24) = 0;
      *(void *)(a2 + 48) = 0;
      uint64_t v36 = v33;
      uint64_t v37 = v34;
      *(void *)(a2 + 16) = *(void *)(a3 + 16);
      sub_1CD6981A8(a2 + 24, (__n128 *)(a3 + 24));
      *(void *)(a3 + 16) = v32;
      uint64_t v26 = a3 + 24;
      goto LABEL_11;
    }
  }
  else if (result)
  {
    long long v16 = *(_OWORD *)a2;
    *(_OWORD *)a2 = *(_OWORD *)a3;
    *(_OWORD *)a3 = v16;
    uint64_t v17 = *(void *)(a2 + 16);
    __n128 v35 = *(__n128 *)(a2 + 24);
    *(void *)(a2 + 24) = 0;
    uint64_t v18 = *(void *)(a2 + 40);
    uint64_t v19 = *(void *)(a2 + 48);
    *(void *)(a2 + 40) = 0;
    *(void *)(a2 + 48) = 0;
    *(void *)(a2 + 32) = 0;
    uint64_t v36 = v18;
    uint64_t v37 = v19;
    *(void *)(a2 + 16) = *(void *)(a3 + 16);
    sub_1CD6981A8(a2 + 24, (__n128 *)(a3 + 24));
    *(void *)(a3 + 16) = v17;
    sub_1CD6981A8(a3 + 24, &v35);
    sub_1CD69825C((uint64_t)&v35);
    uint64_t result = sub_1CCCEFD24(a2, v6, a1, v7);
    if (result)
    {
      long long v20 = *(_OWORD *)a1;
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_OWORD *)a2 = v20;
      __n128 v22 = *(__n128 *)(a1 + 24);
      uint64_t v21 = (void *)(a1 + 24);
      uint64_t v23 = *(v21 - 1);
      __n128 v35 = v22;
      void *v21 = 0;
      v21[1] = 0;
      uint64_t v24 = v21[2];
      uint64_t v25 = v21[3];
      void v21[2] = 0;
      void v21[3] = 0;
      uint64_t v36 = v24;
      uint64_t v37 = v25;
      *(v21 - sub_1CD7485C0(this + 1) = *(void *)(a2 + 16);
      sub_1CD6981A8((uint64_t)v21, (__n128 *)(a2 + 24));
      *(void *)(a2 + 16) = v23;
      uint64_t v26 = a2 + 24;
LABEL_11:
      sub_1CD6981A8(v26, &v35);
      return sub_1CD69825C((uint64_t)&v35);
    }
  }
  return result;
}

BOOL sub_1CCCEFA7C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 3;
  BOOL result = 1;
  switch(0x6DB6DB6DB6DB6DB7 * v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      int v6 = (_OWORD *)(a2 - 56);
      if (sub_1CCCEFD24(a2 - 56, (void *)(a2 - 40), a1, (void *)(a1 + 16)))
      {
        long long v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *int v6 = v7;
        long long v9 = *(_OWORD *)(a1 + 24);
        BOOL v8 = (void *)(a1 + 24);
        *(void *)__n128 v22 = *(v8 - 1);
        uint64_t v10 = *(void *)v22;
        *(_OWORD *)&v22[8] = v9;
        void *v8 = 0;
        v8[1] = 0;
        unint64_t v11 = v8[2];
        unint64_t v12 = v8[3];
        void v8[2] = 0;
        v8[3] = 0;
        v23.n128_u64[0] = v11;
        v23.n128_u64[1] = v12;
        *(v8 - sub_1CD7485C0(this + 1) = *(void *)(a2 - 40);
        sub_1CD6981A8((uint64_t)v8, (__n128 *)(a2 - 32));
        *(void *)(a2 - 40) = v10;
        sub_1CD6981A8(a2 - 32, (__n128 *)&v22[8]);
        sub_1CD69825C((uint64_t)&v22[8]);
      }
      return 1;
    case 3:
      sub_1CCCEF7B8(a1, a1 + 56, a2 - 56);
      return 1;
    case 4:
      sub_1CCCEFDF0(a1, a1 + 56, a1 + 112, a2 - 56);
      return 1;
    case 5:
      sub_1CCCEF550(a1, a1 + 56, a1 + 112, a1 + 168, a2 - 56);
      return 1;
    default:
      uint64_t v13 = a1 + 112;
      sub_1CCCEF7B8(a1, a1 + 56, a1 + 112);
      uint64_t v14 = a1 + 168;
      if (a1 + 168 == a2) {
        return 1;
      }
      uint64_t v15 = 0;
      int v16 = 0;
      break;
  }
  do
  {
    if (sub_1CCCEFD24(v14, (void *)(v14 + 16), v13, (void *)(v13 + 16)))
    {
      *(_OWORD *)__n128 v22 = *(_OWORD *)v14;
      *(void *)&v22[16] = *(void *)(v14 + 16);
      __n128 v23 = *(__n128 *)(v14 + 24);
      *(void *)(v14 + 24) = 0;
      *(void *)(v14 + 32) = 0;
      uint64_t v17 = *(void *)(v14 + 48);
      uint64_t v24 = *(void *)(v14 + 40);
      uint64_t v25 = v17;
      uint64_t v18 = v15;
      *(void *)(v14 + 40) = 0;
      *(void *)(v14 + 48) = 0;
      while (1)
      {
        uint64_t v19 = a1 + v18;
        *(_OWORD *)(v19 + 168) = *(_OWORD *)(a1 + v18 + 112);
        *(void *)(v19 + 184) = *(void *)(a1 + v18 + 128);
        long long v20 = (__n128 *)(a1 + v18 + 136);
        sub_1CD6981A8(a1 + v18 + 192, v20);
        if (v18 == -112) {
          break;
        }
        v18 -= 56;
        if (!sub_1CCCEFD24((uint64_t)v22, &v22[16], v19 + 56, (void *)(v19 + 72)))
        {
          uint64_t v21 = a1 + v18 + 168;
          goto LABEL_14;
        }
      }
      uint64_t v21 = a1;
LABEL_14:
      *(_OWORD *)uint64_t v21 = *(_OWORD *)v22;
      *(void *)(v21 + 16) = *(void *)&v22[16];
      sub_1CD6981A8((uint64_t)v20, &v23);
      ++v16;
      sub_1CD69825C((uint64_t)&v23);
      if (v16 == 8) {
        return v14 + 56 == a2;
      }
    }
    uint64_t v13 = v14;
    v15 += 56;
    v14 += 56;
  }
  while (v14 != a2);
  return 1;
}

BOOL sub_1CCCEFD24(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  unint64_t v6 = *(void *)(a1 + 8);
  unint64_t v7 = *(void *)(a3 + 8);
  if (v7 >= v6) {
    size_t v8 = *(void *)(a1 + 8);
  }
  else {
    size_t v8 = *(void *)(a3 + 8);
  }
  if (v8)
  {
    long long v9 = *(const void **)a3;
    uint64_t v10 = *(const void **)a1;
    int v11 = memcmp(*(const void **)a1, *(const void **)a3, v8);
    if (v11 < 0) {
      return 1;
    }
    if (!v11 && v6 < v7) {
      return 1;
    }
    int v13 = memcmp(v9, v10, v8);
    if (v13 < 0) {
      return 0;
    }
    BOOL v14 = v13 || v7 == v6;
    if (!v14 && v7 < v6) {
      return 0;
    }
  }
  else
  {
    if (v6 < v7) {
      return 1;
    }
    if (v7 < v6) {
      return 0;
    }
  }
  return *a2 < *a4;
}

uint64_t sub_1CCCEFDF0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_1CCCEF7B8(a1, a2, a3);
  uint64_t result = sub_1CCCEFD24(a4, (void *)(a4 + 16), a3, (void *)(a3 + 16));
  if (result)
  {
    long long v9 = *(_OWORD *)a3;
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(_OWORD *)a4 = v9;
    uint64_t v10 = *(void *)(a3 + 16);
    __n128 v23 = *(__n128 *)(a3 + 24);
    *(void *)(a3 + 24) = 0;
    uint64_t v11 = *(void *)(a3 + 40);
    uint64_t v12 = *(void *)(a3 + 48);
    *(void *)(a3 + 40) = 0;
    *(void *)(a3 + 48) = 0;
    *(void *)(a3 + 32) = 0;
    uint64_t v24 = v11;
    uint64_t v25 = v12;
    *(void *)(a3 + 16) = *(void *)(a4 + 16);
    sub_1CD6981A8(a3 + 24, (__n128 *)(a4 + 24));
    *(void *)(a4 + 16) = v10;
    sub_1CD6981A8(a4 + 24, &v23);
    sub_1CD69825C((uint64_t)&v23);
    uint64_t result = sub_1CCCEFD24(a3, (void *)(a3 + 16), a2, (void *)(a2 + 16));
    if (result)
    {
      long long v13 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)a3 = v13;
      uint64_t v14 = *(void *)(a2 + 16);
      __n128 v23 = *(__n128 *)(a2 + 24);
      *(void *)(a2 + 24) = 0;
      uint64_t v15 = *(void *)(a2 + 40);
      uint64_t v16 = *(void *)(a2 + 48);
      *(void *)(a2 + 40) = 0;
      *(void *)(a2 + 48) = 0;
      *(void *)(a2 + 32) = 0;
      uint64_t v24 = v15;
      uint64_t v25 = v16;
      *(void *)(a2 + 16) = *(void *)(a3 + 16);
      sub_1CD6981A8(a2 + 24, (__n128 *)(a3 + 24));
      *(void *)(a3 + 16) = v14;
      sub_1CD6981A8(a3 + 24, &v23);
      sub_1CD69825C((uint64_t)&v23);
      uint64_t result = sub_1CCCEFD24(a2, (void *)(a2 + 16), a1, (void *)(a1 + 16));
      if (result)
      {
        long long v17 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)a2 = v17;
        __n128 v19 = *(__n128 *)(a1 + 24);
        uint64_t v18 = (void *)(a1 + 24);
        uint64_t v20 = *(v18 - 1);
        __n128 v23 = v19;
        void *v18 = 0;
        v18[1] = 0;
        uint64_t v21 = v18[2];
        uint64_t v22 = v18[3];
        _DWORD v18[2] = 0;
        void v18[3] = 0;
        uint64_t v24 = v21;
        uint64_t v25 = v22;
        *(v18 - sub_1CD7485C0(this + 1) = *(void *)(a2 + 16);
        sub_1CD6981A8((uint64_t)v18, (__n128 *)(a2 + 24));
        *(void *)(a2 + 16) = v20;
        sub_1CD6981A8(a2 + 24, &v23);
        return sub_1CD69825C((uint64_t)&v23);
      }
    }
  }
  return result;
}

llvm::raw_ostream *llvm::memprof::IndexedMemProfRecord::serialize(uint64_t *a1, uint64_t a2, llvm::raw_ostream *this)
{
  *(void *)uint64_t v21 = *((unsigned int *)a1 + 2);
  llvm::raw_ostream::write(this, v21, 8uLL);
  unsigned int v6 = *((_DWORD *)a1 + 2);
  if (v6)
  {
    uint64_t v7 = *a1;
    uint64_t v8 = *a1 + 168 * v6;
    do
    {
      *(void *)uint64_t v21 = *(unsigned int *)(v7 + 8);
      llvm::raw_ostream::write(this, v21, 8uLL);
      uint64_t v9 = *(unsigned int *)(v7 + 8);
      if (v9)
      {
        uint64_t v10 = *(uint64_t **)v7;
        uint64_t v11 = 8 * v9;
        do
        {
          uint64_t v12 = *v10++;
          *(void *)uint64_t v21 = v12;
          llvm::raw_ostream::write(this, v21, 8uLL);
          v11 -= 8;
        }
        while (v11);
      }
      sub_1CCCF0128((llvm::raw_ostream *)(v7 + 64), a2, this);
      v7 += 168;
    }
    while (v7 != v8);
  }
  *(void *)uint64_t v21 = *((unsigned int *)a1 + 48);
  uint64_t result = llvm::raw_ostream::write(this, v21, 8uLL);
  uint64_t v14 = *((unsigned int *)a1 + 48);
  if (v14)
  {
    uint64_t v15 = a1[23];
    uint64_t v16 = v15 + (v14 << 6);
    do
    {
      *(void *)uint64_t v21 = *(unsigned int *)(v15 + 8);
      uint64_t result = llvm::raw_ostream::write(this, v21, 8uLL);
      uint64_t v17 = *(unsigned int *)(v15 + 8);
      if (v17)
      {
        uint64_t v18 = *(uint64_t **)v15;
        uint64_t v19 = 8 * v17;
        do
        {
          uint64_t v20 = *v18++;
          *(void *)uint64_t v21 = v20;
          uint64_t result = llvm::raw_ostream::write(this, v21, 8uLL);
          v19 -= 8;
        }
        while (v19);
      }
      v15 += 64;
    }
    while (v15 != v16);
  }
  return result;
}

llvm::raw_ostream *sub_1CCCF0128(llvm::raw_ostream *result, uint64_t a2, llvm::raw_ostream *this)
{
  uint64_t v3 = *(unsigned int *)(a2 + 8);
  if (v3)
  {
    uint64_t v5 = (uint64_t)result;
    unsigned int v6 = *(void **)a2;
    uint64_t v7 = 8 * v3;
    do
    {
      switch(*v6)
      {
        case 2:
          uint64_t v9 = *(void *)(v5 + 8);
          goto LABEL_24;
        case 3:
          uint64_t v9 = *(void *)(v5 + 16);
          goto LABEL_24;
        case 4:
          uint64_t v9 = *(void *)(v5 + 24);
          goto LABEL_24;
        case 5:
          uint64_t v9 = *(void *)(v5 + 32);
          goto LABEL_24;
        case 6:
          int v8 = *(_DWORD *)(v5 + 40);
          goto LABEL_22;
        case 7:
          int v8 = *(_DWORD *)(v5 + 44);
          goto LABEL_22;
        case 8:
          int v8 = *(_DWORD *)(v5 + 48);
          goto LABEL_22;
        case 9:
          int v8 = *(_DWORD *)(v5 + 52);
          goto LABEL_22;
        case 0xALL:
          uint64_t v9 = *(void *)(v5 + 56);
          goto LABEL_24;
        case 0xBLL:
          int v8 = *(_DWORD *)(v5 + 64);
          goto LABEL_22;
        case 0xCLL:
          int v8 = *(_DWORD *)(v5 + 68);
          goto LABEL_22;
        case 0xDLL:
          int v8 = *(_DWORD *)(v5 + 72);
          goto LABEL_22;
        case 0xELL:
          int v8 = *(_DWORD *)(v5 + 76);
          goto LABEL_22;
        case 0xFLL:
          int v8 = *(_DWORD *)(v5 + 80);
          goto LABEL_22;
        case 0x10:
          int v8 = *(_DWORD *)(v5 + 84);
          goto LABEL_22;
        case 0x11:
          int v8 = *(_DWORD *)(v5 + 88);
          goto LABEL_22;
        case 0x12:
          int v8 = *(_DWORD *)(v5 + 92);
          goto LABEL_22;
        case 0x13:
          uint64_t v9 = *(void *)(v5 + 96);
LABEL_24:
          *(void *)uint64_t v12 = v9;
          uint64_t v10 = this;
          size_t v11 = 8;
          break;
        default:
          int v8 = *(_DWORD *)v5;
LABEL_22:
          *(_DWORD *)uint64_t v12 = v8;
          uint64_t v10 = this;
          size_t v11 = 4;
          break;
      }
      uint64_t result = llvm::raw_ostream::write(v10, v12, v11);
      ++v6;
      v7 -= 8;
    }
    while (v7);
  }
  return result;
}

void llvm::memprof::IndexedMemProfRecord::deserialize(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  *(void *)a3 = a3 + 16;
  *(void *)(a3 + 8) = 0x100000000;
  *(void *)(a3 + 184) = a3 + 200;
  uint64_t v49 = a3 + 184;
  *(void *)(a3 + 192) = 0x100000000;
  uint64_t v4 = a2 + 1;
  uint64_t v5 = *a2;
  if (*a2)
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t v50 = v52;
      uint64_t v51 = 0x600000000;
      *(_DWORD *)uint64_t v53 = 0;
      memset(&v53[8], 0, 96);
      uint64_t v9 = v4 + 1;
      uint64_t v8 = *v4;
      if (*v4)
      {
        unsigned int v10 = 0;
        do
        {
          if (v10 >= HIDWORD(v51)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v50 + v10) = *v9;
          unsigned int v10 = v51 + 1;
          LODWORD(v5sub_1CD7485C0(this + 1) = v51 + 1;
          ++v9;
          --v8;
        }
        while (v8);
        uint64_t v4 = v9 - 1;
      }
      uint64_t v11 = *(unsigned int *)(a1 + 8);
      if (v11)
      {
        uint64_t v12 = *(void **)a1;
        uint64_t v13 = 8 * v11;
        do
        {
          switch(*v12)
          {
            case 2:
              uint64_t v17 = *v9++;
              *(void *)&v53[8] = v17;
              break;
            case 3:
              uint64_t v18 = *v9++;
              *(void *)&v53[16] = v18;
              break;
            case 4:
              uint64_t v19 = *v9++;
              *(void *)&v53[24] = v19;
              break;
            case 5:
              uint64_t v20 = *v9++;
              *(void *)&v53[32] = v20;
              break;
            case 6:
              int v21 = *(_DWORD *)v9;
              uint64_t v9 = (uint64_t *)((char *)v9 + 4);
              *(_DWORD *)&v53[40] = v21;
              break;
            case 7:
              int v22 = *(_DWORD *)v9;
              uint64_t v9 = (uint64_t *)((char *)v9 + 4);
              *(_DWORD *)&v53[44] = v22;
              break;
            case 8:
              int v23 = *(_DWORD *)v9;
              uint64_t v9 = (uint64_t *)((char *)v9 + 4);
              *(_DWORD *)&v53[48] = v23;
              break;
            case 9:
              int v24 = *(_DWORD *)v9;
              uint64_t v9 = (uint64_t *)((char *)v9 + 4);
              *(_DWORD *)&v53[52] = v24;
              break;
            case 0xALL:
              uint64_t v25 = *v9++;
              *(void *)&v53[56] = v25;
              break;
            case 0xBLL:
              int v26 = *(_DWORD *)v9;
              uint64_t v9 = (uint64_t *)((char *)v9 + 4);
              *(_DWORD *)&v53[64] = v26;
              break;
            case 0xCLL:
              int v27 = *(_DWORD *)v9;
              uint64_t v9 = (uint64_t *)((char *)v9 + 4);
              *(_DWORD *)&v53[68] = v27;
              break;
            case 0xDLL:
              int v28 = *(_DWORD *)v9;
              uint64_t v9 = (uint64_t *)((char *)v9 + 4);
              *(_DWORD *)&v53[72] = v28;
              break;
            case 0xELL:
              int v29 = *(_DWORD *)v9;
              uint64_t v9 = (uint64_t *)((char *)v9 + 4);
              *(_DWORD *)&v53[76] = v29;
              break;
            case 0xFLL:
              int v15 = *(_DWORD *)v9;
              uint64_t v9 = (uint64_t *)((char *)v9 + 4);
              *(_DWORD *)&v53[80] = v15;
              break;
            case 0x10:
              int v30 = *(_DWORD *)v9;
              uint64_t v9 = (uint64_t *)((char *)v9 + 4);
              *(_DWORD *)&v53[84] = v30;
              break;
            case 0x11:
              int v16 = *(_DWORD *)v9;
              uint64_t v9 = (uint64_t *)((char *)v9 + 4);
              *(_DWORD *)&v53[88] = v16;
              break;
            case 0x12:
              int v31 = *(_DWORD *)v9;
              uint64_t v9 = (uint64_t *)((char *)v9 + 4);
              *(_DWORD *)&v53[92] = v31;
              break;
            case 0x13:
              uint64_t v32 = *v9++;
              *(void *)&v53[96] = v32;
              break;
            default:
              int v14 = *(_DWORD *)v9;
              uint64_t v9 = (uint64_t *)((char *)v9 + 4);
              *(_DWORD *)uint64_t v53 = v14;
              break;
          }
          ++v12;
          v13 -= 8;
        }
        while (v13);
      }
      unsigned int v33 = *(_DWORD *)(a3 + 8);
      unint64_t v34 = *(void *)a3;
      if (v33 >= *(_DWORD *)(a3 + 12))
      {
        BOOL v43 = v34 + 168 * v33 > (unint64_t)&v50;
        if (v34 > (unint64_t)&v50 || !v43) {
          sub_1CD74F738();
        }
        sub_1CD74F738();
      }
      unsigned int v35 = *(_DWORD *)(a3 + 8);
      uint64_t v36 = (void *)(v34 + 168 * v35);
      *uint64_t v36 = v36 + 2;
      v36[1] = 0x600000000;
      if (v51) {
        llvm::DirectedGraph<llvm::DDGNode,llvm::DDGEdge>::operator=((uint64_t)v36, (uint64_t)&v50);
      }
      uint64_t v37 = v34 + 168 * v35;
      long long v38 = *(_OWORD *)v53;
      long long v39 = *(_OWORD *)&v53[32];
      *(_OWORD *)(v37 + 80) = *(_OWORD *)&v53[16];
      *(_OWORD *)(v37 + 96) = v39;
      *(_OWORD *)(v37 + 64) = v38;
      long long v40 = *(_OWORD *)&v53[48];
      long long v41 = *(_OWORD *)&v53[64];
      long long v42 = *(_OWORD *)&v53[80];
      *(void *)(v37 + 160) = *(void *)&v53[96];
      *(_OWORD *)(v37 + 128) = v41;
      *(_OWORD *)(v37 + 144) = v42;
      *(_OWORD *)(v37 + 112) = v40;
      ++*(_DWORD *)(a3 + 8);
      if (v50 != v52) {
        free(v50);
      }
      uint64_t v4 = (uint64_t *)((char *)v4 + 108);
      ++v7;
    }
    while (v7 != v5);
  }
  uint64_t v44 = *v4;
  if (*v4)
  {
    uint64_t v45 = 0;
    unint64_t v46 = (unint64_t *)(v4 + 1);
    do
    {
      unint64_t v47 = *v46;
      uint64_t v50 = v52;
      uint64_t v51 = 0x600000000;
      if (v47 >= 7) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      ++v46;
      if (v47)
      {
        unsigned int v48 = 0;
        do
        {
          if (v48 >= HIDWORD(v51)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v50 + v48) = *v46;
          unsigned int v48 = v51 + 1;
          LODWORD(v5sub_1CD7485C0(this + 1) = v51 + 1;
          ++v46;
          --v47;
        }
        while (v47);
      }
      sub_1CCCF0740(v49, (unint64_t)&v50);
      if (v50 != v52) {
        free(v50);
      }
      ++v45;
    }
    while (v45 != v44);
  }
}

void *sub_1CCCF0740(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 8);
  unint64_t v4 = *(void *)a1;
  if (v3 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v6 = v4 + (v3 << 6);
    if (v4 > a2 || v6 <= a2) {
      sub_1CD74FA34();
    }
    sub_1CD74FA34();
  }
  uint64_t result = (void *)(v4 + ((unint64_t)*(unsigned int *)(a1 + 8) << 6));
  void *result = result + 2;
  result[1] = 0x600000000;
  if (*(_DWORD *)(a2 + 8)) {
    uint64_t result = (void *)llvm::DirectedGraph<llvm::DDGNode,llvm::DDGEdge>::operator=((uint64_t)result, a2);
  }
  ++*(_DWORD *)(a1 + 8);
  return result;
}

uint64_t llvm::memprof::IndexedMemProfRecord::getGUID(int *a1, unint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  v7[0] = (uint64_t)a1;
  v7[1] = a2;
  unint64_t v4 = llvm::StringRef::find(v7, ".llvm.", 6uLL, 0);
  long long v9 = xmmword_1CFAC4320;
  if (a2 >= v4) {
    size_t v5 = v4;
  }
  else {
    size_t v5 = a2;
  }
  uint64_t v10 = 0;
  llvm::MD5::update((int *)&v9, a1, v5);
  llvm::MD5::final((int *)&v9, v8);
  return *(void *)v8;
}

void llvm::memprof::readMemProfSchema(unint64_t **this@<X0>, uint64_t a2@<X8>)
{
  v10[20] = *MEMORY[0x1E4F143B8];
  unint64_t v4 = *this;
  unint64_t v5 = **this;
  if (v5 >= 0x15) {
    operator new();
  }
  uint64_t v8 = v10;
  uint64_t v9 = 0x1400000000;
  unint64_t v6 = v4 + 1;
  if (v5)
  {
    unsigned int v7 = 0;
    do
    {
      if (*v6 > 0x13) {
        operator new();
      }
      if (v7 >= HIDWORD(v9)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v8 + v7) = *v6;
      unsigned int v7 = v9 + 1;
      LODWORD(v9) = v9 + 1;
      ++v6;
      --v5;
    }
    while (v5);
    *this = v6;
    *(unsigned char *)(a2 + 176) &= ~1u;
    *(void *)a2 = a2 + 16;
    *(void *)(a2 + 8) = 0x1400000000;
    if (v7) {
      sub_1CD41C56C(a2, (uint64_t)&v8);
    }
  }
  else
  {
    *this = v6;
    *(unsigned char *)(a2 + 176) &= ~1u;
    *(void *)a2 = a2 + 16;
    *(void *)(a2 + 8) = 0x1400000000;
  }
  if (v8 != v10) {
    free(v8);
  }
}

uint64_t **llvm::InstrProfSummaryBuilder::addRecord(uint64_t **result, uint64_t a2)
{
  uint64_t v3 = (uint64_t)result;
  unint64_t v4 = **(void **)a2;
  ++*((_DWORD *)result + 25);
  if (v4 != -1)
  {
    uint64_t result = sub_1CD7503A0((uint64_t)result, v4);
    if (*(void *)(v3 + 88) < v4) {
      *(void *)(v3 + 88) = v4;
    }
  }
  uint64_t v5 = *(void *)(a2 + 8) - *(void *)a2;
  if ((unint64_t)v5 >= 9)
  {
    unint64_t v6 = v5 >> 3;
    if (v6 <= 2) {
      uint64_t v7 = 2;
    }
    else {
      uint64_t v7 = v6;
    }
    for (uint64_t i = 1; i != v7; ++i)
    {
      unint64_t v9 = *(void *)(*(void *)a2 + 8 * i);
      if (v9 != -1)
      {
        uint64_t result = sub_1CD7503A0(v3, *(void *)(*(void *)a2 + 8 * i));
        if (*(void *)(v3 + 104) < v9) {
          *(void *)(v3 + 104) = v9;
        }
      }
    }
  }
  return result;
}

void llvm::SampleProfileSummaryBuilder::getSummary(llvm::SampleProfileSummaryBuilder *this)
{
}

void sub_1CCCF0C64()
{
}

void sub_1CCCF0D3C()
{
}

void sub_1CCCF0E14(uint64_t a1, char *a2)
{
  if (a2)
  {
    sub_1CCCF0E14(a1, *(void *)a2);
    sub_1CCCF0E14(a1, *((void *)a2 + 1));
    sub_1CD750994(a2 + 152, *((void *)a2 + 20));
    sub_1CD7509F4((uint64_t)(a2 + 128), *((void **)a2 + 17));
    if (a2[55] < 0) {
      operator delete(*((void **)a2 + 4));
    }
    operator delete(a2);
  }
}

uint64_t sub_1CCCF0E90()
{
  int v5 = 1;
  LOBYTE(vsub_1CD7485C0(this + 1) = 0;
  uint64_t v3 = &v1;
  int v2 = 1;
  v4.n128_u64[0] = (unint64_t)"Merge context profiles before calculating thresholds.";
  v4.n128_u64[1] = 53;
  sub_1CD750A50(&v5, (char **)&v3, &v2, &v4);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &UseContextLessSummary, &dword_1CB82C000);
  int v5 = 1;
  int v1 = 1;
  int v2 = 990000;
  uint64_t v3 = &v2;
  v4.n128_u64[0] = (unint64_t)"A count is hot if it exceeds the minimum count to reach this percentile of total counts.";
  v4.n128_u64[1] = 88;
  sub_1CD750BE8(&v5, &v3, &v1, &v4);
  __cxa_atexit((void (*)(void *))sub_1CBB1C45C, &ProfileSummaryCutoffHot, &dword_1CB82C000);
  int v5 = 1;
  int v1 = 1;
  int v2 = 999999;
  uint64_t v3 = &v2;
  v4.n128_u64[0] = (unint64_t)"A count is cold if it is below the minimum count to reach this percentile of total counts.";
  v4.n128_u64[1] = 90;
  sub_1CD750D80(&v5, &v3, &v1, &v4);
  __cxa_atexit((void (*)(void *))sub_1CBB1C45C, &ProfileSummaryCutoffCold, &dword_1CB82C000);
  int v5 = 1;
  int v1 = 1;
  int v2 = 15000;
  uint64_t v3 = &v2;
  v4.n128_u64[0] = (unint64_t)"The code working set size is considered huge if the number of blocks required to re"
                                     "ach the -profile-summary-cutoff-hot percentile exceeds this count.";
  v4.n128_u64[1] = 149;
  sub_1CD750F18(&v5, &v3, &v1, &v4);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &ProfileSummaryHugeWorkingSetSizeThreshold, &dword_1CB82C000);
  int v5 = 1;
  int v1 = 1;
  int v2 = 12500;
  uint64_t v3 = &v2;
  v4.n128_u64[0] = (unint64_t)"The code working set size is considered large if the number of blocks required to r"
                                     "each the -profile-summary-cutoff-hot percentile exceeds this count.";
  v4.n128_u64[1] = 150;
  sub_1CD7510AC(&v5, &v3, &v1, &v4);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &ProfileSummaryLargeWorkingSetSizeThreshold, &dword_1CB82C000);
  LODWORD(v3) = 2;
  int v5 = 1;
  v4.n128_u64[0] = (unint64_t)"A fixed hot count that overrides the count derived from profile-summary-cutoff-hot";
  v4.n128_u64[1] = 82;
  sub_1CD751240(&v3, &v5, (long long *)&v4);
  __cxa_atexit((void (*)(void *))sub_1CC816390, &ProfileSummaryHotCount, &dword_1CB82C000);
  LODWORD(v3) = 2;
  int v5 = 1;
  v4.n128_u64[0] = (unint64_t)"A fixed cold count that overrides the count derived from profile-summary-cutoff-cold";
  v4.n128_u64[1] = 84;
  sub_1CD751358(&v3, &v5, (long long *)&v4);
  return __cxa_atexit((void (*)(void *))sub_1CC816390, &ProfileSummaryColdCount, &dword_1CB82C000);
}

llvm::raw_ostream *llvm::sampleprof::operator<<(llvm::raw_ostream *a1, llvm::sampleprof::LineLocation *this)
{
  return a1;
}

uint64_t sub_1CCCF1128(uint64_t *a1, unint64_t a2, unint64_t a3)
{
  unint64_t v3 = *a1;
  unsigned int v4 = __clz(a3) + __clz(a2);
  if (v4 < 0x40)
  {
    if (v4 != 63
      || (unint64_t v12 = (a2 >> 1) * a3, (v12 & 0x8000000000000000) != 0)
      || (unint64_t v5 = 2 * v12, (a2 & 1) != 0) && (v5 + a3 >= v5 ? (v13 = v5 + a3 >= a3) : (v13 = 0), v5 += a3, !v13))
    {
      *a1 = -1;
      return 10;
    }
  }
  else
  {
    unint64_t v5 = a3 * a2;
  }
  unint64_t v6 = v5 + v3;
  BOOL v8 = v5 + v3 >= v3 && v6 >= v5;
  BOOL v9 = !v8;
  if (v8) {
    uint64_t v10 = v6;
  }
  else {
    uint64_t v10 = -1;
  }
  *a1 = v10;
  if (v9) {
    return 10;
  }
  else {
    return 0;
  }
}

uint64_t sub_1CCCF11AC(uint64_t a1, unsigned __int8 *a2, size_t a3, unint64_t a4, unint64_t a5)
{
  uint64_t v7 = sub_1CD5CF708(a1 + 8, a2, a3);
  BOOL v8 = *v7;
  size_t v9 = (*v7)[1];
  unsigned int v10 = __clz(a5) + __clz(a4);
  if (v10 < 0x40)
  {
    if (v10 != 63
      || (unint64_t v18 = (a4 >> 1) * a5, (v18 & 0x8000000000000000) != 0)
      || (unint64_t v11 = 2 * v18, (a4 & 1) != 0) && (v11 + a5 >= v11 ? (v19 = v11 + a5 >= a5) : (v19 = 0), v11 += a5, !v19))
    {
      v8[1] = -1;
      return 10;
    }
  }
  else
  {
    unint64_t v11 = a5 * a4;
  }
  unint64_t v12 = v11 + v9;
  BOOL v14 = v11 + v9 >= v9 && v12 >= v11;
  BOOL v15 = !v14;
  if (v14) {
    uint64_t v16 = v12;
  }
  else {
    uint64_t v16 = -1;
  }
  v8[1] = v16;
  if (v15) {
    return 10;
  }
  else {
    return 0;
  }
}

llvm::raw_ostream *llvm::sampleprof::operator<<(llvm::raw_ostream *a1, llvm::sampleprof::SampleRecord *this)
{
  return a1;
}

llvm::raw_ostream *llvm::sampleprof::operator<<(llvm::raw_ostream *a1, llvm::sampleprof::FunctionSamples *a2)
{
  return a1;
}

void llvm::sampleprof::sortFuncProfiles(uint64_t a1, uint64_t *a2)
{
  unint64_t v3 = *(uint64_t **)(a1 + 16);
  if (v3)
  {
    unsigned int v4 = (_OWORD *)a2[1];
    do
    {
      unint64_t v5 = v3 + 7;
      long long v26 = *(_OWORD *)(v3 + 9);
      long long v27 = *(_OWORD *)(v3 + 11);
      uint64_t v28 = v3[13];
      unint64_t v6 = a2[2];
      if ((unint64_t)v4 >= v6)
      {
        unsigned int v10 = (_OWORD *)*a2;
        unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v4 - *a2) >> 4);
        unint64_t v12 = v11 + 1;
        if (v11 + 1 > 0x555555555555555) {
          abort();
        }
        unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v6 - (void)v10) >> 4);
        if (2 * v13 > v12) {
          unint64_t v12 = 2 * v13;
        }
        if (v13 >= 0x2AAAAAAAAAAAAAALL) {
          unint64_t v14 = 0x555555555555555;
        }
        else {
          unint64_t v14 = v12;
        }
        if (v14)
        {
          if (v14 > 0x555555555555555) {
            sub_1CB833614();
          }
          BOOL v15 = (char *)operator new(48 * v14);
        }
        else
        {
          BOOL v15 = 0;
        }
        uint64_t v16 = &v15[48 * v11];
        *(_OWORD *)uint64_t v16 = v26;
        *((_OWORD *)v16 + sub_1CD7485C0(this + 1) = v27;
        *((void *)v16 + 4) = v28;
        *((void *)v16 + 5) = v5;
        uint64_t v17 = v16;
        if (v4 != v10)
        {
          do
          {
            long long v18 = *(v4 - 3);
            long long v19 = *(v4 - 1);
            *((_OWORD *)v17 - 2) = *(v4 - 2);
            *((_OWORD *)v17 - sub_1CD7485C0(this + 1) = v19;
            *((_OWORD *)v17 - 3) = v18;
            v17 -= 48;
            v4 -= 3;
          }
          while (v4 != v10);
          unsigned int v4 = (_OWORD *)*a2;
        }
        size_t v9 = v16 + 48;
        *a2 = (uint64_t)v17;
        a2[1] = (uint64_t)(v16 + 48);
        a2[2] = (uint64_t)&v15[48 * v14];
        if (v4) {
          operator delete(v4);
        }
      }
      else
      {
        long long v7 = *(_OWORD *)(v3 + 11);
        uint64_t v8 = v3[13];
        *unsigned int v4 = *(_OWORD *)(v3 + 9);
        v4[1] = v7;
        *((void *)v4 + 4) = v8;
        *((void *)v4 + 5) = v5;
        size_t v9 = v4 + 3;
      }
      a2[1] = (uint64_t)v9;
      unint64_t v3 = (uint64_t *)*v3;
      unsigned int v4 = v9;
    }
    while (v3);
  }
  else
  {
    size_t v9 = (_OWORD *)a2[1];
  }
  uint64_t v20 = *a2;
  if ((uint64_t)v9 - v20 < 1)
  {
LABEL_27:
    sub_1CCCF3BC8(v20, v9, 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v9 - v20) >> 4), 0, 0);
  }
  else
  {
    int v21 = (const std::nothrow_t *)MEMORY[0x1E4FBA2D0];
    unint64_t v22 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v9 - v20) >> 4);
    while (1)
    {
      int v23 = (char *)operator new(48 * v22, v21);
      if (v23) {
        break;
      }
      BOOL v24 = v22 > 1;
      v22 >>= 1;
      if (!v24) {
        goto LABEL_27;
      }
    }
    uint64_t v25 = v23;
    sub_1CCCF3BC8(v20, v9, 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v9 - v20) >> 4), v23, v22);
    operator delete(v25);
  }
}

void llvm::sampleprof::SampleContextTrimmer::trimAndMergeColdContextProfiles(llvm::sampleprof::SampleContextTrimmer *this, unint64_t a2, int a3, int a4, unsigned int a5, int a6)
{
  if (a3)
  {
    if (!a2) {
      return;
    }
  }
  else if (!a2 || (a4 & 1) == 0)
  {
    return;
  }
  uint64_t v8 = *(uint64_t **)(*(void *)this + 16);
  if (!v8)
  {
    size_t v9 = 0;
    unsigned int v10 = 0;
    long long v108 = 0u;
    long long v109 = 0u;
    float v110 = 1.0;
    goto LABEL_142;
  }
  unint64_t v11 = 0;
  unint64_t v12 = 0;
  size_t v9 = 0;
  int v13 = a6 & ~a4;
  do
  {
    if (v8[14] < a2 && (!v13 || v8[5] == 1))
    {
      unint64_t v14 = v8 + 2;
      BOOL v15 = v8 + 7;
      if (v9 >= v11)
      {
        uint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v9 - v12) >> 4);
        unint64_t v18 = v6 + 1;
        if ((unint64_t)(v6 + 1) > 0x555555555555555) {
          abort();
        }
        if (0x5555555555555556 * ((v11 - v12) >> 4) > v18) {
          unint64_t v18 = 0x5555555555555556 * ((v11 - v12) >> 4);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((v11 - v12) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
          unint64_t v18 = 0x555555555555555;
        }
        if (v18 > 0x555555555555555) {
          sub_1CB833614();
        }
        uint64_t v19 = 3 * v18;
        uint64_t v20 = (char *)operator new(48 * v18);
        int v21 = &v20[16 * ((v9 - v12) >> 4)];
        uint64_t v22 = v8[6];
        long long v23 = *((_OWORD *)v8 + 2);
        *(_OWORD *)int v21 = *v14;
        *((_OWORD *)v21 + sub_1CD7485C0(this + 1) = v23;
        *((void *)v21 + 4) = v22;
        *((void *)v21 + 5) = v15;
        if (v9 == v12)
        {
          uint64_t v25 = &v20[16 * ((v9 - v12) >> 4)];
        }
        else
        {
          BOOL v24 = &v20[16 * ((v9 - v12) >> 4)];
          do
          {
            uint64_t v25 = v24 - 48;
            long long v26 = *((_OWORD *)v9 - 3);
            long long v27 = *((_OWORD *)v9 - 1);
            *((_OWORD *)v24 - 2) = *((_OWORD *)v9 - 2);
            *((_OWORD *)v24 - sub_1CD7485C0(this + 1) = v27;
            *((_OWORD *)v24 - 3) = v26;
            v9 -= 48;
            v24 -= 48;
          }
          while (v9 != v12);
        }
        unint64_t v11 = &v20[16 * v19];
        size_t v9 = v21 + 48;
        if (v12) {
          operator delete(v12);
        }
        unint64_t v12 = v25;
      }
      else
      {
        long long v16 = *((_OWORD *)v8 + 2);
        uint64_t v17 = v8[6];
        *(_OWORD *)size_t v9 = *v14;
        *((_OWORD *)v9 + sub_1CD7485C0(this + 1) = v16;
        *((void *)v9 + 4) = v17;
        *((void *)v9 + 5) = v15;
        v9 += 48;
      }
    }
    uint64_t v8 = (uint64_t *)*v8;
  }
  while (v8);
  long long v108 = 0u;
  long long v109 = 0u;
  float v110 = 1.0;
  if (v12 == v9)
  {
    unsigned int v10 = 0;
    goto LABEL_142;
  }
  uint64_t v28 = (uint64_t)v12;
  int v29 = this;
  int v30 = a4;
  do
  {
    if (!v30) {
      goto LABEL_81;
    }
    uint64_t v99 = v28;
    uint64_t v31 = *(void *)(v28 + 40);
    uint64_t v33 = *(void *)(v31 + 32);
    unint64_t v32 = *(void *)(v31 + 40);
    if (v32 >= a5) {
      unint64_t v34 = a5;
    }
    else {
      unint64_t v34 = v32;
    }
    if (v32 <= a5) {
      uint64_t v35 = v33;
    }
    else {
      uint64_t v35 = v33 + 24 * (v32 - a5);
    }
    long long v104 = 0u;
    uint64_t v106 = 0;
    uint64_t v107 = 0;
    *((void *)&v103 + sub_1CD7485C0(this + 1) = &v104;
    uint64_t v105 = &v106;
    uint64_t v36 = (char *)operator new(0xB0uLL);
    *((_DWORD *)v36 + 13) = 0;
    *(void *)uint64_t v36 = 0;
    *((void *)v36 + sub_1CD7485C0(this + 1) = 0;
    *((void *)v36 + 4) = v35;
    *((void *)v36 + 5) = v34;
    *((_OWORD *)v36 + sub_1CD7485C0(this + 1) = *(_OWORD *)(v35 + 24 * v34 - 24);
    *((_DWORD *)v36 + 12) = 1;
    *(_OWORD *)(v36 + 104) = 0u;
    *(_OWORD *)(v36 + 88) = 0u;
    *(_OWORD *)(v36 + 72) = 0u;
    *(_OWORD *)(v36 + 56) = 0u;
    *((void *)v36 + 17) = 0;
    *((void *)v36 + 15) = 0;
    *((void *)v36 + 16) = v36 + 136;
    *((void *)v36 + 2sub_1CD7485C0(this + 1) = 0;
    *((void *)v36 + 20) = 0;
    *((void *)v36 + 18) = 0;
    *((void *)v36 + 19) = v36 + 160;
    *((void *)v36 + sub_1CD7485C0(this + 1) = sub_1CD681950((uint64_t)(v36 + 16));
    unint64_t v37 = sub_1CD681950((uint64_t)(v36 + 16));
    *((void *)v36 + sub_1CD7485C0(this + 1) = v37;
    unint64_t v38 = *((void *)&v108 + 1);
    if (*((void *)&v108 + 1))
    {
      unint64_t v39 = v37;
      uint8x8_t v40 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v108 + 8));
      v40.i16[0] = vaddlv_u8(v40);
      unint64_t v41 = v40.u32[0];
      if (v40.u32[0] > 1uLL)
      {
        unint64_t v42 = v37;
        if (*((void *)&v108 + 1) <= v37) {
          unint64_t v42 = v37 % *((void *)&v108 + 1);
        }
      }
      else
      {
        unint64_t v42 = (*((void *)&v108 + 1) - 1) & v37;
      }
      BOOL v43 = *(char ***)(v108 + 8 * v42);
      if (v43)
      {
        uint64_t v44 = *v43;
        if (*v43)
        {
          uint64_t v6 = *((void *)&v108 + 1) - 1;
          do
          {
            unint64_t v56 = *((void *)v44 + 1);
            if (v56 == v39)
            {
              if (sub_1CD681C28((uint64_t)(v44 + 16), (uint64_t)(v36 + 16)))
              {
                sub_1CCCF491C(1, (void **)v36);
                uint64_t v36 = v44;
                uint64_t v28 = v99;
                int v29 = this;
                int v30 = a4;
                goto LABEL_80;
              }
            }
            else
            {
              if (v41 > 1)
              {
                if (v56 >= v38) {
                  v56 %= v38;
                }
              }
              else
              {
                v56 &= v6;
              }
              if (v56 != v42) {
                break;
              }
            }
            uint64_t v44 = *(char **)v44;
          }
          while (v44);
        }
      }
    }
    float v45 = (float)(unint64_t)(*((void *)&v109 + 1) + 1);
    if (!v38 || (float)(v110 * (float)v38) < v45)
    {
      BOOL v46 = (v38 & (v38 - 1)) != 0;
      if (v38 < 3) {
        BOOL v46 = 1;
      }
      unint64_t v47 = v46 | (2 * v38);
      unint64_t v48 = vcvtps_u32_f32(v45 / v110);
      if (v47 <= v48) {
        size_t v49 = v48;
      }
      else {
        size_t v49 = v47;
      }
      sub_1CC9B3D48((uint64_t)&v108, v49);
    }
    unint64_t v50 = *((void *)&v108 + 1);
    unint64_t v51 = *((void *)v36 + 1);
    uint8x8_t v52 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v108 + 8));
    v52.i16[0] = vaddlv_u8(v52);
    uint64_t v28 = v99;
    int v29 = this;
    if (v52.u32[0] > 1uLL)
    {
      if (v51 >= *((void *)&v108 + 1)) {
        v51 %= *((void *)&v108 + 1);
      }
    }
    else
    {
      v51 &= *((void *)&v108 + 1) - 1;
    }
    uint64_t v53 = v108;
    uint64_t v54 = *(void **)(v108 + 8 * v51);
    int v30 = a4;
    if (v54)
    {
      *(void *)uint64_t v36 = *v54;
    }
    else
    {
      *(void *)uint64_t v36 = v109;
      *(void *)&long long v109 = v36;
      *(void *)(v53 + 8 * v5sub_1CD7485C0(this + 1) = &v109;
      if (!*(void *)v36) {
        goto LABEL_79;
      }
      unint64_t v55 = *(void *)(*(void *)v36 + 8);
      if (v52.u32[0] > 1uLL)
      {
        if (v55 >= v50) {
          v55 %= v50;
        }
      }
      else
      {
        v55 &= v50 - 1;
      }
      uint64_t v54 = (void *)(v108 + 8 * v55);
    }
    *uint64_t v54 = v36;
LABEL_79:
    ++*((void *)&v109 + 1);
LABEL_80:
    sub_1CD750994((uint64_t)&v105, v106);
    sub_1CD7509F4((uint64_t)&v103 + 8, (void *)v104);
    sub_1CD67DFD0((uint64_t)(v36 + 56), *(void *)(v28 + 40), 1uLL);
LABEL_81:
    int64_t v57 = *(void **)v29;
    int64_t v58 = sub_1CD681854(*(void **)v29, v28);
    if (v58) {
      sub_1CCCF4974(v57, v58);
    }
    v28 += 48;
  }
  while ((char *)v28 != v9);
  uint64_t v59 = (void *)v109;
  if (!(void)v109)
  {
    unsigned int v10 = 0;
    goto LABEL_141;
  }
  int v60 = a3;
  while (2)
  {
    uint64_t v61 = (uint64_t)(v59 + 2);
    if (!v60 || v59[14] >= a2 || sub_1CD681854(*(void **)v29, (uint64_t)(v59 + 2)))
    {
      int64x2_t v102 = v59;
      uint64_t v62 = *(void *)v29;
      long long v104 = 0u;
      uint64_t v106 = 0;
      uint64_t v107 = 0;
      *((void *)&v103 + sub_1CD7485C0(this + 1) = &v104;
      uint64_t v105 = &v106;
      unint64_t v63 = sub_1CD681950((uint64_t)(v59 + 2));
      unint64_t v64 = v63;
      unint64_t v65 = *(void *)(v62 + 8);
      if (v65)
      {
        uint8x8_t v66 = (uint8x8_t)vcnt_s8((int8x8_t)v65);
        v66.i16[0] = vaddlv_u8(v66);
        unint64_t v67 = v66.u32[0];
        if (v66.u32[0] > 1uLL)
        {
          uint64_t v6 = v63;
          if (v63 >= v65) {
            uint64_t v6 = v63 % v65;
          }
        }
        else
        {
          uint64_t v6 = (v65 - 1) & v63;
        }
        unsigned int v68 = *(void ***)(*(void *)v62 + 8 * v6);
        if (v68)
        {
          uint64_t v69 = *v68;
          if (*v68)
          {
            while (1)
            {
              unint64_t v70 = v69[1];
              if (v70 == v64)
              {
                if (sub_1CD681C28((uint64_t)(v69 + 2), v61))
                {
                  char v71 = 1;
                  int v60 = a3;
                  uint64_t v59 = v102;
                  goto LABEL_136;
                }
              }
              else
              {
                if (v67 > 1)
                {
                  if (v70 >= v65) {
                    v70 %= v65;
                  }
                }
                else
                {
                  v70 &= v65 - 1;
                }
                if (v70 != v6)
                {
LABEL_107:
                  int v60 = a3;
                  break;
                }
              }
              uint64_t v69 = (void *)*v69;
              if (!v69) {
                goto LABEL_107;
              }
            }
          }
        }
      }
      uint64_t v72 = (char *)operator new(0xB0uLL);
      uint64_t v69 = v72;
      *(void *)uint64_t v72 = 0;
      *((void *)v72 + sub_1CD7485C0(this + 1) = v64;
      uint64_t v73 = *(void *)(v61 + 32);
      long long v74 = *(_OWORD *)(v61 + 16);
      *((_OWORD *)v72 + sub_1CD7485C0(this + 1) = *(_OWORD *)v61;
      *((_OWORD *)v72 + 2) = v74;
      *(_OWORD *)(v72 + 56) = 0u;
      *(_OWORD *)(v72 + 104) = 0u;
      *((void *)v72 + 6) = v73;
      *(_OWORD *)(v72 + 88) = 0u;
      *(_OWORD *)(v72 + 72) = 0u;
      uint64_t v75 = *((void *)&v103 + 1);
      *((void *)v72 + 15) = 0;
      *((void *)v72 + 16) = v75;
      long long v76 = v104;
      *((void *)v72 + 17) = v104;
      uint64_t v77 = v72 + 136;
      *((void *)v72 + 18) = *((void *)&v76 + 1);
      if (*((void *)&v76 + 1))
      {
        *(void *)(v76 + 16) = v77;
        *((void *)&v103 + sub_1CD7485C0(this + 1) = &v104;
        long long v104 = 0uLL;
      }
      else
      {
        *((void *)v72 + 16) = v77;
      }
      unint64_t v79 = v105;
      uint64_t v78 = v106;
      *((void *)v72 + 20) = v106;
      uint64_t v80 = v72 + 160;
      *((void *)v72 + 19) = v79;
      uint64_t v81 = v107;
      *((void *)v72 + 2sub_1CD7485C0(this + 1) = v107;
      if (v81)
      {
        v78[2] = v80;
        uint64_t v105 = &v106;
        uint64_t v106 = 0;
        uint64_t v107 = 0;
      }
      else
      {
        *((void *)v72 + 19) = v80;
      }
      float v82 = (float)(unint64_t)(*(void *)(v62 + 24) + 1);
      float v83 = *(float *)(v62 + 32);
      if (!v65 || (float)(v83 * (float)v65) < v82)
      {
        BOOL v84 = (v65 & (v65 - 1)) != 0;
        if (v65 < 3) {
          BOOL v84 = 1;
        }
        unint64_t v85 = v84 | (2 * v65);
        unint64_t v86 = vcvtps_u32_f32(v82 / v83);
        if (v85 <= v86) {
          size_t v87 = v86;
        }
        else {
          size_t v87 = v85;
        }
        sub_1CC9B3D48(v62, v87);
        unint64_t v65 = *(void *)(v62 + 8);
        if ((v65 & (v65 - 1)) != 0)
        {
          if (v64 >= v65) {
            uint64_t v6 = v64 % v65;
          }
          else {
            uint64_t v6 = v64;
          }
        }
        else
        {
          uint64_t v6 = (v65 - 1) & v64;
        }
      }
      uint64_t v88 = *(void *)v62;
      size_t v89 = *(void **)(*(void *)v62 + 8 * v6);
      if (v89)
      {
        *uint64_t v69 = *v89;
        uint64_t v59 = v102;
        goto LABEL_134;
      }
      *uint64_t v69 = *(void *)(v62 + 16);
      *(void *)(v62 + 16) = v69;
      *(void *)(v88 + 8 * v6) = v62 + 16;
      uint64_t v59 = v102;
      if (*v69)
      {
        unint64_t v90 = *(void *)(*v69 + 8);
        if ((v65 & (v65 - 1)) != 0)
        {
          if (v90 >= v65) {
            v90 %= v65;
          }
        }
        else
        {
          v90 &= v65 - 1;
        }
        size_t v89 = (void *)(*(void *)v62 + 8 * v90);
LABEL_134:
        void *v89 = v69;
      }
      char v71 = 0;
      ++*(void *)(v62 + 24);
LABEL_136:
      sub_1CD750994((uint64_t)&v105, v106);
      sub_1CD7509F4((uint64_t)&v103 + 8, (void *)v104);
      int v29 = this;
      if ((v71 & 1) == 0)
      {
        uint64_t v91 = v69[4];
        uint64_t v92 = v69[5];
        uint64_t v93 = v91 + 24 * v92;
        uint64_t v95 = *(void *)(v93 - 24);
        uint64_t v94 = *(void *)(v93 - 16);
        v69[9] = v95;
        v69[10] = v94;
        v69[11] = v91;
        v69[12] = v92;
        v69[13] = 1;
      }
      sub_1CD67DFD0((uint64_t)(v69 + 7), (uint64_t)(v59 + 7), 1uLL);
    }
    uint64_t v59 = (void *)*v59;
    if (v59) {
      continue;
    }
    break;
  }
  unsigned int v10 = (void **)v109;
LABEL_141:
  size_t v9 = v12;
LABEL_142:
  sub_1CD751470((uint64_t)&v108, v10);
  unint64_t v96 = (void *)v108;
  *(void *)&long long v108 = 0;
  if (v96) {
    operator delete(v96);
  }
  if (v9) {
    operator delete(v9);
  }
}

void llvm::sampleprof::SampleContextTrimmer::canonicalizeContextProfiles(llvm::sampleprof::SampleContextTrimmer *this)
{
  *(_OWORD *)std::string __p = 0u;
  long long v74 = 0u;
  float v75 = 1.0;
  unint64_t v3 = *(uint64_t **)(*(void *)this + 16);
  if (v3)
  {
    unint64_t v5 = 0;
    unsigned int v4 = 0;
    uint64_t v6 = 0;
    while (sub_1CD681C28((uint64_t)(v3 + 2), (uint64_t)(v3 + 9)))
    {
LABEL_63:
      unint64_t v3 = (uint64_t *)*v3;
      if (!v3)
      {
        if (v5 != v4)
        {
          uint64_t v40 = (uint64_t)v5;
          do
          {
            unint64_t v41 = *(void **)this;
            unint64_t v42 = sub_1CD681854(*(void **)this, v40);
            if (v42) {
              sub_1CCCF4974(v41, v42);
            }
            v40 += 40;
          }
          while ((char *)v40 != v4);
          unsigned int v4 = v5;
        }
        goto LABEL_70;
      }
    }
    unint64_t v70 = (long long *)(v3 + 2);
    unint64_t v71 = (unint64_t)v6;
    unint64_t v7 = sub_1CD681950((uint64_t)(v3 + 9));
    unint64_t v8 = v7;
    unint64_t v2 = (unint64_t)__p[1];
    if (__p[1])
    {
      uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)__p[1]);
      v9.i16[0] = vaddlv_u8(v9);
      unint64_t v10 = v9.u32[0];
      if (v9.u32[0] > 1uLL)
      {
        unint64_t v1 = v7;
        if ((void *)v7 >= __p[1]) {
          unint64_t v1 = v7 % (unint64_t)__p[1];
        }
      }
      else
      {
        unint64_t v1 = ((unint64_t)__p[1] - 1) & v7;
      }
      unint64_t v11 = (void *)*((void *)__p[0] + v1);
      if (v11)
      {
        unint64_t v12 = (void *)*v11;
        if (*v11)
        {
          do
          {
            unint64_t v24 = v12[1];
            if (v24 == v8)
            {
              if (sub_1CD681C28((uint64_t)(v12 + 2), (uint64_t)(v3 + 9))) {
                goto LABEL_44;
              }
            }
            else
            {
              if (v10 > 1)
              {
                if (v24 >= v2) {
                  v24 %= v2;
                }
              }
              else
              {
                v24 &= v2 - 1;
              }
              if (v24 != v1) {
                break;
              }
            }
            unint64_t v12 = (void *)*v12;
          }
          while (v12);
        }
      }
    }
    int v13 = (char *)operator new(0xB0uLL);
    *(void *)int v13 = 0;
    *((void *)v13 + sub_1CD7485C0(this + 1) = v8;
    uint64_t v14 = v3[13];
    long long v15 = *(_OWORD *)(v3 + 11);
    *((_OWORD *)v13 + sub_1CD7485C0(this + 1) = *(_OWORD *)(v3 + 9);
    *((_OWORD *)v13 + 2) = v15;
    *((void *)v13 + 6) = v14;
    long long v17 = *(_OWORD *)(v3 + 11);
    long long v16 = *(_OWORD *)(v3 + 13);
    long long v18 = *(_OWORD *)(v3 + 9);
    *((void *)v13 + 15) = v3[15];
    *(_OWORD *)(v13 + 72) = v18;
    *(_OWORD *)(v13 + 104) = v16;
    *(_OWORD *)(v13 + 88) = v17;
    *(_OWORD *)(v13 + 56) = *(_OWORD *)(v3 + 7);
    sub_1CCCF4A9C((uint64_t)(v13 + 128), v3 + 16);
    sub_1CCCF4D4C((uint64_t)(v13 + 152), v3 + 19);
    float v19 = (float)(unint64_t)(*((void *)&v74 + 1) + 1);
    if (!v2 || (float)(v75 * (float)v2) < v19)
    {
      BOOL v20 = (v2 & (v2 - 1)) != 0;
      if (v2 < 3) {
        BOOL v20 = 1;
      }
      unint64_t v21 = v20 | (2 * v2);
      unint64_t v22 = vcvtps_u32_f32(v19 / v75);
      if (v21 <= v22) {
        size_t v23 = v22;
      }
      else {
        size_t v23 = v21;
      }
      sub_1CC9B3D48((uint64_t)__p, v23);
      unint64_t v2 = (unint64_t)__p[1];
      if (((unint64_t)__p[1] & ((unint64_t)__p[1] - 1)) != 0)
      {
        if ((void *)v8 >= __p[1]) {
          unint64_t v1 = v8 % (unint64_t)__p[1];
        }
        else {
          unint64_t v1 = v8;
        }
      }
      else
      {
        unint64_t v1 = ((unint64_t)__p[1] - 1) & v8;
      }
    }
    uint64_t v25 = __p[0];
    long long v26 = (void *)*((void *)__p[0] + v1);
    if (v26)
    {
      *(void *)int v13 = *v26;
    }
    else
    {
      *(void *)int v13 = v74;
      *(void *)&long long v74 = v13;
      v25[v1] = &v74;
      if (!*(void *)v13) {
        goto LABEL_43;
      }
      unint64_t v27 = *(void *)(*(void *)v13 + 8);
      if ((v2 & (v2 - 1)) != 0)
      {
        if (v27 >= v2) {
          v27 %= v2;
        }
      }
      else
      {
        v27 &= v2 - 1;
      }
      long long v26 = (char *)__p[0] + 8 * v27;
    }
    *long long v26 = v13;
LABEL_43:
    ++*((void *)&v74 + 1);
LABEL_44:
    uint64_t v6 = (char *)v71;
    if ((unint64_t)v4 >= v71)
    {
      unint64_t v30 = 0xCCCCCCCCCCCCCCCDLL * ((v4 - v5) >> 3) + 1;
      unint64_t v1 = (unint64_t)(v3 + 2);
      if (v30 > 0x666666666666666) {
        abort();
      }
      if (0x999999999999999ALL * ((uint64_t)(v71 - (void)v5) >> 3) > v30) {
        unint64_t v30 = 0x999999999999999ALL * ((uint64_t)(v71 - (void)v5) >> 3);
      }
      if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v71 - (void)v5) >> 3) >= 0x333333333333333) {
        unint64_t v31 = 0x666666666666666;
      }
      else {
        unint64_t v31 = v30;
      }
      if (v31)
      {
        if (v31 > 0x666666666666666) {
          sub_1CB833614();
        }
        unint64_t v32 = (char *)operator new(40 * v31);
      }
      else
      {
        unint64_t v32 = 0;
      }
      uint64_t v33 = &v32[8 * ((v4 - v5) >> 3)];
      long long v34 = *v70;
      long long v35 = *((_OWORD *)v3 + 2);
      *((void *)v33 + 4) = v3[6];
      *(_OWORD *)uint64_t v33 = v34;
      *((_OWORD *)v33 + sub_1CD7485C0(this + 1) = v35;
      if (v4 == v5)
      {
        uint64_t v36 = &v32[8 * ((v4 - v5) >> 3)];
      }
      else
      {
        unint64_t v37 = &v32[8 * ((v4 - v5) >> 3)];
        do
        {
          long long v38 = *(_OWORD *)(v4 - 40);
          long long v39 = *(_OWORD *)(v4 - 24);
          uint64_t v36 = v37 - 40;
          *((void *)v37 - sub_1CD7485C0(this + 1) = *((void *)v4 - 1);
          *(_OWORD *)(v37 - 24) = v39;
          *(_OWORD *)(v37 - 40) = v38;
          v4 -= 40;
          v37 -= 40;
        }
        while (v4 != v5);
      }
      uint64_t v6 = &v32[40 * v31];
      unsigned int v4 = v33 + 40;
      if (v5) {
        operator delete(v5);
      }
      unint64_t v5 = v36;
    }
    else
    {
      long long v28 = *v70;
      long long v29 = *((_OWORD *)v3 + 2);
      *((void *)v4 + 4) = v3[6];
      *(_OWORD *)unsigned int v4 = v28;
      *((_OWORD *)v4 + sub_1CD7485C0(this + 1) = v29;
      v4 += 40;
    }
    goto LABEL_63;
  }
  unsigned int v4 = 0;
LABEL_70:
  BOOL v43 = (uint64_t *)v74;
  if (!(void)v74)
  {
    uint64_t v44 = 0;
    goto LABEL_113;
  }
  do
  {
    uint64_t v45 = *(void *)this;
    unint64_t v46 = sub_1CD681950((uint64_t)(v43 + 2));
    unint64_t v47 = v46;
    unint64_t v48 = *(void *)(v45 + 8);
    if (v48)
    {
      uint8x8_t v49 = (uint8x8_t)vcnt_s8((int8x8_t)v48);
      v49.i16[0] = vaddlv_u8(v49);
      unint64_t v50 = v49.u32[0];
      if (v49.u32[0] > 1uLL)
      {
        unint64_t v2 = v46;
        if (v46 >= v48) {
          unint64_t v2 = v46 % v48;
        }
      }
      else
      {
        unint64_t v2 = (v48 - 1) & v46;
      }
      unint64_t v51 = *(void **)(*(void *)v45 + 8 * v2);
      if (v51)
      {
        uint8x8_t v52 = (void *)*v51;
        if (*v51)
        {
          do
          {
            unint64_t v65 = v52[1];
            if (v65 == v47)
            {
              if (sub_1CD681C28((uint64_t)(v52 + 2), (uint64_t)(v43 + 2))) {
                goto LABEL_111;
              }
            }
            else
            {
              if (v50 > 1)
              {
                if (v65 >= v48) {
                  v65 %= v48;
                }
              }
              else
              {
                v65 &= v48 - 1;
              }
              if (v65 != v2) {
                break;
              }
            }
            uint8x8_t v52 = (void *)*v52;
          }
          while (v52);
        }
      }
    }
    uint64_t v53 = (char *)operator new(0xB0uLL);
    *(void *)uint64_t v53 = 0;
    *((void *)v53 + sub_1CD7485C0(this + 1) = v47;
    uint64_t v54 = v43[6];
    long long v55 = *((_OWORD *)v43 + 2);
    *((_OWORD *)v53 + sub_1CD7485C0(this + 1) = *((_OWORD *)v43 + 1);
    *((_OWORD *)v53 + 2) = v55;
    *((void *)v53 + 6) = v54;
    long long v57 = *(_OWORD *)(v43 + 11);
    long long v56 = *(_OWORD *)(v43 + 13);
    long long v58 = *(_OWORD *)(v43 + 9);
    *((void *)v53 + 15) = v43[15];
    *(_OWORD *)(v53 + 72) = v58;
    *(_OWORD *)(v53 + 104) = v56;
    *(_OWORD *)(v53 + 88) = v57;
    *(_OWORD *)(v53 + 56) = *(_OWORD *)(v43 + 7);
    sub_1CCCF4A9C((uint64_t)(v53 + 128), v43 + 16);
    sub_1CCCF4D4C((uint64_t)(v53 + 152), v43 + 19);
    float v59 = (float)(unint64_t)(*(void *)(v45 + 24) + 1);
    float v60 = *(float *)(v45 + 32);
    if (!v48 || (float)(v60 * (float)v48) < v59)
    {
      BOOL v61 = (v48 & (v48 - 1)) != 0;
      if (v48 < 3) {
        BOOL v61 = 1;
      }
      unint64_t v62 = v61 | (2 * v48);
      unint64_t v63 = vcvtps_u32_f32(v59 / v60);
      if (v62 <= v63) {
        size_t v64 = v63;
      }
      else {
        size_t v64 = v62;
      }
      sub_1CC9B3D48(v45, v64);
      unint64_t v48 = *(void *)(v45 + 8);
      if ((v48 & (v48 - 1)) != 0)
      {
        if (v47 >= v48) {
          unint64_t v2 = v47 % v48;
        }
        else {
          unint64_t v2 = v47;
        }
      }
      else
      {
        unint64_t v2 = (v48 - 1) & v47;
      }
    }
    uint64_t v66 = *(void *)v45;
    unint64_t v67 = *(void **)(*(void *)v45 + 8 * v2);
    if (v67)
    {
      *(void *)uint64_t v53 = *v67;
LABEL_109:
      *unint64_t v67 = v53;
      goto LABEL_110;
    }
    *(void *)uint64_t v53 = *(void *)(v45 + 16);
    *(void *)(v45 + 16) = v53;
    *(void *)(v66 + 8 * v2) = v45 + 16;
    if (*(void *)v53)
    {
      unint64_t v68 = *(void *)(*(void *)v53 + 8);
      if ((v48 & (v48 - 1)) != 0)
      {
        if (v68 >= v48) {
          v68 %= v48;
        }
      }
      else
      {
        v68 &= v48 - 1;
      }
      unint64_t v67 = (void *)(*(void *)v45 + 8 * v68);
      goto LABEL_109;
    }
LABEL_110:
    ++*(void *)(v45 + 24);
LABEL_111:
    BOOL v43 = (uint64_t *)*v43;
  }
  while (v43);
  uint64_t v44 = (void **)v74;
LABEL_113:
  sub_1CD751470((uint64_t)__p, v44);
  uint64_t v69 = __p[0];
  __p[0] = 0;
  if (v69) {
    operator delete(v69);
  }
  if (v4) {
    operator delete(v4);
  }
}

uint64_t llvm::sampleprof::ProfileSymbolList::write(llvm::sampleprof::ProfileSymbolList *this, llvm::raw_ostream *a2)
{
  if (!*((_DWORD *)this + 4)) {
    goto LABEL_13;
  }
  uint64_t v3 = *((unsigned int *)this + 6);
  if (v3)
  {
    uint64_t v10 = 16 * v3;
    unsigned int v4 = (unint64_t *)*((void *)this + 1);
    while (*v4 >= 0xFFFFFFFFFFFFFFFELL)
    {
      v4 += 2;
      v10 -= 16;
      if (!v10) {
        goto LABEL_13;
      }
    }
  }
  else
  {
    unsigned int v4 = (unint64_t *)*((void *)this + 1);
  }
  uint64_t v5 = *((void *)this + 1) + 16 * v3;
  if ((unint64_t *)v5 == v4)
  {
LABEL_13:
    unint64_t v11 = 0;
    unint64_t v12 = 0;
  }
  else
  {
    unint64_t v6 = 0;
    unint64_t v7 = v4;
LABEL_6:
    unint64_t v8 = v7 + 2;
    while (v8 != (unint64_t *)v5)
    {
      unint64_t v9 = *v8;
      v8 += 2;
      if (v9 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        unint64_t v7 = v8 - 2;
        ++v6;
        goto LABEL_6;
      }
    }
    if (v6 >= 0xFFFFFFFFFFFFFFFLL) {
LABEL_61:
    }
      abort();
    unint64_t v11 = (long long *)operator new(16 * (v6 + 1));
    uint64_t v36 = v11;
LABEL_56:
    *uint64_t v36 = *(_OWORD *)v4;
    unint64_t v37 = v4 + 2;
    while (v37 != (unint64_t *)v5)
    {
      unint64_t v38 = *v37;
      v37 += 2;
      if (v38 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        ++v36;
        unsigned int v4 = v37 - 2;
        goto LABEL_56;
      }
    }
    unint64_t v12 = v36 + 1;
  }
  unint64_t v13 = 126 - 2 * __clz(v12 - v11);
  if (v12 == v11) {
    uint64_t v14 = 0;
  }
  else {
    uint64_t v14 = v13;
  }
  sub_1CD493DB8(v11, v12, (uint64_t)&v42, v14, 1);
  memset(&v42, 0, sizeof(v42));
  if (v12 != v11)
  {
    long long v15 = v11;
    while (1)
    {
      long long v16 = *(const void **)v15;
      if (*(void *)v15) {
        break;
      }
      std::string::size_type v19 = 0;
      BOOL v20 = 0;
      char v21 = 0;
      std::string __p = 0;
      size_t v40 = 0;
      unint64_t v41 = 0;
LABEL_30:
      int v24 = v21;
      if (v21 >= 0) {
        p_p = &__p;
      }
      else {
        p_p = v20;
      }
      std::string::size_type v26 = v21 & 0x7F;
      if (v24 >= 0) {
        std::string::size_type v27 = v26;
      }
      else {
        std::string::size_type v27 = v19;
      }
      std::string::append(&v42, (const std::string::value_type *)p_p, v27);
      if (SHIBYTE(v41) < 0) {
        operator delete(__p);
      }
      std::string::append(&v42, 1uLL, 0);
      if (++v15 == v12)
      {
        char v28 = HIBYTE(v42.__r_.__value_.__r.__words[2]);
        std::string::size_type size = v42.__r_.__value_.__l.__size_;
        std::string::size_type v30 = v42.__r_.__value_.__r.__words[0];
        goto LABEL_41;
      }
    }
    size_t v17 = *((void *)v15 + 1);
    if (v17 >= 0x7FFFFFFFFFFFFFF8) {
      goto LABEL_61;
    }
    if (v17 >= 0x17)
    {
      uint64_t v22 = (v17 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v17 | 7) != 0x17) {
        uint64_t v22 = v17 | 7;
      }
      uint64_t v23 = v22 + 1;
      long long v18 = operator new(v22 + 1);
      size_t v40 = v17;
      unint64_t v41 = v23 | 0x8000000000000000;
      std::string __p = v18;
    }
    else
    {
      HIBYTE(v4sub_1CD7485C0(this + 1) = *((void *)v15 + 1);
      long long v18 = &__p;
      if (!v17) {
        goto LABEL_29;
      }
    }
    memmove(v18, v16, v17);
LABEL_29:
    *((unsigned char *)v18 + v17) = 0;
    char v21 = HIBYTE(v41);
    BOOL v20 = (void **)__p;
    std::string::size_type v19 = v40;
    goto LABEL_30;
  }
  std::string::size_type size = 0;
  std::string::size_type v30 = 0;
  char v28 = 0;
LABEL_41:
  int v31 = v28;
  if (v28 >= 0) {
    unint64_t v32 = &v42;
  }
  else {
    unint64_t v32 = (std::string *)v30;
  }
  size_t v33 = v28 & 0x7F;
  if (v31 >= 0) {
    size_t v34 = v33;
  }
  else {
    size_t v34 = size;
  }
  llvm::raw_ostream::write(a2, (const char *)v32, v34);
  if (!atomic_load_explicit(qword_1EBCF0258, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EBCF0258, (void *(*)(void))sub_1CCCF2FAC, (void (*)(void *))sub_1CCCF2FF4);
  }
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v42.__r_.__value_.__l.__data_);
  }
  if (v11) {
    operator delete(v11);
  }
  return 0;
}

void llvm::sampleprof::ProfileSymbolList::dump(llvm::sampleprof::ProfileSymbolList *this, llvm::raw_ostream *a2)
{
  unsigned int v4 = (void *)*((void *)a2 + 4);
  if (*((void *)a2 + 3) - (void)v4 > 0x2AuLL)
  {
    qmemcpy(v4, "======== Dump profile symbol list ========\n", 43);
    *((void *)a2 + 4) += 43;
  }
  else
  {
    llvm::raw_ostream::write(a2, "======== Dump profile symbol list ========\n", 0x2BuLL);
  }
  if (!*((_DWORD *)this + 4)) {
    goto LABEL_15;
  }
  uint64_t v5 = *((unsigned int *)this + 6);
  if (v5)
  {
    uint64_t v12 = 16 * v5;
    unint64_t v6 = (unint64_t *)*((void *)this + 1);
    while (*v6 >= 0xFFFFFFFFFFFFFFFELL)
    {
      v6 += 2;
      v12 -= 16;
      if (!v12) {
        goto LABEL_15;
      }
    }
  }
  else
  {
    unint64_t v6 = (unint64_t *)*((void *)this + 1);
  }
  uint64_t v7 = *((void *)this + 1) + 16 * v5;
  if ((unint64_t *)v7 == v6)
  {
LABEL_15:
    unint64_t v13 = 0;
    uint64_t v14 = 0;
  }
  else
  {
    unint64_t v8 = 0;
    unint64_t v9 = v6;
LABEL_8:
    uint64_t v10 = v9 + 2;
    while (v10 != (unint64_t *)v7)
    {
      unint64_t v11 = *v10;
      v10 += 2;
      if (v11 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        unint64_t v9 = v10 - 2;
        ++v8;
        goto LABEL_8;
      }
    }
    if (v8 >= 0xFFFFFFFFFFFFFFFLL) {
      abort();
    }
    unint64_t v13 = (long long *)operator new(16 * (v8 + 1));
    char v21 = v13;
LABEL_35:
    long long *v21 = *(_OWORD *)v6;
    uint64_t v22 = v6 + 2;
    while (v22 != (unint64_t *)v7)
    {
      unint64_t v23 = *v22;
      v22 += 2;
      if (v23 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        ++v21;
        unint64_t v6 = v22 - 2;
        goto LABEL_35;
      }
    }
    uint64_t v14 = v21 + 1;
  }
  unint64_t v15 = 126 - 2 * __clz(v14 - v13);
  if (v14 == v13) {
    uint64_t v16 = 0;
  }
  else {
    uint64_t v16 = v15;
  }
  sub_1CD493DB8(v13, v14, (uint64_t)&v24, v16, 1);
  if (v14 != v13)
  {
    size_t v17 = v13;
    do
    {
      long long v18 = *(const void **)v17;
      unint64_t v19 = *((void *)v17 + 1);
      BOOL v20 = (unsigned char *)*((void *)a2 + 4);
      if (v19 <= *((void *)a2 + 3) - (void)v20)
      {
        if (v19)
        {
          memcpy(v20, v18, *((void *)v17 + 1));
          BOOL v20 = (unsigned char *)(*((void *)a2 + 4) + v19);
          *((void *)a2 + 4) = v20;
        }
      }
      else
      {
        llvm::raw_ostream::write(a2, (const char *)v18, *((void *)v17 + 1));
        BOOL v20 = (unsigned char *)*((void *)a2 + 4);
      }
      if (*((unsigned char **)a2 + 3) == v20)
      {
        llvm::raw_ostream::write(a2, "\n", 1uLL);
      }
      else
      {
        *BOOL v20 = 10;
        ++*((void *)a2 + 4);
      }
      ++v17;
    }
    while (v17 != v14);
  }
  if (v13) {
    operator delete(v13);
  }
}

uint64_t **llvm::sampleprof::CSProfileConverter::FrameNode::getOrCreateChildFrame(uint64_t **a1, unsigned int *a2, std::string::value_type *__s, std::string::size_type __sz)
{
  unint64_t v8 = (uint64_t *)llvm::sampleprof::FunctionSamples::getCallSiteHash(__s, __sz, a2);
  uint64_t v25 = v8;
  unint64_t v9 = a1[1];
  if (!v9) {
    goto LABEL_12;
  }
  uint64_t v10 = a1 + 1;
  do
  {
    unint64_t v11 = v9[4];
    BOOL v12 = v11 >= (unint64_t)v8;
    if (v11 >= (unint64_t)v8) {
      unint64_t v13 = (uint64_t **)v9;
    }
    else {
      unint64_t v13 = (uint64_t **)(v9 + 1);
    }
    if (v12) {
      uint64_t v10 = (uint64_t **)v9;
    }
    unint64_t v9 = *v13;
  }
  while (*v13);
  if (v10 == a1 + 1 || v8 < v10[4])
  {
LABEL_12:
    uint64_t v14 = *(void *)a2;
    char v21 = 0;
    uint64_t v22 = 0;
    *(void *)&long long v23 = __s;
    *((void *)&v23 + sub_1CD7485C0(this + 1) = __sz;
    *(void *)&long long v24 = 0;
    *((void *)&v24 + sub_1CD7485C0(this + 1) = v14;
    unint64_t v15 = sub_1CCCF53DC(a1, (unint64_t)v8, &v25);
    uint64_t v16 = (uint64_t *)(v15 + 6);
    sub_1CCB5AD5C(v15[6]);
    size_t v17 = v21;
    v15[5] = (uint64_t *)&v21;
    v15[6] = v17;
    long long v18 = v22;
    v15[7] = v22;
    if (v18)
    {
      void v17[2] = (uint64_t)v16;
      char v21 = 0;
      uint64_t v22 = 0;
      size_t v17 = 0;
    }
    else
    {
      v15[5] = v16;
    }
    long long v19 = v24;
    *((_OWORD *)v15 + 4) = v23;
    *((_OWORD *)v15 + 5) = v19;
    sub_1CCB5AD5C(v17);
    uint64_t v10 = sub_1CCCF53DC(a1, (unint64_t)v8, &v25);
  }
  return v10 + 5;
}

uint64_t llvm::sampleprof::CSProfileConverter::CSProfileConverter(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a1 + 16;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  uint64_t v3 = *(void **)(a2 + 16);
  if (v3)
  {
    do
    {
      ContextPath = llvm::sampleprof::CSProfileConverter::getOrCreateContextPath(a1, (uint64_t)(v3 + 9));
      uint64_t v5 = (void *)*v3;
      ContextPath[5] = v3 + 7;
      uint64_t v3 = v5;
    }
    while (v5);
  }
  return a1;
}

{
  void *v3;
  uint64_t **ContextPath;
  void *v5;

  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a1 + 16;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  uint64_t v3 = *(void **)(a2 + 16);
  if (v3)
  {
    do
    {
      ContextPath = llvm::sampleprof::CSProfileConverter::getOrCreateContextPath(a1, (uint64_t)(v3 + 9));
      uint64_t v5 = (void *)*v3;
      ContextPath[5] = v3 + 7;
      uint64_t v3 = v5;
    }
    while (v5);
  }
  return a1;
}

uint64_t **llvm::sampleprof::CSProfileConverter::getOrCreateContextPath(uint64_t a1, uint64_t a2)
{
  uint64_t result = (uint64_t **)(a1 + 8);
  uint64_t v6 = 0;
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    uint64_t v4 = *(void *)(a2 + 16);
    uint64_t v5 = v4 + 24 * v3;
    do
    {
      uint64_t result = llvm::sampleprof::CSProfileConverter::FrameNode::getOrCreateChildFrame(result, (unsigned int *)&v6, *(std::string::value_type **)v4, *(void *)(v4 + 8));
      uint64_t v6 = *(void *)(v4 + 16);
      v4 += 24;
    }
    while (v4 != v5);
  }
  return result;
}

void llvm::sampleprof::CSProfileConverter::convertProfiles(uint64_t *a1, void *a2)
{
  unint64_t v2 = (unsigned int *)*a2;
  uint64_t v3 = (unsigned int *)(a2 + 1);
  if ((void *)*a2 != a2 + 1)
  {
    uint64_t v5 = a2[5];
    uint64_t v6 = v5 + 96;
    while (1)
    {
      llvm::sampleprof::CSProfileConverter::convertProfiles(a1, v2 + 10);
      uint64_t v7 = *((void *)v2 + 10);
      if (v7) {
        break;
      }
LABEL_4:
      unint64_t v8 = (unsigned int *)*((void *)v2 + 1);
      if (v8)
      {
        do
        {
          unint64_t v9 = v8;
          unint64_t v8 = *(unsigned int **)v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          unint64_t v9 = (unsigned int *)*((void *)v2 + 2);
          BOOL v10 = *(void *)v9 == (void)v2;
          unint64_t v2 = v9;
        }
        while (!v10);
      }
      unint64_t v2 = v9;
      if (v9 == v3) {
        return;
      }
    }
    long long v11 = *(_OWORD *)(v7 + 32);
    *(_OWORD *)__leuint64_t n = *(_OWORD *)(v7 + 16);
    long long v48 = v11;
    uint64_t v49 = *(void *)(v7 + 48);
    *(_OWORD *)(v7 + 16) = *(_OWORD *)__len;
    *(_DWORD *)(v7 + 48) = 0;
    *(void *)(v7 + 32) = 0;
    *(void *)(v7 + 40) = 0;
    if (!v5)
    {
      uint64_t v12 = *a1;
      *(void *)&long long __dst = v7 + 16;
      unint64_t v13 = sub_1CC9B3AE0(v12, v7 + 16, (uint64_t)&std::piecewise_construct, (long long **)&__dst);
      sub_1CD67DFD0((uint64_t)(v13 + 56), v7, 1uLL);
LABEL_44:
      if ((v49 & 0x200000000) != 0) {
        llvm::sampleprof::FunctionSamples::ProfileIsCSNested = 1;
      }
      unint64_t v41 = (void *)*a1;
      std::string v42 = sub_1CD681854((void *)*a1, (uint64_t)__len);
      if (v42) {
        sub_1CCCF4974(v41, v42);
      }
      goto LABEL_4;
    }
    uint64_t v44 = v6;
    *(void *)&long long __dst = v2 + 22;
    uint64_t v14 = sub_1CD67E818(v6, v2 + 22, (uint64_t)&std::piecewise_construct, (uint64_t **)&__dst);
    unint64_t v15 = (const void *)__len[0];
    if (!__len[0])
    {
      long long __dst = 0uLL;
      unint64_t v46 = 0;
      goto LABEL_24;
    }
    size_t v16 = __len[1];
    if (__len[1] > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_49;
    }
    if (__len[1] >= 0x17)
    {
      size_t v18 = (__len[1] & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((__len[1] | 7) != 0x17) {
        size_t v18 = __len[1] | 7;
      }
      uint64_t v43 = v5;
      size_t v19 = v18 + 1;
      p_dst = (long long *)operator new(v18 + 1);
      unint64_t v20 = v19 | 0x8000000000000000;
      uint64_t v5 = v43;
      *((void *)&__dst + sub_1CD7485C0(this + 1) = v16;
      unint64_t v46 = v20;
      *(void *)&long long __dst = p_dst;
    }
    else
    {
      HIBYTE(v46) = __len[1];
      p_dst = &__dst;
      if (!__len[1]) {
        goto LABEL_23;
      }
    }
    memmove(p_dst, v15, v16);
LABEL_23:
    *((unsigned char *)p_dst + v16) = 0;
LABEL_24:
    char v21 = (void **)(v14 + 5);
    uint64_t v22 = (char **)sub_1CD4AF8D4((uint64_t)(v14 + 5), &v50, (uint64_t)&__dst);
    if (!*v22)
    {
      long long v23 = v22;
      long long v24 = (char *)operator new(0xB0uLL);
      *((void *)v24 + 6) = v46;
      *((_OWORD *)v24 + 2) = __dst;
      unint64_t v46 = 0;
      long long __dst = 0uLL;
      uint64_t v25 = *(void *)(v7 + 64);
      long long v26 = *(_OWORD *)(v7 + 48);
      long long v27 = *(_OWORD *)(v7 + 16);
      *(_OWORD *)(v24 + 88) = *(_OWORD *)(v7 + 32);
      *(_OWORD *)(v24 + 72) = v27;
      *(_OWORD *)(v24 + 104) = v26;
      *((void *)v24 + 15) = v25;
      *(_OWORD *)(v24 + 56) = *(_OWORD *)v7;
      sub_1CCCF4A9C((uint64_t)(v24 + 128), (void *)(v7 + 72));
      sub_1CCCF4D4C((uint64_t)(v24 + 152), (void *)(v7 + 96));
      char v28 = v50;
      *(void *)long long v24 = 0;
      *((void *)v24 + sub_1CD7485C0(this + 1) = 0;
      *((void *)v24 + 2) = v28;
      *long long v23 = v24;
      long long v29 = (void *)**v21;
      if (v29)
      {
        uint64_t *v21 = v29;
        long long v24 = *v23;
      }
      sub_1CB8358B8((uint64_t *)v14[6], (uint64_t *)v24);
      ++v14[7];
    }
    if (SHIBYTE(v46) < 0) {
      operator delete((void *)__dst);
    }
    sub_1CC9A75E0(v5, *(void *)(v7 + 56), 1uLL);
    uint64_t v6 = v44;
    if (!byte_1EBD0B238) {
      goto LABEL_44;
    }
    uint64_t v30 = *a1;
    *(void *)&long long __dst = v7 + 16;
    int v31 = sub_1CC9B3AE0(v30, v7 + 16, (uint64_t)&std::piecewise_construct, (long long **)&__dst);
    sub_1CD67DFD0((uint64_t)(v31 + 56), v7, 1uLL);
    *(void *)&long long __dst = v2 + 22;
    unint64_t v32 = sub_1CD67E818(v44, v2 + 22, (uint64_t)&std::piecewise_construct, (uint64_t **)&__dst);
    size_t v33 = *(const void **)(v7 + 16);
    if (!v33)
    {
      long long __dst = 0uLL;
      unint64_t v46 = 0;
      goto LABEL_42;
    }
    size_t v34 = *(void *)(v7 + 24);
    if (v34 > 0x7FFFFFFFFFFFFFF7) {
LABEL_49:
    }
      abort();
    if (v34 >= 0x17)
    {
      uint64_t v36 = (v34 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v34 | 7) != 0x17) {
        uint64_t v36 = v34 | 7;
      }
      uint64_t v37 = v5;
      uint64_t v38 = v36 + 1;
      long long v35 = (long long *)operator new(v36 + 1);
      unint64_t v39 = v38 | 0x8000000000000000;
      uint64_t v5 = v37;
      uint64_t v6 = v44;
      *((void *)&__dst + sub_1CD7485C0(this + 1) = v34;
      unint64_t v46 = v39;
      *(void *)&long long __dst = v35;
    }
    else
    {
      HIBYTE(v46) = *(void *)(v7 + 24);
      long long v35 = &__dst;
      if (!v34) {
        goto LABEL_41;
      }
    }
    memmove(v35, v33, v34);
LABEL_41:
    *((unsigned char *)v35 + v34) = 0;
LABEL_42:
    unint64_t v50 = &__dst;
    size_t v40 = sub_1CD75307C((uint64_t)(v32 + 5), (uint64_t)&__dst, (uint64_t)&std::piecewise_construct, &v50);
    *((_DWORD *)v40 + 27) |= 4u;
    if (SHIBYTE(v46) < 0) {
      operator delete((void *)__dst);
    }
    goto LABEL_44;
  }
}

void llvm::sampleprof::CSProfileConverter::convertProfiles(llvm::sampleprof::CSProfileConverter *this)
{
}

void sub_1CCCF2FAC()
{
}

uint64_t sub_1CCCF2FF4(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1CCCF3024(std::error_category *a1)
{
  std::error_category::~error_category(a1);

  JUMPOUT(0x1D25D9CE0);
}

const char *sub_1CCCF305C()
{
  return "llvm.sampleprof";
}

__n128 sub_1CCCF3068@<Q0>(int a1@<W1>, uint64_t a2@<X8>, __n128 result@<Q0>)
{
  switch(a1)
  {
    case 1:
      uint64_t v4 = (char *)operator new(0x28uLL);
      *(void *)a2 = v4;
      *(_OWORD *)(a2 + 8) = xmmword_1CFB287C0;
      result.n128_u64[0] = *(void *)"Invalid sample profile data (bad magic)";
      strcpy(v4, "Invalid sample profile data (bad magic)");
      return result;
    case 2:
      uint64_t v5 = (char *)operator new(0x30uLL);
      *(void *)a2 = v5;
      *(_OWORD *)(a2 + 8) = xmmword_1CFB1B7C0;
      strcpy(v5, "Unsupported sample profile format version");
      result.n128_u64[0] = *(void *)"e format version";
      return result;
    case 3:
      uint64_t v6 = "Too much profile data";
      goto LABEL_12;
    case 4:
      uint64_t v7 = "Truncated profile data";
      goto LABEL_19;
    case 5:
      unint64_t v8 = (char *)operator new(0x20uLL);
      *(void *)a2 = v8;
      long long v9 = xmmword_1CD91A430;
      BOOL v10 = "Malformed sample profile data";
      goto LABEL_15;
    case 6:
      long long v11 = (char *)operator new(0x30uLL);
      *(void *)a2 = v11;
      *(_OWORD *)(a2 + 8) = xmmword_1CFB28FE0;
      strcpy(v11, "Unrecognized sample profile encoding format");
      result.n128_u64[0] = *(void *)" encoding format";
      return result;
    case 7:
      uint64_t v12 = (char *)operator new(0x40uLL);
      *(void *)a2 = v12;
      *(_OWORD *)(a2 + 8) = xmmword_1CFB2C5C0;
      strcpy(v12, "Profile encoding format unsupported for writing operations");
      result.n128_u64[0] = *(void *)"iting operations";
      return result;
    case 8:
      unint64_t v8 = (char *)operator new(0x20uLL);
      *(void *)a2 = v8;
      long long v9 = xmmword_1CD91A430;
      BOOL v10 = "Truncated function name table";
      goto LABEL_15;
    case 9:
      uint64_t v6 = "Unimplemented feature";
LABEL_12:
      *(unsigned char *)(a2 + 23) = 21;
      uint64_t result = *(__n128 *)v6;
      *(_OWORD *)a2 = *(_OWORD *)v6;
      *(void *)(a2 + 13) = *(void *)(v6 + 13);
      *(unsigned char *)(a2 + 2llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = 0;
      return result;
    case 10:
      *(unsigned char *)(a2 + 23) = 16;
      result.n128_u64[0] = *(void *)"Counter overflow";
      strcpy((char *)a2, "Counter overflow");
      return result;
    case 11:
      unint64_t v8 = (char *)operator new(0x20uLL);
      *(void *)a2 = v8;
      long long v9 = xmmword_1CD91A430;
      BOOL v10 = "Ostream does not support seek";
LABEL_15:
      *(_OWORD *)(a2 + 8) = v9;
      *(_OWORD *)unint64_t v8 = *(_OWORD *)v10;
      uint64_t result = *(__n128 *)(v10 + 13);
      *(__n128 *)(v8 + 13) = result;
      v8[29] = 0;
      break;
    case 12:
      *(unsigned char *)(a2 + 23) = 18;
      result.n128_u64[0] = *(void *)"Uncompress failure";
      strcpy((char *)a2, "Uncompress failure");
      break;
    case 13:
      *(unsigned char *)(a2 + 23) = 19;
      result.n128_u64[0] = *(void *)"Zlib is unavailable";
      strcpy((char *)a2, "Zlib is unavailable");
      break;
    case 14:
      uint64_t v7 = "Function hash mismatch";
LABEL_19:
      uint64_t result = *(__n128 *)v7;
      *(_OWORD *)a2 = *(_OWORD *)v7;
      *(void *)(a2 + 14) = *(void *)(v7 + 14);
      *(_WORD *)(a2 + 22) = 5632;
      break;
    default:
      *(unsigned char *)(a2 + 23) = 7;
      strcpy((char *)a2, "Success");
      break;
  }
  return result;
}

void sub_1CCCF3348(unsigned int **a1, unsigned int **a2, uint64_t a3)
{
  unint64_t v6 = a2 - a1;
  if ((char *)a2 - (char *)a1 < 1025)
  {
LABEL_5:
    sub_1CD752878(a1, a2, a3, v6, 0, 0);
  }
  else
  {
    uint64_t v7 = (const std::nothrow_t *)MEMORY[0x1E4FBA2D0];
    unint64_t v8 = a2 - a1;
    while (1)
    {
      long long v9 = (unsigned int **)operator new(8 * v8, v7);
      if (v9) {
        break;
      }
      BOOL v10 = v8 > 1;
      v8 >>= 1;
      if (!v10) {
        goto LABEL_5;
      }
    }
    long long v11 = v9;
    sub_1CD752878(a1, a2, a3, v6, v9, v8);
    operator delete(v11);
  }
}

unsigned int **sub_1CCCF3438(unsigned int **result, unsigned int **a2)
{
  if (result != a2)
  {
    unint64_t v2 = result + 1;
    if (result + 1 != a2)
    {
      uint64_t v3 = 0;
      uint64_t v4 = result;
      do
      {
        uint64_t v5 = v4;
        uint64_t v4 = v2;
        uint64_t v7 = *v5;
        unint64_t v6 = v5[1];
        unsigned int v8 = *v6;
        unsigned int v9 = **v5;
        if (*v6 < v9 || v8 == v9 && v6[1] < v7[1])
        {
          v5[1] = v7;
          BOOL v10 = result;
          if (v5 != result)
          {
            uint64_t v11 = v3;
            while (1)
            {
              uint64_t v12 = *(unsigned int **)((char *)result + v11 - 8);
              if (v8 >= *v12)
              {
                if (v8 != *v12)
                {
                  BOOL v10 = (unsigned int **)((char *)result + v11);
                  goto LABEL_17;
                }
                if (v6[1] >= v12[1]) {
                  break;
                }
              }
              --v5;
              *(unsigned int **)((char *)result + v1llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = v12;
              v11 -= 8;
              if (!v11)
              {
                BOOL v10 = result;
                goto LABEL_17;
              }
            }
            BOOL v10 = v5;
          }
LABEL_17:
          const char *v10 = v6;
        }
        unint64_t v2 = v4 + 1;
        v3 += 8;
      }
      while (v4 + 1 != a2);
    }
  }
  return result;
}

unsigned int **sub_1CCCF3500(unsigned int **result, unsigned int **a2, unsigned int **a3, unsigned int **a4, unsigned int **a5)
{
  while (1)
  {
    if (result == a2)
    {
      while (a3 != a4)
      {
        unsigned int v9 = *a3++;
        *a5++ = v9;
      }
      return result;
    }
    if (a3 == a4) {
      break;
    }
    uint64_t v5 = *a3;
    unint64_t v6 = *result;
    unsigned int v7 = **a3;
    unsigned int v8 = **result;
    if (v7 < v8 || v7 == v8 && v5[1] < v6[1])
    {
      *a5 = v5;
      ++a3;
    }
    else
    {
      *a5 = v6;
      ++result;
    }
    ++a5;
  }
  if (result != a2)
  {
    uint64_t v10 = 0;
    do
    {
      a5[v10] = result[v10];
      ++v10;
    }
    while (&result[v10] != a2);
  }
  return result;
}

unsigned int **sub_1CCCF3594(unsigned int **result, unsigned int **a2, unsigned int **a3, uint64_t a4, uint64_t a5, uint64_t a6, char *a7, uint64_t a8)
{
  if (!a6) {
    return result;
  }
  uint64_t v9 = a6;
  uint64_t v12 = result;
  while (a5 > a8 && v9 > a8)
  {
    if (!a5) {
      return result;
    }
    unint64_t v13 = *a2;
    unsigned int v14 = **a2;
    while (1)
    {
      unint64_t v15 = *v12;
      unsigned int v16 = **v12;
      if (v14 < v16 || v14 == v16 && v13[1] < v15[1]) {
        break;
      }
      ++v12;
      if (!--a5) {
        return result;
      }
    }
    if (a5 >= v9)
    {
      if (a5 == 1)
      {
        *uint64_t v12 = v13;
        *a2 = v15;
        return result;
      }
      if (a5 >= 0) {
        uint64_t v27 = a5;
      }
      else {
        uint64_t v27 = a5 + 1;
      }
      uint64_t v26 = v27 >> 1;
      size_t v19 = &v12[v27 >> 1];
      uint64_t v18 = 0;
      if (a3 == a2)
      {
        size_t v33 = a3;
LABEL_44:
        long long v35 = v19;
        goto LABEL_47;
      }
      unint64_t v28 = a3 - a2;
      unsigned int v29 = **v19;
      do
      {
        unint64_t v30 = v28 >> 1;
        unint64_t v31 = v18 + (v28 >> 1);
        unint64_t v32 = a2[v31];
        if (*v32 < v29 || *v32 == v29 && v32[1] < (*v19)[1])
        {
          uint64_t v18 = v31 + 1;
          unint64_t v30 = v28 + ~v30;
        }
        unint64_t v28 = v30;
      }
      while (v30);
    }
    else
    {
      if (v9 >= 0) {
        uint64_t v17 = v9;
      }
      else {
        uint64_t v17 = v9 + 1;
      }
      uint64_t v18 = v17 >> 1;
      size_t v19 = a2;
      if (v12 != a2)
      {
        unint64_t v20 = a2 - v12;
        char v21 = a2[v18];
        unsigned int v22 = *v21;
        size_t v19 = v12;
        do
        {
          unint64_t v23 = v20 >> 1;
          long long v24 = &v19[v20 >> 1];
          unsigned int v25 = **v24;
          if (v22 >= v25 && (v22 != v25 || v21[1] >= (*v24)[1]))
          {
            size_t v19 = v24 + 1;
            unint64_t v23 = v20 + ~v23;
          }
          unint64_t v20 = v23;
        }
        while (v23);
      }
      uint64_t v26 = v19 - v12;
    }
    size_t v33 = &a2[v18];
    v9 -= v18;
    if (v19 != a2)
    {
      if (v18)
      {
        if (v19 + 1 == a2)
        {
          uint64_t v36 = *v19;
          memmove(v19, a2, 8 * v18);
          long long v35 = &v19[v18];
          *long long v35 = v36;
        }
        else if (v18 == 1)
        {
          size_t v34 = *(v33 - 1);
          long long v35 = v19 + 1;
          if (v33 - 1 != v19) {
            memmove(v19 + 1, v19, (char *)(v33 - 1) - (char *)v19);
          }
          *size_t v19 = v34;
          uint64_t v18 = 1;
        }
        else
        {
          long long v35 = (unsigned int **)sub_1CC057214(v19, a2, &a2[v18]);
        }
        goto LABEL_47;
      }
      goto LABEL_44;
    }
    size_t v19 = a2;
    long long v35 = &a2[v18];
LABEL_47:
    a5 -= v26;
    if (v18 + v26 >= a5 + v9)
    {
      uint64_t result = (unsigned int **)sub_1CCCF3594(v35, v33, a3, a4, a5, v9, a7, a8);
      size_t v33 = v19;
      uint64_t v9 = v18;
      a5 = v26;
      a3 = v35;
    }
    else
    {
      uint64_t result = (unsigned int **)sub_1CCCF3594(v12, v19, v35, a4, v26, v18, a7, a8);
      uint64_t v12 = v35;
    }
    a2 = v33;
    if (!v9) {
      return result;
    }
  }

  return sub_1CCCF3980(v12, a2, a3, a4, a5, v9, a7);
}

unsigned int **sub_1CCCF38A0(unsigned int **result, unsigned int **a2, unsigned int **a3)
{
  if (result != a2)
  {
    uint64_t v3 = *result++;
    *a3 = v3;
    if (result != a2)
    {
      uint64_t v4 = 0;
      uint64_t v5 = a3;
      unint64_t v6 = a3;
      do
      {
        unsigned int v8 = *v6++;
        unsigned int v7 = v8;
        uint64_t v9 = *result;
        unsigned int v10 = **result;
        unsigned int v11 = *v8;
        if (v10 < *v8 || v10 == v11 && v9[1] < v7[1])
        {
          v5[1] = v7;
          uint64_t v12 = a3;
          if (v5 != a3)
          {
            uint64_t v13 = v4;
            while (1)
            {
              unsigned int v14 = *(unsigned int **)((char *)a3 + v13 - 8);
              unsigned int v15 = **result;
              if (v15 >= *v14)
              {
                if (v15 != *v14)
                {
                  uint64_t v12 = (unsigned int **)((char *)a3 + v13);
                  goto LABEL_17;
                }
                if ((*result)[1] >= v14[1]) {
                  break;
                }
              }
              --v5;
              *(unsigned int **)((char *)a3 + v13) = v14;
              v13 -= 8;
              if (!v13)
              {
                uint64_t v12 = a3;
                goto LABEL_17;
              }
            }
            uint64_t v12 = v5;
          }
LABEL_17:
          *uint64_t v12 = *result;
        }
        else
        {
          *unint64_t v6 = v9;
        }
        ++result;
        v4 += 8;
        uint64_t v5 = v6;
      }
      while (result != a2);
    }
  }
  return result;
}

unsigned int **sub_1CCCF3980(unsigned int **result, unsigned int **a2, unsigned int **a3, int a4, uint64_t a5, uint64_t a6, char *__src)
{
  if (a5 <= a6)
  {
    if (result != a2)
    {
      unint64_t v13 = 0;
      do
      {
        *(void *)&__src[v13] = result[v13 / 8];
        v13 += 8;
      }
      while (&result[v13 / 8] != a2);
      if (v13)
      {
        unsigned int v14 = __src;
        while (a2 != a3)
        {
          unsigned int v15 = *a2;
          unsigned int v16 = *(unsigned int **)v14;
          unsigned int v17 = **a2;
          unsigned int v18 = **(_DWORD **)v14;
          if (v17 < v18 || v17 == v18 && v15[1] < v16[1])
          {
            void *result = v15;
            ++a2;
          }
          else
          {
            void *result = v16;
            v14 += 8;
          }
          ++result;
          if (&__src[v13] == v14) {
            return result;
          }
        }
        return (unsigned int **)memmove(result, v14, __src - v14 + v13);
      }
    }
  }
  else if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      *(void *)&__src[v7 * 8] = a2[v7];
      ++v7;
    }
    while (&a2[v7] != a3);
    if (v7 * 8)
    {
      unsigned int v8 = &__src[v7 * 8];
      uint64_t v9 = a3 - 1;
      while (a2 != result)
      {
        unsigned int v10 = a2 - 1;
        unsigned int v11 = *(a2 - 1);
        uint64_t v12 = (unsigned int *)*((void *)v8 - 1);
        if (*v12 >= *v11 && (*v12 != *v11 || v12[1] >= v11[1]))
        {
          unsigned int v11 = (unsigned int *)*((void *)v8 - 1);
          unsigned int v10 = a2;
          v8 -= 8;
        }
        *v9-- = v11;
        a2 = v10;
        if (v8 == __src) {
          return result;
        }
      }
      if (v8 != __src)
      {
        uint64_t v19 = 0;
        do
        {
          v9[v19] = *(unsigned int **)&v8[v19 * 8 - 8];
          --v19;
        }
        while (&v8[v19 * 8] != __src);
      }
    }
  }
  return result;
}

void sub_1CCCF3AD8(unsigned int **a1, unsigned int **a2, uint64_t a3)
{
  unint64_t v6 = a2 - a1;
  if ((char *)a2 - (char *)a1 < 1025)
  {
LABEL_5:
    sub_1CD752CAC(a1, a2, a3, v6, 0, 0);
  }
  else
  {
    uint64_t v7 = (const std::nothrow_t *)MEMORY[0x1E4FBA2D0];
    unint64_t v8 = a2 - a1;
    while (1)
    {
      uint64_t v9 = (unsigned int **)operator new(8 * v8, v7);
      if (v9) {
        break;
      }
      BOOL v10 = v8 > 1;
      v8 >>= 1;
      if (!v10) {
        goto LABEL_5;
      }
    }
    unsigned int v11 = v9;
    sub_1CD752CAC(a1, a2, a3, v6, v9, v8);
    operator delete(v11);
  }
}

double sub_1CCCF3BC8(uint64_t a1, _OWORD *a2, unint64_t a3, char *a4, uint64_t a5)
{
  if (a3 < 2) {
    return *(double *)&v10;
  }
  uint64_t v6 = a1;
  if (a3 != 2)
  {
    if ((uint64_t)a3 > 0)
    {
      uint64_t v18 = (uint64_t)a4;
      unint64_t v19 = a3 >> 1;
      unint64_t v20 = (_OWORD *)(a1 + 48 * (a3 >> 1));
      unint64_t v21 = a3 >> 1;
      if ((uint64_t)a3 > a5)
      {
        sub_1CCCF3BC8(a1, v20, v21, a4, a5);
        sub_1CCCF3BC8(v6 + 48 * (a3 >> 1), a2, a3 - (a3 >> 1), v18, a5);
        *(void *)&long long v10 = sub_1CCCF42B8(v6, v6 + 48 * (a3 >> 1), (uint64_t)a2, a3 >> 1, a3 - (a3 >> 1), v18, a5).n128_u64[0];
        return *(double *)&v10;
      }
      sub_1CCCF3F74(a1, v20, v21, a4);
      unint64_t v39 = (char *)(v18 + 48 * v19);
      sub_1CCCF3F74(v6 + 48 * (a3 >> 1), a2, a3 - (a3 >> 1), v39);
      unint64_t v40 = v18 + 48 * a3;
      uint64_t v41 = (uint64_t)v39;
      while (1)
      {
        if (v41 == v40)
        {
          if ((char *)v18 != v39)
          {
            uint64_t v50 = 0;
            do
            {
              uint64_t v51 = v18 + v50;
              uint64_t v52 = v6 + v50;
              long long v10 = *(_OWORD *)(v18 + v50);
              long long v53 = *(_OWORD *)(v18 + v50 + 16);
              *(void *)(v52 + 32) = *(void *)(v18 + v50 + 32);
              *(_OWORD *)uint64_t v52 = v10;
              *(_OWORD *)(v52 + 16) = v53;
              *(void *)(v52 + 40) = *(void *)(v18 + v50 + 40);
              v50 += 48;
            }
            while ((char *)(v51 + 48) != v39);
          }
          return *(double *)&v10;
        }
        unint64_t v42 = *(void *)(*(void *)(v41 + 40) + 56);
        unint64_t v43 = *(void *)(*(void *)(v18 + 40) + 56);
        if (v42 == v43)
        {
          if (!sub_1CD67ED6C(v41, v18))
          {
LABEL_38:
            long long v10 = *(_OWORD *)v18;
            long long v45 = *(_OWORD *)(v18 + 16);
            *(void *)(v6 + 32) = *(void *)(v18 + 32);
            *(_OWORD *)uint64_t v6 = v10;
            *(_OWORD *)(v6 + 16) = v45;
            *(void *)(v6 + 40) = *(void *)(v18 + 40);
            v18 += 48;
            goto LABEL_39;
          }
        }
        else if (v42 <= v43)
        {
          goto LABEL_38;
        }
        long long v10 = *(_OWORD *)v41;
        long long v44 = *(_OWORD *)(v41 + 16);
        *(void *)(v6 + 32) = *(void *)(v41 + 32);
        *(_OWORD *)uint64_t v6 = v10;
        *(_OWORD *)(v6 + 16) = v44;
        *(void *)(v6 + 40) = *(void *)(v41 + 40);
        v41 += 48;
LABEL_39:
        v6 += 48;
        if ((char *)v18 == v39)
        {
          if (v41 != v40)
          {
            uint64_t v46 = 0;
            do
            {
              uint64_t v47 = v41 + v46;
              uint64_t v48 = v6 + v46;
              long long v10 = *(_OWORD *)(v41 + v46);
              long long v49 = *(_OWORD *)(v41 + v46 + 16);
              *(void *)(v48 + 32) = *(void *)(v41 + v46 + 32);
              *(_OWORD *)uint64_t v48 = v10;
              *(_OWORD *)(v48 + 16) = v49;
              *(void *)(v48 + 40) = *(void *)(v41 + v46 + 40);
              v46 += 48;
            }
            while (v47 + 48 != v40);
          }
          return *(double *)&v10;
        }
      }
    }
    if ((_OWORD *)a1 == a2) {
      return *(double *)&v10;
    }
    uint64_t v22 = a1 + 48;
    if ((_OWORD *)(a1 + 48) == a2) {
      return *(double *)&v10;
    }
    uint64_t v23 = 0;
    uint64_t v24 = a1;
LABEL_15:
    uint64_t v25 = v24;
    uint64_t v24 = v22;
    unint64_t v26 = *(void *)(*(void *)(v25 + 88) + 56);
    unint64_t v27 = *(void *)(*(void *)(v25 + 40) + 56);
    if (v26 == v27)
    {
      if (!sub_1CD67ED6C(v24, v25)) {
        goto LABEL_27;
      }
    }
    else if (v26 <= v27)
    {
      goto LABEL_27;
    }
    long long v28 = *(_OWORD *)v24;
    long long v29 = *(_OWORD *)(v24 + 32);
    long long v56 = *(_OWORD *)(v24 + 16);
    long long v57 = v29;
    long long v55 = v28;
    long long v30 = *(_OWORD *)v25;
    long long v31 = *(_OWORD *)(v25 + 16);
    *(void *)(v24 + 32) = *(void *)(v25 + 32);
    *(_OWORD *)uint64_t v24 = v30;
    *(_OWORD *)(v24 + 16) = v31;
    *(void *)(v24 + 40) = *(void *)(v25 + 40);
    if (v25 == v6)
    {
LABEL_25:
      uint64_t v25 = v6;
      goto LABEL_26;
    }
    uint64_t v32 = v23;
    while (1)
    {
      uint64_t v33 = v6 + v32;
      unint64_t v34 = *(void *)(*((void *)&v57 + 1) + 56);
      uint64_t v35 = *(void *)(v6 + v32 - 8);
      unint64_t v36 = *(void *)(v35 + 56);
      if (v34 == v36)
      {
        if (!sub_1CD67ED6C((uint64_t)&v55, v6 + v32 - 48))
        {
          uint64_t v25 = v6 + v32;
LABEL_26:
          long long v10 = v55;
          long long v38 = v56;
          *(void *)(v25 + 32) = v57;
          *(_OWORD *)uint64_t v25 = v10;
          *(_OWORD *)(v25 + 16) = v38;
          *(void *)(v25 + 40) = *((void *)&v57 + 1);
LABEL_27:
          uint64_t v22 = v24 + 48;
          v23 += 48;
          if ((_OWORD *)(v24 + 48) == a2) {
            return *(double *)&v10;
          }
          goto LABEL_15;
        }
        uint64_t v35 = *(void *)(v33 - 8);
      }
      else if (v34 <= v36)
      {
        goto LABEL_26;
      }
      v25 -= 48;
      long long v37 = *(_OWORD *)(v6 + v32 - 32);
      *(_OWORD *)uint64_t v33 = *(_OWORD *)(v6 + v32 - 48);
      *(_OWORD *)(v33 + 16) = v37;
      *(void *)(v33 + 32) = *(void *)(v6 + v32 - 16);
      *(void *)(v6 + v32 + 40) = v35;
      v32 -= 48;
      if (!v32) {
        goto LABEL_25;
      }
    }
  }
  uint64_t v7 = a2 - 3;
  unint64_t v8 = *(void *)(*((void *)a2 - 1) + 56);
  unint64_t v9 = *(void *)(*(void *)(a1 + 40) + 56);
  if (v8 == v9)
  {
    if (!sub_1CD67ED6C((uint64_t)(a2 - 3), a1)) {
      return *(double *)&v10;
    }
  }
  else if (v8 <= v9)
  {
    return *(double *)&v10;
  }
  long long v10 = *(_OWORD *)v6;
  long long v11 = *(_OWORD *)(v6 + 16);
  uint64_t v12 = *(void *)(v6 + 32);
  uint64_t v13 = *((void *)a2 - 2);
  long long v14 = *(a2 - 2);
  *(_OWORD *)uint64_t v6 = *v7;
  *(_OWORD *)(v6 + 16) = v14;
  *(void *)(v6 + 32) = v13;
  *((void *)a2 - 2) = v12;
  *uint64_t v7 = v10;
  *(a2 - 2) = v11;
  uint64_t v15 = *(void *)(v6 + 40);
  *(void *)(v6 + 40) = *((void *)a2 - 1);
  *((void *)a2 - llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = v15;
  return *(double *)&v10;
}

uint64_t sub_1CCCF3F74(uint64_t result, _OWORD *a2, unint64_t a3, char *a4)
{
  if (!a3) {
    return result;
  }
  uint64_t v4 = a4;
  uint64_t v7 = result;
  if (a3 == 2)
  {
    long long v10 = a2 - 3;
    unint64_t v11 = *(void *)(*((void *)a2 - 1) + 56);
    unint64_t v12 = *(void *)(*(void *)(result + 40) + 56);
    if (v11 == v12)
    {
      uint64_t result = sub_1CD67ED6C((uint64_t)(a2 - 3), result);
      if (result) {
        goto LABEL_7;
      }
    }
    else if (v11 > v12)
    {
LABEL_7:
      long long v13 = *v10;
      long long v14 = *(a2 - 1);
      *((_OWORD *)v4 + llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = *(a2 - 2);
      *((_OWORD *)v4 + 2) = v14;
      *(_OWORD *)uint64_t v4 = v13;
      long long v15 = *(_OWORD *)v7;
      long long v16 = *(_OWORD *)(v7 + 16);
      long long v17 = *(_OWORD *)(v7 + 32);
LABEL_47:
      *((_OWORD *)v4 + 4) = v16;
      *((_OWORD *)v4 + 5) = v17;
      *((_OWORD *)v4 + 3) = v15;
      return result;
    }
    long long v55 = *(_OWORD *)v7;
    long long v56 = *(_OWORD *)(v7 + 32);
    *((_OWORD *)v4 + llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = *(_OWORD *)(v7 + 16);
    *((_OWORD *)v4 + 2) = v56;
    *(_OWORD *)uint64_t v4 = v55;
    long long v15 = *v10;
    long long v16 = *(a2 - 2);
    long long v17 = *(a2 - 1);
    goto LABEL_47;
  }
  if (a3 == 1)
  {
    long long v8 = *(_OWORD *)result;
    long long v9 = *(_OWORD *)(result + 32);
    *((_OWORD *)a4 + llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = *(_OWORD *)(result + 16);
    *((_OWORD *)a4 + 2) = v9;
    *(_OWORD *)a4 = v8;
    return result;
  }
  if ((uint64_t)a3 > 8)
  {
    unint64_t v39 = result + 48 * (a3 >> 1);
    sub_1CCCF3BC8(result, v39, a3 >> 1, a4, a3 >> 1);
    uint64_t result = sub_1CCCF3BC8(v7 + 48 * (a3 >> 1), a2, a3 - (a3 >> 1), &v4[48 * (a3 >> 1)], a3 - (a3 >> 1));
    uint64_t v40 = v7 + 48 * (a3 >> 1);
    while (1)
    {
      if ((_OWORD *)v40 == a2)
      {
        if (v7 != v39)
        {
          uint64_t v51 = 0;
          do
          {
            uint64_t v52 = &v4[v51];
            long long v53 = *(_OWORD *)(v7 + v51);
            long long v54 = *(_OWORD *)(v7 + v51 + 32);
            *((_OWORD *)v52 + llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = *(_OWORD *)(v7 + v51 + 16);
            *((_OWORD *)v52 + 2) = v54;
            *(_OWORD *)uint64_t v52 = v53;
            v51 += 48;
          }
          while (v7 + v51 != v39);
        }
        return result;
      }
      unint64_t v41 = *(void *)(*(void *)(v40 + 40) + 56);
      unint64_t v42 = *(void *)(*(void *)(v7 + 40) + 56);
      if (v41 == v42)
      {
        uint64_t result = sub_1CD67ED6C(v40, v7);
        if ((result & 1) == 0)
        {
LABEL_35:
          long long v45 = *(_OWORD *)v7;
          long long v46 = *(_OWORD *)(v7 + 32);
          *((_OWORD *)v4 + llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = *(_OWORD *)(v7 + 16);
          *((_OWORD *)v4 + 2) = v46;
          *(_OWORD *)uint64_t v4 = v45;
          v7 += 48;
          goto LABEL_36;
        }
      }
      else if (v41 <= v42)
      {
        goto LABEL_35;
      }
      long long v43 = *(_OWORD *)v40;
      long long v44 = *(_OWORD *)(v40 + 32);
      *((_OWORD *)v4 + llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = *(_OWORD *)(v40 + 16);
      *((_OWORD *)v4 + 2) = v44;
      *(_OWORD *)uint64_t v4 = v43;
      v40 += 48;
LABEL_36:
      v4 += 48;
      if (v7 == v39)
      {
        if ((_OWORD *)v40 != a2)
        {
          uint64_t v47 = 0;
          do
          {
            uint64_t v48 = &v4[v47];
            long long v49 = *(_OWORD *)(v40 + v47);
            long long v50 = *(_OWORD *)(v40 + v47 + 32);
            *((_OWORD *)v48 + llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = *(_OWORD *)(v40 + v47 + 16);
            *((_OWORD *)v48 + 2) = v50;
            *(_OWORD *)uint64_t v48 = v49;
            v47 += 48;
          }
          while ((_OWORD *)(v40 + v47) != a2);
        }
        return result;
      }
    }
  }
  if ((_OWORD *)result == a2) {
    return result;
  }
  long long v18 = *(_OWORD *)result;
  long long v19 = *(_OWORD *)(result + 32);
  *((_OWORD *)a4 + llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = *(_OWORD *)(result + 16);
  *((_OWORD *)a4 + 2) = v19;
  *(_OWORD *)a4 = v18;
  unint64_t v20 = (_OWORD *)(result + 48);
  if ((_OWORD *)(result + 48) == a2) {
    return result;
  }
  uint64_t v21 = 0;
  uint64_t v22 = (uint64_t)a4;
  do
  {
    uint64_t v23 = v20;
    uint64_t v24 = (_OWORD *)(v22 + 48);
    unint64_t v25 = *(void *)(*(void *)(v7 + 88) + 56);
    unint64_t v26 = *(void *)(*(void *)(v22 + 40) + 56);
    if (v25 == v26)
    {
      uint64_t result = sub_1CD67ED6C((uint64_t)v23, v22);
      if ((result & 1) == 0)
      {
LABEL_25:
        long long v37 = *v23;
        long long v38 = v23[2];
        *(_OWORD *)(v22 + 64) = v23[1];
        *(_OWORD *)(v22 + 80) = v38;
        *uint64_t v24 = v37;
        goto LABEL_26;
      }
    }
    else if (v25 <= v26)
    {
      goto LABEL_25;
    }
    long long v27 = *(_OWORD *)(v22 + 16);
    *uint64_t v24 = *(_OWORD *)v22;
    *(_OWORD *)(v22 + 64) = v27;
    *(_OWORD *)(v22 + 80) = *(_OWORD *)(v22 + 32);
    long long v28 = v4;
    if ((char *)v22 == v4) {
      goto LABEL_23;
    }
    uint64_t v29 = v21;
    while (1)
    {
      long long v30 = &v4[v29];
      unint64_t v31 = *(void *)(*(void *)(v7 + 88) + 56);
      uint64_t v32 = *(void *)&v4[v29 - 8];
      unint64_t v33 = *(void *)(v32 + 56);
      if (v31 != v33)
      {
        if (v31 <= v33)
        {
          long long v28 = (char *)v22;
          goto LABEL_23;
        }
        goto LABEL_19;
      }
      uint64_t result = sub_1CD67ED6C((uint64_t)v23, (uint64_t)&v4[v29 - 48]);
      if (!result) {
        break;
      }
      uint64_t v32 = *((void *)v30 - 1);
LABEL_19:
      v22 -= 48;
      long long v34 = *(_OWORD *)&v4[v29 - 32];
      *(_OWORD *)long long v30 = *(_OWORD *)&v4[v29 - 48];
      *((_OWORD *)v30 + llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = v34;
      *((void *)v30 + 4) = *(void *)&v4[v29 - 16];
      *(void *)&v4[v29 + 40] = v32;
      v29 -= 48;
      if (!v29)
      {
        long long v28 = v4;
        goto LABEL_23;
      }
    }
    long long v28 = &v4[v29];
LABEL_23:
    long long v35 = *v23;
    long long v36 = v23[1];
    *((void *)v28 + 4) = *((void *)v23 + 4);
    *(_OWORD *)long long v28 = v35;
    *((_OWORD *)v28 + llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = v36;
    *((void *)v28 + 5) = *(void *)(v7 + 88);
LABEL_26:
    unint64_t v20 = v23 + 3;
    v21 += 48;
    uint64_t v22 = (uint64_t)v24;
    uint64_t v7 = (uint64_t)v23;
  }
  while (v23 + 3 != a2);
  return result;
}

__n128 sub_1CCCF42B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (!a5) {
    return result;
  }
  uint64_t v9 = a5;
  do
  {
    if (a4 <= a7 || v9 <= a7)
    {
      if (a4 > v9)
      {
        if (a2 == a3) {
          return result;
        }
        uint64_t v53 = 0;
        do
        {
          uint64_t v54 = a6 + v53;
          __n128 result = *(__n128 *)(a2 + v53);
          long long v55 = *(_OWORD *)(a2 + v53 + 32);
          *(_OWORD *)(v54 + 16) = *(_OWORD *)(a2 + v53 + 16);
          *(_OWORD *)(v54 + 32) = v55;
          *(__n128 *)uint64_t v54 = result;
          v53 += 48;
        }
        while (a2 + v53 != a3);
        if (!v53) {
          return result;
        }
        uint64_t v56 = a6 + v53;
        while (1)
        {
          if (a2 == a1)
          {
            if (v56 != a6)
            {
              uint64_t v77 = 0;
              do
              {
                uint64_t v78 = a3 + v77;
                __n128 result = *(__n128 *)(v56 + v77 - 48);
                long long v79 = *(_OWORD *)(v56 + v77 - 32);
                *(void *)(v78 - 16) = *(void *)(v56 + v77 - 16);
                *(__n128 *)(v78 - 48) = result;
                *(_OWORD *)(v78 - 32) = v79;
                *(void *)(v78 - 8) = *(void *)(v56 + v77 - 8);
                v77 -= 48;
              }
              while (v56 + v77 != a6);
            }
            return result;
          }
          long long v57 = (void *)(a2 - 8);
          uint64_t v58 = a2 - 48;
          unint64_t v59 = *(void *)(*(void *)(v56 - 8) + 56);
          unint64_t v60 = *(void *)(*(void *)(a2 - 8) + 56);
          if (v59 == v60) {
            break;
          }
          uint64_t v61 = a2 - 48;
          if (v59 <= v60) {
            goto LABEL_74;
          }
LABEL_75:
          __n128 result = *(__n128 *)v58;
          long long v62 = *(_OWORD *)(v58 + 16);
          *(void *)(a3 - 16) = *(void *)(v58 + 32);
          *(__n128 *)(a3 - 48) = result;
          *(_OWORD *)(a3 - 32) = v62;
          *(void *)(a3 - 8) = *v57;
          a3 -= 48;
          a2 = v61;
          if (v56 == a6) {
            return result;
          }
        }
        BOOL v63 = sub_1CD67ED6C(v56 - 48, a2 - 48);
        uint64_t v61 = a2 - 48;
        if (v63) {
          goto LABEL_75;
        }
LABEL_74:
        uint64_t v58 = v56 - 48;
        long long v57 = (void *)(v56 - 8);
        uint64_t v61 = a2;
        v56 -= 48;
        goto LABEL_75;
      }
      if (a1 == a2) {
        return result;
      }
      uint64_t v64 = 0;
      do
      {
        uint64_t v65 = a6 + v64;
        __n128 result = *(__n128 *)(a1 + v64);
        long long v66 = *(_OWORD *)(a1 + v64 + 32);
        *(_OWORD *)(v65 + 16) = *(_OWORD *)(a1 + v64 + 16);
        *(_OWORD *)(v65 + 32) = v66;
        *(__n128 *)uint64_t v65 = result;
        v64 += 48;
      }
      while (a1 + v64 != a2);
      if (!v64) {
        return result;
      }
      uint64_t v67 = a6 + v64;
      uint64_t v68 = a6 + v64 - 48;
      while (1)
      {
        if (a2 == a3)
        {
          if (v67 != a6)
          {
            uint64_t v80 = 0;
            do
            {
              uint64_t v81 = a1 + v80;
              uint64_t v82 = a6 + v80;
              __n128 result = *(__n128 *)(a6 + v80);
              long long v83 = *(_OWORD *)(a6 + v80 + 16);
              *(void *)(v81 + 32) = *(void *)(a6 + v80 + 32);
              *(__n128 *)uint64_t v81 = result;
              *(_OWORD *)(v81 + 16) = v83;
              *(void *)(v81 + 40) = *(void *)(a6 + v80 + 40);
              v80 += 48;
            }
            while (v68 != v82);
          }
          return result;
        }
        unint64_t v69 = *(void *)(*(void *)(a2 + 40) + 56);
        unint64_t v70 = *(void *)(*(void *)(a6 + 40) + 56);
        if (v69 == v70)
        {
          if (!sub_1CD67ED6C(a2, a6))
          {
LABEL_89:
            __n128 result = *(__n128 *)a6;
            long long v72 = *(_OWORD *)(a6 + 16);
            *(void *)(a1 + 32) = *(void *)(a6 + 32);
            *(__n128 *)a1 = result;
            *(_OWORD *)(a1 + 16) = v72;
            *(void *)(a1 + 40) = *(void *)(a6 + 40);
            a6 += 48;
            goto LABEL_90;
          }
        }
        else if (v69 <= v70)
        {
          goto LABEL_89;
        }
        __n128 result = *(__n128 *)a2;
        long long v71 = *(_OWORD *)(a2 + 16);
        *(void *)(a1 + 32) = *(void *)(a2 + 32);
        *(__n128 *)a1 = result;
        *(_OWORD *)(a1 + 16) = v71;
        *(void *)(a1 + 40) = *(void *)(a2 + 40);
        a2 += 48;
LABEL_90:
        a1 += 48;
        if (v67 == a6) {
          return result;
        }
      }
    }
    if (!a4) {
      return result;
    }
    uint64_t v14 = 0;
    uint64_t v15 = -a4;
    while (1)
    {
      unint64_t v16 = *(void *)(*(void *)(a2 + 40) + 56);
      unint64_t v17 = *(void *)(*(void *)(a1 + v14 + 40) + 56);
      if (v16 == v17) {
        break;
      }
      if (v16 > v17) {
        goto LABEL_13;
      }
LABEL_9:
      v14 += 48;
      if (__CFADD__(v15++, 1)) {
        return result;
      }
    }
    if (!sub_1CD67ED6C(a2, a1 + v14)) {
      goto LABEL_9;
    }
LABEL_13:
    uint64_t v20 = -v15;
    uint64_t v87 = a6;
    uint64_t v88 = v9;
    uint64_t v89 = a3;
    if (-v15 < v9)
    {
      if (v9 >= 0) {
        uint64_t v21 = v9;
      }
      else {
        uint64_t v21 = v9 + 1;
      }
      uint64_t v22 = v21 >> 1;
      a3 = a2 + 48 * (v21 >> 1);
      if (a1 + v14 == a2)
      {
        uint64_t v37 = a2;
        uint64_t v23 = a2;
      }
      else
      {
        uint64_t v23 = a1 + v14;
        uint64_t v86 = a7;
        unint64_t v24 = 0xAAAAAAAAAAAAAAABLL * ((a2 - a1 - v14) >> 4);
        uint64_t v25 = a2 + 48 * v22 + 40;
        uint64_t v84 = v21 >> 1;
        do
        {
          unint64_t v26 = v23 + 48 * (v24 >> 1);
          unint64_t v27 = *(void *)(*(void *)v25 + 56);
          unint64_t v28 = *(void *)(*(void *)(v26 + 40) + 56);
          if (v27 == v28)
          {
            BOOL v29 = sub_1CD67ED6C(a3, v23 + 48 * (v24 >> 1));
            uint64_t v22 = v84;
          }
          else
          {
            BOOL v29 = v27 > v28;
          }
          if (v29)
          {
            v24 >>= 1;
          }
          else
          {
            uint64_t v23 = v26 + 48;
            v24 += ~(v24 >> 1);
          }
        }
        while (v24);
        uint64_t v37 = v23;
        a7 = v86;
      }
      uint64_t v30 = 0xAAAAAAAAAAAAAAABLL * ((v37 - a1 - v14) >> 4);
      goto LABEL_45;
    }
    if (v15 == -1)
    {
      uint64_t v73 = a1 + v14;
      uint64_t v96 = *(void *)(a1 + v14 + 32);
      __n128 v91 = *(__n128 *)(a1 + v14);
      long long v94 = *(_OWORD *)(a1 + v14 + 16);
      __n128 v74 = *(__n128 *)a2;
      long long v75 = *(_OWORD *)(a2 + 16);
      *(void *)(v73 + 32) = *(void *)(a2 + 32);
      *(__n128 *)uint64_t v73 = v74;
      *(_OWORD *)(v73 + 16) = v75;
      __n128 result = v91;
      *(void *)(a2 + 32) = v96;
      *(__n128 *)a2 = v91;
      *(_OWORD *)(a2 + 16) = v94;
      uint64_t v76 = *(void *)(a1 + v14 + 40);
      *(void *)(v73 + 40) = *(void *)(a2 + 40);
      *(void *)(a2 + 40) = v76;
      return result;
    }
    if (v15 > 0) {
      uint64_t v20 = 1 - v15;
    }
    uint64_t v30 = v20 >> 1;
    uint64_t v23 = a1 + 48 * (v20 >> 1) + v14;
    if (a3 != a2)
    {
      unint64_t v31 = 0xAAAAAAAAAAAAAAABLL * ((a3 - a2) >> 4);
      uint64_t v32 = a1 + 48 * v30 + v14;
      a3 = a2;
      uint64_t v85 = v20 >> 1;
      do
      {
        unint64_t v33 = a3 + 48 * (v31 >> 1);
        unint64_t v34 = *(void *)(*(void *)(v33 + 40) + 56);
        unint64_t v35 = *(void *)(*(void *)(v32 + 40) + 56);
        if (v34 == v35)
        {
          BOOL v36 = sub_1CD67ED6C(a3 + 48 * (v31 >> 1), v23);
          uint64_t v30 = v85;
        }
        else
        {
          BOOL v36 = v34 > v35;
        }
        if (v36) {
          v31 += ~(v31 >> 1);
        }
        else {
          v31 >>= 1;
        }
        if (v36) {
          a3 = v33 + 48;
        }
      }
      while (v31);
    }
    uint64_t v22 = 0xAAAAAAAAAAAAAAABLL * ((a3 - a2) >> 4);
    uint64_t v37 = a1 + 48 * v30 + v14;
LABEL_45:
    uint64_t v38 = a3;
    if (v23 != a2)
    {
      uint64_t v38 = v37;
      if (a2 != a3)
      {
        uint64_t v38 = v37 + 48;
        uint64_t v39 = v37 + 48;
        uint64_t v40 = a2;
        while (1)
        {
          long long v41 = *(_OWORD *)(v39 - 48);
          long long v92 = *(_OWORD *)(v39 - 32);
          uint64_t v42 = *(void *)(v39 - 16);
          long long v44 = *(_OWORD *)v40;
          long long v43 = *(_OWORD *)(v40 + 16);
          *(void *)(v39 - 16) = *(void *)(v40 + 32);
          *(_OWORD *)(v39 - 48) = v44;
          *(_OWORD *)(v39 - 32) = v43;
          *(void *)(v40 + 32) = v42;
          *(_OWORD *)uint64_t v40 = v41;
          *(_OWORD *)(v40 + 16) = v92;
          uint64_t v45 = *(void *)(v39 - 8);
          *(void *)(v39 - 8) = *(void *)(v40 + 40);
          *(void *)(v40 + 40) = v45;
          v40 += 48;
          if (v40 == a3) {
            break;
          }
          if (v39 == a2) {
            a2 = v40;
          }
          v39 += 48;
          v38 += 48;
        }
        if (v39 != a2)
        {
          uint64_t v46 = a2;
          do
          {
            while (1)
            {
              uint64_t v95 = *(void *)(v39 + 32);
              long long v90 = *(_OWORD *)v39;
              long long v93 = *(_OWORD *)(v39 + 16);
              long long v47 = *(_OWORD *)v46;
              long long v48 = *(_OWORD *)(v46 + 16);
              *(void *)(v39 + 32) = *(void *)(v46 + 32);
              *(_OWORD *)uint64_t v39 = v47;
              *(_OWORD *)(v39 + 16) = v48;
              *(void *)(v46 + 32) = v95;
              *(_OWORD *)uint64_t v46 = v90;
              *(_OWORD *)(v46 + 16) = v93;
              uint64_t v49 = *(void *)(v39 + 40);
              *(void *)(v39 + 40) = *(void *)(v46 + 40);
              *(void *)(v46 + 40) = v49;
              v39 += 48;
              v46 += 48;
              if (v46 == a3) {
                break;
              }
              if (v39 == a2) {
                a2 = v46;
              }
            }
            uint64_t v46 = a2;
          }
          while (v39 != a2);
        }
      }
    }
    a4 = -(v30 + v15);
    uint64_t v50 = v88 - v22;
    if (v30 + v22 >= v88 - (v30 + v22) - v15)
    {
      uint64_t v51 = v30;
      uint64_t v52 = v22;
      sub_1CCCF42B8(v38, a3, v89, a4, v88 - v22, v87, a7);
      a3 = v23;
      a6 = v87;
      uint64_t v50 = v52;
      a4 = v51;
      uint64_t v89 = v38;
      a1 += v14;
    }
    else
    {
      a6 = v87;
      sub_1CCCF42B8(a1 + v14, v37, v38, v30, v22, v87, a7);
      a1 = v38;
    }
    uint64_t v9 = v50;
    a2 = a3;
    a3 = v89;
  }
  while (v50);
  return result;
}

void sub_1CCCF491C(char a1, void **__p)
{
  if (a1)
  {
    sub_1CD750994((uint64_t)(__p + 19), __p[20]);
    sub_1CD7509F4((uint64_t)(__p + 16), __p[17]);
  }

  operator delete(__p);
}

void sub_1CCCF4974(void *a1, void *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  uint64_t v3 = (void *)*a2;
  unint64_t v4 = a2[1];
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v2);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(void *)&v2) {
      v4 %= *(void *)&v2;
    }
  }
  else
  {
    v4 &= *(void *)&v2 - 1;
  }
  uint64_t v6 = *(void **)(*a1 + 8 * v4);
  do
  {
    uint64_t v7 = v6;
    uint64_t v6 = (void *)*v6;
  }
  while (v6 != a2);
  if (v7 != a1 + 2)
  {
    unint64_t v8 = v7[1];
    if (v5.u32[0] > 1uLL)
    {
      if (v8 >= *(void *)&v2) {
        v8 %= *(void *)&v2;
      }
    }
    else
    {
      v8 &= *(void *)&v2 - 1;
    }
    if (v8 == v4)
    {
LABEL_20:
      if (!v3) {
        goto LABEL_27;
      }
      goto LABEL_21;
    }
  }
  if (!v3) {
    goto LABEL_19;
  }
  unint64_t v9 = v3[1];
  if (v5.u32[0] > 1uLL)
  {
    if (v9 >= *(void *)&v2) {
      v9 %= *(void *)&v2;
    }
  }
  else
  {
    v9 &= *(void *)&v2 - 1;
  }
  if (v9 != v4)
  {
LABEL_19:
    *(void *)(*a1 + 8 * v4) = 0;
    uint64_t v3 = (void *)*a2;
    goto LABEL_20;
  }
LABEL_21:
  unint64_t v10 = v3[1];
  if (v5.u32[0] > 1uLL)
  {
    if (v10 >= *(void *)&v2) {
      v10 %= *(void *)&v2;
    }
  }
  else
  {
    v10 &= *(void *)&v2 - 1;
  }
  if (v10 != v4)
  {
    *(void *)(*a1 + 8 * v10) = v7;
    uint64_t v3 = (void *)*a2;
  }
LABEL_27:
  *uint64_t v7 = v3;
  *a2 = 0;
  --a1[3];
  sub_1CCCF491C(1, (void **)a2);
}

uint64_t sub_1CCCF4A9C(uint64_t a1, void *a2)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v3 = (uint64_t *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  unint64_t v4 = (unsigned int *)(a2 + 1);
  uint8x8_t v5 = (unsigned int *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      sub_1CCCF4B34((uint64_t **)a1, v3, v5 + 8, (uint64_t)(v5 + 8));
      uint64_t v6 = (unsigned int *)*((void *)v5 + 1);
      if (v6)
      {
        do
        {
          uint64_t v7 = v6;
          uint64_t v6 = *(unsigned int **)v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v7 = (unsigned int *)*((void *)v5 + 2);
          BOOL v8 = *(void *)v7 == (void)v5;
          uint8x8_t v5 = v7;
        }
        while (!v8);
      }
      uint8x8_t v5 = v7;
    }
    while (v7 != v4);
  }
  return a1;
}

_OWORD *sub_1CCCF4B34(uint64_t **a1, uint64_t *a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v6 = sub_1CCCF4BF0(a1, a2, &v14, &v13, a3);
  uint64_t v7 = (_OWORD *)*v6;
  if (!*v6)
  {
    unint64_t v9 = v6;
    uint64_t v7 = operator new(0x50uLL);
    uint64_t v7[2] = *(_OWORD *)a4;
    sub_1CD67FE2C((llvm::StringMapImpl *)(v7 + 3), (uint64_t *)(a4 + 16));
    unint64_t v10 = v14;
    *(void *)uint64_t v7 = 0;
    *((void *)v7 + llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = 0;
    *((void *)v7 + 2) = v10;
    uint64_t *v9 = (uint64_t)v7;
    unint64_t v11 = (uint64_t *)**a1;
    unint64_t v12 = (uint64_t *)v7;
    if (v11)
    {
      *a1 = v11;
      unint64_t v12 = (uint64_t *)*v9;
    }
    sub_1CB8358B8(a1[1], v12);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

uint64_t *sub_1CCCF4BF0(uint64_t **a1, uint64_t *a2, uint64_t **a3, uint64_t **a4, unsigned int *a5)
{
  if (a1 + 1 == (uint64_t **)a2) {
    goto LABEL_5;
  }
  unsigned int v5 = *a5;
  unsigned int v6 = *((_DWORD *)a2 + 8);
  if (*a5 < v6) {
    goto LABEL_5;
  }
  if (v5 != v6)
  {
    if (v6 >= v5)
    {
LABEL_25:
      *a3 = a2;
      *a4 = a2;
      return (uint64_t *)a4;
    }
LABEL_20:
    uint64_t v15 = a2[1];
    if (v15)
    {
      unint64_t v16 = (uint64_t *)a2[1];
      do
      {
        a4 = (uint64_t **)v16;
        unint64_t v16 = (uint64_t *)*v16;
      }
      while (v16);
    }
    else
    {
      unint64_t v17 = a2;
      do
      {
        a4 = (uint64_t **)v17[2];
        BOOL v13 = *a4 == v17;
        unint64_t v17 = (uint64_t *)a4;
      }
      while (!v13);
    }
    if (a4 == a1 + 1 || (unsigned int v18 = *((_DWORD *)a4 + 8), v5 < v18) || v5 == v18 && a5[1] < *((_DWORD *)a4 + 9))
    {
      if (v15)
      {
        *a3 = (uint64_t *)a4;
      }
      else
      {
        *a3 = a2;
        return a2 + 1;
      }
      return (uint64_t *)a4;
    }
    return sub_1CD67E7AC((uint64_t)a1, a3, a5);
  }
  unsigned int v7 = a5[1];
  unsigned int v8 = *((_DWORD *)a2 + 9);
  if (v7 >= v8)
  {
    if (v8 >= v7) {
      goto LABEL_25;
    }
    goto LABEL_20;
  }
LABEL_5:
  unint64_t v9 = (uint64_t *)*a2;
  if (*a1 == a2)
  {
    unint64_t v11 = a2;
LABEL_16:
    if (v9)
    {
      *a3 = v11;
      return v11 + 1;
    }
    else
    {
      *a3 = a2;
      return a2;
    }
  }
  if (v9)
  {
    unint64_t v10 = (uint64_t *)*a2;
    do
    {
      unint64_t v11 = v10;
      unint64_t v10 = (uint64_t *)v10[1];
    }
    while (v10);
  }
  else
  {
    unint64_t v12 = a2;
    do
    {
      unint64_t v11 = (uint64_t *)v12[2];
      BOOL v13 = *v11 == (void)v12;
      unint64_t v12 = v11;
    }
    while (v13);
  }
  unsigned int v14 = *((_DWORD *)v11 + 8);
  if (v14 < *a5 || v14 == *a5 && *((_DWORD *)v11 + 9) < a5[1]) {
    goto LABEL_16;
  }
  return sub_1CD67E7AC((uint64_t)a1, a3, a5);
}

uint64_t sub_1CCCF4D4C(uint64_t a1, void *a2)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v3 = (uint64_t *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  unint64_t v4 = (unsigned int *)(a2 + 1);
  unsigned int v5 = (unsigned int *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      sub_1CCCF4DE4((uint64_t **)a1, v3, v5 + 8, (void *)v5 + 4);
      unsigned int v6 = (unsigned int *)*((void *)v5 + 1);
      if (v6)
      {
        do
        {
          unsigned int v7 = v6;
          unsigned int v6 = *(unsigned int **)v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          unsigned int v7 = (unsigned int *)*((void *)v5 + 2);
          BOOL v8 = *(void *)v7 == (void)v5;
          unsigned int v5 = v7;
        }
        while (!v8);
      }
      unsigned int v5 = v7;
    }
    while (v7 != v4);
  }
  return a1;
}

uint64_t *sub_1CCCF4DE4(uint64_t **a1, uint64_t *a2, unsigned int *a3, void *a4)
{
  unsigned int v6 = sub_1CCCF4BF0(a1, a2, &v13, &v12, a3);
  __n128 result = (uint64_t *)*v6;
  if (!*v6)
  {
    sub_1CCCF4E90((uint64_t)a1, a4, (uint64_t)&v11);
    BOOL v8 = v13;
    unint64_t v9 = v11;
    *unint64_t v11 = 0;
    v9[1] = 0;
    void v9[2] = (uint64_t)v8;
    *unsigned int v6 = (uint64_t)v9;
    unint64_t v10 = (uint64_t *)**a1;
    if (v10)
    {
      *a1 = v10;
      unint64_t v9 = (uint64_t *)*v6;
    }
    sub_1CB8358B8(a1[1], v9);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    return v11;
  }
  return result;
}

void *sub_1CCCF4E90@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  __n128 result = operator new(0x40uLL);
  *(void *)a3 = result;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  uint64_t v7 = *a2;
  unint64_t v9 = (long long *)a2[1];
  BOOL v8 = (long long *)(a2 + 2);
  result[4] = v7;
  result[7] = 0;
  result[6] = 0;
  unint64_t v10 = result + 6;
  result[5] = result + 6;
  unint64_t v11 = (uint64_t **)(result + 5);
  if (v9 != v8)
  {
    do
    {
      __n128 result = sub_1CCCF4F50(v11, v10, (uint64_t)(v9 + 2), v9 + 2);
      unint64_t v12 = (long long *)*((void *)v9 + 1);
      if (v12)
      {
        do
        {
          BOOL v13 = v12;
          unint64_t v12 = *(long long **)v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          BOOL v13 = (long long *)*((void *)v9 + 2);
          BOOL v14 = *(void *)v13 == (void)v9;
          unint64_t v9 = v13;
        }
        while (!v14);
      }
      unint64_t v9 = v13;
    }
    while (v13 != v8);
  }
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

uint64_t *sub_1CCCF4F50(uint64_t **a1, uint64_t *a2, uint64_t a3, long long *a4)
{
  unsigned int v6 = sub_1CCCF5004(a1, a2, &v14, &v13, a3);
  uint64_t v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    BOOL v8 = v6;
    uint64_t v7 = (uint64_t *)operator new(0xB0uLL);
    sub_1CCCF52D8((uint64_t)(v7 + 4), a4);
    unint64_t v9 = v14;
    *uint64_t v7 = 0;
    v7[1] = 0;
    uint64_t v7[2] = (uint64_t)v9;
    uint64_t *v8 = (uint64_t)v7;
    unint64_t v10 = (uint64_t *)**a1;
    unint64_t v11 = v7;
    if (v10)
    {
      *a1 = v10;
      unint64_t v11 = (uint64_t *)*v8;
    }
    sub_1CB8358B8(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

uint64_t *sub_1CCCF5004(uint64_t **a1, uint64_t *a2, uint64_t **a3, uint64_t **a4, uint64_t a5)
{
  unsigned int v6 = a3;
  uint64_t v50 = a1 + 1;
  if (a1 + 1 == (uint64_t **)a2) {
    goto LABEL_23;
  }
  size_t v9 = *((unsigned __int8 *)a2 + 55);
  if ((v9 & 0x80u) == 0) {
    unint64_t v10 = a2 + 4;
  }
  else {
    unint64_t v10 = (const void *)a2[4];
  }
  size_t v11 = a2[5];
  if ((v9 & 0x80u) == 0) {
    size_t v13 = v9 & 0x7F;
  }
  else {
    size_t v13 = a2[5];
  }
  int v14 = *(char *)(a5 + 23);
  if (v14 >= 0) {
    size_t v15 = *(unsigned __int8 *)(a5 + 23);
  }
  else {
    size_t v15 = *(void *)(a5 + 8);
  }
  if (v14 >= 0) {
    unint64_t v16 = (const void *)a5;
  }
  else {
    unint64_t v16 = *(const void **)a5;
  }
  if (v13 >= v15) {
    size_t v17 = v15;
  }
  else {
    size_t v17 = v13;
  }
  int v18 = memcmp(v16, v10, v17);
  BOOL v19 = v15 >= v13;
  unsigned int v6 = a3;
  BOOL v20 = !v19;
  if (v18) {
    BOOL v20 = v18 < 0;
  }
  if (v20)
  {
LABEL_23:
    uint64_t v21 = (uint64_t *)*a2;
    if (*a1 == a2)
    {
      uint64_t v23 = a2;
LABEL_57:
      if (v21)
      {
        *unsigned int v6 = v23;
        return v23 + 1;
      }
      else
      {
        *unsigned int v6 = a2;
        return a2;
      }
    }
    if (v21)
    {
      uint64_t v22 = (uint64_t *)*a2;
      do
      {
        uint64_t v23 = v22;
        uint64_t v22 = (uint64_t *)v22[1];
      }
      while (v22);
    }
    else
    {
      BOOL v29 = a2;
      do
      {
        uint64_t v23 = (uint64_t *)v29[2];
        BOOL v30 = *v23 == (void)v29;
        BOOL v29 = v23;
      }
      while (v30);
    }
    char v31 = *(unsigned char *)(a5 + 23);
    BOOL v32 = v31 < 0;
    if (v31 >= 0) {
      unint64_t v33 = (const void *)a5;
    }
    else {
      unint64_t v33 = *(const void **)a5;
    }
    size_t v34 = v31 & 0x7F;
    if (v32) {
      size_t v35 = *(void *)(a5 + 8);
    }
    else {
      size_t v35 = v34;
    }
    if (*((char *)v23 + 55) < 0)
    {
      BOOL v36 = (const void *)v23[4];
      size_t v37 = v23[5];
    }
    else
    {
      BOOL v36 = v23 + 4;
      size_t v37 = *((unsigned __int8 *)v23 + 55);
    }
    if (v35 >= v37) {
      size_t v38 = v37;
    }
    else {
      size_t v38 = v35;
    }
    int v39 = memcmp(v36, v33, v38);
    BOOL v40 = v37 < v35;
    if (v39) {
      BOOL v40 = v39 < 0;
    }
    if (v40) {
      goto LABEL_57;
    }
    uint64_t v49 = (uint64_t)a1;
  }
  else
  {
    if ((v9 & 0x80u) == 0) {
      size_t v11 = v9;
    }
    if (v15 >= v11) {
      size_t v24 = v11;
    }
    else {
      size_t v24 = v15;
    }
    int v25 = memcmp(v10, v16, v24);
    BOOL v26 = v11 < v15;
    if (v25) {
      BOOL v26 = v25 < 0;
    }
    if (!v26)
    {
      *a3 = a2;
      *a4 = a2;
      return (uint64_t *)a4;
    }
    uint64_t v27 = a2[1];
    if (v27)
    {
      unint64_t v28 = (uint64_t *)a2[1];
      do
      {
        a4 = (uint64_t **)v28;
        unint64_t v28 = (uint64_t *)*v28;
      }
      while (v28);
    }
    else
    {
      long long v41 = a2;
      do
      {
        a4 = (uint64_t **)v41[2];
        BOOL v30 = *a4 == v41;
        long long v41 = (uint64_t *)a4;
      }
      while (!v30);
    }
    if (a4 == v50) {
      goto LABEL_77;
    }
    char v42 = *((unsigned char *)a4 + 55);
    if (v42 >= 0) {
      long long v43 = (uint64_t *)(a4 + 4);
    }
    else {
      long long v43 = a4[4];
    }
    if (v42 >= 0) {
      size_t v44 = v42 & 0x7F;
    }
    else {
      size_t v44 = (size_t)a4[5];
    }
    if (v44 >= v15) {
      size_t v45 = v15;
    }
    else {
      size_t v45 = v44;
    }
    int v46 = memcmp(v16, v43, v45);
    BOOL v47 = v15 < v44;
    if (v46) {
      BOOL v47 = v46 < 0;
    }
    if (v47)
    {
LABEL_77:
      if (v27)
      {
        *a3 = (uint64_t *)a4;
      }
      else
      {
        *a3 = a2;
        return a2 + 1;
      }
      return (uint64_t *)a4;
    }
    uint64_t v49 = (uint64_t)a1;
  }

  return sub_1CD4AF8D4(v49, v6, a5);
}

uint64_t sub_1CCCF52D8(uint64_t a1, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1CB8BDF7C(a1, *(const void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *(void *)(a1 + 16) = *((void *)a2 + 2);
    *(_OWORD *)a1 = v4;
  }
  *(_OWORD *)(a1 + 24) = *(long long *)((char *)a2 + 24);
  long long v5 = *(long long *)((char *)a2 + 40);
  long long v6 = *(long long *)((char *)a2 + 56);
  long long v7 = *(long long *)((char *)a2 + 72);
  *(void *)(a1 + 88) = *((void *)a2 + 11);
  *(_OWORD *)(a1 + 72) = v7;
  *(_OWORD *)(a1 + 56) = v6;
  *(_OWORD *)(a1 + 40) = v5;
  sub_1CCCF4A9C(a1 + 96, (void *)a2 + 12);
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 120) = a1 + 128;
  *(void *)(a1 + 136) = 0;
  BOOL v8 = (void *)*((void *)a2 + 15);
  size_t v9 = a2 + 8;
  if (v8 != v9)
  {
    do
    {
      sub_1CCCF4DE4(a1 + 120, a1 + 128, v8 + 4, v8 + 4);
      unint64_t v10 = (void *)v8[1];
      if (v10)
      {
        do
        {
          size_t v11 = v10;
          unint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          size_t v11 = (void *)v8[2];
          BOOL v12 = *v11 == (void)v8;
          BOOL v8 = v11;
        }
        while (!v12);
      }
      BOOL v8 = v11;
    }
    while (v11 != v9);
  }
  return a1;
}

uint64_t **sub_1CCCF53DC(uint64_t **a1, unint64_t a2, uint64_t **a3)
{
  long long v6 = a1 + 1;
  long long v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        long long v7 = (uint64_t **)v5;
        unint64_t v8 = v5[4];
        if (v8 <= a2) {
          break;
        }
        long long v5 = *v7;
        long long v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      long long v5 = v7[1];
      if (!v5)
      {
        long long v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    long long v7 = a1 + 1;
LABEL_9:
    size_t v9 = (uint64_t *)v7;
    long long v7 = (uint64_t **)operator new(0x60uLL);
    unint64_t v10 = *a3;
    v7[7] = 0;
    v7[6] = 0;
    void v7[4] = v10;
    v7[5] = (uint64_t *)(v7 + 6);
    *long long v7 = 0;
    v7[1] = 0;
    *((_OWORD *)v7 + 4) = 0u;
    *((_OWORD *)v7 + 5) = 0u;
    uint64_t v7[2] = v9;
    *long long v6 = (uint64_t *)v7;
    size_t v11 = (uint64_t *)**a1;
    BOOL v12 = (uint64_t *)v7;
    if (v11)
    {
      *a1 = v11;
      BOOL v12 = *v6;
    }
    sub_1CB8358B8(a1[1], v12);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

uint64_t sub_1CCCF54BC()
{
  int v4 = 1;
  int v1 = 1;
  int v2 = -1;
  long long v5 = &v2;
  v3.n128_u64[0] = (unint64_t)"Cutoff value about how many symbols in profile symbol list will be used. This is ve"
                                     "ry useful for performance debugging";
  v3.n128_u64[1] = 118;
  sub_1CD7524C8(&v4, &v5, &v1, &v3);
  __cxa_atexit((void (*)(void *))sub_1CC816390, &qword_1EBCF0270, &dword_1CB82C000);
  LOBYTE(v2) = 1;
  long long v5 = &v2;
  int v4 = 1;
  v3.n128_u64[0] = (unint64_t)"When generating nested context-sensitive profiles, always generate extra base profi"
                                     "le for function with all its context profiles merged into it.";
  v3.n128_u64[1] = 144;
  sub_1CD752660((char **)&v5, &v4, (long long *)&v3);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &GenerateMergedBaseProfiles, &dword_1CB82C000);
}

void llvm::sampleprof::SampleProfileReader::dumpFunctionProfile(uint64_t a1, long long *a2, llvm::raw_ostream *this)
{
  uint64_t v6 = *((void *)this + 4);
  if ((unint64_t)(*((void *)this + 3) - v6) > 9)
  {
    *(_WORD *)(v6 + 8) = 8250;
    *(void *)uint64_t v6 = *(void *)"Function: ";
    *((void *)this + 4) += 10;
  }
  else
  {
    llvm::raw_ostream::write(this, "Function: ", 0xAuLL);
  }
  sub_1CCCF56CC(a2, (uint64_t)__p);
  if (v12 >= 0) {
    long long v7 = __p;
  }
  else {
    long long v7 = (void **)__p[0];
  }
  if (v12 >= 0) {
    size_t v8 = v12 & 0x7F;
  }
  else {
    size_t v8 = (size_t)__p[1];
  }
  llvm::raw_ostream::write(this, (const char *)v7, v8);
  size_t v9 = (_WORD *)*((void *)this + 4);
  if (*((void *)this + 3) - (void)v9 > 1uLL)
  {
    _WORD *v9 = 8250;
    *((void *)this + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(this, ": ", 2uLL);
  }
  size_t v13 = a2;
  unint64_t v10 = sub_1CC9B3AE0(a1 + 8, (uint64_t)a2, (uint64_t)&std::piecewise_construct, &v13);
  llvm::sampleprof::FunctionSamples::print((llvm::sampleprof::FunctionSamples *)(v10 + 56), this, 0);
  if (v12 < 0) {
    operator delete(__p[0]);
  }
}

void *sub_1CCCF56CC@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  int v2 = (void *)a2;
  if (!*((_DWORD *)result + 8))
  {
    long long v5 = (const void *)*result;
    if (!*result)
    {
      *(void *)a2 = 0;
      *(void *)(a2 + 8) = 0;
      *(void *)(a2 + 16) = 0;
      return result;
    }
    size_t v6 = result[1];
    if (v6 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    if (v6 >= 0x17)
    {
      uint64_t v7 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v6 | 7) != 0x17) {
        uint64_t v7 = v6 | 7;
      }
      uint64_t v8 = v7 + 1;
      size_t v9 = operator new(v7 + 1);
      v2[1] = v6;
      v2[2] = v8 | 0x8000000000000000;
      void *v2 = v9;
      int v2 = v9;
    }
    else
    {
      *(unsigned char *)(a2 + 23) = v6;
      if (!v6) {
        goto LABEL_15;
      }
    }
    __n128 result = memmove(v2, v5, v6);
LABEL_15:
    *((unsigned char *)v2 + v6) = 0;
    return result;
  }
  unint64_t v3 = result[3];
  uint64_t v4 = result[2];

  return (void *)sub_1CCCF756C(v4, v3, 0);
}

void llvm::sampleprof::SampleProfileReader::dump(llvm::sampleprof::SampleProfileReader *this, llvm::raw_ostream *a2)
{
  unint64_t v10 = 0;
  size_t v11 = 0;
  uint64_t v12 = 0;
  llvm::sampleprof::sortFuncProfiles((uint64_t)this + 8, (uint64_t *)&v10);
  uint64_t v4 = v10;
  long long v5 = v11;
  if (v10 != v11)
  {
    do
    {
      long long v6 = *v4;
      long long v7 = v4[1];
      uint64_t v9 = *((void *)v4 + 4);
      v8[0] = v6;
      v8[1] = v7;
      llvm::sampleprof::SampleProfileReader::dumpFunctionProfile((uint64_t)this, v8, a2);
      v4 += 3;
    }
    while (v4 != v5);
    uint64_t v4 = v10;
  }
  if (v4)
  {
    size_t v11 = v4;
    operator delete(v4);
  }
}

uint64_t sub_1CCCF5840(void *a1, void *a2, unint64_t *a3, unint64_t *a4)
{
  uint64_t v4 = (unsigned char *)*a1;
  if (*(unsigned char *)*a1 != 32)
  {
    unint64_t v6 = a1[1];
    unint64_t v7 = v6 - 1;
    uint64_t v8 = v6;
    while (1)
    {
      unint64_t v9 = v8;
      unint64_t v10 = v7;
      if (!v8) {
        break;
      }
      --v8;
      --v7;
      if (v4[v9 - 1] == 58) {
        goto LABEL_8;
      }
    }
    uint64_t v8 = -1;
LABEL_8:
    if (v6 >= v8 - 1) {
      unint64_t v11 = v8 - 1;
    }
    else {
      unint64_t v11 = a1[1];
    }
    while (1)
    {
      unint64_t v12 = v11;
      if (!v11) {
        break;
      }
      --v11;
      if (v4[v12 - 1] == 58) {
        goto LABEL_15;
      }
    }
    unint64_t v11 = -1;
LABEL_15:
    if (v6 >= v11) {
      unint64_t v6 = v11;
    }
    *a2 = v4;
    a2[1] = v6;
    unint64_t v13 = a1[1];
    if (v13 >= v11 + 1) {
      unint64_t v14 = v11 + 1;
    }
    else {
      unint64_t v14 = a1[1];
    }
    unint64_t v15 = v13 - v14;
    if (v13 - v14 >= v8 + ~v11) {
      unint64_t v15 = v8 + ~v11;
    }
    if (v15)
    {
      unint64_t v16 = 0;
      size_t v17 = (unsigned char *)*a1;
      unint64_t v18 = v10 - v12;
      BOOL v19 = (unsigned __int8 *)(*a1 + v14);
      BOOL v20 = v13 >= v12;
      unint64_t v21 = v13 - v12;
      if (!v20) {
        unint64_t v21 = 0;
      }
      if (v18 < v21) {
        unint64_t v21 = v18;
      }
      uint64_t v22 = -(uint64_t)v21;
      while (1)
      {
        int v23 = *v19;
        if ((v23 - 48) >= 0xA)
        {
          if ((v23 - 97) >= 0x1A)
          {
            if ((v23 - 65) > 0x19) {
              return 0;
            }
            int v24 = -55;
          }
          else
          {
            int v24 = -87;
          }
        }
        else
        {
          int v24 = -48;
        }
        unsigned int v25 = v24 + v23;
        if (v25 > 9) {
          break;
        }
        unint64_t v26 = 10 * v16 + v25;
        if (v16 > v26 / 0xA) {
          break;
        }
        ++v19;
        unint64_t v16 = v26;
        BOOL v20 = __CFADD__(v22++, 1);
        if (v20)
        {
          *a3 = v26;
          if (v13 >= v8 + 1) {
            unint64_t v27 = v8 + 1;
          }
          else {
            unint64_t v27 = v13;
          }
          if (v13 != v27)
          {
            unint64_t v28 = 0;
            BOOL v29 = &v17[v27];
            if (v13 < v9) {
              unint64_t v9 = v13;
            }
            unint64_t v30 = v9 - v13;
            while (1)
            {
              int v31 = *v29;
              if ((v31 - 48) >= 0xA)
              {
                if ((v31 - 97) >= 0x1A)
                {
                  if ((v31 - 65) > 0x19) {
                    return 0;
                  }
                  int v32 = -55;
                }
                else
                {
                  int v32 = -87;
                }
              }
              else
              {
                int v32 = -48;
              }
              unsigned int v33 = v32 + v31;
              if (v33 > 9) {
                break;
              }
              unint64_t v34 = 10 * v28 + v33;
              if (v28 > v34 / 0xA) {
                break;
              }
              ++v29;
              unint64_t v28 = v34;
              BOOL v20 = __CFADD__(v30++, 1);
              if (v20)
              {
                *a4 = v34;
                return 1;
              }
            }
          }
          return 0;
        }
      }
    }
  }
  return 0;
}

void llvm::sampleprof::SampleProfileReader::computeSummary(llvm::sampleprof::SampleProfileReader *this)
{
  int v2 = operator new(0x40uLL);
  _OWORD *v2 = xmmword_1CFB2C580;
  v2[1] = unk_1CFB2C590;
  v2[2] = xmmword_1CFB2C5A0;
  v2[3] = unk_1CFB2C5B0;
  unint64_t v3 = v4;
  v4[0] = 0;
  v4[1] = 0;
  void v4[2] = v2;
  v4[3] = v2 + 4;
  __n128 v4[4] = v2 + 4;
  long long v5 = 0u;
  long long v6 = 0u;
  long long v7 = 0u;
  uint64_t v8 = 0;
  llvm::SampleProfileSummaryBuilder::computeSummaryForProfiles(&v3, (uint64_t)this + 8);
}

unint64_t llvm::sampleprof::SampleProfileReaderBinary::readSummary(llvm::sampleprof::SampleProfileReaderBinary *this)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  sub_1CD754C2C((uint64_t)&v24, (uint64_t)this);
  if ((v25 & 1) == 0)
  {
    std::system_category();
LABEL_6:
    sub_1CD754C2C((uint64_t)&v22, (uint64_t)this);
    if (v23)
    {
      uint64_t v2 = v22;
      uint64_t v3 = v22;
      if (v22) {
        goto LABEL_3;
      }
    }
    else
    {
      std::system_category();
    }
    sub_1CD754C2C((uint64_t)&v20, (uint64_t)this);
    if (v21)
    {
      uint64_t v2 = v20;
      uint64_t v3 = v20;
      if (v20) {
        goto LABEL_3;
      }
    }
    else
    {
      std::system_category();
    }
    sub_1CD754C2C((uint64_t)&v18, (uint64_t)this);
    if (v19)
    {
      uint64_t v2 = v18;
      uint64_t v3 = v18;
      if (v18) {
        goto LABEL_3;
      }
    }
    else
    {
      std::system_category();
    }
    sub_1CD754C2C((uint64_t)&v16, (uint64_t)this);
    if (v17)
    {
      uint64_t v2 = v16;
      uint64_t v3 = v16;
      if (v16) {
        goto LABEL_3;
      }
    }
    else
    {
      std::system_category();
    }
    sub_1CD754C2C((uint64_t)&v14, (uint64_t)this);
    if (v15)
    {
      unint64_t v6 = v14;
      uint64_t v7 = v14;
      if (v14)
      {
        unint64_t v4 = v14 & 0xFFFFFFFF00000000;
LABEL_36:
        uint64_t v3 = v7;
        return v4 | v3;
      }
    }
    else
    {
      std::system_category();
      unint64_t v6 = v14;
    }
    memset(v13, 0, sizeof(v13));
    if (!v6) {
LABEL_34:
    }
      operator new();
    unsigned int v8 = 1;
    while (1)
    {
      unint64_t SummaryEntry = llvm::sampleprof::SampleProfileReaderBinary::readSummaryEntry((uint64_t)this, (uint64_t)v13);
      if (llvm::sampleprof_category((llvm *)SummaryEntry) != v10 || SummaryEntry != 0) {
        break;
      }
      if (v6 <= v8++) {
        goto LABEL_34;
      }
    }
    uint64_t v7 = SummaryEntry;
    unint64_t v4 = SummaryEntry & 0xFFFFFFFF00000000;
    if (v13[0]) {
      operator delete(v13[0]);
    }
    goto LABEL_36;
  }
  uint64_t v2 = v24;
  uint64_t v3 = v24;
  if (!v24) {
    goto LABEL_6;
  }
LABEL_3:
  unint64_t v4 = v2 & 0xFFFFFFFF00000000;
  return v4 | v3;
}

unint64_t llvm::sampleprof::SampleProfileReaderExtBinaryBase::readNameTableSec(llvm::sampleprof::SampleProfileReaderExtBinaryBase *this, int a2)
{
  if (a2) {
    return llvm::sampleprof::SampleProfileReaderExtBinaryBase::readMD5NameTable(this);
  }
  else {
    return llvm::sampleprof::SampleProfileReaderBinary::readNameTable(this);
  }
}

unint64_t llvm::sampleprof::SampleProfileReaderExtBinaryBase::readFuncOffsetTable(llvm::sampleprof::SampleProfileReaderExtBinaryBase *this)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (void *)((char *)this + 320);
  sub_1CD75604C((_DWORD *)this + 80);
  sub_1CD754C2C((uint64_t)&v33, (uint64_t)this);
  if (v34)
  {
    unint64_t v3 = v33;
    if (v33)
    {
LABEL_3:
      unint64_t v4 = v3 & 0xFFFFFFFF00000000;
      return v3 | v4;
    }
    unint64_t v6 = v33;
  }
  else
  {
    std::system_category();
    unint64_t v6 = v33;
  }
  uint64_t v7 = (llvm *)sub_1CD7560A4(v2, v6);
  if (*((unsigned char *)this + 409)) {
    operator new();
  }
  if (v6)
  {
    LODWORD(v8) = 0;
    do
    {
      (*(void (**)(long long *__return_ptr, llvm::sampleprof::SampleProfileReaderExtBinaryBase *))(*(void *)this + 112))(&v29, this);
      if (v32)
      {
        unint64_t v3 = v29;
        if (v29) {
          goto LABEL_3;
        }
      }
      else
      {
        std::system_category();
      }
      sub_1CD754C2C((uint64_t)&v27, (uint64_t)this);
      if (v28)
      {
        unint64_t v3 = v27;
        if (v27) {
          goto LABEL_3;
        }
      }
      else
      {
        std::system_category();
        unint64_t v3 = v27;
      }
      uint64_t v7 = (llvm *)sub_1CD759F3C((uint64_t)v2, (uint64_t)&v29);
      *((void *)v7 + 5) = v3;
      if (*((unsigned char *)this + 409))
      {
        uint64_t v9 = *((void *)this + 43);
        unint64_t v11 = *(_OWORD **)(v9 + 8);
        unint64_t v10 = *(void *)(v9 + 16);
        if ((unint64_t)v11 >= v10)
        {
          char v15 = *(_OWORD **)v9;
          unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v11 - *(void *)v9) >> 4);
          unint64_t v17 = v16 + 1;
          if (v16 + 1 > 0x555555555555555) {
            abort();
          }
          unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - (void)v15) >> 4);
          if (2 * v18 > v17) {
            unint64_t v17 = 2 * v18;
          }
          if (v18 >= 0x2AAAAAAAAAAAAAALL) {
            unint64_t v19 = 0x555555555555555;
          }
          else {
            unint64_t v19 = v17;
          }
          if (v19 > 0x555555555555555) {
            sub_1CB833614();
          }
          uint64_t v20 = 3 * v19;
          uint64_t v7 = (llvm *)operator new(48 * v19);
          char v21 = (void *)((char *)v7 + 48 * v16);
          long long v22 = v30;
          *(_OWORD *)char v21 = v29;
          *((_OWORD *)v21 + llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = v22;
          void v21[4] = v31;
          void v21[5] = v3;
          if (v11 == v15)
          {
            uint64_t v24 = (void *)((char *)v7 + 48 * v16);
          }
          else
          {
            char v23 = (void *)((char *)v7 + 48 * v16);
            do
            {
              uint64_t v24 = v23 - 6;
              long long v25 = *(v11 - 3);
              long long v26 = *(v11 - 1);
              *((_OWORD *)v23 - 2) = *(v11 - 2);
              *((_OWORD *)v23 - llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = v26;
              *((_OWORD *)v23 - 3) = v25;
              v11 -= 3;
              v23 -= 6;
            }
            while (v11 != v15);
          }
          unint64_t v14 = v21 + 6;
          *(void *)uint64_t v9 = v24;
          *(void *)(v9 + 8) = v21 + 6;
          *(void *)(v9 + 16) = (char *)v7 + 16 * v20;
          if (v15) {
            operator delete(v15);
          }
        }
        else
        {
          long long v12 = v30;
          uint64_t v13 = v31;
          *unint64_t v11 = v29;
          v11[1] = v12;
          *((void *)v11 + 4) = v13;
          *((void *)v11 + 5) = v3;
          unint64_t v14 = v11 + 3;
        }
        *(void *)(v9 + 8) = v14;
      }
      unint64_t v8 = (v8 + 1);
    }
    while (v6 > v8);
  }
  llvm::sampleprof_category(v7);
  unint64_t v4 = 0;
  LODWORD(v3) = 0;
  return v3 | v4;
}

unint64_t llvm::sampleprof::SampleProfileReaderExtBinaryBase::readFuncMetadata(unint64_t this, BOOL a2)
{
  unint64_t v3 = (std::error_category *)this;
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t v4 = (void *)(this + 8);
  while (v3[19].__vftable < v3[20].__vftable)
  {
    ((void (*)(llvm::sampleprof::SampleProfileReaderExtBinaryBase **__return_ptr, std::error_category *))v3->__vftable[2].~error_category)(&v9, v3);
    if (v10)
    {
      this = (unint64_t)v9;
      if (v9) {
        goto LABEL_11;
      }
    }
    else
    {
      std::system_category();
    }
    long long v5 = sub_1CD681854(v4, (uint64_t)&v9);
    if (v5) {
      unint64_t v6 = (const std::string::value_type **)(v5 + 7);
    }
    else {
      unint64_t v6 = 0;
    }
    this = llvm::sampleprof::SampleProfileReaderExtBinaryBase::readFuncMetadata(v3, a2, v6);
    if (this)
    {
LABEL_11:
      unint64_t v7 = this & 0xFFFFFFFF00000000;
      return v7 | this;
    }
  }
  llvm::sampleprof_category((llvm *)this);
  LODWORD(this) = 0;
  unint64_t v7 = 0;
  return v7 | this;
}

BOOL llvm::sampleprof::SampleProfileReaderExtBinaryBase::collectFuncsFromModule(llvm::sampleprof::SampleProfileReaderExtBinaryBase *this)
{
  uint64_t v1 = *((void *)this + 17);
  if (v1)
  {
    unint64_t v3 = (char *)this + 352;
    sub_1CCBB9310((_DWORD *)this + 88);
    uint64_t v4 = *((void *)this + 17);
    uint64_t v5 = v4 + 24;
    for (uint64_t i = *(void *)(v4 + 32); i != v5; uint64_t i = *(void *)(i + 8))
    {
      if (i) {
        unint64_t v7 = (llvm::Value *)(i - 56);
      }
      else {
        unint64_t v7 = 0;
      }
      *(void *)&long long v10 = sub_1CD553864(v7);
      *((void *)&v10 + llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = v8;
      sub_1CD752440((uint64_t)v3, &v10, (uint64_t)v11);
    }
  }
  return v1 != 0;
}

unint64_t llvm::sampleprof::SampleProfileReaderCompactBinary::readImpl(llvm::sampleprof::SampleProfileReaderCompactBinary *this)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  uint64_t FuncProfile = (*(uint64_t (**)(llvm::sampleprof::SampleProfileReaderCompactBinary *))(*(void *)this + 32))(this);
  char v3 = byte_1EBCF03B8;
  *((unsigned char *)this + 128) = byte_1EBCF03B8;
  llvm::sampleprof::FunctionSamples::ProfileIsFS = v3;
  if (FuncProfile)
  {
    uint64_t v4 = *((void *)this + 30);
    uint64_t v5 = *((unsigned int *)this + 64);
    unint64_t v6 = (unint64_t *)(v4 + 16 * v5);
    if (*((_DWORD *)this + 62))
    {
      if (v5)
      {
        uint64_t v7 = 16 * v5;
        uint64_t v8 = (unint64_t *)*((void *)this + 30);
        while (*v8 >= 0xFFFFFFFFFFFFFFFELL)
        {
          v8 += 2;
          v7 -= 16;
          if (!v7) {
            goto LABEL_7;
          }
        }
      }
      else
      {
        uint64_t v8 = (unint64_t *)*((void *)this + 30);
      }
    }
    else
    {
LABEL_7:
      uint64_t v8 = (unint64_t *)(v4 + 16 * v5);
    }
    unint64_t v14 = (unint64_t *)(v4 + 16 * v5);
    if (v8 != v14)
    {
      unint64_t v15 = 0;
      unint64_t v16 = 0;
      unint64_t v17 = 0;
      do
      {
        unint64_t v18 = (int *)*v8;
        size_t v19 = v8[1];
        *(_OWORD *)&v49.__r_.__value_.__l.__data_ = xmmword_1CFAC4320;
        v49.__r_.__value_.__r.__words[2] = 0;
        llvm::MD5::update((int *)&v49, v18, v19);
        llvm::MD5::final((int *)&v49, (int *)__val);
        std::to_string(&v49, __val[0]);
        uint64_t v20 = (std::string *)v49.__r_.__value_.__r.__words[0];
        if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v20 = &v49;
        }
        unint64_t size = *((unsigned char *)&v49.__r_.__value_.__s + 23) & 0x7F;
        if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          unint64_t size = v49.__r_.__value_.__l.__size_;
        }
        __val[0] = (unint64_t)v20;
        __val[1] = size;
        uint64_t v47 = 0;
        uint64_t FuncProfile = sub_1CD759820((uint64_t *)this + 27, (const void **)__val, &v47);
        if (FuncProfile)
        {
          uint64_t v22 = v47;
          if (v47 != *((void *)this + 27) + 24 * *((unsigned int *)this + 58))
          {
            if ((unint64_t)v17 >= v15)
            {
              uint64_t v23 = (v17 - v16) >> 3;
              unint64_t v24 = v23 + 1;
              if ((unint64_t)(v23 + 1) >> 61) {
                goto LABEL_88;
              }
              if ((uint64_t)(v15 - (void)v16) >> 2 > v24) {
                unint64_t v24 = (uint64_t)(v15 - (void)v16) >> 2;
              }
              if (v15 - (unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v25 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v25 = v24;
              }
              if (v25)
              {
                if (v25 >> 61) {
                  goto LABEL_89;
                }
                uint64_t FuncProfile = (uint64_t)operator new(8 * v25);
              }
              else
              {
                uint64_t FuncProfile = 0;
              }
              long long v26 = (char *)(FuncProfile + 8 * v23);
              *(void *)long long v26 = *(void *)(v22 + 16);
              unint64_t v27 = v26 + 8;
              while (v17 != v16)
              {
                uint64_t v28 = *((void *)v17 - 1);
                v17 -= 8;
                *((void *)v26 - llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = v28;
                v26 -= 8;
              }
              unint64_t v15 = FuncProfile + 8 * v25;
              if (v16) {
                operator delete(v16);
              }
              unint64_t v17 = v27;
              unint64_t v16 = v26;
            }
            else
            {
              *(void *)unint64_t v17 = *(void *)(v47 + 16);
              v17 += 8;
            }
          }
        }
        if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v49.__r_.__value_.__l.__data_);
        }
        long long v29 = v8 + 2;
        while (v29 != v6)
        {
          unint64_t v30 = *v29;
          v29 += 2;
          if (v30 <= 0xFFFFFFFFFFFFFFFDLL)
          {
            uint64_t v8 = v29 - 2;
            goto LABEL_48;
          }
        }
        uint64_t v8 = v6;
LABEL_48:
        ;
      }
      while (v8 != v14);
      goto LABEL_77;
    }
LABEL_82:
    unint64_t v17 = 0;
LABEL_83:
    llvm::sampleprof_category((llvm *)FuncProfile);
    uint64_t v44 = 0;
    unint64_t v45 = 0;
    unint64_t v16 = v17;
    if (!v17) {
      return v45 | v44;
    }
LABEL_84:
    operator delete(v16);
    return v45 | v44;
  }
  uint64_t v9 = *((void *)this + 27);
  uint64_t v10 = *((unsigned int *)this + 58);
  uint64_t v11 = (unint64_t *)(v9 + 24 * v10);
  if (*((_DWORD *)this + 56))
  {
    if (v10)
    {
      uint64_t v12 = 24 * v10;
      uint64_t v13 = (unint64_t *)*((void *)this + 27);
      while (*v13 >= 0xFFFFFFFFFFFFFFFELL)
      {
        v13 += 3;
        v12 -= 24;
        if (!v12) {
          goto LABEL_13;
        }
      }
    }
    else
    {
      uint64_t v13 = (unint64_t *)*((void *)this + 27);
    }
  }
  else
  {
LABEL_13:
    uint64_t v13 = (unint64_t *)(v9 + 24 * v10);
  }
  uint64_t v31 = (unint64_t *)(v9 + 24 * v10);
  if (v13 == v31) {
    goto LABEL_82;
  }
  unint64_t v32 = 0;
  unint64_t v16 = 0;
  unint64_t v17 = 0;
  do
  {
    unint64_t v33 = v13[2];
    if ((unint64_t)v17 >= v32)
    {
      uint64_t v34 = (v17 - v16) >> 3;
      unint64_t v35 = v34 + 1;
      if ((unint64_t)(v34 + 1) >> 61) {
LABEL_88:
      }
        abort();
      if ((uint64_t)(v32 - (void)v16) >> 2 > v35) {
        unint64_t v35 = (uint64_t)(v32 - (void)v16) >> 2;
      }
      if (v32 - (unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v36 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v36 = v35;
      }
      if (v36)
      {
        if (v36 >> 61) {
LABEL_89:
        }
          sub_1CB833614();
        uint64_t FuncProfile = (uint64_t)operator new(8 * v36);
      }
      else
      {
        uint64_t FuncProfile = 0;
      }
      size_t v37 = (char *)(FuncProfile + 8 * v34);
      *(void *)size_t v37 = v33;
      size_t v38 = v37 + 8;
      while (v17 != v16)
      {
        uint64_t v39 = *((void *)v17 - 1);
        v17 -= 8;
        *((void *)v37 - llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = v39;
        v37 -= 8;
      }
      unint64_t v32 = FuncProfile + 8 * v36;
      if (v16) {
        operator delete(v16);
      }
      unint64_t v16 = v37;
      unint64_t v17 = v38;
    }
    else
    {
      *(void *)unint64_t v17 = v33;
      v17 += 8;
    }
    BOOL v40 = v13 + 3;
    while (v40 != v11)
    {
      unint64_t v41 = *v40;
      v40 += 3;
      if (v41 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        uint64_t v13 = v40 - 3;
        goto LABEL_76;
      }
    }
    uint64_t v13 = v11;
LABEL_76:
    ;
  }
  while (v13 != v31);
LABEL_77:
  if (v16 == v17) {
    goto LABEL_83;
  }
  uint64_t v42 = *((void *)this + 19);
  long long v43 = v16;
  while (1)
  {
    uint64_t FuncProfile = llvm::sampleprof::SampleProfileReaderBinary::readFuncProfile(this, (const unsigned __int8 *)(*(void *)(*((void *)this + 7) + 8) + *(void *)v43));
    uint64_t v44 = FuncProfile;
    if (FuncProfile) {
      break;
    }
    *((void *)this + 19) = v42;
    v43 += 8;
    if (v43 == v17)
    {
      unint64_t v17 = v16;
      goto LABEL_83;
    }
  }
  unint64_t v45 = FuncProfile & 0xFFFFFFFF00000000;
  if (v16) {
    goto LABEL_84;
  }
  return v45 | v44;
}

uint64_t llvm::sampleprof::SampleProfileReaderExtBinaryBase::getSectionSize(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 288);
  uint64_t v3 = *(void *)(a1 + 296);
  if (v2 == v3) {
    return 0;
  }
  uint64_t result = 0;
  do
  {
    if (*(_DWORD *)v2 == a2) {
      uint64_t v5 = *(void *)(v2 + 24);
    }
    else {
      uint64_t v5 = 0;
    }
    result += v5;
    v2 += 40;
  }
  while (v2 != v3);
  return result;
}

unint64_t llvm::sampleprof::SampleProfileReaderExtBinaryBase::getFileSize(llvm::sampleprof::SampleProfileReaderExtBinaryBase *this)
{
  uint64_t v1 = *((void *)this + 36);
  uint64_t v2 = *((void *)this + 37);
  if (v1 == v2) {
    return 0;
  }
  unint64_t result = 0;
  do
  {
    uint64_t v4 = *(void *)(v1 + 24);
    if (v4 + *(void *)(v1 + 16) > result) {
      unint64_t result = v4 + *(void *)(v1 + 16);
    }
    v1 += 40;
  }
  while (v1 != v2);
  return result;
}

BOOL llvm::sampleprof::SampleProfileReaderCompactBinary::collectFuncsFromModule(llvm::sampleprof::SampleProfileReaderCompactBinary *this)
{
  uint64_t v1 = *((void *)this + 17);
  if (v1)
  {
    uint64_t v3 = (char *)this + 240;
    sub_1CCBB9310((_DWORD *)this + 60);
    uint64_t v4 = *((void *)this + 17);
    uint64_t v5 = v4 + 24;
    for (uint64_t i = *(void *)(v4 + 32); i != v5; uint64_t i = *(void *)(i + 8))
    {
      if (i) {
        uint64_t v7 = (llvm::Value *)(i - 56);
      }
      else {
        uint64_t v7 = 0;
      }
      *(void *)&long long v10 = sub_1CD553864(v7);
      *((void *)&v10 + llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = v8;
      sub_1CD752440((uint64_t)v3, &v10, (uint64_t)v11);
    }
  }
  return v1 != 0;
}

BOOL llvm::sampleprof::SampleProfileReaderRawBinary::hasFormat(uint64_t a1)
{
  uint64_t v1 = 0;
  unsigned int v2 = 0;
  for (uint64_t i = *(char **)(a1 + 8); i; ++i)
  {
    char v4 = *i;
    uint64_t v5 = *i & 0x7F;
    if (v2 >= 0x40 && (*i & 0x7F) != 0) {
      break;
    }
    if ((unint64_t)(v5 << v2) >> v2 != v5) {
      break;
    }
    v1 += v5 << v2;
    v2 += 7;
    if ((v4 & 0x80) == 0) {
      return v1 == 0x5350524F463432FFLL;
    }
  }
  uint64_t v1 = 0;
  return v1 == 0x5350524F463432FFLL;
}

BOOL llvm::sampleprof::SampleProfileReaderExtBinary::hasFormat(uint64_t a1)
{
  uint64_t v1 = 0;
  unsigned int v2 = 0;
  for (uint64_t i = *(char **)(a1 + 8); i; ++i)
  {
    char v4 = *i;
    uint64_t v5 = *i & 0x7F;
    if (v2 >= 0x40 && (*i & 0x7F) != 0) {
      break;
    }
    if ((unint64_t)(v5 << v2) >> v2 != v5) {
      break;
    }
    v1 += v5 << v2;
    v2 += 7;
    if ((v4 & 0x80) == 0) {
      return v1 == 0x5350524F46343204;
    }
  }
  uint64_t v1 = 0;
  return v1 == 0x5350524F46343204;
}

BOOL llvm::sampleprof::SampleProfileReaderCompactBinary::hasFormat(uint64_t a1)
{
  uint64_t v1 = 0;
  unsigned int v2 = 0;
  for (uint64_t i = *(char **)(a1 + 8); i; ++i)
  {
    char v4 = *i;
    uint64_t v5 = *i & 0x7F;
    if (v2 >= 0x40 && (*i & 0x7F) != 0) {
      break;
    }
    if ((unint64_t)(v5 << v2) >> v2 != v5) {
      break;
    }
    v1 += v5 << v2;
    v2 += 7;
    if ((v4 & 0x80) == 0) {
      return v1 == 0x5350524F46343202;
    }
  }
  uint64_t v1 = 0;
  return v1 == 0x5350524F46343202;
}

uint64_t llvm::sampleprof::SampleProfileReaderGCC::readString@<X0>(llvm::sampleprof::SampleProfileReaderGCC *this@<X0>, uint64_t a2@<X8>)
{
  long long v6 = 0uLL;
  uint64_t result = sub_1CCCD4F00((uint64_t)this + 152, (unint64_t *)&v6);
  char v4 = *(unsigned char *)(a2 + 16);
  if (result)
  {
    char v5 = v4 & 0xFE;
    *(_OWORD *)a2 = v6;
  }
  else
  {
    char v5 = v4 | 1;
    uint64_t result = llvm::sampleprof_category((llvm *)result);
    *(void *)a2 = 4;
    *(void *)(a2 + 8) = result;
  }
  *(unsigned char *)(a2 + 16) = v5;
  return result;
}

uint64_t llvm::sampleprof::SampleProfileReaderItaniumRemapper::lookUpNameInProfile@<X0>(uint64_t a1@<X0>, char *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t result = sub_1CD06A938(**(void **)(a1 + 8), a2, a3, 0);
  if (result)
  {
    int v7 = *(_DWORD *)(a1 + 32);
    if (v7)
    {
      uint64_t v8 = *(void *)(a1 + 16);
      int v9 = v7 - 1;
      unsigned int v10 = v9 & (37 * result);
      uint64_t v11 = (uint64_t *)(v8 + 24 * v10);
      uint64_t v12 = *v11;
      if (result == *v11)
      {
LABEL_4:
        uint64_t v13 = v11[1];
        uint64_t v14 = v11[2];
      }
      else
      {
        int v15 = 1;
        while (v12 != -1)
        {
          unsigned int v16 = v10 + v15++;
          unsigned int v10 = v16 & v9;
          uint64_t v11 = (uint64_t *)(v8 + 24 * v10);
          uint64_t v12 = *v11;
          if (result == *v11) {
            goto LABEL_4;
          }
        }
        uint64_t v13 = 0;
        uint64_t v14 = 0;
      }
      *(void *)a4 = v13;
      *(void *)(a4 + 8) = v14;
    }
    else
    {
      *(void *)a4 = 0;
      *(void *)(a4 + 8) = 0;
    }
    *(unsigned char *)(a4 + 16) = 1;
  }
  else
  {
    *(unsigned char *)a4 = 0;
    *(unsigned char *)(a4 + 16) = 0;
  }
  return result;
}

void sub_1CCCF6A20(llvm::Twine *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  llvm::Twine::str(a1, &__s1);
  uint64_t v6 = v18;
  if ((v18 & 0x80u) == 0) {
    uint64_t v7 = v18 & 0x7F;
  }
  else {
    uint64_t v7 = v17;
  }
  if (v7 == 1
    && ((v18 & 0x80) != 0 ? (void **)(p_s1 = __s1, uint64_t v6 = v17) : (p_s1 = (void **)&__s1),
        (int v9 = memcmp(p_s1, "-", v6 != 0), v6 == 1) && !v9))
  {
    llvm::MemoryBuffer::getSTDIN((uint64_t)v19);
  }
  else
  {
    BufferForFile = (std::error_category *)llvm::vfs::FileSystem::getBufferForFile(a2, (uint64_t)a1, -1, 1, 0, 0, (uint64_t)v19);
  }
  if ((char)v18 < 0) {
    operator delete(__s1);
  }
  if (v20)
  {
    uint64_t v11 = (void *)v19[0];
    if (LODWORD(v19[0]))
    {
      uint64_t v12 = v19[1];
      *(unsigned char *)(a3 + 16) |= 1u;
      *(void *)a3 = v11;
      *(void *)(a3 + 8) = v12;
      goto LABEL_19;
    }
  }
  else
  {
    BufferForFile = (std::error_category *)std::system_category();
    uint64_t v11 = (void *)v19[0];
  }
  v19[0] = 0;
  char v13 = *(unsigned char *)(a3 + 16);
  if ((v11[2] - v11[1]) >> 32)
  {
    *(unsigned char *)(a3 + 16) = v13 | 1;
    atomic_ullong v14 = llvm::sampleprof_category((llvm *)BufferForFile);
    *(void *)a3 = 3;
    *(void *)(a3 + 8) = v14;
    (*(void (**)(void *))(*v11 + 8))(v11);
  }
  else
  {
    *(unsigned char *)(a3 + 16) = v13 & 0xFE;
    *(void *)a3 = v11;
  }
LABEL_19:
  if ((v20 & 1) == 0)
  {
    uint64_t v15 = v19[0];
    v19[0] = 0;
    if (v15) {
      (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
    }
  }
}

atomic_ullong llvm::sampleprof::SampleProfileReader::create@<X0>(llvm::sampleprof::SampleProfileReaderGCC **a1@<X0>, const llvm::MemoryBuffer *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = 0;
  unsigned int v5 = 0;
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *a1;
  uint64_t v7 = (char *)*((void *)*a1 + 1);
  uint64_t v8 = v7;
  while (v8)
  {
    char v9 = *v8;
    uint64_t v10 = *v8 & 0x7F;
    if (v5 >= 0x40 && (*v8 & 0x7F) != 0) {
      break;
    }
    if ((unint64_t)(v10 << v5) >> v5 != v10) {
      break;
    }
    v4 += v10 << v5;
    v5 += 7;
    ++v8;
    if ((v9 & 0x80) == 0)
    {
      if (v4 == 0x5350524F463432FFLL) {
        operator new();
      }
      break;
    }
  }
  uint64_t v11 = 0;
  unsigned int v12 = 0;
  char v13 = (char *)*((void *)*a1 + 1);
  while (v13)
  {
    char v14 = *v13;
    uint64_t v15 = *v13 & 0x7F;
    if (v12 >= 0x40 && (*v13 & 0x7F) != 0) {
      break;
    }
    if ((unint64_t)(v15 << v12) >> v12 != v15) {
      break;
    }
    v11 += v15 << v12;
    v12 += 7;
    ++v13;
    if ((v14 & 0x80) == 0)
    {
      if (v11 == 0x5350524F46343204) {
        operator new();
      }
      break;
    }
  }
  uint64_t v16 = 0;
  unsigned int v17 = 0;
  while (v7)
  {
    char v18 = *v7;
    uint64_t v19 = *v7 & 0x7F;
    if (v17 >= 0x40 && (*v7 & 0x7F) != 0) {
      break;
    }
    if ((unint64_t)(v19 << v17) >> v17 != v19) {
      break;
    }
    v16 += v19 << v17;
    v17 += 7;
    ++v7;
    if ((v18 & 0x80) == 0)
    {
      if (v16 == 0x5350524F46343202) {
        operator new();
      }
      break;
    }
  }
  if (llvm::sampleprof::SampleProfileReaderGCC::hasFormat(*a1, a2)) {
    operator new();
  }
  hasFormat = (llvm *)llvm::sampleprof::SampleProfileReaderText::hasFormat(v6, v20);
  if (hasFormat) {
    operator new();
  }
  *(unsigned char *)(a3 + 16) |= 1u;
  atomic_ullong result = llvm::sampleprof_category(hasFormat);
  *(void *)a3 = 6;
  *(void *)(a3 + 8) = result;
  return result;
}

void llvm::sampleprof::SampleProfileReaderItaniumRemapper::create()
{
}

uint64_t sub_1CCCF756C(uint64_t a1, unint64_t a2, int a3)
{
  sub_1CBF4C1CC((uint64_t)v17);
  if (a2)
  {
    uint64_t v7 = 0;
    unsigned int v8 = 1;
    while (1)
    {
      std::stringbuf::str();
      uint64_t v9 = (v16 & 0x80u) == 0 ? v16 : v15;
      if ((char)v16 < 0) {
        break;
      }
      if (v9) {
        goto LABEL_9;
      }
LABEL_10:
      if (a2 - 1 == v7) {
        int v10 = a3;
      }
      else {
        int v10 = 1;
      }
      sub_1CCCF76B8(a1 + 24 * v7, v10);
      if ((v16 & 0x80u) == 0) {
        p_p = &__p;
      }
      else {
        p_p = __p;
      }
      if ((v16 & 0x80u) == 0) {
        uint64_t v12 = v16 & 0x7F;
      }
      else {
        uint64_t v12 = v15;
      }
      sub_1CBF435C4(v17, (uint64_t)p_p, v12);
      if ((char)v16 < 0) {
        operator delete(__p);
      }
      uint64_t v7 = v8;
      if (a2 <= v8++) {
        goto LABEL_2;
      }
    }
    operator delete(__p);
    if (!v9) {
      goto LABEL_10;
    }
LABEL_9:
    sub_1CBF435C4(v17, (uint64_t)" @ ", 3);
    goto LABEL_10;
  }
LABEL_2:
  std::stringbuf::str();
  sub_1CD45577C((uint64_t)v17, MEMORY[0x1E4FBA418]);
  return MEMORY[0x1D25D9C00](&v18);
}

uint64_t sub_1CCCF76B8(uint64_t a1, int a2)
{
  sub_1CBF4C1CC((uint64_t)v20);
  uint64_t v4 = *(const void **)a1;
  if (!*(void *)a1)
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    char v7 = 0;
    std::string __p = 0;
    size_t v18 = 0;
    unint64_t v19 = 0;
    goto LABEL_12;
  }
  size_t v8 = *(void *)(a1 + 8);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v8 >= 0x17)
  {
    uint64_t v10 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v10 = v8 | 7;
    }
    uint64_t v11 = v10 + 1;
    p_p = operator new(v10 + 1);
    size_t v18 = v8;
    unint64_t v19 = v11 | 0x8000000000000000;
    std::string __p = p_p;
  }
  else
  {
    HIBYTE(v19) = *(void *)(a1 + 8);
    p_p = &__p;
    if (!v8) {
      goto LABEL_11;
    }
  }
  memmove(p_p, v4, v8);
LABEL_11:
  *((unsigned char *)p_p + v8) = 0;
  char v7 = HIBYTE(v19);
  uint64_t v6 = (void **)__p;
  uint64_t v5 = v18;
LABEL_12:
  BOOL v12 = v7 < 0;
  if (v7 >= 0) {
    char v13 = &__p;
  }
  else {
    char v13 = v6;
  }
  uint64_t v14 = v7 & 0x7F;
  if (v12) {
    uint64_t v15 = v5;
  }
  else {
    uint64_t v15 = v14;
  }
  sub_1CBF435C4(v20, (uint64_t)v13, v15);
  if (SHIBYTE(v19) < 0) {
    operator delete(__p);
  }
  if (a2)
  {
    sub_1CBF435C4(v20, (uint64_t)":", 1);
    std::ostream::operator<<();
    if (*(_DWORD *)(a1 + 20))
    {
      sub_1CBF435C4(v20, (uint64_t)".", 1);
      std::ostream::operator<<();
    }
  }
  std::stringbuf::str();
  sub_1CD45577C((uint64_t)v20, MEMORY[0x1E4FBA418]);
  return MEMORY[0x1D25D9C00](&v21);
}

uint64_t sub_1CCCF783C(uint64_t a1, uint64_t *a2, uint64_t a3, int a4)
{
  uint64_t v7 = *a2;
  *a2 = 0;
  *(void *)a1 = &unk_1F263CC00;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_DWORD *)(a1 + 40) = 1065353216;
  sub_1CC9B3D48(a1 + 8, 0);
  *(void *)(a1 + 48) = a3;
  *(void *)(a1 + 56) = v7;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_DWORD *)(a1 + 96) = 1065353216;
  *(_DWORD *)(a1 + 124) = 0;
  *(unsigned char *)(a1 + 128) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 119) = 0;
  *(_DWORD *)(a1 + 132) = a4;
  *(void *)(a1 + 136) = 0;
  *(_DWORD *)(a1 + 144) = 31;
  *(void *)a1 = &unk_1F263C8A0;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(void *)(a1 + 184) = 0;
  return a1;
}

_DWORD *sub_1CCCF7910(_DWORD *result, int a2)
{
  unsigned int v2 = result;
  if (a2)
  {
    unint64_t v3 = (4 * a2 / 3u + 1) | ((unint64_t)(4 * a2 / 3u + 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    LODWORD(v4) = (((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8)) + 1;
    result[4] = v4;
    atomic_ullong result = operator new(48 * v4, (std::align_val_t)8uLL);
    *(void *)unsigned int v2 = result;
    *((void *)v2 + llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = 0;
    uint64_t v5 = v2[4];
    if (v5)
    {
      uint64_t v6 = 48 * v5;
      do
      {
        *((void *)result + 4) = 0;
        *(_OWORD *)atomic_ullong result = 0uLL;
        *((_OWORD *)result + llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = 0uLL;
        result += 12;
        v6 -= 48;
      }
      while (v6);
    }
  }
  else
  {
    *(void *)atomic_ullong result = 0;
    *((void *)result + llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = 0;
    result[4] = 0;
  }
  return result;
}

uint64_t sub_1CCCF79B0(uint64_t a1)
{
  *(void *)a1 = &unk_1F263CC00;
  unsigned int v2 = *(uint64_t **)(a1 + 112);
  *(void *)(a1 + 112) = 0;
  if (v2)
  {
    unint64_t v3 = sub_1CD759730(v2);
    MEMORY[0x1D25D9CE0](v3, 0x1020C409CDB6E5ELL);
  }
  uint64_t v4 = *(void *)(a1 + 104);
  *(void *)(a1 + 104) = 0;
  if (v4) {
    sub_1CC025ED8(a1 + 104, v4);
  }
  sub_1CD5D8610(a1 + 64);
  uint64_t v5 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  sub_1CD751470(a1 + 8, *(void ***)(a1 + 24));
  uint64_t v6 = *(void **)(a1 + 8);
  *(void *)(a1 + 8) = 0;
  if (v6) {
    operator delete(v6);
  }
  return a1;
}

uint64_t sub_1CCCF7A7C(uint64_t a1)
{
  *(void *)a1 = &unk_1F263C9C0;
  unsigned int v2 = *(void ***)(a1 + 400);
  *(void *)(a1 + 400) = 0;
  if (v2)
  {
    size_t v18 = v2;
    sub_1CCCF7D58(&v18);
    MEMORY[0x1D25D9CE0](v2, 0x20C40960023A9);
  }
  unint64_t v3 = *(void ***)(a1 + 392);
  *(void *)(a1 + 392) = 0;
  if (v3)
  {
    size_t v18 = v3;
    sub_1CB8338B8(&v18);
    MEMORY[0x1D25D9CE0](v3, 0x20C40960023A9);
  }
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 352), 8);
  uint64_t v4 = *(void *)(a1 + 344);
  *(void *)(a1 + 344) = 0;
  if (v4) {
    sub_1CC1B41B0(v4);
  }
  sub_1CD759598(a1 + 320);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 320), 8);
  uint64_t v5 = *(void *)(a1 + 312);
  *(void *)(a1 + 312) = 0;
  if (v5)
  {
    uint64_t v6 = sub_1CD67F760(v5);
    MEMORY[0x1D25D9CE0](v6, 0x10B0C408C61162ELL);
  }
  uint64_t v7 = *(void **)(a1 + 288);
  if (v7)
  {
    *(void *)(a1 + 296) = v7;
    operator delete(v7);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 216);
  if (v8)
  {
    uint64_t v9 = *(uint64_t **)(a1 + 208);
    uint64_t v10 = 8 * v8;
    do
    {
      uint64_t v11 = *v9++;
      MEMORY[0x1D25D9CD0](v11, 8);
      v10 -= 8;
    }
    while (v10);
  }
  BOOL v12 = *(uint64_t **)(a1 + 256);
  uint64_t v13 = *(unsigned int *)(a1 + 264);
  if (v13)
  {
    uint64_t v16 = 16 * v13;
    do
    {
      uint64_t v17 = *v12;
      v12 += 2;
      MEMORY[0x1D25D9CD0](v17, 8);
      v16 -= 16;
    }
    while (v16);
    BOOL v12 = *(uint64_t **)(a1 + 256);
  }
  if (v12 != (uint64_t *)(a1 + 272)) {
    free(v12);
  }
  uint64_t v14 = *(void **)(a1 + 208);
  if (v14 != (void *)(a1 + 224)) {
    free(v14);
  }
  return sub_1CD759538((void *)a1);
}

uint64_t sub_1CCCF7C14(uint64_t *a1, uint64_t a2)
{
  unint64_t v2 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 3);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0x666666666666666) {
    abort();
  }
  if (0x999999999999999ALL * ((a1[2] - *a1) >> 3) > v3) {
    unint64_t v3 = 0x999999999999999ALL * ((a1[2] - *a1) >> 3);
  }
  if (0xCCCCCCCCCCCCCCCDLL * ((a1[2] - *a1) >> 3) >= 0x333333333333333) {
    unint64_t v6 = 0x666666666666666;
  }
  else {
    unint64_t v6 = v3;
  }
  unint64_t v19 = a1 + 2;
  if (v6)
  {
    if (v6 > 0x666666666666666) {
      sub_1CB833614();
    }
    uint64_t v7 = (char *)operator new(40 * v6);
  }
  else
  {
    uint64_t v7 = 0;
  }
  uint64_t v8 = &v7[40 * v2];
  std::string __p = v7;
  uint64_t v16 = v8;
  size_t v18 = &v7[40 * v6];
  *(void *)uint64_t v8 = v8 + 16;
  *((void *)v8 + llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = 0x100000000;
  if (*(_DWORD *)(a2 + 8)) {
    uint64_t v8 = (char *)sub_1CD4683C8((uint64_t)v8, a2);
  }
  uint64_t v17 = v8 + 40;
  sub_1CD75A110(a1, &__p);
  uint64_t v9 = a1[1];
  uint64_t v10 = v16;
  uint64_t v11 = v17;
  while (v11 != v10)
  {
    uint64_t v13 = (char *)*((void *)v11 - 5);
    v11 -= 40;
    BOOL v12 = v13;
    if (v11 + 16 != v13) {
      free(v12);
    }
  }
  if (__p) {
    operator delete(__p);
  }
  return v9;
}

void sub_1CCCF7D58(void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = (char *)*((void *)v4 - 5);
        v4 -= 40;
        unint64_t v6 = v7;
        if (v4 + 16 != v7) {
          free(v6);
        }
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

char *sub_1CCCF7DE4(char **a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *a1;
  uint64_t v5 = a1[1];
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * ((a1[2] - v4) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * ((a1[2] - v4) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - v4) >> 3) >= 0x555555555555555) {
    unint64_t v7 = 0xAAAAAAAAAAAAAAALL;
  }
  if (v7 > 0xAAAAAAAAAAAAAAALL) {
    sub_1CB833614();
  }
  uint64_t v12 = 3 * v7;
  uint64_t v13 = (char *)operator new(24 * v7);
  uint64_t v14 = &v13[24 * v6];
  *(_DWORD *)uint64_t v14 = a2;
  *((void *)v14 + llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = a3;
  *((void *)v14 + 2) = a4;
  uint64_t v15 = v14 + 24;
  if (v5 == v4)
  {
    uint64_t v16 = &v13[24 * v6];
  }
  else
  {
    do
    {
      uint64_t v16 = v14 - 24;
      long long v17 = *(_OWORD *)(v5 - 24);
      *((void *)v14 - llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = *((void *)v5 - 1);
      *(_OWORD *)(v14 - 24) = v17;
      v5 -= 24;
      v14 -= 24;
    }
    while (v5 != v4);
  }
  *a1 = v16;
  a1[1] = v15;
  a1[2] = &v13[8 * v12];
  if (v4) {
    operator delete(v4);
  }
  return v15;
}

uint64_t sub_1CCCF7F04(void *a1, void *a2, uint64_t a3)
{
  uint64_t result = (*(uint64_t (**)(void, void *))(*(void *)*a2 + 48))(*a2, &llvm::SymbolRemappingParseError::ID);
  uint64_t v7 = *a2;
  *a2 = 0;
  if (result)
  {
    uint64_t v8 = *(void *)a3;
    uint64_t v9 = (*(uint64_t (**)(void))(***(void ***)(a3 + 8) + 16))(**(void **)(a3 + 8));
    uint64_t v11 = *(void *)(v7 + 32);
    char v12 = *(unsigned char *)(v7 + 63);
    BOOL v13 = v12 < 0;
    if (v12 >= 0) {
      uint64_t v14 = v7 + 40;
    }
    else {
      uint64_t v14 = *(void *)(v7 + 40);
    }
    uint64_t v15 = *(void *)(v7 + 48);
    uint64_t v16 = v12 & 0x7F;
    __int16 v18 = 261;
    if (v13) {
      uint64_t v16 = v15;
    }
    v17[0] = v14;
    v17[1] = v16;
    int v20 = 8;
    char v21 = 0;
    unint64_t v19 = &unk_1F2616770;
    uint64_t v22 = v9;
    uint64_t v23 = v10;
    int v24 = v11;
    unint64_t v25 = v17;
    llvm::LLVMContext::diagnose(v8, (const llvm::DiagnosticInfo *)&v19);
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 8))(v7);
    uint64_t v7 = 0;
  }
  *a1 = v7;
  return result;
}

uint64_t sub_1CCCF8050()
{
  int v4 = 1;
  char v2 = 0;
  unint64_t v3 = &v2;
  v1.n128_u64[0] = (unint64_t)"Profile uses flow sensitive discriminators";
  v1.n128_u64[1] = 42;
  sub_1CC025F34((llvm::cl::Option *)&unk_1EBCF0338, "profile-isfs", &v4, &v3, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF0338, &dword_1CB82C000);
}

uint64_t sub_1CCCF80DC(uint64_t a1)
{
  uint64_t v2 = 672;
  do
  {
    unint64_t v3 = *(void **)(a1 + v2 - 336);
    if ((void *)(a1 + v2 - 320) != v3) {
      free(v3);
    }
    v2 -= 336;
  }
  while (v2);
  return a1;
}

unint64_t llvm::sampleprof::SampleProfileWriter::writeFuncProfiles(uint64_t a1, uint64_t a2)
{
  std::string __p = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  llvm::sampleprof::sortFuncProfiles(a2, (uint64_t *)&__p);
  int v4 = __p;
  uint64_t v5 = v10;
  while (1)
  {
    if (v4 == v5)
    {
      llvm::sampleprof_category((llvm *)v3);
      unint64_t v7 = 0;
      uint64_t v6 = 0;
      goto LABEL_7;
    }
    unint64_t v3 = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 16))(a1, v4[5]);
    uint64_t v6 = v3;
    if (v3) {
      break;
    }
    v4 += 6;
  }
  unint64_t v7 = v3 & 0xFFFFFFFF00000000;
LABEL_7:
  if (__p)
  {
    uint64_t v10 = __p;
    operator delete(__p);
  }
  return v6 | v7;
}

unint64_t llvm::sampleprof::SampleProfileWriter::write(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 72))(a1);
  if (v4 || (uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 80))(a1, a2), v4))
  {
    unint64_t v5 = v4 & 0xFFFFFFFF00000000;
  }
  else
  {
    llvm::sampleprof_category((llvm *)v4);
    unint64_t v5 = 0;
    LODWORD(v4) = 0;
  }
  return v4 | v5;
}

uint64_t llvm::sampleprof::SampleProfileWriterExtBinaryBase::markSectionStart(void *a1, uint64_t a2, unsigned int a3)
{
  unint64_t v5 = (void *)a1[1];
  uint64_t v6 = (*(uint64_t (**)(void *))(*v5 + 80))(v5);
  uint64_t v7 = v5[4];
  uint64_t v8 = v5[2];
  if (*(unsigned char *)(a1[11] + 40 * a3 + 8))
  {
    uint64_t v9 = a1[54];
    a1[54] = a1[1];
    a1[1] = v9;
  }
  return v6 + v7 - v8;
}

uint64_t llvm::sampleprof::SampleProfileWriterExtBinaryBase::compressAndOutput(llvm::sampleprof::SampleProfileWriterExtBinaryBase *this)
{
  return 13;
}

uint64_t llvm::sampleprof::SampleProfileWriterExtBinaryBase::addNewSection(void *a1, int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v4 = a1;
  uint64_t v5 = *(void *)(a1[11] + 40 * a3 + 8);
  if (v5)
  {
    uint64_t v15 = a1[54];
    a1[54] = a1[1];
    a1[1] = v15;
    uint64_t v16 = 13;
  }
  else
  {
    uint64_t v9 = a4 - a1[55];
    uint64_t v10 = (void *)a1[1];
    a1 = (void *)(*(uint64_t (**)(void *))(*v10 + 80))(v10);
    uint64_t v11 = (char *)a1 + v10[4] - v10[2] - a4;
    BOOL v13 = (char *)v4[58];
    unint64_t v12 = v4[59];
    if ((unint64_t)v13 >= v12)
    {
      long long v17 = (char *)v4[57];
      unint64_t v18 = 0xCCCCCCCCCCCCCCCDLL * ((v13 - v17) >> 3) + 1;
      if (v18 > 0x666666666666666) {
        abort();
      }
      unint64_t v19 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v12 - (void)v17) >> 3);
      if (2 * v19 > v18) {
        unint64_t v18 = 2 * v19;
      }
      if (v19 >= 0x333333333333333) {
        unint64_t v20 = 0x666666666666666;
      }
      else {
        unint64_t v20 = v18;
      }
      if (v20)
      {
        if (v20 > 0x666666666666666) {
          sub_1CB833614();
        }
        a1 = operator new(40 * v20);
      }
      else
      {
        a1 = 0;
      }
      char v21 = &a1[(v13 - v17) >> 3];
      *(_DWORD *)char v21 = a2;
      v21[1] = v5;
      void v21[2] = v9;
      void v21[3] = v11;
      *((_DWORD *)v21 + 8) = a3;
      uint64_t v14 = v21 + 5;
      if (v13 != v17)
      {
        do
        {
          long long v22 = *(_OWORD *)(v13 - 40);
          long long v23 = *(_OWORD *)(v13 - 24);
          *(v21 - llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = *((void *)v13 - 1);
          *(_OWORD *)(v21 - 3) = v23;
          *(_OWORD *)(v21 - 5) = v22;
          v21 -= 5;
          v13 -= 40;
        }
        while (v13 != v17);
        BOOL v13 = (char *)v4[57];
      }
      v4[57] = v21;
      v4[58] = v14;
      v4[59] = &a1[5 * v20];
      if (v13) {
        operator delete(v13);
      }
    }
    else
    {
      *(_DWORD *)BOOL v13 = a2;
      *((void *)v13 + llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = v5;
      *((void *)v13 + 2) = v9;
      *((void *)v13 + 3) = v11;
      uint64_t v14 = v13 + 40;
      *((_DWORD *)v13 + 8) = a3;
    }
    uint64_t v16 = 0;
    v4[58] = v14;
  }
  llvm::sampleprof_category((llvm *)a1);
  return v16;
}

uint64_t llvm::sampleprof::SampleProfileWriterExtBinaryBase::write(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 72))(a1);
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t llvm::sampleprof::SampleProfileWriterExtBinaryBase::writeSecHdrTable(llvm::sampleprof::SampleProfileWriterExtBinaryBase *this)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (llvm::raw_fd_ostream *)*((void *)this + 1);
  uint64_t v3 = (*(uint64_t (**)(llvm::raw_fd_ostream *))(*(void *)v2 + 80))(v2);
  uint64_t v4 = *((void *)v2 + 4);
  uint64_t v5 = *((void *)v2 + 2);
  if (llvm::raw_fd_ostream::seek(v2, *((void *)this + 56)) == -1)
  {
    uint64_t v14 = 11;
    llvm::sampleprof_category((llvm *)0xFFFFFFFFFFFFFFFFLL);
  }
  else
  {
    off_t v6 = v3 + v4 - v5;
    uint64_t v7 = (llvm::raw_ostream *)*((void *)this + 1);
    uint64_t v8 = *((void *)this + 57);
    uint64_t v9 = *((void *)this + 58);
    __b = v29;
    int v28 = 16;
    if (0xCCCCCCCCCCCCCCCDLL * ((v9 - v8) >> 3) >= 0x11)
    {
      int v27 = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    if (v9 == v8)
    {
      int v27 = -858993459 * ((v9 - v8) >> 3);
    }
    else
    {
      memset(v29, 255, 0x3333333333333334 * ((v9 - v8) >> 3));
      int v27 = -858993459 * ((v9 - v8) >> 3);
      uint64_t v10 = (int *)(v8 + 32);
      unsigned int v11 = 1;
      do
      {
        int v12 = *v10;
        v10 += 10;
        v29[v12] = v11 - 1;
      }
      while (0xCCCCCCCCCCCCCCCDLL * ((v9 - v8) >> 3) > v11++);
    }
    if (*((_DWORD *)this + 24))
    {
      unint64_t v15 = 0;
      do
      {
        uint64_t v16 = (void *)(*((void *)this + 57) + 40 * *((unsigned int *)__b + v15));
        uint64_t v17 = v16[1];
        uint64_t v18 = v16[2];
        uint64_t v19 = v16[3];
        uint64_t v25 = *(unsigned int *)v16;
        unint64_t v20 = llvm::raw_ostream::write(v7, (const char *)&v25, 8uLL);
        uint64_t v25 = v17;
        char v21 = llvm::raw_ostream::write(v20, (const char *)&v25, 8uLL);
        uint64_t v25 = v18;
        long long v22 = llvm::raw_ostream::write(v21, (const char *)&v25, 8uLL);
        uint64_t v25 = v19;
        llvm::raw_ostream::write(v22, (const char *)&v25, 8uLL);
        ++v15;
      }
      while (v15 < *((unsigned int *)this + 24));
    }
    long long v23 = (llvm *)llvm::raw_fd_ostream::seek(v2, v6);
    llvm::sampleprof_category(v23);
    if (v23 == (llvm *)-1) {
      uint64_t v14 = 11;
    }
    else {
      uint64_t v14 = 0;
    }
    if (__b != v29) {
      free(__b);
    }
  }
  return v14;
}

uint64_t llvm::sampleprof::SampleProfileWriterExtBinaryBase::writeContextIdx(void *a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 32)) {
    return llvm::sampleprof::SampleProfileWriterExtBinaryBase::writeCSNameIdx((uint64_t)a1, a2);
  }
  else {
    return llvm::sampleprof::SampleProfileWriterBinary::writeNameIdx(a1, *(const void **)a2, *(const void **)(a2 + 8));
  }
}

uint64_t llvm::sampleprof::SampleProfileWriterExtBinaryBase::writeCSNameIdx(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = 0;
  uint64_t v3 = (llvm::raw_ostream *)sub_1CCCFDD40(*(void *)(a1 + 536), *(_DWORD *)(a1 + 552), a2, &v13);
  if (v3) {
    BOOL v4 = v13 == *(void *)(a1 + 536) + 48 * *(unsigned int *)(a1 + 552);
  }
  else {
    BOOL v4 = 1;
  }
  if (v4 || (uint64_t v5 = *(void *)(a1 + 560), v6 = *(_DWORD *)(v13 + 40), *(void *)(a1 + 568) == v5 + 48 * v6))
  {
    uint64_t v11 = 8;
  }
  else
  {
    unint64_t v7 = *(unsigned int *)(v5 + 48 * v6 + 40);
    uint64_t v3 = *(llvm::raw_ostream **)(a1 + 8);
    do
    {
      char v8 = v7 & 0x7F | ((v7 > 0x7F) << 7);
      uint64_t v9 = (char *)*((void *)v3 + 4);
      if ((unint64_t)v9 >= *((void *)v3 + 3))
      {
        uint64_t v3 = llvm::raw_ostream::write(v3, v8);
      }
      else
      {
        *((void *)v3 + 4) = v9 + 1;
        char *v9 = v8;
      }
      BOOL v10 = v7 > 0x7F;
      v7 >>= 7;
    }
    while (v10);
    uint64_t v11 = 0;
  }
  llvm::sampleprof_category(v3);
  return v11;
}

uint64_t llvm::sampleprof::SampleProfileWriterBinary::writeNameIdx(void *a1, const void *a2, const void *a3)
{
  v15[0] = a2;
  v15[1] = a3;
  uint64_t v4 = (*(uint64_t (**)(void *))(*a1 + 88))(a1);
  uint64_t v16 = 0;
  uint64_t v5 = (llvm::raw_ostream *)sub_1CD69C804((uint64_t *)v4, v15, &v16);
  if (v5) {
    BOOL v6 = v16 == *(void *)v4 + 24 * *(unsigned int *)(v4 + 16);
  }
  else {
    BOOL v6 = 1;
  }
  if (v6 || (unsigned int v7 = *(_DWORD *)(v16 + 16), v8 = *(void *)(v4 + 24), *(void *)(v4 + 32) == v8 + 24 * v7))
  {
    uint64_t v13 = 8;
  }
  else
  {
    unint64_t v9 = *(unsigned int *)(v8 + 24 * v7 + 16);
    uint64_t v5 = (llvm::raw_ostream *)a1[1];
    do
    {
      char v10 = v9 & 0x7F | ((v9 > 0x7F) << 7);
      uint64_t v11 = (char *)*((void *)v5 + 4);
      if ((unint64_t)v11 >= *((void *)v5 + 3))
      {
        uint64_t v5 = llvm::raw_ostream::write(v5, v10);
      }
      else
      {
        *((void *)v5 + 4) = v11 + 1;
        *uint64_t v11 = v10;
      }
      BOOL v12 = v9 > 0x7F;
      v9 >>= 7;
    }
    while (v12);
    uint64_t v13 = 0;
  }
  llvm::sampleprof_category(v5);
  return v13;
}

unint64_t llvm::sampleprof::SampleProfileWriterExtBinaryBase::writeSample(llvm::sampleprof::SampleProfileWriterExtBinaryBase *this, const llvm::sampleprof::FunctionSamples *a2)
{
  uint64_t v4 = (void *)*((void *)this + 1);
  uint64_t v5 = (*(uint64_t (**)(void *))(*v4 + 80))(v4);
  uint64_t v6 = v4[4];
  uint64_t v7 = v4[2];
  uint64_t v8 = *((void *)this + 53);
  long long v9 = *((_OWORD *)a2 + 2);
  v38[0] = *((_OWORD *)a2 + 1);
  v38[1] = v9;
  uint64_t v39 = *((void *)a2 + 6);
  int v40 = 0;
  sub_1CCCFDE6C((uint64_t)&v36, (uint64_t)this + 480, (uint64_t)v38, &v40);
  uint64_t v10 = v36;
  if (v37)
  {
    uint64_t v11 = (_OWORD *)((char *)a2 + 16);
    BOOL v12 = (_OWORD *)*((void *)this + 64);
    unint64_t v13 = *((void *)this + 65);
    if ((unint64_t)v12 >= v13)
    {
      uint64_t v35 = v7;
      uint64_t v19 = (_OWORD *)*((void *)this + 63);
      unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * (v12 - v19) + 1;
      if (v20 > 0x555555555555555) {
        abort();
      }
      unint64_t v21 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v19) >> 4);
      if (2 * v21 > v20) {
        unint64_t v20 = 2 * v21;
      }
      if (v21 >= 0x2AAAAAAAAAAAAAALL) {
        unint64_t v22 = 0x555555555555555;
      }
      else {
        unint64_t v22 = v20;
      }
      if (v22)
      {
        if (v22 > 0x555555555555555) {
          sub_1CB833614();
        }
        long long v23 = (char *)operator new(48 * v22);
      }
      else
      {
        long long v23 = 0;
      }
      int v24 = &v23[16 * (v12 - v19)];
      uint64_t v25 = &v23[48 * v22];
      long long v26 = *((_OWORD *)a2 + 2);
      *(_OWORD *)int v24 = *v11;
      *((_OWORD *)v24 + llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = v26;
      *((void *)v24 + 4) = *((void *)a2 + 6);
      *((void *)v24 + 5) = 0;
      uint64_t v16 = v24 + 48;
      if (v12 == v19)
      {
        uint64_t v7 = v35;
      }
      else
      {
        uint64_t v7 = v35;
        do
        {
          long long v27 = *(v12 - 3);
          long long v28 = *(v12 - 1);
          *((_OWORD *)v24 - 2) = *(v12 - 2);
          *((_OWORD *)v24 - llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = v28;
          *((_OWORD *)v24 - 3) = v27;
          v24 -= 48;
          v12 -= 3;
        }
        while (v12 != v19);
        BOOL v12 = (_OWORD *)*((void *)this + 63);
      }
      *((void *)this + 63) = v24;
      *((void *)this + 64) = v16;
      *((void *)this + 65) = v25;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      long long v14 = *((_OWORD *)a2 + 2);
      uint64_t v15 = *((void *)a2 + 6);
      *BOOL v12 = *v11;
      v12[1] = v14;
      *((void *)v12 + 4) = v15;
      *((void *)v12 + 5) = 0;
      uint64_t v16 = v12 + 3;
    }
    *((void *)this + 64) = v16;
    uint64_t v18 = *((void *)this + 63);
    unsigned int v17 = -1431655765 * (((unint64_t)v16 - v18) >> 4) - 1;
    *(_DWORD *)(v10 + 40) = v17;
  }
  else
  {
    unsigned int v17 = *(_DWORD *)(v36 + 40);
    uint64_t v18 = *((void *)this + 63);
  }
  *(void *)(v18 + 48 * v17 + 40) = v5 + v6 - (v8 + v7);
  unint64_t v29 = *((void *)a2 + 8);
  uint64_t v30 = (llvm::raw_ostream *)*((void *)this + 1);
  do
  {
    char v31 = v29 & 0x7F | ((v29 > 0x7F) << 7);
    unint64_t v32 = (char *)*((void *)v30 + 4);
    if ((unint64_t)v32 >= *((void *)v30 + 3))
    {
      uint64_t v30 = llvm::raw_ostream::write(v30, v31);
    }
    else
    {
      *((void *)v30 + 4) = v32 + 1;
      char *v32 = v31;
    }
    BOOL v33 = v29 > 0x7F;
    v29 >>= 7;
  }
  while (v33);

  return llvm::sampleprof::SampleProfileWriterBinary::writeBody(this, a2);
}

unint64_t llvm::sampleprof::SampleProfileWriterBinary::writeBody(llvm::sampleprof::SampleProfileWriterBinary *this, const llvm::sampleprof::FunctionSamples *a2)
{
  uint64_t v4 = (llvm::raw_ostream *)*((void *)this + 1);
  uint64_t v5 = (llvm *)(*(uint64_t (**)(llvm::sampleprof::SampleProfileWriterBinary *, char *))(*(void *)this + 112))(this, (char *)a2 + 16);
  uint64_t v6 = v5;
  if (v5)
  {
LABEL_2:
    unint64_t v7 = (unint64_t)v6 & 0xFFFFFFFF00000000;
    return v7 | v6;
  }
  unint64_t v9 = *((void *)a2 + 7);
  do
  {
    char v10 = v9 & 0x7F | ((v9 > 0x7F) << 7);
    uint64_t v11 = (char *)*((void *)v4 + 4);
    if ((unint64_t)v11 >= *((void *)v4 + 3))
    {
      uint64_t v5 = llvm::raw_ostream::write(v4, v10);
    }
    else
    {
      *((void *)v4 + 4) = v11 + 1;
      *uint64_t v11 = v10;
    }
    BOOL v12 = v9 > 0x7F;
    v9 >>= 7;
  }
  while (v12);
  unint64_t v13 = *((void *)a2 + 11);
  do
  {
    char v14 = v13 & 0x7F | ((v13 > 0x7F) << 7);
    uint64_t v15 = (char *)*((void *)v4 + 4);
    if ((unint64_t)v15 >= *((void *)v4 + 3))
    {
      uint64_t v5 = llvm::raw_ostream::write(v4, v14);
    }
    else
    {
      *((void *)v4 + 4) = v15 + 1;
      char *v15 = v14;
    }
    BOOL v12 = v13 > 0x7F;
    v13 >>= 7;
  }
  while (v12);
  uint64_t v16 = (const llvm::sampleprof::FunctionSamples *)*((void *)a2 + 9);
  if (v16 == (const llvm::sampleprof::FunctionSamples *)((char *)a2 + 80))
  {
LABEL_52:
    uint64_t v39 = (char *)*((void *)a2 + 12);
    int v40 = (char *)a2 + 104;
    if (v39 == (char *)a2 + 104)
    {
      unint64_t v41 = 0;
    }
    else
    {
      unint64_t v41 = 0;
      do
      {
        uint64_t v42 = (char *)*((void *)v39 + 1);
        long long v43 = v39;
        if (v42)
        {
          do
          {
            uint64_t v44 = v42;
            uint64_t v42 = *(char **)v42;
          }
          while (v42);
        }
        else
        {
          do
          {
            uint64_t v44 = (char *)*((void *)v43 + 2);
            BOOL v36 = *(void *)v44 == (void)v43;
            long long v43 = v44;
          }
          while (!v36);
        }
        v41 += *((void *)v39 + 7);
        uint64_t v39 = v44;
      }
      while (v44 != v40);
    }
    do
    {
      char v45 = v41 & 0x7F | ((v41 > 0x7F) << 7);
      int v46 = (char *)*((void *)v4 + 4);
      if ((unint64_t)v46 >= *((void *)v4 + 3))
      {
        uint64_t v5 = llvm::raw_ostream::write(v4, v45);
      }
      else
      {
        *((void *)v4 + 4) = v46 + 1;
        char *v46 = v45;
      }
      BOOL v12 = v41 > 0x7F;
      v41 >>= 7;
    }
    while (v12);
    uint64_t v47 = (char *)*((void *)a2 + 12);
    if (v47 == v40)
    {
LABEL_91:
      llvm::sampleprof_category(v5);
      LODWORD(v6) = 0;
      unint64_t v7 = 0;
      return v7 | v6;
    }
    while (1)
    {
      long long v48 = (char *)*((void *)v47 + 5);
      if (v48 != v47 + 48) {
        break;
      }
LABEL_85:
      long long v57 = (char *)*((void *)v47 + 1);
      if (v57)
      {
        do
        {
          uint64_t v58 = v57;
          long long v57 = *(char **)v57;
        }
        while (v57);
      }
      else
      {
        do
        {
          uint64_t v58 = (char *)*((void *)v47 + 2);
          BOOL v36 = *(void *)v58 == (void)v47;
          uint64_t v47 = v58;
        }
        while (!v36);
      }
      uint64_t v47 = v58;
      if (v58 == v40) {
        goto LABEL_91;
      }
    }
    while (1)
    {
      unint64_t v50 = *((unsigned int *)v47 + 8);
      unint64_t v49 = *((unsigned int *)v47 + 9);
      do
      {
        char v51 = v50 & 0x7F | ((v50 > 0x7F) << 7);
        uint64_t v52 = (char *)*((void *)v4 + 4);
        if ((unint64_t)v52 >= *((void *)v4 + 3))
        {
          llvm::raw_ostream::write(v4, v51);
        }
        else
        {
          *((void *)v4 + 4) = v52 + 1;
          *uint64_t v52 = v51;
        }
        BOOL v12 = v50 > 0x7F;
        v50 >>= 7;
      }
      while (v12);
      do
      {
        char v53 = v49 & 0x7F | ((v49 > 0x7F) << 7);
        uint64_t v54 = (char *)*((void *)v4 + 4);
        if ((unint64_t)v54 >= *((void *)v4 + 3))
        {
          llvm::raw_ostream::write(v4, v53);
        }
        else
        {
          *((void *)v4 + 4) = v54 + 1;
          *uint64_t v54 = v53;
        }
        BOOL v12 = v49 > 0x7F;
        v49 >>= 7;
      }
      while (v12);
      uint64_t v5 = (llvm *)llvm::sampleprof::SampleProfileWriterBinary::writeBody(this, (const llvm::sampleprof::FunctionSamples *)(v48 + 56));
      uint64_t v6 = v5;
      if (v5) {
        goto LABEL_2;
      }
      long long v55 = (char *)*((void *)v48 + 1);
      if (v55)
      {
        do
        {
          uint64_t v56 = v55;
          long long v55 = *(char **)v55;
        }
        while (v55);
      }
      else
      {
        do
        {
          uint64_t v56 = (char *)*((void *)v48 + 2);
          BOOL v36 = *(void *)v56 == (void)v48;
          long long v48 = v56;
        }
        while (!v36);
      }
      long long v48 = v56;
      if (v56 == v47 + 48) {
        goto LABEL_85;
      }
    }
  }
  while (1)
  {
    unint64_t v18 = *((unsigned int *)v16 + 8);
    unint64_t v17 = *((unsigned int *)v16 + 9);
    do
    {
      char v19 = v18 & 0x7F | ((v18 > 0x7F) << 7);
      unint64_t v20 = (char *)*((void *)v4 + 4);
      if ((unint64_t)v20 >= *((void *)v4 + 3))
      {
        llvm::raw_ostream::write(v4, v19);
      }
      else
      {
        *((void *)v4 + 4) = v20 + 1;
        *unint64_t v20 = v19;
      }
      BOOL v12 = v18 > 0x7F;
      v18 >>= 7;
    }
    while (v12);
    do
    {
      char v21 = v17 & 0x7F | ((v17 > 0x7F) << 7);
      unint64_t v22 = (char *)*((void *)v4 + 4);
      if ((unint64_t)v22 >= *((void *)v4 + 3))
      {
        llvm::raw_ostream::write(v4, v21);
      }
      else
      {
        *((void *)v4 + 4) = v22 + 1;
        char *v22 = v21;
      }
      BOOL v12 = v17 > 0x7F;
      v17 >>= 7;
    }
    while (v12);
    unint64_t v23 = *((void *)v16 + 5);
    do
    {
      char v24 = v23 & 0x7F | ((v23 > 0x7F) << 7);
      uint64_t v25 = (char *)*((void *)v4 + 4);
      if ((unint64_t)v25 >= *((void *)v4 + 3))
      {
        llvm::raw_ostream::write(v4, v24);
      }
      else
      {
        *((void *)v4 + 4) = v25 + 1;
        char *v25 = v24;
      }
      BOOL v12 = v23 > 0x7F;
      v23 >>= 7;
    }
    while (v12);
    unint64_t v26 = *((unsigned int *)v16 + 15);
    do
    {
      char v27 = v26 & 0x7F | ((v26 > 0x7F) << 7);
      long long v28 = (char *)*((void *)v4 + 4);
      if ((unint64_t)v28 >= *((void *)v4 + 3))
      {
        llvm::raw_ostream::write(v4, v27);
      }
      else
      {
        *((void *)v4 + 4) = v28 + 1;
        char *v28 = v27;
      }
      BOOL v12 = v26 > 0x7F;
      v26 >>= 7;
    }
    while (v12);
    sub_1CD68327C((uint64_t *)v16 + 6, &v59);
    unint64_t v29 = v59;
    if (v59 != v60) {
      break;
    }
LABEL_46:
    sub_1CB833A08((uint64_t)&v59, v60[0]);
    char v37 = (const llvm::sampleprof::FunctionSamples *)*((void *)v16 + 1);
    if (v37)
    {
      do
      {
        size_t v38 = v37;
        char v37 = *(const llvm::sampleprof::FunctionSamples **)v37;
      }
      while (v37);
    }
    else
    {
      do
      {
        size_t v38 = (const llvm::sampleprof::FunctionSamples *)*((void *)v16 + 2);
        BOOL v36 = *(void *)v38 == (void)v16;
        uint64_t v16 = v38;
      }
      while (!v36);
    }
    uint64_t v16 = v38;
    if (v38 == (const llvm::sampleprof::FunctionSamples *)((char *)a2 + 80)) {
      goto LABEL_52;
    }
  }
  while (1)
  {
    unint64_t v30 = (unint64_t)v29[6];
    uint64_t v31 = llvm::sampleprof::SampleProfileWriterBinary::writeNameIdx(this, v29[4], v29[5]);
    LODWORD(v6) = v31;
    if (v31) {
      break;
    }
    do
    {
      char v32 = v30 & 0x7F | ((v30 > 0x7F) << 7);
      BOOL v33 = (char *)*((void *)v4 + 4);
      if ((unint64_t)v33 >= *((void *)v4 + 3))
      {
        llvm::raw_ostream::write(v4, v32);
      }
      else
      {
        *((void *)v4 + 4) = v33 + 1;
        char *v33 = v32;
      }
      BOOL v12 = v30 > 0x7F;
      v30 >>= 7;
    }
    while (v12);
    uint64_t v34 = v29[1];
    if (v34)
    {
      do
      {
        uint64_t v35 = (void **)v34;
        uint64_t v34 = (void *)*v34;
      }
      while (v34);
    }
    else
    {
      do
      {
        uint64_t v35 = (void **)v29[2];
        BOOL v36 = *v35 == v29;
        unint64_t v29 = v35;
      }
      while (!v36);
    }
    unint64_t v29 = v35;
    if (v35 == v60) {
      goto LABEL_46;
    }
  }
  unint64_t v7 = v31 & 0xFFFFFFFF00000000;
  sub_1CB833A08((uint64_t)&v59, v60[0]);
  return v7 | v6;
}

unint64_t llvm::sampleprof::SampleProfileWriterExtBinaryBase::writeFuncOffsetTable(llvm::raw_ostream **this)
{
  __n128 v1 = (llvm::sampleprof::SampleProfileWriterExtBinaryBase *)this;
  uint64_t v2 = this[1];
  unint64_t v3 = 0xAAAAAAAAAAAAAAABLL * ((this[64] - this[63]) >> 4);
  do
  {
    char v4 = v3 & 0x7F | ((v3 > 0x7F) << 7);
    uint64_t v5 = (char *)*((void *)v2 + 4);
    if ((unint64_t)v5 >= *((void *)v2 + 3))
    {
      this = (llvm::raw_ostream **)llvm::raw_ostream::write(v2, v4);
    }
    else
    {
      *((void *)v2 + 4) = v5 + 1;
      *uint64_t v5 = v4;
    }
    BOOL v6 = v3 > 0x7F;
    v3 >>= 7;
  }
  while (v6);
  if (!llvm::sampleprof::FunctionSamples::ProfileIsCSFlat)
  {
    uint64_t v39 = *((void *)v1 + 63);
    uint64_t v40 = *((void *)v1 + 64);
    while (v39 != v40)
    {
      unint64_t v41 = *(void *)(v39 + 40);
      uint64_t v42 = (llvm *)(*(uint64_t (**)(llvm::sampleprof::SampleProfileWriterExtBinaryBase *, uint64_t))(*(void *)v1 + 112))(v1, v39);
      uint64_t v24 = v42;
      if (v42)
      {
        unint64_t v47 = (unint64_t)v42 & 0xFFFFFFFF00000000;
        return v47 | v24;
      }
      do
      {
        char v43 = v41 & 0x7F | ((v41 > 0x7F) << 7);
        uint64_t v44 = (char *)*((void *)v2 + 4);
        if ((unint64_t)v44 >= *((void *)v2 + 3))
        {
          uint64_t v42 = llvm::raw_ostream::write(v2, v43);
        }
        else
        {
          *((void *)v2 + 4) = v44 + 1;
          *uint64_t v44 = v43;
        }
        BOOL v6 = v41 > 0x7F;
        v41 >>= 7;
      }
      while (v6);
      this = (llvm::raw_ostream **)llvm::sampleprof_category(v42);
      v39 += 48;
    }
    goto LABEL_51;
  }
  uint64_t v7 = *((void *)v1 + 63);
  uint64_t v8 = *((void *)v1 + 64);
  uint64_t v54 = 0;
  uint64_t v55 = 0;
  char v53 = &v54;
  if (v7 == v8)
  {
LABEL_45:
    uint64_t v29 = *((unsigned int *)v1 + 24);
    if (v29)
    {
      uint64_t v30 = 40 * v29;
      uint64_t v31 = (void *)(*((void *)v1 + 11) + 8);
      do
      {
        if (*((_DWORD *)v31 - 2) == 4) {
          *v31 |= 0x100000000uLL;
        }
        v31 += 5;
        v30 -= 40;
      }
      while (v30);
    }
    sub_1CBB0D544(v54);
LABEL_51:
    int v32 = *((_DWORD *)v1 + 122);
    if (v32 || *((_DWORD *)v1 + 123))
    {
      BOOL v33 = (void *)((char *)v1 + 480);
      uint64_t v34 = *((unsigned int *)v1 + 124);
      if (v34 <= 4 * v32 || v34 < 0x41)
      {
        if (v34)
        {
          uint64_t v45 = *v33;
          uint64_t v46 = 48 * v34;
          do
          {
            *(void *)(v45 + 32) = 0;
            *(_OWORD *)uint64_t v45 = 0uLL;
            *(_OWORD *)(v45 + 16) = 0uLL;
            v45 += 48;
            v46 -= 48;
          }
          while (v46);
        }
        *((void *)v1 + 6llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = 0;
      }
      else
      {
        this = (llvm::raw_ostream **)sub_1CD759598((uint64_t)v1 + 480);
        int v35 = 1 << (33 - __clz(v32 - 1));
        if (v35 <= 64) {
          int v35 = 64;
        }
        if (v32) {
          uint64_t v36 = v35;
        }
        else {
          uint64_t v36 = 0;
        }
        if (v36 == *((_DWORD *)v1 + 124))
        {
          *((void *)v1 + 6llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = 0;
          if (v36)
          {
            uint64_t v37 = *((void *)v1 + 60);
            uint64_t v38 = 48 * v36;
            do
            {
              *(void *)(v37 + 32) = 0;
              *(_OWORD *)uint64_t v37 = 0uLL;
              *(_OWORD *)(v37 + 16) = 0uLL;
              v37 += 48;
              v38 -= 48;
            }
            while (v38);
          }
        }
        else
        {
          this = (llvm::raw_ostream **)MEMORY[0x1D25D9CD0](*v33, 8);
          if (v36)
          {
            unint64_t v49 = (4 * (int)v36 / 3u + 1) | ((unint64_t)(4 * (int)v36 / 3u + 1) >> 1);
            unint64_t v50 = v49 | (v49 >> 2) | ((v49 | (v49 >> 2)) >> 4);
            LODWORD(v50) = (((v50 | (v50 >> 8)) >> 16) | v50 | (v50 >> 8)) + 1;
            *((_DWORD *)v1 + 124) = v50;
            this = (llvm::raw_ostream **)operator new(48 * v50, (std::align_val_t)8uLL);
            *((void *)v1 + 60) = this;
            *((void *)v1 + 6llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = 0;
            uint64_t v51 = *((unsigned int *)v1 + 124);
            if (v51)
            {
              uint64_t v52 = 48 * v51;
              do
              {
                this[4] = 0;
                *(_OWORD *)this = 0uLL;
                *((_OWORD *)this + llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = 0uLL;
                this += 6;
                v52 -= 48;
              }
              while (v52);
            }
          }
          else
          {
            void *v33 = 0;
            *((void *)v1 + 6llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = 0;
            *((_DWORD *)v1 + 124) = 0;
          }
        }
      }
    }
    *((void *)v1 + 64) = *((void *)v1 + 63);
    llvm::sampleprof_category((llvm *)this);
    uint64_t v24 = 0;
    unint64_t v47 = 0;
    return v47 | v24;
  }
  for (uint64_t i = 0; ; uint64_t i = v54)
  {
    if (v53 == &v54)
    {
      char v10 = &v54;
LABEL_11:
      uint64_t v11 = &v54;
      BOOL v12 = &v54;
      if (i)
      {
        BOOL v12 = v10 + 1;
        uint64_t v11 = v10;
        goto LABEL_13;
      }
      goto LABEL_14;
    }
    unint64_t v17 = &v54;
    if (i)
    {
      do
      {
        char v10 = (uint64_t **)i;
        uint64_t i = (uint64_t *)i[1];
      }
      while (i);
    }
    else
    {
      do
      {
        char v10 = (uint64_t **)v17[2];
        BOOL v18 = *v10 == (uint64_t *)v17;
        unint64_t v17 = v10;
      }
      while (v18);
    }
    BOOL v19 = sub_1CD67ED6C((uint64_t)(v10 + 4), v7);
    uint64_t i = v54;
    if (v19) {
      goto LABEL_11;
    }
    uint64_t v11 = &v54;
    BOOL v12 = &v54;
    if (v54)
    {
      BOOL v12 = &v54;
      while (1)
      {
        while (1)
        {
          uint64_t v11 = (uint64_t **)i;
          uint64_t v20 = (uint64_t)(i + 4);
          if (!sub_1CD67ED6C(v7, (uint64_t)(i + 4))) {
            break;
          }
          uint64_t i = *v11;
          BOOL v12 = v11;
          if (!*v11) {
            goto LABEL_14;
          }
        }
        if (!sub_1CD67ED6C(v20, v7)) {
          break;
        }
        BOOL v12 = v11 + 1;
        uint64_t i = v11[1];
        if (!i) {
          goto LABEL_14;
        }
      }
LABEL_13:
      if (*v12) {
        goto LABEL_18;
      }
    }
LABEL_14:
    unint64_t v13 = operator new(0x50uLL);
    uint64_t v14 = *(void *)(v7 + 32);
    long long v15 = *(_OWORD *)(v7 + 16);
    uint64_t v13[2] = *(_OWORD *)v7;
    void v13[3] = v15;
    *((void *)v13 + 8) = v14;
    *((void *)v13 + 9) = *(void *)(v7 + 40);
    *(void *)unint64_t v13 = 0;
    *((void *)v13 + llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = 0;
    *((void *)v13 + 2) = v11;
    *BOOL v12 = (uint64_t *)v13;
    if (*v53)
    {
      char v53 = (uint64_t **)*v53;
      uint64_t v16 = *v12;
    }
    else
    {
      uint64_t v16 = (uint64_t *)v13;
    }
    sub_1CB8358B8(v54, v16);
    ++v55;
LABEL_18:
    v7 += 48;
    if (v7 == v8) {
      break;
    }
  }
  char v21 = (uint64_t *)v53;
  if (v53 == &v54) {
    goto LABEL_45;
  }
  while (1)
  {
    unint64_t v22 = v21[9];
    unint64_t v23 = (llvm *)(*(uint64_t (**)(llvm::sampleprof::SampleProfileWriterExtBinaryBase *, uint64_t *))(*(void *)v1 + 112))(v1, v21 + 4);
    uint64_t v24 = v23;
    if (v23) {
      break;
    }
    do
    {
      char v25 = v22 & 0x7F | ((v22 > 0x7F) << 7);
      unint64_t v26 = (char *)*((void *)v2 + 4);
      if ((unint64_t)v26 >= *((void *)v2 + 3))
      {
        unint64_t v23 = llvm::raw_ostream::write(v2, v25);
      }
      else
      {
        *((void *)v2 + 4) = v26 + 1;
        *unint64_t v26 = v25;
      }
      BOOL v6 = v22 > 0x7F;
      v22 >>= 7;
    }
    while (v6);
    llvm::sampleprof_category(v23);
    char v27 = (uint64_t *)v21[1];
    if (v27)
    {
      do
      {
        long long v28 = (uint64_t **)v27;
        char v27 = (uint64_t *)*v27;
      }
      while (v27);
    }
    else
    {
      do
      {
        long long v28 = (uint64_t **)v21[2];
        BOOL v18 = *v28 == v21;
        char v21 = (uint64_t *)v28;
      }
      while (!v18);
    }
    char v21 = (uint64_t *)v28;
    if (v28 == &v54) {
      goto LABEL_45;
    }
  }
  unint64_t v47 = (unint64_t)v23 & 0xFFFFFFFF00000000;
  sub_1CBB0D544(v54);
  return v47 | v24;
}

unint64_t llvm::sampleprof::SampleProfileWriterExtBinaryBase::writeFuncMetadata(llvm::sampleprof::SampleProfileWriterExtBinaryBase *this, const llvm::sampleprof::FunctionSamples *a2)
{
  char v4 = (llvm::raw_ostream *)*((void *)this + 1);
  unint64_t v5 = (*(uint64_t (**)(llvm::sampleprof::SampleProfileWriterExtBinaryBase *, char *))(*(void *)this + 112))(this, (char *)a2 + 16);
  if (!v5)
  {
    if (llvm::sampleprof::FunctionSamples::ProfileIsProbeBased)
    {
      unint64_t v7 = *((void *)a2 + 1);
      do
      {
        char v8 = v7 & 0x7F | ((v7 > 0x7F) << 7);
        unint64_t v9 = (char *)*((void *)v4 + 4);
        if ((unint64_t)v9 >= *((void *)v4 + 3))
        {
          unint64_t v5 = (unint64_t)llvm::raw_ostream::write(v4, v8);
        }
        else
        {
          *((void *)v4 + 4) = v9 + 1;
          char *v9 = v8;
        }
        BOOL v10 = v7 > 0x7F;
        v7 >>= 7;
      }
      while (v10);
    }
    if (llvm::sampleprof::FunctionSamples::ProfileIsCSFlat | llvm::sampleprof::FunctionSamples::ProfileIsCSNested)
    {
      unint64_t v11 = *((unsigned int *)a2 + 13);
      do
      {
        char v12 = v11 & 0x7F | ((v11 > 0x7F) << 7);
        unint64_t v13 = (char *)*((void *)v4 + 4);
        if ((unint64_t)v13 >= *((void *)v4 + 3))
        {
          unint64_t v5 = (unint64_t)llvm::raw_ostream::write(v4, v12);
        }
        else
        {
          *((void *)v4 + 4) = v13 + 1;
          char *v13 = v12;
        }
        BOOL v10 = v11 > 0x7F;
        v11 >>= 7;
      }
      while (v10);
      if (llvm::sampleprof::FunctionSamples::ProfileIsCSFlat) {
        goto LABEL_54;
      }
    }
    uint64_t v14 = (char *)*((void *)a2 + 12);
    long long v15 = (char *)a2 + 104;
    if (v14 == (char *)a2 + 104)
    {
      unint64_t v16 = 0;
    }
    else
    {
      unint64_t v16 = 0;
      do
      {
        unint64_t v17 = (char *)*((void *)v14 + 1);
        BOOL v18 = v14;
        if (v17)
        {
          do
          {
            BOOL v19 = v17;
            unint64_t v17 = *(char **)v17;
          }
          while (v17);
        }
        else
        {
          do
          {
            BOOL v19 = (char *)*((void *)v18 + 2);
            BOOL v20 = *(void *)v19 == (void)v18;
            BOOL v18 = v19;
          }
          while (!v20);
        }
        v16 += *((void *)v14 + 7);
        uint64_t v14 = v19;
      }
      while (v19 != v15);
    }
    do
    {
      char v21 = v16 & 0x7F | ((v16 > 0x7F) << 7);
      unint64_t v22 = (char *)*((void *)v4 + 4);
      if ((unint64_t)v22 >= *((void *)v4 + 3))
      {
        unint64_t v5 = (unint64_t)llvm::raw_ostream::write(v4, v21);
      }
      else
      {
        *((void *)v4 + 4) = v22 + 1;
        char *v22 = v21;
      }
      BOOL v10 = v16 > 0x7F;
      v16 >>= 7;
    }
    while (v10);
    unint64_t v23 = (char *)*((void *)a2 + 12);
    if (v23 == v15)
    {
LABEL_54:
      llvm::sampleprof_category((llvm *)v5);
      LODWORD(v5) = 0;
      unint64_t v6 = 0;
      return v6 | v5;
    }
    while (1)
    {
      uint64_t v24 = (char *)*((void *)v23 + 5);
      if (v24 != v23 + 48) {
        break;
      }
LABEL_48:
      BOOL v33 = (char *)*((void *)v23 + 1);
      if (v33)
      {
        do
        {
          uint64_t v34 = v33;
          BOOL v33 = *(char **)v33;
        }
        while (v33);
      }
      else
      {
        do
        {
          uint64_t v34 = (char *)*((void *)v23 + 2);
          BOOL v20 = *(void *)v34 == (void)v23;
          unint64_t v23 = v34;
        }
        while (!v20);
      }
      unint64_t v23 = v34;
      if (v34 == v15) {
        goto LABEL_54;
      }
    }
    while (1)
    {
      unint64_t v26 = *((unsigned int *)v23 + 8);
      unint64_t v25 = *((unsigned int *)v23 + 9);
      do
      {
        char v27 = v26 & 0x7F | ((v26 > 0x7F) << 7);
        long long v28 = (char *)*((void *)v4 + 4);
        if ((unint64_t)v28 >= *((void *)v4 + 3))
        {
          llvm::raw_ostream::write(v4, v27);
        }
        else
        {
          *((void *)v4 + 4) = v28 + 1;
          char *v28 = v27;
        }
        BOOL v10 = v26 > 0x7F;
        v26 >>= 7;
      }
      while (v10);
      do
      {
        char v29 = v25 & 0x7F | ((v25 > 0x7F) << 7);
        uint64_t v30 = (char *)*((void *)v4 + 4);
        if ((unint64_t)v30 >= *((void *)v4 + 3))
        {
          llvm::raw_ostream::write(v4, v29);
        }
        else
        {
          *((void *)v4 + 4) = v30 + 1;
          char *v30 = v29;
        }
        BOOL v10 = v25 > 0x7F;
        v25 >>= 7;
      }
      while (v10);
      unint64_t v5 = llvm::sampleprof::SampleProfileWriterExtBinaryBase::writeFuncMetadata(this, (const llvm::sampleprof::FunctionSamples *)(v24 + 56));
      if (v5) {
        break;
      }
      uint64_t v31 = (char *)*((void *)v24 + 1);
      if (v31)
      {
        do
        {
          int v32 = v31;
          uint64_t v31 = *(char **)v31;
        }
        while (v31);
      }
      else
      {
        do
        {
          int v32 = (char *)*((void *)v24 + 2);
          BOOL v20 = *(void *)v32 == (void)v24;
          uint64_t v24 = v32;
        }
        while (!v20);
      }
      uint64_t v24 = v32;
      if (v32 == v23 + 48) {
        goto LABEL_48;
      }
    }
  }
  unint64_t v6 = v5 & 0xFFFFFFFF00000000;
  return v6 | v5;
}

unint64_t llvm::sampleprof::SampleProfileWriterExtBinaryBase::writeFuncMetadata(unint64_t this, uint64_t a2)
{
  if (llvm::sampleprof::FunctionSamples::ProfileIsProbeBased) {
    BOOL v2 = 0;
  }
  else {
    BOOL v2 = llvm::sampleprof::FunctionSamples::ProfileIsCSFlat == 0;
  }
  if (!v2 || llvm::sampleprof::FunctionSamples::ProfileIsCSNested != 0)
  {
    char v4 = (llvm::sampleprof::SampleProfileWriterExtBinaryBase *)this;
    unint64_t v5 = (void *)(a2 + 16);
    while (1)
    {
      unint64_t v5 = (void *)*v5;
      if (!v5) {
        break;
      }
      this = llvm::sampleprof::SampleProfileWriterExtBinaryBase::writeFuncMetadata(v4, (const llvm::sampleprof::FunctionSamples *)(v5 + 7));
      uint64_t v6 = this;
      if (this)
      {
        unint64_t v7 = this & 0xFFFFFFFF00000000;
        return v6 | v7;
      }
    }
  }
  llvm::sampleprof_category((llvm *)this);
  unint64_t v7 = 0;
  uint64_t v6 = 0;
  return v6 | v7;
}

uint64_t llvm::sampleprof::SampleProfileWriterExtBinaryBase::writeNameTable(llvm::raw_ostream **this)
{
  __n128 v1 = this;
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (!*((unsigned char *)this + 528)) {
    return llvm::sampleprof::SampleProfileWriterBinary::writeNameTable(this);
  }
  BOOL v2 = this[1];
  v21[0] = 0;
  v21[1] = 0;
  BOOL v20 = (long long *)v21;
  unint64_t v3 = this[7];
  char v4 = this[8];
  if (v3 != v4)
  {
    do
    {
      this = (llvm::raw_ostream **)sub_1CD69C5D0((uint64_t)&v20, (uint64_t)v3, v3);
      unint64_t v3 = (llvm::raw_ostream *)((char *)v3 + 24);
    }
    while (v3 != v4);
    unint64_t v5 = v20;
    if (v20 != (long long *)v21)
    {
      int v6 = 0;
      do
      {
        this = (llvm::raw_ostream **)sub_1CCCFD864(v1 + 4, v5 + 2);
        *(_DWORD *)this = v6;
        unint64_t v7 = (long long *)*((void *)v5 + 1);
        if (v7)
        {
          do
          {
            char v8 = v7;
            unint64_t v7 = *(long long **)v7;
          }
          while (v7);
        }
        else
        {
          do
          {
            char v8 = (long long *)*((void *)v5 + 2);
            BOOL v9 = *(void *)v8 == (void)v5;
            unint64_t v5 = v8;
          }
          while (!v9);
        }
        ++v6;
        unint64_t v5 = v8;
      }
      while (v8 != (long long *)v21);
    }
  }
  unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v1[8] - v1[7]) >> 3);
  do
  {
    char v11 = v10 & 0x7F | ((v10 > 0x7F) << 7);
    char v12 = (char *)*((void *)v2 + 4);
    if ((unint64_t)v12 >= *((void *)v2 + 3))
    {
      this = (llvm::raw_ostream **)llvm::raw_ostream::write(v2, v11);
    }
    else
    {
      *((void *)v2 + 4) = v12 + 1;
      *char v12 = v11;
    }
    BOOL v13 = v10 > 0x7F;
    v10 >>= 7;
  }
  while (v13);
  uint64_t v14 = v20;
  if (v20 != (long long *)v21)
  {
    do
    {
      long long v15 = (int *)*((void *)v14 + 4);
      size_t v16 = *((void *)v14 + 5);
      *(_OWORD *)unint64_t v23 = xmmword_1CFAC4320;
      uint64_t v24 = 0;
      llvm::MD5::update((int *)v23, v15, v16);
      llvm::MD5::final((int *)v23, (int *)&v22);
      *(void *)unint64_t v23 = v22;
      this = (llvm::raw_ostream **)llvm::raw_ostream::write(v2, v23, 8uLL);
      unint64_t v17 = (long long *)*((void *)v14 + 1);
      if (v17)
      {
        do
        {
          BOOL v18 = v17;
          unint64_t v17 = *(long long **)v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          BOOL v18 = (long long *)*((void *)v14 + 2);
          BOOL v9 = *(void *)v18 == (void)v14;
          uint64_t v14 = v18;
        }
        while (!v9);
      }
      uint64_t v14 = v18;
    }
    while (v18 != (long long *)v21);
  }
  llvm::sampleprof_category((llvm *)this);
  sub_1CB833A08((uint64_t)&v20, v21[0]);
  return 0;
}

uint64_t llvm::sampleprof::SampleProfileWriterBinary::writeNameTable(llvm::raw_ostream **this)
{
  __n128 v1 = (llvm::sampleprof::SampleProfileWriterBinary *)this;
  BOOL v2 = this[1];
  v21[0] = 0;
  v21[1] = 0;
  BOOL v20 = (long long *)v21;
  unint64_t v3 = this[7];
  char v4 = this[8];
  if (v3 != v4)
  {
    do
    {
      this = (llvm::raw_ostream **)sub_1CD69C5D0((uint64_t)&v20, (uint64_t)v3, v3);
      unint64_t v3 = (llvm::raw_ostream *)((char *)v3 + 24);
    }
    while (v3 != v4);
    unint64_t v5 = v20;
    if (v20 != (long long *)v21)
    {
      int v6 = 0;
      do
      {
        this = (llvm::raw_ostream **)sub_1CCCFD864((void *)v1 + 4, v5 + 2);
        *(_DWORD *)this = v6;
        unint64_t v7 = (long long *)*((void *)v5 + 1);
        if (v7)
        {
          do
          {
            char v8 = v7;
            unint64_t v7 = *(long long **)v7;
          }
          while (v7);
        }
        else
        {
          do
          {
            char v8 = (long long *)*((void *)v5 + 2);
            BOOL v9 = *(void *)v8 == (void)v5;
            unint64_t v5 = v8;
          }
          while (!v9);
        }
        ++v6;
        unint64_t v5 = v8;
      }
      while (v8 != (long long *)v21);
    }
  }
  unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)v1 + 8) - *((void *)v1 + 7)) >> 3);
  do
  {
    char v11 = v10 & 0x7F | ((v10 > 0x7F) << 7);
    char v12 = (char *)*((void *)v2 + 4);
    if ((unint64_t)v12 >= *((void *)v2 + 3))
    {
      this = (llvm::raw_ostream **)llvm::raw_ostream::write(v2, v11);
    }
    else
    {
      *((void *)v2 + 4) = v12 + 1;
      *char v12 = v11;
    }
    BOOL v13 = v10 > 0x7F;
    v10 >>= 7;
  }
  while (v13);
  uint64_t v14 = v20;
  if (v20 != (long long *)v21)
  {
    do
    {
      long long v15 = (const void *)*((void *)v14 + 4);
      unint64_t v16 = *((void *)v14 + 5);
      this = (llvm::raw_ostream **)*((void *)v2 + 4);
      if (v16 <= *((void *)v2 + 3) - (void)this)
      {
        if (v16)
        {
          memcpy(this, v15, *((void *)v14 + 5));
          this = (llvm::raw_ostream **)(*((void *)v2 + 4) + v16);
          *((void *)v2 + 4) = this;
        }
      }
      else
      {
        llvm::raw_ostream::write(v2, (const char *)v15, *((void *)v14 + 5));
        this = (llvm::raw_ostream **)*((void *)v2 + 4);
      }
      if ((unint64_t)this >= *((void *)v2 + 3))
      {
        this = (llvm::raw_ostream **)llvm::raw_ostream::write(v2, 0);
      }
      else
      {
        *((void *)v2 + 4) = (char *)this + 1;
        *(unsigned char *)this = 0;
      }
      unint64_t v17 = (long long *)*((void *)v14 + 1);
      if (v17)
      {
        do
        {
          BOOL v18 = v17;
          unint64_t v17 = *(long long **)v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          BOOL v18 = (long long *)*((void *)v14 + 2);
          BOOL v9 = *(void *)v18 == (void)v14;
          uint64_t v14 = v18;
        }
        while (!v9);
      }
      uint64_t v14 = v18;
    }
    while (v18 != (long long *)v21);
  }
  llvm::sampleprof_category((llvm *)this);
  sub_1CB833A08((uint64_t)&v20, v21[0]);
  return 0;
}

unint64_t llvm::sampleprof::SampleProfileWriterExtBinaryBase::writeNameTableSection(uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void **)(a2 + 16); i; uint64_t i = (void *)*i)
  {
    (*(void (**)(uint64_t, void *))(*(void *)a1 + 120))(a1, i + 9);
    llvm::sampleprof::SampleProfileWriterBinary::addNames((llvm::sampleprof::SampleProfileWriterBinary *)a1, (const llvm::sampleprof::FunctionSamples *)(i + 7));
  }
  char v4 = *(uint64_t **)(a1 + 56);
  unint64_t v5 = *(uint64_t **)(a1 + 64);
  if (v4 != v5)
  {
    while (llvm::StringRef::find(v4, ".__uniq.", 8uLL, 0) == -1)
    {
      v4 += 3;
      if (v4 == v5) {
        goto LABEL_12;
      }
    }
    uint64_t v6 = *(unsigned int *)(a1 + 96);
    if (v6)
    {
      uint64_t v7 = 40 * v6;
      char v8 = (void *)(*(void *)(a1 + 88) + 8);
      do
      {
        if (*((_DWORD *)v8 - 2) == 2) {
          *v8 |= 0x400000000uLL;
        }
        v8 += 5;
        v7 -= 40;
      }
      while (v7);
    }
  }
LABEL_12:
  unint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 104))(a1);
  if (v9)
  {
    unint64_t v10 = v9 & 0xFFFFFFFF00000000;
  }
  else
  {
    llvm::sampleprof_category((llvm *)v9);
    LODWORD(v9) = 0;
    unint64_t v10 = 0;
  }
  return v10 | v9;
}

llvm::sampleprof::SampleProfileWriterBinary *llvm::sampleprof::SampleProfileWriterBinary::addNames(llvm::sampleprof::SampleProfileWriterBinary *this, const llvm::sampleprof::FunctionSamples *a2)
{
  unint64_t v3 = this;
  char v4 = (char *)*((void *)a2 + 9);
  unint64_t v5 = (char *)a2 + 80;
  if (v4 != (char *)a2 + 80)
  {
    do
    {
      uint64_t v6 = *((unsigned int *)v4 + 14);
      if (v6)
      {
        for (uint64_t i = (uint64_t **)*((void *)v4 + 6); ; ++i)
        {
          BOOL v8 = !*i || *i + 1 == 0;
          if (!v8) {
            break;
          }
        }
      }
      else
      {
        uint64_t i = (uint64_t **)*((void *)v4 + 6);
      }
      uint64_t v9 = *((void *)v4 + 6) + 8 * v6;
      if (i != (uint64_t **)v9)
      {
        unint64_t v10 = *i;
        do
        {
          uint64_t v11 = *v10;
          char v12 = (void *)(*(uint64_t (**)(llvm::sampleprof::SampleProfileWriterBinary *))(*(void *)v3 + 88))(v3);
          *(void *)&long long v26 = v10 + 2;
          *((void *)&v26 + llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = v11;
          int v27 = 0;
          this = (llvm::sampleprof::SampleProfileWriterBinary *)sub_1CD75A1E0(v12, &v26, &v27);
          do
          {
            BOOL v13 = i[1];
            ++i;
            unint64_t v10 = v13;
            if (v13) {
              BOOL v14 = v10 + 1 == 0;
            }
            else {
              BOOL v14 = 1;
            }
          }
          while (v14);
        }
        while (i != (uint64_t **)v9);
      }
      long long v15 = (char *)*((void *)v4 + 1);
      if (v15)
      {
        do
        {
          unint64_t v16 = v15;
          long long v15 = *(char **)v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          unint64_t v16 = (char *)*((void *)v4 + 2);
          BOOL v8 = *(void *)v16 == (void)v4;
          char v4 = v16;
        }
        while (!v8);
      }
      char v4 = v16;
    }
    while (v16 != v5);
  }
  unint64_t v17 = (const llvm::sampleprof::FunctionSamples *)*((void *)a2 + 12);
  if (v17 != (const llvm::sampleprof::FunctionSamples *)((char *)a2 + 104))
  {
    do
    {
      BOOL v18 = (void *)*((void *)v17 + 5);
      if (v18 != (void *)((char *)v17 + 48))
      {
        do
        {
          uint64_t v19 = v18[9];
          uint64_t v20 = v18[10];
          char v21 = (void *)(*(uint64_t (**)(llvm::sampleprof::SampleProfileWriterBinary *))(*(void *)v3 + 88))(v3);
          *(void *)&long long v26 = v19;
          *((void *)&v26 + llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = v20;
          int v27 = 0;
          sub_1CD75A1E0(v21, &v26, &v27);
          this = (llvm::sampleprof::SampleProfileWriterBinary *)llvm::sampleprof::SampleProfileWriterBinary::addNames(v3, (const llvm::sampleprof::FunctionSamples *)(v18 + 7));
          uint64_t v22 = (void *)v18[1];
          if (v22)
          {
            do
            {
              unint64_t v23 = v22;
              uint64_t v22 = (void *)*v22;
            }
            while (v22);
          }
          else
          {
            do
            {
              unint64_t v23 = (void *)v18[2];
              BOOL v8 = *v23 == (void)v18;
              BOOL v18 = v23;
            }
            while (!v8);
          }
          BOOL v18 = v23;
        }
        while (v23 != (void *)((char *)v17 + 48));
      }
      uint64_t v24 = (const llvm::sampleprof::FunctionSamples *)*((void *)v17 + 1);
      if (v24)
      {
        do
        {
          uint64_t v25 = v24;
          uint64_t v24 = *(const llvm::sampleprof::FunctionSamples **)v24;
        }
        while (v24);
      }
      else
      {
        do
        {
          uint64_t v25 = (const llvm::sampleprof::FunctionSamples *)*((void *)v17 + 2);
          BOOL v8 = *(void *)v25 == (void)v17;
          unint64_t v17 = v25;
        }
        while (!v8);
      }
      unint64_t v17 = v25;
    }
    while (v25 != (const llvm::sampleprof::FunctionSamples *)((char *)a2 + 104));
  }
  return this;
}

unint64_t llvm::sampleprof::SampleProfileWriterExtBinaryBase::writeCSNameTableSection(unint64_t this)
{
  __n128 v1 = (void *)this;
  BOOL v63 = 0;
  unint64_t v64 = 0;
  long long v62 = &v63;
  uint64_t v2 = *(void *)(this + 560);
  uint64_t v3 = *(void *)(this + 568);
  if (v2 != v3)
  {
    char v4 = (char *)(this + 536);
    do
    {
      unint64_t v5 = v63;
      uint64_t v6 = &v63;
      uint64_t v7 = &v63;
      if (!v63) {
        goto LABEL_10;
      }
      uint64_t v6 = &v63;
      while (1)
      {
        while (1)
        {
          uint64_t v7 = (uint64_t **)v5;
          uint64_t v8 = (uint64_t)(v5 + 4);
          if (!sub_1CD67ED6C(v2, (uint64_t)(v5 + 4))) {
            break;
          }
          unint64_t v5 = *v7;
          uint64_t v6 = v7;
          if (!*v7) {
            goto LABEL_10;
          }
        }
        this = sub_1CD67ED6C(v8, v2);
        if (!this) {
          break;
        }
        uint64_t v6 = v7 + 1;
        unint64_t v5 = v7[1];
        if (!v5) {
          goto LABEL_10;
        }
      }
      if (!*v6)
      {
LABEL_10:
        uint64_t v9 = operator new(0x48uLL);
        uint64_t v10 = *(void *)(v2 + 32);
        long long v11 = *(_OWORD *)(v2 + 16);
        void v9[2] = *(_OWORD *)v2;
        void v9[3] = v11;
        *((void *)v9 + 8) = v10;
        *(void *)uint64_t v9 = 0;
        *((void *)v9 + llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = 0;
        *((void *)v9 + 2) = v7;
        *uint64_t v6 = (uint64_t *)v9;
        if (*v62)
        {
          long long v62 = (uint64_t **)*v62;
          char v12 = *v6;
        }
        else
        {
          char v12 = (uint64_t *)v9;
        }
        this = (unint64_t)sub_1CB8358B8(v63, v12);
        ++v64;
      }
      v2 += 48;
    }
    while (v2 != v3);
    BOOL v13 = v62;
    if (v62 != &v63)
    {
      int v14 = 0;
      do
      {
        long long v15 = *((_OWORD *)v13 + 3);
        v67[0] = *((_OWORD *)v13 + 2);
        v67[1] = v15;
        uint64_t v68 = v13[8];
        int v69 = 0;
        this = sub_1CCCFDE6C((uint64_t)&v65, (uint64_t)v4, (uint64_t)v67, &v69);
        uint64_t v16 = v65;
        if (v66)
        {
          unint64_t v17 = (long long *)(v13 + 4);
          BOOL v18 = (char *)v1[71];
          unint64_t v19 = v1[72];
          if ((unint64_t)v18 >= v19)
          {
            uint64_t v25 = (char *)v1[70];
            unint64_t v26 = 0xAAAAAAAAAAAAAAABLL * ((v18 - v25) >> 4) + 1;
            if (v26 > 0x555555555555555) {
              abort();
            }
            unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v19 - (void)v25) >> 4);
            if (2 * v27 > v26) {
              unint64_t v26 = 2 * v27;
            }
            if (v27 >= 0x2AAAAAAAAAAAAAALL) {
              unint64_t v28 = 0x555555555555555;
            }
            else {
              unint64_t v28 = v26;
            }
            if (v28)
            {
              if (v28 > 0x555555555555555) {
                sub_1CB833614();
              }
              this = (unint64_t)operator new(48 * v28);
            }
            else
            {
              this = 0;
            }
            char v29 = (char *)(this + 16 * ((v18 - v25) >> 4));
            long long v30 = *v17;
            long long v31 = *((_OWORD *)v13 + 3);
            *((void *)v29 + 4) = v13[8];
            *(_OWORD *)char v29 = v30;
            *((_OWORD *)v29 + llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = v31;
            *((_DWORD *)v29 + 10) = 0;
            int v32 = v29;
            if (v18 != v25)
            {
              do
              {
                long long v33 = *((_OWORD *)v18 - 3);
                long long v34 = *((_OWORD *)v18 - 1);
                *((_OWORD *)v32 - 2) = *((_OWORD *)v18 - 2);
                *((_OWORD *)v32 - llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = v34;
                *((_OWORD *)v32 - 3) = v33;
                v32 -= 48;
                v18 -= 48;
              }
              while (v18 != v25);
              BOOL v18 = (char *)v1[70];
            }
            int v35 = (char *)(this + 48 * v28);
            v1[70] = v32;
            uint64_t v22 = v29 + 48;
            v1[71] = v29 + 48;
            v1[72] = v35;
            char v4 = (char *)(v1 + 67);
            if (v18) {
              operator delete(v18);
            }
          }
          else
          {
            long long v20 = *v17;
            long long v21 = *((_OWORD *)v13 + 3);
            *((void *)v18 + 4) = v13[8];
            *(_OWORD *)BOOL v18 = v20;
            *((_OWORD *)v18 + llvm::sampleprof::CSProfileConverter::convertProfiles((uint64_t *)this, (void *)this + 1) = v21;
            *((_DWORD *)v18 + 10) = 0;
            uint64_t v22 = v18 + 48;
          }
          v1[71] = v22;
          uint64_t v24 = v1[70];
          unsigned int v23 = -1 - 1431655765 * ((unint64_t)&v22[-v24] >> 4);
          *(_DWORD *)(v16 + 40) = v23;
        }
        else
        {
          unsigned int v23 = *(_DWORD *)(v65 + 40);
          uint64_t v24 = v1[70];
        }
        *(_DWORD *)(v24 + 48 * v23 + 40) = v14;
        uint64_t v36 = v13[1];
        if (v36)
        {
          do
          {
            uint64_t v37 = (uint64_t **)v36;
            uint64_t v36 = (uint64_t *)*v36;
          }
          while (v36);
        }
        else
        {
          do
          {
            uint64_t v37 = (uint64_t **)v13[2];
            BOOL v38 = *v37 == (uint64_t *)v13;
            BOOL v13 = v37;
          }
          while (!v38);
        }
        ++v14;
        BOOL v13 = v37;
      }
      while (v37 != &v63);
    }
  }
  uint64_t v39 = (llvm::raw_ostream *)v1[1];
  unint64_t v40 = v64;
  do
  {
    char v41 = v40 & 0x7F | ((v40 > 0x7F) << 7);
    uint64_t v42 = (char *)*((void *)v39 + 4);
    if ((unint64_t)v42 >= *((void *)v39 + 3))
    {
      this = (unint64_t)llvm::raw_ostream::write(v39, v41);
    }
    else
    {
      *((void *)v39 + 4) = v42 + 1;
      *uint64_t v42 = v41;
    }
    BOOL v43 = v40 > 0x7F;
    v40 >>= 7;
  }
  while (v43);
  uint64_t v44 = (uint64_t *)v62;
  if (v62 == &v63)
  {
LABEL_77:
    llvm::sampleprof_category((llvm *)this);
    uint64_t v51 = 0;
    unint64_t v60 = 0;
  }
  else
  {
    while (1)
    {
      uint64_t v46 = v44[6];
      unint64_t v45 = v44[7];
      unint64_t v47 = v45;
      do
      {
        char v48 = v47 & 0x7F | ((v47 > 0x7F) << 7);
        unint64_t v49 = (char *)*((void *)v39 + 4);
        if ((unint64_t)v49 >= *((void *)v39 + 3))
        {
          this = (unint64_t)llvm::raw_ostream::write(v39, v48);
        }
        else
        {
          *((void *)v39 + 4) = v49 + 1;
          *unint64_t v49 = v48;
        }
        BOOL v43 = v47 > 0x7F;
        v47 >>= 7;
      }
      while (v43);
      if (v45) {
        break;
      }
LABEL_71:
      uint64_t v58 = (uint64_t *)v44[1];
      if (v58)
      {
        do
        {
          unint64_t v59 = (uint64_t **)v58;
          uint64_t v58 = (uint64_t *)*v58;
        }
        while (v58);
      }
      else
      {
        do
        {
          unint64_t v59 = (uint64_t **)v44[2];
          BOOL v38 = *v59 == v44;
          uint64_t v44 = (uint64_t *)v59;
        }
        while (!v38);
      }
      uint64_t v44 = (uint64_t *)v59;
      if (v59 == &v63) {
        goto LABEL_77;
      }
    }
    unint64_t v50 = v46 + 24 * v45;
    while (1)
    {
      this = llvm::sampleprof::SampleProfileWriterBinary::writeNameIdx(v1, *(const void **)v46, *(const void **)(v46 + 8));
      uint64_t v51 = this;
      if (this) {
        break;
      }
      unint64_t v52 = *(unsigned int *)(v46 + 16);
      do
      {
        char v53 = v52 & 0x7F | ((v52 > 0x7F) << 7);
        uint64_t v54 = (char *)*((void *)v39 + 4);
        if ((unint64_t)v54 >= *((void *)v39 + 3))
        {
          this = (unint64_t)llvm::raw_ostream::write(v39, v53);
        }
        else
        {
          *((void *)v39 + 4) = v54 + 1;
          *uint64_t v54 = v53;
        }
        BOOL v43 = v52 > 0x7F;
        v52 >>= 7;
      }
      while (v43);
      unint64_t v55 = *(unsigned int *)(v46 + 20);
      do
      {
        char v56 = v55 & 0x7F | ((v55 > 0x7F) << 7);
        long long v57 = (char *)*((void *)v39 + 4);
        if ((unint64_t)v57 >= *((void *)v39 + 3))
        {
          this = (unint64_t)llvm::raw_ostream::write(v39, v56);
        }
        else
        {
          *((void *)v39 + 4) = v57 + 1;
          *long long v57 = v56;
        }
        BOOL v43 = v55 > 0x7F;
        v55 >>= 7;
      }
      while (v43);
      v46 += 24;
      if (v46 == v50) {
        goto LABEL_71;
      }
    }
    unint64_t v60 = this & 0xFFFFFFFF00000000;
  }
  sub_1CBB0D544(v63);
  return v60 | v51;
}

unint64_t llvm::sampleprof::SampleProfileWriterExtBinaryBase::writeProfileSymbolListSection(llvm::sampleprof::SampleProfileWriterExtBinaryBase *this)
{
  uint64_t v2 = *((void *)this + 73);
  if (v2
    && *(_DWORD *)(v2 + 16)
    && (uint64_t v2 = llvm::sampleprof::ProfileSymbolList::write((llvm::sampleprof::ProfileSymbolList *)v2, *((llvm::raw_ostream **)this + 1)), v2))
  {
    unint64_t v3 = v2 & 0xFFFFFFFF00000000;
  }
  else
  {
    llvm::sampleprof_category((llvm *)v2);
    unint64_t v3 = 0;
    LODWORD(v2) = 0;
  }
  return v2 | v3;
}

unint64_t llvm::sampleprof::SampleProfileWriterExtBinaryBase::writeOneSection(unint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  if (a2 == 3)
  {
    uint64_t v8 = *(unsigned char **)(a1 + 584);
    if (!v8) {
      goto LABEL_52;
    }
    if (!*v8) {
      goto LABEL_52;
    }
    uint64_t v9 = *(unsigned int *)(a1 + 96);
    if (!v9) {
      goto LABEL_52;
    }
    uint64_t v10 = 40 * v9;
    long long v11 = (void *)(*(void *)(a1 + 88) + 8);
    do
    {
      if (*((_DWORD *)v11 - 2) == 3) {
        *v11 |= 1uLL;
      }
      v11 += 5;
      v10 -= 40;
    }
    while (v10);
  }
  if (a2 != 5 || !llvm::sampleprof::FunctionSamples::ProfileIsProbeBased) {
    goto LABEL_16;
  }
  uint64_t v12 = *(unsigned int *)(a1 + 96);
  if (v12)
  {
    uint64_t v13 = 40 * v12;
    int v14 = (void *)(*(void *)(a1 + 88) + 8);
    do
    {
      if (*((_DWORD *)v14 - 2) == 5) {
        *v14 |= 0x100000000uLL;
      }
      v14 += 5;
      v13 -= 40;
    }
    while (v13);
LABEL_16:
    int v15 = llvm::sampleprof::FunctionSamples::ProfileIsCSFlat;
    if (a2 != 5)
    {
LABEL_28:
      BOOL v20 = a2 != 1;
      if (a2 == 1 && v15)
      {
        uint64_t v21 = *(unsigned int *)(a1 + 96);
        if (v21)
        {
          uint64_t v22 = 40 * v21;
          unsigned int v23 = (void *)(*(void *)(a1 + 88) + 8);
          do
          {
            if (*((_DWORD *)v23 - 2) == 1) {
              *v23 |= 0x200000000uLL;
            }
            v23 += 5;
            v22 -= 40;
          }
          while (v22);
        }
        BOOL v20 = 0;
      }
      if (!v20)
      {
        if (llvm::sampleprof::FunctionSamples::ProfileIsCSNested)
        {
          uint64_t v24 = *(unsigned int *)(a1 + 96);
          if (v24)
          {
            uint64_t v25 = 40 * v24;
            unint64_t v26 = (void *)(*(void *)(a1 + 88) + 8);
            do
            {
              if (*((_DWORD *)v26 - 2) == 1) {
                *v26 |= 0x1000000000uLL;
              }
              v26 += 5;
              v25 -= 40;
            }
            while (v25);
          }
        }
      }
      if (llvm::sampleprof::FunctionSamples::ProfileIsFS) {
        char v27 = v20;
      }
      else {
        char v27 = 1;
      }
      if ((v27 & 1) == 0)
      {
        uint64_t v28 = *(unsigned int *)(a1 + 96);
        if (v28)
        {
          uint64_t v29 = 40 * v28;
          long long v30 = (void *)(*(void *)(a1 + 88) + 8);
          do
          {
            if (*((_DWORD *)v30 - 2) == 1) {
              *v30 |= 0x400000000uLL;
            }
            v30 += 5;
            v29 -= 40;
          }
          while (v29);
        }
      }
      goto LABEL_52;
    }
    goto LABEL_19;
  }
  int v15 = llvm::sampleprof::FunctionSamples::ProfileIsCSFlat;
LABEL_19:
  if (v15) {
    BOOL v16 = 0;
  }
  else {
    BOOL v16 = llvm::sampleprof::FunctionSamples::ProfileIsCSNested == 0;
  }
  if (!v16)
  {
    uint64_t v17 = *(unsigned int *)(a1 + 96);
    if (v17)
    {
      uint64_t v18 = 40 * v17;
      unint64_t v19 = (void *)(*(void *)(a1 + 88) + 8);
      do
      {
        if (*((_DWORD *)v19 - 2) == 5) {
          *v19 |= 0x200000000uLL;
        }
        v19 += 5;
        v18 -= 40;
      }
      while (v18);
      goto LABEL_28;
    }
  }
LABEL_52:
  long long v31 = *(void **)(a1 + 8);
  uint64_t v32 = (*(uint64_t (**)(void *))(*v31 + 80))(v31);
  uint64_t v33 = v31[4];
  uint64_t v34 = v31[2];
  if (*(unsigned char *)(*(void *)(a1 + 88) + 40 * a3 + 8))
  {
    uint64_t v35 = *(void *)(a1 + 432);
    *(void *)(a1 + 432) = *(void *)(a1 + 8);
    *(void *)(a1 + 8) = v35;
  }
  switch((int)a2)
  {
    case 1:
      llvm::sampleprof::SampleProfileWriter::computeSummary(a1, a4);
    case 2:
      uint64_t v37 = llvm::sampleprof::SampleProfileWriterExtBinaryBase::writeNameTableSection(a1, a4);
      if (!v37) {
        goto LABEL_70;
      }
      goto LABEL_71;
    case 3:
      uint64_t v37 = llvm::sampleprof::SampleProfileWriterExtBinaryBase::writeProfileSymbolListSection((llvm::sampleprof::SampleProfileWriterExtBinaryBase *)a1);
      if (!v37) {
        goto LABEL_70;
      }
      goto LABEL_71;
    case 4:
      uint64_t v37 = llvm::sampleprof::SampleProfileWriterExtBinaryBase::writeFuncOffsetTable((llvm::raw_ostream **)a1);
      if (!v37) {
        goto LABEL_70;
      }
      goto LABEL_71;
    case 5:
      uint64_t v37 = llvm::sampleprof::SampleProfileWriterExtBinaryBase::writeFuncMetadata(a1, a4);
      if (!v37) {
        goto LABEL_70;
      }
      goto LABEL_71;
    case 6:
      uint64_t v37 = llvm::sampleprof::SampleProfileWriterExtBinaryBase::writeCSNameTableSection(a1);
      if (!v37) {
        goto LABEL_70;
      }
      goto LABEL_71;
    default:
      if (a2 != 32)
      {
        uint64_t v37 = (*(uint64_t (**)(unint64_t, uint64_t))(*(void *)a1 + 128))(a1, a2);
        if (!v37) {
          goto LABEL_70;
        }
LABEL_71:
        unint64_t v38 = v37 & 0xFFFFFFFF00000000;
        return v37 | v38;
      }
      uint64_t v36 = *(void **)(a1 + 8);
      *(void *)(a1 + 424) = (*(uint64_t (**)(void *))(*v36 + 80))(v36) + v36[4] - v36[2];
      uint64_t v37 = (*(uint64_t (**)(unint64_t, uint64_t))(*(void *)a1 + 80))(a1, a4);
      if (v37) {
        goto LABEL_71;
      }
LABEL_70:
      uint64_t v37 = llvm::sampleprof::SampleProfileWriterExtBinaryBase::addNewSection((void *)a1, a2, a3, v32 + v33 - v34);
      if (v37) {
        goto LABEL_71;
      }
      llvm::sampleprof_category((llvm *)v37);
      unint64_t v38 = 0;
      LODWORD(v37) = 0;
      return v37 | v38;
  }
}

uint64_t llvm::sampleprof::SampleProfileWriterExtBinaryBase::setToCompressSection(uint64_t result, int a2)
{
  uint64_t v2 = *(unsigned int *)(result + 96);
  if (v2)
  {
    uint64_t v3 = 40 * v2;
    char v4 = (void *)(*(void *)(result + 88) + 8);
    do
    {
      if (*((_DWORD *)v4 - 2) == a2) {
        *v4 |= 1uLL;
      }
      v4 += 5;
      v3 -= 40;
    }
    while (v3);
  }
  return result;
}

void llvm::sampleprof::SampleProfileWriter::computeSummary(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = operator new(0x40uLL);
  *uint64_t v3 = xmmword_1CFB2C580;
  v3[1] = unk_1CFB2C590;
  void v3[2] = xmmword_1CFB2C5A0;
  v3[3] = unk_1CFB2C5B0;
  char v4 = v5;
  v5[0] = 0;
  v5[1] = 0;
  void v5[2] = v3;
  v5[3] = v3 + 4;
  v5[4] = v3 + 4;
  long long v6 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  uint64_t v9 = 0;
  llvm::SampleProfileSummaryBuilder::computeSummaryForProfiles(&v4, a2);
}

uint64_t llvm::sampleprof::SampleProfileWriterBinary::writeSummary(llvm::sampleprof::SampleProfileWriterBinary *this)
{
  uint64_t v2 = (llvm::raw_ostream *)*((void *)this + 1);
  unint64_t v3 = *(void *)(*((void *)this + 2) + 32);
  do
  {
    char v4 = v3 & 0x7F | ((v3 > 0x7F) << 7);
    unint64_t v5 = (char *)*((void *)v2 + 4);
    if ((unint64_t)v5 >= *((void *)v2 + 3))
    {
      uint64_t v2 = llvm::raw_ostream::write(v2, v4);
    }
    else
    {
      *((void *)v2 + 4) = v5 + 1;
      *unint64_t v5 = v4;
    }
    BOOL v6 = v3 > 0x7F;
    v3 >>= 7;
  }
  while (v6);
  unint64_t v7 = *(void *)(*((void *)this + 2) + 40);
  do
  {
    char v8 = v7 & 0x7F | ((v7 > 0x7F) << 7);
    uint64_t v9 = (char *)*((void *)v2 + 4);
    if ((unint64_t)v9 >= *((void *)v2 + 3))
    {
      uint64_t v2 = llvm::raw_ostream::write(v2, v8);
    }
    else
    {
      *((void *)v2 + 4) = v9 + 1;
      char *v9 = v8;
    }
    BOOL v6 = v7 > 0x7F;
    v7 >>= 7;
  }
  while (v6);
  unint64_t v10 = *(void *)(*((void *)this + 2) + 56);
  do
  {
    char v11 = v10 & 0x7F | ((v10 > 0x7F) << 7);
    uint64_t v12 = (char *)*((void *)v2 + 4);
    if ((unint64_t)v12 >= *((void *)v2 + 3))
    {
      uint64_t v2 = llvm::raw_ostream::write(v2, v11);
    }
    else
    {
      *((void *)v2 + 4) = v12 + 1;
      *uint64_t v12 = v11;
    }
    BOOL v6 = v10 > 0x7F;
    v10 >>= 7;
  }
  while (v6);
  unint64_t v13 = *(unsigned int *)(*((void *)this + 2) + 64);
  do
  {
    char v14 = v13 & 0x7F | ((v13 > 0x7F) << 7);
    int v15 = (char *)*((void *)v2 + 4);
    if ((unint64_t)v15 >= *((void *)v2 + 3))
    {
      uint64_t v2 = llvm::raw_ostream::write(v2, v14);
    }
    else
    {
      *((void *)v2 + 4) = v15 + 1;
      char *v15 = v14;
    }
    BOOL v6 = v13 > 0x7F;
    v13 >>= 7;
  }
  while (v6);
  unint64_t v16 = *(unsigned int *)(*((void *)this + 2) + 68);
  do
  {
    char v17 = v16 & 0x7F | ((v16 > 0x7F) << 7);
    uint64_t v18 = (char *)*((void *)v2 + 4);
    if ((unint64_t)v18 >= *((void *)v2 + 3))
    {
      uint64_t v2 = llvm::raw_ostream::write(v2, v17);
    }
    else
    {
      *((void *)v2 + 4) = v18 + 1;
      char *v18 = v17;
    }
    BOOL v6 = v16 > 0x7F;
    v16 >>= 7;
  }
  while (v6);
  uint64_t v19 = *((void *)this + 2);
  unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v19 + 16) - *(void *)(v19 + 8)) >> 3);
  do
  {
    char v21 = v20 & 0x7F | ((v20 > 0x7F) << 7);
    uint64_t v22 = (char *)*((void *)v2 + 4);
    if ((unint64_t)v22 >= *((void *)v2 + 3))
    {
      uint64_t v2 = llvm::raw_ostream::write(v2, v21);
    }
    else
    {
      *((void *)v2 + 4) = v22 + 1;
      char *v22 = v21;
    }
    BOOL v6 = v20 > 0x7F;
    v20 >>= 7;
  }
  while (v6);
  unsigned int v23 = *(unsigned int **)(v19 + 8);
  uint64_t v24 = *(unsigned int **)(v19 + 16);
  while (v23 != v24)
  {
    unint64_t v25 = *v23;
    unint64_t v27 = *((void *)v23 + 1);
    unint64_t v26 = *((void *)v23 + 2);
    do
    {
      char v28 = v25 & 0x7F | ((v25 > 0x7F) << 7);
      uint64_t v29 = (char *)*((void *)v2 + 4);
      if ((unint64_t)v29 >= *((void *)v2 + 3))
      {
        uint64_t v2 = llvm::raw_ostream::write(v2, v28);
      }
      else
      {
        *((void *)v2 + 4) = v29 + 1;
        char *v29 = v28;
      }
      BOOL v6 = v25 > 0x7F;
      v25 >>= 7;
    }
    while (v6);
    do
    {
      char v30 = v27 & 0x7F | ((v27 > 0x7F) << 7);
      long long v31 = (char *)*((void *)v2 + 4);
      if ((unint64_t)v31 >= *((void *)v2 + 3))
      {
        uint64_t v2 = llvm::raw_ostream::write(v2, v30);
      }
      else
      {
        *((void *)v2 + 4) = v31 + 1;
        char *v31 = v30;
      }
      BOOL v6 = v27 > 0x7F;
      v27 >>= 7;
    }
    while (v6);
    do
    {
      char v32 = v26 & 0x7F | ((v26 > 0x7F) << 7);
      uint64_t v33 = (char *)*((void *)v2 + 4);
      if ((unint64_t)v33 >= *((void *)v2 + 3))
      {
        uint64_t v2 = llvm::raw_ostream::write(v2, v32);
      }
      else
      {
        *((void *)v2 + 4) = v33 + 1;
        char *v33 = v32;
      }
      BOOL v6 = v26 > 0x7F;
      v26 >>= 7;
    }
    while (v6);
    v23 += 6;
  }
  llvm::sampleprof_category(v2);
  return 0;
}

unint64_t llvm::sampleprof::SampleProfileWriterExtBinary::writeDefaultLayout(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(*(void *)a1 + 152))(a1, 1, 0, a2);
  if (v4
    || (uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 152))(a1, 2, 1, a2),
        v4)
    || (uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 152))(a1, 6, 2, a2),
        v4)
    || (uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 152))(a1, 32, 4, a2),
        v4)
    || (uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 152))(a1, 3, 5, a2),
        v4)
    || (uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 152))(a1, 4, 3, a2),
        v4)
    || (uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 152))(a1, 5, 6, a2),
        v4))
  {
    unint64_t v5 = v4 & 0xFFFFFFFF00000000;
  }
  else
  {
    llvm::sampleprof_category((llvm *)v4);
    unint64_t v5 = 0;
    LODWORD(v4) = 0;
  }
  return v4 | v5;
}

unint64_t llvm::sampleprof::SampleProfileWriterExtBinary::writeCtxSplitLayout(void *a1, uint64_t a2)
{
  *(_OWORD *)unsigned int v23 = 0u;
  long long v24 = 0u;
  int v25 = 1065353216;
  *(_OWORD *)std::string __p = 0u;
  long long v21 = 0u;
  int v22 = 1065353216;
  for (uint64_t i = *(uint64_t **)(a2 + 16); i; uint64_t i = (uint64_t *)*i)
  {
    unint64_t v5 = (long long *)(i + 2);
    BOOL v6 = (long long *)(i + 7);
    unint64_t v7 = i + 16;
    long long v8 = *((_OWORD *)i + 2);
    if (i[21])
    {
      long long v26 = *v5;
      long long v27 = v8;
      uint64_t v28 = i[6];
      long long v12 = *(_OWORD *)(i + 9);
      long long v13 = *(_OWORD *)(i + 13);
      long long v31 = *(_OWORD *)(i + 11);
      long long v32 = v13;
      uint64_t v33 = i[15];
      long long v30 = v12;
      long long v29 = *v6;
      sub_1CCCF4A9C((uint64_t)v34, v7);
      sub_1CCCF4D4C((uint64_t)v35, i + 19);
      char v11 = v23;
    }
    else
    {
      long long v26 = *v5;
      long long v27 = v8;
      uint64_t v28 = i[6];
      long long v9 = *(_OWORD *)(i + 9);
      long long v10 = *(_OWORD *)(i + 13);
      long long v31 = *(_OWORD *)(i + 11);
      long long v32 = v10;
      uint64_t v33 = i[15];
      long long v30 = v9;
      long long v29 = *v6;
      sub_1CCCF4A9C((uint64_t)v34, v7);
      sub_1CCCF4D4C((uint64_t)v35, i + 19);
      char v11 = __p;
    }
    sub_1CCCFD5A8((uint64_t)v11, (uint64_t)&v26, (uint64_t)&v26);
    sub_1CD750994((uint64_t)v35, v35[1]);
    sub_1CD7509F4((uint64_t)v34, v34[1]);
  }
  uint64_t v14 = (*(uint64_t (**)(void *, uint64_t, void, uint64_t))(*a1 + 152))(a1, 1, 0, a2);
  if (v14) {
    goto LABEL_15;
  }
  uint64_t v14 = (*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(*a1 + 152))(a1, 2, 1, a2);
  if (v14) {
    goto LABEL_15;
  }
  uint64_t v14 = (*(uint64_t (**)(void *, uint64_t, uint64_t, void **))(*a1 + 152))(a1, 32, 3, v23);
  if (v14) {
    goto LABEL_15;
  }
  uint64_t v14 = (*(uint64_t (**)(void *, uint64_t, uint64_t, void **))(*a1 + 152))(a1, 4, 2, v23);
  if (v14
    || (*(void *)(a1[11] + 208) |= 2uLL,
        uint64_t v14 = (*(uint64_t (**)(void *, uint64_t, uint64_t, void **))(*a1 + 152))(a1, 32, 5, __p),
        v14)
    || (*(void *)(a1[11] + 168) |= 2uLL,
        uint64_t v14 = (*(uint64_t (**)(void *, uint64_t, uint64_t, void **))(*a1 + 152))(a1, 4, 4, __p),
        v14)
    || (uint64_t v14 = (*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(*a1 + 152))(a1, 3, 6, a2),
        v14)
    || (int v15 = (llvm *)(*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(*a1 + 152))(a1, 5, 7, a2),
        uint64_t v14 = (uint64_t)v15,
        v15))
  {
LABEL_15:
    unint64_t v16 = v14 & 0xFFFFFFFF00000000;
  }
  else
  {
    llvm::sampleprof_category(v15);
    unint64_t v16 = 0;
    LODWORD(v14) = 0;
  }
  sub_1CD751470((uint64_t)__p, (void **)v21);
  char v17 = __p[0];
  __p[0] = 0;
  if (v17) {
    operator delete(v17);
  }
  sub_1CD751470((uint64_t)v23, (void **)v24);
  uint64_t v18 = v23[0];
  v23[0] = 0;
  if (v18) {
    operator delete(v18);
  }
  return v14 | v16;
}

unint64_t llvm::sampleprof::SampleProfileWriterExtBinary::writeSections(uint64_t a1, uint64_t a2)
{
  std::system_category();
  if (*(_DWORD *)(a1 + 80))
  {
    return llvm::sampleprof::SampleProfileWriterExtBinary::writeCtxSplitLayout((void *)a1, a2);
  }
  else
  {
    return llvm::sampleprof::SampleProfileWriterExtBinary::writeDefaultLayout(a1, a2);
  }
}