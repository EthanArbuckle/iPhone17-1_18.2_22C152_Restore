uint64_t sub_1CBF8F26C@<X0>(uint64_t result@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  void *v11;
  uint64_t v12;
  void *v13;
  int v14;
  BOOL v15;
  unsigned int v16;
  char v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t *v26;
  uint64_t v27;
  int32x2_t *v28;
  unint64_t v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  int v39;
  unsigned int v40;
  uint64_t v41;
  void *v42;
  int v43;
  BOOL v44;
  unsigned int v45;
  void *v46;

  v4 = result;
  v6 = *(_DWORD *)(result + 16);
  if (v6)
  {
    v7 = *(void *)result;
    v8 = a2[3];
    v9 = v6 - 1;
    v10 = ((v8 >> 4) ^ (v8 >> 9)) & (v6 - 1);
    v11 = (void *)(*(void *)result + 40 * v10);
    v12 = v11[3];
    if (v8 == v12)
    {
LABEL_11:
      v17 = 0;
      goto LABEL_33;
    }
    v13 = 0;
    v14 = 1;
    while (v12 != -4096)
    {
      if (v13) {
        v15 = 0;
      }
      else {
        v15 = v12 == -8192;
      }
      if (v15) {
        v13 = v11;
      }
      v16 = v10 + v14++;
      v10 = v16 & v9;
      v11 = (void *)(v7 + 40 * (v16 & v9));
      v12 = v11[3];
      if (v8 == v12) {
        goto LABEL_11;
      }
    }
    if (v13) {
      v11 = v13;
    }
  }
  else
  {
    v11 = 0;
  }
  v18 = *(_DWORD *)(result + 8);
  if (4 * v18 + 4 >= 3 * v6)
  {
    result = (uint64_t)sub_1CBF8F630(result, 2 * v6);
    v37 = *(_DWORD *)(v4 + 16);
    if (v37)
    {
      v38 = a2[3];
      v39 = v37 - 1;
      v40 = ((v38 >> 4) ^ (v38 >> 9)) & (v37 - 1);
      v11 = (void *)(*(void *)v4 + 40 * v40);
      v41 = v11[3];
      if (v38 != v41)
      {
        v42 = 0;
        v43 = 1;
        while (v41 != -4096)
        {
          if (v42) {
            v44 = 0;
          }
          else {
            v44 = v41 == -8192;
          }
          if (v44) {
            v42 = v11;
          }
          v45 = v40 + v43++;
          v40 = v45 & v39;
          v11 = (void *)(*(void *)v4 + 40 * (v45 & v39));
          v41 = v11[3];
          if (v38 == v41) {
            goto LABEL_17;
          }
        }
        if (v42) {
          v11 = v42;
        }
      }
    }
    else
    {
      v11 = 0;
    }
  }
  else if (v6 + ~v18 - *(_DWORD *)(result + 12) <= v6 >> 3)
  {
    sub_1CBF8F630(result, v6);
    v46 = 0;
    result = sub_1CBF8F5B0(*(void *)v4, *(_DWORD *)(v4 + 16), a2[3], &v46);
    v11 = v46;
  }
LABEL_17:
  ++*(_DWORD *)(v4 + 8);
  v19 = v11[3];
  if (v19 != -4096) {
    --*(_DWORD *)(v4 + 12);
  }
  v20 = a2[3];
  if (v19 != v20)
  {
    v21 = v19 == -4096 || v19 == 0;
    if (!v21 && v19 != -8192)
    {
      v25 = v11[1] & 0xFFFFFFFFFFFFFFF8;
      *(void *)v25 = v11[2];
      v26 = (unint64_t *)v11[2];
      if (v26)
      {
        *v26 = *v26 & 7 | v25;
      }
      else
      {
        v27 = v11[3];
        v28 = ***(int32x2_t ****)v27;
        v29 = (unint64_t)v28[303];
        if (v29 <= v25)
        {
          v30 = v28[305].u32[0];
          if (v29 + 16 * v30 > v25)
          {
            v31 = v30 - 1;
            LODWORD(v32) = v31 & ((v27 >> 4) ^ (v27 >> 9));
            v33 = (uint64_t *)(v29 + 16 * v32);
            v34 = *v33;
            if (v27 == *v33)
            {
LABEL_43:
              *v33 = -8192;
              v28[304] = vadd_s32(v28[304], (int32x2_t)0x1FFFFFFFFLL);
              v27 = v11[3];
            }
            else
            {
              v35 = 1;
              while (v34 != -4096)
              {
                v36 = v32 + v35++;
                v32 = v36 & v31;
                v34 = *(void *)(v29 + 16 * v32);
                if (v27 == v34)
                {
                  v33 = (uint64_t *)(v29 + 16 * v32);
                  goto LABEL_43;
                }
              }
            }
            *(unsigned char *)(v27 + 17) &= ~1u;
          }
        }
      }
      v20 = a2[3];
    }
    v11[3] = v20;
    if (v20 != -4096 && v20 != -8192 && v20 != 0)
    {
      v23 = a2[1];
      v11[2] = *(void *)(v23 & 0xFFFFFFFFFFFFFFF8);
      *(void *)(v23 & 0xFFFFFFFFFFFFFFF8) = v11 + 1;
      v11[1] = v23 & 0xFFFFFFFFFFFFFFF8 | v11[1] & 7;
      v24 = (unint64_t *)v11[2];
      if (v24) {
        *v24 = *v24 & 7 | (unint64_t)(v11 + 2);
      }
    }
  }
  v11[4] = a2[4];
  v7 = *(void *)v4;
  v6 = *(_DWORD *)(v4 + 16);
  v17 = 1;
LABEL_33:
  *(void *)a3 = v11;
  *(void *)(a3 + 8) = v7 + 40 * v6;
  *(unsigned char *)(a3 + 16) = v17;
  return result;
}

uint64_t sub_1CBF8F5B0(uint64_t result, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    uint64_t v6 = result + 40 * v5;
    uint64_t v7 = *(void *)(v6 + 24);
    if (v7 != a3)
    {
      uint64_t v8 = 0;
      int v9 = 1;
      while (v7 != -4096)
      {
        if (v8) {
          BOOL v10 = 0;
        }
        else {
          BOOL v10 = v7 == -8192;
        }
        if (v10) {
          uint64_t v8 = v6;
        }
        unsigned int v11 = v5 + v9++;
        unsigned int v5 = v11 & v4;
        uint64_t v6 = result + 40 * (v11 & v4);
        uint64_t v7 = *(void *)(v6 + 24);
        if (v7 == a3) {
          goto LABEL_14;
        }
      }
      if (v8) {
        uint64_t v6 = v8;
      }
    }
  }
  else
  {
    uint64_t v6 = 0;
  }
LABEL_14:
  *a4 = v6;
  return result;
}

void *sub_1CBF8F630(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  int v4 = *(void **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  *(void *)a1 = operator new(40 * v8, (std::align_val_t)8uLL);
  if (v4)
  {
    sub_1CBF8AD4C((void *)a1);
    v56[0] = 2;
    v56[1] = 0;
    uint64_t v57 = -4096;
    uint64_t v58 = 0;
    uint64_t v54 = 0;
    v55 = &unk_1F2601308;
    v52[0] = 2;
    v52[1] = 0;
    uint64_t v53 = -8192;
    if (v3)
    {
      BOOL v10 = v4;
      do
      {
        uint64_t v11 = v10[3];
        if (v11 != v57 && v11 != v53)
        {
          int v13 = *(_DWORD *)(a1 + 16) - 1;
          unsigned int v14 = v13 & ((v11 >> 4) ^ (v11 >> 9));
          v15 = (void *)(*(void *)a1 + 40 * v14);
          uint64_t v16 = v15[3];
          if (v11 != v16)
          {
            v17 = 0;
            int v18 = 1;
            while (v16 != -4096)
            {
              if (v17) {
                BOOL v19 = 0;
              }
              else {
                BOOL v19 = v16 == -8192;
              }
              if (v19) {
                v17 = v15;
              }
              unsigned int v20 = v14 + v18++;
              unsigned int v14 = v20 & v13;
              v15 = (void *)(*(void *)a1 + 40 * (v20 & v13));
              uint64_t v16 = v15[3];
              if (v11 == v16) {
                goto LABEL_39;
              }
            }
            if (v17) {
              v15 = v17;
            }
            uint64_t v21 = v15[3];
            if (v21 != v11)
            {
              BOOL v22 = v21 == -4096 || v21 == 0;
              if (!v22 && v21 != -8192)
              {
                unint64_t v39 = v15[1] & 0xFFFFFFFFFFFFFFF8;
                *(void *)unint64_t v39 = v15[2];
                v40 = (unint64_t *)v15[2];
                if (v40)
                {
                  unint64_t *v40 = *v40 & 7 | v39;
                }
                else
                {
                  uint64_t v41 = v15[3];
                  v42 = ***(int32x2_t ****)v41;
                  unint64_t v43 = (unint64_t)v42[303];
                  if (v43 <= v39)
                  {
                    uint64_t v44 = v42[305].u32[0];
                    if (v43 + 16 * v44 > v39)
                    {
                      unsigned int v45 = v44 - 1;
                      LODWORD(v46) = v45 & ((v41 >> 4) ^ (v41 >> 9));
                      v47 = (uint64_t *)(v43 + 16 * v46);
                      uint64_t v48 = *v47;
                      if (v41 != *v47)
                      {
                        int v49 = 1;
                        do
                        {
                          if (v48 == -4096) {
                            goto LABEL_68;
                          }
                          int v50 = v46 + v49++;
                          uint64_t v46 = v50 & v45;
                          uint64_t v48 = *(void *)(v43 + 16 * v46);
                        }
                        while (v41 != v48);
                        v47 = (uint64_t *)(v43 + 16 * v46);
                      }
                      uint64_t *v47 = -8192;
                      v42[304] = vadd_s32(v42[304], (int32x2_t)0x1FFFFFFFFLL);
                      uint64_t v41 = v15[3];
LABEL_68:
                      *(unsigned char *)(v41 + 17) &= ~1u;
                    }
                  }
                }
                uint64_t v11 = v10[3];
              }
              v15[3] = v11;
              if (v11 != -4096 && v11 != -8192 && v11 != 0)
              {
                uint64_t v24 = v10[1];
                v15[2] = *(void *)(v24 & 0xFFFFFFFFFFFFFFF8);
                *(void *)(v24 & 0xFFFFFFFFFFFFFFF8) = v15 + 1;
                v15[1] = v24 & 0xFFFFFFFFFFFFFFF8 | v15[1] & 7;
                v25 = (unint64_t *)v15[2];
                if (v25) {
                  unint64_t *v25 = *v25 & 7 | (unint64_t)(v15 + 2);
                }
              }
            }
          }
LABEL_39:
          v15[4] = v10[4];
          ++*(_DWORD *)(a1 + 8);
          uint64_t v11 = v10[3];
        }
        if (v11 != -4096 && v11 != -8192 && v11 != 0)
        {
          unint64_t v27 = v10[1] & 0xFFFFFFFFFFFFFFF8;
          *(void *)unint64_t v27 = v10[2];
          v28 = (unint64_t *)v10[2];
          if (v28)
          {
            unint64_t *v28 = *v28 & 7 | v27;
          }
          else
          {
            uint64_t v29 = v10[3];
            v30 = ***(int32x2_t ****)v29;
            unint64_t v31 = (unint64_t)v30[303];
            if (v31 <= v27)
            {
              uint64_t v32 = v30[305].u32[0];
              if (v31 + 16 * v32 > v27)
              {
                unsigned int v33 = v32 - 1;
                LODWORD(v34) = v33 & ((v29 >> 4) ^ (v29 >> 9));
                v35 = (uint64_t *)(v31 + 16 * v34);
                uint64_t v36 = *v35;
                if (v29 != *v35)
                {
                  int v37 = 1;
                  do
                  {
                    if (v36 == -4096) {
                      goto LABEL_54;
                    }
                    int v38 = v34 + v37++;
                    uint64_t v34 = v38 & v33;
                    uint64_t v36 = *(void *)(v31 + 16 * v34);
                  }
                  while (v29 != v36);
                  v35 = (uint64_t *)(v31 + 16 * v34);
                }
                uint64_t *v35 = -8192;
                v30[304] = vadd_s32(v30[304], (int32x2_t)0x1FFFFFFFFLL);
                uint64_t v29 = v10[3];
LABEL_54:
                *(unsigned char *)(v29 + 17) &= ~1u;
              }
            }
          }
        }
        v10 += 5;
      }
      while (v10 != &v4[5 * v3]);
      if (v53 != -8192 && v53 != -4096 && v53 != 0) {
        llvm::ValueHandleBase::RemoveFromUseList(v52);
      }
    }
    if (v57 != -4096 && v57 != -8192 && v57) {
      llvm::ValueHandleBase::RemoveFromUseList(v56);
    }
    JUMPOUT(0x1D25D9CD0);
  }

  return sub_1CBF8AD4C((void *)a1);
}

uint64_t sub_1CBF8FA78(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CBF8F170(a1, (uint64_t *)a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CBF8FAE4(a1, a2, v7);
    *(void *)uint64_t v5 = *(void *)a2;
    *(_DWORD *)(v5 + 8) = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(v5 + 16) = -1;
  }
  return v5;
}

uint64_t sub_1CBF8FAE4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    sub_1CBF8FC94((uint64_t *)a1, 2 * v6);
    int v9 = *(_DWORD *)(a1 + 16);
    if (v9)
    {
      int v10 = *(_DWORD *)(a2 + 8);
      unint64_t v11 = ~((unint64_t)(37 * v10) << 32)
          + (37 * v10)
          + ((unint64_t)((*(void *)a2 >> 4) ^ (*(void *)a2 >> 9)) << 32);
      unint64_t v12 = (v11 ^ (v11 >> 22)) + ~((v11 ^ (v11 >> 22)) << 13);
      unint64_t v13 = (9 * (v12 ^ (v12 >> 8))) ^ ((9 * (v12 ^ (v12 >> 8))) >> 15);
      int v14 = v9 - 1;
      unsigned int v15 = v14 & (((v13 + ~(v13 << 27)) >> 31) ^ (v13 + ~(v13 << 27)));
      a3 = *(void *)a1 + 24 * v15;
      uint64_t v16 = *(void *)a3;
      int v17 = *(_DWORD *)(a3 + 8);
      if (*(void *)a2 != *(void *)a3 || v10 != v17)
      {
        uint64_t v19 = 0;
        int v20 = 1;
        while (v16 != -4096 || v17 != -1)
        {
          if (v19) {
            BOOL v21 = 0;
          }
          else {
            BOOL v21 = v17 == -2;
          }
          if (v21 && v16 == -8192) {
            uint64_t v19 = a3;
          }
          unsigned int v23 = v15 + v20++;
          unsigned int v15 = v23 & v14;
          a3 = *(void *)a1 + 24 * v15;
          uint64_t v16 = *(void *)a3;
          int v17 = *(_DWORD *)(a3 + 8);
          if (*(void *)a2 == *(void *)a3 && v10 == v17) {
            goto LABEL_4;
          }
        }
        if (v19) {
          a3 = v19;
        }
      }
    }
    else
    {
      a3 = 0;
    }
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) <= v6 >> 3)
  {
    sub_1CBF8FC94((uint64_t *)a1, v6);
    uint64_t v25 = 0;
    sub_1CBF8F170(a1, (uint64_t *)a2, &v25);
    a3 = v25;
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (*(void *)a3 != -4096 || *(_DWORD *)(a3 + 8) != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_OWORD *sub_1CBF8FC94(uint64_t *a1, int a2)
{
  unsigned int v3 = *((_DWORD *)a1 + 4);
  char v4 = (uint64_t *)*a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *((_DWORD *)a1 + 4) = v8;
  result = operator new(24 * v8, (std::align_val_t)8uLL);
  *a1 = (uint64_t)result;
  if (v4)
  {
    a1[1] = 0;
    uint64_t v12 = *((unsigned int *)a1 + 4);
    if (v12)
    {
      uint64_t v13 = 24 * v12;
      int v14 = result;
      do
      {
        *int v14 = xmmword_1CFAC30E0;
        int v14 = (_OWORD *)((char *)v14 + 24);
        v13 -= 24;
      }
      while (v13);
    }
    if (v3)
    {
      int v15 = 0;
      int v16 = v12 - 1;
      int v17 = v4;
      do
      {
        uint64_t v18 = *v17;
        int v19 = *((_DWORD *)v17 + 2);
        if ((*v17 != -4096 || v19 != -1) && (v18 != -8192 || v19 != -2))
        {
          unint64_t v22 = ~((unint64_t)(37 * v19) << 32)
              + (37 * v19)
              + ((unint64_t)((v18 >> 4) ^ (v18 >> 9)) << 32);
          unint64_t v23 = (v22 ^ (v22 >> 22)) + ~((v22 ^ (v22 >> 22)) << 13);
          unint64_t v24 = (9 * (v23 ^ (v23 >> 8))) ^ ((9 * (v23 ^ (v23 >> 8))) >> 15);
          unsigned int v25 = v16 & (((v24 + ~(v24 << 27)) >> 31) ^ (v24 + ~(v24 << 27)));
          v26 = (char *)result + 24 * v25;
          uint64_t v27 = *(void *)v26;
          int v28 = *((_DWORD *)v26 + 2);
          if (v18 != *(void *)v26 || v19 != v28)
          {
            v30 = 0;
            int v31 = 1;
            while (v27 != -4096 || v28 != -1)
            {
              if (v30) {
                BOOL v32 = 0;
              }
              else {
                BOOL v32 = v28 == -2;
              }
              if (v32 && v27 == -8192) {
                v30 = v26;
              }
              unsigned int v34 = v25 + v31++;
              unsigned int v25 = v34 & v16;
              v26 = (char *)result + 24 * (v34 & v16);
              uint64_t v27 = *(void *)v26;
              int v28 = *((_DWORD *)v26 + 2);
              if (v18 == *(void *)v26 && v19 == v28) {
                goto LABEL_45;
              }
            }
            if (v30) {
              v26 = v30;
            }
          }
LABEL_45:
          *(void *)v26 = v18;
          *((_DWORD *)v26 + 2) = v19;
          *((_DWORD *)v26 + 4) = *((_DWORD *)v17 + 4);
          *((_DWORD *)a1 + 2) = ++v15;
        }
        v17 += 3;
      }
      while (v17 != &v4[3 * v3]);
    }
    JUMPOUT(0x1D25D9CD0);
  }
  a1[1] = 0;
  uint64_t v10 = *((unsigned int *)a1 + 4);
  if (v10)
  {
    uint64_t v11 = 24 * v10;
    do
    {
      _OWORD *result = xmmword_1CFAC30E0;
      result = (_OWORD *)((char *)result + 24);
      v11 -= 24;
    }
    while (v11);
  }
  return result;
}

void *sub_1CBF8FEAC(void *a1)
{
  uint64_t v2 = a1[3];
  if (v2)
  {
    uint64_t v4 = a1[4];
    unint64_t v5 = (void *)a1[3];
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = *(void *)(v4 - 24);
        v4 -= 24;
        MEMORY[0x1D25D9CD0](v6, 8);
      }
      while (v4 != v2);
      unint64_t v5 = (void *)a1[3];
    }
    a1[4] = v2;
    operator delete(v5);
  }
  MEMORY[0x1D25D9CD0](*a1, 8);
  return a1;
}

void sub_1CBF8FF20(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    sub_1CBF8FF88((uint64_t *)(a2 + 24));
    if (*(void *)a2 != a2 + 16) {
      free(*(void **)a2);
    }
    JUMPOUT(0x1D25D9CE0);
  }
}

uint64_t *sub_1CBF8FF88(uint64_t *a1)
{
  uint64_t v2 = *((unsigned int *)a1 + 4);
  uint64_t v3 = *a1;
  if (v2)
  {
    uint64_t v4 = 16 * v2;
    unint64_t v5 = (uint64_t *)(v3 + 8);
    do
    {
      if ((*(v5 - 1) | 0x1000) != 0xFFFFFFFFFFFFF000) {
        unint64_t v5 = sub_1CB9313C0(v5);
      }
      v5 += 2;
      v4 -= 16;
    }
    while (v4);
    uint64_t v3 = *a1;
  }
  MEMORY[0x1D25D9CD0](v3, 8);
  return a1;
}

void sub_1CBF8FFEC(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    sub_1CBF8FF88((uint64_t *)(a2 + 48));
    if (*(void *)a2 != a2 + 16) {
      free(*(void **)a2);
    }
    JUMPOUT(0x1D25D9CE0);
  }
}

void sub_1CBF90054(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v45[24] = *MEMORY[0x1E4F143B8];
  int v38 = v42;
  int v7 = *(unsigned char **)a1;
  uint64_t v6 = *(const void **)(a1 + 8);
  if (v6 == *(const void **)a1)
  {
    unint64_t v39 = v42;
    uint64_t v8 = *(unsigned int *)(a1 + 20);
    if (v8) {
      memmove(v42, v6, 8 * v8);
    }
  }
  else
  {
    unint64_t v39 = *(unsigned char **)(a1 + 8);
    *(void *)(a1 + 8) = v7;
    LODWORD(v8) = *(_DWORD *)(a1 + 20);
  }
  LODWORD(v40) = *(_DWORD *)(a1 + 16);
  HIDWORD(v40) = v8;
  int v41 = *(_DWORD *)(a1 + 24);
  *(void *)(a1 + 16) = 8;
  *(_DWORD *)(a1 + 24) = 0;
  unint64_t v43 = v45;
  unint64_t v44 = 0x800000000;
  unsigned int v9 = *(_DWORD *)(a1 + 104);
  if (v9 && &v38 != (unsigned char **)a1)
  {
    uint64_t v10 = *(const void **)(a1 + 96);
    if (v10 == (const void *)(a1 + 112))
    {
      if (v9 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v45, v10, 24 * *(unsigned int *)(a1 + 104));
      LODWORD(v44) = v9;
    }
    else
    {
      unint64_t v43 = *(void **)(a1 + 96);
      unint64_t v44 = __PAIR64__(*(_DWORD *)(a1 + 108), v9);
      *(void *)(a1 + 96) = a1 + 112;
      *(_DWORD *)(a1 + 108) = 0;
    }
    *(_DWORD *)(a1 + 104) = 0;
  }
  v30 = v34;
  uint64_t v12 = *(unsigned char **)a2;
  uint64_t v11 = *(const void **)(a2 + 8);
  if (v11 == *(const void **)a2)
  {
    int v31 = v34;
    uint64_t v13 = *(unsigned int *)(a2 + 20);
    if (v13) {
      memmove(v34, v11, 8 * v13);
    }
  }
  else
  {
    int v31 = *(unsigned char **)(a2 + 8);
    *(void *)(a2 + 8) = v12;
    LODWORD(v13) = *(_DWORD *)(a2 + 20);
  }
  LODWORD(v32) = *(_DWORD *)(a2 + 16);
  HIDWORD(v32) = v13;
  int v33 = *(_DWORD *)(a2 + 24);
  *(void *)(a2 + 16) = 8;
  *(_DWORD *)(a2 + 24) = 0;
  v35 = v37;
  unint64_t v36 = 0x800000000;
  unsigned int v14 = *(_DWORD *)(a2 + 104);
  if (v14 && &v30 != (unsigned char **)a2)
  {
    int v15 = *(const void **)(a2 + 96);
    if (v15 == (const void *)(a2 + 112))
    {
      if (v14 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v37, v15, 24 * *(unsigned int *)(a2 + 104));
      LODWORD(v36) = v14;
    }
    else
    {
      v35 = *(void **)(a2 + 96);
      unint64_t v36 = __PAIR64__(*(_DWORD *)(a2 + 108), v14);
      *(void *)(a2 + 96) = a2 + 112;
      *(_DWORD *)(a2 + 108) = 0;
    }
    *(_DWORD *)(a2 + 104) = 0;
  }
  int v16 = (void *)(a3 + 32);
  *(void *)a3 = a3 + 32;
  uint64_t v18 = v38;
  int v17 = v39;
  if (v39 == v38)
  {
    *(void *)(a3 + 8) = v16;
    int v19 = HIDWORD(v40);
    if (HIDWORD(v40)) {
      memmove(v16, v17, 8 * HIDWORD(v40));
    }
  }
  else
  {
    *(void *)(a3 + 8) = v39;
    unint64_t v39 = v18;
    int v19 = HIDWORD(v40);
  }
  int v20 = v41;
  *(_DWORD *)(a3 + 16) = v40;
  *(_DWORD *)(a3 + 20) = v19;
  *(_DWORD *)(a3 + 24) = v20;
  uint64_t v40 = 8;
  *(void *)(a3 + 96) = a3 + 112;
  int v41 = 0;
  *(void *)(a3 + 104) = 0x800000000;
  int v21 = v44;
  if (v44 && &v38 != (unsigned char **)a3)
  {
    if (v43 == v45)
    {
      if (v44 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy((void *)(a3 + 112), v45, 24 * v44);
      *(_DWORD *)(a3 + 104) = v21;
    }
    else
    {
      *(void *)(a3 + 96) = v43;
      int v29 = HIDWORD(v44);
      *(_DWORD *)(a3 + 104) = v21;
      *(_DWORD *)(a3 + 108) = v29;
      unint64_t v43 = v45;
      HIDWORD(v44) = 0;
    }
    LODWORD(v44) = 0;
  }
  unint64_t v22 = (void *)(a3 + 336);
  *(void *)(a3 + 304) = a3 + 336;
  unint64_t v24 = v30;
  unint64_t v23 = v31;
  if (v31 == v30)
  {
    *(void *)(a3 + 312) = v22;
    int v25 = HIDWORD(v32);
    if (HIDWORD(v32)) {
      memmove(v22, v23, 8 * HIDWORD(v32));
    }
  }
  else
  {
    *(void *)(a3 + 312) = v31;
    int v31 = v24;
    int v25 = HIDWORD(v32);
  }
  int v26 = v33;
  *(_DWORD *)(a3 + 320) = v32;
  *(_DWORD *)(a3 + 324) = v25;
  *(_DWORD *)(a3 + 328) = v26;
  uint64_t v32 = 8;
  int v33 = 0;
  *(void *)(a3 + 400) = a3 + 416;
  *(void *)(a3 + 408) = 0x800000000;
  uint64_t v27 = v35;
  if ((unsigned char **)(a3 + 304) != &v30)
  {
    int v28 = v36;
    if (v36)
    {
      if (v35 == v37)
      {
        if (v36 >= 9) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        memcpy((void *)(a3 + 416), v37, 24 * v36);
        *(_DWORD *)(a3 + 408) = v28;
        uint64_t v27 = v35;
      }
      else
      {
        *(void *)(a3 + 400) = v35;
        *(_DWORD *)(a3 + 408) = v28;
        *(_DWORD *)(a3 + 412) = HIDWORD(v36);
        v35 = v37;
        HIDWORD(v36) = 0;
        uint64_t v27 = v37;
      }
      LODWORD(v36) = 0;
    }
  }
  if (v27 != v37) {
    free(v27);
  }
  if (v31 != v30) {
    free(v31);
  }
  if (v43 != v45) {
    free(v43);
  }
  if (v39 != v38) {
    free(v39);
  }
}

uint64_t sub_1CBF904E4()
{
  v40[6] = *MEMORY[0x1E4F143B8];
  LOBYTE(v32) = 0;
  int v38 = &v32;
  LODWORD(v35) = 1;
  v18.n128_u64[0] = (unint64_t)"Print the branch probability info.";
  v18.n128_u64[1] = 34;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBCC4050, "print-bpi", (unsigned char **)&v38, &v35, &v18);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCC4050, &dword_1CB82C000);
  LODWORD(v38) = 1;
  v18.n128_u64[0] = (unint64_t)"The option to specify the name of the function whose branch probability info is printed.";
  v18.n128_u64[1] = 88;
  sub_1CD45DC8C((uint64_t)&PrintBranchProbFuncName, "print-bpi-func-name", &v38, &v18);
  __cxa_atexit((void (*)(void *))sub_1CD41C8DC, &PrintBranchProbFuncName, &dword_1CB82C000);
  qword_1EBCC3F98 = 0x5000000000000001;
  dword_1EBCC3FA0 = 805306368;
  int v38 = (void **)v40;
  v40[0] = 0x3000000050000000;
  uint64_t v39 = 0xC00000002;
  v18.n128_u32[0] = 33;
  v18.n128_u64[1] = (unint64_t)v20;
  uint64_t v19 = 0xC00000000;
  sub_1CD41B6B0((uint64_t)&v18.n128_i64[1], (uint64_t)&v38);
  v35 = v37;
  LODWORD(v37[0]) = dword_1EBCC3FA0;
  HIDWORD(v37[0]) = HIDWORD(qword_1EBCC3F98);
  uint64_t v36 = 0xC00000002;
  int v21 = 32;
  unint64_t v22 = v24;
  uint64_t v23 = 0xC00000000;
  sub_1CD41B6B0((uint64_t)&v22, (uint64_t)&v35);
  uint64_t v0 = 0;
  qword_1EBCC3FC8 = 0;
  unk_1EBCC3FD0 = 0;
  qword_1EBCC3FC0 = (uint64_t)&qword_1EBCC3FC8;
  do
  {
    sub_1CBF8B16C(&qword_1EBCC3FC0, &qword_1EBCC3FC8, v18.n128_u32[v0], (__n128 *)((char *)&v18 + v0 * 4));
    v0 += 18;
  }
  while (v0 != 36);
  for (uint64_t i = 0; i != -18; i -= 9)
  {
    uint64_t v2 = (&v22)[i];
    if (&v24[i * 8] != v2) {
      free(v2);
    }
  }
  if (v35 != v37) {
    free(v35);
  }
  if (v38 != v40) {
    free(v38);
  }
  __cxa_atexit((void (*)(void *))sub_1CBF83748, &qword_1EBCC3FC0, &dword_1CB82C000);
  qword_1EBCC3FA4 = 0x3000000050000000;
  int v38 = (void **)v40;
  v40[0] = 0x5000000030000000;
  uint64_t v39 = 0xC00000002;
  v18.n128_u32[0] = 32;
  v18.n128_u64[1] = (unint64_t)v20;
  uint64_t v19 = 0xC00000000;
  sub_1CD41B6B0((uint64_t)&v18.n128_i64[1], (uint64_t)&v38);
  v35 = v37;
  v37[0] = qword_1EBCC3FA4;
  uint64_t v36 = 0xC00000002;
  int v21 = 33;
  unint64_t v22 = v24;
  uint64_t v23 = 0xC00000000;
  sub_1CD41B6B0((uint64_t)&v22, (uint64_t)&v35);
  uint64_t v32 = v34;
  LODWORD(v34[0]) = HIDWORD(qword_1EBCC3FA4);
  HIDWORD(v34[0]) = qword_1EBCC3FA4;
  uint64_t v33 = 0xC00000002;
  int v25 = 40;
  int v26 = v28;
  uint64_t v27 = 0xC00000000;
  sub_1CD41B6B0((uint64_t)&v26, (uint64_t)&v32);
  v16[0] = v17;
  v17[0] = qword_1EBCC3FA4;
  v16[1] = (void *)0xC00000002;
  int v29 = 38;
  v30[0] = &v31;
  v30[1] = 0xC00000000;
  sub_1CD41B6B0((uint64_t)v30, (uint64_t)v16);
  uint64_t v3 = 0;
  qword_1EBCC3FE0 = 0;
  qword_1EBCC3FE8 = 0;
  qword_1EBCC3FD8 = (uint64_t)&qword_1EBCC3FE0;
  do
  {
    sub_1CBF8B16C(&qword_1EBCC3FD8, &qword_1EBCC3FE0, v18.n128_u32[v3], (__n128 *)((char *)&v18 + v3 * 4));
    v3 += 18;
  }
  while (v3 != 72);
  uint64_t v4 = 36;
  do
  {
    unint64_t v5 = v16[v4];
    if (&v17[v4] != v5) {
      free(v5);
    }
    v4 -= 9;
  }
  while (v4 * 8);
  if (v16[0] != v17) {
    free(v16[0]);
  }
  if (v32 != v34) {
    free(v32);
  }
  if (v35 != v37) {
    free(v35);
  }
  if (v38 != v40) {
    free(v38);
  }
  __cxa_atexit((void (*)(void *))sub_1CBF83748, &qword_1EBCC3FD8, &dword_1CB82C000);
  int v38 = (void **)v40;
  LODWORD(v40[0]) = HIDWORD(qword_1EBCC3FA4);
  HIDWORD(v40[0]) = qword_1EBCC3FA4;
  uint64_t v39 = 0xC00000002;
  v18.n128_u32[0] = 32;
  v18.n128_u64[1] = (unint64_t)v20;
  uint64_t v19 = 0xC00000000;
  sub_1CD41B6B0((uint64_t)&v18.n128_i64[1], (uint64_t)&v38);
  v35 = v37;
  v37[0] = qword_1EBCC3FA4;
  uint64_t v36 = 0xC00000002;
  int v21 = 33;
  unint64_t v22 = v24;
  uint64_t v23 = 0xC00000000;
  sub_1CD41B6B0((uint64_t)&v22, (uint64_t)&v35);
  uint64_t v32 = v34;
  v34[0] = qword_1EBCC3FA4;
  uint64_t v33 = 0xC00000002;
  int v25 = 38;
  int v26 = v28;
  uint64_t v27 = 0xC00000000;
  sub_1CD41B6B0((uint64_t)&v26, (uint64_t)&v32);
  uint64_t v6 = 0;
  qword_1EBCC3FF8 = 0;
  qword_1EBCC4000 = 0;
  qword_1EBCC3FF0 = (uint64_t)&qword_1EBCC3FF8;
  do
  {
    sub_1CBF8B16C(&qword_1EBCC3FF0, &qword_1EBCC3FF8, v18.n128_u32[v6], (__n128 *)((char *)&v18 + v6 * 4));
    v6 += 18;
  }
  while (v6 != 54);
  for (uint64_t j = 0; j != -27; j -= 9)
  {
    uint64_t v8 = (&v26)[j];
    if (&v28[j * 8] != v8) {
      free(v8);
    }
  }
  if (v32 != v34) {
    free(v32);
  }
  if (v35 != v37) {
    free(v35);
  }
  if (v38 != v40) {
    free(v38);
  }
  __cxa_atexit((void (*)(void *))sub_1CBF83748, &qword_1EBCC3FF0, &dword_1CB82C000);
  int v38 = (void **)v40;
  LODWORD(v40[0]) = HIDWORD(qword_1EBCC3FA4);
  HIDWORD(v40[0]) = qword_1EBCC3FA4;
  uint64_t v39 = 0xC00000002;
  v18.n128_u32[0] = 40;
  v18.n128_u64[1] = (unint64_t)v20;
  uint64_t v19 = 0xC00000000;
  sub_1CD41B6B0((uint64_t)&v18.n128_i64[1], (uint64_t)&v38);
  qword_1EBCC4010 = 0;
  qword_1EBCC4008 = (uint64_t)&qword_1EBCC4010;
  qword_1EBCC4018 = 0;
  sub_1CBF8B16C(&qword_1EBCC4008, &qword_1EBCC4010, v18.n128_u32[0], &v18);
  if ((unsigned char *)v18.n128_u64[1] != v20) {
    free((void *)v18.n128_u64[1]);
  }
  if (v38 != v40) {
    free(v38);
  }
  __cxa_atexit((void (*)(void *))sub_1CBF83748, &qword_1EBCC4008, &dword_1CB82C000);
  int v38 = (void **)v40;
  LODWORD(v40[0]) = HIDWORD(qword_1EBCC3FA4);
  HIDWORD(v40[0]) = qword_1EBCC3FA4;
  uint64_t v39 = 0xC00000002;
  v18.n128_u32[0] = 32;
  v18.n128_u64[1] = (unint64_t)v20;
  uint64_t v19 = 0xC00000000;
  sub_1CD41B6B0((uint64_t)&v18.n128_i64[1], (uint64_t)&v38);
  v35 = v37;
  v37[0] = qword_1EBCC3FA4;
  uint64_t v36 = 0xC00000002;
  int v21 = 33;
  unint64_t v22 = v24;
  uint64_t v23 = 0xC00000000;
  sub_1CD41B6B0((uint64_t)&v22, (uint64_t)&v35);
  uint64_t v9 = 0;
  qword_1EBCC4028 = 0;
  qword_1EBCC4030 = 0;
  qword_1EBCC4020 = (uint64_t)&qword_1EBCC4028;
  do
  {
    sub_1CBF8B16C(&qword_1EBCC4020, &qword_1EBCC4028, v18.n128_u32[v9], (__n128 *)((char *)&v18 + v9 * 4));
    v9 += 18;
  }
  while (v9 != 36);
  for (uint64_t k = 0; k != -18; k -= 9)
  {
    uint64_t v11 = (&v22)[k];
    if (&v24[k * 8] != v11) {
      free(v11);
    }
  }
  if (v35 != v37) {
    free(v35);
  }
  if (v38 != v40) {
    free(v38);
  }
  __cxa_atexit((void (*)(void *))sub_1CBF83748, &qword_1EBCC4020, &dword_1CB82C000);
  qword_1EBCC3FAC = 0x8007FFFF800;
  *(void *)&dword_1EBCC3FB4 = 0x3000000050000000;
  int v38 = (void **)v40;
  v40[0] = 0x8007FFFF800;
  uint64_t v39 = 0xC00000002;
  v18.n128_u32[0] = 7;
  v18.n128_u64[1] = (unint64_t)v20;
  uint64_t v19 = 0xC00000000;
  sub_1CD41B6B0((uint64_t)&v18.n128_i64[1], (uint64_t)&v38);
  v35 = v37;
  LODWORD(v37[0]) = HIDWORD(qword_1EBCC3FAC);
  HIDWORD(v37[0]) = qword_1EBCC3FAC;
  uint64_t v36 = 0xC00000002;
  int v21 = 8;
  unint64_t v22 = v24;
  uint64_t v23 = 0xC00000000;
  sub_1CD41B6B0((uint64_t)&v22, (uint64_t)&v35);
  uint64_t v12 = 0;
  qword_1EBCC4040 = 0;
  qword_1EBCC4048 = 0;
  qword_1EBCC4038 = (uint64_t)&qword_1EBCC4040;
  do
  {
    sub_1CBF8B16C(&qword_1EBCC4038, &qword_1EBCC4040, v18.n128_u32[v12], (__n128 *)((char *)&v18 + v12 * 4));
    v12 += 18;
  }
  while (v12 != 36);
  for (uint64_t m = 0; m != -18; m -= 9)
  {
    unsigned int v14 = (&v22)[m];
    if (&v24[m * 8] != v14) {
      free(v14);
    }
  }
  if (v35 != v37) {
    free(v35);
  }
  if (v38 != v40) {
    free(v38);
  }
  return __cxa_atexit((void (*)(void *))sub_1CBF83748, &qword_1EBCC4038, &dword_1CB82C000);
}

void llvm::FindFunctionBackedges(uint64_t a1, uint64_t a2)
{
  v109[24] = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(void *)(a1 + 80);
  if (v8) {
    uint64_t v9 = v8 - 24;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(void *)(v9 + 40);
  if (v10 == v9 + 40) {
    return;
  }
  if (v10) {
    uint64_t v11 = v10 - 24;
  }
  else {
    uint64_t v11 = 0;
  }
  if (*(unsigned char *)(v11 + 16) != 30)
  {
    switch(*(unsigned char *)(v11 + 16))
    {
      case 0x1E:
LABEL_194:
        __break(1u);
        goto LABEL_195;
      case 0x1F:
        int v91 = (*(_DWORD *)(v11 + 20) >> 1) & 0x3FFFFFF;
        goto LABEL_191;
      case 0x20:
      case 0x26:
        int v91 = (*(_DWORD *)(v11 + 20) & 0x7FFFFFF) - 1;
        goto LABEL_191;
      case 0x21:
      case 0x25:
        break;
      case 0x24:
        int v91 = *(_WORD *)(v11 + 18) & 1;
        goto LABEL_191;
      case 0x27:
        int v91 = *(_DWORD *)(v11 + 80) + 1;
LABEL_191:
        if (!v91) {
          return;
        }
        break;
      default:
        return;
    }
  }
  v102 = (char *)v106;
  v103 = (char *)v106;
  int v105 = 0;
  uint64_t v2 = v109;
  v107 = v109;
  v97 = (char *)v101;
  v98 = (char *)v101;
  int v100 = 0;
  uint64_t v104 = 0x100000008;
  v106[0] = v9;
  v109[0] = v9;
  v109[1] = v11;
  v109[2] = 0;
  int v3 = 1;
  uint64_t v108 = 0x800000001;
  unsigned int v4 = 24;
  uint64_t v5 = -2;
  v101[0] = v9;
  uint64_t v6 = &v95;
  unsigned int v13 = 1;
  uint64_t v99 = 0x100000008;
  do
  {
    unsigned int v14 = (char *)v107 + v13 * (unint64_t)v4;
    uint64_t v15 = *((void *)v14 - 3);
    int v16 = (void *)(v15 + 40);
    while (1)
    {
      int v17 = (void *)*v16;
      if ((void *)*v16 == v16)
      {
LABEL_193:
        int v77 = 0;
      }
      else
      {
        __n128 v18 = v17 - 3;
        if (!v17) {
          __n128 v18 = 0;
        }
        int v19 = *((unsigned __int8 *)v18 + 16);
        int v20 = v19 - 29;
        if (v19 != 30)
        {
          int v77 = 0;
          switch(v20)
          {
            case 0:
            case 5:
            case 6:
              goto LABEL_19;
            case 1:
              goto LABEL_194;
            case 2:
              int v77 = (*((_DWORD *)v18 + 5) >> 1) & 0x3FFFFFF;
              goto LABEL_19;
            case 3:
            case 9:
              int v77 = (*((_DWORD *)v18 + 5) & 0x7FFFFFF) - 1;
              goto LABEL_19;
            case 4:
              int v77 = 2;
              goto LABEL_19;
            case 7:
              int v77 = *((_WORD *)v18 + 9) & 1;
              goto LABEL_19;
            case 8:
              int v77 = 1;
              goto LABEL_19;
            case 10:
              int v77 = *((_DWORD *)v18 + 20) + 1;
              goto LABEL_19;
            default:
              goto LABEL_193;
          }
        }
        int v77 = (*((_DWORD *)v18 + 5) & 0x7FFFFFF) == 3 ? v3 + 1 : v3;
      }
LABEL_19:
      int v21 = *((_DWORD *)v14 - 2);
      if (v21 == v77) {
        break;
      }
      uint64_t v23 = *((void *)v14 - 2);
      uint64_t v22 = *((void *)v14 - 1);
      *((_DWORD *)v14 - 2) = v21 + 1;
      if (*(unsigned char *)(v23 + 16) == 30)
      {
        uint64_t v24 = v23 - 32 * v22;
LABEL_22:
        int v25 = (uint64_t *)(v24 - 32);
      }
      else
      {
        switch(*(unsigned char *)(v23 + 16))
        {
          case ' ':
          case '&':
            int v92 = *(_DWORD *)(v23 + 20);
            if ((v92 & 0x40000000) != 0) {
              uint64_t v93 = *(void *)(v23 - 8);
            }
            else {
              uint64_t v93 = v23 - 32 * (v92 & 0x7FFFFFF);
            }
            int v25 = (uint64_t *)(v93 + 32 * (v22 + 1));
            break;
          case '!':
            BOOL v31 = v22 == 0;
            uint64_t v94 = -64;
            if (v31) {
              uint64_t v94 = -96;
            }
            int v25 = (uint64_t *)(v23 + v94);
            break;
          case '""':
          case '#':
            goto LABEL_194;
          case '$':
            if ((*(_WORD *)(v23 + 18) & 1) == 0)
            {
              uint64_t v7 = 0;
              goto LABEL_24;
            }
            uint64_t v88 = v23 - 32 * (*(_DWORD *)(v23 + 20) & 0x7FFFFFF);
LABEL_162:
            int v25 = (uint64_t *)(v88 + 32);
            break;
          case '%':
            int v25 = (uint64_t *)(v23 - 32);
            break;
          case '\'':
            if (v22)
            {
              uint64_t v24 = v23 - 32 * *(unsigned int *)(v23 + 80) + 32 * (v22 - 1);
              goto LABEL_22;
            }
            int v25 = (uint64_t *)(v23 - 32 * *(unsigned int *)(v23 + 80) - 64);
            break;
          default:
            int v86 = *(_DWORD *)(v23 + 20);
            if ((v86 & 0x40000000) != 0) {
              uint64_t v87 = *(void *)(v23 - 8);
            }
            else {
              uint64_t v87 = v23 - 32 * (v86 & 0x7FFFFFF);
            }
            uint64_t v88 = v87 + 32 * (2 * v22);
            goto LABEL_162;
        }
      }
      uint64_t v7 = *v25;
LABEL_24:
      int v26 = v103;
      uint64_t v27 = HIDWORD(v104);
      if (v103 == v102)
      {
        if (HIDWORD(v104))
        {
          int v28 = 0;
          uint64_t v29 = 8 * HIDWORD(v104);
          v30 = v103;
          while (*(void *)v30 != v7)
          {
            if (*(void *)v30 == -2) {
              int v28 = v30;
            }
            v30 += 8;
            v29 -= 8;
            if (!v29)
            {
              if (!v28) {
                goto LABEL_33;
              }
              *(void *)int v28 = v7;
              --v105;
              goto LABEL_78;
            }
          }
          goto LABEL_126;
        }
LABEL_33:
        unsigned int v39 = v104;
        if (HIDWORD(v104) < v104)
        {
          ++HIDWORD(v104);
          *(void *)&v103[8 * v27] = v7;
          goto LABEL_78;
        }
      }
      else
      {
        unsigned int v39 = v104;
      }
      if (3 * v39 <= 4 * (HIDWORD(v104) - v105))
      {
        if (v39 >= 0x40) {
          v39 *= 2;
        }
        else {
          unsigned int v39 = 128;
        }
      }
      else if (v39 - HIDWORD(v104) >= v39 >> 3)
      {
        goto LABEL_51;
      }
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v102, v39);
      unsigned int v39 = v104;
      int v26 = v103;
LABEL_51:
      unsigned int v40 = v39 - 1;
      unsigned int v35 = (v39 - 1) & ((v7 >> 4) ^ (v7 >> 9));
      uint64_t v36 = &v26[8 * v35];
      uint64_t v37 = *(void *)v36;
      if (*(void *)v36 == -1)
      {
        uint64_t v32 = 0;
LABEL_44:
        if (v32) {
          int v38 = v32;
        }
        else {
          int v38 = v36;
        }
        if (*(void *)v38 != v7)
        {
          if (*(void *)v38 == -2) {
            --v105;
          }
          else {
            ++HIDWORD(v104);
          }
          *(void *)int v38 = v7;
LABEL_78:
          v52 = v98;
          uint64_t v53 = HIDWORD(v99);
          if (v98 != v97)
          {
            unsigned int v61 = v99;
            goto LABEL_97;
          }
          if (HIDWORD(v99))
          {
            uint64_t v54 = 0;
            uint64_t v55 = 8 * HIDWORD(v99);
            v56 = v98;
            while (*(void *)v56 != v7)
            {
              if (*(void *)v56 == -2) {
                uint64_t v54 = v56;
              }
              v56 += 8;
              v55 -= 8;
              if (!v55)
              {
                if (!v54) {
                  goto LABEL_87;
                }
                *(void *)uint64_t v54 = v7;
                --v100;
                goto LABEL_89;
              }
            }
            goto LABEL_89;
          }
LABEL_87:
          unsigned int v61 = v99;
          if (HIDWORD(v99) < v99)
          {
            ++HIDWORD(v99);
            *(void *)&v98[8 * v53] = v7;
LABEL_89:
            uint64_t v57 = *(void *)(v7 + 40);
            if (v57 == v7 + 40)
            {
LABEL_195:
              uint64_t v58 = 0;
            }
            else
            {
              if (v57) {
                uint64_t v58 = v57 - 24;
              }
              else {
                uint64_t v58 = 0;
              }
              if (*(unsigned __int8 *)(v58 + 16) - 29 >= 0xB) {
                uint64_t v58 = 0;
              }
            }
            *(void *)&long long v95 = v7;
            *((void *)&v95 + 1) = v58;
            uint64_t v96 = 0;
            if (v108 >= HIDWORD(v108))
            {
              if (v107 > v6 || (char *)v107 + v108 * (unint64_t)v4 <= (char *)v6) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            v59 = (char *)v107 + v108 * (unint64_t)v4;
            long long v60 = v95;
            *((void *)v59 + 2) = v96;
            *(_OWORD *)v59 = v60;
            unsigned int v13 = v108 + 1;
            LODWORD(v108) = v108 + 1;
            goto LABEL_76;
          }
LABEL_97:
          if (3 * v61 <= 4 * (HIDWORD(v99) - v100))
          {
            if (v61 >= 0x40) {
              v61 *= 2;
            }
            else {
              unsigned int v61 = 128;
            }
          }
          else if (v61 - HIDWORD(v99) >= v61 >> 3)
          {
            goto LABEL_99;
          }
          llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v97, v61);
          unsigned int v61 = v99;
          v52 = v98;
LABEL_99:
          unsigned int v62 = v61 - 1;
          unsigned int v63 = (v61 - 1) & ((v7 >> 4) ^ (v7 >> 9));
          v64 = &v52[8 * v63];
          uint64_t v65 = *(void *)v64;
          if (*(void *)v64 == -1)
          {
            v78 = 0;
LABEL_132:
            if (v78) {
              v79 = v78;
            }
            else {
              v79 = v64;
            }
            if (*(void *)v79 != v7)
            {
              if (*(void *)v79 == -2) {
                --v100;
              }
              else {
                ++HIDWORD(v99);
              }
              *(void *)v79 = v7;
            }
          }
          else
          {
            v78 = 0;
            int v66 = 1;
            while (v65 != v7)
            {
              if (v78) {
                BOOL v67 = 0;
              }
              else {
                BOOL v67 = v65 == v5;
              }
              if (v67) {
                v78 = v64;
              }
              unsigned int v68 = v63 + v66++;
              unsigned int v63 = v68 & v62;
              v64 = &v52[8 * (v68 & v62)];
              uint64_t v65 = *(void *)v64;
              if (*(void *)v64 == -1) {
                goto LABEL_132;
              }
            }
          }
          goto LABEL_89;
        }
      }
      else
      {
        uint64_t v32 = 0;
        int v34 = 1;
        while (v37 != v7)
        {
          if (v32) {
            BOOL v31 = 0;
          }
          else {
            BOOL v31 = v37 == v5;
          }
          if (v31) {
            uint64_t v32 = v36;
          }
          unsigned int v33 = v35 + v34++;
          unsigned int v35 = v33 & v40;
          uint64_t v36 = &v26[8 * (v33 & v40)];
          uint64_t v37 = *(void *)v36;
          if (*(void *)v36 == -1) {
            goto LABEL_44;
          }
        }
      }
LABEL_126:
      v42 = v97;
      if (v98 == v97)
      {
        int v76 = HIDWORD(v99);
        v89 = &v98[8 * HIDWORD(v99)];
        if (HIDWORD(v99))
        {
          uint64_t v41 = 0;
          while (*(void *)&v98[v41] != v7)
          {
            v41 += 8;
            if (8 * HIDWORD(v99) == v41) {
              goto LABEL_57;
            }
          }
          v89 = &v98[v41];
        }
LABEL_57:
        v42 = v98;
      }
      else
      {
        int v80 = v99 - 1;
        unsigned int v81 = (v99 - 1) & ((v7 >> 4) ^ (v7 >> 9));
        v89 = &v98[8 * v81];
        uint64_t v82 = *(void *)v89;
        if (*(void *)v89 == -1)
        {
          v90 = 0;
LABEL_169:
          if (v90) {
            v89 = v90;
          }
          int v76 = HIDWORD(v99);
          if (*(void *)v89 != v7) {
            v89 = &v98[8 * v99];
          }
        }
        else
        {
          v90 = 0;
          int v83 = 1;
          while (v82 != v7)
          {
            if (v90) {
              BOOL v84 = 0;
            }
            else {
              BOOL v84 = v82 == v5;
            }
            if (v84) {
              v90 = v89;
            }
            unsigned int v85 = v81 + v83++;
            unsigned int v81 = v85 & v80;
            v89 = &v98[8 * (v85 & v80)];
            uint64_t v82 = *(void *)v89;
            if (*(void *)v89 == -1) {
              goto LABEL_169;
            }
          }
          int v76 = HIDWORD(v99);
        }
      }
      if (v98 == v42) {
        int v43 = v76;
      }
      else {
        int v43 = v99;
      }
      if (v89 != &v98[8 * v43])
      {
        unint64_t v44 = *(unsigned int *)(a2 + 8);
        if (v44 >= *(unsigned int *)(a2 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        unsigned int v45 = (void *)(*(void *)a2 + 16 * v44);
        *unsigned int v45 = v15;
        v45[1] = v7;
        ++*(_DWORD *)(a2 + 8);
      }
    }
    uint64_t v46 = *(void *)((char *)v107 + v108 * (unint64_t)v4 - 24);
    unsigned int v13 = v108 - 1;
    LODWORD(v108) = v108 - 1;
    v47 = v97;
    if (v98 == v97)
    {
      int v48 = HIDWORD(v99);
      int v49 = &v98[8 * HIDWORD(v99)];
      if (HIDWORD(v99))
      {
        uint64_t v50 = 0;
        while (*(void *)&v98[v50] != v46)
        {
          v50 += 8;
          if (8 * HIDWORD(v99) == v50) {
            goto LABEL_71;
          }
        }
        int v49 = &v98[v50];
      }
LABEL_71:
      v47 = v98;
    }
    else
    {
      int v69 = v99 - 1;
      unsigned int v70 = (v99 - 1) & ((v46 >> 4) ^ (v46 >> 9));
      int v49 = &v98[8 * v70];
      uint64_t v71 = *(void *)v49;
      if (*(void *)v49 == -1)
      {
        v72 = 0;
LABEL_141:
        if (v72) {
          int v49 = v72;
        }
        int v48 = HIDWORD(v99);
        if (*(void *)v49 != v46) {
          int v49 = &v98[8 * v99];
        }
      }
      else
      {
        v72 = 0;
        int v73 = 1;
        while (v71 != v46)
        {
          if (v72) {
            BOOL v74 = 0;
          }
          else {
            BOOL v74 = v71 == v5;
          }
          if (v74) {
            v72 = v49;
          }
          unsigned int v75 = v70 + v73++;
          unsigned int v70 = v75 & v69;
          int v49 = &v98[8 * (v75 & v69)];
          uint64_t v71 = *(void *)v49;
          if (*(void *)v49 == -1) {
            goto LABEL_141;
          }
        }
        int v48 = HIDWORD(v99);
      }
    }
    int v51 = v99;
    if (v98 == v47) {
      int v51 = v48;
    }
    if (v49 != &v98[8 * v51])
    {
      *(void *)int v49 = v5;
      ++v100;
    }
LABEL_76:
    ;
  }
  while (v13);
  if (v98 != v97) {
    free(v98);
  }
  if (v107 != v2) {
    free(v107);
  }
  if (v103 != v102) {
    free(v103);
  }
}

uint64_t llvm::GetSuccessorNumber(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2 == a1 + 40)
  {
    uint64_t v4 = 0;
  }
  else
  {
    if (v2) {
      uint64_t v3 = v2 - 24;
    }
    else {
      uint64_t v3 = 0;
    }
    if (*(unsigned __int8 *)(v3 + 16) - 29 >= 0xB) {
      uint64_t v4 = 0;
    }
    else {
      uint64_t v4 = v3;
    }
  }
  unsigned int v5 = 0;
  int v6 = *(unsigned __int8 *)(v4 + 16);
  uint64_t v7 = v4 - 32;
  unsigned int v8 = 1;
  do
  {
    if (v6 == 30)
    {
      uint64_t v9 = (uint64_t *)(v7 - 32 * v5);
    }
    else
    {
      uint64_t v9 = (uint64_t *)(v4 - 32);
      switch(v6)
      {
        case ' ':
        case '&':
          goto LABEL_21;
        case '!':
          uint64_t v16 = -64;
          if (!v5) {
            uint64_t v16 = -96;
          }
          uint64_t v9 = (uint64_t *)(v4 + v16);
          break;
        case '""':
        case '#':
          __break(1u);
LABEL_21:
          int v15 = *(_DWORD *)(v4 + 20);
          if ((v15 & 0x40000000) != 0) {
            uint64_t v13 = *(void *)(v4 - 8);
          }
          else {
            uint64_t v13 = v4 - 32 * (v15 & 0x7FFFFFF);
          }
          uint64_t v14 = v5 + 1;
          goto LABEL_18;
        case '$':
          if ((*(_WORD *)(v4 + 18) & 1) == 0)
          {
            uint64_t v10 = 0;
            goto LABEL_12;
          }
          uint64_t v9 = (uint64_t *)(v4 - 32 * (*(_DWORD *)(v4 + 20) & 0x7FFFFFF) + 32);
          break;
        case '%':
          break;
        case '\'':
          uint64_t v9 = (uint64_t *)(v4 - 32 * *(unsigned int *)(v4 + 80) - 64);
          if (v5) {
            uint64_t v9 = (uint64_t *)(v7 - 32 * *(unsigned int *)(v4 + 80) + 32 * (v5 - 1));
          }
          break;
        default:
          int v12 = *(_DWORD *)(v4 + 20);
          if ((v12 & 0x40000000) != 0) {
            uint64_t v13 = *(void *)(v4 - 8);
          }
          else {
            uint64_t v13 = v4 - 32 * (v12 & 0x7FFFFFF);
          }
          uint64_t v14 = v8;
LABEL_18:
          uint64_t v9 = (uint64_t *)(v13 + 32 * v14);
          break;
      }
    }
    uint64_t v10 = *v9;
LABEL_12:
    ++v5;
    v8 += 2;
  }
  while (v10 != a2);
  return v5 - 1;
}

BOOL llvm::isCriticalEdge(llvm *this, const llvm::Instruction *a2, int a3)
{
  if (*((unsigned char *)this + 16) == 30)
  {
    uint64_t v3 = (char *)this - 32 * a2;
LABEL_3:
    uint64_t v4 = (uint64_t *)(v3 - 32);
  }
  else
  {
    switch(*((unsigned char *)this + 16))
    {
      case ' ':
      case '&':
        int v9 = *((_DWORD *)this + 5);
        if ((v9 & 0x40000000) != 0) {
          uint64_t v7 = (char *)*((void *)this - 1);
        }
        else {
          uint64_t v7 = (char *)this - 32 * (v9 & 0x7FFFFFF);
        }
        uint64_t v8 = (a2 + 1);
        goto LABEL_10;
      case '!':
        uint64_t v10 = -64;
        if (!a2) {
          uint64_t v10 = -96;
        }
        uint64_t v4 = (uint64_t *)((char *)this + v10);
        break;
      case '""':
      case '#':
        __break(1u);
        goto LABEL_17;
      case '$':
LABEL_17:
        if ((*((_WORD *)this + 9) & 1) == 0)
        {
          uint64_t v5 = 0;
          return llvm::isCriticalEdge((uint64_t)this, v5, a3);
        }
        uint64_t v4 = (uint64_t *)((char *)this - 32 * (*((_DWORD *)this + 5) & 0x7FFFFFF) + 32);
        break;
      case '%':
        uint64_t v4 = (uint64_t *)((char *)this - 32);
        break;
      case '\'':
        if (a2)
        {
          uint64_t v3 = (char *)this + 32 * (a2 - 1) + -32 * *((unsigned int *)this + 20);
          goto LABEL_3;
        }
        uint64_t v4 = (uint64_t *)((char *)this - 32 * *((unsigned int *)this + 20) - 64);
        break;
      default:
        int v6 = *((_DWORD *)this + 5);
        if ((v6 & 0x40000000) != 0) {
          uint64_t v7 = (char *)*((void *)this - 1);
        }
        else {
          uint64_t v7 = (char *)this - 32 * (v6 & 0x7FFFFFF);
        }
        uint64_t v8 = (2 * a2) | 1u;
LABEL_10:
        uint64_t v4 = (uint64_t *)&v7[32 * v8];
        break;
    }
  }
  uint64_t v5 = *v4;
  return llvm::isCriticalEdge((uint64_t)this, v5, a3);
}

BOOL llvm::isCriticalEdge(uint64_t a1, uint64_t a2, int a3)
{
  int v4 = *(unsigned __int8 *)(a1 + 16);
  if (v4 != 30)
  {
    BOOL result = 0;
    switch(v4)
    {
      case 30:
        __break(1u);
        goto LABEL_43;
      case 31:
        int v20 = (*(_DWORD *)(a1 + 20) >> 1) & 0x3FFFFFF;
        goto LABEL_40;
      case 32:
      case 38:
LABEL_43:
        int v20 = (*(_DWORD *)(a1 + 20) & 0x7FFFFFF) - 1;
        goto LABEL_40;
      case 36:
        int v20 = *(_WORD *)(a1 + 18) & 1;
        goto LABEL_40;
      case 37:
        return result;
      case 39:
        int v20 = *(_DWORD *)(a1 + 80) + 1;
LABEL_40:
        if (v20 == 1) {
          return 0;
        }
        goto LABEL_3;
      default:
        goto LABEL_3;
    }
  }
  if ((*(_DWORD *)(a1 + 20) & 0x7FFFFFF) != 3) {
    return 0;
  }
LABEL_3:
  for (uint64_t i = *(void *)(a2 + 8); i; uint64_t i = *(void *)(i + 8))
  {
    uint64_t v6 = *(void *)(i + 24);
    unsigned int v7 = *(unsigned __int8 *)(v6 + 16);
    if (v6) {
      BOOL v8 = v7 >= 0x1C;
    }
    else {
      BOOL v8 = 0;
    }
    if (v8 && v7 - 29 < 0xB) {
      break;
    }
  }
  uint64_t v10 = *(void *)(*(void *)(i + 24) + 40);
  do
  {
    uint64_t i = *(void *)(i + 8);
    BOOL result = i != 0;
    if (!i) {
      return (a3 & 1) == 0 && i != 0;
    }
    uint64_t v12 = *(void *)(i + 24);
    unsigned int v13 = *(unsigned __int8 *)(v12 + 16);
    if (v12) {
      BOOL v14 = v13 >= 0x1C;
    }
    else {
      BOOL v14 = 0;
    }
  }
  while (!v14 || v13 - 29 > 0xA);
  if (a3)
  {
    if (*(void *)(v12 + 40) == v10)
    {
      do
      {
        uint64_t i = *(void *)(i + 8);
        BOOL result = i != 0;
        if (!i) {
          break;
        }
        uint64_t v16 = *(void *)(i + 24);
        unsigned int v17 = *(unsigned __int8 *)(v16 + 16);
        BOOL v18 = v16 && v17 >= 0x1C;
        BOOL v19 = !v18 || v17 - 29 > 0xA;
      }
      while (v19 || *(void *)(v16 + 40) == v10);
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t llvm::isPotentiallyReachableFromMany(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t *a5)
{
  if (a4) {
    llvm::DominatorTreeBase<llvm::BasicBlock,false>::isReachableFromEntry();
  }
  int v9 = v139;
  v135 = v139;
  v136 = v139;
  uint64_t v137 = 8;
  int v138 = 0;
  if (a3 && a5)
  {
    uint64_t v10 = a3[1];
    uint64_t v11 = 16;
    if (v10 == *a3) {
      uint64_t v11 = 20;
    }
    uint64_t v12 = *(unsigned int *)((char *)a3 + v11);
    if (v12)
    {
      uint64_t v13 = 8 * v12;
      BOOL v14 = (unint64_t *)a3[1];
      while (*v14 >= 0xFFFFFFFFFFFFFFFELL)
      {
        ++v14;
        v13 -= 8;
        if (!v13) {
          goto LABEL_64;
        }
      }
    }
    else
    {
      BOOL v14 = (unint64_t *)a3[1];
    }
    int v15 = (unint64_t *)(v10 + 8 * v12);
    if (v14 != v15)
    {
      unsigned int v16 = 0;
      unint64_t v17 = *v14;
      unsigned int v18 = 8;
      BOOL v19 = v139;
LABEL_15:
      int v20 = *((_DWORD *)a5 + 4);
      if (!v20) {
        goto LABEL_54;
      }
      uint64_t v21 = *a5;
      unsigned int v22 = v20 - 1;
      uint64_t v23 = ((v17 >> 4) ^ (v17 >> 9)) & (v20 - 1);
      uint64_t v24 = *(void *)(*a5 + 16 * v23);
      if (v17 != v24)
      {
        int v25 = 1;
        while (v24 != -4096)
        {
          int v26 = v23 + v25++;
          uint64_t v23 = v26 & v22;
          uint64_t v24 = *(void *)(v21 + 16 * v23);
          if (v17 == v24) {
            goto LABEL_20;
          }
        }
        goto LABEL_54;
      }
LABEL_20:
      uint64_t v27 = *(void **)(v21 + 16 * v23 + 8);
      if (!v27)
      {
LABEL_54:
        uint64_t v41 = v14 + 1;
        while (v41 != v15)
        {
          unint64_t v42 = *v41++;
          unint64_t v17 = v42;
          if (v42 <= 0xFFFFFFFFFFFFFFFDLL)
          {
            BOOL v14 = v41 - 1;
            goto LABEL_15;
          }
        }
        goto LABEL_64;
      }
      do
      {
        int v28 = v27;
        uint64_t v27 = (void *)*v27;
      }
      while (v27);
      if (v19 == v9)
      {
        if (v16)
        {
          uint64_t v29 = 0;
          uint64_t v30 = 8 * v16;
          BOOL v31 = v9;
          while (*(void **)v31 != v28)
          {
            if (*(void *)v31 == -2) {
              uint64_t v29 = v31;
            }
            v31 += 8;
            v30 -= 8;
            if (!v30)
            {
              if (!v29) {
                goto LABEL_30;
              }
              *(void *)uint64_t v29 = v28;
              --v138;
              goto LABEL_53;
            }
          }
          goto LABEL_53;
        }
LABEL_30:
        if (v18 > v16)
        {
          HIDWORD(v137) = v16 + 1;
          *(void *)&v9[8 * v16] = v28;
LABEL_53:
          int v9 = v135;
          BOOL v19 = v136;
          unsigned int v18 = v137;
          unsigned int v16 = HIDWORD(v137);
          goto LABEL_54;
        }
      }
      if (3 * v18 <= 4 * (v16 - v138))
      {
        if (v18 >= 0x40) {
          v18 *= 2;
        }
        else {
          unsigned int v18 = 128;
        }
      }
      else if (v18 - v16 >= v18 >> 3)
      {
        goto LABEL_34;
      }
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v135, v18);
      unsigned int v18 = v137;
      BOOL v19 = v136;
LABEL_34:
      unsigned int v32 = v18 - 1;
      unsigned int v33 = (v18 - 1) & ((v28 >> 4) ^ (v28 >> 9));
      int v34 = &v19[8 * v33];
      unsigned int v35 = *(void **)v34;
      if (*(void *)v34 == -1)
      {
        uint64_t v36 = 0;
LABEL_46:
        if (v36) {
          unsigned int v40 = v36;
        }
        else {
          unsigned int v40 = v34;
        }
        if (*(void **)v40 != v28)
        {
          if (*(void *)v40 == -2) {
            --v138;
          }
          else {
            ++HIDWORD(v137);
          }
          *(void *)unsigned int v40 = v28;
        }
      }
      else
      {
        uint64_t v36 = 0;
        int v37 = 1;
        while (v35 != v28)
        {
          if (v36) {
            BOOL v38 = 0;
          }
          else {
            BOOL v38 = v35 == (void *)-2;
          }
          if (v38) {
            uint64_t v36 = v34;
          }
          unsigned int v39 = v33 + v37++;
          unsigned int v33 = v39 & v32;
          int v34 = &v19[8 * (v39 & v32)];
          unsigned int v35 = *(void **)v34;
          if (*(void *)v34 == -1) {
            goto LABEL_46;
          }
        }
      }
      goto LABEL_53;
    }
  }
LABEL_64:
  if (a5)
  {
    int v43 = *((_DWORD *)a5 + 4);
    if (v43)
    {
      uint64_t v44 = *a5;
      unsigned int v45 = v43 - 1;
      uint64_t v46 = (v43 - 1) & ((a2 >> 4) ^ (a2 >> 9));
      uint64_t v47 = *(void *)(*a5 + 16 * v46);
      if (v47 == a2)
      {
LABEL_70:
        uint64_t v50 = *(void **)(v44 + 16 * v46 + 8);
        if (v50)
        {
          do
          {
            int v51 = v50;
            uint64_t v50 = (void *)*v50;
          }
          while (v50);
          goto LABEL_74;
        }
      }
      else
      {
        int v48 = 1;
        while (v47 != -4096)
        {
          int v49 = v46 + v48++;
          uint64_t v46 = v49 & v45;
          uint64_t v47 = *(void *)(v44 + 16 * v46);
          if (v47 == a2) {
            goto LABEL_70;
          }
        }
      }
    }
  }
  int v51 = 0;
LABEL_74:
  int v52 = dword_1EBCC4190;
  v130 = v134;
  v131 = v134;
  uint64_t v132 = 32;
  int v133 = 0;
  unsigned int v53 = *(_DWORD *)(a1 + 8);
  do
  {
    while (1)
    {
      uint64_t v54 = *(void *)(*(void *)a1 + 8 * v53 - 8);
      *(_DWORD *)(a1 + 8) = v53 - 1;
      uint64_t v55 = v131;
      uint64_t v56 = HIDWORD(v132);
      if (v131 == v130)
      {
        if (HIDWORD(v132))
        {
          uint64_t v57 = 0;
          uint64_t v58 = 8 * HIDWORD(v132);
          v59 = v131;
          while (*(void *)v59 != v54)
          {
            if (*(void *)v59 == -2) {
              uint64_t v57 = v59;
            }
            v59 += 8;
            v58 -= 8;
            if (!v58)
            {
              if (!v57) {
                goto LABEL_84;
              }
              *(void *)uint64_t v57 = v54;
              --v133;
              goto LABEL_107;
            }
          }
          goto LABEL_176;
        }
LABEL_84:
        unsigned int v60 = v132;
        if (HIDWORD(v132) < v132)
        {
          ++HIDWORD(v132);
          *(void *)&v131[8 * v56] = v54;
          goto LABEL_107;
        }
      }
      else
      {
        unsigned int v60 = v132;
      }
      if (3 * v60 <= 4 * (HIDWORD(v132) - v133))
      {
        if (v60 >= 0x40) {
          v60 *= 2;
        }
        else {
          unsigned int v60 = 128;
        }
      }
      else if (v60 - HIDWORD(v132) >= v60 >> 3)
      {
        goto LABEL_88;
      }
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v130, v60);
      unsigned int v60 = v132;
      uint64_t v55 = v131;
LABEL_88:
      unsigned int v61 = v60 - 1;
      unsigned int v62 = (v60 - 1) & ((v54 >> 4) ^ (v54 >> 9));
      unsigned int v63 = &v55[8 * v62];
      uint64_t v64 = *(void *)v63;
      if (*(void *)v63 != -1)
      {
        unsigned int v68 = 0;
        int v65 = 1;
        while (v64 != v54)
        {
          if (v68) {
            BOOL v66 = 0;
          }
          else {
            BOOL v66 = v64 == -2;
          }
          if (v66) {
            unsigned int v68 = v63;
          }
          unsigned int v67 = v62 + v65++;
          unsigned int v62 = v67 & v61;
          unsigned int v63 = &v55[8 * (v67 & v61)];
          uint64_t v64 = *(void *)v63;
          if (*(void *)v63 == -1) {
            goto LABEL_99;
          }
        }
        goto LABEL_176;
      }
      unsigned int v68 = 0;
LABEL_99:
      int v69 = v68 ? v68 : v63;
      if (*(void *)v69 != v54) {
        break;
      }
LABEL_176:
      unsigned int v53 = *(_DWORD *)(a1 + 8);
      if (!v53) {
        goto LABEL_243;
      }
    }
    if (*(void *)v69 == -2) {
      --v133;
    }
    else {
      ++HIDWORD(v132);
    }
    *(void *)int v69 = v54;
LABEL_107:
    if (v54 == a2) {
      goto LABEL_242;
    }
    if (a3)
    {
      uint64_t v71 = *a3;
      uint64_t v70 = a3[1];
      if (v70 == *a3)
      {
        uint64_t v72 = *((unsigned int *)a3 + 5);
        int v73 = (void *)(v70 + 8 * v72);
        if (v72)
        {
          uint64_t v74 = 0;
          uint64_t v75 = 8 * v72;
          while (*(void *)(v70 + v74) != v54)
          {
            v74 += 8;
            if (v75 == v74) {
              goto LABEL_128;
            }
          }
          int v73 = (void *)(v70 + v74);
        }
LABEL_128:
        uint64_t v71 = a3[1];
      }
      else
      {
        uint64_t v76 = *((unsigned int *)a3 + 4);
        int v77 = v76 - 1;
        unsigned int v78 = (v76 - 1) & ((v54 >> 4) ^ (v54 >> 9));
        int v73 = (void *)(v70 + 8 * v78);
        uint64_t v79 = *v73;
        if (*v73 == -1)
        {
          v126 = 0;
LABEL_218:
          if (v126) {
            int v73 = v126;
          }
          if (*v73 != v54) {
            int v73 = (void *)(v70 + 8 * v76);
          }
        }
        else
        {
          v126 = 0;
          int v80 = 1;
          while (v79 != v54)
          {
            if (v126) {
              BOOL v81 = 0;
            }
            else {
              BOOL v81 = v79 == -2;
            }
            if (v81) {
              v126 = v73;
            }
            unsigned int v82 = v78 + v80++;
            unsigned int v78 = v82 & v77;
            int v73 = (void *)(v70 + 8 * (v82 & v77));
            uint64_t v79 = *v73;
            if (*v73 == -1) {
              goto LABEL_218;
            }
          }
        }
      }
      int v83 = v70 == v71 ? (unsigned int *)((char *)a3 + 20) : (unsigned int *)(a3 + 2);
      if (v73 != (void *)(v70 + 8 * *v83)) {
        goto LABEL_176;
      }
    }
    if (!a5)
    {
      if (!--v52) {
        goto LABEL_242;
      }
      goto LABEL_178;
    }
    int v84 = *((_DWORD *)a5 + 4);
    if (v84)
    {
      uint64_t v85 = *a5;
      unsigned int v86 = v84 - 1;
      uint64_t v87 = (v84 - 1) & ((v54 >> 4) ^ (v54 >> 9));
      uint64_t v88 = *(void *)(*a5 + 16 * v87);
      if (v54 == v88)
      {
LABEL_139:
        int v91 = *(void **)(v85 + 16 * v87 + 8);
        if (v91)
        {
          do
          {
            int v92 = v91;
            int v91 = (void *)*v91;
          }
          while (v91);
          goto LABEL_143;
        }
      }
      else
      {
        int v89 = 1;
        while (v88 != -4096)
        {
          int v90 = v87 + v89++;
          uint64_t v87 = v90 & v86;
          uint64_t v88 = *(void *)(v85 + 16 * v87);
          if (v54 == v88) {
            goto LABEL_139;
          }
        }
      }
    }
    int v92 = 0;
LABEL_143:
    uint64_t v93 = v135;
    if (v136 == v135)
    {
      int v94 = HIDWORD(v137);
      long long v95 = &v136[8 * HIDWORD(v137)];
      if (HIDWORD(v137))
      {
        uint64_t v96 = 0;
        while (*(void **)&v136[v96] != v92)
        {
          v96 += 8;
          if (8 * HIDWORD(v137) == v96) {
            goto LABEL_164;
          }
        }
        long long v95 = &v136[v96];
      }
LABEL_164:
      uint64_t v93 = v136;
    }
    else
    {
      int v97 = v137 - 1;
      unsigned int v98 = (v137 - 1) & ((v92 >> 4) ^ (v92 >> 9));
      long long v95 = &v136[8 * v98];
      uint64_t v99 = *(void **)v95;
      if (*(void *)v95 == -1)
      {
        int v100 = 0;
LABEL_224:
        if (v100) {
          long long v95 = v100;
        }
        int v94 = HIDWORD(v137);
        if (*(void **)v95 != v92) {
          long long v95 = &v136[8 * v137];
        }
      }
      else
      {
        int v100 = 0;
        int v101 = 1;
        while (v99 != v92)
        {
          if (v100) {
            BOOL v102 = 0;
          }
          else {
            BOOL v102 = v99 == (void *)-2;
          }
          if (v102) {
            int v100 = v95;
          }
          unsigned int v103 = v98 + v101++;
          unsigned int v98 = v103 & v97;
          long long v95 = &v136[8 * (v103 & v97)];
          uint64_t v99 = *(void **)v95;
          if (*(void *)v95 == -1) {
            goto LABEL_224;
          }
        }
        int v94 = HIDWORD(v137);
      }
    }
    if (v136 == v93) {
      int v104 = v94;
    }
    else {
      int v104 = v137;
    }
    if (v95 == &v136[8 * v104]) {
      int v105 = v92;
    }
    else {
      int v105 = 0;
    }
    if (v51 && v105 == v51 || (--v52, !v52))
    {
LABEL_242:
      uint64_t v128 = 1;
      goto LABEL_244;
    }
    if (v105) {
      llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getExitBlocks();
    }
LABEL_178:
    uint64_t v106 = *(void *)(v54 + 40);
    if (v106 == v54 + 40)
    {
LABEL_188:
      uint64_t v107 = 0;
      uint64_t v111 = 0;
    }
    else
    {
      uint64_t v107 = v106 - 24;
      if (v106) {
        uint64_t v108 = v106 - 24;
      }
      else {
        uint64_t v108 = 0;
      }
      int v109 = *(unsigned __int8 *)(v108 + 16);
      int v110 = v109 - 29;
      if (v109 != 30)
      {
        unsigned int v127 = 0;
        switch(v110)
        {
          case 0:
          case 5:
          case 6:
            goto LABEL_187;
          case 1:
LABEL_249:
            __break(1u);
            JUMPOUT(0x1CBF9254CLL);
          case 2:
            unsigned int v127 = (*(_DWORD *)(v108 + 20) >> 1) & 0x3FFFFFF;
            goto LABEL_187;
          case 3:
          case 9:
            unsigned int v127 = (*(_DWORD *)(v108 + 20) & 0x7FFFFFF) - 1;
            goto LABEL_187;
          case 4:
            unsigned int v127 = 2;
            goto LABEL_187;
          case 7:
            unsigned int v127 = *(_WORD *)(v108 + 18) & 1;
            goto LABEL_187;
          case 8:
            unsigned int v127 = 1;
            goto LABEL_187;
          case 10:
            unsigned int v127 = *(_DWORD *)(v108 + 80) + 1;
            goto LABEL_187;
          default:
            goto LABEL_188;
        }
      }
      if ((*(_DWORD *)(v108 + 20) & 0x7FFFFFF) == 3) {
        unsigned int v127 = 2;
      }
      else {
        unsigned int v127 = 1;
      }
LABEL_187:
      uint64_t v111 = v127;
    }
    uint64_t v112 = *(unsigned int *)(a1 + 8);
    if (v112 + (int)v111 > (unint64_t)*(unsigned int *)(a1 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    if (v111)
    {
      uint64_t v113 = 0;
      uint64_t v114 = 0;
      v115 = (void *)(*(void *)a1 + 8 * v112);
      int v116 = *(unsigned __int8 *)(v107 + 16);
      uint64_t v117 = v107 - 64;
      do
      {
        if (v116 == 30)
        {
          v119 = (uint64_t *)(v107 - 32 - 32 * v114);
        }
        else
        {
          v119 = (uint64_t *)(v107 - 32);
          switch(v116)
          {
            case ' ':
            case '&':
              int v123 = *(_DWORD *)(v107 + 20);
              if ((v123 & 0x40000000) != 0) {
                uint64_t v124 = *(void *)(v107 - 8);
              }
              else {
                uint64_t v124 = v107 - 32 * (v123 & 0x7FFFFFF);
              }
              uint64_t v122 = v124 + 32 * v114;
              goto LABEL_203;
            case '!':
              uint64_t v125 = -64;
              if (!v113) {
                uint64_t v125 = -96;
              }
              v119 = (uint64_t *)(v107 + v125);
              break;
            case '""':
            case '#':
              goto LABEL_249;
            case '$':
              if ((*(_WORD *)(v107 + 18) & 1) == 0)
              {
                uint64_t v118 = 0;
                goto LABEL_197;
              }
              v119 = (uint64_t *)(v107 + 32 - 32 * (*(_DWORD *)(v107 + 20) & 0x7FFFFFF));
              break;
            case '%':
              break;
            case '\'':
              if (v113) {
                v119 = (uint64_t *)(v117 - 32 * *(unsigned int *)(v107 + 80));
              }
              else {
                v119 = (uint64_t *)(v107 - 64 - 32 * *(unsigned int *)(v107 + 80));
              }
              break;
            default:
              int v120 = *(_DWORD *)(v107 + 20);
              if ((v120 & 0x40000000) != 0) {
                uint64_t v121 = *(void *)(v107 - 8);
              }
              else {
                uint64_t v121 = v107 - 32 * (v120 & 0x7FFFFFF);
              }
              uint64_t v122 = v121 + 32 * (v113 & 0xFFFFFFFE);
LABEL_203:
              v119 = (uint64_t *)(v122 + 32);
              break;
          }
        }
        uint64_t v118 = *v119;
LABEL_197:
        *v115++ = v118;
        ++v114;
        v113 += 2;
        v117 += 32;
      }
      while (2 * v111 != v113);
    }
    unsigned int v53 = v112 + v111;
    *(_DWORD *)(a1 + 8) = v53;
  }
  while (v53);
LABEL_243:
  uint64_t v128 = 0;
LABEL_244:
  if (v131 != v130) {
    free(v131);
  }
  if (v136 != v135) {
    free(v136);
  }
  return v128;
}

uint64_t llvm::isPotentiallyReachable(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t *a5)
{
  v8[32] = *MEMORY[0x1E4F143B8];
  if (a4) {
    llvm::DominatorTreeBase<llvm::BasicBlock,false>::isReachableFromEntry();
  }
  v7[0] = v8;
  v8[0] = a1;
  v7[1] = (void *)0x2000000001;
  uint64_t isPotentiallyReachableFromMany = llvm::isPotentiallyReachableFromMany((uint64_t)v7, a2, a3, 0, a5);
  if (v7[0] != v8) {
    free(v7[0]);
  }
  return isPotentiallyReachableFromMany;
}

uint64_t llvm::isPotentiallyReachable(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  v46[32] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a1 + 40);
  if (v6 == *(void *)(a2 + 40))
  {
    if (a5)
    {
      LODWORD(v9) = *(_DWORD *)(a5 + 16);
      if (v9)
      {
        uint64_t v10 = *(void *)a5;
        unsigned int v11 = v9 - 1;
        uint64_t v9 = (v9 - 1) & ((v6 >> 4) ^ (v6 >> 9));
        uint64_t v12 = *(void *)(*(void *)a5 + 16 * v9);
        if (v6 == v12)
        {
LABEL_11:
          LOBYTE(v9) = *(void *)(v10 + 16 * v9 + 8) != 0;
        }
        else
        {
          int v13 = 1;
          while (v12 != -4096)
          {
            int v14 = v9 + v13++;
            uint64_t v9 = v14 & v11;
            uint64_t v12 = *(void *)(v10 + 16 * v9);
            if (v6 == v12) {
              goto LABEL_11;
            }
          }
          LOBYTE(v9) = 0;
        }
      }
      uint64_t isPotentiallyReachableFromMany = 1;
      if (a1 == a2 || (v9 & 1) != 0) {
        return isPotentiallyReachableFromMany;
      }
    }
    else if (a1 == a2)
    {
      return 1;
    }
    int v16 = *(__int16 *)(v6 + 18);
    if ((v16 & 0x80000000) == 0)
    {
      uint64_t v30 = *(void *)(v6 + 48);
      if (v30 != v6 + 40)
      {
        int v31 = 0;
        do
        {
          uint64_t v32 = v30 - 24;
          if (!v30) {
            uint64_t v32 = 0;
          }
          *(_DWORD *)(v32 + 56) = v31++;
          uint64_t v30 = *(void *)(v30 + 8);
        }
        while (v30 != v6 + 40);
      }
      *(_WORD *)(v6 + 18) = v16 | 0x8000;
    }
    if (*(_DWORD *)(a1 + 56) >= *(_DWORD *)(a2 + 56))
    {
      uint64_t v17 = *(void *)(*(void *)(v6 + 56) + 80);
      if (v17) {
        uint64_t v18 = v17 - 24;
      }
      else {
        uint64_t v18 = 0;
      }
      if (v18 == v6) {
        return 0;
      }
      uint64_t v44 = v46;
      uint64_t v45 = 0x2000000000;
      uint64_t v19 = *(void *)(v6 + 40);
      if (v19 == v6 + 40)
      {
LABEL_60:
        unsigned int v33 = 0;
      }
      else
      {
        uint64_t v20 = v19 - 24;
        if (v19) {
          uint64_t v21 = v19 - 24;
        }
        else {
          uint64_t v21 = 0;
        }
        if (*(unsigned char *)(v21 + 16) == 30)
        {
          if ((*(_DWORD *)(v21 + 20) & 0x7FFFFFF) == 3) {
            unsigned int v33 = 2;
          }
          else {
            unsigned int v33 = 1;
          }
        }
        else
        {
          unsigned int v33 = 0;
          switch(*(unsigned char *)(v21 + 16))
          {
            case 0x1D:
            case 0x22:
            case 0x23:
              goto LABEL_34;
            case 0x1E:
LABEL_61:
              __break(1u);
              break;
            case 0x1F:
              unsigned int v33 = (*(_DWORD *)(v21 + 20) >> 1) & 0x3FFFFFF;
              goto LABEL_32;
            case 0x20:
            case 0x26:
              break;
            case 0x21:
              unsigned int v33 = 2;
              goto LABEL_34;
            case 0x24:
              unsigned int v33 = *(_WORD *)(v21 + 18) & 1;
              goto LABEL_32;
            case 0x25:
              unsigned int v33 = 1;
              goto LABEL_34;
            case 0x27:
              unsigned int v33 = *(_DWORD *)(v21 + 80) + 1;
              goto LABEL_32;
            default:
              goto LABEL_60;
          }
          unsigned int v33 = (*(_DWORD *)(v21 + 20) & 0x7FFFFFF) - 1;
        }
LABEL_32:
        if (v33 >= 0x21) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
LABEL_34:
        if (v33)
        {
          uint64_t v21 = 0;
          uint64_t v22 = 0;
          uint64_t v23 = v44;
          int v24 = *(unsigned __int8 *)(v19 - 8);
          int v25 = (uint64_t *)(v19 - 56);
          uint64_t v26 = v19 - 88;
          do
          {
            if (v24 == 30)
            {
              uint64_t v27 = &v25[-4 * v22];
            }
            else
            {
              uint64_t v27 = v25;
              switch(v24)
              {
                case ' ':
                case '&':
                  uint64_t v36 = v19;
                  int v37 = *(_DWORD *)(v19 - 4);
                  if ((v37 & 0x40000000) != 0) {
                    uint64_t v38 = *(void *)(v36 - 32);
                  }
                  else {
                    uint64_t v38 = v20 - 32 * (v37 & 0x7FFFFFF);
                  }
                  uint64_t v27 = (uint64_t *)(v38 + 32 * v22 + 32);
                  uint64_t v19 = v36;
                  break;
                case '!':
                  uint64_t v39 = -64;
                  if (!v21) {
                    uint64_t v39 = -96;
                  }
                  uint64_t v27 = (uint64_t *)(v20 + v39);
                  break;
                case '""':
                case '#':
                  goto LABEL_61;
                case '$':
                  if ((*(_WORD *)(v19 - 6) & 1) == 0)
                  {
                    uint64_t v28 = 0;
                    goto LABEL_39;
                  }
                  uint64_t v27 = (uint64_t *)(v19 - 32 * (*(_DWORD *)(v19 - 4) & 0x7FFFFFF) + 8);
                  break;
                case '%':
                  break;
                case '\'':
                  uint64_t v40 = *(unsigned int *)(v19 + 56);
                  uint64_t v41 = -v40;
                  unint64_t v42 = (uint64_t *)(v26 - 32 * v40);
                  uint64_t v43 = v19 + 32 * v41 - 88;
                  if (v21) {
                    uint64_t v27 = v42;
                  }
                  else {
                    uint64_t v27 = (uint64_t *)v43;
                  }
                  break;
                default:
                  int v34 = *(_DWORD *)(v19 - 4);
                  if ((v34 & 0x40000000) != 0) {
                    uint64_t v35 = *(void *)(v19 - 32);
                  }
                  else {
                    uint64_t v35 = v20 - 32 * (v34 & 0x7FFFFFF);
                  }
                  uint64_t v27 = (uint64_t *)(v35 + 32 * (v21 & 0xFFFFFFFE) + 32);
                  break;
              }
            }
            uint64_t v28 = *v27;
LABEL_39:
            *v23++ = v28;
            ++v22;
            v21 += 2;
            v26 += 32;
          }
          while (2 * v33 != v21);
        }
      }
      LODWORD(v45) = v33;
      if (v33) {
        uint64_t isPotentiallyReachableFromMany = llvm::isPotentiallyReachableFromMany((uint64_t)&v44, *(void *)(a2 + 40), a3, a4, (uint64_t *)a5);
      }
      else {
        uint64_t isPotentiallyReachableFromMany = 0;
      }
      if (v44 != v46)
      {
        uint64_t v29 = isPotentiallyReachableFromMany;
        free(v44);
        return v29;
      }
      return isPotentiallyReachableFromMany;
    }
    return 1;
  }
  uint64_t v7 = *(void *)(a2 + 40);

  return llvm::isPotentiallyReachable(v6, v7, a3, a4, (uint64_t *)a5);
}

uint64_t sub_1CBF92BC4()
{
  int v4 = 1;
  *(void *)&long long v3 = "Max number of BBs to explore for reachability analysis";
  *((void *)&v3 + 1) = 54;
  int v1 = 32;
  uint64_t v2 = &v1;
  sub_1CD413D64((uint64_t)&unk_1EBCC4110, "dom-tree-reachability-max-bbs-to-explore", &v4, &v3, &v2);
  return __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCC4110, &dword_1CB82C000);
}

void llvm::initializeCFGViewerLegacyPassPass(uint64_t a1)
{
  uint64_t v1 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC41D8, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CBF92CC4;
    v3[1] = &v1;
    uint64_t v2 = v3;
    std::__call_once(&qword_1EBCC41D8, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CBF92CC4()
{
}

void sub_1CBF92D64(uint64_t ***a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  v21[0] = a1;
  v21[1] = a2;
  v21[2] = a3;
  v21[3] = a4;
  char v22 = byte_1EBCC43F8;
  char v23 = byte_1EBCC4578;
  char v24 = byte_1EBCC44B8;
  uint64_t v20 = v21;
  if ((*((unsigned char *)a1 + 23) & 0x10) == 0)
  {
    int v15 = 0;
    int v14 = &byte_1CFBCE98E;
    goto LABEL_10;
  }
  uint64_t v5 = ***a1;
  uint64_t v6 = *(void *)(v5 + 152);
  uint64_t v7 = *(unsigned int *)(v5 + 168);
  if (!v7) {
    goto LABEL_8;
  }
  LODWORD(v8) = (v7 - 1) & ((a1 >> 4) ^ (a1 >> 9));
  uint64_t v9 = (uint64_t ****)(v6 + 16 * v8);
  uint64_t v10 = *v9;
  if (*v9 != a1)
  {
    int v11 = 1;
    while (v10 != (uint64_t ***)-4096)
    {
      int v12 = v8 + v11++;
      uint64_t v8 = v12 & (v7 - 1);
      uint64_t v10 = *(uint64_t ****)(v6 + 16 * v8);
      if (v10 == a1)
      {
        uint64_t v9 = (uint64_t ****)(v6 + 16 * v8);
        goto LABEL_9;
      }
    }
LABEL_8:
    uint64_t v9 = (uint64_t ****)(v6 + 16 * v7);
  }
LABEL_9:
  int v13 = v9[1];
  int v16 = *v13;
  int v14 = (char *)(v13 + 2);
  int v15 = v16;
LABEL_10:
  __int16 v19 = 1283;
  v18[0] = "cfg.";
  v18[2] = v14;
  v18[3] = v15;
  v17[16] = 257;
  sub_1CD46463C((uint64_t)&v20, (llvm::Twine *)v18, a5, (uint64_t)v17);
}

void llvm::initializeCFGOnlyViewerLegacyPassPass(uint64_t a1)
{
  uint64_t v1 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC41E0, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CBF92EE0;
    v3[1] = &v1;
    uint64_t v2 = v3;
    std::__call_once(&qword_1EBCC41E0, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CBF92EE0()
{
}

void llvm::initializeCFGPrinterLegacyPassPass(uint64_t a1)
{
  uint64_t v1 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC41E8, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CBF92FF0;
    v3[1] = &v1;
    uint64_t v2 = v3;
    std::__call_once(&qword_1EBCC41E8, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CBF92FF0()
{
}

void sub_1CBF93090(uint64_t ***a1, uint64_t a2, char *a3, uint64_t **a4, char a5)
{
  if (byte_1EBCC47FF >= 0) {
    size_t v10 = byte_1EBCC47FF & 0x7F;
  }
  else {
    size_t v10 = qword_1EBCC47F0;
  }
  int v11 = __p;
  sub_1CB907098((uint64_t)__p, v10 + 1);
  if (v40 < 0) {
    int v11 = (void **)__p[0];
  }
  if (v10)
  {
    if (byte_1EBCC47FF >= 0) {
      int v12 = &qword_1EBCC47E8;
    }
    else {
      int v12 = (uint64_t *)qword_1EBCC47E8;
    }
    memmove(v11, v12, v10);
  }
  *(_WORD *)((char *)v11 + v10) = 46;
  if ((*((unsigned char *)a1 + 23) & 0x10) != 0)
  {
    uint64_t v13 = ***a1;
    uint64_t v14 = *(void *)(v13 + 152);
    uint64_t v15 = *(unsigned int *)(v13 + 168);
    if (v15)
    {
      LODWORD(v16) = (v15 - 1) & ((a1 >> 4) ^ (a1 >> 9));
      uint64_t v17 = (uint64_t ****)(v14 + 16 * v16);
      uint64_t v18 = *v17;
      if (*v17 == a1)
      {
LABEL_19:
        uint64_t v21 = v17[1];
        char v24 = *v21;
        char v22 = (char *)(v21 + 2);
        char v23 = v24;
        goto LABEL_20;
      }
      int v19 = 1;
      while (v18 != (uint64_t ***)-4096)
      {
        int v20 = v16 + v19++;
        uint64_t v16 = v20 & (v15 - 1);
        uint64_t v18 = *(uint64_t ****)(v14 + 16 * v16);
        if (v18 == a1)
        {
          uint64_t v17 = (uint64_t ****)(v14 + 16 * v16);
          goto LABEL_19;
        }
      }
    }
    uint64_t v17 = (uint64_t ****)(v14 + 16 * v15);
    goto LABEL_19;
  }
  char v23 = 0;
  char v22 = &byte_1CFBCE98E;
LABEL_20:
  v46[0] = __p;
  uint64_t v47 = v22;
  int v48 = v23;
  __int16 v49 = 1284;
  v43[0] = v46;
  v43[2] = ".dot";
  __int16 v44 = 770;
  llvm::Twine::str((llvm::Twine *)v43, &v51);
  if (v40 < 0) {
    operator delete(__p[0]);
  }
  uint64_t v26 = (llvm::raw_ostream *)llvm::errs(v25);
  uint64_t v27 = *((void *)v26 + 4);
  if ((unint64_t)(*((void *)v26 + 3) - v27) > 8)
  {
    *(unsigned char *)(v27 + 8) = 39;
    *(void *)uint64_t v27 = *(void *)"Writing '";
    *((void *)v26 + 4) += 9;
  }
  else
  {
    uint64_t v26 = llvm::raw_ostream::write(v26, "Writing '", 9uLL);
  }
  if (v53 >= 0) {
    uint64_t v28 = (const char *)&v51;
  }
  else {
    uint64_t v28 = v51;
  }
  if (v53 >= 0) {
    size_t v29 = v53 & 0x7F;
  }
  else {
    size_t v29 = v52;
  }
  uint64_t v30 = llvm::raw_ostream::write(v26, v28, v29);
  int v31 = (_DWORD *)*((void *)v30 + 4);
  if (*((void *)v30 + 3) - (void)v31 > 3uLL)
  {
    *int v31 = 774778407;
    *((void *)v30 + 4) += 4;
  }
  else
  {
    llvm::raw_ostream::write(v30, "'...", 4uLL);
  }
  v45[0] = 0;
  std::system_category();
  if (v53 >= 0) {
    uint64_t v32 = (void **)&v51;
  }
  else {
    uint64_t v32 = (void **)v51;
  }
  if (v53 >= 0) {
    uint64_t v33 = v53 & 0x7F;
  }
  else {
    uint64_t v33 = v52;
  }
  int v34 = (llvm *)llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)v43, v32, v33, (uint64_t)v45, 1);
  v46[0] = a1;
  v46[1] = a2;
  uint64_t v47 = a3;
  int v48 = a4;
  LOBYTE(v49) = byte_1EBCC43F8;
  HIBYTE(v49) = byte_1EBCC4578;
  char v50 = byte_1EBCC44B8;
  if (!v45[0])
  {
    unint64_t v42 = v46;
    __int16 v41 = 257;
    sub_1CD46497C((uint64_t)v43, (uint64_t)&v42, a5);
  }
  uint64_t v35 = (llvm::raw_ostream *)llvm::errs(v34);
  uint64_t v36 = (void *)*((void *)v35 + 4);
  if (*((void *)v35 + 3) - (void)v36 > 0x20uLL)
  {
    qmemcpy(v36, "  error opening file for writing!", 33);
    *((void *)v35 + 4) += 33;
  }
  else
  {
    uint64_t v35 = llvm::raw_ostream::write(v35, "  error opening file for writing!", 0x21uLL);
  }
  int v37 = (llvm::raw_ostream *)llvm::errs(v35);
  uint64_t v38 = (unsigned char *)*((void *)v37 + 4);
  if (*((unsigned char **)v37 + 3) == v38)
  {
    llvm::raw_ostream::write(v37, "\n", 1uLL);
  }
  else
  {
    *uint64_t v38 = 10;
    ++*((void *)v37 + 4);
  }
  llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)v43);
  if (v53 < 0) {
    operator delete(v51);
  }
}

void llvm::initializeCFGOnlyPrinterLegacyPassPass(uint64_t a1)
{
  uint64_t v1 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC41F0, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CBF93474;
    v3[1] = &v1;
    uint64_t v2 = v3;
    std::__call_once(&qword_1EBCC41F0, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CBF93474()
{
}

void llvm::Function::viewCFGOnly(llvm::Function *this, const llvm::BlockFrequencyInfo *a2, const llvm::BranchProbabilityInfo *a3)
{
}

void llvm::createCFGPrinterLegacyPassPass(llvm *this)
{
}

uint64_t sub_1CBF93560(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCC41D2;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F26014D0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC41E8, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CBF92FF0;
    v5[1] = &PassRegistry;
    int v4 = v5;
    std::__call_once(&qword_1EBCC41E8, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void llvm::createCFGOnlyPrinterLegacyPassPass(llvm *this)
{
}

uint64_t sub_1CBF9364C(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCC41D3;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F2601570;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC41F0, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CBF93474;
    v5[1] = &PassRegistry;
    int v4 = v5;
    std::__call_once(&qword_1EBCC41F0, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

BOOL llvm::DOTGraphTraits<llvm::DOTFuncInfo *>::isNodeHidden(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v11 = a2;
  if (word_1EBCC45C0)
  {
    uint64_t v5 = *(uint64_t **)(a3 + 8);
    if (v5)
    {
      uint64_t v6 = *v5;
      double v7 = 0.0;
      if (*v5)
      {
        unsigned int v8 = sub_1CBF7A45C(*v5, a2);
        if (v8 == -1) {
          unint64_t v9 = 0;
        }
        else {
          unint64_t v9 = *(void *)(*(void *)(v6 + 8) + 24 * v8 + 16);
        }
        if (*v5) {
          double v7 = (double)*(unint64_t *)(*(void *)(*v5 + 8) + 16);
        }
      }
      else
      {
        unint64_t v9 = 0;
      }
      if ((double)v9 / v7 < *(double *)&xmmword_1EBCC4638) {
        return 1;
      }
    }
  }
  if (!(byte_1EBCC4278 | byte_1EBCC4338)) {
    return 0;
  }
  uint64_t v12 = a2;
  uint64_t v13 = 0;
  if (!sub_1CD3C8538((uint64_t *)(a1 + 8), &v12, &v13)
    || v13 == *(void *)(a1 + 8) + 16 * *(unsigned int *)(a1 + 24))
  {
    llvm::DOTGraphTraits<llvm::DOTFuncInfo *>::computeDeoptOrUnreachablePaths(a1, *(void *)(a2 + 56));
  }
  return *((unsigned char *)sub_1CD46647C((uint64_t *)(a1 + 8), &v11) + 8) != 0;
}

void sub_1CBF9383C()
{
}

void sub_1CBF93908(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CBF93944(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
}

uint64_t sub_1CBF93990(uint64_t a1, llvm *a2)
{
  if (byte_1EBCC4717 >= 0) {
    size_t v4 = byte_1EBCC4717 & 0x7F;
  }
  else {
    size_t v4 = qword_1EBCC4708;
  }
  if (v4)
  {
    if ((*((unsigned char *)a2 + 23) & 0x10) == 0)
    {
      uint64_t v15 = 0;
      uint64_t v14 = &byte_1CFBCE98E;
LABEL_14:
      v31[0] = (uint64_t)v14;
      v31[1] = v15;
      if (byte_1EBCC4717 >= 0) {
        uint64_t v17 = (char *)&qword_1EBCC4700;
      }
      else {
        uint64_t v17 = (char *)qword_1EBCC4700;
      }
      if (llvm::StringRef::find(v31, v17, v4, 0) == -1) {
        return 0;
      }
      goto LABEL_19;
    }
    uint64_t v5 = ***(void ***)a2;
    uint64_t v6 = *(void *)(v5 + 152);
    uint64_t v7 = *(unsigned int *)(v5 + 168);
    if (v7)
    {
      LODWORD(v8) = (v7 - 1) & ((a2 >> 4) ^ (a2 >> 9));
      unint64_t v9 = (llvm **)(v6 + 16 * v8);
      size_t v10 = *v9;
      if (*v9 == a2)
      {
LABEL_13:
        uint64_t v13 = v9[1];
        uint64_t v16 = *(void *)v13;
        uint64_t v14 = (char *)v13 + 16;
        uint64_t v15 = v16;
        goto LABEL_14;
      }
      int v11 = 1;
      while (v10 != (llvm *)-4096)
      {
        int v12 = v8 + v11++;
        uint64_t v8 = v12 & (v7 - 1);
        size_t v10 = *(llvm **)(v6 + 16 * v8);
        if (v10 == a2)
        {
          unint64_t v9 = (llvm **)(v6 + 16 * v8);
          goto LABEL_13;
        }
      }
    }
    unint64_t v9 = (llvm **)(v6 + 16 * v7);
    goto LABEL_13;
  }
LABEL_19:
  int v19 = *(uint64_t **)(a1 + 8);
  uint64_t v20 = *v19;
  uint64_t v21 = v19[1];
  if (v20 == v21)
  {
LABEL_22:
    uint64_t v22 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v20 != &llvm::BranchProbabilityInfoWrapperPass::ID)
    {
      v20 += 16;
      if (v20 == v21) {
        goto LABEL_22;
      }
    }
    uint64_t v22 = *(void *)(v20 + 8);
  }
  uint64_t v23 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v22 + 96))(v22, &llvm::BranchProbabilityInfoWrapperPass::ID)+ 32;
  char v24 = *(uint64_t **)(a1 + 8);
  uint64_t v25 = *v24;
  uint64_t v26 = v24[1];
  if (v25 == v26)
  {
LABEL_28:
    uint64_t v27 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v25 != &llvm::BlockFrequencyInfoWrapperPass::ID)
    {
      v25 += 16;
      if (v25 == v26) {
        goto LABEL_28;
      }
    }
    uint64_t v27 = *(void *)(v25 + 8);
  }
  uint64_t v28 = (const llvm::Function *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v27 + 96))(v27, &llvm::BlockFrequencyInfoWrapperPass::ID)+ 32);
  unint64_t MaxFreq = llvm::getMaxFreq(a2, v28, v29);
  sub_1CBF92D64((uint64_t ***)a2, (uint64_t)v28, v23, MaxFreq, 0);
  return 0;
}

void sub_1CBF93BA4()
{
}

void sub_1CBF93C70(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CBF93CAC(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
}

uint64_t sub_1CBF93CF8(uint64_t a1, llvm *a2)
{
  if (byte_1EBCC4717 >= 0) {
    size_t v4 = byte_1EBCC4717 & 0x7F;
  }
  else {
    size_t v4 = qword_1EBCC4708;
  }
  if (v4)
  {
    if ((*((unsigned char *)a2 + 23) & 0x10) == 0)
    {
      uint64_t v15 = 0;
      uint64_t v14 = &byte_1CFBCE98E;
LABEL_14:
      v31[0] = (uint64_t)v14;
      v31[1] = v15;
      if (byte_1EBCC4717 >= 0) {
        uint64_t v17 = (char *)&qword_1EBCC4700;
      }
      else {
        uint64_t v17 = (char *)qword_1EBCC4700;
      }
      if (llvm::StringRef::find(v31, v17, v4, 0) == -1) {
        return 0;
      }
      goto LABEL_19;
    }
    uint64_t v5 = ***(void ***)a2;
    uint64_t v6 = *(void *)(v5 + 152);
    uint64_t v7 = *(unsigned int *)(v5 + 168);
    if (v7)
    {
      LODWORD(v8) = (v7 - 1) & ((a2 >> 4) ^ (a2 >> 9));
      unint64_t v9 = (llvm **)(v6 + 16 * v8);
      size_t v10 = *v9;
      if (*v9 == a2)
      {
LABEL_13:
        uint64_t v13 = v9[1];
        uint64_t v16 = *(void *)v13;
        uint64_t v14 = (char *)v13 + 16;
        uint64_t v15 = v16;
        goto LABEL_14;
      }
      int v11 = 1;
      while (v10 != (llvm *)-4096)
      {
        int v12 = v8 + v11++;
        uint64_t v8 = v12 & (v7 - 1);
        size_t v10 = *(llvm **)(v6 + 16 * v8);
        if (v10 == a2)
        {
          unint64_t v9 = (llvm **)(v6 + 16 * v8);
          goto LABEL_13;
        }
      }
    }
    unint64_t v9 = (llvm **)(v6 + 16 * v7);
    goto LABEL_13;
  }
LABEL_19:
  int v19 = *(uint64_t **)(a1 + 8);
  uint64_t v20 = *v19;
  uint64_t v21 = v19[1];
  if (v20 == v21)
  {
LABEL_22:
    uint64_t v22 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v20 != &llvm::BranchProbabilityInfoWrapperPass::ID)
    {
      v20 += 16;
      if (v20 == v21) {
        goto LABEL_22;
      }
    }
    uint64_t v22 = *(void *)(v20 + 8);
  }
  uint64_t v23 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v22 + 96))(v22, &llvm::BranchProbabilityInfoWrapperPass::ID)+ 32;
  char v24 = *(uint64_t **)(a1 + 8);
  uint64_t v25 = *v24;
  uint64_t v26 = v24[1];
  if (v25 == v26)
  {
LABEL_28:
    uint64_t v27 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v25 != &llvm::BlockFrequencyInfoWrapperPass::ID)
    {
      v25 += 16;
      if (v25 == v26) {
        goto LABEL_28;
      }
    }
    uint64_t v27 = *(void *)(v25 + 8);
  }
  uint64_t v28 = (const llvm::Function *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v27 + 96))(v27, &llvm::BlockFrequencyInfoWrapperPass::ID)+ 32);
  unint64_t MaxFreq = llvm::getMaxFreq(a2, v28, v29);
  sub_1CBF92D64((uint64_t ***)a2, (uint64_t)v28, v23, MaxFreq, 1);
  return 0;
}

void sub_1CBF93F0C()
{
}

void sub_1CBF93F48(uint64_t **a1, llvm::Value *a2)
{
  sub_1CD464E9C((uint64_t)v98, (uint64_t)a2, *a1[1]);
  size_t v4 = *a1;
  uint64_t v5 = (*a1)[4];
  if ((unint64_t)((*a1)[3] - v5) > 4)
  {
    *(unsigned char *)(v5 + 4) = 101;
    *(_DWORD *)uint64_t v5 = 1685016073;
    v4[4] += 5;
  }
  else
  {
    llvm::raw_ostream::write((llvm::raw_ostream *)*a1, "\tNode", 5uLL);
  }
  llvm::write_hex((llvm::raw_ostream *)v4, (unint64_t)a2, 3, 0, 0);
  uint64_t v6 = (void *)v4[4];
  if ((unint64_t)(v4[3] - (void)v6) > 7)
  {
    *uint64_t v6 = 0x3D65706168735B20;
    v4[4] += 8;
  }
  else
  {
    llvm::raw_ostream::write((llvm::raw_ostream *)v4, " [shape=", 8uLL);
  }
  uint64_t v7 = (llvm::raw_ostream *)*a1;
  uint64_t v8 = (*a1)[4];
  unint64_t v9 = (*a1)[3] - v8;
  if (*((unsigned char *)a1 + 16))
  {
    if (v9 <= 4)
    {
      size_t v10 = "none,";
      size_t v11 = 5;
      goto LABEL_10;
    }
    *(unsigned char *)(v8 + 4) = 44;
    *(_DWORD *)uint64_t v8 = 1701736302;
    uint64_t v26 = *((void *)v7 + 4) + 5;
  }
  else
  {
    if (v9 <= 6)
    {
      size_t v10 = "record,";
      size_t v11 = 7;
LABEL_10:
      llvm::raw_ostream::write(v7, v10, v11);
      goto LABEL_11;
    }
    *(_DWORD *)(v8 + 3) = 744780399;
    *(_DWORD *)uint64_t v8 = 1868785010;
    uint64_t v26 = *((void *)v7 + 4) + 7;
  }
  *((void *)v7 + 4) = v26;
LABEL_11:
  if (v99 >= 0) {
    size_t v12 = v99 & 0x7F;
  }
  else {
    size_t v12 = (size_t)v98[1];
  }
  if (v12)
  {
    if (v99 >= 0) {
      uint64_t v13 = v98;
    }
    else {
      uint64_t v13 = (void **)v98[0];
    }
    uint64_t v14 = llvm::raw_ostream::write((llvm::raw_ostream *)*a1, (const char *)v13, v12);
    uint64_t v15 = (unsigned char *)*((void *)v14 + 4);
    if (*((unsigned char **)v14 + 3) == v15)
    {
      llvm::raw_ostream::write(v14, ",", 1uLL);
    }
    else
    {
      unsigned char *v15 = 44;
      ++*((void *)v14 + 4);
    }
  }
  uint64_t v16 = (llvm::raw_ostream *)*a1;
  uint64_t v17 = (*a1)[4];
  if ((unint64_t)((*a1)[3] - v17) > 5)
  {
    *(_WORD *)(v17 + 4) = 15724;
    *(_DWORD *)uint64_t v17 = 1700946284;
    *((void *)v16 + 4) += 6;
  }
  else
  {
    llvm::raw_ostream::write(v16, "label=", 6uLL);
  }
  if (!*((unsigned char *)a1 + 16))
  {
    uint64_t v18 = (llvm::raw_ostream *)*a1;
    int v19 = (_WORD *)(*a1)[4];
    if ((unint64_t)((*a1)[3] - (void)v19) > 1)
    {
      *int v19 = 31522;
      *((void *)v18 + 4) += 2;
      goto LABEL_61;
    }
    uint64_t v20 = "\"{";
    goto LABEL_60;
  }
  uint64_t v21 = (void *)*((void *)a2 + 5);
  if (v21 == (void *)((char *)a2 + 40))
  {
LABEL_48:
    unsigned int v28 = 0;
    LODWORD(v29) = 0;
  }
  else
  {
    if (v21) {
      uint64_t v22 = v21 - 3;
    }
    else {
      uint64_t v22 = 0;
    }
    int v23 = *((unsigned __int8 *)v22 + 16);
    int v24 = v23 - 29;
    if (v23 != 30)
    {
      uint64_t v27 = 2;
      unsigned int v28 = 0;
      uint64_t v29 = 0;
      switch(v24)
      {
        case 0:
        case 5:
        case 6:
          goto LABEL_49;
        case 1:
LABEL_205:
          __break(1u);
LABEL_206:
          int v57 = (*(_DWORD *)(v27 + 20) & 0x7FFFFFF) - 1;
LABEL_157:
          if (v57) {
            goto LABEL_114;
          }
LABEL_158:
          int v71 = 0;
          goto LABEL_159;
        case 2:
          LODWORD(v27) = (*((_DWORD *)v22 + 5) >> 1) & 0x3FFFFFF;
          goto LABEL_47;
        case 3:
        case 9:
          LODWORD(v27) = (*((_DWORD *)v22 + 5) & 0x7FFFFFF) - 1;
          goto LABEL_47;
        case 4:
          goto LABEL_34;
        case 7:
          LODWORD(v27) = *((_WORD *)v22 + 9) & 1;
          goto LABEL_47;
        case 8:
          LODWORD(v27) = 1;
          goto LABEL_34;
        case 10:
          LODWORD(v27) = *((_DWORD *)v22 + 20) + 1;
LABEL_47:
          if (!v27) {
            goto LABEL_48;
          }
          goto LABEL_34;
        default:
          goto LABEL_48;
      }
    }
    if ((*((_DWORD *)v22 + 5) & 0x7FFFFFF) == 3) {
      LODWORD(v27) = 2;
    }
    else {
      LODWORD(v27) = 1;
    }
LABEL_34:
    int v25 = v27 - 1;
    if ((v27 - 1) >= 0x3F) {
      int v25 = 63;
    }
    unsigned int v28 = v25 + 1;
    LODWORD(v29) = v27 != v28;
  }
LABEL_49:
  if (v28 <= 1) {
    int v30 = 1;
  }
  else {
    int v30 = v28;
  }
  int v31 = (llvm::raw_ostream *)*a1;
  uint64_t v32 = (void *)(*a1)[4];
  if ((unint64_t)((*a1)[3] - (void)v32) <= 0x30)
  {
    llvm::raw_ostream::write((llvm::raw_ostream *)*a1, "<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\"", 0x31uLL);
    int v89 = (void *)*((void *)v31 + 4);
  }
  else
  {
    qmemcpy(v32, "<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\"", 49);
    int v89 = (void *)(*((void *)v31 + 4) + 49);
    *((void *)v31 + 4) = v89;
  }
  unint64_t v33 = (v30 + v29);
  if (*((void *)v31 + 3) - (void)v89 <= 0x2EuLL)
  {
    llvm::raw_ostream::write(v31, " cellpadding=\"0\"><tr><td align=\"text\" colspan=\"", 0x2FuLL);
  }
  else
  {
    qmemcpy(v89, " cellpadding=\"0\"><tr><td align=\"text\" colspan=\"", 47);
    *((void *)v31 + 4) += 47;
  }
  sub_1CD098D14(v31, v33, 0, 0, 0);
  int v34 = (_WORD *)*((void *)v31 + 4);
  if (*((void *)v31 + 3) - (void)v34 <= 1uLL)
  {
    uint64_t v20 = "\">";
    uint64_t v18 = v31;
LABEL_60:
    llvm::raw_ostream::write(v18, v20, 2uLL);
    goto LABEL_61;
  }
  *int v34 = 15906;
  *((void *)v31 + 4) += 2;
LABEL_61:
  uint64_t v35 = (llvm::raw_ostream *)*a1;
  if (*((unsigned char *)a1 + 16))
  {
    sub_1CD465070(&__p, *((unsigned char *)a1 + 24), a2);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      size_t size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      size_t size = __p.__r_.__value_.__l.__size_;
    }
    llvm::raw_ostream::write(v35, (const char *)p_p, size);
    uint64_t v41 = *((void *)v35 + 4);
    if ((unint64_t)(*((void *)v35 + 3) - v41) > 4)
    {
      *(unsigned char *)(v41 + 4) = 62;
      *(_DWORD *)uint64_t v41 = 1685335868;
      *((void *)v35 + 4) += 5;
    }
    else
    {
      llvm::raw_ostream::write(v35, "</td>", 5uLL);
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      uint64_t v38 = (void *)__p.__r_.__value_.__r.__words[0];
      goto LABEL_82;
    }
  }
  else
  {
    sub_1CD465070(&v97, *((unsigned char *)a1 + 24), a2);
    llvm::DOT::EscapeString((char *)&v97, (uint64_t)&__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v36 = &__p;
    }
    else {
      uint64_t v36 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      size_t v37 = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      size_t v37 = __p.__r_.__value_.__l.__size_;
    }
    llvm::raw_ostream::write(v35, (const char *)v36, v37);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v97.__r_.__value_.__r.__words[2]) < 0)
    {
      uint64_t v38 = (void *)v97.__r_.__value_.__r.__words[0];
LABEL_82:
      operator delete(v38);
    }
  }
  memset(&v97, 0, sizeof(v97));
  LODWORD(__p.__r_.__value_.__r.__words[1]) = 0;
  char v93 = 0;
  uint64_t v94 = 0;
  uint64_t v96 = &v97;
  int v95 = 0;
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1F2646F30;
  __p.__r_.__value_.__r.__words[2] = 0;
  uint64_t v91 = 0;
  uint64_t v92 = 0;
  if (!sub_1CD4650FC((uint64_t)a1, (llvm::raw_ostream *)&__p, (uint64_t)a2)) {
    goto LABEL_95;
  }
  if (*((unsigned char *)a1 + 16)) {
    goto LABEL_88;
  }
  unint64_t v42 = (llvm::raw_ostream *)*a1;
  uint64_t v43 = (unsigned char *)(*a1)[4];
  if ((unsigned char *)(*a1)[3] == v43)
  {
    llvm::raw_ostream::write(v42, "|", 1uLL);
  }
  else
  {
    *uint64_t v43 = 124;
    ++*((void *)v42 + 4);
  }
  if (*((unsigned char *)a1 + 16))
  {
LABEL_88:
    __int16 v44 = (llvm::raw_ostream *)*a1;
    char v45 = HIBYTE(v96->__r_.__value_.__r.__words[2]);
    if (v45 >= 0) {
      uint64_t v46 = (const char *)v96;
    }
    else {
      uint64_t v46 = (const char *)v96->__r_.__value_.__r.__words[0];
    }
    if (v45 >= 0) {
      size_t v47 = v45 & 0x7F;
    }
    else {
      size_t v47 = v96->__r_.__value_.__l.__size_;
    }
    goto LABEL_94;
  }
  uint64_t v72 = (llvm::raw_ostream *)*a1;
  int v73 = (unsigned char *)(*a1)[4];
  if ((unsigned char *)(*a1)[3] == v73)
  {
    uint64_t v72 = llvm::raw_ostream::write(v72, "{", 1uLL);
  }
  else
  {
    *int v73 = 123;
    ++*((void *)v72 + 4);
  }
  char v74 = HIBYTE(v96->__r_.__value_.__r.__words[2]);
  if (v74 >= 0) {
    uint64_t v75 = (const char *)v96;
  }
  else {
    uint64_t v75 = (const char *)v96->__r_.__value_.__r.__words[0];
  }
  if (v74 >= 0) {
    size_t v76 = v74 & 0x7F;
  }
  else {
    size_t v76 = v96->__r_.__value_.__l.__size_;
  }
  __int16 v44 = llvm::raw_ostream::write(v72, v75, v76);
  int v77 = (unsigned char *)*((void *)v44 + 4);
  if (*((unsigned char **)v44 + 3) == v77)
  {
    uint64_t v46 = "}";
    size_t v47 = 1;
LABEL_94:
    llvm::raw_ostream::write(v44, v46, v47);
    goto LABEL_95;
  }
  *int v77 = 125;
  ++*((void *)v44 + 4);
LABEL_95:
  int v48 = (llvm::raw_ostream *)*a1;
  __int16 v49 = (_WORD *)(*a1)[4];
  unint64_t v50 = (*a1)[3] - (void)v49;
  if (*((unsigned char *)a1 + 16))
  {
    if (v50 <= 0xD)
    {
      int v51 = "</tr></table>>";
      size_t v52 = 14;
LABEL_100:
      llvm::raw_ostream::write(v48, v51, v52);
      goto LABEL_101;
    }
    qmemcpy(v49, "</tr></table>>", 14);
    uint64_t v88 = *((void *)v48 + 4) + 14;
  }
  else
  {
    if (v50 <= 1)
    {
      int v51 = "}\"";
      size_t v52 = 2;
      goto LABEL_100;
    }
    *__int16 v49 = 8829;
    uint64_t v88 = *((void *)v48 + 4) + 2;
  }
  *((void *)v48 + 4) = v88;
LABEL_101:
  size_t v4 = (uint64_t *)(a1 + 3);
  char v53 = (llvm::raw_ostream *)*a1;
  uint64_t v54 = (*a1)[4];
  if ((unint64_t)((*a1)[3] - v54) > 2)
  {
    *(unsigned char *)(v54 + 2) = 10;
    *(_WORD *)uint64_t v54 = 15197;
    *((void *)v53 + 4) += 3;
  }
  else
  {
    llvm::raw_ostream::write(v53, "];\n", 3uLL);
  }
  uint64_t v55 = (void *)*((void *)a2 + 5);
  if (v55 == (void *)((char *)a2 + 40))
  {
    int v71 = 0;
    uint64_t v29 = 0;
LABEL_159:
    unint64_t v59 = 0;
  }
  else
  {
    if (v55) {
      uint64_t v27 = (uint64_t)(v55 - 3);
    }
    else {
      uint64_t v27 = 0;
    }
    int v56 = *(unsigned __int8 *)(v27 + 16);
    if ((v56 - 29) >= 0xB) {
      uint64_t v29 = 0;
    }
    else {
      uint64_t v29 = v27;
    }
    if (v56 == 30)
    {
      if ((*(_DWORD *)(v27 + 20) & 0x7FFFFFF) == 3) {
        int v57 = 2;
      }
      else {
        int v57 = 1;
      }
LABEL_114:
      uint64_t v27 = 0;
      int v58 = 0;
      unint64_t v59 = 0;
      uint64_t v60 = v29 - 32;
      do
      {
        int v61 = *(unsigned __int8 *)(v29 + 16);
        if (v61 == 30)
        {
          unsigned int v62 = (uint64_t *)(v60 - 32 * v27);
        }
        else
        {
          uint64_t v65 = (v61 - 31);
          unsigned int v62 = (uint64_t *)(v29 - 32);
          switch(v65)
          {
            case 1:
            case 7:
              int v69 = *(_DWORD *)(v29 + 20);
              if ((v69 & 0x40000000) != 0) {
                uint64_t v67 = *(void *)(v29 - 8);
              }
              else {
                uint64_t v67 = v29 - 32 * (v69 & 0x7FFFFFF);
              }
              uint64_t v68 = (v27 + 1);
              goto LABEL_128;
            case 2:
              BOOL v64 = v27 == 0;
              uint64_t v70 = -64;
              if (v64) {
                uint64_t v70 = -96;
              }
              unsigned int v62 = (uint64_t *)(v29 + v70);
              break;
            case 3:
            case 4:
              goto LABEL_205;
            case 5:
              if ((*(_WORD *)(v29 + 18) & 1) == 0)
              {
                uint64_t v63 = 0;
                goto LABEL_118;
              }
              unsigned int v62 = (uint64_t *)(v29 + 32 - 32 * (*(_DWORD *)(v29 + 20) & 0x7FFFFFF));
              break;
            case 6:
              break;
            case 8:
              if (v27)
              {
                uint64_t v68 = (v27 - 1);
                uint64_t v67 = v60 - 32 * *(unsigned int *)(v29 + 80);
LABEL_128:
                unsigned int v62 = (uint64_t *)(v67 + 32 * v68);
              }
              else
              {
                unsigned int v62 = (uint64_t *)(v29 - 64 - 32 * *(unsigned int *)(v29 + 80));
              }
              break;
            default:
              int v66 = *(_DWORD *)(v29 + 20);
              if ((v66 & 0x40000000) != 0) {
                uint64_t v67 = *(void *)(v29 - 8);
              }
              else {
                uint64_t v67 = v29 - 32 * (v66 & 0x7FFFFFF);
              }
              uint64_t v68 = (2 * v27) | 1u;
              goto LABEL_128;
          }
        }
        uint64_t v63 = *v62;
LABEL_118:
        if (!llvm::DOTGraphTraits<llvm::DOTFuncInfo *>::isNodeHidden((uint64_t)v4, v63, *a1[1])) {
          sub_1CD465378((uint64_t)a1, (unint64_t)a2, v58, (llvm::Instruction *)v29, v59);
        }
        uint64_t v27 = v59 + 1;
        unint64_t v59 = v59 & 0xFFFFFFFF00000000 | (v59 + 1);
        if (v57 == v27) {
          break;
        }
        BOOL v64 = v58++ == 63;
      }
      while (!v64);
      int v71 = v57;
    }
    else
    {
      int v57 = 2;
      unint64_t v59 = 0;
      int v71 = 0;
      switch(*(unsigned char *)(v27 + 16))
      {
        case 0x1D:
        case 0x22:
        case 0x23:
          break;
        case 0x1E:
          goto LABEL_205;
        case 0x1F:
          int v57 = (*(_DWORD *)(v27 + 20) >> 1) & 0x3FFFFFF;
          goto LABEL_157;
        case 0x20:
        case 0x26:
          goto LABEL_206;
        case 0x21:
          goto LABEL_114;
        case 0x24:
          int v57 = *(_WORD *)(v27 + 18) & 1;
          goto LABEL_157;
        case 0x25:
          int v57 = 1;
          goto LABEL_114;
        case 0x27:
          int v57 = *(_DWORD *)(v27 + 80) + 1;
          goto LABEL_157;
        default:
          goto LABEL_158;
      }
    }
  }
  if (v71 != v59)
  {
    uint64_t v78 = v29 - 32;
    uint64_t v27 = v59;
    do
    {
      int v79 = *(unsigned __int8 *)(v29 + 16);
      if (v79 == 30)
      {
        int v80 = (uint64_t *)(v78 - 32 * v27);
      }
      else
      {
        uint64_t v82 = (v79 - 31);
        int v80 = (uint64_t *)(v29 - 32);
        switch(v82)
        {
          case 1:
          case 7:
            int v86 = *(_DWORD *)(v29 + 20);
            if ((v86 & 0x40000000) != 0) {
              uint64_t v84 = *(void *)(v29 - 8);
            }
            else {
              uint64_t v84 = v29 - 32 * (v86 & 0x7FFFFFF);
            }
            uint64_t v85 = (v27 + 1);
            goto LABEL_179;
          case 2:
            BOOL v64 = v27 == 0;
            uint64_t v87 = -64;
            if (v64) {
              uint64_t v87 = -96;
            }
            int v80 = (uint64_t *)(v29 + v87);
            break;
          case 3:
          case 4:
            goto LABEL_205;
          case 5:
            if ((*(_WORD *)(v29 + 18) & 1) == 0)
            {
              uint64_t v81 = 0;
              goto LABEL_171;
            }
            int v80 = (uint64_t *)(v29 + 32 - 32 * (*(_DWORD *)(v29 + 20) & 0x7FFFFFF));
            break;
          case 6:
            break;
          case 8:
            if (v27)
            {
              uint64_t v85 = (v27 - 1);
              uint64_t v84 = v78 - 32 * *(unsigned int *)(v29 + 80);
LABEL_179:
              int v80 = (uint64_t *)(v84 + 32 * v85);
            }
            else
            {
              int v80 = (uint64_t *)(v29 - 64 - 32 * *(unsigned int *)(v29 + 80));
            }
            break;
          default:
            int v83 = *(_DWORD *)(v29 + 20);
            if ((v83 & 0x40000000) != 0) {
              uint64_t v84 = *(void *)(v29 - 8);
            }
            else {
              uint64_t v84 = v29 - 32 * (v83 & 0x7FFFFFF);
            }
            uint64_t v85 = (2 * v27) | 1u;
            goto LABEL_179;
        }
      }
      uint64_t v81 = *v80;
LABEL_171:
      if (!llvm::DOTGraphTraits<llvm::DOTFuncInfo *>::isNodeHidden((uint64_t)v4, v81, *a1[1])) {
        sub_1CD465378((uint64_t)a1, (unint64_t)a2, 64, (llvm::Instruction *)v29, v59);
      }
      uint64_t v27 = v59 + 1;
      unint64_t v59 = v59 & 0xFFFFFFFF00000000 | (v59 + 1);
    }
    while (v71 != v27);
  }
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1F2646B98;
  if (v95 == 1 && __p.__r_.__value_.__r.__words[2]) {
    MEMORY[0x1D25D9CB0](__p.__r_.__value_.__r.__words[2], 0x1000C8077774924);
  }
  if (SHIBYTE(v97.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v97.__r_.__value_.__l.__data_);
  }
  if (v99 < 0) {
    operator delete(v98[0]);
  }
}

void sub_1CBF94B54(llvm::Value *a1@<X0>, void (*a2)(uint64_t, void **, llvm::Value *)@<X2>, uint64_t a3@<X3>, void (*a4)(uint64_t, uint64_t, unsigned int *, std::string::size_type)@<X4>, uint64_t a5@<X5>, uint64_t a6@<X8>)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v53 = 0;
  int v44 = 0;
  char v48 = 0;
  uint64_t v49 = 0;
  int v51 = __p;
  int v50 = 0;
  uint64_t v43 = &unk_1F2646F30;
  uint64_t v45 = 0;
  uint64_t v46 = 0;
  size_t v47 = 0;
  if ((*((unsigned char *)a1 + 23) & 0x10) == 0) {
    goto LABEL_49;
  }
  uint64_t v12 = ***(void ***)a1;
  uint64_t v13 = *(void *)(v12 + 152);
  uint64_t v14 = *(unsigned int *)(v12 + 168);
  if (v14)
  {
    LODWORD(v15) = (v14 - 1) & ((a1 >> 4) ^ (a1 >> 9));
    uint64_t v16 = v13 + 16 * v15;
    uint64_t v17 = *(llvm::Value **)v16;
    if (*(llvm::Value **)v16 == a1) {
      goto LABEL_9;
    }
    int v18 = 1;
    while (v17 != (llvm::Value *)-4096)
    {
      int v19 = v15 + v18++;
      uint64_t v15 = v19 & (v14 - 1);
      uint64_t v17 = *(llvm::Value **)(v13 + 16 * v15);
      if (v17 == a1)
      {
        uint64_t v16 = v13 + 16 * v15;
        goto LABEL_9;
      }
    }
  }
  uint64_t v16 = v13 + 16 * v14;
LABEL_9:
  if (!**(void **)(v16 + 8))
  {
LABEL_49:
    llvm::Value::printAsOperand(a1, (llvm::raw_ostream *)&v43, 0, 0);
    if (v46 == v47) {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v43, ":", 1uLL);
    }
    else {
      *v47++ = 58;
    }
  }
  a2(a3, &v43, a1);
  if (*((char *)v51 + 23) < 0)
  {
    sub_1CB8BDF7C(a6, *v51, (unint64_t)v51[1]);
  }
  else
  {
    long long v20 = *(_OWORD *)v51;
    *(void *)(a6 + 16) = v51[2];
    *(_OWORD *)a6 = v20;
  }
  int v21 = *(char *)(a6 + 23);
  uint64_t v22 = *(unsigned char **)a6;
  if (v21 >= 0) {
    uint64_t v22 = (unsigned char *)a6;
  }
  if (*v22 == 10)
  {
    std::string::erase((std::string *)a6, 0, 1uLL);
    LOBYTE(v21) = *(unsigned char *)(a6 + 23);
  }
  unsigned int v42 = 0;
  BOOL v37 = (v21 & 0x80u) != 0;
  BOOL v23 = v37;
  uint64_t v24 = v21 & 0x7F;
  if (v37) {
    uint64_t v24 = *(void *)(a6 + 8);
  }
  if (v24)
  {
    uint64_t v25 = 0;
    int v26 = 0;
    unsigned int v27 = 0;
    unsigned int v28 = 0;
    uint64_t v29 = *(unsigned char **)a6;
    do
    {
      if (v23) {
        uint64_t v30 = (uint64_t)v29;
      }
      else {
        uint64_t v30 = a6;
      }
      int v31 = *(unsigned __int8 *)(v30 + v25);
      if (v31 == 59)
      {
        std::string::size_type v34 = std::string::find((const std::string *)a6, 10, v28 + 1);
        a4(a5, a6, &v42, v34);
      }
      else if (v31 == 10)
      {
        *(unsigned char *)(v30 + v25) = 92;
        if (*(char *)(a6 + 23) >= 0) {
          uint64_t v32 = (unsigned char *)a6;
        }
        else {
          uint64_t v32 = *(unsigned char **)a6;
        }
        v33.__i_ = &v32[v42 + 1];
        std::string::insert((std::string *)a6, v33, 108);
        unsigned int v27 = 0;
        int v26 = 0;
      }
      else if (v26 == 80)
      {
        if (v27) {
          std::string::size_type v35 = v27;
        }
        else {
          std::string::size_type v35 = v28;
        }
        std::string::insert((std::string *)a6, v35, "\\l...");
        unsigned int v27 = 0;
        int v26 = v42 - v35;
        v42 += 3;
      }
      else
      {
        ++v26;
      }
      char v36 = *(unsigned char *)(a6 + 23);
      BOOL v37 = v36 < 0;
      BOOL v23 = v37;
      uint64_t v29 = *(unsigned char **)a6;
      uint64_t v38 = *(void *)(a6 + 8);
      if (v36 >= 0) {
        uint64_t v39 = (unsigned char *)a6;
      }
      else {
        uint64_t v39 = *(unsigned char **)a6;
      }
      int v40 = v39[v42];
      uint64_t v41 = v36 & 0x7F;
      if (!v37) {
        uint64_t v38 = v41;
      }
      if (v40 == 32) {
        unsigned int v27 = v42;
      }
      uint64_t v25 = v42 + 1;
      unsigned int v42 = v25;
      unsigned int v28 = v25;
    }
    while (v38 != v25);
  }
  uint64_t v43 = &unk_1F2646B98;
  if (v50 == 1 && v45) {
    MEMORY[0x1D25D9CB0](v45, 0x1000C8077774924);
  }
  if (SHIBYTE(v53) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1CBF94EC4(uint64_t a1@<X0>, int a2@<W2>, uint64_t a3@<X8>)
{
  v28[5] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 40);
  if (v4 == a1 + 40) {
    goto LABEL_26;
  }
  uint64_t v5 = v4 - 24;
  if (!v4) {
    uint64_t v5 = 0;
  }
  unsigned int v6 = *(unsigned __int8 *)(v5 + 16) - 40;
  if (v6 < 0xFFFFFFF5) {
    uint64_t v5 = 0;
  }
  int v7 = *(unsigned __int8 *)(v5 + 16);
  if (v4)
  {
    if (v7 == 30 && v6 >= 0xFFFFFFF5)
    {
      if ((*(_DWORD *)(v5 + 20) & 0x7FFFFFF) == 3)
      {
        *(unsigned char *)(a3 + 23) = 1;
        if (a2) {
          char v9 = 70;
        }
        else {
          char v9 = 84;
        }
        *(unsigned char *)a3 = v9;
        *(unsigned char *)(a3 + 1) = 0;
        return;
      }
LABEL_26:
      *(unsigned char *)(a3 + 23) = 0;
      *(unsigned char *)a3 = 0;
      return;
    }
  }
  if (!v4) {
    goto LABEL_26;
  }
  if (v7 != 31 || v6 < 0xFFFFFFF5) {
    goto LABEL_26;
  }
  if (a2)
  {
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v25 = 0;
    int v16 = 0;
    char v20 = 0;
    uint64_t v21 = 0;
    BOOL v23 = __p;
    int v22 = 0;
    uint64_t v15 = &unk_1F2646F30;
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    int v11 = *(_DWORD *)(v5 + 20);
    if ((v11 & 0x40000000) != 0) {
      uint64_t v12 = *(void *)(v5 - 8);
    }
    else {
      uint64_t v12 = v5 - 32 * (v11 & 0x7FFFFFF);
    }
    uint64_t v13 = (unsigned int *)(*(void *)(v12 + 32 * (2 * a2)) + 24);
    int v26 = (char *)v28;
    long long v27 = xmmword_1CDB15B30;
    llvm::APInt::toString(v13, &v26, 0xAu, 1, 0);
    llvm::raw_ostream::write((llvm::raw_ostream *)&v15, v26, v27);
    if (v26 != (char *)v28) {
      free(v26);
    }
    if (*((char *)v23 + 23) < 0)
    {
      sub_1CB8BDF7C(a3, *v23, (unint64_t)v23[1]);
    }
    else
    {
      long long v14 = *(_OWORD *)v23;
      *(void *)(a3 + 16) = v23[2];
      *(_OWORD *)a3 = v14;
    }
    uint64_t v15 = &unk_1F2646B98;
    if (v22 == 1 && v17) {
      MEMORY[0x1D25D9CB0](v17, 0x1000C8077774924);
    }
    if (SHIBYTE(v25) < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    *(unsigned char *)(a3 + 23) = 3;
    *(_DWORD *)a3 = 6710628;
  }
}

void sub_1CBF95104()
{
}

void sub_1CBF95144(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CBF95180(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
}

uint64_t sub_1CBF951CC(uint64_t a1, llvm *a2)
{
  if (byte_1EBCC4717 >= 0) {
    size_t v4 = byte_1EBCC4717 & 0x7F;
  }
  else {
    size_t v4 = qword_1EBCC4708;
  }
  if (v4)
  {
    if ((*((unsigned char *)a2 + 23) & 0x10) == 0)
    {
      uint64_t v15 = 0;
      long long v14 = &byte_1CFBCE98E;
LABEL_14:
      v31[0] = (uint64_t)v14;
      v31[1] = v15;
      if (byte_1EBCC4717 >= 0) {
        uint64_t v17 = (char *)&qword_1EBCC4700;
      }
      else {
        uint64_t v17 = (char *)qword_1EBCC4700;
      }
      if (llvm::StringRef::find(v31, v17, v4, 0) == -1) {
        return 0;
      }
      goto LABEL_19;
    }
    uint64_t v5 = ***(void ***)a2;
    uint64_t v6 = *(void *)(v5 + 152);
    uint64_t v7 = *(unsigned int *)(v5 + 168);
    if (v7)
    {
      LODWORD(v8) = (v7 - 1) & ((a2 >> 4) ^ (a2 >> 9));
      char v9 = (llvm **)(v6 + 16 * v8);
      size_t v10 = *v9;
      if (*v9 == a2)
      {
LABEL_13:
        uint64_t v13 = v9[1];
        uint64_t v16 = *(void *)v13;
        long long v14 = (char *)v13 + 16;
        uint64_t v15 = v16;
        goto LABEL_14;
      }
      int v11 = 1;
      while (v10 != (llvm *)-4096)
      {
        int v12 = v8 + v11++;
        uint64_t v8 = v12 & (v7 - 1);
        size_t v10 = *(llvm **)(v6 + 16 * v8);
        if (v10 == a2)
        {
          char v9 = (llvm **)(v6 + 16 * v8);
          goto LABEL_13;
        }
      }
    }
    char v9 = (llvm **)(v6 + 16 * v7);
    goto LABEL_13;
  }
LABEL_19:
  uint64_t v19 = *(uint64_t **)(a1 + 8);
  uint64_t v20 = *v19;
  uint64_t v21 = v19[1];
  if (v20 == v21)
  {
LABEL_22:
    uint64_t v22 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v20 != &llvm::BranchProbabilityInfoWrapperPass::ID)
    {
      v20 += 16;
      if (v20 == v21) {
        goto LABEL_22;
      }
    }
    uint64_t v22 = *(void *)(v20 + 8);
  }
  BOOL v23 = (char *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v22 + 96))(v22, &llvm::BranchProbabilityInfoWrapperPass::ID)+ 32);
  uint64_t v24 = *(uint64_t **)(a1 + 8);
  uint64_t v25 = *v24;
  uint64_t v26 = v24[1];
  if (v25 == v26)
  {
LABEL_28:
    uint64_t v27 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v25 != &llvm::BlockFrequencyInfoWrapperPass::ID)
    {
      v25 += 16;
      if (v25 == v26) {
        goto LABEL_28;
      }
    }
    uint64_t v27 = *(void *)(v25 + 8);
  }
  unsigned int v28 = (const llvm::Function *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v27 + 96))(v27, &llvm::BlockFrequencyInfoWrapperPass::ID)+ 32);
  unint64_t MaxFreq = (uint64_t **)llvm::getMaxFreq(a2, v28, v29);
  sub_1CBF93090((uint64_t ***)a2, (uint64_t)v28, v23, MaxFreq, 0);
  return 0;
}

void sub_1CBF953E4(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CBF95420(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
}

uint64_t sub_1CBF9546C(uint64_t a1, llvm *a2)
{
  if (byte_1EBCC4717 >= 0) {
    size_t v4 = byte_1EBCC4717 & 0x7F;
  }
  else {
    size_t v4 = qword_1EBCC4708;
  }
  if (v4)
  {
    if ((*((unsigned char *)a2 + 23) & 0x10) == 0)
    {
      uint64_t v15 = 0;
      long long v14 = &byte_1CFBCE98E;
LABEL_14:
      v31[0] = (uint64_t)v14;
      v31[1] = v15;
      if (byte_1EBCC4717 >= 0) {
        uint64_t v17 = (char *)&qword_1EBCC4700;
      }
      else {
        uint64_t v17 = (char *)qword_1EBCC4700;
      }
      if (llvm::StringRef::find(v31, v17, v4, 0) == -1) {
        return 0;
      }
      goto LABEL_19;
    }
    uint64_t v5 = ***(void ***)a2;
    uint64_t v6 = *(void *)(v5 + 152);
    uint64_t v7 = *(unsigned int *)(v5 + 168);
    if (v7)
    {
      LODWORD(v8) = (v7 - 1) & ((a2 >> 4) ^ (a2 >> 9));
      char v9 = (llvm **)(v6 + 16 * v8);
      size_t v10 = *v9;
      if (*v9 == a2)
      {
LABEL_13:
        uint64_t v13 = v9[1];
        uint64_t v16 = *(void *)v13;
        long long v14 = (char *)v13 + 16;
        uint64_t v15 = v16;
        goto LABEL_14;
      }
      int v11 = 1;
      while (v10 != (llvm *)-4096)
      {
        int v12 = v8 + v11++;
        uint64_t v8 = v12 & (v7 - 1);
        size_t v10 = *(llvm **)(v6 + 16 * v8);
        if (v10 == a2)
        {
          char v9 = (llvm **)(v6 + 16 * v8);
          goto LABEL_13;
        }
      }
    }
    char v9 = (llvm **)(v6 + 16 * v7);
    goto LABEL_13;
  }
LABEL_19:
  uint64_t v19 = *(uint64_t **)(a1 + 8);
  uint64_t v20 = *v19;
  uint64_t v21 = v19[1];
  if (v20 == v21)
  {
LABEL_22:
    uint64_t v22 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v20 != &llvm::BranchProbabilityInfoWrapperPass::ID)
    {
      v20 += 16;
      if (v20 == v21) {
        goto LABEL_22;
      }
    }
    uint64_t v22 = *(void *)(v20 + 8);
  }
  BOOL v23 = (char *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v22 + 96))(v22, &llvm::BranchProbabilityInfoWrapperPass::ID)+ 32);
  uint64_t v24 = *(uint64_t **)(a1 + 8);
  uint64_t v25 = *v24;
  uint64_t v26 = v24[1];
  if (v25 == v26)
  {
LABEL_28:
    uint64_t v27 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v25 != &llvm::BlockFrequencyInfoWrapperPass::ID)
    {
      v25 += 16;
      if (v25 == v26) {
        goto LABEL_28;
      }
    }
    uint64_t v27 = *(void *)(v25 + 8);
  }
  unsigned int v28 = (const llvm::Function *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v27 + 96))(v27, &llvm::BlockFrequencyInfoWrapperPass::ID)+ 32);
  unint64_t MaxFreq = (uint64_t **)llvm::getMaxFreq(a2, v28, v29);
  sub_1CBF93090((uint64_t ***)a2, (uint64_t)v28, v23, MaxFreq, 1);
  return 0;
}

void **sub_1CBF95680(void **a1)
{
  uint64_t v2 = (void **)a1[50];
  if (v2 != a1 + 52) {
    free(v2);
  }
  long long v3 = a1[39];
  if (v3 != a1[38]) {
    free(v3);
  }
  size_t v4 = (void **)a1[12];
  if (v4 != a1 + 14) {
    free(v4);
  }
  uint64_t v5 = a1[1];
  if (v5 != *a1) {
    free(v5);
  }
  return a1;
}

void sub_1CBF956FC(unsigned char *a1, uint64_t a2, llvm::Twine *this, char a4, uint64_t a5, uint64_t a6)
{
  if (*(char *)(a6 + 23) < 0) {
    uint64_t v10 = *(void *)(a6 + 8);
  }
  else {
    uint64_t v10 = *(unsigned __int8 *)(a6 + 23);
  }
  int v45 = 0;
  if (v10)
  {
    __int16 v40 = 260;
    uint64_t v38 = a6;
    *(void *)&long long v43 = llvm::sys::fs::openFile((unsigned __int8 *)&v38, &v45, 0, 2, 1, 438);
    *((void *)&v43 + 1) = v11;
    int v12 = std::generic_category();
    uint64_t v38 = 17;
    uint64_t v39 = v12;
    uint64_t v13 = (llvm *)(*(uint64_t (**)(void, void, uint64_t *))(**((void **)&v43 + 1) + 32))(*((void *)&v43 + 1), v43, &v38);
    if (v13
      || (uint64_t v13 = (llvm *)((uint64_t (*)(const std::error_category *, long long *, void))v39->equivalent_0)(v39, &v43, v38), v13))
    {
      uint64_t v19 = (llvm::raw_ostream *)llvm::errs(v13);
      uint64_t v20 = (void *)*((void *)v19 + 4);
      if (*((void *)v19 + 3) - (void)v20 > 0x17uLL)
      {
        qmemcpy(v20, "file exists, overwriting", 24);
        uint64_t v21 = (unsigned char *)(*((void *)v19 + 4) + 24);
        *((void *)v19 + 4) = v21;
      }
      else
      {
        uint64_t v19 = llvm::raw_ostream::write(v19, "file exists, overwriting", 0x18uLL);
        uint64_t v21 = (unsigned char *)*((void *)v19 + 4);
      }
      uint64_t v22 = (unsigned char *)*((void *)v19 + 3);
    }
    else
    {
      int v14 = v43;
      uint64_t v15 = (llvm::raw_ostream *)llvm::errs(v13);
      uint64_t v16 = (char *)*((void *)v15 + 4);
      unint64_t v17 = *((void *)v15 + 3) - (void)v16;
      if (v14)
      {
        if (v17 > 0x16)
        {
          qmemcpy(v16, "error writing into file", 23);
          uint64_t v18 = (unsigned char *)(*((void *)v15 + 4) + 23);
          *((void *)v15 + 4) = v18;
        }
        else
        {
          uint64_t v15 = llvm::raw_ostream::write(v15, "error writing into file", 0x17uLL);
          uint64_t v18 = (unsigned char *)*((void *)v15 + 4);
        }
        if (*((unsigned char **)v15 + 3) == v18)
        {
          llvm::raw_ostream::write(v15, "\n", 1uLL);
        }
        else
        {
          *uint64_t v18 = 10;
          ++*((void *)v15 + 4);
        }
        a1[23] = 0;
        *a1 = 0;
        return;
      }
      if (v17 > 0x21)
      {
        qmemcpy(v16, "writing to the newly created file ", 34);
        *((void *)v15 + 4) += 34;
      }
      else
      {
        uint64_t v15 = llvm::raw_ostream::write(v15, "writing to the newly created file ", 0x22uLL);
      }
      char v23 = *(unsigned char *)(a6 + 23);
      BOOL v24 = v23 < 0;
      if (v23 >= 0) {
        uint64_t v25 = (const char *)a6;
      }
      else {
        uint64_t v25 = *(const char **)a6;
      }
      size_t v26 = v23 & 0x7F;
      if (v24) {
        size_t v27 = *(void *)(a6 + 8);
      }
      else {
        size_t v27 = v26;
      }
      uint64_t v19 = llvm::raw_ostream::write(v15, v25, v27);
      uint64_t v22 = (unsigned char *)*((void *)v19 + 3);
      uint64_t v21 = (unsigned char *)*((void *)v19 + 4);
    }
    if (v22 == v21)
    {
      llvm::raw_ostream::write(v19, "\n", 1uLL);
    }
    else
    {
      *uint64_t v21 = 10;
      ++*((void *)v19 + 4);
    }
  }
  else
  {
    llvm::Twine::str(this, __p);
    __int16 v40 = 260;
    uint64_t v38 = (uint64_t)__p;
    llvm::createGraphFilename((llvm *)&v38, (const llvm::Twine *)&v45, (uint64_t)&v43);
    if (*(char *)(a6 + 23) < 0) {
      operator delete(*(void **)a6);
    }
    *(_OWORD *)a6 = v43;
    *(void *)(a6 + 16) = v44;
    HIBYTE(v44) = 0;
    LOBYTE(v43) = 0;
    if (v42 < 0) {
      operator delete(__p[0]);
    }
  }
  unsigned int v28 = (llvm *)llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)&v38, v45, 1, 0, 0);
  if (v45 != -1) {
    sub_1CD46497C((uint64_t)&v38, a2, a4);
  }
  uint64_t v29 = (llvm::raw_ostream *)llvm::errs(v28);
  uint64_t v30 = *((void *)v29 + 4);
  if ((unint64_t)(*((void *)v29 + 3) - v30) > 0x13)
  {
    *(_DWORD *)(v30 + 16) = 656434540;
    *(_OWORD *)uint64_t v30 = *(_OWORD *)"error opening file '";
    *((void *)v29 + 4) += 20;
  }
  else
  {
    uint64_t v29 = llvm::raw_ostream::write(v29, "error opening file '", 0x14uLL);
  }
  char v31 = *(unsigned char *)(a6 + 23);
  BOOL v32 = v31 < 0;
  if (v31 >= 0) {
    std::string::const_iterator v33 = (const char *)a6;
  }
  else {
    std::string::const_iterator v33 = *(const char **)a6;
  }
  size_t v34 = v31 & 0x7F;
  if (v32) {
    size_t v35 = *(void *)(a6 + 8);
  }
  else {
    size_t v35 = v34;
  }
  char v36 = llvm::raw_ostream::write(v29, v33, v35);
  BOOL v37 = (void *)*((void *)v36 + 4);
  if (*((void *)v36 + 3) - (void)v37 > 0xEuLL)
  {
    qmemcpy(v37, "' for writing!\n", 15);
    *((void *)v36 + 4) += 15;
  }
  else
  {
    llvm::raw_ostream::write(v36, "' for writing!\n", 0xFuLL);
  }
  a1[23] = 0;
  *a1 = 0;
  llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)&v38);
}

uint64_t sub_1CBF95B50(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (v1 == a1 + 40) {
    return 1;
  }
  uint64_t v2 = v1 - 24;
  if (!v1) {
    uint64_t v2 = 0;
  }
  int v3 = *(unsigned __int8 *)(v2 + 16);
  int v4 = v3 - 29;
  if (v3 == 30)
  {
LABEL_5:
    int v5 = 1;
  }
  else
  {
    int v5 = 0;
    switch(v4)
    {
      case 0:
      case 5:
      case 6:
        return v5 == 0;
      case 1:
        __break(1u);
        break;
      case 2:
        int v5 = (*(_DWORD *)(v2 + 20) >> 1) & 0x3FFFFFF;
        return v5 == 0;
      case 3:
      case 9:
        int v5 = (*(_DWORD *)(v2 + 20) & 0x7FFFFFF) - 1;
        return v5 == 0;
      case 4:
      case 8:
        goto LABEL_5;
      case 7:
        break;
      case 10:
        int v5 = *(_DWORD *)(v2 + 80) + 1;
        return v5 == 0;
      default:
        return 1;
    }
    int v5 = *(_WORD *)(v2 + 18) & 1;
  }
  return v5 == 0;
}

uint64_t sub_1CBF95C20(uint64_t a1, uint64_t a2)
{
  int v4 = (void *)(a1 + 32);
  *(void *)a1 = v4;
  int v5 = *(const void **)(a2 + 8);
  if (v5 == *(const void **)a2)
  {
    *(void *)(a1 + 8) = v4;
  }
  else
  {
    uint64_t v12 = *(unsigned int *)(a2 + 16);
    int v4 = malloc_type_malloc(8 * v12, 0x4065EBACuLL);
    if (!v4 && (v12 || (int v4 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0)) {
      llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
    }
    *(void *)(a1 + 8) = v4;
    int v5 = *(const void **)a2;
  }
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  uint64_t v6 = *(const void **)(a2 + 8);
  int v7 = *(_DWORD *)(a2 + 20);
  if (v6 == v5) {
    unsigned int v8 = *(_DWORD *)(a2 + 20);
  }
  else {
    unsigned int v8 = *(_DWORD *)(a2 + 16);
  }
  if (v8)
  {
    memmove(v4, v6, 8 * v8);
    int v7 = *(_DWORD *)(a2 + 20);
  }
  *(void *)(a1 + 96) = a1 + 112;
  int v9 = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a1 + 20) = v7;
  *(_DWORD *)(a1 + 24) = v9;
  *(void *)(a1 + 104) = 0x800000000;
  unsigned int v10 = *(_DWORD *)(a2 + 104);
  if (v10 && a1 != a2)
  {
    if (v10 >= 9) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    memcpy((void *)(a1 + 112), *(const void **)(a2 + 96), 24 * *(unsigned int *)(a2 + 104));
    *(_DWORD *)(a1 + 104) = v10;
  }
  return a1;
}

uint64_t sub_1CBF95D54()
{
  LODWORD(v4) = 1;
  v2.n128_u64[0] = (unint64_t)"The name of a function (or its substring) whose CFG is viewed/printed.";
  v2.n128_u64[1] = 70;
  sub_1CD465F40(&v4, (long long *)&v2);
  __cxa_atexit((void (*)(void *))sub_1CD41C8DC, &qword_1EBCC4680, &dword_1CB82C000);
  LODWORD(v4) = 1;
  v2.n128_u64[0] = (unint64_t)"The prefix used for the CFG dot file names.";
  v2.n128_u64[1] = 43;
  sub_1CD466058(&v4, (long long *)&v2);
  __cxa_atexit((void (*)(void *))sub_1CD41C8DC, &qword_1EBCC4768, &dword_1CB82C000);
  LOBYTE(v4) = 0;
  v2.n128_u64[0] = (unint64_t)&v4;
  sub_1CD466170((char **)&v2);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, qword_1EBCC41F8, &dword_1CB82C000);
  LOBYTE(v4) = 0;
  v2.n128_u64[0] = (unint64_t)&v4;
  sub_1CD46626C((char **)&v2);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, qword_1EBCC42B8, &dword_1CB82C000);
  int v4 = (char *)&v1;
  uint64_t v1 = 0;
  v2.n128_u64[0] = (unint64_t)"Hide blocks with relative frequency below the given value";
  v2.n128_u64[1] = 57;
  sub_1CD466368((uint64_t **)&v4, (long long *)&v2);
  __cxa_atexit((void (*)(void *))sub_1CBF801A0, &qword_1EBCC45B8, &dword_1CB82C000);
  char v3 = 1;
  int v4 = &v3;
  LODWORD(v1) = 1;
  v2.n128_u64[0] = (unint64_t)"Show heat colors in CFG";
  v2.n128_u64[1] = 23;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBCC4378, "cfg-heat-colors", &v4, &v1, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCC4378, &dword_1CB82C000);
  char v3 = 0;
  int v4 = &v3;
  LODWORD(v1) = 1;
  v2.n128_u64[0] = (unint64_t)"Use raw weights for labels. Use percentages as default.";
  v2.n128_u64[1] = 55;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBCC4438, "cfg-raw-weights", &v4, &v1, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCC4438, &dword_1CB82C000);
  char v3 = 0;
  int v4 = &v3;
  LODWORD(v1) = 1;
  v2.n128_u64[0] = (unint64_t)"Show edges labeled with weights";
  v2.n128_u64[1] = 31;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBCC44F8, "cfg-weights", &v4, &v1, &v2);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCC44F8, &dword_1CB82C000);
}

uint64_t llvm::CFLAndersAAResult::CFLAndersAAResult(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  uint64_t v3 = a1 + 8;
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 32) = v3;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), v3);
    }
    else
    {
      *(void *)(a1 + 32) = v4;
      *(void *)(a2 + 24) = 0;
    }
  }
  else
  {
    *(void *)(a1 + 32) = 0;
  }
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  return a1;
}

{
  uint64_t v3;
  uint64_t v4;

  *(void *)a1 = 0;
  uint64_t v3 = a1 + 8;
  uint64_t v4 = *(void *)(a2 + 32);
  if (v4)
  {
    if (v4 == a2 + 8)
    {
      *(void *)(a1 + 32) = v3;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 32) + 24))(*(void *)(a2 + 32), v3);
    }
    else
    {
      *(void *)(a1 + 32) = v4;
      *(void *)(a2 + 32) = 0;
    }
  }
  else
  {
    *(void *)(a1 + 32) = 0;
  }
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  return a1;
}

char *sub_1CBF960B0(char *result, char *a2, unint64_t a3)
{
  if (a2 == result) {
    return result;
  }
  unint64_t v3 = (a2 - result) >> 4;
  while (1)
  {
    unint64_t v4 = v3 >> 1;
    int v5 = (unint64_t *)&result[16 * (v3 >> 1)];
    if (*v5 >= a3) {
      break;
    }
    BOOL result = (char *)(v5 + 2);
    unint64_t v4 = v3 + ~v4;
LABEL_7:
    unint64_t v3 = v4;
    if (!v4) {
      return result;
    }
  }
  if (a3 < *v5)
  {
    a2 = &result[16 * (v3 >> 1)];
    goto LABEL_7;
  }
  if (v3 >= 2)
  {
    do
    {
      unint64_t v6 = v4 >> 1;
      int v7 = (unint64_t *)&result[16 * (v4 >> 1)];
      unint64_t v9 = *v7;
      unsigned int v8 = (char *)(v7 + 2);
      v4 += ~(v4 >> 1);
      if (v9 < a3) {
        BOOL result = v8;
      }
      else {
        unint64_t v4 = v6;
      }
    }
    while (v4);
  }
  unsigned int v10 = v5 + 2;
  uint64_t v11 = a2 - (char *)(v5 + 2);
  if (v11)
  {
    unint64_t v12 = v11 >> 4;
    do
    {
      unint64_t v13 = v12 >> 1;
      int v14 = &v10[2 * (v12 >> 1)];
      unint64_t v16 = *v14;
      uint64_t v15 = v14 + 2;
      v12 += ~(v12 >> 1);
      if (a3 < v16) {
        unint64_t v12 = v13;
      }
      else {
        unsigned int v10 = v15;
      }
    }
    while (v12);
  }
  return result;
}

uint64_t *llvm::CFLAndersAAResult::buildInfoFrom@<X0>(llvm::CFLAndersAAResult *this@<X0>, const llvm::Function *a2@<X1>, uint64_t a3@<X8>)
{
  v396[4] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *((void *)this + 4);
  if (!v5) {
    sub_1CB920400();
  }
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 48))(v5);
  v390[0] = this;
  v390[1] = v7;
  v391 = 0;
  uint64_t v392 = 0;
  unsigned int v393 = 0;
  v394 = (char *)v396;
  uint64_t v395 = 0x400000000;
  uint64_t v8 = *((void *)a2 + 5) + 272;
  *(void *)v387 = this;
  *(void *)&v387[8] = v8;
  *(void *)&v387[16] = v7;
  v388 = (uint64_t *)&v391;
  v389 = (void **)&v394;
  unint64_t v9 = (char *)a2 + 72;
  v349 = a2;
  for (uint64_t i = *((void *)a2 + 10); (char *)i != v9; uint64_t i = *(void *)(i + 8))
  {
    uint64_t v11 = i - 24;
    if (!i) {
      uint64_t v11 = 0;
    }
    uint64_t v12 = v11 + 40;
    for (uint64_t j = *(void *)(v11 + 48); j != v12; uint64_t j = *(void *)(j + 8))
    {
      if (j) {
        int v14 = (unsigned __int8 *)(j - 24);
      }
      else {
        int v14 = 0;
      }
      int v15 = v14[16];
      if ((v15 - 81) >= 2)
      {
        BOOL v16 = v15 != 33 && (v15 - 40) >= 0xFFFFFFF5;
        int v18 = !v16 || v15 == 29;
        if (v15 != 63 && v18 != 0) {
          sub_1CD468810((llvm::cflaa *)v387, (llvm::cflaa *)v14);
        }
      }
    }
  }
  if (*((_WORD *)v349 + 9))
  {
    llvm::Function::BuildLazyArguments(v349);
    uint64_t v20 = (llvm::cflaa *)*((void *)v349 + 11);
    if (*((_WORD *)v349 + 9))
    {
      llvm::Function::BuildLazyArguments(v349);
      uint64_t v21 = (llvm::cflaa *)*((void *)v349 + 11);
      goto LABEL_31;
    }
  }
  else
  {
    uint64_t v20 = (llvm::cflaa *)*((void *)v349 + 11);
  }
  uint64_t v21 = v20;
LABEL_31:
  uint64_t v22 = (llvm::cflaa *)((char *)v21 + 40 * *((void *)v349 + 12));
  while (v20 != v22)
  {
    sub_1CD468790((BOOL)v390, v20);
    uint64_t v20 = (llvm::cflaa *)((char *)v20 + 40);
  }
  uint64_t v382 = 0;
  uint64_t v383 = 0;
  unsigned int v384 = 0;
  v380[0] = 0;
  v380[1] = 0;
  unsigned int v381 = 0;
  v377 = 0;
  v378 = 0;
  uint64_t v379 = 0;
  std::string __p = 0;
  v375 = 0;
  char v23 = &v391[4 * v393];
  uint64_t v376 = 0;
  if (v392)
  {
    if (v393)
    {
      uint64_t v25 = 32 * v393;
      BOOL v24 = v391;
      while ((*v24 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v24 += 4;
        v25 -= 32;
        if (!v25) {
          goto LABEL_40;
        }
      }
    }
    else
    {
      BOOL v24 = v391;
    }
  }
  else
  {
LABEL_40:
    BOOL v24 = &v391[4 * v393];
  }
  size_t v26 = &v391[4 * v393];
  if (v24 != v26)
  {
    do
    {
      uint64_t v27 = -1227133513 * ((unint64_t)(v24[2] - v24[1]) >> 3);
      if (v27)
      {
        uint64_t v28 = 0;
        uint64_t v29 = *v24;
        do
        {
          uint64_t v30 = v24[1] + 56 * v28;
          BOOL v32 = *(uint64_t **)v30;
          char v31 = *(uint64_t **)(v30 + 8);
          while (v32 != v31)
          {
            sub_1CBF97DD0(*v32, v32[1], v29, v28, 0, (uint64_t)&v382, (char **)&v377);
            uint64_t v33 = *v32;
            uint64_t v34 = v32[1];
            v32 += 3;
            sub_1CBF97DD0(v29, v28, v33, v34, 3, (uint64_t)&v382, (char **)&v377);
          }
          ++v28;
        }
        while (v28 != v27);
      }
      size_t v35 = v24 + 4;
      BOOL v24 = v23;
      if (v35 != v23)
      {
        BOOL v24 = v35;
        while ((*v24 | 0x1000) == 0xFFFFFFFFFFFFF000)
        {
          v24 += 4;
          if (v24 == v23)
          {
            BOOL v24 = v23;
            break;
          }
        }
      }
    }
    while (v24 != v26);
    char v36 = (uint64_t *)v377;
    v361 = v378;
    if (v377 != v378)
    {
      uint64_t v37 = v379;
      do
      {
        uint64_t v353 = v37;
        unint64_t v356 = (unint64_t)v36;
        do
        {
          uint64_t v38 = *v36;
          uint64_t v39 = v36[1];
          uint64_t v40 = v36[2];
          uint64_t v41 = v36[3];
          uint64_t v365 = sub_1CD467844((uint64_t)&v391, v40, v41);
          uint64_t v42 = sub_1CD467844((uint64_t)&v391, v38, (int)v39 + 1);
          uint64_t v43 = (v41 + 1);
          uint64_t v44 = sub_1CD467844((uint64_t)&v391, v40, (int)v41 + 1);
          if (v42) {
            BOOL v45 = v44 == 0;
          }
          else {
            BOOL v45 = 1;
          }
          if (!v45)
          {
            *(void *)&long long v385 = v38;
            *((void *)&v385 + 1) = (v39 + 1);
            uint64_t v371 = v40;
            uint64_t v372 = (v41 + 1);
            uint64_t v70 = sub_1CD46797C((uint64_t)v380, (uint64_t)&v385);
            sub_1CD4679F4((uint64_t)v387, v70 + 16, (uint64_t)&v371);
            if (v387[16])
            {
              int v351 = v41;
              sub_1CBF97DD0(v38, (v39 + 1), v40, (v41 + 1), 1, (uint64_t)&v382, (char **)&__p);
              sub_1CBF97F84((uint64_t *)v387, (uint64_t)&v382, v38, v39 + 1);
              int v71 = *(uint64_t **)v387;
              v358 = *(uint64_t **)&v387[16];
              if (*(void *)v387 != *(void *)&v387[16])
              {
                uint64_t v72 = *(uint64_t **)&v387[8];
                do
                {
                  uint64_t v74 = *v71;
                  uint64_t v73 = v71[1];
                  uint64_t v75 = v71[2];
                  if (v75)
                  {
                    sub_1CBF97DD0(*v71, v71[1], v40, v43, 2, (uint64_t)&v382, (char **)&__p);
                    uint64_t v75 = v71[2];
                    if ((v75 & 8) == 0)
                    {
LABEL_86:
                      if ((v75 & 0x10) == 0) {
                        goto LABEL_88;
                      }
LABEL_87:
                      sub_1CBF97DD0(v74, v73, v40, v43, 6, (uint64_t)&v382, (char **)&__p);
                      goto LABEL_88;
                    }
                  }
                  else if ((v75 & 8) == 0)
                  {
                    goto LABEL_86;
                  }
                  sub_1CBF97DD0(v74, v73, v40, v43, 5, (uint64_t)&v382, (char **)&__p);
                  if ((v71[2] & 0x10) != 0) {
                    goto LABEL_87;
                  }
LABEL_88:
                  while (1)
                  {
                    v71 += 3;
                    if (v71 == v72) {
                      break;
                    }
                    int v76 = *((_DWORD *)v71 + 2);
                    if ((*v71 != -4096 || v76 != -1) && (*v71 != -8192 || v76 != -2)) {
                      goto LABEL_99;
                    }
                  }
                  int v71 = v72;
LABEL_99:
                  ;
                }
                while (v71 != v358);
              }
              LODWORD(v41) = v351;
            }
          }
          switch(*((unsigned char *)v36 + 32))
          {
            case 0:
              int v89 = *(uint64_t **)(v365 + 24);
              int v90 = *(uint64_t **)(v365 + 32);
              while (v89 != v90)
              {
                uint64_t v91 = *v89;
                uint64_t v92 = v89[1];
                v89 += 3;
                sub_1CBF97DD0(v38, v39, v91, v92, 0, (uint64_t)&v382, (char **)&__p);
              }
              char v93 = *(uint64_t **)v365;
              uint64_t v94 = *(uint64_t **)(v365 + 8);
              int v81 = v41;
              while (v93 != v94)
              {
                uint64_t v95 = *v93;
                uint64_t v96 = v93[1];
                v93 += 3;
                sub_1CBF97DD0(v38, v39, v95, v96, 4, (uint64_t)&v382, (char **)&__p);
              }
              char v84 = 2;
              goto LABEL_120;
            case 1:
              uint64_t v46 = *(uint64_t **)(v365 + 24);
              size_t v47 = *(uint64_t **)(v365 + 32);
              while (v46 != v47)
              {
                uint64_t v48 = *v46;
                uint64_t v49 = v46[1];
                v46 += 3;
                sub_1CBF97DD0(v38, v39, v48, v49, 0, (uint64_t)&v382, (char **)&__p);
              }
              uint64_t v54 = *(uint64_t **)v365;
              uint64_t v55 = *(uint64_t **)(v365 + 8);
              while (v54 != v55)
              {
                uint64_t v56 = *v54;
                uint64_t v57 = v54[1];
                v54 += 3;
                sub_1CBF97DD0(v38, v39, v56, v57, 3, (uint64_t)&v382, (char **)&__p);
              }
              goto LABEL_154;
            case 2:
              int v58 = *(uint64_t **)(v365 + 24);
              unint64_t v59 = *(uint64_t **)(v365 + 32);
              while (v58 != v59)
              {
                uint64_t v60 = *v58;
                uint64_t v61 = v58[1];
                v58 += 3;
                sub_1CBF97DD0(v38, v39, v60, v61, 0, (uint64_t)&v382, (char **)&__p);
              }
              unsigned int v62 = *(uint64_t **)v365;
              uint64_t v63 = *(uint64_t **)(v365 + 8);
              while (v62 != v63)
              {
                uint64_t v64 = *v62;
                uint64_t v65 = v62[1];
                v62 += 3;
                sub_1CBF97DD0(v38, v39, v64, v65, 4, (uint64_t)&v382, (char **)&__p);
              }
              goto LABEL_154;
            case 3:
              uint64_t v85 = *(uint64_t **)v365;
              int v86 = *(uint64_t **)(v365 + 8);
              int v81 = v41;
              while (v85 != v86)
              {
                uint64_t v87 = *v85;
                uint64_t v88 = v85[1];
                v85 += 3;
                sub_1CBF97DD0(v38, v39, v87, v88, 3, (uint64_t)&v382, (char **)&__p);
              }
              char v84 = 5;
              goto LABEL_120;
            case 4:
              int v79 = *(uint64_t **)v365;
              int v80 = *(uint64_t **)(v365 + 8);
              int v81 = v41;
              while (v79 != v80)
              {
                uint64_t v82 = *v79;
                uint64_t v83 = v79[1];
                v79 += 3;
                sub_1CBF97DD0(v38, v39, v82, v83, 4, (uint64_t)&v382, (char **)&__p);
              }
              char v84 = 6;
LABEL_120:
              *(void *)v387 = 0;
              uint64_t v97 = v380[0];
              unsigned int v98 = v381;
              if (sub_1CD4670BC(v380[0], v381, v40, v81, v387)) {
                uint64_t v99 = *(void *)v387;
              }
              else {
                uint64_t v99 = v97 + 40 * v98;
              }
              uint64_t v100 = v99 + 16;
              if (v99 == v97 + 40 * v98) {
                goto LABEL_154;
              }
              int v101 = *(_DWORD *)(v99 + 24);
              uint64_t v102 = *(void *)(v99 + 16);
              uint64_t v103 = *(unsigned int *)(v99 + 32);
              int v104 = (uint64_t *)(v102 + 16 * v103);
              int v105 = v104;
              if (!v101) {
                goto LABEL_139;
              }
              if (!v103) {
                goto LABEL_138;
              }
              uint64_t v106 = 16 * v103;
              break;
            case 5:
              int v50 = *(uint64_t **)v365;
              int v51 = *(uint64_t **)(v365 + 8);
              while (v50 != v51)
              {
                uint64_t v52 = *v50;
                uint64_t v53 = v50[1];
                v50 += 3;
                sub_1CBF97DD0(v38, v39, v52, v53, 3, (uint64_t)&v382, (char **)&__p);
              }
              goto LABEL_154;
            case 6:
              int v66 = *(uint64_t **)v365;
              uint64_t v67 = *(uint64_t **)(v365 + 8);
              while (v66 != v67)
              {
                uint64_t v68 = *v66;
                uint64_t v69 = v66[1];
                v66 += 3;
                sub_1CBF97DD0(v38, v39, v68, v69, 4, (uint64_t)&v382, (char **)&__p);
              }
              goto LABEL_154;
            default:
              goto LABEL_154;
          }
          while (1)
          {
            int v107 = *(_DWORD *)(v102 + 8);
            if ((*(void *)v102 != -4096 || v107 != -1) && (*(void *)v102 != -8192 || v107 != -2)) {
              break;
            }
            v102 += 16;
            v106 -= 16;
            if (!v106)
            {
              int v105 = v104;
              goto LABEL_139;
            }
          }
LABEL_138:
          int v105 = (uint64_t *)v102;
LABEL_139:
          uint64_t v110 = *(void *)v100 + 16 * *(unsigned int *)(v100 + 16);
LABEL_140:
          while (v105 != (uint64_t *)v110)
          {
            sub_1CBF97DD0(v38, v39, *v105, v105[1], v84, (uint64_t)&v382, (char **)&__p);
            uint64_t v111 = v105 + 2;
            int v105 = v104;
            if (v111 != v104)
            {
              int v105 = v111;
              while (1)
              {
                int v112 = *((_DWORD *)v105 + 2);
                if ((*v105 != -4096 || v112 != -1) && (*v105 != -8192 || v112 != -2)) {
                  break;
                }
                v105 += 2;
                if (v105 == v104)
                {
                  int v105 = v104;
                  goto LABEL_140;
                }
              }
            }
          }
LABEL_154:
          v36 += 5;
        }
        while (v36 != v361);
        v377 = __p;
        v378 = v375;
        uint64_t v37 = v376;
        uint64_t v376 = v353;
        uint64_t v379 = v37;
        std::string __p = (void *)v356;
        v375 = (uint64_t *)v356;
        char v36 = (uint64_t *)v377;
        v361 = v378;
      }
      while (v377 != v378);
    }
  }
  uint64_t v371 = 0;
  uint64_t v372 = 0;
  unsigned int v373 = 0;
  v115 = &v391[4 * v393];
  if (v392)
  {
    if (v393)
    {
      uint64_t v117 = 32 * v393;
      int v116 = v391;
      while ((*v116 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v116 += 4;
        v117 -= 32;
        if (!v117) {
          goto LABEL_162;
        }
      }
    }
    else
    {
      int v116 = v391;
    }
  }
  else
  {
LABEL_162:
    int v116 = &v391[4 * v393];
  }
  v366 = &v391[4 * v393];
  if (v116 != v366)
  {
    uint64_t v118 = 0;
    v119 = 0;
    int v120 = 0;
    do
    {
      uint64_t v121 = -1227133513 * ((unint64_t)(v116[2] - v116[1]) >> 3);
      if (v121)
      {
        uint64_t v122 = 0;
        uint64_t v123 = *v116;
        uint64_t v124 = (char *)v119;
        do
        {
          uint64_t v125 = *(void *)(v116[1] + 56 * v122 + 48);
          *(void *)v387 = v123;
          *(void *)&v387[8] = v122;
          uint64_t v126 = sub_1CD467468((uint64_t)&v371, (uint64_t)v387);
          uint64_t v127 = *(void *)(v126 + 16);
          if ((v127 | v125) != v127) {
            *(void *)(v126 + 16) = v127 | v125;
          }
          if (v124 >= v118)
          {
            uint64_t v128 = v118;
            uint64_t v129 = (v124 - (char *)v120) >> 4;
            unint64_t v130 = v129 + 1;
            if ((unint64_t)(v129 + 1) >> 60) {
LABEL_602:
            }
              abort();
            unint64_t v131 = v128 - (char *)v120;
            unint64_t v132 = (v128 - (char *)v120) >> 3;
            if (v132 > v130) {
              unint64_t v130 = v132;
            }
            if (v131 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v133 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v133 = v130;
            }
            if (v133)
            {
              if (v133 >> 60) {
LABEL_603:
              }
                sub_1CB833614();
              v134 = (char *)operator new(16 * v133);
            }
            else
            {
              v134 = 0;
            }
            v135 = &v134[16 * v129];
            *(void *)v135 = v123;
            *((void *)v135 + 1) = v122;
            if (v124 == (char *)v120)
            {
              int v120 = (unint64_t *)&v134[16 * v129];
            }
            else
            {
              v136 = &v134[16 * v129];
              do
              {
                *((_OWORD *)v136 - 1) = *((_OWORD *)v124 - 1);
                v136 -= 16;
                v124 -= 16;
              }
              while (v124 != (char *)v120);
              uint64_t v124 = (char *)v120;
              int v120 = (unint64_t *)v136;
            }
            uint64_t v118 = &v134[16 * v133];
            v119 = (unint64_t *)(v135 + 16);
            if (v124) {
              operator delete(v124);
            }
          }
          else
          {
            *(void *)uint64_t v124 = v123;
            *((void *)v124 + 1) = v122;
            v119 = (unint64_t *)(v124 + 16);
          }
          ++v122;
          uint64_t v124 = (char *)v119;
        }
        while (v122 != v121);
      }
      uint64_t v137 = v116 + 4;
      int v116 = v115;
      if (v137 != v115)
      {
        int v116 = v137;
        while ((*v116 | 0x1000) == 0xFFFFFFFFFFFFF000)
        {
          v116 += 4;
          if (v116 == v115)
          {
            int v116 = v115;
            break;
          }
        }
      }
    }
    while (v116 != v366);
    if (v120 != v119)
    {
      int v138 = 0;
      v139 = 0;
      do
      {
        v140 = v139;
        v141 = v138;
        v139 = v120;
        int v138 = v118;
        v142 = v120;
        uint64_t v118 = v141;
        int v120 = v140;
        do
        {
          uint64_t v143 = *v142;
          int v144 = *((_DWORD *)v142 + 2);
          *(void *)v387 = 0;
          uint64_t v145 = v371;
          unsigned int v146 = v373;
          if (sub_1CD4674DC(v371, v373, v143, v144, v387)) {
            BOOL v147 = *(void *)v387 == v145 + 24 * v146;
          }
          else {
            BOOL v147 = 1;
          }
          if (!v147 && *(void *)(*(void *)v387 + 16))
          {
            uint64_t v367 = *(void *)(*(void *)v387 + 16);
            v352 = v138;
            v354 = v139;
            sub_1CBF97F84((uint64_t *)v387, (uint64_t)&v382, *v142, v142[1]);
            v148 = *(unint64_t **)v387;
            v362 = *(unint64_t **)&v387[16];
            if (*(void *)v387 != *(void *)&v387[16])
            {
              v149 = *(unint64_t **)&v387[8];
              do
              {
                unint64_t v151 = *v148;
                unint64_t v150 = v148[1];
                *(void *)&long long v385 = *v148;
                *((void *)&v385 + 1) = v150;
                uint64_t v152 = sub_1CD467468((uint64_t)&v371, (uint64_t)&v385);
                uint64_t v153 = *(void *)(v152 + 16);
                if ((v153 | v367) != v153)
                {
                  *(void *)(v152 + 16) = v153 | v367;
                  if (v140 >= (unint64_t *)v118)
                  {
                    v154 = v118;
                    uint64_t v155 = ((char *)v140 - (char *)v120) >> 4;
                    unint64_t v156 = v155 + 1;
                    if ((unint64_t)(v155 + 1) >> 60) {
                      goto LABEL_602;
                    }
                    unint64_t v157 = v154 - (char *)v120;
                    unint64_t v158 = (v154 - (char *)v120) >> 3;
                    if (v158 > v156) {
                      unint64_t v156 = v158;
                    }
                    if (v157 >= 0x7FFFFFFFFFFFFFF0) {
                      unint64_t v159 = 0xFFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v159 = v156;
                    }
                    if (v159)
                    {
                      if (v159 >> 60) {
                        goto LABEL_603;
                      }
                      unint64_t v359 = v159;
                      v160 = (char *)operator new(16 * v159);
                      unint64_t v159 = v359;
                    }
                    else
                    {
                      v160 = 0;
                    }
                    v161 = &v160[16 * v155];
                    *(void *)v161 = v151;
                    *((void *)v161 + 1) = v150;
                    if (v140 == v120)
                    {
                      v162 = v140;
                      int v120 = (unint64_t *)&v160[16 * v155];
                    }
                    else
                    {
                      v163 = &v160[16 * v155];
                      do
                      {
                        *((_OWORD *)v163 - 1) = *((_OWORD *)v140 - 1);
                        v163 -= 16;
                        v140 -= 2;
                      }
                      while (v140 != v120);
                      v162 = v120;
                      int v120 = (unint64_t *)v163;
                    }
                    uint64_t v118 = &v160[16 * v159];
                    v140 = (unint64_t *)(v161 + 16);
                    if (v162) {
                      operator delete(v162);
                    }
                  }
                  else
                  {
                    unint64_t *v140 = v151;
                    v140[1] = v150;
                    v140 += 2;
                  }
                }
                v164 = v148 + 3;
                v148 = v149;
                if (v164 != v149)
                {
                  v148 = v164;
                  while (1)
                  {
                    int v165 = *((_DWORD *)v148 + 2);
                    if ((*v148 != -4096 || v165 != -1) && (*v148 != -8192 || v165 != -2)) {
                      break;
                    }
                    v148 += 3;
                    if (v148 == v149)
                    {
                      v148 = v149;
                      break;
                    }
                  }
                }
              }
              while (v148 != v362);
            }
            uint64_t v168 = *v142;
            int v169 = *((_DWORD *)v142 + 2);
            unint64_t v170 = (v169 + 1);
            uint64_t v171 = sub_1CD467844((uint64_t)&v391, *v142, v169 + 1);
            unint64_t v172 = v356 & 0xFFFFFFFFFFFFFF00;
            if (v171) {
              unint64_t v172 = v168;
            }
            unint64_t v356 = v172;
            if (v171)
            {
              int v138 = v352;
              v139 = v354;
              unint64_t v173 = v172;
              while (1)
              {
                *(void *)v387 = v173;
                *(void *)&v387[8] = v170;
                uint64_t v174 = sub_1CD467468((uint64_t)&v371, (uint64_t)v387);
                uint64_t v175 = *(void *)(v174 + 16);
                if ((v175 | v367) != v175) {
                  break;
                }
                unint64_t v170 = (v170 + 1);
                uint64_t v176 = sub_1CD467844((uint64_t)&v391, v173, v170);
                if (!v176) {
                  unint64_t v173 = v350 & 0xFFFFFFFFFFFFFF00;
                }
                unint64_t v350 = v173;
                if (!v176)
                {
                  unint64_t v356 = v173;
                  goto LABEL_203;
                }
              }
              unint64_t v356 = v173;
              *(void *)(v174 + 16) = v175 | v367;
              if (v140 >= (unint64_t *)v118)
              {
                v177 = v118;
                uint64_t v178 = ((char *)v140 - (char *)v120) >> 4;
                unint64_t v179 = v178 + 1;
                if ((unint64_t)(v178 + 1) >> 60) {
                  goto LABEL_602;
                }
                unint64_t v180 = v177 - (char *)v120;
                unint64_t v181 = (v177 - (char *)v120) >> 3;
                if (v181 > v179) {
                  unint64_t v179 = v181;
                }
                if (v180 >= 0x7FFFFFFFFFFFFFF0) {
                  unint64_t v182 = 0xFFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v182 = v179;
                }
                if (v182)
                {
                  if (v182 >> 60) {
                    goto LABEL_603;
                  }
                  v183 = (char *)operator new(16 * v182);
                }
                else
                {
                  v183 = 0;
                }
                v184 = (unint64_t *)&v183[16 * v178];
                unint64_t *v184 = v356;
                v184[1] = v170;
                if (v140 == v120)
                {
                  v186 = &v183[16 * v178];
                }
                else
                {
                  v185 = &v183[16 * v178];
                  do
                  {
                    v186 = v185 - 16;
                    *((_OWORD *)v185 - 1) = *((_OWORD *)v140 - 1);
                    v140 -= 2;
                    v185 -= 16;
                  }
                  while (v140 != v120);
                }
                uint64_t v118 = &v183[16 * v182];
                v140 = v184 + 2;
                if (v120) {
                  operator delete(v120);
                }
                int v120 = (unint64_t *)v186;
              }
              else
              {
                unint64_t *v140 = v173;
                v140[1] = v170;
                v140 += 2;
              }
            }
            else
            {
              int v138 = v352;
              v139 = v354;
            }
          }
LABEL_203:
          v142 += 2;
        }
        while (v142 != v119);
        v119 = v140;
      }
      while (v120 != v140);
      if (v139) {
        operator delete(v139);
      }
    }
    if (v120) {
      operator delete(v120);
    }
  }
  *(void *)(a3 + 24) = 0;
  unint64_t v187 = a3 + 24;
  *(void *)(a3 + 48) = a3 + 64;
  v188 = (uint64_t **)(a3 + 48);
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 16) = 0;
  *(void *)(a3 + 32) = 0;
  *(_DWORD *)(a3 + 40) = 0;
  *(void *)(a3 + 56) = 0x800000000;
  unint64_t v189 = a3 + 272;
  *(void *)(a3 + 256) = a3 + 272;
  *(void *)(a3 + 264) = 0x800000000;
  uint64_t v190 = v371;
  int v191 = v372;
  uint64_t v192 = v373;
  uint64_t v193 = v371 + 24 * v373;
  unsigned int v194 = v373;
  uint64_t v195 = v193;
  if (v372)
  {
    if (v373)
    {
      uint64_t v196 = 24 * v373;
      uint64_t v195 = v371;
      do
      {
        int v197 = *(_DWORD *)(v195 + 8);
        if ((*(void *)v195 != -4096 || v197 != -1) && (*(void *)v195 != -8192 || v197 != -2))
        {
          unsigned int v194 = v373;
          goto LABEL_293;
        }
        v195 += 24;
        v196 -= 24;
      }
      while (v196);
      unsigned int v194 = v373;
      uint64_t v195 = v371 + 24 * v373;
    }
    else
    {
      unsigned int v194 = 0;
      uint64_t v195 = v371;
    }
  }
LABEL_293:
  uint64_t v200 = v371 + 24 * v194;
LABEL_294:
  while (v195 != v200)
  {
    *(_OWORD *)v387 = *(_OWORD *)v195;
    v201 = sub_1CD467E2C(a3 + 24, (uint64_t *)v387);
    if (!*(_DWORD *)&v387[8]) {
      v201[1] |= *(void *)(v195 + 16);
    }
    uint64_t v202 = v195 + 24;
    uint64_t v195 = v193;
    if (v202 != v193)
    {
      uint64_t v195 = v202;
      while (1)
      {
        int v203 = *(_DWORD *)(v195 + 8);
        if ((*(void *)v195 != -4096 || v203 != -1) && (*(void *)v195 != -8192 || v203 != -2)) {
          break;
        }
        v195 += 24;
        if (v195 == v193)
        {
          uint64_t v195 = v193;
          goto LABEL_294;
        }
      }
    }
  }
  if (v191)
  {
    if (v192)
    {
      uint64_t v207 = 24 * v192;
      uint64_t v206 = v190;
      while (1)
      {
        int v208 = *(_DWORD *)(v206 + 8);
        if ((*(void *)v206 != -4096 || v208 != -1) && (*(void *)v206 != -8192 || v208 != -2)) {
          break;
        }
        v206 += 24;
        v207 -= 24;
        if (!v207) {
          goto LABEL_324;
        }
      }
    }
    else
    {
      uint64_t v206 = v190;
    }
  }
  else
  {
LABEL_324:
    uint64_t v206 = v193;
  }
  uint64_t v211 = v190 + 24 * v192;
  if (v206 != v211)
  {
    unint64_t v187 = a3 + 256;
    do
    {
      uint64_t v215 = *(void *)v206;
      uint64_t v214 = *(void *)(v206 + 8);
      if (*(void *)v206) {
        BOOL v216 = *(unsigned char *)(*(void *)v206 + 16) == 21;
      }
      else {
        BOOL v216 = 0;
      }
      if (v216)
      {
        unint64_t v219 = (*(_DWORD *)(v215 + 32) + 1) | (unint64_t)(v214 << 32);
      }
      else
      {
        if (v395)
        {
          uint64_t v217 = 8 * v395;
          v218 = v394;
          while (*(void *)v218 != v215)
          {
            v218 += 8;
            v217 -= 8;
            if (!v217)
            {
              v218 = &v394[8 * v395];
              break;
            }
          }
        }
        else
        {
          v218 = v394;
        }
        if (v395 == (v218 - v394) >> 3) {
          goto LABEL_346;
        }
        unint64_t v219 = v214 << 32;
      }
      uint64_t v220 = *(void *)(v206 + 16) & 7;
      if (v220)
      {
        unint64_t v221 = *(unsigned int *)(a3 + 264);
        if (v221 >= *(unsigned int *)(a3 + 268)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        v222 = (unint64_t *)(*(void *)(a3 + 256) + 16 * v221);
        unint64_t *v222 = v219;
        v222[1] = v220;
        ++*(_DWORD *)(a3 + 264);
      }
LABEL_346:
      uint64_t v223 = v206 + 24;
      uint64_t v206 = v193;
      if (v223 != v193)
      {
        uint64_t v206 = v223;
        while (1)
        {
          int v224 = *(_DWORD *)(v206 + 8);
          if ((*(void *)v206 != -4096 || v224 != -1) && (*(void *)v206 != -8192 || v224 != -2)) {
            break;
          }
          v206 += 24;
          if (v206 == v193)
          {
            uint64_t v206 = v193;
            break;
          }
        }
      }
    }
    while (v206 != v211);
  }
  uint64_t v212 = v382 + 40 * v384;
  if (v383)
  {
    if (v384)
    {
      uint64_t v227 = 40 * v384;
      uint64_t v213 = v382;
      while (1)
      {
        int v228 = *(_DWORD *)(v213 + 8);
        if ((*(void *)v213 != -4096 || v228 != -1) && (*(void *)v213 != -8192 || v228 != -2)) {
          break;
        }
        v213 += 40;
        v227 -= 40;
        if (!v227) {
          goto LABEL_373;
        }
      }
    }
    else
    {
      uint64_t v213 = v382;
    }
  }
  else
  {
LABEL_373:
    uint64_t v213 = v382 + 40 * v384;
  }
  uint64_t v231 = v382 + 40 * v384;
  if (v213 != v231)
  {
    uint64_t v363 = v382 + 40 * v384;
    while (*(_DWORD *)(v213 + 8))
    {
LABEL_381:
      uint64_t v236 = v213 + 40;
      uint64_t v213 = v212;
      if (v236 != v212)
      {
        uint64_t v213 = v236;
        while (1)
        {
          int v237 = *(_DWORD *)(v213 + 8);
          if ((*(void *)v213 != -4096 || v237 != -1) && (*(void *)v213 != -8192 || v237 != -2)) {
            break;
          }
          v213 += 40;
          if (v213 == v212)
          {
            uint64_t v213 = v212;
            break;
          }
        }
      }
      if (v213 == v231) {
        goto LABEL_375;
      }
    }
    unint64_t v189 = *(void *)v213;
    *(void *)v387 = 0;
    char v240 = sub_1CBF98030(*(void *)a3, *(_DWORD *)(a3 + 16), v189, v387);
    v241 = *(unint64_t **)v387;
    if (v240)
    {
LABEL_402:
      uint64_t v244 = sub_1CD467DD0((uint64_t *)(v213 + 16));
      uint64_t v246 = *(void *)(v213 + 16) + 24 * *(unsigned int *)(v213 + 32);
      if (v246 != v244)
      {
        unint64_t v187 = v244;
        unint64_t v189 = v245;
        uint64_t v368 = *(void *)(v213 + 16) + 24 * *(unsigned int *)(v213 + 32);
        do
        {
          if (*(_DWORD *)(v187 + 8)) {
            goto LABEL_424;
          }
          uint64_t v247 = *(void *)v187;
          v249 = (void *)v241[2];
          unint64_t v248 = v241[3];
          if ((unint64_t)v249 >= v248)
          {
            unint64_t v251 = v241[1];
            uint64_t v252 = (uint64_t)((uint64_t)v249 - v251) >> 4;
            unint64_t v253 = v252 + 1;
            if ((unint64_t)(v252 + 1) >> 60) {
              goto LABEL_602;
            }
            uint64_t v254 = v248 - v251;
            if (v254 >> 3 > v253) {
              unint64_t v253 = v254 >> 3;
            }
            if ((unint64_t)v254 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v255 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v255 = v253;
            }
            if (v255)
            {
              if (v255 >> 60) {
                goto LABEL_603;
              }
              v256 = (char *)operator new(16 * v255);
            }
            else
            {
              v256 = 0;
            }
            v257 = &v256[16 * v252];
            *(void *)v257 = v247;
            *((void *)v257 + 1) = 0x7FFFFFFFFFFFFFFFLL;
            v259 = (char *)v241[1];
            v258 = (char *)v241[2];
            v260 = v257;
            if (v258 != v259)
            {
              do
              {
                *((_OWORD *)v260 - 1) = *((_OWORD *)v258 - 1);
                v260 -= 16;
                v258 -= 16;
              }
              while (v258 != v259);
              v258 = (char *)v241[1];
            }
            v250 = v257 + 16;
            v241[1] = (unint64_t)v260;
            v241[2] = (unint64_t)(v257 + 16);
            v241[3] = (unint64_t)&v256[16 * v255];
            if (v258) {
              operator delete(v258);
            }
            uint64_t v246 = v368;
          }
          else
          {
            void *v249 = v247;
            v249[1] = 0x7FFFFFFFFFFFFFFFLL;
            v250 = v249 + 2;
          }
          v241[2] = (unint64_t)v250;
LABEL_424:
          while (1)
          {
            v187 += 24;
            if (v187 == v189) {
              break;
            }
            int v261 = *(_DWORD *)(v187 + 8);
            if ((*(void *)v187 != -4096 || v261 != -1) && (*(void *)v187 != -8192 || v261 != -2)) {
              goto LABEL_435;
            }
          }
          unint64_t v187 = v189;
LABEL_435:
          ;
        }
        while (v187 != v246);
      }
      unint64_t v264 = v241[1];
      v265 = (long long *)v241[2];
      unint64_t v266 = 126 - 2 * __clz((uint64_t)((uint64_t)v265 - v264) >> 4);
      if (v265 == (long long *)v264) {
        uint64_t v267 = 0;
      }
      else {
        uint64_t v267 = v266;
      }
      sub_1CBF98228(v264, v265, v267, 1);
      uint64_t v231 = v363;
      goto LABEL_381;
    }
    int v242 = *(_DWORD *)(a3 + 8);
    unsigned int v243 = *(_DWORD *)(a3 + 16);
    if (4 * v242 + 4 >= 3 * v243)
    {
      v243 *= 2;
    }
    else if (v243 + ~v242 - *(_DWORD *)(a3 + 12) > v243 >> 3)
    {
LABEL_399:
      ++*(_DWORD *)(a3 + 8);
      if (*v241 != -4096) {
        --*(_DWORD *)(a3 + 12);
      }
      unint64_t *v241 = v189;
      v241[1] = 0;
      v241[2] = 0;
      v241[3] = 0;
      goto LABEL_402;
    }
    sub_1CBF980C4(a3, v243);
    *(void *)v387 = 0;
    sub_1CBF98030(*(void *)a3, *(_DWORD *)(a3 + 16), v189, v387);
    v241 = *(unint64_t **)v387;
    goto LABEL_399;
  }
LABEL_375:
  uint64_t v232 = sub_1CB923B44(v349);
  if (v232 != v233)
  {
    uint64_t v268 = v232;
    unint64_t v189 = v233;
    unint64_t v187 = 24;
    do
    {
      if (v395)
      {
        uint64_t v269 = 8 * v395;
        v270 = v394;
        while (*(void *)v270 != v268)
        {
          v270 += 8;
          v269 -= 8;
          if (!v269)
          {
            v270 = &v394[8 * v395];
            break;
          }
        }
      }
      else
      {
        v270 = v394;
      }
      if (v395 != (v270 - v394) >> 3)
      {
        *(_DWORD *)v387 = *(_DWORD *)(v268 + 32) + 1;
        memset(&v387[4], 0, 20);
        unint64_t v271 = sub_1CD41C4F0(a3 + 48, (unint64_t)v387, 1);
        uint64_t v272 = *(void *)(a3 + 48) + 24 * *(unsigned int *)(a3 + 56);
        long long v273 = *(_OWORD *)v271;
        *(void *)(v272 + 16) = *(void *)(v271 + 16);
        *(_OWORD *)uint64_t v272 = v273;
        ++*(_DWORD *)(a3 + 56);
      }
      v268 += 40;
    }
    while (v268 != v189);
  }
  memset(v387, 0, 20);
  uint64_t v234 = v382 + 40 * v384;
  if (v383)
  {
    if (v384)
    {
      uint64_t v274 = 40 * v384;
      uint64_t v235 = v382;
      while (1)
      {
        int v275 = *(_DWORD *)(v235 + 8);
        if ((*(void *)v235 != -4096 || v275 != -1) && (*(void *)v235 != -8192 || v275 != -2)) {
          break;
        }
        v235 += 40;
        v274 -= 40;
        if (!v274) {
          goto LABEL_464;
        }
      }
    }
    else
    {
      uint64_t v235 = v382;
    }
  }
  else
  {
LABEL_464:
    uint64_t v235 = v382 + 40 * v384;
  }
  uint64_t v369 = v382 + 40 * v384;
  uint64_t v360 = v382;
  if (v235 == v369)
  {
    LODWORD(v278) = 0;
    uint64_t v279 = 0;
    goto LABEL_531;
  }
  do
  {
    uint64_t v281 = *(void *)v235;
    uint64_t v280 = *(void *)(v235 + 8);
    if (*(void *)v235) {
      BOOL v282 = *(unsigned char *)(*(void *)v235 + 16) == 21;
    }
    else {
      BOOL v282 = 0;
    }
    if (v282)
    {
      uint64_t v289 = (*(_DWORD *)(v281 + 32) + 1) | (unint64_t)(v280 << 32);
      goto LABEL_495;
    }
    if (v395)
    {
      uint64_t v283 = 8 * v395;
      v284 = v394;
      while (*(void *)v284 != v281)
      {
        v284 += 8;
        v283 -= 8;
        if (!v283)
        {
          v284 = &v394[8 * v395];
          break;
        }
      }
    }
    else
    {
      v284 = v394;
    }
    if (v395 != (v284 - v394) >> 3)
    {
      uint64_t v289 = v280 << 32;
LABEL_495:
      uint64_t v290 = sub_1CD467DD0((uint64_t *)(v235 + 16));
      uint64_t v292 = *(void *)(v235 + 16) + 24 * *(unsigned int *)(v235 + 32);
      if (v292 != v290)
      {
        v293 = (void *)v290;
        v294 = v291;
        do
        {
          uint64_t v296 = *v293;
          uint64_t v295 = v293[1];
          if (*v293) {
            BOOL v297 = *(unsigned char *)(*v293 + 16) == 21;
          }
          else {
            BOOL v297 = 0;
          }
          if (v297)
          {
            unint64_t v300 = (*(_DWORD *)(v296 + 32) + 1) | (unint64_t)(v295 << 32);
          }
          else
          {
            if (v395)
            {
              uint64_t v298 = 8 * v395;
              v299 = v394;
              while (*(void *)v299 != v296)
              {
                v299 += 8;
                v298 -= 8;
                if (!v298)
                {
                  v299 = &v394[8 * v395];
                  break;
                }
              }
            }
            else
            {
              v299 = v394;
            }
            if (v395 == (v299 - v394) >> 3)
            {
              long long v385 = *(_OWORD *)v293;
              uint64_t v301 = v293[2];
              if ((v301 & 5) != 0)
              {
                uint64_t v302 = sub_1CBF990AC((uint64_t)v387, (uint64_t *)&v385);
                unint64_t v189 = v189 & 0xFFFFFFFF00000000 | DWORD2(v385);
                sub_1CB839378(v302, v289, v189);
                uint64_t v301 = v293[2];
              }
              if ((v301 & 0x28) != 0)
              {
                uint64_t v303 = sub_1CBF990AC((uint64_t)v387, (uint64_t *)&v385);
                unint64_t v187 = v187 & 0xFFFFFFFF00000000 | DWORD2(v385);
                sub_1CB839378(v303 + 64, v289, v187);
              }
              goto LABEL_517;
            }
            unint64_t v300 = v295 << 32;
          }
          if (v289 != v300 && (v293[2] & 5) != 0)
          {
            *(void *)&long long v385 = v289;
            *((void *)&v385 + 1) = v300;
            uint64_t v386 = 0x7FFFFFFFFFFFFFFFLL;
            unint64_t v307 = sub_1CD41C4F0(a3 + 48, (unint64_t)&v385, 1);
            uint64_t v308 = *(void *)(a3 + 48) + 24 * *(unsigned int *)(a3 + 56);
            long long v309 = *(_OWORD *)v307;
            *(void *)(v308 + 16) = *(void *)(v307 + 16);
            *(_OWORD *)uint64_t v308 = v309;
            ++*(_DWORD *)(a3 + 56);
          }
LABEL_517:
          while (1)
          {
            v293 += 3;
            if (v293 == v294) {
              break;
            }
            int v304 = *((_DWORD *)v293 + 2);
            if ((*v293 != -4096 || v304 != -1) && (*v293 != -8192 || v304 != -2)) {
              goto LABEL_528;
            }
          }
          v293 = v294;
LABEL_528:
          ;
        }
        while (v293 != (void *)v292);
      }
    }
    uint64_t v285 = v235 + 40;
    uint64_t v235 = v234;
    if (v285 != v234)
    {
      uint64_t v235 = v285;
      while (1)
      {
        int v286 = *(_DWORD *)(v235 + 8);
        if ((*(void *)v235 != -4096 || v286 != -1) && (*(void *)v235 != -8192 || v286 != -2)) {
          break;
        }
        v235 += 40;
        if (v235 == v234)
        {
          uint64_t v235 = v234;
          break;
        }
      }
    }
  }
  while (v235 != v369);
  uint64_t v279 = *(void *)v387;
  uint64_t v278 = *(unsigned int *)&v387[16];
  if (*(_DWORD *)&v387[8])
  {
    uint64_t v311 = *(void *)v387 + 136 * *(unsigned int *)&v387[16];
    if (*(_DWORD *)&v387[16])
    {
      uint64_t v338 = 0;
      while ((*(void *)(*(void *)v387 + v338) | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v338 += 136;
        if (136 * *(unsigned int *)&v387[16] == v338)
        {
          int v357 = 1;
          uint64_t v310 = *(void *)v387 + 136 * *(unsigned int *)&v387[16];
          goto LABEL_532;
        }
      }
      uint64_t v310 = *(void *)v387 + v338;
      int v357 = 1;
    }
    else
    {
      uint64_t v278 = 0;
      int v357 = 0;
      uint64_t v310 = *(void *)v387;
    }
  }
  else
  {
LABEL_531:
    uint64_t v278 = v278;
    int v357 = v278;
    uint64_t v310 = v279 + 136 * v278;
    uint64_t v311 = v310;
  }
LABEL_532:
  uint64_t v355 = v278;
  uint64_t v364 = v279;
  uint64_t v370 = v279 + 136 * v278;
  while (v310 != v370)
  {
    int v312 = *(_DWORD *)(v310 + 16);
    if (v312)
    {
      v313 = *(_DWORD **)(v310 + 8);
      v314 = &v313[3 * v312];
      do
      {
        uint64_t v315 = *(unsigned int *)(v310 + 80);
        if (v315)
        {
          uint64_t v316 = 12 * v315;
          v317 = (int *)(*(void *)(v310 + 72) + 4);
          do
          {
            unsigned int v318 = v317[1];
            unsigned int v319 = v313[2];
            if (v318 != v319)
            {
              unsigned int v320 = *(v317 - 1);
              int v321 = *v317;
              unsigned int v322 = v318 - v319;
              if (v318 < v319) {
                unsigned int v322 = 0;
              }
              unsigned int v323 = v313[1] + v322;
              BOOL v16 = v319 >= v318;
              unsigned int v324 = v319 - v318;
              if (!v16) {
                unsigned int v324 = 0;
              }
              LODWORD(v385) = *v313;
              *(void *)((char *)&v385 + 4) = __PAIR64__(v320, v323);
              HIDWORD(v385) = v321 + v324;
              uint64_t v386 = 0x7FFFFFFFFFFFFFFFLL;
              unint64_t v325 = sub_1CD41C4F0(a3 + 48, (unint64_t)&v385, 1);
              uint64_t v326 = *(void *)(a3 + 48) + 24 * *(unsigned int *)(a3 + 56);
              long long v327 = *(_OWORD *)v325;
              *(void *)(v326 + 16) = *(void *)(v325 + 16);
              *(_OWORD *)uint64_t v326 = v327;
              ++*(_DWORD *)(a3 + 56);
            }
            v317 += 3;
            v316 -= 12;
          }
          while (v316);
        }
        v313 += 3;
      }
      while (v313 != v314);
    }
    uint64_t v328 = v310 + 136;
    uint64_t v310 = v311;
    if (v328 != v311)
    {
      uint64_t v310 = v328;
      while ((*(void *)v310 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v310 += 136;
        if (v310 == v311)
        {
          uint64_t v310 = v311;
          break;
        }
      }
    }
  }
  size_t v329 = *(unsigned int *)(a3 + 56);
  if (v329 >= 2)
  {
    qsort(*(void **)(a3 + 48), v329, 0x18uLL, (int (__cdecl *)(const void *, const void *))sub_1CD4680D0);
    LODWORD(v329) = *(_DWORD *)(a3 + 56);
  }
  v330 = *v188;
  uint64_t v331 = (uint64_t)&(*v188)[3 * v329];
  v332 = *v188;
  if (v329)
  {
    if (v329 != 1)
    {
      unint64_t v333 = 0;
      uint64_t v334 = *v330;
      uint64_t v335 = v364;
      while (1)
      {
        uint64_t v336 = v330[v333 / 8 + 3];
        BOOL v337 = v334 == v336 && v330[v333 / 8 + 1] == v330[v333 / 8 + 4];
        if (v337 && v330[v333 / 8 + 2] == v330[v333 / 8 + 5]) {
          break;
        }
        v333 += 24;
        uint64_t v334 = v336;
        if (24 * v329 - 24 == v333) {
          goto LABEL_574;
        }
      }
      v332 = &v330[v333 / 8];
      goto LABEL_572;
    }
LABEL_573:
    uint64_t v335 = v364;
LABEL_574:
    int v339 = v357;
  }
  else
  {
LABEL_572:
    if (v332 == (uint64_t *)v331) {
      goto LABEL_573;
    }
    v340 = v332 + 6;
    uint64_t v335 = v364;
    if (v332 + 6 != (uint64_t *)v331)
    {
      do
      {
        BOOL v341 = *v332 == *v340 && v332[1] == v340[1];
        if (!v341 || v332[2] != v340[2])
        {
          long long v342 = *(_OWORD *)v340;
          v332[5] = v340[2];
          *(_OWORD *)(v332 + 3) = v342;
          v332 += 3;
        }
        v340 += 3;
      }
      while (v340 != (void *)v331);
      v330 = *v188;
    }
    int v339 = v357;
    uint64_t v331 = (uint64_t)(v332 + 3);
  }
  *(_DWORD *)(a3 + 56) = -1431655765 * ((unint64_t)(v331 - (void)v330) >> 3);
  if (v339)
  {
    uint64_t v343 = 136 * v355;
    v344 = (void *)(v335 + 88);
    do
    {
      if ((*(v344 - 11) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        v345 = (void *)*(v344 - 2);
        if (v344 != v345) {
          free(v345);
        }
        v346 = (char *)*(v344 - 10);
        if (v344 - 8 != (void *)v346) {
          free(v346);
        }
      }
      v344 += 17;
      v343 -= 136;
    }
    while (v343);
  }
  MEMORY[0x1D25D9CD0](v335, 8);
  MEMORY[0x1D25D9CD0](v371, 8);
  if (__p) {
    operator delete(__p);
  }
  if (v377) {
    operator delete(v377);
  }
  uint64_t v347 = v380[0];
  sub_1CD468160(v380[0], v381);
  MEMORY[0x1D25D9CD0](v347, 8);
  sub_1CD468160(v360, v384);
  MEMORY[0x1D25D9CD0](v360, 8);
  if (v394 != (char *)v396) {
    free(v394);
  }
  return sub_1CD4681D8((uint64_t *)&v391);
}

int32x2_t llvm::CFLAndersAAResult::evict(llvm::CFLAndersAAResult *this, const llvm::Function *a2)
{
  return sub_1CD466B08((uint64_t)this + 40, (uint64_t)a2);
}

uint64_t llvm::CFLAndersAAResult::ensureCached(llvm::CFLAndersAAResult *this, const llvm::Function *a2)
{
  uint64_t v8 = 0;
  int v4 = sub_1CD469D10(*((void *)this + 5), *((_DWORD *)this + 14), (uint64_t)a2, &v8);
  uint64_t v5 = v8;
  if (!v4) {
    uint64_t v5 = *((void *)this + 5) + 416 * *((unsigned int *)this + 14);
  }
  if (*((void *)this + 5) + 416 * *((unsigned int *)this + 14) == v5)
  {
    llvm::CFLAndersAAResult::scan(this, a2);
    uint64_t v8 = 0;
    int v7 = sub_1CD469D10(*((void *)this + 5), *((_DWORD *)this + 14), (uint64_t)a2, &v8);
    uint64_t v5 = v8;
    if (!v7) {
      uint64_t v5 = *((void *)this + 5) + 416 * *((unsigned int *)this + 14);
    }
  }
  return v5 + 8;
}

uint64_t llvm::CFLAndersAAResult::getAliasSummary(llvm::CFLAndersAAResult *this, const llvm::Function *a2)
{
  uint64_t v2 = llvm::CFLAndersAAResult::ensureCached(this, a2);
  if (*(unsigned char *)(v2 + 400)) {
    return v2 + 48;
  }
  else {
    return 0;
  }
}

void sub_1CBF97D2C()
{
}

void sub_1CBF97DD0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, char **a7)
{
  if (a1 != a3 || a2 != a4)
  {
    v29[0] = a1;
    v29[1] = a2;
    v28[0] = a3;
    v28[1] = a4;
    uint64_t v13 = sub_1CD467044(a6, (uint64_t)v28);
    uint64_t v14 = sub_1CD467468(v13 + 16, (uint64_t)v29);
    uint64_t v15 = *(void *)(v14 + 16);
    if ((v15 & (1 << a5)) == 0)
    {
      *(void *)(v14 + 16) = v15 | (1 << a5);
      unint64_t v17 = a7[1];
      unint64_t v16 = (unint64_t)a7[2];
      if ((unint64_t)v17 >= v16)
      {
        uint64_t v19 = *a7;
        unint64_t v20 = 0xCCCCCCCCCCCCCCCDLL * ((v17 - *a7) >> 3);
        unint64_t v21 = v20 + 1;
        if (v20 + 1 > 0x666666666666666) {
          abort();
        }
        unint64_t v22 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v16 - (void)v19) >> 3);
        if (2 * v22 > v21) {
          unint64_t v21 = 2 * v22;
        }
        if (v22 >= 0x333333333333333) {
          unint64_t v23 = 0x666666666666666;
        }
        else {
          unint64_t v23 = v21;
        }
        if (v23)
        {
          if (v23 > 0x666666666666666) {
            sub_1CB833614();
          }
          BOOL v24 = (char *)operator new(40 * v23);
        }
        else
        {
          BOOL v24 = 0;
        }
        uint64_t v25 = &v24[40 * v20];
        *(void *)uint64_t v25 = a1;
        *((void *)v25 + 1) = a2;
        *((void *)v25 + 2) = a3;
        *((void *)v25 + 3) = a4;
        v25[32] = a5;
        int v18 = v25 + 40;
        if (v17 != v19)
        {
          do
          {
            long long v26 = *(_OWORD *)(v17 - 40);
            long long v27 = *(_OWORD *)(v17 - 24);
            *((void *)v25 - 1) = *((void *)v17 - 1);
            *(_OWORD *)(v25 - 24) = v27;
            *(_OWORD *)(v25 - 40) = v26;
            v25 -= 40;
            v17 -= 40;
          }
          while (v17 != v19);
          unint64_t v17 = *a7;
        }
        *a7 = v25;
        a7[1] = v18;
        a7[2] = &v24[40 * v23];
        if (v17) {
          operator delete(v17);
        }
      }
      else
      {
        *(void *)unint64_t v17 = a1;
        *((void *)v17 + 1) = a2;
        *((void *)v17 + 2) = a3;
        *((void *)v17 + 3) = a4;
        int v18 = v17 + 40;
        v17[32] = a5;
      }
      a7[1] = v18;
    }
  }
}

uint64_t sub_1CBF97F84(uint64_t *a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v12 = 0;
  if (sub_1CD4670BC(*(void *)a2, *(_DWORD *)(a2 + 16), a3, a4, &v12))
  {
    uint64_t v6 = v12;
    uint64_t v7 = *(void *)a2;
    unsigned int v8 = *(_DWORD *)(a2 + 16);
  }
  else
  {
    uint64_t v7 = *(void *)a2;
    unsigned int v8 = *(_DWORD *)(a2 + 16);
    uint64_t v6 = *(void *)a2 + 40 * v8;
  }
  if (v6 == v7 + 40 * v8)
  {
    uint64_t result = 0;
    uint64_t v10 = 0;
    uint64_t v11 = 0;
  }
  else
  {
    uint64_t result = sub_1CD467DD0((uint64_t *)(v6 + 16));
    uint64_t v11 = *(void *)(v6 + 16) + 24 * *(unsigned int *)(v6 + 32);
  }
  *a1 = result;
  a1[1] = v10;
  a1[2] = v11;
  a1[3] = v11;
  return result;
}

uint64_t sub_1CBF98030(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    uint64_t v4 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    uint64_t v5 = (void *)(a1 + 32 * v4);
    uint64_t v6 = *v5;
    if (*v5 == a3)
    {
      uint64_t v7 = 1;
    }
    else
    {
      unint64_t v9 = 0;
      int v10 = 1;
      while (v6 != -4096)
      {
        if (v9) {
          BOOL v11 = 0;
        }
        else {
          BOOL v11 = v6 == -8192;
        }
        if (v11) {
          unint64_t v9 = v5;
        }
        int v12 = v4 + v10++;
        uint64_t v4 = v12 & (a2 - 1);
        uint64_t v5 = (void *)(a1 + 32 * v4);
        uint64_t v6 = *v5;
        uint64_t v7 = 1;
        if (*v5 == a3) {
          goto LABEL_5;
        }
      }
      uint64_t v7 = 0;
      if (v9) {
        uint64_t v5 = v9;
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t v7 = 0;
  }
LABEL_5:
  *a4 = v5;
  return v7;
}

void *sub_1CBF980C4(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(32 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v10 = *(unsigned int *)(a1 + 16);
    if (v10)
    {
      uint64_t v11 = 32 * v10;
      do
      {
        void *result = -4096;
        result += 4;
        v11 -= 32;
      }
      while (v11);
    }
    if (v3)
    {
      int v12 = 0;
      uint64_t v13 = 32 * v3;
      uint64_t v14 = v4;
      do
      {
        uint64_t v15 = *(void *)v14;
        if ((*(void *)v14 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          uint64_t v19 = 0;
          sub_1CBF98030(*(void *)a1, *(_DWORD *)(a1 + 16), v15, &v19);
          unint64_t v16 = v19;
          *uint64_t v19 = v15;
          v16[1] = 0;
          v16[2] = 0;
          v16[3] = 0;
          *(_OWORD *)(v16 + 1) = *(_OWORD *)(v14 + 8);
          v16[3] = *(void *)(v14 + 24);
          ++v12;
          *(void *)(v14 + 8) = 0;
          *(void *)(v14 + 16) = 0;
          *(void *)(v14 + 24) = 0;
          *(_DWORD *)(a1 + 8) = v12;
        }
        v14 += 32;
        v13 -= 32;
      }
      while (v13);
    }
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v17 = *(unsigned int *)(a1 + 16);
  if (v17)
  {
    uint64_t v18 = 32 * v17;
    do
    {
      void *result = -4096;
      result += 4;
      v18 -= 32;
    }
    while (v18);
  }
  return result;
}

void sub_1CBF98228(unint64_t a1, long long *a2, uint64_t a3, char a4)
{
long long *sub_1CBF98BD8(long long *result, unint64_t *a2, long long *a3)
{
  unint64_t v3 = *a2;
  if (*a2 < *(void *)result
    || ((uint64_t v4 = a2[1], v3 == *(void *)result) ? (v5 = v4 < *((void *)result + 1)) : (v5 = 0), v5))
  {
    if (*(void *)a3 < v3 || (*(void *)a3 == v3 ? (BOOL v9 = *((void *)a3 + 1) < (uint64_t)a2[1]) : (BOOL v9 = 0), v9))
    {
      long long v11 = *result;
      void *result = *a3;
    }
    else
    {
      long long v10 = *result;
      void *result = *(_OWORD *)a2;
      *(_OWORD *)a2 = v10;
      if (*(void *)a3 >= *a2 && (*(void *)a3 != *a2 || *((void *)a3 + 1) >= (int64_t)a2[1])) {
        return result;
      }
      long long v11 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *a3;
    }
    *a3 = v11;
    return result;
  }
  if (*(void *)a3 < v3 || (*(void *)a3 == v3 ? (BOOL v6 = *((void *)a3 + 1) < v4) : (BOOL v6 = 0), v6))
  {
    long long v7 = *(_OWORD *)a2;
    *(_OWORD *)a2 = *a3;
    *a3 = v7;
    if (*a2 < *(void *)result || *a2 == *(void *)result && (int64_t)a2[1] < *((void *)result + 1))
    {
      long long v8 = *result;
      void *result = *(_OWORD *)a2;
      *(_OWORD *)a2 = v8;
    }
  }
  return result;
}

BOOL sub_1CBF98CE4(uint64_t a1, long long *a2)
{
  uint64_t v4 = ((uint64_t)a2 - a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      BOOL v6 = a2 - 1;
      unint64_t v7 = *((void *)a2 - 2);
      if (v7 < *(void *)a1 || (v7 == *(void *)a1 ? (BOOL v8 = *((void *)a2 - 1) < *(void *)(a1 + 8)) : (BOOL v8 = 0), v8))
      {
        long long v9 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *BOOL v6 = v9;
      }
      return result;
    case 3:
      sub_1CBF98BD8((long long *)a1, (unint64_t *)(a1 + 16), a2 - 1);
      return 1;
    case 4:
      sub_1CBF98FCC(a1, (unint64_t *)(a1 + 16), a1 + 32, (uint64_t)(a2 - 1));
      return 1;
    case 5:
      uint64_t v21 = (void *)(a1 + 16);
      unint64_t v22 = (void *)(a1 + 32);
      BOOL v23 = (long long *)(a1 + 48);
      sub_1CBF98FCC(a1, (unint64_t *)(a1 + 16), a1 + 32, a1 + 48);
      unint64_t v24 = a2 - 1;
      unint64_t v25 = *((void *)a2 - 2);
      unint64_t v26 = *(void *)(a1 + 48);
      if (v25 >= v26 && (v25 != v26 || *((void *)a2 - 1) >= *(void *)(a1 + 56))) {
        return 1;
      }
      long long v28 = *v23;
      *BOOL v23 = *v24;
      *unint64_t v24 = v28;
      if (*(void *)v23 >= *v22 && (*(void *)v23 != *v22 || *(void *)(a1 + 56) >= *(void *)(a1 + 40))) {
        return 1;
      }
      long long v30 = *(_OWORD *)v22;
      *(_OWORD *)unint64_t v22 = *v23;
      *BOOL v23 = v30;
      if (*v22 >= *v21)
      {
        BOOL result = 1;
        if (*v22 != *v21 || *(void *)(a1 + 40) >= *(void *)(a1 + 24)) {
          return result;
        }
      }
      long long v31 = *(_OWORD *)v21;
      *(_OWORD *)uint64_t v21 = *(_OWORD *)v22;
      *(_OWORD *)unint64_t v22 = v31;
      unint64_t v32 = *(void *)(a1 + 16);
      if (v32 >= *(void *)a1)
      {
        BOOL result = 1;
        if (v32 != *(void *)a1 || *(void *)(a1 + 24) >= *(void *)(a1 + 8)) {
          return result;
        }
      }
      long long v33 = *(_OWORD *)a1;
      *(_OWORD *)a1 = *(_OWORD *)v21;
      *(_OWORD *)uint64_t v21 = v33;
      return 1;
    default:
      long long v10 = (long long *)(a1 + 32);
      sub_1CBF98BD8((long long *)a1, (unint64_t *)(a1 + 16), (long long *)(a1 + 32));
      long long v11 = (long long *)(a1 + 48);
      if ((long long *)(a1 + 48) == a2) {
        return 1;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      break;
  }
  while (1)
  {
    unint64_t v14 = *(void *)v11;
    if (*(void *)v11 < *(void *)v10) {
      break;
    }
    uint64_t v15 = *((void *)v11 + 1);
    if (v14 == *(void *)v10 && v15 < *((void *)v10 + 1)) {
      goto LABEL_18;
    }
LABEL_29:
    long long v10 = v11;
    v12 += 16;
    if (++v11 == a2) {
      return 1;
    }
  }
  uint64_t v15 = *((void *)v11 + 1);
LABEL_18:
  *long long v11 = *v10;
  unint64_t v17 = (void *)a1;
  if (v10 != (long long *)a1)
  {
    uint64_t v18 = v12;
    do
    {
      unint64_t v19 = *(void *)(a1 + v18 + 16);
      if (v14 >= v19 && (v14 != v19 || v15 >= *(void *)(a1 + v18 + 24)))
      {
        unint64_t v17 = (void *)(a1 + v18 + 32);
        goto LABEL_28;
      }
      *(_OWORD *)(a1 + v18 + 32) = *(_OWORD *)(a1 + v18 + 16);
      v18 -= 16;
    }
    while (v18 != -32);
    unint64_t v17 = (void *)a1;
  }
LABEL_28:
  void *v17 = v14;
  v17[1] = v15;
  if (++v13 != 8) {
    goto LABEL_29;
  }
  return v11 + 1 == a2;
}

__n128 sub_1CBF98FCC(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t a4)
{
  sub_1CBF98BD8((long long *)a1, a2, (long long *)a3);
  if (*(void *)a4 < *(void *)a3
    || (*(void *)a4 == *(void *)a3 ? (BOOL v9 = *(void *)(a4 + 8) < *(void *)(a3 + 8)) : (BOOL v9 = 0), v9))
  {
    __n128 result = *(__n128 *)a3;
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(__n128 *)a4 = result;
    if (*(void *)a3 < *a2 || (*(void *)a3 == *a2 ? (BOOL v10 = *(void *)(a3 + 8) < (uint64_t)a2[1]) : (BOOL v10 = 0), v10))
    {
      __n128 result = *(__n128 *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(__n128 *)a3 = result;
      if (*a2 < *(void *)a1 || *a2 == *(void *)a1 && (int64_t)a2[1] < *(void *)(a1 + 8))
      {
        __n128 result = *(__n128 *)a1;
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }
  return result;
}

uint64_t sub_1CBF990AC(uint64_t a1, uint64_t *a2)
{
  uint64_t v27 = 0;
  char v4 = sub_1CBF99320(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v27);
  uint64_t v5 = v27;
  if (v4) {
    return v5 + 8;
  }
  uint64_t v28 = v27;
  int v6 = *(_DWORD *)(a1 + 8);
  uint64_t v7 = *(unsigned int *)(a1 + 16);
  if (4 * v6 + 4 >= (3 * v7))
  {
    int v8 = 2 * v7;
    goto LABEL_9;
  }
  int v8 = *(_DWORD *)(a1 + 16);
  if ((int)v7 + ~v6 - *(_DWORD *)(a1 + 12) <= v7 >> 3)
  {
LABEL_9:
    uint64_t v11 = *(void *)a1;
    unint64_t v12 = (v8 - 1) | ((unint64_t)(v8 - 1) >> 1);
    unint64_t v13 = v12 | (v12 >> 2) | ((v12 | (v12 >> 2)) >> 4);
    int v14 = ((v13 | (v13 >> 8)) >> 16) | v13 | (v13 >> 8);
    if ((v14 + 1) > 0x40) {
      unsigned int v15 = v14 + 1;
    }
    else {
      unsigned int v15 = 64;
    }
    *(_DWORD *)(a1 + 16) = v15;
    unint64_t v16 = operator new(136 * v15, (std::align_val_t)8uLL);
    *(void *)a1 = v16;
    if (v11)
    {
      *(void *)(a1 + 8) = 0;
      uint64_t v17 = *(unsigned int *)(a1 + 16);
      if (v17)
      {
        uint64_t v18 = 136 * v17;
        do
        {
          *unint64_t v16 = -4096;
          v16 += 17;
          v18 -= 136;
        }
        while (v18);
      }
      if (v7)
      {
        unint64_t v19 = (void **)(v11 + 72);
        uint64_t v20 = 136 * v7;
        do
        {
          uint64_t v21 = (uint64_t)*(v19 - 9);
          if ((v21 | 0x1000) != 0xFFFFFFFFFFFFF000)
          {
            uint64_t v29 = 0;
            sub_1CBF99320(*(void *)a1, *(_DWORD *)(a1 + 16), v21, &v29);
            unint64_t v22 = v29;
            BOOL v23 = v29;
            *uint64_t v29 = v21;
            sub_1CBF993B8((uint64_t)(v23 + 1), (uint64_t)(v19 - 8));
            sub_1CBF993B8((uint64_t)(v22 + 9), (uint64_t)v19);
            ++*(_DWORD *)(a1 + 8);
            if (v19 + 2 != *v19) {
              free(*v19);
            }
            unint64_t v24 = (void **)*(v19 - 8);
            if (v19 - 6 != v24) {
              free(v24);
            }
          }
          v19 += 17;
          v20 -= 136;
        }
        while (v20);
      }
      MEMORY[0x1D25D9CD0](v11, 8);
      unint64_t v16 = *(void **)a1;
      LODWORD(v25) = *(_DWORD *)(a1 + 16);
    }
    else
    {
      *(void *)(a1 + 8) = 0;
      uint64_t v25 = *(unsigned int *)(a1 + 16);
      if (v25)
      {
        uint64_t v26 = 0;
        do
        {
          v16[v26] = -4096;
          v26 += 17;
        }
        while (17 * v25 != v26);
      }
    }
    sub_1CBF99320((uint64_t)v16, v25, *a2, &v28);
    int v6 = *(_DWORD *)(a1 + 8);
    uint64_t v5 = v28;
  }
  *(_DWORD *)(a1 + 8) = v6 + 1;
  if (*(void *)v5 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  uint64_t v9 = *a2;
  *(_OWORD *)(v5 + 72) = 0u;
  *(_OWORD *)(v5 + 40) = 0u;
  *(_OWORD *)(v5 + 56) = 0u;
  *(_OWORD *)(v5 + 104) = 0u;
  *(_OWORD *)(v5 + 88) = 0u;
  *(_OWORD *)(v5 + 120) = 0u;
  *(_OWORD *)(v5 + 24) = 0u;
  *(void *)uint64_t v5 = v9;
  *(void *)(v5 + 8) = v5 + 24;
  *(void *)(v5 + 16) = 0x400000000;
  *(void *)(v5 + 72) = v5 + 88;
  *(_DWORD *)(v5 + 84) = 4;
  return v5 + 8;
}

uint64_t sub_1CBF99320(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    int v6 = (void *)(a1 + 136 * v5);
    uint64_t v7 = *v6;
    if (*v6 == a3)
    {
      uint64_t v8 = 1;
    }
    else
    {
      BOOL v10 = 0;
      int v11 = 1;
      while (v7 != -4096)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v7 == -8192;
        }
        if (v12) {
          BOOL v10 = v6;
        }
        unsigned int v13 = v5 + v11++;
        unsigned int v5 = v13 & v4;
        int v6 = (void *)(a1 + 136 * (v13 & v4));
        uint64_t v7 = *v6;
        uint64_t v8 = 1;
        if (*v6 == a3) {
          goto LABEL_5;
        }
      }
      uint64_t v8 = 0;
      if (v10) {
        int v6 = v10;
      }
    }
  }
  else
  {
    int v6 = 0;
    uint64_t v8 = 0;
  }
LABEL_5:
  *a4 = v6;
  return v8;
}

uint64_t sub_1CBF993B8(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a1 + 16;
  *(void *)(a1 + 8) = 0x400000000;
  if (a1 != a2)
  {
    unsigned int v4 = *(_DWORD *)(a2 + 8);
    if (v4)
    {
      unsigned int v5 = *(const void **)a2;
      if (*(void *)a2 == a2 + 16)
      {
        if (v4 >= 5) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        memcpy((void *)(a1 + 16), v5, 12 * v4);
        *(_DWORD *)(a1 + 8) = v4;
      }
      else
      {
        *(void *)a1 = v5;
        int v6 = *(_DWORD *)(a2 + 12);
        *(_DWORD *)(a1 + 8) = v4;
        *(_DWORD *)(a1 + 12) = v6;
        *(void *)a2 = a2 + 16;
        *(_DWORD *)(a2 + 12) = 0;
      }
      *(_DWORD *)(a2 + 8) = 0;
    }
  }
  return a1;
}

BOOL sub_1CBF99480(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *a2;
  if (*a1 < *a2) {
    return 1;
  }
  if (v2 == v3 && HIDWORD(v2) < HIDWORD(v3)) {
    return 1;
  }
  uint64_t v5 = 0;
  BOOL v7 = v2 == v3 && HIDWORD(v3) < HIDWORD(v2);
  if (v3 >= v2 && !v7)
  {
    uint64_t v8 = a1[1];
    uint64_t v9 = a2[1];
    if (v8 < v9 || v8 == v9 && HIDWORD(v8) < HIDWORD(v9)) {
      return 1;
    }
    uint64_t v5 = 0;
    BOOL v12 = v8 == v9 && HIDWORD(v9) < HIDWORD(v8);
    if (v9 >= v8 && !v12) {
      return a1[2] < a2[2];
    }
  }
  return v5;
}

void sub_1CBF99524(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        uint64_t v4 = sub_1CD468254(v4 - 56);
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1CBF995A8(unsigned int *a1)
{
  uint64_t v1 = a1[4];
  if (v1)
  {
    uint64_t v2 = 32 * v1;
    uint64_t v3 = (void *)(*(void *)a1 + 16);
    do
    {
      if ((*(v3 - 2) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t v4 = (void *)*(v3 - 1);
        if (v4)
        {
          *uint64_t v3 = v4;
          operator delete(v4);
        }
      }
      v3 += 4;
      v2 -= 32;
    }
    while (v2);
  }
}

BOOL sub_1CBF99710(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v12 = a2;
  uint64_t v13 = a3;
  uint64_t v5 = sub_1CD468DB0(a1, &v12);
  uint64_t v6 = v5[1];
  BOOL v7 = v5 + 1;
  unint64_t v8 = v13;
  unint64_t v9 = 0x6DB6DB6DB6DB6DB7 * ((v5[2] - v6) >> 3);
  unsigned int v10 = v13;
  if (v9 <= v13)
  {
    sub_1CD469070(v5 + 1, (v13 + 1));
    unsigned int v10 = v13;
    uint64_t v6 = *v7;
  }
  BOOL result = v9 <= v8;
  *(void *)(v6 + 56 * v10 + 48) |= a4;
  return result;
}

__n128 sub_1CBF9988C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a3 != a5)
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = a7 + v7;
      uint64_t v9 = a3 + v7;
      *(void *)(v8 - 56) = 0;
      *(void *)(v8 - 48) = 0;
      *(void *)(v8 - 40) = 0;
      *(_OWORD *)(v8 - 56) = *(_OWORD *)(a3 + v7 - 56);
      *(void *)(v8 - 40) = *(void *)(a3 + v7 - 40);
      *(void *)(v9 - 56) = 0;
      *(void *)(v9 - 48) = 0;
      *(void *)(v9 - 40) = 0;
      *(void *)(v8 - 32) = 0;
      *(void *)(v8 - 24) = 0;
      *(void *)(v8 - 16) = 0;
      __n128 result = *(__n128 *)(a3 + v7 - 32);
      *(__n128 *)(v8 - 32) = result;
      *(void *)(v8 - 16) = *(void *)(a3 + v7 - 16);
      *(void *)(v9 - 32) = 0;
      *(void *)(v9 - 24) = 0;
      *(void *)(v9 - 16) = 0;
      *(void *)(v8 - 8) = *(void *)(a3 + v7 - 8);
      v7 -= 56;
    }
    while (a3 + v7 != a5);
  }
  return result;
}

char *sub_1CBF99908(void **a1, uint64_t a2)
{
  uint64_t v3 = (char *)*a1;
  uint64_t v2 = (char *)a1[1];
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((v2 - (unsigned char *)*a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * (((unsigned char *)a1[2] - v3) >> 3) > v5) {
    unint64_t v5 = 0x5555555555555556 * (((unsigned char *)a1[2] - v3) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[2] - v3) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v5;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      sub_1CB833614();
    }
    uint64_t v9 = (char *)operator new(24 * v8);
  }
  else
  {
    uint64_t v9 = 0;
  }
  unsigned int v10 = &v9[24 * v4];
  *(_OWORD *)unsigned int v10 = *(_OWORD *)a2;
  *((void *)v10 + 2) = *(void *)(a2 + 16);
  int v11 = v10 + 24;
  if (v2 != v3)
  {
    do
    {
      long long v12 = *(_OWORD *)(v2 - 24);
      *((void *)v10 - 1) = *((void *)v2 - 1);
      *(_OWORD *)(v10 - 24) = v12;
      v10 -= 24;
      v2 -= 24;
    }
    while (v2 != v3);
    uint64_t v2 = (char *)*a1;
  }
  *a1 = v10;
  a1[1] = v11;
  a1[2] = &v9[24 * v8];
  if (v2) {
    operator delete(v2);
  }
  return v11;
}

uint64_t sub_1CBF99A24(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    if (!*(unsigned char *)(result + 16) && *(void *)(result + 24) == a2)
    {
      unsigned int v3 = *(_DWORD *)(a3 + 8);
      if (v3 >= *(_DWORD *)(a3 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)a3 + 8 * v3) = result;
      ++*(_DWORD *)(a3 + 8);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_1CBF99AB0(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 64);
  if (v4 && (((*(unsigned __int8 *)(v4 + a2 / 8 + 12) >> (a2 & 7)) & 1) != 0 || (*(unsigned char *)(v4 + 17) & 0x10) != 0)) {
    return 1;
  }
  if (sub_1CB8F87D0(a1, a2)) {
    return 0;
  }
  if (llvm::CallBase::hasFnAttrOnCalledFunction(a1, a2)) {
    return 1;
  }

  return llvm::CallBase::hasFnAttrOnCalledFunction(a1, 44);
}

void *sub_1CBF99B58(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = operator new(0x30uLL);
  *uint64_t v6 = a1;
  v6[2] = 2;
  v6[3] = 0;
  v6[4] = a2;
  if (a2 != -8192 && a2 != -4096 && a2) {
    llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)(v6 + 2));
  }
  v6[1] = &unk_1F26016B8;
  v6[5] = a3;
  return v6;
}

void sub_1CBF99BE8()
{
}

void *sub_1CBF99BFC(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1F26016E0;
  result[1] = v3;
  return result;
}

uint64_t sub_1CBF99C44(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F26016E0;
  a2[1] = v2;
  return result;
}

void sub_1CBF99C70()
{
}

void sub_1CBF99CA0()
{
}

void *sub_1CBF99CB4(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1F2601728;
  result[1] = v3;
  return result;
}

uint64_t sub_1CBF99CFC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F2601728;
  a2[1] = v2;
  return result;
}

void sub_1CBF99D28(uint64_t a1, uint64_t a2)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(uint64_t **)(*(void *)(a1 + 8) + 8);
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  if (v4 == v5)
  {
LABEL_4:
    uint64_t v6 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v4 != &llvm::TargetLibraryInfoWrapperPass::ID)
    {
      v4 += 16;
      if (v4 == v5) {
        goto LABEL_4;
      }
    }
    uint64_t v6 = *(void *)(v4 + 8);
  }
  uint64_t v7 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v6 + 96))(v6, &llvm::TargetLibraryInfoWrapperPass::ID);
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  int v13 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  int v16 = 0;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  int v19 = 0;
  uint64_t v8 = v7 + 32;
  if (!*(unsigned char *)(v7 + 232))
  {
    uint64_t v9 = *(void *)(a2 + 40) + 216;
    __int16 v21 = 260;
    v20[0] = v9;
    llvm::Triple::Triple((llvm::Triple *)__p, (const llvm::Twine *)v20);
    uint64_t v31 = 0;
    uint64_t v32 = 0;
    int v33 = 0;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    *(void *)&long long v10 = -1;
    *((void *)&v10 + 1) = -1;
    *(_OWORD *)__src = v10;
    long long v25 = v10;
    long long v26 = v10;
    long long v27 = v10;
    long long v28 = v10;
    long long v29 = v10;
    *(_OWORD *)long long v30 = v10;
    *(void *)&v30[13] = -1;
    sub_1CC153974((uint64_t)__src, (int *)__p);
    sub_1CD4D04B8(v8, (uint64_t)__src);
    sub_1CD4CFA4C((uint64_t *)__src);
    if (v23 < 0) {
      operator delete(__p[0]);
    }
  }
  sub_1CC1569E8(__src, v8);
}

uint64_t llvm::CFLSteensAAResult::CFLSteensAAResult(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  uint64_t v3 = a1 + 8;
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 32) = v3;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), v3);
    }
    else
    {
      *(void *)(a1 + 32) = v4;
      *(void *)(a2 + 24) = 0;
    }
  }
  else
  {
    *(void *)(a1 + 32) = 0;
  }
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  return a1;
}

{
  uint64_t v3;
  uint64_t v4;

  *(void *)a1 = 0;
  uint64_t v3 = a1 + 8;
  uint64_t v4 = *(void *)(a2 + 32);
  if (v4)
  {
    if (v4 == a2 + 8)
    {
      *(void *)(a1 + 32) = v3;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 32) + 24))(*(void *)(a2 + 32), v3);
    }
    else
    {
      *(void *)(a1 + 32) = v4;
      *(void *)(a2 + 32) = 0;
    }
  }
  else
  {
    *(void *)(a1 + 32) = 0;
  }
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  return a1;
}

uint64_t *llvm::CFLSteensAAResult::FunctionInfo::FunctionInfo(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_1CD46AEB4((uint64_t)a1, a4);
  v7[6] = v7 + 8;
  v7[7] = 0x800000000;
  v7[32] = v7 + 34;
  v7[33] = 0x800000000;
  if (*(void *)(a2 + 96) > 0x32uLL) {
    return a1;
  }
  v19[0] = 0;
  v19[1] = 0;
  int v20 = 0;
  v18[0] = v19;
  v18[1] = a1;
  uint64_t v8 = *(unsigned int *)(a3 + 8);
  if (v8)
  {
    uint64_t v9 = *(uint64_t **)a3;
    uint64_t v10 = 8 * v8;
    do
    {
      unint64_t v11 = sub_1CBF9A2D8((uint64_t)a1, *v9, 0);
      if (HIDWORD(v11)) {
        sub_1CBF9A360(v18, 0, v11);
      }
      ++v9;
      v10 -= 8;
    }
    while (v10);
  }
  if (*(_WORD *)(a2 + 18))
  {
    llvm::Function::BuildLazyArguments((llvm::Function *)a2);
    uint64_t v12 = *(void *)(a2 + 88);
    if (*(_WORD *)(a2 + 18))
    {
      llvm::Function::BuildLazyArguments((llvm::Function *)a2);
      uint64_t v13 = *(void *)(a2 + 88);
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v12 = *(void *)(a2 + 88);
  }
  uint64_t v13 = v12;
LABEL_10:
  uint64_t v14 = v13 + 40 * *(void *)(a2 + 96);
  if (v12 != v14)
  {
    unsigned int v15 = 1;
    do
    {
      if (*(unsigned char *)(*(void *)v12 + 8) == 15)
      {
        unint64_t v16 = sub_1CBF9A2D8((uint64_t)a1, v12, 0);
        if (HIDWORD(v16)) {
          sub_1CBF9A360(v18, v15, v16);
        }
      }
      v12 += 40;
      ++v15;
    }
    while (v12 != v14);
  }
  MEMORY[0x1D25D9CD0](v19[0], 4);
  return a1;
}

uint64_t sub_1CBF9A2D8(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v8 = 0;
  if (sub_1CD4674DC(*(void *)a1, *(_DWORD *)(a1 + 16), a2, a3, &v8))
  {
    uint64_t v4 = v8;
    uint64_t v5 = *(void *)a1;
    unsigned int v6 = *(_DWORD *)(a1 + 16);
  }
  else
  {
    uint64_t v5 = *(void *)a1;
    unsigned int v6 = *(_DWORD *)(a1 + 16);
    uint64_t v4 = *(void *)a1 + 24 * v6;
  }
  if (v4 == v5 + 24 * v6) {
    return 0;
  }
  else {
    return *(unsigned int *)(v4 + 16) | 0x100000000;
  }
}

__n128 sub_1CBF9A360(uint64_t **a1, unsigned int a2, unsigned int a3)
{
  uint64_t v5 = 0;
  unsigned int v6 = a1[1];
  uint64_t v7 = a2;
  while (1)
  {
    uint64_t v8 = *a1;
    uint64_t v9 = **a1;
    unsigned int v10 = *((_DWORD *)*a1 + 4);
    if (v10)
    {
      unsigned int v11 = (v10 - 1) & (37 * a3);
      uint64_t v12 = (int *)(v9 + 12 * v11);
      int v13 = *v12;
      if (a3 == *v12) {
        goto LABEL_9;
      }
      int v14 = 1;
      while (v13 != -1)
      {
        unsigned int v15 = v11 + v14++;
        unsigned int v11 = v15 & (v10 - 1);
        uint64_t v12 = (int *)(v9 + 12 * v11);
        int v13 = *v12;
        if (a3 == *v12) {
          goto LABEL_9;
        }
      }
    }
    uint64_t v12 = (int *)(v9 + 12 * v10);
LABEL_9:
    if (v12 != (int *)(v9 + 12 * v10)) {
      break;
    }
    uint64_t v16 = v6[3];
    LODWORD(v26) = a3;
    *(void *)((char *)&v26 + 4) = v7 | (v5 << 32);
    uint64_t v24 = v26;
    int v25 = v5;
    sub_1CD46AFB4((uint64_t)&v26, (uint64_t)v8, (int *)&v24, (uint64_t *)((char *)&v24 + 4));
    uint64_t v18 = *(void *)(v16 + 16 * a3 + 8) & 7;
    if (v18)
    {
      unint64_t v19 = *((unsigned int *)v6 + 66);
      if (v19 >= *((unsigned int *)v6 + 67)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      int v20 = (uint64_t *)(v6[32] + 16 * v19);
      *int v20 = v7 | (v5 << 32);
      v20[1] = v18;
      ++*((_DWORD *)v6 + 66);
    }
    a3 = *(_DWORD *)(v16 + 16 * a3 + 4);
    if (a3 == -1) {
      uint64_t v5 = v5;
    }
    else {
      uint64_t v5 = (v5 + 1);
    }
    if (a3 == -1) {
      return result;
    }
  }
  uint64_t v21 = *(void *)(v12 + 1);
  if ((v7 | (v5 << 32)) != v21)
  {
    *(void *)&long long v26 = v7 | (v5 << 32);
    *((void *)&v26 + 1) = v21;
    uint64_t v27 = 0x7FFFFFFFFFFFFFFFLL;
    unint64_t v22 = (__n128 *)sub_1CD41C4F0((uint64_t)(v6 + 6), (unint64_t)&v26, 1);
    char v23 = (__n128 *)(v6[6] + 24 * *((unsigned int *)v6 + 14));
    __n128 result = *v22;
    v23[1].n128_u64[0] = v22[1].n128_u64[0];
    *char v23 = result;
    ++*((_DWORD *)v6 + 14);
  }
  return result;
}

int32x2_t llvm::CFLSteensAAResult::evict(llvm::CFLSteensAAResult *this, llvm::Function *a2)
{
  return sub_1CD46AAF0((uint64_t)this + 40, (uint64_t)a2);
}

uint64_t llvm::CFLSteensAAResult::ensureCached(llvm::CFLSteensAAResult *this, llvm::Function *a2)
{
  uint64_t v8 = 0;
  int v4 = sub_1CD469D10(*((void *)this + 5), *((_DWORD *)this + 14), (uint64_t)a2, &v8);
  uint64_t v5 = v8;
  if (!v4) {
    uint64_t v5 = *((void *)this + 5) + 416 * *((unsigned int *)this + 14);
  }
  if (*((void *)this + 5) + 416 * *((unsigned int *)this + 14) == v5)
  {
    llvm::CFLSteensAAResult::scan(this, a2);
    uint64_t v8 = 0;
    int v7 = sub_1CD469D10(*((void *)this + 5), *((_DWORD *)this + 14), (uint64_t)a2, &v8);
    uint64_t v5 = v8;
    if (!v7) {
      uint64_t v5 = *((void *)this + 5) + 416 * *((unsigned int *)this + 14);
    }
  }
  return v5 + 8;
}

uint64_t llvm::CFLSteensAAResult::getAliasSummary(llvm::CFLSteensAAResult *this, llvm::Function *a2)
{
  uint64_t v2 = llvm::CFLSteensAAResult::ensureCached(this, a2);
  if (*(unsigned char *)(v2 + 400)) {
    return v2 + 48;
  }
  else {
    return 0;
  }
}

BOOL llvm::CFLSteensAAResult::query(llvm::CFLSteensAAResult *this, const llvm::MemoryLocation *a2, const llvm::MemoryLocation *a3)
{
  uint64_t v3 = *(void *)a2;
  if (*(unsigned char *)(**(void **)a2 + 8) != 15) {
    return 0;
  }
  uint64_t v4 = *(void *)a3;
  if (*(unsigned char *)(**(void **)a3 + 8) != 15) {
    return 0;
  }
  unsigned int v5 = *(unsigned __int8 *)(v3 + 16);
  if (v5 >= 0x1C)
  {
    unsigned int v6 = (uint64_t *)(*(void *)(v3 + 40) + 56);
    goto LABEL_8;
  }
  if (v5 == 21)
  {
    unsigned int v6 = (uint64_t *)(v3 + 24);
LABEL_8:
    uint64_t v8 = *v6;
    goto LABEL_10;
  }
  uint64_t v8 = 0;
LABEL_10:
  unsigned int v9 = *(unsigned __int8 *)(v4 + 16);
  if (v9 >= 0x1C)
  {
    unsigned int v10 = (uint64_t *)(*(void *)(v4 + 40) + 56);
  }
  else
  {
    if (v9 != 21)
    {
      uint64_t v11 = 0;
      goto LABEL_16;
    }
    unsigned int v10 = (uint64_t *)(v4 + 24);
  }
  uint64_t v11 = *v10;
LABEL_16:
  if (!(v8 | v11)) {
    return 1;
  }
  uint64_t v12 = (llvm::Function *)(v8 ? v8 : v11);
  uint64_t v13 = llvm::CFLSteensAAResult::ensureCached(this, v12);
  unint64_t v14 = sub_1CBF9A2D8(v13, v3, 0);
  if (!HIDWORD(v14)) {
    return 1;
  }
  unsigned int v15 = v14;
  unint64_t v16 = sub_1CBF9A2D8(v13, v4, 0);
  if (!HIDWORD(v16)) {
    return 1;
  }
  unsigned int v17 = v16;
  if (v15 == v16) {
    return 1;
  }
  BOOL result = 0;
  uint64_t v18 = *(void *)(v13 + 24);
  uint64_t v19 = *(void *)(v18 + 16 * v15 + 8);
  if (v19)
  {
    uint64_t v20 = *(void *)(v18 + 16 * v17 + 8);
    if (v20)
    {
      if (((v19 | v20) & 0xA) != 0) {
        return 1;
      }
      return (v20 & 0xFFFFFFF4) != 0 && (*(void *)(v18 + 16 * v15 + 8) & 0xFFFFFFF4) != 0;
    }
  }
  return result;
}

void sub_1CBF9A76C()
{
}

void sub_1CBF9A810(void *a1, llvm::Function *this)
{
  uint64_t v4 = *((void *)this + 5) + 272;
  uint64_t v5 = a1[1];
  v20[0] = *a1;
  v20[1] = v4;
  v20[2] = v5;
  v20[3] = a1 + 2;
  uint64_t v20[4] = a1 + 5;
  unsigned int v6 = (char *)this + 72;
  for (uint64_t i = *((void *)this + 10); (char *)i != v6; uint64_t i = *(void *)(i + 8))
  {
    uint64_t v8 = i - 24;
    if (!i) {
      uint64_t v8 = 0;
    }
    uint64_t v9 = v8 + 40;
    for (uint64_t j = *(void *)(v8 + 48); j != v9; uint64_t j = *(void *)(j + 8))
    {
      if (j) {
        uint64_t v11 = (unsigned __int8 *)(j - 24);
      }
      else {
        uint64_t v11 = 0;
      }
      int v12 = v11[16];
      if ((v12 - 81) >= 2)
      {
        BOOL v15 = v12 == 33 || (v12 - 40) < 0xFFFFFFF5 || v12 == 29;
        if (v12 != 63 && v15) {
          sub_1CD46B468((llvm::cflaa *)v20, (llvm::cflaa *)v11);
        }
      }
    }
  }
  if (*((_WORD *)this + 9))
  {
    llvm::Function::BuildLazyArguments(this);
    unsigned int v17 = (llvm::cflaa *)*((void *)this + 11);
    if (*((_WORD *)this + 9))
    {
      llvm::Function::BuildLazyArguments(this);
      uint64_t v18 = (llvm::cflaa *)*((void *)this + 11);
      goto LABEL_30;
    }
  }
  else
  {
    unsigned int v17 = (llvm::cflaa *)*((void *)this + 11);
  }
  uint64_t v18 = v17;
LABEL_30:
  uint64_t v19 = (llvm::cflaa *)((char *)v18 + 40 * *((void *)this + 12));
  while (v17 != v19)
  {
    sub_1CD468790((BOOL)a1, v17);
    unsigned int v17 = (llvm::cflaa *)((char *)v17 + 40);
  }
}

BOOL sub_1CBF9AB30(uint64_t a1, long long *a2, unsigned int a3)
{
  long long v28 = *a2;
  unsigned int v29 = a3;
  sub_1CD46C2FC((uint64_t)&v30, a1, (uint64_t)&v28, &v29);
  int v5 = v31;
  if (!v31)
  {
    uint64_t v6 = *(unsigned int *)(v30 + 16);
    uint64_t v7 = *(void *)(a1 + 24);
    uint64_t v8 = v7 + 32 * v6;
    unsigned int v11 = *(_DWORD *)(v8 + 24);
    uint64_t v9 = (_DWORD *)(v8 + 24);
    uint64_t v10 = v11;
    if (v11 != -1)
    {
      uint64_t v12 = v10;
      do
      {
        uint64_t v13 = v12;
        uint64_t v12 = *(unsigned int *)(v7 + 32 * v12 + 24);
      }
      while (v12 != -1);
      int v14 = *(_DWORD *)(v7 + 32 * v13);
      do
      {
        uint64_t v6 = v10;
        *uint64_t v9 = v14;
        uint64_t v15 = v7 + 32 * v10;
        unsigned int v16 = *(_DWORD *)(v15 + 24);
        uint64_t v9 = (_DWORD *)(v15 + 24);
        uint64_t v10 = v16;
      }
      while (v16 != -1);
    }
    uint64_t v17 = a3;
    uint64_t v18 = v7 + 32 * a3;
    unsigned int v21 = *(_DWORD *)(v18 + 24);
    uint64_t v19 = (_DWORD *)(v18 + 24);
    uint64_t v20 = v21;
    if (v21 != -1)
    {
      uint64_t v22 = v20;
      do
      {
        uint64_t v23 = v22;
        uint64_t v22 = *(unsigned int *)(v7 + 32 * v22 + 24);
      }
      while (v22 != -1);
      int v24 = *(_DWORD *)(v7 + 32 * v23);
      do
      {
        uint64_t v17 = v20;
        *uint64_t v19 = v24;
        uint64_t v25 = v7 + 32 * v20;
        unsigned int v26 = *(_DWORD *)(v25 + 24);
        uint64_t v19 = (_DWORD *)(v25 + 24);
        uint64_t v20 = v26;
      }
      while (v26 != -1);
    }
    if (v6 != v17) {
      sub_1CD46C284(a1, *(_DWORD *)(v7 + 32 * v6), *(_DWORD *)(v7 + 32 * v17));
    }
  }
  return v5 != 0;
}

_OWORD *sub_1CBF9AC5C(void **a1, _OWORD *a2)
{
  uint64_t v3 = (char *)*a1;
  uint64_t v2 = (char *)a1[1];
  uint64_t v4 = (v2 - (unsigned char *)*a1) >> 5;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 59) {
    abort();
  }
  uint64_t v8 = (unsigned char *)a1[2] - v3;
  if (v8 >> 4 > v5) {
    unint64_t v5 = v8 >> 4;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v9 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  if (v9)
  {
    if (v9 >> 59) {
      sub_1CB833614();
    }
    uint64_t v10 = (char *)operator new(32 * v9);
  }
  else
  {
    uint64_t v10 = 0;
  }
  unsigned int v11 = &v10[32 * v4];
  long long v12 = a2[1];
  *(_OWORD *)unsigned int v11 = *a2;
  *((_OWORD *)v11 + 1) = v12;
  uint64_t v13 = v11 + 32;
  if (v2 != v3)
  {
    do
    {
      long long v14 = *((_OWORD *)v2 - 1);
      *((_OWORD *)v11 - 2) = *((_OWORD *)v2 - 2);
      *((_OWORD *)v11 - 1) = v14;
      v11 -= 32;
      v2 -= 32;
    }
    while (v2 != v3);
    uint64_t v2 = (char *)*a1;
  }
  *a1 = v11;
  a1[1] = v13;
  a1[2] = &v10[32 * v9];
  if (v2) {
    operator delete(v2);
  }
  return v13;
}

uint64_t sub_1CBF9AD40(uint64_t a1, unsigned int **a2)
{
  uint64_t v4 = 0;
  v96[0] = 0;
  v96[1] = 0;
  unsigned int v97 = 0;
  unint64_t v5 = *(unsigned int **)(a1 + 24);
  uint64_t v6 = *(unsigned int **)(a1 + 32);
  if (v5 != v6)
  {
    while (v5[6] != -1)
    {
LABEL_36:
      v5 += 8;
      if (v5 == v6)
      {
        uint64_t v4 = v96[0];
        goto LABEL_39;
      }
    }
    uint64_t v7 = a2[1];
    unsigned int v8 = *v5;
    unint64_t v95 = *v5 | ((unint64_t)((unint64_t)((char *)v7 - (char *)*a2) >> 4) << 32);
    if (v97)
    {
      unsigned int v9 = (v97 - 1) & (37 * v8);
      uint64_t v10 = (_DWORD *)(v96[0] + 8 * v9);
      int v11 = *v10;
      if (v8 == *v10)
      {
LABEL_18:
        uint64_t v18 = v5 + 2;
        unint64_t v19 = (unint64_t)a2[2];
        if ((unint64_t)v7 >= v19)
        {
          unsigned int v21 = *a2;
          uint64_t v22 = ((char *)v7 - (char *)*a2) >> 4;
          unint64_t v23 = v22 + 1;
          if ((unint64_t)(v22 + 1) >> 60) {
            abort();
          }
          uint64_t v24 = v19 - (void)v21;
          if (v24 >> 3 > v23) {
            unint64_t v23 = v24 >> 3;
          }
          if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v25 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v25 = v23;
          }
          if (v25)
          {
            if (v25 >> 60) {
              sub_1CB833614();
            }
            unsigned int v26 = (char *)operator new(16 * v25);
          }
          else
          {
            unsigned int v26 = 0;
          }
          uint64_t v27 = &v26[16 * v22];
          *(_OWORD *)uint64_t v27 = *v18;
          long long v28 = (unsigned int *)v27;
          if (v7 != v21)
          {
            do
            {
              *((_OWORD *)v28 - 1) = *((_OWORD *)v7 - 1);
              v28 -= 4;
              v7 -= 4;
            }
            while (v7 != v21);
            uint64_t v7 = *a2;
          }
          uint64_t v20 = (unsigned int *)(v27 + 16);
          *a2 = v28;
          a2[1] = (unsigned int *)(v27 + 16);
          a2[2] = (unsigned int *)&v26[16 * v25];
          if (v7) {
            operator delete(v7);
          }
        }
        else
        {
          *(_OWORD *)uint64_t v7 = *v18;
          uint64_t v20 = v7 + 4;
        }
        a2[1] = v20;
        goto LABEL_36;
      }
      long long v12 = 0;
      int v13 = 1;
      while (v11 != -1)
      {
        if (v12) {
          BOOL v14 = 0;
        }
        else {
          BOOL v14 = v11 == -2;
        }
        if (v14) {
          long long v12 = v10;
        }
        unsigned int v15 = v9 + v13++;
        unsigned int v9 = v15 & (v97 - 1);
        uint64_t v10 = (_DWORD *)(v96[0] + 8 * v9);
        int v11 = *v10;
        if (v8 == *v10) {
          goto LABEL_18;
        }
      }
      if (v12) {
        unsigned int v16 = v12;
      }
      else {
        unsigned int v16 = v10;
      }
    }
    else
    {
      unsigned int v16 = 0;
    }
    uint64_t v17 = sub_1CB83889C((uint64_t)v96, (uint64_t)&v95, &v95, v16);
    *(void *)uint64_t v17 = v95;
    uint64_t v7 = a2[1];
    goto LABEL_18;
  }
LABEL_39:
  unsigned int v29 = *a2;
  uint64_t v30 = a2[1];
  if (*a2 != v30)
  {
    unsigned int v58 = v97;
    unsigned int v59 = v97 - 1;
    uint64_t v60 = (int *)(v4 + 8 * v97);
    do
    {
      uint64_t v61 = *v29;
      if (v61 != -1)
      {
        uint64_t v62 = *(void *)(a1 + 24);
        uint64_t v63 = v62 + 32 * v61;
        unsigned int v66 = *(_DWORD *)(v63 + 24);
        uint64_t v64 = (_DWORD *)(v63 + 24);
        uint64_t v65 = v66;
        if (v66 != -1)
        {
          uint64_t v67 = v65;
          do
          {
            uint64_t v68 = v67;
            uint64_t v67 = *(unsigned int *)(v62 + 32 * v67 + 24);
          }
          while (v67 != -1);
          int v69 = *(_DWORD *)(v62 + 32 * v68);
          do
          {
            uint64_t v61 = v65;
            _DWORD *v64 = v69;
            uint64_t v70 = v62 + 32 * v65;
            unsigned int v71 = *(_DWORD *)(v70 + 24);
            uint64_t v64 = (_DWORD *)(v70 + 24);
            uint64_t v65 = v71;
          }
          while (v71 != -1);
        }
        long long v72 = v60;
        if (v58)
        {
          int v73 = *(_DWORD *)(v62 + 32 * v61);
          LODWORD(v74) = (37 * v73) & v59;
          long long v72 = (int *)(v4 + 8 * v74);
          int v75 = *v72;
          if (v73 != *v72)
          {
            int v91 = 1;
            while (v75 != -1)
            {
              int v92 = v74 + v91++;
              uint64_t v74 = v92 & v59;
              int v75 = *(_DWORD *)(v4 + 8 * v74);
              if (v73 == v75)
              {
                long long v72 = (int *)(v4 + 8 * v74);
                goto LABEL_78;
              }
            }
            long long v72 = v60;
          }
        }
LABEL_78:
        *unsigned int v29 = v72[1];
      }
      uint64_t v76 = v29[1];
      if (v76 != -1)
      {
        uint64_t v77 = *(void *)(a1 + 24);
        uint64_t v78 = v77 + 32 * v76;
        unsigned int v81 = *(_DWORD *)(v78 + 24);
        int v79 = (_DWORD *)(v78 + 24);
        uint64_t v80 = v81;
        if (v81 != -1)
        {
          uint64_t v82 = v80;
          do
          {
            uint64_t v83 = v82;
            uint64_t v82 = *(unsigned int *)(v77 + 32 * v82 + 24);
          }
          while (v82 != -1);
          int v84 = *(_DWORD *)(v77 + 32 * v83);
          do
          {
            uint64_t v76 = v80;
            _DWORD *v79 = v84;
            uint64_t v85 = v77 + 32 * v80;
            unsigned int v86 = *(_DWORD *)(v85 + 24);
            int v79 = (_DWORD *)(v85 + 24);
            uint64_t v80 = v86;
          }
          while (v86 != -1);
        }
        unint64_t v87 = v60;
        if (v58)
        {
          int v88 = *(_DWORD *)(v77 + 32 * v76);
          LODWORD(v89) = (37 * v88) & v59;
          unint64_t v87 = (int *)(v4 + 8 * v89);
          int v90 = *v87;
          if (v88 != *v87)
          {
            int v93 = 1;
            while (v90 != -1)
            {
              int v94 = v89 + v93++;
              uint64_t v89 = v94 & v59;
              int v90 = *(_DWORD *)(v4 + 8 * v89);
              if (v88 == v90)
              {
                unint64_t v87 = (int *)(v4 + 8 * v89);
                goto LABEL_87;
              }
            }
            unint64_t v87 = v60;
          }
        }
LABEL_87:
        v29[1] = v87[1];
      }
      v29 += 4;
    }
    while (v29 != v30);
  }
  uint64_t v31 = sub_1CD467DD0((uint64_t *)a1);
  uint64_t v33 = *(void *)a1 + 24 * *(unsigned int *)(a1 + 16);
  if (v33 != v31)
  {
    uint64_t v34 = *(void *)(a1 + 24);
    unsigned int v35 = v97;
    unsigned int v36 = v97 - 1;
    uint64_t v37 = (int *)(v4 + 8 * v97);
    do
    {
      uint64_t v38 = *(unsigned int *)(v31 + 16);
      uint64_t v39 = v34 + 32 * v38;
      unsigned int v42 = *(_DWORD *)(v39 + 24);
      uint64_t v40 = (_DWORD *)(v39 + 24);
      uint64_t v41 = v42;
      if (v42 != -1)
      {
        uint64_t v43 = v41;
        do
        {
          uint64_t v44 = v43;
          uint64_t v43 = *(unsigned int *)(v34 + 32 * v43 + 24);
        }
        while (v43 != -1);
        int v45 = *(_DWORD *)(v34 + 32 * v44);
        do
        {
          uint64_t v38 = v41;
          _DWORD *v40 = v45;
          uint64_t v46 = v34 + 32 * v41;
          unsigned int v47 = *(_DWORD *)(v46 + 24);
          uint64_t v40 = (_DWORD *)(v46 + 24);
          uint64_t v41 = v47;
        }
        while (v47 != -1);
      }
      unint64_t v48 = v37;
      if (v35)
      {
        int v49 = *(_DWORD *)(v34 + 32 * v38);
        LODWORD(v50) = (37 * v49) & v36;
        unint64_t v48 = (int *)(v4 + 8 * v50);
        int v51 = *v48;
        if (v49 != *v48)
        {
          int v55 = 1;
          while (v51 != -1)
          {
            int v56 = v50 + v55++;
            uint64_t v50 = v56 & v36;
            int v51 = *(_DWORD *)(v4 + 8 * v50);
            if (v49 == v51)
            {
              unint64_t v48 = (int *)(v4 + 8 * v50);
              goto LABEL_49;
            }
          }
          unint64_t v48 = v37;
        }
      }
LABEL_49:
      *(_DWORD *)(v31 + 16) = v48[1];
      while (1)
      {
        v31 += 24;
        if (v31 == v32) {
          break;
        }
        int v52 = *(_DWORD *)(v31 + 8);
        if ((*(void *)v31 != -4096 || v52 != -1) && (*(void *)v31 != -8192 || v52 != -2)) {
          goto LABEL_61;
        }
      }
      uint64_t v31 = v32;
LABEL_61:
      ;
    }
    while (v31 != v33);
  }
  return MEMORY[0x1D25D9CD0](v4, 4);
}

void *sub_1CBF9B234(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = operator new(0x30uLL);
  *uint64_t v6 = a1;
  v6[2] = 2;
  v6[3] = 0;
  v6[4] = a2;
  if (a2 != -8192 && a2 != -4096 && a2) {
    llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)(v6 + 2));
  }
  v6[1] = &unk_1F2601818;
  v6[5] = a3;
  return v6;
}

void sub_1CBF9B2C4()
{
}

void *sub_1CBF9B2D8(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1F2601840;
  result[1] = v3;
  return result;
}

uint64_t sub_1CBF9B320(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F2601840;
  a2[1] = v2;
  return result;
}

void sub_1CBF9B34C()
{
}

void sub_1CBF9B37C()
{
}

void *sub_1CBF9B390(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1F2601888;
  result[1] = v3;
  return result;
}

uint64_t sub_1CBF9B3D8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F2601888;
  a2[1] = v2;
  return result;
}

void sub_1CBF9B404(uint64_t a1, uint64_t a2)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(uint64_t **)(*(void *)(a1 + 8) + 8);
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  if (v4 == v5)
  {
LABEL_4:
    uint64_t v6 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v4 != &llvm::TargetLibraryInfoWrapperPass::ID)
    {
      v4 += 16;
      if (v4 == v5) {
        goto LABEL_4;
      }
    }
    uint64_t v6 = *(void *)(v4 + 8);
  }
  uint64_t v7 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v6 + 96))(v6, &llvm::TargetLibraryInfoWrapperPass::ID);
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  int v13 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  int v16 = 0;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  int v19 = 0;
  uint64_t v8 = v7 + 32;
  if (!*(unsigned char *)(v7 + 232))
  {
    uint64_t v9 = *(void *)(a2 + 40) + 216;
    __int16 v21 = 260;
    v20[0] = v9;
    llvm::Triple::Triple((llvm::Triple *)__p, (const llvm::Twine *)v20);
    uint64_t v31 = 0;
    uint64_t v32 = 0;
    int v33 = 0;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    *(void *)&long long v10 = -1;
    *((void *)&v10 + 1) = -1;
    *(_OWORD *)__src = v10;
    long long v25 = v10;
    long long v26 = v10;
    long long v27 = v10;
    long long v28 = v10;
    long long v29 = v10;
    *(_OWORD *)uint64_t v30 = v10;
    *(void *)&v30[13] = -1;
    sub_1CC153974((uint64_t)__src, (int *)__p);
    sub_1CD4D04B8(v8, (uint64_t)__src);
    sub_1CD4CFA4C((uint64_t *)__src);
    if (v23 < 0) {
      operator delete(__p[0]);
    }
  }
  sub_1CC1569E8(__src, v8);
}

void *llvm::AllAnalysesOn<llvm::LazyCallGraph::SCC>::ID()
{
  return &llvm::AllAnalysesOn<llvm::LazyCallGraph::SCC>::SetKey;
}

void *llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>::Invalidator::Invalidator(void *result, uint64_t a2, uint64_t a3)
{
  void *result = a2;
  result[1] = a3;
  return result;
}

{
  void *result = a2;
  result[1] = a3;
  return result;
}

uint64_t llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>::AnalysisManager(uint64_t result)
{
  *(void *)BOOL result = 0;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  *(void *)(result + 32) = 0;
  *(_DWORD *)(result + 40) = 0;
  *(void *)(result + 48) = 0;
  *(void *)(result + 56) = 0;
  *(_DWORD *)(result + 64) = 0;
  return result;
}

{
  *(void *)BOOL result = 0;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  *(void *)(result + 32) = 0;
  *(_DWORD *)(result + 40) = 0;
  *(void *)(result + 48) = 0;
  *(void *)(result + 56) = 0;
  *(_DWORD *)(result + 64) = 0;
  return result;
}

uint64_t llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>::AnalysisManager(uint64_t result, uint64_t a2)
{
  *(void *)BOOL result = 0;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(void *)BOOL result = *(void *)a2;
  *(void *)a2 = 0;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a2 + 8) = 0;
  int v2 = *(_DWORD *)(result + 12);
  *(_DWORD *)(result + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a2 + 12) = v2;
  int v3 = *(_DWORD *)(result + 16);
  *(_DWORD *)(result + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 16) = v3;
  *(void *)(result + 24) = 0;
  *(void *)(result + 32) = 0;
  *(_DWORD *)(result + 40) = 0;
  *(void *)(result + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = 0;
  *(_DWORD *)(result + 32) = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a2 + 32) = 0;
  int v4 = *(_DWORD *)(result + 36);
  *(_DWORD *)(result + 36) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a2 + 36) = v4;
  int v5 = *(_DWORD *)(result + 40);
  *(_DWORD *)(result + 40) = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a2 + 40) = v5;
  *(void *)(result + 48) = 0;
  *(void *)(result + 56) = 0;
  *(_DWORD *)(result + 64) = 0;
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = 0;
  *(_DWORD *)(result + 56) = *(_DWORD *)(a2 + 56);
  *(_DWORD *)(a2 + 56) = 0;
  int v6 = *(_DWORD *)(result + 60);
  *(_DWORD *)(result + 60) = *(_DWORD *)(a2 + 60);
  *(_DWORD *)(a2 + 60) = v6;
  int v7 = *(_DWORD *)(result + 64);
  *(_DWORD *)(result + 64) = *(_DWORD *)(a2 + 64);
  *(_DWORD *)(a2 + 64) = v7;
  return result;
}

{
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;

  *(void *)BOOL result = 0;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(void *)BOOL result = *(void *)a2;
  *(void *)a2 = 0;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a2 + 8) = 0;
  int v2 = *(_DWORD *)(result + 12);
  *(_DWORD *)(result + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a2 + 12) = v2;
  int v3 = *(_DWORD *)(result + 16);
  *(_DWORD *)(result + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 16) = v3;
  *(void *)(result + 24) = 0;
  *(void *)(result + 32) = 0;
  *(_DWORD *)(result + 40) = 0;
  *(void *)(result + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = 0;
  *(_DWORD *)(result + 32) = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a2 + 32) = 0;
  int v4 = *(_DWORD *)(result + 36);
  *(_DWORD *)(result + 36) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a2 + 36) = v4;
  int v5 = *(_DWORD *)(result + 40);
  *(_DWORD *)(result + 40) = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a2 + 40) = v5;
  *(void *)(result + 48) = 0;
  *(void *)(result + 56) = 0;
  *(_DWORD *)(result + 64) = 0;
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = 0;
  *(_DWORD *)(result + 56) = *(_DWORD *)(a2 + 56);
  *(_DWORD *)(a2 + 56) = 0;
  int v6 = *(_DWORD *)(result + 60);
  *(_DWORD *)(result + 60) = *(_DWORD *)(a2 + 60);
  *(_DWORD *)(a2 + 60) = v6;
  int v7 = *(_DWORD *)(result + 64);
  *(_DWORD *)(result + 64) = *(_DWORD *)(a2 + 64);
  *(_DWORD *)(a2 + 64) = v7;
  return result;
}

void *llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>::operator=(void *a1, uint64_t a2)
{
  sub_1CBFA5078((unsigned int *)a1);
  MEMORY[0x1D25D9CD0](*a1, 8);
  *a1 = 0;
  a1[1] = 0;
  *((_DWORD *)a1 + 4) = 0;
  *a1 = *(void *)a2;
  *(void *)a2 = 0;
  *((_DWORD *)a1 + 2) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a2 + 8) = 0;
  int v5 = a1 + 3;
  uint64_t v4 = a1[3];
  int v6 = *((_DWORD *)a1 + 3);
  *((_DWORD *)a1 + 3) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a2 + 12) = v6;
  int v7 = *((_DWORD *)a1 + 4);
  *((_DWORD *)a1 + 4) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 16) = v7;
  uint64_t v8 = *((unsigned int *)a1 + 10);
  if (v8)
  {
    uint64_t v9 = (uint64_t *)(v4 + 8);
    uint64_t v10 = 32 * v8;
    do
    {
      if ((*(v9 - 1) | 0x1000) != 0xFFFFFFFFFFFFF000) {
        sub_1CBFA50F4(v9);
      }
      v9 += 4;
      v10 -= 32;
    }
    while (v10);
    uint64_t v4 = *v5;
  }
  MEMORY[0x1D25D9CD0](v4, 8);
  *int v5 = 0;
  a1[4] = 0;
  *((_DWORD *)a1 + 10) = 0;
  a1[3] = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = 0;
  *((_DWORD *)a1 + 8) = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a2 + 32) = 0;
  int v11 = *((_DWORD *)a1 + 9);
  *((_DWORD *)a1 + 9) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a2 + 36) = v11;
  int v12 = *((_DWORD *)a1 + 10);
  *((_DWORD *)a1 + 10) = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a2 + 40) = v12;
  MEMORY[0x1D25D9CD0](a1[6], 8);
  a1[6] = 0;
  a1[7] = 0;
  *((_DWORD *)a1 + 16) = 0;
  a1[6] = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = 0;
  *((_DWORD *)a1 + 14) = *(_DWORD *)(a2 + 56);
  *(_DWORD *)(a2 + 56) = 0;
  int v13 = *((_DWORD *)a1 + 15);
  *((_DWORD *)a1 + 15) = *(_DWORD *)(a2 + 60);
  *(_DWORD *)(a2 + 60) = v13;
  int v14 = *((_DWORD *)a1 + 16);
  *((_DWORD *)a1 + 16) = *(_DWORD *)(a2 + 64);
  *(_DWORD *)(a2 + 64) = v14;
  return a1;
}

BOOL llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>::empty(uint64_t a1)
{
  return *(_DWORD *)(a1 + 56) == 0;
}

void llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>::clear()
{
}

{
  while (1)
    ;
}

void llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>::clear(uint64_t a1)
{
  sub_1CBF9BC38((_DWORD *)(a1 + 48));

  sub_1CBF9BC8C((_DWORD *)(a1 + 24));
}

_DWORD *sub_1CBF9BC38(_DWORD *result)
{
  if (*((void *)result + 1))
  {
    unsigned int v1 = result[4];
    if (v1 <= 4 * result[2] || v1 < 0x41)
    {
      if (v1)
      {
        int v2 = *(void **)result;
        uint64_t v3 = *(void *)result + 24 * v1;
        do
        {
          *int v2 = -4096;
          v2[1] = -4096;
          v2 += 3;
        }
        while (v2 != (void *)v3);
      }
      *((void *)result + 1) = 0;
    }
    else
    {
      return sub_1CBFA5190(result);
    }
  }
  return result;
}

void sub_1CBF9BC8C(_DWORD *a1)
{
  int v2 = a1[2];
  if (v2 || a1[3])
  {
    uint64_t v3 = a1[4];
    if (v3 > 4 * v2 && v3 >= 0x41)
    {
      sub_1CBFA5244(a1);
    }
    else
    {
      if (v3)
      {
        uint64_t v4 = 32 * v3;
        int v5 = (uint64_t *)(*(void *)a1 + 8);
        do
        {
          uint64_t v6 = *(v5 - 1);
          if (v6 != -4096)
          {
            if (v6 != -8192) {
              sub_1CBFA50F4(v5);
            }
            *(v5 - 1) = -4096;
          }
          v5 += 4;
          v4 -= 32;
        }
        while (v4);
      }
      *((void *)a1 + 1) = 0;
    }
  }
}

void llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>::invalidate(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (!sub_1CBFA534C(a3, (uint64_t)&llvm::AllAnalysesOn<llvm::LazyCallGraph::SCC>::SetKey))
  {
    uint64_t v21 = 1;
    for (uint64_t i = 8; i != 136; i += 16)
      *(uint64_t *)((char *)&v21 + i) = -4096;
    v20[0] = &v21;
    v20[1] = a1 + 48;
    uint64_t v19 = a2;
    int v7 = sub_1CBFA5558(a1 + 24, &v19);
    uint64_t v8 = v7 + 1;
    uint64_t v9 = (uint64_t *)v7[2];
    if (v9 != v7 + 1)
    {
      do
      {
        uint64_t v10 = v9[2];
        uint64_t v11 = v9[3];
        uint64_t v12 = sub_1CBF5BF34((uint64_t)&v21, v10);
        if (v21) {
          int v13 = &v22;
        }
        else {
          int v13 = v22;
        }
        unsigned int v14 = v23;
        if (v21) {
          unsigned int v14 = 8;
        }
        if (&v13[2 * v14] == (void *)v12)
        {
          char v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *, void *))(*(void *)v11 + 16))(v11, a2, a3, v20);
          uint64_t v17 = v10;
          v18[0] = v15;
          sub_1CBF5C150((uint64_t)&v21, &v17, v18, (uint64_t)&v19);
        }
        uint64_t v9 = (uint64_t *)v9[1];
      }
      while (v9 != v8);
    }
    if (v21 >= 2)
    {
      for (uint64_t j = v7[2]; (uint64_t *)j != v8; uint64_t j = *(void *)(j + 8))
      {
        uint64_t v19 = *(void *)(j + 16);
        uint64_t v17 = 0;
        if (sub_1CBF5BFB4((uint64_t)&v21, &v19, &v17) && *(unsigned char *)(v17 + 8)) {
          llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>::getCachedResultImpl();
        }
      }
    }
    if (!v7[3]) {
      sub_1CD46D52C(a1 + 24, a2);
    }
    if ((v21 & 1) == 0) {
      MEMORY[0x1D25D9CD0](v22, 8);
    }
  }
}

uint64_t sub_1CBF9C01C(uint64_t result, uint64_t a2)
{
  if (result)
  {
    if (*(_DWORD *)(result + 1016))
    {
      (*(void (**)(uint64_t))(*(void *)a2 + 24))(a2);
      uint64_t v2 = 0;
      operator new();
    }
  }
  return result;
}

uint64_t llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>::lookUpPass(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = 0;
  if (sub_1CD40EA84(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v5)) {
    uint64_t v3 = v5;
  }
  else {
    uint64_t v3 = *(void *)a1 + 16 * *(unsigned int *)(a1 + 16);
  }
  return *(void *)(v3 + 8);
}

{
  uint64_t v3;
  uint64_t v5;

  uint64_t v5 = 0;
  if (sub_1CD40EA84(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v5)) {
    uint64_t v3 = v5;
  }
  else {
    uint64_t v3 = *(void *)a1 + 16 * *(unsigned int *)(a1 + 16);
  }
  return *(void *)(v3 + 8);
}

uint64_t llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>::getResultImpl(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v24 = (uint64_t)a2;
  uint64_t v25 = a3;
  uint64_t v8 = (uint64_t *)(a1 + 48);
  uint64_t v26 = 0;
  long long v27 = 0;
  char v9 = sub_1CBF5C064((uint64_t *)(a1 + 48), &v24, &v27);
  uint64_t v10 = v27;
  if (v9)
  {
    uint64_t v11 = v27[2];
    return *(void *)(v11 + 24);
  }
  int v13 = *(_DWORD *)(a1 + 56);
  unsigned int v14 = *(_DWORD *)(a1 + 64);
  if (4 * v13 + 4 >= 3 * v14)
  {
    v14 *= 2;
  }
  else if (v14 + ~v13 - *(_DWORD *)(a1 + 60) > v14 >> 3)
  {
    goto LABEL_6;
  }
  sub_1CBFA590C((uint64_t)v8, v14);
  long long v27 = 0;
  sub_1CBF5C064(v8, &v24, &v27);
  uint64_t v10 = v27;
LABEL_6:
  ++*(_DWORD *)(a1 + 56);
  if (*v10 != -4096 || v10[1] != -4096) {
    --*(_DWORD *)(a1 + 60);
  }
  *uint64_t v10 = v24;
  v10[1] = v25;
  v10[2] = v26;
  uint64_t v24 = 0;
  if (sub_1CD40EA84(*(void *)a1, *(_DWORD *)(a1 + 16), (uint64_t)a2, &v24)) {
    uint64_t v15 = v24;
  }
  else {
    uint64_t v15 = *(void *)a1 + 16 * *(unsigned int *)(a1 + 16);
  }
  uint64_t v16 = *(void *)(v15 + 8);
  if (a2 == &llvm::PassInstrumentationAnalysis::Key)
  {
    uint64_t v17 = 0;
  }
  else
  {
    uint64_t v17 = *(void *)(llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>::getResultImpl(a1, &llvm::PassInstrumentationAnalysis::Key, a3, a4)+ 8);
    if (v17 && *(_DWORD *)(v17 + 728))
    {
      (*(void (**)(uint64_t))(*(void *)v16 + 24))(v16);
      uint64_t v24 = 0;
      operator new();
    }
  }
  uint64_t v24 = a3;
  uint64_t v18 = sub_1CBFA5558(a1 + 24, &v24);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v16 + 16))(&v24, v16, a3, a1, a4);
  uint64_t v19 = operator new(0x20uLL);
  uint64_t v21 = v18[1];
  uint64_t v20 = v18 + 1;
  uint64_t v22 = v24;
  void v19[2] = a2;
  v19[3] = v22;
  *uint64_t v19 = v21;
  v19[1] = v20;
  *(void *)(v21 + 8) = v19;
  *uint64_t v20 = (uint64_t)v19;
  ++v20[2];
  if (v17 && *(_DWORD *)(v17 + 872))
  {
    (*(void (**)(uint64_t))(*(void *)v16 + 24))(v16);
    uint64_t v24 = 0;
    operator new();
  }
  uint64_t v24 = (uint64_t)a2;
  uint64_t v25 = a3;
  long long v27 = 0;
  if (sub_1CBF5C064(v8, &v24, &v27)) {
    uint64_t v23 = (uint64_t)v27;
  }
  else {
    uint64_t v23 = *(void *)(a1 + 48) + 24 * *(unsigned int *)(a1 + 64);
  }
  uint64_t v11 = *v20;
  *(void *)(v23 + 16) = *v20;
  return *(void *)(v11 + 24);
}

uint64_t llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>::getCachedResultImpl(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v8[0] = a2;
  v8[1] = a3;
  uint64_t v9 = 0;
  if (sub_1CBF5C064((uint64_t *)(a1 + 48), v8, &v9))
  {
    uint64_t v4 = v9;
    uint64_t v5 = *(void *)(a1 + 48);
    unsigned int v6 = *(_DWORD *)(a1 + 64);
  }
  else
  {
    uint64_t v5 = *(void *)(a1 + 48);
    unsigned int v6 = *(_DWORD *)(a1 + 64);
    uint64_t v4 = v5 + 24 * v6;
  }
  if (v4 == v5 + 24 * v6) {
    return 0;
  }
  else {
    return *(void *)(*(void *)(v4 + 16) + 24);
  }
}

__n128 llvm::PassManager<llvm::LazyCallGraph::SCC,llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>,llvm::LazyCallGraph&,llvm::CGSCCUpdateResult &>::PassManager(__n128 *a1, __n128 *a2)
{
  a1->n128_u64[0] = 0;
  a1->n128_u64[1] = 0;
  a1[1].n128_u64[0] = 0;
  __n128 result = *a2;
  *a1 = *a2;
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  return result;
}

{
  __n128 result;

  a1->n128_u64[0] = 0;
  a1->n128_u64[1] = 0;
  a1[1].n128_u64[0] = 0;
  __n128 result = *a2;
  *a1 = *a2;
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  return result;
}

void *llvm::PassManager<llvm::LazyCallGraph::SCC,llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>,llvm::LazyCallGraph&,llvm::CGSCCUpdateResult &>::operator=(void *a1, uint64_t a2)
{
  uint64_t v4 = (void *)*a1;
  if (*a1)
  {
    uint64_t v5 = (void *)a1[1];
    unsigned int v6 = (void *)*a1;
    if (v5 != v4)
    {
      do
      {
        uint64_t v8 = *--v5;
        uint64_t v7 = v8;
        *uint64_t v5 = 0;
        if (v8) {
          (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
        }
      }
      while (v5 != v4);
      unsigned int v6 = (void *)*a1;
    }
    a1[1] = v4;
    operator delete(v6);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  *(_OWORD *)a1 = *(_OWORD *)a2;
  a1[2] = *(void *)(a2 + 16);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  return a1;
}

BOOL llvm::PassManager<llvm::LazyCallGraph::SCC,llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>,llvm::LazyCallGraph&,llvm::CGSCCUpdateResult &>::isEmpty(void *a1)
{
  return *a1 == a1[1];
}

uint64_t llvm::PassManager<llvm::LazyCallGraph::SCC,llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>,llvm::LazyCallGraph&,llvm::CGSCCUpdateResult &>::isRequired()
{
  return 1;
}

void *llvm::InnerAnalysisManagerProxy<llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>,llvm::Module>::InnerAnalysisManagerProxy(void *result, uint64_t a2)
{
  void *result = a2;
  return result;
}

{
  void *result = a2;
  return result;
}

void *llvm::OuterAnalysisManagerProxy<llvm::AnalysisManager<llvm::Module>,llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>::Result::Result(void *result, uint64_t a2)
{
  void *result = a2;
  result[1] = 1;
  for (uint64_t i = 2; i != 6; i += 2)
    result[i] = -4096;
  return result;
}

{
  uint64_t i;

  void *result = a2;
  result[1] = 1;
  for (uint64_t i = 2; i != 6; i += 2)
    result[i] = -4096;
  return result;
}

uint64_t llvm::OuterAnalysisManagerProxy<llvm::AnalysisManager<llvm::Module>,llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>::Result::invalidate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v30[4] = *MEMORY[0x1E4F143B8];
  long long v28 = v30;
  uint64_t v29 = 0x400000000;
  uint64_t v8 = (_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 8);
  if (v7 <= 1)
  {
    if (v7)
    {
      uint64_t v9 = a1 + 16;
      uint64_t v10 = 2;
    }
    else
    {
      uint64_t v9 = *(void *)(a1 + 16);
      uint64_t v10 = *(unsigned int *)(a1 + 24);
    }
    uint64_t v11 = (void *)(v9 + 16 * v10);
    uint64_t v12 = v11;
    if (v7)
    {
LABEL_5:
      int v13 = (void *)(a1 + 16);
      uint64_t v14 = 2;
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  if (v7)
  {
    uint64_t v12 = (void *)(a1 + 16);
    uint64_t v15 = (void *)(a1 + 48);
LABEL_8:
    uint64_t v11 = v12;
    while ((*v11 | 0x1000) == 0xFFFFFFFFFFFFF000)
    {
      v11 += 2;
      if (v11 == v15)
      {
        uint64_t v11 = v15;
        break;
      }
    }
    uint64_t v12 = v15;
    if (*(_DWORD *)(a1 + 8)) {
      goto LABEL_5;
    }
LABEL_13:
    int v13 = *(void **)(a1 + 16);
    uint64_t v14 = *(unsigned int *)(a1 + 24);
    goto LABEL_14;
  }
  uint64_t v12 = *(void **)(a1 + 16);
  uint64_t v25 = *(unsigned int *)(a1 + 24);
  if (v25)
  {
    uint64_t v15 = &v12[2 * v25];
    goto LABEL_8;
  }
  uint64_t v14 = 0;
  uint64_t v11 = *(void **)(a1 + 16);
  int v13 = v11;
LABEL_14:
  uint64_t v16 = &v13[2 * v14];
  if (v11 != v16)
  {
    do
    {
      uint64_t v17 = *v11;
      v27[0] = a4;
      v27[1] = a2;
      v27[2] = a3;
      sub_1CD46D654(v11 + 1, (uint64_t)v27);
      unint64_t v18 = v11[1];
      if (v18 < 8 || (v18 & 4) != 0 && (unint64_t v19 = v18 & 0xFFFFFFFFFFFFFFF8) != 0 && !*(_DWORD *)(v19 + 8))
      {
        if (v29 >= (unint64_t)HIDWORD(v29)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v28 + v29) = v17;
        LODWORD(v29) = v29 + 1;
      }
      uint64_t v20 = v11 + 2;
      uint64_t v11 = v12;
      if (v20 != v12)
      {
        uint64_t v11 = v20;
        while ((*v11 | 0x1000) == 0xFFFFFFFFFFFFF000)
        {
          v11 += 2;
          if (v11 == v12)
          {
            uint64_t v11 = v12;
            break;
          }
        }
      }
    }
    while (v11 != v16);
    uint64_t v21 = (uint64_t *)v28;
    if (v29)
    {
      uint64_t v22 = 8 * v29;
      do
      {
        uint64_t v23 = *v21++;
        uint64_t v26 = v23;
        sub_1CBF9CADC(v8, &v26);
        v22 -= 8;
      }
      while (v22);
      uint64_t v21 = (uint64_t *)v28;
    }
    if (v21 != v30) {
      free(v21);
    }
  }
  return 0;
}

uint64_t sub_1CBF9CADC(_DWORD *a1, void *a2)
{
  unsigned int v7 = 0;
  uint64_t v3 = sub_1CBFA5BF8((uint64_t)a1, a2, &v7);
  if (v3)
  {
    uint64_t v4 = v7;
    sub_1CBFA5CA8(v7 + 1);
    *uint64_t v4 = -8192;
    int v5 = a1[1] + 1;
    *a1 -= 2;
    a1[1] = v5;
  }
  return v3;
}

uint64_t llvm::OuterAnalysisManagerProxy<llvm::AnalysisManager<llvm::Module>,llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>::Result::getOuterInvalidations(uint64_t a1)
{
  return a1 + 8;
}

void *llvm::OuterAnalysisManagerProxy<llvm::AnalysisManager<llvm::Module>,llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>::OuterAnalysisManagerProxy(void *result, uint64_t a2)
{
  void *result = a2;
  return result;
}

{
  void *result = a2;
  return result;
}

void *llvm::OuterAnalysisManagerProxy<llvm::AnalysisManager<llvm::Module>,llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>::run@<X0>(void *result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = 0;
  *a2 = *result;
  a2[1] = 1;
  uint64_t v3 = a2 + 2;
  do
  {
    v3[v2] = -4096;
    v2 += 2;
  }
  while (v2 != 4);
  return result;
}

void *llvm::OuterAnalysisManagerProxy<llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>,llvm::Function>::Result::Result(void *result, uint64_t a2)
{
  void *result = a2;
  result[1] = 1;
  for (uint64_t i = 2; i != 6; i += 2)
    result[i] = -4096;
  return result;
}

{
  uint64_t i;

  void *result = a2;
  result[1] = 1;
  for (uint64_t i = 2; i != 6; i += 2)
    result[i] = -4096;
  return result;
}

uint64_t llvm::OuterAnalysisManagerProxy<llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>,llvm::Function>::Result::invalidate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v30[4] = *MEMORY[0x1E4F143B8];
  long long v28 = v30;
  uint64_t v29 = 0x400000000;
  uint64_t v8 = (_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 8);
  if (v7 <= 1)
  {
    if (v7)
    {
      uint64_t v9 = a1 + 16;
      uint64_t v10 = 2;
    }
    else
    {
      uint64_t v9 = *(void *)(a1 + 16);
      uint64_t v10 = *(unsigned int *)(a1 + 24);
    }
    uint64_t v11 = (void *)(v9 + 16 * v10);
    uint64_t v12 = v11;
    if (v7)
    {
LABEL_5:
      int v13 = (void *)(a1 + 16);
      uint64_t v14 = 2;
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  if (v7)
  {
    uint64_t v12 = (void *)(a1 + 16);
    uint64_t v15 = (void *)(a1 + 48);
LABEL_8:
    uint64_t v11 = v12;
    while ((*v11 | 0x1000) == 0xFFFFFFFFFFFFF000)
    {
      v11 += 2;
      if (v11 == v15)
      {
        uint64_t v11 = v15;
        break;
      }
    }
    uint64_t v12 = v15;
    if (*(_DWORD *)(a1 + 8)) {
      goto LABEL_5;
    }
LABEL_13:
    int v13 = *(void **)(a1 + 16);
    uint64_t v14 = *(unsigned int *)(a1 + 24);
    goto LABEL_14;
  }
  uint64_t v12 = *(void **)(a1 + 16);
  uint64_t v25 = *(unsigned int *)(a1 + 24);
  if (v25)
  {
    uint64_t v15 = &v12[2 * v25];
    goto LABEL_8;
  }
  uint64_t v14 = 0;
  uint64_t v11 = *(void **)(a1 + 16);
  int v13 = v11;
LABEL_14:
  uint64_t v16 = &v13[2 * v14];
  if (v11 != v16)
  {
    do
    {
      uint64_t v17 = *v11;
      v27[0] = a4;
      v27[1] = a2;
      v27[2] = a3;
      sub_1CD46D6C8(v11 + 1, (uint64_t)v27);
      unint64_t v18 = v11[1];
      if (v18 < 8 || (v18 & 4) != 0 && (unint64_t v19 = v18 & 0xFFFFFFFFFFFFFFF8) != 0 && !*(_DWORD *)(v19 + 8))
      {
        if (v29 >= (unint64_t)HIDWORD(v29)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v28 + v29) = v17;
        LODWORD(v29) = v29 + 1;
      }
      uint64_t v20 = v11 + 2;
      uint64_t v11 = v12;
      if (v20 != v12)
      {
        uint64_t v11 = v20;
        while ((*v11 | 0x1000) == 0xFFFFFFFFFFFFF000)
        {
          v11 += 2;
          if (v11 == v12)
          {
            uint64_t v11 = v12;
            break;
          }
        }
      }
    }
    while (v11 != v16);
    uint64_t v21 = (uint64_t *)v28;
    if (v29)
    {
      uint64_t v22 = 8 * v29;
      do
      {
        uint64_t v23 = *v21++;
        uint64_t v26 = v23;
        sub_1CBF9CADC(v8, &v26);
        v22 -= 8;
      }
      while (v22);
      uint64_t v21 = (uint64_t *)v28;
    }
    if (v21 != v30) {
      free(v21);
    }
  }
  return 0;
}

uint64_t llvm::OuterAnalysisManagerProxy<llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>,llvm::Function>::Result::getOuterInvalidations(uint64_t a1)
{
  return a1 + 8;
}

void *llvm::OuterAnalysisManagerProxy<llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>,llvm::Function>::OuterAnalysisManagerProxy(void *result, uint64_t a2)
{
  void *result = a2;
  return result;
}

{
  void *result = a2;
  return result;
}

void *llvm::OuterAnalysisManagerProxy<llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>,llvm::Function>::run@<X0>(void *result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = 0;
  *a2 = *result;
  a2[1] = 1;
  uint64_t v3 = a2 + 2;
  do
  {
    v3[v2] = -4096;
    v2 += 2;
  }
  while (v2 != 4);
  return result;
}

void llvm::PassManager<llvm::LazyCallGraph::SCC,llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>,llvm::LazyCallGraph&,llvm::CGSCCUpdateResult &>::run()
{
}

uint64_t sub_1CBF9D3B4(uint64_t *a1, uint64_t a2)
{
  if (*a1)
  {
    char v4 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
    uint64_t v5 = *a1;
    if ((v4 & 1) == 0 && *(_DWORD *)(v5 + 8))
    {
      (*(void (**)(uint64_t))(*(void *)a2 + 32))(a2);
      operator new();
    }
    if (*(_DWORD *)(v5 + 296))
    {
      (*(void (**)(uint64_t))(*(void *)a2 + 32))(a2);
      operator new();
    }
  }
  return 1;
}

uint64_t sub_1CBF9D784(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    uint64_t v3 = *(unsigned int *)(result + 584);
    if (v3)
    {
      unsigned int v6 = *(void **)(result + 576);
      uint64_t v7 = 32 * v3;
      do
      {
        uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 32))(a2);
        uint64_t v10 = v6[3];
        uint64_t v11 = v6;
        if ((v10 & 2) == 0) {
          uint64_t v11 = (void *)*v6;
        }
        __n128 result = (*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(v10 & 0xFFFFFFFFFFFFFFF8))(v11, v9, v8, a3);
        v6 += 4;
        v7 -= 32;
      }
      while (v7);
    }
  }
  return result;
}

uint64_t sub_1CBF9D82C(uint64_t result, uint64_t a2)
{
  if (result)
  {
    if (*(_DWORD *)(result + 440))
    {
      (*(void (**)(uint64_t))(*(void *)a2 + 32))(a2);
      uint64_t v2 = 0;
      operator new();
    }
  }
  return result;
}

double sub_1CBF9D990(uint64_t a1, uint64_t a2)
{
  LODWORD(v4) = *(_DWORD *)(a2 + 68);
  if (v4 != *(_DWORD *)(a2 + 72)) {
    goto LABEL_24;
  }
  double v6 = *(double *)a2;
  uint64_t v5 = *(void *)(a2 + 8);
  if (v5 == *(void *)a2)
  {
    uint64_t v7 = *(unsigned int *)(a2 + 20);
    uint64_t v8 = (void **)(v5 + 8 * v7);
    if (v7)
    {
      uint64_t v9 = 0;
      while (*(_UNKNOWN **)(v5 + v9) != &llvm::PreservedAnalyses::AllAnalysesKey)
      {
        v9 += 8;
        if (8 * v7 == v9) {
          goto LABEL_7;
        }
      }
      uint64_t v8 = (void **)(v5 + v9);
    }
LABEL_7:
    double v6 = *(double *)(a2 + 8);
  }
  else
  {
    uint64_t v11 = *(unsigned int *)(a2 + 16);
    int v12 = v11 - 1;
    unsigned int v13 = (v11 - 1) & ((&llvm::PreservedAnalyses::AllAnalysesKey >> 4) ^ (&llvm::PreservedAnalyses::AllAnalysesKey >> 9));
    uint64_t v8 = (void **)(v5 + 8 * v13);
    uint64_t v14 = *v8;
    if (*v8 == (void *)-1)
    {
      uint64_t v15 = 0;
LABEL_53:
      if (v15) {
        uint64_t v8 = v15;
      }
      if (*v8 != &llvm::PreservedAnalyses::AllAnalysesKey)
      {
        LODWORD(v7) = *(_DWORD *)(a2 + 20);
        uint64_t v8 = (void **)(v5 + 8 * v11);
        goto LABEL_8;
      }
    }
    else
    {
      uint64_t v15 = 0;
      int v16 = 1;
      while (v14 != &llvm::PreservedAnalyses::AllAnalysesKey)
      {
        if (v15) {
          BOOL v17 = 0;
        }
        else {
          BOOL v17 = v14 == (void *)-2;
        }
        if (v17) {
          uint64_t v15 = v8;
        }
        unsigned int v18 = v13 + v16++;
        unsigned int v13 = v18 & v12;
        uint64_t v8 = (void **)(v5 + 8 * (v18 & v12));
        uint64_t v14 = *v8;
        if (*v8 == (void *)-1) {
          goto LABEL_53;
        }
      }
    }
    LODWORD(v7) = *(_DWORD *)(a2 + 20);
  }
LABEL_8:
  if (v5 == *(void *)&v6) {
    unsigned int v10 = v7;
  }
  else {
    unsigned int v10 = *(_DWORD *)(a2 + 16);
  }
  if (v8 != (void **)(v5 + 8 * v10)) {
    return result;
  }
LABEL_24:
  if (*(_DWORD *)(a1 + 68) == *(_DWORD *)(a1 + 72))
  {
    uint64_t v20 = *(void *)a1;
    uint64_t v19 = *(void *)(a1 + 8);
    if (v19 == *(void *)a1)
    {
      uint64_t v21 = *(unsigned int *)(a1 + 20);
      uint64_t v22 = (void **)(v19 + 8 * v21);
      if (v21)
      {
        uint64_t v23 = 0;
        uint64_t v24 = 8 * v21;
        while (*(_UNKNOWN **)(v19 + v23) != &llvm::PreservedAnalyses::AllAnalysesKey)
        {
          v23 += 8;
          if (v24 == v23) {
            goto LABEL_30;
          }
        }
        uint64_t v22 = (void **)(v19 + v23);
      }
LABEL_30:
      uint64_t v20 = *(void *)(a1 + 8);
    }
    else
    {
      uint64_t v35 = *(unsigned int *)(a1 + 16);
      int v36 = v35 - 1;
      unsigned int v37 = (v35 - 1) & ((&llvm::PreservedAnalyses::AllAnalysesKey >> 4) ^ (&llvm::PreservedAnalyses::AllAnalysesKey >> 9));
      uint64_t v22 = (void **)(v19 + 8 * v37);
      uint64_t v38 = *v22;
      if (*v22 == (void *)-1)
      {
        uint64_t v39 = 0;
LABEL_132:
        if (v39) {
          uint64_t v22 = v39;
        }
        if (*v22 != &llvm::PreservedAnalyses::AllAnalysesKey) {
          uint64_t v22 = (void **)(v19 + 8 * v35);
        }
      }
      else
      {
        uint64_t v39 = 0;
        int v40 = 1;
        while (v38 != &llvm::PreservedAnalyses::AllAnalysesKey)
        {
          if (v39) {
            BOOL v41 = 0;
          }
          else {
            BOOL v41 = v38 == (void *)-2;
          }
          if (v41) {
            uint64_t v39 = v22;
          }
          unsigned int v42 = v37 + v40++;
          unsigned int v37 = v42 & v36;
          uint64_t v22 = (void **)(v19 + 8 * (v42 & v36));
          uint64_t v38 = *v22;
          if (*v22 == (void *)-1) {
            goto LABEL_132;
          }
        }
      }
    }
    BOOL v17 = v19 == v20;
    uint64_t v25 = 16;
    if (v17) {
      uint64_t v25 = 20;
    }
    if (v22 != (void **)(v19 + 8 * *(unsigned int *)(a1 + v25)))
    {
      if (a2 != a1)
      {
        llvm::SmallPtrSetImplBase::MoveFrom(a1, 2, (double *)a2);
        return llvm::SmallPtrSetImplBase::MoveFrom(a1 + 48, 2, (double *)(a2 + 48));
      }
      return result;
    }
  }
  uint64_t v26 = *(void *)(a2 + 56);
  if (v26 == *(void *)(a2 + 48)) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = *(unsigned int *)(a2 + 64);
  }
  if (v4)
  {
    uint64_t v43 = 8 * v4;
    long long v27 = *(unint64_t **)(a2 + 56);
    while (*v27 >= 0xFFFFFFFFFFFFFFFELL)
    {
      ++v27;
      v43 -= 8;
      if (!v43) {
        goto LABEL_40;
      }
    }
  }
  else
  {
    long long v27 = *(unint64_t **)(a2 + 56);
  }
  long long v28 = (unint64_t *)(v26 + 8 * v4);
  if (v27 != v28)
  {
    unint64_t v44 = *v27;
LABEL_75:
    uint64_t v46 = *(void *)a1;
    uint64_t v45 = *(void *)(a1 + 8);
    if (v45 == *(void *)a1)
    {
      uint64_t v47 = *(unsigned int *)(a1 + 20);
      unint64_t v48 = (void *)(v45 + 8 * v47);
      if (v47)
      {
        uint64_t v49 = 0;
        uint64_t v50 = 8 * v47;
        while (*(void *)(v45 + v49) != v44)
        {
          v49 += 8;
          if (v50 == v49) {
            goto LABEL_80;
          }
        }
        unint64_t v48 = (void *)(v45 + v49);
      }
LABEL_80:
      uint64_t v46 = *(void *)(a1 + 8);
    }
    else
    {
      uint64_t v68 = *(unsigned int *)(a1 + 16);
      int v69 = v68 - 1;
      unsigned int v70 = (v68 - 1) & ((v44 >> 4) ^ (v44 >> 9));
      unint64_t v48 = (void *)(v45 + 8 * v70);
      uint64_t v71 = *v48;
      if (*v48 == -1)
      {
        long long v72 = 0;
LABEL_138:
        if (v72) {
          unint64_t v48 = v72;
        }
        if (*v48 != v44) {
          unint64_t v48 = (void *)(v45 + 8 * v68);
        }
      }
      else
      {
        long long v72 = 0;
        int v73 = 1;
        while (v71 != v44)
        {
          if (v72) {
            BOOL v74 = 0;
          }
          else {
            BOOL v74 = v71 == -2;
          }
          if (v74) {
            long long v72 = v48;
          }
          unsigned int v75 = v70 + v73++;
          unsigned int v70 = v75 & v69;
          unint64_t v48 = (void *)(v45 + 8 * (v75 & v69));
          uint64_t v71 = *v48;
          if (*v48 == -1) {
            goto LABEL_138;
          }
        }
      }
    }
    if (v45 == v46) {
      int v51 = (unsigned int *)(a1 + 20);
    }
    else {
      int v51 = (unsigned int *)(a1 + 16);
    }
    if (v48 != (void *)(v45 + 8 * *v51))
    {
      *unint64_t v48 = -2;
      ++*(_DWORD *)(a1 + 24);
    }
    uint64_t v52 = *(void *)(a1 + 56);
    uint64_t v53 = *(unsigned int *)(a1 + 68);
    if (v52 == *(void *)(a1 + 48))
    {
      if (v53)
      {
        BOOL v54 = 0;
        uint64_t v55 = 8 * v53;
        int v56 = *(unint64_t **)(a1 + 56);
        while (*v56 != v44)
        {
          if (*v56 == -2) {
            BOOL v54 = v56;
          }
          ++v56;
          v55 -= 8;
          if (!v55)
          {
            if (!v54) {
              goto LABEL_94;
            }
            *BOOL v54 = v44;
            --*(_DWORD *)(a1 + 72);
            goto LABEL_96;
          }
        }
        goto LABEL_96;
      }
LABEL_94:
      unsigned int v57 = *(_DWORD *)(a1 + 64);
      if (v53 < v57)
      {
        *(_DWORD *)(a1 + 68) = v53 + 1;
        *(void *)(v52 + 8 * v53) = v44;
LABEL_96:
        unsigned int v58 = v27 + 1;
        while (v58 != v28)
        {
          unint64_t v110 = *v58++;
          unint64_t v44 = v110;
          if (v110 <= 0xFFFFFFFFFFFFFFFDLL)
          {
            long long v27 = v58 - 1;
            goto LABEL_75;
          }
        }
        goto LABEL_40;
      }
    }
    else
    {
      unsigned int v57 = *(_DWORD *)(a1 + 64);
    }
    if (3 * v57 <= 4 * ((int)v53 - *(_DWORD *)(a1 + 72)))
    {
      if (v57 >= 0x40) {
        v57 *= 2;
      }
      else {
        unsigned int v57 = 128;
      }
    }
    else if (v57 - v53 >= v57 >> 3)
    {
      goto LABEL_102;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)(a1 + 48), v57);
    unsigned int v57 = *(_DWORD *)(a1 + 64);
    uint64_t v52 = *(void *)(a1 + 56);
LABEL_102:
    unsigned int v59 = v57 - 1;
    unsigned int v60 = (v57 - 1) & ((v44 >> 4) ^ (v44 >> 9));
    uint64_t v61 = (unint64_t *)(v52 + 8 * v60);
    unint64_t v62 = *v61;
    if (*v61 == -1)
    {
      uint64_t v63 = 0;
LABEL_112:
      if (v63) {
        uint64_t v67 = v63;
      }
      else {
        uint64_t v67 = v61;
      }
      if (*v67 != v44)
      {
        if (*v67 == -2) {
          --*(_DWORD *)(a1 + 72);
        }
        else {
          ++*(_DWORD *)(a1 + 68);
        }
        *uint64_t v67 = v44;
      }
    }
    else
    {
      uint64_t v63 = 0;
      int v64 = 1;
      while (v62 != v44)
      {
        if (v63) {
          BOOL v65 = 0;
        }
        else {
          BOOL v65 = v62 == -2;
        }
        if (v65) {
          uint64_t v63 = v61;
        }
        unsigned int v66 = v60 + v64++;
        unsigned int v60 = v66 & v59;
        uint64_t v61 = (unint64_t *)(v52 + 8 * (v66 & v59));
        unint64_t v62 = *v61;
        if (*v61 == -1) {
          goto LABEL_112;
        }
      }
    }
    goto LABEL_96;
  }
LABEL_40:
  uint64_t v29 = *(void *)(a1 + 8);
  uint64_t v30 = 16;
  if (v29 == *(void *)a1) {
    uint64_t v30 = 20;
  }
  uint64_t v31 = *(unsigned int *)(a1 + v30);
  if (v31)
  {
    uint64_t v32 = 8 * v31;
    for (uint64_t i = *(unint64_t **)(a1 + 8); *i >= 0xFFFFFFFFFFFFFFFELL; ++i)
    {
      v32 -= 8;
      if (!v32) {
        return result;
      }
    }
  }
  else
  {
    uint64_t i = *(unint64_t **)(a1 + 8);
  }
  uint64_t v76 = (unint64_t *)(v29 + 8 * v31);
  if (i != v76)
  {
    unint64_t v77 = *i;
LABEL_145:
    double v79 = *(double *)a2;
    uint64_t v78 = *(void *)(a2 + 8);
    if (v78 == *(void *)a2)
    {
      uint64_t v80 = *(unsigned int *)(a2 + 20);
      unsigned int v81 = (void *)(v78 + 8 * v80);
      if (v80)
      {
        uint64_t v82 = 0;
        while (*(void *)(v78 + v82) != v77)
        {
          v82 += 8;
          if (8 * v80 == v82) {
            goto LABEL_150;
          }
        }
        unsigned int v81 = (void *)(v78 + v82);
      }
LABEL_150:
      double v79 = *(double *)(a2 + 8);
    }
    else
    {
      uint64_t v86 = *(unsigned int *)(a2 + 16);
      int v87 = v86 - 1;
      unsigned int v88 = (v86 - 1) & ((v77 >> 4) ^ (v77 >> 9));
      unsigned int v81 = (void *)(v78 + 8 * v88);
      uint64_t v89 = *v81;
      if (*v81 == -1)
      {
        int v90 = 0;
LABEL_184:
        if (v90) {
          unsigned int v81 = v90;
        }
        LODWORD(v80) = *(_DWORD *)(a2 + 20);
        uint64_t v101 = (void *)(v78 + 8 * v86);
        if (*v81 != v77) {
          unsigned int v81 = v101;
        }
      }
      else
      {
        int v90 = 0;
        int v91 = 1;
        while (v89 != v77)
        {
          if (v90) {
            BOOL v92 = 0;
          }
          else {
            BOOL v92 = v89 == -2;
          }
          if (v92) {
            int v90 = v81;
          }
          unsigned int v93 = v88 + v91++;
          unsigned int v88 = v93 & v87;
          unsigned int v81 = (void *)(v78 + 8 * (v93 & v87));
          uint64_t v89 = *v81;
          if (*v81 == -1) {
            goto LABEL_184;
          }
        }
        LODWORD(v80) = *(_DWORD *)(a2 + 20);
      }
    }
    if (v78 == *(void *)&v79) {
      unsigned int v83 = v80;
    }
    else {
      unsigned int v83 = *(_DWORD *)(a2 + 16);
    }
    if (v81 == (void *)(v78 + 8 * v83))
    {
      uint64_t v95 = *(void *)a1;
      uint64_t v94 = *(void *)(a1 + 8);
      if (v94 == *(void *)a1)
      {
        uint64_t v96 = *(unsigned int *)(a1 + 20);
        unsigned int v97 = (void *)(v94 + 8 * v96);
        if (v96)
        {
          uint64_t v98 = 0;
          uint64_t v99 = 8 * v96;
          while (*(void *)(v94 + v98) != v77)
          {
            v98 += 8;
            if (v99 == v98) {
              goto LABEL_177;
            }
          }
          unsigned int v97 = (void *)(v94 + v98);
        }
LABEL_177:
        uint64_t v95 = *(void *)(a1 + 8);
      }
      else
      {
        uint64_t v102 = *(unsigned int *)(a1 + 16);
        int v103 = v102 - 1;
        unsigned int v104 = (v102 - 1) & ((v77 >> 4) ^ (v77 >> 9));
        unsigned int v97 = (void *)(v94 + 8 * v104);
        uint64_t v105 = *v97;
        if (*v97 == -1)
        {
          uint64_t v106 = 0;
LABEL_202:
          if (v106) {
            unsigned int v97 = v106;
          }
          if (*v97 != v77) {
            unsigned int v97 = (void *)(v94 + 8 * v102);
          }
        }
        else
        {
          uint64_t v106 = 0;
          int v107 = 1;
          while (v105 != v77)
          {
            if (v106) {
              BOOL v108 = 0;
            }
            else {
              BOOL v108 = v105 == -2;
            }
            if (v108) {
              uint64_t v106 = v97;
            }
            unsigned int v109 = v104 + v107++;
            unsigned int v104 = v109 & v103;
            unsigned int v97 = (void *)(v94 + 8 * (v109 & v103));
            uint64_t v105 = *v97;
            if (*v97 == -1) {
              goto LABEL_202;
            }
          }
        }
      }
      if (v94 == v95) {
        uint64_t v100 = (unsigned int *)(a1 + 20);
      }
      else {
        uint64_t v100 = (unsigned int *)(a1 + 16);
      }
      if (v97 != (void *)(v94 + 8 * *v100))
      {
        void *v97 = -2;
        ++*(_DWORD *)(a1 + 24);
      }
    }
    int v84 = i + 1;
    while (v84 != v76)
    {
      unint64_t v85 = *v84++;
      unint64_t v77 = v85;
      if (v85 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        uint64_t i = v84 - 1;
        goto LABEL_145;
      }
    }
  }
  return result;
}

void sub_1CBF9E154(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 68) == *(_DWORD *)(a2 + 72))
  {
    long long v72 = sub_1CB896AE8(a2, (uint64_t)&llvm::PreservedAnalyses::AllAnalysesKey);
    uint64_t v73 = *(void *)(a2 + 8);
    BOOL v74 = (unsigned int *)(v73 == *(void *)a2 ? a2 + 20 : a2 + 16);
    if (v72 != (void *)(v73 + 8 * *v74)) {
      return;
    }
  }
  if (*(_DWORD *)(a1 + 68) == *(_DWORD *)(a1 + 72))
  {
    unsigned int v66 = sub_1CB896AE8(a1, (uint64_t)&llvm::PreservedAnalyses::AllAnalysesKey);
    uint64_t v67 = *(void *)(a1 + 8);
    uint64_t v68 = 16;
    if (v67 == *(void *)a1) {
      uint64_t v68 = 20;
    }
    if (v66 != (void *)(v67 + 8 * *(unsigned int *)(a1 + v68)))
    {
      if (a2 != a1)
      {
        llvm::SmallPtrSetImplBase::CopyFrom((llvm::SmallPtrSetImplBase *)a1, (const llvm::SmallPtrSetImplBase *)a2);
        llvm::SmallPtrSetImplBase::CopyFrom((llvm::SmallPtrSetImplBase *)(a1 + 48), (const llvm::SmallPtrSetImplBase *)(a2 + 48));
      }
      return;
    }
  }
  uint64_t v4 = *(void *)(a2 + 56);
  if (v4 == *(void *)(a2 + 48)) {
    uint64_t v5 = (unsigned int *)(a2 + 68);
  }
  else {
    uint64_t v5 = (unsigned int *)(a2 + 64);
  }
  uint64_t v6 = *v5;
  if (v6)
  {
    uint64_t v7 = 8 * v6;
    uint64_t v8 = *(unint64_t **)(a2 + 56);
    while (*v8 >= 0xFFFFFFFFFFFFFFFELL)
    {
      ++v8;
      v7 -= 8;
      if (!v7) {
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v8 = *(unint64_t **)(a2 + 56);
  }
  uint64_t v9 = (unint64_t *)(v4 + 8 * v6);
  if (v8 != v9)
  {
    unint64_t v34 = *v8;
LABEL_51:
    uint64_t v36 = *(void *)a1;
    uint64_t v35 = *(void *)(a1 + 8);
    if (v35 == *(void *)a1)
    {
      uint64_t v37 = *(unsigned int *)(a1 + 20);
      uint64_t v38 = (void *)(v35 + 8 * v37);
      if (v37)
      {
        uint64_t v39 = 0;
        uint64_t v40 = 8 * v37;
        while (*(void *)(v35 + v39) != v34)
        {
          v39 += 8;
          if (v40 == v39) {
            goto LABEL_56;
          }
        }
        uint64_t v38 = (void *)(v35 + v39);
      }
LABEL_56:
      uint64_t v36 = *(void *)(a1 + 8);
    }
    else
    {
      uint64_t v58 = *(unsigned int *)(a1 + 16);
      int v59 = v58 - 1;
      unsigned int v60 = (v58 - 1) & ((v34 >> 4) ^ (v34 >> 9));
      uint64_t v38 = (void *)(v35 + 8 * v60);
      uint64_t v61 = *v38;
      if (*v38 == -1)
      {
        unint64_t v62 = 0;
LABEL_109:
        if (v62) {
          uint64_t v38 = v62;
        }
        if (*v38 != v34) {
          uint64_t v38 = (void *)(v35 + 8 * v58);
        }
      }
      else
      {
        unint64_t v62 = 0;
        int v63 = 1;
        while (v61 != v34)
        {
          if (v62) {
            BOOL v64 = 0;
          }
          else {
            BOOL v64 = v61 == -2;
          }
          if (v64) {
            unint64_t v62 = v38;
          }
          unsigned int v65 = v60 + v63++;
          unsigned int v60 = v65 & v59;
          uint64_t v38 = (void *)(v35 + 8 * (v65 & v59));
          uint64_t v61 = *v38;
          if (*v38 == -1) {
            goto LABEL_109;
          }
        }
      }
    }
    if (v35 == v36) {
      BOOL v41 = (unsigned int *)(a1 + 20);
    }
    else {
      BOOL v41 = (unsigned int *)(a1 + 16);
    }
    if (v38 != (void *)(v35 + 8 * *v41))
    {
      *uint64_t v38 = -2;
      ++*(_DWORD *)(a1 + 24);
    }
    uint64_t v42 = *(void *)(a1 + 56);
    uint64_t v43 = *(unsigned int *)(a1 + 68);
    if (v42 == *(void *)(a1 + 48))
    {
      if (v43)
      {
        unint64_t v44 = 0;
        uint64_t v45 = 8 * v43;
        uint64_t v46 = *(unint64_t **)(a1 + 56);
        while (*v46 != v34)
        {
          if (*v46 == -2) {
            unint64_t v44 = v46;
          }
          ++v46;
          v45 -= 8;
          if (!v45)
          {
            if (!v44) {
              goto LABEL_70;
            }
            *unint64_t v44 = v34;
            --*(_DWORD *)(a1 + 72);
            goto LABEL_72;
          }
        }
        goto LABEL_72;
      }
LABEL_70:
      unsigned int v47 = *(_DWORD *)(a1 + 64);
      if (v43 < v47)
      {
        *(_DWORD *)(a1 + 68) = v43 + 1;
        *(void *)(v42 + 8 * v43) = v34;
LABEL_72:
        unint64_t v48 = v8 + 1;
        while (v48 != v9)
        {
          unint64_t v75 = *v48++;
          unint64_t v34 = v75;
          if (v75 <= 0xFFFFFFFFFFFFFFFDLL)
          {
            uint64_t v8 = v48 - 1;
            goto LABEL_51;
          }
        }
        goto LABEL_10;
      }
    }
    else
    {
      unsigned int v47 = *(_DWORD *)(a1 + 64);
    }
    if (3 * v47 <= 4 * ((int)v43 - *(_DWORD *)(a1 + 72)))
    {
      if (v47 >= 0x40) {
        v47 *= 2;
      }
      else {
        unsigned int v47 = 128;
      }
    }
    else if (v47 - v43 >= v47 >> 3)
    {
      goto LABEL_78;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)(a1 + 48), v47);
    unsigned int v47 = *(_DWORD *)(a1 + 64);
    uint64_t v42 = *(void *)(a1 + 56);
LABEL_78:
    unsigned int v49 = v47 - 1;
    unsigned int v50 = (v47 - 1) & ((v34 >> 4) ^ (v34 >> 9));
    int v51 = (unint64_t *)(v42 + 8 * v50);
    unint64_t v52 = *v51;
    if (*v51 == -1)
    {
      uint64_t v53 = 0;
LABEL_88:
      if (v53) {
        unsigned int v57 = v53;
      }
      else {
        unsigned int v57 = v51;
      }
      if (*v57 != v34)
      {
        if (*v57 == -2) {
          --*(_DWORD *)(a1 + 72);
        }
        else {
          ++*(_DWORD *)(a1 + 68);
        }
        *unsigned int v57 = v34;
      }
    }
    else
    {
      uint64_t v53 = 0;
      int v54 = 1;
      while (v52 != v34)
      {
        if (v53) {
          BOOL v55 = 0;
        }
        else {
          BOOL v55 = v52 == -2;
        }
        if (v55) {
          uint64_t v53 = v51;
        }
        unsigned int v56 = v50 + v54++;
        unsigned int v50 = v56 & v49;
        int v51 = (unint64_t *)(v42 + 8 * (v56 & v49));
        unint64_t v52 = *v51;
        if (*v51 == -1) {
          goto LABEL_88;
        }
      }
    }
    goto LABEL_72;
  }
LABEL_10:
  uint64_t v10 = *(void *)(a1 + 8);
  uint64_t v11 = 16;
  if (v10 == *(void *)a1) {
    uint64_t v11 = 20;
  }
  uint64_t v12 = *(unsigned int *)(a1 + v11);
  if (v12)
  {
    uint64_t v13 = 8 * v12;
    for (uint64_t i = *(uint64_t **)(a1 + 8); (unint64_t)*i >= 0xFFFFFFFFFFFFFFFELL; ++i)
    {
      v13 -= 8;
      if (!v13) {
        return;
      }
    }
  }
  else
  {
    uint64_t i = *(uint64_t **)(a1 + 8);
  }
  uint64_t v15 = (void *)(v10 + 8 * v12);
  if (i != v15)
  {
    uint64_t v16 = *i;
LABEL_17:
    uint64_t v18 = *(void *)a2;
    uint64_t v17 = *(void *)(a2 + 8);
    if (v17 == *(void *)a2)
    {
      uint64_t v19 = *(unsigned int *)(a2 + 20);
      uint64_t v20 = (void *)(v17 + 8 * v19);
      if (v19)
      {
        uint64_t v21 = 0;
        while (*(void *)(v17 + v21) != v16)
        {
          v21 += 8;
          if (8 * v19 == v21) {
            goto LABEL_22;
          }
        }
        uint64_t v20 = (void *)(v17 + v21);
      }
LABEL_22:
      uint64_t v18 = *(void *)(a2 + 8);
    }
    else
    {
      uint64_t v25 = *(unsigned int *)(a2 + 16);
      int v26 = v25 - 1;
      unsigned int v27 = (v25 - 1) & ((v16 >> 4) ^ (v16 >> 9));
      uint64_t v20 = (void *)(v17 + 8 * v27);
      uint64_t v28 = *v20;
      if (*v20 == -1)
      {
        uint64_t v29 = 0;
LABEL_45:
        if (v29) {
          uint64_t v20 = v29;
        }
        LODWORD(v19) = *(_DWORD *)(a2 + 20);
        int v33 = (void *)(v17 + 8 * v25);
        if (*v20 != v16) {
          uint64_t v20 = v33;
        }
      }
      else
      {
        uint64_t v29 = 0;
        int v30 = 1;
        while (v28 != v16)
        {
          if (v29) {
            BOOL v31 = 0;
          }
          else {
            BOOL v31 = v28 == -2;
          }
          if (v31) {
            uint64_t v29 = v20;
          }
          unsigned int v32 = v27 + v30++;
          unsigned int v27 = v32 & v26;
          uint64_t v20 = (void *)(v17 + 8 * (v32 & v26));
          uint64_t v28 = *v20;
          if (*v20 == -1) {
            goto LABEL_45;
          }
        }
        LODWORD(v19) = *(_DWORD *)(a2 + 20);
      }
    }
    if (v17 == v18) {
      unsigned int v22 = v19;
    }
    else {
      unsigned int v22 = *(_DWORD *)(a2 + 16);
    }
    if (v20 == (void *)(v17 + 8 * v22))
    {
      int v69 = sub_1CB896AE8(a1, v16);
      uint64_t v70 = *(void *)(a1 + 8);
      uint64_t v71 = 16;
      if (v70 == *(void *)a1) {
        uint64_t v71 = 20;
      }
      if (v69 != (void *)(v70 + 8 * *(unsigned int *)(a1 + v71)))
      {
        *int v69 = -2;
        ++*(_DWORD *)(a1 + 24);
      }
    }
    uint64_t v23 = (unint64_t *)(i + 1);
    while (v23 != v15)
    {
      unint64_t v24 = *v23++;
      uint64_t v16 = v24;
      if (v24 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        uint64_t i = (uint64_t *)(v23 - 1);
        goto LABEL_17;
      }
    }
  }
}

void llvm::ModuleToPostOrderCGSCCPassAdaptor::run()
{
}

uint64_t sub_1CBF9F324(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = (void *)(a1 + 72);
  uint64_t v5 = *(unsigned int *)(a1 + 80);
  uint64_t v6 = *a2;
  uint64_t v16 = 0;
  uint64_t result = sub_1CBFA5DA4(a1, v6, &v16);
  uint64_t v8 = v16;
  if (!result)
  {
    int v9 = *(_DWORD *)a1 >> 1;
    if (*(_DWORD *)a1) {
      unsigned int v10 = 4;
    }
    else {
      unsigned int v10 = *(_DWORD *)(a1 + 16);
    }
    if (4 * v9 + 4 >= 3 * v10)
    {
      v10 *= 2;
    }
    else if (v10 + ~v9 - *(_DWORD *)(a1 + 4) > v10 >> 3)
    {
LABEL_6:
      *(_DWORD *)a1 += 2;
      if (*v8 != -4096) {
        --*(_DWORD *)(a1 + 4);
      }
      *uint64_t v8 = v6;
      v8[1] = v5;
      uint64_t v11 = *a2;
      unsigned int v12 = *(_DWORD *)(a1 + 80);
      if (v12 >= *(_DWORD *)(a1 + 84)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v13 = (uint64_t *)(*v4 + 8 * v12);
LABEL_10:
      *uint64_t v13 = v11;
      ++*(_DWORD *)(a1 + 80);
      return result;
    }
    sub_1CBFA5E50(a1, v10);
    uint64_t v16 = 0;
    uint64_t result = sub_1CBFA5DA4(a1, v6, &v16);
    uint64_t v8 = v16;
    goto LABEL_6;
  }
  uint64_t v14 = v16[1];
  uint64_t v15 = *(unsigned int *)(a1 + 80);
  if (v14 != v15 - 1)
  {
    *(void *)(*(void *)(a1 + 72) + 8 * v14) = 0;
    v8[1] = v15;
    uint64_t v11 = *a2;
    if (v15 >= *(_DWORD *)(a1 + 84)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v13 = (uint64_t *)(*v4 + 8 * v15);
    goto LABEL_10;
  }
  return result;
}

BOOL sub_1CBF9F4B4(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = (void *)(a1 + 72);
  uint64_t v5 = *(unsigned int *)(a1 + 80);
  uint64_t v14 = *a2;
  uint64_t v15 = v5;
  sub_1CBFA60E4(a1, &v14, &v15, (uint64_t)&v16);
  int v6 = v17;
  if (v17)
  {
    uint64_t v7 = *a2;
    unsigned int v8 = *(_DWORD *)(a1 + 80);
    if (v8 >= *(_DWORD *)(a1 + 84)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    int v9 = (void *)(*v4 + 8 * v8);
  }
  else
  {
    uint64_t v11 = v16;
    uint64_t v12 = *(void *)(v16 + 8);
    uint64_t v13 = *(unsigned int *)(a1 + 80);
    if (v12 == v13 - 1) {
      return v6 != 0;
    }
    *(void *)(*(void *)(a1 + 72) + 8 * v12) = 0;
    *(void *)(v11 + 8) = v13;
    uint64_t v7 = *a2;
    if (v13 >= *(_DWORD *)(a1 + 84)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    int v9 = (void *)(*v4 + 8 * v13);
  }
  *int v9 = v7;
  ++*(_DWORD *)(a1 + 80);
  return v6 != 0;
}

void llvm::DevirtSCCRepeatedPass::run(uint64_t a1@<X8>)
{
  *(void *)(a1 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
  *(void *)a1 = a1 + 32;
  *(void *)(a1 + 8) = a1 + 32;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v2 = a1 + 80;
  *(void *)(a1 + 48) = v2;
  *(void *)(a1 + 56) = v2;
  *(void *)(a1 + 64) = 2;
  *(_DWORD *)(a1 + 72) = 0;
  *(void *)(a1 + 16) = 0x100000002;
  llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>::getResultImpl();
}

int *sub_1CBF9FE18(int *result)
{
  int v1 = *result;
  if (*result > 1 || result[1])
  {
    if (v1)
    {
      uint64_t v4 = result + 2;
      uint64_t v5 = result + 66;
    }
    else
    {
      uint64_t v3 = result[4];
      if (((2 * v1) & 0xFFFFFFFC) < v3 && v3 >= 0x41)
      {
        uint64_t v12 = result;
        sub_1CD46EB34(result);
        uint64_t result = v12;
        goto LABEL_3;
      }
      if (!v3)
      {
        int v11 = 0;
LABEL_22:
        void *result = v11;
        result[1] = 0;
        goto LABEL_3;
      }
      uint64_t v4 = (void *)*((void *)result + 1);
      uint64_t v5 = &v4[2 * v3];
    }
    do
    {
      *uint64_t v4 = -4096;
      v4 += 2;
    }
    while (v4 != v5);
    int v11 = *result & 1;
    goto LABEL_22;
  }
LABEL_3:
  uint64_t v2 = result[68];
  if (v2)
  {
    uint64_t v6 = *((void *)result + 33);
    uint64_t v7 = 32 * v2;
    do
    {
      unsigned int v8 = result;
      uint64_t v9 = *(void *)(v6 + v7 - 8);
      if (v9 != -8192 && v9 != -4096 && v9 != 0) {
        llvm::ValueHandleBase::RemoveFromUseList((void *)(v6 + v7 - 24));
      }
      v7 -= 32;
      uint64_t result = v8;
    }
    while (v7);
  }
  result[68] = 0;
  return result;
}

uint64_t sub_1CBF9FF14(uint64_t result, uint64_t *a2, unsigned int a3, uint64_t a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = result;
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  *(void *)uint64_t result = 1;
  for (uint64_t i = 8; i != 72; i += 16)
    *(void *)(result + i) = -4096;
  if (a3)
  {
    uint64_t v7 = &a2[a3];
    while (1)
    {
      uint64_t v8 = *v4;
      uint64_t v9 = *(void *)(*v4 + 8);
      uint64_t v68 = 0;
      uint64_t result = sub_1CBFA3B90(v5, v9, &v68);
      uint64_t v10 = v68;
      if (result) {
        goto LABEL_14;
      }
      uint64_t v65 = v68;
      int v11 = *(_DWORD *)v5;
      int v12 = *(_DWORD *)v5 >> 1;
      int v13 = *(_DWORD *)v5 & 1;
      uint64_t v14 = *(unsigned int *)(v5 + 16);
      unsigned int v15 = v13 ? 4 : *(_DWORD *)(v5 + 16);
      if (4 * v12 + 4 >= 3 * v15) {
        break;
      }
      if (v15 + ~v12 - *(_DWORD *)(v5 + 4) <= v15 >> 3) {
        goto LABEL_82;
      }
LABEL_11:
      *(_DWORD *)uint64_t v5 = ((v11 & 0xFFFFFFFE) + 2) | v13;
      if (*(void *)v10 != -4096) {
        --*(_DWORD *)(v5 + 4);
      }
      *(void *)uint64_t v10 = v9;
      *(void *)(v10 + 8) = 0;
LABEL_14:
      uint64_t v16 = *(void *)(v8 + 8);
      uint64_t v17 = v16 + 72;
      for (uint64_t j = *(void *)(v16 + 80); j != v17; uint64_t j = *(void *)(j + 8))
      {
        uint64_t v19 = j - 24;
        if (!j) {
          uint64_t v19 = 0;
        }
        uint64_t v20 = *(void *)(v19 + 48);
        if (v20 != v19 + 40)
        {
          while (1)
          {
            if (v20) {
              uint64_t v46 = v20 - 24;
            }
            else {
              uint64_t v46 = 0;
            }
            unsigned int v47 = *(unsigned __int8 *)(v46 + 16) - 33;
            BOOL v48 = v47 > 0x33;
            uint64_t v49 = (1 << v47) & 0x8000000000041;
            if (!v48 && v49 != 0)
            {
              uint64_t v51 = *(void *)(v20 - 56);
              if (v51 && !*(unsigned char *)(v51 + 16) && *(void *)(v51 + 24) == *(void *)(v20 + 48))
              {
                ++*(_DWORD *)(v10 + 8);
              }
              else
              {
                ++*(_DWORD *)(v10 + 12);
                uint64_t v65 = 6;
                unsigned int v66 = 0;
                uint64_t v67 = (int32x2_t ****)(v20 - 24);
                if (v20 == -8168 || v20 == -4072)
                {
                  uint64_t v21 = (int32x2_t ****)(v20 - 24);
                }
                else
                {
                  uint64_t v21 = (int32x2_t ****)(v20 - 24);
                  if (v20 != 24)
                  {
                    llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v65);
                    uint64_t v21 = v67;
                  }
                }
                uint64_t v69 = v20 - 24;
                uint64_t v70 = 6;
                uint64_t v71 = 0;
                long long v72 = v21;
                if (v21 != (int32x2_t ****)-8192 && v21 != (int32x2_t ****)-4096)
                {
                  if (v21)
                  {
                    unint64_t v22 = v65 & 0xFFFFFFFFFFFFFFF8;
                    uint64_t v71 = *(unint64_t **)(v65 & 0xFFFFFFFFFFFFFFF8);
                    *(void *)unint64_t v22 = &v70;
                    uint64_t v70 = v22 | 6;
                    if (v71) {
                      *uint64_t v71 = *v71 & 7 | (unint64_t)&v71;
                    }
                  }
                }
                uint64_t result = sub_1CD46DA04(a4, &v69, &v70);
                if (v72 != (int32x2_t ****)-8192 && v72 != (int32x2_t ****)-4096 && v72)
                {
                  unint64_t v23 = v70 & 0xFFFFFFFFFFFFFFF8;
                  *(void *)(v70 & 0xFFFFFFFFFFFFFFF8) = v71;
                  if (v71)
                  {
                    *uint64_t v71 = *v71 & 7 | v23;
                  }
                  else
                  {
                    unint64_t v24 = v72;
                    uint64_t v25 = ***v72;
                    unint64_t v26 = (unint64_t)v25[303];
                    if (v26 <= v23)
                    {
                      uint64_t v27 = v25[305].u32[0];
                      if (v26 + 16 * v27 > v23)
                      {
                        unsigned int v28 = v27 - 1;
                        LODWORD(v29) = v28 & ((v72 >> 4) ^ (v72 >> 9));
                        int v30 = (int32x2_t *****)(v26 + 16 * v29);
                        BOOL v31 = *v30;
                        if (v72 == *v30)
                        {
LABEL_41:
                          unsigned int *v30 = (int32x2_t ****)-8192;
                          v25[304] = vadd_s32(v25[304], (int32x2_t)0x1FFFFFFFFLL);
                          unint64_t v24 = v72;
                        }
                        else
                        {
                          int v32 = 1;
                          while (v31 != (int32x2_t ****)-4096)
                          {
                            int v33 = v29 + v32++;
                            uint64_t v29 = v33 & v28;
                            BOOL v31 = *(int32x2_t *****)(v26 + 16 * v29);
                            if (v72 == v31)
                            {
                              int v30 = (int32x2_t *****)(v26 + 16 * v29);
                              goto LABEL_41;
                            }
                          }
                        }
                        *((unsigned char *)v24 + 17) &= ~1u;
                      }
                    }
                  }
                }
                if (v67 != (int32x2_t ****)-8192 && v67 != (int32x2_t ****)-4096 && v67 != 0)
                {
                  unint64_t v35 = v65 & 0xFFFFFFFFFFFFFFF8;
                  *(void *)(v65 & 0xFFFFFFFFFFFFFFF8) = v66;
                  if (v66)
                  {
                    *unsigned int v66 = *v66 & 7 | v35;
                  }
                  else
                  {
                    uint64_t v36 = v67;
                    uint64_t v37 = ***v67;
                    unint64_t v38 = (unint64_t)v37[303];
                    if (v38 <= v35)
                    {
                      uint64_t v39 = v37[305].u32[0];
                      if (v38 + 16 * v39 > v35)
                      {
                        unsigned int v40 = v39 - 1;
                        LODWORD(v41) = v40 & ((v67 >> 4) ^ (v67 >> 9));
                        uint64_t v42 = (int32x2_t *****)(v38 + 16 * v41);
                        uint64_t v43 = *v42;
                        if (v67 == *v42)
                        {
LABEL_57:
                          llvm::raw_ostream *v42 = (int32x2_t ****)-8192;
                          v37[304] = vadd_s32(v37[304], (int32x2_t)0x1FFFFFFFFLL);
                          uint64_t v36 = v67;
                        }
                        else
                        {
                          int v44 = 1;
                          while (v43 != (int32x2_t ****)-4096)
                          {
                            int v45 = v41 + v44++;
                            uint64_t v41 = v45 & v40;
                            uint64_t v43 = *(int32x2_t *****)(v38 + 16 * v41);
                            if (v67 == v43)
                            {
                              uint64_t v42 = (int32x2_t *****)(v38 + 16 * v41);
                              goto LABEL_57;
                            }
                          }
                        }
                        *((unsigned char *)v36 + 17) &= ~1u;
                      }
                    }
                  }
                }
              }
            }
            uint64_t v20 = *(void *)(v20 + 8);
            uint64_t v52 = j - 24;
            if (!j) {
              uint64_t v52 = 0;
            }
            if (v20 == v52 + 40) {
              break;
            }
LABEL_78:
            if (j == v17) {
              goto LABEL_79;
            }
          }
          while (1)
          {
            uint64_t j = *(void *)(j + 8);
            if (j == v17) {
              goto LABEL_79;
            }
            uint64_t v53 = j - 24;
            if (!j) {
              uint64_t v53 = 0;
            }
            uint64_t v20 = *(void *)(v53 + 48);
            if (v20 != v53 + 40) {
              goto LABEL_78;
            }
          }
        }
      }
LABEL_79:
      if (++v4 == v7) {
        return result;
      }
    }
    v15 *= 2;
LABEL_82:
    if (v15 >= 5)
    {
      unint64_t v54 = (v15 - 1) | ((unint64_t)(v15 - 1) >> 1);
      unint64_t v55 = v54 | (v54 >> 2) | ((v54 | (v54 >> 2)) >> 4);
      int v56 = ((v55 | (v55 >> 8)) >> 16) | v55 | (v55 >> 8);
      if ((v56 + 1) > 0x40) {
        unsigned int v15 = v56 + 1;
      }
      else {
        unsigned int v15 = 64;
      }
    }
    if (v13)
    {
      uint64_t v58 = 0;
      int v59 = &v69;
      do
      {
        uint64_t v60 = *(void *)(v5 + v58 + 8);
        if ((v60 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          uint64_t v61 = *(void *)(v5 + v58 + 16);
          uint64_t *v59 = v60;
          v59[1] = v61;
          v59 += 2;
        }
        v58 += 16;
      }
      while (v58 != 64);
      if (v15 > 4)
      {
        *(_DWORD *)v5 &= ~1u;
        uint64_t v62 = v15;
        *(void *)(v5 + 8) = operator new(16 * v15, (std::align_val_t)8uLL);
        *(void *)(v5 + 16) = v62;
      }
      sub_1CBFA3C3C(v5, &v69, v59);
    }
    else
    {
      unsigned int v57 = *(uint64_t **)(v5 + 8);
      if (v15 > 4)
      {
        uint64_t v63 = v15;
        *(void *)(v5 + 8) = operator new(16 * v15, (std::align_val_t)8uLL);
        *(void *)(v5 + 16) = v63;
      }
      else
      {
        *(_DWORD *)uint64_t v5 = v11 | 1;
      }
      sub_1CBFA3C3C(v5, v57, &v57[2 * v14]);
      MEMORY[0x1D25D9CD0](v57, 8);
    }
    uint64_t result = sub_1CBFA3B90(v5, v9, &v65);
    int v11 = *(_DWORD *)v5;
    uint64_t v10 = v65;
    int v13 = *(_DWORD *)v5 & 1;
    goto LABEL_11;
  }
  return result;
}

void llvm::CGSCCToFunctionPassAdaptor::run()
{
}

uint64_t sub_1CBFA0B7C(uint64_t *a1, uint64_t a2)
{
  if (*a1)
  {
    char v4 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
    uint64_t v5 = *a1;
    if ((v4 & 1) == 0 && *(_DWORD *)(v5 + 8))
    {
      (*(void (**)(uint64_t))(*(void *)a2 + 32))(a2);
      operator new();
    }
    if (*(_DWORD *)(v5 + 296))
    {
      (*(void (**)(uint64_t))(*(void *)a2 + 32))(a2);
      operator new();
    }
  }
  return 1;
}

uint64_t sub_1CBFA0F4C(uint64_t result, uint64_t a2)
{
  if (*(void *)result)
  {
    if (*(_DWORD *)(*(void *)result + 440))
    {
      (*(void (**)(uint64_t))(*(void *)a2 + 32))(a2);
      uint64_t v2 = 0;
      operator new();
    }
  }
  return result;
}

BOOL sub_1CBFA10B0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 16)) {
    return 0;
  }
  int v1 = *(void ****)a1;
  uint64_t v3 = **(void ****)a1;
  uint64_t v2 = *(void ***)(*(void *)a1 + 8);
  if (v2 == v3)
  {
    char v4 = (unsigned int *)v1 + 5;
    uint64_t v5 = *((unsigned int *)v1 + 5);
    if (!v5)
    {
      uint64_t v10 = (unsigned int *)(v1 + 2);
      uint64_t v3 = *(void ***)(*(void *)a1 + 8);
      int v12 = v3;
      goto LABEL_17;
    }
    uint64_t v6 = 0;
    uint64_t v7 = &v2[v5];
    while (v2[v6] != &llvm::PreservedAnalyses::AllAnalysesKey)
    {
      if (v5 == ++v6) {
        goto LABEL_7;
      }
    }
    uint64_t v7 = &v2[v6];
LABEL_7:
    uint64_t v8 = *(void ***)(*(void *)a1 + 8);
  }
  else
  {
    uint64_t v17 = *((unsigned int *)v1 + 4);
    int v18 = v17 - 1;
    unsigned int v19 = (v17 - 1) & ((&llvm::PreservedAnalyses::AllAnalysesKey >> 4) ^ (&llvm::PreservedAnalyses::AllAnalysesKey >> 9));
    uint64_t v7 = &v2[v19];
    uint64_t v20 = *v7;
    if (*v7 == (void *)-1)
    {
      uint64_t v21 = 0;
LABEL_47:
      if (v21) {
        uint64_t v7 = v21;
      }
      if (*v7 != &llvm::PreservedAnalyses::AllAnalysesKey) {
        uint64_t v7 = &v2[v17];
      }
    }
    else
    {
      uint64_t v21 = 0;
      int v22 = 1;
      while (v20 != &llvm::PreservedAnalyses::AllAnalysesKey)
      {
        if (v21) {
          BOOL v23 = 0;
        }
        else {
          BOOL v23 = v20 == (void *)-2;
        }
        if (v23) {
          uint64_t v21 = v7;
        }
        unsigned int v24 = v19 + v22++;
        unsigned int v19 = v24 & v18;
        uint64_t v7 = &v2[v24 & v18];
        uint64_t v20 = *v7;
        if (*v7 == (void *)-1) {
          goto LABEL_47;
        }
      }
    }
    uint64_t v8 = v3;
  }
  BOOL v23 = v2 == v8;
  uint64_t v9 = 16;
  if (v23) {
    uint64_t v9 = 20;
  }
  if (v7 != &v2[*(unsigned int *)((char *)v1 + v9)]) {
    return 1;
  }
  char v4 = (unsigned int *)v1 + 5;
  uint64_t v10 = (unsigned int *)(v1 + 2);
  if (v2 == v3)
  {
    uint64_t v11 = *v4;
    int v12 = &v2[v11];
    if (v11)
    {
      unint64_t v13 = 0;
      uint64_t v14 = 8 * v11;
      while (v2[v13 / 8] != &llvm::AllAnalysesOn<llvm::Module>::SetKey)
      {
        v13 += 8;
        if (v14 == v13) {
          goto LABEL_16;
        }
      }
      int v12 = &v2[v13 / 8];
    }
LABEL_16:
    uint64_t v3 = v2;
  }
  else
  {
    uint64_t v25 = *v10;
    int v26 = v25 - 1;
    unsigned int v27 = (v25 - 1) & ((&llvm::AllAnalysesOn<llvm::Module>::SetKey >> 4) ^ (&llvm::AllAnalysesOn<llvm::Module>::SetKey >> 9));
    int v12 = &v2[v27];
    unsigned int v28 = *v12;
    if (*v12 == (void *)-1)
    {
      uint64_t v29 = 0;
LABEL_53:
      if (v29) {
        int v12 = v29;
      }
      if (*v12 != &llvm::AllAnalysesOn<llvm::Module>::SetKey) {
        int v12 = &v2[v25];
      }
    }
    else
    {
      uint64_t v29 = 0;
      int v30 = 1;
      while (v28 != &llvm::AllAnalysesOn<llvm::Module>::SetKey)
      {
        if (v29) {
          BOOL v31 = 0;
        }
        else {
          BOOL v31 = v28 == (void *)-2;
        }
        if (v31) {
          uint64_t v29 = v12;
        }
        unsigned int v32 = v27 + v30++;
        unsigned int v27 = v32 & v26;
        int v12 = &v2[v32 & v26];
        unsigned int v28 = *v12;
        if (*v12 == (void *)-1) {
          goto LABEL_53;
        }
      }
    }
  }
LABEL_17:
  if (v2 == v3) {
    unsigned int v15 = v4;
  }
  else {
    unsigned int v15 = v10;
  }
  return v12 != &v2[*v15];
}

uint64_t llvm::InnerAnalysisManagerProxy<llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>,llvm::Module>::Result::invalidate(llvm::LazyCallGraph **a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  if (*(_DWORD *)(a3 + 68) != *(_DWORD *)(a3 + 72)
    || ((uint64_t v8 = sub_1CB896AE8(a3, (uint64_t)&llvm::PreservedAnalyses::AllAnalysesKey),
         uint64_t v9 = *(void *)(a3 + 8),
         v9 != *(void *)a3)
      ? (uint64_t v10 = (unsigned int *)(a3 + 16))
      : (uint64_t v10 = (unsigned int *)(a3 + 20)),
        v8 == (void *)(v9 + 8 * *v10)))
  {
    v20[0] = (void **)a3;
    v20[1] = (void **)&llvm::InnerAnalysisManagerProxy<llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>,llvm::Module>::Key;
    uint64_t v11 = sub_1CB896AE8(a3 + 48, (uint64_t)&llvm::InnerAnalysisManagerProxy<llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>,llvm::Module>::Key);
    uint64_t v12 = *(void *)(a3 + 56);
    if (v12 == *(void *)(a3 + 48)) {
      unint64_t v13 = (unsigned int *)(a3 + 68);
    }
    else {
      unint64_t v13 = (unsigned int *)(a3 + 64);
    }
    BOOL v21 = v11 != (void *)(v12 + 8 * *v13);
    if (!sub_1CBF75724(v20) && !sub_1CBFA10B0((uint64_t)v20)
      || (sub_1CD46EC0C(a4, a2, a3) & 1) != 0
      || sub_1CD46ED2C(a4, a2, a3))
    {
      uint64_t v17 = *a1;
      sub_1CBF9BC38((_DWORD *)*a1 + 12);
      sub_1CBF9BC8C((_DWORD *)v17 + 6);
      return 1;
    }
    sub_1CBFA534C((uint64_t *)a3, (uint64_t)&llvm::AllAnalysesOn<llvm::LazyCallGraph::SCC>::SetKey);
    llvm::LazyCallGraph::buildRefSCCs(a1[1]);
    uint64_t v14 = (uint64_t)a1[1];
    sub_1CBFA3A10(v14);
    uint64_t v18 = v14;
    uint64_t v19 = v15;
    if (v15)
    {
      do
      {
        if (*(_DWORD *)(v15 + 16)) {
          llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>::getCachedResultImpl();
        }
        do
        {
          sub_1CBFA3A74(&v18);
          uint64_t v15 = v19;
        }
        while (v19 && !*(_DWORD *)(v19 + 16));
      }
      while (v19 || v18 != v14);
    }
  }
  return 0;
}

int *sub_1CBFA167C(int *a1)
{
  int v2 = *a1;
  if (*a1 > 1)
  {
    if (v2)
    {
      uint64_t result = a1 + 2;
      uint64_t v7 = a1 + 10;
LABEL_11:
      while ((*(void *)result | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        result += 4;
        if (result == v7) {
          return v7;
        }
      }
    }
    else
    {
      uint64_t result = (int *)*((void *)a1 + 1);
      uint64_t v6 = a1[4];
      if (v6)
      {
        uint64_t v7 = &result[4 * v6];
        goto LABEL_11;
      }
    }
  }
  else
  {
    if (v2)
    {
      uint64_t v3 = a1 + 2;
      uint64_t v4 = 2;
    }
    else
    {
      uint64_t v3 = (int *)*((void *)a1 + 1);
      uint64_t v4 = a1[4];
    }
    return &v3[4 * v4];
  }
  return result;
}

void sub_1CBFA16F4(uint64_t *a1, uint64_t a2)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  if (v4 == *a1)
  {
    uint64_t v6 = *((unsigned int *)a1 + 5);
    uint64_t v7 = (void *)(v4 + 8 * v6);
    if (v6)
    {
      uint64_t v8 = 0;
      uint64_t v9 = 8 * v6;
      while (*(void *)(v4 + v8) != a2)
      {
        v8 += 8;
        if (v9 == v8) {
          goto LABEL_6;
        }
      }
      uint64_t v7 = (void *)(v4 + v8);
    }
LABEL_6:
    uint64_t v5 = a1[1];
  }
  else
  {
    uint64_t v27 = *((unsigned int *)a1 + 4);
    int v28 = v27 - 1;
    unsigned int v29 = (v27 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v7 = (void *)(v4 + 8 * v29);
    uint64_t v30 = *v7;
    if (*v7 == -1)
    {
      BOOL v31 = 0;
LABEL_57:
      if (v31) {
        uint64_t v7 = v31;
      }
      if (*v7 != a2) {
        uint64_t v7 = (void *)(v4 + 8 * v27);
      }
    }
    else
    {
      BOOL v31 = 0;
      int v32 = 1;
      while (v30 != a2)
      {
        if (v31) {
          BOOL v33 = 0;
        }
        else {
          BOOL v33 = v30 == -2;
        }
        if (v33) {
          BOOL v31 = v7;
        }
        unsigned int v34 = v29 + v32++;
        unsigned int v29 = v34 & v28;
        uint64_t v7 = (void *)(v4 + 8 * (v34 & v28));
        uint64_t v30 = *v7;
        if (*v7 == -1) {
          goto LABEL_57;
        }
      }
    }
  }
  BOOL v25 = v4 == v5;
  uint64_t v10 = 16;
  if (v25) {
    uint64_t v10 = 20;
  }
  if (v7 != (void *)(v4 + 8 * *(unsigned int *)((char *)a1 + v10)))
  {
    *uint64_t v7 = -2;
    ++*((_DWORD *)a1 + 6);
  }
  uint64_t v13 = a1[6];
  uint64_t v12 = a1[7];
  uint64_t v11 = (llvm::SmallPtrSetImplBase *)(a1 + 6);
  uint64_t v14 = *((unsigned int *)a1 + 17);
  if (v12 != v13)
  {
    unsigned int v18 = *((_DWORD *)a1 + 16);
    goto LABEL_23;
  }
  if (!v14)
  {
LABEL_19:
    unsigned int v18 = *((_DWORD *)a1 + 16);
    if (v14 < v18)
    {
      *((_DWORD *)a1 + 17) = v14 + 1;
      *(void *)(v12 + 8 * v14) = a2;
      return;
    }
LABEL_23:
    if (3 * v18 <= 4 * ((int)v14 - *((_DWORD *)a1 + 18)))
    {
      if (v18 >= 0x40) {
        v18 *= 2;
      }
      else {
        unsigned int v18 = 128;
      }
    }
    else if (v18 - v14 >= v18 >> 3)
    {
      goto LABEL_25;
    }
    llvm::SmallPtrSetImplBase::Grow(v11, v18);
    unsigned int v18 = *((_DWORD *)a1 + 16);
    uint64_t v12 = a1[7];
LABEL_25:
    unsigned int v19 = v18 - 1;
    unsigned int v20 = (v18 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    BOOL v21 = (void *)(v12 + 8 * v20);
    uint64_t v22 = *v21;
    if (*v21 == -1)
    {
      BOOL v23 = 0;
LABEL_49:
      if (v23) {
        unint64_t v35 = v23;
      }
      else {
        unint64_t v35 = v21;
      }
      if (*v35 != a2)
      {
        if (*v35 == -2) {
          --*((_DWORD *)a1 + 18);
        }
        else {
          ++*((_DWORD *)a1 + 17);
        }
        void *v35 = a2;
      }
    }
    else
    {
      BOOL v23 = 0;
      int v24 = 1;
      while (v22 != a2)
      {
        if (v23) {
          BOOL v25 = 0;
        }
        else {
          BOOL v25 = v22 == -2;
        }
        if (v25) {
          BOOL v23 = v21;
        }
        unsigned int v26 = v20 + v24++;
        unsigned int v20 = v26 & v19;
        BOOL v21 = (void *)(v12 + 8 * (v26 & v19));
        uint64_t v22 = *v21;
        if (*v21 == -1) {
          goto LABEL_49;
        }
      }
    }
    return;
  }
  uint64_t v15 = 0;
  uint64_t v16 = 8 * v14;
  uint64_t v17 = (void *)a1[7];
  while (*v17 != a2)
  {
    if (*v17 == -2) {
      uint64_t v15 = v17;
    }
    ++v17;
    v16 -= 8;
    if (!v16)
    {
      if (!v15) {
        goto LABEL_19;
      }
      void *v15 = a2;
      --*((_DWORD *)a1 + 18);
      return;
    }
  }
}

void llvm::FunctionAnalysisManagerCGSCCProxy::run()
{
}

uint64_t llvm::FunctionAnalysisManagerCGSCCProxy::Result::invalidate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(unsigned int *)(a3 + 68);
  if (v5 == *(_DWORD *)(a3 + 72))
  {
    unsigned int v20 = *(void **)a3;
    unsigned int v19 = *(void **)(a3 + 8);
    if (v19 == *(void **)a3)
    {
      uint64_t v21 = *(unsigned int *)(a3 + 20);
      uint64_t v22 = (void **)&v19[v21];
      if (v21)
      {
        uint64_t v23 = 0;
        while ((_UNKNOWN *)v19[v23] != &llvm::PreservedAnalyses::AllAnalysesKey)
        {
          if (v21 == ++v23) {
            goto LABEL_30;
          }
        }
        uint64_t v22 = (void **)&v19[v23];
      }
LABEL_30:
      unsigned int v20 = *(void **)(a3 + 8);
    }
    else
    {
      uint64_t v25 = *(unsigned int *)(a3 + 16);
      int v26 = v25 - 1;
      unsigned int v27 = (v25 - 1) & ((&llvm::PreservedAnalyses::AllAnalysesKey >> 4) ^ (&llvm::PreservedAnalyses::AllAnalysesKey >> 9));
      uint64_t v22 = (void **)&v19[v27];
      int v28 = *v22;
      if (*v22 == (void *)-1)
      {
        unsigned int v29 = 0;
LABEL_56:
        if (v29) {
          uint64_t v22 = v29;
        }
        if (*v22 != &llvm::PreservedAnalyses::AllAnalysesKey)
        {
          LODWORD(v21) = *(_DWORD *)(a3 + 20);
          uint64_t v22 = (void **)&v19[v25];
          goto LABEL_31;
        }
      }
      else
      {
        unsigned int v29 = 0;
        int v30 = 1;
        while (v28 != &llvm::PreservedAnalyses::AllAnalysesKey)
        {
          if (v29) {
            BOOL v31 = 0;
          }
          else {
            BOOL v31 = v28 == (void *)-2;
          }
          if (v31) {
            unsigned int v29 = v22;
          }
          unsigned int v32 = v27 + v30++;
          unsigned int v27 = v32 & v26;
          uint64_t v22 = (void **)&v19[v32 & v26];
          int v28 = *v22;
          if (*v22 == (void *)-1) {
            goto LABEL_56;
          }
        }
      }
      LODWORD(v21) = *(_DWORD *)(a3 + 20);
    }
LABEL_31:
    if (v19 == v20) {
      int v24 = v21;
    }
    else {
      int v24 = *(_DWORD *)(a3 + 16);
    }
    if (v22 != &v19[v24]) {
      return 0;
    }
  }
  v33[0] = (void **)a3;
  v33[1] = (void **)&llvm::FunctionAnalysisManagerCGSCCProxy::Key;
  uint64_t v7 = *(void *)(a3 + 48);
  uint64_t v6 = *(void *)(a3 + 56);
  if (v6 == v7)
  {
    uint64_t v8 = (void **)(v6 + 8 * v5);
    if (v5)
    {
      uint64_t v9 = 0;
      while (*(_UNKNOWN **)(v6 + v9) != &llvm::FunctionAnalysisManagerCGSCCProxy::Key)
      {
        v9 += 8;
        if (8 * v5 == v9) {
          goto LABEL_7;
        }
      }
      uint64_t v8 = (void **)(v6 + v9);
    }
LABEL_7:
    uint64_t v7 = *(void *)(a3 + 56);
  }
  else
  {
    uint64_t v11 = *(unsigned int *)(a3 + 64);
    int v12 = v11 - 1;
    unsigned int v13 = (v11 - 1) & ((&llvm::FunctionAnalysisManagerCGSCCProxy::Key >> 4) ^ (&llvm::FunctionAnalysisManagerCGSCCProxy::Key >> 9));
    uint64_t v8 = (void **)(v6 + 8 * v13);
    uint64_t v14 = *v8;
    if (*v8 == (void *)-1)
    {
      uint64_t v15 = 0;
LABEL_49:
      if (v15) {
        uint64_t v8 = v15;
      }
      if (*v8 != &llvm::FunctionAnalysisManagerCGSCCProxy::Key) {
        uint64_t v8 = (void **)(v6 + 8 * v11);
      }
    }
    else
    {
      uint64_t v15 = 0;
      int v16 = 1;
      while (v14 != &llvm::FunctionAnalysisManagerCGSCCProxy::Key)
      {
        if (v15) {
          BOOL v17 = 0;
        }
        else {
          BOOL v17 = v14 == (void *)-2;
        }
        if (v17) {
          uint64_t v15 = v8;
        }
        unsigned int v18 = v13 + v16++;
        unsigned int v13 = v18 & v12;
        uint64_t v8 = (void **)(v6 + 8 * (v18 & v12));
        uint64_t v14 = *v8;
        if (*v8 == (void *)-1) {
          goto LABEL_49;
        }
      }
    }
  }
  if (v6 != v7) {
    LODWORD(v5) = *(_DWORD *)(a3 + 64);
  }
  BOOL v34 = v8 != (void **)(v6 + 8 * v5);
  if (sub_1CBF75724(v33) || sub_1CD46D7A4((uint64_t)v33))
  {
    sub_1CBFA534C((uint64_t *)a3, (uint64_t)&llvm::AllAnalysesOn<llvm::Function>::SetKey);
    if (*(_DWORD *)(a2 + 16)) {
      llvm::AnalysisManager<llvm::Function>::getCachedResultImpl();
    }
  }
  else if (*(_DWORD *)(a2 + 16))
  {
    llvm::AnalysisManager<llvm::Function>::invalidate();
  }
  return 0;
}

llvm::LazyCallGraph::RefSCC **llvm::updateCGAndAnalysisManagerForCGSCCPass(uint64_t *a1, llvm::LazyCallGraph::RefSCC **a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = (llvm::LazyCallGraph::Node *)a3;
  uint64_t v6 = (uint64_t)a1;
  v349[16] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *a2;
  v314 = a2;
  uint64_t v8 = *(void *)(a3 + 8);
  uint64_t v347 = v349;
  uint64_t v348 = 0x1000000000;
  long long v309 = v313;
  uint64_t v310 = v313;
  uint64_t v311 = 16;
  int v312 = 0;
  int v304 = v308;
  v305 = v308;
  uint64_t v306 = 16;
  int v307 = 0;
  uint64_t v341 = 1;
  int64x2_t v342 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  int64x2_t v343 = v342;
  v344 = v346;
  uint64_t v345 = 0x400000000;
  uint64_t v335 = 1;
  int64x2_t v336 = v342;
  int64x2_t v337 = v342;
  uint64_t v338 = v340;
  uint64_t v339 = 0x400000000;
  uint64_t v329 = 1;
  int64x2_t v330 = v342;
  int64x2_t v331 = v342;
  v332 = v334;
  uint64_t v333 = 0x400000000;
  uint64_t v323 = 1;
  int64x2_t v324 = v342;
  int64x2_t v325 = v342;
  uint64_t v326 = v328;
  uint64_t v327 = 0x400000000;
  uint64_t v9 = v8 + 72;
  uint64_t v10 = *(void *)(v8 + 80);
  if (v10 == v8 + 72) {
    goto LABEL_316;
  }
  uint64_t v11 = v10 - 24;
  if (!v10) {
    uint64_t v11 = 0;
  }
  uint64_t v12 = *(void *)(v11 + 48);
  if (v12 == v11 + 40)
  {
    uint64_t v13 = *(void *)(v8 + 80);
    do
    {
      uint64_t v13 = *(void *)(v13 + 8);
      if (v13 == v9) {
        goto LABEL_246;
      }
      uint64_t v14 = v13 - 24;
      if (!v13) {
        uint64_t v14 = 0;
      }
      uint64_t v12 = *(void *)(v14 + 48);
    }
    while (v12 == v14 + 40);
    uint64_t v284 = v8;
  }
  else
  {
    uint64_t v284 = v8;
    uint64_t v13 = *(void *)(v8 + 80);
  }
  uint64_t v286 = a5 + 144;
  uint64_t v15 = a1 + 12;
  uint64_t v16 = a3 + 24;
  while (1)
  {
    BOOL v17 = (uint64_t ***)(v12 - 24);
    if (v12) {
      uint64_t v18 = v12 - 24;
    }
    else {
      uint64_t v18 = 0;
    }
    unsigned int v19 = *(unsigned __int8 *)(v18 + 16) - 33;
    BOOL v148 = v19 > 0x33;
    uint64_t v20 = (1 << v19) & 0x8000000000041;
    if (v148 || v20 == 0) {
      goto LABEL_166;
    }
    unsigned int v319 = &v321;
    uint64_t v320 = 0x100000000;
    uint64_t v22 = *(void *)(v12 - 56);
    if (v22 && !*(unsigned char *)(v22 + 16) && *(void *)(v22 + 24) == *(void *)(v12 + 48))
    {
      uint64_t v321 = *(void *)(v12 - 56);
      LODWORD(v320) = 1;
      uint64_t v49 = &v322;
      unsigned int v50 = &v321;
      goto LABEL_88;
    }
    if ((*(unsigned char *)(v12 - 1) & 0x20) == 0) {
      goto LABEL_38;
    }
    uint64_t v23 = ***v17;
    uint64_t v292 = v12 - 24;
    int v24 = *(_DWORD *)(v23 + 2496);
    if (!v24)
    {
      uint64_t v113 = 0;
LABEL_202:
      int v28 = sub_1CC609054(v23 + 2480, (uint64_t)&v292, &v292, v113);
      uint64_t v114 = v292;
      v28[4] = 0;
      v28[3] = 0;
      void *v28 = v114;
      v28[1] = v28 + 3;
      void v28[2] = 0x100000000;
      goto LABEL_34;
    }
    uint64_t v25 = *(void *)(v23 + 2480);
    int v26 = v24 - 1;
    unsigned int v27 = v26 & ((v17 >> 4) ^ (v17 >> 9));
    int v28 = (void *)(v25 + 40 * v27);
    unsigned int v29 = (void ***)*v28;
    if ((uint64_t ***)*v28 != v17)
    {
      int v30 = 0;
      int v31 = 1;
      while (v29 != (void ***)-4096)
      {
        if (v30) {
          BOOL v32 = 0;
        }
        else {
          BOOL v32 = v29 == (void ***)-8192;
        }
        if (v32) {
          int v30 = v28;
        }
        unsigned int v33 = v27 + v31++;
        unsigned int v27 = v33 & v26;
        int v28 = (void *)(v25 + 40 * v27);
        unsigned int v29 = (void ***)*v28;
        if ((uint64_t ***)*v28 == v17) {
          goto LABEL_34;
        }
      }
      if (v30) {
        uint64_t v113 = v30;
      }
      else {
        uint64_t v113 = v28;
      }
      goto LABEL_202;
    }
LABEL_34:
    uint64_t v34 = *((unsigned int *)v28 + 4);
    if (v34)
    {
      unint64_t v35 = (void *)(v28[1] + 8);
      uint64_t v36 = 16 * v34;
      while (*((_DWORD *)v35 - 2) != 23)
      {
        v35 += 2;
        v36 -= 16;
        if (!v36) {
          goto LABEL_38;
        }
      }
      uint64_t v44 = *v35;
      if (*v35)
      {
        uint64_t v45 = *(unsigned int *)(v44 + 8);
        if (v45)
        {
          uint64_t v46 = -8 * v45;
          do
          {
            uint64_t v47 = *(void *)(v44 + v46);
            if (v47)
            {
              uint64_t v48 = *(void *)(v47 + 128);
              if (v48)
              {
                if (v320 >= (unint64_t)HIDWORD(v320)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                *((void *)v319 + v320) = v48;
                LODWORD(v320) = v320 + 1;
              }
            }
            v46 += 8;
          }
          while (v46);
        }
        goto LABEL_71;
      }
    }
LABEL_38:
    uint64_t v37 = sub_1CD46E154(v286, v12 - 24);
    if (v37 == *(void *)(a5 + 408) + 32 * *(unsigned int *)(a5 + 416))
    {
      uint64_t v299 = 6;
      unint64_t v300 = 0;
      uint64_t v301 = (llvm::SmallPtrSetImplBase *)(v12 - 24);
      if (v12 == -8168 || v12 == -4072)
      {
        unint64_t v115 = (llvm::SmallPtrSetImplBase *)(v12 - 24);
      }
      else
      {
        unint64_t v115 = (llvm::SmallPtrSetImplBase *)(v12 - 24);
        if (v12 != 24)
        {
          llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v299);
          unint64_t v115 = v301;
        }
      }
      uint64_t v292 = v12 - 24;
      uint64_t v293 = 6;
      uint64_t v294 = 0;
      uint64_t v295 = (int32x2_t ****)v115;
      if (v115 != (llvm::SmallPtrSetImplBase *)-8192 && v115 != (llvm::SmallPtrSetImplBase *)-4096)
      {
        if (v115)
        {
          unint64_t v116 = v299 & 0xFFFFFFFFFFFFFFF8;
          uint64_t v294 = *(void *)(v299 & 0xFFFFFFFFFFFFFFF8);
          *(void *)unint64_t v116 = &v293;
          uint64_t v293 = v116 | 6;
          if (v294) {
            *(void *)uint64_t v294 = *(void *)v294 & 7 | (unint64_t)&v294;
          }
        }
      }
      sub_1CD46DA04(v286, &v292, &v293);
      if (v295 != (int32x2_t ****)-8192 && v295 != (int32x2_t ****)-4096 && v295)
      {
        unint64_t v117 = v293 & 0xFFFFFFFFFFFFFFF8;
        *(void *)(v293 & 0xFFFFFFFFFFFFFFF8) = v294;
        if (v294)
        {
          *(void *)uint64_t v294 = *(void *)v294 & 7 | v117;
        }
        else
        {
          uint64_t v118 = v295;
          BOOL v119 = ***v295;
          unint64_t v120 = (unint64_t)v119[303];
          if (v120 <= v117)
          {
            uint64_t v121 = v119[305].u32[0];
            if (v120 + 16 * v121 > v117)
            {
              unsigned int v122 = v121 - 1;
              LODWORD(v123) = v122 & ((v295 >> 4) ^ (v295 >> 9));
              unint64_t v124 = (int32x2_t *****)(v120 + 16 * v123);
              uint64_t v125 = *v124;
              if (v295 == *v124)
              {
LABEL_224:
                *unint64_t v124 = (int32x2_t ****)-8192;
                v119[304] = vadd_s32(v119[304], (int32x2_t)0x1FFFFFFFFLL);
                uint64_t v118 = v295;
              }
              else
              {
                int v126 = 1;
                while (v125 != (int32x2_t ****)-4096)
                {
                  int v127 = v123 + v126++;
                  uint64_t v123 = v127 & v122;
                  uint64_t v125 = *(int32x2_t *****)(v120 + 16 * v123);
                  if (v295 == v125)
                  {
                    unint64_t v124 = (int32x2_t *****)(v120 + 16 * v123);
                    goto LABEL_224;
                  }
                }
              }
              *((unsigned char *)v118 + 17) &= ~1u;
            }
          }
        }
      }
      if (v301 == (llvm::SmallPtrSetImplBase *)-8192) {
        goto LABEL_71;
      }
      if (v301 == (llvm::SmallPtrSetImplBase *)-4096 || v301 == 0) {
        goto LABEL_71;
      }
      unint64_t v89 = v299 & 0xFFFFFFFFFFFFFFF8;
      *(void *)(v299 & 0xFFFFFFFFFFFFFFF8) = v300;
      int v90 = v300;
      if (v300) {
        goto LABEL_243;
      }
      int v91 = v301;
      BOOL v129 = ***(int32x2_t ****)v301;
      unint64_t v130 = (unint64_t)v129[303];
      if (v130 > v89) {
        goto LABEL_71;
      }
      uint64_t v131 = v129[305].u32[0];
      if (v130 + 16 * v131 <= v89) {
        goto LABEL_71;
      }
      unsigned int v132 = v131 - 1;
      LODWORD(v133) = v132 & ((v301 >> 4) ^ (v301 >> 9));
      long long v134 = (llvm::SmallPtrSetImplBase **)(v130 + 16 * v133);
      long long v135 = *v134;
      if (v301 == *v134)
      {
LABEL_242:
        char *v134 = (llvm::SmallPtrSetImplBase *)-8192;
        v129[304] = vadd_s32(v129[304], (int32x2_t)0x1FFFFFFFFLL);
        int v91 = v301;
      }
      else
      {
        int v136 = 1;
        while (v135 != (llvm::SmallPtrSetImplBase *)-4096)
        {
          int v137 = v133 + v136++;
          uint64_t v133 = v137 & v132;
          long long v135 = *(llvm::SmallPtrSetImplBase **)(v130 + 16 * v133);
          if (v301 == v135)
          {
            long long v134 = (llvm::SmallPtrSetImplBase **)(v130 + 16 * v133);
            goto LABEL_242;
          }
        }
      }
    }
    else
    {
      unint64_t v38 = (void *)v37;
      uint64_t v39 = *(void *)(v37 + 24);
      if (v39) {
        goto LABEL_71;
      }
      uint64_t v292 = 6;
      uint64_t v293 = 0;
      uint64_t v294 = v12 - 24;
      if (v12 == -8168
        || v12 == -4072
        || v12 == 24
        || (llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v292),
            uint64_t v39 = v38[3],
            BOOL v17 = (uint64_t ***)v294,
            v39 != v294))
      {
        if (v39 != -4096 && v39 && v39 != -8192)
        {
          unint64_t v101 = v38[1] & 0xFFFFFFFFFFFFFFF8;
          *(void *)unint64_t v101 = v38[2];
          uint64_t v102 = (unint64_t *)v38[2];
          if (v102)
          {
            unint64_t *v102 = *v102 & 7 | v101;
          }
          else
          {
            uint64_t v103 = v38[3];
            unsigned int v104 = ***(int32x2_t ****)v103;
            unint64_t v105 = (unint64_t)v104[303];
            if (v105 <= v101)
            {
              uint64_t v106 = v104[305].u32[0];
              if (v105 + 16 * v106 > v101)
              {
                unsigned int v107 = v106 - 1;
                LODWORD(v108) = v107 & ((v103 >> 4) ^ (v103 >> 9));
                unsigned int v109 = (uint64_t *)(v105 + 16 * v108);
                uint64_t v110 = *v109;
                if (v103 == *v109)
                {
LABEL_197:
                  *unsigned int v109 = -8192;
                  v104[304] = vadd_s32(v104[304], (int32x2_t)0x1FFFFFFFFLL);
                  uint64_t v103 = v38[3];
                }
                else
                {
                  int v111 = 1;
                  while (v110 != -4096)
                  {
                    int v112 = v108 + v111++;
                    uint64_t v108 = v112 & v107;
                    uint64_t v110 = *(void *)(v105 + 16 * v108);
                    if (v103 == v110)
                    {
                      unsigned int v109 = (uint64_t *)(v105 + 16 * v108);
                      goto LABEL_197;
                    }
                  }
                }
                *(unsigned char *)(v103 + 17) &= ~1u;
              }
            }
          }
          BOOL v17 = (uint64_t ***)v294;
        }
        v38[3] = v17;
        if (v17 != (uint64_t ***)-4096 && v17 != (uint64_t ***)-8192 && v17 != 0)
        {
          uint64_t v41 = v38 + 1;
          unint64_t v42 = v292 & 0xFFFFFFFFFFFFFFF8;
          v38[2] = *(void *)(v292 & 0xFFFFFFFFFFFFFFF8);
          uint64_t v43 = (unint64_t **)(v38 + 2);
          *(void *)unint64_t v42 = v41;
          *(v43 - 1) = (unint64_t *)(v42 | (unint64_t)*(v43 - 1) & 7);
          if (*v43) {
            **uint64_t v43 = **v43 & 7 | (unint64_t)v43;
          }
          BOOL v17 = (uint64_t ***)v294;
        }
      }
      else
      {
        BOOL v17 = (uint64_t ***)v38[3];
      }
      if (v17 == (uint64_t ***)-8192) {
        goto LABEL_71;
      }
      if (v17 == (uint64_t ***)-4096 || v17 == 0) {
        goto LABEL_71;
      }
      unint64_t v89 = v292 & 0xFFFFFFFFFFFFFFF8;
      *(void *)(v292 & 0xFFFFFFFFFFFFFFF8) = v293;
      int v90 = (void *)v293;
      if (v293)
      {
LABEL_243:
        void *v90 = *v90 & 7 | v89;
        goto LABEL_71;
      }
      int v91 = (llvm::SmallPtrSetImplBase *)v294;
      BOOL v92 = ***(int32x2_t ****)v294;
      unint64_t v93 = (unint64_t)v92[303];
      if (v93 > v89) {
        goto LABEL_71;
      }
      uint64_t v94 = v92[305].u32[0];
      if (v93 + 16 * v94 <= v89) {
        goto LABEL_71;
      }
      unsigned int v95 = v94 - 1;
      LODWORD(v96) = v95 & ((v294 >> 4) ^ (v294 >> 9));
      unsigned int v97 = (uint64_t *)(v93 + 16 * v96);
      uint64_t v98 = *v97;
      if (v294 == *v97)
      {
LABEL_185:
        uint64_t *v97 = -8192;
        v92[304] = vadd_s32(v92[304], (int32x2_t)0x1FFFFFFFFLL);
        int v91 = (llvm::SmallPtrSetImplBase *)v294;
      }
      else
      {
        int v99 = 1;
        while (v98 != -4096)
        {
          int v100 = v96 + v99++;
          uint64_t v96 = v100 & v95;
          uint64_t v98 = *(void *)(v93 + 16 * v96);
          if (v294 == v98)
          {
            unsigned int v97 = (uint64_t *)(v93 + 16 * v96);
            goto LABEL_185;
          }
        }
      }
    }
    *((unsigned char *)v91 + 17) &= ~1u;
LABEL_71:
    unsigned int v50 = (uint64_t *)v319;
    if (v320)
    {
      uint64_t v49 = (uint64_t *)((char *)v319 + 8 * v320);
      while (1)
      {
LABEL_88:
        uint64_t v57 = *v50;
        unint64_t v54 = v310;
        uint64_t v58 = HIDWORD(v311);
        if (v310 == v309)
        {
          if (HIDWORD(v311))
          {
            int v59 = 0;
            uint64_t v60 = 8 * HIDWORD(v311);
            uint64_t v61 = (uint64_t *)v310;
            while (*v61 != v57)
            {
              if (*v61 == -2) {
                int v59 = v61;
              }
              ++v61;
              v60 -= 8;
              if (!v60)
              {
                if (v59)
                {
                  uint64_t *v59 = v57;
                  --v312;
                  goto LABEL_120;
                }
                goto LABEL_96;
              }
            }
            goto LABEL_162;
          }
LABEL_96:
          unsigned int v53 = v311;
          if (HIDWORD(v311) < v311)
          {
            ++HIDWORD(v311);
            *(void *)&v310[8 * v58] = v57;
            goto LABEL_120;
          }
        }
        else
        {
          unsigned int v53 = v311;
        }
        if (3 * v53 <= 4 * (HIDWORD(v311) - v312))
        {
          if (v53 >= 0x40) {
            v53 *= 2;
          }
          else {
            unsigned int v53 = 128;
          }
        }
        else if (v53 - HIDWORD(v311) >= v53 >> 3)
        {
          goto LABEL_101;
        }
        llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v309, v53);
        unsigned int v53 = v311;
        unint64_t v54 = v310;
LABEL_101:
        unsigned int v62 = v53 - 1;
        unsigned int v63 = (v53 - 1) & ((v57 >> 4) ^ (v57 >> 9));
        BOOL v64 = &v54[8 * v63];
        uint64_t v65 = *(void *)v64;
        if (*(void *)v64 != -1)
        {
          unsigned int v66 = 0;
          int v67 = 1;
          while (v65 != v57)
          {
            if (v66) {
              BOOL v68 = 0;
            }
            else {
              BOOL v68 = v65 == -2;
            }
            if (v68) {
              unsigned int v66 = (uint64_t *)v64;
            }
            unsigned int v69 = v63 + v67++;
            unsigned int v63 = v69 & v62;
            BOOL v64 = &v54[8 * (v69 & v62)];
            uint64_t v65 = *(void *)v64;
            if (*(void *)v64 == -1) {
              goto LABEL_113;
            }
          }
          goto LABEL_162;
        }
        unsigned int v66 = 0;
LABEL_113:
        if (v66) {
          uint64_t v70 = v66;
        }
        else {
          uint64_t v70 = (uint64_t *)v64;
        }
        if (*v70 == v57) {
          goto LABEL_162;
        }
        if (*v70 == -2) {
          --v312;
        }
        else {
          ++HIDWORD(v311);
        }
        *uint64_t v70 = v57;
LABEL_120:
        if (v57 && *(unsigned char *)(v57 + 16) == 3)
        {
          if ((*(_DWORD *)(v57 + 20) & 0x7FFFFFF) == 0) {
            goto LABEL_162;
          }
        }
        else if (!*(unsigned char *)(v57 + 16) && *(void *)(v57 + 72) == v57 + 72 && (*(unsigned char *)(v57 + 34) & 0x80) == 0)
        {
          goto LABEL_162;
        }
        uint64_t v292 = v57;
        uint64_t v299 = 0;
        sub_1CB915048(v15, &v292, &v299);
        uint64_t v71 = *(void *)(v299 + 8);
        uint64_t v292 = v71;
        uint64_t v72 = sub_1CBFA3D74(v16, v71);
        uint64_t v73 = (unsigned char *)v72;
        int v56 = v305;
        uint64_t v74 = HIDWORD(v306);
        if (v305 != v304)
        {
          unsigned int v55 = v306;
          goto LABEL_139;
        }
        if (!HIDWORD(v306))
        {
LABEL_135:
          unsigned int v55 = v306;
          if (HIDWORD(v306) < v306)
          {
            ++HIDWORD(v306);
            *(void *)&v305[8 * v74] = v71;
            if (!v72) {
              goto LABEL_76;
            }
            goto LABEL_161;
          }
LABEL_139:
          if (3 * v55 <= 4 * (HIDWORD(v306) - v307))
          {
            if (v55 >= 0x40) {
              v55 *= 2;
            }
            else {
              unsigned int v55 = 128;
            }
          }
          else if (v55 - HIDWORD(v306) >= v55 >> 3)
          {
LABEL_141:
            unsigned int v78 = v55 - 1;
            unsigned int v79 = (v55 - 1) & ((v71 >> 4) ^ (v71 >> 9));
            uint64_t v80 = &v56[8 * v79];
            uint64_t v81 = *(void *)v80;
            if (*(void *)v80 == -1)
            {
              uint64_t v82 = 0;
LABEL_153:
              if (v82) {
                uint64_t v86 = v82;
              }
              else {
                uint64_t v86 = (uint64_t *)v80;
              }
              if (*v86 != v71)
              {
                if (*v86 == -2) {
                  --v307;
                }
                else {
                  ++HIDWORD(v306);
                }
                *uint64_t v86 = v71;
              }
            }
            else
            {
              uint64_t v82 = 0;
              int v83 = 1;
              while (v81 != v71)
              {
                if (v82) {
                  BOOL v84 = 0;
                }
                else {
                  BOOL v84 = v81 == -2;
                }
                if (v84) {
                  uint64_t v82 = (uint64_t *)v80;
                }
                unsigned int v85 = v79 + v83++;
                unsigned int v79 = v85 & v78;
                uint64_t v80 = &v56[8 * (v85 & v78)];
                uint64_t v81 = *(void *)v80;
                if (*(void *)v80 == -1) {
                  goto LABEL_153;
                }
              }
            }
            goto LABEL_160;
          }
          llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v304, v55);
          unsigned int v55 = v306;
          int v56 = v305;
          goto LABEL_141;
        }
        unint64_t v75 = 0;
        uint64_t v76 = 8 * HIDWORD(v306);
        unint64_t v77 = (uint64_t *)v305;
        while (*v77 != v71)
        {
          if (*v77 == -2) {
            unint64_t v75 = v77;
          }
          ++v77;
          v76 -= 8;
          if (!v76)
          {
            if (!v75) {
              goto LABEL_135;
            }
            *unint64_t v75 = v71;
            --v307;
            if (v72) {
              goto LABEL_161;
            }
            goto LABEL_76;
          }
        }
LABEL_160:
        if (!v73)
        {
LABEL_76:
          uint64_t v52 = &v329;
          goto LABEL_77;
        }
LABEL_161:
        if ((*v73 & 4) != 0) {
          goto LABEL_162;
        }
        uint64_t v52 = &v341;
LABEL_77:
        sub_1CD46E1B4((uint64_t)v52, &v292);
LABEL_162:
        if (++v50 == v49)
        {
          unsigned int v50 = (uint64_t *)v319;
          break;
        }
      }
    }
    if (v50 != &v321) {
      free(v50);
    }
LABEL_166:
    uint64_t v12 = *(void *)(v12 + 8);
    uint64_t v87 = v13 - 24;
    if (!v13) {
      uint64_t v87 = 0;
    }
    if (v12 == v87 + 40) {
      break;
    }
    uint64_t v5 = (llvm::LazyCallGraph::Node *)a3;
LABEL_175:
    if (v13 == v9) {
      goto LABEL_245;
    }
  }
  uint64_t v5 = (llvm::LazyCallGraph::Node *)a3;
  while (1)
  {
    uint64_t v13 = *(void *)(v13 + 8);
    if (v13 == v9) {
      break;
    }
    uint64_t v88 = v13 - 24;
    if (!v13) {
      uint64_t v88 = 0;
    }
    uint64_t v12 = *(void *)(v88 + 48);
    if (v12 != v88 + 40) {
      goto LABEL_175;
    }
  }
LABEL_245:
  uint64_t v10 = *(void *)(v284 + 80);
LABEL_246:
  uint64_t v6 = (uint64_t)a1;
  if (v10 == v9) {
    goto LABEL_316;
  }
  while (1)
  {
    uint64_t v138 = v10 - 24;
    if (!v10) {
      uint64_t v138 = 0;
    }
    uint64_t v139 = *(void *)(v138 + 48);
    if (v139 != v138 + 40) {
      break;
    }
    uint64_t v10 = *(void *)(v10 + 8);
    if (v10 == v9) {
      goto LABEL_316;
    }
  }
  while (2)
  {
    if (v139) {
      uint64_t v140 = v139 - 24;
    }
    else {
      uint64_t v140 = 0;
    }
    int v141 = *(_DWORD *)(v140 + 20);
    if ((v141 & 0x40000000) != 0)
    {
      uint64_t v143 = *(uint64_t **)(v140 - 8);
      uint64_t v142 = v141 & 0x7FFFFFF;
    }
    else
    {
      uint64_t v142 = v141 & 0x7FFFFFF;
      uint64_t v143 = (uint64_t *)(v140 - 32 * v142);
    }
    int v144 = &v143[4 * v142];
    if (v142)
    {
      while (1)
      {
        uint64_t v147 = *v143;
        BOOL v148 = !*v143 || *(unsigned __int8 *)(*v143 + 16) > 0x14u;
        if (!v148) {
          break;
        }
LABEL_305:
        v143 += 4;
        if (v143 == v144) {
          goto LABEL_306;
        }
      }
      unsigned int v146 = v310;
      uint64_t v149 = HIDWORD(v311);
      if (v310 == v309)
      {
        if (HIDWORD(v311))
        {
          unint64_t v150 = 0;
          uint64_t v151 = 8 * HIDWORD(v311);
          uint64_t v152 = v310;
          while (*v152 != v147)
          {
            if (*v152 == -2) {
              unint64_t v150 = v152;
            }
            ++v152;
            v151 -= 8;
            if (!v151)
            {
              if (v150)
              {
                *unint64_t v150 = v147;
                --v312;
                goto LABEL_303;
              }
              goto LABEL_279;
            }
          }
          goto LABEL_305;
        }
LABEL_279:
        unsigned int v145 = v311;
        if (HIDWORD(v311) < v311)
        {
          ++HIDWORD(v311);
          *(void *)&v310[8 * v149] = v147;
LABEL_303:
          if (v348 >= (unint64_t)HIDWORD(v348)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v347 + v348) = v147;
          LODWORD(v348) = v348 + 1;
          goto LABEL_305;
        }
      }
      else
      {
        unsigned int v145 = v311;
      }
      if (3 * v145 <= 4 * (HIDWORD(v311) - v312))
      {
        if (v145 >= 0x40) {
          v145 *= 2;
        }
        else {
          unsigned int v145 = 128;
        }
      }
      else if (v145 - HIDWORD(v311) >= v145 >> 3)
      {
        goto LABEL_284;
      }
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v309, v145);
      unsigned int v145 = v311;
      unsigned int v146 = v310;
LABEL_284:
      unsigned int v153 = v145 - 1;
      unsigned int v154 = (v145 - 1) & ((v147 >> 4) ^ (v147 >> 9));
      uint64_t v155 = &v146[8 * v154];
      uint64_t v156 = *(void *)v155;
      if (*(void *)v155 != -1)
      {
        unint64_t v157 = 0;
        int v158 = 1;
        while (v156 != v147)
        {
          if (v157) {
            BOOL v159 = 0;
          }
          else {
            BOOL v159 = v156 == -2;
          }
          if (v159) {
            unint64_t v157 = v155;
          }
          unsigned int v160 = v154 + v158++;
          unsigned int v154 = v160 & v153;
          uint64_t v155 = &v146[8 * (v160 & v153)];
          uint64_t v156 = *(void *)v155;
          if (*(void *)v155 == -1) {
            goto LABEL_296;
          }
        }
        goto LABEL_305;
      }
      unint64_t v157 = 0;
LABEL_296:
      if (v157) {
        v161 = v157;
      }
      else {
        v161 = v155;
      }
      if (*(void *)v161 == v147) {
        goto LABEL_305;
      }
      if (*(void *)v161 == -2) {
        --v312;
      }
      else {
        ++HIDWORD(v311);
      }
      *(void *)v161 = v147;
      goto LABEL_303;
    }
LABEL_306:
    uint64_t v139 = *(void *)(v139 + 8);
    uint64_t v162 = v10 - 24;
    if (!v10) {
      uint64_t v162 = 0;
    }
    if (v139 != v162 + 40)
    {
      uint64_t v6 = (uint64_t)a1;
      uint64_t v5 = (llvm::LazyCallGraph::Node *)a3;
LABEL_315:
      if (v10 == v9) {
        goto LABEL_316;
      }
      continue;
    }
    break;
  }
  uint64_t v6 = (uint64_t)a1;
  uint64_t v5 = (llvm::LazyCallGraph::Node *)a3;
  while (1)
  {
    uint64_t v10 = *(void *)(v10 + 8);
    if (v10 == v9) {
      break;
    }
    uint64_t v163 = v10 - 24;
    if (!v10) {
      uint64_t v163 = 0;
    }
    uint64_t v139 = *(void *)(v163 + 48);
    if (v139 != v163 + 40) {
      goto LABEL_315;
    }
  }
LABEL_316:
  uint64_t v299 = v6;
  unint64_t v300 = v5;
  uint64_t v301 = (llvm::SmallPtrSetImplBase *)&v304;
  uint64_t v302 = &v323;
  uint64_t v303 = &v335;
  llvm::LazyCallGraph::visitReferences((uint64_t)&v347, (llvm::SmallPtrSetImplBase *)&v309, (void (*)(uint64_t))sub_1CBFA3F8C, (uint64_t)&v299);
  if (v327)
  {
    v164 = (llvm::LazyCallGraph::Node **)v326;
    uint64_t v165 = 8 * v327;
    do
    {
      v166 = *v164++;
      uint64_t v292 = (uint64_t)v166;
      unsigned int v319 = 0;
      sub_1CBFA3AF4((uint64_t *)(v6 + 288), &v292, &v319);
      llvm::LazyCallGraph::RefSCC::insertTrivialRefEdge(v7, v5, v166);
      v165 -= 8;
    }
    while (v165);
  }
  if (v333)
  {
    v167 = (llvm::LazyCallGraph::Node **)v332;
    uint64_t v168 = 8 * v333;
    do
    {
      int v169 = *v167++;
      uint64_t v292 = (uint64_t)v169;
      unsigned int v319 = 0;
      sub_1CBFA3AF4((uint64_t *)(v6 + 288), &v292, &v319);
      llvm::LazyCallGraph::RefSCC::insertTrivialRefEdge(v7, v5, v169);
      v168 -= 8;
    }
    while (v168);
  }
  uint64_t v170 = *(unsigned int *)(v6 + 624);
  if (v170)
  {
    uint64_t v171 = (uint64_t *)a1[77];
    unint64_t v172 = &v171[v170];
    while (2)
    {
      uint64_t v173 = *v171;
      uint64_t v174 = v309;
      if (v310 == v309)
      {
        int v175 = HIDWORD(v311);
        uint64_t v176 = &v310[8 * HIDWORD(v311)];
        if (HIDWORD(v311))
        {
          uint64_t v177 = 0;
          while (*(void *)&v310[v177] != v173)
          {
            v177 += 8;
            if (8 * HIDWORD(v311) == v177) {
              goto LABEL_343;
            }
          }
          uint64_t v176 = &v310[v177];
        }
LABEL_343:
        uint64_t v174 = v310;
      }
      else
      {
        int v178 = v311 - 1;
        unsigned int v179 = (v311 - 1) & ((v173 >> 4) ^ (v173 >> 9));
        uint64_t v176 = &v310[8 * v179];
        uint64_t v180 = *(void *)v176;
        if (*(void *)v176 == -1)
        {
          unint64_t v181 = 0;
LABEL_373:
          if (v181) {
            uint64_t v176 = v181;
          }
          int v175 = HIDWORD(v311);
          if (*(void *)v176 != v173) {
            uint64_t v176 = &v310[8 * v311];
          }
        }
        else
        {
          unint64_t v181 = 0;
          int v182 = 1;
          while (v180 != v173)
          {
            if (v181) {
              BOOL v183 = 0;
            }
            else {
              BOOL v183 = v180 == -2;
            }
            if (v183) {
              unint64_t v181 = v176;
            }
            unsigned int v184 = v179 + v182++;
            unsigned int v179 = v184 & v178;
            uint64_t v176 = &v310[8 * (v184 & v178)];
            uint64_t v180 = *(void *)v176;
            if (*(void *)v176 == -1) {
              goto LABEL_373;
            }
          }
          int v175 = HIDWORD(v311);
        }
      }
      if (v310 == v174) {
        int v185 = v175;
      }
      else {
        int v185 = v311;
      }
      if (v176 != &v310[8 * v185]) {
        goto LABEL_388;
      }
      uint64_t v292 = *v171;
      unsigned int v319 = 0;
      sub_1CB915048((uint64_t *)(v299 + 96), &v292, &v319);
      uint64_t v186 = *((void *)v319 + 1);
      uint64_t v292 = v186;
      unint64_t v187 = (unsigned char *)sub_1CBFA3D74((uint64_t)v300 + 24, v186);
      v188 = v301;
      uint64_t v189 = *((void *)v301 + 1);
      uint64_t v190 = *((unsigned int *)v301 + 5);
      if (v189 == *(void *)v301)
      {
        if (v190)
        {
          int v191 = 0;
          uint64_t v192 = 8 * v190;
          uint64_t v193 = (uint64_t *)*((void *)v301 + 1);
          while (*v193 != v186)
          {
            if (*v193 == -2) {
              int v191 = v193;
            }
            ++v193;
            v192 -= 8;
            if (!v192)
            {
              if (!v191) {
                goto LABEL_356;
              }
              *int v191 = v186;
              --*((_DWORD *)v188 + 6);
              break;
            }
          }
LABEL_386:
          v204 = &v302;
          if (!v187 || (v204 = &v303, (*v187 & 4) != 0)) {
            sub_1CD46E1B4((uint64_t)*v204, &v292);
          }
LABEL_388:
          if (++v171 == v172) {
            goto LABEL_397;
          }
          continue;
        }
LABEL_356:
        unsigned int v194 = *((_DWORD *)v301 + 4);
        if (v190 < v194)
        {
          *((_DWORD *)v301 + 5) = v190 + 1;
          *(void *)(v189 + 8 * v190) = v186;
          goto LABEL_386;
        }
      }
      else
      {
        unsigned int v194 = *((_DWORD *)v301 + 4);
      }
      break;
    }
    if (3 * v194 <= 4 * ((int)v190 - *((_DWORD *)v301 + 6)))
    {
      if (v194 >= 0x40) {
        v194 *= 2;
      }
      else {
        unsigned int v194 = 128;
      }
    }
    else if (v194 - v190 >= v194 >> 3)
    {
      goto LABEL_361;
    }
    llvm::SmallPtrSetImplBase::Grow(v301, v194);
    unsigned int v194 = *((_DWORD *)v188 + 4);
    uint64_t v189 = *((void *)v188 + 1);
LABEL_361:
    unsigned int v195 = v194 - 1;
    unsigned int v196 = (v194 - 1) & ((v186 >> 4) ^ (v186 >> 9));
    int v197 = (uint64_t *)(v189 + 8 * v196);
    uint64_t v198 = *v197;
    if (*v197 == -1)
    {
      v199 = 0;
LABEL_379:
      if (v199) {
        int v203 = v199;
      }
      else {
        int v203 = v197;
      }
      if (*v203 != v186)
      {
        if (*v203 == -2) {
          --*((_DWORD *)v188 + 6);
        }
        else {
          ++*((_DWORD *)v188 + 5);
        }
        *int v203 = v186;
      }
    }
    else
    {
      v199 = 0;
      int v200 = 1;
      while (v198 != v186)
      {
        if (v199) {
          BOOL v201 = 0;
        }
        else {
          BOOL v201 = v198 == -2;
        }
        if (v201) {
          v199 = v197;
        }
        unsigned int v202 = v196 + v200++;
        unsigned int v196 = v202 & v195;
        int v197 = (uint64_t *)(v189 + 8 * (v202 & v195));
        uint64_t v198 = *v197;
        if (*v197 == -1) {
          goto LABEL_379;
        }
      }
    }
    goto LABEL_386;
  }
LABEL_397:
  v205 = &v321;
  unsigned int v319 = &v321;
  uint64_t v320 = 0x400000000;
  uint64_t v206 = (llvm::LazyCallGraph::Node *)a3;
  uint64_t v207 = a3 + 24;
  uint64_t v208 = *(unsigned int *)(a3 + 32);
  if (v208)
  {
    uint64_t v209 = 8 * v208;
    v210 = *(uint64_t **)(a3 + 24);
    while ((*v210 & 0xFFFFFFFFFFFFFFF8) == 0 || !*(void *)(*v210 & 0xFFFFFFFFFFFFFFF8))
    {
      ++v210;
      v209 -= 8;
      if (!v209) {
        goto LABEL_462;
      }
    }
  }
  else
  {
    v210 = *(uint64_t **)(a3 + 24);
  }
  uint64_t v211 = *(void *)(a3 + 24) + 8 * v208;
  uint64_t v212 = (uint64_t)a1;
  if (v210 != (uint64_t *)v211)
  {
    unsigned int v213 = 0;
    uint64_t v214 = a1 + 36;
    uint64_t v215 = *v210;
LABEL_406:
    unint64_t v216 = v215 & 0xFFFFFFFFFFFFFFF8;
    uint64_t v217 = v304;
    if (v305 == v304)
    {
      int v218 = HIDWORD(v306);
      unint64_t v219 = &v305[8 * HIDWORD(v306)];
      if (HIDWORD(v306))
      {
        uint64_t v220 = 0;
        while (*(void *)&v305[v220] != v216)
        {
          v220 += 8;
          if (8 * HIDWORD(v306) == v220) {
            goto LABEL_425;
          }
        }
        unint64_t v219 = &v305[v220];
      }
LABEL_425:
      uint64_t v217 = v305;
    }
    else
    {
      int v221 = v306 - 1;
      unsigned int v222 = (v306 - 1) & ((v216 >> 4) ^ (v216 >> 9));
      unint64_t v219 = &v305[8 * v222];
      uint64_t v223 = *(void *)v219;
      if (*(void *)v219 == -1)
      {
        int v224 = 0;
LABEL_442:
        if (v224) {
          unint64_t v219 = v224;
        }
        int v218 = HIDWORD(v306);
        if (*(void *)v219 != v216) {
          unint64_t v219 = &v305[8 * v306];
        }
      }
      else
      {
        int v224 = 0;
        int v225 = 1;
        while (v223 != v216)
        {
          if (v224) {
            BOOL v226 = 0;
          }
          else {
            BOOL v226 = v223 == -2;
          }
          if (v226) {
            int v224 = v219;
          }
          unsigned int v227 = v222 + v225++;
          unsigned int v222 = v227 & v221;
          unint64_t v219 = &v305[8 * (v227 & v221)];
          uint64_t v223 = *(void *)v219;
          if (*(void *)v219 == -1) {
            goto LABEL_442;
          }
        }
        int v218 = HIDWORD(v306);
      }
    }
    if (v305 == v217) {
      int v228 = v218;
    }
    else {
      int v228 = v306;
    }
    if (v219 == &v305[8 * v228])
    {
      uint64_t v292 = v216;
      uint64_t v316 = 0;
      sub_1CBFA3AF4(v214, &v292, &v316);
      v229 = (llvm::LazyCallGraph::RefSCC **)*((void *)v316 + 1);
      if (*v229 == v7 && (*v210 & 4) != 0)
      {
        v230 = (llvm::LazyCallGraph::Node *)(*v210 & 0xFFFFFFFFFFFFFFF8);
        if (v314 == v229)
        {
          uint64_t v292 = llvm::LazyCallGraph::RefSCC::switchInternalEdgeToRef(v7, (llvm::LazyCallGraph::Node *)a3, v230);
          uint64_t v293 = v231;
          v314 = (llvm::LazyCallGraph::RefSCC **)sub_1CBFA3E00((uint64_t)&v292, v212, (uint64_t)v314, a4, a5);
        }
        else
        {
          llvm::LazyCallGraph::RefSCC::switchTrivialInternalEdgeToRef(v7, (llvm::LazyCallGraph::Node *)a3, v230);
        }
      }
      if (v320 >= (unint64_t)HIDWORD(v320)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v319 + v320) = *v210 & 0xFFFFFFFFFFFFFFF8;
      unsigned int v213 = v320 + 1;
      LODWORD(v320) = v320 + 1;
      uint64_t v212 = (uint64_t)a1;
    }
    while (++v210 != (uint64_t *)v211)
    {
      uint64_t v215 = *v210;
      if ((*v210 & 0xFFFFFFFFFFFFFFF8) != 0 && *(void *)(*v210 & 0xFFFFFFFFFFFFFFF8))
      {
        if (v210 != (uint64_t *)v211) {
          goto LABEL_406;
        }
        break;
      }
    }
    uint64_t v232 = (uint64_t *)v319;
    if (!v213) {
      goto LABEL_461;
    }
    v205 = (uint64_t *)((char *)v319 + 8 * v213);
    uint64_t v233 = 8 * v213 - 8;
    do
    {
      uint64_t v234 = *v232;
      uint64_t v292 = *v232;
      uint64_t v316 = 0;
      sub_1CBFA3AF4(v214, &v292, &v316);
      if (**((llvm::LazyCallGraph::RefSCC ***)v316 + 1) != v7) {
        break;
      }
      ++v232;
      v233 -= 8;
    }
    while (v232 != v205);
    llvm::LazyCallGraph::EdgeSequence::removeEdgeInternal(v207, v234);
    if (v232 + 1 == v205)
    {
LABEL_461:
      v205 = v232;
    }
    else
    {
      uint64_t v235 = 1;
      v205 = v232;
      do
      {
        uint64_t v236 = v232[v235];
        uint64_t v292 = v236;
        uint64_t v316 = 0;
        sub_1CBFA3AF4(v214, &v292, &v316);
        if (**((llvm::LazyCallGraph::RefSCC ***)v316 + 1) == v7) {
          *v205++ = v232[v235];
        }
        else {
          llvm::LazyCallGraph::EdgeSequence::removeEdgeInternal(v207, v236);
        }
        ++v235;
        v233 -= 8;
      }
      while (v233);
    }
  }
LABEL_462:
  LODWORD(v320) = (unint64_t)((char *)v205 - (unsigned char *)v319) >> 3;
  llvm::LazyCallGraph::RefSCC::removeInternalRefEdge((uint64_t *)v7, (void *)a3, (void **)v319, v320, (uint64_t)&v316);
  if (!v317)
  {
    uint64_t v237 = a4;
    uint64_t v238 = a5;
    uint64_t v242 = (uint64_t)a1;
    goto LABEL_499;
  }
  uint64_t v237 = a4;
  uint64_t v238 = a5;
  uint64_t v239 = *(void *)(a5 + 16);
  uint64_t v240 = *(void *)(v239 + 8);
  uint64_t v241 = *(unsigned int *)(v239 + 20);
  if (v240 != *(void *)v239)
  {
    unsigned int v246 = *(_DWORD *)(v239 + 16);
    uint64_t v242 = (uint64_t)a1;
    goto LABEL_475;
  }
  uint64_t v242 = (uint64_t)a1;
  if (!v241)
  {
LABEL_471:
    unsigned int v246 = *(_DWORD *)(v239 + 16);
    if (v241 < v246)
    {
      *(_DWORD *)(v239 + 20) = v241 + 1;
      *(void *)(v240 + 8 * v241) = v7;
      goto LABEL_496;
    }
LABEL_475:
    if (3 * v246 <= 4 * ((int)v241 - *(_DWORD *)(v239 + 24)))
    {
      if (v246 >= 0x40) {
        v246 *= 2;
      }
      else {
        unsigned int v246 = 128;
      }
    }
    else if (v246 - v241 >= v246 >> 3)
    {
      goto LABEL_477;
    }
    llvm::SmallPtrSetImplBase::Grow(*(llvm::SmallPtrSetImplBase **)(a5 + 16), v246);
    unsigned int v246 = *(_DWORD *)(v239 + 16);
    uint64_t v240 = *(void *)(v239 + 8);
LABEL_477:
    unsigned int v247 = v246 - 1;
    unsigned int v248 = (v246 - 1) & ((v7 >> 4) ^ (v7 >> 9));
    v249 = (llvm::LazyCallGraph::RefSCC **)(v240 + 8 * v248);
    v250 = *v249;
    if (*v249 == (llvm::LazyCallGraph::RefSCC *)-1)
    {
      unint64_t v251 = 0;
LABEL_489:
      if (v251) {
        unint64_t v255 = v251;
      }
      else {
        unint64_t v255 = v249;
      }
      if (*v255 != v7)
      {
        if (*v255 == (llvm::LazyCallGraph::RefSCC *)-2) {
          --*(_DWORD *)(v239 + 24);
        }
        else {
          ++*(_DWORD *)(v239 + 20);
        }
        *unint64_t v255 = v7;
      }
    }
    else
    {
      unint64_t v251 = 0;
      int v252 = 1;
      while (v250 != v7)
      {
        if (v251) {
          BOOL v253 = 0;
        }
        else {
          BOOL v253 = v250 == (llvm::LazyCallGraph::RefSCC *)-2;
        }
        if (v253) {
          unint64_t v251 = v249;
        }
        unsigned int v254 = v248 + v252++;
        unsigned int v248 = v254 & v247;
        v249 = (llvm::LazyCallGraph::RefSCC **)(v240 + 8 * (v254 & v247));
        v250 = *v249;
        if (*v249 == (llvm::LazyCallGraph::RefSCC *)-1) {
          goto LABEL_489;
        }
      }
    }
    goto LABEL_496;
  }
  unsigned int v243 = 0;
  uint64_t v244 = 8 * v241;
  unint64_t v245 = *(llvm::LazyCallGraph::RefSCC ***)(v239 + 8);
  while (*v245 != v7)
  {
    if (*v245 == (llvm::LazyCallGraph::RefSCC *)-2) {
      unsigned int v243 = v245;
    }
    ++v245;
    v244 -= 8;
    if (!v244)
    {
      if (!v243) {
        goto LABEL_471;
      }
      *unsigned int v243 = v7;
      --*(_DWORD *)(v239 + 24);
      break;
    }
  }
LABEL_496:
  uint64_t v7 = *v314;
  if (v317 != 1)
  {
    v256 = (char *)v316;
    uint64_t v257 = 8 * v317 - 8;
    do
    {
      uint64_t v292 = *(void *)&v256[v257];
      sub_1CBF9F324(*(void *)a5, &v292);
      v257 -= 8;
    }
    while (v257);
  }
LABEL_499:
  if (v339)
  {
    v258 = (llvm::LazyCallGraph::Node **)v338;
    uint64_t v259 = 8 * v339;
    do
    {
      v260 = *v258;
      uint64_t v292 = (uint64_t)*v258;
      uint64_t v315 = 0;
      sub_1CBFA3AF4((uint64_t *)(v242 + 288), &v292, &v315);
      int v261 = *(llvm::LazyCallGraph::RefSCC ***)(v315 + 8);
      if (*v261 == v7)
      {
        if (v314 == v261)
        {
          uint64_t v292 = llvm::LazyCallGraph::RefSCC::switchInternalEdgeToRef(v7, (llvm::LazyCallGraph::Node *)a3, v260);
          uint64_t v293 = v262;
          v314 = (llvm::LazyCallGraph::RefSCC **)sub_1CBFA3E00((uint64_t)&v292, v242, (uint64_t)v314, v237, v238);
        }
        else
        {
          llvm::LazyCallGraph::RefSCC::switchTrivialInternalEdgeToRef(v7, (llvm::LazyCallGraph::Node *)a3, v260);
        }
      }
      else
      {
        llvm::LazyCallGraph::RefSCC::switchOutgoingEdgeToRef(v7, (llvm::LazyCallGraph::Node *)a3, v260);
      }
      ++v258;
      v259 -= 8;
    }
    while (v259);
  }
  if (v333)
  {
    v263 = (uint64_t *)v332;
    uint64_t v264 = 8 * v333;
    do
    {
      uint64_t v265 = *v263++;
      uint64_t v292 = v265;
      sub_1CD46E1B4((uint64_t)&v341, &v292);
      v264 -= 8;
    }
    while (v264);
  }
  if (v345)
  {
    unint64_t v266 = (unsigned int **)v344;
    uint64_t v267 = (unsigned int **)((char *)v344 + 8 * v345);
    uint64_t v268 = (uint64_t *)(v242 + 288);
    uint64_t v287 = (uint64_t)v7 + 56;
    do
    {
      uint64_t v269 = *v266;
      uint64_t v292 = (uint64_t)*v266;
      uint64_t v315 = 0;
      v270 = 0;
      if (sub_1CBFA3AF4(v268, &v292, &v315)) {
        v270 = *(llvm::LazyCallGraph::RefSCC ***)(v315 + 8);
      }
      if (*v270 == v7)
      {
        LOBYTE(v315) = 0;
        uint64_t v271 = *((void *)v7 + 1);
        uint64_t v272 = *(int *)(sub_1CD46E598(v287, (uint64_t)v314) + 8);
        uint64_t v273 = v238;
        uint64_t v274 = *((void *)v7 + 1);
        uint64_t v292 = (uint64_t)&v315;
        uint64_t v293 = a4;
        uint64_t v294 = v273;
        if (llvm::LazyCallGraph::RefSCC::switchInternalEdgeToCall((uint64_t)v7, (uint64_t)v206, v269, (void (*)(uint64_t, void **, int64_t))sub_1CBFA43D8, (uint64_t)&v292))
        {
          v314 = v270;
          if ((_BYTE)v315) {
            llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>::getResultImpl();
          }
          uint64_t v292 = (uint64_t)v296;
          uint64_t v293 = (uint64_t)v296;
          uint64_t v294 = 2;
          LODWORD(v295) = 0;
          v296[2] = v298;
          v296[3] = v298;
          v296[4] = 2;
          int v297 = 0;
          sub_1CBF541A4((llvm::SmallPtrSetImplBase *)&v292, (uint64_t)&llvm::AllAnalysesOn<llvm::Function>::SetKey);
          sub_1CBFA65B8((llvm::SmallPtrSetImplBase *)&v292, (uint64_t)&llvm::FunctionAnalysisManagerCGSCCProxy::Key);
          llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>::invalidate();
        }
        uint64_t v275 = (v271 + 8 * v272 - v274) >> 3;
        uint64_t v276 = 8 * *(int *)(sub_1CD46E598(v287, (uint64_t)v314) + 8);
        uint64_t v238 = a5;
        if (v275 < v276 >> 3)
        {
          uint64_t v277 = v276 >> 3;
          sub_1CBF9F4B4(*(void *)(a5 + 8), (uint64_t *)&v314);
          uint64_t v278 = 8 * v275 - 8 * v277;
          uint64_t v279 = (uint64_t *)(*((void *)v7 + 1) + 8 * v277 - 8);
          do
          {
            uint64_t v280 = *v279--;
            uint64_t v281 = *(void *)(a5 + 8);
            uint64_t v292 = v280;
            sub_1CBF9F4B4(v281, &v292);
            v278 += 8;
          }
          while (v278);
        }
        uint64_t v206 = (llvm::LazyCallGraph::Node *)a3;
      }
      else
      {
        llvm::LazyCallGraph::RefSCC::switchOutgoingEdgeToCall(v7, v206, (llvm::LazyCallGraph::Node *)v269);
      }
      ++v266;
    }
    while (v266 != v267);
  }
  BOOL v282 = v314;
  if (v314 != a2) {
    *(void *)(v238 + 32) = v314;
  }
  if (v316 != &v318) {
    free(v316);
  }
  if (v319 != &v321) {
    free(v319);
  }
  if (v326 != v328) {
    free(v326);
  }
  if ((v323 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v324.i64[0], 8);
  }
  if (v332 != v334) {
    free(v332);
  }
  if ((v329 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v330.i64[0], 8);
  }
  if (v338 != v340) {
    free(v338);
  }
  if ((v335 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v336.i64[0], 8);
  }
  if (v344 != v346) {
    free(v344);
  }
  if ((v341 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v342.i64[0], 8);
  }
  if (v305 != v304) {
    free(v305);
  }
  if (v310 != v309) {
    free(v310);
  }
  if (v347 != v349) {
    free(v347);
  }
  return v282;
}

void __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> sub_1CBFA3A10(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 416))
  {
    uint64_t v1 = **(void **)(a1 + 408);
    uint64_t v3 = v1;
    if (v1)
    {
      if (!*(_DWORD *)(v1 + 16))
      {
        do
          sub_1CBFA3A74(&v2);
        while (v3 && !*(_DWORD *)(v3 + 16));
      }
    }
  }
}

uint64_t sub_1CBFA3A74(void *a1)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  uint64_t v4 = (uint64_t *)(*a1 + 552);
  uint64_t v9 = v2;
  uint64_t v10 = 0;
  uint64_t result = sub_1CBFA3AF4(v4, &v9, &v10);
  if (result) {
    uint64_t v6 = v10;
  }
  else {
    uint64_t v6 = *(void *)(v3 + 552) + 16 * *(unsigned int *)(v3 + 568);
  }
  uint64_t v7 = *(int *)(v6 + 8) + 1;
  if (*(_DWORD *)(v3 + 416) == v7) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = *(void *)(*(void *)(v3 + 408) + 8 * v7);
  }
  a1[1] = v8;
  return result;
}

uint64_t sub_1CBFA3AF4(uint64_t *a1, void *a2, void *a3)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    uint64_t v4 = *a1;
    int v5 = v3 - 1;
    unsigned int v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v3 - 1);
    uint64_t v7 = (void *)(*a1 + 16 * v6);
    uint64_t v8 = *v7;
    if (*a2 == *v7)
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v10 = 0;
      int v11 = 1;
      uint64_t result = 1;
      while (v8 != -4096)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v8 == -8192;
        }
        if (v12) {
          uint64_t v10 = v7;
        }
        unsigned int v13 = v6 + v11++;
        unsigned int v6 = v13 & v5;
        uint64_t v7 = (void *)(v4 + 16 * (v13 & v5));
        uint64_t v8 = *v7;
        if (*a2 == *v7) {
          goto LABEL_4;
        }
      }
      uint64_t result = 0;
      if (v10) {
        uint64_t v7 = v10;
      }
    }
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t result = 0;
  }
LABEL_4:
  *a3 = v7;
  return result;
}

uint64_t sub_1CBFA3B90(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 4;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      uint64_t v7 = 0;
      uint64_t result = 0;
      goto LABEL_7;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = (v4 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v7 = (void *)(v3 + 16 * v6);
  uint64_t v8 = *v7;
  if (*v7 == a2)
  {
    uint64_t result = 1;
  }
  else
  {
    uint64_t v10 = 0;
    int v11 = 1;
    uint64_t result = 1;
    while (v8 != -4096)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -8192;
      }
      if (v12) {
        uint64_t v10 = v7;
      }
      unsigned int v13 = v6 + v11++;
      unsigned int v6 = v13 & v5;
      uint64_t v7 = (void *)(v3 + 16 * (v13 & v5));
      uint64_t v8 = *v7;
      if (*v7 == a2) {
        goto LABEL_7;
      }
    }
    uint64_t result = 0;
    if (v10) {
      uint64_t v7 = v10;
    }
  }
LABEL_7:
  *a3 = v7;
  return result;
}

uint64_t sub_1CBFA3C3C(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  int v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    uint64_t v8 = (void *)(result + 8);
    uint64_t v9 = (void *)(result + 72);
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(result + 16);
    if (!v7) {
      goto LABEL_10;
    }
    uint64_t v8 = *(void **)(result + 8);
    uint64_t v9 = &v8[2 * v7];
  }
  do
  {
    *uint64_t v8 = -4096;
    v8 += 2;
  }
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    uint64_t v10 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      BOOL v12 = 0;
      uint64_t result = sub_1CBFA3B90((uint64_t)v5, v10, &v12);
      int v11 = v12;
      *BOOL v12 = *a2;
      v11[1] = a2[1];
      *v5 += 2;
    }
    a2 += 2;
  }
  return result;
}

void *sub_1CBFA3D00(void *result, void *a2)
{
  int *result = *a2;
  result[1] = 6;
  uint64_t v2 = result + 1;
  result[2] = 0;
  unint64_t v3 = (unint64_t)(result + 2);
  uint64_t v4 = a2[3];
  result[3] = v4;
  if (v4 != -8192 && v4 != -4096 && v4 != 0)
  {
    unint64_t v6 = a2[1] & 0xFFFFFFFFFFFFFFF8;
    *(void *)unint64_t v3 = *(void *)v6;
    *(void *)unint64_t v6 = v2;
    *uint64_t v2 = v6 | 6;
    if (*(void *)v3) {
      **(void **)unint64_t v3 = **(void **)v3 & 7 | v3;
    }
  }
  return result;
}

uint64_t sub_1CBFA3D74(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = a2;
  uint64_t v7 = 0;
  int v3 = sub_1CB915048((uint64_t *)(a1 + 48), &v6, &v7);
  uint64_t result = 0;
  if (v3 && v7 != *(void *)(a1 + 48) + 16 * *(unsigned int *)(a1 + 64))
  {
    int v5 = (void *)(*(void *)a1 + 8 * *(int *)(v7 + 8));
    if ((*v5 & 0xFFFFFFFFFFFFFFF8) != 0)
    {
      if (*(void *)(*v5 & 0xFFFFFFFFFFFFFFF8)) {
        return *(void *)a1 + 8 * *(int *)(v7 + 8);
      }
      else {
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_1CBFA3E00(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7 = a3;
  if (*(void *)a1 != *(void *)(a1 + 8))
  {
    sub_1CBF9F4B4(*(void *)(a5 + 8), &v7);
    uint64_t v7 = **(void **)a1;
    llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>::getCachedResultImpl();
  }
  return a3;
}

void sub_1CBFA3F8C(uint64_t a1, uint64_t a2)
{
  int v3 = (uint64_t *)(*(void *)a1 + 96);
  uint64_t v24 = 0;
  uint64_t v25 = a2;
  sub_1CB915048(v3, &v25, &v24);
  uint64_t v4 = *(void *)(v24 + 8);
  uint64_t v25 = v4;
  uint64_t v5 = sub_1CBFA3D74(*(void *)(a1 + 8) + 24, v4);
  uint64_t v6 = (unsigned char *)v5;
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t v8 = *(void *)(v7 + 8);
  uint64_t v9 = *(unsigned int *)(v7 + 20);
  if (v8 != *(void *)v7)
  {
    unsigned int v13 = *(_DWORD *)(v7 + 16);
    goto LABEL_13;
  }
  if (v9)
  {
    uint64_t v10 = 0;
    uint64_t v11 = 8 * v9;
    BOOL v12 = *(uint64_t **)(v7 + 8);
    while (*v12 != v4)
    {
      if (*v12 == -2) {
        uint64_t v10 = v12;
      }
      ++v12;
      v11 -= 8;
      if (!v11)
      {
        if (!v10) {
          goto LABEL_9;
        }
        *uint64_t v10 = v4;
        --*(_DWORD *)(v7 + 24);
        if (v5) {
          goto LABEL_35;
        }
        goto LABEL_38;
      }
    }
LABEL_34:
    if (v6) {
      goto LABEL_35;
    }
LABEL_38:
    uint64_t v23 = (uint64_t *)(a1 + 24);
    goto LABEL_39;
  }
LABEL_9:
  unsigned int v13 = *(_DWORD *)(v7 + 16);
  if (v9 >= v13)
  {
LABEL_13:
    if (3 * v13 <= 4 * ((int)v9 - *(_DWORD *)(v7 + 24)))
    {
      if (v13 >= 0x40) {
        v13 *= 2;
      }
      else {
        unsigned int v13 = 128;
      }
    }
    else if (v13 - v9 >= v13 >> 3)
    {
      goto LABEL_15;
    }
    llvm::SmallPtrSetImplBase::Grow(*(llvm::SmallPtrSetImplBase **)(a1 + 16), v13);
    unsigned int v13 = *(_DWORD *)(v7 + 16);
    uint64_t v8 = *(void *)(v7 + 8);
LABEL_15:
    unsigned int v14 = v13 - 1;
    unsigned int v15 = (v13 - 1) & ((v4 >> 4) ^ (v4 >> 9));
    uint64_t v16 = (uint64_t *)(v8 + 8 * v15);
    uint64_t v17 = *v16;
    if (*v16 == -1)
    {
      uint64_t v18 = 0;
LABEL_27:
      if (v18) {
        uint64_t v22 = v18;
      }
      else {
        uint64_t v22 = v16;
      }
      if (*v22 != v4)
      {
        if (*v22 == -2) {
          --*(_DWORD *)(v7 + 24);
        }
        else {
          ++*(_DWORD *)(v7 + 20);
        }
        *uint64_t v22 = v4;
      }
    }
    else
    {
      uint64_t v18 = 0;
      int v19 = 1;
      while (v17 != v4)
      {
        if (v18) {
          BOOL v20 = 0;
        }
        else {
          BOOL v20 = v17 == -2;
        }
        if (v20) {
          uint64_t v18 = v16;
        }
        unsigned int v21 = v15 + v19++;
        unsigned int v15 = v21 & v14;
        uint64_t v16 = (uint64_t *)(v8 + 8 * (v21 & v14));
        uint64_t v17 = *v16;
        if (*v16 == -1) {
          goto LABEL_27;
        }
      }
    }
    goto LABEL_34;
  }
  *(_DWORD *)(v7 + 20) = v9 + 1;
  *(void *)(v8 + 8 * v9) = v4;
  if (!v5) {
    goto LABEL_38;
  }
LABEL_35:
  if ((*v6 & 4) == 0) {
    return;
  }
  uint64_t v23 = (uint64_t *)(a1 + 32);
LABEL_39:
  sub_1CD46E1B4(*v23, &v25);
}

void sub_1CBFA4180()
{
}

void sub_1CBFA43D8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3) {
    llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>::getCachedResultImpl();
  }
}

uint64_t sub_1CBFA465C(uint64_t result, uint64_t a2)
{
  if (*(void *)result)
  {
    if (*(_DWORD *)(*(void *)result + 728))
    {
      (*(void (**)(uint64_t))(*(void *)a2 + 24))(a2);
      uint64_t v2 = 0;
      operator new();
    }
  }
  return result;
}

uint64_t sub_1CBFA47B0(uint64_t result, uint64_t a2)
{
  if (*(void *)result)
  {
    if (*(_DWORD *)(*(void *)result + 872))
    {
      (*(void (**)(uint64_t))(*(void *)a2 + 24))(a2);
      uint64_t v2 = 0;
      operator new();
    }
  }
  return result;
}

uint64_t sub_1CBFA4904@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  BOOL v12 = 0;
  uint64_t result = sub_1CBFA49A4((uint64_t *)a1, a2, &v12);
  uint64_t v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CBFA4A98(a1, (uint64_t)a2, a2, v12);
    uint64_t v9 = (void *)result;
    *(void *)uint64_t result = *a2;
    *(void *)(result + 8) = a2[1];
    *(void *)(result + 16) = *a3;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a1 + 24 * *(unsigned int *)(a1 + 16);
  *(void *)a4 = v9;
  *(void *)(a4 + 8) = v11;
  *(unsigned char *)(a4 + 16) = v10;
  return result;
}

uint64_t sub_1CBFA49A4(uint64_t *a1, uint64_t *a2, void *a3)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    uint64_t v4 = *a1;
    uint64_t v5 = *a2;
    uint64_t v6 = a2[1];
    unint64_t v7 = ((v6 >> 4) ^ (v6 >> 9) | ((unint64_t)((*a2 >> 4) ^ (*a2 >> 9)) << 32))
       + ~((unint64_t)((v6 >> 4) ^ (v6 >> 9)) << 32);
    unint64_t v8 = (v7 ^ (v7 >> 22)) + ~((v7 ^ (v7 >> 22)) << 13);
    unint64_t v9 = (9 * (v8 ^ (v8 >> 8))) ^ ((9 * (v8 ^ (v8 >> 8))) >> 15);
    int v10 = ((v9 + ~(v9 << 27)) >> 31) ^ (v9 + ~(v9 << 27));
    int v11 = v3 - 1;
    unsigned int v12 = (v3 - 1) & v10;
    unsigned int v13 = (void *)(*a1 + 24 * v12);
    uint64_t v15 = *v13;
    uint64_t v14 = v13[1];
    if (v5 == *v13 && v6 == v14)
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v17 = 0;
      int v18 = 1;
      uint64_t result = 1;
      while (v15 != -4096 || v14 != -4096)
      {
        if (v17) {
          BOOL v20 = 0;
        }
        else {
          BOOL v20 = v14 == -8192;
        }
        if (v20 && v15 == -8192) {
          uint64_t v17 = v13;
        }
        unsigned int v22 = v12 + v18++;
        unsigned int v12 = v22 & v11;
        unsigned int v13 = (void *)(v4 + 24 * (v22 & v11));
        uint64_t v15 = *v13;
        uint64_t v14 = v13[1];
        if (v5 == *v13 && v6 == v14) {
          goto LABEL_8;
        }
      }
      uint64_t result = 0;
      if (v17) {
        unsigned int v13 = v17;
      }
    }
  }
  else
  {
    unsigned int v13 = 0;
    uint64_t result = 0;
  }
LABEL_8:
  *a3 = v13;
  return result;
}

void *sub_1CBFA4A98(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
    goto LABEL_8;
  }
  if (v7 + ~v6 - *(_DWORD *)(a1 + 12) <= v7 >> 3)
  {
LABEL_8:
    sub_1CBFA4B58(a1, v7);
    unint64_t v9 = 0;
    sub_1CBFA49A4((uint64_t *)a1, a3, &v9);
    a4 = v9;
  }
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096 || a4[1] != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

_OWORD *sub_1CBFA4B58(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(24 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD46E6AC(a1, v4, &v4[3 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 24 * v10;
    int64x2_t v12 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
    do
    {
      _OWORD *result = v12;
      uint64_t result = (_OWORD *)((char *)result + 24);
      v11 -= 24;
    }
    while (v11);
  }
  return result;
}

void sub_1CBFA4C34()
{
}

void sub_1CBFA4C48()
{
}

void *sub_1CBFA4CA8()
{
  return &llvm::Any::TypeId<llvm::Module const*>::Id;
}

void *sub_1CBFA4CB4(uint64_t *a1, void *a2)
{
  int v7 = 0;
  char v4 = sub_1CBFA4D20(a1, a2, &v7);
  unint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    unint64_t v5 = sub_1CBFA4DBC((uint64_t)a1, (uint64_t)a2, a2, v7);
    *unint64_t v5 = *a2;
    v5[1] = v5 + 1;
    void v5[2] = v5 + 1;
    v5[3] = 0;
  }
  return v5;
}

uint64_t sub_1CBFA4D20(uint64_t *a1, void *a2, void *a3)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    uint64_t v4 = *a1;
    unsigned int v5 = v3 - 1;
    uint64_t v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v3 - 1);
    int v7 = (void *)(*a1 + 32 * v6);
    uint64_t v8 = *v7;
    if (*a2 == *v7)
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v10 = 0;
      int v11 = 1;
      uint64_t result = 1;
      while (v8 != -4096)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v8 == -8192;
        }
        if (v12) {
          uint64_t v10 = v7;
        }
        int v13 = v6 + v11++;
        uint64_t v6 = v13 & v5;
        int v7 = (void *)(v4 + 32 * v6);
        uint64_t v8 = *v7;
        if (*a2 == *v7) {
          goto LABEL_4;
        }
      }
      uint64_t result = 0;
      if (v10) {
        int v7 = v10;
      }
    }
  }
  else
  {
    int v7 = 0;
    uint64_t result = 0;
  }
LABEL_4:
  *a3 = v7;
  return result;
}

void *sub_1CBFA4DBC(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CBFA4E70(a1, v7);
  unint64_t v9 = 0;
  sub_1CBFA4D20((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CBFA4E70(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(32 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD46E78C(a1, v4, &v4[4 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 32 * v10;
    do
    {
      void *result = -4096;
      result += 4;
      v11 -= 32;
    }
    while (v11);
  }
  return result;
}

void sub_1CBFA4F3C(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v2 = *a1;
    uint64_t v3 = (uint64_t *)a1[1];
    uint64_t v4 = *v3;
    *(void *)(v4 + 8) = *(void *)(*a1 + 8);
    **(void **)(v2 + 8) = v4;
    a1[2] = 0;
    if (v3 != a1)
    {
      do
      {
        unint64_t v5 = (uint64_t *)v3[1];
        uint64_t v6 = v3[3];
        v3[3] = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
        }
        operator delete(v3);
        uint64_t v3 = v5;
      }
      while (v5 != a1);
    }
  }
}

_DWORD *sub_1CBFA4FD8(_DWORD *result, int a2)
{
  uint64_t v2 = result;
  if (a2)
  {
    unint64_t v3 = (4 * a2 / 3u + 1) | ((unint64_t)(4 * a2 / 3u + 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    LODWORD(v4) = (((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8)) + 1;
    result[4] = v4;
    uint64_t result = operator new(24 * v4, (std::align_val_t)8uLL);
    *(void *)uint64_t v2 = result;
    *((void *)v2 + 1) = 0;
    uint64_t v5 = v2[4];
    if (v5)
    {
      uint64_t v6 = 24 * v5;
      int64x2_t v7 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
      do
      {
        *(int64x2_t *)uint64_t result = v7;
        result += 6;
        v6 -= 24;
      }
      while (v6);
    }
  }
  else
  {
    *(void *)uint64_t result = 0;
    *((void *)result + 1) = 0;
    result[4] = 0;
  }
  return result;
}

unsigned int *sub_1CBFA5078(unsigned int *result)
{
  uint64_t v1 = result[4];
  if (v1)
  {
    uint64_t v2 = 16 * v1;
    unint64_t v3 = (unsigned int **)(*(void *)result + 8);
    do
    {
      if (((unint64_t)*(v3 - 1) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t result = *v3;
        *unint64_t v3 = 0;
        if (result) {
          uint64_t result = (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(void *)result + 8))(result);
        }
      }
      v3 += 2;
      v2 -= 16;
    }
    while (v2);
  }
  return result;
}

void sub_1CBFA50F4(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v2 = *a1;
    unint64_t v3 = (uint64_t *)a1[1];
    uint64_t v4 = *v3;
    *(void *)(v4 + 8) = *(void *)(*a1 + 8);
    **(void **)(v2 + 8) = v4;
    a1[2] = 0;
    if (v3 != a1)
    {
      do
      {
        uint64_t v5 = (uint64_t *)v3[1];
        uint64_t v6 = v3[3];
        v3[3] = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
        }
        operator delete(v3);
        unint64_t v3 = v5;
      }
      while (v5 != a1);
    }
  }
}

_DWORD *sub_1CBFA5190(_DWORD *result)
{
  uint64_t v1 = result;
  uint64_t v2 = result[4];
  int v3 = result[2];
  int v4 = 1 << (33 - __clz(v3 - 1));
  if (v4 <= 64) {
    int v4 = 64;
  }
  if (v3) {
    int v5 = v4;
  }
  else {
    int v5 = 0;
  }
  if (v5 == v2)
  {
    *((void *)result + 1) = 0;
    if (v2)
    {
      uint64_t v6 = *(int64x2_t **)result;
      uint64_t v7 = 24 * v2;
      int64x2_t v8 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
      do
      {
        *uint64_t v6 = v8;
        uint64_t v6 = (int64x2_t *)((char *)v6 + 24);
        v7 -= 24;
      }
      while (v7);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)result, 8);
    return sub_1CBFA4FD8(v1, v5);
  }
  return result;
}

void sub_1CBFA5244(_DWORD *a1)
{
  uint64_t v2 = a1[4];
  int v3 = a1[2];
  if (v2)
  {
    uint64_t v4 = 32 * v2;
    int v5 = (uint64_t *)(*(void *)a1 + 8);
    do
    {
      if ((*(v5 - 1) | 0x1000) != 0xFFFFFFFFFFFFF000) {
        sub_1CBFA50F4(v5);
      }
      v5 += 4;
      v4 -= 32;
    }
    while (v4);
  }
  if (v3)
  {
    int v6 = 1 << (33 - __clz(v3 - 1));
    if (v6 <= 64) {
      unsigned int v7 = 64;
    }
    else {
      unsigned int v7 = v6;
    }
    int64x2_t v8 = *(void **)a1;
    if (v7 == a1[4])
    {
      *((void *)a1 + 1) = 0;
      uint64_t v9 = 32 * v7;
      do
      {
        *int64x2_t v8 = -4096;
        v8 += 4;
        v9 -= 32;
      }
      while (v9);
      return;
    }
  }
  else
  {
    if (!a1[4])
    {
      *((void *)a1 + 1) = 0;
      return;
    }
    unsigned int v7 = 0;
  }
  MEMORY[0x1D25D9CD0]();

  sub_1CBC04C8C(a1, v7);
}

BOOL sub_1CBFA534C(uint64_t *a1, uint64_t a2)
{
  if (*((_DWORD *)a1 + 17) != *((_DWORD *)a1 + 18)) {
    return 0;
  }
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  if (v2 == *a1)
  {
    uint64_t v4 = *((unsigned int *)a1 + 5);
    int v5 = (void **)(v2 + 8 * v4);
    if (v4)
    {
      uint64_t v6 = 0;
      uint64_t v7 = 8 * v4;
      while (*(_UNKNOWN **)(v2 + v6) != &llvm::PreservedAnalyses::AllAnalysesKey)
      {
        v6 += 8;
        if (v7 == v6) {
          goto LABEL_7;
        }
      }
      int v5 = (void **)(v2 + v6);
    }
LABEL_7:
    uint64_t v8 = a1[1];
  }
  else
  {
    uint64_t v11 = *((unsigned int *)a1 + 4);
    int v12 = v11 - 1;
    unsigned int v13 = (v11 - 1) & ((&llvm::PreservedAnalyses::AllAnalysesKey >> 4) ^ (&llvm::PreservedAnalyses::AllAnalysesKey >> 9));
    int v5 = (void **)(v2 + 8 * v13);
    uint64_t v14 = *v5;
    if (*v5 == (void *)-1)
    {
      uint64_t v15 = 0;
LABEL_47:
      if (v15) {
        int v5 = v15;
      }
      if (*v5 != &llvm::PreservedAnalyses::AllAnalysesKey) {
        int v5 = (void **)(v2 + 8 * v11);
      }
    }
    else
    {
      uint64_t v15 = 0;
      int v16 = 1;
      while (v14 != &llvm::PreservedAnalyses::AllAnalysesKey)
      {
        if (v15) {
          BOOL v17 = 0;
        }
        else {
          BOOL v17 = v14 == (void *)-2;
        }
        if (v17) {
          uint64_t v15 = v5;
        }
        unsigned int v18 = v13 + v16++;
        unsigned int v13 = v18 & v12;
        int v5 = (void **)(v2 + 8 * (v18 & v12));
        uint64_t v14 = *v5;
        if (*v5 == (void *)-1) {
          goto LABEL_47;
        }
      }
    }
    uint64_t v8 = *a1;
  }
  uint64_t v9 = 16;
  if (v2 == v8) {
    uint64_t v9 = 20;
  }
  if (v5 != (void **)(v2 + 8 * *(unsigned int *)((char *)a1 + v9))) {
    return 1;
  }
  int v19 = (unsigned int *)a1 + 5;
  BOOL v20 = (unsigned int *)(a1 + 2);
  if (v2 == v8)
  {
    uint64_t v21 = *v19;
    unsigned int v22 = (void *)(v2 + 8 * v21);
    if (v21)
    {
      uint64_t v23 = 0;
      uint64_t v24 = 8 * v21;
      while (*(void *)(v2 + v23) != a2)
      {
        v23 += 8;
        if (v24 == v23) {
          goto LABEL_28;
        }
      }
      unsigned int v22 = (void *)(v2 + v23);
    }
LABEL_28:
    uint64_t v3 = a1[1];
  }
  else
  {
    int v26 = *v20 - 1;
    unsigned int v27 = v26 & ((a2 >> 4) ^ (a2 >> 9));
    unsigned int v22 = (void *)(v2 + 8 * v27);
    uint64_t v28 = *v22;
    if (*v22 == -1)
    {
      unsigned int v29 = 0;
LABEL_54:
      if (v29) {
        unsigned int v22 = v29;
      }
      if (*v22 != a2)
      {
        if (v2 == v3) {
          unsigned int v33 = v19;
        }
        else {
          unsigned int v33 = v20;
        }
        unsigned int v22 = (void *)(v2 + 8 * *v33);
      }
    }
    else
    {
      unsigned int v29 = 0;
      int v30 = 1;
      while (v28 != a2)
      {
        if (v29) {
          BOOL v31 = 0;
        }
        else {
          BOOL v31 = v28 == -2;
        }
        if (v31) {
          unsigned int v29 = v22;
        }
        unsigned int v32 = v27 + v30++;
        unsigned int v27 = v32 & v26;
        unsigned int v22 = (void *)(v2 + 8 * (v32 & v26));
        uint64_t v28 = *v22;
        if (*v22 == -1) {
          goto LABEL_54;
        }
      }
    }
  }
  if (v2 == v3) {
    uint64_t v25 = v19;
  }
  else {
    uint64_t v25 = v20;
  }
  return v22 != (void *)(v2 + 8 * *v25);
}

uint64_t *sub_1CBFA5558(uint64_t a1, uint64_t *a2)
{
  uint64_t v8 = 0;
  char v4 = sub_1CBFA5644(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  uint64_t result = v8;
  if (v4) {
    return result;
  }
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
    goto LABEL_8;
  }
  if (v7 + ~v6 - *(_DWORD *)(a1 + 12) <= v7 >> 3)
  {
LABEL_8:
    sub_1CBFA56CC(a1, v7);
    uint64_t v8 = 0;
    sub_1CBFA5644(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
    uint64_t result = v8;
  }
  ++*(_DWORD *)(a1 + 8);
  if (*result != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  uint64_t *result = *a2;
  result[1] = (uint64_t)(result + 1);
  result[2] = (uint64_t)(result + 1);
  result[3] = 0;
  return result;
}

uint64_t sub_1CBFA5644(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    uint64_t v4 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    int v5 = (void *)(a1 + 32 * v4);
    uint64_t v6 = *v5;
    if (*v5 == a3)
    {
LABEL_11:
      uint64_t result = 1;
    }
    else
    {
      unsigned int v7 = 0;
      int v8 = 1;
      while (v6 != -4096)
      {
        if (v7) {
          BOOL v9 = 0;
        }
        else {
          BOOL v9 = v6 == -8192;
        }
        if (v9) {
          unsigned int v7 = v5;
        }
        int v10 = v4 + v8++;
        uint64_t v4 = v10 & (a2 - 1);
        int v5 = (void *)(a1 + 32 * v4);
        uint64_t v6 = *v5;
        if (*v5 == a3) {
          goto LABEL_11;
        }
      }
      uint64_t result = 0;
      if (v7) {
        int v5 = v7;
      }
    }
  }
  else
  {
    int v5 = 0;
    uint64_t result = 0;
  }
  *a4 = v5;
  return result;
}

void *sub_1CBFA56CC(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(32 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CBFA5798(a1, v4, &v4[4 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 32 * v10;
    do
    {
      void *result = -4096;
      result += 4;
      v11 -= 32;
    }
    while (v11);
  }
  return result;
}

void sub_1CBFA5798(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6)
  {
    int v7 = *(void **)a1;
    uint64_t v8 = 32 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 4;
      v8 -= 32;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      BOOL v17 = 0;
      sub_1CBFA5644(*(void *)a1, *(_DWORD *)(a1 + 16), v9, &v17);
      uint64_t v10 = v17;
      uint64_t v11 = v17 + 1;
      uint64_t *v17 = *a2;
      v10[1] = (uint64_t)v11;
      v10[2] = (uint64_t)v11;
      v10[3] = 0;
      uint64_t v12 = a2[3];
      if (v12)
      {
        uint64_t v14 = a2[1];
        unsigned int v13 = (uint64_t *)a2[2];
        uint64_t v15 = *v13;
        *(void *)(v15 + 8) = *(void *)(v14 + 8);
        **(void **)(v14 + 8) = v15;
        uint64_t v16 = v10[1];
        *(void *)(v16 + 8) = v13;
        *unsigned int v13 = v16;
        v10[1] = v14;
        *(void *)(v14 + 8) = v11;
        v10[3] = v12;
        a2[3] = 0;
      }
      ++*(_DWORD *)(a1 + 8);
      sub_1CBFA50F4(a2 + 1);
    }
    a2 += 4;
  }
}

void sub_1CBFA588C()
{
}

void sub_1CBFA58A0()
{
}

void *sub_1CBFA5900()
{
  return &llvm::Any::TypeId<llvm::LazyCallGraph::SCC const*>::Id;
}

_OWORD *sub_1CBFA590C(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(24 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CBFA59E8(a1, v4, &v4[3 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 24 * v10;
    int64x2_t v12 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
    do
    {
      _OWORD *result = v12;
      uint64_t result = (_OWORD *)((char *)result + 24);
      v11 -= 24;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CBFA59E8(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(int64x2_t **)result;
    uint64_t v8 = 24 * v6;
    int64x2_t v9 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
    do
    {
      *int v7 = v9;
      int v7 = (int64x2_t *)((char *)v7 + 24);
      v8 -= 24;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v10 = a2[1];
    if ((*a2 != -4096 || v10 != -4096) && (*a2 != -8192 || v10 != -8192))
    {
      int64x2_t v12 = 0;
      uint64_t result = sub_1CBF5C064((uint64_t *)v5, a2, &v12);
      uint64_t v11 = v12;
      *int64x2_t v12 = *a2;
      v11[1] = a2[1];
      v11[2] = a2[2];
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 3;
  }
  return result;
}

unint64_t *sub_1CBFA5ABC(unint64_t *a1, unint64_t *__dst, unint64_t *__src)
{
  unsigned int v3 = __dst;
  unint64_t v4 = *a1;
  if ((*a1 & 4) != 0)
  {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFF8;
    if ((v4 & 0xFFFFFFFFFFFFFFF8) != 0)
    {
      uint64_t v6 = *(void *)v5;
      int v7 = (unint64_t *)(*(void *)v5 + 8 * *(unsigned int *)(v5 + 8));
      int64_t v8 = (char *)v7 - (char *)__src;
      if (v7 != __src)
      {
        memmove(__dst, __src, (char *)v7 - (char *)__src);
        uint64_t v6 = *(void *)v5;
      }
      *(_DWORD *)(v5 + 8) = ((unint64_t)v3 + v8 - v6) >> 3;
    }
  }
  else
  {
    if (a1 == __dst && __dst != __src)
    {
      unint64_t v4 = 0;
      *__dst = 0;
    }
    return &a1[v4 > 7];
  }
  return v3;
}

uint64_t *sub_1CBFA5B5C(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  unsigned int v3 = a1;
  if (a1 != a2)
  {
    uint64_t v6 = a1;
    while (1)
    {
      uint64_t v7 = *v6++;
      if (llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>::Invalidator::invalidate(*(uint64_t **)a3, v7, *(void *)(a3 + 8), *(void *)(a3 + 16)))break; {
      unsigned int v3 = v6;
      }
      if (v6 == a2) {
        return a2;
      }
    }
    if (v6 != a2)
    {
      int64x2_t v9 = v3 + 1;
      do
      {
        if ((llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>::Invalidator::invalidate(*(uint64_t **)a3, *v9, *(void *)(a3 + 8), *(void *)(a3 + 16)) & 1) == 0)*v3++ = *v9; {
        ++v9;
        }
      }
      while (v9 != a2);
    }
  }
  return v3;
}

uint64_t sub_1CBFA5BF8(uint64_t a1, void *a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 2;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      uint64_t v7 = 0;
      uint64_t result = 0;
      goto LABEL_15;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v4 - 1);
  uint64_t v7 = (void *)(v3 + 16 * v6);
  uint64_t v8 = *v7;
  if (*a2 == *v7)
  {
    uint64_t result = 1;
  }
  else
  {
    int64x2_t v9 = 0;
    int v10 = 1;
    uint64_t result = 1;
    while (v8 != -4096)
    {
      if (v9) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -8192;
      }
      if (v12) {
        int64x2_t v9 = v7;
      }
      unsigned int v13 = v6 + v10++;
      unsigned int v6 = v13 & v5;
      uint64_t v7 = (void *)(v3 + 16 * (v13 & v5));
      uint64_t v8 = *v7;
      if (*a2 == *v7) {
        goto LABEL_15;
      }
    }
    uint64_t result = 0;
    if (v9) {
      uint64_t v7 = v9;
    }
  }
LABEL_15:
  *a3 = v7;
  return result;
}

void *sub_1CBFA5CA8(void *result)
{
  if ((*result & 4) != 0)
  {
    uint64_t v1 = (void **)(*result & 0xFFFFFFFFFFFFFFF8);
    if (v1)
    {
      uint64_t v2 = result;
      unint64_t v3 = *result & 0xFFFFFFFFFFFFFFF8;
      if (*v1 != v1 + 2) {
        free(*v1);
      }
      MEMORY[0x1D25D9CE0](v3, 0x1080C40ED926357);
      return v2;
    }
  }
  return result;
}

uint64_t *sub_1CBFA5D08(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  unint64_t v3 = a1;
  if (a1 != a2)
  {
    unsigned int v6 = a1;
    while (1)
    {
      uint64_t v7 = *v6++;
      if (llvm::AnalysisManager<llvm::Function>::Invalidator::invalidate(*(uint64_t **)a3, v7, *(void *)(a3 + 8), *(void *)(a3 + 16)))break; {
      unint64_t v3 = v6;
      }
      if (v6 == a2) {
        return a2;
      }
    }
    if (v6 != a2)
    {
      uint64_t v8 = v3 + 1;
      do
      {
        if ((llvm::AnalysisManager<llvm::Function>::Invalidator::invalidate(*(uint64_t **)a3, *v8, *(void *)(a3 + 8), *(void *)(a3 + 16)) & 1) == 0)*v3++ = *v8; {
        ++v8;
        }
      }
      while (v8 != a2);
    }
  }
  return v3;
}

uint64_t sub_1CBFA5DA4(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 4;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      uint64_t v7 = 0;
      uint64_t result = 0;
      goto LABEL_15;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = (v4 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v7 = (void *)(v3 + 16 * v6);
  uint64_t v8 = *v7;
  if (*v7 == a2)
  {
    uint64_t result = 1;
  }
  else
  {
    int64x2_t v9 = 0;
    int v10 = 1;
    uint64_t result = 1;
    while (v8 != -4096)
    {
      if (v9) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -8192;
      }
      if (v12) {
        int64x2_t v9 = v7;
      }
      unsigned int v13 = v6 + v10++;
      unsigned int v6 = v13 & v5;
      uint64_t v7 = (void *)(v3 + 16 * (v13 & v5));
      uint64_t v8 = *v7;
      if (*v7 == a2) {
        goto LABEL_15;
      }
    }
    uint64_t result = 0;
    if (v9) {
      uint64_t v7 = v9;
    }
  }
LABEL_15:
  *a3 = v7;
  return result;
}

uint64_t sub_1CBFA5E50(uint64_t a1, unsigned int a2)
{
  char v18[8] = *MEMORY[0x1E4F143B8];
  if (a2 >= 5)
  {
    unint64_t v6 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v7 = v6 | (v6 >> 2) | ((v6 | (v6 >> 2)) >> 4);
    int v8 = ((v7 | (v7 >> 8)) >> 16) | v7 | (v7 >> 8);
    if ((v8 + 1) > 0x40) {
      a2 = v8 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    int64x2_t v9 = *(uint64_t **)(a1 + 8);
    uint64_t v17 = a1;
    uint64_t v10 = *(unsigned int *)(a1 + 16);
    if (a2 > 4)
    {
      uint64_t v16 = a2;
      *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
      *(void *)(v17 + 16) = v16;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CBFA600C(v17, v9, &v9[2 * v10]);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v2 = 0;
  uint64_t v3 = v18;
  do
  {
    uint64_t v4 = *(void *)(a1 + v2 + 8);
    if (v4 != -8192 && v4 != -4096)
    {
      *uint64_t v3 = v4;
      v3[1] = *(void *)(a1 + v2 + 16);
      v3 += 2;
    }
    v2 += 16;
  }
  while (v2 != 64);
  if (a2 > 4)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v11 = a2;
    uint64_t v12 = a1;
    unsigned int v13 = v3;
    uint64_t v14 = operator new(16 * a2, (std::align_val_t)8uLL);
    uint64_t v3 = v13;
    uint64_t v15 = v14;
    a1 = v12;
    *(void *)(v12 + 8) = v15;
    *(void *)(v12 + 16) = v11;
  }
  return sub_1CBFA600C(a1, v18, v3);
}

uint64_t sub_1CBFA600C(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  int v3 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v3)
  {
    uint64_t v4 = (void *)(result + 8);
    int v5 = (void *)(result + 72);
  }
  else
  {
    uint64_t v6 = *(unsigned int *)(result + 16);
    if (!v6) {
      goto LABEL_4;
    }
    uint64_t v4 = *(void **)(result + 8);
    int v5 = &v4[2 * v6];
  }
  do
  {
    *uint64_t v4 = -4096;
    v4 += 2;
  }
  while (v4 != v5);
LABEL_4:
  if (a2 != a3)
  {
    do
    {
      unint64_t v7 = (_DWORD *)result;
      int v8 = a2;
      uint64_t v9 = *a2;
      if ((v9 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        unsigned int v13 = 0;
        sub_1CBFA5DA4(result, v9, &v13);
        uint64_t v10 = v13;
        uint64_t v11 = v8[1];
        *unsigned int v13 = *v8;
        v10[1] = v11;
        *v7 += 2;
      }
      a2 = v8 + 2;
      uint64_t result = (uint64_t)v7;
    }
    while (v8 + 2 != a3);
  }
  return result;
}

void *sub_1CBFA60E4@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v17 = 0;
  uint64_t result = (void *)sub_1CBFA61A8(a1, a2, &v17);
  uint64_t v9 = v17;
  if (result)
  {
    uint64_t v15 = a1 + 8;
    if (*(unsigned char *)a1)
    {
      uint64_t v16 = 4;
    }
    else
    {
      uint64_t v15 = *(void *)(a1 + 8);
      uint64_t v16 = *(unsigned int *)(a1 + 16);
    }
    char v14 = 0;
    uint64_t v13 = v15 + 16 * v16;
  }
  else
  {
    uint64_t result = sub_1CBFA6258((_DWORD *)a1, (uint64_t)a2, a2, v17);
    uint64_t v9 = result;
    uint64_t v10 = *a3;
    void *result = *a2;
    result[1] = v10;
    uint64_t v11 = a1 + 8;
    if (*(unsigned char *)a1)
    {
      uint64_t v12 = 4;
    }
    else
    {
      uint64_t v11 = *(void *)(a1 + 8);
      uint64_t v12 = *(unsigned int *)(a1 + 16);
    }
    uint64_t v13 = v11 + 16 * v12;
    char v14 = 1;
  }
  *(void *)a4 = v9;
  *(void *)(a4 + 8) = v13;
  *(unsigned char *)(a4 + 16) = v14;
  return result;
}

uint64_t sub_1CBFA61A8(uint64_t a1, void *a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 4;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      unint64_t v7 = 0;
      uint64_t result = 0;
      goto LABEL_15;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v4 - 1);
  unint64_t v7 = (void *)(v3 + 16 * v6);
  uint64_t v8 = *v7;
  if (*a2 == *v7)
  {
    uint64_t result = 1;
  }
  else
  {
    uint64_t v9 = 0;
    int v10 = 1;
    uint64_t result = 1;
    while (v8 != -4096)
    {
      if (v9) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -8192;
      }
      if (v12) {
        uint64_t v9 = v7;
      }
      unsigned int v13 = v6 + v10++;
      unsigned int v6 = v13 & v5;
      unint64_t v7 = (void *)(v3 + 16 * (v13 & v5));
      uint64_t v8 = *v7;
      if (*a2 == *v7) {
        goto LABEL_15;
      }
    }
    uint64_t result = 0;
    if (v9) {
      unint64_t v7 = v9;
    }
  }
LABEL_15:
  *a3 = v7;
  return result;
}

void *sub_1CBFA6258(_DWORD *a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *a1 >> 1;
  if (*a1) {
    unsigned int v7 = 4;
  }
  else {
    unsigned int v7 = a1[4];
  }
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - a1[1] > v7 >> 3)
  {
    goto LABEL_5;
  }
  sub_1CBFA6318((uint64_t)a1, v7);
  uint64_t v9 = 0;
  sub_1CBFA61A8((uint64_t)a1, a3, &v9);
  a4 = v9;
LABEL_5:
  *a1 += 2;
  if (*a4 != -4096) {
    --a1[1];
  }
  return a4;
}

uint64_t sub_1CBFA6318(uint64_t a1, unsigned int a2)
{
  char v18[8] = *MEMORY[0x1E4F143B8];
  if (a2 >= 5)
  {
    unint64_t v6 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v7 = v6 | (v6 >> 2) | ((v6 | (v6 >> 2)) >> 4);
    int v8 = ((v7 | (v7 >> 8)) >> 16) | v7 | (v7 >> 8);
    if ((v8 + 1) > 0x40) {
      a2 = v8 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    uint64_t v9 = *(void **)(a1 + 8);
    uint64_t v17 = a1;
    uint64_t v10 = *(unsigned int *)(a1 + 16);
    if (a2 > 4)
    {
      uint64_t v16 = a2;
      *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
      *(void *)(v17 + 16) = v16;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CBFA64D4(v17, v9, &v9[2 * v10]);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v2 = 0;
  uint64_t v3 = v18;
  do
  {
    uint64_t v4 = *(void *)(a1 + v2 + 8);
    if (v4 != -8192 && v4 != -4096)
    {
      *uint64_t v3 = v4;
      v3[1] = *(void *)(a1 + v2 + 16);
      v3 += 2;
    }
    v2 += 16;
  }
  while (v2 != 64);
  if (a2 > 4)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v11 = a2;
    uint64_t v12 = a1;
    unsigned int v13 = v3;
    char v14 = operator new(16 * a2, (std::align_val_t)8uLL);
    uint64_t v3 = v13;
    uint64_t v15 = v14;
    a1 = v12;
    *(void *)(v12 + 8) = v15;
    *(void *)(v12 + 16) = v11;
  }
  return sub_1CBFA64D4(a1, v18, v3);
}

uint64_t sub_1CBFA64D4(uint64_t result, void *a2, void *a3)
{
  int v3 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v3)
  {
    uint64_t v4 = (void *)(result + 8);
    int v5 = (void *)(result + 72);
  }
  else
  {
    uint64_t v6 = *(unsigned int *)(result + 16);
    if (!v6) {
      goto LABEL_4;
    }
    uint64_t v4 = *(void **)(result + 8);
    int v5 = &v4[2 * v6];
  }
  do
  {
    *uint64_t v4 = -4096;
    v4 += 2;
  }
  while (v4 != v5);
LABEL_4:
  if (a2 != a3)
  {
    do
    {
      unint64_t v7 = (_DWORD *)result;
      int v8 = a3;
      uint64_t v9 = a2;
      if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t v12 = 0;
        sub_1CBFA61A8(result, a2, &v12);
        uint64_t v10 = v12;
        uint64_t v11 = v9[1];
        *uint64_t v12 = *v9;
        v10[1] = v11;
        *v7 += 2;
      }
      a2 = v9 + 2;
      a3 = v8;
      uint64_t result = (uint64_t)v7;
    }
    while (v9 + 2 != v8);
  }
  return result;
}

void sub_1CBFA65B8(llvm::SmallPtrSetImplBase *this, uint64_t a2)
{
  uint64_t v5 = *((void *)this + 6);
  uint64_t v4 = *((void *)this + 7);
  if (v4 == v5)
  {
    uint64_t v6 = *((unsigned int *)this + 17);
    unint64_t v7 = (void *)(v4 + 8 * v6);
    if (v6)
    {
      uint64_t v8 = 0;
      uint64_t v9 = 8 * v6;
      while (*(void *)(v4 + v8) != a2)
      {
        v8 += 8;
        if (v9 == v8) {
          goto LABEL_6;
        }
      }
      unint64_t v7 = (void *)(v4 + v8);
    }
LABEL_6:
    uint64_t v5 = *((void *)this + 7);
  }
  else
  {
    uint64_t v32 = *((unsigned int *)this + 16);
    int v33 = v32 - 1;
    unsigned int v34 = (v32 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    unint64_t v7 = (void *)(v4 + 8 * v34);
    uint64_t v35 = *v7;
    if (*v7 == -1)
    {
      uint64_t v36 = 0;
LABEL_79:
      if (v36) {
        unint64_t v7 = v36;
      }
      if (*v7 != a2) {
        unint64_t v7 = (void *)(v4 + 8 * v32);
      }
    }
    else
    {
      uint64_t v36 = 0;
      int v37 = 1;
      while (v35 != a2)
      {
        if (v36) {
          BOOL v38 = 0;
        }
        else {
          BOOL v38 = v35 == -2;
        }
        if (v38) {
          uint64_t v36 = v7;
        }
        unsigned int v39 = v34 + v37++;
        unsigned int v34 = v39 & v33;
        unint64_t v7 = (void *)(v4 + 8 * (v39 & v33));
        uint64_t v35 = *v7;
        if (*v7 == -1) {
          goto LABEL_79;
        }
      }
    }
  }
  BOOL v30 = v4 == v5;
  uint64_t v10 = 64;
  if (v30) {
    uint64_t v10 = 68;
  }
  if (v7 == (void *)(v4 + 8 * *(unsigned int *)((char *)this + v10)))
  {
    int v11 = *((_DWORD *)this + 18);
  }
  else
  {
    *unint64_t v7 = -2;
    int v11 = *((_DWORD *)this + 18) + 1;
    *((_DWORD *)this + 18) = v11;
  }
  uint64_t v13 = *(void *)this;
  uint64_t v12 = *((void *)this + 1);
  if (*((_DWORD *)this + 17) != v11) {
    goto LABEL_21;
  }
  if (v12 == v13)
  {
    uint64_t v14 = *((unsigned int *)this + 5);
    uint64_t v15 = (void **)(v12 + 8 * v14);
    if (v14)
    {
      uint64_t v16 = 0;
      uint64_t v17 = 8 * v14;
      while (*(_UNKNOWN **)(v12 + v16) != &llvm::PreservedAnalyses::AllAnalysesKey)
      {
        v16 += 8;
        if (v17 == v16) {
          goto LABEL_17;
        }
      }
      uint64_t v15 = (void **)(v12 + v16);
    }
LABEL_17:
    uint64_t v13 = *((void *)this + 1);
  }
  else
  {
    uint64_t v40 = *((unsigned int *)this + 4);
    int v41 = v40 - 1;
    unsigned int v42 = (v40 - 1) & ((&llvm::PreservedAnalyses::AllAnalysesKey >> 4) ^ (&llvm::PreservedAnalyses::AllAnalysesKey >> 9));
    uint64_t v15 = (void **)(v12 + 8 * v42);
    uint64_t v43 = *v15;
    if (*v15 == (void *)-1)
    {
      uint64_t v44 = 0;
LABEL_84:
      if (v44) {
        uint64_t v15 = v44;
      }
      if (*v15 != &llvm::PreservedAnalyses::AllAnalysesKey) {
        uint64_t v15 = (void **)(v12 + 8 * v40);
      }
    }
    else
    {
      uint64_t v44 = 0;
      int v45 = 1;
      while (v43 != &llvm::PreservedAnalyses::AllAnalysesKey)
      {
        if (v44) {
          BOOL v46 = 0;
        }
        else {
          BOOL v46 = v43 == (void *)-2;
        }
        if (v46) {
          uint64_t v44 = v15;
        }
        unsigned int v47 = v42 + v45++;
        unsigned int v42 = v47 & v41;
        uint64_t v15 = (void **)(v12 + 8 * (v47 & v41));
        uint64_t v43 = *v15;
        if (*v15 == (void *)-1) {
          goto LABEL_84;
        }
      }
    }
  }
  uint64_t v18 = 16;
  if (v12 == v13) {
    uint64_t v18 = 20;
  }
  if (v15 == (void **)(v12 + 8 * *(unsigned int *)((char *)this + v18)))
  {
LABEL_21:
    uint64_t v19 = *((unsigned int *)this + 5);
    if (v12 == v13)
    {
      if (v19)
      {
        BOOL v20 = 0;
        uint64_t v21 = 8 * v19;
        unsigned int v22 = (void *)*((void *)this + 1);
        while (*v22 != a2)
        {
          if (*v22 == -2) {
            BOOL v20 = v22;
          }
          ++v22;
          v21 -= 8;
          if (!v21)
          {
            if (!v20) {
              goto LABEL_29;
            }
            *BOOL v20 = a2;
            --*((_DWORD *)this + 6);
            return;
          }
        }
        return;
      }
LABEL_29:
      unsigned int v23 = *((_DWORD *)this + 4);
      if (v19 < v23)
      {
        *((_DWORD *)this + 5) = v19 + 1;
        *(void *)(v12 + 8 * v19) = a2;
        return;
      }
    }
    else
    {
      unsigned int v23 = *((_DWORD *)this + 4);
    }
    if (3 * v23 <= 4 * ((int)v19 - *((_DWORD *)this + 6)))
    {
      if (v23 >= 0x40) {
        v23 *= 2;
      }
      else {
        unsigned int v23 = 128;
      }
    }
    else if (v23 - v19 >= v23 >> 3)
    {
      goto LABEL_35;
    }
    llvm::SmallPtrSetImplBase::Grow(this, v23);
    unsigned int v23 = *((_DWORD *)this + 4);
    uint64_t v12 = *((void *)this + 1);
LABEL_35:
    unsigned int v24 = v23 - 1;
    unsigned int v25 = (v23 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    int v26 = (void *)(v12 + 8 * v25);
    uint64_t v27 = *v26;
    if (*v26 == -1)
    {
      uint64_t v28 = 0;
LABEL_71:
      if (v28) {
        uint64_t v48 = v28;
      }
      else {
        uint64_t v48 = v26;
      }
      if (*v48 != a2)
      {
        if (*v48 == -2) {
          --*((_DWORD *)this + 6);
        }
        else {
          ++*((_DWORD *)this + 5);
        }
        *uint64_t v48 = a2;
      }
    }
    else
    {
      uint64_t v28 = 0;
      int v29 = 1;
      while (v27 != a2)
      {
        if (v28) {
          BOOL v30 = 0;
        }
        else {
          BOOL v30 = v27 == -2;
        }
        if (v30) {
          uint64_t v28 = v26;
        }
        unsigned int v31 = v25 + v29++;
        unsigned int v25 = v31 & v24;
        int v26 = (void *)(v12 + 8 * (v31 & v24));
        uint64_t v27 = *v26;
        if (*v26 == -1) {
          goto LABEL_71;
        }
      }
    }
  }
}

uint64_t sub_1CBFA693C(uint64_t result, uint64_t a2)
{
  if (*(void *)result)
  {
    if (*(_DWORD *)(*(void *)result + 728))
    {
      (*(void (**)(uint64_t))(*(void *)a2 + 24))(a2);
      uint64_t v2 = 0;
      operator new();
    }
  }
  return result;
}

uint64_t sub_1CBFA6A90(uint64_t result, uint64_t a2)
{
  if (*(void *)result)
  {
    if (*(_DWORD *)(*(void *)result + 872))
    {
      (*(void (**)(uint64_t))(*(void *)a2 + 24))(a2);
      uint64_t v2 = 0;
      operator new();
    }
  }
  return result;
}

uint64_t sub_1CBFA6BE4@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v12 = 0;
  uint64_t result = sub_1CBF5C064((uint64_t *)a1, a2, &v12);
  uint64_t v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CBFA6C84(a1, (uint64_t)a2, a2, v12);
    uint64_t v9 = (void *)result;
    *(void *)uint64_t result = *a2;
    *(void *)(result + 8) = a2[1];
    *(void *)(result + 16) = *a3;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a1 + 24 * *(unsigned int *)(a1 + 16);
  *(void *)a4 = v9;
  *(void *)(a4 + 8) = v11;
  *(unsigned char *)(a4 + 16) = v10;
  return result;
}

void *sub_1CBFA6C84(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
    goto LABEL_8;
  }
  if (v7 + ~v6 - *(_DWORD *)(a1 + 12) <= v7 >> 3)
  {
LABEL_8:
    sub_1CBFA590C(a1, v7);
    uint64_t v9 = 0;
    sub_1CBF5C064((uint64_t *)a1, a3, &v9);
    a4 = v9;
  }
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096 || a4[1] != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void sub_1CBFA6D44()
{
}

void sub_1CBFA6D58()
{
}

void *sub_1CBFA6DB8()
{
  return &llvm::Any::TypeId<llvm::Function const*>::Id;
}

void *sub_1CBFA6DC4(uint64_t *a1, void *a2)
{
  unsigned int v7 = 0;
  char v4 = sub_1CBC610E0(a1, a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CBFA6E30((uint64_t)a1, (uint64_t)a2, a2, v7);
    *uint64_t v5 = *a2;
    v5[1] = v5 + 1;
    void v5[2] = v5 + 1;
    v5[3] = 0;
  }
  return v5;
}

void *sub_1CBFA6E30(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CBFA6EE4(a1, v7);
  uint64_t v9 = 0;
  sub_1CBC610E0((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CBFA6EE4(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  char v4 = *(void **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(32 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CBFA6FB0(a1, v4, &v4[4 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 32 * v10;
    do
    {
      void *result = -4096;
      result += 4;
      v11 -= 32;
    }
    while (v11);
  }
  return result;
}

void sub_1CBFA6FB0(uint64_t a1, void *a2, void *a3)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6)
  {
    int v7 = *(void **)a1;
    uint64_t v8 = 32 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 4;
      v8 -= 32;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v16 = 0;
      sub_1CBC610E0((uint64_t *)a1, a2, &v16);
      uint64_t v9 = v16;
      uint64_t v10 = v16 + 1;
      *uint64_t v16 = *a2;
      v9[1] = v10;
      v9[2] = v10;
      v9[3] = 0;
      uint64_t v11 = a2[3];
      if (v11)
      {
        uint64_t v13 = a2[1];
        uint64_t v12 = (uint64_t *)a2[2];
        uint64_t v14 = *v12;
        *(void *)(v14 + 8) = *(void *)(v13 + 8);
        **(void **)(v13 + 8) = v14;
        uint64_t v15 = v9[1];
        *(void *)(v15 + 8) = v12;
        *uint64_t v12 = v15;
        v9[1] = v13;
        *(void *)(v13 + 8) = v10;
        v9[3] = v11;
        a2[3] = 0;
      }
      ++*(_DWORD *)(a1 + 8);
      sub_1CBF5408C(a2 + 1);
    }
    a2 += 4;
  }
}

uint64_t sub_1CBFA70A4(uint64_t result, uint64_t a2)
{
  if (*(void *)result)
  {
    if (*(_DWORD *)(*(void *)result + 1016))
    {
      (*(void (**)(uint64_t))(*(void *)a2 + 24))(a2);
      uint64_t v2 = 0;
      operator new();
    }
  }
  return result;
}

uint64_t sub_1CBFA71F8(uint64_t a1, uint64_t *__p)
{
  uint64_t v3 = *__p;
  uint64_t v4 = __p[1];
  *(void *)(v3 + 8) = v4;
  *(void *)__p[1] = v3;
  --*(void *)(a1 + 16);
  uint64_t v5 = __p[3];
  __p[3] = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  operator delete(__p);
  return v4;
}

uint64_t sub_1CBFA7270(uint64_t a1, void *a2)
{
  uint64_t v6 = 0;
  uint64_t v3 = sub_1CBC610E0((uint64_t *)a1, a2, &v6);
  if (v3)
  {
    uint64_t v4 = v6;
    sub_1CBF5408C(v6 + 1);
    *uint64_t v4 = -8192;
    *(int32x2_t *)(a1 + 8) = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
  }
  return v3;
}

uint64_t sub_1CBFA72E0()
{
  *(void *)&long long v1 = "Abort when the max iterations for devirtualization CGSCC repeat pass is reached";
  *((void *)&v1 + 1) = 79;
  sub_1CD46E898(&v1);

  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCC4860, &dword_1CB82C000);
}

void llvm::CallGraph::CallGraph(llvm::CallGraph *this, llvm::Module *a2)
{
  *((void *)this + 2) = 0;
  *(void *)this = a2;
  *((void *)this + 1) = (char *)this + 16;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 3) = 0;
  *((_DWORD *)this + 12) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 10) = llvm::CallGraph::getOrInsertFunction(this, 0);
  operator new();
}

uint64_t *llvm::CallGraph::getOrInsertFunction(llvm::CallGraph *this, const llvm::Function *a2)
{
  uint64_t v5 = (char *)this + 16;
  uint64_t v4 = (uint64_t *)*((void *)this + 2);
  uint64_t v6 = (uint64_t **)((char *)this + 16);
  int v7 = (uint64_t **)((char *)this + 16);
  if (v4)
  {
    do
    {
      while (1)
      {
        int v7 = (uint64_t **)v4;
        unint64_t v8 = v4[4];
        if (v8 <= (unint64_t)a2) {
          break;
        }
        uint64_t v4 = *v7;
        uint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_7;
        }
      }
      if (v8 >= (unint64_t)a2) {
        goto LABEL_10;
      }
      uint64_t v4 = v7[1];
    }
    while (v4);
    uint64_t v6 = v7 + 1;
  }
LABEL_7:
  uint64_t v9 = (uint64_t *)operator new(0x30uLL);
  v12[0] = v9;
  v12[1] = v5;
  v9[4] = (uint64_t)a2;
  v9[5] = 0;
  char v13 = 1;
  *uint64_t v9 = 0;
  v9[1] = 0;
  v9[2] = (uint64_t)v7;
  *uint64_t v6 = v9;
  uint64_t v10 = **((void **)this + 1);
  if (v10)
  {
    *((void *)this + 1) = v10;
    uint64_t v9 = *v6;
  }
  sub_1CB8358B8(*((uint64_t **)this + 2), v9);
  ++*((void *)this + 3);
  int v7 = (uint64_t **)v12[0];
  v12[0] = 0;
  sub_1CBFADFB8((uint64_t)v12, 0);
LABEL_10:
  uint64_t result = v7[5];
  if (!result) {
    operator new();
  }
  return result;
}

void llvm::CallGraph::addToCallGraph(llvm::CallGraph *this, llvm::Function *a2)
{
  inserted = llvm::CallGraph::getOrInsertFunction(this, a2);
  if ((*((_DWORD *)a2 + 8) & 0xFu) - 7 > 1 || llvm::Function::hasAddressTaken(a2, 0, 1, 1, 0, 0))
  {
    uint64_t v5 = *((void *)this + 10);
    unsigned int v22 = inserted;
    long long v20 = 0u;
    long long v21 = 0u;
    unint64_t v6 = *(void *)(v5 + 24);
    if (v6 >= *(void *)(v5 + 32))
    {
      int v7 = sub_1CBFA9300((char **)(v5 + 16), (uint64_t)&v20, &v22);
      int v8 = BYTE8(v21);
      *(void *)(v5 + 24) = v7;
      if (v8 && (void)v21 != -8192 && (void)v21 != -4096 && (void)v21)
      {
        unint64_t v9 = v20 & 0xFFFFFFFFFFFFFFF8;
        *(void *)(v20 & 0xFFFFFFFFFFFFFFF8) = *((void *)&v20 + 1);
        if (*((void *)&v20 + 1))
        {
          **((void **)&v20 + 1) = **((void **)&v20 + 1) & 7 | v9;
        }
        else
        {
          uint64_t v10 = v21;
          uint64_t v11 = ***(int32x2_t ****)v21;
          unint64_t v12 = (unint64_t)v11[303];
          if (v12 <= v9)
          {
            uint64_t v13 = v11[305].u32[0];
            if (v12 + 16 * v13 > v9)
            {
              unsigned int v14 = v13 - 1;
              LODWORD(v15) = v14 & ((v21 >> 4) ^ (v21 >> 9));
              uint64_t v16 = (uint64_t *)(v12 + 16 * v15);
              uint64_t v17 = *v16;
              if ((void)v21 == *v16)
              {
LABEL_18:
                *uint64_t v16 = -8192;
                v11[304] = vadd_s32(v11[304], (int32x2_t)0x1FFFFFFFFLL);
                uint64_t v10 = v21;
              }
              else
              {
                int v18 = 1;
                while (v17 != -4096)
                {
                  int v19 = v15 + v18++;
                  uint64_t v15 = v19 & v14;
                  uint64_t v17 = *(void *)(v12 + 16 * v15);
                  if ((void)v21 == v17)
                  {
                    uint64_t v16 = (uint64_t *)(v12 + 16 * v15);
                    goto LABEL_18;
                  }
                }
              }
              *(unsigned char *)(v10 + 17) &= ~1u;
            }
          }
        }
      }
    }
    else
    {
      *(unsigned char *)unint64_t v6 = 0;
      *(unsigned char *)(v6 + 24) = 0;
      *(void *)(v6 + 32) = inserted;
      *(void *)(v5 + 24) = v6 + 40;
    }
    ++*((_DWORD *)v22 + 10);
  }
  llvm::CallGraph::populateCallGraphNode(this, (llvm::CallGraphNode *)inserted);
}

uint64_t llvm::CallGraph::CallGraph(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  uint64_t v4 = (void *)(a2 + 8);
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  unint64_t v6 = (void *)(a2 + 16);
  uint64_t v5 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v5;
  int v7 = (void *)(a1 + 16);
  uint64_t v8 = *(void *)(a2 + 24);
  *(void *)(a1 + 24) = v8;
  if (v8)
  {
    *(void *)(v5 + 16) = v7;
    *uint64_t v4 = v6;
    *unint64_t v6 = 0;
    *(void *)(a2 + 24) = 0;
  }
  else
  {
    *(void *)(a1 + 8) = v7;
  }
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = 0;
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a2 + 40) = 0;
  int v9 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 44);
  *(_DWORD *)(a2 + 44) = v9;
  int v10 = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a2 + 48) = v10;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 72) = 0;
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  uint64_t v11 = *(void *)(a2 + 88);
  *(void *)(a2 + 88) = 0;
  *(void *)(a1 + 88) = v11;
  sub_1CBFA9C10((uint64_t)v4, *(void **)(a2 + 16));
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 8) = v6;
  *(void *)(a2 + 80) = 0;
  **(void **)(a1 + 88) = a1;
  unint64_t v12 = *(void **)(a1 + 8);
  if (v12 != v7)
  {
    do
    {
      *(void *)v12[5] = a1;
      uint64_t v13 = (void *)v12[1];
      if (v13)
      {
        do
        {
          unsigned int v14 = v13;
          uint64_t v13 = (void *)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          unsigned int v14 = (void *)v12[2];
          BOOL v15 = *v14 == (void)v12;
          unint64_t v12 = v14;
        }
        while (!v15);
      }
      unint64_t v12 = v14;
    }
    while (v14 != v7);
  }
  return a1;
}

void llvm::CallGraph::~CallGraph(llvm::CallGraph *this)
{
  uint64_t v4 = *((void *)this + 11);
  uint64_t v2 = (void *)((char *)this + 88);
  uint64_t v3 = v4;
  if (v4)
  {
    *(_DWORD *)(v3 + 40) = 0;
    *uint64_t v2 = 0;
    sub_1CBFA9BA8((uint64_t)v2, v3);
  }
  else
  {
    *uint64_t v2 = 0;
  }
  uint64_t v5 = (void **)((char *)this + 56);
  sub_1CBFA9268(&v5);
  MEMORY[0x1D25D9CD0](*((void *)this + 4), 8);
  sub_1CBFA9C10((uint64_t)this + 8, *((void **)this + 2));
}

BOOL llvm::CallGraph::invalidate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v18[0] = (void **)a3;
  v18[1] = (void **)&llvm::CallGraphAnalysis::Key;
  uint64_t v4 = *(void *)(a3 + 48);
  uint64_t v3 = *(void *)(a3 + 56);
  if (v3 == v4)
  {
    uint64_t v5 = *(unsigned int *)(a3 + 68);
    unint64_t v6 = (void **)(v3 + 8 * v5);
    if (v5)
    {
      uint64_t v7 = 0;
      while (*(_UNKNOWN **)(v3 + v7) != &llvm::CallGraphAnalysis::Key)
      {
        v7 += 8;
        if (8 * v5 == v7) {
          goto LABEL_6;
        }
      }
      unint64_t v6 = (void **)(v3 + v7);
    }
LABEL_6:
    uint64_t v4 = *(void *)(a3 + 56);
  }
  else
  {
    uint64_t v10 = *(unsigned int *)(a3 + 64);
    int v11 = v10 - 1;
    unsigned int v12 = (v10 - 1) & ((&llvm::CallGraphAnalysis::Key >> 4) ^ (&llvm::CallGraphAnalysis::Key >> 9));
    unint64_t v6 = (void **)(v3 + 8 * v12);
    uint64_t v13 = *v6;
    if (*v6 == (void *)-1)
    {
      unsigned int v14 = 0;
LABEL_27:
      if (v14) {
        unint64_t v6 = v14;
      }
      if (*v6 != &llvm::CallGraphAnalysis::Key)
      {
        LODWORD(v5) = *(_DWORD *)(a3 + 68);
        unint64_t v6 = (void **)(v3 + 8 * v10);
        goto LABEL_7;
      }
    }
    else
    {
      unsigned int v14 = 0;
      int v15 = 1;
      while (v13 != &llvm::CallGraphAnalysis::Key)
      {
        if (v14) {
          BOOL v16 = 0;
        }
        else {
          BOOL v16 = v13 == (void *)-2;
        }
        if (v16) {
          unsigned int v14 = v6;
        }
        unsigned int v17 = v12 + v15++;
        unsigned int v12 = v17 & v11;
        unint64_t v6 = (void **)(v3 + 8 * (v17 & v11));
        uint64_t v13 = *v6;
        if (*v6 == (void *)-1) {
          goto LABEL_27;
        }
      }
    }
    LODWORD(v5) = *(_DWORD *)(a3 + 68);
  }
LABEL_7:
  if (v3 == v4) {
    unsigned int v8 = v5;
  }
  else {
    unsigned int v8 = *(_DWORD *)(a3 + 64);
  }
  BOOL v19 = v6 != (void **)(v3 + 8 * v8);
  return !sub_1CBF75724(v18) && !sub_1CBFA10B0((uint64_t)v18) && !sub_1CBF75B60((uint64_t)v18);
}

char *sub_1CBFA7A30(uint64_t a1, int32x2_t ****a2, uint64_t a3)
{
  uint64_t v38 = a3;
  if (a2)
  {
    uint64_t v33 = 6;
    unsigned int v34 = 0;
    uint64_t v35 = a2;
    if (a2 == (int32x2_t ****)-8192 || a2 == (int32x2_t ****)-4096)
    {
      unsigned int v8 = a2;
    }
    else
    {
      llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v33);
      unsigned int v8 = v35;
    }
    long long v36 = 6uLL;
    *(void *)&long long v37 = v8;
    if (v8 != (int32x2_t ****)-8192 && v8 != (int32x2_t ****)-4096)
    {
      if (v8)
      {
        unint64_t v9 = v33 & 0xFFFFFFFFFFFFFFF8;
        *((void *)&v36 + 1) = *(void *)(v33 & 0xFFFFFFFFFFFFFFF8);
        *(void *)unint64_t v9 = &v36;
        *(void *)&long long v36 = v9 | 6;
        if (*((void *)&v36 + 1)) {
          **((void **)&v36 + 1) = **((void **)&v36 + 1) & 7 | ((unint64_t)&v36 + 8);
        }
      }
    }
    BYTE8(v37) = 1;
  }
  else
  {
    long long v36 = 0u;
    long long v37 = 0u;
  }
  unint64_t v6 = *(void *)(a1 + 24);
  if (v6 >= *(void *)(a1 + 32))
  {
    uint64_t result = sub_1CBFA9300((char **)(a1 + 16), (uint64_t)&v36, &v38);
  }
  else
  {
    *(unsigned char *)unint64_t v6 = 0;
    *(unsigned char *)(v6 + 24) = 0;
    if (BYTE8(v37)) {
      sub_1CBFA9590((llvm::ValueHandleBase *)v6, &v36);
    }
    *(void *)(v6 + 32) = a3;
    uint64_t result = (char *)(v6 + 40);
  }
  *(void *)(a1 + 24) = result;
  if (BYTE8(v37))
  {
    if ((void)v37 != -8192 && (void)v37 != -4096 && (void)v37)
    {
      unint64_t v10 = v36 & 0xFFFFFFFFFFFFFFF8;
      *(void *)(v36 & 0xFFFFFFFFFFFFFFF8) = *((void *)&v36 + 1);
      if (*((void *)&v36 + 1))
      {
        **((void **)&v36 + 1) = **((void **)&v36 + 1) & 7 | v10;
      }
      else
      {
        uint64_t v11 = v37;
        unsigned int v12 = ***(int32x2_t ****)v37;
        unint64_t v13 = (unint64_t)v12[303];
        if (v13 <= v10)
        {
          uint64_t v14 = v12[305].u32[0];
          if (v13 + 16 * v14 > v10)
          {
            unsigned int v15 = v14 - 1;
            LODWORD(v16) = v15 & ((v37 >> 4) ^ (v37 >> 9));
            unsigned int v17 = (uint64_t *)(v13 + 16 * v16);
            uint64_t v18 = *v17;
            if ((void)v37 == *v17)
            {
LABEL_31:
              uint64_t *v17 = -8192;
              v12[304] = vadd_s32(v12[304], (int32x2_t)0x1FFFFFFFFLL);
              uint64_t v11 = v37;
            }
            else
            {
              int v19 = 1;
              while (v18 != -4096)
              {
                int v20 = v16 + v19++;
                uint64_t v16 = v20 & v15;
                uint64_t v18 = *(void *)(v13 + 16 * v16);
                if ((void)v37 == v18)
                {
                  unsigned int v17 = (uint64_t *)(v13 + 16 * v16);
                  goto LABEL_31;
                }
              }
            }
            *(unsigned char *)(v11 + 17) &= ~1u;
          }
        }
      }
    }
    BYTE8(v37) = 0;
  }
  if (a2 && v35 != (int32x2_t ****)-8192 && v35 != (int32x2_t ****)-4096 && v35 != 0)
  {
    unint64_t v22 = v33 & 0xFFFFFFFFFFFFFFF8;
    *(void *)(v33 & 0xFFFFFFFFFFFFFFF8) = v34;
    if (v34)
    {
      *unsigned int v34 = *v34 & 7 | v22;
    }
    else
    {
      unsigned int v23 = v35;
      unsigned int v24 = ***v35;
      unint64_t v25 = (unint64_t)v24[303];
      if (v25 <= v22)
      {
        uint64_t v26 = v24[305].u32[0];
        if (v25 + 16 * v26 > v22)
        {
          unsigned int v27 = v26 - 1;
          LODWORD(v28) = v27 & ((v35 >> 4) ^ (v35 >> 9));
          int v29 = (int32x2_t *****)(v25 + 16 * v28);
          BOOL v30 = *v29;
          if (v35 == *v29)
          {
LABEL_46:
            *int v29 = (int32x2_t ****)-8192;
            v24[304] = vadd_s32(v24[304], (int32x2_t)0x1FFFFFFFFLL);
            unsigned int v23 = v35;
          }
          else
          {
            int v31 = 1;
            while (v30 != (int32x2_t ****)-4096)
            {
              int v32 = v28 + v31++;
              uint64_t v28 = v32 & v27;
              BOOL v30 = *(int32x2_t *****)(v25 + 16 * v28);
              if (v35 == v30)
              {
                int v29 = (int32x2_t *****)(v25 + 16 * v28);
                goto LABEL_46;
              }
            }
          }
          *((unsigned char *)v23 + 17) &= ~1u;
        }
      }
    }
  }
  ++*(_DWORD *)(v38 + 40);
  return result;
}

void llvm::CallGraph::populateCallGraphNode(llvm::CallGraph *this, llvm::CallGraphNode *a2)
{
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *((void *)a2 + 1);
  if (v3) {
    BOOL v4 = *(unsigned char *)(v3 + 16) == 3;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4)
  {
    if ((*(_DWORD *)(v3 + 20) & 0x7FFFFFF) != 0) {
      goto LABEL_12;
    }
    int v5 = *(_DWORD *)(v3 + 32);
  }
  else
  {
    if (*(unsigned char *)(v3 + 16)) {
      goto LABEL_12;
    }
    if (*(void *)(v3 + 72) != v3 + 72) {
      goto LABEL_12;
    }
    int v5 = *(_DWORD *)(v3 + 32);
    if ((v5 & 0x800000) != 0) {
      goto LABEL_12;
    }
  }
  if ((v5 & 0x2000) == 0)
  {
    unsigned int v39 = (llvm::CallBase *)*((void *)this + 11);
    uint64_t v58 = v39;
    *(_OWORD *)uint64_t v60 = 0u;
    v61[0] = 0u;
    unint64_t v40 = *((void *)a2 + 3);
    if (v40 >= *((void *)a2 + 4))
    {
      int v41 = sub_1CBFA9300((char **)a2 + 2, (uint64_t)v60, &v58);
    }
    else
    {
      *(unsigned char *)unint64_t v40 = 0;
      *(unsigned char *)(v40 + 24) = 0;
      if (BYTE8(v61[0])) {
        sub_1CBFA9590((llvm::ValueHandleBase *)v40, v60);
      }
      *(void *)(v40 + 32) = v39;
      int v41 = (char *)(v40 + 40);
    }
    *((void *)a2 + 3) = v41;
    if (BYTE8(v61[0]) && *(void *)&v61[0] != -8192 && *(void *)&v61[0] != -4096 && *(void *)&v61[0])
    {
      unint64_t v42 = (unint64_t)v60[0] & 0xFFFFFFFFFFFFFFF8;
      *(void **)((unint64_t)v60[0] & 0xFFFFFFFFFFFFFFF8) = v60[1];
      if (v60[1])
      {
        *(void *)v60[1] = *(void *)v60[1] & 7 | v42;
      }
      else
      {
        uint64_t v43 = *(void *)&v61[0];
        uint64_t v44 = ****(int32x2_t *****)&v61[0];
        unint64_t v45 = (unint64_t)v44[303];
        if (v45 <= v42)
        {
          uint64_t v46 = v44[305].u32[0];
          if (v45 + 16 * v46 > v42)
          {
            unsigned int v47 = v46 - 1;
            LODWORD(v48) = v47 & ((LODWORD(v61[0]) >> 4) ^ (LODWORD(v61[0]) >> 9));
            uint64_t v49 = (uint64_t *)(v45 + 16 * v48);
            uint64_t v50 = *v49;
            if (*(void *)&v61[0] == *v49)
            {
LABEL_90:
              *uint64_t v49 = -8192;
              v44[304] = vadd_s32(v44[304], (int32x2_t)0x1FFFFFFFFLL);
              uint64_t v43 = *(void *)&v61[0];
            }
            else
            {
              int v51 = 1;
              while (v50 != -4096)
              {
                int v52 = v48 + v51++;
                uint64_t v48 = v52 & v47;
                uint64_t v50 = *(void *)(v45 + 16 * v48);
                if (*(void *)&v61[0] == v50)
                {
                  uint64_t v49 = (uint64_t *)(v45 + 16 * v48);
                  goto LABEL_90;
                }
              }
            }
            *(unsigned char *)(v43 + 17) &= ~1u;
          }
        }
      }
    }
    ++*((_DWORD *)v58 + 10);
  }
LABEL_12:
  int v56 = a2;
  uint64_t v6 = v3 + 72;
  uint64_t v7 = *(void *)(v3 + 80);
  if (v7 != v3 + 72)
  {
    do
    {
      uint64_t v8 = v7 - 24;
      if (!v7) {
        uint64_t v8 = 0;
      }
      uint64_t v9 = v8 + 40;
      for (uint64_t i = *(void *)(v8 + 48); i != v9; uint64_t i = *(void *)(i + 8))
      {
        if (i) {
          uint64_t v11 = (_DWORD *)(i - 24);
        }
        else {
          uint64_t v11 = 0;
        }
        unsigned int v12 = *((unsigned __int8 *)v11 + 16) - 33;
        BOOL v13 = v12 > 0x33;
        uint64_t v14 = (1 << v12) & 0x8000000000041;
        if (v13 || v14 == 0) {
          continue;
        }
        uint64_t v16 = *(void *)(i - 56);
        if (!v16 || *(unsigned char *)(v16 + 16) || *(void *)(v16 + 24) != *(void *)(i + 48)) {
          uint64_t v16 = 0;
        }
        if ((v11[5] & 0x20000000) == 0) {
          goto LABEL_30;
        }
        uint64_t v23 = ***(void ***)v11;
        v60[0] = v11;
        int v24 = *(_DWORD *)(v23 + 2496);
        if (!v24)
        {
          long long v37 = 0;
LABEL_68:
          uint64_t v28 = sub_1CC609054(v23 + 2480, (uint64_t)v60, (uint64_t *)v60, v37);
          uint64_t v38 = v60[0];
          v28[4] = 0;
          v28[3] = 0;
          void *v28 = v38;
          v28[1] = v28 + 3;
          void v28[2] = 0x100000000;
          goto LABEL_45;
        }
        uint64_t v25 = *(void *)(v23 + 2480);
        int v26 = v24 - 1;
        unsigned int v27 = v26 & ((v11 >> 4) ^ (v11 >> 9));
        uint64_t v28 = (void *)(v25 + 40 * v27);
        int v29 = (void *)*v28;
        if ((_DWORD *)*v28 != v11)
        {
          int v31 = 0;
          int v32 = 1;
          while (v29 != (void *)-4096)
          {
            if (v31) {
              BOOL v33 = 0;
            }
            else {
              BOOL v33 = v29 == (void *)-8192;
            }
            if (v33) {
              int v31 = v28;
            }
            unsigned int v34 = v27 + v32++;
            unsigned int v27 = v34 & v26;
            uint64_t v28 = (void *)(v25 + 40 * v27);
            int v29 = (void *)*v28;
            if ((_DWORD *)*v28 == v11) {
              goto LABEL_45;
            }
          }
          if (v31) {
            long long v37 = v31;
          }
          else {
            long long v37 = v28;
          }
          goto LABEL_68;
        }
LABEL_45:
        uint64_t v30 = *((unsigned int *)v28 + 4);
        if (v30)
        {
          long long v21 = (llvm::MDNode **)(v28[1] + 8);
          uint64_t v22 = 16 * v30;
          while (*((_DWORD *)v21 - 2) != 23)
          {
            v21 += 2;
            v22 -= 16;
            if (!v22) {
              goto LABEL_30;
            }
          }
          if (!v16 && *v21)
          {
            inserted = (uint64_t *)llvm::CallGraph::getOrInsertNodeForCalleesMD(this, *v21);
            goto LABEL_63;
          }
        }
LABEL_30:
        if (!v16
          || ((v17 = *(_DWORD *)(v16 + 36) - 124, BOOL v13 = v17 > 4, v18 = (1 << v17) & 0x19, !v13)
            ? (BOOL v19 = v18 == 0)
            : (BOOL v19 = 1),
              !v19))
        {
          uint64_t v36 = *((void *)this + 11);
          goto LABEL_64;
        }
        if ((*(unsigned char *)(v16 + 33) & 0x20) == 0)
        {
          inserted = llvm::CallGraph::getOrInsertFunction(this, (const llvm::Function *)v16);
LABEL_63:
          uint64_t v36 = (uint64_t)inserted;
LABEL_64:
          sub_1CBFA7A30((uint64_t)v56, (int32x2_t ****)(i - 24), v36);
        }
        v60[0] = v61;
        v60[1] = (void *)0x400000000;
        llvm::AbstractCallSite::getCallbackUses((uint64_t ****)(i - 24), (uint64_t)v60);
        int v20 = (const llvm::Use **)v60[0];
        if (LODWORD(v60[1]))
        {
          uint64_t v53 = 8 * LODWORD(v60[1]);
          do
          {
            llvm::AbstractCallSite::AbstractCallSite((llvm::AbstractCallSite *)&v58, *v20);
            unint64_t v54 = sub_1CD46F814(&v58);
            if (v54)
            {
              unsigned int v55 = llvm::CallGraph::getOrInsertFunction(this, v54);
              sub_1CBFA7A30((uint64_t)v56, 0, (uint64_t)v55);
            }
            if (v59 != v60) {
              free(v59);
            }
            ++v20;
            v53 -= 8;
          }
          while (v53);
          int v20 = (const llvm::Use **)v60[0];
        }
        if (v20 != (const llvm::Use **)v61) {
          free(v20);
        }
      }
      uint64_t v7 = *(void *)(v7 + 8);
    }
    while (v7 != v6);
  }
}

uint64_t llvm::CallGraph::getOrInsertNodeForCalleesMD(llvm::CallGraph *this, llvm::MDNode *a2)
{
  uint64_t v6 = *((void *)this + 4);
  BOOL v4 = (char *)this + 32;
  uint64_t v5 = v6;
  uint64_t v25 = a2;
  int v26 = 0;
  int v7 = *((_DWORD *)v4 + 4);
  if (v7)
  {
    unsigned int v8 = v7 - 1;
    uint64_t v9 = (v7 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    unint64_t v10 = (llvm::MDNode **)(v5 + 16 * v9);
    uint64_t v11 = *v10;
    if (*v10 == a2)
    {
LABEL_11:
      unsigned int v16 = *(_DWORD *)(v5 + 16 * v9 + 8);
      uint64_t v17 = *((void *)this + 7);
      goto LABEL_12;
    }
    unsigned int v12 = 0;
    int v13 = 1;
    while (v11 != (llvm::MDNode *)-4096)
    {
      if (v12) {
        BOOL v14 = 0;
      }
      else {
        BOOL v14 = v11 == (llvm::MDNode *)-8192;
      }
      if (v14) {
        unsigned int v12 = v10;
      }
      int v15 = v9 + v13++;
      uint64_t v9 = v15 & v8;
      unint64_t v10 = (llvm::MDNode **)(v5 + 16 * v9);
      uint64_t v11 = *v10;
      if (*v10 == a2) {
        goto LABEL_11;
      }
    }
    if (v12) {
      BOOL v19 = v12;
    }
    else {
      BOOL v19 = v10;
    }
  }
  else
  {
    BOOL v19 = 0;
  }
  int v20 = sub_1CBFAE01C((uint64_t)v4, (uint64_t)&v25, (uint64_t *)&v25, v19);
  *int v20 = v25;
  *((_DWORD *)v20 + 2) = v26;
  long long v21 = (uint64_t *)((char *)this + 56);
  long long v27 = (unint64_t)a2;
  uint64_t v22 = (void *)*((void *)this + 8);
  if ((unint64_t)v22 < *((void *)this + 9))
  {
    *uint64_t v22 = a2;
    v22[1] = 0;
    uint64_t v23 = v22 + 2;
    *((void *)this + 8) = v22 + 2;
  }
  else
  {
    uint64_t v23 = sub_1CBFAE150((int64x2_t *)((char *)this + 56), &v27);
    uint64_t v24 = *((void *)&v27 + 1);
    *((void *)this + 8) = v23;
    *((void *)&v27 + 1) = 0;
    if (v24)
    {
      sub_1CBFA9BA8((uint64_t)&v27 + 8, v24);
      uint64_t v23 = (_OWORD *)*((void *)this + 8);
    }
  }
  uint64_t v17 = *v21;
  unsigned int v16 = (((unint64_t)v23 - *v21) >> 4) - 1;
  *((_DWORD *)v20 + 2) = v16;
LABEL_12:
  uint64_t result = *(void *)(v17 + 16 * v16 + 8);
  if (!result) {
    operator new();
  }
  return result;
}

unint64_t llvm::CallGraph::removeFunctionFromModule(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 56);
  uint64_t v5 = *(void *)(a1 + 64);
  while (v4 != v5)
  {
    llvm::CallGraphNode::removeAnyCallEdgeTo(*(void *)(v4 + 8), a2);
    v4 += 16;
  }
  unint64_t v6 = *(void *)(a2 + 8);
  int v7 = *(void **)(a1 + 16);
  if (v7)
  {
    unsigned int v8 = (uint64_t *)(a1 + 16);
    do
    {
      unint64_t v9 = v7[4];
      BOOL v10 = v9 >= v6;
      if (v9 >= v6) {
        uint64_t v11 = v7;
      }
      else {
        uint64_t v11 = v7 + 1;
      }
      if (v10) {
        unsigned int v8 = v7;
      }
      int v7 = (void *)*v11;
    }
    while (*v11);
    if (v8 != (uint64_t *)(a1 + 16) && v6 >= v8[4]) {
      sub_1CBFADEF8((uint64_t **)(a1 + 8), v8);
    }
  }
  unint64_t v12 = v6 + 56;
  if (!v6) {
    unint64_t v12 = 0;
  }
  unint64_t v13 = v12 - 56;
  uint64_t v14 = *(void *)a1 + 24;
  if (v6) {
    unint64_t v15 = v13;
  }
  else {
    unint64_t v15 = 0;
  }
  llvm::SymbolTableListTraits<llvm::Function>::removeNodeFromList(v14, (uint64_t ***)v15);
  uint64_t v16 = *(void *)(v15 + 56);
  uint64_t v17 = *(void **)(v15 + 64);
  void *v17 = v16;
  *(void *)(v16 + 8) = v17;
  *(void *)(v15 + 56) = 0;
  *(void *)(v15 + 64) = 0;
  return v6;
}

uint64_t llvm::CallGraphNode::removeAnyCallEdgeTo(uint64_t result, uint64_t a2)
{
  uint64_t v2 = (uint64_t *)(result + 16);
  int v3 = -858993459 * ((*(void *)(result + 24) - *(void *)(result + 16)) >> 3);
  if (v3)
  {
    uint64_t v5 = result;
    for (unsigned int i = 0; i != v3; ++i)
    {
      uint64_t v7 = *v2;
      uint64_t v8 = *v2 + 40 * i;
      uint64_t v10 = *(void *)(v8 + 32);
      unint64_t v9 = (void *)(v8 + 32);
      if (v10 == a2)
      {
        --*(_DWORD *)(a2 + 40);
        uint64_t v11 = *(void *)(v5 + 24);
        sub_1CBFA9984((llvm::ValueHandleBase *)(v7 + 40 * i), (uint64_t *)(v11 - 40));
        *unint64_t v9 = *(void *)(v11 - 8);
        uint64_t result = sub_1CBFA986C((uint64_t)v2, *(void *)(v5 + 24) - 40);
        --i;
        --v3;
      }
    }
  }
  return result;
}

void llvm::CallGraphNode::removeCallEdgeFor(llvm::CallGraphNode *this, uint64_t ****a2)
{
  v16[4] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (char *)this + 16;
  for (uint64_t i = *((void *)this + 2); !*(unsigned char *)(i + 24) || *(uint64_t *****)(i + 16) != a2; i += 40)
    ;
  --*(_DWORD *)(*(void *)(i + 32) + 40);
  uint64_t v6 = *((void *)this + 3);
  sub_1CBFA9984((llvm::ValueHandleBase *)i, (uint64_t *)(v6 - 40));
  *(void *)(i + 32) = *(void *)(v6 - 8);
  sub_1CBFA986C((uint64_t)v4, *((void *)this + 3) - 40);
  uint64_t v14 = v16;
  uint64_t v15 = 0x400000000;
  llvm::AbstractCallSite::getCallbackUses(a2, (uint64_t)&v14);
  uint64_t v7 = v14;
  if (v15)
  {
    uint64_t v8 = (const llvm::Use **)v14;
    uint64_t v9 = 8 * v15;
    do
    {
      llvm::AbstractCallSite::AbstractCallSite((llvm::AbstractCallSite *)&v12, *v8);
      uint64_t v10 = sub_1CD46F814(&v12);
      if (v10)
      {
        inserted = llvm::CallGraph::getOrInsertFunction(*(llvm::CallGraph **)this, v10);
        llvm::CallGraphNode::removeOneAbstractEdgeTo((uint64_t)this, (uint64_t)inserted);
      }
      if (v13 != &v14) {
        free(v13);
      }
      ++v8;
      v9 -= 8;
    }
    while (v9);
    uint64_t v7 = v14;
  }
  if (v7 != v16) {
    free(v7);
  }
}

uint64_t llvm::CallGraphNode::removeOneAbstractEdgeTo(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1 + 16;
  for (uint64_t i = *(void *)(a1 + 16); *(void *)(i + 32) != a2 || *(unsigned char *)(i + 24); i += 40)
    ;
  --*(_DWORD *)(a2 + 40);
  uint64_t v5 = *(void *)(a1 + 24);
  sub_1CBFA9984((llvm::ValueHandleBase *)i, (uint64_t *)(v5 - 40));
  *(void *)(i + 32) = *(void *)(v5 - 8);
  uint64_t v6 = *(void *)(a1 + 24) - 40;

  return sub_1CBFA986C(v3, v6);
}

void llvm::CallGraphNode::replaceCallEdge(llvm::CallGraphNode *this, uint64_t ****a2, llvm::CallBase *a3, llvm::CallGraphNode *a4)
{
  v75[4] = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *((void *)this + 2);
  uint64_t v9 = v8 + 8;
  while (!*(unsigned char *)(v8 + 24) || *(uint64_t *****)(v8 + 16) != a2)
  {
    v8 += 40;
    v9 += 40;
  }
  --*(_DWORD *)(*(void *)(v8 + 32) + 40);
  uint64_t v73 = (void *)6;
  uint64_t v74 = 0;
  v75[0] = a3;
  if (a3 == (llvm::CallBase *)-8192
    || a3 == (llvm::CallBase *)-4096
    || !a3
    || (llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v73), *(unsigned char *)(v8 + 24)))
  {
    uint64_t v10 = *(void *)(v8 + 16);
    uint64_t v11 = v75[0];
    if (v10 != v75[0])
    {
      if (v10 != -4096 && v10 && v10 != -8192)
      {
        unint64_t v33 = *(void *)v8 & 0xFFFFFFFFFFFFFFF8;
        *(void *)unint64_t v33 = *(void *)(v8 + 8);
        unsigned int v34 = *(unint64_t **)(v8 + 8);
        if (v34)
        {
          *unsigned int v34 = *v34 & 7 | v33;
        }
        else
        {
          uint64_t v35 = *(void *)(v8 + 16);
          uint64_t v36 = ***(int32x2_t ****)v35;
          unint64_t v37 = (unint64_t)v36[303];
          if (v37 <= v33)
          {
            uint64_t v38 = v36[305].u32[0];
            if (v37 + 16 * v38 > v33)
            {
              unsigned int v39 = v38 - 1;
              LODWORD(v40) = v39 & ((v35 >> 4) ^ (v35 >> 9));
              int v41 = (uint64_t *)(v37 + 16 * v40);
              uint64_t v42 = *v41;
              if (v35 == *v41)
              {
LABEL_57:
                *int v41 = -8192;
                v36[304] = vadd_s32(v36[304], (int32x2_t)0x1FFFFFFFFLL);
                uint64_t v35 = *(void *)(v8 + 16);
              }
              else
              {
                int v43 = 1;
                while (v42 != -4096)
                {
                  int v44 = v40 + v43++;
                  uint64_t v40 = v44 & v39;
                  uint64_t v42 = *(void *)(v37 + 16 * v40);
                  if (v35 == v42)
                  {
                    int v41 = (uint64_t *)(v37 + 16 * v40);
                    goto LABEL_57;
                  }
                }
              }
              *(unsigned char *)(v35 + 17) &= ~1u;
            }
          }
        }
        uint64_t v11 = v75[0];
      }
      *(void *)(v8 + 16) = v11;
      if (v11 != -4096 && v11 != -8192 && v11 != 0)
      {
        unint64_t v13 = (unint64_t)v73;
        uint64_t v14 = (void *)((unint64_t)v73 & 0xFFFFFFFFFFFFFFF8);
        *(void *)(v8 + 8) = *(void *)((unint64_t)v73 & 0xFFFFFFFFFFFFFFF8);
        *uint64_t v14 = v8;
        uint64_t v15 = *(uint64_t **)(v8 + 8);
        *(void *)uint64_t v8 = v13 & 0xFFFFFFFFFFFFFFF8 | *(void *)v8 & 7;
        if (v15) {
          uint64_t *v15 = *v15 & 7 | v9;
        }
      }
    }
  }
  else
  {
    *(void *)uint64_t v8 = 6;
    *(void *)(v8 + 8) = 0;
    uint64_t v45 = v75[0];
    *(void *)(v8 + 16) = v75[0];
    if (v45 != -8192 && v45 != -4096)
    {
      if (v45)
      {
        unint64_t v46 = (unint64_t)v73 & 0xFFFFFFFFFFFFFFF8;
        *(void *)(v8 + 8) = *(void *)((unint64_t)v73 & 0xFFFFFFFFFFFFFFF8);
        *(void *)unint64_t v46 = v8;
        *(void *)uint64_t v8 = v46 | 6;
        unsigned int v47 = *(uint64_t **)(v8 + 8);
        if (v47) {
          uint64_t *v47 = *v47 & 7 | v9;
        }
      }
    }
    *(unsigned char *)(v8 + 24) = 1;
  }
  if (v75[0] != -8192 && v75[0] != -4096 && v75[0] != 0)
  {
    unint64_t v17 = (unint64_t)v73 & 0xFFFFFFFFFFFFFFF8;
    *(void *)((unint64_t)v73 & 0xFFFFFFFFFFFFFFF8) = v74;
    if (v74)
    {
      *(void *)uint64_t v74 = *(void *)v74 & 7 | v17;
    }
    else
    {
      uint64_t v18 = v75[0];
      BOOL v19 = ***(int32x2_t ****)v75[0];
      unint64_t v20 = (unint64_t)v19[303];
      if (v20 <= v17)
      {
        uint64_t v21 = v19[305].u32[0];
        if (v20 + 16 * v21 > v17)
        {
          unsigned int v22 = v21 - 1;
          LODWORD(v23) = v22 & ((LODWORD(v75[0]) >> 4) ^ (LODWORD(v75[0]) >> 9));
          uint64_t v24 = (uint64_t *)(v20 + 16 * v23);
          uint64_t v25 = *v24;
          if (v75[0] == *v24)
          {
LABEL_31:
            *uint64_t v24 = -8192;
            v19[304] = vadd_s32(v19[304], (int32x2_t)0x1FFFFFFFFLL);
            uint64_t v18 = v75[0];
          }
          else
          {
            int v26 = 1;
            while (v25 != -4096)
            {
              int v27 = v23 + v26++;
              uint64_t v23 = v27 & v22;
              uint64_t v25 = *(void *)(v20 + 16 * v23);
              if (v75[0] == v25)
              {
                uint64_t v24 = (uint64_t *)(v20 + 16 * v23);
                goto LABEL_31;
              }
            }
          }
          *(unsigned char *)(v18 + 17) &= ~1u;
        }
      }
    }
  }
  *(void *)(v8 + 32) = a4;
  ++*((_DWORD *)a4 + 10);
  uint64_t v70 = v72;
  uint64_t v71 = 0x400000000;
  int v67 = v69;
  uint64_t v68 = 0x400000000;
  uint64_t v73 = v75;
  uint64_t v74 = 0x400000000;
  llvm::AbstractCallSite::getCallbackUses(a2, (uint64_t)&v73);
  uint64_t v28 = (const llvm::Use **)v73;
  if (v74)
  {
    uint64_t v48 = 8 * v74;
    do
    {
      llvm::AbstractCallSite::AbstractCallSite((llvm::AbstractCallSite *)&v65, *v28);
      uint64_t v49 = sub_1CD46F814(&v65);
      if (v49)
      {
        inserted = llvm::CallGraph::getOrInsertFunction(*(llvm::CallGraph **)this, v49);
        if (v71 >= (unint64_t)HIDWORD(v71)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v70 + v71) = inserted;
        LODWORD(v71) = v71 + 1;
      }
      if (v66 != &v67) {
        free(v66);
      }
      ++v28;
      v48 -= 8;
    }
    while (v48);
    uint64_t v28 = (const llvm::Use **)v73;
  }
  if (v28 != v75) {
    free(v28);
  }
  uint64_t v73 = v75;
  uint64_t v74 = 0x400000000;
  llvm::AbstractCallSite::getCallbackUses((uint64_t ****)a3, (uint64_t)&v73);
  int v29 = (const llvm::Use **)v73;
  if (v74)
  {
    uint64_t v51 = 8 * v74;
    do
    {
      llvm::AbstractCallSite::AbstractCallSite((llvm::AbstractCallSite *)&v65, *v29);
      int v52 = sub_1CD46F814(&v65);
      if (v52)
      {
        uint64_t v53 = llvm::CallGraph::getOrInsertFunction(*(llvm::CallGraph **)this, v52);
        if (v68 >= (unint64_t)HIDWORD(v68)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v67 + v68) = v53;
        LODWORD(v68) = v68 + 1;
      }
      if (v66 != &v67) {
        free(v66);
      }
      ++v29;
      v51 -= 8;
    }
    while (v51);
    int v29 = (const llvm::Use **)v73;
  }
  if (v29 != v75) {
    free(v29);
  }
  uint64_t v30 = v71;
  unsigned int v31 = v68;
  if (v71 == v68)
  {
    int v32 = (uint64_t *)v67;
    if (v71)
    {
      uint64_t v59 = 0;
      uint64_t v60 = v70;
      uint64_t v61 = *((void *)this + 2) + 32;
      do
      {
        uint64_t v62 = v60[v59];
        uint64_t v63 = v32[v59];
        for (uint64_t i = (void *)v61; *((unsigned char *)i - 8) || *i != v62; i += 5)
          ;
        *uint64_t i = v63;
        --*(_DWORD *)(v62 + 40);
        ++*(_DWORD *)(v63 + 40);
        ++v59;
      }
      while (v59 != v30);
    }
  }
  else
  {
    if (v71)
    {
      unint64_t v54 = (uint64_t *)v70;
      uint64_t v55 = 8 * v71;
      do
      {
        uint64_t v56 = *v54++;
        llvm::CallGraphNode::removeOneAbstractEdgeTo((uint64_t)this, v56);
        v55 -= 8;
      }
      while (v55);
      unsigned int v31 = v68;
    }
    int v32 = (uint64_t *)v67;
    if (v31)
    {
      uint64_t v57 = 8 * v31;
      do
      {
        uint64_t v58 = *v32++;
        sub_1CBFA7A30((uint64_t)this, 0, v58);
        v57 -= 8;
      }
      while (v57);
      int v32 = (uint64_t *)v67;
    }
  }
  if (v32 != (uint64_t *)v69) {
    free(v32);
  }
  if (v70 != v72) {
    free(v70);
  }
}

void llvm::CallGraphWrapperPass::runOnModule(llvm::CallGraphWrapperPass *this, llvm::Module *a2)
{
}

void sub_1CBFA900C()
{
}

llvm::CallGraph *llvm::CallGraphWrapperPass::releaseMemory(llvm::CallGraphWrapperPass *this)
{
  uint64_t result = (llvm::CallGraph *)*((void *)this + 4);
  *((void *)this + 4) = 0;
  if (result)
  {
    llvm::CallGraph::~CallGraph(result);
    JUMPOUT(0x1D25D9CE0);
  }
  return result;
}

void llvm::initializeCallGraphPrinterLegacyPassPass(uint64_t a1)
{
  uint64_t v1 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC4930, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CBFA916C;
    v3[1] = &v1;
    uint64_t v2 = v3;
    std::__call_once(&qword_1EBCC4930, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CBFA916C(uint64_t a1)
{
  uint64_t v1 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC4928, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CBFA900C;
    v3[1] = &v1;
    uint64_t v2 = v3;
    std::__call_once(&qword_1EBCC4928, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
  operator new();
}

void sub_1CBFA9268(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (uint64_t *)**a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = v4 - 1;
      do
      {
        uint64_t v7 = *v6;
        *uint64_t v6 = 0;
        if (v7) {
          sub_1CBFA9BA8((uint64_t)v6, v7);
        }
        uint64_t v8 = v6 - 1;
        v6 -= 2;
      }
      while (v8 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

char *sub_1CBFA9300(char **a1, uint64_t a2, void *a3)
{
  uint64_t v3 = *a1;
  uint64_t v4 = a1[1];
  unint64_t v5 = 0xCCCCCCCCCCCCCCCDLL * ((v4 - *a1) >> 3);
  unint64_t v6 = v5 + 1;
  if (v5 + 1 > 0x666666666666666) {
    abort();
  }
  if (0x999999999999999ALL * ((a1[2] - v3) >> 3) > v6) {
    unint64_t v6 = 0x999999999999999ALL * ((a1[2] - v3) >> 3);
  }
  if (0xCCCCCCCCCCCCCCCDLL * ((a1[2] - v3) >> 3) >= 0x333333333333333) {
    unint64_t v10 = 0x666666666666666;
  }
  else {
    unint64_t v10 = v6;
  }
  if (v10)
  {
    if (v10 > 0x666666666666666) {
      sub_1CB833614();
    }
    uint64_t v11 = operator new(40 * v10);
  }
  else
  {
    uint64_t v11 = 0;
  }
  unint64_t v12 = (char *)&v11[5 * v5];
  *unint64_t v12 = 0;
  v12[24] = 0;
  if (*(unsigned char *)(a2 + 24))
  {
    sub_1CBFA9590((llvm::ValueHandleBase *)&v11[5 * v5], (void *)a2);
    uint64_t v3 = *a1;
    uint64_t v4 = a1[1];
  }
  unint64_t v13 = (char *)&v11[5 * v10];
  v11[5 * v5 + 4] = *a3;
  uint64_t v14 = v12 + 40;
  if (v4 == v3)
  {
    *a1 = v12;
    a1[1] = v14;
    a1[2] = v13;
  }
  else
  {
    uint64_t v15 = 0;
    do
    {
      v12[v15 - 40] = 0;
      uint64_t v16 = &v4[v15];
      v12[v15 - 16] = 0;
      if (v4[v15 - 16]) {
        sub_1CBFA9590((llvm::ValueHandleBase *)&v12[v15 - 40], (void *)v16 - 5);
      }
      *(void *)&v12[v15 - 8] = *((void *)v16 - 1);
      v15 -= 40;
    }
    while (&v4[v15] != v3);
    uint64_t v3 = *a1;
    unint64_t v17 = a1[1];
    *a1 = &v12[v15];
    a1[1] = v14;
    for (a1[2] = v13; v17 != v3; v17 -= 40)
    {
      if (*(v17 - 16))
      {
        uint64_t v18 = *((void *)v17 - 3);
        if (v18 != -8192 && v18 != -4096 && v18 != 0)
        {
          unint64_t v20 = *((void *)v17 - 5) & 0xFFFFFFFFFFFFFFF8;
          *(void *)unint64_t v20 = *((void *)v17 - 4);
          uint64_t v21 = (unint64_t *)*((void *)v17 - 4);
          if (v21)
          {
            *uint64_t v21 = *v21 & 7 | v20;
          }
          else
          {
            uint64_t v22 = *((void *)v17 - 3);
            uint64_t v23 = ***(int32x2_t ****)v22;
            unint64_t v24 = (unint64_t)v23[303];
            if (v24 <= v20)
            {
              uint64_t v25 = v23[305].u32[0];
              if (v24 + 16 * v25 > v20)
              {
                unsigned int v26 = v25 - 1;
                LODWORD(v27) = v26 & ((v22 >> 4) ^ (v22 >> 9));
                uint64_t v28 = (uint64_t *)(v24 + 16 * v27);
                uint64_t v29 = *v28;
                if (v22 == *v28)
                {
LABEL_37:
                  uint64_t *v28 = -8192;
                  v23[304] = vadd_s32(v23[304], (int32x2_t)0x1FFFFFFFFLL);
                  uint64_t v22 = *((void *)v17 - 3);
                }
                else
                {
                  int v30 = 1;
                  while (v29 != -4096)
                  {
                    int v31 = v27 + v30++;
                    uint64_t v27 = v31 & v26;
                    uint64_t v29 = *(void *)(v24 + 16 * v27);
                    if (v22 == v29)
                    {
                      uint64_t v28 = (uint64_t *)(v24 + 16 * v27);
                      goto LABEL_37;
                    }
                  }
                }
                *(unsigned char *)(v22 + 17) &= ~1u;
              }
            }
          }
        }
        *(v17 - 16) = 0;
      }
    }
  }
  if (v3) {
    operator delete(v3);
  }
  return v12 + 40;
}

llvm::ValueHandleBase *sub_1CBFA9590(llvm::ValueHandleBase *result, void *a2)
{
  if (*((unsigned char *)result + 24))
  {
    uint64_t v8 = a2;
    uint64_t v9 = result;
    uint64_t v6 = *((void *)result + 2);
    if (v6 != -8192 && v6 != -4096 && v6 != 0) {
      llvm::ValueHandleBase::RemoveFromUseList(result);
    }
    a2 = v8;
    uint64_t result = v9;
    *((unsigned char *)v9 + 24) = 0;
  }
  *(void *)uint64_t result = 6;
  *((void *)result + 1) = 0;
  uint64_t v2 = a2[2];
  *((void *)result + 2) = v2;
  if (v2 != -8192 && v2 != -4096 && v2 != 0)
  {
    unint64_t v4 = *a2 & 0xFFFFFFFFFFFFFFF8;
    *((void *)result + 1) = *(void *)v4;
    *(void *)unint64_t v4 = result;
    *(void *)uint64_t result = v4 | 6;
    unint64_t v5 = (uint64_t *)*((void *)result + 1);
    if (v5) {
      *unint64_t v5 = *v5 & 7 | ((unint64_t)result + 8);
    }
  }
  *((unsigned char *)result + 24) = 1;
  return result;
}

void sub_1CBFA964C()
{
}

void sub_1CBFA9718(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CBFA9750(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
  sub_1CB843600(a2, a2, (uint64_t)&llvm::CallGraphWrapperPass::ID);

  sub_1CB843600(a2, a2 + 80, (uint64_t)&llvm::CallGraphWrapperPass::ID);
}

uint64_t sub_1CBFA97A8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(uint64_t **)(a1 + 8);
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  if (v4 == v5)
  {
LABEL_4:
    uint64_t v6 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v4 != &llvm::CallGraphWrapperPass::ID)
    {
      v4 += 16;
      if (v4 == v5) {
        goto LABEL_4;
      }
    }
    uint64_t v6 = *(void *)(v4 + 8);
  }
  uint64_t v7 = (llvm *)(*(uint64_t (**)(uint64_t, void *))(*(void *)v6 + 96))(v6, &llvm::CallGraphWrapperPass::ID);
  uint64_t v8 = llvm::errs(v7);
  (*(void (**)(llvm *, void *, uint64_t))(*(void *)v7 + 40))(v7, v8, a2);
  return 0;
}

uint64_t sub_1CBFA986C(uint64_t result, uint64_t a2)
{
  for (uint64_t i = *(void *)(result + 8); i != a2; i -= 40)
  {
    if (*(unsigned char *)(i - 16))
    {
      uint64_t v3 = *(void *)(i - 24);
      if (v3 != -8192 && v3 != -4096 && v3 != 0)
      {
        unint64_t v5 = *(void *)(i - 40) & 0xFFFFFFFFFFFFFFF8;
        *(void *)unint64_t v5 = *(void *)(i - 32);
        uint64_t v6 = *(unint64_t **)(i - 32);
        if (v6)
        {
          *uint64_t v6 = *v6 & 7 | v5;
        }
        else
        {
          uint64_t v7 = *(void *)(i - 24);
          uint64_t v8 = ***(int32x2_t ****)v7;
          unint64_t v9 = (unint64_t)v8[303];
          if (v9 <= v5)
          {
            uint64_t v10 = v8[305].u32[0];
            if (v9 + 16 * v10 > v5)
            {
              unsigned int v11 = v10 - 1;
              LODWORD(v12) = v11 & ((v7 >> 4) ^ (v7 >> 9));
              unint64_t v13 = (uint64_t *)(v9 + 16 * v12);
              uint64_t v14 = *v13;
              if (v7 == *v13)
              {
LABEL_20:
                *unint64_t v13 = -8192;
                v8[304] = vadd_s32(v8[304], (int32x2_t)0x1FFFFFFFFLL);
                uint64_t v7 = *(void *)(i - 24);
              }
              else
              {
                int v15 = 1;
                while (v14 != -4096)
                {
                  int v16 = v12 + v15++;
                  uint64_t v12 = v16 & v11;
                  uint64_t v14 = *(void *)(v9 + 16 * v12);
                  if (v7 == v14)
                  {
                    unint64_t v13 = (uint64_t *)(v9 + 16 * v12);
                    goto LABEL_20;
                  }
                }
              }
              *(unsigned char *)(v7 + 17) &= ~1u;
            }
          }
        }
      }
      *(unsigned char *)(i - 16) = 0;
    }
  }
  *(void *)(result + 8) = a2;
  return result;
}

llvm::ValueHandleBase *sub_1CBFA9984(llvm::ValueHandleBase *result, uint64_t *a2)
{
  if (*((unsigned char *)a2 + 24))
  {
    if (*((unsigned char *)result + 24))
    {
      uint64_t v2 = *((void *)result + 2);
      uint64_t v3 = a2[2];
      if (v2 != v3)
      {
        BOOL v4 = v2 == -4096 || v2 == 0;
        if (!v4 && v2 != -8192)
        {
          unint64_t v9 = *(void *)result & 0xFFFFFFFFFFFFFFF8;
          *(void *)unint64_t v9 = *((void *)result + 1);
          uint64_t v10 = (unint64_t *)*((void *)result + 1);
          if (v10)
          {
            *uint64_t v10 = *v10 & 7 | v9;
          }
          else
          {
            uint64_t v11 = *((void *)result + 2);
            uint64_t v12 = ***(int32x2_t ****)v11;
            unint64_t v13 = (unint64_t)v12[303];
            if (v13 <= v9)
            {
              uint64_t v14 = v12[305].u32[0];
              if (v13 + 16 * v14 > v9)
              {
                unsigned int v15 = v14 - 1;
                LODWORD(v16) = v15 & ((v11 >> 4) ^ (v11 >> 9));
                unint64_t v17 = (uint64_t *)(v13 + 16 * v16);
                uint64_t v18 = *v17;
                if (v11 == *v17)
                {
LABEL_26:
                  uint64_t *v17 = -8192;
                  v12[304] = vadd_s32(v12[304], (int32x2_t)0x1FFFFFFFFLL);
                  uint64_t v11 = *((void *)result + 2);
                }
                else
                {
                  int v19 = 1;
                  while (v18 != -4096)
                  {
                    int v20 = v16 + v19++;
                    uint64_t v16 = v20 & v15;
                    uint64_t v18 = *(void *)(v13 + 16 * v16);
                    if (v11 == v18)
                    {
                      unint64_t v17 = (uint64_t *)(v13 + 16 * v16);
                      goto LABEL_26;
                    }
                  }
                }
                *(unsigned char *)(v11 + 17) &= ~1u;
              }
            }
          }
          uint64_t v3 = a2[2];
        }
        *((void *)result + 2) = v3;
        if (v3 != -4096 && v3 != -8192 && v3 != 0)
        {
          uint64_t v6 = *a2;
          uint64_t v7 = (void *)(*a2 & 0xFFFFFFFFFFFFFFF8);
          *((void *)result + 1) = *v7;
          *uint64_t v7 = result;
          *(void *)uint64_t result = v6 & 0xFFFFFFFFFFFFFFF8 | *(void *)result & 7;
          uint64_t v8 = (uint64_t *)*((void *)result + 1);
          if (v8) {
            *uint64_t v8 = *v8 & 7 | ((unint64_t)result + 8);
          }
        }
      }
    }
    else
    {
      *(void *)uint64_t result = 6;
      *((void *)result + 1) = 0;
      uint64_t v23 = a2[2];
      *((void *)result + 2) = v23;
      if (v23 != -8192 && v23 != -4096 && v23 != 0)
      {
        unint64_t v25 = *a2 & 0xFFFFFFFFFFFFFFF8;
        *((void *)result + 1) = *(void *)v25;
        *(void *)unint64_t v25 = result;
        *(void *)uint64_t result = v25 | 6;
        unsigned int v26 = (uint64_t *)*((void *)result + 1);
        if (v26) {
          uint64_t *v26 = *v26 & 7 | ((unint64_t)result + 8);
        }
      }
      *((unsigned char *)result + 24) = 1;
    }
  }
  else if (*((unsigned char *)result + 24))
  {
    uint64_t v27 = result;
    uint64_t v21 = *((void *)result + 2);
    if (v21 != -8192 && v21 != -4096 && v21 != 0) {
      llvm::ValueHandleBase::RemoveFromUseList(result);
    }
    uint64_t result = v27;
    *((unsigned char *)v27 + 24) = 0;
  }
  return result;
}

void sub_1CBFA9BA8(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = (void **)(a2 + 16);
    uint64_t v2 = *(void *)(a2 + 16);
    if (v2)
    {
      sub_1CBFA986C((uint64_t)v3, v2);
      operator delete(*v3);
    }
    JUMPOUT(0x1D25D9CE0);
  }
}

void sub_1CBFA9C10(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1CBFA9C10(a1, *a2);
    sub_1CBFA9C10(a1, a2[1]);
    uint64_t v5 = a2[5];
    a2[5] = 0;
    if (v5) {
      sub_1CBFA9BA8((uint64_t)(a2 + 5), v5);
    }
    operator delete(a2);
  }
}

char *sub_1CBFA9C78(char *result, char *a2, uint64_t a3, char a4)
{
  uint64_t v6 = (uint64_t *)result;
LABEL_2:
  uint64_t v7 = a2;
  v828 = a2 - 8;
  uint64_t i = v6;
  while (1)
  {
    unint64_t v9 = i;
    uint64_t v10 = v7 - (char *)i;
    uint64_t v11 = (v7 - (char *)i) >> 3;
    if (v5 || !v4)
    {
      switch(v11)
      {
        case 0:
        case 1:
          return result;
        case 2:
          uint64_t v359 = *((void *)a2 - 1);
          uint64_t v360 = *v9;
          v361 = *(uint64_t ****)(v359 + 8);
          v362 = *(uint64_t ****)(*v9 + 8);
          if (!v361)
          {
            if (!v362) {
              return result;
            }
            goto LABEL_901;
          }
          if (!v362) {
            return result;
          }
          if ((*((unsigned char *)v361 + 23) & 0x10) != 0)
          {
            uint64_t v363 = ***v361;
            uint64_t v364 = *(void *)(v363 + 152);
            uint64_t v365 = *(unsigned int *)(v363 + 168);
            if (v365)
            {
              LODWORD(v366) = (v365 - 1) & ((v361 >> 4) ^ (v361 >> 9));
              uint64_t v367 = (uint64_t ****)(v364 + 16 * v366);
              uint64_t v368 = *v367;
              if (*v367 != v361)
              {
                int v369 = 1;
                do
                {
                  if (v368 == (uint64_t ***)-4096) {
                    goto LABEL_873;
                  }
                  int v370 = v366 + v369++;
                  uint64_t v366 = v370 & (v365 - 1);
                  uint64_t v368 = *(uint64_t ****)(v364 + 16 * v366);
                }
                while (v368 != v361);
                uint64_t v367 = (uint64_t ****)(v364 + 16 * v366);
              }
            }
            else
            {
LABEL_873:
              uint64_t v367 = (uint64_t ****)(v364 + 16 * v365);
            }
            v714 = v367[1];
            size_t v716 = (size_t)*v714;
            uint64_t result = (char *)(v714 + 2);
            size_t v715 = v716;
            goto LABEL_875;
          }
          size_t v715 = 0;
          uint64_t result = &byte_1CFBCE98E;
LABEL_875:
          if ((*((unsigned char *)v362 + 23) & 0x10) != 0)
          {
            uint64_t v717 = ***v362;
            uint64_t v718 = *(void *)(v717 + 152);
            uint64_t v719 = *(unsigned int *)(v717 + 168);
            if (v719)
            {
              LODWORD(v720) = (v719 - 1) & ((v362 >> 4) ^ (v362 >> 9));
              v721 = (uint64_t ****)(v718 + 16 * v720);
              v722 = *v721;
              if (*v721 != v362)
              {
                int v723 = 1;
                do
                {
                  if (v722 == (uint64_t ***)-4096) {
                    goto LABEL_891;
                  }
                  int v724 = v720 + v723++;
                  uint64_t v720 = v724 & (v719 - 1);
                  v722 = *(uint64_t ****)(v718 + 16 * v720);
                }
                while (v722 != v362);
                v721 = (uint64_t ****)(v718 + 16 * v720);
              }
            }
            else
            {
LABEL_891:
              v721 = (uint64_t ****)(v718 + 16 * v719);
            }
            v736 = v721[1];
            size_t v739 = (size_t)*v736;
            v737 = (char *)(v736 + 2);
            size_t v738 = v739;
            goto LABEL_893;
          }
          size_t v738 = 0;
          v737 = &byte_1CFBCE98E;
LABEL_893:
          if (v738 >= v715) {
            size_t v740 = v715;
          }
          else {
            size_t v740 = v738;
          }
          if (v740 && (uint64_t result = (char *)memcmp(result, v737, v740), result))
          {
            if ((result & 0x80000000) == 0) {
              return result;
            }
          }
          else if (v715 >= v738)
          {
            return result;
          }
LABEL_901:
          *unint64_t v9 = v359;
          *((void *)a2 - 1) = v360;
          return result;
        case 3:
          return sub_1CBFAC870((char *)v9, (char *)v9 + 8, v828);
        case 4:
          return sub_1CBFADA84((char *)v9, (char *)v9 + 8, (char *)v9 + 16, (uint64_t *)v828);
        case 5:
          uint64_t v371 = v9 + 1;
          uint64_t v372 = v9 + 2;
          unsigned int v373 = v9 + 3;
          uint64_t result = sub_1CBFADA84((char *)v9, (char *)v9 + 8, (char *)v9 + 16, v9 + 3);
          uint64_t v374 = *((void *)a2 - 1);
          uint64_t v375 = v9[3];
          uint64_t v376 = *(uint64_t ****)(v374 + 8);
          v377 = *(uint64_t ****)(v375 + 8);
          if (!v376)
          {
            if (!v377) {
              return result;
            }
            goto LABEL_912;
          }
          if (!v377) {
            return result;
          }
          if ((*((unsigned char *)v376 + 23) & 0x10) != 0)
          {
            uint64_t v378 = ***v376;
            uint64_t v379 = *(void *)(v378 + 152);
            uint64_t v380 = *(unsigned int *)(v378 + 168);
            if (v380)
            {
              LODWORD(v381) = (v380 - 1) & ((v376 >> 4) ^ (v376 >> 9));
              uint64_t v382 = (uint64_t ****)(v379 + 16 * v381);
              uint64_t v383 = *v382;
              if (*v382 != v376)
              {
                int v384 = 1;
                do
                {
                  if (v383 == (uint64_t ***)-4096) {
                    goto LABEL_882;
                  }
                  int v385 = v381 + v384++;
                  uint64_t v381 = v385 & (v380 - 1);
                  uint64_t v383 = *(uint64_t ****)(v379 + 16 * v381);
                }
                while (v383 != v376);
                uint64_t v382 = (uint64_t ****)(v379 + 16 * v381);
              }
            }
            else
            {
LABEL_882:
              uint64_t v382 = (uint64_t ****)(v379 + 16 * v380);
            }
            v725 = v382[1];
            size_t v727 = (size_t)*v725;
            uint64_t result = (char *)(v725 + 2);
            size_t v726 = v727;
            goto LABEL_884;
          }
          size_t v726 = 0;
          uint64_t result = &byte_1CFBCE98E;
LABEL_884:
          if ((*((unsigned char *)v377 + 23) & 0x10) != 0)
          {
            uint64_t v728 = ***v377;
            uint64_t v729 = *(void *)(v728 + 152);
            uint64_t v730 = *(unsigned int *)(v728 + 168);
            if (v730)
            {
              LODWORD(v731) = (v730 - 1) & ((v377 >> 4) ^ (v377 >> 9));
              v732 = (uint64_t ****)(v729 + 16 * v731);
              v733 = *v732;
              if (*v732 != v377)
              {
                int v734 = 1;
                do
                {
                  if (v733 == (uint64_t ***)-4096) {
                    goto LABEL_902;
                  }
                  int v735 = v731 + v734++;
                  uint64_t v731 = v735 & (v730 - 1);
                  v733 = *(uint64_t ****)(v729 + 16 * v731);
                }
                while (v733 != v377);
                v732 = (uint64_t ****)(v729 + 16 * v731);
              }
            }
            else
            {
LABEL_902:
              v732 = (uint64_t ****)(v729 + 16 * v730);
            }
            v741 = v732[1];
            size_t v744 = (size_t)*v741;
            v742 = (char *)(v741 + 2);
            size_t v743 = v744;
            goto LABEL_904;
          }
          size_t v743 = 0;
          v742 = &byte_1CFBCE98E;
LABEL_904:
          if (v743 >= v726) {
            size_t v745 = v726;
          }
          else {
            size_t v745 = v743;
          }
          if (v745 && (uint64_t result = (char *)memcmp(result, v742, v745), result))
          {
            if ((result & 0x80000000) == 0) {
              return result;
            }
          }
          else if (v726 >= v743)
          {
            return result;
          }
LABEL_912:
          *unsigned int v373 = v374;
          *((void *)a2 - 1) = v375;
          uint64_t v746 = *v373;
          uint64_t v747 = *v372;
          v748 = *(uint64_t ****)(*v373 + 8);
          v749 = *(uint64_t ****)(*v372 + 8);
          if (!v748)
          {
            if (!v749) {
              return result;
            }
            goto LABEL_942;
          }
          if (!v749) {
            return result;
          }
          if ((*((unsigned char *)v748 + 23) & 0x10) != 0)
          {
            uint64_t v750 = ***v748;
            uint64_t v751 = *(void *)(v750 + 152);
            uint64_t v752 = *(unsigned int *)(v750 + 168);
            if (v752)
            {
              LODWORD(v753) = (v752 - 1) & ((v748 >> 4) ^ (v748 >> 9));
              v754 = (uint64_t ****)(v751 + 16 * v753);
              v755 = *v754;
              if (*v754 != v748)
              {
                int v756 = 1;
                do
                {
                  if (v755 == (uint64_t ***)-4096) {
                    goto LABEL_923;
                  }
                  int v757 = v753 + v756++;
                  uint64_t v753 = v757 & (v752 - 1);
                  v755 = *(uint64_t ****)(v751 + 16 * v753);
                }
                while (v755 != v748);
                v754 = (uint64_t ****)(v751 + 16 * v753);
              }
            }
            else
            {
LABEL_923:
              v754 = (uint64_t ****)(v751 + 16 * v752);
            }
            v758 = v754[1];
            size_t v760 = (size_t)*v758;
            uint64_t result = (char *)(v758 + 2);
            size_t v759 = v760;
            goto LABEL_925;
          }
          size_t v759 = 0;
          uint64_t result = &byte_1CFBCE98E;
LABEL_925:
          if ((*((unsigned char *)v749 + 23) & 0x10) != 0)
          {
            uint64_t v761 = ***v749;
            uint64_t v762 = *(void *)(v761 + 152);
            uint64_t v763 = *(unsigned int *)(v761 + 168);
            if (v763)
            {
              LODWORD(v764) = (v763 - 1) & ((v749 >> 4) ^ (v749 >> 9));
              v765 = (uint64_t ****)(v762 + 16 * v764);
              v766 = *v765;
              if (*v765 != v749)
              {
                int v767 = 1;
                do
                {
                  if (v766 == (uint64_t ***)-4096) {
                    goto LABEL_932;
                  }
                  int v768 = v764 + v767++;
                  uint64_t v764 = v768 & (v763 - 1);
                  v766 = *(uint64_t ****)(v762 + 16 * v764);
                }
                while (v766 != v749);
                v765 = (uint64_t ****)(v762 + 16 * v764);
              }
            }
            else
            {
LABEL_932:
              v765 = (uint64_t ****)(v762 + 16 * v763);
            }
            v769 = v765[1];
            size_t v772 = (size_t)*v769;
            v770 = (char *)(v769 + 2);
            size_t v771 = v772;
            goto LABEL_934;
          }
          size_t v771 = 0;
          v770 = &byte_1CFBCE98E;
LABEL_934:
          if (v771 >= v759) {
            size_t v773 = v759;
          }
          else {
            size_t v773 = v771;
          }
          if (v773 && (uint64_t result = (char *)memcmp(result, v770, v773), result))
          {
            if ((result & 0x80000000) == 0) {
              return result;
            }
          }
          else if (v759 >= v771)
          {
            return result;
          }
LABEL_942:
          *uint64_t v372 = v746;
          *unsigned int v373 = v747;
          uint64_t v774 = *v371;
          v775 = *(uint64_t ****)(v746 + 8);
          v776 = *(uint64_t ****)(*v371 + 8);
          if (!v775)
          {
            if (!v776) {
              return result;
            }
            goto LABEL_972;
          }
          if (!v776) {
            return result;
          }
          if ((*((unsigned char *)v775 + 23) & 0x10) != 0)
          {
            uint64_t v777 = ***v775;
            uint64_t v778 = *(void *)(v777 + 152);
            uint64_t v779 = *(unsigned int *)(v777 + 168);
            if (v779)
            {
              LODWORD(v780) = (v779 - 1) & ((v775 >> 4) ^ (v775 >> 9));
              v781 = (uint64_t ****)(v778 + 16 * v780);
              v782 = *v781;
              if (*v781 != v775)
              {
                int v783 = 1;
                do
                {
                  if (v782 == (uint64_t ***)-4096) {
                    goto LABEL_953;
                  }
                  int v784 = v780 + v783++;
                  uint64_t v780 = v784 & (v779 - 1);
                  v782 = *(uint64_t ****)(v778 + 16 * v780);
                }
                while (v782 != v775);
                v781 = (uint64_t ****)(v778 + 16 * v780);
              }
            }
            else
            {
LABEL_953:
              v781 = (uint64_t ****)(v778 + 16 * v779);
            }
            v785 = v781[1];
            size_t v787 = (size_t)*v785;
            uint64_t result = (char *)(v785 + 2);
            size_t v786 = v787;
            goto LABEL_955;
          }
          size_t v786 = 0;
          uint64_t result = &byte_1CFBCE98E;
LABEL_955:
          if ((*((unsigned char *)v776 + 23) & 0x10) != 0)
          {
            uint64_t v788 = ***v776;
            uint64_t v789 = *(void *)(v788 + 152);
            uint64_t v790 = *(unsigned int *)(v788 + 168);
            if (v790)
            {
              LODWORD(v791) = (v790 - 1) & ((v776 >> 4) ^ (v776 >> 9));
              v792 = (uint64_t ****)(v789 + 16 * v791);
              v793 = *v792;
              if (*v792 != v776)
              {
                int v794 = 1;
                do
                {
                  if (v793 == (uint64_t ***)-4096) {
                    goto LABEL_962;
                  }
                  int v795 = v791 + v794++;
                  uint64_t v791 = v795 & (v790 - 1);
                  v793 = *(uint64_t ****)(v789 + 16 * v791);
                }
                while (v793 != v776);
                v792 = (uint64_t ****)(v789 + 16 * v791);
              }
            }
            else
            {
LABEL_962:
              v792 = (uint64_t ****)(v789 + 16 * v790);
            }
            v796 = v792[1];
            size_t v799 = (size_t)*v796;
            v797 = (char *)(v796 + 2);
            size_t v798 = v799;
            goto LABEL_964;
          }
          size_t v798 = 0;
          v797 = &byte_1CFBCE98E;
LABEL_964:
          if (v798 >= v786) {
            size_t v800 = v786;
          }
          else {
            size_t v800 = v798;
          }
          if (v800 && (uint64_t result = (char *)memcmp(result, v797, v800), result))
          {
            if ((result & 0x80000000) == 0) {
              return result;
            }
          }
          else if (v786 >= v798)
          {
            return result;
          }
LABEL_972:
          v9[1] = v746;
          v9[2] = v774;
          uint64_t v801 = *v9;
          v802 = *(uint64_t ****)(v746 + 8);
          v803 = *(uint64_t ****)(*v9 + 8);
          if (!v802)
          {
            if (!v803) {
              return result;
            }
            goto LABEL_982;
          }
          if (!v803) {
            return result;
          }
          if ((*((unsigned char *)v802 + 23) & 0x10) == 0)
          {
            size_t v813 = 0;
            uint64_t result = &byte_1CFBCE98E;
LABEL_990:
            if ((*((unsigned char *)v803 + 23) & 0x10) == 0)
            {
              size_t v825 = 0;
              v824 = &byte_1CFBCE98E;
LABEL_999:
              if (v825 >= v813) {
                size_t v827 = v813;
              }
              else {
                size_t v827 = v825;
              }
              if (v827 && (uint64_t result = (char *)memcmp(result, v824, v827), result))
              {
                if ((result & 0x80000000) == 0) {
                  return result;
                }
              }
              else if (v813 >= v825)
              {
                return result;
              }
LABEL_982:
              *unint64_t v9 = v746;
              v9[1] = v801;
              return result;
            }
            uint64_t v815 = ***v803;
            uint64_t v816 = *(void *)(v815 + 152);
            uint64_t v817 = *(unsigned int *)(v815 + 168);
            if (v817)
            {
              LODWORD(v818) = (v817 - 1) & ((v803 >> 4) ^ (v803 >> 9));
              v819 = (uint64_t ****)(v816 + 16 * v818);
              v820 = *v819;
              if (*v819 == v803)
              {
LABEL_998:
                v823 = v819[1];
                size_t v826 = (size_t)*v823;
                v824 = (char *)(v823 + 2);
                size_t v825 = v826;
                goto LABEL_999;
              }
              int v821 = 1;
              while (v820 != (uint64_t ***)-4096)
              {
                int v822 = v818 + v821++;
                uint64_t v818 = v822 & (v817 - 1);
                v820 = *(uint64_t ****)(v816 + 16 * v818);
                if (v820 == v803)
                {
                  v819 = (uint64_t ****)(v816 + 16 * v818);
                  goto LABEL_998;
                }
              }
            }
            v819 = (uint64_t ****)(v816 + 16 * v817);
            goto LABEL_998;
          }
          uint64_t v804 = ***v802;
          uint64_t v805 = *(void *)(v804 + 152);
          uint64_t v806 = *(unsigned int *)(v804 + 168);
          if (!v806) {
            goto LABEL_988;
          }
          LODWORD(v807) = (v806 - 1) & ((v802 >> 4) ^ (v802 >> 9));
          v808 = (uint64_t ****)(v805 + 16 * v807);
          v809 = *v808;
          if (*v808 != v802)
          {
            int v810 = 1;
            while (v809 != (uint64_t ***)-4096)
            {
              int v811 = v807 + v810++;
              uint64_t v807 = v811 & (v806 - 1);
              v809 = *(uint64_t ****)(v805 + 16 * v807);
              if (v809 == v802)
              {
                v808 = (uint64_t ****)(v805 + 16 * v807);
                goto LABEL_989;
              }
            }
LABEL_988:
            v808 = (uint64_t ****)(v805 + 16 * v806);
          }
LABEL_989:
          v812 = v808[1];
          size_t v814 = (size_t)*v812;
          uint64_t result = (char *)(v812 + 2);
          size_t v813 = v814;
          goto LABEL_990;
        default:
          JUMPOUT(0);
      }
    }
    v832 = v9;
    if (v10 <= 191) {
      break;
    }
    if (!a3)
    {
      if (v9 == (uint64_t *)v7) {
        return result;
      }
      int64_t v449 = (unint64_t)(v11 - 2) >> 1;
      int64_t v450 = v449;
      while (1)
      {
        int64_t v451 = v450;
        if (v449 < v450) {
          goto LABEL_662;
        }
        uint64_t v452 = (2 * v450) | 1;
        v453 = &v9[v452];
        if (2 * v450 + 2 >= v11) {
          goto LABEL_559;
        }
        v454 = *(uint64_t ****)(*v453 + 8);
        v455 = *(uint64_t ****)(v453[1] + 8);
        if (v454)
        {
          if (v455)
          {
            if ((*((unsigned char *)v454 + 23) & 0x10) != 0)
            {
              uint64_t v456 = ***v454;
              uint64_t v457 = *(void *)(v456 + 152);
              uint64_t v458 = *(unsigned int *)(v456 + 168);
              if (v458)
              {
                LODWORD(v459) = (v458 - 1) & ((v454 >> 4) ^ (v454 >> 9));
                v460 = (uint64_t ****)(v457 + 16 * v459);
                v461 = *v460;
                if (*v460 != v454)
                {
                  int v462 = 1;
                  do
                  {
                    if (v461 == (uint64_t ***)-4096) {
                      goto LABEL_664;
                    }
                    int v463 = v459 + v462++;
                    uint64_t v459 = v463 & (v458 - 1);
                    v461 = *(uint64_t ****)(v457 + 16 * v459);
                  }
                  while (v461 != v454);
                  v460 = (uint64_t ****)(v457 + 16 * v459);
                }
              }
              else
              {
LABEL_664:
                v460 = (uint64_t ****)(v457 + 16 * v458);
              }
              v548 = v460[1];
              size_t v550 = (size_t)*v548;
              uint64_t result = (char *)(v548 + 2);
              size_t v549 = v550;
            }
            else
            {
              size_t v549 = 0;
              uint64_t result = &byte_1CFBCE98E;
            }
            if ((*((unsigned char *)v455 + 23) & 0x10) != 0)
            {
              uint64_t v551 = ***v455;
              uint64_t v552 = *(void *)(v551 + 152);
              uint64_t v553 = *(unsigned int *)(v551 + 168);
              if (v553)
              {
                LODWORD(v554) = (v553 - 1) & ((v455 >> 4) ^ (v455 >> 9));
                v555 = (uint64_t ****)(v552 + 16 * v554);
                v556 = *v555;
                if (*v555 != v455)
                {
                  int v557 = 1;
                  do
                  {
                    if (v556 == (uint64_t ***)-4096) {
                      goto LABEL_673;
                    }
                    int v558 = v554 + v557++;
                    uint64_t v554 = v558 & (v553 - 1);
                    v556 = *(uint64_t ****)(v552 + 16 * v554);
                  }
                  while (v556 != v455);
                  v555 = (uint64_t ****)(v552 + 16 * v554);
                }
              }
              else
              {
LABEL_673:
                v555 = (uint64_t ****)(v552 + 16 * v553);
              }
              v559 = v555[1];
              size_t v562 = (size_t)*v559;
              v560 = (char *)(v559 + 2);
              size_t v561 = v562;
            }
            else
            {
              size_t v561 = 0;
              v560 = &byte_1CFBCE98E;
            }
            if (v561 >= v549) {
              size_t v563 = v549;
            }
            else {
              size_t v563 = v561;
            }
            if (v563 && (uint64_t result = (char *)memcmp(result, v560, v563), result))
            {
              if ((result & 0x80000000) == 0) {
                goto LABEL_559;
              }
            }
            else if (v549 >= v561)
            {
              goto LABEL_559;
            }
LABEL_558:
            ++v453;
            uint64_t v452 = 2 * v451 + 2;
          }
        }
        else if (v455)
        {
          goto LABEL_558;
        }
LABEL_559:
        uint64_t v464 = *v453;
        unint64_t v9 = v832;
        uint64_t v465 = v832[v451];
        v466 = *(uint64_t ****)(*v453 + 8);
        v467 = *(uint64_t ****)(v465 + 8);
        if (v466)
        {
          if (v467)
          {
            if ((*((unsigned char *)v466 + 23) & 0x10) != 0)
            {
              uint64_t v468 = ***v466;
              uint64_t v469 = *(void *)(v468 + 152);
              uint64_t v470 = *(unsigned int *)(v468 + 168);
              if (v470)
              {
                LODWORD(v471) = (v470 - 1) & ((v466 >> 4) ^ (v466 >> 9));
                v472 = (uint64_t ****)(v469 + 16 * v471);
                v473 = *v472;
                if (*v472 != v466)
                {
                  int v474 = 1;
                  do
                  {
                    if (v473 == (uint64_t ***)-4096) {
                      goto LABEL_570;
                    }
                    int v475 = v471 + v474++;
                    uint64_t v471 = v475 & (v470 - 1);
                    v473 = *(uint64_t ****)(v469 + 16 * v471);
                  }
                  while (v473 != v466);
                  v472 = (uint64_t ****)(v469 + 16 * v471);
                }
              }
              else
              {
LABEL_570:
                v472 = (uint64_t ****)(v469 + 16 * v470);
              }
              v476 = v472[1];
              size_t v478 = (size_t)*v476;
              uint64_t result = (char *)(v476 + 2);
              size_t v477 = v478;
            }
            else
            {
              size_t v477 = 0;
              uint64_t result = &byte_1CFBCE98E;
            }
            if ((*((unsigned char *)v467 + 23) & 0x10) != 0)
            {
              uint64_t v479 = ***v467;
              uint64_t v480 = *(void *)(v479 + 152);
              uint64_t v481 = *(unsigned int *)(v479 + 168);
              if (v481)
              {
                LODWORD(v482) = (v481 - 1) & ((v467 >> 4) ^ (v467 >> 9));
                v483 = (uint64_t ****)(v480 + 16 * v482);
                v484 = *v483;
                if (*v483 != v467)
                {
                  int v485 = 1;
                  do
                  {
                    if (v484 == (uint64_t ***)-4096) {
                      goto LABEL_579;
                    }
                    int v486 = v482 + v485++;
                    uint64_t v482 = v486 & (v481 - 1);
                    v484 = *(uint64_t ****)(v480 + 16 * v482);
                  }
                  while (v484 != v467);
                  v483 = (uint64_t ****)(v480 + 16 * v482);
                }
              }
              else
              {
LABEL_579:
                v483 = (uint64_t ****)(v480 + 16 * v481);
              }
              v487 = v483[1];
              size_t v490 = (size_t)*v487;
              v488 = (char *)(v487 + 2);
              size_t v489 = v490;
            }
            else
            {
              size_t v489 = 0;
              v488 = &byte_1CFBCE98E;
            }
            if (v489 >= v477) {
              size_t v491 = v477;
            }
            else {
              size_t v491 = v489;
            }
            if (v491 && (uint64_t result = (char *)memcmp(result, v488, v491), result))
            {
              if ((result & 0x80000000) != 0) {
                goto LABEL_662;
              }
            }
            else if (v477 < v489)
            {
              goto LABEL_662;
            }
          }
        }
        else if (v467)
        {
          goto LABEL_662;
        }
        v832[v451] = v464;
        while (1)
        {
          if (v449 < v452) {
            goto LABEL_661;
          }
          v492 = v453;
          uint64_t v493 = 2 * v452;
          uint64_t v452 = (2 * v452) | 1;
          v453 = &v9[v452];
          uint64_t v494 = v493 + 2;
          if (v493 + 2 < v11)
          {
            v495 = *(uint64_t ****)(*v453 + 8);
            v496 = *(uint64_t ****)(v453[1] + 8);
            if (!v495)
            {
              if (!v496) {
                goto LABEL_603;
              }
LABEL_602:
              ++v453;
              uint64_t v452 = v494;
              goto LABEL_603;
            }
            if (!v496) {
              goto LABEL_603;
            }
            if ((*((unsigned char *)v495 + 23) & 0x10) != 0)
            {
              uint64_t v497 = ***v495;
              uint64_t v498 = *(void *)(v497 + 152);
              uint64_t v499 = *(unsigned int *)(v497 + 168);
              if (v499)
              {
                LODWORD(v500) = (v499 - 1) & ((v495 >> 4) ^ (v495 >> 9));
                v501 = (uint64_t ****)(v498 + 16 * v500);
                v502 = *v501;
                if (*v501 != v495)
                {
                  int v503 = 1;
                  do
                  {
                    if (v502 == (uint64_t ***)-4096) {
                      goto LABEL_635;
                    }
                    int v504 = v500 + v503++;
                    uint64_t v500 = v504 & (v499 - 1);
                    v502 = *(uint64_t ****)(v498 + 16 * v500);
                  }
                  while (v502 != v495);
                  v501 = (uint64_t ****)(v498 + 16 * v500);
                }
              }
              else
              {
LABEL_635:
                v501 = (uint64_t ****)(v498 + 16 * v499);
              }
              v532 = v501[1];
              size_t v534 = (size_t)*v532;
              uint64_t result = (char *)(v532 + 2);
              size_t v533 = v534;
            }
            else
            {
              size_t v533 = 0;
              uint64_t result = &byte_1CFBCE98E;
            }
            if ((*((unsigned char *)v496 + 23) & 0x10) != 0)
            {
              uint64_t v535 = ***v496;
              uint64_t v536 = *(void *)(v535 + 152);
              uint64_t v537 = *(unsigned int *)(v535 + 168);
              if (v537)
              {
                LODWORD(v538) = (v537 - 1) & ((v496 >> 4) ^ (v496 >> 9));
                v539 = (uint64_t ****)(v536 + 16 * v538);
                v540 = *v539;
                if (*v539 != v496)
                {
                  int v541 = 1;
                  do
                  {
                    if (v540 == (uint64_t ***)-4096) {
                      goto LABEL_644;
                    }
                    int v542 = v538 + v541++;
                    uint64_t v538 = v542 & (v537 - 1);
                    v540 = *(uint64_t ****)(v536 + 16 * v538);
                  }
                  while (v540 != v496);
                  v539 = (uint64_t ****)(v536 + 16 * v538);
                }
              }
              else
              {
LABEL_644:
                v539 = (uint64_t ****)(v536 + 16 * v537);
              }
              v543 = v539[1];
              size_t v546 = (size_t)*v543;
              v544 = (char *)(v543 + 2);
              size_t v545 = v546;
            }
            else
            {
              size_t v545 = 0;
              v544 = &byte_1CFBCE98E;
            }
            if (v545 >= v533) {
              size_t v547 = v533;
            }
            else {
              size_t v547 = v545;
            }
            if (v547 && (uint64_t result = (char *)memcmp(result, v544, v547), result))
            {
              int64_t v449 = (unint64_t)(v11 - 2) >> 1;
              if ((result & 0x80000000) != 0) {
                goto LABEL_602;
              }
            }
            else
            {
              BOOL v4 = v533 >= v545;
              int64_t v449 = (unint64_t)(v11 - 2) >> 1;
              if (!v4) {
                goto LABEL_602;
              }
            }
          }
LABEL_603:
          uint64_t v505 = *v453;
          v506 = *(uint64_t ****)(*v453 + 8);
          v507 = *(uint64_t ****)(v465 + 8);
          if (!v506)
          {
            unint64_t v9 = v832;
            if (v507) {
              goto LABEL_660;
            }
            goto LABEL_634;
          }
          unint64_t v9 = v832;
          if (!v507) {
            goto LABEL_634;
          }
          if ((*((unsigned char *)v506 + 23) & 0x10) != 0)
          {
            uint64_t v508 = ***v506;
            uint64_t v509 = *(void *)(v508 + 152);
            uint64_t v510 = *(unsigned int *)(v508 + 168);
            if (v510)
            {
              LODWORD(v511) = (v510 - 1) & ((v506 >> 4) ^ (v506 >> 9));
              v512 = (uint64_t ****)(v509 + 16 * v511);
              v513 = *v512;
              if (*v512 != v506)
              {
                int v514 = 1;
                do
                {
                  if (v513 == (uint64_t ***)-4096) {
                    goto LABEL_614;
                  }
                  int v515 = v511 + v514++;
                  uint64_t v511 = v515 & (v510 - 1);
                  v513 = *(uint64_t ****)(v509 + 16 * v511);
                }
                while (v513 != v506);
                v512 = (uint64_t ****)(v509 + 16 * v511);
              }
            }
            else
            {
LABEL_614:
              v512 = (uint64_t ****)(v509 + 16 * v510);
            }
            v516 = v512[1];
            unint64_t v518 = (unint64_t)*v516;
            uint64_t result = (char *)(v516 + 2);
            unint64_t v517 = v518;
          }
          else
          {
            unint64_t v517 = 0;
            uint64_t result = &byte_1CFBCE98E;
          }
          if ((*((unsigned char *)v507 + 23) & 0x10) != 0)
          {
            uint64_t v519 = ***v507;
            uint64_t v520 = *(void *)(v519 + 152);
            uint64_t v521 = *(unsigned int *)(v519 + 168);
            if (v521)
            {
              LODWORD(v522) = (v521 - 1) & ((v507 >> 4) ^ (v507 >> 9));
              v523 = (uint64_t ****)(v520 + 16 * v522);
              v524 = *v523;
              if (*v523 != v507)
              {
                int v525 = 1;
                do
                {
                  if (v524 == (uint64_t ***)-4096) {
                    goto LABEL_623;
                  }
                  int v526 = v522 + v525++;
                  uint64_t v522 = v526 & (v521 - 1);
                  v524 = *(uint64_t ****)(v520 + 16 * v522);
                }
                while (v524 != v507);
                v523 = (uint64_t ****)(v520 + 16 * v522);
              }
            }
            else
            {
LABEL_623:
              v523 = (uint64_t ****)(v520 + 16 * v521);
            }
            v527 = v523[1];
            unint64_t v530 = (unint64_t)*v527;
            v528 = (char *)(v527 + 2);
            unint64_t v529 = v530;
          }
          else
          {
            unint64_t v529 = 0;
            v528 = &byte_1CFBCE98E;
          }
          size_t v531 = v529 >= v517 ? v517 : v529;
          if (!v531) {
            break;
          }
          uint64_t result = (char *)memcmp(result, v528, v531);
          if (!result) {
            break;
          }
          int64_t v449 = (unint64_t)(v11 - 2) >> 1;
          if ((result & 0x80000000) != 0) {
            goto LABEL_660;
          }
LABEL_634:
          uint64_t *v492 = v505;
        }
        BOOL v4 = v517 >= v529;
        int64_t v449 = (unint64_t)(v11 - 2) >> 1;
        if (v4) {
          goto LABEL_634;
        }
LABEL_660:
        v453 = v492;
LABEL_661:
        uint64_t *v453 = v465;
LABEL_662:
        int64_t v450 = v451 - 1;
        if (!v451)
        {
LABEL_724:
          uint64_t v598 = 0;
          uint64_t v599 = *v9;
          v566 = (char *)v9;
          while (1)
          {
            v600 = v566;
            v566 += 8 * v598 + 8;
            uint64_t v601 = 2 * v598;
            uint64_t v598 = (2 * v598) | 1;
            uint64_t v602 = v601 + 2;
            if (v601 + 2 < v11)
            {
              v603 = *(uint64_t ****)(*(void *)v566 + 8);
              v604 = *(uint64_t ****)(*((void *)v566 + 1) + 8);
              if (v603)
              {
                if (v604)
                {
                  if ((*((unsigned char *)v603 + 23) & 0x10) != 0)
                  {
                    uint64_t v605 = ***v603;
                    uint64_t v606 = *(void *)(v605 + 152);
                    uint64_t v607 = *(unsigned int *)(v605 + 168);
                    if (!v607) {
                      goto LABEL_739;
                    }
                    LODWORD(v608) = (v607 - 1) & ((v603 >> 4) ^ (v603 >> 9));
                    v609 = (uint64_t ****)(v606 + 16 * v608);
                    v610 = *v609;
                    if (*v609 != v603)
                    {
                      int v611 = 1;
                      while (v610 != (uint64_t ***)-4096)
                      {
                        int v612 = v608 + v611++;
                        uint64_t v608 = v612 & (v607 - 1);
                        v610 = *(uint64_t ****)(v606 + 16 * v608);
                        if (v610 == v603)
                        {
                          v609 = (uint64_t ****)(v606 + 16 * v608);
                          goto LABEL_740;
                        }
                      }
LABEL_739:
                      v609 = (uint64_t ****)(v606 + 16 * v607);
                    }
LABEL_740:
                    v613 = v609[1];
                    size_t v615 = (size_t)*v613;
                    uint64_t result = (char *)(v613 + 2);
                    size_t v614 = v615;
                  }
                  else
                  {
                    size_t v614 = 0;
                    uint64_t result = &byte_1CFBCE98E;
                  }
                  if ((*((unsigned char *)v604 + 23) & 0x10) != 0)
                  {
                    uint64_t v616 = ***v604;
                    uint64_t v617 = *(void *)(v616 + 152);
                    uint64_t v618 = *(unsigned int *)(v616 + 168);
                    if (!v618) {
                      goto LABEL_748;
                    }
                    LODWORD(v619) = (v618 - 1) & ((v604 >> 4) ^ (v604 >> 9));
                    v620 = (uint64_t ****)(v617 + 16 * v619);
                    v621 = *v620;
                    if (*v620 != v604)
                    {
                      int v622 = 1;
                      while (v621 != (uint64_t ***)-4096)
                      {
                        int v623 = v619 + v622++;
                        uint64_t v619 = v623 & (v618 - 1);
                        v621 = *(uint64_t ****)(v617 + 16 * v619);
                        if (v621 == v604)
                        {
                          v620 = (uint64_t ****)(v617 + 16 * v619);
                          goto LABEL_749;
                        }
                      }
LABEL_748:
                      v620 = (uint64_t ****)(v617 + 16 * v618);
                    }
LABEL_749:
                    v624 = v620[1];
                    size_t v627 = (size_t)*v624;
                    v625 = (char *)(v624 + 2);
                    size_t v626 = v627;
                  }
                  else
                  {
                    size_t v626 = 0;
                    v625 = &byte_1CFBCE98E;
                  }
                  if (v626 >= v614) {
                    size_t v628 = v614;
                  }
                  else {
                    size_t v628 = v626;
                  }
                  if (v628 && (uint64_t result = (char *)memcmp(result, v625, v628), result))
                  {
                    if ((result & 0x80000000) == 0) {
                      goto LABEL_737;
                    }
                  }
                  else if (v614 >= v626)
                  {
                    goto LABEL_737;
                  }
LABEL_736:
                  v566 += 8;
                  uint64_t v598 = v602;
                }
              }
              else if (v604)
              {
                goto LABEL_736;
              }
            }
LABEL_737:
            *(void *)v600 = *(void *)v566;
            if (v598 > (uint64_t)((unint64_t)(v11 - 2) >> 1))
            {
              v629 = a2 - 8;
              BOOL v5 = v566 == a2 - 8;
              a2 -= 8;
              if (v5) {
                goto LABEL_795;
              }
              *(void *)v566 = *(void *)v629;
              *(void *)v629 = v599;
              uint64_t v630 = v566 - (char *)v832 + 8;
              if (v630 >= 9)
              {
                unint64_t v631 = ((unint64_t)v630 >> 3) - 2;
                unint64_t v565 = v631 >> 1;
                v594 = &v832[v631 >> 1];
                uint64_t v632 = *v594;
                uint64_t v599 = *(void *)v566;
                v633 = *(uint64_t ****)(*v594 + 8);
                v634 = *(uint64_t ****)(*(void *)v566 + 8);
                if (!v633)
                {
                  if (v634) {
                    goto LABEL_793;
                  }
                  goto LABEL_796;
                }
                if (!v634) {
                  goto LABEL_796;
                }
                if ((*((unsigned char *)v633 + 23) & 0x10) != 0)
                {
                  uint64_t v635 = ***v633;
                  uint64_t v636 = *(void *)(v635 + 152);
                  uint64_t v637 = *(unsigned int *)(v635 + 168);
                  if (!v637) {
                    goto LABEL_774;
                  }
                  LODWORD(v638) = (v637 - 1) & ((v633 >> 4) ^ (v633 >> 9));
                  v639 = (uint64_t ****)(v636 + 16 * v638);
                  v640 = *v639;
                  if (*v639 != v633)
                  {
                    int v641 = 1;
                    while (v640 != (uint64_t ***)-4096)
                    {
                      int v642 = v638 + v641++;
                      uint64_t v638 = v642 & (v637 - 1);
                      v640 = *(uint64_t ****)(v636 + 16 * v638);
                      if (v640 == v633)
                      {
                        v639 = (uint64_t ****)(v636 + 16 * v638);
                        goto LABEL_775;
                      }
                    }
LABEL_774:
                    v639 = (uint64_t ****)(v636 + 16 * v637);
                  }
LABEL_775:
                  v643 = v639[1];
                  size_t v644 = (size_t)*v643;
                  uint64_t result = (char *)(v643 + 2);
                  size_t v595 = v644;
                }
                else
                {
                  size_t v595 = 0;
                  uint64_t result = &byte_1CFBCE98E;
                }
                if ((*((unsigned char *)v634 + 23) & 0x10) != 0)
                {
                  uint64_t v645 = ***v634;
                  uint64_t v646 = *(void *)(v645 + 152);
                  uint64_t v647 = *(unsigned int *)(v645 + 168);
                  if (!v647) {
                    goto LABEL_783;
                  }
                  LODWORD(v648) = (v647 - 1) & ((v634 >> 4) ^ (v634 >> 9));
                  v649 = (uint64_t ****)(v646 + 16 * v648);
                  v650 = *v649;
                  if (*v649 != v634)
                  {
                    int v651 = 1;
                    while (v650 != (uint64_t ***)-4096)
                    {
                      int v652 = v648 + v651++;
                      uint64_t v648 = v652 & (v647 - 1);
                      v650 = *(uint64_t ****)(v646 + 16 * v648);
                      if (v650 == v634)
                      {
                        v649 = (uint64_t ****)(v646 + 16 * v648);
                        goto LABEL_784;
                      }
                    }
LABEL_783:
                    v649 = (uint64_t ****)(v646 + 16 * v647);
                  }
LABEL_784:
                  v653 = v649[1];
                  size_t v654 = (size_t)*v653;
                  v597 = (char *)(v653 + 2);
                  size_t v596 = v654;
                }
                else
                {
                  size_t v596 = 0;
                  v597 = &byte_1CFBCE98E;
                }
                if (v596 >= v595) {
                  size_t v655 = v595;
                }
                else {
                  size_t v655 = v596;
                }
                if (!v655 || (uint64_t result = (char *)memcmp(result, v597, v655), !result))
                {
                  if (v595 < v596) {
                    goto LABEL_793;
                  }
                  goto LABEL_796;
                }
                if ((result & 0x80000000) == 0) {
                  goto LABEL_796;
                }
LABEL_793:
                *(void *)v566 = v632;
                if (v631 < 2)
                {
LABEL_794:
                  v566 = (char *)v594;
LABEL_795:
                  *(void *)v566 = v599;
                  goto LABEL_796;
                }
                while (2)
                {
                  unint64_t v564 = v565 - 1;
                  unint64_t v565 = (v565 - 1) >> 1;
                  v566 = (char *)&v832[v565];
                  uint64_t v567 = *(void *)v566;
                  v568 = *(uint64_t ****)(*(void *)v566 + 8);
                  v569 = *(uint64_t ****)(v599 + 8);
                  if (v568)
                  {
                    if (!v569) {
                      goto LABEL_794;
                    }
                    if ((*((unsigned char *)v568 + 23) & 0x10) != 0)
                    {
                      uint64_t v570 = ***v568;
                      uint64_t v571 = *(void *)(v570 + 152);
                      uint64_t v572 = *(unsigned int *)(v570 + 168);
                      if (!v572) {
                        goto LABEL_699;
                      }
                      LODWORD(v573) = (v572 - 1) & ((v568 >> 4) ^ (v568 >> 9));
                      v574 = (uint64_t ****)(v571 + 16 * v573);
                      v575 = *v574;
                      if (*v574 != v568)
                      {
                        int v576 = 1;
                        while (v575 != (uint64_t ***)-4096)
                        {
                          int v577 = v573 + v576++;
                          uint64_t v573 = v577 & (v572 - 1);
                          v575 = *(uint64_t ****)(v571 + 16 * v573);
                          if (v575 == v568)
                          {
                            v574 = (uint64_t ****)(v571 + 16 * v573);
                            goto LABEL_700;
                          }
                        }
LABEL_699:
                        v574 = (uint64_t ****)(v571 + 16 * v572);
                      }
LABEL_700:
                      v578 = v574[1];
                      size_t v580 = (size_t)*v578;
                      uint64_t result = (char *)(v578 + 2);
                      size_t v579 = v580;
                    }
                    else
                    {
                      size_t v579 = 0;
                      uint64_t result = &byte_1CFBCE98E;
                    }
                    if ((*((unsigned char *)v569 + 23) & 0x10) != 0)
                    {
                      uint64_t v581 = ***v569;
                      uint64_t v582 = *(void *)(v581 + 152);
                      uint64_t v583 = *(unsigned int *)(v581 + 168);
                      if (!v583) {
                        goto LABEL_708;
                      }
                      LODWORD(v584) = (v583 - 1) & ((v569 >> 4) ^ (v569 >> 9));
                      v585 = (uint64_t ****)(v582 + 16 * v584);
                      v586 = *v585;
                      if (*v585 != v569)
                      {
                        int v587 = 1;
                        while (v586 != (uint64_t ***)-4096)
                        {
                          int v588 = v584 + v587++;
                          uint64_t v584 = v588 & (v583 - 1);
                          v586 = *(uint64_t ****)(v582 + 16 * v584);
                          if (v586 == v569)
                          {
                            v585 = (uint64_t ****)(v582 + 16 * v584);
                            goto LABEL_709;
                          }
                        }
LABEL_708:
                        v585 = (uint64_t ****)(v582 + 16 * v583);
                      }
LABEL_709:
                      v589 = v585[1];
                      size_t v592 = (size_t)*v589;
                      v590 = (char *)(v589 + 2);
                      size_t v591 = v592;
                    }
                    else
                    {
                      size_t v591 = 0;
                      v590 = &byte_1CFBCE98E;
                    }
                    if (v591 >= v579) {
                      size_t v593 = v579;
                    }
                    else {
                      size_t v593 = v591;
                    }
                    if (v593 && (uint64_t result = (char *)memcmp(result, v590, v593), result))
                    {
                      if ((result & 0x80000000) == 0) {
                        goto LABEL_794;
                      }
                    }
                    else if (v579 >= v591)
                    {
                      goto LABEL_794;
                    }
                  }
                  else if (!v569)
                  {
                    goto LABEL_794;
                  }
                  uint64_t *v594 = v567;
                  v594 = &v832[v565];
                  if (v564 <= 1) {
                    goto LABEL_795;
                  }
                  continue;
                }
              }
LABEL_796:
              BOOL v656 = v11-- <= 2;
              unint64_t v9 = v832;
              if (v656) {
                return result;
              }
              goto LABEL_724;
            }
          }
        }
      }
    }
    unint64_t v12 = (unint64_t)v11 >> 1;
    unint64_t v13 = (char *)&v9[(unint64_t)v11 >> 1];
    if ((unint64_t)v10 < 0x401)
    {
      uint64_t result = sub_1CBFAC870(v13, (char *)v9, v828);
    }
    else
    {
      sub_1CBFAC870((char *)v9, v13, v828);
      sub_1CBFAC870((char *)v9 + 8, v13 - 8, a2 - 16);
      sub_1CBFAC870((char *)v9 + 16, (char *)&v9[v12 + 1], a2 - 24);
      uint64_t result = sub_1CBFAC870(v13 - 8, v13, (char *)&v9[v12 + 1]);
      uint64_t v14 = *v9;
      *unint64_t v9 = *(void *)v13;
      *(void *)unint64_t v13 = v14;
    }
    uint64_t v15 = *v9;
    --a3;
    if (a4)
    {
      uint64_t v16 = *(uint64_t ****)(v15 + 8);
LABEL_83:
      unsigned int v80 = (v16 >> 4) ^ (v16 >> 9);
      uint64_t v81 = v9;
      do
      {
        while (1)
        {
          while (1)
          {
            uint64_t v82 = v81;
            uint64_t v84 = v81[1];
            ++v81;
            uint64_t v83 = v84;
            unsigned int v85 = *(uint64_t ****)(v84 + 8);
            if (v85) {
              break;
            }
            if (!v16) {
              goto LABEL_117;
            }
          }
          if (!v16) {
            goto LABEL_117;
          }
          if ((*((unsigned char *)v85 + 23) & 0x10) != 0)
          {
            uint64_t v86 = ***v85;
            uint64_t v87 = *(void *)(v86 + 152);
            uint64_t v88 = *(unsigned int *)(v86 + 168);
            if (v88)
            {
              LODWORD(v89) = (v88 - 1) & ((v85 >> 4) ^ (v85 >> 9));
              int v90 = (uint64_t ****)(v87 + 16 * v89);
              int v91 = *v90;
              if (*v90 == v85)
              {
LABEL_96:
                uint64_t v94 = v90[1];
                unint64_t v97 = (unint64_t)*v94;
                unsigned int v95 = (char *)(v94 + 2);
                unint64_t v96 = v97;
                goto LABEL_97;
              }
              int v92 = 1;
              while (v91 != (uint64_t ***)-4096)
              {
                int v93 = v89 + v92++;
                uint64_t v89 = v93 & (v88 - 1);
                int v91 = *(uint64_t ****)(v87 + 16 * v89);
                if (v91 == v85)
                {
                  int v90 = (uint64_t ****)(v87 + 16 * v89);
                  goto LABEL_96;
                }
              }
            }
            int v90 = (uint64_t ****)(v87 + 16 * v88);
            goto LABEL_96;
          }
          unint64_t v96 = 0;
          unsigned int v95 = &byte_1CFBCE98E;
LABEL_97:
          if ((*((unsigned char *)v16 + 23) & 0x10) != 0)
          {
            uint64_t v98 = ***v16;
            uint64_t v99 = *(void *)(v98 + 152);
            uint64_t v100 = *(unsigned int *)(v98 + 168);
            if (v100)
            {
              LODWORD(v101) = (v100 - 1) & v80;
              uint64_t v102 = (uint64_t ****)(v99 + 16 * v101);
              uint64_t v103 = *v102;
              if (*v102 == v16)
              {
LABEL_105:
                uint64_t v106 = v102[1];
                unint64_t v109 = (unint64_t)*v106;
                unsigned int v107 = (char *)(v106 + 2);
                unint64_t v108 = v109;
                goto LABEL_106;
              }
              int v104 = 1;
              while (v103 != (uint64_t ***)-4096)
              {
                int v105 = v101 + v104++;
                uint64_t v101 = v105 & (v100 - 1);
                uint64_t v103 = *(uint64_t ****)(v99 + 16 * v101);
                if (v103 == v16)
                {
                  uint64_t v102 = (uint64_t ****)(v99 + 16 * v101);
                  goto LABEL_105;
                }
              }
            }
            uint64_t v102 = (uint64_t ****)(v99 + 16 * v100);
            goto LABEL_105;
          }
          unint64_t v108 = 0;
          unsigned int v107 = &byte_1CFBCE98E;
LABEL_106:
          size_t v110 = v108 >= v96 ? v96 : v108;
          if (!v110) {
            break;
          }
          int v111 = memcmp(v95, v107, v110);
          if (!v111) {
            break;
          }
          if ((v111 & 0x80000000) == 0) {
            goto LABEL_117;
          }
        }
      }
      while (v96 < v108);
LABEL_117:
      int v112 = v16;
      uint64_t v113 = a2;
      if (v82 != v9)
      {
        while (1)
        {
          do
          {
            while (1)
            {
              uint64_t v114 = v112;
              uint64_t v115 = *((void *)v113 - 1);
              v113 -= 8;
              unint64_t v116 = *(uint64_t ****)(v115 + 8);
              if (v116) {
                break;
              }
              int v112 = 0;
              if (v114) {
                goto LABEL_189;
              }
            }
            int v112 = 0;
          }
          while (!v114);
          if ((*((unsigned char *)v116 + 23) & 0x10) != 0) {
            break;
          }
          size_t v127 = 0;
          int v126 = &byte_1CFBCE98E;
LABEL_131:
          if ((*((unsigned char *)v114 + 23) & 0x10) == 0)
          {
            size_t v139 = 0;
            uint64_t v138 = &byte_1CFBCE98E;
            goto LABEL_140;
          }
          uint64_t v129 = ***v114;
          uint64_t v130 = *(void *)(v129 + 152);
          uint64_t v131 = *(unsigned int *)(v129 + 168);
          if (!v131) {
            goto LABEL_138;
          }
          LODWORD(v132) = (v131 - 1) & ((v114 >> 4) ^ (v114 >> 9));
          uint64_t v133 = (uint64_t ****)(v130 + 16 * v132);
          long long v134 = *v133;
          if (*v133 != v114)
          {
            int v135 = 1;
            while (v134 != (uint64_t ***)-4096)
            {
              int v136 = v132 + v135++;
              uint64_t v132 = v136 & (v131 - 1);
              long long v134 = *(uint64_t ****)(v130 + 16 * v132);
              if (v134 == v114)
              {
                uint64_t v133 = (uint64_t ****)(v130 + 16 * v132);
                goto LABEL_139;
              }
            }
LABEL_138:
            uint64_t v133 = (uint64_t ****)(v130 + 16 * v131);
          }
LABEL_139:
          int v137 = v133[1];
          size_t v140 = (size_t)*v137;
          uint64_t v138 = (char *)(v137 + 2);
          size_t v139 = v140;
LABEL_140:
          if (v139 >= v127) {
            size_t v141 = v127;
          }
          else {
            size_t v141 = v139;
          }
          if (v141 && (int v142 = memcmp(v126, v138, v141)) != 0)
          {
            int v112 = v16;
            if (v142 < 0) {
              goto LABEL_189;
            }
          }
          else
          {
            int v112 = v16;
            if (v127 < v139) {
              goto LABEL_189;
            }
          }
        }
        uint64_t v117 = ***v116;
        uint64_t v118 = *(void *)(v117 + 152);
        uint64_t v119 = *(unsigned int *)(v117 + 168);
        if (v119)
        {
          LODWORD(v120) = (v119 - 1) & ((v116 >> 4) ^ (v116 >> 9));
          uint64_t v121 = (uint64_t ****)(v118 + 16 * v120);
          unsigned int v122 = *v121;
          if (*v121 != v116)
          {
            int v123 = 1;
            while (v122 != (uint64_t ***)-4096)
            {
              int v124 = v120 + v123++;
              uint64_t v120 = v124 & (v119 - 1);
              unsigned int v122 = *(uint64_t ****)(v118 + 16 * v120);
              if (v122 == v116)
              {
                uint64_t v121 = (uint64_t ****)(v118 + 16 * v120);
                goto LABEL_130;
              }
            }
            goto LABEL_129;
          }
        }
        else
        {
LABEL_129:
          uint64_t v121 = (uint64_t ****)(v118 + 16 * v119);
        }
LABEL_130:
        uint64_t v125 = v121[1];
        size_t v128 = (size_t)*v125;
        int v126 = (char *)(v125 + 2);
        size_t v127 = v128;
        goto LABEL_131;
      }
      uint64_t v113 = a2;
      if (v81 < (uint64_t *)a2)
      {
        uint64_t v113 = a2;
        while (1)
        {
          uint64_t v143 = *((void *)v113 - 1);
          v113 -= 8;
          int v144 = *(uint64_t ****)(v143 + 8);
          if (!v144) {
            break;
          }
          if (v16)
          {
            if ((*((unsigned char *)v144 + 23) & 0x10) != 0)
            {
              uint64_t v145 = ***v144;
              uint64_t v146 = *(void *)(v145 + 152);
              uint64_t v147 = *(unsigned int *)(v145 + 168);
              if (!v147) {
                goto LABEL_165;
              }
              LODWORD(v148) = (v147 - 1) & ((v144 >> 4) ^ (v144 >> 9));
              uint64_t v149 = (uint64_t ****)(v146 + 16 * v148);
              unint64_t v150 = *v149;
              if (*v149 != v144)
              {
                int v151 = 1;
                while (v150 != (uint64_t ***)-4096)
                {
                  int v152 = v148 + v151++;
                  uint64_t v148 = v152 & (v147 - 1);
                  unint64_t v150 = *(uint64_t ****)(v146 + 16 * v148);
                  if (v150 == v144)
                  {
                    uint64_t v149 = (uint64_t ****)(v146 + 16 * v148);
                    goto LABEL_166;
                  }
                }
LABEL_165:
                uint64_t v149 = (uint64_t ****)(v146 + 16 * v147);
              }
LABEL_166:
              unsigned int v153 = v149[1];
              size_t v156 = (size_t)*v153;
              unsigned int v154 = (char *)(v153 + 2);
              size_t v155 = v156;
              goto LABEL_167;
            }
            size_t v155 = 0;
            unsigned int v154 = &byte_1CFBCE98E;
LABEL_167:
            if ((*((unsigned char *)v16 + 23) & 0x10) == 0)
            {
              size_t v167 = 0;
              v166 = &byte_1CFBCE98E;
              goto LABEL_176;
            }
            uint64_t v157 = ***v16;
            uint64_t v158 = *(void *)(v157 + 152);
            uint64_t v159 = *(unsigned int *)(v157 + 168);
            if (!v159) {
              goto LABEL_174;
            }
            LODWORD(v160) = (v159 - 1) & v80;
            v161 = (uint64_t ****)(v158 + 16 * v160);
            uint64_t v162 = *v161;
            if (*v161 != v16)
            {
              int v163 = 1;
              while (v162 != (uint64_t ***)-4096)
              {
                int v164 = v160 + v163++;
                uint64_t v160 = v164 & (v159 - 1);
                uint64_t v162 = *(uint64_t ****)(v158 + 16 * v160);
                if (v162 == v16)
                {
                  v161 = (uint64_t ****)(v158 + 16 * v160);
                  goto LABEL_175;
                }
              }
LABEL_174:
              v161 = (uint64_t ****)(v158 + 16 * v159);
            }
LABEL_175:
            uint64_t v165 = v161[1];
            size_t v168 = (size_t)*v165;
            v166 = (char *)(v165 + 2);
            size_t v167 = v168;
LABEL_176:
            if (v167 >= v155) {
              size_t v169 = v155;
            }
            else {
              size_t v169 = v167;
            }
            if (v169 && (int v170 = memcmp(v154, v166, v169)) != 0)
            {
              BOOL v171 = v170 >= 0;
            }
            else
            {
              if (v155 < v167) {
                goto LABEL_189;
              }
              BOOL v171 = 1;
            }
            if (v81 >= (uint64_t *)v113 || !v171) {
              goto LABEL_189;
            }
          }
          else
          {
LABEL_163:
            if (v81 >= (uint64_t *)v113) {
              goto LABEL_189;
            }
          }
        }
        if (v16) {
          goto LABEL_189;
        }
        goto LABEL_163;
      }
LABEL_189:
      if (v81 >= (uint64_t *)v113)
      {
        uint64_t i = v81;
        goto LABEL_263;
      }
      uint64_t v172 = *(void *)v113;
      uint64_t i = v81;
      uint64_t v173 = (uint64_t *)v113;
      while (2)
      {
        *uint64_t i = v172;
        *uint64_t v173 = v83;
        uint64_t v174 = *(uint64_t ****)(v15 + 8);
        while (2)
        {
          while (2)
          {
            while (1)
            {
              uint64_t v175 = i[1];
              ++i;
              uint64_t v83 = v175;
              uint64_t v176 = *(uint64_t ****)(v175 + 8);
              if (v176) {
                break;
              }
              if (!v174)
              {
LABEL_225:
                int v203 = 0;
                goto LABEL_227;
              }
            }
            if (!v174) {
              goto LABEL_225;
            }
            if ((*((unsigned char *)v176 + 23) & 0x10) != 0)
            {
              uint64_t v177 = ***v176;
              uint64_t v178 = *(void *)(v177 + 152);
              uint64_t v179 = *(unsigned int *)(v177 + 168);
              if (!v179) {
                goto LABEL_203;
              }
              LODWORD(v180) = (v179 - 1) & ((v176 >> 4) ^ (v176 >> 9));
              unint64_t v181 = (uint64_t ****)(v178 + 16 * v180);
              int v182 = *v181;
              if (*v181 != v176)
              {
                int v183 = 1;
                while (v182 != (uint64_t ***)-4096)
                {
                  int v184 = v180 + v183++;
                  uint64_t v180 = v184 & (v179 - 1);
                  int v182 = *(uint64_t ****)(v178 + 16 * v180);
                  if (v182 == v176)
                  {
                    unint64_t v181 = (uint64_t ****)(v178 + 16 * v180);
                    goto LABEL_204;
                  }
                }
LABEL_203:
                unint64_t v181 = (uint64_t ****)(v178 + 16 * v179);
              }
LABEL_204:
              int v185 = v181[1];
              size_t v188 = (size_t)*v185;
              uint64_t v186 = (char *)(v185 + 2);
              size_t v187 = v188;
            }
            else
            {
              size_t v187 = 0;
              uint64_t v186 = &byte_1CFBCE98E;
            }
            if ((*((unsigned char *)v174 + 23) & 0x10) != 0)
            {
              uint64_t v189 = ***v174;
              uint64_t v190 = *(void *)(v189 + 152);
              uint64_t v191 = *(unsigned int *)(v189 + 168);
              if (!v191) {
                goto LABEL_212;
              }
              LODWORD(v192) = (v191 - 1) & ((v174 >> 4) ^ (v174 >> 9));
              uint64_t v193 = (uint64_t ****)(v190 + 16 * v192);
              unsigned int v194 = *v193;
              if (*v193 != v174)
              {
                int v195 = 1;
                while (v194 != (uint64_t ***)-4096)
                {
                  int v196 = v192 + v195++;
                  uint64_t v192 = v196 & (v191 - 1);
                  unsigned int v194 = *(uint64_t ****)(v190 + 16 * v192);
                  if (v194 == v174)
                  {
                    uint64_t v193 = (uint64_t ****)(v190 + 16 * v192);
                    goto LABEL_213;
                  }
                }
LABEL_212:
                uint64_t v193 = (uint64_t ****)(v190 + 16 * v191);
              }
LABEL_213:
              int v197 = v193[1];
              size_t v200 = (size_t)*v197;
              uint64_t v198 = (char *)(v197 + 2);
              size_t v199 = v200;
            }
            else
            {
              size_t v199 = 0;
              uint64_t v198 = &byte_1CFBCE98E;
            }
            if (v199 >= v187) {
              size_t v201 = v187;
            }
            else {
              size_t v201 = v199;
            }
            if (v201)
            {
              int v202 = memcmp(v186, v198, v201);
              if (v202)
              {
                if ((v202 & 0x80000000) == 0) {
                  goto LABEL_226;
                }
                continue;
              }
            }
            break;
          }
          if (v187 < v199) {
            continue;
          }
          break;
        }
LABEL_226:
        int v203 = v174;
        do
        {
LABEL_227:
          while (1)
          {
            v204 = v203;
            uint64_t v205 = *--v173;
            uint64_t v172 = v205;
            uint64_t v206 = *(uint64_t ****)(v205 + 8);
            if (v206) {
              break;
            }
            int v203 = v174;
            if (v204) {
              goto LABEL_260;
            }
          }
          int v203 = v174;
        }
        while (!v204);
        if ((*((unsigned char *)v206 + 23) & 0x10) != 0)
        {
          uint64_t v207 = ***v206;
          uint64_t v208 = *(void *)(v207 + 152);
          uint64_t v209 = *(unsigned int *)(v207 + 168);
          if (!v209) {
            goto LABEL_238;
          }
          LODWORD(v210) = (v209 - 1) & ((v206 >> 4) ^ (v206 >> 9));
          uint64_t v211 = (uint64_t ****)(v208 + 16 * v210);
          uint64_t v212 = *v211;
          if (*v211 != v206)
          {
            int v213 = 1;
            while (v212 != (uint64_t ***)-4096)
            {
              int v214 = v210 + v213++;
              uint64_t v210 = v214 & (v209 - 1);
              uint64_t v212 = *(uint64_t ****)(v208 + 16 * v210);
              if (v212 == v206)
              {
                uint64_t v211 = (uint64_t ****)(v208 + 16 * v210);
                goto LABEL_239;
              }
            }
LABEL_238:
            uint64_t v211 = (uint64_t ****)(v208 + 16 * v209);
          }
LABEL_239:
          uint64_t v215 = v211[1];
          size_t v218 = (size_t)*v215;
          unint64_t v216 = (char *)(v215 + 2);
          size_t v217 = v218;
        }
        else
        {
          size_t v217 = 0;
          unint64_t v216 = &byte_1CFBCE98E;
        }
        if ((*((unsigned char *)v204 + 23) & 0x10) != 0)
        {
          uint64_t v219 = ***v204;
          uint64_t v220 = *(void *)(v219 + 152);
          uint64_t v221 = *(unsigned int *)(v219 + 168);
          if (!v221) {
            goto LABEL_247;
          }
          LODWORD(v222) = (v221 - 1) & ((v204 >> 4) ^ (v204 >> 9));
          uint64_t v223 = (uint64_t ****)(v220 + 16 * v222);
          int v224 = *v223;
          if (*v223 != v204)
          {
            int v225 = 1;
            while (v224 != (uint64_t ***)-4096)
            {
              int v226 = v222 + v225++;
              uint64_t v222 = v226 & (v221 - 1);
              int v224 = *(uint64_t ****)(v220 + 16 * v222);
              if (v224 == v204)
              {
                uint64_t v223 = (uint64_t ****)(v220 + 16 * v222);
                goto LABEL_248;
              }
            }
LABEL_247:
            uint64_t v223 = (uint64_t ****)(v220 + 16 * v221);
          }
LABEL_248:
          unsigned int v227 = v223[1];
          size_t v230 = (size_t)*v227;
          int v228 = (char *)(v227 + 2);
          size_t v229 = v230;
        }
        else
        {
          size_t v229 = 0;
          int v228 = &byte_1CFBCE98E;
        }
        if (v229 >= v217) {
          size_t v231 = v217;
        }
        else {
          size_t v231 = v229;
        }
        if (v231)
        {
          int v232 = memcmp(v216, v228, v231);
          if (v232)
          {
            int v203 = v174;
            if (v232 < 0) {
              goto LABEL_260;
            }
            goto LABEL_227;
          }
        }
        int v203 = v174;
        if (v217 >= v229) {
          goto LABEL_227;
        }
LABEL_260:
        if (i < v173) {
          continue;
        }
        break;
      }
LABEL_263:
      uint64_t v233 = i - 1;
      uint64_t v6 = v832;
      if (i - 1 != v832) {
        uint64_t *v832 = *v233;
      }
      *uint64_t v233 = v15;
      uint64_t v7 = a2;
      if (v81 < (uint64_t *)v113)
      {
LABEL_268:
        uint64_t result = (char *)sub_1CBFA9C78(v832, i - 1, a3, a4 & 1);
        a4 = 0;
      }
      else
      {
        BOOL v234 = sub_1CBFACF78(v832, (char *)i - 8);
        uint64_t result = (char *)sub_1CBFACF78(i, a2);
        if (result)
        {
          a2 = (char *)(i - 1);
          if (v234) {
            return result;
          }
          goto LABEL_2;
        }
        if (!v234) {
          goto LABEL_268;
        }
      }
    }
    else
    {
      unint64_t v17 = *(uint64_t ****)(*(v9 - 1) + 8);
      uint64_t v16 = *(uint64_t ****)(v15 + 8);
      if (!v17)
      {
        if (v16) {
          goto LABEL_83;
        }
LABEL_22:
        unsigned int v26 = (uint64_t ****)(v15 + 8);
        uint64_t v27 = *(void *)v828;
        if (*(void *)(*(void *)v828 + 8)) {
          goto LABEL_23;
        }
        goto LABEL_291;
      }
      if (!v16) {
        goto LABEL_22;
      }
      if ((*((unsigned char *)v17 + 23) & 0x10) != 0)
      {
        uint64_t v18 = ***v17;
        uint64_t v19 = *(void *)(v18 + 152);
        uint64_t v20 = *(unsigned int *)(v18 + 168);
        if (!v20) {
          goto LABEL_57;
        }
        LODWORD(v21) = (v20 - 1) & ((v17 >> 4) ^ (v17 >> 9));
        uint64_t v22 = (uint64_t ****)(v19 + 16 * v21);
        uint64_t v23 = *v22;
        if (*v22 != v17)
        {
          int v24 = 1;
          while (v23 != (uint64_t ***)-4096)
          {
            int v25 = v21 + v24++;
            uint64_t v21 = v25 & (v20 - 1);
            uint64_t v23 = *(uint64_t ****)(v19 + 16 * v21);
            if (v23 == v17)
            {
              uint64_t v22 = (uint64_t ****)(v19 + 16 * v21);
              goto LABEL_58;
            }
          }
LABEL_57:
          uint64_t v22 = (uint64_t ****)(v19 + 16 * v20);
        }
LABEL_58:
        unint64_t v54 = v22[1];
        size_t v56 = (size_t)*v54;
        uint64_t result = (char *)(v54 + 2);
        size_t v55 = v56;
        goto LABEL_59;
      }
      size_t v55 = 0;
      uint64_t result = &byte_1CFBCE98E;
LABEL_59:
      int v57 = *((_DWORD *)v16 + 5);
      if ((v57 & 0x10000000) != 0)
      {
        uint64_t v58 = ***v16;
        uint64_t v59 = *(void *)(v58 + 152);
        uint64_t v60 = *(unsigned int *)(v58 + 168);
        if (v60)
        {
          LODWORD(v61) = (v60 - 1) & ((v16 >> 4) ^ (v16 >> 9));
          uint64_t v62 = (uint64_t ****)(v59 + 16 * v61);
          uint64_t v63 = *v62;
          if (*v62 == v16)
          {
LABEL_67:
            unsigned int v66 = v62[1];
            size_t v69 = (size_t)*v66;
            int v67 = (char *)(v66 + 2);
            size_t v68 = v69;
            goto LABEL_68;
          }
          int v64 = 1;
          while (v63 != (uint64_t ***)-4096)
          {
            int v65 = v61 + v64++;
            uint64_t v61 = v65 & (v60 - 1);
            uint64_t v63 = *(uint64_t ****)(v59 + 16 * v61);
            if (v63 == v16)
            {
              uint64_t v62 = (uint64_t ****)(v59 + 16 * v61);
              goto LABEL_67;
            }
          }
        }
        uint64_t v62 = (uint64_t ****)(v59 + 16 * v60);
        goto LABEL_67;
      }
      size_t v68 = 0;
      int v67 = &byte_1CFBCE98E;
LABEL_68:
      if (v68 >= v55) {
        size_t v70 = v55;
      }
      else {
        size_t v70 = v68;
      }
      if (v70 && (uint64_t result = (char *)memcmp(result, v67, v70), result))
      {
        if ((result & 0x80000000) != 0) {
          goto LABEL_83;
        }
      }
      else if (v55 < v68)
      {
        goto LABEL_83;
      }
      unsigned int v26 = (uint64_t ****)(v15 + 8);
      uint64_t v27 = *(void *)v828;
      uint64_t v71 = *(uint64_t ****)(*(void *)v828 + 8);
      if (!v71) {
        goto LABEL_291;
      }
      if ((v57 & 0x10000000) != 0)
      {
        uint64_t v72 = ***v16;
        uint64_t v73 = *(void *)(v72 + 152);
        uint64_t v74 = *(unsigned int *)(v72 + 168);
        if (!v74) {
          goto LABEL_271;
        }
        LODWORD(v75) = (v74 - 1) & ((v16 >> 4) ^ (v16 >> 9));
        uint64_t v76 = (uint64_t ****)(v73 + 16 * v75);
        unint64_t v77 = *v76;
        if (*v76 != v16)
        {
          int v78 = 1;
          while (v77 != (uint64_t ***)-4096)
          {
            int v79 = v75 + v78++;
            uint64_t v75 = v79 & (v74 - 1);
            unint64_t v77 = *(uint64_t ****)(v73 + 16 * v75);
            if (v77 == v16)
            {
              uint64_t v76 = (uint64_t ****)(v73 + 16 * v75);
              goto LABEL_272;
            }
          }
LABEL_271:
          uint64_t v76 = (uint64_t ****)(v73 + 16 * v74);
        }
LABEL_272:
        uint64_t v235 = v76[1];
        size_t v237 = (size_t)*v235;
        uint64_t result = (char *)(v235 + 2);
        size_t v236 = v237;
        goto LABEL_273;
      }
      size_t v236 = 0;
      uint64_t result = &byte_1CFBCE98E;
LABEL_273:
      if ((*((unsigned char *)v71 + 23) & 0x10) != 0)
      {
        uint64_t v238 = ***v71;
        uint64_t v239 = *(void *)(v238 + 152);
        uint64_t v240 = *(unsigned int *)(v238 + 168);
        if (!v240) {
          goto LABEL_280;
        }
        LODWORD(v241) = (v240 - 1) & ((v71 >> 4) ^ (v71 >> 9));
        uint64_t v242 = (uint64_t ****)(v239 + 16 * v241);
        unsigned int v243 = *v242;
        if (*v242 != v71)
        {
          int v244 = 1;
          while (v243 != (uint64_t ***)-4096)
          {
            int v245 = v241 + v244++;
            uint64_t v241 = v245 & (v240 - 1);
            unsigned int v243 = *(uint64_t ****)(v239 + 16 * v241);
            if (v243 == v71)
            {
              uint64_t v242 = (uint64_t ****)(v239 + 16 * v241);
              goto LABEL_281;
            }
          }
LABEL_280:
          uint64_t v242 = (uint64_t ****)(v239 + 16 * v240);
        }
LABEL_281:
        unsigned int v246 = v242[1];
        size_t v249 = (size_t)*v246;
        unsigned int v247 = (char *)(v246 + 2);
        size_t v248 = v249;
        goto LABEL_282;
      }
      size_t v248 = 0;
      unsigned int v247 = &byte_1CFBCE98E;
LABEL_282:
      if (v248 >= v236) {
        size_t v250 = v236;
      }
      else {
        size_t v250 = v248;
      }
      if (v250)
      {
        uint64_t result = (char *)memcmp(result, v247, v250);
        if (result)
        {
          uint64_t v7 = a2;
          if ((result & 0x80000000) != 0) {
            goto LABEL_23;
          }
          goto LABEL_291;
        }
      }
      BOOL v4 = v236 >= v248;
      uint64_t v7 = a2;
      if (!v4)
      {
LABEL_23:
        uint64_t i = v9;
        while (1)
        {
          do
          {
            while (1)
            {
              uint64_t v28 = i[1];
              ++i;
              uint64_t v29 = *(uint64_t ****)(v28 + 8);
              if (v16) {
                break;
              }
              if (v29) {
                goto LABEL_327;
              }
            }
          }
          while (!v29);
          if ((*((unsigned char *)v16 + 23) & 0x10) != 0) {
            break;
          }
          size_t v39 = 0;
          uint64_t result = &byte_1CFBCE98E;
LABEL_37:
          if ((*((unsigned char *)v29 + 23) & 0x10) == 0)
          {
            size_t v51 = 0;
            uint64_t v50 = &byte_1CFBCE98E;
            goto LABEL_46;
          }
          uint64_t v41 = ***v29;
          uint64_t v42 = *(void *)(v41 + 152);
          uint64_t v43 = *(unsigned int *)(v41 + 168);
          if (!v43) {
            goto LABEL_44;
          }
          LODWORD(v44) = (v43 - 1) & ((v29 >> 4) ^ (v29 >> 9));
          uint64_t v45 = (uint64_t ****)(v42 + 16 * v44);
          unint64_t v46 = *v45;
          if (*v45 != v29)
          {
            int v47 = 1;
            while (v46 != (uint64_t ***)-4096)
            {
              int v48 = v44 + v47++;
              uint64_t v44 = v48 & (v43 - 1);
              unint64_t v46 = *(uint64_t ****)(v42 + 16 * v44);
              if (v46 == v29)
              {
                uint64_t v45 = (uint64_t ****)(v42 + 16 * v44);
                goto LABEL_45;
              }
            }
LABEL_44:
            uint64_t v45 = (uint64_t ****)(v42 + 16 * v43);
          }
LABEL_45:
          uint64_t v49 = v45[1];
          size_t v52 = (size_t)*v49;
          uint64_t v50 = (char *)(v49 + 2);
          size_t v51 = v52;
LABEL_46:
          if (v51 >= v39) {
            size_t v53 = v39;
          }
          else {
            size_t v53 = v51;
          }
          if (v53 && (uint64_t result = (char *)memcmp(result, v50, v53), result))
          {
            uint64_t v7 = a2;
            if ((result & 0x80000000) != 0) {
              goto LABEL_327;
            }
          }
          else
          {
            BOOL v4 = v39 >= v51;
            uint64_t v7 = a2;
            if (!v4) {
              goto LABEL_327;
            }
          }
        }
        uint64_t v30 = ***v16;
        uint64_t v31 = *(void *)(v30 + 152);
        uint64_t v32 = *(unsigned int *)(v30 + 168);
        if (v32)
        {
          LODWORD(v33) = (v32 - 1) & ((v16 >> 4) ^ (v16 >> 9));
          unsigned int v34 = (uint64_t ****)(v31 + 16 * v33);
          uint64_t v35 = *v34;
          if (*v34 != v16)
          {
            int v36 = 1;
            while (v35 != (uint64_t ***)-4096)
            {
              int v37 = v33 + v36++;
              uint64_t v33 = v37 & (v32 - 1);
              uint64_t v35 = *(uint64_t ****)(v31 + 16 * v33);
              if (v35 == v16)
              {
                unsigned int v34 = (uint64_t ****)(v31 + 16 * v33);
                goto LABEL_36;
              }
            }
            goto LABEL_35;
          }
        }
        else
        {
LABEL_35:
          unsigned int v34 = (uint64_t ****)(v31 + 16 * v32);
        }
LABEL_36:
        uint64_t v38 = v34[1];
        size_t v40 = (size_t)*v38;
        uint64_t result = (char *)(v38 + 2);
        size_t v39 = v40;
        goto LABEL_37;
      }
LABEL_291:
      for (uint64_t i = v9 + 1; i < (uint64_t *)v7; ++i)
      {
        unint64_t v251 = *(uint64_t ****)(*i + 8);
        if (v16)
        {
          if (v251)
          {
            if ((*((unsigned char *)v16 + 23) & 0x10) != 0)
            {
              uint64_t v252 = ***v16;
              uint64_t v253 = *(void *)(v252 + 152);
              uint64_t v254 = *(unsigned int *)(v252 + 168);
              if (!v254) {
                goto LABEL_303;
              }
              LODWORD(v255) = (v254 - 1) & ((v16 >> 4) ^ (v16 >> 9));
              v256 = (uint64_t ****)(v253 + 16 * v255);
              uint64_t v257 = *v256;
              if (*v256 != v16)
              {
                int v258 = 1;
                while (v257 != (uint64_t ***)-4096)
                {
                  int v259 = v255 + v258++;
                  uint64_t v255 = v259 & (v254 - 1);
                  uint64_t v257 = *(uint64_t ****)(v253 + 16 * v255);
                  if (v257 == v16)
                  {
                    v256 = (uint64_t ****)(v253 + 16 * v255);
                    goto LABEL_304;
                  }
                }
LABEL_303:
                v256 = (uint64_t ****)(v253 + 16 * v254);
              }
LABEL_304:
              v260 = v256[1];
              size_t v262 = (size_t)*v260;
              uint64_t result = (char *)(v260 + 2);
              size_t v261 = v262;
            }
            else
            {
              size_t v261 = 0;
              uint64_t result = &byte_1CFBCE98E;
            }
            if ((*((unsigned char *)v251 + 23) & 0x10) != 0)
            {
              uint64_t v263 = ***v251;
              uint64_t v264 = *(void *)(v263 + 152);
              uint64_t v265 = *(unsigned int *)(v263 + 168);
              if (!v265) {
                goto LABEL_312;
              }
              LODWORD(v266) = (v265 - 1) & ((v251 >> 4) ^ (v251 >> 9));
              uint64_t v267 = (uint64_t ****)(v264 + 16 * v266);
              uint64_t v268 = *v267;
              if (*v267 != v251)
              {
                int v269 = 1;
                while (v268 != (uint64_t ***)-4096)
                {
                  int v270 = v266 + v269++;
                  uint64_t v266 = v270 & (v265 - 1);
                  uint64_t v268 = *(uint64_t ****)(v264 + 16 * v266);
                  if (v268 == v251)
                  {
                    uint64_t v267 = (uint64_t ****)(v264 + 16 * v266);
                    goto LABEL_313;
                  }
                }
LABEL_312:
                uint64_t v267 = (uint64_t ****)(v264 + 16 * v265);
              }
LABEL_313:
              uint64_t v271 = v267[1];
              size_t v274 = (size_t)*v271;
              uint64_t v272 = (char *)(v271 + 2);
              size_t v273 = v274;
            }
            else
            {
              size_t v273 = 0;
              uint64_t v272 = &byte_1CFBCE98E;
            }
            if (v273 >= v261) {
              size_t v275 = v261;
            }
            else {
              size_t v275 = v273;
            }
            if (v275 && (uint64_t result = (char *)memcmp(result, v272, v275), result))
            {
              uint64_t v7 = a2;
              if ((result & 0x80000000) != 0) {
                break;
              }
            }
            else
            {
              BOOL v4 = v261 >= v273;
              uint64_t v7 = a2;
              if (!v4) {
                break;
              }
            }
          }
        }
        else if (v251)
        {
          break;
        }
      }
LABEL_327:
      if (i < (uint64_t *)v7)
      {
        for (uint64_t j = a2; ; j -= 8)
        {
          uint64_t v7 = j - 8;
          uint64_t v277 = *(uint64_t ****)(v27 + 8);
          if (!v16)
          {
            if (!v277) {
              goto LABEL_362;
            }
            goto LABEL_359;
          }
          if (!v277) {
            goto LABEL_362;
          }
          if ((*((unsigned char *)v16 + 23) & 0x10) != 0) {
            break;
          }
          size_t v287 = 0;
          uint64_t result = &byte_1CFBCE98E;
LABEL_342:
          if ((*((unsigned char *)v277 + 23) & 0x10) != 0)
          {
            uint64_t v289 = ***v277;
            uint64_t v290 = *(void *)(v289 + 152);
            uint64_t v291 = *(unsigned int *)(v289 + 168);
            if (!v291) {
              goto LABEL_349;
            }
            LODWORD(v292) = (v291 - 1) & ((v277 >> 4) ^ (v277 >> 9));
            uint64_t v293 = (uint64_t ****)(v290 + 16 * v292);
            uint64_t v294 = *v293;
            if (*v293 != v277)
            {
              int v295 = 1;
              while (v294 != (uint64_t ***)-4096)
              {
                int v296 = v292 + v295++;
                uint64_t v292 = v296 & (v291 - 1);
                uint64_t v294 = *(uint64_t ****)(v290 + 16 * v292);
                if (v294 == v277)
                {
                  uint64_t v293 = (uint64_t ****)(v290 + 16 * v292);
                  goto LABEL_350;
                }
              }
LABEL_349:
              uint64_t v293 = (uint64_t ****)(v290 + 16 * v291);
            }
LABEL_350:
            int v297 = v293[1];
            size_t v300 = (size_t)*v297;
            uint64_t v298 = (char *)(v297 + 2);
            size_t v299 = v300;
            goto LABEL_351;
          }
          size_t v299 = 0;
          uint64_t v298 = &byte_1CFBCE98E;
LABEL_351:
          if (v299 >= v287) {
            size_t v301 = v287;
          }
          else {
            size_t v301 = v299;
          }
          if (v301 && (uint64_t result = (char *)memcmp(result, v298, v301), result))
          {
            if ((result & 0x80000000) == 0) {
              goto LABEL_362;
            }
          }
          else if (v287 >= v299)
          {
            goto LABEL_362;
          }
LABEL_359:
          uint64_t v27 = *((void *)j - 2);
        }
        uint64_t v278 = ***v16;
        uint64_t v279 = *(void *)(v278 + 152);
        uint64_t v280 = *(unsigned int *)(v278 + 168);
        if (v280)
        {
          LODWORD(v281) = (v280 - 1) & ((v16 >> 4) ^ (v16 >> 9));
          BOOL v282 = (uint64_t ****)(v279 + 16 * v281);
          uint64_t v283 = *v282;
          if (*v282 != v16)
          {
            int v284 = 1;
            while (v283 != (uint64_t ***)-4096)
            {
              int v285 = v281 + v284++;
              uint64_t v281 = v285 & (v280 - 1);
              uint64_t v283 = *(uint64_t ****)(v279 + 16 * v281);
              if (v283 == v16)
              {
                BOOL v282 = (uint64_t ****)(v279 + 16 * v281);
                goto LABEL_341;
              }
            }
            goto LABEL_340;
          }
        }
        else
        {
LABEL_340:
          BOOL v282 = (uint64_t ****)(v279 + 16 * v280);
        }
LABEL_341:
        uint64_t v286 = v282[1];
        size_t v288 = (size_t)*v286;
        uint64_t result = (char *)(v286 + 2);
        size_t v287 = v288;
        goto LABEL_342;
      }
LABEL_362:
      if (i >= (uint64_t *)v7) {
        goto LABEL_431;
      }
      uint64_t v302 = *i;
      uint64_t v303 = *(void *)v7;
      do
      {
        *uint64_t i = v303;
        *(void *)uint64_t v7 = v302;
        int v304 = *v26;
        unsigned int v305 = (*v26 >> 4) ^ (*v26 >> 9);
        do
        {
          while (1)
          {
            do
            {
              while (1)
              {
                uint64_t v306 = i[1];
                ++i;
                uint64_t v302 = v306;
                int v307 = *(uint64_t ****)(v306 + 8);
                if (v304) {
                  break;
                }
                if (v307) {
                  goto LABEL_420;
                }
              }
            }
            while (!v307);
            if ((*((unsigned char *)v304 + 23) & 0x10) != 0)
            {
              uint64_t v308 = ***v304;
              uint64_t v309 = *(void *)(v308 + 152);
              uint64_t v310 = *(unsigned int *)(v308 + 168);
              if (!v310) {
                goto LABEL_376;
              }
              LODWORD(v311) = (v310 - 1) & v305;
              int v312 = (uint64_t ****)(v309 + 16 * v311);
              v313 = *v312;
              if (*v312 != v304)
              {
                int v314 = 1;
                while (v313 != (uint64_t ***)-4096)
                {
                  int v315 = v311 + v314++;
                  uint64_t v311 = v315 & (v310 - 1);
                  v313 = *(uint64_t ****)(v309 + 16 * v311);
                  if (v313 == v304)
                  {
                    int v312 = (uint64_t ****)(v309 + 16 * v311);
                    goto LABEL_377;
                  }
                }
LABEL_376:
                int v312 = (uint64_t ****)(v309 + 16 * v310);
              }
LABEL_377:
              uint64_t v316 = v312[1];
              unint64_t v318 = (unint64_t)*v316;
              uint64_t result = (char *)(v316 + 2);
              unint64_t v317 = v318;
              goto LABEL_378;
            }
            unint64_t v317 = 0;
            uint64_t result = &byte_1CFBCE98E;
LABEL_378:
            if ((*((unsigned char *)v307 + 23) & 0x10) != 0)
            {
              uint64_t v319 = ***v307;
              uint64_t v320 = *(void *)(v319 + 152);
              uint64_t v321 = *(unsigned int *)(v319 + 168);
              if (!v321) {
                goto LABEL_385;
              }
              LODWORD(v322) = (v321 - 1) & ((v307 >> 4) ^ (v307 >> 9));
              uint64_t v323 = (uint64_t ****)(v320 + 16 * v322);
              int64x2_t v324 = *v323;
              if (*v323 != v307)
              {
                int v325 = 1;
                while (v324 != (uint64_t ***)-4096)
                {
                  int v326 = v322 + v325++;
                  uint64_t v322 = v326 & (v321 - 1);
                  int64x2_t v324 = *(uint64_t ****)(v320 + 16 * v322);
                  if (v324 == v307)
                  {
                    uint64_t v323 = (uint64_t ****)(v320 + 16 * v322);
                    goto LABEL_386;
                  }
                }
LABEL_385:
                uint64_t v323 = (uint64_t ****)(v320 + 16 * v321);
              }
LABEL_386:
              uint64_t v327 = v323[1];
              unint64_t v330 = (unint64_t)*v327;
              uint64_t v328 = (char *)(v327 + 2);
              unint64_t v329 = v330;
              goto LABEL_387;
            }
            unint64_t v329 = 0;
            uint64_t v328 = &byte_1CFBCE98E;
LABEL_387:
            size_t v331 = v329 >= v317 ? v317 : v329;
            if (!v331) {
              break;
            }
            uint64_t result = (char *)memcmp(result, v328, v331);
            if (!result) {
              break;
            }
            if ((result & 0x80000000) != 0) {
              goto LABEL_420;
            }
          }
        }
        while (v317 >= v329);
        do
        {
LABEL_420:
          while (1)
          {
            uint64_t v349 = *((void *)v7 - 1);
            v7 -= 8;
            uint64_t v303 = v349;
            unint64_t v350 = *(uint64_t ****)(v349 + 8);
            if (!v304) {
              break;
            }
            if (!v350) {
              goto LABEL_430;
            }
            if ((*((unsigned char *)v304 + 23) & 0x10) != 0)
            {
              uint64_t v351 = ***v304;
              uint64_t v352 = *(void *)(v351 + 152);
              uint64_t v353 = *(unsigned int *)(v351 + 168);
              if (!v353) {
                goto LABEL_398;
              }
              LODWORD(v354) = (v353 - 1) & v305;
              v332 = (uint64_t ****)(v352 + 16 * v354);
              uint64_t v355 = *v332;
              if (*v332 != v304)
              {
                int v356 = 1;
                while (v355 != (uint64_t ***)-4096)
                {
                  int v357 = v354 + v356++;
                  uint64_t v354 = v357 & (v353 - 1);
                  uint64_t v355 = *(uint64_t ****)(v352 + 16 * v354);
                  if (v355 == v304)
                  {
                    v332 = (uint64_t ****)(v352 + 16 * v354);
                    goto LABEL_399;
                  }
                }
LABEL_398:
                v332 = (uint64_t ****)(v352 + 16 * v353);
              }
LABEL_399:
              uint64_t v333 = v332[1];
              size_t v335 = (size_t)*v333;
              uint64_t result = (char *)(v333 + 2);
              size_t v334 = v335;
              goto LABEL_400;
            }
            size_t v334 = 0;
            uint64_t result = &byte_1CFBCE98E;
LABEL_400:
            if ((*((unsigned char *)v350 + 23) & 0x10) == 0)
            {
              size_t v346 = 0;
              uint64_t v345 = &byte_1CFBCE98E;
              goto LABEL_409;
            }
            uint64_t v336 = ***v350;
            uint64_t v337 = *(void *)(v336 + 152);
            uint64_t v338 = *(unsigned int *)(v336 + 168);
            if (!v338) {
              goto LABEL_407;
            }
            LODWORD(v339) = (v338 - 1) & ((v350 >> 4) ^ (v350 >> 9));
            v340 = (uint64_t ****)(v337 + 16 * v339);
            uint64_t v341 = *v340;
            if (*v340 != v350)
            {
              int v342 = 1;
              while (v341 != (uint64_t ***)-4096)
              {
                int v343 = v339 + v342++;
                uint64_t v339 = v343 & (v338 - 1);
                uint64_t v341 = *(uint64_t ****)(v337 + 16 * v339);
                if (v341 == v350)
                {
                  v340 = (uint64_t ****)(v337 + 16 * v339);
                  goto LABEL_408;
                }
              }
LABEL_407:
              v340 = (uint64_t ****)(v337 + 16 * v338);
            }
LABEL_408:
            v344 = v340[1];
            size_t v347 = (size_t)*v344;
            uint64_t v345 = (char *)(v344 + 2);
            size_t v346 = v347;
LABEL_409:
            if (v346 >= v334) {
              size_t v348 = v334;
            }
            else {
              size_t v348 = v346;
            }
            if (v348 && (uint64_t result = (char *)memcmp(result, v345, v348), result))
            {
              if ((result & 0x80000000) == 0) {
                goto LABEL_430;
              }
            }
            else if (v334 >= v346)
            {
              goto LABEL_430;
            }
          }
        }
        while (v350);
LABEL_430:
        ;
      }
      while (i < (uint64_t *)v7);
LABEL_431:
      v358 = i - 1;
      BOOL v4 = i - 1 >= v832;
      BOOL v5 = i - 1 == v832;
      if (i - 1 != v832) {
        uint64_t *v832 = *v358;
      }
      a4 = 0;
      uint64_t *v358 = v15;
      uint64_t v7 = a2;
    }
  }
  uint64_t v386 = (char *)(v9 + 1);
  BOOL v388 = v9 == (uint64_t *)v7 || v386 == v7;
  if ((a4 & 1) == 0)
  {
    if (v388) {
      return result;
    }
    while (1)
    {
      v657 = v9;
      unint64_t v9 = (uint64_t *)v386;
      uint64_t v659 = *v657;
      uint64_t v658 = v657[1];
      v660 = *(uint64_t ****)(v658 + 8);
      v661 = *(uint64_t ****)(*v657 + 8);
      if (v660)
      {
        if (!v661) {
          goto LABEL_865;
        }
        if ((*((unsigned char *)v660 + 23) & 0x10) != 0)
        {
          uint64_t v662 = ***v660;
          uint64_t v663 = *(void *)(v662 + 152);
          uint64_t v664 = *(unsigned int *)(v662 + 168);
          if (v664)
          {
            LODWORD(v665) = (v664 - 1) & ((v660 >> 4) ^ (v660 >> 9));
            v666 = (uint64_t ****)(v663 + 16 * v665);
            v667 = *v666;
            if (*v666 != v660)
            {
              int v668 = 1;
              do
              {
                if (v667 == (uint64_t ***)-4096) {
                  goto LABEL_811;
                }
                int v669 = v665 + v668++;
                uint64_t v665 = v669 & (v664 - 1);
                v667 = *(uint64_t ****)(v663 + 16 * v665);
              }
              while (v667 != v660);
              v666 = (uint64_t ****)(v663 + 16 * v665);
            }
          }
          else
          {
LABEL_811:
            v666 = (uint64_t ****)(v663 + 16 * v664);
          }
          v670 = v666[1];
          size_t v672 = (size_t)*v670;
          uint64_t result = (char *)(v670 + 2);
          size_t v671 = v672;
        }
        else
        {
          size_t v671 = 0;
          uint64_t result = &byte_1CFBCE98E;
        }
        if ((*((unsigned char *)v661 + 23) & 0x10) != 0)
        {
          uint64_t v673 = ***v661;
          uint64_t v674 = *(void *)(v673 + 152);
          uint64_t v675 = *(unsigned int *)(v673 + 168);
          if (v675)
          {
            LODWORD(v676) = (v675 - 1) & ((v661 >> 4) ^ (v661 >> 9));
            v677 = (uint64_t ****)(v674 + 16 * v676);
            v678 = *v677;
            if (*v677 != v661)
            {
              int v679 = 1;
              do
              {
                if (v678 == (uint64_t ***)-4096) {
                  goto LABEL_820;
                }
                int v680 = v676 + v679++;
                uint64_t v676 = v680 & (v675 - 1);
                v678 = *(uint64_t ****)(v674 + 16 * v676);
              }
              while (v678 != v661);
              v677 = (uint64_t ****)(v674 + 16 * v676);
            }
          }
          else
          {
LABEL_820:
            v677 = (uint64_t ****)(v674 + 16 * v675);
          }
          v681 = v677[1];
          size_t v684 = (size_t)*v681;
          v682 = (char *)(v681 + 2);
          size_t v683 = v684;
        }
        else
        {
          size_t v683 = 0;
          v682 = &byte_1CFBCE98E;
        }
        if (v683 >= v671) {
          size_t v685 = v671;
        }
        else {
          size_t v685 = v683;
        }
        if (v685 && (uint64_t result = (char *)memcmp(result, v682, v685), result))
        {
          if ((result & 0x80000000) == 0) {
            goto LABEL_865;
          }
        }
        else if (v671 >= v683)
        {
          goto LABEL_865;
        }
      }
      else if (!v661)
      {
        goto LABEL_865;
      }
      v686 = v9;
      do
      {
        while (1)
        {
          while (1)
          {
            uint64_t *v686 = v659;
            v686 = v657;
            uint64_t v687 = *--v657;
            uint64_t v659 = v687;
            v688 = *(uint64_t ****)(v658 + 8);
            v689 = *(uint64_t ****)(v687 + 8);
            if (v688) {
              break;
            }
            if (!v689) {
              goto LABEL_864;
            }
          }
          if (!v689) {
            goto LABEL_864;
          }
          if ((*((unsigned char *)v688 + 23) & 0x10) != 0)
          {
            uint64_t v690 = ***v688;
            uint64_t v691 = *(void *)(v690 + 152);
            uint64_t v692 = *(unsigned int *)(v690 + 168);
            if (v692)
            {
              LODWORD(v693) = (v692 - 1) & ((v688 >> 4) ^ (v688 >> 9));
              v694 = (uint64_t ****)(v691 + 16 * v693);
              v695 = *v694;
              if (*v694 != v688)
              {
                int v696 = 1;
                do
                {
                  if (v695 == (uint64_t ***)-4096) {
                    goto LABEL_842;
                  }
                  int v697 = v693 + v696++;
                  uint64_t v693 = v697 & (v692 - 1);
                  v695 = *(uint64_t ****)(v691 + 16 * v693);
                }
                while (v695 != v688);
                v694 = (uint64_t ****)(v691 + 16 * v693);
              }
            }
            else
            {
LABEL_842:
              v694 = (uint64_t ****)(v691 + 16 * v692);
            }
            v698 = v694[1];
            unint64_t v700 = (unint64_t)*v698;
            uint64_t result = (char *)(v698 + 2);
            unint64_t v699 = v700;
          }
          else
          {
            unint64_t v699 = 0;
            uint64_t result = &byte_1CFBCE98E;
          }
          if ((*((unsigned char *)v689 + 23) & 0x10) != 0)
          {
            uint64_t v701 = ***v689;
            uint64_t v702 = *(void *)(v701 + 152);
            uint64_t v703 = *(unsigned int *)(v701 + 168);
            if (v703)
            {
              LODWORD(v704) = (v703 - 1) & ((v689 >> 4) ^ (v689 >> 9));
              v705 = (uint64_t ****)(v702 + 16 * v704);
              v706 = *v705;
              if (*v705 != v689)
              {
                int v707 = 1;
                do
                {
                  if (v706 == (uint64_t ***)-4096) {
                    goto LABEL_851;
                  }
                  int v708 = v704 + v707++;
                  uint64_t v704 = v708 & (v703 - 1);
                  v706 = *(uint64_t ****)(v702 + 16 * v704);
                }
                while (v706 != v689);
                v705 = (uint64_t ****)(v702 + 16 * v704);
              }
            }
            else
            {
LABEL_851:
              v705 = (uint64_t ****)(v702 + 16 * v703);
            }
            v709 = v705[1];
            unint64_t v712 = (unint64_t)*v709;
            v710 = (char *)(v709 + 2);
            unint64_t v711 = v712;
          }
          else
          {
            unint64_t v711 = 0;
            v710 = &byte_1CFBCE98E;
          }
          size_t v713 = v711 >= v699 ? v699 : v711;
          if (!v713) {
            break;
          }
          uint64_t result = (char *)memcmp(result, v710, v713);
          if (!result) {
            break;
          }
          if ((result & 0x80000000) == 0) {
            goto LABEL_864;
          }
        }
      }
      while (v699 < v711);
LABEL_864:
      uint64_t *v686 = v658;
LABEL_865:
      uint64_t v386 = (char *)(v9 + 1);
      if (v9 + 1 == (uint64_t *)a2) {
        return result;
      }
    }
  }
  if (v388) {
    return result;
  }
  v389 = (char *)v9;
  while (2)
  {
    v390 = (uint64_t *)v389;
    v389 = v386;
    uint64_t v392 = *v390;
    uint64_t v391 = v390[1];
    unsigned int v393 = *(uint64_t ****)(v391 + 8);
    v394 = *(uint64_t ****)(*v390 + 8);
    if (v393)
    {
      if (!v394) {
        goto LABEL_540;
      }
      if ((*((unsigned char *)v393 + 23) & 0x10) != 0)
      {
        uint64_t v395 = ***v393;
        uint64_t v396 = *(void *)(v395 + 152);
        uint64_t v397 = *(unsigned int *)(v395 + 168);
        if (!v397) {
          goto LABEL_483;
        }
        LODWORD(v398) = (v397 - 1) & ((v393 >> 4) ^ (v393 >> 9));
        v399 = (uint64_t ****)(v396 + 16 * v398);
        v400 = *v399;
        if (*v399 != v393)
        {
          int v401 = 1;
          while (v400 != (uint64_t ***)-4096)
          {
            int v402 = v398 + v401++;
            uint64_t v398 = v402 & (v397 - 1);
            v400 = *(uint64_t ****)(v396 + 16 * v398);
            if (v400 == v393)
            {
              v399 = (uint64_t ****)(v396 + 16 * v398);
              goto LABEL_484;
            }
          }
LABEL_483:
          v399 = (uint64_t ****)(v396 + 16 * v397);
        }
LABEL_484:
        v403 = v399[1];
        size_t v405 = (size_t)*v403;
        uint64_t result = (char *)(v403 + 2);
        size_t v404 = v405;
      }
      else
      {
        size_t v404 = 0;
        uint64_t result = &byte_1CFBCE98E;
      }
      if ((*((unsigned char *)v394 + 23) & 0x10) != 0)
      {
        uint64_t v406 = ***v394;
        uint64_t v407 = *(void *)(v406 + 152);
        uint64_t v408 = *(unsigned int *)(v406 + 168);
        if (!v408) {
          goto LABEL_492;
        }
        LODWORD(v409) = (v408 - 1) & ((v394 >> 4) ^ (v394 >> 9));
        v410 = (uint64_t ****)(v407 + 16 * v409);
        v411 = *v410;
        if (*v410 != v394)
        {
          int v412 = 1;
          while (v411 != (uint64_t ***)-4096)
          {
            int v413 = v409 + v412++;
            uint64_t v409 = v413 & (v408 - 1);
            v411 = *(uint64_t ****)(v407 + 16 * v409);
            if (v411 == v394)
            {
              v410 = (uint64_t ****)(v407 + 16 * v409);
              goto LABEL_493;
            }
          }
LABEL_492:
          v410 = (uint64_t ****)(v407 + 16 * v408);
        }
LABEL_493:
        v414 = v410[1];
        size_t v417 = (size_t)*v414;
        v415 = (char *)(v414 + 2);
        size_t v416 = v417;
      }
      else
      {
        size_t v416 = 0;
        v415 = &byte_1CFBCE98E;
      }
      if (v416 >= v404) {
        size_t v418 = v404;
      }
      else {
        size_t v418 = v416;
      }
      if (v418 && (uint64_t result = (char *)memcmp(result, v415, v418), result))
      {
        if ((result & 0x80000000) == 0) {
          goto LABEL_540;
        }
      }
      else if (v404 >= v416)
      {
        goto LABEL_540;
      }
    }
    else if (!v394)
    {
      goto LABEL_540;
    }
    v390[1] = v392;
    v419 = v9;
    if (v390 == v9) {
      goto LABEL_539;
    }
    v420 = v390;
    while (2)
    {
      uint64_t v422 = *--v420;
      uint64_t v421 = v422;
      v423 = *(uint64_t ****)(v391 + 8);
      v424 = *(uint64_t ****)(v422 + 8);
      if (!v423)
      {
        if (!v424) {
          break;
        }
        goto LABEL_534;
      }
      if (!v424) {
        break;
      }
      if ((*((unsigned char *)v423 + 23) & 0x10) != 0)
      {
        uint64_t v425 = ***v423;
        uint64_t v426 = *(void *)(v425 + 152);
        uint64_t v427 = *(unsigned int *)(v425 + 168);
        if (!v427) {
          goto LABEL_515;
        }
        LODWORD(v428) = (v427 - 1) & ((v423 >> 4) ^ (v423 >> 9));
        v429 = (uint64_t ****)(v426 + 16 * v428);
        v430 = *v429;
        if (*v429 != v423)
        {
          int v431 = 1;
          while (v430 != (uint64_t ***)-4096)
          {
            int v432 = v428 + v431++;
            uint64_t v428 = v432 & (v427 - 1);
            v430 = *(uint64_t ****)(v426 + 16 * v428);
            if (v430 == v423)
            {
              v429 = (uint64_t ****)(v426 + 16 * v428);
              goto LABEL_516;
            }
          }
LABEL_515:
          v429 = (uint64_t ****)(v426 + 16 * v427);
        }
LABEL_516:
        v433 = v429[1];
        size_t v435 = (size_t)*v433;
        uint64_t result = (char *)(v433 + 2);
        size_t v434 = v435;
      }
      else
      {
        size_t v434 = 0;
        uint64_t result = &byte_1CFBCE98E;
      }
      if ((*((unsigned char *)v424 + 23) & 0x10) != 0)
      {
        uint64_t v436 = ***v424;
        uint64_t v437 = *(void *)(v436 + 152);
        uint64_t v438 = *(unsigned int *)(v436 + 168);
        if (!v438) {
          goto LABEL_524;
        }
        LODWORD(v439) = (v438 - 1) & ((v424 >> 4) ^ (v424 >> 9));
        v440 = (uint64_t ****)(v437 + 16 * v439);
        v441 = *v440;
        if (*v440 != v424)
        {
          int v442 = 1;
          while (v441 != (uint64_t ***)-4096)
          {
            int v443 = v439 + v442++;
            uint64_t v439 = v443 & (v438 - 1);
            v441 = *(uint64_t ****)(v437 + 16 * v439);
            if (v441 == v424)
            {
              v440 = (uint64_t ****)(v437 + 16 * v439);
              goto LABEL_525;
            }
          }
LABEL_524:
          v440 = (uint64_t ****)(v437 + 16 * v438);
        }
LABEL_525:
        v444 = v440[1];
        size_t v447 = (size_t)*v444;
        v445 = (char *)(v444 + 2);
        size_t v446 = v447;
      }
      else
      {
        size_t v446 = 0;
        v445 = &byte_1CFBCE98E;
      }
      if (v446 >= v434) {
        size_t v448 = v434;
      }
      else {
        size_t v448 = v446;
      }
      if (v448)
      {
        uint64_t result = (char *)memcmp(result, v445, v448);
        if (result)
        {
          unint64_t v9 = v832;
          if ((result & 0x80000000) == 0) {
            break;
          }
          goto LABEL_534;
        }
      }
      BOOL v4 = v434 >= v446;
      unint64_t v9 = v832;
      if (!v4)
      {
LABEL_534:
        uint64_t *v390 = v421;
        v390 = v420;
        if (v420 == v9)
        {
          v419 = v9;
          goto LABEL_539;
        }
        continue;
      }
      break;
    }
    v419 = v390;
LABEL_539:
    uint64_t *v419 = v391;
LABEL_540:
    uint64_t v386 = v389 + 8;
    if (v389 + 8 != a2) {
      continue;
    }
    return result;
  }
}

char *sub_1CBFAC870(char *result, char *a2, char *a3)
{
  BOOL v4 = a2;
  BOOL v5 = result;
  uint64_t v6 = *(void *)a2;
  uint64_t v7 = *(void *)result;
  uint64_t v8 = *(uint64_t ****)(*(void *)a2 + 8);
  unint64_t v9 = *(uint64_t ****)(*(void *)result + 8);
  if (!v8)
  {
    if (!v9) {
      return result;
    }
    goto LABEL_11;
  }
  unsigned int v10 = v8 >> 4;
  if (!v9) {
    goto LABEL_38;
  }
  int v11 = *((_DWORD *)v8 + 5);
  if ((v11 & 0x10000000) != 0)
  {
    uint64_t v12 = ***v8;
    uint64_t v13 = *(void *)(v12 + 152);
    uint64_t v14 = *(unsigned int *)(v12 + 168);
    if (v14)
    {
      LODWORD(v15) = (v14 - 1) & (v10 ^ (v8 >> 9));
      uint64_t v16 = (uint64_t ****)(v13 + 16 * v15);
      unint64_t v17 = *v16;
      if (*v16 == v8)
      {
LABEL_22:
        uint64_t v31 = v16[1];
        size_t v33 = (size_t)*v31;
        uint64_t result = (char *)(v31 + 2);
        size_t v32 = v33;
        goto LABEL_23;
      }
      int v18 = 1;
      while (v17 != (uint64_t ***)-4096)
      {
        int v19 = v15 + v18++;
        uint64_t v15 = v19 & (v14 - 1);
        unint64_t v17 = *(uint64_t ****)(v13 + 16 * v15);
        if (v17 == v8)
        {
          uint64_t v16 = (uint64_t ****)(v13 + 16 * v15);
          goto LABEL_22;
        }
      }
    }
    uint64_t v16 = (uint64_t ****)(v13 + 16 * v14);
    goto LABEL_22;
  }
  size_t v32 = 0;
  uint64_t result = &byte_1CFBCE98E;
LABEL_23:
  if ((*((unsigned char *)v9 + 23) & 0x10) != 0)
  {
    uint64_t v34 = ***v9;
    uint64_t v35 = *(void *)(v34 + 152);
    uint64_t v36 = *(unsigned int *)(v34 + 168);
    if (v36)
    {
      LODWORD(v37) = (v36 - 1) & ((v9 >> 4) ^ (v9 >> 9));
      uint64_t v38 = (uint64_t ****)(v35 + 16 * v37);
      size_t v39 = *v38;
      if (*v38 == v9)
      {
LABEL_31:
        uint64_t v42 = v38[1];
        size_t v45 = (size_t)*v42;
        uint64_t v43 = (char *)(v42 + 2);
        size_t v44 = v45;
        goto LABEL_32;
      }
      int v40 = 1;
      while (v39 != (uint64_t ***)-4096)
      {
        int v41 = v37 + v40++;
        uint64_t v37 = v41 & (v36 - 1);
        size_t v39 = *(uint64_t ****)(v35 + 16 * v37);
        if (v39 == v9)
        {
          uint64_t v38 = (uint64_t ****)(v35 + 16 * v37);
          goto LABEL_31;
        }
      }
    }
    uint64_t v38 = (uint64_t ****)(v35 + 16 * v36);
    goto LABEL_31;
  }
  size_t v44 = 0;
  uint64_t v43 = &byte_1CFBCE98E;
LABEL_32:
  if (v44 >= v32) {
    size_t v46 = v32;
  }
  else {
    size_t v46 = v44;
  }
  if (v46 && (uint64_t result = (char *)memcmp(result, v43, v46), result))
  {
    if ((result & 0x80000000) == 0) {
      goto LABEL_38;
    }
  }
  else if (v32 >= v44)
  {
LABEL_38:
    uint64_t v47 = *(void *)a3;
    int v48 = *(uint64_t ****)(*(void *)a3 + 8);
    if (!v48) {
      goto LABEL_74;
    }
    if ((*((unsigned char *)v48 + 23) & 0x10) == 0)
    {
      size_t v67 = 0;
      uint64_t result = &byte_1CFBCE98E;
LABEL_57:
      if ((*((unsigned char *)v8 + 23) & 0x10) == 0)
      {
        size_t v79 = 0;
        int v78 = &byte_1CFBCE98E;
LABEL_66:
        if (v79 >= v67) {
          size_t v81 = v67;
        }
        else {
          size_t v81 = v79;
        }
        if (v81 && (uint64_t result = (char *)memcmp(result, v78, v81), result))
        {
          if ((result & 0x80000000) == 0) {
            return result;
          }
        }
        else if (v67 >= v79)
        {
          return result;
        }
LABEL_74:
        *(void *)BOOL v4 = v47;
        *(void *)a3 = v6;
        uint64_t v20 = *(void *)v4;
        uint64_t v7 = *(void *)v5;
        uint64_t v82 = *(uint64_t ****)(*(void *)v4 + 8);
        uint64_t v22 = *(uint64_t ****)(*(void *)v5 + 8);
        if (v82)
        {
          if (!v22) {
            return result;
          }
          if ((*((unsigned char *)v82 + 23) & 0x10) == 0)
          {
            size_t v103 = 0;
            uint64_t result = &byte_1CFBCE98E;
LABEL_96:
            if ((*((unsigned char *)v22 + 23) & 0x10) == 0)
            {
              size_t v120 = 0;
              uint64_t v119 = &byte_1CFBCE98E;
              goto LABEL_115;
            }
            uint64_t v105 = ***v22;
            uint64_t v106 = *(void *)(v105 + 152);
            uint64_t v107 = *(unsigned int *)(v105 + 168);
            if (v107)
            {
              LODWORD(v108) = (v107 - 1) & ((v22 >> 4) ^ (v22 >> 9));
              unint64_t v109 = (uint64_t ****)(v106 + 16 * v108);
              size_t v110 = *v109;
              if (*v109 == v22)
              {
LABEL_114:
                uint64_t v118 = v109[1];
                size_t v121 = (size_t)*v118;
                uint64_t v119 = (char *)(v118 + 2);
                size_t v120 = v121;
LABEL_115:
                if (v120 >= v103) {
                  size_t v122 = v103;
                }
                else {
                  size_t v122 = v120;
                }
                if (v122)
                {
                  uint64_t result = (char *)memcmp(result, v119, v122);
                  if (result)
                  {
LABEL_120:
                    if ((result & 0x80000000) == 0) {
                      return result;
                    }
                    goto LABEL_143;
                  }
                }
                if (v103 >= v120) {
                  return result;
                }
                goto LABEL_143;
              }
              int v111 = 1;
              while (v110 != (uint64_t ***)-4096)
              {
                int v112 = v108 + v111++;
                uint64_t v108 = v112 & (v107 - 1);
                size_t v110 = *(uint64_t ****)(v106 + 16 * v108);
                if (v110 == v22)
                {
                  unint64_t v109 = (uint64_t ****)(v106 + 16 * v108);
                  goto LABEL_114;
                }
              }
            }
            unint64_t v109 = (uint64_t ****)(v106 + 16 * v107);
            goto LABEL_114;
          }
          uint64_t v83 = ***v82;
          uint64_t v84 = *(void *)(v83 + 152);
          uint64_t v85 = *(unsigned int *)(v83 + 168);
          if (v85)
          {
            LODWORD(v86) = (v85 - 1) & ((v82 >> 4) ^ (v82 >> 9));
            uint64_t v87 = (uint64_t ****)(v84 + 16 * v86);
            uint64_t v88 = *v87;
            if (*v87 == v82)
            {
LABEL_95:
              uint64_t v102 = v87[1];
              size_t v104 = (size_t)*v102;
              uint64_t result = (char *)(v102 + 2);
              size_t v103 = v104;
              goto LABEL_96;
            }
            int v89 = 1;
            while (v88 != (uint64_t ***)-4096)
            {
              int v90 = v86 + v89++;
              uint64_t v86 = v90 & (v85 - 1);
              uint64_t v88 = *(uint64_t ****)(v84 + 16 * v86);
              if (v88 == v82)
              {
                uint64_t v87 = (uint64_t ****)(v84 + 16 * v86);
                goto LABEL_95;
              }
            }
          }
          uint64_t v87 = (uint64_t ****)(v84 + 16 * v85);
          goto LABEL_95;
        }
LABEL_83:
        if (!v22) {
          return result;
        }
        goto LABEL_143;
      }
      uint64_t v69 = ***v8;
      uint64_t v70 = *(void *)(v69 + 152);
      uint64_t v71 = *(unsigned int *)(v69 + 168);
      if (v71)
      {
        LODWORD(v72) = (v71 - 1) & (v10 ^ (v8 >> 9));
        uint64_t v73 = (uint64_t ****)(v70 + 16 * v72);
        uint64_t v74 = *v73;
        if (*v73 == v8)
        {
LABEL_65:
          unint64_t v77 = v73[1];
          size_t v80 = (size_t)*v77;
          int v78 = (char *)(v77 + 2);
          size_t v79 = v80;
          goto LABEL_66;
        }
        int v75 = 1;
        while (v74 != (uint64_t ***)-4096)
        {
          int v76 = v72 + v75++;
          uint64_t v72 = v76 & (v71 - 1);
          uint64_t v74 = *(uint64_t ****)(v70 + 16 * v72);
          if (v74 == v8)
          {
            uint64_t v73 = (uint64_t ****)(v70 + 16 * v72);
            goto LABEL_65;
          }
        }
      }
      uint64_t v73 = (uint64_t ****)(v70 + 16 * v71);
      goto LABEL_65;
    }
    uint64_t v49 = ***v48;
    uint64_t v50 = *(void *)(v49 + 152);
    uint64_t v51 = *(unsigned int *)(v49 + 168);
    if (v51)
    {
      LODWORD(v52) = (v51 - 1) & ((v48 >> 4) ^ (v48 >> 9));
      size_t v53 = (uint64_t ****)(v50 + 16 * v52);
      unint64_t v54 = *v53;
      if (*v53 == v48)
      {
LABEL_56:
        unsigned int v66 = v53[1];
        size_t v68 = (size_t)*v66;
        uint64_t result = (char *)(v66 + 2);
        size_t v67 = v68;
        goto LABEL_57;
      }
      int v55 = 1;
      while (v54 != (uint64_t ***)-4096)
      {
        int v56 = v52 + v55++;
        uint64_t v52 = v56 & (v51 - 1);
        unint64_t v54 = *(uint64_t ****)(v50 + 16 * v52);
        if (v54 == v48)
        {
          size_t v53 = (uint64_t ****)(v50 + 16 * v52);
          goto LABEL_56;
        }
      }
    }
    size_t v53 = (uint64_t ****)(v50 + 16 * v51);
    goto LABEL_56;
  }
  uint64_t v20 = *(void *)a3;
  int v57 = *(uint64_t ****)(*(void *)a3 + 8);
  if (!v57) {
    goto LABEL_142;
  }
  if ((*((unsigned char *)v57 + 23) & 0x10) != 0)
  {
    uint64_t v58 = ***v57;
    uint64_t v59 = *(void *)(v58 + 152);
    uint64_t v60 = *(unsigned int *)(v58 + 168);
    if (v60)
    {
      LODWORD(v61) = (v60 - 1) & ((v57 >> 4) ^ (v57 >> 9));
      uint64_t v62 = (uint64_t ****)(v59 + 16 * v61);
      uint64_t v63 = *v62;
      if (*v62 == v57) {
        goto LABEL_125;
      }
      int v64 = 1;
      while (v63 != (uint64_t ***)-4096)
      {
        int v65 = v61 + v64++;
        uint64_t v61 = v65 & (v60 - 1);
        uint64_t v63 = *(uint64_t ****)(v59 + 16 * v61);
        if (v63 == v57)
        {
          uint64_t v62 = (uint64_t ****)(v59 + 16 * v61);
          goto LABEL_125;
        }
      }
    }
    uint64_t v62 = (uint64_t ****)(v59 + 16 * v60);
LABEL_125:
    int v123 = v62[1];
    size_t v125 = (size_t)*v123;
    uint64_t result = (char *)(v123 + 2);
    size_t v124 = v125;
    if ((v11 & 0x10000000) != 0) {
      goto LABEL_126;
    }
    goto LABEL_151;
  }
  size_t v124 = 0;
  uint64_t result = &byte_1CFBCE98E;
  if ((v11 & 0x10000000) != 0)
  {
LABEL_126:
    uint64_t v126 = ***v8;
    uint64_t v127 = *(void *)(v126 + 152);
    uint64_t v128 = *(unsigned int *)(v126 + 168);
    if (v128)
    {
      LODWORD(v129) = (v128 - 1) & (v10 ^ (v8 >> 9));
      uint64_t v130 = (uint64_t ****)(v127 + 16 * v129);
      uint64_t v131 = *v130;
      if (*v130 == v8)
      {
LABEL_133:
        long long v134 = v130[1];
        size_t v137 = (size_t)*v134;
        int v135 = (char *)(v134 + 2);
        size_t v136 = v137;
        goto LABEL_134;
      }
      int v132 = 1;
      while (v131 != (uint64_t ***)-4096)
      {
        int v133 = v129 + v132++;
        uint64_t v129 = v133 & (v128 - 1);
        uint64_t v131 = *(uint64_t ****)(v127 + 16 * v129);
        if (v131 == v8)
        {
          uint64_t v130 = (uint64_t ****)(v127 + 16 * v129);
          goto LABEL_133;
        }
      }
    }
    uint64_t v130 = (uint64_t ****)(v127 + 16 * v128);
    goto LABEL_133;
  }
LABEL_151:
  size_t v136 = 0;
  int v135 = &byte_1CFBCE98E;
LABEL_134:
  if (v136 >= v124) {
    size_t v138 = v124;
  }
  else {
    size_t v138 = v136;
  }
  if (!v138 || (uint64_t result = (char *)memcmp(result, v135, v138), !result))
  {
    if (v124 >= v136) {
      goto LABEL_11;
    }
LABEL_142:
    BOOL v4 = a3;
    goto LABEL_143;
  }
  if ((result & 0x80000000) != 0) {
    goto LABEL_142;
  }
LABEL_11:
  *(void *)BOOL v5 = v6;
  *(void *)BOOL v4 = v7;
  uint64_t v20 = *(void *)a3;
  uint64_t v21 = *(uint64_t ****)(*(void *)a3 + 8);
  uint64_t v22 = *(uint64_t ****)(v7 + 8);
  if (!v21)
  {
    BOOL v5 = v4;
    BOOL v4 = a3;
    goto LABEL_83;
  }
  if (!v22) {
    return result;
  }
  if ((*((unsigned char *)v21 + 23) & 0x10) != 0)
  {
    uint64_t v23 = ***v21;
    uint64_t v24 = *(void *)(v23 + 152);
    uint64_t v25 = *(unsigned int *)(v23 + 168);
    if (v25)
    {
      LODWORD(v26) = (v25 - 1) & ((v21 >> 4) ^ (v21 >> 9));
      uint64_t v27 = (uint64_t ****)(v24 + 16 * v26);
      uint64_t v28 = *v27;
      if (*v27 == v21)
      {
LABEL_86:
        int v91 = v27[1];
        size_t v93 = (size_t)*v91;
        uint64_t result = (char *)(v91 + 2);
        size_t v92 = v93;
        goto LABEL_87;
      }
      int v29 = 1;
      while (v28 != (uint64_t ***)-4096)
      {
        int v30 = v26 + v29++;
        uint64_t v26 = v30 & (v25 - 1);
        uint64_t v28 = *(uint64_t ****)(v24 + 16 * v26);
        if (v28 == v21)
        {
          uint64_t v27 = (uint64_t ****)(v24 + 16 * v26);
          goto LABEL_86;
        }
      }
    }
    uint64_t v27 = (uint64_t ****)(v24 + 16 * v25);
    goto LABEL_86;
  }
  size_t v92 = 0;
  uint64_t result = &byte_1CFBCE98E;
LABEL_87:
  if ((*((unsigned char *)v22 + 23) & 0x10) == 0)
  {
    size_t v115 = 0;
    uint64_t v114 = &byte_1CFBCE98E;
    goto LABEL_105;
  }
  uint64_t v94 = ***v22;
  uint64_t v95 = *(void *)(v94 + 152);
  uint64_t v96 = *(unsigned int *)(v94 + 168);
  if (!v96) {
    goto LABEL_103;
  }
  LODWORD(v97) = (v96 - 1) & ((v22 >> 4) ^ (v22 >> 9));
  uint64_t v98 = (uint64_t ****)(v95 + 16 * v97);
  uint64_t v99 = *v98;
  if (*v98 != v22)
  {
    int v100 = 1;
    while (v99 != (uint64_t ***)-4096)
    {
      int v101 = v97 + v100++;
      uint64_t v97 = v101 & (v96 - 1);
      uint64_t v99 = *(uint64_t ****)(v95 + 16 * v97);
      if (v99 == v22)
      {
        uint64_t v98 = (uint64_t ****)(v95 + 16 * v97);
        goto LABEL_104;
      }
    }
LABEL_103:
    uint64_t v98 = (uint64_t ****)(v95 + 16 * v96);
  }
LABEL_104:
  uint64_t v113 = v98[1];
  size_t v116 = (size_t)*v113;
  uint64_t v114 = (char *)(v113 + 2);
  size_t v115 = v116;
LABEL_105:
  if (v115 >= v92) {
    size_t v117 = v92;
  }
  else {
    size_t v117 = v115;
  }
  if (v117)
  {
    uint64_t result = (char *)memcmp(result, v114, v117);
    if (result)
    {
      BOOL v5 = v4;
      BOOL v4 = a3;
      goto LABEL_120;
    }
  }
  BOOL v5 = v4;
  BOOL v4 = a3;
  if (v92 >= v115) {
    return result;
  }
LABEL_143:
  *(void *)BOOL v5 = v20;
  *(void *)BOOL v4 = v7;
  return result;
}

BOOL sub_1CBFACF78(uint64_t *a1, char *a2)
{
  uint64_t v4 = (a2 - (char *)a1) >> 3;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v6 = *((void *)a2 - 1);
      uint64_t v7 = *a1;
      uint64_t v8 = *(uint64_t ****)(v6 + 8);
      unint64_t v9 = *(uint64_t ****)(*a1 + 8);
      if (v8)
      {
        if (v9)
        {
          if ((*((unsigned char *)v8 + 23) & 0x10) != 0)
          {
            uint64_t v10 = ***v8;
            uint64_t v11 = *(void *)(v10 + 152);
            uint64_t v12 = *(unsigned int *)(v10 + 168);
            if (v12)
            {
              LODWORD(v13) = (v12 - 1) & ((v8 >> 4) ^ (v8 >> 9));
              uint64_t v14 = (uint64_t ****)(v11 + 16 * v13);
              uint64_t v15 = *v14;
              if (*v14 != v8)
              {
                int v16 = 1;
                do
                {
                  if (v15 == (uint64_t ***)-4096) {
                    goto LABEL_101;
                  }
                  int v17 = v13 + v16++;
                  uint64_t v13 = v17 & (v12 - 1);
                  uint64_t v15 = *(uint64_t ****)(v11 + 16 * v13);
                }
                while (v15 != v8);
                uint64_t v14 = (uint64_t ****)(v11 + 16 * v13);
              }
            }
            else
            {
LABEL_101:
              uint64_t v14 = (uint64_t ****)(v11 + 16 * v12);
            }
            uint64_t v97 = v14[1];
            size_t v100 = (size_t)*v97;
            uint64_t v98 = (char *)(v97 + 2);
            size_t v99 = v100;
          }
          else
          {
            size_t v99 = 0;
            uint64_t v98 = &byte_1CFBCE98E;
          }
          if ((*((unsigned char *)v9 + 23) & 0x10) != 0)
          {
            uint64_t v101 = ***v9;
            uint64_t v102 = *(void *)(v101 + 152);
            uint64_t v103 = *(unsigned int *)(v101 + 168);
            if (v103)
            {
              LODWORD(v104) = (v103 - 1) & ((v9 >> 4) ^ (v9 >> 9));
              uint64_t v105 = (uint64_t ****)(v102 + 16 * v104);
              uint64_t v106 = *v105;
              if (*v105 != v9)
              {
                int v107 = 1;
                do
                {
                  if (v106 == (uint64_t ***)-4096) {
                    goto LABEL_119;
                  }
                  int v108 = v104 + v107++;
                  uint64_t v104 = v108 & (v103 - 1);
                  uint64_t v106 = *(uint64_t ****)(v102 + 16 * v104);
                }
                while (v106 != v9);
                uint64_t v105 = (uint64_t ****)(v102 + 16 * v104);
              }
            }
            else
            {
LABEL_119:
              uint64_t v105 = (uint64_t ****)(v102 + 16 * v103);
            }
            size_t v121 = v105[1];
            size_t v124 = (size_t)*v121;
            size_t v122 = (char *)(v121 + 2);
            size_t v123 = v124;
          }
          else
          {
            size_t v123 = 0;
            size_t v122 = &byte_1CFBCE98E;
          }
          if (v123 >= v99) {
            size_t v125 = v99;
          }
          else {
            size_t v125 = v123;
          }
          if (v125 && (int v126 = memcmp(v98, v122, v125)) != 0)
          {
            if ((v126 & 0x80000000) == 0) {
              return 1;
            }
          }
          else if (v99 >= v123)
          {
            return 1;
          }
LABEL_129:
          *a1 = v6;
          *((void *)a2 - 1) = v7;
          return 1;
        }
      }
      else if (v9)
      {
        goto LABEL_129;
      }
      return result;
    case 3:
      sub_1CBFAC870((char *)a1, (char *)a1 + 8, a2 - 8);
      return 1;
    case 4:
      sub_1CBFADA84((char *)a1, (char *)a1 + 8, (char *)a1 + 16, (uint64_t *)a2 - 1);
      return 1;
    case 5:
      uint64_t v83 = a1 + 2;
      uint64_t v84 = a1 + 3;
      sub_1CBFADA84((char *)a1, (char *)a1 + 8, (char *)a1 + 16, a1 + 3);
      uint64_t v85 = *((void *)a2 - 1);
      uint64_t v86 = a1[3];
      uint64_t v87 = *(uint64_t ****)(v85 + 8);
      uint64_t v88 = *(uint64_t ****)(v86 + 8);
      if (!v87)
      {
        if (!v88) {
          return 1;
        }
        goto LABEL_140;
      }
      if (!v88) {
        return 1;
      }
      if ((*((unsigned char *)v87 + 23) & 0x10) != 0)
      {
        uint64_t v89 = ***v87;
        uint64_t v90 = *(void *)(v89 + 152);
        uint64_t v91 = *(unsigned int *)(v89 + 168);
        if (v91)
        {
          LODWORD(v92) = (v91 - 1) & ((v87 >> 4) ^ (v87 >> 9));
          size_t v93 = (uint64_t ****)(v90 + 16 * v92);
          uint64_t v94 = *v93;
          if (*v93 != v87)
          {
            int v95 = 1;
            do
            {
              if (v94 == (uint64_t ***)-4096) {
                goto LABEL_110;
              }
              int v96 = v92 + v95++;
              uint64_t v92 = v96 & (v91 - 1);
              uint64_t v94 = *(uint64_t ****)(v90 + 16 * v92);
            }
            while (v94 != v87);
            size_t v93 = (uint64_t ****)(v90 + 16 * v92);
          }
        }
        else
        {
LABEL_110:
          size_t v93 = (uint64_t ****)(v90 + 16 * v91);
        }
        unint64_t v109 = v93[1];
        size_t v112 = (size_t)*v109;
        size_t v110 = (char *)(v109 + 2);
        size_t v111 = v112;
        goto LABEL_112;
      }
      size_t v111 = 0;
      size_t v110 = &byte_1CFBCE98E;
LABEL_112:
      if ((*((unsigned char *)v88 + 23) & 0x10) != 0)
      {
        uint64_t v113 = ***v88;
        uint64_t v114 = *(void *)(v113 + 152);
        uint64_t v115 = *(unsigned int *)(v113 + 168);
        if (v115)
        {
          LODWORD(v116) = (v115 - 1) & ((v88 >> 4) ^ (v88 >> 9));
          size_t v117 = (uint64_t ****)(v114 + 16 * v116);
          uint64_t v118 = *v117;
          if (*v117 != v88)
          {
            int v119 = 1;
            do
            {
              if (v118 == (uint64_t ***)-4096) {
                goto LABEL_130;
              }
              int v120 = v116 + v119++;
              uint64_t v116 = v120 & (v115 - 1);
              uint64_t v118 = *(uint64_t ****)(v114 + 16 * v116);
            }
            while (v118 != v88);
            size_t v117 = (uint64_t ****)(v114 + 16 * v116);
          }
        }
        else
        {
LABEL_130:
          size_t v117 = (uint64_t ****)(v114 + 16 * v115);
        }
        uint64_t v127 = v117[1];
        size_t v130 = (size_t)*v127;
        uint64_t v128 = (char *)(v127 + 2);
        size_t v129 = v130;
        goto LABEL_132;
      }
      size_t v129 = 0;
      uint64_t v128 = &byte_1CFBCE98E;
LABEL_132:
      if (v129 >= v111) {
        size_t v131 = v111;
      }
      else {
        size_t v131 = v129;
      }
      if (v131 && (int v132 = memcmp(v110, v128, v131)) != 0)
      {
        if ((v132 & 0x80000000) == 0) {
          return 1;
        }
      }
      else if (v111 >= v129)
      {
        return 1;
      }
LABEL_140:
      *uint64_t v84 = v85;
      *((void *)a2 - 1) = v86;
      uint64_t v133 = *v84;
      uint64_t v134 = *v83;
      int v135 = *(uint64_t ****)(*v84 + 8);
      size_t v136 = *(uint64_t ****)(*v83 + 8);
      if (!v135)
      {
        if (!v136) {
          return 1;
        }
        goto LABEL_170;
      }
      if (!v136) {
        return 1;
      }
      if ((*((unsigned char *)v135 + 23) & 0x10) != 0)
      {
        uint64_t v137 = ***v135;
        uint64_t v138 = *(void *)(v137 + 152);
        uint64_t v139 = *(unsigned int *)(v137 + 168);
        if (v139)
        {
          LODWORD(v140) = (v139 - 1) & ((v135 >> 4) ^ (v135 >> 9));
          size_t v141 = (uint64_t ****)(v138 + 16 * v140);
          int v142 = *v141;
          if (*v141 != v135)
          {
            int v143 = 1;
            do
            {
              if (v142 == (uint64_t ***)-4096) {
                goto LABEL_151;
              }
              int v144 = v140 + v143++;
              uint64_t v140 = v144 & (v139 - 1);
              int v142 = *(uint64_t ****)(v138 + 16 * v140);
            }
            while (v142 != v135);
            size_t v141 = (uint64_t ****)(v138 + 16 * v140);
          }
        }
        else
        {
LABEL_151:
          size_t v141 = (uint64_t ****)(v138 + 16 * v139);
        }
        uint64_t v145 = v141[1];
        size_t v148 = (size_t)*v145;
        uint64_t v146 = (char *)(v145 + 2);
        size_t v147 = v148;
        goto LABEL_153;
      }
      size_t v147 = 0;
      uint64_t v146 = &byte_1CFBCE98E;
LABEL_153:
      if ((*((unsigned char *)v136 + 23) & 0x10) != 0)
      {
        uint64_t v149 = ***v136;
        uint64_t v150 = *(void *)(v149 + 152);
        uint64_t v151 = *(unsigned int *)(v149 + 168);
        if (v151)
        {
          LODWORD(v152) = (v151 - 1) & ((v136 >> 4) ^ (v136 >> 9));
          unsigned int v153 = (uint64_t ****)(v150 + 16 * v152);
          unsigned int v154 = *v153;
          if (*v153 != v136)
          {
            int v155 = 1;
            do
            {
              if (v154 == (uint64_t ***)-4096) {
                goto LABEL_160;
              }
              int v156 = v152 + v155++;
              uint64_t v152 = v156 & (v151 - 1);
              unsigned int v154 = *(uint64_t ****)(v150 + 16 * v152);
            }
            while (v154 != v136);
            unsigned int v153 = (uint64_t ****)(v150 + 16 * v152);
          }
        }
        else
        {
LABEL_160:
          unsigned int v153 = (uint64_t ****)(v150 + 16 * v151);
        }
        uint64_t v157 = v153[1];
        size_t v160 = (size_t)*v157;
        uint64_t v158 = (char *)(v157 + 2);
        size_t v159 = v160;
        goto LABEL_162;
      }
      size_t v159 = 0;
      uint64_t v158 = &byte_1CFBCE98E;
LABEL_162:
      if (v159 >= v147) {
        size_t v161 = v147;
      }
      else {
        size_t v161 = v159;
      }
      if (v161 && (int v162 = memcmp(v146, v158, v161)) != 0)
      {
        if ((v162 & 0x80000000) == 0) {
          return 1;
        }
      }
      else if (v147 >= v159)
      {
        return 1;
      }
LABEL_170:
      *uint64_t v83 = v133;
      *uint64_t v84 = v134;
      uint64_t v163 = a1[1];
      int v164 = *(uint64_t ****)(v133 + 8);
      uint64_t v165 = *(uint64_t ****)(v163 + 8);
      if (!v164)
      {
        if (!v165) {
          return 1;
        }
        goto LABEL_200;
      }
      if (!v165) {
        return 1;
      }
      if ((*((unsigned char *)v164 + 23) & 0x10) != 0)
      {
        uint64_t v166 = ***v164;
        uint64_t v167 = *(void *)(v166 + 152);
        uint64_t v168 = *(unsigned int *)(v166 + 168);
        if (v168)
        {
          LODWORD(v169) = (v168 - 1) & ((v164 >> 4) ^ (v164 >> 9));
          int v170 = (uint64_t ****)(v167 + 16 * v169);
          BOOL v171 = *v170;
          if (*v170 != v164)
          {
            int v172 = 1;
            do
            {
              if (v171 == (uint64_t ***)-4096) {
                goto LABEL_181;
              }
              int v173 = v169 + v172++;
              uint64_t v169 = v173 & (v168 - 1);
              BOOL v171 = *(uint64_t ****)(v167 + 16 * v169);
            }
            while (v171 != v164);
            int v170 = (uint64_t ****)(v167 + 16 * v169);
          }
        }
        else
        {
LABEL_181:
          int v170 = (uint64_t ****)(v167 + 16 * v168);
        }
        uint64_t v174 = v170[1];
        size_t v177 = (size_t)*v174;
        uint64_t v175 = (char *)(v174 + 2);
        size_t v176 = v177;
        goto LABEL_183;
      }
      size_t v176 = 0;
      uint64_t v175 = &byte_1CFBCE98E;
LABEL_183:
      if ((*((unsigned char *)v165 + 23) & 0x10) != 0)
      {
        uint64_t v178 = ***v165;
        uint64_t v179 = *(void *)(v178 + 152);
        uint64_t v180 = *(unsigned int *)(v178 + 168);
        if (v180)
        {
          LODWORD(v181) = (v180 - 1) & ((v165 >> 4) ^ (v165 >> 9));
          int v182 = (uint64_t ****)(v179 + 16 * v181);
          int v183 = *v182;
          if (*v182 != v165)
          {
            int v184 = 1;
            do
            {
              if (v183 == (uint64_t ***)-4096) {
                goto LABEL_190;
              }
              int v185 = v181 + v184++;
              uint64_t v181 = v185 & (v180 - 1);
              int v183 = *(uint64_t ****)(v179 + 16 * v181);
            }
            while (v183 != v165);
            int v182 = (uint64_t ****)(v179 + 16 * v181);
          }
        }
        else
        {
LABEL_190:
          int v182 = (uint64_t ****)(v179 + 16 * v180);
        }
        uint64_t v186 = v182[1];
        size_t v189 = (size_t)*v186;
        size_t v187 = (char *)(v186 + 2);
        size_t v188 = v189;
        goto LABEL_192;
      }
      size_t v188 = 0;
      size_t v187 = &byte_1CFBCE98E;
LABEL_192:
      if (v188 >= v176) {
        size_t v190 = v176;
      }
      else {
        size_t v190 = v188;
      }
      if (v190 && (int v191 = memcmp(v175, v187, v190)) != 0)
      {
        if ((v191 & 0x80000000) == 0) {
          return 1;
        }
      }
      else if (v176 >= v188)
      {
        return 1;
      }
LABEL_200:
      a1[1] = v133;
      a1[2] = v163;
      uint64_t v192 = *a1;
      uint64_t v193 = *(uint64_t ****)(v133 + 8);
      unsigned int v194 = *(uint64_t ****)(*a1 + 8);
      if (!v193)
      {
        if (!v194) {
          return 1;
        }
        goto LABEL_210;
      }
      if (!v194) {
        return 1;
      }
      if ((*((unsigned char *)v193 + 23) & 0x10) != 0)
      {
        uint64_t v195 = ***v193;
        uint64_t v196 = *(void *)(v195 + 152);
        uint64_t v197 = *(unsigned int *)(v195 + 168);
        if (v197)
        {
          LODWORD(v198) = (v197 - 1) & ((v193 >> 4) ^ (v193 >> 9));
          size_t v199 = (uint64_t ****)(v196 + 16 * v198);
          size_t v200 = *v199;
          if (*v199 == v193)
          {
LABEL_218:
            int v203 = v199[1];
            size_t v206 = (size_t)*v203;
            v204 = (char *)(v203 + 2);
            size_t v205 = v206;
            goto LABEL_219;
          }
          int v201 = 1;
          while (v200 != (uint64_t ***)-4096)
          {
            int v202 = v198 + v201++;
            uint64_t v198 = v202 & (v197 - 1);
            size_t v200 = *(uint64_t ****)(v196 + 16 * v198);
            if (v200 == v193)
            {
              size_t v199 = (uint64_t ****)(v196 + 16 * v198);
              goto LABEL_218;
            }
          }
        }
        size_t v199 = (uint64_t ****)(v196 + 16 * v197);
        goto LABEL_218;
      }
      size_t v205 = 0;
      v204 = &byte_1CFBCE98E;
LABEL_219:
      if ((*((unsigned char *)v194 + 23) & 0x10) != 0)
      {
        uint64_t v207 = ***v194;
        uint64_t v208 = *(void *)(v207 + 152);
        uint64_t v209 = *(unsigned int *)(v207 + 168);
        if (v209)
        {
          LODWORD(v210) = (v209 - 1) & ((v194 >> 4) ^ (v194 >> 9));
          uint64_t v211 = (uint64_t ****)(v208 + 16 * v210);
          uint64_t v212 = *v211;
          if (*v211 == v194)
          {
LABEL_227:
            uint64_t v215 = v211[1];
            size_t v218 = (size_t)*v215;
            unint64_t v216 = (char *)(v215 + 2);
            size_t v217 = v218;
            goto LABEL_228;
          }
          int v213 = 1;
          while (v212 != (uint64_t ***)-4096)
          {
            int v214 = v210 + v213++;
            uint64_t v210 = v214 & (v209 - 1);
            uint64_t v212 = *(uint64_t ****)(v208 + 16 * v210);
            if (v212 == v194)
            {
              uint64_t v211 = (uint64_t ****)(v208 + 16 * v210);
              goto LABEL_227;
            }
          }
        }
        uint64_t v211 = (uint64_t ****)(v208 + 16 * v209);
        goto LABEL_227;
      }
      size_t v217 = 0;
      unint64_t v216 = &byte_1CFBCE98E;
LABEL_228:
      if (v217 >= v205) {
        size_t v219 = v205;
      }
      else {
        size_t v219 = v217;
      }
      if (v219)
      {
        int v220 = memcmp(v204, v216, v219);
        if (v220)
        {
          if ((v220 & 0x80000000) == 0) {
            return 1;
          }
LABEL_210:
          *a1 = v133;
          a1[1] = v192;
          return 1;
        }
      }
      if (v205 < v217) {
        goto LABEL_210;
      }
      return 1;
    default:
      int v18 = (char *)(a1 + 2);
      sub_1CBFAC870((char *)a1, (char *)a1 + 8, (char *)a1 + 16);
      int v19 = (char *)(a1 + 3);
      if (a1 + 3 == (uint64_t *)a2) {
        return 1;
      }
      int v20 = 0;
      while (2)
      {
        uint64_t v21 = *(void *)v19;
        uint64_t v22 = *(void *)v18;
        uint64_t v23 = *(uint64_t ****)(*(void *)v19 + 8);
        uint64_t v24 = *(uint64_t ****)(*(void *)v18 + 8);
        if (v23)
        {
          if (!v24) {
            goto LABEL_81;
          }
          if ((*((unsigned char *)v23 + 23) & 0x10) != 0)
          {
            uint64_t v25 = ***v23;
            uint64_t v26 = *(void *)(v25 + 152);
            uint64_t v27 = *(unsigned int *)(v25 + 168);
            if (v27)
            {
              LODWORD(v28) = (v27 - 1) & ((v23 >> 4) ^ (v23 >> 9));
              int v29 = (uint64_t ****)(v26 + 16 * v28);
              int v30 = *v29;
              if (*v29 != v23)
              {
                int v31 = 1;
                do
                {
                  if (v30 == (uint64_t ***)-4096) {
                    goto LABEL_24;
                  }
                  int v32 = v28 + v31++;
                  uint64_t v28 = v32 & (v27 - 1);
                  int v30 = *(uint64_t ****)(v26 + 16 * v28);
                }
                while (v30 != v23);
                int v29 = (uint64_t ****)(v26 + 16 * v28);
              }
            }
            else
            {
LABEL_24:
              int v29 = (uint64_t ****)(v26 + 16 * v27);
            }
            size_t v33 = v29[1];
            size_t v36 = (size_t)*v33;
            uint64_t v34 = (char *)(v33 + 2);
            size_t v35 = v36;
          }
          else
          {
            size_t v35 = 0;
            uint64_t v34 = &byte_1CFBCE98E;
          }
          if ((*((unsigned char *)v24 + 23) & 0x10) != 0)
          {
            uint64_t v37 = ***v24;
            uint64_t v38 = *(void *)(v37 + 152);
            uint64_t v39 = *(unsigned int *)(v37 + 168);
            if (v39)
            {
              LODWORD(v40) = (v39 - 1) & ((v24 >> 4) ^ (v24 >> 9));
              int v41 = (uint64_t ****)(v38 + 16 * v40);
              uint64_t v42 = *v41;
              if (*v41 != v24)
              {
                int v43 = 1;
                do
                {
                  if (v42 == (uint64_t ***)-4096) {
                    goto LABEL_33;
                  }
                  int v44 = v40 + v43++;
                  uint64_t v40 = v44 & (v39 - 1);
                  uint64_t v42 = *(uint64_t ****)(v38 + 16 * v40);
                }
                while (v42 != v24);
                int v41 = (uint64_t ****)(v38 + 16 * v40);
              }
            }
            else
            {
LABEL_33:
              int v41 = (uint64_t ****)(v38 + 16 * v39);
            }
            size_t v45 = v41[1];
            size_t v48 = (size_t)*v45;
            size_t v46 = (char *)(v45 + 2);
            size_t v47 = v48;
          }
          else
          {
            size_t v47 = 0;
            size_t v46 = &byte_1CFBCE98E;
          }
          if (v47 >= v35) {
            size_t v49 = v35;
          }
          else {
            size_t v49 = v47;
          }
          if (v49 && (int v50 = memcmp(v34, v46, v49)) != 0)
          {
            if ((v50 & 0x80000000) == 0) {
              goto LABEL_81;
            }
          }
          else if (v35 >= v47)
          {
            goto LABEL_81;
          }
          goto LABEL_43;
        }
        if (!v24) {
          goto LABEL_81;
        }
LABEL_43:
        *(void *)int v19 = v22;
        uint64_t v51 = (char *)a1;
        if (v18 == (char *)a1) {
          goto LABEL_80;
        }
        uint64_t v52 = (uint64_t *)v18;
        while (2)
        {
          uint64_t v54 = *--v52;
          uint64_t v53 = v54;
          int v55 = *(uint64_t ****)(v21 + 8);
          int v56 = *(uint64_t ****)(v54 + 8);
          if (!v55)
          {
            if (!v56) {
              break;
            }
            goto LABEL_75;
          }
          if (!v56) {
            break;
          }
          if ((*((unsigned char *)v55 + 23) & 0x10) != 0)
          {
            uint64_t v57 = ***v55;
            uint64_t v58 = *(void *)(v57 + 152);
            uint64_t v59 = *(unsigned int *)(v57 + 168);
            if (v59)
            {
              LODWORD(v60) = (v59 - 1) & ((v55 >> 4) ^ (v55 >> 9));
              uint64_t v61 = (uint64_t ****)(v58 + 16 * v60);
              uint64_t v62 = *v61;
              if (*v61 == v55)
              {
LABEL_57:
                int v65 = v61[1];
                size_t v68 = (size_t)*v65;
                unsigned int v66 = (char *)(v65 + 2);
                size_t v67 = v68;
                goto LABEL_58;
              }
              int v63 = 1;
              while (v62 != (uint64_t ***)-4096)
              {
                int v64 = v60 + v63++;
                uint64_t v60 = v64 & (v59 - 1);
                uint64_t v62 = *(uint64_t ****)(v58 + 16 * v60);
                if (v62 == v55)
                {
                  uint64_t v61 = (uint64_t ****)(v58 + 16 * v60);
                  goto LABEL_57;
                }
              }
            }
            uint64_t v61 = (uint64_t ****)(v58 + 16 * v59);
            goto LABEL_57;
          }
          size_t v67 = 0;
          unsigned int v66 = &byte_1CFBCE98E;
LABEL_58:
          if ((*((unsigned char *)v56 + 23) & 0x10) != 0)
          {
            uint64_t v69 = ***v56;
            uint64_t v70 = *(void *)(v69 + 152);
            uint64_t v71 = *(unsigned int *)(v69 + 168);
            if (v71)
            {
              LODWORD(v72) = (v71 - 1) & ((v56 >> 4) ^ (v56 >> 9));
              uint64_t v73 = (uint64_t ****)(v70 + 16 * v72);
              uint64_t v74 = *v73;
              if (*v73 == v56)
              {
LABEL_66:
                unint64_t v77 = v73[1];
                size_t v80 = (size_t)*v77;
                int v78 = (char *)(v77 + 2);
                size_t v79 = v80;
                goto LABEL_67;
              }
              int v75 = 1;
              while (v74 != (uint64_t ***)-4096)
              {
                int v76 = v72 + v75++;
                uint64_t v72 = v76 & (v71 - 1);
                uint64_t v74 = *(uint64_t ****)(v70 + 16 * v72);
                if (v74 == v56)
                {
                  uint64_t v73 = (uint64_t ****)(v70 + 16 * v72);
                  goto LABEL_66;
                }
              }
            }
            uint64_t v73 = (uint64_t ****)(v70 + 16 * v71);
            goto LABEL_66;
          }
          size_t v79 = 0;
          int v78 = &byte_1CFBCE98E;
LABEL_67:
          if (v79 >= v67) {
            size_t v81 = v67;
          }
          else {
            size_t v81 = v79;
          }
          if (v81)
          {
            int v82 = memcmp(v66, v78, v81);
            if (v82)
            {
              if ((v82 & 0x80000000) == 0) {
                break;
              }
              goto LABEL_75;
            }
          }
          if (v67 < v79)
          {
LABEL_75:
            *(void *)int v18 = v53;
            int v18 = (char *)v52;
            if (v52 == a1)
            {
              uint64_t v51 = (char *)a1;
              goto LABEL_80;
            }
            continue;
          }
          break;
        }
        uint64_t v51 = v18;
LABEL_80:
        *(void *)uint64_t v51 = v21;
        if (++v20 != 8)
        {
LABEL_81:
          int v18 = v19;
          v19 += 8;
          if (v19 == a2) {
            return 1;
          }
          continue;
        }
        return v19 + 8 == a2;
      }
  }
}

char *sub_1CBFADA84(char *a1, char *a2, char *a3, uint64_t *a4)
{
  BOOL result = sub_1CBFAC870(a1, a2, a3);
  uint64_t v9 = *a4;
  uint64_t v10 = *(void *)a3;
  uint64_t v11 = *(uint64_t ****)(*a4 + 8);
  uint64_t v12 = *(uint64_t ****)(*(void *)a3 + 8);
  if (!v11)
  {
    if (!v12) {
      return result;
    }
    goto LABEL_31;
  }
  if (!v12) {
    return result;
  }
  if ((*((unsigned char *)v11 + 23) & 0x10) != 0)
  {
    uint64_t v13 = ***v11;
    uint64_t v14 = *(void *)(v13 + 152);
    uint64_t v15 = *(unsigned int *)(v13 + 168);
    if (v15)
    {
      LODWORD(v16) = (v15 - 1) & ((v11 >> 4) ^ (v11 >> 9));
      int v17 = (uint64_t ****)(v14 + 16 * v16);
      int v18 = *v17;
      if (*v17 == v11)
      {
LABEL_13:
        uint64_t v21 = v17[1];
        size_t v23 = (size_t)*v21;
        BOOL result = (char *)(v21 + 2);
        size_t v22 = v23;
        goto LABEL_14;
      }
      int v19 = 1;
      while (v18 != (uint64_t ***)-4096)
      {
        int v20 = v16 + v19++;
        uint64_t v16 = v20 & (v15 - 1);
        int v18 = *(uint64_t ****)(v14 + 16 * v16);
        if (v18 == v11)
        {
          int v17 = (uint64_t ****)(v14 + 16 * v16);
          goto LABEL_13;
        }
      }
    }
    int v17 = (uint64_t ****)(v14 + 16 * v15);
    goto LABEL_13;
  }
  size_t v22 = 0;
  BOOL result = &byte_1CFBCE98E;
LABEL_14:
  if ((*((unsigned char *)v12 + 23) & 0x10) != 0)
  {
    uint64_t v24 = ***v12;
    uint64_t v25 = *(void *)(v24 + 152);
    uint64_t v26 = *(unsigned int *)(v24 + 168);
    if (v26)
    {
      LODWORD(v27) = (v26 - 1) & ((v12 >> 4) ^ (v12 >> 9));
      uint64_t v28 = (uint64_t ****)(v25 + 16 * v27);
      int v29 = *v28;
      if (*v28 == v12)
      {
LABEL_22:
        int v32 = v28[1];
        size_t v35 = (size_t)*v32;
        size_t v33 = (char *)(v32 + 2);
        size_t v34 = v35;
        goto LABEL_23;
      }
      int v30 = 1;
      while (v29 != (uint64_t ***)-4096)
      {
        int v31 = v27 + v30++;
        uint64_t v27 = v31 & (v26 - 1);
        int v29 = *(uint64_t ****)(v25 + 16 * v27);
        if (v29 == v12)
        {
          uint64_t v28 = (uint64_t ****)(v25 + 16 * v27);
          goto LABEL_22;
        }
      }
    }
    uint64_t v28 = (uint64_t ****)(v25 + 16 * v26);
    goto LABEL_22;
  }
  size_t v34 = 0;
  size_t v33 = &byte_1CFBCE98E;
LABEL_23:
  if (v34 >= v22) {
    size_t v36 = v22;
  }
  else {
    size_t v36 = v34;
  }
  if (v36 && (BOOL result = (char *)memcmp(result, v33, v36), result))
  {
    if ((result & 0x80000000) == 0) {
      return result;
    }
  }
  else if (v22 >= v34)
  {
    return result;
  }
LABEL_31:
  *(void *)a3 = v9;
  *a4 = v10;
  uint64_t v37 = *(void *)a3;
  uint64_t v38 = *(void *)a2;
  uint64_t v39 = *(uint64_t ****)(*(void *)a3 + 8);
  uint64_t v40 = *(uint64_t ****)(*(void *)a2 + 8);
  if (!v39)
  {
    if (!v40) {
      return result;
    }
    goto LABEL_61;
  }
  if (!v40) {
    return result;
  }
  if ((*((unsigned char *)v39 + 23) & 0x10) != 0)
  {
    uint64_t v41 = ***v39;
    uint64_t v42 = *(void *)(v41 + 152);
    uint64_t v43 = *(unsigned int *)(v41 + 168);
    if (v43)
    {
      LODWORD(v44) = (v43 - 1) & ((v39 >> 4) ^ (v39 >> 9));
      size_t v45 = (uint64_t ****)(v42 + 16 * v44);
      size_t v46 = *v45;
      if (*v45 == v39)
      {
LABEL_43:
        size_t v49 = v45[1];
        size_t v51 = (size_t)*v49;
        BOOL result = (char *)(v49 + 2);
        size_t v50 = v51;
        goto LABEL_44;
      }
      int v47 = 1;
      while (v46 != (uint64_t ***)-4096)
      {
        int v48 = v44 + v47++;
        uint64_t v44 = v48 & (v43 - 1);
        size_t v46 = *(uint64_t ****)(v42 + 16 * v44);
        if (v46 == v39)
        {
          size_t v45 = (uint64_t ****)(v42 + 16 * v44);
          goto LABEL_43;
        }
      }
    }
    size_t v45 = (uint64_t ****)(v42 + 16 * v43);
    goto LABEL_43;
  }
  size_t v50 = 0;
  BOOL result = &byte_1CFBCE98E;
LABEL_44:
  if ((*((unsigned char *)v40 + 23) & 0x10) != 0)
  {
    uint64_t v52 = ***v40;
    uint64_t v53 = *(void *)(v52 + 152);
    uint64_t v54 = *(unsigned int *)(v52 + 168);
    if (v54)
    {
      LODWORD(v55) = (v54 - 1) & ((v40 >> 4) ^ (v40 >> 9));
      int v56 = (uint64_t ****)(v53 + 16 * v55);
      uint64_t v57 = *v56;
      if (*v56 == v40)
      {
LABEL_52:
        uint64_t v60 = v56[1];
        size_t v63 = (size_t)*v60;
        uint64_t v61 = (char *)(v60 + 2);
        size_t v62 = v63;
        goto LABEL_53;
      }
      int v58 = 1;
      while (v57 != (uint64_t ***)-4096)
      {
        int v59 = v55 + v58++;
        uint64_t v55 = v59 & (v54 - 1);
        uint64_t v57 = *(uint64_t ****)(v53 + 16 * v55);
        if (v57 == v40)
        {
          int v56 = (uint64_t ****)(v53 + 16 * v55);
          goto LABEL_52;
        }
      }
    }
    int v56 = (uint64_t ****)(v53 + 16 * v54);
    goto LABEL_52;
  }
  size_t v62 = 0;
  uint64_t v61 = &byte_1CFBCE98E;
LABEL_53:
  if (v62 >= v50) {
    size_t v64 = v50;
  }
  else {
    size_t v64 = v62;
  }
  if (v64 && (BOOL result = (char *)memcmp(result, v61, v64), result))
  {
    if ((result & 0x80000000) == 0) {
      return result;
    }
  }
  else if (v50 >= v62)
  {
    return result;
  }
LABEL_61:
  *(void *)a2 = v37;
  *(void *)a3 = v38;
  uint64_t v65 = *(void *)a2;
  uint64_t v66 = *(void *)a1;
  size_t v67 = *(uint64_t ****)(*(void *)a2 + 8);
  size_t v68 = *(uint64_t ****)(*(void *)a1 + 8);
  if (!v67)
  {
    if (!v68) {
      return result;
    }
    goto LABEL_71;
  }
  if (!v68) {
    return result;
  }
  if ((*((unsigned char *)v67 + 23) & 0x10) != 0)
  {
    uint64_t v69 = ***v67;
    uint64_t v70 = *(void *)(v69 + 152);
    uint64_t v71 = *(unsigned int *)(v69 + 168);
    if (v71)
    {
      LODWORD(v72) = (v71 - 1) & ((v67 >> 4) ^ (v67 >> 9));
      uint64_t v73 = (uint64_t ****)(v70 + 16 * v72);
      uint64_t v74 = *v73;
      if (*v73 == v67)
      {
LABEL_74:
        unint64_t v77 = v73[1];
        size_t v79 = (size_t)*v77;
        BOOL result = (char *)(v77 + 2);
        size_t v78 = v79;
        goto LABEL_75;
      }
      int v75 = 1;
      while (v74 != (uint64_t ***)-4096)
      {
        int v76 = v72 + v75++;
        uint64_t v72 = v76 & (v71 - 1);
        uint64_t v74 = *(uint64_t ****)(v70 + 16 * v72);
        if (v74 == v67)
        {
          uint64_t v73 = (uint64_t ****)(v70 + 16 * v72);
          goto LABEL_74;
        }
      }
    }
    uint64_t v73 = (uint64_t ****)(v70 + 16 * v71);
    goto LABEL_74;
  }
  size_t v78 = 0;
  BOOL result = &byte_1CFBCE98E;
LABEL_75:
  if ((*((unsigned char *)v68 + 23) & 0x10) != 0)
  {
    uint64_t v80 = ***v68;
    uint64_t v81 = *(void *)(v80 + 152);
    uint64_t v82 = *(unsigned int *)(v80 + 168);
    if (v82)
    {
      LODWORD(v83) = (v82 - 1) & ((v68 >> 4) ^ (v68 >> 9));
      uint64_t v84 = (uint64_t ****)(v81 + 16 * v83);
      uint64_t v85 = *v84;
      if (*v84 == v68)
      {
LABEL_83:
        uint64_t v88 = v84[1];
        size_t v91 = (size_t)*v88;
        uint64_t v89 = (char *)(v88 + 2);
        size_t v90 = v91;
        goto LABEL_84;
      }
      int v86 = 1;
      while (v85 != (uint64_t ***)-4096)
      {
        int v87 = v83 + v86++;
        uint64_t v83 = v87 & (v82 - 1);
        uint64_t v85 = *(uint64_t ****)(v81 + 16 * v83);
        if (v85 == v68)
        {
          uint64_t v84 = (uint64_t ****)(v81 + 16 * v83);
          goto LABEL_83;
        }
      }
    }
    uint64_t v84 = (uint64_t ****)(v81 + 16 * v82);
    goto LABEL_83;
  }
  size_t v90 = 0;
  uint64_t v89 = &byte_1CFBCE98E;
LABEL_84:
  if (v90 >= v78) {
    size_t v92 = v78;
  }
  else {
    size_t v92 = v90;
  }
  if (v92 && (BOOL result = (char *)memcmp(result, v89, v92), result))
  {
    if ((result & 0x80000000) != 0) {
      goto LABEL_71;
    }
  }
  else if (v78 < v90)
  {
LABEL_71:
    *(void *)a1 = v65;
    *(void *)a2 = v66;
  }
  return result;
}

uint64_t *sub_1CBFADEF8(uint64_t **a1, uint64_t *a2)
{
  uint64_t v3 = sub_1CBFADF40(a1, a2);
  uint64_t v4 = a2[5];
  a2[5] = 0;
  if (v4) {
    sub_1CBFA9BA8((uint64_t)(a2 + 5), v4);
  }
  operator delete(a2);
  return v3;
}

uint64_t *sub_1CBFADF40(uint64_t **a1, uint64_t *a2)
{
  uint64_t v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      uint64_t v3 = v2;
      uint64_t v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    uint64_t v4 = a2;
    do
    {
      uint64_t v3 = (uint64_t *)v4[2];
      BOOL v5 = *v3 == (void)v4;
      uint64_t v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2) {
    *a1 = v3;
  }
  uint64_t v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  sub_1CB91F7C8(v6, a2);
  return v3;
}

void sub_1CBFADFB8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16))
    {
      uint64_t v3 = v2[5];
      v2[5] = 0;
      if (v3) {
        sub_1CBFA9BA8((uint64_t)(v2 + 5), v3);
      }
    }
    operator delete(v2);
  }
}

void *sub_1CBFAE01C(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 < 3 * v7)
  {
    if (v7 + ~v6 - *(_DWORD *)(a1 + 12) <= v7 >> 3)
    {
      sub_1CBAEE424(a1, v7);
      int v17 = 0;
      sub_1CB883B0C(a1, a3, &v17);
      a4 = v17;
    }
LABEL_4:
    uint64_t v8 = *a4;
    goto LABEL_5;
  }
  sub_1CBAEE424(a1, 2 * v7);
  uint64_t v8 = *a3;
  int v10 = *(_DWORD *)(a1 + 16) - 1;
  unsigned int v11 = ((*a3 >> 4) ^ (*a3 >> 9)) & v10;
  a4 = (void *)(*(void *)a1 + 16 * v11);
  uint64_t v12 = *a4;
  if (*a3 != *a4)
  {
    uint64_t v13 = 0;
    int v14 = 1;
    while (v12 != -4096)
    {
      if (v13) {
        BOOL v15 = 0;
      }
      else {
        BOOL v15 = v12 == -8192;
      }
      if (v15) {
        uint64_t v13 = a4;
      }
      unsigned int v16 = v11 + v14++;
      unsigned int v11 = v16 & v10;
      a4 = (void *)(*(void *)a1 + 16 * v11);
      uint64_t v12 = *a4;
      if (v8 == *a4) {
        goto LABEL_5;
      }
    }
    if (v13) {
      a4 = v13;
    }
    goto LABEL_4;
  }
LABEL_5:
  ++*(_DWORD *)(a1 + 8);
  if (v8 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

_OWORD *sub_1CBFAE150(int64x2_t *a1, long long *a2)
{
  uint64_t v2 = (a1->i64[1] - a1->i64[0]) >> 4;
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 60) {
    abort();
  }
  uint64_t v5 = a1[1].i64[0] - a1->i64[0];
  if (v5 >> 3 > v3) {
    unint64_t v3 = v5 >> 3;
  }
  if ((unint64_t)v5 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v6 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v6 = v3;
  }
  size_t v23 = a1 + 1;
  if (v6 >> 60) {
    sub_1CB833614();
  }
  uint64_t v8 = (char *)operator new(16 * v6);
  uint64_t v9 = &v8[16 * v2];
  long long v10 = *a2;
  *((void *)a2 + 1) = 0;
  *(_OWORD *)uint64_t v9 = v10;
  uint64_t v12 = a1->i64[0];
  unint64_t v11 = a1->u64[1];
  if (v11 == a1->i64[0])
  {
    int64x2_t v13 = vdupq_n_s64(v11);
    int v14 = &v8[16 * v2];
  }
  else
  {
    int v14 = &v8[16 * v2];
    do
    {
      uint64_t v15 = *(void *)(v11 - 16);
      v11 -= 16;
      *((void *)v14 - 2) = v15;
      v14 -= 16;
      uint64_t v16 = *(void *)(v11 + 8);
      *(void *)(v11 + 8) = 0;
      *((void *)v14 + 1) = v16;
    }
    while (v11 != v12);
    int64x2_t v13 = *a1;
  }
  int v17 = v9 + 16;
  a1->i64[0] = (uint64_t)v14;
  a1->i64[1] = (uint64_t)(v9 + 16);
  int64x2_t v21 = v13;
  uint64_t v18 = a1[1].i64[0];
  a1[1].i64[0] = (uint64_t)&v8[16 * v6];
  uint64_t v22 = v18;
  uint64_t v20 = v13.i64[0];
  sub_1CD46F884((uint64_t)&v20);
  return v17;
}

void *llvm::CallGraphSCC::ReplaceNode(void *a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = 0;
  uint64_t v4 = a1[2];
  do
  {
    unsigned int v5 = v3;
    uint64_t v6 = *(void *)(v4 + 8 * v3++);
  }
  while (v6 != a2);
  unsigned int v7 = (uint64_t *)(v4 + 8 * v5);
  if (a3)
  {
    *unsigned int v7 = a3;
  }
  else
  {
    uint64_t v14 = a2;
    __dst = v7;
    long long v10 = v7 + 1;
    int64x2_t v13 = a1;
    unint64_t v11 = (unsigned char *)a1[3];
    int64_t v12 = v11 - v10;
    if (v11 != v10) {
      memmove(__dst, v10, v11 - v10);
    }
    a2 = v14;
    a1 = v13;
    a3 = 0;
    v13[3] = (char *)__dst + v12;
  }
  uint64_t v8 = (int32x2_t *)a1[1];

  return sub_1CBFAE2F8(v8, a2, a3);
}

void *sub_1CBFAE2F8(int32x2_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v34 = a3;
  uint64_t v35 = a2;
  uint64_t v6 = a1 + 1;
  int32x2_t v5 = a1[1];
  __int32 v7 = a1[3].i32[0];
  if (v7)
  {
    __int32 v8 = v7 - 1;
    unsigned int v9 = (v7 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v10 = *(void *)&v5 + 16 * v9;
    uint64_t v11 = *(void *)v10;
    if (*(void *)v10 == a2)
    {
      int v12 = *(_DWORD *)(v10 + 8);
      goto LABEL_4;
    }
    int64x2_t v21 = 0;
    int v22 = 1;
    while (v11 != -4096)
    {
      if (v21) {
        BOOL v23 = 0;
      }
      else {
        BOOL v23 = v11 == -8192;
      }
      if (v23) {
        int64x2_t v21 = (void *)v10;
      }
      unsigned int v24 = v9 + v22++;
      unsigned int v9 = v24 & v8;
      uint64_t v10 = *(void *)&v5 + 16 * v9;
      uint64_t v11 = *(void *)v10;
      if (*(void *)v10 == a2)
      {
        int v12 = *(_DWORD *)(v10 + 8);
        goto LABEL_35;
      }
    }
    if (v21) {
      int v31 = v21;
    }
    else {
      int v31 = (void *)v10;
    }
  }
  else
  {
    int v31 = 0;
  }
  int v32 = sub_1CBFAF8D8((uint64_t)&a1[1], (uint64_t)&v35, &v35, v31);
  int v12 = 0;
  *int v32 = v35;
  *((_DWORD *)v32 + 2) = 0;
  int32x2_t v5 = a1[1];
  __int32 v7 = a1[3].i32[0];
LABEL_35:
  if (!v7)
  {
    size_t v33 = 0;
    goto LABEL_40;
  }
  __int32 v8 = v7 - 1;
LABEL_4:
  unsigned int v13 = v8 & ((a3 >> 4) ^ (a3 >> 9));
  BOOL result = (void *)(*(void *)&v5 + 16 * v13);
  uint64_t v15 = *result;
  if (*result == a3) {
    goto LABEL_5;
  }
  uint64_t v25 = 0;
  int v26 = 1;
  while (v15 != -4096)
  {
    if (v25) {
      BOOL v27 = 0;
    }
    else {
      BOOL v27 = v15 == -8192;
    }
    if (v27) {
      uint64_t v25 = result;
    }
    unsigned int v28 = v13 + v26++;
    unsigned int v13 = v28 & v8;
    BOOL result = (void *)(*(void *)&v5 + 16 * v13);
    uint64_t v15 = *result;
    if (*result == a3) {
      goto LABEL_5;
    }
  }
  if (v25) {
    size_t v33 = v25;
  }
  else {
    size_t v33 = result;
  }
LABEL_40:
  BOOL result = sub_1CBFAF8D8((uint64_t)v6, (uint64_t)&v34, &v34, v33);
  void *result = v34;
  *((_DWORD *)result + 2) = 0;
  int32x2_t v5 = *v6;
LABEL_5:
  *((_DWORD *)result + 2) = v12;
  __int32 v16 = a1[3].i32[0];
  if (v16)
  {
    __int32 v17 = v16 - 1;
    LODWORD(v18) = ((v35 >> 4) ^ (v35 >> 9)) & (v16 - 1);
    int v19 = (uint64_t *)(*(void *)&v5 + 16 * v18);
    uint64_t v20 = *v19;
    if (v35 == *v19)
    {
LABEL_7:
      *int v19 = -8192;
      a1[2] = vadd_s32(a1[2], (int32x2_t)0x1FFFFFFFFLL);
    }
    else
    {
      int v29 = 1;
      while (v20 != -4096)
      {
        int v30 = v18 + v29++;
        uint64_t v18 = v30 & v17;
        uint64_t v20 = *(void *)(*(void *)&v5 + 16 * v18);
        if (v35 == v20)
        {
          int v19 = (uint64_t *)(*(void *)&v5 + 16 * v18);
          goto LABEL_7;
        }
      }
    }
  }
  return result;
}

uint64_t llvm::CallGraphSCCPass::skipSCC(uint64_t a1, uint64_t a2)
{
  uint64_t OptPassGate = llvm::LLVMContextImpl::getOptPassGate(****(llvm::LLVMContextImpl *****)a2);
  if (!(*(unsigned int (**)(uint64_t))(*(void *)OptPassGate + 24))(OptPassGate)) {
    return 0;
  }
  *((unsigned char *)&v18.__r_.__value_.__s + 23) = 5;
  strcpy((char *)&v18, "SCC (");
  __int32 v7 = *(uint64_t **)(a2 + 16);
  __int32 v8 = *(uint64_t **)(a2 + 24);
  if (v7 != v8)
  {
    char v9 = 0;
    do
    {
      uint64_t v10 = *v7;
      if (v9) {
        std::string::size_type v11 = 2;
      }
      else {
        std::string::size_type v11 = 0;
      }
      if (v9) {
        int v12 = ", ";
      }
      else {
        int v12 = 0;
      }
      std::string::append(&v18, v12, v11);
      unsigned int v13 = *(llvm::Value **)(v10 + 8);
      if (v13)
      {
        Name = llvm::Value::getName(v13);
        std::string::append(&v18, Name, v15);
      }
      else
      {
        std::string::append(&v18, "<<null function>>");
      }
      ++v7;
      char v9 = 1;
    }
    while (v7 != v8);
  }
  std::string::append(&v18, ")");
  if ((v18.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    __int32 v16 = &v18;
  }
  else {
    __int32 v16 = (std::string *)v18.__r_.__value_.__r.__words[0];
  }
  if ((v18.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = *((unsigned char *)&v18.__r_.__value_.__s + 23) & 0x7F;
  }
  else {
    std::string::size_type size = v18.__r_.__value_.__l.__size_;
  }
  uint64_t v5 = (*(unsigned int (**)(uint64_t, uint64_t, std::string *, std::string::size_type))(*(void *)OptPassGate
                                                                                               + 16))(OptPassGate, a1, v16, size) ^ 1;
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v18.__r_.__value_.__l.__data_);
  }
  return v5;
}

void sub_1CBFAE698()
{
}

void sub_1CBFAE730(uint64_t a1)
{
  llvm::PMDataManager::~PMDataManager((llvm::PMDataManager *)(a1 + 32));

  llvm::Pass::~Pass((llvm::Pass *)a1);
}

void sub_1CBFAE76C(uint64_t a1)
{
  llvm::PMDataManager::~PMDataManager((llvm::PMDataManager *)(a1 + 32));
  llvm::Pass::~Pass((llvm::Pass *)a1);

  JUMPOUT(0x1D25D9CE0);
}

const char *sub_1CBFAE7BC()
{
  return "CallGraph Pass Manager";
}

void sub_1CBFAE7CC(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
}

uint64_t sub_1CBFAE804(uint64_t a1)
{
  return a1 + 32;
}

void sub_1CBFAE80C(uint64_t a1, int a2)
{
  uint64_t v4 = (llvm::raw_ostream *)llvm::errs((llvm *)a1);
  uint64_t v5 = llvm::raw_ostream::indent(v4, 2 * a2);
  uint64_t v6 = (void *)*((void *)v5 + 4);
  if (*((void *)v5 + 3) - (void)v6 > 0x1BuLL)
  {
    qmemcpy(v6, "Call Graph SCC Pass Manager\n", 28);
    *((void *)v5 + 4) += 28;
  }
  else
  {
    llvm::raw_ostream::write(v5, "Call Graph SCC Pass Manager\n", 0x1CuLL);
  }
  if (*(_DWORD *)(a1 + 56))
  {
    unint64_t v7 = 0;
    uint64_t v8 = (a2 + 1);
    do
    {
      char v9 = *(llvm::Pass **)(*(void *)(a1 + 48) + 8 * v7);
      (*(void (**)(llvm::Pass *, uint64_t))(*(void *)v9 + 128))(v9, v8);
      llvm::PMDataManager::dumpLastUses((llvm::PMDataManager *)(a1 + 32), v9, v8);
      ++v7;
    }
    while (v7 < *(unsigned int *)(a1 + 56));
  }
}

uint64_t sub_1CBFAE8FC(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v97 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(uint64_t **)(a1 + 8);
  uint64_t v3 = *v2;
  uint64_t v4 = v2[1];
  if (v3 == v4)
  {
LABEL_4:
    uint64_t v5 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v3 != &llvm::CallGraphWrapperPass::ID)
    {
      v3 += 16;
      if (v3 == v4) {
        goto LABEL_4;
      }
    }
    uint64_t v5 = *(void *)(v3 + 8);
  }
  size_t v68 = *(llvm::Module ***)((*(uint64_t (**)(uint64_t, void *))(*(void *)v5 + 96))(v5, &llvm::CallGraphWrapperPass::ID)+ 32);
  uint64_t v6 = *(unsigned int *)(v1 + 56);
  if (v6)
  {
    uint64_t v7 = 0;
    int v8 = 0;
    uint64_t v9 = 8 * v6;
    do
    {
      uint64_t v10 = (*(uint64_t (**)(void))(**(void **)(*(void *)(v1 + 48) + v7) + 112))(*(void *)(*(void *)(v1 + 48) + v7));
      if (v10) {
        int v11 = (*(uint64_t (**)(void))(*(void *)(v10 - 32) + 24))();
      }
      else {
        int v11 = (*(uint64_t (**)(void, llvm::Module **))(**(void **)(*(void *)(v1 + 48) + v7) + 136))(*(void *)(*(void *)(v1 + 48) + v7), v68);
      }
      v8 |= v11;
      v7 += 8;
    }
    while (v9 != v7);
  }
  else
  {
    int v8 = 0;
  }
  uint64_t v12 = (uint64_t)v68[10];
  LODWORD(v76) = 0;
  uint64_t v77 = 0;
  uint64_t v78 = 0;
  int v79 = 0;
  *(_OWORD *)uint64_t v80 = 0u;
  *(_OWORD *)uint64_t v81 = 0u;
  long long v82 = 0u;
  *(_OWORD *)uint64_t v83 = 0u;
  uint64_t v84 = 0;
  sub_1CBFAF330((int *)&v76, v12);
  sub_1CBFAF5D8(&v76);
  v72[0] = v68;
  v72[1] = &v76;
  uint64_t v74 = 0;
  uint64_t v75 = 0;
  uint64_t v73 = 0;
  unsigned int v13 = (char *)v81[1];
  uint64_t v14 = (char *)v82;
  if (v81[1] != (void *)v82)
  {
    std::string::size_type v15 = (llvm *)(v1 + 32);
    do
    {
      sub_1CBFAFDE4(&v73, v13, v14, (v14 - v13) >> 3);
      sub_1CBFAF5D8(&v76);
      unsigned int v16 = 0;
      do
      {
        uint64_t v70 = *(unsigned int *)(v1 + 56);
        if (!v70) {
          break;
        }
        unsigned int v65 = v16;
        int v66 = v8;
        uint64_t v17 = 0;
        int v69 = 0;
        int v67 = 0;
        int v71 = 1;
        do
        {
          std::string v18 = *(const void *****)(*(void *)(v1 + 48) + 8 * v17);
          if (dword_1EBD066F8 >= 3)
          {
            std::string __p = 0;
            uint64_t v86 = 0;
            v87[0] = 0;
            llvm::PMDataManager::dumpPassInfo(v15, (uint64_t)v18, 0, 7, &__p, 0);
            if (SHIBYTE(v87[0]) < 0) {
              operator delete(__p);
            }
            if (dword_1EBD066F8 >= 4)
            {
              std::string __p = v87;
              uint64_t v86 = 0x800000000;
              uint64_t v88 = v90;
              uint64_t v89 = 0x200000000;
              size_t v91 = v93;
              uint64_t v92 = 0x200000000;
              uint64_t v94 = &v96;
              uint64_t v95 = 0;
              char v96 = 0;
              ((void (*)(const void ****, void **))(*v18)[10])(v18, &__p);
              llvm::PMDataManager::dumpAnalysisUsage(v15, "Required", 8uLL, (unint64_t)v18, (uint64_t)&__p);
              sub_1CC5F62A0((uint64_t)&__p);
            }
          }
          llvm::PMDataManager::initializeAnalysisImpl((llvm::PMTopLevelManager **)v15, v18);
          if (((uint64_t (*)(const void ****))(*v18)[14])(v18))
          {
            uint64_t v19 = v1;
            uint64_t v20 = (char ***)v73;
            int64x2_t v21 = v74;
            if (v73 == v74)
            {
              uint64_t v1 = v19;
              goto LABEL_64;
            }
            char v22 = 0;
            while (1)
            {
              BOOL v23 = (llvm::Function *)(*v20)[1];
              if (v23) {
                break;
              }
LABEL_42:
              if (++v20 == v21)
              {
                int v41 = v71;
                if ((v22 & 1 & (v71 != 0)) != 0) {
                  int v41 = 0;
                }
                int v71 = v41;
                uint64_t v1 = v19;
                if ((v22 & 1) == 0) {
                  goto LABEL_64;
                }
LABEL_60:
                llvm::PMDataManager::dumpPassInfo(v15, (uint64_t)v18, 1, 7, "", 0);
                if (dword_1EBD066F8 >= 4)
                {
                  std::string __p = v87;
                  uint64_t v86 = 0x800000000;
                  uint64_t v88 = v90;
                  uint64_t v89 = 0x200000000;
                  size_t v91 = v93;
                  uint64_t v92 = 0x200000000;
                  uint64_t v94 = &v96;
                  uint64_t v95 = 0;
                  char v96 = 0;
                  ((void (*)(const void ****, void **))(*v18)[10])(v18, &__p);
                  llvm::PMDataManager::dumpAnalysisUsage(v15, "Preserved", 9uLL, (unint64_t)v18, (uint64_t)&v91);
                  sub_1CC5F62A0((uint64_t)&__p);
                }
                llvm::PMDataManager::removeNotPreservedAnalysis(v15, (llvm::Pass *)v18);
                int v69 = 1;
                goto LABEL_66;
              }
            }
            if ((*((unsigned char *)v23 + 23) & 0x10) != 0)
            {
              uint64_t v24 = ***(void ***)v23;
              uint64_t v25 = *(void *)(v24 + 152);
              uint64_t v26 = *(unsigned int *)(v24 + 168);
              if (!v26) {
                goto LABEL_35;
              }
              LODWORD(v27) = (v26 - 1) & ((v23 >> 4) ^ (v23 >> 9));
              unsigned int v28 = (llvm::Function **)(v25 + 16 * v27);
              int v29 = *v28;
              if (*v28 != v23)
              {
                int v30 = 1;
                while (v29 != (llvm::Function *)-4096)
                {
                  int v31 = v27 + v30++;
                  uint64_t v27 = v31 & (v26 - 1);
                  int v29 = *(llvm::Function **)(v25 + 16 * v27);
                  if (v29 == v23)
                  {
                    unsigned int v28 = (llvm::Function **)(v25 + 16 * v27);
                    goto LABEL_36;
                  }
                }
LABEL_35:
                unsigned int v28 = (llvm::Function **)(v25 + 16 * v26);
              }
LABEL_36:
              int v32 = v28[1];
              size_t v35 = *(void *)v32;
              size_t v33 = (char *)v32 + 16;
              size_t v34 = v35;
            }
            else
            {
              size_t v34 = 0;
              size_t v33 = &byte_1CFBCE98E;
            }
            llvm::PMDataManager::dumpPassInfo(v15, (uint64_t)v18, 0, 3, v33, v34);
            PassTimer = (llvm::Timer *)llvm::getPassTimer((llvm *)v18, v36);
            if (PassTimer)
            {
              uint64_t v38 = PassTimer;
              llvm::Timer::startTimer(PassTimer);
              char v39 = llvm::FPPassManager::runOnFunction((llvm::FPPassManager *)v18, v23);
              llvm::Timer::stopTimer(v38);
            }
            else
            {
              char v39 = llvm::FPPassManager::runOnFunction((llvm::FPPassManager *)v18, v23);
            }
            v22 |= v39;
            uint64_t v40 = *(void (**)(void))(***(void ***)v23 + 136);
            if (v40) {
              v40();
            }
            goto LABEL_42;
          }
          uint64_t v42 = *v68;
          if (!(_BYTE)v71) {
            v67 |= sub_1CBFAFF24((char ***)v73, v74, (llvm::CallGraph *)v68);
          }
          std::string __p = 0;
          uint64_t v86 = 0;
          v87[0] = 0x1000000000;
          int v43 = (*(uint64_t (**)(void, const char *, uint64_t))(**(void **)(**(void **)v42 + 72) + 24))(*(void *)(**(void **)v42 + 72), "size-info", 9);
          size_t v45 = (llvm::Timer *)llvm::getPassTimer((llvm *)v18, v44);
          int v47 = v45;
          if (v45) {
            v46.n128_f64[0] = llvm::Timer::startTimer(v45);
          }
          if (v43) {
            unsigned int inited = llvm::PMDataManager::initSizeRemarkInfo((uint64_t)v15, (uint64_t)v42, (uint64_t)&__p);
          }
          else {
            unsigned int inited = 0;
          }
          char v49 = ((uint64_t (*)(const void ****, void *, __n128))(*v18)[18])(v18, v72, v46);
          if (v43)
          {
            unsigned int InstructionCount = llvm::Module::getInstructionCount(v42);
            if (InstructionCount != inited) {
              llvm::PMDataManager::emitInstrCountChangedRemark((uint64_t)v15, (uint64_t)v18, (uint64_t)v42, InstructionCount - (unint64_t)inited, inited, (uint64_t)&__p, 0);
            }
          }
          if (v47) {
            llvm::Timer::stopTimer(v47);
          }
          if (HIDWORD(v86) && v86)
          {
            uint64_t v51 = 0;
            uint64_t v52 = 8 * v86;
            do
            {
              uint64_t v53 = *(void *)((char *)__p + v51);
              if (v53 != -8 && v53 != 0) {
                MEMORY[0x1D25D9CD0]();
              }
              v51 += 8;
            }
            while (v52 != v51);
          }
          free(__p);
          int v71 = 1;
          if (v49) {
            goto LABEL_60;
          }
LABEL_64:
          if (dword_1EBD066F8 >= 4)
          {
            std::string __p = v87;
            uint64_t v86 = 0x800000000;
            uint64_t v88 = v90;
            uint64_t v89 = 0x200000000;
            size_t v91 = v93;
            uint64_t v92 = 0x200000000;
            uint64_t v94 = &v96;
            uint64_t v95 = 0;
            char v96 = 0;
            ((void (*)(const void ****, void **))(*v18)[10])(v18, &__p);
            llvm::PMDataManager::dumpAnalysisUsage(v15, "Preserved", 9uLL, (unint64_t)v18, (uint64_t)&v91);
            sub_1CC5F62A0((uint64_t)&__p);
          }
LABEL_66:
          llvm::PMDataManager::recordAvailableAnalysis(v15, (llvm::Pass *)v18);
          llvm::PMDataManager::removeDeadPasses((int32x2_t *)v15, (uint64_t)v18, "", 0, 7);
          ++v17;
        }
        while (v17 != v70);
        if ((_BYTE)v71)
        {
          unsigned int v55 = v65;
          int v56 = v66;
          char v57 = v67;
        }
        else
        {
          int v56 = v66;
          char v57 = v67 | sub_1CBFAFF24((char ***)v73, v74, (llvm::CallGraph *)v68);
          unsigned int v55 = v65;
        }
        int v8 = v56 | v69;
        if (v55 >= dword_1EBD03148) {
          break;
        }
        unsigned int v16 = v55 + 1;
      }
      while (v57);
      unsigned int v13 = (char *)v81[1];
      uint64_t v14 = (char *)v82;
    }
    while (v81[1] != (void *)v82);
  }
  uint64_t v58 = *(unsigned int *)(v1 + 56);
  if (v58)
  {
    uint64_t v59 = 0;
    int v60 = 0;
    uint64_t v61 = 8 * v58;
    do
    {
      uint64_t v62 = (*(uint64_t (**)(void))(**(void **)(*(void *)(v1 + 48) + v59) + 112))(*(void *)(*(void *)(v1 + 48) + v59));
      if (v62) {
        int v63 = (*(uint64_t (**)(void))(*(void *)(v62 - 32) + 32))();
      }
      else {
        int v63 = (*(uint64_t (**)(void, llvm::Module **))(**(void **)(*(void *)(v1 + 48) + v59) + 152))(*(void *)(*(void *)(v1 + 48) + v59), v68);
      }
      v60 |= v63;
      v59 += 8;
    }
    while (v61 != v59);
  }
  else
  {
    int v60 = 0;
  }
  if (v73)
  {
    uint64_t v74 = (char ***)v73;
    operator delete(v73);
  }
  if (v83[0])
  {
    v83[1] = v83[0];
    operator delete(v83[0]);
  }
  if (v81[1])
  {
    *(void **)&long long v82 = v81[1];
    operator delete(v81[1]);
  }
  if (v80[0])
  {
    v80[1] = v80[0];
    operator delete(v80[0]);
  }
  MEMORY[0x1D25D9CD0](v77, 8);
  return (v8 | v60) & 1;
}

uint64_t sub_1CBFAF294()
{
  return 2;
}

void sub_1CBFAF29C(llvm::PMDataManager *a1)
{
  uint64_t v1 = (llvm::PMDataManager *)((char *)a1 - 32);
  llvm::PMDataManager::~PMDataManager(a1);

  llvm::Pass::~Pass(v1);
}

void sub_1CBFAF2D4(llvm::PMDataManager *a1)
{
  uint64_t v1 = (llvm::PMDataManager *)((char *)a1 - 32);
  llvm::PMDataManager::~PMDataManager(a1);
  llvm::Pass::~Pass(v1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CBFAF320(uint64_t a1)
{
  return a1 - 32;
}

uint64_t sub_1CBFAF328()
{
  return 2;
}

void sub_1CBFAF330(int *a1, uint64_t a2)
{
  uint64_t v42 = a2;
  int v3 = *a1 + 1;
  *a1 = v3;
  uint64_t v6 = *((void *)a1 + 1);
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  int v7 = a1[6];
  if (v7)
  {
    int v8 = v7 - 1;
    unsigned int v9 = (v7 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v10 = (void *)(v5 + 16 * v9);
    uint64_t v11 = *v10;
    if (*v10 == a2) {
      goto LABEL_3;
    }
    uint64_t v37 = 0;
    int v38 = 1;
    while (v11 != -4096)
    {
      if (v37) {
        BOOL v39 = 0;
      }
      else {
        BOOL v39 = v11 == -8192;
      }
      if (v39) {
        uint64_t v37 = v10;
      }
      unsigned int v40 = v9 + v38++;
      unsigned int v9 = v40 & v8;
      uint64_t v10 = (void *)(v5 + 16 * (v40 & v8));
      uint64_t v11 = *v10;
      if (*v10 == a2) {
        goto LABEL_3;
      }
    }
    if (v37) {
      int v41 = v37;
    }
    else {
      int v41 = v10;
    }
  }
  else
  {
    int v41 = 0;
  }
  uint64_t v10 = sub_1CBFAF8D8(v4, (uint64_t)&v42, &v42, v41);
  *uint64_t v10 = v42;
  *((_DWORD *)v10 + 2) = 0;
LABEL_3:
  *((_DWORD *)v10 + 2) = v3;
  unsigned int v13 = (void *)*((void *)a1 + 5);
  unint64_t v12 = *((void *)a1 + 6);
  if ((unint64_t)v13 < v12)
  {
    *unsigned int v13 = v42;
    int64x2_t v21 = v13 + 1;
  }
  else
  {
    uint64_t v14 = (void *)*((void *)a1 + 4);
    uint64_t v15 = v13 - v14;
    unint64_t v16 = v15 + 1;
    if ((unint64_t)(v15 + 1) >> 61) {
      goto LABEL_51;
    }
    uint64_t v17 = v12 - (void)v14;
    if (v17 >> 2 > v16) {
      unint64_t v16 = v17 >> 2;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v16;
    }
    if (v18)
    {
      if (v18 >> 61) {
        goto LABEL_52;
      }
      uint64_t v19 = (char *)operator new(8 * v18);
    }
    else
    {
      uint64_t v19 = 0;
    }
    uint64_t v20 = &v19[8 * v15];
    *(void *)uint64_t v20 = v42;
    int64x2_t v21 = v20 + 8;
    if (v13 != v14)
    {
      do
      {
        uint64_t v22 = *--v13;
        *((void *)v20 - 1) = v22;
        v20 -= 8;
      }
      while (v13 != v14);
      unsigned int v13 = (void *)*((void *)a1 + 4);
    }
    *((void *)a1 + 4) = v20;
    *((void *)a1 + 5) = v21;
    *((void *)a1 + 6) = &v19[8 * v18];
    if (v13) {
      operator delete(v13);
    }
  }
  *((void *)a1 + 5) = v21;
  uint64_t v23 = v42;
  uint64_t v24 = *(void *)(v42 + 16);
  int v25 = *a1;
  uint64_t v27 = (char *)*((void *)a1 + 11);
  unint64_t v26 = *((void *)a1 + 12);
  if ((unint64_t)v27 < v26)
  {
    *(void *)uint64_t v27 = v42;
    *((void *)v27 + 1) = v24;
    *((void *)v27 + 2) = sub_1CBFAFBB4;
    *((_DWORD *)v27 + 6) = v25;
    unsigned int v28 = v27 + 32;
    goto LABEL_20;
  }
  int v29 = (unsigned char *)*((void *)a1 + 10);
  uint64_t v30 = (v27 - v29) >> 5;
  unint64_t v31 = v30 + 1;
  if ((unint64_t)(v30 + 1) >> 59) {
LABEL_51:
  }
    abort();
  uint64_t v32 = v26 - (void)v29;
  if (v32 >> 4 > v31) {
    unint64_t v31 = v32 >> 4;
  }
  if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v33 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v33 = v31;
  }
  if (!v33)
  {
    size_t v34 = 0;
    goto LABEL_30;
  }
  if (v33 >> 59) {
LABEL_52:
  }
    sub_1CB833614();
  size_t v34 = (char *)operator new(32 * v33);
LABEL_30:
  size_t v35 = &v34[32 * v30];
  *(void *)size_t v35 = v23;
  *((void *)v35 + 1) = v24;
  *((void *)v35 + 2) = sub_1CBFAFBB4;
  *((_DWORD *)v35 + 6) = v25;
  unsigned int v28 = v35 + 32;
  if (v27 != v29)
  {
    do
    {
      long long v36 = *((_OWORD *)v27 - 2);
      *(_OWORD *)(v35 - 20) = *(_OWORD *)(v27 - 20);
      *((_OWORD *)v35 - 2) = v36;
      v35 -= 32;
      v27 -= 32;
    }
    while (v27 != v29);
    uint64_t v27 = (char *)*((void *)a1 + 10);
  }
  *((void *)a1 + 10) = v35;
  *((void *)a1 + 11) = v28;
  *((void *)a1 + 12) = &v34[32 * v33];
  if (v27) {
    operator delete(v27);
  }
LABEL_20:
  *((void *)a1 + 11) = v28;
}

void *sub_1CBFAF5D8(void *result)
{
  result[8] = result[7];
  if (result[10] != result[11])
  {
    uint64_t v1 = (uint64_t)result;
    uint64_t v2 = (uint64_t)(result + 1);
    do
    {
      sub_1CBFAFBBC(v1);
      uint64_t v41 = 0;
      uint64_t v4 = *(void *)(v1 + 80);
      uint64_t v3 = *(void *)(v1 + 88);
      uint64_t v5 = *(void *)(v3 - 32);
      uint64_t v41 = v5;
      unsigned int v6 = *(_DWORD *)(v3 - 8);
      *(void *)(v1 + 88) = v3 - 32;
      if (v4 != v3 - 32 && *(_DWORD *)(v3 - 40) > v6) {
        *(_DWORD *)(v3 - 40) = v6;
      }
      int v7 = *(_DWORD *)(v1 + 24);
      if (v7)
      {
        uint64_t v8 = *(void *)(v1 + 8);
        int v9 = v7 - 1;
        unsigned int v10 = v9 & ((v5 >> 4) ^ (v5 >> 9));
        BOOL result = (void *)(v8 + 16 * v10);
        uint64_t v11 = *result;
        if (v5 == *result) {
          goto LABEL_8;
        }
        unint64_t v12 = 0;
        int v13 = 1;
        while (v11 != -4096)
        {
          if (v12) {
            BOOL v14 = 0;
          }
          else {
            BOOL v14 = v11 == -8192;
          }
          if (v14) {
            unint64_t v12 = result;
          }
          unsigned int v15 = v10 + v13++;
          unsigned int v10 = v15 & v9;
          BOOL result = (void *)(v8 + 16 * v10);
          uint64_t v11 = *result;
          if (v5 == *result) {
            goto LABEL_8;
          }
        }
        if (v12) {
          unint64_t v16 = v12;
        }
        else {
          unint64_t v16 = result;
        }
      }
      else
      {
        unint64_t v16 = 0;
      }
      BOOL result = sub_1CBFAF8D8(v2, (uint64_t)&v41, &v41, v16);
      void *result = v41;
      *((_DWORD *)result + 2) = 0;
LABEL_8:
      if (v6 == *((_DWORD *)result + 2))
      {
        uint64_t v17 = *(void **)(v1 + 64);
        while (1)
        {
          uint64_t v18 = *(void *)(v1 + 40);
          unint64_t v19 = *(void *)(v1 + 72);
          if ((unint64_t)v17 >= v19)
          {
            size_t v35 = *(void **)(v1 + 56);
            uint64_t v36 = v17 - v35;
            unint64_t v37 = v36 + 1;
            if ((unint64_t)(v36 + 1) >> 61) {
              abort();
            }
            uint64_t v38 = v19 - (void)v35;
            if (v38 >> 2 > v37) {
              unint64_t v37 = v38 >> 2;
            }
            unint64_t v39 = (unint64_t)v38 >= 0x7FFFFFFFFFFFFFF8 ? 0x1FFFFFFFFFFFFFFFLL : v37;
            if (v39)
            {
              if (v39 >> 61) {
                sub_1CB833614();
              }
              unsigned int v40 = (char *)operator new(8 * v39);
            }
            else
            {
              unsigned int v40 = 0;
            }
            int v29 = &v40[8 * v36];
            *(void *)int v29 = *(void *)(v18 - 8);
            uint64_t v20 = v29 + 8;
            if (v17 != v35)
            {
              do
              {
                uint64_t v28 = *--v17;
                *((void *)v29 - 1) = v28;
                v29 -= 8;
              }
              while (v17 != v35);
              uint64_t v17 = *(void **)(v1 + 56);
            }
            *(void *)(v1 + 56) = v29;
            *(void *)(v1 + 64) = v20;
            *(void *)(v1 + 72) = &v40[8 * v39];
            if (v17) {
              operator delete(v17);
            }
          }
          else
          {
            void *v17 = *(void *)(v18 - 8);
            uint64_t v20 = v17 + 1;
          }
          *(void *)(v1 + 64) = v20;
          *(void *)(v1 + 40) -= 8;
          int64x2_t v21 = v20 - 1;
          int v22 = *(_DWORD *)(v1 + 24);
          if (!v22) {
            break;
          }
          uint64_t v23 = *(void *)(v1 + 8);
          uint64_t v24 = *v21;
          int v25 = v22 - 1;
          unsigned int v26 = ((*v21 >> 4) ^ (*v21 >> 9)) & v25;
          BOOL result = (void *)(v23 + 16 * v26);
          uint64_t v27 = *result;
          if (*v21 != *result)
          {
            uint64_t v30 = 0;
            int v31 = 1;
            while (v27 != -4096)
            {
              if (v30) {
                BOOL v32 = 0;
              }
              else {
                BOOL v32 = v27 == -8192;
              }
              if (v32) {
                uint64_t v30 = result;
              }
              unsigned int v33 = v26 + v31++;
              unsigned int v26 = v33 & v25;
              BOOL result = (void *)(v23 + 16 * v26);
              uint64_t v27 = *result;
              if (v24 == *result) {
                goto LABEL_28;
              }
            }
            if (v30) {
              size_t v34 = v30;
            }
            else {
              size_t v34 = result;
            }
            goto LABEL_44;
          }
LABEL_28:
          *((_DWORD *)result + 2) = -1;
          uint64_t v17 = v20;
          if (v24 == v41) {
            return result;
          }
        }
        size_t v34 = 0;
LABEL_44:
        BOOL result = sub_1CBFAF8D8(v2, (uint64_t)(v20 - 1), v20 - 1, v34);
        void *result = *v21;
        *((_DWORD *)result + 2) = 0;
        uint64_t v20 = *(void **)(v1 + 64);
        uint64_t v24 = *(v20 - 1);
        goto LABEL_28;
      }
    }
    while (*(void *)(v1 + 80) != *(void *)(v1 + 88));
  }
  return result;
}

void *sub_1CBFAF8D8(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 < 3 * v7)
  {
    if (v7 + ~v6 - *(_DWORD *)(a1 + 12) <= v7 >> 3)
    {
      sub_1CBFAFA0C(a1, v7);
      uint64_t v17 = 0;
      sub_1CB915048((uint64_t *)a1, a3, &v17);
      a4 = v17;
    }
LABEL_4:
    uint64_t v8 = *a4;
    goto LABEL_5;
  }
  sub_1CBFAFA0C(a1, 2 * v7);
  uint64_t v8 = *a3;
  int v10 = *(_DWORD *)(a1 + 16) - 1;
  unsigned int v11 = ((*a3 >> 4) ^ (*a3 >> 9)) & v10;
  a4 = (void *)(*(void *)a1 + 16 * v11);
  uint64_t v12 = *a4;
  if (*a3 != *a4)
  {
    int v13 = 0;
    int v14 = 1;
    while (v12 != -4096)
    {
      if (v13) {
        BOOL v15 = 0;
      }
      else {
        BOOL v15 = v12 == -8192;
      }
      if (v15) {
        int v13 = a4;
      }
      unsigned int v16 = v11 + v14++;
      unsigned int v11 = v16 & v10;
      a4 = (void *)(*(void *)a1 + 16 * v11);
      uint64_t v12 = *a4;
      if (v8 == *a4) {
        goto LABEL_5;
      }
    }
    if (v13) {
      a4 = v13;
    }
    goto LABEL_4;
  }
LABEL_5:
  ++*(_DWORD *)(a1 + 8);
  if (v8 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CBFAFA0C(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  BOOL result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CBFAFAD8(a1, v4, &v4[2 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      void *result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CBFAFAD8(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  *(void *)(result + 8) = 0;
  uint64_t v3 = *(unsigned int *)(result + 16);
  if (v3)
  {
    uint64_t v4 = *(void **)result;
    uint64_t v5 = 16 * v3;
    do
    {
      *uint64_t v4 = -4096;
      v4 += 2;
      v5 -= 16;
    }
    while (v5);
  }
  for (; a2 != a3; a2 += 2)
  {
    uint64_t v6 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      int v7 = *(_DWORD *)(result + 16) - 1;
      unsigned int v8 = v7 & ((v6 >> 4) ^ (v6 >> 9));
      uint64_t v9 = *(void *)result + 16 * v8;
      uint64_t v10 = *(void *)v9;
      if (v6 != *(void *)v9)
      {
        uint64_t v11 = 0;
        int v12 = 1;
        while (v10 != -4096)
        {
          if (v11) {
            BOOL v13 = 0;
          }
          else {
            BOOL v13 = v10 == -8192;
          }
          if (v13) {
            uint64_t v11 = v9;
          }
          unsigned int v14 = v8 + v12++;
          unsigned int v8 = v14 & v7;
          uint64_t v9 = *(void *)result + 16 * (v14 & v7);
          uint64_t v10 = *(void *)v9;
          if (v6 == *(void *)v9) {
            goto LABEL_7;
          }
        }
        if (v11) {
          uint64_t v9 = v11;
        }
      }
LABEL_7:
      *(void *)uint64_t v9 = v6;
      *(_DWORD *)(v9 + 8) = *((_DWORD *)a2 + 2);
      ++*(_DWORD *)(result + 8);
    }
  }
  return result;
}

uint64_t sub_1CBFAFBB4(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

void sub_1CBFAFBBC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 88);
  uint64_t v2 = *(void *)(v1 - 24);
  if (v2 != *(void *)(*(void *)(v1 - 32) + 24))
  {
    while (1)
    {
      uint64_t v4 = *(uint64_t (**)(uint64_t *))(v1 - 16);
      *(void *)(v1 - 24) = v2 + 40;
      LOBYTE(v26) = 0;
      char v29 = 0;
      if (*(unsigned char *)(v2 + 24)) {
        sub_1CBFA9590((llvm::ValueHandleBase *)&v26, (void *)v2);
      }
      uint64_t v30 = *(void *)(v2 + 32);
      uint64_t v5 = v4(&v26);
      if (v29 && v28 != (int32x2_t ****)-8192 && v28 != (int32x2_t ****)-4096 && v28 != 0)
      {
        unint64_t v14 = v26 & 0xFFFFFFFFFFFFFFF8;
        *(void *)(v26 & 0xFFFFFFFFFFFFFFF8) = v27;
        if (v27)
        {
          *uint64_t v27 = *v27 & 7 | v14;
        }
        else
        {
          BOOL v15 = v28;
          unsigned int v16 = ***v28;
          unint64_t v17 = (unint64_t)v16[303];
          if (v17 <= v14)
          {
            uint64_t v18 = v16[305].u32[0];
            if (v17 + 16 * v18 > v14)
            {
              unsigned int v19 = v18 - 1;
              LODWORD(v20) = v19 & ((v28 >> 4) ^ (v28 >> 9));
              int64x2_t v21 = (int32x2_t *****)(v17 + 16 * v20);
              int v22 = *v21;
              if (v28 == *v21)
              {
LABEL_30:
                *int64x2_t v21 = (int32x2_t ****)-8192;
                v16[304] = vadd_s32(v16[304], (int32x2_t)0x1FFFFFFFFLL);
                BOOL v15 = v28;
              }
              else
              {
                int v23 = 1;
                while (v22 != (int32x2_t ****)-4096)
                {
                  int v24 = v20 + v23++;
                  uint64_t v20 = v24 & v19;
                  int v22 = *(int32x2_t *****)(v17 + 16 * v20);
                  if (v28 == v22)
                  {
                    int64x2_t v21 = (int32x2_t *****)(v17 + 16 * v20);
                    goto LABEL_30;
                  }
                }
              }
              *((unsigned char *)v15 + 17) &= ~1u;
            }
          }
        }
      }
      uint64_t v6 = *(void *)(a1 + 8);
      uint64_t v7 = *(unsigned int *)(a1 + 24);
      if (!v7) {
        goto LABEL_12;
      }
      LODWORD(v8) = (v7 - 1) & ((v5 >> 4) ^ (v5 >> 9));
      uint64_t v9 = (uint64_t *)(v6 + 16 * v8);
      uint64_t v10 = *v9;
      if (v5 != *v9) {
        break;
      }
LABEL_13:
      if (v9 == (uint64_t *)(v6 + 16 * v7))
      {
        sub_1CBFAF330((int *)a1, v5);
        uint64_t v1 = *(void *)(a1 + 88);
      }
      else
      {
        unsigned int v25 = *((_DWORD *)v9 + 2);
        uint64_t v1 = *(void *)(a1 + 88);
        if (*(_DWORD *)(v1 - 8) > v25) {
          *(_DWORD *)(v1 - 8) = v25;
        }
      }
      uint64_t v2 = *(void *)(v1 - 24);
      if (v2 == *(void *)(*(void *)(v1 - 32) + 24)) {
        return;
      }
    }
    int v11 = 1;
    while (v10 != -4096)
    {
      int v12 = v8 + v11++;
      uint64_t v8 = v12 & (v7 - 1);
      uint64_t v10 = *(void *)(v6 + 16 * v8);
      if (v5 == v10)
      {
        uint64_t v9 = (uint64_t *)(v6 + 16 * v8);
        goto LABEL_13;
      }
    }
LABEL_12:
    uint64_t v9 = (uint64_t *)(v6 + 16 * v7);
    goto LABEL_13;
  }
}

void *sub_1CBFAFDE4(void *result, char *__src, char *a3, unint64_t a4)
{
  uint64_t v6 = __src;
  uint64_t v7 = result;
  uint64_t v8 = result[2];
  uint64_t v9 = (char *)*result;
  if (a4 > (v8 - *result) >> 3)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *uint64_t v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 61) {
      goto LABEL_23;
    }
    uint64_t v10 = v8 >> 2;
    if (v8 >> 2 <= a4) {
      uint64_t v10 = a4;
    }
    unint64_t v11 = (unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8 ? 0x1FFFFFFFFFFFFFFFLL : v10;
    if (v11 >> 61) {
LABEL_23:
    }
      abort();
    BOOL result = operator new(8 * v11);
    uint64_t v9 = (char *)result;
    *uint64_t v7 = result;
    v7[1] = result;
    v7[2] = &result[v11];
    size_t v12 = a3 - v6;
    if (v12) {
      BOOL result = memcpy(result, v6, v12);
    }
    BOOL v13 = (void **)(v7 + 1);
    goto LABEL_22;
  }
  BOOL v13 = (void **)(result + 1);
  unint64_t v14 = (unsigned char *)result[1];
  unint64_t v15 = (v14 - v9) >> 3;
  if (v15 >= a4)
  {
    size_t v12 = a3 - __src;
    if (a3 == __src) {
      goto LABEL_22;
    }
    unint64_t v17 = (void *)*result;
LABEL_21:
    BOOL result = memmove(v17, __src, v12);
    goto LABEL_22;
  }
  unsigned int v16 = &__src[8 * v15];
  if (v14 != v9)
  {
    BOOL result = memmove((void *)*result, __src, v14 - v9);
    uint64_t v9 = (char *)*v13;
  }
  size_t v12 = a3 - v16;
  if (v12)
  {
    unint64_t v17 = v9;
    __src = v16;
    goto LABEL_21;
  }
LABEL_22:
  *BOOL v13 = &v9[v12];
  return result;
}

uint64_t sub_1CBFAFF24(char ***a1, char ***a2, llvm::CallGraph *a3)
{
  v100[4] = *MEMORY[0x1E4F143B8];
  uint64_t v90 = 0;
  int32x2_t v91 = 0;
  unsigned int v92 = 0;
  if (a1 == a2)
  {
    uint64_t v77 = 0;
    LOBYTE(v3) = 0;
    goto LABEL_142;
  }
  int v3 = 0;
  int v4 = 0;
  uint64_t v5 = (const llvm::Use **)v100;
  int v79 = a2;
  do
  {
    uint64_t v6 = *a1;
    uint64_t v7 = (*a1)[1];
    if (!v7) {
      goto LABEL_139;
    }
    if (v7[16])
    {
      if (v7[16] == 3 && (*((_DWORD *)v7 + 5) & 0x7FFFFFF) == 0) {
        goto LABEL_139;
      }
    }
    else if (*((char **)v7 + 9) == v7 + 72 && (v7[34] & 0x80) == 0)
    {
      goto LABEL_139;
    }
    int v80 = v4;
    uint64_t v81 = a1;
    int v84 = v3;
    uint64_t v8 = v6[2];
    uint64_t v88 = v6 + 2;
    uint64_t v9 = v6[3];
    if (v8 != v9)
    {
      unsigned int v82 = 0;
      unsigned int v83 = 0;
      while (1)
      {
        uint64_t v10 = v8 + 40;
        while (!v8[24])
        {
          --*(_DWORD *)(*((void *)v8 + 4) + 40);
          unint64_t v11 = v6[3];
          sub_1CBFA9984((llvm::ValueHandleBase *)v8, (uint64_t *)v11 - 5);
          *((void *)v8 + 4) = *((void *)v11 - 1);
          sub_1CBFA986C((uint64_t)v88, (uint64_t)(v6[3] - 40));
          if (v10 != v9)
          {
            uint64_t v9 = v6[3];
            if (v8 != v9) {
              continue;
            }
          }
          goto LABEL_59;
        }
        uint64_t v12 = *((void *)v8 + 2);
        if (!v12) {
          break;
        }
        unsigned int v13 = *(unsigned __int8 *)(v12 + 16);
        if (v13 < 0x1C) {
          break;
        }
        unsigned int v14 = v13 - 33;
        BOOL v15 = v14 > 0x33;
        uint64_t v16 = (1 << v14) & 0x8000000000041;
        if (v15 || v16 == 0) {
          break;
        }
        unsigned int v18 = v92;
        if (v92)
        {
          unsigned int v19 = (v92 - 1) & ((v12 >> 4) ^ (v12 >> 9));
          uint64_t v20 = *(void *)(v90 + 16 * v19);
          if (v12 == v20) {
            break;
          }
          int v25 = 1;
          while (v20 != -4096)
          {
            unsigned int v26 = v19 + v25++;
            unsigned int v19 = v26 & (v92 - 1);
            uint64_t v20 = *(void *)(v90 + 16 * v19);
            if (v12 == v20) {
              goto LABEL_25;
            }
          }
        }
        uint64_t v27 = *(void *)(v12 - 32);
        if (v27 && !*(unsigned char *)(v27 + 16) && *(void *)(v27 + 24) == *(void *)(v12 + 72))
        {
          if ((*(unsigned char *)(v27 + 33) & 0x20) != 0)
          {
            unsigned int v31 = *(_DWORD *)(v27 + 36) - 124;
            BOOL v15 = v31 > 4;
            int v32 = (1 << v31) & 0x19;
            if (v15 || v32 == 0) {
              break;
            }
          }
          if ((*(unsigned char *)(v27 + 33) & 0x20) != 0) {
            goto LABEL_32;
          }
        }
        uint64_t v28 = *((void *)v8 + 4);
        uint64_t v98 = 0;
        if ((sub_1CBF8BDAC(v90, v92, v12, &v98) & 1) == 0)
        {
          if (4 * v91.i32[0] + 4 >= 3 * v18)
          {
            int v29 = 2 * v18;
LABEL_46:
            sub_1CBFB070C((uint64_t)&v90, v29);
            uint64_t v98 = 0;
            sub_1CBF8BDAC(v90, v92, v12, &v98);
          }
          else if (v18 + ~v91.i32[0] - v91.i32[1] <= v18 >> 3)
          {
            int v29 = v18;
            goto LABEL_46;
          }
          uint64_t v30 = v98;
          ++v91.i32[0];
          if (*v98 != -4096) {
            --v91.i32[1];
          }
          uint64_t *v98 = v12;
          v30[1] = v28;
        }
LABEL_32:
        uint64_t v8 = v10;
        if (v10 == v9) {
          goto LABEL_59;
        }
      }
LABEL_25:
      uint64_t v21 = *((void *)v8 + 4);
      if (*(void *)(v21 + 8)) {
        unsigned int v22 = v82;
      }
      else {
        unsigned int v22 = v82 + 1;
      }
      unsigned int v23 = v83;
      if (*(void *)(v21 + 8)) {
        unsigned int v23 = v83 + 1;
      }
      unsigned int v82 = v22;
      unsigned int v83 = v23;
      --*(_DWORD *)(v21 + 40);
      int v24 = v6[3];
      sub_1CBFA9984((llvm::ValueHandleBase *)v8, (uint64_t *)v24 - 5);
      *((void *)v8 + 4) = *((void *)v24 - 1);
      sub_1CBFA986C((uint64_t)v88, (uint64_t)(v6[3] - 40));
      if (v10 == v9) {
        goto LABEL_59;
      }
      uint64_t v9 = v6[3];
      uint64_t v10 = v8;
      goto LABEL_32;
    }
    unsigned int v82 = 0;
    unsigned int v83 = 0;
LABEL_59:
    size_t v34 = (char *)*((void *)v7 + 10);
    uint64_t v85 = v7 + 72;
    if (v34 == v7 + 72)
    {
      unsigned int v86 = 0;
      unsigned int v35 = 0;
      goto LABEL_130;
    }
    unsigned int v35 = 0;
    unsigned int v86 = 0;
    do
    {
      uint64_t v36 = v34 - 24;
      int v87 = v34;
      if (!v34) {
        uint64_t v36 = 0;
      }
      unint64_t v37 = v36 + 40;
      for (uint64_t i = *((void *)v36 + 6); (char *)i != v37; uint64_t i = *(void *)(i + 8))
      {
        uint64_t v39 = i - 24;
        if (i) {
          uint64_t v40 = i - 24;
        }
        else {
          uint64_t v40 = 0;
        }
        unsigned int v41 = *(unsigned __int8 *)(v40 + 16) - 33;
        BOOL v15 = v41 > 0x33;
        uint64_t v42 = (1 << v41) & 0x8000000000041;
        if (v15 || v42 == 0) {
          continue;
        }
        uint64_t v44 = *(void *)(i - 56);
        if (v44)
        {
          if (!*(unsigned char *)(v44 + 16)
            && *(void *)(v44 + 24) == *(void *)(i + 48)
            && (*(unsigned char *)(v44 + 33) & 0x20) != 0)
          {
            continue;
          }
        }
        size_t v45 = v5;
        uint64_t v98 = (uint64_t *)v5;
        uint64_t v99 = 0x400000000;
        llvm::AbstractCallSite::getCallbackUses((uint64_t ****)(i - 24), (uint64_t)&v98);
        __n128 v46 = (const llvm::Use **)v98;
        int v47 = (const llvm::Use **)&v98[v99];
        if (v99)
        {
          do
          {
            llvm::AbstractCallSite::AbstractCallSite((llvm::AbstractCallSite *)&v93, *v46);
            int v48 = sub_1CD46F814(&v93);
            if (v48)
            {
              inserted = llvm::CallGraph::getOrInsertFunction(a3, v48);
              uint64_t v97 = inserted;
              long long v95 = 0u;
              long long v96 = 0u;
              size_t v50 = v6[3];
              if (v50 >= v6[4])
              {
                uint64_t v52 = sub_1CBFA9300(v88, (uint64_t)&v95, &v97);
              }
              else
              {
                uint64_t v51 = inserted;
                *size_t v50 = 0;
                v50[24] = 0;
                if (BYTE8(v96)) {
                  sub_1CBFA9590((llvm::ValueHandleBase *)v50, &v95);
                }
                *((void *)v50 + 4) = v51;
                uint64_t v52 = v50 + 40;
              }
              v6[3] = v52;
              if (BYTE8(v96) && (void)v96 != -8192 && (void)v96 != -4096 && (void)v96)
              {
                unint64_t v53 = v95 & 0xFFFFFFFFFFFFFFF8;
                *(void *)(v95 & 0xFFFFFFFFFFFFFFF8) = *((void *)&v95 + 1);
                if (*((void *)&v95 + 1))
                {
                  **((void **)&v95 + 1) = **((void **)&v95 + 1) & 7 | v53;
                }
                else
                {
                  uint64_t v54 = v96;
                  unsigned int v55 = ***(int32x2_t ****)v96;
                  unint64_t v56 = (unint64_t)v55[303];
                  if (v56 <= v53)
                  {
                    uint64_t v57 = v55[305].u32[0];
                    if (v56 + 16 * v57 > v53)
                    {
                      unsigned int v58 = v57 - 1;
                      LODWORD(v59) = v58 & ((v96 >> 4) ^ (v96 >> 9));
                      int v60 = (uint64_t *)(v56 + 16 * v59);
                      uint64_t v61 = *v60;
                      if ((void)v96 == *v60)
                      {
LABEL_100:
                        *int v60 = -8192;
                        v55[304] = vadd_s32(v55[304], (int32x2_t)0x1FFFFFFFFLL);
                        uint64_t v54 = v96;
                      }
                      else
                      {
                        int v62 = 1;
                        while (v61 != -4096)
                        {
                          int v63 = v59 + v62++;
                          uint64_t v59 = v63 & v58;
                          uint64_t v61 = *(void *)(v56 + 16 * v59);
                          if ((void)v96 == v61)
                          {
                            int v60 = (uint64_t *)(v56 + 16 * v59);
                            goto LABEL_100;
                          }
                        }
                      }
                      *(unsigned char *)(v54 + 17) &= ~1u;
                    }
                  }
                }
              }
              ++*((_DWORD *)v97 + 10);
            }
            if (v94 != &v95) {
              free(v94);
            }
            ++v46;
          }
          while (v46 != v47);
          __n128 v46 = (const llvm::Use **)v98;
        }
        uint64_t v5 = v45;
        if (v46 != v45) {
          free(v46);
        }
        if (!v92) {
          goto LABEL_108;
        }
        LODWORD(v64) = (v92 - 1) & ((v39 >> 4) ^ (v39 >> 9));
        unsigned int v65 = (uint64_t *)(v90 + 16 * v64);
        uint64_t v66 = *v65;
        if (v39 != *v65)
        {
          int v73 = 1;
          while (v66 != -4096)
          {
            int v74 = v64 + v73++;
            uint64_t v64 = v74 & (v92 - 1);
            uint64_t v66 = *(void *)(v90 + 16 * v64);
            if (v39 == v66)
            {
              unsigned int v65 = (uint64_t *)(v90 + 16 * v64);
              goto LABEL_107;
            }
          }
LABEL_108:
          uint64_t v67 = *(void *)(i - 56);
          if (v67 && !*(unsigned char *)(v67 + 16) && *(void *)(v67 + 24) == *(void *)(i + 48))
          {
            size_t v68 = llvm::CallGraph::getOrInsertFunction(a3, (const llvm::Function *)v67);
            ++v86;
          }
          else
          {
            size_t v68 = (uint64_t *)*((void *)a3 + 11);
            ++v35;
          }
          sub_1CBFA7A30((uint64_t)v6, (int32x2_t ****)(i - 24), (uint64_t)v68);
          continue;
        }
LABEL_107:
        if (v64 == v92) {
          goto LABEL_108;
        }
        uint64_t v69 = v65[1];
        *unsigned int v65 = -8192;
        int32x2_t v91 = vadd_s32(v91, (int32x2_t)0x1FFFFFFFFLL);
        uint64_t v70 = *(void *)(v69 + 8);
        uint64_t v71 = *(void *)(i - 56);
        if (!v71 || *(unsigned char *)(v71 + 16) || *(void *)(v71 + 24) != *(void *)(i + 48))
        {
          if (!v70) {
            continue;
          }
          uint64_t v72 = (uint64_t *)*((void *)a3 + 11);
          goto LABEL_118;
        }
        if (v70 != v71)
        {
          uint64_t v72 = llvm::CallGraph::getOrInsertFunction(a3, (const llvm::Function *)v71);
          v84 |= *(void *)(v69 + 8) == 0;
LABEL_118:
          llvm::CallGraphNode::replaceCallEdge((llvm::CallGraphNode *)v6, (uint64_t ****)(i - 24), (llvm::CallBase *)(i - 24), (llvm::CallGraphNode *)v72);
          continue;
        }
      }
      size_t v34 = (char *)*((void *)v87 + 1);
    }
    while (v34 != v85);
LABEL_130:
    BOOL v76 = v82 > v35 && v83 < v86;
    int v3 = v76 | v84;
    int v4 = v80;
    if ((~v80 & 0xF) == 0) {
      sub_1CD3C7F68(&v90);
    }
    a2 = v79;
    a1 = v81;
LABEL_139:
    ++a1;
    ++v4;
  }
  while (a1 != a2);
  uint64_t v77 = v90;
LABEL_142:
  MEMORY[0x1D25D9CD0](v77, 8);
  return v3 & 1;
}

void *sub_1CBFB070C(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  BOOL result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CBFB07D8(a1, v4, &v4[2 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      void *result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CBFB07D8(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v11 = 0;
      BOOL result = sub_1CBF8BDAC(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v11);
      uint64_t v10 = v11;
      *uint64_t v11 = *a2;
      v10[1] = a2[1];
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 2;
  }
  return result;
}

void sub_1CBFB0888(void **this)
{
  *this = &unk_1F2601C40;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }

  llvm::Pass::~Pass((llvm::Pass *)this);
}

void sub_1CBFB08E8(void **this)
{
  *this = &unk_1F2601C40;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }
  llvm::Pass::~Pass((llvm::Pass *)this);

  JUMPOUT(0x1D25D9CE0);
}

const char *sub_1CBFB095C()
{
  return "Print CallGraph IR";
}

void sub_1CBFB096C(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
}

uint64_t sub_1CBFB0978(uint64_t a1, uint64_t a2)
{
  int v4 = byte_1EBD06DE0;
  if (llvm::isFunctionInPrintList("*", 1uLL)) {
    BOOL v5 = v4 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    uint64_t v39 = *(llvm::raw_ostream **)(a1 + 56);
    uint64_t v38 = (llvm::raw_ostream **)(a1 + 56);
    unint64_t v37 = v39;
    uint64_t v10 = v38;
    char v40 = *((unsigned char *)v38 - 1);
    int v41 = v40;
    if (v40 >= 0) {
      uint64_t v42 = (const char *)(v38 - 3);
    }
    else {
      uint64_t v42 = (const char *)*(v38 - 3);
    }
    size_t v43 = v40 & 0x7F;
    if (v41 >= 0) {
      size_t v44 = v43;
    }
    else {
      size_t v44 = (size_t)*(v38 - 2);
    }
    llvm::raw_ostream::write(v37, v42, v44);
    size_t v45 = *v38;
    goto LABEL_68;
  }
  uint64_t v6 = *(void *)(a2 + 16);
  uint64_t v7 = *(void *)(a2 + 24);
  if (v6 != v7)
  {
    char v8 = 0;
    int v9 = 0;
    uint64_t v10 = (llvm::raw_ostream **)(a1 + 56);
    while (1)
    {
      uint64_t v11 = *(uint64_t ****)(*(void *)v6 + 8);
      if (!v11)
      {
        if (llvm::isFunctionInPrintList("*", 1uLL))
        {
          if (!v9)
          {
            char v12 = *(unsigned char *)(a1 + 55);
            BOOL v13 = v12 < 0;
            if (v12 >= 0) {
              unsigned int v14 = (const char *)(a1 + 32);
            }
            else {
              unsigned int v14 = *(const char **)(a1 + 32);
            }
            size_t v15 = v12 & 0x7F;
            if (v13) {
              size_t v16 = *(void *)(a1 + 40);
            }
            else {
              size_t v16 = v15;
            }
            llvm::raw_ostream::write(*(llvm::raw_ostream **)(a1 + 56), v14, v16);
          }
          unint64_t v17 = *v10;
          unsigned int v18 = (void *)*((void *)*v10 + 4);
          if (*((void *)*v10 + 3) - (void)v18 > 0x19uLL)
          {
            qmemcpy(v18, "\nPrinting <null> Function\n", 26);
            *((void *)v17 + 4) += 26;
          }
          else
          {
            llvm::raw_ostream::write(v17, "\nPrinting <null> Function\n", 0x1AuLL);
          }
          int v9 = 1;
        }
        goto LABEL_38;
      }
      if (*((unsigned char *)v11 + 16))
      {
        if (*((unsigned char *)v11 + 16) != 3 || (*((_DWORD *)v11 + 5) & 0x7FFFFFF) != 0) {
          goto LABEL_27;
        }
      }
      else if (v11[9] != (uint64_t **)(v11 + 9) || (*((unsigned char *)v11 + 34) & 0x80) != 0)
      {
LABEL_27:
        if ((*((unsigned char *)v11 + 23) & 0x10) != 0)
        {
          uint64_t v19 = ***v11;
          uint64_t v20 = *(void *)(v19 + 152);
          uint64_t v21 = *(unsigned int *)(v19 + 168);
          if (!v21) {
            goto LABEL_34;
          }
          LODWORD(v22) = (v21 - 1) & ((v11 >> 4) ^ (v11 >> 9));
          unsigned int v23 = (uint64_t ****)(v20 + 16 * v22);
          int v24 = *v23;
          if (*v23 != v11)
          {
            int v25 = 1;
            while (v24 != (uint64_t ***)-4096)
            {
              int v26 = v22 + v25++;
              uint64_t v22 = v26 & (v21 - 1);
              int v24 = *(uint64_t ****)(v20 + 16 * v22);
              if (v24 == v11)
              {
                unsigned int v23 = (uint64_t ****)(v20 + 16 * v22);
                goto LABEL_35;
              }
            }
LABEL_34:
            unsigned int v23 = (uint64_t ****)(v20 + 16 * v21);
          }
LABEL_35:
          uint64_t v27 = v23[1];
          std::string::size_type v30 = (std::string::size_type)*v27;
          uint64_t v28 = (const std::string::value_type *)(v27 + 2);
          std::string::size_type v29 = v30;
        }
        else
        {
          std::string::size_type v29 = 0;
          uint64_t v28 = &byte_1CFBCE98E;
        }
        int isFunctionInPrintList = llvm::isFunctionInPrintList(v28, v29);
        v8 |= isFunctionInPrintList;
        if (!v4 && isFunctionInPrintList)
        {
          if (!v9)
          {
            char v32 = *(unsigned char *)(a1 + 55);
            BOOL v33 = v32 < 0;
            if (v32 >= 0) {
              size_t v34 = (const char *)(a1 + 32);
            }
            else {
              size_t v34 = *(const char **)(a1 + 32);
            }
            size_t v35 = v32 & 0x7F;
            if (v33) {
              size_t v36 = *(void *)(a1 + 40);
            }
            else {
              size_t v36 = v35;
            }
            llvm::raw_ostream::write(*(llvm::raw_ostream **)(a1 + 56), v34, v36);
          }
          llvm::Function::print((const llvm::Module **)v11, *v10, 0, 0, 0);
          int v9 = 1;
          char v8 = 1;
        }
      }
LABEL_38:
      v6 += 8;
      if (v6 == v7)
      {
        if (((v4 != 0) & v8) != 0)
        {
          if (!v9)
          {
            char v46 = *(unsigned char *)(a1 + 55);
            BOOL v47 = v46 < 0;
            if (v46 >= 0) {
              int v48 = (const char *)(a1 + 32);
            }
            else {
              int v48 = *(const char **)(a1 + 32);
            }
            size_t v49 = v46 & 0x7F;
            if (v47) {
              size_t v50 = *(void *)(a1 + 40);
            }
            else {
              size_t v50 = v49;
            }
            llvm::raw_ostream::write(*(llvm::raw_ostream **)(a1 + 56), v48, v50);
          }
          size_t v45 = *v10;
LABEL_68:
          uint64_t v51 = (unsigned char *)*((void *)v45 + 4);
          if (*((unsigned char **)v45 + 3) == v51)
          {
            llvm::raw_ostream::write(v45, "\n", 1uLL);
          }
          else
          {
            *uint64_t v51 = 10;
            ++*((void *)v45 + 4);
          }
          llvm::Module::print(**(const std::string ***)a2, *v10, 0, 0, 0);
        }
        return 0;
      }
    }
  }
  return 0;
}

uint64_t sub_1CBFB0CAC()
{
  int v3 = 2;
  int v1 = 4;
  uint64_t v2 = &v1;
  sub_1CD46FD38((uint64_t)&llvm::MaxDevirtIterations, "max-devirt-iterations", &v3, &v2);
  return __cxa_atexit((void (*)(void *))sub_1CB8598A4, &llvm::MaxDevirtIterations, &dword_1CB82C000);
}

void sub_1CBFB0D28(uint64_t a1)
{
  v19[12] = *MEMORY[0x1E4F143B8];
  if (byte_1EBCC4C27 >= 0) {
    size_t v2 = byte_1EBCC4C27 & 0x7F;
  }
  else {
    size_t v2 = qword_1EBCC4C18;
  }
  if (v2)
  {
    int v3 = &v16;
    sub_1CB907098((uint64_t)&v16, v2 + 14);
    if ((v16.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      int v3 = (std::string *)v16.__r_.__value_.__r.__words[0];
    }
    if (byte_1EBCC4C27 >= 0) {
      int v4 = &qword_1EBCC4C10;
    }
    else {
      int v4 = (uint64_t *)qword_1EBCC4C10;
    }
    BOOL v5 = (std::string::size_type *)memmove(v3, v4, v2);
    strcpy((char *)v3 + v2, ".callgraph.dot");
    std::string __p = v16;
  }
  else
  {
    if (*(char *)(a1 + 191) < 0) {
      sub_1CB8BDF7C((uint64_t)&v16, *(const void **)(a1 + 168), *(void *)(a1 + 176));
    }
    else {
      std::string v16 = *(std::string *)(a1 + 168);
    }
    BOOL v5 = (std::string::size_type *)std::string::append(&v16, ".callgraph.dot");
    std::string::size_type v6 = *v5;
    v19[0] = v5[1];
    *(void *)((char *)v19 + 7) = *(std::string::size_type *)((char *)v5 + 15);
    char v7 = *((unsigned char *)v5 + 23);
    v5[1] = 0;
    void v5[2] = 0;
    *BOOL v5 = 0;
    __p.__r_.__value_.__r.__words[0] = v6;
    __p.__r_.__value_.__l.__size_ = v19[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(void *)((char *)v19 + 7);
    *((unsigned char *)&__p.__r_.__value_.__s + 23) = v7;
    if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v16.__r_.__value_.__l.__data_);
    }
  }
  char v8 = (llvm::raw_ostream *)llvm::errs((llvm *)v5);
  uint64_t v9 = *((void *)v8 + 4);
  if ((unint64_t)(*((void *)v8 + 3) - v9) > 8)
  {
    *(unsigned char *)(v9 + 8) = 39;
    *(void *)uint64_t v9 = *(void *)"Writing '";
    *((void *)v8 + 4) += 9;
  }
  else
  {
    char v8 = llvm::raw_ostream::write(v8, "Writing '", 9uLL);
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
  }
  else {
    size_t size = __p.__r_.__value_.__l.__size_;
  }
  char v12 = llvm::raw_ostream::write(v8, (const char *)p_p, size);
  BOOL v13 = (_DWORD *)*((void *)v12 + 4);
  if (*((void *)v12 + 3) - (void)v13 > 3uLL)
  {
    *BOOL v13 = 774778407;
    *((void *)v12 + 4) += 4;
  }
  else
  {
    llvm::raw_ostream::write(v12, "'...", 4uLL);
  }
  v17[0] = 0;
  std::system_category();
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unsigned int v14 = &__p;
  }
  else {
    unsigned int v14 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v15 = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
  }
  else {
    uint64_t v15 = __p.__r_.__value_.__l.__size_;
  }
  llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)&v16, v14, v15, (uint64_t)v17, 1);
  llvm::CallGraph::CallGraph((llvm::CallGraph *)v19, (llvm::Module *)a1);
}

void sub_1CBFB1098(llvm::Module *a1)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  llvm::CallGraph::CallGraph((llvm::CallGraph *)v1, a1);
}

void llvm::initializeCallGraphViewerPass(uint64_t a1)
{
  uint64_t v1 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC4940, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CBFB1200;
    v3[1] = &v1;
    uint64_t v2 = v3;
    std::__call_once(&qword_1EBCC4940, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CBFB1200()
{
}

void llvm::initializeCallGraphDOTPrinterPass(uint64_t a1)
{
  uint64_t v1 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC4948, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CBFB130C;
    v3[1] = &v1;
    uint64_t v2 = v3;
    std::__call_once(&qword_1EBCC4948, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CBFB130C()
{
}

void *sub_1CBFB13A8(uint64_t *a1, void *a2)
{
  char v7 = 0;
  char v4 = sub_1CB834D78(a1, a2, &v7);
  BOOL v5 = v7;
  if ((v4 & 1) == 0)
  {
    BOOL v5 = sub_1CBFB1408((uint64_t)a1, (uint64_t)a2, a2, v7);
    *BOOL v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

void *sub_1CBFB1408(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CBFB14BC(a1, v7);
  uint64_t v9 = 0;
  sub_1CB834D78((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CBFB14BC(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  char v4 = *(void **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  BOOL result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CBFB1588(a1, v4, &v4[2 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      void *result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CBFB1588(uint64_t result, void *a2, void *a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v11 = 0;
      BOOL result = sub_1CB834D78((uint64_t *)v5, a2, &v11);
      uint64_t v9 = v11;
      uint64_t v10 = a2[1];
      *uint64_t v11 = *a2;
      v9[1] = v10;
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 2;
  }
  return result;
}

void sub_1CBFB1630(uint64_t **a1, std::string::size_type *a2)
{
  sub_1CD470824((uint64_t)v70, a2[1], *a1[1]);
  char v4 = *a1;
  uint64_t v5 = (*a1)[4];
  if ((unint64_t)((*a1)[3] - v5) > 4)
  {
    *(unsigned char *)(v5 + 4) = 101;
    *(_DWORD *)uint64_t v5 = 1685016073;
    v4[4] += 5;
  }
  else
  {
    llvm::raw_ostream::write((llvm::raw_ostream *)*a1, "\tNode", 5uLL);
  }
  llvm::write_hex((llvm::raw_ostream *)v4, (unint64_t)a2, 3, 0, 0);
  uint64_t v6 = (void *)v4[4];
  if ((unint64_t)(v4[3] - (void)v6) > 7)
  {
    *uint64_t v6 = 0x3D65706168735B20;
    v4[4] += 8;
  }
  else
  {
    llvm::raw_ostream::write((llvm::raw_ostream *)v4, " [shape=", 8uLL);
  }
  int v7 = (llvm::raw_ostream *)*a1;
  uint64_t v8 = (*a1)[4];
  unint64_t v9 = (*a1)[3] - v8;
  if (*((unsigned char *)a1 + 16))
  {
    if (v9 <= 4)
    {
      uint64_t v10 = "none,";
      size_t v11 = 5;
LABEL_10:
      llvm::raw_ostream::write(v7, v10, v11);
      goto LABEL_11;
    }
    *(unsigned char *)(v8 + 4) = 44;
    *(_DWORD *)uint64_t v8 = 1701736302;
    uint64_t v55 = *((void *)v7 + 4) + 5;
  }
  else
  {
    if (v9 <= 6)
    {
      uint64_t v10 = "record,";
      size_t v11 = 7;
      goto LABEL_10;
    }
    *(_DWORD *)(v8 + 3) = 744780399;
    *(_DWORD *)uint64_t v8 = 1868785010;
    uint64_t v55 = *((void *)v7 + 4) + 7;
  }
  *((void *)v7 + 4) = v55;
LABEL_11:
  if (v71 >= 0) {
    size_t v12 = v71 & 0x7F;
  }
  else {
    size_t v12 = (size_t)v70[1];
  }
  if (v12)
  {
    if (v71 >= 0) {
      BOOL v13 = (const char *)v70;
    }
    else {
      BOOL v13 = (const char *)v70[0];
    }
    unsigned int v14 = llvm::raw_ostream::write((llvm::raw_ostream *)*a1, v13, v12);
    uint64_t v15 = (unsigned char *)*((void *)v14 + 4);
    if (*((unsigned char **)v14 + 3) == v15)
    {
      llvm::raw_ostream::write(v14, ",", 1uLL);
    }
    else
    {
      unsigned char *v15 = 44;
      ++*((void *)v14 + 4);
    }
  }
  std::string v16 = (llvm::raw_ostream *)*a1;
  uint64_t v17 = (*a1)[4];
  if ((unint64_t)((*a1)[3] - v17) > 5)
  {
    *(_WORD *)(v17 + 4) = 15724;
    *(_DWORD *)uint64_t v17 = 1700946284;
    *((void *)v16 + 4) += 6;
  }
  else
  {
    llvm::raw_ostream::write(v16, "label=", 6uLL);
  }
  if (*((unsigned char *)a1 + 16))
  {
    std::string::size_type v19 = a2[2];
    std::string::size_type v18 = a2[3];
    if (v19 == v18)
    {
      unsigned int v22 = 0;
      BOOL v23 = 0;
    }
    else
    {
      int v20 = 0;
      std::string::size_type v21 = v19 + 40;
      do
      {
        unsigned int v22 = v20 + 1;
        BOOL v23 = v21 != v18;
        if (v21 == v18) {
          break;
        }
        v21 += 40;
      }
      while (v20++ != 63);
    }
    if (v22 <= 1) {
      int v28 = 1;
    }
    else {
      int v28 = v22;
    }
    std::string::size_type v29 = (llvm::raw_ostream *)*a1;
    std::string::size_type v30 = (void *)(*a1)[4];
    if ((unint64_t)((*a1)[3] - (void)v30) > 0x30)
    {
      qmemcpy(v30, "<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\"", 49);
      unsigned int v31 = (void *)(*((void *)v29 + 4) + 49);
      *((void *)v29 + 4) = v31;
    }
    else
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)*a1, "<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\"", 0x31uLL);
      unsigned int v31 = (void *)*((void *)v29 + 4);
    }
    unint64_t v32 = (v28 + v23);
    if (*((void *)v29 + 3) - (void)v31 > 0x2EuLL)
    {
      qmemcpy(v31, " cellpadding=\"0\"><tr><td align=\"text\" colspan=\"", 47);
      *((void *)v29 + 4) += 47;
    }
    else
    {
      llvm::raw_ostream::write(v29, " cellpadding=\"0\"><tr><td align=\"text\" colspan=\"", 0x2FuLL);
    }
    sub_1CD098D14(v29, v32, 0, 0, 0);
    BOOL v33 = (_WORD *)*((void *)v29 + 4);
    if (*((void *)v29 + 3) - (void)v33 <= 1uLL)
    {
      uint64_t v27 = "\">";
      int v25 = v29;
      goto LABEL_41;
    }
    *BOOL v33 = 15906;
    *((void *)v29 + 4) += 2;
  }
  else
  {
    int v25 = (llvm::raw_ostream *)*a1;
    int v26 = (_WORD *)(*a1)[4];
    if ((unint64_t)((*a1)[3] - (void)v26) <= 1)
    {
      uint64_t v27 = "\"{";
LABEL_41:
      llvm::raw_ostream::write(v25, v27, 2uLL);
      goto LABEL_42;
    }
    _WORD *v26 = 31522;
    *((void *)v25 + 4) += 2;
  }
LABEL_42:
  size_t v34 = (llvm::raw_ostream *)*a1;
  if (*((unsigned char *)a1 + 16))
  {
    sub_1CBFB1D64((char *)&__p, (uint64_t)a2, *(void *)(*a1[1] + 8));
    if (v61 >= 0) {
      p_p = (const char *)&__p;
    }
    else {
      p_p = (const char *)__p;
    }
    if (v61 >= 0) {
      size_t v36 = HIBYTE(v61) & 0x7F;
    }
    else {
      size_t v36 = v60;
    }
    llvm::raw_ostream::write(v34, p_p, v36);
    uint64_t v37 = *((void *)v34 + 4);
    if ((unint64_t)(*((void *)v34 + 3) - v37) > 4)
    {
      *(unsigned char *)(v37 + 4) = 62;
      *(_DWORD *)uint64_t v37 = 1685335868;
      *((void *)v34 + 4) += 5;
    }
    else
    {
      llvm::raw_ostream::write(v34, "</td>", 5uLL);
    }
    if (SHIBYTE(v61) < 0)
    {
      uint64_t v38 = __p;
LABEL_63:
      operator delete(v38);
    }
  }
  else
  {
    sub_1CBFB1D64((char *)__dst, (uint64_t)a2, *(void *)(*a1[1] + 8));
    llvm::DOT::EscapeString((char *)__dst, (uint64_t)&__p);
    if (v61 >= 0) {
      uint64_t v39 = (const char *)&__p;
    }
    else {
      uint64_t v39 = (const char *)__p;
    }
    if (v61 >= 0) {
      size_t v40 = HIBYTE(v61) & 0x7F;
    }
    else {
      size_t v40 = v60;
    }
    llvm::raw_ostream::write(v34, v39, v40);
    if (SHIBYTE(v61) < 0) {
      operator delete(__p);
    }
    if (SHIBYTE(v69) < 0)
    {
      uint64_t v38 = __dst[0];
      goto LABEL_63;
    }
  }
  __dst[0] = 0;
  __dst[1] = 0;
  uint64_t v69 = 0;
  LODWORD(v60) = 0;
  char v64 = 0;
  uint64_t v65 = 0;
  uint64_t v67 = __dst;
  int v66 = 0;
  std::string __p = &unk_1F2646F30;
  uint64_t v61 = 0;
  uint64_t v62 = 0;
  uint64_t v63 = 0;
  if (*((unsigned char *)a1 + 16)
    && (llvm::raw_ostream::write((llvm::raw_ostream *)&__p, "</tr><tr>", 9uLL), *((unsigned char *)a1 + 16)))
  {
    int v41 = (llvm::raw_ostream *)*a1;
    uint64_t v42 = (void *)(*a1)[4];
    if ((unint64_t)((*a1)[3] - (void)v42) <= 0xD)
    {
      size_t v43 = "</tr></table>>";
      size_t v44 = 14;
LABEL_70:
      llvm::raw_ostream::write(v41, v43, v44);
      goto LABEL_71;
    }
    qmemcpy(v42, "</tr></table>>", 14);
    uint64_t v56 = *((void *)v41 + 4) + 14;
  }
  else
  {
    int v41 = (llvm::raw_ostream *)*a1;
    size_t v45 = (_WORD *)(*a1)[4];
    if ((unint64_t)((*a1)[3] - (void)v45) <= 1)
    {
      size_t v43 = "}\"";
      size_t v44 = 2;
      goto LABEL_70;
    }
    *size_t v45 = 8829;
    uint64_t v56 = *((void *)v41 + 4) + 2;
  }
  *((void *)v41 + 4) = v56;
LABEL_71:
  char v46 = (llvm::raw_ostream *)*a1;
  uint64_t v47 = (*a1)[4];
  if ((unint64_t)((*a1)[3] - v47) > 2)
  {
    *(unsigned char *)(v47 + 2) = 10;
    *(_WORD *)uint64_t v47 = 15197;
    *((void *)v46 + 4) += 3;
  }
  else
  {
    llvm::raw_ostream::write(v46, "];\n", 3uLL);
  }
  uint64_t v48 = a2[2];
  std::string::size_type v49 = a2[3];
  uint64_t v57 = v48;
  unsigned int v58 = sub_1CBFB2040;
  if (v48 != v49)
  {
    int v50 = 63;
    do
    {
      uint64_t v51 = sub_1CBFB1F00(&v57);
      if (byte_1EBCC4B50 || *(void *)(v51 + 8)) {
        sub_1CD4709BC((uint64_t)a1, (unint64_t)a2, v57, (uint64_t)v58);
      }
      uint64_t v48 = v57 + 40;
      v57 += 40;
      BOOL v53 = v50-- != 0;
    }
    while (v48 != v49 && v53);
  }
  if (v48 != v49)
  {
    do
    {
      uint64_t v54 = sub_1CBFB1F00(&v57);
      if (byte_1EBCC4B50 || *(void *)(v54 + 8)) {
        sub_1CD4709BC((uint64_t)a1, (unint64_t)a2, v57, (uint64_t)v58);
      }
      v57 += 40;
    }
    while (v57 != v49);
  }
  std::string __p = &unk_1F2646B98;
  if (v66 == 1 && v61) {
    MEMORY[0x1D25D9CB0](v61, 0x1000C8077774924);
  }
  if (SHIBYTE(v69) < 0) {
    operator delete(__dst[0]);
  }
  if (v71 < 0) {
    operator delete(v70[0]);
  }
}

char *sub_1CBFB1D64(char *__dst, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = __dst;
  if (*(void *)(a3 + 80) == a2)
  {
    BOOL v13 = "external caller";
LABEL_13:
    __dst[23] = 15;
    *(void *)__dst = *(void *)v13;
    *(void *)(__dst + 7) = *(void *)(v13 + 7);
    unsigned int v14 = __dst + 15;
    goto LABEL_25;
  }
  if (*(void *)(a3 + 88) == a2)
  {
    BOOL v13 = "external callee";
    goto LABEL_13;
  }
  char v4 = *(uint64_t ****)(a2 + 8);
  if (v4)
  {
    if ((*((unsigned char *)v4 + 23) & 0x10) == 0)
    {
      size_t v16 = 0;
      __dst[23] = 0;
      goto LABEL_24;
    }
    uint64_t v5 = ***v4;
    uint64_t v6 = *(void *)(v5 + 152);
    uint64_t v7 = *(unsigned int *)(v5 + 168);
    if (v7)
    {
      LODWORD(v8) = (v7 - 1) & ((v4 >> 4) ^ (v4 >> 9));
      unint64_t v9 = (uint64_t ****)(v6 + 16 * v8);
      uint64_t v10 = *v9;
      if (*v9 == v4)
      {
LABEL_16:
        uint64_t v15 = (unint64_t *)v9[1];
        unint64_t v18 = *v15;
        uint64_t v17 = v15 + 2;
        size_t v16 = v18;
        if (v18 >= 0x7FFFFFFFFFFFFFF8) {
          abort();
        }
        if (v16 >= 0x17)
        {
          uint64_t v19 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v16 | 7) != 0x17) {
            uint64_t v19 = v16 | 7;
          }
          uint64_t v20 = v19 + 1;
          std::string::size_type v21 = operator new(v19 + 1);
          v3[1] = v16;
          void v3[2] = v20 | 0x8000000000000000;
          *uint64_t v3 = v21;
          uint64_t v3 = v21;
        }
        else
        {
          __dst[23] = v16;
          if (!v16) {
            goto LABEL_24;
          }
        }
        __dst = (char *)memmove(v3, v17, v16);
LABEL_24:
        unsigned int v14 = (char *)v3 + v16;
        goto LABEL_25;
      }
      int v11 = 1;
      while (v10 != (uint64_t ***)-4096)
      {
        int v12 = v8 + v11++;
        uint64_t v8 = v12 & (v7 - 1);
        uint64_t v10 = *(uint64_t ****)(v6 + 16 * v8);
        if (v10 == v4)
        {
          unint64_t v9 = (uint64_t ****)(v6 + 16 * v8);
          goto LABEL_16;
        }
      }
    }
    unint64_t v9 = (uint64_t ****)(v6 + 16 * v7);
    goto LABEL_16;
  }
  __dst[23] = 13;
  qmemcpy(__dst, "external node", 13);
  unsigned int v14 = __dst + 13;
LABEL_25:
  *unsigned int v14 = 0;
  return __dst;
}

uint64_t sub_1CBFB1F00(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (uint64_t (*)(uint64_t *))a1[1];
  LOBYTE(v16) = 0;
  char v19 = 0;
  if (*(unsigned char *)(v1 + 24)) {
    sub_1CBFA9590((llvm::ValueHandleBase *)&v16, (void *)v1);
  }
  uint64_t v20 = *(void *)(v1 + 32);
  uint64_t result = v2(&v16);
  if (v19 && v18 != (int32x2_t ****)-8192 && v18 != (int32x2_t ****)-4096 && v18 != 0)
  {
    unint64_t v5 = v16 & 0xFFFFFFFFFFFFFFF8;
    *(void *)(v16 & 0xFFFFFFFFFFFFFFF8) = v17;
    if (v17)
    {
      unint64_t *v17 = *v17 & 7 | v5;
    }
    else
    {
      uint64_t v6 = v18;
      uint64_t v7 = ***v18;
      unint64_t v8 = (unint64_t)v7[303];
      if (v8 <= v5)
      {
        uint64_t v9 = v7[305].u32[0];
        if (v8 + 16 * v9 > v5)
        {
          unsigned int v10 = v9 - 1;
          LODWORD(v11) = v10 & ((v18 >> 4) ^ (v18 >> 9));
          int v12 = (int32x2_t *****)(v8 + 16 * v11);
          BOOL v13 = *v12;
          if (v18 == *v12)
          {
LABEL_17:
            *int v12 = (int32x2_t ****)-8192;
            v7[304] = vadd_s32(v7[304], (int32x2_t)0x1FFFFFFFFLL);
            uint64_t v6 = v18;
          }
          else
          {
            int v14 = 1;
            while (v13 != (int32x2_t ****)-4096)
            {
              int v15 = v11 + v14++;
              uint64_t v11 = v15 & v10;
              BOOL v13 = *(int32x2_t *****)(v8 + 16 * v11);
              if (v18 == v13)
              {
                int v12 = (int32x2_t *****)(v8 + 16 * v11);
                goto LABEL_17;
              }
            }
          }
          *((unsigned char *)v6 + 17) &= ~1u;
        }
      }
    }
  }
  return result;
}

uint64_t sub_1CBFB2040(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

void sub_1CBFB2048(uint64_t a1, uint64_t *a2, llvm::Twine *this, llvm::Twine *a4, uint64_t a5)
{
  if (*(char *)(a5 + 23) < 0) {
    uint64_t v9 = *(void *)(a5 + 8);
  }
  else {
    uint64_t v9 = *(unsigned __int8 *)(a5 + 23);
  }
  int v47 = 0;
  if (v9)
  {
    __int16 v42 = 260;
    uint64_t v40 = a5;
    *(void *)&long long v45 = llvm::sys::fs::openFile((unsigned __int8 *)&v40, &v47, 0, 2, 1, 438);
    *((void *)&v45 + 1) = v10;
    uint64_t v11 = std::generic_category();
    uint64_t v40 = 17;
    int v41 = v11;
    int v12 = (llvm *)(*(uint64_t (**)(void, void, uint64_t *))(**((void **)&v45 + 1) + 32))(*((void *)&v45 + 1), v45, &v40);
    if (v12
      || (int v12 = (llvm *)((uint64_t (*)(const std::error_category *, long long *, void))v41->equivalent_0)(v41, &v45, v40), v12))
    {
      unint64_t v18 = (llvm::raw_ostream *)llvm::errs(v12);
      char v19 = (void *)*((void *)v18 + 4);
      if (*((void *)v18 + 3) - (void)v19 > 0x17uLL)
      {
        qmemcpy(v19, "file exists, overwriting", 24);
        uint64_t v20 = (unsigned char *)(*((void *)v18 + 4) + 24);
        *((void *)v18 + 4) = v20;
      }
      else
      {
        unint64_t v18 = llvm::raw_ostream::write(v18, "file exists, overwriting", 0x18uLL);
        uint64_t v20 = (unsigned char *)*((void *)v18 + 4);
      }
      std::string::size_type v21 = (unsigned char *)*((void *)v18 + 3);
    }
    else
    {
      int v13 = v45;
      int v14 = (llvm::raw_ostream *)llvm::errs(v12);
      int v15 = (char *)*((void *)v14 + 4);
      unint64_t v16 = *((void *)v14 + 3) - (void)v15;
      if (v13)
      {
        if (v16 > 0x16)
        {
          qmemcpy(v15, "error writing into file", 23);
          uint64_t v17 = (unsigned char *)(*((void *)v14 + 4) + 23);
          *((void *)v14 + 4) = v17;
        }
        else
        {
          int v14 = llvm::raw_ostream::write(v14, "error writing into file", 0x17uLL);
          uint64_t v17 = (unsigned char *)*((void *)v14 + 4);
        }
        if (*((unsigned char **)v14 + 3) == v17)
        {
          llvm::raw_ostream::write(v14, "\n", 1uLL);
        }
        else
        {
          unsigned char *v17 = 10;
          ++*((void *)v14 + 4);
        }
        *(unsigned char *)(a1 + 23) = 0;
        *(unsigned char *)a1 = 0;
        return;
      }
      if (v16 > 0x21)
      {
        qmemcpy(v15, "writing to the newly created file ", 34);
        *((void *)v14 + 4) += 34;
      }
      else
      {
        int v14 = llvm::raw_ostream::write(v14, "writing to the newly created file ", 0x22uLL);
      }
      char v22 = *(unsigned char *)(a5 + 23);
      BOOL v23 = v22 < 0;
      if (v22 >= 0) {
        int v24 = (const char *)a5;
      }
      else {
        int v24 = *(const char **)a5;
      }
      size_t v25 = v22 & 0x7F;
      if (v23) {
        size_t v26 = *(void *)(a5 + 8);
      }
      else {
        size_t v26 = v25;
      }
      unint64_t v18 = llvm::raw_ostream::write(v14, v24, v26);
      std::string::size_type v21 = (unsigned char *)*((void *)v18 + 3);
      uint64_t v20 = (unsigned char *)*((void *)v18 + 4);
    }
    if (v21 == v20)
    {
      llvm::raw_ostream::write(v18, "\n", 1uLL);
    }
    else
    {
      *uint64_t v20 = 10;
      ++*((void *)v18 + 4);
    }
  }
  else
  {
    llvm::Twine::str(this, __p);
    __int16 v42 = 260;
    uint64_t v40 = (uint64_t)__p;
    llvm::createGraphFilename((llvm *)&v40, (const llvm::Twine *)&v47, (uint64_t)&v45);
    if (*(char *)(a5 + 23) < 0) {
      operator delete(*(void **)a5);
    }
    *(_OWORD *)a5 = v45;
    *(void *)(a5 + 16) = v46;
    HIBYTE(v46) = 0;
    LOBYTE(v45) = 0;
    if (v44 < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v27 = (llvm *)llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)&v40, v47, 1, 0, 0);
  if (v47 == -1)
  {
    int v28 = (llvm::raw_ostream *)llvm::errs(v27);
    uint64_t v29 = *((void *)v28 + 4);
    if ((unint64_t)(*((void *)v28 + 3) - v29) > 0x13)
    {
      *(_DWORD *)(v29 + 16) = 656434540;
      *(_OWORD *)uint64_t v29 = *(_OWORD *)"error opening file '";
      *((void *)v28 + 4) += 20;
    }
    else
    {
      int v28 = llvm::raw_ostream::write(v28, "error opening file '", 0x14uLL);
    }
    char v30 = *(unsigned char *)(a5 + 23);
    BOOL v31 = v30 < 0;
    if (v30 >= 0) {
      unint64_t v32 = (const char *)a5;
    }
    else {
      unint64_t v32 = *(const char **)a5;
    }
    size_t v33 = v30 & 0x7F;
    if (v31) {
      size_t v34 = *(void *)(a5 + 8);
    }
    else {
      size_t v34 = v33;
    }
    size_t v35 = llvm::raw_ostream::write(v28, v32, v34);
    size_t v36 = (void *)*((void *)v35 + 4);
    if (*((void *)v35 + 3) - (void)v36 > 0xEuLL)
    {
      qmemcpy(v36, "' for writing!\n", 15);
      *((void *)v35 + 4) += 15;
    }
    else
    {
      llvm::raw_ostream::write(v35, "' for writing!\n", 0xFuLL);
    }
    *(unsigned char *)(a1 + 23) = 0;
    *(unsigned char *)a1 = 0;
  }
  else
  {
    uint64_t v37 = sub_1CD470048(&v40, a2, 1, a4);
    uint64_t v38 = (llvm::raw_ostream *)llvm::errs((llvm *)v37);
    uint64_t v39 = (void *)*((void *)v38 + 4);
    if (*((void *)v38 + 3) - (void)v39 > 7uLL)
    {
      *uint64_t v39 = 0xA202E656E6F6420;
      *((void *)v38 + 4) += 8;
    }
    else
    {
      llvm::raw_ostream::write(v38, " done. \n", 8uLL);
    }
    *(_OWORD *)a1 = *(_OWORD *)a5;
    *(void *)(a1 + 16) = *(void *)(a5 + 16);
    *(void *)(a5 + 8) = 0;
    *(void *)(a5 + 16) = 0;
    *(void *)a5 = 0;
  }
  llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)&v40);
}

void sub_1CBFB2498()
{
}

void sub_1CBFB24F4()
{
}

void sub_1CBFB2554(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CBFB258C(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
}

void sub_1CBFB25C4(int a1, llvm::Module *a2)
{
}

uint64_t sub_1CBFB2604(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(*(void *)a1 + 8) + 24);
  uint64_t v2 = (*(uint64_t (**)(uint64_t))(*(void *)v1 + 32))(v1);
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)v2 + 96))(v2, &llvm::BlockFrequencyInfoWrapperPass::ID)+ 32;
}

void sub_1CBFB2690(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CBFB26C8(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
}

void sub_1CBFB2700(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_1CBFB2740(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(*(void *)a1 + 8) + 24);
  uint64_t v2 = (*(uint64_t (**)(uint64_t))(*(void *)v1 + 32))(v1);
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)v2 + 96))(v2, &llvm::BlockFrequencyInfoWrapperPass::ID)+ 32;
}

void sub_1CBFB27C8()
{
}

void sub_1CBFB27F4()
{
}

uint64_t sub_1CBFB2820()
{
  char v2 = 0;
  int v1 = 1;
  uint64_t v3 = &v2;
  v4.n128_u64[0] = (unint64_t)"Show heat colors in call-graph";
  v4.n128_u64[1] = 30;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBCC4950, "callgraph-heat-colors", &v3, &v1, &v4);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCC4950, &dword_1CB82C000);
  char v2 = 0;
  int v1 = 1;
  uint64_t v3 = &v2;
  v4.n128_u64[0] = (unint64_t)"Show edges labeled with weights";
  v4.n128_u64[1] = 31;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBCC4A10, "callgraph-show-weights", &v3, &v1, &v4);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCC4A10, &dword_1CB82C000);
  char v2 = 0;
  int v1 = 1;
  uint64_t v3 = &v2;
  v4.n128_u64[0] = (unint64_t)"Show call-multigraph (do not remove parallel edges)";
  v4.n128_u64[1] = 51;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBCC4AD0, "callgraph-multigraph", &v3, &v1, &v4);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCC4AD0, &dword_1CB82C000);
  LODWORD(v3) = 1;
  v4.n128_u64[0] = (unint64_t)"The prefix used for the CallGraph dot file names.";
  v4.n128_u64[1] = 49;
  sub_1CD470D20(&v3, (long long *)&v4);
  return __cxa_atexit((void (*)(void *))sub_1CD41C8DC, &qword_1EBCC4B90, &dword_1CB82C000);
}

uint64_t llvm::getDefaultMaxUsesToExploreForCaptureTracking(llvm *this)
{
  return dword_1EBCC4CF8;
}

uint64_t llvm::CaptureTracker::shouldExplore()
{
  return 1;
}

BOOL llvm::CaptureTracker::isDereferenceableOrNull(llvm::CaptureTracker *this, uint64_t ***a2, const llvm::DataLayout *a3)
{
  uint64_t v3 = a3;
  __n128 v4 = a2;
  if (a2)
  {
    if (*((unsigned char *)a2 + 16) == 62)
    {
      char v6 = llvm::GetElementPtrInst::isInBounds((llvm::GetElementPtrInst *)a2);
      uint64_t v3 = a3;
      __n128 v4 = a2;
      if (v6) {
        return 1;
      }
    }
  }
  *(_WORD *)uint64_t v9 = 0;
  return llvm::Value::getPointerDereferenceableBytes(v4, v3, &v9[1], v9) != 0;
}

BOOL llvm::PointerMayBeCaptured(llvm *this, const llvm::Value *a2, BOOL a3, llvm::CaptureTracker *a4)
{
  uint64_t v7 = &v11;
  unint64_t v8 = &v11;
  uint64_t v9 = 1;
  int v10 = 0;
  v12[0] = &unk_1F2601EB8;
  v12[1] = &v7;
  char v13 = (char)a2;
  unsigned __int8 v14 = 0;
  llvm::PointerMayBeCaptured(this, (const llvm::Value *)v12, a4);
  int v4 = v14;
  if (v8 != v7)
  {
    int v6 = v14;
    free(v8);
    int v4 = v6;
  }
  return v4 != 0;
}

void llvm::PointerMayBeCaptured(llvm *this, const llvm::Value *a2, llvm::CaptureTracker *a3)
{
  int v3 = (int)a3;
  v18[20] = *MEMORY[0x1E4F143B8];
  if (!a3) {
    int v3 = dword_1EBCC4CF8;
  }
  int v14 = v3;
  int v15 = a2;
  unint64_t v16 = v18;
  uint64_t v17 = 0x1400000000;
  if (dword_1EBCC4CF8 >= 0x15) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  uint64_t v9 = v13;
  int v10 = v13;
  uint64_t v11 = 32;
  int v12 = 0;
  v8[0] = (llvm::SmallPtrSetImplBase *)&v9;
  v8[1] = (llvm::SmallPtrSetImplBase *)&v14;
  uint64_t v8[2] = (llvm::SmallPtrSetImplBase *)&v15;
  v8[3] = (llvm::SmallPtrSetImplBase *)&v16;
  if (sub_1CBFB31B0(v8, *((void *)this + 1)))
  {
    uint64_t v7 = v15;
    for (unsigned int i = v17; v17; unsigned int i = v17)
    {
      unint64_t v5 = v16[i - 1];
      LODWORD(v17) = i - 1;
      int v6 = llvm::DetermineUseCaptureKind(v5, (uint64_t (*)(uint64_t, llvm::Value *, uint64_t))sub_1CBFB3B0C, (uint64_t)&v7);
      if (v6 == 2)
      {
        if (!sub_1CBFB31B0(v8, *(void *)(*(void *)(v5 + 24) + 8))) {
          break;
        }
      }
      else if (v6 == 1 {
             && ((*(uint64_t (**)(const llvm::Value *, unint64_t))(*(void *)v15 + 32))(v15, v5) & 1) != 0)
      }
      {
        break;
      }
    }
  }
  if (v10 != v9) {
    free(v10);
  }
  if (v16 != v18) {
    free(v16);
  }
}

uint64_t llvm::PointerMayBeCapturedBefore(llvm *this, const llvm::Value *a2, BOOL a3, uint64_t a4, const llvm::Instruction *a5, const llvm::DominatorTree *a6, llvm::CaptureTracker *a7, uint64_t a8, const llvm::LoopInfo *a9)
{
  if (a5)
  {
    v11[0] = &unk_1F2601EF8;
    v11[1] = a4;
    v11[2] = a5;
    char v12 = (char)a2;
    char v13 = (char)a6;
    LOBYTE(v14[0]) = 0;
    *(void *)&v14[3] = a8;
    llvm::PointerMayBeCaptured(this, (const llvm::Value *)v11, a7);
    return LOBYTE(v14[0]);
  }
  else
  {
    return llvm::PointerMayBeCaptured(this, a2, 0, a7);
  }
}

uint64_t llvm::FindEarliestCapture(llvm *a1, uint64_t a2, char a3, int a4, uint64_t a5, uint64_t a6, llvm::CaptureTracker *a7)
{
  v8[0] = &unk_1F2601F38;
  v8[1] = a6;
  uint64_t v9 = 0;
  uint64_t v10 = a5;
  char v11 = a3;
  char v12 = 0;
  uint64_t v13 = a2;
  llvm::PointerMayBeCaptured(a1, (const llvm::Value *)v8, a7);
  return v9;
}

uint64_t llvm::DetermineUseCaptureKind(unint64_t a1, uint64_t (*a2)(uint64_t, llvm::Value *, uint64_t), uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 24);
  uint64_t result = 0;
  switch(*(unsigned char *)(v4 + 16))
  {
    case '<':
      return *(_WORD *)(v4 + 18) & 1;
    case '=':
      int v31 = *(_DWORD *)(v4 + 20);
      if ((v31 & 0x40000000) != 0) {
        uint64_t v32 = *(void *)(v4 - 8);
      }
      else {
        uint64_t v32 = v4 - 32 * (v31 & 0x7FFFFFF);
      }
      if (((a1 - v32) & 0x1FFFFFFFE0) == 0) {
        return 1;
      }
      return *(_WORD *)(v4 + 18) & 1;
    case '>':
    case 'M':
    case 'N':
    case 'S':
    case 'U':
      return 2;
    case '?':
    case 'B':
    case 'C':
    case 'D':
    case 'E':
    case 'F':
    case 'G':
    case 'H':
    case 'I':
    case 'J':
    case 'K':
    case 'L':
    case 'O':
    case 'P':
    case 'R':
    case 'V':
    case 'W':
      return 1;
    case '@':
      int v11 = *(_DWORD *)(v4 + 20);
      if ((v11 & 0x40000000) != 0) {
        uint64_t v12 = *(void *)(v4 - 8);
      }
      else {
        uint64_t v12 = v4 + 32 * -(v11 & 0x7FFFFFF);
      }
      uint64_t v13 = (a1 - v12) & 0x1FFFFFFFE0;
      if (v13 == 32 || v13 == 64) {
        return 1;
      }
      return *(_WORD *)(v4 + 18) & 1;
    case 'A':
      int v33 = *(_DWORD *)(v4 + 20);
      if ((v33 & 0x40000000) != 0) {
        uint64_t v34 = *(void *)(v4 - 8);
      }
      else {
        uint64_t v34 = v4 - 32 * (v33 & 0x7FFFFFF);
      }
      if (((a1 - v34) & 0x1FFFFFFFE0) == 0x20) {
        return 1;
      }
      return *(_WORD *)(v4 + 18) & 1;
    case 'Q':
      int v16 = *(_DWORD *)(v4 + 20);
      if ((v16 & 0x40000000) != 0) {
        uint64_t v17 = *(void *)(v4 - 8);
      }
      else {
        uint64_t v17 = v4 - 32 * (v16 & 0x7FFFFFF);
      }
      unint64_t v18 = a1 - v17;
      uint64_t v19 = 1 - ((a1 - v17) >> 5);
      uint64_t v20 = *(unsigned char **)(v17 + 32 * v19);
      if (v20) {
        BOOL v21 = v20[16] == 19;
      }
      else {
        BOOL v21 = 0;
      }
      if (!v21) {
        goto LABEL_68;
      }
      if (*(_DWORD *)(*(void *)v20 + 8) > 0xFFu
        || (char v22 = llvm::Value::stripPointerCasts(*(llvm::Value **)a1), v23 = *((unsigned __int8 *)v22 + 16), v23 < 0x1C)
        || ((unsigned int v24 = v23 - 33, v25 = v24 > 0x33, v26 = (1 << v24) & 0x8000000000041, !v25)
          ? (BOOL v27 = v26 == 0)
          : (BOOL v27 = 1),
            v27 || (sub_1CBF5BCC4((uint64_t)v22, 19) & 1) == 0))
      {
        if ((uint64_t v28 = *(void *)(*(void *)(*(void *)(v4 + 40) + 56) + 112)) != 0
          && (*(unsigned char *)(v28 + 17) & 1) != 0
          || ((int v29 = *(_DWORD *)(v4 + 20), (v29 & 0x40000000) != 0)
            ? (uint64_t v30 = *(void *)(v4 - 8))
            : (uint64_t v30 = v4 - 32 * (v29 & 0x7FFFFFF)),
              (__int16 v42 = llvm::Value::stripPointerCastsSameRepresentation(*(llvm::Value **)(v30 + (v18 & 0x1FFFFFFFE0))),
               !a2)
           || (a2(a3, v42, *(void *)(*(void *)(*(void *)(v4 + 40) + 56) + 40) + 272) & 1) == 0))
        {
LABEL_68:
          int v43 = *(_DWORD *)(v4 + 20);
          uint64_t v44 = (v43 & 0x40000000) != 0 ? *(void *)(v4 - 8) : v4 - 32 * (v43 & 0x7FFFFFF);
          uint64_t v45 = *(void *)(v44 + 32 * v19);
          if (!v45 || *(unsigned char *)(v45 + 16) != 60 || *(unsigned char *)(*(void *)(v45 - 32) + 16) != 3) {
            return 1;
          }
        }
      }
      return 0;
    case 'T':
      goto LABEL_4;
    case 'X':
      return result;
    default:
      if (*(unsigned char *)(v4 + 16) != 33) {
        return 1;
      }
LABEL_4:
      uint64_t v6 = *(void *)(v4 + 64);
      if (v6 && (*(unsigned char *)(v6 + 17) & 0x30) != 0) {
        goto LABEL_9;
      }
      int v7 = *(_DWORD *)(v4 + 20);
      if ((v7 & 0x80000000) == 0) {
        goto LABEL_7;
      }
      uint64_t v46 = v4 - 32 * (v7 & 0x7FFFFFF);
      uint64_t v49 = *(void *)(v46 - 8);
      uint64_t v47 = v46 - 8;
      uint64_t v48 = v49;
      if (!v49) {
        goto LABEL_7;
      }
      uint64_t v50 = -v48;
      break;
  }
  do
  {
    unsigned int v51 = *(_DWORD *)(*(void *)(v47 + v50) + 8);
    BOOL v25 = v51 > 7;
    int v52 = (1 << v51) & 0x83;
    if (v25 || v52 == 0) {
      goto LABEL_13;
    }
    v50 += 16;
  }
  while (v50);
LABEL_7:
  if ((llvm::CallBase::hasFnAttrOnCalledFunction(v4, 45) & 1) != 0
    || llvm::CallBase::hasFnAttrOnCalledFunction(v4, 44))
  {
LABEL_9:
    uint64_t v8 = *(void *)(v4 + 64);
    if ((v8 && (*(unsigned char *)(v8 + 16) & 0x20) != 0 || llvm::CallBase::hasFnAttrOnCalledFunction(v4, 37))
      && *(unsigned char *)(*(void *)v4 + 8) == 7)
    {
      return 0;
    }
  }
LABEL_13:
  if (llvm::isIntrinsicReturningPointerAliasingArgumentWithoutCapturing(v4, 1)) {
    return 2;
  }
  if (sub_1CBFB3AB0(v4))
  {
    uint64_t v9 = *(void *)(v4 - 32 * (*(_DWORD *)(v4 + 20) & 0x7FFFFFF) + 96);
    uint64_t v10 = *(unsigned int *)(v9 + 32);
    if (v10 > 0x40)
    {
      int v35 = 0;
      int64_t v36 = (unint64_t)(v10 + 63) >> 6;
      do
      {
        BOOL v25 = v36-- < 1;
        if (v25) {
          break;
        }
        unint64_t v37 = *(void *)(*(void *)(v9 + 24) + 8 * v36);
        v35 += __clz(v37);
      }
      while (!v37);
      int v38 = v10 | 0xFFFFFFC0;
      if ((v10 & 0x3F) == 0) {
        int v38 = 0;
      }
      if (v35 + v38 != v10) {
        return 1;
      }
    }
    else if (*(void *)(v9 + 24))
    {
      return 1;
    }
  }
  if (v4 - 32 != a1)
  {
    unint64_t v39 = v4 - 32 * (*(_DWORD *)(v4 + 20) & 0x7FFFFFF);
    if (v39 <= a1)
    {
      int v40 = *(unsigned __int8 *)(v4 + 16);
      if (v40 == 84) {
        uint64_t v41 = 0;
      }
      else {
        uint64_t v41 = v40 == 39 ? (*(_DWORD *)(v4 + 80) + 1) : 2;
      }
      if (v4 - 32 * v41 - 32 > a1 && !sub_1CBF5BC2C(v4, (a1 - v39) >> 5, 22)) {
        return 1;
      }
    }
  }
  return 0;
}

uint64_t sub_1CBFB31B0(llvm::SmallPtrSetImplBase **a1, uint64_t a2)
{
  if (!a2) {
    return 1;
  }
  uint64_t v2 = a2;
  while (1)
  {
    uint64_t v4 = *a1;
    uint64_t v5 = *((unsigned int *)*a1 + 5);
    int v6 = *((_DWORD *)*a1 + 6);
    if ((v5 - v6) >= *(_DWORD *)a1[1]) {
      break;
    }
    uint64_t v7 = *((void *)v4 + 1);
    if (v7 == *(void *)v4)
    {
      if (v5)
      {
        uint64_t v8 = 0;
        uint64_t v9 = 8 * v5;
        uint64_t v10 = (void *)*((void *)v4 + 1);
        while (*v10 != v2)
        {
          if (*v10 == -2) {
            uint64_t v8 = v10;
          }
          ++v10;
          v9 -= 8;
          if (!v9)
          {
            if (!v8) {
              goto LABEL_12;
            }
            *uint64_t v8 = v2;
            *((_DWORD *)v4 + 6) = v6 - 1;
            goto LABEL_36;
          }
        }
        goto LABEL_39;
      }
LABEL_12:
      unsigned int v11 = *((_DWORD *)v4 + 4);
      if (v5 < v11)
      {
        *((_DWORD *)v4 + 5) = v5 + 1;
        *(void *)(v7 + 8 * v5) = v2;
        goto LABEL_36;
      }
    }
    else
    {
      unsigned int v11 = *((_DWORD *)v4 + 4);
    }
    if (3 * v11 <= 4 * ((int)v5 - v6))
    {
      if (v11 >= 0x40) {
        v11 *= 2;
      }
      else {
        unsigned int v11 = 128;
      }
LABEL_46:
      llvm::SmallPtrSetImplBase::Grow(*a1, v11);
      unsigned int v11 = *((_DWORD *)v4 + 4);
      uint64_t v7 = *((void *)v4 + 1);
      goto LABEL_17;
    }
    if (v11 - v5 < v11 >> 3) {
      goto LABEL_46;
    }
LABEL_17:
    unsigned int v12 = v11 - 1;
    unsigned int v13 = (v11 - 1) & ((v2 >> 4) ^ (v2 >> 9));
    int v14 = (void *)(v7 + 8 * v13);
    uint64_t v15 = *v14;
    if (*v14 != -1)
    {
      int v16 = 0;
      int v17 = 1;
      while (v15 != v2)
      {
        if (v16) {
          BOOL v18 = 0;
        }
        else {
          BOOL v18 = v15 == -2;
        }
        if (v18) {
          int v16 = v14;
        }
        unsigned int v19 = v13 + v17++;
        unsigned int v13 = v19 & v12;
        int v14 = (void *)(v7 + 8 * (v19 & v12));
        uint64_t v15 = *v14;
        if (*v14 == -1) {
          goto LABEL_29;
        }
      }
      goto LABEL_39;
    }
    int v16 = 0;
LABEL_29:
    if (v16) {
      uint64_t v20 = v16;
    }
    else {
      uint64_t v20 = v14;
    }
    if (*v20 == v2) {
      goto LABEL_39;
    }
    if (*v20 == -2) {
      --*((_DWORD *)v4 + 6);
    }
    else {
      ++*((_DWORD *)v4 + 5);
    }
    *uint64_t v20 = v2;
LABEL_36:
    if ((*(unsigned int (**)(void, uint64_t))(**(void **)a1[2] + 24))(*(void *)a1[2], v2))
    {
      BOOL v21 = a1[3];
      unint64_t v22 = *((unsigned int *)v21 + 2);
      if (v22 >= *((unsigned int *)v21 + 3)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)v21 + 8 * v22) = v2;
      ++*((_DWORD *)v21 + 2);
    }
LABEL_39:
    uint64_t v2 = *(void *)(v2 + 8);
    if (!v2) {
      return 1;
    }
  }
  (*(void (**)(void))(**(void **)a1[2] + 16))(*(void *)a1[2]);
  return 0;
}

uint64_t llvm::isNonEscapingLocalObject(llvm *a1, uint64_t a2)
{
  if (a2)
  {
    int v17 = a1;
    char v18 = 0;
    uint64_t v4 = a2 + 8;
    if (*(unsigned char *)a2)
    {
      int v5 = 8;
    }
    else
    {
      int v5 = *(_DWORD *)(a2 + 16);
      if (!v5)
      {
        unsigned int v12 = 0;
LABEL_10:
        unsigned int v13 = sub_1CBFB3BE4(a2, (uint64_t)&v17, &v17, v12);
        *unsigned int v13 = v17;
        *((unsigned char *)v13 + 8) = v18;
        goto LABEL_11;
      }
      uint64_t v4 = *(void *)(a2 + 8);
    }
    int v6 = v5 - 1;
    uint64_t v7 = (v5 - 1) & ((a1 >> 4) ^ (a1 >> 9));
    uint64_t v8 = (llvm **)(v4 + 16 * v7);
    uint64_t v9 = *v8;
    if (*v8 == a1) {
      return *(unsigned __int8 *)(v4 + 16 * v7 + 8) != 0;
    }
    uint64_t v10 = 0;
    int v11 = 1;
    while (v9 != (llvm *)-4096)
    {
      if (v10) {
        BOOL v15 = 0;
      }
      else {
        BOOL v15 = v9 == (llvm *)-8192;
      }
      if (v15) {
        uint64_t v10 = v8;
      }
      int v16 = v7 + v11++;
      uint64_t v7 = v16 & v6;
      uint64_t v8 = (llvm **)(v4 + 16 * v7);
      uint64_t v9 = *v8;
      if (*v8 == a1) {
        return *(unsigned __int8 *)(v4 + 16 * v7 + 8) != 0;
      }
    }
    if (v10) {
      unsigned int v12 = v10;
    }
    else {
      unsigned int v12 = v8;
    }
    goto LABEL_10;
  }
  unsigned int v13 = 0;
LABEL_11:
  uint64_t result = llvm::isIdentifiedFunctionLocal(a1, (const llvm::Value *)a2);
  if (result)
  {
    uint64_t result = !llvm::PointerMayBeCaptured(a1, 0, 0, 0);
    if (a2) {
      *((unsigned char *)v13 + 8) = result;
    }
  }
  return result;
}

void sub_1CBFB3548()
{
}

uint64_t sub_1CBFB355C(uint64_t result)
{
  *(unsigned char *)(result + 17) = 1;
  return result;
}

uint64_t sub_1CBFB3568(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 24);
  if (*(unsigned char *)(v2 + 16) != 29 || (uint64_t v3 = *(unsigned __int8 *)(a1 + 16), *(unsigned char *)(a1 + 16)))
  {
    uint64_t v4 = *(uint64_t **)(a1 + 8);
    uint64_t v6 = *v4;
    uint64_t v5 = v4[1];
    if (v5 == *v4)
    {
      uint64_t v7 = *((unsigned int *)v4 + 5);
      uint64_t v8 = (void *)(v5 + 8 * v7);
      if (v7)
      {
        uint64_t v9 = 0;
        uint64_t v10 = 8 * v7;
        while (*(void *)(v5 + v9) != v2)
        {
          v9 += 8;
          if (v10 == v9) {
            goto LABEL_21;
          }
        }
        uint64_t v8 = (void *)(v5 + v9);
      }
LABEL_21:
      uint64_t v6 = v4[1];
    }
    else
    {
      uint64_t v11 = *((unsigned int *)v4 + 4);
      int v12 = v11 - 1;
      unsigned int v13 = (v11 - 1) & ((v2 >> 4) ^ (v2 >> 9));
      uint64_t v8 = (void *)(v5 + 8 * v13);
      uint64_t v14 = *v8;
      if (*v8 == -1)
      {
        BOOL v15 = 0;
LABEL_29:
        if (v15) {
          uint64_t v8 = v15;
        }
        if (*v8 != v2) {
          uint64_t v8 = (void *)(v5 + 8 * v11);
        }
      }
      else
      {
        BOOL v15 = 0;
        int v16 = 1;
        while (v14 != v2)
        {
          if (v15) {
            BOOL v17 = 0;
          }
          else {
            BOOL v17 = v14 == -2;
          }
          if (v17) {
            BOOL v15 = v8;
          }
          unsigned int v18 = v13 + v16++;
          unsigned int v13 = v18 & v12;
          uint64_t v8 = (void *)(v5 + 8 * (v18 & v12));
          uint64_t v14 = *v8;
          if (*v8 == -1) {
            goto LABEL_29;
          }
        }
      }
    }
    uint64_t v19 = 16;
    if (v5 == v6) {
      uint64_t v19 = 20;
    }
    if (v8 == (void *)(v5 + 8 * *(unsigned int *)((char *)v4 + v19)))
    {
      uint64_t v3 = 1;
      *(unsigned char *)(a1 + 17) = 1;
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

void sub_1CBFB3684()
{
}

uint64_t sub_1CBFB3698(uint64_t result)
{
  *(unsigned char *)(result + 26) = 1;
  return result;
}

uint64_t sub_1CBFB36A4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (*(unsigned char *)(v3 + 16) == 29 && !*(unsigned char *)(a1 + 24)) {
    return 0;
  }
  if (*(void *)(a1 + 8) != v3) {
    llvm::DominatorTreeBase<llvm::BasicBlock,false>::isReachableFromEntry();
  }
  if (!*(unsigned char *)(a1 + 25)) {
    return 0;
  }
  uint64_t result = 1;
  *(unsigned char *)(a1 + 26) = 1;
  return result;
}

void sub_1CBFB372C()
{
}

uint64_t sub_1CBFB3740(uint64_t result)
{
  *(unsigned char *)(result + 33) = 1;
  uint64_t v1 = *(void *)(*(void *)(result + 40) + 80);
  if (v1) {
    uint64_t v2 = v1 - 24;
  }
  else {
    uint64_t v2 = 0;
  }
  uint64_t v3 = *(void *)(v2 + 48);
  if (v3) {
    uint64_t v4 = v3 - 24;
  }
  else {
    uint64_t v4 = 0;
  }
  *(void *)(result + 16) = v4;
  return result;
}

uint64_t sub_1CBFB3774(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (*(unsigned char *)(v3 + 16) != 29 || *(unsigned char *)(a1 + 32))
  {
    uint64_t v4 = *(uint64_t **)(a1 + 8);
    uint64_t v6 = *v4;
    uint64_t v5 = v4[1];
    if (v5 == *v4)
    {
      uint64_t v7 = *((unsigned int *)v4 + 5);
      uint64_t v8 = (void *)(v5 + 8 * v7);
      if (v7)
      {
        uint64_t v9 = 0;
        uint64_t v10 = 8 * v7;
        while (*(void *)(v5 + v9) != v3)
        {
          v9 += 8;
          if (v10 == v9) {
            goto LABEL_21;
          }
        }
        uint64_t v8 = (void *)(v5 + v9);
      }
LABEL_21:
      uint64_t v6 = v4[1];
    }
    else
    {
      uint64_t v11 = *((unsigned int *)v4 + 4);
      int v12 = v11 - 1;
      unsigned int v13 = (v11 - 1) & ((v3 >> 4) ^ (v3 >> 9));
      uint64_t v8 = (void *)(v5 + 8 * v13);
      uint64_t v14 = *v8;
      if (*v8 == -1)
      {
        BOOL v15 = 0;
LABEL_32:
        if (v15) {
          uint64_t v8 = v15;
        }
        if (*v8 != v3) {
          uint64_t v8 = (void *)(v5 + 8 * v11);
        }
      }
      else
      {
        BOOL v15 = 0;
        int v16 = 1;
        while (v14 != v3)
        {
          if (v15) {
            BOOL v17 = 0;
          }
          else {
            BOOL v17 = v14 == -2;
          }
          if (v17) {
            BOOL v15 = v8;
          }
          unsigned int v18 = v13 + v16++;
          unsigned int v13 = v18 & v12;
          uint64_t v8 = (void *)(v5 + 8 * (v18 & v12));
          uint64_t v14 = *v8;
          if (*v8 == -1) {
            goto LABEL_32;
          }
        }
      }
    }
    BOOL v17 = v5 == v6;
    uint64_t v19 = 16;
    if (v17) {
      uint64_t v19 = 20;
    }
    if (v8 == (void *)(v5 + 8 * *(unsigned int *)((char *)v4 + v19)))
    {
      uint64_t v20 = *(void *)(a1 + 16);
      if (!v20) {
        goto LABEL_42;
      }
      uint64_t v21 = *(void *)(v20 + 40);
      if (v21 != *(void *)(v3 + 40)) {
        llvm::DominatorTreeBase<llvm::BasicBlock,false>::dominates();
      }
      int v22 = *(__int16 *)(v21 + 18);
      if ((v22 & 0x80000000) == 0)
      {
        uint64_t v23 = *(void *)(v21 + 48);
        if (v23 != v21 + 40)
        {
          int v24 = 0;
          do
          {
            uint64_t v25 = v23 - 24;
            if (!v23) {
              uint64_t v25 = 0;
            }
            *(_DWORD *)(v25 + 56) = v24++;
            uint64_t v23 = *(void *)(v23 + 8);
          }
          while (v23 != v21 + 40);
        }
        *(_WORD *)(v21 + 18) = v22 | 0x8000;
      }
      if (*(_DWORD *)(v3 + 56) < *(_DWORD *)(v20 + 56)) {
LABEL_42:
      }
        *(void *)(a1 + 16) = v3;
      *(unsigned char *)(a1 + 33) = 1;
    }
  }
  return 0;
}

uint64_t sub_1CBFB3AB0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 16) == 84
    && (uint64_t v1 = *(void *)(a1 - 32)) != 0
    && !*(unsigned char *)(v1 + 16)
    && *(void *)(v1 + 24) == *(void *)(a1 + 72)
    && (*(unsigned char *)(v1 + 33) & 0x20) != 0
    && (unsigned int v2 = *(_DWORD *)(v1 + 36) - 194, v2 <= 5))
  {
    return (0x2Du >> v2) & 1;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1CBFB3B0C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 40))();
}

uint64_t sub_1CBFB3B34(uint64_t a1, void *a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 8;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      uint64_t v7 = 0;
      uint64_t result = 0;
      goto LABEL_8;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v4 - 1);
  uint64_t v7 = (void *)(v3 + 16 * v6);
  uint64_t v8 = *v7;
  if (*a2 == *v7)
  {
    uint64_t result = 1;
  }
  else
  {
    uint64_t v9 = 0;
    int v10 = 1;
    uint64_t result = 1;
    while (v8 != -4096)
    {
      if (v9) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -8192;
      }
      if (v12) {
        uint64_t v9 = v7;
      }
      unsigned int v13 = v6 + v10++;
      unsigned int v6 = v13 & v5;
      uint64_t v7 = (void *)(v3 + 16 * (v13 & v5));
      uint64_t v8 = *v7;
      if (*a2 == *v7) {
        goto LABEL_8;
      }
    }
    uint64_t result = 0;
    if (v9) {
      uint64_t v7 = v9;
    }
  }
LABEL_8:
  *a3 = v7;
  return result;
}

void *sub_1CBFB3BE4(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  int v4 = *(_DWORD *)a1;
  int v5 = *(_DWORD *)a1 >> 1;
  if (*(_DWORD *)a1) {
    unsigned int v6 = 8;
  }
  else {
    unsigned int v6 = *(_DWORD *)(a1 + 16);
  }
  if (4 * v5 + 4 >= 3 * v6)
  {
    uint64_t v9 = (int *)a1;
    sub_1CBFB3D60(a1, 2 * v6);
    a1 = (uint64_t)v9;
    int v11 = *v9;
    int v10 = v9 + 2;
    int v4 = v11;
    if (v11)
    {
      int v12 = 8;
    }
    else
    {
      int v12 = *(_DWORD *)(a1 + 16);
      if (!v12)
      {
        int v7 = 0;
        a4 = 0;
        goto LABEL_7;
      }
      int v10 = *(_DWORD **)(a1 + 8);
    }
    int v7 = v4 & 1;
    int v13 = v12 - 1;
    unsigned int v14 = ((*a3 >> 4) ^ (*a3 >> 9)) & v13;
    a4 = &v10[4 * v14];
    uint64_t v15 = *a4;
    if (*a3 != *a4)
    {
      int v16 = 0;
      int v17 = 1;
      while (v15 != -4096)
      {
        if (v16) {
          BOOL v18 = 0;
        }
        else {
          BOOL v18 = v15 == -8192;
        }
        if (v18) {
          int v16 = a4;
        }
        unsigned int v19 = v14 + v17++;
        unsigned int v14 = v19 & v13;
        a4 = &v10[4 * v14];
        uint64_t v15 = *a4;
        if (*a3 == *a4) {
          goto LABEL_7;
        }
      }
      if (v16) {
        a4 = v16;
      }
    }
  }
  else
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 4) <= v6 >> 3)
    {
      int v22 = (int *)a1;
      sub_1CBFB3D60(a1, v6);
      uint64_t v23 = 0;
      sub_1CBFB3B34((uint64_t)v22, a3, &v23);
      a1 = (uint64_t)v22;
      a4 = v23;
      int v4 = *v22;
    }
    int v7 = v4 & 1;
  }
LABEL_7:
  *(_DWORD *)a1 = (v4 & 0xFFFFFFFE | v7) + 2;
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 4);
  }
  return a4;
}

int *sub_1CBFB3D60(uint64_t a1, unsigned int a2)
{
  v14[16] = *MEMORY[0x1E4F143B8];
  if (a2 >= 9)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    int v11 = *(uint64_t **)(a1 + 8);
    uint64_t v12 = *(unsigned int *)(a1 + 16);
    if (a2 > 8)
    {
      uint64_t v13 = a2;
      *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CBFB3EF0((int *)a1, v11, &v11[2 * v12]);
    llvm::deallocate_buffer((llvm *)v11, (void *)(16 * v12));
  }
  uint64_t v6 = 0;
  int v7 = v14;
  do
  {
    uint64_t v8 = *(void *)(a1 + v6 + 8);
    if ((v8 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      *int v7 = v8;
      *((unsigned char *)v7 + 8) = *(unsigned char *)(a1 + v6 + 16);
      v7 += 2;
    }
    v6 += 16;
  }
  while (v6 != 128);
  if (a2 > 8)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v9 = a2;
    *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v9;
  }
  return sub_1CBFB3EF0((int *)a1, v14, v7);
}

int *sub_1CBFB3EF0(int *result, uint64_t *a2, uint64_t *a3)
{
  int v3 = *result;
  *result &= 1u;
  result[1] = 0;
  if (v3)
  {
    uint64_t v6 = result + 34;
    int v5 = result + 2;
  }
  else
  {
    uint64_t v4 = result[4];
    if (!v4) {
      goto LABEL_5;
    }
    int v5 = (void *)*((void *)result + 1);
    uint64_t v6 = &v5[2 * v4];
  }
  do
  {
    *int v5 = -4096;
    v5 += 2;
  }
  while (v5 != v6);
LABEL_5:
  while (a2 != a3)
  {
    uint64_t v7 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      if (*(unsigned char *)result)
      {
        int v8 = 8;
        uint64_t v9 = result + 2;
      }
      else
      {
        uint64_t v9 = (int *)*((void *)result + 1);
        int v8 = result[4];
      }
      int v10 = v8 - 1;
      unsigned int v11 = (v8 - 1) & ((v7 >> 4) ^ (v7 >> 9));
      uint64_t v12 = (uint64_t *)&v9[4 * v11];
      uint64_t v13 = *v12;
      if (v7 != *v12)
      {
        unsigned int v14 = 0;
        int v15 = 1;
        while (v13 != -4096)
        {
          if (v14) {
            BOOL v16 = 0;
          }
          else {
            BOOL v16 = v13 == -8192;
          }
          if (v16) {
            unsigned int v14 = v12;
          }
          unsigned int v17 = v11 + v15++;
          unsigned int v11 = v17 & v10;
          uint64_t v12 = (uint64_t *)&v9[4 * (v17 & v10)];
          uint64_t v13 = *v12;
          if (v7 == *v12) {
            goto LABEL_14;
          }
        }
        if (v14) {
          uint64_t v12 = v14;
        }
      }
LABEL_14:
      *uint64_t v12 = v7;
      *((unsigned char *)v12 + 8) = *((unsigned char *)a2 + 8);
      *result += 2;
    }
    a2 += 2;
  }
  return result;
}

uint64_t sub_1CBFB3FF8()
{
  int v4 = 1;
  *(void *)&long long v3 = "Maximal number of uses to explore.";
  *((void *)&v3 + 1) = 34;
  int v1 = 100;
  unsigned int v2 = &v1;
  sub_1CD413D64((uint64_t)&unk_1EBCC4C78, "capture-tracking-max-uses-to-explore", &v4, &v3, &v2);
  return __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCC4C78, &dword_1CB82C000);
}

uint64_t llvm::getICmpCode(int a1)
{
  return dword_1CFAC3108[a1 - 32];
}

void *llvm::getPredForICmpCode(int a1, int a2, _DWORD *a3, int *a4)
{
  if (a1 == 6)
  {
    BOOL v4 = a2 == 0;
    int v5 = 37;
    int v6 = 41;
LABEL_3:
    if (!v4) {
      int v5 = v6;
    }
LABEL_5:
    *a4 = v5;
    return 0;
  }
  else
  {
    switch(a1)
    {
      case 1:
        BOOL v4 = a2 == 0;
        int v5 = 34;
        int v6 = 38;
        goto LABEL_3;
      case 2:
        int v5 = 32;
        goto LABEL_5;
      case 3:
        BOOL v4 = a2 == 0;
        int v5 = 35;
        int v6 = 39;
        goto LABEL_3;
      case 4:
        BOOL v4 = a2 == 0;
        int v5 = 36;
        int v6 = 40;
        goto LABEL_3;
      case 5:
        int v5 = 33;
        goto LABEL_5;
      case 6:
        __break(1u);
        goto LABEL_11;
      case 7:
LABEL_11:
        sub_1CB90C994(a3);
        unint64_t v9 = 1;
        break;
      default:
        sub_1CB90C994(a3);
        unint64_t v9 = 0;
        break;
    }
    return llvm::ConstantInt::get(v8, v9, 0);
  }
}

uint64_t llvm::predicatesFoldable(int a1, int a2)
{
  BOOL v3 = (a1 - 38) < 4 && (a2 & 0xFFFFFFFE) == 32;
  if ((a2 - 38) <= 3) {
    BOOL v4 = (a1 & 0xFFFFFFFE) == 32;
  }
  else {
    BOOL v4 = v3;
  }
  if (!v3) {
    BOOL v3 = v4;
  }
  return (a1 - 38) < 4 == (a2 - 38) < 4 || v3;
}

void *llvm::getPredForFCmpCode(int a1, _DWORD *a2, _DWORD *a3)
{
  *a3 = a1;
  if (a1)
  {
    if (a1 != 15) {
      return 0;
    }
    sub_1CB90C994(a2);
    unint64_t v5 = 1;
  }
  else
  {
    BOOL v4 = (llvm::FixedVectorType *)(**(void **)a2 + 1888);
    if (a2 && (a2[2] & 0xFE) == 0x12) {
      llvm::VectorType::get(v4, (llvm::Type *)(a2[8] | ((unint64_t)(a2[2] == 19) << 32)));
    }
    unint64_t v5 = 0;
  }

  return llvm::ConstantInt::get(v4, v5, 0);
}

uint64_t llvm::decomposeBitTestICmp(uint64_t a1, unsigned __int8 *a2, int *a3, uint64_t *a4, int8x8_t ***a5, int a6)
{
  uint64_t v57 = 0;
  unsigned int v58 = 0;
  uint64_t v56 = &v58;
  uint64_t result = sub_1CBF528D8((uint64_t)&v56, a2);
  if (result)
  {
    if (!(!v12 & v11))
    {
      switch(*a3)
      {
        case '""':
          unsigned int v50 = v58[1].u32[0];
          if (v50 > 0x40) {
            operator new[]();
          }
          int8x8_t v49 = *v58;
          llvm::APInt::operator+=((uint64_t)&v49, 1uLL);
          unsigned int v16 = v50;
          LODWORD(v57) = v50;
          uint64_t v56 = (int8x8_t **)v49;
          unsigned int v50 = 0;
          if (v16 <= 0x40)
          {
            if (!*(void *)&v49 || (*(void *)&v49 & (*(void *)&v49 - 1)) != 0) {
              return 0;
            }
            goto LABEL_21;
          }
          int8x8_t v40 = v49;
          int v41 = llvm::APInt::countPopulationSlowCase((uint64_t)&v56);
          if (v40)
          {
            MEMORY[0x1D25D9CB0](*(void *)&v40, 0x1000C8000313F17);
            if (v50 >= 0x41)
            {
              if (v49) {
                MEMORY[0x1D25D9CB0](*(void *)&v49, 0x1000C8000313F17);
              }
            }
          }
          if (v41 == 1)
          {
LABEL_21:
            unsigned int v17 = v58[1].u32[0];
            unsigned int v48 = v17;
            if (v17 > 0x40) {
              operator new[]();
            }
            unint64_t v18 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v17;
            if (!v17) {
              unint64_t v18 = 0;
            }
            unint64_t v19 = v18 & ~*(void *)v58;
            if (*((_DWORD *)a5 + 2) > 0x40u && *a5) {
              MEMORY[0x1D25D9CB0](*a5, 0x1000C8000313F17);
            }
            *a5 = (int8x8_t **)v19;
            *((_DWORD *)a5 + 2) = v17;
            goto LABEL_12;
          }
          return 0;
        case '#':
          unsigned int v35 = v58[1].u32[0];
          if (v35 > 0x40)
          {
            if (llvm::APInt::countPopulationSlowCase((uint64_t)v58) == 1)
            {
              __int32 v47 = v35;
              operator new[]();
            }
            return 0;
          }
          int8x8_t v36 = *v58;
          uint8x8_t v37 = (uint8x8_t)vcnt_s8(*v58);
          v37.i16[0] = vaddlv_u8(v37);
          if (v37.u32[0] != 1) {
            return 0;
          }
          __int32 v47 = v58[1].i32[0];
          uint64_t v46 = (int8x8_t **)v36;
          sub_1CBA14940((uint64_t)&v46);
          llvm::APInt::operator++((uint64_t)&v46);
          unsigned int v14 = v47;
          int v38 = v46;
          __int32 v47 = 0;
          if (*((_DWORD *)a5 + 2) <= 0x40u || !*a5)
          {
            *a5 = v46;
            goto LABEL_11;
          }
          MEMORY[0x1D25D9CB0](*a5, 0x1000C8000313F17);
          unsigned int v45 = v47;
          *a5 = v38;
          *((_DWORD *)a5 + 2) = v14;
          if (v45 >= 0x41 && v46) {
            MEMORY[0x1D25D9CB0](v46, 0x1000C8000313F17);
          }
          goto LABEL_12;
        case '$':
          unsigned int v20 = v58[1].u32[0];
          if (v20 > 0x40)
          {
            if (llvm::APInt::countPopulationSlowCase((uint64_t)v58) == 1)
            {
              __int32 v55 = v20;
              operator new[]();
            }
            return 0;
          }
          int8x8_t v21 = *v58;
          uint8x8_t v22 = (uint8x8_t)vcnt_s8(*v58);
          v22.i16[0] = vaddlv_u8(v22);
          if (v22.u32[0] != 1) {
            return 0;
          }
          __int32 v55 = v58[1].i32[0];
          uint64_t v23 = ~*(void *)&v21;
          unint64_t v24 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v20;
          if (!v20) {
            unint64_t v24 = 0;
          }
          unint64_t v54 = v24 & v23;
          llvm::APInt::operator++((uint64_t)&v54);
          unsigned int v25 = v55;
          uint64_t v26 = (int8x8_t **)v54;
          __int32 v55 = 0;
          if (*((_DWORD *)a5 + 2) <= 0x40u)
          {
            *a5 = (int8x8_t **)v54;
            goto LABEL_32;
          }
          if (*a5) {
            MEMORY[0x1D25D9CB0](*a5, 0x1000C8000313F17);
          }
          unsigned int v42 = v55;
          *a5 = v26;
          *((_DWORD *)a5 + 2) = v25;
          if (v42 >= 0x41 && v54) {
            MEMORY[0x1D25D9CB0](v54, 0x1000C8000313F17);
          }
          goto LABEL_39;
        case '%':
          unsigned int v53 = v58[1].u32[0];
          if (v53 > 0x40) {
            operator new[]();
          }
          int8x8_t v52 = *v58;
          llvm::APInt::operator+=((uint64_t)&v52, 1uLL);
          unsigned int v28 = v53;
          LODWORD(v57) = v53;
          uint64_t v56 = (int8x8_t **)v52;
          unsigned int v53 = 0;
          if (v28 <= 0x40)
          {
            if (!*(void *)&v52 || (*(void *)&v52 & (*(void *)&v52 - 1)) != 0) {
              return 0;
            }
            goto LABEL_44;
          }
          int8x8_t v43 = v52;
          int v44 = llvm::APInt::countPopulationSlowCase((uint64_t)&v56);
          if (v43)
          {
            MEMORY[0x1D25D9CB0](*(void *)&v43, 0x1000C8000313F17);
            if (v53 >= 0x41)
            {
              if (v52) {
                MEMORY[0x1D25D9CB0](*(void *)&v52, 0x1000C8000313F17);
              }
            }
          }
          if (v44 == 1)
          {
LABEL_44:
            unsigned int v27 = v58[1].u32[0];
            unsigned int v51 = v27;
            if (v27 > 0x40) {
              operator new[]();
            }
            unint64_t v29 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v27;
            if (!v27) {
              unint64_t v29 = 0;
            }
            unint64_t v30 = v29 & ~*(void *)v58;
            if (*((_DWORD *)a5 + 2) > 0x40u && *a5) {
              MEMORY[0x1D25D9CB0](*a5, 0x1000C8000313F17);
            }
            *a5 = (int8x8_t **)v30;
            goto LABEL_38;
          }
          break;
        case '&':
          unsigned int v27 = v58[1].u32[0];
          if (!v27) {
            goto LABEL_36;
          }
          if (v27 > 0x40)
          {
            if (llvm::APInt::countTrailingOnesSlowCase((llvm::APInt *)v58) == v27)
            {
              LODWORD(v57) = v27;
              llvm::APInt::initSlowCase((llvm::APInt *)&v56);
            }
            return 0;
          }
          if (*v58 != 0xFFFFFFFFFFFFFFFFLL >> -(char)v27) {
            return 0;
          }
LABEL_36:
          LODWORD(v57) = v58[1].i32[0];
          uint64_t v56 = (int8x8_t **)(1 << (v27 - 1));
          if (*((_DWORD *)a5 + 2) >= 0x41u && *a5)
          {
            MEMORY[0x1D25D9CB0](*a5, 0x1000C8000313F17);
            unsigned int v27 = v57;
          }
          *a5 = v56;
LABEL_38:
          *((_DWORD *)a5 + 2) = v27;
          goto LABEL_39;
        case '\'':
          unsigned int v25 = v58[1].u32[0];
          if (v25 > 0x40)
          {
            if (llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)v58) == v25)
            {
              LODWORD(v57) = v25;
              llvm::APInt::initSlowCase((llvm::APInt *)&v56);
            }
            return 0;
          }
          if (*v58) {
            return 0;
          }
          LODWORD(v57) = v58[1].i32[0];
          uint64_t v56 = (int8x8_t **)(1 << (v25 - 1));
          if (*((_DWORD *)a5 + 2) >= 0x41u && *a5)
          {
            MEMORY[0x1D25D9CB0](*a5, 0x1000C8000313F17);
            unsigned int v25 = v57;
          }
          *a5 = v56;
LABEL_32:
          *((_DWORD *)a5 + 2) = v25;
LABEL_39:
          int v15 = 32;
          goto LABEL_13;
        case '(':
          unsigned int v14 = v58[1].u32[0];
          if (v14 > 0x40)
          {
            if (llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)v58) == v14)
            {
              LODWORD(v57) = v14;
              llvm::APInt::initSlowCase((llvm::APInt *)&v56);
            }
            return 0;
          }
          if (*v58) {
            return 0;
          }
          LODWORD(v57) = v58[1].i32[0];
          uint64_t v56 = (int8x8_t **)(1 << (v14 - 1));
          if (*((_DWORD *)a5 + 2) >= 0x41u && *a5)
          {
            MEMORY[0x1D25D9CB0](*a5, 0x1000C8000313F17);
            unsigned int v14 = v57;
          }
          *a5 = v56;
LABEL_11:
          *((_DWORD *)a5 + 2) = v14;
          goto LABEL_12;
        case ')':
          uint64_t v39 = v58[1].u32[0];
          if (!v39) {
            goto LABEL_70;
          }
          if (v39 > 0x40)
          {
            if (llvm::APInt::countTrailingOnesSlowCase((llvm::APInt *)v58) != v39) {
              return 0;
            }
          }
          else if (*v58 != 0xFFFFFFFFFFFFFFFFLL >> -(char)v39)
          {
            return 0;
          }
LABEL_70:
          sub_1CBA62420(v39, (llvm::APInt *)&v56);
          if (*((_DWORD *)a5 + 2) >= 0x41u && *a5) {
            MEMORY[0x1D25D9CB0](*a5, 0x1000C8000313F17);
          }
          *a5 = v56;
          *((_DWORD *)a5 + 2) = v57;
LABEL_12:
          int v15 = 33;
LABEL_13:
          *a3 = v15;
          if (a6 && (uint64_t v56 = (int8x8_t **)a4, sub_1CBC5BF18(&v56, a1)))
          {
            uint64_t v31 = *(void *)*a4;
            if ((*(_DWORD *)(v31 + 8) & 0xFE) == 0x12) {
              uint64_t v31 = **(void **)(v31 + 16);
            }
            unsigned int PrimitiveSizeInBits = llvm::Type::getPrimitiveSizeInBits((llvm::Type *)v31);
            if (PrimitiveSizeInBits > 0x40)
            {
              if (*((_DWORD *)a5 + 2) != PrimitiveSizeInBits) {
                operator new[]();
              }
              sub_1CD0463BC((uint64_t)&v56, (uint64_t)a5);
            }
            else
            {
              int v33 = *a5;
              LODWORD(v57) = PrimitiveSizeInBits;
              if (PrimitiveSizeInBits) {
                unint64_t v34 = 0xFFFFFFFFFFFFFFFFLL >> -(char)PrimitiveSizeInBits;
              }
              else {
                unint64_t v34 = 0;
              }
              uint64_t v56 = (int8x8_t **)(v34 & (unint64_t)v33);
            }
            if (*((_DWORD *)a5 + 2) >= 0x41u)
            {
              if (*a5) {
                MEMORY[0x1D25D9CB0](*a5, 0x1000C8000313F17);
              }
            }
            *a5 = v56;
            *((_DWORD *)a5 + 2) = v57;
          }
          else
          {
            *a4 = a1;
          }
          return 1;
        default:
          JUMPOUT(0);
      }
    }
    return 0;
  }
  return result;
}

void llvm::initializeCostModelAnalysisPass(uint64_t a1)
{
  uint64_t v1 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC4F98, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CBFB4D5C;
    v3[1] = &v1;
    unsigned int v2 = v3;
    std::__call_once(&qword_1EBCC4F98, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CBFB4D5C()
{
}

uint64_t sub_1CBFB4DFC(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCC4F90;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F2602070;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC4F98, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CBFB4D5C;
    v5[1] = &PassRegistry;
    BOOL v4 = v5;
    std::__call_once(&qword_1EBCC4F98, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void sub_1CBFB4EB0()
{
}

void sub_1CBFB4EF0(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CBFB4F28(uint64_t a1, llvm::raw_ostream *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    uint64_t v3 = v2 + 72;
    uint64_t v4 = *(void *)(v2 + 80);
    if (v4 != v2 + 72)
    {
      do
      {
        uint64_t v7 = v4 - 24;
        if (!v4) {
          uint64_t v7 = 0;
        }
        uint64_t v8 = v7 + 40;
        for (uint64_t i = *(void *)(v7 + 48); i != v8; uint64_t i = *(void *)(i + 8))
        {
          if (i) {
            int v10 = (const llvm::Instruction *)(i - 24);
          }
          else {
            int v10 = 0;
          }
          uint64_t v11 = sub_1CD4710C0(*(llvm::TargetTransformInfo **)(a1 + 40), v10, dword_1EBCC4DB8);
          if (v12)
          {
            int v15 = (void *)*((void *)a2 + 4);
            if (*((void *)a2 + 3) - (void)v15 > 0x17uLL)
            {
              qmemcpy(v15, "Cost Model: Invalid cost", 24);
              *((void *)a2 + 4) += 24;
            }
            else
            {
              llvm::raw_ostream::write(a2, "Cost Model: Invalid cost", 0x18uLL);
            }
          }
          else
          {
            unint64_t v13 = v11;
            unsigned int v14 = (void *)*((void *)a2 + 4);
            if (*((void *)a2 + 3) - (void)v14 > 0x26uLL)
            {
              qmemcpy(v14, "Cost Model: Found an estimated cost of ", 39);
              *((void *)a2 + 4) += 39;
            }
            else
            {
              llvm::raw_ostream::write(a2, "Cost Model: Found an estimated cost of ", 0x27uLL);
            }
            llvm::raw_ostream::operator<<(a2, v13);
          }
          uint64_t v16 = *((void *)a2 + 4);
          if ((unint64_t)(*((void *)a2 + 3) - v16) > 0x11)
          {
            *(_WORD *)(v16 + 16) = 8250;
            *(_OWORD *)uint64_t v16 = *(_OWORD *)" for instruction: ";
            *((void *)a2 + 4) += 18;
          }
          else
          {
            llvm::raw_ostream::write(a2, " for instruction: ", 0x12uLL);
          }
          llvm::Value::print(v10, a2, 0);
          unsigned int v17 = (unsigned char *)*((void *)a2 + 4);
          if (*((unsigned char **)a2 + 3) == v17)
          {
            llvm::raw_ostream::write(a2, "\n", 1uLL);
          }
          else
          {
            unsigned char *v17 = 10;
            ++*((void *)a2 + 4);
          }
        }
        uint64_t v4 = *(void *)(v4 + 8);
      }
      while (v4 != v3);
    }
  }
}

void sub_1CBFB5118(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
}

uint64_t sub_1CBFB5124(void *a1, const Function *a2)
{
  a1[4] = a2;
  AnalysisPass = (llvm::TargetTransformInfoWrapperPass *)llvm::PMDataManager::findAnalysisPass(*(llvm::PMDataManager **)(a1[1] + 24), &llvm::TargetTransformInfoWrapperPass::ID, 1);
  if (AnalysisPass)
  {
    AnalysisPass = (llvm::TargetTransformInfoWrapperPass *)(*(uint64_t (**)(llvm::TargetTransformInfoWrapperPass *, void *))(*(void *)AnalysisPass + 96))(AnalysisPass, &llvm::TargetTransformInfoWrapperPass::ID);
    if (AnalysisPass) {
      AnalysisPass = (llvm::TargetTransformInfoWrapperPass *)llvm::TargetTransformInfoWrapperPass::getTTI(AnalysisPass, a2);
    }
  }
  a1[5] = AnalysisPass;
  return 0;
}

uint64_t sub_1CBFB51A8(void *a1, uint64_t a2)
{
  v9[4] = *MEMORY[0x1E4F143B8];
  int v2 = *(_DWORD *)(a2 + 20);
  if ((v2 & 0x40000000) != 0)
  {
    uint64_t v4 = *(uint64_t **)(a2 - 8);
    unint64_t v3 = v2 & 0x7FFFFFF;
  }
  else
  {
    unint64_t v3 = v2 & 0x7FFFFFF;
    uint64_t v4 = (uint64_t *)(a2 - 32 * v3);
  }
  if (v3 >= 5) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (v3)
  {
    uint64_t v5 = 32 * v3;
    int v6 = v9;
    do
    {
      uint64_t v7 = *v4;
      v4 += 4;
      *v6++ = v7;
      v5 -= 32;
    }
    while (v5);
  }
  return (*(uint64_t (**)(void, uint64_t, void *))(*(void *)*a1 + 72))(*a1, a2, v9);
}

void sub_1CBFB5304(uint64_t a1, unsigned int a2)
{
  if (a2)
  {
    uint64_t v2 = a1;
    uint64_t v3 = a1 + 40 * a2;
    do
    {
      sub_1CD4716D8(*(unsigned __int8 **)v2, *(void *)(v2 + 8), *(_DWORD *)(v2 + 16), *(void *)(v2 + 24), *(void *)(v2 + 32));
      v2 += 40;
    }
    while (v2 != v3);
  }
}

uint64_t sub_1CBFB5350()
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v3 = "Target cost kind";
  *((void *)&v3 + 1) = 16;
  int v1 = 0;
  uint64_t v2 = &v1;
  v4[0] = v5;
  v5[0] = "throughput";
  v5[1] = 10;
  int v6 = 0;
  uint64_t v7 = "Reciprocal throughput";
  uint64_t v8 = 21;
  unint64_t v9 = "latency";
  uint64_t v10 = 7;
  int v11 = 1;
  int v12 = "Instruction latency";
  uint64_t v13 = 19;
  unsigned int v14 = "code-size";
  uint64_t v15 = 9;
  unsigned int v17 = "Code size";
  uint64_t v18 = 9;
  unint64_t v19 = "size-latency";
  uint64_t v20 = 12;
  int v16 = 2;
  int v21 = 3;
  uint8x8_t v22 = "Code size and latency";
  uint64_t v23 = 21;
  v4[1] = (void *)0x400000004;
  sub_1CD4714D0(&v3, &v2, (uint64_t)v4);
  if (v4[0] != v5) {
    free(v4[0]);
  }
  return __cxa_atexit((void (*)(void *))sub_1CD470E8C, qword_1EBCC4D38, &dword_1CB82C000);
}

void llvm::CodeMetrics::collectEphemeralValues(uint64_t a1, llvm::AssumptionCache *this, llvm::SmallPtrSetImplBase *a3)
{
  v47[16] = *MEMORY[0x1E4F143B8];
  int v41 = v45;
  unsigned int v42 = v45;
  uint64_t v43 = 32;
  int v44 = 0;
  v46[0] = v47;
  v46[1] = (void *)0x1000000000;
  if (!*((unsigned char *)this + 184)) {
    llvm::AssumptionCache::scanFunction(this);
  }
  uint64_t v6 = *((unsigned int *)this + 6);
  if (v6)
  {
    uint64_t v7 = *((void *)this + 2);
    uint64_t v8 = v7 + 32 * v6;
    while (1)
    {
      uint64_t v9 = *(void *)(v7 + 16);
      if (!v9) {
        goto LABEL_21;
      }
      uint64_t v10 = *(void *)(v9 + 40);
      uint64_t v12 = *(void *)(a1 + 56);
      uint64_t v11 = *(void *)(a1 + 64);
      if (v11 == v12)
      {
        uint64_t v13 = *(unsigned int *)(a1 + 76);
        unsigned int v14 = (void *)(v11 + 8 * v13);
        if (v13)
        {
          uint64_t v15 = 0;
          uint64_t v16 = 8 * v13;
          while (*(void *)(v11 + v15) != v10)
          {
            v15 += 8;
            if (v16 == v15) {
              goto LABEL_16;
            }
          }
          unsigned int v14 = (void *)(v11 + v15);
        }
LABEL_16:
        uint64_t v12 = *(void *)(a1 + 64);
      }
      else
      {
        uint64_t v18 = *(unsigned int *)(a1 + 72);
        int v19 = v18 - 1;
        unsigned int v20 = (v18 - 1) & ((v10 >> 4) ^ (v10 >> 9));
        unsigned int v14 = (void *)(v11 + 8 * v20);
        uint64_t v21 = *v14;
        if (*v14 == -1)
        {
          uint8x8_t v22 = 0;
LABEL_33:
          if (v22) {
            unsigned int v14 = v22;
          }
          if (*v14 != v10) {
            unsigned int v14 = (void *)(v11 + 8 * v18);
          }
        }
        else
        {
          uint8x8_t v22 = 0;
          int v23 = 1;
          while (v21 != v10)
          {
            if (v22) {
              BOOL v24 = 0;
            }
            else {
              BOOL v24 = v21 == -2;
            }
            if (v24) {
              uint8x8_t v22 = v14;
            }
            unsigned int v25 = v20 + v23++;
            unsigned int v20 = v25 & v19;
            unsigned int v14 = (void *)(v11 + 8 * (v25 & v19));
            uint64_t v21 = *v14;
            if (*v14 == -1) {
              goto LABEL_33;
            }
          }
        }
      }
      unsigned int v17 = (unsigned int *)(v11 == v12 ? a1 + 76 : a1 + 72);
      if (v14 == (void *)(v11 + 8 * *v17)) {
        goto LABEL_21;
      }
      uint64_t v26 = *((void *)a3 + 1);
      uint64_t v27 = *((unsigned int *)a3 + 5);
      if (v26 == *(void *)a3)
      {
        if (v27)
        {
          unsigned int v28 = 0;
          uint64_t v29 = 8 * v27;
          unint64_t v30 = (uint64_t *)*((void *)a3 + 1);
          while (*v30 != v9)
          {
            if (*v30 == -2) {
              unsigned int v28 = v30;
            }
            ++v30;
            v29 -= 8;
            if (!v29)
            {
              if (!v28) {
                goto LABEL_47;
              }
              uint64_t *v28 = v9;
              --*((_DWORD *)a3 + 6);
              goto LABEL_49;
            }
          }
          goto LABEL_21;
        }
LABEL_47:
        unsigned int v31 = *((_DWORD *)a3 + 4);
        if (v27 < v31)
        {
          *((_DWORD *)a3 + 5) = v27 + 1;
          *(void *)(v26 + 8 * v27) = v9;
          goto LABEL_49;
        }
      }
      else
      {
        unsigned int v31 = *((_DWORD *)a3 + 4);
      }
      if (3 * v31 <= 4 * ((int)v27 - *((_DWORD *)a3 + 6))) {
        break;
      }
      if (v31 - v27 < v31 >> 3) {
        goto LABEL_77;
      }
LABEL_53:
      unsigned int v32 = v31 - 1;
      unsigned int v33 = (v31 - 1) & ((v9 >> 4) ^ (v9 >> 9));
      unint64_t v34 = (uint64_t *)(v26 + 8 * v33);
      uint64_t v35 = *v34;
      if (*v34 != -1)
      {
        int8x8_t v36 = 0;
        int v37 = 1;
        while (v35 != v9)
        {
          if (v36) {
            BOOL v38 = 0;
          }
          else {
            BOOL v38 = v35 == -2;
          }
          if (v38) {
            int8x8_t v36 = v34;
          }
          unsigned int v39 = v33 + v37++;
          unsigned int v33 = v39 & v32;
          unint64_t v34 = (uint64_t *)(v26 + 8 * (v39 & v32));
          uint64_t v35 = *v34;
          if (*v34 == -1) {
            goto LABEL_65;
          }
        }
        goto LABEL_21;
      }
      int8x8_t v36 = 0;
LABEL_65:
      if (v36) {
        int8x8_t v40 = v36;
      }
      else {
        int8x8_t v40 = v34;
      }
      if (*v40 == v9) {
        goto LABEL_21;
      }
      if (*v40 == -2) {
        --*((_DWORD *)a3 + 6);
      }
      else {
        ++*((_DWORD *)a3 + 5);
      }
      uint64_t *v40 = v9;
LABEL_49:
      sub_1CBFB5828(v9, (llvm::SmallPtrSetImplBase *)&v41, (uint64_t)v46);
LABEL_21:
      v7 += 32;
      if (v7 == v8) {
        goto LABEL_4;
      }
    }
    if (v31 >= 0x40) {
      v31 *= 2;
    }
    else {
      unsigned int v31 = 128;
    }
LABEL_77:
    llvm::SmallPtrSetImplBase::Grow(a3, v31);
    unsigned int v31 = *((_DWORD *)a3 + 4);
    uint64_t v26 = *((void *)a3 + 1);
    goto LABEL_53;
  }
LABEL_4:
  sub_1CBFB5A88((llvm::SmallPtrSetImplBase *)&v41, (uint64_t)v46, a3);
  if (v46[0] != v47) {
    free(v46[0]);
  }
  if (v42 != v41) {
    free(v42);
  }
}

void sub_1CBFB5828(uint64_t a1, llvm::SmallPtrSetImplBase *this, uint64_t a3)
{
  if (a1 && *(unsigned __int8 *)(a1 + 16) - 21 >= 7)
  {
    int v5 = *(_DWORD *)(a1 + 20);
    if ((v5 & 0x40000000) != 0)
    {
      uint64_t v7 = *(unsigned __int8 ***)(a1 - 8);
      uint64_t v6 = v5 & 0x7FFFFFF;
      if (!v6) {
        return;
      }
    }
    else
    {
      uint64_t v6 = v5 & 0x7FFFFFF;
      uint64_t v7 = (unsigned __int8 **)(a1 - 32 * v6);
      if (!v6) {
        return;
      }
    }
    uint64_t v8 = &v7[4 * v6];
    while (1)
    {
      uint64_t v9 = *v7;
      uint64_t v10 = *((void *)this + 1);
      uint64_t v11 = *((unsigned int *)this + 5);
      if (v10 != *(void *)this) {
        break;
      }
      if (v11)
      {
        uint64_t v12 = 0;
        uint64_t v13 = 8 * v11;
        unsigned int v14 = (unsigned __int8 **)*((void *)this + 1);
        while (*v14 != v9)
        {
          if (*v14 == (unsigned __int8 *)-2) {
            uint64_t v12 = v14;
          }
          ++v14;
          v13 -= 8;
          if (!v13)
          {
            if (!v12) {
              goto LABEL_16;
            }
            *uint64_t v12 = v9;
            --*((_DWORD *)this + 6);
            if (v9) {
              goto LABEL_41;
            }
            goto LABEL_46;
          }
        }
        goto LABEL_46;
      }
LABEL_16:
      unsigned int v15 = *((_DWORD *)this + 4);
      if (v11 >= v15) {
        goto LABEL_20;
      }
      *((_DWORD *)this + 5) = v11 + 1;
      *(void *)(v10 + 8 * v11) = v9;
      if (v9) {
        goto LABEL_41;
      }
LABEL_46:
      v7 += 4;
      if (v7 == v8) {
        return;
      }
    }
    unsigned int v15 = *((_DWORD *)this + 4);
LABEL_20:
    if (3 * v15 <= 4 * ((int)v11 - *((_DWORD *)this + 6)))
    {
      if (v15 >= 0x40) {
        v15 *= 2;
      }
      else {
        unsigned int v15 = 128;
      }
    }
    else if (v15 - v11 >= v15 >> 3)
    {
LABEL_22:
      unsigned int v16 = v15 - 1;
      unsigned int v17 = (v15 - 1) & ((v9 >> 4) ^ (v9 >> 9));
      uint64_t v18 = (unsigned __int8 **)(v10 + 8 * v17);
      int v19 = *v18;
      if (*v18 != (unsigned __int8 *)-1)
      {
        unsigned int v20 = 0;
        int v21 = 1;
        while (v19 != v9)
        {
          if (v20) {
            BOOL v22 = 0;
          }
          else {
            BOOL v22 = v19 == (unsigned __int8 *)-2;
          }
          if (v22) {
            unsigned int v20 = v18;
          }
          unsigned int v23 = v17 + v21++;
          unsigned int v17 = v23 & v16;
          uint64_t v18 = (unsigned __int8 **)(v10 + 8 * (v23 & v16));
          int v19 = *v18;
          if (*v18 == (unsigned __int8 *)-1) {
            goto LABEL_34;
          }
        }
        goto LABEL_46;
      }
      unsigned int v20 = 0;
LABEL_34:
      if (v20) {
        BOOL v24 = v20;
      }
      else {
        BOOL v24 = v18;
      }
      if (*v24 == v9) {
        goto LABEL_46;
      }
      if (*v24 == (unsigned __int8 *)-2) {
        --*((_DWORD *)this + 6);
      }
      else {
        ++*((_DWORD *)this + 5);
      }
      *BOOL v24 = v9;
      if (!v9) {
        goto LABEL_46;
      }
LABEL_41:
      if (v9[16] >= 0x1Cu
        && (llvm::Instruction::mayHaveSideEffects((llvm::Instruction *)v9) & 1) == 0
        && v9[16] - 29 >= 0xB)
      {
        unint64_t v25 = *(unsigned int *)(a3 + 8);
        if (v25 >= *(unsigned int *)(a3 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)a3 + 8 * v25) = v9;
        ++*(_DWORD *)(a3 + 8);
      }
      goto LABEL_46;
    }
    llvm::SmallPtrSetImplBase::Grow(this, v15);
    unsigned int v15 = *((_DWORD *)this + 4);
    uint64_t v10 = *((void *)this + 1);
    goto LABEL_22;
  }
}

void sub_1CBFB5A88(llvm::SmallPtrSetImplBase *this, uint64_t a2, llvm::SmallPtrSetImplBase *a3)
{
  int v3 = *(_DWORD *)(a2 + 8);
  if (v3 >= 1)
  {
    uint64_t v7 = 0;
    while (1)
    {
      uint64_t v8 = *(void *)(*(void *)a2 + 8 * v7);
      uint64_t v9 = *(void *)(v8 + 8);
      uint64_t v11 = *(void *)a3;
      uint64_t v10 = *((void *)a3 + 1);
      uint64_t v12 = *((unsigned int *)a3 + 5);
      uint64_t v13 = v10;
      if (v9)
      {
        int v14 = *((_DWORD *)a3 + 4) - 1;
        if (v10 == v11) {
          unsigned int v15 = *((_DWORD *)a3 + 5);
        }
        else {
          unsigned int v15 = *((_DWORD *)a3 + 4);
        }
        unsigned int v16 = (void *)(v10 + 8 * v15);
        uint64_t v13 = *((void *)a3 + 1);
        do
        {
          uint64_t v17 = *(void *)(v9 + 24);
          if (v13 == v11)
          {
            if (v12)
            {
              uint64_t v18 = 0;
              while (*(void *)(v11 + v18) != v17)
              {
                v18 += 8;
                if (8 * v12 == v18)
                {
                  unsigned int v19 = *((_DWORD *)a3 + 5);
                  goto LABEL_28;
                }
              }
              unsigned int v28 = (void *)(v11 + v18);
              unsigned int v19 = *((_DWORD *)a3 + 5);
              uint64_t v13 = *(void *)a3;
            }
            else
            {
              unsigned int v19 = 0;
LABEL_28:
              uint64_t v13 = *(void *)a3;
              unsigned int v28 = (void *)(v11 + 8 * v12);
            }
          }
          else
          {
            unsigned int v20 = v14 & ((v17 >> 4) ^ (v17 >> 9));
            int v21 = (void *)(v10 + 8 * v20);
            uint64_t v22 = *v21;
            if (*v21 == -1)
            {
              unsigned int v23 = 0;
LABEL_30:
              if (v23) {
                int v21 = v23;
              }
              uint64_t v27 = *v21;
            }
            else
            {
              unsigned int v23 = 0;
              int v24 = 1;
              while (v22 != v17)
              {
                if (v23) {
                  BOOL v25 = 0;
                }
                else {
                  BOOL v25 = v22 == -2;
                }
                if (v25) {
                  unsigned int v23 = v21;
                }
                unsigned int v26 = v20 + v24++;
                unsigned int v20 = v26 & v14;
                int v21 = (void *)(v10 + 8 * (v26 & v14));
                uint64_t v22 = *v21;
                if (*v21 == -1) {
                  goto LABEL_30;
                }
              }
              uint64_t v27 = *(void *)(v9 + 24);
            }
            unsigned int v28 = v27 == v17 ? v21 : v16;
            unsigned int v19 = *((_DWORD *)a3 + 5);
            uint64_t v13 = *((void *)a3 + 1);
          }
          if (v13 != v11) {
            unsigned int v19 = *((_DWORD *)a3 + 4);
          }
          if (v28 == (void *)(v13 + 8 * v19)) {
            goto LABEL_74;
          }
          uint64_t v9 = *(void *)(v9 + 8);
        }
        while (v9);
      }
      if (v13 != v11) {
        break;
      }
      if (v12)
      {
        uint64_t v29 = 0;
        uint64_t v30 = 8 * v12;
        unsigned int v31 = *(uint64_t **)a3;
        while (*v31 != v8)
        {
          if (*v31 == -2) {
            uint64_t v29 = v31;
          }
          ++v31;
          v30 -= 8;
          if (!v30)
          {
            if (!v29) {
              goto LABEL_49;
            }
            *uint64_t v29 = v8;
            --*((_DWORD *)a3 + 6);
            goto LABEL_73;
          }
        }
        goto LABEL_73;
      }
LABEL_49:
      unsigned int v32 = *((_DWORD *)a3 + 4);
      if (v12 >= v32) {
        goto LABEL_52;
      }
      *((_DWORD *)a3 + 5) = v12 + 1;
      *(void *)(v11 + 8 * v12) = v8;
LABEL_73:
      sub_1CBFB5828(v8, this, a2);
      int v3 = *(_DWORD *)(a2 + 8);
LABEL_74:
      if (++v7 >= v3) {
        return;
      }
    }
    unsigned int v32 = *((_DWORD *)a3 + 4);
LABEL_52:
    if (3 * v32 <= 4 * ((int)v12 - *((_DWORD *)a3 + 6)))
    {
      if (v32 >= 0x40) {
        v32 *= 2;
      }
      else {
        unsigned int v32 = 128;
      }
    }
    else if (v32 - v12 >= v32 >> 3)
    {
      goto LABEL_54;
    }
    llvm::SmallPtrSetImplBase::Grow(a3, v32);
    unsigned int v32 = *((_DWORD *)a3 + 4);
    uint64_t v10 = *((void *)a3 + 1);
LABEL_54:
    unsigned int v33 = v32 - 1;
    unsigned int v34 = (v32 - 1) & ((v8 >> 4) ^ (v8 >> 9));
    uint64_t v35 = (uint64_t *)(v10 + 8 * v34);
    uint64_t v36 = *v35;
    if (*v35 == -1)
    {
      int v37 = 0;
LABEL_66:
      if (v37) {
        int v41 = v37;
      }
      else {
        int v41 = v35;
      }
      if (*v41 != v8)
      {
        if (*v41 == -2) {
          --*((_DWORD *)a3 + 6);
        }
        else {
          ++*((_DWORD *)a3 + 5);
        }
        *int v41 = v8;
      }
    }
    else
    {
      int v37 = 0;
      int v38 = 1;
      while (v36 != v8)
      {
        if (v37) {
          BOOL v39 = 0;
        }
        else {
          BOOL v39 = v36 == -2;
        }
        if (v39) {
          int v37 = v35;
        }
        unsigned int v40 = v34 + v38++;
        unsigned int v34 = v40 & v33;
        uint64_t v35 = (uint64_t *)(v10 + 8 * (v40 & v33));
        uint64_t v36 = *v35;
        if (*v35 == -1) {
          goto LABEL_66;
        }
      }
    }
    goto LABEL_73;
  }
}

void llvm::CodeMetrics::collectEphemeralValues(int a1, llvm::AssumptionCache *this, llvm::SmallPtrSetImplBase *a3)
{
  v30[16] = *MEMORY[0x1E4F143B8];
  int v24 = v28;
  BOOL v25 = v28;
  uint64_t v26 = 32;
  int v27 = 0;
  v29[0] = v30;
  v29[1] = (void *)0x1000000000;
  if (!*((unsigned char *)this + 184)) {
    llvm::AssumptionCache::scanFunction(this);
  }
  uint64_t v5 = *((unsigned int *)this + 6);
  if (v5)
  {
    uint64_t v6 = *((void *)this + 2);
    uint64_t v7 = v6 + 32 * v5;
    while (1)
    {
      uint64_t v8 = *(void *)(v6 + 16);
      if (v8) {
        break;
      }
LABEL_11:
      v6 += 32;
      if (v6 == v7) {
        goto LABEL_4;
      }
    }
    uint64_t v9 = *((void *)a3 + 1);
    uint64_t v10 = *((unsigned int *)a3 + 5);
    if (v9 == *(void *)a3)
    {
      if (v10)
      {
        uint64_t v11 = 0;
        uint64_t v12 = 8 * v10;
        uint64_t v13 = (uint64_t *)*((void *)a3 + 1);
        while (*v13 != v8)
        {
          if (*v13 == -2) {
            uint64_t v11 = v13;
          }
          ++v13;
          v12 -= 8;
          if (!v12)
          {
            if (!v11) {
              goto LABEL_21;
            }
            *uint64_t v11 = v8;
            --*((_DWORD *)a3 + 6);
            goto LABEL_23;
          }
        }
        goto LABEL_11;
      }
LABEL_21:
      unsigned int v14 = *((_DWORD *)a3 + 4);
      if (v10 < v14)
      {
        *((_DWORD *)a3 + 5) = v10 + 1;
        *(void *)(v9 + 8 * v10) = v8;
LABEL_23:
        sub_1CBFB5828(v8, (llvm::SmallPtrSetImplBase *)&v24, (uint64_t)v29);
        goto LABEL_11;
      }
    }
    else
    {
      unsigned int v14 = *((_DWORD *)a3 + 4);
    }
    if (3 * v14 <= 4 * ((int)v10 - *((_DWORD *)a3 + 6)))
    {
      if (v14 >= 0x40) {
        v14 *= 2;
      }
      else {
        unsigned int v14 = 128;
      }
    }
    else if (v14 - v10 >= v14 >> 3)
    {
LABEL_36:
      unsigned int v22 = v14 - 1;
      unsigned int v19 = (v14 - 1) & ((v8 >> 4) ^ (v8 >> 9));
      unsigned int v20 = (uint64_t *)(v9 + 8 * v19);
      uint64_t v21 = *v20;
      if (*v20 != -1)
      {
        unsigned int v16 = 0;
        int v18 = 1;
        while (v21 != v8)
        {
          if (v16) {
            BOOL v15 = 0;
          }
          else {
            BOOL v15 = v21 == -2;
          }
          if (v15) {
            unsigned int v16 = v20;
          }
          unsigned int v17 = v19 + v18++;
          unsigned int v19 = v17 & v22;
          unsigned int v20 = (uint64_t *)(v9 + 8 * (v17 & v22));
          uint64_t v21 = *v20;
          if (*v20 == -1) {
            goto LABEL_39;
          }
        }
        goto LABEL_11;
      }
      unsigned int v16 = 0;
LABEL_39:
      if (v16) {
        unsigned int v23 = v16;
      }
      else {
        unsigned int v23 = v20;
      }
      if (*v23 == v8) {
        goto LABEL_11;
      }
      if (*v23 == -2) {
        --*((_DWORD *)a3 + 6);
      }
      else {
        ++*((_DWORD *)a3 + 5);
      }
      *unsigned int v23 = v8;
      goto LABEL_23;
    }
    llvm::SmallPtrSetImplBase::Grow(a3, v14);
    unsigned int v14 = *((_DWORD *)a3 + 4);
    uint64_t v9 = *((void *)a3 + 1);
    goto LABEL_36;
  }
LABEL_4:
  sub_1CBFB5A88((llvm::SmallPtrSetImplBase *)&v24, (uint64_t)v29, a3);
  if (v29[0] != v30) {
    free(v29[0]);
  }
  if (v25 != v24) {
    free(v25);
  }
}

uint64_t *llvm::CodeMetrics::analyzeBasicBlock(uint64_t a1, llvm::BasicBlock *a2, void *a3, uint64_t *a4, int a5)
{
  v81[4] = *MEMORY[0x1E4F143B8];
  uint64_t v78 = a2;
  unint64_t v6 = *(unsigned int *)(a1 + 8);
  ++*(_DWORD *)(a1 + 12);
  uint64_t v7 = (void *)((char *)a2 + 40);
  uint64_t v8 = (void *)*((void *)a2 + 6);
  if (v8 != (void *)((char *)a2 + 40))
  {
    int v10 = 0;
    unint64_t v76 = v6;
    unint64_t v11 = v6;
    while (1)
    {
      if (v8) {
        uint64_t v12 = (uint64_t)(v8 - 3);
      }
      else {
        uint64_t v12 = 0;
      }
      uint64_t v14 = *a4;
      uint64_t v13 = a4[1];
      if (v13 == *a4)
      {
        uint64_t v15 = *((unsigned int *)a4 + 5);
        unsigned int v16 = (void *)(v13 + 8 * v15);
        if (v15)
        {
          uint64_t v17 = 0;
          while (*(void *)(v13 + v17) != v12)
          {
            v17 += 8;
            if (8 * v15 == v17) {
              goto LABEL_25;
            }
          }
          unsigned int v16 = (void *)(v13 + v17);
        }
LABEL_25:
        uint64_t v14 = a4[1];
      }
      else
      {
        uint64_t v18 = *((unsigned int *)a4 + 4);
        int v19 = v18 - 1;
        unsigned int v20 = (v18 - 1) & ((v12 >> 4) ^ (v12 >> 9));
        unsigned int v16 = (void *)(v13 + 8 * v20);
        uint64_t v21 = *v16;
        if (*v16 == -1)
        {
          unsigned int v22 = 0;
LABEL_109:
          if (v22) {
            unsigned int v16 = v22;
          }
          LODWORD(v15) = *((_DWORD *)a4 + 5);
          uint64_t v56 = (void *)(v13 + 8 * v18);
          if (*v16 != v12) {
            unsigned int v16 = v56;
          }
        }
        else
        {
          unsigned int v22 = 0;
          int v23 = 1;
          while (v21 != v12)
          {
            if (v22) {
              BOOL v24 = 0;
            }
            else {
              BOOL v24 = v21 == -2;
            }
            if (v24) {
              unsigned int v22 = v16;
            }
            unsigned int v25 = v20 + v23++;
            unsigned int v20 = v25 & v19;
            unsigned int v16 = (void *)(v13 + 8 * (v25 & v19));
            uint64_t v21 = *v16;
            if (*v16 == -1) {
              goto LABEL_109;
            }
          }
          LODWORD(v15) = *((_DWORD *)a4 + 5);
        }
      }
      if (v13 == v14) {
        unsigned int v26 = v15;
      }
      else {
        unsigned int v26 = *((_DWORD *)a4 + 4);
      }
      if (v16 != (void *)(v13 + 8 * v26)) {
        goto LABEL_106;
      }
      int v27 = *(unsigned __int8 *)(v12 + 16);
      if ((v27 - 33) <= 0x33 && ((1 << (v27 - 33)) & 0x8000000000041) != 0) {
        break;
      }
LABEL_51:
      if (v8 && v27 == 59)
      {
        if (*(unsigned char *)(*(void *)(v12 - 32) + 16) != 16
          || ((uint64_t v36 = *(void *)(v12 + 40), (v37 = *(void *)(*(void *)(v36 + 56) + 80)) != 0)
            ? (uint64_t v38 = v37 - 24)
            : (uint64_t v38 = 0),
              v36 != v38 || (*(_WORD *)(v12 + 18) & 0x40) != 0))
        {
          *(unsigned char *)(a1 + 4) = 1;
        }
        uint64_t v39 = *(void *)v12;
      }
      else
      {
        uint64_t v39 = *(void *)v12;
        if (v27 == 89) {
          goto LABEL_63;
        }
      }
      if ((*(_DWORD *)(v39 + 8) & 0xFE) == 0x12)
      {
LABEL_63:
        ++*(_DWORD *)(a1 + 48);
        int v40 = *(unsigned __int8 *)(v39 + 8);
        goto LABEL_65;
      }
      int v40 = *(_DWORD *)(v39 + 8);
LABEL_65:
      if (v40 == 12 && llvm::Instruction::isUsedOutsideOfBlock((llvm::Instruction *)v12, v78)) {
        *(unsigned char *)(a1 + 2) = 1;
      }
      if (v27 == 84) {
        uint64_t v41 = v12;
      }
      else {
        uint64_t v41 = 0;
      }
      if (v8 && v27 == 84)
      {
        uint64_t v42 = *(void *)(v41 + 64);
        if (v42 && (*(unsigned char *)(v42 + 15) & 1) != 0 || llvm::CallBase::hasFnAttrOnCalledFunction(v41, 24)) {
          *(unsigned char *)(a1 + 2) = 1;
        }
        uint64_t v43 = *(void *)(v41 + 64);
        if (v43 && (*(unsigned char *)(v43 + 12) & 0x40) != 0
          || llvm::CallBase::hasFnAttrOnCalledFunction(v41, 6))
        {
          *(unsigned char *)(a1 + 3) = 1;
        }
      }
      if (v8
        && *(unsigned char *)(v12 + 16) == 33
        && ((uint64_t v44 = *(void *)(v12 + 64)) != 0 && (*(unsigned char *)(v44 + 15) & 1) != 0
         || llvm::CallBase::hasFnAttrOnCalledFunction(v12, 24)))
      {
        *(unsigned char *)(a1 + 2) = 1;
      }
      int v45 = *(_DWORD *)(v12 + 20);
      if ((v45 & 0x40000000) != 0)
      {
        __int32 v47 = *(uint64_t **)(v12 - 8);
        unint64_t v46 = v45 & 0x7FFFFFF;
      }
      else
      {
        unint64_t v46 = v45 & 0x7FFFFFF;
        __int32 v47 = (uint64_t *)(v12 - 32 * v46);
      }
      int v79 = v81;
      uint64_t v80 = 0x400000000;
      if (v46 >= 5) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v46)
      {
        uint64_t v48 = 32 * v46;
        int8x8_t v49 = v81;
        do
        {
          uint64_t v50 = *v47;
          v47 += 4;
          *v49++ = v50;
          v48 -= 32;
        }
        while (v48);
        unsigned int v51 = v79;
      }
      else
      {
        unsigned int v51 = v81;
      }
      LODWORD(v80) = v46;
      uint64_t v52 = (*(uint64_t (**)(void, uint64_t, void *))(*(void *)*a3 + 72))(*a3, v12, v51);
      int v54 = v53;
      if (v79 != v81) {
        free(v79);
      }
      if (v54 == 1) {
        int v10 = 1;
      }
      if (__OFADD__(v11, v52)) {
        unint64_t v11 = ((uint64_t)(v11 + v52) >> 63) ^ 0x8000000000000000;
      }
      else {
        v11 += v52;
      }
      if (v10) {
        int v55 = 0;
      }
      else {
        int v55 = v11;
      }
      *(_DWORD *)(a1 + 8) = v55;
LABEL_106:
      uint64_t v8 = (void *)v8[1];
      if (v8 == v7)
      {
        a2 = v78;
        unint64_t v6 = v76;
        goto LABEL_124;
      }
    }
    uint64_t v29 = *(v8 - 7);
    if (v29)
    {
      int v30 = *(unsigned __int8 *)(v29 + 16);
      if (!*(unsigned char *)(v29 + 16))
      {
        if (*(void *)(v29 + 24) == v8[6])
        {
          int v31 = (*(uint64_t (**)(void, void))(*(void *)*a3 + 176))(*a3, *(v8 - 7));
          uint64_t v32 = v8[5];
          if (!v32 || (*(unsigned char *)(v32 + 15) & 8) == 0)
          {
            int v33 = v31;
            char hasFnAttrOnCalledFunction = llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)(v8 - 3), 27);
            LOBYTE(v31) = v33;
            if ((hasFnAttrOnCalledFunction & 1) == 0 && ((v33 ^ 1) & 1) == 0)
            {
              if ((*(_DWORD *)(v29 + 32) & 0xF) != 7)
              {
                if (!a5) {
                  goto LABEL_117;
                }
                goto LABEL_116;
              }
              uint64_t v35 = *(void *)(v29 + 8);
              if (v35) {
                LOBYTE(v35) = *(void *)(v35 + 8) == 0;
              }
              if (v35 & 1) != 0 || (a5) {
LABEL_116:
              }
                ++*(_DWORD *)(a1 + 44);
            }
          }
LABEL_117:
          if (v29 == *((void *)v78 + 7))
          {
            *(unsigned char *)(a1 + 1) = 1;
            if ((v31 & 1) == 0) {
              goto LABEL_50;
            }
          }
          else if ((v31 & 1) == 0)
          {
            goto LABEL_50;
          }
        }
LABEL_49:
        ++*(_DWORD *)(a1 + 40);
        goto LABEL_50;
      }
    }
    else
    {
      int v30 = MEMORY[0x10];
    }
    if (v30 == 24)
    {
LABEL_50:
      int v27 = *(unsigned __int8 *)(v12 + 16);
      goto LABEL_51;
    }
    goto LABEL_49;
  }
  int v10 = 0;
  unint64_t v11 = v6;
LABEL_124:
  uint64_t v57 = *((void *)a2 + 5);
  if (v57) {
    uint64_t v58 = v57 - 24;
  }
  else {
    uint64_t v58 = 0;
  }
  if (*(unsigned __int8 *)(v58 + 16) - 29 >= 0xB) {
    uint64_t v58 = 0;
  }
  int v59 = *(unsigned __int8 *)(v58 + 16);
  if (v59 == 29) {
    ++*(_DWORD *)(a1 + 52);
  }
  BOOL v60 = v59 == 32;
  uint64_t v63 = *(void *)(a1 + 16);
  uint64_t v62 = a1 + 16;
  uint64_t v61 = v63;
  *(unsigned char *)(v62 - 14) |= v60;
  int v64 = *(_DWORD *)(v62 + 16);
  if (v64)
  {
    int v65 = v64 - 1;
    unsigned int v66 = v65 & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t result = (uint64_t *)(v61 + 16 * v66);
    uint64_t v68 = *result;
    if (a2 == (llvm::BasicBlock *)*result) {
      goto LABEL_146;
    }
    uint64_t v69 = 0;
    int v70 = 1;
    while (v68 != -4096)
    {
      if (v69) {
        BOOL v71 = 0;
      }
      else {
        BOOL v71 = v68 == -8192;
      }
      if (v71) {
        uint64_t v69 = result;
      }
      unsigned int v72 = v66 + v70++;
      unsigned int v66 = v72 & v65;
      uint64_t result = (uint64_t *)(v61 + 16 * v66);
      uint64_t v68 = *result;
      if (a2 == (llvm::BasicBlock *)*result) {
        goto LABEL_146;
      }
    }
    if (v69) {
      int v73 = v69;
    }
    else {
      int v73 = result;
    }
  }
  else
  {
    int v73 = 0;
  }
  uint64_t result = sub_1CBF8BBE8(v62, (uint64_t)&v78, (uint64_t *)&v78, v73);
  uint64_t *result = (uint64_t)v78;
  *((_DWORD *)result + 2) = 0;
LABEL_146:
  int v74 = v11 - v6;
  if (__OFSUB__(v11, v6)) {
    int v74 = 0;
  }
  if (v10) {
    int v74 = 0;
  }
  *((_DWORD *)result + 2) = v74;
  return result;
}

uint64_t llvm::IsConstantOffsetFromGlobal(llvm *this, uint64_t **a2, llvm::GlobalValue **a3, llvm::APInt *a4, const llvm::DataLayout *a5, llvm::DSOLocalEquivalent **a6)
{
  v65[6] = *MEMORY[0x1E4F143B8];
  if (!a5) {
    goto LABEL_3;
  }
LABEL_2:
  *(void *)a5 = 0;
  while (1)
  {
LABEL_3:
    unsigned int v10 = *((unsigned __int8 *)this + 16);
    if (v10 >= 4) {
      unint64_t v11 = 0;
    }
    else {
      unint64_t v11 = this;
    }
    *a2 = (uint64_t *)v11;
    if (v11)
    {
      Section = llvm::GlobalValue::getSection(v11);
      if (v26 == 12 && *(void *)Section == 0x7274702E6D766C6CLL && *((_DWORD *)Section + 2) == 1752462689) {
        return 0;
      }
      uint64_t v28 = **a2;
      unsigned int v29 = *(_DWORD *)(v28 + 8);
      if ((v29 & 0xFE) == 0x12) {
        unsigned int v29 = *(_DWORD *)(**(void **)(v28 + 16) + 8);
      }
      uint64_t v16 = *((void *)a4 + 29);
      if (v29 >= 0x100)
      {
        unsigned int v17 = v29 >> 8;
        uint64_t v18 = *((unsigned int *)a4 + 60);
        uint64_t v19 = *((void *)a4 + 29);
        if (v18)
        {
          uint64_t v19 = *((void *)a4 + 29);
          unint64_t v30 = *((unsigned int *)a4 + 60);
          do
          {
            unint64_t v31 = v30 >> 1;
            uint64_t v32 = v19 + 16 * (v30 >> 1);
            unsigned int v33 = *(_DWORD *)(v32 + 8);
            uint64_t v34 = v32 + 16;
            v30 += ~(v30 >> 1);
            if (v33 < v17) {
              uint64_t v19 = v34;
            }
            else {
              unint64_t v30 = v31;
            }
          }
          while (v30);
        }
LABEL_39:
        if (v19 != v16 + 16 * v18 && *(_DWORD *)(v19 + 8) == v17) {
          goto LABEL_42;
        }
      }
LABEL_41:
      uint64_t v19 = v16;
LABEL_42:
      unsigned int v35 = *(_DWORD *)(v19 + 12);
      if (v35 >= 0x41) {
        operator new[]();
      }
      if (*((_DWORD *)a3 + 2) >= 0x41u && *a3) {
        MEMORY[0x1D25D9CB0](*a3, 0x1000C8000313F17);
      }
      *a3 = 0;
      *((_DWORD *)a3 + 2) = v35;
      return 1;
    }
    if (v10 != 5)
    {
      if (v10 != 6) {
        return 0;
      }
      if (a5) {
        *(void *)a5 = this;
      }
      uint64_t v13 = (uint64_t *)*((void *)this - 4);
      *a2 = v13;
      uint64_t v14 = *v13;
      unsigned int v15 = *(_DWORD *)(v14 + 8);
      if ((v15 & 0xFE) == 0x12) {
        unsigned int v15 = *(_DWORD *)(**(void **)(v14 + 16) + 8);
      }
      uint64_t v16 = *((void *)a4 + 29);
      if (v15 >= 0x100)
      {
        unsigned int v17 = v15 >> 8;
        uint64_t v18 = *((unsigned int *)a4 + 60);
        uint64_t v19 = *((void *)a4 + 29);
        if (v18)
        {
          uint64_t v19 = *((void *)a4 + 29);
          unint64_t v20 = *((unsigned int *)a4 + 60);
          do
          {
            unint64_t v21 = v20 >> 1;
            uint64_t v22 = v19 + 16 * (v20 >> 1);
            unsigned int v23 = *(_DWORD *)(v22 + 8);
            uint64_t v24 = v22 + 16;
            v20 += ~(v20 >> 1);
            if (v23 < v17) {
              uint64_t v19 = v24;
            }
            else {
              unint64_t v20 = v21;
            }
          }
          while (v20);
        }
        goto LABEL_39;
      }
      goto LABEL_41;
    }
    int v12 = *((unsigned __int16 *)this + 9);
    if (v12 != 47 && v12 != 49) {
      break;
    }
    this = (llvm *)*((void *)this - 4 * (*((_DWORD *)this + 5) & 0x7FFFFFF));
    if (a5) {
      goto LABEL_2;
    }
  }
  if (v12 != 34) {
    return 0;
  }
  unsigned int v37 = *(_DWORD *)(*(void *)this + 8);
  if ((v37 & 0xFE) == 0x12) {
    unsigned int v37 = *(_DWORD *)(**(void **)(*(void *)this + 16) + 8);
  }
  if (v37 < 0x100) {
    goto LABEL_59;
  }
  unsigned int v38 = v37 >> 8;
  uint64_t v39 = *((unsigned int *)a4 + 60);
  uint64_t v40 = *((void *)a4 + 29);
  if (v39)
  {
    uint64_t v40 = *((void *)a4 + 29);
    unint64_t v41 = *((unsigned int *)a4 + 60);
    do
    {
      unint64_t v42 = v41 >> 1;
      uint64_t v43 = v40 + 16 * (v41 >> 1);
      unsigned int v44 = *(_DWORD *)(v43 + 8);
      uint64_t v45 = v43 + 16;
      v41 += ~(v41 >> 1);
      if (v44 < v38) {
        uint64_t v40 = v45;
      }
      else {
        unint64_t v41 = v42;
      }
    }
    while (v41);
  }
  if (v40 == *((void *)a4 + 29) + 16 * v39 || *(_DWORD *)(v40 + 8) != v38) {
LABEL_59:
  }
    uint64_t v40 = *((void *)a4 + 29);
  unsigned int v62 = *(_DWORD *)(v40 + 12);
  if (v62 > 0x40) {
    operator new[]();
  }
  __src = 0;
  if (!llvm::IsConstantOffsetFromGlobal(*((llvm **)this - 4 * (*((_DWORD *)this + 5) & 0x7FFFFFF)), (llvm::Constant *)a2, (llvm::GlobalValue **)&__src, a4, a5, a6))goto LABEL_85; {
  int v47 = *((_DWORD *)this + 5);
  }
  if ((v47 & 0x40000000) != 0)
  {
    int8x8_t v49 = (char *)*((void *)this - 1);
    uint64_t v48 = v47 & 0x7FFFFFF;
  }
  else
  {
    uint64_t v48 = v47 & 0x7FFFFFF;
    int8x8_t v49 = (char *)this - 32 * v48;
  }
  uint64_t v63 = v65;
  uint64_t v64 = 0x600000000;
  unint64_t v50 = 32 * v48 - 32;
  if (v50 >= 0xC1) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  unsigned int v51 = (llvm::Constant **)v65;
  if (v48 != 1)
  {
    uint64_t v52 = (uint64_t *)(v49 + 32);
    int v53 = v65;
    uint64_t v54 = 32 * v48 - 32;
    do
    {
      uint64_t v55 = *v52;
      v52 += 4;
      *v53++ = v55;
      v54 -= 32;
    }
    while (v54);
    unsigned int v51 = (llvm::Constant **)v63;
  }
  LODWORD(v64) = v50 >> 5;
  uint64_t v56 = 24;
  if (*((unsigned char *)this + 16) == 62) {
    uint64_t v56 = 64;
  }
  int v57 = llvm::GEPOperator::accumulateConstantOffset(*(void *)((char *)this + v56), v51, (v50 >> 5), a4, (llvm::APInt *)&__src, 0, v46);
  if (v63 != v65)
  {
    free(v63);
    if (v57) {
      goto LABEL_73;
    }
    goto LABEL_85;
  }
  if (!v57)
  {
LABEL_85:
    uint64_t v36 = 0;
    goto LABEL_86;
  }
LABEL_73:
  if (*((_DWORD *)a3 + 2) > 0x40u || (unsigned int v58 = v62, v62 > 0x40))
  {
    if (&__src != (void **)a3)
    {
      llvm::APInt::reallocate((uint64_t)a3, v62);
      uint64_t v60 = *((unsigned int *)a3 + 2);
      if (v60 <= 0x40) {
        *a3 = (llvm::GlobalValue *)__src;
      }
      else {
        memcpy(*a3, __src, ((unint64_t)(v60 + 63) >> 3) & 0x3FFFFFF8);
      }
    }
  }
  else
  {
    *a3 = (llvm::GlobalValue *)__src;
    *((_DWORD *)a3 + 2) = v58;
  }
  uint64_t v36 = 1;
LABEL_86:
  if (v62 >= 0x41 && __src) {
    MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
  }
  return v36;
}

llvm::ConstantExpr *llvm::ConstantFoldLoadThroughBitcast(llvm::Constant **this, llvm::Constant ***a2, llvm::Type *a3, const llvm::DataLayout *a4)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  while (1)
  {
    uint64_t v7 = *this;
    if (*this == (llvm::Constant *)a2) {
      return (llvm::ConstantExpr *)this;
    }
    unint64_t v8 = sub_1CB83544C((uint64_t)a3, (uint64_t)a2);
    int v10 = v9;
    unint64_t v11 = sub_1CB83544C((uint64_t)a3, (uint64_t)v7);
    int v14 = (int)v12;
    if (v10 == 1 && v12 != 1 || v11 < v8) {
      return 0;
    }
    unint64_t v17 = v11;
    int v18 = *((unsigned __int8 *)this + 16);
    if (v18 == 12)
    {
      uint64_t result = (llvm::ConstantExpr *)llvm::PoisonValue::get((llvm::PoisonValue *)a2, v12);
      if (result) {
        return result;
      }
      goto LABEL_17;
    }
    if ((v18 - 11) <= 1)
    {
      uint64_t result = llvm::UndefValue::get((llvm::UndefValue *)a2, v12);
      if (result) {
        return result;
      }
      goto LABEL_17;
    }
    if (v18 == 16)
    {
      uint64_t v19 = *((unsigned int *)this + 8);
      if (v19 >= 0x41)
      {
        int v50 = 0;
        int64_t v51 = (unint64_t)(v19 + 63) >> 6;
        do
        {
          if (v51-- < 1) {
            break;
          }
          unint64_t v53 = *((void *)this[3] + v51);
          v50 += __clz(v53);
        }
        while (!v53);
        int v54 = v19 | 0xFFFFFFC0;
        if ((v19 & 0x3F) == 0) {
          int v54 = 0;
        }
        if (v50 + v54 == v19)
        {
LABEL_39:
          if ((a2[1] & 0xFE) != 0xA)
          {
            uint64_t result = llvm::Constant::getNullValue((llvm::Constant *)a2, v12, v13);
            if (result) {
              return result;
            }
            goto LABEL_17;
          }
        }
      }
      else if (!this[3])
      {
        goto LABEL_39;
      }
    }
    else if (v18 == 17)
    {
      if (sub_1CB844168((uint64_t)this, 0.0)) {
        goto LABEL_39;
      }
    }
    else if ((v18 - 18) < 3 || v18 == 13)
    {
      goto LABEL_39;
    }
    if (llvm::Constant::isAllOnesValue((llvm::Constant *)this))
    {
      unsigned int v49 = (a2[1] & 0xFE) == 0x12 ? *((unsigned __int8 *)*a2[2] + 8) : *((_DWORD *)a2 + 2);
      if (v49 == 13 || v49 <= 6)
      {
        uint64_t result = (llvm::ConstantExpr *)llvm::Constant::getAllOnesValue((llvm::Constant *)a2, v20, v21);
        if (result) {
          return result;
        }
      }
    }
LABEL_17:
    if (v17 != v8 || v14 != v10) {
      goto LABEL_24;
    }
    uint64_t v22 = (uint64_t)v7;
    if ((*((_DWORD *)v7 + 2) & 0xFE) == 0x12) {
      uint64_t v22 = **((void **)v7 + 2);
    }
    BOOL v23 = sub_1CBFB72C8((uint64_t)a3, v22);
    uint64_t v24 = (llvm::Constant *)a2;
    if ((a2[1] & 0xFE) == 0x12) {
      uint64_t v24 = *a2[2];
    }
    if (v23 != sub_1CBFB72C8((uint64_t)a3, (uint64_t)v24))
    {
LABEL_24:
      uint64_t v25 = (uint64_t)*this;
      unint64_t v26 = (unint64_t)(sub_1CB83544C((uint64_t)a3, (uint64_t)a2) + 7) >> 3;
      BOOL v28 = v27 == 1;
      char Alignment = llvm::DataLayout::getAlignment(a3, (llvm::Type *)a2, 1);
      uint64_t v30 = ((1 << Alignment) + v26 - 1) & -(1 << Alignment);
      uint64_t v31 = sub_1CB83544C((uint64_t)a3, v25);
      BOOL v33 = v32 == 1;
      unint64_t v34 = (unint64_t)(v31 + 7) >> 3;
      char v35 = llvm::DataLayout::getAlignment(a3, (llvm::Type *)v25, 1);
      if (v30 == (((1 << v35) + v34 - 1) & -(1 << v35))
        && ((v28 ^ v33 ^ 1) & 1) != 0
        && *((unsigned char *)a2 + 8) == 18
        && *(unsigned char *)(v25 + 8) == 18
        && *((_DWORD *)a2 + 8) == 3
        && *(_DWORD *)(v25 + 32) == 4
        && *a2[2] == **(llvm::Constant ***)(v25 + 16)
        && *((unsigned __int8 *)llvm::Constant::getAggregateElement((llvm::Constant *)this, (llvm::Type *)3)+ 16)- 11 <= 1)
      {
        uint64_t v55 = llvm::UndefValue::get(v7, v36);
        uint64_t v57 = 0x100000000;
        int v58 = 2;
        return (llvm::ConstantExpr *)llvm::ConstantExpr::getShuffleVector((llvm *)this, v55, (int *)&v57, (llvm::Type *)3, 0);
      }
      goto LABEL_48;
    }
    int v37 = *((unsigned __int8 *)v7 + 8);
    if (v37 == 13)
    {
      unsigned int v38 = 48;
      int v39 = 15;
    }
    else
    {
      if (v37 != 15)
      {
        uint64_t v40 = 49;
        goto LABEL_47;
      }
      unsigned int v38 = 47;
      int v39 = 13;
    }
    uint64_t v40 = *((unsigned __int8 *)a2 + 8) == v39 ? v38 : 49;
LABEL_47:
    if (llvm::CastInst::castIsValid(v40, *this, (uint64_t)a2))
    {
      return llvm::ConstantExpr::getCast((llvm::ConstantExpr *)v40, (llvm::ConstantExpr *)this, a2, 0);
    }
LABEL_48:
    if ((*((_DWORD *)v7 + 2) & 0xFC | 2) != 0x12) {
      return 0;
    }
    if (*((_DWORD *)v7 + 2) == 16) {
      break;
    }
    if ((*((_DWORD *)v7 + 2) & 0xFE) == 0x12)
    {
      uint64_t v43 = *((void *)v7 + 3);
      uint64_t v44 = sub_1CB83544C((uint64_t)a3, v43);
      int v46 = v45;
      uint64_t v48 = sub_1CB83544C((uint64_t)a3, v43);
      uint64_t result = 0;
      if (v44 != ((v48 + 7) & 0xFFFFFFFFFFFFFFF8) || v46 != (v47 == 1)) {
        return result;
      }
    }
    AggregateElement = (llvm *)llvm::Constant::getAggregateElement((llvm::Constant *)this, 0);
LABEL_58:
    this = (llvm::Constant **)AggregateElement;
    if (!AggregateElement) {
      return 0;
    }
  }
  unint64_t v41 = 0;
  while (1)
  {
    uint64_t result = (llvm::ConstantExpr *)llvm::Constant::getAggregateElement((llvm::Constant *)this, v41);
    if (!result) {
      return result;
    }
    AggregateElement = result;
    unint64_t v41 = (llvm::Type *)(v41 + 1);
    if (sub_1CB83544C((uint64_t)a3, *(void *)result)) {
      goto LABEL_58;
    }
  }
}

llvm::UndefValue *llvm::ConstantFoldLoadFromUniformValue(llvm *this, llvm::Constant *a2, llvm::Type *a3)
{
  int v4 = *((unsigned __int8 *)this + 16);
  if (v4 == 12)
  {
    return (llvm::UndefValue *)llvm::PoisonValue::get(a2, a2);
  }
  else if ((v4 - 11) <= 1)
  {
    return llvm::UndefValue::get(a2, a2);
  }
  else
  {
    if (v4 == 16)
    {
      uint64_t v6 = *((unsigned int *)this + 8);
      if (v6 >= 0x41)
      {
        int v12 = 0;
        int64_t v13 = (unint64_t)(v6 + 63) >> 6;
        do
        {
          if (v13-- < 1) {
            break;
          }
          unint64_t v15 = *(void *)(*((void *)this + 3) + 8 * v13);
          v12 += __clz(v15);
        }
        while (!v15);
        int v16 = v6 | 0xFFFFFFC0;
        if ((v6 & 0x3F) == 0) {
          int v16 = 0;
        }
        if (v12 + v16 != v6) {
          goto LABEL_6;
        }
      }
      else if (*((void *)this + 3))
      {
        goto LABEL_6;
      }
    }
    else if (v4 == 17)
    {
      if ((sub_1CB844168((uint64_t)this, 0.0) & 1) == 0) {
        goto LABEL_6;
      }
    }
    else if ((v4 - 18) >= 3 && v4 != 13)
    {
LABEL_6:
      if (!llvm::Constant::isAllOnesValue(this)) {
        return 0;
      }
      unsigned int v11 = (*((_DWORD *)a2 + 2) & 0xFE) == 0x12
          ? *(unsigned __int8 *)(**((void **)a2 + 2) + 8)
          : *((_DWORD *)a2 + 2);
      if (v11 != 13 && v11 > 6) {
        return 0;
      }
      return (llvm::UndefValue *)llvm::Constant::getAllOnesValue(a2, v7, v8);
    }
    if ((*((_DWORD *)a2 + 2) & 0xFE) == 0xA) {
      goto LABEL_6;
    }
    return llvm::Constant::getNullValue(a2, a2, a3);
  }
}

BOOL sub_1CBFB72C8(uint64_t a1, uint64_t a2)
{
  BOOL result = 0;
  if (a2 && *(_DWORD *)(a2 + 8) == 15)
  {
    int v4 = *(__int32 **)(a1 + 384);
    size_t v5 = *(unsigned int *)(a1 + 392);
    uint64_t v6 = wmemchr(v4, *(_DWORD *)(a2 + 8) >> 8, v5);
    if (v6) {
      uint64_t v7 = v6;
    }
    else {
      uint64_t v7 = &v4[v5];
    }
    return v5 != v7 - v4;
  }
  return result;
}

llvm::UndefValue *llvm::ConstantFoldLoadFromConst(llvm::Type **this, llvm::Constant *a2, llvm::Type *a3, const llvm::APInt *a4, const llvm::DataLayout *a5)
{
  v40[6] = *MEMORY[0x1E4F143B8];
  unsigned int v9 = *((_DWORD *)a3 + 2);
  unsigned int v36 = v9;
  if (v9 > 0x40) {
    operator new[]();
  }
  uint64_t v35 = *(void *)a3;
  AggregateElement = (llvm::Constant *)this;
  if (v35)
  {
    AggregateElement = 0;
    unsigned int v11 = *((unsigned __int8 *)this + 16);
    if (v11 > 0xF || ((1 << v11) & 0xC700) == 0)
    {
LABEL_31:
      if (v9 >= 0x41 && v35) {
        MEMORY[0x1D25D9CB0](v35, 0x1000C8000313F17);
      }
      goto LABEL_32;
    }
    int v37 = *this;
    llvm::DataLayout::getGEPIndicesForOffset(a4, &v37, (llvm::APInt *)&v35, (uint64_t)&v38);
    unsigned int v12 = v36;
    if (v36 > 0x40)
    {
      if (llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v35) != v12) {
        goto LABEL_22;
      }
    }
    else if (v35)
    {
      goto LABEL_22;
    }
    int64_t v13 = v38;
    unsigned int v14 = *((_DWORD *)v38 + 2);
    if (v14 > 0x40)
    {
      if (llvm::APInt::countLeadingZerosSlowCase(v38) == v14)
      {
LABEL_9:
        unint64_t v15 = (llvm::APInt *)((char *)v13 + 16);
        uint64_t v16 = 16 * v39 - 16;
        AggregateElement = (llvm::Constant *)this;
        while (v16)
        {
          unsigned int v17 = *((_DWORD *)v15 + 2);
          unsigned int v18 = v17 - 1;
          if (v17 > 0x40)
          {
            unint64_t v20 = *(llvm::Type ***)v15;
            if (((*(void *)(*(void *)v15 + 8 * (v18 >> 6)) >> v18) & 1) != 0
              || v17 - llvm::APInt::countLeadingZerosSlowCase(v15) > 0x1F)
            {
              goto LABEL_22;
            }
            uint64_t v19 = *v20;
          }
          else
          {
            uint64_t v19 = *(llvm::Type **)v15;
            if ((*(void *)v15 & ((1 << v18) | 0xFFFFFFFF80000000)) != 0) {
              goto LABEL_22;
            }
          }
          AggregateElement = (llvm::Constant *)llvm::Constant::getAggregateElement(AggregateElement, v19);
          unint64_t v15 = (llvm::APInt *)((char *)v15 + 16);
          v16 -= 16;
          if (!AggregateElement) {
            goto LABEL_23;
          }
        }
        goto LABEL_23;
      }
    }
    else if (!*(void *)v38)
    {
      goto LABEL_9;
    }
LABEL_22:
    AggregateElement = 0;
LABEL_23:
    unint64_t v21 = v38;
    if (v39)
    {
      uint64_t v22 = 16 * v39;
      do
      {
        if (*(_DWORD *)((char *)v21 + v22 - 8) >= 0x41u)
        {
          uint64_t v34 = *(void *)((char *)v21 + v22 - 16);
          if (v34) {
            MEMORY[0x1D25D9CB0](v34, 0x1000C8000313F17);
          }
        }
        v22 -= 16;
      }
      while (v22);
      unint64_t v21 = v38;
    }
    if (v21 != (llvm::APInt *)v40) {
      free(v21);
    }
    unsigned int v9 = v36;
    goto LABEL_31;
  }
LABEL_32:
  if (!AggregateElement
    || (BOOL result = llvm::ConstantFoldLoadThroughBitcast((llvm::Constant **)AggregateElement, (llvm::Constant ***)a2, a4, a4)) == 0)
  {
    uint64_t v24 = *this;
    uint64_t v25 = sub_1CB83544C((uint64_t)a4, (uint64_t)*this);
    BOOL v27 = v26 == 1;
    char Alignment = llvm::DataLayout::getAlignment(a4, v24, 1);
    if (v27
      || (sub_1CBFC5D80(a3, ((1 << Alignment) + ((unint64_t)(v25 + 7) >> 3) - 1) & -(1 << Alignment)) & 1) != 0)
    {
      BOOL result = llvm::ConstantFoldLoadFromUniformValue((llvm *)this, a2, v29);
      if (!result)
      {
        int v31 = *((_DWORD *)a3 + 2);
        if (v31 - sub_1CBAB1CB8(a3) + 1 > 0x40) {
          return 0;
        }
        unsigned int v32 = *((_DWORD *)a3 + 2);
        uint64_t v33 = v32 > 0x40 ? **(void **)a3 : (uint64_t)(*(void *)a3 << -(char)v32) >> -(char)v32;
        BOOL result = sub_1CBFB76DC((uint64_t *)this, (uint64_t)a2, v33, (uint64_t)a4);
        if (!result) {
          return 0;
        }
      }
    }
    else
    {
      return llvm::UndefValue::get(a2, v30);
    }
  }
  return result;
}

llvm::UndefValue *sub_1CBFB76DC(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v90 = *MEMORY[0x1E4F143B8];
  unsigned int v8 = *(_DWORD *)(a2 + 8);
  if (v8 != 13)
  {
    if (v8 == 19) {
      return 0;
    }
    BOOL v9 = (v8 & 0xFE) != 0x12 && v8 >= 7u;
    if (v9 && v8 != 15) {
      return 0;
    }
    unsigned int v11 = *(llvm::IntegerType **)*a1;
    unsigned int v12 = (llvm::LLVMContext *)sub_1CB83544C(a4, a2);
    uint64_t v13 = llvm::IntegerType::get(v11, v12);
    uint64_t v14 = sub_1CBFB76DC(a1, v13, a3, a4);
    unsigned int v17 = (llvm::detail::IEEEFloat *)v14;
    if (!v14) {
      return v17;
    }
    int v18 = *(unsigned __int8 *)(v14 + 16);
    if (v18 == 16)
    {
      uint64_t v19 = *(unsigned int *)(v14 + 32);
      if (v19 < 0x41)
      {
        unsigned int v20 = *(_DWORD *)(a2 + 8);
        int v21 = v20 & 0xFE;
        if (*(void *)(v14 + 24)) {
          goto LABEL_15;
        }
LABEL_66:
        if (v21 != 10)
        {
LABEL_100:
          return llvm::Constant::getNullValue((llvm::Constant *)a2, v15, v16);
        }
        BOOL v23 = (llvm::PoisonValue *)a2;
        if (v20 == 15) {
          goto LABEL_68;
        }
        goto LABEL_79;
      }
      int v75 = 0;
      int64_t v76 = (unint64_t)(v19 + 63) >> 6;
      do
      {
        BOOL v77 = v76-- < 1;
        if (v77) {
          break;
        }
        unint64_t v78 = *(void *)(*(void *)(v14 + 24) + 8 * v76);
        v75 += __clz(v78);
      }
      while (!v78);
      int v79 = v19 | 0xFFFFFFC0;
      if ((v19 & 0x3F) == 0) {
        int v79 = 0;
      }
      int v80 = v75 + v79;
      unsigned int v20 = *(_DWORD *)(a2 + 8);
      int v21 = v20 & 0xFE;
      if (v80 == v19) {
        goto LABEL_66;
      }
    }
    else if (v18 == 17)
    {
      char v39 = sub_1CB844168(v14, 0.0);
      unsigned int v20 = *(_DWORD *)(a2 + 8);
      int v21 = v20 & 0xFE;
      if (v39) {
        goto LABEL_66;
      }
    }
    else
    {
      if ((v18 - 18) < 3 || v18 == 13)
      {
        unsigned int v20 = *(_DWORD *)(a2 + 8);
        int v21 = v20 & 0xFE;
        goto LABEL_66;
      }
      unsigned int v20 = *(_DWORD *)(a2 + 8);
      int v21 = v20 & 0xFE;
    }
LABEL_15:
    char v22 = v20;
    if (v21 == 18) {
      char v22 = *(unsigned char *)(**(void **)(a2 + 16) + 8);
    }
    BOOL v23 = (llvm::PoisonValue *)a2;
    if (v22 == 15)
    {
      if (v21 == 18) {
        unsigned int v20 = *(_DWORD *)(**(void **)(a2 + 16) + 8);
      }
LABEL_68:
      if (v20 < 0x100) {
        goto LABEL_77;
      }
      unsigned int v52 = v20 >> 8;
      uint64_t v53 = *(unsigned int *)(a4 + 240);
      uint64_t v54 = *(void *)(a4 + 232);
      if (v53)
      {
        uint64_t v54 = *(void *)(a4 + 232);
        unint64_t v55 = *(unsigned int *)(a4 + 240);
        do
        {
          unint64_t v56 = v55 >> 1;
          uint64_t v57 = v54 + 16 * (v55 >> 1);
          unsigned int v58 = *(_DWORD *)(v57 + 8);
          uint64_t v59 = v57 + 16;
          v55 += ~(v55 >> 1);
          if (v58 < v52) {
            uint64_t v54 = v59;
          }
          else {
            unint64_t v55 = v56;
          }
        }
        while (v55);
      }
      if (v54 == *(void *)(a4 + 232) + 16 * v53 || *(_DWORD *)(v54 + 8) != v52) {
LABEL_77:
      }
        uint64_t v54 = *(void *)(a4 + 232);
      uint64_t v60 = (uint64_t **)llvm::IntegerType::get(*(llvm::IntegerType **)a2, (llvm::LLVMContext *)*(unsigned int *)(v54 + 4));
      BOOL v23 = (llvm::PoisonValue *)v60;
      if ((*(_DWORD *)(a2 + 8) & 0xFE) == 0x12)
      {
        uint64_t v85 = (llvm::Type *)*(unsigned int *)(a2 + 32);
        if (*(_DWORD *)(a2 + 8) == 19) {
          llvm::ScalableVectorType::get(v60, v85);
        }
        else {
          llvm::FixedVectorType::get((llvm::FixedVectorType *)v60, v85);
        }
        BOOL v23 = v86;
      }
    }
LABEL_79:
    uint64_t v61 = sub_1CBFBB130((uint64_t)v17, v23, (const llvm::APFloat *)a4);
    unsigned int v17 = v61;
    int v62 = *(_DWORD *)(a2 + 8) & 0xFE;
    if (v62 == 18) {
      int v63 = *(unsigned __int8 *)(**(void **)(a2 + 16) + 8);
    }
    else {
      int v63 = *(_DWORD *)(a2 + 8);
    }
    if (v63 != 15) {
      return v17;
    }
    unsigned int v64 = *((unsigned __int8 *)v61 + 16);
    if (v61 && v64 == 16)
    {
      uint64_t v65 = *((unsigned int *)v61 + 8);
      if (v65 >= 0x41)
      {
        int v81 = 0;
        int64_t v82 = (unint64_t)(v65 + 63) >> 6;
        do
        {
          BOOL v77 = v82-- < 1;
          if (v77) {
            break;
          }
          unint64_t v83 = *(void *)(*((void *)v61 + 3) + 8 * v82);
          v81 += __clz(v83);
        }
        while (!v83);
        int v84 = v65 | 0xFFFFFFC0;
        if ((v65 & 0x3F) == 0) {
          int v84 = 0;
        }
        if (v81 + v84 != v65) {
          goto LABEL_87;
        }
      }
      else if (*((void *)v61 + 3))
      {
        goto LABEL_87;
      }
      goto LABEL_95;
    }
    if (v61 && v64 == 17)
    {
      char v66 = sub_1CB844168((uint64_t)v61, 0.0);
      int v62 = *(_DWORD *)(a2 + 8) & 0xFE;
      if (v66) {
        goto LABEL_95;
      }
    }
    else if (v64 <= 0x14 && ((1 << v64) & 0x1C2000) != 0)
    {
LABEL_95:
      unint64_t v15 = (llvm::Type *)a2;
      if (v62 == 10) {
        goto LABEL_96;
      }
      goto LABEL_100;
    }
LABEL_87:
    unint64_t v15 = (llvm::Type *)a2;
    if (v62 == 18) {
      unint64_t v15 = **(llvm::Type ***)(a2 + 16);
    }
LABEL_96:
    if (!sub_1CBFB72C8(a4, (uint64_t)v15))
    {
      return sub_1CC56C0C0((llvm *)0x30, v17, (llvm::Constant *)a2, 0);
    }
    return 0;
  }
  unsigned int v24 = v8 >> 8;
  if (v24 - 257 < 0xFFFFFF00) {
    return 0;
  }
  unsigned int v26 = (v24 + 7) >> 3;
  if (-(uint64_t)v26 < a3)
  {
    BOOL v27 = (llvm::Type *)*a1;
    uint64_t v28 = sub_1CB83544C(a4, *a1);
    BOOL v30 = v29 == 1;
    char Alignment = llvm::DataLayout::getAlignment((llvm::DataLayout *)a4, v27, 1);
    if (v30) {
      return 0;
    }
    if ((uint64_t)(((1 << Alignment) + ((unint64_t)(v28 + 7) >> 3) - 1) & -(1 << Alignment)) > a3)
    {
      memset(v89, 0, sizeof(v89));
      int v32 = sub_1CBFC5E34((unsigned __int8 *)a1, a3 & ~(a3 >> 63), (unsigned char *)v89 + (-a3 & (a3 >> 63)), v26 + (a3 & (a3 >> 63)), a4);
      unsigned int v17 = 0;
      if (!v32) {
        return v17;
      }
      unint64_t v34 = *(unsigned int *)(a2 + 8);
      unint64_t v35 = v34 >> 8;
      unsigned int v88 = *(_DWORD *)(a2 + 8) >> 8;
      if (v34 >> 8 > 0x40) {
        operator new[]();
      }
      int v87 = 0;
      if (*(unsigned char *)a4)
      {
        if (v34 >> 8 > 0x40)
        {
          unint64_t v37 = (unint64_t)v87;
          uint64_t v43 = v87;
          *int v87 = LOBYTE(v89[0]);
          bzero(v43 + 1, (((v35 + 63) >> 3) & 0x3FFFF8) - 8);
        }
        else
        {
          if (v34 <= 0xFF) {
            LOBYTE(v36) = 0;
          }
          else {
            unint64_t v36 = 0xFFFFFFFFFFFFFFFFLL >> -BYTE1(v34);
          }
          unint64_t v37 = v36 & LOBYTE(v89[0]);
          int v87 = (void *)v37;
        }
        unsigned int v44 = v26 - 1;
        if (v26 != 1)
        {
          int v45 = (unsigned __int8 *)v89 + 1;
          while (v35 > 0x40)
          {
            llvm::APInt::shlSlowCase((llvm::APInt *)&v87, 8u);
            LODWORD(v35) = v88;
            uint64_t v49 = *v45;
            if (v88 <= 0x40)
            {
              unint64_t v48 = (unint64_t)v87;
LABEL_57:
              unint64_t v50 = v48 | v49;
              unint64_t v51 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v35;
              if (!v35) {
                unint64_t v51 = 0;
              }
              unint64_t v37 = v51 & v50;
              int v87 = (void *)(v51 & v50);
              goto LABEL_60;
            }
            unint64_t v37 = (unint64_t)v87;
            *v87 |= v49;
LABEL_60:
            ++v45;
            if (!--v44) {
              goto LABEL_105;
            }
          }
          unint64_t v46 = v37 << 8;
          unint64_t v47 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v35;
          if (!v35) {
            unint64_t v47 = 0;
          }
          if (v35 == 8)
          {
            unint64_t v46 = 0;
            unint64_t v47 = 255;
          }
          unint64_t v48 = v47 & v46;
          uint64_t v49 = *v45;
          goto LABEL_57;
        }
LABEL_105:
        unsigned int v17 = (llvm::detail::IEEEFloat *)llvm::ConstantInt::get(*(llvm::ConstantInt **)a2, (llvm::LLVMContext *)&v87, v33);
        if (v88 >= 0x41 && v87) {
          MEMORY[0x1D25D9CB0](v87, 0x1000C8000313F17);
        }
        return v17;
      }
      uint64_t v40 = *((unsigned __int8 *)v89 + v26 - 1);
      if (v34 >> 8 > 0x40)
      {
        unint64_t v42 = (unint64_t)v87;
        uint64_t v67 = v87;
        *int v87 = v40;
        bzero(v67 + 1, (((v35 + 63) >> 3) & 0x3FFFF8) - 8);
      }
      else
      {
        if (v34 <= 0xFF) {
          unint64_t v41 = 0;
        }
        else {
          unint64_t v41 = 0xFFFFFFFFFFFFFFFFLL >> -BYTE1(v34);
        }
        unint64_t v42 = v41 & v40;
        int v87 = (void *)(v41 & v40);
      }
      if (v26 == 1) {
        goto LABEL_105;
      }
      unsigned int v68 = v26 - 2;
      while (v35 > 0x40)
      {
        llvm::APInt::shlSlowCase((llvm::APInt *)&v87, 8u);
        LODWORD(v35) = v88;
        uint64_t v72 = *((unsigned __int8 *)v89 + v68);
        if (v88 <= 0x40)
        {
          unint64_t v71 = (unint64_t)v87;
LABEL_115:
          unint64_t v73 = v71 | v72;
          unint64_t v74 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v35;
          if (!v35) {
            unint64_t v74 = 0;
          }
          unint64_t v42 = v74 & v73;
          int v87 = (void *)(v74 & v73);
          goto LABEL_118;
        }
        unint64_t v42 = (unint64_t)v87;
        *v87 |= v72;
LABEL_118:
        if (--v68 == -1) {
          goto LABEL_105;
        }
      }
      unint64_t v69 = v42 << 8;
      unint64_t v70 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v35;
      if (!v35) {
        unint64_t v70 = 0;
      }
      if (v35 == 8)
      {
        unint64_t v69 = 0;
        unint64_t v70 = 255;
      }
      unint64_t v71 = v70 & v69;
      uint64_t v72 = *((unsigned __int8 *)v89 + v68);
      goto LABEL_115;
    }
  }

  return llvm::UndefValue::get((llvm::UndefValue *)a2, (llvm::Type *)a2);
}

void *llvm::ConstantFoldLoadFromConstPtr(llvm::GlobalValue *a1, uint64_t a2, llvm::APInt *a3, llvm::DataLayout *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v10 = llvm::Value::stripAndAccumulateConstantOffsets(a1, a4, a3, 1, 0, 0, a7);
  unsigned int v11 = (llvm::Type ***)v10;
  if (v10)
  {
    if (*((unsigned char *)v10 + 16) == 3
      && (*((unsigned char *)v10 + 80) & 1) != 0
      && (*((_DWORD *)v10 + 5) & 0x7FFFFFF) != 0
      && (llvm::GlobalValue::isInterposable(v10) & 1) == 0
      && ((_BYTE)v11[10] & 2) == 0)
    {
      BOOL result = llvm::ConstantFoldLoadFromConst(*(v11 - 4), (llvm::Constant *)a2, a3, a4, v12);
      if (result) {
        return result;
      }
    }
  }
  UnderlyingObject = llvm::getUnderlyingObject((llvm *)v11, (const llvm::Value *)6);
  if (!UnderlyingObject) {
    return 0;
  }
  unint64_t v15 = UnderlyingObject;
  if (*((unsigned char *)UnderlyingObject + 16) != 3
    || (*((unsigned char *)UnderlyingObject + 80) & 1) == 0
    || (*((_DWORD *)UnderlyingObject + 5) & 0x7FFFFFF) == 0
    || (llvm::GlobalValue::isInterposable(UnderlyingObject) & 1) != 0
    || (*((unsigned char *)v15 + 80) & 2) != 0)
  {
    return 0;
  }
  uint64_t v18 = *((void *)v15 - 4);
  int v19 = *(unsigned __int8 *)(v18 + 16);
  if (v19 == 12)
  {
    BOOL result = llvm::PoisonValue::get((llvm::PoisonValue *)a2, v16);
    if (result) {
      return result;
    }
    return 0;
  }
  if ((v19 - 11) <= 1)
  {
    BOOL result = llvm::UndefValue::get((llvm::UndefValue *)a2, v16);
    if (result) {
      return result;
    }
    return 0;
  }
  if (v19 != 16)
  {
    if (v19 == 17)
    {
      if ((sub_1CB844168(v18, 0.0) & 1) == 0) {
        goto LABEL_19;
      }
    }
    else if ((v19 - 18) >= 3 && v19 != 13)
    {
      goto LABEL_19;
    }
    goto LABEL_25;
  }
  uint64_t v20 = *(unsigned int *)(v18 + 32);
  if (v20 < 0x41)
  {
    if (*(void *)(v18 + 24)) {
      goto LABEL_19;
    }
    goto LABEL_25;
  }
  int v24 = 0;
  int64_t v25 = (unint64_t)(v20 + 63) >> 6;
  do
  {
    if (v25-- < 1) {
      break;
    }
    unint64_t v27 = *(void *)(*(void *)(v18 + 24) + 8 * v25);
    v24 += __clz(v27);
  }
  while (!v27);
  int v28 = v20 | 0xFFFFFFC0;
  if ((v20 & 0x3F) == 0) {
    int v28 = 0;
  }
  if (v24 + v28 == v20)
  {
LABEL_25:
    if ((*(_DWORD *)(a2 + 8) & 0xFE) == 0xA) {
      goto LABEL_19;
    }
    BOOL result = llvm::Constant::getNullValue((llvm::Constant *)a2, v16, v17);
    if (result) {
      return result;
    }
    return 0;
  }
LABEL_19:
  if (!llvm::Constant::isAllOnesValue((llvm::Constant *)v18)) {
    return 0;
  }
  unsigned int v23 = (*(_DWORD *)(a2 + 8) & 0xFE) == 0x12
      ? *(unsigned __int8 *)(**(void **)(a2 + 16) + 8)
      : *(_DWORD *)(a2 + 8);
  if (v23 != 13 && v23 > 6) {
    return 0;
  }
  BOOL result = llvm::Constant::getAllOnesValue((llvm::Constant *)a2, v21, v22);
  if (!result) {
    return 0;
  }
  return result;
}

void *llvm::ConstantFoldLoadFromConstPtr(llvm *this, llvm::Constant *a2, llvm::Type *a3, const llvm::DataLayout *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  unsigned int v7 = *(_DWORD *)(*(void *)this + 8);
  if ((v7 & 0xFE) == 0x12) {
    unsigned int v7 = *(_DWORD *)(**(void **)(*(void *)this + 16) + 8);
  }
  if (v7 < 0x100) {
    goto LABEL_12;
  }
  unsigned int v8 = v7 >> 8;
  uint64_t v9 = *((unsigned int *)a3 + 60);
  uint64_t v10 = *((void *)a3 + 29);
  if (v9)
  {
    uint64_t v10 = *((void *)a3 + 29);
    unint64_t v11 = *((unsigned int *)a3 + 60);
    do
    {
      unint64_t v12 = v11 >> 1;
      uint64_t v13 = v10 + 16 * (v11 >> 1);
      unsigned int v14 = *(_DWORD *)(v13 + 8);
      uint64_t v15 = v13 + 16;
      v11 += ~(v11 >> 1);
      if (v14 < v8) {
        uint64_t v10 = v15;
      }
      else {
        unint64_t v11 = v12;
      }
    }
    while (v11);
  }
  if (v10 == *((void *)a3 + 29) + 16 * v9 || *(_DWORD *)(v10 + 8) != v8) {
LABEL_12:
  }
    uint64_t v10 = *((void *)a3 + 29);
  if (*(_DWORD *)(v10 + 12) > 0x40u) {
    operator new[]();
  }
  unsigned int v19 = *(_DWORD *)(v10 + 12);
  uint64_t v18 = 0;
  uint64_t v16 = llvm::ConstantFoldLoadFromConstPtr(this, (uint64_t)a2, (llvm::APInt *)&v18, a3, a5, a6, a7);
  if (v19 >= 0x41 && v18) {
    MEMORY[0x1D25D9CB0](v18, 0x1000C8000313F17);
  }
  return v16;
}

llvm::UndefValue *llvm::ConstantFoldInstruction(uint64_t a1, llvm::DataLayout *a2, llvm::DSOLocalEquivalent **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v35[9] = *MEMORY[0x1E4F143B8];
  int v10 = *(unsigned __int8 *)(a1 + 16);
  if (a1 && v10 == 83)
  {
    int v32 = (void *)1;
    for (uint64_t i = 8; i != 72; i += 16)
      *(void **)((char *)&v32 + i) = (void *)-4096;
    int v12 = *(_DWORD *)(a1 + 20);
    if ((v12 & 0x40000000) != 0)
    {
      unsigned int v14 = *(uint64_t **)(a1 - 8);
      uint64_t v13 = v12 & 0x7FFFFFF;
      if (!v13) {
        goto LABEL_33;
      }
    }
    else
    {
      uint64_t v13 = v12 & 0x7FFFFFF;
      unsigned int v14 = (uint64_t *)(a1 - 32 * v13);
      if (!v13) {
        goto LABEL_33;
      }
    }
    int v24 = 0;
    uint64_t v25 = 32 * v13;
    do
    {
      unsigned int v26 = *(unsigned __int8 *)(*v14 + 16);
      if (v26 - 11 >= 2)
      {
        if (v26 > 0x14) {
          goto LABEL_45;
        }
        unint64_t v27 = sub_1CBFB8694(*v14, a2, (BOOL)a3, (uint64_t)&v32);
        if (v24)
        {
          BOOL v28 = v27 == v24;
          int v24 = v27;
          if (!v28)
          {
LABEL_45:
            int v24 = 0;
            goto LABEL_46;
          }
        }
        else
        {
          int v24 = v27;
        }
      }
      v14 += 4;
      v25 -= 32;
    }
    while (v25);
    if (v24) {
      goto LABEL_46;
    }
LABEL_33:
    int v24 = llvm::UndefValue::get(*(llvm::UndefValue **)a1, a2);
LABEL_46:
    if ((v32 & 1) == 0)
    {
      uint64_t v30 = v33;
LABEL_62:
      MEMORY[0x1D25D9CD0](v30, 8);
      return v24;
    }
    return v24;
  }
  int v15 = *(_DWORD *)(a1 + 20);
  if ((v15 & 0x40000000) != 0)
  {
    uint64_t v17 = *(void *)(a1 - 8);
    uint64_t v16 = v15 & 0x7FFFFFF;
  }
  else
  {
    uint64_t v16 = v15 & 0x7FFFFFF;
    uint64_t v17 = a1 - 32 * v16;
  }
  uint64_t v18 = 32 * v16;
  if (v16)
  {
    uint64_t v19 = 32 * v16;
    while (*(unsigned __int8 *)(*(void *)v17 + 16) < 0x15u)
    {
      v17 += 32;
      v19 -= 32;
      if (!v19) {
        goto LABEL_15;
      }
    }
    return 0;
  }
LABEL_15:
  v35[0] = 1;
  for (uint64_t j = 1; j != 9; j += 2)
    v35[j] = -4096;
  int v32 = v34;
  uint64_t v33 = 0x800000000;
  if ((v15 & 0x40000000) != 0)
  {
    int v21 = *(uint64_t **)(a1 - 8);
    if (v16)
    {
      do
      {
LABEL_19:
        char v22 = sub_1CBFB8694(*v21, a2, (BOOL)a3, (uint64_t)v35);
        if (v33 >= (unint64_t)HIDWORD(v33)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v32 + v33) = v22;
        uint64_t v23 = (v33 + 1);
        LODWORD(v33) = v33 + 1;
        v21 += 4;
        v18 -= 32;
      }
      while (v18);
      int v10 = *(unsigned __int8 *)(a1 + 16);
      if (!a1) {
        goto LABEL_40;
      }
      goto LABEL_38;
    }
  }
  else
  {
    int v21 = (uint64_t *)(a1 - 32 * v16);
    if (v16) {
      goto LABEL_19;
    }
  }
  uint64_t v23 = 0;
  if (!a1) {
    goto LABEL_40;
  }
LABEL_38:
  if ((v10 - 83) >= 0xFFFFFFFE)
  {
    InsertValue = llvm::ConstantFoldCompareInstOperands(*(_WORD *)(a1 + 18) & 0x3F, *(llvm::ConstantExpr **)v32, *((llvm::Constant **)v32 + 1), a2, (BOOL)a3);
    goto LABEL_56;
  }
LABEL_40:
  if (a1 && v10 == 60)
  {
    if (*(_WORD *)(a1 + 18))
    {
      int v24 = 0;
      goto LABEL_57;
    }
    InsertValue = (llvm::UndefValue *)llvm::ConstantFoldLoadFromConstPtr(*(llvm **)v32, *(llvm::Constant **)a1, a2, (const llvm::DataLayout *)v23, a5, a6, a7);
  }
  else if (a1 && v10 == 93)
  {
    InsertValue = llvm::ConstantExpr::getInsertValue(*(llvm::Constant **)v32, *((uint64_t **)v32 + 1), *(_DWORD **)(a1 + 64), *(unsigned int *)(a1 + 72), 0);
  }
  else if (a1 && v10 == 92)
  {
    InsertValue = llvm::ConstantExpr::getExtractValue(*(llvm::Constant **)v32, *(unsigned int **)(a1 + 64), *(unsigned int *)(a1 + 72), 0);
  }
  else
  {
    InsertValue = sub_1CBFB8E50((llvm *)a1, (llvm *)(v10 - 28), (uint64_t **)v32, v23, a2, a3);
  }
LABEL_56:
  int v24 = InsertValue;
LABEL_57:
  if (v32 != v34) {
    free(v32);
  }
  if ((v35[0] & 1) == 0)
  {
    uint64_t v30 = v35[1];
    goto LABEL_62;
  }
  return v24;
}

llvm::Value *sub_1CBFB8694(uint64_t a1, llvm::DataLayout *a2, BOOL a3, uint64_t a4)
{
  Impl = (llvm::Value *)a1;
  v31[8] = *MEMORY[0x1E4F143B8];
  int v5 = *(unsigned __int8 *)(a1 + 16);
  if (v5 != 10 && v5 != 5) {
    return Impl;
  }
  int v29 = v31;
  uint64_t v30 = 0x800000000;
  int v9 = *(_DWORD *)(a1 + 20);
  if ((v9 & 0x40000000) == 0)
  {
    uint64_t v10 = v9 & 0x7FFFFFF;
    unint64_t v11 = (uint64_t *)(a1 - 32 * v10);
    if (v10) {
      goto LABEL_8;
    }
LABEL_27:
    uint64_t v20 = 0;
    goto LABEL_28;
  }
  unint64_t v11 = *(uint64_t **)(a1 - 8);
  uint64_t v10 = v9 & 0x7FFFFFF;
  if (!v10) {
    goto LABEL_27;
  }
LABEL_8:
  uint64_t v12 = 32 * v10;
  do
  {
    uint64_t v13 = *v11;
    int v14 = *(unsigned __int8 *)(*v11 + 16);
    if (v14 == 10 || v14 == 5)
    {
      uint64_t v16 = sub_1CBFC6318(a4, *v11);
      if (*(_DWORD *)a4) {
        uint64_t v17 = a4 + 8;
      }
      else {
        uint64_t v17 = *(void *)(a4 + 8);
      }
      unsigned int v18 = *(_DWORD *)(a4 + 16);
      if (*(_DWORD *)a4) {
        unsigned int v18 = 4;
      }
      if (v17 + 16 * v18 == v16)
      {
        uint64_t v19 = sub_1CBFB8694(v13, a2, a3, a4);
        uint64_t v27 = v13;
        uint64_t v28 = v19;
        sub_1CBFC6440(a4, &v27, &v28, (uint64_t)v26);
        uint64_t v13 = v19;
      }
      else
      {
        uint64_t v13 = *(void *)(v16 + 8);
      }
    }
    if (v30 >= (unint64_t)HIDWORD(v30)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)v29 + v30) = v13;
    uint64_t v20 = (v30 + 1);
    LODWORD(v30) = v30 + 1;
    v11 += 4;
    v12 -= 32;
  }
  while (v12);
  int v5 = *((unsigned __int8 *)Impl + 16);
LABEL_28:
  if (v5 == 5)
  {
    if (*((unsigned __int16 *)Impl + 9) - 53 > 1) {
      uint64_t v21 = sub_1CBFB8E50(Impl);
    }
    else {
      uint64_t v21 = (uint64_t)llvm::ConstantFoldCompareInstOperands(*((unsigned __int16 *)Impl + 12), *(llvm::ConstantExpr **)v29, *((llvm::Constant **)v29 + 1), a2, a3);
    }
  }
  else
  {
    char v22 = (llvm::FixedVectorType ***)v29;
    Impl = llvm::ConstantVector::getImpl((llvm::FixedVectorType ***)v29, (llvm::Type *)v20);
    if (Impl) {
      goto LABEL_35;
    }
    llvm::FixedVectorType::get(**v22, (llvm::Type *)v20);
    uint64_t v21 = sub_1CC56A4DC(**v23 + 1288, (uint64_t)v23, v22, v20);
  }
  Impl = (llvm::Value *)v21;
LABEL_35:
  if (v29 != v31) {
    free(v29);
  }
  return Impl;
}

const llvm::detail::DoubleAPFloat *llvm::ConstantFoldCompareInstOperands(int SwappedPredicate, llvm::ConstantExpr *a2, llvm::Constant *a3, llvm::DataLayout *a4, BOOL a5)
{
  while (!a2 || *((unsigned char *)a2 + 16) != 5)
  {
LABEL_3:
    if (*((unsigned char *)a3 + 16) != 5) {
      goto LABEL_4;
    }
    uint64_t v21 = a2;
    char v22 = a3;
    uint64_t v23 = a4;
    BOOL v24 = a5;
    SwappedPredicate = llvm::CmpInst::getSwappedPredicate(SwappedPredicate);
    a5 = v24;
    a4 = v23;
    a2 = v22;
    a3 = v21;
  }
  unsigned int v45 = SwappedPredicate;
  Compare = a4;
  while (1)
  {
    BOOL v8 = a5;
    int v9 = a2;
    unint64_t v47 = a3;
    if (llvm::Constant::isNullValue(a3))
    {
      int v16 = *((unsigned __int16 *)v9 + 9);
      if (v16 == 48)
      {
        llvm::DataLayout::getIntPtrType(Compare, *(llvm::Type **)v9);
        IntegerCast = llvm::ConstantExpr::getIntegerCast(*((llvm::ConstantExpr **)v9 - 4 * (*((_DWORD *)v9 + 5) & 0x7FFFFFF)), v17, 0);
        uint64_t v20 = *(llvm::Constant **)IntegerCast;
        goto LABEL_25;
      }
      if (v16 == 47)
      {
        llvm::DataLayout::getIntPtrType(Compare, **((llvm::Type ***)v9 - 4 * (*((_DWORD *)v9 + 5) & 0x7FFFFFF)));
        if (*(void *)v9 == v25)
        {
          IntegerCast = (llvm::ConstantExpr *)*((void *)v9 - 4 * (*((_DWORD *)v9 + 5) & 0x7FFFFFF));
          uint64_t v20 = *(llvm::Constant **)IntegerCast;
LABEL_25:
          NullValue = llvm::Constant::getNullValue(v20, v18, v19);
LABEL_16:
          a3 = NullValue;
          goto LABEL_17;
        }
      }
    }
    if (!v47) {
      break;
    }
    if (*((unsigned char *)v47 + 16) != 5) {
      break;
    }
    int v10 = *((unsigned __int16 *)v9 + 9);
    if (v10 != *((unsigned __int16 *)v47 + 9)) {
      break;
    }
    if (v10 == 48)
    {
      llvm::DataLayout::getIntPtrType(Compare, *(llvm::Type **)v9);
      uint64_t v12 = v11;
      IntegerCast = llvm::ConstantExpr::getIntegerCast(*((llvm::ConstantExpr **)v9 - 4 * (*((_DWORD *)v9 + 5) & 0x7FFFFFF)), v11, 0);
      NullValue = llvm::ConstantExpr::getIntegerCast(*((llvm::ConstantExpr **)v47 - 4 * (*((_DWORD *)v47 + 5) & 0x7FFFFFF)), v12, 0);
      goto LABEL_16;
    }
    if (v10 != 47) {
      break;
    }
    llvm::DataLayout::getIntPtrType(Compare, **((llvm::Type ***)v9 - 4 * (*((_DWORD *)v9 + 5) & 0x7FFFFFF)));
    if (*(void *)v9 != v26) {
      break;
    }
    uint64_t v27 = (llvm::ConstantExpr **)((char *)v9 - 32 * (*((_DWORD *)v9 + 5) & 0x7FFFFFF));
    IntegerCast = *v27;
    if (*(void *)*v27 != **((void **)v47 - 4 * (*((_DWORD *)v47 + 5) & 0x7FFFFFF))) {
      break;
    }
    a3 = (llvm::Constant *)*((void *)v47 - 4 * (*((_DWORD *)v47 + 5) & 0x7FFFFFF));
LABEL_17:
    a2 = IntegerCast;
    if (IntegerCast) {
      BOOL v15 = *((unsigned char *)IntegerCast + 16) == 5;
    }
    else {
      BOOL v15 = 0;
    }
    SwappedPredicate = v45;
    a4 = Compare;
    a5 = v8;
    if (!v15) {
      goto LABEL_3;
    }
  }
  if ((v45 & 0xFFFFFFFE) != 0x20 || *((_WORD *)v9 + 9) != 29 || (llvm::Constant::isNullValue(v47) & 1) == 0)
  {
    if (*(unsigned char *)(*(void *)v9 + 8) != 15 || llvm::CmpInst::isSigned(v45))
    {
      LOWORD(SwappedPredicate) = v45;
      a2 = v9;
      a3 = v47;
    }
    else
    {
      unsigned int IndexTypeSizeInBits = llvm::DataLayout::getIndexTypeSizeInBits((uint64_t)Compare, *(void *)v9);
      sub_1CB8F1EEC((uint64_t)&v50, IndexTypeSizeInBits, 0);
      unint64_t v36 = llvm::Value::stripAndAccumulateConstantOffsets(v9, Compare, (llvm::APInt *)&v50, 0, 0, 0, v35);
      sub_1CB8F1EEC((uint64_t)&v48, IndexTypeSizeInBits, 0);
      unsigned int v38 = llvm::Value::stripAndAccumulateConstantOffsets(v47, Compare, (llvm::APInt *)&v48, 0, 0, 0, v37);
      if (v36 == v38)
      {
        unsigned __int16 SignedPredicate = llvm::ICmpInst::getSignedPredicate(v45);
        unint64_t v41 = (llvm::Type *)llvm::ConstantInt::get(**(llvm::ConstantInt ***)v9, (llvm::LLVMContext *)&v50, v40);
        uint64_t v43 = (llvm::Constant *)llvm::ConstantInt::get(**(llvm::ConstantInt ***)v9, (llvm::LLVMContext *)&v48, v42);
        Compare = (llvm::DataLayout *)llvm::ConstantExpr::getCompare((llvm::ConstantExpr *)SignedPredicate, v41, v43, 0, v44);
      }
      if (v49 >= 0x41 && v48) {
        MEMORY[0x1D25D9CB0](v48, 0x1000C8000313F17);
      }
      if (v51 >= 0x41 && v50) {
        MEMORY[0x1D25D9CB0](v50, 0x1000C8000313F17);
      }
      LOWORD(SwappedPredicate) = v45;
      a2 = v9;
      uint64_t v6 = Compare;
      a3 = v47;
      if (v36 == v38) {
        return v6;
      }
    }
LABEL_4:
    if ((unsigned __int16)SwappedPredicate <= 0xFu) {
      return (const llvm::detail::DoubleAPFloat *)llvm::ConstantExpr::getFCmp((llvm::ConstantExpr *)(unsigned __int16)SwappedPredicate, (uint64_t ***)a2, a3, 0);
    }
    else {
      return (const llvm::detail::DoubleAPFloat *)llvm::ConstantExpr::getICmp((llvm::ConstantExpr *)(unsigned __int16)SwappedPredicate, a2, a3, 0, a5);
    }
  }
  uint64_t v28 = v9;
  int v29 = (llvm *)llvm::ConstantFoldCompareInstOperands(v45, *((void *)v9 - 4 * (*((_DWORD *)v9 + 5) & 0x7FFFFFF)), v47, Compare, v8);
  uint64_t v30 = (llvm::Constant *)llvm::ConstantFoldCompareInstOperands(v45, ((void *)v28 - 4 * (*((_DWORD *)v28 + 5) & 0x7FFFFFF))[4], v47, Compare, v8);
  if (v45 == 32) {
    uint64_t v33 = 28;
  }
  else {
    uint64_t v33 = 29;
  }

  return llvm::ConstantFoldBinaryOpOperands((llvm *)v33, v29, v30, Compare, v31, v32);
}

llvm *llvm::ConstantFoldInstOperands(unsigned __int8 *a1, uint64_t **a2, uint64_t a3, llvm::Type *a4, llvm::DSOLocalEquivalent **a5)
{
  return sub_1CBFB8E50((llvm *)a1, (llvm *)(a1[16] - 28), a2, a3, a4, a5);
}

llvm::Value *llvm::ConstantFoldConstant(uint64_t a1, llvm::DataLayout *a2, BOOL a3)
{
  v6[9] = *MEMORY[0x1E4F143B8];
  v6[0] = 1;
  for (uint64_t i = 1; i != 9; i += 2)
    v6[i] = -4096;
  BOOL result = sub_1CBFB8694(a1, a2, a3, (uint64_t)v6);
  if ((v6[0] & 1) == 0)
  {
    int v5 = result;
    MEMORY[0x1D25D9CD0](v6[1], 8);
    return v5;
  }
  return result;
}

llvm *sub_1CBFB8E50(llvm *this, llvm *a2, uint64_t **a3, uint64_t a4, llvm::Type *a5, llvm::DSOLocalEquivalent **a6)
{
  v247[7] = *MEMORY[0x1E4F143B8];
  if (a2 == 12)
  {
    unsigned int v7 = (unsigned __int8 *)*a3;
    return (llvm *)llvm::ConstantExpr::get((llvm::ConstantExpr *)0xC, v7, 0, 0, a5);
  }
  uint64_t v9 = (uint64_t)a5;
  if ((a2 - 13) <= 0x11)
  {
    int v10 = (llvm::Constant *)a3[1];
    uint64_t v12 = (llvm *)*a3;
    return llvm::ConstantFoldBinaryOpOperands(a2, v12, v10, a5, a5, a6);
  }
  BOOL v15 = *(llvm::Constant **)this;
  if ((a2 - 38) <= 0xC)
  {
    uint64_t v17 = (uint64_t)*a3;
    return llvm::ConstantFoldCastOperand(a2, v17, v15, a5, a5);
  }
  int v19 = *((unsigned __int8 *)this + 16);
  if (v19 == 62) {
    goto LABEL_16;
  }
  if (v19 != 5)
  {
    ElementInstruction = 0;
    switch((int)a2)
    {
      case '8':
        ElementInstruction = 0;
        uint64_t v53 = a3[a4 - 1];
        if (!v53 || *((unsigned char *)v53 + 16)) {
          return (llvm *)ElementInstruction;
        }
        if (!llvm::canConstantFoldCallTo(this, (const llvm::CallBase *)a3[a4 - 1], (const llvm::Function *)a3))goto LABEL_198; {
        return llvm::ConstantFoldCall((uint64_t)this, (uint64_t ***)v53, (uint64_t)a3, a4 - 1, (uint64_t *)a6);
        }
      case '9':
        int v81 = (llvm::ConstantExpr *)*a3;
        int64_t v82 = (llvm::PoisonValue **)a3[1];
        unint64_t v83 = (llvm::Constant *)a3[2];
        return llvm::ConstantExpr::getSelect(v81, v82, v83, 0, a5);
      case '=':
        uint64_t v85 = (unsigned __int8 *)*a3;
        int v84 = (llvm::Constant *)a3[1];
        ElementInstruction = llvm::ConstantFoldExtractElementInstruction((llvm *)*a3, v84, (llvm::Constant *)a3);
        if (ElementInstruction) {
          return (llvm *)ElementInstruction;
        }
        unsigned int v86 = *(void ***)v85;
        uint64_t v87 = *(void *)(*(void *)v85 + 24);
        if (v87)
        {
          unint64_t v245 = (unint64_t)v85;
          unsigned int v246 = v84;
          uint64_t v88 = **v86 + 1512;
          LODWORD(v239) = 61;
          uint64_t v240 = (uint64_t)&v245;
          uint64_t v241 = 2;
          long long v242 = 0u;
          long long v243 = 0u;
          uint64_t v244 = 0;
          return (llvm *)sub_1CC56C20C(v88, v87, (unsigned __int8 *)&v239);
        }
LABEL_198:
        ElementInstruction = 0;
        break;
      case '>':
        uint64_t v90 = (llvm::ConstantExpr *)*a3;
        int32x2_t v91 = (llvm::Constant *)a3[1];
        unsigned int v92 = (llvm::Constant *)a3[2];
        return llvm::ConstantExpr::getInsertElement(v90, v91, v92, 0, a5);
      case '?':
        size_t v93 = (llvm *)*a3;
        uint64_t v94 = (llvm *)a3[1];
        long long v95 = (int *)*((void *)this + 8);
        long long v96 = (llvm::Type *)*((unsigned int *)this + 18);
        return (llvm *)llvm::ConstantExpr::getShuffleVector(v93, v94, v95, v96, 0);
      case '@':
        unint64_t v78 = (llvm::Constant *)*a3;
        int v79 = (unsigned int *)*((void *)this + 8);
        uint64_t v80 = *((unsigned int *)this + 18);
        return llvm::ConstantExpr::getExtractValue(v78, v79, v80, 0);
      case 'C':
        ElementInstruction = 0;
        if (sub_1CC16A22C((uint64_t ***)*a3, 0, 0, 0, 0, 0)) {
          return (llvm *)*a3;
        }
        return (llvm *)ElementInstruction;
      default:
        return (llvm *)ElementInstruction;
    }
    return (llvm *)ElementInstruction;
  }
  if (*((_WORD *)this + 9) == 34)
  {
LABEL_16:
    unsigned int v20 = *((unsigned __int8 *)this + 17);
    BOOL v21 = v19 == 62;
    uint64_t v22 = 24;
    if (v21) {
      uint64_t v22 = 64;
    }
    uint64_t v23 = *(void *)((char *)this + v22);
    uint64_t v24 = 32;
    if (v21) {
      uint64_t v24 = 72;
    }
    size_t v229 = *(llvm::Type **)((char *)this + v24);
    size_t v230 = *(llvm::Constant **)this;
    uint64_t v232 = v23;
    unsigned int v25 = *(unsigned __int8 *)(v23 + 8);
    if (v25 > 0x11) {
      goto LABEL_185;
    }
    if (((1 << v25) & 0xAC7F) != 0) {
      goto LABEL_22;
    }
    if (((1 << v25) & 0x30000) == 0)
    {
LABEL_185:
      if ((v25 & 0xFE) != 0x12 && v25 != 21) {
        goto LABEL_258;
      }
    }
    if (!llvm::Type::isSizedDerivedType(v23, 0)) {
      goto LABEL_258;
    }
    unsigned int v25 = *(unsigned __int8 *)(v232 + 8);
LABEL_22:
    if (v25 == 19) {
      goto LABEL_258;
    }
    unint64_t v26 = *((unsigned __int8 *)this + 17);
    if (v26 <= 3) {
      uint64_t v27 = 0;
    }
    else {
      uint64_t v27 = ((v26 >> 2) + 0xFFFFFFFF) | 0x100000000;
    }
    unsigned int v28 = *((_DWORD *)v230 + 2);
    if ((v28 & 0xFE) == 0x12) {
      unsigned int v28 = *(_DWORD *)(**((void **)v230 + 2) + 8);
    }
    if (v28 < 0x100) {
      goto LABEL_37;
    }
    unsigned int v29 = v28 >> 8;
    uint64_t v30 = *(unsigned int *)(v9 + 240);
    uint64_t v31 = *(void *)(v9 + 232);
    if (v30)
    {
      uint64_t v31 = *(void *)(v9 + 232);
      unint64_t v32 = *(unsigned int *)(v9 + 240);
      do
      {
        unint64_t v33 = v32 >> 1;
        uint64_t v34 = v31 + 16 * (v32 >> 1);
        unsigned int v35 = *(_DWORD *)(v34 + 8);
        uint64_t v36 = v34 + 16;
        v32 += ~(v32 >> 1);
        if (v35 < v29) {
          uint64_t v31 = v36;
        }
        else {
          unint64_t v32 = v33;
        }
      }
      while (v32);
    }
    if (v31 == *(void *)(v9 + 232) + 16 * v30 || *(_DWORD *)(v31 + 8) != v29) {
LABEL_37:
    }
      uint64_t v31 = *(void *)(v9 + 232);
    uint64_t v37 = llvm::IntegerType::get(*(llvm::IntegerType **)v230, (llvm::LLVMContext *)*(unsigned int *)(v31 + 12));
    size_t v231 = (llvm::DataLayout *)v9;
    if ((*((_DWORD *)v230 + 2) & 0xFE) == 0x12)
    {
      size_t v218 = (llvm::Type *)*((unsigned int *)v230 + 8);
      if (*((_DWORD *)v230 + 2) == 19) {
        llvm::ScalableVectorType::get((uint64_t **)v37, v218);
      }
      else {
        llvm::FixedVectorType::get((llvm::FixedVectorType *)v37, v218);
      }
    }
    unsigned int v38 = (llvm::Constant ***)v37;
    if ((*(_DWORD *)(v37 + 8) & 0xFE) == 0x12) {
      unsigned int v38 = **(llvm::Constant *****)(v37 + 16);
    }
    uint64_t v239 = &v241;
    uint64_t v240 = 0x2000000000;
    if (a4 != 1)
    {
      uint64_t v222 = (llvm::Constant ***)v37;
      unsigned int v223 = v20;
      char v39 = 0;
      uint64_t v227 = a4;
      int v40 = -(int)a4;
      uint64_t v41 = 1;
      int v42 = 1;
      int v221 = -(int)a4;
LABEL_43:
      int v224 = v42;
      char v225 = v39;
      uint64_t v43 = 0;
      BOOL v44 = &a3[v41];
      int v45 = v40 + v42;
      do
      {
        if (v41 + v43 == 1
          || *(unsigned char *)(llvm::GetElementPtrInst::getIndexedType(v232, (uint64_t)(a3 + 1), v41 + v43 - 1) + 8) != 16)
        {
          unint64_t v46 = (llvm::CastInst *)v44[v43];
          uint64_t v47 = *(void *)v46;
          if ((*(_DWORD *)(*(void *)v46 + 8) & 0xFE) == 0x12) {
            uint64_t v47 = **(void **)(v47 + 16);
          }
          if ((llvm::Constant ***)v47 != v38)
          {
            if ((*(_DWORD *)(*(void *)v46 + 8) & 0xFE) == 0x12) {
              unsigned int v49 = v222;
            }
            else {
              unsigned int v49 = v38;
            }
            CastOpcode = (llvm::ConstantExpr *)llvm::CastInst::getCastOpcode(v46, (const llvm::Value *)1, (uint64_t)v49, (llvm::Type *)1);
            Cast = llvm::ConstantExpr::getCast(CastOpcode, (llvm::ConstantExpr *)(&a3[v41])[v43], v49, 0);
            if (v240 >= (unint64_t)HIDWORD(v240)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            uint64_t v9 = (uint64_t)v231;
            *((void *)v239 + v240) = Cast;
            unsigned int v48 = v240 + 1;
            LODWORD(v240) = v240 + 1;
            int v42 = v224 + v43 + 1;
            int v40 = v221;
            v41 += v43 + 1;
            char v39 = 1;
            if (v224 + v43 + v221 == -1)
            {
              size_t v199 = (uint64_t *)v239;
              unsigned int v20 = v223;
              uint64_t v200 = v27;
              goto LABEL_73;
            }
            goto LABEL_43;
          }
        }
        else
        {
          unint64_t v46 = (llvm::CastInst *)v44[v43];
        }
        if (v240 >= (unint64_t)HIDWORD(v240)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v239 + v240) = v46;
        unsigned int v48 = v240 + 1;
        LODWORD(v240) = v240 + 1;
        ++v43;
      }
      while (v45 + v43);
      size_t v199 = (uint64_t *)v239;
      uint64_t v9 = (uint64_t)v231;
      uint64_t v200 = v27;
      if ((v225 & 1) == 0)
      {
        ElementInstruction = 0;
        a4 = v227;
        unsigned int v20 = v223;
        goto LABEL_82;
      }
      unsigned int v20 = v223;
LABEL_73:
      uint64_t ElementPtr = llvm::ConstantExpr::getGetElementPtr(v232, *a3, (uint64_t)v199, v48, 0, v200, 0);
      unint64_t v245 = 1;
      for (uint64_t i = 8; i != 72; i += 16)
        *(unint64_t *)((char *)&v245 + i) = -4096;
      ElementInstruction = sub_1CBFB8694(ElementPtr, (llvm::DataLayout *)v9, (BOOL)a6, (uint64_t)&v245);
      if ((v245 & 1) == 0) {
        MEMORY[0x1D25D9CD0](v246, 8);
      }
      size_t v199 = (uint64_t *)v239;
      a4 = v227;
LABEL_82:
      if (v199 != &v241) {
        free(v199);
      }
      if (ElementInstruction) {
        return (llvm *)ElementInstruction;
      }
    }
    unint64_t v56 = (llvm::detail::IEEEFloat *)*a3;
    uint64_t v57 = **a3;
    unsigned int v58 = *(_DWORD *)(v57 + 8);
    if (v58 != 15) {
      goto LABEL_258;
    }
    if ((v58 & 0xFE) == 0x12) {
      unsigned int v58 = *(_DWORD *)(**(void **)(v57 + 16) + 8);
    }
    if (v58 < 0x100) {
      goto LABEL_97;
    }
    unsigned int v59 = v58 >> 8;
    uint64_t v60 = *(unsigned int *)(v9 + 240);
    uint64_t v61 = *(void *)(v9 + 232);
    if (v60)
    {
      uint64_t v61 = *(void *)(v9 + 232);
      unint64_t v62 = *(unsigned int *)(v9 + 240);
      do
      {
        unint64_t v63 = v62 >> 1;
        uint64_t v64 = v61 + 16 * (v62 >> 1);
        unsigned int v65 = *(_DWORD *)(v64 + 8);
        uint64_t v66 = v64 + 16;
        v62 += ~(v62 >> 1);
        if (v65 < v59) {
          uint64_t v61 = v66;
        }
        else {
          unint64_t v62 = v63;
        }
      }
      while (v62);
    }
    if (v61 == *(void *)(v9 + 232) + 16 * v60 || *(_DWORD *)(v61 + 8) != v59) {
LABEL_97:
    }
      uint64_t v61 = *(void *)(v9 + 232);
    uint64_t v67 = (uint64_t **)llvm::IntegerType::get(*(llvm::IntegerType **)v57, (llvm::LLVMContext *)*(unsigned int *)(v61 + 12));
    uint64_t v68 = (uint64_t)v67;
    if ((*(_DWORD *)(v57 + 8) & 0xFE) == 0x12)
    {
      size_t v219 = (llvm::Type *)*(unsigned int *)(v57 + 32);
      if (*(_DWORD *)(v57 + 8) == 19) {
        llvm::ScalableVectorType::get(v67, v219);
      }
      else {
        llvm::FixedVectorType::get((llvm::FixedVectorType *)v67, v219);
      }
      uint64_t v68 = v220;
      uint64_t v9 = (uint64_t)v231;
    }
    if (a4 == 2)
    {
      if (*((_DWORD *)v229 + 2) == 2061)
      {
        unint64_t v69 = a3[1];
        if (v69)
        {
          if (*((unsigned char *)v69 + 16) == 5 && *((_WORD *)v69 + 9) == 15)
          {
            uint64_t v70 = v69[-4 * (*((_DWORD *)v69 + 5) & 0x7FFFFFF)];
            unsigned int v71 = *(unsigned __int8 *)(v70 + 16);
            if (v70) {
              BOOL v72 = v71 == 16;
            }
            else {
              BOOL v72 = 0;
            }
            if (v72)
            {
              uint64_t v73 = *(unsigned int *)(v70 + 32);
              if (v73 >= 0x41)
              {
                int v214 = 0;
                int64_t v215 = (unint64_t)(v73 + 63) >> 6;
                do
                {
                  BOOL v146 = v215-- < 1;
                  if (v146) {
                    break;
                  }
                  unint64_t v216 = *(void *)(*(void *)(v70 + 24) + 8 * v215);
                  v214 += __clz(v216);
                }
                while (!v216);
                int v217 = v73 | 0xFFFFFFC0;
                if ((v73 & 0x3F) == 0) {
                  int v217 = 0;
                }
                uint64_t v9 = (uint64_t)v231;
                if (v214 + v217 == v73) {
                  goto LABEL_111;
                }
              }
              else if (!*(void *)(v70 + 24))
              {
                goto LABEL_111;
              }
            }
            else
            {
              if (v70) {
                BOOL v207 = v71 == 17;
              }
              else {
                BOOL v207 = 0;
              }
              if (v207)
              {
                if (sub_1CB844168(v70, 0.0)) {
                  goto LABEL_111;
                }
              }
              else
              {
                BOOL v146 = v71 > 0x14;
                int v208 = (1 << v71) & 0x1C2000;
                if (!v146 && v208 != 0)
                {
LABEL_111:
                  unint64_t v74 = sub_1CC56C0C0((llvm *)0x2F, v56, (llvm::Constant *)*v69, 0);
                  Sub = llvm::ConstantExpr::getSub(v74, (llvm::Constant *)v69[-4 * (*((_DWORD *)v69 + 5) & 0x7FFFFFF) + 4], 0, 0);
                  int64_t v76 = sub_1CC56C0C0((llvm *)0x30, Sub, v230, 0);
                  uint64_t v239 = (void *)1;
                  for (uint64_t j = 8; j != 72; j += 16)
                    *(void **)((char *)&v239 + j) = (void *)-4096;
                  ElementInstruction = sub_1CBFB8694((uint64_t)v76, (llvm::DataLayout *)v9, (BOOL)a6, (uint64_t)&v239);
                  if ((v239 & 1) == 0) {
                    MEMORY[0x1D25D9CD0](v240, 8);
                  }
                  goto LABEL_257;
                }
              }
            }
          }
        }
      }
LABEL_133:
      unsigned int v97 = 1;
      while (*((unsigned char *)a3[v97] + 16) == 16)
      {
        if (a4 == ++v97) {
          goto LABEL_136;
        }
      }
      goto LABEL_258;
    }
    if (a4 != 1) {
      goto LABEL_133;
    }
LABEL_136:
    unsigned int v99 = sub_1CB83544C(v9, v68);
    if (v98 == 1) {
    int v100 = (v20 >> 1) & 1;
    }
    uint64_t IndexedOffsetInType = llvm::DataLayout::getIndexedOffsetInType((llvm::DataLayout *)v9, v232, (const llvm::Value **)a3 + 1, a4 - 1);
    unsigned int v238 = v99;
    uint64_t v228 = a4;
    if (v99 > 0x40) {
      llvm::APInt::initSlowCase((llvm::APInt *)&__src);
    }
    unint64_t v102 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v99;
    if (!v99) {
      unint64_t v102 = 0;
    }
    __src = (void *)(v102 & IndexedOffsetInType);
    uint64_t v103 = sub_1CBFC68C8(v56);
    uint64_t v104 = this;
    do
    {
      uint64_t v105 = v103;
      int v106 = *((unsigned __int8 *)v103 + 16);
      if (v106 != 62 && (v106 != 5 || *((_WORD *)v103 + 9) != 34)) {
        break;
      }
      int v107 = *((_DWORD *)v103 + 5);
      if ((v107 & 0x40000000) != 0)
      {
        unint64_t v109 = (char *)*((void *)v103 - 1);
        uint64_t v108 = v107 & 0x7FFFFFF;
      }
      else
      {
        uint64_t v108 = v107 & 0x7FFFFFF;
        unint64_t v109 = (char *)v105 - 32 * v108;
      }
      char v110 = *((unsigned char *)v105 + 17);
      uint64_t v239 = &v241;
      uint64_t v240 = 0x400000000;
      unint64_t v111 = 32 * v108 - 32;
      if (v111 >= 0x81) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      size_t v112 = (const llvm::Value **)&v241;
      if (v108 != 1)
      {
        uint64_t v113 = (uint64_t *)(v109 + 32);
        uint64_t v114 = &v241;
        uint64_t v115 = 32 * v108 - 32;
        do
        {
          uint64_t v116 = *v113;
          v113 += 4;
          *v114++ = v116;
          v115 -= 32;
        }
        while (v115);
        size_t v112 = (const llvm::Value **)v239;
      }
      uint64_t v9 = (uint64_t)v231;
      uint64_t v117 = (v111 >> 5);
      LODWORD(v240) = v111 >> 5;
      if (v240)
      {
        uint64_t v118 = 0;
        while (*((unsigned char *)v112[v118] + 16) == 16)
        {
          if (v117 == ++v118) {
            goto LABEL_157;
          }
        }
        char v128 = 0;
        uint64_t v103 = v105;
      }
      else
      {
LABEL_157:
        int v119 = *((_DWORD *)v105 + 5);
        if ((v119 & 0x40000000) != 0) {
          int v120 = (llvm::Value **)*((void *)v105 - 1);
        }
        else {
          int v120 = (llvm::Value **)((char *)v105 - 32 * (v119 & 0x7FFFFFF));
        }
        size_t v121 = *v120;
        uint64_t v122 = 24;
        if (*((unsigned char *)v105 + 16) == 62) {
          uint64_t v122 = 64;
        }
        uint64_t v123 = llvm::DataLayout::getIndexedOffsetInType(v231, *(void *)((char *)v105 + v122), v112, v117);
        LODWORD(v246) = v99;
        unint64_t v124 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v99;
        if (!v99) {
          unint64_t v124 = 0;
        }
        unint64_t v245 = v124 & v123;
        char v125 = v238;
        if (v238 >= 0x41)
        {
          uint64_t v129 = 0;
          BOOL v130 = 0;
          size_t v131 = (char *)__src;
          unint64_t v126 = v245;
          unint64_t v132 = ((unint64_t)v238 + 63) >> 6;
          do
          {
            unint64_t v133 = *(void *)&v131[v129];
            unint64_t v134 = *(void *)(v126 + v129) + v133;
            BOOL v135 = v134 < v133;
            BOOL v136 = v134 + 1 <= v133;
            if (v130)
            {
              ++v134;
              BOOL v130 = v136;
            }
            else
            {
              BOOL v130 = v135;
            }
            *(void *)&v131[v129] = v134;
            v129 += 8;
          }
          while (8 * v132 != v129);
          *((void *)__src + (v132 - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -v125;
          uint64_t v9 = (uint64_t)v231;
        }
        else
        {
          unint64_t v126 = v245;
          if (v238) {
            unint64_t v127 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v238;
          }
          else {
            unint64_t v127 = 0;
          }
          __src = (void *)(v127 & ((unint64_t)__src + v245));
        }
        if (v246 >= 0x41 && v126) {
          MEMORY[0x1D25D9CB0](v126, 0x1000C8000313F17);
        }
        uint64_t v103 = sub_1CBFC68C8(v121);
        char v128 = 1;
        size_t v112 = (const llvm::Value **)v239;
      }
      if (v112 != (const llvm::Value **)&v241) {
        free(v112);
      }
      v100 &= (v110 & 2) >> 1;
      uint64_t v104 = v105;
    }
    while ((v128 & 1) != 0);
    unsigned int v236 = v99;
    uint64_t v235 = 0;
    int v138 = *((unsigned __int8 *)v103 + 16);
    uint64_t v233 = (llvm::IntegerType ***)v103;
    int v226 = v104;
    if (v138 == 5 && v103)
    {
      if (*((_WORD *)v103 + 9) != 48
        || ((uint64_t v139 = *((void *)v103 - 4 * (*((_DWORD *)v103 + 5) & 0x7FFFFFF))) != 0
          ? (BOOL v140 = *(unsigned char *)(v139 + 16) == 16)
          : (BOOL v140 = 0),
            !v140))
      {
        size_t v141 = *(llvm::ConstantInt ***)v103;
        goto LABEL_203;
      }
      llvm::APInt::zextOrTrunc((uint64_t *)(v139 + 24), v99, (uint64_t)&v239);
      uint64_t v235 = v239;
      unsigned int v236 = v240;
      int v138 = *((unsigned __int8 *)v103 + 16);
    }
    size_t v141 = *(llvm::ConstantInt ***)v103;
    if (v138 == 16)
    {
      uint64_t v142 = *((unsigned int *)v103 + 8);
      if (v142 >= 0x41)
      {
        int v210 = 0;
        int64_t v211 = (unint64_t)(v142 + 63) >> 6;
        do
        {
          BOOL v146 = v211-- < 1;
          if (v146) {
            break;
          }
          unint64_t v212 = *(void *)(*((void *)v103 + 3) + 8 * v211);
          v210 += __clz(v212);
        }
        while (!v212);
        int v213 = v142 | 0xFFFFFFC0;
        if ((v142 & 0x3F) == 0) {
          int v213 = 0;
        }
        uint64_t v9 = (uint64_t)v231;
        if (v210 + v213 == v142) {
          goto LABEL_212;
        }
      }
      else if (!*((void *)v103 + 3))
      {
        goto LABEL_212;
      }
    }
    else if (v138 == 17)
    {
      if (sub_1CB844168((uint64_t)v103, 0.0)) {
        goto LABEL_212;
      }
    }
    else if ((v138 - 18) < 3 || v138 == 13)
    {
      goto LABEL_212;
    }
LABEL_203:
    int v143 = v235;
    if (v236 < 0x41) {
      goto LABEL_211;
    }
    int v144 = 0;
    int64_t v145 = ((unint64_t)v236 + 63) >> 6;
    do
    {
      BOOL v146 = v145-- < 1;
      if (v146) {
        break;
      }
      unint64_t v147 = v235[v145];
      v144 += __clz(v147);
    }
    while (!v147);
    unsigned int v148 = v236 | 0xFFFFFFC0;
    if ((v236 & 0x3F) == 0) {
      unsigned int v148 = 0;
    }
    if (v236 - v144 - v148 <= 0x40)
    {
      int v143 = (void *)*v235;
LABEL_211:
      if (!v143) {
        goto LABEL_220;
      }
    }
LABEL_212:
    uint64_t v149 = *(__int32 **)(v9 + 384);
    size_t v150 = *(unsigned int *)(v9 + 392);
    uint64_t v151 = wmemchr(v149, *((_DWORD *)v141 + 2) >> 8, v150);
    if (v151) {
      unsigned int v153 = v151;
    }
    else {
      unsigned int v153 = &v149[v150];
    }
    if (v150 == v153 - v149)
    {
      unsigned int v154 = **(llvm::ConstantInt ***)v103;
      if (v238 >= 0x41) {
        operator new[]();
      }
      unint64_t v155 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v238;
      if (!v238) {
        unint64_t v155 = 0;
      }
      a4 = v228;
      LODWORD(v240) = v238;
      uint64_t v239 = (void *)(v155 & ((unint64_t)__src + (void)v235));
      uint64_t v157 = (llvm::detail::IEEEFloat *)llvm::ConstantInt::get(v154, (llvm::LLVMContext *)&v239, v152);
      if (v240 >= 0x41 && v239) {
        MEMORY[0x1D25D9CB0](v239, 0x1000C8000313F17);
      }
      ElementInstruction = sub_1CC56C0C0((llvm *)0x30, v157, v230, 0);
      goto LABEL_251;
    }
LABEL_220:
    if (*((unsigned __int8 *)v103 + 16) <= 3u)
    {
      int v156 = (unsigned __int8 *)*((void *)v103 + 3);
    }
    else if (v141[3])
    {
      int v156 = *(unsigned __int8 **)v141[2];
    }
    else
    {
      int v156 = (unsigned __int8 *)(***(void ***)v103 + 1912);
    }
    unsigned int v158 = v156[8];
    a4 = v228;
    if (v158 <= 0x11)
    {
      if (((1 << v158) & 0xAC7F) != 0) {
        goto LABEL_232;
      }
      if (((1 << v158) & 0x30000) != 0) {
        goto LABEL_301;
      }
    }
    if ((v158 & 0xFE) == 0x12 || v158 == 21)
    {
LABEL_301:
      ElementInstruction = 0;
      if (llvm::Type::isSizedDerivedType((uint64_t)v156, 0))
      {
LABEL_232:
        BOOL v234 = (llvm::Type *)v156;
        llvm::DataLayout::getGEPIndicesForOffset((llvm::DataLayout *)v9, &v234, (llvm::APInt *)&__src, (uint64_t)&v245);
        size_t v159 = __src;
        if (v238 >= 0x41)
        {
          int v160 = 0;
          int64_t v161 = ((unint64_t)v238 + 63) >> 6;
          do
          {
            BOOL v146 = v161-- < 1;
            if (v146) {
              break;
            }
            unint64_t v162 = *((void *)__src + v161);
            v160 += __clz(v162);
          }
          while (!v162);
          unsigned int v163 = v238 | 0xFFFFFFC0;
          if ((v238 & 0x3F) == 0) {
            unsigned int v163 = 0;
          }
          if (v238 - v160 - v163 > 0x40) {
            goto LABEL_241;
          }
          size_t v159 = *(void **)__src;
        }
        if (!v159)
        {
          for (uint64_t k = v234; k != v229; v234 = k)
          {
            int v175 = *((unsigned __int8 *)k + 8);
            if (k && v175 == 16)
            {
              if (!*((_DWORD *)k + 3)) {
                break;
              }
              size_t v176 = (llvm::Type **)*((void *)k + 2);
            }
            else
            {
              if ((!k || v175 != 17) && (!k || (v175 & 0xFE) != 0x12)) {
                break;
              }
              size_t v176 = (llvm::Type **)((char *)k + 24);
            }
            uint64_t k = *v176;
            if (!*v176) {
              break;
            }
            if (v175 == 16) {
              int v177 = 32;
            }
            else {
              int v177 = v99;
            }
            LODWORD(v240) = v177;
            uint64_t v239 = 0;
            unint64_t v178 = v245;
            if (v246 >= HIDWORD(v246))
            {
              unint64_t v181 = v246 + 1;
              if (v245 <= (unint64_t)&v239 && v245 + 16 * v246 > (unint64_t)&v239)
              {
                int v182 = (char *)&v239 - v245;
                sub_1CBFC6948((uint64_t)&v245, v181);
                unint64_t v178 = v245;
                uint64_t v179 = (void **)&v182[v245];
              }
              else
              {
                sub_1CBFC6948((uint64_t)&v245, v181);
                uint64_t v179 = &v239;
                unint64_t v178 = v245;
              }
              uint64_t v9 = (uint64_t)v231;
            }
            else
            {
              uint64_t v179 = &v239;
            }
            unint64_t v180 = v178 + 16 * v246;
            *(_DWORD *)(v180 + 8) = *((_DWORD *)v179 + 2);
            *(void *)unint64_t v180 = *v179;
            *((_DWORD *)v179 + 2) = 0;
            LODWORD(v246) = v246 + 1;
            if (v240 >= 0x41 && v239) {
              MEMORY[0x1D25D9CB0](v239, 0x1000C8000313F17);
            }
          }
          uint64_t v239 = &v241;
          uint64_t v240 = 0x2000000000;
          if (v246)
          {
            int v183 = (unsigned int *)v245;
            uint64_t v184 = 16 * v246;
            a4 = v228;
            int v185 = v233;
            do
            {
              uint64_t v186 = llvm::IntegerType::get(**v185, (llvm::LLVMContext *)v183[2]);
              Splat = llvm::ConstantInt::get(*(llvm::ConstantInt **)v186, (llvm::LLVMContext *)v183, v187);
              if ((*(_DWORD *)(v186 + 8) & 0xFE) == 0x12) {
                Splat = llvm::ConstantVector::getSplat((llvm::Type *)(*(unsigned int *)(v186 + 32) | ((unint64_t)(*(_DWORD *)(v186 + 8) == 19) << 32)), (uint64_t)Splat);
              }
              int v185 = v233;
              if (v240 >= (unint64_t)HIDWORD(v240)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((void *)v239 + v240) = Splat;
              unint64_t v189 = (v240 + 1);
              LODWORD(v240) = v240 + 1;
              v183 += 4;
              v184 -= 16;
            }
            while (v184);
          }
          else
          {
            unint64_t v189 = 0;
            a4 = v228;
            int v185 = v233;
          }
          unint64_t v190 = *((unsigned __int8 *)v226 + 17);
          uint64_t v191 = (v190 >> 2) + 0xFFFFFFFF;
          unsigned int v192 = (v190 >> 2) - 1;
          if (v190 < 4) {
            unsigned int v192 = 0;
          }
          if (v190 > 3)
          {
            uint64_t v197 = 24;
            if (*((unsigned char *)v226 + 16) == 62) {
              uint64_t v197 = 64;
            }
            uint64_t v196 = v239;
            if (v156 != *(unsigned __int8 **)((char *)v226 + v197) || v191 >= v189)
            {
              uint64_t v193 = 0;
              uint64_t v194 = 0;
              uint64_t v195 = 0;
            }
            else
            {
              unsigned int v202 = 0;
              int v203 = *((_DWORD *)v226 + 5);
              while (v202 <= v192)
              {
                v204 = (char *)v226 - 32 * (v203 & 0x7FFFFFF);
                if ((v203 & 0x40000000) != 0) {
                  v204 = (char *)*((void *)v226 - 1);
                }
                uint64_t v205 = *((void *)v239 + v202++);
                if (v205 != *(void *)&v204[32 * v202])
                {
                  ElementInstruction = 0;
                  goto LABEL_333;
                }
              }
              uint64_t v195 = v191 & 0xFFFFFF00;
              uint64_t v193 = v192;
              uint64_t v194 = 0x100000000;
            }
          }
          else
          {
            uint64_t v193 = 0;
            uint64_t v194 = 0;
            uint64_t v195 = 0;
            uint64_t v196 = v239;
          }
          size_t v206 = (llvm::Constant **)llvm::ConstantExpr::getGetElementPtr((uint64_t)v156, (uint64_t *)v185, (uint64_t)v196, v189, v100 & 1, v194 | v193 | v195, 0);
          ElementInstruction = v206;
          if (*v206 != v230) {
            ElementInstruction = sub_1CBFBB130((uint64_t)v206, v230, (const llvm::APFloat *)v9);
          }
LABEL_333:
          if (v239 != &v241) {
            free(v239);
          }
          goto LABEL_242;
        }
LABEL_241:
        ElementInstruction = 0;
LABEL_242:
        int v164 = (char *)v245;
        if (v246)
        {
          uint64_t v165 = 16 * v246;
          do
          {
            if (*(_DWORD *)&v164[v165 - 8] >= 0x41u)
            {
              uint64_t v166 = *(void *)&v164[v165 - 16];
              if (v166) {
                MEMORY[0x1D25D9CB0](v166, 0x1000C8000313F17);
              }
            }
            v165 -= 16;
          }
          while (v165);
          int v164 = (char *)v245;
        }
        if (v164 != (char *)v247) {
          free(v164);
        }
      }
    }
    else
    {
      ElementInstruction = 0;
    }
LABEL_251:
    if (v236 >= 0x41 && v235) {
      MEMORY[0x1D25D9CB0](v235, 0x1000C8000313F17);
    }
    if (v238 >= 0x41 && __src) {
      MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
    }
LABEL_257:
    if (ElementInstruction) {
      return (llvm *)ElementInstruction;
    }
LABEL_258:
    uint64_t v167 = 24;
    if (*((unsigned char *)this + 16) == 62) {
      uint64_t v167 = 64;
    }
    uint64_t v168 = *(void *)((char *)this + v167);
    BOOL v171 = (unsigned __int8 *)*a3;
    uint64_t v170 = (uint64_t)(a3 + 1);
    uint64_t v169 = (uint64_t *)v171;
    unint64_t v172 = *((unsigned __int8 *)this + 17);
    if (v172 <= 3) {
      uint64_t v173 = 0;
    }
    else {
      uint64_t v173 = ((v172 >> 2) + 0xFFFFFFFF) | 0x100000000;
    }
    return (llvm *)llvm::ConstantExpr::getGetElementPtr(v168, v169, v170, a4 - 1, (v172 & 2) != 0, v173, 0);
  }

  return llvm::ConstantExpr::getWithOperands(this, (llvm::ConstantExpr **)a3, a4, (llvm::Constant ***)v15, 0, 0);
}

const llvm::detail::DoubleAPFloat *llvm::ConstantFoldBinaryOpOperands(llvm *this, llvm *a2, llvm::Constant *a3, llvm::Constant *a4, const llvm::DataLayout *a5, llvm::DSOLocalEquivalent **a6)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  unsigned int v9 = *((unsigned __int8 *)a2 + 16);
  if (v9 == 5 || *((unsigned char *)a3 + 16) == 5)
  {
    int v45 = a4;
    if (this == 28)
    {
      if (v9 < 0x1C || (unint64_t v11 = a2, !*((void *)a2 + 5))) {
        unint64_t v11 = 0;
      }
      unint64_t v56 = a4;
      uint64_t v57 = 0;
      long long v59 = 0uLL;
      uint64_t v58 = (uint64_t)v11;
      LOBYTE(v60) = 1;
      sub_1CC16089C((uint64_t *)a2, 0, &v56, (uint64_t)&v62);
      if (!a3 || *((unsigned __int8 *)a3 + 16) < 0x1Cu || (uint64_t v12 = a3, !*((void *)a3 + 5))) {
        uint64_t v12 = 0;
      }
      unint64_t v56 = v45;
      uint64_t v57 = 0;
      long long v59 = 0uLL;
      uint64_t v58 = (uint64_t)v12;
      LOBYTE(v60) = 1;
      sub_1CC16089C((uint64_t *)a3, 0, &v56, (uint64_t)&v52);
      if (v55 >= 0x41) {
        operator new[]();
      }
      if (!v55 || ((unint64_t)v62 | (unint64_t)__src) == 0xFFFFFFFFFFFFFFFFLL >> -(char)v55)
      {
        char v20 = 0;
        int v45 = a2;
      }
      else
      {
        if (v65 >= 0x41) {
          operator new[]();
        }
        if (!v65 || (v52 | v64) == 0xFFFFFFFFFFFFFFFFLL >> -(char)v65)
        {
          char v20 = 0;
          int v45 = a3;
        }
        else
        {
          uint64_t v14 = v63;
          if (v63 > 0x40)
          {
            unint64_t v33 = v62;
            uint64_t v34 = (uint64_t *)v52;
            unint64_t v35 = ((unint64_t)v63 + 63) >> 6;
            do
            {
              uint64_t v36 = *v34++;
              *(void *)v33 |= v36;
              unint64_t v33 = (llvm::GlobalValue *)((char *)v33 + 8);
              --v35;
            }
            while (v35);
          }
          else
          {
            unint64_t v62 = (llvm::GlobalValue *)((unint64_t)v62 | v52);
          }
          uint64_t v15 = v65;
          if (v65 > 0x40)
          {
            uint64_t v37 = (void *)v64;
            unsigned int v38 = (uint64_t *)__src;
            unint64_t v39 = ((unint64_t)v65 + 63) >> 6;
            do
            {
              uint64_t v40 = *v38++;
              *v37++ &= v40;
              --v39;
            }
            while (v39);
          }
          else
          {
            v64 &= (unint64_t)__src;
          }
          if (v14 > 0x40)
          {
            __int32 v17 = 0;
            unint64_t v25 = (unint64_t)(v14 + 63) >> 6;
            unint64_t v26 = v62;
            do
            {
              int8x8_t v27 = *(int8x8_t *)v26;
              unint64_t v26 = (llvm::GlobalValue *)((char *)v26 + 8);
              uint8x8_t v28 = (uint8x8_t)vcnt_s8(v27);
              v28.i16[0] = vaddlv_u8(v28);
              v17 += v28.i32[0];
              --v25;
            }
            while (v25);
          }
          else
          {
            uint8x8_t v16 = (uint8x8_t)vcnt_s8((int8x8_t)v62);
            v16.i16[0] = vaddlv_u8(v16);
            __int32 v17 = v16.i32[0];
          }
          if (v15 > 0x40)
          {
            __int32 v19 = 0;
            unint64_t v29 = (unint64_t)(v15 + 63) >> 6;
            uint64_t v30 = (int8x8_t *)v64;
            do
            {
              int8x8_t v31 = *v30++;
              uint8x8_t v32 = (uint8x8_t)vcnt_s8(v31);
              v32.i16[0] = vaddlv_u8(v32);
              v19 += v32.i32[0];
              --v29;
            }
            while (v29);
          }
          else
          {
            uint8x8_t v18 = (uint8x8_t)vcnt_s8((int8x8_t)v64);
            v18.i16[0] = vaddlv_u8(v18);
            __int32 v19 = v18.i32[0];
          }
          if (v19 + v17 == v14)
          {
            int v45 = llvm::ConstantInt::get(*(llvm::ConstantInt ***)a2, (llvm::Type *)&v64, v13);
            char v20 = 0;
          }
          else
          {
            char v20 = 1;
          }
        }
      }
      if (v55 >= 0x41 && __src) {
        MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
      }
      if (v53 >= 0x41 && v52) {
        MEMORY[0x1D25D9CB0](v52, 0x1000C8000313F17);
      }
      if (v65 >= 0x41 && v64) {
        MEMORY[0x1D25D9CB0](v64, 0x1000C8000313F17);
      }
      if (v63 >= 0x41)
      {
        uint64_t v24 = v62;
        if (v62) {
LABEL_68:
        }
          MEMORY[0x1D25D9CB0](v24, 0x1000C8000313F17);
      }
    }
    else
    {
      if (this != 15) {
        goto LABEL_3;
      }
      uint64_t v50 = 0;
      unsigned int v51 = 0;
      char v20 = 1;
      LODWORD(v57) = 1;
      unint64_t v56 = 0;
      LODWORD(v63) = 1;
      unint64_t v62 = 0;
      if (llvm::IsConstantOffsetFromGlobal(a2, &v51, &v56, a4, 0, a6)
        && llvm::IsConstantOffsetFromGlobal(a3, &v50, &v62, v45, 0, v23)
        && v51 == v50)
      {
        unsigned int v42 = sub_1CB83544C((uint64_t)v45, *(void *)a2);
        if (v41 == 1) {
        uint64_t v43 = *(llvm::ConstantInt ***)a2;
        }
        llvm::APInt::zextOrTrunc((uint64_t *)&v56, v42, (uint64_t)&v48);
        llvm::APInt::zextOrTrunc((uint64_t *)&v62, v42, (uint64_t)&v46);
        sub_1CBA14940((uint64_t)&v46);
        llvm::APInt::operator++((uint64_t)&v46);
        llvm::APInt::operator+=((uint64_t)&v46, &v48);
        unsigned int v53 = v47;
        unint64_t v52 = (unint64_t)v46;
        unsigned int v47 = 0;
        int v45 = llvm::ConstantInt::get(v43, (llvm::Type *)&v52, v44);
        if (v53 >= 0x41 && v52) {
          MEMORY[0x1D25D9CB0](v52, 0x1000C8000313F17);
        }
        if (v47 >= 0x41 && v46) {
          MEMORY[0x1D25D9CB0](v46, 0x1000C8000313F17);
        }
        if (v49 >= 0x41 && v48) {
          MEMORY[0x1D25D9CB0](v48, 0x1000C8000313F17);
        }
        char v20 = 0;
      }
      if (v63 >= 0x41 && v62) {
        MEMORY[0x1D25D9CB0](v62, 0x1000C8000313F17);
      }
      if (v57 >= 0x41)
      {
        uint64_t v24 = v56;
        if (v56) {
          goto LABEL_68;
        }
      }
    }
    BOOL result = v45;
    if ((v20 & 1) == 0 && v45) {
      return result;
    }
  }
LABEL_3:
  BOOL result = llvm::ConstantFoldBinaryInstruction(this, a2, a3, a4);
  if (!result)
  {
    BOOL v21 = *(void ***)a2;
    if (*(void *)a2)
    {
      unint64_t v62 = a2;
      unint64_t v63 = a3;
      uint64_t v22 = **v21 + 1512;
      LODWORD(v56) = this;
      uint64_t v57 = &v62;
      uint64_t v58 = 2;
      long long v59 = 0u;
      long long v60 = 0u;
      uint64_t v61 = 0;
      return (const llvm::detail::DoubleAPFloat *)sub_1CC56C20C(v22, (uint64_t)v21, (unsigned __int8 *)&v56);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t llvm::ConstantFoldUnaryOpOperand(llvm *this, unsigned __int8 *a2, llvm::Constant *a3, const llvm::DataLayout *a4, llvm::Type *a5)
{
  return llvm::ConstantExpr::get(this, a2, 0, 0, a5);
}

llvm::ConstantExpr *llvm::ConstantFoldCastOperand(llvm *this, uint64_t a2, llvm::Constant *a3, llvm::Type *a4, const llvm::DataLayout *a5)
{
  switch((int)this)
  {
    case '/':
      if (!a2 || *(unsigned char *)(a2 + 16) != 5) {
        return sub_1CC56C0C0((llvm *)0x2F, (llvm::detail::IEEEFloat *)a2, a3, 0);
      }
      int v10 = *(unsigned __int16 *)(a2 + 18);
      if (v10 == 48)
      {
        uint64_t v11 = *(void *)a2;
        unsigned int v12 = *(_DWORD *)(*(void *)a2 + 8);
        if ((v12 & 0xFE) == 0x12) {
          unsigned int v12 = *(_DWORD *)(**(void **)(v11 + 16) + 8);
        }
        uint64_t v13 = *(llvm::ConstantExpr **)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF));
        if (v12 < 0x100) {
          goto LABEL_28;
        }
        unsigned int v14 = v12 >> 8;
        uint64_t v15 = *((unsigned int *)a4 + 60);
        uint64_t v16 = *((void *)a4 + 29);
        if (v15)
        {
          uint64_t v16 = *((void *)a4 + 29);
          unint64_t v17 = *((unsigned int *)a4 + 60);
          do
          {
            unint64_t v18 = v17 >> 1;
            uint64_t v19 = v16 + 16 * (v17 >> 1);
            unsigned int v20 = *(_DWORD *)(v19 + 8);
            uint64_t v21 = v19 + 16;
            v17 += ~(v17 >> 1);
            if (v20 < v14) {
              uint64_t v16 = v21;
            }
            else {
              unint64_t v17 = v18;
            }
          }
          while (v17);
        }
        if (v16 == *((void *)a4 + 29) + 16 * v15 || *(_DWORD *)(v16 + 8) != v14) {
LABEL_28:
        }
          uint64_t v16 = *((void *)a4 + 29);
        uint64_t v22 = (llvm::FixedVectorType *)llvm::IntegerType::get(*(llvm::IntegerType **)v11, (llvm::LLVMContext *)*(unsigned int *)(v16 + 4));
        uint64_t v23 = (llvm::Type ***)v22;
        if ((*(_DWORD *)(v11 + 8) & 0xFE) == 0x12)
        {
          llvm::VectorType::get(v22, (llvm::Type *)(*(unsigned int *)(v11 + 32) | ((unint64_t)(*(_DWORD *)(v11 + 8) == 19) << 32)));
          uint64_t v23 = v41;
        }
        IntegerCast = llvm::ConstantExpr::getIntegerCast(v13, v23, 0);
      }
      else
      {
        if (v10 != 34) {
          return sub_1CC56C0C0((llvm *)0x2F, (llvm::detail::IEEEFloat *)a2, a3, 0);
        }
        unsigned int IndexTypeSizeInBits = llvm::DataLayout::getIndexTypeSizeInBits((uint64_t)a4, *(void *)a2);
        sub_1CB8F1EEC((uint64_t)&v46, IndexTypeSizeInBits, 0);
        BOOL v44 = llvm::Value::stripAndAccumulateConstantOffsets((llvm::GlobalValue *)a2, a4, (llvm::APInt *)&v46, 1, 0, 0, v43);
        IntegerCast = 0;
        if (llvm::Constant::isNullValue(v44)) {
          IntegerCast = (llvm::ConstantExpr *)llvm::ConstantInt::get(**(llvm::ConstantInt ***)a2, (llvm::LLVMContext *)&v46, v45);
        }
        if (v47 >= 0x41 && v46) {
          MEMORY[0x1D25D9CB0](v46, 0x1000C8000313F17);
        }
      }
      if (IntegerCast) {
        return llvm::ConstantExpr::getIntegerCast(IntegerCast, (llvm::Type ***)a3, 0);
      }
      return sub_1CC56C0C0((llvm *)0x2F, (llvm::detail::IEEEFloat *)a2, a3, 0);
    case '0':
      if (a2 && *(unsigned char *)(a2 + 16) == 5 && *(_WORD *)(a2 + 18) == 47)
      {
        unint64_t v25 = (uint64_t **)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF));
        unint64_t v26 = *v25;
        uint64_t v27 = **v25;
        unsigned int v28 = *(_DWORD *)(v27 + 8);
        unsigned int v29 = v28;
        if ((v28 & 0xFE) == 0x12) {
          unsigned int v29 = *(_DWORD *)(**(void **)(v27 + 16) + 8);
        }
        if (v29 < 0x100) {
          goto LABEL_48;
        }
        unsigned int v30 = v29 >> 8;
        uint64_t v31 = *((unsigned int *)a4 + 60);
        uint64_t v32 = *((void *)a4 + 29);
        if (v31)
        {
          uint64_t v32 = *((void *)a4 + 29);
          unint64_t v33 = *((unsigned int *)a4 + 60);
          do
          {
            unint64_t v34 = v33 >> 1;
            uint64_t v35 = v32 + 16 * (v33 >> 1);
            unsigned int v36 = *(_DWORD *)(v35 + 8);
            uint64_t v37 = v35 + 16;
            v33 += ~(v33 >> 1);
            if (v36 < v30) {
              uint64_t v32 = v37;
            }
            else {
              unint64_t v33 = v34;
            }
          }
          while (v33);
        }
        if (v32 == *((void *)a4 + 29) + 16 * v31 || *(_DWORD *)(v32 + 8) != v30) {
LABEL_48:
        }
          uint64_t v32 = *((void *)a4 + 29);
        unint64_t v39 = *(llvm::Type **)a2;
        if ((*(_DWORD *)(*(void *)a2 + 8) & 0xFE) == 0x12) {
          unint64_t v39 = (llvm::Type *)**((void **)v39 + 2);
        }
        unsigned int v38 = *(_DWORD *)(v32 + 4);
        if (v38 <= llvm::Type::getPrimitiveSizeInBits(v39))
        {
          if ((v28 & 0xFE) == 0x12) {
            unsigned int v28 = *(_DWORD *)(**(void **)(v27 + 16) + 8);
          }
          int v40 = *((_DWORD *)a3 + 2);
          if ((v40 & 0xFE) == 0x12) {
            int v40 = *(_DWORD *)(**((void **)a3 + 2) + 8);
          }
          if ((v40 ^ v28) <= 0xFF)
          {
            uint64_t v8 = (uint64_t)v26;
            goto LABEL_3;
          }
        }
      }
      return sub_1CC56C0C0((llvm *)0x30, (llvm::detail::IEEEFloat *)a2, a3, 0);
    case '1':
      uint64_t v8 = a2;
LABEL_3:
      return sub_1CBFBB130(v8, a3, a4);
    default:
      return llvm::ConstantExpr::getCast(this, (llvm::ConstantExpr *)a2, (llvm::Constant ***)a3, 0);
  }
}

llvm::detail::IEEEFloat *sub_1CBFBB130(uint64_t a1, llvm::PoisonValue *a2, const llvm::APFloat *a3)
{
  uint64_t v4 = (uint64_t)a2;
  int v5 = (unsigned __int8 *)a1;
  v137[32] = *MEMORY[0x1E4F143B8];
  int v6 = *(unsigned __int8 *)(a1 + 16);
  if (v6 == 12)
  {
    NullValue = (llvm::detail::IEEEFloat *)llvm::PoisonValue::get(a2, a2);
LABEL_176:
    Splat = NullValue;
    if (NullValue) {
      return Splat;
    }
    goto LABEL_7;
  }
  if ((v6 - 11) <= 1)
  {
    NullValue = llvm::UndefValue::get(a2, a2);
    goto LABEL_176;
  }
  if (v6 == 16)
  {
    uint64_t v7 = *(unsigned int *)(a1 + 32);
    if (v7 >= 0x41)
    {
      int v117 = 0;
      int64_t v118 = (unint64_t)(v7 + 63) >> 6;
      do
      {
        if (v118-- < 1) {
          break;
        }
        unint64_t v120 = *(void *)(*(void *)(a1 + 24) + 8 * v118);
        v117 += __clz(v120);
      }
      while (!v120);
      int v121 = v7 | 0xFFFFFFC0;
      if ((v7 & 0x3F) == 0) {
        int v121 = 0;
      }
      if (v117 + v121 != v7) {
        goto LABEL_6;
      }
    }
    else if (*(void *)(a1 + 24))
    {
      goto LABEL_6;
    }
  }
  else if (v6 == 17)
  {
    if ((sub_1CB844168(a1, 0.0) & 1) == 0) {
      goto LABEL_6;
    }
  }
  else if ((v6 - 18) >= 3 && v6 != 13)
  {
    goto LABEL_6;
  }
  if ((*(_DWORD *)(v4 + 8) & 0xFE) != 0xA)
  {
    NullValue = llvm::Constant::getNullValue((llvm::Constant *)v4, a2, a3);
    goto LABEL_176;
  }
LABEL_6:
  if (llvm::Constant::isAllOnesValue((llvm::Constant *)v5))
  {
    unsigned int v116 = (*(_DWORD *)(v4 + 8) & 0xFE) == 0x12
         ? *(unsigned __int8 *)(**(void **)(v4 + 16) + 8)
         : *(_DWORD *)(v4 + 8);
    if (v116 == 13 || v116 <= 6)
    {
      NullValue = (llvm::detail::IEEEFloat *)llvm::Constant::getAllOnesValue((llvm::Constant *)v4, v8, v9);
      goto LABEL_176;
    }
  }
LABEL_7:
  BOOL v130 = a3;
  int v10 = *(llvm::IntegerType ***)v5;
  if (!*(void *)v5
    || (v10[1] & 0xFE) != 0x12
    || *(_DWORD *)(v4 + 8) >= 7u && *(_DWORD *)(v4 + 8) != 13)
  {
    if ((*(_DWORD *)(v4 + 8) & 0xFE) != 0x12) {
      goto LABEL_81;
    }
    int v46 = v5[16];
    if ((v46 - 16) < 2)
    {
      BOOL v135 = v5;
      uint64_t Impl = (uint64_t)llvm::ConstantVector::getImpl((llvm::FixedVectorType ***)&v135, (llvm::Type *)1);
      if (!Impl)
      {
        llvm::FixedVectorType::get(*(llvm::FixedVectorType **)v135, (llvm::Type *)1);
        uint64_t Impl = sub_1CC56A4DC(**v52 + 1288, (uint64_t)v52, &v135, 1);
      }
      return (llvm::detail::IEEEFloat *)sub_1CBFBB130(Impl, v4, v130);
    }
    if (v46 != 10 && v46 != 15
      || (unsigned int v47 = (llvm::Type *)*(unsigned int *)(v4 + 32),
          unsigned int v48 = (llvm::Type *)*((unsigned int *)v10 + 8),
          v47 == v48))
    {
LABEL_81:
      if (v10 == (llvm::IntegerType **)v4) {
        return (llvm::detail::IEEEFloat *)v5;
      }
      unsigned int v49 = (llvm::detail::IEEEFloat *)v5;
LABEL_83:
      return sub_1CC56C0C0((llvm *)0x31, v49, (llvm::Constant *)v4, 0);
    }
    unsigned int v53 = *(unsigned __int8 **)(v4 + 24);
    if (v53[8] <= 6u)
    {
      unsigned int PrimitiveSizeInBits = (llvm::LLVMContext *)llvm::Type::getPrimitiveSizeInBits(*(llvm::Type **)(v4 + 24));
      if (v54 == 1)
      {
        int v10 = *(llvm::IntegerType ***)v5;
      }
      unint64_t v56 = (llvm::FixedVectorType *)llvm::IntegerType::get(*v10, PrimitiveSizeInBits);
      llvm::FixedVectorType::get(v56, v47);
      Splat = (llvm::detail::IEEEFloat *)sub_1CBFBB130(v5, v57, v130);
      if (*(void *)Splat == v4) {
        return Splat;
      }
      unsigned int v49 = Splat;
      goto LABEL_83;
    }
    uint64_t v58 = (unsigned __int8 *)v10[3];
    if (v58[8] > 6u)
    {
      unint64_t v63 = v130;
    }
    else
    {
      long long v60 = (llvm::LLVMContext *)llvm::Type::getPrimitiveSizeInBits(v10[3]);
      if (v59 == 1)
      {
        int v10 = *(llvm::IntegerType ***)v5;
      }
      uint64_t v61 = (llvm::FixedVectorType *)llvm::IntegerType::get(*v10, v60);
      llvm::FixedVectorType::get(v61, v48);
      if (*(llvm::Constant **)v5 != v62) {
        int v5 = (unsigned __int8 *)sub_1CC56C0C0((llvm *)0x31, (llvm::detail::IEEEFloat *)v5, v62, 0);
      }
      unint64_t v63 = v130;
      int v64 = v5[16];
      if (v64 == 15 || v64 == 10) {
        Splat = 0;
      }
      else {
        Splat = (llvm::detail::IEEEFloat *)v5;
      }
      if (v64 != 15 && v64 != 10) {
        return Splat;
      }
    }
    int v66 = *(unsigned __int8 *)v63;
    BOOL v135 = v137;
    uint64_t v136 = 0x2000000000;
    if (v47 < v48)
    {
      size_t v131 = llvm::Constant::getNullValue((llvm::Constant *)v53, v8, v9);
      int v68 = llvm::Type::getPrimitiveSizeInBits((llvm::Type *)v58);
      if (v67 == 1)
      {
        if (v47) {
          goto LABEL_118;
        }
      }
      else if (v47)
      {
LABEL_118:
        uint64_t v129 = (llvm::Constant *)v4;
        int v69 = 0;
        uint64_t v70 = 0;
        unsigned int v71 = v48 / v47;
        if (v66) {
          unsigned int v72 = (v48 / v47 - 1) * v68;
        }
        else {
          unsigned int v72 = 0;
        }
        if (v66) {
          int v73 = -v68;
        }
        else {
          int v73 = v68;
        }
        unsigned int v126 = v72;
LABEL_125:
        unsigned int v74 = v71;
        int v75 = (llvm::Constant **)v131;
        while (1)
        {
          AggregateElement = (unsigned __int8 *)llvm::Constant::getAggregateElement((llvm::Constant *)v5, v70);
          if (!AggregateElement) {
            break;
          }
          unint64_t v78 = (llvm::Value *)AggregateElement;
          int v79 = AggregateElement[16];
          if ((v79 - 11) >= 2)
          {
            if (v79 != 16) {
              break;
            }
          }
          else
          {
            unint64_t v78 = llvm::Constant::getNullValue(*(llvm::Constant **)(*(void *)v5 + 24), (llvm::Type *)AggregateElement, v77);
            if (!v78) {
              break;
            }
          }
          uint64_t v80 = (llvm::ConstantInt **)sub_1CC56C0C0((llvm *)0x27, v78, *v75, 0);
          int v81 = (llvm::Constant *)llvm::ConstantInt::get(*v80, v72, 0);
          Shl = llvm::ConstantExpr::getShl((llvm::ConstantExpr *)v80, v81, 0, 0);
          int v75 = (llvm::Constant **)llvm::ConstantExpr::getOr((llvm::ConstantExpr *)v75, Shl, v83, v84);
          v72 += v73;
          uint64_t v70 = (llvm::Type *)(v70 + 1);
          if (!--v74)
          {
            if (v136 >= (unint64_t)HIDWORD(v136)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            unsigned int v72 = v126;
            *((void *)v135 + v136) = v75;
            unint64_t v85 = (v136 + 1);
            LODWORD(v136) = v136 + 1;
            if (++v69 != v47) {
              goto LABEL_125;
            }
            goto LABEL_202;
          }
        }
LABEL_165:
        uint64_t v113 = v129;
        if (*(llvm::Constant **)v5 != v129)
        {
          uint64_t v114 = (llvm::detail::IEEEFloat *)v5;
LABEL_170:
          uint64_t v115 = (uint64_t)sub_1CC56C0C0((llvm *)0x31, v114, v113, 0);
LABEL_205:
          Splat = (llvm::detail::IEEEFloat *)v115;
LABEL_206:
          if (v135 != v137) {
            free(v135);
          }
          return Splat;
        }
        goto LABEL_178;
      }
      unint64_t v85 = v136;
LABEL_202:
      unint64_t v109 = (llvm::FixedVectorType ***)v135;
      uint64_t v110 = v85;
      Splat = llvm::ConstantVector::getImpl((llvm::FixedVectorType ***)v135, (llvm::Type *)v85);
      if (Splat) {
        goto LABEL_206;
      }
      unint64_t v111 = **(llvm::FixedVectorType ***)v135;
      size_t v112 = (llvm::Type *)v85;
LABEL_204:
      llvm::FixedVectorType::get(v111, v112);
      uint64_t v115 = sub_1CC56A4DC(**v123 + 1288, (uint64_t)v123, v109, v110);
      goto LABEL_205;
    }
    unint64_t v132 = (llvm::LLVMContext *)sub_1CB83544C((uint64_t)v63, (uint64_t)v53);
    if (v86 == 1)
    {
      if (v48) {
        goto LABEL_138;
      }
    }
    else if (v48)
    {
LABEL_138:
      uint64_t v87 = 0;
      uint64_t v127 = v47 / v48;
      uint64_t v129 = (llvm::Constant *)v4;
      int v88 = (v127 - 1) * v132;
      if (!v66) {
        int v88 = 0;
      }
      int v124 = v88;
      int v125 = (int)v48;
      if (v66) {
        int v89 = -(int)v132;
      }
      else {
        int v89 = (int)v132;
      }
      while (1)
      {
        uint64_t v90 = (llvm::ConstantExpr *)llvm::Constant::getAggregateElement((llvm::Constant *)v5, v87);
        if (!v90) {
          break;
        }
        size_t v93 = v90;
        int v94 = *((unsigned __int8 *)v90 + 16);
        if ((v94 - 11) > 1)
        {
          int v96 = v127;
          int v97 = v124;
          if (v94 != 16) {
            goto LABEL_165;
          }
          do
          {
            int v99 = v97;
            int v100 = **(llvm::ConstantInt ***)v93;
            unsigned int v101 = *(_DWORD *)(*(void *)v93 + 8);
            unsigned int v134 = v101 >> 8;
            if (v101 >> 8 > 0x40) {
              operator new[]();
            }
            if (v101 <= 0xFF) {
              LODWORD(v102) = 0;
            }
            else {
              unint64_t v102 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v101) + 63);
            }
            unint64_t v133 = v102 & v97;
            uint64_t v103 = (llvm::Constant *)llvm::ConstantInt::get(v100, (llvm::LLVMContext *)&v133, v92);
            if (v134 >= 0x41 && v133) {
              MEMORY[0x1D25D9CB0](v133, 0x1000C8000313F17);
            }
            LShr = (llvm::detail::IEEEFloat *)llvm::ConstantExpr::getLShr(v93, v103, 0, v98);
            if (v53[8] == 15)
            {
              uint64_t v105 = (llvm::Constant *)llvm::IntegerType::get(**(llvm::IntegerType ***)v5, v132);
              int v106 = sub_1CC56C0C0((llvm *)0x26, LShr, v105, 0);
              uint64_t v107 = 48;
            }
            else
            {
              uint64_t v107 = 38;
              int v106 = LShr;
            }
            uint64_t v108 = sub_1CC56C0C0((llvm *)v107, v106, (llvm::Constant *)v53, 0);
            if (v136 >= (unint64_t)HIDWORD(v136)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            int v97 = v99 + v89;
            *((void *)v135 + v136) = v108;
            LODWORD(v136) = v136 + 1;
            --v96;
          }
          while (v96);
        }
        else
        {
          long long v95 = llvm::UndefValue::get((llvm::UndefValue *)v53, v91);
          sub_1CBFC6AA8((uint64_t)&v135, v127, (uint64_t)v95);
        }
        uint64_t v87 = (llvm::Type *)(v87 + 1);
        uint64_t v4 = (uint64_t)v129;
        if (v87 == v125) {
          goto LABEL_163;
        }
      }
      if (*(void *)v5 != v4)
      {
        uint64_t v114 = (llvm::detail::IEEEFloat *)v5;
        uint64_t v113 = (llvm::Constant *)v4;
        goto LABEL_170;
      }
LABEL_178:
      Splat = (llvm::detail::IEEEFloat *)v5;
      goto LABEL_206;
    }
LABEL_163:
    unint64_t v109 = (llvm::FixedVectorType ***)v135;
    uint64_t v110 = v136;
    Splat = llvm::ConstantVector::getImpl((llvm::FixedVectorType ***)v135, (llvm::Type *)v136);
    if (Splat) {
      goto LABEL_206;
    }
    unint64_t v111 = **v109;
    size_t v112 = (llvm::Type *)v110;
    goto LABEL_204;
  }
  uint64_t v11 = (llvm::Type *)*((unsigned int *)v10 + 8);
  uint64_t v12 = (uint64_t)v10[3];
  if (*(unsigned __int8 *)(v12 + 8) <= 6u)
  {
    unsigned int v14 = (llvm::LLVMContext *)llvm::Type::getPrimitiveSizeInBits(v10[3]);
    if (v13 == 1)
    {
      int v10 = *(llvm::IntegerType ***)v5;
    }
    uint64_t v15 = (llvm::FixedVectorType *)llvm::IntegerType::get(*v10, v14);
    llvm::FixedVectorType::get(v15, v11);
    if (*(llvm::Constant **)v5 != v16) {
      int v5 = (unsigned __int8 *)sub_1CC56C0C0((llvm *)0x31, (llvm::detail::IEEEFloat *)v5, v16, 0);
    }
  }
  unint64_t v17 = v130;
  unsigned int v19 = sub_1CB83544C((uint64_t)v130, v4);
  if (v18 == 1) {
  unsigned int v134 = v19;
  }
  uint64_t v128 = v4;
  if (v19 > 0x40) {
    operator new[]();
  }
  unint64_t v133 = 0;
  unsigned int v20 = (unsigned __int8 *)sub_1CB83544C((uint64_t)v130, v12);
  unsigned int v23 = v20;
  if (v21 == 1)
  {
    if (!v11) {
      goto LABEL_57;
    }
  }
  else if (!v11)
  {
LABEL_57:
    int v41 = *(unsigned __int8 *)(v128 + 8);
    if (v41 == 13)
    {
      Splat = (llvm::detail::IEEEFloat *)llvm::ConstantInt::get(*(llvm::ConstantInt **)v128, (llvm::LLVMContext *)&v133, v22);
      if ((*(_DWORD *)(v128 + 8) & 0xFE) == 0x12) {
        Splat = llvm::ConstantVector::getSplat((llvm::Type *)(*(unsigned int *)(v128 + 32) | ((unint64_t)(*(_DWORD *)(v128 + 8) == 19) << 32)), (uint64_t)Splat);
      }
    }
    else
    {
      if (v41 == 2)
      {
        unsigned int v42 = &unk_1CFB2E308;
      }
      else
      {
        unsigned int v42 = &unk_1CFB2E2E0;
        switch(*(unsigned char *)(v128 + 8))
        {
          case 1:
            unsigned int v42 = &unk_1CFB2E2F4;
            break;
          case 2:
            __break(1u);
            goto LABEL_195;
          case 3:
LABEL_195:
            unsigned int v42 = &unk_1CFB2E31C;
            break;
          case 4:
            uint64_t v122 = llvm::APFloatBase::x87DoubleExtended((llvm::APFloatBase *)v20);
            goto LABEL_198;
          case 5:
            uint64_t v122 = llvm::APFloatBase::IEEEquad((llvm::APFloatBase *)v20);
LABEL_198:
            unsigned int v42 = v122;
            if (v122 == &unk_1CFB2E344) {
              goto LABEL_199;
            }
            break;
          case 6:
LABEL_199:
            llvm::detail::DoubleAPFloat::DoubleAPFloat(&v136, (uint64_t)&unk_1CFB2E344);
          default:
            break;
        }
      }
      llvm::detail::IEEEFloat::initFromAPInt((llvm::detail::IEEEFloat *)&v136, v42, (const llvm::APInt **)&v133);
      Splat = llvm::ConstantFP::get(*(llvm::ConstantFP **)v128, (llvm::LLVMContext *)&v135, v43);
      if ((_UNKNOWN *)v136 == &unk_1CFB2E344)
      {
        sub_1CB845718(v137);
      }
      else if ((*(_DWORD *)(v136 + 8) - 64) <= 0xFFFFFF7F && v137[0])
      {
        MEMORY[0x1D25D9CB0](v137[0], 0x1000C8000313F17);
      }
    }
    goto LABEL_64;
  }
  int v24 = 0;
  while (1)
  {
    unint64_t v25 = *(unsigned char *)v17 ? (llvm::Type *)v24 : (llvm::Type *)(v11 + ~v24);
    unsigned int v20 = (unsigned __int8 *)llvm::Constant::getAggregateElement((llvm::Constant *)v5, v25);
    if (!v20) {
      break;
    }
    unint64_t v26 = v20;
    int v27 = v20[16];
    if ((v27 - 11) <= 1)
    {
      if (v134 > 0x40)
      {
        llvm::APInt::shlSlowCase((llvm::APInt *)&v133, v23);
      }
      else
      {
        unint64_t v28 = v133 << v23;
        if (v134 == v23) {
          unint64_t v28 = 0;
        }
        if (v134) {
          unint64_t v29 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v134;
        }
        else {
          unint64_t v29 = 0;
        }
        unint64_t v133 = v29 & v28;
      }
      goto LABEL_52;
    }
    if (v27 != 16) {
      break;
    }
    unsigned int v30 = v134;
    if (v134 > 0x40)
    {
      llvm::APInt::shlSlowCase((llvm::APInt *)&v133, v23);
      unsigned int v30 = v134;
    }
    else
    {
      unint64_t v31 = v133 << v23;
      if (v134 == v23) {
        unint64_t v31 = 0;
      }
      unint64_t v32 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v134;
      if (!v134) {
        unint64_t v32 = 0;
      }
      unint64_t v133 = v32 & v31;
    }
    unint64_t v33 = (unint64_t *)(v26 + 24);
    unsigned int v34 = *((_DWORD *)v26 + 8);
    if (v34 < v30)
    {
      if (v30 > 0x40) {
        operator new[]();
      }
      unint64_t v35 = *v33 & (0xFFFFFFFFFFFFFFFFLL >> -(char)v30);
    }
    else
    {
      if (v34 > 0x40) {
        operator new[]();
      }
      unint64_t v35 = *v33;
      if (v30 > 0x40)
      {
        unsigned int v36 = (const llvm::APInt *)v133;
        unint64_t v37 = ((unint64_t)v30 + 63) >> 6;
        unsigned int v38 = (uint64_t *)*v33;
        do
        {
          uint64_t v39 = *v38++;
          *(void *)v36 |= v39;
          unsigned int v36 = (const llvm::APInt *)((char *)v36 + 8);
          --v37;
        }
        while (v37);
        goto LABEL_51;
      }
    }
    v133 |= v35;
LABEL_51:
    unint64_t v17 = v130;
LABEL_52:
    if (++v24 == v11) {
      goto LABEL_57;
    }
  }
  if (*(void *)v5 == v128)
  {
    Splat = (llvm::detail::IEEEFloat *)v5;
  }
  else
  {
    unsigned int v20 = (unsigned __int8 *)sub_1CC56C0C0((llvm *)0x31, (llvm::detail::IEEEFloat *)v5, (llvm::Constant *)v128, 0);
    Splat = (llvm::detail::IEEEFloat *)v20;
    if (!v20) {
      goto LABEL_57;
    }
  }
LABEL_64:
  if (v134 >= 0x41)
  {
    if (v133) {
      MEMORY[0x1D25D9CB0](v133, 0x1000C8000313F17);
    }
  }
  return Splat;
}

uint64_t llvm::canConstantFoldCallTo(llvm *this, const llvm::CallBase *a2, const llvm::Function *a3)
{
  uint64_t v5 = *((void *)this + 8);
  if (!v5 || (*(unsigned char *)(v5 + 14) & 0x10) == 0)
  {
    if (!llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)this, 20)) {
      goto LABEL_4;
    }
    uint64_t v5 = *((void *)this + 8);
    if (!v5) {
      goto LABEL_144;
    }
  }
  if ((*(unsigned char *)(v5 + 12) & 0x10) == 0)
  {
LABEL_144:
    uint64_t result = llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)this, 4);
    if (!result) {
      return result;
    }
  }
LABEL_4:
  if (*((void *)this + 9) != *((void *)a2 + 3)) {
    return 0;
  }
  int v6 = *((_DWORD *)a2 + 9);
  uint64_t result = 1;
  if (v6 > 202)
  {
    if (v6 <= 2130)
    {
      if (v6 <= 731)
      {
        switch(v6)
        {
          case 253:
          case 258:
          case 259:
          case 260:
          case 261:
          case 262:
          case 263:
          case 274:
          case 275:
          case 276:
          case 277:
          case 278:
          case 283:
          case 284:
          case 290:
          case 296:
          case 300:
          case 301:
          case 305:
          case 306:
          case 309:
          case 311:
          case 312:
          case 317:
          case 318:
          case 323:
          case 324:
          case 325:
          case 326:
          case 327:
          case 328:
          case 329:
            return result;
          case 254:
          case 255:
          case 256:
          case 257:
          case 264:
          case 265:
          case 266:
          case 267:
          case 268:
          case 269:
          case 270:
          case 271:
          case 272:
          case 279:
          case 281:
          case 282:
          case 285:
          case 286:
          case 287:
          case 288:
          case 289:
          case 291:
          case 292:
          case 293:
          case 294:
          case 295:
          case 297:
          case 298:
          case 299:
          case 302:
          case 303:
          case 304:
          case 307:
          case 308:
          case 310:
          case 313:
          case 314:
          case 315:
          case 316:
          case 319:
          case 320:
          case 321:
          case 322:
            return 0;
          case 273:
          case 280:
            goto LABEL_8;
          default:
            if (v6 == 203) {
              return result;
            }
            if ((v6 - 238) < 2) {
              goto LABEL_8;
            }
            return 0;
        }
      }
      if (v6 != 732
        && ((v6 - 1827) > 0x18 || ((1 << (v6 - 35)) & 0x1000009) == 0)
        && (v6 - 2015) >= 2)
      {
        return 0;
      }
    }
    else if (v6 > 2622)
    {
      if (v6 > 2876)
      {
        if (v6 > 3744)
        {
          if (v6 > 11301)
          {
            if ((v6 - 11302) >= 8
              && ((v6 - 12196) > 0x2B || ((1 << (v6 + 92)) & 0xC6000000033) == 0)
              && (v6 - 11802) >= 8)
            {
              return 0;
            }
            goto LABEL_8;
          }
          if ((v6 - 3745) >= 4 && (v6 - 11097) >= 4) {
            return 0;
          }
        }
        else
        {
          if (v6 <= 3474)
          {
            if (((v6 - 2877) > 0x31 || ((1 << (v6 - 61)) & 0x320000000001FLL) == 0)
              && v6 != 3428)
            {
              return 0;
            }
            goto LABEL_8;
          }
          if (v6 != 3475)
          {
            if (v6 != 3540) {
              return 0;
            }
            goto LABEL_8;
          }
        }
      }
      else if (v6 != 2623)
      {
        return 0;
      }
    }
    else if (v6 != 2131)
    {
      return 0;
    }
    return result;
  }
  char v8 = v6 + 117;
  if ((v6 - 139) > 0x3F) {
    goto LABEL_21;
  }
  if (((1 << v8) & 0xC060007000000078) != 0)
  {
LABEL_8:
    uint64_t v9 = *((void *)this + 8);
    if (!v9 || (*(unsigned char *)(v9 + 19) & 0x20) == 0) {
      return llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)this, 61) ^ 1;
    }
    return 0;
  }
  if (((1 << v8) & 0x40000C004603) == 0)
  {
LABEL_21:
    char v10 = v6 - 75;
    if ((v6 - 75) > 0x2A) {
      goto LABEL_284;
    }
    if (((1 << v10) & 3) != 0) {
      goto LABEL_8;
    }
    if (((1 << v10) & 0x4720030FF10) == 0)
    {
LABEL_284:
      if (v6 > 0x36) {
        return 0;
      }
      if (((1 << v6) & 0x70000000084302) == 0)
      {
        if (*((_DWORD *)a2 + 9))
        {
          if (((1 << v6) & 0x8000000060000) == 0) {
            return 0;
          }
          goto LABEL_8;
        }
        if ((*((unsigned char *)a2 + 23) & 0x10) == 0) {
          return 0;
        }
        uint64_t v11 = *((void *)this + 8);
        if (v11)
        {
          if ((*(unsigned char *)(v11 + 19) & 0x20) != 0) {
            return 0;
          }
        }
        if (llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)this, 61)) {
          return 0;
        }
        if ((*((unsigned char *)a2 + 23) & 0x10) == 0)
        {
          unint64_t v22 = 0;
          uint64_t v21 = &byte_1CFBCE98E;
          goto LABEL_68;
        }
        uint64_t v12 = ***(void ***)a2;
        uint64_t v13 = *(void *)(v12 + 152);
        uint64_t v14 = *(unsigned int *)(v12 + 168);
        if (v14)
        {
          LODWORD(v15) = (v14 - 1) & ((a2 >> 4) ^ (a2 >> 9));
          uint64_t v16 = v13 + 16 * v15;
          unint64_t v17 = *(const llvm::CallBase **)v16;
          if (*(const llvm::CallBase **)v16 == a2)
          {
LABEL_67:
            unsigned int v20 = *(void **)(v16 + 8);
            unint64_t v23 = *v20;
            uint64_t v21 = (char *)(v20 + 2);
            unint64_t v22 = v23;
LABEL_68:
            if (*v21 == 97)
            {
              if (v22 >= 0xB)
              {
                BOOL v24 = *(void *)v21 == 0x766E6F632E726961 && *(void *)(v21 + 3) == 0x747265766E6F632ELL;
                return v24 || v22 >= 0x29 && !memcmp(v21, "air.normalize_function_constant_predicate", 0x29uLL);
              }
              switch(v22)
              {
                case 6uLL:
                  int v50 = *(_DWORD *)v21;
                  int v47 = *((unsigned __int16 *)v21 + 2);
                  BOOL v48 = v50 == 1851880545;
                  int v49 = 26162;
                  break;
                case 5uLL:
                  if (*(_DWORD *)v21 == 1936679777 && v21[4] == 102) {
                    return 1;
                  }
                  if (*(_DWORD *)v21 == 1852404577 && v21[4] == 102) {
                    return 1;
                  }
                  if (*(_DWORD *)v21 == 1851880545 && v21[4] == 102) {
                    return 1;
                  }
                  int v90 = *(_DWORD *)v21;
                  int v47 = v21[4];
                  BOOL v48 = v90 == 1851880545;
                  int v49 = 50;
                  break;
                case 4uLL:
                  if (*(_DWORD *)v21 == 1936679777 || *(_DWORD *)v21 == 1852404577) {
                    return 1;
                  }
                  int v44 = *(_DWORD *)v21;
                  int v45 = 1851880545;
                  return v44 == v45;
                default:
                  return 0;
              }
              return v48 && v47 == v49;
            }
            uint64_t result = 0;
            switch(*v21)
            {
              case '_':
                if (v22 < 0xC || v21[1] != 95) {
                  return 0;
                }
                uint64_t result = 0;
                int v25 = v21[2];
                if (v25 <= 100)
                {
                  if (v25 != 99)
                  {
                    if (v25 != 97) {
                      return result;
                    }
                    if (v22 != 15)
                    {
                      if (v22 == 14)
                      {
                        if (*(void *)v21 == 0x5F66736F63615F5FLL && *(void *)(v21 + 6) == 0x6574696E69665F66) {
                          return 1;
                        }
                        if (*(void *)v21 == 0x5F666E6973615F5FLL && *(void *)(v21 + 6) == 0x6574696E69665F66) {
                          return 1;
                        }
                        uint64_t v27 = *(void *)v21;
                        uint64_t v28 = *(void *)(v21 + 6);
                        uint64_t v29 = 0x6574696E69665F32;
                        uint64_t v30 = 0x5F326E6174615F5FLL;
                      }
                      else
                      {
                        if (v22 != 13) {
                          return 0;
                        }
                        if (*(void *)v21 == 0x665F736F63615F5FLL && *(void *)(v21 + 5) == 0x6574696E69665F73) {
                          return 1;
                        }
                        uint64_t v27 = *(void *)v21;
                        uint64_t v28 = *(void *)(v21 + 5);
                        uint64_t v29 = 0x6574696E69665F6ELL;
                        uint64_t v30 = 0x665F6E6973615F5FLL;
                      }
                      BOOL v31 = v27 == v30;
                      return v31 && v28 == v29;
                    }
                    uint64_t v71 = *(void *)v21;
                    uint64_t v28 = *(void *)(v21 + 7);
                    uint64_t v72 = 0x66326E6174615F5FLL;
LABEL_220:
                    BOOL v31 = v71 == v72;
                    uint64_t v29 = 0x6574696E69665F66;
                    return v31 && v28 == v29;
                  }
                  if (v22 != 14)
                  {
                    if (v22 != 13) {
                      return 0;
                    }
                    uint64_t v37 = *(void *)v21;
                    uint64_t v38 = *(void *)(v21 + 5);
                    uint64_t v39 = 0x68736F635F5FLL;
                    return v37 == (v39 & 0xFFFFFFFFFFFFLL | 0x665F000000000000) && v38 == 0x6574696E69665F68;
                  }
                  uint64_t v71 = *(void *)v21;
                  uint64_t v28 = *(void *)(v21 + 6);
                  uint64_t v75 = 0x68736F635F5FLL;
                  goto LABEL_219;
                }
                if (v25 > 111)
                {
                  if (v25 == 112)
                  {
                    if (v22 != 13)
                    {
                      if (v22 != 12) {
                        return 0;
                      }
                      uint64_t v70 = *(void *)v21;
                      int v47 = *((_DWORD *)v21 + 2);
                      BOOL v48 = v70 == 0x69665F776F705F5FLL;
                      int v49 = 1702127982;
                      return v48 && v47 == v49;
                    }
                    uint64_t v71 = *(void *)v21;
                    uint64_t v28 = *(void *)(v21 + 5);
                    uint64_t v72 = 0x665F66776F705F5FLL;
                    goto LABEL_220;
                  }
                  if (v25 != 115) {
                    return result;
                  }
                  if (v22 != 14)
                  {
                    if (v22 != 13) {
                      return 0;
                    }
                    uint64_t v37 = *(void *)v21;
                    uint64_t v38 = *(void *)(v21 + 5);
                    uint64_t v39 = 0x686E69735F5FLL;
                    return v37 == (v39 & 0xFFFFFFFFFFFFLL | 0x665F000000000000) && v38 == 0x6574696E69665F68;
                  }
                  uint64_t v71 = *(void *)v21;
                  uint64_t v28 = *(void *)(v21 + 6);
                  uint64_t v75 = 0x686E69735F5FLL;
LABEL_219:
                  uint64_t v72 = v75 & 0xFFFFFFFFFFFFLL | 0x5F66000000000000;
                  goto LABEL_220;
                }
                if (v25 == 108)
                {
                  switch(v22)
                  {
                    case 0xCuLL:
                      uint64_t v32 = *(void *)v21;
                      int v33 = *((_DWORD *)v21 + 2);
                      uint64_t v34 = 0x5F676F6C5F5FLL;
                      goto LABEL_100;
                    case 0xDuLL:
                      uint64_t v94 = *(void *)v21;
                      uint64_t v78 = *(void *)(v21 + 5);
                      BOOL v80 = v94 == 0x665F66676F6C5F5FLL;
                      uint64_t v79 = 0x6574696E69665F66;
                      goto LABEL_231;
                    case 0xEuLL:
                      uint64_t v95 = *(void *)v21;
                      uint64_t v96 = *(void *)(v21 + 6);
                      return v95 == 0x5F3031676F6C5F5FLL && v96 == 0x6574696E69665F30;
                    case 0xFuLL:
                      uint64_t v71 = *(void *)v21;
                      uint64_t v28 = *(void *)(v21 + 7);
                      uint64_t v72 = 0x663031676F6C5F5FLL;
                      goto LABEL_220;
                    default:
                      return 0;
                  }
                }
                if (v25 == 101)
                {
                  if (v22 != 14)
                  {
                    if (v22 == 13)
                    {
                      if (*(void *)v21 != 0x665F667078655F5FLL || *(void *)(v21 + 5) != 0x6574696E69665F66)
                      {
                        uint64_t v77 = *(void *)v21;
                        uint64_t v78 = *(void *)(v21 + 5);
                        uint64_t v79 = 0x6574696E69665F32;
                        BOOL v80 = v77 == 0x665F327078655F5FLL;
LABEL_231:
                        if (!v80 || v78 != v79) {
                          return 0;
                        }
                      }
                    }
                    else
                    {
                      if (v22 != 12) {
                        return 0;
                      }
                      uint64_t v32 = *(void *)v21;
                      int v33 = *((_DWORD *)v21 + 2);
                      uint64_t v34 = 0x5F7078655F5FLL;
LABEL_100:
                      BOOL v35 = v32 == (v34 & 0xFFFFFFFFFFFFLL | 0x6966000000000000);
                      int v36 = 1702127982;
LABEL_176:
                      if (!v35 || v33 != v36) {
                        return 0;
                      }
                    }
                    return 1;
                  }
                  uint64_t v71 = *(void *)v21;
                  uint64_t v28 = *(void *)(v21 + 6);
                  uint64_t v75 = 0x327078655F5FLL;
                  goto LABEL_219;
                }
                break;
              case 'c':
                switch(v22)
                {
                  case 3uLL:
                    int v59 = *(unsigned __int16 *)v21;
                    int v33 = v21[2];
                    BOOL v35 = v59 == 28515;
                    int v36 = 115;
                    goto LABEL_176;
                  case 5uLL:
                    int v49 = 102;
                    if (*(_DWORD *)v21 != 1818846563 || v21[4] != 102)
                    {
                      int v57 = *(_DWORD *)v21;
                      int v47 = v21[4];
                      int v58 = 1752395619;
                      goto LABEL_187;
                    }
                    break;
                  case 4uLL:
                    if (*(_DWORD *)v21 != 1818846563 && *(_DWORD *)v21 != 1718841187)
                    {
                      int v44 = *(_DWORD *)v21;
                      int v45 = 1752395619;
                      return v44 == v45;
                    }
                    break;
                  default:
                    return 0;
                }
                return 1;
              case 'e':
                if (v22 == 5)
                {
                  int v85 = *(_DWORD *)v21;
                  int v47 = v21[4];
                  int v86 = 846231653;
                  goto LABEL_248;
                }
                if (v22 != 4)
                {
                  if (v22 != 3) {
                    return 0;
                  }
                  int v51 = *(unsigned __int16 *)v21;
                  int v33 = v21[2];
                  BOOL v35 = v51 == 30821;
                  int v36 = 112;
                  goto LABEL_176;
                }
                if (*(_DWORD *)v21 == 1718646885) {
                  return 1;
                }
                int v41 = *(_DWORD *)v21;
                int v42 = 846231653;
                goto LABEL_148;
              case 'f':
                if (v22 == 6)
                {
                  int v82 = *(_DWORD *)v21;
                  int v33 = *((unsigned __int16 *)v21 + 2);
                  BOOL v35 = v82 == 1869573222;
LABEL_204:
                  int v36 = 26226;
                  goto LABEL_176;
                }
                if (v22 == 5)
                {
                  if (*(_DWORD *)v21 == 1935827302 && v21[4] == 102) {
                    return 1;
                  }
                  if (*(_DWORD *)v21 == 1869573222 && v21[4] == 114) {
                    return 1;
                  }
                  int v85 = *(_DWORD *)v21;
                  int v47 = v21[4];
                  int v86 = 1685024102;
LABEL_248:
                  BOOL v48 = v85 == v86;
                  int v49 = 102;
                  return v48 && v47 == v49;
                }
                if (v22 != 4) {
                  return 0;
                }
                if (*(_DWORD *)v21 != 1935827302)
                {
                  int v41 = *(_DWORD *)v21;
                  int v42 = 1685024102;
LABEL_148:
                  if (v41 != v42) {
                    return 0;
                  }
                }
                return 1;
              case 'l':
                switch(v22)
                {
                  case 3uLL:
                    int v53 = *(unsigned __int16 *)v21;
                    int v33 = v21[2];
                    BOOL v35 = v53 == 28524;
                    int v36 = 103;
                    goto LABEL_176;
                  case 4uLL:
                    if (*(_DWORD *)v21 == 1718054764) {
                      return 1;
                    }
                    int v41 = *(_DWORD *)v21;
                    int v42 = 845639532;
                    goto LABEL_148;
                  case 5uLL:
                    if (*(_DWORD *)v21 == 845639532 && v21[4] == 102) {
                      return 1;
                    }
                    int v63 = *(_DWORD *)v21;
                    int v33 = v21[4];
                    BOOL v35 = v63 == 828862316;
                    int v36 = 48;
                    goto LABEL_176;
                  case 6uLL:
                    int v64 = *(_DWORD *)v21;
                    int v47 = *((unsigned __int16 *)v21 + 2);
                    BOOL v48 = v64 == 828862316;
                    int v49 = 26160;
                    return v48 && v47 == v49;
                  default:
                    return 0;
                }
              case 'n':
                if (v22 == 10)
                {
                  uint64_t v55 = *(void *)v21;
                  int v47 = *((unsigned __int16 *)v21 + 4);
                  BOOL v48 = v55 == 0x6E6979627261656ELL;
                  int v49 = 26228;
                }
                else
                {
                  if (v22 != 9) {
                    return 0;
                  }
                  uint64_t v54 = *(void *)v21;
                  int v47 = v21[8];
                  BOOL v48 = v54 == 0x6E6979627261656ELL;
                  int v49 = 116;
                }
                return v48 && v47 == v49;
              case 'p':
                if (v22 == 4)
                {
                  int v44 = *(_DWORD *)v21;
                  int v45 = 1719103344;
                  return v44 == v45;
                }
                if (v22 != 3) {
                  return 0;
                }
                int v46 = *(unsigned __int16 *)v21;
                int v47 = v21[2];
                BOOL v48 = v46 == 28528;
                int v49 = 119;
                return v48 && v47 == v49;
              case 'r':
                uint64_t result = 0;
                switch(v22)
                {
                  case 4uLL:
                    int v41 = *(_DWORD *)v21;
                    int v42 = 1953393010;
                    goto LABEL_148;
                  case 5uLL:
                    if (*(_DWORD *)v21 == 1953393010 && v21[4] == 102) {
                      return 1;
                    }
                    int v66 = *(_DWORD *)v21;
                    int v33 = v21[4];
                    BOOL v35 = v66 == 1853190002;
                    int v36 = 100;
                    goto LABEL_176;
                  case 6uLL:
                    int v67 = *(_DWORD *)v21;
                    int v47 = *((unsigned __int16 *)v21 + 2);
                    BOOL v48 = v67 == 1853190002;
                    int v49 = 26212;
                    return v48 && v47 == v49;
                  case 9uLL:
                    uint64_t v68 = *(void *)v21;
                    int v33 = v21[8];
                    BOOL v35 = v68 == 0x65646E69616D6572;
                    int v36 = 114;
                    goto LABEL_176;
                  case 0xAuLL:
                    uint64_t v69 = *(void *)v21;
                    int v33 = *((unsigned __int16 *)v21 + 4);
                    BOOL v35 = v69 == 0x65646E69616D6572;
                    goto LABEL_204;
                  default:
                    return result;
                }
              case 's':
                if (v22 == 5)
                {
                  int v49 = 102;
                  if (*(_DWORD *)v21 == 1752066419 && v21[4] == 102) {
                    return 1;
                  }
                  int v57 = *(_DWORD *)v21;
                  int v47 = v21[4];
                  int v58 = 1953657203;
LABEL_187:
                  BOOL v48 = v57 == v58;
                  return v48 && v47 == v49;
                }
                if (v22 != 4)
                {
                  if (v22 != 3) {
                    return 0;
                  }
                  int v52 = *(unsigned __int16 *)v21;
                  int v47 = v21[2];
                  BOOL v48 = v52 == 26995;
                  int v49 = 110;
                  return v48 && v47 == v49;
                }
                if (*(_DWORD *)v21 != 1718511987 && *(_DWORD *)v21 != 1752066419)
                {
                  int v44 = *(_DWORD *)v21;
                  int v45 = 1953657203;
                  return v44 == v45;
                }
                return 1;
              case 't':
                switch(v22)
                {
                  case 3uLL:
                    int v43 = *(unsigned __int16 *)v21;
                    int v33 = v21[2];
                    BOOL v35 = v43 == 24948;
                    int v36 = 110;
                    goto LABEL_176;
                  case 4uLL:
                    if (*(_DWORD *)v21 == 1718509940) {
                      return 1;
                    }
                    int v41 = *(_DWORD *)v21;
                    int v42 = 1752064372;
                    goto LABEL_148;
                  case 5uLL:
                    if (*(_DWORD *)v21 == 1752064372 && v21[4] == 102) {
                      return 1;
                    }
                    int v92 = *(_DWORD *)v21;
                    int v33 = v21[4];
                    BOOL v35 = v92 == 1853190772;
                    int v36 = 99;
                    goto LABEL_176;
                  case 6uLL:
                    int v93 = *(_DWORD *)v21;
                    int v47 = *((unsigned __int16 *)v21 + 2);
                    BOOL v48 = v93 == 1853190772;
                    int v49 = 26211;
                    return v48 && v47 == v49;
                  default:
                    return 0;
                }
              default:
                return result;
            }
            return result;
          }
          int v18 = 1;
          while (v17 != (const llvm::CallBase *)-4096)
          {
            int v19 = v15 + v18++;
            uint64_t v15 = v19 & (v14 - 1);
            unint64_t v17 = *(const llvm::CallBase **)(v13 + 16 * v15);
            if (v17 == a2)
            {
              uint64_t v16 = v13 + 16 * v15;
              goto LABEL_67;
            }
          }
        }
        uint64_t v16 = v13 + 16 * v14;
        goto LABEL_67;
      }
    }
  }
  return result;
}

llvm::Value *llvm::ConstantFoldCall(uint64_t a1, uint64_t ***a2, uint64_t a3, unint64_t a4, uint64_t *a5)
{
  v136[4] = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *(void *)(a1 + 64);
  if (!v10 || (*(unsigned char *)(v10 + 14) & 0x10) == 0)
  {
    if (!llvm::CallBase::hasFnAttrOnCalledFunction(a1, 20)) {
      goto LABEL_7;
    }
    uint64_t v10 = *(void *)(a1 + 64);
    if (!v10) {
      goto LABEL_6;
    }
  }
  if ((*(unsigned char *)(v10 + 12) & 0x10) == 0)
  {
LABEL_6:
    if (!llvm::CallBase::hasFnAttrOnCalledFunction(a1, 4)) {
      return 0;
    }
  }
LABEL_7:
  if ((*((unsigned char *)a2 + 23) & 0x10) == 0) {
    return 0;
  }
  unsigned int v13 = a2 >> 4;
  if (*((_DWORD *)a2 + 9)) {
    goto LABEL_11;
  }
  uint64_t v22 = ***a2;
  uint64_t v23 = *(void *)(v22 + 152);
  uint64_t v24 = *(unsigned int *)(v22 + 168);
  if (v24)
  {
    LODWORD(v25) = (v24 - 1) & (v13 ^ (a2 >> 9));
    unint64_t v26 = (uint64_t ****)(v23 + 16 * v25);
    uint64_t v27 = *v26;
    if (*v26 == a2) {
      goto LABEL_131;
    }
    int v28 = 1;
    while (v27 != (uint64_t ***)-4096)
    {
      int v29 = v25 + v28++;
      uint64_t v25 = v29 & (v24 - 1);
      uint64_t v27 = *(uint64_t ****)(v23 + 16 * v25);
      if (v27 == a2)
      {
        unint64_t v26 = (uint64_t ****)(v23 + 16 * v25);
        goto LABEL_131;
      }
    }
  }
  unint64_t v26 = (uint64_t ****)(v23 + 16 * v24);
LABEL_131:
  int v90 = v26[1];
  if ((unint64_t)*v90 < 4 || *((_DWORD *)v90 + 4) != 779250017)
  {
    if (!a5 || !llvm::TargetLibraryInfoImpl::getLibFunc(*a5, a2, &v128)) {
      return 0;
    }
    if ((*((unsigned char *)a2 + 23) & 0x10) == 0)
    {
      BOOL v31 = 0;
      uint64_t v32 = &byte_1CFBCE98E;
      goto LABEL_25;
    }
  }
LABEL_11:
  uint64_t v14 = ***a2;
  uint64_t v15 = *(void *)(v14 + 152);
  uint64_t v16 = *(unsigned int *)(v14 + 168);
  if (!v16)
  {
LABEL_23:
    int v18 = (uint64_t ****)(v15 + 16 * v16);
    goto LABEL_24;
  }
  LODWORD(v17) = (v16 - 1) & (v13 ^ (a2 >> 9));
  int v18 = (uint64_t ****)(v15 + 16 * v17);
  int v19 = *v18;
  if (*v18 != a2)
  {
    int v20 = 1;
    while (v19 != (uint64_t ***)-4096)
    {
      int v21 = v17 + v20++;
      uint64_t v17 = v21 & (v16 - 1);
      int v19 = *(uint64_t ****)(v15 + 16 * v17);
      if (v19 == a2)
      {
        int v18 = (uint64_t ****)(v15 + 16 * v17);
        goto LABEL_24;
      }
    }
    goto LABEL_23;
  }
LABEL_24:
  uint64_t v30 = v18[1];
  int v33 = (llvm::Type *)*v30;
  uint64_t v32 = (char *)(v30 + 2);
  BOOL v31 = v33;
LABEL_25:
  uint64_t v34 = (_DWORD *)*a2[3][2];
  int v35 = *((unsigned __int8 *)v34 + 8);
  if (v34) {
    BOOL v36 = v35 == 18;
  }
  else {
    BOOL v36 = 0;
  }
  if (!v36)
  {
    uint64_t v37 = (const llvm::APFloat *)*((unsigned int *)a2 + 9);
    if (v34) {
      BOOL v38 = v35 == 19;
    }
    else {
      BOOL v38 = 0;
    }
    if (!v38) {
      return sub_1CBFBDCD8(v32, v31, v37, (uint64_t)v34, (llvm::Constant **)a3, a4, a5, a1, (uint64_t)a2);
    }
    if (v37 == 732)
    {
      long long v60 = *(llvm::Constant **)a3;
      if (*(void *)a3)
      {
        int v61 = *((unsigned __int8 *)v60 + 16);
        if (v61 == 16)
        {
          uint64_t v62 = *((unsigned int *)v60 + 8);
          if (v62 >= 0x41)
          {
            int v120 = 0;
            int64_t v121 = (unint64_t)(v62 + 63) >> 6;
            do
            {
              BOOL v83 = v121-- < 1;
              if (v83) {
                break;
              }
              unint64_t v122 = *(void *)(*((void *)v60 + 3) + 8 * v121);
              v120 += __clz(v122);
            }
            while (!v122);
            int v123 = v62 | 0xFFFFFFC0;
            if ((v62 & 0x3F) == 0) {
              int v123 = 0;
            }
            if (v120 + v123 != v62) {
              return 0;
            }
          }
          else if (*((void *)v60 + 3))
          {
            return 0;
          }
        }
        else if (v61 == 17)
        {
          if ((sub_1CB844168((uint64_t)v60, 0.0) & 1) == 0) {
            return 0;
          }
        }
        else if ((v61 - 18) >= 3 && v61 != 13)
        {
          return 0;
        }
        uint64_t v63 = **(void **)v34;
        uint64_t Impl = *(void *)(v63 + 1568);
        if (!Impl)
        {
          int v119 = *(llvm::ConstantInt **)(v63 + 1888);
          LODWORD(v129) = *(_DWORD *)(v63 + 1896) >> 8;
          if (v129 > 0x40) {
            llvm::APInt::initSlowCase((llvm::APInt *)&v128);
          }
          uint64_t v128 = 0;
          uint64_t Impl = (uint64_t)llvm::ConstantInt::get(v119, (llvm::LLVMContext *)&v128, v37);
          if (v129 >= 0x41 && v128) {
            MEMORY[0x1D25D9CB0](v128, 0x1000C8000313F17);
          }
          *(void *)(v63 + 1568) = Impl;
        }
        if ((v34[2] & 0xFE) == 0x12) {
          return llvm::ConstantVector::getSplat((llvm::Type *)(v34[8] | ((unint64_t)(v34[2] == 19) << 32)), Impl);
        }
        return (llvm::Value *)Impl;
      }
    }
    return 0;
  }
  int v125 = v31;
  uint64_t v39 = (const llvm::APFloat *)*((unsigned int *)a2 + 9);
  int v40 = a2[5];
  unint64_t v41 = v34[8];
  unsigned int v134 = (llvm::FixedVectorType ***)v136;
  uint64_t v135 = 0x400000000;
  sub_1CBFC6B20((uint64_t)&v134, v41, 0);
  size_t v131 = (llvm::Constant **)v133;
  uint64_t v132 = 0x400000000;
  sub_1CBFC6B20((uint64_t)&v131, a4, 0);
  uint64_t v47 = *((void *)v34 + 3);
  if ((v39 - 3745) < 4)
  {
    BOOL v48 = *(llvm::Constant **)a3;
    if (*(void *)a3 && *((unsigned char *)v48 + 16) == 16)
    {
      uint64_t v49 = v34[8];
      int v50 = (void *)((char *)v48 + 24);
      if (*((_DWORD *)v48 + 8) >= 0x41u) {
        int v50 = (void *)*v50;
      }
      int v51 = (void *)*v50;
      uint64_t v128 = v130;
      uint64_t v129 = 0x1000000000;
      if (v49)
      {
        for (unint64_t i = 0; i != v49; ++i)
        {
          uint64_t v53 = **(void **)v47;
          if ((unint64_t)v51 <= i)
          {
            Splat = *(void **)(v53 + 1568);
            if (!Splat)
            {
              int v59 = *(llvm::ConstantInt **)(v53 + 1888);
              unsigned int v127 = *(_DWORD *)(v53 + 1896) >> 8;
              if (v127 > 0x40) {
                llvm::APInt::initSlowCase((llvm::APInt *)&v126);
              }
              uint64_t v126 = 0;
              Splat = llvm::ConstantInt::get(v59, (llvm::LLVMContext *)&v126, v42);
              if (v127 >= 0x41 && v126) {
                MEMORY[0x1D25D9CB0](v126, 0x1000C8000313F17);
              }
              *(void *)(v53 + 1568) = Splat;
            }
          }
          else
          {
            Splat = *(void **)(v53 + 1560);
            if (!Splat)
            {
              uint64_t v55 = *(llvm::ConstantInt **)(v53 + 1888);
              unsigned int v56 = *(_DWORD *)(v53 + 1896);
              unsigned int v127 = v56 >> 8;
              if (v56 >> 8 > 0x40) {
                llvm::APInt::initSlowCase((llvm::APInt *)&v126);
              }
              if (v56 <= 0xFF) {
                char v57 = 0;
              }
              else {
                char v57 = 0xFFFFFFFFFFFFFFFFLL >> -BYTE1(v56);
              }
              uint64_t v126 = v57 & 1;
              Splat = llvm::ConstantInt::get(v55, (llvm::LLVMContext *)&v126, v42);
              if (v127 >= 0x41 && v126) {
                MEMORY[0x1D25D9CB0](v126, 0x1000C8000313F17);
              }
              *(void *)(v53 + 1560) = Splat;
            }
          }
          if ((*(_DWORD *)(v47 + 8) & 0xFE) == 0x12) {
            Splat = llvm::ConstantVector::getSplat((llvm::Type *)(*(unsigned int *)(v47 + 32) | ((unint64_t)(*(_DWORD *)(v47 + 8) == 19) << 32)), (uint64_t)Splat);
          }
          if (v129 >= (unint64_t)HIDWORD(v129)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v128 + v129) = Splat;
          uint64_t v58 = (v129 + 1);
          LODWORD(v129) = v129 + 1;
        }
LABEL_188:
        uint64_t v114 = (llvm::FixedVectorType ***)v128;
LABEL_190:
        uint64_t Impl = (uint64_t)llvm::ConstantVector::getImpl(v114, (llvm::Type *)v58);
        if (!Impl)
        {
          llvm::FixedVectorType::get(**v114, (llvm::Type *)v58);
          uint64_t Impl = sub_1CC56A4DC(**v115 + 1288, (uint64_t)v115, v114, v58);
        }
        if (v128 != v130) {
          free(v128);
        }
        goto LABEL_203;
      }
      goto LABEL_189;
    }
    goto LABEL_147;
  }
  if (v39 == 153)
  {
    uint64_t v91 = *(void *)(a3 + 8);
    if (*(unsigned char *)(*(void *)a3 + 16) == 16) {
      int v92 = *(llvm::Constant **)a3;
    }
    else {
      int v92 = 0;
    }
    if (*(unsigned char *)(v91 + 16) != 16) {
      uint64_t v91 = 0;
    }
    if (v92) {
      BOOL v93 = v91 == 0;
    }
    else {
      BOOL v93 = 1;
    }
    if (!v93)
    {
      uint64_t v103 = v34[8];
      uint64_t v104 = (void *)((char *)v92 + 24);
      if (*((_DWORD *)v92 + 8) >= 0x41u) {
        uint64_t v104 = (void *)*v104;
      }
      uint64_t v105 = (void *)(v91 + 24);
      if (*(_DWORD *)(v91 + 32) >= 0x41u) {
        uint64_t v105 = (void *)*v105;
      }
      int v106 = (void *)*v104;
      uint64_t v107 = (void *)*v105;
      uint64_t v128 = v130;
      uint64_t v129 = 0x1000000000;
      if (v103)
      {
        do
        {
          uint64_t v108 = **(void **)v47;
          if (v106 >= v107)
          {
            unint64_t v109 = *(void **)(v108 + 1568);
            if (!v109)
            {
              uint64_t v113 = *(llvm::ConstantInt **)(v108 + 1888);
              unsigned int v127 = *(_DWORD *)(v108 + 1896) >> 8;
              if (v127 > 0x40) {
                llvm::APInt::initSlowCase((llvm::APInt *)&v126);
              }
              uint64_t v126 = 0;
              unint64_t v109 = llvm::ConstantInt::get(v113, (llvm::LLVMContext *)&v126, v42);
              if (v127 >= 0x41 && v126) {
                MEMORY[0x1D25D9CB0](v126, 0x1000C8000313F17);
              }
              *(void *)(v108 + 1568) = v109;
            }
          }
          else
          {
            unint64_t v109 = *(void **)(v108 + 1560);
            if (!v109)
            {
              uint64_t v110 = *(llvm::ConstantInt **)(v108 + 1888);
              unsigned int v111 = *(_DWORD *)(v108 + 1896);
              unsigned int v127 = v111 >> 8;
              if (v111 >> 8 > 0x40) {
                llvm::APInt::initSlowCase((llvm::APInt *)&v126);
              }
              if (v111 <= 0xFF) {
                char v112 = 0;
              }
              else {
                char v112 = 0xFFFFFFFFFFFFFFFFLL >> -BYTE1(v111);
              }
              uint64_t v126 = v112 & 1;
              unint64_t v109 = llvm::ConstantInt::get(v110, (llvm::LLVMContext *)&v126, v42);
              if (v127 >= 0x41 && v126) {
                MEMORY[0x1D25D9CB0](v126, 0x1000C8000313F17);
              }
              *(void *)(v108 + 1560) = v109;
            }
          }
          if ((*(_DWORD *)(v47 + 8) & 0xFE) == 0x12) {
            unint64_t v109 = llvm::ConstantVector::getSplat((llvm::Type *)(*(unsigned int *)(v47 + 32) | ((unint64_t)(*(_DWORD *)(v47 + 8) == 19) << 32)), (uint64_t)v109);
          }
          if (v129 >= (unint64_t)HIDWORD(v129)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v128 + v129) = v109;
          uint64_t v58 = (v129 + 1);
          LODWORD(v129) = v129 + 1;
          int v106 = (void *)((char *)v106 + 1);
          --v103;
        }
        while (v103);
        goto LABEL_188;
      }
LABEL_189:
      uint64_t v58 = 0;
      uint64_t v114 = (llvm::FixedVectorType ***)v130;
      goto LABEL_190;
    }
LABEL_147:
    int v124 = (llvm::Type *)v34[8];
    if (v124)
    {
      uint64_t v94 = 0;
      uint64_t v95 = a4;
      while (!v95)
      {
LABEL_154:
        int v99 = sub_1CBFBDCD8(v32, v125, v39, v47, v131, v132, a5, a1, (uint64_t)a2);
        if (!v99) {
          goto LABEL_158;
        }
        v134[(void)v94] = (llvm::FixedVectorType **)v99;
        uint64_t v94 = (llvm::Type *)((char *)v94 + 1);
        if (v94 == v124) {
          goto LABEL_156;
        }
      }
      uint64_t v96 = 0;
      while (1)
      {
        BOOL hasVectorInstrinsicScalarOpd = llvm::hasVectorInstrinsicScalarOpd(v39, v96);
        AggregateElement = *(llvm::Constant **)(a3 + 8 * v96);
        if (!hasVectorInstrinsicScalarOpd)
        {
          AggregateElement = (llvm::Constant *)llvm::Constant::getAggregateElement(AggregateElement, v94);
          if (!AggregateElement) {
            break;
          }
        }
        v131[v96++] = AggregateElement;
        if (v95 == v96) {
          goto LABEL_154;
        }
      }
LABEL_158:
      uint64_t Impl = 0;
    }
    else
    {
LABEL_156:
      int v100 = v134;
      uint64_t v101 = v135;
      uint64_t Impl = (uint64_t)llvm::ConstantVector::getImpl(v134, (llvm::Type *)v135);
      if (!Impl)
      {
        llvm::FixedVectorType::get(**v100, (llvm::Type *)v101);
        uint64_t Impl = sub_1CC56A4DC(**v102 + 1288, (uint64_t)v102, v100, v101);
      }
    }
    goto LABEL_203;
  }
  if (v39 != 185) {
    goto LABEL_147;
  }
  int v64 = *(llvm **)a3;
  int v66 = *(llvm::Constant **)(a3 + 16);
  unsigned int v65 = *(llvm::Constant **)(a3 + 24);
  int v67 = (llvm::Constant *)llvm::ConstantFoldLoadFromConstPtr(v64, (llvm::Constant *)v34, (llvm::Type *)(v40 + 34), v43, v44, v45, v46);
  uint64_t v128 = v130;
  uint64_t v129 = 0x2000000000;
  int v68 = v34[8];
  if (!v68)
  {
    unint64_t v80 = 0;
    unsigned int v116 = (llvm::FixedVectorType ***)v130;
LABEL_198:
    uint64_t Impl = (uint64_t)llvm::ConstantVector::getImpl(v116, (llvm::Type *)v80);
    if (!Impl)
    {
      llvm::FixedVectorType::get(**v116, (llvm::Type *)v80);
      uint64_t Impl = sub_1CC56A4DC(**v117 + 1288, (uint64_t)v117, v116, v80);
    }
    goto LABEL_201;
  }
  uint64_t v69 = v67;
  uint64_t v70 = 0;
  while (1)
  {
    uint64_t v71 = llvm::Constant::getAggregateElement(v66, v70);
    if (!v71) {
      break;
    }
    uint64_t v72 = (uint64_t)v71;
    uint64_t Impl = (uint64_t)llvm::Constant::getAggregateElement(v65, v70);
    if (v69) {
      int v73 = llvm::Constant::getAggregateElement(v69, v70);
    }
    else {
      int v73 = 0;
    }
    int v74 = *(unsigned __int8 *)(v72 + 16);
    if ((v74 - 11) <= 1)
    {
      if (!Impl)
      {
        if (!v73) {
          goto LABEL_200;
        }
        if (v129 >= (unint64_t)HIDWORD(v129)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v128 + v129) = v73;
        LODWORD(v129) = v129 + 1;
        int v78 = *(unsigned __int8 *)(v72 + 16);
        if (v78 == 16)
        {
          uint64_t v79 = *(unsigned int *)(v72 + 32);
          if (v79 >= 0x41)
          {
            int v86 = 0;
            int64_t v87 = (unint64_t)(v79 + 63) >> 6;
            do
            {
              BOOL v83 = v87-- < 1;
              if (v83) {
                break;
              }
              unint64_t v88 = *(void *)(*(void *)(v72 + 24) + 8 * v87);
              v86 += __clz(v88);
            }
            while (!v88);
            int v89 = v79 | 0xFFFFFFC0;
            if ((v79 & 0x3F) == 0) {
              int v89 = 0;
            }
            if (v86 + v89 == v79) {
              goto LABEL_200;
            }
          }
          else if (!*(void *)(v72 + 24))
          {
            goto LABEL_200;
          }
        }
        else if (v78 == 17)
        {
          if (sub_1CB844168(v72, 0.0)) {
            goto LABEL_200;
          }
        }
        else
        {
          uint64_t Impl = 0;
          if ((v78 - 18) < 3 || v78 == 13) {
            goto LABEL_201;
          }
        }
LABEL_99:
        uint64_t Impl = 0;
        if (!llvm::Constant::isOneValue((llvm::Constant *)v72) || !v73) {
          goto LABEL_201;
        }
        unint64_t v76 = v129;
        unint64_t v77 = HIDWORD(v129);
        uint64_t Impl = (uint64_t)v73;
        goto LABEL_102;
      }
      if (v129 >= (unint64_t)HIDWORD(v129)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v128 + v129) = Impl;
      LODWORD(v129) = v129 + 1;
      int v74 = *(unsigned __int8 *)(v72 + 16);
    }
    if (v74 == 16)
    {
      uint64_t v75 = *(unsigned int *)(v72 + 32);
      if (v75 >= 0x41)
      {
        int v81 = 0;
        int64_t v82 = (unint64_t)(v75 + 63) >> 6;
        do
        {
          BOOL v83 = v82-- < 1;
          if (v83) {
            break;
          }
          unint64_t v84 = *(void *)(*(void *)(v72 + 24) + 8 * v82);
          v81 += __clz(v84);
        }
        while (!v84);
        int v85 = v75 | 0xFFFFFFC0;
        if ((v75 & 0x3F) == 0) {
          int v85 = 0;
        }
        if (v81 + v85 != v75) {
          goto LABEL_99;
        }
      }
      else if (*(void *)(v72 + 24))
      {
        goto LABEL_99;
      }
    }
    else if (v74 == 17)
    {
      if ((sub_1CB844168(v72, 0.0) & 1) == 0) {
        goto LABEL_99;
      }
    }
    else if ((v74 - 18) >= 3 && v74 != 13)
    {
      goto LABEL_99;
    }
    if (!Impl) {
      goto LABEL_201;
    }
    unint64_t v76 = v129;
    unint64_t v77 = HIDWORD(v129);
LABEL_102:
    if (v76 >= v77) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)v128 + v76) = Impl;
    unint64_t v80 = (v129 + 1);
    LODWORD(v129) = v129 + 1;
    uint64_t v70 = (llvm::Type *)(v70 + 1);
    if (v70 == v68) {
      goto LABEL_196;
    }
  }
  unint64_t v80 = v129;
LABEL_196:
  if (v80 == v34[8])
  {
    unsigned int v116 = (llvm::FixedVectorType ***)v128;
    goto LABEL_198;
  }
LABEL_200:
  uint64_t Impl = 0;
LABEL_201:
  if (v128 != v130) {
    free(v128);
  }
LABEL_203:
  if (v131 != (llvm::Constant **)v133) {
    free(v131);
  }
  if (v134 != v136) {
    free(v134);
  }
  return (llvm::Value *)Impl;
}

const llvm::detail::DoubleAPFloat *sub_1CBFBDCD8(char *__s1, llvm::Type *a2, const llvm::APFloat *a3, uint64_t a4, llvm::Constant **a5, uint64_t a6, void *a7, uint64_t a8, uint64_t a9)
{
  uint64_t v11 = (int8x8_t **)a5;
  LODWORD(v12) = a3;
  uint64_t v627 = *MEMORY[0x1E4F143B8];
  if (a6 != 3)
  {
    size_t v14 = (size_t)a2;
    if (a6 != 2)
    {
      if (a6 != 1) {
        return 0;
      }
      if ((unint64_t)a2 < 0xB)
      {
LABEL_11:
        int v19 = *v11;
        if (v12 == 165)
        {
          uint64_t v186 = (uint64_t **)a4;
          if (llvm::Constant::isManifestConstant((llvm::Constant *)*v11))
          {
            uint64_t v188 = **v186;
            int v21 = *(llvm::Constant **)(v188 + 1560);
            if (!v21)
            {
              unint64_t v189 = *(llvm::ConstantInt **)(v188 + 1888);
              unsigned int v190 = *(_DWORD *)(v188 + 1896);
              DWORD2(__src) = v190 >> 8;
              if (v190 >> 8 > 0x40) {
                llvm::APInt::initSlowCase((llvm::APInt *)&__src);
              }
              if (v190 <= 0xFF) {
                char v191 = 0;
              }
              else {
                char v191 = 0xFFFFFFFFFFFFFFFFLL >> -BYTE1(v190);
              }
              *(void *)&long long __src = v191 & 1;
              int v21 = (llvm::Constant *)llvm::ConstantInt::get(v189, (llvm::LLVMContext *)&__src, v187);
              if (DWORD2(__src) >= 0x41 && (void)__src) {
                MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
              }
              *(void *)(v188 + 1560) = v21;
            }
            return v21;
          }
          return 0;
        }
        int v20 = v19[2].u8[0];
        if ((v20 - 11) <= 1)
        {
          if ((int)v12 <= 143)
          {
            int v21 = (llvm::Constant *)*v11;
            if ((v12 - 8) < 2) {
              return v21;
            }
            if (v12 == 51 || v12 == 53) {
              goto LABEL_339;
            }
            goto LABEL_345;
          }
          if ((v12 - 290) > 0x27)
          {
LABEL_338:
            if ((v12 - 144) < 2)
            {
LABEL_339:
              uint64_t v169 = (llvm::Constant *)a4;
              return llvm::Constant::getNullValue(v169, a2, a3);
            }
            int v21 = (llvm::Constant *)*v11;
            if (v12 == 166) {
              return v21;
            }
            goto LABEL_345;
          }
          if (((1 << (v12 - 34)) & 0xFE18000000) == 0)
          {
            if (v12 == 290) {
              return (const llvm::detail::DoubleAPFloat *)*v11;
            }
            goto LABEL_338;
          }
LABEL_282:
          int8x8_t v149 = *v19;
          if (*(void *)v19 && *(unsigned char *)(*(void *)&v149 + 8) == 18)
          {
            if (v20 == 12) {
              goto LABEL_342;
            }
            uint64_t v150 = a4;
            if (v20 == 13)
            {
              uint64_t v151 = (llvm::Constant *)llvm::ConstantInt::get(*(llvm::ConstantInt **)(*(void *)&v149 + 24), 0, 0);
LABEL_343:
              int v21 = v151;
              goto LABEL_344;
            }
            int v171 = llvm::Constant::containsPoisonElement((llvm::Constant *)*v11);
            a4 = v150;
            if (v171)
            {
LABEL_342:
              uint64_t v150 = a4;
              uint64_t v151 = (llvm::Constant *)llvm::PoisonValue::get(*(llvm::PoisonValue **)(*(void *)&v149 + 24), a2);
              goto LABEL_343;
            }
            int v211 = v19[2].u8[0];
            if (v211 == 15 || v211 == 10)
            {
              AggregateElement = llvm::Constant::getAggregateElement((llvm::Constant *)v19, 0);
              a4 = v150;
              if (AggregateElement)
              {
                if (*((unsigned char *)AggregateElement + 16) == 16)
                {
                  DWORD2(__src) = *((_DWORD *)AggregateElement + 8);
                  if (DWORD2(__src) > 0x40) {
                    operator new[]();
                  }
                  *(void *)&long long __src = AggregateElement[3];
                  int v331 = *(_DWORD *)(*(void *)&v149 + 32);
                  if (v331 == 1)
                  {
LABEL_752:
                    int v21 = (llvm::Constant *)llvm::ConstantInt::get(**(llvm::ConstantInt ***)v19, (llvm::LLVMContext *)&__src, v213);
                  }
                  else
                  {
                    int v332 = v12 - 317;
                    uint64_t v333 = 1;
                    int v578 = v331;
                    while (2)
                    {
                      size_t v334 = llvm::Constant::getAggregateElement((llvm::Constant *)v19, (llvm::Type *)v333);
                      int v21 = 0;
                      if (v334 && *((unsigned char *)v334 + 16) == 16)
                      {
                        p_src = v334 + 3;
                        switch(v332)
                        {
                          case 0:
                            int v336 = DWORD2(__src);
                            if (DWORD2(__src) >= 0x41) {
                              operator new[]();
                            }
                            uint64_t v337 = *p_src + __src;
                            unint64_t v338 = 0xFFFFFFFFFFFFFFFFLL >> -BYTE8(__src);
                            if (!DWORD2(__src)) {
                              unint64_t v338 = 0;
                            }
                            goto LABEL_779;
                          case 1:
                            int v336 = DWORD2(__src);
                            if (DWORD2(__src) > 0x40) {
                              operator new[]();
                            }
                            uint64_t v337 = __src;
                            unint64_t v338 = *p_src;
LABEL_779:
                            unint64_t v345 = v338 & v337;
                            goto LABEL_817;
                          case 6:
                            llvm::APInt::operator*((uint64_t)&__src, p_src, (uint64_t)&v623);
                            if (DWORD2(__src) >= 0x41 && (void)__src) {
                              MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
                            }
                            *(void *)&long long __src = v623;
                            DWORD2(__src) = v624;
                            goto LABEL_819;
                          case 7:
                            int v336 = DWORD2(__src);
                            if (DWORD2(__src) > 0x40) {
                              operator new[]();
                            }
                            unint64_t v345 = *p_src | __src;
                            goto LABEL_817;
                          case 8:
                            if (DWORD2(__src) <= 0x40)
                            {
                              uint64_t v353 = -(uint64_t)DWORD2(__src);
                              uint64_t v354 = (uint64_t)((void)__src << v353) >> v353;
                              uint64_t v355 = (uint64_t)(v334[3] << v353) >> v353;
                              BOOL v347 = v354 > v355;
                              if (v354 > v355) {
                                p_src = (unint64_t *)&__src;
                              }
                              int v356 = (unsigned int *)(v334 + 4);
                              if (v354 > v355) {
                                int v356 = (unsigned int *)&__src + 2;
                              }
                              unsigned int v343 = *v356;
                              if (v343 < 0x41)
                              {
                                if (v354 <= v355) {
                                  uint64_t v344 = v334[3];
                                }
                                else {
                                  uint64_t v344 = __src;
                                }
                                goto LABEL_810;
                              }
                              goto LABEL_852;
                            }
                            uint64_t v362 = *(void *)(__src + 8 * ((DWORD2(__src) - 1) >> 6)) & (1 << (BYTE8(__src) - 1));
                            unsigned int v363 = *((_DWORD *)v334 + 8);
                            unsigned int v364 = v363 - 1;
                            uint64_t v365 = v334[3];
                            if (v363 >= 0x41) {
                              uint64_t v366 = (void *)(v365 + 8 * (v364 >> 6));
                            }
                            else {
                              uint64_t v366 = v334 + 3;
                            }
                            if ((v362 != 0) != ((*v366 >> v364) & 1))
                            {
                              BOOL v347 = v362 == 0;
                              if (!v362) {
                                p_src = (unint64_t *)&__src;
                              }
                              goto LABEL_851;
                            }
                            uint64_t v372 = v365 - 8;
                            unint64_t v373 = (((unint64_t)DWORD2(__src) + 63) >> 3) & 0x3FFFFFF8;
                            do
                            {
                              if (!v373) {
                                goto LABEL_850;
                              }
                              unint64_t v374 = *(void *)(__src - 8 + v373);
                              unint64_t v375 = *(void *)(v372 + v373);
                              v373 -= 8;
                              BOOL v376 = v374 > v375;
                            }
                            while (v374 == v375);
                            goto LABEL_845;
                          case 9:
                            if (DWORD2(__src) <= 0x40)
                            {
                              uint64_t v339 = (uint64_t)((void)__src << -BYTE8(__src)) >> -BYTE8(__src);
                              uint64_t v340 = (uint64_t)(v334[3] << -(uint64_t)DWORD2(__src)) >> -(uint64_t)DWORD2(__src);
                              unsigned int v341 = v339 < v340;
                              if (v339 < v340) {
                                p_src = (unint64_t *)&__src;
                              }
                              int v342 = (unsigned int *)(v334 + 4);
                              if (v339 < v340) {
                                int v342 = (unsigned int *)&__src + 2;
                              }
                              unsigned int v343 = *v342;
                              if (v343 >= 0x41) {
                                goto LABEL_863;
                              }
                              if (v339 >= v340) {
                                uint64_t v344 = v334[3];
                              }
                              else {
                                uint64_t v344 = __src;
                              }
LABEL_810:
                              *(void *)&long long __src = v344;
                              DWORD2(__src) = v343;
                              goto LABEL_819;
                            }
                            uint64_t v357 = *(void *)(__src + 8 * ((DWORD2(__src) - 1) >> 6)) & (1 << (BYTE8(__src) - 1));
                            unsigned int v341 = v357 != 0;
                            unsigned int v358 = *((_DWORD *)v334 + 8);
                            unsigned int v359 = v358 - 1;
                            uint64_t v360 = v334[3];
                            if (v358 >= 0x41) {
                              v361 = (void *)(v360 + 8 * (v359 >> 6));
                            }
                            else {
                              v361 = v334 + 3;
                            }
                            if (v341 != ((*v361 >> v359) & 1))
                            {
                              if (v357) {
                                p_src = (unint64_t *)&__src;
                              }
                              goto LABEL_862;
                            }
                            uint64_t v367 = v360 - 8;
                            unint64_t v368 = (((unint64_t)DWORD2(__src) + 63) >> 3) & 0x3FFFFFF8;
                            do
                            {
                              if (!v368) {
                                goto LABEL_860;
                              }
                              unint64_t v369 = *(void *)(__src - 8 + v368);
                              unint64_t v370 = *(void *)(v367 + v368);
                              v368 -= 8;
                              BOOL v371 = v369 > v370;
                            }
                            while (v369 == v370);
                            goto LABEL_857;
                          case 10:
                            if (DWORD2(__src) > 0x40)
                            {
                              unint64_t v377 = (((unint64_t)DWORD2(__src) + 63) >> 3) & 0x3FFFFFF8;
                              do
                              {
                                if (!v377)
                                {
LABEL_850:
                                  BOOL v347 = 0;
LABEL_851:
                                  int v331 = v578;
                                  int v332 = v12 - 317;
                                  goto LABEL_852;
                                }
                                unint64_t v378 = *(void *)(__src - 8 + v377);
                                unint64_t v379 = *(void *)(*p_src - 8 + v377);
                                v377 -= 8;
                                BOOL v376 = v378 > v379;
                              }
                              while (v378 == v379);
LABEL_845:
                              BOOL v347 = v376;
                              int v331 = v578;
                              int v332 = v12 - 317;
                              if (v376) {
                                goto LABEL_819;
                              }
                            }
                            else
                            {
                              unint64_t v346 = v334[3];
                              BOOL v347 = (unint64_t)__src > v346;
                              if ((unint64_t)__src > v346) {
                                p_src = (unint64_t *)&__src;
                              }
                              size_t v348 = (unsigned int *)(v334 + 4);
                              if ((unint64_t)__src > v346) {
                                size_t v348 = (unsigned int *)&__src + 2;
                              }
                              unsigned int v349 = *v348;
                              if (v349 < 0x41)
                              {
                                if ((unint64_t)__src <= v346) {
                                  uint64_t v350 = v334[3];
                                }
                                else {
                                  uint64_t v350 = __src;
                                }
                                goto LABEL_798;
                              }
                            }
LABEL_852:
                            if (&__src == (long long *)p_src) {
                              goto LABEL_819;
                            }
                            uint64_t v380 = (unsigned int *)(v334 + 4);
                            BOOL v381 = !v347;
                            goto LABEL_865;
                          case 11:
                            if (DWORD2(__src) > 0x40)
                            {
                              unint64_t v368 = (((unint64_t)DWORD2(__src) + 63) >> 3) & 0x3FFFFFF8;
                              do
                              {
                                if (!v368) {
                                  goto LABEL_860;
                                }
                                unint64_t v382 = *(void *)(__src - 8 + v368);
                                unint64_t v383 = *(void *)(*p_src - 8 + v368);
                                v368 -= 8;
                                BOOL v371 = v382 > v383;
                              }
                              while (v382 == v383);
LABEL_857:
                              if (v371) {
                                LODWORD(v368) = 1;
                              }
                              else {
                                LODWORD(v368) = -1;
                              }
LABEL_860:
                              unsigned int v341 = v368 >> 31;
                              if ((v368 & 0x80000000) != 0) {
                                p_src = (unint64_t *)&__src;
                              }
LABEL_862:
                              int v331 = v578;
                              int v332 = v12 - 317;
                              goto LABEL_863;
                            }
                            unint64_t v351 = v334[3];
                            unsigned int v341 = (unint64_t)__src < v351;
                            if ((unint64_t)__src < v351) {
                              p_src = (unint64_t *)&__src;
                            }
                            uint64_t v352 = (unsigned int *)(v334 + 4);
                            if ((unint64_t)__src < v351) {
                              uint64_t v352 = (unsigned int *)&__src + 2;
                            }
                            unsigned int v349 = *v352;
                            if (v349 < 0x41)
                            {
                              if ((unint64_t)__src >= v351) {
                                uint64_t v350 = v334[3];
                              }
                              else {
                                uint64_t v350 = __src;
                              }
LABEL_798:
                              *(void *)&long long __src = v350;
                              DWORD2(__src) = v349;
                              goto LABEL_819;
                            }
LABEL_863:
                            if (&__src != (long long *)p_src)
                            {
                              uint64_t v380 = (unsigned int *)(v334 + 4);
                              BOOL v381 = v341 == 0;
LABEL_865:
                              if (v381) {
                                int v384 = v380;
                              }
                              else {
                                int v384 = (unsigned int *)&__src + 2;
                              }
                              llvm::APInt::reallocate((uint64_t)&__src, *v384);
                              if (DWORD2(__src) <= 0x40) {
                                *(void *)&long long __src = *p_src;
                              }
                              else {
                                memcpy((void *)__src, (const void *)*p_src, (((unint64_t)DWORD2(__src) + 63) >> 3) & 0x3FFFFFF8);
                              }
                              int v331 = v578;
LABEL_818:
                              int v332 = v12 - 317;
                            }
LABEL_819:
                            uint64_t v333 = (v333 + 1);
                            if (v333 == v331) {
                              goto LABEL_752;
                            }
                            continue;
                          case 12:
                            int v336 = DWORD2(__src);
                            if (DWORD2(__src) > 0x40) {
                              operator new[]();
                            }
                            unint64_t v345 = *p_src ^ __src;
LABEL_817:
                            *(void *)&long long __src = v345;
                            DWORD2(__src) = v336;
                            goto LABEL_818;
                          default:
                            goto LABEL_819;
                        }
                      }
                      break;
                    }
                  }
                  if (DWORD2(__src) >= 0x41 && (void)__src) {
                    MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
                  }
LABEL_344:
                  a4 = v150;
                  if (v21) {
                    return v21;
                  }
                }
              }
            }
          }
LABEL_345:
          uint64_t v94 = (llvm::Constant *)*v11;
          int v172 = (*v11)[2].u8[0];
          if (v172 != 15 && v172 != 10) {
            return 0;
          }
          int v21 = 0;
          char v174 = (_BYTE)v12 + 92;
          if ((v12 - 12196) > 0x2B) {
            return v21;
          }
          if (((1 << v174) & 0x6000000003) == 0)
          {
            if (((1 << v174) & 0xC0000000030) == 0) {
              return v21;
            }
            BOOL v93 = (llvm::ConstantInt *)a4;
LABEL_354:
            int v175 = llvm::Constant::getAggregateElement(v94, 0);
            if (v175 && *((unsigned char *)v175 + 16) == 17)
            {
              uint64_t v96 = (uint64_t)(v175 + 3);
              int v97 = 1;
LABEL_361:
              int v177 = v93;
              uint64_t v178 = 1;
              return (const llvm::detail::DoubleAPFloat *)sub_1CBFC6F2C(v96, v97, v177, (const llvm::APInt *)v178);
            }
            return 0;
          }
          BOOL v93 = (llvm::ConstantInt *)a4;
LABEL_358:
          size_t v176 = llvm::Constant::getAggregateElement(v94, 0);
          if (v176 && *((unsigned char *)v176 + 16) == 17)
          {
            uint64_t v96 = (uint64_t)(v176 + 3);
            int v97 = 0;
            goto LABEL_361;
          }
          return 0;
        }
        if (v20 != 16)
        {
          if (v20 != 17)
          {
            if (v20 != 19)
            {
              if ((v12 - 323) >= 7 && (v12 - 317) > 1) {
                goto LABEL_345;
              }
              goto LABEL_282;
            }
            if ((v12 - 290) > 0x27) {
              goto LABEL_144;
            }
            if (((1 << (v12 - 34)) & 0xFE18000000) != 0) {
              goto LABEL_282;
            }
            if (v12 != 290)
            {
LABEL_144:
              if (v12 != 166) {
                goto LABEL_345;
              }
            }
            uint64_t v81 = *(void *)(a8 + 40);
            if (v81)
            {
              uint64_t v82 = *(void *)(v81 + 56);
              if (v82)
              {
                unsigned int v83 = *(_DWORD *)(*(void *)v19 + 8);
                if ((v83 & 0xFE) == 0x12) {
                  unsigned int v83 = *(_DWORD *)(**(void **)(*(void *)v19 + 16) + 8);
                }
                uint64_t v84 = *(void *)(v82 + 112);
                if (v84)
                {
                  int v21 = 0;
                  if ((*(unsigned char *)(v84 + 17) & 1) != 0 || v83 > 0xFF) {
                    return v21;
                  }
                  return (const llvm::detail::DoubleAPFloat *)*v11;
                }
                if (v83 <= 0xFF) {
                  return (const llvm::detail::DoubleAPFloat *)*v11;
                }
              }
            }
            return 0;
          }
          if (v12 == 18)
          {
            uint64_t v142 = (llvm::ConstantInt **)a4;
            int v143 = (const llvm::detail::DoubleAPFloat *)&v19[4];
            if (*(_UNKNOWN **)&v19[4] == &unk_1CFB2E344) {
              llvm::detail::DoubleAPFloat::DoubleAPFloat((void *)&__src + 1, v143);
            }
            else {
              llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&__src + 8, v143);
            }
            llvm::APFloat::convert((uint64_t)&__src, &unk_1CFB2E2E0, 1, v620);
            int v144 = *v142;
            if (*((_UNKNOWN **)&__src + 1) == &unk_1CFB2E344) {
              llvm::detail::DoubleAPFloat::bitcastToAPInt((llvm::detail::DoubleAPFloat *)((char *)&__src + 8), (llvm::APInt *)&v623);
            }
            else {
              llvm::detail::IEEEFloat::bitcastToAPInt((uint64_t)&__src + 8, (uint64_t)&v623);
            }
            Splat = (llvm::Constant *)llvm::ConstantInt::get(v144, (llvm::LLVMContext *)&v623, v145);
LABEL_275:
            int v21 = Splat;
LABEL_557:
            if (v624 >= 0x41)
            {
              unint64_t v266 = v623;
              if (v623) {
LABEL_559:
              }
                MEMORY[0x1D25D9CB0](v266, 0x1000C8000313F17);
            }
LABEL_1709:
            uint64_t v192 = *((void *)&__src + 1);
            if (*((_UNKNOWN **)&__src + 1) != &unk_1CFB2E344) {
              goto LABEL_1710;
            }
            goto LABEL_1713;
          }
          uint64_t v583 = a4;
          uint64_t v179 = (void **)&v19[4];
          unint64_t v180 = (const llvm::detail::DoubleAPFloat *)&v19[4];
          if (*(_UNKNOWN **)&v19[4] == &unk_1CFB2E344) {
            llvm::detail::DoubleAPFloat::DoubleAPFloat((void *)&__src + 1, v180);
          }
          else {
            llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&__src + 8, v180);
          }
          if ((v12 - 11099) <= 1)
          {
            int v182 = &__src;
            if (*((_UNKNOWN **)&__src + 1) == &unk_1CFB2E344) {
              int v182 = v585;
            }
            if ((*((unsigned char *)v182 + 28) & 7) == 1) {
              goto LABEL_370;
            }
            LODWORD(v624) = *(_DWORD *)(v583 + 8) >> 8;
            if (v624 > 0x40) {
              llvm::APInt::initSlowCase((llvm::APInt *)&v623);
            }
            unint64_t v623 = 0;
            BYTE4(v624) = v12 != 11099;
            v620[0] = 0;
            if ((llvm::APFloat::convertToInteger((uint64_t)&__src, (uint64_t)&v623, 0, v620) & 0xFFFFFFEF) != 0)
            {
              int v21 = 0;
              goto LABEL_557;
            }
LABEL_556:
            int v21 = (llvm::Constant *)llvm::ConstantInt::get(*(llvm::ConstantInt **)v583, (llvm::LLVMContext *)&v623, v216);
            if ((*(_DWORD *)(v583 + 8) & 0xFE) != 0x12) {
              goto LABEL_557;
            }
            Splat = llvm::ConstantVector::getSplat((llvm::Type *)(*(unsigned int *)(v583 + 32) | ((unint64_t)(*(_DWORD *)(v583 + 8) == 19) << 32)), (uint64_t)v21);
            goto LABEL_275;
          }
          if ((v12 & 0xFFFFFFFE) == 0x90)
          {
            LODWORD(v624) = *(_DWORD *)(v583 + 8) >> 8;
            if (v624 > 0x40) {
              llvm::APInt::initSlowCase((llvm::APInt *)&v623);
            }
            unint64_t v623 = 0;
            BYTE4(v624) = v12 == 145;
            v620[0] = 0;
            llvm::APFloat::convertToInteger((uint64_t)&__src, (uint64_t)&v623, 0, v620);
            goto LABEL_556;
          }
          int v21 = 0;
          unsigned int v267 = *(unsigned __int8 *)(v583 + 8);
          if (v267 > 3 || v267 == 1) {
            goto LABEL_1709;
          }
          if ((int)v12 <= 138)
          {
            if ((int)v12 > 107)
            {
              LOBYTE(RoundingMode) = 4;
              switch((int)v12)
              {
                case 'l':
                case 'o':
                  unsigned __int16 RoundingMode = llvm::ConstrainedFPIntrinsic::getRoundingMode((llvm::ConstrainedFPIntrinsic *)a8);
                  int v21 = 0;
                  if (RoundingMode >= 0x100u && RoundingMode != 7) {
                    goto LABEL_1078;
                  }
                  break;
                case 'p':
                  goto LABEL_1078;
                case 'u':
                  LOBYTE(RoundingMode) = 0;
                  goto LABEL_1078;
                default:
                  goto LABEL_1153;
              }
              goto LABEL_1709;
            }
            switch(v12)
            {
              case 0xE:
                goto LABEL_1704;
              case 0x4F:
                LOBYTE(RoundingMode) = 2;
                break;
              case 0x57:
                LOBYTE(RoundingMode) = 3;
                break;
              default:
                goto LABEL_1153;
            }
LABEL_1078:
            if (*((_UNKNOWN **)&__src + 1) == &unk_1CFB2E344) {
              uint64_t v457 = v585;
            }
            else {
              uint64_t v457 = &__src;
            }
            char v458 = *((unsigned char *)v457 + 28);
            if ((v458 & 6) != 0)
            {
              int v459 = sub_1CBFC6BD8((uint64_t)&__src, (char)RoundingMode);
              if (v12 != 111) {
                goto LABEL_1706;
              }
              if (v459 != 16) {
                goto LABEL_1706;
              }
              unsigned __int16 ExceptionBehavior = llvm::ConstrainedFPIntrinsic::getExceptionBehavior((llvm::ConstrainedFPIntrinsic *)a8);
              if (ExceptionBehavior < 0x100u || ExceptionBehavior != 2) {
                goto LABEL_1706;
              }
            }
            else
            {
              if ((v458 & 7) != 1) {
                goto LABEL_1706;
              }
              v461 = *((_UNKNOWN **)&__src + 1) == &unk_1CFB2E344 ? v585 : &__src;
              uint64_t v462 = *((void *)v461 + 1);
              if (*(_DWORD *)(v462 + 16) == 1) {
                goto LABEL_1706;
              }
              int v463 = *(_DWORD *)(v462 + 8);
              if (*((_UNKNOWN **)&__src + 1) == &unk_1CFB2E344) {
                uint64_t v464 = v585;
              }
              else {
                uint64_t v464 = &__src;
              }
              if (*((_UNKNOWN **)&__src + 1) == &unk_1CFB2E344) {
                uint64_t v465 = (uint64_t *)(v585 + 1);
              }
              else {
                uint64_t v465 = (uint64_t *)&v585;
              }
              if ((v463 - 64) <= 0xFFFFFF7F) {
                uint64_t v465 = (uint64_t *)*((void *)v464 + 2);
              }
              if (((unint64_t)v465[(v463 - 2) >> 6] >> (v463 - 2))) {
                goto LABEL_1706;
              }
              v466 = (void *)llvm::ConstrainedFPIntrinsic::getExceptionBehavior((llvm::ConstrainedFPIntrinsic *)a8);
              if ((unsigned __int16)v466 < 0x100u || !(_BYTE)v466)
              {
                if (*((_UNKNOWN **)&__src + 1) == &unk_1CFB2E344) {
                  llvm::detail::DoubleAPFloat::DoubleAPFloat(&v624, (uint64_t)&unk_1CFB2E344);
                }
                *(void *)&long long v624 = *((void *)&__src + 1);
                if ((*(_DWORD *)(*((void *)&__src + 1) + 8) + 64) >= 0x80) {
                  operator new[]();
                }
                char v626 = 3;
                int v625 = *(_DWORD *)(*((void *)&__src + 1) + 4) - 1;
                int v467 = *(_DWORD *)(*((void *)&__src + 1) + 8);
                if ((v467 - 64) < 0xFFFFFF80)
                {
                  void *v466 = 0;
                  bzero(v466 + 1, 8 * (((v467 + 64) >> 6) - 2) + 8);
                }
                else
                {
                  *((void *)&v624 + 1) = 0;
                }
                sub_1CBFC6FE8((uint64_t)&v623, 0, 0, 0);
                sub_1CB9190C0((uint64_t *)&__src + 1, (void **)&v624);
                if ((_UNKNOWN *)v624 == &unk_1CFB2E344)
                {
                  sub_1CB845718((uint64_t *)&v624 + 1);
                }
                else if ((*(_DWORD *)(v624 + 8) - 64) <= 0xFFFFFF7F && *((void *)&v624 + 1))
                {
                  MEMORY[0x1D25D9CB0](*((void *)&v624 + 1), 0x1000C8000313F17);
                }
                goto LABEL_1706;
              }
            }
            goto LABEL_370;
          }
          if ((int)v12 > 258)
          {
            if ((int)v12 > 295)
            {
              if (v12 == 296)
              {
LABEL_1054:
                uint64_t v268 = 0;
                goto LABEL_1705;
              }
              if (v12 == 2926)
              {
                if (*((_UNKNOWN **)&__src + 1) == &unk_1CFB2E344) {
                  llvm::detail::DoubleAPFloat::DoubleAPFloat(&v624, (const llvm::detail::DoubleAPFloat *)((char *)&__src + 8));
                }
                else {
                  llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&v624, (const llvm::detail::IEEEFloat *)((char *)&__src + 8));
                }
                sub_1CBFC6BD8((uint64_t)&v623, 3);
                if (*((_UNKNOWN **)&__src + 1) == &unk_1CFB2E344) {
                  llvm::detail::DoubleAPFloat::DoubleAPFloat(&v620[8], (const llvm::detail::DoubleAPFloat *)((char *)&__src + 8));
                }
                else {
                  llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&v620[8], (const llvm::detail::IEEEFloat *)((char *)&__src + 8));
                }
                sub_1CB9C2E3C((uint64_t)v620, (uint64_t)&v623, 1);
                uint64_t v513 = *((void *)&__src + 1);
                if (*((_UNKNOWN **)&__src + 1) == &unk_1CFB2E344) {
                  llvm::detail::DoubleAPFloat::DoubleAPFloat(&v617.__r_.__value_.__l.__size_, (uint64_t)&unk_1CFB2E344);
                }
                v617.__r_.__value_.__l.__size_ = *((void *)&__src + 1);
                if ((*(_DWORD *)(*((void *)&__src + 1) + 8) + 64) >= 0x80) {
                  operator new[]();
                }
                char v619 = v619 & 0xF0 | 2;
                int v514 = *(_DWORD *)(*((void *)&__src + 1) + 8);
                if ((v514 - 64) < 0xFFFFFF80)
                {
                  std::string::size_type v563 = v617.__r_.__value_.__r.__words[2];
                  *(void *)v617.__r_.__value_.__r.__words[2] = 0;
                  bzero((void *)(v563 + 8), 8 * (((v514 + 64) >> 6) - 2) + 8);
                  int v515 = (std::string::size_type *)v617.__r_.__value_.__r.__words[2];
                }
                else
                {
                  int v515 = &v617.__r_.__value_.__r.__words[2];
                  v617.__r_.__value_.__r.__words[2] = 0;
                }
                int v618 = *(_DWORD *)(v513 + 8) - 1;
                *int v515 = 1;
                llvm::detail::IEEEFloat::normalize((llvm::detail::IEEEFloat *)&v617.__r_.__value_.__r.__words[1], 1, 0);
                sub_1CD3CFB7C((uint64_t)&v617, 1);
                v516 = *(llvm::ConstantFP **)v583;
                sub_1CD472298((uint64_t)v620, (uint64_t)&v617, (uint64_t)v612);
                int v21 = llvm::ConstantFP::get(v516, (llvm::LLVMContext *)v612, v517);
                if (v613 == (_DWORD *)&unk_1CFB2E344)
                {
                  sub_1CB845718((uint64_t *)&v614);
                }
                else if ((v613[2] - 64) <= 0xFFFFFF7F && v614)
                {
                  MEMORY[0x1D25D9CB0](v614, 0x1000C8000313F17);
                }
                if ((_UNKNOWN *)v617.__r_.__value_.__l.__size_ == &unk_1CFB2E344)
                {
                  sub_1CB845718((uint64_t *)&v617.__r_.__value_.__r.__words[2]);
                }
                else if ((*(_DWORD *)(v617.__r_.__value_.__l.__size_ + 8) - 64) <= 0xFFFFFF7F {
                       && v617.__r_.__value_.__r.__words[2])
                }
                {
                  MEMORY[0x1D25D9CB0](v617.__r_.__value_.__r.__words[2], 0x1000C8000313F17);
                }
                if (*(_UNKNOWN **)&v620[8] == &unk_1CFB2E344)
                {
                  sub_1CB845718((uint64_t *)&v620[16]);
                }
                else if ((*(_DWORD *)(*(void *)&v620[8] + 8) - 64) <= 0xFFFFFF7F {
                       && *(void *)&v620[16])
                }
                {
                  MEMORY[0x1D25D9CB0](*(void *)&v620[16], 0x1000C8000313F17);
                }
                uint64_t v518 = v624;
                if ((_UNKNOWN *)v624 != &unk_1CFB2E344)
                {
LABEL_1693:
                  if ((*(_DWORD *)(v518 + 8) - 64) <= 0xFFFFFF7F)
                  {
                    unint64_t v266 = *((void *)&v624 + 1);
                    if (*((void *)&v624 + 1)) {
                      goto LABEL_559;
                    }
                  }
                  goto LABEL_1709;
                }
LABEL_1696:
                sub_1CB845718((uint64_t *)&v624 + 1);
                goto LABEL_1709;
              }
LABEL_1153:
              if (*v179 == &unk_1CFB2E344) {
                __int8 v481 = *(unsigned char *)(*(void *)&v19[5] + 28);
              }
              else {
                __int8 v481 = v19[6].i8[4];
              }
              if ((v481 & 7u) <= 1)
              {
                uint64_t v482 = *(void *)(a9 + 40);
                if (*(char *)(v482 + 239) < 0) {
                  sub_1CB8BDF7C((uint64_t)&v617, *(const void **)(v482 + 216), *(void *)(v482 + 224));
                }
                else {
                  std::string v617 = *(std::string *)(v482 + 216);
                }
                if (!std::string::compare(&v617, 0, 4uLL, "agx1"))
                {
                  int v483 = 27;
                }
                else if (!std::string::compare(&v617, 0, 4uLL, "agx2"))
                {
                  int v483 = 28;
                }
                else if (!std::string::compare(&v617, 0, 4uLL, "agx3"))
                {
                  int v483 = 29;
                }
                else
                {
                  int v483 = 0;
                }
                if (SHIBYTE(v617.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v617.__r_.__value_.__l.__data_);
                }
                if ((v483 - 27) > 2) {
                  goto LABEL_370;
                }
              }
              size_t v579 = (llvm::detail::IEEEFloat *)&v19[3];
              if ((int)v12 <= 279)
              {
                if ((int)v12 <= 174)
                {
                  if ((int)v12 <= 74)
                  {
                    if (v12 == 51) {
                      goto LABEL_1270;
                    }
                  }
                  else
                  {
                    if (v12 == 75) {
                      goto LABEL_1776;
                    }
                    if (v12 == 76) {
                      goto LABEL_1692;
                    }
                  }
                }
                else if ((int)v12 > 252)
                {
                  switch(v12)
                  {
                    case 0xFD:
                      v488 = (double (*)(double))sub_1CBFC706C;
                      goto LABEL_1777;
                    case 0x105:
                      v488 = (double (*)(double))sub_1CBFC703C;
                      goto LABEL_1777;
                    case 0x111:
LABEL_1219:
                      v488 = (double (*)(double))MEMORY[0x1E4F14A50];
                      goto LABEL_1777;
                  }
                }
                else
                {
                  switch(v12)
                  {
                    case 0xAF:
                      goto LABEL_1770;
                    case 0xB0:
                      goto LABEL_1752;
                    case 0xB1:
LABEL_1185:
                      v488 = (double (*)(double))j__log2;
LABEL_1777:
                      uint64_t v522 = sub_1CBFC5054(v488, v579, v583);
                      goto LABEL_1708;
                  }
                }
LABEL_1278:
                if (!a7) {
                  goto LABEL_370;
                }
                v523 = sub_1CC154CDC(__s1, v14);
                if (!v524) {
                  goto LABEL_370;
                }
                int v525 = v523;
                size_t v526 = v524;
                v527 = &llvm::TargetLibraryInfoImpl::StandardNames;
                unint64_t v528 = 468;
                do
                {
                  unint64_t v529 = &v527[2 * (v528 >> 1)];
                  size_t v530 = (size_t)v529[1];
                  if (v526 >= v530) {
                    size_t v531 = (size_t)v529[1];
                  }
                  else {
                    size_t v531 = v526;
                  }
                  if (v531 && (int v532 = memcmp(*v529, v525, v531)) != 0)
                  {
                    int v533 = (v532 >> 31) | 1;
                  }
                  else
                  {
                    if (v530 < v526) {
                      int v533 = -1;
                    }
                    else {
                      int v533 = 1;
                    }
                    if (v530 == v526) {
                      int v533 = 0;
                    }
                  }
                  if (v533 == -1) {
                    v528 += ~(v528 >> 1);
                  }
                  else {
                    v528 >>= 1;
                  }
                  if (v533 == -1) {
                    v527 = v529 + 2;
                  }
                }
                while (v528);
                if (v527 == &llvm::TargetLibraryInfoImpl::StandardNames + 936
                  || v527[1] != (char *)v526
                  || memcmp(*v527, v525, v526))
                {
                  goto LABEL_370;
                }
                int v21 = 0;
                unint64_t v534 = (char *)v527 - (char *)&llvm::TargetLibraryInfoImpl::StandardNames;
                unint64_t v535 = (unint64_t)((char *)v527 - (char *)&llvm::TargetLibraryInfoImpl::StandardNames) >> 4;
                if ((int)v535 <= 206)
                {
                  if ((int)v535 <= 112)
                  {
                    switch((int)v535)
                    {
                      case 'G':
                      case 'H':
                        goto LABEL_1659;
                      case 'I':
                      case 'J':
                      case 'K':
                      case 'L':
                      case 'M':
                      case 'N':
                      case 'O':
                      case 'P':
                      case 'Q':
                      case 'R':
                      case 'U':
                      case 'X':
                      case 'Y':
                      case 'Z':
                      case '[':
                      case '\\':
                      case '_':
                      case 'b':
                        goto LABEL_1709;
                      case 'S':
                      case 'T':
                        goto LABEL_1690;
                      case 'V':
                      case 'W':
                        goto LABEL_1774;
                      case ']':
                      case '^':
                        goto LABEL_1675;
                      case 'a':
                        goto LABEL_1698;
                      case 'c':
                      case 'd':
                        goto LABEL_1763;
                      default:
                        if ((v535 - 54) < 2) {
                          goto LABEL_1683;
                        }
                        if ((v535 - 60) >= 2) {
                          goto LABEL_1709;
                        }
                        goto LABEL_1716;
                    }
                  }
                  if ((int)v535 <= 158)
                  {
                    if ((int)v535 <= 148)
                    {
                      if ((v535 - 113) < 2)
                      {
LABEL_1686:
                        if (((*(void *)(a7[1] + 8 * ((v534 >> 10) & 0x3FFFFFF)) >> v535) & 1) == 0
                          && ((*(unsigned __int8 *)(*a7 + ((v534 >> 6) & 0x3FFFFFFF)) >> (2 * (v535 & 3))) & 3) != 0)
                        {
                          v488 = (double (*)(double))MEMORY[0x1E4F14A58];
                          goto LABEL_1777;
                        }
                      }
                      else
                      {
                        if ((v535 - 142) >= 2) {
                          goto LABEL_1709;
                        }
LABEL_1683:
                        if (((*(void *)(a7[1] + 8 * ((v534 >> 10) & 0x3FFFFFF)) >> v535) & 1) == 0
                          && ((*(unsigned __int8 *)(*a7 + ((v534 >> 6) & 0x3FFFFFFF)) >> (2 * (v535 & 3))) & 3) != 0)
                        {
                          v488 = (double (*)(double))MEMORY[0x1E4F14608];
                          goto LABEL_1777;
                        }
                      }
                      goto LABEL_370;
                    }
                    if ((v535 - 149) < 2)
                    {
LABEL_1716:
                      if (((*(void *)(a7[1] + 8 * ((v534 >> 10) & 0x3FFFFFF)) >> v535) & 1) == 0
                        && ((*(unsigned __int8 *)(*a7 + ((v534 >> 6) & 0x3FFFFFFF)) >> (2 * (v535 & 3))) & 3) != 0)
                      {
                        v488 = (double (*)(double))MEMORY[0x1E4F14618];
                        goto LABEL_1777;
                      }
                      goto LABEL_370;
                    }
                    if (v535 != 155) {
                      goto LABEL_1709;
                    }
                  }
                  else
                  {
                    if ((int)v535 > 187)
                    {
                      if ((v535 - 188) >= 2)
                      {
                        if ((v535 - 190) < 2)
                        {
LABEL_1659:
                          if (((*(void *)(a7[1] + 8 * ((v534 >> 10) & 0x3FFFFFF)) >> v535) & 1) == 0
                            && ((*(unsigned __int8 *)(*a7 + ((v534 >> 6) & 0x3FFFFFFF)) >> (2 * (v535 & 3))) & 3) != 0)
                          {
                            v488 = (double (*)(double))MEMORY[0x1E4F14748];
                            goto LABEL_1777;
                          }
                          goto LABEL_370;
                        }
                        if (v535 != 203) {
                          goto LABEL_1709;
                        }
                        goto LABEL_1774;
                      }
                      if (((*(void *)(a7[1] + 8 * ((v534 >> 10) & 0x3FFFFFF)) >> v535) & 1) != 0
                        || ((*(unsigned __int8 *)(*a7 + ((v534 >> 6) & 0x3FFFFFFF)) >> (2 * (v535 & 3))) & 3) == 0)
                      {
                        goto LABEL_370;
                      }
LABEL_1270:
                      v488 = (double (*)(double))MEMORY[0x1E4F14740];
                      goto LABEL_1777;
                    }
                    if ((v535 - 178) < 2)
                    {
                      if (((*(void *)(a7[1] + 8 * ((v534 >> 10) & 0x3FFFFFF)) >> v535) & 1) != 0
                        || ((*(unsigned __int8 *)(*a7 + ((v534 >> 6) & 0x3FFFFFFF)) >> (2 * (v535 & 3))) & 3) == 0)
                      {
                        goto LABEL_370;
                      }
LABEL_1704:
                      uint64_t v268 = 2;
                      goto LABEL_1705;
                    }
                    if (v535 != 159) {
                      goto LABEL_1709;
                    }
                  }
                  if (((*(void *)(a7[1] + 8 * ((v534 >> 10) & 0x3FFFFFF)) >> v535) & 1) == 0
                    && ((*(unsigned __int8 *)(*a7 + ((v534 >> 6) & 0x3FFFFFFF)) >> (2 * (v535 & 3))) & 3) != 0)
                  {
                    v488 = (double (*)(double))MEMORY[0x1E4F14628];
                    goto LABEL_1777;
                  }
                  goto LABEL_370;
                }
                if ((int)v535 > 334)
                {
                  switch((int)v535)
                  {
                    case 370:
                    case 371:
                      goto LABEL_1730;
                    case 372:
                    case 373:
                    case 375:
                    case 376:
                    case 377:
                    case 379:
                    case 380:
                    case 381:
                    case 382:
                    case 383:
                    case 388:
                    case 389:
                    case 390:
                    case 391:
                    case 392:
                      goto LABEL_1709;
                    case 374:
                    case 378:
                      if (((*(void *)(a7[1] + 8 * ((v534 >> 10) & 0x3FFFFFF)) >> v535) & 1) == 0
                        && ((*(unsigned __int8 *)(*a7 + ((v534 >> 6) & 0x3FFFFFFF)) >> (2 * (v535 & 3))) & 3) != 0)
                      {
                        goto LABEL_1647;
                      }
                      goto LABEL_370;
                    case 384:
                    case 385:
                      if (((*(void *)(a7[1] + 8 * ((v534 >> 10) & 0x3FFFFFF)) >> v535) & 1) != 0
                        || ((*(unsigned __int8 *)(*a7 + ((v534 >> 6) & 0x3FFFFFFF)) >> (2 * (v535 & 3))) & 3) == 0)
                      {
                        goto LABEL_370;
                      }
                      goto LABEL_1219;
                    case 386:
                    case 387:
                      goto LABEL_1686;
                    case 393:
                    case 394:
                      v574 = v19 + 3;
                      if (*v179 == &unk_1CFB2E344) {
                        v574 = (int8x8_t *)v19[5];
                      }
                      if ((v574[3].i8[4] & 8) == 0
                        && ((*(void *)(a7[1] + 8 * ((v534 >> 10) & 0x3FFFFFF)) >> v535) & 1) == 0
                        && ((*(unsigned __int8 *)(*a7 + ((v534 >> 6) & 0x3FFFFFFF)) >> (2 * (v535 & 3))) & 3) != 0)
                      {
                        goto LABEL_1741;
                      }
                      goto LABEL_370;
                    default:
                      char v569 = v535 + 77;
                      if ((v535 - 435) > 0xB) {
                        goto LABEL_1729;
                      }
                      if (((1 << v569) & 3) != 0)
                      {
                        if (((*(void *)(a7[1] + 8 * ((v534 >> 10) & 0x3FFFFFF)) >> v535) & 1) == 0
                          && ((*(unsigned __int8 *)(*a7 + ((v534 >> 6) & 0x3FFFFFFF)) >> (2 * (v535 & 3))) & 3) != 0)
                        {
                          v488 = (double (*)(double))MEMORY[0x1E4F14AB8];
                          goto LABEL_1777;
                        }
                      }
                      else if (((1 << v569) & 0xC) != 0)
                      {
                        if (((*(void *)(a7[1] + 8 * ((v534 >> 10) & 0x3FFFFFF)) >> v535) & 1) == 0
                          && ((*(unsigned __int8 *)(*a7 + ((v534 >> 6) & 0x3FFFFFFF)) >> (2 * (v535 & 3))) & 3) != 0)
                        {
                          v488 = (double (*)(double))MEMORY[0x1E4F14AC0];
                          goto LABEL_1777;
                        }
                      }
                      else if (((1 << v569) & 0xC00) != 0)
                      {
                        if (((*(void *)(a7[1] + 8 * ((v534 >> 10) & 0x3FFFFFF)) >> v535) & 1) == 0
                          && ((*(unsigned __int8 *)(*a7 + ((v534 >> 6) & 0x3FFFFFFF)) >> (2 * (v535 & 3))) & 3) != 0)
                        {
                          goto LABEL_1054;
                        }
                      }
                      else
                      {
LABEL_1729:
                        if ((v535 - 335) >= 2) {
                          goto LABEL_1709;
                        }
LABEL_1730:
                        if (((*(void *)(a7[1] + 8 * ((v534 >> 10) & 0x3FFFFFF)) >> v535) & 1) == 0
                          && ((*(unsigned __int8 *)(*a7 + ((v534 >> 6) & 0x3FFFFFFF)) >> (2 * (v535 & 3))) & 3) != 0)
                        {
                          goto LABEL_1028;
                        }
                      }
                      break;
                  }
                  goto LABEL_370;
                }
                if ((int)v535 <= 299)
                {
                  if ((int)v535 > 214)
                  {
                    if ((v535 - 215) < 2)
                    {
                      if (((*(void *)(a7[1] + 8 * ((v534 >> 10) & 0x3FFFFFF)) >> v535) & 1) == 0
                        && ((*(unsigned __int8 *)(*a7 + ((v534 >> 6) & 0x3FFFFFFF)) >> (2 * (v535 & 3))) & 3) != 0)
                      {
                        uint64_t v572 = (uint64_t)v585;
                        uint64_t v573 = &__src;
                        if (*((_UNKNOWN **)&__src + 1) == &unk_1CFB2E344) {
                          uint64_t v573 = v585;
                        }
                        if ((*((unsigned char *)v573 + 28) & 8) != 0)
                        {
                          if (*((_UNKNOWN **)&__src + 1) == &unk_1CFB2E344)
                          {
                            if (*((_UNKNOWN **)v585 + 1) == &unk_1CFB2E344)
                            {
                              llvm::detail::DoubleAPFloat::changeSign((llvm::detail::DoubleAPFloat *)((char *)v585 + 8));
                              uint64_t v572 = (uint64_t)v585;
                            }
                            else
                            {
                              *((unsigned char *)v585 + 28) ^= 8u;
                            }
                            if (*(_UNKNOWN **)(v572 + 40) == &unk_1CFB2E344) {
                              llvm::detail::DoubleAPFloat::changeSign((llvm::detail::DoubleAPFloat *)(v572 + 40));
                            }
                            else {
                              *(unsigned char *)(v572 + 60) ^= 8u;
                            }
                          }
                          else
                          {
                            v587 ^= 8u;
                          }
                        }
                        goto LABEL_1706;
                      }
                    }
                    else
                    {
                      if ((v535 - 234) >= 2) {
                        goto LABEL_1709;
                      }
                      if (((*(void *)(a7[1] + 8 * ((v534 >> 10) & 0x3FFFFFF)) >> v535) & 1) == 0
                        && ((*(unsigned __int8 *)(*a7 + ((v534 >> 6) & 0x3FFFFFFF)) >> (2 * (v535 & 3))) & 3) != 0)
                      {
LABEL_567:
                        uint64_t v268 = 3;
LABEL_1705:
                        sub_1CBFC6BD8((uint64_t)&__src, v268);
LABEL_1706:
                        uint64_t v456 = *(llvm::ConstantFP **)v583;
LABEL_1707:
                        uint64_t v522 = llvm::ConstantFP::get(v456, (llvm::LLVMContext *)&__src, v181);
                        goto LABEL_1708;
                      }
                    }
                    goto LABEL_370;
                  }
                  if ((v535 - 207) >= 2)
                  {
                    if (v535 != 210) {
                      goto LABEL_1709;
                    }
LABEL_1774:
                    if (((*(void *)(a7[1] + 8 * ((v534 >> 10) & 0x3FFFFFF)) >> v535) & 1) != 0
                      || ((*(unsigned __int8 *)(*a7 + ((v534 >> 6) & 0x3FFFFFFF)) >> (2 * (v535 & 3))) & 3) == 0)
                    {
                      goto LABEL_370;
                    }
LABEL_1776:
                    v488 = (double (*)(double))MEMORY[0x1E4F147F8];
                    goto LABEL_1777;
                  }
LABEL_1690:
                  if (((*(void *)(a7[1] + 8 * ((v534 >> 10) & 0x3FFFFFF)) >> v535) & 1) != 0
                    || ((*(unsigned __int8 *)(*a7 + ((v534 >> 6) & 0x3FFFFFFF)) >> (2 * (v535 & 3))) & 3) == 0)
                  {
                    goto LABEL_370;
                  }
LABEL_1692:
                  LODWORD(v624) = 64;
                  unint64_t v623 = 0x4000000000000000;
                  llvm::detail::IEEEFloat::initFromDoubleAPInt((llvm::detail::IEEEFloat *)v620, (const llvm::APInt **)&v623);
                  long long v624 = *(_OWORD *)v620;
                  int v625 = *(_DWORD *)&v620[16];
                  char v626 = v620[20] & 0xF;
                  int v21 = sub_1CBFC510C(MEMORY[0x1E4F14A28], (llvm::APFloat *)&v623, v579, v583);
                  uint64_t v518 = v624;
                  if ((_UNKNOWN *)v624 != &unk_1CFB2E344) {
                    goto LABEL_1693;
                  }
                  goto LABEL_1696;
                }
                if ((int)v535 > 306)
                {
                  if ((v535 - 307) < 2)
                  {
LABEL_1698:
                    if (*v179 == &unk_1CFB2E344)
                    {
                      __int8 v571 = *(unsigned char *)(*(void *)&v19[5] + 28);
                      if ((v571 & 8) != 0) {
                        goto LABEL_370;
                      }
                    }
                    else
                    {
                      __int8 v571 = v19[6].i8[4];
                      if ((v571 & 8) != 0) {
                        goto LABEL_370;
                      }
                    }
                    if ((v571 & 7) != 3
                      && ((*(void *)(a7[1] + 8 * ((v534 >> 10) & 0x3FFFFFF)) >> v535) & 1) == 0
                      && ((*(unsigned __int8 *)(*a7 + ((v534 >> 6) & 0x3FFFFFFF)) >> (2 * (v535 & 3))) & 3) != 0)
                    {
                      goto LABEL_1185;
                    }
LABEL_370:
                    int v21 = 0;
                    goto LABEL_1709;
                  }
                  if (v535 != 313) {
                    goto LABEL_1709;
                  }
                }
                else
                {
                  if ((v535 - 301) < 2)
                  {
LABEL_1675:
                    if (*v179 == &unk_1CFB2E344)
                    {
                      __int8 v570 = *(unsigned char *)(*(void *)&v19[5] + 28);
                      if ((v570 & 8) != 0) {
                        goto LABEL_370;
                      }
                    }
                    else
                    {
                      __int8 v570 = v19[6].i8[4];
                      if ((v570 & 8) != 0) {
                        goto LABEL_370;
                      }
                    }
                    if ((v570 & 7) == 3
                      || ((*(void *)(a7[1] + 8 * ((v534 >> 10) & 0x3FFFFFF)) >> v535) & 1) != 0
                      || ((*(unsigned __int8 *)(*a7 + ((v534 >> 6) & 0x3FFFFFFF)) >> (2 * (v535 & 3))) & 3) == 0)
                    {
                      goto LABEL_370;
                    }
LABEL_1752:
                    v488 = (double (*)(double))MEMORY[0x1E4F14948];
                    goto LABEL_1777;
                  }
                  if (v535 != 300) {
                    goto LABEL_1709;
                  }
                }
LABEL_1763:
                if (*v179 == &unk_1CFB2E344)
                {
                  __int8 v575 = *(unsigned char *)(*(void *)&v19[5] + 28);
                  if ((v575 & 8) != 0) {
                    goto LABEL_370;
                  }
                }
                else
                {
                  __int8 v575 = v19[6].i8[4];
                  if ((v575 & 8) != 0) {
                    goto LABEL_370;
                  }
                }
                if ((v575 & 7) == 3
                  || ((*(void *)(a7[1] + 8 * ((v534 >> 10) & 0x3FFFFFF)) >> v535) & 1) != 0
                  || ((*(unsigned __int8 *)(*a7 + ((v534 >> 6) & 0x3FFFFFFF)) >> (2 * (v535 & 3))) & 3) == 0)
                {
                  goto LABEL_370;
                }
LABEL_1770:
                v488 = (double (*)(double))MEMORY[0x1E4F14940];
                goto LABEL_1777;
              }
              if ((int)v12 > 2014)
              {
                if ((int)v12 > 2622)
                {
                  if (v12 != 2623)
                  {
                    if (v12 != 2877 && v12 != 3540) {
                      goto LABEL_1278;
                    }
                    double v498 = sub_1CBFC6BF8((void **)v19);
                    int v21 = 0;
                    if (v498 < -256.0 || v498 > 256.0) {
                      goto LABEL_1709;
                    }
                    if (v498 * 4.0 == floor(v498 * 4.0))
                    {
                      int v499 = (int)(v498 * 4.0);
                      if (v12 == 2877) {
                        LOBYTE(v499) = v499 + 1;
                      }
                      double v500 = dbl_1CFAC3150[v499 & 3];
                    }
                    else
                    {
                      double v540 = (v498 + v498) * 3.14159265;
                      if (v12 == 2877) {
                        double v500 = cos(v540);
                      }
                      else {
                        double v500 = sin(v540);
                      }
                    }
                    uint64_t v522 = sub_1CBFC6D3C(v583, v500);
LABEL_1708:
                    int v21 = v522;
                    goto LABEL_1709;
                  }
                }
                else if ((v12 - 2015) >= 2)
                {
                  if (v12 != 2131) {
                    goto LABEL_1278;
                  }
                  goto LABEL_1267;
                }
                v488 = sub_1CBFC7004;
                goto LABEL_1777;
              }
              if ((int)v12 <= 1829)
              {
                if (v12 == 280)
                {
LABEL_1741:
                  v488 = (double (*)(double))MEMORY[0x1E4F14A60];
                  goto LABEL_1777;
                }
                if (v12 == 1827)
                {
                  v488 = (double (*)(double))sub_1CBFC7014;
                  goto LABEL_1777;
                }
                goto LABEL_1278;
              }
              if (v12 == 1830)
              {
                double v520 = sub_1CBFC6BF8((void **)v19);
                double v521 = 0.0;
                if (v520 <= 0.0)
                {
LABEL_1276:
                  uint64_t v522 = llvm::ConstantFP::get(*(llvm::ConstantFP ***)v19, v519, v521);
                  goto LABEL_1708;
                }
LABEL_1274:
                double v521 = v520;
                if (v520 > 1.0) {
                  double v521 = 1.0;
                }
                goto LABEL_1276;
              }
              if (v12 != 1851) {
                goto LABEL_1278;
              }
LABEL_1267:
              double v520 = sub_1CBFC6BF8((void **)v19);
              double v521 = 0.0;
              if (v520 <= 0.0) {
                goto LABEL_1276;
              }
              goto LABEL_1274;
            }
            if (v12 == 259)
            {
LABEL_1647:
              uint64_t v268 = 4;
              goto LABEL_1705;
            }
            if (v12 != 260) {
              goto LABEL_1153;
            }
          }
          else
          {
            if ((int)v12 <= 202)
            {
              if (v12 == 139)
              {
                uint64_t v453 = (uint64_t)v585;
                v454 = &__src;
                if (*((_UNKNOWN **)&__src + 1) == &unk_1CFB2E344) {
                  v454 = v585;
                }
                v455 = (llvm::ConstantFP **)v583;
                if ((*((unsigned char *)v454 + 28) & 8) != 0)
                {
                  if (*((_UNKNOWN **)&__src + 1) == &unk_1CFB2E344)
                  {
                    if (*((_UNKNOWN **)v585 + 1) == &unk_1CFB2E344)
                    {
                      llvm::detail::DoubleAPFloat::changeSign((llvm::detail::DoubleAPFloat *)((char *)v585 + 8));
                      uint64_t v453 = (uint64_t)v585;
                    }
                    else
                    {
                      *((unsigned char *)v585 + 28) ^= 8u;
                    }
                    if (*(_UNKNOWN **)(v453 + 40) == &unk_1CFB2E344) {
                      llvm::detail::DoubleAPFloat::changeSign((llvm::detail::DoubleAPFloat *)(v453 + 40));
                    }
                    else {
                      *(unsigned char *)(v453 + 60) ^= 8u;
                    }
                    v455 = (llvm::ConstantFP **)v583;
                  }
                  else
                  {
                    v587 ^= 8u;
                  }
                }
                uint64_t v456 = *v455;
                goto LABEL_1707;
              }
              if (v12 == 140) {
                goto LABEL_567;
              }
              goto LABEL_1153;
            }
            if (v12 != 203 && v12 != 258) {
              goto LABEL_1153;
            }
          }
LABEL_1028:
          uint64_t v268 = 1;
          goto LABEL_1705;
        }
        int v21 = 0;
        if ((int)v12 <= 16)
        {
          if (v12 == 8)
          {
            unint64_t v147 = *(llvm::ConstantInt **)a4;
            llvm::APInt::reverseBits((unsigned int *)&v19[3], (llvm::APInt *)&__src);
          }
          else
          {
            if (v12 != 9) {
              return v21;
            }
            unint64_t v147 = *(llvm::ConstantInt **)a4;
            llvm::APInt::byteSwap((llvm::APInt *)&v19[3], (uint64_t)&__src);
          }
          uint64_t v129 = (llvm::Constant *)llvm::ConstantInt::get(v147, (llvm::LLVMContext *)&__src, v148);
          goto LABEL_428;
        }
        if (v12 != 17)
        {
          if (v12 != 53) {
            return v21;
          }
          uint64_t v183 = v19[4].u32[0];
          if (v183 > 0x40)
          {
            unsigned __int32 v185 = 0;
            unint64_t v272 = (unint64_t)(v183 + 63) >> 6;
            size_t v273 = (int8x8_t *)v19[3];
            do
            {
              int8x8_t v274 = *v273++;
              uint8x8_t v275 = (uint8x8_t)vcnt_s8(v274);
              v275.i16[0] = vaddlv_u8(v275);
              v185 += v275.i32[0];
              --v272;
            }
            while (v272);
          }
          else
          {
            uint8x8_t v184 = (uint8x8_t)vcnt_s8(v19[3]);
            v184.i16[0] = vaddlv_u8(v184);
            unsigned __int32 v185 = v184.i32[0];
          }
          unint64_t v276 = v185;
          uint64_t v277 = (llvm::ConstantInt *)a4;
          return (const llvm::detail::DoubleAPFloat *)llvm::ConstantInt::get(v277, v276, 0);
        }
        uint64_t v217 = a4;
        llvm::detail::IEEEFloat::initFromHalfAPInt((llvm::detail::IEEEFloat *)((char *)&__src + 8), (const llvm::APInt **)&v19[3]);
        size_t v219 = (llvm::ConstantFP **)v217;
        if (*(unsigned char *)(v217 + 8) == 2)
        {
          uint64_t v220 = &unk_1CFB2E308;
        }
        else
        {
          uint64_t v220 = &unk_1CFB2E2E0;
          switch(*(unsigned char *)(v217 + 8))
          {
            case 1:
              uint64_t v220 = &unk_1CFB2E2F4;
              break;
            case 2:
              __break(1u);
              goto LABEL_1566;
            case 3:
LABEL_1566:
              uint64_t v220 = &unk_1CFB2E31C;
              break;
            case 4:
              size_t v561 = llvm::APFloatBase::x87DoubleExtended(v218);
              goto LABEL_1569;
            case 5:
              size_t v561 = llvm::APFloatBase::IEEEquad(v218);
LABEL_1569:
              uint64_t v220 = v561;
              break;
            case 6:
              uint64_t v220 = &unk_1CFB2E344;
              break;
            default:
              break;
          }
        }
        int v221 = (std::string *)&__src;
        llvm::APFloat::convert((uint64_t)&__src, v220, 1, &v623);
        int v21 = llvm::ConstantFP::get(*v219, (llvm::LLVMContext *)&__src, v222);
        uint64_t v192 = *((void *)&__src + 1);
        if (*((_UNKNOWN **)&__src + 1) == &unk_1CFB2E344) {
          goto LABEL_1368;
        }
LABEL_1710:
        if ((*(_DWORD *)(v192 + 8) - 64) > 0xFFFFFF7F || !v585) {
          return v21;
        }
        goto LABEL_1359;
      }
      if (*(void *)__s1 != 0x766E6F632E726961 || *(void *)(__s1 + 3) != 0x747265766E6F632ELL)
      {
        if ((unint64_t)a2 >= 0x29)
        {
          uint64_t v17 = a4;
          int v18 = memcmp(__s1, "air.normalize_function_constant_predicate", 0x29uLL);
          a4 = v17;
          if (!v18)
          {
            int v21 = (llvm::Constant *)*v11;
            if ((*v11)[2].u8[0] - 11 > 1) {
              return v21;
            }
            goto LABEL_339;
          }
        }
        goto LABEL_11;
      }
      int v21 = *a5;
      unint64_t v623 = (unint64_t)__s1;
      *(void *)&long long v624 = a2;
      if ((*((unsigned char *)v21 + 16) & 0xFE) != 0x10) {
        return 0;
      }
      unsigned int v134 = (unsigned __int8 *)a4;
      *(void *)&long long __src = &v585;
      *((void *)&__src + 1) = 0x800000000;
      llvm::StringRef::split(&v623, (uint64_t)&__src, ".", 1uLL, 8, 1);
      if (DWORD2(__src) != 6)
      {
        int v21 = 0;
        goto LABEL_882;
      }
      BOOL v135 = *(void *)(__src + 72) != 1 || **(unsigned __int8 **)(__src + 64) != 117;
      int v214 = v134;
      if (*(void *)(__src + 40) == 1)
      {
        if (**(unsigned char **)(__src + 32) == 117) {
          uint64_t v215 = 41;
        }
        else {
          uint64_t v215 = 42;
        }
      }
      else
      {
        uint64_t v215 = 42;
      }
      if (*(unsigned char *)(*(void *)v21 + 8))
      {
        if (*(unsigned char *)(*(void *)v21 + 8) != 1 || v134[8])
        {
LABEL_447:
          unsigned int v225 = v214[8];
          if (*((unsigned char *)v21 + 16) == 16)
          {
            if (v225 <= 6)
            {
              if (v135) {
                uint64_t v226 = 44;
              }
              else {
                uint64_t v226 = 43;
              }
              goto LABEL_880;
            }
            unsigned int PrimitiveSizeInBits = llvm::Type::getPrimitiveSizeInBits((llvm::Type *)v214);
            if (v257 == 1) {
            unsigned int v261 = llvm::Type::getPrimitiveSizeInBits(*(llvm::Type **)v21);
            }
            if (v259 == 1) {
            if (PrimitiveSizeInBits == v261)
            }
              goto LABEL_882;
            if (PrimitiveSizeInBits != 1)
            {
              int v214 = v134;
              if (v135) {
                unsigned int v388 = 40;
              }
              else {
                unsigned int v388 = 39;
              }
              if (PrimitiveSizeInBits <= v261) {
                uint64_t v226 = 38;
              }
              else {
                uint64_t v226 = v388;
              }
              goto LABEL_880;
            }
            NullValue = llvm::Constant::getNullValue(*(llvm::Constant **)v21, (llvm::Type *)v259, v260);
            uint64_t ICmp = (uint64_t)llvm::ConstantExpr::getICmp((llvm::ConstantExpr *)0x21, v21, NullValue, 0, v263);
          }
          else
          {
            unint64_t v229 = llvm::Type::getPrimitiveSizeInBits((llvm::Type *)v214);
            if (v225 != 13)
            {
              if (v227 == 1) {
              unsigned int v265 = llvm::Type::getPrimitiveSizeInBits(*(llvm::Type **)v21);
              }
              if (v264 == 1) {
              if (v229 == v265)
              }
                goto LABEL_882;
              int v214 = v134;
              if (v229 <= v265) {
                uint64_t v226 = 45;
              }
              else {
                uint64_t v226 = 46;
              }
              goto LABEL_880;
            }
            if (v227 == 1) {
            if (v229 != 1)
            }
            {
              int v214 = v134;
              uint64_t v226 = v215;
LABEL_880:
              uint64_t ICmp = (uint64_t)llvm::ConstantExpr::getCast((llvm::ConstantExpr *)v226, v21, (llvm::Constant ***)v214, 0);
              goto LABEL_881;
            }
            size_t v230 = llvm::Constant::getNullValue(*(llvm::Constant **)v21, (llvm::Type *)v227, v228);
            uint64_t ICmp = llvm::ConstantExpr::getFCmp((llvm::ConstantExpr *)0xE, (uint64_t ***)v21, v230, 0);
          }
LABEL_881:
          int v21 = (llvm::Constant *)ICmp;
LABEL_882:
          if ((long long **)__src != &v585) {
            free((void *)__src);
          }
          return v21;
        }
      }
      else if (v134[8] != 1)
      {
        goto LABEL_447;
      }
      int v224 = sub_1CC56C0C0((llvm *)0x2E, v21, (llvm::Constant *)(**(void **)v134 + 1672), 0);
      int v214 = v134;
      int v21 = v224;
      goto LABEL_447;
    }
    unsigned int v22 = *(unsigned __int8 *)(a4 + 8);
    if (v22 <= 6 && (a3 - 192) <= 0xA && ((1 << ((_BYTE)a3 + 64)) & 0x603) != 0)
    {
      uint64_t v9 = *a5;
      unsigned int v23 = *((unsigned __int8 *)*a5 + 16) - 11;
      int v21 = v23 >= 2 ? *a5 : a5[1];
      BOOL v24 = v23 >= 2 && *((unsigned __int8 *)a5[1] + 16) - 11 >= 2;
      if (!v24) {
        return v21;
      }
    }
    uint64_t v25 = *a5;
    unsigned int v26 = *((unsigned __int8 *)*a5 + 16);
    if (*a5 && v26 == 17)
    {
      uint64_t v27 = (char *)v25 + 24;
      int v28 = a5[1];
      int v29 = *((unsigned __int8 *)v28 + 16);
      if (v28 && v29 == 17)
      {
        if (*(void *)v28 != *(void *)v25) {
          return 0;
        }
        size_t v580 = (llvm::ConstantFP **)a4;
        BOOL v30 = sub_1CBFC7338(a8);
        if (a8 && v30)
        {
          unsigned __int16 v31 = llvm::ConstrainedFPIntrinsic::getRoundingMode((llvm::ConstrainedFPIntrinsic *)a8);
          if (v31 != 7 && v31 >= 0x100u) {
            char v33 = v31;
          }
          else {
            char v33 = 1;
          }
          uint64_t v34 = (uint64_t)v28 + 24;
          int v35 = (llvm::Constant *)((char *)v25 + 32);
          if (*((_UNKNOWN **)v25 + 4) == &unk_1CFB2E344) {
            llvm::detail::DoubleAPFloat::DoubleAPFloat((void *)&__src + 1, v35);
          }
          else {
            llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&__src + 8, v35);
          }
          int v21 = 0;
          switch((int)v12)
          {
            case 'S':
              int v298 = sub_1CB88A708((uint64_t)&__src, (uint64_t)v28 + 24, v33);
              goto LABEL_657;
            case 'T':
            case 'U':
              int v36 = sub_1CC5E4A64(*(void *)(a8 - 32 * (*(_DWORD *)(a8 + 20) & 0x7FFFFFF) + 64));
              uint64_t v37 = (void *)*((void *)v25 + 4);
              if (*(_DWORD *)(*(void *)(a8 - 32) + 36) == 85)
              {
                if (v37 == &unk_1CFB2E344) {
                  BOOL v38 = (char *)*((void *)v25 + 5);
                }
                else {
                  BOOL v38 = (char *)v25 + 24;
                }
                if ((v38[28] & 7) == 1
                  || (*((_UNKNOWN **)v28 + 4) != &unk_1CFB2E344
                    ? (uint64_t v39 = (uint64_t)v28 + 24)
                    : (uint64_t v39 = *((void *)v28 + 5)),
                      (*(unsigned char *)(v39 + 28) & 7) == 1))
                {
LABEL_54:
                  int v40 = 1;
                  goto LABEL_668;
                }
              }
              else
              {
                if (v37 == &unk_1CFB2E344) {
                  size_t v301 = (unsigned char *)(*((void *)v25 + 5) + 8);
                }
                else {
                  size_t v301 = (char *)v25 + 32;
                }
                if ((v301[20] & 7) == 1 && *(_DWORD *)(*(void *)v301 + 16) != 1)
                {
                  int v536 = *(_DWORD *)(*(void *)v301 + 8);
                  uint64_t v537 = v301 + 8;
                  if ((v536 - 64) <= 0xFFFFFF7F) {
                    uint64_t v537 = (void *)*v537;
                  }
                  if (((v537[(v536 - 2) >> 6] >> (v536 - 2)) & 1) == 0) {
                    goto LABEL_54;
                  }
                }
                uint64_t v302 = (void *)*((void *)v28 + 4);
                uint64_t v303 = *((void *)v28 + 5);
                uint64_t v304 = (uint64_t)v28 + 32;
                uint64_t v305 = v303 + 8;
                uint64_t v306 = (unsigned char *)(v302 == &unk_1CFB2E344 ? v305 : v304);
                if ((v306[20] & 7) == 1 && *(_DWORD *)(*(void *)v306 + 16) != 1)
                {
                  int v538 = *(_DWORD *)(*(void *)v306 + 8);
                  v539 = v306 + 8;
                  if ((v538 - 64) <= 0xFFFFFF7F) {
                    v539 = (void *)*v539;
                  }
                  if (((v539[(v538 - 2) >> 6] >> (v538 - 2)) & 1) == 0) {
                    goto LABEL_54;
                  }
                }
              }
              int v40 = 0;
LABEL_668:
              unsigned int v307 = llvm::FCmpInst::compare((uint64_t)v25 + 24, v34, v36);
              if (sub_1CBFC7098((llvm::ConstrainedFPIntrinsic *)a8, v40))
              {
                uint64_t v308 = *(llvm::ConstantInt **)a8;
                if ((*(_DWORD *)(*(void *)a8 + 8) & 0xFE) == 0x12) {
                  uint64_t v308 = (llvm::ConstantInt *)**((void **)v308 + 2);
                }
                size_t v300 = (llvm::Constant *)llvm::ConstantInt::get(v308, v307, 0);
LABEL_672:
                int v21 = v300;
              }
              else
              {
LABEL_673:
                int v21 = 0;
              }
LABEL_674:
              uint64_t v192 = *((void *)&__src + 1);
              if (*((_UNKNOWN **)&__src + 1) != &unk_1CFB2E344) {
                goto LABEL_1710;
              }
              break;
            case 'V':
              int v298 = sub_1CB887A54((uint64_t)&__src, (uint64_t)v28 + 24, v33);
              goto LABEL_657;
            case 'Y':
              int v298 = sub_1CB9C2E60((uint64_t)&__src, (uint64_t)v28 + 24, v33);
              goto LABEL_657;
            case '_':
              int v298 = sub_1CD472368((uint64_t)&__src, (uint64_t)v28 + 24);
              goto LABEL_657;
              int v298 = sub_1CB9C2E3C((uint64_t)&__src, (uint64_t)v28 + 24, v33);
LABEL_657:
              if (!sub_1CBFC7098((llvm::ConstrainedFPIntrinsic *)a8, v298)) {
                goto LABEL_673;
              }
              size_t v300 = llvm::ConstantFP::get(*v580, (llvm::LLVMContext *)&__src, v299);
              goto LABEL_672;
            default:
              goto LABEL_674;
          }
LABEL_1713:
          uint64_t v437 = (uint64_t *)&v585;
          goto LABEL_1714;
        }
        if ((int)v12 > 200)
        {
          uint64_t v193 = (uint64_t)v580;
          if (v12 != 202)
          {
            if (v12 == 238)
            {
              uint64_t v194 = (double (*)(double, double))MEMORY[0x1E4F14A28];
              uint64_t v195 = (llvm::Constant *)((char *)v25 + 24);
              uint64_t v196 = (llvm::Constant *)((char *)v28 + 24);
              return sub_1CBFC510C(v194, v195, v196, v193);
            }
            if (v12 != 201) {
              goto LABEL_719;
            }
            uint64_t v197 = *v580;
            sub_1CD472298((uint64_t)v25 + 24, (uint64_t)v28 + 24, (uint64_t)&__src);
            goto LABEL_572;
          }
          uint64_t v278 = (char *)v28 + 24;
          uint64_t v279 = *((void *)v25 + 4);
          uint64_t v280 = (char *)*((void *)v25 + 5);
          uint64_t v281 = *v580;
          if ((_UNKNOWN *)v279 != &unk_1CFB2E344) {
            uint64_t v280 = (char *)v25 + 24;
          }
          if ((v280[28] & 7) == 1)
          {
            size_t v288 = (llvm::Constant *)((char *)v28 + 32);
            uint64_t v501 = *((void *)v28 + 4);
            if ((_UNKNOWN *)v501 != &unk_1CFB2E344)
            {
              *((void *)&__src + 1) = *((void *)v28 + 4);
              if ((*(_DWORD *)(v501 + 8) + 64) >= 0x80) {
                operator new[]();
              }
              char v502 = *((unsigned char *)v28 + 52);
              int v503 = v502 & 7;
              char v587 = v502 & 0xF;
              int v586 = *((_DWORD *)v28 + 12);
              BOOL v505 = (v502 & 6) != 0 && v503 != 3;
              if (v503 == 1 || v505)
              {
                uint64_t v506 = *(unsigned int *)(v501 + 8);
                if ((v506 - 64) <= 0xFFFFFF7F) {
                  v507 = (uint64_t *)v30;
                }
                else {
                  v507 = (uint64_t *)&v585;
                }
                uint64_t v510 = (uint64_t *)*((void *)v28 + 5);
                uint64_t v509 = (uint64_t *)((char *)v28 + 40);
                uint64_t v508 = v510;
                if ((*(_DWORD *)(*(v509 - 1) + 8) - 64) >= 0xFFFFFF80) {
                  uint64_t v508 = v509;
                }
                if (v506 <= 0xFFFFFFBF)
                {
                  unint64_t v511 = (unint64_t)(v506 + 64) >> 6;
                  do
                  {
                    uint64_t v512 = *v508++;
                    *v507++ = v512;
                    --v511;
                  }
                  while (v511);
                }
              }
LABEL_590:
              int v21 = llvm::ConstantFP::get(v281, (llvm::LLVMContext *)&__src, a3);
              uint64_t v192 = *((void *)&__src + 1);
              if (*((_UNKNOWN **)&__src + 1) != &unk_1CFB2E344) {
                goto LABEL_1710;
              }
              goto LABEL_1033;
            }
          }
          else
          {
            BOOL v282 = (void *)*((void *)v28 + 4);
            uint64_t v283 = (char *)*((void *)v28 + 5);
            int v284 = (llvm::Constant *)((char *)v28 + 32);
            if (v282 != &unk_1CFB2E344) {
              uint64_t v283 = v278;
            }
            if ((v283[28] & 7) != 1)
            {
              int v285 = (llvm::Constant *)((char *)v25 + 32);
              if (v282 == &unk_1CFB2E344) {
                int v286 = llvm::detail::DoubleAPFloat::compare(v284, v285);
              }
              else {
                int v286 = llvm::detail::IEEEFloat::compare(v284, v285);
              }
              if (v286) {
                size_t v287 = (char *)v25 + 24;
              }
              else {
                size_t v287 = v278;
              }
              uint64_t v289 = (void *)*((void *)v287 + 1);
              size_t v288 = (const llvm::detail::IEEEFloat *)(v287 + 8);
              if (v289 != &unk_1CFB2E344)
              {
                llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&__src + 8, v288);
                goto LABEL_590;
              }
              goto LABEL_1598;
            }
            if ((_UNKNOWN *)v279 != &unk_1CFB2E344)
            {
              *((void *)&__src + 1) = *((void *)v25 + 4);
              if ((*(_DWORD *)(v279 + 8) + 64) >= 0x80) {
                operator new[]();
              }
              char v541 = *((unsigned char *)v25 + 52);
              int v542 = v541 & 7;
              char v587 = v541 & 0xF;
              int v586 = *((_DWORD *)v25 + 12);
              BOOL v544 = (v541 & 6) != 0 && v542 != 3;
              if (v542 == 1 || v544)
              {
                uint64_t v545 = *(unsigned int *)(v279 + 8);
                size_t v546 = (v545 - 64) <= 0xFFFFFF7F ? (uint64_t *)v30 : (uint64_t *)&v585;
                size_t v547 = (*(_DWORD *)(*((void *)v25 + 4) + 8) - 64) >= 0xFFFFFF80
                     ? (uint64_t *)((char *)v25 + 40)
                     : (uint64_t *)*((void *)v25 + 5);
                if (v545 <= 0xFFFFFFBF)
                {
                  unint64_t v548 = (unint64_t)(v545 + 64) >> 6;
                  do
                  {
                    uint64_t v549 = *v547++;
                    *v546++ = v549;
                    --v548;
                  }
                  while (v548);
                }
              }
              goto LABEL_590;
            }
            size_t v288 = (llvm::Constant *)((char *)v25 + 32);
          }
LABEL_1598:
          llvm::detail::DoubleAPFloat::DoubleAPFloat((void *)&__src + 1, v288);
          goto LABEL_590;
        }
        uint64_t v193 = (uint64_t)v580;
        if (v12 == 193)
        {
          uint64_t v197 = *v580;
          sub_1CBFC7220((llvm::Constant *)((char *)v25 + 24), (void *)v28 + 3, (uint64_t)&__src);
          goto LABEL_572;
        }
        if (v12 != 19)
        {
          if (v12 != 192)
          {
LABEL_719:
            int v577 = (llvm::Constant *)((char *)v28 + 24);
            int v21 = 0;
            unsigned int v325 = *(unsigned __int8 *)(v193 + 8);
            if (v325 > 3 || v325 == 1) {
              return v21;
            }
            if (v12 != 2925)
            {
              if (!a7) {
                return 0;
              }
              __s2 = sub_1CC154CDC(__s1, v14);
              if (!v415) {
                return 0;
              }
              size_t v416 = v415;
              size_t v417 = &llvm::TargetLibraryInfoImpl::StandardNames;
              unint64_t v418 = 468;
              do
              {
                v419 = &v417[2 * (v418 >> 1)];
                size_t v420 = (size_t)v419[1];
                if (v416 >= v420) {
                  size_t v421 = (size_t)v419[1];
                }
                else {
                  size_t v421 = v416;
                }
                if (v421 && (int v422 = memcmp(*v419, __s2, v421)) != 0)
                {
                  int v423 = (v422 >> 31) | 1;
                }
                else
                {
                  if (v420 < v416) {
                    int v423 = -1;
                  }
                  else {
                    int v423 = 1;
                  }
                  if (v420 == v416) {
                    int v423 = 0;
                  }
                }
                if (v423 == -1) {
                  v418 += ~(v418 >> 1);
                }
                else {
                  v418 >>= 1;
                }
                if (v423 == -1) {
                  size_t v417 = v419 + 2;
                }
              }
              while (v418);
              if (v417 == &llvm::TargetLibraryInfoImpl::StandardNames + 936
                || v417[1] != (char *)v416
                || memcmp(*v417, __s2, v416))
              {
                return 0;
              }
              unint64_t v489 = (char *)v417 - (char *)&llvm::TargetLibraryInfoImpl::StandardNames;
              unint64_t v490 = (unint64_t)((char *)v417 - (char *)&llvm::TargetLibraryInfoImpl::StandardNames) >> 4;
              if ((int)v490 <= 245)
              {
                if ((v490 - 63) < 2)
                {
LABEL_1200:
                  if ((*(void *)(a7[1] + 8 * ((v489 >> 10) & 0x3FFFFFF)) >> v490)) {
                    return 0;
                  }
                  unsigned int v491 = *(unsigned __int8 *)(*a7 + ((v489 >> 6) & 0x3FFFFFFF));
                  char v492 = 2 * (v490 & 3);
                  uint64_t v493 = (double (*)(double, double))MEMORY[0x1E4F14630];
                  goto LABEL_1619;
                }
                if ((v490 - 108) >= 2)
                {
                  if ((v490 - 156) >= 2) {
                    return 0;
                  }
                  goto LABEL_1200;
                }
LABEL_1617:
                if ((*(void *)(a7[1] + 8 * ((v489 >> 10) & 0x3FFFFFF)) >> v490)) {
                  return 0;
                }
                unsigned int v491 = *(unsigned __int8 *)(*a7 + ((v489 >> 6) & 0x3FFFFFFF));
                char v492 = 2 * (v490 & 3);
                uint64_t v493 = (double (*)(double, double))MEMORY[0x1E4F14A28];
LABEL_1619:
                if (((v491 >> v492) & 3) == 0) {
                  return 0;
                }
                uint64_t v194 = v493;
                uint64_t v195 = (llvm::Constant *)((char *)v25 + 24);
                uint64_t v196 = v577;
                uint64_t v193 = (uint64_t)v580;
                return sub_1CBFC510C(v194, v195, v196, v193);
              }
              if ((v490 - 246) < 2)
              {
                if (((*(void *)(a7[1] + 8 * ((v489 >> 10) & 0x3FFFFFF)) >> v490) & 1) != 0
                  || ((*(unsigned __int8 *)(*a7 + ((v489 >> 6) & 0x3FFFFFFF)) >> (2 * (v490 & 3))) & 3) == 0)
                {
                  return 0;
                }
                unint64_t v564 = (llvm::Constant *)((char *)v25 + 32);
                if (*((_UNKNOWN **)v25 + 4) == &unk_1CFB2E344) {
                  llvm::detail::DoubleAPFloat::DoubleAPFloat((void *)&__src + 1, v564);
                }
                else {
                  llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&__src + 8, v564);
                }
                int v565 = sub_1CD472368((uint64_t)&__src, (uint64_t)v577);
              }
              else
              {
                if ((v490 - 364) >= 2)
                {
                  if ((v490 - 347) > 1) {
                    return 0;
                  }
                  goto LABEL_1617;
                }
                if (((*(void *)(a7[1] + 8 * ((v489 >> 10) & 0x3FFFFFF)) >> v490) & 1) != 0
                  || ((*(unsigned __int8 *)(*a7 + ((v489 >> 6) & 0x3FFFFFFF)) >> (2 * (v490 & 3))) & 3) == 0)
                {
                  return 0;
                }
                uint64_t v567 = (llvm::Constant *)((char *)v25 + 32);
                if (*((_UNKNOWN **)v25 + 4) == &unk_1CFB2E344) {
                  llvm::detail::DoubleAPFloat::DoubleAPFloat((void *)&__src + 1, v567);
                }
                else {
                  llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&__src + 8, v567);
                }
                int v565 = sub_1CD47245C((uint64_t)&__src, (uint64_t)v577);
              }
              int v568 = v565;
              if (!v565) {
                uint64_t v9 = llvm::ConstantFP::get(*v580, (llvm::LLVMContext *)&__src, v566);
              }
              int v21 = v9;
              if (*((_UNKNOWN **)&__src + 1) == &unk_1CFB2E344)
              {
                sub_1CB845718((uint64_t *)&v585);
              }
              else if ((*(_DWORD *)(*((void *)&__src + 1) + 8) - 64) <= 0xFFFFFF7F && v585)
              {
                MEMORY[0x1D25D9CB0](v585, 0x1000C8000313F17);
              }
              if (!v568) {
                return v21;
              }
              return 0;
            }
            a2 = (llvm::Constant *)((char *)v25 + 32);
            v411 = (void *)*((void *)v25 + 4);
            if (v411 == &unk_1CFB2E344) {
              uint64_t v27 = (char *)*((void *)v25 + 5);
            }
            uint64_t v169 = (llvm::Constant *)v580;
            if ((v27[28] & 7) == 3) {
              return llvm::Constant::getNullValue(v169, a2, a3);
            }
            uint64_t v412 = (uint64_t)v28 + 24;
            if (*((_UNKNOWN **)v28 + 4) == &unk_1CFB2E344) {
              uint64_t v412 = *((void *)v28 + 5);
            }
            if ((*(unsigned char *)(v412 + 28) & 7) == 3) {
              return llvm::Constant::getNullValue(v169, a2, a3);
            }
            int v413 = *v580;
            if (v411 == &unk_1CFB2E344) {
              llvm::detail::DoubleAPFloat::DoubleAPFloat((void *)&__src + 1, a2);
            }
            else {
              llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&__src + 8, a2);
            }
            int v203 = (unint64_t *)&__src;
            sub_1CB9C2E60((uint64_t)&__src, (uint64_t)v577, 1);
            int v21 = llvm::ConstantFP::get(v413, (llvm::LLVMContext *)&__src, v414);
            uint64_t v192 = *((void *)&__src + 1);
            if (*((_UNKNOWN **)&__src + 1) != &unk_1CFB2E344) {
              goto LABEL_1710;
            }
            goto LABEL_1069;
          }
          uint64_t v197 = *v580;
          sub_1CD472388((uint64_t)v25 + 24, (uint64_t)v28 + 24, (uint64_t)&__src);
          goto LABEL_572;
        }
        int64_t v449 = *v580;
        int64_t v450 = (llvm::Constant *)((char *)v25 + 32);
        if (*((_UNKNOWN **)v25 + 4) == &unk_1CFB2E344) {
          llvm::detail::DoubleAPFloat::DoubleAPFloat(&v624, v450);
        }
        else {
          llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&v624, v450);
        }
        int v203 = &v623;
        sub_1CD47267C((uint64_t)&v623, (uint64_t)v28 + 24);
        uint64_t v452 = *((void *)&v624 + 1);
        if ((_UNKNOWN *)v624 == &unk_1CFB2E344)
        {
          *((void *)&v624 + 1) = 0;
        }
        else
        {
          int v586 = v625;
          char v587 = v626 & 0xF;
        }
        *((void *)&__src + 1) = v624;
        v585 = (long long *)v452;
        *(void *)&long long v624 = &unk_1CFB2E394;
        int v21 = llvm::ConstantFP::get(v449, (llvm::LLVMContext *)&__src, v451);
        if (*((_UNKNOWN **)&__src + 1) == &unk_1CFB2E344)
        {
          sub_1CB845718((uint64_t *)&v585);
        }
        else if ((*(_DWORD *)(*((void *)&__src + 1) + 8) - 64) <= 0xFFFFFF7F && v585)
        {
          MEMORY[0x1D25D9CB0](v585, 0x1000C8000313F17);
        }
        uint64_t v256 = v624;
        if ((_UNKNOWN *)v624 == &unk_1CFB2E344)
        {
LABEL_1069:
          uint64_t v437 = (uint64_t *)(v203 + 2);
          goto LABEL_1714;
        }
LABEL_530:
        if ((*(_DWORD *)(v256 + 8) - 64) > 0xFFFFFF7F || !*((void *)&v624 + 1)) {
          return v21;
        }
LABEL_1359:
        MEMORY[0x1D25D9CB0]();
        return v21;
      }
      int v21 = 0;
      if (!v28) {
        return v21;
      }
      if (v29 != 16) {
        return v21;
      }
      int v21 = 0;
      if (v22 > 3 || v22 == 1) {
        return v21;
      }
      BOOL v130 = (llvm::ConstantFP **)a4;
      if (a3 == 239)
      {
        if (v22 == 3)
        {
          uint64_t v197 = *(llvm::ConstantFP **)a4;
          long double v269 = llvm::APFloat::convertToDouble((llvm::Constant *)((char *)v25 + 24));
          int v270 = (void *)((char *)v28 + 24);
          if (*((_DWORD *)v28 + 8) >= 0x41u) {
            int v270 = (void *)*v270;
          }
          long double v271 = pow(v269, (double)*(int *)v270);
          DWORD2(__src) = 64;
          *(long double *)&long long __src = v271;
          llvm::detail::IEEEFloat::initFromDoubleAPInt((llvm::detail::IEEEFloat *)&v623, (const llvm::APInt **)&__src);
        }
        else
        {
          uint64_t v197 = *(llvm::ConstantFP **)a4;
          float v198 = llvm::APFloat::convertToDouble((llvm::Constant *)((char *)v25 + 24));
          size_t v199 = (void *)((char *)v28 + 24);
          if (*((_DWORD *)v28 + 8) >= 0x41u) {
            size_t v199 = (void *)*v199;
          }
          *(float *)&unsigned int v200 = pow(v198, (double)*(int *)v199);
          DWORD2(__src) = 32;
          *(void *)&long long __src = v200;
          llvm::detail::IEEEFloat::initFromFloatAPInt((llvm::detail::IEEEFloat *)&v623, (const llvm::APInt **)&__src);
        }
        *((void *)&__src + 1) = v623;
        v585 = (long long *)v624;
        int v586 = DWORD2(v624);
        char v587 = BYTE12(v624) & 0xF;
LABEL_572:
        int v21 = llvm::ConstantFP::get(v197, (llvm::LLVMContext *)&__src, v201);
        uint64_t v192 = *((void *)&__src + 1);
        if (*((_UNKNOWN **)&__src + 1) != &unk_1CFB2E344) {
          goto LABEL_1710;
        }
        goto LABEL_1033;
      }
      if (a3 != 3428) {
        return 0;
      }
      size_t v131 = (llvm::Constant *)((char *)v25 + 32);
      if (*((_UNKNOWN **)v25 + 4) == &unk_1CFB2E344) {
        llvm::detail::DoubleAPFloat::DoubleAPFloat(&v624, v131);
      }
      else {
        llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&v624, v131);
      }
      unsigned int v132 = *((_DWORD *)v28 + 8);
      if (v132 > 0x40) {
        uint64_t v133 = **((void **)v28 + 3);
      }
      else {
        uint64_t v133 = (uint64_t)(*((void *)v28 + 3) << -(char)v132) >> -(char)v132;
      }
      sub_1CD47247C((uint64_t *)&__src, (void **)&v623, v133, 1);
      if ((_UNKNOWN *)v624 == &unk_1CFB2E344)
      {
        sub_1CB845718((uint64_t *)&v624 + 1);
      }
      else
      {
        uint64_t v436 = v130;
        if ((*(_DWORD *)(v624 + 8) - 64) > 0xFFFFFF7F || !*((void *)&v624 + 1))
        {
LABEL_1032:
          int v21 = llvm::ConstantFP::get(*v436, (llvm::LLVMContext *)&__src, v435);
          uint64_t v192 = *((void *)&__src + 1);
          if (*((_UNKNOWN **)&__src + 1) != &unk_1CFB2E344) {
            goto LABEL_1710;
          }
LABEL_1033:
          uint64_t v437 = (uint64_t *)&v585;
LABEL_1714:
          sub_1CB845718(v437);
          return v21;
        }
        MEMORY[0x1D25D9CB0](*((void *)&v624 + 1), 0x1000C8000313F17);
      }
      uint64_t v436 = v130;
      goto LABEL_1032;
    }
    if (*(unsigned char *)(*(void *)v25 + 8) != 13
      || (uint64_t v70 = (unsigned __int8 *)a5[1], *(unsigned char *)(*(void *)v70 + 8) != 13))
    {
      if (v26 != 15 && v26 != 10) {
        return 0;
      }
      int v86 = a5[1];
      if (*((unsigned char *)v86 + 16) != 16) {
        return 0;
      }
      int64_t v87 = (void *)((char *)v86 + 24);
      uint64_t v88 = *((unsigned int *)v86 + 8);
      if (v88 >= 0x41)
      {
        int v89 = 0;
        int64_t v90 = (unint64_t)(v88 + 63) >> 6;
        do
        {
          BOOL v371 = v90-- < 1;
          if (v371) {
            break;
          }
          unint64_t v91 = *(void *)(*v87 + 8 * v90);
          v89 += __clz(v91);
        }
        while (!v91);
        int v92 = v88 | 0xFFFFFFC0;
        if ((v88 & 0x3F) == 0) {
          int v92 = 0;
        }
        if ((v88 - v89 - v92) > 0x40) {
          return 0;
        }
        int64_t v87 = (void *)*v87;
      }
      if (*v87 != 4) {
        return 0;
      }
      if ((a3 - 11302) <= 7)
      {
        BOOL v93 = (llvm::ConstantInt *)a4;
        uint64_t v94 = *a5;
        if (((1 << ((_BYTE)a3 - 38)) & 0x33) != 0) {
          goto LABEL_354;
        }
        unsigned int v223 = llvm::Constant::getAggregateElement(v94, 0);
        if (!v223 || *((unsigned char *)v223 + 16) != 17) {
          return 0;
        }
        uint64_t v96 = (uint64_t)(v223 + 3);
        int v97 = 1;
      }
      else
      {
        if ((a3 - 11802) > 7) {
          return 0;
        }
        BOOL v93 = (llvm::ConstantInt *)a4;
        uint64_t v94 = *a5;
        if (((1 << ((_BYTE)a3 - 26)) & 0x33) != 0) {
          goto LABEL_358;
        }
        uint64_t v95 = llvm::Constant::getAggregateElement(v94, 0);
        if (!v95 || *((unsigned char *)v95 + 16) != 17) {
          return 0;
        }
        uint64_t v96 = (uint64_t)(v95 + 3);
        int v97 = 0;
      }
      int v177 = v93;
      uint64_t v178 = 0;
      return (const llvm::detail::DoubleAPFloat *)sub_1CBFC6F2C(v96, v97, v177, (const llvm::APInt *)v178);
    }
    if (v26 == 16) {
      uint64_t v71 = (llvm::Constant *)((char *)v25 + 24);
    }
    else {
      uint64_t v71 = 0;
    }
    if (v26 - 11 < 2) {
      uint64_t v71 = 0;
    }
    if (v26 == 16) {
      uint64_t v72 = (llvm::Constant *)((char *)v25 + 24);
    }
    else {
      uint64_t v72 = v71;
    }
    if (v26 > 0x10 || ((1 << v26) & 0x11800) == 0) {
      return 0;
    }
    int v21 = 0;
    unsigned int v74 = v70[16];
    uint64_t v75 = (unsigned int *)(v70 + 24);
    if (v74 == 16) {
      unint64_t v76 = v75;
    }
    else {
      unint64_t v76 = 0;
    }
    if (v74 > 0x10 || ((1 << v74) & 0x11800) == 0) {
      return v21;
    }
    unint64_t v77 = (uint64_t **)a4;
    int v21 = 0;
    if ((int)a3 > 299)
    {
      switch((int)a3)
      {
        case 300:
LABEL_735:
          if (v26 == 12 || v74 == 12) {
            goto LABEL_743;
          }
          uint64_t v169 = (llvm::Constant *)a4;
          if (!v72 && v74 != 16) {
            return llvm::UndefValue::get(v169, a2);
          }
          if (!v72 || v74 != 16) {
            return (const llvm::detail::DoubleAPFloat *)llvm::Constant::getAllOnesValue((llvm::Constant *)a4, a2, a3);
          }
          if (a3 == 300) {
            llvm::APInt::uadd_sat(v72, (const llvm::APInt *)v76, (uint64_t)&__src);
          }
          else {
            llvm::APInt::sadd_sat(v72, (const llvm::APInt *)v76, (uint64_t)&__src);
          }
          goto LABEL_1356;
        case 301:
          goto LABEL_726;
        case 305:
        case 306:
LABEL_439:
          if (v26 == 12 || v74 == 12) {
            goto LABEL_743;
          }
          a2 = (llvm::Type *)a4;
          if (!v72 && v74 != 16)
          {
            uint64_t v169 = (llvm::Constant *)a4;
            return llvm::UndefValue::get(v169, a2);
          }
          if (!v72 || v74 != 16) {
            return sub_1CD4725DC((uint64_t)a3, (llvm::Type ***)a4);
          }
          if ((int)a3 > 304)
          {
            if (a3 == 306) {
              int v389 = 36;
            }
            else {
              int v389 = 34;
            }
          }
          else if (a3 == 274)
          {
            int v389 = 38;
          }
          else
          {
            int v389 = 40;
          }
          if (llvm::ICmpInst::compare((uint64_t)v72, (uint64_t)v76, v389)) {
            size_t v448 = v72;
          }
          else {
            size_t v448 = (llvm::LLVMContext *)v76;
          }
          int v21 = (llvm::Constant *)llvm::ConstantInt::get((llvm::ConstantInt *)*v77, v448, v447);
          if ((v77[1] & 0xFE) == 0x12) {
            return llvm::ConstantVector::getSplat((llvm::Type *)(*((unsigned int *)v77 + 8) | ((unint64_t)(*((_DWORD *)v77 + 2) == 19) << 32)), (uint64_t)v21);
          }
          return v21;
        case 309:
          goto LABEL_728;
        case 311:
LABEL_645:
          if (v26 == 12 || v74 == 12)
          {
LABEL_743:
            uint64_t v327 = (llvm::PoisonValue *)a4;
            return (const llvm::detail::DoubleAPFloat *)llvm::PoisonValue::get(v327, a2);
          }
          uint64_t v169 = (llvm::Constant *)a4;
          if (!v72 && v74 != 16) {
            return llvm::UndefValue::get(v169, a2);
          }
          if (!v72 || v74 != 16) {
            return llvm::Constant::getNullValue(v169, a2, a3);
          }
          if (a3 == 311) {
            llvm::APInt::usub_sat(v72, (const llvm::APInt *)v76, (uint64_t)&__src);
          }
          else {
            llvm::APInt::ssub_sat(v72, (const llvm::APInt *)v76, (llvm::APInt *)&__src);
          }
          goto LABEL_1356;
        case 312:
LABEL_642:
          if (!v72 || v74 != 16) {
            goto LABEL_734;
          }
LABEL_726:
          if (!v72 || v74 != 16)
          {
            *(void *)&long long __src = llvm::Constant::getAllOnesValue(**(llvm::Constant ***)(a4 + 16), a2, a3);
            *((void *)&__src + 1) = llvm::Constant::getNullValue((llvm::Constant *)v77[2][1], v329, v330);
            return (const llvm::detail::DoubleAPFloat *)llvm::ConstantStruct::get((llvm::PoisonValue *)v77, (llvm::Type *)&__src, 2);
          }
LABEL_728:
          if (!v72 || v74 != 16) {
            goto LABEL_734;
          }
          v617.__r_.__value_.__s.__data_[0] = 0;
          if ((int)a3 > 300)
          {
            if (a3 == 301)
            {
              llvm::APInt::uadd_ov((uint64_t)v72, (const llvm::APInt *)v76, (BOOL *)&v617, (uint64_t)&__src);
            }
            else if (a3 == 309)
            {
              llvm::APInt::umul_ov(v72, (const llvm::APInt *)v76, (BOOL *)&v617, (uint64_t)&__src);
            }
            else
            {
              llvm::APInt::usub_ov((uint64_t)v72, (const llvm::APInt *)v76, (BOOL *)&v617, (uint64_t)&__src);
            }
          }
          else if (a3 == 263)
          {
            llvm::APInt::sadd_ov(v72, (const llvm::APInt *)v76, (BOOL *)&v617, (uint64_t)&__src);
          }
          else if (a3 == 278)
          {
            llvm::APInt::smul_ov((const void **)v72, (const llvm::APInt *)v76, (BOOL *)&v617, (llvm::APInt *)&__src);
          }
          else
          {
            llvm::APInt::ssub_ov(v72, (const llvm::APInt *)v76, (BOOL *)&v617, (uint64_t)&__src);
          }
          unint64_t v623 = __src;
          LODWORD(v624) = DWORD2(__src);
          *(void *)v620 = llvm::ConstantInt::get((llvm::ConstantInt *)*v77, (llvm::LLVMContext *)&v623, v326);
          uint64_t v442 = **v77;
          int v443 = *(llvm::ConstantInt **)(v442 + 1888);
          unint64_t v444 = *(unsigned int *)(v442 + 1896);
          DWORD2(__src) = v444 >> 8;
          if (v444 >> 8 > 0x40) {
            operator new[]();
          }
          if (v444 <= 0xFF) {
            LOBYTE(v445) = 0;
          }
          else {
            unint64_t v445 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v444) + 63);
          }
          *(void *)&long long __src = v445 & v617.__r_.__value_.__s.__data_[0];
          size_t v446 = llvm::ConstantInt::get(v443, (llvm::LLVMContext *)&__src, v441);
          if (DWORD2(__src) >= 0x41 && (void)__src) {
            MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
          }
          *(void *)&v620[8] = v446;
          int v21 = (llvm::Constant *)llvm::ConstantStruct::get((llvm::PoisonValue *)v77, (llvm::Type *)v620, 2);
          if (v624 < 0x41 || !v623) {
            return v21;
          }
          goto LABEL_1359;
        default:
          return v21;
      }
    }
    if ((int)a3 > 261)
    {
      switch((int)a3)
      {
        case 274:
        case 275:
          goto LABEL_439;
        case 276:
        case 277:
        case 279:
        case 280:
        case 281:
        case 282:
          return v21;
        case 278:
          goto LABEL_728;
        case 283:
          goto LABEL_645;
        case 284:
          goto LABEL_642;
        default:
          if (a3 == 262) {
            goto LABEL_735;
          }
          if (a3 == 263) {
            goto LABEL_726;
          }
          return v21;
      }
    }
    if (a3 != 1)
    {
      if (a3 != 52 && a3 != 54) {
        return v21;
      }
      uint64_t v78 = v76[2];
      if (v78 > 0x40)
      {
        int v319 = 0;
        int64_t v320 = (unint64_t)(v78 + 63) >> 6;
        uint64_t v79 = (llvm::Constant *)a4;
        do
        {
          BOOL v371 = v320-- < 1;
          if (v371) {
            break;
          }
          unint64_t v321 = *(void *)(*(void *)v76 + 8 * v320);
          v319 += __clz(v321);
        }
        while (!v321);
        int v322 = v78 | 0xFFFFFFC0;
        if ((v78 & 0x3F) == 0) {
          int v322 = 0;
        }
        if (v319 + v322 != v78 - 1) {
          goto LABEL_136;
        }
      }
      else
      {
        uint64_t v79 = (llvm::Constant *)a4;
        if (*(void *)v76 != 1)
        {
LABEL_136:
          if (!v72)
          {
            uint64_t v169 = v79;
            return llvm::Constant::getNullValue(v169, a2, a3);
          }
          LODWORD(v80) = *((_DWORD *)v72 + 2);
          goto LABEL_713;
        }
      }
      if (v72)
      {
        uint64_t v80 = *((unsigned int *)v72 + 2);
        if (v80 > 0x40)
        {
          int v426 = 0;
          int64_t v427 = (unint64_t)(v80 + 63) >> 6;
          do
          {
            BOOL v371 = v427-- < 1;
            if (v371) {
              break;
            }
            unint64_t v428 = *(void *)(*(void *)v72 + 8 * v427);
            v426 += __clz(v428);
          }
          while (!v428);
          int v429 = v80 | 0xFFFFFFC0;
          if ((v80 & 0x3F) == 0) {
            int v429 = 0;
          }
          if (v426 + v429 != v80) {
            goto LABEL_713;
          }
        }
        else if (*(void *)v72)
        {
LABEL_713:
          if (a3 == 54)
          {
            if (v80 > 0x40)
            {
              unsigned int v324 = llvm::APInt::countTrailingZerosSlowCase((unint64_t **)v72);
              uint64_t v79 = (llvm::Constant *)v77;
            }
            else
            {
              unsigned int v323 = __clz(__rbit64(*(void *)v72));
              if (v80 >= v323) {
                unsigned int v324 = v323;
              }
              else {
                unsigned int v324 = v80;
              }
            }
            unint64_t v276 = v324;
          }
          else
          {
            if (v80 > 0x40)
            {
              int v431 = 0;
              int64_t v432 = ((unint64_t)v80 + 63) >> 6;
              do
              {
                BOOL v371 = v432-- < 1;
                if (v371) {
                  break;
                }
                unint64_t v433 = *(void *)(*(void *)v72 + 8 * v432);
                v431 += __clz(v433);
              }
              while (!v433);
              if ((v80 & 0x3F) != 0) {
                int v434 = v80 | 0xFFFFFFC0;
              }
              else {
                int v434 = 0;
              }
              unsigned int v410 = v431 + v434;
            }
            else
            {
              unsigned int v410 = v80 + __clz(*(void *)v72) - 64;
            }
            unint64_t v276 = v410;
          }
          uint64_t v277 = v79;
          return (const llvm::detail::DoubleAPFloat *)llvm::ConstantInt::get(v277, v276, 0);
        }
      }
      uint64_t v327 = v79;
      return (const llvm::detail::DoubleAPFloat *)llvm::PoisonValue::get(v327, a2);
    }
    uint64_t v318 = v76[2];
    if (v318 > 0x40)
    {
      int v405 = 0;
      int64_t v406 = (unint64_t)(v318 + 63) >> 6;
      do
      {
        BOOL v371 = v406-- < 1;
        if (v371) {
          break;
        }
        unint64_t v407 = *(void *)(*(void *)v76 + 8 * v406);
        v405 += __clz(v407);
      }
      while (!v407);
      int v408 = v318 | 0xFFFFFFC0;
      if ((v318 & 0x3F) == 0) {
        int v408 = 0;
      }
      if (v405 + v408 != v318 - 1)
      {
LABEL_702:
        if (!v72)
        {
LABEL_734:
          uint64_t v169 = (llvm::Constant *)a4;
          return llvm::Constant::getNullValue(v169, a2, a3);
        }
        goto LABEL_1355;
      }
    }
    else if (*(void *)v76 != 1)
    {
      goto LABEL_702;
    }
    if (v72)
    {
      unsigned int v409 = *((_DWORD *)v72 + 2);
      if (v409 <= 0x40)
      {
        if (*(void *)v72 == 1 << (v409 - 1)) {
          goto LABEL_934;
        }
LABEL_1355:
        sub_1CBF71A98(v72, (llvm::APInt *)&__src);
LABEL_1356:
        int v21 = (llvm::Constant *)llvm::ConstantInt::get((llvm::ConstantInt *)*v77, (llvm::LLVMContext *)&__src, v297);
        if ((v77[1] & 0xFE) != 0x12) {
          goto LABEL_1357;
        }
        int v386 = *((_DWORD *)v77 + 2);
        uint64_t v387 = *((unsigned int *)v77 + 8);
        goto LABEL_1361;
      }
      if (((*(void *)(*(void *)v72 + 8 * ((v409 - 1) >> 6)) >> (v409 - 1)) & 1) == 0
        || llvm::APInt::countTrailingZerosSlowCase((unint64_t **)v72) != v409 - 1)
      {
        goto LABEL_1355;
      }
    }
LABEL_934:
    uint64_t v169 = (llvm::Constant *)v77;
    return llvm::UndefValue::get(v169, a2);
  }
  unint64_t v41 = *a5;
  if (*a5) {
    BOOL v42 = *((unsigned char *)*a5 + 16) == 17;
  }
  else {
    BOOL v42 = 0;
  }
  if (v42)
  {
    int v43 = a5[1];
    if (v43 && *((unsigned char *)v43 + 16) == 17)
    {
      uint64_t v98 = a5[2];
      if (v98)
      {
        if (*((unsigned char *)v98 + 16) == 17)
        {
          uint64_t v582 = (llvm::ConstantFP **)a4;
          int v99 = (_OWORD *)((char *)v98 + 24);
          int v100 = (void *)sub_1CBFC7338(a8);
          if (a8 && v100)
          {
            unsigned __int16 v101 = llvm::ConstrainedFPIntrinsic::getRoundingMode((llvm::ConstrainedFPIntrinsic *)a8);
            unint64_t v102 = (llvm::Constant *)((char *)v41 + 32);
            if (*((_UNKNOWN **)v41 + 4) == &unk_1CFB2E344) {
              llvm::detail::DoubleAPFloat::DoubleAPFloat((void *)&__src + 1, v102);
            }
            else {
              llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&__src + 8, v102);
            }
            if ((v12 | 2) == 0x5A
              && (v101 != 7 ? (BOOL v103 = v101 >= 0x100u) : (BOOL v103 = 0),
                  !v103 ? (char v104 = 1) : (char v104 = v101),
                  int v105 = sub_1CB8DA0F4((uint64_t)&__src, (uint64_t)v43 + 24, (uint64_t)v99, v104),
                  sub_1CBFC7098((llvm::ConstrainedFPIntrinsic *)a8, v105)))
            {
              int v21 = llvm::ConstantFP::get(*v582, (llvm::LLVMContext *)&__src, v106);
            }
            else
            {
              int v21 = 0;
            }
            uint64_t v192 = *((void *)&__src + 1);
            if (*((_UNKNOWN **)&__src + 1) != &unk_1CFB2E344) {
              goto LABEL_1710;
            }
            goto LABEL_1713;
          }
          int v152 = v12 - 2878;
          uint64_t v11 = (int8x8_t **)((char *)v41 + 32);
          std::string::size_type v153 = *((void *)v41 + 4);
          uint64_t v12 = &unk_1CFB2E344;
          if ((_UNKNOWN *)v153 == &unk_1CFB2E344) {
            llvm::detail::DoubleAPFloat::DoubleAPFloat((void *)&__src + 1, (uint64_t)&unk_1CFB2E344);
          }
          *((void *)&__src + 1) = *((void *)v41 + 4);
          if ((*(_DWORD *)(v153 + 8) + 64) >= 0x80) {
            operator new[]();
          }
          char v587 = 3;
          int v586 = *(_DWORD *)(v153 + 4) - 1;
          int v154 = *(_DWORD *)(v153 + 8);
          if ((v154 - 64) < 0xFFFFFF80)
          {
            *int v100 = 0;
            bzero(v100 + 1, 8 * (((v154 + 64) >> 6) - 2) + 8);
            *(void *)&long long v624 = v153;
            operator new[]();
          }
          v585 = 0;
          *(void *)&long long v624 = v153;
          char v626 = 3;
          int v625 = *(_DWORD *)(v153 + 4) - 1;
          int v155 = *(_DWORD *)(v153 + 8);
          if ((v155 - 64) < 0xFFFFFF80)
          {
            *int v100 = 0;
            bzero(v100 + 1, 8 * (((v155 + 64) >> 6) - 2) + 8);
            *(void *)&v620[8] = v153;
            operator new[]();
          }
          *((void *)&v624 + 1) = 0;
          *(void *)&v620[8] = v153;
          char v622 = 3;
          int v621 = *(_DWORD *)(v153 + 4) - 1;
          int v156 = *(_DWORD *)(v153 + 8);
          if ((v156 - 64) < 0xFFFFFF80)
          {
            *int v100 = 0;
            bzero(v100 + 1, 8 * (((v156 + 64) >> 6) - 2) + 8);
          }
          else
          {
            *(void *)&v620[16] = 0;
          }
          uint64_t v157 = (llvm::Constant *)((char *)v98 + 32);
          unsigned int v158 = (llvm::Constant *)((char *)v98 + 32);
          if (*((_UNKNOWN **)v98 + 4) == &unk_1CFB2E344) {
            llvm::detail::DoubleAPFloat::DoubleAPFloat(&v613, v158);
          }
          else {
            llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&v613, v158);
          }
          if (v613 == (_DWORD *)&unk_1CFB2E344)
          {
            uint64_t v550 = v614;
            if ((*(unsigned char *)(v614 + 28) & 8) != 0)
            {
              if (*(_UNKNOWN **)(v614 + 8) == &unk_1CFB2E344)
              {
                llvm::detail::DoubleAPFloat::changeSign((llvm::detail::DoubleAPFloat *)(v614 + 8));
                uint64_t v550 = v614;
              }
              else
              {
                *(unsigned char *)(v614 + 28) ^= 8u;
              }
              if (*(_UNKNOWN **)(v550 + 40) == &unk_1CFB2E344) {
                llvm::detail::DoubleAPFloat::changeSign((llvm::detail::DoubleAPFloat *)(v550 + 40));
              }
              else {
                *(unsigned char *)(v550 + 60) ^= 8u;
              }
            }
          }
          else if ((v616 & 8) != 0)
          {
            v616 ^= 8u;
          }
          std::string::size_type v159 = v614;
          if (v613 == (_DWORD *)&unk_1CFB2E344)
          {
            std::string::size_type v614 = 0;
          }
          else
          {
            int v618 = v615;
            char v619 = v619 & 0xF0 | v616 & 0xF;
          }
          v617.__r_.__value_.__l.__size_ = (std::string::size_type)v613;
          v617.__r_.__value_.__r.__words[2] = v159;
          v613 = &unk_1CFB2E394;
          int v160 = (llvm::Constant *)((char *)v41 + 32);
          if (*v11 == (int8x8_t *)&unk_1CFB2E344) {
            llvm::detail::DoubleAPFloat::DoubleAPFloat(&v604, v160);
          }
          else {
            llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&v604, v160);
          }
          if (v604 == (_DWORD *)&unk_1CFB2E344)
          {
            uint64_t v551 = v605;
            if ((*(unsigned char *)(v605 + 28) & 8) != 0)
            {
              if (*(_UNKNOWN **)(v605 + 8) == &unk_1CFB2E344)
              {
                llvm::detail::DoubleAPFloat::changeSign((llvm::detail::DoubleAPFloat *)(v605 + 8));
                uint64_t v551 = v605;
              }
              else
              {
                *(unsigned char *)(v605 + 28) ^= 8u;
              }
              if (*(_UNKNOWN **)(v551 + 40) == &unk_1CFB2E344) {
                llvm::detail::DoubleAPFloat::changeSign((llvm::detail::DoubleAPFloat *)(v551 + 40));
              }
              else {
                *(unsigned char *)(v551 + 60) ^= 8u;
              }
            }
          }
          else if ((v607 & 8) != 0)
          {
            v607 ^= 8u;
          }
          uint64_t v161 = v605;
          if (v604 == (_DWORD *)&unk_1CFB2E344)
          {
            uint64_t v605 = 0;
          }
          else
          {
            int v610 = v606;
            char v611 = v611 & 0xF0 | v607 & 0xF;
          }
          uint64_t v608 = v604;
          uint64_t v609 = v161;
          v604 = &unk_1CFB2E394;
          if ((_UNKNOWN *)v617.__r_.__value_.__l.__size_ == &unk_1CFB2E344) {
            int v162 = llvm::detail::DoubleAPFloat::compare((llvm::detail::DoubleAPFloat *)&v617.__r_.__value_.__r.__words[1], (const llvm::detail::DoubleAPFloat *)&v608);
          }
          else {
            int v162 = llvm::detail::IEEEFloat::compare((llvm::detail::IEEEFloat *)&v617.__r_.__value_.__r.__words[1], (const llvm::detail::IEEEFloat *)&v608);
          }
          if ((v162 - 1) > 1)
          {
            BOOL v168 = 0;
          }
          else
          {
            unsigned int v163 = (llvm::Constant *)((char *)v98 + 32);
            if (*(_UNKNOWN **)v157 == &unk_1CFB2E344) {
              llvm::detail::DoubleAPFloat::DoubleAPFloat(&v596, v163);
            }
            else {
              llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&v596, v163);
            }
            if (v596 == (_DWORD *)&unk_1CFB2E344)
            {
              uint64_t v553 = v597;
              if ((*(unsigned char *)(v597 + 28) & 8) != 0)
              {
                if (*(_UNKNOWN **)(v597 + 8) == &unk_1CFB2E344)
                {
                  llvm::detail::DoubleAPFloat::changeSign((llvm::detail::DoubleAPFloat *)(v597 + 8));
                  uint64_t v553 = v597;
                }
                else
                {
                  *(unsigned char *)(v597 + 28) ^= 8u;
                }
                if (*(_UNKNOWN **)(v553 + 40) == &unk_1CFB2E344) {
                  llvm::detail::DoubleAPFloat::changeSign((llvm::detail::DoubleAPFloat *)(v553 + 40));
                }
                else {
                  *(unsigned char *)(v553 + 60) ^= 8u;
                }
              }
            }
            else if ((v599 & 8) != 0)
            {
              v599 ^= 8u;
            }
            uint64_t v164 = v597;
            if (v596 == (_DWORD *)&unk_1CFB2E344)
            {
              uint64_t v597 = 0;
            }
            else
            {
              int v602 = v598;
              char v603 = v603 & 0xF0 | v599 & 0xF;
            }
            v600 = v596;
            uint64_t v601 = v164;
            size_t v596 = &unk_1CFB2E394;
            uint64_t v165 = (llvm::Constant *)((char *)v43 + 32);
            if (*((_UNKNOWN **)v43 + 4) == &unk_1CFB2E344) {
              llvm::detail::DoubleAPFloat::DoubleAPFloat(&v588, v165);
            }
            else {
              llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&v588, v165);
            }
            if (v588 == (_DWORD *)&unk_1CFB2E344)
            {
              uint64_t v554 = v589;
              if ((*(unsigned char *)(v589 + 28) & 8) != 0)
              {
                if (*(_UNKNOWN **)(v589 + 8) == &unk_1CFB2E344)
                {
                  llvm::detail::DoubleAPFloat::changeSign((llvm::detail::DoubleAPFloat *)(v589 + 8));
                  uint64_t v554 = v589;
                }
                else
                {
                  *(unsigned char *)(v589 + 28) ^= 8u;
                }
                if (*(_UNKNOWN **)(v554 + 40) == &unk_1CFB2E344) {
                  llvm::detail::DoubleAPFloat::changeSign((llvm::detail::DoubleAPFloat *)(v554 + 40));
                }
                else {
                  *(unsigned char *)(v554 + 60) ^= 8u;
                }
              }
            }
            else if ((v591 & 8) != 0)
            {
              v591 ^= 8u;
            }
            uint64_t v166 = v589;
            if (v588 == (_DWORD *)&unk_1CFB2E344)
            {
              uint64_t v589 = 0;
            }
            else
            {
              int v594 = v590;
              char v595 = v595 & 0xF0 | v591 & 0xF;
            }
            size_t v592 = v588;
            uint64_t v593 = v166;
            int v588 = &unk_1CFB2E394;
            if (v600 == (_DWORD *)&unk_1CFB2E344) {
              int v167 = llvm::detail::DoubleAPFloat::compare((llvm::detail::DoubleAPFloat *)&v600, (const llvm::detail::DoubleAPFloat *)&v592);
            }
            else {
              int v167 = llvm::detail::IEEEFloat::compare((llvm::detail::IEEEFloat *)&v600, (const llvm::detail::IEEEFloat *)&v592);
            }
            BOOL v168 = (v167 - 1) < 2;
            if (v592 == (_DWORD *)&unk_1CFB2E344)
            {
              sub_1CB845718(&v593);
            }
            else if ((v592[2] - 64) <= 0xFFFFFF7F && v593)
            {
              MEMORY[0x1D25D9CB0](v593, 0x1000C8000313F17);
            }
            if (v588 == (_DWORD *)&unk_1CFB2E344)
            {
              sub_1CB845718(&v589);
            }
            else if ((v588[2] - 64) <= 0xFFFFFF7F && v589)
            {
              MEMORY[0x1D25D9CB0](v589, 0x1000C8000313F17);
            }
            if (v600 == (_DWORD *)&unk_1CFB2E344)
            {
              sub_1CB845718(&v601);
            }
            else if ((v600[2] - 64) <= 0xFFFFFF7F && v601)
            {
              MEMORY[0x1D25D9CB0](v601, 0x1000C8000313F17);
            }
            if (v596 == (_DWORD *)&unk_1CFB2E344)
            {
              sub_1CB845718(&v597);
            }
            else if ((v596[2] - 64) <= 0xFFFFFF7F && v597)
            {
              MEMORY[0x1D25D9CB0](v597, 0x1000C8000313F17);
            }
          }
          if (v608 == (_DWORD *)&unk_1CFB2E344)
          {
            sub_1CB845718(&v609);
          }
          else if ((v608[2] - 64) <= 0xFFFFFF7F && v609)
          {
            MEMORY[0x1D25D9CB0](v609, 0x1000C8000313F17);
          }
          if (v604 == (_DWORD *)&unk_1CFB2E344)
          {
            sub_1CB845718(&v605);
          }
          else if ((v604[2] - 64) <= 0xFFFFFF7F && v605)
          {
            MEMORY[0x1D25D9CB0](v605, 0x1000C8000313F17);
          }
          if ((_UNKNOWN *)v617.__r_.__value_.__l.__size_ == &unk_1CFB2E344)
          {
            sub_1CB845718((uint64_t *)&v617.__r_.__value_.__r.__words[2]);
          }
          else if ((*(_DWORD *)(v617.__r_.__value_.__l.__size_ + 8) - 64) <= 0xFFFFFF7F {
                 && v617.__r_.__value_.__r.__words[2])
          }
          {
            MEMORY[0x1D25D9CB0](v617.__r_.__value_.__r.__words[2], 0x1000C8000313F17);
          }
          if (v613 == (_DWORD *)&unk_1CFB2E344)
          {
            sub_1CB845718((uint64_t *)&v614);
          }
          else if ((v613[2] - 64) <= 0xFFFFFF7F && v614)
          {
            MEMORY[0x1D25D9CB0](v614, 0x1000C8000313F17);
          }
          if (v168)
          {
            if (*((_UNKNOWN **)v98 + 4) == &unk_1CFB2E344) {
              uint64_t v232 = *((void *)v98 + 5);
            }
            else {
              uint64_t v232 = (uint64_t)v98 + 24;
            }
            char v233 = *(unsigned char *)(v232 + 28);
            if ((v233 & 8) != 0 && (v233 & 5 | 2) != 3)
            {
              size_t v404 = (llvm::Constant *)((char *)v41 + 32);
              if (*v11 == (int8x8_t *)&unk_1CFB2E344) {
                llvm::detail::DoubleAPFloat::DoubleAPFloat(&v617.__r_.__value_.__l.__size_, v404);
              }
              else {
                llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&v617.__r_.__value_.__l.__size_, v404);
              }
              if ((_UNKNOWN *)v617.__r_.__value_.__l.__size_ == &unk_1CFB2E344)
              {
                std::string::size_type v560 = v617.__r_.__value_.__r.__words[2];
                if (*(_UNKNOWN **)(v617.__r_.__value_.__r.__words[2] + 8) == &unk_1CFB2E344)
                {
                  llvm::detail::DoubleAPFloat::changeSign((llvm::detail::DoubleAPFloat *)(v617.__r_.__value_.__r.__words[2]
                                                                                        + 8));
                  std::string::size_type v560 = v617.__r_.__value_.__r.__words[2];
                }
                else
                {
                  *(unsigned char *)(v617.__r_.__value_.__r.__words[2] + 28) ^= 8u;
                }
                if (*(_UNKNOWN **)(v560 + 40) == &unk_1CFB2E344) {
                  llvm::detail::DoubleAPFloat::changeSign((llvm::detail::DoubleAPFloat *)(v560 + 40));
                }
                else {
                  *(unsigned char *)(v560 + 60) ^= 8u;
                }
              }
              else
              {
                v619 ^= 8u;
              }
              sub_1CB9190C0((uint64_t *)&v624, (void **)&v617.__r_.__value_.__l.__size_);
              if ((_UNKNOWN *)v617.__r_.__value_.__l.__size_ == &unk_1CFB2E344)
              {
                sub_1CB845718((uint64_t *)&v617.__r_.__value_.__r.__words[2]);
              }
              else if ((*(_DWORD *)(v617.__r_.__value_.__l.__size_ + 8) - 64) <= 0xFFFFFF7F {
                     && v617.__r_.__value_.__r.__words[2])
              }
              {
                MEMORY[0x1D25D9CB0](v617.__r_.__value_.__r.__words[2], 0x1000C8000313F17);
              }
              uint64_t v235 = 5;
            }
            else
            {
              BOOL v234 = (llvm::Constant *)*v11;
              if ((_UNKNOWN *)v624 == &unk_1CFB2E344 || v234 == (llvm::Constant *)&unk_1CFB2E344)
              {
                if ((_UNKNOWN *)v624 == &unk_1CFB2E344 && v234 == (llvm::Constant *)&unk_1CFB2E344)
                {
                  llvm::detail::DoubleAPFloat::operator=((const llvm::detail::DoubleAPFloat *)&v624, (llvm::Constant *)((char *)v41 + 32));
                }
                else if (&v624 != (long long *)v11)
                {
                  if ((_UNKNOWN *)v624 == &unk_1CFB2E344)
                  {
                    sub_1CB845718((uint64_t *)&v624 + 1);
                  }
                  else if ((*(_DWORD *)(v624 + 8) - 64) <= 0xFFFFFF7F && *((void *)&v624 + 1))
                  {
                    MEMORY[0x1D25D9CB0](*((void *)&v624 + 1), 0x1000C8000313F17);
                  }
                  if (*v11 == (int8x8_t *)&unk_1CFB2E344) {
                    llvm::detail::DoubleAPFloat::DoubleAPFloat(&v624, (llvm::Constant *)((char *)v41 + 32));
                  }
                  else {
                    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&v624, (llvm::Constant *)((char *)v41 + 32));
                  }
                }
                uint64_t v235 = 4;
              }
              else
              {
                llvm::detail::IEEEFloat::operator=(&v624, (void *)v41 + 4);
                uint64_t v235 = 4;
              }
            }
            unsigned int v236 = *(void **)v157;
            if (*((_UNKNOWN **)&__src + 1) == &unk_1CFB2E344 || v236 == &unk_1CFB2E344)
            {
              if (*((_UNKNOWN **)&__src + 1) == &unk_1CFB2E344 && v236 == &unk_1CFB2E344)
              {
                llvm::detail::DoubleAPFloat::operator=((const llvm::detail::DoubleAPFloat *)((char *)&__src + 8), (llvm::Constant *)((char *)v98 + 32));
              }
              else if ((const llvm::detail::DoubleAPFloat *)((char *)&__src + 8) != v157)
              {
                if (*((_UNKNOWN **)&__src + 1) == &unk_1CFB2E344)
                {
                  sub_1CB845718((uint64_t *)&v585);
                }
                else if ((*(_DWORD *)(*((void *)&__src + 1) + 8) - 64) <= 0xFFFFFF7F && v585)
                {
                  MEMORY[0x1D25D9CB0](v585, 0x1000C8000313F17);
                }
                if (*(_UNKNOWN **)v157 == &unk_1CFB2E344) {
                  llvm::detail::DoubleAPFloat::DoubleAPFloat((void *)&__src + 1, (llvm::Constant *)((char *)v98 + 32));
                }
                else {
                  llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&__src + 8, (llvm::Constant *)((char *)v98 + 32));
                }
              }
            }
            else
            {
              llvm::detail::IEEEFloat::operator=((void *)&__src + 1, (void *)v98 + 4);
            }
            unsigned int v238 = (void *)*((void *)v43 + 4);
            int v43 = (llvm::Constant *)((char *)v43 + 32);
            size_t v237 = v238;
            uint64_t v239 = v43;
          }
          else
          {
            int v99 = (_OWORD *)((char *)v43 + 32);
            uint64_t v240 = (llvm::Constant *)((char *)v43 + 32);
            if (*((_UNKNOWN **)v43 + 4) == &unk_1CFB2E344) {
              llvm::detail::DoubleAPFloat::DoubleAPFloat(&v608, v240);
            }
            else {
              llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&v608, v240);
            }
            if (v608 == (_DWORD *)&unk_1CFB2E344)
            {
              uint64_t v555 = v609;
              if ((*(unsigned char *)(v609 + 28) & 8) != 0)
              {
                if (*(_UNKNOWN **)(v609 + 8) == &unk_1CFB2E344)
                {
                  llvm::detail::DoubleAPFloat::changeSign((llvm::detail::DoubleAPFloat *)(v609 + 8));
                  uint64_t v555 = v609;
                }
                else
                {
                  *(unsigned char *)(v609 + 28) ^= 8u;
                }
                if (*(_UNKNOWN **)(v555 + 40) == &unk_1CFB2E344) {
                  llvm::detail::DoubleAPFloat::changeSign((llvm::detail::DoubleAPFloat *)(v555 + 40));
                }
                else {
                  *(unsigned char *)(v555 + 60) ^= 8u;
                }
              }
            }
            else if ((v611 & 8) != 0)
            {
              v611 ^= 8u;
            }
            std::string::size_type v241 = v609;
            if (v608 == (_DWORD *)&unk_1CFB2E344)
            {
              uint64_t v609 = 0;
            }
            else
            {
              int v618 = v610;
              char v619 = v619 & 0xF0 | v611 & 0xF;
            }
            v617.__r_.__value_.__l.__size_ = (std::string::size_type)v608;
            v617.__r_.__value_.__r.__words[2] = v241;
            uint64_t v608 = &unk_1CFB2E394;
            long long v242 = (llvm::Constant *)((char *)v41 + 32);
            if (*v11 == (int8x8_t *)&unk_1CFB2E344) {
              llvm::detail::DoubleAPFloat::DoubleAPFloat(&v592, v242);
            }
            else {
              llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&v592, v242);
            }
            if (v592 == (_DWORD *)&unk_1CFB2E344)
            {
              uint64_t v556 = v593;
              if ((*(unsigned char *)(v593 + 28) & 8) != 0)
              {
                if (*(_UNKNOWN **)(v593 + 8) == &unk_1CFB2E344)
                {
                  llvm::detail::DoubleAPFloat::changeSign((llvm::detail::DoubleAPFloat *)(v593 + 8));
                  uint64_t v556 = v593;
                }
                else
                {
                  *(unsigned char *)(v593 + 28) ^= 8u;
                }
                if (*(_UNKNOWN **)(v556 + 40) == &unk_1CFB2E344) {
                  llvm::detail::DoubleAPFloat::changeSign((llvm::detail::DoubleAPFloat *)(v556 + 40));
                }
                else {
                  *(unsigned char *)(v556 + 60) ^= 8u;
                }
              }
            }
            else if ((v595 & 8) != 0)
            {
              v595 ^= 8u;
            }
            uint64_t v243 = v593;
            if (v592 == (_DWORD *)&unk_1CFB2E344)
            {
              uint64_t v593 = 0;
            }
            else
            {
              int v602 = v594;
              char v603 = v603 & 0xF0 | v595 & 0xF;
            }
            v600 = v592;
            uint64_t v601 = v243;
            size_t v592 = &unk_1CFB2E394;
            if ((_UNKNOWN *)v617.__r_.__value_.__l.__size_ == &unk_1CFB2E344) {
              int v244 = llvm::detail::DoubleAPFloat::compare((llvm::detail::DoubleAPFloat *)&v617.__r_.__value_.__r.__words[1], (const llvm::detail::DoubleAPFloat *)&v600);
            }
            else {
              int v244 = llvm::detail::IEEEFloat::compare((llvm::detail::IEEEFloat *)&v617.__r_.__value_.__r.__words[1], (const llvm::detail::IEEEFloat *)&v600);
            }
            int v245 = v244;
            if (v600 == (_DWORD *)&unk_1CFB2E344)
            {
              sub_1CB845718(&v601);
            }
            else if ((v600[2] - 64) <= 0xFFFFFF7F && v601)
            {
              MEMORY[0x1D25D9CB0](v601, 0x1000C8000313F17);
            }
            if (v592 == (_DWORD *)&unk_1CFB2E344)
            {
              sub_1CB845718(&v593);
            }
            else if ((v592[2] - 64) <= 0xFFFFFF7F && v593)
            {
              MEMORY[0x1D25D9CB0](v593, 0x1000C8000313F17);
            }
            if ((_UNKNOWN *)v617.__r_.__value_.__l.__size_ == &unk_1CFB2E344)
            {
              sub_1CB845718((uint64_t *)&v617.__r_.__value_.__r.__words[2]);
            }
            else if ((*(_DWORD *)(v617.__r_.__value_.__l.__size_ + 8) - 64) <= 0xFFFFFF7F {
                   && v617.__r_.__value_.__r.__words[2])
            }
            {
              MEMORY[0x1D25D9CB0](v617.__r_.__value_.__r.__words[2], 0x1000C8000313F17);
            }
            unsigned int v246 = v245 - 1;
            if (v608 == (_DWORD *)&unk_1CFB2E344)
            {
              sub_1CB845718(&v609);
            }
            else if ((v608[2] - 64) <= 0xFFFFFF7F && v609)
            {
              MEMORY[0x1D25D9CB0](v609, 0x1000C8000313F17);
            }
            if (v246 <= 1)
            {
              if (*((_UNKNOWN **)v43 + 4) == &unk_1CFB2E344) {
                uint64_t v247 = *((void *)v43 + 5);
              }
              else {
                uint64_t v247 = (uint64_t)v43 + 24;
              }
              char v248 = *(unsigned char *)(v247 + 28);
              if ((v248 & 8) != 0 && (v248 & 5 | 2) != 3)
              {
                if (*(_UNKNOWN **)v157 == &unk_1CFB2E344) {
                  llvm::detail::DoubleAPFloat::DoubleAPFloat(&v617.__r_.__value_.__l.__size_, v157);
                }
                else {
                  llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&v617.__r_.__value_.__l.__size_, v157);
                }
                if ((_UNKNOWN *)v617.__r_.__value_.__l.__size_ == &unk_1CFB2E344)
                {
                  std::string::size_type v562 = v617.__r_.__value_.__r.__words[2];
                  if (*(_UNKNOWN **)(v617.__r_.__value_.__r.__words[2] + 8) == &unk_1CFB2E344)
                  {
                    llvm::detail::DoubleAPFloat::changeSign((llvm::detail::DoubleAPFloat *)(v617.__r_.__value_.__r.__words[2]
                                                                                          + 8));
                    std::string::size_type v562 = v617.__r_.__value_.__r.__words[2];
                  }
                  else
                  {
                    *(unsigned char *)(v617.__r_.__value_.__r.__words[2] + 28) ^= 8u;
                  }
                  if (*(_UNKNOWN **)(v562 + 40) == &unk_1CFB2E344) {
                    llvm::detail::DoubleAPFloat::changeSign((llvm::detail::DoubleAPFloat *)(v562 + 40));
                  }
                  else {
                    *(unsigned char *)(v562 + 60) ^= 8u;
                  }
                }
                else
                {
                  v619 ^= 8u;
                }
                sub_1CB9190C0((uint64_t *)&v620[8], (void **)&v617.__r_.__value_.__l.__size_);
                if ((_UNKNOWN *)v617.__r_.__value_.__l.__size_ == &unk_1CFB2E344)
                {
                  sub_1CB845718((uint64_t *)&v617.__r_.__value_.__r.__words[2]);
                }
                else if ((*(_DWORD *)(v617.__r_.__value_.__l.__size_ + 8) - 64) <= 0xFFFFFF7F {
                       && v617.__r_.__value_.__r.__words[2])
                }
                {
                  MEMORY[0x1D25D9CB0](v617.__r_.__value_.__r.__words[2], 0x1000C8000313F17);
                }
                uint64_t v235 = 3;
              }
              else
              {
                size_t v249 = *(void **)v157;
                if (*(_UNKNOWN **)&v620[8] == &unk_1CFB2E344 || v249 == &unk_1CFB2E344)
                {
                  if (*(_UNKNOWN **)&v620[8] == &unk_1CFB2E344 && v249 == &unk_1CFB2E344)
                  {
                    llvm::detail::DoubleAPFloat::operator=((const llvm::detail::DoubleAPFloat *)&v620[8], v157);
                  }
                  else if (&v620[8] != (unsigned char *)v157)
                  {
                    if (*(_UNKNOWN **)&v620[8] == &unk_1CFB2E344)
                    {
                      sub_1CB845718((uint64_t *)&v620[16]);
                    }
                    else if ((*(_DWORD *)(*(void *)&v620[8] + 8) - 64) <= 0xFFFFFF7F {
                           && *(void *)&v620[16])
                    }
                    {
                      MEMORY[0x1D25D9CB0](*(void *)&v620[16], 0x1000C8000313F17);
                    }
                    if (*(_UNKNOWN **)v157 == &unk_1CFB2E344) {
                      llvm::detail::DoubleAPFloat::DoubleAPFloat(&v620[8], v157);
                    }
                    else {
                      llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&v620[8], v157);
                    }
                  }
                  uint64_t v235 = 2;
                }
                else
                {
                  llvm::detail::IEEEFloat::operator=(&v620[8], v157);
                  uint64_t v235 = 2;
                }
              }
              size_t v250 = *(void **)v99;
              if (*((_UNKNOWN **)&__src + 1) == &unk_1CFB2E344 || v250 == &unk_1CFB2E344)
              {
                if (*((_UNKNOWN **)&__src + 1) == &unk_1CFB2E344 && v250 == &unk_1CFB2E344)
                {
                  llvm::detail::DoubleAPFloat::operator=((const llvm::detail::DoubleAPFloat *)((char *)&__src + 8), (llvm::Constant *)((char *)v43 + 32));
                }
                else if ((long long *)((char *)&__src + 8) != v99)
                {
                  if (*((_UNKNOWN **)&__src + 1) == &unk_1CFB2E344)
                  {
                    sub_1CB845718((uint64_t *)&v585);
                  }
                  else if ((*(_DWORD *)(*((void *)&__src + 1) + 8) - 64) <= 0xFFFFFF7F && v585)
                  {
                    MEMORY[0x1D25D9CB0](v585, 0x1000C8000313F17);
                  }
                  if (*(_UNKNOWN **)v99 == &unk_1CFB2E344) {
                    llvm::detail::DoubleAPFloat::DoubleAPFloat((void *)&__src + 1, (llvm::Constant *)((char *)v43 + 32));
                  }
                  else {
                    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&__src + 8, (llvm::Constant *)((char *)v43 + 32));
                  }
                }
              }
              else
              {
                llvm::detail::IEEEFloat::operator=((void *)&__src + 1, (void *)v43 + 4);
              }
              unint64_t v251 = (llvm::Constant *)*v11;
              if ((_UNKNOWN *)v624 == &unk_1CFB2E344 || v251 == (llvm::Constant *)&unk_1CFB2E344)
              {
                if ((_UNKNOWN *)v624 == &unk_1CFB2E344 && v251 == (llvm::Constant *)&unk_1CFB2E344)
                {
                  llvm::detail::DoubleAPFloat::operator=((const llvm::detail::DoubleAPFloat *)&v624, (llvm::Constant *)((char *)v41 + 32));
                }
                else
                {
                  uint64_t v252 = &v624;
                  if (&v624 != (long long *)v11)
                  {
                    if ((_UNKNOWN *)v624 == &unk_1CFB2E344)
                    {
                      sub_1CB845718((uint64_t *)&v624 + 1);
                    }
                    else if ((*(_DWORD *)(v624 + 8) - 64) <= 0xFFFFFF7F && *((void *)&v624 + 1))
                    {
                      MEMORY[0x1D25D9CB0](*((void *)&v624 + 1), 0x1000C8000313F17);
                    }
                    if (*v11 == (int8x8_t *)&unk_1CFB2E344) {
                      llvm::detail::DoubleAPFloat::DoubleAPFloat(&v624, (llvm::Constant *)((char *)v41 + 32));
                    }
                    else {
                      llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&v624, (llvm::Constant *)((char *)v41 + 32));
                    }
                  }
                }
              }
              else
              {
                llvm::detail::IEEEFloat::operator=(&v624, (void *)v41 + 4);
              }
              goto LABEL_613;
            }
            uint64_t v290 = (char *)v41 + 24;
            if (*((_UNKNOWN **)v41 + 4) == &unk_1CFB2E344) {
              uint64_t v290 = (char *)*((void *)v41 + 5);
            }
            char v291 = v290[28];
            if ((v291 & 8) != 0 && (v291 & 5 | 2) != 3)
            {
              v430 = *(void **)v157;
              if ((_UNKNOWN *)v624 == &unk_1CFB2E344 || v430 == &unk_1CFB2E344)
              {
                if ((_UNKNOWN *)v624 == &unk_1CFB2E344 && v430 == &unk_1CFB2E344)
                {
                  llvm::detail::DoubleAPFloat::operator=((const llvm::detail::DoubleAPFloat *)&v624, v157);
                }
                else if (&v624 != (long long *)v157)
                {
                  if ((_UNKNOWN *)v624 == &unk_1CFB2E344)
                  {
                    sub_1CB845718((uint64_t *)&v624 + 1);
                  }
                  else if ((*(_DWORD *)(v624 + 8) - 64) <= 0xFFFFFF7F && *((void *)&v624 + 1))
                  {
                    MEMORY[0x1D25D9CB0](*((void *)&v624 + 1), 0x1000C8000313F17);
                  }
                  if (*(_UNKNOWN **)v157 == &unk_1CFB2E344) {
                    llvm::detail::DoubleAPFloat::DoubleAPFloat(&v624, v157);
                  }
                  else {
                    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&v624, v157);
                  }
                }
                uint64_t v235 = 1;
              }
              else
              {
                llvm::detail::IEEEFloat::operator=(&v624, v157);
                uint64_t v235 = 1;
              }
            }
            else
            {
              if (*(_UNKNOWN **)v157 == &unk_1CFB2E344) {
                llvm::detail::DoubleAPFloat::DoubleAPFloat(&v617.__r_.__value_.__l.__size_, v157);
              }
              else {
                llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&v617.__r_.__value_.__l.__size_, v157);
              }
              if ((_UNKNOWN *)v617.__r_.__value_.__l.__size_ == &unk_1CFB2E344)
              {
                std::string::size_type v559 = v617.__r_.__value_.__r.__words[2];
                if (*(_UNKNOWN **)(v617.__r_.__value_.__r.__words[2] + 8) == &unk_1CFB2E344)
                {
                  llvm::detail::DoubleAPFloat::changeSign((llvm::detail::DoubleAPFloat *)(v617.__r_.__value_.__r.__words[2]
                                                                                        + 8));
                  std::string::size_type v559 = v617.__r_.__value_.__r.__words[2];
                }
                else
                {
                  *(unsigned char *)(v617.__r_.__value_.__r.__words[2] + 28) ^= 8u;
                }
                if (*(_UNKNOWN **)(v559 + 40) == &unk_1CFB2E344) {
                  llvm::detail::DoubleAPFloat::changeSign((llvm::detail::DoubleAPFloat *)(v559 + 40));
                }
                else {
                  *(unsigned char *)(v559 + 60) ^= 8u;
                }
              }
              else
              {
                v619 ^= 8u;
              }
              sub_1CB9190C0((uint64_t *)&v624, (void **)&v617.__r_.__value_.__l.__size_);
              if ((_UNKNOWN *)v617.__r_.__value_.__l.__size_ == &unk_1CFB2E344)
              {
                sub_1CB845718((uint64_t *)&v617.__r_.__value_.__r.__words[2]);
              }
              else if ((*(_DWORD *)(v617.__r_.__value_.__l.__size_ + 8) - 64) <= 0xFFFFFF7F {
                     && v617.__r_.__value_.__r.__words[2])
              }
              {
                MEMORY[0x1D25D9CB0](v617.__r_.__value_.__r.__words[2], 0x1000C8000313F17);
              }
              uint64_t v235 = 0;
            }
            uint64_t v292 = (llvm::Constant *)*v11;
            if (*((_UNKNOWN **)&__src + 1) == &unk_1CFB2E344 || v292 == (llvm::Constant *)&unk_1CFB2E344)
            {
              if (*((_UNKNOWN **)&__src + 1) == &unk_1CFB2E344 && v292 == (llvm::Constant *)&unk_1CFB2E344)
              {
                llvm::detail::DoubleAPFloat::operator=((const llvm::detail::DoubleAPFloat *)((char *)&__src + 8), (llvm::Constant *)((char *)v41 + 32));
              }
              else if ((int8x8_t **)((char *)&__src + 8) != v11)
              {
                if (*((_UNKNOWN **)&__src + 1) == &unk_1CFB2E344)
                {
                  sub_1CB845718((uint64_t *)&v585);
                }
                else if ((*(_DWORD *)(*((void *)&__src + 1) + 8) - 64) <= 0xFFFFFF7F && v585)
                {
                  MEMORY[0x1D25D9CB0](v585, 0x1000C8000313F17);
                }
                if (*v11 == (int8x8_t *)&unk_1CFB2E344) {
                  llvm::detail::DoubleAPFloat::DoubleAPFloat((void *)&__src + 1, (llvm::Constant *)((char *)v41 + 32));
                }
                else {
                  llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&__src + 8, (llvm::Constant *)((char *)v41 + 32));
                }
              }
            }
            else
            {
              llvm::detail::IEEEFloat::operator=((void *)&__src + 1, (void *)v41 + 4);
            }
            size_t v237 = *(void **)v99;
            uint64_t v239 = (llvm::Constant *)((char *)v43 + 32);
          }
          if (v237 == &unk_1CFB2E344) {
            llvm::detail::DoubleAPFloat::DoubleAPFloat(&v617.__r_.__value_.__l.__size_, v239);
          }
          else {
            llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&v617.__r_.__value_.__l.__size_, v239);
          }
          if ((_UNKNOWN *)v617.__r_.__value_.__l.__size_ == &unk_1CFB2E344)
          {
            std::string::size_type v552 = v617.__r_.__value_.__r.__words[2];
            if (*(_UNKNOWN **)(v617.__r_.__value_.__r.__words[2] + 8) == &unk_1CFB2E344)
            {
              llvm::detail::DoubleAPFloat::changeSign((llvm::detail::DoubleAPFloat *)(v617.__r_.__value_.__r.__words[2]
                                                                                    + 8));
              std::string::size_type v552 = v617.__r_.__value_.__r.__words[2];
            }
            else
            {
              *(unsigned char *)(v617.__r_.__value_.__r.__words[2] + 28) ^= 8u;
            }
            if (*(_UNKNOWN **)(v552 + 40) == &unk_1CFB2E344) {
              llvm::detail::DoubleAPFloat::changeSign((llvm::detail::DoubleAPFloat *)(v552 + 40));
            }
            else {
              *(unsigned char *)(v552 + 60) ^= 8u;
            }
          }
          else
          {
            v619 ^= 8u;
          }
          sub_1CB9190C0((uint64_t *)&v620[8], (void **)&v617.__r_.__value_.__l.__size_);
          if ((_UNKNOWN *)v617.__r_.__value_.__l.__size_ == &unk_1CFB2E344)
          {
            sub_1CB845718((uint64_t *)&v617.__r_.__value_.__r.__words[2]);
          }
          else if ((*(_DWORD *)(v617.__r_.__value_.__l.__size_ + 8) - 64) <= 0xFFFFFF7F {
                 && v617.__r_.__value_.__r.__words[2])
          }
          {
            MEMORY[0x1D25D9CB0](v617.__r_.__value_.__r.__words[2], 0x1000C8000313F17);
          }
LABEL_613:
          switch(v152)
          {
            case 0:
              if ((_UNKNOWN *)v153 == &unk_1CFB2E344) {
                llvm::detail::DoubleAPFloat::DoubleAPFloat(&v617.__r_.__value_.__l.__size_, (uint64_t)&unk_1CFB2E344);
              }
              v617.__r_.__value_.__l.__size_ = v153;
              if ((*(_DWORD *)(v153 + 8) + 64) >= 0x80) {
                operator new[]();
              }
              char v619 = v619 & 0xF0 | 2;
              int v293 = *(_DWORD *)(v153 + 8);
              if ((v293 - 64) < 0xFFFFFF80)
              {
                std::string::size_type v557 = v617.__r_.__value_.__r.__words[2];
                *(void *)v617.__r_.__value_.__r.__words[2] = 0;
                bzero((void *)(v557 + 8), 8 * (((v293 + 64) >> 6) - 2) + 8);
                uint64_t v294 = (uint64_t *)v617.__r_.__value_.__r.__words[2];
              }
              else
              {
                uint64_t v294 = (uint64_t *)&v617.__r_.__value_.__r.__words[2];
                v617.__r_.__value_.__r.__words[2] = 0;
              }
              int v618 = *(_DWORD *)(v153 + 8) - 1;
              uint64_t *v294 = v235;
              llvm::detail::IEEEFloat::normalize((llvm::detail::IEEEFloat *)&v617.__r_.__value_.__r.__words[1], 1, 0);
              goto LABEL_628;
            case 1:
              if (*((_UNKNOWN **)&__src + 1) == &unk_1CFB2E344) {
                llvm::detail::DoubleAPFloat::DoubleAPFloat(&v617.__r_.__value_.__l.__size_, (const llvm::detail::DoubleAPFloat *)((char *)&__src + 8));
              }
              else {
                llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&v617.__r_.__value_.__l.__size_, (const llvm::detail::IEEEFloat *)((char *)&__src + 8));
              }
              sub_1CB88A708((uint64_t)&v617, (uint64_t)&__src, 1);
              goto LABEL_628;
            case 2:
              if ((_UNKNOWN *)v624 == &unk_1CFB2E344)
              {
                v617.__r_.__value_.__l.__size_ = (std::string::size_type)&unk_1CFB2E344;
                v617.__r_.__value_.__r.__words[2] = *((void *)&v624 + 1);
                *((void *)&v624 + 1) = 0;
              }
              else
              {
                *(_OWORD *)&v617.__r_.__value_.__r.__words[1] = v624;
                int v618 = v625;
                char v619 = v619 & 0xF0 | v626 & 0xF;
              }
              *(void *)&long long v624 = &unk_1CFB2E394;
LABEL_628:
              int v295 = v582;
              int v296 = *(_DWORD **)&v620[8];
              if (*(_UNKNOWN **)&v620[8] != &unk_1CFB2E344) {
                goto LABEL_629;
              }
              sub_1CB845718((uint64_t *)&v620[16]);
              goto LABEL_1438;
            case 3:
              if (*(_UNKNOWN **)&v620[8] == &unk_1CFB2E344)
              {
                std::string::size_type v558 = *(void *)&v620[16];
                *(void *)&v620[16] = 0;
                v617.__r_.__value_.__l.__size_ = (std::string::size_type)&unk_1CFB2E344;
                v617.__r_.__value_.__r.__words[2] = v558;
              }
              else
              {
                *(_OWORD *)&v617.__r_.__value_.__r.__words[1] = *(_OWORD *)&v620[8];
                int v618 = v621;
                char v619 = v619 & 0xF0 | v622 & 0xF;
              }
              int v295 = v582;
              int v296 = &unk_1CFB2E394;
              *(void *)&v620[8] = &unk_1CFB2E394;
LABEL_629:
              if ((v296[2] - 64) > 0xFFFFFF7F || !*(void *)&v620[16]) {
                goto LABEL_630;
              }
              MEMORY[0x1D25D9CB0](*(void *)&v620[16], 0x1000C8000313F17);
LABEL_1438:
              int v295 = v582;
LABEL_630:
              if ((_UNKNOWN *)v624 == &unk_1CFB2E344)
              {
                sub_1CB845718((uint64_t *)&v624 + 1);
LABEL_1418:
                int v295 = v582;
                goto LABEL_632;
              }
              if ((*(_DWORD *)(v624 + 8) - 64) <= 0xFFFFFF7F && *((void *)&v624 + 1))
              {
                MEMORY[0x1D25D9CB0](*((void *)&v624 + 1), 0x1000C8000313F17);
                goto LABEL_1418;
              }
LABEL_632:
              if (*((_UNKNOWN **)&__src + 1) == &unk_1CFB2E344)
              {
                sub_1CB845718((uint64_t *)&v585);
              }
              else
              {
                if ((*(_DWORD *)(*((void *)&__src + 1) + 8) - 64) > 0xFFFFFF7F || !v585) {
                  goto LABEL_634;
                }
                MEMORY[0x1D25D9CB0](v585, 0x1000C8000313F17);
              }
              int v295 = v582;
LABEL_634:
              int v221 = &v617;
              int v21 = llvm::ConstantFP::get(*v295, (llvm::LLVMContext *)&v617, a3);
              if ((_UNKNOWN *)v617.__r_.__value_.__l.__size_ == &unk_1CFB2E344)
              {
LABEL_1368:
                uint64_t v437 = (uint64_t *)&v221->__r_.__value_.__r.__words[2];
                goto LABEL_1714;
              }
              if ((*(_DWORD *)(v617.__r_.__value_.__l.__size_ + 8) - 64) > 0xFFFFFF7F
                || !v617.__r_.__value_.__r.__words[2])
              {
                return v21;
              }
              goto LABEL_1359;
            default:
              if (&unk_1CFB2E344 - 142 < 2) {
                goto LABEL_395;
              }
              if (&unk_1CFB2E344 != 2922) {
                break;
              }
              if (*((_UNKNOWN **)v41 + 4) == &unk_1CFB2E344) {
                uint64_t v252 = (long long *)*((void *)v41 + 5);
              }
              if ((*((unsigned char *)v252 + 28) & 7) == 3) {
                goto LABEL_525;
              }
              uint64_t v253 = v235;
              if (*((_UNKNOWN **)v43 + 4) == &unk_1CFB2E344) {
                uint64_t v253 = *((void *)v43 + 5);
              }
              if ((*(unsigned char *)(v253 + 28) & 7) == 3)
              {
LABEL_525:
                uint64_t v254 = *(llvm::ConstantFP **)a4;
                *(_DWORD *)&v620[8] = 32;
                *(void *)v620 = 0;
                llvm::detail::IEEEFloat::initFromFloatAPInt((llvm::detail::IEEEFloat *)&__src, (const llvm::APInt **)v620);
                long long v624 = __src;
                int v625 = (int)v585;
                char v626 = BYTE4(v585) & 0xF;
                if ((_UNKNOWN *)__src == &unk_1CFB2E344) {
                  llvm::detail::DoubleAPFloat::DoubleAPFloat((void *)&__src + 1, (const llvm::detail::DoubleAPFloat *)&v624);
                }
                else {
                  llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&__src + 8, (const llvm::detail::IEEEFloat *)&v624);
                }
                sub_1CB88A708((uint64_t)&__src, (uint64_t)v99, 1);
                int v21 = llvm::ConstantFP::get(v254, (llvm::LLVMContext *)&__src, v255);
                if (*((_UNKNOWN **)&__src + 1) == &unk_1CFB2E344)
                {
                  sub_1CB845718((uint64_t *)&v585);
                }
                else if ((*(_DWORD *)(*((void *)&__src + 1) + 8) - 64) <= 0xFFFFFF7F && v585)
                {
                  MEMORY[0x1D25D9CB0](v585, 0x1000C8000313F17);
                }
                uint64_t v256 = v624;
                if ((_UNKNOWN *)v624 == &unk_1CFB2E344)
                {
                  uint64_t v437 = (uint64_t *)&v624 + 1;
                  goto LABEL_1714;
                }
                goto LABEL_530;
              }
LABEL_395:
              unsigned int v202 = (llvm::Constant *)((char *)v41 + 32);
              if (*((_UNKNOWN **)v41 + 4) == &unk_1CFB2E344) {
                llvm::detail::DoubleAPFloat::DoubleAPFloat((void *)&__src + 1, v202);
              }
              else {
                llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&__src + 8, v202);
              }
              int v203 = (unint64_t *)&__src;
              sub_1CB8DA0F4((uint64_t)&__src, v235, (uint64_t)v99, 1);
              int v21 = llvm::ConstantFP::get(*v582, (llvm::LLVMContext *)&__src, v204);
              uint64_t v192 = *((void *)&__src + 1);
              if (*((_UNKNOWN **)&__src + 1) != &unk_1CFB2E344) {
                goto LABEL_1710;
              }
              goto LABEL_1069;
          }
        }
      }
    }
  }
  if ((v12 & 0xFFFFFFFE) == 0x114)
  {
    int v45 = (*v11)[2].u8[0];
    if (v45 == 12 || (uint64_t v46 = v11[1], v47 = v46[2].u8[0], v47 == 12))
    {
      return (const llvm::detail::DoubleAPFloat *)llvm::PoisonValue::get((llvm::PoisonValue *)a4, a2);
    }
    if (v45 == 16) {
      uint64_t v136 = (uint64_t)&(*v11)[3];
    }
    else {
      uint64_t v136 = 0;
    }
    if (v45 != 16 && v45 != 11) {
      return 0;
    }
    int v138 = v46 + 3;
    uint64_t v139 = v47 == 16 ? (uint64_t)v138 : 0;
    if (v47 != 16 && v47 != 11) {
      return 0;
    }
    if (v45 != 16 || v47 != 16)
    {
      return llvm::Constant::getNullValue((llvm::Constant *)a4, a2, a3);
    }
    uint64_t v205 = v11[2];
    size_t v206 = v205 + 3;
    if (v205[4].i32[0] >= 0x41u) {
      size_t v206 = (int8x8_t *)*v206;
    }
    BOOL v207 = (int8x8_t *)*v206;
    unsigned int v208 = *(_DWORD *)(v136 + 8);
    unsigned int v209 = 2 * v208;
    char v210 = v208 - 1;
    if ((int)v208 >= 1)
    {
      uint64_t v309 = a4;
      llvm::APInt::sext(v136, 2 * v208, (uint64_t)v620);
      a4 = v309;
    }
    else
    {
      *(_DWORD *)&v620[8] = *(_DWORD *)(v136 + 8);
      if (v208) {
        operator new[]();
      }
      *(void *)v620 = *(void *)v136;
    }
    unsigned int v310 = *(_DWORD *)(v139 + 8);
    uint64_t v311 = (llvm::ConstantInt **)a4;
    if (v310 < v209)
    {
      llvm::APInt::sext(v139, 2 * v208, (uint64_t)&v617);
    }
    else
    {
      LODWORD(v617.__r_.__value_.__r.__words[1]) = *(_DWORD *)(v139 + 8);
      if (v310 > 0x40) {
        operator new[]();
      }
      v617.__r_.__value_.__r.__words[0] = *(void *)v139;
    }
    llvm::APInt::operator*((uint64_t)v620, &v617, (uint64_t)&v623);
    DWORD2(__src) = v624;
    if (v624 > 0x40) {
      operator new[]();
    }
    int v312 = v311;
    char v313 = (char)v207;
    if (v624 == v207) {
      char v313 = 63;
    }
    uint64_t v314 = (uint64_t)(v623 << -(char)v624) >> -(char)v624 >> v313;
    if (v624) {
      unint64_t v315 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v624;
    }
    else {
      unint64_t v315 = 0;
    }
    *(void *)&long long __src = v315 & v314;
    if (LODWORD(v617.__r_.__value_.__r.__words[1]) >= 0x41 && v617.__r_.__value_.__r.__words[0])
    {
      MEMORY[0x1D25D9CB0](v617.__r_.__value_.__r.__words[0], 0x1000C8000313F17);
      int v312 = v311;
    }
    if (*(_DWORD *)&v620[8] >= 0x41u && *(void *)v620)
    {
      uint64_t v316 = v312;
      MEMORY[0x1D25D9CB0](*(void *)v620, 0x1000C8000313F17);
      int v312 = v316;
    }
    if (v12 != 277)
    {
LABEL_1148:
      uint64_t v479 = *v312;
      llvm::APInt::sextOrTrunc((uint64_t)&__src, v208, (uint64_t)&v623);
      int v21 = (llvm::Constant *)llvm::ConstantInt::get(v479, (llvm::LLVMContext *)&v623, v480);
      if (v624 >= 0x41 && v623) {
        MEMORY[0x1D25D9CB0](v623, 0x1000C8000313F17);
      }
LABEL_1357:
      if (DWORD2(__src) < 0x41 || !(void)__src) {
        return v21;
      }
      goto LABEL_1359;
    }
    *(_DWORD *)&v620[8] = v208;
    if (v208 > 0x40) {
      llvm::APInt::initSlowCase((llvm::APInt *)v620);
    }
    if (v208) {
      unint64_t v317 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v208;
    }
    else {
      unint64_t v317 = 0;
    }
    *(void *)v620 = v317 & ~(1 << v210);
    if (*(_DWORD *)&v620[8] < v209)
    {
      v390 = v312;
      llvm::APInt::sext((uint64_t)v620, 2 * v208, (uint64_t)&v623);
      int v312 = v390;
    }
    else
    {
      LODWORD(v624) = *(_DWORD *)&v620[8];
      if (*(_DWORD *)&v620[8] > 0x40u) {
        operator new[]();
      }
      unint64_t v623 = *(void *)v620;
    }
    if (*(_DWORD *)&v620[8] >= 0x41u && *(void *)v620)
    {
      uint64_t v391 = v312;
      MEMORY[0x1D25D9CB0](*(void *)v620, 0x1000C8000313F17);
      int v312 = v391;
    }
    LODWORD(v617.__r_.__value_.__r.__words[1]) = v208;
    v617.__r_.__value_.__r.__words[0] = 1 << v210;
    if (v208 < v209)
    {
      uint64_t v392 = v312;
      llvm::APInt::sext((uint64_t)&v617, 2 * v208, (uint64_t)v620);
      int v312 = v392;
    }
    else
    {
      *(_DWORD *)&v620[8] = v617.__r_.__value_.__r.__words[1];
      *(void *)v620 = v617.__r_.__value_.__r.__words[0];
    }
    if (LODWORD(v617.__r_.__value_.__r.__words[1]) >= 0x41 && v617.__r_.__value_.__r.__words[0])
    {
      unsigned int v393 = v312;
      MEMORY[0x1D25D9CB0](v617.__r_.__value_.__r.__words[0], 0x1000C8000313F17);
      int v312 = v393;
    }
    unsigned int v394 = DWORD2(__src);
    if (DWORD2(__src) > 0x40)
    {
      v472 = v312;
      uint64_t v473 = *(void *)(__src + 8 * ((DWORD2(__src) - 1) >> 6)) & (1 << (BYTE8(__src) - 1));
      unsigned int v397 = v624;
      int v474 = (unint64_t *)(v623 + 8 * ((v624 - 1) >> 6));
      if (v624 < 0x41) {
        int v474 = &v623;
      }
      if ((v473 != 0) == ((*v474 >> (v624 - 1)) & 1))
      {
        unint64_t v484 = (((unint64_t)DWORD2(__src) + 63) >> 3) & 0x3FFFFFF8;
        do
        {
          if (!v484)
          {
            int v312 = v472;
            goto LABEL_1171;
          }
          unint64_t v485 = *(void *)(__src - 8 + v484);
          unint64_t v486 = *(void *)(v623 - 8 + v484);
          v484 -= 8;
        }
        while (v485 == v486);
        int v312 = v472;
        if (v485 <= v486) {
          goto LABEL_1173;
        }
      }
      else
      {
        int v312 = v472;
        if (v473) {
          goto LABEL_1134;
        }
      }
    }
    else
    {
      uint64_t v395 = (uint64_t)((void)__src << -BYTE8(__src)) >> -BYTE8(__src);
      uint64_t v396 = (uint64_t)(v623 << -BYTE8(__src)) >> -BYTE8(__src);
      unsigned int v397 = v624;
      if (v395 >= v396) {
        unsigned int v398 = v624;
      }
      else {
        unsigned int v398 = DWORD2(__src);
      }
      if (v398 < 0x41)
      {
        if (v395 >= v396) {
          unint64_t v399 = v623;
        }
        else {
          unint64_t v399 = __src;
        }
        *(void *)&long long __src = v399;
        DWORD2(__src) = v398;
        BOOL v400 = (uint64_t)(v399 << -(char)v398) >> -(char)v398 > (uint64_t)(*(void *)v620 << -(char)v398) >> -(char)v398;
        unsigned int v394 = v398;
LABEL_911:
        if (v400) {
          int v402 = &__src;
        }
        else {
          int v402 = (long long *)v620;
        }
        unsigned int v403 = *(_DWORD *)&v620[8];
        if (!v400) {
          unsigned int v394 = *(_DWORD *)&v620[8];
        }
        if (v394 <= 0x40)
        {
          *(void *)&long long __src = *(void *)v402;
          DWORD2(__src) = v394;
LABEL_1142:
          if (v403 >= 0x41 && *(void *)v620)
          {
            size_t v477 = v312;
            MEMORY[0x1D25D9CB0](*(void *)v620, 0x1000C8000313F17);
            int v312 = v477;
          }
          if (v624 >= 0x41 && v623)
          {
            size_t v478 = v312;
            MEMORY[0x1D25D9CB0](v623, 0x1000C8000313F17);
            int v312 = v478;
          }
          goto LABEL_1148;
        }
LABEL_1140:
        if (&__src != v402)
        {
LABEL_1213:
          uint64_t v497 = v312;
          llvm::APInt::reallocate((uint64_t)&__src, *((_DWORD *)v402 + 2));
          if (DWORD2(__src) <= 0x40) {
            *(void *)&long long __src = *(void *)v402;
          }
          else {
            memcpy((void *)__src, *(const void **)v402, (((unint64_t)DWORD2(__src) + 63) >> 3) & 0x3FFFFFF8);
          }
          int v312 = v497;
        }
        unsigned int v403 = *(_DWORD *)&v620[8];
        goto LABEL_1142;
      }
      if (v395 < v396) {
        goto LABEL_909;
      }
    }
LABEL_1171:
    v487 = v312;
    llvm::APInt::reallocate((uint64_t)&__src, v397);
    unsigned int v394 = DWORD2(__src);
    if (DWORD2(__src) <= 0x40)
    {
      unint64_t v401 = v623;
      *(void *)&long long __src = v623;
      int v312 = v487;
      goto LABEL_910;
    }
    memcpy((void *)__src, (const void *)v623, (((unint64_t)DWORD2(__src) + 63) >> 3) & 0x3FFFFFF8);
    unsigned int v394 = DWORD2(__src);
    int v312 = v487;
LABEL_1173:
    if (v394 <= 0x40)
    {
LABEL_909:
      unint64_t v401 = __src;
LABEL_910:
      BOOL v400 = (uint64_t)(v401 << -(char)v394) >> -(char)v394 > (uint64_t)(*(void *)v620 << -(char)v394) >> -(char)v394;
      goto LABEL_911;
    }
LABEL_1134:
    uint64_t v475 = *(void *)(__src + 8 * ((v394 - 1) >> 6)) & (1 << (v394 - 1));
    v476 = (void *)(*(void *)v620 + 8 * ((*(_DWORD *)&v620[8] - 1) >> 6));
    if (*(_DWORD *)&v620[8] < 0x41u) {
      v476 = v620;
    }
    if ((v475 != 0) == ((*v476 >> (v620[8] - 1)) & 1))
    {
      unint64_t v494 = (((unint64_t)v394 + 63) >> 3) & 0x3FFFFFF8;
      do
      {
        if (!v494)
        {
          int v402 = (long long *)v620;
          goto LABEL_1213;
        }
        unint64_t v495 = *(void *)(__src - 8 + v494);
        unint64_t v496 = *(void *)(*(void *)v620 - 8 + v494);
        v494 -= 8;
      }
      while (v495 == v496);
      if (v495 <= v496) {
        int v402 = (long long *)v620;
      }
      else {
        int v402 = &__src;
      }
    }
    else if (v475)
    {
      int v402 = (long long *)v620;
    }
    else
    {
      int v402 = &__src;
    }
    goto LABEL_1140;
  }
  if ((v12 & 0xFFFFFFFE) == 0x94)
  {
    uint64_t v49 = (llvm::Constant *)*v11;
    int v50 = (*v11)[2].u8[0];
    if (*v11) {
      BOOL v51 = v50 == 16;
    }
    else {
      BOOL v51 = 0;
    }
    int v52 = v51;
    if (!v51 && (v50 - 11) > 1) {
      return 0;
    }
    uint64_t v53 = v11[1];
    int v54 = v53[2].u8[0];
    BOOL v55 = v53 != 0 && v54 == 16;
    if (v53 != 0 && v54 == 16) {
      unsigned int v56 = v53 + 3;
    }
    else {
      unsigned int v56 = 0;
    }
    if (v53 == 0 || v54 != 16)
    {
      int v21 = 0;
      if ((v54 - 11) > 1) {
        return v21;
      }
    }
    char v57 = v11[2];
    int v58 = v57[2].u8[0];
    BOOL v59 = v57 && v58 == 16;
    BOOL v60 = v59;
    if (!v59 && (v58 - 11) > 1) {
      return 0;
    }
    if (!v60) {
      return (const llvm::detail::DoubleAPFloat *)v11[v12 == 149];
    }
    if ((v52 | v55))
    {
      uint64_t v581 = a4;
      unsigned int v61 = v57[4].u32[0];
      unsigned int v62 = llvm::APInt::urem((uint64_t **)&v57[3], v61);
      if (v62)
      {
        unsigned int v64 = v61 - v62;
        if (v12 == 149) {
          unsigned int v65 = v62;
        }
        else {
          unsigned int v65 = v61 - v62;
        }
        if (v12 == 149) {
          unsigned int v66 = v64;
        }
        else {
          unsigned int v66 = v62;
        }
        if (v52)
        {
          if (v55)
          {
            unsigned int v67 = *((_DWORD *)v49 + 8);
            LODWORD(v624) = v67;
            if (v67 > 0x40) {
              operator new[]();
            }
            uint64_t v68 = *((void *)v49 + 3) << v66;
            if (v67 == v66) {
              uint64_t v68 = 0;
            }
            if (v67) {
              unint64_t v69 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v67;
            }
            else {
              unint64_t v69 = 0;
            }
            unint64_t v623 = v69 & v68;
            unsigned int v468 = v53[4].u32[0];
            *(_DWORD *)&v620[8] = v468;
            if (v468 > 0x40) {
              operator new[]();
            }
            if (v468 == v65)
            {
              uint64_t v469 = 0;
              unsigned int v468 = v65;
            }
            else
            {
              uint64_t v469 = *(void *)&v53[3] >> v65;
            }
            unint64_t v470 = v623;
            DWORD2(__src) = v468;
            *(void *)&long long __src = v469 | v623;
            uint64_t v471 = (llvm::Constant *)llvm::ConstantInt::get(*(llvm::ConstantInt **)v581, (llvm::LLVMContext *)&__src, v63);
            int v21 = v471;
            if ((*(_DWORD *)(v581 + 8) & 0xFE) == 0x12) {
              int v21 = llvm::ConstantVector::getSplat((llvm::Type *)(*(unsigned int *)(v581 + 32) | ((unint64_t)(*(_DWORD *)(v581 + 8) == 19) << 32)), (uint64_t)v471);
            }
            if (DWORD2(__src) >= 0x41 && (void)__src) {
              MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
            }
            if (v624 < 0x41 || !v470) {
              return v21;
            }
            goto LABEL_1359;
          }
          unsigned int v438 = *((_DWORD *)v49 + 8);
          DWORD2(__src) = v438;
          if (v438 > 0x40) {
            operator new[]();
          }
          uint64_t v439 = *((void *)v49 + 3) << v66;
          if (v438 == v66) {
            uint64_t v439 = 0;
          }
          if (v438) {
            unint64_t v440 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v438;
          }
          else {
            unint64_t v440 = 0;
          }
          *(void *)&long long __src = v440 & v439;
          uint64_t v425 = *(llvm::ConstantInt **)v581;
        }
        else
        {
          unsigned int v424 = v56[1].u32[0];
          DWORD2(__src) = v424;
          if (v424 > 0x40) {
            operator new[]();
          }
          if (v424 == v65) {
            *(void *)&long long __src = 0;
          }
          else {
            *(void *)&long long __src = *(unint64_t *)v56 >> v65;
          }
          uint64_t v425 = *(llvm::ConstantInt **)v581;
        }
        int v21 = (llvm::Constant *)llvm::ConstantInt::get(v425, (llvm::LLVMContext *)&__src, v63);
        if ((*(_DWORD *)(v581 + 8) & 0xFE) != 0x12) {
          goto LABEL_1357;
        }
        int v386 = *(_DWORD *)(v581 + 8);
        uint64_t v387 = *(unsigned int *)(v581 + 32);
        goto LABEL_1361;
      }
      return (const llvm::detail::DoubleAPFloat *)v11[v12 == 149];
    }
  }
  else
  {
    if (v12 != 3475) {
      return 0;
    }
    int v107 = (*v11)[2].u8[0];
    uint64_t v108 = (uint64_t)&(*v11)[3];
    if (*v11 == 0 || v107 != 16)
    {
      uint64_t v108 = 0;
      int v21 = 0;
      if ((v107 - 11) > 1) {
        return v21;
      }
    }
    unint64_t v109 = v11[1];
    int v110 = v109[2].u8[0];
    BOOL v111 = v109 != 0;
    uint64_t v112 = (uint64_t)&v109[3];
    if (!v111 || v110 != 16)
    {
      uint64_t v112 = 0;
      int v21 = 0;
      if ((v110 - 11) > 1) {
        return v21;
      }
    }
    uint64_t v113 = v11[2];
    int v114 = v113[2].u8[0];
    uint64_t v115 = v113 + 3;
    if (v113 == 0 || v114 != 16)
    {
      uint64_t v115 = 0;
      int v21 = 0;
      if ((v114 - 11) > 1) {
        return v21;
      }
    }
    if (v113 != 0 && v114 == 16)
    {
      unint64_t v116 = 0;
      uint64_t v117 = 0;
      int v118 = 0;
      DWORD2(__src) = 32;
      unsigned int v119 = v113[4].u32[0];
      do
      {
        int v120 = v115;
        if (v119 >= 0x41) {
          int v120 = (int8x8_t *)(*(void *)v115 + 8 * (v116 >> 6));
        }
        unint64_t v121 = *(unint64_t *)v120 >> v116;
        if (v121 <= 0xCu)
        {
          if (v121 == 12)
          {
            uint64_t v122 = 0;
          }
          else
          {
            if ((v121 & 0xC) == 4 || (~v121 & 0xA) == 0) {
              uint64_t v122 = v108;
            }
            else {
              uint64_t v122 = v112;
            }
            if (v122)
            {
              unsigned int v124 = *(_DWORD *)(v122 + 8);
              if (v121 > 7u)
              {
                if (v124 >= 0x41) {
                  uint64_t v122 = *(void *)v122;
                }
                uint64_t v125 = *(void *)v122;
                if (v121) {
                  uint64_t v126 = 0x80000000;
                }
                else {
                  uint64_t v126 = 0x8000;
                }
                if ((v125 & v126) != 0) {
                  uint64_t v122 = 255;
                }
                else {
                  uint64_t v122 = 0;
                }
              }
              else
              {
                if (v124 >= 0x41) {
                  uint64_t v122 = *(void *)v122;
                }
                uint64_t v122 = (*(void *)v122 >> (8 * (v121 & 3u)));
              }
            }
            else
            {
              ++v118;
            }
          }
        }
        else
        {
          uint64_t v122 = 255;
        }
        unsigned int v127 = (const llvm::APInt *)(255 << v116);
        uint64_t v117 = v117 & ~(255 << v116) | (v122 << v116);
        *(void *)&long long __src = v117;
        uint64_t v128 = (llvm::Type *)(v116 + 8);
        BOOL v24 = v116 >= 0x18;
        v116 += 8;
      }
      while (!v24);
      if (v118 == 4)
      {
        uint64_t v129 = llvm::UndefValue::get((llvm::UndefValue *)a4, v128);
LABEL_428:
        int v21 = v129;
        goto LABEL_1357;
      }
      uint64_t v385 = a4;
      int v21 = (llvm::Constant *)llvm::ConstantInt::get(*(llvm::ConstantInt **)a4, (llvm::LLVMContext *)&__src, v127);
      if ((*(_DWORD *)(v385 + 8) & 0xFE) != 0x12) {
        goto LABEL_1357;
      }
      int v386 = *(_DWORD *)(v385 + 8);
      uint64_t v387 = *(unsigned int *)(v385 + 32);
LABEL_1361:
      uint64_t v129 = llvm::ConstantVector::getSplat((llvm::Type *)(v387 | ((unint64_t)(v386 == 19) << 32)), (uint64_t)v21);
      goto LABEL_428;
    }
  }

  return llvm::UndefValue::get((llvm::UndefValue *)a4, a2);
}

uint64_t llvm::isMathLibCallNoop(uint64_t a1, unint64_t a2)
{
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(unsigned char **)(a1 + 64);
  if (!v4 || (v4[14] & 0x10) == 0)
  {
    int hasFnAttrOnCalledFunction = llvm::CallBase::hasFnAttrOnCalledFunction(a1, 20);
    uint64_t v4 = *(unsigned char **)(a1 + 64);
    if (!hasFnAttrOnCalledFunction) {
      goto LABEL_8;
    }
    if (!v4) {
      goto LABEL_6;
    }
  }
  if ((v4[12] & 0x10) == 0)
  {
LABEL_6:
    if (!llvm::CallBase::hasFnAttrOnCalledFunction(a1, 4)) {
      return 0;
    }
    uint64_t v4 = *(unsigned char **)(a1 + 64);
LABEL_8:
    if (!v4) {
      goto LABEL_10;
    }
  }
  if ((v4[19] & 0x20) != 0) {
    return 0;
  }
LABEL_10:
  if (llvm::CallBase::hasFnAttrOnCalledFunction(a1, 61)) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 - 32);
  if (!v6 || *(unsigned char *)(v6 + 16) || *(void *)(v6 + 24) != *(void *)(a1 + 72)) {
    return 0;
  }
  int v56 = 0;
  if (!a2) {
    return a2;
  }
  if (!llvm::TargetLibraryInfoImpl::getLibFunc(*(void *)a2, (uint64_t ***)v6, &v56)) {
    return 0;
  }
  int v8 = *(unsigned __int8 *)(a1 + 16);
  if (v8 == 84)
  {
    uint64_t v9 = 0;
  }
  else if (v8 == 39)
  {
    uint64_t v9 = (*(_DWORD *)(a1 + 80) + 1);
  }
  else
  {
    uint64_t v9 = 2;
  }
  int v10 = *(_DWORD *)(a1 + 20);
  if (v10 < 0 && (v52 = a1 - 32 * (v10 & 0x7FFFFFF), uint64_t v53 = *(void *)(v52 - 8), (v53 & 0xFFFFFFFF0) != 0))
  {
    uint64_t v12 = -(uint64_t)(v10 & 0x7FFFFFF);
    int v11 = *(_DWORD *)(v52 - 12) - *(_DWORD *)(v52 - v53);
  }
  else
  {
    int v11 = 0;
    uint64_t v12 = -(uint64_t)(v10 & 0x7FFFFFF);
  }
  uint64_t v13 = a1 - 32 * v9 + 32 * -v11;
  size_t v14 = (void *)(a1 + 32 * v12);
  if (((v13 - (void)v14 - 32) & 0x1FFFFFFFE0) == 0x20)
  {
    uint64_t v15 = *v14;
    if (*v14)
    {
      if (*(unsigned char *)(v15 + 16) == 17)
      {
        uint64_t v16 = (llvm::APFloat *)(v15 + 24);
        if (v56 > 299)
        {
          if (v56 <= 385)
          {
            if ((v56 - 300) <= 0xE && ((1 << (v56 - 44)) & 0x638F) != 0)
            {
              if (*(_UNKNOWN **)(v15 + 32) == &unk_1CFB2E344) {
                char v17 = *(unsigned char *)(*(void *)(v15 + 40) + 28);
              }
              else {
                char v17 = *(unsigned char *)(v15 + 52);
              }
              if ((v17 & 7) != 1)
              {
                if ((v17 & 7) != 3) {
                  return (v17 & 8) == 0;
                }
                return 0;
              }
              return 1;
            }
            if ((v56 - 384) >= 2) {
              goto LABEL_81;
            }
LABEL_70:
            if (*(_UNKNOWN **)(v15 + 32) == &unk_1CFB2E344) {
              uint64_t v16 = *(llvm::APFloat **)(v15 + 40);
            }
            BOOL v31 = (*((unsigned char *)v16 + 28) & 7) == 0;
            return !v31;
          }
          char v22 = v56 + 123;
          if ((v56 - 389) <= 0x33)
          {
            if (((1 << v22) & 0x70) != 0)
            {
              if (*(_UNKNOWN **)(v15 + 32) == &unk_1CFB2E344) {
                char v17 = *(unsigned char *)(*(void *)(v15 + 40) + 28);
              }
              else {
                char v17 = *(unsigned char *)(v15 + 52);
              }
              if ((v17 & 5 | 2) != 3) {
                return (v17 & 8) == 0;
              }
              return 1;
            }
            if (((1 << v22) & 0x8C00000000000) != 0)
            {
              unsigned int v23 = *(unsigned __int8 *)(*(void *)v15 + 8);
              if (v23 <= 3 && v23 != 1)
              {
                BOOL v24 = sub_1CBFC5054(MEMORY[0x1E4F14AB8], v16, *(void *)v15);
LABEL_102:
                BOOL v31 = v24 == 0;
                return !v31;
              }
              goto LABEL_81;
            }
            if (v56 == 389) {
              goto LABEL_70;
            }
          }
          if ((v56 - 386) >= 3) {
            goto LABEL_81;
          }
LABEL_74:
          int v32 = *(unsigned __int8 *)(*(void *)v15 + 8);
          if (v32 != 2)
          {
            if (v32 != 3) {
              goto LABEL_81;
            }
            LODWORD(v58) = 64;
            unint64_t v57 = 0xC086300000000000;
            llvm::detail::IEEEFloat::initFromDoubleAPInt((llvm::detail::IEEEFloat *)&v63, (const llvm::APInt **)&v57);
            unint64_t v69 = v63;
            uint64_t v70 = v64;
            int v71 = v65;
            char v72 = BYTE4(v65) & 0xF;
            char v33 = *(void **)(v15 + 32);
            int v19 = (llvm::detail::DoubleAPFloat *)(v15 + 32);
            if (v33 == &unk_1CFB2E344)
            {
              if (llvm::detail::DoubleAPFloat::compare(v19, (const llvm::detail::DoubleAPFloat *)&v69)) {
                goto LABEL_78;
              }
            }
            else if (llvm::detail::IEEEFloat::compare(v19, (const llvm::detail::IEEEFloat *)&v69))
            {
LABEL_78:
              int v62 = 64;
              uint64_t v21 = 0x300000000000;
LABEL_79:
              uint64_t v30 = v21 & 0xFFFFFFFFFFFFLL | 0x4086000000000000;
LABEL_80:
              unsigned int v61 = (const llvm::APInt *)v30;
              llvm::detail::IEEEFloat::initFromDoubleAPInt((llvm::detail::IEEEFloat *)&v57, &v61);
              goto LABEL_129;
            }
LABEL_164:
            a2 = 0;
            goto LABEL_165;
          }
          LODWORD(v58) = 32;
          unint64_t v57 = 3266445312;
          llvm::detail::IEEEFloat::initFromFloatAPInt((llvm::detail::IEEEFloat *)&v63, (const llvm::APInt **)&v57);
          unint64_t v69 = v63;
          uint64_t v70 = v64;
          int v71 = v65;
          char v72 = BYTE4(v65) & 0xF;
          int v47 = *(void **)(v15 + 32);
          int v19 = (llvm::detail::DoubleAPFloat *)(v15 + 32);
          if (v47 == &unk_1CFB2E344)
          {
            if (!llvm::detail::DoubleAPFloat::compare(v19, (const llvm::detail::DoubleAPFloat *)&v69)) {
              goto LABEL_164;
            }
          }
          else if (!llvm::detail::IEEEFloat::compare(v19, (const llvm::detail::IEEEFloat *)&v69))
          {
            goto LABEL_164;
          }
          int v62 = 32;
          uint64_t v48 = 1118961664;
LABEL_128:
          unsigned int v61 = (const llvm::APInt *)v48;
          llvm::detail::IEEEFloat::initFromFloatAPInt((llvm::detail::IEEEFloat *)&v57, &v61);
LABEL_129:
          unsigned int v64 = (const llvm::APInt *)v57;
          uint64_t v65 = v58;
          int v66 = v59;
          char v67 = v60 & 0xF;
          if (*(_UNKNOWN **)v19 == &unk_1CFB2E344) {
            int v51 = llvm::detail::DoubleAPFloat::compare(v19, (const llvm::detail::DoubleAPFloat *)&v64);
          }
          else {
            int v51 = llvm::detail::IEEEFloat::compare(v19, (const llvm::detail::IEEEFloat *)&v64);
          }
          a2 = v51 != 2;
          if (v64 == (const llvm::APInt *)&unk_1CFB2E344)
          {
            sub_1CB845718(&v65);
          }
          else if ((*((_DWORD *)v64 + 2) - 64) <= 0xFFFFFF7F && v65)
          {
            MEMORY[0x1D25D9CB0](v65, 0x1000C8000313F17);
          }
LABEL_165:
          BOOL v55 = v69;
          if (v69 != (_DWORD *)&unk_1CFB2E344)
          {
LABEL_166:
            if ((v55[2] - 64) <= 0xFFFFFF7F && v70) {
              MEMORY[0x1D25D9CB0](v70, 0x1000C8000313F17);
            }
            return a2;
          }
LABEL_169:
          sub_1CB845718((uint64_t *)&v70);
          return a2;
        }
        switch(v56)
        {
          case 188:
          case 189:
          case 193:
            goto LABEL_70;
          case 190:
          case 191:
          case 192:
            goto LABEL_74;
          case 194:
          case 195:
          case 196:
          case 197:
          case 198:
          case 199:
          case 200:
          case 201:
          case 202:
          case 204:
          case 205:
          case 206:
            break;
          case 203:
          case 210:
          case 211:
            int v18 = *(unsigned __int8 *)(*(void *)v15 + 8);
            if (v18 != 2)
            {
              if (v18 != 3) {
                break;
              }
              LODWORD(v58) = 64;
              unint64_t v57 = 0xC087480000000000;
              llvm::detail::IEEEFloat::initFromDoubleAPInt((llvm::detail::IEEEFloat *)&v63, (const llvm::APInt **)&v57);
              unint64_t v69 = v63;
              uint64_t v70 = v64;
              int v71 = v65;
              char v72 = BYTE4(v65) & 0xF;
              int v20 = *(void **)(v15 + 32);
              int v19 = (llvm::detail::DoubleAPFloat *)(v15 + 32);
              if (v20 == &unk_1CFB2E344)
              {
                if (!llvm::detail::DoubleAPFloat::compare(v19, (const llvm::detail::DoubleAPFloat *)&v69)) {
                  goto LABEL_164;
                }
              }
              else if (!llvm::detail::IEEEFloat::compare(v19, (const llvm::detail::IEEEFloat *)&v69))
              {
                goto LABEL_164;
              }
              int v62 = 64;
              uint64_t v21 = 0x280000000000;
              goto LABEL_79;
            }
            LODWORD(v58) = 32;
            unint64_t v57 = 3268280320;
            llvm::detail::IEEEFloat::initFromFloatAPInt((llvm::detail::IEEEFloat *)&v63, (const llvm::APInt **)&v57);
            unint64_t v69 = v63;
            uint64_t v70 = v64;
            int v71 = v65;
            char v72 = BYTE4(v65) & 0xF;
            int v50 = *(void **)(v15 + 32);
            int v19 = (llvm::detail::DoubleAPFloat *)(v15 + 32);
            if (v50 == &unk_1CFB2E344)
            {
              if (!llvm::detail::DoubleAPFloat::compare(v19, (const llvm::detail::DoubleAPFloat *)&v69)) {
                goto LABEL_164;
              }
            }
            else if (!llvm::detail::IEEEFloat::compare(v19, (const llvm::detail::IEEEFloat *)&v69))
            {
              goto LABEL_164;
            }
            int v62 = 32;
            uint64_t v48 = 1118830592;
            goto LABEL_128;
          case 207:
          case 208:
          case 209:
            int v28 = *(unsigned __int8 *)(*(void *)v15 + 8);
            if (v28 != 2)
            {
              if (v28 != 3) {
                break;
              }
              LODWORD(v58) = 64;
              unint64_t v57 = 0xC090C80000000000;
              llvm::detail::IEEEFloat::initFromDoubleAPInt((llvm::detail::IEEEFloat *)&v63, (const llvm::APInt **)&v57);
              unint64_t v69 = v63;
              uint64_t v70 = v64;
              int v71 = v65;
              char v72 = BYTE4(v65) & 0xF;
              int v29 = *(void **)(v15 + 32);
              int v19 = (llvm::detail::DoubleAPFloat *)(v15 + 32);
              if (v29 == &unk_1CFB2E344)
              {
                if (!llvm::detail::DoubleAPFloat::compare(v19, (const llvm::detail::DoubleAPFloat *)&v69)) {
                  goto LABEL_164;
                }
              }
              else if (!llvm::detail::IEEEFloat::compare(v19, (const llvm::detail::IEEEFloat *)&v69))
              {
                goto LABEL_164;
              }
              int v62 = 64;
              uint64_t v30 = 0x408FF80000000000;
              goto LABEL_80;
            }
            LODWORD(v58) = 32;
            unint64_t v57 = 3272933376;
            llvm::detail::IEEEFloat::initFromFloatAPInt((llvm::detail::IEEEFloat *)&v63, (const llvm::APInt **)&v57);
            unint64_t v69 = v63;
            uint64_t v70 = v64;
            int v71 = v65;
            char v72 = BYTE4(v65) & 0xF;
            uint64_t v49 = *(void **)(v15 + 32);
            int v19 = (llvm::detail::DoubleAPFloat *)(v15 + 32);
            if (v49 == &unk_1CFB2E344)
            {
              if (!llvm::detail::DoubleAPFloat::compare(v19, (const llvm::detail::DoubleAPFloat *)&v69)) {
                goto LABEL_164;
              }
            }
            else if (!llvm::detail::IEEEFloat::compare(v19, (const llvm::detail::IEEEFloat *)&v69))
            {
              goto LABEL_164;
            }
            int v62 = 32;
            uint64_t v48 = 1123942400;
            goto LABEL_128;
          default:
            if ((v56 - 142) > 0xC || ((1 << (v56 + 114)) & 0x11A3) == 0) {
              break;
            }
            unsigned int v26 = *(void **)(v15 + 32);
            uint64_t v25 = (void **)(v15 + 32);
            llvm::APFloat::APFloat((uint64_t)v68, v26, "-1", 2uLL);
            if (*v25 == &unk_1CFB2E344)
            {
              if (llvm::detail::DoubleAPFloat::compare((llvm::detail::DoubleAPFloat *)v25, (const llvm::detail::DoubleAPFloat *)&v69))
              {
LABEL_47:
                llvm::APFloat::APFloat((uint64_t)&v63, *v25, "1", 1uLL);
                if (*v25 == &unk_1CFB2E344) {
                  int v27 = llvm::detail::DoubleAPFloat::compare((llvm::detail::DoubleAPFloat *)v25, (const llvm::detail::DoubleAPFloat *)&v64);
                }
                else {
                  int v27 = llvm::detail::IEEEFloat::compare((llvm::detail::IEEEFloat *)v25, (const llvm::detail::IEEEFloat *)&v64);
                }
                a2 = v27 != 2;
                if (v64 == (const llvm::APInt *)&unk_1CFB2E344)
                {
                  sub_1CB845718(&v65);
                }
                else if ((*((_DWORD *)v64 + 2) - 64) <= 0xFFFFFF7F && v65)
                {
                  MEMORY[0x1D25D9CB0](v65, 0x1000C8000313F17);
                }
LABEL_147:
                BOOL v55 = v69;
                if (v69 != (_DWORD *)&unk_1CFB2E344) {
                  goto LABEL_166;
                }
                goto LABEL_169;
              }
            }
            else if (llvm::detail::IEEEFloat::compare((llvm::detail::IEEEFloat *)v25, (const llvm::detail::IEEEFloat *)&v69))
            {
              goto LABEL_47;
            }
            a2 = 0;
            goto LABEL_147;
        }
      }
    }
  }
LABEL_81:
  if (v8 == 84)
  {
    uint64_t v34 = 0;
  }
  else if (v8 == 39)
  {
    uint64_t v34 = (*(_DWORD *)(a1 + 80) + 1);
  }
  else
  {
    uint64_t v34 = 2;
  }
  if (v10 < 0 && (uint64_t v54 = *(v14 - 1), (v54 & 0xFFFFFFFF0) != 0)) {
    int v35 = *((_DWORD *)v14 - 3) - *(_DWORD *)((char *)v14 - v54);
  }
  else {
    int v35 = 0;
  }
  a2 = 0;
  if (((a1 - 32 * v34 + 32 * -v35 - (void)v14 - 32) & 0x1FFFFFFFE0) == 0x40)
  {
    a2 = 0;
    if (*(unsigned char *)(*v14 + 16) == 17) {
      int v36 = (uint64_t *)*v14;
    }
    else {
      int v36 = 0;
    }
    uint64_t v37 = v14[4];
    if (*(unsigned char *)(v37 + 16) != 17) {
      uint64_t v37 = 0;
    }
    if (v36 && v37)
    {
      BOOL v38 = (llvm::APFloat *)(v36 + 3);
      uint64_t v39 = (llvm::APFloat *)(v37 + 24);
      if ((v56 - 246) < 3 || (v56 - 364) < 3)
      {
        int v43 = (void *)v36[4];
        uint64_t v44 = v36 + 3;
        if (v43 == &unk_1CFB2E344) {
          uint64_t v44 = (void *)v36[5];
        }
        if ((*((unsigned char *)v44 + 28) & 7) == 1) {
          return 1;
        }
        int v45 = *(void **)(v37 + 32);
        uint64_t v46 = v37 + 24;
        if (v45 == &unk_1CFB2E344) {
          uint64_t v46 = *(void *)(v37 + 40);
        }
        if ((*(unsigned char *)(v46 + 28) & 7) == 1) {
          return 1;
        }
        if (v43 == &unk_1CFB2E344) {
          BOOL v38 = (llvm::APFloat *)v36[5];
        }
        if ((*((unsigned char *)v38 + 28) & 7) != 0)
        {
          if (v45 == &unk_1CFB2E344) {
            uint64_t v39 = *(llvm::APFloat **)(v37 + 40);
          }
          BOOL v31 = (*((unsigned char *)v39 + 28) & 7) == 3;
          return !v31;
        }
      }
      else if ((v56 - 347) <= 2)
      {
        uint64_t v40 = *v36;
        unsigned int v41 = *(unsigned __int8 *)(*v36 + 8);
        BOOL v42 = v41 > 3 || v41 == 1;
        if (!v42 && v40 == *(void *)v37)
        {
          BOOL v24 = sub_1CBFC510C(MEMORY[0x1E4F14A28], v38, v39, v40);
          goto LABEL_102;
        }
      }
      return 0;
    }
  }
  return a2;
}

const llvm::detail::DoubleAPFloat *sub_1CBFC5054(double (*a1)(double), llvm::APFloat *a2, uint64_t a3)
{
  feclearexcept(159);
  *__error() = 0;
  double v6 = llvm::APFloat::convertToDouble(a2);
  double v7 = a1(v6);
  if ((*__error() - 33) < 2 || fetestexcept(143))
  {
    feclearexcept(159);
    *__error() = 0;
    return 0;
  }
  else
  {
    return sub_1CBFC6D3C(a3, v7);
  }
}

const llvm::detail::DoubleAPFloat *sub_1CBFC510C(double (*a1)(double, double), llvm::APFloat *a2, llvm::APFloat *a3, uint64_t a4)
{
  feclearexcept(159);
  *__error() = 0;
  double v8 = llvm::APFloat::convertToDouble(a2);
  double v9 = llvm::APFloat::convertToDouble(a3);
  double v10 = a1(v8, v9);
  if ((*__error() - 33) < 2 || fetestexcept(143))
  {
    feclearexcept(159);
    *__error() = 0;
    return 0;
  }
  else
  {
    return sub_1CBFC6D3C(a4, v10);
  }
}

llvm::Value *sub_1CBFC51DC(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3, llvm::Constant *a4, llvm::Constant *a5)
{
  v14[9] = *MEMORY[0x1E4F143B8];
  if (a2[16] >= 0x15u) {
    double v6 = 0;
  }
  else {
    double v6 = (llvm::ConstantExpr *)a2;
  }
  if (a3[16] >= 0x15u) {
    double v7 = 0;
  }
  else {
    double v7 = (llvm::Constant *)a3;
  }
  if (v6) {
    BOOL v8 = v7 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8) {
    return 0;
  }
  Add = llvm::ConstantExpr::getAdd(v6, v7, a4, a5);
  double v10 = *(llvm::DataLayout **)(a1 + 8);
  v14[0] = 1;
  for (uint64_t i = 1; i != 9; i += 2)
    v14[i] = -4096;
  uint64_t v12 = sub_1CBFB8694((uint64_t)Add, v10, 0, (uint64_t)v14);
  if ((v14[0] & 1) == 0) {
    MEMORY[0x1D25D9CD0](v14[1], 8);
  }
  return v12;
}

llvm::Value *sub_1CBFC52C0(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3, llvm::Constant *a4)
{
  if (a2[16] >= 0x15u) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = (llvm::ConstantExpr *)a2;
  }
  if (a3[16] >= 0x15u) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = (llvm::Constant *)a3;
  }
  if (v4) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6) {
    return 0;
  }
  uint64_t v9 = llvm::ConstantExpr::getAnd(v4, v5, (llvm::Constant *)a3, a4);

  return sub_1CBFC74F8(a1, v9);
}

llvm::Value *sub_1CBFC5334(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3, llvm::Constant *a4)
{
  uint64_t result = 0;
  v13[9] = *MEMORY[0x1E4F143B8];
  if (a2[16] >= 0x15u) {
    BOOL v6 = 0;
  }
  else {
    BOOL v6 = (llvm::ConstantExpr *)a2;
  }
  if (a3[16] >= 0x15u) {
    double v7 = 0;
  }
  else {
    double v7 = (llvm::Constant *)a3;
  }
  if (v6) {
    BOOL v8 = v7 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (!v8)
  {
    uint64_t v9 = llvm::ConstantExpr::getOr(v6, v7, (llvm::Constant *)a3, a4);
    double v10 = *(llvm::DataLayout **)(a1 + 8);
    v13[0] = 1;
    for (uint64_t i = 1; i != 9; i += 2)
      v13[i] = -4096;
    uint64_t result = sub_1CBFB8694((uint64_t)v9, v10, 0, (uint64_t)v13);
    if ((v13[0] & 1) == 0)
    {
      uint64_t v12 = result;
      MEMORY[0x1D25D9CD0](v13[1], 8);
      return v12;
    }
  }
  return result;
}

void *sub_1CBFC5414(uint64_t a1, unsigned __int16 a2, unsigned __int8 *a3, unsigned __int8 *a4, BOOL a5)
{
  if (a3[16] >= 0x15u) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = (llvm::Type *)a3;
  }
  if (a4[16] >= 0x15u) {
    BOOL v6 = 0;
  }
  else {
    BOOL v6 = (llvm::Constant *)a4;
  }
  if (v5) {
    BOOL v7 = v6 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7) {
    return 0;
  }
  else {
    return llvm::ConstantExpr::getCompare((llvm::ConstantExpr *)a2, v5, v6, 0, a5);
  }
}

llvm::Value *sub_1CBFC5450(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t result = 0;
  v15[9] = *MEMORY[0x1E4F143B8];
  if (a3 && *(unsigned __int8 *)(a3 + 16) <= 0x14u)
  {
    if (a5)
    {
      uint64_t v8 = 8 * a5;
      uint64_t v9 = a4;
      while (*(unsigned __int8 *)(*(void *)v9 + 16) <= 0x14u)
      {
        v9 += 8;
        v8 -= 8;
        if (!v8) {
          goto LABEL_7;
        }
      }
      return 0;
    }
    else
    {
LABEL_7:
      if (a6)
      {
        uint64_t ElementPtr = llvm::ConstantExpr::getGetElementPtr(a2, (uint64_t *)a3, a4, a5, 1, 0, 0);
        int v11 = *(llvm::DataLayout **)(a1 + 8);
        v15[0] = 1;
        for (uint64_t i = 1; i != 9; i += 2)
          v15[i] = -4096;
      }
      else
      {
        uint64_t ElementPtr = llvm::ConstantExpr::getGetElementPtr(a2, (uint64_t *)a3, a4, a5, 0, 0, 0);
        int v11 = *(llvm::DataLayout **)(a1 + 8);
        v15[0] = 1;
        for (uint64_t j = 1; j != 9; j += 2)
          v15[j] = -4096;
      }
      uint64_t result = sub_1CBFB8694(ElementPtr, v11, 0, (uint64_t)v15);
      if ((v15[0] & 1) == 0)
      {
        size_t v14 = result;
        MEMORY[0x1D25D9CD0](v15[1], 8);
        return v14;
      }
    }
  }
  return result;
}

llvm::Value *sub_1CBFC55A4(uint64_t a1, unsigned __int8 *a2, uint64_t a3, unsigned __int8 *a4, llvm::Type *a5)
{
  if (a2[16] >= 0x15u) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = (llvm::ConstantExpr *)a2;
  }
  if (*(unsigned __int8 *)(a3 + 16) >= 0x15u) {
    BOOL v6 = 0;
  }
  else {
    BOOL v6 = (llvm::PoisonValue **)a3;
  }
  if (a4[16] >= 0x15u) {
    BOOL v7 = 0;
  }
  else {
    BOOL v7 = (llvm::Constant *)a4;
  }
  if (v5) {
    BOOL v8 = v6 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8 || v7 == 0) {
    return 0;
  }
  Select = llvm::ConstantExpr::getSelect(v5, v6, v7, 0, a5);

  return sub_1CBFC74F8(a1, (uint64_t)Select);
}

llvm::Value *sub_1CBFC562C(uint64_t a1, llvm::ConstantExpr *a2, llvm::Constant *a3, llvm::Constant *a4, llvm::Constant *a5)
{
  v11[9] = *MEMORY[0x1E4F143B8];
  Mul = llvm::ConstantExpr::getMul(a2, a3, a4, a5);
  BOOL v7 = *(llvm::DataLayout **)(a1 + 8);
  v11[0] = 1;
  for (uint64_t i = 1; i != 9; i += 2)
    v11[i] = -4096;
  uint64_t result = sub_1CBFB8694((uint64_t)Mul, v7, 0, (uint64_t)v11);
  if ((v11[0] & 1) == 0)
  {
    double v10 = result;
    MEMORY[0x1D25D9CD0](v11[1], 8);
    return v10;
  }
  return result;
}

llvm::Value *sub_1CBFC56F0(uint64_t a1, llvm::ConstantExpr *a2, llvm::Constant *a3, llvm::Constant *a4, llvm::Constant *a5)
{
  v11[9] = *MEMORY[0x1E4F143B8];
  Shl = llvm::ConstantExpr::getShl(a2, a3, a4, a5);
  BOOL v7 = *(llvm::DataLayout **)(a1 + 8);
  v11[0] = 1;
  for (uint64_t i = 1; i != 9; i += 2)
    v11[i] = -4096;
  uint64_t result = sub_1CBFB8694((uint64_t)Shl, v7, 0, (uint64_t)v11);
  if ((v11[0] & 1) == 0)
  {
    double v10 = result;
    MEMORY[0x1D25D9CD0](v11[1], 8);
    return v10;
  }
  return result;
}

llvm::Value *sub_1CBFC57B4(uint64_t a1, llvm::ConstantExpr *a2, llvm::Constant *a3, llvm::Constant *a4)
{
  v10[9] = *MEMORY[0x1E4F143B8];
  uint64_t LShr = llvm::ConstantExpr::getLShr(a2, a3, a4, a4);
  BOOL v6 = *(llvm::DataLayout **)(a1 + 8);
  v10[0] = 1;
  for (uint64_t i = 1; i != 9; i += 2)
    v10[i] = -4096;
  uint64_t result = sub_1CBFB8694(LShr, v6, 0, (uint64_t)v10);
  if ((v10[0] & 1) == 0)
  {
    uint64_t v9 = result;
    MEMORY[0x1D25D9CD0](v10[1], 8);
    return v9;
  }
  return result;
}

llvm::Value *sub_1CBFC5874(uint64_t a1, llvm *a2, llvm::Constant *a3, llvm::Constant *a4)
{
  unsigned __int8 v6 = a2;
  v21[2] = *MEMORY[0x1E4F143B8];
  uint64_t v8 = (uint64_t)llvm::ConstantFoldBinaryInstruction(a2, a3, a4, a4);
  if (!v8)
  {
    uint64_t v13 = *(void ***)a3;
    if (*(void *)a3)
    {
      v21[0] = a3;
      v21[1] = a4;
      uint64_t v14 = **v13 + 1512;
      LODWORD(v15) = v6;
      uint64_t v16 = v21;
      uint64_t v17 = 2;
      long long v18 = 0u;
      long long v19 = 0u;
      uint64_t v20 = 0;
      uint64_t v8 = sub_1CC56C20C(v14, (uint64_t)v13, (unsigned __int8 *)&v15);
    }
    else
    {
      uint64_t v8 = 0;
    }
  }
  uint64_t v9 = *(llvm::DataLayout **)(a1 + 8);
  uint64_t v15 = 1;
  for (uint64_t i = 8; i != 72; i += 16)
    *(uint64_t *)((char *)&v15 + i) = -4096;
  int v11 = sub_1CBFB8694(v8, v9, 0, (uint64_t)&v15);
  if ((v15 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v16, 8);
  }
  return v11;
}

llvm::Value *sub_1CBFC599C(uint64_t a1, llvm::Constant **a2, const llvm::APInt *a3)
{
  v9[9] = *MEMORY[0x1E4F143B8];
  Not = llvm::ConstantExpr::getNot(a2, (llvm::Constant *)a2, a3);
  uint64_t v5 = *(llvm::DataLayout **)(a1 + 8);
  v9[0] = 1;
  for (uint64_t i = 1; i != 9; i += 2)
    v9[i] = -4096;
  uint64_t result = sub_1CBFB8694((uint64_t)Not, v5, 0, (uint64_t)v9);
  if ((v9[0] & 1) == 0)
  {
    uint64_t v8 = result;
    MEMORY[0x1D25D9CD0](v9[1], 8);
    return v8;
  }
  return result;
}

llvm::ConstantExpr *sub_1CBFC5A54(uint64_t a1, llvm::ConstantExpr *a2, llvm::ConstantExpr *a3, llvm::Constant ***a4)
{
  v10[9] = *MEMORY[0x1E4F143B8];
  if (*(llvm::Constant ****)a3 != a4)
  {
    Cast = llvm::ConstantExpr::getCast(a2, a3, a4, 0);
    unsigned __int8 v6 = *(llvm::DataLayout **)(a1 + 8);
    v10[0] = 1;
    for (uint64_t i = 1; i != 9; i += 2)
      v10[i] = -4096;
    a3 = sub_1CBFB8694((uint64_t)Cast, v6, 0, (uint64_t)v10);
    if ((v10[0] & 1) == 0)
    {
      uint64_t v9 = a3;
      MEMORY[0x1D25D9CD0](v10[1], 8);
      return v9;
    }
  }
  return a3;
}

llvm::ConstantExpr *sub_1CBFC5B28(uint64_t a1, llvm::ConstantExpr *a2, llvm::Type ***a3, llvm::Type *a4)
{
  v10[9] = *MEMORY[0x1E4F143B8];
  if (*(llvm::Type ****)a2 != a3)
  {
    IntegerCast = llvm::ConstantExpr::getIntegerCast(a2, a3, a4);
    unsigned __int8 v6 = *(llvm::DataLayout **)(a1 + 8);
    v10[0] = 1;
    for (uint64_t i = 1; i != 9; i += 2)
      v10[i] = -4096;
    a2 = sub_1CBFB8694((uint64_t)IntegerCast, v6, 0, (uint64_t)v10);
    if ((v10[0] & 1) == 0)
    {
      uint64_t v9 = a2;
      MEMORY[0x1D25D9CD0](v10[1], 8);
      return v9;
    }
  }
  return a2;
}

llvm::Value *sub_1CBFC5BF8(uint64_t a1, llvm::ConstantExpr *a2, llvm::Constant *a3, llvm::Constant *a4, llvm::Type *a5)
{
  v11[9] = *MEMORY[0x1E4F143B8];
  InsertElement = llvm::ConstantExpr::getInsertElement(a2, a3, a4, 0, a5);
  BOOL v7 = *(llvm::DataLayout **)(a1 + 8);
  v11[0] = 1;
  for (uint64_t i = 1; i != 9; i += 2)
    v11[i] = -4096;
  uint64_t result = sub_1CBFB8694((uint64_t)InsertElement, v7, 0, (uint64_t)v11);
  if ((v11[0] & 1) == 0)
  {
    double v10 = result;
    MEMORY[0x1D25D9CD0](v11[1], 8);
    return v10;
  }
  return result;
}

llvm::Value *sub_1CBFC5CBC(uint64_t a1, llvm::Constant *a2, unsigned int *a3, uint64_t a4)
{
  v10[9] = *MEMORY[0x1E4F143B8];
  Value = llvm::ConstantExpr::getExtractValue(a2, a3, a4, 0);
  unsigned __int8 v6 = *(llvm::DataLayout **)(a1 + 8);
  v10[0] = 1;
  for (uint64_t i = 1; i != 9; i += 2)
    v10[i] = -4096;
  uint64_t result = sub_1CBFB8694((uint64_t)Value, v6, 0, (uint64_t)v10);
  if ((v10[0] & 1) == 0)
  {
    uint64_t v9 = result;
    MEMORY[0x1D25D9CD0](v10[1], 8);
    return v9;
  }
  return result;
}

uint64_t sub_1CBFC5D80(llvm::APInt *a1, uint64_t a2)
{
  unsigned int v2 = *((_DWORD *)a1 + 2);
  if (v2 < 0x41) {
    goto LABEL_2;
  }
  uint64_t v8 = a2;
  uint64_t v5 = a1;
  unsigned int v6 = v2 - sub_1CBAB1CB8(a1) - 64;
  a1 = v5;
  unsigned int v2 = *((_DWORD *)v5 + 2);
  if (v6 > 0xFFFFFFBE)
  {
    a2 = v8;
    if (v2 > 0x40)
    {
      uint64_t v3 = **(void **)v5;
      return v3 < a2;
    }
LABEL_2:
    uint64_t v3 = (uint64_t)(*(void *)a1 << -(char)v2) >> -(char)v2;
    return v3 < a2;
  }
  unsigned int v7 = v2 - 1;
  if (*((_DWORD *)v5 + 2) >= 0x41u) {
    a1 = (llvm::APInt *)(*(void *)v5 + 8 * (v7 >> 6));
  }
  return (*(void *)a1 >> v7) & 1;
}

uint64_t sub_1CBFC5E34(unsigned __int8 *a1, unint64_t a2, unsigned char *a3, uint64_t a4, uint64_t a5)
{
  int v5 = a1[16];
  if ((v5 - 11) >= 3)
  {
    int v11 = (llvm::detail::IEEEFloat *)a1;
    while (1)
    {
      while (v5 == 17)
      {
        unsigned int v26 = *(void ***)v11;
        int v27 = *(unsigned __int8 *)(*(void *)v11 + 8);
        if (*(unsigned char *)(*(void *)v11 + 8))
        {
          if (v27 == 2)
          {
            int v28 = (llvm::PoisonValue *)(**v26 + 1960);
          }
          else
          {
            if (v27 != 3) {
              return 0;
            }
            int v28 = (llvm::PoisonValue *)(**v26 + 1984);
          }
        }
        else
        {
          int v28 = (llvm::PoisonValue *)(**v26 + 1936);
        }
        int v11 = sub_1CBFBB130((uint64_t)v11, v28, (const llvm::APFloat *)a5);
        int v5 = *((unsigned __int8 *)v11 + 16);
        if ((v5 - 11) < 3) {
          return 1;
        }
      }
      if (v5 == 16)
      {
        unint64_t v43 = *((unsigned int *)v11 + 8);
        if (v43 > 0x40 || (*((_DWORD *)v11 + 8) & 7) != 0) {
          return 0;
        }
        uint64_t result = 1;
        if (a4)
        {
          unint64_t v64 = v43 >> 3;
          if (v43 >> 3 != a2)
          {
            unint64_t v65 = *((void *)v11 + 3);
            uint64_t v66 = a4 - 1;
            unint64_t v67 = v64 - 1;
            int v68 = -(int)a2;
            do
            {
              if (*(unsigned char *)a5) {
                char v69 = v67 + v68;
              }
              else {
                char v69 = a2;
              }
              *a3++ = v65 >> (8 * v69);
              if (v66-- == 0) {
                break;
              }
              LOBYTE(v68) = v68 - 1;
              BOOL v13 = v67 == a2++;
            }
            while (!v13);
          }
        }
        return result;
      }
      int v12 = *((unsigned __int8 *)v11 + 16);
      BOOL v13 = v12 == 8 || v12 == 10;
      if (v13) {
        break;
      }
      if (v12 == 9)
      {
        StructLayout = llvm::DataLayout::getStructLayout((llvm::DataLayout *)a5, *(llvm::StructType **)v11);
        uint64_t v46 = (char *)StructLayout + 16;
        int v71 = (char *)StructLayout + 16;
        unint64_t v47 = *((_DWORD *)StructLayout + 3) & 0x7FFFFFFF;
        if (v47)
        {
          uint64_t v46 = (char *)StructLayout + 16;
          do
          {
            unint64_t v48 = v47 >> 1;
            uint64_t v49 = &v46[8 * (v47 >> 1)];
            unint64_t v51 = *(void *)v49;
            int v50 = v49 + 8;
            v47 += ~(v47 >> 1);
            if (v51 > a2) {
              unint64_t v47 = v48;
            }
            else {
              uint64_t v46 = v50;
            }
          }
          while (v47);
        }
        unint64_t v52 = v46 - v71 - 8;
        uint64_t v53 = *(void *)&v71[v52 & 0x7FFFFFFF8];
        unint64_t v54 = a2 - v53;
        for (i = v52 >> 3; ; uint64_t v53 = *(void *)&v71[8 * i])
        {
          int v56 = (llvm::Type *)**((void **)v11 + 4 * i + -4 * (*((_DWORD *)v11 + 5) & 0x7FFFFFF));
          uint64_t v57 = sub_1CB83544C(a5, (uint64_t)v56);
          BOOL v59 = v58 == 1;
          char Alignment = llvm::DataLayout::getAlignment((llvm::DataLayout *)a5, v56, 1);
          if (v59)
          {
            char v63 = Alignment;
            char Alignment = v63;
          }
          if (v54 < (((1 << Alignment) + ((unint64_t)(v57 + 7) >> 3) - 1) & -(1 << Alignment)))
          {
            uint64_t result = sub_1CBFC5E34(*((void *)v11 + 4 * i + -4 * (*((_DWORD *)v11 + 5) & 0x7FFFFFF)), v54, a3, a4, a5);
            if (!result) {
              break;
            }
          }
          LODWORD(i) = i + 1;
          if (i == *(_DWORD *)(*(void *)v11 + 12)) {
            return 1;
          }
          unint64_t v62 = *(void *)&v71[8 * i] - (v53 + v54);
          if (v62 >= a4) {
            return 1;
          }
          unint64_t v54 = 0;
          a3 += v62;
          a4 = (a4 - v62);
        }
        return result;
      }
      if ((v12 & 0xFE) == 0xE) {
        break;
      }
      if (v12 != 5 || *((_WORD *)v11 + 9) != 48) {
        return 0;
      }
      uint64_t v14 = *(llvm::StructType **)v11;
      unsigned int v15 = *(_DWORD *)(*(void *)v11 + 8);
      if ((v15 & 0xFE) == 0x12) {
        unsigned int v15 = *(_DWORD *)(**((void **)v14 + 2) + 8);
      }
      if (v15 < 0x100) {
        goto LABEL_25;
      }
      unsigned int v16 = v15 >> 8;
      uint64_t v17 = *(unsigned int *)(a5 + 240);
      uint64_t v18 = *(void *)(a5 + 232);
      if (v17)
      {
        uint64_t v18 = *(void *)(a5 + 232);
        unint64_t v19 = *(unsigned int *)(a5 + 240);
        do
        {
          unint64_t v20 = v19 >> 1;
          uint64_t v21 = v18 + 16 * (v19 >> 1);
          unsigned int v22 = *(_DWORD *)(v21 + 8);
          uint64_t v23 = v21 + 16;
          v19 += ~(v19 >> 1);
          if (v22 < v16) {
            uint64_t v18 = v23;
          }
          else {
            unint64_t v19 = v20;
          }
        }
        while (v19);
      }
      if (v18 == *(void *)(a5 + 232) + 16 * v17 || *(_DWORD *)(v18 + 8) != v16) {
LABEL_25:
      }
        uint64_t v18 = *(void *)(a5 + 232);
      BOOL v24 = (uint64_t **)**((void **)v11 - 4 * (*((_DWORD *)v11 + 5) & 0x7FFFFFF));
      uint64_t v25 = (uint64_t **)llvm::IntegerType::get(*(llvm::IntegerType **)v14, (llvm::LLVMContext *)*(unsigned int *)(v18 + 4));
      if ((*((_DWORD *)v14 + 2) & 0xFE) == 0x12)
      {
        int v29 = (llvm::Type *)*((unsigned int *)v14 + 8);
        if (*((_DWORD *)v14 + 2) == 19) {
          llvm::ScalableVectorType::get(v25, v29);
        }
        else {
          llvm::FixedVectorType::get((llvm::FixedVectorType *)v25, v29);
        }
      }
      if (v24 != v25) {
        return 0;
      }
      int v11 = (llvm::detail::IEEEFloat *)*((void *)v11 - 4 * (*((_DWORD *)v11 + 5) & 0x7FFFFFF));
      int v5 = *((unsigned __int8 *)v11 + 16);
      if ((v5 - 11) <= 2) {
        return 1;
      }
    }
    uint64_t v30 = *(llvm::StructType **)v11;
    if (*(void *)v11 && *((unsigned char *)v30 + 8) == 17) {
      BOOL v31 = (llvm::Type *)*((void *)v30 + 4);
    }
    else {
      BOOL v31 = (llvm::Type *)*((unsigned int *)v30 + 8);
    }
    int v32 = (llvm::Type *)*((void *)v30 + 3);
    unint64_t v33 = (unint64_t)(sub_1CB83544C(a5, (uint64_t)v32) + 7) >> 3;
    BOOL v35 = v34 == 1;
    char v36 = llvm::DataLayout::getAlignment((llvm::DataLayout *)a5, v32, 1);
    unint64_t v38 = ((1 << v36) + v33 - 1) & -(1 << v36);
    if (v35) {
    unint64_t v39 = a2 / v38;
    }
    if ((llvm::Type *)(a2 / v38) != v31)
    {
      unint64_t v40 = a2 % v38;
      do
      {
        AggregateElement = llvm::Constant::getAggregateElement(v11, (llvm::Type *)v39);
        uint64_t result = sub_1CBFC5E34(AggregateElement, v40, a3, a4, a5);
        if (!result) {
          break;
        }
        unint64_t v42 = v38 - v40;
        if (v38 - v40 >= a4) {
          break;
        }
        unint64_t v40 = 0;
        a4 = (a4 - v42);
        a3 += v42;
        ++v39;
      }
      while ((llvm::Type *)v39 != v31);
      return result;
    }
  }
  return 1;
}

uint64_t sub_1CBFC6318(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = a2;
  uint64_t v8 = 0;
  int v3 = sub_1CBFC6398(a1, &v7, &v8);
  uint64_t v4 = a1 + 8;
  if (v3) {
    return v8;
  }
  if (*(_DWORD *)a1)
  {
    uint64_t v5 = 4;
  }
  else
  {
    uint64_t v4 = *(void *)(a1 + 8);
    uint64_t v5 = *(unsigned int *)(a1 + 16);
  }
  return v4 + 16 * v5;
}

uint64_t sub_1CBFC6398(uint64_t a1, void *a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 4;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      uint64_t v7 = 0;
      uint64_t result = 0;
      goto LABEL_8;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v4 - 1);
  uint64_t v7 = (void *)(v3 + 16 * v6);
  uint64_t v8 = *v7;
  if (*a2 == *v7)
  {
LABEL_15:
    uint64_t result = 1;
  }
  else
  {
    uint64_t v9 = 0;
    int v10 = 1;
    while (v8 != -4096)
    {
      if (v9) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -8192;
      }
      if (v12) {
        uint64_t v9 = v7;
      }
      unsigned int v13 = v6 + v10++;
      unsigned int v6 = v13 & v5;
      uint64_t v7 = (void *)(v3 + 16 * (v13 & v5));
      uint64_t v8 = *v7;
      if (*a2 == *v7) {
        goto LABEL_15;
      }
    }
    uint64_t result = 0;
    if (v9) {
      uint64_t v7 = v9;
    }
  }
LABEL_8:
  *a3 = v7;
  return result;
}

void *sub_1CBFC6440@<X0>(uint64_t a1@<X0>, void *a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  unsigned int v16 = 0;
  uint64_t result = (void *)sub_1CBFC6508(a1, a2, &v16);
  uint64_t v9 = v16;
  if (result)
  {
    uint64_t v14 = a1 + 8;
    if (*(unsigned char *)a1)
    {
      uint64_t v15 = 4;
    }
    else
    {
      uint64_t v14 = *(void *)(a1 + 8);
      uint64_t v15 = *(unsigned int *)(a1 + 16);
    }
    char v13 = 0;
    uint64_t v12 = v14 + 16 * v15;
  }
  else
  {
    uint64_t result = sub_1CBFC65B0((_DWORD *)a1, (uint64_t)a2, a2, v16);
    uint64_t v9 = result;
    void *result = *a2;
    result[1] = *a3;
    uint64_t v10 = a1 + 8;
    if (*(unsigned char *)a1)
    {
      uint64_t v11 = 4;
    }
    else
    {
      uint64_t v10 = *(void *)(a1 + 8);
      uint64_t v11 = *(unsigned int *)(a1 + 16);
    }
    uint64_t v12 = v10 + 16 * v11;
    char v13 = 1;
  }
  *(void *)a4 = v9;
  *(void *)(a4 + 8) = v12;
  *(unsigned char *)(a4 + 16) = v13;
  return result;
}

uint64_t sub_1CBFC6508(uint64_t a1, void *a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 4;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      uint64_t v7 = 0;
      uint64_t result = 0;
      goto LABEL_8;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v4 - 1);
  uint64_t v7 = (void *)(v3 + 16 * v6);
  uint64_t v8 = *v7;
  if (*a2 == *v7)
  {
LABEL_15:
    uint64_t result = 1;
  }
  else
  {
    uint64_t v9 = 0;
    int v10 = 1;
    while (v8 != -4096)
    {
      if (v9) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -8192;
      }
      if (v12) {
        uint64_t v9 = v7;
      }
      unsigned int v13 = v6 + v10++;
      unsigned int v6 = v13 & v5;
      uint64_t v7 = (void *)(v3 + 16 * (v13 & v5));
      uint64_t v8 = *v7;
      if (*a2 == *v7) {
        goto LABEL_15;
      }
    }
    uint64_t result = 0;
    if (v9) {
      uint64_t v7 = v9;
    }
  }
LABEL_8:
  *a3 = v7;
  return result;
}

void *sub_1CBFC65B0(_DWORD *a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *a1 >> 1;
  if (*a1) {
    unsigned int v7 = 4;
  }
  else {
    unsigned int v7 = a1[4];
  }
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - a1[1] > v7 >> 3)
  {
    goto LABEL_5;
  }
  sub_1CBFC6674((uint64_t)a1, v7);
  uint64_t v9 = 0;
  sub_1CBFC6508((uint64_t)a1, a3, &v9);
  a4 = v9;
LABEL_5:
  *a1 += 2;
  if (*a4 != -4096) {
    --a1[1];
  }
  return a4;
}

uint64_t sub_1CBFC6674(uint64_t a1, unsigned int a2)
{
  v14[8] = *MEMORY[0x1E4F143B8];
  if (a2 >= 5)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    uint64_t v11 = *(void **)(a1 + 8);
    uint64_t v12 = *(unsigned int *)(a1 + 16);
    if (a2 > 4)
    {
      uint64_t v13 = a2;
      *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CBFC6800(a1, v11, &v11[2 * v12]);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v6 = 0;
  unsigned int v7 = v14;
  do
  {
    uint64_t v8 = *(void *)(a1 + v6 + 8);
    if ((v8 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      *unsigned int v7 = v8;
      v7[1] = *(void *)(a1 + v6 + 16);
      v7 += 2;
    }
    v6 += 16;
  }
  while (v6 != 64);
  if (a2 > 4)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v9 = a2;
    *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v9;
  }
  return sub_1CBFC6800(a1, v14, v7);
}

uint64_t sub_1CBFC6800(uint64_t result, void *a2, void *a3)
{
  int v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    uint64_t v8 = (void *)(result + 8);
    uint64_t v9 = (void *)(result + 72);
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(result + 16);
    if (!v7) {
      goto LABEL_9;
    }
    uint64_t v8 = *(void **)(result + 8);
    uint64_t v9 = &v8[2 * v7];
  }
  do
  {
    *uint64_t v8 = -4096;
    v8 += 2;
  }
  while (v8 != v9);
LABEL_9:
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v11 = 0;
      uint64_t result = sub_1CBFC6508((uint64_t)v5, a2, &v11);
      int v10 = v11;
      *uint64_t v11 = *a2;
      v10[1] = a2[1];
      *v5 += 2;
    }
    a2 += 2;
  }
  return result;
}

llvm::ConstantExpr *sub_1CBFC68C8(llvm::Value *a1)
{
  uint64_t v1 = *(void *)a1;
  uint64_t result = llvm::Value::stripPointerCasts(a1);
  unint64_t v3 = result;
  uint64_t v4 = *(void *)result;
  int v5 = (llvm::Type *)(*(_DWORD *)(v1 + 8) >> 8);
  if (v5 != *(_DWORD *)(*(void *)result + 8) >> 8)
  {
    int v6 = *(llvm::PointerType **)(v4 + 24);
    if (v6) {
      uint64_t v7 = (llvm::Constant *)llvm::PointerType::get(v6, v5);
    }
    else {
      uint64_t v7 = (llvm::Constant *)llvm::PointerType::get(*(uint64_t ***)v4, v5);
    }
    return llvm::ConstantExpr::getPointerCast(v3, v7, v8);
  }
  return result;
}

void sub_1CBFC6948(uint64_t a1, unint64_t a2)
{
  if (HIDWORD(a2)) {
    sub_1CD0A88F0(a2);
  }
  uint64_t v3 = *(unsigned int *)(a1 + 12);
  if (v3 == -1) {
    sub_1CD0A89A8(0xFFFFFFFFuLL);
  }
  unint64_t v4 = (2 * v3) | 1;
  if (v4 <= a2) {
    unint64_t v4 = a2;
  }
  if (v4 >= 0xFFFFFFFF) {
    uint64_t v5 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v5 = v4;
  }
  int v6 = malloc_type_malloc(16 * v5, 0x4065EBACuLL);
  if (!v6) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  uint64_t v7 = v6;
  sub_1CBFC6A04(a1, (uint64_t)v6);
  if (*(void *)a1 != a1 + 16) {
    free(*(void **)a1);
  }
  *(void *)a1 = v7;
  *(_DWORD *)(a1 + 12) = v5;
}

uint64_t sub_1CBFC6A04(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(result + 8);
  if (v2)
  {
    uint64_t v3 = (_DWORD *)(a2 + 8);
    uint64_t v4 = 16 * v2;
    uint64_t v5 = (_DWORD *)(*(void *)result + 8);
    do
    {
      *uint64_t v3 = *v5;
      *((void *)v3 - 1) = *((void *)v5 - 1);
      *uint64_t v5 = 0;
      v5 += 4;
      v3 += 4;
      v4 -= 16;
    }
    while (v4);
    uint64_t v6 = *(unsigned int *)(result + 8);
    if (v6)
    {
      uint64_t v7 = *(void *)result;
      uint64_t v8 = 16 * v6;
      do
      {
        if (*(_DWORD *)(v7 + v8 - 8) >= 0x41u)
        {
          uint64_t result = *(void *)(v7 + v8 - 16);
          if (result)
          {
            uint64_t v9 = v8;
            uint64_t v10 = v7;
            uint64_t result = MEMORY[0x1D25D9CB0](result, 0x1000C8000313F17);
            uint64_t v8 = v9;
            uint64_t v7 = v10;
          }
        }
        v8 -= 16;
      }
      while (v8);
    }
  }
  return result;
}

uint64_t sub_1CBFC6AA8(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(result + 8);
  if (v3 + a2 > (unint64_t)*(unsigned int *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (a2)
  {
    uint64_t v4 = (void *)(*(void *)result + 8 * v3);
    uint64_t v5 = a2;
    do
    {
      *v4++ = a3;
      --v5;
    }
    while (v5);
  }
  *(_DWORD *)(result + 8) = v3 + a2;
  return result;
}

uint64_t sub_1CBFC6B20(uint64_t result, unint64_t a2, uint64_t a3)
{
  if (*(unsigned int *)(result + 12) < a2)
  {
    *(_DWORD *)(result + 8) = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  unint64_t v3 = *(unsigned int *)(result + 8);
  if (v3 >= a2) {
    unint64_t v4 = a2;
  }
  else {
    unint64_t v4 = *(unsigned int *)(result + 8);
  }
  if (v4)
  {
    uint64_t v8 = *(void **)result;
    do
    {
      *v8++ = a3;
      --v4;
    }
    while (v4);
  }
  unint64_t v5 = v3 - a2;
  if (v3 < a2 && a2 != v3)
  {
    uint64_t v6 = (void *)(*(void *)result + 8 * v3);
    do
      *v6++ = a3;
    while (!__CFADD__(v5++, 1));
  }
  *(_DWORD *)(result + 8) = a2;
  return result;
}

uint64_t sub_1CBFC6BD8(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void **)(a1 + 8);
  uint64_t v2 = (llvm::detail::DoubleAPFloat *)(a1 + 8);
  if (v3 == &unk_1CFB2E344) {
    llvm::detail::DoubleAPFloat::roundToIntegral(v2, a2);
  }
  return llvm::detail::IEEEFloat::roundToIntegral(v2, a2);
}

double sub_1CBFC6BF8(void **a1)
{
  void v8[2] = *MEMORY[0x1E4F143B8];
  if ((*((unsigned char *)*a1 + 8) & 0xFC) != 0)
  {
    uint64_t v1 = (const llvm::detail::DoubleAPFloat *)(a1 + 4);
    if (a1[4] == &unk_1CFB2E344) {
      llvm::detail::DoubleAPFloat::DoubleAPFloat(&v7, v1);
    }
    else {
      llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&v7, v1);
    }
    llvm::APFloat::convert((uint64_t)v6, &unk_1CFB2E31C, 1, &v5);
    double result = llvm::APFloat::convertToDouble((llvm::APFloat *)v6);
    if ((_UNKNOWN *)v7 == &unk_1CFB2E344)
    {
      double v4 = result;
      sub_1CB845718(v8);
      return v4;
    }
    if ((*(_DWORD *)(v7 + 8) - 64) <= 0xFFFFFF7F && v8[0])
    {
      double v4 = result;
      MEMORY[0x1D25D9CB0](v8[0], 0x1000C8000313F17);
      return v4;
    }
  }
  else
  {
    unint64_t v3 = (llvm::APFloat *)(a1 + 3);
    return llvm::APFloat::convertToDouble(v3);
  }
  return result;
}

const llvm::detail::DoubleAPFloat *sub_1CBFC6D3C(uint64_t a1, double a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if ((*(unsigned __int8 *)(a1 + 8) | 2) == 2)
  {
    LODWORD(v16) = 64;
    uint64_t v15 = *(const llvm::APInt **)&a2;
    llvm::detail::IEEEFloat::initFromDoubleAPInt((llvm::detail::IEEEFloat *)&v11, &v15);
    uint64_t v16 = v11;
    uint64_t v17 = v12;
    int v18 = v13;
    char v19 = v14 & 0xF;
    if (*(unsigned char *)(a1 + 8) == 2)
    {
      double v4 = &unk_1CFB2E308;
    }
    else
    {
      double v4 = &unk_1CFB2E2E0;
      switch(*(unsigned char *)(a1 + 8))
      {
        case 1:
          double v4 = &unk_1CFB2E2F4;
          break;
        case 2:
          __break(1u);
          goto LABEL_15;
        case 3:
LABEL_15:
          double v4 = &unk_1CFB2E31C;
          break;
        case 4:
          uint64_t v10 = llvm::APFloatBase::x87DoubleExtended(v3);
          goto LABEL_18;
        case 5:
          uint64_t v10 = llvm::APFloatBase::IEEEquad(v3);
LABEL_18:
          double v4 = v10;
          break;
        case 6:
          double v4 = &unk_1CFB2E344;
          break;
        default:
          break;
      }
    }
    llvm::APFloat::convert((uint64_t)&v15, v4, 1, &v11);
    uint64_t v6 = *(llvm::ConstantFP **)a1;
  }
  else
  {
    uint64_t v7 = *(llvm::ConstantFP **)a1;
    LODWORD(v16) = 64;
    uint64_t v15 = *(const llvm::APInt **)&a2;
    llvm::detail::IEEEFloat::initFromDoubleAPInt((llvm::detail::IEEEFloat *)&v11, &v15);
    uint64_t v16 = v11;
    uint64_t v17 = v12;
    int v18 = v13;
    char v19 = v14 & 0xF;
    uint64_t v6 = v7;
  }
  uint64_t v8 = llvm::ConstantFP::get(v6, (llvm::LLVMContext *)&v15, v5);
  if ((_UNKNOWN *)v16 == &unk_1CFB2E344)
  {
    sub_1CB845718(&v17);
  }
  else if ((*(_DWORD *)(v16 + 8) - 64) <= 0xFFFFFF7F && v17)
  {
    MEMORY[0x1D25D9CB0](v17, 0x1000C8000313F17);
  }
  return v8;
}

void *sub_1CBFC6F2C(uint64_t a1, int a2, llvm::ConstantInt *a3, const llvm::APInt *a4)
{
  uint64_t v7 = *((_DWORD *)a3 + 2) >> 8;
  int v13 = 0;
  char v12 = 0;
  int v8 = sub_1CB87E144(a1, (uint64_t *)&v13, 1, v7, (uint64_t)a4, a2 ^ 1u, &v12);
  double result = 0;
  if (v8 == 16) {
    int v10 = a2;
  }
  else {
    int v10 = 0;
  }
  if (v8) {
    BOOL v11 = v10 == 0;
  }
  else {
    BOOL v11 = 0;
  }
  if (!v11) {
    return llvm::ConstantInt::get(a3, (unint64_t)v13, a4);
  }
  return result;
}

uint64_t sub_1CBFC6FB8(uint64_t result)
{
  if (*(_UNKNOWN **)(result + 8) == &unk_1CFB2E344) {
    return llvm::detail::DoubleAPFloat::changeSign((llvm::detail::DoubleAPFloat *)(result + 8));
  }
  *(unsigned char *)(result + 28) ^= 8u;
  return result;
}

unsigned char *sub_1CBFC6FE8(uint64_t a1, char a2, char a3, const llvm::APInt *a4)
{
  char v5 = *(void **)(a1 + 8);
  double v4 = (llvm::detail::DoubleAPFloat *)(a1 + 8);
  if (v5 == &unk_1CFB2E344) {
    return (unsigned char *)llvm::detail::DoubleAPFloat::makeNaN(v4, a2, a3, a4);
  }
  else {
    return llvm::detail::IEEEFloat::makeNaN(v4, a2, a3, a4);
  }
}

double sub_1CBFC7004(double a1)
{
  return sin(a1 * 1.57079633);
}

long double sub_1CBFC7014(long double a1)
{
  return atan(a1) * a1;
}

double sub_1CBFC703C(int8x16_t a1, int8x16_t a2)
{
  if (*(double *)a1.i64 != 0.0) {
    return 1.0 / sqrt(*(double *)a1.i64);
  }
  a2.i64[0] = 0x7FF0000000000000;
  v2.f64[0] = NAN;
  v2.f64[1] = NAN;
  *(void *)&double result = vbslq_s8((int8x16_t)vnegq_f64(v2), a2, a1).u64[0];
  return result;
}

double sub_1CBFC706C(int8x16_t a1, int8x16_t a2)
{
  if (*(double *)a1.i64 != 0.0) {
    return 1.0 / *(double *)a1.i64;
  }
  a2.i64[0] = 0x7FF0000000000000;
  v2.f64[0] = NAN;
  v2.f64[1] = NAN;
  *(void *)&double result = vbslq_s8((int8x16_t)vnegq_f64(v2), a2, a1).u64[0];
  return result;
}

BOOL sub_1CBFC7098(llvm::ConstrainedFPIntrinsic *a1, int a2)
{
  unsigned __int16 RoundingMode = llvm::ConstrainedFPIntrinsic::getRoundingMode(a1);
  unsigned __int16 ExceptionBehavior = llvm::ConstrainedFPIntrinsic::getExceptionBehavior(a1);
  if (!a2) {
    return 1;
  }
  if (RoundingMode >= 0x100u && RoundingMode == 7) {
    return 0;
  }
  return ExceptionBehavior > 0xFFu && ExceptionBehavior != 2;
}

void *sub_1CBFC7114@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  char v5 = (const llvm::detail::DoubleAPFloat *)(a1 + 8);
  if (*(_UNKNOWN **)(a1 + 8) == &unk_1CFB2E344) {
    uint64_t v6 = *(void *)(a1 + 16);
  }
  else {
    uint64_t v6 = a1;
  }
  if ((*(unsigned char *)(v6 + 28) & 7) == 1)
  {
    uint64_t v17 = a3 + 8;
    char v5 = (const llvm::detail::DoubleAPFloat *)(a2 + 8);
  }
  else
  {
    int v8 = (llvm::detail::DoubleAPFloat *)(a2 + 8);
    uint64_t v9 = *(void **)(a2 + 8);
    uint64_t v10 = *(void *)(a2 + 16);
    if (v9 != &unk_1CFB2E344) {
      uint64_t v10 = a2;
    }
    if ((*(unsigned char *)(v10 + 28) & 7) != 1)
    {
      if (v9 == &unk_1CFB2E344) {
        int v11 = llvm::detail::DoubleAPFloat::compare(v8, v5);
      }
      else {
        int v11 = llvm::detail::IEEEFloat::compare(v8, v5);
      }
      if (v11) {
        uint64_t v12 = a1;
      }
      else {
        uint64_t v12 = a2;
      }
      int v13 = (void *)(a3 + 8);
      uint64_t v15 = *(void **)(v12 + 8);
      char v14 = (const llvm::detail::DoubleAPFloat *)(v12 + 8);
      if (v15 == &unk_1CFB2E344)
      {
        return llvm::detail::DoubleAPFloat::DoubleAPFloat(v13, v14);
      }
      else
      {
        return (void *)llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v13, v14);
      }
    }
    uint64_t v17 = a3 + 8;
  }

  return (void *)sub_1CB87DDC4(v17, (uint64_t *)v5);
}

void *sub_1CBFC7220@<X0>(llvm::detail::IEEEFloat *this@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  char v5 = (void *)*((void *)this + 1);
  uint64_t v6 = (llvm::detail::IEEEFloat *)*((void *)this + 2);
  if (v5 != &unk_1CFB2E344) {
    uint64_t v6 = this;
  }
  if ((*((unsigned char *)v6 + 28) & 7) == 1)
  {
    int v13 = (void *)(a3 + 8);
    uint64_t v15 = (void *)a2[1];
    char v14 = (const llvm::detail::DoubleAPFloat *)(a2 + 1);
    goto LABEL_14;
  }
  uint64_t v7 = (const llvm::detail::DoubleAPFloat *)(a2 + 1);
  if ((_UNKNOWN *)a2[1] == &unk_1CFB2E344) {
    int v8 = (void *)a2[2];
  }
  else {
    int v8 = a2;
  }
  if ((*((unsigned char *)v8 + 28) & 7) != 1)
  {
    uint64_t v10 = (llvm::detail::IEEEFloat *)((char *)this + 8);
    if (v5 == &unk_1CFB2E344) {
      int v11 = llvm::detail::DoubleAPFloat::compare(v10, v7);
    }
    else {
      int v11 = llvm::detail::IEEEFloat::compare(v10, v7);
    }
    if (v11) {
      uint64_t v12 = this;
    }
    else {
      uint64_t v12 = (llvm::detail::IEEEFloat *)a2;
    }
    int v13 = (void *)(a3 + 8);
    uint64_t v16 = (void *)*((void *)v12 + 1);
    char v14 = (llvm::detail::IEEEFloat *)((char *)v12 + 8);
    uint64_t v15 = v16;
LABEL_14:
    if (v15 == &unk_1CFB2E344)
    {
      return llvm::detail::DoubleAPFloat::DoubleAPFloat(v13, v14);
    }
    else
    {
      return (void *)llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v13, v14);
    }
  }

  return (void *)sub_1CB87DDC4(a3 + 8, (uint64_t *)this + 1);
}

BOOL sub_1CBFC7338(uint64_t a1)
{
  return *(unsigned char *)(a1 + 16) == 84
      && (uint64_t v1 = *(void *)(a1 - 32)) != 0
      && !*(unsigned char *)(v1 + 16)
      && *(void *)(v1 + 24) == *(void *)(a1 + 72)
      && (*(unsigned char *)(v1 + 33) & 0x20) != 0
      && (*(_DWORD *)(v1 + 36) - 79) < 0x28;
}

uint64_t sub_1CBFC7388@<X0>(uint64_t result@<X0>, unsigned int a2@<W1>, llvm::APInt *a3@<X8>)
{
  if ((int)result <= 305)
  {
    if (result != 305)
    {
      if (result == 274)
      {
        *((_DWORD *)a3 + 2) = a2;
        if (a2 > 0x40) {
          llvm::APInt::initSlowCase(a3);
        }
        unint64_t v5 = 0xFFFFFFFFFFFFFFFFLL >> -(char)a2;
        if (!a2) {
          unint64_t v5 = 0;
        }
        *(void *)a3 = v5;
        unint64_t v4 = *(void *)a3 & ~(1 << (a2 - 1));
      }
      else
      {
        *((_DWORD *)a3 + 2) = a2;
        if (a2 > 0x40) {
          llvm::APInt::initSlowCase(a3);
        }
        *(void *)a3 = 0;
        unint64_t v4 = (1 << (a2 - 1)) | *(void *)a3;
      }
      goto LABEL_6;
    }
    *((_DWORD *)a3 + 2) = a2;
    if (a2 <= 0x40)
    {
      unint64_t v4 = 0xFFFFFFFFFFFFFFFFLL >> -(char)a2;
      if (!a2) {
        unint64_t v4 = 0;
      }
LABEL_6:
      *(void *)a3 = v4;
      return result;
    }
    uint64_t v6 = a3;
LABEL_18:
    llvm::APInt::initSlowCase(v6);
  }
  *((_DWORD *)a3 + 2) = a2;
  if (a2 > 0x40)
  {
    uint64_t v6 = a3;
    goto LABEL_18;
  }
  *(void *)a3 = 0;
  return result;
}

llvm::Value *sub_1CBFC74F8(uint64_t a1, uint64_t a2)
{
  v7[9] = *MEMORY[0x1E4F143B8];
  unint64_t v3 = *(llvm::DataLayout **)(a1 + 8);
  v7[0] = 1;
  for (uint64_t i = 1; i != 9; i += 2)
    v7[i] = -4096;
  double result = sub_1CBFB8694(a2, v3, 0, (uint64_t)v7);
  if ((v7[0] & 1) == 0)
  {
    uint64_t v6 = result;
    MEMORY[0x1D25D9CD0](v7[1], 8);
    return v6;
  }
  return result;
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::Function>>::block_begin(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::Function>>::block_end(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

_DWORD *llvm::GenericCycleInfo<llvm::GenericSSAContext<llvm::Function>>::clear(uint64_t a1)
{
  uint64_t v1 = a1 + 56;
  sub_1CBFC9218(a1 + 56, *(void **)(a1 + 56));
  sub_1CBFC75FC((_DWORD *)(v1 - 48));

  return sub_1CBFC75FC((_DWORD *)(v1 - 24));
}

_DWORD *sub_1CBFC75FC(_DWORD *result)
{
  uint64_t v1 = result;
  int v2 = result[2];
  if (v2)
  {
    unsigned int v3 = result[4];
    if (v3 > 4 * v2 && v3 >= 0x41)
    {
      int v4 = 1 << (33 - __clz(v2 - 1));
      if (v4 <= 64) {
        int v5 = 64;
      }
      else {
        int v5 = v4;
      }
LABEL_10:
      if (v5 == v3)
      {
        *((void *)result + 1) = 0;
        uint64_t v6 = 16 * v3;
        uint64_t v7 = *(void **)result;
        do
        {
          *uint64_t v7 = -4096;
          v7 += 2;
          v6 -= 16;
        }
        while (v6);
      }
      else
      {
        double result = (_DWORD *)MEMORY[0x1D25D9CD0](*(void *)result, 8);
        if (v5)
        {
          unint64_t v10 = (4 * v5 / 3u + 1) | ((unint64_t)(4 * v5 / 3u + 1) >> 1);
          unint64_t v11 = v10 | (v10 >> 2) | ((v10 | (v10 >> 2)) >> 4);
          LODWORD(v11) = (((v11 | (v11 >> 8)) >> 16) | v11 | (v11 >> 8)) + 1;
          v1[4] = v11;
          double result = operator new(16 * v11, (std::align_val_t)8uLL);
          *(void *)uint64_t v1 = result;
          *((void *)v1 + 1) = 0;
          uint64_t v12 = v1[4];
          if (v12)
          {
            uint64_t v13 = 16 * v12;
            do
            {
              *(void *)double result = -4096;
              result += 4;
              v13 -= 16;
            }
            while (v13);
          }
        }
        else
        {
          *(void *)uint64_t v1 = 0;
          *((void *)v1 + 1) = 0;
          v1[4] = 0;
        }
      }
      return result;
    }
  }
  else
  {
    if (!result[3]) {
      return result;
    }
    unsigned int v3 = result[4];
    if (v3 > 0x40)
    {
      int v5 = 0;
      goto LABEL_10;
    }
  }
  if (v3)
  {
    int v8 = *(void **)result;
    uint64_t v9 = 16 * v3;
    do
    {
      *int v8 = -4096;
      v8 += 2;
      v9 -= 16;
    }
    while (v9);
  }
  *((void *)result + 1) = 0;
  return result;
}

void sub_1CBFC7748(uint64_t a1, uint64_t a2)
{
  v31[8] = *MEMORY[0x1E4F143B8];
  sub_1CD473120(a1, a2);
  int v29 = v31;
  uint64_t v30 = 0x800000000;
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v5 = v4 + 8 * v3;
    do
    {
      uint64_t v7 = *(void *)(v5 - 8);
      v5 -= 8;
      uint64_t v6 = v7;
      uint64_t v28 = v7;
      uint64_t v26 = 0;
      int v8 = sub_1CD40EA84(*(void *)(a1 + 8), *(_DWORD *)(a1 + 24), v7, &v26);
      uint64_t v9 = 0;
      if (v8) {
        uint64_t v9 = *(void *)(v26 + 8);
      }
      uint64_t v27 = v9;
      uint64_t v10 = *(void *)(v6 + 8);
      if (v10)
      {
        while (1)
        {
          uint64_t v11 = *(void *)(v10 + 24);
          unsigned int v12 = *(unsigned __int8 *)(v11 + 16);
          BOOL v13 = v11 && v12 >= 0x1C;
          if (v13 && v12 - 29 <= 0xA) {
            break;
          }
          uint64_t v10 = *(void *)(v10 + 8);
          if (!v10) {
            goto LABEL_15;
          }
        }
LABEL_18:
        uint64_t v15 = *(void *)(v11 + 40);
        uint64_t v26 = 0;
        int v16 = sub_1CD40EA84(*(void *)(a1 + 8), *(_DWORD *)(a1 + 24), v15, &v26);
        uint64_t v17 = 0;
        if (v16) {
          uint64_t v17 = *(void *)(v26 + 8);
        }
        if (v27 <= v17 && HIDWORD(v27) >= HIDWORD(v17))
        {
          if (v30 >= (unint64_t)HIDWORD(v30)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v29 + v30) = v15;
          LODWORD(v30) = v30 + 1;
        }
        while (1)
        {
          uint64_t v10 = *(void *)(v10 + 8);
          if (!v10) {
            break;
          }
          uint64_t v11 = *(void *)(v10 + 24);
          unsigned int v19 = *(unsigned __int8 *)(v11 + 16);
          if (v11) {
            BOOL v20 = v19 >= 0x1C;
          }
          else {
            BOOL v20 = 0;
          }
          if (v20 && v19 - 29 < 0xB) {
            goto LABEL_18;
          }
        }
      }
LABEL_15:
      if (v30) {
        operator new();
      }
    }
    while (v5 != v4);
  }
  uint64_t v22 = *(void *)a1;
  uint64_t v23 = *(void ***)(*(void *)a1 + 56);
  BOOL v24 = *(void ***)(v22 + 64);
  while (v23 != v24)
  {
    uint64_t v25 = *v23++;
    void *v25 = 0;
    sub_1CD4733A4((uint64_t)v25);
  }
  if (v29 != v31) {
    free(v29);
  }
}

uint64_t llvm::GenericCycleInfo<llvm::GenericSSAContext<llvm::Function>>::getFunction(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t llvm::GenericCycleInfo<llvm::GenericSSAContext<llvm::Function>>::getCycle(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = 0;
  if (sub_1CD40EA84(*(void *)(a1 + 8), *(_DWORD *)(a1 + 24), a2, &v7))
  {
    uint64_t v3 = v7;
    uint64_t v4 = *(void *)(a1 + 8);
    uint64_t v5 = *(unsigned int *)(a1 + 24);
  }
  else
  {
    uint64_t v4 = *(void *)(a1 + 8);
    uint64_t v5 = *(unsigned int *)(a1 + 24);
    uint64_t v3 = v4 + 16 * v5;
  }
  if (v3 == v4 + 16 * v5) {
    return 0;
  }
  else {
    return *(void *)(v3 + 8);
  }
}

uint64_t llvm::GenericCycleInfo<llvm::GenericSSAContext<llvm::Function>>::getCycleDepth(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = 0;
  if (sub_1CD40EA84(*(void *)(a1 + 8), *(_DWORD *)(a1 + 24), a2, &v8))
  {
    uint64_t v3 = v8;
    uint64_t v4 = *(void *)(a1 + 8);
    uint64_t v5 = *(unsigned int *)(a1 + 24);
  }
  else
  {
    uint64_t v4 = *(void *)(a1 + 8);
    uint64_t v5 = *(unsigned int *)(a1 + 24);
    uint64_t v3 = v4 + 16 * v5;
  }
  if (v3 == v4 + 16 * v5) {
    return 0;
  }
  uint64_t v6 = *(void *)(v3 + 8);
  if (!v6) {
    return 0;
  }
  else {
    return *(unsigned int *)(v6 + 80);
  }
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::Function>>::getDepth(uint64_t a1)
{
  return *(unsigned int *)(a1 + 80);
}

uint64_t llvm::GenericCycleInfo<llvm::GenericSSAContext<llvm::Function>>::validateTree(uint64_t a1)
{
  v92[0] = 0;
  v92[1] = 0;
  int v93 = 0;
  v90[0] = 0;
  v90[1] = 0;
  int v91 = 0;
  uint64_t v3 = *(uint64_t **)(a1 + 56);
  int v2 = *(uint64_t **)(a1 + 64);
  while (v3 != v2)
  {
    sub_1CD472A94(&v76, *v3);
    unint64_t v67 = v72;
    uint64_t v4 = v77;
    if (v77 == v76)
    {
      int v68 = v72;
      uint64_t v5 = v72;
      uint64_t v6 = v77;
    }
    else
    {
      unsigned int v43 = v78;
      uint64_t v5 = malloc_type_malloc(8 * v78, 0x4065EBACuLL);
      if (!v5 && (v43 || (uint64_t v5 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0)) {
LABEL_105:
      }
        llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
      int v68 = v5;
      uint64_t v6 = v76;
      uint64_t v4 = v77;
    }
    unsigned int v7 = v79;
    unsigned int v69 = v78;
    if (v4 == v6) {
      unsigned int v8 = v79;
    }
    else {
      unsigned int v8 = v78;
    }
    if (v8)
    {
      memmove(v5, v4, 8 * v8);
      unsigned int v7 = v79;
    }
    unsigned int v70 = v7;
    int v71 = v80;
    unsigned int v74 = 0;
    uint64_t v75 = 0;
    uint64_t v73 = 0;
    sub_1CBF340A8(&v73, v81, v82, 0xAAAAAAAAAAAAAAABLL * ((v82 - (unsigned char *)v81) >> 3));
    int v58 = v63;
    uint64_t v9 = v84;
    if (v84 == v83)
    {
      BOOL v59 = v63;
      uint64_t v10 = v63;
      uint64_t v11 = v84;
    }
    else
    {
      unsigned int v44 = v85;
      uint64_t v10 = malloc_type_malloc(8 * v85, 0x4065EBACuLL);
      if (!v10)
      {
        if (v44) {
          goto LABEL_105;
        }
        uint64_t v10 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
        if (!v10) {
          goto LABEL_105;
        }
      }
      BOOL v59 = v10;
      uint64_t v11 = v83;
      uint64_t v9 = v84;
    }
    unsigned int v12 = v86;
    unsigned int v60 = v85;
    if (v9 == v11) {
      unsigned int v13 = v86;
    }
    else {
      unsigned int v13 = v85;
    }
    if (v13)
    {
      memmove(v10, v9, 8 * v13);
      unsigned int v12 = v86;
    }
    unsigned int v61 = v12;
    int v62 = v87;
    unint64_t v65 = 0;
    uint64_t v66 = 0;
    std::string __p = 0;
    sub_1CBF340A8(&__p, v88, v89, 0xAAAAAAAAAAAAAAABLL * ((v89 - (unsigned char *)v88) >> 3));
    while (2)
    {
      if (v74 - (unsigned char *)v73 == v65 - (unsigned char *)__p)
      {
        if (v73 == v74)
        {
LABEL_69:
          char v40 = 1;
          goto LABEL_72;
        }
        char v14 = (char *)__p + 8;
        uint64_t v15 = (char *)v73 + 8;
        while (1)
        {
          int v16 = v15 - 8;
          if (*((void *)v15 - 1) != *((void *)v14 - 1)) {
            break;
          }
          int v17 = v14[8];
          if (v15[8]) {
            BOOL v18 = v17 == 0;
          }
          else {
            BOOL v18 = 1;
          }
          if (v18)
          {
            if ((v15[8] == 0) == (v17 != 0)) {
              break;
            }
          }
          else if (*(void *)v15 != *(void *)v14)
          {
            break;
          }
          v14 += 24;
          v15 += 24;
          if (v16 + 24 == v74) {
            goto LABEL_69;
          }
        }
      }
      unsigned int v19 = (uint64_t *)*((void *)v74 - 3);
      uint64_t v20 = *v19;
      if (*v19)
      {
        uint64_t v21 = *(uint64_t ***)(v20 + 32);
        uint64_t v22 = *(uint64_t ***)(v20 + 40);
        while (v21 != v22)
        {
          if (*v21 == v19) {
            goto LABEL_36;
          }
          ++v21;
        }
        uint64_t v41 = 416;
        unint64_t v42 = "is_contained(Cycle->ParentCycle->children(), Cycle)";
      }
      else
      {
LABEL_36:
        uint64_t v23 = (uint64_t *)v19[7];
        BOOL v24 = (uint64_t *)v19[8];
        while (v23 != v24)
        {
          uint64_t v57 = 0;
          uint64_t v57 = *v23;
          v94[0] = 0;
          if (sub_1CD40EA84(*(void *)(a1 + 8), *(_DWORD *)(a1 + 24), v57, v94))
          {
            uint64_t v25 = v94[0];
            uint64_t v26 = *(void *)(a1 + 8);
            uint64_t v27 = *(unsigned int *)(a1 + 24);
          }
          else
          {
            uint64_t v26 = *(void *)(a1 + 8);
            uint64_t v27 = *(unsigned int *)(a1 + 24);
            uint64_t v25 = v26 + 16 * v27;
          }
          if (v25 == v26 + 16 * v27)
          {
            uint64_t v41 = 420;
            unint64_t v42 = "MapIt != BlockMap.end()";
            goto LABEL_71;
          }
          uint64_t v28 = *(uint64_t **)(v25 + 8);
          if (!v28) {
            goto LABEL_68;
          }
          unsigned int v29 = *((_DWORD *)v19 + 20);
          unsigned int v30 = *((_DWORD *)v28 + 20);
          if (v29 > v30) {
            goto LABEL_68;
          }
          if (v29 < v30)
          {
            do
              uint64_t v28 = (uint64_t *)*v28;
            while (v29 < *((_DWORD *)v28 + 20));
          }
          if (v28 != v19)
          {
LABEL_68:
            uint64_t v41 = 421;
            unint64_t v42 = "Cycle->contains(MapIt->second)";
            goto LABEL_71;
          }
          sub_1CBB23C3C(v92, &v57, (uint64_t)v94);
          if (!v95)
          {
            uint64_t v41 = 422;
            unint64_t v42 = "Blocks.insert(Block).second";
            goto LABEL_71;
          }
          ++v23;
        }
        sub_1CBFC9A80(v92);
        uint64_t v31 = *((unsigned int *)v19 + 4);
        if (v31)
        {
          int v32 = (uint64_t *)v19[1];
          unint64_t v33 = &v32[v31];
          do
          {
            uint64_t v57 = 0;
            uint64_t v57 = *v32;
            sub_1CBB23C3C(v90, &v57, (uint64_t)v94);
            if (!v95)
            {
              uint64_t v41 = 428;
              unint64_t v42 = "Entries.insert(Entry).second";
              goto LABEL_71;
            }
            int v34 = (void *)v19[7];
            BOOL v35 = (void *)v19[8];
            if (v34 != v35)
            {
              while (*v34 != v57)
              {
                if (++v34 == v35)
                {
                  int v34 = (void *)v19[8];
                  break;
                }
              }
            }
            if (v34 == v35)
            {
              uint64_t v41 = 429;
              unint64_t v42 = "is_contained(Cycle->Blocks, Entry)";
              goto LABEL_71;
            }
            ++v32;
          }
          while (v32 != v33);
          sub_1CBFC9A80(v90);
          uint64_t v36 = v19[4];
          uint64_t v37 = v19[5];
          if (v36 == v37)
          {
LABEL_66:
            sub_1CD47384C((char *)&v67);
            continue;
          }
          int v38 = 0;
          while (1)
          {
            unsigned int v39 = *(_DWORD *)(*(void *)v36 + 80);
            if (v39 <= *((_DWORD *)v19 + 20)) {
              break;
            }
            if (v38)
            {
              if (v38 != v39)
              {
                uint64_t v41 = 439;
                unint64_t v42 = "ChildDepth == Child->Depth";
                goto LABEL_71;
              }
            }
            else
            {
              int v38 = *(_DWORD *)(*(void *)v36 + 80);
            }
            v36 += 8;
            if (v36 == v37) {
              goto LABEL_66;
            }
          }
          uint64_t v41 = 435;
          unint64_t v42 = "Child->Depth > Cycle->Depth";
        }
        else
        {
          uint64_t v41 = 426;
          unint64_t v42 = "!Cycle->Entries.empty()";
        }
      }
      break;
    }
LABEL_71:
    sub_1CBFC83A4((llvm *)v41, v42);
    char v40 = 0;
LABEL_72:
    if (__p)
    {
      unint64_t v65 = __p;
      operator delete(__p);
    }
    if (v59 != v58) {
      free(v59);
    }
    if (v73)
    {
      unsigned int v74 = (char *)v73;
      operator delete(v73);
    }
    if (v68 != v67) {
      free(v68);
    }
    if (v88)
    {
      int v89 = v88;
      operator delete(v88);
    }
    if (v84 != v83) {
      free(v84);
    }
    if (v81)
    {
      uint64_t v82 = v81;
      operator delete(v81);
    }
    if (v77 != v76) {
      free(v77);
    }
    if ((v40 & 1) == 0)
    {
LABEL_128:
      uint64_t v55 = 0;
      goto LABEL_130;
    }
    ++v3;
  }
  uint64_t v45 = *(void *)(a1 + 8);
  uint64_t v46 = *(unsigned int *)(a1 + 24);
  unint64_t v47 = (void *)(v45 + 16 * v46);
  if (*(_DWORD *)(a1 + 16))
  {
    if (v46)
    {
      uint64_t v48 = 16 * v46;
      uint64_t v49 = *(void **)(a1 + 8);
      while ((*v49 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v49 += 2;
        v48 -= 16;
        if (!v48) {
          goto LABEL_111;
        }
      }
    }
    else
    {
      uint64_t v49 = *(void **)(a1 + 8);
    }
  }
  else
  {
LABEL_111:
    uint64_t v49 = (void *)(v45 + 16 * v46);
  }
  int v50 = (void *)(v45 + 16 * v46);
LABEL_114:
  while (v49 != v50)
  {
    unint64_t v51 = v49 + 1;
    while (1)
    {
      unint64_t v51 = (void *)*v51;
      if (!v51) {
        break;
      }
      unint64_t v52 = (void *)v51[7];
      uint64_t v53 = (void *)v51[8];
      if (v52 != v53)
      {
        while (*v52 != *v49)
        {
          if (++v52 == v53)
          {
            unint64_t v52 = (void *)v51[8];
            break;
          }
        }
      }
      if (v52 == v53)
      {
        sub_1CBFC83A4((llvm *)0x1C1, "is_contained(Cycle->Blocks, Block)");
        goto LABEL_128;
      }
    }
    unint64_t v54 = v49 + 2;
    uint64_t v49 = v47;
    if (v54 != v47)
    {
      while ((*v54 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v54 += 2;
        if (v54 == v47)
        {
          uint64_t v49 = v47;
          goto LABEL_114;
        }
      }
      uint64_t v49 = v54;
    }
  }
  uint64_t v55 = 1;
LABEL_130:
  MEMORY[0x1D25D9CD0](v90[0], 8);
  MEMORY[0x1D25D9CD0](v92[0], 8);
  return v55;
}

uint64_t llvm::GenericCycleInfo<llvm::GenericSSAContext<llvm::Function>>::toplevel_cycles(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

uint64_t llvm::GenericCycleInfo<llvm::GenericSSAContext<llvm::Function>>::const_toplevel_iterator::operator*(uint64_t a1)
{
  return **(void **)a1;
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::Function>>::children(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

llvm::raw_ostream *sub_1CBFC83A4(llvm *a1, const char *a2)
{
  unsigned int v3 = a1;
  uint64_t v4 = (llvm::raw_ostream *)llvm::errs(a1);
  uint64_t v5 = v4;
  uint64_t v6 = (void *)*((void *)v4 + 4);
  if (*((void *)v4 + 3) - (void)v6 > 0x5DuLL)
  {
    qmemcpy(v6, "/Library/Caches/com.apple.xbs/Sources/llvmCore_Device/llvm/include/llvm/ADT/GenericCycleImpl.h", 94);
    unsigned int v7 = (unsigned char *)(*((void *)v4 + 4) + 94);
    *((void *)v4 + 4) = v7;
  }
  else
  {
    llvm::raw_ostream::write(v4, "/Library/Caches/com.apple.xbs/Sources/llvmCore_Device/llvm/include/llvm/ADT/GenericCycleImpl.h", 0x5EuLL);
    unsigned int v7 = (unsigned char *)*((void *)v5 + 4);
  }
  if ((unint64_t)v7 >= *((void *)v5 + 3))
  {
    llvm::raw_ostream::write(v5, 58);
  }
  else
  {
    *((void *)v5 + 4) = v7 + 1;
    *unsigned int v7 = 58;
  }
  double result = sub_1CD098D14(v5, v3, 0, 0, 0);
  uint64_t v9 = (void *)*((void *)v5 + 4);
  if (*((void *)v5 + 3) - (void)v9 > 0x21uLL)
  {
    qmemcpy(v9, ": GenericCycleInfo::validateTree: ", 34);
    uint64_t v10 = (unsigned char *)(*((void *)v5 + 4) + 34);
    *((void *)v5 + 4) = v10;
    if (!a2) {
      goto LABEL_10;
    }
  }
  else
  {
    double result = llvm::raw_ostream::write(v5, ": GenericCycleInfo::validateTree: ", 0x22uLL);
    uint64_t v10 = (unsigned char *)*((void *)v5 + 4);
    if (!a2) {
      goto LABEL_10;
    }
  }
  double result = (llvm::raw_ostream *)strlen(a2);
  uint64_t v11 = result;
  if ((unint64_t)result <= *((void *)v5 + 3) - (void)v10)
  {
    if (result)
    {
      double result = (llvm::raw_ostream *)memcpy(v10, a2, (size_t)result);
      uint64_t v10 = (char *)v11 + *((void *)v5 + 4);
      *((void *)v5 + 4) = v10;
    }
  }
  else
  {
    double result = llvm::raw_ostream::write(v5, a2, (size_t)result);
    uint64_t v10 = (unsigned char *)*((void *)v5 + 4);
  }
LABEL_10:
  if ((unint64_t)v10 >= *((void *)v5 + 3))
  {
    return llvm::raw_ostream::write(v5, 10);
  }
  else
  {
    *((void *)v5 + 4) = v10 + 1;
    *uint64_t v10 = 10;
  }
  return result;
}

BOOL llvm::GenericCycle<llvm::GenericSSAContext<llvm::Function>>::contains(uint64_t a1, uint64_t *a2)
{
  if (!a2) {
    return 0;
  }
  unsigned int v2 = *(_DWORD *)(a1 + 80);
  unsigned int v3 = *((_DWORD *)a2 + 20);
  if (v2 > v3) {
    return 0;
  }
  if (v2 < v3)
  {
    do
      a2 = (uint64_t *)*a2;
    while (v2 < *((_DWORD *)a2 + 20));
  }
  return a2 == (uint64_t *)a1;
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::Function>>::const_child_iterator::operator*(uint64_t a1)
{
  return **(void **)a1;
}

void llvm::GenericCycleInfo<llvm::GenericSSAContext<llvm::Function>>::dump(llvm *a1)
{
  llvm::dbgs(a1);

  llvm::GenericCycleInfo<llvm::GenericSSAContext<llvm::Function>>::print();
}

void *llvm::GenericCycleInfo<llvm::GenericSSAContext<llvm::Function>>::const_toplevel_iterator::const_toplevel_iterator(void *result, uint64_t a2)
{
  llvm::raw_ostream *result = a2;
  return result;
}

{
  llvm::raw_ostream *result = a2;
  return result;
}

uint64_t llvm::GenericCycleInfo<llvm::GenericSSAContext<llvm::Function>>::toplevel_begin(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

uint64_t llvm::GenericCycleInfo<llvm::GenericSSAContext<llvm::Function>>::toplevel_end(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::Function>>::clear(uint64_t a1)
{
  *(_DWORD *)(a1 + 16) = 0;
  uint64_t result = sub_1CBFC9218(a1 + 32, *(void **)(a1 + 32));
  *(void *)(a1 + 64) = *(void *)(a1 + 56);
  *(_DWORD *)(a1 + 80) = 0;
  *(void *)a1 = 0;
  return result;
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::Function>>::appendEntry(uint64_t result, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(result + 16);
  if (v2 >= *(_DWORD *)(result + 20)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)(result + 8) + 8 * v2) = a2;
  ++*(_DWORD *)(result + 16);
  return result;
}

void llvm::GenericCycle<llvm::GenericSSAContext<llvm::Function>>::appendBlock(void *a1, uint64_t a2)
{
  uint64_t v5 = (void *)a1[8];
  unint64_t v4 = a1[9];
  if ((unint64_t)v5 >= v4)
  {
    unsigned int v7 = (void *)a1[7];
    uint64_t v8 = v5 - v7;
    unint64_t v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 61) {
      abort();
    }
    uint64_t v10 = v4 - (void)v7;
    if (v10 >> 2 > v9) {
      unint64_t v9 = v10 >> 2;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11)
    {
      if (v11 >> 61) {
        sub_1CB833614();
      }
      unsigned int v12 = (char *)operator new(8 * v11);
    }
    else
    {
      unsigned int v12 = 0;
    }
    unsigned int v13 = &v12[8 * v8];
    *(void *)unsigned int v13 = a2;
    uint64_t v6 = v13 + 8;
    if (v5 != v7)
    {
      do
      {
        uint64_t v14 = *--v5;
        *((void *)v13 - 1) = v14;
        v13 -= 8;
      }
      while (v5 != v7);
      uint64_t v5 = (void *)a1[7];
    }
    a1[7] = v13;
    a1[8] = v6;
    a1[9] = &v12[8 * v11];
    if (v5) {
      operator delete(v5);
    }
  }
  else
  {
    *uint64_t v5 = a2;
    uint64_t v6 = v5 + 1;
  }
  a1[8] = v6;
}

BOOL llvm::GenericCycle<llvm::GenericSSAContext<llvm::Function>>::isReducible(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) == 1;
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::Function>>::getHeader(uint64_t a1)
{
  return **(void **)(a1 + 8);
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::Function>>::getEntries(uint64_t a1)
{
  return a1 + 8;
}

BOOL llvm::GenericCycle<llvm::GenericSSAContext<llvm::Function>>::isEntry(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  if (v3)
  {
    uint64_t v4 = 8 * v3;
    uint64_t v5 = *(void **)(a1 + 8);
    while (*v5 != a2)
    {
      ++v5;
      v4 -= 8;
      if (!v4)
      {
        uint64_t v5 = (void *)(v2 + 8 * v3);
        return v3 != ((uint64_t)v5 - v2) >> 3;
      }
    }
  }
  else
  {
    uint64_t v5 = *(void **)(a1 + 8);
  }
  return v3 != ((uint64_t)v5 - v2) >> 3;
}

BOOL llvm::GenericCycle<llvm::GenericSSAContext<llvm::Function>>::contains(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 56);
  uint64_t v3 = *(void **)(a1 + 64);
  if (v2 != v3)
  {
    while (*v2 != a2)
    {
      if (++v2 == v3)
      {
        uint64_t v2 = *(void **)(a1 + 64);
        return v2 != v3;
      }
    }
  }
  return v2 != v3;
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::Function>>::getParentCycle(uint64_t a1)
{
  return *(void *)a1;
}

{
  return *(void *)a1;
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::Function>>::getExitBlocks(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(a2 + 8) = 0;
  uint64_t v2 = *(void *)(result + 56);
  uint64_t v3 = *(void *)(result + 64);
  if (v2 != v3)
  {
    uint64_t v5 = result;
    unint64_t v6 = 0;
    do
    {
      uint64_t v7 = *(void *)(*(void *)v2 + 40);
      if (v7 == *(void *)v2 + 40)
      {
LABEL_32:
        uint64_t v8 = 0;
        uint64_t v9 = 0;
        int v12 = 0;
      }
      else
      {
        uint64_t v8 = v7 - 24;
        if (v7) {
          uint64_t v9 = v7 - 24;
        }
        else {
          uint64_t v9 = 0;
        }
        int v10 = *(unsigned __int8 *)(v9 + 16);
        int v11 = v10 - 29;
        if (v10 != 30)
        {
          int v22 = 0;
          switch(v11)
          {
            case 0:
            case 5:
            case 6:
              goto LABEL_12;
            case 1:
              __break(1u);
              JUMPOUT(0x1CBFC8A30);
            case 2:
              int v22 = (*(_DWORD *)(v9 + 20) >> 1) & 0x3FFFFFF;
              goto LABEL_12;
            case 3:
            case 9:
              int v22 = (*(_DWORD *)(v9 + 20) & 0x7FFFFFF) - 1;
              goto LABEL_12;
            case 4:
              int v22 = 2;
              goto LABEL_12;
            case 7:
              int v22 = *(_WORD *)(v9 + 18) & 1;
              goto LABEL_12;
            case 8:
              int v22 = 1;
              goto LABEL_12;
            case 10:
              int v22 = *(_DWORD *)(v9 + 80) + 1;
              goto LABEL_12;
            default:
              goto LABEL_32;
          }
        }
        if ((*(_DWORD *)(v9 + 20) & 0x7FFFFFF) == 3) {
          int v22 = 2;
        }
        else {
          int v22 = 1;
        }
LABEL_12:
        int v12 = v22;
      }
      sub_1CBFC9784(a2, *(void *)a2 + 8 * *(unsigned int *)(a2 + 8), (llvm::Instruction *)v9, 0, v8, v12);
      unint64_t v13 = *(unsigned int *)(a2 + 8);
      unint64_t v14 = v6;
      if (v6 < v13)
      {
        do
        {
          uint64_t v15 = *(void **)a2;
          uint64_t v16 = *(void *)(*(void *)a2 + 8 * v14);
          int v17 = *(void **)(v5 + 56);
          BOOL v18 = *(void **)(v5 + 64);
          if (v17 != v18)
          {
            while (*v17 != v16)
            {
              if (++v17 == v18)
              {
                int v17 = *(void **)(v5 + 64);
                break;
              }
            }
          }
          if (v17 == v18)
          {
            unsigned int v19 = &v15[v6];
            if (v6)
            {
              uint64_t v20 = 8 * v6;
              uint64_t v21 = *(void **)a2;
              while (*v21 != v16)
              {
                ++v21;
                v20 -= 8;
                if (!v20)
                {
                  uint64_t v21 = &v15[v6];
                  break;
                }
              }
            }
            else
            {
              uint64_t v21 = *(void **)a2;
            }
            if (v6 == v21 - v15)
            {
              ++v6;
              *unsigned int v19 = v16;
            }
          }
          ++v14;
        }
        while (v14 != v13);
      }
      uint64_t result = sub_1CBFC9AD0(a2, v6);
      v2 += 8;
    }
    while (v2 != v3);
  }
  return result;
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::Function>>::blocks(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

void llvm::GenericCycle<llvm::GenericSSAContext<llvm::Function>>::getCyclePreheader()
{
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::Function>>::getCyclePredecessor(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 16) == 1)
  {
    uint64_t v1 = **(void **)(a1 + 8);
    while (1)
    {
      uint64_t v1 = *(void *)(v1 + 8);
      if (!v1) {
        break;
      }
      uint64_t v2 = *(void *)(v1 + 24);
      unsigned int v3 = *(unsigned __int8 *)(v2 + 16);
      if (v2) {
        BOOL v4 = v3 >= 0x1C;
      }
      else {
        BOOL v4 = 0;
      }
      if (v4 && v3 - 29 < 0xB)
      {
        uint64_t v6 = 0;
        uint64_t v7 = *(void **)(a1 + 56);
        uint64_t v8 = *(void **)(a1 + 64);
LABEL_12:
        uint64_t result = *(void *)(v2 + 40);
        int v10 = v7;
        if (v7 != v8)
        {
          while (*v10 != result)
          {
            if (++v10 == v8)
            {
              int v10 = v8;
              break;
            }
          }
        }
        if (v10 != v8)
        {
          uint64_t result = v6;
          goto LABEL_20;
        }
        if (!v6 || v6 == result)
        {
LABEL_20:
          while (1)
          {
            uint64_t v1 = *(void *)(v1 + 8);
            if (!v1) {
              return result;
            }
            uint64_t v2 = *(void *)(v1 + 24);
            unsigned int v11 = *(unsigned __int8 *)(v2 + 16);
            if (v2) {
              BOOL v12 = v11 >= 0x1C;
            }
            else {
              BOOL v12 = 0;
            }
            if (v12 && v11 - 29 < 0xB)
            {
              uint64_t v6 = result;
              goto LABEL_12;
            }
          }
        }
        return 0;
      }
    }
  }
  return 0;
}

void *llvm::GenericCycle<llvm::GenericSSAContext<llvm::Function>>::const_child_iterator::const_child_iterator(void *result, uint64_t a2)
{
  llvm::raw_ostream *result = a2;
  return result;
}

{
  llvm::raw_ostream *result = a2;
  return result;
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::Function>>::child_begin(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::Function>>::child_end(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::Function>>::getNumChildren(uint64_t a1)
{
  return (uint64_t)(*(void *)(a1 + 40) - *(void *)(a1 + 32)) >> 3;
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::Function>>::getNumBlocks(uint64_t a1)
{
  return (uint64_t)(*(void *)(a1 + 64) - *(void *)(a1 + 56)) >> 3;
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::Function>>::getNumEntries(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::Function>>::entries(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *llvm::CycleInfoPrinterPass::CycleInfoPrinterPass(void *result, uint64_t a2)
{
  llvm::raw_ostream *result = a2;
  return result;
}

llvm::CycleInfoWrapperPass *llvm::CycleInfoWrapperPass::CycleInfoWrapperPass(llvm::CycleInfoWrapperPass *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::CycleInfoWrapperPass::ID;
  *((_DWORD *)this + 6) = 2;
  *(void *)this = &unk_1F26022D8;
  *((void *)this + 4) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((_DWORD *)this + 16) = 0;
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
  *((_DWORD *)this + 22) = 0;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  *((void *)this + 12) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC4FA0, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CBFC8DE8;
    v5[1] = &PassRegistry;
    BOOL v4 = v5;
    std::__call_once(&qword_1EBCC4FA0, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

void llvm::initializeCycleInfoWrapperPassPass(uint64_t a1)
{
  uint64_t v1 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC4FA0, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CBFC8DE8;
    v3[1] = &v1;
    uint64_t v2 = v3;
    std::__call_once(&qword_1EBCC4FA0, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CBFC8DE8()
{
}

void llvm::CycleInfoWrapperPass::getAnalysisUsage(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
}

void llvm::CycleInfoWrapperPass::runOnFunction(llvm::CycleInfoWrapperPass *this, llvm::Function *a2)
{
  unsigned int v3 = (char *)this + 96;
  sub_1CBFC9218((uint64_t)this + 96, *((void **)this + 12));
  sub_1CBFC75FC((_DWORD *)v3 - 12);
  sub_1CBFC75FC((_DWORD *)v3 - 6);
  *((void *)v3 - 8) = a2;
  llvm::GenericCycleInfo<llvm::GenericSSAContext<llvm::Function>>::compute();
}

void llvm::CycleInfoWrapperPass::print(llvm::CycleInfoWrapperPass *this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
  uint64_t v5 = (void *)*((void *)a2 + 4);
  if (*((void *)a2 + 3) - (void)v5 > 0x17uLL)
  {
    qmemcpy(v5, "CycleInfo for function: ", 24);
    *((void *)a2 + 4) += 24;
  }
  else
  {
    llvm::raw_ostream::write(a2, "CycleInfo for function: ", 0x18uLL);
  }
  uint64_t v6 = (uint64_t ***)*((void *)this + 4);
  if ((*((unsigned char *)v6 + 23) & 0x10) != 0)
  {
    uint64_t v7 = ***v6;
    uint64_t v8 = *(void *)(v7 + 152);
    uint64_t v9 = *(unsigned int *)(v7 + 168);
    if (v9)
    {
      LODWORD(v10) = (v9 - 1) & ((v6 >> 4) ^ (v6 >> 9));
      unsigned int v11 = (uint64_t ****)(v8 + 16 * v10);
      BOOL v12 = *v11;
      if (*v11 != v6)
      {
        int v13 = 1;
        do
        {
          if (v12 == (uint64_t ***)-4096) {
            goto LABEL_10;
          }
          int v14 = v10 + v13++;
          uint64_t v10 = v14 & (v9 - 1);
          BOOL v12 = *(uint64_t ****)(v8 + 16 * v10);
        }
        while (v12 != v6);
        unsigned int v11 = (uint64_t ****)(v8 + 16 * v10);
      }
    }
    else
    {
LABEL_10:
      unsigned int v11 = (uint64_t ****)(v8 + 16 * v9);
    }
    uint64_t v15 = (size_t *)v11[1];
    size_t v18 = *v15;
    uint64_t v16 = v15 + 2;
    size_t v17 = v18;
    unsigned int v19 = (unsigned char *)*((void *)a2 + 4);
    if (v18 <= *((void *)a2 + 3) - (void)v19)
    {
      if (v17)
      {
        memcpy(v19, v16, v17);
        unsigned int v19 = (unsigned char *)(*((void *)a2 + 4) + v17);
        *((void *)a2 + 4) = v19;
      }
LABEL_16:
      if (*((unsigned char **)a2 + 3) == v19)
      {
        llvm::raw_ostream::write(a2, "\n", 1uLL);
      }
      else
      {
        *unsigned int v19 = 10;
        ++*((void *)a2 + 4);
      }
      llvm::GenericCycleInfo<llvm::GenericSSAContext<llvm::Function>>::print();
    }
    llvm::raw_ostream::write(a2, (const char *)v16, v17);
  }
  unsigned int v19 = (unsigned char *)*((void *)a2 + 4);
  goto LABEL_16;
}

_DWORD *llvm::CycleInfoWrapperPass::releaseMemory(llvm::CycleInfoWrapperPass *this)
{
  uint64_t v1 = (char *)this + 96;
  sub_1CBFC9218((uint64_t)this + 96, *((void **)this + 12));
  sub_1CBFC75FC((_DWORD *)v1 - 12);
  uint64_t result = sub_1CBFC75FC((_DWORD *)v1 - 6);
  *((void *)v1 - 8) = 0;
  return result;
}

void sub_1CBFC90B8(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F26022D8;
  sub_1CD47306C((uint64_t)a1 + 40);

  llvm::Pass::~Pass(a1);
}

void sub_1CBFC910C(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F26022D8;
  sub_1CD47306C((uint64_t)a1 + 40);
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CBFC9174(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    BOOL v4 = v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = *--v4;
        *BOOL v4 = 0;
        if (v6)
        {
          uint64_t v7 = sub_1CD4730C0();
          MEMORY[0x1D25D9CE0](v7, 0x10A0C40B2354FA7);
        }
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1CBFC9218(uint64_t result, void *a2)
{
  uint64_t v3 = result;
  BOOL v4 = *(void **)(result + 8);
  while (v4 != a2)
  {
    uint64_t v5 = *--v4;
    uint64_t result = v5;
    *BOOL v4 = 0;
    if (v5)
    {
      uint64_t v6 = sub_1CD4730C0(result);
      uint64_t result = MEMORY[0x1D25D9CE0](v6, 0x10A0C40B2354FA7);
    }
  }
  *(void *)(v3 + 8) = a2;
  return result;
}

void llvm::callDefaultCtor<llvm::CycleInfoWrapperPass>()
{
}

char *sub_1CBFC92C4(char **a1, uint64_t *a2)
{
  uint64_t v2 = (a1[1] - *a1) >> 3;
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 61) {
    abort();
  }
  uint64_t v6 = a1[2] - *a1;
  if (v6 >> 2 > v3) {
    unint64_t v3 = v6 >> 2;
  }
  if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v7 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v7 = v3;
  }
  if (v7)
  {
    if (v7 >> 61) {
      sub_1CB833614();
    }
    uint64_t v8 = (char *)operator new(8 * v7);
  }
  else
  {
    uint64_t v8 = 0;
  }
  uint64_t v9 = &v8[8 * v2];
  uint64_t v10 = &v8[8 * v7];
  uint64_t v11 = *a2;
  *a2 = 0;
  *(void *)uint64_t v9 = v11;
  BOOL v12 = v9 + 8;
  int v13 = *a1;
  int v14 = a1[1];
  if (v14 == *a1)
  {
    *a1 = v9;
    a1[1] = v12;
    a1[2] = v10;
  }
  else
  {
    do
    {
      uint64_t v15 = *((void *)v14 - 1);
      v14 -= 8;
      *(void *)int v14 = 0;
      *((void *)v9 - 1) = v15;
      v9 -= 8;
    }
    while (v14 != v13);
    int v14 = *a1;
    uint64_t v16 = a1[1];
    *a1 = v9;
    a1[1] = v12;
    a1[2] = v10;
    while (v16 != v14)
    {
      uint64_t v18 = *((void *)v16 - 1);
      v16 -= 8;
      uint64_t v17 = v18;
      *(void *)uint64_t v16 = 0;
      if (v18)
      {
        uint64_t v19 = sub_1CD4730C0(v17);
        MEMORY[0x1D25D9CE0](v19, 0x10A0C40B2354FA7);
      }
    }
  }
  if (v14) {
    operator delete(v14);
  }
  return v12;
}

void sub_1CBFC93DC(uint64_t a1, uint64_t a2, char *__src, char *a4, uint64_t a5)
{
  if (a5 < 1) {
    return;
  }
  uint64_t v6 = __src;
  uint64_t v8 = *(char **)a1;
  uint64_t v9 = *(uint64_t **)(a1 + 8);
  uint64_t v10 = a2 - *(void *)a1;
  uint64_t v11 = (char *)(*(void *)a1 + (v10 & 0xFFFFFFFFFFFFFFF8));
  uint64_t v12 = *(void *)(a1 + 16);
  if (a5 > (v12 - (uint64_t)v9) >> 3)
  {
    unint64_t v13 = a5 + (((char *)v9 - v8) >> 3);
    if (v13 >> 61) {
      abort();
    }
    uint64_t v14 = v12 - (void)v8;
    uint64_t v15 = v14 >> 2;
    if (v14 >> 2 <= v13) {
      uint64_t v15 = v13;
    }
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v16 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v16 = v15;
    }
    if (v16)
    {
      if (v16 >> 61) {
        sub_1CB833614();
      }
      uint64_t v17 = (char *)operator new(8 * v16);
    }
    else
    {
      uint64_t v17 = 0;
    }
    uint64_t v26 = &v17[8 * (v10 >> 3)];
    uint64_t v27 = &v26[8 * a5];
    uint64_t v28 = 8 * a5;
    unsigned int v29 = v26;
    do
    {
      uint64_t v30 = *(void *)v6;
      v6 += 8;
      *(void *)unsigned int v29 = v30;
      v29 += 8;
      v28 -= 8;
    }
    while (v28);
    uint64_t v31 = *(char **)a1;
    if (v11 != *(char **)a1)
    {
      int v32 = v11;
      do
      {
        uint64_t v33 = *((void *)v32 - 1);
        v32 -= 8;
        *((void *)v26 - 1) = v33;
        v26 -= 8;
      }
      while (v32 != v31);
      uint64_t v9 = *(uint64_t **)(a1 + 8);
    }
    int v34 = &v17[8 * v16];
    if (v9 != (uint64_t *)v11) {
      memmove(v27, v11, (char *)v9 - v11);
    }
    BOOL v35 = *(char **)a1;
    *(void *)a1 = v26;
    *(void *)(a1 + 8) = &v27[(char *)v9 - v11];
    *(void *)(a1 + 16) = v34;
    if (v35)
    {
      operator delete(v35);
    }
    return;
  }
  uint64_t v18 = ((char *)v9 - v11) >> 3;
  if (v18 >= a5)
  {
    uint64_t v19 = &__src[8 * a5];
    uint64_t v21 = *(char **)(a1 + 8);
LABEL_18:
    int v22 = &v11[8 * a5];
    uint64_t v23 = (uint64_t *)&v21[-8 * a5];
    BOOL v24 = v21;
    if (v23 < v9)
    {
      BOOL v24 = v21;
      do
      {
        uint64_t v25 = *v23++;
        *(void *)BOOL v24 = v25;
        v24 += 8;
      }
      while (v23 < v9);
    }
    *(void *)(a1 + 8) = v24;
    if (v21 != v22) {
      memmove(&v21[-8 * ((v21 - v22) >> 3)], v11, v21 - v22);
    }
    if (v19 != v6)
    {
      memmove(v11, v6, v19 - v6);
    }
    return;
  }
  uint64_t v19 = &__src[8 * v18];
  int64_t v20 = a4 - v19;
  if (a4 != v19) {
    memmove(*(void **)(a1 + 8), &__src[8 * v18], a4 - v19);
  }
  uint64_t v21 = (char *)v9 + v20;
  *(void *)(a1 + 8) = (char *)v9 + v20;
  if ((char *)v9 - v11 >= 1) {
    goto LABEL_18;
  }
}

void *sub_1CBFC9604(void *result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2)
  {
    BOOL v4 = result;
    uint64_t v5 = *result;
    while (1)
    {
      uint64_t v6 = *(void *)(v2 + 24);
      unsigned int v7 = *(unsigned __int8 *)(v6 + 16);
      BOOL v8 = v6 && v7 >= 0x1C;
      if (v8 && v7 - 29 < 0xB) {
        break;
      }
      uint64_t v2 = *(void *)(v2 + 8);
      if (!v2) {
        return result;
      }
    }
    char v10 = 0;
LABEL_13:
    uint64_t v11 = *(void *)(v6 + 40);
    uint64_t v21 = 0;
    uint64_t result = (void *)sub_1CD40EA84(*(void *)(v5 + 8), *(_DWORD *)(v5 + 24), v11, &v21);
    uint64_t v12 = 0;
    if (result) {
      uint64_t v12 = *(void *)(v21 + 8);
    }
    unint64_t v13 = (_DWORD *)v4[1];
    if (*v13 <= v12 && v13[1] >= HIDWORD(v12))
    {
      uint64_t v14 = v4[2];
      unint64_t v15 = *(unsigned int *)(v14 + 8);
      if (v15 >= *(unsigned int *)(v14 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)v14 + 8 * v15) = v11;
      ++*(_DWORD *)(v14 + 8);
    }
    else
    {
      char v10 = 1;
    }
    while (1)
    {
      uint64_t v2 = *(void *)(v2 + 8);
      if (!v2) {
        break;
      }
      uint64_t v6 = *(void *)(v2 + 24);
      unsigned int v16 = *(unsigned __int8 *)(v6 + 16);
      if (v6) {
        BOOL v17 = v16 >= 0x1C;
      }
      else {
        BOOL v17 = 0;
      }
      if (v17 && v16 - 29 < 0xB) {
        goto LABEL_13;
      }
    }
    if (v10)
    {
      uint64_t v19 = *(void *)v4[3];
      unsigned int v20 = *(_DWORD *)(v19 + 16);
      if (v20 >= *(_DWORD *)(v19 + 20)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(v19 + 8) + 8 * v20) = a2;
      ++*(_DWORD *)(v19 + 16);
    }
  }
  return result;
}

unsigned char *sub_1CBFC9784(uint64_t a1, uint64_t a2, llvm::Instruction *this, unsigned int a4, uint64_t a5, int a6)
{
  unsigned int v7 = a4;
  unsigned int v9 = a4;
  uint64_t v10 = *(void *)a1;
  uint64_t v11 = (a2 - *(void *)a1) >> 3;
  uint64_t v12 = *(unsigned int *)(a1 + 8);
  unint64_t v13 = *(unsigned int *)(a1 + 12);
  int v14 = a6 - a4;
  unint64_t v15 = v12 + (int)(a6 - a4);
  if (*(void *)a1 + 8 * v12 == a2)
  {
    if (v15 > v13) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    if (a4 != a6)
    {
      unsigned int v16 = (void *)(v10 + 8 * v12);
      int v17 = *((unsigned __int8 *)this + 16);
      uint64_t v18 = (char *)this - 32;
      do
      {
        if (v17 == 30)
        {
          uint64_t v19 = &v18[-32 * v9];
        }
        else
        {
          uint64_t v19 = (char *)this - 32;
          switch(v17)
          {
            case ' ':
            case '&':
              goto LABEL_27;
            case '!':
              uint64_t v30 = -64;
              if (!v9) {
                uint64_t v30 = -96;
              }
              uint64_t v19 = (char *)this + v30;
              break;
            case '""':
            case '#':
              __break(1u);
LABEL_27:
              int v29 = *((_DWORD *)this + 5);
              if ((v29 & 0x40000000) != 0) {
                uint64_t v23 = (char *)*((void *)this - 1);
              }
              else {
                uint64_t v23 = (char *)this - 32 * (v29 & 0x7FFFFFF);
              }
              uint64_t v24 = v9 + 1;
              goto LABEL_15;
            case '$':
              if ((*((_WORD *)this + 9) & 1) == 0)
              {
                uint64_t v20 = 0;
                goto LABEL_8;
              }
              uint64_t v19 = (char *)this - 32 * (*((_DWORD *)this + 5) & 0x7FFFFFF) + 32;
              break;
            case '%':
              break;
            case '\'':
              uint64_t v19 = (char *)this - 32 * *((unsigned int *)this + 20) - 64;
              if (v9) {
                uint64_t v19 = &v18[32 * v9 - 32 + -32 * *((unsigned int *)this + 20)];
              }
              break;
            default:
              int v22 = *((_DWORD *)this + 5);
              if ((v22 & 0x40000000) != 0) {
                uint64_t v23 = (char *)*((void *)this - 1);
              }
              else {
                uint64_t v23 = (char *)this - 32 * (v22 & 0x7FFFFFF);
              }
              uint64_t v24 = (2 * v9) | 1;
LABEL_15:
              uint64_t v19 = &v23[32 * v24];
              break;
          }
        }
        uint64_t v20 = *(void *)v19;
LABEL_8:
        *v16++ = v20;
        unsigned int v9 = ++v7;
      }
      while (v7 != a6);
      uint64_t v10 = *(void *)a1;
    }
    *(_DWORD *)(a1 + 8) = v12 + v14;
    return (unsigned char *)(v10 + 8 * v11);
  }
  else
  {
    int v33 = a6 - a4;
    unint64_t v25 = v14;
    if (v15 > v13) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v26 = (char *)(v10 + 8 * v12);
    long long __src = (unsigned char *)(v10 + 8 * v11);
    unint64_t v27 = (v26 - __src) >> 3;
    if (v27 >= v25)
    {
      sub_1CD4570C8(a1, &v26[-8 * v25], (char *)(v10 + 8 * v12));
      if (&v26[-8 * v25] != __src) {
        memmove(&__src[8 * v25], __src, &v26[-8 * v25] - __src);
      }
      if (v9 != a6)
      {
        unsigned int v31 = v9;
        int v32 = __src;
        do
        {
          *v32++ = llvm::Instruction::getSuccessor(this, v31);
          unsigned int v31 = ++v7;
        }
        while (v7 != a6);
      }
    }
    else
    {
      *(_DWORD *)(a1 + 8) = v12 + v33;
      if (v11 != v12)
      {
        uint64_t v28 = (void *)(v10 + 8 * v11);
        memcpy((void *)(v10 + 8 * (v12 + v33) - 8 * v27), __src, v26 - __src);
        do
        {
          *v28++ = llvm::Instruction::getSuccessor(this, v9++);
          --v27;
        }
        while (v27);
      }
      for (; a6 != v9; ++v9)
      {
        *(void *)uint64_t v26 = llvm::Instruction::getSuccessor(this, v9);
        v26 += 8;
      }
    }
    return __src;
  }
}

_DWORD *sub_1CBFC9A80(_DWORD *result)
{
  if (*((void *)result + 1))
  {
    uint64_t v1 = result[4];
    if (v1 > 4 * result[2] && v1 >= 0x41)
    {
      return sub_1CD42616C(result);
    }
    else
    {
      if (v1)
      {
        uint64_t v2 = *(void **)result;
        uint64_t v3 = 8 * v1;
        do
        {
          *v2++ = -4096;
          v3 -= 8;
        }
        while (v3);
      }
      *((void *)result + 1) = 0;
    }
  }
  return result;
}

uint64_t sub_1CBFC9AD0(uint64_t result, unint64_t a2)
{
  unint64_t v2 = *(unsigned int *)(result + 8);
  if (v2 != a2)
  {
    if (v2 <= a2)
    {
      uint64_t v3 = result;
      int v4 = a2;
      if (*(unsigned int *)(result + 12) < a2) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (a2 != v2)
      {
        bzero((void *)(*(void *)result + 8 * v2), 8 * (a2 - v2));
        uint64_t result = v3;
        LODWORD(a2) = v4;
      }
    }
    *(_DWORD *)(result + 8) = a2;
  }
  return result;
}

void *llvm::DGEdge<llvm::DDGNode,llvm::DDGEdge>::DGEdge(void *result, uint64_t a2)
{
  _DWORD *result = a2;
  return result;
}

{
  _DWORD *result = a2;
  return result;
}

void *llvm::DGEdge<llvm::DDGNode,llvm::DDGEdge>::DGEdge(void *result, void *a2)
{
  _DWORD *result = *a2;
  return result;
}

{
  _DWORD *result = *a2;
  return result;
}

uint64_t *llvm::DGEdge<llvm::DDGNode,llvm::DDGEdge>::operator=(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *a1;
  if (*a2 != *a1)
  {
    sub_1CBFCB9AC(v4 + 8, v3 + 8);
    sub_1CBFAFDE4((void *)(v4 + 32), *(char **)(v3 + 32), *(char **)(v3 + 40), (uint64_t)(*(void *)(v3 + 40) - *(void *)(v3 + 32)) >> 3);
  }
  *(_DWORD *)(v4 + 56) = *(_DWORD *)(v3 + 56);
  return a1;
}

BOOL llvm::DGEdge<llvm::DDGNode,llvm::DDGEdge>::operator==(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

BOOL llvm::DGEdge<llvm::DDGNode,llvm::DDGEdge>::isEqualTo(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

BOOL llvm::DGEdge<llvm::DDGNode,llvm::DDGEdge>::operator!=(uint64_t a1, uint64_t a2)
{
  return a1 != a2;
}

uint64_t llvm::DGEdge<llvm::DDGNode,llvm::DDGEdge>::getTargetNode(uint64_t a1)
{
  return *(void *)a1;
}

{
  return *(void *)a1;
}

uint64_t *llvm::DGEdge<llvm::DDGNode,llvm::DDGEdge>::setTargetNode(uint64_t *result, uint64_t a2)
{
  uint64_t v3 = *result;
  if (*result != a2)
  {
    sub_1CBFCB9AC(v3 + 8, a2 + 8);
    uint64_t result = sub_1CBFAFDE4((void *)(v3 + 32), *(char **)(a2 + 32), *(char **)(a2 + 40), (uint64_t)(*(void *)(a2 + 40) - *(void *)(a2 + 32)) >> 3);
  }
  *(_DWORD *)(v3 + 56) = *(_DWORD *)(a2 + 56);
  return result;
}

uint64_t llvm::DGNode<llvm::DDGNode,llvm::DDGEdge>::DGNode(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  uint64_t v4 = a2;
  sub_1CBFC9CB4((void *)a1, &v4);
  return a1;
}

{
  uint64_t v4;

  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  uint64_t v4 = a2;
  sub_1CBFC9CB4((void *)a1, &v4);
  return a1;
}

{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  sub_1CBFCB9AC(a1, a2);
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 24) = 0;
  sub_1CBFCBA2C((void *)(a1 + 24), *(const void **)(a2 + 24), *(void *)(a2 + 32), (uint64_t)(*(void *)(a2 + 32) - *(void *)(a2 + 24)) >> 3);
  return a1;
}

{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  sub_1CBFCB9AC(a1, a2);
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 24) = 0;
  sub_1CBFCBA2C((void *)(a1 + 24), *(const void **)(a2 + 24), *(void *)(a2 + 32), (uint64_t)(*(void *)(a2 + 32) - *(void *)(a2 + 24)) >> 3);
  return a1;
}

BOOL sub_1CBFC9CB4(void *a1, void *a2)
{
  sub_1CD475450((uint64_t)v17, (uint64_t)a1, a2);
  int v4 = v18;
  if (v18)
  {
    uint64_t v6 = (void *)a1[4];
    unint64_t v5 = a1[5];
    if ((unint64_t)v6 >= v5)
    {
      BOOL v8 = (void *)a1[3];
      uint64_t v9 = v6 - v8;
      unint64_t v10 = v9 + 1;
      if ((unint64_t)(v9 + 1) >> 61) {
        abort();
      }
      uint64_t v11 = v5 - (void)v8;
      if (v11 >> 2 > v10) {
        unint64_t v10 = v11 >> 2;
      }
      if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v12 = v10;
      }
      if (v12)
      {
        if (v12 >> 61) {
          sub_1CB833614();
        }
        unint64_t v13 = (char *)operator new(8 * v12);
      }
      else
      {
        unint64_t v13 = 0;
      }
      int v14 = &v13[8 * v9];
      *(void *)int v14 = *a2;
      unsigned int v7 = v14 + 8;
      if (v6 != v8)
      {
        do
        {
          uint64_t v15 = *--v6;
          *((void *)v14 - 1) = v15;
          v14 -= 8;
        }
        while (v6 != v8);
        uint64_t v6 = (void *)a1[3];
      }
      a1[3] = v14;
      a1[4] = v7;
      a1[5] = &v13[8 * v12];
      if (v6) {
        operator delete(v6);
      }
    }
    else
    {
      *uint64_t v6 = *a2;
      unsigned int v7 = v6 + 1;
    }
    a1[4] = v7;
  }
  return v4 != 0;
}

__n128 llvm::DGNode<llvm::DDGNode,llvm::DDGEdge>::DGNode(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(void *)a1 = *(void *)a2;
  *(void *)a2 = 0;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a2 + 8) = 0;
  int v2 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a2 + 12) = v2;
  int v3 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 16) = v3;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  __n128 result = *(__n128 *)(a2 + 24);
  *(__n128 *)(a1 + 24) = result;
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  return result;
}

{
  int v2;
  int v3;
  __n128 result;

  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(void *)a1 = *(void *)a2;
  *(void *)a2 = 0;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a2 + 8) = 0;
  int v2 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a2 + 12) = v2;
  int v3 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 16) = v3;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  __n128 result = *(__n128 *)(a2 + 24);
  *(__n128 *)(a1 + 24) = result;
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t llvm::DGNode<llvm::DDGNode,llvm::DDGEdge>::operator=(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    sub_1CBFCB9AC(a1, a2);
    sub_1CBFAFDE4((void *)(a1 + 24), *(char **)(a2 + 24), *(char **)(a2 + 32), (uint64_t)(*(void *)(a2 + 32) - *(void *)(a2 + 24)) >> 3);
  }
  return a1;
}

{
  if (a2 != a1)
  {
    sub_1CBFCB9AC(a1, a2);
    sub_1CBFAFDE4((void *)(a1 + 24), *(char **)(a2 + 24), *(char **)(a2 + 32), (uint64_t)(*(void *)(a2 + 32) - *(void *)(a2 + 24)) >> 3);
  }
  return a1;
}

uint64_t llvm::DGNode<llvm::DDGNode,llvm::DDGEdge>::begin(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

{
  return *(void *)(a1 + 24);
}

uint64_t llvm::DGNode<llvm::DDGNode,llvm::DDGEdge>::end(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

{
  return *(void *)(a1 + 32);
}

uint64_t llvm::DGNode<llvm::DDGNode,llvm::DDGEdge>::front(uint64_t a1)
{
  return **(void **)(a1 + 24);
}

{
  return **(void **)(a1 + 24);
}

uint64_t llvm::DGNode<llvm::DDGNode,llvm::DDGEdge>::back(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 32) - 8);
}

{
  return *(void *)(*(void *)(a1 + 32) - 8);
}

BOOL llvm::DGNode<llvm::DDGNode,llvm::DDGEdge>::addEdge(void *a1, uint64_t a2)
{
  uint64_t v3 = a2;
  return sub_1CBFC9CB4(a1, &v3);
}

uint64_t llvm::DGNode<llvm::DDGNode,llvm::DDGEdge>::removeEdge(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  return sub_1CD473F30(a1, &v3);
}

BOOL llvm::DGNode<llvm::DDGNode,llvm::DDGEdge>::hasEdgeTo(uint64_t a1, uint64_t a2)
{
  int v2 = *(void ***)(a1 + 24);
  uint64_t v3 = *(void ***)(a1 + 32);
  if (v2 != v3)
  {
    while (**v2 != a2)
    {
      if (++v2 == v3)
      {
        int v2 = *(void ***)(a1 + 32);
        return v2 != v3;
      }
    }
  }
  return v2 != v3;
}

void **llvm::DGNode<llvm::DDGNode,llvm::DDGEdge>::findEdgeTo(uint64_t a1, uint64_t a2)
{
  __n128 result = *(void ***)(a1 + 24);
  int v4 = *(void ***)(a1 + 32);
  if (result != v4)
  {
    while (**result != a2)
    {
      if (++result == v4) {
        return v4;
      }
    }
  }
  return result;
}

_DWORD *llvm::DGNode<llvm::DDGNode,llvm::DDGEdge>::clear(uint64_t a1)
{
  __n128 result = sub_1CD47558C((_DWORD *)a1);
  *(void *)(a1 + 32) = *(void *)(a1 + 24);
  return result;
}

BOOL llvm::DGNode<llvm::DDGNode,llvm::DDGEdge>::isEqualTo(uint64_t a1, uint64_t a2)
{
  return a2 + 8 == a1;
}

uint64_t llvm::DGNode<llvm::DDGNode,llvm::DDGEdge>::getDerived(uint64_t a1)
{
  return a1 - 8;
}

{
  return a1 - 8;
}

void llvm::DirectedGraph<llvm::DDGNode,llvm::DDGEdge>::DirectedGraph(void *a1)
{
  *a1 = a1 + 2;
  a1[1] = 0xA00000000;
  llvm::DirectedGraph<llvm::DDGNode,llvm::DDGEdge>::addNode();
}

{
  *a1 = a1 + 2;
  a1[1] = 0xA00000000;
  llvm::DirectedGraph<llvm::DDGNode,llvm::DDGEdge>::addNode();
}

void *llvm::DirectedGraph<llvm::DDGNode,llvm::DDGEdge>::DirectedGraph(void *result, uint64_t a2)
{
  _DWORD *result = result + 2;
  result[1] = 0xA00000000;
  if (*(_DWORD *)(a2 + 8)) {
    return (void *)llvm::DirectedGraph<llvm::DDGNode,llvm::DDGEdge>::operator=((uint64_t)result, a2);
  }
  return result;
}

{
  _DWORD *result = result + 2;
  result[1] = 0xA00000000;
  if (*(_DWORD *)(a2 + 8)) {
    return (void *)llvm::DirectedGraph<llvm::DDGNode,llvm::DDGEdge>::operator=((uint64_t)result, a2);
  }
  return result;
}

void *llvm::DirectedGraph<llvm::DDGNode,llvm::DDGEdge>::DirectedGraph(void *a1, uint64_t a2)
{
  *a1 = a1 + 2;
  a1[1] = 0xA00000000;
  if (*(_DWORD *)(a2 + 8)) {
    sub_1CD41C56C((uint64_t)a1, a2);
  }
  return a1;
}

{
  *a1 = a1 + 2;
  a1[1] = 0xA00000000;
  if (*(_DWORD *)(a2 + 8)) {
    sub_1CD41C56C((uint64_t)a1, a2);
  }
  return a1;
}

uint64_t llvm::DirectedGraph<llvm::DDGNode,llvm::DDGEdge>::begin(uint64_t a1)
{
  return *(void *)a1;
}

{
  return *(void *)a1;
}

uint64_t llvm::DirectedGraph<llvm::DDGNode,llvm::DDGEdge>::end(uint64_t a1)
{
  return *(void *)a1 + 8 * *(unsigned int *)(a1 + 8);
}

{
  return *(void *)a1 + 8 * *(unsigned int *)(a1 + 8);
}

uint64_t llvm::DirectedGraph<llvm::DDGNode,llvm::DDGEdge>::front(uint64_t a1)
{
  return **(void **)a1;
}

{
  return **(void **)a1;
}

uint64_t llvm::DirectedGraph<llvm::DDGNode,llvm::DDGEdge>::back(uint64_t a1)
{
  return *(void *)(*(void *)a1 + 8 * *(unsigned int *)(a1 + 8) - 8);
}

{
  return *(void *)(*(void *)a1 + 8 * *(unsigned int *)(a1 + 8) - 8);
}

uint64_t llvm::DirectedGraph<llvm::DDGNode,llvm::DDGEdge>::size(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

void *llvm::DirectedGraph<llvm::DDGNode,llvm::DDGEdge>::findNode(uint64_t a1, uint64_t a2)
{
  __n128 result = *(void **)a1;
  uint64_t v4 = *(unsigned int *)(a1 + 8);
  if (v4)
  {
    uint64_t v5 = 8 * v4;
    uint64_t v6 = &result[v4];
    while (*result != a2)
    {
      ++result;
      v5 -= 8;
      if (!v5) {
        return v6;
      }
    }
  }
  return result;
}

{
  void *result;
  uint64_t v4;
  uint64_t v5;
  void *v6;

  __n128 result = *(void **)a1;
  uint64_t v4 = *(unsigned int *)(a1 + 8);
  if (v4)
  {
    uint64_t v5 = 8 * v4;
    uint64_t v6 = &result[v4];
    while (*result != a2)
    {
      ++result;
      v5 -= 8;
      if (!v5) {
        return v6;
      }
    }
  }
  return result;
}

BOOL llvm::DirectedGraph<llvm::DDGNode,llvm::DDGEdge>::findIncomingEdgesToNode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(a1 + 8);
  if (v3)
  {
    uint64_t v4 = *(void **)a1;
    uint64_t v5 = 8 * v3;
    do
    {
      if (*v4 != a2) {
        llvm::DGNode<llvm::DDGNode,llvm::DDGEdge>::findEdgesTo();
      }
      ++v4;
      v5 -= 8;
    }
    while (v5);
    int v6 = *(_DWORD *)(a3 + 8);
  }
  else
  {
    int v6 = *(_DWORD *)(a3 + 8);
  }
  return v6 != 0;
}

uint64_t llvm::DirectedGraph<llvm::DDGNode,llvm::DDGEdge>::removeNode(unsigned int *a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a1[2];
  if (!v2) {
    return 0;
  }
  uint64_t v5 = *(void **)a1;
  uint64_t v6 = *(void *)a1 + 8 * v2;
  unsigned int v7 = (void *)(*(void *)a1 + 8);
  uint64_t v8 = 8 * v2;
  uint64_t v9 = v7;
  while (*(v7 - 1) != a2)
  {
    ++v9;
    ++v7;
    v8 -= 8;
    if (!v8) {
      return 0;
    }
  }
  if (!v8) {
    return 0;
  }
  do
  {
    if (*v5 != a2) {
      llvm::DGNode<llvm::DDGNode,llvm::DDGEdge>::findEdgesTo();
    }
    ++v5;
  }
  while (v5 != (void *)v6);
  sub_1CD47558C((_DWORD *)(a2 + 8));
  *(void *)(a2 + 40) = *(void *)(a2 + 32);
  uint64_t v11 = a1[2];
  uint64_t v12 = *(void *)a1 + 8 * v11;
  if (v7 != (void *)v12)
  {
    memmove(v7 - 1, v7, v12 - (void)v9);
    LODWORD(v11) = a1[2];
  }
  a1[2] = v11 - 1;
  return 1;
}

BOOL llvm::DirectedGraph<llvm::DDGNode,llvm::DDGEdge>::connect(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a4;
  return sub_1CBFC9CB4((void *)(a2 + 8), &v5);
}

void llvm::DDGNode::~DDGNode(llvm::DDGNode *this)
{
}

llvm::raw_ostream *llvm::operator<<(llvm::raw_ostream *a1, unsigned int a2)
{
  if (a2 <= 4)
  {
    uint64_t v3 = off_1E682C680[a2];
    size_t v4 = strlen(v3);
    uint64_t v5 = (void *)*((void *)a1 + 4);
    if (v4 <= *((void *)a1 + 3) - (void)v5)
    {
      if (v4)
      {
        memcpy(v5, v3, v4);
        *((void *)a1 + 4) += v4;
      }
    }
    else
    {
      llvm::raw_ostream::write(a1, v3, v4);
    }
  }
  return a1;
}

{
  const char *v3;
  size_t v4;
  void *v5;

  if (a2 <= 3)
  {
    uint64_t v3 = off_1E682C6A8[a2];
    size_t v4 = strlen(v3);
    uint64_t v5 = (void *)*((void *)a1 + 4);
    if (v4 <= *((void *)a1 + 3) - (void)v5)
    {
      if (v4)
      {
        memcpy(v5, v3, v4);
        *((void *)a1 + 4) += v4;
      }
    }
    else
    {
      llvm::raw_ostream::write(a1, v3, v4);
    }
  }
  return a1;
}

llvm::raw_ostream *llvm::operator<<(llvm::raw_ostream *a1, unint64_t a2)
{
  size_t v4 = (void *)*((void *)a1 + 4);
  if (*((void *)a1 + 3) - (void)v4 > 0xCuLL)
  {
    qmemcpy(v4, "Node Address:", 13);
    *((void *)a1 + 4) += 13;
  }
  else
  {
    llvm::raw_ostream::write(a1, "Node Address:", 0xDuLL);
  }
  llvm::write_hex(a1, a2, 3, 0, 0);
  uint64_t v5 = (unsigned char *)*((void *)a1 + 4);
  if (*((unsigned char **)a1 + 3) == v5)
  {
    llvm::raw_ostream::write(a1, ":", 1uLL);
  }
  else
  {
    *uint64_t v5 = 58;
    ++*((void *)a1 + 4);
  }
  uint64_t v6 = *(int *)(a2 + 56);
  if (v6 <= 4)
  {
    unsigned int v7 = off_1E682C680[v6];
    size_t v8 = strlen(v7);
    uint64_t v9 = (void *)*((void *)a1 + 4);
    if (v8 <= *((void *)a1 + 3) - (void)v9)
    {
      if (v8)
      {
        memcpy(v9, v7, v8);
        *((void *)a1 + 4) += v8;
      }
    }
    else
    {
      llvm::raw_ostream::write(a1, v7, v8);
    }
  }
  unint64_t v10 = (unsigned char *)*((void *)a1 + 4);
  if (*((unsigned char **)a1 + 3) == v10)
  {
    llvm::raw_ostream::write(a1, "\n", 1uLL);
  }
  else
  {
    *unint64_t v10 = 10;
    ++*((void *)a1 + 4);
  }
  int v11 = *(_DWORD *)(a2 + 56);
  if ((v11 - 1) > 1)
  {
    if (v11 == 3)
    {
      unsigned __int8 v18 = (void *)*((void *)a1 + 4);
      if (*((void *)a1 + 3) - (void)v18 > 0x22uLL)
      {
        qmemcpy(v18, "--- start of nodes in pi-block ---\n", 35);
        *((void *)a1 + 4) += 35;
      }
      else
      {
        llvm::raw_ostream::write(a1, "--- start of nodes in pi-block ---\n", 0x23uLL);
      }
      uint64_t v19 = *(unsigned int *)(a2 + 72);
      if (v19)
      {
        uint64_t v20 = 0;
        uint64_t v21 = *(void *)(a2 + 64);
        uint64_t v22 = 8 * v19;
        do
        {
          llvm::operator<<(a1, *(void *)(v21 + 8 * v20));
          int v23 = v20 + 1;
          int v24 = *(_DWORD *)(a2 + 72);
          unint64_t v25 = v20 + 1 != v24;
          uint64_t v26 = (void *)*((void *)a1 + 4);
          if (*((void *)a1 + 3) - (void)v26 >= v25)
          {
            if (v23 != v24)
            {
              memcpy(v26, "\n", v23 != v24);
              *((void *)a1 + 4) += v25;
            }
          }
          else
          {
            if (v23 == v24) {
              unint64_t v27 = "";
            }
            else {
              unint64_t v27 = "\n";
            }
            llvm::raw_ostream::write(a1, v27, v23 != v24);
          }
          ++v20;
          v22 -= 8;
        }
        while (v22);
      }
      uint64_t v28 = (void *)*((void *)a1 + 4);
      if (*((void *)a1 + 3) - (void)v28 > 0x20uLL)
      {
        qmemcpy(v28, "--- end of nodes in pi-block ---\n", 33);
        *((void *)a1 + 4) += 33;
      }
      else
      {
        llvm::raw_ostream::write(a1, "--- end of nodes in pi-block ---\n", 0x21uLL);
      }
    }
  }
  else
  {
    uint64_t v12 = (void *)*((void *)a1 + 4);
    if (*((void *)a1 + 3) - (void)v12 > 0xEuLL)
    {
      qmemcpy(v12, " Instructions:\n", 15);
      *((void *)a1 + 4) += 15;
    }
    else
    {
      llvm::raw_ostream::write(a1, " Instructions:\n", 0xFuLL);
    }
    uint64_t v13 = *(unsigned int *)(a2 + 72);
    if (v13)
    {
      int v14 = *(llvm::Value ***)(a2 + 64);
      uint64_t v15 = 8 * v13;
      do
      {
        unsigned int v16 = *v14;
        llvm::raw_ostream::write(a1, "                                                                                ", 2uLL);
        llvm::Value::print(v16, a1, 0);
        int v17 = (unsigned char *)*((void *)a1 + 4);
        if (*((unsigned char **)a1 + 3) == v17)
        {
          llvm::raw_ostream::write(a1, "\n", 1uLL);
        }
        else
        {
          unsigned char *v17 = 10;
          ++*((void *)a1 + 4);
        }
        ++v14;
        v15 -= 8;
      }
      while (v15);
    }
  }
  uint64_t v29 = *(void *)(a2 + 32);
  uint64_t v30 = *(void *)(a2 + 40);
  if (v29 == v30) {
    unsigned int v31 = " Edges:none!\n";
  }
  else {
    unsigned int v31 = " Edges:\n";
  }
  if (v29 == v30) {
    size_t v32 = 13;
  }
  else {
    size_t v32 = 8;
  }
  int v33 = (void *)*((void *)a1 + 4);
  if (v32 <= *((void *)a1 + 3) - (void)v33)
  {
    memcpy(v33, v31, v32);
    *((void *)a1 + 4) += v32;
  }
  else
  {
    llvm::raw_ostream::write(a1, v31, v32);
  }
  int v34 = *(uint64_t **)(a2 + 32);
  BOOL v35 = *(uint64_t **)(a2 + 40);
  while (v34 != v35)
  {
    uint64_t v36 = llvm::raw_ostream::write(a1, "                                                                                ", 2uLL);
    uint64_t v37 = *v34++;
    llvm::operator<<(v36, v37);
  }
  return a1;
}

llvm::raw_ostream *llvm::operator<<(llvm::raw_ostream *this, uint64_t a2)
{
  size_t v4 = (unsigned char *)*((void *)this + 4);
  if (*((unsigned char **)this + 3) == v4)
  {
    llvm::raw_ostream::write(this, "[", 1uLL);
  }
  else
  {
    *size_t v4 = 91;
    ++*((void *)this + 4);
  }
  uint64_t v5 = *(int *)(a2 + 8);
  if (v5 <= 3)
  {
    uint64_t v6 = off_1E682C6A8[v5];
    size_t v7 = strlen(v6);
    size_t v8 = (void *)*((void *)this + 4);
    if (v7 <= *((void *)this + 3) - (void)v8)
    {
      if (v7)
      {
        memcpy(v8, v6, v7);
        *((void *)this + 4) += v7;
      }
    }
    else
    {
      llvm::raw_ostream::write(this, v6, v7);
    }
  }
  uint64_t v9 = *((void *)this + 4);
  if ((unint64_t)(*((void *)this + 3) - v9) > 4)
  {
    *(unsigned char *)(v9 + 4) = 32;
    *(_DWORD *)uint64_t v9 = 1869881437;
    *((void *)this + 4) += 5;
  }
  else
  {
    llvm::raw_ostream::write(this, "] to ", 5uLL);
  }
  llvm::write_hex(this, *(void *)a2, 3, 0, 0);
  unint64_t v10 = (unsigned char *)*((void *)this + 4);
  if (*((unsigned char **)this + 3) == v10)
  {
    llvm::raw_ostream::write(this, "\n", 1uLL);
  }
  else
  {
    *unint64_t v10 = 10;
    ++*((void *)this + 4);
  }
  return this;
}

{
  uint64_t v4;
  _WORD *v5;
  uint64_t v6;
  unsigned char *v7;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;

  size_t v4 = *((void *)this + 4);
  if ((unint64_t)(*((void *)this + 3) - v4) > 0xB)
  {
    *(_DWORD *)(v4 + 8) = 677737569;
    *(void *)size_t v4 = *(void *)"range-state(";
    *((void *)this + 4) += 12;
  }
  else
  {
    llvm::raw_ostream::write(this, "range-state(", 0xCuLL);
  }
  sub_1CD098D14(this, *(unsigned int *)(a2 + 8), 0, 0, 0);
  uint64_t v5 = (_WORD *)*((void *)this + 4);
  if (*((void *)this + 3) - (void)v5 > 1uLL)
  {
    *uint64_t v5 = 15401;
    *((void *)this + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(this, ")<", 2uLL);
  }
  unint64_t v10 = *(_DWORD *)(a2 + 56);
  if (v10 > 0x40) {
    operator new[]();
  }
  uint64_t v9 = *(void *)(a2 + 48);
  uint64_t v12 = *(_DWORD *)(a2 + 72);
  if (v12 > 0x40) {
    operator new[]();
  }
  int v11 = *(void *)(a2 + 64);
  llvm::ConstantRange::print((llvm::ConstantRange *)&v9, this);
  if (v12 >= 0x41 && v11) {
    MEMORY[0x1D25D9CB0](v11, 0x1000C8000313F17);
  }
  if (v10 >= 0x41 && v9) {
    MEMORY[0x1D25D9CB0](v9, 0x1000C8000313F17);
  }
  uint64_t v6 = *((void *)this + 4);
  if ((unint64_t)(*((void *)this + 3) - v6) > 2)
  {
    *(unsigned char *)(v6 + 2) = 32;
    *(_WORD *)uint64_t v6 = 12064;
    *((void *)this + 4) += 3;
  }
  else
  {
    llvm::raw_ostream::write(this, " / ", 3uLL);
  }
  unint64_t v10 = *(_DWORD *)(a2 + 24);
  if (v10 > 0x40) {
    operator new[]();
  }
  uint64_t v9 = *(void *)(a2 + 16);
  uint64_t v12 = *(_DWORD *)(a2 + 40);
  if (v12 > 0x40) {
    operator new[]();
  }
  int v11 = *(void *)(a2 + 32);
  llvm::ConstantRange::print((llvm::ConstantRange *)&v9, this);
  if (v12 >= 0x41 && v11) {
    MEMORY[0x1D25D9CB0](v11, 0x1000C8000313F17);
  }
  if (v10 >= 0x41 && v9) {
    MEMORY[0x1D25D9CB0](v9, 0x1000C8000313F17);
  }
  size_t v7 = (unsigned char *)*((void *)this + 4);
  if (*((unsigned char **)this + 3) == v7)
  {
    llvm::raw_ostream::write(this, ">", 1uLL);
  }
  else
  {
    *size_t v7 = 62;
    ++*((void *)this + 4);
  }
  return llvm::operator<<(this, a2);
}

{
  _WORD *v4;
  unint64_t v5;
  llvm::raw_ostream *v6;
  int v7;
  _WORD *v8;
  _WORD *v9;
  unint64_t v10;
  const char *v11;
  llvm::raw_ostream *v12;
  size_t v13;
  uint64_t v15;
  unsigned char *v16;
  uint64_t v17;

  size_t v4 = (_WORD *)*((void *)this + 4);
  if (*((void *)this + 3) - (void)v4 > 1uLL)
  {
    *size_t v4 = 23328;
    *((void *)this + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(this, " [", 2uLL);
  }
  uint64_t v5 = *(int *)(a2 + 32);
  if ((v5 & 0x80000000) != 0)
  {
    uint64_t v5 = -(uint64_t)v5;
    uint64_t v6 = this;
    size_t v7 = 1;
  }
  else
  {
    uint64_t v6 = this;
    size_t v7 = 0;
  }
  sub_1CD098D14(v6, v5, 0, 0, v7);
  size_t v8 = (_WORD *)*((void *)this + 4);
  if (*((void *)this + 3) - (void)v8 > 1uLL)
  {
    *size_t v8 = 8285;
    *((void *)this + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(this, "] ", 2uLL);
  }
  llvm::Value::print(*(llvm::Value **)(a2 + 8), this, 0);
  if (*(void *)a2 != *(void *)(a2 + 8))
  {
    uint64_t v15 = *((void *)this + 4);
    if ((unint64_t)(*((void *)this + 3) - v15) > 4)
    {
      *(unsigned char *)(v15 + 4) = 32;
      *(_DWORD *)uint64_t v15 = 1634301472;
      *((void *)this + 4) += 5;
    }
    else
    {
      llvm::raw_ostream::write(this, " via ", 5uLL);
    }
    llvm::Value::print(*(llvm::Value **)a2, this, 0);
  }
  if (*(unsigned char *)(a2 + 24))
  {
    uint64_t v9 = (_WORD *)*((void *)this + 4);
    unint64_t v10 = *((void *)this + 3) - (void)v9;
    if (*(void *)(a2 + 16))
    {
      if (v10 > 1)
      {
        *uint64_t v9 = 23328;
        *((void *)this + 4) += 2;
      }
      else
      {
        llvm::raw_ostream::write(this, " [", 2uLL);
      }
      llvm::Value::print(*(llvm::Value **)(a2 + 16), this, 0);
      unsigned int v16 = (unsigned char *)*((void *)this + 4);
      if (*((unsigned char **)this + 3) == v16)
      {
        int v11 = "]";
        uint64_t v12 = this;
        uint64_t v13 = 1;
        goto LABEL_12;
      }
      *unsigned int v16 = 93;
      int v17 = *((void *)this + 4) + 1;
    }
    else
    {
      if (v10 <= 0xD)
      {
        int v11 = " [ <unknown> ]";
        uint64_t v12 = this;
        uint64_t v13 = 14;
LABEL_12:
        llvm::raw_ostream::write(v12, v11, v13);
        return this;
      }
      qmemcpy(v9, " [ <unknown> ]", 14);
      int v17 = *((void *)this + 4) + 14;
    }
    *((void *)this + 4) = v17;
  }
  return this;
}

{
  uint64_t v4;
  uint64_t v5;
  unsigned char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned char *v11;
  unsigned int *v13;
  uint64_t v14;
  int v15;
  __int16 v16;
  char v17;

  size_t v4 = *((void *)this + 4);
  if ((unint64_t)(*((void *)this + 3) - v4) > 0x10)
  {
    *(unsigned char *)(v4 + 16) = 32;
    *(_OWORD *)size_t v4 = *(_OWORD *)"FunctionAddress: ";
    *((void *)this + 4) += 17;
  }
  else
  {
    llvm::raw_ostream::write(this, "FunctionAddress: ", 0x11uLL);
  }
  uint64_t v13 = **(unsigned int ***)a2;
  int v14 = 0;
  uint64_t v15 = 8;
  unsigned int v16 = 1;
  int v17 = 1;
  llvm::raw_ostream::operator<<(this, (uint64_t)&v13);
  uint64_t v5 = *((void *)this + 4);
  if ((unint64_t)(*((void *)this + 3) - v5) > 0x11)
  {
    *(_WORD *)(v5 + 16) = 8250;
    *(_OWORD *)uint64_t v5 = *(_OWORD *)", NumFaultingPCs: ";
    *((void *)this + 4) += 18;
  }
  else
  {
    llvm::raw_ostream::write(this, ", NumFaultingPCs: ", 0x12uLL);
  }
  sub_1CD098D14(this, *(unsigned int *)(*(void *)a2 + 8), 0, 0, 0);
  uint64_t v6 = (unsigned char *)*((void *)this + 4);
  if (*((unsigned char **)this + 3) == v6)
  {
    llvm::raw_ostream::write(this, "\n", 1uLL);
  }
  else
  {
    *uint64_t v6 = 10;
    ++*((void *)this + 4);
  }
  size_t v7 = *(unsigned int *)(*(void *)a2 + 8);
  if (v7)
  {
    size_t v8 = 0;
    uint64_t v9 = 12 * v7;
    do
    {
      unint64_t v10 = *(void *)(a2 + 8);
      uint64_t v13 = (unsigned int *)(v8 + *(void *)a2 + 16);
      int v14 = v10;
      llvm::operator<<(this, &v13);
      int v11 = (unsigned char *)*((void *)this + 4);
      if (*((unsigned char **)this + 3) == v11)
      {
        llvm::raw_ostream::write(this, "\n", 1uLL);
      }
      else
      {
        *int v11 = 10;
        ++*((void *)this + 4);
      }
      v8 += 12;
    }
    while (v9 != v8);
  }
  return this;
}

double llvm::SimpleDDGNode::SimpleDDGNode(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 56) = 1;
  *(void *)(a1 + 80) = a2;
  *(void *)a1 = &unk_1F2602408;
  *(void *)(a1 + 64) = a1 + 80;
  *(void *)&double result = 0x200000001;
  *(void *)(a1 + 72) = 0x200000001;
  return result;
}

{
  double result;

  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 56) = 1;
  *(void *)(a1 + 80) = a2;
  *(void *)a1 = &unk_1F2602408;
  *(void *)(a1 + 64) = a1 + 80;
  *(void *)&double result = 0x200000001;
  *(void *)(a1 + 72) = 0x200000001;
  return result;
}

llvm::SimpleDDGNode *llvm::SimpleDDGNode::SimpleDDGNode(llvm::SimpleDDGNode *this, const llvm::SimpleDDGNode *a2)
{
  size_t v4 = (const llvm::SimpleDDGNode *)sub_1CBFCAEA0((uint64_t)this, (uint64_t)a2);
  *(void *)size_t v4 = &unk_1F2602408;
  *((void *)v4 + 8) = (char *)v4 + 80;
  *((void *)v4 + 9) = 0x200000000;
  unsigned int v5 = *((_DWORD *)a2 + 18);
  if (v5) {
    BOOL v6 = v4 == a2;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    if (v5 >= 3) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    memcpy((char *)v4 + 80, *((const void **)a2 + 8), 8 * *((unsigned int *)a2 + 18));
    *((_DWORD *)this + 18) = v5;
  }
  return this;
}

uint64_t sub_1CBFCAEA0(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 8) = 0;
  sub_1CBFCB9AC(a1 + 8, a2 + 8);
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 32) = 0;
  sub_1CBFCBA2C((void *)(a1 + 32), *(const void **)(a2 + 32), *(void *)(a2 + 40), (uint64_t)(*(void *)(a2 + 40) - *(void *)(a2 + 32)) >> 3);
  *(void *)a1 = &unk_1F26024F0;
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  return a1;
}

uint64_t llvm::SimpleDDGNode::SimpleDDGNode(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 16) = 0;
  int v3 = *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(a2 + 20) = v3;
  int v4 = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a2 + 24) = v4;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 32) = 0;
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(void *)a1 = &unk_1F2602408;
  *(void *)(a1 + 64) = a1 + 80;
  *(void *)(a1 + 72) = 0x200000000;
  uint64_t v5 = *(unsigned int *)(a2 + 72);
  if (v5 && a1 != a2)
  {
    size_t v7 = *(const void **)(a2 + 64);
    if (v7 == (const void *)(a2 + 80))
    {
      if (v5 >= 3) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy((void *)(a1 + 80), v7, 8 * v5);
      *(_DWORD *)(a1 + 72) = v5;
    }
    else
    {
      *(void *)(a1 + 64) = v7;
      int v9 = *(_DWORD *)(a2 + 76);
      *(_DWORD *)(a1 + 72) = v5;
      *(_DWORD *)(a1 + 76) = v9;
      *(void *)(a2 + 64) = a2 + 80;
      *(_DWORD *)(a2 + 76) = 0;
    }
    *(_DWORD *)(a2 + 72) = 0;
  }
  return a1;
}

void llvm::SimpleDDGNode::~SimpleDDGNode(llvm::SimpleDDGNode *this)
{
  *(void *)this = &unk_1F2602408;
  *((_DWORD *)this + 18) = 0;
  uint64_t v2 = (char *)*((void *)this + 8);
  if (v2 != (char *)this + 80) {
    free(v2);
  }
  sub_1CD456CB4((void *)this + 1);
}

{
  char *v2;

  *(void *)this = &unk_1F2602408;
  *((_DWORD *)this + 18) = 0;
  uint64_t v2 = (char *)*((void *)this + 8);
  if (v2 != (char *)this + 80) {
    free(v2);
  }
  sub_1CD456CB4((void *)this + 1);
}

{
  char *v2;
  uint64_t vars8;

  *(void *)this = &unk_1F2602408;
  *((_DWORD *)this + 18) = 0;
  uint64_t v2 = (char *)*((void *)this + 8);
  if (v2 != (char *)this + 80) {
    free(v2);
  }
  sub_1CD456CB4((void *)this + 1);

  JUMPOUT(0x1D25D9CE0);
}

llvm::PiBlockDDGNode *llvm::PiBlockDDGNode::PiBlockDDGNode(llvm::PiBlockDDGNode *this, const llvm::PiBlockDDGNode *a2)
{
  int v4 = (void *)sub_1CBFCAEA0((uint64_t)this, (uint64_t)a2);
  *int v4 = &unk_1F2602428;
  v4[8] = v4 + 10;
  uint64_t v5 = (uint64_t)(v4 + 8);
  *((void *)this + 9) = 0x400000000;
  if (*((_DWORD *)a2 + 18)) {
    llvm::DirectedGraph<llvm::DDGNode,llvm::DDGEdge>::operator=(v5, (uint64_t)a2 + 64);
  }
  return this;
}

uint64_t llvm::PiBlockDDGNode::PiBlockDDGNode(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 16) = 0;
  int v3 = *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(a2 + 20) = v3;
  int v4 = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a2 + 24) = v4;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 32) = 0;
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(void *)a1 = &unk_1F2602428;
  *(void *)(a1 + 64) = a1 + 80;
  uint64_t v5 = a1 + 64;
  *(void *)(a1 + 72) = 0x400000000;
  if (*(_DWORD *)(a2 + 72)) {
    sub_1CD41C56C(v5, a2 + 64);
  }
  return a1;
}

{
  uint64_t v3;

  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 56) = 3;
  *(void *)a1 = &unk_1F2602428;
  *(void *)(a1 + 64) = a1 + 80;
  int v3 = a1 + 64;
  *(void *)(a1 + 72) = 0x400000000;
  if (*(_DWORD *)(a2 + 8)) {
    llvm::DirectedGraph<llvm::DDGNode,llvm::DDGEdge>::operator=(v3, a2);
  }
  return a1;
}

void llvm::PiBlockDDGNode::~PiBlockDDGNode(llvm::PiBlockDDGNode *this)
{
  *(void *)this = &unk_1F2602428;
  *((_DWORD *)this + 18) = 0;
  uint64_t v2 = (char *)*((void *)this + 8);
  if (v2 != (char *)this + 80) {
    free(v2);
  }
  sub_1CD456CB4((void *)this + 1);
}

{
  char *v2;

  *(void *)this = &unk_1F2602428;
  *((_DWORD *)this + 18) = 0;
  uint64_t v2 = (char *)*((void *)this + 8);
  if (v2 != (char *)this + 80) {
    free(v2);
  }
  sub_1CD456CB4((void *)this + 1);
}

{
  char *v2;
  uint64_t vars8;

  *(void *)this = &unk_1F2602428;
  *((_DWORD *)this + 18) = 0;
  uint64_t v2 = (char *)*((void *)this + 8);
  if (v2 != (char *)this + 80) {
    free(v2);
  }
  sub_1CD456CB4((void *)this + 1);

  JUMPOUT(0x1D25D9CE0);
}

void llvm::DataDependenceGraph::DataDependenceGraph(llvm::DataDependenceGraph *this, llvm::Function *a2, llvm::DependenceInfo *a3)
{
  v122[8] = *MEMORY[0x1E4F143B8];
  *((void *)this + 1sub_1CD456CB4((void *)this + 1) = (char *)this + 104;
  *((void *)this + 12) = 0xA00000000;
  if ((*((unsigned char *)a2 + 23) & 0x10) != 0)
  {
    uint64_t v6 = ***(void ***)a2;
    uint64_t v7 = *(void *)(v6 + 152);
    uint64_t v8 = *(unsigned int *)(v6 + 168);
    if (v8)
    {
      LODWORD(v9) = (v8 - 1) & ((a2 >> 4) ^ (a2 >> 9));
      uint64_t v10 = v7 + 16 * v9;
      int v11 = *(llvm::Function **)v10;
      if (*(llvm::Function **)v10 != a2)
      {
        int v12 = 1;
        do
        {
          if (v11 == (llvm::Function *)-4096) {
            goto LABEL_8;
          }
          int v13 = v9 + v12++;
          uint64_t v9 = v13 & (v8 - 1);
          int v11 = *(llvm::Function **)(v7 + 16 * v9);
        }
        while (v11 != a2);
        uint64_t v10 = v7 + 16 * v9;
      }
    }
    else
    {
LABEL_8:
      uint64_t v10 = v7 + 16 * v8;
    }
    int v14 = *(unint64_t **)(v10 + 8);
    unint64_t v17 = *v14;
    unsigned int v16 = v14 + 2;
    size_t v15 = v17;
    if (v17 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    if (v15 >= 0x17)
    {
      uint64_t v19 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v15 | 7) != 0x17) {
        uint64_t v19 = v15 | 7;
      }
      uint64_t v20 = v19 + 1;
      p_dst = (long long *)operator new(v19 + 1);
      *((void *)&__dst + sub_1CD456CB4((void *)this + 1) = v15;
      unsigned int v74 = (llvm::DependenceInfo *)(v20 | 0x8000000000000000);
      *(void *)&long long __dst = p_dst;
    }
    else
    {
      HIBYTE(v74) = v15;
      p_dst = &__dst;
      if (!v15) {
        goto LABEL_17;
      }
    }
    memmove(p_dst, v16, v15);
  }
  else
  {
    size_t v15 = 0;
    HIBYTE(v74) = 0;
    p_dst = &__dst;
  }
LABEL_17:
  *((unsigned char *)p_dst + v15) = 0;
  int v21 = SHIBYTE(v74);
  *(void *)this = &unk_1F2602598;
  uint64_t v22 = (_OWORD *)((char *)this + 8);
  if (v21 < 0)
  {
    int v23 = (void *)__dst;
    sub_1CB8BDF7C((uint64_t)v22, (const void *)__dst, *((unint64_t *)&__dst + 1));
    long long v24 = *(_OWORD *)a3;
    long long v25 = *((_OWORD *)a3 + 2);
    *((_OWORD *)this + 3) = *((_OWORD *)a3 + 1);
    *((_OWORD *)this + 4) = v25;
    *((_OWORD *)this + 2) = v24;
    *((void *)this + 10) = 0;
    operator delete(v23);
  }
  else
  {
    *uint64_t v22 = __dst;
    *((void *)this + 3) = v74;
    long long v27 = *((_OWORD *)a3 + 1);
    long long v26 = *((_OWORD *)a3 + 2);
    *((_OWORD *)this + 2) = *(_OWORD *)a3;
    *((_OWORD *)this + 3) = v27;
    *((_OWORD *)this + 4) = v26;
    *((void *)this + 10) = 0;
  }
  *(void *)this = &unk_1F2602448;
  *((void *)this + 23) = 0;
  *((void *)this + 24) = 0;
  *((_DWORD *)this + 50) = 0;
  int v120 = v122;
  uint64_t v121 = 0x800000000;
  int v62 = a2;
  sub_1CD47573C((uint64_t)&v62, (uint64_t)&v63);
  long long v55 = 0uLL;
  long long v56 = 0u;
  int v28 = v63;
  LODWORD(v107) = v63;
  uint64_t v29 = v64;
  uint64_t v64 = 0;
  int v30 = v66;
  int v66 = 0;
  long long v31 = v68;
  size_t v32 = v67;
  int v33 = v69;
  unint64_t v67 = 0;
  long long v68 = 0uLL;
  long long v34 = v70;
  uint64_t v52 = v31;
  uint64_t v53 = v70;
  long long v70 = 0uLL;
  unsigned int v69 = 0;
  BOOL v35 = v71;
  uint64_t v54 = v72;
  long long v36 = v72;
  int v71 = 0;
  long long v72 = 0uLL;
  LODWORD(v94) = 0;
  *(void *)&long long v56 = 0;
  DWORD2(v56) = 0;
  uint64_t v61 = 0;
  long long v59 = 0u;
  long long v60 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  LODWORD(__dst) = v63;
  *((void *)&__dst + sub_1CD456CB4((void *)this + 1) = v29;
  uint64_t v108 = 0;
  uint64_t v37 = v65;
  unint64_t v65 = 0;
  unsigned int v74 = v37;
  uint64_t v109 = 0;
  LODWORD(v75) = v30;
  int v110 = 0;
  long long v77 = v31;
  uint64_t v112 = 0;
  uint64_t v111 = 0;
  unint64_t v76 = v32;
  unsigned int v78 = v33;
  long long v79 = v34;
  uint64_t v113 = 0;
  __s1 = 0;
  uint64_t v115 = 0;
  uint64_t v116 = 0;
  int v80 = v35;
  long long v81 = v36;
  uint64_t v118 = 0;
  uint64_t v117 = 0;
  uint64_t v119 = 0;
  LODWORD(v82) = 0;
  v83[0] = 0;
  uint64_t v95 = 0;
  v83[1] = 0;
  uint64_t v96 = 0;
  int v84 = 0;
  int v97 = 0;
  uint64_t v85 = 0;
  uint64_t v86 = 0;
  uint64_t v99 = 0;
  uint64_t v98 = 0;
  uint64_t v87 = 0;
  uint64_t v88 = 0;
  uint64_t v89 = 0;
  uint64_t v90 = 0;
  uint64_t v100 = 0;
  __s2 = 0;
  uint64_t v102 = 0;
  uint64_t v103 = 0;
  uint64_t v91 = 0;
  uint64_t v92 = 0;
  uint64_t v93 = 0;
  uint64_t v105 = 0;
  uint64_t v104 = 0;
  uint64_t v106 = 0;
  sub_1CD4750A4(&v94);
  sub_1CD4750A4(&v107);
  sub_1CD4750A4(&v55);
  sub_1CD4750A4(&v63);
  LODWORD(v107) = v28;
  uint64_t v109 = 0;
  uint64_t v108 = 0;
  int v110 = 0;
  sub_1CBFCBCC4((uint64_t)&v108, (uint64_t)&__dst + 8);
  uint64_t v112 = 0;
  uint64_t v111 = 0;
  uint64_t v113 = 0;
  sub_1CBFCBA2C(&v111, v32, v52, (v52 - (uint64_t)v32) >> 3);
  uint64_t v115 = 0;
  __s1 = 0;
  uint64_t v116 = 0;
  sub_1CBFCBA2C(&__s1, v33, v53, (v53 - (uint64_t)v33) >> 3);
  uint64_t v118 = 0;
  uint64_t v117 = 0;
  uint64_t v119 = 0;
  sub_1CBFCBD44(&v117, v35, v54, (v54 - (uint64_t)v35) >> 5);
  LODWORD(v94) = 0;
  uint64_t v95 = 0;
  uint64_t v96 = 0;
  int v97 = 0;
  sub_1CBFCBCC4((uint64_t)&v95, (uint64_t)v83);
  uint64_t v99 = 0;
  uint64_t v98 = 0;
  uint64_t v100 = 0;
  sub_1CBFCBA2C(&v98, 0, 0, 0);
  uint64_t v102 = 0;
  __s2 = 0;
  uint64_t v103 = 0;
  sub_1CBFCBA2C(&__s2, 0, 0, 0);
  uint64_t v105 = 0;
  uint64_t v104 = 0;
  uint64_t v106 = 0;
  sub_1CBFCBD44(&v104, 0, 0, 0);
  uint64_t v38 = v104;
  uint64_t v39 = v105 - v104;
  while (1)
  {
    uint64_t v40 = v117;
    if (v118 - v117 == v39)
    {
      if (v117 == v118)
      {
LABEL_23:
        if ((char *)v115 - (unsigned char *)__s1 == v102 - (void)__s2 && !memcmp(__s1, __s2, (char *)v115 - (unsigned char *)__s1))
        {
          sub_1CD4750A4(&v94);
          sub_1CD4750A4(&v107);
          sub_1CD4750A4(&v82);
          sub_1CD4750A4(&__dst);
          if (v121)
          {
            uint64_t v48 = &v120[v121 - 1];
            if (v120 < v48)
            {
              uint64_t v49 = v120 + 1;
              do
              {
                uint64_t v50 = *(v49 - 1);
                *(v49 - sub_1CD456CB4((void *)this + 1) = *v48;
                *v48-- = v50;
              }
              while (v49++ < v48);
            }
          }
          *((void *)&__dst + sub_1CD456CB4((void *)this + 1) = this;
          unsigned int v74 = a3;
          uint64_t v75 = &v120;
          unint64_t v76 = 0;
          *(void *)&long long v77 = 0;
          DWORD2(v77) = 0;
          unsigned int v78 = 0;
          *(void *)&long long v79 = 0;
          DWORD2(v79) = 0;
          int v80 = 0;
          *(void *)&long long v81 = 0;
          DWORD2(v8sub_1CD456CB4((void *)this + 1) = 0;
          *(void *)&long long __dst = &unk_1F2602468;
          sub_1CD47442C();
        }
      }
      else
      {
        uint64_t v47 = v38;
        while (*(void *)v40 == *(void *)v47
             && *(_DWORD *)(v40 + 16) == *(_DWORD *)(v47 + 16)
             && *(_DWORD *)(v40 + 24) == *(_DWORD *)(v47 + 24))
        {
          v40 += 32;
          v47 += 32;
          if (v40 == v118) {
            goto LABEL_23;
          }
        }
      }
    }
    uint64_t v41 = (uint64_t *)__s1;
    unint64_t v42 = v115;
    unint64_t v43 = (char *)v115 - (unsigned char *)__s1;
    int v44 = v121;
    if ((unint64_t)v121 + (((char *)v115 - (unsigned char *)__s1) >> 3) > HIDWORD(v121)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    if (__s1 != v115)
    {
      uint64_t v45 = &v120[v121];
      do
      {
        uint64_t v46 = *v41++;
        *v45++ = v46;
      }
      while (v41 != v42);
    }
    LODWORD(v12sub_1CD456CB4((void *)this + 1) = v44 + (v43 >> 3);
    sub_1CD47588C(&v107);
  }
}

void *sub_1CBFCB9AC(uint64_t a1, uint64_t a2)
{
  double result = (void *)MEMORY[0x1D25D9CD0](*(void *)a1, 8);
  uint64_t v5 = *(unsigned int *)(a2 + 16);
  *(_DWORD *)(a1 + 16) = v5;
  if (v5)
  {
    uint64_t v6 = operator new(8 * v5, (std::align_val_t)8uLL);
    *(void *)a1 = v6;
    *(void *)(a1 + 8) = *(void *)(a2 + 8);
    uint64_t v7 = *(const void **)a2;
    size_t v8 = 8 * *(unsigned int *)(a1 + 16);
    return memcpy(v6, v7, v8);
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
  }
  return result;
}

void *sub_1CBFCBA2C(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >> 61) {
      abort();
    }
    uint64_t v7 = result;
    double result = operator new(8 * a4);
    size_t v8 = result;
    *uint64_t v7 = result;
    v7[1] = result;
    v7[2] = &result[a4];
    size_t v9 = a3 - (void)a2;
    if (v9) {
      double result = memcpy(result, a2, v9);
    }
    v7[1] = (char *)v8 + v9;
  }
  return result;
}

uint64_t sub_1CBFCBAB0(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a2;
  unint64_t v4 = ((*(void *)(a2 + 40) - *(void *)(a2 + 32)) >> 3);
  unint64_t v5 = v4 | (v4 >> 1) | ((v4 | (v4 >> 1)) >> 2);
  unint64_t v6 = v5 | (v5 >> 4) | ((v5 | (v5 >> 4)) >> 8);
  sub_1CB837D60((_DWORD *)(a1 + 8), ((v6 >> 16) | v6) + 1);
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  unint64_t v7 = *(void *)(a2 + 40) - *(void *)(a2 + 32);
  uint64_t v8 = (v7 >> 3);
  if ((v7 >> 3))
  {
    size_t v9 = (char *)operator new(8 * v8);
    *(void *)(a1 + 32) = v9;
    *(void *)(a1 + 40) = v9;
    *(void *)(a1 + 48) = &v9[8 * v8];
  }
  return a1;
}

void *sub_1CBFCBB34(void *a1)
{
  uint64_t v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }
  MEMORY[0x1D25D9CD0](a1[1], 8);
  return a1;
}

unsigned int *sub_1CBFCBB74(unsigned int *result, unsigned char *a2, unsigned char *a3)
{
  int v3 = result;
  size_t v4 = a3 - a2;
  uint64_t v5 = result[2];
  if (v5 + ((a3 - a2) >> 3) > (unint64_t)result[3]) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (a2 != a3)
  {
    double result = (unsigned int *)memcpy((void *)(*(void *)result + 8 * v5), a2, v4);
    LODWORD(v5) = v3[2];
  }
  void v3[2] = v5 + (v4 >> 3);
  return result;
}

void *sub_1CBFCBC00(uint64_t a1, uint64_t *a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (!v3)
  {
    int v13 = 0;
LABEL_16:
    unint64_t v6 = sub_1CBFAF8D8(a1, (uint64_t)a2, a2, v13);
    *unint64_t v6 = *a2;
    *((_DWORD *)v6 + 2) = 0;
    return v6;
  }
  int v4 = v3 - 1;
  unsigned int v5 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v3 - 1);
  unint64_t v6 = (void *)(*(void *)a1 + 16 * v5);
  uint64_t v7 = *v6;
  if (*a2 != *v6)
  {
    size_t v9 = 0;
    int v10 = 1;
    while (v7 != -4096)
    {
      if (v9) {
        BOOL v11 = 0;
      }
      else {
        BOOL v11 = v7 == -8192;
      }
      if (v11) {
        size_t v9 = v6;
      }
      unsigned int v12 = v5 + v10++;
      unsigned int v5 = v12 & v4;
      unint64_t v6 = (void *)(*(void *)a1 + 16 * (v12 & v4));
      uint64_t v7 = *v6;
      if (*a2 == *v6) {
        return v6;
      }
    }
    if (v9) {
      int v13 = v9;
    }
    else {
      int v13 = v6;
    }
    goto LABEL_16;
  }
  return v6;
}

void *sub_1CBFCBCC4(uint64_t a1, uint64_t a2)
{
  double result = (void *)MEMORY[0x1D25D9CD0](*(void *)a1, 8);
  uint64_t v5 = *(unsigned int *)(a2 + 16);
  *(_DWORD *)(a1 + 16) = v5;
  if (v5)
  {
    unint64_t v6 = operator new(16 * v5, (std::align_val_t)8uLL);
    *(void *)a1 = v6;
    *(void *)(a1 + 8) = *(void *)(a2 + 8);
    uint64_t v7 = *(const void **)a2;
    size_t v8 = 16 * *(unsigned int *)(a1 + 16);
    return memcpy(v6, v7, v8);
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
  }
  return result;
}

void *sub_1CBFCBD44(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >> 59) {
      abort();
    }
    uint64_t v7 = result;
    double result = operator new(32 * a4);
    size_t v8 = result;
    *uint64_t v7 = result;
    v7[1] = result;
    v7[2] = &result[4 * a4];
    uint64_t v9 = a3 - (void)a2;
    if (v9) {
      double result = memcpy(result, a2, v9 - 4);
    }
    v7[1] = (char *)v8 + v9;
  }
  return result;
}

uint64_t sub_1CBFCBDC8()
{
  char v4 = 1;
  uint64_t v5 = &v4;
  int v2 = 1;
  int v3 = 1;
  v1.n128_u64[0] = (unint64_t)"Simplify DDG by merging nodes that have less interesting edges.";
  v1.n128_u64[1] = 63;
  sub_1CD462280((llvm::cl::Option *)&unk_1EBCC4FA8, "ddg-simplify", &v5, &v3, &v2, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCC4FA8, &dword_1CB82C000);
  char v4 = 1;
  uint64_t v5 = &v4;
  int v2 = 1;
  int v3 = 1;
  v1.n128_u64[0] = (unint64_t)"Create pi-block nodes.";
  v1.n128_u64[1] = 22;
  sub_1CD4752B8(&v5, &v3, &v2, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCC5068, &dword_1CB82C000);
}

void llvm::DOTGraphTraits<llvm::DataDependenceGraph const*>::getNodeLabel(unsigned char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  if (*a1) {
    llvm::DOTGraphTraits<llvm::DataDependenceGraph const*>::getSimpleNodeLabel(a2, a4);
  }
  else {
    llvm::DOTGraphTraits<llvm::DataDependenceGraph const*>::getVerboseNodeLabel(a2, a3, a4);
  }
}

void llvm::DOTGraphTraits<llvm::DataDependenceGraph const*>::getEdgeAttributes(unsigned char *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v6 = *a3;
  if (*a1) {
    llvm::DOTGraphTraits<llvm::DataDependenceGraph const*>::getSimpleEdgeAttributes(v6, a5);
  }
  else {
    llvm::DOTGraphTraits<llvm::DataDependenceGraph const*>::getVerboseEdgeAttributes(a2, v6, a4, a5);
  }
}

BOOL llvm::DOTGraphTraits<llvm::DataDependenceGraph const*>::isNodeHidden(unsigned char *a1, const llvm::DDGNode *a2, llvm::DataDependenceGraph *this)
{
  return *a1 && *((_DWORD *)a2 + 14) == 4 || llvm::DataDependenceGraph::getPiBlock(this, a2) != 0;
}

void llvm::DependenceGraphInfo<llvm::DDGNode>::getDependenceString(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  v20[1] = *MEMORY[0x1E4F143B8];
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v16 = 0;
  int v7 = 0;
  char v11 = 0;
  uint64_t v12 = 0;
  int v14 = __p;
  int v13 = 0;
  uint64_t v6 = &unk_1F2646F30;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  unsigned __int8 v18 = (llvm::raw_ostream *)v20;
  uint64_t v19 = 0x100000000;
  if (llvm::DependenceGraphInfo<llvm::DDGNode>::getDependencies(a1, a2, a3, (uint64_t)&v18))
  {
    v17[0] = ", ";
    v17[1] = 2;
    sub_1CD47711C(v18, (llvm::Instruction ***)v18 + v19, (llvm::raw_ostream *)&v6, (llvm::raw_ostream *)&v6, (uint64_t)v17);
  }
  if (*((char *)v14 + 23) < 0)
  {
    sub_1CB8BDF7C(a4, *v14, (unint64_t)v14[1]);
  }
  else
  {
    long long v5 = *(_OWORD *)v14;
    *(void *)(a4 + 16) = v14[2];
    *(_OWORD *)a4 = v5;
  }
  sub_1CBFCC82C((char **)&v18);
  uint64_t v6 = &unk_1F2646B98;
  if (v13 == 1 && v8) {
    MEMORY[0x1D25D9CB0](v8, 0x1000C8077774924);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1CBFCC0AC(uint64_t a1, unint64_t a2)
{
  char v69 = 0;
  LOBYTE(v68[0]) = 0;
  char v4 = *(llvm::raw_ostream **)a1;
  uint64_t v5 = *(void *)(*(void *)a1 + 32);
  if ((unint64_t)(*(void *)(*(void *)a1 + 24) - v5) > 4)
  {
    *(unsigned char *)(v5 + 4) = 101;
    *(_DWORD *)uint64_t v5 = 1685016073;
    *((void *)v4 + 4) += 5;
  }
  else
  {
    llvm::raw_ostream::write(*(llvm::raw_ostream **)a1, "\tNode", 5uLL);
  }
  llvm::write_hex(v4, a2, 3, 0, 0);
  uint64_t v6 = (void *)*((void *)v4 + 4);
  if (*((void *)v4 + 3) - (void)v6 > 7uLL)
  {
    *uint64_t v6 = 0x3D65706168735B20;
    *((void *)v4 + 4) += 8;
  }
  else
  {
    llvm::raw_ostream::write(v4, " [shape=", 8uLL);
  }
  int v7 = *(llvm::raw_ostream **)a1;
  uint64_t v8 = *(void *)(*(void *)a1 + 32);
  unint64_t v9 = *(void *)(*(void *)a1 + 24) - v8;
  if (*(unsigned char *)(a1 + 16))
  {
    if (v9 <= 4)
    {
      uint64_t v10 = "none,";
      size_t v11 = 5;
      goto LABEL_10;
    }
    *(unsigned char *)(v8 + 4) = 44;
    *(_DWORD *)uint64_t v8 = 1701736302;
    uint64_t v56 = *((void *)v7 + 4) + 5;
  }
  else
  {
    if (v9 <= 6)
    {
      uint64_t v10 = "record,";
      size_t v11 = 7;
LABEL_10:
      llvm::raw_ostream::write(v7, v10, v11);
      goto LABEL_11;
    }
    *(_DWORD *)(v8 + 3) = 744780399;
    *(_DWORD *)uint64_t v8 = 1868785010;
    uint64_t v56 = *((void *)v7 + 4) + 7;
  }
  *((void *)v7 + 4) = v56;
LABEL_11:
  if (v69 >= 0) {
    size_t v12 = v69 & 0x7F;
  }
  else {
    size_t v12 = (size_t)v68[1];
  }
  if (v12)
  {
    if (v69 >= 0) {
      int v13 = (const char *)v68;
    }
    else {
      int v13 = (const char *)v68[0];
    }
    int v14 = llvm::raw_ostream::write(*(llvm::raw_ostream **)a1, v13, v12);
    size_t v15 = (unsigned char *)*((void *)v14 + 4);
    if (*((unsigned char **)v14 + 3) == v15)
    {
      llvm::raw_ostream::write(v14, ",", 1uLL);
    }
    else
    {
      unsigned char *v15 = 44;
      ++*((void *)v14 + 4);
    }
  }
  uint64_t v16 = *(llvm::raw_ostream **)a1;
  uint64_t v17 = *(void *)(*(void *)a1 + 32);
  if ((unint64_t)(*(void *)(*(void *)a1 + 24) - v17) > 5)
  {
    *(_WORD *)(v17 + 4) = 15724;
    *(_DWORD *)uint64_t v17 = 1700946284;
    *((void *)v16 + 4) += 6;
  }
  else
  {
    llvm::raw_ostream::write(v16, "label=", 6uLL);
  }
  if (*(unsigned char *)(a1 + 16))
  {
    uint64_t v22 = *(void *)(a2 + 32);
    uint64_t v21 = *(void *)(a2 + 40);
    if (v22 == v21)
    {
      unsigned int v23 = 0;
      BOOL v24 = 0;
    }
    else
    {
      int v25 = 0;
      uint64_t v26 = v22 + 8;
      do
      {
        unsigned int v23 = v25 + 1;
        BOOL v24 = v26 != v21;
        if (v26 == v21) {
          break;
        }
        v26 += 8;
        BOOL v27 = v25++ == 63;
      }
      while (!v27);
    }
    if (v23 <= 1) {
      int v28 = 1;
    }
    else {
      int v28 = v23;
    }
    uint64_t v29 = *(llvm::raw_ostream **)a1;
    int v30 = *(void **)(*(void *)a1 + 32);
    if (*(void *)(*(void *)a1 + 24) - (void)v30 > 0x30uLL)
    {
      qmemcpy(v30, "<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\"", 49);
      long long v31 = (void *)(*((void *)v29 + 4) + 49);
      *((void *)v29 + 4) = v31;
    }
    else
    {
      llvm::raw_ostream::write(*(llvm::raw_ostream **)a1, "<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\"", 0x31uLL);
      long long v31 = (void *)*((void *)v29 + 4);
    }
    unint64_t v32 = (v28 + v24);
    if (*((void *)v29 + 3) - (void)v31 > 0x2EuLL)
    {
      qmemcpy(v31, " cellpadding=\"0\"><tr><td align=\"text\" colspan=\"", 47);
      *((void *)v29 + 4) += 47;
    }
    else
    {
      llvm::raw_ostream::write(v29, " cellpadding=\"0\"><tr><td align=\"text\" colspan=\"", 0x2FuLL);
    }
    sub_1CD098D14(v29, v32, 0, 0, 0);
    int v33 = (_WORD *)*((void *)v29 + 4);
    if (*((void *)v29 + 3) - (void)v33 <= 1uLL)
    {
      uint64_t v20 = "\">";
      unsigned __int8 v18 = v29;
      goto LABEL_40;
    }
    *int v33 = 15906;
    *((void *)v29 + 4) += 2;
  }
  else
  {
    unsigned __int8 v18 = *(llvm::raw_ostream **)a1;
    uint64_t v19 = *(_WORD **)(*(void *)a1 + 32);
    if (*(void *)(*(void *)a1 + 24) - (void)v19 <= 1uLL)
    {
      uint64_t v20 = "\"{";
LABEL_40:
      llvm::raw_ostream::write(v18, v20, 2uLL);
      goto LABEL_41;
    }
    *uint64_t v19 = 31522;
    *((void *)v18 + 4) += 2;
  }
LABEL_41:
  long long v34 = *(llvm::raw_ostream **)a1;
  if (*(unsigned char *)(a1 + 16))
  {
    if (*(unsigned char *)(a1 + 17)) {
      llvm::DOTGraphTraits<llvm::DataDependenceGraph const*>::getSimpleNodeLabel(a2, (uint64_t)&__p);
    }
    else {
      llvm::DOTGraphTraits<llvm::DataDependenceGraph const*>::getVerboseNodeLabel(a2, **(void **)(a1 + 8), (uint64_t)&__p);
    }
    if (v59 >= 0) {
      p_p = (const char *)&__p;
    }
    else {
      p_p = (const char *)__p;
    }
    if (v59 >= 0) {
      size_t v39 = HIBYTE(v59) & 0x7F;
    }
    else {
      size_t v39 = v58;
    }
    llvm::raw_ostream::write(v34, p_p, v39);
    uint64_t v40 = *((void *)v34 + 4);
    if ((unint64_t)(*((void *)v34 + 3) - v40) > 4)
    {
      *(unsigned char *)(v40 + 4) = 62;
      *(_DWORD *)uint64_t v40 = 1685335868;
      *((void *)v34 + 4) += 5;
    }
    else
    {
      llvm::raw_ostream::write(v34, "</td>", 5uLL);
    }
    if (SHIBYTE(v59) < 0)
    {
      uint64_t v37 = __p;
      goto LABEL_68;
    }
  }
  else
  {
    if (*(unsigned char *)(a1 + 17)) {
      llvm::DOTGraphTraits<llvm::DataDependenceGraph const*>::getSimpleNodeLabel(a2, (uint64_t)v66);
    }
    else {
      llvm::DOTGraphTraits<llvm::DataDependenceGraph const*>::getVerboseNodeLabel(a2, **(void **)(a1 + 8), (uint64_t)v66);
    }
    llvm::DOT::EscapeString((char *)v66, (uint64_t)&__p);
    if (v59 >= 0) {
      BOOL v35 = (const char *)&__p;
    }
    else {
      BOOL v35 = (const char *)__p;
    }
    if (v59 >= 0) {
      size_t v36 = HIBYTE(v59) & 0x7F;
    }
    else {
      size_t v36 = v58;
    }
    llvm::raw_ostream::write(v34, v35, v36);
    if (SHIBYTE(v59) < 0) {
      operator delete(__p);
    }
    if (SHIBYTE(v67) < 0)
    {
      uint64_t v37 = v66[0];
LABEL_68:
      operator delete(v37);
    }
  }
  v66[0] = 0;
  v66[1] = 0;
  uint64_t v67 = 0;
  LODWORD(v58) = 0;
  char v62 = 0;
  uint64_t v63 = 0;
  unint64_t v65 = v66;
  int v64 = 0;
  std::string __p = &unk_1F2646F30;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  if (*(unsigned char *)(a1 + 16)
    && (llvm::raw_ostream::write((llvm::raw_ostream *)&__p, "</tr><tr>", 9uLL), *(unsigned char *)(a1 + 16)))
  {
    uint64_t v41 = *(llvm::raw_ostream **)a1;
    unint64_t v42 = *(void **)(*(void *)a1 + 32);
    if (*(void *)(*(void *)a1 + 24) - (void)v42 <= 0xDuLL)
    {
      unint64_t v43 = "</tr></table>>";
      size_t v44 = 14;
LABEL_75:
      llvm::raw_ostream::write(v41, v43, v44);
      goto LABEL_76;
    }
    qmemcpy(v42, "</tr></table>>", 14);
    uint64_t v55 = *((void *)v41 + 4) + 14;
  }
  else
  {
    uint64_t v41 = *(llvm::raw_ostream **)a1;
    uint64_t v45 = *(_WORD **)(*(void *)a1 + 32);
    if (*(void *)(*(void *)a1 + 24) - (void)v45 <= 1uLL)
    {
      unint64_t v43 = "}\"";
      size_t v44 = 2;
      goto LABEL_75;
    }
    *uint64_t v45 = 8829;
    uint64_t v55 = *((void *)v41 + 4) + 2;
  }
  *((void *)v41 + 4) = v55;
LABEL_76:
  uint64_t v46 = *(llvm::raw_ostream **)a1;
  uint64_t v47 = *(void *)(*(void *)a1 + 32);
  if ((unint64_t)(*(void *)(*(void *)a1 + 24) - v47) > 2)
  {
    *(unsigned char *)(v47 + 2) = 10;
    *(_WORD *)uint64_t v47 = 15197;
    *((void *)v46 + 4) += 3;
  }
  else
  {
    llvm::raw_ostream::write(v46, "];\n", 3uLL);
  }
  uint64_t v48 = *(uint64_t **)(a2 + 32);
  uint64_t v49 = *(uint64_t **)(a2 + 40);
  if (v48 != v49)
  {
    uint64_t v50 = 0;
    do
    {
      unint64_t v51 = *(const llvm::DDGNode **)v48[v50];
      if ((!*(unsigned char *)(a1 + 17) || *((_DWORD *)v51 + 14) != 4)
        && !llvm::DataDependenceGraph::getPiBlock(**(llvm::DataDependenceGraph ***)(a1 + 8), v51))
      {
        sub_1CD476B30(a1, a2, &v48[v50], sub_1CD476BCC);
      }
      uint64_t v52 = v50 * 8 + 8;
      if (&v48[v50 + 1] == v49) {
        break;
      }
      BOOL v27 = (v50 * 8) == 504;
      ++v50;
    }
    while (!v27);
    uint64_t v48 = (uint64_t *)((char *)v48 + v52);
  }
  if (v48 != v49)
  {
    uint64_t v53 = v48;
    do
    {
      uint64_t v54 = *(const llvm::DDGNode **)*v48;
      if ((!*(unsigned char *)(a1 + 17) || *((_DWORD *)v54 + 14) != 4)
        && !llvm::DataDependenceGraph::getPiBlock(**(llvm::DataDependenceGraph ***)(a1 + 8), v54))
      {
        sub_1CD476B30(a1, a2, v53, sub_1CD476BCC);
      }
      ++v48;
      ++v53;
    }
    while (v48 != v49);
  }
  std::string __p = &unk_1F2646B98;
  if (v64 == 1 && v59) {
    MEMORY[0x1D25D9CB0](v59, 0x1000C8077774924);
  }
  if (SHIBYTE(v67) < 0) {
    operator delete(v66[0]);
  }
  if (v69 < 0) {
    operator delete(v68[0]);
  }
}

char **sub_1CBFCC82C(char **a1)
{
  int v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 8 * v3;
    uint64_t v5 = v2 - 8;
    do
    {
      uint64_t v6 = *(void *)&v5[v4];
      *(void *)&v5[v4] = 0;
      if (v6) {
        (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
      }
      v4 -= 8;
    }
    while (v4);
    int v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

uint64_t sub_1CBFCC8B8()
{
  char v2 = 0;
  uint64_t v5 = &v2;
  int v4 = 1;
  int v1 = 1;
  v3.n128_u64[0] = (unint64_t)"simple ddg dot graph";
  v3.n128_u64[1] = 20;
  sub_1CD462280((llvm::cl::Option *)&unk_1EBCC5128, "dot-ddg-only", (unsigned char **)&v5, &v4, &v1, &v3);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCC5128, &dword_1CB82C000);
  uint64_t v5 = "ddg";
  int v4 = 1;
  v3.n128_u64[0] = (unint64_t)"The prefix used for the DDG dot file names.";
  v3.n128_u64[1] = 43;
  sub_1CD476BD4(&v5, &v4, &v3);
  return __cxa_atexit((void (*)(void *))sub_1CD41C8DC, &qword_1EBCC51E8, &dword_1CB82C000);
}

BOOL llvm::ConstraintSystem::eliminateUsingFM(llvm::ConstraintSystem *this)
{
  v62[40] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(unsigned int *)(*(void *)this + 8);
  uint64_t v60 = (char *)v62;
  uint64_t v61 = 0x400000000;
  unint64_t v3 = *((unsigned int *)this + 2);
  if (!v3)
  {
    LODWORD(v8) = 1;
LABEL_89:
    sub_1CD477A94((uint64_t)this, (uint64_t)&v60);
    *((_DWORD *)this + 84) = v8;
    LOBYTE(v5) = 1;
    goto LABEL_87;
  }
  unint64_t v4 = 0;
  BOOL v5 = 0;
  uint64_t v6 = 8 * v2;
  uint64_t v7 = 1;
  uint64_t v8 = 1;
  int v48 = v2;
  unint64_t v47 = *((unsigned int *)this + 2);
  while (1)
  {
    unint64_t v9 = (void **)(*(void *)this + 80 * v4);
    if (!(*v9)[1])
    {
      uint64_t v43 = v7;
      long long v57 = v59;
      v59[0] = **v9;
      uint64_t v58 = 0x800000001;
      if (v2 >= 3)
      {
        unsigned int v44 = 1;
        uint64_t v45 = 16;
        do
        {
          if (v44 >= HIDWORD(v58)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v57 + v44) = *(void *)(*(void *)(*(void *)this + 80 * v4) + v45);
          unsigned int v44 = v58 + 1;
          LODWORD(v58) = v58 + 1;
          v45 += 8;
        }
        while (v6 != v45);
      }
      sub_1CD477248((uint64_t)&v60, (unint64_t)&v57);
      if (v57 != v59) {
        free(v57);
      }
      unint64_t v42 = v4 + 1;
      uint64_t v7 = v43;
      goto LABEL_73;
    }
    uint64_t v10 = v7;
    BOOL v11 = __OFSUB__(v4 + 1, v3);
    if (v4 + 1 < v3) {
      break;
    }
LABEL_72:
    unint64_t v42 = v4 + 1;
LABEL_73:
    ++v7;
    unint64_t v4 = v42;
    BOOL v5 = v42 >= v3;
    if (v42 == v3) {
      goto LABEL_89;
    }
  }
  while (1)
  {
    uint64_t v12 = *(void *)(*(void *)(*(void *)this + 80 * v10) + 8);
    if (v12)
    {
      uint64_t v13 = *(void *)(*(void *)(*(void *)this + 80 * v4) + 8);
      if ((v13 & v12) < 0 == v11)
      {
        BOOL v14 = v12 < 1 || v13 <= 0;
        if (v14) {
          break;
        }
      }
    }
LABEL_11:
    BOOL v11 = __OFSUB__(v3, ++v10);
    if (v3 == v10) {
      goto LABEL_72;
    }
  }
  BOOL v50 = v5;
  uint64_t v49 = v7;
  long long v57 = v59;
  uint64_t v58 = 0x800000000;
  if (!v2)
  {
LABEL_14:
    sub_1CD477248((uint64_t)&v60, (unint64_t)&v57);
    unsigned int v15 = v61;
    if (v57 != v59) {
      free(v57);
    }
    BOOL v14 = v15 > 0x1F4;
    unint64_t v3 = v47;
    LODWORD(v2) = v48;
    uint64_t v7 = v49;
    BOOL v5 = v50;
    if (v14) {
      goto LABEL_87;
    }
    goto LABEL_11;
  }
  uint64_t v16 = 0;
  BOOL v17 = v12 < 0;
  if (v12 >= 0) {
    unsigned int v18 = v10;
  }
  else {
    unsigned int v18 = v4;
  }
  if (v17) {
    unsigned int v19 = v10;
  }
  else {
    unsigned int v19 = v4;
  }
  unsigned int v20 = v18;
  unsigned int v21 = v19;
  while (2)
  {
    if (v16 == 8)
    {
LABEL_69:
      v16 += 8;
      if (v6 == v16) {
        goto LABEL_14;
      }
      continue;
    }
    break;
  }
  uint64_t v22 = *(void *)(*(void *)this + 80 * v20);
  uint64_t v23 = *(void *)(v22 + v16);
  uint64_t v24 = *(void *)(*(void *)this + 80 * v21);
  uint64_t v25 = *((unsigned int *)this + 84);
  uint64_t v26 = *(void *)(v24 + 8) / v25;
  uint64_t v27 = -v26;
  if (v23 >= 0) {
    unint64_t v28 = *(void *)(v22 + v16);
  }
  else {
    unint64_t v28 = -v23;
  }
  if (v26 >= 0) {
    unint64_t v29 = *(void *)(v24 + 8) / v25;
  }
  else {
    unint64_t v29 = -v26;
  }
  uint64_t v30 = v23 ^ v27;
  if ((v23 ^ v27) >= 0) {
    unint64_t v31 = v29 * v28;
  }
  else {
    unint64_t v31 = -(uint64_t)(v29 * v28);
  }
  if (!v23 || !v26 || (v30 < 0 ? (unint64_t v32 = 0x8000000000000000) : (unint64_t v32 = 0x7FFFFFFFFFFFFFFFLL), v28 <= v32 / v29))
  {
    uint64_t v33 = *(void *)(v24 + v16);
    uint64_t v34 = *(void *)(v22 + 8);
    uint64_t v35 = v34 / v25;
    if (v33 >= 0) {
      unint64_t v36 = *(void *)(v24 + v16);
    }
    else {
      unint64_t v36 = -v33;
    }
    if (v35 >= 0) {
      unint64_t v37 = v34 / v25;
    }
    else {
      unint64_t v37 = -v35;
    }
    unint64_t v38 = v37 * v36;
    if ((v35 ^ v33) < 0) {
      unint64_t v38 = -(uint64_t)v38;
    }
    if (!v33
      || !v35
      || ((v35 ^ v33) < 0 ? (unint64_t v39 = 0x8000000000000000) : (unint64_t v39 = 0x7FFFFFFFFFFFFFFFLL), v36 <= v39 / v37))
    {
      if (!__OFADD__(v31, v38))
      {
        if (v58 >= (unint64_t)HIDWORD(v58)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v57 + v58) = v31 + v38;
        LODWORD(v58) = v58 + 1;
        uint64_t v40 = *((unsigned int *)v57 + 2 * v58 - 2);
        unsigned int v54 = 32;
        uint64_t v53 = v40;
        unsigned int v52 = 32;
        uint64_t v51 = v8;
        llvm::APIntOps::GreatestCommonDivisor((uint64_t)&v53, (uint64_t)&v51, (uint64_t)&v55);
        uint64_t v41 = (unsigned int **)&v55;
        if (v56 >= 0x41) {
          uint64_t v41 = v55;
        }
        uint64_t v8 = *(unsigned int *)v41;
        if (v56 >= 0x41 && v55) {
          MEMORY[0x1D25D9CB0]();
        }
        if (v52 >= 0x41 && v51) {
          MEMORY[0x1D25D9CB0](v51, 0x1000C8000313F17);
        }
        if (v54 >= 0x41 && v53) {
          MEMORY[0x1D25D9CB0](v53, 0x1000C8000313F17);
        }
        goto LABEL_69;
      }
    }
  }
  if (v57 != v59) {
    free(v57);
  }
  LOBYTE(v5) = v50;
LABEL_87:
  sub_1CD4779B0(&v60);
  return v5;
}

char **llvm::ConstraintSystem::dump(char **result, const void **a2)
{
  unsigned char v24[48] = *MEMORY[0x1E4F143B8];
  int v2 = *((_DWORD *)result + 2);
  if (v2)
  {
    unint64_t v3 = *result;
    uint64_t v17 = (uint64_t)&(*result)[80 * v2];
    do
    {
      uint64_t v22 = (char *)v24;
      uint64_t v23 = 0x1000000000;
      uint64_t v4 = *((unsigned int *)v3 + 2);
      if (v4 >= 2)
      {
        uint64_t v5 = 8 * v4;
        uint64_t v6 = a2;
        uint64_t v7 = 8;
        do
        {
          uint64_t v8 = *(void *)v3;
          if (*(void *)(*(void *)v3 + v7))
          {
            std::string __p = 0;
            long long v20 = 0uLL;
            uint64_t v9 = *(void *)(v8 + v7);
            if (v9 != 1)
            {
              std::to_string(&v18, v9);
              uint64_t v10 = std::string::append(&v18, " * ");
              BOOL v11 = (void *)v10->__r_.__value_.__r.__words[0];
              v21[0] = v10->__r_.__value_.__l.__size_;
              *(void *)((char *)v21 + 7) = *(std::string::size_type *)((char *)&v10->__r_.__value_.__r.__words[1] + 7);
              char v12 = HIBYTE(v10->__r_.__value_.__r.__words[2]);
              v10->__r_.__value_.__l.__size_ = 0;
              v10->__r_.__value_.__r.__words[2] = 0;
              v10->__r_.__value_.__r.__words[0] = 0;
              if (SHIBYTE(v20) < 0) {
                operator delete(__p);
              }
              std::string __p = v11;
              *(void *)&long long v20 = v21[0];
              *(void *)((char *)&v20 + 7) = *(void *)((char *)v21 + 7);
              HIBYTE(v20) = v12;
              if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v18.__r_.__value_.__l.__data_);
              }
            }
            sub_1CB906918((const void **)&__p, v6, (uint64_t)&v18);
            unint64_t v13 = sub_1CBFCD38C((uint64_t)&v22, (unint64_t)&v18, 1);
            BOOL v14 = &v22[24 * v23];
            long long v15 = *(_OWORD *)v13;
            *((void *)v14 + 2) = *(void *)(v13 + 16);
            *(_OWORD *)BOOL v14 = v15;
            *(void *)(v13 + 8) = 0;
            *(void *)(v13 + 16) = 0;
            *(void *)unint64_t v13 = 0;
            LODWORD(v23) = v23 + 1;
            if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v18.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v20) < 0) {
              operator delete(__p);
            }
          }
          v7 += 8;
          v6 += 3;
        }
        while (v5 != v7);
      }
      double result = sub_1CBFCD310(&v22);
      v3 += 80;
    }
    while (v3 != (char *)v17);
  }
  return result;
}

char **llvm::ConstraintSystem::dump(char **this)
{
  v15[48] = *MEMORY[0x1E4F143B8];
  int v2 = (const void **)v15;
  unint64_t v13 = (const void **)v15;
  uint64_t v14 = 0x1000000000;
  if (*(_DWORD *)&(*this)[80 * *((unsigned int *)this + 2) - 72] >= 2u)
  {
    unsigned int v3 = 1;
    do
    {
      std::to_string(&v10, v3);
      uint64_t v4 = std::string::insert(&v10, 0, "x");
      std::string::size_type v5 = v4->__r_.__value_.__r.__words[2];
      *(_OWORD *)std::string __p = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
      std::string::size_type v12 = v5;
      v4->__r_.__value_.__l.__size_ = 0;
      v4->__r_.__value_.__r.__words[2] = 0;
      v4->__r_.__value_.__r.__words[0] = 0;
      unint64_t v6 = sub_1CBFCD38C((uint64_t)&v13, (unint64_t)__p, 1);
      uint64_t v7 = (char *)&v13[3 * v14];
      long long v8 = *(_OWORD *)v6;
      *((void *)v7 + 2) = *(void *)(v6 + 16);
      *(_OWORD *)uint64_t v7 = v8;
      *(void *)(v6 + 8) = 0;
      *(void *)(v6 + 16) = 0;
      *(void *)unint64_t v6 = 0;
      LODWORD(v14) = v14 + 1;
      if (SHIBYTE(v12) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v10.__r_.__value_.__l.__data_);
      }
      ++v3;
    }
    while (*(_DWORD *)&(*this)[80 * *((unsigned int *)this + 2) - 72] > v3);
    int v2 = v13;
  }
  llvm::ConstraintSystem::dump(this, v2);
  return sub_1CBFCD310((char **)&v13);
}

BOOL sub_1CBFCD1A8(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  std::string::size_type v5 = &a2[a3];
  uint64_t v6 = 8 * a3;
  for (uint64_t i = 8; ; i += 8)
  {
    uint64_t v8 = i;
    if (v6 == i) {
      break;
    }
    if (a2[(unint64_t)i / 8])
    {
      if (a3)
      {
        uint64_t v10 = 8 * a3;
        BOOL v11 = a2;
        do
        {
          uint64_t v12 = *v11;
          if (*v11 < 0) {
            uint64_t v12 = -v12;
          }
          unsigned int v23 = 32;
          uint64_t v22 = v12;
          uint64_t v13 = *(unsigned int *)(a1 + 336);
          unsigned int v21 = 32;
          uint64_t v20 = v13;
          llvm::APIntOps::GreatestCommonDivisor((uint64_t)&v22, (uint64_t)&v20, (uint64_t)&v24);
          uint64_t v14 = v24;
          BOOL v15 = v25 >= 0x41;
          if (v25 >= 0x41) {
            uint64_t v16 = v24;
          }
          else {
            uint64_t v16 = &v24;
          }
          *(_DWORD *)(a1 + 336) = *v16;
          if (v15 && v14 != 0) {
            MEMORY[0x1D25D9CB0]();
          }
          if (v21 >= 0x41 && v20) {
            MEMORY[0x1D25D9CB0](v20, 0x1000C8000313F17);
          }
          if (v23 >= 0x41 && v22) {
            MEMORY[0x1D25D9CB0](v22, 0x1000C8000313F17);
          }
          ++v11;
          v10 -= 8;
        }
        while (v10);
      }
      uint64_t v24 = a2;
      unsigned int v19 = v5;
      sub_1CD4777DC(a1, (unsigned char **)&v24, (unsigned char **)&v19);
      return v6 != v8;
    }
  }
  return v6 != v8;
}

char **sub_1CBFCD310(char **a1)
{
  int v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v5 = 24 * v3;
    do
    {
      if (v2[v5 - 1] < 0) {
        operator delete(*(void **)&v2[v5 - 24]);
      }
      v5 -= 24;
    }
    while (v5);
    int v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

unint64_t sub_1CBFCD38C(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(a1 + 8);
  if (v3 + a3 > (unint64_t)*(unsigned int *)(a1 + 12))
  {
    unint64_t v5 = *(void *)a1 + 24 * v3;
    if (*(void *)a1 > a2 || v5 <= a2) {
      sub_1CD477D68();
    }
    sub_1CD477D68();
  }
  return a2;
}

void sub_1CBFCD3F8(long long **a1, uint64_t a2)
{
  uint64_t v2 = *((unsigned int *)a1 + 2);
  if (v2)
  {
    uint64_t v3 = *a1;
    uint64_t v4 = 24 * v2;
    do
    {
      long long v5 = *v3;
      *(void *)(a2 + 16) = *((void *)v3 + 2);
      *(_OWORD *)a2 = v5;
      a2 += 24;
      *((void *)v3 + sub_1CD456CB4((void *)this + 1) = 0;
      *((void *)v3 + 2) = 0;
      *(void *)uint64_t v3 = 0;
      uint64_t v3 = (long long *)((char *)v3 + 24);
      v4 -= 24;
    }
    while (v4);
    uint64_t v6 = *((unsigned int *)a1 + 2);
    if (v6)
    {
      uint64_t v7 = *a1;
      uint64_t v8 = 24 * v6;
      do
      {
        if (*((char *)v7 + v8 - 1) < 0)
        {
          uint64_t v9 = v8;
          uint64_t v10 = v7;
          operator delete(*(void **)((char *)v7 + v8 - 24));
          uint64_t v8 = v9;
          uint64_t v7 = v10;
        }
        v8 -= 24;
      }
      while (v8);
    }
  }
}

void llvm::findArrayDimensions(llvm::SCEVDivision *a1, uint64_t a2, uint64_t a3, const llvm::SCEV ***a4)
{
  _OWORD v61[2] = *MEMORY[0x1E4F143B8];
  if (a4)
  {
    uint64_t v5 = *(unsigned int *)(a2 + 8);
    if (v5)
    {
      uint64_t v8 = *(uint64_t **)a2;
      uint64_t v9 = *(void *)a2 + 8 * v5;
      while (1)
      {
        uint64_t v10 = *v8;
        LOBYTE(v59) = 0;
        BOOL v50 = (llvm::SCEV *)&v59;
        uint64_t v51 = v53;
        uint64_t v52 = 0x800000000;
        unsigned int v54 = v58;
        uint64_t v55 = v58;
        uint64_t v56 = 8;
        int v57 = 0;
        sub_1CBFCED8C((uint64_t)&v50, v10);
        unsigned int v11 = v52;
        while (v11)
        {
          if (*(unsigned char *)v50) {
            break;
          }
          uint64_t v12 = *((void *)v51 + --v11);
          LODWORD(v52) = v11;
          switch(*(_WORD *)(v12 + 24))
          {
            case 1:
            case 2:
            case 3:
            case 0xD:
              std::string v18 = (uint64_t *)(v12 + 32);
              goto LABEL_16;
            case 4:
            case 5:
            case 7:
            case 8:
            case 9:
            case 0xA:
            case 0xB:
            case 0xC:
              uint64_t v13 = *(void *)(v12 + 40);
              if (v13)
              {
                uint64_t v14 = *(uint64_t **)(v12 + 32);
                uint64_t v15 = 8 * v13 - 8;
                do
                {
                  uint64_t v16 = *v14++;
                  sub_1CBFCED8C((uint64_t)&v50, v16);
                  if (*(unsigned char *)v50) {
                    BOOL v17 = 1;
                  }
                  else {
                    BOOL v17 = v15 == 0;
                  }
                  v15 -= 8;
                }
                while (!v17);
              }
              goto LABEL_17;
            case 6:
              sub_1CBFCED8C((uint64_t)&v50, *(void *)(v12 + 32));
              std::string v18 = (uint64_t *)(v12 + 40);
LABEL_16:
              sub_1CBFCED8C((uint64_t)&v50, *v18);
LABEL_17:
              unsigned int v11 = v52;
              break;
            default:
              break;
          }
        }
        if (v55 != v54) {
          free(v55);
        }
        if (v51 != v53) {
          free(v51);
        }
        if ((_BYTE)v59) {
          break;
        }
        if (++v8 == (uint64_t *)v9) {
          return;
        }
      }
      size_t v19 = *(unsigned int *)(a2 + 8);
      if (v19 >= 2)
      {
        qsort(*(void **)a2, v19, 8uLL, (int (__cdecl *)(const void *, const void *))sub_1CD4783D8);
        LODWORD(v19) = *(_DWORD *)(a2 + 8);
      }
      uint64_t v20 = *(uint64_t **)a2;
      uint64_t v21 = *(void *)a2 + 8 * v19;
      uint64_t v22 = *(uint64_t **)a2;
      if (v19)
      {
        unint64_t v23 = 0;
        while (8 * v19 - 8 != v23)
        {
          uint64_t v25 = v20[v23 / 8];
          uint64_t v24 = v20[v23 / 8 + 1];
          v23 += 8;
          if (v25 == v24)
          {
            uint64_t v22 = &v20[v23 / 8 - 1];
            goto LABEL_35;
          }
        }
      }
      else
      {
LABEL_35:
        if (v22 != (uint64_t *)v21)
        {
          uint64_t v26 = v22 + 2;
          if (v22 + 2 != (uint64_t *)v21)
          {
            uint64_t v27 = *v22;
            do
            {
              uint64_t v28 = v27;
              uint64_t v27 = *v26;
              if (v28 != *v26)
              {
                v22[1] = v27;
                ++v22;
              }
              ++v26;
            }
            while (v26 != (uint64_t *)v21);
            uint64_t v20 = *(uint64_t **)a2;
          }
          uint64_t v21 = (uint64_t)(v22 + 1);
        }
      }
      unint64_t v29 = (unint64_t)(v21 - (void)v20) >> 3;
      *(_DWORD *)(a2 + 8) = v29;
      unint64_t v30 = 126 - 2 * __clz(v29);
      if (v29) {
        uint64_t v31 = v30;
      }
      else {
        uint64_t v31 = 0;
      }
      sub_1CBFD00A8((uint64_t)v20, &v20[v29], v31, 1);
      uint64_t v33 = *(unsigned int *)(a2 + 8);
      if (v33)
      {
        uint64_t v34 = *(llvm::ScalarEvolution ***)a2;
        uint64_t v35 = 8 * v33;
        do
        {
          BOOL v50 = 0;
          llvm::SCEVDivision::divide(a1, *v34, a4, &v50, &v59, v32);
          unint64_t v36 = v50;
          if (!llvm::SCEV::isZero(v50)) {
            *uint64_t v34 = v36;
          }
          ++v34;
          v35 -= 8;
        }
        while (v35);
        unint64_t v39 = *(uint64_t **)a2;
        uint64_t v40 = *(unsigned int *)(a2 + 8);
        BOOL v50 = (llvm::SCEV *)&v52;
        uint64_t v51 = (void *)0x400000000;
        if (v40)
        {
          uint64_t v41 = &v39[v40];
          do
          {
            uint64_t MulExpr = *v39;
            if (*(_WORD *)(*v39 + 24))
            {
              if (*(_WORD *)(*v39 + 24) != 5) {
                goto LABEL_66;
              }
              uint64_t v59 = (llvm::SCEV *)v61;
              uint64_t v60 = 0x200000000;
              uint64_t v43 = *(void *)(MulExpr + 40);
              if (v43)
              {
                unsigned int v44 = 0;
                uint64_t v45 = *(void *)(MulExpr + 32);
                uint64_t v46 = 8 * v43;
                do
                {
                  if (*(_WORD *)(*(void *)v45 + 24))
                  {
                    if (v44 >= HIDWORD(v60)) {
                      llvm::SmallVectorBase<unsigned int>::grow_pod();
                    }
                    *((void *)v59 + v44) = *(void *)v45;
                    unsigned int v44 = v60 + 1;
                    LODWORD(v60) = v60 + 1;
                  }
                  v45 += 8;
                  v46 -= 8;
                }
                while (v46);
              }
              uint64_t MulExpr = llvm::ScalarEvolution::getMulExpr((uint64_t)a1, (uint64_t)&v59, 0, 0);
              if (v59 != (llvm::SCEV *)v61) {
                free(v59);
              }
              if (MulExpr)
              {
LABEL_66:
                if (v51 >= (unint64_t)HIDWORD(v51)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                *((void *)v50 + v5sub_1CD456CB4((void *)this + 1) = MulExpr;
                LODWORD(v5sub_1CD456CB4((void *)this + 1) = v51 + 1;
              }
            }
            ++v39;
          }
          while (v39 != v41);
          if (v51)
          {
            uint64_t v47 = a3;
            if (sub_1CBFCDA3C(a1, (uint64_t)&v50, a3, v37, v38, v32))
            {
              unsigned int v48 = *(_DWORD *)(a3 + 8);
              if (v48 >= *(_DWORD *)(a3 + 12)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *(void *)(*(void *)a3 + 8 * v48) = a4;
              ++*(_DWORD *)(a3 + 8);
              goto LABEL_78;
            }
LABEL_77:
            *(_DWORD *)(v47 + 8) = 0;
LABEL_78:
            if (v50 != (llvm::SCEV *)&v52) {
              free(v50);
            }
            return;
          }
        }
      }
      else
      {
        BOOL v50 = (llvm::SCEV *)&v52;
        uint64_t v51 = (void *)0x400000000;
      }
      uint64_t v47 = a3;
      goto LABEL_77;
    }
  }
}

uint64_t sub_1CBFCDA3C(llvm::SCEVDivision *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const llvm::SCEV **a6)
{
  v32[2] = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(unsigned int *)(a2 + 8);
  uint64_t v9 = *(llvm::ScalarEvolution ***)a2;
  uint64_t MulExpr = *(void *)(*(void *)a2 + 8 * ((int)v8 - 1));
  if (v8 == 1)
  {
    if (*(_WORD *)(MulExpr + 24) == 5 && MulExpr != 0)
    {
      unint64_t v30 = v32;
      uint64_t v31 = 0x200000000;
      uint64_t v21 = *(void *)(MulExpr + 40);
      if (v21)
      {
        unsigned int v22 = 0;
        uint64_t v23 = *(void *)(MulExpr + 32);
        uint64_t v24 = 8 * v21;
        do
        {
          if (*(_WORD *)(*(void *)v23 + 24))
          {
            if (v22 >= HIDWORD(v31)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((void *)v30 + v22) = *(void *)v23;
            unsigned int v22 = v31 + 1;
            LODWORD(v3sub_1CD456CB4((void *)this + 1) = v31 + 1;
          }
          v23 += 8;
          v24 -= 8;
        }
        while (v24);
      }
      uint64_t MulExpr = llvm::ScalarEvolution::getMulExpr((uint64_t)a1, (uint64_t)&v30, 0, 0);
      if (v30 != v32) {
        free(v30);
      }
    }
    goto LABEL_29;
  }
  if (v8)
  {
    uint64_t v12 = 8 * v8;
    while (1)
    {
      unint64_t v29 = 0;
      unint64_t v30 = 0;
      llvm::SCEVDivision::divide(a1, *v9, (const llvm::SCEV ***)MulExpr, (llvm::ScalarEvolution **)&v30, &v29, a6);
      uint64_t result = llvm::SCEV::isZero(v29);
      if (!result) {
        return result;
      }
      *v9++ = (llvm::ScalarEvolution *)v30;
      v12 -= 8;
      if (!v12)
      {
        uint64_t v9 = *(llvm::ScalarEvolution ***)a2;
        uint64_t v14 = *(unsigned int *)(a2 + 8);
        if (!v14) {
          break;
        }
        uint64_t v15 = &v9[v14];
        uint64_t v16 = 8 * v14 - 8;
        BOOL v17 = *(llvm::ScalarEvolution ***)a2;
        std::string v18 = *(llvm::ScalarEvolution ***)a2;
        while (1)
        {
          uint64_t v19 = (uint64_t)*v18++;
          if (!*(_WORD *)(v19 + 24)) {
            break;
          }
          v16 -= 8;
          BOOL v17 = v18;
          if (v18 == v15) {
            goto LABEL_24;
          }
        }
        if (v18 == v15)
        {
          uint64_t v15 = v17;
        }
        else
        {
          uint64_t v27 = 1;
          uint64_t v15 = v17;
          do
          {
            uint64_t v28 = v17[v27];
            if (*((_WORD *)v28 + 12)) {
              *v15++ = v28;
            }
            ++v27;
            v16 -= 8;
          }
          while (v16);
          uint64_t v9 = *(llvm::ScalarEvolution ***)a2;
        }
        goto LABEL_24;
      }
    }
  }
  uint64_t v15 = v9;
LABEL_24:
  unint64_t v25 = (char *)v15 - (char *)v9;
  *(_DWORD *)(a2 + 8) = v25 >> 3;
  if ((v25 & 0x7FFFFFFF8) == 0 || (uint64_t result = sub_1CBFCDA3C(a1, a2, a3), result))
  {
LABEL_29:
    unsigned int v26 = *(_DWORD *)(a3 + 8);
    if (v26 >= *(_DWORD *)(a3 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)a3 + 8 * v26) = MulExpr;
    ++*(_DWORD *)(a3 + 8);
    return 1;
  }
  return result;
}

void llvm::computeAccessFunctions(llvm::SCEVDivision *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const llvm::SCEV **a6)
{
  int v6 = *(_DWORD *)(a4 + 8);
  if (v6)
  {
    uint64_t v9 = (llvm::ScalarEvolution *)a2;
    if (!a2 || *(_WORD *)(a2 + 24) != 7 || *(void *)(a2 + 40) == 2)
    {
      uint64_t v11 = (v6 - 1);
      if (v6 - 1 >= 0)
      {
        uint64_t v12 = 0;
        do
        {
          uint64_t v21 = 0;
          unsigned int v22 = 0;
          llvm::SCEVDivision::divide(a1, v9, *(const llvm::SCEV ****)(*(void *)a4 + 8 * v11), &v22, &v21, a6);
          uint64_t v9 = v22;
          if (v12)
          {
            unint64_t v13 = *(unsigned int *)(a3 + 8);
            if (v13 >= *(unsigned int *)(a3 + 12)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(*(void *)a3 + 8 * v13) = v21;
            ++*(_DWORD *)(a3 + 8);
          }
          else if (!llvm::SCEV::isZero(v21))
          {
            *(_DWORD *)(a3 + 8) = 0;
            *(_DWORD *)(a4 + 8) = 0;
            return;
          }
          ++v12;
        }
        while (v11-- >= 1);
      }
      unsigned int v15 = *(_DWORD *)(a3 + 8);
      if (v15 >= *(_DWORD *)(a3 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)a3 + 8 * v15) = v9;
      unsigned int v16 = *(_DWORD *)(a3 + 8) + 1;
      *(_DWORD *)(a3 + 8) = v16;
      if (v16)
      {
        BOOL v17 = (void *)(*(void *)a3 + 8 * v16 - 8);
        if (*(void *)a3 < (unint64_t)v17)
        {
          unint64_t v18 = *(void *)a3 + 8;
          do
          {
            uint64_t v19 = *(void *)(v18 - 8);
            *(void *)(v18 - 8) = *v17;
            *v17-- = v19;
            BOOL v20 = v18 >= (unint64_t)v17;
            v18 += 8;
          }
          while (!v20);
        }
      }
    }
  }
}

BOOL llvm::getIndexExpressionsFromGEP(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v5 = *(_DWORD *)(a2 + 20) & 0x7FFFFFF;
  if (v5 < 2) {
    return *(_DWORD *)(a3 + 8) != 0;
  }
  char v9 = 0;
  uint64_t v10 = 0;
  unint64_t v11 = 1;
  while (1)
  {
    unint64_t v12 = *(void *)(a2 - 32 * v5 + 32 * v11);
    uint64_t v13 = *(void *)(a1 + 104);
    unsigned int v14 = *(_DWORD *)(a1 + 120);
    if (!v14) {
      goto LABEL_9;
    }
    unsigned int v15 = ((v12 >> 4) ^ (v12 >> 9)) & (v14 - 1);
    uint64_t v16 = v13 + 48 * v15;
    uint64_t v17 = *(void *)(v16 + 24);
    if (v17 != v12)
    {
      int v18 = 1;
      while (v17 != -4096)
      {
        unsigned int v19 = v15 + v18++;
        unsigned int v15 = v19 & (v14 - 1);
        uint64_t v16 = v13 + 48 * v15;
        uint64_t v17 = *(void *)(v16 + 24);
        if (v17 == v12) {
          goto LABEL_10;
        }
      }
LABEL_9:
      uint64_t v16 = v13 + 48 * v14;
    }
LABEL_10:
    if (v16 == v13 + 48 * v14 || (uint64_t SCEVIter = *(void *)(v16 + 40)) == 0) {
      uint64_t SCEVIter = llvm::ScalarEvolution::createSCEVIter((llvm::ScalarEvolution *)a1, v12);
    }
    if (v11 != 1) {
      break;
    }
    uint64_t v10 = *(void *)(a2 + 64);
    if (*(_WORD *)(SCEVIter + 24)) {
      BOOL v21 = 1;
    }
    else {
      BOOL v21 = SCEVIter == 0;
    }
    if (v21) {
      goto LABEL_20;
    }
    uint64_t v22 = *(void *)(SCEVIter + 32);
    uint64_t v23 = *(unsigned int *)(v22 + 32);
    if (v23 > 0x40)
    {
      int v27 = 0;
      int64_t v28 = (unint64_t)(v23 + 63) >> 6;
      do
      {
        if (v28-- < 1) {
          break;
        }
        unint64_t v30 = *(void *)(*(void *)(v22 + 24) + 8 * v28);
        v27 += __clz(v30);
      }
      while (!v30);
      int v31 = v23 | 0xFFFFFFC0;
      if ((v23 & 0x3F) == 0) {
        int v31 = 0;
      }
      if (v27 + v31 != v23)
      {
LABEL_20:
        unint64_t v24 = *(unsigned int *)(a3 + 8);
        if (v24 >= *(unsigned int *)(a3 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)a3 + 8 * v24) = SCEVIter;
        ++*(_DWORD *)(a3 + 8);
        goto LABEL_29;
      }
    }
    else if (*(void *)(v22 + 24))
    {
      goto LABEL_20;
    }
    char v9 = 1;
LABEL_29:
    ++v11;
    unint64_t v5 = *(_DWORD *)(a2 + 20) & 0x7FFFFFF;
    if (v11 >= v5) {
      return *(_DWORD *)(a3 + 8) != 0;
    }
  }
  if (*(unsigned char *)(v10 + 8) == 17 && v10)
  {
    unint64_t v25 = *(unsigned int *)(a3 + 8);
    if (v25 >= *(unsigned int *)(a3 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)a3 + 8 * v25) = SCEVIter;
    ++*(_DWORD *)(a3 + 8);
    if (((v11 == 2) & v9) == 0)
    {
      unint64_t v26 = *(unsigned int *)(a4 + 8);
      if (v26 >= *(unsigned int *)(a4 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a4 + 4 * v26) = *(_DWORD *)(v10 + 32);
      ++*(_DWORD *)(a4 + 8);
    }
    uint64_t v10 = *(void *)(v10 + 24);
    goto LABEL_29;
  }
  BOOL result = 0;
  *(_DWORD *)(a3 + 8) = 0;
  *(_DWORD *)(a4 + 8) = 0;
  return result;
}

void llvm::initializeDelinearizationPass(uint64_t a1)
{
  uint64_t v1 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC52D8, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CBFCE138;
    v3[1] = &v1;
    uint64_t v2 = v3;
    std::__call_once(&qword_1EBCC52D8, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CBFCE138(uint64_t a1)
{
}

void llvm::createDelinearizationPass(llvm *this)
{
}

uint64_t sub_1CBFCE218(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCC52D0;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F26025D8;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC52D8, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CBFCE138;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCC52D8, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void *llvm::DelinearizationPrinterPass::DelinearizationPrinterPass(void *result, uint64_t a2)
{
  void *result = a2;
  return result;
}

void sub_1CBFCE2D0(llvm::raw_ostream *this, uint64_t ***a2, uint64_t *a3, llvm::ScalarEvolution *a4)
{
  v98[3] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = (void *)*((void *)this + 4);
  if (*((void *)this + 3) - (void)v7 > 0x1BuLL)
  {
    qmemcpy(v7, "Delinearization on function ", 28);
    *((void *)this + 4) += 28;
    uint64_t v8 = this;
  }
  else
  {
    uint64_t v8 = llvm::raw_ostream::write(this, "Delinearization on function ", 0x1CuLL);
  }
  if ((*((unsigned char *)a2 + 23) & 0x10) == 0)
  {
    uint64_t v22 = (_WORD *)*((void *)v8 + 4);
    goto LABEL_16;
  }
  uint64_t v9 = ***a2;
  uint64_t v10 = *(void *)(v9 + 152);
  uint64_t v11 = *(unsigned int *)(v9 + 168);
  if (!v11) {
    goto LABEL_10;
  }
  LODWORD(v12) = (v11 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v13 = (uint64_t ****)(v10 + 16 * v12);
  unsigned int v14 = *v13;
  if (*v13 != a2)
  {
    int v15 = 1;
    while (v14 != (uint64_t ***)-4096)
    {
      int v16 = v12 + v15++;
      uint64_t v12 = v16 & (v11 - 1);
      unsigned int v14 = *(uint64_t ****)(v10 + 16 * v12);
      if (v14 == a2)
      {
        uint64_t v13 = (uint64_t ****)(v10 + 16 * v12);
        goto LABEL_11;
      }
    }
LABEL_10:
    uint64_t v13 = (uint64_t ****)(v10 + 16 * v11);
  }
LABEL_11:
  uint64_t v17 = a3;
  int v18 = (size_t *)v13[1];
  size_t v21 = *v18;
  unsigned int v19 = v18 + 2;
  size_t v20 = v21;
  uint64_t v22 = (_WORD *)*((void *)v8 + 4);
  if (v21 <= *((void *)v8 + 3) - (void)v22)
  {
    if (v20)
    {
      memcpy(v22, v19, v20);
      uint64_t v22 = (_WORD *)(*((void *)v8 + 4) + v20);
      *((void *)v8 + 4) = v22;
    }
  }
  else
  {
    uint64_t v8 = llvm::raw_ostream::write(v8, (const char *)v19, v20);
    uint64_t v22 = (_WORD *)*((void *)v8 + 4);
  }
  a3 = v17;
LABEL_16:
  if (*((void *)v8 + 3) - (void)v22 > 1uLL)
  {
    *uint64_t v22 = 2618;
    *((void *)v8 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(v8, ":\n", 2uLL);
  }
  uint64_t v23 = a2 + 9;
  for (uint64_t i = a2[10]; ; uint64_t i = (uint64_t **)i[1])
  {
    if (i == (uint64_t **)v23) {
      return;
    }
    unint64_t v25 = i - 3;
    if (!i) {
      unint64_t v25 = 0;
    }
    unint64_t v26 = v25[6];
    if (v26 != (uint64_t *)(v25 + 5)) {
      break;
    }
  }
  while (1)
  {
    if (v26) {
      int v27 = v26 - 3;
    }
    else {
      int v27 = 0;
    }
    if (*((unsigned __int8 *)v27 + 16) - 60 > 2) {
      goto LABEL_132;
    }
    int v28 = *((_DWORD *)a3 + 4);
    if (!v28) {
      goto LABEL_132;
    }
    uint64_t v29 = v27[5];
    uint64_t v30 = *a3;
    unsigned int v31 = v28 - 1;
    uint64_t v32 = ((v29 >> 4) ^ (v29 >> 9)) & (v28 - 1);
    uint64_t v33 = *(void *)(*a3 + 16 * v32);
    if (v29 == v33)
    {
LABEL_33:
      unint64_t v36 = *(const llvm::Loop **)(v30 + 16 * v32 + 8);
      if (!v36) {
        goto LABEL_132;
      }
      uint64_t v91 = a3;
      while (1)
      {
        int v37 = *((unsigned __int8 *)v27 + 16);
        if (v26)
        {
          if ((v37 - 62) > 0xFFFFFFFD) {
            break;
          }
        }
        unint64_t v39 = 0;
        if (v26 && v37 == 62)
        {
          uint64_t v38 = -(uint64_t)(*((_DWORD *)v27 + 5) & 0x7FFFFFF);
          goto LABEL_41;
        }
LABEL_42:
        SCEVAtScope = llvm::ScalarEvolution::getSCEVAtScope(a4, v39, v36);
        PointerBase = llvm::ScalarEvolution::getPointerBase(a4, SCEVAtScope);
        if (!PointerBase) {
          goto LABEL_132;
        }
        unint64_t v42 = PointerBase;
        if (*((_WORD *)PointerBase + 12) != 14) {
          goto LABEL_132;
        }
        MinusSCEV = (llvm::SCEV *)llvm::ScalarEvolution::getMinusSCEV(a4, SCEVAtScope, PointerBase, 0, 0);
        unsigned int v44 = (unsigned char *)*((void *)this + 4);
        if (*((unsigned char **)this + 3) == v44)
        {
          llvm::raw_ostream::write(this, "\n", 1uLL);
          uint64_t v45 = *((void *)this + 4);
        }
        else
        {
          *unsigned int v44 = 10;
          uint64_t v45 = *((void *)this + 4) + 1;
          *((void *)this + 4) = v45;
        }
        if ((unint64_t)(*((void *)this + 3) - v45) > 4)
        {
          *(unsigned char *)(v45 + 4) = 58;
          *(_DWORD *)uint64_t v45 = 1953721929;
          *((void *)this + 4) += 5;
          uint64_t v46 = this;
        }
        else
        {
          uint64_t v46 = llvm::raw_ostream::write(this, "Inst:", 5uLL);
        }
        llvm::Value::print((llvm::Value *)v27, v46, 0);
        uint64_t v47 = (unsigned char *)*((void *)v46 + 4);
        if (*((unsigned char **)v46 + 3) == v47)
        {
          llvm::raw_ostream::write(v46, "\n", 1uLL);
        }
        else
        {
          unsigned char *v47 = 10;
          ++*((void *)v46 + 4);
        }
        unsigned int v48 = (void *)*((void *)this + 4);
        if (*((void *)this + 3) - (void)v48 > 0x14uLL)
        {
          qmemcpy(v48, "In Loop with Header: ", 21);
          *((void *)this + 4) += 21;
          uint64_t v49 = this;
        }
        else
        {
          uint64_t v49 = llvm::raw_ostream::write(this, "In Loop with Header: ", 0x15uLL);
        }
        BOOL v50 = (uint64_t ***)**((void **)v36 + 4);
        if ((*((unsigned char *)v50 + 23) & 0x10) != 0)
        {
          uint64_t v51 = ***v50;
          uint64_t v52 = *(void *)(v51 + 152);
          uint64_t v53 = *(unsigned int *)(v51 + 168);
          if (!v53) {
            goto LABEL_59;
          }
          LODWORD(v54) = (v53 - 1) & ((v50 >> 4) ^ (v50 >> 9));
          uint64_t v55 = (uint64_t ****)(v52 + 16 * v54);
          uint64_t v56 = *v55;
          if (*v55 != v50)
          {
            int v57 = 1;
            while (v56 != (uint64_t ***)-4096)
            {
              int v58 = v54 + v57++;
              uint64_t v54 = v58 & (v53 - 1);
              uint64_t v56 = *(uint64_t ****)(v52 + 16 * v54);
              if (v56 == v50)
              {
                uint64_t v55 = (uint64_t ****)(v52 + 16 * v54);
                goto LABEL_60;
              }
            }
LABEL_59:
            uint64_t v55 = (uint64_t ****)(v52 + 16 * v53);
          }
LABEL_60:
          uint64_t v59 = (size_t *)v55[1];
          size_t v62 = *v59;
          uint64_t v60 = v59 + 2;
          size_t v61 = v62;
          uint64_t v63 = (unsigned char *)*((void *)v49 + 4);
          if (v62 <= *((void *)v49 + 3) - (void)v63)
          {
            if (v61)
            {
              memcpy(v63, v60, v61);
              uint64_t v63 = (unsigned char *)(*((void *)v49 + 4) + v61);
              *((void *)v49 + 4) = v63;
            }
          }
          else
          {
            uint64_t v49 = llvm::raw_ostream::write(v49, (const char *)v60, v61);
            uint64_t v63 = (unsigned char *)*((void *)v49 + 4);
          }
          goto LABEL_64;
        }
        uint64_t v63 = (unsigned char *)*((void *)v49 + 4);
LABEL_64:
        if (*((unsigned char **)v49 + 3) == v63)
        {
          llvm::raw_ostream::write(v49, "\n", 1uLL);
        }
        else
        {
          *uint64_t v63 = 10;
          ++*((void *)v49 + 4);
        }
        int v64 = (_OWORD *)*((void *)this + 4);
        if (*((void *)this + 3) - (void)v64 > 0xFuLL)
        {
          _OWORD *v64 = *(_OWORD *)"AccessFunction: ";
          *((void *)this + 4) += 16;
          unint64_t v65 = this;
        }
        else
        {
          unint64_t v65 = llvm::raw_ostream::write(this, "AccessFunction: ", 0x10uLL);
        }
        llvm::SCEV::print(MinusSCEV, v65);
        int v66 = (unsigned char *)*((void *)v65 + 4);
        if (*((unsigned char **)v65 + 3) == v66)
        {
          llvm::raw_ostream::write(v65, "\n", 1uLL);
        }
        else
        {
          *int v66 = 10;
          ++*((void *)v65 + 4);
        }
        uint64_t v96 = v98;
        uint64_t v97 = 0x300000000;
        uint64_t v93 = v95;
        uint64_t v94 = 0x300000000;
        ElementSize = (const llvm::SCEV ***)llvm::ScalarEvolution::getElementSize(a4, (llvm::Instruction *)v27);
        llvm::delinearize(a4, (uint64_t)MinusSCEV, (uint64_t)&v96, (uint64_t)&v93, ElementSize);
        if (v97 && v94 && v97 == v94)
        {
          long long v68 = (void *)*((void *)this + 4);
          if (*((void *)this + 3) - (void)v68 > 0xCuLL)
          {
            qmemcpy(v68, "Base offset: ", 13);
            *((void *)this + 4) += 13;
            char v69 = this;
          }
          else
          {
            char v69 = llvm::raw_ostream::write(this, "Base offset: ", 0xDuLL);
          }
          llvm::SCEV::print(v42, v69);
          long long v70 = (unsigned char *)*((void *)v69 + 4);
          if (*((unsigned char **)v69 + 3) == v70)
          {
            llvm::raw_ostream::write(v69, "\n", 1uLL);
          }
          else
          {
            *long long v70 = 10;
            ++*((void *)v69 + 4);
          }
          int v71 = (void *)*((void *)this + 4);
          if (*((void *)this + 3) - (void)v71 > 0x15uLL)
          {
            qmemcpy(v71, "ArrayDecl[UnknownSize]", 22);
            *((void *)this + 4) += 22;
          }
          else
          {
            llvm::raw_ostream::write(this, "ArrayDecl[UnknownSize]", 0x16uLL);
          }
          uint64_t v72 = v97;
          unsigned int v90 = v97 - 1;
          if ((int)v97 >= 2)
          {
            uint64_t v73 = 0;
            do
            {
              unsigned int v74 = (unsigned char *)*((void *)this + 4);
              if (*((unsigned char **)this + 3) == v74)
              {
                uint64_t v75 = llvm::raw_ostream::write(this, "[", 1uLL);
              }
              else
              {
                *unsigned int v74 = 91;
                ++*((void *)this + 4);
                uint64_t v75 = this;
              }
              llvm::SCEV::print(*(llvm::SCEV **)((char *)v93 + v73), v75);
              unint64_t v76 = (unsigned char *)*((void *)v75 + 4);
              if (*((unsigned char **)v75 + 3) == v76)
              {
                llvm::raw_ostream::write(v75, "]", 1uLL);
              }
              else
              {
                *unint64_t v76 = 93;
                ++*((void *)v75 + 4);
              }
              v73 += 8;
            }
            while (8 * v90 != v73);
          }
          uint64_t v78 = *((void *)this + 4);
          if ((unint64_t)(*((void *)this + 3) - v78) > 0x11)
          {
            *(_WORD *)(v78 + 16) = 8294;
            *(_OWORD *)uint64_t v78 = *(_OWORD *)" with elements of ";
            *((void *)this + 4) += 18;
            long long v79 = this;
          }
          else
          {
            long long v79 = llvm::raw_ostream::write(this, " with elements of ", 0x12uLL);
          }
          llvm::SCEV::print(*((llvm::SCEV **)v93 + (int)v90), v79);
          int v80 = (void *)*((void *)v79 + 4);
          if (*((void *)v79 + 3) - (void)v80 > 7uLL)
          {
            *int v80 = 0xA2E736574796220;
            *((void *)v79 + 4) += 8;
          }
          else
          {
            llvm::raw_ostream::write(v79, " bytes.\n", 8uLL);
          }
          long long v81 = (void *)*((void *)this + 4);
          if (*((void *)this + 3) - (void)v81 > 7uLL)
          {
            *long long v81 = 0x6665527961727241;
            *((void *)this + 4) += 8;
          }
          else
          {
            llvm::raw_ostream::write(this, "ArrayRef", 8uLL);
          }
          if ((int)v72 >= 1)
          {
            uint64_t v82 = 0;
            uint64_t v83 = 8 * v72;
            do
            {
              int v84 = (unsigned char *)*((void *)this + 4);
              if (*((unsigned char **)this + 3) == v84)
              {
                uint64_t v85 = llvm::raw_ostream::write(this, "[", 1uLL);
              }
              else
              {
                *int v84 = 91;
                ++*((void *)this + 4);
                uint64_t v85 = this;
              }
              llvm::SCEV::print(*(llvm::SCEV **)((char *)v96 + v82), v85);
              uint64_t v86 = (unsigned char *)*((void *)v85 + 4);
              if (*((unsigned char **)v85 + 3) == v86)
              {
                llvm::raw_ostream::write(v85, "]", 1uLL);
              }
              else
              {
                *uint64_t v86 = 93;
                ++*((void *)v85 + 4);
              }
              v82 += 8;
            }
            while (v83 != v82);
          }
          uint64_t v87 = (unsigned char *)*((void *)this + 4);
          if (*((unsigned char **)this + 3) == v87)
          {
            llvm::raw_ostream::write(this, "\n", 1uLL);
          }
          else
          {
            *uint64_t v87 = 10;
            ++*((void *)this + 4);
          }
          a3 = v91;
        }
        else
        {
          long long v77 = (void *)*((void *)this + 4);
          a3 = v91;
          if (*((void *)this + 3) - (void)v77 > 0x15uLL)
          {
            qmemcpy(v77, "failed to delinearize\n", 22);
            *((void *)this + 4) += 22;
          }
          else
          {
            llvm::raw_ostream::write(this, "failed to delinearize\n", 0x16uLL);
          }
        }
        if (v93 != v95) {
          free(v93);
        }
        if (v96 != v98) {
          free(v96);
        }
        unint64_t v36 = *(const llvm::Loop **)v36;
        if (!v36) {
          goto LABEL_132;
        }
      }
      uint64_t v38 = -1;
LABEL_41:
      unint64_t v39 = (llvm::Value *)v27[4 * v38];
      goto LABEL_42;
    }
    int v34 = 1;
    while (v33 != -4096)
    {
      int v35 = v32 + v34++;
      uint64_t v32 = v35 & v31;
      uint64_t v33 = *(void *)(v30 + 16 * v32);
      if (v29 == v33) {
        goto LABEL_33;
      }
    }
LABEL_132:
    unint64_t v26 = (uint64_t *)v26[1];
    uint64_t v88 = i - 3;
    if (!i) {
      uint64_t v88 = 0;
    }
    if (v26 == (uint64_t *)(v88 + 5)) {
      break;
    }
LABEL_139:
    if (i == (uint64_t **)v23) {
      return;
    }
  }
  while (1)
  {
    uint64_t i = (uint64_t **)i[1];
    if (i == (uint64_t **)v23) {
      break;
    }
    uint64_t v89 = i - 3;
    if (!i) {
      uint64_t v89 = 0;
    }
    unint64_t v26 = v89[6];
    if (v26 != (uint64_t *)(v89 + 5)) {
      goto LABEL_139;
    }
  }
}

void sub_1CBFCED8C(uint64_t a1, uint64_t a2)
{
  int v6 = *(void **)(a1 + 88);
  unint64_t v5 = *(void **)(a1 + 96);
  uint64_t v4 = (unsigned int *)(a1 + 88);
  uint64_t v7 = v4[5];
  if (v5 == v6)
  {
    if (v7)
    {
      uint64_t v8 = 0;
      uint64_t v9 = 8 * v7;
      uint64_t v10 = v5;
      while (*v10 != a2)
      {
        if (*v10 == -2) {
          uint64_t v8 = v10;
        }
        ++v10;
        v9 -= 8;
        if (!v9)
        {
          if (!v8) {
            goto LABEL_9;
          }
          *uint64_t v8 = a2;
          --*(_DWORD *)(a1 + 112);
          goto LABEL_33;
        }
      }
      return;
    }
LABEL_9:
    unsigned int v11 = *(_DWORD *)(a1 + 104);
    if (v7 < v11)
    {
      *(_DWORD *)(a1 + 108) = v7 + 1;
      v5[v7] = a2;
LABEL_33:
      if (*(_WORD *)(a2 + 24) == 14)
      {
        **(unsigned char **)a1 = 1;
      }
      else
      {
        unsigned int v21 = *(_DWORD *)(a1 + 16);
        if (v21 >= *(_DWORD *)(a1 + 20)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 8) + 8 * v2sub_1CD456CB4((void *)this + 1) = a2;
        ++*(_DWORD *)(a1 + 16);
      }
      return;
    }
  }
  else
  {
    unsigned int v11 = *(_DWORD *)(a1 + 104);
  }
  if (3 * v11 <= 4 * ((int)v7 - *(_DWORD *)(a1 + 112)))
  {
    if (v11 >= 0x40) {
      v11 *= 2;
    }
    else {
      unsigned int v11 = 128;
    }
  }
  else if (v11 - v7 >= v11 >> 3)
  {
    goto LABEL_14;
  }
  llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)v4, v11);
  unsigned int v11 = *(_DWORD *)(a1 + 104);
  unint64_t v5 = *(void **)(a1 + 96);
LABEL_14:
  unsigned int v12 = v11 - 1;
  unsigned int v13 = (v11 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  unsigned int v14 = &v5[v13];
  uint64_t v15 = *v14;
  if (*v14 != -1)
  {
    int v16 = 0;
    int v17 = 1;
    while (v15 != a2)
    {
      if (v16) {
        BOOL v18 = 0;
      }
      else {
        BOOL v18 = v15 == -2;
      }
      if (v18) {
        int v16 = v14;
      }
      unsigned int v19 = v13 + v17++;
      unsigned int v13 = v19 & v12;
      unsigned int v14 = &v5[v19 & v12];
      uint64_t v15 = *v14;
      if (*v14 == -1) {
        goto LABEL_26;
      }
    }
    return;
  }
  int v16 = 0;
LABEL_26:
  if (v16) {
    size_t v20 = v16;
  }
  else {
    size_t v20 = v14;
  }
  if (*v20 != a2)
  {
    if (*v20 == -2) {
      --*(_DWORD *)(a1 + 112);
    }
    else {
      ++*(_DWORD *)(a1 + 108);
    }
    *size_t v20 = a2;
    goto LABEL_33;
  }
}

void sub_1CBFCEF60()
{
}

void sub_1CBFCEFA0(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CBFCEFD8(uint64_t a1, llvm::raw_ostream *this)
{
}

void sub_1CBFCEFEC(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
  sub_1CB843600(a2, a2, (uint64_t)&llvm::LoopInfoWrapperPass::ID);

  sub_1CB843600(a2, a2, (uint64_t)&llvm::ScalarEvolutionWrapperPass::ID);
}

uint64_t sub_1CBFCF044(void *a1, uint64_t a2)
{
  a1[4] = a2;
  uint64_t v3 = (uint64_t *)a1[1];
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  if (v4 == v5)
  {
LABEL_4:
    uint64_t v6 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v4 != &llvm::ScalarEvolutionWrapperPass::ID)
    {
      v4 += 16;
      if (v4 == v5) {
        goto LABEL_4;
      }
    }
    uint64_t v6 = *(void *)(v4 + 8);
  }
  a1[6] = *(void *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v6 + 96))(v6, &llvm::ScalarEvolutionWrapperPass::ID)+ 32);
  uint64_t v7 = (uint64_t *)a1[1];
  uint64_t v8 = *v7;
  uint64_t v9 = v7[1];
  if (v8 == v9)
  {
LABEL_9:
    uint64_t v10 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v8 != &llvm::LoopInfoWrapperPass::ID)
    {
      v8 += 16;
      if (v8 == v9) {
        goto LABEL_9;
      }
    }
    uint64_t v10 = *(void *)(v8 + 8);
  }
  a1[5] = (*(uint64_t (**)(uint64_t, void *))(*(void *)v10 + 96))(v10, &llvm::LoopInfoWrapperPass::ID) + 32;
  return 0;
}

void sub_1CBFCF14C(uint64_t a1, uint64_t a2)
{
  v33[3] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void **)(a1 + 88);
  uint64_t v5 = *(void **)(a1 + 96);
  uint64_t v4 = (unsigned int *)(a1 + 88);
  uint64_t v7 = v4[5];
  if (v5 == v6)
  {
    if (v7)
    {
      uint64_t v8 = 0;
      uint64_t v9 = 8 * v7;
      uint64_t v10 = v5;
      while (*v10 != a2)
      {
        if (*v10 == -2) {
          uint64_t v8 = v10;
        }
        ++v10;
        v9 -= 8;
        if (!v9)
        {
          if (!v8) {
            goto LABEL_9;
          }
          *uint64_t v8 = a2;
          --*(_DWORD *)(a1 + 112);
          if (a2) {
            goto LABEL_34;
          }
          goto LABEL_39;
        }
      }
      return;
    }
LABEL_9:
    unsigned int v11 = *(_DWORD *)(a1 + 104);
    if (v7 < v11)
    {
      *(_DWORD *)(a1 + 108) = v7 + 1;
      v5[v7] = a2;
      if (!a2)
      {
LABEL_39:
        unsigned int v25 = *(_DWORD *)(a1 + 16);
        if (v25 >= *(_DWORD *)(a1 + 20)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 8) + 8 * v25) = a2;
        ++*(_DWORD *)(a1 + 16);
        return;
      }
LABEL_34:
      if (*(_WORD *)(a2 + 24) == 7)
      {
        uint64_t v21 = *(void *)(*(void *)a1 + 8);
        uint64_t v22 = *(void *)(a2 + 40);
        if (v22 == 2)
        {
          uint64_t v23 = *(void *)(*(void *)(a2 + 32) + 8);
        }
        else
        {
          unint64_t v26 = **(llvm::ScalarEvolution ***)a1;
          uint64_t v27 = *(void *)(a2 + 32);
          unsigned int v31 = v33;
          uint64_t v32 = 0x300000000;
          uint64_t v28 = v22;
          size_t v29 = 8 * v22 - 8;
          if (v29 >= 0x19) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          int v30 = 0;
          if (v28 != 1)
          {
            memcpy(v31, (const void *)(v27 + 8), v29);
            int v30 = v32;
          }
          LODWORD(v32) = v30 + (v29 >> 3);
          uint64_t v23 = sub_1CD478318(v26, (uint64_t)&v31, *(const llvm::Loop **)(a2 + 48), 0);
          if (v31 != v33) {
            free(v31);
          }
        }
        unsigned int v24 = *(_DWORD *)(v21 + 8);
        if (v24 >= *(_DWORD *)(v21 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)v21 + 8 * v24) = v23;
        ++*(_DWORD *)(v21 + 8);
      }
      goto LABEL_39;
    }
  }
  else
  {
    unsigned int v11 = *(_DWORD *)(a1 + 104);
  }
  if (3 * v11 <= 4 * ((int)v7 - *(_DWORD *)(a1 + 112)))
  {
    if (v11 >= 0x40) {
      v11 *= 2;
    }
    else {
      unsigned int v11 = 128;
    }
  }
  else if (v11 - v7 >= v11 >> 3)
  {
    goto LABEL_15;
  }
  llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)v4, v11);
  unsigned int v11 = *(_DWORD *)(a1 + 104);
  uint64_t v5 = *(void **)(a1 + 96);
LABEL_15:
  unsigned int v12 = v11 - 1;
  unsigned int v13 = (v11 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  unsigned int v14 = &v5[v13];
  uint64_t v15 = *v14;
  if (*v14 != -1)
  {
    int v16 = 0;
    int v17 = 1;
    while (v15 != a2)
    {
      if (v16) {
        BOOL v18 = 0;
      }
      else {
        BOOL v18 = v15 == -2;
      }
      if (v18) {
        int v16 = v14;
      }
      unsigned int v19 = v13 + v17++;
      unsigned int v13 = v19 & v12;
      unsigned int v14 = &v5[v19 & v12];
      uint64_t v15 = *v14;
      if (*v14 == -1) {
        goto LABEL_27;
      }
    }
    return;
  }
  int v16 = 0;
LABEL_27:
  if (v16) {
    size_t v20 = v16;
  }
  else {
    size_t v20 = v14;
  }
  if (*v20 != a2)
  {
    if (*v20 == -2) {
      --*(_DWORD *)(a1 + 112);
    }
    else {
      ++*(_DWORD *)(a1 + 108);
    }
    *size_t v20 = a2;
    if (!a2) {
      goto LABEL_39;
    }
    goto LABEL_34;
  }
}

void sub_1CBFCF46C(uint64_t *a1, uint64_t a2)
{
  v43[8] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (uint64_t *)a1[11];
  uint64_t v5 = (uint64_t *)a1[12];
  uint64_t v4 = (unsigned int *)(a1 + 11);
  uint64_t v7 = v4[5];
  if (v5 == v6)
  {
    if (v7)
    {
      uint64_t v8 = 0;
      uint64_t v9 = 8 * v7;
      uint64_t v10 = v5;
      do
      {
        if (*v10 == a2) {
          return;
        }
        if (*v10 == -2) {
          uint64_t v8 = v10;
        }
        ++v10;
        v9 -= 8;
      }
      while (v9);
      if (v8)
      {
        *uint64_t v8 = a2;
        --*((_DWORD *)a1 + 28);
LABEL_33:
        unsigned int v21 = *(unsigned __int16 *)(a2 + 24);
        if (v21 > 0xE || ((1 << v21) & 0x4028) == 0)
        {
          uint64_t v33 = (unsigned int *)(a1 + 2);
          unsigned int v32 = *((_DWORD *)a1 + 4);
          unsigned int v31 = a1 + 1;
          if (v32 >= *((_DWORD *)a1 + 5)) {
            goto LABEL_68;
          }
LABEL_60:
          *(void *)(*v31 + 8 * v32) = a2;
          ++*v33;
          return;
        }
        uint64_t v22 = *a1;
        char v34 = 0;
        int v35 = &v34;
        unint64_t v36 = v38;
        uint64_t v37 = 0x800000000;
        unint64_t v39 = v43;
        uint64_t v40 = v43;
        uint64_t v41 = 8;
        int v42 = 0;
        sub_1CBFCF81C((uint64_t)&v35, a2);
        unsigned int v23 = v37;
        while (v23)
        {
          if (*v35) {
            break;
          }
          uint64_t v24 = *((void *)v36 + --v23);
          LODWORD(v37) = v23;
          switch(*(_WORD *)(v24 + 24))
          {
            case 1:
            case 2:
            case 3:
            case 0xD:
              int v30 = (uint64_t *)(v24 + 32);
              goto LABEL_47;
            case 4:
            case 5:
            case 7:
            case 8:
            case 9:
            case 0xA:
            case 0xB:
            case 0xC:
              uint64_t v25 = *(void *)(v24 + 40);
              if (v25)
              {
                unint64_t v26 = *(uint64_t **)(v24 + 32);
                uint64_t v27 = 8 * v25 - 8;
                do
                {
                  uint64_t v28 = *v26++;
                  sub_1CBFCF81C((uint64_t)&v35, v28);
                  if (*v35) {
                    BOOL v29 = 1;
                  }
                  else {
                    BOOL v29 = v27 == 0;
                  }
                  v27 -= 8;
                }
                while (!v29);
              }
              goto LABEL_48;
            case 6:
              sub_1CBFCF81C((uint64_t)&v35, *(void *)(v24 + 32));
              int v30 = (uint64_t *)(v24 + 40);
LABEL_47:
              sub_1CBFCF81C((uint64_t)&v35, *v30);
LABEL_48:
              unsigned int v23 = v37;
              break;
            default:
              break;
          }
        }
        if (v40 != v39) {
          free(v40);
        }
        if (v36 != v38) {
          free(v36);
        }
        if (!v34)
        {
          unsigned int v31 = *(void **)v22;
          uint64_t v33 = (unsigned int *)(*(void *)v22 + 8);
          unsigned int v32 = *v33;
          if (*v33 >= *(_DWORD *)(*(void *)v22 + 12)) {
LABEL_68:
          }
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          goto LABEL_60;
        }
        return;
      }
    }
    unsigned int v11 = *((_DWORD *)a1 + 26);
    if (v7 < v11)
    {
      *((_DWORD *)a1 + 27) = v7 + 1;
      v5[v7] = a2;
      goto LABEL_33;
    }
  }
  else
  {
    unsigned int v11 = *((_DWORD *)a1 + 26);
  }
  if (3 * v11 <= 4 * ((int)v7 - *((_DWORD *)a1 + 28)))
  {
    if (v11 >= 0x40) {
      v11 *= 2;
    }
    else {
      unsigned int v11 = 128;
    }
  }
  else if (v11 - v7 >= v11 >> 3)
  {
    goto LABEL_14;
  }
  llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)v4, v11);
  unsigned int v11 = *((_DWORD *)a1 + 26);
  uint64_t v5 = (uint64_t *)a1[12];
LABEL_14:
  unsigned int v12 = v11 - 1;
  unsigned int v13 = (v11 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  unsigned int v14 = &v5[v13];
  uint64_t v15 = *v14;
  if (*v14 != -1)
  {
    int v16 = 0;
    int v17 = 1;
    while (v15 != a2)
    {
      if (v16) {
        BOOL v18 = 0;
      }
      else {
        BOOL v18 = v15 == -2;
      }
      if (v18) {
        int v16 = v14;
      }
      unsigned int v19 = v13 + v17++;
      unsigned int v13 = v19 & v12;
      unsigned int v14 = &v5[v19 & v12];
      uint64_t v15 = *v14;
      if (*v14 == -1) {
        goto LABEL_26;
      }
    }
    return;
  }
  int v16 = 0;
LABEL_26:
  if (v16) {
    size_t v20 = v16;
  }
  else {
    size_t v20 = v14;
  }
  if (*v20 != a2)
  {
    if (*v20 == -2) {
      --*((_DWORD *)a1 + 28);
    }
    else {
      ++*((_DWORD *)a1 + 27);
    }
    *size_t v20 = a2;
    goto LABEL_33;
  }
}

void sub_1CBFCF81C(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *(void **)(a1 + 88);
  uint64_t v5 = *(void **)(a1 + 96);
  uint64_t v4 = (unsigned int *)(a1 + 88);
  uint64_t v7 = v4[5];
  if (v5 == v6)
  {
    if (v7)
    {
      uint64_t v8 = 0;
      uint64_t v9 = 8 * v7;
      uint64_t v10 = v5;
      while (*v10 != a2)
      {
        if (*v10 == -2) {
          uint64_t v8 = v10;
        }
        ++v10;
        v9 -= 8;
        if (!v9)
        {
          if (!v8) {
            goto LABEL_9;
          }
          *uint64_t v8 = a2;
          --*(_DWORD *)(a1 + 112);
          if (a2) {
            goto LABEL_34;
          }
          goto LABEL_38;
        }
      }
      return;
    }
LABEL_9:
    unsigned int v11 = *(_DWORD *)(a1 + 104);
    if (v7 < v11)
    {
      *(_DWORD *)(a1 + 108) = v7 + 1;
      v5[v7] = a2;
      if (!a2)
      {
LABEL_38:
        unsigned int v21 = *(_DWORD *)(a1 + 16);
        if (v21 >= *(_DWORD *)(a1 + 20)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 8) + 8 * v2sub_1CD456CB4((void *)this + 1) = a2;
        ++*(_DWORD *)(a1 + 16);
        return;
      }
LABEL_34:
      if (*(_WORD *)(a2 + 24) == 14 && *(unsigned __int8 *)(*(void *)(a2 - 8) + 16) - 11 <= 1)
      {
        **(unsigned char **)a1 = 1;
        return;
      }
      goto LABEL_38;
    }
  }
  else
  {
    unsigned int v11 = *(_DWORD *)(a1 + 104);
  }
  if (3 * v11 <= 4 * ((int)v7 - *(_DWORD *)(a1 + 112)))
  {
    if (v11 >= 0x40) {
      v11 *= 2;
    }
    else {
      unsigned int v11 = 128;
    }
  }
  else if (v11 - v7 >= v11 >> 3)
  {
    goto LABEL_15;
  }
  llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)v4, v11);
  unsigned int v11 = *(_DWORD *)(a1 + 104);
  uint64_t v5 = *(void **)(a1 + 96);
LABEL_15:
  unsigned int v12 = v11 - 1;
  unsigned int v13 = (v11 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  unsigned int v14 = &v5[v13];
  uint64_t v15 = *v14;
  if (*v14 != -1)
  {
    int v16 = 0;
    int v17 = 1;
    while (v15 != a2)
    {
      if (v16) {
        BOOL v18 = 0;
      }
      else {
        BOOL v18 = v15 == -2;
      }
      if (v18) {
        int v16 = v14;
      }
      unsigned int v19 = v13 + v17++;
      unsigned int v13 = v19 & v12;
      unsigned int v14 = &v5[v19 & v12];
      uint64_t v15 = *v14;
      if (*v14 == -1) {
        goto LABEL_27;
      }
    }
    return;
  }
  int v16 = 0;
LABEL_27:
  if (v16) {
    size_t v20 = v16;
  }
  else {
    size_t v20 = v14;
  }
  if (*v20 != a2)
  {
    if (*v20 == -2) {
      --*(_DWORD *)(a1 + 112);
    }
    else {
      ++*(_DWORD *)(a1 + 108);
    }
    *size_t v20 = a2;
    if (!a2) {
      goto LABEL_38;
    }
    goto LABEL_34;
  }
}

void sub_1CBFCFA0C(uint64_t a1, uint64_t a2)
{
  v53[8] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void **)(a1 + 88);
  uint64_t v5 = *(void **)(a1 + 96);
  uint64_t v4 = (unsigned int *)(a1 + 88);
  uint64_t v7 = v4[5];
  if (v5 == v6)
  {
    if (v7)
    {
      uint64_t v8 = 0;
      uint64_t v9 = 8 * v7;
      uint64_t v10 = v5;
      while (*v10 != a2)
      {
        if (*v10 == -2) {
          uint64_t v8 = v10;
        }
        ++v10;
        v9 -= 8;
        if (!v9)
        {
          if (!v8) {
            goto LABEL_9;
          }
          *uint64_t v8 = a2;
          --*(_DWORD *)(a1 + 112);
          if (a2) {
            goto LABEL_34;
          }
          goto LABEL_73;
        }
      }
      return;
    }
LABEL_9:
    unsigned int v11 = *(_DWORD *)(a1 + 104);
    if (v7 < v11)
    {
      *(_DWORD *)(a1 + 108) = v7 + 1;
      v5[v7] = a2;
      if (!a2) {
        goto LABEL_73;
      }
      goto LABEL_34;
    }
  }
  else
  {
    unsigned int v11 = *(_DWORD *)(a1 + 104);
  }
  if (3 * v11 <= 4 * ((int)v7 - *(_DWORD *)(a1 + 112)))
  {
    if (v11 >= 0x40) {
      v11 *= 2;
    }
    else {
      unsigned int v11 = 128;
    }
  }
  else if (v11 - v7 >= v11 >> 3)
  {
    goto LABEL_15;
  }
  llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)v4, v11);
  unsigned int v11 = *(_DWORD *)(a1 + 104);
  uint64_t v5 = *(void **)(a1 + 96);
LABEL_15:
  unsigned int v12 = v11 - 1;
  unsigned int v13 = (v11 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  unsigned int v14 = &v5[v13];
  uint64_t v15 = *v14;
  if (*v14 != -1)
  {
    int v16 = 0;
    int v17 = 1;
    while (v15 != a2)
    {
      if (v16) {
        BOOL v18 = 0;
      }
      else {
        BOOL v18 = v15 == -2;
      }
      if (v18) {
        int v16 = v14;
      }
      unsigned int v19 = v13 + v17++;
      unsigned int v13 = v19 & v12;
      unsigned int v14 = &v5[v19 & v12];
      uint64_t v15 = *v14;
      if (*v14 == -1) {
        goto LABEL_27;
      }
    }
    return;
  }
  int v16 = 0;
LABEL_27:
  if (v16) {
    size_t v20 = v16;
  }
  else {
    size_t v20 = v14;
  }
  if (*v20 != a2)
  {
    if (*v20 == -2) {
      --*(_DWORD *)(a1 + 112);
    }
    else {
      ++*(_DWORD *)(a1 + 108);
    }
    *size_t v20 = a2;
    if (!a2) {
      goto LABEL_73;
    }
LABEL_34:
    if (*(_WORD *)(a2 + 24) == 5)
    {
      unsigned int v21 = *(uint64_t **)a1;
      uint64_t v43 = &v45;
      uint64_t v44 = 0;
      uint64_t v22 = *(void *)(a2 + 40);
      if (v22)
      {
        uint64_t v40 = v21;
        BOOL v23 = 0;
        uint64_t v24 = *(uint64_t **)(a2 + 32);
        uint64_t v25 = &v24[v22];
        do
        {
          uint64_t v26 = *v24;
          if (*v24) {
            BOOL v27 = *(unsigned __int16 *)(*v24 + 24) == 14;
          }
          else {
            BOOL v27 = 0;
          }
          if (v27)
          {
            if (*(unsigned char *)(*(void *)(v26 - 8) + 16) == 84)
            {
              BOOL v23 = 1;
            }
            else
            {
              if (v44 >= (unint64_t)HIDWORD(v44)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((void *)v43 + v44) = v26;
              LODWORD(v44) = v44 + 1;
            }
          }
          else
          {
            uint64_t v41 = &v42;
            unsigned __int8 v42 = 0;
            uint64_t v45 = &v41;
            uint64_t v46 = v48;
            uint64_t v47 = 0x800000000;
            uint64_t v49 = v53;
            BOOL v50 = v53;
            uint64_t v51 = 8;
            int v52 = 0;
            sub_1CBFCFED0((uint64_t)&v45, v26);
            unsigned int v28 = v47;
            while (v28)
            {
              uint64_t v29 = *((void *)v46 + --v28);
              LODWORD(v47) = v28;
              switch(*(_WORD *)(v29 + 24))
              {
                case 1:
                case 2:
                case 3:
                case 0xD:
                  char v34 = (uint64_t *)(v29 + 32);
                  goto LABEL_48;
                case 4:
                case 5:
                case 7:
                case 8:
                case 9:
                case 0xA:
                case 0xB:
                case 0xC:
                  uint64_t v30 = *(void *)(v29 + 40);
                  if (v30)
                  {
                    unsigned int v31 = *(uint64_t **)(v29 + 32);
                    uint64_t v32 = 8 * v30;
                    do
                    {
                      uint64_t v33 = *v31++;
                      sub_1CBFCFED0((uint64_t)&v45, v33);
                      v32 -= 8;
                    }
                    while (v32);
                  }
                  goto LABEL_49;
                case 6:
                  sub_1CBFCFED0((uint64_t)&v45, *(void *)(v29 + 32));
                  char v34 = (uint64_t *)(v29 + 40);
LABEL_48:
                  sub_1CBFCFED0((uint64_t)&v45, *v34);
LABEL_49:
                  unsigned int v28 = v47;
                  break;
                default:
                  break;
              }
            }
            if (v50 != v49) {
              free(v50);
            }
            if (v46 != v48) {
              free(v46);
            }
            BOOL v23 = (v42 | v23) != 0;
          }
          ++v24;
        }
        while (v24 != v25);
        BOOL v35 = v44 == 0;
        if (v44 && v23)
        {
          uint64_t v36 = *v40;
          uint64_t MulExpr = llvm::ScalarEvolution::getMulExpr(v40[1], (uint64_t)&v43, 0, 0);
          unsigned int v38 = *(_DWORD *)(v36 + 8);
          if (v38 >= *(_DWORD *)(v36 + 12)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          BOOL v35 = 0;
          *(void *)(*(void *)v36 + 8 * v38) = MulExpr;
          ++*(_DWORD *)(v36 + 8);
        }
      }
      else
      {
        BOOL v35 = 1;
      }
      if (v43 != &v45) {
        free(v43);
      }
      if (!v35) {
        return;
      }
    }
LABEL_73:
    unsigned int v39 = *(_DWORD *)(a1 + 16);
    if (v39 >= *(_DWORD *)(a1 + 20)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(a1 + 8) + 8 * v39) = a2;
    ++*(_DWORD *)(a1 + 16);
  }
}

void sub_1CBFCFED0(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *(void **)(a1 + 88);
  uint64_t v5 = *(void **)(a1 + 96);
  uint64_t v4 = (unsigned int *)(a1 + 88);
  uint64_t v7 = v4[5];
  if (v5 == v6)
  {
    if (v7)
    {
      uint64_t v8 = 0;
      uint64_t v9 = 8 * v7;
      uint64_t v10 = v5;
      while (*v10 != a2)
      {
        if (*v10 == -2) {
          uint64_t v8 = v10;
        }
        ++v10;
        v9 -= 8;
        if (!v9)
        {
          if (!v8) {
            goto LABEL_9;
          }
          *uint64_t v8 = a2;
          --*(_DWORD *)(a1 + 112);
          goto LABEL_33;
        }
      }
      return;
    }
LABEL_9:
    unsigned int v11 = *(_DWORD *)(a1 + 104);
    if (v7 < v11)
    {
      *(_DWORD *)(a1 + 108) = v7 + 1;
      v5[v7] = a2;
LABEL_33:
      if (*(_WORD *)(a2 + 24) == 7)
      {
        ***(unsigned char ***)a1 = 1;
      }
      else
      {
        unsigned int v21 = *(_DWORD *)(a1 + 16);
        if (v21 >= *(_DWORD *)(a1 + 20)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 8) + 8 * v2sub_1CD456CB4((void *)this + 1) = a2;
        ++*(_DWORD *)(a1 + 16);
      }
      return;
    }
  }
  else
  {
    unsigned int v11 = *(_DWORD *)(a1 + 104);
  }
  if (3 * v11 <= 4 * ((int)v7 - *(_DWORD *)(a1 + 112)))
  {
    if (v11 >= 0x40) {
      v11 *= 2;
    }
    else {
      unsigned int v11 = 128;
    }
  }
  else if (v11 - v7 >= v11 >> 3)
  {
    goto LABEL_14;
  }
  llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)v4, v11);
  unsigned int v11 = *(_DWORD *)(a1 + 104);
  uint64_t v5 = *(void **)(a1 + 96);
LABEL_14:
  unsigned int v12 = v11 - 1;
  unsigned int v13 = (v11 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  unsigned int v14 = &v5[v13];
  uint64_t v15 = *v14;
  if (*v14 != -1)
  {
    int v16 = 0;
    int v17 = 1;
    while (v15 != a2)
    {
      if (v16) {
        BOOL v18 = 0;
      }
      else {
        BOOL v18 = v15 == -2;
      }
      if (v18) {
        int v16 = v14;
      }
      unsigned int v19 = v13 + v17++;
      unsigned int v13 = v19 & v12;
      unsigned int v14 = &v5[v19 & v12];
      uint64_t v15 = *v14;
      if (*v14 == -1) {
        goto LABEL_26;
      }
    }
    return;
  }
  int v16 = 0;
LABEL_26:
  if (v16) {
    size_t v20 = v16;
  }
  else {
    size_t v20 = v14;
  }
  if (*v20 != a2)
  {
    if (*v20 == -2) {
      --*(_DWORD *)(a1 + 112);
    }
    else {
      ++*(_DWORD *)(a1 + 108);
    }
    *size_t v20 = a2;
    goto LABEL_33;
  }
}

uint64_t sub_1CBFD00A8(uint64_t result, uint64_t *a2, uint64_t a3, char a4)
{
  uint64_t v9 = (uint64_t *)result;
LABEL_2:
  uint64_t v10 = a2 - 1;
  unsigned int v11 = v9;
  while (1)
  {
    uint64_t v9 = v11;
    uint64_t v12 = (char *)a2 - (char *)v11;
    uint64_t v13 = a2 - v11;
    if (v5 || !v4)
    {
      switch(v13)
      {
        case 0:
        case 1:
          return result;
        case 2:
          uint64_t v85 = *(a2 - 1);
          uint64_t v86 = *v11;
          if (v85) {
            BOOL v87 = *(unsigned __int16 *)(v85 + 24) == 5;
          }
          else {
            BOOL v87 = 0;
          }
          if (v87) {
            int v88 = *(_DWORD *)(v85 + 40);
          }
          else {
            int v88 = 1;
          }
          if (v86) {
            BOOL v164 = *(unsigned __int16 *)(v86 + 24) == 5;
          }
          else {
            BOOL v164 = 0;
          }
          if (v164) {
            int v165 = *(_DWORD *)(v86 + 40);
          }
          else {
            int v165 = 1;
          }
          if (v88 > v165)
          {
            *unsigned int v11 = v85;
            *(a2 - sub_1CD456CB4((void *)this + 1) = v86;
          }
          break;
        case 3:
          BOOL result = (uint64_t)sub_1CBFD0D50(v11, v11 + 1, a2 - 1);
          break;
        case 4:
          BOOL result = (uint64_t)sub_1CBFD10C8(v11, v11 + 1, v11 + 2, a2 - 1);
          break;
        case 5:
          BOOL result = (uint64_t)sub_1CBFD0BE4(v11, v11 + 1, v11 + 2, v11 + 3, a2 - 1);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v12 <= 191)
    {
      uint64_t v89 = v11 + 1;
      BOOL v91 = v11 == a2 || v89 == a2;
      if (a4)
      {
        if (!v91)
        {
          uint64_t v92 = 8;
          uint64_t v93 = v11;
          do
          {
            uint64_t v94 = v89;
            uint64_t v95 = v93[1];
            if (v95) {
              BOOL v96 = *(unsigned __int16 *)(v95 + 24) == 5;
            }
            else {
              BOOL v96 = 0;
            }
            char v97 = !v96;
            if (v96) {
              int v98 = *(_DWORD *)(v95 + 40);
            }
            else {
              int v98 = 1;
            }
            uint64_t v99 = *v93;
            if (v99) {
              BOOL v100 = *(unsigned __int16 *)(v99 + 24) == 5;
            }
            else {
              BOOL v100 = 0;
            }
            if (v100) {
              int v101 = *(_DWORD *)(v99 + 40);
            }
            else {
              int v101 = 1;
            }
            if (v98 > v101)
            {
              uint64_t v102 = v92;
              do
              {
                *(uint64_t *)((char *)v11 + v102) = v99;
                uint64_t v103 = v102 - 8;
                if (v102 == 8)
                {
                  uint64_t v107 = v11;
                  goto LABEL_214;
                }
                if (v97) {
                  int v104 = 1;
                }
                else {
                  int v104 = *(_DWORD *)(v95 + 40);
                }
                uint64_t v99 = *(uint64_t *)((char *)v11 + v102 - 16);
                if (v99) {
                  BOOL v105 = *(unsigned __int16 *)(v99 + 24) == 5;
                }
                else {
                  BOOL v105 = 0;
                }
                if (v105) {
                  int v106 = *(_DWORD *)(v99 + 40);
                }
                else {
                  int v106 = 1;
                }
                v102 -= 8;
              }
              while (v104 > v106);
              uint64_t v107 = (uint64_t *)((char *)v11 + v103);
LABEL_214:
              uint64_t *v107 = v95;
            }
            uint64_t v89 = v94 + 1;
            v92 += 8;
            uint64_t v93 = v94;
          }
          while (v94 + 1 != a2);
        }
      }
      else if (!v91)
      {
        do
        {
          uint64_t v166 = v89;
          uint64_t v167 = v9[1];
          if (v167) {
            BOOL v168 = *(unsigned __int16 *)(v167 + 24) == 5;
          }
          else {
            BOOL v168 = 0;
          }
          char v169 = !v168;
          if (v168) {
            int v170 = *(_DWORD *)(v167 + 40);
          }
          else {
            int v170 = 1;
          }
          uint64_t v171 = *v9;
          if (*v9) {
            BOOL v172 = *(unsigned __int16 *)(*v9 + 24) == 5;
          }
          else {
            BOOL v172 = 0;
          }
          if (v172) {
            int v173 = *(_DWORD *)(v171 + 40);
          }
          else {
            int v173 = 1;
          }
          if (v170 > v173)
          {
            char v174 = v166;
            do
            {
              *char v174 = v171;
              if (v169) {
                int v175 = 1;
              }
              else {
                int v175 = *(_DWORD *)(v167 + 40);
              }
              uint64_t v171 = *(v174 - 2);
              if (v171) {
                BOOL v176 = *(unsigned __int16 *)(v171 + 24) == 5;
              }
              else {
                BOOL v176 = 0;
              }
              if (v176) {
                int v177 = *(_DWORD *)(v171 + 40);
              }
              else {
                int v177 = 1;
              }
              --v174;
            }
            while (v175 > v177);
            *char v174 = v167;
          }
          uint64_t v89 = v166 + 1;
          uint64_t v9 = v166;
        }
        while (v166 + 1 != a2);
      }
      return result;
    }
    if (!a3) {
      break;
    }
    unint64_t v14 = (unint64_t)v13 >> 1;
    uint64_t v15 = &v11[(unint64_t)v13 >> 1];
    if ((unint64_t)v12 >= 0x401)
    {
      sub_1CBFD0D50(v9, &v9[(unint64_t)v13 >> 1], a2 - 1);
      sub_1CBFD0D50(v9 + 1, v15 - 1, a2 - 2);
      sub_1CBFD0D50(v9 + 2, &v9[v14 + 1], a2 - 3);
      BOOL result = (uint64_t)sub_1CBFD0D50(v15 - 1, v15, &v9[v14 + 1]);
      uint64_t v16 = *v9;
      *uint64_t v9 = *v15;
      uint64_t *v15 = v16;
    }
    else
    {
      BOOL result = (uint64_t)sub_1CBFD0D50(&v9[(unint64_t)v13 >> 1], v9, a2 - 1);
    }
    --a3;
    uint64_t v17 = *v9;
    if (a4)
    {
      int v18 = *(unsigned __int16 *)(v17 + 24);
LABEL_22:
      uint64_t v22 = 0;
      do
      {
        uint64_t v23 = v9[v22 + 1];
        if (v23) {
          BOOL v24 = *(unsigned __int16 *)(v23 + 24) == 5;
        }
        else {
          BOOL v24 = 0;
        }
        if (v24) {
          int v25 = *(_DWORD *)(v23 + 40);
        }
        else {
          int v25 = 1;
        }
        if (v18 == 5) {
          int v26 = *(_DWORD *)(v17 + 40);
        }
        else {
          int v26 = 1;
        }
        ++v22;
      }
      while (v25 > v26);
      BOOL v27 = &v9[v22];
      unsigned int v28 = a2;
      if (v22 == 1)
      {
        unsigned int v28 = a2;
        do
        {
          if (v27 >= v28) {
            break;
          }
          uint64_t v36 = *--v28;
          uint64_t v35 = v36;
          int v37 = *(unsigned __int16 *)(v36 + 24);
          BOOL v38 = v36 && v37 == 5;
          int v39 = v38 ? *(_DWORD *)(v35 + 40) : 1;
          int v40 = v18 == 5 ? *(_DWORD *)(v17 + 40) : 1;
        }
        while (v39 <= v40);
      }
      else
      {
        do
        {
          uint64_t v30 = *--v28;
          uint64_t v29 = v30;
          int v31 = *(unsigned __int16 *)(v30 + 24);
          if (v30) {
            BOOL v32 = v31 == 5;
          }
          else {
            BOOL v32 = 0;
          }
          if (v32) {
            int v33 = *(_DWORD *)(v29 + 40);
          }
          else {
            int v33 = 1;
          }
          if (v18 == 5) {
            int v34 = *(_DWORD *)(v17 + 40);
          }
          else {
            int v34 = 1;
          }
        }
        while (v33 <= v34);
      }
      if (v27 >= v28)
      {
        unsigned int v11 = v27;
      }
      else
      {
        uint64_t v41 = *v28;
        unsigned int v11 = v27;
        unsigned __int8 v42 = v28;
        do
        {
          *unsigned int v11 = v41;
          uint64_t *v42 = v23;
          do
          {
            uint64_t v43 = v11[1];
            ++v11;
            uint64_t v23 = v43;
            int v44 = *(unsigned __int16 *)(v43 + 24);
            if (v43) {
              BOOL v45 = v44 == 5;
            }
            else {
              BOOL v45 = 0;
            }
            if (v45) {
              int v46 = *(_DWORD *)(v23 + 40);
            }
            else {
              int v46 = 1;
            }
            if (v18 == 5) {
              int v47 = *(_DWORD *)(v17 + 40);
            }
            else {
              int v47 = 1;
            }
          }
          while (v46 > v47);
          do
          {
            uint64_t v48 = *--v42;
            uint64_t v41 = v48;
            int v49 = *(unsigned __int16 *)(v48 + 24);
            if (v48) {
              BOOL v50 = v49 == 5;
            }
            else {
              BOOL v50 = 0;
            }
            if (v50) {
              int v51 = *(_DWORD *)(v41 + 40);
            }
            else {
              int v51 = 1;
            }
            if (v18 == 5) {
              int v52 = *(_DWORD *)(v17 + 40);
            }
            else {
              int v52 = 1;
            }
          }
          while (v51 <= v52);
        }
        while (v11 < v42);
      }
      uint64_t v53 = v11 - 1;
      if (v11 - 1 != v9) {
        *uint64_t v9 = *v53;
      }
      *uint64_t v53 = v17;
      if (v27 < v28) {
        goto LABEL_88;
      }
      BOOL v54 = sub_1CBFD0EA8(v9, v11 - 1);
      BOOL result = sub_1CBFD0EA8(v11, a2);
      if (result)
      {
        a2 = v11 - 1;
        if (v54) {
          return result;
        }
        goto LABEL_2;
      }
      if (!v54)
      {
LABEL_88:
        BOOL result = sub_1CBFD00A8(v9, v11 - 1, a3, a4 & 1);
        a4 = 0;
      }
    }
    else
    {
      uint64_t v19 = *(v9 - 1);
      if (v19 && *(_WORD *)(v19 + 24) == 5)
      {
        int v20 = *(_DWORD *)(v19 + 40);
        int v18 = *(unsigned __int16 *)(v17 + 24);
        if (!v17 || v18 != 5)
        {
          if (v20 > 1) {
            goto LABEL_22;
          }
          LOBYTE(v20) = 1;
LABEL_90:
          int v21 = 1;
          goto LABEL_91;
        }
LABEL_20:
        int v21 = *(_DWORD *)(v17 + 40);
        if (v20 > v21)
        {
          int v18 = 5;
          goto LABEL_22;
        }
        LOBYTE(v20) = 0;
        goto LABEL_91;
      }
      int v20 = 1;
      if (!v17) {
        goto LABEL_90;
      }
      int v21 = 1;
      if (*(_WORD *)(v17 + 24) == 5) {
        goto LABEL_20;
      }
LABEL_91:
      uint64_t v55 = *v10;
      int v56 = 1;
      if (*v10 && *(_WORD *)(v55 + 24) == 5) {
        int v56 = *(_DWORD *)(v55 + 40);
      }
      if (v21 <= v56)
      {
        uint64_t v63 = v9 + 1;
        do
        {
          unsigned int v11 = v63;
          if (v63 >= a2) {
            break;
          }
          int v64 = (v20 & 1) != 0 ? 1 : *(_DWORD *)(v17 + 40);
          BOOL v65 = *v63 && *(_WORD *)(*v63 + 24) == 5;
          int v66 = v65 ? *(_DWORD *)(*v63++ + 40) : 1;
        }
        while (v64 <= v66);
      }
      else
      {
        unsigned int v11 = v9;
        do
        {
          if (v20) {
            int v57 = 1;
          }
          else {
            int v57 = *(_DWORD *)(v17 + 40);
          }
          uint64_t v59 = v11[1];
          ++v11;
          uint64_t v58 = v59;
          int v60 = *(unsigned __int16 *)(v59 + 24);
          if (v59) {
            BOOL v61 = v60 == 5;
          }
          else {
            BOOL v61 = 0;
          }
          if (v61) {
            int v62 = *(_DWORD *)(v58 + 40);
          }
          else {
            int v62 = 1;
          }
        }
        while (v57 <= v62);
      }
      uint64_t v67 = a2;
      if (v11 < a2)
      {
        uint64_t v67 = a2;
        do
        {
          if (v20) {
            int v68 = 1;
          }
          else {
            int v68 = *(_DWORD *)(v17 + 40);
          }
          uint64_t v70 = *--v67;
          uint64_t v69 = v70;
          int v71 = *(unsigned __int16 *)(v70 + 24);
          if (v70) {
            BOOL v72 = v71 == 5;
          }
          else {
            BOOL v72 = 0;
          }
          if (v72) {
            int v73 = *(_DWORD *)(v69 + 40);
          }
          else {
            int v73 = 1;
          }
        }
        while (v68 > v73);
      }
      if (v11 < v67)
      {
        uint64_t v74 = *v11;
        uint64_t v75 = *v67;
        do
        {
          *unsigned int v11 = v75;
          *uint64_t v67 = v74;
          do
          {
            uint64_t v76 = v11[1];
            ++v11;
            uint64_t v74 = v76;
            if (v20) {
              int v77 = 1;
            }
            else {
              int v77 = *(_DWORD *)(v17 + 40);
            }
            if (v74) {
              BOOL v78 = *(unsigned __int16 *)(v74 + 24) == 5;
            }
            else {
              BOOL v78 = 0;
            }
            if (v78) {
              int v79 = *(_DWORD *)(v74 + 40);
            }
            else {
              int v79 = 1;
            }
          }
          while (v77 <= v79);
          do
          {
            uint64_t v80 = *--v67;
            uint64_t v75 = v80;
            if (v20) {
              int v81 = 1;
            }
            else {
              int v81 = *(_DWORD *)(v17 + 40);
            }
            if (v75) {
              BOOL v82 = *(unsigned __int16 *)(v75 + 24) == 5;
            }
            else {
              BOOL v82 = 0;
            }
            if (v82) {
              int v83 = *(_DWORD *)(v75 + 40);
            }
            else {
              int v83 = 1;
            }
          }
          while (v81 > v83);
        }
        while (v11 < v67);
      }
      int v84 = v11 - 1;
      BOOL v4 = v11 - 1 >= v9;
      BOOL v5 = v11 - 1 == v9;
      if (v11 - 1 != v9) {
        *uint64_t v9 = *v84;
      }
      a4 = 0;
      *int v84 = v17;
    }
  }
  if (v11 != a2)
  {
    int64_t v108 = (unint64_t)(v13 - 2) >> 1;
    int64_t v109 = v108;
    while (2)
    {
      int64_t v110 = v109;
      if (v108 >= v109)
      {
        uint64_t v111 = (2 * v109) | 1;
        uint64_t v112 = &v11[v111];
        if (2 * v110 + 2 < v13)
        {
          if (*v112) {
            BOOL v113 = *(unsigned __int16 *)(*v112 + 24) == 5;
          }
          else {
            BOOL v113 = 0;
          }
          if (v113) {
            int v114 = *(_DWORD *)(*v112 + 40);
          }
          else {
            int v114 = 1;
          }
          uint64_t v116 = v112[1];
          ++v112;
          uint64_t v115 = v116;
          int v117 = *(unsigned __int16 *)(v116 + 24);
          if (v116) {
            BOOL v118 = v117 == 5;
          }
          else {
            BOOL v118 = 0;
          }
          if (v118) {
            int v119 = *(_DWORD *)(v115 + 40);
          }
          else {
            int v119 = 1;
          }
          if (v114 > v119) {
            uint64_t v111 = 2 * v110 + 2;
          }
          else {
            uint64_t v112 = &v11[v111];
          }
        }
        uint64_t v120 = *v112;
        BOOL v121 = *v112 && *(_WORD *)(*v112 + 24) == 5;
        int v122 = v121 ? *(_DWORD *)(v120 + 40) : 1;
        int v123 = &v11[v110];
        uint64_t v124 = *v123;
        BOOL v125 = *v123 && *(_WORD *)(*v123 + 24) == 5;
        BOOL v126 = !v125;
        BOOL result = v125 ? *(unsigned int *)(v124 + 40) : 1;
        if (v122 <= (int)result)
        {
          while (2)
          {
            unsigned int v127 = v112;
            *int v123 = v120;
            if (v108 < v111)
            {
LABEL_279:
              *unsigned int v127 = v124;
              break;
            }
            uint64_t v128 = (2 * v111) | 1;
            uint64_t v112 = &v11[v128];
            if (2 * v111 + 2 < v13)
            {
              if (*v112) {
                BOOL v129 = *(unsigned __int16 *)(*v112 + 24) == 5;
              }
              else {
                BOOL v129 = 0;
              }
              if (v129) {
                int v130 = *(_DWORD *)(*v112 + 40);
              }
              else {
                int v130 = 1;
              }
              uint64_t v132 = v112[1];
              ++v112;
              uint64_t v131 = v132;
              int v133 = *(unsigned __int16 *)(v132 + 24);
              if (v132) {
                BOOL v134 = v133 == 5;
              }
              else {
                BOOL v134 = 0;
              }
              if (v134) {
                int v135 = *(_DWORD *)(v131 + 40);
              }
              else {
                int v135 = 1;
              }
              if (v130 > v135)
              {
                uint64_t v111 = 2 * v111 + 2;
              }
              else
              {
                uint64_t v112 = &v11[v128];
                uint64_t v111 = (2 * v111) | 1;
              }
            }
            else
            {
              uint64_t v111 = (2 * v111) | 1;
            }
            uint64_t v120 = *v112;
            if (*v112) {
              BOOL v136 = *(unsigned __int16 *)(*v112 + 24) == 5;
            }
            else {
              BOOL v136 = 0;
            }
            if (v136)
            {
              BOOL result = *(unsigned int *)(v120 + 40);
              if (v126) {
                goto LABEL_277;
              }
LABEL_275:
              int v137 = *(_DWORD *)(v124 + 40);
            }
            else
            {
              BOOL result = 1;
              if (!v126) {
                goto LABEL_275;
              }
LABEL_277:
              int v137 = 1;
            }
            int v123 = v127;
            if ((int)result > v137) {
              goto LABEL_279;
            }
            continue;
          }
        }
      }
      int64_t v109 = v110 - 1;
      if (v110) {
        continue;
      }
      break;
    }
    while (1)
    {
      uint64_t v138 = 0;
      uint64_t v139 = *v11;
      BOOL v140 = v11;
      do
      {
        size_t v141 = &v140[v138 + 1];
        uint64_t v142 = (2 * v138) | 1;
        uint64_t v143 = 2 * v138 + 2;
        if (v143 < v13)
        {
          BOOL v144 = *v141 && *(_WORD *)(*v141 + 24) == 5;
          int v145 = v144 ? *(_DWORD *)(*v141 + 40) : 1;
          uint64_t v146 = v141[1];
          BOOL result = *(unsigned __int16 *)(v146 + 24);
          BOOL v147 = v146 && result == 5;
          int v148 = v147 ? *(_DWORD *)(v146 + 40) : 1;
          if (v145 > v148)
          {
            ++v141;
            uint64_t v142 = v143;
          }
        }
        uint64_t *v140 = *v141;
        BOOL v140 = v141;
        uint64_t v138 = v142;
      }
      while (v142 <= (uint64_t)((unint64_t)(v13 - 2) >> 1));
      if (v141 == --a2)
      {
        uint64_t *v141 = v139;
        goto LABEL_328;
      }
      uint64_t *v141 = *a2;
      *a2 = v139;
      uint64_t v149 = (char *)v141 - (char *)v11 + 8;
      if (v149 >= 9)
      {
        unint64_t v150 = (((unint64_t)v149 >> 3) - 2) >> 1;
        uint64_t v151 = &v11[v150];
        uint64_t v152 = *v151;
        BOOL v153 = *v151 && *(_WORD *)(*v151 + 24) == 5;
        int v154 = v153 ? *(_DWORD *)(v152 + 40) : 1;
        uint64_t v155 = *v141;
        BOOL v156 = *v141 && *(_WORD *)(*v141 + 24) == 5;
        BOOL v157 = !v156;
        int v158 = v156 ? *(_DWORD *)(v155 + 40) : 1;
        if (v154 > v158) {
          break;
        }
      }
LABEL_328:
      if (v13-- <= 2) {
        return result;
      }
    }
    while (2)
    {
      std::string::size_type v159 = v151;
      uint64_t *v141 = v152;
      if (!v150)
      {
LABEL_327:
        *std::string::size_type v159 = v155;
        goto LABEL_328;
      }
      unint64_t v150 = (v150 - 1) >> 1;
      uint64_t v151 = &v11[v150];
      uint64_t v152 = *v151;
      if (*v151) {
        BOOL v160 = *(unsigned __int16 *)(*v151 + 24) == 5;
      }
      else {
        BOOL v160 = 0;
      }
      if (v160)
      {
        int v161 = *(_DWORD *)(v152 + 40);
        if (v157) {
          goto LABEL_325;
        }
LABEL_323:
        int v162 = *(_DWORD *)(v155 + 40);
      }
      else
      {
        int v161 = 1;
        if (!v157) {
          goto LABEL_323;
        }
LABEL_325:
        int v162 = 1;
      }
      size_t v141 = v159;
      if (v161 <= v162) {
        goto LABEL_327;
      }
      continue;
    }
  }
  return result;
}

uint64_t *sub_1CBFD0BE4(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  BOOL result = sub_1CBFD10C8(a1, a2, a3, a4);
  uint64_t v11 = *a5;
  uint64_t v12 = *a4;
  if (*a5) {
    BOOL v13 = *(unsigned __int16 *)(*a5 + 24) == 5;
  }
  else {
    BOOL v13 = 0;
  }
  if (v13) {
    int v14 = *(_DWORD *)(v11 + 40);
  }
  else {
    int v14 = 1;
  }
  if (v12) {
    BOOL v15 = *(unsigned __int16 *)(v12 + 24) == 5;
  }
  else {
    BOOL v15 = 0;
  }
  if (v15) {
    int v16 = *(_DWORD *)(v12 + 40);
  }
  else {
    int v16 = 1;
  }
  if (v14 > v16)
  {
    *a4 = v11;
    *a5 = v12;
    uint64_t v17 = *a4;
    uint64_t v18 = *a3;
    int v19 = 1;
    if (*a4 && *(_WORD *)(v17 + 24) == 5) {
      int v19 = *(_DWORD *)(v17 + 40);
    }
    int v20 = 1;
    if (v18 && *(_WORD *)(v18 + 24) == 5) {
      int v20 = *(_DWORD *)(v18 + 40);
    }
    if (v19 > v20)
    {
      *a3 = v17;
      *a4 = v18;
      uint64_t v21 = *a3;
      uint64_t v22 = *a2;
      int v23 = 1;
      if (*a3 && *(_WORD *)(v21 + 24) == 5) {
        int v23 = *(_DWORD *)(v21 + 40);
      }
      int v24 = 1;
      if (v22 && *(_WORD *)(v22 + 24) == 5) {
        int v24 = *(_DWORD *)(v22 + 40);
      }
      if (v23 > v24)
      {
        *a2 = v21;
        *a3 = v22;
        uint64_t v25 = *a2;
        uint64_t v26 = *a1;
        int v27 = 1;
        if (*a2 && *(_WORD *)(v25 + 24) == 5) {
          int v27 = *(_DWORD *)(v25 + 40);
        }
        int v28 = 1;
        if (v26 && *(_WORD *)(v26 + 24) == 5) {
          int v28 = *(_DWORD *)(v26 + 40);
        }
        if (v27 > v28)
        {
          *a1 = v25;
          *a2 = v26;
        }
      }
    }
  }
  return result;
}

uint64_t *sub_1CBFD0D50(uint64_t *result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *result;
  if (*a2) {
    BOOL v5 = *(unsigned __int16 *)(*a2 + 24) == 5;
  }
  else {
    BOOL v5 = 0;
  }
  char v6 = !v5;
  if (v5) {
    int v7 = *(_DWORD *)(v3 + 40);
  }
  else {
    int v7 = 1;
  }
  if (v4) {
    BOOL v8 = *(unsigned __int16 *)(v4 + 24) == 5;
  }
  else {
    BOOL v8 = 0;
  }
  char v9 = !v8;
  if (v8) {
    int v10 = *(_DWORD *)(v4 + 40);
  }
  else {
    int v10 = 1;
  }
  uint64_t v11 = *a3;
  if (*a3) {
    BOOL v12 = *(unsigned __int16 *)(*a3 + 24) == 5;
  }
  else {
    BOOL v12 = 0;
  }
  char v13 = !v12;
  if (v7 <= v10)
  {
    if (v13)
    {
      int v16 = 1;
      if ((v6 & 1) == 0)
      {
LABEL_31:
        int v17 = *(_DWORD *)(v3 + 40);
        goto LABEL_38;
      }
    }
    else
    {
      int v16 = *(_DWORD *)(v11 + 40);
      if ((v6 & 1) == 0) {
        goto LABEL_31;
      }
    }
    int v17 = 1;
LABEL_38:
    if (v16 > v17)
    {
      *a2 = v11;
      *a3 = v3;
      uint64_t v18 = *a2;
      uint64_t v19 = *result;
      int v20 = 1;
      if (*a2 && *(_WORD *)(v18 + 24) == 5) {
        int v20 = *(_DWORD *)(v18 + 40);
      }
      int v21 = 1;
      if (v19 && *(_WORD *)(v19 + 24) == 5) {
        int v21 = *(_DWORD *)(v19 + 40);
      }
      if (v20 > v21)
      {
        uint64_t *result = v18;
        *a2 = v19;
      }
    }
    return result;
  }
  if ((v13 & 1) == 0)
  {
    int v14 = *(_DWORD *)(v11 + 40);
    if ((v6 & 1) == 0) {
      goto LABEL_28;
    }
LABEL_33:
    int v15 = 1;
    goto LABEL_34;
  }
  int v14 = 1;
  if (v6) {
    goto LABEL_33;
  }
LABEL_28:
  int v15 = *(_DWORD *)(v3 + 40);
LABEL_34:
  if (v14 > v15)
  {
    uint64_t *result = v11;
LABEL_55:
    *a3 = v4;
    return result;
  }
  uint64_t *result = v3;
  *a2 = v4;
  uint64_t v22 = *a3;
  int v23 = 1;
  if (*a3 && *(_WORD *)(v22 + 24) == 5) {
    int v23 = *(_DWORD *)(v22 + 40);
  }
  if (v9) {
    int v24 = 1;
  }
  else {
    int v24 = *(_DWORD *)(v4 + 40);
  }
  if (v23 > v24)
  {
    *a2 = v22;
    goto LABEL_55;
  }
  return result;
}

BOOL sub_1CBFD0EA8(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v6 = *(a2 - 1);
      uint64_t v7 = *a1;
      if (v6) {
        BOOL v8 = *(unsigned __int16 *)(v6 + 24) == 5;
      }
      else {
        BOOL v8 = 0;
      }
      if (v8) {
        int v9 = *(_DWORD *)(v6 + 40);
      }
      else {
        int v9 = 1;
      }
      if (v7) {
        BOOL v27 = *(unsigned __int16 *)(v7 + 24) == 5;
      }
      else {
        BOOL v27 = 0;
      }
      if (v27) {
        int v28 = *(_DWORD *)(v7 + 40);
      }
      else {
        int v28 = 1;
      }
      if (v9 > v28)
      {
        *a1 = v6;
        *(a2 - sub_1CD456CB4((void *)this + 1) = v7;
      }
      return result;
    case 3:
      sub_1CBFD0D50(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      sub_1CBFD10C8(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      sub_1CBFD0BE4(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      int v10 = a1 + 2;
      sub_1CBFD0D50(a1, a1 + 1, a1 + 2);
      uint64_t v11 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v12 = 0;
      uint64_t v13 = 24;
      break;
  }
  while (1)
  {
    uint64_t v14 = *v11;
    BOOL v15 = *v11 && *(_WORD *)(*v11 + 24) == 5;
    BOOL v16 = !v15;
    int v17 = v15 ? *(_DWORD *)(v14 + 40) : 1;
    uint64_t v18 = *v10;
    BOOL v19 = *v10 && *(_WORD *)(*v10 + 24) == 5;
    int v20 = v19 ? *(_DWORD *)(v18 + 40) : 1;
    if (v17 > v20)
    {
      uint64_t v21 = v13;
      while (1)
      {
        *(uint64_t *)((char *)a1 + v2sub_1CD456CB4((void *)this + 1) = v18;
        uint64_t v22 = v21 - 8;
        if (v21 == 8) {
          break;
        }
        if (v16) {
          int v23 = 1;
        }
        else {
          int v23 = *(_DWORD *)(v14 + 40);
        }
        uint64_t v18 = *(uint64_t *)((char *)a1 + v21 - 16);
        if (v18) {
          BOOL v24 = *(unsigned __int16 *)(v18 + 24) == 5;
        }
        else {
          BOOL v24 = 0;
        }
        if (v24) {
          int v25 = *(_DWORD *)(v18 + 40);
        }
        else {
          int v25 = 1;
        }
        v21 -= 8;
        if (v23 <= v25)
        {
          uint64_t v26 = (uint64_t *)((char *)a1 + v22);
          goto LABEL_39;
        }
      }
      uint64_t v26 = a1;
LABEL_39:
      uint64_t *v26 = v14;
      if (++v12 == 8) {
        return v11 + 1 == a2;
      }
    }
    int v10 = v11;
    v13 += 8;
    if (++v11 == a2) {
      return 1;
    }
  }
}

uint64_t *sub_1CBFD10C8(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  BOOL result = sub_1CBFD0D50(a1, a2, a3);
  uint64_t v9 = *a4;
  uint64_t v10 = *a3;
  if (*a4) {
    BOOL v11 = *(unsigned __int16 *)(*a4 + 24) == 5;
  }
  else {
    BOOL v11 = 0;
  }
  if (v11) {
    int v12 = *(_DWORD *)(v9 + 40);
  }
  else {
    int v12 = 1;
  }
  if (v10) {
    BOOL v13 = *(unsigned __int16 *)(v10 + 24) == 5;
  }
  else {
    BOOL v13 = 0;
  }
  if (v13) {
    int v14 = *(_DWORD *)(v10 + 40);
  }
  else {
    int v14 = 1;
  }
  if (v12 > v14)
  {
    *a3 = v9;
    *a4 = v10;
    uint64_t v15 = *a3;
    uint64_t v16 = *a2;
    int v17 = 1;
    if (*a3 && *(_WORD *)(v15 + 24) == 5) {
      int v17 = *(_DWORD *)(v15 + 40);
    }
    int v18 = 1;
    if (v16 && *(_WORD *)(v16 + 24) == 5) {
      int v18 = *(_DWORD *)(v16 + 40);
    }
    if (v17 > v18)
    {
      *a2 = v15;
      *a3 = v16;
      uint64_t v19 = *a2;
      uint64_t v20 = *a1;
      int v21 = 1;
      if (*a2 && *(_WORD *)(v19 + 24) == 5) {
        int v21 = *(_DWORD *)(v19 + 40);
      }
      int v22 = 1;
      if (v20 && *(_WORD *)(v20 + 24) == 5) {
        int v22 = *(_DWORD *)(v20 + 40);
      }
      if (v21 > v22)
      {
        *a1 = v19;
        *a2 = v20;
      }
    }
  }
  return result;
}

void sub_1CBFD11E0(uint64_t a1)
{
}

void llvm::DemandedBits::determineLiveOperandBits(llvm::DemandedBits *this, const llvm::Instruction *a2, uint64_t a3, llvm::DemandedBits *a4, const llvm::APInt *a5, llvm::APInt *a6, llvm::KnownBits *a7, llvm::KnownBits *a8, int8x8_t a9, BOOL *a10)
{
  int v12 = (unsigned int *)a5;
  int v14 = a2;
  v204 = a2;
  unint64_t v15 = *((unsigned int *)a6 + 2);
  v203[0] = a10;
  v203[1] = &v204;
  v203[2] = a7;
  v203[3] = this;
  v203[4] = a8;
  switch(*((unsigned char *)a2 + 16))
  {
    case ')':
      uint64_t v17 = *((unsigned int *)a5 + 2);
      if (v17 <= 0x40)
      {
        uint64_t v18 = *(void *)a5;
        if (*(void *)a5 && ((v18 + 1) & v18) == 0) {
          goto LABEL_22;
        }
        goto LABEL_5;
      }
      int v181 = llvm::APInt::countTrailingOnesSlowCase(a5);
      if (!v181) {
        goto LABEL_5;
      }
      int v182 = 0;
      int64_t v183 = (unint64_t)(v17 + 63) >> 6;
      do
      {
        BOOL v56 = v183-- < 1;
        if (v56) {
          break;
        }
        unint64_t v184 = *(void *)(*(void *)v12 + 8 * v183);
        v182 += __clz(v184);
      }
      while (!v184);
      int v185 = v17 | 0xFFFFFFC0;
      if ((v17 & 0x3F) == 0) {
        int v185 = 0;
      }
      if (v181 + v182 + v185 != v17)
      {
LABEL_5:
        int v19 = *((_DWORD *)v14 + 5);
        if ((v19 & 0x40000000) != 0) {
          uint64_t v20 = (uint64_t *)*((void *)v14 - 1);
        }
        else {
          uint64_t v20 = (uint64_t *)((char *)v14 - 32 * (v19 & 0x7FFFFFF));
        }
        sub_1CBFD2DD4((uint64_t)v203, v15, *v20, v20[4]);
        sub_1CBFD4900((uint64_t)&v201, (int)a4, v12, (uint64_t)a7, (uint64_t)a8, 1, 0);
        goto LABEL_103;
      }
      goto LABEL_23;
    case '*':
    case ',':
    case '.':
    case '/':
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case ';':
    case '<':
    case '=':
    case '>':
    case '?':
    case '@':
    case 'A':
      return;
    case '+':
      uint64_t v17 = *((unsigned int *)a5 + 2);
      if (v17 > 0x40)
      {
        int v178 = llvm::APInt::countTrailingOnesSlowCase(a5);
        if (v178)
        {
          int v196 = 0;
          int64_t v197 = (unint64_t)(v17 + 63) >> 6;
          do
          {
            BOOL v56 = v197-- < 1;
            if (v56) {
              break;
            }
            unint64_t v198 = *(void *)(*(void *)v12 + 8 * v197);
            v196 += __clz(v198);
          }
          while (!v198);
          int v199 = v17 | 0xFFFFFFC0;
          if ((v17 & 0x3F) == 0) {
            int v199 = 0;
          }
          if (v178 + v196 + v199 == v17) {
            goto LABEL_23;
          }
        }
      }
      else
      {
        uint64_t v18 = *(void *)a5;
        if (*(void *)a5 && ((v18 + 1) & v18) == 0)
        {
LABEL_22:
          if (v15 <= 0x40) {
            goto LABEL_71;
          }
LABEL_23:
          if (a6 != (llvm::APInt *)v12)
          {
            uint64_t v26 = a6;
            unsigned int v27 = v17;
LABEL_74:
            llvm::APInt::reallocate((uint64_t)v26, v27);
            uint64_t v46 = *((unsigned int *)a6 + 2);
            if (v46 > 0x40)
            {
              memcpy(*(void **)a6, *(const void **)v12, ((unint64_t)(v46 + 63) >> 3) & 0x3FFFFFF8);
              return;
            }
            unint64_t v156 = *(void *)v12;
            goto LABEL_359;
          }
          return;
        }
      }
      int v179 = *((_DWORD *)v14 + 5);
      if ((v179 & 0x40000000) != 0) {
        unint64_t v180 = (uint64_t *)*((void *)v14 - 1);
      }
      else {
        unint64_t v180 = (uint64_t *)((char *)v14 - 32 * (v179 & 0x7FFFFFF));
      }
      sub_1CBFD2DD4((uint64_t)v203, v15, *v180, v180[4]);
      llvm::DemandedBits::determineLiveOperandBitsSub(a4, a7, a8, v12, (uint64_t)&v201);
      goto LABEL_103;
    case '-':
      uint64_t v34 = *((unsigned int *)a5 + 2);
      if (v34 > 0x40)
      {
        int v54 = 0;
        int64_t v55 = (unint64_t)(v34 + 63) >> 6;
        do
        {
          BOOL v56 = v55-- < 1;
          if (v56) {
            break;
          }
          unint64_t v57 = *(void *)(*(void *)a5 + 8 * v55);
          v54 += __clz(v57);
        }
        while (!v57);
        int v58 = v34 | 0xFFFFFFC0;
        if ((v34 & 0x3F) == 0) {
          int v58 = 0;
        }
        int v35 = v54 + v58;
      }
      else
      {
        int v35 = v34 + __clz(*(void *)a5) - 64;
      }
      LODWORD(v202) = v15;
      if (v15 > 0x40) {
        llvm::APInt::initSlowCase((llvm::APInt *)&v201);
      }
      unint64_t v201 = 0;
      if (v34 == v35) {
        goto LABEL_103;
      }
      a3 = (v34 - v35);
      if (a3 > 0x40) {
        goto LABEL_353;
      }
      LOBYTE(v59) = v35 - v34;
LABEL_100:
      unint64_t v60 = 0xFFFFFFFFFFFFFFFFLL >> v59;
      if (v202 <= 0x40)
      {
        int v40 = (llvm::APInt **)(v201 | v60);
        goto LABEL_102;
      }
      *(void *)v201 |= v60;
      goto LABEL_103;
    case '5':
      if (a4) {
        return;
      }
      unsigned int v200 = 0;
      int v36 = *((_DWORD *)a2 + 5);
      int v37 = (v36 & 0x40000000) != 0
          ? (const llvm::Instruction *)*((void *)a2 - 1)
          : (const llvm::Instruction *)((char *)a2 - 32 * (v36 & 0x7FFFFFF));
      int v104 = (unsigned __int8 *)*((void *)v37 + 4);
      unint64_t v201 = (unint64_t)&v200;
      uint64_t v202 = 0;
      if (!sub_1CBF528D8((uint64_t)&v201, v104)) {
        return;
      }
      BOOL v105 = v200;
      int v106 = v15 - 1;
      uint64_t v107 = *((unsigned int *)v200 + 2);
      if (v107 < 0x41) {
        goto LABEL_192;
      }
      int v108 = 0;
      int64_t v109 = (unint64_t)(v107 + 63) >> 6;
      do
      {
        BOOL v56 = v109-- < 1;
        if (v56) {
          break;
        }
        unint64_t v110 = *(void *)(*(void *)v200 + 8 * v109);
        v108 += __clz(v110);
      }
      while (!v110);
      int v111 = v107 | 0xFFFFFFC0;
      if ((v107 & 0x3F) == 0) {
        int v111 = 0;
      }
      if ((v107 - v108 - v111) <= 0x40)
      {
        BOOL v105 = *(llvm::APInt **)v200;
LABEL_192:
        unint64_t v112 = *(void *)v105;
        if (v112 <= (v15 - 1)) {
          int v106 = v112;
        }
      }
      unsigned int v113 = v12[2];
      LODWORD(v202) = v113;
      if (v113 > 0x40) {
        operator new[]();
      }
      if (v113 == v106) {
        uint64_t v114 = 0;
      }
      else {
        uint64_t v114 = *(void *)v12 >> v106;
      }
      if (*((_DWORD *)a6 + 2) >= 0x41u && *(void *)a6) {
        MEMORY[0x1D25D9CB0](*(void *)a6, 0x1000C8000313F17);
      }
      *(void *)a6 = v114;
      *((_DWORD *)a6 + 2) = v113;
      if ((*((unsigned char *)v204 + 17) & 4) != 0)
      {
        LODWORD(v202) = v15;
        if (v15 > 0x40) {
          llvm::APInt::initSlowCase((llvm::APInt *)&v201);
        }
        unint64_t v201 = 0;
        if (v106 != -1)
        {
          unsigned int v139 = v15 + ~v106;
          if (v139 > 0x3F) {
            llvm::APInt::setBitsSlowCase(&v201, v139, v15);
          }
          else {
            v201 |= 0xFFFFFFFFFFFFFFFFLL >> ~(_BYTE)v106 << v139;
          }
        }
        uint64_t v140 = *((unsigned int *)a6 + 2);
        if (v140 > 0x40)
        {
          uint64_t v141 = 0;
          uint64_t v142 = *(char **)a6;
          unint64_t v143 = v201;
          unint64_t v144 = ((unint64_t)(v140 + 63) >> 3) & 0x3FFFFFF8;
          do
          {
            *(void *)&v142[v141] |= *(void *)(v143 + v141);
            v141 += 8;
          }
          while (v144 != v141);
          return;
        }
      }
      else
      {
        if ((*((unsigned char *)v204 + 17) & 2) == 0) {
          return;
        }
        LODWORD(v202) = v15;
        if (v15 > 0x40) {
          llvm::APInt::initSlowCase((llvm::APInt *)&v201);
        }
        unint64_t v201 = 0;
        if (v106)
        {
          unsigned int v115 = v15 - v106;
          if ((v15 - v106) > 0x3F) {
            llvm::APInt::setBitsSlowCase(&v201, v115, v15);
          }
          else {
            v201 |= 0xFFFFFFFFFFFFFFFFLL >> -(char)v106 << v115;
          }
        }
        uint64_t v116 = *((unsigned int *)a6 + 2);
        if (v116 > 0x40)
        {
          uint64_t v117 = 0;
          BOOL v118 = *(char **)a6;
          unint64_t v119 = v201;
          unint64_t v120 = ((unint64_t)(v116 + 63) >> 3) & 0x3FFFFFF8;
          do
          {
            *(void *)&v118[v117] |= *(void *)(v119 + v117);
            v117 += 8;
          }
          while (v120 != v117);
          return;
        }
      }
      *(void *)a6 |= v201;
      return;
    case '6':
      if (a4) {
        return;
      }
      unsigned int v200 = 0;
      int v24 = *((_DWORD *)a2 + 5);
      int v25 = (v24 & 0x40000000) != 0
          ? (const llvm::Instruction *)*((void *)a2 - 1)
          : (const llvm::Instruction *)((char *)a2 - 32 * (v24 & 0x7FFFFFF));
      BOOL v82 = (unsigned __int8 *)*((void *)v25 + 4);
      unint64_t v201 = (unint64_t)&v200;
      uint64_t v202 = 0;
      if (!sub_1CBF528D8((uint64_t)&v201, v82)) {
        return;
      }
      int v83 = v200;
      unsigned int v84 = v15 - 1;
      uint64_t v85 = *((unsigned int *)v200 + 2);
      if (v85 < 0x41) {
        goto LABEL_162;
      }
      int v86 = 0;
      int64_t v87 = (unint64_t)(v85 + 63) >> 6;
      do
      {
        BOOL v56 = v87-- < 1;
        if (v56) {
          break;
        }
        unint64_t v88 = *(void *)(*(void *)v200 + 8 * v87);
        v86 += __clz(v88);
      }
      while (!v88);
      int v89 = v85 | 0xFFFFFFC0;
      if ((v85 & 0x3F) == 0) {
        int v89 = 0;
      }
      if ((v85 - v86 - v89) <= 0x40)
      {
        int v83 = *(llvm::APInt **)v200;
LABEL_162:
        unint64_t v90 = *(void *)v83;
        if (v90 <= (v15 - 1)) {
          unsigned int v84 = v90;
        }
      }
      unsigned int v91 = v12[2];
      LODWORD(v202) = v91;
      if (v91 > 0x40) {
        operator new[]();
      }
      uint64_t v92 = *(void *)v12 << v84;
      if (v91 == v84) {
        uint64_t v92 = 0;
      }
      if (v91) {
        unint64_t v93 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v91;
      }
      else {
        unint64_t v93 = 0;
      }
      unint64_t v201 = v93 & v92;
      if (*((_DWORD *)a6 + 2) >= 0x41u && *(void *)a6) {
        MEMORY[0x1D25D9CB0](*(void *)a6, 0x1000C8000313F17);
      }
      *(void *)a6 = v201;
      *((_DWORD *)a6 + 2) = v202;
      if ((*((unsigned char *)v204 + 17) & 2) == 0) {
        return;
      }
      LODWORD(v202) = v15;
      if (v15 > 0x40) {
        llvm::APInt::initSlowCase((llvm::APInt *)&v201);
      }
      unint64_t v201 = 0;
      if (v84)
      {
        if (v84 > 0x40)
        {
          llvm::APInt::setBitsSlowCase(&v201, 0, v84);
        }
        else
        {
          unint64_t v133 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v84;
          if (v202 > 0x40) {
            *(void *)v201 |= v133;
          }
          else {
            v201 |= v133;
          }
        }
      }
      uint64_t v134 = *((unsigned int *)a6 + 2);
      if (v134 <= 0x40) {
        goto LABEL_375;
      }
      uint64_t v135 = 0;
      BOOL v136 = *(char **)a6;
      unint64_t v137 = v201;
      unint64_t v138 = ((unint64_t)(v134 + 63) >> 3) & 0x3FFFFFF8;
      do
      {
        *(void *)&v136[v135] |= *(void *)(v137 + v135);
        v135 += 8;
      }
      while (v138 != v135);
      goto LABEL_378;
    case '7':
      if (a4) {
        return;
      }
      unsigned int v200 = 0;
      int v22 = *((_DWORD *)a2 + 5);
      int v23 = (v22 & 0x40000000) != 0
          ? (const llvm::Instruction *)*((void *)a2 - 1)
          : (const llvm::Instruction *)((char *)a2 - 32 * (v22 & 0x7FFFFFF));
      uint64_t v70 = (unsigned __int8 *)*((void *)v23 + 4);
      unint64_t v201 = (unint64_t)&v200;
      uint64_t v202 = 0;
      if (!sub_1CBF528D8((uint64_t)&v201, v70)) {
        return;
      }
      int v71 = v200;
      unint64_t v72 = (v15 - 1);
      uint64_t v73 = *((unsigned int *)v200 + 2);
      if (v73 < 0x41) {
        goto LABEL_143;
      }
      int v74 = 0;
      int64_t v75 = (unint64_t)(v73 + 63) >> 6;
      do
      {
        BOOL v56 = v75-- < 1;
        if (v56) {
          break;
        }
        unint64_t v76 = *(void *)(*(void *)v200 + 8 * v75);
        v74 += __clz(v76);
      }
      while (!v76);
      int v77 = v73 | 0xFFFFFFC0;
      if ((v73 & 0x3F) == 0) {
        int v77 = 0;
      }
      if ((v73 - v74 - v77) <= 0x40)
      {
        int v71 = *(llvm::APInt **)v200;
LABEL_143:
        unint64_t v78 = *(void *)v71;
        if (v78 <= v72) {
          LODWORD(v72) = v78;
        }
      }
      unsigned int v79 = v12[2];
      LODWORD(v202) = v79;
      if (v79 > 0x40) {
        operator new[]();
      }
      uint64_t v80 = *(void *)v12 << v72;
      if (v79 == v72) {
        uint64_t v80 = 0;
      }
      if (v79) {
        unint64_t v81 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v79;
      }
      else {
        unint64_t v81 = 0;
      }
      unint64_t v201 = v81 & v80;
      if (*((_DWORD *)a6 + 2) >= 0x41u && *(void *)a6) {
        MEMORY[0x1D25D9CB0](*(void *)a6, 0x1000C8000313F17);
      }
      *(void *)a6 = v201;
      *((_DWORD *)a6 + 2) = v202;
      LODWORD(v202) = v15;
      if (v15 > 0x40) {
        llvm::APInt::initSlowCase((llvm::APInt *)&v201);
      }
      unint64_t v201 = 0;
      if (!v72) {
        goto LABEL_364;
      }
      unsigned int v131 = v15 - v72;
      if ((v15 - v72) > 0x3F)
      {
        llvm::APInt::setBitsSlowCase(&v201, v131, v15);
LABEL_364:
        unint64_t v132 = v201;
      }
      else
      {
        unint64_t v132 = v201 | (0xFFFFFFFFFFFFFFFFLL >> -(char)v72 << v131);
      }
      if ((v132 & *(void *)v12) != 0)
      {
        unsigned int v188 = *((_DWORD *)a6 + 2);
        uint64_t v189 = 1 << (v188 - 1);
        if (v188 >= 0x41) {
          unsigned int v190 = (llvm::APInt *)(*(void *)a6 + 8 * ((v188 - 1) >> 6));
        }
        else {
          unsigned int v190 = a6;
        }
        *(void *)v190 |= v189;
      }
      if ((*((unsigned char *)v204 + 17) & 2) == 0) {
        return;
      }
      LODWORD(v202) = v15;
      unint64_t v201 = 0;
      if (v72)
      {
        if (v72 > 0x40) {
          llvm::APInt::setBitsSlowCase(&v201, 0, v72);
        }
        else {
          v201 |= 0xFFFFFFFFFFFFFFFFLL >> -(char)v72;
        }
      }
      uint64_t v191 = *((unsigned int *)a6 + 2);
      if (v191 > 0x40)
      {
        uint64_t v192 = 0;
        uint64_t v193 = *(char **)a6;
        unint64_t v137 = v201;
        unint64_t v194 = ((unint64_t)(v191 + 63) >> 3) & 0x3FFFFFF8;
        do
        {
          *(void *)&v193[v192] |= *(void *)(v137 + v192);
          v192 += 8;
        }
        while (v194 != v192);
      }
      else
      {
LABEL_375:
        unint64_t v137 = v201;
        *(void *)a6 |= v201;
      }
LABEL_378:
      if (v202 >= 0x41 && v137 != 0) {
        MEMORY[0x1D25D9CB0](v137, 0x1000C8000313F17);
      }
      return;
    case '8':
      if (v15 > 0x40 || *((_DWORD *)a5 + 2) > 0x40u)
      {
        if (a6 != a5)
        {
          llvm::APInt::reallocate((uint64_t)a6, *((_DWORD *)a5 + 2));
          uint64_t v145 = *((unsigned int *)a6 + 2);
          if (v145 <= 0x40) {
            *(void *)a6 = *(void *)v12;
          }
          else {
            memcpy(*(void **)a6, *(const void **)v12, ((unint64_t)(v145 + 63) >> 3) & 0x3FFFFFF8);
          }
        }
        int v14 = v204;
      }
      else
      {
        *(void *)a6 = *(void *)a5;
        *((_DWORD *)a6 + 2) = *((_DWORD *)a5 + 2);
      }
      int v47 = *((_DWORD *)v14 + 5);
      if ((v47 & 0x40000000) != 0) {
        uint64_t v48 = (uint64_t *)*((void *)v14 - 1);
      }
      else {
        uint64_t v48 = (uint64_t *)((char *)v14 - 32 * (v47 & 0x7FFFFFF));
      }
      sub_1CBFD2DD4((uint64_t)v203, v15, *v48, v48[4]);
      unsigned int v51 = *((_DWORD *)a8 + 2);
      if (a4)
      {
        if (v51 > 0x40) {
          operator new[]();
        }
        unint64_t v52 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v51;
        if (v51) {
          unint64_t v53 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v51;
        }
        else {
          unint64_t v53 = 0;
        }
        if (!v51) {
          unint64_t v52 = 0;
        }
        unint64_t v68 = v52 & ~(*(void *)a7 & v53 & ~*(void *)a8);
        uint64_t v121 = *((unsigned int *)a6 + 2);
        if (v121 > 0x40)
        {
          int v122 = *(void **)a6;
          unint64_t v123 = (unint64_t)(v121 + 63) >> 6;
          uint64_t v124 = (uint64_t *)v68;
          do
          {
            uint64_t v125 = *v124++;
            *v122++ &= v125;
            --v123;
          }
          while (v123);
        }
        else
        {
          *(void *)a6 &= v68;
        }
        return;
      }
      if (v51 > 0x40) {
        operator new[]();
      }
      unint64_t v64 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v51;
      if (!v51) {
        unint64_t v64 = 0;
      }
      unint64_t v65 = v64 & ~*(void *)a8;
      uint64_t v94 = *((unsigned int *)a6 + 2);
      if (v94 > 0x40)
      {
        uint64_t v95 = *(void **)a6;
        unint64_t v96 = (unint64_t)(v94 + 63) >> 6;
        char v97 = (uint64_t *)v65;
        do
        {
          uint64_t v98 = *v97++;
          *v95++ &= v98;
          --v96;
        }
        while (v96);
        return;
      }
      goto LABEL_178;
    case '9':
      if (v15 > 0x40 || *((_DWORD *)a5 + 2) > 0x40u)
      {
        if (a6 != a5)
        {
          llvm::APInt::reallocate((uint64_t)a6, *((_DWORD *)a5 + 2));
          uint64_t v146 = *((unsigned int *)a6 + 2);
          if (v146 <= 0x40) {
            *(void *)a6 = *(void *)v12;
          }
          else {
            memcpy(*(void **)a6, *(const void **)v12, ((unint64_t)(v146 + 63) >> 3) & 0x3FFFFFF8);
          }
        }
        int v14 = v204;
      }
      else
      {
        *(void *)a6 = *(void *)a5;
        *((_DWORD *)a6 + 2) = *((_DWORD *)a5 + 2);
      }
      int v49 = *((_DWORD *)v14 + 5);
      if ((v49 & 0x40000000) != 0) {
        BOOL v50 = (uint64_t *)*((void *)v14 - 1);
      }
      else {
        BOOL v50 = (uint64_t *)((char *)v14 - 32 * (v49 & 0x7FFFFFF));
      }
      sub_1CBFD2DD4((uint64_t)v203, v15, *v50, v50[4]);
      if (a4)
      {
        unsigned int v61 = *((_DWORD *)a8 + 6);
        if (v61 > 0x40) {
          operator new[]();
        }
        unint64_t v62 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v61;
        if (v61) {
          unint64_t v63 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v61;
        }
        else {
          unint64_t v63 = 0;
        }
        if (!v61) {
          unint64_t v62 = 0;
        }
        unint64_t v69 = v62 & ~(*((void *)a7 + 2) & v63 & ~*((void *)a8 + 2));
        uint64_t v126 = *((unsigned int *)a6 + 2);
        if (v126 > 0x40)
        {
          unsigned int v127 = *(void **)a6;
          unint64_t v128 = (unint64_t)(v126 + 63) >> 6;
          BOOL v129 = (uint64_t *)v69;
          do
          {
            uint64_t v130 = *v129++;
            *v127++ &= v130;
            --v128;
          }
          while (v128);
        }
        else
        {
          *(void *)a6 &= v69;
        }
      }
      else
      {
        unsigned int v66 = *((_DWORD *)a8 + 6);
        if (v66 > 0x40) {
          operator new[]();
        }
        unint64_t v67 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v66;
        if (!v66) {
          unint64_t v67 = 0;
        }
        unint64_t v65 = v67 & ~*((void *)a8 + 2);
        uint64_t v99 = *((unsigned int *)a6 + 2);
        if (v99 > 0x40)
        {
          BOOL v100 = *(void **)a6;
          unint64_t v101 = (unint64_t)(v99 + 63) >> 6;
          uint64_t v102 = (uint64_t *)v65;
          do
          {
            uint64_t v103 = *v102++;
            *v100++ &= v103;
            --v101;
          }
          while (v101);
        }
        else
        {
LABEL_178:
          *(void *)a6 &= v65;
        }
      }
      return;
    case ':':
LABEL_68:
      if (v15 <= 0x40 && *((_DWORD *)a5 + 2) <= 0x40u)
      {
        uint64_t v18 = *(void *)a5;
LABEL_71:
        *(void *)a6 = v18;
        int v45 = *((_DWORD *)a5 + 2);
        goto LABEL_107;
      }
      if (a6 == a5) {
        return;
      }
      unsigned int v27 = *((_DWORD *)a5 + 2);
      uint64_t v26 = a6;
      goto LABEL_74;
    case 'B':
      if (v15 <= 0x40) {
        goto LABEL_50;
      }
      if (*((_DWORD *)a5 + 2) != v15) {
        operator new[]();
      }
      goto LABEL_412;
    case 'C':
      unsigned int v21 = *((_DWORD *)a5 + 2);
      if (v15 <= 0x40)
      {
        if (v21 >= 0x41) {
          int v12 = *(unsigned int **)a5;
        }
LABEL_50:
        unint64_t v38 = *(void *)v12;
        LODWORD(v202) = v15;
        unint64_t v39 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v15;
        if (!v15) {
          unint64_t v39 = 0;
        }
        int v40 = (llvm::APInt **)(v39 & v38);
        goto LABEL_102;
      }
      if (v21 != v15) {
        operator new[]();
      }
LABEL_412:
      sub_1CD0463BC((uint64_t)&v201, (uint64_t)a5);
      goto LABEL_103;
    case 'D':
      unsigned int v28 = *((_DWORD *)a5 + 2);
      if (v15 > 0x40)
      {
        if (v28 != v15) {
          operator new[]();
        }
        sub_1CD0463BC((uint64_t)&v201, (uint64_t)a5);
      }
      else
      {
        uint64_t v29 = a5;
        if (v28 >= 0x41) {
          uint64_t v29 = *(const llvm::APInt **)a5;
        }
        uint64_t v30 = *(void *)v29;
        LODWORD(v202) = v15;
        unint64_t v31 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v15;
        if (!v15) {
          unint64_t v31 = 0;
        }
        unint64_t v201 = v31 & v30;
      }
      if (*((_DWORD *)a6 + 2) >= 0x41u && *(void *)a6) {
        MEMORY[0x1D25D9CB0](*(void *)a6, 0x1000C8000313F17);
      }
      *(void *)a6 = v201;
      *((_DWORD *)a6 + 2) = v202;
      unsigned int v32 = v12[2];
      LODWORD(v202) = v32;
      if (v32 > 0x40) {
        llvm::APInt::initSlowCase((llvm::APInt *)&v201);
      }
      unint64_t v201 = 0;
      if (v15 == v32) {
        goto LABEL_355;
      }
      if (v15 > 0x3F)
      {
        llvm::APInt::setBitsSlowCase(&v201, v15, v32);
LABEL_355:
        unint64_t v33 = v201;
      }
      else
      {
        unint64_t v33 = v201 | (0xFFFFFFFFFFFFFFFFLL >> (v15 - v32) << v15);
      }
      if ((v33 & *(void *)v12) == 0) {
        return;
      }
      unsigned int v186 = *((_DWORD *)a6 + 2);
      uint64_t v187 = 1 << (v186 - 1);
      if (v186 <= 0x40)
      {
        unint64_t v156 = *(void *)a6 | v187;
        goto LABEL_359;
      }
      *(void *)(*(void *)a6 + 8 * ((v186 - 1) >> 6)) |= v187;
      return;
    default:
      switch(*((unsigned char *)a2 + 16))
      {
        case 'S':
          goto LABEL_68;
        case 'T':
          uint64_t v41 = *((void *)a2 - 4);
          if (!v41
            || *(unsigned char *)(v41 + 16)
            || *(void *)(v41 + 24) != *((void *)a2 + 9)
            || (*(unsigned char *)(v41 + 33) & 0x20) == 0)
          {
            return;
          }
          int v42 = *(_DWORD *)(v41 + 36);
          if (v42 > 273)
          {
            unsigned int v147 = v42 - 274;
            BOOL v56 = v147 > 0x20;
            uint64_t v148 = (1 << v147) & 0x180000003;
            if (v56 || v148 == 0) {
              return;
            }
            unsigned int v150 = *((_DWORD *)a5 + 2);
            if (v150 > 0x40)
            {
              unsigned int v152 = llvm::APInt::countTrailingZerosSlowCase((unint64_t **)a5);
            }
            else
            {
              unsigned int v151 = __clz(__rbit64(*(void *)a5));
              if (v150 >= v151) {
                unsigned int v152 = v151;
              }
              else {
                unsigned int v152 = *((_DWORD *)a5 + 2);
              }
            }
            LODWORD(v202) = v15;
            if (v15 > 0x40) {
              llvm::APInt::initSlowCase((llvm::APInt *)&v201);
            }
            unint64_t v201 = 0;
            if (v152 == v15) {
              goto LABEL_278;
            }
            if (v152 <= 0x3F)
            {
              unint64_t v157 = 0xFFFFFFFFFFFFFFFFLL >> (v152 - v15) << v152;
LABEL_277:
              v201 |= v157;
              goto LABEL_278;
            }
            unsigned int v172 = v152;
            goto LABEL_406;
          }
          if (v42 <= 53)
          {
            if (v42 == 8)
            {
              llvm::APInt::reverseBits((unsigned int *)a5, (llvm::APInt *)&v201);
              goto LABEL_103;
            }
            if (v42 == 9)
            {
              llvm::APInt::byteSwap(a5, (uint64_t)&v201);
              goto LABEL_103;
            }
            if (v42 != 52 || a4) {
              return;
            }
            sub_1CBFD2DD4((uint64_t)v203, v15, a3, 0);
            uint64_t v43 = *((unsigned int *)a7 + 6);
            if (v43 > 0x40)
            {
              int v167 = 0;
              int64_t v168 = (unint64_t)(v43 + 63) >> 6;
              do
              {
                BOOL v56 = v168-- < 1;
                if (v56) {
                  break;
                }
                unint64_t v169 = *(void *)(*((void *)a7 + 2) + 8 * v168);
                v167 += __clz(v169);
              }
              while (!v169);
              if ((v43 & 0x3F) != 0) {
                int v170 = v43 | 0xFFFFFFC0;
              }
              else {
                int v170 = 0;
              }
              int v44 = v167 + v170;
            }
            else
            {
              int v44 = v43 + __clz(*((void *)a7 + 2)) - 64;
            }
            if (v44 + 1 < v15) {
              int v171 = v44 + 1;
            }
            else {
              int v171 = v15;
            }
            LODWORD(v202) = v15;
            if (v15 > 0x40) {
              llvm::APInt::initSlowCase((llvm::APInt *)&v201);
            }
            unint64_t v201 = 0;
            if (!v171)
            {
LABEL_278:
              if (*((_DWORD *)a6 + 2) >= 0x41u && *(void *)a6) {
                MEMORY[0x1D25D9CB0](*(void *)a6, 0x1000C8000313F17, a3);
              }
              *(void *)a6 = v201;
              *((_DWORD *)a6 + 2) = v15;
              return;
            }
            unsigned int v172 = v15 - v171;
            if ((v15 - v171) <= 0x3F)
            {
              unint64_t v157 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v171 << v172;
              goto LABEL_277;
            }
LABEL_406:
            llvm::APInt::setBitsSlowCase(&v201, v172, v15);
            goto LABEL_278;
          }
          if ((v42 - 148) >= 2)
          {
            if (v42 != 54 || a4) {
              return;
            }
            sub_1CBFD2DD4((uint64_t)v203, v15, a3, 0);
            int v158 = (unint64_t **)((char *)a7 + 16);
            unsigned int v159 = *((_DWORD *)a7 + 6);
            if (v159 > 0x40)
            {
              int v161 = llvm::APInt::countTrailingZerosSlowCase(v158);
            }
            else
            {
              unsigned int v160 = __clz(__rbit64((unint64_t)*v158));
              if (v159 >= v160) {
                int v161 = v160;
              }
              else {
                int v161 = *((_DWORD *)a7 + 6);
              }
            }
            if (v161 + 1 < v15) {
              unsigned int v173 = v161 + 1;
            }
            else {
              unsigned int v173 = v15;
            }
            LODWORD(v202) = v15;
            if (v15 > 0x40) {
              llvm::APInt::initSlowCase((llvm::APInt *)&v201);
            }
            unint64_t v201 = 0;
            if (v173)
            {
              if (v173 <= 0x40)
              {
                int v59 = -v173;
                goto LABEL_100;
              }
              LODWORD(a3) = v173;
LABEL_353:
              llvm::APInt::setBitsSlowCase(&v201, 0, a3);
            }
          }
          else
          {
            unsigned int v200 = 0;
            if (a4 == 2)
            {
              a9.i32[0] = v15;
              uint8x8_t v153 = (uint8x8_t)vcnt_s8(a9);
              v153.i16[0] = vaddlv_u8(v153);
              if (v153.i32[0] != 1) {
                return;
              }
              uint64_t v154 = (v15 - 1);
              if (v15 > 0x40)
              {
                **(void **)a6 = v154;
                bzero((void *)(*(void *)a6 + 8), (((v15 + 63) >> 3) - 8) & 0xFFFFFFF8);
                return;
              }
              unint64_t v155 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v15;
              if (!v15) {
                unint64_t v155 = 0;
              }
              unint64_t v156 = v155 & v154;
LABEL_359:
              *(void *)a6 = v156;
              return;
            }
            int v162 = (unsigned __int8 *)((void *)a2 - 4 * (*((_DWORD *)a2 + 5) & 0x7FFFFFF))[8];
            unint64_t v201 = (unint64_t)&v200;
            uint64_t v202 = 0;
            if (!sub_1CBF528D8((uint64_t)&v201, v162)) {
              return;
            }
            int v163 = llvm::APInt::urem((uint64_t **)v200, v15);
            if (*(_DWORD *)(*((void *)v14 - 4) + 36) == 149) {
              int v164 = v15 - v163;
            }
            else {
              int v164 = v163;
            }
            if (a4 != 1)
            {
              if (!a4)
              {
                unsigned int v165 = v12[2];
                LODWORD(v202) = v165;
                if (v165 > 0x40) {
                  operator new[]();
                }
                if (v165 == v164) {
                  uint64_t v166 = 0;
                }
                else {
                  uint64_t v166 = *(void *)v12 >> v164;
                }
                if (*((_DWORD *)a6 + 2) >= 0x41u && *(void *)a6) {
                  MEMORY[0x1D25D9CB0](*(void *)a6, 0x1000C8000313F17);
                }
                *(void *)a6 = v166;
                *((_DWORD *)a6 + 2) = v165;
              }
              return;
            }
            int v174 = v15 - v164;
            unsigned int v175 = v12[2];
            LODWORD(v202) = v175;
            if (v175 > 0x40) {
              operator new[]();
            }
            uint64_t v176 = *(void *)v12 << v174;
            if (v175 == v174) {
              uint64_t v176 = 0;
            }
            if (v175) {
              unint64_t v177 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v175;
            }
            else {
              unint64_t v177 = 0;
            }
            int v40 = (llvm::APInt **)(v177 & v176);
LABEL_102:
            unint64_t v201 = (unint64_t)v40;
          }
LABEL_103:
          if (*((_DWORD *)a6 + 2) >= 0x41u)
          {
            if (*(void *)a6) {
              MEMORY[0x1D25D9CB0](*(void *)a6, 0x1000C8000313F17, a3);
            }
          }
          *(void *)a6 = v201;
          int v45 = v202;
LABEL_107:
          *((_DWORD *)a6 + 2) = v45;
          return;
        case 'U':
          if (a4) {
            goto LABEL_68;
          }
          return;
        case 'Y':
          if (!a4) {
            goto LABEL_68;
          }
          return;
        case 'Z':
        case '[':
          if (a4 <= 1) {
            goto LABEL_68;
          }
          return;
        default:
          return;
      }
  }
}

void sub_1CBFD2DD4(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  if (!**(unsigned char **)a1)
  {
    uint64_t v8 = *(void *)(a1 + 24);
    **(unsigned char **)a1 = 1;
    uint64_t v9 = *(void *)(*(void *)(*(void *)(**(void **)(a1 + 8) + 40) + 56) + 40);
    LODWORD(v26) = a2;
    if (a2 > 0x40) {
      llvm::APInt::initSlowCase((llvm::APInt *)&v25);
    }
    LODWORD(v28) = a2;
    int v25 = 0;
    uint64_t v27 = 0;
    uint64_t v10 = *(void *)(a1 + 16);
    if (*(_DWORD *)(v10 + 8) >= 0x41u && *(void *)v10)
    {
      uint64_t v21 = *(void *)(a1 + 16);
      MEMORY[0x1D25D9CB0](*(void *)v10, 0x1000C8000313F17);
      uint64_t v10 = v21;
    }
    BOOL v11 = (const llvm::DataLayout *)(v9 + 272);
    *(void *)uint64_t v10 = v25;
    *(_DWORD *)(v10 + 8) = v26;
    if (*(_DWORD *)(v10 + 24) >= 0x41u)
    {
      uint64_t v22 = *(void *)(v10 + 16);
      if (v22)
      {
        uint64_t v23 = v10;
        MEMORY[0x1D25D9CB0](v22, 0x1000C8000313F17);
        uint64_t v10 = v23;
      }
    }
    *(void *)(v10 + 16) = v27;
    *(_DWORD *)(v10 + 24) = v28;
    int v12 = *(int8x8_t **)(a1 + 16);
    uint64_t v13 = **(void **)(a1 + 8);
    uint64_t v15 = *(void *)(v8 + 8);
    uint64_t v14 = *(void *)(v8 + 16);
    if (!v13 || !*(void *)(v13 + 40))
    {
      if (!a3 || *(unsigned __int8 *)(a3 + 16) < 0x1Cu || (uint64_t v13 = a3, !*(void *)(a3 + 40))) {
        uint64_t v13 = 0;
      }
    }
    int v25 = v11;
    uint64_t v26 = v15;
    uint64_t v27 = v13;
    uint64_t v28 = v14;
    uint64_t v29 = 0;
    char v30 = 1;
    sub_1CC15FBF8(a3, v12, 0, &v25);
    if (a4)
    {
      LODWORD(v26) = a2;
      if (a2 > 0x40) {
        llvm::APInt::initSlowCase((llvm::APInt *)&v25);
      }
      LODWORD(v28) = a2;
      int v25 = 0;
      uint64_t v27 = 0;
      uint64_t v16 = *(void *)(a1 + 32);
      if (*(_DWORD *)(v16 + 8) >= 0x41u && *(void *)v16) {
        MEMORY[0x1D25D9CB0](*(void *)v16, 0x1000C8000313F17);
      }
      *(void *)uint64_t v16 = v25;
      *(_DWORD *)(v16 + 8) = v26;
      if (*(_DWORD *)(v16 + 24) >= 0x41u)
      {
        uint64_t v24 = *(void *)(v16 + 16);
        if (v24) {
          MEMORY[0x1D25D9CB0](v24, 0x1000C8000313F17);
        }
      }
      *(void *)(v16 + 16) = v27;
      *(_DWORD *)(v16 + 24) = v28;
      uint64_t v17 = *(int8x8_t **)(a1 + 32);
      uint64_t v18 = **(void **)(a1 + 8);
      uint64_t v20 = *(void *)(v8 + 8);
      uint64_t v19 = *(void *)(v8 + 16);
      if (!v18 || !*(void *)(v18 + 40))
      {
        if (*(unsigned __int8 *)(a4 + 16) < 0x1Cu || (uint64_t v18 = a4, !*(void *)(a4 + 40))) {
          uint64_t v18 = 0;
        }
      }
      int v25 = v11;
      uint64_t v26 = v20;
      uint64_t v27 = v18;
      uint64_t v28 = v19;
      uint64_t v29 = 0;
      char v30 = 1;
      sub_1CC15FBF8(a4, v17, 0, &v25);
    }
  }
}

uint64_t llvm::DemandedBits::determineLiveOperandBitsAdd@<X0>(llvm::DemandedBits *this@<X0>, const llvm::APInt *a2@<X2>, const llvm::KnownBits *a3@<X3>, unsigned int *a4@<X1>, uint64_t a5@<X8>)
{
  return sub_1CBFD4900(a5, (int)this, a4, (uint64_t)a2, (uint64_t)a3, 1, 0);
}

void llvm::DemandedBits::performAnalysis(llvm::DemandedBits *this)
{
  v194[16] = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)this + 24)) {
    return;
  }
  uint64_t v2 = (void *)*((void *)this + 4);
  *((unsigned char *)this + 24) = 1;
  int v171 = (void **)((char *)this + 32);
  uint64_t v3 = (void *)*((void *)this + 5);
  if (v3 != v2)
  {
    uint64_t v145 = *((unsigned int *)this + 12);
    if (v145 >= 0x21 && 4 * (*((_DWORD *)this + 13) - *((_DWORD *)this + 14)) < v145)
    {
      llvm::SmallPtrSetImplBase::shrink_and_clear(v171);
      goto LABEL_5;
    }
    memset(v3, 255, 8 * v145);
  }
  *((_DWORD *)this + 13) = 0;
  *((_DWORD *)this + 14) = 0;
LABEL_5:
  int v4 = *((_DWORD *)this + 82);
  if (v4 || *((_DWORD *)this + 83))
  {
    uint64_t v166 = *((unsigned int *)this + 84);
    if (v166 > 4 * v4 && v166 >= 0x41)
    {
      sub_1CD478D54((_DWORD *)this + 80);
      goto LABEL_7;
    }
    if (!v166)
    {
LABEL_348:
      *((void *)this + 4sub_1CD456CB4((void *)this + 1) = 0;
      goto LABEL_7;
    }
    uint64_t v167 = *((void *)this + 40);
    uint64_t v168 = 24 * v166;
    while (1)
    {
      if (*(void *)v167 == -8192) {
        goto LABEL_346;
      }
      if (*(void *)v167 != -4096) {
        break;
      }
LABEL_347:
      v167 += 24;
      v168 -= 24;
      if (!v168) {
        goto LABEL_348;
      }
    }
    if (*(_DWORD *)(v167 + 16) >= 0x41u)
    {
      uint64_t v169 = *(void *)(v167 + 8);
      if (v169) {
        MEMORY[0x1D25D9CB0](v169, 0x1000C8000313F17);
      }
    }
LABEL_346:
    *(void *)uint64_t v167 = -4096;
    goto LABEL_347;
  }
LABEL_7:
  int v170 = (void **)((char *)this + 344);
  BOOL v5 = (void *)*((void *)this + 44);
  if (v5 != *((void **)this + 43))
  {
    uint64_t v147 = *((unsigned int *)this + 90);
    if (v147 >= 0x21 && 4 * (*((_DWORD *)this + 91) - *((_DWORD *)this + 92)) < v147)
    {
      llvm::SmallPtrSetImplBase::shrink_and_clear(v170);
      goto LABEL_9;
    }
    memset(v5, 255, 8 * v147);
  }
  *(void *)((char *)this + 364) = 0;
LABEL_9:
  uint64_t v189 = 1;
  uint64_t v6 = 8;
  int64x2_t v7 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  do
  {
    *(int64x2_t *)((char *)&v189 + v6) = v7;
    v6 += 16;
  }
  while (v6 != 136);
  uint64_t v192 = v194;
  uint64_t v193 = 0x1000000000;
  uint64_t v8 = *(void *)this + 72;
  for (uint64_t i = *(void *)(*(void *)this + 80); ; uint64_t i = *(void *)(i + 8))
  {
    if (i == v8) {
      goto LABEL_266;
    }
    uint64_t v10 = i - 24;
    if (!i) {
      uint64_t v10 = 0;
    }
    uint64_t v11 = *(void *)(v10 + 48);
    if (v11 != v10 + 40) {
      break;
    }
  }
  while (1)
  {
    if (v11) {
      uint64_t v12 = v11 - 24;
    }
    else {
      uint64_t v12 = 0;
    }
    if (!sub_1CBFD41B0((unsigned __int8 *)v12)) {
      goto LABEL_20;
    }
    uint64_t v14 = *(void *)v12;
    if ((*(_DWORD *)(*(void *)v12 + 8) & 0xFE) == 0x12)
    {
      uint64_t v14 = **(void **)(v14 + 16);
      int v15 = *(unsigned __int8 *)(v14 + 8);
    }
    else
    {
      int v15 = *(_DWORD *)(*(void *)v12 + 8);
    }
    if (v15 != 13)
    {
      int v16 = *(_DWORD *)(v12 + 20);
      if ((v16 & 0x40000000) != 0)
      {
        uint64_t v18 = *(uint64_t **)(v12 - 8);
        uint64_t v17 = v16 & 0x7FFFFFF;
      }
      else
      {
        uint64_t v17 = v16 & 0x7FFFFFF;
        uint64_t v18 = (uint64_t *)(v12 - 32 * v17);
      }
      if (!v17) {
        goto LABEL_20;
      }
      uint64_t v19 = &v18[4 * v17];
      while (1)
      {
        uint64_t v178 = 0;
        if (*(unsigned __int8 *)(*v18 + 16) <= 0x1Bu) {
          uint64_t v20 = 0;
        }
        else {
          uint64_t v20 = *v18;
        }
        uint64_t v178 = v20;
        if (!v20) {
          goto LABEL_36;
        }
        uint64_t v21 = *(void *)v20;
        if ((*(_DWORD *)(*(void *)v20 + 8) & 0xFE) == 0x12)
        {
          uint64_t v21 = **(void **)(v21 + 16);
          int v22 = *(unsigned __int8 *)(v21 + 8);
        }
        else
        {
          int v22 = *(_DWORD *)(*(void *)v20 + 8);
        }
        if (v22 == 13)
        {
          unsigned int PrimitiveSizeInBits = llvm::Type::getPrimitiveSizeInBits((llvm::Type *)v21);
          unsigned int v183 = PrimitiveSizeInBits;
          if (PrimitiveSizeInBits > 0x40) {
            llvm::APInt::initSlowCase((llvm::APInt *)&v182);
          }
          if (PrimitiveSizeInBits) {
            char v30 = (void *)(0xFFFFFFFFFFFFFFFFLL >> -(char)PrimitiveSizeInBits);
          }
          else {
            char v30 = 0;
          }
          int v182 = v30;
          unint64_t v31 = sub_1CBFD601C((uint64_t)this + 320, &v178);
          unsigned int v32 = v31;
          if (*((_DWORD *)v31 + 4) >= 0x41u)
          {
            uint64_t v165 = v31[1];
            if (v165) {
              MEMORY[0x1D25D9CB0](v165, 0x1000C8000313F17);
            }
          }
          v32[1] = v182;
          *((_DWORD *)v32 + 4) = v183;
        }
        else
        {
          uint64_t v23 = *((void *)this + 5);
          uint64_t v24 = *((unsigned int *)this + 13);
          if (v23 != *((void *)this + 4))
          {
            unsigned int v28 = *((_DWORD *)this + 12);
LABEL_75:
            if (3 * v28 <= 4 * ((int)v24 - *((_DWORD *)this + 14)))
            {
              if (v28 >= 0x40) {
                v28 *= 2;
              }
              else {
                unsigned int v28 = 128;
              }
            }
            else if (v28 - v24 >= v28 >> 3)
            {
              goto LABEL_77;
            }
            llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)v171, v28);
            unsigned int v28 = *((_DWORD *)this + 12);
            uint64_t v23 = *((void *)this + 5);
LABEL_77:
            unsigned int v45 = v28 - 1;
            unsigned int v46 = (v28 - 1) & ((v20 >> 4) ^ (v20 >> 9));
            int v47 = (uint64_t *)(v23 + 8 * v46);
            uint64_t v48 = *v47;
            if (*v47 == -1)
            {
              int v49 = 0;
LABEL_87:
              if (v49) {
                unint64_t v53 = v49;
              }
              else {
                unint64_t v53 = v47;
              }
              if (*v53 != v20)
              {
                if (*v53 == -2) {
                  --*((_DWORD *)this + 14);
                }
                else {
                  ++*((_DWORD *)this + 13);
                }
                *unint64_t v53 = v20;
              }
            }
            else
            {
              int v49 = 0;
              int v50 = 1;
              while (v48 != v20)
              {
                if (v49) {
                  BOOL v51 = 0;
                }
                else {
                  BOOL v51 = v48 == -2;
                }
                if (v51) {
                  int v49 = v47;
                }
                unsigned int v52 = v46 + v50++;
                unsigned int v46 = v52 & v45;
                int v47 = (uint64_t *)(v23 + 8 * (v52 & v45));
                uint64_t v48 = *v47;
                if (*v47 == -1) {
                  goto LABEL_87;
                }
              }
            }
            goto LABEL_56;
          }
          if (v24)
          {
            int v25 = 0;
            uint64_t v26 = 8 * v24;
            uint64_t v27 = (uint64_t *)*((void *)this + 5);
            while (*v27 != v20)
            {
              if (*v27 == -2) {
                int v25 = v27;
              }
              ++v27;
              v26 -= 8;
              if (!v26)
              {
                if (!v25) {
                  goto LABEL_49;
                }
                uint64_t *v25 = v20;
                --*((_DWORD *)this + 14);
                goto LABEL_56;
              }
            }
            goto LABEL_56;
          }
LABEL_49:
          unsigned int v28 = *((_DWORD *)this + 12);
          if (v24 >= v28) {
            goto LABEL_75;
          }
          *((_DWORD *)this + 13) = v24 + 1;
          *(void *)(v23 + 8 * v24) = v20;
        }
LABEL_56:
        if (v189)
        {
          int v33 = 16;
          uint64_t v34 = &v190;
        }
        else
        {
          int v33 = v191;
          if (!v191)
          {
            uint64_t v43 = 0;
LABEL_72:
            int v44 = sub_1CBFD5BBC((uint64_t)&v189, (uint64_t)&v178, &v178, v43);
            *int v44 = v178;
            if (v193 >= (unint64_t)HIDWORD(v193)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((void *)v192 + v193) = v178;
            LODWORD(v193) = v193 + 1;
            goto LABEL_36;
          }
          uint64_t v34 = v190;
        }
        int v35 = v33 - 1;
        unsigned int v36 = ((v178 >> 4) ^ (v178 >> 9)) & v35;
        int v37 = &v34[v36];
        uint64_t v38 = *v37;
        if (v178 != *v37)
        {
          unint64_t v39 = 0;
          int v40 = 1;
          while (v38 != -4096)
          {
            if (v39) {
              BOOL v41 = 0;
            }
            else {
              BOOL v41 = v38 == -8192;
            }
            if (v41) {
              unint64_t v39 = v37;
            }
            unsigned int v42 = v36 + v40++;
            unsigned int v36 = v42 & v35;
            int v37 = &v34[v36];
            uint64_t v38 = *v37;
            if (v178 == *v37) {
              goto LABEL_36;
            }
          }
          if (v39) {
            uint64_t v43 = v39;
          }
          else {
            uint64_t v43 = v37;
          }
          goto LABEL_72;
        }
LABEL_36:
        v18 += 4;
        if (v18 == v19) {
          goto LABEL_20;
        }
      }
    }
    uint64_t v178 = v12;
    unsigned int v148 = llvm::Type::getPrimitiveSizeInBits((llvm::Type *)v14);
    int v182 = 0;
    if (sub_1CBFD5918(*((void *)this + 40), *((_DWORD *)this + 84), v12, &v182)) {
      goto LABEL_20;
    }
    uint64_t v149 = sub_1CBFD59A4((uint64_t)this + 320, &v178, v182);
    void *v149 = v178;
    unsigned int v150 = (llvm::APInt *)(v149 + 1);
    *((_DWORD *)v149 + 4) = v148;
    if (v148 > 0x40) {
      llvm::APInt::initSlowCase(v150);
    }
    *(void *)unsigned int v150 = 0;
    int v182 = (void *)v12;
    if (v189)
    {
      int v151 = 16;
      unsigned int v152 = &v190;
      goto LABEL_285;
    }
    int v151 = v191;
    if (v191)
    {
      unsigned int v152 = v190;
LABEL_285:
      int v153 = v151 - 1;
      unsigned int v59 = v153 & ((v12 >> 4) ^ (v12 >> 9));
      unint64_t v60 = &v152[v59];
      uint64_t v61 = *v60;
      if (v12 == *v60) {
        goto LABEL_20;
      }
      BOOL v56 = 0;
      int v58 = 1;
      while (v61 != -4096)
      {
        if (v56) {
          BOOL v55 = 0;
        }
        else {
          BOOL v55 = v61 == -8192;
        }
        if (v55) {
          BOOL v56 = v60;
        }
        unsigned int v57 = v59 + v58++;
        unsigned int v59 = v57 & v153;
        unint64_t v60 = &v152[v59];
        uint64_t v61 = *v60;
        if (v12 == *v60) {
          goto LABEL_20;
        }
      }
      if (v56) {
        uint64_t v154 = v56;
      }
      else {
        uint64_t v154 = v60;
      }
      goto LABEL_296;
    }
    uint64_t v154 = 0;
LABEL_296:
    unint64_t v155 = sub_1CBFD5BBC((uint64_t)&v189, (uint64_t)&v182, &v182, v154);
    *unint64_t v155 = v182;
    if (v193 >= (unint64_t)HIDWORD(v193)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)v192 + v193) = v182;
    LODWORD(v193) = v193 + 1;
LABEL_20:
    uint64_t v11 = *(void *)(v11 + 8);
    uint64_t v13 = i - 24;
    if (!i) {
      uint64_t v13 = 0;
    }
    if (v11 == v13 + 40) {
      break;
    }
LABEL_23:
    if (i == v8) {
      goto LABEL_113;
    }
  }
  while (1)
  {
    uint64_t i = *(void *)(i + 8);
    if (i == v8) {
      break;
    }
    uint64_t v54 = i - 24;
    if (!i) {
      uint64_t v54 = 0;
    }
    uint64_t v11 = *(void *)(v54 + 48);
    if (v11 != v54 + 40) {
      goto LABEL_23;
    }
  }
LABEL_113:
  uint64_t v62 = v193;
  if (!v193) {
    goto LABEL_266;
  }
  while (2)
  {
    unint64_t v63 = (char *)v192 + 8 * v62;
    unint64_t v64 = (llvm::Instruction *)*((void *)v63 - 1);
    sub_1CBFD6090((uint64_t)&v189, (void *)v63 - 1);
    LODWORD(v193) = v193 - 1;
    unsigned int v188 = v64;
    unsigned int v187 = 1;
    uint64_t v186 = 0;
    if ((*(_DWORD *)(*(void *)v64 + 8) & 0xFE) == 0x12) {
      int v65 = *(unsigned __int8 *)(**(void **)(*(void *)v64 + 16) + 8);
    }
    else {
      int v65 = *(_DWORD *)(*(void *)v64 + 8);
    }
    if (v65 != 13) {
      goto LABEL_121;
    }
    unsigned int v66 = sub_1CBFD601C((uint64_t)this + 320, (uint64_t *)&v188);
    unint64_t v67 = (const llvm::APInt *)(v66 + 1);
    if (v187 <= 0x40)
    {
      unsigned int v68 = *((_DWORD *)v66 + 4);
      if (v68 <= 0x40)
      {
        uint64_t v69 = *(void *)v67;
        uint64_t v186 = *(void *)v67;
        unsigned int v187 = v68;
        goto LABEL_120;
      }
    }
    llvm::APInt::assignSlowCase((const llvm::APInt *)&v186, v67);
    unsigned int v156 = v187;
    if (v187 <= 0x40)
    {
      uint64_t v69 = v186;
LABEL_120:
      if (v69) {
        goto LABEL_121;
      }
LABEL_313:
      int v70 = sub_1CBFD41B0((unsigned __int8 *)v64) ^ 1;
    }
    else
    {
      if (llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v186) == v156) {
        goto LABEL_313;
      }
LABEL_121:
      int v70 = 0;
    }
    unsigned int v183 = 1;
    int v182 = 0;
    unsigned int v185 = 1;
    uint64_t v184 = 0;
    unsigned int v179 = 1;
    uint64_t v178 = 0;
    unsigned int v181 = 1;
    uint64_t v180 = 0;
    BOOL v177 = 0;
    int v71 = *((_DWORD *)v64 + 5);
    if ((v71 & 0x40000000) != 0)
    {
      uint64_t v73 = (uint64_t *)*((void *)v64 - 1);
      uint64_t v72 = v71 & 0x7FFFFFF;
    }
    else
    {
      uint64_t v72 = v71 & 0x7FFFFFF;
      uint64_t v73 = (uint64_t *)((char *)v64 - 32 * v72);
    }
    int v74 = &v73[4 * v72];
    if (!v72) {
      goto LABEL_249;
    }
    while (2)
    {
      uint64_t v176 = 0;
      if (*(unsigned __int8 *)(*v73 + 16) <= 0x1Bu) {
        uint64_t v100 = 0;
      }
      else {
        uint64_t v100 = *v73;
      }
      uint64_t v176 = v100;
      unint64_t v101 = (unsigned char *)*v73;
      if (!v100 && v101[16] != 21) {
        goto LABEL_247;
      }
      uint64_t v86 = *(void *)v101;
      int v87 = *(_DWORD *)(*(void *)v101 + 8);
      if ((v87 & 0xFE) == 0x12)
      {
        uint64_t v86 = **(void **)(v86 + 16);
        int v87 = *(unsigned __int8 *)(v86 + 8);
      }
      else
      {
        int v87 = v87;
      }
      if (v87 != 13)
      {
        if (!v100) {
          goto LABEL_247;
        }
        uint64_t v128 = *((void *)this + 5);
        uint64_t v129 = *((unsigned int *)this + 13);
        if (v128 == *((void *)this + 4))
        {
          if (v129)
          {
            uint64_t v130 = 0;
            uint64_t v131 = 8 * v129;
            unint64_t v132 = (uint64_t *)*((void *)this + 5);
            while (*v132 != v100)
            {
              if (*v132 == -2) {
                uint64_t v130 = v132;
              }
              ++v132;
              v131 -= 8;
              if (!v131)
              {
                if (!v130) {
                  goto LABEL_226;
                }
                uint64_t *v130 = v100;
                --*((_DWORD *)this + 14);
                goto LABEL_228;
              }
            }
            goto LABEL_247;
          }
LABEL_226:
          unsigned int v98 = *((_DWORD *)this + 12);
          if (v129 < v98)
          {
            *((_DWORD *)this + 13) = v129 + 1;
            *(void *)(v128 + 8 * v129) = v100;
            goto LABEL_228;
          }
        }
        else
        {
          unsigned int v98 = *((_DWORD *)this + 12);
        }
        if (3 * v98 <= 4 * ((int)v129 - *((_DWORD *)this + 14)))
        {
          if (v98 >= 0x40) {
            v98 *= 2;
          }
          else {
            unsigned int v98 = 128;
          }
        }
        else if (v98 - v129 >= v98 >> 3)
        {
LABEL_169:
          unsigned int v99 = v98 - 1;
          unsigned int v94 = (v98 - 1) & ((v100 >> 4) ^ (v100 >> 9));
          uint64_t v95 = (uint64_t *)(v128 + 8 * v94);
          uint64_t v96 = *v95;
          if (*v95 != -1)
          {
            unsigned int v91 = 0;
            int v93 = 1;
            while (v96 != v100)
            {
              if (v91) {
                BOOL v90 = 0;
              }
              else {
                BOOL v90 = v96 == -2;
              }
              if (v90) {
                unsigned int v91 = v95;
              }
              unsigned int v92 = v94 + v93++;
              unsigned int v94 = v92 & v99;
              uint64_t v95 = (uint64_t *)(v128 + 8 * (v92 & v99));
              uint64_t v96 = *v95;
              if (*v95 == -1) {
                goto LABEL_159;
              }
            }
            goto LABEL_247;
          }
          unsigned int v91 = 0;
LABEL_159:
          if (v91) {
            char v97 = v91;
          }
          else {
            char v97 = v95;
          }
          if (*v97 == v100) {
            goto LABEL_247;
          }
          if (*v97 == -2) {
            --*((_DWORD *)this + 14);
          }
          else {
            ++*((_DWORD *)this + 13);
          }
          uint64_t *v97 = v100;
LABEL_228:
          if (v189)
          {
            int v133 = 16;
            uint64_t v134 = &v190;
          }
          else
          {
            int v133 = v191;
            if (!v191)
            {
              unint64_t v88 = 0;
LABEL_149:
              int v89 = sub_1CBFD5BBC((uint64_t)&v189, (uint64_t)&v176, &v176, v88);
              void *v89 = v176;
              if (v193 >= (unint64_t)HIDWORD(v193)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((void *)v192 + v193) = v176;
              LODWORD(v193) = v193 + 1;
              goto LABEL_247;
            }
            uint64_t v134 = v190;
          }
          int v135 = v133 - 1;
          unsigned int v136 = ((v176 >> 4) ^ (v176 >> 9)) & v135;
          unint64_t v137 = &v134[v136];
          uint64_t v138 = *v137;
          if (v176 == *v137) {
            goto LABEL_247;
          }
          unsigned int v139 = 0;
          int v140 = 1;
          while (v138 != -4096)
          {
            if (v139) {
              BOOL v141 = 0;
            }
            else {
              BOOL v141 = v138 == -8192;
            }
            if (v141) {
              unsigned int v139 = v137;
            }
            unsigned int v142 = v136 + v140++;
            unsigned int v136 = v142 & v135;
            unint64_t v137 = &v134[v136];
            uint64_t v138 = *v137;
            if (v176 == *v137) {
              goto LABEL_247;
            }
          }
          if (v139) {
            unint64_t v88 = v139;
          }
          else {
            unint64_t v88 = v137;
          }
          goto LABEL_149;
        }
        llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)v171, v98);
        unsigned int v98 = *((_DWORD *)this + 12);
        uint64_t v128 = *((void *)this + 5);
        goto LABEL_169;
      }
      unsigned int v102 = llvm::Type::getPrimitiveSizeInBits((llvm::Type *)v86);
      unsigned int v175 = v102;
      if (v102 > 0x40) {
        llvm::APInt::initSlowCase((llvm::APInt *)&v174);
      }
      unint64_t v104 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v102;
      if (!v102) {
        unint64_t v104 = 0;
      }
      unint64_t v174 = v104;
      if (v70)
      {
        sub_1CB8F1EEC((uint64_t)&v172, v102, 0);
        if (v175 >= 0x41 && v174) {
          MEMORY[0x1D25D9CB0](v174, 0x1000C8000313F17);
        }
        unint64_t v174 = (unint64_t)v172;
        unsigned int v175 = v173;
      }
      else
      {
        uint64_t v105 = v73[3];
        int v106 = *(_DWORD *)(v105 + 20);
        if ((v106 & 0x40000000) != 0) {
          uint64_t v107 = *(void *)(v105 - 8);
        }
        else {
          uint64_t v107 = v105 - 32 * (v106 & 0x7FFFFFF);
        }
        llvm::DemandedBits::determineLiveOperandBits(this, v188, *v73, (llvm::DemandedBits *)(((unint64_t)v73 - v107) >> 5), (const llvm::APInt *)&v186, (llvm::APInt *)&v174, (llvm::KnownBits *)&v182, (llvm::KnownBits *)&v178, v103, &v177);
        unsigned int v108 = v175;
        if (v175 > 0x40)
        {
          if (llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v174) == v108) {
            goto LABEL_315;
          }
LABEL_187:
          uint64_t v110 = *((void *)this + 43);
          uint64_t v109 = *((void *)this + 44);
          if (v109 == v110)
          {
            uint64_t v111 = *((unsigned int *)this + 91);
            uint64_t v80 = (uint64_t **)(v109 + 8 * v111);
            if (v111)
            {
              uint64_t v112 = 0;
              uint64_t v113 = 8 * v111;
              while (*(uint64_t **)(v109 + v112) != v73)
              {
                v112 += 8;
                if (v113 == v112) {
                  goto LABEL_192;
                }
              }
              uint64_t v80 = (uint64_t **)(v109 + v112);
            }
LABEL_192:
            uint64_t v110 = *((void *)this + 44);
          }
          else
          {
            uint64_t v77 = *((unsigned int *)this + 90);
            int v78 = v77 - 1;
            unsigned int v79 = (v77 - 1) & ((v73 >> 4) ^ (v73 >> 9));
            uint64_t v80 = (uint64_t **)(v109 + 8 * v79);
            unint64_t v81 = *v80;
            if (*v80 == (uint64_t *)-1)
            {
              BOOL v82 = 0;
LABEL_141:
              if (v82) {
                uint64_t v80 = v82;
              }
              if (*v80 != v73) {
                uint64_t v80 = (uint64_t **)(v109 + 8 * v77);
              }
            }
            else
            {
              BOOL v82 = 0;
              int v83 = 1;
              while (v81 != v73)
              {
                if (v82) {
                  BOOL v84 = 0;
                }
                else {
                  BOOL v84 = v81 == (uint64_t *)-2;
                }
                if (v84) {
                  BOOL v82 = v80;
                }
                unsigned int v85 = v79 + v83++;
                unsigned int v79 = v85 & v78;
                uint64_t v80 = (uint64_t **)(v109 + 8 * (v85 & v78));
                unint64_t v81 = *v80;
                if (*v80 == (uint64_t *)-1) {
                  goto LABEL_141;
                }
              }
            }
          }
          if (v109 == v110) {
            uint64_t v114 = (char *)this + 364;
          }
          else {
            uint64_t v114 = (char *)this + 360;
          }
          if (v80 != (uint64_t **)(v109 + 8 * *(unsigned int *)v114))
          {
            *uint64_t v80 = (uint64_t *)-2;
            ++*((_DWORD *)this + 92);
          }
        }
        else
        {
          if (v174) {
            goto LABEL_187;
          }
LABEL_315:
          sub_1CB89694C((llvm::SmallPtrSetImplBase *)v170, (uint64_t)v73);
        }
      }
      if (!v176) {
        goto LABEL_246;
      }
      unsigned int v172 = 0;
      char v115 = sub_1CBFD5918(*((void *)this + 40), *((_DWORD *)this + 84), v176, &v172);
      uint64_t v116 = v172;
      if ((v115 & 1) == 0)
      {
        uint64_t v116 = sub_1CBFD59A4((uint64_t)this + 320, &v176, v172);
        uint64_t v117 = v176;
        *((_DWORD *)v116 + 4) = 1;
        *uint64_t v116 = v117;
        v116[1] = 0;
        goto LABEL_201;
      }
      int64_t v75 = (const void **)(v172 + 1);
      if (v175 >= 0x41)
      {
        unsigned int v159 = v172;
        unsigned int v160 = (void *)v174;
        int v161 = (uint64_t *)*v75;
        unint64_t v162 = ((unint64_t)v175 + 63) >> 6;
        do
        {
          uint64_t v163 = *v161++;
          *v160++ |= v163;
          --v162;
        }
        while (v162);
        BOOL v164 = llvm::APInt::equalSlowCase((const void **)&v174, v75);
        uint64_t v116 = v159;
        if (v164) {
          goto LABEL_246;
        }
LABEL_201:
        if (*((_DWORD *)v116 + 4) >= 0x41u)
        {
          uint64_t v157 = v116[1];
          if (v157)
          {
            int v158 = v116;
            MEMORY[0x1D25D9CB0](v157, 0x1000C8000313F17);
            uint64_t v116 = v158;
          }
        }
        v116[1] = v174;
        *((_DWORD *)v116 + 4) = v175;
        unsigned int v175 = 0;
        if (v189)
        {
          int v118 = 16;
          unint64_t v119 = &v190;
        }
        else
        {
          int v118 = v191;
          if (!v191)
          {
            unint64_t v143 = 0;
LABEL_244:
            unint64_t v144 = sub_1CBFD5BBC((uint64_t)&v189, (uint64_t)&v176, &v176, v143);
            *unint64_t v144 = v176;
            if (v193 >= (unint64_t)HIDWORD(v193)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((void *)v192 + v193) = v176;
            LODWORD(v193) = v193 + 1;
            goto LABEL_246;
          }
          unint64_t v119 = v190;
        }
        int v120 = v118 - 1;
        unsigned int v121 = ((v176 >> 4) ^ (v176 >> 9)) & v120;
        int v122 = &v119[v121];
        uint64_t v123 = *v122;
        if (v176 == *v122) {
          goto LABEL_246;
        }
        uint64_t v124 = 0;
        int v125 = 1;
        while (v123 != -4096)
        {
          if (v124) {
            BOOL v126 = 0;
          }
          else {
            BOOL v126 = v123 == -8192;
          }
          if (v126) {
            uint64_t v124 = v122;
          }
          unsigned int v127 = v121 + v125++;
          unsigned int v121 = v127 & v120;
          int v122 = &v119[v121];
          uint64_t v123 = *v122;
          if (v176 == *v122) {
            goto LABEL_246;
          }
        }
        if (v124) {
          unint64_t v143 = v124;
        }
        else {
          unint64_t v143 = v122;
        }
        goto LABEL_244;
      }
      unint64_t v76 = *v75;
      v174 |= (unint64_t)*v75;
      if ((const void *)v174 != v76) {
        goto LABEL_201;
      }
LABEL_246:
      if (v175 >= 0x41 && v174) {
        MEMORY[0x1D25D9CB0](v174, 0x1000C8000313F17);
      }
LABEL_247:
      v73 += 4;
      if (v73 != v74) {
        continue;
      }
      break;
    }
    if (v181 >= 0x41 && v180) {
      MEMORY[0x1D25D9CB0](v180, 0x1000C8000313F17);
    }
LABEL_249:
    if (v179 >= 0x41 && v178) {
      MEMORY[0x1D25D9CB0](v178, 0x1000C8000313F17);
    }
    if (v185 >= 0x41 && v184) {
      MEMORY[0x1D25D9CB0](v184, 0x1000C8000313F17);
    }
    if (v183 >= 0x41 && v182) {
      MEMORY[0x1D25D9CB0](v182, 0x1000C8000313F17);
    }
    if (v187 >= 0x41 && v186) {
      MEMORY[0x1D25D9CB0](v186, 0x1000C8000313F17);
    }
    uint64_t v62 = v193;
    if (v193) {
      continue;
    }
    break;
  }
LABEL_266:
  if (v192 != v194) {
    free(v192);
  }
  if ((v189 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v190, 8);
  }
}

uint64_t sub_1CBFD41B0(unsigned __int8 *a1)
{
  if (a1[16] - 29 < 0xB) {
    return 1;
  }
  if (sub_1CBF63B28((uint64_t)a1)) {
    return 1;
  }
  unsigned int v2 = a1[16] - 38;
  if (v2 < 0x39 && ((0x100060000000001uLL >> v2) & 1) != 0) {
    return 1;
  }

  return llvm::Instruction::mayHaveSideEffects((llvm::Instruction *)a1);
}

uint64_t llvm::DemandedBits::getDemandedBits@<X0>(llvm::DemandedBits *this@<X0>, llvm::Instruction *a2@<X1>, llvm::APInt *a3@<X8>)
{
  llvm::DemandedBits::performAnalysis(this);
  uint64_t v13 = a2;
  uint64_t v14 = 0;
  uint64_t result = sub_1CBFD6124((uint64_t *)this + 40, &v13, &v14);
  if (!result || (uint64_t v7 = v14, v14 == *((void *)this + 40) + 24 * *((unsigned int *)this + 84)))
  {
    uint64_t v10 = *(void *)a2;
    if ((*(_DWORD *)(*(void *)a2 + 8) & 0xFE) == 0x12) {
      uint64_t v10 = **(void **)(v10 + 16);
    }
    uint64_t result = sub_1CB83544C(*(void *)(*(void *)(*((void *)a2 + 5) + 56) + 40) + 272, v10);
    unsigned int v12 = result;
    if (v11 == 1) {
    *((_DWORD *)a3 + 2) = v12;
    }
    if (v12 > 0x40) {
      llvm::APInt::initSlowCase(a3);
    }
    unint64_t v9 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v12;
    if (!v12) {
      unint64_t v9 = 0;
    }
  }
  else
  {
    unsigned int v8 = *(_DWORD *)(v14 + 16);
    *((_DWORD *)a3 + 2) = v8;
    if (v8 > 0x40) {
      operator new[]();
    }
    unint64_t v9 = *(void *)(v7 + 8);
  }
  *(void *)a3 = v9;
  return result;
}

BOOL llvm::DemandedBits::isUseDead(llvm::DemandedBits *this, llvm::Use *a2)
{
  uint64_t v4 = **(void **)a2;
  if ((*(_DWORD *)(v4 + 8) & 0xFE) == 0x12) {
    int v5 = *(unsigned __int8 *)(**(void **)(v4 + 16) + 8);
  }
  else {
    int v5 = *(_DWORD *)(v4 + 8);
  }
  if (v5 != 13) {
    return 0;
  }
  uint64_t v6 = (unsigned __int8 *)*((void *)a2 + 3);
  if (sub_1CBFD41B0(v6)) {
    return 0;
  }
  llvm::DemandedBits::performAnalysis(this);
  uint64_t v9 = *((void *)this + 43);
  uint64_t v8 = *((void *)this + 44);
  if (v8 == v9)
  {
    uint64_t v10 = *((unsigned int *)this + 91);
    uint64_t v11 = (llvm::Use **)(v8 + 8 * v10);
    if (v10)
    {
      uint64_t v12 = 0;
      uint64_t v13 = 8 * v10;
      while (*(llvm::Use **)(v8 + v12) != a2)
      {
        v12 += 8;
        if (v13 == v12) {
          goto LABEL_26;
        }
      }
      uint64_t v11 = (llvm::Use **)(v8 + v12);
    }
LABEL_26:
    uint64_t v9 = *((void *)this + 44);
  }
  else
  {
    uint64_t v14 = *((unsigned int *)this + 90);
    int v15 = v14 - 1;
    unsigned int v16 = (v14 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v11 = (llvm::Use **)(v8 + 8 * v16);
    uint64_t v17 = *v11;
    if (*v11 == (llvm::Use *)-1)
    {
      uint64_t v18 = 0;
LABEL_40:
      if (v18) {
        uint64_t v11 = v18;
      }
      if (*v11 != a2) {
        uint64_t v11 = (llvm::Use **)(v8 + 8 * v14);
      }
    }
    else
    {
      uint64_t v18 = 0;
      int v19 = 1;
      while (v17 != a2)
      {
        if (v18) {
          BOOL v20 = 0;
        }
        else {
          BOOL v20 = v17 == (llvm::Use *)-2;
        }
        if (v20) {
          uint64_t v18 = v11;
        }
        unsigned int v21 = v16 + v19++;
        unsigned int v16 = v21 & v15;
        uint64_t v11 = (llvm::Use **)(v8 + 8 * (v21 & v15));
        uint64_t v17 = *v11;
        if (*v11 == (llvm::Use *)-1) {
          goto LABEL_40;
        }
      }
    }
  }
  BOOL v20 = v8 == v9;
  uint64_t v22 = 360;
  if (v20) {
    uint64_t v22 = 364;
  }
  if (v11 != (llvm::Use **)(v8 + 8 * *(unsigned int *)((char *)this + v22))) {
    return 1;
  }
  int v23 = (*(_DWORD *)(*(void *)v6 + 8) & 0xFE) == 0x12
      ? *(unsigned __int8 *)(**(void **)(*(void *)v6 + 16) + 8)
      : *(_DWORD *)(*(void *)v6 + 8);
  if (v23 != 13) {
    return 0;
  }
  unsigned int v32 = v6;
  uint64_t v33 = 0;
  int v24 = sub_1CBFD6124((uint64_t *)this + 40, &v32, &v33);
  BOOL result = 0;
  if (v24 && v33 != *((void *)this + 40) + 24 * *((unsigned int *)this + 84))
  {
    uint64_t v25 = *(unsigned int *)(v33 + 16);
    if (v25 > 0x40)
    {
      int v27 = 0;
      int64_t v28 = (unint64_t)(v25 + 63) >> 6;
      do
      {
        if (v28-- < 1) {
          break;
        }
        unint64_t v30 = *(void *)(*(void *)(v33 + 8) + 8 * v28);
        v27 += __clz(v30);
      }
      while (!v30);
      int v31 = v25 | 0xFFFFFFC0;
      if ((v25 & 0x3F) == 0) {
        int v31 = 0;
      }
      return v27 + v31 == v25;
    }
    else
    {
      return *(void *)(v33 + 8) == 0;
    }
  }
  return result;
}

uint64_t llvm::DemandedBits::isInstructionDead(llvm::DemandedBits *this, llvm::Instruction *a2)
{
  llvm::DemandedBits::performAnalysis(this);
  uint64_t v5 = *((void *)this + 4);
  uint64_t v4 = *((void *)this + 5);
  if (v4 == v5)
  {
    uint64_t v6 = *((unsigned int *)this + 13);
    uint64_t v7 = (llvm::Instruction **)(v4 + 8 * v6);
    if (v6)
    {
      uint64_t v8 = 0;
      uint64_t v9 = 8 * v6;
      while (*(llvm::Instruction **)(v4 + v8) != a2)
      {
        v8 += 8;
        if (v9 == v8) {
          goto LABEL_19;
        }
      }
      uint64_t v7 = (llvm::Instruction **)(v4 + v8);
    }
LABEL_19:
    uint64_t v5 = *((void *)this + 5);
  }
  else
  {
    uint64_t v10 = *((unsigned int *)this + 12);
    int v11 = v10 - 1;
    unsigned int v12 = (v10 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v7 = (llvm::Instruction **)(v4 + 8 * v12);
    uint64_t v13 = *v7;
    if (*v7 == (llvm::Instruction *)-1)
    {
      uint64_t v14 = 0;
LABEL_28:
      if (v14) {
        uint64_t v7 = v14;
      }
      if (*v7 != a2) {
        uint64_t v7 = (llvm::Instruction **)(v4 + 8 * v10);
      }
    }
    else
    {
      uint64_t v14 = 0;
      int v15 = 1;
      while (v13 != a2)
      {
        if (v14) {
          BOOL v16 = 0;
        }
        else {
          BOOL v16 = v13 == (llvm::Instruction *)-2;
        }
        if (v16) {
          uint64_t v14 = v7;
        }
        unsigned int v17 = v12 + v15++;
        unsigned int v12 = v17 & v11;
        uint64_t v7 = (llvm::Instruction **)(v4 + 8 * (v17 & v11));
        uint64_t v13 = *v7;
        if (*v7 == (llvm::Instruction *)-1) {
          goto LABEL_28;
        }
      }
    }
  }
  BOOL v16 = v4 == v5;
  uint64_t v18 = 48;
  if (v16) {
    uint64_t v18 = 52;
  }
  if (v7 == (llvm::Instruction **)(v4 + 8 * *(unsigned int *)((char *)this + v18))
    && ((BOOL v20 = a2, v21 = 0, !sub_1CBFD6124((uint64_t *)this + 40, &v20, &v21))
     || v21 == *((void *)this + 40) + 24 * *((unsigned int *)this + 84)))
  {
    return sub_1CBFD41B0((unsigned __int8 *)a2) ^ 1;
  }
  else
  {
    return 0;
  }
}

void sub_1CBFD4710(llvm::raw_ostream **a1, llvm::Value *a2, uint64_t a3, llvm::Value *a4)
{
  uint64_t v7 = a1;
  uint64_t v8 = *a1;
  uint64_t v9 = (_OWORD *)*((void *)*a1 + 4);
  if (*((void *)*a1 + 3) - (void)v9 > 0xFuLL)
  {
    *uint64_t v9 = *(_OWORD *)"DemandedBits: 0x";
    *((void *)v8 + 4) += 16;
  }
  else
  {
    a1 = (llvm::raw_ostream **)llvm::raw_ostream::write(*a1, "DemandedBits: 0x", 0x10uLL);
  }
  uint64_t v10 = *(unsigned int *)(a3 + 8);
  if (v10 < 0x41) {
    goto LABEL_11;
  }
  int v11 = 0;
  a3 = *(void *)a3;
  int64_t v12 = (unint64_t)(v10 + 63) >> 6;
  do
  {
    if (v12-- < 1) {
      break;
    }
    unint64_t v14 = *(void *)(a3 + 8 * v12);
    v11 += __clz(v14);
  }
  while (!v14);
  int v15 = v10 | 0xFFFFFFC0;
  if ((v10 & 0x3F) == 0) {
    int v15 = 0;
  }
  if ((v10 - v11 - v15) <= 0x40) {
LABEL_11:
  }
    uint64_t v16 = *(void *)a3;
  else {
    uint64_t v16 = -1;
  }
  uint64_t v24 = v16;
  unsigned int v17 = llvm::Twine::printOneChild((llvm::raw_ostream *)a1, v8, (uint64_t)&v24, (size_t)a4, 14);
  llvm::Twine::printOneChild(v17, v8, 0, v18, 1);
  uint64_t v19 = *((void *)v8 + 4);
  if ((unint64_t)(*((void *)v8 + 3) - v19) > 4)
  {
    *(unsigned char *)(v19 + 4) = 32;
    *(_DWORD *)uint64_t v19 = 1919903264;
    *((void *)v8 + 4) += 5;
    if (a4)
    {
LABEL_14:
      llvm::Value::printAsOperand(a4, *v7, 0, 0);
      BOOL v20 = *v7;
      uint64_t v21 = (_DWORD *)*((void *)*v7 + 4);
      if (*((void *)*v7 + 3) - (void)v21 > 3uLL)
      {
        *uint64_t v21 = 544106784;
        *((void *)v20 + 4) += 4;
      }
      else
      {
        llvm::raw_ostream::write(v20, " in ", 4uLL);
      }
    }
  }
  else
  {
    llvm::raw_ostream::write(v8, " for ", 5uLL);
    if (a4) {
      goto LABEL_14;
    }
  }
  uint64_t v22 = *v7;
  llvm::Value::print(a2, v22, 0);
  int v23 = (unsigned char *)*((void *)v22 + 4);
  if ((unint64_t)v23 >= *((void *)v22 + 3))
  {
    llvm::raw_ostream::write(v22, 10);
  }
  else
  {
    *((void *)v22 + 4) = v23 + 1;
    *int v23 = 10;
  }
}

uint64_t sub_1CBFD4900(uint64_t a1, int a2, unsigned int *a3, uint64_t a4, uint64_t a5, int a6, unsigned int a7)
{
  if (*(_DWORD *)(a4 + 8) > 0x40u) {
    operator new[]();
  }
  int v11 = (void *)(a4 + 16);
  if (*(_DWORD *)(a4 + 24) >= 0x41u) {
    operator new[]();
  }
  int64_t v12 = (void *)(a5 + 16);
  uint64_t v13 = *(void *)(a5 + 16) & *v11 | *(void *)a5 & *(void *)a4;
  unsigned int v90 = *(_DWORD *)(a4 + 24);
  uint64_t v89 = v13;
  llvm::APInt::reverseBits((unsigned int *)&v89, (llvm::APInt *)&v87);
  llvm::APInt::reverseBits(a3, (llvm::APInt *)&v85);
  unsigned int v84 = v88;
  if (v88 > 0x40) {
    operator new[]();
  }
  uint64_t v14 = ~v87;
  unint64_t v15 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v88;
  if (v88) {
    unint64_t v16 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v88;
  }
  else {
    unint64_t v16 = 0;
  }
  unint64_t v83 = v16 & v14;
  unsigned int v84 = 0;
  if (!v88) {
    unint64_t v15 = 0;
  }
  unint64_t v17 = v15 & ((v85 | v16 & v14) + v85);
  unsigned int v80 = v88;
  if (v88) {
    unint64_t v18 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v88;
  }
  else {
    unint64_t v18 = 0;
  }
  unint64_t v79 = v18 & ~v87;
  unsigned int v80 = 0;
  unsigned int v82 = v88;
  uint64_t v81 = v79 ^ v17;
  llvm::APInt::reverseBits((unsigned int *)&v81, (llvm::APInt *)&v77);
  BOOL v56 = v11;
  if (a2)
  {
    unsigned int v19 = *(_DWORD *)(a4 + 8);
    unsigned int v72 = v19;
    if (v19 > 0x40) {
      operator new[]();
    }
    uint64_t v20 = ~*(void *)a4;
    unint64_t v21 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v19;
    if (!v19) {
      unint64_t v21 = 0;
    }
    unint64_t v71 = v21 & v20;
    unsigned int v72 = 0;
    unint64_t v25 = *(void *)a5 | v21 & v20;
    unsigned int v27 = *(_DWORD *)(a4 + 24);
    unsigned int v70 = v27;
    uint64_t v61 = v25;
    if (v27 > 0x40) {
      operator new[]();
    }
    int64_t v28 = &v70;
    uint64_t v29 = ~*v11;
    if (v27) {
      unint64_t v30 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v27;
    }
    else {
      unint64_t v30 = 0;
    }
    unint64_t v31 = v30 & v29;
    unint64_t v69 = v30 & v29;
    unsigned int v32 = v12;
  }
  else
  {
    unsigned int v22 = *(_DWORD *)(a5 + 8);
    unsigned int v76 = v22;
    if (v22 > 0x40) {
      operator new[]();
    }
    uint64_t v23 = ~*(void *)a5;
    unint64_t v24 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v22;
    if (!v22) {
      unint64_t v24 = 0;
    }
    unint64_t v75 = v24 & v23;
    unsigned int v76 = 0;
    unint64_t v26 = *(void *)a4 | v24 & v23;
    unsigned int v33 = *(_DWORD *)(a5 + 24);
    unsigned int v74 = v33;
    uint64_t v61 = v26;
    if (v33 > 0x40) {
      operator new[]();
    }
    int64_t v28 = &v74;
    uint64_t v34 = ~*v12;
    if (v33) {
      unint64_t v35 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v33;
    }
    else {
      unint64_t v35 = 0;
    }
    unint64_t v31 = v35 & v34;
    unint64_t v73 = v35 & v34;
    unsigned int v32 = v11;
  }
  unsigned int *v28 = 0;
  unsigned int v36 = v12;
  unint64_t v37 = *v32 | v31;
  uint64_t v38 = a3;
  unsigned int v39 = *(_DWORD *)(a4 + 8);
  unsigned int v66 = v39;
  if (v39 > 0x40) {
    operator new[]();
  }
  uint64_t v40 = ~*(void *)a4;
  unint64_t v41 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v39;
  if (!v39) {
    unint64_t v41 = 0;
  }
  unint64_t v42 = v41 & v40;
  unint64_t v65 = v41 & v40;
  unsigned int v66 = 0;
  unsigned int v43 = *(_DWORD *)(a5 + 8);
  unsigned int v64 = v43;
  if (v43 > 0x40) {
    operator new[]();
  }
  unint64_t v44 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v43;
  unint64_t v45 = v44;
  if (!v43) {
    unint64_t v45 = 0;
  }
  unint64_t v46 = (v45 & ~*(void *)a5) + v42;
  if (!v43) {
    unint64_t v44 = 0;
  }
  unsigned int v68 = v43;
  unint64_t v67 = v44 & v46;
  llvm::APInt::operator+=((uint64_t)&v67, a6 ^ 1u);
  unsigned int v47 = v68;
  unint64_t v48 = v67;
  unsigned int v68 = 0;
  unsigned int v49 = *(_DWORD *)(a4 + 24);
  if (v49 >= 0x41) {
    operator new[]();
  }
  uint64_t v50 = *v36 + *v56;
  unint64_t v51 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v49;
  if (!v49) {
    unint64_t v51 = 0;
  }
  unsigned int v63 = *(_DWORD *)(a4 + 24);
  unint64_t v62 = v51 & v50;
  llvm::APInt::operator+=((uint64_t)&v62, a7);
  unsigned int v52 = v63;
  unsigned int v63 = 0;
  if (v47 > 0x40) {
    operator new[]();
  }
  unint64_t v53 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v47;
  if (!v47) {
    unint64_t v53 = 0;
  }
  if (v52 >= 0x41) {
    operator new[]();
  }
  if (v78 >= 0x41) {
    operator new[]();
  }
  unint64_t v54 = *(void *)v38 | v77 & (v53 & ~v48 | v61) & (v62 | v37);
  *(_DWORD *)(a1 + 8) = v78;
  *(void *)a1 = v54;
  uint64_t result = v61;
  if (v78 >= 0x41)
  {
    uint64_t result = v77;
    if (v77) {
      uint64_t result = MEMORY[0x1D25D9CB0](v77, 0x1000C8000313F17);
    }
  }
  if (v82 >= 0x41)
  {
    uint64_t result = v81;
    if (v81) {
      uint64_t result = MEMORY[0x1D25D9CB0](v81, 0x1000C8000313F17);
    }
  }
  if (v86 >= 0x41)
  {
    uint64_t result = v85;
    if (v85) {
      uint64_t result = MEMORY[0x1D25D9CB0](v85, 0x1000C8000313F17);
    }
  }
  if (v88 >= 0x41)
  {
    uint64_t result = v87;
    if (v87) {
      uint64_t result = MEMORY[0x1D25D9CB0](v87, 0x1000C8000313F17);
    }
  }
  if (v90 >= 0x41)
  {
    uint64_t result = v89;
    if (v89) {
      return MEMORY[0x1D25D9CB0](v89, 0x1000C8000313F17);
    }
  }
  return result;
}

void llvm::createDemandedBitsWrapperPass(llvm *this)
{
}

void llvm::DemandedBitsAnalysis::run()
{
}

void *sub_1CBFD5834(void *a1)
{
  unsigned int v2 = (void *)a1[44];
  if (v2 != (void *)a1[43]) {
    free(v2);
  }
  sub_1CBFD5898((uint64_t)(a1 + 40));
  MEMORY[0x1D25D9CD0](a1[40], 8);
  uint64_t v3 = (void *)a1[5];
  if (v3 != (void *)a1[4]) {
    free(v3);
  }
  return a1;
}

uint64_t sub_1CBFD5898(uint64_t result)
{
  uint64_t v1 = *(unsigned int *)(result + 16);
  if (v1)
  {
    uint64_t v2 = 24 * v1;
    uint64_t v3 = *(void *)result + 8;
    do
    {
      if ((*(void *)(v3 - 8) | 0x1000) != 0xFFFFFFFFFFFFF000 && *(_DWORD *)(v3 + 8) >= 0x41u)
      {
        uint64_t result = *(void *)v3;
        if (*(void *)v3) {
          uint64_t result = MEMORY[0x1D25D9CB0](result, 0x1000C8000313F17);
        }
      }
      v3 += 24;
      v2 -= 24;
    }
    while (v2);
  }
  return result;
}

uint64_t sub_1CBFD5918(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    uint64_t v6 = (void *)(a1 + 24 * v5);
    uint64_t v7 = *v6;
    if (*v6 == a3)
    {
LABEL_11:
      uint64_t result = 1;
    }
    else
    {
      uint64_t v8 = 0;
      int v9 = 1;
      while (v7 != -4096)
      {
        if (v8) {
          BOOL v10 = 0;
        }
        else {
          BOOL v10 = v7 == -8192;
        }
        if (v10) {
          uint64_t v8 = v6;
        }
        unsigned int v11 = v5 + v9++;
        unsigned int v5 = v11 & v4;
        uint64_t v6 = (void *)(a1 + 24 * (v11 & v4));
        uint64_t v7 = *v6;
        if (*v6 == a3) {
          goto LABEL_11;
        }
      }
      uint64_t result = 0;
      if (v8) {
        uint64_t v6 = v8;
      }
    }
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t result = 0;
  }
  *a4 = v6;
  return result;
}

void *sub_1CBFD59A4(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CBFD5A5C(a1, v6);
  uint64_t v8 = 0;
  sub_1CBFD5918(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CBFD5A5C(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(24 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v12 = *(unsigned int *)(a1 + 16);
    if (v12)
    {
      uint64_t v13 = 24 * v12;
      do
      {
        void *result = -4096;
        result += 3;
        v13 -= 24;
      }
      while (v13);
    }
    if (v3)
    {
      uint64_t v14 = (_DWORD *)(v4 + 16);
      uint64_t v15 = 24 * v3;
      do
      {
        uint64_t v16 = *((void *)v14 - 2);
        if ((v16 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          unint64_t v18 = 0;
          sub_1CBFD5918(*(void *)a1, *(_DWORD *)(a1 + 16), v16, &v18);
          unint64_t v17 = v18;
          *unint64_t v18 = *((void *)v14 - 2);
          *((_DWORD *)v17 + 4) = *v14;
          v17[1] = *((void *)v14 - 1);
          *uint64_t v14 = 0;
          ++*(_DWORD *)(a1 + 8);
        }
        v14 += 6;
        v15 -= 24;
      }
      while (v15);
    }
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 24 * v10;
    do
    {
      void *result = -4096;
      result += 3;
      v11 -= 24;
    }
    while (v11);
  }
  return result;
}

void *sub_1CBFD5BBC(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *(_DWORD *)a1;
  int v7 = *(_DWORD *)a1 >> 1;
  if (*(_DWORD *)a1) {
    unsigned int v8 = 16;
  }
  else {
    unsigned int v8 = *(_DWORD *)(a1 + 16);
  }
  if (4 * v7 + 4 >= 3 * v8)
  {
    sub_1CBFD5D90(a1, 2 * v8);
    uint64_t v20 = a1 + 8;
    int v6 = *(_DWORD *)a1;
    if (*(_DWORD *)a1)
    {
      int v21 = 16;
    }
    else
    {
      int v21 = *(_DWORD *)(a1 + 16);
      if (!v21) {
        goto LABEL_41;
      }
      uint64_t v20 = *(void *)(a1 + 8);
    }
    int v9 = *(_DWORD *)a1 & 1;
    int v22 = v21 - 1;
    unsigned int v23 = ((*a3 >> 4) ^ (*a3 >> 9)) & v22;
    a4 = (void *)(v20 + 8 * v23);
    uint64_t v24 = *a4;
    if (*a3 == *a4) {
      goto LABEL_6;
    }
    uint64_t v16 = 0;
    int v25 = 1;
    while (v24 != -4096)
    {
      if (v16) {
        BOOL v26 = 0;
      }
      else {
        BOOL v26 = v24 == -8192;
      }
      if (v26) {
        uint64_t v16 = a4;
      }
      unsigned int v27 = v23 + v25++;
      unsigned int v23 = v27 & v22;
      a4 = (void *)(v20 + 8 * v23);
      uint64_t v24 = *a4;
      if (*a3 == *a4) {
        goto LABEL_6;
      }
    }
    goto LABEL_36;
  }
  if (v8 + ~v7 - *(_DWORD *)(a1 + 4) > v8 >> 3)
  {
    int v9 = *(_DWORD *)a1 & 1;
    goto LABEL_6;
  }
  sub_1CBFD5D90(a1, v8);
  uint64_t v11 = a1 + 8;
  int v6 = *(_DWORD *)a1;
  if (*(_DWORD *)a1)
  {
    int v12 = 16;
    goto LABEL_13;
  }
  int v12 = *(_DWORD *)(a1 + 16);
  if (!v12)
  {
LABEL_41:
    int v9 = 0;
    a4 = 0;
    goto LABEL_6;
  }
  uint64_t v11 = *(void *)(a1 + 8);
LABEL_13:
  int v9 = *(_DWORD *)a1 & 1;
  int v13 = v12 - 1;
  unsigned int v14 = ((*a3 >> 4) ^ (*a3 >> 9)) & v13;
  a4 = (void *)(v11 + 8 * v14);
  uint64_t v15 = *a4;
  if (*a3 == *a4) {
    goto LABEL_6;
  }
  uint64_t v16 = 0;
  int v17 = 1;
  while (v15 != -4096)
  {
    if (v16) {
      BOOL v18 = 0;
    }
    else {
      BOOL v18 = v15 == -8192;
    }
    if (v18) {
      uint64_t v16 = a4;
    }
    unsigned int v19 = v14 + v17++;
    unsigned int v14 = v19 & v13;
    a4 = (void *)(v11 + 8 * v14);
    uint64_t v15 = *a4;
    if (*a3 == *a4) {
      goto LABEL_6;
    }
  }
LABEL_36:
  if (v16) {
    a4 = v16;
  }
LABEL_6:
  *(_DWORD *)a1 = (v6 & 0xFFFFFFFE | v9) + 2;
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 4);
  }
  return a4;
}

int *sub_1CBFD5D90(uint64_t a1, unsigned int a2)
{
  v14[16] = *MEMORY[0x1E4F143B8];
  if (a2 >= 0x11)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    uint64_t v10 = *(uint64_t **)(a1 + 8);
    uint64_t v11 = *(unsigned int *)(a1 + 16);
    if (a2 <= 0x10)
    {
      *(_DWORD *)a1 |= 1u;
    }
    else
    {
      uint64_t v12 = a2;
      *(void *)(a1 + 8) = operator new(8 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v12;
    }
    sub_1CBFD5F18((int *)a1, v10, &v10[v11]);
    JUMPOUT(0x1D25D9CD0);
  }
  int v6 = v14;
  for (uint64_t i = 8; i != 136; i += 8)
  {
    uint64_t v8 = *(void *)(a1 + i);
    if ((v8 | 0x1000) != 0xFFFFFFFFFFFFF000) {
      *v6++ = v8;
    }
  }
  if (a2 > 0x10)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v13 = a2;
    *(void *)(a1 + 8) = operator new(8 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v13;
  }
  return sub_1CBFD5F18((int *)a1, v14, v6);
}

int *sub_1CBFD5F18(int *result, uint64_t *a2, uint64_t *a3)
{
  int v3 = *result;
  *result &= 1u;
  result[1] = 0;
  if (v3)
  {
    int v6 = result + 34;
    int v5 = result + 2;
  }
  else
  {
    uint64_t v4 = result[4];
    if (!v4) {
      goto LABEL_5;
    }
    int v5 = (void *)*((void *)result + 1);
    int v6 = &v5[v4];
  }
  do
    *v5++ = -4096;
  while (v5 != v6);
LABEL_5:
  while (a2 != a3)
  {
    uint64_t v7 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      if (*(unsigned char *)result)
      {
        int v9 = 16;
        uint64_t v8 = result + 2;
      }
      else
      {
        uint64_t v8 = (int *)*((void *)result + 1);
        int v9 = result[4];
      }
      int v10 = v9 - 1;
      unsigned int v11 = (v9 - 1) & ((v7 >> 4) ^ (v7 >> 9));
      uint64_t v12 = &v8[2 * v11];
      uint64_t v13 = *(void *)v12;
      if (v7 != *(void *)v12)
      {
        unsigned int v14 = 0;
        int v15 = 1;
        while (v13 != -4096)
        {
          if (v14) {
            BOOL v16 = 0;
          }
          else {
            BOOL v16 = v13 == -8192;
          }
          if (v16) {
            unsigned int v14 = v12;
          }
          unsigned int v17 = v11 + v15++;
          unsigned int v11 = v17 & v10;
          uint64_t v12 = &v8[2 * (v17 & v10)];
          uint64_t v13 = *(void *)v12;
          if (v7 == *(void *)v12) {
            goto LABEL_23;
          }
        }
        if (v14) {
          uint64_t v12 = v14;
        }
      }
LABEL_23:
      *(void *)uint64_t v12 = v7;
      *result += 2;
    }
    ++a2;
  }
  return result;
}

void *sub_1CBFD601C(uint64_t a1, uint64_t *a2)
{
  uint64_t v8 = 0;
  char v4 = sub_1CBFD5918(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  int v5 = v8;
  if ((v4 & 1) == 0)
  {
    int v5 = sub_1CBFD59A4(a1, a2, v8);
    uint64_t v7 = *a2;
    *((_DWORD *)v5 + 4) = 1;
    *int v5 = v7;
    v5[1] = 0;
  }
  return v5;
}

uint64_t sub_1CBFD6090(uint64_t a1, void *a2)
{
  uint64_t v2 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v3 = 16;
  }
  else
  {
    int v3 = *(_DWORD *)(a1 + 16);
    if (!v3) {
      return 0;
    }
    uint64_t v2 = *(void *)(a1 + 8);
  }
  int v4 = v3 - 1;
  LODWORD(v5) = ((*a2 >> 4) ^ (*a2 >> 9)) & (v3 - 1);
  int v6 = (uint64_t *)(v2 + 8 * v5);
  uint64_t v7 = *v6;
  if (*a2 == *v6)
  {
LABEL_9:
    *int v6 = -8192;
    int v10 = *(_DWORD *)(a1 + 4) + 1;
    *(_DWORD *)a1 -= 2;
    *(_DWORD *)(a1 + 4) = v10;
    return 1;
  }
  int v8 = 1;
  while (v7 != -4096)
  {
    int v9 = v5 + v8++;
    uint64_t v5 = v9 & v4;
    uint64_t v7 = *(void *)(v2 + 8 * v5);
    if (*a2 == v7)
    {
      int v6 = (uint64_t *)(v2 + 8 * v5);
      goto LABEL_9;
    }
  }
  return 0;
}

uint64_t sub_1CBFD6124(uint64_t *a1, void *a2, void *a3)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    uint64_t v4 = *a1;
    int v5 = v3 - 1;
    unsigned int v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v3 - 1);
    uint64_t v7 = (void *)(*a1 + 24 * v6);
    uint64_t v8 = *v7;
    if (*a2 == *v7)
    {
      uint64_t result = 1;
    }
    else
    {
      int v10 = 0;
      int v11 = 1;
      uint64_t result = 1;
      while (v8 != -4096)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v8 == -8192;
        }
        if (v12) {
          int v10 = v7;
        }
        unsigned int v13 = v6 + v11++;
        unsigned int v6 = v13 & v5;
        uint64_t v7 = (void *)(v4 + 24 * (v13 & v5));
        uint64_t v8 = *v7;
        if (*a2 == *v7) {
          goto LABEL_4;
        }
      }
      uint64_t result = 0;
      if (v10) {
        uint64_t v7 = v10;
      }
    }
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t result = 0;
  }
LABEL_4:
  *a3 = v7;
  return result;
}

void sub_1CBFD61C4(llvm *a1)
{
  llvm::initializeLoopInfoWrapperPassPass((uint64_t)a1);
  llvm::initializeScalarEvolutionWrapperPassPass(a1, v2);
  llvm::initializeAAResultsWrapperPassPass(a1, v3);
  operator new();
}

uint64_t sub_1CBFD627C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 24);
  uint64_t v3 = v2 + 72;
  uint64_t v4 = *(void *)(v2 + 80);
  if (v4 == v2 + 72) {
    return result;
  }
  uint64_t v5 = a2;
  unsigned int v6 = (llvm::raw_ostream *)result;
  while (1)
  {
    uint64_t v7 = v4 - 24;
    if (!v4) {
      uint64_t v7 = 0;
    }
    uint64_t v8 = *(void *)(v7 + 48);
    if (v8 != v7 + 40) {
      break;
    }
    uint64_t v4 = *(void *)(v4 + 8);
    if (v4 == v3) {
      return result;
    }
  }
  while (2)
  {
    if (v8) {
      uint64_t v9 = v8 - 24;
    }
    else {
      uint64_t v9 = 0;
    }
    int v10 = *(unsigned __int8 *)(v9 + 16);
    uint64_t v11 = (v10 - 33);
    if (v11 > 0x37) {
      goto LABEL_15;
    }
    if (((1 << (v10 - 33)) & 0x8000000000041) != 0)
    {
      uint64_t v15 = *(void *)(v9 + 64);
      if (!v15 || (*(unsigned char *)(v15 + 20) & 4) == 0 && (*(unsigned char *)(v15 + 17) & 0x10) == 0)
      {
        LODWORD(v60) = 7;
        uint64_t result = sub_1CC5CB59C(v9, (__int32 *)&v60, 1uLL);
        if (result)
        {
          uint64_t v49 = *(void *)(v9 - 32);
          if (!v49
            || *(unsigned char *)(v49 + 16)
            || *(void *)(v49 + 24) != *(void *)(v9 + 72)
            || *(_DWORD *)(v49 + 36) != 7)
          {
            goto LABEL_46;
          }
        }
        uint64_t result = llvm::CallBase::hasFnAttrOnCalledFunction(v9, 66);
        if ((result & 1) == 0)
        {
          uint64_t result = llvm::CallBase::hasFnAttrOnCalledFunction(v9, 44);
          if (!result) {
            goto LABEL_46;
          }
        }
      }
LABEL_34:
      int v10 = *(unsigned __int8 *)(v9 + 16);
      goto LABEL_15;
    }
    if (((1 << (v10 - 33)) & 0x808001C8000010) == 0)
    {
      if (v11 != 28)
      {
LABEL_15:
        uint64_t v12 = (v10 - 33);
        if (v12 > 0x37) {
          goto LABEL_19;
        }
        if (((1 << v12) & 0x8000000000041) != 0)
        {
          uint64_t v16 = *(void *)(v9 + 64);
          if (v16 && (*(unsigned char *)(v16 + 17) & 0x30) != 0) {
            goto LABEL_19;
          }
          int v17 = *(_DWORD *)(v9 + 20);
          if (v17 < 0
            && (uint64_t v50 = v9 - 32 * (v17 & 0x7FFFFFF), v53 = *(void *)(v50 - 8), v51 = v50 - 8, (v52 = v53) != 0))
          {
            uint64_t v54 = -v52;
            while (1)
            {
              unsigned int v55 = *(_DWORD *)(*(void *)(v51 + v54) + 8);
              BOOL v56 = v55 > 7;
              int v57 = (1 << v55) & 0x83;
              if (v56 || v57 == 0) {
                break;
              }
              v54 += 16;
              if (!v54) {
                goto LABEL_38;
              }
            }
            char v18 = 1;
          }
          else
          {
LABEL_38:
            uint64_t result = llvm::CallBase::hasFnAttrOnCalledFunction(v9, 45);
            if (result) {
              goto LABEL_19;
            }
            uint64_t result = llvm::CallBase::hasFnAttrOnCalledFunction(v9, 44);
            char v18 = result ^ 1;
          }
        }
        else if (v12 == 27)
        {
          char v18 = (*(_WORD *)(v9 + 18) & 0x301) != 0;
        }
        else
        {
          if (((1 << v12) & 0x808001D0000010) == 0) {
            goto LABEL_19;
          }
          char v18 = 1;
        }
        if (v4 == v3 || (v18 & 1) == 0) {
          goto LABEL_19;
        }
        goto LABEL_47;
      }
      if ((*(_WORD *)(v9 + 18) & 0x301) == 0) {
        goto LABEL_34;
      }
    }
LABEL_46:
    if (v4 == v3) {
      goto LABEL_19;
    }
LABEL_47:
    uint64_t v19 = v8;
    uint64_t v20 = v4;
    while (1)
    {
      if (v19) {
        uint64_t v21 = v19 - 24;
      }
      else {
        uint64_t v21 = 0;
      }
      int v22 = *(unsigned __int8 *)(v21 + 16);
      uint64_t v23 = (v22 - 33);
      if (v23 <= 0x37)
      {
        if (((1 << (v22 - 33)) & 0x8000000000041) != 0)
        {
          uint64_t v24 = *(void *)(v21 + 64);
          if (!v24 || (*(unsigned char *)(v24 + 20) & 4) == 0 && (*(unsigned char *)(v24 + 17) & 0x10) == 0)
          {
            LODWORD(v60) = 7;
            if (sub_1CC5CB59C(v21, (__int32 *)&v60, 1uLL))
            {
              uint64_t v41 = *(void *)(v21 - 32);
              if (!v41
                || *(unsigned char *)(v41 + 16)
                || *(void *)(v41 + 24) != *(void *)(v21 + 72)
                || *(_DWORD *)(v41 + 36) != 7)
              {
                goto LABEL_68;
              }
            }
            uint64_t result = llvm::CallBase::hasFnAttrOnCalledFunction(v21, 66);
            if ((result & 1) == 0)
            {
              uint64_t result = llvm::CallBase::hasFnAttrOnCalledFunction(v21, 44);
              if (!result) {
                goto LABEL_68;
              }
            }
          }
        }
        else
        {
          if (((1 << (v22 - 33)) & 0x808001C8000010) != 0) {
            goto LABEL_68;
          }
          if (v23 != 28) {
            goto LABEL_64;
          }
          if ((*(_WORD *)(v21 + 18) & 0x301) != 0) {
            goto LABEL_68;
          }
        }
        int v22 = *(unsigned __int8 *)(v21 + 16);
      }
LABEL_64:
      uint64_t v25 = (v22 - 33);
      if (v25 > 0x37) {
        goto LABEL_86;
      }
      if (((1 << v25) & 0x8000000000041) != 0)
      {
        uint64_t v32 = *(void *)(v21 + 64);
        if (v32 && (*(unsigned char *)(v32 + 17) & 0x30) != 0) {
          goto LABEL_86;
        }
        int v33 = *(_DWORD *)(v21 + 20);
        if (v33 < 0
          && (v42 = v21 - 32 * (v33 & 0x7FFFFFF), v45 = *(void *)(v42 - 8), uint64_t v43 = v42 - 8, (v44 = v45) != 0))
        {
          uint64_t v46 = -v44;
          while (1)
          {
            unsigned int v47 = *(_DWORD *)(*(void *)(v43 + v46) + 8);
            if (v47 >= 2 && v47 != 7) {
              break;
            }
            v46 += 16;
            if (!v46) {
              goto LABEL_82;
            }
          }
        }
        else
        {
LABEL_82:
          uint64_t result = llvm::CallBase::hasFnAttrOnCalledFunction(v21, 45);
          if (result) {
            goto LABEL_86;
          }
          uint64_t result = llvm::CallBase::hasFnAttrOnCalledFunction(v21, 44);
          if (result) {
            goto LABEL_86;
          }
        }
      }
      else if (v25 == 27)
      {
        if ((*(_WORD *)(v21 + 18) & 0x301) == 0) {
          goto LABEL_86;
        }
      }
      else if (((1 << v25) & 0x808001D0000010) == 0)
      {
        goto LABEL_86;
      }
LABEL_68:
      BOOL v26 = (_DWORD *)*((void *)v6 + 4);
      if (*((void *)v6 + 3) - (void)v26 > 3uLL)
      {
        _DWORD *v26 = 979595859;
        *((void *)v6 + 4) += 4;
      }
      else
      {
        llvm::raw_ostream::write(v6, "Src:", 4uLL);
      }
      llvm::Value::print((llvm::Value *)v9, v6, 0);
      uint64_t v27 = *((void *)v6 + 4);
      if ((unint64_t)(*((void *)v6 + 3) - v27) > 8)
      {
        *(unsigned char *)(v27 + 8) = 58;
        *(void *)uint64_t v27 = *(void *)" --> Dst:";
        *((void *)v6 + 4) += 9;
      }
      else
      {
        llvm::raw_ostream::write(v6, " --> Dst:", 9uLL);
      }
      llvm::Value::print((llvm::Value *)v21, v6, 0);
      int64_t v28 = (unsigned char *)*((void *)v6 + 4);
      if (*((unsigned char **)v6 + 3) == v28)
      {
        llvm::raw_ostream::write(v6, "\n", 1uLL);
        uint64_t v29 = (void *)*((void *)v6 + 4);
      }
      else
      {
        unsigned char *v28 = 10;
        uint64_t v29 = (void *)(*((void *)v6 + 4) + 1);
        *((void *)v6 + 4) = v29;
      }
      if (*((void *)v6 + 3) - (void)v29 > 0xEuLL)
      {
        qmemcpy(v29, "  da analyze - ", 15);
        *((void *)v6 + 4) += 15;
      }
      else
      {
        llvm::raw_ostream::write(v6, "  da analyze - ", 0xFuLL);
      }
      uint64_t result = llvm::DependenceInfo::depends(v5, (llvm::Instruction *)v9, (llvm::Instruction *)v21, 1, &v60);
      unint64_t v30 = v60;
      if (v60)
      {
        unsigned int v59 = (llvm::DependenceInfo *)v5;
        llvm::Dependence::dump((llvm::Instruction **)v60, v6);
        if ((*(unsigned int (**)(llvm::Dependence *))(*(void *)v30 + 40))(v30))
        {
          uint64_t v36 = 1;
          do
          {
            if ((*(unsigned int (**)(llvm::Dependence *, uint64_t))(*(void *)v30 + 80))(v30, v36))
            {
              unint64_t v37 = (void *)*((void *)v6 + 4);
              if (*((void *)v6 + 3) - (void)v37 > 0x1CuLL)
              {
                qmemcpy(v37, "  da analyze - split level = ", 29);
                *((void *)v6 + 4) += 29;
              }
              else
              {
                llvm::raw_ostream::write(v6, "  da analyze - split level = ", 0x1DuLL);
              }
              sub_1CD098D14(v6, v36, 0, 0, 0);
              uint64_t v38 = (void *)*((void *)v6 + 4);
              if (*((void *)v6 + 3) - (void)v38 > 0xDuLL)
              {
                qmemcpy(v38, ", iteration = ", 14);
                *((void *)v6 + 4) += 14;
              }
              else
              {
                llvm::raw_ostream::write(v6, ", iteration = ", 0xEuLL);
              }
              SplitIteration = (llvm::SCEV *)llvm::DependenceInfo::getSplitIteration(v59, v30, v36);
              llvm::SCEV::print(SplitIteration, v6);
              uint64_t v40 = (_WORD *)*((void *)v6 + 4);
              if (*((void *)v6 + 3) - (void)v40 > 1uLL)
              {
                _WORD *v40 = 2593;
                *((void *)v6 + 4) += 2;
              }
              else
              {
                llvm::raw_ostream::write(v6, "!\n", 2uLL);
              }
            }
            uint64_t v36 = (v36 + 1);
          }
          while (v36 <= (*(unsigned int (**)(llvm::Dependence *))(*(void *)v30 + 40))(v30));
        }
        uint64_t result = (*(uint64_t (**)(llvm::Dependence *))(*(void *)v30 + 8))(v30);
        uint64_t v5 = (uint64_t)v59;
      }
      else
      {
        uint64_t v31 = *((void *)v6 + 4);
        if ((unint64_t)(*((void *)v6 + 3) - v31) > 5)
        {
          *(_WORD *)(v31 + 4) = 2593;
          *(_DWORD *)uint64_t v31 = 1701736302;
          *((void *)v6 + 4) += 6;
        }
        else
        {
          uint64_t result = (uint64_t)llvm::raw_ostream::write(v6, "none!\n", 6uLL);
        }
      }
LABEL_86:
      uint64_t v19 = *(void *)(v19 + 8);
      uint64_t v34 = v20 - 24;
      if (!v20) {
        uint64_t v34 = 0;
      }
      if (v19 == v34 + 40) {
        break;
      }
LABEL_93:
      if (v20 == v3) {
        goto LABEL_19;
      }
    }
    while (1)
    {
      uint64_t v20 = *(void *)(v20 + 8);
      if (v20 == v3) {
        break;
      }
      uint64_t v35 = v20 - 24;
      if (!v20) {
        uint64_t v35 = 0;
      }
      uint64_t v19 = *(void *)(v35 + 48);
      if (v19 != v35 + 40) {
        goto LABEL_93;
      }
    }
LABEL_19:
    uint64_t v8 = *(void *)(v8 + 8);
    uint64_t v13 = v4 - 24;
    if (!v4) {
      uint64_t v13 = 0;
    }
    if (v8 != v13 + 40)
    {
LABEL_26:
      if (v4 == v3) {
        return result;
      }
      continue;
    }
    break;
  }
  while (1)
  {
    uint64_t v4 = *(void *)(v4 + 8);
    if (v4 == v3) {
      return result;
    }
    uint64_t v14 = v4 - 24;
    if (!v4) {
      uint64_t v14 = 0;
    }
    uint64_t v8 = *(void *)(v14 + 48);
    if (v8 != v14 + 40) {
      goto LABEL_26;
    }
  }
}

uint64_t llvm::Dependence::isInput(llvm::Dependence *this)
{
  uint64_t result = 0;
  uint64_t v3 = *((void *)this + 1);
  uint64_t v4 = *(unsigned __int8 *)(v3 + 16) - 33;
  if (v4 <= 0x37)
  {
    if (((1 << (*(unsigned char *)(v3 + 16) - 33)) & 0x8000000000041) != 0)
    {
      uint64_t v5 = *(void *)(v3 + 64);
      if (v5 && ((*(unsigned char *)(v5 + 20) & 4) != 0 || (*(unsigned char *)(v5 + 17) & 0x10) != 0)) {
        return 0;
      }
      __int32 v11 = 7;
      if ((!sub_1CC5CB59C(v3, &v11, 1uLL)
         || (uint64_t v9 = *(void *)(v3 - 32)) != 0
         && !*(unsigned char *)(v9 + 16)
         && *(void *)(v9 + 24) == *(void *)(v3 + 72)
         && *(_DWORD *)(v9 + 36) == 7)
        && ((llvm::CallBase::hasFnAttrOnCalledFunction(v3, 66) & 1) != 0
         || (llvm::CallBase::hasFnAttrOnCalledFunction(v3, 44) & 1) != 0))
      {
        return 0;
      }
    }
    else if (((1 << (*(unsigned char *)(v3 + 16) - 33)) & 0x808001C8000010) == 0)
    {
      if (v4 != 28) {
        return result;
      }
      if ((*(_WORD *)(v3 + 18) & 0x301) == 0) {
        return 0;
      }
    }
    uint64_t result = 0;
    uint64_t v6 = *((void *)this + 2);
    uint64_t v7 = *(unsigned __int8 *)(v6 + 16) - 33;
    if (v7 > 0x37) {
      return result;
    }
    if (((1 << (*(unsigned char *)(v6 + 16) - 33)) & 0x8000000000041) == 0)
    {
      if (((1 << (*(unsigned char *)(v6 + 16) - 33)) & 0x808001C8000010) == 0)
      {
        if (v7 == 28) {
          return (*(_WORD *)(v6 + 18) & 0x301) != 0;
        }
        return result;
      }
      return 1;
    }
    uint64_t v8 = *(void *)(v6 + 64);
    if (!v8 || (*(unsigned char *)(v8 + 20) & 4) == 0 && (*(unsigned char *)(v8 + 17) & 0x10) == 0)
    {
      __int32 v12 = 7;
      if (sub_1CC5CB59C(v6, &v12, 1uLL))
      {
        uint64_t v10 = *(void *)(v6 - 32);
        if (!v10 || *(unsigned char *)(v10 + 16) || *(void *)(v10 + 24) != *(void *)(v6 + 72) || *(_DWORD *)(v10 + 36) != 7) {
          return 1;
        }
      }
      if ((llvm::CallBase::hasFnAttrOnCalledFunction(v6, 66) & 1) == 0) {
        return llvm::CallBase::hasFnAttrOnCalledFunction(v6, 44) ^ 1;
      }
    }
    return 0;
  }
  return result;
}

uint64_t llvm::DependenceInfo::Constraint::getX(llvm::DependenceInfo::Constraint *this)
{
  return *((void *)this + 2);
}

uint64_t llvm::DependenceInfo::Constraint::getY(llvm::DependenceInfo::Constraint *this)
{
  return *((void *)this + 3);
}

uint64_t llvm::DependenceInfo::Constraint::getA(llvm::DependenceInfo::Constraint *this)
{
  return *((void *)this + 2);
}

uint64_t llvm::DependenceInfo::Constraint::getB(llvm::DependenceInfo::Constraint *this)
{
  return *((void *)this + 3);
}

uint64_t llvm::DependenceInfo::Constraint::getC(llvm::DependenceInfo::Constraint *this)
{
  return *((void *)this + 4);
}

unint64_t llvm::DependenceInfo::Constraint::getD(llvm::DependenceInfo::Constraint *this)
{
  return llvm::ScalarEvolution::getNegativeSCEV(*((llvm::ScalarEvolution **)this + 1), *((void *)this + 4), 0);
}

uint64_t llvm::DependenceInfo::Constraint::getAssociatedLoop(llvm::DependenceInfo::Constraint *this)
{
  return *((void *)this + 5);
}

uint64_t llvm::DependenceInfo::Constraint::setPoint(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_DWORD *)uint64_t result = 1;
  *(void *)(result + 16) = a2;
  *(void *)(result + 24) = a3;
  *(void *)(result + 40) = a4;
  return result;
}

uint64_t llvm::DependenceInfo::Constraint::setLine(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(_DWORD *)uint64_t result = 3;
  *(void *)(result + 16) = a2;
  *(void *)(result + 24) = a3;
  *(void *)(result + 32) = a4;
  *(void *)(result + 40) = a5;
  return result;
}

_DWORD *llvm::DependenceInfo::Constraint::setEmpty(_DWORD *this)
{
  *this = 0;
  return this;
}

uint64_t llvm::DependenceInfo::Constraint::setAny(uint64_t result, uint64_t a2)
{
  *(void *)(result + 8) = a2;
  *(_DWORD *)uint64_t result = 4;
  return result;
}

uint64_t llvm::DependenceInfo::intersectConstraints(llvm::DependenceInfo *this, llvm::DependenceInfo::Constraint *a2, const llvm::DependenceInfo::Constraint *a3)
{
  uint64_t v155 = *MEMORY[0x1E4F143B8];
  int v3 = *(_DWORD *)a2;
  if (!*(_DWORD *)a2) {
    return 0;
  }
  if (v3 == 4)
  {
    if (*(_DWORD *)a3 == 4) {
      return 0;
    }
LABEL_26:
    long long v31 = *(_OWORD *)a3;
    long long v32 = *((_OWORD *)a3 + 2);
    *((_OWORD *)a2 + sub_1CD456CB4((void *)this + 1) = *((_OWORD *)a3 + 1);
    *((_OWORD *)a2 + 2) = v32;
    *(_OWORD *)a2 = v31;
    return 1;
  }
  int v7 = *(_DWORD *)a3;
  if (!*(_DWORD *)a3)
  {
LABEL_6:
    *(_DWORD *)a2 = 0;
    return 1;
  }
  if (v3 == 2 && v7 == 2)
  {
    unint64_t NegativeSCEV = llvm::ScalarEvolution::getNegativeSCEV(*((llvm::ScalarEvolution **)a2 + 1), *((void *)a2 + 4), 0);
    unint64_t v26 = llvm::ScalarEvolution::getNegativeSCEV(*((llvm::ScalarEvolution **)a3 + 1), *((void *)a3 + 4), 0);
    char isKnownPredicate = llvm::DependenceInfo::isKnownPredicate((uint64_t)this, 0x20u, NegativeSCEV, v26);
    uint64_t result = 0;
    if (isKnownPredicate) {
      return result;
    }
    unint64_t v28 = llvm::ScalarEvolution::getNegativeSCEV(*((llvm::ScalarEvolution **)a2 + 1), *((void *)a2 + 4), 0);
    unint64_t v29 = llvm::ScalarEvolution::getNegativeSCEV(*((llvm::ScalarEvolution **)a3 + 1), *((void *)a3 + 4), 0);
    if (!llvm::DependenceInfo::isKnownPredicate((uint64_t)this, 0x21u, v28, v29))
    {
      unint64_t v30 = llvm::ScalarEvolution::getNegativeSCEV(*((llvm::ScalarEvolution **)a3 + 1), *((void *)a3 + 4), 0);
      uint64_t result = 0;
      if (*(_WORD *)(v30 + 24)) {
        return result;
      }
      goto LABEL_26;
    }
    goto LABEL_6;
  }
  unsigned int v10 = v7 & 0xFFFFFFFE;
  if ((v3 & 0xFFFFFFFE) == 2 && v10 == 2)
  {
    uint64_t v33 = *((void *)this + 1);
    uint64_t v34 = *((void *)a2 + 2);
    uint64_t v35 = *((void *)a3 + 3);
    long long __src = &v153;
    uint64_t v153 = v34;
    uint64_t v154 = v35;
    uint64_t v152 = 0x200000002;
    uint64_t MulExpr = llvm::ScalarEvolution::getMulExpr(v33, (uint64_t)&__src, 0, 0);
    if (__src != &v153) {
      free(__src);
    }
    uint64_t v37 = *((void *)this + 1);
    uint64_t v38 = *((void *)a2 + 3);
    uint64_t v39 = *((void *)a3 + 2);
    long long __src = &v153;
    uint64_t v153 = v38;
    uint64_t v154 = v39;
    uint64_t v152 = 0x200000002;
    uint64_t v40 = llvm::ScalarEvolution::getMulExpr(v37, (uint64_t)&__src, 0, 0);
    if (__src != &v153) {
      free(__src);
    }
    if (llvm::DependenceInfo::isKnownPredicate((uint64_t)this, 0x20u, MulExpr, v40))
    {
      uint64_t v41 = *((void *)this + 1);
      uint64_t v42 = *((void *)a2 + 4);
      uint64_t v43 = *((void *)a3 + 3);
      long long __src = &v153;
      uint64_t v153 = v42;
      uint64_t v154 = v43;
      uint64_t v152 = 0x200000002;
      uint64_t v44 = llvm::ScalarEvolution::getMulExpr(v41, (uint64_t)&__src, 0, 0);
      if (__src != &v153) {
        free(__src);
      }
      uint64_t v45 = *((void *)this + 1);
      uint64_t v46 = *((void *)a2 + 3);
      uint64_t v47 = *((void *)a3 + 4);
      long long __src = &v153;
      uint64_t v153 = v46;
      uint64_t v154 = v47;
      uint64_t v152 = 0x200000002;
      uint64_t v48 = llvm::ScalarEvolution::getMulExpr(v45, (uint64_t)&__src, 0, 0);
      if (__src != &v153) {
        free(__src);
      }
      if (llvm::DependenceInfo::isKnownPredicate((uint64_t)this, 0x20u, v44, v48)) {
        return 0;
      }
      uint64_t v23 = this;
      uint64_t v24 = v44;
      uint64_t v22 = v48;
      goto LABEL_40;
    }
    uint64_t result = llvm::DependenceInfo::isKnownPredicate((uint64_t)this, 0x21u, MulExpr, v40);
    if (!result) {
      return result;
    }
    uint64_t v49 = *((void *)this + 1);
    uint64_t v50 = *((void *)a2 + 4);
    uint64_t v51 = *((void *)a3 + 3);
    long long __src = &v153;
    uint64_t v153 = v50;
    uint64_t v154 = v51;
    uint64_t v152 = 0x200000002;
    uint64_t v52 = (llvm::SCEV *)llvm::ScalarEvolution::getMulExpr(v49, (uint64_t)&__src, 0, 0);
    if (__src != &v153) {
      free(__src);
    }
    uint64_t v53 = *((void *)this + 1);
    uint64_t v54 = *((void *)a2 + 4);
    uint64_t v55 = *((void *)a3 + 2);
    long long __src = &v153;
    uint64_t v153 = v54;
    uint64_t v154 = v55;
    uint64_t v152 = 0x200000002;
    BOOL v56 = (llvm::SCEV *)llvm::ScalarEvolution::getMulExpr(v53, (uint64_t)&__src, 0, 0);
    if (__src != &v153) {
      free(__src);
    }
    uint64_t v57 = *((void *)this + 1);
    uint64_t v58 = *((void *)a3 + 4);
    uint64_t v59 = *((void *)a2 + 3);
    long long __src = &v153;
    uint64_t v153 = v58;
    uint64_t v154 = v59;
    uint64_t v152 = 0x200000002;
    unint64_t v60 = (const llvm::APInt *)llvm::ScalarEvolution::getMulExpr(v57, (uint64_t)&__src, 0, 0);
    if (__src != &v153) {
      free(__src);
    }
    uint64_t v61 = *((void *)this + 1);
    uint64_t v62 = *((void *)a3 + 4);
    uint64_t v63 = *((void *)a2 + 2);
    long long __src = &v153;
    uint64_t v153 = v62;
    uint64_t v154 = v63;
    uint64_t v152 = 0x200000002;
    unsigned int v64 = (const llvm::APInt *)llvm::ScalarEvolution::getMulExpr(v61, (uint64_t)&__src, 0, 0);
    if (__src != &v153) {
      free(__src);
    }
    uint64_t v65 = *((void *)this + 1);
    uint64_t v66 = *((void *)a2 + 2);
    uint64_t v67 = *((void *)a3 + 3);
    long long __src = &v153;
    uint64_t v153 = v66;
    uint64_t v154 = v67;
    uint64_t v152 = 0x200000002;
    unsigned int v68 = (llvm::SCEV *)llvm::ScalarEvolution::getMulExpr(v65, (uint64_t)&__src, 0, 0);
    if (__src != &v153) {
      free(__src);
    }
    uint64_t v69 = *((void *)this + 1);
    uint64_t v70 = *((void *)a3 + 2);
    uint64_t v71 = *((void *)a2 + 3);
    long long __src = &v153;
    uint64_t v153 = v70;
    uint64_t v154 = v71;
    uint64_t v152 = 0x200000002;
    unsigned int v72 = (const llvm::APInt *)llvm::ScalarEvolution::getMulExpr(v69, (uint64_t)&__src, 0, 0);
    if (__src != &v153) {
      free(__src);
    }
    unint64_t MinusSCEV = llvm::ScalarEvolution::getMinusSCEV(*((llvm::ScalarEvolution **)this + 1), v56, v64, 0, 0);
    unint64_t v74 = *(_WORD *)(MinusSCEV + 24) ? 0 : MinusSCEV;
    unint64_t v75 = llvm::ScalarEvolution::getMinusSCEV(*((llvm::ScalarEvolution **)this + 1), v52, v60, 0, 0);
    unint64_t v76 = *(_WORD *)(v75 + 24) ? 0 : v75;
    unint64_t v77 = llvm::ScalarEvolution::getMinusSCEV(*((llvm::ScalarEvolution **)this + 1), v68, v72, 0, 0);
    unint64_t v78 = *(_WORD *)(v77 + 24) ? 0 : v77;
    unint64_t v80 = llvm::ScalarEvolution::getMinusSCEV(*((llvm::ScalarEvolution **)this + 1), v72, v68, 0, 0);
    uint64_t result = 0;
    unint64_t v81 = *(_WORD *)(v80 + 24) ? 0 : v80;
    if (!v76 || !v74 || !v78 || !v81) {
      return result;
    }
    uint64_t v82 = *(void *)(v76 + 32);
    LODWORD(v152) = *(_DWORD *)(v82 + 32);
    if (v152 > 0x40) {
      operator new[]();
    }
    long long __src = *(void **)(v82 + 24);
    uint64_t v83 = *(void *)(v78 + 32);
    unsigned int v150 = *(_DWORD *)(v83 + 32);
    if (v150 > 0x40) {
      operator new[]();
    }
    uint64_t v149 = *(void *)(v83 + 24);
    uint64_t v84 = *(void *)(v74 + 32);
    unsigned int v148 = *(_DWORD *)(v84 + 32);
    if (v148 > 0x40) {
      operator new[]();
    }
    uint64_t v147 = *(void **)(v84 + 24);
    uint64_t v85 = *(void *)(v81 + 32);
    unsigned int v146 = *(_DWORD *)(v85 + 32);
    if (v146 > 0x40) {
      operator new[]();
    }
    uint64_t v145 = *(void *)(v85 + 24);
    unsigned int v144 = v152;
    unint64_t v143 = __src;
    unsigned int v142 = v152;
    BOOL v141 = __src;
    llvm::APInt::sdivrem((llvm::APInt *)&__src, (const llvm::APInt *)&v149, (const llvm::APInt *)&v143, (llvm::APInt *)&v141, v79);
    unsigned int v140 = v148;
    if (v148 > 0x40) {
      operator new[]();
    }
    unsigned int v139 = v147;
    unsigned int v138 = v148;
    unint64_t v137 = v147;
    llvm::APInt::sdivrem((llvm::APInt *)&v147, (const llvm::APInt *)&v145, (const llvm::APInt *)&v139, (llvm::APInt *)&v137, v86);
    uint64_t v87 = v141;
    if (v142 >= 0x41)
    {
      int v88 = 0;
      int64_t v89 = ((unint64_t)v142 + 63) >> 6;
      do
      {
        BOOL v90 = v89-- < 1;
        if (v90) {
          break;
        }
        unint64_t v91 = v141[v89];
        v88 += __clz(v91);
      }
      while (!v91);
      unsigned int v92 = v142 | 0xFFFFFFC0;
      if ((v142 & 0x3F) == 0) {
        unsigned int v92 = 0;
      }
      if (v142 - v88 - v92 > 0x40) {
        goto LABEL_108;
      }
      uint64_t v87 = (void *)*v141;
    }
    if (v87) {
      goto LABEL_108;
    }
    int v93 = v137;
    if (v138 >= 0x41)
    {
      int v94 = 0;
      int64_t v95 = ((unint64_t)v138 + 63) >> 6;
      do
      {
        BOOL v90 = v95-- < 1;
        if (v90) {
          break;
        }
        unint64_t v96 = v137[v95];
        v94 += __clz(v96);
      }
      while (!v96);
      unsigned int v97 = v138 | 0xFFFFFFC0;
      if ((v138 & 0x3F) == 0) {
        unsigned int v97 = 0;
      }
      if (v138 - v94 - v97 > 0x40) {
        goto LABEL_108;
      }
      int v93 = (void *)*v137;
    }
    if (v93) {
      goto LABEL_108;
    }
    if (v144 >= 0x41)
    {
      unsigned int v98 = v143;
      unsigned int v99 = v144 - 64;
      if ((*((void *)v143 + ((v144 - 1) >> 6)) >> (v144 - 1)))
      {
        if (v99 - llvm::APInt::countLeadingOnesSlowCase((llvm::APInt *)&v143) < 0xFFFFFFBF) {
          goto LABEL_108;
        }
      }
      else
      {
        int v100 = 0;
        int64_t v101 = ((unint64_t)v144 + 63) >> 6;
        do
        {
          BOOL v90 = v101-- < 1;
          if (v90) {
            break;
          }
          unint64_t v102 = *((void *)v143 + v101);
          v100 += __clz(v102);
        }
        while (!v102);
        if ((v144 & 0x3F) != 0) {
          unsigned int v103 = v144 | 0xFFFFFFC0;
        }
        else {
          unsigned int v103 = 0;
        }
        if (v99 - v100 - v103 < 0xFFFFFFBF) {
          goto LABEL_106;
        }
      }
      if ((*v98 & 0x8000000000000000) != 0) {
        goto LABEL_108;
      }
    }
    else if ((uint64_t)((void)v143 << -(uint64_t)v144) >> -(uint64_t)v144 < 0)
    {
      goto LABEL_108;
    }
LABEL_106:
    if (v140 >= 0x41)
    {
      unint64_t v104 = v139;
      unsigned int v105 = v140 - 64;
      if ((*((void *)v139 + ((v140 - 1) >> 6)) >> (v140 - 1)))
      {
        if (v105 - llvm::APInt::countLeadingOnesSlowCase((llvm::APInt *)&v139) < 0xFFFFFFBF) {
          goto LABEL_108;
        }
      }
      else
      {
        int v106 = 0;
        int64_t v107 = ((unint64_t)v140 + 63) >> 6;
        do
        {
          BOOL v90 = v107-- < 1;
          if (v90) {
            break;
          }
          unint64_t v108 = *((void *)v139 + v107);
          v106 += __clz(v108);
        }
        while (!v108);
        if ((v140 & 0x3F) != 0) {
          unsigned int v109 = v140 | 0xFFFFFFC0;
        }
        else {
          unsigned int v109 = 0;
        }
        if (v105 - v106 - v109 < 0xFFFFFFBF) {
          goto LABEL_152;
        }
      }
      if ((*v104 & 0x8000000000000000) != 0) {
        goto LABEL_108;
      }
    }
    else if ((uint64_t)((void)v139 << -(uint64_t)v140) >> -(uint64_t)v140 < 0)
    {
      goto LABEL_108;
    }
LABEL_152:
    while (2)
    {
      switch(*(_WORD *)(MulExpr + 24))
      {
        case 1:
        case 2:
        case 3:
        case 0xD:
          uint64_t v111 = (llvm::Type **)(MulExpr + 40);
          goto LABEL_159;
        case 4:
          uint64_t v111 = (llvm::Type **)(MulExpr + 48);
          goto LABEL_159;
        case 5:
        case 7:
        case 8:
        case 9:
        case 0xA:
        case 0xB:
        case 0xC:
          uint64_t v110 = *(uint64_t **)(MulExpr + 32);
          goto LABEL_154;
        case 6:
          uint64_t v110 = (uint64_t *)(MulExpr + 40);
LABEL_154:
          uint64_t MulExpr = *v110;
          continue;
        case 0xE:
          uint64_t v111 = *(llvm::Type ***)(MulExpr - 8);
          goto LABEL_159;
        default:
          uint64_t v111 = *(llvm::Type ***)(MulExpr + 32);
LABEL_159:
          uint64_t v112 = llvm::DependenceInfo::collectUpperBound((llvm::ScalarEvolution **)this, *((const llvm::Loop **)a2 + 5), *v111);
          if (!v112 || *((_WORD *)v112 + 12)) {
            goto LABEL_165;
          }
          uint64_t v114 = v112[4];
          char v115 = (uint64_t *)((char *)v114 + 24);
          if (v144 > 0x40)
          {
            uint64_t v124 = *((void *)v143 + ((v144 - 1) >> 6)) & (1 << (v144 - 1));
            unsigned int v125 = *((_DWORD *)v114 + 8);
            unsigned int v126 = v125 - 1;
            uint64_t v116 = *((void *)v114 + 3);
            if (v125 >= 0x41) {
              unsigned int v127 = (void *)(v116 + 8 * (v126 >> 6));
            }
            else {
              unsigned int v127 = (void *)((char *)v114 + 24);
            }
            if ((v124 != 0) == ((*v127 >> v126) & 1))
            {
              unint64_t v131 = (((unint64_t)v144 + 63) >> 3) & 0x3FFFFFF8;
              do
              {
                if (!v131) {
                  goto LABEL_163;
                }
                unint64_t v132 = *(void *)((char *)v143 + v131 - 8);
                unint64_t v133 = *(void *)(v116 + v131 - 8);
                v131 -= 8;
              }
              while (v132 == v133);
              if (v132 > v133) {
                goto LABEL_108;
              }
            }
            else if (!v124)
            {
              goto LABEL_108;
            }
          }
          else
          {
            uint64_t v116 = *v115;
            if ((uint64_t)((void)v143 << -(uint64_t)v144) >> -(uint64_t)v144 > *v115 << -(uint64_t)v144 >> -(uint64_t)v144) {
              goto LABEL_108;
            }
          }
LABEL_163:
          if (v140 <= 0x40)
          {
            if ((uint64_t)((void)v139 << -(char)v140) >> -(char)v140 > v116 << -(char)v140 >> -(char)v140) {
              goto LABEL_108;
            }
            goto LABEL_165;
          }
          uint64_t v128 = *((void *)v139 + ((v140 - 1) >> 6)) & (1 << (v140 - 1));
          unsigned int v129 = *((_DWORD *)v114 + 8);
          unsigned int v130 = v129 - 1;
          if (v129 >= 0x41) {
            char v115 = (uint64_t *)(v116 + 8 * (v130 >> 6));
          }
          if ((v128 != 0) == (((unint64_t)*v115 >> v130) & 1))
          {
            unint64_t v134 = (((unint64_t)v140 + 63) >> 3) & 0x3FFFFFF8;
            do
            {
              if (!v134) {
                goto LABEL_165;
              }
              unint64_t v135 = *(void *)((char *)v139 + v134 - 8);
              unint64_t v136 = *(void *)(v116 - 8 + v134);
              v134 -= 8;
            }
            while (v135 == v136);
            if (v135 > v136) {
              goto LABEL_108;
            }
LABEL_165:
            uint64_t v117 = (llvm::ConstantInt ****)*((void *)this + 1);
            int v118 = (llvm::ConstantInt *)llvm::ConstantInt::get(***v117, (llvm::LLVMContext *)&v143, v113);
            unint64_t Constant = llvm::ScalarEvolution::getConstant((llvm::ScalarEvolution *)v117, v118);
            int v120 = (llvm::ConstantInt ****)*((void *)this + 1);
            int v122 = (llvm::ConstantInt *)llvm::ConstantInt::get(***v120, (llvm::LLVMContext *)&v139, v121);
            unint64_t v123 = llvm::ScalarEvolution::getConstant((llvm::ScalarEvolution *)v120, v122);
            *(_DWORD *)a2 = 1;
            *((void *)a2 + 2) = Constant;
            *((void *)a2 + 3) = v123;
            goto LABEL_109;
          }
          if (v128) {
            goto LABEL_165;
          }
          break;
      }
      break;
    }
LABEL_108:
    *(_DWORD *)a2 = 0;
LABEL_109:
    if (v138 >= 0x41 && v137) {
      MEMORY[0x1D25D9CB0](v137, 0x1000C8000313F17);
    }
    if (v140 >= 0x41 && v139) {
      MEMORY[0x1D25D9CB0](v139, 0x1000C8000313F17);
    }
    if (v142 >= 0x41 && v141) {
      MEMORY[0x1D25D9CB0](v141, 0x1000C8000313F17);
    }
    if (v144 >= 0x41 && v143) {
      MEMORY[0x1D25D9CB0](v143, 0x1000C8000313F17);
    }
    if (v146 >= 0x41 && v145) {
      MEMORY[0x1D25D9CB0](v145, 0x1000C8000313F17);
    }
    if (v148 >= 0x41 && v147) {
      MEMORY[0x1D25D9CB0](v147, 0x1000C8000313F17);
    }
    if (v150 >= 0x41 && v149) {
      MEMORY[0x1D25D9CB0](v149, 0x1000C8000313F17);
    }
    if (v152 >= 0x41 && __src) {
      MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
    }
    return 1;
  }
  uint64_t v12 = *((void *)this + 1);
  uint64_t v13 = *((void *)a3 + 2);
  uint64_t v14 = *((void *)a2 + 2);
  long long __src = &v153;
  uint64_t v153 = v13;
  uint64_t v154 = v14;
  uint64_t v152 = 0x200000002;
  uint64_t v15 = llvm::ScalarEvolution::getMulExpr(v12, (uint64_t)&__src, 0, 0);
  if (__src != &v153) {
    free(__src);
  }
  uint64_t v16 = *((void *)this + 1);
  uint64_t v17 = *((void *)a3 + 3);
  uint64_t v18 = *((void *)a2 + 3);
  long long __src = &v153;
  uint64_t v153 = v17;
  uint64_t v154 = v18;
  uint64_t v152 = 0x200000002;
  uint64_t v19 = llvm::ScalarEvolution::getMulExpr(v16, (uint64_t)&__src, 0, 0);
  if (__src != &v153) {
    free(__src);
  }
  uint64_t v20 = *((void *)this + 1);
  long long __src = &v153;
  uint64_t v153 = v15;
  uint64_t v154 = v19;
  uint64_t v152 = 0x200000002;
  uint64_t AddExpr = llvm::ScalarEvolution::getAddExpr(v20, (unint64_t **)&__src, 0, 0);
  if (__src != &v153) {
    free(__src);
  }
  if (llvm::DependenceInfo::isKnownPredicate((uint64_t)this, 0x20u, AddExpr, *((void *)a3 + 4))) {
    return 0;
  }
  uint64_t v22 = *((void *)a3 + 4);
  uint64_t v23 = this;
  uint64_t v24 = AddExpr;
LABEL_40:
  uint64_t result = llvm::DependenceInfo::isKnownPredicate((uint64_t)v23, 0x21u, v24, v22);
  if (result) {
    goto LABEL_6;
  }
  return result;
}

uint64_t sub_1CBFD7CB4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  void v8[2] = *MEMORY[0x1E4F143B8];
  v7[0] = v8;
  v8[0] = a2;
  v8[1] = a3;
  v7[1] = (void *)0x200000002;
  uint64_t MulExpr = llvm::ScalarEvolution::getMulExpr(a1, (uint64_t)v7, a4, a5);
  if (v7[0] != v8) {
    free(v7[0]);
  }
  return MulExpr;
}

llvm::detail::IEEEFloat **llvm::DependenceInfo::collectConstantUpperBound(llvm::ScalarEvolution **this, const llvm::Loop *a2, llvm::Type *a3)
{
  uint64_t result = llvm::DependenceInfo::collectUpperBound(this, a2, a3);
  if (result)
  {
    if (*((_WORD *)result + 12)) {
      return 0;
    }
  }
  return result;
}

uint64_t sub_1CBFD7D6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void v8[2] = *MEMORY[0x1E4F143B8];
  v7[0] = v8;
  v8[0] = a2;
  v8[1] = a3;
  v7[1] = (void *)0x200000002;
  uint64_t AddExpr = llvm::ScalarEvolution::getAddExpr(a1, (unint64_t **)v7, a4, a5);
  if (v7[0] != v8) {
    free(v7[0]);
  }
  return AddExpr;
}

uint64_t llvm::DependenceInfo::mapSrcLoop(uint64_t a1, void *a2)
{
  LODWORD(result) = 0;
  do
  {
    a2 = (void *)*a2;
    uint64_t result = (result + 1);
  }
  while (a2);
  return result;
}

uint64_t llvm::DependenceInfo::mapDstLoop(uint64_t result, void *a2)
{
  uint64_t v2 = result;
  LODWORD(result) = 0;
  do
  {
    a2 = (void *)*a2;
    uint64_t result = (result + 1);
  }
  while (a2);
  unsigned int v3 = *(_DWORD *)(v2 + 32);
  if (result > v3) {
    return *(_DWORD *)(v2 + 36) - v3 + result;
  }
  return result;
}

unint64_t *sub_1CBFD7E40(unint64_t *result, unsigned int a2)
{
  unint64_t v2 = *result;
  if (*result) {
    void *result = v2 & 0xFC00000000000000 | (2
  }
                                         * (((v2 >> 1) & ~(-1 << (v2 >> 58)) | (1 << a2)) & ~(-1 << (v2 >> 58)))) | 1;
  else {
    *(void *)(*(void *)v2 + 8 * (a2 >> 6)) |= 1 << a2;
  }
  return result;
}

uint64_t sub_1CBFD7EA0(uint64_t a1, llvm::ScalarEvolution *a2)
{
  v9[3] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2 == 2) {
    return *(void *)(*(void *)(a1 + 32) + 8);
  }
  uint64_t v4 = *(void *)(a1 + 32);
  v8[0] = v9;
  v8[1] = (void *)0x300000000;
  sub_1CD47792C((unsigned int *)v8, (unsigned char *)(v4 + 8), (unsigned char *)(v4 + 8 * v2));
  uint64_t v7 = sub_1CD478318(a2, (uint64_t)v8, *(const llvm::Loop **)(a1 + 48), 0);
  if (v8[0] != v9) {
    free(v8[0]);
  }
  return v7;
}

BOOL llvm::DependenceInfo::checkSrcSubscript(uint64_t a1, llvm::SCEV *a2, const llvm::Loop *a3, unint64_t *a4)
{
  return llvm::DependenceInfo::checkSubscript(a1, a2, a3, a4, 1);
}

BOOL llvm::DependenceInfo::checkDstSubscript(uint64_t a1, llvm::SCEV *a2, const llvm::Loop *a3, unint64_t *a4)
{
  return llvm::DependenceInfo::checkSubscript(a1, a2, a3, a4, 0);
}

unint64_t llvm::DependenceInfo::isKnownLessThan(llvm::ScalarEvolution **this, llvm::detail::IEEEFloat **a2, llvm::detail::IEEEFloat **a3)
{
  uint64_t v5 = a2;
  while (2)
  {
    switch(*((_WORD *)v5 + 12))
    {
      case 1:
      case 2:
      case 3:
      case 0xD:
        uint64_t v7 = (llvm::detail::IEEEFloat *)(v5 + 5);
        goto LABEL_9;
      case 4:
        uint64_t v7 = (llvm::detail::IEEEFloat *)(v5 + 6);
        goto LABEL_9;
      case 5:
      case 7:
      case 8:
      case 9:
      case 0xA:
      case 0xB:
      case 0xC:
        uint64_t v6 = (llvm::detail::IEEEFloat ***)v5[4];
        goto LABEL_4;
      case 6:
        uint64_t v6 = (llvm::detail::IEEEFloat ***)(v5 + 5);
LABEL_4:
        uint64_t v5 = *v6;
        continue;
      case 0xE:
        uint64_t v7 = *(v5 - 1);
        goto LABEL_9;
      default:
        uint64_t v7 = v5[4];
LABEL_9:
        uint64_t v8 = *(llvm::Type **)v7;
        if (*((unsigned char *)v8 + 8) != 13) {
          uint64_t v8 = 0;
        }
        uint64_t v9 = a3;
        while (2)
        {
          switch(*((_WORD *)v9 + 12))
          {
            case 1:
            case 2:
            case 3:
            case 0xD:
              __int32 v11 = (llvm::detail::IEEEFloat *)(v9 + 5);
              goto LABEL_19;
            case 4:
              __int32 v11 = (llvm::detail::IEEEFloat *)(v9 + 6);
              goto LABEL_19;
            case 5:
            case 7:
            case 8:
            case 9:
            case 0xA:
            case 0xB:
            case 0xC:
              unsigned int v10 = (llvm::detail::IEEEFloat ***)v9[4];
              goto LABEL_14;
            case 6:
              unsigned int v10 = (llvm::detail::IEEEFloat ***)(v9 + 5);
LABEL_14:
              uint64_t v9 = *v10;
              continue;
            case 0xE:
              __int32 v11 = *(v9 - 1);
              goto LABEL_19;
            default:
              __int32 v11 = v9[4];
LABEL_19:
              unint64_t result = 0;
              uint64_t v13 = *(llvm::Type **)v11;
              if (*((unsigned char *)v13 + 8) != 13) {
                uint64_t v13 = 0;
              }
              if (v8 && v13)
              {
                if (*((_DWORD *)v8 + 2) >> 8 >= *((_DWORD *)v13 + 2) >> 8) {
                  uint64_t v14 = v8;
                }
                else {
                  uint64_t v14 = v13;
                }
                TruncateOrZeroExtend = llvm::ScalarEvolution::getTruncateOrZeroExtend(this[1], a2, v14, 0);
                uint64_t v16 = llvm::ScalarEvolution::getTruncateOrZeroExtend(this[1], a3, v14, 0);
                unint64_t MinusSCEV = llvm::ScalarEvolution::getMinusSCEV(this[1], (llvm::SCEV *)TruncateOrZeroExtend, (const llvm::APInt *)v16, 0, 0);
                if (MinusSCEV) {
                  BOOL v18 = *(unsigned __int16 *)(MinusSCEV + 24) == 7;
                }
                else {
                  BOOL v18 = 0;
                }
                if (v18
                  && (unint64_t v19 = MinusSCEV, *(void *)(MinusSCEV + 40) == 2)
                  && (uint64_t v20 = this[1],
                      uint64_t v21 = *(const llvm::Loop **)(MinusSCEV + 48),
                      BackedgeTakenInfo = llvm::ScalarEvolution::getBackedgeTakenInfo(v20, v21),
                      Exact = (const llvm::SCEV *)llvm::ScalarEvolution::BackedgeTakenInfo::getExact((uint64_t)BackedgeTakenInfo, (uint64_t)v21, (uint64_t)v20), *((_WORD *)Exact + 12) != 15)&& (uint64_t v24 = (const llvm::SCEV *)llvm::SCEVAddRecExpr::evaluateAtIteration(*(uint64_t **)(v19 + 32), *(void *)(v19 + 40), Exact, this[1]), (llvm::ScalarEvolution::isKnownNegative(this[1], v24) & 1) != 0))
                {
                  return 1;
                }
                else
                {
                  uint64_t v25 = this[1];
                  unint64_t v26 = v16;
                  while (2)
                  {
                    switch(*((_WORD *)v26 + 12))
                    {
                      case 1:
                      case 2:
                      case 3:
                      case 0xD:
                        unint64_t v28 = v26 + 5;
                        goto LABEL_44;
                      case 4:
                        unint64_t v28 = v26 + 6;
                        goto LABEL_44;
                      case 5:
                      case 7:
                      case 8:
                      case 9:
                      case 0xA:
                      case 0xB:
                      case 0xC:
                        uint64_t v27 = (llvm::detail::IEEEFloat ***)v26[4];
                        goto LABEL_39;
                      case 6:
                        uint64_t v27 = (llvm::detail::IEEEFloat ***)(v26 + 5);
LABEL_39:
                        unint64_t v26 = *v27;
                        continue;
                      case 0xE:
                        unint64_t v28 = (llvm::Type **)*(v26 - 1);
                        goto LABEL_44;
                      default:
                        unint64_t v28 = (llvm::Type **)v26[4];
LABEL_44:
                        unint64_t Constant = (const llvm::SCEV *)llvm::ScalarEvolution::getConstant(this[1], *v28, 1uLL, 0);
                        SMaxExpr = (const llvm::APInt *)llvm::ScalarEvolution::getSMaxExpr(v25, (const llvm::SCEV *)v16, Constant);
                        long long v31 = (const llvm::SCEV *)llvm::ScalarEvolution::getMinusSCEV(v25, (llvm::SCEV *)TruncateOrZeroExtend, SMaxExpr, 0, 0);
                        long long v32 = this[1];
                        unint64_t result = llvm::ScalarEvolution::isKnownNegative(v32, v31);
                        break;
                    }
                    break;
                  }
                }
              }
              return result;
          }
        }
    }
  }
}

uint64_t llvm::DependenceInfo::testZIV(llvm::DependenceInfo *this, const llvm::SCEV *a2, const llvm::SCEV *a3, llvm::FullDependence *a4)
{
  if (llvm::DependenceInfo::isKnownPredicate((uint64_t)this, 0x20u, (uint64_t)a2, (uint64_t)a3)) {
    return 0;
  }
  if (llvm::DependenceInfo::isKnownPredicate((uint64_t)this, 0x21u, (uint64_t)a2, (uint64_t)a3)) {
    return 1;
  }
  uint64_t result = 0;
  *((unsigned char *)a4 + 43) = 0;
  return result;
}

BOOL sub_1CBFD8350(llvm::APInt *a1, uint64_t a2)
{
  unsigned int v2 = *((_DWORD *)a1 + 2);
  if (v2 < 0x41) {
    goto LABEL_2;
  }
  uint64_t v8 = a2;
  uint64_t v5 = a1;
  unsigned int v6 = v2 - sub_1CBAB1CB8(a1) - 64;
  a1 = v5;
  unsigned int v2 = *((_DWORD *)v5 + 2);
  if (v6 > 0xFFFFFFBE)
  {
    a2 = v8;
    if (v2 > 0x40)
    {
      uint64_t v3 = **(void **)v5;
      return v3 > a2;
    }
LABEL_2:
    uint64_t v3 = (uint64_t)(*(void *)a1 << -(char)v2) >> -(char)v2;
    return v3 > a2;
  }
  unsigned int v7 = v2 - 1;
  if (*((_DWORD *)v5 + 2) >= 0x41u) {
    a1 = (llvm::APInt *)(*(void *)v5 + 8 * (v7 >> 6));
  }
  return ((*(void *)a1 >> v7) & 1) == 0;
}

BOOL sub_1CBFD8408(unsigned int a1, unsigned int *a2, unsigned int *a3, llvm::APInt *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  unsigned int v106 = a1;
  if (a1 > 0x40) {
    llvm::APInt::initSlowCase((llvm::APInt *)&v105);
  }
  unint64_t v13 = 0xFFFFFFFFFFFFFFFFLL >> -(char)a1;
  if (a1) {
    unint64_t v14 = 0xFFFFFFFFFFFFFFFFLL >> -(char)a1;
  }
  else {
    LOBYTE(v14) = 0;
  }
  unsigned int v105 = (uint64_t *)(v14 & 1);
  unsigned int v104 = a1;
  unint64_t v103 = 0;
  unsigned int v102 = a1;
  long long __dst = 0;
  unsigned int v100 = a1;
  if (!a1) {
    LOBYTE(v13) = 0;
  }
  unsigned int v99 = (void *)(v13 & 1);
  sub_1CBF71A98((const llvm::APInt *)a2, (llvm::APInt *)&__src);
  sub_1CBF71A98((const llvm::APInt *)a3, (llvm::APInt *)&v95);
  unsigned int v94 = v98;
  uint64_t v84 = a4;
  if (v98 > 0x40) {
    operator new[]();
  }
  unint64_t v93 = (unint64_t)__src;
  unsigned int v92 = v98;
  unint64_t v91 = __src;
  llvm::APInt::sdivrem((llvm::APInt *)&__src, (const llvm::APInt *)&v95, (const llvm::APInt *)&v93, (llvm::APInt *)&v91, v15);
  while (1)
  {
    uint64_t v16 = v91;
    if (v92 < 0x41) {
      break;
    }
    int v17 = 0;
    int64_t v18 = ((unint64_t)v92 + 63) >> 6;
    do
    {
      BOOL v19 = v18-- < 1;
      if (v19) {
        break;
      }
      unint64_t v20 = *((void *)v91 + v18);
      v17 += __clz(v20);
    }
    while (!v20);
    unsigned int v21 = v92 | 0xFFFFFFC0;
    if ((v92 & 0x3F) == 0) {
      unsigned int v21 = 0;
    }
    if (v92 - v17 - v21 <= 0x40)
    {
      uint64_t v16 = *(void **)v91;
      break;
    }
LABEL_19:
    llvm::APInt::operator*((uint64_t)&v93, &v103, (uint64_t)&v89);
    if (v90 > 0x40)
    {
      llvm::APInt::flipAllBitsSlowCase((uint64_t)&v89);
    }
    else
    {
      if (v90) {
        unint64_t v22 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v90;
      }
      else {
        unint64_t v22 = 0;
      }
      unint64_t v89 = v22 & ~v89;
    }
    llvm::APInt::operator++((uint64_t)&v89);
    unsigned int v23 = v90;
    if (v90 >= 0x41)
    {
      uint64_t v34 = 0;
      uint64_t v35 = (unint64_t *)v89;
      uint64_t v36 = v105;
      unint64_t v37 = ((unint64_t)v90 + 63) >> 6;
      unint64_t v38 = v37;
      do
      {
        uint64_t v39 = *v36++;
        unint64_t v40 = v39 + *v35;
        BOOL v41 = v40 + 1 <= *v35;
        if (v34)
        {
          ++v40;
          uint64_t v34 = v41;
        }
        else
        {
          uint64_t v34 = v40 < *v35;
        }
        *v35++ = v40;
        --v38;
      }
      while (v38);
      *(void *)(v89 + 8 * (v37 - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v23;
      unsigned int v23 = v90;
      uint64_t v25 = (void *)v89;
    }
    else
    {
      if (v90) {
        unint64_t v24 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v90;
      }
      else {
        unint64_t v24 = 0;
      }
      uint64_t v25 = (void *)(v24 & ((unint64_t)v105 + v89));
    }
    if (v106 >= 0x41)
    {
      unsigned int v26 = v104;
LABEL_32:
      llvm::APInt::reallocate((uint64_t)&v105, v26);
      if (v106 <= 0x40) {
        unsigned int v105 = (uint64_t *)v103;
      }
      else {
        memcpy(v105, (const void *)v103, (((unint64_t)v106 + 63) >> 3) & 0x3FFFFFF8);
      }
      unsigned int v26 = v104;
      goto LABEL_35;
    }
    unsigned int v26 = v104;
    if (v104 > 0x40) {
      goto LABEL_32;
    }
    unsigned int v105 = (uint64_t *)v103;
    unsigned int v106 = v104;
LABEL_35:
    if (v26 > 0x40 || v23 > 0x40)
    {
      llvm::APInt::reallocate((uint64_t)&v103, v23);
      if (v104 <= 0x40) {
        unint64_t v103 = (unint64_t)v25;
      }
      else {
        memcpy((void *)v103, v25, (((unint64_t)v104 + 63) >> 3) & 0x3FFFFFF8);
      }
    }
    else
    {
      unint64_t v103 = (unint64_t)v25;
      unsigned int v104 = v23;
    }
    llvm::APInt::operator*((uint64_t)&v93, &v99, (uint64_t)&v89);
    if (v90 > 0x40)
    {
      llvm::APInt::flipAllBitsSlowCase((uint64_t)&v89);
    }
    else
    {
      if (v90) {
        unint64_t v27 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v90;
      }
      else {
        unint64_t v27 = 0;
      }
      unint64_t v89 = v27 & ~v89;
    }
    llvm::APInt::operator++((uint64_t)&v89);
    unsigned int v29 = v90;
    if (v90 >= 0x41)
    {
      uint64_t v42 = 0;
      uint64_t v43 = (unint64_t *)v89;
      uint64_t v44 = (uint64_t *)__dst;
      unint64_t v45 = ((unint64_t)v90 + 63) >> 6;
      unint64_t v46 = v45;
      do
      {
        uint64_t v47 = *v44++;
        unint64_t v48 = v47 + *v43;
        BOOL v49 = v48 + 1 <= *v43;
        if (v42)
        {
          ++v48;
          uint64_t v42 = v49;
        }
        else
        {
          uint64_t v42 = v48 < *v43;
        }
        *v43++ = v48;
        --v46;
      }
      while (v46);
      *(void *)(v89 + 8 * (v45 - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v29;
      unsigned int v29 = v90;
      long long v31 = (void *)v89;
    }
    else
    {
      if (v90) {
        unint64_t v30 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v90;
      }
      else {
        unint64_t v30 = 0;
      }
      long long v31 = (void *)(v30 & ((unint64_t)__dst + v89));
    }
    if (v102 >= 0x41)
    {
      unsigned int v32 = v100;
LABEL_52:
      llvm::APInt::reallocate((uint64_t)&__dst, v32);
      if (v102 <= 0x40) {
        long long __dst = v99;
      }
      else {
        memcpy(__dst, v99, (((unint64_t)v102 + 63) >> 3) & 0x3FFFFFF8);
      }
      unsigned int v32 = v100;
      goto LABEL_55;
    }
    unsigned int v32 = v100;
    if (v100 > 0x40) {
      goto LABEL_52;
    }
    long long __dst = v99;
    unsigned int v102 = v100;
LABEL_55:
    if (v32 > 0x40 || v29 > 0x40)
    {
      llvm::APInt::reallocate((uint64_t)&v99, v29);
      if (v100 <= 0x40) {
        unsigned int v99 = v31;
      }
      else {
        memcpy(v99, v31, (((unint64_t)v100 + 63) >> 3) & 0x3FFFFFF8);
      }
    }
    else
    {
      unsigned int v99 = v31;
      unsigned int v100 = v29;
    }
    unsigned int v33 = v96;
    if (v98 > 0x40 || v96 > 0x40)
    {
      llvm::APInt::reallocate((uint64_t)&__src, v96);
      if (v98 <= 0x40) {
        long long __src = v95;
      }
      else {
        memcpy(__src, v95, (((unint64_t)v98 + 63) >> 3) & 0x3FFFFFF8);
      }
      unsigned int v33 = v96;
    }
    else
    {
      long long __src = v95;
      unsigned int v98 = v96;
    }
    if (v33 > 0x40 || v92 > 0x40)
    {
      llvm::APInt::reallocate((uint64_t)&v95, v92);
      if (v96 <= 0x40) {
        int64_t v95 = v91;
      }
      else {
        memcpy(v95, v91, (((unint64_t)v96 + 63) >> 3) & 0x3FFFFFF8);
      }
    }
    else
    {
      int64_t v95 = v91;
      unsigned int v96 = v92;
    }
    llvm::APInt::sdivrem((llvm::APInt *)&__src, (const llvm::APInt *)&v95, (const llvm::APInt *)&v93, (llvm::APInt *)&v91, v28);
    if (v29 >= 0x41 && v31) {
      MEMORY[0x1D25D9CB0](v31, 0x1000C8000313F17);
    }
    if (v23 >= 0x41)
    {
      if (v25) {
        MEMORY[0x1D25D9CB0](v25, 0x1000C8000313F17);
      }
    }
  }
  if (v16) {
    goto LABEL_19;
  }
  if (*(_DWORD *)(a5 + 8) > 0x40u || (unsigned int v50 = v96, v96 > 0x40))
  {
    if (&v95 != (void **)a5)
    {
      llvm::APInt::reallocate(a5, v96);
      uint64_t v55 = *(unsigned int *)(a5 + 8);
      if (v55 <= 0x40) {
        *(void *)a5 = v95;
      }
      else {
        memcpy(*(void **)a5, v95, ((unint64_t)(v55 + 63) >> 3) & 0x3FFFFFF8);
      }
    }
  }
  else
  {
    *(void *)a5 = v95;
    *(_DWORD *)(a5 + 8) = v50;
  }
  uint64_t v51 = a2[2];
  if (v51 >= 0x41)
  {
    BOOL v56 = *(void **)a2;
    int v57 = v51 - 64;
    if ((*(void *)(*(void *)a2 + 8 * ((v51 - 1) >> 6)) >> (v51 - 1)))
    {
      if (v57 - llvm::APInt::countLeadingOnesSlowCase((llvm::APInt *)a2) < 0xFFFFFFBF) {
        goto LABEL_122;
      }
    }
    else
    {
      int v58 = 0;
      int64_t v59 = (unint64_t)(v51 + 63) >> 6;
      do
      {
        BOOL v19 = v59-- < 1;
        if (v19) {
          break;
        }
        unint64_t v60 = v56[v59];
        v58 += __clz(v60);
      }
      while (!v60);
      if ((v51 & 0x3F) != 0) {
        int v61 = v51 | 0xFFFFFFC0;
      }
      else {
        int v61 = 0;
      }
      if ((v57 - v58 - v61) < 0xFFFFFFBF)
      {
LABEL_106:
        unsigned int v52 = v104;
        if (v104 > 0x40) {
          operator new[]();
        }
        int v53 = 0;
        unint64_t v54 = v103;
        goto LABEL_127;
      }
    }
    if ((*v56 & 0x8000000000000000) != 0) {
      goto LABEL_122;
    }
    goto LABEL_106;
  }
  if ((((uint64_t)(*(void *)a2 << -(char)v51) >> -(char)v51) & 0x8000000000000000) == 0) {
    goto LABEL_106;
  }
LABEL_122:
  unsigned int v88 = v104;
  if (v104 > 0x40) {
    operator new[]();
  }
  unint64_t v62 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v104;
  if (!v104) {
    unint64_t v62 = 0;
  }
  unint64_t v87 = v62 & ~v103;
  llvm::APInt::operator++((uint64_t)&v87);
  unsigned int v52 = v88;
  unint64_t v54 = v87;
  int v53 = 1;
  unsigned int v88 = 0;
LABEL_127:
  if (*(_DWORD *)(a6 + 8) >= 0x41u && *(void *)a6) {
    MEMORY[0x1D25D9CB0](*(void *)a6, 0x1000C8000313F17);
  }
  *(void *)a6 = v54;
  *(_DWORD *)(a6 + 8) = v52;
  if (v88 > 0x40) {
    int v63 = v53;
  }
  else {
    int v63 = 0;
  }
  if (v63 == 1 && v87) {
    MEMORY[0x1D25D9CB0](v87, 0x1000C8000313F17);
  }
  uint64_t v64 = a3[2];
  if (v64 >= 0x41)
  {
    uint64_t v69 = *(void **)a3;
    int v70 = v64 - 64;
    if ((*(void *)(*(void *)a3 + 8 * ((v64 - 1) >> 6)) >> (v64 - 1)))
    {
      if (v70 - llvm::APInt::countLeadingOnesSlowCase((llvm::APInt *)a3) < 0xFFFFFFBF) {
        goto LABEL_152;
      }
    }
    else
    {
      int v71 = 0;
      int64_t v72 = (unint64_t)(v64 + 63) >> 6;
      do
      {
        BOOL v19 = v72-- < 1;
        if (v19) {
          break;
        }
        unint64_t v73 = v69[v72];
        v71 += __clz(v73);
      }
      while (!v73);
      if ((v64 & 0x3F) != 0) {
        int v74 = v64 | 0xFFFFFFC0;
      }
      else {
        int v74 = 0;
      }
      if ((v70 - v71 - v74) < 0xFFFFFFBF)
      {
LABEL_138:
        unsigned int v86 = v100;
        if (v100 > 0x40) {
          operator new[]();
        }
        unint64_t v65 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v100;
        if (!v100) {
          unint64_t v65 = 0;
        }
        unint64_t v85 = v65 & ~(unint64_t)v99;
        llvm::APInt::operator++((uint64_t)&v85);
        char v66 = 0;
        unsigned int v67 = v86;
        unint64_t v68 = v85;
        unsigned int v86 = 0;
        goto LABEL_155;
      }
    }
    if ((*v69 & 0x8000000000000000) != 0) {
      goto LABEL_152;
    }
    goto LABEL_138;
  }
  if ((((uint64_t)(*(void *)a3 << -(char)v64) >> -(char)v64) & 0x8000000000000000) == 0) {
    goto LABEL_138;
  }
LABEL_152:
  unsigned int v67 = v100;
  if (v100 > 0x40) {
    operator new[]();
  }
  char v66 = 1;
  unint64_t v68 = (unint64_t)v99;
LABEL_155:
  if (*(_DWORD *)(a7 + 8) >= 0x41u && *(void *)a7) {
    MEMORY[0x1D25D9CB0](*(void *)a7, 0x1000C8000313F17);
  }
  *(void *)a7 = v68;
  *(_DWORD *)(a7 + 8) = v67;
  if (v86 < 0x41) {
    char v75 = 1;
  }
  else {
    char v75 = v66;
  }
  if ((v75 & 1) == 0 && v85) {
    MEMORY[0x1D25D9CB0](v85, 0x1000C8000313F17);
  }
  llvm::APInt::srem(v84, (const llvm::APInt *)a5, (uint64_t)&v89);
  if (v92 >= 0x41 && v91) {
    MEMORY[0x1D25D9CB0](v91, 0x1000C8000313F17);
  }
  unint64_t v76 = v89;
  unint64_t v91 = (void *)v89;
  unsigned int v77 = v90;
  unsigned int v92 = v90;
  if (v90 < 0x41)
  {
LABEL_175:
    BOOL v82 = v76 != 0;
    if (!v76)
    {
      llvm::APInt::sdiv(v84, (const llvm::APInt *)a5, (uint64_t)&v89);
      if (v94 >= 0x41 && v93) {
        MEMORY[0x1D25D9CB0](v93, 0x1000C8000313F17);
      }
      unint64_t v93 = v89;
      unsigned int v94 = v90;
      unsigned int v77 = v92;
    }
    if (v77 < 0x41 || !v91) {
      goto LABEL_183;
    }
LABEL_182:
    MEMORY[0x1D25D9CB0]();
    goto LABEL_183;
  }
  int v78 = 0;
  int64_t v79 = ((unint64_t)v90 + 63) >> 6;
  do
  {
    BOOL v19 = v79-- < 1;
    if (v19) {
      break;
    }
    unint64_t v80 = *(void *)(v89 + 8 * v79);
    v78 += __clz(v80);
  }
  while (!v80);
  unsigned int v81 = v90 | 0xFFFFFFC0;
  if ((v90 & 0x3F) == 0) {
    unsigned int v81 = 0;
  }
  if (v90 - v78 - v81 <= 0x40)
  {
    unint64_t v76 = *(void *)v89;
    goto LABEL_175;
  }
  BOOL v82 = 1;
  if (v89) {
    goto LABEL_182;
  }
LABEL_183:
  if (v94 >= 0x41 && v93) {
    MEMORY[0x1D25D9CB0](v93, 0x1000C8000313F17);
  }
  if (v96 >= 0x41 && v95) {
    MEMORY[0x1D25D9CB0](v95, 0x1000C8000313F17);
  }
  if (v98 >= 0x41 && __src) {
    MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
  }
  if (v100 >= 0x41 && v99) {
    MEMORY[0x1D25D9CB0](v99, 0x1000C8000313F17);
  }
  if (v102 >= 0x41 && __dst) {
    MEMORY[0x1D25D9CB0](__dst, 0x1000C8000313F17);
  }
  if (v104 >= 0x41 && v103) {
    MEMORY[0x1D25D9CB0](v103, 0x1000C8000313F17);
  }
  if (v106 >= 0x41 && v105) {
    MEMORY[0x1D25D9CB0](v105, 0x1000C8000313F17);
  }
  return v82;
}

uint64_t sub_1CBFD9168@<X0>(uint64_t result@<X0>, llvm::APInt *a2@<X8>)
{
  *((_DWORD *)a2 + 2) = result;
  if (result > 0x40) {
    llvm::APInt::initSlowCase(a2);
  }
  unint64_t v3 = 0xFFFFFFFFFFFFFFFFLL >> -(char)result;
  if (!result) {
    unint64_t v3 = 0;
  }
  *(void *)a2 = v3;
  *(void *)a2 &= ~(1 << (result - 1));
  return result;
}

void sub_1CBFD91F8(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 8);
  unint64_t v5 = *(void *)a1;
  if (v4 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v7 = v4 + 1;
    unint64_t v8 = v5 + 16 * v4;
    if (v5 <= a2 && v8 > a2)
    {
      unint64_t v10 = a2 - v5;
      sub_1CBFC6948(a1, v7);
      unint64_t v5 = *(void *)a1;
      a2 = *(void *)a1 + v10;
    }
    else
    {
      sub_1CBFC6948(a1, v7);
      unint64_t v5 = *(void *)a1;
    }
  }
  unint64_t v6 = v5 + 16 * *(unsigned int *)(a1 + 8);
  *(_DWORD *)(v6 + 8) = *(_DWORD *)(a2 + 8);
  *(void *)unint64_t v6 = *(void *)a2;
  *(_DWORD *)(a2 + 8) = 0;
  ++*(_DWORD *)(a1 + 8);
}

void sub_1CBFD9290(uint64_t a1, llvm::APInt *this, llvm::APInt *a3, uint64_t a4, llvm::APInt *a5)
{
  unsigned int v8 = *((_DWORD *)this + 2);
  unsigned int v54 = v8;
  if (v8 > 0x40) {
    operator new[]();
  }
  long long __src = *(void **)this;
  unsigned int v52 = v8;
  uint64_t v51 = __src;
  llvm::APInt::sdivrem(this, a3, (const llvm::APInt *)&__src, (llvm::APInt *)&v51, a5);
  unsigned int v9 = v52;
  unint64_t v10 = v51;
  if (v52 >= 0x41)
  {
    int v11 = 0;
    int64_t v12 = ((unint64_t)v52 + 63) >> 6;
    do
    {
      BOOL v13 = v12-- < 1;
      if (v13) {
        break;
      }
      unint64_t v14 = v51[v12];
      v11 += __clz(v14);
    }
    while (!v14);
    unsigned int v15 = v52 | 0xFFFFFFC0;
    if ((v52 & 0x3F) == 0) {
      unsigned int v15 = 0;
    }
    if (v52 - v11 - v15 > 0x40) {
      goto LABEL_13;
    }
    unint64_t v10 = (void *)*v51;
  }
  if (!v10) {
    goto LABEL_48;
  }
LABEL_13:
  uint64_t v16 = *((unsigned int *)this + 2);
  if (v16 >= 0x41)
  {
    int v17 = *(uint64_t **)this;
    uint64_t v21 = 1 << (v16 - 1);
    uint64_t v22 = *(void *)(*(void *)this + 8 * ((v16 - 1) >> 6));
    uint64_t v47 = *((unsigned int *)this + 2);
    int v23 = v16 - 64;
    int v24 = v22 & v21;
    if ((v22 & v21) != 0)
    {
      if (v23 - llvm::APInt::countLeadingOnesSlowCase(this) < 0xFFFFFFBF) {
        goto LABEL_57;
      }
    }
    else
    {
      int64_t v25 = (unint64_t)(v47 + 63) >> 6;
      do
      {
        BOOL v13 = v25-- < 1;
        if (v13) {
          break;
        }
        unint64_t v26 = v17[v25];
        v24 += __clz(v26);
      }
      while (!v26);
      if ((v47 & 0x3F) != 0) {
        int v27 = v47 | 0xFFFFFFC0;
      }
      else {
        int v27 = 0;
      }
      if ((v23 - v24 - v27) < 0xFFFFFFBF)
      {
        uint64_t v16 = *((unsigned int *)this + 2);
        goto LABEL_16;
      }
    }
    uint64_t v18 = *v17;
    uint64_t v16 = v47;
  }
  else
  {
    int v17 = *(uint64_t **)this;
    uint64_t v18 = (uint64_t)(*(void *)this << -(char)v16) >> -(char)v16;
  }
  if (v18 < 1) {
    goto LABEL_44;
  }
LABEL_16:
  uint64_t v19 = *((unsigned int *)a3 + 2);
  if (v19 >= 0x41)
  {
    uint64_t v48 = v16;
    unint64_t v28 = *(uint64_t **)a3;
    int v29 = v19 - 64;
    if ((*(void *)(*(void *)a3 + 8 * ((v19 - 1) >> 6)) >> (v19 - 1)))
    {
      int v35 = llvm::APInt::countLeadingOnesSlowCase(a3);
      uint64_t v16 = v48;
      if ((v29 - v35) < 0xFFFFFFBF) {
        goto LABEL_44;
      }
    }
    else
    {
      int v30 = 0;
      int64_t v31 = (unint64_t)(v19 + 63) >> 6;
      do
      {
        BOOL v13 = v31-- < 1;
        if (v13) {
          break;
        }
        unint64_t v32 = v28[v31];
        v30 += __clz(v32);
      }
      while (!v32);
      if ((v19 & 0x3F) != 0) {
        int v33 = v19 | 0xFFFFFFC0;
      }
      else {
        int v33 = 0;
      }
      BOOL v34 = __CFADD__(v29 - v30 - v33, 65);
      uint64_t v16 = v48;
      if (!v34) {
        goto LABEL_19;
      }
    }
    uint64_t v20 = *v28;
  }
  else
  {
    uint64_t v20 = (uint64_t)(*(void *)a3 << -(char)v19) >> -(char)v19;
  }
  if (v20 <= 0)
  {
LABEL_44:
    if (v16 < 0x41)
    {
      if ((((uint64_t)((void)v17 << -(char)v16) >> -(char)v16) & 0x8000000000000000) == 0) {
        goto LABEL_48;
      }
      goto LABEL_46;
    }
    uint64_t v21 = 1 << (v16 - 1);
    uint64_t v22 = v17[(v16 - 1) >> 6];
    uint64_t v47 = v16;
    int v23 = v16 - 64;
LABEL_57:
    if ((v22 & v21) != 0)
    {
      if (v23 - llvm::APInt::countLeadingOnesSlowCase(this) < 0xFFFFFFBF)
      {
LABEL_46:
        uint64_t v36 = *((unsigned int *)a3 + 2);
        if (v36 >= 0x41)
        {
          BOOL v41 = *(void **)a3;
          int v42 = v36 - 64;
          if ((*(void *)(*(void *)a3 + 8 * ((v36 - 1) >> 6)) >> (v36 - 1)))
          {
            if (v42 - llvm::APInt::countLeadingOnesSlowCase(a3) < 0xFFFFFFBF) {
              goto LABEL_19;
            }
          }
          else
          {
            int v43 = 0;
            int64_t v44 = (unint64_t)(v36 + 63) >> 6;
            do
            {
              BOOL v13 = v44-- < 1;
              if (v13) {
                break;
              }
              unint64_t v45 = v41[v44];
              v43 += __clz(v45);
            }
            while (!v45);
            if ((v36 & 0x3F) != 0) {
              int v46 = v36 | 0xFFFFFFC0;
            }
            else {
              int v46 = 0;
            }
            if ((v42 - v43 - v46) < 0xFFFFFFBF) {
              goto LABEL_48;
            }
          }
          if ((*v41 & 0x8000000000000000) != 0) {
            goto LABEL_19;
          }
        }
        else if ((uint64_t)(*(void *)a3 << -(char)v36) >> -(char)v36 < 0)
        {
          goto LABEL_19;
        }
LABEL_48:
        *(_DWORD *)(a1 + 8) = v54;
        *(void *)a1 = __src;
        unsigned int v54 = 0;
        goto LABEL_49;
      }
    }
    else
    {
      int v37 = 0;
      int64_t v38 = (unint64_t)(v47 + 63) >> 6;
      do
      {
        BOOL v13 = v38-- < 1;
        if (v13) {
          break;
        }
        unint64_t v39 = v17[v38];
        v37 += __clz(v39);
      }
      while (!v39);
      if ((v47 & 0x3F) != 0) {
        int v40 = v47 | 0xFFFFFFC0;
      }
      else {
        int v40 = 0;
      }
      if ((v23 - v37 - v40) < 0xFFFFFFBF) {
        goto LABEL_48;
      }
    }
    if ((*v17 & 0x8000000000000000) == 0) {
      goto LABEL_48;
    }
    goto LABEL_46;
  }
LABEL_19:
  unsigned int v50 = v54;
  if (v54 > 0x40) {
    operator new[]();
  }
  BOOL v49 = __src;
  llvm::APInt::operator+=((uint64_t)&v49, 1uLL);
  *(_DWORD *)(a1 + 8) = v50;
  *(void *)a1 = v49;
  unsigned int v50 = 0;
  unsigned int v9 = v52;
LABEL_49:
  if (v9 >= 0x41 && v51) {
    MEMORY[0x1D25D9CB0](v51, 0x1000C8000313F17);
  }
  if (v54 >= 0x41)
  {
    if (__src) {
      MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
    }
  }
}

void sub_1CBFD9768(uint64_t a1, llvm::APInt *this, llvm::APInt *a3, uint64_t a4, llvm::APInt *a5)
{
  unsigned int v8 = *((_DWORD *)this + 2);
  unsigned int v54 = v8;
  if (v8 > 0x40) {
    operator new[]();
  }
  long long __src = *(void **)this;
  unsigned int v52 = v8;
  uint64_t v51 = __src;
  llvm::APInt::sdivrem(this, a3, (const llvm::APInt *)&__src, (llvm::APInt *)&v51, a5);
  unsigned int v9 = v52;
  unint64_t v10 = v51;
  if (v52 >= 0x41)
  {
    int v11 = 0;
    int64_t v12 = ((unint64_t)v52 + 63) >> 6;
    do
    {
      BOOL v13 = v12-- < 1;
      if (v13) {
        break;
      }
      unint64_t v14 = v51[v12];
      v11 += __clz(v14);
    }
    while (!v14);
    unsigned int v15 = v52 | 0xFFFFFFC0;
    if ((v52 & 0x3F) == 0) {
      unsigned int v15 = 0;
    }
    if (v52 - v11 - v15 > 0x40) {
      goto LABEL_13;
    }
    unint64_t v10 = (void *)*v51;
  }
  if (!v10)
  {
LABEL_19:
    *(_DWORD *)(a1 + 8) = v54;
    *(void *)a1 = __src;
    unsigned int v54 = 0;
    goto LABEL_49;
  }
LABEL_13:
  uint64_t v16 = *((unsigned int *)this + 2);
  if (v16 < 0x41)
  {
    int v17 = *(uint64_t **)this;
    uint64_t v18 = (uint64_t)(*(void *)this << -(char)v16) >> -(char)v16;
    goto LABEL_15;
  }
  int v17 = *(uint64_t **)this;
  uint64_t v21 = 1 << (v16 - 1);
  uint64_t v22 = *(void *)(*(void *)this + 8 * ((v16 - 1) >> 6));
  uint64_t v47 = *((unsigned int *)this + 2);
  int v23 = v16 - 64;
  int v24 = v22 & v21;
  if ((v22 & v21) != 0)
  {
    if (v23 - llvm::APInt::countLeadingOnesSlowCase(this) < 0xFFFFFFBF) {
      goto LABEL_57;
    }
    goto LABEL_40;
  }
  int64_t v25 = (unint64_t)(v47 + 63) >> 6;
  do
  {
    BOOL v13 = v25-- < 1;
    if (v13) {
      break;
    }
    unint64_t v26 = v17[v25];
    v24 += __clz(v26);
  }
  while (!v26);
  if ((v47 & 0x3F) != 0) {
    int v27 = v47 | 0xFFFFFFC0;
  }
  else {
    int v27 = 0;
  }
  if ((v23 - v24 - v27) >= 0xFFFFFFBF)
  {
LABEL_40:
    uint64_t v18 = *v17;
    uint64_t v16 = v47;
LABEL_15:
    if (v18 < 1) {
      goto LABEL_42;
    }
    goto LABEL_16;
  }
  uint64_t v16 = *((unsigned int *)this + 2);
LABEL_16:
  uint64_t v19 = *((unsigned int *)a3 + 2);
  if (v19 < 0x41)
  {
    uint64_t v20 = (uint64_t)(*(void *)a3 << -(char)v19) >> -(char)v19;
    goto LABEL_18;
  }
  uint64_t v48 = v16;
  unint64_t v28 = *(uint64_t **)a3;
  int v29 = v19 - 64;
  if (((*(void *)(*(void *)a3 + 8 * ((v19 - 1) >> 6)) >> (v19 - 1)) & 1) == 0)
  {
    int v30 = 0;
    int64_t v31 = (unint64_t)(v19 + 63) >> 6;
    do
    {
      BOOL v13 = v31-- < 1;
      if (v13) {
        break;
      }
      unint64_t v32 = v28[v31];
      v30 += __clz(v32);
    }
    while (!v32);
    if ((v19 & 0x3F) != 0) {
      int v33 = v19 | 0xFFFFFFC0;
    }
    else {
      int v33 = 0;
    }
    BOOL v34 = __CFADD__(v29 - v30 - v33, 65);
    uint64_t v16 = v48;
    if (!v34) {
      goto LABEL_19;
    }
    goto LABEL_38;
  }
  int v35 = llvm::APInt::countLeadingOnesSlowCase(a3);
  uint64_t v16 = v48;
  if ((v29 - v35) >= 0xFFFFFFBF)
  {
LABEL_38:
    uint64_t v20 = *v28;
LABEL_18:
    if (v20 > 0) {
      goto LABEL_19;
    }
  }
LABEL_42:
  if (v16 < 0x41)
  {
    if ((((uint64_t)((void)v17 << -(char)v16) >> -(char)v16) & 0x8000000000000000) == 0) {
      goto LABEL_46;
    }
    goto LABEL_44;
  }
  uint64_t v21 = 1 << (v16 - 1);
  uint64_t v22 = v17[(v16 - 1) >> 6];
  uint64_t v47 = v16;
  int v23 = v16 - 64;
LABEL_57:
  if ((v22 & v21) == 0)
  {
    int v37 = 0;
    int64_t v38 = (unint64_t)(v47 + 63) >> 6;
    do
    {
      BOOL v13 = v38-- < 1;
      if (v13) {
        break;
      }
      unint64_t v39 = v17[v38];
      v37 += __clz(v39);
    }
    while (!v39);
    if ((v47 & 0x3F) != 0) {
      int v40 = v47 | 0xFFFFFFC0;
    }
    else {
      int v40 = 0;
    }
    if ((v23 - v37 - v40) < 0xFFFFFFBF) {
      goto LABEL_46;
    }
LABEL_65:
    if ((*v17 & 0x8000000000000000) == 0) {
      goto LABEL_46;
    }
    goto LABEL_44;
  }
  if (v23 - llvm::APInt::countLeadingOnesSlowCase(this) >= 0xFFFFFFBF) {
    goto LABEL_65;
  }
LABEL_44:
  uint64_t v36 = *((unsigned int *)a3 + 2);
  if (v36 >= 0x41)
  {
    BOOL v41 = *(void **)a3;
    int v42 = v36 - 64;
    if ((*(void *)(*(void *)a3 + 8 * ((v36 - 1) >> 6)) >> (v36 - 1)))
    {
      if (v42 - llvm::APInt::countLeadingOnesSlowCase(a3) < 0xFFFFFFBF) {
        goto LABEL_19;
      }
    }
    else
    {
      int v43 = 0;
      int64_t v44 = (unint64_t)(v36 + 63) >> 6;
      do
      {
        BOOL v13 = v44-- < 1;
        if (v13) {
          break;
        }
        unint64_t v45 = v41[v44];
        v43 += __clz(v45);
      }
      while (!v45);
      if ((v36 & 0x3F) != 0) {
        int v46 = v36 | 0xFFFFFFC0;
      }
      else {
        int v46 = 0;
      }
      if ((v42 - v43 - v46) < 0xFFFFFFBF) {
        goto LABEL_46;
      }
    }
    if ((*v41 & 0x8000000000000000) != 0) {
      goto LABEL_19;
    }
  }
  else if ((uint64_t)(*(void *)a3 << -(char)v36) >> -(char)v36 < 0)
  {
    goto LABEL_19;
  }
LABEL_46:
  unsigned int v50 = v54;
  if (v54 > 0x40) {
    operator new[]();
  }
  BOOL v49 = __src;
  llvm::APInt::operator-=((uint64_t)&v49, 1uLL);
  *(_DWORD *)(a1 + 8) = v50;
  *(void *)a1 = v49;
  unsigned int v50 = 0;
  unsigned int v9 = v52;
LABEL_49:
  if (v9 >= 0x41 && v51) {
    MEMORY[0x1D25D9CB0](v51, 0x1000C8000313F17);
  }
  if (v54 >= 0x41)
  {
    if (__src) {
      MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
    }
  }
}

BOOL sub_1CBFD9C40(uint64_t a1, uint64_t a2)
{
  llvm::APInt::srem((llvm::APInt *)(a1 + 24), (const llvm::APInt *)(a2 + 24), (uint64_t)&v10);
  if (v11 >= 0x41)
  {
    int v3 = 0;
    int64_t v4 = ((unint64_t)v11 + 63) >> 6;
    do
    {
      if (v4-- < 1) {
        break;
      }
      unint64_t v6 = v10[v4];
      v3 += __clz(v6);
    }
    while (!v6);
    unsigned int v7 = v11 | 0xFFFFFFC0;
    if ((v11 & 0x3F) == 0) {
      unsigned int v7 = 0;
    }
    if (v11 - v3 - v7 > 0x40)
    {
      BOOL v8 = 0;
      uint64_t v2 = 0;
      if (!v10) {
        return v2;
      }
    }
    else
    {
      BOOL v8 = *v10 == 0;
    }
    MEMORY[0x1D25D9CB0](v10, 0x1000C8000313F17);
    return v8;
  }
  return v10 == 0;
}

uint64_t llvm::DependenceInfo::gcdMIVtest(llvm::DependenceInfo *this, const llvm::SCEV *a2, const llvm::SCEV *a3, llvm::FullDependence *a4)
{
  v164[3] = *MEMORY[0x1E4F143B8];
  BOOL v8 = a2;
  while (2)
  {
    switch(*((_WORD *)v8 + 12))
    {
      case 1:
      case 2:
      case 3:
      case 0xD:
        unint64_t v10 = (uint64_t *)((char *)v8 + 40);
        goto LABEL_9;
      case 4:
        unint64_t v10 = (uint64_t *)((char *)v8 + 48);
        goto LABEL_9;
      case 5:
      case 7:
      case 8:
      case 9:
      case 0xA:
      case 0xB:
      case 0xC:
        unsigned int v9 = (const llvm::SCEV **)*((void *)v8 + 4);
        goto LABEL_4;
      case 6:
        unsigned int v9 = (const llvm::SCEV **)((char *)v8 + 40);
LABEL_4:
        BOOL v8 = *v9;
        continue;
      case 0xE:
        unint64_t v10 = (uint64_t *)*((void *)v8 - 1);
        goto LABEL_9;
      default:
        unint64_t v10 = (uint64_t *)*((void *)v8 + 4);
LABEL_9:
        uint64_t v11 = *v10;
        unsigned int v12 = *(_DWORD *)(*v10 + 8);
        uint64_t v13 = *(void *)(**((void **)this + 1) + 40);
        if (v12 == 15)
        {
          if ((v12 & 0xFE) == 0x12) {
            unsigned int v12 = *(_DWORD *)(**(void **)(v11 + 16) + 8);
          }
          uint64_t v108 = *(void *)(v13 + 504);
          if (v12 < 0x100) {
            goto LABEL_368;
          }
          unsigned int v109 = v12 >> 8;
          unint64_t v110 = *(unsigned int *)(v13 + 512);
          uint64_t v111 = *(void *)(v13 + 504);
          if (v110)
          {
            uint64_t v111 = v108;
            unint64_t v112 = v110;
            do
            {
              unint64_t v113 = v112 >> 1;
              uint64_t v114 = v111 + 16 * (v112 >> 1);
              unsigned int v115 = *(_DWORD *)(v114 + 8);
              uint64_t v116 = v114 + 16;
              v112 += ~(v112 >> 1);
              if (v115 < v109) {
                uint64_t v111 = v116;
              }
              else {
                unint64_t v112 = v113;
              }
            }
            while (v112);
          }
          if (v111 == v108 + 16 * v110 || *(_DWORD *)(v111 + 8) != v109) {
LABEL_368:
          }
            uint64_t v111 = v108;
          unsigned int v15 = *(_DWORD *)(v111 + 12);
        }
        else
        {
          unsigned int v15 = sub_1CB83544C(v13 + 272, v11);
          if (v14 == 1) {
        }
          }
        unsigned int v161 = v15;
        if (v15 > 0x40) {
          llvm::APInt::initSlowCase((llvm::APInt *)&v160);
        }
        unsigned int v160 = 0;
        uint64_t v16 = a2;
        if (!a2) {
          goto LABEL_56;
        }
        uint64_t v16 = a2;
        if (*((_WORD *)a2 + 12) != 7) {
          goto LABEL_56;
        }
        uint64_t v16 = a2;
        break;
    }
    break;
  }
  do
  {
    uint64_t v17 = *((void *)v16 + 5);
    if (v17 == 2)
    {
      uint64_t v18 = *(void *)(*((void *)v16 + 4) + 8);
    }
    else
    {
      unsigned int v121 = (llvm::ScalarEvolution *)*((void *)this + 1);
      uint64_t v23 = *((void *)v16 + 4);
      unint64_t v162 = v164;
      uint64_t v163 = 0x300000000;
      unint64_t v24 = 8 * v17 - 8;
      if (v24 >= 0x19) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      int v25 = 0;
      if (v17 != 1)
      {
        memcpy(v162, (const void *)(v23 + 8), 8 * v17 - 8);
        int v25 = v163;
      }
      LODWORD(v163) = v25 + (v24 >> 3);
      uint64_t v18 = sub_1CD478318(v121, (uint64_t)&v162, *((const llvm::Loop **)v16 + 6), 0);
      if (v162 != v164) {
        free(v162);
      }
    }
    int v19 = *(unsigned __int16 *)(v18 + 24);
    if (v18) {
      BOOL v20 = v19 == 0;
    }
    else {
      BOOL v20 = 0;
    }
    if (!v20)
    {
      if (v19 != 5) {
        goto LABEL_135;
      }
      uint64_t v18 = **(void **)(v18 + 32);
      if (!v18 || *(_WORD *)(v18 + 24) != 0) {
        goto LABEL_135;
      }
    }
    uint64_t v22 = *(void *)(v18 + 32);
    LODWORD(v163) = *(_DWORD *)(v22 + 32);
    if (v163 > 0x40) {
      operator new[]();
    }
    unint64_t v162 = *(void **)(v22 + 24);
    unsigned int v157 = v161;
    if (v161 > 0x40) {
      operator new[]();
    }
    unsigned int v156 = v160;
    sub_1CBF71A98((const llvm::APInt *)&v162, (llvm::APInt *)&v154);
    llvm::APIntOps::GreatestCommonDivisor((uint64_t)&v156, (uint64_t)&v154, (uint64_t)&v158);
    if (v161 >= 0x41 && v160) {
      MEMORY[0x1D25D9CB0](v160, 0x1000C8000313F17);
    }
    unsigned int v160 = v158;
    unsigned int v161 = v159;
    unsigned int v159 = 0;
    if (v155 >= 0x41 && v154) {
      MEMORY[0x1D25D9CB0](v154, 0x1000C8000313F17);
    }
    if (v157 >= 0x41 && v156) {
      MEMORY[0x1D25D9CB0](v156, 0x1000C8000313F17);
    }
    uint64_t v16 = (const llvm::SCEV *)**((void **)v16 + 4);
    if (v163 >= 0x41 && v162) {
      MEMORY[0x1D25D9CB0](v162, 0x1000C8000313F17);
    }
  }
  while (v16 && *((_WORD *)v16 + 12) == 7);
LABEL_56:
  unint64_t v26 = a3;
  if (a3)
  {
    unint64_t v26 = a3;
    if (*((_WORD *)a3 + 12) == 7)
    {
      unint64_t v26 = a3;
      while (1)
      {
        uint64_t v27 = *((void *)v26 + 5);
        if (v27 == 2)
        {
          uint64_t v28 = *(void *)(*((void *)v26 + 4) + 8);
        }
        else
        {
          uint64_t v120 = *((void *)v26 + 4);
          int v122 = (llvm::ScalarEvolution *)*((void *)this + 1);
          unint64_t v162 = v164;
          uint64_t v163 = 0x300000000;
          unint64_t v33 = 8 * v27 - 8;
          if (v33 >= 0x19) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          int v34 = 0;
          if (v27 != 1)
          {
            memcpy(v162, (const void *)(v120 + 8), 8 * v27 - 8);
            int v34 = v163;
          }
          LODWORD(v163) = v34 + (v33 >> 3);
          uint64_t v28 = sub_1CD478318(v122, (uint64_t)&v162, *((const llvm::Loop **)v26 + 6), 0);
          if (v162 != v164) {
            free(v162);
          }
        }
        int v29 = *(unsigned __int16 *)(v28 + 24);
        if (!v28 || v29 != 0)
        {
          if (v29 != 5) {
            break;
          }
          uint64_t v28 = **(void **)(v28 + 32);
          if (!v28 || *(_WORD *)(v28 + 24) != 0) {
            break;
          }
        }
        uint64_t v32 = *(void *)(v28 + 32);
        LODWORD(v163) = *(_DWORD *)(v32 + 32);
        if (v163 > 0x40) {
          operator new[]();
        }
        unint64_t v162 = *(void **)(v32 + 24);
        unsigned int v153 = v161;
        if (v161 > 0x40) {
          operator new[]();
        }
        uint64_t v152 = v160;
        sub_1CBF71A98((const llvm::APInt *)&v162, (llvm::APInt *)&v150);
        llvm::APIntOps::GreatestCommonDivisor((uint64_t)&v152, (uint64_t)&v150, (uint64_t)&v158);
        if (v161 >= 0x41 && v160) {
          MEMORY[0x1D25D9CB0](v160, 0x1000C8000313F17);
        }
        unsigned int v160 = v158;
        unsigned int v161 = v159;
        unsigned int v159 = 0;
        if (v151 >= 0x41 && v150) {
          MEMORY[0x1D25D9CB0](v150, 0x1000C8000313F17);
        }
        if (v153 >= 0x41 && v152) {
          MEMORY[0x1D25D9CB0](v152, 0x1000C8000313F17);
        }
        unint64_t v26 = (const llvm::SCEV *)**((void **)v26 + 4);
        if (v163 >= 0x41 && v162) {
          MEMORY[0x1D25D9CB0](v162, 0x1000C8000313F17);
        }
        if (!v26 || *((_WORD *)v26 + 12) != 7) {
          goto LABEL_99;
        }
      }
LABEL_135:
      uint64_t v48 = 0;
      goto LABEL_174;
    }
  }
LABEL_99:
  unsigned int v159 = v15;
  int v158 = 0;
  unint64_t MinusSCEV = llvm::ScalarEvolution::getMinusSCEV(*((llvm::ScalarEvolution **)this + 1), v26, v16, 0, 0);
  if (*(_WORD *)(MinusSCEV + 24)) {
    unint64_t v36 = 0;
  }
  else {
    unint64_t v36 = MinusSCEV;
  }
  if (!MinusSCEV) {
    goto LABEL_131;
  }
  if (*(_WORD *)(MinusSCEV + 24) != 4) {
    goto LABEL_131;
  }
  unint64_t v37 = MinusSCEV;
  if (!*(_DWORD *)(MinusSCEV + 40)) {
    goto LABEL_131;
  }
  uint64_t v38 = 0;
  unint64_t v39 = v159;
  uint64_t v40 = 8 * *(unsigned int *)(MinusSCEV + 40);
  while (1)
  {
    uint64_t v41 = *(void *)(*(void *)(v37 + 32) + v38);
    if (*(_WORD *)(v41 + 24)) {
      break;
    }
    unint64_t v36 = *(void *)(*(void *)(v37 + 32) + v38);
LABEL_129:
    v38 += 8;
    if (v40 == v38)
    {
      unsigned int v159 = v39;
LABEL_131:
      if (!v36)
      {
        uint64_t v48 = 0;
LABEL_170:
        unint64_t v39 = v159;
        goto LABEL_171;
      }
      uint64_t v45 = *(void *)(v36 + 32);
      unsigned int v46 = *(_DWORD *)(v45 + 32);
      unsigned int v149 = v46;
      if (v46 > 0x40) {
        operator new[]();
      }
      unsigned int v148 = *(void **)(v45 + 24);
      unsigned int v47 = v46;
      if (!v148)
      {
        uint64_t v48 = 0;
LABEL_167:
        if (v47 >= 0x41 && v148) {
          MEMORY[0x1D25D9CB0](v148, 0x1000C8000313F17);
        }
        goto LABEL_170;
      }
      unsigned int v143 = v161;
      if (v161 > 0x40) {
        operator new[]();
      }
      unsigned int v142 = v160;
      unsigned int v141 = v159;
      if (v159 > 0x40) {
        operator new[]();
      }
      unsigned int v140 = v158;
      llvm::APIntOps::GreatestCommonDivisor((uint64_t)&v142, (uint64_t)&v140, (uint64_t)&v162);
      if (v161 >= 0x41 && v160) {
        MEMORY[0x1D25D9CB0](v160, 0x1000C8000313F17);
      }
      unsigned int v160 = v162;
      unsigned int v161 = v163;
      LODWORD(v163) = 0;
      if (v141 >= 0x41 && v140) {
        MEMORY[0x1D25D9CB0](v140, 0x1000C8000313F17);
      }
      if (v143 >= 0x41 && v142) {
        MEMORY[0x1D25D9CB0](v142, 0x1000C8000313F17);
      }
      llvm::APInt::srem((llvm::APInt *)&v148, (const llvm::APInt *)&v160, (uint64_t)&v138);
      BOOL v49 = v138;
      if (v139 >= 0x41)
      {
        int v50 = 0;
        int64_t v51 = ((unint64_t)v139 + 63) >> 6;
        do
        {
          BOOL v52 = v51-- < 1;
          if (v52) {
            break;
          }
          unint64_t v53 = v138[v51];
          v50 += __clz(v53);
        }
        while (!v53);
        unsigned int v54 = v139 | 0xFFFFFFC0;
        if ((v139 & 0x3F) == 0) {
          unsigned int v54 = 0;
        }
        if (v139 - v50 - v54 > 0x40) {
          goto LABEL_162;
        }
        BOOL v49 = (void *)*v138;
      }
      if (v49)
      {
LABEL_162:
        uint64_t v48 = 1;
        goto LABEL_163;
      }
      uint64_t v48 = 0;
      if (!a2 || *((_WORD *)a2 + 12) != 7)
      {
LABEL_163:
        if (v139 >= 0x41 && v138) {
          MEMORY[0x1D25D9CB0](v138, 0x1000C8000313F17);
        }
        unsigned int v47 = v149;
        goto LABEL_167;
      }
      BOOL v56 = a2;
LABEL_182:
      int v57 = (void *)*((void *)v56 + 6);
      unint64_t v123 = (const llvm::SCEV *)**((void **)v56 + 4);
      if (v161 > 0x40 || v159 > 0x40)
      {
        llvm::APInt::reallocate((uint64_t)&v160, v159);
        if (v161 <= 0x40) {
          unsigned int v160 = v158;
        }
        else {
          memcpy(v160, v158, (((unint64_t)v161 + 63) >> 3) & 0x3FFFFFF8);
        }
      }
      else
      {
        unsigned int v160 = v158;
        unsigned int v161 = v159;
      }
      int v58 = (llvm::ScalarEvolution *)*((void *)this + 1);
      uint64_t v59 = *((void *)v56 + 5);
      if (v59 == 2)
      {
        unint64_t v60 = *(llvm::SCEV **)(*((void *)v56 + 4) + 8);
      }
      else
      {
        uint64_t v105 = *((void *)v56 + 4);
        unint64_t v162 = v164;
        uint64_t v163 = 0x300000000;
        unint64_t v106 = 8 * v59 - 8;
        if (v106 >= 0x19) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        int v107 = 0;
        if (v59 != 1)
        {
          memcpy(v162, (const void *)(v105 + 8), 8 * v59 - 8);
          int v107 = v163;
        }
        LODWORD(v163) = v107 + (v106 >> 3);
        unint64_t v60 = (llvm::SCEV *)sub_1CD478318(v58, (uint64_t)&v162, *((const llvm::Loop **)v56 + 6), 0);
        if (v162 != v164) {
          free(v162);
        }
        int v58 = (llvm::ScalarEvolution *)*((void *)this + 1);
      }
      int v61 = (const llvm::APInt *)llvm::ScalarEvolution::getMinusSCEV(v58, v60, v60, 0, 0);
      for (uint64_t i = a2; ; uint64_t i = (const llvm::SCEV *)**((void **)i + 4))
      {
        unsigned int v63 = v161;
        uint64_t v64 = v160;
        if (v161 >= 0x41)
        {
          int v65 = 0;
          int64_t v66 = ((unint64_t)v161 + 63) >> 6;
          do
          {
            BOOL v52 = v66-- < 1;
            if (v52) {
              break;
            }
            unint64_t v67 = v160[v66];
            v65 += __clz(v67);
          }
          while (!v67);
          unsigned int v68 = v161 | 0xFFFFFFC0;
          if ((v161 & 0x3F) == 0) {
            unsigned int v68 = 0;
          }
          if (v161 - v65 - v68 > 0x40) {
            goto LABEL_199;
          }
          uint64_t v64 = (void *)*v160;
        }
        if (v64 == (void *)1) {
          goto LABEL_240;
        }
LABEL_199:
        if (*((_WORD *)i + 12) != 7)
        {
LABEL_240:
          unint64_t v76 = a3;
          while (1)
          {
            if (v63 > 0x40)
            {
              int v79 = 0;
              int64_t v80 = ((unint64_t)v63 + 63) >> 6;
              int v78 = v160;
              do
              {
                BOOL v52 = v80-- < 1;
                if (v52) {
                  break;
                }
                unint64_t v81 = v160[v80];
                v79 += __clz(v81);
              }
              while (!v81);
              unsigned int v82 = v63 | 0xFFFFFFC0;
              if ((v63 & 0x3F) == 0) {
                unsigned int v82 = 0;
              }
              unsigned int v77 = (llvm::ScalarEvolution *)*((void *)this + 1);
              if (v63 - v79 - v82 > 0x40) {
                goto LABEL_250;
              }
            }
            else
            {
              unsigned int v77 = (llvm::ScalarEvolution *)*((void *)this + 1);
              int v78 = &v160;
            }
            if (*v78 == 1) {
              goto LABEL_292;
            }
LABEL_250:
            if (*((_WORD *)v76 + 12) != 7)
            {
LABEL_292:
              unint64_t v90 = llvm::ScalarEvolution::getMinusSCEV(v77, v60, v61, 0, 0);
              if (v90 && !*(_WORD *)(v90 + 24))
              {
                unint64_t v91 = v123;
                goto LABEL_295;
              }
              unint64_t v91 = v123;
              if (*(_WORD *)(v90 + 24) == 5)
              {
                unint64_t v90 = **(void **)(v90 + 32);
                if (v90 && *(_WORD *)(v90 + 24) == 0)
                {
LABEL_295:
                  uint64_t v92 = *(void *)(v90 + 32);
                  LODWORD(v163) = *(_DWORD *)(v92 + 32);
                  if (v163 > 0x40) {
                    operator new[]();
                  }
                  unint64_t v162 = *(void **)(v92 + 24);
                  unsigned int v127 = v161;
                  if (v161 > 0x40) {
                    operator new[]();
                  }
                  unsigned int v126 = v160;
                  sub_1CBF71A98((const llvm::APInt *)&v162, (llvm::APInt *)&v124);
                  llvm::APIntOps::GreatestCommonDivisor((uint64_t)&v126, (uint64_t)&v124, (uint64_t)&v136);
                  if (v161 >= 0x41 && v160) {
                    MEMORY[0x1D25D9CB0](v160, 0x1000C8000313F17);
                  }
                  unsigned int v160 = v136;
                  unsigned int v161 = v137;
                  unsigned int v137 = 0;
                  if (v125 >= 0x41 && v124) {
                    MEMORY[0x1D25D9CB0](v124, 0x1000C8000313F17);
                  }
                  if (v127 >= 0x41 && v126) {
                    MEMORY[0x1D25D9CB0](v126, 0x1000C8000313F17);
                  }
                  unsigned int v94 = v160;
                  if (v161 < 0x41)
                  {
LABEL_324:
                    if (v94) {
                      goto LABEL_325;
                    }
                  }
                  else
                  {
                    int v95 = 0;
                    int64_t v96 = ((unint64_t)v161 + 63) >> 6;
                    do
                    {
                      BOOL v52 = v96-- < 1;
                      if (v52) {
                        break;
                      }
                      unint64_t v97 = v160[v96];
                      v95 += __clz(v97);
                    }
                    while (!v97);
                    unsigned int v98 = v161 | 0xFFFFFFC0;
                    if ((v161 & 0x3F) == 0) {
                      unsigned int v98 = 0;
                    }
                    if (v161 - v95 - v98 <= 0x40)
                    {
                      unsigned int v94 = (void *)*v160;
                      goto LABEL_324;
                    }
LABEL_325:
                    llvm::APInt::srem((llvm::APInt *)&v148, (const llvm::APInt *)&v160, (uint64_t)&v136);
                    if (v139 >= 0x41 && v138) {
                      MEMORY[0x1D25D9CB0](v138, 0x1000C8000313F17);
                    }
                    unsigned int v99 = v136;
                    unsigned int v138 = v136;
                    unsigned int v139 = v137;
                    if (v137 < 0x41)
                    {
LABEL_336:
                      if (v99) {
                        goto LABEL_337;
                      }
                    }
                    else
                    {
                      int v100 = 0;
                      int64_t v101 = ((unint64_t)v137 + 63) >> 6;
                      do
                      {
                        BOOL v52 = v101-- < 1;
                        if (v52) {
                          break;
                        }
                        unint64_t v102 = v136[v101];
                        v100 += __clz(v102);
                      }
                      while (!v102);
                      unsigned int v103 = v137 | 0xFFFFFFC0;
                      if ((v137 & 0x3F) == 0) {
                        unsigned int v103 = 0;
                      }
                      if (v137 - v100 - v103 <= 0x40)
                      {
                        unsigned int v99 = (void *)*v136;
                        goto LABEL_336;
                      }
LABEL_337:
                      unsigned int v104 = -1;
                      do
                      {
                        int v57 = (void *)*v57;
                        ++v104;
                      }
                      while (v57);
                      *(unsigned char *)(*((void *)a4 + 6) + 16 * v104) &= ~2u;
                    }
                  }
                  if (v163 >= 0x41 && v162) {
                    MEMORY[0x1D25D9CB0](v162, 0x1000C8000313F17);
                  }
                }
              }
              uint64_t v48 = 0;
              if (!v91) {
                goto LABEL_163;
              }
              BOOL v56 = v91;
              if (*((_WORD *)v91 + 12) != 7) {
                goto LABEL_163;
              }
              goto LABEL_182;
            }
            uint64_t v83 = *((void *)v76 + 5);
            if (v83 == 2)
            {
              uint64_t v84 = *(void *)(*((void *)v76 + 4) + 8);
            }
            else
            {
              uint64_t v88 = *((void *)v76 + 4);
              unint64_t v162 = v164;
              uint64_t v163 = 0x300000000;
              size_t v119 = 8 * v83 - 8;
              if (v119 >= 0x19) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              int v89 = 0;
              if (v83 != 1)
              {
                memcpy(v162, (const void *)(v88 + 8), v119);
                int v89 = v163;
              }
              LODWORD(v163) = v89 + (v119 >> 3);
              uint64_t v84 = sub_1CD478318(v77, (uint64_t)&v162, *((const llvm::Loop **)v76 + 6), 0);
              if (v162 != v164) {
                free(v162);
              }
            }
            if (v57 == *((void **)v76 + 6))
            {
              int v61 = (const llvm::APInt *)v84;
            }
            else
            {
              if (*(_WORD *)(v84 + 24)) {
                BOOL v85 = 1;
              }
              else {
                BOOL v85 = v84 == 0;
              }
              if (v85)
              {
                if (*(_WORD *)(v84 + 24) != 5) {
                  goto LABEL_356;
                }
                uint64_t v84 = **(void **)(v84 + 32);
                if (!v84 || *(_WORD *)(v84 + 24) != 0) {
                  goto LABEL_356;
                }
              }
              uint64_t v87 = *(void *)(v84 + 32);
              LODWORD(v163) = *(_DWORD *)(v87 + 32);
              if (v163 > 0x40) {
                operator new[]();
              }
              unint64_t v162 = *(void **)(v87 + 24);
              unsigned int v131 = v161;
              if (v161 > 0x40) {
                operator new[]();
              }
              unsigned int v130 = v160;
              sub_1CBF71A98((const llvm::APInt *)&v162, (llvm::APInt *)&v128);
              llvm::APIntOps::GreatestCommonDivisor((uint64_t)&v130, (uint64_t)&v128, (uint64_t)&v136);
              if (v161 >= 0x41 && v160) {
                MEMORY[0x1D25D9CB0](v160, 0x1000C8000313F17);
              }
              unsigned int v160 = v136;
              unsigned int v161 = v137;
              unsigned int v137 = 0;
              if (v129 >= 0x41 && v128) {
                MEMORY[0x1D25D9CB0](v128, 0x1000C8000313F17);
              }
              if (v131 >= 0x41 && v130) {
                MEMORY[0x1D25D9CB0](v130, 0x1000C8000313F17);
              }
              if (v163 >= 0x41 && v162) {
                MEMORY[0x1D25D9CB0](v162, 0x1000C8000313F17);
              }
            }
            unint64_t v76 = (const llvm::SCEV *)**((void **)v76 + 4);
            unsigned int v63 = v161;
          }
        }
        uint64_t v69 = *((void *)i + 5);
        if (v69 == 2)
        {
          uint64_t v70 = *(void *)(*((void *)i + 4) + 8);
        }
        else
        {
          uint64_t v117 = *((void *)i + 4);
          int v118 = (llvm::ScalarEvolution *)*((void *)this + 1);
          unint64_t v162 = v164;
          uint64_t v163 = 0x300000000;
          size_t v74 = 8 * v69 - 8;
          if (v74 >= 0x19) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          int v75 = 0;
          if (v69 != 1)
          {
            memcpy(v162, (const void *)(v117 + 8), v74);
            int v75 = v163;
          }
          LODWORD(v163) = v75 + (v74 >> 3);
          uint64_t v70 = sub_1CD478318(v118, (uint64_t)&v162, *((const llvm::Loop **)i + 6), 0);
          if (v162 != v164) {
            free(v162);
          }
        }
        if (v57 != *((void **)i + 6))
        {
          if (*(_WORD *)(v70 + 24)) {
            BOOL v71 = 1;
          }
          else {
            BOOL v71 = v70 == 0;
          }
          if (v71)
          {
            if (*(_WORD *)(v70 + 24) != 5
              || ((uint64_t v70 = **(void **)(v70 + 32)) != 0 ? (v72 = *(unsigned __int16 *)(v70 + 24) == 0) : (v72 = 0), !v72))
            {
LABEL_356:
              uint64_t v48 = 0;
              goto LABEL_163;
            }
          }
          uint64_t v73 = *(void *)(v70 + 32);
          LODWORD(v163) = *(_DWORD *)(v73 + 32);
          if (v163 > 0x40) {
            operator new[]();
          }
          unint64_t v162 = *(void **)(v73 + 24);
          unsigned int v135 = v161;
          if (v161 > 0x40) {
            operator new[]();
          }
          unint64_t v134 = v160;
          sub_1CBF71A98((const llvm::APInt *)&v162, (llvm::APInt *)&v132);
          llvm::APIntOps::GreatestCommonDivisor((uint64_t)&v134, (uint64_t)&v132, (uint64_t)&v136);
          if (v161 >= 0x41 && v160) {
            MEMORY[0x1D25D9CB0](v160, 0x1000C8000313F17);
          }
          unsigned int v160 = v136;
          unsigned int v161 = v137;
          unsigned int v137 = 0;
          if (v133 >= 0x41 && v132) {
            MEMORY[0x1D25D9CB0](v132, 0x1000C8000313F17);
          }
          if (v135 >= 0x41 && v134) {
            MEMORY[0x1D25D9CB0](v134, 0x1000C8000313F17);
          }
          if (v163 >= 0x41 && v162) {
            MEMORY[0x1D25D9CB0](v162, 0x1000C8000313F17);
          }
        }
      }
    }
  }
  if (*(_WORD *)(v41 + 24) == 5)
  {
    uint64_t v42 = **(void **)(v41 + 32);
    if (v42 && *(_WORD *)(v42 + 24) == 0)
    {
      uint64_t v44 = *(void *)(v42 + 32);
      LODWORD(v163) = *(_DWORD *)(v44 + 32);
      if (v163 > 0x40) {
        operator new[]();
      }
      unint64_t v162 = *(void **)(v44 + 24);
      unsigned int v147 = v39;
      if (v39 > 0x40) {
        operator new[]();
      }
      unsigned int v146 = v158;
      sub_1CBF71A98((const llvm::APInt *)&v162, (llvm::APInt *)&v144);
      llvm::APIntOps::GreatestCommonDivisor((uint64_t)&v146, (uint64_t)&v144, (uint64_t)&v148);
      int v158 = v148;
      unint64_t v39 = v149;
      unsigned int v149 = 0;
      if (v145 >= 0x41 && v144) {
        MEMORY[0x1D25D9CB0](v144, 0x1000C8000313F17);
      }
      if (v147 >= 0x41 && v146) {
        MEMORY[0x1D25D9CB0](v146, 0x1000C8000313F17);
      }
      if (v163 >= 0x41 && v162) {
        MEMORY[0x1D25D9CB0](v162, 0x1000C8000313F17);
      }
      goto LABEL_129;
    }
  }
  uint64_t v48 = 0;
LABEL_171:
  if (v39 >= 0x41 && v158) {
    MEMORY[0x1D25D9CB0](v158, 0x1000C8000313F17);
  }
LABEL_174:
  if (v161 >= 0x41 && v160) {
    MEMORY[0x1D25D9CB0](v160, 0x1000C8000313F17);
  }
  return v48;
}

uint64_t llvm::DependenceInfo::testMIV(llvm::DependenceInfo *a1, const llvm::SCEV *a2, const llvm::SCEV *a3, int a4, llvm::FullDependence *a5)
{
  *((unsigned char *)a5 + 43) = 0;
  if ((llvm::DependenceInfo::gcdMIVtest(a1, a2, a3, a5) & 1) == 0)
  {
    llvm::DependenceInfo::banerjeeMIVtest(a1, a2);
  }
  return 1;
}

void llvm::DependenceInfo::banerjeeMIVtest(llvm::DependenceInfo *a1, const llvm::SCEV *a2)
{
  uint64_t v2 = 0;
  llvm::DependenceInfo::collectCoeffInfo(a1, a2, 1, &v2);
}

void llvm::DependenceInfo::collectCoeffInfo(llvm::DependenceInfo *this, const llvm::SCEV *a2, BOOL a3, const llvm::SCEV **a4)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  int64_t v4 = (llvm::ScalarEvolution *)*((void *)this + 1);
  while (2)
  {
    switch(*((_WORD *)a2 + 12))
    {
      case 1:
      case 2:
      case 3:
      case 0xD:
        unsigned int v7 = (llvm::Type **)((char *)a2 + 40);
        goto LABEL_9;
      case 4:
        unsigned int v7 = (llvm::Type **)((char *)a2 + 48);
        goto LABEL_9;
      case 5:
      case 7:
      case 8:
      case 9:
      case 0xA:
      case 0xB:
      case 0xC:
        unint64_t v6 = (const llvm::SCEV **)*((void *)a2 + 4);
        goto LABEL_4;
      case 6:
        unint64_t v6 = (const llvm::SCEV **)((char *)a2 + 40);
LABEL_4:
        a2 = *v6;
        continue;
      case 0xE:
        unsigned int v7 = (llvm::Type **)*((void *)a2 - 1);
        goto LABEL_9;
      default:
        unsigned int v7 = (llvm::Type **)*((void *)a2 + 4);
LABEL_9:
        llvm::ScalarEvolution::getConstant(v4, *v7, 0, 0);
        operator new[]();
    }
  }
}

uint64_t llvm::DependenceInfo::getNegativePart(llvm::DependenceInfo *this, const llvm::SCEV *a2)
{
  int v3 = (llvm::ScalarEvolution *)*((void *)this + 1);
  int64_t v4 = a2;
  while (2)
  {
    switch(*((_WORD *)v4 + 12))
    {
      case 1:
      case 2:
      case 3:
      case 0xD:
        unint64_t v6 = (llvm::Type **)((char *)v4 + 40);
        goto LABEL_9;
      case 4:
        unint64_t v6 = (llvm::Type **)((char *)v4 + 48);
        goto LABEL_9;
      case 5:
      case 7:
      case 8:
      case 9:
      case 0xA:
      case 0xB:
      case 0xC:
        unint64_t v5 = (const llvm::SCEV **)*((void *)v4 + 4);
        goto LABEL_4;
      case 6:
        unint64_t v5 = (const llvm::SCEV **)((char *)v4 + 40);
LABEL_4:
        int64_t v4 = *v5;
        continue;
      case 0xE:
        unint64_t v6 = (llvm::Type **)*((void *)v4 - 1);
        goto LABEL_9;
      default:
        unint64_t v6 = (llvm::Type **)*((void *)v4 + 4);
LABEL_9:
        unint64_t Constant = (const llvm::SCEV *)llvm::ScalarEvolution::getConstant(*((llvm::ScalarEvolution **)this + 1), *v6, 0, 0);
        return llvm::ScalarEvolution::getSMinExpr(v3, a2, Constant);
    }
  }
}

uint64_t llvm::DependenceInfo::getPositivePart(llvm::DependenceInfo *this, const llvm::SCEV *a2)
{
  int v3 = (llvm::ScalarEvolution *)*((void *)this + 1);
  int64_t v4 = a2;
  while (2)
  {
    switch(*((_WORD *)v4 + 12))
    {
      case 1:
      case 2:
      case 3:
      case 0xD:
        unint64_t v6 = (llvm::Type **)((char *)v4 + 40);
        goto LABEL_9;
      case 4:
        unint64_t v6 = (llvm::Type **)((char *)v4 + 48);
        goto LABEL_9;
      case 5:
      case 7:
      case 8:
      case 9:
      case 0xA:
      case 0xB:
      case 0xC:
        unint64_t v5 = (const llvm::SCEV **)*((void *)v4 + 4);
        goto LABEL_4;
      case 6:
        unint64_t v5 = (const llvm::SCEV **)((char *)v4 + 40);
LABEL_4:
        int64_t v4 = *v5;
        continue;
      case 0xE:
        unint64_t v6 = (llvm::Type **)*((void *)v4 - 1);
        goto LABEL_9;
      default:
        unint64_t v6 = (llvm::Type **)*((void *)v4 + 4);
LABEL_9:
        unint64_t Constant = (const llvm::SCEV *)llvm::ScalarEvolution::getConstant(*((llvm::ScalarEvolution **)this + 1), *v6, 0, 0);
        return llvm::ScalarEvolution::getSMaxExpr(v3, a2, Constant);
    }
  }
}

uint64_t llvm::DependenceInfo::tryDelinearizeParametricSize(llvm::ScalarEvolution **a1, unsigned __int8 *a2, unsigned __int8 *a3, llvm::SCEV *a4, const llvm::SCEV *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v13 = 0;
  v48[4] = *MEMORY[0x1E4F143B8];
  if (a2 && a2[16] - 62 >= 0xFFFFFFFE) {
    uint64_t v13 = (llvm::Value *)*((void *)a2 - 4);
  }
  unint64_t v14 = 0;
  int v43 = v13;
  if (a3 && a3[16] - 62 >= 0xFFFFFFFE) {
    unint64_t v14 = (llvm::Value *)*((void *)a3 - 4);
  }
  uint64_t v42 = v14;
  PointerBase = llvm::ScalarEvolution::getPointerBase(a1[1], a4);
  int v16 = *((unsigned __int16 *)PointerBase + 12);
  uint64_t v17 = llvm::ScalarEvolution::getPointerBase(a1[1], a5);
  int v18 = *((unsigned __int16 *)v17 + 12);
  ElementSize = (const llvm::SCEV ***)llvm::ScalarEvolution::getElementSize(a1[1], (llvm::Instruction *)a2);
  if (ElementSize != (const llvm::SCEV ***)llvm::ScalarEvolution::getElementSize(a1[1], (llvm::Instruction *)a3)) {
    return 0;
  }
  uint64_t v22 = (char *)v17 - 32;
  uint64_t v23 = (char *)PointerBase - 32;
  if (v16 != 14) {
    uint64_t v23 = 0;
  }
  unint64_t v24 = (const llvm::APInt *)(v23 + 32);
  if (v16 == 14) {
    int v25 = v24;
  }
  else {
    int v25 = 0;
  }
  unint64_t MinusSCEV = llvm::ScalarEvolution::getMinusSCEV(a1[1], a4, v25, 0, 0);
  if (v18 == 14) {
    uint64_t v27 = v22;
  }
  else {
    uint64_t v27 = 0;
  }
  uint64_t v28 = (const llvm::APInt *)(v27 + 32);
  if (v18 == 14) {
    int v29 = v28;
  }
  else {
    int v29 = 0;
  }
  unint64_t v30 = llvm::ScalarEvolution::getMinusSCEV(a1[1], a5, v29, 0, 0);
  uint64_t v20 = 0;
  if (*(_WORD *)(MinusSCEV + 24) == 7) {
    uint64_t v31 = MinusSCEV;
  }
  else {
    uint64_t v31 = 0;
  }
  if (*(_WORD *)(v30 + 24) == 7) {
    uint64_t v32 = v30;
  }
  else {
    uint64_t v32 = 0;
  }
  if (v31) {
    BOOL v33 = v32 == 0;
  }
  else {
    BOOL v33 = 1;
  }
  if (!v33)
  {
    if (*(void *)(v31 + 40) != 2 || *(void *)(v32 + 40) != 2) {
      return 0;
    }
    v47[0] = v48;
    v47[1] = (void *)0x400000000;
    llvm::collectParametricTerms((uint64_t)a1[1], v31, (uint64_t)v47);
    llvm::collectParametricTerms((uint64_t)a1[1], v32, (uint64_t)v47);
    v45[0] = v46;
    v45[1] = (void *)0x400000000;
    llvm::findArrayDimensions(a1[1], (uint64_t)v47, (uint64_t)v45, ElementSize);
    llvm::computeAccessFunctions(a1[1], v31, a6, (uint64_t)v45, v34, v35);
    llvm::computeAccessFunctions(a1[1], v32, a7, (uint64_t)v45, v36, v37);
    uint64_t v38 = *(unsigned int *)(a6 + 8);
    if (v38 >= 2)
    {
      uint64_t v20 = 0;
      unsigned int v39 = *(_DWORD *)(a7 + 8);
      if (v39 < 2 || v38 != v39) {
        goto LABEL_39;
      }
      if (byte_1EBCC5430)
      {
        uint64_t v20 = 1;
        goto LABEL_39;
      }
      uint64_t v40 = 0;
      uint64_t v41 = 8 * v38 - 8;
      uint64_t v20 = 1;
      while (llvm::DependenceInfo::isKnownNonNegative(a1, *(const llvm::SCEV **)(*(void *)a6 + v40 + 8), v43)
           && llvm::DependenceInfo::isKnownLessThan(a1, *(llvm::detail::IEEEFloat ***)(*(void *)a6 + v40 + 8), *(llvm::detail::IEEEFloat ***)((char *)v45[0] + v40))&& llvm::DependenceInfo::isKnownNonNegative(a1, *(const llvm::SCEV **)(*(void *)a7 + v40 + 8), v42)&& (llvm::DependenceInfo::isKnownLessThan(a1, *(llvm::detail::IEEEFloat ***)(*(void *)a7 + v40 + 8), *(llvm::detail::IEEEFloat ***)((char *)v45[0] + v40)) & 1) != 0)
      {
        v40 += 8;
        if (v41 == v40) {
          goto LABEL_39;
        }
      }
    }
    uint64_t v20 = 0;
LABEL_39:
    if (v45[0] != v46) {
      free(v45[0]);
    }
    if (v47[0] != v48) {
      free(v47[0]);
    }
  }
  return v20;
}

BOOL sub_1CBFDC168(llvm::ScalarEvolution **a1, void *a2, unsigned int *a3, const llvm::Value *a4)
{
  unint64_t v4 = a3[2];
  if (v4 >= 2)
  {
    uint64_t v11 = *(llvm::detail::IEEEFloat ***)(*(void *)a3 + 8);
    BOOL v5 = 0;
    if (llvm::DependenceInfo::isKnownNonNegative(a1, (const llvm::SCEV *)v11, a4))
    {
      uint64_t v13 = 1;
LABEL_6:
      unint64_t v14 = v11;
      while (2)
      {
        switch(*((_WORD *)v14 + 12))
        {
          case 1:
          case 2:
          case 3:
          case 0xD:
            int v16 = (llvm::ConstantInt ***)(v14 + 5);
            goto LABEL_14;
          case 4:
            int v16 = (llvm::ConstantInt ***)(v14 + 6);
            goto LABEL_14;
          case 5:
          case 7:
          case 8:
          case 9:
          case 0xA:
          case 0xB:
          case 0xC:
            unsigned int v15 = (llvm::detail::IEEEFloat ***)v14[4];
            goto LABEL_9;
          case 6:
            unsigned int v15 = (llvm::detail::IEEEFloat ***)(v14 + 5);
LABEL_9:
            unint64_t v14 = *v15;
            continue;
          case 0xE:
            int v16 = (llvm::ConstantInt ***)*(v14 - 1);
            goto LABEL_14;
          default:
            int v16 = (llvm::ConstantInt ***)v14[4];
LABEL_14:
            uint64_t v17 = *v16;
            unint64_t v18 = *((unsigned int *)*v16 + 2);
            if (v17) {
              BOOL v19 = v18 == 13;
            }
            else {
              BOOL v19 = 0;
            }
            if (v19)
            {
              uint64_t v20 = a1[1];
              uint64_t v21 = *(int *)(*a2 + 4 * v13 - 4);
              uint64_t v22 = *v17;
              unsigned int v29 = v18 >> 8;
              uint64_t v27 = v20;
              if (v18 >> 8 > 0x40) {
                operator new[]();
              }
              unint64_t v23 = v18 <= 0xFF ? 0 : 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v18) + 63);
              unint64_t v28 = v23 & v21;
              unint64_t v24 = (llvm::ConstantInt *)llvm::ConstantInt::get(v22, (llvm::LLVMContext *)&v28, v12);
              if (v29 >= 0x41 && v28)
              {
                unint64_t v26 = v24;
                MEMORY[0x1D25D9CB0](v28, 0x1000C8000313F17);
                unint64_t v24 = v26;
              }
              unint64_t Constant = (llvm::detail::IEEEFloat **)llvm::ScalarEvolution::getConstant(v27, v24);
              if (!llvm::DependenceInfo::isKnownLessThan(a1, v11, Constant)) {
                return v5;
              }
            }
            BOOL v5 = ++v13 >= v4;
            if (v13 == v4) {
              return v5;
            }
            uint64_t v11 = *(llvm::detail::IEEEFloat ***)(*(void *)a3 + 8 * v13);
            if (!llvm::DependenceInfo::isKnownNonNegative(a1, (const llvm::SCEV *)v11, a4)) {
              return v5;
            }
            goto LABEL_6;
        }
      }
    }
  }
  else
  {
    return 1;
  }
  return v5;
}

uint64_t llvm::DependenceInfo::depends@<X0>(uint64_t this@<X0>, llvm::Instruction *a2@<X1>, llvm::Instruction *a3@<X2>, char a4@<W3>, void *a5@<X8>)
{
  uint64_t v7 = this;
  uint64_t v355 = *MEMORY[0x1E4F143B8];
  if (a2 == a3) {
    char v9 = 0;
  }
  else {
    char v9 = a4;
  }
  int v10 = *((unsigned __int8 *)a2 + 16);
  uint64_t v11 = (v10 - 33);
  if (v11 <= 0x37)
  {
    if (((1 << (v10 - 33)) & 0x8000000000041) != 0)
    {
      uint64_t v13 = *((void *)a2 + 8);
      if (!v13 || (*(unsigned char *)(v13 + 20) & 4) == 0 && (*(unsigned char *)(v13 + 17) & 0x10) == 0)
      {
        LODWORD(v350) = 7;
        this = sub_1CC5CB59C((uint64_t)a2, (__int32 *)&v350, 1uLL);
        if (this)
        {
          uint64_t v308 = *((void *)a2 - 4);
          if (!v308
            || *(unsigned char *)(v308 + 16)
            || *(void *)(v308 + 24) != *((void *)a2 + 9)
            || *(_DWORD *)(v308 + 36) != 7)
          {
            goto LABEL_30;
          }
        }
        this = llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)a2, 66);
        if ((this & 1) == 0)
        {
          this = llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)a2, 44);
          if (!this) {
            goto LABEL_30;
          }
        }
      }
    }
    else
    {
      if (((1 << (v10 - 33)) & 0x808001C8000010) != 0) {
        goto LABEL_30;
      }
      if (v11 != 28) {
        goto LABEL_8;
      }
      if ((*((_WORD *)a2 + 9) & 0x301) != 0) {
        goto LABEL_30;
      }
    }
    int v10 = *((unsigned __int8 *)a2 + 16);
  }
LABEL_8:
  uint64_t v12 = (v10 - 33);
  if (v12 > 0x37)
  {
LABEL_12:
    *a5 = 0;
    return this;
  }
  if (((1 << v12) & 0x8000000000041) != 0)
  {
    uint64_t v14 = *((void *)a2 + 8);
    if (v14 && (*(unsigned char *)(v14 + 17) & 0x30) != 0) {
      goto LABEL_12;
    }
    int v15 = *((_DWORD *)a2 + 5);
    if (v15 < 0
      && (uint64_t v309 = (char *)a2 - 32 * (v15 & 0x7FFFFFF), v312 = *((void *)v309 - 1), v310 = v309 - 8, (v311 = v312) != 0))
    {
      uint64_t v313 = -v311;
      while (1)
      {
        unsigned int v314 = *(_DWORD *)(*(void *)&v310[v313] + 8);
        BOOL v315 = v314 > 7;
        int v316 = (1 << v314) & 0x83;
        if (v315 || v316 == 0) {
          break;
        }
        v313 += 16;
        if (!v313) {
          goto LABEL_24;
        }
      }
    }
    else
    {
LABEL_24:
      this = llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)a2, 45);
      if (this) {
        goto LABEL_12;
      }
      this = llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)a2, 44);
      if (this) {
        goto LABEL_12;
      }
    }
  }
  else if (v12 == 27)
  {
    if ((*((_WORD *)a2 + 9) & 0x301) == 0) {
      goto LABEL_12;
    }
  }
  else if (((1 << v12) & 0x808001D0000010) == 0)
  {
    goto LABEL_12;
  }
LABEL_30:
  int v16 = *((unsigned __int8 *)a3 + 16);
  uint64_t v17 = (v16 - 33);
  if (v17 <= 0x37)
  {
    if (((1 << (v16 - 33)) & 0x8000000000041) != 0)
    {
      uint64_t v19 = *((void *)a3 + 8);
      if (!v19 || (*(unsigned char *)(v19 + 20) & 4) == 0 && (*(unsigned char *)(v19 + 17) & 0x10) == 0)
      {
        LODWORD(v350) = 7;
        if (sub_1CC5CB59C((uint64_t)a3, (__int32 *)&v350, 1uLL))
        {
          uint64_t v318 = *((void *)a3 - 4);
          if (!v318
            || *(unsigned char *)(v318 + 16)
            || *(void *)(v318 + 24) != *((void *)a3 + 9)
            || *(_DWORD *)(v318 + 36) != 7)
          {
            goto LABEL_55;
          }
        }
        this = llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)a3, 66);
        if ((this & 1) == 0)
        {
          this = llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)a3, 44);
          if (!this) {
            goto LABEL_55;
          }
        }
      }
    }
    else
    {
      if (((1 << (v16 - 33)) & 0x808001C8000010) != 0) {
        goto LABEL_55;
      }
      if (v17 != 28) {
        goto LABEL_34;
      }
      if ((*((_WORD *)a3 + 9) & 0x301) != 0) {
        goto LABEL_55;
      }
    }
    int v16 = *((unsigned __int8 *)a3 + 16);
  }
LABEL_34:
  uint64_t v18 = (v16 - 33);
  if (v18 > 0x37) {
    goto LABEL_12;
  }
  if (((1 << v18) & 0x8000000000041) != 0)
  {
    uint64_t v20 = *((void *)a3 + 8);
    if (v20 && (*(unsigned char *)(v20 + 17) & 0x30) != 0) {
      goto LABEL_12;
    }
    int v21 = *((_DWORD *)a3 + 5);
    if (v21 < 0
      && (int v319 = (char *)a3 - 32 * (v21 & 0x7FFFFFF), v322 = *((void *)v319 - 1), v320 = v319 - 8, (v321 = v322) != 0))
    {
      uint64_t v323 = -v321;
      while (1)
      {
        unsigned int v324 = *(_DWORD *)(*(void *)&v320[v323] + 8);
        BOOL v315 = v324 > 7;
        int v325 = (1 << v324) & 0x83;
        if (v315 || v325 == 0) {
          break;
        }
        v323 += 16;
        if (!v323) {
          goto LABEL_49;
        }
      }
    }
    else
    {
LABEL_49:
      this = llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)a3, 45);
      if (this) {
        goto LABEL_12;
      }
      this = llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)a3, 44);
      if (this) {
        goto LABEL_12;
      }
    }
  }
  else if (v18 == 27)
  {
    if ((*((_WORD *)a3 + 9) & 0x301) == 0) {
      goto LABEL_12;
    }
  }
  else if (((1 << v18) & 0x808001D0000010) == 0)
  {
    goto LABEL_12;
  }
LABEL_55:
  int v22 = *((unsigned __int8 *)a2 + 16);
  if (a2) {
    BOOL v23 = v22 == 60;
  }
  else {
    BOOL v23 = 0;
  }
  char v24 = !v23;
  if (!a2 || (v22 - 62) < 0xFFFFFFFE || (*((_WORD *)a2 + 9) & 0x301) != 0) {
    goto LABEL_64;
  }
  int v25 = *((unsigned __int8 *)a3 + 16);
  BOOL v26 = a3 && v25 == 60;
  BOOL v27 = !v26;
  if (!a3 || (v25 - 62) < 0xFFFFFFFE || (*((_WORD *)a3 + 9) & 0x301) != 0) {
    goto LABEL_64;
  }
  if (v22 == 61) {
    char v28 = 0;
  }
  else {
    char v28 = v24;
  }
  if (v28) {
    int v331 = 0;
  }
  else {
    int v331 = (llvm::Value *)*((void *)a2 - 4);
  }
  if (v25 != 61 && v27) {
    uint64_t v333 = 0;
  }
  else {
    uint64_t v333 = (llvm::Value *)*((void *)a3 - 4);
  }
  uint64_t v30 = *(void *)v7;
  llvm::MemoryLocation::getOrNone((uint64_t ***)a3, (uint64_t)&v350);
  *(_OWORD *)uint64_t v344 = *(_OWORD *)v351;
  *(_OWORD *)&v344[16] = *(_OWORD *)&v351[16];
  uint64_t v31 = v350;
  *(void *)&v344[32] = *(void *)&v351[32];
  llvm::MemoryLocation::getOrNone((uint64_t ***)a2, (uint64_t)&v350);
  *(_OWORD *)unsigned int v341 = *(_OWORD *)v351;
  *(_OWORD *)&v341[16] = *(_OWORD *)&v351[16];
  uint64_t v32 = (void **)v350;
  *(void *)&v341[32] = *(void *)&v351[32];
  uint64_t v350 = v31;
  *(void *)unint64_t v351 = -1;
  *(_OWORD *)&v351[8] = *(_OWORD *)&v344[8];
  *(_OWORD *)&v351[24] = *(_OWORD *)&v344[24];
  uint64_t v352 = (void ***)v32;
  uint64_t v353 = -1;
  v354[0] = *(_OWORD *)&v341[8];
  v354[1] = *(_OWORD *)&v341[24];
  this = llvm::AAResults::alias(v30, (uint64_t)&v350, (uint64_t)&v352);
  if (!(_BYTE)this) {
    goto LABEL_12;
  }
  UnderlyingObject = llvm::getUnderlyingObject(v31, (const llvm::Value *)6);
  uint64_t v34 = llvm::getUnderlyingObject((llvm *)v32, (const llvm::Value *)6);
  if (UnderlyingObject != v34)
  {
    uint64_t v36 = v34;
    if (llvm::isIdentifiedObject(UnderlyingObject, v35))
    {
      this = llvm::isIdentifiedObject(v36, v37);
      if (this) {
        goto LABEL_12;
      }
    }
LABEL_64:
    operator new();
  }
  llvm::DependenceInfo::establishNestingLevels((llvm::DependenceInfo *)v7, a2, a3);
  char v328 = v9;
  llvm::FullDependence::FullDependence((uint64_t)v344, a2, a3, v9, *(_DWORD *)(v7 + 32));
  uint64_t v350 = 0;
  *(void *)unint64_t v351 = 0;
  *(int64x2_t *)&v351[16] = vdupq_n_s64(1uLL);
  *(void *)&v351[8] = 0;
  *(void *)&v351[32] = 1;
  uint64_t v352 = (void ***)v354;
  uint64_t v353 = 0x200000000;
  sub_1CD480E9C((uint64_t)&v352, (long long *)&v350);
  uint64_t v38 = *(void *)&v351[32];
  if ((v351[32] & 1) == 0 && *(void *)&v351[32])
  {
    if (**(void **)&v351[32] != *(void *)&v351[32] + 16) {
      free(**(void ***)&v351[32]);
    }
    MEMORY[0x1D25D9CE0](v38, 0x1080C40EF38A13ELL);
  }
  uint64_t v39 = *(void *)&v351[24];
  if ((v351[24] & 1) == 0 && *(void *)&v351[24])
  {
    if (**(void **)&v351[24] != *(void *)&v351[24] + 16) {
      free(**(void ***)&v351[24]);
    }
    MEMORY[0x1D25D9CE0](v39, 0x1080C40EF38A13ELL);
  }
  uint64_t v40 = *(void *)&v351[16];
  if ((v351[16] & 1) == 0 && *(void *)&v351[16])
  {
    if (**(void **)&v351[16] != *(void *)&v351[16] + 16) {
      free(**(void ***)&v351[16]);
    }
    MEMORY[0x1D25D9CE0](v40, 0x1080C40EF38A13ELL);
  }
  uint64_t v41 = *(void *)(v7 + 8);
  uint64_t v42 = *(void *)(v41 + 104);
  unsigned int v43 = *(_DWORD *)(v41 + 120);
  if (!v43) {
    goto LABEL_100;
  }
  unsigned int v44 = v43 - 1;
  unsigned int v45 = (v43 - 1) & ((v331 >> 4) ^ (v331 >> 9));
  uint64_t v46 = v42 + 48 * v45;
  unsigned int v47 = *(llvm::Value **)(v46 + 24);
  if (v47 != v331)
  {
    int v48 = 1;
    while (v47 != (llvm::Value *)-4096)
    {
      unsigned int v49 = v45 + v48++;
      unsigned int v45 = v49 & v44;
      uint64_t v46 = v42 + 48 * (v49 & v44);
      unsigned int v47 = *(llvm::Value **)(v46 + 24);
      if (v47 == v331) {
        goto LABEL_101;
      }
    }
LABEL_100:
    uint64_t v46 = v42 + 48 * v43;
  }
LABEL_101:
  if (v46 == v42 + 48 * v43 || (uint64_t SCEVIter = *(const llvm::SCEV **)(v46 + 40)) == 0)
  {
    uint64_t SCEVIter = (const llvm::SCEV *)llvm::ScalarEvolution::createSCEVIter((llvm::ScalarEvolution *)v41, (unint64_t)v331);
    uint64_t v41 = *(void *)(v7 + 8);
    uint64_t v42 = *(void *)(v41 + 104);
    unsigned int v43 = *(_DWORD *)(v41 + 120);
  }
  if (v43)
  {
    unsigned int v51 = (v43 - 1) & ((v333 >> 4) ^ (v333 >> 9));
    uint64_t v52 = v42 + 48 * v51;
    unint64_t v53 = *(llvm::Value **)(v52 + 24);
    if (v53 == v333) {
      goto LABEL_111;
    }
    int v54 = 1;
    while (v53 != (llvm::Value *)-4096)
    {
      unsigned int v55 = v51 + v54++;
      unsigned int v51 = v55 & (v43 - 1);
      uint64_t v52 = v42 + 48 * v51;
      unint64_t v53 = *(llvm::Value **)(v52 + 24);
      if (v53 == v333) {
        goto LABEL_111;
      }
    }
  }
  uint64_t v52 = v42 + 48 * v43;
LABEL_111:
  if (v52 == v42 + 48 * v43 || (BOOL v56 = *(const llvm::SCEV **)(v52 + 40)) == 0)
  {
    BOOL v56 = (const llvm::SCEV *)llvm::ScalarEvolution::createSCEVIter((llvm::ScalarEvolution *)v41, (unint64_t)v333);
    uint64_t v41 = *(void *)(v7 + 8);
  }
  PointerBase = llvm::ScalarEvolution::getPointerBase((llvm::ScalarEvolution *)v41, SCEVIter);
  if (PointerBase != llvm::ScalarEvolution::getPointerBase(*(llvm::ScalarEvolution **)(v7 + 8), v56)) {
    operator new();
  }
  int v58 = (void **)v352;
  unsigned int *v352 = (void **)SCEVIter;
  v58[1] = v56;
  if (byte_1EBCC5370
    && llvm::DependenceInfo::tryDelinearize(v7, (uint64_t)a2, (uint64_t)a3, (void ***)&v352))
  {
    uint64_t v334 = v353;
    if (!v353)
    {
      uint64_t v334 = 0;
      unint64_t v342 = 1;
      unint64_t v343 = 1;
      BOOL v329 = 1;
      *(void *)&v341[8] = *(void *)(v7 + 8);
      *(_DWORD *)unsigned int v341 = 4;
      char v327 = 1;
      unint64_t v59 = 1;
      goto LABEL_204;
    }
  }
  else
  {
    uint64_t v334 = 1;
  }
  uint64_t v60 = 0;
  int v61 = (void **)v352;
  do
  {
    sub_1CBA7B5AC((unint64_t *)&v61[6 * v60 + 3], (*(_DWORD *)(v7 + 40) + 1), 0);
    sub_1CBA7B5AC((unint64_t *)&v352[6 * v60 + 4], (*(_DWORD *)(v7 + 40) + 1), 0);
    unint64_t v62 = sub_1CBA7B5AC((unint64_t *)&v352[6 * v60 + 5], v334, 0);
    llvm::DependenceInfo::removeMatchingExtensions((uint64_t)v62, (llvm::SCEV **)&v352[6 * v60]);
    unsigned int v63 = *(uint64_t **)(v7 + 16);
    int v64 = *((_DWORD *)v63 + 4);
    if (v64)
    {
      uint64_t v65 = *((void *)a2 + 5);
      uint64_t v66 = *v63;
      unsigned int v67 = v64 - 1;
      uint64_t v68 = ((v65 >> 4) ^ (v65 >> 9)) & v67;
      uint64_t v69 = *(void *)(v66 + 16 * v68);
      if (v65 == v69)
      {
LABEL_127:
        BOOL v72 = *(const llvm::Loop **)(v66 + 16 * v68 + 8);
      }
      else
      {
        int v70 = 1;
        while (v69 != -4096)
        {
          int v71 = v68 + v70++;
          uint64_t v68 = v71 & v67;
          uint64_t v69 = *(void *)(v66 + 16 * v68);
          if (v65 == v69) {
            goto LABEL_127;
          }
        }
        BOOL v72 = 0;
      }
      uint64_t v73 = (llvm::SCEV *)v352[6 * v60 + 1];
      uint64_t v74 = *((void *)a3 + 5);
      uint64_t v75 = ((v74 >> 4) ^ (v74 >> 9)) & v67;
      uint64_t v76 = *(void *)(v66 + 16 * v75);
      if (v74 == v76)
      {
LABEL_133:
        int v79 = *(const llvm::Loop **)(v66 + 16 * v75 + 8);
      }
      else
      {
        int v77 = 1;
        while (v76 != -4096)
        {
          int v78 = v75 + v77++;
          uint64_t v75 = v78 & v67;
          uint64_t v76 = *(void *)(v66 + 16 * v75);
          if (v74 == v76) {
            goto LABEL_133;
          }
        }
        int v79 = 0;
      }
    }
    else
    {
      BOOL v72 = 0;
      int v79 = 0;
      uint64_t v73 = (llvm::SCEV *)v352[6 * v60 + 1];
    }
    int v80 = llvm::DependenceInfo::classifyPair(v7, (llvm::SCEV *)v352[6 * v60], v72, v73, v79, (uint64_t *)&v352[6 * v60 + 3]);
    unint64_t v81 = (void **)&v352[6 * v60];
    *((_DWORD *)v81 + 4) = v80;
    sub_1CBC563DC((uint64_t *)v81 + 4, (uint64_t *)v81 + 3);
    int v61 = (void **)v352;
    unsigned int v82 = (void **)&v352[6 * v60];
    BOOL v85 = v82[5];
    uint64_t v83 = (unint64_t *)(v82 + 5);
    unint64_t v84 = (unint64_t)v85;
    if (v85) {
      *uint64_t v83 = v84 & 0xFC00000000000000 | (2
    }
                                         * (((v84 >> 1) & ~(-1 << (v84 >> 58)) | (1 << v60)) & ~(-1 << (v84 >> 58)))) | 1;
    else {
      *(void *)(*(void *)v84 + 8 * (v60 >> 6)) |= 1 << v60;
    }
    ++v60;
  }
  while (v60 != v334);
  unint64_t v343 = 1;
  BOOL v329 = v334 < 0x3A;
  if (v334 >= 0x3A) {
    operator new();
  }
  unint64_t v343 = ((unint64_t)v334 << 58) | 1;
  uint64_t v86 = 0;
  unint64_t v342 = v343;
  uint64_t v87 = 1;
  unint64_t v88 = v334;
  do
  {
    int v89 = (void **)v352;
    int v90 = (int)v352[6 * v86 + 2];
    if (!v90) {
      goto LABEL_173;
    }
    if (v90 == 4)
    {
      uint64_t v105 = *(uint64_t **)(v7 + 16);
      int v106 = *((_DWORD *)v105 + 4);
      if (v106)
      {
        uint64_t v107 = *((void *)a2 + 5);
        uint64_t v108 = *v105;
        unsigned int v109 = v106 - 1;
        uint64_t v110 = ((v107 >> 4) ^ (v107 >> 9)) & (v106 - 1);
        uint64_t v111 = *(void *)(v108 + 16 * v110);
        if (v107 == v111)
        {
LABEL_183:
          uint64_t v114 = *(llvm::Loop **)(v108 + 16 * v110 + 8);
          goto LABEL_185;
        }
        int v112 = 1;
        while (v111 != -4096)
        {
          int v113 = v110 + v112++;
          uint64_t v110 = v113 & v109;
          uint64_t v111 = *(void *)(v108 + 16 * v110);
          if (v107 == v111) {
            goto LABEL_183;
          }
        }
      }
      uint64_t v114 = 0;
LABEL_185:
      llvm::DependenceInfo::collectCommonLoops((unint64_t *)v7, (llvm::SCEV *)v352[6 * v86], v114, (unint64_t *)&v352[6 * v86 + 3]);
      unsigned int v115 = *(uint64_t **)(v7 + 16);
      int v116 = *((_DWORD *)v115 + 4);
      if (v116)
      {
        uint64_t v117 = *((void *)a3 + 5);
        uint64_t v118 = *v115;
        unsigned int v119 = v116 - 1;
        uint64_t v120 = ((v117 >> 4) ^ (v117 >> 9)) & (v116 - 1);
        uint64_t v121 = *(void *)(v118 + 16 * v120);
        if (v117 == v121)
        {
LABEL_190:
          uint64_t v124 = *(llvm::Loop **)(v118 + 16 * v120 + 8);
LABEL_192:
          llvm::DependenceInfo::collectCommonLoops((unint64_t *)v7, (llvm::SCEV *)v352[6 * v86 + 1], v124, (unint64_t *)&v352[6 * v86 + 3]);
          BOOL v346 = 0;
          goto LABEL_193;
        }
        int v122 = 1;
        while (v121 != -4096)
        {
          int v123 = v120 + v122++;
          uint64_t v120 = v123 & v119;
          uint64_t v121 = *(void *)(v118 + 16 * v120);
          if (v117 == v121) {
            goto LABEL_190;
          }
        }
      }
      uint64_t v124 = 0;
      goto LABEL_192;
    }
    if (v86 + 1 >= v88) {
      goto LABEL_166;
    }
    char v91 = 1;
    int v332 = (llvm::Value *)v87;
    do
    {
      uint64_t v350 = (llvm::SCEV *)1;
      if ((v352[6 * v86 + 4] & 1) == 0) {
        operator new();
      }
      uint64_t v350 = (llvm::SCEV *)v352[6 * v86 + 4];
      sub_1CBA7B2F4((unint64_t *)&v350, (unint64_t *)&v352[6 * v87 + 4]);
      uint64_t v92 = (void **)v350;
      if (v350)
      {
        if ((((unint64_t)v350 >> 1) & ~(-1 << ((unint64_t)v350 >> 58))) != 0) {
          goto LABEL_155;
        }
      }
      else
      {
        uint64_t v93 = *((unsigned int *)v350 + 2);
        if (v93)
        {
          unsigned int v94 = *(void **)v350;
          uint64_t v95 = 8 * v93;
          while (!*v94)
          {
            ++v94;
            v95 -= 8;
            if (!v95) {
              goto LABEL_156;
            }
          }
LABEL_155:
          sub_1CBC56144((unint64_t *)&v352[6 * v87 + 4], (unint64_t *)&v352[6 * v86 + 4]);
          sub_1CBC56144((unint64_t *)&v352[6 * v87 + 5], (unint64_t *)&v352[6 * v86 + 5]);
          char v91 = 0;
          uint64_t v92 = (void **)v350;
        }
      }
LABEL_156:
      if ((v92 & 1) == 0 && v92)
      {
        if (*v92 != v92 + 2) {
          free(*v92);
        }
        MEMORY[0x1D25D9CE0](v92, 0x1080C40EF38A13ELL);
      }
      ++v87;
    }
    while (v334 != v87);
    unint64_t v88 = v334;
    uint64_t v87 = (uint64_t)v332;
    if ((v91 & 1) == 0) {
      goto LABEL_193;
    }
    int v89 = (void **)v352;
LABEL_166:
    int64_t v96 = (int8x8_t **)v89[6 * v86 + 5];
    if (v96)
    {
      uint8x8_t v103 = (uint8x8_t)vcnt_s8((int8x8_t)(((unint64_t)v96 >> 1) & ~(-1 << ((unint64_t)v96 >> 58))));
      v103.i16[0] = vaddlv_u8(v103);
      __int32 v98 = v103.i32[0];
      goto LABEL_172;
    }
    uint64_t v97 = *((unsigned int *)v96 + 2);
    if (!v97) {
      goto LABEL_175;
    }
    __int32 v98 = 0;
    unsigned int v99 = *v96;
    uint64_t v100 = 8 * v97;
    do
    {
      int8x8_t v101 = *v99++;
      uint8x8_t v102 = (uint8x8_t)vcnt_s8(v101);
      v102.i16[0] = vaddlv_u8(v102);
      v98 += v102.i32[0];
      v100 -= 8;
    }
    while (v100);
LABEL_172:
    if (v98 == 1)
    {
LABEL_173:
      unsigned int v104 = (void *)v343;
      if (v343)
      {
        unint64_t v343 = v343 & 0xFC00000000000000 | (2
                                            * (((v343 >> 1) & ~(-1 << (v343 >> 58)) | (1 << v86)) & ~(-1 << (v343 >> 58)))) | 1;
        goto LABEL_193;
      }
LABEL_176:
      *(void *)(*v104 + 8 * (v86 >> 6)) |= 1 << v86;
    }
    else
    {
LABEL_175:
      unsigned int v104 = (void *)v342;
      if ((v342 & 1) == 0) {
        goto LABEL_176;
      }
      unint64_t v342 = v342 & 0xFC00000000000000 | (2
                                          * (((v342 >> 1) & ~(-1 << (v342 >> 58)) | (1 << v86)) & ~(-1 << (v342 >> 58)))) | 1;
    }
LABEL_193:
    ++v86;
    ++v87;
  }
  while (v86 != v88);
  unint64_t v59 = v343;
  *(void *)&v341[8] = *(void *)(v7 + 8);
  *(_DWORD *)unsigned int v341 = 4;
  if (v343)
  {
    char v327 = 0;
LABEL_204:
    int v135 = __clz(__rbit64(~(-1 << (v59 >> 58)) & (v59 >> 1)));
    if ((~(-1 << (v59 >> 58)) & (v59 >> 1)) != 0) {
      LODWORD(v136) = v135;
    }
    else {
      LODWORD(v136) = -1;
    }
    goto LABEL_208;
  }
  int v125 = *(_DWORD *)(v343 + 64);
  if (!v125)
  {
LABEL_202:
    char v327 = 0;
    goto LABEL_209;
  }
  uint64_t v126 = 0;
  int v127 = v125 - 1;
  uint64_t v128 = *(uint64_t **)v343;
  unint64_t v129 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v125;
  uint64_t v130 = v127 & 0xFFFFFFC0;
  while (1)
  {
    uint64_t v132 = *v128++;
    uint64_t v131 = v132;
    unint64_t v133 = v130 == v126 ? v129 : -1;
    unint64_t v134 = v133 & v131;
    if (v134) {
      break;
    }
    v126 += 64;
    if (v130 + 64 == v126) {
      goto LABEL_202;
    }
  }
  char v327 = 0;
  uint64_t v136 = __clz(__rbit64(v134)) + v126;
LABEL_208:
  if (v136 != -1)
  {
    uint64_t v143 = v136;
    while (1)
    {
      uint64_t v144 = (void **)&v352[6 * v143];
      int v145 = *((_DWORD *)v144 + 4);
      if (v145 == 3) {
        break;
      }
      if (v145 == 2)
      {
        if (llvm::DependenceInfo::testRDIV((llvm::ScalarEvolution **)v7, (const llvm::SCEV *)*v144, (const llvm::SCEV *)v352[6 * v143 + 1], (llvm::FullDependence *)v344))goto LABEL_245; {
      }
        }
      else if (v145 == 1)
      {
        LODWORD(v348[0]) = 0;
        if (llvm::DependenceInfo::testSIV((llvm::ScalarEvolution **)v7, (const llvm::SCEV *)*v144, (const llvm::SCEV *)v352[6 * v143 + 1], (unsigned int *)v348, (llvm::FullDependence *)v344, (llvm::DependenceInfo::Constraint *)v341, &v350))goto LABEL_245; {
      }
        }
      else
      {
        unsigned int v148 = (const llvm::SCEV *)*v144;
        unsigned int v149 = v352[6 * v143 + 1];
        if ((llvm::DependenceInfo::isKnownPredicate(v7, 0x20u, (uint64_t)*v144, (uint64_t)v149) & 1) == 0)
        {
          if (llvm::DependenceInfo::isKnownPredicate(v7, 0x21u, (uint64_t)v148, (uint64_t)v149)) {
            goto LABEL_245;
          }
          BOOL v346 = 0;
        }
      }
      LODWORD(v136) = sub_1CB9F9DF0(&v343, v136);
      uint64_t v143 = v136;
      if (v136 == -1) {
        goto LABEL_209;
      }
    }
    unsigned int v146 = (const llvm::SCEV *)*v144;
    unsigned int v147 = (const llvm::SCEV *)v352[6 * v143 + 1];
    BOOL v346 = 0;
    if ((llvm::DependenceInfo::gcdMIVtest((llvm::DependenceInfo *)v7, v146, v147, (llvm::FullDependence *)v344) & 1) == 0) {
      llvm::DependenceInfo::banerjeeMIVtest((llvm::DependenceInfo *)v7, v146);
    }
LABEL_245:
    *a5 = 0;
    goto LABEL_480;
  }
LABEL_209:
  if (v342)
  {
    uint8x8_t v150 = (uint8x8_t)vcnt_s8((int8x8_t)((v342 >> 1) & ~(-1 << (v342 >> 58))));
    v150.i16[0] = vaddlv_u8(v150);
    __int32 v138 = v150.i32[0];
    goto LABEL_230;
  }
  uint64_t v137 = *(unsigned int *)(v342 + 8);
  if (!v137) {
    goto LABEL_452;
  }
  __int32 v138 = 0;
  unsigned int v139 = *(int8x8_t **)v342;
  uint64_t v140 = 8 * v137;
  do
  {
    int8x8_t v141 = *v139++;
    uint8x8_t v142 = (uint8x8_t)vcnt_s8(v141);
    v142.i16[0] = vaddlv_u8(v142);
    v138 += v142.i32[0];
    v140 -= 8;
  }
  while (v140);
LABEL_230:
  if (!v138) {
    goto LABEL_452;
  }
  unint64_t v151 = (*(_DWORD *)(v7 + 40) + 1);
  memset(v349, 0, sizeof(v349));
  *(_OWORD *)size_t v348 = 0u;
  uint64_t v350 = (llvm::SCEV *)&v351[8];
  *(void *)unint64_t v351 = 0x400000000;
  sub_1CD480FD4((uint64_t)&v350, v151, (long long *)v348);
  uint64_t v152 = 0;
  int v153 = *(_DWORD *)(v7 + 40);
  uint64_t v154 = v350;
  uint64_t v155 = *(void *)(v7 + 8);
  if ((v153 + 1) > 1) {
    unsigned int v156 = v153 + 1;
  }
  else {
    unsigned int v156 = 1;
  }
  uint64_t v157 = 48 * v156;
  do
  {
    int v158 = (char *)v154 + v152;
    *((void *)v158 + sub_1CD456CB4((void *)this + 1) = v155;
    *(_DWORD *)int v158 = 4;
    v152 += 48;
  }
  while (v157 != v152);
  if (v342)
  {
    LODWORD(v170) = __clz(__rbit64(~(-1 << (v342 >> 58)) & (v342 >> 1)));
    if ((~(-1 << (v342 >> 58)) & (v342 >> 1)) == 0) {
      LODWORD(v170) = -1;
    }
    goto LABEL_250;
  }
  int v159 = *(_DWORD *)(v342 + 64);
  if (!v159) {
    goto LABEL_251;
  }
  uint64_t v160 = 0;
  int v161 = v159 - 1;
  unint64_t v162 = *(uint64_t **)v342;
  unint64_t v163 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v159;
  uint64_t v164 = v161 & 0xFFFFFFC0;
  int v165 = 1;
  while (1)
  {
    uint64_t v167 = *v162++;
    uint64_t v166 = v167;
    unint64_t v168 = v164 == v160 ? v163 : -1;
    unint64_t v169 = v168 & v166;
    if (v169) {
      break;
    }
    v160 += 64;
    if (v164 + 64 == v160) {
      goto LABEL_449;
    }
  }
  uint64_t v170 = __clz(__rbit64(v169)) + v160;
LABEL_250:
  if (v170 == -1)
  {
LABEL_251:
    int v165 = 1;
    goto LABEL_449;
  }
  unsigned int v171 = v170;
  uint64_t v170 = v170;
  while (2)
  {
    int v330 = v171;
    unint64_t v340 = 1;
    unint64_t v172 = (unint64_t)v352[6 * v170 + 5];
    if ((v172 & 1) == 0) {
      operator new();
    }
    unint64_t v339 = 1;
    unint64_t v340 = v172;
    if (!v329) {
      operator new();
    }
    unint64_t v339 = (v334 << 58) | 1;
    uint64_t v173 = (*(_DWORD *)(v7 + 40) + 1);
    unint64_t v337 = 1;
    unint64_t v338 = v339;
    if (v173 > 0x39) {
      operator new();
    }
    unint64_t v337 = (v173 << 58) | 1;
    v348[0] = v349;
    v348[1] = (void *)0x400000000;
    if (v340)
    {
      int v184 = __clz(__rbit64(~(-1 << (v340 >> 58)) & (v340 >> 1)));
      if ((~(-1 << (v340 >> 58)) & (v340 >> 1)) != 0) {
        LODWORD(v185) = v184;
      }
      else {
        LODWORD(v185) = -1;
      }
    }
    else
    {
      int v174 = *(_DWORD *)(v340 + 64);
      if (!v174) {
        goto LABEL_270;
      }
      uint64_t v175 = 0;
      int v176 = v174 - 1;
      BOOL v177 = *(uint64_t **)v340;
      unint64_t v178 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v174;
      uint64_t v179 = v176 & 0xFFFFFFC0;
      while (1)
      {
        uint64_t v181 = *v177++;
        uint64_t v180 = v181;
        unint64_t v182 = v179 == v175 ? v178 : -1;
        unint64_t v183 = v182 & v180;
        if (v183) {
          break;
        }
        v175 += 64;
        if (v179 + 64 == v175) {
          goto LABEL_270;
        }
      }
      uint64_t v185 = __clz(__rbit64(v183)) + v175;
    }
    if (v185 == -1)
    {
LABEL_270:
      uint64_t v186 = 0;
      unsigned int v187 = (llvm::SCEV ***)v349;
      goto LABEL_282;
    }
    unint64_t v188 = v185;
    while (2)
    {
      uint64_t v189 = (void **)v352;
      if (LODWORD(v352[6 * v188 + 2]) == 1)
      {
        unsigned int v190 = (void *)v339;
        if (v339)
        {
          unint64_t v339 = v339 & 0xFC00000000000000 | (2
                                              * (((v339 >> 1) & ~(-1 << (v339 >> 58)) | (1 << v188)) & ~(-1 << (v339 >> 58)))) | 1;
          goto LABEL_278;
        }
LABEL_276:
        *(void *)(*v190 + ((v188 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v188;
      }
      else
      {
        unsigned int v190 = (void *)v338;
        if ((v338 & 1) == 0) {
          goto LABEL_276;
        }
        unint64_t v338 = v338 & 0xFC00000000000000 | (2
                                            * (((v338 >> 1) & ~(-1 << (v338 >> 58)) | (1 << v188)) & ~(-1 << (v338 >> 58)))) | 1;
      }
LABEL_278:
      if (LODWORD(v348[1]) >= (unint64_t)HIDWORD(v348[1])) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v348[0] + LODWORD(v348[1])) = &v189[6 * v188];
      ++LODWORD(v348[1]);
      LODWORD(v185) = sub_1CB9F9DF0(&v340, v185);
      unint64_t v188 = v185;
      if (v185 != -1) {
        continue;
      }
      break;
    }
    unsigned int v187 = (llvm::SCEV ***)v348[0];
    uint64_t v186 = LODWORD(v348[1]);
LABEL_282:
    llvm::DependenceInfo::unifySubscriptType(v7, v187, v186);
LABEL_283:
    while (2)
    {
      if ((v339 & 1) == 0)
      {
        uint64_t v191 = *(unsigned int *)(v339 + 8);
        if (!v191) {
          goto LABEL_361;
        }
        uint64_t v192 = *(uint64_t **)v339;
        uint64_t v193 = 8 * v191;
        unint64_t v194 = *(void **)v339;
        while (!*v194)
        {
          ++v194;
          v193 -= 8;
          if (!v193) {
            goto LABEL_361;
          }
        }
        int v197 = *(_DWORD *)(v339 + 64);
        if (!v197) {
          continue;
        }
        uint64_t v198 = 0;
        int v199 = v197 - 1;
        unint64_t v200 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v197;
        uint64_t v201 = v199 & 0xFFFFFFC0;
        while (1)
        {
          uint64_t v203 = *v192++;
          uint64_t v202 = v203;
          unint64_t v204 = v201 == v198 ? v200 : -1;
          unint64_t v205 = v204 & v202;
          if (v205) {
            break;
          }
          v198 += 64;
          if (v201 + 64 == v198) {
            goto LABEL_283;
          }
        }
        uint64_t v196 = __clz(__rbit64(v205)) + v198;
LABEL_300:
        if (v196 == -1) {
          continue;
        }
        char v206 = 0;
        unint64_t v207 = v196;
        do
        {
          unsigned int v336 = 0;
          if (llvm::DependenceInfo::testSIV((llvm::ScalarEvolution **)v7, (const llvm::SCEV *)v352[6 * v207], (const llvm::SCEV *)v352[6 * v207 + 1], &v336, (llvm::FullDependence *)v344, (llvm::DependenceInfo::Constraint *)v341, &v335))goto LABEL_419; {
          unsigned int v208 = v336;
          }
          if (v337) {
            unint64_t v337 = v337 & 0xFC00000000000000 | (2
          }
                                                * (((v337 >> 1) & ~(-1 << (v337 >> 58)) | (1 << v336)) & ~(-1 << (v337 >> 58)))) | 1;
          else {
            *(void *)(*(void *)v337 + 8 * (v336 >> 6)) |= 1 << v336;
          }
          if (llvm::DependenceInfo::intersectConstraints((llvm::DependenceInfo *)v7, (llvm::SCEV *)((char *)v350 + 48 * v208), (const llvm::DependenceInfo::Constraint *)v341))
          {
            if (!*((_DWORD *)v350 + 12 * v208)) {
              goto LABEL_419;
            }
            char v206 = 1;
          }
          if (v339) {
            unint64_t v339 = ((2 * ~((-1 << (v339 >> 58)) | (1 << v207))) | 0xFC00000000000000) & v339 | 1;
          }
          else {
            *(void *)(*(void *)v339 + ((v207 >> 3) & 0x1FFFFFFFFFFFFFF8)) &= ~(1 << v207);
          }
          LODWORD(v196) = sub_1CB9F9DF0(&v339, v196);
          unint64_t v207 = v196;
        }
        while (v196 != -1);
        if ((v206 & 1) == 0) {
          continue;
        }
        if (v338)
        {
          int v219 = __clz(__rbit64(~(-1 << (v338 >> 58)) & (v338 >> 1)));
          LODWORD(v220) = (~(-1 << (v338 >> 58)) & (v338 >> 1)) != 0 ? v219 : -1;
        }
        else
        {
          int v209 = *(_DWORD *)(v338 + 64);
          if (!v209) {
            continue;
          }
          uint64_t v210 = 0;
          int v211 = v209 - 1;
          unint64_t v212 = *(uint64_t **)v338;
          unint64_t v213 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v209;
          uint64_t v214 = v211 & 0xFFFFFFC0;
          while (1)
          {
            uint64_t v216 = *v212++;
            uint64_t v215 = v216;
            unint64_t v217 = v214 == v210 ? v213 : -1;
            unint64_t v218 = v217 & v215;
            if (v218) {
              break;
            }
            v210 += 64;
            if (v214 + 64 == v210) {
              goto LABEL_283;
            }
          }
          uint64_t v220 = __clz(__rbit64(v218)) + v210;
        }
        if (v220 == -1) {
          continue;
        }
        unint64_t v221 = v220;
LABEL_329:
        if (llvm::DependenceInfo::propagate((llvm::ScalarEvolution **)v7, (const llvm::SCEV **)&v352[6 * v221], (const llvm::SCEV **)&v352[6 * v221 + 1], (unint64_t *)&v352[6 * v221 + 3], &v350, &v346))
        {
          uint64_t v222 = *(uint64_t **)(v7 + 16);
          int v223 = *((_DWORD *)v222 + 4);
          if (v223)
          {
            uint64_t v224 = *((void *)a2 + 5);
            uint64_t v225 = *v222;
            unsigned int v226 = v223 - 1;
            uint64_t v227 = ((v224 >> 4) ^ (v224 >> 9)) & v226;
            uint64_t v228 = *(void *)(v225 + 16 * v227);
            if (v224 == v228)
            {
LABEL_337:
              size_t v231 = *(const llvm::Loop **)(v225 + 16 * v227 + 8);
            }
            else
            {
              int v229 = 1;
              while (v228 != -4096)
              {
                int v230 = v227 + v229++;
                uint64_t v227 = v230 & v226;
                uint64_t v228 = *(void *)(v225 + 16 * v227);
                if (v224 == v228) {
                  goto LABEL_337;
                }
              }
              size_t v231 = 0;
            }
            uint64_t v232 = (llvm::SCEV *)v352[6 * v221 + 1];
            uint64_t v233 = *((void *)a3 + 5);
            uint64_t v234 = ((v233 >> 4) ^ (v233 >> 9)) & v226;
            uint64_t v235 = *(void *)(v225 + 16 * v234);
            if (v233 == v235)
            {
LABEL_343:
              unsigned int v238 = *(const llvm::Loop **)(v225 + 16 * v234 + 8);
            }
            else
            {
              int v236 = 1;
              while (v235 != -4096)
              {
                int v237 = v234 + v236++;
                uint64_t v234 = v237 & v226;
                uint64_t v235 = *(void *)(v225 + 16 * v234);
                if (v233 == v235) {
                  goto LABEL_343;
                }
              }
              unsigned int v238 = 0;
            }
          }
          else
          {
            size_t v231 = 0;
            unsigned int v238 = 0;
            uint64_t v232 = (llvm::SCEV *)v352[6 * v221 + 1];
          }
          int v239 = llvm::DependenceInfo::classifyPair(v7, (llvm::SCEV *)v352[6 * v221], v231, v232, v238, (uint64_t *)&v352[6 * v221 + 3]);
          uint64_t v240 = (void **)v352;
          LODWORD(v352[6 * v221 + 2]) = v239;
          if ((v239 - 2) >= 2)
          {
            if (v239 == 1)
            {
              if (v339) {
                unint64_t v339 = v339 & 0xFC00000000000000 | (2
              }
                                                    * (((v339 >> 1) & ~(-1 << (v339 >> 58)) | (1 << v221)) & ~(-1 << (v339 >> 58)))) | 1;
              else {
                *(void *)(*(void *)v339 + ((v221 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v221;
              }
              unint64_t v241 = v338;
              if ((v338 & 1) == 0)
              {
                *(void *)(*(void *)v338 + ((v221 >> 3) & 0x1FFFFFFFFFFFFFF8)) &= ~(1 << v221);
                goto LABEL_330;
              }
              unint64_t v242 = v338 >> 58;
LABEL_353:
              unint64_t v338 = ((2 * ~((-1 << v242) | (1 << v221))) | 0xFC00000000000000) & v241 | 1;
            }
            else
            {
              uint64_t v243 = (uint64_t *)&v240[6 * v221];
              uint64_t v244 = *v243;
              uint64_t v245 = v243[1];
              if ((llvm::DependenceInfo::isKnownPredicate(v7, 0x20u, *v243, v245) & 1) == 0)
              {
                if (llvm::DependenceInfo::isKnownPredicate(v7, 0x21u, v244, v245)) {
                  goto LABEL_419;
                }
                BOOL v346 = 0;
              }
              unint64_t v241 = v338;
              if (v338)
              {
                unint64_t v242 = v338 >> 58;
                goto LABEL_353;
              }
              *(void *)(*(void *)v338 + ((v221 >> 3) & 0x1FFFFFFFFFFFFFF8)) &= ~(1 << v221);
            }
          }
        }
LABEL_330:
        LODWORD(v220) = sub_1CB9F9DF0(&v338, v220);
        unint64_t v221 = v220;
        if (v220 == -1) {
          continue;
        }
        goto LABEL_329;
      }
      break;
    }
    unint64_t v195 = (v339 >> 1) & ~(-1 << (v339 >> 58));
    if (v195)
    {
      LODWORD(v196) = __clz(__rbit64(v195));
      goto LABEL_300;
    }
LABEL_361:
    unint64_t v246 = v338;
    if (v338)
    {
      int v258 = __clz(__rbit64(~(-1 << (v338 >> 58)) & (v338 >> 1)));
      if ((~(-1 << (v338 >> 58)) & (v338 >> 1)) != 0) {
        LODWORD(v259) = v258;
      }
      else {
        LODWORD(v259) = -1;
      }
      goto LABEL_374;
    }
    int v247 = *(_DWORD *)(v338 + 64);
    if (v247)
    {
      uint64_t v248 = 0;
      int v249 = -v247;
      int v250 = v247 - 1;
      unint64_t v251 = *(uint64_t **)v338;
      unint64_t v252 = 0xFFFFFFFFFFFFFFFFLL >> v249;
      uint64_t v253 = v250 & 0xFFFFFFC0;
      while (1)
      {
        uint64_t v255 = *v251++;
        uint64_t v254 = v255;
        unint64_t v256 = v253 == v248 ? v252 : -1;
        unint64_t v257 = v256 & v254;
        if (v257) {
          break;
        }
        v248 += 64;
        if (v253 + 64 == v248) {
          goto LABEL_383;
        }
      }
      uint64_t v259 = __clz(__rbit64(v257)) + v248;
LABEL_374:
      if (v259 != -1)
      {
        unint64_t v260 = v259;
        do
        {
          if (LODWORD(v352[6 * v260 + 2]) == 2)
          {
            if (llvm::DependenceInfo::testRDIV((llvm::ScalarEvolution **)v7, (const llvm::SCEV *)v352[6 * v260], (const llvm::SCEV *)v352[6 * v260 + 1], (llvm::FullDependence *)v344))goto LABEL_419; {
            if (v338)
            }
              unint64_t v338 = ((2 * ~((-1 << (v338 >> 58)) | (1 << v260))) | 0xFC00000000000000) & v338 | 1;
            else {
              *(void *)(*(void *)v338 + ((v260 >> 3) & 0x1FFFFFFFFFFFFFF8)) &= ~(1 << v260);
            }
          }
          LODWORD(v259) = sub_1CB9F9DF0(&v338, v259);
          unint64_t v260 = v259;
        }
        while (v259 != -1);
        unint64_t v246 = v338;
      }
    }
LABEL_383:
    if (v246)
    {
      unint64_t v271 = ~(-1 << (v246 >> 58)) & (v246 >> 1);
      BOOL v23 = v271 == 0;
      int v272 = __clz(__rbit64(v271));
      if (v23) {
        LODWORD(v273) = -1;
      }
      else {
        LODWORD(v273) = v272;
      }
      goto LABEL_396;
    }
    int v261 = *(_DWORD *)(v246 + 64);
    if (!v261) {
      goto LABEL_399;
    }
    uint64_t v262 = 0;
    int v263 = v261 - 1;
    uint64_t v264 = *(uint64_t **)v246;
    unint64_t v265 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v261;
    uint64_t v266 = v263 & 0xFFFFFFC0;
    while (1)
    {
      uint64_t v268 = *v264++;
      uint64_t v267 = v268;
      unint64_t v269 = v266 == v262 ? v265 : -1;
      unint64_t v270 = v269 & v267;
      if (v270) {
        break;
      }
      v262 += 64;
      if (v266 + 64 == v262) {
        goto LABEL_399;
      }
    }
    uint64_t v273 = __clz(__rbit64(v270)) + v262;
LABEL_396:
    if (v273 == -1)
    {
LABEL_399:
      if (v337)
      {
        int v287 = __clz(__rbit64(~(-1 << (v337 >> 58)) & (v337 >> 1)));
        if ((~(-1 << (v337 >> 58)) & (v337 >> 1)) != 0) {
          LODWORD(v288) = v287;
        }
        else {
          LODWORD(v288) = -1;
        }
      }
      else
      {
        int v277 = *(_DWORD *)(v337 + 64);
        if (!v277)
        {
LABEL_413:
          int v165 = 1;
          goto LABEL_420;
        }
        uint64_t v278 = 0;
        int v279 = v277 - 1;
        uint64_t v280 = *(uint64_t **)v337;
        unint64_t v281 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v277;
        uint64_t v282 = v279 & 0xFFFFFFC0;
        while (1)
        {
          uint64_t v284 = *v280++;
          uint64_t v283 = v284;
          unint64_t v285 = v282 == v278 ? v281 : -1;
          unint64_t v286 = v285 & v283;
          if (v286) {
            break;
          }
          v278 += 64;
          int v165 = 1;
          if (v282 + 64 == v278) {
            goto LABEL_420;
          }
        }
        uint64_t v288 = __clz(__rbit64(v286)) + v278;
      }
      if (v288 != -1)
      {
        uint64_t v289 = v288;
        do
        {
          if (*(_DWORD *)(v7 + 32) < v288) {
            break;
          }
          uint64_t v290 = 16 * (v289 - 1);
          llvm::DependenceInfo::updateDirection(v7, (char *)(v347 + v290), (int *)v350 + 12 * v289);
          if ((*(unsigned char *)(v347 + v290) & 7) == 0) {
            goto LABEL_419;
          }
          LODWORD(v288) = sub_1CB9F9DF0(&v337, v288);
          uint64_t v289 = v288;
        }
        while (v288 != -1);
      }
      goto LABEL_413;
    }
    int8x8_t v274 = (void **)&v352[6 * v273];
    unint64_t v276 = (const llvm::SCEV *)*v274;
    uint8x8_t v275 = (const llvm::SCEV *)v274[1];
    BOOL v346 = 0;
    if ((llvm::DependenceInfo::gcdMIVtest((llvm::DependenceInfo *)v7, v276, v275, (llvm::FullDependence *)v344) & 1) == 0) {
      llvm::DependenceInfo::banerjeeMIVtest((llvm::DependenceInfo *)v7, v276);
    }
LABEL_419:
    int v165 = 0;
    *a5 = 0;
LABEL_420:
    if (v348[0] != v349) {
      free(v348[0]);
    }
    unint64_t v291 = v337;
    if ((v337 & 1) == 0 && v337)
    {
      if (*(void *)v337 != v337 + 16) {
        free(*(void **)v337);
      }
      MEMORY[0x1D25D9CE0](v291, 0x1080C40EF38A13ELL);
    }
    unint64_t v292 = v338;
    if ((v338 & 1) == 0 && v338)
    {
      if (*(void *)v338 != v338 + 16) {
        free(*(void **)v338);
      }
      MEMORY[0x1D25D9CE0](v292, 0x1080C40EF38A13ELL);
    }
    unint64_t v293 = v339;
    if ((v339 & 1) == 0 && v339)
    {
      if (*(void *)v339 != v339 + 16) {
        free(*(void **)v339);
      }
      MEMORY[0x1D25D9CE0](v293, 0x1080C40EF38A13ELL);
    }
    unint64_t v294 = v340;
    if ((v340 & 1) == 0 && v340)
    {
      if (*(void *)v340 != v340 + 16) {
        free(*(void **)v340);
      }
      MEMORY[0x1D25D9CE0](v294, 0x1080C40EF38A13ELL);
    }
    if (v165)
    {
      unsigned int v171 = sub_1CB9F9DF0(&v342, v330);
      uint64_t v170 = v171;
      if (v171 != -1) {
        continue;
      }
    }
    break;
  }
  uint64_t v154 = v350;
LABEL_449:
  if (v154 != (llvm::SCEV *)&v351[8]) {
    free(v154);
  }
  if (v165)
  {
LABEL_452:
    uint64_t v295 = (*(_DWORD *)(v7 + 40) + 1);
    uint64_t v350 = (llvm::SCEV *)1;
    if (v295 > 0x39) {
      operator new();
    }
    uint64_t v350 = (llvm::SCEV *)((v295 << 58) | 1);
    if ((v327 & 1) == 0)
    {
      uint64_t v296 = v334;
      uint64_t v297 = 3;
      do
      {
        sub_1CBC56144((unint64_t *)&v350, (unint64_t *)&v352[v297]);
        v297 += 6;
        --v296;
      }
      while (v296);
    }
    unsigned int v298 = *(_DWORD *)(v7 + 32);
    if (v298)
    {
      for (unsigned int i = 1; i <= v298; ++i)
      {
        if (v350) {
          unint64_t v300 = (1 << i) & ((unint64_t)v350 >> 1) & ~(-1 << ((unint64_t)v350 >> 58));
        }
        else {
          unint64_t v300 = *(void *)(*(void *)v350 + 8 * (i >> 6)) & (1 << i);
        }
        if (v300)
        {
          *(unsigned char *)(v347 + 16 * (i - 1)) &= ~8u;
          unsigned int v298 = *(_DWORD *)(v7 + 32);
        }
      }
      if (v328)
      {
        if (v298)
        {
          unsigned int v301 = 0;
          while ((*(unsigned char *)(v347 + 16 * v301) & 2) != 0)
          {
            unsigned int v302 = v301 + 2;
            ++v301;
            if (v302 > v298) {
              goto LABEL_478;
            }
          }
          char v345 = 0;
        }
      }
      else
      {
        if (!v298) {
          goto LABEL_479;
        }
        unsigned int v303 = 0;
        while ((*(unsigned char *)(v347 + 16 * v303) & 7) == 2)
        {
          unsigned int v304 = v303 + 2;
          ++v303;
          if (v304 > v298) {
            goto LABEL_479;
          }
        }
      }
LABEL_478:
      operator new();
    }
    if (v328) {
      goto LABEL_478;
    }
LABEL_479:
    *a5 = 0;
    uint64_t v305 = v350;
    if ((v350 & 1) == 0 && v350)
    {
      if (*(llvm::SCEV **)v350 != (llvm::SCEV *)((char *)v350 + 16)) {
        free(*(void **)v350);
      }
      MEMORY[0x1D25D9CE0](v305, 0x1080C40EF38A13ELL);
    }
  }
LABEL_480:
  unint64_t v306 = v342;
  if ((v342 & 1) == 0 && v342)
  {
    if (*(void *)v342 != v342 + 16) {
      free(*(void **)v342);
    }
    MEMORY[0x1D25D9CE0](v306, 0x1080C40EF38A13ELL);
  }
  unint64_t v307 = v343;
  if ((v343 & 1) == 0 && v343)
  {
    if (*(void *)v343 != v343 + 16) {
      free(*(void **)v343);
    }
    MEMORY[0x1D25D9CE0](v307, 0x1080C40EF38A13ELL);
  }
  sub_1CD480D50(v352, &v352[6 * v353]);
  if (v352 != (void ***)v354) {
    free(v352);
  }
  this = v347;
  uint64_t v347 = 0;
  if (this) {
    return MEMORY[0x1D25D9CB0](this, 0x1060C80768B1B2DLL);
  }
  return this;
}

unint64_t llvm::DependenceInfo::getSplitIteration(llvm::DependenceInfo *this, const llvm::Dependence *a2, int a3)
{
  v240[12] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *((void *)a2 + 1);
  uint64_t v4 = *((void *)a2 + 2);
  if (v3) {
    BOOL v5 = *(unsigned __int8 *)(v3 + 16) - 62 >= 0xFFFFFFFE;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5) {
    unint64_t v6 = *(void *)(v3 - 32);
  }
  else {
    unint64_t v6 = 0;
  }
  if (v4) {
    BOOL v7 = *(unsigned __int8 *)(v4 + 16) - 62 >= 0xFFFFFFFE;
  }
  else {
    BOOL v7 = 0;
  }
  if (v7) {
    unint64_t v8 = *(void *)(v4 - 32);
  }
  else {
    unint64_t v8 = 0;
  }
  llvm::DependenceInfo::establishNestingLevels(this, *((const llvm::Instruction **)a2 + 1), (const llvm::Instruction *)v4);
  llvm::FullDependence::FullDependence((uint64_t)v231, (llvm::Instruction *)v3, (llvm::Instruction *)v4, 0, *((_DWORD *)this + 8));
  long long v234 = 0uLL;
  uint64_t v235 = 0;
  int64x2_t v236 = vdupq_n_s64(1uLL);
  uint64_t v237 = 1;
  unsigned int v238 = (void ***)v240;
  uint64_t v239 = 0x200000000;
  sub_1CD480E9C((uint64_t)&v238, &v234);
  uint64_t v9 = v237;
  if ((v237 & 1) == 0 && v237)
  {
    if (*(void *)v237 != v237 + 16) {
      free(*(void **)v237);
    }
    MEMORY[0x1D25D9CE0](v9, 0x1080C40EF38A13ELL);
  }
  uint64_t v10 = v236.i64[1];
  if ((v236.i8[8] & 1) == 0 && v236.i64[1])
  {
    if (*(void *)v236.i64[1] != v236.i64[1] + 16) {
      free(*(void **)v236.i64[1]);
    }
    MEMORY[0x1D25D9CE0](v10, 0x1080C40EF38A13ELL);
  }
  uint64_t v11 = v236.i64[0];
  if ((v236.i8[0] & 1) == 0 && v236.i64[0])
  {
    if (*(void *)v236.i64[0] != v236.i64[0] + 16) {
      free(*(void **)v236.i64[0]);
    }
    MEMORY[0x1D25D9CE0](v11, 0x1080C40EF38A13ELL);
  }
  uint64_t v12 = *((void *)this + 1);
  uint64_t v13 = *(void *)(v12 + 104);
  unsigned int v14 = *(_DWORD *)(v12 + 120);
  if (!v14)
  {
LABEL_22:
    uint64_t v17 = v13 + 48 * v14;
    goto LABEL_23;
  }
  unsigned int v15 = v14 - 1;
  unsigned int v16 = (v14 - 1) & ((v6 >> 4) ^ (v6 >> 9));
  uint64_t v17 = v13 + 48 * v16;
  uint64_t v18 = *(void *)(v17 + 24);
  if (v18 != v6)
  {
    int v19 = 1;
    while (v18 != -4096)
    {
      unsigned int v20 = v16 + v19++;
      unsigned int v16 = v20 & v15;
      uint64_t v17 = v13 + 48 * (v20 & v15);
      uint64_t v18 = *(void *)(v17 + 24);
      if (v18 == v6) {
        goto LABEL_23;
      }
    }
    goto LABEL_22;
  }
LABEL_23:
  if (v17 == v13 + 48 * v14 || (uint64_t SCEVIter = *(void ***)(v17 + 40)) == 0)
  {
    uint64_t SCEVIter = (void **)llvm::ScalarEvolution::createSCEVIter((llvm::ScalarEvolution *)v12, v6);
    uint64_t v12 = *((void *)this + 1);
    uint64_t v13 = *(void *)(v12 + 104);
    unsigned int v14 = *(_DWORD *)(v12 + 120);
    if (!v14) {
      goto LABEL_32;
    }
  }
  else if (!v14)
  {
    goto LABEL_32;
  }
  unsigned int v22 = (v14 - 1) & ((v8 >> 4) ^ (v8 >> 9));
  uint64_t v23 = v13 + 48 * v22;
  uint64_t v24 = *(void *)(v23 + 24);
  if (v24 == v8) {
    goto LABEL_33;
  }
  int v25 = 1;
  while (v24 != -4096)
  {
    unsigned int v26 = v22 + v25++;
    unsigned int v22 = v26 & (v14 - 1);
    uint64_t v23 = v13 + 48 * v22;
    uint64_t v24 = *(void *)(v23 + 24);
    if (v24 == v8) {
      goto LABEL_33;
    }
  }
LABEL_32:
  uint64_t v23 = v13 + 48 * v14;
LABEL_33:
  if (v23 == v13 + 48 * v14 || (uint64_t v27 = *(void *)(v23 + 40)) == 0) {
    uint64_t v27 = llvm::ScalarEvolution::createSCEVIter((llvm::ScalarEvolution *)v12, v8);
  }
  char v28 = (void **)v238;
  *unsigned int v238 = SCEVIter;
  v28[1] = (void *)v27;
  uint64_t v213 = v4;
  if (byte_1EBCC5370
    && llvm::DependenceInfo::tryDelinearize((unint64_t)this, v3, v4, (void ***)&v238))
  {
    uint64_t v29 = v239;
    if (!v239)
    {
      uint64_t v30 = 0;
      unint64_t v229 = 1;
      unint64_t v230 = 1;
      BOOL v214 = 1;
      uint64_t v228 = *((void *)this + 1);
      int v227 = 4;
      unint64_t v31 = 1;
      goto LABEL_123;
    }
  }
  else
  {
    uint64_t v29 = 1;
  }
  uint64_t v32 = 0;
  BOOL v33 = (void **)v238;
  uint64_t v216 = v29;
  unint64_t v215 = v29;
  do
  {
    sub_1CBA7B5AC((unint64_t *)&v33[6 * v32 + 3], (*((_DWORD *)this + 10) + 1), 0);
    sub_1CBA7B5AC((unint64_t *)&v238[6 * v32 + 4], (*((_DWORD *)this + 10) + 1), 0);
    uint64_t v34 = sub_1CBA7B5AC((unint64_t *)&v238[6 * v32 + 5], v216, 0);
    llvm::DependenceInfo::removeMatchingExtensions((uint64_t)v34, (llvm::SCEV **)&v238[6 * v32]);
    int v35 = (uint64_t *)*((void *)this + 2);
    int v36 = *((_DWORD *)v35 + 4);
    if (v36)
    {
      uint64_t v37 = *(void *)(v3 + 40);
      uint64_t v38 = *v35;
      unsigned int v39 = v36 - 1;
      uint64_t v40 = ((v37 >> 4) ^ (v37 >> 9)) & v39;
      uint64_t v41 = *(void *)(v38 + 16 * v40);
      if (v37 == v41)
      {
LABEL_47:
        unsigned int v44 = *(const llvm::Loop **)(v38 + 16 * v40 + 8);
      }
      else
      {
        int v42 = 1;
        while (v41 != -4096)
        {
          int v43 = v40 + v42++;
          uint64_t v40 = v43 & v39;
          uint64_t v41 = *(void *)(v38 + 16 * v40);
          if (v37 == v41) {
            goto LABEL_47;
          }
        }
        unsigned int v44 = 0;
      }
      unsigned int v45 = (llvm::SCEV *)v238[6 * v32 + 1];
      uint64_t v46 = *(void *)(v4 + 40);
      uint64_t v47 = ((v46 >> 4) ^ (v46 >> 9)) & v39;
      uint64_t v48 = *(void *)(v38 + 16 * v47);
      if (v46 == v48)
      {
LABEL_53:
        unsigned int v51 = *(const llvm::Loop **)(v38 + 16 * v47 + 8);
      }
      else
      {
        int v49 = 1;
        while (v48 != -4096)
        {
          int v50 = v47 + v49++;
          uint64_t v47 = v50 & v39;
          uint64_t v48 = *(void *)(v38 + 16 * v47);
          if (v46 == v48) {
            goto LABEL_53;
          }
        }
        unsigned int v51 = 0;
      }
    }
    else
    {
      unsigned int v44 = 0;
      unsigned int v51 = 0;
      unsigned int v45 = (llvm::SCEV *)v238[6 * v32 + 1];
    }
    int v52 = llvm::DependenceInfo::classifyPair((uint64_t)this, (llvm::SCEV *)v238[6 * v32], v44, v45, v51, (uint64_t *)&v238[6 * v32 + 3]);
    unint64_t v53 = (void **)&v238[6 * v32];
    *((_DWORD *)v53 + 4) = v52;
    sub_1CBC563DC((uint64_t *)v53 + 4, (uint64_t *)v53 + 3);
    BOOL v33 = (void **)v238;
    int v54 = (void **)&v238[6 * v32];
    int v57 = v54[5];
    unsigned int v55 = (unint64_t *)(v54 + 5);
    unint64_t v56 = (unint64_t)v57;
    if (v57) {
      unint64_t *v55 = v56 & 0xFC00000000000000 | (2
    }
                                         * (((v56 >> 1) & ~(-1 << (v56 >> 58)) | (1 << v32)) & ~(-1 << (v56 >> 58)))) | 1;
    else {
      *(void *)(*(void *)v56 + 8 * (v32 >> 6)) |= 1 << v32;
    }
    ++v32;
  }
  while (v32 != v215);
  unint64_t v230 = 1;
  uint64_t v30 = v216;
  BOOL v214 = v216 < 0x3A;
  if (v216 >= 0x3A) {
    operator new();
  }
  unint64_t v8 = v215;
  unint64_t v230 = (v215 << 58) | 1;
  uint64_t v58 = 0;
  unint64_t v229 = v230;
  uint64_t v59 = 1;
  do
  {
    uint64_t v60 = (void **)v238;
    int v61 = (int)v238[6 * v58 + 2];
    if (!v61) {
      goto LABEL_93;
    }
    if (v61 == 4)
    {
      int v77 = (uint64_t *)*((void *)this + 2);
      int v78 = *((_DWORD *)v77 + 4);
      if (v78)
      {
        uint64_t v79 = *(void *)(v3 + 40);
        uint64_t v80 = *v77;
        unsigned int v81 = v78 - 1;
        uint64_t v82 = ((v79 >> 4) ^ (v79 >> 9)) & (v78 - 1);
        uint64_t v83 = *(void *)(v80 + 16 * v82);
        if (v79 == v83)
        {
LABEL_103:
          uint64_t v86 = *(llvm::Loop **)(v80 + 16 * v82 + 8);
          goto LABEL_105;
        }
        int v84 = 1;
        while (v83 != -4096)
        {
          int v85 = v82 + v84++;
          uint64_t v82 = v85 & v81;
          uint64_t v83 = *(void *)(v80 + 16 * v82);
          if (v79 == v83) {
            goto LABEL_103;
          }
        }
      }
      uint64_t v86 = 0;
LABEL_105:
      llvm::DependenceInfo::collectCommonLoops((unint64_t *)this, (llvm::SCEV *)v238[6 * v58], v86, (unint64_t *)&v238[6 * v58 + 3]);
      uint64_t v87 = (uint64_t *)*((void *)this + 2);
      int v88 = *((_DWORD *)v87 + 4);
      if (v88)
      {
        uint64_t v89 = *(void *)(v4 + 40);
        uint64_t v90 = *v87;
        unsigned int v91 = v88 - 1;
        uint64_t v92 = ((v89 >> 4) ^ (v89 >> 9)) & (v88 - 1);
        uint64_t v93 = *(void *)(v90 + 16 * v92);
        if (v89 == v93)
        {
LABEL_110:
          int64_t v96 = *(llvm::Loop **)(v90 + 16 * v92 + 8);
LABEL_112:
          llvm::DependenceInfo::collectCommonLoops((unint64_t *)this, (llvm::SCEV *)v238[6 * v58 + 1], v96, (unint64_t *)&v238[6 * v58 + 3]);
          BOOL v232 = 0;
          goto LABEL_113;
        }
        int v94 = 1;
        while (v93 != -4096)
        {
          int v95 = v92 + v94++;
          uint64_t v92 = v95 & v91;
          uint64_t v93 = *(void *)(v90 + 16 * v92);
          if (v89 == v93) {
            goto LABEL_110;
          }
        }
      }
      int64_t v96 = 0;
      goto LABEL_112;
    }
    if (v58 + 1 >= v8) {
      goto LABEL_86;
    }
    char v62 = 1;
    uint64_t v63 = v59;
    do
    {
      *(void *)&long long v234 = 1;
      if ((v238[6 * v58 + 4] & 1) == 0) {
        operator new();
      }
      *(void *)&long long v234 = v238[6 * v58 + 4];
      sub_1CBA7B2F4((unint64_t *)&v234, (unint64_t *)&v238[6 * v63 + 4]);
      int v64 = (void **)v234;
      if (v234)
      {
        if ((((unint64_t)v234 >> 1) & ~(-1 << ((unint64_t)v234 >> 58))) != 0) {
          goto LABEL_75;
        }
      }
      else
      {
        uint64_t v65 = *(unsigned int *)(v234 + 8);
        if (v65)
        {
          uint64_t v66 = *(void **)v234;
          uint64_t v67 = 8 * v65;
          while (!*v66)
          {
            ++v66;
            v67 -= 8;
            if (!v67) {
              goto LABEL_76;
            }
          }
LABEL_75:
          sub_1CBC56144((unint64_t *)&v238[6 * v63 + 4], (unint64_t *)&v238[6 * v58 + 4]);
          sub_1CBC56144((unint64_t *)&v238[6 * v63 + 5], (unint64_t *)&v238[6 * v58 + 5]);
          char v62 = 0;
          int v64 = (void **)v234;
        }
      }
LABEL_76:
      if ((v64 & 1) == 0 && v64)
      {
        if (*v64 != v64 + 2) {
          free(*v64);
        }
        MEMORY[0x1D25D9CE0](v64, 0x1080C40EF38A13ELL);
      }
      ++v63;
    }
    while (v216 != v63);
    unint64_t v8 = v215;
    if ((v62 & 1) == 0) {
      goto LABEL_113;
    }
    uint64_t v60 = (void **)v238;
LABEL_86:
    uint64_t v68 = (int8x8_t **)v60[6 * v58 + 5];
    if (v68)
    {
      uint8x8_t v75 = (uint8x8_t)vcnt_s8((int8x8_t)(((unint64_t)v68 >> 1) & ~(-1 << ((unint64_t)v68 >> 58))));
      v75.i16[0] = vaddlv_u8(v75);
      __int32 v70 = v75.i32[0];
      goto LABEL_92;
    }
    uint64_t v69 = *((unsigned int *)v68 + 2);
    if (!v69) {
      goto LABEL_95;
    }
    __int32 v70 = 0;
    int v71 = *v68;
    uint64_t v72 = 8 * v69;
    do
    {
      int8x8_t v73 = *v71++;
      uint8x8_t v74 = (uint8x8_t)vcnt_s8(v73);
      v74.i16[0] = vaddlv_u8(v74);
      v70 += v74.i32[0];
      v72 -= 8;
    }
    while (v72);
LABEL_92:
    if (v70 == 1)
    {
LABEL_93:
      uint64_t v76 = (void *)v230;
      if (v230)
      {
        unint64_t v230 = v230 & 0xFC00000000000000 | (2
                                            * (((v230 >> 1) & ~(-1 << (v230 >> 58)) | (1 << v58)) & ~(-1 << (v230 >> 58)))) | 1;
        goto LABEL_113;
      }
LABEL_96:
      *(void *)(*v76 + 8 * (v58 >> 6)) |= 1 << v58;
    }
    else
    {
LABEL_95:
      uint64_t v76 = (void *)v229;
      if ((v229 & 1) == 0) {
        goto LABEL_96;
      }
      unint64_t v229 = v229 & 0xFC00000000000000 | (2
                                          * (((v229 >> 1) & ~(-1 << (v229 >> 58)) | (1 << v58)) & ~(-1 << (v229 >> 58)))) | 1;
    }
LABEL_113:
    ++v58;
    ++v59;
  }
  while (v58 != v8);
  unint64_t v31 = v230;
  uint64_t v228 = *((void *)this + 1);
  int v227 = 4;
  if (v230)
  {
LABEL_123:
    int v107 = __clz(__rbit64(~(-1 << (v31 >> 58)) & (v31 >> 1)));
    if ((~(-1 << (v31 >> 58)) & (v31 >> 1)) != 0) {
      LODWORD(v108) = v107;
    }
    else {
      LODWORD(v108) = -1;
    }
    goto LABEL_127;
  }
  int v97 = *(_DWORD *)(v230 + 64);
  if (!v97) {
    goto LABEL_128;
  }
  uint64_t v98 = 0;
  int v99 = v97 - 1;
  uint64_t v100 = *(uint64_t **)v230;
  unint64_t v101 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v97;
  uint64_t v102 = v99 & 0xFFFFFFC0;
  while (1)
  {
    uint64_t v104 = *v100++;
    uint64_t v103 = v104;
    unint64_t v105 = v102 == v98 ? v101 : -1;
    unint64_t v106 = v105 & v103;
    if (v106) {
      break;
    }
    v98 += 64;
    if (v102 + 64 == v98) {
      goto LABEL_128;
    }
  }
  uint64_t v108 = __clz(__rbit64(v106)) + v98;
LABEL_127:
  if (v108 != -1)
  {
    uint64_t v133 = v108;
    while (1)
    {
      if (LODWORD(v238[6 * v133 + 2]) == 1)
      {
        v224[0] = 0;
        *(void *)&long long v234 = 0;
        llvm::DependenceInfo::testSIV((llvm::ScalarEvolution **)this, (const llvm::SCEV *)v238[6 * v133], (const llvm::SCEV *)v238[6 * v133 + 1], v224, (llvm::FullDependence *)v231, (llvm::DependenceInfo::Constraint *)&v227, (const llvm::SCEV **)&v234);
        if (v224[0] == a3) {
          break;
        }
      }
      LODWORD(v108) = sub_1CB9F9DF0(&v230, v108);
      uint64_t v133 = v108;
      if (v108 == -1) {
        goto LABEL_128;
      }
    }
    unint64_t v8 = v234;
  }
  else
  {
LABEL_128:
    if ((v229 & 1) == 0)
    {
      uint64_t v109 = *(unsigned int *)(v229 + 8);
      if (v109)
      {
        int v110 = 0;
        uint64_t v111 = *(int8x8_t **)v229;
        uint64_t v112 = 8 * v109;
        do
        {
          int8x8_t v113 = *v111++;
          uint8x8_t v114 = (uint8x8_t)vcnt_s8(v113);
          v114.i16[0] = vaddlv_u8(v114);
          v110 += v114.i32[0];
          v112 -= 8;
        }
        while (v112);
      }
    }
    unint64_t v115 = (*((_DWORD *)this + 10) + 1);
    long long v225 = 0u;
    long long v226 = 0u;
    *(_OWORD *)uint64_t v224 = 0u;
    *(void *)&long long v234 = &v235;
    *((void *)&v234 + sub_1CD456CB4((void *)this + 1) = 0x400000000;
    sub_1CD480FD4((uint64_t)&v234, v115, (long long *)v224);
    uint64_t v116 = 0;
    int v117 = *((_DWORD *)this + 10);
    uint64_t v118 = (char *)v234;
    uint64_t v119 = *((void *)this + 1);
    if ((v117 + 1) > 1) {
      unsigned int v120 = v117 + 1;
    }
    else {
      unsigned int v120 = 1;
    }
    uint64_t v121 = 48 * v120;
    do
    {
      int v122 = &v118[v116];
      *((void *)v122 + sub_1CD456CB4((void *)this + 1) = v119;
      *(_DWORD *)int v122 = 4;
      v116 += 48;
    }
    while (v121 != v116);
    uint64_t v217 = v30;
    if (v229)
    {
      int v134 = __clz(__rbit64(~(-1 << (v229 >> 58)) & (v229 >> 1)));
      if ((~(-1 << (v229 >> 58)) & (v229 >> 1)) != 0) {
        LODWORD(v135) = v134;
      }
      else {
        LODWORD(v135) = -1;
      }
    }
    else
    {
      int v123 = *(_DWORD *)(v229 + 64);
      if (!v123) {
        goto LABEL_283;
      }
      uint64_t v124 = 0;
      int v125 = v123 - 1;
      uint64_t v126 = *(uint64_t **)v229;
      unint64_t v127 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v123;
      uint64_t v128 = v125 & 0xFFFFFFC0;
      while (1)
      {
        uint64_t v130 = *v126++;
        uint64_t v129 = v130;
        unint64_t v131 = v128 == v124 ? v127 : -1;
        unint64_t v132 = v131 & v129;
        if (v132) {
          break;
        }
        v124 += 64;
        if (v128 + 64 == v124) {
          goto LABEL_283;
        }
      }
      uint64_t v135 = __clz(__rbit64(v132)) + v124;
    }
    if (v135 != -1)
    {
      uint64_t v136 = v135;
      while (1)
      {
        *(void *)uint64_t v224 = 1;
        uint64_t v137 = v238[6 * v136 + 5];
        if ((v137 & 1) == 0) {
          operator new();
        }
        unint64_t v223 = 1;
        *(void *)uint64_t v224 = v137;
        if (!v214) {
          operator new();
        }
        unint64_t v223 = (v217 << 58) | 1;
        unint64_t v222 = v223;
        uint64_t v138 = (*((_DWORD *)this + 10) + 1);
        if (v138 > 0x39) {
          operator new();
        }
        unint64_t v139 = (v138 << 58) | 1;
        if (v224[0])
        {
          int v150 = __clz(__rbit64(~(-1 << (*(void *)v224 >> 58)) & (*(void *)v224 >> 1)));
          if ((~(-1 << (*(void *)v224 >> 58)) & (*(void *)v224 >> 1)) != 0) {
            LODWORD(v15sub_1CD456CB4((void *)this + 1) = v150;
          }
          else {
            LODWORD(v15sub_1CD456CB4((void *)this + 1) = -1;
          }
        }
        else
        {
          int v140 = *(_DWORD *)(*(void *)v224 + 64);
          if (!v140) {
            goto LABEL_254;
          }
          uint64_t v141 = 0;
          int v142 = v140 - 1;
          uint64_t v143 = **(uint64_t ***)v224;
          unint64_t v144 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v140;
          uint64_t v145 = v142 & 0xFFFFFFC0;
          while (1)
          {
            uint64_t v147 = *v143++;
            uint64_t v146 = v147;
            unint64_t v148 = v145 == v141 ? v144 : -1;
            unint64_t v149 = v148 & v146;
            if (v149) {
              break;
            }
            v141 += 64;
            if (v145 + 64 == v141) {
              goto LABEL_254;
            }
          }
          uint64_t v151 = __clz(__rbit64(v149)) + v141;
        }
        if (v151 == -1) {
          goto LABEL_254;
        }
        unint64_t v152 = v151;
        do
        {
          if (LODWORD(v238[6 * v152 + 2]) == 1)
          {
            int v153 = (void *)v223;
            if (v223)
            {
              unint64_t v223 = v223 & 0xFC00000000000000 | (2
                                                  * (((v223 >> 1) & ~(-1 << (v223 >> 58)) | (1 << v152)) & ~(-1 << (v223 >> 58)))) | 1;
              goto LABEL_182;
            }
LABEL_180:
            *(void *)(*v153 + ((v152 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v152;
            goto LABEL_182;
          }
          int v153 = (void *)v222;
          if ((v222 & 1) == 0) {
            goto LABEL_180;
          }
          unint64_t v222 = v222 & 0xFC00000000000000 | (2
                                              * (((v222 >> 1) & ~(-1 << (v222 >> 58)) | (1 << v152)) & ~(-1 << (v222 >> 58)))) | 1;
LABEL_182:
          LODWORD(v15sub_1CD456CB4((void *)this + 1) = sub_1CB9F9DF0((unint64_t *)v224, v151);
          unint64_t v152 = v151;
        }
        while (v151 != -1);
        while (1)
        {
LABEL_254:
          while ((v223 & 1) != 0)
          {
            unint64_t v157 = (v223 >> 1) & ~(-1 << (v223 >> 58));
            if (!v157) {
              goto LABEL_256;
            }
            LODWORD(v158) = __clz(__rbit64(v157));
LABEL_199:
            if (v158 != -1)
            {
              char v168 = 0;
              unint64_t v169 = v158;
              while (1)
              {
                unsigned int v221 = 0;
                uint64_t v220 = 0;
                llvm::DependenceInfo::testSIV((llvm::ScalarEvolution **)this, (const llvm::SCEV *)v238[6 * v169], (const llvm::SCEV *)v238[6 * v169 + 1], &v221, (llvm::FullDependence *)v231, (llvm::DependenceInfo::Constraint *)&v227, &v220);
                unsigned int v170 = v221;
                if (v221 == a3 && v220 != 0) {
                  break;
                }
                if (v139) {
                  unint64_t v139 = v139 & 0xFC00000000000000 | (2
                }
                                                      * (((1 << v221) | (v139 >> 1) & ~(-1 << (v139 >> 58))) & ~(-1 << (v139 >> 58)))) | 1;
                else {
                  *(void *)(*(void *)v139 + 8 * (v221 >> 6)) |= 1 << v221;
                }
                char v172 = llvm::DependenceInfo::intersectConstraints(this, (llvm::DependenceInfo::Constraint *)(v234 + 48 * v170), (const llvm::DependenceInfo::Constraint *)&v227);
                if (v223) {
                  unint64_t v223 = ((2 * ~((-1 << (v223 >> 58)) | (1 << v169))) | 0xFC00000000000000) & v223 | 1;
                }
                else {
                  *(void *)(*(void *)v223 + ((v169 >> 3) & 0x1FFFFFFFFFFFFFF8)) &= ~(1 << v169);
                }
                v168 |= v172;
                LODWORD(v158) = sub_1CB9F9DF0(&v223, v158);
                unint64_t v169 = v158;
                if (v158 == -1)
                {
                  if ((v168 & 1) == 0) {
                    goto LABEL_254;
                  }
                  if (v222)
                  {
                    int v183 = __clz(__rbit64(~(-1 << (v222 >> 58)) & (v222 >> 1)));
                    if ((~(-1 << (v222 >> 58)) & (v222 >> 1)) != 0) {
                      LODWORD(v184) = v183;
                    }
                    else {
                      LODWORD(v184) = -1;
                    }
                  }
                  else
                  {
                    int v173 = *(_DWORD *)(v222 + 64);
                    if (!v173) {
                      goto LABEL_254;
                    }
                    uint64_t v174 = 0;
                    int v175 = v173 - 1;
                    int v176 = *(uint64_t **)v222;
                    unint64_t v177 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v173;
                    uint64_t v178 = v175 & 0xFFFFFFC0;
                    while (1)
                    {
                      uint64_t v180 = *v176++;
                      uint64_t v179 = v180;
                      unint64_t v181 = v178 == v174 ? v177 : -1;
                      unint64_t v182 = v181 & v179;
                      if (v182) {
                        break;
                      }
                      v174 += 64;
                      if (v178 + 64 == v174) {
                        goto LABEL_254;
                      }
                    }
                    uint64_t v184 = __clz(__rbit64(v182)) + v174;
                  }
                  if (v184 != -1)
                  {
                    unint64_t v185 = v184;
                    do
                    {
                      if (llvm::DependenceInfo::propagate((llvm::ScalarEvolution **)this, (const llvm::SCEV **)&v238[6 * v185], (const llvm::SCEV **)&v238[6 * v185 + 1], (unint64_t *)&v238[6 * v185 + 3], &v234, &v232))
                      {
                        uint64_t v186 = (uint64_t *)*((void *)this + 2);
                        int v187 = *((_DWORD *)v186 + 4);
                        if (v187)
                        {
                          uint64_t v188 = *(void *)(v3 + 40);
                          uint64_t v189 = *v186;
                          unsigned int v190 = v187 - 1;
                          uint64_t v191 = ((v188 >> 4) ^ (v188 >> 9)) & v190;
                          uint64_t v192 = *(void *)(v189 + 16 * v191);
                          if (v188 == v192)
                          {
LABEL_237:
                            unint64_t v195 = *(const llvm::Loop **)(v189 + 16 * v191 + 8);
                          }
                          else
                          {
                            int v193 = 1;
                            while (v192 != -4096)
                            {
                              int v194 = v191 + v193++;
                              uint64_t v191 = v194 & v190;
                              uint64_t v192 = *(void *)(v189 + 16 * v191);
                              if (v188 == v192) {
                                goto LABEL_237;
                              }
                            }
                            unint64_t v195 = 0;
                          }
                          uint64_t v196 = (llvm::SCEV *)v238[6 * v185 + 1];
                          uint64_t v197 = *(void *)(v213 + 40);
                          uint64_t v198 = ((v197 >> 4) ^ (v197 >> 9)) & v190;
                          uint64_t v199 = *(void *)(v189 + 16 * v198);
                          if (v197 == v199)
                          {
LABEL_243:
                            uint64_t v202 = *(const llvm::Loop **)(v189 + 16 * v198 + 8);
                          }
                          else
                          {
                            int v200 = 1;
                            while (v199 != -4096)
                            {
                              int v201 = v198 + v200++;
                              uint64_t v198 = v201 & v190;
                              uint64_t v199 = *(void *)(v189 + 16 * v198);
                              if (v197 == v199) {
                                goto LABEL_243;
                              }
                            }
                            uint64_t v202 = 0;
                          }
                        }
                        else
                        {
                          unint64_t v195 = 0;
                          uint64_t v202 = 0;
                          uint64_t v196 = (llvm::SCEV *)v238[6 * v185 + 1];
                        }
                        int v203 = llvm::DependenceInfo::classifyPair((uint64_t)this, (llvm::SCEV *)v238[6 * v185], v195, v196, v202, (uint64_t *)&v238[6 * v185 + 3]);
                        LODWORD(v238[6 * v185 + 2]) = v203;
                        if ((v203 - 2) >= 2)
                        {
                          if (v203 == 1)
                          {
                            if (v223) {
                              unint64_t v223 = v223 & 0xFC00000000000000 | (2
                            }
                                                                  * (((v223 >> 1) & ~(-1 << (v223 >> 58)) | (1 << v185)) & ~(-1 << (v223 >> 58)))) | 1;
                            else {
                              *(void *)(*(void *)v223 + ((v185 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v185;
                            }
                          }
                          if (v222) {
                            unint64_t v222 = ((2 * ~((-1 << (v222 >> 58)) | (1 << v185))) | 0xFC00000000000000) & v222 | 1;
                          }
                          else {
                            *(void *)(*(void *)v222 + ((v185 >> 3) & 0x1FFFFFFFFFFFFFF8)) &= ~(1 << v185);
                          }
                        }
                      }
                      LODWORD(v184) = sub_1CB9F9DF0(&v222, v184);
                      unint64_t v185 = v184;
                    }
                    while (v184 != -1);
                  }
                  goto LABEL_254;
                }
              }
              int v205 = 0;
              unint64_t v8 = (unint64_t)v220;
              if (v139) {
                goto LABEL_257;
              }
              goto LABEL_264;
            }
          }
          uint64_t v204 = *(unsigned int *)(v223 + 8);
          if (!v204) {
            break;
          }
          uint64_t v154 = *(uint64_t **)v223;
          uint64_t v155 = 8 * v204;
          unsigned int v156 = *(void **)v223;
          while (!*v156)
          {
            ++v156;
            v155 -= 8;
            if (!v155) {
              goto LABEL_256;
            }
          }
          int v159 = *(_DWORD *)(v223 + 64);
          if (v159)
          {
            uint64_t v160 = 0;
            int v161 = v159 - 1;
            unint64_t v162 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v159;
            uint64_t v163 = v161 & 0xFFFFFFC0;
            while (1)
            {
              uint64_t v165 = *v154++;
              uint64_t v164 = v165;
              unint64_t v166 = v163 == v160 ? v162 : -1;
              unint64_t v167 = v166 & v164;
              if (v167) {
                break;
              }
              v160 += 64;
              if (v163 + 64 == v160) {
                goto LABEL_254;
              }
            }
            uint64_t v158 = __clz(__rbit64(v167)) + v160;
            goto LABEL_199;
          }
        }
LABEL_256:
        int v205 = 1;
        if (v139) {
          goto LABEL_257;
        }
LABEL_264:
        if (*(void *)v139 != v139 + 16) {
          free(*(void **)v139);
        }
        MEMORY[0x1D25D9CE0](v139, 0x1080C40EF38A13ELL);
LABEL_257:
        unint64_t v206 = v222;
        if ((v222 & 1) == 0 && v222)
        {
          if (*(void *)v222 != v222 + 16) {
            free(*(void **)v222);
          }
          MEMORY[0x1D25D9CE0](v206, 0x1080C40EF38A13ELL);
        }
        unint64_t v207 = v223;
        if ((v223 & 1) == 0 && v223)
        {
          if (*(void *)v223 != v223 + 16) {
            free(*(void **)v223);
          }
          MEMORY[0x1D25D9CE0](v207, 0x1080C40EF38A13ELL);
        }
        uint64_t v208 = *(void *)v224;
        if ((v224[0] & 1) == 0 && *(void *)v224)
        {
          if (**(void **)v224 != *(void *)v224 + 16) {
            free(**(void ***)v224);
          }
          MEMORY[0x1D25D9CE0](v208, 0x1080C40EF38A13ELL);
        }
        if (v205)
        {
          LODWORD(v135) = sub_1CB9F9DF0(&v229, v135);
          uint64_t v136 = v135;
          if (v135 != -1) {
            continue;
          }
        }
        uint64_t v118 = (char *)v234;
        break;
      }
    }
LABEL_283:
    if (v118 != (char *)&v235) {
      free(v118);
    }
  }
  unint64_t v209 = v229;
  if ((v229 & 1) == 0 && v229)
  {
    if (*(void *)v229 != v229 + 16) {
      free(*(void **)v229);
    }
    MEMORY[0x1D25D9CE0](v209, 0x1080C40EF38A13ELL);
  }
  unint64_t v210 = v230;
  if ((v230 & 1) == 0 && v230)
  {
    if (*(void *)v230 != v230 + 16) {
      free(*(void **)v230);
    }
    MEMORY[0x1D25D9CE0](v210, 0x1080C40EF38A13ELL);
  }
  sub_1CD480D50(v238, &v238[6 * v239]);
  if (v238 != v240) {
    free(v238);
  }
  uint64_t v211 = v233;
  uint64_t v233 = 0;
  if (v211) {
    MEMORY[0x1D25D9CB0](v211, 0x1060C80768B1B2DLL);
  }
  return v8;
}

void sub_1CBFDFCA4(llvm::Pass *this)
{
  *(void *)this = &unk_1F2602718;
  uint64_t v2 = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v2) {
    MEMORY[0x1D25D9CE0](v2, 0x1020C4063BC1FCFLL);
  }

  llvm::Pass::~Pass(this);
}

void sub_1CBFDFD14(llvm::Pass *this)
{
  *(void *)this = &unk_1F2602718;
  uint64_t v2 = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v2) {
    MEMORY[0x1D25D9CE0](v2, 0x1020C4063BC1FCFLL);
  }
  llvm::Pass::~Pass(this);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t *sub_1CBFDFD98(unint64_t *result, unsigned int a2, int a3)
{
  void *result = 1;
  if (a2 > 0x39) {
    operator new();
  }
  uint64_t v3 = 2 * ~(-1 << a2);
  if (!a3) {
    uint64_t v3 = 0;
  }
  void *result = v3 | ((unint64_t)a2 << 58) | 1;
  return result;
}

uint64_t *sub_1CBFDFE2C(uint64_t *result, uint64_t a2, long long *a3)
{
  if (a2)
  {
    uint64_t v3 = result;
    uint64_t v4 = (uint64_t *)a3 + 5;
    BOOL v5 = (uint64_t *)(a3 + 2);
    long long v6 = *a3;
    *((_DWORD *)result + 4) = *((_DWORD *)a3 + 4);
    *(_OWORD *)uint64_t result = v6;
    sub_1CBC563DC(result + 3, (uint64_t *)a3 + 3);
    sub_1CBC563DC(v3 + 4, v5);
    return sub_1CBC563DC(v3 + 5, v4);
  }
  return result;
}

uint64_t sub_1CBFDFEA0(uint64_t result, long long *a2)
{
  long long v2 = *a2;
  *(_DWORD *)(result + 16) = *((_DWORD *)a2 + 4);
  *(_OWORD *)uint64_t result = v2;
  *(void *)(result + 24) = 1;
  uint64_t v3 = *((void *)a2 + 3);
  if ((v3 & 1) == 0) {
    operator new();
  }
  *(void *)(result + 24) = v3;
  *(void *)(result + 32) = 1;
  uint64_t v4 = *((void *)a2 + 4);
  if ((v4 & 1) == 0) {
    operator new();
  }
  *(void *)(result + 32) = v4;
  *(void *)(result + 40) = 1;
  uint64_t v5 = *((void *)a2 + 5);
  if ((v5 & 1) == 0) {
    operator new();
  }
  *(void *)(result + 40) = v5;
  return result;
}

uint64_t sub_1CBFE00D4()
{
  LOBYTE(v2) = 1;
  uint64_t v5 = &v2;
  int v3 = 1;
  int v4 = 1;
  v1.n128_u64[0] = (unint64_t)"Try to delinearize array references.";
  v1.n128_u64[1] = 36;
  sub_1CD4808EC((char **)&v5, &v4, &v3, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCC52F0, &dword_1CB82C000);
  LOBYTE(v2) = 0;
  uint64_t v5 = &v2;
  int v3 = 1;
  int v4 = 1;
  v1.n128_u64[0] = (unint64_t)"Disable checks that try to statically verify validity of delinearized subscripts. E"
                                     "nabling this option may result in incorrect dependence vectors for languages that a"
                                     "llow the subscript of one dimension to underflow or overflow into another dimension.";
  v1.n128_u64[1] = 250;
  sub_1CD462280((llvm::cl::Option *)&unk_1EBCC53B0, "da-disable-delinearization-checks", (unsigned char **)&v5, &v4, &v3, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCC53B0, &dword_1CB82C000);
  int v3 = 1;
  int v4 = 7;
  uint64_t v5 = &v4;
  int v2 = 1;
  v1.n128_u64[0] = (unint64_t)"Maximum depth allowed for the recursive algorithm used to explore MIV direction vectors.";
  v1.n128_u64[1] = 88;
  sub_1CD480A84(&v5, &v3, &v2, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB8598A4, &qword_1EBCC5470, &dword_1CB82C000);
}

uint64_t llvm::AbstractDependenceGraphBuilder<llvm::DataDependenceGraph>::AbstractDependenceGraphBuilder(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)uint64_t result = &unk_1F2602510;
  *(void *)(result + 8) = a2;
  *(void *)(result + 16) = a3;
  *(void *)(result + 24) = a4;
  *(void *)(result + 32) = 0;
  *(void *)(result + 40) = 0;
  *(_DWORD *)(result + 48) = 0;
  *(void *)(result + 56) = 0;
  *(void *)(result + 64) = 0;
  *(_DWORD *)(result + 72) = 0;
  *(void *)(result + 80) = 0;
  *(void *)(result + 88) = 0;
  *(_DWORD *)(result + 96) = 0;
  return result;
}

void llvm::AbstractDependenceGraphBuilder<llvm::DataDependenceGraph>::createDefUseEdges(uint64_t a1)
{
  v42[2] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(unsigned int *)(v1 + 96);
  if (!v2) {
    return;
  }
  int v4 = *(uint64_t **)(v1 + 88);
  uint64_t v5 = &v4[v2];
  do
  {
    uint64_t v6 = *v4;
    uint64_t v40 = v42;
    uint64_t v41 = 0x200000000;
    uint64_t v34 = sub_1CD481F50;
    int v35 = &v39;
    llvm::DDGNode::collectInstructions(v6, (uint64_t)&v34, (unsigned int *)&v40);
    uint64_t v34 = (uint64_t (*)())v38;
    int v35 = (uint64_t *)v38;
    uint64_t v36 = 4;
    int v37 = 0;
    if (!v41) {
      goto LABEL_65;
    }
    BOOL v7 = (char *)v40;
    unint64_t v8 = (char *)v40 + 8 * v41;
    do
    {
      uint64_t v9 = *(void *)(*(void *)v7 + 8);
      if (v9)
      {
        while (1)
        {
          uint64_t v10 = *(void *)(v9 + 24);
          if (v10) {
            BOOL v11 = *(unsigned __int8 *)(v10 + 16) >= 0x1Cu;
          }
          else {
            BOOL v11 = 0;
          }
          if (!v11) {
            goto LABEL_10;
          }
          uint64_t v39 = 0;
          int v12 = sub_1CD40EA84(*(void *)(a1 + 32), *(_DWORD *)(a1 + 48), v10, &v39);
          uint64_t v13 = *(void *)(a1 + 32);
          uint64_t v14 = *(unsigned int *)(a1 + 48);
          if (!v12 || v39 == v13 + 16 * v14) {
            goto LABEL_10;
          }
          uint64_t v39 = 0;
          uint64_t v16 = (sub_1CD40EA84(v13, v14, v10, &v39) & 1) != 0
              ? v39
              : *(void *)(a1 + 32) + 16 * *(unsigned int *)(a1 + 48);
          uint64_t v17 = *(void *)(v16 + 8);
          if (!v17 || v17 == v6) {
            goto LABEL_10;
          }
          int v19 = v35;
          uint64_t v20 = HIDWORD(v36);
          if (v35 != (uint64_t *)v34) {
            break;
          }
          if (HIDWORD(v36))
          {
            int v21 = 0;
            uint64_t v22 = 8 * HIDWORD(v36);
            uint64_t v23 = v35;
            while (*v23 != v17)
            {
              if (*v23 == -2) {
                int v21 = v23;
              }
              ++v23;
              v22 -= 8;
              if (!v22)
              {
                if (!v21) {
                  goto LABEL_31;
                }
                *int v21 = v17;
                --v37;
                goto LABEL_55;
              }
            }
            goto LABEL_10;
          }
LABEL_31:
          unsigned int v24 = v36;
          if (HIDWORD(v36) >= v36) {
            goto LABEL_34;
          }
          ++HIDWORD(v36);
          v35[v20] = v17;
LABEL_55:
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 40))(a1, v6, v17);
LABEL_10:
          uint64_t v9 = *(void *)(v9 + 8);
          if (!v9) {
            goto LABEL_62;
          }
        }
        unsigned int v24 = v36;
LABEL_34:
        if (3 * v24 <= 4 * (HIDWORD(v36) - v37))
        {
          if (v24 >= 0x40) {
            v24 *= 2;
          }
          else {
            unsigned int v24 = 128;
          }
        }
        else if (v24 - HIDWORD(v36) >= v24 >> 3)
        {
LABEL_36:
          unsigned int v25 = v24 - 1;
          unsigned int v26 = (v24 - 1) & ((v17 >> 4) ^ (v17 >> 9));
          uint64_t v27 = &v19[v26];
          uint64_t v28 = *v27;
          if (*v27 != -1)
          {
            uint64_t v29 = 0;
            int v30 = 1;
            while (v28 != v17)
            {
              if (v29) {
                BOOL v31 = 0;
              }
              else {
                BOOL v31 = v28 == -2;
              }
              if (v31) {
                uint64_t v29 = v27;
              }
              unsigned int v32 = v26 + v30++;
              unsigned int v26 = v32 & v25;
              uint64_t v27 = &v19[v32 & v25];
              uint64_t v28 = *v27;
              if (*v27 == -1) {
                goto LABEL_48;
              }
            }
            goto LABEL_10;
          }
          uint64_t v29 = 0;
LABEL_48:
          if (v29) {
            BOOL v33 = v29;
          }
          else {
            BOOL v33 = v27;
          }
          if (*v33 == v17) {
            goto LABEL_10;
          }
          if (*v33 == -2) {
            --v37;
          }
          else {
            ++HIDWORD(v36);
          }
          *BOOL v33 = v17;
          goto LABEL_55;
        }
        llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v34, v24);
        unsigned int v24 = v36;
        int v19 = v35;
        goto LABEL_36;
      }
LABEL_62:
      v7 += 8;
    }
    while (v7 != v8);
    if (v35 != (uint64_t *)v34) {
      free(v35);
    }
LABEL_65:
    if (v40 != v42) {
      free(v40);
    }
    ++v4;
  }
  while (v4 != v5);
}

void llvm::AbstractDependenceGraphBuilder<llvm::DataDependenceGraph>::createMemoryDependencyEdges(void *a1)
{
  v34[2] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1[1];
  uint64_t v2 = *(unsigned int *)(v1 + 96);
  if (!v2) {
    return;
  }
  int v4 = *(uint64_t **)(v1 + 88);
  uint64_t v5 = &v4[v2];
  unsigned int v24 = v5;
  do
  {
    unsigned int v32 = v34;
    uint64_t v33 = 0x200000000;
    uint64_t v6 = *v4;
    uint64_t v29 = sub_1CD481F58;
    uint64_t v30 = (uint64_t)&v28;
    llvm::DDGNode::collectInstructions(v6, (uint64_t)&v29, (unsigned int *)&v32);
    if (v4 == v5 || !v33) {
      goto LABEL_57;
    }
    BOOL v7 = v4;
    do
    {
      uint64_t v8 = *v7;
      if (*v7 == *v4) {
        goto LABEL_7;
      }
      uint64_t v29 = v31;
      uint64_t v30 = 0x200000000;
      v27[0] = (llvm::Instruction **)sub_1CD481F58;
      v27[1] = (llvm::Instruction **)&v28;
      llvm::DDGNode::collectInstructions(v8, (uint64_t)v27, (unsigned int *)&v29);
      if (!v30 || !v33) {
        goto LABEL_54;
      }
      int v9 = 0;
      int v10 = 0;
      BOOL v11 = (llvm::Instruction **)v32;
      unsigned int v25 = (char *)v32 + 8 * v33;
      do
      {
        unsigned int v26 = v11;
        if (!v30) {
          goto LABEL_48;
        }
        int v12 = *v11;
        uint64_t v13 = (llvm::Instruction **)v29;
        uint64_t v14 = (llvm::Instruction **)((char *)v29 + 8 * v30);
        while (1)
        {
          llvm::DependenceInfo::depends(a1[2], v12, *v13, 1, v27);
          if (v27[0]) {
            break;
          }
LABEL_29:
          if (++v13 == v14) {
            goto LABEL_48;
          }
        }
        if ((*((unsigned int (**)(llvm::Instruction **))*v27[0] + 3))(v27[0]))
        {
LABEL_16:
          uint64_t v15 = *v4;
          uint64_t v16 = *v7;
          if (v10)
          {
            if (v9) {
              goto LABEL_18;
            }
LABEL_32:
            (*(void (**)(void *, uint64_t, uint64_t))(*a1 + 48))(a1, v16, v15);
          }
          else
          {
            (*(void (**)(void *, uint64_t, uint64_t))(*a1 + 48))(a1, *v4, *v7);
            if (!v9) {
              goto LABEL_32;
            }
          }
LABEL_18:
          int v10 = 1;
LABEL_19:
          int v9 = 1;
          goto LABEL_20;
        }
        if (sub_1CD481868(v27[0])
          && ((*((uint64_t (**)(llvm::Instruction **))*v27[0] + 2))(v27[0]) & 1) == 0
          && (*((unsigned int (**)(llvm::Instruction **))*v27[0] + 5))(v27[0]))
        {
          uint64_t v20 = 1;
          while (1)
          {
            int v21 = (*((uint64_t (**)(llvm::Instruction **, uint64_t))*v27[0] + 6))(v27[0], v20);
            uint64_t v22 = (uint64_t)*v27[0];
            if (v21 != 2) {
              break;
            }
            uint64_t v20 = (v20 + 1);
            if (v20 > (*(unsigned int (**)(void))(v22 + 40))()) {
              goto LABEL_44;
            }
          }
          if ((*(unsigned int (**)(void))(v22 + 48))() == 4)
          {
            if (!v9) {
              (*(void (**)(void *, uint64_t, uint64_t))(*a1 + 48))(a1, *v7, *v4);
            }
            goto LABEL_19;
          }
          if ((*((unsigned int (**)(llvm::Instruction **, uint64_t))*v27[0] + 6))(v27[0], v20) != 1) {
            goto LABEL_16;
          }
        }
LABEL_44:
        if (!v10) {
          (*(void (**)(void *, uint64_t, uint64_t))(*a1 + 48))(a1, *v4, *v7);
        }
        int v10 = 1;
LABEL_20:
        if (v10) {
          BOOL v17 = v9 == 0;
        }
        else {
          BOOL v17 = 1;
        }
        int v18 = v17;
        int v19 = v27[0];
        v27[0] = 0;
        if (v19) {
          (*((void (**)(llvm::Instruction **))*v19 + 1))(v19);
        }
        if (v18) {
          goto LABEL_29;
        }
        int v10 = 1;
        int v9 = 1;
LABEL_48:
        if (v9) {
          BOOL v23 = v10 == 0;
        }
        else {
          BOOL v23 = 1;
        }
        if (!v23) {
          break;
        }
        BOOL v11 = v26 + 1;
      }
      while (v26 + 1 != (llvm::Instruction **)v25);
LABEL_54:
      if (v29 != v31) {
        free(v29);
      }
      uint64_t v5 = v24;
LABEL_7:
      ++v7;
    }
    while (v7 != v5);
LABEL_57:
    if (v32 != v34) {
      free(v32);
    }
    ++v4;
  }
  while (v4 != v5);
}

void llvm::AbstractDependenceGraphBuilder<llvm::DataDependenceGraph>::simplify(void *a1)
{
  v97[32] = *MEMORY[0x1E4F143B8];
  if (!(*(unsigned int (**)(void *))(*a1 + 96))(a1)) {
    return;
  }
  uint64_t v90 = v94;
  unsigned int v91 = v94;
  uint64_t v92 = 32;
  int v93 = 0;
  v88[0] = 0;
  v88[1] = 0;
  int v89 = 0;
  uint64_t v2 = a1[1];
  uint64_t v3 = *(unsigned int *)(v2 + 96);
  if (!v3) {
    goto LABEL_62;
  }
  int v4 = *(uint64_t **)(v2 + 88);
  uint64_t v5 = &v4[v3];
  do
  {
    uint64_t v6 = *v4;
    uint64_t v7 = *(void *)(*v4 + 40);
    if (v7 - *(void *)(*v4 + 32) == 8)
    {
      uint64_t v8 = *(void *)(v7 - 8);
      if (*(_DWORD *)(v8 + 8) == 1)
      {
        int v9 = v91;
        uint64_t v10 = HIDWORD(v92);
        if (v91 == v90)
        {
          if (HIDWORD(v92))
          {
            BOOL v11 = 0;
            uint64_t v12 = 8 * HIDWORD(v92);
            uint64_t v13 = v91;
            while (*v13 != v6)
            {
              if (*v13 == -2) {
                BOOL v11 = v13;
              }
              ++v13;
              v12 -= 8;
              if (!v12)
              {
                if (!v11) {
                  goto LABEL_17;
                }
                *BOOL v11 = v6;
                --v93;
                goto LABEL_41;
              }
            }
            goto LABEL_41;
          }
LABEL_17:
          unsigned int v14 = v92;
          if (HIDWORD(v92) < v92)
          {
            ++HIDWORD(v92);
            *(void *)&v91[8 * v10] = v6;
LABEL_41:
            uint64_t v86 = *(void *)v8;
            int v87 = 0;
            sub_1CD40E370((uint64_t)&v95, (uint64_t)v88, &v86, &v87);
            goto LABEL_7;
          }
        }
        else
        {
          unsigned int v14 = v92;
        }
        if (3 * v14 <= 4 * (HIDWORD(v92) - v93))
        {
          if (v14 >= 0x40) {
            v14 *= 2;
          }
          else {
            unsigned int v14 = 128;
          }
        }
        else if (v14 - HIDWORD(v92) >= v14 >> 3)
        {
          goto LABEL_22;
        }
        llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v90, v14);
        unsigned int v14 = v92;
        int v9 = v91;
LABEL_22:
        unsigned int v15 = v14 - 1;
        unsigned int v16 = (v14 - 1) & ((v6 >> 4) ^ (v6 >> 9));
        BOOL v17 = &v9[8 * v16];
        uint64_t v18 = *(void *)v17;
        if (*(void *)v17 == -1)
        {
          int v19 = 0;
LABEL_34:
          if (v19) {
            BOOL v23 = v19;
          }
          else {
            BOOL v23 = v17;
          }
          if (*(void *)v23 != v6)
          {
            if (*(void *)v23 == -2) {
              --v93;
            }
            else {
              ++HIDWORD(v92);
            }
            *(void *)BOOL v23 = v6;
          }
        }
        else
        {
          int v19 = 0;
          int v20 = 1;
          while (v18 != v6)
          {
            if (v19) {
              BOOL v21 = 0;
            }
            else {
              BOOL v21 = v18 == -2;
            }
            if (v21) {
              int v19 = v17;
            }
            unsigned int v22 = v16 + v20++;
            unsigned int v16 = v22 & v15;
            BOOL v17 = &v9[8 * (v22 & v15)];
            uint64_t v18 = *(void *)v17;
            if (*(void *)v17 == -1) {
              goto LABEL_34;
            }
          }
        }
        goto LABEL_41;
      }
    }
LABEL_7:
    ++v4;
  }
  while (v4 != v5);
  uint64_t v24 = a1[1];
  uint64_t v25 = *(unsigned int *)(v24 + 96);
  if (v25)
  {
    uint64_t v26 = *(void *)(v24 + 88);
    uint64_t v27 = v26 + 8 * v25;
    uint64_t v28 = v88[0];
    int v29 = v89;
    unsigned int v30 = v89 - 1;
    do
    {
      BOOL v31 = *(uint64_t ***)(*(void *)v26 + 32);
      unsigned int v32 = *(uint64_t ***)(*(void *)v26 + 40);
      while (v31 != v32)
      {
        if (v29)
        {
          uint64_t v33 = **v31;
          uint64_t v34 = ((v33 >> 4) ^ (v33 >> 9)) & v30;
          uint64_t v35 = *(void *)(v28 + 16 * v34);
          if (v33 == v35)
          {
LABEL_54:
            if (v34 != v29) {
              ++*(_DWORD *)(v28 + 16 * v34 + 8);
            }
          }
          else
          {
            int v36 = 1;
            while (v35 != -4096)
            {
              int v37 = v34 + v36++;
              uint64_t v34 = v37 & v30;
              uint64_t v35 = *(void *)(v28 + 16 * v34);
              if (v33 == v35) {
                goto LABEL_54;
              }
            }
          }
        }
        ++v31;
      }
      v26 += 8;
    }
    while (v26 != v27);
  }
LABEL_62:
  uint64_t v38 = (unint64_t *)v91;
  if (v91 == v90) {
    uint64_t v39 = (uint64_t *)((char *)&v92 + 4);
  }
  else {
    uint64_t v39 = &v92;
  }
  uint64_t v40 = *(unsigned int *)v39;
  uint64_t v41 = (unint64_t *)&v91[8 * v40];
  if (v40)
  {
    uint64_t v42 = 8 * v40;
    while (*v38 >= 0xFFFFFFFFFFFFFFFELL)
    {
      ++v38;
      v42 -= 8;
      if (!v42)
      {
        uint64_t v38 = v41;
        break;
      }
    }
  }
  int v95 = v97;
  uint64_t v96 = 0x2000000000;
  sub_1CD482BCC((uint64_t)&v95, v38, v41, v41);
  unsigned int v43 = v96;
  if (v96)
  {
    while (2)
    {
      uint64_t v44 = *((void *)v95 + v43 - 1);
      LODWORD(v96) = v43 - 1;
      unsigned int v45 = v90;
      if (v91 == v90)
      {
        int v46 = HIDWORD(v92);
        uint64_t v47 = &v91[8 * HIDWORD(v92)];
        if (HIDWORD(v92))
        {
          uint64_t v48 = 0;
          while (*(void *)&v91[v48] != v44)
          {
            v48 += 8;
            if (8 * HIDWORD(v92) == v48) {
              goto LABEL_90;
            }
          }
          uint64_t v47 = &v91[v48];
        }
LABEL_90:
        unsigned int v45 = v91;
      }
      else
      {
        int v49 = v92 - 1;
        unsigned int v50 = (v92 - 1) & ((v44 >> 4) ^ (v44 >> 9));
        uint64_t v47 = &v91[8 * v50];
        uint64_t v51 = *(void *)v47;
        if (*(void *)v47 == -1)
        {
          int v52 = 0;
LABEL_98:
          if (v52) {
            uint64_t v47 = v52;
          }
          int v46 = HIDWORD(v92);
          if (*(void *)v47 != v44) {
            uint64_t v47 = &v91[8 * v92];
          }
        }
        else
        {
          int v52 = 0;
          int v53 = 1;
          while (v51 != v44)
          {
            if (v52) {
              BOOL v54 = 0;
            }
            else {
              BOOL v54 = v51 == -2;
            }
            if (v54) {
              int v52 = v47;
            }
            unsigned int v55 = v50 + v53++;
            unsigned int v50 = v55 & v49;
            uint64_t v47 = &v91[8 * (v55 & v49)];
            uint64_t v51 = *(void *)v47;
            if (*(void *)v47 == -1) {
              goto LABEL_98;
            }
          }
          int v46 = HIDWORD(v92);
        }
      }
      if (v91 == v45) {
        int v56 = v46;
      }
      else {
        int v56 = v92;
      }
      if (v47 == &v91[8 * v56]) {
        goto LABEL_95;
      }
      *(void *)uint64_t v47 = -2;
      ++v93;
      uint64_t v57 = **(void **)(*(void *)(v44 + 40) - 8);
      uint64_t v86 = v57;
      if (*((_DWORD *)sub_1CD40EB18((uint64_t)v88, &v86) + 2) != 1
        || !(*(unsigned int (**)(void *, uint64_t, uint64_t))(*a1 + 104))(a1, v44, v57))
      {
        goto LABEL_95;
      }
      for (unsigned int i = *(void ***)(v57 + 32); i != *(void ***)(v57 + 40); ++i)
      {
        if (**i == v44) {
          goto LABEL_95;
        }
      }
      (*(void (**)(void *, uint64_t, uint64_t))(*a1 + 112))(a1, v44, v57);
      uint64_t v59 = v90;
      if (v91 == v90)
      {
        int v60 = HIDWORD(v92);
        int v61 = &v91[8 * HIDWORD(v92)];
        if (HIDWORD(v92))
        {
          uint64_t v62 = 0;
          while (*(void *)&v91[v62] != v57)
          {
            v62 += 8;
            if (8 * HIDWORD(v92) == v62) {
              goto LABEL_128;
            }
          }
          int v61 = &v91[v62];
        }
LABEL_128:
        uint64_t v59 = v91;
      }
      else
      {
        int v63 = v92 - 1;
        unsigned int v64 = (v92 - 1) & ((v57 >> 4) ^ (v57 >> 9));
        int v61 = &v91[8 * v64];
        uint64_t v65 = *(void *)v61;
        if (*(void *)v61 == -1)
        {
          uint64_t v66 = 0;
LABEL_167:
          if (v66) {
            int v61 = v66;
          }
          int v60 = HIDWORD(v92);
          if (*(void *)v61 != v57) {
            int v61 = &v91[8 * v92];
          }
        }
        else
        {
          uint64_t v66 = 0;
          int v67 = 1;
          while (v65 != v57)
          {
            if (v66) {
              BOOL v68 = 0;
            }
            else {
              BOOL v68 = v65 == -2;
            }
            if (v68) {
              uint64_t v66 = v61;
            }
            unsigned int v69 = v64 + v67++;
            unsigned int v64 = v69 & v63;
            int v61 = &v91[8 * (v69 & v63)];
            uint64_t v65 = *(void *)v61;
            if (*(void *)v61 == -1) {
              goto LABEL_167;
            }
          }
          int v60 = HIDWORD(v92);
        }
      }
      int v70 = v91 == v59 ? v60 : v92;
      if (v61 == &v91[8 * v70])
      {
LABEL_95:
        unsigned int v43 = v96;
        if (!v96) {
          goto LABEL_179;
        }
        continue;
      }
      break;
    }
    *(void *)int v61 = -2;
    ++v93;
    if (v96 >= (unint64_t)HIDWORD(v96)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)v95 + v96) = v44;
    LODWORD(v96) = v96 + 1;
    int v71 = v91;
    uint64_t v72 = HIDWORD(v92);
    if (v91 == v90)
    {
      if (HIDWORD(v92))
      {
        int8x8_t v73 = 0;
        uint64_t v74 = 8 * HIDWORD(v92);
        uint8x8_t v75 = v91;
        while (*v75 != v44)
        {
          if (*v75 == -2) {
            int8x8_t v73 = v75;
          }
          ++v75;
          v74 -= 8;
          if (!v74)
          {
            if (!v73) {
              goto LABEL_142;
            }
            *int8x8_t v73 = v44;
            --v93;
            goto LABEL_95;
          }
        }
        goto LABEL_95;
      }
LABEL_142:
      unsigned int v76 = v92;
      if (HIDWORD(v92) < v92)
      {
        ++HIDWORD(v92);
        *(void *)&v91[8 * v72] = v44;
        goto LABEL_95;
      }
    }
    else
    {
      unsigned int v76 = v92;
    }
    if (3 * v76 <= 4 * (HIDWORD(v92) - v93))
    {
      if (v76 >= 0x40) {
        v76 *= 2;
      }
      else {
        unsigned int v76 = 128;
      }
    }
    else if (v76 - HIDWORD(v92) >= v76 >> 3)
    {
      goto LABEL_147;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v90, v76);
    unsigned int v76 = v92;
    int v71 = v91;
LABEL_147:
    unsigned int v77 = v76 - 1;
    unsigned int v78 = (v76 - 1) & ((v44 >> 4) ^ (v44 >> 9));
    uint64_t v79 = &v71[8 * v78];
    uint64_t v80 = *(void *)v79;
    if (*(void *)v79 == -1)
    {
      unsigned int v81 = 0;
LABEL_159:
      if (v81) {
        int v85 = v81;
      }
      else {
        int v85 = v79;
      }
      if (*(void *)v85 != v44)
      {
        if (*(void *)v85 == -2) {
          --v93;
        }
        else {
          ++HIDWORD(v92);
        }
        *(void *)int v85 = v44;
      }
    }
    else
    {
      unsigned int v81 = 0;
      int v82 = 1;
      while (v80 != v44)
      {
        if (v81) {
          BOOL v83 = 0;
        }
        else {
          BOOL v83 = v80 == -2;
        }
        if (v83) {
          unsigned int v81 = v79;
        }
        unsigned int v84 = v78 + v82++;
        unsigned int v78 = v84 & v77;
        uint64_t v79 = &v71[8 * (v84 & v77)];
        uint64_t v80 = *(void *)v79;
        if (*(void *)v79 == -1) {
          goto LABEL_159;
        }
      }
    }
    goto LABEL_95;
  }
LABEL_179:
  if (v95 != v97) {
    free(v95);
  }
  MEMORY[0x1D25D9CD0](v88[0], 8);
  if (v91 != v90) {
    free(v91);
  }
}

void llvm::AbstractDependenceGraphBuilder<llvm::DataDependenceGraph>::createAndConnectRootNode(void *a1)
{
  uint64_t v2 = (*(uint64_t (**)(void *))(*a1 + 16))(a1);
  uint64_t v27 = v31;
  uint64_t v28 = v31;
  uint64_t v29 = 4;
  int v30 = 0;
  uint64_t v3 = a1[1];
  uint64_t v4 = *(unsigned int *)(v3 + 96);
  if (v4)
  {
    uint64_t v5 = v2;
    uint64_t v6 = *(uint64_t **)(v3 + 88);
    uint64_t v7 = &v6[v4];
    while (1)
    {
      uint64_t v8 = *v6;
      if (v5 == *v6) {
        goto LABEL_4;
      }
      sub_1CD481FA8(&v32, *v6, (llvm::SmallPtrSetImplBase *)&v27);
      int v9 = v33;
      v21[0] = v32;
      v21[1] = v33;
      long long v22 = v34;
      uint64_t v10 = (unsigned char *)v34;
      BOOL v23 = &v27;
      uint64_t v25 = 0;
      uint64_t v26 = 0;
      uint64_t v24 = 0;
      long long v34 = 0uLL;
      uint64_t v33 = 0;
      sub_1CBFE1720(&v33, v9, v10, (v10 - v9) >> 5);
      uint64_t v18 = 0;
      uint64_t v19 = 0;
      uint64_t v20 = 0;
      sub_1CBFE1720(&v18, v24, v25, (v25 - v24) >> 5);
      BOOL v11 = v18;
      uint64_t v12 = v19 - (void)v18;
      while (1)
      {
        uint64_t v13 = (void *)v34;
        if ((void)v34 - (void)v33 != v12) {
          goto LABEL_21;
        }
        if (v33 == (unsigned char *)v34) {
          break;
        }
        uint64_t v14 = 0;
        while (1)
        {
          unsigned int v15 = &v33[v14];
          if (*(void *)&v33[v14] != *(void *)&v11[v14]) {
            break;
          }
          int v16 = v11[v14 + 24];
          if (v15[24]) {
            BOOL v17 = v16 == 0;
          }
          else {
            BOOL v17 = 1;
          }
          if (v17)
          {
            if ((v15[24] == 0) == (v16 != 0)) {
              break;
            }
          }
          else if (*(void *)&v33[v14 + 8] != *(void *)&v11[v14 + 8])
          {
            break;
          }
          v14 += 32;
          if (v15 + 32 == (unsigned char *)v34)
          {
            uint64_t v13 = v33;
            goto LABEL_24;
          }
        }
LABEL_21:
        if (*(void *)(v34 - 32) == v8) {
          (*(void (**)(void *, uint64_t, uint64_t))(*a1 + 56))(a1, v5, v8);
        }
        sub_1CD48209C((char *)&v32);
      }
LABEL_24:
      if (v11) {
        operator delete(v11);
      }
      if (v13) {
        operator delete(v13);
      }
      sub_1CD481D8C(v21);
LABEL_4:
      if (++v6 == v7)
      {
        if (v28 != v27) {
          free(v28);
        }
        return;
      }
    }
  }
}

uint64_t llvm::AbstractDependenceGraphBuilder<llvm::DataDependenceGraph>::getOrdinal(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  return sub_1CD45F378(a1 + 56, &v3)[1];
}

{
  uint64_t v3;

  uint64_t v3 = a2;
  return sub_1CD45F378(a1 + 80, &v3)[1];
}

uint64_t llvm::DependenceGraphInfo<llvm::DDGNode>::DependenceGraphInfo(uint64_t a1, long long *a2, long long *a3)
{
  *(void *)a1 = &unk_1F2602598;
  uint64_t v5 = a1 + 8;
  if (*((char *)a2 + 23) < 0)
  {
    sub_1CB8BDF7C(v5, *(const void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v6 = *a2;
    *(void *)(v5 + 16) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v5 = v6;
  }
  long long v7 = *a3;
  long long v8 = a3[2];
  *(_OWORD *)(a1 + 48) = a3[1];
  *(_OWORD *)(a1 + 64) = v8;
  *(_OWORD *)(a1 + 32) = v7;
  *(void *)(a1 + 80) = 0;
  return a1;
}

{
  uint64_t v5;
  long long v6;
  long long v7;
  long long v8;

  *(void *)a1 = &unk_1F2602598;
  uint64_t v5 = a1 + 8;
  if (*((char *)a2 + 23) < 0)
  {
    sub_1CB8BDF7C(v5, *(const void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v6 = *a2;
    *(void *)(v5 + 16) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v5 = v6;
  }
  long long v7 = *a3;
  long long v8 = a3[2];
  *(_OWORD *)(a1 + 48) = a3[1];
  *(_OWORD *)(a1 + 64) = v8;
  *(_OWORD *)(a1 + 32) = v7;
  *(void *)(a1 + 80) = 0;
  return a1;
}

__n128 llvm::DependenceGraphInfo<llvm::DDGNode>::DependenceGraphInfo(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_1F2602598;
  long long v2 = *(_OWORD *)(a2 + 8);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(_OWORD *)(a1 + 8) = v2;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 8) = 0;
  __n128 result = *(__n128 *)(a2 + 32);
  long long v4 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 64) = v4;
  *(__n128 *)(a1 + 32) = result;
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  return result;
}

{
  long long v2;
  __n128 result;
  long long v4;

  *(void *)a1 = &unk_1F2602598;
  long long v2 = *(_OWORD *)(a2 + 8);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(_OWORD *)(a1 + 8) = v2;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 8) = 0;
  __n128 result = *(__n128 *)(a2 + 32);
  long long v4 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 64) = v4;
  *(__n128 *)(a1 + 32) = result;
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  return result;
}

uint64_t llvm::DependenceGraphInfo<llvm::DDGNode>::getName(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v1 = a1 + 8;
  uint64_t v2 = v3;
  if (*(char *)(v1 + 23) >= 0) {
    return v1;
  }
  return v2;
}

uint64_t llvm::DependenceGraphInfo<llvm::DDGNode>::getRoot(uint64_t a1)
{
  return *(void *)(a1 + 80);
}

void *sub_1CBFE1720(void *result, unsigned char *a2, unsigned char *a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >> 59) {
      abort();
    }
    long long v7 = result;
    __n128 result = operator new(32 * a4);
    long long v8 = result;
    *long long v7 = result;
    v7[1] = result;
    v7[2] = &result[4 * a4];
    if (a2 != a3)
    {
      size_t v9 = (a3 - a2) & 0xFFFFFFFFFFFFFFE0;
      __n128 result = memcpy(result, a2, v9);
      long long v8 = (void *)((char *)v8 + v9);
    }
    v7[1] = v8;
  }
  return result;
}

uint64_t *sub_1CBFE17C4(uint64_t *result, uint64_t *a2, void *a3)
{
  if (result != a2)
  {
    v21[11] = v3;
    v21[12] = v4;
    long long v6 = result;
    long long v7 = result + 1;
    if (result + 1 != a2)
    {
      uint64_t v9 = 0;
      uint64_t v10 = result;
      do
      {
        uint64_t v12 = *v10;
        uint64_t v11 = v10[1];
        uint64_t v10 = v7;
        uint64_t v13 = *a3 + 80;
        v21[0] = v11;
        unint64_t v14 = sub_1CD45F378(v13, v21)[1];
        v21[0] = v12;
        __n128 result = sub_1CD45F378(v13, v21);
        if (v14 < result[1])
        {
          uint64_t v15 = *v10;
          uint64_t v16 = v9;
          while (1)
          {
            *(uint64_t *)((char *)v6 + v16 + 8) = *(uint64_t *)((char *)v6 + v16);
            if (!v16) {
              break;
            }
            uint64_t v17 = *(uint64_t *)((char *)v6 + v16 - 8);
            uint64_t v18 = *a3 + 80;
            v21[0] = v15;
            unint64_t v19 = sub_1CD45F378(v18, v21)[1];
            v21[0] = v17;
            __n128 result = sub_1CD45F378(v18, v21);
            v16 -= 8;
            if (v19 >= result[1])
            {
              uint64_t v20 = (uint64_t *)((char *)v6 + v16 + 8);
              goto LABEL_10;
            }
          }
          uint64_t v20 = v6;
LABEL_10:
          *uint64_t v20 = v15;
        }
        long long v7 = v10 + 1;
        v9 += 8;
      }
      while (v10 + 1 != a2);
    }
  }
  return result;
}

uint64_t *sub_1CBFE18F0(uint64_t *result, uint64_t *a2, void *a3)
{
  if (result != a2)
  {
    v20[9] = v3;
    v20[10] = v4;
    long long v6 = result;
    for (unsigned int i = result + 1; v6 + 1 != a2; unsigned int i = v6 + 1)
    {
      uint64_t v10 = *v6;
      uint64_t v9 = v6[1];
      long long v6 = i;
      uint64_t v11 = *a3 + 80;
      v20[0] = v9;
      unint64_t v12 = sub_1CD45F378(v11, v20)[1];
      v20[0] = v10;
      __n128 result = sub_1CD45F378(v11, v20);
      if (v12 < result[1])
      {
        uint64_t v13 = *v6;
        unint64_t v14 = v6;
        do
        {
          uint64_t v15 = v14;
          uint64_t v16 = *--v14;
          uint64_t *v15 = v16;
          uint64_t v17 = *(v15 - 2);
          uint64_t v18 = *a3 + 80;
          v20[0] = v13;
          unint64_t v19 = sub_1CD45F378(v18, v20)[1];
          v20[0] = v17;
          __n128 result = sub_1CD45F378(v18, v20);
        }
        while (v19 < result[1]);
        *unint64_t v14 = v13;
      }
    }
  }
  return result;
}

void *sub_1CBFE19F0(uint64_t *a1, uint64_t *a2, uint64_t *a3, void *a4)
{
  uint64_t v8 = *a1;
  uint64_t v9 = *a4 + 80;
  uint64_t v26 = *a2;
  unint64_t v10 = sub_1CD45F378(v9, &v26)[1];
  uint64_t v26 = v8;
  uint64_t v11 = sub_1CD45F378(v9, &v26);
  uint64_t v12 = *a2;
  uint64_t v13 = *a4 + 80;
  if (v10 >= v11[1])
  {
    uint64_t v26 = *a3;
    unint64_t v17 = sub_1CD45F378(v13, &v26)[1];
    uint64_t v26 = v12;
    __n128 result = sub_1CD45F378(v13, &v26);
    if (v17 < result[1])
    {
      uint64_t v21 = *a2;
      *a2 = *a3;
      *a3 = v21;
      uint64_t v22 = *a1;
      uint64_t v23 = *a4 + 80;
      uint64_t v26 = *a2;
      unint64_t v24 = sub_1CD45F378(v23, &v26)[1];
      uint64_t v26 = v22;
      __n128 result = sub_1CD45F378(v23, &v26);
      if (v24 < result[1])
      {
        uint64_t v25 = *a1;
        *a1 = *a2;
        *a2 = v25;
      }
    }
  }
  else
  {
    uint64_t v26 = *a3;
    unint64_t v14 = sub_1CD45F378(v13, &v26)[1];
    uint64_t v26 = v12;
    __n128 result = sub_1CD45F378(v13, &v26);
    uint64_t v16 = *a1;
    if (v14 >= result[1])
    {
      *a1 = *a2;
      *a2 = v16;
      uint64_t v18 = *a4 + 80;
      uint64_t v26 = *a3;
      unint64_t v19 = sub_1CD45F378(v18, &v26)[1];
      uint64_t v26 = v16;
      __n128 result = sub_1CD45F378(v18, &v26);
      if (v19 < result[1])
      {
        uint64_t v20 = *a2;
        *a2 = *a3;
        *a3 = v20;
      }
    }
    else
    {
      *a1 = *a3;
      *a3 = v16;
    }
  }
  return result;
}

uint64_t *sub_1CBFE1BC0(uint64_t *a1, uint64_t *a2, void *a3)
{
  uint64_t v4 = a2;
  uint64_t v6 = *a1;
  uint64_t v7 = *(a2 - 1);
  uint64_t v8 = *a3 + 80;
  uint64_t v29 = *a1;
  unint64_t v9 = sub_1CD45F378(v8, &v29)[1];
  uint64_t v29 = v7;
  if (v9 >= sub_1CD45F378(v8, &v29)[1])
  {
    uint64_t v25 = a1 + 1;
    do
    {
      unint64_t v10 = v25;
      if (v25 >= v4) {
        break;
      }
      ++v25;
      uint64_t v26 = *v10;
      uint64_t v27 = *a3 + 80;
      uint64_t v29 = v6;
      unint64_t v28 = sub_1CD45F378(v27, &v29)[1];
      uint64_t v29 = v26;
    }
    while (v28 >= sub_1CD45F378(v27, &v29)[1]);
  }
  else
  {
    unint64_t v10 = a1;
    do
    {
      uint64_t v11 = v10[1];
      ++v10;
      uint64_t v12 = *a3 + 80;
      uint64_t v29 = v6;
      unint64_t v13 = sub_1CD45F378(v12, &v29)[1];
      uint64_t v29 = v11;
    }
    while (v13 >= sub_1CD45F378(v12, &v29)[1]);
  }
  if (v10 < v4)
  {
    do
    {
      uint64_t v14 = *--v4;
      uint64_t v15 = *a3 + 80;
      uint64_t v29 = v6;
      unint64_t v16 = sub_1CD45F378(v15, &v29)[1];
      uint64_t v29 = v14;
    }
    while (v16 < sub_1CD45F378(v15, &v29)[1]);
  }
  while (v10 < v4)
  {
    uint64_t v17 = *v10;
    *unint64_t v10 = *v4;
    *uint64_t v4 = v17;
    do
    {
      uint64_t v18 = v10[1];
      ++v10;
      uint64_t v19 = *a3 + 80;
      uint64_t v29 = v6;
      unint64_t v20 = sub_1CD45F378(v19, &v29)[1];
      uint64_t v29 = v18;
    }
    while (v20 >= sub_1CD45F378(v19, &v29)[1]);
    do
    {
      uint64_t v21 = *--v4;
      uint64_t v22 = *a3 + 80;
      uint64_t v29 = v6;
      unint64_t v23 = sub_1CD45F378(v22, &v29)[1];
      uint64_t v29 = v21;
    }
    while (v23 < sub_1CD45F378(v22, &v29)[1]);
  }
  if (v10 - 1 != a1) {
    *a1 = *(v10 - 1);
  }
  *(v10 - sub_1CD456CB4((void *)this + 1) = v6;
  return v10;
}

uint64_t *sub_1CBFE1DD8(uint64_t *a1, uint64_t *a2, void *a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = *a1;
  do
  {
    uint64_t v8 = *a3 + 80;
    uint64_t v28 = a1[v6 + 1];
    unint64_t v9 = sub_1CD45F378(v8, &v28)[1];
    uint64_t v28 = v7;
    ++v6;
  }
  while (v9 < sub_1CD45F378(v8, &v28)[1]);
  unint64_t v10 = &a1[v6];
  uint64_t v11 = &a1[v6 - 1];
  if (v6 == 1)
  {
    do
    {
      if (v10 >= a2) {
        break;
      }
      uint64_t v15 = *--a2;
      uint64_t v16 = *a3 + 80;
      uint64_t v28 = v15;
      unint64_t v17 = sub_1CD45F378(v16, &v28)[1];
      uint64_t v28 = v7;
    }
    while (v17 >= sub_1CD45F378(v16, &v28)[1]);
  }
  else
  {
    do
    {
      uint64_t v12 = *--a2;
      uint64_t v13 = *a3 + 80;
      uint64_t v28 = v12;
      unint64_t v14 = sub_1CD45F378(v13, &v28)[1];
      uint64_t v28 = v7;
    }
    while (v14 >= sub_1CD45F378(v13, &v28)[1]);
  }
  if (v10 < a2)
  {
    uint64_t v18 = v10;
    uint64_t v19 = a2;
    do
    {
      uint64_t v20 = *v18;
      *uint64_t v18 = *v19;
      *uint64_t v19 = v20;
      do
      {
        uint64_t v21 = v18[1];
        ++v18;
        uint64_t v22 = *a3 + 80;
        uint64_t v28 = v21;
        unint64_t v23 = sub_1CD45F378(v22, &v28)[1];
        uint64_t v28 = v7;
      }
      while (v23 < sub_1CD45F378(v22, &v28)[1]);
      do
      {
        uint64_t v24 = *--v19;
        uint64_t v25 = *a3 + 80;
        uint64_t v28 = v24;
        unint64_t v26 = sub_1CD45F378(v25, &v28)[1];
        uint64_t v28 = v7;
      }
      while (v26 >= sub_1CD45F378(v25, &v28)[1]);
    }
    while (v18 < v19);
    uint64_t v11 = v18 - 1;
  }
  if (v11 != a1) {
    *a1 = *v11;
  }
  *uint64_t v11 = v7;
  return v11;
}

BOOL sub_1CBFE1FCC(uint64_t *a1, uint64_t *a2, void *a3)
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v20 = *a1;
      uint64_t v21 = *a3 + 80;
      uint64_t v25 = *(a2 - 1);
      unint64_t v22 = sub_1CD45F378(v21, &v25)[1];
      uint64_t v25 = v20;
      if (v22 < sub_1CD45F378(v21, &v25)[1])
      {
        uint64_t v23 = *a1;
        *a1 = *(a2 - 1);
        *(a2 - sub_1CD456CB4((void *)this + 1) = v23;
      }
      return 1;
    case 3:
      sub_1CBFE19F0(a1, a1 + 1, a2 - 1, a3);
      return 1;
    case 4:
      sub_1CBFE2234(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      sub_1CBFE2380(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return 1;
    default:
      uint64_t v8 = a1 + 2;
      sub_1CBFE19F0(a1, a1 + 1, a1 + 2, a3);
      unint64_t v9 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      uint64_t v10 = 0;
      int v11 = 0;
      break;
  }
  while (1)
  {
    uint64_t v12 = *v8;
    uint64_t v13 = *a3 + 80;
    uint64_t v25 = *v9;
    unint64_t v14 = sub_1CD45F378(v13, &v25)[1];
    uint64_t v25 = v12;
    if (v14 < sub_1CD45F378(v13, &v25)[1])
    {
      uint64_t v24 = *v9;
      uint64_t v15 = v10;
      while (1)
      {
        *(uint64_t *)((char *)a1 + v15 + 24) = *(uint64_t *)((char *)a1 + v15 + 16);
        if (v15 == -16) {
          break;
        }
        uint64_t v16 = *(uint64_t *)((char *)a1 + v15 + 8);
        uint64_t v17 = *a3 + 80;
        uint64_t v25 = v24;
        unint64_t v18 = sub_1CD45F378(v17, &v25)[1];
        uint64_t v25 = v16;
        v15 -= 8;
        if (v18 >= sub_1CD45F378(v17, &v25)[1])
        {
          uint64_t v19 = (uint64_t *)((char *)a1 + v15 + 24);
          goto LABEL_11;
        }
      }
      uint64_t v19 = a1;
LABEL_11:
      *uint64_t v19 = v24;
      if (++v11 == 8) {
        return v9 + 1 == a2;
      }
    }
    uint64_t v8 = v9;
    v10 += 8;
    BOOL result = 1;
    if (++v9 == a2) {
      return result;
    }
  }
}

void *sub_1CBFE2234(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, void *a5)
{
  sub_1CBFE19F0(a1, a2, a3, a5);
  uint64_t v10 = *a3;
  uint64_t v11 = *a5 + 80;
  uint64_t v23 = *a4;
  unint64_t v12 = sub_1CD45F378(v11, &v23)[1];
  uint64_t v23 = v10;
  BOOL result = sub_1CD45F378(v11, &v23);
  if (v12 < result[1])
  {
    uint64_t v14 = *a3;
    *a3 = *a4;
    *a4 = v14;
    uint64_t v15 = *a2;
    uint64_t v16 = *a5 + 80;
    uint64_t v23 = *a3;
    unint64_t v17 = sub_1CD45F378(v16, &v23)[1];
    uint64_t v23 = v15;
    BOOL result = sub_1CD45F378(v16, &v23);
    if (v17 < result[1])
    {
      uint64_t v18 = *a2;
      *a2 = *a3;
      *a3 = v18;
      uint64_t v19 = *a1;
      uint64_t v20 = *a5 + 80;
      uint64_t v23 = *a2;
      unint64_t v21 = sub_1CD45F378(v20, &v23)[1];
      uint64_t v23 = v19;
      BOOL result = sub_1CD45F378(v20, &v23);
      if (v21 < result[1])
      {
        uint64_t v22 = *a1;
        *a1 = *a2;
        *a2 = v22;
      }
    }
  }
  return result;
}

void *sub_1CBFE2380(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, void *a6)
{
  sub_1CBFE2234(a1, a2, a3, a4, a6);
  uint64_t v12 = *a4;
  uint64_t v13 = *a6 + 80;
  uint64_t v29 = *a5;
  unint64_t v14 = sub_1CD45F378(v13, &v29)[1];
  uint64_t v29 = v12;
  BOOL result = sub_1CD45F378(v13, &v29);
  if (v14 < result[1])
  {
    uint64_t v16 = *a4;
    *a4 = *a5;
    *a5 = v16;
    uint64_t v17 = *a3;
    uint64_t v18 = *a6 + 80;
    uint64_t v29 = *a4;
    unint64_t v19 = sub_1CD45F378(v18, &v29)[1];
    uint64_t v29 = v17;
    BOOL result = sub_1CD45F378(v18, &v29);
    if (v19 < result[1])
    {
      uint64_t v20 = *a3;
      *a3 = *a4;
      *a4 = v20;
      uint64_t v21 = *a2;
      uint64_t v22 = *a6 + 80;
      uint64_t v29 = *a3;
      unint64_t v23 = sub_1CD45F378(v22, &v29)[1];
      uint64_t v29 = v21;
      BOOL result = sub_1CD45F378(v22, &v29);
      if (v23 < result[1])
      {
        uint64_t v24 = *a2;
        *a2 = *a3;
        *a3 = v24;
        uint64_t v25 = *a1;
        uint64_t v26 = *a6 + 80;
        uint64_t v29 = *a2;
        unint64_t v27 = sub_1CD45F378(v26, &v29)[1];
        uint64_t v29 = v25;
        BOOL result = sub_1CD45F378(v26, &v29);
        if (v27 < result[1])
        {
          uint64_t v28 = *a1;
          *a1 = *a2;
          *a2 = v28;
        }
      }
    }
  }
  return result;
}

uint64_t *sub_1CBFE2528(uint64_t *result, uint64_t *a2, uint64_t *a3, void *a4)
{
  if (result != a2)
  {
    uint64_t v5 = a2;
    uint64_t v6 = result;
    uint64_t v7 = (char *)a2 - (char *)result;
    uint64_t v8 = a2 - result;
    if ((char *)a2 - (char *)result >= 9)
    {
      unint64_t v9 = (unint64_t)(v8 - 2) >> 1;
      unint64_t v10 = v9 + 1;
      uint64_t v11 = &result[v9];
      do
      {
        BOOL result = sub_1CBFE2820(v6, a4, v8, v11--);
        --v10;
      }
      while (v10);
    }
    uint64_t v38 = v6;
    if (v5 != a3)
    {
      uint64_t v12 = v5;
      do
      {
        uint64_t v13 = *v38;
        uint64_t v14 = *a4 + 80;
        uint64_t v42 = *v12;
        unint64_t v15 = sub_1CD45F378(v14, &v42)[1];
        uint64_t v42 = v13;
        uint64_t v6 = v38;
        BOOL result = sub_1CD45F378(v14, &v42);
        if (v15 < result[1])
        {
          uint64_t v16 = *v12;
          *uint64_t v12 = *v38;
          *uint64_t v38 = v16;
          BOOL result = sub_1CBFE2820(v38, a4, v8, v38);
        }
        ++v12;
      }
      while (v12 != a3);
    }
    if (v7 >= 9)
    {
      do
      {
        uint64_t v17 = 0;
        uint64_t v39 = v5;
        uint64_t v40 = *v6;
        uint64_t v18 = v8 - 2;
        if (v8 < 2) {
          uint64_t v18 = v8 - 1;
        }
        uint64_t v19 = v18 >> 1;
        uint64_t v20 = v6;
        do
        {
          uint64_t v21 = &v20[v17 + 1];
          uint64_t v22 = (2 * v17) | 1;
          uint64_t v23 = 2 * v17 + 2;
          if (v23 < v8)
          {
            uint64_t v24 = v20[v17 + 2];
            uint64_t v25 = *a4 + 80;
            uint64_t v42 = *v21;
            unint64_t v26 = sub_1CD45F378(v25, &v42)[1];
            uint64_t v42 = v24;
            BOOL result = sub_1CD45F378(v25, &v42);
            if (v26 < result[1])
            {
              ++v21;
              uint64_t v22 = v23;
            }
          }
          *uint64_t v20 = *v21;
          uint64_t v20 = v21;
          uint64_t v17 = v22;
        }
        while (v22 <= v19);
        uint64_t v5 = v39 - 1;
        if (v21 == v39 - 1)
        {
          *uint64_t v21 = v40;
        }
        else
        {
          *uint64_t v21 = *v5;
          *uint64_t v5 = v40;
          uint64_t v6 = v38;
          uint64_t v27 = (char *)v21 - (char *)v38 + 8;
          if (v27 < 9) {
            continue;
          }
          unint64_t v28 = (((unint64_t)v27 >> 3) - 2) >> 1;
          uint64_t v29 = &v38[v28];
          uint64_t v30 = *v21;
          uint64_t v31 = *a4 + 80;
          uint64_t v42 = *v29;
          unint64_t v32 = sub_1CD45F378(v31, &v42)[1];
          uint64_t v42 = v30;
          BOOL result = sub_1CD45F378(v31, &v42);
          if (v32 >= result[1]) {
            continue;
          }
          uint64_t v33 = *v21;
          do
          {
            long long v34 = v29;
            *uint64_t v21 = *v29;
            if (!v28) {
              break;
            }
            unint64_t v28 = (v28 - 1) >> 1;
            uint64_t v29 = &v38[v28];
            uint64_t v35 = *a4 + 80;
            uint64_t v42 = *v29;
            unint64_t v36 = sub_1CD45F378(v35, &v42)[1];
            uint64_t v42 = v33;
            BOOL result = sub_1CD45F378(v35, &v42);
            uint64_t v21 = v34;
          }
          while (v36 < result[1]);
          *long long v34 = v33;
          uint64_t v5 = v39 - 1;
        }
        uint64_t v6 = v38;
      }
      while (v8-- > 2);
    }
  }
  return result;
}

void *sub_1CBFE2820(void *result, void *a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v6 = a3 - 2;
  if (a3 >= 2)
  {
    v31[11] = v4;
    v31[12] = v5;
    uint64_t v7 = a4;
    uint64_t v8 = result;
    int64_t v9 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) >= a4 - result)
    {
      uint64_t v12 = ((char *)a4 - (char *)result) >> 2;
      uint64_t v13 = v12 + 1;
      uint64_t v14 = &result[v12 + 1];
      uint64_t v15 = v12 + 2;
      if (v12 + 2 < a3)
      {
        uint64_t v29 = v14[1];
        v31[0] = *v14;
        uint64_t v16 = *a2 + 80;
        unint64_t v27 = sub_1CD45F378(v16, v31)[1];
        v31[0] = v29;
        if (v27 < sub_1CD45F378(v16, v31)[1])
        {
          ++v14;
          uint64_t v13 = v15;
        }
      }
      uint64_t v17 = *v7;
      uint64_t v18 = *a2 + 80;
      v31[0] = *v14;
      unint64_t v19 = sub_1CD45F378(v18, v31)[1];
      v31[0] = v17;
      BOOL result = sub_1CD45F378(v18, v31);
      if (v19 >= result[1])
      {
        uint64_t v30 = *v7;
        do
        {
          uint64_t v20 = v14;
          *uint64_t v7 = *v14;
          if (v9 < v13) {
            break;
          }
          uint64_t v21 = (2 * v13) | 1;
          uint64_t v14 = &v8[v21];
          uint64_t v22 = 2 * v13 + 2;
          if (v22 < a3)
          {
            uint64_t v28 = v14[1];
            uint64_t v23 = *a2 + 80;
            v31[0] = *v14;
            unint64_t v26 = sub_1CD45F378(v23, v31)[1];
            v31[0] = v28;
            if (v26 < sub_1CD45F378(v23, v31)[1])
            {
              ++v14;
              uint64_t v21 = v22;
            }
          }
          uint64_t v24 = *a2 + 80;
          v31[0] = *v14;
          unint64_t v25 = sub_1CD45F378(v24, v31)[1];
          v31[0] = v30;
          BOOL result = sub_1CD45F378(v24, v31);
          uint64_t v7 = v20;
          uint64_t v13 = v21;
        }
        while (v25 >= result[1]);
        *uint64_t v20 = v30;
      }
    }
  }
  return result;
}

uint64_t llvm::DivergenceAnalysisImpl::DivergenceAnalysisImpl(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7)
{
  *(void *)BOOL result = a2;
  *(void *)(result + 8) = a3;
  *(void *)(result + 16) = a4;
  *(void *)(result + 24) = a5;
  *(void *)(result + 32) = 0;
  *(void *)(result + 40) = 0;
  *(_DWORD *)(result + 48) = 0;
  *(void *)(result + 56) = a6;
  *(unsigned char *)(result + 64) = a7;
  *(void *)(result + 72) = 0;
  *(void *)(result + 80) = 0;
  *(_DWORD *)(result + 88) = 0;
  *(void *)(result + 96) = 0;
  *(void *)(result + 104) = 0;
  *(_DWORD *)(result + 112) = 0;
  *(void *)(result + 128) = 0;
  *(void *)(result + 136) = 0;
  *(void *)(result + 120) = 0;
  return result;
}

{
  *(void *)BOOL result = a2;
  *(void *)(result + 8) = a3;
  *(void *)(result + 16) = a4;
  *(void *)(result + 24) = a5;
  *(void *)(result + 32) = 0;
  *(void *)(result + 40) = 0;
  *(_DWORD *)(result + 48) = 0;
  *(void *)(result + 56) = a6;
  *(unsigned char *)(result + 64) = a7;
  *(void *)(result + 72) = 0;
  *(void *)(result + 80) = 0;
  *(_DWORD *)(result + 88) = 0;
  *(void *)(result + 96) = 0;
  *(void *)(result + 104) = 0;
  *(_DWORD *)(result + 112) = 0;
  *(void *)(result + 128) = 0;
  *(void *)(result + 136) = 0;
  *(void *)(result + 120) = 0;
  return result;
}

BOOL llvm::DivergenceAnalysisImpl::isAlwaysUniform(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 72);
  uint64_t v3 = *(unsigned int *)(a1 + 88);
  if (!v3)
  {
LABEL_7:
    uint64_t v5 = (uint64_t *)(v2 + 8 * v3);
    return v5 != (uint64_t *)(v2 + 8 * v3);
  }
  LODWORD(v4) = (v3 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v5 = (uint64_t *)(v2 + 8 * v4);
  uint64_t v6 = *v5;
  if (*v5 != a2)
  {
    int v7 = 1;
    while (v6 != -4096)
    {
      int v8 = v4 + v7++;
      uint64_t v4 = v8 & (v3 - 1);
      uint64_t v6 = *(void *)(v2 + 8 * v4);
      if (v6 == a2)
      {
        uint64_t v5 = (uint64_t *)(v2 + 8 * v4);
        return v5 != (uint64_t *)(v2 + 8 * v3);
      }
    }
    goto LABEL_7;
  }
  return v5 != (uint64_t *)(v2 + 8 * v3);
}

uint64_t llvm::DivergenceAnalysisImpl::addUniformOverride(llvm::DivergenceAnalysisImpl *this, const llvm::Value *a2)
{
  uint64_t v3 = a2;
  return sub_1CD48410C((uint64_t)this + 72, (uint64_t *)&v3, (uint64_t)v4);
}

uint64_t llvm::DivergenceAnalysisImpl::isTemporalDivergent(llvm::DivergenceAnalysisImpl *this, const llvm::BasicBlock *a2, const llvm::Value *a3)
{
  if (*((unsigned __int8 *)a3 + 16) < 0x1Cu) {
    return 0;
  }
  uint64_t v5 = (uint64_t *)*((void *)this + 3);
  int v6 = *((_DWORD *)v5 + 4);
  if (v6)
  {
    uint64_t v7 = *((void *)a3 + 5);
    uint64_t v8 = *v5;
    unsigned int v9 = v6 - 1;
    uint64_t v10 = ((v7 >> 4) ^ (v7 >> 9)) & (v6 - 1);
    uint64_t v11 = *(void *)(v8 + 16 * v10);
    if (v7 == v11)
    {
LABEL_7:
      uint64_t v14 = *(uint64_t **)(v8 + 16 * v10 + 8);
      goto LABEL_9;
    }
    int v12 = 1;
    while (v11 != -4096)
    {
      int v13 = v10 + v12++;
      uint64_t v10 = v13 & v9;
      uint64_t v11 = *(void *)(v8 + 16 * v10);
      if (v7 == v11) {
        goto LABEL_7;
      }
    }
  }
  uint64_t v14 = 0;
LABEL_9:
  if (v14 != *((uint64_t **)this + 1))
  {
    unsigned int v15 = (a2 >> 4) ^ (a2 >> 9);
    while (1)
    {
      uint64_t v17 = v14[7];
      uint64_t v16 = v14[8];
      if (v16 == v17)
      {
        uint64_t v18 = *((unsigned int *)v14 + 19);
        unint64_t v19 = (const llvm::BasicBlock **)(v16 + 8 * v18);
        if (v18)
        {
          uint64_t v20 = 0;
          uint64_t v21 = 8 * v18;
          while (*(const llvm::BasicBlock **)(v16 + v20) != a2)
          {
            v20 += 8;
            if (v21 == v20) {
              goto LABEL_29;
            }
          }
          unint64_t v19 = (const llvm::BasicBlock **)(v16 + v20);
        }
LABEL_29:
        uint64_t v17 = v14[8];
      }
      else
      {
        uint64_t v22 = *((unsigned int *)v14 + 18);
        int v23 = v22 - 1;
        unsigned int v24 = (v22 - 1) & v15;
        unint64_t v19 = (const llvm::BasicBlock **)(v16 + 8 * v24);
        unint64_t v25 = *v19;
        if (*v19 == (const llvm::BasicBlock *)-1)
        {
          unint64_t v26 = 0;
LABEL_41:
          if (v26) {
            unint64_t v19 = v26;
          }
          if (*v19 != a2) {
            unint64_t v19 = (const llvm::BasicBlock **)(v16 + 8 * v22);
          }
        }
        else
        {
          unint64_t v26 = 0;
          int v27 = 1;
          while (v25 != a2)
          {
            if (v26) {
              BOOL v28 = 0;
            }
            else {
              BOOL v28 = v25 == (const llvm::BasicBlock *)-2;
            }
            if (v28) {
              unint64_t v26 = v19;
            }
            unsigned int v29 = v24 + v27++;
            unsigned int v24 = v29 & v23;
            unint64_t v19 = (const llvm::BasicBlock **)(v16 + 8 * (v29 & v23));
            unint64_t v25 = *v19;
            if (*v19 == (const llvm::BasicBlock *)-1) {
              goto LABEL_41;
            }
          }
        }
      }
      uint64_t v30 = v16 == v17 ? 76 : 72;
      if (v19 != (const llvm::BasicBlock **)(v16 + 8 * *(unsigned int *)((char *)v14 + v30))) {
        break;
      }
      uint64_t v35 = 0;
      unint64_t v36 = v14;
      if (sub_1CD420258((uint64_t *)this + 4, &v36, &v35))
      {
        uint64_t v31 = v35;
        uint64_t v32 = *((void *)this + 4);
        uint64_t v33 = *((unsigned int *)this + 12);
      }
      else
      {
        uint64_t v32 = *((void *)this + 4);
        uint64_t v33 = *((unsigned int *)this + 12);
        uint64_t v31 = v32 + 8 * v33;
      }
      if (v31 != v32 + 8 * v33) {
        return 1;
      }
      uint64_t result = 0;
      uint64_t v14 = (uint64_t *)*v14;
      if (v14 == *((uint64_t **)this + 1)) {
        return result;
      }
    }
  }
  return 0;
}

BOOL llvm::DivergenceAnalysisImpl::inRegion(void *a1, uint64_t a2)
{
  uint64_t v2 = a1[1];
  if (!v2) {
    return *(void *)(a2 + 56) == *a1;
  }
  uint64_t v4 = *(void *)(v2 + 56);
  uint64_t v3 = *(void *)(v2 + 64);
  if (v3 == v4)
  {
    uint64_t v5 = *(unsigned int *)(v2 + 76);
    int v6 = (void *)(v3 + 8 * v5);
    if (v5)
    {
      uint64_t v7 = 0;
      uint64_t v8 = 8 * v5;
      while (*(void *)(v3 + v7) != a2)
      {
        v7 += 8;
        if (v8 == v7) {
          goto LABEL_21;
        }
      }
      int v6 = (void *)(v3 + v7);
    }
LABEL_21:
    uint64_t v4 = *(void *)(v2 + 64);
  }
  else
  {
    uint64_t v10 = *(unsigned int *)(v2 + 72);
    int v11 = v10 - 1;
    unsigned int v12 = (v10 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    int v6 = (void *)(v3 + 8 * v12);
    uint64_t v13 = *v6;
    if (*v6 == -1)
    {
      uint64_t v14 = 0;
LABEL_26:
      if (v14) {
        int v6 = v14;
      }
      if (*v6 != a2) {
        int v6 = (void *)(v3 + 8 * v10);
      }
    }
    else
    {
      uint64_t v14 = 0;
      int v15 = 1;
      while (v13 != a2)
      {
        if (v14) {
          BOOL v16 = 0;
        }
        else {
          BOOL v16 = v13 == -2;
        }
        if (v16) {
          uint64_t v14 = v6;
        }
        unsigned int v17 = v12 + v15++;
        unsigned int v12 = v17 & v11;
        int v6 = (void *)(v3 + 8 * (v17 & v11));
        uint64_t v13 = *v6;
        if (*v6 == -1) {
          goto LABEL_26;
        }
      }
    }
  }
  BOOL v16 = v3 == v4;
  uint64_t v18 = 72;
  if (v16) {
    uint64_t v18 = 76;
  }
  return v6 != (void *)(v3 + 8 * *(unsigned int *)(v2 + v18));
}

void llvm::DivergenceAnalysisImpl::pushUsers(llvm::DivergenceAnalysisImpl *this, const llvm::Value *a2)
{
  unsigned int v3 = *((unsigned __int8 *)a2 + 16);
  if (v3 >= 0x1C && v3 - 29 <= 0xA)
  {
    llvm::DivergenceAnalysisImpl::analyzeControlDivergence(this, a2);
  }
  for (uint64_t i = *((void *)a2 + 1); i; uint64_t i = *(void *)(i + 8))
  {
    int v6 = *(unsigned __int8 **)(i + 24);
    if (v6) {
      BOOL v7 = v6[16] >= 0x1Cu;
    }
    else {
      BOOL v7 = 0;
    }
    if (v7
      && llvm::DivergenceAnalysisImpl::inRegion(this, *(const llvm::Instruction **)(i + 24))
      && llvm::DivergenceAnalysisImpl::markDivergent(this, (const llvm::Value *)v6))
    {
      unsigned int v9 = (unsigned __int8 **)*((void *)this + 16);
      unint64_t v8 = *((void *)this + 17);
      if ((unint64_t)v9 >= v8)
      {
        int v11 = (void *)*((void *)this + 15);
        uint64_t v12 = v9 - (unsigned __int8 **)v11;
        unint64_t v13 = v12 + 1;
        if ((unint64_t)(v12 + 1) >> 61) {
          abort();
        }
        uint64_t v14 = v8 - (void)v11;
        if (v14 >> 2 > v13) {
          unint64_t v13 = v14 >> 2;
        }
        if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v15 = v13;
        }
        if (v15)
        {
          if (v15 >> 61) {
            sub_1CB833614();
          }
          BOOL v16 = (char *)operator new(8 * v15);
        }
        else
        {
          BOOL v16 = 0;
        }
        unsigned int v17 = (unsigned __int8 **)&v16[8 * v12];
        char *v17 = v6;
        uint64_t v10 = v17 + 1;
        if (v9 != v11)
        {
          do
          {
            uint64_t v18 = *--v9;
            *--unsigned int v17 = v18;
          }
          while (v9 != v11);
          unsigned int v9 = (unsigned __int8 **)*((void *)this + 15);
        }
        *((void *)this + 15) = v17;
        *((void *)this + 16) = v10;
        *((void *)this + 17) = &v16[8 * v15];
        if (v9) {
          operator delete(v9);
        }
      }
      else
      {
        *unsigned int v9 = v6;
        uint64_t v10 = v9 + 1;
      }
      *((void *)this + 16) = v10;
    }
  }
}

void llvm::DivergenceAnalysisImpl::analyzeControlDivergence(llvm::DivergenceAnalysisImpl *this, const llvm::Instruction *a2)
{
}

uint64_t llvm::DivergenceAnalysisImpl::analyzeTemporalDivergence(uint64_t this, const llvm::Instruction *a2, const llvm::Loop *a3)
{
  uint64_t v4 = (llvm::DivergenceAnalysisImpl *)this;
  uint64_t v5 = *(void *)(this + 72);
  uint64_t v6 = *(unsigned int *)(this + 88);
  unsigned int v7 = a2 >> 4;
  if (v6)
  {
    LODWORD(v8) = (v6 - 1) & (v7 ^ (a2 >> 9));
    unsigned int v9 = (const llvm::Instruction **)(v5 + 8 * v8);
    uint64_t v10 = *v9;
    if (*v9 == a2) {
      goto LABEL_8;
    }
    int v11 = 1;
    while (v10 != (const llvm::Instruction *)-4096)
    {
      int v12 = v8 + v11++;
      uint64_t v8 = v12 & (v6 - 1);
      uint64_t v10 = *(const llvm::Instruction **)(v5 + 8 * v8);
      if (v10 == a2)
      {
        unsigned int v9 = (const llvm::Instruction **)(v5 + 8 * v8);
        goto LABEL_8;
      }
    }
  }
  unsigned int v9 = (const llvm::Instruction **)(v5 + 8 * v6);
LABEL_8:
  if (v9 != (const llvm::Instruction **)(v5 + 8 * v6)) {
    return this;
  }
  uint64_t v13 = *(void *)(this + 96);
  uint64_t v14 = *(unsigned int *)(this + 112);
  if (v14)
  {
    LODWORD(v15) = (v14 - 1) & (v7 ^ (a2 >> 9));
    BOOL v16 = (const llvm::Instruction **)(v13 + 8 * v15);
    unsigned int v17 = *v16;
    if (*v16 == a2) {
      goto LABEL_16;
    }
    int v18 = 1;
    while (v17 != (const llvm::Instruction *)-4096)
    {
      int v19 = v15 + v18++;
      uint64_t v15 = v19 & (v14 - 1);
      unsigned int v17 = *(const llvm::Instruction **)(v13 + 8 * v15);
      if (v17 == a2)
      {
        BOOL v16 = (const llvm::Instruction **)(v13 + 8 * v15);
        goto LABEL_16;
      }
    }
  }
  BOOL v16 = (const llvm::Instruction **)(v13 + 8 * v14);
LABEL_16:
  if (v16 != (const llvm::Instruction **)(v13 + 8 * v14)) {
    return this;
  }
  int v20 = *((_DWORD *)a2 + 5);
  if ((v20 & 0x40000000) != 0)
  {
    uint64_t v22 = (char *)*((void *)a2 - 1);
    uint64_t v21 = v20 & 0x7FFFFFF;
    if (!v21) {
      return this;
    }
  }
  else
  {
    uint64_t v21 = v20 & 0x7FFFFFF;
    uint64_t v22 = (char *)a2 - 32 * v21;
    if (!v21) {
      return this;
    }
  }
  int v23 = &v22[32 * v21];
  uint64_t v25 = *((void *)a3 + 7);
  uint64_t v24 = *((void *)a3 + 8);
  uint64_t v26 = *((unsigned int *)a3 + 18);
  uint64_t v27 = *((unsigned int *)a3 + 19);
  int v28 = v26 - 1;
  this = -2;
  while (1)
  {
    if (*(void *)v22 && *(unsigned __int8 *)(*(void *)v22 + 16) >= 0x1Cu)
    {
      uint64_t v30 = *(void *)(*(void *)v22 + 40);
      if (v24 == v25)
      {
        if (v27)
        {
          uint64_t v31 = 0;
          while (*(void *)(v24 + v31) != v30)
          {
            v31 += 8;
            if (8 * v27 == v31)
            {
              unsigned int v32 = v27;
              goto LABEL_47;
            }
          }
          uint64_t v41 = (void *)(v24 + v31);
          unsigned int v32 = v27;
          uint64_t v42 = v24;
        }
        else
        {
          unsigned int v32 = 0;
LABEL_47:
          uint64_t v42 = v24;
          uint64_t v41 = (void *)(v24 + 8 * v27);
        }
      }
      else
      {
        unsigned int v33 = v28 & ((v30 >> 4) ^ (v30 >> 9));
        long long v34 = (void *)(v24 + 8 * v33);
        uint64_t v35 = *v34;
        if (*v34 == -1)
        {
          unint64_t v36 = 0;
LABEL_49:
          if (v36) {
            long long v34 = v36;
          }
          uint64_t v40 = *v34;
        }
        else
        {
          unint64_t v36 = 0;
          int v37 = 1;
          while (v35 != v30)
          {
            if (v36) {
              BOOL v38 = 0;
            }
            else {
              BOOL v38 = v35 == -2;
            }
            if (v38) {
              unint64_t v36 = v34;
            }
            unsigned int v39 = v33 + v37++;
            unsigned int v33 = v39 & v28;
            long long v34 = (void *)(v24 + 8 * (v39 & v28));
            uint64_t v35 = *v34;
            if (*v34 == -1) {
              goto LABEL_49;
            }
          }
          uint64_t v40 = *(void *)(*(void *)v22 + 40);
        }
        uint64_t v41 = v40 == v30 ? v34 : (void *)(v24 + 8 * v26);
        unsigned int v32 = v27;
        uint64_t v42 = v25;
      }
      if (v24 != v42) {
        unsigned int v32 = v26;
      }
      if (v41 != (void *)(v24 + 8 * v32)) {
        break;
      }
    }
    v22 += 32;
    if (v22 == v23) {
      return this;
    }
  }
  this = llvm::DivergenceAnalysisImpl::markDivergent(v4, a2);
  if (this)
  {
    return llvm::DivergenceAnalysisImpl::pushUsers(v4, a2);
  }
  return this;
}

uint64_t llvm::DivergenceAnalysisImpl::isDivergentUse(llvm::DivergenceAnalysisImpl *this, const llvm::Value **a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = *((void *)this + 12);
  uint64_t v4 = *((unsigned int *)this + 28);
  if (v4)
  {
    LODWORD(v5) = ((v2 >> 4) ^ (v2 >> 9)) & (v4 - 1);
    uint64_t v6 = (const llvm::Value **)(v3 + 8 * v5);
    unsigned int v7 = *v6;
    if (v2 == *v6) {
      goto LABEL_8;
    }
    int v8 = 1;
    while (v7 != (const llvm::Value *)-4096)
    {
      int v9 = v5 + v8++;
      uint64_t v5 = v9 & (v4 - 1);
      unsigned int v7 = *(const llvm::Value **)(v3 + 8 * v5);
      if (v2 == v7)
      {
        uint64_t v6 = (const llvm::Value **)(v3 + 8 * v5);
        goto LABEL_8;
      }
    }
  }
  uint64_t v6 = (const llvm::Value **)(v3 + 8 * v4);
LABEL_8:
  if (v6 == (const llvm::Value **)(v3 + 8 * v4)) {
    return llvm::DivergenceAnalysisImpl::isTemporalDivergent(this, *((const llvm::BasicBlock **)a2[3] + 5), v2);
  }
  else {
    return 1;
  }
}

uint64_t sub_1CBFE347C(void *a1, uint64_t *a2)
{
  unsigned int v55 = v59;
  int v56 = v59;
  uint64_t v57 = 32;
  int v58 = 0;
  uint64_t v8 = *a1;
  uint64_t v7 = a1[1];
  if (v7 == *a1) {
    return 0;
  }
  uint64_t v10 = 32;
  while (1)
  {
    uint64_t v12 = *(void *)(v7 - 8);
    v7 -= 8;
    uint64_t v11 = v12;
    uint64_t v13 = v56;
    uint64_t v14 = HIDWORD(v57);
    if (v56 != v55) {
      goto LABEL_61;
    }
    if (!HIDWORD(v57))
    {
LABEL_11:
      if (HIDWORD(v57) < v10)
      {
        unint64_t v15 = ++HIDWORD(v57);
        *(void *)&v56[8 * v14] = v11;
        goto LABEL_13;
      }
LABEL_61:
      if (3 * (int)v10 <= (4 * (HIDWORD(v57) - v58)))
      {
        if (v10 >= 0x40) {
          LODWORD(v10) = 2 * v10;
        }
        else {
          LODWORD(v10) = 128;
        }
      }
      else if ((int)v10 - HIDWORD(v57) >= v10 >> 3)
      {
        goto LABEL_63;
      }
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v55, v10);
      uint64_t v10 = v57;
      uint64_t v13 = v56;
LABEL_63:
      unint64_t v15 = (v10 - 1);
      unint64_t v3 = v15 & ((v11 >> 4) ^ (v11 >> 9));
      unsigned int v33 = &v13[8 * v3];
      uint64_t v4 = *v33;
      if (*v33 == -1)
      {
        uint64_t v2 = 0;
LABEL_75:
        if (v2) {
          unint64_t v36 = (void *)v2;
        }
        else {
          unint64_t v36 = v33;
        }
        if (*v36 != v11)
        {
          if (*v36 == -2) {
            --v58;
          }
          else {
            ++HIDWORD(v57);
          }
          *unint64_t v36 = v11;
        }
      }
      else
      {
        uint64_t v2 = 0;
        uint64_t v5 = 1;
        while (v4 != v11)
        {
          if (v2) {
            BOOL v34 = 0;
          }
          else {
            BOOL v34 = v4 == -2;
          }
          if (v34) {
            uint64_t v2 = (uint64_t)v33;
          }
          int v35 = v3 + v5;
          uint64_t v5 = (v5 + 1);
          unint64_t v3 = v35 & v15;
          unsigned int v33 = &v13[8 * v3];
          uint64_t v4 = *v33;
          if (*v33 == -1) {
            goto LABEL_75;
          }
        }
      }
      goto LABEL_13;
    }
    unint64_t v15 = 0;
    uint64_t v2 = 8 * HIDWORD(v57);
    unint64_t v3 = (unint64_t)v56;
    while (1)
    {
      uint64_t v4 = *(void *)v3;
      if (*(void *)v3 == v11) {
        break;
      }
      if (v4 == -2) {
        unint64_t v15 = v3;
      }
      v3 += 8;
      v2 -= 8;
      if (!v2)
      {
        if (!v15) {
          goto LABEL_11;
        }
        *(void *)unint64_t v15 = v11;
        --v58;
        break;
      }
    }
LABEL_13:
    uint64_t v16 = *(void *)(v11 + 40);
    if (v16 == v11 + 40) {
      goto LABEL_96;
    }
    uint64_t v17 = v16 ? v16 - 24 : 0;
    int v18 = *(unsigned __int8 *)(v17 + 16);
    if (v18 == 30) {
      break;
    }
    uint64_t v49 = 2;
    switch(*(unsigned char *)(v17 + 16))
    {
      case 0x1E:
LABEL_108:
        __break(1u);
LABEL_109:
        int v51 = *(_DWORD *)(v17 + 20);
        if ((v51 & 0x40000000) != 0) {
          uint64_t v52 = *(void *)(v17 - 8);
        }
        else {
          uint64_t v52 = v17 - 32 * (v51 & 0x7FFFFFF);
        }
        unsigned int v45 = (uint64_t *)(v52 + 32 * (v15 + 1));
        goto LABEL_26;
      case 0x1F:
        LODWORD(v49) = (*(_DWORD *)(v17 + 20) >> 1) & 0x3FFFFFF;
        break;
      case 0x20:
      case 0x26:
        LODWORD(v49) = (*(_DWORD *)(v17 + 20) & 0x7FFFFFF) - 1;
        break;
      case 0x21:
        goto LABEL_22;
      case 0x24:
        LODWORD(v49) = *(_WORD *)(v17 + 18) & 1;
        break;
      case 0x25:
        LODWORD(v49) = 1;
        goto LABEL_22;
      case 0x27:
        LODWORD(v49) = *(_DWORD *)(v17 + 80) + 1;
        break;
      default:
        goto LABEL_96;
    }
    if (v49) {
      goto LABEL_22;
    }
LABEL_96:
    if (v7 == v8)
    {
      uint64_t v50 = 0;
      uint64_t v22 = v55;
      a1 = v56;
      goto LABEL_125;
    }
  }
  if ((*(_DWORD *)(v17 + 20) & 0x7FFFFFF) == 3) {
    LODWORD(v49) = 2;
  }
  else {
    LODWORD(v49) = 1;
  }
LABEL_22:
  unint64_t v15 = 0;
  uint64_t v2 = v17 - 32;
  unint64_t v3 = (unint64_t)v55;
  a1 = v56;
  uint64_t v10 = v57;
  LODWORD(v4) = HIDWORD(v57);
  uint64_t v5 = (uint64_t)&v56[8 * HIDWORD(v57)];
  uint64_t v6 = 8 * HIDWORD(v57);
  uint64_t v49 = v49;
  while (2)
  {
    if (v18 == 30)
    {
      unsigned int v45 = (uint64_t *)(v2 - 32 * v15);
    }
    else
    {
      unsigned int v45 = (uint64_t *)v2;
      switch(v18)
      {
        case ' ':
        case '&':
          goto LABEL_109;
        case '!':
          uint64_t v53 = -64;
          if (!v15) {
            uint64_t v53 = -96;
          }
          unsigned int v45 = (uint64_t *)(v17 + v53);
          break;
        case '""':
        case '#':
          goto LABEL_108;
        case '$':
          if ((*(_WORD *)(v17 + 18) & 1) == 0)
          {
            uint64_t v19 = 0;
            goto LABEL_27;
          }
          uint64_t v48 = v17 - 32 * (*(_DWORD *)(v17 + 20) & 0x7FFFFFF);
LABEL_94:
          unsigned int v45 = (uint64_t *)(v48 + 32);
          break;
        case '%':
          break;
        case '\'':
          if (v15) {
            unsigned int v45 = (uint64_t *)(v2 - 32 * *(unsigned int *)(v17 + 80) + 32 * v15 - 32);
          }
          else {
            unsigned int v45 = (uint64_t *)(v17 - 32 * *(unsigned int *)(v17 + 80) - 64);
          }
          break;
        default:
          int v46 = *(_DWORD *)(v17 + 20);
          if ((v46 & 0x40000000) != 0) {
            uint64_t v47 = *(void *)(v17 - 8);
          }
          else {
            uint64_t v47 = v17 - 32 * (v46 & 0x7FFFFFF);
          }
          uint64_t v48 = v47 + 32 * (2 * v15);
          goto LABEL_94;
      }
    }
LABEL_26:
    uint64_t v19 = *v45;
LABEL_27:
    if (a1 == (void *)v3)
    {
      if (v4)
      {
        unint64_t v20 = 0;
        while (a1[v20 / 8] != v19)
        {
          v20 += 8;
          if (v6 == v20)
          {
            int v21 = v4;
            goto LABEL_33;
          }
        }
        int v23 = &a1[v20 / 8];
        int v21 = v4;
        uint64_t v22 = a1;
      }
      else
      {
        int v21 = 0;
LABEL_33:
        uint64_t v22 = a1;
        int v23 = (void *)v5;
      }
    }
    else
    {
      int v24 = v10 - 1;
      unsigned int v25 = (v10 - 1) & ((v19 >> 4) ^ (v19 >> 9));
      uint64_t v26 = &a1[v25];
      uint64_t v27 = *v26;
      if (*v26 == -1)
      {
        int v28 = 0;
LABEL_58:
        if (v28) {
          uint64_t v26 = v28;
        }
        uint64_t v32 = *v26;
      }
      else
      {
        int v28 = 0;
        int v29 = 1;
        while (v27 != v19)
        {
          if (v28) {
            BOOL v30 = 0;
          }
          else {
            BOOL v30 = v27 == -2;
          }
          if (v30) {
            int v28 = v26;
          }
          unsigned int v31 = v25 + v29++;
          unsigned int v25 = v31 & v24;
          uint64_t v26 = &a1[v31 & v24];
          uint64_t v27 = *v26;
          if (*v26 == -1) {
            goto LABEL_58;
          }
        }
        uint64_t v32 = v19;
      }
      if (v32 == v19) {
        int v23 = v26;
      }
      else {
        int v23 = &a1[v10];
      }
      int v21 = v4;
      uint64_t v22 = (void *)v3;
    }
    if (a1 != v22) {
      int v21 = v10;
    }
    if (v23 == &a1[v21])
    {
LABEL_37:
      if (++v15 == v49) {
        goto LABEL_96;
      }
      continue;
    }
    break;
  }
  int v37 = *((_DWORD *)a2 + 4);
  if (!v37) {
    goto LABEL_124;
  }
  uint64_t v38 = *a2;
  unsigned int v39 = v37 - 1;
  uint64_t v40 = (v37 - 1) & ((v11 >> 4) ^ (v11 >> 9));
  uint64_t v41 = *(void *)(*a2 + 16 * v40);
  if (v11 == v41)
  {
LABEL_87:
    uint64_t v44 = *(uint64_t ***)(v38 + 16 * v40 + 8);
    if (!v44) {
      goto LABEL_124;
    }
    while (*v44[4] != v19)
    {
      uint64_t v44 = (uint64_t **)*v44;
      if (!v44) {
        goto LABEL_124;
      }
    }
    goto LABEL_37;
  }
  int v42 = 1;
  while (v41 != -4096)
  {
    int v43 = v40 + v42++;
    uint64_t v40 = v43 & v39;
    uint64_t v41 = *(void *)(v38 + 16 * v40);
    if (v11 == v41) {
      goto LABEL_87;
    }
  }
LABEL_124:
  uint64_t v50 = 1;
LABEL_125:
  if (a1 != v22) {
    free(a1);
  }
  return v50;
}

void llvm::DivergenceAnalysisPrinterPass::run()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  llvm::AnalysisManager<llvm::Function>::getResultImpl();
}

uint64_t sub_1CBFE4194(uint64_t *a1, void *a2, void *a3)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    uint64_t v4 = *a1;
    int v5 = v3 - 1;
    unsigned int v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v3 - 1);
    uint64_t v7 = (void *)(*a1 + 8 * v6);
    uint64_t v8 = *v7;
    if (*a2 == *v7)
    {
      uint64_t result = 1;
    }
    else
    {
      int v9 = 0;
      int v10 = 1;
      uint64_t result = 1;
      while (v8 != -4096)
      {
        if (v9) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v8 == -8192;
        }
        if (v12) {
          int v9 = v7;
        }
        unsigned int v13 = v6 + v10++;
        unsigned int v6 = v13 & v5;
        uint64_t v7 = (void *)(v4 + 8 * (v13 & v5));
        uint64_t v8 = *v7;
        if (*a2 == *v7) {
          goto LABEL_13;
        }
      }
      uint64_t result = 0;
      if (v9) {
        uint64_t v7 = v9;
      }
    }
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t result = 0;
  }
LABEL_13:
  *a3 = v7;
  return result;
}

void *sub_1CBFE4230(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 < 3 * v7)
  {
    if (v7 + ~v6 - *(_DWORD *)(a1 + 12) <= v7 >> 3)
    {
      sub_1CBB24F14(a1, v7);
      uint64_t v17 = 0;
      sub_1CBFE4194((uint64_t *)a1, a3, &v17);
      a4 = v17;
    }
LABEL_4:
    uint64_t v8 = *a4;
    goto LABEL_5;
  }
  sub_1CBB24F14(a1, 2 * v7);
  uint64_t v8 = *a3;
  int v10 = *(_DWORD *)(a1 + 16) - 1;
  unsigned int v11 = ((*a3 >> 4) ^ (*a3 >> 9)) & v10;
  a4 = (void *)(*(void *)a1 + 8 * v11);
  uint64_t v12 = *a4;
  if (*a3 != *a4)
  {
    unsigned int v13 = 0;
    int v14 = 1;
    while (v12 != -4096)
    {
      if (v13) {
        BOOL v15 = 0;
      }
      else {
        BOOL v15 = v12 == -8192;
      }
      if (v15) {
        unsigned int v13 = a4;
      }
      unsigned int v16 = v11 + v14++;
      unsigned int v11 = v16 & v10;
      a4 = (void *)(*(void *)a1 + 8 * v11);
      uint64_t v12 = *a4;
      if (v8 == *a4) {
        goto LABEL_5;
      }
    }
    if (v13) {
      a4 = v13;
    }
    goto LABEL_4;
  }
LABEL_5:
  ++*(_DWORD *)(a1 + 8);
  if (v8 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

double llvm::DominatorTree::viewGraph(llvm *a1)
{
  uint64_t v1 = (llvm::raw_ostream *)llvm::errs(a1);
  uint64_t v2 = (void *)*((void *)v1 + 4);
  if (*((void *)v1 + 3) - (void)v2 > 0x2CuLL)
  {
    qmemcpy(v2, "DomTree dump not available, build with DEBUG\n", 45);
    double result = *(double *)"uild with DEBUG\n";
    *((void *)v1 + 4) += 45;
  }
  else
  {
    llvm::raw_ostream::write(v1, "DomTree dump not available, build with DEBUG\n", 0x2DuLL);
  }
  return result;
}

double llvm::DominatorTree::viewGraph(llvm::DominatorTree *this)
{
  uint64_t v1 = (llvm::raw_ostream *)llvm::errs(this);
  uint64_t v2 = (void *)*((void *)v1 + 4);
  if (*((void *)v1 + 3) - (void)v2 > 0x2CuLL)
  {
    qmemcpy(v2, "DomTree dump not available, build with DEBUG\n", 45);
    double result = *(double *)"uild with DEBUG\n";
    *((void *)v1 + 4) += 45;
  }
  else
  {
    llvm::raw_ostream::write(v1, "DomTree dump not available, build with DEBUG\n", 0x2DuLL);
  }
  return result;
}

void llvm::initializeDomViewerPass(uint64_t a1)
{
  uint64_t v1 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5538, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CBFE44B4;
    v3[1] = &v1;
    uint64_t v2 = v3;
    std::__call_once(&qword_1EBCC5538, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CBFE44B4()
{
}

void llvm::initializeDomOnlyViewerPass(uint64_t a1)
{
  uint64_t v1 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5540, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CBFE45C0;
    v3[1] = &v1;
    uint64_t v2 = v3;
    std::__call_once(&qword_1EBCC5540, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CBFE45C0()
{
}

void llvm::initializePostDomViewerPass(uint64_t a1)
{
  uint64_t v1 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5548, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CBFE46CC;
    v3[1] = &v1;
    uint64_t v2 = v3;
    std::__call_once(&qword_1EBCC5548, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CBFE46CC()
{
}

void llvm::initializePostDomOnlyViewerPass(uint64_t a1)
{
  uint64_t v1 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5550, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CBFE47D8;
    v3[1] = &v1;
    uint64_t v2 = v3;
    std::__call_once(&qword_1EBCC5550, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CBFE47D8()
{
}

void llvm::initializeDomPrinterPass(uint64_t a1)
{
  uint64_t v1 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5558, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CBFE48E4;
    v3[1] = &v1;
    uint64_t v2 = v3;
    std::__call_once(&qword_1EBCC5558, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CBFE48E4()
{
}

void llvm::initializeDomOnlyPrinterPass(uint64_t a1)
{
  uint64_t v1 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5560, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CBFE49F0;
    v3[1] = &v1;
    uint64_t v2 = v3;
    std::__call_once(&qword_1EBCC5560, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CBFE49F0()
{
}

void llvm::initializePostDomPrinterPass(uint64_t a1)
{
  uint64_t v1 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5568, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CBFE4AFC;
    v3[1] = &v1;
    uint64_t v2 = v3;
    std::__call_once(&qword_1EBCC5568, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CBFE4AFC()
{
}

void llvm::initializePostDomOnlyPrinterPass(uint64_t a1)
{
  uint64_t v1 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5570, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CBFE4C08;
    v3[1] = &v1;
    uint64_t v2 = v3;
    std::__call_once(&qword_1EBCC5570, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CBFE4C08()
{
}

uint64_t sub_1CBFE4CA4(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCC5534;
  *(_DWORD *)(a1 + 24) = 2;
  *(unsigned char *)(a1 + 55) = 3;
  *(_DWORD *)(a1 + 32) = 7171940;
  *(void *)a1 = &unk_1F2602898;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5558, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CBFE48E4;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCC5558, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

uint64_t sub_1CBFE4D68(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCC5535;
  *(_DWORD *)(a1 + 24) = 2;
  *(unsigned char *)(a1 + 55) = 7;
  strcpy((char *)(a1 + 32), "domonly");
  *(void *)a1 = &unk_1F26029E8;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5560, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CBFE49F0;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCC5560, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

uint64_t sub_1CBFE4E3C(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCC5530;
  *(_DWORD *)(a1 + 24) = 2;
  *(unsigned char *)(a1 + 55) = 3;
  *(_DWORD *)(a1 + 32) = 7171940;
  *(void *)a1 = &unk_1F2602B38;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5538, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CBFE44B4;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCC5538, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

uint64_t sub_1CBFE4F00(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCC5531;
  *(_DWORD *)(a1 + 24) = 2;
  *(unsigned char *)(a1 + 55) = 7;
  strcpy((char *)(a1 + 32), "domonly");
  *(void *)a1 = &unk_1F2602C88;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5540, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CBFE45C0;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCC5540, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

uint64_t sub_1CBFE4FD4(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCC5536;
  *(_DWORD *)(a1 + 24) = 2;
  *(unsigned char *)(a1 + 55) = 7;
  strcpy((char *)(a1 + 32), "postdom");
  *(void *)a1 = &unk_1F2602DD8;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5568, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CBFE4AFC;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCC5568, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

uint64_t sub_1CBFE50A8(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCC5537;
  *(_DWORD *)(a1 + 24) = 2;
  *(unsigned char *)(a1 + 55) = 11;
  strcpy((char *)(a1 + 32), "postdomonly");
  *(void *)a1 = &unk_1F2602F28;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5570, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CBFE4C08;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCC5570, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

uint64_t sub_1CBFE5180(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCC5532;
  *(_DWORD *)(a1 + 24) = 2;
  *(unsigned char *)(a1 + 55) = 7;
  strcpy((char *)(a1 + 32), "postdom");
  *(void *)a1 = &unk_1F2603078;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5548, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CBFE46CC;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCC5548, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

uint64_t sub_1CBFE5254(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCC5533;
  *(_DWORD *)(a1 + 24) = 2;
  *(unsigned char *)(a1 + 55) = 11;
  strcpy((char *)(a1 + 32), "postdomonly");
  *(void *)a1 = &unk_1F26031C8;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5550, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CBFE47D8;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCC5550, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void sub_1CBFE532C()
{
}

void sub_1CBFE5368()
{
}

void sub_1CBFE53A4()
{
}

void sub_1CBFE53E0()
{
}

void sub_1CBFE541C()
{
}

void sub_1CBFE5458()
{
}

void sub_1CBFE5494()
{
}

void sub_1CBFE54D0()
{
}

void sub_1CBFE550C(void **this)
{
  *this = &unk_1F2602940;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }

  llvm::Pass::~Pass((llvm::Pass *)this);
}

void sub_1CBFE556C(void **this)
{
  *this = &unk_1F2602940;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }
  llvm::Pass::~Pass((llvm::Pass *)this);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CBFE55E0(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
  sub_1CB843600(a2, a2, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
}

uint64_t sub_1CBFE55F8(uint64_t a1, uint64_t ***a2)
{
  uint64_t v4 = *(uint64_t **)(a1 + 8);
  uint64_t v5 = *v4;
  uint64_t v6 = v4[1];
  if (v5 == v6)
  {
LABEL_4:
    uint64_t v7 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v5 != &llvm::DominatorTreeWrapperPass::ID)
    {
      v5 += 16;
      if (v5 == v6) {
        goto LABEL_4;
      }
    }
    uint64_t v7 = *(void *)(v5 + 8);
  }
  uint64_t v8 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v7 + 96))(v7, &llvm::DominatorTreeWrapperPass::ID);
  if ((*(unsigned int (**)(uint64_t, uint64_t ***, uint64_t))(*(void *)a1 + 144))(a1, a2, v8))
  {
    uint64_t v87 = v8 + 32;
    char v10 = *(unsigned char *)(a1 + 55);
    int v11 = v10;
    size_t v12 = v10 & 0x7F;
    if (v11 >= 0) {
      size_t v13 = v12;
    }
    else {
      size_t v13 = *(void *)(a1 + 40);
    }
    p_p = &__p;
    sub_1CB907098((uint64_t)&__p, v13 + 1);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if (v13)
    {
      uint64_t v17 = *(char **)(a1 + 32);
      unsigned int v16 = (char *)(a1 + 32);
      BOOL v15 = v17;
      if (v16[23] >= 0) {
        int v18 = v16;
      }
      else {
        int v18 = v15;
      }
      memmove(p_p, v18, v13);
    }
    *(_WORD *)((char *)&p_p->__r_.__value_.__l.__data_ + v13) = 46;
    unsigned int v19 = a2 >> 4;
    if ((*((unsigned char *)a2 + 23) & 0x10) == 0)
    {
      size_t v29 = 0;
      HIBYTE(v84) = 0;
      p_dst = &__dst;
      goto LABEL_34;
    }
    uint64_t v20 = ***a2;
    uint64_t v21 = *(void *)(v20 + 152);
    uint64_t v22 = *(unsigned int *)(v20 + 168);
    if (v22)
    {
      LODWORD(v23) = (v22 - 1) & (v19 ^ (a2 >> 9));
      int v24 = (uint64_t ****)(v21 + 16 * v23);
      unsigned int v25 = *v24;
      if (*v24 == a2) {
        goto LABEL_26;
      }
      int v26 = 1;
      while (v25 != (uint64_t ***)-4096)
      {
        int v27 = v23 + v26++;
        uint64_t v23 = v27 & (v22 - 1);
        unsigned int v25 = *(uint64_t ****)(v21 + 16 * v23);
        if (v25 == a2)
        {
          int v24 = (uint64_t ****)(v21 + 16 * v23);
          goto LABEL_26;
        }
      }
    }
    int v24 = (uint64_t ****)(v21 + 16 * v22);
LABEL_26:
    int v28 = (unint64_t *)v24[1];
    unint64_t v31 = *v28;
    BOOL v30 = v28 + 2;
    size_t v29 = v31;
    if (v31 > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_106;
    }
    if (v29 >= 0x17)
    {
      uint64_t v33 = (v29 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v29 | 7) != 0x17) {
        uint64_t v33 = v29 | 7;
      }
      uint64_t v34 = v33 + 1;
      p_dst = (long long *)operator new(v33 + 1);
      *((void *)&__dst + sub_1CD456CB4((void *)this + 1) = v29;
      int64_t v84 = v34 | 0x8000000000000000;
      *(void *)&long long __dst = p_dst;
    }
    else
    {
      HIBYTE(v84) = v29;
      p_dst = &__dst;
      if (!v29)
      {
LABEL_34:
        *((unsigned char *)p_dst + v29) = 0;
        if (v84 >= 0) {
          int v35 = (const std::string::value_type *)&__dst;
        }
        else {
          int v35 = (const std::string::value_type *)__dst;
        }
        if (v84 >= 0) {
          std::string::size_type v36 = HIBYTE(v84) & 0x7F;
        }
        else {
          std::string::size_type v36 = *((void *)&__dst + 1);
        }
        int v37 = std::string::append(&__p, v35, v36);
        std::string::size_type v38 = v37->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v81.__r_.__value_.__l.__data_ = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
        v81.__r_.__value_.__r.__words[2] = v38;
        v37->__r_.__value_.__l.__size_ = 0;
        v37->__r_.__value_.__r.__words[2] = 0;
        v37->__r_.__value_.__r.__words[0] = 0;
        unsigned int v39 = std::string::append(&v81, ".dot");
        std::string::size_type v40 = v39->__r_.__value_.__r.__words[2];
        long long v85 = *(_OWORD *)&v39->__r_.__value_.__l.__data_;
        uint64_t v86 = v40;
        v39->__r_.__value_.__l.__size_ = 0;
        v39->__r_.__value_.__r.__words[2] = 0;
        v39->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v81.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v81.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v84) < 0) {
          operator delete((void *)__dst);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        v82[0] = 0;
        uint64_t v41 = (llvm *)std::system_category();
        int v42 = (llvm::raw_ostream *)llvm::errs(v41);
        uint64_t v43 = *((void *)v42 + 4);
        if ((unint64_t)(*((void *)v42 + 3) - v43) > 8)
        {
          *(unsigned char *)(v43 + 8) = 39;
          *(void *)uint64_t v43 = *(void *)"Writing '";
          *((void *)v42 + 4) += 9;
        }
        else
        {
          int v42 = llvm::raw_ostream::write(v42, "Writing '", 9uLL);
        }
        if (v86 >= 0) {
          uint64_t v44 = (const char *)&v85;
        }
        else {
          uint64_t v44 = (const char *)v85;
        }
        if (v86 >= 0) {
          size_t v45 = HIBYTE(v86) & 0x7F;
        }
        else {
          size_t v45 = *((void *)&v85 + 1);
        }
        int v46 = llvm::raw_ostream::write(v42, v44, v45);
        uint64_t v47 = (_DWORD *)*((void *)v46 + 4);
        if (*((void *)v46 + 3) - (void)v47 > 3uLL)
        {
          _DWORD *v47 = 774778407;
          *((void *)v46 + 4) += 4;
        }
        else
        {
          llvm::raw_ostream::write(v46, "'...", 4uLL);
        }
        if (v86 >= 0) {
          uint64_t v48 = &v85;
        }
        else {
          uint64_t v48 = (long long *)v85;
        }
        if (v86 >= 0) {
          uint64_t v49 = HIBYTE(v86) & 0x7F;
        }
        else {
          uint64_t v49 = *((void *)&v85 + 1);
        }
        llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)&v81, v48, v49, (uint64_t)v82, 3);
        v80.__r_.__value_.__s.__data_[21] = 0;
        HIWORD(v80.__r_.__value_.__r.__words[2]) = 5120;
        strcpy((char *)&v80, "Dominator tree for '");
        if ((*((unsigned char *)a2 + 23) & 0x10) == 0)
        {
          size_t v59 = 0;
          HIBYTE(v79) = 0;
          uint64_t v62 = &v77;
          goto LABEL_78;
        }
        uint64_t v50 = ***a2;
        uint64_t v51 = *(void *)(v50 + 152);
        uint64_t v52 = *(unsigned int *)(v50 + 168);
        if (v52)
        {
          LODWORD(v53) = (v52 - 1) & (v19 ^ (a2 >> 9));
          BOOL v54 = (uint64_t ****)(v51 + 16 * v53);
          unsigned int v55 = *v54;
          if (*v54 == a2) {
            goto LABEL_70;
          }
          int v56 = 1;
          while (v55 != (uint64_t ***)-4096)
          {
            int v57 = v53 + v56++;
            uint64_t v53 = v57 & (v52 - 1);
            unsigned int v55 = *(uint64_t ****)(v51 + 16 * v53);
            if (v55 == a2)
            {
              BOOL v54 = (uint64_t ****)(v51 + 16 * v53);
              goto LABEL_70;
            }
          }
        }
        BOOL v54 = (uint64_t ****)(v51 + 16 * v52);
LABEL_70:
        int v58 = (unint64_t *)v54[1];
        unint64_t v61 = *v58;
        int v60 = v58 + 2;
        size_t v59 = v61;
        if (v61 <= 0x7FFFFFFFFFFFFFF7)
        {
          if (v59 >= 0x17)
          {
            uint64_t v63 = (v59 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v59 | 7) != 0x17) {
              uint64_t v63 = v59 | 7;
            }
            uint64_t v64 = v63 + 1;
            uint64_t v62 = operator new(v63 + 1);
            std::string::size_type v78 = v59;
            int64_t v79 = v64 | 0x8000000000000000;
            unsigned int v77 = v62;
          }
          else
          {
            HIBYTE(v79) = v59;
            uint64_t v62 = &v77;
            if (!v59) {
              goto LABEL_78;
            }
          }
          memmove(v62, v60, v59);
LABEL_78:
          *((unsigned char *)v62 + v59) = 0;
          if (v79 >= 0) {
            uint64_t v65 = (const std::string::value_type *)&v77;
          }
          else {
            uint64_t v65 = (const std::string::value_type *)v77;
          }
          if (v79 >= 0) {
            std::string::size_type v66 = HIBYTE(v79) & 0x7F;
          }
          else {
            std::string::size_type v66 = v78;
          }
          int v67 = std::string::append(&v80, v65, v66);
          std::string::size_type v68 = v67->__r_.__value_.__r.__words[2];
          *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v67->__r_.__value_.__l.__data_;
          __p.__r_.__value_.__r.__words[2] = v68;
          v67->__r_.__value_.__l.__size_ = 0;
          v67->__r_.__value_.__r.__words[2] = 0;
          v67->__r_.__value_.__r.__words[0] = 0;
          unsigned int v69 = std::string::append(&__p, "' function");
          int64_t v70 = v69->__r_.__value_.__r.__words[2];
          long long __dst = *(_OWORD *)&v69->__r_.__value_.__l.__data_;
          int64_t v84 = v70;
          v69->__r_.__value_.__l.__size_ = 0;
          v69->__r_.__value_.__r.__words[2] = 0;
          v69->__r_.__value_.__r.__words[0] = 0;
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v79) < 0) {
            operator delete(v77);
          }
          if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v80.__r_.__value_.__l.__data_);
          }
          if (v82[0])
          {
            int v71 = (llvm::raw_ostream *)llvm::errs((llvm *)v69);
            uint64_t v72 = (void *)*((void *)v71 + 4);
            if (*((void *)v71 + 3) - (void)v72 > 0x20uLL)
            {
              qmemcpy(v72, "  error opening file for writing!", 33);
              *((void *)v71 + 4) += 33;
            }
            else
            {
              int v71 = llvm::raw_ostream::write(v71, "  error opening file for writing!", 0x21uLL);
            }
          }
          else
          {
            __int16 v76 = 260;
            __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&__dst;
            int v71 = sub_1CD484984((llvm::raw_ostream *)&v81, (llvm::raw_ostream *)&v87, 0, (llvm::Twine *)&__p);
          }
          int8x8_t v73 = (llvm::raw_ostream *)llvm::errs(v71);
          uint64_t v74 = (unsigned char *)*((void *)v73 + 4);
          if (*((unsigned char **)v73 + 3) == v74)
          {
            llvm::raw_ostream::write(v73, "\n", 1uLL);
          }
          else
          {
            *uint64_t v74 = 10;
            ++*((void *)v73 + 4);
          }
          if (SHIBYTE(v84) < 0) {
            operator delete((void *)__dst);
          }
          llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)&v81);
          if (SHIBYTE(v86) < 0) {
            operator delete((void *)v85);
          }
          return 0;
        }
LABEL_106:
        abort();
      }
    }
    memmove(p_dst, v30, v29);
    goto LABEL_34;
  }
  return 0;
}

uint64_t sub_1CBFE5C70()
{
  return 1;
}

void sub_1CBFE5C78(void **this)
{
  *this = &unk_1F2602940;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }

  llvm::Pass::~Pass((llvm::Pass *)this);
}

void sub_1CBFE5CD8(void **this)
{
  *this = &unk_1F2602940;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }
  llvm::Pass::~Pass((llvm::Pass *)this);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CBFE5D4C(uint64_t a1, unint64_t a2)
{
  char v68 = 0;
  LOBYTE(v67[0]) = 0;
  uint64_t v4 = *(llvm::raw_ostream **)a1;
  uint64_t v5 = *(void *)(*(void *)a1 + 32);
  if ((unint64_t)(*(void *)(*(void *)a1 + 24) - v5) > 4)
  {
    *(unsigned char *)(v5 + 4) = 101;
    *(_DWORD *)uint64_t v5 = 1685016073;
    *((void *)v4 + 4) += 5;
  }
  else
  {
    llvm::raw_ostream::write(*(llvm::raw_ostream **)a1, "\tNode", 5uLL);
  }
  llvm::write_hex(v4, a2, 3, 0, 0);
  uint64_t v6 = (void *)*((void *)v4 + 4);
  if (*((void *)v4 + 3) - (void)v6 > 7uLL)
  {
    *uint64_t v6 = 0x3D65706168735B20;
    *((void *)v4 + 4) += 8;
  }
  else
  {
    llvm::raw_ostream::write(v4, " [shape=", 8uLL);
  }
  uint64_t v7 = *(llvm::raw_ostream **)a1;
  uint64_t v8 = *(void *)(*(void *)a1 + 32);
  unint64_t v9 = *(void *)(*(void *)a1 + 24) - v8;
  if (*(unsigned char *)(a1 + 16))
  {
    if (v9 <= 4)
    {
      char v10 = "none,";
      size_t v11 = 5;
      goto LABEL_10;
    }
    *(unsigned char *)(v8 + 4) = 44;
    *(_DWORD *)uint64_t v8 = 1701736302;
    uint64_t v55 = *((void *)v7 + 4) + 5;
  }
  else
  {
    if (v9 <= 6)
    {
      char v10 = "record,";
      size_t v11 = 7;
LABEL_10:
      llvm::raw_ostream::write(v7, v10, v11);
      goto LABEL_11;
    }
    *(_DWORD *)(v8 + 3) = 744780399;
    *(_DWORD *)uint64_t v8 = 1868785010;
    uint64_t v55 = *((void *)v7 + 4) + 7;
  }
  *((void *)v7 + 4) = v55;
LABEL_11:
  if (v68 >= 0) {
    size_t v12 = v68 & 0x7F;
  }
  else {
    size_t v12 = (size_t)v67[1];
  }
  if (v12)
  {
    if (v68 >= 0) {
      size_t v13 = (const char *)v67;
    }
    else {
      size_t v13 = (const char *)v67[0];
    }
    int v14 = llvm::raw_ostream::write(*(llvm::raw_ostream **)a1, v13, v12);
    BOOL v15 = (unsigned char *)*((void *)v14 + 4);
    if (*((unsigned char **)v14 + 3) == v15)
    {
      llvm::raw_ostream::write(v14, ",", 1uLL);
    }
    else
    {
      unsigned char *v15 = 44;
      ++*((void *)v14 + 4);
    }
  }
  unsigned int v16 = *(llvm::raw_ostream **)a1;
  uint64_t v17 = *(void *)(*(void *)a1 + 32);
  if ((unint64_t)(*(void *)(*(void *)a1 + 24) - v17) > 5)
  {
    *(_WORD *)(v17 + 4) = 15724;
    *(_DWORD *)uint64_t v17 = 1700946284;
    *((void *)v16 + 4) += 6;
  }
  else
  {
    llvm::raw_ostream::write(v16, "label=", 6uLL);
  }
  if (*(unsigned char *)(a1 + 16))
  {
    uint64_t v21 = *(unsigned int *)(a2 + 32);
    if (v21)
    {
      int v23 = 0;
      uint64_t v24 = 8 * v21 - 8;
      do
      {
        LODWORD(v2sub_1CD456CB4((void *)this + 1) = v23 + 1;
        BOOL v22 = v24 != 0;
        if (!v24) {
          break;
        }
        v24 -= 8;
        BOOL v25 = v23++ == 63;
      }
      while (!v25);
    }
    else
    {
      BOOL v22 = 0;
    }
    if (v21 <= 1) {
      int v26 = 1;
    }
    else {
      int v26 = v21;
    }
    int v27 = *(llvm::raw_ostream **)a1;
    int v28 = *(void **)(*(void *)a1 + 32);
    if (*(void *)(*(void *)a1 + 24) - (void)v28 > 0x30uLL)
    {
      qmemcpy(v28, "<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\"", 49);
      size_t v29 = (void *)(*((void *)v27 + 4) + 49);
      *((void *)v27 + 4) = v29;
    }
    else
    {
      llvm::raw_ostream::write(*(llvm::raw_ostream **)a1, "<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\"", 0x31uLL);
      size_t v29 = (void *)*((void *)v27 + 4);
    }
    unint64_t v30 = (v26 + v22);
    if (*((void *)v27 + 3) - (void)v29 > 0x2EuLL)
    {
      qmemcpy(v29, " cellpadding=\"0\"><tr><td align=\"text\" colspan=\"", 47);
      *((void *)v27 + 4) += 47;
    }
    else
    {
      llvm::raw_ostream::write(v27, " cellpadding=\"0\"><tr><td align=\"text\" colspan=\"", 0x2FuLL);
    }
    sub_1CD098D14(v27, v30, 0, 0, 0);
    unint64_t v31 = (_WORD *)*((void *)v27 + 4);
    if (*((void *)v27 + 3) - (void)v31 <= 1uLL)
    {
      uint64_t v20 = "\">";
      int v18 = v27;
      goto LABEL_40;
    }
    *unint64_t v31 = 15906;
    *((void *)v27 + 4) += 2;
  }
  else
  {
    int v18 = *(llvm::raw_ostream **)a1;
    unsigned int v19 = *(_WORD **)(*(void *)a1 + 32);
    if (*(void *)(*(void *)a1 + 24) - (void)v19 <= 1uLL)
    {
      uint64_t v20 = "\"{";
LABEL_40:
      llvm::raw_ostream::write(v18, v20, 2uLL);
      goto LABEL_41;
    }
    *unsigned int v19 = 31522;
    *((void *)v18 + 4) += 2;
  }
LABEL_41:
  uint64_t v32 = *(llvm::raw_ostream **)a1;
  uint64_t v33 = (unsigned char *)(a1 + 17);
  if (*(unsigned char *)(a1 + 16))
  {
    sub_1CD484F2C((uint64_t)&__p, v33, *(llvm::Value **)a2);
    if (v58 >= 0) {
      p_p = (const char *)&__p;
    }
    else {
      p_p = (const char *)__p;
    }
    if (v58 >= 0) {
      size_t v38 = HIBYTE(v58) & 0x7F;
    }
    else {
      size_t v38 = v57;
    }
    llvm::raw_ostream::write(v32, p_p, v38);
    uint64_t v39 = *((void *)v32 + 4);
    if ((unint64_t)(*((void *)v32 + 3) - v39) > 4)
    {
      *(unsigned char *)(v39 + 4) = 62;
      *(_DWORD *)uint64_t v39 = 1685335868;
      *((void *)v32 + 4) += 5;
    }
    else
    {
      llvm::raw_ostream::write(v32, "</td>", 5uLL);
    }
    if (SHIBYTE(v58) < 0)
    {
      std::string::size_type v36 = __p;
      goto LABEL_62;
    }
  }
  else
  {
    sub_1CD484F2C((uint64_t)v65, v33, *(llvm::Value **)a2);
    llvm::DOT::EscapeString((char *)v65, (uint64_t)&__p);
    if (v58 >= 0) {
      uint64_t v34 = (const char *)&__p;
    }
    else {
      uint64_t v34 = (const char *)__p;
    }
    if (v58 >= 0) {
      size_t v35 = HIBYTE(v58) & 0x7F;
    }
    else {
      size_t v35 = v57;
    }
    llvm::raw_ostream::write(v32, v34, v35);
    if (SHIBYTE(v58) < 0) {
      operator delete(__p);
    }
    if (SHIBYTE(v66) < 0)
    {
      std::string::size_type v36 = v65[0];
LABEL_62:
      operator delete(v36);
    }
  }
  v65[0] = 0;
  v65[1] = 0;
  uint64_t v66 = 0;
  LODWORD(v57) = 0;
  char v61 = 0;
  uint64_t v62 = 0;
  uint64_t v64 = v65;
  int v63 = 0;
  std::string __p = &unk_1F2646F30;
  uint64_t v58 = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  if (*(unsigned char *)(a1 + 16)
    && (llvm::raw_ostream::write((llvm::raw_ostream *)&__p, "</tr><tr>", 9uLL), *(unsigned char *)(a1 + 16)))
  {
    std::string::size_type v40 = *(llvm::raw_ostream **)a1;
    uint64_t v41 = *(void **)(*(void *)a1 + 32);
    if (*(void *)(*(void *)a1 + 24) - (void)v41 <= 0xDuLL)
    {
      int v42 = "</tr></table>>";
      size_t v43 = 14;
LABEL_69:
      llvm::raw_ostream::write(v40, v42, v43);
      goto LABEL_70;
    }
    qmemcpy(v41, "</tr></table>>", 14);
    uint64_t v54 = *((void *)v40 + 4) + 14;
  }
  else
  {
    std::string::size_type v40 = *(llvm::raw_ostream **)a1;
    uint64_t v44 = *(_WORD **)(*(void *)a1 + 32);
    if (*(void *)(*(void *)a1 + 24) - (void)v44 <= 1uLL)
    {
      int v42 = "}\"";
      size_t v43 = 2;
      goto LABEL_69;
    }
    *uint64_t v44 = 8829;
    uint64_t v54 = *((void *)v40 + 4) + 2;
  }
  *((void *)v40 + 4) = v54;
LABEL_70:
  size_t v45 = *(llvm::raw_ostream **)a1;
  uint64_t v46 = *(void *)(*(void *)a1 + 32);
  if ((unint64_t)(*(void *)(*(void *)a1 + 24) - v46) > 2)
  {
    *(unsigned char *)(v46 + 2) = 10;
    *(_WORD *)uint64_t v46 = 15197;
    *((void *)v45 + 4) += 3;
  }
  else
  {
    llvm::raw_ostream::write(v45, "];\n", 3uLL);
  }
  uint64_t v47 = *(unint64_t **)(a2 + 24);
  uint64_t v48 = *(unsigned int *)(a2 + 32);
  uint64_t v49 = &v47[v48];
  if (v48)
  {
    unint64_t v50 = 0;
    uint64_t v51 = 8 * v48 - 8;
    do
    {
      sub_1CD484EE4((llvm::raw_ostream **)a1, a2, v47[v50 / 8]);
      unint64_t v52 = v50 + 8;
      if (v50 == 504) {
        break;
      }
      BOOL v25 = v51 == v50;
      v50 += 8;
    }
    while (!v25);
    uint64_t v47 = (unint64_t *)((char *)v47 + v52);
  }
  while (v47 != v49)
  {
    unint64_t v53 = *v47++;
    sub_1CD484EE4((llvm::raw_ostream **)a1, a2, v53);
  }
  std::string __p = &unk_1F2646B98;
  if (v63 == 1 && v58) {
    MEMORY[0x1D25D9CB0](v58, 0x1000C8077774924);
  }
  if (SHIBYTE(v66) < 0) {
    operator delete(v65[0]);
  }
  if (v68 < 0) {
    operator delete(v67[0]);
  }
}

void sub_1CBFE63FC(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v20 = v25;
  uint64_t v7 = *(const void **)a1;
  uint64_t v6 = *(const void **)(a1 + 8);
  if (v6 == *(const void **)a1)
  {
    uint64_t v21 = v25;
    uint64_t v8 = *(unsigned int *)(a1 + 20);
    if (v8) {
      memmove(v25, v6, 8 * v8);
    }
  }
  else
  {
    uint64_t v21 = *(unsigned char **)(a1 + 8);
    *(void *)(a1 + 8) = v7;
    LODWORD(v8) = *(_DWORD *)(a1 + 20);
  }
  int v22 = *(_DWORD *)(a1 + 16);
  int v23 = v8;
  int v24 = *(_DWORD *)(a1 + 24);
  *(void *)(a1 + 16) = 8;
  *(_DWORD *)(a1 + 24) = 0;
  *(_OWORD *)int v26 = *(_OWORD *)(a1 + 96);
  uint64_t v27 = *(void *)(a1 + 112);
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  size_t v12 = v17;
  char v10 = *(const void **)a2;
  unint64_t v9 = *(const void **)(a2 + 8);
  if (v9 == *(const void **)a2)
  {
    size_t v13 = v17;
    uint64_t v11 = *(unsigned int *)(a2 + 20);
    if (v11) {
      memmove(v17, v9, 8 * v11);
    }
  }
  else
  {
    size_t v13 = *(unsigned char **)(a2 + 8);
    *(void *)(a2 + 8) = v10;
    LODWORD(v1sub_1CD456CB4((void *)this + 1) = *(_DWORD *)(a2 + 20);
  }
  int v14 = *(_DWORD *)(a2 + 16);
  int v15 = v11;
  int v16 = *(_DWORD *)(a2 + 24);
  *(void *)(a2 + 16) = 8;
  *(_DWORD *)(a2 + 24) = 0;
  *(_OWORD *)std::string __p = *(_OWORD *)(a2 + 96);
  uint64_t v19 = *(void *)(a2 + 112);
  *(void *)(a2 + 96) = 0;
  *(void *)(a2 + 104) = 0;
  *(void *)(a2 + 112) = 0;
  sub_1CBFE6584(a3, (uint64_t *)&v20, (uint64_t *)&v12);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v13 != v12) {
    free(v13);
  }
  if (v26[0])
  {
    v26[1] = v26[0];
    operator delete(v26[0]);
  }
  if (v21 != v20) {
    free(v21);
  }
}

uint64_t sub_1CBFE6584(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6 = (void *)(a1 + 32);
  *(void *)a1 = v6;
  uint64_t v8 = *a2;
  uint64_t v7 = a2[1];
  if (v7 == *a2)
  {
    *(void *)(a1 + 8) = v6;
    uint64_t v9 = *((unsigned int *)a2 + 5);
    if (v9) {
      memmove(v6, (const void *)a2[1], 8 * v9);
    }
  }
  else
  {
    *(void *)(a1 + 8) = v7;
    a2[1] = v8;
  }
  *(void *)(a1 + 16) = a2[2];
  *(_DWORD *)(a1 + 24) = *((_DWORD *)a2 + 6);
  a2[2] = 8;
  *((_DWORD *)a2 + 6) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(_OWORD *)(a1 + 96) = *((_OWORD *)a2 + 6);
  *(void *)(a1 + 112) = a2[14];
  char v10 = (void *)(a1 + 152);
  a2[12] = 0;
  a2[13] = 0;
  a2[14] = 0;
  *(void *)(a1 + 120) = a1 + 152;
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  if (v11 == *a3)
  {
    *(void *)(a1 + 128) = v10;
    uint64_t v13 = *((unsigned int *)a3 + 5);
    if (v13) {
      memmove(v10, (const void *)a3[1], 8 * v13);
    }
  }
  else
  {
    *(void *)(a1 + 128) = v11;
    a3[1] = v12;
  }
  *(void *)(a1 + 136) = a3[2];
  *(_DWORD *)(a1 + 144) = *((_DWORD *)a3 + 6);
  a3[2] = 8;
  *((_DWORD *)a3 + 6) = 0;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 224) = 0;
  *(void *)(a1 + 232) = 0;
  *(_OWORD *)(a1 + 216) = *((_OWORD *)a3 + 6);
  *(void *)(a1 + 232) = a3[14];
  a3[12] = 0;
  a3[13] = 0;
  a3[14] = 0;
  return a1;
}

void sub_1CBFE66A8(llvm::SmallPtrSetImplBase *this)
{
  uint64_t v2 = *((void *)this + 13);
  while (2)
  {
    uint64_t v3 = *(void *)(v2 - 24);
    if (!*(unsigned char *)(v2 - 8))
    {
      *(void *)(v2 - 16) = *(void *)(v3 + 24);
      *(unsigned char *)(v2 - 8) = 1;
    }
    while (1)
    {
      uint64_t v4 = *(uint64_t **)(v2 - 16);
      if (v4 == (uint64_t *)(*(void *)(v3 + 24) + 8 * *(unsigned int *)(v3 + 32))) {
        break;
      }
      *(void *)(v2 - 16) = v4 + 1;
      uint64_t v5 = *v4;
      uint64_t v6 = *((void *)this + 1);
      uint64_t v7 = *((unsigned int *)this + 5);
      if (v6 != *(void *)this)
      {
        unsigned int v11 = *((_DWORD *)this + 4);
        goto LABEL_25;
      }
      if (v7)
      {
        uint64_t v8 = 0;
        uint64_t v9 = 8 * v7;
        char v10 = (void *)*((void *)this + 1);
        while (*v10 != v5)
        {
          if (*v10 == -2) {
            uint64_t v8 = v10;
          }
          ++v10;
          v9 -= 8;
          if (!v9)
          {
            if (!v8) {
              goto LABEL_13;
            }
            *uint64_t v8 = v5;
            --*((_DWORD *)this + 6);
            goto LABEL_39;
          }
        }
      }
      else
      {
LABEL_13:
        unsigned int v11 = *((_DWORD *)this + 4);
        if (v7 < v11)
        {
          *((_DWORD *)this + 5) = v7 + 1;
          *(void *)(v6 + 8 * v7) = v5;
LABEL_39:
          int v23 = (unsigned char *)*((void *)this + 13);
          unint64_t v22 = *((void *)this + 14);
          if ((unint64_t)v23 >= v22)
          {
            BOOL v25 = (unsigned char *)*((void *)this + 12);
            unint64_t v26 = 0xAAAAAAAAAAAAAAABLL * ((v23 - v25) >> 3) + 1;
            if (v26 > 0xAAAAAAAAAAAAAAALL) {
              abort();
            }
            unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v22 - (void)v25) >> 3);
            if (2 * v27 > v26) {
              unint64_t v26 = 2 * v27;
            }
            if (v27 >= 0x555555555555555) {
              unint64_t v28 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v28 = v26;
            }
            if (v28)
            {
              if (v28 > 0xAAAAAAAAAAAAAAALL) {
                sub_1CB833614();
              }
              size_t v29 = (char *)operator new(24 * v28);
            }
            else
            {
              size_t v29 = 0;
            }
            unint64_t v30 = &v29[8 * ((v23 - v25) >> 3)];
            *(void *)unint64_t v30 = v5;
            v30[8] = 0;
            v30[16] = 0;
            int v24 = v30 + 24;
            if (v23 != v25)
            {
              do
              {
                long long v31 = *(_OWORD *)(v23 - 24);
                *((void *)v30 - sub_1CD456CB4((void *)this + 1) = *((void *)v23 - 1);
                *(_OWORD *)(v30 - 24) = v31;
                v30 -= 24;
                v23 -= 24;
              }
              while (v23 != v25);
              int v23 = (unsigned char *)*((void *)this + 12);
            }
            *((void *)this + 12) = v30;
            *((void *)this + 13) = v24;
            *((void *)this + 14) = &v29[24 * v28];
            if (v23) {
              operator delete(v23);
            }
          }
          else
          {
            *(void *)int v23 = v5;
            v23[8] = 0;
            int v24 = v23 + 24;
            v23[16] = 0;
          }
          *((void *)this + 13) = v24;
          return;
        }
LABEL_25:
        if (3 * v11 <= 4 * ((int)v7 - *((_DWORD *)this + 6)))
        {
          if (v11 >= 0x40) {
            v11 *= 2;
          }
          else {
            unsigned int v11 = 128;
          }
LABEL_63:
          llvm::SmallPtrSetImplBase::Grow(this, v11);
          unsigned int v11 = *((_DWORD *)this + 4);
          uint64_t v6 = *((void *)this + 1);
          goto LABEL_27;
        }
        if (v11 - v7 < v11 >> 3) {
          goto LABEL_63;
        }
LABEL_27:
        unsigned int v19 = v11 - 1;
        unsigned int v16 = (v11 - 1) & ((v5 >> 4) ^ (v5 >> 9));
        uint64_t v17 = (void *)(v6 + 8 * v16);
        uint64_t v18 = *v17;
        if (*v17 == -1)
        {
          uint64_t v13 = 0;
LABEL_31:
          if (v13) {
            uint64_t v21 = v13;
          }
          else {
            uint64_t v21 = v17;
          }
          if (*v21 != v5)
          {
            if (*v21 == -2) {
              --*((_DWORD *)this + 6);
            }
            else {
              ++*((_DWORD *)this + 5);
            }
            *uint64_t v21 = v5;
            goto LABEL_39;
          }
        }
        else
        {
          uint64_t v13 = 0;
          int v15 = 1;
          while (v18 != v5)
          {
            if (v13) {
              BOOL v12 = 0;
            }
            else {
              BOOL v12 = v18 == -2;
            }
            if (v12) {
              uint64_t v13 = v17;
            }
            unsigned int v14 = v16 + v15++;
            unsigned int v16 = v14 & v19;
            uint64_t v17 = (void *)(v6 + 8 * (v14 & v19));
            uint64_t v18 = *v17;
            if (*v17 == -1) {
              goto LABEL_31;
            }
          }
        }
      }
    }
    uint64_t v20 = *((void *)this + 12);
    uint64_t v2 = *((void *)this + 13) - 24;
    *((void *)this + 13) = v2;
    if (v20 != v2) {
      continue;
    }
    break;
  }
}

void sub_1CBFE699C(void **this)
{
  *this = &unk_1F2602A90;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }

  llvm::Pass::~Pass((llvm::Pass *)this);
}

void sub_1CBFE69FC(void **this)
{
  *this = &unk_1F2602A90;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }
  llvm::Pass::~Pass((llvm::Pass *)this);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CBFE6A70(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
  sub_1CB843600(a2, a2, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
}

uint64_t sub_1CBFE6A88(uint64_t a1, uint64_t ***a2)
{
  uint64_t v4 = *(uint64_t **)(a1 + 8);
  uint64_t v5 = *v4;
  uint64_t v6 = v4[1];
  if (v5 == v6)
  {
LABEL_4:
    uint64_t v7 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v5 != &llvm::DominatorTreeWrapperPass::ID)
    {
      v5 += 16;
      if (v5 == v6) {
        goto LABEL_4;
      }
    }
    uint64_t v7 = *(void *)(v5 + 8);
  }
  uint64_t v8 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v7 + 96))(v7, &llvm::DominatorTreeWrapperPass::ID);
  if ((*(unsigned int (**)(uint64_t, uint64_t ***, uint64_t))(*(void *)a1 + 144))(a1, a2, v8))
  {
    uint64_t v87 = v8 + 32;
    char v10 = *(unsigned char *)(a1 + 55);
    int v11 = v10;
    size_t v12 = v10 & 0x7F;
    if (v11 >= 0) {
      size_t v13 = v12;
    }
    else {
      size_t v13 = *(void *)(a1 + 40);
    }
    p_p = &__p;
    sub_1CB907098((uint64_t)&__p, v13 + 1);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if (v13)
    {
      uint64_t v17 = *(char **)(a1 + 32);
      unsigned int v16 = (char *)(a1 + 32);
      int v15 = v17;
      if (v16[23] >= 0) {
        uint64_t v18 = v16;
      }
      else {
        uint64_t v18 = v15;
      }
      memmove(p_p, v18, v13);
    }
    *(_WORD *)((char *)&p_p->__r_.__value_.__l.__data_ + v13) = 46;
    unsigned int v19 = a2 >> 4;
    if ((*((unsigned char *)a2 + 23) & 0x10) == 0)
    {
      size_t v29 = 0;
      HIBYTE(v84) = 0;
      p_dst = &__dst;
      goto LABEL_34;
    }
    uint64_t v20 = ***a2;
    uint64_t v21 = *(void *)(v20 + 152);
    uint64_t v22 = *(unsigned int *)(v20 + 168);
    if (v22)
    {
      LODWORD(v23) = (v22 - 1) & (v19 ^ (a2 >> 9));
      int v24 = (uint64_t ****)(v21 + 16 * v23);
      BOOL v25 = *v24;
      if (*v24 == a2) {
        goto LABEL_26;
      }
      int v26 = 1;
      while (v25 != (uint64_t ***)-4096)
      {
        int v27 = v23 + v26++;
        uint64_t v23 = v27 & (v22 - 1);
        BOOL v25 = *(uint64_t ****)(v21 + 16 * v23);
        if (v25 == a2)
        {
          int v24 = (uint64_t ****)(v21 + 16 * v23);
          goto LABEL_26;
        }
      }
    }
    int v24 = (uint64_t ****)(v21 + 16 * v22);
LABEL_26:
    unint64_t v28 = (unint64_t *)v24[1];
    unint64_t v31 = *v28;
    unint64_t v30 = v28 + 2;
    size_t v29 = v31;
    if (v31 > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_106;
    }
    if (v29 >= 0x17)
    {
      uint64_t v33 = (v29 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v29 | 7) != 0x17) {
        uint64_t v33 = v29 | 7;
      }
      uint64_t v34 = v33 + 1;
      p_dst = (long long *)operator new(v33 + 1);
      *((void *)&__dst + sub_1CD456CB4((void *)this + 1) = v29;
      int64_t v84 = v34 | 0x8000000000000000;
      *(void *)&long long __dst = p_dst;
    }
    else
    {
      HIBYTE(v84) = v29;
      p_dst = &__dst;
      if (!v29)
      {
LABEL_34:
        *((unsigned char *)p_dst + v29) = 0;
        if (v84 >= 0) {
          size_t v35 = (const std::string::value_type *)&__dst;
        }
        else {
          size_t v35 = (const std::string::value_type *)__dst;
        }
        if (v84 >= 0) {
          std::string::size_type v36 = HIBYTE(v84) & 0x7F;
        }
        else {
          std::string::size_type v36 = *((void *)&__dst + 1);
        }
        int v37 = std::string::append(&__p, v35, v36);
        std::string::size_type v38 = v37->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v81.__r_.__value_.__l.__data_ = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
        v81.__r_.__value_.__r.__words[2] = v38;
        v37->__r_.__value_.__l.__size_ = 0;
        v37->__r_.__value_.__r.__words[2] = 0;
        v37->__r_.__value_.__r.__words[0] = 0;
        uint64_t v39 = std::string::append(&v81, ".dot");
        std::string::size_type v40 = v39->__r_.__value_.__r.__words[2];
        long long v85 = *(_OWORD *)&v39->__r_.__value_.__l.__data_;
        uint64_t v86 = v40;
        v39->__r_.__value_.__l.__size_ = 0;
        v39->__r_.__value_.__r.__words[2] = 0;
        v39->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v81.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v81.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v84) < 0) {
          operator delete((void *)__dst);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        v82[0] = 0;
        uint64_t v41 = (llvm *)std::system_category();
        int v42 = (llvm::raw_ostream *)llvm::errs(v41);
        uint64_t v43 = *((void *)v42 + 4);
        if ((unint64_t)(*((void *)v42 + 3) - v43) > 8)
        {
          *(unsigned char *)(v43 + 8) = 39;
          *(void *)uint64_t v43 = *(void *)"Writing '";
          *((void *)v42 + 4) += 9;
        }
        else
        {
          int v42 = llvm::raw_ostream::write(v42, "Writing '", 9uLL);
        }
        if (v86 >= 0) {
          uint64_t v44 = (const char *)&v85;
        }
        else {
          uint64_t v44 = (const char *)v85;
        }
        if (v86 >= 0) {
          size_t v45 = HIBYTE(v86) & 0x7F;
        }
        else {
          size_t v45 = *((void *)&v85 + 1);
        }
        uint64_t v46 = llvm::raw_ostream::write(v42, v44, v45);
        uint64_t v47 = (_DWORD *)*((void *)v46 + 4);
        if (*((void *)v46 + 3) - (void)v47 > 3uLL)
        {
          _DWORD *v47 = 774778407;
          *((void *)v46 + 4) += 4;
        }
        else
        {
          llvm::raw_ostream::write(v46, "'...", 4uLL);
        }
        if (v86 >= 0) {
          uint64_t v48 = &v85;
        }
        else {
          uint64_t v48 = (long long *)v85;
        }
        if (v86 >= 0) {
          uint64_t v49 = HIBYTE(v86) & 0x7F;
        }
        else {
          uint64_t v49 = *((void *)&v85 + 1);
        }
        llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)&v81, v48, v49, (uint64_t)v82, 3);
        v80.__r_.__value_.__s.__data_[21] = 0;
        HIWORD(v80.__r_.__value_.__r.__words[2]) = 5120;
        strcpy((char *)&v80, "Dominator tree for '");
        if ((*((unsigned char *)a2 + 23) & 0x10) == 0)
        {
          size_t v59 = 0;
          HIBYTE(v79) = 0;
          uint64_t v62 = &v77;
          goto LABEL_78;
        }
        uint64_t v50 = ***a2;
        uint64_t v51 = *(void *)(v50 + 152);
        uint64_t v52 = *(unsigned int *)(v50 + 168);
        if (v52)
        {
          LODWORD(v53) = (v52 - 1) & (v19 ^ (a2 >> 9));
          uint64_t v54 = (uint64_t ****)(v51 + 16 * v53);
          uint64_t v55 = *v54;
          if (*v54 == a2) {
            goto LABEL_70;
          }
          int v56 = 1;
          while (v55 != (uint64_t ***)-4096)
          {
            int v57 = v53 + v56++;
            uint64_t v53 = v57 & (v52 - 1);
            uint64_t v55 = *(uint64_t ****)(v51 + 16 * v53);
            if (v55 == a2)
            {
              uint64_t v54 = (uint64_t ****)(v51 + 16 * v53);
              goto LABEL_70;
            }
          }
        }
        uint64_t v54 = (uint64_t ****)(v51 + 16 * v52);
LABEL_70:
        uint64_t v58 = (unint64_t *)v54[1];
        unint64_t v61 = *v58;
        uint64_t v60 = v58 + 2;
        size_t v59 = v61;
        if (v61 <= 0x7FFFFFFFFFFFFFF7)
        {
          if (v59 >= 0x17)
          {
            uint64_t v63 = (v59 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v59 | 7) != 0x17) {
              uint64_t v63 = v59 | 7;
            }
            uint64_t v64 = v63 + 1;
            uint64_t v62 = operator new(v63 + 1);
            std::string::size_type v78 = v59;
            int64_t v79 = v64 | 0x8000000000000000;
            unsigned int v77 = v62;
          }
          else
          {
            HIBYTE(v79) = v59;
            uint64_t v62 = &v77;
            if (!v59) {
              goto LABEL_78;
            }
          }
          memmove(v62, v60, v59);
LABEL_78:
          *((unsigned char *)v62 + v59) = 0;
          if (v79 >= 0) {
            uint64_t v65 = (const std::string::value_type *)&v77;
          }
          else {
            uint64_t v65 = (const std::string::value_type *)v77;
          }
          if (v79 >= 0) {
            std::string::size_type v66 = HIBYTE(v79) & 0x7F;
          }
          else {
            std::string::size_type v66 = v78;
          }
          int v67 = std::string::append(&v80, v65, v66);
          std::string::size_type v68 = v67->__r_.__value_.__r.__words[2];
          *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v67->__r_.__value_.__l.__data_;
          __p.__r_.__value_.__r.__words[2] = v68;
          v67->__r_.__value_.__l.__size_ = 0;
          v67->__r_.__value_.__r.__words[2] = 0;
          v67->__r_.__value_.__r.__words[0] = 0;
          unsigned int v69 = std::string::append(&__p, "' function");
          int64_t v70 = v69->__r_.__value_.__r.__words[2];
          long long __dst = *(_OWORD *)&v69->__r_.__value_.__l.__data_;
          int64_t v84 = v70;
          v69->__r_.__value_.__l.__size_ = 0;
          v69->__r_.__value_.__r.__words[2] = 0;
          v69->__r_.__value_.__r.__words[0] = 0;
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v79) < 0) {
            operator delete(v77);
          }
          if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v80.__r_.__value_.__l.__data_);
          }
          if (v82[0])
          {
            int v71 = (llvm::raw_ostream *)llvm::errs((llvm *)v69);
            uint64_t v72 = (void *)*((void *)v71 + 4);
            if (*((void *)v71 + 3) - (void)v72 > 0x20uLL)
            {
              qmemcpy(v72, "  error opening file for writing!", 33);
              *((void *)v71 + 4) += 33;
            }
            else
            {
              int v71 = llvm::raw_ostream::write(v71, "  error opening file for writing!", 0x21uLL);
            }
          }
          else
          {
            __int16 v76 = 260;
            __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&__dst;
            int v71 = sub_1CD484984((llvm::raw_ostream *)&v81, (llvm::raw_ostream *)&v87, 1, (llvm::Twine *)&__p);
          }
          int8x8_t v73 = (llvm::raw_ostream *)llvm::errs(v71);
          uint64_t v74 = (unsigned char *)*((void *)v73 + 4);
          if (*((unsigned char **)v73 + 3) == v74)
          {
            llvm::raw_ostream::write(v73, "\n", 1uLL);
          }
          else
          {
            *uint64_t v74 = 10;
            ++*((void *)v73 + 4);
          }
          if (SHIBYTE(v84) < 0) {
            operator delete((void *)__dst);
          }
          llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)&v81);
          if (SHIBYTE(v86) < 0) {
            operator delete((void *)v85);
          }
          return 0;
        }
LABEL_106:
        abort();
      }
    }
    memmove(p_dst, v30, v29);
    goto LABEL_34;
  }
  return 0;
}

uint64_t sub_1CBFE7100()
{
  return 1;
}

void sub_1CBFE7108(void **this)
{
  *this = &unk_1F2602A90;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }

  llvm::Pass::~Pass((llvm::Pass *)this);
}

void sub_1CBFE7168(void **this)
{
  *this = &unk_1F2602A90;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }
  llvm::Pass::~Pass((llvm::Pass *)this);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CBFE71DC(void **this)
{
  *this = &unk_1F2602BE0;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }

  llvm::Pass::~Pass((llvm::Pass *)this);
}

void sub_1CBFE723C(void **this)
{
  *this = &unk_1F2602BE0;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }
  llvm::Pass::~Pass((llvm::Pass *)this);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CBFE72B0(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
  sub_1CB843600(a2, a2, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
}

uint64_t sub_1CBFE72C8(void *a1, uint64_t ***a2)
{
  uint64_t v4 = (uint64_t *)a1[1];
  uint64_t v5 = *v4;
  uint64_t v6 = v4[1];
  if (v5 == v6)
  {
LABEL_4:
    uint64_t v7 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v5 != &llvm::DominatorTreeWrapperPass::ID)
    {
      v5 += 16;
      if (v5 == v6) {
        goto LABEL_4;
      }
    }
    uint64_t v7 = *(void *)(v5 + 8);
  }
  uint64_t v8 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v7 + 96))(v7, &llvm::DominatorTreeWrapperPass::ID);
  if ((*(unsigned int (**)(void *, uint64_t ***, uint64_t))(*a1 + 144))(a1, a2, v8))
  {
    uint64_t v40 = v8 + 32;
    v31.__r_.__value_.__s.__data_[21] = 0;
    HIWORD(v31.__r_.__value_.__r.__words[2]) = 5120;
    strcpy((char *)&v31, "Dominator tree for '");
    if ((*((unsigned char *)a2 + 23) & 0x10) == 0)
    {
      size_t v19 = 0;
      HIBYTE(v37) = 0;
      p_dst = (void **)&__dst;
      goto LABEL_24;
    }
    uint64_t v10 = ***a2;
    uint64_t v11 = *(void *)(v10 + 152);
    uint64_t v12 = *(unsigned int *)(v10 + 168);
    if (v12)
    {
      LODWORD(v13) = (v12 - 1) & ((a2 >> 4) ^ (a2 >> 9));
      unsigned int v14 = (uint64_t ****)(v11 + 16 * v13);
      int v15 = *v14;
      if (*v14 == a2)
      {
LABEL_16:
        uint64_t v18 = (unint64_t *)v14[1];
        unint64_t v21 = *v18;
        uint64_t v20 = v18 + 2;
        size_t v19 = v21;
        if (v21 >= 0x7FFFFFFFFFFFFFF8) {
          abort();
        }
        if (v19 >= 0x17)
        {
          uint64_t v23 = (v19 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v19 | 7) != 0x17) {
            uint64_t v23 = v19 | 7;
          }
          uint64_t v24 = v23 + 1;
          p_dst = (void **)operator new(v23 + 1);
          std::string::size_type v36 = v19;
          int64_t v37 = v24 | 0x8000000000000000;
          long long __dst = p_dst;
        }
        else
        {
          HIBYTE(v37) = v19;
          p_dst = (void **)&__dst;
          if (!v19) {
            goto LABEL_24;
          }
        }
        memmove(p_dst, v20, v19);
LABEL_24:
        *((unsigned char *)p_dst + v19) = 0;
        if (v37 >= 0) {
          BOOL v25 = (const std::string::value_type *)&__dst;
        }
        else {
          BOOL v25 = (const std::string::value_type *)__dst;
        }
        if (v37 >= 0) {
          std::string::size_type v26 = HIBYTE(v37) & 0x7F;
        }
        else {
          std::string::size_type v26 = v36;
        }
        int v27 = std::string::append(&v31, v25, v26);
        std::string::size_type v28 = v27->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v33.__r_.__value_.__l.__data_ = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
        v33.__r_.__value_.__r.__words[2] = v28;
        v27->__r_.__value_.__l.__size_ = 0;
        v27->__r_.__value_.__r.__words[2] = 0;
        v27->__r_.__value_.__r.__words[0] = 0;
        size_t v29 = std::string::append(&v33, "' function");
        std::string::size_type v30 = v29->__r_.__value_.__r.__words[2];
        long long v38 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
        std::string::size_type v39 = v30;
        v29->__r_.__value_.__l.__size_ = 0;
        v29->__r_.__value_.__r.__words[2] = 0;
        v29->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v33.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v37) < 0) {
          operator delete(__dst);
        }
        if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v31.__r_.__value_.__l.__data_);
        }
        __int16 v34 = 260;
        v33.__r_.__value_.__r.__words[0] = (std::string::size_type)(a1 + 4);
        __int16 v32 = 260;
        v31.__r_.__value_.__r.__words[0] = (std::string::size_type)&v38;
        sub_1CD48500C((llvm::raw_ostream *)&v40, (llvm::Twine *)&v33, 0, (llvm::Twine *)&v31);
        if (SHIBYTE(v39) < 0) {
          operator delete((void *)v38);
        }
        return 0;
      }
      int v16 = 1;
      while (v15 != (uint64_t ***)-4096)
      {
        int v17 = v13 + v16++;
        uint64_t v13 = v17 & (v12 - 1);
        int v15 = *(uint64_t ****)(v11 + 16 * v13);
        if (v15 == a2)
        {
          unsigned int v14 = (uint64_t ****)(v11 + 16 * v13);
          goto LABEL_16;
        }
      }
    }
    unsigned int v14 = (uint64_t ****)(v11 + 16 * v12);
    goto LABEL_16;
  }
  return 0;
}

uint64_t sub_1CBFE75CC()
{
  return 1;
}

void sub_1CBFE75D4(void **this)
{
  *this = &unk_1F2602BE0;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }

  llvm::Pass::~Pass((llvm::Pass *)this);
}

void sub_1CBFE7634(void **this)
{
  *this = &unk_1F2602BE0;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }
  llvm::Pass::~Pass((llvm::Pass *)this);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CBFE76A8(uint64_t a1, llvm::raw_ostream *a2, llvm::Twine *this, char a4, llvm::Twine *a5, uint64_t a6)
{
  if (*(char *)(a6 + 23) < 0) {
    uint64_t v11 = *(void *)(a6 + 8);
  }
  else {
    uint64_t v11 = *(unsigned __int8 *)(a6 + 23);
  }
  int v49 = 0;
  if (v11)
  {
    __int16 v44 = 260;
    uint64_t v42 = a6;
    *(void *)&long long v47 = llvm::sys::fs::openFile((unsigned __int8 *)&v42, &v49, 0, 2, 1, 438);
    *((void *)&v47 + sub_1CD456CB4((void *)this + 1) = v12;
    uint64_t v13 = std::generic_category();
    uint64_t v42 = 17;
    uint64_t v43 = v13;
    unsigned int v14 = (llvm *)(*(uint64_t (**)(void, void, uint64_t *))(**((void **)&v47 + 1) + 32))(*((void *)&v47 + 1), v47, &v42);
    if (v14
      || (unsigned int v14 = (llvm *)((uint64_t (*)(const std::error_category *, long long *, void))v43->equivalent_0)(v43, &v47, v42), v14))
    {
      uint64_t v20 = (llvm::raw_ostream *)llvm::errs(v14);
      unint64_t v21 = (void *)*((void *)v20 + 4);
      if (*((void *)v20 + 3) - (void)v21 > 0x17uLL)
      {
        qmemcpy(v21, "file exists, overwriting", 24);
        uint64_t v22 = (unsigned char *)(*((void *)v20 + 4) + 24);
        *((void *)v20 + 4) = v22;
      }
      else
      {
        uint64_t v20 = llvm::raw_ostream::write(v20, "file exists, overwriting", 0x18uLL);
        uint64_t v22 = (unsigned char *)*((void *)v20 + 4);
      }
      uint64_t v23 = (unsigned char *)*((void *)v20 + 3);
    }
    else
    {
      int v15 = v47;
      int v16 = (llvm::raw_ostream *)llvm::errs(v14);
      int v17 = (char *)*((void *)v16 + 4);
      unint64_t v18 = *((void *)v16 + 3) - (void)v17;
      if (v15)
      {
        if (v18 > 0x16)
        {
          qmemcpy(v17, "error writing into file", 23);
          size_t v19 = (unsigned char *)(*((void *)v16 + 4) + 23);
          *((void *)v16 + 4) = v19;
        }
        else
        {
          int v16 = llvm::raw_ostream::write(v16, "error writing into file", 0x17uLL);
          size_t v19 = (unsigned char *)*((void *)v16 + 4);
        }
        if (*((unsigned char **)v16 + 3) == v19)
        {
          llvm::raw_ostream::write(v16, "\n", 1uLL);
        }
        else
        {
          *size_t v19 = 10;
          ++*((void *)v16 + 4);
        }
        *(unsigned char *)(a1 + 23) = 0;
        *(unsigned char *)a1 = 0;
        return;
      }
      if (v18 > 0x21)
      {
        qmemcpy(v17, "writing to the newly created file ", 34);
        *((void *)v16 + 4) += 34;
      }
      else
      {
        int v16 = llvm::raw_ostream::write(v16, "writing to the newly created file ", 0x22uLL);
      }
      char v24 = *(unsigned char *)(a6 + 23);
      BOOL v25 = v24 < 0;
      if (v24 >= 0) {
        std::string::size_type v26 = (const char *)a6;
      }
      else {
        std::string::size_type v26 = *(const char **)a6;
      }
      size_t v27 = v24 & 0x7F;
      if (v25) {
        size_t v28 = *(void *)(a6 + 8);
      }
      else {
        size_t v28 = v27;
      }
      uint64_t v20 = llvm::raw_ostream::write(v16, v26, v28);
      uint64_t v23 = (unsigned char *)*((void *)v20 + 3);
      uint64_t v22 = (unsigned char *)*((void *)v20 + 4);
    }
    if (v23 == v22)
    {
      llvm::raw_ostream::write(v20, "\n", 1uLL);
    }
    else
    {
      *uint64_t v22 = 10;
      ++*((void *)v20 + 4);
    }
  }
  else
  {
    llvm::Twine::str(this, __p);
    __int16 v44 = 260;
    uint64_t v42 = (uint64_t)__p;
    llvm::createGraphFilename((llvm *)&v42, (const llvm::Twine *)&v49, (uint64_t)&v47);
    if (*(char *)(a6 + 23) < 0) {
      operator delete(*(void **)a6);
    }
    *(_OWORD *)a6 = v47;
    *(void *)(a6 + 16) = v48;
    HIBYTE(v48) = 0;
    LOBYTE(v47) = 0;
    if (v46 < 0) {
      operator delete(__p[0]);
    }
  }
  size_t v29 = (llvm *)llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)&v42, v49, 1, 0, 0);
  if (v49 == -1)
  {
    std::string::size_type v30 = (llvm::raw_ostream *)llvm::errs(v29);
    uint64_t v31 = *((void *)v30 + 4);
    if ((unint64_t)(*((void *)v30 + 3) - v31) > 0x13)
    {
      *(_DWORD *)(v31 + 16) = 656434540;
      *(_OWORD *)uint64_t v31 = *(_OWORD *)"error opening file '";
      *((void *)v30 + 4) += 20;
    }
    else
    {
      std::string::size_type v30 = llvm::raw_ostream::write(v30, "error opening file '", 0x14uLL);
    }
    char v32 = *(unsigned char *)(a6 + 23);
    BOOL v33 = v32 < 0;
    if (v32 >= 0) {
      __int16 v34 = (const char *)a6;
    }
    else {
      __int16 v34 = *(const char **)a6;
    }
    size_t v35 = v32 & 0x7F;
    if (v33) {
      size_t v36 = *(void *)(a6 + 8);
    }
    else {
      size_t v36 = v35;
    }
    int64_t v37 = llvm::raw_ostream::write(v30, v34, v36);
    long long v38 = (void *)*((void *)v37 + 4);
    if (*((void *)v37 + 3) - (void)v38 > 0xEuLL)
    {
      qmemcpy(v38, "' for writing!\n", 15);
      *((void *)v37 + 4) += 15;
    }
    else
    {
      llvm::raw_ostream::write(v37, "' for writing!\n", 0xFuLL);
    }
    *(unsigned char *)(a1 + 23) = 0;
    *(unsigned char *)a1 = 0;
  }
  else
  {
    std::string::size_type v39 = sub_1CD484984((llvm::raw_ostream *)&v42, a2, a4, a5);
    uint64_t v40 = (llvm::raw_ostream *)llvm::errs(v39);
    uint64_t v41 = (void *)*((void *)v40 + 4);
    if (*((void *)v40 + 3) - (void)v41 > 7uLL)
    {
      *uint64_t v41 = 0xA202E656E6F6420;
      *((void *)v40 + 4) += 8;
    }
    else
    {
      llvm::raw_ostream::write(v40, " done. \n", 8uLL);
    }
    *(_OWORD *)a1 = *(_OWORD *)a6;
    *(void *)(a1 + 16) = *(void *)(a6 + 16);
    *(void *)(a6 + 8) = 0;
    *(void *)(a6 + 16) = 0;
    *(void *)a6 = 0;
  }
  llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)&v42);
}

void sub_1CBFE7AFC(void **this)
{
  *this = &unk_1F2602D30;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }

  llvm::Pass::~Pass((llvm::Pass *)this);
}

void sub_1CBFE7B5C(void **this)
{
  *this = &unk_1F2602D30;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }
  llvm::Pass::~Pass((llvm::Pass *)this);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CBFE7BD0(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
  sub_1CB843600(a2, a2, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
}

uint64_t sub_1CBFE7BE8(void *a1, uint64_t ***a2)
{
  uint64_t v4 = (uint64_t *)a1[1];
  uint64_t v5 = *v4;
  uint64_t v6 = v4[1];
  if (v5 == v6)
  {
LABEL_4:
    uint64_t v7 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v5 != &llvm::DominatorTreeWrapperPass::ID)
    {
      v5 += 16;
      if (v5 == v6) {
        goto LABEL_4;
      }
    }
    uint64_t v7 = *(void *)(v5 + 8);
  }
  uint64_t v8 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v7 + 96))(v7, &llvm::DominatorTreeWrapperPass::ID);
  if ((*(unsigned int (**)(void *, uint64_t ***, uint64_t))(*a1 + 144))(a1, a2, v8))
  {
    uint64_t v40 = v8 + 32;
    v31.__r_.__value_.__s.__data_[21] = 0;
    HIWORD(v31.__r_.__value_.__r.__words[2]) = 5120;
    strcpy((char *)&v31, "Dominator tree for '");
    if ((*((unsigned char *)a2 + 23) & 0x10) == 0)
    {
      size_t v19 = 0;
      HIBYTE(v37) = 0;
      p_dst = (void **)&__dst;
      goto LABEL_24;
    }
    uint64_t v10 = ***a2;
    uint64_t v11 = *(void *)(v10 + 152);
    uint64_t v12 = *(unsigned int *)(v10 + 168);
    if (v12)
    {
      LODWORD(v13) = (v12 - 1) & ((a2 >> 4) ^ (a2 >> 9));
      unsigned int v14 = (uint64_t ****)(v11 + 16 * v13);
      int v15 = *v14;
      if (*v14 == a2)
      {
LABEL_16:
        unint64_t v18 = (unint64_t *)v14[1];
        unint64_t v21 = *v18;
        uint64_t v20 = v18 + 2;
        size_t v19 = v21;
        if (v21 >= 0x7FFFFFFFFFFFFFF8) {
          abort();
        }
        if (v19 >= 0x17)
        {
          uint64_t v23 = (v19 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v19 | 7) != 0x17) {
            uint64_t v23 = v19 | 7;
          }
          uint64_t v24 = v23 + 1;
          p_dst = (void **)operator new(v23 + 1);
          std::string::size_type v36 = v19;
          int64_t v37 = v24 | 0x8000000000000000;
          long long __dst = p_dst;
        }
        else
        {
          HIBYTE(v37) = v19;
          p_dst = (void **)&__dst;
          if (!v19) {
            goto LABEL_24;
          }
        }
        memmove(p_dst, v20, v19);
LABEL_24:
        *((unsigned char *)p_dst + v19) = 0;
        if (v37 >= 0) {
          BOOL v25 = (const std::string::value_type *)&__dst;
        }
        else {
          BOOL v25 = (const std::string::value_type *)__dst;
        }
        if (v37 >= 0) {
          std::string::size_type v26 = HIBYTE(v37) & 0x7F;
        }
        else {
          std::string::size_type v26 = v36;
        }
        size_t v27 = std::string::append(&v31, v25, v26);
        std::string::size_type v28 = v27->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v33.__r_.__value_.__l.__data_ = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
        v33.__r_.__value_.__r.__words[2] = v28;
        v27->__r_.__value_.__l.__size_ = 0;
        v27->__r_.__value_.__r.__words[2] = 0;
        v27->__r_.__value_.__r.__words[0] = 0;
        size_t v29 = std::string::append(&v33, "' function");
        std::string::size_type v30 = v29->__r_.__value_.__r.__words[2];
        long long v38 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
        std::string::size_type v39 = v30;
        v29->__r_.__value_.__l.__size_ = 0;
        v29->__r_.__value_.__r.__words[2] = 0;
        v29->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v33.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v37) < 0) {
          operator delete(__dst);
        }
        if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v31.__r_.__value_.__l.__data_);
        }
        __int16 v34 = 260;
        v33.__r_.__value_.__r.__words[0] = (std::string::size_type)(a1 + 4);
        __int16 v32 = 260;
        v31.__r_.__value_.__r.__words[0] = (std::string::size_type)&v38;
        sub_1CD48500C((llvm::raw_ostream *)&v40, (llvm::Twine *)&v33, 1, (llvm::Twine *)&v31);
        if (SHIBYTE(v39) < 0) {
          operator delete((void *)v38);
        }
        return 0;
      }
      int v16 = 1;
      while (v15 != (uint64_t ***)-4096)
      {
        int v17 = v13 + v16++;
        uint64_t v13 = v17 & (v12 - 1);
        int v15 = *(uint64_t ****)(v11 + 16 * v13);
        if (v15 == a2)
        {
          unsigned int v14 = (uint64_t ****)(v11 + 16 * v13);
          goto LABEL_16;
        }
      }
    }
    unsigned int v14 = (uint64_t ****)(v11 + 16 * v12);
    goto LABEL_16;
  }
  return 0;
}

uint64_t sub_1CBFE7EEC()
{
  return 1;
}

void sub_1CBFE7EF4(void **this)
{
  *this = &unk_1F2602D30;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }

  llvm::Pass::~Pass((llvm::Pass *)this);
}

void sub_1CBFE7F54(void **this)
{
  *this = &unk_1F2602D30;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }
  llvm::Pass::~Pass((llvm::Pass *)this);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CBFE7FC8(void **this)
{
  *this = &unk_1F2602E80;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }

  llvm::Pass::~Pass((llvm::Pass *)this);
}

void sub_1CBFE8028(void **this)
{
  *this = &unk_1F2602E80;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }
  llvm::Pass::~Pass((llvm::Pass *)this);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CBFE809C(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
  sub_1CB843600(a2, a2, (uint64_t)&llvm::PostDominatorTreeWrapperPass::ID);
}

uint64_t sub_1CBFE80B4(uint64_t a1, uint64_t ***a2)
{
  uint64_t v4 = *(uint64_t **)(a1 + 8);
  uint64_t v5 = *v4;
  uint64_t v6 = v4[1];
  if (v5 == v6)
  {
LABEL_4:
    uint64_t v7 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v5 != &llvm::PostDominatorTreeWrapperPass::ID)
    {
      v5 += 16;
      if (v5 == v6) {
        goto LABEL_4;
      }
    }
    uint64_t v7 = *(void *)(v5 + 8);
  }
  uint64_t v8 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v7 + 96))(v7, &llvm::PostDominatorTreeWrapperPass::ID);
  if ((*(unsigned int (**)(uint64_t, uint64_t ***, uint64_t))(*(void *)a1 + 144))(a1, a2, v8))
  {
    uint64_t v87 = v8 + 32;
    char v10 = *(unsigned char *)(a1 + 55);
    int v11 = v10;
    size_t v12 = v10 & 0x7F;
    if (v11 >= 0) {
      size_t v13 = v12;
    }
    else {
      size_t v13 = *(void *)(a1 + 40);
    }
    p_p = &__p;
    sub_1CB907098((uint64_t)&__p, v13 + 1);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if (v13)
    {
      int v17 = *(char **)(a1 + 32);
      int v16 = (char *)(a1 + 32);
      int v15 = v17;
      if (v16[23] >= 0) {
        unint64_t v18 = v16;
      }
      else {
        unint64_t v18 = v15;
      }
      memmove(p_p, v18, v13);
    }
    *(_WORD *)((char *)&p_p->__r_.__value_.__l.__data_ + v13) = 46;
    unsigned int v19 = a2 >> 4;
    if ((*((unsigned char *)a2 + 23) & 0x10) == 0)
    {
      size_t v29 = 0;
      HIBYTE(v84) = 0;
      p_dst = &__dst;
      goto LABEL_34;
    }
    uint64_t v20 = ***a2;
    uint64_t v21 = *(void *)(v20 + 152);
    uint64_t v22 = *(unsigned int *)(v20 + 168);
    if (v22)
    {
      LODWORD(v23) = (v22 - 1) & (v19 ^ (a2 >> 9));
      uint64_t v24 = (uint64_t ****)(v21 + 16 * v23);
      BOOL v25 = *v24;
      if (*v24 == a2) {
        goto LABEL_26;
      }
      int v26 = 1;
      while (v25 != (uint64_t ***)-4096)
      {
        int v27 = v23 + v26++;
        uint64_t v23 = v27 & (v22 - 1);
        BOOL v25 = *(uint64_t ****)(v21 + 16 * v23);
        if (v25 == a2)
        {
          uint64_t v24 = (uint64_t ****)(v21 + 16 * v23);
          goto LABEL_26;
        }
      }
    }
    uint64_t v24 = (uint64_t ****)(v21 + 16 * v22);
LABEL_26:
    std::string::size_type v28 = (unint64_t *)v24[1];
    unint64_t v31 = *v28;
    std::string::size_type v30 = v28 + 2;
    size_t v29 = v31;
    if (v31 > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_106;
    }
    if (v29 >= 0x17)
    {
      uint64_t v33 = (v29 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v29 | 7) != 0x17) {
        uint64_t v33 = v29 | 7;
      }
      uint64_t v34 = v33 + 1;
      p_dst = (long long *)operator new(v33 + 1);
      *((void *)&__dst + sub_1CD456CB4((void *)this + 1) = v29;
      int64_t v84 = v34 | 0x8000000000000000;
      *(void *)&long long __dst = p_dst;
    }
    else
    {
      HIBYTE(v84) = v29;
      p_dst = &__dst;
      if (!v29)
      {
LABEL_34:
        *((unsigned char *)p_dst + v29) = 0;
        if (v84 >= 0) {
          size_t v35 = (const std::string::value_type *)&__dst;
        }
        else {
          size_t v35 = (const std::string::value_type *)__dst;
        }
        if (v84 >= 0) {
          std::string::size_type v36 = HIBYTE(v84) & 0x7F;
        }
        else {
          std::string::size_type v36 = *((void *)&__dst + 1);
        }
        int64_t v37 = std::string::append(&__p, v35, v36);
        std::string::size_type v38 = v37->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v81.__r_.__value_.__l.__data_ = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
        v81.__r_.__value_.__r.__words[2] = v38;
        v37->__r_.__value_.__l.__size_ = 0;
        v37->__r_.__value_.__r.__words[2] = 0;
        v37->__r_.__value_.__r.__words[0] = 0;
        std::string::size_type v39 = std::string::append(&v81, ".dot");
        std::string::size_type v40 = v39->__r_.__value_.__r.__words[2];
        long long v85 = *(_OWORD *)&v39->__r_.__value_.__l.__data_;
        uint64_t v86 = v40;
        v39->__r_.__value_.__l.__size_ = 0;
        v39->__r_.__value_.__r.__words[2] = 0;
        v39->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v81.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v81.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v84) < 0) {
          operator delete((void *)__dst);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        v82[0] = 0;
        uint64_t v41 = (llvm *)std::system_category();
        uint64_t v42 = (llvm::raw_ostream *)llvm::errs(v41);
        uint64_t v43 = *((void *)v42 + 4);
        if ((unint64_t)(*((void *)v42 + 3) - v43) > 8)
        {
          *(unsigned char *)(v43 + 8) = 39;
          *(void *)uint64_t v43 = *(void *)"Writing '";
          *((void *)v42 + 4) += 9;
        }
        else
        {
          uint64_t v42 = llvm::raw_ostream::write(v42, "Writing '", 9uLL);
        }
        if (v86 >= 0) {
          __int16 v44 = (const char *)&v85;
        }
        else {
          __int16 v44 = (const char *)v85;
        }
        if (v86 >= 0) {
          size_t v45 = HIBYTE(v86) & 0x7F;
        }
        else {
          size_t v45 = *((void *)&v85 + 1);
        }
        char v46 = llvm::raw_ostream::write(v42, v44, v45);
        long long v47 = (_DWORD *)*((void *)v46 + 4);
        if (*((void *)v46 + 3) - (void)v47 > 3uLL)
        {
          _DWORD *v47 = 774778407;
          *((void *)v46 + 4) += 4;
        }
        else
        {
          llvm::raw_ostream::write(v46, "'...", 4uLL);
        }
        if (v86 >= 0) {
          uint64_t v48 = &v85;
        }
        else {
          uint64_t v48 = (long long *)v85;
        }
        if (v86 >= 0) {
          uint64_t v49 = HIBYTE(v86) & 0x7F;
        }
        else {
          uint64_t v49 = *((void *)&v85 + 1);
        }
        llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)&v81, v48, v49, (uint64_t)v82, 3);
        v80.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x20uLL);
        *(_OWORD *)&v80.__r_.__value_.__r.__words[1] = xmmword_1CD91A400;
        strcpy(v80.__r_.__value_.__l.__data_, "Post dominator tree for '");
        if ((*((unsigned char *)a2 + 23) & 0x10) == 0)
        {
          size_t v59 = 0;
          HIBYTE(v79) = 0;
          uint64_t v62 = &v77;
          goto LABEL_78;
        }
        uint64_t v50 = ***a2;
        uint64_t v51 = *(void *)(v50 + 152);
        uint64_t v52 = *(unsigned int *)(v50 + 168);
        if (v52)
        {
          LODWORD(v53) = (v52 - 1) & (v19 ^ (a2 >> 9));
          uint64_t v54 = (uint64_t ****)(v51 + 16 * v53);
          uint64_t v55 = *v54;
          if (*v54 == a2) {
            goto LABEL_70;
          }
          int v56 = 1;
          while (v55 != (uint64_t ***)-4096)
          {
            int v57 = v53 + v56++;
            uint64_t v53 = v57 & (v52 - 1);
            uint64_t v55 = *(uint64_t ****)(v51 + 16 * v53);
            if (v55 == a2)
            {
              uint64_t v54 = (uint64_t ****)(v51 + 16 * v53);
              goto LABEL_70;
            }
          }
        }
        uint64_t v54 = (uint64_t ****)(v51 + 16 * v52);
LABEL_70:
        uint64_t v58 = (unint64_t *)v54[1];
        unint64_t v61 = *v58;
        uint64_t v60 = v58 + 2;
        size_t v59 = v61;
        if (v61 <= 0x7FFFFFFFFFFFFFF7)
        {
          if (v59 >= 0x17)
          {
            uint64_t v63 = (v59 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v59 | 7) != 0x17) {
              uint64_t v63 = v59 | 7;
            }
            uint64_t v64 = v63 + 1;
            uint64_t v62 = operator new(v63 + 1);
            std::string::size_type v78 = v59;
            int64_t v79 = v64 | 0x8000000000000000;
            unsigned int v77 = v62;
          }
          else
          {
            HIBYTE(v79) = v59;
            uint64_t v62 = &v77;
            if (!v59) {
              goto LABEL_78;
            }
          }
          memmove(v62, v60, v59);
LABEL_78:
          *((unsigned char *)v62 + v59) = 0;
          if (v79 >= 0) {
            uint64_t v65 = (const std::string::value_type *)&v77;
          }
          else {
            uint64_t v65 = (const std::string::value_type *)v77;
          }
          if (v79 >= 0) {
            std::string::size_type v66 = HIBYTE(v79) & 0x7F;
          }
          else {
            std::string::size_type v66 = v78;
          }
          int v67 = std::string::append(&v80, v65, v66);
          std::string::size_type v68 = v67->__r_.__value_.__r.__words[2];
          *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v67->__r_.__value_.__l.__data_;
          __p.__r_.__value_.__r.__words[2] = v68;
          v67->__r_.__value_.__l.__size_ = 0;
          v67->__r_.__value_.__r.__words[2] = 0;
          v67->__r_.__value_.__r.__words[0] = 0;
          unsigned int v69 = std::string::append(&__p, "' function");
          int64_t v70 = v69->__r_.__value_.__r.__words[2];
          long long __dst = *(_OWORD *)&v69->__r_.__value_.__l.__data_;
          int64_t v84 = v70;
          v69->__r_.__value_.__l.__size_ = 0;
          v69->__r_.__value_.__r.__words[2] = 0;
          v69->__r_.__value_.__r.__words[0] = 0;
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v79) < 0) {
            operator delete(v77);
          }
          if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v80.__r_.__value_.__l.__data_);
          }
          if (v82[0])
          {
            int v71 = (llvm::raw_ostream *)llvm::errs((llvm *)v69);
            uint64_t v72 = (void *)*((void *)v71 + 4);
            if (*((void *)v71 + 3) - (void)v72 > 0x20uLL)
            {
              qmemcpy(v72, "  error opening file for writing!", 33);
              *((void *)v71 + 4) += 33;
            }
            else
            {
              int v71 = llvm::raw_ostream::write(v71, "  error opening file for writing!", 0x21uLL);
            }
          }
          else
          {
            __int16 v76 = 260;
            __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&__dst;
            int v71 = sub_1CD4850A4((llvm::raw_ostream *)&v81, (llvm::raw_ostream *)&v87, 0, (llvm::Twine *)&__p);
          }
          int8x8_t v73 = (llvm::raw_ostream *)llvm::errs(v71);
          uint64_t v74 = (unsigned char *)*((void *)v73 + 4);
          if (*((unsigned char **)v73 + 3) == v74)
          {
            llvm::raw_ostream::write(v73, "\n", 1uLL);
          }
          else
          {
            *uint64_t v74 = 10;
            ++*((void *)v73 + 4);
          }
          if (SHIBYTE(v84) < 0) {
            operator delete((void *)__dst);
          }
          llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)&v81);
          if (SHIBYTE(v86) < 0) {
            operator delete((void *)v85);
          }
          return 0;
        }
LABEL_106:
        abort();
      }
    }
    memmove(p_dst, v30, v29);
    goto LABEL_34;
  }
  return 0;
}

uint64_t sub_1CBFE873C()
{
  return 1;
}

void sub_1CBFE8744(void **this)
{
  *this = &unk_1F2602E80;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }

  llvm::Pass::~Pass((llvm::Pass *)this);
}

void sub_1CBFE87A4(void **this)
{
  *this = &unk_1F2602E80;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }
  llvm::Pass::~Pass((llvm::Pass *)this);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CBFE8818(void **this)
{
  *this = &unk_1F2602FD0;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }

  llvm::Pass::~Pass((llvm::Pass *)this);
}

void sub_1CBFE8878(void **this)
{
  *this = &unk_1F2602FD0;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }
  llvm::Pass::~Pass((llvm::Pass *)this);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CBFE88EC(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
  sub_1CB843600(a2, a2, (uint64_t)&llvm::PostDominatorTreeWrapperPass::ID);
}

uint64_t sub_1CBFE8904(uint64_t a1, uint64_t ***a2)
{
  uint64_t v4 = *(uint64_t **)(a1 + 8);
  uint64_t v5 = *v4;
  uint64_t v6 = v4[1];
  if (v5 == v6)
  {
LABEL_4:
    uint64_t v7 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v5 != &llvm::PostDominatorTreeWrapperPass::ID)
    {
      v5 += 16;
      if (v5 == v6) {
        goto LABEL_4;
      }
    }
    uint64_t v7 = *(void *)(v5 + 8);
  }
  uint64_t v8 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v7 + 96))(v7, &llvm::PostDominatorTreeWrapperPass::ID);
  if ((*(unsigned int (**)(uint64_t, uint64_t ***, uint64_t))(*(void *)a1 + 144))(a1, a2, v8))
  {
    uint64_t v87 = v8 + 32;
    char v10 = *(unsigned char *)(a1 + 55);
    int v11 = v10;
    size_t v12 = v10 & 0x7F;
    if (v11 >= 0) {
      size_t v13 = v12;
    }
    else {
      size_t v13 = *(void *)(a1 + 40);
    }
    p_p = &__p;
    sub_1CB907098((uint64_t)&__p, v13 + 1);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if (v13)
    {
      int v17 = *(char **)(a1 + 32);
      int v16 = (char *)(a1 + 32);
      int v15 = v17;
      if (v16[23] >= 0) {
        unint64_t v18 = v16;
      }
      else {
        unint64_t v18 = v15;
      }
      memmove(p_p, v18, v13);
    }
    *(_WORD *)((char *)&p_p->__r_.__value_.__l.__data_ + v13) = 46;
    unsigned int v19 = a2 >> 4;
    if ((*((unsigned char *)a2 + 23) & 0x10) == 0)
    {
      size_t v29 = 0;
      HIBYTE(v84) = 0;
      p_dst = &__dst;
      goto LABEL_34;
    }
    uint64_t v20 = ***a2;
    uint64_t v21 = *(void *)(v20 + 152);
    uint64_t v22 = *(unsigned int *)(v20 + 168);
    if (v22)
    {
      LODWORD(v23) = (v22 - 1) & (v19 ^ (a2 >> 9));
      uint64_t v24 = (uint64_t ****)(v21 + 16 * v23);
      BOOL v25 = *v24;
      if (*v24 == a2) {
        goto LABEL_26;
      }
      int v26 = 1;
      while (v25 != (uint64_t ***)-4096)
      {
        int v27 = v23 + v26++;
        uint64_t v23 = v27 & (v22 - 1);
        BOOL v25 = *(uint64_t ****)(v21 + 16 * v23);
        if (v25 == a2)
        {
          uint64_t v24 = (uint64_t ****)(v21 + 16 * v23);
          goto LABEL_26;
        }
      }
    }
    uint64_t v24 = (uint64_t ****)(v21 + 16 * v22);
LABEL_26:
    std::string::size_type v28 = (unint64_t *)v24[1];
    unint64_t v31 = *v28;
    std::string::size_type v30 = v28 + 2;
    size_t v29 = v31;
    if (v31 > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_106;
    }
    if (v29 >= 0x17)
    {
      uint64_t v33 = (v29 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v29 | 7) != 0x17) {
        uint64_t v33 = v29 | 7;
      }
      uint64_t v34 = v33 + 1;
      p_dst = (long long *)operator new(v33 + 1);
      *((void *)&__dst + sub_1CD456CB4((void *)this + 1) = v29;
      int64_t v84 = v34 | 0x8000000000000000;
      *(void *)&long long __dst = p_dst;
    }
    else
    {
      HIBYTE(v84) = v29;
      p_dst = &__dst;
      if (!v29)
      {
LABEL_34:
        *((unsigned char *)p_dst + v29) = 0;
        if (v84 >= 0) {
          size_t v35 = (const std::string::value_type *)&__dst;
        }
        else {
          size_t v35 = (const std::string::value_type *)__dst;
        }
        if (v84 >= 0) {
          std::string::size_type v36 = HIBYTE(v84) & 0x7F;
        }
        else {
          std::string::size_type v36 = *((void *)&__dst + 1);
        }
        int64_t v37 = std::string::append(&__p, v35, v36);
        std::string::size_type v38 = v37->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v81.__r_.__value_.__l.__data_ = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
        v81.__r_.__value_.__r.__words[2] = v38;
        v37->__r_.__value_.__l.__size_ = 0;
        v37->__r_.__value_.__r.__words[2] = 0;
        v37->__r_.__value_.__r.__words[0] = 0;
        std::string::size_type v39 = std::string::append(&v81, ".dot");
        std::string::size_type v40 = v39->__r_.__value_.__r.__words[2];
        long long v85 = *(_OWORD *)&v39->__r_.__value_.__l.__data_;
        uint64_t v86 = v40;
        v39->__r_.__value_.__l.__size_ = 0;
        v39->__r_.__value_.__r.__words[2] = 0;
        v39->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v81.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v81.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v84) < 0) {
          operator delete((void *)__dst);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        v82[0] = 0;
        uint64_t v41 = (llvm *)std::system_category();
        uint64_t v42 = (llvm::raw_ostream *)llvm::errs(v41);
        uint64_t v43 = *((void *)v42 + 4);
        if ((unint64_t)(*((void *)v42 + 3) - v43) > 8)
        {
          *(unsigned char *)(v43 + 8) = 39;
          *(void *)uint64_t v43 = *(void *)"Writing '";
          *((void *)v42 + 4) += 9;
        }
        else
        {
          uint64_t v42 = llvm::raw_ostream::write(v42, "Writing '", 9uLL);
        }
        if (v86 >= 0) {
          __int16 v44 = (const char *)&v85;
        }
        else {
          __int16 v44 = (const char *)v85;
        }
        if (v86 >= 0) {
          size_t v45 = HIBYTE(v86) & 0x7F;
        }
        else {
          size_t v45 = *((void *)&v85 + 1);
        }
        char v46 = llvm::raw_ostream::write(v42, v44, v45);
        long long v47 = (_DWORD *)*((void *)v46 + 4);
        if (*((void *)v46 + 3) - (void)v47 > 3uLL)
        {
          _DWORD *v47 = 774778407;
          *((void *)v46 + 4) += 4;
        }
        else
        {
          llvm::raw_ostream::write(v46, "'...", 4uLL);
        }
        if (v86 >= 0) {
          uint64_t v48 = &v85;
        }
        else {
          uint64_t v48 = (long long *)v85;
        }
        if (v86 >= 0) {
          uint64_t v49 = HIBYTE(v86) & 0x7F;
        }
        else {
          uint64_t v49 = *((void *)&v85 + 1);
        }
        llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)&v81, v48, v49, (uint64_t)v82, 3);
        v80.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x20uLL);
        *(_OWORD *)&v80.__r_.__value_.__r.__words[1] = xmmword_1CD91A400;
        strcpy(v80.__r_.__value_.__l.__data_, "Post dominator tree for '");
        if ((*((unsigned char *)a2 + 23) & 0x10) == 0)
        {
          size_t v59 = 0;
          HIBYTE(v79) = 0;
          uint64_t v62 = &v77;
          goto LABEL_78;
        }
        uint64_t v50 = ***a2;
        uint64_t v51 = *(void *)(v50 + 152);
        uint64_t v52 = *(unsigned int *)(v50 + 168);
        if (v52)
        {
          LODWORD(v53) = (v52 - 1) & (v19 ^ (a2 >> 9));
          uint64_t v54 = (uint64_t ****)(v51 + 16 * v53);
          uint64_t v55 = *v54;
          if (*v54 == a2) {
            goto LABEL_70;
          }
          int v56 = 1;
          while (v55 != (uint64_t ***)-4096)
          {
            int v57 = v53 + v56++;
            uint64_t v53 = v57 & (v52 - 1);
            uint64_t v55 = *(uint64_t ****)(v51 + 16 * v53);
            if (v55 == a2)
            {
              uint64_t v54 = (uint64_t ****)(v51 + 16 * v53);
              goto LABEL_70;
            }
          }
        }
        uint64_t v54 = (uint64_t ****)(v51 + 16 * v52);
LABEL_70:
        uint64_t v58 = (unint64_t *)v54[1];
        unint64_t v61 = *v58;
        uint64_t v60 = v58 + 2;
        size_t v59 = v61;
        if (v61 <= 0x7FFFFFFFFFFFFFF7)
        {
          if (v59 >= 0x17)
          {
            uint64_t v63 = (v59 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v59 | 7) != 0x17) {
              uint64_t v63 = v59 | 7;
            }
            uint64_t v64 = v63 + 1;
            uint64_t v62 = operator new(v63 + 1);
            std::string::size_type v78 = v59;
            int64_t v79 = v64 | 0x8000000000000000;
            unsigned int v77 = v62;
          }
          else
          {
            HIBYTE(v79) = v59;
            uint64_t v62 = &v77;
            if (!v59) {
              goto LABEL_78;
            }
          }
          memmove(v62, v60, v59);
LABEL_78:
          *((unsigned char *)v62 + v59) = 0;
          if (v79 >= 0) {
            uint64_t v65 = (const std::string::value_type *)&v77;
          }
          else {
            uint64_t v65 = (const std::string::value_type *)v77;
          }
          if (v79 >= 0) {
            std::string::size_type v66 = HIBYTE(v79) & 0x7F;
          }
          else {
            std::string::size_type v66 = v78;
          }
          int v67 = std::string::append(&v80, v65, v66);
          std::string::size_type v68 = v67->__r_.__value_.__r.__words[2];
          *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v67->__r_.__value_.__l.__data_;
          __p.__r_.__value_.__r.__words[2] = v68;
          v67->__r_.__value_.__l.__size_ = 0;
          v67->__r_.__value_.__r.__words[2] = 0;
          v67->__r_.__value_.__r.__words[0] = 0;
          unsigned int v69 = std::string::append(&__p, "' function");
          int64_t v70 = v69->__r_.__value_.__r.__words[2];
          long long __dst = *(_OWORD *)&v69->__r_.__value_.__l.__data_;
          int64_t v84 = v70;
          v69->__r_.__value_.__l.__size_ = 0;
          v69->__r_.__value_.__r.__words[2] = 0;
          v69->__r_.__value_.__r.__words[0] = 0;
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v79) < 0) {
            operator delete(v77);
          }
          if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v80.__r_.__value_.__l.__data_);
          }
          if (v82[0])
          {
            int v71 = (llvm::raw_ostream *)llvm::errs((llvm *)v69);
            uint64_t v72 = (void *)*((void *)v71 + 4);
            if (*((void *)v71 + 3) - (void)v72 > 0x20uLL)
            {
              qmemcpy(v72, "  error opening file for writing!", 33);
              *((void *)v71 + 4) += 33;
            }
            else
            {
              int v71 = llvm::raw_ostream::write(v71, "  error opening file for writing!", 0x21uLL);
            }
          }
          else
          {
            __int16 v76 = 260;
            __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&__dst;
            int v71 = sub_1CD4850A4((llvm::raw_ostream *)&v81, (llvm::raw_ostream *)&v87, 1, (llvm::Twine *)&__p);
          }
          int8x8_t v73 = (llvm::raw_ostream *)llvm::errs(v71);
          uint64_t v74 = (unsigned char *)*((void *)v73 + 4);
          if (*((unsigned char **)v73 + 3) == v74)
          {
            llvm::raw_ostream::write(v73, "\n", 1uLL);
          }
          else
          {
            *uint64_t v74 = 10;
            ++*((void *)v73 + 4);
          }
          if (SHIBYTE(v84) < 0) {
            operator delete((void *)__dst);
          }
          llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)&v81);
          if (SHIBYTE(v86) < 0) {
            operator delete((void *)v85);
          }
          return 0;
        }
LABEL_106:
        abort();
      }
    }
    memmove(p_dst, v30, v29);
    goto LABEL_34;
  }
  return 0;
}

uint64_t sub_1CBFE8F8C()
{
  return 1;
}

void sub_1CBFE8F94(void **this)
{
  *this = &unk_1F2602FD0;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }

  llvm::Pass::~Pass((llvm::Pass *)this);
}

void sub_1CBFE8FF4(void **this)
{
  *this = &unk_1F2602FD0;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }
  llvm::Pass::~Pass((llvm::Pass *)this);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CBFE9068(void **this)
{
  *this = &unk_1F2603120;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }

  llvm::Pass::~Pass((llvm::Pass *)this);
}

void sub_1CBFE90C8(void **this)
{
  *this = &unk_1F2603120;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }
  llvm::Pass::~Pass((llvm::Pass *)this);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CBFE913C(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
  sub_1CB843600(a2, a2, (uint64_t)&llvm::PostDominatorTreeWrapperPass::ID);
}

uint64_t sub_1CBFE9154(void *a1, uint64_t ***a2)
{
  uint64_t v4 = (uint64_t *)a1[1];
  uint64_t v5 = *v4;
  uint64_t v6 = v4[1];
  if (v5 == v6)
  {
LABEL_4:
    uint64_t v7 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v5 != &llvm::PostDominatorTreeWrapperPass::ID)
    {
      v5 += 16;
      if (v5 == v6) {
        goto LABEL_4;
      }
    }
    uint64_t v7 = *(void *)(v5 + 8);
  }
  uint64_t v8 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v7 + 96))(v7, &llvm::PostDominatorTreeWrapperPass::ID);
  if ((*(unsigned int (**)(void *, uint64_t ***, uint64_t))(*a1 + 144))(a1, a2, v8))
  {
    uint64_t v40 = v8 + 32;
    v31.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x20uLL);
    *(_OWORD *)&v31.__r_.__value_.__r.__words[1] = xmmword_1CD91A400;
    strcpy(v31.__r_.__value_.__l.__data_, "Post dominator tree for '");
    if ((*((unsigned char *)a2 + 23) & 0x10) == 0)
    {
      size_t v19 = 0;
      HIBYTE(v37) = 0;
      p_dst = (void **)&__dst;
      goto LABEL_24;
    }
    uint64_t v10 = ***a2;
    uint64_t v11 = *(void *)(v10 + 152);
    uint64_t v12 = *(unsigned int *)(v10 + 168);
    if (v12)
    {
      LODWORD(v13) = (v12 - 1) & ((a2 >> 4) ^ (a2 >> 9));
      unsigned int v14 = (uint64_t ****)(v11 + 16 * v13);
      int v15 = *v14;
      if (*v14 == a2)
      {
LABEL_16:
        unint64_t v18 = (unint64_t *)v14[1];
        unint64_t v21 = *v18;
        uint64_t v20 = v18 + 2;
        size_t v19 = v21;
        if (v21 >= 0x7FFFFFFFFFFFFFF8) {
          abort();
        }
        if (v19 >= 0x17)
        {
          uint64_t v23 = (v19 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v19 | 7) != 0x17) {
            uint64_t v23 = v19 | 7;
          }
          uint64_t v24 = v23 + 1;
          p_dst = (void **)operator new(v23 + 1);
          std::string::size_type v36 = v19;
          int64_t v37 = v24 | 0x8000000000000000;
          long long __dst = p_dst;
        }
        else
        {
          HIBYTE(v37) = v19;
          p_dst = (void **)&__dst;
          if (!v19) {
            goto LABEL_24;
          }
        }
        memmove(p_dst, v20, v19);
LABEL_24:
        *((unsigned char *)p_dst + v19) = 0;
        if (v37 >= 0) {
          BOOL v25 = (const std::string::value_type *)&__dst;
        }
        else {
          BOOL v25 = (const std::string::value_type *)__dst;
        }
        if (v37 >= 0) {
          std::string::size_type v26 = HIBYTE(v37) & 0x7F;
        }
        else {
          std::string::size_type v26 = v36;
        }
        int v27 = std::string::append(&v31, v25, v26);
        std::string::size_type v28 = v27->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v33.__r_.__value_.__l.__data_ = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
        v33.__r_.__value_.__r.__words[2] = v28;
        v27->__r_.__value_.__l.__size_ = 0;
        v27->__r_.__value_.__r.__words[2] = 0;
        v27->__r_.__value_.__r.__words[0] = 0;
        size_t v29 = std::string::append(&v33, "' function");
        std::string::size_type v30 = v29->__r_.__value_.__r.__words[2];
        long long v38 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
        std::string::size_type v39 = v30;
        v29->__r_.__value_.__l.__size_ = 0;
        v29->__r_.__value_.__r.__words[2] = 0;
        v29->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v33.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v37) < 0) {
          operator delete(__dst);
        }
        if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v31.__r_.__value_.__l.__data_);
        }
        __int16 v34 = 260;
        v33.__r_.__value_.__r.__words[0] = (std::string::size_type)(a1 + 4);
        __int16 v32 = 260;
        v31.__r_.__value_.__r.__words[0] = (std::string::size_type)&v38;
        sub_1CD48563C((llvm::raw_ostream *)&v40, (llvm::Twine *)&v33, 0, (llvm::Twine *)&v31);
        if (SHIBYTE(v39) < 0) {
          operator delete((void *)v38);
        }
        return 0;
      }
      int v16 = 1;
      while (v15 != (uint64_t ***)-4096)
      {
        int v17 = v13 + v16++;
        uint64_t v13 = v17 & (v12 - 1);
        int v15 = *(uint64_t ****)(v11 + 16 * v13);
        if (v15 == a2)
        {
          unsigned int v14 = (uint64_t ****)(v11 + 16 * v13);
          goto LABEL_16;
        }
      }
    }
    unsigned int v14 = (uint64_t ****)(v11 + 16 * v12);
    goto LABEL_16;
  }
  return 0;
}

uint64_t sub_1CBFE9468()
{
  return 1;
}

void sub_1CBFE9470(void **this)
{
  *this = &unk_1F2603120;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }

  llvm::Pass::~Pass((llvm::Pass *)this);
}

void sub_1CBFE94D0(void **this)
{
  *this = &unk_1F2603120;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }
  llvm::Pass::~Pass((llvm::Pass *)this);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CBFE9544(uint64_t a1, llvm::raw_ostream *a2, llvm::Twine *this, char a4, llvm::Twine *a5, uint64_t a6)
{
  if (*(char *)(a6 + 23) < 0) {
    uint64_t v11 = *(void *)(a6 + 8);
  }
  else {
    uint64_t v11 = *(unsigned __int8 *)(a6 + 23);
  }
  int v49 = 0;
  if (v11)
  {
    __int16 v44 = 260;
    uint64_t v42 = a6;
    *(void *)&long long v47 = llvm::sys::fs::openFile((unsigned __int8 *)&v42, &v49, 0, 2, 1, 438);
    *((void *)&v47 + sub_1CD456CB4((void *)this + 1) = v12;
    uint64_t v13 = std::generic_category();
    uint64_t v42 = 17;
    uint64_t v43 = v13;
    unsigned int v14 = (llvm *)(*(uint64_t (**)(void, void, uint64_t *))(**((void **)&v47 + 1) + 32))(*((void *)&v47 + 1), v47, &v42);
    if (v14
      || (unsigned int v14 = (llvm *)((uint64_t (*)(const std::error_category *, long long *, void))v43->equivalent_0)(v43, &v47, v42), v14))
    {
      uint64_t v20 = (llvm::raw_ostream *)llvm::errs(v14);
      unint64_t v21 = (void *)*((void *)v20 + 4);
      if (*((void *)v20 + 3) - (void)v21 > 0x17uLL)
      {
        qmemcpy(v21, "file exists, overwriting", 24);
        uint64_t v22 = (unsigned char *)(*((void *)v20 + 4) + 24);
        *((void *)v20 + 4) = v22;
      }
      else
      {
        uint64_t v20 = llvm::raw_ostream::write(v20, "file exists, overwriting", 0x18uLL);
        uint64_t v22 = (unsigned char *)*((void *)v20 + 4);
      }
      uint64_t v23 = (unsigned char *)*((void *)v20 + 3);
    }
    else
    {
      int v15 = v47;
      int v16 = (llvm::raw_ostream *)llvm::errs(v14);
      int v17 = (char *)*((void *)v16 + 4);
      unint64_t v18 = *((void *)v16 + 3) - (void)v17;
      if (v15)
      {
        if (v18 > 0x16)
        {
          qmemcpy(v17, "error writing into file", 23);
          size_t v19 = (unsigned char *)(*((void *)v16 + 4) + 23);
          *((void *)v16 + 4) = v19;
        }
        else
        {
          int v16 = llvm::raw_ostream::write(v16, "error writing into file", 0x17uLL);
          size_t v19 = (unsigned char *)*((void *)v16 + 4);
        }
        if (*((unsigned char **)v16 + 3) == v19)
        {
          llvm::raw_ostream::write(v16, "\n", 1uLL);
        }
        else
        {
          *size_t v19 = 10;
          ++*((void *)v16 + 4);
        }
        *(unsigned char *)(a1 + 23) = 0;
        *(unsigned char *)a1 = 0;
        return;
      }
      if (v18 > 0x21)
      {
        qmemcpy(v17, "writing to the newly created file ", 34);
        *((void *)v16 + 4) += 34;
      }
      else
      {
        int v16 = llvm::raw_ostream::write(v16, "writing to the newly created file ", 0x22uLL);
      }
      char v24 = *(unsigned char *)(a6 + 23);
      BOOL v25 = v24 < 0;
      if (v24 >= 0) {
        std::string::size_type v26 = (const char *)a6;
      }
      else {
        std::string::size_type v26 = *(const char **)a6;
      }
      size_t v27 = v24 & 0x7F;
      if (v25) {
        size_t v28 = *(void *)(a6 + 8);
      }
      else {
        size_t v28 = v27;
      }
      uint64_t v20 = llvm::raw_ostream::write(v16, v26, v28);
      uint64_t v23 = (unsigned char *)*((void *)v20 + 3);
      uint64_t v22 = (unsigned char *)*((void *)v20 + 4);
    }
    if (v23 == v22)
    {
      llvm::raw_ostream::write(v20, "\n", 1uLL);
    }
    else
    {
      *uint64_t v22 = 10;
      ++*((void *)v20 + 4);
    }
  }
  else
  {
    llvm::Twine::str(this, __p);
    __int16 v44 = 260;
    uint64_t v42 = (uint64_t)__p;
    llvm::createGraphFilename((llvm *)&v42, (const llvm::Twine *)&v49, (uint64_t)&v47);
    if (*(char *)(a6 + 23) < 0) {
      operator delete(*(void **)a6);
    }
    *(_OWORD *)a6 = v47;
    *(void *)(a6 + 16) = v48;
    HIBYTE(v48) = 0;
    LOBYTE(v47) = 0;
    if (v46 < 0) {
      operator delete(__p[0]);
    }
  }
  size_t v29 = (llvm *)llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)&v42, v49, 1, 0, 0);
  if (v49 == -1)
  {
    std::string::size_type v30 = (llvm::raw_ostream *)llvm::errs(v29);
    uint64_t v31 = *((void *)v30 + 4);
    if ((unint64_t)(*((void *)v30 + 3) - v31) > 0x13)
    {
      *(_DWORD *)(v31 + 16) = 656434540;
      *(_OWORD *)uint64_t v31 = *(_OWORD *)"error opening file '";
      *((void *)v30 + 4) += 20;
    }
    else
    {
      std::string::size_type v30 = llvm::raw_ostream::write(v30, "error opening file '", 0x14uLL);
    }
    char v32 = *(unsigned char *)(a6 + 23);
    BOOL v33 = v32 < 0;
    if (v32 >= 0) {
      __int16 v34 = (const char *)a6;
    }
    else {
      __int16 v34 = *(const char **)a6;
    }
    size_t v35 = v32 & 0x7F;
    if (v33) {
      size_t v36 = *(void *)(a6 + 8);
    }
    else {
      size_t v36 = v35;
    }
    int64_t v37 = llvm::raw_ostream::write(v30, v34, v36);
    long long v38 = (void *)*((void *)v37 + 4);
    if (*((void *)v37 + 3) - (void)v38 > 0xEuLL)
    {
      qmemcpy(v38, "' for writing!\n", 15);
      *((void *)v37 + 4) += 15;
    }
    else
    {
      llvm::raw_ostream::write(v37, "' for writing!\n", 0xFuLL);
    }
    *(unsigned char *)(a1 + 23) = 0;
    *(unsigned char *)a1 = 0;
  }
  else
  {
    std::string::size_type v39 = sub_1CD4850A4((llvm::raw_ostream *)&v42, a2, a4, a5);
    uint64_t v40 = (llvm::raw_ostream *)llvm::errs(v39);
    uint64_t v41 = (void *)*((void *)v40 + 4);
    if (*((void *)v40 + 3) - (void)v41 > 7uLL)
    {
      *uint64_t v41 = 0xA202E656E6F6420;
      *((void *)v40 + 4) += 8;
    }
    else
    {
      llvm::raw_ostream::write(v40, " done. \n", 8uLL);
    }
    *(_OWORD *)a1 = *(_OWORD *)a6;
    *(void *)(a1 + 16) = *(void *)(a6 + 16);
    *(void *)(a6 + 8) = 0;
    *(void *)(a6 + 16) = 0;
    *(void *)a6 = 0;
  }
  llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)&v42);
}

void sub_1CBFE9998(void **this)
{
  *this = &unk_1F2603270;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }

  llvm::Pass::~Pass((llvm::Pass *)this);
}

void sub_1CBFE99F8(void **this)
{
  *this = &unk_1F2603270;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }
  llvm::Pass::~Pass((llvm::Pass *)this);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CBFE9A6C(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
  sub_1CB843600(a2, a2, (uint64_t)&llvm::PostDominatorTreeWrapperPass::ID);
}

uint64_t sub_1CBFE9A84(void *a1, uint64_t ***a2)
{
  uint64_t v4 = (uint64_t *)a1[1];
  uint64_t v5 = *v4;
  uint64_t v6 = v4[1];
  if (v5 == v6)
  {
LABEL_4:
    uint64_t v7 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v5 != &llvm::PostDominatorTreeWrapperPass::ID)
    {
      v5 += 16;
      if (v5 == v6) {
        goto LABEL_4;
      }
    }
    uint64_t v7 = *(void *)(v5 + 8);
  }
  uint64_t v8 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v7 + 96))(v7, &llvm::PostDominatorTreeWrapperPass::ID);
  if ((*(unsigned int (**)(void *, uint64_t ***, uint64_t))(*a1 + 144))(a1, a2, v8))
  {
    uint64_t v40 = v8 + 32;
    v31.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x20uLL);
    *(_OWORD *)&v31.__r_.__value_.__r.__words[1] = xmmword_1CD91A400;
    strcpy(v31.__r_.__value_.__l.__data_, "Post dominator tree for '");
    if ((*((unsigned char *)a2 + 23) & 0x10) == 0)
    {
      size_t v19 = 0;
      HIBYTE(v37) = 0;
      p_dst = (void **)&__dst;
      goto LABEL_24;
    }
    uint64_t v10 = ***a2;
    uint64_t v11 = *(void *)(v10 + 152);
    uint64_t v12 = *(unsigned int *)(v10 + 168);
    if (v12)
    {
      LODWORD(v13) = (v12 - 1) & ((a2 >> 4) ^ (a2 >> 9));
      unsigned int v14 = (uint64_t ****)(v11 + 16 * v13);
      int v15 = *v14;
      if (*v14 == a2)
      {
LABEL_16:
        unint64_t v18 = (unint64_t *)v14[1];
        unint64_t v21 = *v18;
        uint64_t v20 = v18 + 2;
        size_t v19 = v21;
        if (v21 >= 0x7FFFFFFFFFFFFFF8) {
          abort();
        }
        if (v19 >= 0x17)
        {
          uint64_t v23 = (v19 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v19 | 7) != 0x17) {
            uint64_t v23 = v19 | 7;
          }
          uint64_t v24 = v23 + 1;
          p_dst = (void **)operator new(v23 + 1);
          std::string::size_type v36 = v19;
          int64_t v37 = v24 | 0x8000000000000000;
          long long __dst = p_dst;
        }
        else
        {
          HIBYTE(v37) = v19;
          p_dst = (void **)&__dst;
          if (!v19) {
            goto LABEL_24;
          }
        }
        memmove(p_dst, v20, v19);
LABEL_24:
        *((unsigned char *)p_dst + v19) = 0;
        if (v37 >= 0) {
          BOOL v25 = (const std::string::value_type *)&__dst;
        }
        else {
          BOOL v25 = (const std::string::value_type *)__dst;
        }
        if (v37 >= 0) {
          std::string::size_type v26 = HIBYTE(v37) & 0x7F;
        }
        else {
          std::string::size_type v26 = v36;
        }
        size_t v27 = std::string::append(&v31, v25, v26);
        std::string::size_type v28 = v27->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v33.__r_.__value_.__l.__data_ = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
        v33.__r_.__value_.__r.__words[2] = v28;
        v27->__r_.__value_.__l.__size_ = 0;
        v27->__r_.__value_.__r.__words[2] = 0;
        v27->__r_.__value_.__r.__words[0] = 0;
        size_t v29 = std::string::append(&v33, "' function");
        std::string::size_type v30 = v29->__r_.__value_.__r.__words[2];
        long long v38 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
        std::string::size_type v39 = v30;
        v29->__r_.__value_.__l.__size_ = 0;
        v29->__r_.__value_.__r.__words[2] = 0;
        v29->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v33.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v37) < 0) {
          operator delete(__dst);
        }
        if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v31.__r_.__value_.__l.__data_);
        }
        __int16 v34 = 260;
        v33.__r_.__value_.__r.__words[0] = (std::string::size_type)(a1 + 4);
        __int16 v32 = 260;
        v31.__r_.__value_.__r.__words[0] = (std::string::size_type)&v38;
        sub_1CD48563C((llvm::raw_ostream *)&v40, (llvm::Twine *)&v33, 1, (llvm::Twine *)&v31);
        if (SHIBYTE(v39) < 0) {
          operator delete((void *)v38);
        }
        return 0;
      }
      int v16 = 1;
      while (v15 != (uint64_t ***)-4096)
      {
        int v17 = v13 + v16++;
        uint64_t v13 = v17 & (v12 - 1);
        int v15 = *(uint64_t ****)(v11 + 16 * v13);
        if (v15 == a2)
        {
          unsigned int v14 = (uint64_t ****)(v11 + 16 * v13);
          goto LABEL_16;
        }
      }
    }
    unsigned int v14 = (uint64_t ****)(v11 + 16 * v12);
    goto LABEL_16;
  }
  return 0;
}

uint64_t sub_1CBFE9D98()
{
  return 1;
}

void sub_1CBFE9DA0(void **this)
{
  *this = &unk_1F2603270;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }

  llvm::Pass::~Pass((llvm::Pass *)this);
}

void sub_1CBFE9E00(void **this)
{
  *this = &unk_1F2603270;
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }
  llvm::Pass::~Pass((llvm::Pass *)this);

  JUMPOUT(0x1D25D9CE0);
}

BOOL llvm::DomTreeUpdater::isUpdateValid(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v4 = a3;
  uint64_t v5 = *(void *)(a2 + 40);
  if (v5 == a2 + 40 || (v5 ? (uint64_t v6 = (unsigned __int8 *)(v5 - 24)) : (uint64_t v6 = 0), v6[16] - 29 > 0xA))
  {
    unsigned int NumSuccessors = 0;
    goto LABEL_20;
  }
  unsigned int NumSuccessors = llvm::Instruction::getNumSuccessors((llvm::Instruction *)v6);
  if (!NumSuccessors)
  {
LABEL_20:
    unsigned int v8 = 0;
    goto LABEL_11;
  }
  unsigned int v8 = 0;
  unint64_t v9 = a3 & 0xFFFFFFFFFFFFFFF8;
  while (llvm::Instruction::getSuccessor((llvm::Instruction *)v6, v8) != v9)
  {
    if (NumSuccessors == ++v8)
    {
      unsigned int v8 = NumSuccessors;
      break;
    }
  }
LABEL_11:
  if ((v4 & 4) == 0 && v8 == NumSuccessors) {
    return 0;
  }
  return ((v4 >> 2) & 1) == 0 || v8 == NumSuccessors;
}

BOOL llvm::DomTreeUpdater::isSelfDominance(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a2 == (a3 & 0xFFFFFFFFFFFFFFF8);
}

uint64_t llvm::DomTreeUpdater::applyDomTreeUpdates(uint64_t this)
{
  v8[8] = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(this + 304) == 1)
  {
    uint64_t v1 = this;
    uint64_t v2 = *(void *)(this + 288);
    if (v2)
    {
      uint64_t v3 = *(unsigned int *)(this + 8);
      uint64_t v4 = *(void *)(this + 272);
      if (v3 != v4)
      {
        sub_1CBFEBC30((uint64_t)v5, (unint64_t *)(*(void *)this + 16 * v4), v3 - v4, 1u);
        llvm::DomTreeBuilder::ApplyUpdates<llvm::DominatorTreeBase<llvm::BasicBlock,false>>(v2, (uint64_t)v5, 0);
        if (v7 != v8) {
          free(v7);
        }
        sub_1CBFEECCC((uint64_t)&v6);
        this = sub_1CBFEECCC((uint64_t)v5);
        *(void *)(v1 + 272) = *(unsigned int *)(v1 + 8);
      }
    }
  }
  return this;
}

BOOL llvm::DomTreeUpdater::hasPendingDomTreeUpdates(llvm::DomTreeUpdater *this)
{
  return *((void *)this + 36) && *((void *)this + 34) != *((unsigned int *)this + 2);
}

uint64_t llvm::DomTreeUpdater::flush(llvm::DomTreeUpdater *this)
{
  v20[8] = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)this + 304) == 1)
  {
    uint64_t v3 = *((void *)this + 36);
    if (v3)
    {
      uint64_t v4 = *((unsigned int *)this + 2);
      uint64_t v5 = *((void *)this + 34);
      if (v4 != v5)
      {
        sub_1CBFEBC30((uint64_t)v17, (unint64_t *)(*(void *)this + 16 * v5), v4 - v5, 1u);
        llvm::DomTreeBuilder::ApplyUpdates<llvm::DominatorTreeBase<llvm::BasicBlock,false>>(v3, (uint64_t)v17, 0);
        if (v19 != v20) {
          free(v19);
        }
        sub_1CBFEECCC((uint64_t)&v18);
        sub_1CBFEECCC((uint64_t)v17);
        *((void *)this + 34) = *((unsigned int *)this + 2);
      }
    }
  }
  uint64_t result = llvm::DomTreeUpdater::applyPostDomTreeUpdates((uint64_t)this);
  if (*((unsigned char *)this + 304))
  {
    uint64_t v6 = *((void *)this + 36);
    if (!v6 || *((void *)this + 34) == *((_DWORD *)this + 2))
    {
      if (!*((void *)this + 37) || *((void *)this + 35) == *((_DWORD *)this + 2))
      {
        uint64_t result = llvm::DomTreeUpdater::forceFlushDeletedBB(this);
        uint64_t v6 = *((void *)this + 36);
      }
      if (!v6) {
        *((void *)this + 34) = *((unsigned int *)this + 2);
      }
    }
    if (*((void *)this + 37))
    {
      unint64_t v8 = *((void *)this + 35);
      unint64_t v7 = *((unsigned int *)this + 2);
    }
    else
    {
      unint64_t v7 = *((unsigned int *)this + 2);
      *((void *)this + 35) = v7;
      unint64_t v8 = v7;
    }
    unint64_t v9 = *((void *)this + 34);
    if (v8 >= v9) {
      unint64_t v10 = *((void *)this + 34);
    }
    else {
      unint64_t v10 = v8;
    }
    uint64_t v11 = *(void **)this;
    uint64_t v12 = (const void *)(*(void *)this + 16 * v10);
    size_t v13 = *(void *)this + 16 * v7 - (void)v12;
    if (v10 == v7)
    {
      uint64_t v14 = *(void *)this;
    }
    else
    {
      int v16 = *(void **)this;
      unint64_t v15 = v10;
      uint64_t result = (uint64_t)memmove(v11, v12, v13);
      unint64_t v10 = v15;
      uint64_t v11 = v16;
      uint64_t v14 = *(void *)this;
      unint64_t v9 = *((void *)this + 34);
      unint64_t v8 = *((void *)this + 35);
    }
    *((_DWORD *)this + 2) = ((unint64_t)v11 + v13 - v14) >> 4;
    *((void *)this + 34) = v9 - v10;
    *((void *)this + 35) = v8 - v10;
  }
  return result;
}

uint64_t llvm::DomTreeUpdater::applyPostDomTreeUpdates(uint64_t this)
{
  v5[85] = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(this + 304) == 1)
  {
    uint64_t v1 = *(void *)(this + 296);
    if (v1)
    {
      uint64_t v2 = *(unsigned int *)(this + 8);
      uint64_t v3 = *(void *)(this + 280);
      if (v2 != v3)
      {
        uint64_t v4 = this;
        sub_1CBFEEDA8((uint64_t)v5, (unint64_t *)(*(void *)this + 16 * v3), v2 - v3, 1u);
        llvm::DomTreeBuilder::ApplyUpdates<llvm::DominatorTreeBase<llvm::BasicBlock,true>>(v1, (uint64_t)v5, 0);
        this = sub_1CBFEF604((uint64_t)v5);
        *(void *)(v4 + 280) = *(unsigned int *)(v4 + 8);
      }
    }
  }
  return this;
}

uint64_t llvm::DomTreeUpdater::dropOutOfDateUpdates(uint64_t this)
{
  if (*(unsigned char *)(this + 304))
  {
    uint64_t v1 = this;
    uint64_t v2 = *(void *)(this + 288);
    if (!v2 || *(void *)(this + 272) == *(_DWORD *)(this + 8))
    {
      if (!*(void *)(this + 296) || *(void *)(this + 280) == *(_DWORD *)(this + 8))
      {
        this = llvm::DomTreeUpdater::forceFlushDeletedBB((llvm::DomTreeUpdater *)this);
        uint64_t v2 = *(void *)(v1 + 288);
      }
      if (!v2) {
        *(void *)(v1 + 272) = *(unsigned int *)(v1 + 8);
      }
    }
    if (*(void *)(v1 + 296))
    {
      unint64_t v4 = *(void *)(v1 + 280);
      unint64_t v3 = *(unsigned int *)(v1 + 8);
    }
    else
    {
      unint64_t v3 = *(unsigned int *)(v1 + 8);
      *(void *)(v1 + 280) = v3;
      unint64_t v4 = v3;
    }
    unint64_t v5 = *(void *)(v1 + 272);
    if (v4 >= v5) {
      unint64_t v6 = *(void *)(v1 + 272);
    }
    else {
      unint64_t v6 = v4;
    }
    unint64_t v7 = *(unsigned char **)v1;
    unint64_t v8 = (const void *)(*(void *)v1 + 16 * v6);
    size_t v9 = *(void *)v1 + 16 * v3 - (void)v8;
    if (v6 == v3)
    {
      unint64_t v10 = *(unsigned char **)v1;
    }
    else
    {
      size_t v12 = *(void *)v1 + 16 * v3 - (void)v8;
      size_t v13 = *(unsigned char **)v1;
      unint64_t v11 = v6;
      this = (uint64_t)memmove(v7, v8, v9);
      unint64_t v6 = v11;
      size_t v9 = v12;
      unint64_t v7 = v13;
      unint64_t v10 = *(unsigned char **)v1;
      unint64_t v5 = *(void *)(v1 + 272);
      unint64_t v4 = *(void *)(v1 + 280);
    }
    *(_DWORD *)(v1 + 8) = (unint64_t)(&v7[v9] - v10) >> 4;
    *(void *)(v1 + 272) = v5 - v6;
    *(void *)(v1 + 280) = v4 - v6;
  }
  return this;
}

BOOL llvm::DomTreeUpdater::hasPendingPostDomTreeUpdates(llvm::DomTreeUpdater *this)
{
  return *((void *)this + 37) && *((void *)this + 35) != *((unsigned int *)this + 2);
}

BOOL llvm::DomTreeUpdater::tryFlushDeletedBB(BOOL this)
{
  if ((!*(void *)(this + 288) || *(void *)(this + 272) == *(_DWORD *)(this + 8))
    && (!*(void *)(this + 296) || *(void *)(this + 280) == *(_DWORD *)(this + 8)))
  {
    return llvm::DomTreeUpdater::forceFlushDeletedBB((llvm::DomTreeUpdater *)this);
  }
  return this;
}

BOOL llvm::DomTreeUpdater::hasPendingUpdates(llvm::DomTreeUpdater *this)
{
  if (*((void *)this + 36) && *((void *)this + 34) != *((_DWORD *)this + 2)) {
    return 1;
  }
  if (*((void *)this + 37)) {
    return *((void *)this + 35) != *((unsigned int *)this + 2);
  }
  return 0;
}

BOOL llvm::DomTreeUpdater::forceFlushDeletedBB(llvm::DomTreeUpdater *this)
{
  int v1 = *((_DWORD *)this + 83);
  int v2 = *((_DWORD *)this + 84);
  if (v1 != v2)
  {
    unint64_t v4 = (llvm::BasicBlock **)*((void *)this + 40);
    unint64_t v5 = (llvm::BasicBlock **)*((void *)this + 39);
    uint64_t v6 = 328;
    if (v4 == v5) {
      uint64_t v6 = 332;
    }
    uint64_t v7 = *(unsigned int *)((char *)this + v6);
    unint64_t v8 = v4;
    if (v7)
    {
      uint64_t v9 = 0;
      while ((unint64_t)v4[v9] >= 0xFFFFFFFFFFFFFFFELL)
      {
        if (v7 == ++v9) {
          goto LABEL_19;
        }
      }
      unint64_t v8 = &v4[v9];
    }
    unint64_t v10 = &v4[v7];
    if (v8 != v10)
    {
      unint64_t v11 = *v8;
LABEL_12:
      llvm::BasicBlock::removeFromParent(v11);
      llvm::DomTreeUpdater::eraseDelBBNode((uint64_t)this, v11);
      if (v11)
      {
        llvm::BasicBlock::~BasicBlock((llvm::Type ***)v11, v12);
        MEMORY[0x1D25D9CE0]();
      }
      size_t v13 = (unint64_t *)(v8 + 1);
      while (v13 != (unint64_t *)v10)
      {
        unint64_t v14 = *v13++;
        unint64_t v11 = (llvm::BasicBlock *)v14;
        if (v14 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          unint64_t v8 = (llvm::BasicBlock **)(v13 - 1);
          goto LABEL_12;
        }
      }
      unint64_t v5 = (llvm::BasicBlock **)*((void *)this + 39);
      unint64_t v4 = (llvm::BasicBlock **)*((void *)this + 40);
    }
LABEL_19:
    if (v4 != v5)
    {
      uint64_t v18 = *((unsigned int *)this + 82);
      if (v18 >= 0x21 && 4 * (*((_DWORD *)this + 83) - *((_DWORD *)this + 84)) < v18)
      {
        llvm::SmallPtrSetImplBase::shrink_and_clear((void **)this + 39);
LABEL_21:
        int v16 = (void *)*((void *)this + 51);
        for (uint64_t i = (void *)*((void *)this + 52); i != v16; uint64_t i = sub_1CD486098(i - 9))
          ;
        *((void *)this + 52) = v16;
        return v1 != v2;
      }
      memset(v4, 255, 8 * v18);
    }
    *(void *)((char *)this + 332) = 0;
    goto LABEL_21;
  }
  return v1 != v2;
}

uint64_t llvm::DomTreeUpdater::eraseDelBBNode(uint64_t this, llvm::BasicBlock *a2)
{
  uint64_t v2 = *(void *)(this + 288);
  if (!v2 || *(unsigned char *)(this + 432)) {
    goto LABEL_6;
  }
  uint64_t v3 = *(void *)(v2 + 24);
  uint64_t v4 = *(unsigned int *)(v2 + 40);
  if (!v4) {
    goto LABEL_12;
  }
  LODWORD(v5) = (v4 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v6 = v3 + 16 * v5;
  uint64_t v7 = *(llvm::BasicBlock **)v6;
  if (*(llvm::BasicBlock **)v6 != a2)
  {
    int v9 = 1;
    while (v7 != (llvm::BasicBlock *)-4096)
    {
      int v10 = v5 + v9++;
      uint64_t v5 = v10 & (v4 - 1);
      uint64_t v7 = *(llvm::BasicBlock **)(v3 + 16 * v5);
      if (v7 == a2)
      {
        uint64_t v6 = v3 + 16 * v5;
        goto LABEL_5;
      }
    }
LABEL_12:
    uint64_t v6 = v3 + 16 * v4;
  }
LABEL_5:
  if (v6 != v3 + 16 * v4 && *(void *)(v6 + 8)) {
    llvm::DominatorTreeBase<llvm::BasicBlock,false>::eraseNode();
  }
LABEL_6:
  uint64_t v8 = *(void *)(this + 296);
  if (v8 && !*(unsigned char *)(this + 433))
  {
    uint64_t v14 = *(void *)(this + 296);
    uint64_t v15 = 0;
    int v16 = a2;
    this = sub_1CB915048((uint64_t *)(v8 + 48), &v16, &v15);
    if (this)
    {
      uint64_t v11 = v15;
      uint64_t v12 = *(void *)(v14 + 48);
      uint64_t v13 = *(unsigned int *)(v14 + 64);
    }
    else
    {
      uint64_t v12 = *(void *)(v14 + 48);
      uint64_t v13 = *(unsigned int *)(v14 + 64);
      uint64_t v11 = v12 + 16 * v13;
    }
    if (v11 != v12 + 16 * v13)
    {
      if (*(void *)(v11 + 8)) {
        llvm::DominatorTreeBase<llvm::BasicBlock,true>::eraseNode();
      }
    }
  }
  return this;
}

void llvm::DomTreeUpdater::deleteBB(llvm::DomTreeUpdater *this, llvm::BasicBlock *a2)
{
  llvm::DomTreeUpdater::validateDeleteBB(this, a2);
  if (*((unsigned char *)this + 304) != 1)
  {
    llvm::BasicBlock::removeFromParent(a2);
    llvm::DomTreeUpdater::eraseDelBBNode((uint64_t)this, a2);
    if (a2)
    {
      llvm::BasicBlock::~BasicBlock((llvm::Type ***)a2, v18);
      JUMPOUT(0x1D25D9CE0);
    }
    return;
  }
  uint64_t v4 = *((void *)this + 40);
  uint64_t v5 = *((unsigned int *)this + 83);
  if (v4 != *((void *)this + 39))
  {
    unsigned int v9 = *((_DWORD *)this + 82);
    goto LABEL_14;
  }
  if (!v5)
  {
LABEL_10:
    unsigned int v9 = *((_DWORD *)this + 82);
    if (v5 < v9)
    {
      *((_DWORD *)this + 83) = v5 + 1;
      *(void *)(v4 + 8 * v5) = a2;
      return;
    }
LABEL_14:
    if (3 * v9 <= 4 * ((int)v5 - *((_DWORD *)this + 84)))
    {
      if (v9 >= 0x40) {
        v9 *= 2;
      }
      else {
        unsigned int v9 = 128;
      }
    }
    else if (v9 - v5 >= v9 >> 3)
    {
      goto LABEL_16;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::DomTreeUpdater *)((char *)this + 312), v9);
    unsigned int v9 = *((_DWORD *)this + 82);
    uint64_t v4 = *((void *)this + 40);
LABEL_16:
    unsigned int v10 = v9 - 1;
    unsigned int v11 = (v9 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v12 = (llvm::BasicBlock **)(v4 + 8 * v11);
    uint64_t v13 = *v12;
    if (*v12 == (llvm::BasicBlock *)-1)
    {
      uint64_t v14 = 0;
LABEL_32:
      if (v14) {
        size_t v19 = v14;
      }
      else {
        size_t v19 = v12;
      }
      if (*v19 != a2)
      {
        if (*v19 == (llvm::BasicBlock *)-2) {
          --*((_DWORD *)this + 84);
        }
        else {
          ++*((_DWORD *)this + 83);
        }
        *size_t v19 = a2;
      }
    }
    else
    {
      uint64_t v14 = 0;
      int v15 = 1;
      while (v13 != a2)
      {
        if (v14) {
          BOOL v16 = 0;
        }
        else {
          BOOL v16 = v13 == (llvm::BasicBlock *)-2;
        }
        if (v16) {
          uint64_t v14 = v12;
        }
        unsigned int v17 = v11 + v15++;
        unsigned int v11 = v17 & v10;
        uint64_t v12 = (llvm::BasicBlock **)(v4 + 8 * (v17 & v10));
        uint64_t v13 = *v12;
        if (*v12 == (llvm::BasicBlock *)-1) {
          goto LABEL_32;
        }
      }
    }
    return;
  }
  uint64_t v6 = 0;
  uint64_t v7 = 8 * v5;
  uint64_t v8 = (void *)*((void *)this + 40);
  while ((llvm::BasicBlock *)*v8 != a2)
  {
    if (*v8 == -2) {
      uint64_t v6 = v8;
    }
    ++v8;
    v7 -= 8;
    if (!v7)
    {
      if (!v6) {
        goto LABEL_10;
      }
      *uint64_t v6 = a2;
      --*((_DWORD *)this + 84);
      return;
    }
  }
}

char *llvm::DomTreeUpdater::validateDeleteBB(llvm::DomTreeUpdater *this, llvm::BasicBlock *a2)
{
  uint64_t v4 = (char *)a2 + 40;
  uint64_t v3 = (llvm::BasicBlock *)*((void *)a2 + 5);
  if (v3 != (llvm::BasicBlock *)((char *)a2 + 40))
  {
    if (v3) {
      uint64_t v5 = (llvm::BasicBlock *)((char *)v3 - 24);
    }
    else {
      uint64_t v5 = 0;
    }
    if (*((void *)v5 + 1))
    {
      unsigned int v9 = llvm::UndefValue::get(*(llvm::UndefValue **)v5, a2);
      llvm::Value::replaceAllUsesWith(v5, v9);
    }
    llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
  }
  uint64_t v6 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v6 = ***(void ***)a2 + 1576;
  *((void *)v6 + sub_1CD456CB4((void *)this + 1) = 0;
  v6[16] = 35;
  *(_OWORD *)(v6 + 44) = 0u;
  *(_OWORD *)(v6 + 33) = 0u;
  *(_OWORD *)(v6 + 17) = 0u;
  *((_WORD *)a2 + 9) &= ~0x8000u;
  uint64_t v7 = *((void *)a2 + 5);
  *((void *)v6 + 4) = v4;
  *((void *)v6 + 5) = a2;
  *((void *)v6 + 3) = v7;
  uint64_t result = v6 + 24;
  *(void *)(v7 + 8) = result;
  *((void *)a2 + 5) = result;
  return result;
}

void llvm::DomTreeUpdater::callbackDeleteBB(uint64_t a1, llvm::BasicBlock *a2, uint64_t a3)
{
  uint64_t v69 = *MEMORY[0x1E4F143B8];
  llvm::DomTreeUpdater::validateDeleteBB((llvm::DomTreeUpdater *)a1, a2);
  if (*(unsigned char *)(a1 + 304) != 1)
  {
    llvm::BasicBlock::removeFromParent(a2);
    llvm::DomTreeUpdater::eraseDelBBNode(a1, a2);
    uint64_t v63 = a2;
    uint64_t v6 = *(void *)(a3 + 24);
    if (v6)
    {
      (*(void (**)(uint64_t, llvm::BasicBlock **))(*(void *)v6 + 48))(v6, &v63);
      if (a2)
      {
        llvm::BasicBlock::~BasicBlock((llvm::Type ***)a2, v7);
        MEMORY[0x1D25D9CE0]();
      }
      return;
    }
    sub_1CB920400();
LABEL_107:
    abort();
  }
  sub_1CBFEBB98((uint64_t)v61, a3);
  v64[0] = 2;
  v64[1] = 0;
  uint64_t v65 = a2;
  if (a2 != (llvm::BasicBlock *)-8192 && a2 != (llvm::BasicBlock *)-4096 && a2) {
    llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)v64);
  }
  uint64_t v63 = (llvm::BasicBlock *)&unk_1F2603318;
  std::string::size_type v66 = a2;
  sub_1CBFEBB98((uint64_t)v67, (uint64_t)v61);
  unsigned int v9 = *(void **)(a1 + 416);
  unint64_t v8 = *(void *)(a1 + 424);
  if ((unint64_t)v9 < v8)
  {
    uint64_t v10 = v64[0] & 6;
    v9[1] = v10;
    unsigned int v11 = v9 + 1;
    BOOL v9[2] = 0;
    unint64_t v12 = (unint64_t)(v9 + 2);
    uint64_t v13 = v65;
    v9[3] = v65;
    if (v13 != (llvm::BasicBlock *)-8192 && v13 != (llvm::BasicBlock *)-4096)
    {
      if (v13)
      {
        unint64_t v14 = v64[0] & 0xFFFFFFFFFFFFFFF8;
        *(void *)unint64_t v12 = *(void *)(v64[0] & 0xFFFFFFFFFFFFFFF8);
        *(void *)unint64_t v14 = v11;
        *unsigned int v11 = v14 | v10;
        if (*(void *)v12) {
          **(void **)unint64_t v12 = **(void **)v12 & 7 | v12;
        }
      }
    }
    *unsigned int v9 = &unk_1F2603318;
    void v9[4] = v66;
    if (v68)
    {
      if (v68 == v67)
      {
        v9[8] = v9 + 5;
        (*(void (**)(void *))(*v68 + 24))(v68);
      }
      else
      {
        v9[8] = v68;
        std::string::size_type v68 = 0;
      }
    }
    else
    {
      v9[8] = 0;
    }
    size_t v29 = v9 + 9;
    goto LABEL_46;
  }
  uint64_t v15 = *(void *)(a1 + 408);
  unint64_t v16 = 0x8E38E38E38E38E39 * (((uint64_t)v9 - v15) >> 3);
  if (v16 + 1 > 0x38E38E38E38E38ELL) {
    goto LABEL_107;
  }
  unint64_t v17 = 0x8E38E38E38E38E39 * ((uint64_t)(v8 - v15) >> 3);
  uint64_t v18 = 2 * v17;
  if (2 * v17 <= v16 + 1) {
    uint64_t v18 = v16 + 1;
  }
  if (v17 >= 0x1C71C71C71C71C7) {
    unint64_t v19 = 0x38E38E38E38E38ELL;
  }
  else {
    unint64_t v19 = v18;
  }
  if (v19)
  {
    if (v19 > 0x38E38E38E38E38ELL) {
      sub_1CB833614();
    }
    uint64_t v20 = operator new(72 * v19);
  }
  else
  {
    uint64_t v20 = 0;
  }
  unint64_t v21 = &v20[9 * v16];
  uint64_t v22 = v64[0];
  uint64_t v23 = v65;
  v21[1] = v64[0] & 6;
  uint64_t v24 = v21 + 1;
  void v21[2] = 0;
  unint64_t v25 = (unint64_t)(v21 + 2);
  void v21[3] = v23;
  if (v23 != (llvm::BasicBlock *)-8192 && v23 != (llvm::BasicBlock *)-4096)
  {
    if (v23)
    {
      *(void *)unint64_t v25 = *(void *)(v22 & 0xFFFFFFFFFFFFFFF8);
      *(void *)(v22 & 0xFFFFFFFFFFFFFFF8) = v24;
      *uint64_t v24 = v22 & 0xFFFFFFFFFFFFFFFELL;
      if (*(void *)v25) {
        **(void **)unint64_t v25 = **(void **)v25 & 7 | v25;
      }
    }
  }
  *unint64_t v21 = &unk_1F2603318;
  std::string::size_type v26 = (char *)&v20[9 * v16];
  size_t v27 = v68;
  *((void *)v26 + 4) = v66;
  if (v27)
  {
    std::string::size_type v28 = &v20[9 * v16 + 8];
    if (v27 == v67)
    {
      void *v28 = v26 + 40;
      (*(void (**)(void *))(v67[0] + 24))(v67);
    }
    else
    {
      void *v28 = v27;
      std::string::size_type v68 = 0;
    }
  }
  else
  {
    v20[9 * v16 + 8] = 0;
  }
  std::string::size_type v30 = (char *)&v20[9 * v19];
  size_t v29 = v21 + 9;
  __int16 v32 = *(char **)(a1 + 408);
  std::string v31 = *(char **)(a1 + 416);
  if (v31 != v32)
  {
    uint64_t v47 = 0;
    uint64_t v48 = (char *)&v20[9 * v16];
    while (1)
    {
      int v49 = &v21[v47];
      uint64_t v50 = &v31[v47 * 8];
      uint64_t v51 = *(void *)&v31[v47 * 8 - 64] & 6;
      v21[v47 - 8] = v51;
      uint64_t v52 = &v21[v47 - 8];
      *(v49 - 7) = 0;
      uint64_t v53 = *(void *)&v31[v47 * 8 - 48];
      *(v49 - 6) = v53;
      if (v53 != -8192 && v53 != -4096 && v53 != 0)
      {
        unint64_t v55 = *((void *)v50 - 8) & 0xFFFFFFFFFFFFFFF8;
        *(v49 - 7) = *(void *)v55;
        *(void *)unint64_t v55 = v52;
        unint64_t *v52 = v55 | v51;
        int v56 = (uint64_t *)*(v49 - 7);
        if (v56) {
          uint64_t *v56 = *v56 & 7 | (unint64_t)&v48[v47 * 8 - 56];
        }
      }
      *(v49 - 9) = &unk_1F2603318;
      *(v49 - 5) = *((void *)v50 - 5);
      int v57 = (char *)*((void *)v50 - 1);
      if (v57)
      {
        uint64_t v58 = &v21[v47];
        if (&v31[v47 * 8 - 32] == v57)
        {
          *(v58 - sub_1CD456CB4((void *)this + 1) = v49 - 4;
          (*(void (**)(void))(**((void **)v50 - 1) + 24))(*((void *)v50 - 1));
          goto LABEL_88;
        }
        *(v58 - sub_1CD456CB4((void *)this + 1) = v57;
      }
      else
      {
        uint64_t v50 = (char *)&v21[v47];
      }
      *((void *)v50 - sub_1CD456CB4((void *)this + 1) = 0;
LABEL_88:
      v47 -= 9;
      if (&v31[v47 * 8] == v32)
      {
        std::string v31 = *(char **)(a1 + 408);
        size_t v59 = *(char **)(a1 + 416);
        *(void *)(a1 + 408) = &v21[v47];
        *(void *)(a1 + 416) = v29;
        *(void *)(a1 + 424) = v30;
        while (v59 != v31)
          size_t v59 = (char *)sub_1CD486098((void *)v59 - 9);
        goto LABEL_44;
      }
    }
  }
  *(void *)(a1 + 408) = v21;
  *(void *)(a1 + 416) = v29;
  *(void *)(a1 + 424) = v30;
LABEL_44:
  if (v31) {
    operator delete(v31);
  }
LABEL_46:
  *(void *)(a1 + 416) = v29;
  sub_1CD486098(&v63);
  if (v62 == v61)
  {
    (*(void (**)(void *))(v61[0] + 32))(v61);
  }
  else if (v62)
  {
    (*(void (**)(void))(*v62 + 40))();
  }
  uint64_t v33 = *(void *)(a1 + 320);
  uint64_t v34 = *(unsigned int *)(a1 + 332);
  if (v33 != *(void *)(a1 + 312))
  {
    unsigned int v38 = *(_DWORD *)(a1 + 328);
    goto LABEL_61;
  }
  if (!v34)
  {
LABEL_58:
    unsigned int v38 = *(_DWORD *)(a1 + 328);
    if (v34 < v38)
    {
      *(_DWORD *)(a1 + 332) = v34 + 1;
      *(void *)(v33 + 8 * v34) = a2;
      return;
    }
LABEL_61:
    if (3 * v38 <= 4 * ((int)v34 - *(_DWORD *)(a1 + 336)))
    {
      if (v38 >= 0x40) {
        v38 *= 2;
      }
      else {
        unsigned int v38 = 128;
      }
    }
    else if (v38 - v34 >= v38 >> 3)
    {
      goto LABEL_63;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)(a1 + 312), v38);
    unsigned int v38 = *(_DWORD *)(a1 + 328);
    uint64_t v33 = *(void *)(a1 + 320);
LABEL_63:
    unsigned int v39 = v38 - 1;
    unsigned int v40 = (v38 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v41 = (llvm::BasicBlock **)(v33 + 8 * v40);
    uint64_t v42 = *v41;
    if (*v41 == (llvm::BasicBlock *)-1)
    {
      uint64_t v43 = 0;
LABEL_93:
      if (v43) {
        uint64_t v60 = v43;
      }
      else {
        uint64_t v60 = v41;
      }
      if (*v60 != a2)
      {
        if (*v60 == (llvm::BasicBlock *)-2) {
          --*(_DWORD *)(a1 + 336);
        }
        else {
          ++*(_DWORD *)(a1 + 332);
        }
        *uint64_t v60 = a2;
      }
    }
    else
    {
      uint64_t v43 = 0;
      int v44 = 1;
      while (v42 != a2)
      {
        if (v43) {
          BOOL v45 = 0;
        }
        else {
          BOOL v45 = v42 == (llvm::BasicBlock *)-2;
        }
        if (v45) {
          uint64_t v43 = v41;
        }
        unsigned int v46 = v40 + v44++;
        unsigned int v40 = v46 & v39;
        uint64_t v41 = (llvm::BasicBlock **)(v33 + 8 * (v46 & v39));
        uint64_t v42 = *v41;
        if (*v41 == (llvm::BasicBlock *)-1) {
          goto LABEL_93;
        }
      }
    }
    return;
  }
  size_t v35 = 0;
  uint64_t v36 = 8 * v34;
  int64_t v37 = *(llvm::BasicBlock ***)(a1 + 320);
  while (*v37 != a2)
  {
    if (*v37 == (llvm::BasicBlock *)-2) {
      size_t v35 = v37;
    }
    ++v37;
    v36 -= 8;
    if (!v36)
    {
      if (!v35) {
        goto LABEL_58;
      }
      const std::string::value_type *v35 = a2;
      --*(_DWORD *)(a1 + 336);
      return;
    }
  }
}

uint64_t llvm::DomTreeUpdater::applyUpdates(uint64_t result, unint64_t *a2, uint64_t a3)
{
  uint64_t v4 = a2;
  uint64_t v5 = result;
  v14[8] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(result + 288);
  if (!v6)
  {
    uint64_t v10 = *(void *)(result + 296);
    if (!v10) {
      return result;
    }
    if (*(unsigned char *)(result + 304) == 1) {
      goto LABEL_3;
    }
LABEL_13:
    sub_1CBFEEDA8((uint64_t)v11, v4, a3, 1u);
    llvm::DomTreeBuilder::ApplyUpdates<llvm::DominatorTreeBase<llvm::BasicBlock,true>>(v10, (uint64_t)v11, 0);
    if (v13 != v14) {
      free(v13);
    }
    sub_1CBFEF654((uint64_t)v12);
    return sub_1CBFEF654((uint64_t)v11);
  }
  if (*(unsigned char *)(result + 304) == 1)
  {
LABEL_3:
    if (a3 + (unint64_t)*(unsigned int *)(result + 8) > *(unsigned int *)(result + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    if (a3)
    {
      do
      {
        unint64_t v7 = v4[1];
        if (*v4 != (v7 & 0xFFFFFFFFFFFFFFF8))
        {
          unint64_t v8 = *(unsigned int *)(result + 8);
          if (v8 >= *(unsigned int *)(result + 12)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          unsigned int v9 = (unint64_t *)(*(void *)result + 16 * v8);
          *unsigned int v9 = *v4;
          v9[1] = v7;
          ++*(_DWORD *)(result + 8);
        }
        v4 += 2;
      }
      while (v4 != &a2[2 * a3]);
    }
    return result;
  }
  sub_1CBFEBC30((uint64_t)v11, a2, a3, 1u);
  llvm::DomTreeBuilder::ApplyUpdates<llvm::DominatorTreeBase<llvm::BasicBlock,false>>(v6, (uint64_t)v11, 0);
  if (v13 != v14) {
    free(v13);
  }
  sub_1CBFEECCC((uint64_t)v12);
  uint64_t result = sub_1CBFEECCC((uint64_t)v11);
  uint64_t v10 = *(void *)(v5 + 296);
  if (v10) {
    goto LABEL_13;
  }
  return result;
}

uint64_t llvm::DomTreeUpdater::getDomTree(llvm::DomTreeUpdater *this)
{
  v20[8] = *MEMORY[0x1E4F143B8];
  int v2 = *((unsigned __int8 *)this + 304);
  if (v2 == 1)
  {
    uint64_t v4 = *((void *)this + 36);
    if (!v4) {
      goto LABEL_7;
    }
    uint64_t v5 = *((unsigned int *)this + 2);
    uint64_t v6 = *((void *)this + 34);
    if (v5 == v6) {
      goto LABEL_6;
    }
    sub_1CBFEBC30((uint64_t)v17, (unint64_t *)(*(void *)this + 16 * v6), v5 - v6, 1u);
    llvm::DomTreeBuilder::ApplyUpdates<llvm::DominatorTreeBase<llvm::BasicBlock,false>>(v4, (uint64_t)v17, 0);
    if (v19 != v20) {
      free(v19);
    }
    sub_1CBFEECCC((uint64_t)&v18);
    sub_1CBFEECCC((uint64_t)v17);
    *((void *)this + 34) = *((unsigned int *)this + 2);
    int v2 = *((unsigned __int8 *)this + 304);
  }
  if (!v2) {
    return *((void *)this + 36);
  }
  uint64_t v4 = *((void *)this + 36);
  if (!v4) {
    goto LABEL_7;
  }
LABEL_6:
  if (*((void *)this + 34) == *((_DWORD *)this + 2))
  {
LABEL_7:
    if (!*((void *)this + 37) || *((void *)this + 35) == *((_DWORD *)this + 2))
    {
      llvm::DomTreeUpdater::forceFlushDeletedBB(this);
      uint64_t v4 = *((void *)this + 36);
    }
    if (!v4) {
      *((void *)this + 34) = *((unsigned int *)this + 2);
    }
  }
  if (*((void *)this + 37))
  {
    unint64_t v8 = *((void *)this + 35);
    unint64_t v7 = *((unsigned int *)this + 2);
  }
  else
  {
    unint64_t v7 = *((unsigned int *)this + 2);
    *((void *)this + 35) = v7;
    unint64_t v8 = v7;
  }
  unint64_t v9 = *((void *)this + 34);
  if (v8 >= v9) {
    unint64_t v10 = *((void *)this + 34);
  }
  else {
    unint64_t v10 = v8;
  }
  uint64_t v11 = *(void *)this;
  unint64_t v12 = (const void *)(*(void *)this + 16 * v10);
  size_t v13 = *(void *)this + 16 * v7 - (void)v12;
  if (v10 == v7)
  {
    uint64_t v14 = *(void *)this;
  }
  else
  {
    size_t v16 = *(void *)this + 16 * v7 - (void)v12;
    unint64_t v15 = v10;
    memmove(*(void **)this, v12, v13);
    unint64_t v10 = v15;
    size_t v13 = v16;
    uint64_t v14 = *(void *)this;
    unint64_t v9 = *((void *)this + 34);
    unint64_t v8 = *((void *)this + 35);
  }
  *((_DWORD *)this + 2) = (v11 + v13 - v14) >> 4;
  *((void *)this + 34) = v9 - v10;
  *((void *)this + 35) = v8 - v10;
  return *((void *)this + 36);
}

uint64_t llvm::DomTreeUpdater::getPostDomTree(llvm::DomTreeUpdater *this)
{
  return *((void *)this + 37);
}

llvm::raw_ostream *sub_1CBFEB4C4(llvm::raw_ostream **a1, unint64_t *a2, unint64_t *a3)
{
  if (a2 != a3)
  {
    uint64_t v5 = a2;
    *(_DWORD *)a1[1] = 0;
    while (1)
    {
      unint64_t v6 = *v5;
      unint64_t v7 = v5[1];
      unint64_t v8 = *a1;
      unint64_t v9 = (_WORD *)*((void *)*a1 + 4);
      if (*((void *)*a1 + 3) - (void)v9 > 1uLL)
      {
        *unint64_t v9 = 8224;
        *((void *)v8 + 4) += 2;
      }
      else
      {
        llvm::raw_ostream::write(*a1, "  ", 2uLL);
      }
      unint64_t v10 = *(int *)a1[1];
      if ((v10 & 0x80000000) != 0)
      {
        unint64_t v10 = -(uint64_t)v10;
        uint64_t v11 = v8;
        int v12 = 1;
      }
      else
      {
        uint64_t v11 = v8;
        int v12 = 0;
      }
      sub_1CD098D14(v11, v10, 0, 0, v12);
      uint64_t v13 = *((void *)v8 + 4);
      if ((unint64_t)(*((void *)v8 + 3) - v13) > 2)
      {
        *(unsigned char *)(v13 + 2) = 32;
        *(_WORD *)uint64_t v13 = 14880;
        *((void *)v8 + 4) += 3;
      }
      else
      {
        llvm::raw_ostream::write(v8, " : ", 3uLL);
      }
      uint64_t v14 = *a1;
      ++*(_DWORD *)a1[1];
      unint64_t v15 = (uint64_t *)*((void *)v14 + 4);
      unint64_t v16 = *((void *)v14 + 3) - (void)v15;
      if ((v7 & 4) != 0)
      {
        if (v16 <= 7)
        {
          unint64_t v17 = "Delete, ";
LABEL_14:
          llvm::raw_ostream::write(v14, v17, 8uLL);
          if (v6) {
            goto LABEL_15;
          }
          goto LABEL_41;
        }
        uint64_t v36 = 0x6574656C6544;
      }
      else
      {
        if (v16 <= 7)
        {
          unint64_t v17 = "Insert, ";
          goto LABEL_14;
        }
        uint64_t v36 = 0x747265736E49;
      }
      uint64_t *v15 = v36 & 0xFFFFFFFFFFFFLL | 0x202C000000000000;
      *((void *)v14 + 4) += 8;
      if (v6)
      {
LABEL_15:
        if ((*(unsigned char *)(v6 + 23) & 0x10) != 0)
        {
          uint64_t v18 = ***(void ***)v6;
          uint64_t v19 = *(void *)(v18 + 152);
          uint64_t v20 = *(unsigned int *)(v18 + 168);
          if (!v20) {
            goto LABEL_22;
          }
          LODWORD(v2sub_1CD456CB4((void *)this + 1) = (v20 - 1) & ((v6 >> 4) ^ (v6 >> 9));
          uint64_t v22 = (void *)(v19 + 16 * v21);
          uint64_t v23 = *v22;
          if (*v22 == v6)
          {
            std::string::size_type v26 = (size_t **)(v22 + 1);
          }
          else
          {
            int v24 = 1;
            while (v23 != -4096)
            {
              int v25 = v21 + v24++;
              uint64_t v21 = v25 & (v20 - 1);
              uint64_t v23 = *(void *)(v19 + 16 * v21);
              if (v23 == v6)
              {
                uint64_t v20 = v21;
                break;
              }
            }
LABEL_22:
            std::string::size_type v26 = (size_t **)(v19 + 16 * v20 + 8);
          }
          size_t v27 = (const char *)(*v26 + 2);
          size_t v28 = **v26;
          size_t v29 = *a1;
          std::string::size_type v30 = (void *)*((void *)*a1 + 4);
          if (v28 > *((void *)*a1 + 3) - (void)v30)
          {
LABEL_25:
            llvm::raw_ostream::write(v29, v27, v28);
LABEL_28:
            std::string v31 = (unsigned char *)*((void *)v29 + 4);
            if (*((unsigned char **)v29 + 3) == v31)
            {
              llvm::raw_ostream::write(v29, "(", 1uLL);
            }
            else
            {
              *std::string v31 = 40;
              ++*((void *)v29 + 4);
            }
            llvm::write_hex(v29, v6, 3, 0, 0);
            uint64_t v32 = *((void *)v29 + 4);
            if ((unint64_t)(*((void *)v29 + 3) - v32) > 2)
            {
              *(unsigned char *)(v32 + 2) = 32;
              *(_WORD *)uint64_t v32 = 11305;
              *((void *)v29 + 4) += 3;
              goto LABEL_44;
            }
            uint64_t v33 = v29;
            uint64_t v34 = "), ";
            size_t v35 = 3;
            goto LABEL_43;
          }
          if (!v28) {
            goto LABEL_28;
          }
        }
        else
        {
          size_t v29 = *a1;
          std::string::size_type v30 = (void *)*((void *)*a1 + 4);
          size_t v27 = "(no name)";
          size_t v28 = 9;
          if (*((void *)*a1 + 3) - (void)v30 <= 8uLL) {
            goto LABEL_25;
          }
        }
        memcpy(v30, v27, v28);
        *((void *)v29 + 4) += v28;
        goto LABEL_28;
      }
LABEL_41:
      uint64_t v33 = *a1;
      uint64_t v37 = *((void *)*a1 + 4);
      if ((unint64_t)(*((void *)*a1 + 3) - v37) <= 9)
      {
        uint64_t v34 = "(badref), ";
        size_t v35 = 10;
LABEL_43:
        llvm::raw_ostream::write(v33, v34, v35);
        goto LABEL_44;
      }
      *(_WORD *)(v37 + 8) = 8236;
      *(void *)uint64_t v37 = *(void *)"(badref), ";
      *((void *)v33 + 4) += 10;
LABEL_44:
      unint64_t v38 = v7 & 0xFFFFFFFFFFFFFFF8;
      if ((v7 & 0xFFFFFFFFFFFFFFF8) == 0)
      {
        uint64_t result = *a1;
        uint64_t v49 = *((void *)*a1 + 4);
        if ((unint64_t)(*((void *)*a1 + 3) - v49) > 8)
        {
          *(unsigned char *)(v49 + 8) = 10;
          *(void *)uint64_t v49 = *(void *)"(badref)\n";
          *((void *)result + 4) += 9;
          goto LABEL_65;
        }
        uint64_t v50 = "(badref)\n";
        size_t v51 = 9;
        goto LABEL_64;
      }
      if ((*(unsigned char *)(v38 + 23) & 0x10) == 0)
      {
        uint64_t v54 = *a1;
        unint64_t v55 = (void *)*((void *)*a1 + 4);
        uint64_t v52 = "(no_name)";
        size_t v53 = 9;
        if (*((void *)*a1 + 3) - (void)v55 > 8uLL)
        {
LABEL_59:
          memcpy(v55, v52, v53);
          *((void *)v54 + 4) += v53;
          goto LABEL_60;
        }
LABEL_57:
        llvm::raw_ostream::write(v54, v52, v53);
        goto LABEL_60;
      }
      uint64_t v39 = ***(void ***)v38;
      uint64_t v40 = *(void *)(v39 + 152);
      uint64_t v41 = *(unsigned int *)(v39 + 168);
      if (!v41) {
        goto LABEL_52;
      }
      LODWORD(v42) = (v41 - 1) & ((v38 >> 4) ^ (v38 >> 9));
      uint64_t v43 = (void *)(v40 + 16 * v42);
      uint64_t v44 = *v43;
      if (*v43 != v38)
      {
        int v45 = 1;
        while (v44 != -4096)
        {
          int v46 = v42 + v45++;
          uint64_t v42 = v46 & (v41 - 1);
          uint64_t v44 = *(void *)(v40 + 16 * v42);
          if (v44 == v38)
          {
            uint64_t v41 = v42;
            break;
          }
        }
LABEL_52:
        uint64_t v47 = (size_t **)(v40 + 16 * v41 + 8);
        goto LABEL_56;
      }
      uint64_t v47 = (size_t **)(v43 + 1);
LABEL_56:
      uint64_t v52 = (const char *)(*v47 + 2);
      size_t v53 = **v47;
      uint64_t v54 = *a1;
      unint64_t v55 = (void *)*((void *)*a1 + 4);
      if (v53 > *((void *)*a1 + 3) - (void)v55) {
        goto LABEL_57;
      }
      if (v53) {
        goto LABEL_59;
      }
LABEL_60:
      int v56 = (unsigned char *)*((void *)v54 + 4);
      if (*((unsigned char **)v54 + 3) == v56)
      {
        llvm::raw_ostream::write(v54, "(", 1uLL);
      }
      else
      {
        unsigned char *v56 = 40;
        ++*((void *)v54 + 4);
      }
      uint64_t result = llvm::write_hex(v54, v7 & 0xFFFFFFFFFFFFFFF8, 3, 0, 0);
      int v57 = (_WORD *)*((void *)v54 + 4);
      if (*((void *)v54 + 3) - (void)v57 > 1uLL)
      {
        *int v57 = 2601;
        *((void *)v54 + 4) += 2;
        goto LABEL_65;
      }
      uint64_t result = v54;
      uint64_t v50 = ")\n";
      size_t v51 = 2;
LABEL_64:
      uint64_t result = llvm::raw_ostream::write(result, v50, v51);
LABEL_65:
      v5 += 2;
      if (v5 == a3) {
        return result;
      }
    }
  }
  uint64_t result = *a1;
  uint64_t v58 = (_DWORD *)*((void *)*a1 + 4);
  if (*((void *)*a1 + 3) - (void)v58 > 6uLL)
  {
    *(_DWORD *)((char *)v58 + 3) = 174419567;
    *uint64_t v58 = 1867391008;
    *((void *)result + 4) += 7;
  }
  else
  {
    uint64_t result = llvm::raw_ostream::write(result, "  None\n", 7uLL);
  }
  *(_DWORD *)a1[1] = 0;
  return result;
}

uint64_t sub_1CBFEBA4C(void *a1)
{
  uint64_t v19 = a1[4];
  uint64_t v2 = a1[8];
  if (v2)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v19);
    uint64_t v4 = a1[3];
    if (v4)
    {
      if ((v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        unint64_t v5 = a1[1] & 0xFFFFFFFFFFFFFFF8;
        *(void *)unint64_t v5 = a1[2];
        unint64_t v6 = (unint64_t *)a1[2];
        if (v6)
        {
          *unint64_t v6 = *v6 & 7 | v5;
        }
        else
        {
          uint64_t v7 = a1[3];
          unint64_t v8 = ***(int32x2_t ****)v7;
          unint64_t v9 = (unint64_t)v8[303];
          if (v9 <= v5)
          {
            uint64_t v10 = v8[305].u32[0];
            if (v9 + 16 * v10 > v5)
            {
              unsigned int v11 = v10 - 1;
              LODWORD(v12) = v11 & ((v7 >> 4) ^ (v7 >> 9));
              uint64_t v13 = (uint64_t *)(v9 + 16 * v12);
              uint64_t v14 = *v13;
              if (v7 == *v13)
              {
LABEL_14:
                *uint64_t v13 = -8192;
                v8[304] = vadd_s32(v8[304], (int32x2_t)0x1FFFFFFFFLL);
                uint64_t v7 = a1[3];
              }
              else
              {
                int v15 = 1;
                while (v14 != -4096)
                {
                  int v16 = v12 + v15++;
                  uint64_t v12 = v16 & v11;
                  uint64_t v14 = *(void *)(v9 + 16 * v12);
                  if (v7 == v14)
                  {
                    uint64_t v13 = (uint64_t *)(v9 + 16 * v12);
                    goto LABEL_14;
                  }
                }
              }
              *(unsigned char *)(v7 + 17) &= ~1u;
            }
          }
        }
      }
      a1[3] = 0;
    }
  }
  else
  {
    sub_1CB920400();
    return sub_1CBFEBB98(v17, v18);
  }
  return result;
}

uint64_t sub_1CBFEBB98(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_1CBFEBC30(uint64_t a1, unint64_t *a2, uint64_t a3, unsigned int a4)
{
  *(void *)a1 = 1;
  uint64_t v47 = a1 + 8;
  unint64_t v6 = (unsigned char *)(a1 + 296);
  for (uint64_t i = 8; i != 296; i += 72)
    *(void *)(a1 + i) = -4096;
  *(void *)(a1 + 296) = 1;
  uint64_t v46 = a1 + 304;
  for (uint64_t j = 304; j != 592; j += 72)
    *(void *)(a1 + j) = -4096;
  *(void *)(a1 + 600) = a1 + 616;
  *(void *)(a1 + 608) = 0x400000000;
  sub_1CBFEBF88(a2, a3, a1 + 600, 0, 0);
  uint64_t v9 = *(unsigned int *)(a1 + 608);
  if (v9)
  {
    uint64_t v10 = *(unint64_t **)(a1 + 600);
    unsigned int v11 = &v10[2 * v9];
    do
    {
      unint64_t v13 = *v10;
      unint64_t v12 = v10[1];
      unint64_t v48 = *v10;
      if (*(unsigned char *)a1)
      {
        int v14 = 4;
        uint64_t v15 = v47;
      }
      else
      {
        int v14 = *(_DWORD *)(a1 + 16);
        if (!v14)
        {
          uint64_t v41 = 0;
          goto LABEL_40;
        }
        uint64_t v15 = *(void *)(a1 + 8);
      }
      int v16 = v14 - 1;
      unsigned int v17 = v16 & ((v13 >> 4) ^ (v13 >> 9));
      uint64_t v18 = (void *)(v15 + 72 * v17);
      uint64_t v19 = *v18;
      if (v13 == *v18) {
        goto LABEL_11;
      }
      uint64_t v33 = 0;
      int v34 = 1;
      while (v19 != -4096)
      {
        if (v33) {
          BOOL v35 = 0;
        }
        else {
          BOOL v35 = v19 == -8192;
        }
        if (v35) {
          uint64_t v33 = v18;
        }
        unsigned int v36 = v17 + v34++;
        unsigned int v17 = v36 & v16;
        uint64_t v18 = (void *)(v15 + 72 * v17);
        uint64_t v19 = *v18;
        if (v13 == *v18) {
          goto LABEL_11;
        }
      }
      if (v33) {
        uint64_t v41 = v33;
      }
      else {
        uint64_t v41 = v18;
      }
LABEL_40:
      uint64_t v18 = sub_1CBFEE5DC(a1, (uint64_t)&v48, &v48, v41);
      unint64_t v42 = v48;
      *(_OWORD *)(v18 + 7) = 0u;
      *(_OWORD *)(v18 + 3) = 0u;
      *(_OWORD *)(v18 + 5) = 0u;
      *uint64_t v18 = v42;
      v18[1] = v18 + 3;
      v18[2] = 0x200000000;
      v18[5] = v18 + 7;
      *((_DWORD *)v18 + 13) = 2;
LABEL_11:
      uint64_t v20 = ((v12 & 4) == 0) ^ a4;
      uint64_t v21 = &v18[4 * v20];
      uint64_t v22 = v21 + 1;
      unint64_t v23 = *((unsigned int *)v21 + 4);
      if (v23 >= *((unsigned int *)v21 + 5)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      unint64_t v24 = v12 & 0xFFFFFFFFFFFFFFF8;
      *(void *)(*v22 + 8 * v23) = v12 & 0xFFFFFFFFFFFFFFF8;
      ++*((_DWORD *)v22 + 2);
      unint64_t v48 = v12 & 0xFFFFFFFFFFFFFFF8;
      if (*v6)
      {
        int v25 = 4;
        uint64_t v26 = v46;
      }
      else
      {
        int v25 = *(_DWORD *)(a1 + 312);
        if (!v25)
        {
          uint64_t v43 = 0;
LABEL_44:
          size_t v29 = sub_1CBFEE5DC((uint64_t)v6, (uint64_t)&v48, &v48, v43);
          unint64_t v44 = v48;
          *(_OWORD *)(v29 + 7) = 0u;
          *(_OWORD *)(v29 + 3) = 0u;
          *(_OWORD *)(v29 + 5) = 0u;
          *size_t v29 = v44;
          v29[1] = v29 + 3;
          void v29[2] = 0x200000000;
          v29[5] = v29 + 7;
          *((_DWORD *)v29 + 13) = 2;
          goto LABEL_16;
        }
        uint64_t v26 = *(void *)(a1 + 304);
      }
      int v27 = v25 - 1;
      unsigned int v28 = v27 & ((v24 >> 4) ^ (v24 >> 9));
      size_t v29 = (void *)(v26 + 72 * v28);
      uint64_t v30 = *v29;
      if (*v29 != v24)
      {
        uint64_t v37 = 0;
        int v38 = 1;
        while (v30 != -4096)
        {
          if (v37) {
            BOOL v39 = 0;
          }
          else {
            BOOL v39 = v30 == -8192;
          }
          if (v39) {
            uint64_t v37 = v29;
          }
          unsigned int v40 = v28 + v38++;
          unsigned int v28 = v40 & v27;
          size_t v29 = (void *)(v26 + 72 * v28);
          uint64_t v30 = *v29;
          if (*v29 == v24) {
            goto LABEL_16;
          }
        }
        if (v37) {
          uint64_t v43 = v37;
        }
        else {
          uint64_t v43 = v29;
        }
        goto LABEL_44;
      }
LABEL_16:
      std::string v31 = &v29[4 * v20];
      unint64_t v32 = *((unsigned int *)v31 + 4);
      if (v32 >= *((unsigned int *)v31 + 5)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(v31[1] + 8 * v32) = v13;
      ++*((_DWORD *)v31 + 4);
      v10 += 2;
    }
    while (v10 != v11);
  }
  *(unsigned char *)(a1 + 592) = a4;
  return a1;
}

void sub_1CBFEBF88(unint64_t *a1, uint64_t a2, uint64_t a3, int a4, char a5)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  char v43 = a5;
  uint64_t v46 = 1;
  uint64_t v9 = (uint64_t *)&v47;
  uint64_t v10 = &v49;
  uint64_t v11 = 8;
  int64x2_t v12 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  do
  {
    *(int64x2_t *)((char *)&v46 + v1sub_1CD456CB4((void *)this + 1) = v12;
    v11 += 24;
  }
  while (v11 != 104);
  sub_1CBFEC2C4((int *)&v46, a2);
  if (a2)
  {
    unint64_t v13 = a1;
    do
    {
      unint64_t v14 = *v13;
      unint64_t v15 = v13[1];
      v13 += 2;
      if (a4) {
        unint64_t v16 = v14;
      }
      else {
        unint64_t v16 = v15 & 0xFFFFFFFFFFFFFFF8;
      }
      if (a4) {
        unint64_t v14 = v15 & 0xFFFFFFFFFFFFFFF8;
      }
      unint64_t v44 = (uint64_t *)v14;
      int v45 = (char *)v16;
      unsigned int v17 = sub_1CBFEC774((uint64_t)&v46, (uint64_t *)&v44);
      int v18 = *((_DWORD *)v17 + 4);
      if ((v15 & 4) != 0) {
        int v19 = v18 - 1;
      }
      else {
        int v19 = v18 + 1;
      }
      *((_DWORD *)v17 + 4) = v19;
    }
    while (v13 != &a1[2 * a2]);
  }
  *(_DWORD *)(a3 + 8) = 0;
  int v20 = v46;
  if (*(_DWORD *)(a3 + 12) < v46 >> 1) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (v46 <= 1)
  {
    if (v46)
    {
      unsigned int v42 = 4;
    }
    else
    {
      uint64_t v9 = v47;
      unsigned int v42 = v48;
    }
    v9 += 3 * v42;
    goto LABEL_60;
  }
  if (v46) {
    goto LABEL_20;
  }
  uint64_t v9 = v47;
  if (!v48)
  {
    int v20 = 0;
LABEL_60:
    uint64_t v10 = v9;
    goto LABEL_27;
  }
  uint64_t v10 = &v47[3 * v48];
LABEL_20:
  int v20 = v46 & 1;
  while (1)
  {
    uint64_t v21 = v9[1];
    if ((*v9 != -4096 || v21 != -4096) && (*v9 != -8192 || v21 != -8192)) {
      break;
    }
    v9 += 3;
    if (v9 == v10)
    {
      uint64_t v9 = v10;
      break;
    }
  }
LABEL_27:
  BOOL v22 = v20 == 0;
  if (v20) {
    unint64_t v23 = &v47;
  }
  else {
    unint64_t v23 = v47;
  }
  unsigned int v24 = v48;
  if (!v22) {
    unsigned int v24 = 4;
  }
  int v25 = &v23[3 * v24];
LABEL_33:
  while (v9 != v25)
  {
    int v26 = *((_DWORD *)v9 + 4);
    if (v26)
    {
      BOOL v27 = v26 < 1;
      uint64_t v28 = v9[1];
      unint64_t v29 = *(unsigned int *)(a3 + 8);
      if (v29 >= *(unsigned int *)(a3 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v30 = (uint64_t *)(*(void *)a3 + 16 * v29);
      uint64_t *v30 = *v9;
      v30[1] = v28 & 0xFFFFFFFFFFFFFFFBLL | (4 * v27);
      ++*(_DWORD *)(a3 + 8);
    }
    std::string v31 = v9 + 3;
    uint64_t v9 = v10;
    if (v31 != v10)
    {
      uint64_t v9 = v31;
      while (1)
      {
        uint64_t v32 = v9[1];
        if ((*v9 != -4096 || v32 != -4096) && (*v9 != -8192 || v32 != -8192)) {
          break;
        }
        v9 += 3;
        if (v9 == v10)
        {
          uint64_t v9 = v10;
          goto LABEL_33;
        }
      }
    }
  }
  if (a2)
  {
    uint64_t v33 = 0;
    int v34 = a1 + 1;
    do
    {
      if (a4)
      {
        unint64_t v36 = *(v34 - 1);
        unint64_t v35 = *v34 & 0xFFFFFFFFFFFFFFF8;
      }
      else
      {
        unint64_t v35 = *(v34 - 1);
        unint64_t v36 = *v34 & 0xFFFFFFFFFFFFFFF8;
      }
      unint64_t v44 = (uint64_t *)v35;
      int v45 = (char *)v36;
      *((_DWORD *)sub_1CBFEC774((uint64_t)&v46, (uint64_t *)&v44) + 4) = v33++;
      v34 += 2;
    }
    while (a2 != v33);
  }
  uint64_t v37 = *(uint64_t **)a3;
  unint64_t v38 = *(unsigned int *)(a3 + 8);
  BOOL v39 = (uint64_t *)(*(void *)a3 + 16 * v38);
  unint64_t v44 = &v46;
  int v45 = &v43;
  unint64_t v40 = 126 - 2 * __clz(v38);
  if (v38) {
    uint64_t v41 = v40;
  }
  else {
    uint64_t v41 = 0;
  }
  sub_1CBFECA88(v37, v39, (uint64_t)&v44, v41, 1);
  if ((v46 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v47, 8);
  }
}

int *sub_1CBFEC2C4(int *result, unsigned int a2)
{
  if (a2)
  {
    unint64_t v2 = (4 * a2 / 3 + 1) | ((unint64_t)(4 * a2 / 3 + 1) >> 1);
    unint64_t v3 = v2 | (v2 >> 2) | ((v2 | (v2 >> 2)) >> 4);
    a2 = (((v3 | (v3 >> 8)) >> 16) | v3 | (v3 >> 8)) + 1;
  }
  if (*(unsigned char *)result) {
    unsigned int v4 = 4;
  }
  else {
    unsigned int v4 = result[4];
  }
  if (a2 > v4) {
    return sub_1CBFEC320((uint64_t)result, a2);
  }
  return result;
}

int *sub_1CBFEC320(uint64_t a1, unsigned int a2)
{
  v15[12] = *MEMORY[0x1E4F143B8];
  if (a2 >= 5)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    int64x2_t v12 = *(uint64_t **)(a1 + 8);
    unsigned int v13 = *(_DWORD *)(a1 + 16);
    if (a2 > 4)
    {
      uint64_t v14 = a2;
      *(void *)(a1 + 8) = operator new(24 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v14;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CBFEC4E4((int *)a1, v12, &v12[3 * v13]);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v6 = 0;
  uint64_t v7 = v15;
  do
  {
    uint64_t v9 = *(void *)(a1 + v6 + 8);
    uint64_t v8 = *(void *)(a1 + v6 + 16);
    if ((v9 != -4096 || v8 != -4096) && (v9 != -8192 || v8 != -8192))
    {
      *(_OWORD *)uint64_t v7 = *(_OWORD *)(a1 + v6 + 8);
      *((_DWORD *)v7 + 4) = *(_DWORD *)(a1 + v6 + 24);
      v7 += 3;
    }
    v6 += 24;
  }
  while (v6 != 96);
  if (a2 > 4)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v10 = a2;
    *(void *)(a1 + 8) = operator new(24 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v10;
  }
  return sub_1CBFEC4E4((int *)a1, v15, v7);
}

int *sub_1CBFEC4E4(int *result, uint64_t *a2, uint64_t *a3)
{
  int v3 = *result;
  *result &= 1u;
  result[1] = 0;
  if (v3)
  {
    uint64_t v6 = (int64x2_t *)(result + 26);
    int v5 = (int64x2_t *)(result + 2);
  }
  else
  {
    unsigned int v4 = result[4];
    if (!v4) {
      goto LABEL_6;
    }
    int v5 = (int64x2_t *)*((void *)result + 1);
    uint64_t v6 = (int64x2_t *)((char *)v5 + 24 * v4);
  }
  int64x2_t v7 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  do
  {
    *int v5 = v7;
    int v5 = (int64x2_t *)((char *)v5 + 24);
  }
  while (v5 != v6);
LABEL_6:
  while (a2 != a3)
  {
    uint64_t v8 = *a2;
    uint64_t v9 = a2[1];
    if ((*a2 != -4096 || v9 != -4096) && (v8 != -8192 || v9 != -8192))
    {
      if (*(unsigned char *)result)
      {
        int v11 = 4;
        uint64_t v10 = result + 2;
      }
      else
      {
        uint64_t v10 = (int *)*((void *)result + 1);
        int v11 = result[4];
      }
      unint64_t v12 = ((v9 >> 4) ^ (v9 >> 9) | ((unint64_t)((v8 >> 4) ^ (v8 >> 9)) << 32))
          + ~((unint64_t)((v9 >> 4) ^ (v9 >> 9)) << 32);
      unint64_t v13 = (v12 ^ (v12 >> 22)) + ~((v12 ^ (v12 >> 22)) << 13);
      unint64_t v14 = (9 * (v13 ^ (v13 >> 8))) ^ ((9 * (v13 ^ (v13 >> 8))) >> 15);
      int v15 = ((v14 + ~(v14 << 27)) >> 31) ^ (v14 + ~(v14 << 27));
      int v16 = v11 - 1;
      unsigned int v17 = (v11 - 1) & v15;
      int v18 = (uint64_t *)&v10[6 * v17];
      uint64_t v19 = *v18;
      uint64_t v20 = v18[1];
      if (v8 != *v18 || v9 != v20)
      {
        BOOL v22 = 0;
        int v23 = 1;
        while (v19 != -4096 || v20 != -4096)
        {
          if (v22) {
            BOOL v24 = 0;
          }
          else {
            BOOL v24 = v20 == -8192;
          }
          if (v24 && v19 == -8192) {
            BOOL v22 = v18;
          }
          unsigned int v26 = v17 + v23++;
          unsigned int v17 = v26 & v16;
          int v18 = (uint64_t *)&v10[6 * (v26 & v16)];
          uint64_t v19 = *v18;
          uint64_t v20 = v18[1];
          if (v8 == *v18 && v9 == v20) {
            goto LABEL_19;
          }
        }
        if (v22) {
          int v18 = v22;
        }
      }
LABEL_19:
      *int v18 = v8;
      v18[1] = a2[1];
      *((_DWORD *)v18 + 4) = *((_DWORD *)a2 + 4);
      *result += 2;
    }
    a2 += 3;
  }
  return result;
}

uint64_t sub_1CBFEC66C(uint64_t a1, uint64_t *a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 4;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      unint64_t v13 = 0;
      uint64_t result = 0;
      goto LABEL_10;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  uint64_t v5 = *a2;
  uint64_t v6 = a2[1];
  unint64_t v7 = ((v6 >> 4) ^ (v6 >> 9) | ((unint64_t)((*a2 >> 4) ^ (*a2 >> 9)) << 32))
     + ~((unint64_t)((v6 >> 4) ^ (v6 >> 9)) << 32);
  unint64_t v8 = (v7 ^ (v7 >> 22)) + ~((v7 ^ (v7 >> 22)) << 13);
  unint64_t v9 = (9 * (v8 ^ (v8 >> 8))) ^ ((9 * (v8 ^ (v8 >> 8))) >> 15);
  int v10 = ((v9 + ~(v9 << 27)) >> 31) ^ (v9 + ~(v9 << 27));
  int v11 = v4 - 1;
  unsigned int v12 = (v4 - 1) & v10;
  unint64_t v13 = (void *)(v3 + 24 * v12);
  uint64_t v15 = *v13;
  uint64_t v14 = v13[1];
  if (v5 == *v13 && v6 == v14)
  {
    uint64_t result = 1;
  }
  else
  {
    unsigned int v17 = 0;
    int v18 = 1;
    uint64_t result = 1;
    while (v15 != -4096 || v14 != -4096)
    {
      if (v17) {
        BOOL v20 = 0;
      }
      else {
        BOOL v20 = v14 == -8192;
      }
      if (v20 && v15 == -8192) {
        unsigned int v17 = v13;
      }
      unsigned int v22 = v12 + v18++;
      unsigned int v12 = v22 & v11;
      unint64_t v13 = (void *)(v3 + 24 * (v22 & v11));
      uint64_t v15 = *v13;
      uint64_t v14 = v13[1];
      if (v5 == *v13 && v6 == v14) {
        goto LABEL_10;
      }
    }
    uint64_t result = 0;
    if (v17) {
      unint64_t v13 = v17;
    }
  }
LABEL_10:
  *a3 = v13;
  return result;
}

void *sub_1CBFEC774(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 4;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      BOOL v24 = 0;
LABEL_28:
      unint64_t v13 = sub_1CBFEC8AC(a1, (uint64_t)a2, a2, v24);
      *unint64_t v13 = *a2;
      v13[1] = a2[1];
      *((_DWORD *)v13 + 4) = 0;
      return v13;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  uint64_t v5 = *a2;
  uint64_t v6 = a2[1];
  unint64_t v7 = ((v6 >> 4) ^ (v6 >> 9) | ((unint64_t)((*a2 >> 4) ^ (*a2 >> 9)) << 32))
     + ~((unint64_t)((v6 >> 4) ^ (v6 >> 9)) << 32);
  unint64_t v8 = (v7 ^ (v7 >> 22)) + ~((v7 ^ (v7 >> 22)) << 13);
  unint64_t v9 = (9 * (v8 ^ (v8 >> 8))) ^ ((9 * (v8 ^ (v8 >> 8))) >> 15);
  int v10 = ((v9 + ~(v9 << 27)) >> 31) ^ (v9 + ~(v9 << 27));
  int v11 = v4 - 1;
  unsigned int v12 = (v4 - 1) & v10;
  unint64_t v13 = (void *)(v3 + 24 * v12);
  uint64_t v15 = *v13;
  uint64_t v14 = v13[1];
  if (*a2 != *v13 || v6 != v14)
  {
    int v18 = 0;
    int v19 = 1;
    while (v15 != -4096 || v14 != -4096)
    {
      if (v18) {
        BOOL v20 = 0;
      }
      else {
        BOOL v20 = v14 == -8192;
      }
      if (v20 && v15 == -8192) {
        int v18 = v13;
      }
      unsigned int v22 = v12 + v19++;
      unsigned int v12 = v22 & v11;
      unint64_t v13 = (void *)(v3 + 24 * (v22 & v11));
      uint64_t v15 = *v13;
      uint64_t v14 = v13[1];
      if (v5 == *v13 && v6 == v14) {
        return v13;
      }
    }
    if (v18) {
      BOOL v24 = v18;
    }
    else {
      BOOL v24 = v13;
    }
    goto LABEL_28;
  }
  return v13;
}

void *sub_1CBFEC8AC(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  int v6 = *(_DWORD *)a1;
  int v7 = *(_DWORD *)a1 >> 1;
  if (*(_DWORD *)a1) {
    unsigned int v8 = 4;
  }
  else {
    unsigned int v8 = *(_DWORD *)(a1 + 16);
  }
  if (4 * v7 + 4 >= 3 * v8)
  {
    sub_1CBFEC320(a1, 2 * v8);
    uint64_t v11 = a1 + 8;
    int v6 = *(_DWORD *)a1;
    if (*(_DWORD *)a1)
    {
      int v12 = 4;
    }
    else
    {
      int v12 = *(_DWORD *)(a1 + 16);
      if (!v12)
      {
        int v9 = 0;
        a4 = 0;
        goto LABEL_7;
      }
      uint64_t v11 = *(void *)(a1 + 8);
    }
    int v9 = *(_DWORD *)a1 & 1;
    uint64_t v13 = a3[1];
    unint64_t v14 = ((v13 >> 4) ^ (v13 >> 9) | ((unint64_t)((*a3 >> 4) ^ (*a3 >> 9)) << 32))
        + ~((unint64_t)((v13 >> 4) ^ (v13 >> 9)) << 32);
    unint64_t v15 = (v14 ^ (v14 >> 22)) + ~((v14 ^ (v14 >> 22)) << 13);
    unint64_t v16 = (9 * (v15 ^ (v15 >> 8))) ^ ((9 * (v15 ^ (v15 >> 8))) >> 15);
    int v17 = v12 - 1;
    unsigned int v18 = v17 & (((v16 + ~(v16 << 27)) >> 31) ^ (v16 + ~(v16 << 27)));
    a4 = (void *)(v11 + 24 * v18);
    uint64_t v20 = *a4;
    uint64_t v19 = a4[1];
    if (*a3 != *a4 || v13 != v19)
    {
      unsigned int v22 = 0;
      int v23 = 1;
      while (v20 != -4096 || v19 != -4096)
      {
        if (v22) {
          BOOL v24 = 0;
        }
        else {
          BOOL v24 = v19 == -8192;
        }
        if (v24 && v20 == -8192) {
          unsigned int v22 = a4;
        }
        unsigned int v26 = v18 + v23++;
        unsigned int v18 = v26 & v17;
        a4 = (void *)(v11 + 24 * v18);
        uint64_t v20 = *a4;
        uint64_t v19 = a4[1];
        if (*a3 == *a4 && v13 == v19) {
          goto LABEL_7;
        }
      }
      if (v22) {
        a4 = v22;
      }
    }
  }
  else
  {
    if (v8 + ~v7 - *(_DWORD *)(a1 + 4) <= v8 >> 3)
    {
      sub_1CBFEC320(a1, v8);
      uint64_t v28 = 0;
      sub_1CBFEC66C(a1, a3, &v28);
      a4 = v28;
      int v6 = *(_DWORD *)a1;
    }
    int v9 = v6 & 1;
  }
LABEL_7:
  *(_DWORD *)a1 = (v6 & 0xFFFFFFFE | v9) + 2;
  if (*a4 != -4096 || a4[1] != -4096) {
    --*(_DWORD *)(a1 + 4);
  }
  return a4;
}

void sub_1CBFECA88(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4, char a5)
{
uint64_t *sub_1CBFECDF4(uint64_t *result, uint64_t *a2, uint64_t a3)
{
  if (result == a2) {
    return result;
  }
  uint64_t v34 = v3;
  uint64_t v35 = v4;
  char v5 = a2;
  char v6 = result;
  int v7 = result + 2;
  if (result + 2 == a2) {
    return result;
  }
  uint64_t v9 = 0;
  int v10 = result;
  do
  {
    uint64_t v11 = v10;
    int v10 = v7;
    uint64_t v12 = *(void *)a3;
    unint64_t v13 = v11[3] & 0xFFFFFFFFFFFFFFF8;
    uint64_t v32 = v11[2];
    unint64_t v33 = v13;
    uint64_t v14 = sub_1CBFEC774(v12, &v32);
    uint64_t v15 = *(void *)a3;
    unint64_t v16 = v11[1] & 0xFFFFFFFFFFFFFFF8;
    uint64_t v32 = *v11;
    unint64_t v33 = v16;
    uint64_t result = sub_1CBFEC774(v15, &v32);
    int v17 = *((_DWORD *)v14 + 4);
    int v18 = *((_DWORD *)result + 4);
    if (**(unsigned char **)(a3 + 8))
    {
      if (v17 >= v18) {
        goto LABEL_17;
      }
    }
    else if (v17 <= v18)
    {
      goto LABEL_17;
    }
    uint64_t v20 = v11[2];
    uint64_t v19 = v11[3];
    *(_OWORD *)int v10 = *(_OWORD *)v11;
    unint64_t v21 = v6;
    if (v11 == v6) {
      goto LABEL_16;
    }
    uint64_t v31 = v19;
    unint64_t v22 = v19 & 0xFFFFFFFFFFFFFFF8;
    uint64_t v23 = v9;
    while (1)
    {
      uint64_t v24 = *(void *)a3;
      uint64_t v32 = v20;
      unint64_t v33 = v22;
      int v25 = sub_1CBFEC774(v24, &v32);
      uint64_t v26 = *(void *)a3;
      unint64_t v27 = *(uint64_t *)((char *)v6 + v23 - 8) & 0xFFFFFFFFFFFFFFF8;
      uint64_t v32 = *(uint64_t *)((char *)v6 + v23 - 16);
      unint64_t v33 = v27;
      uint64_t result = sub_1CBFEC774(v26, &v32);
      int v28 = *((_DWORD *)v25 + 4);
      int v29 = *((_DWORD *)result + 4);
      if (!**(unsigned char **)(a3 + 8)) {
        break;
      }
      if (v28 >= v29)
      {
        unint64_t v21 = (uint64_t *)((char *)v6 + v23);
        goto LABEL_15;
      }
LABEL_10:
      v11 -= 2;
      *(_OWORD *)((char *)v6 + v23) = *(_OWORD *)((char *)v6 + v23 - 16);
      v23 -= 16;
      if (!v23)
      {
        unint64_t v21 = v6;
        goto LABEL_15;
      }
    }
    if (v28 > v29) {
      goto LABEL_10;
    }
    unint64_t v21 = v11;
LABEL_15:
    char v5 = a2;
    uint64_t v19 = v31;
LABEL_16:
    *unint64_t v21 = v20;
    v21[1] = v19;
LABEL_17:
    int v7 = v10 + 2;
    v9 += 16;
  }
  while (v10 + 2 != v5);
  return result;
}

uint64_t *sub_1CBFECF90(uint64_t *result, uint64_t *a2, uint64_t a3)
{
  if (result != a2)
  {
    uint64_t v29 = v3;
    uint64_t v30 = v4;
    char v6 = result;
    for (uint64_t i = result + 2; v6 + 2 != a2; uint64_t i = v6 + 2)
    {
      uint64_t v9 = v6;
      char v6 = i;
      uint64_t v10 = *(void *)a3;
      unint64_t v11 = v9[3] & 0xFFFFFFFFFFFFFFF8;
      uint64_t v27 = v9[2];
      unint64_t v28 = v11;
      uint64_t v12 = sub_1CBFEC774(v10, &v27);
      uint64_t v13 = *(void *)a3;
      unint64_t v14 = v9[1] & 0xFFFFFFFFFFFFFFF8;
      uint64_t v27 = *v9;
      unint64_t v28 = v14;
      uint64_t result = sub_1CBFEC774(v13, &v27);
      int v15 = *((_DWORD *)v12 + 4);
      int v16 = *((_DWORD *)result + 4);
      if (**(unsigned char **)(a3 + 8))
      {
        if (v15 < v16)
        {
LABEL_5:
          uint64_t v17 = *v6;
          uint64_t v18 = v9[3];
          do
          {
            while (1)
            {
              uint64_t v19 = v9;
              *((_OWORD *)v9 + sub_1CD456CB4((void *)this + 1) = *(_OWORD *)v9;
              uint64_t v20 = *(void *)a3;
              uint64_t v27 = v17;
              unint64_t v28 = v18 & 0xFFFFFFFFFFFFFFF8;
              unint64_t v21 = sub_1CBFEC774(v20, &v27);
              uint64_t v22 = *(void *)a3;
              uint64_t v23 = *(v9 - 2);
              uint64_t v24 = *(v9 - 1);
              v9 -= 2;
              uint64_t v27 = v23;
              unint64_t v28 = v24 & 0xFFFFFFFFFFFFFFF8;
              uint64_t result = sub_1CBFEC774(v22, &v27);
              int v25 = *((_DWORD *)v21 + 4);
              int v26 = *((_DWORD *)result + 4);
              if (**(unsigned char **)(a3 + 8)) {
                break;
              }
              if (v25 <= v26) {
                goto LABEL_10;
              }
            }
          }
          while (v25 < v26);
LABEL_10:
          *uint64_t v19 = v17;
          v19[1] = v18;
        }
      }
      else if (v15 > v16)
      {
        goto LABEL_5;
      }
    }
  }
  return result;
}

uint64_t sub_1CBFED0D4(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v8 = *(void *)a4;
  unint64_t v9 = a2[1] & 0xFFFFFFFFFFFFFFF8;
  uint64_t v54 = *a2;
  unint64_t v55 = v9;
  uint64_t v10 = sub_1CBFEC774(v8, &v54);
  uint64_t v11 = *(void *)a4;
  unint64_t v12 = a1[1] & 0xFFFFFFFFFFFFFFF8;
  uint64_t v54 = *a1;
  unint64_t v55 = v12;
  uint64_t v13 = sub_1CBFEC774(v11, &v54);
  int v14 = *((_DWORD *)v10 + 4);
  int v15 = *((_DWORD *)v13 + 4);
  if (!**(unsigned char **)(a4 + 8))
  {
    if (v14 > v15) {
      goto LABEL_3;
    }
LABEL_7:
    uint64_t v25 = *(void *)a4;
    unint64_t v26 = a3[1] & 0xFFFFFFFFFFFFFFF8;
    uint64_t v54 = *a3;
    unint64_t v55 = v26;
    uint64_t v27 = sub_1CBFEC774(v25, &v54);
    uint64_t v28 = *(void *)a4;
    unint64_t v29 = a2[1] & 0xFFFFFFFFFFFFFFF8;
    uint64_t v54 = *a2;
    unint64_t v55 = v29;
    uint64_t v30 = sub_1CBFEC774(v28, &v54);
    int v31 = *((_DWORD *)v27 + 4);
    int v32 = *((_DWORD *)v30 + 4);
    if (**(unsigned char **)(a4 + 8))
    {
      if (v31 < v32) {
        goto LABEL_9;
      }
    }
    else if (v31 > v32)
    {
LABEL_9:
      long long v33 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)a3 = v33;
      uint64_t v34 = *(void *)a4;
      unint64_t v35 = a2[1] & 0xFFFFFFFFFFFFFFF8;
      uint64_t v54 = *a2;
      unint64_t v55 = v35;
      unint64_t v36 = sub_1CBFEC774(v34, &v54);
      uint64_t v37 = *(void *)a4;
      unint64_t v38 = a1[1] & 0xFFFFFFFFFFFFFFF8;
      uint64_t v54 = *a1;
      unint64_t v55 = v38;
      long long v39 = sub_1CBFEC774(v37, &v54);
      int v40 = *((_DWORD *)v36 + 4);
      int v41 = *((_DWORD *)v39 + 4);
      if (**(unsigned char **)(a4 + 8))
      {
        if (v40 >= v41) {
          return 1;
        }
      }
      else if (v40 <= v41)
      {
        return 1;
      }
      long long v42 = *(_OWORD *)a1;
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_OWORD *)a2 = v42;
      return 2;
    }
    return 0;
  }
  if (v14 >= v15) {
    goto LABEL_7;
  }
LABEL_3:
  uint64_t v16 = *(void *)a4;
  unint64_t v17 = a3[1] & 0xFFFFFFFFFFFFFFF8;
  uint64_t v54 = *a3;
  unint64_t v55 = v17;
  uint64_t v18 = sub_1CBFEC774(v16, &v54);
  uint64_t v19 = *(void *)a4;
  unint64_t v20 = a2[1] & 0xFFFFFFFFFFFFFFF8;
  uint64_t v54 = *a2;
  unint64_t v55 = v20;
  unint64_t v21 = sub_1CBFEC774(v19, &v54);
  int v22 = *((_DWORD *)v18 + 4);
  int v23 = *((_DWORD *)v21 + 4);
  if (**(unsigned char **)(a4 + 8))
  {
    if (v22 < v23) {
      goto LABEL_5;
    }
    goto LABEL_13;
  }
  if (v22 <= v23)
  {
LABEL_13:
    long long v43 = *(_OWORD *)a1;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_OWORD *)a2 = v43;
    uint64_t v44 = *(void *)a4;
    unint64_t v45 = a3[1] & 0xFFFFFFFFFFFFFFF8;
    uint64_t v54 = *a3;
    unint64_t v55 = v45;
    uint64_t v46 = sub_1CBFEC774(v44, &v54);
    uint64_t v47 = *(void *)a4;
    unint64_t v48 = a2[1] & 0xFFFFFFFFFFFFFFF8;
    uint64_t v54 = *a2;
    unint64_t v55 = v48;
    uint64_t v49 = sub_1CBFEC774(v47, &v54);
    int v50 = *((_DWORD *)v46 + 4);
    int v51 = *((_DWORD *)v49 + 4);
    if (**(unsigned char **)(a4 + 8))
    {
      if (v50 >= v51) {
        return 1;
      }
    }
    else if (v50 <= v51)
    {
      return 1;
    }
    long long v52 = *(_OWORD *)a2;
    *(_OWORD *)a2 = *(_OWORD *)a3;
    *(_OWORD *)a3 = v52;
    return 2;
  }
LABEL_5:
  long long v24 = *(_OWORD *)a1;
  *(_OWORD *)a1 = *(_OWORD *)a3;
  *(_OWORD *)a3 = v24;
  return 1;
}

void *sub_1CBFED32C(uint64_t *a1, void *a2, uint64_t a3)
{
  uint64_t v6 = *a1;
  uint64_t v7 = a1[1];
  uint64_t v8 = *(void *)a3;
  *(void *)&long long v56 = v6;
  *((void *)&v56 + sub_1CD456CB4((void *)this + 1) = v7 & 0xFFFFFFFFFFFFFFF8;
  unint64_t v9 = sub_1CBFEC774(v8, (uint64_t *)&v56);
  uint64_t v10 = *(void *)a3;
  unint64_t v11 = *(a2 - 1) & 0xFFFFFFFFFFFFFFF8;
  *(void *)&long long v56 = *(a2 - 2);
  *((void *)&v56 + sub_1CD456CB4((void *)this + 1) = v11;
  unint64_t v12 = sub_1CBFEC774(v10, (uint64_t *)&v56);
  int v13 = *((_DWORD *)v9 + 4);
  int v14 = *((_DWORD *)v12 + 4);
  if (**(unsigned char **)(a3 + 8))
  {
    if (v13 < v14)
    {
LABEL_3:
      int v15 = a1 + 2;
      do
      {
        while (1)
        {
          uint64_t i = v15;
          uint64_t v17 = *(void *)a3;
          *(void *)&long long v56 = v6;
          *((void *)&v56 + sub_1CD456CB4((void *)this + 1) = v7 & 0xFFFFFFFFFFFFFFF8;
          uint64_t v18 = sub_1CBFEC774(v17, (uint64_t *)&v56);
          uint64_t v19 = *(void *)a3;
          unint64_t v20 = i[1] & 0xFFFFFFFFFFFFFFF8;
          *(void *)&long long v56 = *i;
          *((void *)&v56 + sub_1CD456CB4((void *)this + 1) = v20;
          unint64_t v21 = sub_1CBFEC774(v19, (uint64_t *)&v56);
          int v22 = *((_DWORD *)v18 + 4);
          int v23 = *((_DWORD *)v21 + 4);
          int v15 = i + 2;
          if (**(unsigned char **)(a3 + 8)) {
            break;
          }
          if (v22 > v23) {
            goto LABEL_16;
          }
        }
      }
      while (v22 >= v23);
      goto LABEL_16;
    }
  }
  else if (v13 > v14)
  {
    goto LABEL_3;
  }
  for (uint64_t i = a1 + 2; i < a2; i += 2)
  {
    uint64_t v24 = *(void *)a3;
    *(void *)&long long v56 = v6;
    *((void *)&v56 + sub_1CD456CB4((void *)this + 1) = v7 & 0xFFFFFFFFFFFFFFF8;
    uint64_t v25 = sub_1CBFEC774(v24, (uint64_t *)&v56);
    uint64_t v26 = *(void *)a3;
    unint64_t v27 = i[1] & 0xFFFFFFFFFFFFFFF8;
    *(void *)&long long v56 = *i;
    *((void *)&v56 + sub_1CD456CB4((void *)this + 1) = v27;
    uint64_t v28 = sub_1CBFEC774(v26, (uint64_t *)&v56);
    int v29 = *((_DWORD *)v25 + 4);
    int v30 = *((_DWORD *)v28 + 4);
    if (**(unsigned char **)(a3 + 8))
    {
      if (v29 < v30) {
        break;
      }
    }
    else if (v29 > v30)
    {
      break;
    }
  }
LABEL_16:
  if (i < a2)
  {
    int v31 = a2 - 2;
    do
    {
      while (1)
      {
        a2 = v31;
        uint64_t v32 = *(void *)a3;
        *(void *)&long long v56 = v6;
        *((void *)&v56 + sub_1CD456CB4((void *)this + 1) = v7 & 0xFFFFFFFFFFFFFFF8;
        long long v33 = sub_1CBFEC774(v32, (uint64_t *)&v56);
        uint64_t v34 = *(void *)a3;
        unint64_t v35 = a2[1] & 0xFFFFFFFFFFFFFFF8;
        *(void *)&long long v56 = *a2;
        *((void *)&v56 + sub_1CD456CB4((void *)this + 1) = v35;
        unint64_t v36 = sub_1CBFEC774(v34, (uint64_t *)&v56);
        int v37 = *((_DWORD *)v33 + 4);
        int v38 = *((_DWORD *)v36 + 4);
        int v31 = a2 - 2;
        if (**(unsigned char **)(a3 + 8)) {
          break;
        }
        if (v37 <= v38) {
          goto LABEL_33;
        }
      }
    }
    while (v37 < v38);
  }
LABEL_33:
  while (i < a2)
  {
    long long v56 = *(_OWORD *)i;
    *(_OWORD *)uint64_t i = *(_OWORD *)a2;
    *(_OWORD *)a2 = v56;
    long long v39 = i + 2;
    do
    {
      while (1)
      {
        uint64_t i = v39;
        uint64_t v40 = *(void *)a3;
        *(void *)&long long v56 = v6;
        *((void *)&v56 + sub_1CD456CB4((void *)this + 1) = v7 & 0xFFFFFFFFFFFFFFF8;
        int v41 = sub_1CBFEC774(v40, (uint64_t *)&v56);
        uint64_t v42 = *(void *)a3;
        unint64_t v43 = i[1] & 0xFFFFFFFFFFFFFFF8;
        *(void *)&long long v56 = *i;
        *((void *)&v56 + sub_1CD456CB4((void *)this + 1) = v43;
        uint64_t v44 = sub_1CBFEC774(v42, (uint64_t *)&v56);
        int v45 = *((_DWORD *)v41 + 4);
        int v46 = *((_DWORD *)v44 + 4);
        long long v39 = i + 2;
        if (**(unsigned char **)(a3 + 8)) {
          break;
        }
        if (v45 > v46) {
          goto LABEL_28;
        }
      }
    }
    while (v45 >= v46);
LABEL_28:
    uint64_t v47 = a2 - 2;
    do
    {
      while (1)
      {
        a2 = v47;
        uint64_t v48 = *(void *)a3;
        *(void *)&long long v56 = v6;
        *((void *)&v56 + sub_1CD456CB4((void *)this + 1) = v7 & 0xFFFFFFFFFFFFFFF8;
        uint64_t v49 = sub_1CBFEC774(v48, (uint64_t *)&v56);
        uint64_t v50 = *(void *)a3;
        unint64_t v51 = a2[1] & 0xFFFFFFFFFFFFFFF8;
        *(void *)&long long v56 = *a2;
        *((void *)&v56 + sub_1CD456CB4((void *)this + 1) = v51;
        long long v52 = sub_1CBFEC774(v50, (uint64_t *)&v56);
        int v53 = *((_DWORD *)v49 + 4);
        int v54 = *((_DWORD *)v52 + 4);
        uint64_t v47 = a2 - 2;
        if (**(unsigned char **)(a3 + 8)) {
          break;
        }
        if (v53 <= v54) {
          goto LABEL_33;
        }
      }
    }
    while (v53 < v54);
  }
  if (i - 2 != a1) {
    *(_OWORD *)a1 = *((_OWORD *)i - 1);
  }
  *(i - 2) = v6;
  *(i - sub_1CD456CB4((void *)this + 1) = v7;
  return i;
}

uint64_t *sub_1CBFED5E4(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = *a1;
  uint64_t v8 = a1[1];
  while (1)
  {
    uint64_t v9 = *(void *)a3;
    unint64_t v10 = a1[v6 + 3] & 0xFFFFFFFFFFFFFFF8;
    *(void *)&long long v52 = a1[v6 + 2];
    *((void *)&v52 + sub_1CD456CB4((void *)this + 1) = v10;
    unint64_t v11 = sub_1CBFEC774(v9, (uint64_t *)&v52);
    uint64_t v12 = *(void *)a3;
    *(void *)&long long v52 = v7;
    *((void *)&v52 + sub_1CD456CB4((void *)this + 1) = v8 & 0xFFFFFFFFFFFFFFF8;
    int v13 = sub_1CBFEC774(v12, (uint64_t *)&v52);
    int v14 = *((_DWORD *)v11 + 4);
    int v15 = *((_DWORD *)v13 + 4);
    if (**(unsigned char **)(a3 + 8)) {
      break;
    }
    if (v14 <= v15) {
      goto LABEL_6;
    }
LABEL_4:
    v6 += 2;
  }
  if (v14 < v15) {
    goto LABEL_4;
  }
LABEL_6:
  unint64_t v16 = (unint64_t)&a1[v6 + 2];
  if (v6 * 8)
  {
    uint64_t v17 = a2 - 2;
    do
    {
      while (1)
      {
        a2 = v17;
        uint64_t v18 = *(void *)a3;
        unint64_t v19 = v17[1] & 0xFFFFFFFFFFFFFFF8;
        *(void *)&long long v52 = *v17;
        *((void *)&v52 + sub_1CD456CB4((void *)this + 1) = v19;
        unint64_t v20 = sub_1CBFEC774(v18, (uint64_t *)&v52);
        uint64_t v21 = *(void *)a3;
        *(void *)&long long v52 = v7;
        *((void *)&v52 + sub_1CD456CB4((void *)this + 1) = v8 & 0xFFFFFFFFFFFFFFF8;
        int v22 = sub_1CBFEC774(v21, (uint64_t *)&v52);
        int v23 = *((_DWORD *)v20 + 4);
        int v24 = *((_DWORD *)v22 + 4);
        uint64_t v17 = a2 - 2;
        if (**(unsigned char **)(a3 + 8)) {
          break;
        }
        if (v23 > v24) {
          goto LABEL_21;
        }
      }
    }
    while (v23 >= v24);
  }
  else if (v16 < (unint64_t)a2)
  {
    uint64_t v25 = a2 - 2;
    do
    {
      while (1)
      {
        a2 = v25;
        uint64_t v26 = *(void *)a3;
        unint64_t v27 = v25[1] & 0xFFFFFFFFFFFFFFF8;
        *(void *)&long long v52 = *v25;
        *((void *)&v52 + sub_1CD456CB4((void *)this + 1) = v27;
        uint64_t v28 = sub_1CBFEC774(v26, (uint64_t *)&v52);
        uint64_t v29 = *(void *)a3;
        *(void *)&long long v52 = v7;
        *((void *)&v52 + sub_1CD456CB4((void *)this + 1) = v8 & 0xFFFFFFFFFFFFFFF8;
        int v30 = sub_1CBFEC774(v29, (uint64_t *)&v52);
        int v31 = *((_DWORD *)v28 + 4);
        int v32 = *((_DWORD *)v30 + 4);
        uint64_t v25 = a2 - 2;
        if (**(unsigned char **)(a3 + 8)) {
          break;
        }
        if (v16 >= (unint64_t)a2 || v31 > v32) {
          goto LABEL_21;
        }
      }
    }
    while (v16 < (unint64_t)a2 && v31 >= v32);
  }
LABEL_21:
  long long v33 = &a1[v6 + 2];
  if (v16 < (unint64_t)a2)
  {
    uint64_t v34 = a2;
    do
    {
      long long v52 = *(_OWORD *)v33;
      *(_OWORD *)long long v33 = *(_OWORD *)v34;
      *(_OWORD *)uint64_t v34 = v52;
      unint64_t v35 = v33 + 2;
      do
      {
        while (1)
        {
          long long v33 = v35;
          uint64_t v36 = *(void *)a3;
          unint64_t v37 = v35[1] & 0xFFFFFFFFFFFFFFF8;
          *(void *)&long long v52 = *v35;
          *((void *)&v52 + sub_1CD456CB4((void *)this + 1) = v37;
          int v38 = sub_1CBFEC774(v36, (uint64_t *)&v52);
          uint64_t v39 = *(void *)a3;
          *(void *)&long long v52 = v7;
          *((void *)&v52 + sub_1CD456CB4((void *)this + 1) = v8 & 0xFFFFFFFFFFFFFFF8;
          uint64_t v40 = sub_1CBFEC774(v39, (uint64_t *)&v52);
          int v41 = *((_DWORD *)v38 + 4);
          int v42 = *((_DWORD *)v40 + 4);
          unint64_t v35 = v33 + 2;
          if (**(unsigned char **)(a3 + 8)) {
            break;
          }
          if (v41 <= v42) {
            goto LABEL_28;
          }
        }
      }
      while (v41 < v42);
LABEL_28:
      unint64_t v43 = v34 - 2;
      do
      {
        while (1)
        {
          uint64_t v34 = v43;
          uint64_t v44 = *(void *)a3;
          unint64_t v45 = v43[1] & 0xFFFFFFFFFFFFFFF8;
          *(void *)&long long v52 = *v43;
          *((void *)&v52 + sub_1CD456CB4((void *)this + 1) = v45;
          int v46 = sub_1CBFEC774(v44, (uint64_t *)&v52);
          uint64_t v47 = *(void *)a3;
          *(void *)&long long v52 = v7;
          *((void *)&v52 + sub_1CD456CB4((void *)this + 1) = v8 & 0xFFFFFFFFFFFFFFF8;
          uint64_t v48 = sub_1CBFEC774(v47, (uint64_t *)&v52);
          int v49 = *((_DWORD *)v46 + 4);
          int v50 = *((_DWORD *)v48 + 4);
          unint64_t v43 = v34 - 2;
          if (**(unsigned char **)(a3 + 8)) {
            break;
          }
          if (v49 > v50) {
            goto LABEL_33;
          }
        }
      }
      while (v49 >= v50);
LABEL_33:
      ;
    }
    while (v33 < v34);
  }
  uint64_t result = v33 - 2;
  if (v33 - 2 != a1) {
    *(_OWORD *)a1 = *(_OWORD *)result;
  }
  *(v33 - 2) = v7;
  *(v33 - sub_1CD456CB4((void *)this + 1) = v8;
  return result;
}

BOOL sub_1CBFED890(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = a2;
  uint64_t v6 = ((char *)a2 - (char *)a1) >> 4;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v8 = *(void *)a3;
      uint64_t v9 = *(a2 - 1);
      unint64_t v10 = a2 - 2;
      uint64_t v45 = *(a2 - 2);
      unint64_t v46 = v9 & 0xFFFFFFFFFFFFFFF8;
      unint64_t v11 = sub_1CBFEC774(v8, &v45);
      uint64_t v12 = *(void *)a3;
      unint64_t v13 = a1[1] & 0xFFFFFFFFFFFFFFF8;
      uint64_t v45 = *a1;
      unint64_t v46 = v13;
      int v14 = sub_1CBFEC774(v12, &v45);
      int v15 = *((_DWORD *)v11 + 4);
      int v16 = *((_DWORD *)v14 + 4);
      if (!**(unsigned char **)(a3 + 8))
      {
        if (v15 <= v16) {
          return 1;
        }
        goto LABEL_4;
      }
      if (v15 < v16)
      {
LABEL_4:
        long long v17 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v10;
        *(_OWORD *)unint64_t v10 = v17;
      }
      return 1;
    case 3:
      sub_1CBFED0D4(a1, a1 + 2, a2 - 2, a3);
      return 1;
    case 4:
      sub_1CBFEDB68(a1, a1 + 2, a1 + 4, a2 - 2, a3);
      return 1;
    case 5:
      sub_1CBFEDCF0(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2, a3);
      return 1;
    default:
      uint64_t v18 = a1 + 4;
      sub_1CBFED0D4(a1, a1 + 2, a1 + 4, a3);
      unint64_t v19 = a1 + 6;
      if (a1 + 6 == v4) {
        return 1;
      }
      uint64_t v20 = 0;
      int v21 = 0;
      int v42 = v4;
      while (2)
      {
        uint64_t v22 = *(void *)a3;
        unint64_t v23 = v19[1] & 0xFFFFFFFFFFFFFFF8;
        uint64_t v45 = *v19;
        unint64_t v46 = v23;
        int v24 = sub_1CBFEC774(v22, &v45);
        uint64_t v25 = *(void *)a3;
        unint64_t v26 = v18[1] & 0xFFFFFFFFFFFFFFF8;
        uint64_t v45 = *v18;
        unint64_t v46 = v26;
        unint64_t v27 = sub_1CBFEC774(v25, &v45);
        int v28 = *((_DWORD *)v24 + 4);
        int v29 = *((_DWORD *)v27 + 4);
        if (**(unsigned char **)(a3 + 8))
        {
          if (v28 >= v29) {
            goto LABEL_22;
          }
        }
        else if (v28 <= v29)
        {
          goto LABEL_22;
        }
        uint64_t v31 = *v19;
        uint64_t v30 = v19[1];
        *(_OWORD *)unint64_t v19 = *(_OWORD *)v18;
        int v32 = a1;
        if (v18 == a1) {
          goto LABEL_21;
        }
        int v44 = v21;
        uint64_t v43 = v30;
        unint64_t v33 = v30 & 0xFFFFFFFFFFFFFFF8;
        uint64_t v34 = v20;
        while (2)
        {
          uint64_t v35 = *(void *)a3;
          uint64_t v45 = v31;
          unint64_t v46 = v33;
          uint64_t v36 = sub_1CBFEC774(v35, &v45);
          uint64_t v37 = *(void *)a3;
          uint64_t v38 = *(uint64_t *)((char *)a1 + v34 + 24);
          uint64_t v45 = *(uint64_t *)((char *)a1 + v34 + 16);
          unint64_t v46 = v38 & 0xFFFFFFFFFFFFFFF8;
          uint64_t v39 = sub_1CBFEC774(v37, &v45);
          int v40 = *((_DWORD *)v36 + 4);
          int v41 = *((_DWORD *)v39 + 4);
          if (**(unsigned char **)(a3 + 8))
          {
            if (v40 >= v41)
            {
              int v32 = (uint64_t *)((char *)a1 + v34 + 32);
              goto LABEL_20;
            }
            goto LABEL_15;
          }
          if (v40 > v41)
          {
LABEL_15:
            v18 -= 2;
            *(_OWORD *)((char *)a1 + v34 + 32) = *(_OWORD *)((char *)a1 + v34 + 16);
            v34 -= 16;
            if (v34 == -32)
            {
              int v32 = a1;
              goto LABEL_20;
            }
            continue;
          }
          break;
        }
        int v32 = v18;
LABEL_20:
        uint64_t v4 = v42;
        uint64_t v30 = v43;
        int v21 = v44;
LABEL_21:
        *int v32 = v31;
        v32[1] = v30;
        if (++v21 != 8)
        {
LABEL_22:
          uint64_t v18 = v19;
          v20 += 16;
          v19 += 2;
          if (v19 == v4) {
            return 1;
          }
          continue;
        }
        return v19 + 2 == v4;
      }
  }
}

__n128 sub_1CBFEDB68(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  sub_1CBFED0D4(a1, a2, a3, a5);
  uint64_t v10 = *(void *)a5;
  unint64_t v11 = a4[1] & 0xFFFFFFFFFFFFFFF8;
  uint64_t v37 = *a4;
  unint64_t v38 = v11;
  uint64_t v12 = sub_1CBFEC774(v10, &v37);
  uint64_t v13 = *(void *)a5;
  unint64_t v14 = a3[1] & 0xFFFFFFFFFFFFFFF8;
  uint64_t v37 = *a3;
  unint64_t v38 = v14;
  int v15 = sub_1CBFEC774(v13, &v37);
  int v17 = *((_DWORD *)v12 + 4);
  int v18 = *((_DWORD *)v15 + 4);
  if (**(unsigned char **)(a5 + 8))
  {
    if (v17 >= v18) {
      return result;
    }
  }
  else if (v17 <= v18)
  {
    return result;
  }
  long long v19 = *(_OWORD *)a3;
  *(_OWORD *)a3 = *(_OWORD *)a4;
  *(_OWORD *)a4 = v19;
  uint64_t v20 = *(void *)a5;
  unint64_t v21 = a3[1] & 0xFFFFFFFFFFFFFFF8;
  uint64_t v37 = *a3;
  unint64_t v38 = v21;
  uint64_t v22 = sub_1CBFEC774(v20, &v37);
  uint64_t v23 = *(void *)a5;
  unint64_t v24 = a2[1] & 0xFFFFFFFFFFFFFFF8;
  uint64_t v37 = *a2;
  unint64_t v38 = v24;
  uint64_t v25 = sub_1CBFEC774(v23, &v37);
  int v26 = *((_DWORD *)v22 + 4);
  int v27 = *((_DWORD *)v25 + 4);
  if (**(unsigned char **)(a5 + 8))
  {
    if (v26 >= v27) {
      return result;
    }
  }
  else if (v26 <= v27)
  {
    return result;
  }
  long long v28 = *(_OWORD *)a2;
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)a3 = v28;
  uint64_t v29 = *(void *)a5;
  unint64_t v30 = a2[1] & 0xFFFFFFFFFFFFFFF8;
  uint64_t v37 = *a2;
  unint64_t v38 = v30;
  uint64_t v31 = sub_1CBFEC774(v29, &v37);
  uint64_t v32 = *(void *)a5;
  unint64_t v33 = a1[1] & 0xFFFFFFFFFFFFFFF8;
  uint64_t v37 = *a1;
  unint64_t v38 = v33;
  uint64_t v34 = sub_1CBFEC774(v32, &v37);
  int v35 = *((_DWORD *)v31 + 4);
  int v36 = *((_DWORD *)v34 + 4);
  if (**(unsigned char **)(a5 + 8))
  {
    if (v35 >= v36) {
      return result;
    }
  }
  else if (v35 <= v36)
  {
    return result;
  }
  __n128 result = *(__n128 *)a1;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(__n128 *)a2 = result;
  return result;
}

__n128 sub_1CBFEDCF0(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t a6)
{
  sub_1CBFEDB68(a1, a2, a3, a4, a6);
  uint64_t v12 = *(void *)a6;
  unint64_t v13 = a5[1] & 0xFFFFFFFFFFFFFFF8;
  uint64_t v48 = *a5;
  unint64_t v49 = v13;
  unint64_t v14 = sub_1CBFEC774(v12, &v48);
  uint64_t v15 = *(void *)a6;
  unint64_t v16 = a4[1] & 0xFFFFFFFFFFFFFFF8;
  uint64_t v48 = *a4;
  unint64_t v49 = v16;
  int v17 = sub_1CBFEC774(v15, &v48);
  int v19 = *((_DWORD *)v14 + 4);
  int v20 = *((_DWORD *)v17 + 4);
  if (**(unsigned char **)(a6 + 8))
  {
    if (v19 >= v20) {
      return result;
    }
  }
  else if (v19 <= v20)
  {
    return result;
  }
  long long v21 = *(_OWORD *)a4;
  *(_OWORD *)a4 = *(_OWORD *)a5;
  *(_OWORD *)a5 = v21;
  uint64_t v22 = *(void *)a6;
  unint64_t v23 = a4[1] & 0xFFFFFFFFFFFFFFF8;
  uint64_t v48 = *a4;
  unint64_t v49 = v23;
  unint64_t v24 = sub_1CBFEC774(v22, &v48);
  uint64_t v25 = *(void *)a6;
  unint64_t v26 = a3[1] & 0xFFFFFFFFFFFFFFF8;
  uint64_t v48 = *a3;
  unint64_t v49 = v26;
  int v27 = sub_1CBFEC774(v25, &v48);
  int v28 = *((_DWORD *)v24 + 4);
  int v29 = *((_DWORD *)v27 + 4);
  if (**(unsigned char **)(a6 + 8))
  {
    if (v28 >= v29) {
      return result;
    }
  }
  else if (v28 <= v29)
  {
    return result;
  }
  long long v30 = *(_OWORD *)a3;
  *(_OWORD *)a3 = *(_OWORD *)a4;
  *(_OWORD *)a4 = v30;
  uint64_t v31 = *(void *)a6;
  unint64_t v32 = a3[1] & 0xFFFFFFFFFFFFFFF8;
  uint64_t v48 = *a3;
  unint64_t v49 = v32;
  unint64_t v33 = sub_1CBFEC774(v31, &v48);
  uint64_t v34 = *(void *)a6;
  unint64_t v35 = a2[1] & 0xFFFFFFFFFFFFFFF8;
  uint64_t v48 = *a2;
  unint64_t v49 = v35;
  int v36 = sub_1CBFEC774(v34, &v48);
  int v37 = *((_DWORD *)v33 + 4);
  int v38 = *((_DWORD *)v36 + 4);
  if (**(unsigned char **)(a6 + 8))
  {
    if (v37 >= v38) {
      return result;
    }
  }
  else if (v37 <= v38)
  {
    return result;
  }
  long long v39 = *(_OWORD *)a2;
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)a3 = v39;
  uint64_t v40 = *(void *)a6;
  unint64_t v41 = a2[1] & 0xFFFFFFFFFFFFFFF8;
  uint64_t v48 = *a2;
  unint64_t v49 = v41;
  int v42 = sub_1CBFEC774(v40, &v48);
  uint64_t v43 = *(void *)a6;
  unint64_t v44 = a1[1] & 0xFFFFFFFFFFFFFFF8;
  uint64_t v48 = *a1;
  unint64_t v49 = v44;
  uint64_t v45 = sub_1CBFEC774(v43, &v48);
  int v46 = *((_DWORD *)v42 + 4);
  int v47 = *((_DWORD *)v45 + 4);
  if (**(unsigned char **)(a6 + 8))
  {
    if (v46 >= v47) {
      return result;
    }
  }
  else if (v46 <= v47)
  {
    return result;
  }
  __n128 result = *(__n128 *)a1;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(__n128 *)a2 = result;
  return result;
}

uint64_t *sub_1CBFEDEEC(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  if (a1 != a2)
  {
    uint64_t v6 = a2;
    uint64_t v8 = (char *)a2 - (char *)a1;
    uint64_t v9 = ((char *)a2 - (char *)a1) >> 4;
    if ((char *)a2 - (char *)a1 >= 17)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      uint64_t v12 = &a1[2 * v10];
      do
      {
        sub_1CBFEE154(a1, a4, v9, v12);
        v12 -= 2;
        --v11;
      }
      while (v11);
    }
    unint64_t v13 = v6;
    if (v6 != a3)
    {
      unint64_t v14 = v6;
      while (1)
      {
        uint64_t v15 = *(void *)a4;
        unint64_t v16 = v14[1] & 0xFFFFFFFFFFFFFFF8;
        uint64_t v45 = *v14;
        unint64_t v46 = v16;
        int v17 = sub_1CBFEC774(v15, &v45);
        uint64_t v18 = *(void *)a4;
        unint64_t v19 = a1[1] & 0xFFFFFFFFFFFFFFF8;
        uint64_t v45 = *a1;
        unint64_t v46 = v19;
        int v20 = sub_1CBFEC774(v18, &v45);
        int v21 = *((_DWORD *)v17 + 4);
        int v22 = *((_DWORD *)v20 + 4);
        if (**(unsigned char **)(a4 + 8)) {
          break;
        }
        if (v21 > v22) {
          goto LABEL_9;
        }
LABEL_10:
        v14 += 2;
        if (v14 == a3)
        {
          unint64_t v13 = a3;
          goto LABEL_14;
        }
      }
      if (v21 >= v22) {
        goto LABEL_10;
      }
LABEL_9:
      long long v23 = *(_OWORD *)v14;
      *(_OWORD *)unint64_t v14 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v23;
      sub_1CBFEE154(a1, a4, v9, a1);
      goto LABEL_10;
    }
LABEL_14:
    if (v8 < 17)
    {
      return v13;
    }
    else
    {
      int v42 = v13;
      do
      {
        uint64_t v43 = v6;
        uint64_t v24 = 0;
        long long v44 = *(_OWORD *)a1;
        uint64_t v25 = a1;
        do
        {
          unint64_t v26 = &v25[2 * v24 + 2];
          uint64_t v27 = (2 * v24) | 1;
          uint64_t v28 = 2 * v24 + 2;
          if (v28 < v9)
          {
            uint64_t v29 = *(void *)a4;
            unint64_t v30 = v26[1] & 0xFFFFFFFFFFFFFFF8;
            uint64_t v45 = *v26;
            unint64_t v46 = v30;
            uint64_t v31 = sub_1CBFEC774(v29, &v45);
            uint64_t v32 = *(void *)a4;
            unint64_t v33 = v26[3] & 0xFFFFFFFFFFFFFFF8;
            uint64_t v45 = v26[2];
            unint64_t v46 = v33;
            uint64_t v34 = sub_1CBFEC774(v32, &v45);
            int v35 = *((_DWORD *)v31 + 4);
            int v36 = *((_DWORD *)v34 + 4);
            BOOL v37 = v35 < v36;
            BOOL v38 = v35 > v36;
            BOOL v39 = v37;
            if (**(unsigned char **)(a4 + 8) ? v39 : v38)
            {
              v26 += 2;
              uint64_t v27 = v28;
            }
          }
          *(_OWORD *)uint64_t v25 = *(_OWORD *)v26;
          uint64_t v25 = v26;
          uint64_t v24 = v27;
        }
        while (v27 <= (uint64_t)((unint64_t)(v9 - 2) >> 1));
        v6 -= 2;
        if (v26 == v43 - 2)
        {
          *(_OWORD *)unint64_t v26 = v44;
        }
        else
        {
          *(_OWORD *)unint64_t v26 = *(_OWORD *)v6;
          *(_OWORD *)uint64_t v6 = v44;
          sub_1CBFEE3D8(a1, (uint64_t)(v26 + 2), a4, ((char *)(v26 + 2) - (char *)a1) >> 4);
        }
        BOOL v37 = v9-- <= 2;
      }
      while (!v37);
      return v42;
    }
  }
  return a3;
}

void *sub_1CBFEE154(void *result, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v6 = a3 - 2;
  if (a3 >= 2)
  {
    uint64_t v62 = v4;
    uint64_t v63 = v5;
    uint64_t v8 = result;
    uint64_t v9 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) >= ((char *)a4 - (char *)result) >> 4)
    {
      uint64_t v10 = a3;
      uint64_t v12 = a4 - result;
      uint64_t v13 = v12 + 1;
      unint64_t v14 = &result[2 * v12 + 2];
      uint64_t v15 = v12 + 2;
      if (v12 + 2 < a3)
      {
        uint64_t v16 = *(void *)a2;
        unint64_t v17 = v14[1] & 0xFFFFFFFFFFFFFFF8;
        uint64_t v60 = *v14;
        unint64_t v61 = v17;
        uint64_t v18 = sub_1CBFEC774(v16, &v60);
        uint64_t v19 = *(void *)a2;
        unint64_t v20 = v14[3] & 0xFFFFFFFFFFFFFFF8;
        uint64_t v60 = v14[2];
        unint64_t v61 = v20;
        int v21 = sub_1CBFEC774(v19, &v60);
        int v22 = *((_DWORD *)v18 + 4);
        int v23 = *((_DWORD *)v21 + 4);
        BOOL v24 = v22 < v23;
        BOOL v25 = v22 > v23;
        BOOL v26 = v24;
        if (**(unsigned char **)(a2 + 8) ? v26 : v25)
        {
          v14 += 2;
          uint64_t v13 = v15;
        }
      }
      uint64_t v28 = *(void *)a2;
      unint64_t v29 = v14[1] & 0xFFFFFFFFFFFFFFF8;
      uint64_t v60 = *v14;
      unint64_t v61 = v29;
      unint64_t v30 = sub_1CBFEC774(v28, &v60);
      uint64_t v31 = *(void *)a2;
      unint64_t v32 = a4[1] & 0xFFFFFFFFFFFFFFF8;
      uint64_t v60 = *a4;
      unint64_t v61 = v32;
      __n128 result = sub_1CBFEC774(v31, &v60);
      int v33 = *((_DWORD *)v30 + 4);
      int v34 = *((_DWORD *)result + 4);
      if (**(unsigned char **)(a2 + 8))
      {
        if (v33 < v34) {
          return result;
        }
      }
      else if (v33 > v34)
      {
        return result;
      }
      uint64_t v36 = *a4;
      uint64_t v35 = a4[1];
      *(_OWORD *)a4 = *(_OWORD *)v14;
      uint64_t v57 = v35;
      if (v9 >= v13)
      {
        uint64_t v58 = v10;
        unint64_t v59 = v35 & 0xFFFFFFFFFFFFFFF8;
        while (1)
        {
          uint64_t v38 = 2 * v13;
          uint64_t v13 = (2 * v13) | 1;
          BOOL v37 = &v8[2 * v13];
          uint64_t v39 = v38 + 2;
          if (v38 + 2 < v10)
          {
            uint64_t v40 = *(void *)a2;
            unint64_t v41 = v37[1] & 0xFFFFFFFFFFFFFFF8;
            uint64_t v60 = *v37;
            unint64_t v61 = v41;
            int v42 = sub_1CBFEC774(v40, &v60);
            uint64_t v43 = *(void *)a2;
            unint64_t v44 = v37[3] & 0xFFFFFFFFFFFFFFF8;
            uint64_t v60 = v37[2];
            unint64_t v61 = v44;
            uint64_t v45 = sub_1CBFEC774(v43, &v60);
            int v46 = *((_DWORD *)v42 + 4);
            int v47 = *((_DWORD *)v45 + 4);
            BOOL v24 = v46 < v47;
            BOOL v48 = v46 > v47;
            int v49 = v24;
            if (**(unsigned char **)(a2 + 8)) {
              int v50 = v49;
            }
            else {
              int v50 = v48;
            }
            if (v50) {
              v37 += 2;
            }
            uint64_t v10 = v58;
            if (v50) {
              uint64_t v13 = v39;
            }
          }
          uint64_t v51 = *(void *)a2;
          unint64_t v52 = v37[1] & 0xFFFFFFFFFFFFFFF8;
          uint64_t v60 = *v37;
          unint64_t v61 = v52;
          int v53 = sub_1CBFEC774(v51, &v60);
          uint64_t v54 = *(void *)a2;
          uint64_t v60 = v36;
          unint64_t v61 = v59;
          __n128 result = sub_1CBFEC774(v54, &v60);
          int v55 = *((_DWORD *)v53 + 4);
          int v56 = *((_DWORD *)result + 4);
          if (**(unsigned char **)(a2 + 8))
          {
            if (v55 < v56) {
              break;
            }
          }
          else if (v55 > v56)
          {
            break;
          }
          *(_OWORD *)unint64_t v14 = *(_OWORD *)v37;
          unint64_t v14 = v37;
          if (v9 < v13) {
            goto LABEL_16;
          }
        }
      }
      BOOL v37 = v14;
LABEL_16:
      *BOOL v37 = v36;
      v37[1] = v57;
    }
  }
  return result;
}

void *sub_1CBFEE3D8(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = a4 - 2;
  if (a4 >= 2)
  {
    uint64_t v7 = result;
    unint64_t v8 = v4 >> 1;
    uint64_t v9 = &result[2 * (v4 >> 1)];
    uint64_t v10 = *(void *)a3;
    unint64_t v11 = v9[1] & 0xFFFFFFFFFFFFFFF8;
    uint64_t v27 = *v9;
    unint64_t v28 = v11;
    uint64_t v12 = sub_1CBFEC774(v10, &v27);
    uint64_t v13 = *(void *)a3;
    unint64_t v14 = *(void *)(a2 - 8) & 0xFFFFFFFFFFFFFFF8;
    uint64_t v27 = *(void *)(a2 - 16);
    unint64_t v28 = v14;
    __n128 result = sub_1CBFEC774(v13, &v27);
    int v15 = *((_DWORD *)v12 + 4);
    int v16 = *((_DWORD *)result + 4);
    if (**(unsigned char **)(a3 + 8))
    {
      if (v15 >= v16) {
        return result;
      }
    }
    else if (v15 <= v16)
    {
      return result;
    }
    uint64_t v17 = *(void *)(a2 - 16);
    uint64_t v18 = *(void *)(a2 - 8);
    *(_OWORD *)(a2 - 16) = *(_OWORD *)v9;
    if (v4 >= 2)
    {
      while (1)
      {
        unint64_t v20 = v8 - 1;
        unint64_t v8 = (v8 - 1) >> 1;
        uint64_t v19 = &v7[2 * v8];
        uint64_t v21 = *(void *)a3;
        unint64_t v22 = v19[1] & 0xFFFFFFFFFFFFFFF8;
        uint64_t v27 = *v19;
        unint64_t v28 = v22;
        int v23 = sub_1CBFEC774(v21, &v27);
        uint64_t v24 = *(void *)a3;
        uint64_t v27 = v17;
        unint64_t v28 = v18 & 0xFFFFFFFFFFFFFFF8;
        __n128 result = sub_1CBFEC774(v24, &v27);
        int v25 = *((_DWORD *)v23 + 4);
        int v26 = *((_DWORD *)result + 4);
        if (**(unsigned char **)(a3 + 8))
        {
          if (v25 >= v26) {
            break;
          }
        }
        else if (v25 <= v26)
        {
          break;
        }
        *(_OWORD *)uint64_t v9 = *(_OWORD *)v19;
        uint64_t v9 = &v7[2 * v8];
        if (v20 <= 1) {
          goto LABEL_6;
        }
      }
    }
    uint64_t v19 = v9;
LABEL_6:
    *uint64_t v19 = v17;
    v19[1] = v18;
  }
  return result;
}

uint64_t sub_1CBFEE528(uint64_t a1, void *a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 4;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      uint64_t v7 = 0;
      uint64_t result = 0;
      goto LABEL_6;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v4 - 1);
  uint64_t v7 = (void *)(v3 + 72 * v6);
  uint64_t v8 = *v7;
  if (*a2 == *v7)
  {
    uint64_t result = 1;
  }
  else
  {
    uint64_t v10 = 0;
    int v11 = 1;
    uint64_t result = 1;
    while (v8 != -4096)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -8192;
      }
      if (v12) {
        uint64_t v10 = v7;
      }
      unsigned int v13 = v6 + v11++;
      unsigned int v6 = v13 & v5;
      uint64_t v7 = (void *)(v3 + 72 * (v13 & v5));
      uint64_t v8 = *v7;
      if (*a2 == *v7) {
        goto LABEL_6;
      }
    }
    uint64_t result = 0;
    if (v10) {
      uint64_t v7 = v10;
    }
  }
LABEL_6:
  *a3 = v7;
  return result;
}

void *sub_1CBFEE5DC(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *(_DWORD *)a1;
  int v7 = *(_DWORD *)a1 >> 1;
  if (*(_DWORD *)a1) {
    unsigned int v8 = 4;
  }
  else {
    unsigned int v8 = *(_DWORD *)(a1 + 16);
  }
  if (4 * v7 + 4 >= 3 * v8)
  {
    sub_1CBFEE758(a1, 2 * v8);
    uint64_t v11 = a1 + 8;
    int v6 = *(_DWORD *)a1;
    if (*(_DWORD *)a1)
    {
      int v12 = 4;
    }
    else
    {
      int v12 = *(_DWORD *)(a1 + 16);
      if (!v12)
      {
        int v9 = 0;
        a4 = 0;
        goto LABEL_7;
      }
      uint64_t v11 = *(void *)(a1 + 8);
    }
    int v9 = *(_DWORD *)a1 & 1;
    int v13 = v12 - 1;
    unsigned int v14 = ((*a3 >> 4) ^ (*a3 >> 9)) & v13;
    a4 = (void *)(v11 + 72 * v14);
    uint64_t v15 = *a4;
    if (*a3 != *a4)
    {
      int v16 = 0;
      int v17 = 1;
      while (v15 != -4096)
      {
        if (v16) {
          BOOL v18 = 0;
        }
        else {
          BOOL v18 = v15 == -8192;
        }
        if (v18) {
          int v16 = a4;
        }
        unsigned int v19 = v14 + v17++;
        unsigned int v14 = v19 & v13;
        a4 = (void *)(v11 + 72 * v14);
        uint64_t v15 = *a4;
        if (*a3 == *a4) {
          goto LABEL_7;
        }
      }
      if (v16) {
        a4 = v16;
      }
    }
  }
  else
  {
    if (v8 + ~v7 - *(_DWORD *)(a1 + 4) <= v8 >> 3)
    {
      sub_1CBFEE758(a1, v8);
      unint64_t v20 = 0;
      sub_1CBFEE528(a1, a3, &v20);
      a4 = v20;
      int v6 = *(_DWORD *)a1;
    }
    int v9 = v6 & 1;
  }
LABEL_7:
  *(_DWORD *)a1 = (v6 & 0xFFFFFFFE | v9) + 2;
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 4);
  }
  return a4;
}

void sub_1CBFEE758(uint64_t a1, unsigned int a2)
{
  v27[36] = *MEMORY[0x1E4F143B8];
  if (a2 >= 5)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    unint64_t v22 = *(uint64_t **)(a1 + 8);
    unsigned int v23 = *(_DWORD *)(a1 + 16);
    if (a2 <= 4)
    {
      *(_DWORD *)a1 |= 1u;
    }
    else
    {
      uint64_t v24 = a2;
      *(void *)(a1 + 8) = operator new(72 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v24;
    }
    sub_1CBFEEA34((int *)a1, v22, &v22[9 * v23]);
    JUMPOUT(0x1D25D9CD0);
  }
  unsigned int v25 = a2;
  uint64_t v6 = 0;
  uint64_t v7 = a1 + 8;
  unsigned int v8 = v27;
  uint64_t v9 = a1;
  uint64_t v10 = (uint64_t *)(a1 + 8);
  do
  {
    if ((*v10 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      char v11 = 0;
      uint64_t v12 = 0;
      *unsigned int v8 = *v10;
      int v13 = v8 + 1;
      unsigned int v14 = v10 + 1;
      do
      {
        char v15 = v11;
        int v16 = &v13[4 * v12];
        *int v16 = (uint64_t)(v16 + 2);
        v16[1] = 0x200000000;
        if (v13 != v14)
        {
          int v17 = &v14[4 * v12];
          unint64_t v18 = *((unsigned int *)v17 + 2);
          if (*((_DWORD *)v17 + 2))
          {
            unsigned int v19 = (const void *)*v17;
            if ((uint64_t *)*v17 == v17 + 2)
            {
              if (v18 >= 3) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              memcpy(v16 + 2, v19, 8 * *((unsigned int *)v17 + 2));
              *((_DWORD *)v16 + 2) = v18;
            }
            else
            {
              *int v16 = (uint64_t)v19;
              *((_DWORD *)v16 + 2) = v18;
              *((_DWORD *)v16 + 3) = *((_DWORD *)v17 + 3);
              uint64_t *v17 = (uint64_t)(v17 + 2);
              *((_DWORD *)v17 + 3) = 0;
            }
            *((_DWORD *)v17 + 2) = 0;
          }
        }
        char v11 = 1;
        uint64_t v12 = 1;
      }
      while ((v15 & 1) == 0);
      for (uint64_t i = 0; i != -64; i -= 32)
      {
        uint64_t v21 = *(void **)(v9 + i + 48);
        if ((void *)(v9 + i + 64) != v21) {
          free(v21);
        }
      }
      v8 += 9;
    }
    ++v6;
    uint64_t v10 = (uint64_t *)(v7 + 72 * v6);
    v9 += 72;
  }
  while (v6 != 4);
  if (v25 > 4)
  {
    *(_DWORD *)a1 &= ~1u;
    *(void *)(a1 + 8) = operator new(72 * v25, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v25;
  }
  sub_1CBFEEA34((int *)a1, v27, v8);
}

void sub_1CBFEEA34(int *a1, uint64_t *a2, uint64_t *a3)
{
  unint64_t v4 = a2;
  int v6 = *a1;
  *a1 &= 1u;
  a1[1] = 0;
  int v33 = a1 + 2;
  if (v6)
  {
    uint64_t v9 = a1 + 74;
    unsigned int v8 = a1 + 2;
  }
  else
  {
    unsigned int v7 = a1[4];
    if (!v7) {
      goto LABEL_5;
    }
    unsigned int v8 = (void *)*((void *)a1 + 1);
    uint64_t v9 = &v8[9 * v7];
  }
  do
  {
    *unsigned int v8 = -4096;
    v8 += 9;
  }
  while (v8 != v9);
LABEL_5:
  if (a2 != a3)
  {
    do
    {
      uint64_t v10 = *v4;
      if ((*v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        if (*(unsigned char *)a1)
        {
          int v12 = 4;
          char v11 = v33;
        }
        else
        {
          char v11 = (int *)*((void *)a1 + 1);
          int v12 = a1[4];
        }
        int v13 = v12 - 1;
        unsigned int v14 = v13 & ((v10 >> 4) ^ (v10 >> 9));
        char v15 = &v11[18 * v14];
        uint64_t v16 = *(void *)v15;
        if (v10 != *(void *)v15)
        {
          unint64_t v28 = 0;
          int v29 = 1;
          while (v16 != -4096)
          {
            if (v28) {
              BOOL v30 = 0;
            }
            else {
              BOOL v30 = v16 == -8192;
            }
            if (v30) {
              unint64_t v28 = v15;
            }
            unsigned int v31 = v14 + v29++;
            unsigned int v14 = v31 & v13;
            char v15 = &v11[18 * v14];
            uint64_t v16 = *(void *)v15;
            if (v10 == *(void *)v15) {
              goto LABEL_10;
            }
          }
          if (v28) {
            char v15 = v28;
          }
        }
LABEL_10:
        char v17 = 0;
        uint64_t v18 = 0;
        *(void *)char v15 = v10;
        unsigned int v19 = v15 + 2;
        unint64_t v20 = v4 + 1;
        do
        {
          char v21 = v17;
          unint64_t v22 = &v19[4 * v18];
          *unint64_t v22 = v22 + 2;
          v22[1] = 0x200000000;
          if (v19 != v20)
          {
            unsigned int v23 = &v20[4 * v18];
            unint64_t v24 = *((unsigned int *)v23 + 2);
            if (*((_DWORD *)v23 + 2))
            {
              unsigned int v25 = (const void *)*v23;
              if ((void *)*v23 == v23 + 2)
              {
                if (v24 >= 3) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                memcpy(v22 + 2, v25, 8 * *((unsigned int *)v23 + 2));
                *((_DWORD *)v22 + 2) = v24;
              }
              else
              {
                *unint64_t v22 = v25;
                int v32 = *((_DWORD *)v23 + 3);
                *((_DWORD *)v22 + 2) = v24;
                *((_DWORD *)v22 + 3) = v32;
                *unsigned int v23 = v23 + 2;
                *((_DWORD *)v23 + 3) = 0;
              }
              *((_DWORD *)v23 + 2) = 0;
            }
          }
          char v17 = 1;
          uint64_t v18 = 1;
        }
        while ((v21 & 1) == 0);
        uint64_t v26 = 0;
        *a1 += 2;
        do
        {
          uint64_t v27 = (uint64_t *)v4[v26 + 5];
          if (&v4[v26 + 7] != v27) {
            free(v27);
          }
          v26 -= 4;
        }
        while (v26 != -8);
      }
      v4 += 9;
    }
    while (v4 != a3);
  }
}

uint64_t sub_1CBFEEC7C(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 600);
  if (v2 != (void *)(a1 + 616)) {
    free(v2);
  }
  sub_1CBFEECCC(a1 + 296);

  return sub_1CBFEECCC(a1);
}

uint64_t sub_1CBFEECCC(uint64_t a1)
{
  if ((*(unsigned char *)a1 & 1) == 0) {
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 8), 8);
  }
  return a1;
}

void sub_1CBFEED08(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    unint64_t v2 = (void *)(a1 + 8);
    unsigned int v1 = 4;
  }
  else
  {
    unsigned int v1 = *(_DWORD *)(a1 + 16);
    if (!v1) {
      return;
    }
    unint64_t v2 = *(void **)(a1 + 8);
  }
  unint64_t v3 = &v2[9 * v1];
  do
  {
    if (*v2 != -4096 && *v2 != -8192)
    {
      for (uint64_t i = 0; i != -8; i -= 4)
      {
        int v5 = (void *)v2[i + 5];
        if (&v2[i + 7] != v5) {
          free(v5);
        }
      }
    }
    v2 += 9;
  }
  while (v2 != v3);
}

uint64_t sub_1CBFEEDA8(uint64_t a1, unint64_t *a2, uint64_t a3, unsigned int a4)
{
  *(void *)a1 = 1;
  int v6 = (_DWORD *)(a1 + 296);
  for (uint64_t i = 8; i != 296; i += 72)
    *(void *)(a1 + i) = -4096;
  *(void *)(a1 + 296) = 1;
  for (uint64_t j = 304; j != 592; j += 72)
    *(void *)(a1 + j) = -4096;
  *(void *)(a1 + 600) = a1 + 616;
  *(void *)(a1 + 608) = 0x400000000;
  sub_1CBFEBF88(a2, a3, a1 + 600, 1, 0);
  uint64_t v9 = *(unsigned int *)(a1 + 608);
  if (v9)
  {
    uint64_t v10 = *(unint64_t **)(a1 + 600);
    char v11 = &v10[2 * v9];
    do
    {
      unint64_t v12 = *v10;
      unint64_t v13 = v10[1];
      uint64_t v14 = ((v13 & 4) == 0) ^ a4;
      unint64_t v20 = *v10;
      char v15 = &sub_1CBFEEF50((_DWORD *)a1, (uint64_t *)&v20)[4 * v14];
      unint64_t v16 = *((unsigned int *)v15 + 4);
      if (v16 >= *((unsigned int *)v15 + 5)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(v15[1] + 8 * v16) = v13 & 0xFFFFFFFFFFFFFFF8;
      ++*((_DWORD *)v15 + 4);
      unint64_t v20 = v13 & 0xFFFFFFFFFFFFFFF8;
      char v17 = &sub_1CBFEEF50(v6, (uint64_t *)&v20)[4 * v14];
      unint64_t v18 = *((unsigned int *)v17 + 4);
      if (v18 >= *((unsigned int *)v17 + 5)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(v17[1] + 8 * v18) = v12;
      ++*((_DWORD *)v17 + 4);
      v10 += 2;
    }
    while (v10 != v11);
  }
  *(unsigned char *)(a1 + 592) = a4;
  return a1;
}

void *sub_1CBFEEF50(_DWORD *a1, uint64_t *a2)
{
  unsigned int v8 = 0;
  char v4 = sub_1CBFEEFE0((uint64_t)a1, a2, &v8);
  int v5 = v8;
  if ((v4 & 1) == 0)
  {
    int v5 = sub_1CBFEF094(a1, (uint64_t)a2, a2, v8);
    uint64_t v6 = *a2;
    *(_OWORD *)(v5 + 7) = 0u;
    *(_OWORD *)(v5 + 5) = 0u;
    *(_OWORD *)(v5 + 3) = 0u;
    *int v5 = v6;
    v5[1] = v5 + 3;
    void v5[2] = 0x200000000;
    v5[5] = v5 + 7;
    *((_DWORD *)v5 + 13) = 2;
  }
  return v5;
}

uint64_t sub_1CBFEEFE0(uint64_t a1, void *a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 4;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      unsigned int v7 = 0;
      uint64_t result = 0;
      goto LABEL_16;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v4 - 1);
  unsigned int v7 = (void *)(v3 + 72 * v6);
  uint64_t v8 = *v7;
  if (*a2 == *v7)
  {
    uint64_t result = 1;
  }
  else
  {
    uint64_t v9 = 0;
    int v10 = 1;
    uint64_t result = 1;
    while (v8 != -4096)
    {
      if (v9) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -8192;
      }
      if (v12) {
        uint64_t v9 = v7;
      }
      unsigned int v13 = v6 + v10++;
      unsigned int v6 = v13 & v5;
      unsigned int v7 = (void *)(v3 + 72 * (v13 & v5));
      uint64_t v8 = *v7;
      if (*a2 == *v7) {
        goto LABEL_16;
      }
    }
    uint64_t result = 0;
    if (v9) {
      unsigned int v7 = v9;
    }
  }
LABEL_16:
  *a3 = v7;
  return result;
}

void *sub_1CBFEF094(_DWORD *a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *a1 >> 1;
  if (*a1) {
    unsigned int v7 = 4;
  }
  else {
    unsigned int v7 = a1[4];
  }
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - a1[1] > v7 >> 3)
  {
    goto LABEL_5;
  }
  sub_1CBFEF158((uint64_t)a1, v7);
  uint64_t v9 = 0;
  sub_1CBFEEFE0((uint64_t)a1, a3, &v9);
  a4 = v9;
LABEL_5:
  *a1 += 2;
  if (*a4 != -4096) {
    --a1[1];
  }
  return a4;
}

void sub_1CBFEF158(uint64_t a1, unsigned int a2)
{
  v27[36] = *MEMORY[0x1E4F143B8];
  if (a2 >= 5)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    unint64_t v22 = *(void **)(a1 + 8);
    unsigned int v23 = *(_DWORD *)(a1 + 16);
    if (a2 <= 4)
    {
      *(_DWORD *)a1 |= 1u;
    }
    else
    {
      uint64_t v24 = a2;
      *(void *)(a1 + 8) = operator new(72 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v24;
    }
    sub_1CBFEF438(a1, v22, &v22[9 * v23]);
    JUMPOUT(0x1D25D9CD0);
  }
  unsigned int v25 = a2;
  uint64_t v6 = 0;
  uint64_t v7 = a1 + 8;
  uint64_t v8 = v27;
  uint64_t v9 = a1;
  int v10 = (void *)(a1 + 8);
  do
  {
    if ((*v10 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      char v11 = 0;
      uint64_t v12 = 0;
      *uint64_t v8 = *v10;
      unsigned int v13 = v8 + 1;
      uint64_t v14 = v10 + 1;
      do
      {
        char v15 = v11;
        unint64_t v16 = &v13[4 * v12];
        *unint64_t v16 = v16 + 2;
        v16[1] = 0x200000000;
        if (v13 != v14)
        {
          char v17 = &v14[4 * v12];
          unint64_t v18 = *((unsigned int *)v17 + 2);
          if (*((_DWORD *)v17 + 2))
          {
            unsigned int v19 = (const void *)*v17;
            if ((void *)*v17 == v17 + 2)
            {
              if (v18 >= 3) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              memcpy(v16 + 2, v19, 8 * *((unsigned int *)v17 + 2));
              *((_DWORD *)v16 + 2) = v18;
            }
            else
            {
              *unint64_t v16 = v19;
              *((_DWORD *)v16 + 2) = v18;
              *((_DWORD *)v16 + 3) = *((_DWORD *)v17 + 3);
              void *v17 = v17 + 2;
              *((_DWORD *)v17 + 3) = 0;
            }
            *((_DWORD *)v17 + 2) = 0;
          }
        }
        char v11 = 1;
        uint64_t v12 = 1;
      }
      while ((v15 & 1) == 0);
      for (uint64_t i = 0; i != -64; i -= 32)
      {
        char v21 = *(void **)(v9 + i + 48);
        if ((void *)(v9 + i + 64) != v21) {
          free(v21);
        }
      }
      v8 += 9;
    }
    ++v6;
    int v10 = (void *)(v7 + 72 * v6);
    v9 += 72;
  }
  while (v6 != 4);
  if (v25 > 4)
  {
    *(_DWORD *)a1 &= ~1u;
    *(void *)(a1 + 8) = operator new(72 * v25, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v25;
  }
  sub_1CBFEF438(a1, v27, v8);
}

void sub_1CBFEF438(uint64_t a1, void *a2, void *a3)
{
  unint64_t v4 = a2;
  int v6 = *(_DWORD *)a1;
  *(void *)a1 = *(_DWORD *)a1 & 1;
  if (v6)
  {
    uint64_t v8 = (void *)(a1 + 8);
    uint64_t v9 = (void *)(a1 + 296);
  }
  else
  {
    unsigned int v7 = *(_DWORD *)(a1 + 16);
    if (!v7) {
      goto LABEL_5;
    }
    uint64_t v8 = *(void **)(a1 + 8);
    uint64_t v9 = &v8[9 * v7];
  }
  do
  {
    *uint64_t v8 = -4096;
    v8 += 9;
  }
  while (v8 != v9);
LABEL_5:
  if (a2 != a3)
  {
    do
    {
      if ((*v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        unsigned int v23 = 0;
        sub_1CBFEEFE0(a1, v4, &v23);
        char v10 = 0;
        uint64_t v11 = 0;
        uint64_t v12 = v23;
        unsigned int v13 = v4 + 1;
        *unsigned int v23 = *v4;
        uint64_t v14 = v12 + 1;
        do
        {
          char v15 = v10;
          unint64_t v16 = &v14[4 * v11];
          *unint64_t v16 = v16 + 2;
          v16[1] = 0x200000000;
          if (v14 != v13)
          {
            char v17 = &v13[4 * v11];
            unint64_t v18 = *((unsigned int *)v17 + 2);
            if (*((_DWORD *)v17 + 2))
            {
              unsigned int v19 = (const void *)*v17;
              if ((void *)*v17 == v17 + 2)
              {
                if (v18 >= 3) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                memcpy(v16 + 2, v19, 8 * *((unsigned int *)v17 + 2));
                *((_DWORD *)v16 + 2) = v18;
              }
              else
              {
                *unint64_t v16 = v19;
                int v22 = *((_DWORD *)v17 + 3);
                *((_DWORD *)v16 + 2) = v18;
                *((_DWORD *)v16 + 3) = v22;
                void *v17 = v17 + 2;
                *((_DWORD *)v17 + 3) = 0;
              }
              *((_DWORD *)v17 + 2) = 0;
            }
          }
          char v10 = 1;
          uint64_t v11 = 1;
        }
        while ((v15 & 1) == 0);
        uint64_t v20 = 0;
        *(_DWORD *)a1 += 2;
        do
        {
          char v21 = (void *)v4[v20 + 5];
          if (&v4[v20 + 7] != v21) {
            free(v21);
          }
          v20 -= 4;
        }
        while (v20 != -8);
      }
      v4 += 9;
    }
    while (v4 != a3);
  }
}

uint64_t sub_1CBFEF604(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 600);
  if (v2 != (void *)(a1 + 616)) {
    free(v2);
  }
  sub_1CBFEF654(a1 + 296);

  return sub_1CBFEF654(a1);
}

uint64_t sub_1CBFEF654(uint64_t a1)
{
  if ((*(unsigned char *)a1 & 1) == 0) {
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 8), 8);
  }
  return a1;
}

void sub_1CBFEF690(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    unsigned int v1 = (void *)(a1 + 8);
    unsigned int v2 = 4;
  }
  else
  {
    unsigned int v2 = *(_DWORD *)(a1 + 16);
    if (!v2) {
      return;
    }
    unsigned int v1 = *(void **)(a1 + 8);
  }
  unint64_t v3 = &v1[9 * v2];
  do
  {
    if (*v1 != -4096 && *v1 != -8192)
    {
      for (uint64_t i = 0; i != -8; i -= 4)
      {
        int v5 = (void *)v1[i + 5];
        if (&v1[i + 7] != v5) {
          free(v5);
        }
      }
    }
    v1 += 9;
  }
  while (v1 != v3);
}

uint64_t llvm::DominanceFrontierBase<llvm::BasicBlock,false>::getRoots(uint64_t a1)
{
  return a1 + 24;
}

uint64_t llvm::DominanceFrontierBase<llvm::BasicBlock,false>::getRoot(uint64_t a1)
{
  return **(void **)(a1 + 24);
}

uint64_t llvm::DominanceFrontierBase<llvm::BasicBlock,false>::isPostDominator()
{
  return 0;
}

void llvm::DominanceFrontierBase<llvm::BasicBlock,false>::releaseMemory(uint64_t a1)
{
  unsigned int v2 = (void *)(a1 + 8);
  sub_1CD486DF0(a1, *(void **)(a1 + 8));
  *(void *)a1 = v2;
  *(void *)(a1 + 16) = 0;
  *unsigned int v2 = 0;
}

uint64_t llvm::DominanceFrontierBase<llvm::BasicBlock,false>::begin(uint64_t a1)
{
  return *(void *)a1;
}

{
  return *(void *)a1;
}

uint64_t llvm::DominanceFrontierBase<llvm::BasicBlock,false>::end(uint64_t a1)
{
  return a1 + 8;
}

{
  return a1 + 8;
}

void *llvm::DominanceFrontierBase<llvm::BasicBlock,false>::find(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(void **)(a1 + 8);
  unsigned int v2 = (void *)(a1 + 8);
  unint64_t v3 = v4;
  if (!v4) {
    return v2;
  }
  int v5 = v2;
  do
  {
    unint64_t v6 = v3[4];
    BOOL v7 = v6 >= a2;
    if (v6 >= a2) {
      uint64_t v8 = v3;
    }
    else {
      uint64_t v8 = v3 + 1;
    }
    if (v7) {
      int v5 = v3;
    }
    unint64_t v3 = (void *)*v8;
  }
  while (*v8);
  if (v5 == v2 || v5[4] > a2) {
    return v2;
  }
  return v5;
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  unint64_t v6;
  BOOL v7;
  void *v8;

  unint64_t v4 = *(void **)(a1 + 8);
  unsigned int v2 = (void *)(a1 + 8);
  unint64_t v3 = v4;
  if (!v4) {
    return v2;
  }
  int v5 = v2;
  do
  {
    unint64_t v6 = v3[4];
    BOOL v7 = v6 >= a2;
    if (v6 >= a2) {
      uint64_t v8 = v3;
    }
    else {
      uint64_t v8 = v3 + 1;
    }
    if (v7) {
      int v5 = v3;
    }
    unint64_t v3 = (void *)*v8;
  }
  while (*v8);
  if (v5 == v2 || v5[4] > a2) {
    return v2;
  }
  return v5;
}

uint64_t **llvm::DominanceFrontierBase<llvm::BasicBlock,false>::addBasicBlock(uint64_t **a1, unint64_t a2, void *a3)
{
  unint64_t v6 = a2;
  sub_1CBFF0474(v7, a3);
  unint64_t v4 = sub_1CBFF05F8(a1, v6, (uint64_t)&v6);
  sub_1CB833A08((uint64_t)v7, v7[1]);
  return v4;
}

void llvm::DominanceFrontierBase<llvm::BasicBlock,false>::removeBlock(uint64_t **a1, unint64_t a2)
{
  unint64_t v4 = a1 + 1;
  int v5 = *a1;
  if (*a1 != (uint64_t *)(a1 + 1))
  {
    do
    {
      sub_1CBFF06F8((uint64_t **)v5 + 5, a2);
      unint64_t v6 = (uint64_t *)v5[1];
      if (v6)
      {
        do
        {
          BOOL v7 = v6;
          unint64_t v6 = (uint64_t *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          BOOL v7 = (uint64_t *)v5[2];
          BOOL v8 = *v7 == (void)v5;
          int v5 = v7;
        }
        while (!v8);
      }
      int v5 = v7;
    }
    while (v7 != (uint64_t *)v4);
  }

  sub_1CBFF07C4(a1, a2);
}

uint64_t *llvm::DominanceFrontierBase<llvm::BasicBlock,false>::addToFrontier(uint64_t a1, uint64_t a2, unint64_t a3)
{
  return sub_1CBFF06F8((uint64_t **)(a2 + 40), a3);
}

uint64_t *llvm::DominanceFrontierBase<llvm::BasicBlock,false>::removeFromFrontier(uint64_t a1, uint64_t a2, unint64_t a3)
{
  return sub_1CBFF06F8((uint64_t **)(a2 + 40), a3);
}

BOOL llvm::DominanceFrontierBase<llvm::BasicBlock,false>::compareDomSet(uint64_t a1, void *a2, void *a3)
{
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  unsigned int v19 = (uint64_t *)&v20;
  unint64_t v4 = a3 + 1;
  int v5 = (void *)*a3;
  if ((void *)*a3 != a3 + 1)
  {
    do
    {
      unint64_t v18 = (uint64_t *)v5[4];
      sub_1CD3CFB98(&v19, (unint64_t *)&v18, &v18);
      unint64_t v6 = (void *)v5[1];
      if (v6)
      {
        do
        {
          BOOL v7 = v6;
          unint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          BOOL v7 = (void *)v5[2];
          BOOL v8 = *v7 == (void)v5;
          int v5 = v7;
        }
        while (!v8);
      }
      int v5 = v7;
    }
    while (v7 != v4);
  }
  uint64_t v11 = (void *)*a2;
  char v10 = a2 + 1;
  uint64_t v9 = v11;
  while (v9 != v10)
  {
    uint64_t v12 = (void *)v9[1];
    unsigned int v13 = v9;
    if (v12)
    {
      do
      {
        uint64_t v14 = v12;
        uint64_t v12 = (void *)*v12;
      }
      while (v12);
    }
    else
    {
      do
      {
        uint64_t v14 = (void *)v13[2];
        BOOL v8 = *v14 == (void)v13;
        unsigned int v13 = v14;
      }
      while (!v8);
    }
    char v15 = sub_1CBFF06F8(&v19, v9[4]);
    uint64_t v9 = v14;
    if (!v15)
    {
      BOOL v16 = 1;
      goto LABEL_18;
    }
  }
  BOOL v16 = v21 != 0;
LABEL_18:
  sub_1CB833A08((uint64_t)&v19, v20);
  return v16;
}

BOOL llvm::DominanceFrontierBase<llvm::BasicBlock,false>::compare(uint64_t a1, void *a2)
{
  unsigned int v19 = 0;
  uint64_t v20 = 0;
  unint64_t v18 = (uint64_t *)&v19;
  unsigned int v2 = a2 + 1;
  unint64_t v3 = (void *)*a2;
  if ((void *)*a2 == a2 + 1) {
    goto LABEL_9;
  }
  do
  {
    unint64_t v16 = v3[4];
    sub_1CBFF0474(v17, v3 + 5);
    sub_1CBFF05F8(&v18, v16, (uint64_t)&v16);
    sub_1CB833A08((uint64_t)v17, v17[1]);
    int v5 = (void *)v3[1];
    if (v5)
    {
      do
      {
        unint64_t v6 = v5;
        int v5 = (void *)*v5;
      }
      while (v5);
    }
    else
    {
      do
      {
        unint64_t v6 = (void *)v3[2];
        BOOL v7 = *v6 == (void)v3;
        unint64_t v3 = v6;
      }
      while (!v7);
    }
    unint64_t v3 = v6;
  }
  while (v6 != v2);
  if (v18 == (uint64_t *)&v19)
  {
LABEL_9:
    BOOL v8 = v20 != 0;
  }
  else
  {
    uint64_t v9 = *(void **)(a1 + 8);
    if (v9)
    {
      unint64_t v10 = v18[4];
      uint64_t v11 = (void *)(a1 + 8);
      do
      {
        unint64_t v12 = v9[4];
        BOOL v13 = v12 >= v10;
        if (v12 >= v10) {
          uint64_t v14 = v9;
        }
        else {
          uint64_t v14 = v9 + 1;
        }
        if (v13) {
          uint64_t v11 = v9;
        }
        uint64_t v9 = (void *)*v14;
      }
      while (*v14);
      if (v11 != (void *)(a1 + 8) && v11[4] <= v10) {
        llvm::DominanceFrontierBase<llvm::BasicBlock,false>::compareDomSet();
      }
    }
    BOOL v8 = 1;
  }
  sub_1CD486DF0((uint64_t)&v18, v19);
  return v8;
}

void llvm::DominanceFrontierBase<llvm::BasicBlock,false>::dump(llvm *a1)
{
  llvm::dbgs(a1);

  llvm::DominanceFrontierBase<llvm::BasicBlock,false>::print();
}

uint64_t llvm::DominanceFrontierBase<llvm::BasicBlock,true>::getRoots(uint64_t a1)
{
  return a1 + 24;
}

uint64_t llvm::DominanceFrontierBase<llvm::BasicBlock,true>::getRoot(uint64_t a1)
{
  return **(void **)(a1 + 24);
}

uint64_t llvm::DominanceFrontierBase<llvm::BasicBlock,true>::isPostDominator()
{
  return 1;
}

void llvm::DominanceFrontierBase<llvm::BasicBlock,true>::releaseMemory(uint64_t a1)
{
  unsigned int v2 = (void *)(a1 + 8);
  sub_1CD486DF0(a1, *(void **)(a1 + 8));
  *(void *)a1 = v2;
  *(void *)(a1 + 16) = 0;
  *unsigned int v2 = 0;
}

uint64_t llvm::DominanceFrontierBase<llvm::BasicBlock,true>::begin(uint64_t a1)
{
  return *(void *)a1;
}

{
  return *(void *)a1;
}

uint64_t llvm::DominanceFrontierBase<llvm::BasicBlock,true>::end(uint64_t a1)
{
  return a1 + 8;
}

{
  return a1 + 8;
}

void *llvm::DominanceFrontierBase<llvm::BasicBlock,true>::find(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(void **)(a1 + 8);
  unsigned int v2 = (void *)(a1 + 8);
  unint64_t v3 = v4;
  if (!v4) {
    return v2;
  }
  int v5 = v2;
  do
  {
    unint64_t v6 = v3[4];
    BOOL v7 = v6 >= a2;
    if (v6 >= a2) {
      BOOL v8 = v3;
    }
    else {
      BOOL v8 = v3 + 1;
    }
    if (v7) {
      int v5 = v3;
    }
    unint64_t v3 = (void *)*v8;
  }
  while (*v8);
  if (v5 == v2 || v5[4] > a2) {
    return v2;
  }
  return v5;
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  unint64_t v6;
  BOOL v7;
  void *v8;

  unint64_t v4 = *(void **)(a1 + 8);
  unsigned int v2 = (void *)(a1 + 8);
  unint64_t v3 = v4;
  if (!v4) {
    return v2;
  }
  int v5 = v2;
  do
  {
    unint64_t v6 = v3[4];
    BOOL v7 = v6 >= a2;
    if (v6 >= a2) {
      BOOL v8 = v3;
    }
    else {
      BOOL v8 = v3 + 1;
    }
    if (v7) {
      int v5 = v3;
    }
    unint64_t v3 = (void *)*v8;
  }
  while (*v8);
  if (v5 == v2 || v5[4] > a2) {
    return v2;
  }
  return v5;
}

uint64_t **llvm::DominanceFrontierBase<llvm::BasicBlock,true>::addBasicBlock(uint64_t **a1, unint64_t a2, void *a3)
{
  unint64_t v6 = a2;
  sub_1CBFF0474(v7, a3);
  unint64_t v4 = sub_1CBFF05F8(a1, v6, (uint64_t)&v6);
  sub_1CB833A08((uint64_t)v7, v7[1]);
  return v4;
}

void llvm::DominanceFrontierBase<llvm::BasicBlock,true>::removeBlock(uint64_t **a1, unint64_t a2)
{
  unint64_t v4 = a1 + 1;
  int v5 = *a1;
  if (*a1 != (uint64_t *)(a1 + 1))
  {
    do
    {
      sub_1CBFF06F8((uint64_t **)v5 + 5, a2);
      unint64_t v6 = (uint64_t *)v5[1];
      if (v6)
      {
        do
        {
          BOOL v7 = v6;
          unint64_t v6 = (uint64_t *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          BOOL v7 = (uint64_t *)v5[2];
          BOOL v8 = *v7 == (void)v5;
          int v5 = v7;
        }
        while (!v8);
      }
      int v5 = v7;
    }
    while (v7 != (uint64_t *)v4);
  }

  sub_1CBFF07C4(a1, a2);
}

uint64_t *llvm::DominanceFrontierBase<llvm::BasicBlock,true>::addToFrontier(uint64_t a1, uint64_t a2, unint64_t a3)
{
  return sub_1CBFF06F8((uint64_t **)(a2 + 40), a3);
}

uint64_t *llvm::DominanceFrontierBase<llvm::BasicBlock,true>::removeFromFrontier(uint64_t a1, uint64_t a2, unint64_t a3)
{
  return sub_1CBFF06F8((uint64_t **)(a2 + 40), a3);
}

BOOL llvm::DominanceFrontierBase<llvm::BasicBlock,true>::compareDomSet(uint64_t a1, void *a2, void *a3)
{
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  unsigned int v19 = (uint64_t *)&v20;
  unint64_t v4 = a3 + 1;
  int v5 = (void *)*a3;
  if ((void *)*a3 != a3 + 1)
  {
    do
    {
      unint64_t v18 = (uint64_t *)v5[4];
      sub_1CD3CFB98(&v19, (unint64_t *)&v18, &v18);
      unint64_t v6 = (void *)v5[1];
      if (v6)
      {
        do
        {
          BOOL v7 = v6;
          unint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          BOOL v7 = (void *)v5[2];
          BOOL v8 = *v7 == (void)v5;
          int v5 = v7;
        }
        while (!v8);
      }
      int v5 = v7;
    }
    while (v7 != v4);
  }
  uint64_t v11 = (void *)*a2;
  unint64_t v10 = a2 + 1;
  uint64_t v9 = v11;
  while (v9 != v10)
  {
    unint64_t v12 = (void *)v9[1];
    BOOL v13 = v9;
    if (v12)
    {
      do
      {
        uint64_t v14 = v12;
        unint64_t v12 = (void *)*v12;
      }
      while (v12);
    }
    else
    {
      do
      {
        uint64_t v14 = (void *)v13[2];
        BOOL v8 = *v14 == (void)v13;
        BOOL v13 = v14;
      }
      while (!v8);
    }
    char v15 = sub_1CBFF06F8(&v19, v9[4]);
    uint64_t v9 = v14;
    if (!v15)
    {
      BOOL v16 = 1;
      goto LABEL_18;
    }
  }
  BOOL v16 = v21 != 0;
LABEL_18:
  sub_1CB833A08((uint64_t)&v19, v20);
  return v16;
}

BOOL llvm::DominanceFrontierBase<llvm::BasicBlock,true>::compare(uint64_t a1, void *a2)
{
  unsigned int v19 = 0;
  uint64_t v20 = 0;
  unint64_t v18 = (uint64_t *)&v19;
  unsigned int v2 = a2 + 1;
  unint64_t v3 = (void *)*a2;
  if ((void *)*a2 == a2 + 1) {
    goto LABEL_9;
  }
  do
  {
    unint64_t v16 = v3[4];
    sub_1CBFF0474(v17, v3 + 5);
    sub_1CBFF05F8(&v18, v16, (uint64_t)&v16);
    sub_1CB833A08((uint64_t)v17, v17[1]);
    int v5 = (void *)v3[1];
    if (v5)
    {
      do
      {
        unint64_t v6 = v5;
        int v5 = (void *)*v5;
      }
      while (v5);
    }
    else
    {
      do
      {
        unint64_t v6 = (void *)v3[2];
        BOOL v7 = *v6 == (void)v3;
        unint64_t v3 = v6;
      }
      while (!v7);
    }
    unint64_t v3 = v6;
  }
  while (v6 != v2);
  if (v18 == (uint64_t *)&v19)
  {
LABEL_9:
    BOOL v8 = v20 != 0;
  }
  else
  {
    uint64_t v9 = *(void **)(a1 + 8);
    if (v9)
    {
      unint64_t v10 = v18[4];
      uint64_t v11 = (void *)(a1 + 8);
      do
      {
        unint64_t v12 = v9[4];
        BOOL v13 = v12 >= v10;
        if (v12 >= v10) {
          uint64_t v14 = v9;
        }
        else {
          uint64_t v14 = v9 + 1;
        }
        if (v13) {
          uint64_t v11 = v9;
        }
        uint64_t v9 = (void *)*v14;
      }
      while (*v14);
      if (v11 != (void *)(a1 + 8) && v11[4] <= v10) {
        llvm::DominanceFrontierBase<llvm::BasicBlock,true>::compareDomSet();
      }
    }
    BOOL v8 = 1;
  }
  sub_1CD486DF0((uint64_t)&v18, v19);
  return v8;
}

llvm::Value *llvm::DominanceFrontierBase<llvm::BasicBlock,true>::print(llvm::Value *result, llvm::raw_ostream *this)
{
  unsigned int v2 = (void *)((char *)result + 8);
  unint64_t v3 = *(void **)result;
  if (*(llvm::Value **)result != (llvm::Value *)((char *)result + 8))
  {
    while (1)
    {
      int v5 = (void *)*((void *)this + 4);
      if (*((void *)this + 3) - (void)v5 > 0x14uLL)
      {
        qmemcpy(v5, "  DomFrontier for BB ", 21);
        *((void *)this + 4) += 21;
      }
      else
      {
        llvm::raw_ostream::write(this, "  DomFrontier for BB ", 0x15uLL);
      }
      uint64_t result = (llvm::Value *)v3[4];
      if (result)
      {
        uint64_t result = (llvm::Value *)llvm::Value::printAsOperand(result, this, 0, 0);
      }
      else
      {
        unint64_t v6 = (void *)*((void *)this + 4);
        if (*((void *)this + 3) - (void)v6 > 0xDuLL)
        {
          qmemcpy(v6, " <<exit node>>", 14);
          *((void *)this + 4) += 14;
        }
        else
        {
          uint64_t result = llvm::raw_ostream::write(this, " <<exit node>>", 0xEuLL);
        }
      }
      uint64_t v7 = *((void *)this + 4);
      if ((unint64_t)(*((void *)this + 3) - v7) > 4)
      {
        *(unsigned char *)(v7 + 4) = 9;
        *(_DWORD *)uint64_t v7 = 980642080;
        *((void *)this + 4) += 5;
      }
      else
      {
        uint64_t result = llvm::raw_ostream::write(this, " is:\t", 5uLL);
      }
      BOOL v8 = (void *)v3[5];
      if (v8 != v3 + 6) {
        break;
      }
LABEL_24:
      char v15 = (unsigned char *)*((void *)this + 4);
      if ((unint64_t)v15 >= *((void *)this + 3))
      {
        uint64_t result = llvm::raw_ostream::write(this, 10);
      }
      else
      {
        *((void *)this + 4) = v15 + 1;
        unsigned char *v15 = 10;
      }
      unint64_t v16 = (void *)v3[1];
      if (v16)
      {
        do
        {
          char v17 = v16;
          unint64_t v16 = (void *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          char v17 = (void *)v3[2];
          BOOL v14 = *v17 == (void)v3;
          unint64_t v3 = v17;
        }
        while (!v14);
      }
      unint64_t v3 = v17;
      if (v17 == v2) {
        return result;
      }
    }
    while (1)
    {
      uint64_t v9 = (llvm::Value *)v8[4];
      unint64_t v10 = (unsigned char *)*((void *)this + 4);
      if ((unint64_t)v10 >= *((void *)this + 3))
      {
        uint64_t result = llvm::raw_ostream::write(this, 32);
        if (v9)
        {
LABEL_12:
          uint64_t result = (llvm::Value *)llvm::Value::printAsOperand(v9, this, 0, 0);
          goto LABEL_16;
        }
      }
      else
      {
        *((void *)this + 4) = v10 + 1;
        *unint64_t v10 = 32;
        if (v9) {
          goto LABEL_12;
        }
      }
      uint64_t v11 = (void *)*((void *)this + 4);
      if (*((void *)this + 3) - (void)v11 > 0xCuLL)
      {
        qmemcpy(v11, "<<exit node>>", 13);
        *((void *)this + 4) += 13;
      }
      else
      {
        uint64_t result = llvm::raw_ostream::write(this, "<<exit node>>", 0xDuLL);
      }
LABEL_16:
      unint64_t v12 = (void *)v8[1];
      if (v12)
      {
        do
        {
          BOOL v13 = v12;
          unint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          BOOL v13 = (void *)v8[2];
          BOOL v14 = *v13 == (void)v8;
          BOOL v8 = v13;
        }
        while (!v14);
      }
      BOOL v8 = v13;
      if (v13 == v3 + 6) {
        goto LABEL_24;
      }
    }
  }
  return result;
}

void llvm::DominanceFrontierBase<llvm::BasicBlock,true>::dump(llvm *a1)
{
  llvm::dbgs(a1);

  llvm::DominanceFrontierBase<llvm::BasicBlock,true>::print();
}

void sub_1CBFF03C4(uint64_t a1)
{
}

void *llvm::DominanceFrontierPrinterPass::DominanceFrontierPrinterPass(void *result, uint64_t a2)
{
  uint64_t *result = a2;
  return result;
}

uint64_t **sub_1CBFF0474(uint64_t **a1, void *a2)
{
  a1[1] = 0;
  unint64_t v3 = (uint64_t *)(a1 + 1);
  a1[2] = 0;
  *a1 = (uint64_t *)(a1 + 1);
  unint64_t v4 = a2 + 1;
  int v5 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      unint64_t v6 = v5[4];
      uint64_t v7 = a1[1];
      BOOL v8 = v3;
      if (*a1 == v3) {
        goto LABEL_8;
      }
      uint64_t v9 = a1[1];
      unint64_t v10 = v3;
      if (v7)
      {
        do
        {
          BOOL v8 = v9;
          uint64_t v9 = (uint64_t *)v9[1];
        }
        while (v9);
      }
      else
      {
        do
        {
          BOOL v8 = (uint64_t *)v10[2];
          BOOL v11 = *v8 == (void)v10;
          unint64_t v10 = v8;
        }
        while (v11);
      }
      if (v8[4] < v6)
      {
LABEL_8:
        if (v7) {
          unint64_t v12 = (uint64_t **)v8;
        }
        else {
          unint64_t v12 = (uint64_t **)v3;
        }
        if (v7) {
          BOOL v13 = (uint64_t **)(v8 + 1);
        }
        else {
          BOOL v13 = (uint64_t **)v3;
        }
        if (*v13) {
          goto LABEL_27;
        }
      }
      else
      {
        BOOL v13 = (uint64_t **)v3;
        unint64_t v12 = (uint64_t **)v3;
        if (v7)
        {
          while (1)
          {
            while (1)
            {
              unint64_t v12 = (uint64_t **)v7;
              unint64_t v14 = v7[4];
              if (v14 <= v6) {
                break;
              }
              uint64_t v7 = *v12;
              BOOL v13 = v12;
              if (!*v12) {
                goto LABEL_23;
              }
            }
            if (v14 >= v6) {
              goto LABEL_27;
            }
            uint64_t v7 = v12[1];
            if (!v7)
            {
              BOOL v13 = v12 + 1;
              break;
            }
          }
        }
      }
LABEL_23:
      char v15 = (uint64_t *)operator new(0x28uLL);
      v15[4] = v6;
      uint64_t *v15 = 0;
      v15[1] = 0;
      v15[2] = (uint64_t)v12;
      *BOOL v13 = v15;
      unint64_t v16 = (uint64_t *)**a1;
      if (v16)
      {
        *a1 = v16;
        char v17 = *v13;
      }
      else
      {
        char v17 = v15;
      }
      sub_1CB8358B8(a1[1], v17);
      a1[2] = (uint64_t *)((char *)a1[2] + 1);
LABEL_27:
      unint64_t v18 = (void *)v5[1];
      if (v18)
      {
        do
        {
          unsigned int v19 = v18;
          unint64_t v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          unsigned int v19 = (void *)v5[2];
          BOOL v11 = *v19 == (void)v5;
          int v5 = v19;
        }
        while (!v11);
      }
      int v5 = v19;
    }
    while (v19 != v4);
  }
  return a1;
}

uint64_t **sub_1CBFF05F8(uint64_t **a1, unint64_t a2, uint64_t a3)
{
  unint64_t v6 = a1 + 1;
  int v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        unint64_t v8 = v5[4];
        if (v8 <= a2) {
          break;
        }
        int v5 = *v7;
        unint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        return v7;
      }
      int v5 = v7[1];
      if (!v5)
      {
        unint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = a1 + 1;
LABEL_9:
    uint64_t v9 = operator new(0x40uLL);
    unint64_t v10 = v9;
    BOOL v11 = (void *)(a3 + 16);
    uint64_t v12 = *(void *)(a3 + 16);
    BOOL v9[2] = *(_OWORD *)a3;
    *((void *)v9 + 6) = v12;
    BOOL v13 = (char *)(v9 + 3);
    uint64_t v14 = *(void *)(a3 + 24);
    *((void *)v9 + 7) = v14;
    if (v14)
    {
      *(void *)(v12 + 16) = v13;
      *(void *)(a3 + 8) = v11;
      *BOOL v11 = 0;
      *(void *)(a3 + 24) = 0;
    }
    else
    {
      *((void *)v9 + 5) = v13;
    }
    *(void *)uint64_t v9 = 0;
    *((void *)v9 + sub_1CD456CB4((void *)this + 1) = 0;
    *((void *)v9 + 2) = v7;
    *unint64_t v6 = (uint64_t *)v9;
    char v15 = (uint64_t *)**a1;
    unint64_t v16 = (uint64_t *)v9;
    if (v15)
    {
      *a1 = v15;
      unint64_t v16 = *v6;
    }
    sub_1CB8358B8(a1[1], v16);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return (uint64_t **)v10;
}

uint64_t *sub_1CBFF06F8(uint64_t **a1, unint64_t a2)
{
  unint64_t v4 = (uint64_t *)(a1 + 1);
  uint64_t result = a1[1];
  if (result)
  {
    int v5 = result;
    unint64_t v6 = v4;
    do
    {
      unint64_t v7 = v5[4];
      BOOL v8 = v7 >= a2;
      if (v7 >= a2) {
        uint64_t v9 = (uint64_t **)v5;
      }
      else {
        uint64_t v9 = (uint64_t **)(v5 + 1);
      }
      if (v8) {
        unint64_t v6 = v5;
      }
      int v5 = *v9;
    }
    while (*v9);
    if (v6 == v4 || v6[4] > a2)
    {
      return 0;
    }
    else
    {
      unint64_t v10 = (uint64_t *)v6[1];
      if (v10)
      {
        do
        {
          BOOL v11 = v10;
          unint64_t v10 = (uint64_t *)*v10;
        }
        while (v10);
      }
      else
      {
        uint64_t v12 = v6;
        do
        {
          BOOL v11 = (uint64_t *)v12[2];
          BOOL v13 = *v11 == (void)v12;
          uint64_t v12 = v11;
        }
        while (!v13);
      }
      if (*a1 == v6) {
        *a1 = v11;
      }
      a1[2] = (uint64_t *)((char *)a1[2] - 1);
      sub_1CB91F7C8(result, v6);
      operator delete(v6);
      return (uint64_t *)1;
    }
  }
  return result;
}

void sub_1CBFF07C4(uint64_t **a1, unint64_t a2)
{
  unint64_t v4 = (uint64_t *)(a1 + 1);
  unint64_t v3 = a1[1];
  if (v3)
  {
    int v5 = v3;
    unint64_t v6 = v4;
    do
    {
      unint64_t v7 = v5[4];
      BOOL v8 = v7 >= a2;
      if (v7 >= a2) {
        uint64_t v9 = (uint64_t **)v5;
      }
      else {
        uint64_t v9 = (uint64_t **)(v5 + 1);
      }
      if (v8) {
        unint64_t v6 = v5;
      }
      int v5 = *v9;
    }
    while (*v9);
    if (v6 != v4 && v6[4] <= a2)
    {
      unint64_t v10 = (uint64_t *)v6[1];
      if (v10)
      {
        do
        {
          uint64_t v12 = v10;
          unint64_t v10 = (uint64_t *)*v10;
        }
        while (v10);
      }
      else
      {
        BOOL v11 = v6;
        do
        {
          uint64_t v12 = (uint64_t *)v11[2];
          BOOL v13 = *v12 == (void)v11;
          BOOL v11 = v12;
        }
        while (!v13);
      }
      if (*a1 == v6) {
        *a1 = v12;
      }
      a1[2] = (uint64_t *)((char *)a1[2] - 1);
      sub_1CB91F7C8(v3, v6);
      sub_1CB833A08((uint64_t)(v6 + 5), (void *)v6[6]);
      operator delete(v6);
    }
  }
}

_OWORD *sub_1CBFF08A8(void **a1, _OWORD *a2)
{
  unint64_t v3 = (char *)*a1;
  unsigned int v2 = (char *)a1[1];
  uint64_t v4 = (v2 - (unsigned char *)*a1) >> 5;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 59) {
    abort();
  }
  uint64_t v8 = (unsigned char *)a1[2] - v3;
  if (v8 >> 4 > v5) {
    unint64_t v5 = v8 >> 4;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v9 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  if (v9)
  {
    if (v9 >> 59) {
      sub_1CB833614();
    }
    unint64_t v10 = (char *)operator new(32 * v9);
  }
  else
  {
    unint64_t v10 = 0;
  }
  BOOL v11 = &v10[32 * v4];
  long long v12 = a2[1];
  *(_OWORD *)BOOL v11 = *a2;
  *((_OWORD *)v11 + sub_1CD456CB4((void *)this + 1) = v12;
  BOOL v13 = v11 + 32;
  if (v2 != v3)
  {
    do
    {
      long long v14 = *((_OWORD *)v2 - 1);
      *((_OWORD *)v11 - 2) = *((_OWORD *)v2 - 2);
      *((_OWORD *)v11 - sub_1CD456CB4((void *)this + 1) = v14;
      v11 -= 32;
      v2 -= 32;
    }
    while (v2 != v3);
    unsigned int v2 = (char *)*a1;
  }
  *a1 = v11;
  a1[1] = v13;
  a1[2] = &v10[32 * v9];
  if (v2) {
    operator delete(v2);
  }
  return v13;
}

llvm::Value *llvm::classifyEHPersonality(llvm::Value *this, const llvm::Value *a2)
{
  if (this)
  {
    unsigned int v2 = llvm::Value::stripPointerCasts(this);
    if (*((unsigned __int8 *)v2 + 16) > 3u) {
      return 0;
    }
    uint64_t v3 = *((void *)v2 + 3);
    if (!v3 || *(unsigned char *)(v3 + 8) != 14) {
      return 0;
    }
    if ((*((unsigned char *)v2 + 23) & 0x10) == 0)
    {
LABEL_94:
      uint64_t v12 = 0;
LABEL_123:
      if ((v12 & 0x300000000) != 0) {
        return (llvm::Value *)v12;
      }
      else {
        return 0;
      }
    }
    uint64_t v4 = ***(void ***)v2;
    uint64_t v5 = *(void *)(v4 + 152);
    uint64_t v6 = *(unsigned int *)(v4 + 168);
    if (v6)
    {
      LODWORD(v7) = (v6 - 1) & ((v2 >> 4) ^ (v2 >> 9));
      uint64_t v8 = (llvm::Value **)(v5 + 16 * v7);
      unint64_t v9 = *v8;
      if (*v8 == v2) {
        goto LABEL_15;
      }
      int v10 = 1;
      while (v9 != (llvm::Value *)-4096)
      {
        int v11 = v7 + v10++;
        uint64_t v7 = v11 & (v6 - 1);
        unint64_t v9 = *(llvm::Value **)(v5 + 16 * v7);
        if (v9 == v2)
        {
          uint64_t v8 = (llvm::Value **)(v5 + 16 * v7);
          goto LABEL_15;
        }
      }
    }
    uint64_t v8 = (llvm::Value **)(v5 + 16 * v6);
LABEL_15:
    uint64_t v12 = 0;
    BOOL v13 = v8[1];
    switch(*(void *)v13)
    {
      case 0x10:
        if (*((void *)v13 + 2) == 0x5F7470656378655FLL && *((void *)v13 + 3) == 0x3372656C646E6168)
        {
          uint64_t v12 = 0x100000007;
        }
        else
        {
          uint64_t v16 = *((void *)v13 + 2);
          uint64_t v15 = *((void *)v13 + 3);
          if (v16 != 0x5F7470656378655FLL || v15 != 0x3472656C646E6168) {
            goto LABEL_94;
          }
          uint64_t v12 = 0x100000007;
        }
        break;
      case 0x12:
        uint64_t v18 = *((void *)v13 + 2);
        uint64_t v19 = *((void *)v13 + 3);
        int v20 = *((unsigned __int16 *)v13 + 16);
        if (v18 != 0x6172467878435F5FLL || v19 != 0x656C646E6148656DLL || v20 != 13170) {
          goto LABEL_94;
        }
        uint64_t v12 = 0x100000009;
        break;
      case 0x13:
        if (*((void *)v13 + 2) != 0x43737365636F7250
          || *((void *)v13 + 3) != 0x747065637845524CLL
          || *(void *)((char *)v13 + 27) != 0x6E6F697470656378)
        {
          uint64_t v25 = *((void *)v13 + 2) ^ 0x5F68655F74737572 | *((void *)v13 + 3) ^ 0x6C616E6F73726570 | *(void *)((char *)v13 + 27) ^ 0x7974696C616E6F73;
          uint64_t v12 = 0x10000000BLL;
          goto LABEL_110;
        }
        uint64_t v12 = 0x10000000ALL;
        break;
      case 0x14:
        uint64_t v12 = 0x100000002;
        if (*((void *)v13 + 2) == 0x65705F7878675F5FLL
          && *((void *)v13 + 3) == 0x74696C616E6F7372
          && *((_DWORD *)v13 + 8) == 813064057)
        {
          goto LABEL_116;
        }
        if (*((void *)v13 + 2) != 0x65705F6363675F5FLL
          || *((void *)v13 + 3) != 0x74696C616E6F7372
          || *((_DWORD *)v13 + 8) != 813064057)
        {
          uint64_t v30 = *((void *)v13 + 2);
          uint64_t v31 = *((void *)v13 + 3);
          int v32 = *((_DWORD *)v13 + 8);
          if (v30 != 0x636570735F435F5FLL || v31 != 0x6E61685F63696669 || v32 != 1919249508) {
            goto LABEL_94;
          }
          uint64_t v12 = 0x100000008;
        }
        break;
      case 0x15:
        if (*((void *)v13 + 2) == 0x655F74616E675F5FLL
          && *((void *)v13 + 3) == 0x6E6F737265705F68
          && *(void *)((char *)v13 + 29) == 0x7974696C616E6F73)
        {
          uint64_t v12 = 0x100000001;
        }
        else if (*((void *)v13 + 2) == 0x65705F7878675F5FLL {
               && *((void *)v13 + 3) == 0x74696C616E6F7372
        }
               && *(void *)((char *)v13 + 29) == 0x306A735F7974696CLL)
        {
          uint64_t v12 = 0x100000005;
        }
        else if (*((void *)v13 + 2) == 0x65705F6363675F5FLL {
               && *((void *)v13 + 3) == 0x74696C616E6F7372
        }
               && *(void *)((char *)v13 + 29) == 0x306A735F7974696CLL)
        {
          uint64_t v12 = 0x100000003;
        }
        else
        {
          uint64_t v41 = *((void *)v13 + 2);
          uint64_t v42 = *((void *)v13 + 3);
          uint64_t v43 = *(void *)((char *)v13 + 29);
          if (v41 != 0x705F636A626F5F5FLL || v42 != 0x696C616E6F737265 || v43 != 0x30765F7974696C61) {
            goto LABEL_94;
          }
          uint64_t v12 = 0x100000006;
        }
        break;
      case 0x16:
        uint64_t v12 = 0x100000002;
        if (*((void *)v13 + 2) == 0x65705F7878675F5FLL
          && *((void *)v13 + 3) == 0x74696C616E6F7372
          && *(void *)((char *)v13 + 30) == 0x306865735F797469)
        {
LABEL_116:
          uint64_t v12 = 0x100000004;
        }
        else if (*((void *)v13 + 2) != 0x65705F6363675F5FLL {
               || *((void *)v13 + 3) != 0x74696C616E6F7372
        }
               || *(void *)((char *)v13 + 30) != 0x306865735F797469)
        {
          uint64_t v25 = *((void *)v13 + 2) ^ 0x5F7878636C785F5FLL | *((void *)v13 + 3) ^ 0x6C616E6F73726570 | *(void *)((char *)v13 + 30) ^ 0x31765F7974696C61;
          uint64_t v12 = 0x10000000DLL;
LABEL_110:
          if (v25) {
            uint64_t v12 = 0;
          }
        }
        break;
      case 0x19:
        if (*((void *)v13 + 2) ^ 0x61775F7878675F5FLL | *((void *)v13 + 3) ^ 0x6F737265705F6D73 | *((void *)v13 + 4) ^ 0x765F7974696C616ELL | *((unsigned __int8 *)v13 + 40) ^ 0x30) {
          uint64_t v12 = 0;
        }
        else {
          uint64_t v12 = 0x10000000CLL;
        }
        break;
      default:
        goto LABEL_123;
    }
    goto LABEL_123;
  }
  return this;
}

void llvm::colorEHFunclets(llvm *this@<X0>, uint64_t a2@<X8>)
{
  v34[32] = *MEMORY[0x1E4F143B8];
  uint64_t v31 = v34;
  unsigned int v33 = 16;
  uint64_t v4 = *((void *)this + 10);
  if (v4) {
    uint64_t v5 = v4 - 24;
  }
  else {
    uint64_t v5 = 0;
  }
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  v34[0] = v5;
  v34[1] = v5;
  unsigned int v6 = 1;
  do
  {
    uint64_t v30 = 0;
    uint64_t v7 = (char *)v31 + 16 * v6;
    uint64_t v8 = *((void *)v7 - 2);
    uint64_t v9 = *((void *)v7 - 1);
    unsigned int v32 = v6 - 1;
    uint64_t v30 = v8;
    for (uint64_t i = *(void *)(v8 + 48); ; uint64_t i = *(void *)(i + 8))
    {
      uint64_t v11 = i - 24;
      if (!i) {
        uint64_t v11 = 0;
      }
      if (*(unsigned char *)(v11 + 16) != 83) {
        break;
      }
    }
    unsigned int v12 = *(unsigned __int8 *)(i - 8) - 38;
    BOOL v13 = v12 > 0x38;
    uint64_t v14 = (1 << v12) & 0x100060000000001;
    if (!v13 && v14 != 0) {
      uint64_t v9 = v8;
    }
    uint64_t v16 = sub_1CD487170((uint64_t *)a2, &v30) + 1;
    if (sub_1CD486F7C(v16, v9) || (sub_1CD486FFC(v16, v9), uint64_t v17 = *(void *)(v30 + 40), v17 == v30 + 40))
    {
LABEL_16:
      unsigned int v6 = v32;
      continue;
    }
    if (v17) {
      uint64_t v18 = v17 - 24;
    }
    else {
      uint64_t v18 = 0;
    }
    int v19 = *(unsigned __int8 *)(v18 + 16);
    if ((v19 - 40) >= 0xFFFFFFF5) {
      uint64_t v20 = v18;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v17 && (*(unsigned char *)(v20 + 16) == 37 ? (BOOL v21 = (v19 - 40) >= 0xFFFFFFF5) : (BOOL v21 = 0), v21))
    {
      uint64_t v22 = *(void *)(*(void *)(v20 - 64) - 32);
      int v23 = *(_DWORD *)(v22 + 20);
      if ((v23 & 0x40000000) != 0) {
        uint64_t v24 = *(uint64_t **)(v22 - 8);
      }
      else {
        uint64_t v24 = (uint64_t *)(v22 - 32 * (v23 & 0x7FFFFFF));
      }
      uint64_t v25 = *v24;
      uint64_t v9 = v5;
      if (*(unsigned char *)(v25 + 16) != 20) {
        uint64_t v9 = *(void *)(v25 + 40);
      }
    }
    else if ((v19 - 29) > 0xA)
    {
      goto LABEL_16;
    }
    if (v19 != 30)
    {
      int v26 = 2;
      switch(*(unsigned char *)(v18 + 16))
      {
        case 0x1E:
          __break(1u);
          JUMPOUT(0x1CBFF1214);
        case 0x1F:
          int v26 = (*(_DWORD *)(v18 + 20) >> 1) & 0x3FFFFFF;
          goto LABEL_50;
        case 0x20:
        case 0x26:
          int v26 = (*(_DWORD *)(v18 + 20) & 0x7FFFFFF) - 1;
          goto LABEL_50;
        case 0x21:
          goto LABEL_43;
        case 0x24:
          int v26 = *(_WORD *)(v18 + 18) & 1;
          goto LABEL_50;
        case 0x25:
          int v26 = 1;
          goto LABEL_43;
        case 0x27:
          int v26 = *(_DWORD *)(v18 + 80) + 1;
LABEL_50:
          if (!v26) {
            goto LABEL_16;
          }
          goto LABEL_43;
        default:
          goto LABEL_16;
      }
    }
    if ((*(_DWORD *)(v18 + 20) & 0x7FFFFFF) == 3) {
      int v26 = 2;
    }
    else {
      int v26 = 1;
    }
LABEL_43:
    for (unsigned int j = 0; j != v26; ++j)
    {
      uint64_t Successor = llvm::Instruction::getSuccessor((llvm::Instruction *)v18, j);
      if (v32 >= (unint64_t)v33) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      int v29 = (uint64_t *)((char *)v31 + 16 * v32);
      *int v29 = Successor;
      v29[1] = v9;
      unsigned int v6 = ++v32;
    }
  }
  while (v6);
  if (v31 != v34) {
    free(v31);
  }
}

uint64_t llvm::FunctionPropertiesInfo::getFunctionPropertiesInfo@<X0>(uint64_t result@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  uint64_t v3 = *(void *)(result + 8);
  if (v3)
  {
    int v4 = 0;
    do
    {
      ++v4;
      uint64_t v3 = *(void *)(v3 + 8);
    }
    while (v3);
  }
  else
  {
    int v4 = 0;
  }
  *(void *)(a3 + 16) = v4 + ((*(_DWORD *)(result + 32) & 0xFu) - 9 < 0xFFFFFFFE);
  uint64_t v5 = result + 72;
  uint64_t v6 = *(void *)(result + 80);
  if (v6 != result + 72)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    unint64_t v12 = 0;
    uint64_t v13 = *a2;
    uint64_t result = *((unsigned int *)a2 + 4);
    unsigned int v14 = result - 1;
    while (1)
    {
      uint64_t v15 = v6 - 24;
      if (!v6) {
        uint64_t v15 = 0;
      }
      uint64_t v16 = *(void *)(v15 + 40);
      if (v16 != v15 + 40)
      {
        uint64_t v17 = v16 - 24;
        if (!v16) {
          uint64_t v17 = 0;
        }
        unsigned int v18 = *(unsigned __int8 *)(v17 + 16) - 40;
        if (v18 < 0xFFFFFFF5) {
          uint64_t v17 = 0;
        }
        int v19 = *(unsigned __int8 *)(v17 + 16);
        if (!v16 || (v19 == 30 ? (BOOL v20 = v18 >= 0xFFFFFFF5) : (BOOL v20 = 0), !v20))
        {
          if (!v16) {
            goto LABEL_34;
          }
          if (v19 != 31 || v18 < 0xFFFFFFF5) {
            goto LABEL_34;
          }
          unsigned int v23 = *(_DWORD *)(v17 + 20);
          if ((v23 & 0x40000000) != 0) {
            uint64_t v24 = *(void *)(v17 - 8);
          }
          else {
            uint64_t v24 = v17 - 32 * (v23 & 0x7FFFFFF);
          }
          unsigned int v25 = ((v23 >> 1) & 0x3FFFFFF) - 1;
          if (*(void *)(v24 + 32)) {
            uint64_t v21 = v25 + 1;
          }
          else {
            uint64_t v21 = v25;
          }
          goto LABEL_33;
        }
        if ((*(_DWORD *)(v17 + 20) & 0x7FFFFFF) == 3)
        {
          uint64_t v21 = 2;
LABEL_33:
          v8 += v21;
          *(void *)(a3 + 8) = v8;
        }
      }
LABEL_34:
      for (uint64_t i = *(void *)(v15 + 48); i != v15 + 40; uint64_t i = *(void *)(i + 8))
      {
        uint64_t v27 = i - 24;
        if (!i) {
          uint64_t v27 = 0;
        }
        int v28 = *(unsigned __int8 *)(v27 + 16);
        if ((v28 - 33) <= 0x33 && ((1 << (v28 - 33)) & 0x8000000000041) != 0)
        {
          uint64_t v30 = *(void *)(i - 56);
          if (v30)
          {
            if (!*(unsigned char *)(v30 + 16) && *(void *)(v30 + 24) == *(void *)(i + 48))
            {
              int v31 = *(_DWORD *)(v30 + 32);
              if ((v31 & 0x2000) == 0 && ((v31 & 0x800000) != 0 || *(void *)(v30 + 72) != v30 + 72)) {
                *(void *)(a3 + 24) = ++v9;
              }
            }
          }
        }
        if (v28 == 61)
        {
          *(void *)(a3 + 40) = ++v10;
        }
        else if (v28 == 60)
        {
          *(void *)(a3 + 32) = ++v11;
        }
      }
      if (result)
      {
        uint64_t v32 = v14 & ((v15 >> 4) ^ (v15 >> 9));
        uint64_t v33 = *(void *)(v13 + 16 * v32);
        if (v15 == v33)
        {
LABEL_59:
          uint64_t v36 = *(void **)(v13 + 16 * v32 + 8);
          if (v36)
          {
            unsigned int v37 = 0;
            do
            {
              uint64_t v36 = (void *)*v36;
              ++v37;
            }
            while (v36);
            goto LABEL_64;
          }
        }
        else
        {
          int v34 = 1;
          while (v33 != -4096)
          {
            int v35 = v32 + v34++;
            uint64_t v32 = v35 & v14;
            uint64_t v33 = *(void *)(v13 + 16 * v32);
            if (v15 == v33) {
              goto LABEL_59;
            }
          }
        }
      }
      unsigned int v37 = 0;
LABEL_64:
      if (v12 < v37)
      {
        unint64_t v12 = v37;
        *(void *)(a3 + 48) = v37;
      }
      ++v7;
      uint64_t v6 = *(void *)(v6 + 8);
      if (v6 == v5)
      {
        *(void *)a3 = v7;
        break;
      }
    }
  }
  *(void *)(a3 + 56) = (a2[4] - a2[3]) >> 3;
  return result;
}

void llvm::GlobalsAAResult::DeletionCallbackHandle::deleted(llvm::GlobalsAAResult::DeletionCallbackHandle *this)
{
  uint64_t v2 = *((void *)this + 3);
  unsigned int v3 = *(unsigned __int8 *)(v2 + 16);
  if (*(unsigned char *)(v2 + 16)) {
    int v4 = 0;
  }
  else {
    int v4 = (void *)*((void *)this + 3);
  }
  uint64_t v86 = v4;
  if (v4)
  {
    sub_1CBFF1B00((int32x2_t *)(*((void *)this + 4) + 272), &v86);
    unsigned int v3 = *(unsigned __int8 *)(v2 + 16);
  }
  if (v3 <= 3)
  {
    uint64_t v5 = *((void *)this + 4);
    uint64_t v7 = *(void *)(v5 + 48);
    uint64_t v6 = *(void *)(v5 + 56);
    if (v6 == v7)
    {
      uint64_t v8 = *(unsigned int *)(v5 + 68);
      uint64_t v9 = (void *)(v6 + 8 * v8);
      if (v8)
      {
        uint64_t v10 = 0;
        uint64_t v11 = 8 * v8;
        while (*(void *)(v6 + v10) != v2)
        {
          v10 += 8;
          if (v11 == v10) {
            goto LABEL_25;
          }
        }
        uint64_t v9 = (void *)(v6 + v10);
      }
LABEL_25:
      uint64_t v7 = *(void *)(v5 + 56);
    }
    else
    {
      uint64_t v12 = *(unsigned int *)(v5 + 64);
      int v13 = v12 - 1;
      unsigned int v14 = (v12 - 1) & ((v2 >> 4) ^ (v2 >> 9));
      uint64_t v9 = (void *)(v6 + 8 * v14);
      uint64_t v15 = *v9;
      if (*v9 == -1)
      {
        uint64_t v16 = 0;
LABEL_104:
        if (v16) {
          uint64_t v9 = v16;
        }
        if (*v9 != v2) {
          uint64_t v9 = (void *)(v6 + 8 * v12);
        }
      }
      else
      {
        uint64_t v16 = 0;
        int v17 = 1;
        while (v15 != v2)
        {
          if (v16) {
            BOOL v18 = 0;
          }
          else {
            BOOL v18 = v15 == -2;
          }
          if (v18) {
            uint64_t v16 = v9;
          }
          unsigned int v19 = v14 + v17++;
          unsigned int v14 = v19 & v13;
          uint64_t v9 = (void *)(v6 + 8 * (v19 & v13));
          uint64_t v15 = *v9;
          if (*v9 == -1) {
            goto LABEL_104;
          }
        }
      }
    }
    BOOL v18 = v6 == v7;
    uint64_t v20 = 64;
    if (v18) {
      uint64_t v20 = 68;
    }
    if (v9 != (void *)(v6 + 8 * *(unsigned int *)(v5 + v20)))
    {
      *uint64_t v9 = -2;
      ++*(_DWORD *)(v5 + 72);
      uint64_t v21 = *((void *)this + 4);
      uint64_t v23 = *(void *)(v21 + 152);
      uint64_t v22 = *(void *)(v21 + 160);
      if (v22 == v23)
      {
        uint64_t v24 = *(unsigned int *)(v21 + 172);
        unsigned int v25 = (void *)(v22 + 8 * v24);
        if (v24)
        {
          uint64_t v26 = 0;
          uint64_t v27 = 8 * v24;
          while (*(void *)(v22 + v26) != v2)
          {
            v26 += 8;
            if (v27 == v26) {
              goto LABEL_47;
            }
          }
          unsigned int v25 = (void *)(v22 + v26);
        }
LABEL_47:
        uint64_t v23 = *(void *)(v21 + 160);
      }
      else
      {
        uint64_t v28 = *(unsigned int *)(v21 + 168);
        int v29 = v28 - 1;
        unsigned int v30 = (v28 - 1) & ((v2 >> 4) ^ (v2 >> 9));
        unsigned int v25 = (void *)(v22 + 8 * v30);
        uint64_t v31 = *v25;
        if (*v25 == -1)
        {
          uint64_t v32 = 0;
LABEL_109:
          if (v32) {
            unsigned int v25 = v32;
          }
          if (*v25 != v2) {
            unsigned int v25 = (void *)(v22 + 8 * v28);
          }
        }
        else
        {
          uint64_t v32 = 0;
          int v33 = 1;
          while (v31 != v2)
          {
            if (v32) {
              BOOL v34 = 0;
            }
            else {
              BOOL v34 = v31 == -2;
            }
            if (v34) {
              uint64_t v32 = v25;
            }
            unsigned int v35 = v30 + v33++;
            unsigned int v30 = v35 & v29;
            unsigned int v25 = (void *)(v22 + 8 * (v35 & v29));
            uint64_t v31 = *v25;
            if (*v25 == -1) {
              goto LABEL_109;
            }
          }
        }
      }
      BOOL v18 = v22 == v23;
      uint64_t v36 = 168;
      if (v18) {
        uint64_t v36 = 172;
      }
      if (v25 != (void *)(v22 + 8 * *(unsigned int *)(v21 + v36)))
      {
        void *v25 = -2;
        ++*(_DWORD *)(v21 + 176);
        uint64_t v21 = *((void *)this + 4);
        uint64_t v37 = *(void *)(v21 + 248);
        uint64_t v38 = *(unsigned int *)(v21 + 264);
        uint64_t v39 = (void *)(v37 + 16 * v38);
        if (*(_DWORD *)(v21 + 256))
        {
          if (v38)
          {
            uint64_t v40 = 16 * v38;
            uint64_t v41 = *(void **)(v21 + 248);
            while ((*v41 | 0x1000) == 0xFFFFFFFFFFFFF000)
            {
              v41 += 2;
              v40 -= 16;
              if (!v40) {
                goto LABEL_56;
              }
            }
          }
          else
          {
            uint64_t v41 = *(void **)(v21 + 248);
          }
        }
        else
        {
LABEL_56:
          uint64_t v41 = (void *)(v37 + 16 * v38);
        }
        uint64_t v42 = (void *)(v37 + 16 * v38);
        if (v41 != v42)
        {
          do
          {
            if (v41[1] == v2)
            {
              uint64_t v43 = (int32x2_t *)*((void *)this + 4);
              *uint64_t v41 = -8192;
              v43[32] = vadd_s32(v43[32], (int32x2_t)0x1FFFFFFFFLL);
            }
            unint64_t v44 = v41 + 2;
            uint64_t v41 = v39;
            if (v44 != v39)
            {
              uint64_t v41 = v44;
              while ((*v41 | 0x1000) == 0xFFFFFFFFFFFFF000)
              {
                v41 += 2;
                if (v41 == v39)
                {
                  uint64_t v41 = v39;
                  break;
                }
              }
            }
          }
          while (v41 != v42);
          uint64_t v21 = *((void *)this + 4);
        }
      }
      int v45 = *(_DWORD *)(v21 + 280);
      int v46 = *(void **)(v21 + 272);
      uint64_t v47 = *(unsigned int *)(v21 + 288);
      BOOL v48 = &v46[2 * v47];
      if (v45)
      {
        if (v47)
        {
          uint64_t v49 = 16 * v47;
          int v50 = v46;
          while ((*v50 | 0x1000) == 0xFFFFFFFFFFFFF000)
          {
            v50 += 2;
            v49 -= 16;
            if (!v49) {
              goto LABEL_73;
            }
          }
        }
        else
        {
          int v50 = v46;
        }
      }
      else
      {
LABEL_73:
        int v50 = &v46[2 * v47];
      }
      uint64_t v51 = &v46[2 * v47];
      while (v50 != v51)
      {
        uint64_t v52 = v50[1];
        int v53 = (_DWORD *)(v52 & 0xFFFFFFFFFFFFFFF8);
        if ((v52 & 0xFFFFFFFFFFFFFFF8) != 0)
        {
          uint64_t v86 = 0;
          if (sub_1CBFF5EC8(v52 & 0xFFFFFFFFFFFFFFF8, v2, &v86))
          {
            *uint64_t v86 = -8192;
            int v54 = v53[1] + 1;
            *v53 -= 2;
            v53[1] = v54;
          }
        }
        int v55 = v50 + 2;
        int v50 = v48;
        if (v55 != v48)
        {
          int v50 = v55;
          while ((*v50 | 0x1000) == 0xFFFFFFFFFFFFF000)
          {
            v50 += 2;
            if (v50 == v48)
            {
              int v50 = v48;
              break;
            }
          }
        }
      }
    }
  }
  uint64_t v56 = *((void *)this + 4);
  uint64_t v86 = 0;
  if (sub_1CBFF64C0(*(void *)(v56 + 248), *(_DWORD *)(v56 + 264), v2, &v86))
  {
    *uint64_t v86 = -8192;
    *(int32x2_t *)(v56 + 256) = vadd_s32(*(int32x2_t *)(v56 + 256), (int32x2_t)0x1FFFFFFFFLL);
  }
  uint64_t v57 = *((void *)this + 3);
  if (v57)
  {
    if ((v57 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      unint64_t v62 = *((void *)this + 1) & 0xFFFFFFFFFFFFFFF8;
      *(void *)unint64_t v62 = *((void *)this + 2);
      uint64_t v63 = (unint64_t *)*((void *)this + 2);
      if (v63)
      {
        *uint64_t v63 = *v63 & 7 | v62;
      }
      else
      {
        uint64_t v64 = *((void *)this + 3);
        uint64_t v65 = ***(int32x2_t ****)v64;
        unint64_t v66 = (unint64_t)v65[303];
        if (v66 <= v62)
        {
          uint64_t v67 = v65[305].u32[0];
          if (v66 + 16 * v67 > v62)
          {
            unsigned int v68 = v67 - 1;
            LODWORD(v69) = v68 & ((v64 >> 4) ^ (v64 >> 9));
            int64_t v70 = (uint64_t *)(v66 + 16 * v69);
            uint64_t v71 = *v70;
            if (v64 == *v70)
            {
LABEL_100:
              *int64_t v70 = -8192;
              v65[304] = vadd_s32(v65[304], (int32x2_t)0x1FFFFFFFFLL);
              uint64_t v64 = *((void *)this + 3);
            }
            else
            {
              int v72 = 1;
              while (v71 != -4096)
              {
                int v73 = v69 + v72++;
                uint64_t v69 = v73 & v68;
                uint64_t v71 = *(void *)(v66 + 16 * v69);
                if (v64 == v71)
                {
                  int64_t v70 = (uint64_t *)(v66 + 16 * v69);
                  goto LABEL_100;
                }
              }
            }
            *(unsigned char *)(v64 + 17) &= ~1u;
          }
        }
      }
    }
    *((void *)this + 3) = 0;
  }
  uint64_t v59 = *((void *)this + 4);
  uint64_t v58 = (uint64_t *)*((void *)this + 5);
  uint64_t v60 = *v58;
  *(void *)(v60 + 8) = v58[1];
  *(void *)v58[1] = v60;
  --*(void *)(v59 + 336);
  uint64_t v61 = v58[5];
  if (v61 && v61 != -8192 && v61 != -4096)
  {
    unint64_t v74 = v58[3] & 0xFFFFFFFFFFFFFFF8;
    *(void *)unint64_t v74 = v58[4];
    uint8x8_t v75 = (unint64_t *)v58[4];
    if (v75)
    {
      *uint8x8_t v75 = *v75 & 7 | v74;
    }
    else
    {
      uint64_t v76 = v58[5];
      unsigned int v77 = ***(int32x2_t ****)v76;
      unint64_t v78 = (unint64_t)v77[303];
      if (v78 <= v74)
      {
        uint64_t v79 = v77[305].u32[0];
        if (v78 + 16 * v79 > v74)
        {
          unsigned int v80 = v79 - 1;
          LODWORD(v8sub_1CD456CB4((void *)this + 1) = v80 & ((v76 >> 4) ^ (v76 >> 9));
          int v82 = (uint64_t *)(v78 + 16 * v81);
          uint64_t v83 = *v82;
          if (v76 == *v82)
          {
LABEL_123:
            *int v82 = -8192;
            v77[304] = vadd_s32(v77[304], (int32x2_t)0x1FFFFFFFFLL);
            uint64_t v76 = v58[5];
          }
          else
          {
            int v84 = 1;
            while (v83 != -4096)
            {
              int v85 = v81 + v84++;
              uint64_t v81 = v85 & v80;
              uint64_t v83 = *(void *)(v78 + 16 * v81);
              if (v76 == v83)
              {
                int v82 = (uint64_t *)(v78 + 16 * v81);
                goto LABEL_123;
              }
            }
          }
          *(unsigned char *)(v76 + 17) &= ~1u;
        }
      }
    }
  }
  operator delete(v58);
}

int32x2_t sub_1CBFF1B00(int32x2_t *a1, void *a2)
{
  uint64_t v6 = 0;
  if (sub_1CBA0E618((uint64_t)a1, a2, &v6))
  {
    int v4 = v6;
    unint64_t v5 = v6[1] & 0xFFFFFFFFFFFFFFF8;
    if (v5)
    {
      if ((*(unsigned char *)v5 & 1) == 0) {
        MEMORY[0x1D25D9CD0](*(void *)(v5 + 8), 8);
      }
      MEMORY[0x1D25D9CE0](v5, 0x1000C400BDB4DB4);
    }
    *int v4 = -8192;
    int32x2_t result = vadd_s32(a1[1], (int32x2_t)0x1FFFFFFFFLL);
    a1[1] = result;
  }
  return result;
}

uint64_t llvm::GlobalsAAResult::getModRefBehavior(llvm::GlobalsAAResult *this, const Function *a2)
{
  unint64_t v5 = a2;
  uint64_t v6 = 0;
  int v3 = sub_1CBA0E618((uint64_t)this + 272, &v5, &v6);
  uint64_t result = 63;
  if (v3 && v6 != *((void *)this + 34) + 16 * *((unsigned int *)this + 72))
  {
    if ((*(unsigned char *)(v6 + 8) & 3) != 0)
    {
      if ((*(unsigned char *)(v6 + 8) & 2) != 0) {
        return 63;
      }
      else {
        return 61;
      }
    }
    else
    {
      return 4;
    }
  }
  return result;
}

uint64_t llvm::GlobalsAAResult::getFunctionInfo(llvm::GlobalsAAResult *this, const Function *a2)
{
  uint64_t v6 = a2;
  uint64_t v7 = 0;
  int v3 = sub_1CBA0E618((uint64_t)this + 272, &v6, &v7);
  uint64_t v4 = v7;
  if (!v3) {
    uint64_t v4 = *((void *)this + 34) + 16 * *((unsigned int *)this + 72);
  }
  if (v4 == *((void *)this + 34) + 16 * *((unsigned int *)this + 72)) {
    return 0;
  }
  else {
    return v4 + 8;
  }
}

uint64_t llvm::GlobalsAAResult::getModRefBehavior(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a2 + 20);
  if (v3 < 0 && (*(void *)(a2 - 32 * (v3 & 0x7FFFFFF) - 8) & 0xFFFFFFFF0) != 0) {
    return 63;
  }
  uint64_t v4 = *(void *)(a2 - 32);
  if (!v4 || *(unsigned char *)(v4 + 16) || *(void *)(v4 + 24) != *(void *)(a2 + 72)) {
    return 63;
  }
  uint64_t v7 = *(void *)(a2 - 32);
  uint64_t v8 = 0;
  int v5 = sub_1CBA0E618(a1 + 272, &v7, &v8);
  uint64_t result = 63;
  if (v5 && v8 != *(void *)(a1 + 272) + 16 * *(unsigned int *)(a1 + 288))
  {
    if ((*(unsigned char *)(v8 + 8) & 3) != 0)
    {
      if ((*(unsigned char *)(v8 + 8) & 2) != 0) {
        return 63;
      }
      else {
        return 61;
      }
    }
    else
    {
      return 4;
    }
  }
  return result;
}

void llvm::GlobalsAAResult::AnalyzeGlobals(llvm::GlobalsAAResult *this, llvm::Module *a2)
{
  uint64_t v108 = v112;
  uint64_t v109 = v112;
  uint64_t v110 = 32;
  int v111 = 0;
  uint64_t v4 = (char *)a2 + 24;
  int v5 = (char *)*((void *)a2 + 4);
  if (v5 != (char *)a2 + 24)
  {
    do
    {
      if (v5) {
        uint64_t v6 = v5 - 56;
      }
      else {
        uint64_t v6 = 0;
      }
      if ((*((_DWORD *)v6 + 8) & 0xFu) - 7 <= 1)
      {
        if ((llvm::GlobalsAAResult::AnalyzeUsesOfPointer((uint64_t)this, v6, 0, 0, 0) & 1) == 0)
        {
          uint64_t v7 = *((void *)this + 7);
          uint64_t v8 = *((unsigned int *)this + 17);
          if (v7 == *((void *)this + 6))
          {
            if (v8)
            {
              uint64_t v9 = 0;
              uint64_t v10 = 8 * v8;
              uint64_t v11 = (char **)*((void *)this + 7);
              while (*v11 != v6)
              {
                if (*v11 == (char *)-2) {
                  uint64_t v9 = v11;
                }
                ++v11;
                v10 -= 8;
                if (!v10)
                {
                  if (!v9) {
                    goto LABEL_17;
                  }
                  *uint64_t v9 = v6;
                  --*((_DWORD *)this + 18);
                  break;
                }
              }
LABEL_19:
              int v13 = v109;
              uint64_t v14 = HIDWORD(v110);
              if (v109 == v108)
              {
                if (HIDWORD(v110))
                {
                  uint64_t v15 = 0;
                  uint64_t v16 = 8 * HIDWORD(v110);
                  int v17 = v109;
                  while (*(char **)v17 != v6)
                  {
                    if (*(void *)v17 == -2) {
                      uint64_t v15 = v17;
                    }
                    v17 += 8;
                    v16 -= 8;
                    if (!v16)
                    {
                      if (!v15) {
                        goto LABEL_27;
                      }
                      void *v15 = v6;
                      --v111;
                      goto LABEL_29;
                    }
                  }
                  goto LABEL_29;
                }
LABEL_27:
                unsigned int v18 = v110;
                if (HIDWORD(v110) < v110)
                {
                  ++HIDWORD(v110);
                  *(void *)&v109[8 * v14] = v6;
LABEL_29:
                  unsigned int v19 = operator new(0x40uLL);
                  v19[3] = 2;
                  *unsigned int v19 = 0;
                  v19[1] = 0;
                  v19[4] = 0;
                  v19[5] = v6;
                  if (v6 != (char *)-8192 && v6 != (char *)-4096 && v6) {
                    llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)(v19 + 3));
                  }
                  v19[6] = this;
                  uint64_t v20 = (void *)*((void *)this + 41);
                  *unsigned int v19 = (char *)this + 320;
                  v19[1] = v20;
                  void v19[2] = &unk_1F2603480;
                  *uint64_t v20 = v19;
                  uint64_t v21 = *((void *)this + 42) + 1;
                  *((void *)this + 4sub_1CD456CB4((void *)this + 1) = v19;
                  *((void *)this + 42) = v21;
                  v19[7] = v19;
                  goto LABEL_6;
                }
              }
              else
              {
                unsigned int v18 = v110;
              }
              if (3 * v18 <= 4 * (HIDWORD(v110) - v111))
              {
                if (v18 >= 0x40) {
                  v18 *= 2;
                }
                else {
                  unsigned int v18 = 128;
                }
              }
              else if (v18 - HIDWORD(v110) >= v18 >> 3)
              {
                goto LABEL_51;
              }
              llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v108, v18);
              unsigned int v18 = v110;
              int v13 = v109;
LABEL_51:
              unsigned int v30 = v18 - 1;
              unsigned int v31 = (v18 - 1) & ((v6 >> 4) ^ (v6 >> 9));
              uint64_t v32 = &v13[8 * v31];
              int v33 = *(char **)v32;
              if (*(void *)v32 == -1)
              {
                BOOL v34 = 0;
LABEL_71:
                if (v34) {
                  uint64_t v39 = v34;
                }
                else {
                  uint64_t v39 = v32;
                }
                if (*(char **)v39 != v6)
                {
                  if (*(void *)v39 == -2) {
                    --v111;
                  }
                  else {
                    ++HIDWORD(v110);
                  }
                  *(void *)uint64_t v39 = v6;
                }
              }
              else
              {
                BOOL v34 = 0;
                int v35 = 1;
                while (v33 != v6)
                {
                  if (v34) {
                    BOOL v36 = 0;
                  }
                  else {
                    BOOL v36 = v33 == (char *)-2;
                  }
                  if (v36) {
                    BOOL v34 = v32;
                  }
                  unsigned int v37 = v31 + v35++;
                  unsigned int v31 = v37 & v30;
                  uint64_t v32 = &v13[8 * (v37 & v30)];
                  int v33 = *(char **)v32;
                  if (*(void *)v32 == -1) {
                    goto LABEL_71;
                  }
                }
              }
              goto LABEL_29;
            }
LABEL_17:
            unsigned int v12 = *((_DWORD *)this + 16);
            if (v8 < v12)
            {
              *((_DWORD *)this + 17) = v8 + 1;
              *(void *)(v7 + 8 * v8) = v6;
              goto LABEL_19;
            }
          }
          else
          {
            unsigned int v12 = *((_DWORD *)this + 16);
          }
          if (3 * v12 <= 4 * ((int)v8 - *((_DWORD *)this + 18)))
          {
            if (v12 >= 0x40) {
              v12 *= 2;
            }
            else {
              unsigned int v12 = 128;
            }
          }
          else if (v12 - v8 >= v12 >> 3)
          {
            goto LABEL_37;
          }
          llvm::SmallPtrSetImplBase::Grow((llvm::GlobalsAAResult *)((char *)this + 48), v12);
          unsigned int v12 = *((_DWORD *)this + 16);
          uint64_t v7 = *((void *)this + 7);
LABEL_37:
          unsigned int v22 = v12 - 1;
          unsigned int v23 = (v12 - 1) & ((v6 >> 4) ^ (v6 >> 9));
          uint64_t v24 = (char **)(v7 + 8 * v23);
          unsigned int v25 = *v24;
          if (*v24 == (char *)-1)
          {
            uint64_t v26 = 0;
LABEL_63:
            if (v26) {
              uint64_t v38 = v26;
            }
            else {
              uint64_t v38 = v24;
            }
            if (*v38 != v6)
            {
              if (*v38 == (char *)-2) {
                --*((_DWORD *)this + 18);
              }
              else {
                ++*((_DWORD *)this + 17);
              }
              *uint64_t v38 = v6;
            }
          }
          else
          {
            uint64_t v26 = 0;
            int v27 = 1;
            while (v25 != v6)
            {
              if (v26) {
                BOOL v28 = 0;
              }
              else {
                BOOL v28 = v25 == (char *)-2;
              }
              if (v28) {
                uint64_t v26 = v24;
              }
              unsigned int v29 = v23 + v27++;
              unsigned int v23 = v29 & v22;
              uint64_t v24 = (char **)(v7 + 8 * (v29 & v22));
              unsigned int v25 = *v24;
              if (*v24 == (char *)-1) {
                goto LABEL_63;
              }
            }
          }
          goto LABEL_19;
        }
        *((unsigned char *)this + 144) = 1;
      }
LABEL_6:
      int v5 = (char *)*((void *)v5 + 1);
    }
    while (v5 != v4);
  }
  uint64_t v103 = v107;
  uint64_t v104 = v107;
  uint64_t v105 = 16;
  int v106 = 0;
  uint64_t v98 = v102;
  int v99 = v102;
  uint64_t v100 = 16;
  int v101 = 0;
  uint64_t v40 = (void *)*((void *)a2 + 2);
  if (v40 == (void *)((char *)a2 + 8)) {
    goto LABEL_202;
  }
  uint64_t v41 = (char *)this + 320;
  do
  {
    if (v40) {
      uint64_t v42 = (uint64_t)(v40 - 7);
    }
    else {
      uint64_t v42 = 0;
    }
    if ((*(_DWORD *)(v42 + 32) & 0xFu) - 7 > 1) {
      goto LABEL_166;
    }
    if (*(unsigned char *)(v42 + 80)) {
      uint64_t v43 = 0;
    }
    else {
      uint64_t v43 = (void **)&v98;
    }
    if ((llvm::GlobalsAAResult::AnalyzeUsesOfPointer((uint64_t)this, (void *)v42, (uint64_t)&v103, (uint64_t)v43, 0) & 1) == 0)
    {
      uint64_t v44 = *((void *)this + 7);
      if (v44 == *((void *)this + 6))
      {
        uint64_t v45 = *((unsigned int *)this + 17);
        if (v45)
        {
          int v46 = 0;
          uint64_t v47 = 8 * v45;
          BOOL v48 = (uint64_t *)*((void *)this + 7);
          while (*v48 != v42)
          {
            if (*v48 == -2) {
              int v46 = v48;
            }
            ++v48;
            v47 -= 8;
            if (!v47)
            {
              if (!v46) {
                goto LABEL_99;
              }
              *int v46 = v42;
              --*((_DWORD *)this + 18);
              break;
            }
          }
LABEL_101:
          uint64_t v49 = operator new(0x40uLL);
          v49[3] = 2;
          *uint64_t v49 = 0;
          v49[1] = 0;
          v49[4] = 0;
          v49[5] = v42;
          if (v42 != -8192 && v42 != -4096 && v42) {
            llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)(v49 + 3));
          }
          v49[6] = this;
          int v50 = (void *)*((void *)this + 41);
          *uint64_t v49 = v41;
          v49[1] = v50;
          v49[2] = &unk_1F2603480;
          *int v50 = v49;
          uint64_t v51 = *((void *)this + 42) + 1;
          *((void *)this + 4sub_1CD456CB4((void *)this + 1) = v49;
          *((void *)this + 42) = v51;
          v49[7] = v49;
          if (v104 == v103) {
            uint64_t v52 = (uint64_t *)((char *)&v105 + 4);
          }
          else {
            uint64_t v52 = &v105;
          }
          uint64_t v53 = *(unsigned int *)v52;
          if (v53)
          {
            uint64_t v54 = 8 * v53;
            int v55 = v104;
            while (*(void *)v55 >= 0xFFFFFFFFFFFFFFFELL)
            {
              v55 += 8;
              v54 -= 8;
              if (!v54) {
                goto LABEL_152;
              }
            }
          }
          else
          {
            int v55 = v104;
          }
          uint64_t v56 = &v104[8 * v53];
          if (v55 == v56) {
            goto LABEL_152;
          }
LABEL_114:
          int v97 = 0;
          uint64_t v57 = *(const void **)v55;
          int v97 = *(const void **)v55;
          uint64_t v58 = v109;
          uint64_t v59 = HIDWORD(v110);
          if (v109 == v108)
          {
            if (HIDWORD(v110))
            {
              uint64_t v60 = 0;
              uint64_t v61 = 8 * HIDWORD(v110);
              unint64_t v62 = v109;
              while (*(const void **)v62 != v57)
              {
                if (*(void *)v62 == -2) {
                  uint64_t v60 = v62;
                }
                v62 += 8;
                v61 -= 8;
                if (!v61)
                {
                  if (!v60) {
                    goto LABEL_122;
                  }
                  *(void *)uint64_t v60 = v57;
                  --v111;
                  goto LABEL_124;
                }
              }
              goto LABEL_125;
            }
LABEL_122:
            unsigned int v63 = v110;
            if (HIDWORD(v110) < v110)
            {
              ++HIDWORD(v110);
              *(void *)&v109[8 * v59] = v57;
              goto LABEL_124;
            }
          }
          else
          {
            unsigned int v63 = v110;
          }
          if (3 * v63 <= 4 * (HIDWORD(v110) - v111))
          {
            if (v63 >= 0x40) {
              v63 *= 2;
            }
            else {
              unsigned int v63 = 128;
            }
          }
          else if (v63 - HIDWORD(v110) >= v63 >> 3)
          {
LABEL_132:
            unsigned int v70 = v63 - 1;
            unsigned int v71 = (v63 - 1) & ((v57 >> 4) ^ (v57 >> 9));
            int v72 = &v58[8 * v71];
            int v73 = *(const void **)v72;
            if (*(void *)v72 != -1)
            {
              unint64_t v74 = 0;
              int v75 = 1;
              while (v73 != v57)
              {
                if (v74) {
                  BOOL v76 = 0;
                }
                else {
                  BOOL v76 = v73 == (const void *)-2;
                }
                if (v76) {
                  unint64_t v74 = v72;
                }
                unsigned int v77 = v71 + v75++;
                unsigned int v71 = v77 & v70;
                int v72 = &v58[8 * (v77 & v70)];
                int v73 = *(const void **)v72;
                if (*(void *)v72 == -1) {
                  goto LABEL_144;
                }
              }
              goto LABEL_125;
            }
            unint64_t v74 = 0;
LABEL_144:
            if (v74) {
              unint64_t v78 = (const void **)v74;
            }
            else {
              unint64_t v78 = (const void **)v72;
            }
            if (*v78 == v57) {
              goto LABEL_125;
            }
            if (*v78 == (const void *)-2) {
              --v111;
            }
            else {
              ++HIDWORD(v110);
            }
            void *v78 = v57;
LABEL_124:
            uint64_t v64 = sub_1CBFF6554((uint64_t)this, (uint64_t)v97);
            void *v64 = v41;
            uint64_t v65 = (void *)*((void *)this + 41);
            v64[1] = v65;
            *uint64_t v65 = v64;
            uint64_t v66 = *((void *)this + 42) + 1;
            *((void *)this + 4sub_1CD456CB4((void *)this + 1) = v64;
            *((void *)this + 42) = v66;
            v64[7] = v64;
LABEL_125:
            uint64_t v67 = sub_1CBFF65DC((_DWORD *)this + 68, &v97);
            sub_1CBFF2EE4(v67 + 1, v42, 5);
            unsigned int v68 = (unint64_t *)(v55 + 8);
            while (v68 != (unint64_t *)v56)
            {
              unint64_t v69 = *v68++;
              if (v69 <= 0xFFFFFFFFFFFFFFFDLL)
              {
                int v55 = (char *)(v68 - 1);
                goto LABEL_114;
              }
            }
LABEL_152:
            if (*(unsigned char *)(v42 + 80)) {
              goto LABEL_160;
            }
            uint64_t v79 = v99 == v98 ? (uint64_t *)((char *)&v100 + 4) : &v100;
            uint64_t v80 = *(unsigned int *)v79;
            if (v80)
            {
              uint64_t v81 = 8 * v80;
              int v82 = v99;
              while (*(void *)v82 >= 0xFFFFFFFFFFFFFFFELL)
              {
                v82 += 8;
                v81 -= 8;
                if (!v81) {
                  goto LABEL_160;
                }
              }
            }
            else
            {
              int v82 = v99;
            }
            uint64_t v83 = &v99[8 * v80];
            if (v82 == v83) {
              goto LABEL_160;
            }
LABEL_168:
            int v97 = 0;
            int v84 = *(const void **)v82;
            int v97 = *(const void **)v82;
            if (v109 != v108) {
              goto LABEL_182;
            }
            uint64_t v85 = HIDWORD(v110);
            if (HIDWORD(v110))
            {
              uint64_t v86 = 0;
              uint64_t v87 = 8 * HIDWORD(v110);
              int v88 = v109;
              while (*(const void **)v88 != v84)
              {
                if (*(void *)v88 == -2) {
                  uint64_t v86 = v88;
                }
                v88 += 8;
                v87 -= 8;
                if (!v87)
                {
                  if (!v86) {
                    goto LABEL_176;
                  }
                  *(void *)uint64_t v86 = v84;
                  --v111;
                  goto LABEL_178;
                }
              }
              goto LABEL_179;
            }
LABEL_176:
            if (HIDWORD(v110) < v110)
            {
              ++HIDWORD(v110);
              *(void *)&v109[8 * v85] = v84;
            }
            else
            {
LABEL_182:
              llvm::SmallPtrSetImplBase::insert_imp_big((llvm::SmallPtrSetImplBase *)&v108, v84);
              if (!v94)
              {
LABEL_179:
                uint64_t v92 = sub_1CBFF65DC((_DWORD *)this + 68, &v97);
                sub_1CBFF2EE4(v92 + 1, v42, 6);
                int v93 = (unint64_t *)(v82 + 8);
                while (v93 != (unint64_t *)v83)
                {
                  unint64_t v96 = *v93++;
                  if (v96 <= 0xFFFFFFFFFFFFFFFDLL)
                  {
                    int v82 = (char *)(v93 - 1);
                    goto LABEL_168;
                  }
                }
LABEL_160:
                if (*(unsigned char *)(*(void *)(v42 + 24) + 8) == 15) {
                  llvm::GlobalsAAResult::AnalyzeIndirectGlobalMemory(this, (llvm::GlobalVariable *)v42);
                }
                goto LABEL_162;
              }
            }
LABEL_178:
            int v89 = sub_1CBFF6554((uint64_t)this, (uint64_t)v97);
            void *v89 = v41;
            uint64_t v90 = (void *)*((void *)this + 41);
            v89[1] = v90;
            void *v90 = v89;
            uint64_t v91 = *((void *)this + 42) + 1;
            *((void *)this + 4sub_1CD456CB4((void *)this + 1) = v89;
            *((void *)this + 42) = v91;
            v89[7] = v89;
            goto LABEL_179;
          }
          llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v108, v63);
          unsigned int v63 = v110;
          uint64_t v58 = v109;
          goto LABEL_132;
        }
LABEL_99:
        if (v45 < *((_DWORD *)this + 16))
        {
          *((_DWORD *)this + 17) = v45 + 1;
          *(void *)(v44 + 8 * v45) = v42;
          goto LABEL_101;
        }
      }
      llvm::SmallPtrSetImplBase::insert_imp_big((llvm::GlobalsAAResult *)((char *)this + 48), (const void *)v42);
      goto LABEL_101;
    }
LABEL_162:
    if (v104 != v103)
    {
      if (v105 >= 0x21 && 4 * (HIDWORD(v105) - v106) < v105)
      {
        llvm::SmallPtrSetImplBase::shrink_and_clear((void **)&v103);
        goto LABEL_164;
      }
      memset(v104, 255, 8 * v105);
    }
    HIDWORD(v105) = 0;
    int v106 = 0;
LABEL_164:
    if (v99 == v98) {
      goto LABEL_165;
    }
    if (v100 < 0x21 || 4 * (HIDWORD(v100) - v101) >= v100)
    {
      memset(v99, 255, 8 * v100);
LABEL_165:
      HIDWORD(v100) = 0;
      int v101 = 0;
      goto LABEL_166;
    }
    llvm::SmallPtrSetImplBase::shrink_and_clear((void **)&v98);
LABEL_166:
    uint64_t v40 = (void *)v40[1];
  }
  while (v40 != (void *)((char *)a2 + 8));
  if (v99 != v98) {
    free(v99);
  }
LABEL_202:
  if (v104 != v103) {
    free(v104);
  }
  if (v109 != v108) {
    free(v109);
  }
}

uint64_t llvm::GlobalsAAResult::AnalyzeUsesOfPointer(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, void *a5)
{
  if (*(unsigned char *)(*a2 + 8) != 15) {
    return 1;
  }
  for (unint64_t i = a2[1]; i; unint64_t i = *(void *)(i + 8))
  {
    uint64_t v11 = *(void *)(i + 24);
    unsigned int v12 = *(unsigned __int8 *)(v11 + 16);
    if (v11 && v12 == 60)
    {
      if (a3)
      {
        uint64_t v13 = *(void *)(*(void *)(v11 + 40) + 56);
        uint64_t v14 = *(void *)(a3 + 8);
        uint64_t v15 = *(unsigned int *)(a3 + 20);
        if (v14 != *(void *)a3)
        {
          unsigned int v19 = *(_DWORD *)(a3 + 16);
LABEL_35:
          if (3 * v19 <= 4 * ((int)v15 - *(_DWORD *)(a3 + 24)))
          {
            if (v19 >= 0x40) {
              v19 *= 2;
            }
            else {
              unsigned int v19 = 128;
            }
          }
          else if (v19 - v15 >= v19 >> 3)
          {
LABEL_37:
            unsigned int v28 = v19 - 1;
            unsigned int v29 = (v19 - 1) & ((v13 >> 4) ^ (v13 >> 9));
            unsigned int v30 = (void *)(v14 + 8 * v29);
            uint64_t v31 = *v30;
            if (*v30 != -1)
            {
              uint64_t v32 = 0;
              int v33 = 1;
              while (v31 != v13)
              {
                if (v32) {
                  BOOL v34 = 0;
                }
                else {
                  BOOL v34 = v31 == -2;
                }
                if (v34) {
                  uint64_t v32 = v30;
                }
                unsigned int v35 = v29 + v33++;
                unsigned int v29 = v35 & v28;
                unsigned int v30 = (void *)(v14 + 8 * (v35 & v28));
                uint64_t v31 = *v30;
                if (*v30 == -1) {
                  goto LABEL_60;
                }
              }
              continue;
            }
            uint64_t v32 = 0;
LABEL_60:
            if (v32) {
              uint64_t v40 = v32;
            }
            else {
              uint64_t v40 = v30;
            }
            if (*v40 == v13) {
              continue;
            }
            if (*v40 == -2) {
              --*(_DWORD *)(a3 + 24);
            }
            else {
              ++*(_DWORD *)(a3 + 20);
            }
            goto LABEL_66;
          }
          llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)a3, v19);
          unsigned int v19 = *(_DWORD *)(a3 + 16);
          uint64_t v14 = *(void *)(a3 + 8);
          goto LABEL_37;
        }
        if (v15)
        {
          uint64_t v16 = 0;
          uint64_t v17 = 8 * v15;
          unsigned int v18 = *(void **)(a3 + 8);
          while (*v18 != v13)
          {
            if (*v18 == -2) {
              uint64_t v16 = v18;
            }
            ++v18;
            v17 -= 8;
            if (!v17)
            {
              if (!v16) {
                goto LABEL_14;
              }
              *uint64_t v16 = v13;
              --*(_DWORD *)(a3 + 24);
              goto LABEL_84;
            }
          }
          continue;
        }
LABEL_14:
        unsigned int v19 = *(_DWORD *)(a3 + 16);
        if (v15 >= v19) {
          goto LABEL_35;
        }
        *(_DWORD *)(a3 + 20) = v15 + 1;
        goto LABEL_16;
      }
    }
    else
    {
      if (!v11 || v12 != 61)
      {
        if (v11) {
          BOOL v21 = v12 > 0x1B;
        }
        else {
          BOOL v21 = 0;
        }
        if (v21)
        {
          if (v12 == 77) {
            goto LABEL_69;
          }
          if (v12 == 62)
          {
LABEL_33:
            uint64_t v23 = a1;
            uint64_t v24 = *(void *)(i + 24);
            uint64_t v25 = a3;
            uint64_t v26 = a4;
            int v27 = 0;
            goto LABEL_70;
          }
          unsigned int v22 = v12 - 28;
LABEL_68:
          if (v22 == 50) {
            goto LABEL_69;
          }
        }
        else if (v11 && v12 == 5)
        {
          unsigned int v22 = *(unsigned __int16 *)(v11 + 18);
          if (v22 == 34) {
            goto LABEL_33;
          }
          if (v22 == 49)
          {
LABEL_69:
            uint64_t v23 = a1;
            uint64_t v24 = *(void *)(i + 24);
            uint64_t v25 = a3;
            uint64_t v26 = a4;
            int v27 = a5;
LABEL_70:
            if (llvm::GlobalsAAResult::AnalyzeUsesOfPointer(v23, v24, v25, v26, v27)) {
              return 1;
            }
            continue;
          }
          goto LABEL_68;
        }
        if (v12 < 0x1C)
        {
          uint64_t result = 1;
          if (!v11 || v12 - 21 < 0xFFFFFFEF) {
            return result;
          }
          if (llvm::Constant::isConstantUsed(*(llvm::Constant **)(i + 24))) {
            return 1;
          }
        }
        else if (v12 - 33 > 0x33 || ((1 << (v12 - 33)) & 0x8000000000041) == 0)
        {
          uint64_t result = 1;
          if (!v11 || v12 != 81 || *(unsigned char *)(*(void *)(v11 - 32) + 16) != 19) {
            return result;
          }
        }
        else
        {
          int v42 = *(_DWORD *)(v11 + 20);
          unint64_t v43 = v11 - 32 * (v42 & 0x7FFFFFF);
          if (v43 <= i)
          {
            if (v12 == 84) {
              uint64_t v44 = 0;
            }
            else {
              uint64_t v44 = v12 == 39 ? (*(_DWORD *)(v11 + 80) + 1) : 2;
            }
            if (v11 - 32 * v44 - 32 > i)
            {
              if (v12 == 84)
              {
                uint64_t v54 = 0;
              }
              else if (v12 == 39)
              {
                uint64_t v54 = (*(_DWORD *)(v11 + 80) + 1);
              }
              else
              {
                uint64_t v54 = 2;
              }
              if (v42 < 0 && (uint64_t v66 = *(void *)(v43 - 8), (v66 & 0xFFFFFFFF0) != 0)) {
                uint64_t v55 = (*(_DWORD *)(v43 - 12) - *(_DWORD *)(v43 - v66));
              }
              else {
                uint64_t v55 = 0;
              }
              if (v11 - 32 * v54 - 32 * v55 - 32 <= i) {
                return 1;
              }
              uint64_t v56 = *(void *)(a1 + 40);
              if (!v56)
              {
                sub_1CB920400();
                return sub_1CBFF2EE4();
              }
              uint64_t v57 = (uint64_t *)(*(uint64_t (**)(uint64_t, void))(*(void *)v56 + 48))(v56, *(void *)(*(void *)(v11 + 40) + 56));
              char v78 = 0;
              uint64_t v58 = (uint64_t ***)sub_1CC0960E8(v11, &v78);
              if (!v58) {
                return 1;
              }
              if (v78) {
                return 1;
              }
              unsigned int v77 = 0;
              BOOL v76 = (llvm::Function *)v58;
              if (!llvm::TargetLibraryInfoImpl::getLibFunc(*v57, v58, &v77)
                || ((*(void *)(v57[1] + (((unint64_t)v77 >> 3) & 0x1FFFFFF8)) >> v77) & 1) != 0
                || ((*(unsigned __int8 *)(*v57 + ((unint64_t)v77 >> 2)) >> (2 * (v77 & 3))) & 3) == 0
                || !llvm::isLibFreeFunction(v76, v77)
                || *(unsigned char *)(v11 + 16) != 84)
              {
                return 1;
              }
              if (a4)
              {
                uint64_t v59 = *(void *)(*(void *)(v11 + 40) + 56);
                uint64_t v60 = *(void *)(a4 + 8);
                uint64_t v61 = *(unsigned int *)(a4 + 20);
                if (v60 != *(void *)a4)
                {
                  unsigned int v65 = *(_DWORD *)(a4 + 16);
LABEL_156:
                  if (3 * v65 <= 4 * ((int)v61 - *(_DWORD *)(a4 + 24)))
                  {
                    if (v65 >= 0x40) {
                      v65 *= 2;
                    }
                    else {
                      unsigned int v65 = 128;
                    }
                  }
                  else if (v65 - v61 >= v65 >> 3)
                  {
                    goto LABEL_158;
                  }
                  llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)a4, v65);
                  unsigned int v65 = *(_DWORD *)(a4 + 16);
                  uint64_t v60 = *(void *)(a4 + 8);
LABEL_158:
                  unsigned int v67 = v65 - 1;
                  unsigned int v68 = (v65 - 1) & ((v59 >> 4) ^ (v59 >> 9));
                  unint64_t v69 = (void *)(v60 + 8 * v68);
                  uint64_t v70 = *v69;
                  if (*v69 == -1)
                  {
                    unsigned int v71 = 0;
LABEL_170:
                    if (v71) {
                      int v75 = v71;
                    }
                    else {
                      int v75 = v69;
                    }
                    if (*v75 != v59)
                    {
                      if (*v75 == -2) {
                        --*(_DWORD *)(a4 + 24);
                      }
                      else {
                        ++*(_DWORD *)(a4 + 20);
                      }
                      *int v75 = v59;
                    }
                  }
                  else
                  {
                    unsigned int v71 = 0;
                    int v72 = 1;
                    while (v70 != v59)
                    {
                      if (v71) {
                        BOOL v73 = 0;
                      }
                      else {
                        BOOL v73 = v70 == -2;
                      }
                      if (v73) {
                        unsigned int v71 = v69;
                      }
                      unsigned int v74 = v68 + v72++;
                      unsigned int v68 = v74 & v67;
                      unint64_t v69 = (void *)(v60 + 8 * (v74 & v67));
                      uint64_t v70 = *v69;
                      if (*v69 == -1) {
                        goto LABEL_170;
                      }
                    }
                  }
                  continue;
                }
                if (v61)
                {
                  unint64_t v62 = 0;
                  uint64_t v63 = 8 * v61;
                  uint64_t v64 = *(void **)(a4 + 8);
                  while (*v64 != v59)
                  {
                    if (*v64 == -2) {
                      unint64_t v62 = v64;
                    }
                    ++v64;
                    v63 -= 8;
                    if (!v63)
                    {
                      if (!v62) {
                        goto LABEL_137;
                      }
                      *unint64_t v62 = v59;
                      --*(_DWORD *)(a4 + 24);
                      goto LABEL_84;
                    }
                  }
                  continue;
                }
LABEL_137:
                unsigned int v65 = *(_DWORD *)(a4 + 16);
                if (v61 >= v65) {
                  goto LABEL_156;
                }
                *(_DWORD *)(a4 + 20) = v61 + 1;
                *(void *)(v60 + 8 * v6sub_1CD456CB4((void *)this + 1) = v59;
              }
            }
          }
        }
        continue;
      }
      uint64_t v20 = *(void **)(v11 - 32);
      if (v20 != a2)
      {
        if (v20 != a5) {
          return 1;
        }
        continue;
      }
      if (a4)
      {
        uint64_t v13 = *(void *)(*(void *)(v11 + 40) + 56);
        uint64_t v14 = *(void *)(a4 + 8);
        uint64_t v15 = *(unsigned int *)(a4 + 20);
        if (v14 != *(void *)a4)
        {
          unsigned int v39 = *(_DWORD *)(a4 + 16);
LABEL_87:
          if (3 * v39 <= 4 * ((int)v15 - *(_DWORD *)(a4 + 24)))
          {
            if (v39 >= 0x40) {
              v39 *= 2;
            }
            else {
              unsigned int v39 = 128;
            }
          }
          else if (v39 - v15 >= v39 >> 3)
          {
            goto LABEL_89;
          }
          llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)a4, v39);
          unsigned int v39 = *(_DWORD *)(a4 + 16);
          uint64_t v14 = *(void *)(a4 + 8);
LABEL_89:
          unsigned int v46 = v39 - 1;
          unsigned int v47 = (v39 - 1) & ((v13 >> 4) ^ (v13 >> 9));
          BOOL v48 = (void *)(v14 + 8 * v47);
          uint64_t v49 = *v48;
          if (*v48 != -1)
          {
            int v50 = 0;
            int v51 = 1;
            while (v49 != v13)
            {
              if (v50) {
                BOOL v52 = 0;
              }
              else {
                BOOL v52 = v49 == -2;
              }
              if (v52) {
                int v50 = v48;
              }
              unsigned int v53 = v47 + v51++;
              unsigned int v47 = v53 & v46;
              BOOL v48 = (void *)(v14 + 8 * (v53 & v46));
              uint64_t v49 = *v48;
              if (*v48 == -1) {
                goto LABEL_106;
              }
            }
            continue;
          }
          int v50 = 0;
LABEL_106:
          if (v50) {
            uint64_t v40 = v50;
          }
          else {
            uint64_t v40 = v48;
          }
          if (*v40 == v13) {
            continue;
          }
          if (*v40 == -2) {
            --*(_DWORD *)(a4 + 24);
          }
          else {
            ++*(_DWORD *)(a4 + 20);
          }
LABEL_66:
          void *v40 = v13;
          continue;
        }
        if (v15)
        {
          BOOL v36 = 0;
          uint64_t v37 = 8 * v15;
          uint64_t v38 = *(void **)(a4 + 8);
          while (*v38 != v13)
          {
            if (*v38 == -2) {
              BOOL v36 = v38;
            }
            ++v38;
            v37 -= 8;
            if (!v37)
            {
              if (!v36) {
                goto LABEL_57;
              }
              *BOOL v36 = v13;
              --*(_DWORD *)(a4 + 24);
              goto LABEL_84;
            }
          }
          continue;
        }
LABEL_57:
        unsigned int v39 = *(_DWORD *)(a4 + 16);
        if (v15 >= v39) {
          goto LABEL_87;
        }
        *(_DWORD *)(a4 + 20) = v15 + 1;
LABEL_16:
        *(void *)(v14 + 8 * v15) = v13;
      }
    }
LABEL_84:
    ;
  }
  return 0;
}

uint64_t sub_1CBFF2EE4(void *a1, uint64_t a2, char a3)
{
  int v5 = (_DWORD *)(*a1 & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    operator new();
  }
  uint64_t v11 = 0;
  uint64_t result = sub_1CBFF5EC8((uint64_t)v5, a2, &v11);
  uint64_t v7 = v11;
  if (result)
  {
    char v10 = *(unsigned char *)(v11 + 8);
    goto LABEL_10;
  }
  int v8 = *v5 >> 1;
  if (*v5) {
    unsigned int v9 = 16;
  }
  else {
    unsigned int v9 = v5[4];
  }
  if (4 * v8 + 4 >= 3 * v9)
  {
    v9 *= 2;
    goto LABEL_15;
  }
  if (v9 + ~v8 - v5[1] <= v9 >> 3)
  {
LABEL_15:
    sub_1CBFF5F6C((uint64_t)v5, v9);
    uint64_t v11 = 0;
    uint64_t result = sub_1CBFF5EC8((uint64_t)v5, a2, &v11);
    uint64_t v7 = v11;
  }
  *v5 += 2;
  if (*(void *)v7 != -4096) {
    --v5[1];
  }
  char v10 = 0;
  *(void *)uint64_t v7 = a2;
  *(unsigned char *)(v7 + 8) = 0;
LABEL_10:
  *(unsigned char *)(v7 + 8) = v10 | a3;
  return result;
}

uint64_t llvm::GlobalsAAResult::AnalyzeIndirectGlobalMemory(llvm::GlobalsAAResult *this, llvm::GlobalVariable *a2)
{
  uint64_t v4 = *((void *)a2 - 4);
  if (v4)
  {
    int v5 = *(unsigned __int8 *)(v4 + 16);
    if (v5 == 16)
    {
      uint64_t v6 = *(unsigned int *)(v4 + 32);
      if (v6 >= 0x41)
      {
        int v55 = 0;
        int64_t v56 = (unint64_t)(v6 + 63) >> 6;
        do
        {
          BOOL v19 = v56-- < 1;
          if (v19) {
            break;
          }
          unint64_t v57 = *(void *)(*(void *)(v4 + 24) + 8 * v56);
          v55 += __clz(v57);
        }
        while (!v57);
        uint64_t v7 = 0;
        int v58 = v6 | 0xFFFFFFC0;
        if ((v6 & 0x3F) == 0) {
          int v58 = 0;
        }
        if (v55 + v58 != v6) {
          return v7;
        }
      }
      else if (*(void *)(v4 + 24))
      {
        return 0;
      }
    }
    else if (v5 == 17)
    {
      if ((sub_1CB844168(v4, 0.0) & 1) == 0) {
        return 0;
      }
    }
    else
    {
      BOOL v8 = (v5 - 18) < 3 || v5 == 13;
      if (!v8) {
        return 0;
      }
    }
  }
  uint64_t v9 = *((void *)a2 + 1);
  if (v9)
  {
    char v10 = 0;
    uint64_t v11 = 0;
    unsigned int v12 = 0;
    while (1)
    {
      uint64_t v13 = *(void *)(v9 + 24);
      int v14 = *(unsigned __int8 *)(v13 + 16);
      if (v13 && v14 == 60)
      {
        if (llvm::GlobalsAAResult::AnalyzeUsesOfPointer((uint64_t)this, (void *)v13, 0, 0, 0)) {
          goto LABEL_61;
        }
      }
      else
      {
        if (!v13) {
          goto LABEL_61;
        }
        if (v14 != 61) {
          goto LABEL_61;
        }
        uint64_t v15 = *(llvm **)(v13 - 64);
        if (v15 == a2) {
          goto LABEL_61;
        }
        if (*((unsigned char *)v15 + 16) != 19)
        {
          UnderlyingObject = llvm::getUnderlyingObject(v15, (const llvm::Value *)6);
          unsigned int v17 = *((unsigned __int8 *)UnderlyingObject + 16);
          if (v17 < 0x1C
            || ((unsigned int v18 = v17 - 33, v19 = v18 > 0x33, v20 = (1 << v18) & 0x8000000000041, !v19)
              ? (BOOL v21 = v20 == 0)
              : (BOOL v21 = 1),
                v21
             || (unsigned int v22 = UnderlyingObject, !sub_1CBF5BCC4((uint64_t)UnderlyingObject, 19))
             || (llvm::GlobalsAAResult::AnalyzeUsesOfPointer((uint64_t)this, v22, 0, 0, a2) & 1) != 0))
          {
LABEL_61:
            uint64_t v7 = 0;
            if (v10) {
              goto LABEL_101;
            }
            return v7;
          }
          if (v11 >= v12)
          {
            uint64_t v23 = (v11 - v10) >> 3;
            unint64_t v24 = v23 + 1;
            if ((unint64_t)(v23 + 1) >> 61) {
              abort();
            }
            if ((v12 - v10) >> 2 > v24) {
              unint64_t v24 = (v12 - v10) >> 2;
            }
            if ((unint64_t)(v12 - v10) >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v25 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v25 = v24;
            }
            if (v25)
            {
              if (v25 >> 61) {
                sub_1CB833614();
              }
              uint64_t v26 = (char *)operator new(8 * v25);
            }
            else
            {
              uint64_t v26 = 0;
            }
            int v27 = (llvm **)&v26[8 * v23];
            *int v27 = v22;
            unsigned int v28 = (char *)(v27 + 1);
            while (v11 != v10)
            {
              unsigned int v29 = (llvm *)*((void *)v11 - 1);
              v11 -= 8;
              *--int v27 = v29;
            }
            unsigned int v12 = &v26[8 * v25];
            if (v10) {
              operator delete(v10);
            }
            char v10 = (char *)v27;
            uint64_t v11 = v28;
          }
          else
          {
            *(void *)uint64_t v11 = v22;
            v11 += 8;
          }
        }
      }
      uint64_t v9 = *(void *)(v9 + 8);
      if (!v9)
      {
        if (v10 != v11)
        {
          unsigned int v30 = (uint64_t *)(v11 - 8);
          do
          {
            sub_1CD488100((uint64_t)this + 248, v30)[1] = a2;
            uint64_t v31 = *v30;
            uint64_t v32 = operator new(0x40uLL);
            void v32[3] = 2;
            *uint64_t v32 = 0;
            v32[1] = 0;
            v32[4] = 0;
            v32[5] = v31;
            if (v31 != -8192 && v31 != -4096 && v31 != 0) {
              llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)(v32 + 3));
            }
            BOOL v34 = (void *)*((void *)this + 41);
            uint64_t v35 = *((void *)this + 42);
            *uint64_t v32 = (char *)this + 320;
            v32[1] = v34;
            v32[2] = &unk_1F2603480;
            *BOOL v34 = v32;
            *((void *)this + 4sub_1CD456CB4((void *)this + 1) = v32;
            *((void *)this + 42) = v35 + 1;
            v32[6] = this;
            v32[7] = v32;
            BOOL v8 = v30-- == (uint64_t *)v10;
          }
          while (!v8);
        }
        goto LABEL_64;
      }
    }
  }
  char v10 = 0;
LABEL_64:
  uint64_t v36 = *((void *)this + 20);
  uint64_t v37 = *((unsigned int *)this + 43);
  if (v36 != *((void *)this + 19))
  {
    unsigned int v41 = *((_DWORD *)this + 42);
    goto LABEL_75;
  }
  if (!v37)
  {
LABEL_72:
    unsigned int v41 = *((_DWORD *)this + 42);
    if (v37 < v41)
    {
      *((_DWORD *)this + 43) = v37 + 1;
      *(void *)(v36 + 8 * v37) = a2;
      goto LABEL_96;
    }
LABEL_75:
    if (3 * v41 <= 4 * ((int)v37 - *((_DWORD *)this + 44)))
    {
      if (v41 >= 0x40) {
        v41 *= 2;
      }
      else {
        unsigned int v41 = 128;
      }
    }
    else if (v41 - v37 >= v41 >> 3)
    {
      goto LABEL_77;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::GlobalsAAResult *)((char *)this + 152), v41);
    unsigned int v41 = *((_DWORD *)this + 42);
    uint64_t v36 = *((void *)this + 20);
LABEL_77:
    unsigned int v42 = v41 - 1;
    unsigned int v43 = (v41 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v44 = (llvm::GlobalVariable **)(v36 + 8 * v43);
    uint64_t v45 = *v44;
    if (*v44 == (llvm::GlobalVariable *)-1)
    {
      unsigned int v46 = 0;
LABEL_89:
      if (v46) {
        int v50 = v46;
      }
      else {
        int v50 = v44;
      }
      if (*v50 != a2)
      {
        if (*v50 == (llvm::GlobalVariable *)-2) {
          --*((_DWORD *)this + 44);
        }
        else {
          ++*((_DWORD *)this + 43);
        }
        *int v50 = a2;
      }
    }
    else
    {
      unsigned int v46 = 0;
      int v47 = 1;
      while (v45 != a2)
      {
        if (v46) {
          BOOL v48 = 0;
        }
        else {
          BOOL v48 = v45 == (llvm::GlobalVariable *)-2;
        }
        if (v48) {
          unsigned int v46 = v44;
        }
        unsigned int v49 = v43 + v47++;
        unsigned int v43 = v49 & v42;
        uint64_t v44 = (llvm::GlobalVariable **)(v36 + 8 * (v49 & v42));
        uint64_t v45 = *v44;
        if (*v44 == (llvm::GlobalVariable *)-1) {
          goto LABEL_89;
        }
      }
    }
    goto LABEL_96;
  }
  uint64_t v38 = 0;
  uint64_t v39 = 8 * v37;
  uint64_t v40 = (void *)*((void *)this + 20);
  while ((llvm::GlobalVariable *)*v40 != a2)
  {
    if (*v40 == -2) {
      uint64_t v38 = v40;
    }
    ++v40;
    v39 -= 8;
    if (!v39)
    {
      if (!v38) {
        goto LABEL_72;
      }
      *uint64_t v38 = a2;
      --*((_DWORD *)this + 44);
      break;
    }
  }
LABEL_96:
  int v51 = operator new(0x40uLL);
  v51[3] = 2;
  *int v51 = 0;
  v51[1] = 0;
  v51[4] = 0;
  v51[5] = a2;
  if (a2 != (llvm::GlobalVariable *)-8192 && a2 != (llvm::GlobalVariable *)-4096 && a2) {
    llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)(v51 + 3));
  }
  BOOL v52 = (void *)*((void *)this + 41);
  uint64_t v53 = *((void *)this + 42);
  *int v51 = (char *)this + 320;
  v51[1] = v52;
  v51[2] = &unk_1F2603480;
  void *v52 = v51;
  *((void *)this + 4sub_1CD456CB4((void *)this + 1) = v51;
  *((void *)this + 42) = v53 + 1;
  v51[6] = this;
  v51[7] = v51;
  uint64_t v7 = 1;
  if (v10) {
LABEL_101:
  }
    operator delete(v10);
  return v7;
}

void *sub_1CBFF3560(llvm::SmallPtrSetImplBase *this)
{
  uint64_t result = (void *)*((void *)this + 1);
  if (result == *(void **)this) {
    goto LABEL_2;
  }
  uint64_t v3 = *((unsigned int *)this + 4);
  if (v3 < 0x21 || 4 * (*((_DWORD *)this + 5) - *((_DWORD *)this + 6)) >= v3)
  {
    uint64_t result = memset(result, 255, 8 * v3);
LABEL_2:
    *((_DWORD *)this + 5) = 0;
    *((_DWORD *)this + 6) = 0;
    return result;
  }

  return llvm::SmallPtrSetImplBase::shrink_and_clear((void **)this);
}

void *llvm::GlobalsAAResult::CollectSCCMembership(llvm::GlobalsAAResult *this, llvm::CallGraph *a2)
{
  uint64_t v3 = *((void *)a2 + 10);
  LODWORD(v10[0]) = 0;
  v10[1] = 0;
  v10[2] = 0;
  int v11 = 0;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  uint64_t v16 = 0;
  sub_1CBFAF330((int *)v10, v3);
  sub_1CBFAF5D8(v10);
  uint64_t v4 = *((void *)&v13 + 1);
  uint64_t v5 = v14;
  if (*((void *)&v13 + 1) != (void)v14)
  {
    int v6 = 0;
    uint64_t v7 = (char *)this + 296;
    while (1)
    {
      uint64_t v9 = *(void *)(*(void *)v4 + 8);
      if (v9) {
        *((_DWORD *)sub_1CBFF6864((uint64_t)v7, &v9) + 2) = v6;
      }
      v4 += 8;
      if (v4 == v5)
      {
        ++v6;
        sub_1CBFAF5D8(v10);
        uint64_t v4 = *((void *)&v13 + 1);
        uint64_t v5 = v14;
        if (*((void *)&v13 + 1) == (void)v14) {
          break;
        }
      }
    }
  }
  return sub_1CD4750A4(v10);
}

uint64_t llvm::GlobalsAAResult::AnalyzeCallGraph(llvm::GlobalsAAResult *this, llvm::CallGraph *a2, llvm::Module *a3)
{
  uint64_t v5 = *((void *)a2 + 10);
  LODWORD(v96) = 0;
  uint64_t v97 = 0;
  uint64_t v98 = 0;
  int v99 = 0;
  *(_OWORD *)uint64_t v100 = 0u;
  long long v101 = 0u;
  long long v102 = 0u;
  *(_OWORD *)std::string __p = 0u;
  uint64_t v104 = 0;
  sub_1CBFAF330((int *)&v96, v5);
  sub_1CBFAF5D8(&v96);
  uint64_t v7 = (char *)*((void *)&v101 + 1);
  int v6 = (char *)v102;
  if (*((void *)&v101 + 1) != (void)v102)
  {
    BOOL v8 = (int32x2_t *)((char *)this + 272);
    uint64_t v91 = (char *)this + 320;
    uint64_t v9 = (void *)((char *)a2 + 16);
    int v93 = this;
    char v94 = (char *)a2 + 16;
    while (1)
    {
      int v95 = 0;
      char v10 = *(llvm::GlobalValue **)(*(void *)v7 + 8);
      int v95 = v10;
      if (!v10 || ((1 << (*((_DWORD *)v10 + 8) & 0xF)) & 0x7D5) == 0) {
        goto LABEL_8;
      }
      if (!llvm::GlobalValue::isInterposable(v10)) {
        break;
      }
      uint64_t v7 = (char *)*((void *)&v101 + 1);
      int v6 = (char *)v102;
LABEL_8:
      while (v7 != v6)
      {
        uint64_t v11 = *(void *)v7;
        v7 += 8;
        *(void *)int v106 = *(void *)(v11 + 8);
        sub_1CBFF1B00(v8, v106);
      }
LABEL_9:
      sub_1CBFAF5D8(&v96);
      uint64_t v7 = (char *)*((void *)&v101 + 1);
      int v6 = (char *)v102;
      if (*((void *)&v101 + 1) == (void)v102) {
        goto LABEL_179;
      }
    }
    long long v12 = sub_1CBFF65DC(v8, &v95) + 1;
    long long v13 = sub_1CBFF6554((uint64_t)this, (uint64_t)v95);
    *long long v13 = v91;
    long long v14 = (void *)*((void *)this + 41);
    v13[1] = v14;
    *long long v14 = v13;
    uint64_t v15 = *((void *)this + 42) + 1;
    *((void *)this + 4sub_1CD456CB4((void *)this + 1) = v13;
    *((void *)this + 42) = v15;
    v13[7] = v13;
    unsigned int v17 = (uint64_t *)*((void *)&v101 + 1);
    uint64_t v16 = (uint64_t *)v102;
    if ((((void)v102 - *((void *)&v101 + 1)) & 0x7FFFFFFF8) == 0) {
      goto LABEL_101;
    }
    uint64_t v18 = 0;
    uint64_t v19 = (((void)v102 - *((void *)&v101 + 1)) >> 3);
LABEL_13:
    uint64_t v20 = (uint64_t)v95;
    if (!v95) {
      goto LABEL_98;
    }
    int v21 = *((unsigned __int8 *)v95 + 16);
    if (v21 == 3)
    {
      if ((*((_DWORD *)v95 + 5) & 0x7FFFFFF) == 0) {
        goto LABEL_63;
      }
LABEL_20:
      uint64_t v22 = *((void *)v95 + 14);
      if (v22 && (*(unsigned char *)(v22 + 17) & 8) != 0) {
        goto LABEL_63;
      }
      uint64_t v23 = *(void *)(*((void *)&v101 + 1) + 8 * v18);
      uint64_t v24 = *(void *)(v23 + 16);
      uint64_t v25 = *(void *)(v23 + 24);
      if (v24 == v25) {
        goto LABEL_90;
      }
      while (2)
      {
        uint64_t v26 = *(void *)(v24 + 32);
        unint64_t v27 = *(void *)(v26 + 8);
        if (v27)
        {
          uint64_t v105 = *(void *)(v26 + 8);
          *(void *)int v106 = 0;
          if (!sub_1CBA0E618((uint64_t)v8, &v105, v106)
            || (uint64_t v28 = *(void *)v106, *(void *)v106 == *((void *)this + 34) + 16 * *((unsigned int *)this + 72)))
          {
            int v33 = (void *)*v9;
            if (!*v9) {
              goto LABEL_41;
            }
            BOOL v34 = v9;
            do
            {
              unint64_t v35 = v33[4];
              BOOL v36 = v35 >= v27;
              if (v35 >= v27) {
                uint64_t v37 = v33;
              }
              else {
                uint64_t v37 = v33 + 1;
              }
              if (v36) {
                BOOL v34 = v33;
              }
              int v33 = (void *)*v37;
            }
            while (*v37);
            if (v34 == v9 || v34[4] > v27) {
LABEL_41:
            }
              BOOL v34 = v9;
            uint64_t v38 = (void *)*((void *)&v101 + 1);
            if (*((void *)&v101 + 1) != (void)v102)
            {
              uint64_t v39 = v34[5];
              while (*v38 != v39)
              {
                if (++v38 == (void *)v102)
                {
                  uint64_t v38 = (void *)v102;
                  break;
                }
              }
            }
            BOOL v32 = v38 == (void *)v102;
          }
          else
          {
            uint64_t v29 = *v12 | *(void *)(*(void *)v106 + 8) & 3;
            *long long v12 = v29;
            uint64_t v30 = *(void *)(v28 + 8);
            if ((v30 & 4) != 0)
            {
              *long long v12 = v29 | 4;
              uint64_t v30 = *(void *)(v28 + 8);
            }
            unint64_t v31 = v30 & 0xFFFFFFFFFFFFFFF8;
            if ((v30 & 0xFFFFFFFFFFFFFFF8) == 0
              || ((uint64_t v40 = sub_1CBFF61C8((int *)(v30 & 0xFFFFFFFFFFFFFFF8)),
                   unsigned int v41 = v40,
                   unsigned int v43 = v42,
                   unint64_t v44 = v31 + 8,
                   (*(unsigned char *)v31 & 1) == 0)
                ? (unint64_t v44 = *(void *)(v31 + 8), v45 = *(unsigned int *)(v31 + 16))
                : (uint64_t v45 = 16),
                  unsigned int v46 = (int *)(v44 + 16 * v45),
                  v46 == v40))
            {
              BOOL v32 = 0;
            }
            else
            {
              do
              {
                sub_1CBFF2EE4(v12, *(void *)v41, *((unsigned char *)v41 + 8));
                while (1)
                {
                  v41 += 4;
                  if (v41 == v43) {
                    break;
                  }
                  if (*(void *)v41 != -4096 && *(void *)v41 != -8192) {
                    goto LABEL_60;
                  }
                }
                unsigned int v41 = v43;
LABEL_60:
                BOOL v32 = 0;
              }
              while (v41 != v46);
            }
          }
          v24 += 40;
          if (v24 != v25)
          {
            uint64_t v9 = v94;
            if (v32) {
              goto LABEL_91;
            }
            continue;
          }
          uint64_t v9 = v94;
LABEL_91:
          if (++v18 != v19 && !v32) {
            goto LABEL_13;
          }
          unsigned int v17 = (uint64_t *)*((void *)&v101 + 1);
          uint64_t v16 = (uint64_t *)v102;
          if (!v32)
          {
LABEL_101:
            if (v17 != v16)
            {
              uint64_t v92 = v12;
              while ((~*(_DWORD *)v12 & 3) != 0)
              {
                uint64_t v52 = *v17;
                uint64_t v53 = *(void *)(*v17 + 8);
                uint64_t v54 = *(void *)(v53 + 112);
                if (!v54 || (*(unsigned char *)(v54 + 17) & 8) == 0)
                {
                  uint64_t v55 = v53 + 72;
                  for (uint64_t i = *(void *)(v53 + 80); i != v55; uint64_t i = *(void *)(i + 8))
                  {
                    uint64_t v57 = i - 24;
                    if (!i) {
                      uint64_t v57 = 0;
                    }
                    uint64_t v58 = *(void *)(v57 + 48);
                    if (v58 != v57 + 40)
                    {
                      while (1)
                      {
                        if (v58) {
                          uint64_t v75 = v58 - 24;
                        }
                        else {
                          uint64_t v75 = 0;
                        }
                        if ((~*(_DWORD *)v12 & 3) == 0) {
                          goto LABEL_169;
                        }
                        uint64_t v76 = *(unsigned __int8 *)(v75 + 16) - 33;
                        if (v76 <= 0x37)
                        {
                          if (((1 << (*(unsigned char *)(v75 + 16) - 33)) & 0x8000000000041) != 0)
                          {
                            uint64_t v77 = *((void *)v93 + 5);
                            if (!v77)
                            {
                              sub_1CB920400();
                              return llvm::GlobalsAAResult::isNonEscapingGlobalNoAlias(v88, v89, v90);
                            }
                            char v78 = (uint64_t *)(*(uint64_t (**)(uint64_t, void))(*(void *)v77 + 48))(v77, *(void *)(v52 + 8));
                            if (byte_1EBD04470) {
                              int v79 = 59;
                            }
                            else {
                              int v79 = 63;
                            }
                            sub_1CC095244(v58 - 24, v79, v78, v106);
                            if (v107)
                            {
LABEL_159:
                              uint64_t v64 = 3;
                              goto LABEL_160;
                            }
                            uint64_t v59 = v52;
                            LOBYTE(v105) = 0;
                            uint64_t v60 = (uint64_t ***)sub_1CC0960E8(v58 - 24, &v105);
                            if (v60)
                            {
                              if (!(_BYTE)v105)
                              {
                                unsigned int v65 = (llvm::Function *)v60;
                                v106[0] = 0;
                                if (llvm::TargetLibraryInfoImpl::getLibFunc(*v78, v60, v106)
                                  && ((*(void *)(v78[1] + (((unint64_t)v106[0] >> 3) & 0x1FFFFFF8)) >> SLOBYTE(v106[0])) & 1) == 0
                                  && ((*(unsigned __int8 *)(*v78 + ((unint64_t)v106[0] >> 2)) >> (2 * (v106[0] & 3))) & 3) != 0
                                  && llvm::isLibFreeFunction(v65, v106[0])
                                  && *(unsigned char *)(v58 - 8) == 84)
                                {
                                  uint64_t v64 = 3;
                                  uint64_t v52 = v59;
                                  long long v12 = v92;
                                  goto LABEL_160;
                                }
                              }
                            }
                            uint64_t v61 = *(void *)(v58 - 56);
                            uint64_t v52 = v59;
                            long long v12 = v92;
                            if (v61
                              && !*(unsigned char *)(v61 + 16)
                              && *(void *)(v61 + 24) == *(void *)(v58 + 48)
                              && (*(unsigned char *)(v61 + 33) & 0x20) != 0
                              && !sub_1CBF63B28(v58 - 24))
                            {
                              goto LABEL_159;
                            }
                          }
                          else
                          {
                            if (((1 << (*(unsigned char *)(v75 + 16) - 33)) & 0x808001C8000010) == 0)
                            {
                              if (v76 != 28) {
                                goto LABEL_161;
                              }
                              if ((*(_WORD *)(v75 + 18) & 0x301) == 0) {
                                goto LABEL_133;
                              }
                            }
                            *v12 |= 1uLL;
                            if (((1 << v76) & 0x8000000000041) != 0)
                            {
                              uint64_t v62 = *(void *)(v75 + 64);
                              if (!v62 || (*(unsigned char *)(v62 + 17) & 0x30) == 0)
                              {
                                int v63 = *(_DWORD *)(v75 + 20);
                                if (v63 < 0)
                                {
                                  uint64_t v66 = v75 - 32 * (v63 & 0x7FFFFFF);
                                  uint64_t v69 = *(void *)(v66 - 8);
                                  uint64_t v67 = v66 - 8;
                                  uint64_t v68 = v69;
                                  if (v69)
                                  {
                                    uint64_t v70 = -v68;
                                    while (1)
                                    {
                                      unsigned int v71 = *(_DWORD *)(*(void *)(v67 + v70) + 8);
                                      BOOL v72 = v71 > 7;
                                      int v73 = (1 << v71) & 0x83;
                                      if (v72 || v73 == 0) {
                                        break;
                                      }
                                      v70 += 16;
                                      if (!v70) {
                                        goto LABEL_131;
                                      }
                                    }
LABEL_133:
                                    uint64_t v64 = 2;
LABEL_160:
                                    *v12 |= v64;
                                    goto LABEL_161;
                                  }
                                }
LABEL_131:
                                if ((llvm::CallBase::hasFnAttrOnCalledFunction(v75, 45) & 1) == 0
                                  && (llvm::CallBase::hasFnAttrOnCalledFunction(v75, 44) & 1) == 0)
                                {
                                  goto LABEL_133;
                                }
                              }
                            }
                            else if (((1 << v76) & 0x808001D0000010) != 0 {
                                   || v76 == 27 && (*(_WORD *)(v75 + 18) & 0x301) != 0)
                            }
                            {
                              goto LABEL_133;
                            }
                          }
                        }
LABEL_161:
                        uint64_t v58 = *(void *)(v58 + 8);
                        uint64_t v80 = i - 24;
                        if (!i) {
                          uint64_t v80 = 0;
                        }
                        if (v58 == v80 + 40)
                        {
                          do
                          {
                            uint64_t i = *(void *)(i + 8);
                            if (i == v55) {
                              goto LABEL_169;
                            }
                            uint64_t v81 = i - 24;
                            if (!i) {
                              uint64_t v81 = 0;
                            }
                            uint64_t v58 = *(void *)(v81 + 48);
                          }
                          while (v58 == v81 + 40);
                        }
                        if (i == v55) {
                          goto LABEL_169;
                        }
                      }
                    }
                  }
                }
LABEL_169:
                if (++v17 == v16) {
                  break;
                }
              }
            }
            uint64_t v82 = *v12;
            *(void *)int v106 = *v12 & 7;
            this = v93;
            uint64_t v9 = v94;
            if ((v82 & 0xFFFFFFFFFFFFFFF8) != 0) {
              operator new();
            }
            uint64_t v83 = ((void)v102 - *((void *)&v101 + 1)) >> 3;
            if (v83 != 1)
            {
              uint64_t v84 = 1;
              do
              {
                uint64_t v105 = *(void *)(*(void *)(*((void *)&v101 + 1) + 8 * v84) + 8);
                uint64_t v85 = sub_1CBFF65DC(v8, &v105);
                sub_1CD4876BC(v85 + 1, v106);
                ++v84;
              }
              while (v83 != v84);
            }
            goto LABEL_9;
          }
        }
        else
        {
          unsigned int v17 = (uint64_t *)*((void *)&v101 + 1);
          uint64_t v16 = (uint64_t *)v102;
        }
        break;
      }
LABEL_177:
      while (v17 != v16)
      {
        uint64_t v86 = *v17++;
        *(void *)int v106 = *(void *)(v86 + 8);
        sub_1CBFF1B00(v8, v106);
      }
      goto LABEL_9;
    }
    if (*((unsigned char *)v95 + 16)
      || *((llvm::GlobalValue **)v95 + 9) != (llvm::GlobalValue *)((char *)v95 + 72)
      || (*((unsigned char *)v95 + 34) & 0x80) != 0)
    {
      goto LABEL_20;
    }
LABEL_63:
    int v47 = (unsigned char *)*((void *)v95 + 14);
    if (v47)
    {
      if ((v47[17] & 0x10) != 0) {
        goto LABEL_90;
      }
      uint64_t v48 = *v12;
      if ((v47[17] & 0x20) != 0)
      {
        *long long v12 = v48 | 1;
        if ((v47[12] & 8) == 0)
        {
          if (v21 == 3)
          {
            if ((*(_DWORD *)(v20 + 20) & 0x7FFFFFF) == 0) {
              goto LABEL_88;
            }
            goto LABEL_97;
          }
          if (v21 || *(void *)(v20 + 72) != v20 + 72 || (*(unsigned char *)(v20 + 34) & 0x80) != 0) {
            goto LABEL_97;
          }
LABEL_88:
          if ((v47[16] & 8) == 0 || (v47[14] & 0x20) == 0)
          {
LABEL_97:
            BOOL v32 = 0;
            *long long v12 = v48 | 5;
            goto LABEL_91;
          }
        }
LABEL_90:
        BOOL v32 = 0;
        goto LABEL_91;
      }
      uint64_t v49 = v48 | 3;
      *long long v12 = v49;
      if ((v47[12] & 8) != 0)
      {
LABEL_70:
        if (v21 == 3)
        {
          int v50 = *(_DWORD *)(v20 + 20) & 0x7FFFFFF;
          if (v47) {
            BOOL v51 = v50 == 0;
          }
          else {
            BOOL v51 = 0;
          }
          if (!v51) {
            goto LABEL_98;
          }
        }
        else if (v21 || *(void *)(v20 + 72) != v20 + 72 || !v47 || (*(_DWORD *)(v20 + 32) & 0x800000) != 0)
        {
LABEL_98:
          unsigned int v17 = (uint64_t *)*((void *)&v101 + 1);
          uint64_t v16 = (uint64_t *)v102;
          goto LABEL_177;
        }
        if ((v47[16] & 8) != 0 && (v47[14] & 0x20) != 0) {
          goto LABEL_90;
        }
        goto LABEL_98;
      }
    }
    else
    {
      uint64_t v49 = *v12 | 3;
    }
    *long long v12 = v49 | 4;
    goto LABEL_70;
  }
LABEL_179:
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
    uint64_t v7 = (char *)*((void *)&v101 + 1);
  }
  if (v7)
  {
    *(void *)&long long v102 = v7;
    operator delete(v7);
  }
  if (v100[0])
  {
    v100[1] = v100[0];
    operator delete(v100[0]);
  }
  return MEMORY[0x1D25D9CD0](v97, 8);
}