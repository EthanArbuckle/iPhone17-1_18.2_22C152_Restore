llvm *llvm::detail::IEEEFloat::convertFromDecimalString@<X0>(uint64_t a1@<X0>, unsigned __int8 *a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, uint64_t a5@<X8>)
{
  char *v9;
  llvm *result;
  int v11;
  char *v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  int v15;
  const char *v16;
  int v17;
  unsigned __int8 *v18;
  unsigned __int8 *v19;
  int v20;
  int v21;
  unsigned __int8 *v22;
  int v23;
  BOOL v24;
  BOOL v25;
  BOOL v26;
  int v27;
  _DWORD *v28;
  int v29;
  void *v30;
  char *v31;
  int v32;
  char v33;
  unsigned int v34;
  char *v35;
  unsigned int v36;
  unsigned __int8 *v37[5];
  __int16 v38;
  char *v39;
  unsigned __int8 v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E4F143B8];
  v9 = (char *)&a2[a3];
  v37[0] = &a2[a3];
  result = sub_1CD03459C((llvm *)&v39, a2, &a2[a3], v37);
  v11 = v40;
  v12 = v39;
  if ((v40 & 1) == 0)
  {
    v13 = v37[0];
    if (v39 == v9) {
      goto LABEL_19;
    }
    v14 = (unsigned __int8 *)v39;
    while (1)
    {
      v15 = *v14;
      if (v15 == 46)
      {
        if (v13 != (unsigned __int8 *)v9)
        {
          v16 = "String contains multiple dots";
          goto LABEL_52;
        }
        v37[0] = v14;
        if (v14 + 1 == (unsigned __int8 *)v9)
        {
          v17 = 0;
          v18 = (unsigned __int8 *)v9;
          goto LABEL_46;
        }
        v15 = v14[1];
        v13 = v14++;
      }
      if (((char)v15 - 58) < 0xFFFFFFF6) {
        break;
      }
      if (++v14 == (unsigned __int8 *)v9) {
        goto LABEL_19;
      }
    }
    if (v14 == (unsigned __int8 *)v9)
    {
LABEL_19:
      v17 = 0;
      v18 = (unsigned __int8 *)v9;
    }
    else
    {
      if ((v15 | 0x20) != 0x65)
      {
        v16 = "Invalid character in significand";
        goto LABEL_52;
      }
      if (v14 == a2 || v13 != (unsigned __int8 *)v9 && v14 - a2 == 1)
      {
        v16 = "Significand has no digits";
        goto LABEL_52;
      }
      v31 = (char *)(v14 + 1);
      if (v14 + 1 == (unsigned __int8 *)v9
        || ((v32 = *v31, v32 == 45) || v32 == 43) && v14 + 2 == (unsigned __int8 *)v9)
      {
        v17 = 0;
      }
      else
      {
        if (v32 == 45 || (v33 = *v31, v32 == 43))
        {
          v31 = (char *)(v14 + 2);
          if (v14 + 2 != (unsigned __int8 *)v9)
          {
            v33 = *v31;
            goto LABEL_62;
          }
          v16 = "Exponent has no digits";
LABEL_52:
          v37[1] = (unsigned __int8 *)v16;
          v38 = 259;
          llvm::inconvertibleErrorCode(result);
          operator new();
        }
LABEL_62:
        v34 = v33 - 48;
        if (v34 > 9)
        {
LABEL_63:
          v16 = "Invalid character in exponent";
          goto LABEL_52;
        }
        v35 = v31 + 1;
        while (v35 != v9)
        {
          v36 = *v35 - 48;
          if (v36 > 9) {
            goto LABEL_63;
          }
          v34 = v36 + 10 * v34;
          ++v35;
          if (v34 >> 6 >= 0x177)
          {
            v34 = 24000;
            break;
          }
        }
        if (v32 == 45) {
          v17 = -v34;
        }
        else {
          v17 = v34;
        }
      }
      if (v13 == (unsigned __int8 *)v9)
      {
        v37[0] = v14;
        v18 = v14;
LABEL_46:
        v13 = v14;
      }
      else
      {
        v18 = v14;
      }
    }
    if (v18 == (unsigned __int8 *)v39)
    {
      v11 = 0;
    }
    else
    {
      if (v18 != a2)
      {
LABEL_22:
        v19 = v18 - 1;
        while (v19 != a2)
        {
          v21 = *v19--;
          v20 = v21;
          if (v21 != 48)
          {
            if (v20 == 46)
            {
              v18 = v19 + 1;
              goto LABEL_22;
            }
            v22 = v19 + 1;
            goto LABEL_30;
          }
        }
      }
      v22 = a2;
LABEL_30:
      v23 = v13 - v22;
      v24 = v13 > (unsigned __int8 *)v39;
      v25 = v13 >= v22;
      v26 = v13 > v22;
      if (v25) {
        v24 = 0;
      }
      v11 = v17 + v23 - v26 + v22 - v39 - v24;
    }
LABEL_33:
    if (v39 == v9 || (*v39 - 58) <= 0xFFFFFFF5)
    {
      v27 = 0;
      *(unsigned char *)(a1 + 20) = *(unsigned char *)(a1 + 20) & 0xF8 | 3;
LABEL_50:
      *(unsigned char *)(a5 + 8) &= ~1u;
      *(_DWORD *)a5 = v27;
      return result;
    }
    if (v11 < 51085)
    {
      v28 = *(_DWORD **)a1;
      if (v11 < -51082 || 28738 * v11 + 28738 <= 8651 * (v28[1] - v28[2]))
      {
        *(unsigned char *)(a1 + 20) = *(unsigned char *)(a1 + 20) & 0xF8 | 2;
        v29 = v28[2];
        if ((v29 - 64) >= 0xFFFFFF80)
        {
          *(void *)(a1 + 8) = 0;
        }
        else
        {
          v30 = *(void **)(a1 + 8);
          *v30 = 0;
          bzero(v30 + 1, 8 * (((v29 + 64) >> 6) - 2) + 8);
        }
        result = (llvm *)llvm::detail::IEEEFloat::normalize((llvm::detail::IEEEFloat *)a1, a4, 1);
        goto LABEL_49;
      }
      if (42039 * v11 - 42039 < 12655 * *v28) {
        operator new[]();
      }
    }
    result = (llvm *)llvm::detail::IEEEFloat::handleOverflow((_DWORD **)a1, a4);
LABEL_49:
    v27 = (int)result;
    goto LABEL_50;
  }
  if (!v39) {
    goto LABEL_33;
  }
  *(unsigned char *)(a5 + 8) |= 1u;
  *(void *)a5 = v12;
  return result;
}

uint64_t llvm::detail::IEEEFloat::convertFromStringSpecials(llvm::detail::IEEEFloat *a1, unsigned __int8 *a2, unint64_t a3)
{
  if (a3 < 3) {
    return 0;
  }
  uint64_t v28 = v3;
  uint64_t v29 = v4;
  if (a3 == 4)
  {
    if (*(_DWORD *)a2 == 1718503723)
    {
LABEL_42:
      int v11 = 0;
      goto LABEL_22;
    }
    goto LABEL_5;
  }
  if (a3 != 3)
  {
    if (a3 == 8 && *(void *)a2 == 0x5954494E49464E49) {
      goto LABEL_42;
    }
LABEL_5:
    int v5 = *a2;
    if (v5 != 45)
    {
      LODWORD(v6) = 0;
      unint64_t v7 = a3;
      goto LABEL_7;
    }
    unint64_t v7 = a3 - 1;
    ++a2;
    if (a3 == 4)
    {
      if (*(_WORD *)a2 == 28265 && a2[2] == 102) {
        goto LABEL_21;
      }
      if (*(_WORD *)a2 == 28233 && a2[2] == 102) {
        goto LABEL_21;
      }
    }
    else if (a3 == 9 && *(void *)a2 == 0x5954494E49464E49)
    {
LABEL_21:
      int v11 = 1;
LABEL_22:
      llvm::detail::IEEEFloat::makeInf(a1, v11);
      return 1;
    }
    int v5 = *a2;
    LODWORD(v6) = 1;
LABEL_7:
    if ((v5 | 0x20) == 0x73)
    {
      if (v7 < 4) {
        return 0;
      }
      ++a2;
      --v7;
    }
    if ((*(_WORD *)a2 != 24942 || a2[2] != 110) && (*(_WORD *)a2 != 24910 || a2[2] != 78)) {
      return 0;
    }
    int v23 = v6;
    unsigned int v15 = v5 & 0xFFFFFFDF;
    uint64_t v16 = 3;
    if (v7 < 3) {
      uint64_t v16 = v7;
    }
    v17 = &a2[v16];
    unint64_t v18 = v7 - v16;
    v26 = &a2[v16];
    unint64_t v27 = v7 - v16;
    if (v7 == v16)
    {
      llvm::detail::IEEEFloat::makeNaN(a1, v15 == 83, v23, 0);
      return 1;
    }
    int v19 = *v17;
    if (v19 != 40)
    {
LABEL_52:
      if (v19 == 48)
      {
        if (v18 >= 2 && __tolower((char)v17[1]) == 120)
        {
          v26 = v17 + 2;
          unint64_t v27 = v18 - 2;
          unsigned int v21 = 16;
        }
        else
        {
          unsigned int v21 = 8;
        }
      }
      else
      {
        unsigned int v21 = 10;
      }
      unsigned int v25 = 1;
      uint64_t v24 = 0;
      if ((llvm::StringRef::getAsInteger((llvm::StringRef *)&v26, v21, (llvm::APInt *)&v24) & 1) == 0)
      {
        llvm::detail::IEEEFloat::makeNaN(a1, v15 == 83, v23, (const llvm::APInt *)&v24);
        if (v25 >= 0x41 && v24) {
          MEMORY[0x1D25D9CB0](v24, 0x1000C8000313F17);
        }
        return 1;
      }
      if (v25 >= 0x41 && v24) {
        MEMORY[0x1D25D9CB0](v24, 0x1000C8000313F17);
      }
      return 0;
    }
    if (v18 >= 3)
    {
      unint64_t v20 = v18 - 1;
      if (v17[v18 - 1] == 41)
      {
        if (v18 < v20) {
          unint64_t v20 = v18;
        }
        unint64_t v18 = v20 - 1;
        v26 = v17 + 1;
        unint64_t v27 = v20 - 1;
        int v19 = *++v17;
        goto LABEL_52;
      }
    }
    return 0;
  }
  if (*(_WORD *)a2 == 28265 && a2[2] == 102) {
    goto LABEL_42;
  }
  uint64_t v6 = 0;
  int v5 = *a2;
  if (v5 != 45)
  {
    unint64_t v7 = 3;
    goto LABEL_7;
  }
  return v6;
}

void llvm::detail::IEEEFloat::makeInf(llvm::detail::IEEEFloat *this, int a2)
{
  v2 = *(_DWORD **)this;
  if (*(_DWORD *)(*(void *)this + 16) == 1)
  {
    llvm::detail::IEEEFloat::makeNaN(this, 0, a2, 0);
  }
  else
  {
    if (a2) {
      char v3 = 8;
    }
    else {
      char v3 = 0;
    }
    *((unsigned char *)this + 20) = *((unsigned char *)this + 20) & 0xF0 | v3;
    *((_DWORD *)this + 4) = *v2 + 1;
    int v4 = v2[2];
    if ((v4 - 64) < 0xFFFFFF80)
    {
      int v5 = (void *)*((void *)this + 1);
      *int v5 = 0;
      bzero(v5 + 1, 8 * (((v4 + 64) >> 6) - 2) + 8);
    }
    else
    {
      *((void *)this + 1) = 0;
    }
  }
}

llvm::detail::IEEEFloat *llvm::detail::IEEEFloat::convertFromString@<X0>(llvm::detail::IEEEFloat *result@<X0>, unsigned __int8 *a2@<X1>, unint64_t a3@<X2>, int a4@<W3>, llvm *a5@<X8>)
{
  if (!a3) {
    goto LABEL_17;
  }
  unint64_t v7 = a3;
  v8 = a2;
  v9 = result;
  result = (llvm::detail::IEEEFloat *)llvm::detail::IEEEFloat::convertFromStringSpecials(result, a2, a3);
  if (result)
  {
    *((unsigned char *)a5 + 8) &= ~1u;
    *(_DWORD *)a5 = 0;
    return result;
  }
  *((unsigned char *)v9 + 20) = *((unsigned char *)v9 + 20) & 0xF7 | (8 * (*v8 == 45));
  int v10 = *v8;
  if (v10 == 45 || v10 == 43)
  {
    if (--v7)
    {
      ++v8;
      goto LABEL_5;
    }
LABEL_17:
    llvm::inconvertibleErrorCode(result);
    operator new();
  }
LABEL_5:
  if (v7 >= 2 && *v8 == 48 && (v8[1] | 0x20) == 0x78)
  {
    if (v7 == 2) {
      sub_1CD0346C0(a5);
    }
    return llvm::detail::IEEEFloat::convertFromHexadecimalString(v9, v8 + 2, v7 - 2, a4, (uint64_t)a5);
  }
  else
  {
    return llvm::detail::IEEEFloat::convertFromDecimalString((uint64_t)v9, v8, v7, a4, (uint64_t)a5);
  }
}

uint64_t llvm::detail::IEEEFloat::convertToHexString(uint64_t a1, unsigned char *a2, unsigned int a3, int a4, int a5)
{
  int v6 = (int)a2;
  char v7 = *(unsigned char *)(a1 + 20);
  if ((v7 & 8) != 0)
  {
    *a2++ = 45;
    char v7 = *(unsigned char *)(a1 + 20);
  }
  switch(v7 & 7)
  {
    case 0:
      uint64_t v8 = 0x7974696E69666E69;
      if (a4) {
        uint64_t v8 = 0x5954494E49464E49;
      }
      *(void *)a2 = v8;
      a2 += 8;
      break;
    case 1:
      v13 = "nan";
      if (a4) {
        v13 = "NAN";
      }
      *(_WORD *)a2 = *(_WORD *)v13;
      a2[2] = v13[2];
      a2 += 3;
      break;
    case 2:
      a2 = llvm::detail::IEEEFloat::convertNormalToHexString((unint64_t **)a1, a2, a3, a4, a5);
      break;
    case 3:
      *a2 = 48;
      if (a4) {
        char v9 = 88;
      }
      else {
        char v9 = 120;
      }
      a2[1] = v9;
      a2[2] = 48;
      if (a3 < 2)
      {
        v12 = a2 + 3;
      }
      else
      {
        int v10 = a2 + 4;
        a2[3] = 46;
        size_t v11 = a3 - 1;
        memset(a2 + 4, 48, v11);
        v12 = &v10[v11];
      }
      if (a4) {
        char v14 = 80;
      }
      else {
        char v14 = 112;
      }
      char *v12 = v14;
      a2 = v12 + 2;
      v12[1] = 48;
      break;
    default:
      break;
  }
  *a2 = 0;
  return (a2 - v6);
}

unsigned char *llvm::detail::IEEEFloat::convertNormalToHexString(unint64_t **a1, unsigned char *a2, unsigned int a3, int a4, int a5)
{
  int v5 = a4;
  unsigned int v6 = a3;
  uint64_t v8 = a1;
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  *a2 = 48;
  if (a4) {
    char v9 = 88;
  }
  else {
    char v9 = 120;
  }
  a2[1] = v9;
  if (a4) {
    int v10 = "0123456789ABCDEF0";
  }
  else {
    int v10 = "0123456789abcdef0";
  }
  size_t v11 = a1 + 1;
  unsigned int v12 = *((_DWORD *)*a1 + 2);
  if (v12 - 64 > 0xFFFFFF7F)
  {
    unsigned int v14 = (v12 + 64) >> 6;
    unsigned int v15 = v12 + 3;
    char v16 = (v12 + 3) & 0x3F;
    char v17 = 64 - v16;
    if (v12 > 0xFFFFFFBF)
    {
      int v21 = 1;
      v13 = (unint64_t *)(a1 + 1);
      goto LABEL_16;
    }
    v13 = (unint64_t *)(a1 + 1);
  }
  else
  {
    v13 = *v11;
    unsigned int v14 = (v12 + 64) >> 6;
    unsigned int v15 = v12 + 3;
    char v16 = (v12 + 3) & 0x3F;
    char v17 = 64 - v16;
  }
  int v18 = 0;
  uint64_t v19 = 0;
  while (1)
  {
    unint64_t v20 = v13[v19];
    if (v20) {
      break;
    }
    ++v19;
    v18 += 64;
    if (v14 == v19)
    {
      int v21 = 1;
      goto LABEL_16;
    }
  }
  int v21 = -v18 - __clz(__rbit64(v20));
LABEL_16:
  unsigned int v22 = (v12 + v21 + 6) >> 2;
  if (!a3)
  {
    LODWORD(v26) = 0;
    unsigned int v6 = v22;
    goto LABEL_27;
  }
  if (v22 <= a3)
  {
    LODWORD(v26) = 0;
    goto LABEL_27;
  }
  char v50 = v16;
  char v51 = v17;
  unsigned int v23 = v15 - 4 * a3;
  unsigned int v25 = sub_1CD0331C0(v13, v14, v23);
  if (a5 == 1)
  {
    if (v25 == 2)
    {
      char v16 = v50;
      char v17 = v51;
      if ((*((unsigned char *)a1 + 20) & 7) != 3)
      {
        if (v12 - 64 <= 0xFFFFFF7F) {
          size_t v11 = (unint64_t **)*v11;
        }
        uint64_t v26 = ((unint64_t)v11[v23 >> 6] >> v23) & 1;
        goto LABEL_24;
      }
    }
    else
    {
      char v16 = v50;
      char v17 = v51;
      if (v25 == 3)
      {
        LODWORD(v26) = 1;
        goto LABEL_24;
      }
    }
    LODWORD(v26) = 0;
LABEL_24:
    uint64_t v8 = a1;
    int v5 = a4;
    goto LABEL_27;
  }
  char v16 = v50;
  char v17 = v51;
  LODWORD(v26) = 0;
  uint64_t v8 = a1;
  int v5 = a4;
  switch((int)a1)
  {
    case 1:
      __break(1u);
      goto LABEL_72;
    case 2:
      LODWORD(v26) = (*((unsigned char *)a1 + 20) & 8) == 0;
      break;
    case 3:
      LODWORD(v26) = (*((unsigned __int8 *)a1 + 20) >> 3) & 1;
      break;
    case 4:
LABEL_72:
      LODWORD(v26) = v25 > 1;
      break;
    default:
      break;
  }
LABEL_27:
  uint64_t v27 = 3;
  if (v12 + 66 >= 0x40 && v6)
  {
    unsigned int v28 = (v12 + 66) >> 6;
    char v29 = v17;
    uint64_t v27 = 3;
    char v30 = v16;
    while (1)
    {
      unsigned int v31 = v28 - 1;
      if (v28 - 1 == v14) {
        break;
      }
      unint64_t v32 = v13[v31] << v29;
      if (v28 != 1) {
        goto LABEL_34;
      }
LABEL_35:
      if (v6 >= 0x10) {
        unsigned int v33 = 16;
      }
      else {
        unsigned int v33 = v6;
      }
      unint64_t v34 = v32 >> (-4 * v33);
      v35 = &a2[v27 - 1 + v33];
      unsigned int v36 = v33;
      do
      {
        *v35-- = v10[v34 & 0xF];
        v34 >>= 4;
        --v36;
      }
      while (v36);
      v27 += v33;
      v6 -= v33;
      if (v31)
      {
        unsigned int v28 = v31;
        if (v6) {
          continue;
        }
      }
      v37 = &a2[v27];
      if (!v26) {
        goto LABEL_43;
      }
LABEL_45:
      v38 = v37 - 1;
      do
      {
        int v39 = v10[word_1CFAC4A4C[*v38] + 1];
        *v38-- = v39;
      }
      while (v39 == 48);
      goto LABEL_47;
    }
    unint64_t v32 = 0;
    if (v28 == 1) {
      goto LABEL_35;
    }
LABEL_34:
    v32 |= v13[v28 - 2] >> v30;
    goto LABEL_35;
  }
  v37 = a2 + 3;
  if (v26) {
    goto LABEL_45;
  }
LABEL_43:
  memset(v37, 48, v6);
  v27 += v6;
LABEL_47:
  v40 = &a2[v27];
  a2[2] = a2[3];
  if (v27 == 4) {
    --v40;
  }
  else {
    a2[3] = 46;
  }
  if (v5) {
    char v41 = 80;
  }
  else {
    char v41 = 112;
  }
  char *v40 = v41;
  result = v40 + 1;
  unsigned int v43 = *((_DWORD *)v8 + 4);
  if ((v43 & 0x80000000) != 0)
  {
    uint64_t v47 = 0;
    unsigned char *result = 45;
    unsigned int v48 = -v43;
    do
    {
      v54[v47++] = (v48 % 0xA) | 0x30;
      BOOL v45 = v48 > 9;
      v48 /= 0xAu;
    }
    while (v45);
    result = v40 + 2;
    uint64_t v49 = v47 - 1;
    do
      *result++ = v54[v49--];
    while (v49 != -1);
  }
  else
  {
    uint64_t v44 = 0;
    do
    {
      v54[v44++] = (v43 % 0xA) | 0x30;
      BOOL v45 = v43 > 9;
      v43 /= 0xAu;
    }
    while (v45);
    uint64_t v46 = v44 - 1;
    do
      *result++ = v54[v46--];
    while (v46 != -1);
  }
  return result;
}

unint64_t llvm::detail::hash_value(llvm::detail *this, const llvm::detail::IEEEFloat *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  unsigned int v2 = *((unsigned __int8 *)this + 20);
  int v3 = v2 & 6;
  int v4 = v2 & 7;
  int v5 = (v2 >> 3) & 1;
  if (v3) {
    BOOL v6 = v4 == 3;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6)
  {
    if (v4 == 1) {
      char v14 = 0;
    }
    else {
      char v14 = v5;
    }
    uint64_t v15 = *(void *)this;
    uint64_t v28 = 0;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v21 = 0u;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EBCBE588))
    {
      unint64_t v18 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v18 = 0xFF51AFD7ED558CCDLL;
      }
      qword_1EBCBE580 = v18;
      __cxa_guard_release(&qword_1EBCBE588);
    }
    uint64_t v29 = qword_1EBCBE580;
    LOBYTE(v21) = v4;
    BYTE1(v21) = v14;
    *(_DWORD *)((char *)&v21 + 2) = *(_DWORD *)(v15 + 8);
    return sub_1CBAE06B8(&v21, 6uLL, qword_1EBCBE580);
  }
  else
  {
    char v20 = v5;
    char v7 = (int *)(*(void *)this + 8);
    int v10 = (void *)*((void *)this + 1);
    uint64_t v8 = (void *)((char *)this + 8);
    char v9 = v10;
    size_t v11 = (int *)(v8 + 1);
    if ((*v7 - 64) < 0xFFFFFF80) {
      uint64_t v8 = v9;
    }
    unint64_t v19 = sub_1CC36B4D0(v8, (uint64_t)&v8[(*v7 + 64) >> 6]);
    uint64_t v28 = 0;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v21 = 0u;
    unsigned int v12 = &unk_1EBCBE000;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
    {
      int v16 = __cxa_guard_acquire(&qword_1EBCBE588);
      unsigned int v12 = &unk_1EBCBE000;
      if (v16)
      {
        unint64_t v17 = llvm::hashing::detail::fixed_seed_override;
        if (!llvm::hashing::detail::fixed_seed_override) {
          unint64_t v17 = 0xFF51AFD7ED558CCDLL;
        }
        qword_1EBCBE580 = v17;
        __cxa_guard_release(&qword_1EBCBE588);
        unsigned int v12 = (void *)&unk_1EBCBE000;
      }
    }
    uint64_t v29 = v12[176];
    LOBYTE(v21) = v4;
    return sub_1CD03A98C((char *)&v21, 0, (unsigned char *)&v21 + 1, (char *)&v25, &v20, v7, v11, (uint64_t *)&v19);
  }
}

uint64_t llvm::detail::IEEEFloat::convertDoubleAPFloatToAPInt@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(unsigned __int8 *)(this + 20);
  int v3 = v2 & 7;
  if ((v2 & 6) == 0 || v3 == 3)
  {
    if (v3 == 3)
    {
      LOWORD(v5) = 0;
      unint64_t v7 = 0;
    }
    else
    {
      if ((v2 & 7) != 0)
      {
        uint64_t v8 = *(void *)this;
        this += 8;
        if ((*(_DWORD *)(v8 + 8) - 64) <= 0xFFFFFF7F) {
          this = *(void *)this;
        }
        unint64_t v7 = *(void *)this;
      }
      else
      {
        unint64_t v7 = 0;
      }
      LOWORD(v5) = 2047;
    }
  }
  else
  {
    LODWORD(v5) = *(_DWORD *)(this + 16) + 1023;
    BOOL v6 = (unint64_t *)(this + 8);
    if ((*(_DWORD *)(*(void *)this + 8) - 64) <= 0xFFFFFF7F) {
      BOOL v6 = (unint64_t *)*v6;
    }
    unint64_t v7 = *v6;
    if (*(_DWORD *)(this + 16) == -1022) {
      uint64_t v5 = (v7 >> 52) & 1;
    }
  }
  *(_DWORD *)(a2 + 8) = 64;
  *(void *)a2 = (v2 << 60) & 0x8000000000000000 | ((unint64_t)(v5 & 0x7FF) << 52) | v7 & 0xFFFFFFFFFFFFFLL;
  return this;
}

uint64_t llvm::detail::IEEEFloat::convertFloatAPFloatToAPInt@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  int v2 = *(unsigned __int8 *)(this + 20);
  int v3 = v2 & 7;
  if ((v2 & 6) == 0 || v3 == 3)
  {
    if (v3 == 3)
    {
      LOBYTE(v5) = 0;
      int v3 = 0;
    }
    else
    {
      if ((v2 & 7) != 0)
      {
        uint64_t v7 = *(void *)this;
        this += 8;
        if ((*(_DWORD *)(v7 + 8) - 64) <= 0xFFFFFF7F) {
          this = *(void *)this;
        }
        int v3 = *(_DWORD *)this;
      }
      LOBYTE(v5) = -1;
    }
  }
  else
  {
    int v5 = *(_DWORD *)(this + 16) + 127;
    BOOL v6 = (void *)(this + 8);
    if ((*(_DWORD *)(*(void *)this + 8) - 64) <= 0xFFFFFF7F) {
      BOOL v6 = (void *)*v6;
    }
    int v3 = *(_DWORD *)v6;
    if (*(_DWORD *)(this + 16) == -126) {
      LOBYTE(v5) = (v3 & 0x800000) != 0;
    }
  }
  *(_DWORD *)(a2 + 8) = 32;
  *(void *)a2 = (v2 << 28) & 0x80000000 | (v5 << 23) | v3 & 0x7FFFFF;
  return this;
}

uint64_t llvm::detail::IEEEFloat::convertHalfAPFloatToAPInt@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  unsigned int v2 = *(unsigned __int8 *)(this + 20);
  int v3 = v2 & 7;
  if ((v2 & 6) == 0 || v3 == 3)
  {
    if (v3 == 3)
    {
      LOBYTE(v5) = 0;
      LOWORD(v3) = 0;
    }
    else
    {
      if ((v2 & 7) != 0)
      {
        uint64_t v7 = *(void *)this;
        this += 8;
        if ((*(_DWORD *)(v7 + 8) - 64) <= 0xFFFFFF7F) {
          this = *(void *)this;
        }
        int v3 = *(_DWORD *)this;
      }
      LOBYTE(v5) = 31;
    }
  }
  else
  {
    int v5 = *(_DWORD *)(this + 16) + 15;
    BOOL v6 = (void *)(this + 8);
    if ((*(_DWORD *)(*(void *)this + 8) - 64) <= 0xFFFFFF7F) {
      BOOL v6 = (void *)*v6;
    }
    int v3 = *(_DWORD *)v6;
    if (*(_DWORD *)(this + 16) == -14) {
      LOBYTE(v5) = (v3 & 0x400) != 0;
    }
  }
  *(_DWORD *)(a2 + 8) = 16;
  *(void *)a2 = (((v2 >> 3) & 1) << 15) | ((v5 & 0x1F) << 10) | v3 & 0x3FF;
  return this;
}

uint64_t llvm::detail::IEEEFloat::bitcastToAPInt@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  unsigned int v2 = *(void **)this;
  if (*(_UNKNOWN **)this == &unk_1CFB2E2E0)
  {
    unsigned int v7 = *(unsigned __int8 *)(this + 20);
    int v8 = v7 & 7;
    if ((v7 & 6) == 0 || v8 == 3)
    {
      if (v8 == 3)
      {
        LOBYTE(v10) = 0;
        LOWORD(v8) = 0;
      }
      else
      {
        if ((v7 & 7) != 0) {
          int v8 = *(_DWORD *)(this + 8);
        }
        LOBYTE(v10) = 31;
      }
    }
    else
    {
      int v10 = *(_DWORD *)(this + 16) + 15;
      int v8 = *(_DWORD *)(this + 8);
      if (*(_DWORD *)(this + 16) == -14) {
        LOBYTE(v10) = (*(_DWORD *)(this + 8) & 0x400) != 0;
      }
    }
    unint64_t v14 = (((v7 >> 3) & 1) << 15) | ((v10 & 0x1F) << 10) | v8 & 0x3FF;
    int v15 = 16;
    goto LABEL_27;
  }
  if (v2 == &unk_1CFB2E2F4) {
    return llvm::detail::IEEEFloat::convertBFloatAPFloatToAPInt(this, a2);
  }
  if (v2 == &unk_1CFB2E308)
  {
    int v11 = *(unsigned __int8 *)(this + 20);
    int v12 = v11 & 7;
    if ((v11 & 6) == 0 || v12 == 3)
    {
      if (v12 == 3)
      {
        LOBYTE(v13) = 0;
        int v12 = 0;
      }
      else
      {
        if ((v11 & 7) != 0) {
          int v12 = *(_DWORD *)(this + 8);
        }
        LOBYTE(v13) = -1;
      }
    }
    else
    {
      int v13 = *(_DWORD *)(this + 16) + 127;
      int v12 = *(_DWORD *)(this + 8);
      if (*(_DWORD *)(this + 16) == -126) {
        LOBYTE(v13) = (v12 & 0x800000) != 0;
      }
    }
    unint64_t v14 = (v11 << 28) & 0x80000000 | (v13 << 23) | v12 & 0x7FFFFF;
    int v15 = 32;
    goto LABEL_27;
  }
  if (v2 == &unk_1CFB2E31C)
  {
    uint64_t v3 = *(unsigned __int8 *)(this + 20);
    int v4 = v3 & 7;
    if ((v3 & 6) == 0 || v4 == 3)
    {
      if (v4 == 3)
      {
        LOWORD(v5) = 0;
        unint64_t v6 = 0;
      }
      else
      {
        if ((v3 & 7) != 0) {
          unint64_t v6 = *(void *)(this + 8);
        }
        else {
          unint64_t v6 = 0;
        }
        LOWORD(v5) = 2047;
      }
    }
    else
    {
      LODWORD(v5) = *(_DWORD *)(this + 16) + 1023;
      unint64_t v6 = *(void *)(this + 8);
      if (*(_DWORD *)(this + 16) == -1022) {
        uint64_t v5 = (v6 >> 52) & 1;
      }
    }
    unint64_t v14 = (v3 << 60) & 0x8000000000000000 | ((unint64_t)(v5 & 0x7FF) << 52) | v6 & 0xFFFFFFFFFFFFFLL;
    int v15 = 64;
LABEL_27:
    *(_DWORD *)(a2 + 8) = v15;
    *(void *)a2 = v14;
    return this;
  }
  if (v2 == &unk_1CFB2E330) {
    return llvm::detail::IEEEFloat::convertQuadrupleAPFloatToAPInt((llvm::detail::IEEEFloat *)this, a2);
  }
  if (v2 == &unk_1CFB2E3B0) {
    return llvm::detail::IEEEFloat::convertPPCDoubleDoubleAPFloatToAPInt((llvm::detail::IEEEFloat *)this, a2);
  }
  if (v2 == &unk_1CFB2E358) {
    return llvm::detail::IEEEFloat::convertFloat8E5M2APFloatToAPInt(this, a2);
  }
  if (v2 == &unk_1CFB2E36C) {
    return llvm::detail::IEEEFloat::convertFloat8E4M3FNAPFloatToAPInt(this, a2);
  }
  return llvm::detail::IEEEFloat::convertF80LongDoubleAPFloatToAPInt((llvm::detail::IEEEFloat *)this, a2);
}

float llvm::detail::IEEEFloat::convertToFloat(llvm::detail::IEEEFloat *this)
{
  llvm::detail::IEEEFloat::bitcastToAPInt((uint64_t)this, (uint64_t)&v6);
  if (v7 >= 0x41) {
    v1 = v6;
  }
  else {
    v1 = (uint64_t *)&v6;
  }
  uint64_t v2 = *v1;
  if (v7 >= 0x41 && v6 != 0)
  {
    int v5 = v2;
    MEMORY[0x1D25D9CB0]();
    LODWORD(v2) = v5;
  }
  return *(float *)&v2;
}

double llvm::detail::IEEEFloat::convertToDouble(llvm::detail::IEEEFloat *this)
{
  llvm::detail::IEEEFloat::bitcastToAPInt((uint64_t)this, (uint64_t)&v5);
  if (v6 >= 0x41) {
    v1 = v5;
  }
  else {
    v1 = (double *)&v5;
  }
  double result = *v1;
  if (v6 >= 0x41 && v5 != 0)
  {
    double v4 = *v1;
    MEMORY[0x1D25D9CB0]();
    return v4;
  }
  return result;
}

uint64_t llvm::detail::IEEEFloat::initFromPPCDoubleDoubleAPInt(llvm::detail::IEEEFloat *this, const llvm::APInt **a2)
{
  if (*((_DWORD *)a2 + 2) >= 0x41u) {
    uint64_t v3 = *a2;
  }
  else {
    uint64_t v3 = (const llvm::APInt *)a2;
  }
  double v4 = *(const llvm::APInt **)v3;
  int v5 = (const llvm::APInt *)*((void *)v3 + 1);
  LODWORD(v11) = 64;
  int v10 = v4;
  llvm::detail::IEEEFloat::initFromDoubleAPInt(this, &v10);
  uint64_t result = llvm::detail::IEEEFloat::convert((uint64_t *)this, (uint64_t)&unk_1CFB2E3B0, 1, &v12);
  if ((*((unsigned char *)this + 20) & 6) != 0 && (*((unsigned char *)this + 20) & 7) != 3)
  {
    int v9 = 64;
    int v8 = v5;
    llvm::detail::IEEEFloat::initFromDoubleAPInt((llvm::detail::IEEEFloat *)&v10, &v8);
    llvm::detail::IEEEFloat::convert((uint64_t *)&v10, (uint64_t)&unk_1CFB2E3B0, 1, &v12);
    uint64_t result = llvm::detail::IEEEFloat::addOrSubtract(this, (const llvm::detail::IEEEFloat *)&v10, 1, 0);
    if ((*((_DWORD *)v10 + 2) - 64) <= 0xFFFFFF7F)
    {
      uint64_t result = v11;
      if (v11) {
        return MEMORY[0x1D25D9CB0](v11, 0x1000C8000313F17);
      }
    }
  }
  return result;
}

void llvm::detail::IEEEFloat::initFromDoubleAPInt(llvm::detail::IEEEFloat *this, const llvm::APInt **a2)
{
  if (*((_DWORD *)a2 + 2) >= 0x41u) {
    uint64_t v2 = *a2;
  }
  else {
    uint64_t v2 = (const llvm::APInt *)a2;
  }
  unint64_t v3 = *(void *)v2;
  uint64_t v4 = (*(void *)v2 >> 52) & 0x7FFLL;
  uint64_t v5 = *(void *)v2 & 0xFFFFFFFFFFFFFLL;
  *(void *)this = &unk_1CFB2E31C;
  char v6 = *((unsigned char *)this + 20);
  unint64_t v7 = v3 >> 60;
  *((unsigned char *)this + 20) = v6 & 0xF7 | v7 & 8;
  if (v4 | v5)
  {
    if (!v5 && v4 == 2047)
    {
      llvm::detail::IEEEFloat::makeInf(this, v7 > 7);
      return;
    }
    char v9 = v6 & 0xF0 | v7 & 8;
    if (v5 && v4 == 2047)
    {
      *((unsigned char *)this + 20) = v9 | 1;
      *((_DWORD *)this + 4) = 1024;
LABEL_17:
      *((void *)this + 1) = v5;
      return;
    }
    *((unsigned char *)this + 20) = v9 | 2;
    *((_DWORD *)this + 4) = v4 - 1023;
    *((void *)this + 1) = v5;
    if (v4)
    {
      v5 |= 0x10000000000000uLL;
      goto LABEL_17;
    }
    *((_DWORD *)this + 4) = -1022;
  }
  else
  {
    if (v7 <= 7) {
      char v8 = 3;
    }
    else {
      char v8 = 11;
    }
    *((unsigned char *)this + 20) = v8 | v6 & 0xF0;
    *((_DWORD *)this + 4) = -1023;
    *((void *)this + 1) = 0;
  }
}

llvm::detail::IEEEFloat *llvm::detail::IEEEFloat::IEEEFloat(llvm::detail::IEEEFloat *a1, void *a2, const llvm::APInt **a3)
{
  return a1;
}

{
  llvm::detail::IEEEFloat::initFromAPInt(a1, a2, a3);
  return a1;
}

void llvm::detail::IEEEFloat::initFromFloatAPInt(llvm::detail::IEEEFloat *this, const llvm::APInt **a2)
{
  if (*((_DWORD *)a2 + 2) >= 0x41u) {
    uint64_t v2 = *a2;
  }
  else {
    uint64_t v2 = (const llvm::APInt *)a2;
  }
  uint64_t v3 = *(void *)v2;
  int v4 = (v3 >> 23);
  int v5 = v3 & 0x7FFFFF;
  *(void *)this = &unk_1CFB2E308;
  char v6 = *((unsigned char *)this + 20);
  *((unsigned char *)this + 20) = v6 & 0xF7 | (8 * ((int)v3 < 0));
  if (v4 | v3 & 0x7FFFFF)
  {
    if (!v5 && v4 == 255)
    {
      llvm::detail::IEEEFloat::makeInf(this, v3 >> 31);
      return;
    }
    char v8 = v6 & 0xF0 | (8 * ((int)v3 < 0));
    if (v5 && v4 == 255)
    {
      *((unsigned char *)this + 20) = v8 | 1;
      *((_DWORD *)this + 4) = 128;
      uint64_t v9 = v3 & 0x7FFFFF;
LABEL_17:
      *((void *)this + 1) = v9;
      return;
    }
    *((unsigned char *)this + 20) = v8 | 2;
    *((_DWORD *)this + 4) = v4 - 127;
    uint64_t v10 = v3 & 0x7FFFFF;
    *((void *)this + 1) = v10;
    if (v4)
    {
      uint64_t v9 = v10 | 0x800000;
      goto LABEL_17;
    }
    *((_DWORD *)this + 4) = -126;
  }
  else
  {
    if ((int)v3 >= 0) {
      char v7 = 3;
    }
    else {
      char v7 = 11;
    }
    *((unsigned char *)this + 20) = v7 | v6 & 0xF0;
    *((_DWORD *)this + 4) = -127;
    *((void *)this + 1) = 0;
  }
}

void llvm::detail::IEEEFloat::initFromBFloatAPInt(llvm::detail::IEEEFloat *this, const llvm::APInt **a2)
{
  if (*((_DWORD *)a2 + 2) >= 0x41u) {
    uint64_t v2 = *a2;
  }
  else {
    uint64_t v2 = (const llvm::APInt *)a2;
  }
  uint64_t v3 = *(void *)v2;
  int v4 = (v3 >> 7);
  *(void *)this = &unk_1CFB2E2F4;
  char v5 = *((unsigned char *)this + 20);
  unsigned int v6 = (v3 >> 12) & 8;
  *((unsigned char *)this + 20) = v5 & 0xF7 | (v3 >> 12) & 8;
  if (!(v4 | v3 & 0x7F))
  {
    *((unsigned char *)this + 20) = v6 | v5 & 0xF0 | 3;
    *((_DWORD *)this + 4) = -127;
    *((void *)this + 1) = 0;
    return;
  }
  if ((v3 & 0x7F) == 0 && v4 == 255)
  {
    llvm::detail::IEEEFloat::makeInf(this, v6 != 0);
    return;
  }
  char v7 = v5 & 0xF0 | (v3 >> 12) & 8;
  if ((v3 & 0x7F) != 0 && v4 == 255)
  {
    *((unsigned char *)this + 20) = v7 | 1;
    *((_DWORD *)this + 4) = 128;
    uint64_t v8 = v3 & 0x7F;
LABEL_14:
    *((void *)this + 1) = v8;
    return;
  }
  *((unsigned char *)this + 20) = v7 | 2;
  *((_DWORD *)this + 4) = v4 - 127;
  uint64_t v9 = v3 & 0x7F;
  *((void *)this + 1) = v9;
  if (v4)
  {
    uint64_t v8 = v9 | 0x80;
    goto LABEL_14;
  }
  *((_DWORD *)this + 4) = -126;
}

void llvm::detail::IEEEFloat::initFromHalfAPInt(llvm::detail::IEEEFloat *this, const llvm::APInt **a2)
{
  if (*((_DWORD *)a2 + 2) >= 0x41u) {
    uint64_t v2 = *a2;
  }
  else {
    uint64_t v2 = (const llvm::APInt *)a2;
  }
  uint64_t v3 = *(void *)v2;
  unsigned int v4 = (v3 >> 10) & 0x1F;
  *(void *)this = &unk_1CFB2E2E0;
  char v5 = *((unsigned char *)this + 20);
  unsigned int v6 = (v3 >> 12) & 8;
  *((unsigned char *)this + 20) = v5 & 0xF7 | (v3 >> 12) & 8;
  if (!(v4 | v3 & 0x3FF))
  {
    *((unsigned char *)this + 20) = v6 | v5 & 0xF0 | 3;
    *((_DWORD *)this + 4) = -15;
    *((void *)this + 1) = 0;
    return;
  }
  if ((v3 & 0x3FF) == 0 && v4 == 31)
  {
    llvm::detail::IEEEFloat::makeInf(this, v6 != 0);
    return;
  }
  char v8 = v5 & 0xF0 | (v3 >> 12) & 8;
  if ((v3 & 0x3FF) != 0 && v4 == 31)
  {
    *((unsigned char *)this + 20) = v8 | 1;
    *((_DWORD *)this + 4) = 16;
    uint64_t v11 = v3 & 0x3FF;
    goto LABEL_18;
  }
  *((unsigned char *)this + 20) = v8 | 2;
  *((_DWORD *)this + 4) = v4 - 15;
  uint64_t v10 = v3 & 0x3FF;
  *((void *)this + 1) = v10;
  if (v4)
  {
    uint64_t v11 = v10 | 0x400;
LABEL_18:
    *((void *)this + 1) = v11;
    return;
  }
  *((_DWORD *)this + 4) = -14;
}

void llvm::detail::IEEEFloat::initFromFloat8E5M2APInt(llvm::detail::IEEEFloat *this, const llvm::APInt **a2)
{
  if (*((_DWORD *)a2 + 2) >= 0x41u) {
    uint64_t v2 = *a2;
  }
  else {
    uint64_t v2 = (const llvm::APInt *)a2;
  }
  uint64_t v3 = *(void *)v2;
  unsigned int v4 = (v3 >> 2) & 0x1F;
  *(void *)this = &unk_1CFB2E358;
  char v5 = *((unsigned char *)this + 20);
  *((unsigned char *)this + 20) = v5 & 0xF7 | (v3 >> 4) & 8;
  if (v4 | v3 & 3)
  {
    if ((v3 & 3) == 0 && v4 == 31)
    {
      llvm::detail::IEEEFloat::makeInf(this, ((char)v3 >> 7) & 1);
      return;
    }
    char v7 = v5 & 0xF0 | (v3 >> 4) & 8;
    if ((v3 & 3) != 0 && v4 == 31)
    {
      *((unsigned char *)this + 20) = v7 | 1;
      *((_DWORD *)this + 4) = 16;
      uint64_t v10 = v3 & 3;
      goto LABEL_21;
    }
    *((unsigned char *)this + 20) = v7 | 2;
    *((_DWORD *)this + 4) = v4 - 15;
    uint64_t v9 = v3 & 3;
    *((void *)this + 1) = v9;
    if (v4)
    {
      uint64_t v10 = v9 | 4;
LABEL_21:
      *((void *)this + 1) = v10;
      return;
    }
    *((_DWORD *)this + 4) = -14;
  }
  else
  {
    if ((v3 & 0x80u) == 0) {
      char v11 = 3;
    }
    else {
      char v11 = 11;
    }
    *((unsigned char *)this + 20) = v11 | v5 & 0xF0;
    *((_DWORD *)this + 4) = -15;
    *((void *)this + 1) = 0;
  }
}

uint64_t llvm::detail::IEEEFloat::initFromFloat8E4M3FNAPInt(uint64_t result, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 8) >= 0x41u) {
    uint64_t v2 = *(uint64_t **)a2;
  }
  else {
    uint64_t v2 = (uint64_t *)a2;
  }
  uint64_t v3 = *v2;
  unsigned int v4 = (v3 >> 3) & 0xF;
  *(void *)uint64_t result = &unk_1CFB2E36C;
  char v5 = *(unsigned char *)(result + 20);
  if (v4 | v3 & 7)
  {
    unsigned int v6 = v5 & 0xF0 | ((char)v3 >> 4) & 8;
    if ((v3 & 7) == 7 && v4 == 15)
    {
      *(unsigned char *)(result + 20) = v6 | 1;
      *(_DWORD *)(result + 16) = 8;
      uint64_t v9 = 7;
      goto LABEL_16;
    }
    *(unsigned char *)(result + 20) = v6 | 2;
    *(_DWORD *)(result + 16) = v4 - 7;
    uint64_t v8 = v3 & 7;
    *(void *)(result + 8) = v8;
    if (v4)
    {
      uint64_t v9 = v8 | 8;
LABEL_16:
      *(void *)(result + 8) = v9;
      return result;
    }
    *(_DWORD *)(result + 16) = -6;
  }
  else
  {
    if ((v3 & 0x80u) == 0) {
      char v10 = 3;
    }
    else {
      char v10 = 11;
    }
    *(unsigned char *)(result + 20) = v10 | v5 & 0xF0;
    *(_DWORD *)(result + 16) = -7;
    *(void *)(result + 8) = 0;
  }
  return result;
}

void llvm::detail::IEEEFloat::initFromAPInt(llvm::detail::IEEEFloat *a1, void *a2, const llvm::APInt **a3)
{
  if (a2 == &unk_1CFB2E2E0)
  {
    llvm::detail::IEEEFloat::initFromHalfAPInt(a1, a3);
  }
  else if (a2 == &unk_1CFB2E2F4)
  {
    llvm::detail::IEEEFloat::initFromBFloatAPInt(a1, a3);
  }
  else if (a2 == &unk_1CFB2E308)
  {
    llvm::detail::IEEEFloat::initFromFloatAPInt(a1, a3);
  }
  else if (a2 == &unk_1CFB2E31C)
  {
    llvm::detail::IEEEFloat::initFromDoubleAPInt(a1, a3);
  }
  else
  {
    if (a2 == &unk_1CFB2E380) {
      llvm::detail::IEEEFloat::initFromF80LongDoubleAPInt(a1, (const llvm::APInt *)a3);
    }
    if (a2 == &unk_1CFB2E330) {
      llvm::detail::IEEEFloat::initFromQuadrupleAPInt(a1, (const llvm::APInt *)a3);
    }
    if (a2 == &unk_1CFB2E3B0)
    {
      llvm::detail::IEEEFloat::initFromPPCDoubleDoubleAPInt(a1, a3);
    }
    else if (a2 == &unk_1CFB2E358)
    {
      llvm::detail::IEEEFloat::initFromFloat8E5M2APInt(a1, a3);
    }
    else
    {
      llvm::detail::IEEEFloat::initFromFloat8E4M3FNAPInt((uint64_t)a1, (uint64_t)a3);
    }
  }
}

void *llvm::detail::IEEEFloat::makeLargest(llvm::detail::IEEEFloat *this, int a2)
{
  if (a2) {
    char v3 = 10;
  }
  else {
    char v3 = 2;
  }
  *((unsigned char *)this + 20) = *((unsigned char *)this + 20) & 0xF0 | v3;
  uint64_t v4 = *(void *)this;
  *((_DWORD *)this + 4) = **(_DWORD **)this;
  int v5 = *(_DWORD *)(v4 + 8);
  unsigned int v6 = (void *)((char *)this + 8);
  if ((v5 - 64) <= 0xFFFFFF7F) {
    unsigned int v6 = (void *)*v6;
  }
  int v7 = v5 + 64;
  uint64_t v8 = ((v5 + 64) >> 6) - 1;
  uint64_t result = memset(v6, 255, 8 * v8);
  uint64_t v10 = *(void *)this;
  if ((v7 & 0xFFFFFFC0) - *(_DWORD *)(*(void *)this + 8) >= 0x40) {
    unint64_t v11 = 0;
  }
  else {
    unint64_t v11 = 0xFFFFFFFFFFFFFFFFLL >> ((v7 & 0xC0u) - *(unsigned char *)(*(void *)this + 8));
  }
  v6[v8] = v11;
  if (*(_DWORD *)(v10 + 16) == 1) {
    *v6 &= ~1uLL;
  }
  return result;
}

uint64_t *llvm::detail::IEEEFloat::makeSmallestNormalized(uint64_t *this, int a2)
{
  *((unsigned char *)this + 20) = *((unsigned char *)this + 20) & 0xF8 | 2;
  uint64_t v2 = *this;
  int v3 = *(_DWORD *)(*this + 8);
  uint64_t v4 = (void **)(this + 1);
  if ((v3 - 64) < 0xFFFFFF80)
  {
    char v12 = (void **)(this + 1);
    uint64_t v8 = *v4;
    void *v8 = 0;
    uint64_t v10 = (uint64_t)this;
    uint64_t v11 = v2;
    int v9 = a2;
    bzero(v8 + 1, 8 * (((v3 + 64) >> 6) - 2) + 8);
    this = (uint64_t *)v10;
    uint64_t v2 = v11;
    uint64_t v4 = v12;
    a2 = v9;
  }
  else
  {
    *uint64_t v4 = 0;
  }
  if (a2) {
    char v5 = 8;
  }
  else {
    char v5 = 0;
  }
  *((unsigned char *)this + 20) = *((unsigned char *)this + 20) & 0xF7 | v5;
  int v7 = *(_DWORD *)(v2 + 4);
  int v6 = *(_DWORD *)(v2 + 8);
  *((_DWORD *)this + 4) = v7;
  if ((v6 - 64) <= 0xFFFFFF7F) {
    uint64_t v4 = (void **)*v4;
  }
  v4[((v6 + 63) >> 6) - 1] = (void *)((unint64_t)v4[((v6 + 63) >> 6) - 1] | (1 << (v6 + 63)));
  return this;
}

llvm::detail::IEEEFloat *llvm::detail::IEEEFloat::IEEEFloat(llvm::detail::IEEEFloat *this, float a2)
{
  int v5 = 32;
  uint64_t v4 = (const llvm::APInt *)LODWORD(a2);
  llvm::detail::IEEEFloat::initFromFloatAPInt(this, &v4);
  return this;
}

{
  const llvm::APInt *v4;
  int v5;

  int v5 = 32;
  uint64_t v4 = (const llvm::APInt *)LODWORD(a2);
  llvm::detail::IEEEFloat::initFromFloatAPInt(this, &v4);
  return this;
}

llvm::detail::IEEEFloat *llvm::detail::IEEEFloat::IEEEFloat(llvm::detail::IEEEFloat *this, double a2)
{
  int v5 = 64;
  uint64_t v4 = *(const llvm::APInt **)&a2;
  llvm::detail::IEEEFloat::initFromDoubleAPInt(this, &v4);
  return this;
}

{
  const llvm::APInt *v4;
  int v5;

  int v5 = 64;
  uint64_t v4 = *(const llvm::APInt **)&a2;
  llvm::detail::IEEEFloat::initFromDoubleAPInt(this, &v4);
  return this;
}

void llvm::detail::IEEEFloat::toString(uint64_t a1, uint64_t *a2, unsigned int a3, unsigned int a4, int a5)
{
  char v5 = a5;
  unsigned int v7 = a3;
  v125[32] = *MEMORY[0x1E4F143B8];
  int v9 = *(unsigned char *)(a1 + 20) & 7;
  if (v9 == 3)
  {
    uint64_t v17 = a2[1];
    if ((*(unsigned char *)(a1 + 20) & 8) != 0)
    {
      if (v17 + 1 > (unint64_t)a2[2]) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      *(unsigned char *)(*a2 + v17) = 45;
      uint64_t v17 = a2[1] + 1;
      a2[1] = v17;
    }
    if (a4)
    {
      if (v17 + 1 > (unint64_t)a2[2]) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      *(unsigned char *)(*a2 + v17) = 48;
      uint64_t v16 = a2[1] + 1;
      goto LABEL_72;
    }
    unint64_t v26 = a2[2];
    if (a5)
    {
      if (v26 < v17 + 6) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      uint64_t v27 = *a2 + v17;
      *(_WORD *)(v27 + 4) = 12331;
      *(_DWORD *)uint64_t v27 = 1160785456;
      uint64_t v16 = a2[1] + 6;
      goto LABEL_72;
    }
    if (v26 < v17 + 3) {
      llvm::SmallVectorBase<unsigned long long>::grow_pod();
    }
    uint64_t v38 = *a2 + v17;
    *(unsigned char *)(v38 + 2) = 48;
    *(_WORD *)uint64_t v38 = 11824;
    uint64_t v10 = a2[1] + 3;
    a2[1] = v10;
    if (a3 >= 2)
    {
      uint64_t v39 = a3 - 1;
      if (v10 + v39 > (unint64_t)a2[2]) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      memset((void *)(*a2 + v10), 48, a3 - 1);
      uint64_t v10 = a2[1] + v39;
      a2[1] = v10;
    }
    if (a2[2] < (unint64_t)(v10 + 4)) {
      llvm::SmallVectorBase<unsigned long long>::grow_pod();
    }
    uint64_t v12 = *a2;
    int v13 = 808463205;
    goto LABEL_71;
  }
  if (v9 == 1)
  {
    uint64_t v14 = a2[1];
    if (a2[2] < (unint64_t)(v14 + 3)) {
      llvm::SmallVectorBase<unsigned long long>::grow_pod();
    }
    uint64_t v15 = *a2 + v14;
    *(unsigned char *)(v15 + 2) = 78;
    *(_WORD *)uint64_t v15 = 24910;
    uint64_t v16 = a2[1] + 3;
    goto LABEL_72;
  }
  if ((*(unsigned char *)(a1 + 20) & 7) == 0)
  {
    uint64_t v10 = a2[1];
    unint64_t v11 = a2[2];
    if ((*(unsigned char *)(a1 + 20) & 8) != 0)
    {
      if (v11 < v10 + 4) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      uint64_t v12 = *a2;
      int v13 = 1718503725;
    }
    else
    {
      if (v11 < v10 + 4) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      uint64_t v12 = *a2;
      int v13 = 1718503723;
    }
LABEL_71:
    *(_DWORD *)(v12 + v10) = v13;
    uint64_t v16 = a2[1] + 4;
LABEL_72:
    a2[1] = v16;
    return;
  }
  if ((*(unsigned char *)(a1 + 20) & 8) != 0)
  {
    uint64_t v19 = a2[1];
    if (v19 + 1 > (unint64_t)a2[2]) {
      llvm::SmallVectorBase<unsigned long long>::grow_pod();
    }
    *(unsigned char *)(*a2 + v19) = 45;
    ++a2[1];
  }
  int v20 = *(_DWORD *)(*(void *)a1 + 8);
  long long v21 = (uint64_t *)(a1 + 8);
  if ((v20 - 64) <= 0xFFFFFF7F) {
    long long v21 = (uint64_t *)*v21;
  }
  int v22 = *(_DWORD *)(a1 + 16);
  unsigned int v120 = *(_DWORD *)(*(void *)a1 + 8);
  llvm::APInt::initFromArray((uint64_t)&__src, v21);
  if (!v7) {
    unsigned int v7 = 59 * *(_DWORD *)(*(void *)a1 + 8) / 0xC4u + 2;
  }
  if (v120 > 0x40)
  {
    unsigned int v25 = llvm::APInt::countTrailingZerosSlowCase((unint64_t **)&__src);
    llvm::APInt::lshrSlowCase((void **)&__src, v25);
  }
  else
  {
    unsigned int v24 = __clz(__rbit64(__src));
    if (v120 >= v24) {
      unsigned int v25 = v24;
    }
    else {
      unsigned int v25 = v120;
    }
    if (v120 > v24) {
      __src >>= v25;
    }
    else {
      unint64_t __src = 0;
    }
  }
  unsigned int v28 = v22 - v20 + v25;
  signed int v29 = v28 + 1;
  if (v28 != -1)
  {
    if (v29 < 1)
    {
      unsigned int v34 = *(_DWORD *)(*(void *)a1 + 8) + (-137 * v29 + 136) / 59;
      if (v34 > 0x40)
      {
        if (v120 != v34) {
          operator new[]();
        }
        sub_1CD0463BC((uint64_t)&__dst, (uint64_t)&__src);
      }
      else
      {
        LODWORD(v124) = *(_DWORD *)(*(void *)a1 + 8) + (-137 * v29 + 136) / 59;
        unint64_t v35 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v34;
        if (!v34) {
          unint64_t v35 = 0;
        }
        __dst = (void *)(v35 & __src);
      }
      if (v120 >= 0x41 && __src) {
        MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
      }
      int v36 = -v29;
      unint64_t __src = (unint64_t)__dst;
      unsigned int v120 = v124;
      LODWORD(v115) = v34;
      if (v34 > 0x40) {
        llvm::APInt::initSlowCase((llvm::APInt *)&v114);
      }
      unint64_t v37 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v34;
      if (!v34) {
        LOBYTE(v37) = 0;
      }
      v114 = (void *)(v37 & 5);
      while (1)
      {
        if (v36)
        {
          llvm::APInt::operator*((uint64_t)&__src, &v114, (uint64_t)&__dst);
          if (v120 >= 0x41 && __src) {
            MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
          }
          unint64_t __src = (unint64_t)__dst;
          unsigned int v120 = v124;
        }
        if (v36 < 2) {
          break;
        }
        llvm::APInt::operator*((uint64_t)&v114, &v114, (uint64_t)&__dst);
        if (v34 >= 0x41 && v114) {
          MEMORY[0x1D25D9CB0](v114, 0x1000C8000313F17);
        }
        v36 >>= 1;
        v114 = __dst;
        unsigned int v34 = v124;
        LODWORD(v115) = v124;
      }
      if (v34 >= 0x41 && v114) {
        MEMORY[0x1D25D9CB0](v114, 0x1000C8000313F17);
      }
    }
    else
    {
      unsigned int v30 = *(_DWORD *)(*(void *)a1 + 8) + v29;
      if (v30 > 0x40)
      {
        if (v120 != v30) {
          operator new[]();
        }
        sub_1CD0463BC((uint64_t)&__dst, (uint64_t)&__src);
      }
      else
      {
        LODWORD(v124) = *(_DWORD *)(*(void *)a1 + 8) + v29;
        unint64_t v31 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v30;
        if (!v30) {
          unint64_t v31 = 0;
        }
        __dst = (void *)(v31 & __src);
      }
      if (v120 >= 0x41 && __src) {
        MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
      }
      unint64_t __src = (unint64_t)__dst;
      unsigned int v120 = v124;
      if (v124 > 0x40)
      {
        llvm::APInt::shlSlowCase((llvm::APInt *)&__src, v29);
      }
      else
      {
        uint64_t v32 = (void)__dst << v29;
        if (v124 == v29) {
          uint64_t v32 = 0;
        }
        if (v124) {
          unint64_t v33 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v124;
        }
        else {
          unint64_t v33 = 0;
        }
        unint64_t __src = v33 & v32;
      }
      signed int v29 = 0;
    }
  }
  unsigned int v40 = v120;
  if (v120 > 0x40)
  {
    int v42 = 0;
    int64_t v43 = ((unint64_t)v120 + 63) >> 6;
    do
    {
      BOOL v44 = v43-- < 1;
      if (v44) {
        break;
      }
      unint64_t v45 = *(void *)(__src + 8 * v43);
      v42 += __clz(v45);
    }
    while (!v45);
    unsigned int v46 = v120 | 0xFFFFFFC0;
    if ((v120 & 0x3F) == 0) {
      unsigned int v46 = 0;
    }
    int v41 = v42 + v46;
  }
  else
  {
    int v41 = v120 + __clz(__src) - 64;
  }
  unsigned int v47 = v120 - v41;
  unsigned int v48 = (196 * v7 + 58) / 0x3B;
  BOOL v49 = v47 >= v48;
  unsigned int v50 = v47 - v48;
  if (v50 == 0 || !v49) {
    goto LABEL_154;
  }
  unsigned int v51 = 59 * v50;
  if (v51 < 0xC4) {
    goto LABEL_154;
  }
  unsigned int v52 = v51 / 0xC4;
  v29 += v51 / 0xC4;
  LODWORD(v115) = v120;
  if (v120 > 0x40) {
    llvm::APInt::initSlowCase((llvm::APInt *)&v114);
  }
  unint64_t v53 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v120;
  if (v120) {
    unint64_t v54 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v120;
  }
  else {
    LOBYTE(v54) = 0;
  }
  v114 = (void *)(v54 & 1);
  unsigned int v122 = v120;
  if (!v120) {
    LOBYTE(v53) = 0;
  }
  unint64_t v121 = v53 & 0xA;
  while (1)
  {
    if (v52)
    {
      llvm::APInt::operator*((uint64_t)&v114, &v121, (uint64_t)&__dst);
      if (v115 >= 0x41 && v114) {
        MEMORY[0x1D25D9CB0](v114, 0x1000C8000313F17);
      }
      v114 = __dst;
      LODWORD(v115) = v124;
    }
    if (v52 < 2) {
      break;
    }
    llvm::APInt::operator*((uint64_t)&v121, &v121, (uint64_t)&__dst);
    if (v40 >= 0x41 && v121) {
      MEMORY[0x1D25D9CB0](v121, 0x1000C8000313F17);
    }
    v52 >>= 1;
    unint64_t v121 = (unint64_t)__dst;
    unsigned int v40 = v124;
    unsigned int v122 = v124;
  }
  llvm::APInt::udiv((uint64_t)&__src, (const llvm::APInt *)&v114, (uint64_t)&__dst);
  if (v120 >= 0x41 && __src) {
    MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
  }
  p_src = (unint64_t *)__dst;
  unint64_t __src = (unint64_t)__dst;
  unsigned int v120 = v124;
  if (v124 >= 0x41)
  {
    int v57 = 0;
    int64_t v58 = ((unint64_t)v124 + 63) >> 6;
    do
    {
      BOOL v44 = v58-- < 1;
      if (v44) {
        break;
      }
      unint64_t v59 = *((void *)__dst + v58);
      v57 += __clz(v59);
    }
    while (!v59);
    int v60 = v124 | 0xFFFFFFC0;
    if ((v124 & 0x3F) == 0) {
      int v60 = 0;
    }
    int v61 = v60 + v57;
    int v56 = v124 - v61;
    if ((v124 - v61) >= 0x41)
    {
      if (v61) {
        operator new[]();
      }
      sub_1CD0463BC((uint64_t)&__dst, (uint64_t)&__src);
      goto LABEL_144;
    }
  }
  else
  {
    int v56 = 64 - __clz((unint64_t)__dst);
    p_src = &__src;
  }
  unint64_t v62 = *p_src;
  LODWORD(v124) = v56;
  if (v56) {
    unint64_t v63 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v56;
  }
  else {
    unint64_t v63 = 0;
  }
  __dst = (void *)(v63 & v62);
LABEL_144:
  if (v120 >= 0x41 && __src) {
    MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
  }
  unint64_t __src = (unint64_t)__dst;
  unsigned int v120 = v124;
  if (v122 >= 0x41 && v121) {
    MEMORY[0x1D25D9CB0](v121, 0x1000C8000313F17);
  }
  if (v115 >= 0x41 && v114) {
    MEMORY[0x1D25D9CB0](v114, 0x1000C8000313F17);
  }
  unsigned int v40 = v120;
LABEL_154:
  __dst = v125;
  long long v124 = xmmword_1CD96DBF0;
  unsigned int v122 = v40;
  if (v40 > 0x40) {
    llvm::APInt::initSlowCase((llvm::APInt *)&v121);
  }
  if (v40) {
    unint64_t v64 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v40;
  }
  else {
    LOBYTE(v64) = 0;
  }
  unint64_t v121 = v64 & 0xA;
  unsigned int v118 = v40;
  v117 = 0;
  LOBYTE(v40) = 1;
  while (1)
  {
    unint64_t v65 = __src;
    if (v120 < 0x41) {
      break;
    }
    int v66 = 0;
    int64_t v67 = ((unint64_t)v120 + 63) >> 6;
    do
    {
      BOOL v44 = v67-- < 1;
      if (v44) {
        break;
      }
      unint64_t v68 = *(void *)(__src + 8 * v67);
      v66 += __clz(v68);
    }
    while (!v68);
    unsigned int v69 = v120 | 0xFFFFFFC0;
    if ((v120 & 0x3F) == 0) {
      unsigned int v69 = 0;
    }
    if (v120 - v66 - v69 <= 0x40)
    {
      unint64_t v65 = *(void *)__src;
      break;
    }
LABEL_167:
    llvm::APInt::udivrem((llvm::APInt *)&__src, (const llvm::APInt *)&v121, (const llvm::APInt *)&__src, (llvm::APInt *)&v117, v23);
    if (v118 >= 0x41) {
      v70 = v117;
    }
    else {
      v70 = &v117;
    }
    unsigned int v40 = v40 & (*v70 == 0);
    if (v40 == 1)
    {
      ++v29;
    }
    else
    {
      if ((unint64_t)(v124 + 1) > *((void *)&v124 + 1)) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      *((unsigned char *)__dst + v124) = *v70 + 48;
      *(void *)&long long v124 = v124 + 1;
    }
  }
  if (v65) {
    goto LABEL_167;
  }
  unsigned int v71 = v124;
  uint64_t v72 = v124 - v7;
  if (v124 > v7)
  {
    v73 = __dst;
    if (*((char *)__dst + (v72 - 1)) >= 53)
    {
      int v75 = -v7;
      while (1)
      {
        uint64_t v72 = (v124 + v75);
        int v76 = *((unsigned __int8 *)__dst + v72);
        if (v76 != 57) {
          break;
        }
        BOOL v49 = __CFADD__(v75++, 1);
        if (v49) {
          goto LABEL_191;
        }
      }
      *((unsigned char *)__dst + v72) = v76 + 1;
      if (!v75)
      {
LABEL_191:
        *(void *)&long long v124 = 0;
        if (!*((void *)&v124 + 1)) {
          llvm::SmallVectorBase<unsigned long long>::grow_pod();
        }
        *(unsigned char *)__dst = 49;
        int64_t v79 = v124 + 1;
        LODWORD(v72) = v71;
        goto LABEL_197;
      }
      v77 = __dst;
      uint64_t v78 = v124 - v72;
      if ((void)v124 != v72) {
        memmove(__dst, (char *)__dst + v72, v124 - v72);
      }
      int64_t v79 = &v77[v78] - (unsigned char *)__dst;
    }
    else
    {
      if (v72 < v124)
      {
        while (*((unsigned char *)__dst + v72) == 48)
        {
          if (v124 == ++v72)
          {
            LODWORD(v72) = v124;
            break;
          }
        }
      }
      uint64_t v74 = v124 - v72;
      if ((void)v124 != v72) {
        memmove(__dst, (char *)__dst + v72, v124 - v72);
      }
      int64_t v79 = &v73[v74] - (unsigned char *)__dst;
    }
LABEL_197:
    v29 += v72;
    *(void *)&long long v124 = v79;
    unsigned int v71 = v79;
  }
  if (!a4) {
    goto LABEL_210;
  }
  if (v29 < 0)
  {
    int v83 = v29 + v71;
    if (((v29 + v71 - 1) & 0x80000000) != 0 && 1 - v83 > a4) {
      goto LABEL_210;
    }
    if (v83 < 1)
    {
      uint64_t v110 = a2[1];
      if (v110 + 1 > (unint64_t)a2[2]) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      *(unsigned char *)(*a2 + v110) = 48;
      uint64_t v111 = a2[1];
      unint64_t v112 = a2[2];
      a2[1] = v111 + 1;
      if (v111 + 2 > v112) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      *(unsigned char *)(*a2 + v111 + 1) = 46;
      uint64_t v109 = a2[1] + 1;
      a2[1] = v109;
      if (v83)
      {
        do
        {
          if (v109 + 1 > (unint64_t)a2[2]) {
            llvm::SmallVectorBase<unsigned long long>::grow_pod();
          }
          *(unsigned char *)(*a2 + v109) = 48;
          uint64_t v109 = a2[1] + 1;
          a2[1] = v109;
          BOOL v49 = __CFADD__(v83++, 1);
        }
        while (!v49);
        int v83 = 0;
      }
    }
    else
    {
      uint64_t v105 = a2[1];
      unsigned int v106 = v71 - 1;
      uint64_t v107 = v29 + v71;
      do
      {
        if (v105 + 1 > (unint64_t)a2[2]) {
          llvm::SmallVectorBase<unsigned long long>::grow_pod();
        }
        *(unsigned char *)(*a2 + v105) = *((unsigned char *)__dst + v106);
        uint64_t v108 = a2[1];
        uint64_t v105 = v108 + 1;
        a2[1] = v108 + 1;
        --v106;
        --v107;
      }
      while (v107);
      if (v108 + 2 > (unint64_t)a2[2]) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      *(unsigned char *)(*a2 + v105) = 46;
      uint64_t v109 = a2[1] + 1;
      a2[1] = v109;
    }
    if (v83 != v71)
    {
      unsigned int v113 = ~v83 + v71;
      do
      {
        if (v109 + 1 > (unint64_t)a2[2]) {
          llvm::SmallVectorBase<unsigned long long>::grow_pod();
        }
        *(unsigned char *)(*a2 + v109) = *((unsigned char *)__dst + v113);
        uint64_t v109 = a2[1] + 1;
        a2[1] = v109;
        --v113;
      }
      while (v113 != -1);
    }
  }
  else
  {
    if (v29 <= a4 && v29 + v71 <= v7)
    {
      if (v71)
      {
        uint64_t v80 = v71;
        uint64_t v81 = a2[1];
        unsigned int v82 = v71 - 1;
        do
        {
          if (v81 + 1 > (unint64_t)a2[2]) {
            llvm::SmallVectorBase<unsigned long long>::grow_pod();
          }
          *(unsigned char *)(*a2 + v81) = *((unsigned char *)__dst + v82);
          uint64_t v81 = a2[1] + 1;
          a2[1] = v81;
          --v82;
          --v80;
        }
        while (v80);
      }
      if (v29)
      {
        uint64_t v103 = a2[1];
        do
        {
          if (v103 + 1 > (unint64_t)a2[2]) {
            llvm::SmallVectorBase<unsigned long long>::grow_pod();
          }
          *(unsigned char *)(*a2 + v103) = 48;
          uint64_t v103 = a2[1] + 1;
          a2[1] = v103;
          --v29;
        }
        while (v29);
      }
      goto LABEL_250;
    }
LABEL_210:
    unsigned int v84 = v71 - 1;
    uint64_t v85 = a2[1];
    if (v85 + 1 > (unint64_t)a2[2]) {
      llvm::SmallVectorBase<unsigned long long>::grow_pod();
    }
    *(unsigned char *)(*a2 + v85) = *((unsigned char *)__dst + v71 - 1);
    uint64_t v86 = a2[1];
    unint64_t v87 = a2[2];
    a2[1] = v86 + 1;
    if (v86 + 2 > v87) {
      llvm::SmallVectorBase<unsigned long long>::grow_pod();
    }
    *(unsigned char *)(*a2 + v86 + 1) = 46;
    uint64_t v88 = a2[1];
    uint64_t v89 = v88 + 1;
    a2[1] = v88 + 1;
    if (v71 == 1 && (v5 & 1) != 0)
    {
      if (v88 + 2 > (unint64_t)a2[2]) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      *(unsigned char *)(*a2 + v89) = 48;
      uint64_t v89 = a2[1] + 1;
      a2[1] = v89;
    }
    else if (v71 != 1)
    {
      unsigned int v104 = v71 - 2;
      do
      {
        if (v89 + 1 > (unint64_t)a2[2]) {
          llvm::SmallVectorBase<unsigned long long>::grow_pod();
        }
        *(unsigned char *)(*a2 + v89) = *((unsigned char *)__dst + v104);
        uint64_t v89 = a2[1] + 1;
        a2[1] = v89;
        --v104;
      }
      while (v104 != -1);
    }
    if (v5)
    {
      char v90 = 69;
    }
    else
    {
      if (v7 > v84)
      {
        size_t v91 = v7 - v71 + 1;
        if (v89 + v91 > a2[2]) {
          llvm::SmallVectorBase<unsigned long long>::grow_pod();
        }
        if (v91)
        {
          memset((void *)(*a2 + v89), 48, v91);
          uint64_t v89 = a2[1];
        }
        v89 += v91;
        a2[1] = v89;
      }
      char v90 = 101;
    }
    int v92 = v84 + v29;
    if (v89 + 1 > (unint64_t)a2[2]) {
      llvm::SmallVectorBase<unsigned long long>::grow_pod();
    }
    *(unsigned char *)(*a2 + v89) = v90;
    uint64_t v93 = a2[1];
    unint64_t v94 = a2[2];
    uint64_t v95 = v93 + 1;
    a2[1] = v93 + 1;
    if (v92 < 0) {
      char v96 = 45;
    }
    else {
      char v96 = 43;
    }
    if (v93 + 2 > v94) {
      llvm::SmallVectorBase<unsigned long long>::grow_pod();
    }
    unint64_t v97 = 0;
    *(unsigned char *)(*a2 + v95) = v96;
    ++a2[1];
    if (v92 >= 0) {
      unsigned int v98 = v92;
    }
    else {
      unsigned int v98 = -v92;
    }
    v114 = &v116;
    long long v115 = xmmword_1CFAC6570;
    do
    {
      if (v97 + 1 > *((void *)&v115 + 1)) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      *((unsigned char *)v114 + v97) = (v98 % 0xA) | 0x30;
      uint64_t v99 = v115;
      unint64_t v97 = v115 + 1;
      *(void *)&long long v115 = v115 + 1;
      BOOL v44 = v98 > 9;
      v98 /= 0xAu;
    }
    while (v44);
    if ((v5 & 1) == 0 && v97 <= 1)
    {
      if ((unint64_t)(v99 + 2) > *((void *)&v115 + 1)) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      *((unsigned char *)v114 + v97) = 48;
      LODWORD(v97) = v115 + 1;
      *(void *)&long long v115 = v115 + 1;
    }
    uint64_t v100 = v97;
    if (v97)
    {
      uint64_t v101 = a2[1];
      unsigned int v102 = v97 - 1;
      do
      {
        if (v101 + 1 > (unint64_t)a2[2]) {
          llvm::SmallVectorBase<unsigned long long>::grow_pod();
        }
        *(unsigned char *)(*a2 + v101) = *((unsigned char *)v114 + v102);
        uint64_t v101 = a2[1] + 1;
        a2[1] = v101;
        --v102;
        --v100;
      }
      while (v100);
    }
    if (v114 != &v116) {
      free(v114);
    }
  }
LABEL_250:
  if (v118 >= 0x41 && v117) {
    MEMORY[0x1D25D9CB0](v117, 0x1000C8000313F17);
  }
  if (v122 >= 0x41 && v121) {
    MEMORY[0x1D25D9CB0](v121, 0x1000C8000313F17);
  }
  if (__dst != v125) {
    free(__dst);
  }
  if (v120 >= 0x41 && __src) {
    MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
  }
}

uint64_t llvm::detail::IEEEFloat::getExactInverse(void **a1, uint64_t a2)
{
  v27[3] = *(void **)MEMORY[0x1E4F143B8];
  if ((*((unsigned char *)a1 + 20) & 6) == 0 || (*((unsigned char *)a1 + 20) & 7) == 3) {
    return 0;
  }
  char v5 = (unint64_t *)(a1 + 1);
  unsigned int v6 = *((_DWORD *)*a1 + 2);
  unsigned int v7 = v6 - 64;
  if (v6 - 64 <= 0xFFFFFF7F)
  {
    char v5 = (unint64_t *)*v5;
    unsigned int v8 = v6 + 64;
  }
  else
  {
    unsigned int v8 = v6 + 64;
    if (v6 > 0xFFFFFFBF)
    {
LABEL_28:
      int v13 = -1;
      goto LABEL_10;
    }
  }
  int v9 = 0;
  unint64_t v10 = (unint64_t)v8 >> 6;
  while (1)
  {
    unint64_t v12 = *v5++;
    unint64_t v11 = v12;
    if (v12) {
      break;
    }
    v9 -= 64;
    if (!--v10) {
      goto LABEL_28;
    }
  }
  int v13 = __clz(__rbit64(v11)) - v9;
LABEL_10:
  if (v13 != v6 - 1) {
    return 0;
  }
  int v22 = *a1;
  if (v8 >= 0x80) {
    operator new[]();
  }
  char v25 = 2;
  uint64_t v16 = &v23;
  uint64_t v17 = (void **)&v23;
  if (v7 <= 0xFFFFFF7F) {
    uint64_t v17 = a1;
  }
  unsigned __int8 *v17 = 0;
  if (v6 + 64 >= 0x80)
  {
    unsigned int v19 = v6;
    unsigned int v18 = v6 - 64;
    bzero(v17 + 1, 8 * (((v6 + 64) >> 6) - 2) + 8);
    uint64_t v16 = &v23;
    unsigned int v7 = v18;
    unsigned int v6 = v19;
  }
  unsigned int v24 = v6 - 1;
  if (v7 <= 0xFFFFFF7F) {
    uint64_t v16 = v23;
  }
  *uint64_t v16 = 1;
  llvm::detail::IEEEFloat::normalize((llvm::detail::IEEEFloat *)&v22, 1, 0);
  if (llvm::detail::IEEEFloat::divide((llvm::detail::IEEEFloat *)&v22, (const llvm::detail::IEEEFloat *)a1, 1)|| llvm::detail::IEEEFloat::isDenormal((llvm::detail::IEEEFloat *)&v22))
  {
    uint64_t v14 = 0;
  }
  else
  {
    if (a2)
    {
      llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&v20, (const llvm::detail::IEEEFloat *)&v22);
      sub_1CD8249E0((uint64_t)v26, (uint64_t)&v20, *a1);
      sub_1CB9190C0((uint64_t *)(a2 + 8), v27);
      sub_1CB87DEE4((uint64_t *)v27);
      if ((*(_DWORD *)(v20 + 8) - 64) <= 0xFFFFFF7F)
      {
        if (v21) {
          MEMORY[0x1D25D9CB0](v21, 0x1000C8000313F17);
        }
      }
    }
    uint64_t v14 = 1;
  }
  if ((v22[2] - 64) <= 0xFFFFFF7F && v23) {
    MEMORY[0x1D25D9CB0](v23, 0x1000C8000313F17);
  }
  return v14;
}

uint64_t llvm::detail::IEEEFloat::exponentInf(llvm::detail::IEEEFloat *this)
{
  return (**(_DWORD **)this + 1);
}

uint64_t llvm::detail::IEEEFloat::exponentZero(llvm::detail::IEEEFloat *this)
{
  return (*(_DWORD *)(*(void *)this + 4) - 1);
}

void *llvm::detail::frexp@<X0>(uint64_t *a1@<X0>, const llvm::detail::IEEEFloat *a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t result = (void *)llvm::detail::ilogb((llvm::detail *)a1, a2);
  *(_DWORD *)a2 = result;
  if (result == 0x80000000)
  {
    uint64_t v24 = *a1;
    *(void *)a4 = *a1;
    if ((*(_DWORD *)(v24 + 8) + 64) >= 0x80) {
      operator new[]();
    }
    char v25 = *((unsigned char *)a1 + 20);
    int v26 = v25 & 7;
    *(unsigned char *)(a4 + 20) = *(unsigned char *)(a4 + 20) & 0xF0 | v25 & 0xF;
    *(_DWORD *)(a4 + 16) = *((_DWORD *)a1 + 4);
    BOOL v28 = (v25 & 6) != 0 && v26 != 3;
    if (v26 == 1 || v28)
    {
      uint64_t v30 = *(unsigned int *)(v24 + 8);
      unint64_t v31 = (void *)(a4 + 8);
      if ((v30 - 64) <= 0xFFFFFF7F) {
        unint64_t v31 = (void *)*v31;
      }
      unsigned int v32 = *(_DWORD *)(*a1 + 8) - 64;
      unint64_t v35 = (uint64_t *)a1[1];
      unsigned int v34 = a1 + 1;
      unint64_t v33 = v35;
      if (v32 >= 0xFFFFFF80) {
        int v36 = v34;
      }
      else {
        int v36 = v33;
      }
      if (v30 <= 0xFFFFFFBF)
      {
        unint64_t v37 = (unint64_t)(v30 + 64) >> 6;
        do
        {
          uint64_t v38 = *v36++;
          *v31++ = v38;
          --v37;
        }
        while (v37);
      }
    }
    if (*(_DWORD *)(v24 + 16) != 1)
    {
      int v39 = *(_DWORD *)(v24 + 8);
      uint64_t v42 = *(void *)(a4 + 8);
      uint64_t v41 = a4 + 8;
      uint64_t v40 = v42;
      if ((v39 - 64) >= 0xFFFFFF80) {
        uint64_t v40 = v41;
      }
      *(void *)(v40 + 8 * ((v39 - 2) >> 6)) |= 1 << (v39 - 2);
    }
  }
  else if (result == 0x7FFFFFFF)
  {
    uint64_t v9 = *a1;
    *(void *)a4 = *a1;
    if ((*(_DWORD *)(v9 + 8) + 64) >= 0x80) {
      operator new[]();
    }
    char v10 = *((unsigned char *)a1 + 20);
    int v11 = v10 & 7;
    *(unsigned char *)(a4 + 20) = *(unsigned char *)(a4 + 20) & 0xF0 | v10 & 0xF;
    *(_DWORD *)(a4 + 16) = *((_DWORD *)a1 + 4);
    BOOL v13 = (v10 & 6) != 0 && v11 != 3;
    if (v11 == 1 || v13)
    {
      uint64_t v15 = *(unsigned int *)(v9 + 8);
      uint64_t v16 = (void *)(a4 + 8);
      if ((v15 - 64) <= 0xFFFFFF7F) {
        uint64_t v16 = (void *)*v16;
      }
      unsigned int v17 = *(_DWORD *)(*a1 + 8) - 64;
      uint64_t v20 = (uint64_t *)a1[1];
      unsigned int v19 = a1 + 1;
      unsigned int v18 = v20;
      if (v17 >= 0xFFFFFF80) {
        uint64_t v21 = v19;
      }
      else {
        uint64_t v21 = v18;
      }
      if (v15 <= 0xFFFFFFBF)
      {
        unint64_t v22 = (unint64_t)(v15 + 64) >> 6;
        do
        {
          uint64_t v23 = *v21++;
          *v16++ = v23;
          --v22;
        }
        while (v22);
      }
    }
  }
  else
  {
    if (result == -2147483647) {
      int v43 = 0;
    }
    else {
      int v43 = result + 1;
    }
    *(_DWORD *)a2 = v43;
    uint64_t v44 = *a1;
    uint64_t v58 = v44;
    if ((*(_DWORD *)(v44 + 8) + 64) >= 0x80) {
      operator new[]();
    }
    char v45 = *((unsigned char *)a1 + 20);
    int v46 = v45 & 7;
    char v61 = v45 & 0xF;
    int v60 = *((_DWORD *)a1 + 4);
    BOOL v48 = (v45 & 6) != 0 && v46 != 3;
    if (v46 == 1 || v48)
    {
      uint64_t v49 = *(unsigned int *)(v44 + 8);
      unsigned int v50 = (v49 - 64) <= 0xFFFFFF7F ? result : &v59;
      unsigned int v51 = *(_DWORD *)(*a1 + 8) - 64;
      unint64_t v54 = (uint64_t *)a1[1];
      unint64_t v53 = a1 + 1;
      unsigned int v52 = v54;
      uint64_t v55 = v51 >= 0xFFFFFF80 ? v53 : v52;
      if (v49 <= 0xFFFFFFBF)
      {
        unint64_t v56 = (unint64_t)(v49 + 64) >> 6;
        do
        {
          uint64_t v57 = *v55++;
          *v50++ = v57;
          --v56;
        }
        while (v56);
      }
    }
    uint64_t result = (void *)llvm::detail::scalbn(&v58, -*(_DWORD *)a2, a3, (void *)a4);
    if ((*(_DWORD *)(v58 + 8) - 64) <= 0xFFFFFF7F)
    {
      uint64_t result = v59;
      if (v59) {
        return (void *)MEMORY[0x1D25D9CB0](v59, 0x1000C8000313F17);
      }
    }
  }
  return result;
}

void llvm::detail::DoubleAPFloat::DoubleAPFloat(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new[]();
}

{
  *a1 = a2;
  operator new[]();
}

{
  *a1 = a2;
  operator new[]();
}

{
  *a1 = a2;
  operator new[]();
}

{
  *a1 = a2;
  operator new[]();
}

{
  *a1 = a2;
  operator new[]();
}

{
  *a1 = a2;
  operator new[]();
}

{
  *a1 = a2;
  operator new[]();
}

void *llvm::detail::DoubleAPFloat::DoubleAPFloat(void *result, void *a2)
{
  void *result = *a2;
  uint64_t v2 = a2[1];
  a2[1] = 0;
  result[1] = v2;
  *a2 = &unk_1CFB2E394;
  return result;
}

{
  uint64_t v2;

  void *result = *a2;
  uint64_t v2 = a2[1];
  a2[1] = 0;
  result[1] = v2;
  *a2 = &unk_1CFB2E394;
  return result;
}

uint64_t llvm::detail::DoubleAPFloat::getCategory(llvm::detail::DoubleAPFloat *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (*(_UNKNOWN **)(v1 + 8) == &unk_1CFB2E344) {
    uint64_t v1 = *(void *)(v1 + 16);
  }
  return *(unsigned char *)(v1 + 28) & 7;
}

uint64_t llvm::detail::DoubleAPFloat::isNegative(llvm::detail::DoubleAPFloat *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (*(_UNKNOWN **)(v1 + 8) == &unk_1CFB2E344) {
    uint64_t v1 = *(void *)(v1 + 16);
  }
  return (*(unsigned __int8 *)(v1 + 28) >> 3) & 1;
}

unint64_t llvm::hash_value(llvm *this, const llvm::APFloat *a2)
{
  int v3 = (void *)*((void *)this + 1);
  uint64_t v2 = (llvm *)((char *)this + 8);
  if (v3 == &unk_1CFB2E344) {
    return llvm::detail::hash_value(v2, a2);
  }
  else {
    return llvm::detail::hash_value(v2, a2);
  }
}

llvm::detail::IEEEFloat *llvm::APFloat::convertFromString@<X0>(uint64_t a1@<X0>, unsigned __int8 *a2@<X1>, unint64_t a3@<X2>, int a4@<W3>, llvm *a5@<X8>)
{
  unsigned int v6 = *(void **)(a1 + 8);
  char v5 = (llvm::detail::IEEEFloat *)(a1 + 8);
  if (v6 == &unk_1CFB2E344) {
    return (llvm::detail::IEEEFloat *)llvm::detail::DoubleAPFloat::convertFromString(v5);
  }
  else {
    return llvm::detail::IEEEFloat::convertFromString(v5, a2, a3, a4, a5);
  }
}

void llvm::detail::DoubleAPFloat::convertFromSignExtendedInteger(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v12[3] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = (llvm::detail::IEEEFloat *)llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v12, (uint64_t)&unk_1CFB2E3B0);
  if ((_UNKNOWN *)v12[0] == &unk_1CFB2E344) {
    llvm::detail::DoubleAPFloat::convertFromSignExtendedInteger(v9, a2, a3, a4, a5);
  }
  else {
    llvm::detail::IEEEFloat::convertFromSignExtendedInteger(v9, a2, a3, a4, a5);
  }
  if ((_UNKNOWN *)v12[0] == &unk_1CFB2E344) {
    llvm::detail::DoubleAPFloat::bitcastToAPInt((llvm::detail::DoubleAPFloat *)v12, (llvm::APInt *)&v10);
  }
  else {
    llvm::detail::IEEEFloat::bitcastToAPInt((uint64_t)v12, (uint64_t)&v10);
  }
  llvm::detail::DoubleAPFloat::DoubleAPFloat(&v11, (uint64_t)&unk_1CFB2E344);
}

void llvm::detail::DoubleAPFloat::convertFromZeroExtendedInteger(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v12[3] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = (llvm::detail::IEEEFloat *)llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v12, (uint64_t)&unk_1CFB2E3B0);
  if ((_UNKNOWN *)v12[0] == &unk_1CFB2E344) {
    llvm::detail::DoubleAPFloat::convertFromZeroExtendedInteger(v9, a2, a3, a4, a5);
  }
  else {
    llvm::detail::IEEEFloat::convertFromZeroExtendedInteger(v9, a2, a3, a4, a5);
  }
  if ((_UNKNOWN *)v12[0] == &unk_1CFB2E344) {
    llvm::detail::DoubleAPFloat::bitcastToAPInt((llvm::detail::DoubleAPFloat *)v12, (llvm::APInt *)&v10);
  }
  else {
    llvm::detail::IEEEFloat::bitcastToAPInt((uint64_t)v12, (uint64_t)&v10);
  }
  llvm::detail::DoubleAPFloat::DoubleAPFloat(&v11, (uint64_t)&unk_1CFB2E344);
}

uint64_t llvm::detail::DoubleAPFloat::convertToHexString(llvm::detail::DoubleAPFloat *a1, unsigned char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v14[3] = *MEMORY[0x1E4F143B8];
  llvm::detail::DoubleAPFloat::bitcastToAPInt(a1, (llvm::APInt *)&v12);
  llvm::detail::IEEEFloat::initFromPPCDoubleDoubleAPInt((llvm::detail::IEEEFloat *)v14, &v12);
  if ((_UNKNOWN *)v14[0] == &unk_1CFB2E344) {
    uint64_t v9 = llvm::detail::DoubleAPFloat::convertToHexString(v14, a2, a3, a4, a5);
  }
  else {
    uint64_t v9 = llvm::detail::IEEEFloat::convertToHexString((uint64_t)v14, a2, a3, a4, a5);
  }
  uint64_t v10 = v9;
  sub_1CB87DEE4(v14);
  if (v13 >= 0x41 && v12) {
    MEMORY[0x1D25D9CB0](v12, 0x1000C8000313F17);
  }
  return v10;
}

void llvm::detail::frexp(uint64_t a1@<X0>, const llvm::detail::IEEEFloat *a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  int v4 = a3;
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v10 = *(void **)(v8 + 8);
  uint64_t v9 = (uint64_t *)(v8 + 8);
  if (v10 == &unk_1CFB2E344)
  {
    long long v11 = (uint64_t **)llvm::detail::frexp(&v42, v9, a2, a3);
    long long v47 = v42;
  }
  else
  {
    llvm::detail::frexp(v9, a2, a3, (uint64_t)&v42);
    long long v11 = (uint64_t **)sub_1CD8249E0((uint64_t)v46, (uint64_t)&v42, (void *)*v9);
    if ((*(_DWORD *)(v42 + 8) - 64) <= 0xFFFFFF7F)
    {
      long long v11 = (uint64_t **)*((void *)&v42 + 1);
      if (*((void *)&v42 + 1)) {
        long long v11 = (uint64_t **)MEMORY[0x1D25D9CB0](*((void *)&v42 + 1), 0x1000C8000313F17);
      }
    }
  }
  uint64_t v12 = *(void *)(a1 + 8);
  uint64_t v13 = *(void *)(v12 + 40);
  if ((_UNKNOWN *)v13 == &unk_1CFB2E344)
  {
    llvm::detail::DoubleAPFloat::DoubleAPFloat((void *)&v42 + 1, (const llvm::detail::DoubleAPFloat *)(v12 + 40));
  }
  else
  {
    *((void *)&v42 + 1) = *(void *)(v12 + 40);
    if ((*(_DWORD *)(v13 + 8) + 64) >= 0x80) {
      operator new[]();
    }
    char v14 = *(unsigned char *)(v12 + 60);
    int v15 = v14 & 7;
    char v45 = v14 & 0xF;
    int v44 = *(_DWORD *)(v12 + 56);
    BOOL v17 = (v14 & 6) != 0 && v15 != 3;
    if (v15 == 1 || v17)
    {
      uint64_t v19 = *(unsigned int *)(*((void *)&v42 + 1) + 8);
      if ((v19 - 64) <= 0xFFFFFF7F) {
        uint64_t v20 = v11;
      }
      else {
        uint64_t v20 = &v43;
      }
      uint64_t v23 = *(uint64_t **)(v12 + 48);
      uint64_t v21 = (uint64_t *)(v12 + 48);
      unint64_t v22 = v23;
      if ((*(_DWORD *)(*(v21 - 1) + 8) - 64) < 0xFFFFFF80) {
        uint64_t v21 = v22;
      }
      if (v19 <= 0xFFFFFFBF)
      {
        unint64_t v24 = (unint64_t)(v19 + 64) >> 6;
        do
        {
          char v25 = (uint64_t *)*v21++;
          *v20++ = v25;
          --v24;
        }
        while (v24);
      }
    }
  }
  uint64_t v26 = *(void *)(a1 + 8);
  if (*(_UNKNOWN **)(v26 + 8) == &unk_1CFB2E344) {
    uint64_t v26 = *(void *)(v26 + 16);
  }
  if ((*(unsigned char *)(v26 + 28) & 7) == 2)
  {
    if (*((_UNKNOWN **)&v42 + 1) == &unk_1CFB2E344)
    {
      llvm::detail::DoubleAPFloat::DoubleAPFloat(&v36, (const llvm::detail::DoubleAPFloat *)((char *)&v42 + 8));
    }
    else
    {
      uint64_t v36 = *((void *)&v42 + 1);
      if ((*(_DWORD *)(*((void *)&v42 + 1) + 8) + 64) >= 0x80) {
        operator new[]();
      }
      int v27 = v45 & 7;
      char v39 = v39 & 0xF0 | v45 & 0xF;
      int v38 = v44;
      BOOL v29 = (v45 & 6) != 0 && v27 != 3;
      if (v27 == 1 || v29)
      {
        uint64_t v30 = *(unsigned int *)(v36 + 8);
        if ((v30 - 64) <= 0xFFFFFF7F) {
          unint64_t v31 = v37;
        }
        else {
          unint64_t v31 = &v37;
        }
        if ((*(_DWORD *)(*((void *)&v42 + 1) + 8) - 64) >= 0xFFFFFF80) {
          unsigned int v32 = (uint64_t *)&v43;
        }
        else {
          unsigned int v32 = v43;
        }
        if (v30 <= 0xFFFFFFBF)
        {
          unint64_t v33 = (unint64_t)(v30 + 64) >> 6;
          do
          {
            uint64_t v34 = *v32++;
            *v31++ = v34;
            --v33;
          }
          while (v33);
        }
      }
    }
    sub_1CD47247C(&v40, &v35, -*(_DWORD *)a2, v4);
    sub_1CB9190C0((uint64_t *)&v42 + 1, v41);
    sub_1CB87DEE4((uint64_t *)v41);
    sub_1CB87DEE4(&v36);
  }
  llvm::detail::DoubleAPFloat::DoubleAPFloat(a4, (uint64_t)&unk_1CFB2E344);
}

uint64_t llvm::APFloat::Storage::Storage(uint64_t result, uint64_t a2, void *a3)
{
  v13[3] = *MEMORY[0x1E4F143B8];
  if (a3 == &unk_1CFB2E344)
  {
    uint64_t v4 = *(void *)a2;
    char v5 = (void *)result;
    v6[0] = &unk_1CFB2E394;
    llvm::detail::IEEEFloat::operator=((uint64_t)v6, a2);
    uint64_t v9 = v6[0];
    uint64_t v10 = v6[1];
    int v11 = v7;
    char v12 = v8 & 0xF;
    v6[0] = &unk_1CFB2E394;
    llvm::APFloat::Storage::Storage(v13, &v9, v4);
    if ((*(_DWORD *)(v9 + 8) - 64) <= 0xFFFFFF7F && v10) {
      MEMORY[0x1D25D9CB0](v10, 0x1000C8000313F17);
    }
    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&v10, (uint64_t)&unk_1CFB2E31C);
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v5, (uint64_t)&unk_1CFB2E344);
  }
  *(void *)uint64_t result = &unk_1CFB2E394;
  *(void *)uint64_t result = *(void *)a2;
  *(void *)(result + 8) = *(void *)(a2 + 8);
  *(_DWORD *)(result + 16) = *(_DWORD *)(a2 + 16);
  char v3 = *(unsigned char *)(result + 20) & 0xF8 | *(unsigned char *)(a2 + 20) & 7;
  *(unsigned char *)(result + 20) = v3;
  *(unsigned char *)(result + 20) = v3 & 0xF7 | *(unsigned char *)(a2 + 20) & 8;
  *(void *)a2 = &unk_1CFB2E394;
  return result;
}

uint64_t llvm::APFloat::APFloat(uint64_t a1, void *a2, unsigned __int8 *a3, unint64_t a4)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  int v7 = (llvm::detail::IEEEFloat *)(a1 + 8);
  if (a2 == &unk_1CFB2E344)
  {
    *(void *)(a1 + 8) = &unk_1CFB2E344;
    operator new[]();
  }
  llvm::detail::IEEEFloat::IEEEFloat(a1 + 8, (uint64_t)a2);
  if (*(_UNKNOWN **)v7 == &unk_1CFB2E344) {
    llvm::detail::DoubleAPFloat::convertFromString(a3, a4, 1, (llvm *)&v12);
  }
  llvm::detail::IEEEFloat::convertFromString(v7, a3, a4, 1, (llvm *)&v12);
  char v8 = v13;
  if (v13)
  {
    uint64_t v9 = v12;
    char v12 = 0;
  }
  else
  {
    uint64_t v9 = 0;
  }
  int v11 = v9;
  sub_1CD4515D0(&v11);
  if (v11) {
    (*(void (**)(void *))(*v11 + 8))(v11);
  }
  if ((v8 & 1) != 0 && v12) {
    (*(void (**)(void *))(*v12 + 8))(v12);
  }
  return a1;
}

{
  llvm::detail::IEEEFloat *v7;
  char v8;
  void *v9;
  void *v11;
  void *v12;
  char v13;
  uint64_t v14;

  uint64_t v14 = *MEMORY[0x1E4F143B8];
  int v7 = (llvm::detail::IEEEFloat *)(a1 + 8);
  if (a2 == &unk_1CFB2E344)
  {
    *(void *)(a1 + 8) = &unk_1CFB2E344;
    operator new[]();
  }
  llvm::detail::IEEEFloat::IEEEFloat(a1 + 8, (uint64_t)a2);
  if (*(_UNKNOWN **)v7 == &unk_1CFB2E344) {
    llvm::detail::DoubleAPFloat::convertFromString(a3, a4, 1, (llvm *)&v12);
  }
  llvm::detail::IEEEFloat::convertFromString(v7, a3, a4, 1, (llvm *)&v12);
  char v8 = v13;
  if (v13)
  {
    uint64_t v9 = v12;
    char v12 = 0;
  }
  else
  {
    uint64_t v9 = 0;
  }
  int v11 = v9;
  sub_1CD4515D0(&v11);
  if (v11) {
    (*(void (**)(void *))(*v11 + 8))(v11);
  }
  if ((v8 & 1) != 0 && v12) {
    (*(void (**)(void *))(*v12 + 8))(v12);
  }
  return a1;
}

uint64_t llvm::APFloat::convert(uint64_t a1, void *a2, int a3, unsigned char *a4)
{
  v18[3] = *(void **)MEMORY[0x1E4F143B8];
  int v7 = *(void **)(a1 + 8);
  char v5 = (uint64_t *)(a1 + 8);
  unsigned int v6 = v7;
  if (v7 == a2)
  {
    uint64_t result = 0;
    *a4 = 0;
  }
  else if (a2 == &unk_1CFB2E344 || v6 == &unk_1CFB2E344)
  {
    uint64_t v9 = a1;
    char v13 = v5;
    if (a2 == &unk_1CFB2E344 && v6 != &unk_1CFB2E344)
    {
      llvm::detail::IEEEFloat::convert(v5, (uint64_t)&unk_1CFB2E3B0, a3, a4);
      llvm::detail::IEEEFloat::bitcastToAPInt((uint64_t)v13, (uint64_t)&v16);
      llvm::detail::DoubleAPFloat::DoubleAPFloat(v18, (uint64_t)&unk_1CFB2E344);
    }
    unsigned int v12 = llvm::detail::IEEEFloat::convert((uint64_t *)(*(void *)(a1 + 16) + 8), (uint64_t)a2, a3, a4);
    uint64_t v10 = (uint64_t)v13;
    if (*(_UNKNOWN **)(v9 + 8) == &unk_1CFB2E344) {
      uint64_t v10 = *(void *)(v9 + 16) + 8;
    }
    uint64_t v14 = &unk_1CFB2E394;
    llvm::detail::IEEEFloat::operator=((uint64_t)&v14, v10);
    sub_1CD8249E0((uint64_t)v17, (uint64_t)&v14, a2);
    sub_1CB9190C0(v13, v18);
    sub_1CB87DEE4((uint64_t *)v18);
    if ((v14[2] - 64) <= 0xFFFFFF7F && v15) {
      MEMORY[0x1D25D9CB0](v15, 0x1000C8000313F17);
    }
    return v12;
  }
  else
  {
    return llvm::detail::IEEEFloat::convert(v5, (uint64_t)a2, a3, a4);
  }
  return result;
}

void llvm::APFloat::getAllOnesValue(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  unsigned int v4 = *(_DWORD *)(a1 + 12);
  unsigned int v8 = v4;
  if (v4 > 0x40) {
    llvm::APInt::initSlowCase((llvm::APInt *)&v7);
  }
  if (v4) {
    char v5 = (const llvm::APInt *)(0xFFFFFFFFFFFFFFFFLL >> -(char)v4);
  }
  else {
    char v5 = 0;
  }
  int v7 = v5;
  unsigned int v6 = (llvm::detail::IEEEFloat *)(a2 + 8);
  if ((_UNKNOWN *)a1 == &unk_1CFB2E344) {
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v6, (uint64_t)&unk_1CFB2E344);
  }
  llvm::detail::IEEEFloat::initFromAPInt(v6, (void *)a1, &v7);
  if (v8 >= 0x41 && v7)
  {
    JUMPOUT(0x1D25D9CB0);
  }
}

uint64_t llvm::APFloat::convertToInteger(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  v15[4] = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(unsigned int *)(a2 + 8);
  char v13 = v15;
  uint64_t v14 = 0x400000000;
  sub_1CBF7C198((uint64_t)&v13, (unint64_t)(v8 + 63) >> 6, 0);
  uint64_t v9 = sub_1CB87E144(a1, (uint64_t *)v13, v14, v8, *(unsigned char *)(a2 + 12) == 0, a3, a4);
  int v12 = v8;
  llvm::APInt::initFromArray((uint64_t)&v11, (uint64_t *)v13);
  if (*(_DWORD *)(a2 + 8) >= 0x41u && *(void *)a2) {
    MEMORY[0x1D25D9CB0](*(void *)a2, 0x1000C8000313F17);
  }
  *(void *)a2 = v11;
  *(_DWORD *)(a2 + 8) = v12;
  if (v13 != v15) {
    free(v13);
  }
  return v9;
}

double llvm::APFloat::convertToDouble(llvm::APFloat *this)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *((void *)this + 1);
  if ((_UNKNOWN *)v1 == &unk_1CFB2E31C)
  {
    llvm::detail::IEEEFloat::bitcastToAPInt((uint64_t)this + 8, (uint64_t)&v20);
    if (v21 > 0x40)
    {
      double v15 = *v20;
      MEMORY[0x1D25D9CB0]();
    }
    else
    {
      return *(double *)&v20;
    }
  }
  else
  {
    if ((_UNKNOWN *)v1 == &unk_1CFB2E344)
    {
      llvm::detail::DoubleAPFloat::DoubleAPFloat(&v21, (llvm::APFloat *)((char *)this + 8));
    }
    else
    {
      uint64_t v21 = (void *)*((void *)this + 1);
      uint64_t v2 = (uint64_t *)*(unsigned int *)(v1 + 8);
      if ((v2 + 64) >= 0x80) {
        operator new[]();
      }
      char v3 = *((unsigned char *)this + 28);
      int v4 = v3 & 7;
      char v24 = v3 & 0xF;
      int v23 = *((_DWORD *)this + 6);
      BOOL v6 = (v3 & 6) != 0 && v4 != 3;
      if (v4 == 1 || v6)
      {
        uint64_t v7 = *(unsigned int *)(v1 + 8);
        if ((v7 - 64) > 0xFFFFFF7F) {
          uint64_t v2 = &v22;
        }
        uint64_t v10 = (uint64_t *)*((void *)this + 2);
        uint64_t v8 = (char *)this + 16;
        uint64_t v9 = v10;
        if ((*(_DWORD *)(*((void *)v8 - 1) + 8) - 64) >= 0xFFFFFF80) {
          uint64_t v9 = (uint64_t *)v8;
        }
        if (v7 <= 0xFFFFFFBF)
        {
          unint64_t v11 = (unint64_t)(v7 + 64) >> 6;
          do
          {
            uint64_t v12 = *v9++;
            *v2++ = v12;
            --v11;
          }
          while (v11);
        }
      }
    }
    llvm::APFloat::convert((uint64_t)&v20, &unk_1CFB2E31C, 1, &v17);
    if (v21 == &unk_1CFB2E344) {
      char v13 = (void **)(v22 + 8);
    }
    else {
      char v13 = &v21;
    }
    llvm::detail::IEEEFloat::bitcastToAPInt((uint64_t)v13, (uint64_t)&v18);
    if (v19 >= 0x41) {
      uint64_t v14 = v18;
    }
    else {
      uint64_t v14 = (double *)&v18;
    }
    double v15 = *v14;
    if (v19 >= 0x41 && v18) {
      MEMORY[0x1D25D9CB0]();
    }
    sub_1CB87DEE4((uint64_t *)&v21);
  }
  return v15;
}

float llvm::APFloat::convertToFloat(llvm::APFloat *this)
{
  v9[3] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = (llvm::APFloat *)((char *)this + 8);
  uint64_t v2 = (void *)*((void *)this + 1);
  if (v2 == &unk_1CFB2E308)
  {
    char v3 = (llvm::APFloat *)((char *)this + 8);
    return llvm::detail::IEEEFloat::convertToFloat(v3);
  }
  else
  {
    if (v2 == &unk_1CFB2E344) {
      llvm::detail::DoubleAPFloat::DoubleAPFloat(v9, v1);
    }
    else {
      llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v9, v1);
    }
    llvm::APFloat::convert((uint64_t)v8, &unk_1CFB2E308, 1, &v7);
    if ((_UNKNOWN *)v9[0] == &unk_1CFB2E344) {
      char v5 = (llvm::detail::IEEEFloat *)(v9[1] + 8);
    }
    else {
      char v5 = (llvm::detail::IEEEFloat *)v9;
    }
    float v6 = llvm::detail::IEEEFloat::convertToFloat(v5);
    sub_1CB87DEE4(v9);
    return v6;
  }
}

uint64_t sub_1CD03A810(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD **)a2;
  if (*(_UNKNOWN **)a1 == &unk_1CFB2E344 || v4 == (_DWORD *)&unk_1CFB2E344)
  {
    if (*(_UNKNOWN **)a1 == &unk_1CFB2E344 && v4 == (_DWORD *)&unk_1CFB2E344)
    {
      llvm::detail::DoubleAPFloat::operator=(a1, a2);
    }
    else if (a1 != a2)
    {
      sub_1CB87DEE4((uint64_t *)a1);
      char v7 = *(_DWORD **)a2;
      if (*(_UNKNOWN **)a2 == &unk_1CFB2E344)
      {
        llvm::detail::DoubleAPFloat::DoubleAPFloat((void *)a1, (const llvm::detail::DoubleAPFloat *)a2);
      }
      else
      {
        *(void *)a1 = v7;
        if ((v7[2] + 64) >= 0x80) {
          operator new[]();
        }
        char v8 = *(unsigned char *)(a1 + 20) & 0xF7 | *(unsigned char *)(a2 + 20) & 8;
        *(unsigned char *)(a1 + 20) = v8;
        char v9 = *(unsigned char *)(a2 + 20);
        int v10 = v9 & 7;
        *(unsigned char *)(a1 + 20) = v8 & 0xF8 | v9 & 7;
        *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
        BOOL v12 = (v9 & 6) != 0 && v10 != 3;
        if (v10 == 1 || v12)
        {
          char v13 = (void *)(a1 + 8);
          uint64_t v14 = *(unsigned int *)(*(void *)a1 + 8);
          if ((v14 - 64) <= 0xFFFFFF7F) {
            char v13 = (void *)*v13;
          }
          unsigned int v15 = *(_DWORD *)(*(void *)a2 + 8) - 64;
          unsigned int v18 = *(uint64_t **)(a2 + 8);
          char v17 = (uint64_t *)(a2 + 8);
          uint64_t v16 = v18;
          if (v15 >= 0xFFFFFF80) {
            unsigned int v19 = v17;
          }
          else {
            unsigned int v19 = v16;
          }
          if (v14 <= 0xFFFFFFBF)
          {
            unint64_t v20 = (unint64_t)(v14 + 64) >> 6;
            do
            {
              uint64_t v21 = *v19++;
              *v13++ = v21;
              --v20;
            }
            while (v20);
          }
        }
      }
    }
  }
  else
  {
    llvm::detail::IEEEFloat::operator=((void *)a1, (void *)a2);
  }
  return a1;
}

unint64_t sub_1CD03A98C(char *a1, uint64_t a2, unsigned char *a3, char *a4, char *a5, int *a6, int *a7, uint64_t *a8)
{
  uint64_t v21 = a2;
  char v13 = sub_1CC0AC730(a1, &v21, a3, (unint64_t)a4, *a5);
  uint64_t v22 = v21;
  uint64_t v14 = sub_1CC0AC9D0(a1, &v22, v13, (unint64_t)a4, *a6);
  uint64_t v23 = v22;
  unsigned int v15 = sub_1CC0AC9D0(a1, &v23, v14, (unint64_t)a4, *a7);
  uint64_t v24 = v23;
  uint64_t v16 = (char *)sub_1CBFFCBA0(a1, &v24, v15, (unint64_t)a4, *a8);
  uint64_t v17 = v24;
  if (!v24) {
    return sub_1CBAE06B8(a1, v16 - a1, *((void *)a1 + 15));
  }
  unint64_t v20 = v16;
  if (v16 != a1 && v16 != a4) {
    sub_1CBFFD1E8(a1, v16, a4);
  }
  sub_1CBFFCF68((unint64_t *)a1 + 8, a1);
  return sub_1CBFFD150((void *)a1 + 8, (unint64_t)&v20[v17 - (void)a1]);
}

void llvm::APInt::initSlowCase(llvm::APInt *this)
{
}

void llvm::APInt::initSlowCase(llvm::APInt *this, const llvm::APInt *a2)
{
}

uint64_t llvm::APInt::initFromArray(uint64_t result, uint64_t *a2)
{
  unsigned int v2 = *(_DWORD *)(result + 8);
  if (v2 > 0x40) {
    operator new[]();
  }
  uint64_t v3 = *a2;
  *(void *)uint64_t result = *a2;
  if (v2) {
    unint64_t v4 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v2;
  }
  else {
    unint64_t v4 = 0;
  }
  *(void *)uint64_t result = v4 & v3;
  return result;
}

uint64_t llvm::APInt::APInt(uint64_t a1, int a2, uint64_t *a3)
{
  *(_DWORD *)(a1 + 8) = a2;
  llvm::APInt::initFromArray(a1, a3);
  return a1;
}

{
  *(_DWORD *)(a1 + 8) = a2;
  llvm::APInt::initFromArray(a1, a3);
  return a1;
}

llvm::APInt *llvm::APInt::APInt(llvm::APInt *this, int a2, unsigned int a3, unint64_t *a4)
{
  *((_DWORD *)this + 2) = a2;
  llvm::APInt::initFromArray((uint64_t)this, (uint64_t *)a4);
  return this;
}

{
  *((_DWORD *)this + 2) = a2;
  llvm::APInt::initFromArray((uint64_t)this, (uint64_t *)a4);
  return this;
}

uint64_t llvm::APInt::APInt(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, unsigned int a5)
{
  *(_DWORD *)(a1 + 8) = a2;
  llvm::APInt::fromString(a1, a2, a3, a4, a5);
  return a1;
}

{
  *(_DWORD *)(a1 + 8) = a2;
  llvm::APInt::fromString(a1, a2, a3, a4, a5);
  return a1;
}

uint64_t llvm::APInt::fromString(uint64_t result, uint64_t a2, char *a3, uint64_t a4, unsigned int a5)
{
  float v6 = (unsigned int *)result;
  int v7 = *a3;
  BOOL v8 = v7 == 45 || v7 == 43;
  uint64_t v9 = v8;
  if (v8) {
    int v10 = a3 + 1;
  }
  else {
    int v10 = a3;
  }
  if (*(_DWORD *)(result + 8) >= 0x41u) {
    operator new[]();
  }
  *(void *)uint64_t result = 0;
  if (a5 == 16) {
    int v11 = 4;
  }
  else {
    int v11 = a5 == 2;
  }
  if (a5 == 8) {
    unsigned int v12 = 3;
  }
  else {
    unsigned int v12 = v11;
  }
  if (a4 != v9)
  {
    unint64_t v15 = a4 - v9;
    uint64_t v16 = &a3[a4];
    unsigned int v17 = a5 - 11;
    while (1)
    {
      int v18 = *v10;
      if (a5 != 16 && a5 != 36) {
        break;
      }
      unsigned int v19 = v18 - 48;
      if ((v18 - 48) >= 0xA)
      {
        if (v18 - 65 <= v17)
        {
          unsigned int v19 = v18 - 55;
        }
        else
        {
          if (v18 - 97 > v17)
          {
            unsigned int v20 = 10;
            goto LABEL_37;
          }
          unsigned int v19 = v18 - 87;
        }
      }
LABEL_41:
      if (v15 >= 2)
      {
        if (v12)
        {
          sub_1CCA66680((llvm::APInt *)v6, v12);
        }
        else
        {
          uint64_t v21 = v6[2];
          if (v21 >= 0x41)
          {
            unint64_t v25 = 0;
            unint64_t v26 = (unint64_t)(v21 + 63) >> 6;
            int v27 = *(unint64_t **)v6;
            unint64_t v28 = v26;
            do
            {
              unint64_t v29 = 0;
              if (a5)
              {
                unint64_t v30 = *v27;
                if (*v27)
                {
                  unint64_t v31 = v30 * (unint64_t)a5;
                  unint64_t v32 = (HIDWORD(v30) * (unint64_t)a5) >> 32;
                  unint64_t v33 = v30 * a5;
                  BOOL v34 = __CFADD__(v33, v25);
                  v25 += v33;
                  unint64_t v29 = (v33 < v31) + v34 + v32;
                }
              }
              *v27++ = v25;
              unint64_t v25 = v29;
              --v28;
            }
            while (v28);
            unint64_t v23 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v21;
            uint64_t v24 = (uint64_t *)(*(void *)v6 + 8 * (v26 - 1));
            uint64_t v22 = *v24;
          }
          else
          {
            uint64_t v22 = *(void *)v6 * a5;
            *(void *)float v6 = v22;
            if (v21) {
              unint64_t v23 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v21;
            }
            else {
              unint64_t v23 = 0;
            }
            uint64_t v24 = (uint64_t *)v6;
          }
          *uint64_t v24 = v22 & v23;
        }
      }
      uint64_t result = llvm::APInt::operator+=((uint64_t)v6, v19);
      if (++v10 == v16) {
        goto LABEL_20;
      }
    }
    unsigned int v19 = v18 - 48;
    unsigned int v20 = a5;
LABEL_37:
    if (v19 >= v20) {
      unsigned int v19 = -1;
    }
    goto LABEL_41;
  }
LABEL_20:
  if (v7 == 45)
  {
    unsigned int v13 = v6[2];
    if (v13 > 0x40)
    {
      llvm::APInt::flipAllBitsSlowCase((uint64_t)v6);
    }
    else
    {
      if (v13) {
        unint64_t v14 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v13;
      }
      else {
        unint64_t v14 = 0;
      }
      *(void *)float v6 = v14 & ~*(void *)v6;
    }
    return llvm::APInt::operator++((uint64_t)v6);
  }
  return result;
}

uint64_t llvm::APInt::reallocate(uint64_t this, unsigned int a2)
{
  uint64_t v3 = this;
  uint64_t v4 = *(unsigned int *)(this + 8);
  if (((unint64_t)(v4 + 63) >> 6) == (((unint64_t)a2 + 63) >> 6))
  {
    *(_DWORD *)(this + 8) = a2;
  }
  else
  {
    if (v4 >= 0x41)
    {
      this = *(void *)this;
      if (*(void *)v3) {
        this = MEMORY[0x1D25D9CB0]();
      }
    }
    *(_DWORD *)(v3 + 8) = a2;
    if (a2 >= 0x41) {
      operator new[]();
    }
  }
  return this;
}

const llvm::APInt *llvm::APInt::assignSlowCase(const llvm::APInt *this, const llvm::APInt *a2)
{
  if (this != a2)
  {
    uint64_t v3 = this;
    this = (const llvm::APInt *)llvm::APInt::reallocate((uint64_t)this, *((_DWORD *)a2 + 2));
    uint64_t v4 = *((unsigned int *)v3 + 2);
    if (v4 <= 0x40)
    {
      *(void *)uint64_t v3 = *(void *)a2;
    }
    else
    {
      char v5 = *(void **)v3;
      float v6 = *(const void **)a2;
      return (const llvm::APInt *)memcpy(v5, v6, ((unint64_t)(v4 + 63) >> 3) & 0x3FFFFFF8);
    }
  }
  return this;
}

uint64_t llvm::APInt::Profile(uint64_t result, uint64_t a2)
{
  uint64_t v3 = (void *)result;
  unsigned int v4 = *(_DWORD *)(a2 + 8);
  if (v4 >= *(_DWORD *)(a2 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)a2 + 4 * v4) = *(_DWORD *)(result + 8);
  unsigned int v5 = *(_DWORD *)(a2 + 8) + 1;
  *(_DWORD *)(a2 + 8) = v5;
  uint64_t v6 = *(unsigned int *)(result + 8);
  if (v6 > 0x40)
  {
    uint64_t v10 = 0;
    unint64_t v11 = ((unint64_t)(v6 + 63) >> 3) & 0x3FFFFFF8;
    do
    {
      uint64_t result = sub_1CC1312F4(a2, *(void *)(*v3 + v10));
      v10 += 8;
    }
    while (v11 != v10);
  }
  else
  {
    uint64_t v7 = *(void *)result;
    if (v5 >= *(_DWORD *)(a2 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(_DWORD *)(*(void *)a2 + 4 * v5) = v7;
    unsigned int v8 = *(_DWORD *)(a2 + 12);
    unsigned int v9 = *(_DWORD *)(a2 + 8) + 1;
    *(_DWORD *)(a2 + 8) = v9;
    if (v9 >= v8) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(_DWORD *)(*(void *)a2 + 4 * v9) = HIDWORD(v7);
    ++*(_DWORD *)(a2 + 8);
  }
  return result;
}

uint64_t llvm::APInt::operator++(uint64_t result)
{
  uint64_t v1 = *(unsigned int *)(result + 8);
  if (v1 >= 0x41)
  {
    uint64_t v3 = *(uint64_t **)result;
    unint64_t v4 = (unint64_t)(v1 + 63) >> 6;
    unint64_t v5 = v4 - 1;
    do
    {
      uint64_t v6 = *v3 + 1;
      *v3++ = v6;
      if (v6) {
        BOOL v7 = 1;
      }
      else {
        BOOL v7 = v5 == 0;
      }
      --v5;
    }
    while (!v7);
    *(void *)(*(void *)result + 8 * (v4 - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v1;
  }
  else
  {
    if (v1) {
      unint64_t v2 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v1;
    }
    else {
      unint64_t v2 = 0;
    }
    *(void *)uint64_t result = v2 & (*(void *)result + 1);
  }
  return result;
}

uint64_t llvm::APInt::operator--(uint64_t result)
{
  uint64_t v1 = *(unsigned int *)(result + 8);
  if (v1 >= 0x41)
  {
    uint64_t v3 = *(void **)result;
    unint64_t v4 = (unint64_t)(v1 + 63) >> 6;
    unint64_t v5 = v4 - 1;
    do
    {
      unint64_t v6 = v5;
      if ((*v3++)-- != 0) {
        break;
      }
      --v5;
    }
    while (v6);
    *(void *)(*(void *)result + 8 * (v4 - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v1;
  }
  else
  {
    if (v1) {
      unint64_t v2 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v1;
    }
    else {
      unint64_t v2 = 0;
    }
    *(void *)uint64_t result = v2 & (*(void *)result - 1);
  }
  return result;
}

uint64_t llvm::APInt::operator+=(uint64_t result, uint64_t **a2)
{
  uint64_t v2 = *(unsigned int *)(result + 8);
  if (v2 >= 0x41)
  {
    uint64_t v4 = 0;
    unint64_t v5 = *(unint64_t **)result;
    unint64_t v6 = *a2;
    unint64_t v7 = (unint64_t)(v2 + 63) >> 6;
    unint64_t v8 = v7;
    do
    {
      uint64_t v9 = *v6++;
      unint64_t v10 = v9 + *v5;
      BOOL v11 = v10 + 1 <= *v5;
      if (v4)
      {
        ++v10;
        uint64_t v4 = v11;
      }
      else
      {
        uint64_t v4 = v10 < *v5;
      }
      *v5++ = v10;
      --v8;
    }
    while (v8);
    *(void *)(*(void *)result + 8 * (v7 - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v2;
  }
  else
  {
    if (v2) {
      unint64_t v3 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v2;
    }
    else {
      unint64_t v3 = 0;
    }
    *(void *)uint64_t result = v3 & ((unint64_t)*a2 + *(void *)result);
  }
  return result;
}

unint64_t llvm::APInt::tcAdd(llvm::APInt *this, unint64_t *a2, unint64_t a3, unsigned int a4)
{
  if (a4)
  {
    uint64_t v4 = a4;
    do
    {
      uint64_t v5 = *a2++;
      unint64_t v6 = v5 + *(void *)this;
      BOOL v7 = v6 + 1 <= *(void *)this;
      if (a3)
      {
        ++v6;
        a3 = v7;
      }
      else
      {
        a3 = v6 < *(void *)this;
      }
      *(void *)this = v6;
      this = (llvm::APInt *)((char *)this + 8);
      --v4;
    }
    while (v4);
  }
  return a3;
}

uint64_t llvm::APInt::operator+=(uint64_t result, unint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(result + 8);
  if (v2 >= 0x41)
  {
    uint64_t v4 = *(unint64_t **)result;
    unint64_t v5 = (unint64_t)(v2 + 63) >> 6;
    unint64_t v6 = v5 - 1;
    do
    {
      unint64_t v7 = *v4 + a2;
      *v4++ = v7;
      BOOL v8 = v7 >= a2 || v6-- == 0;
      a2 = 1;
    }
    while (!v8);
    *(void *)(*(void *)result + 8 * (v5 - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v2;
  }
  else
  {
    if (v2) {
      unint64_t v3 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v2;
    }
    else {
      unint64_t v3 = 0;
    }
    *(void *)uint64_t result = v3 & (*(void *)result + a2);
  }
  return result;
}

BOOL llvm::APInt::tcAddPart(llvm::APInt *this, unint64_t *a2, unsigned int a3)
{
  if (!a3) {
    return 1;
  }
  BOOL v3 = __CFADD__(*(void *)this, a2);
  *(void *)this += a2;
  if (!v3) {
    return 0;
  }
  uint64_t v4 = 1;
  do
  {
    unint64_t v5 = v4;
    if (a3 == v4) {
      break;
    }
    uint64_t v6 = *((void *)this + v4++);
    *((void *)this + v5) = v6 + 1;
  }
  while (v6 == -1);
  return v5 >= a3;
}

uint64_t llvm::APInt::operator-=(uint64_t result, unint64_t **a2)
{
  uint64_t v2 = *(unsigned int *)(result + 8);
  if (v2 >= 0x41)
  {
    uint64_t v4 = 0;
    unint64_t v5 = *(unint64_t **)result;
    uint64_t v6 = *a2;
    unint64_t v7 = (unint64_t)(v2 + 63) >> 6;
    unint64_t v8 = v7;
    do
    {
      unint64_t v9 = *v6++;
      unint64_t v10 = *v5 - v9;
      BOOL v11 = *v5 < v9;
      unint64_t v12 = *v5 + ~v9;
      if (v4)
      {
        uint64_t v4 = v12 >= *v5;
      }
      else
      {
        unint64_t v12 = v10;
        uint64_t v4 = v11;
      }
      *v5++ = v12;
      --v8;
    }
    while (v8);
    *(void *)(*(void *)result + 8 * (v7 - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v2;
  }
  else
  {
    if (v2) {
      unint64_t v3 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v2;
    }
    else {
      unint64_t v3 = 0;
    }
    *(void *)uint64_t result = v3 & (*(void *)result - (void)*a2);
  }
  return result;
}

unint64_t llvm::APInt::tcSubtract(llvm::APInt *this, unint64_t *a2, unint64_t a3, unsigned int a4)
{
  if (a4)
  {
    uint64_t v4 = a4;
    do
    {
      unint64_t v5 = *a2++;
      unint64_t v6 = *(void *)this - v5;
      BOOL v7 = *(void *)this < v5;
      unint64_t v8 = *(void *)this + ~v5;
      if (a3)
      {
        a3 = v8 >= *(void *)this;
      }
      else
      {
        unint64_t v8 = v6;
        a3 = v7;
      }
      *(void *)this = v8;
      this = (llvm::APInt *)((char *)this + 8);
      --v4;
    }
    while (v4);
  }
  return a3;
}

uint64_t llvm::APInt::operator-=(uint64_t result, unint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(result + 8);
  if (v2 >= 0x41)
  {
    uint64_t v4 = *(unint64_t **)result;
    unint64_t v5 = (unint64_t)(v2 + 63) >> 6;
    unint64_t v6 = v5 - 1;
    do
    {
      BOOL v7 = *v4 >= a2 || v6-- == 0;
      *v4++ -= a2;
      a2 = 1;
    }
    while (!v7);
    *(void *)(*(void *)result + 8 * (v5 - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v2;
  }
  else
  {
    if (v2) {
      unint64_t v3 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v2;
    }
    else {
      unint64_t v3 = 0;
    }
    *(void *)uint64_t result = v3 & (*(void *)result - a2);
  }
  return result;
}

BOOL llvm::APInt::tcSubtractPart(llvm::APInt *this, unint64_t a2, unsigned int a3)
{
  if (!a3) {
    return 1;
  }
  BOOL v3 = *(void *)this >= a2;
  *(void *)this -= a2;
  if (v3) {
    return 0;
  }
  uint64_t v4 = 1;
  do
  {
    unint64_t v5 = v4;
    if (a3 == v4) {
      break;
    }
    uint64_t v6 = *((void *)this + v4);
    *((void *)this + v4++) = v6 - 1;
  }
  while (!v6);
  return v5 >= a3;
}

uint64_t llvm::APInt::operator*@<X0>(uint64_t result@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v4 = *(_DWORD *)(result + 8);
  if (v4 > 0x40) {
    operator new[]();
  }
  uint64_t v5 = *a2 * *(void *)result;
  *(_DWORD *)(a3 + 8) = v4;
  if (v4) {
    unint64_t v6 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v4;
  }
  else {
    unint64_t v6 = 0;
  }
  *(void *)a3 = v6 & v5;
  return result;
}

uint64_t llvm::APInt::tcMultiply(llvm::APInt *this, unint64_t *a2, const unint64_t *a3, const unint64_t *a4)
{
  unsigned int v4 = a4;
  BOOL v7 = this;
  *(void *)this = 0;
  if (a4 >= 2)
  {
    bzero((char *)this + 8, 8 * (a4 - 2) + 8);
LABEL_4:
    uint64_t v8 = 0;
    LODWORD(result) = 0;
    for (unsigned int i = v4; ; --i)
    {
      unint64_t v11 = v4 - (unint64_t)i;
      if (v4 >= (unint64_t)i) {
        uint64_t v12 = i;
      }
      else {
        uint64_t v12 = v4;
      }
      unint64_t v13 = a3[v8];
      if (v4 >= v4 - v8) {
        unsigned int v14 = v4 - v8;
      }
      else {
        unsigned int v14 = v4;
      }
      if (!v14) {
        goto LABEL_26;
      }
      uint64_t v15 = 0;
      unsigned int v16 = a3[v8];
      unsigned int v17 = a2;
      int v18 = v7;
      do
      {
        uint64_t v19 = 0;
        unint64_t v21 = *v17++;
        unint64_t v20 = v21;
        if (v13 && v20)
        {
          unint64_t v22 = v20 * (unint64_t)v16;
          unint64_t v23 = HIDWORD(v20);
          unint64_t v24 = v20 * (unint64_t)HIDWORD(v13);
          unint64_t v25 = HIDWORD(v24) + HIDWORD(v20) * (unint64_t)HIDWORD(v13);
          unint64_t v26 = v20 * v13;
          BOOL v27 = __CFADD__(v26, v15);
          v15 += v26;
          uint64_t v28 = v27;
          if (v26 >= v22 + (v24 << 32)) {
            uint64_t v19 = (__PAIR128__(v28, v22)
          }
                 + __PAIR128__(v25 + ((v23 * (unint64_t)v16) >> 32), v24 << 32)) >> 64;
          else {
            uint64_t v19 = ((__PAIR128__(v28, v22)
          }
                  + __PAIR128__(v25 + ((v23 * (unint64_t)v16) >> 32), v24 << 32)) >> 64)
                + 1;
        }
        uint64_t v29 = *(void *)v18 + v15;
        if (__CFADD__(v15, *(void *)v18)) {
          uint64_t v15 = v19 + 1;
        }
        else {
          uint64_t v15 = v19;
        }
        *(void *)int v18 = v29;
        int v18 = (llvm::APInt *)((char *)v18 + 8);
        --v12;
      }
      while (v12);
      if (!v15)
      {
LABEL_26:
        int v30 = 0;
        if (v4 - v8 >= v4 || !v13) {
          goto LABEL_28;
        }
        unint64_t v31 = &a2[i];
        while (!*v31++)
        {
          int v30 = 0;
          if (!--v11) {
            goto LABEL_28;
          }
        }
      }
      int v30 = 1;
LABEL_28:
      uint64_t result = v30 | result;
      ++v8;
      BOOL v7 = (llvm::APInt *)((char *)v7 + 8);
      if (v8 == v4) {
        return result;
      }
    }
  }
  if (a4) {
    goto LABEL_4;
  }
  return 0;
}

uint64_t llvm::APInt::andAssignSlowCase(uint64_t this, uint64_t **a2)
{
  uint64_t v2 = *(unsigned int *)(this + 8);
  if (v2)
  {
    BOOL v3 = *(void **)this;
    unsigned int v4 = *a2;
    unint64_t v5 = (unint64_t)(v2 + 63) >> 6;
    do
    {
      uint64_t v6 = *v4++;
      *v3++ &= v6;
      --v5;
    }
    while (v5);
  }
  return this;
}

uint64_t llvm::APInt::orAssignSlowCase(uint64_t this, uint64_t **a2)
{
  uint64_t v2 = *(unsigned int *)(this + 8);
  if (v2)
  {
    BOOL v3 = *(void **)this;
    unsigned int v4 = *a2;
    unint64_t v5 = (unint64_t)(v2 + 63) >> 6;
    do
    {
      uint64_t v6 = *v4++;
      *v3++ |= v6;
      --v5;
    }
    while (v5);
  }
  return this;
}

uint64_t llvm::APInt::operator*=(uint64_t a1, void *a2)
{
  llvm::APInt::operator*(a1, a2, (uint64_t)&v4);
  if (*(_DWORD *)(a1 + 8) >= 0x41u && *(void *)a1) {
    MEMORY[0x1D25D9CB0](*(void *)a1, 0x1000C8000313F17);
  }
  *(void *)a1 = v4;
  *(_DWORD *)(a1 + 8) = v5;
  return a1;
}

uint64_t llvm::APInt::operator*=(uint64_t result, unint64_t *a2)
{
  uint64_t v2 = *(unsigned int *)(result + 8);
  if (v2 > 0x40)
  {
    uint64_t v5 = result;
    llvm::APInt::tcMultiplyPart(*(llvm::APInt **)result, *(unint64_t **)result, a2, 0, (unint64_t)(v2 + 63) >> 6, (unint64_t)(v2 + 63) >> 6, 0);
    uint64_t result = v5;
    LODWORD(v2) = *(_DWORD *)(v5 + 8);
  }
  else
  {
    *(void *)result *= (void)a2;
  }
  unint64_t v3 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v2;
  if ((v2 - 1) >= 0x40)
  {
    if (v2)
    {
      if (v2 >= 0x41)
      {
        uint64_t v4 = (void *)(*(void *)result + 8 * ((((unint64_t)v2 + 63) >> 6) - 1));
        goto LABEL_5;
      }
    }
    else
    {
      unint64_t v3 = 0;
    }
  }
  uint64_t v4 = (void *)result;
LABEL_5:
  *v4 &= v3;
  return result;
}

uint64_t llvm::APInt::tcMultiplyPart(llvm::APInt *this, unint64_t *a2, const unint64_t *a3, uint64_t a4, unsigned int a5, unsigned int a6, int a7)
{
  if (a5 >= a6) {
    uint64_t v7 = a6;
  }
  else {
    uint64_t v7 = a5;
  }
  if (v7)
  {
    uint64_t v8 = a2;
    unint64_t v9 = this;
    do
    {
      uint64_t v10 = 0;
      unint64_t v12 = *v8++;
      unint64_t v11 = v12;
      if (a3 && v11)
      {
        unint64_t v13 = v11 * (unint64_t)a3;
        unint64_t v14 = HIDWORD(v11);
        unint64_t v15 = v11 * (unint64_t)HIDWORD(a3);
        unint64_t v16 = HIDWORD(v15) + HIDWORD(v11) * (unint64_t)HIDWORD(a3);
        unint64_t v17 = v11 * (void)a3;
        BOOL v18 = __CFADD__(v17, a4);
        a4 += v17;
        BOOL v19 = v18;
        uint64_t v10 = (__PAIR128__(v19, v13)
             + __PAIR128__(v16 + ((v14 * (unint64_t)a3) >> 32), v15 << 32)) >> 64;
        if (v17 < v13 + (v15 << 32)) {
          ++v10;
        }
      }
      if (a7)
      {
        if (__CFADD__(a4, *(void *)v9)) {
          ++v10;
        }
        a4 += *(void *)v9;
      }
      *(void *)unint64_t v9 = a4;
      unint64_t v9 = (llvm::APInt *)((char *)v9 + 8);
      a4 = v10;
      --v7;
    }
    while (v7);
  }
  else
  {
    uint64_t v10 = a4;
  }
  if (a5 < a6)
  {
    uint64_t v20 = 0;
    *((void *)this + a5) = v10;
    return v20;
  }
  if (v10) {
    return 1;
  }
  uint64_t v20 = 0;
  if (a3 && a6 < a5)
  {
    unint64_t v22 = &a2[a6];
    unint64_t v23 = a5 - (unint64_t)a6;
    while (1)
    {
      uint64_t v24 = *v22++;
      uint64_t v20 = v24;
      if (v24) {
        break;
      }
      if (!--v23) {
        return v20;
      }
    }
    return 1;
  }
  return v20;
}

BOOL llvm::APInt::equalSlowCase(const void **this, const void **a2)
{
  return memcmp(*this, *a2, (((unint64_t)*((unsigned int *)this + 2) + 63) >> 3) & 0x3FFFFFF8) == 0;
}

uint64_t llvm::APInt::compare(llvm::APInt *this, const llvm::APInt *a2)
{
  uint64_t v2 = *((unsigned int *)this + 2);
  if (v2 > 0x40)
  {
    unint64_t v4 = ((unint64_t)(v2 + 63) >> 3) & 0x3FFFFFF8;
    do
    {
      if (!v4) {
        return 0;
      }
      unint64_t v5 = *(void *)(*(void *)this - 8 + v4);
      unint64_t v6 = *(void *)(*(void *)a2 - 8 + v4);
      v4 -= 8;
    }
    while (v5 == v6);
    if (v5 > v6) {
      return 1;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  else if (*(void *)this < *(void *)a2)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    return *(void *)this > *(void *)a2;
  }
}

uint64_t llvm::APInt::tcCompare(llvm::APInt *this, const unint64_t *a2, const unint64_t *a3)
{
  uint64_t v3 = a3;
  do
  {
    if (!(v3 * 8)) {
      return 0;
    }
    unint64_t v4 = *(void *)((char *)this + v3 * 8 - 8);
    unint64_t v5 = a2[--v3];
  }
  while (v4 == v5);
  if (v4 > v5) {
    return 1;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t llvm::APInt::compareSigned(llvm::APInt *this, const llvm::APInt *a2)
{
  uint64_t v2 = *((unsigned int *)this + 2);
  if (v2 > 0x40)
  {
    uint64_t v9 = *(void *)(*(void *)this + 8 * ((v2 - 1) >> 6)) & (1 << (v2 - 1));
    unsigned int v10 = *((_DWORD *)a2 + 2);
    unsigned int v11 = v10 - 1;
    if (v10 >= 0x41) {
      unint64_t v12 = (const llvm::APInt *)(*(void *)a2 + 8 * (v11 >> 6));
    }
    else {
      unint64_t v12 = a2;
    }
    if ((v9 != 0) == ((*(void *)v12 >> v11) & 1))
    {
      unint64_t v13 = ((unint64_t)(v2 + 63) >> 3) & 0x3FFFFFF8;
      do
      {
        if (!v13) {
          return 0;
        }
        unint64_t v14 = *(void *)(*(void *)this - 8 + v13);
        unint64_t v15 = *(void *)(*(void *)a2 - 8 + v13);
        v13 -= 8;
      }
      while (v14 == v15);
      if (v14 > v15) {
        return 1;
      }
      else {
        return 0xFFFFFFFFLL;
      }
    }
    else if (v9)
    {
      return 0xFFFFFFFFLL;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    uint64_t v3 = -v2;
    uint64_t v4 = (uint64_t)(*(void *)this << v3) >> v3;
    uint64_t v5 = (uint64_t)(*(void *)a2 << v3) >> v3;
    BOOL v6 = v4 < v5;
    BOOL v7 = v4 > v5;
    if (v6) {
      return 0xFFFFFFFFLL;
    }
    else {
      return v7;
    }
  }
}

void *llvm::APInt::setBitsSlowCase(void *this, unsigned int a2, unsigned int a3)
{
  unsigned int v3 = a2 >> 6;
  uint64_t v4 = a3 >> 6;
  uint64_t v5 = -1 << a2;
  if ((a3 & 0x3F) != 0)
  {
    unint64_t v7 = 0xFFFFFFFFFFFFFFFFLL >> -(a3 & 0x3F);
    if (v4 == v3) {
      v5 &= v7;
    }
    else {
      *(void *)(*this + 8 * v4) |= v7;
    }
  }
  *(void *)(*this + 8 * v3) |= v5;
  uint64_t v6 = v3 + 1;
  if (v6 < v4)
  {
    do
      *(void *)(*this + 8 * v6++) = -1;
    while (v4 != v6);
  }
  return this;
}

uint64_t llvm::APInt::flipAllBitsSlowCase(uint64_t this)
{
  uint64_t v1 = *(unsigned int *)(this + 8);
  if (v1)
  {
    uint64_t v2 = *(void **)this;
    unint64_t v3 = (unint64_t)(v1 + 63) >> 6;
    unint64_t v4 = v3;
    do
    {
      void *v2 = ~*v2;
      ++v2;
      --v4;
    }
    while (v4);
    unint64_t v5 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v1;
    if (v1 >= 0x41) {
      this = *(void *)this + 8 * (v3 - 1);
    }
  }
  else
  {
    unint64_t v5 = 0;
  }
  *(void *)this &= v5;
  return this;
}

void **llvm::APInt::concatSlowCase@<X0>(llvm::APInt *this@<X0>, const llvm::APInt *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v4 = *((_DWORD *)a2 + 2);
  unsigned int v5 = v4 + *((_DWORD *)this + 2);
  if (v4 >= v5)
  {
    *(_DWORD *)(a3 + 8) = v4;
    if (v4 > 0x40) {
      operator new[]();
    }
    unint64_t v7 = *(void *)a2;
  }
  else
  {
    if (v5 > 0x40) {
      operator new[]();
    }
    uint64_t v6 = *(void *)a2;
    *(_DWORD *)(a3 + 8) = v5;
    unint64_t v7 = v6 & (0xFFFFFFFFFFFFFFFFLL >> -(char)v5);
  }
  *(void *)a3 = v7;

  return llvm::APInt::insertBits((void **)a3, this, v4);
}

uint64_t llvm::APInt::zextOrSelf@<X0>(uint64_t this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  unsigned int v4 = *(_DWORD *)(this + 8);
  if (v4 < a2)
  {
    if (a2 > 0x40) {
      operator new[]();
    }
    unint64_t v6 = *(void *)this;
    *(_DWORD *)(a3 + 8) = a2;
    unint64_t v5 = v6 & (0xFFFFFFFFFFFFFFFFLL >> -(char)a2);
  }
  else
  {
    *(_DWORD *)(a3 + 8) = v4;
    if (v4 > 0x40) {
      operator new[]();
    }
    unint64_t v5 = *(void *)this;
  }
  *(void *)a3 = v5;
  return this;
}

void **llvm::APInt::insertBits(void **this, const llvm::APInt *a2, unsigned int a3)
{
  unint64_t v3 = *((unsigned int *)a2 + 2);
  if (v3)
  {
    unsigned int v4 = *((_DWORD *)this + 2);
    if (v3 == v4)
    {
      return sub_1CD828004(this, (uint64_t)a2);
    }
    else if (v4 > 0x40)
    {
      char v6 = a3 & 0x3F;
      unsigned int v7 = a3 >> 6;
      unsigned int v8 = v3 - 1 + a3;
      if (a3 >> 6 == v8 >> 6)
      {
        *((void *)*this + v7) &= ~(0xFFFFFFFFFFFFFFFFLL >> -(char)v3 << v6);
        *((void *)*this + v7) |= *(void *)a2 << v6;
      }
      else
      {
        unsigned int v14 = v3 - 1;
        int v15 = *((_DWORD *)a2 + 2);
        unint64_t v16 = (uint64_t *)this;
        BOOL v18 = a2;
        if ((a3 & 0x3F) != 0)
        {
          unsigned int v9 = 0;
          unsigned int v11 = a3;
          unsigned int v10 = a2;
          do
          {
            if (*((_DWORD *)v10 + 2) >= 0x41u) {
              unsigned int v10 = (const llvm::APInt *)(*(void *)v10 + 8 * (v9 >> 6));
            }
            this = (void **)sub_1CD6BFBEC(v16, v11 + v9, (*(void *)v10 >> v9) & 1);
            unsigned int v11 = a3;
            unsigned int v10 = v18;
            ++v9;
          }
          while (v15 != v9);
        }
        else
        {
          unint64_t v12 = (char *)*this + 8 * v7;
          if (v3 >= 0x41) {
            a2 = *(const llvm::APInt **)a2;
          }
          this = (void **)memcpy(v12, a2, (v3 >> 3) & 0x1FFFFFF8);
          if ((v15 & 0x3F) != 0)
          {
            *(void *)(*v16 + 8 * (v8 >> 6)) &= ~(0xFFFFFFFFFFFFFFFFLL >> -(v15 & 0x3F));
            if (*((_DWORD *)v18 + 2) >= 0x41u) {
              unint64_t v13 = (const llvm::APInt *)(*(void *)v18 + 8 * (v14 >> 6));
            }
            else {
              unint64_t v13 = v18;
            }
            *(void *)(*v16 + 8 * (v8 >> 6)) |= *(void *)v13;
          }
        }
      }
    }
    else
    {
      unint64_t v5 = (unint64_t)*this & ~(0xFFFFFFFFFFFFFFFFLL >> -(char)v3 << a3);
      *this = (void *)v5;
      *this = (void *)((*(void *)a2 << a3) | v5);
    }
  }
  return this;
}

uint64_t *llvm::APInt::flipBit(llvm::APInt *this, unsigned int a2)
{
  uint64_t v2 = this;
  if (*((_DWORD *)this + 2) >= 0x41u) {
    uint64_t v2 = (llvm::APInt *)(*(void *)this + 8 * (a2 >> 6));
  }
  return sub_1CD6BFBEC((uint64_t *)this, a2, ((*(void *)v2 >> a2) & 1) == 0);
}

uint64_t llvm::APInt::insertBits(uint64_t this, uint64_t a2, unsigned int a3, int a4)
{
  unint64_t v4 = 0xFFFFFFFFFFFFFFFFLL >> -(char)a4;
  unsigned int v5 = a3 >> 6;
  if (a4 && v5 == (a3 + a4 - 1) >> 6)
  {
    unint64_t v6 = v4 & a2;
    if (*(_DWORD *)(this + 8) > 0x40u)
    {
      *(void *)(*(void *)this + 8 * v5) &= ~(v4 << a3);
      *(void *)(*(void *)this + 8 * v5) |= v6 << a3;
      return this;
    }
    unint64_t v10 = *(void *)this & ~(v4 << a3);
    unint64_t v11 = v6 << a3;
    goto LABEL_12;
  }
  if (a4) {
    unint64_t v7 = 0xFFFFFFFFFFFFFFFFLL >> -(char)a4;
  }
  else {
    unint64_t v7 = 0;
  }
  unint64_t v8 = v7 & a2;
  if (*(_DWORD *)(this + 8) <= 0x40u)
  {
    unint64_t v10 = *(void *)this & ~(v7 << a3);
    unint64_t v11 = v8 << a3;
LABEL_12:
    *(void *)this = v10 | v11;
    return this;
  }
  unsigned int v9 = a3 + a4 - 1;
  *(void *)(*(void *)this + 8 * v5) &= ~(v7 << a3);
  *(void *)(*(void *)this + 8 * v5) |= v8 << a3;
  if (v5 != v9 >> 6)
  {
    unsigned int v12 = v9 >> 6;
    int v13 = -(a3 & 0x3F);
    *(void *)(*(void *)this + 8 * v12) &= ~(v7 >> v13);
    *(void *)(*(void *)this + 8 * v12) |= v8 >> v13;
  }
  return this;
}

uint64_t llvm::APInt::extractBits@<X0>(uint64_t this@<X0>, unsigned int a2@<W1>, unsigned int a3@<W2>, uint64_t a4@<X8>)
{
  if (*(_DWORD *)(this + 8) > 0x40u)
  {
    uint64_t v8 = this;
    char v9 = a3 & 0x3F;
    uint64_t v10 = a3 >> 6;
    if ((a2 + a3 - 1) >> 6 == a3 >> 6)
    {
      uint64_t v11 = *(void *)(*(void *)this + 8 * v10) >> v9;
      return sub_1CB8F1EEC(a4, a2, v11);
    }
    else if ((a3 & 0x3F) != 0)
    {
      this = sub_1CB8F1EEC((uint64_t)&__src, a2, 0);
      unsigned int v12 = v23;
      unint64_t v13 = (unint64_t)__src;
      if (v23 >= 0x41) {
        p_src = (uint64_t *)__src;
      }
      else {
        p_src = (uint64_t *)&__src;
      }
      if (v23)
      {
        unint64_t v15 = ((unint64_t)v23 + 63) >> 6;
        unint64_t v16 = ((unint64_t)*(unsigned int *)(v8 + 8) + 63) >> 6;
        unint64_t v17 = v15;
        do
        {
          uint64_t v18 = *(void *)v8;
          if (v10 + 1 >= v16) {
            uint64_t v19 = 0;
          }
          else {
            uint64_t v19 = *(void *)(v18 + 8 * v10 + 8);
          }
          *p_src++ = (v19 << (64 - v9)) | (*(void *)(v18 + 8 * v10++) >> v9);
          --v17;
        }
        while (v17);
        unint64_t v20 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v12;
        if (v12 > 0x40)
        {
          *((void *)__src + (v15 - 1)) &= v20;
          *(_DWORD *)(a4 + 8) = v12;
          operator new[]();
        }
        unint64_t v13 = (unint64_t)__src;
      }
      else
      {
        unint64_t v20 = 0;
      }
      *(_DWORD *)(a4 + 8) = v12;
      *(void *)a4 = v13 & v20;
    }
    else
    {
      unint64_t v21 = (uint64_t *)(*(void *)this + 8 * v10);
      *(_DWORD *)(a4 + 8) = a2;
      return llvm::APInt::initFromArray(a4, v21);
    }
  }
  else
  {
    uint64_t v6 = *(void *)this >> a3;
    *(_DWORD *)(a4 + 8) = a2;
    if (a2 > 0x40) {
      operator new[]();
    }
    unint64_t v7 = 0xFFFFFFFFFFFFFFFFLL >> -(char)a2;
    if (!a2) {
      unint64_t v7 = 0;
    }
    *(void *)a4 = v7 & v6;
  }
  return this;
}

unint64_t llvm::APInt::extractBitsAsZExtValue(llvm::APInt *this, int a2, unsigned int a3)
{
  if (*((_DWORD *)this + 2) <= 0x40u)
  {
    uint64_t v4 = *(void *)this >> a3;
  }
  else
  {
    unsigned int v3 = a2 + a3 - 1;
    uint64_t v4 = *(void *)(*(void *)this + 8 * (a3 >> 6)) >> a3;
    if (a3 >> 6 != v3 >> 6) {
      v4 |= *(void *)(*(void *)this + 8 * (v3 >> 6)) << -(a3 & 0x3F);
    }
  }
  unint64_t v5 = 0xFFFFFFFFFFFFFFFFLL >> -(char)a2;
  if (!a2) {
    unint64_t v5 = 0;
  }
  return v4 & v5;
}

uint64_t llvm::APInt::getBitsNeeded(unsigned __int8 *a1, uint64_t a2, unsigned int a3)
{
  uint64_t SufficientBitsNeeded = llvm::APInt::getSufficientBitsNeeded(a1, a2, a3);
  uint64_t v8 = SufficientBitsNeeded;
  if (a3 <= 0x10 && ((1 << a3) & 0x10104) != 0) {
    return v8;
  }
  int v10 = *a1;
  BOOL v11 = v10 == 43 || v10 == 45;
  unsigned int v28 = SufficientBitsNeeded;
  llvm::APInt::fromString((uint64_t)&v27, v7, (char *)&a1[v11], a2 - v11, a3);
  if (v28 > 0x40)
  {
    int v14 = 0;
    int64_t v15 = ((unint64_t)v28 + 63) >> 6;
    int8x8_t v12 = (int8x8_t)v27;
    do
    {
      if (v15-- < 1) {
        break;
      }
      unint64_t v17 = *(void *)(v27 + 8 * v15);
      v14 += __clz(v17);
    }
    while (!v17);
    unsigned int v18 = v28 | 0xFFFFFFC0;
    if ((v28 & 0x3F) == 0) {
      unsigned int v18 = 0;
    }
    int v13 = v14 + v18;
  }
  else
  {
    int8x8_t v12 = (int8x8_t)v27;
    int v13 = v28 + __clz(v27) - 64;
  }
  unsigned int v19 = v28 + ~v13;
  if (v19 != -1)
  {
    if (v10 != 45)
    {
      int v21 = 1;
      goto LABEL_24;
    }
    if (v28 >= 0x41)
    {
      int v22 = 0;
      unint64_t v23 = ((unint64_t)v28 + 63) >> 6;
      uint64_t v24 = (int8x8_t *)v12;
      do
      {
        int8x8_t v25 = *v24++;
        uint8x8_t v26 = (uint8x8_t)vcnt_s8(v25);
        v26.i16[0] = vaddlv_u8(v26);
        v22 += v26.i32[0];
        --v23;
      }
      while (v23);
      if (v22 != 1) {
        goto LABEL_19;
      }
    }
    else
    {
      uint8x8_t v20 = (uint8x8_t)vcnt_s8(v12);
      v20.i16[0] = vaddlv_u8(v20);
      if (v20.u32[0] != 1)
      {
LABEL_19:
        int v21 = 2;
LABEL_24:
        uint64_t v8 = v21 + v19;
        goto LABEL_29;
      }
    }
    uint64_t v8 = v19 + (v10 == 45);
    goto LABEL_29;
  }
  if (v10 == 45) {
    uint64_t v8 = 2;
  }
  else {
    uint64_t v8 = 1;
  }
LABEL_29:
  if (v28 >= 0x41 && *(void *)&v12) {
    MEMORY[0x1D25D9CB0](*(void *)&v12, 0x1000C8000313F17);
  }
  return v8;
}

unint64_t llvm::hash_value(llvm *this, const llvm::APInt *a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *((unsigned int *)this + 2);
  if (v3 > 0x40)
  {
    unint64_t v6 = sub_1CC36B4D0(*(void **)this, *(void *)this + (((unint64_t)(v3 + 63) >> 3) & 0x3FFFFFF8));
    uint64_t v20 = 0;
    long long v18 = 0u;
    long long v19 = 0u;
    long long v16 = 0u;
    long long v17 = 0u;
    long long v14 = 0u;
    long long v15 = 0u;
    long long v13 = 0u;
    uint64_t v7 = &unk_1EBCBE000;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
    {
      unint64_t v12 = v6;
      int v9 = __cxa_guard_acquire(&qword_1EBCBE588);
      uint64_t v7 = &unk_1EBCBE000;
      int v10 = v9;
      unint64_t v6 = v12;
      if (v10)
      {
        unint64_t v11 = llvm::hashing::detail::fixed_seed_override;
        if (!llvm::hashing::detail::fixed_seed_override) {
          unint64_t v11 = 0xFF51AFD7ED558CCDLL;
        }
        qword_1EBCBE580 = v11;
        __cxa_guard_release(&qword_1EBCBE588);
        uint64_t v7 = (void *)&unk_1EBCBE000;
        unint64_t v6 = v12;
      }
    }
    unint64_t v4 = v7[176];
    uint64_t v21 = v4;
    LODWORD(v13) = *((_DWORD *)this + 2);
    *(void *)((char *)&v13 + 4) = v6;
  }
  else
  {
    uint64_t v20 = 0;
    long long v18 = 0u;
    long long v19 = 0u;
    long long v16 = 0u;
    long long v17 = 0u;
    long long v14 = 0u;
    long long v15 = 0u;
    long long v13 = 0u;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EBCBE588))
    {
      unint64_t v8 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v8 = 0xFF51AFD7ED558CCDLL;
      }
      qword_1EBCBE580 = v8;
      __cxa_guard_release(&qword_1EBCBE588);
    }
    unint64_t v4 = qword_1EBCBE580;
    uint64_t v21 = qword_1EBCBE580;
    LODWORD(v13) = *((_DWORD *)this + 2);
    *(void *)((char *)&v13 + 4) = *(void *)this;
  }
  return sub_1CBAE06B8(&v13, 0xCuLL, v4);
}

unint64_t llvm::DenseMapInfo<llvm::APInt,void>::getHashValue(llvm *a1, const llvm::APInt *a2)
{
  return llvm::hash_value(a1, a2);
}

uint64_t llvm::APInt::rotl@<X0>(llvm::APInt *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  unsigned int v5 = *((_DWORD *)this + 2);
  if (v5 && (unsigned int v6 = a2 % v5) != 0)
  {
    unsigned int v17 = *((_DWORD *)this + 2);
    if (v5 > 0x40) {
      operator new[]();
    }
    uint64_t v16 = *(void *)this;
    sub_1CCA66680((llvm::APInt *)&v16, v6);
    uint64_t result = sub_1CB8F02F4((uint64_t)this, *((_DWORD *)this + 2) - v6, (uint64_t)&v14);
    unsigned int v8 = v15;
    if (v15 > 0x40)
    {
      int v10 = (void *)v14;
      unint64_t v11 = (uint64_t *)v16;
      unint64_t v12 = ((unint64_t)v15 + 63) >> 6;
      do
      {
        uint64_t v13 = *v11++;
        *v10++ |= v13;
        --v12;
      }
      while (v12);
      uint64_t v9 = v14;
    }
    else
    {
      uint64_t v9 = v14 | v16;
    }
    *(_DWORD *)(a3 + 8) = v8;
    *(void *)a3 = v9;
    if (v17 >= 0x41)
    {
      uint64_t result = v16;
      if (v16) {
        return MEMORY[0x1D25D9CB0](v16, 0x1000C8000313F17);
      }
    }
  }
  else
  {
    return sub_1CD0463BC(a3, (uint64_t)this);
  }
  return result;
}

uint64_t llvm::APInt::getHiBits@<X0>(llvm::APInt *this@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  return sub_1CB8F02F4((uint64_t)this, *((_DWORD *)this + 2) - a2, a3);
}

void *llvm::APInt::getLoBits@<X0>(void *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v3 = this;
  unsigned int v5 = *((_DWORD *)this + 2);
  *(_DWORD *)(a3 + 8) = v5;
  if (v5 >= 0x41) {
    operator new[]();
  }
  unint64_t v6 = 0;
  *(void *)a3 = 0;
  if (a2)
  {
    if (a2 > 0x40) {
      this = llvm::APInt::setBitsSlowCase((void *)a3, 0, a2);
    }
    else {
      unint64_t v6 = 0xFFFFFFFFFFFFFFFFLL >> -(char)a2;
    }
  }
  *(void *)a3 = *v3 & v6;
  return this;
}

uint64_t llvm::APInt::countLeadingZerosSlowCase(llvm::APInt *this)
{
  int v1 = 0;
  uint64_t v2 = *((unsigned int *)this + 2);
  int64_t v3 = (unint64_t)(v2 + 63) >> 6;
  do
  {
    if (v3-- < 1) {
      break;
    }
    unint64_t v5 = *(void *)(*(void *)this + 8 * v3);
    v1 += __clz(v5);
  }
  while (!v5);
  if ((v2 & 0x3F) != 0) {
    int v6 = v2 | 0xFFFFFFC0;
  }
  else {
    int v6 = 0;
  }
  return (v1 + v6);
}

unint64_t llvm::APInt::countLeadingOnesSlowCase(llvm::APInt *this)
{
  uint64_t v1 = *((unsigned int *)this + 2);
  char v2 = 64 - (v1 & 0x3F);
  LODWORD(v3) = *((_DWORD *)this + 2) & 0x3F;
  if ((v1 & 0x3F) != 0) {
    uint64_t v3 = v3;
  }
  else {
    uint64_t v3 = 64;
  }
  if ((v1 & 0x3F) == 0) {
    char v2 = 0;
  }
  unint64_t v4 = v1 + 63;
  unint64_t v5 = ((unint64_t)(v1 + 63) >> 3) & 0x3FFFFFF8;
  uint64_t v6 = *(void *)this;
  unint64_t result = __clz(~(*(void *)(v5 + *(void *)this - 8) << v2));
  if (v3 == result)
  {
    unint64_t v8 = v4 >> 6;
    if (v8 < 2)
    {
      return v3;
    }
    else
    {
      unint64_t result = (v3 + (v8 << 6) - 64);
      int v9 = v8 - 1;
      while (1)
      {
        uint64_t v10 = *(void *)(v6 + 8 * --v9);
        if (v10 != -1) {
          break;
        }
        LODWORD(v3) = v3 + 64;
        if (v9 <= 0) {
          return result;
        }
      }
      return __clz(~v10) + v3;
    }
  }
  return result;
}

uint64_t llvm::APInt::countTrailingZerosSlowCase(unint64_t **this)
{
  uint64_t v1 = *((unsigned int *)this + 2);
  unint64_t v2 = (unint64_t)(v1 + 63) >> 6;
  if (v2)
  {
    uint64_t v3 = 0;
    unint64_t v4 = *this;
    unsigned int v5 = v2 << 6;
    unint64_t v6 = v2 << 6;
    while (!*v4)
    {
      ++v4;
      v3 += 64;
      if (v6 == v3) {
        goto LABEL_5;
      }
    }
    unsigned int v5 = __clz(__rbit64(*v4)) + v3;
  }
  else
  {
    unsigned int v5 = 0;
  }
LABEL_5:
  if (v1 >= v5) {
    return v5;
  }
  else {
    return v1;
  }
}

uint64_t llvm::APInt::countTrailingOnesSlowCase(llvm::APInt *this)
{
  unint64_t v1 = ((unint64_t)*((unsigned int *)this + 2) + 63) >> 6;
  if (!v1) {
    return 0;
  }
  uint64_t v2 = 0;
  uint64_t v3 = *(void **)this;
  uint64_t result = (v1 << 6);
  unint64_t v5 = v1 << 6;
  while (*v3 == -1)
  {
    ++v3;
    v2 += 64;
    if (v5 == v2) {
      return result;
    }
  }
  return __clz(__rbit64(~*v3)) + v2;
}

uint64_t llvm::APInt::countPopulationSlowCase(uint64_t this)
{
  uint64_t v1 = *(unsigned int *)(this + 8);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = (int8x8_t **)this;
  LODWORD(this) = 0;
  unint64_t v3 = (unint64_t)(v1 + 63) >> 6;
  unint64_t v4 = *v2;
  do
  {
    int8x8_t v5 = *v4++;
    uint8x8_t v6 = (uint8x8_t)vcnt_s8(v5);
    v6.i16[0] = vaddlv_u8(v6);
    this = (this + v6.i32[0]);
    --v3;
  }
  while (v3);
  return this;
}

BOOL llvm::APInt::intersectsSlowCase(uint64_t **this, uint64_t **a2)
{
  uint64_t v2 = *((unsigned int *)this + 2);
  if (!v2) {
    return 0;
  }
  unint64_t v3 = (unint64_t)(v2 + 63) >> 6;
  unint64_t v4 = *this;
  int8x8_t v5 = *a2;
  unint64_t v6 = v3 - 1;
  do
  {
    uint64_t v8 = *v4++;
    uint64_t v7 = v8;
    uint64_t v9 = *v5++;
    uint64_t v10 = v9 & v7;
    BOOL result = v10 != 0;
    if (v10) {
      BOOL v12 = 1;
    }
    else {
      BOOL v12 = v6 == 0;
    }
    --v6;
  }
  while (!v12);
  return result;
}

BOOL llvm::APInt::isSubsetOfSlowCase(uint64_t **this, uint64_t **a2)
{
  uint64_t v2 = *((unsigned int *)this + 2);
  if (!v2) {
    return 1;
  }
  unint64_t v3 = (unint64_t)(v2 + 63) >> 6;
  unint64_t v4 = *this;
  int8x8_t v5 = *a2;
  unint64_t v6 = v3 - 1;
  do
  {
    uint64_t v8 = *v4++;
    uint64_t v7 = v8;
    uint64_t v9 = *v5++;
    uint64_t v10 = v7 & ~v9;
    BOOL result = v10 == 0;
    BOOL v13 = v6-- != 0;
  }
  while (!v10 && v13);
  return result;
}

void llvm::APInt::byteSwap(llvm::APInt *this@<X0>, uint64_t a2@<X8>)
{
  unsigned int v2 = *((_DWORD *)this + 2);
  if (v2 == 32)
  {
    uint64_t v3 = bswap32(*(_DWORD *)this);
    int v4 = 32;
LABEL_3:
    *(_DWORD *)(a2 + 8) = v4;
    *(void *)a2 = v3;
    return;
  }
  if (v2 == 16)
  {
    uint64_t v3 = bswap32(*(unsigned __int16 *)this) >> 16;
    int v4 = 16;
    goto LABEL_3;
  }
  if (v2 > 0x40)
  {
    sub_1CB8F1EEC(a2, (v2 + 63) & 0xFFFFFFC0, 0);
    uint64_t v6 = *((unsigned int *)this + 2);
    if (v6)
    {
      uint64_t v7 = 0;
      unint64_t v8 = ((unint64_t)(v6 + 63) >> 6) - 1;
      do
      {
        *(void *)(*(void *)a2 + v7) = bswap64(*(void *)(*(void *)this + 8 * v8--));
        v7 += 8;
      }
      while (v8 != -1);
    }
    uint64_t v9 = *(unsigned int *)(a2 + 8);
    if (v9 != v6)
    {
      unsigned int v10 = v9 - v6;
      if (v9 > 0x40)
      {
        llvm::APInt::tcShiftRight(*(llvm::APInt **)a2, (unint64_t *)((unint64_t)(v9 + 63) >> 6), v10);
        LODWORD(v6) = *((_DWORD *)this + 2);
      }
      else if (v6)
      {
        *(void *)a2 >>= v10;
      }
      else
      {
        *(void *)a2 = 0;
      }
      *(_DWORD *)(a2 + 8) = v6;
    }
  }
  else
  {
    unint64_t v5 = bswap64(*(void *)this) >> -(char)v2;
    sub_1CB8F1EEC(a2, v2, v5);
  }
}

unsigned int *llvm::APInt::reverseBits@<X0>(unsigned int *this@<X0>, llvm::APInt *a2@<X8>)
{
  uint64_t v3 = this[2];
  HIDWORD(v4) = this[2];
  LODWORD(v4) = HIDWORD(v4);
  switch((v4 >> 3))
  {
    case 0u:
      return (unsigned int *)sub_1CD0463BC((uint64_t)a2, (uint64_t)this);
    case 1u:
      uint64_t v5 = __rbit32(*(unsigned __int8 *)this) >> 24;
      goto LABEL_4;
    case 2u:
      uint64_t v5 = __rbit32(*(unsigned __int16 *)this) >> 16;
      goto LABEL_4;
    case 4u:
      uint64_t v5 = __rbit32(*this);
LABEL_4:
      *((_DWORD *)a2 + 2) = v3;
      if (v3 > 0x40) {
        operator new[]();
      }
      unint64_t v6 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v3;
      if (!v3) {
        unint64_t v6 = 0;
      }
      *(void *)a2 = v6 & v5;
      break;
    case 8u:
      uint64_t v10 = __rbit64(*(void *)this);
      this = (unsigned int *)sub_1CB8F1EEC((uint64_t)a2, v3, v10);
      break;
    default:
      if (v3 > 0x40) {
        operator new[]();
      }
      unint64_t v7 = *(void *)this;
      *((_DWORD *)a2 + 2) = v3;
      uint64_t v8 = v3 + 63;
      unsigned int v9 = v3;
      *(void *)a2 = 0;
      while (v7)
      {
        unsigned int v11 = v9;
        uint64_t v12 = v8;
        sub_1CCA66680(a2, 1u);
        sub_1CD03D6F8((uint64_t)a2, v7 & 1);
        if (v3 == 1) {
          unint64_t v7 = 0;
        }
        else {
          v7 >>= 1;
        }
        uint64_t v8 = v12;
        unsigned int v9 = v11 - 1;
      }
      this = (unsigned int *)sub_1CCA66680(a2, v9);
      break;
  }
  return this;
}

uint64_t sub_1CD03D6F8(uint64_t result, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(result + 8);
  if (v2 <= 0x40)
  {
    if (v2) {
      unint64_t v3 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v2;
    }
    else {
      unint64_t v3 = 0;
    }
    *(void *)BOOL result = v3 & (*(void *)result | a2);
  }
  else
  {
    **(void **)result |= a2;
  }
  return result;
}

void llvm::APIntOps::GreatestCommonDivisor(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v6 = (_DWORD *)(a1 + 8);
  uint64_t v7 = *(unsigned int *)(a1 + 8);
  if (v7 > 0x40)
  {
    unint64_t v8 = *(void *)a1;
    unint64_t v9 = *(void *)a2;
    if (!memcmp(*(const void **)a1, *(const void **)a2, ((unint64_t)(v7 + 63) >> 3) & 0x3FFFFFF8)) {
      goto LABEL_3;
    }
    int v28 = 0;
    int64_t v29 = (unint64_t)(v7 + 63) >> 6;
    do
    {
      BOOL v30 = v29-- < 1;
      if (v30) {
        break;
      }
      unint64_t v31 = *(void *)(v8 + 8 * v29);
      v28 += __clz(v31);
    }
    while (!v31);
    int v32 = v7 | 0xFFFFFFC0;
    if ((v7 & 0x3F) == 0) {
      int v32 = 0;
    }
    if (v28 + v32 != v7) {
      goto LABEL_6;
    }
    goto LABEL_46;
  }
  unint64_t v8 = *(void *)a1;
  unint64_t v9 = *(void *)a2;
  if (*(void *)a1 != *(void *)a2)
  {
    if (v8)
    {
LABEL_6:
      uint64_t v10 = *(unsigned int *)(a2 + 8);
      if (v10 > 0x40)
      {
        int v43 = 0;
        int64_t v44 = (unint64_t)(v10 + 63) >> 6;
        do
        {
          BOOL v30 = v44-- < 1;
          if (v30) {
            break;
          }
          unint64_t v45 = *(void *)(v9 + 8 * v44);
          v43 += __clz(v45);
        }
        while (!v45);
        int v46 = v10 | 0xFFFFFFC0;
        if ((v10 & 0x3F) == 0) {
          int v46 = 0;
        }
        if (v43 + v46 == v10) {
          goto LABEL_3;
        }
      }
      else if (!v9)
      {
        goto LABEL_3;
      }
      unsigned int v11 = sub_1CD03DB34(a1);
      unsigned int v12 = sub_1CD03DB34(a2);
      unsigned int v13 = v12;
      unsigned int v14 = v11 - v12;
      if (v11 > v12)
      {
        if (v7 > 0x40)
        {
          llvm::APInt::tcShiftRight((llvm::APInt *)v8, (unint64_t *)((unint64_t)(v7 + 63) >> 6), v14);
        }
        else if (v7 == v14)
        {
          *(void *)a1 = 0;
        }
        else
        {
          *(void *)a1 = v8 >> v14;
        }
      }
      else
      {
        unsigned int v15 = v12 - v11;
        if (v12 > v11)
        {
          if (v10 > 0x40)
          {
            llvm::APInt::tcShiftRight((llvm::APInt *)v9, (unint64_t *)((unint64_t)(v10 + 63) >> 6), v15);
          }
          else if (v10 == v15)
          {
            *(void *)a2 = 0;
          }
          else
          {
            *(void *)a2 = v9 >> v15;
          }
        }
        unsigned int v13 = v11;
      }
      while (1)
      {
        uint64_t v7 = *v6;
        if (v7 > 0x40)
        {
          unint64_t v8 = *(void *)a1;
          unint64_t v33 = v7 + 63;
          uint64_t v16 = *(char **)a2;
          if (!memcmp(*(const void **)a1, *(const void **)a2, ((unint64_t)(v7 + 63) >> 3) & 0x3FFFFFF8)) {
            goto LABEL_3;
          }
          uint64_t v34 = 8 * (v33 >> 6);
          while (v34)
          {
            unint64_t v35 = *(void *)(v8 + v34 - 8);
            unint64_t v36 = *(void *)&v16[v34 - 8];
            v34 -= 8;
            if (v35 != v36)
            {
              if (v35 <= v36) {
                break;
              }
              uint64_t v37 = 0;
              unint64_t v38 = v33 >> 6;
              do
              {
                unint64_t v39 = *(void *)v16;
                v16 += 8;
                unint64_t v40 = *(void *)v8 - v39;
                BOOL v41 = *(void *)v8 < v39;
                unint64_t v42 = *(void *)v8 + ~v39;
                if (v37)
                {
                  uint64_t v37 = v42 >= *(void *)v8;
                }
                else
                {
                  unint64_t v42 = v40;
                  uint64_t v37 = v41;
                }
                *(void *)unint64_t v8 = v42;
                v8 += 8;
                --v38;
              }
              while (v38);
              *(void *)(*(void *)a1 + 8 * ((v33 >> 6) - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v7;
              uint64_t v7 = *(unsigned int *)(a1 + 8);
              unsigned int v18 = sub_1CD03DB34(a1) - v13;
              if (v7 > 0x40)
              {
                unint64_t v27 = *(llvm::APInt **)a1;
                goto LABEL_38;
              }
              goto LABEL_29;
            }
          }
LABEL_17:
          uint64_t v7 = *(unsigned int *)(a2 + 8);
          if (v7 < 0x41)
          {
            unint64_t v17 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v7;
            if (!v7) {
              unint64_t v17 = 0;
            }
            *(void *)a2 = v17 & (unint64_t)&v16[-v8];
            unsigned int v18 = sub_1CD03DB34(a2) - v13;
            goto LABEL_21;
          }
          uint64_t v20 = 0;
          unint64_t v21 = (unint64_t)(v7 + 63) >> 6;
          unint64_t v22 = v21;
          do
          {
            unint64_t v23 = *(void *)v8;
            v8 += 8;
            unint64_t v24 = *(void *)v16 - v23;
            BOOL v25 = *(void *)v16 < v23;
            unint64_t v26 = *(void *)v16 + ~v23;
            if (v20)
            {
              uint64_t v20 = v26 >= *(void *)v16;
            }
            else
            {
              unint64_t v26 = v24;
              uint64_t v20 = v25;
            }
            *(void *)uint64_t v16 = v26;
            v16 += 8;
            --v22;
          }
          while (v22);
          *(void *)(*(void *)a2 + 8 * (v21 - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v7;
          uint64_t v7 = *(unsigned int *)(a2 + 8);
          unsigned int v18 = sub_1CD03DB34(a2) - v13;
          if (v7 <= 0x40)
          {
LABEL_21:
            if (v7 == v18) {
              *(void *)a2 = 0;
            }
            else {
              *(void *)a2 >>= v18;
            }
          }
          else
          {
            unint64_t v27 = *(llvm::APInt **)a2;
LABEL_38:
            llvm::APInt::tcShiftRight(v27, (unint64_t *)((unint64_t)(v7 + 63) >> 6), v18);
          }
        }
        else
        {
          unint64_t v8 = *(void *)a1;
          uint64_t v16 = *(char **)a2;
          if (*(void *)a1 == *(void *)a2) {
            goto LABEL_3;
          }
          if (*(void *)a1 <= *(void *)a2) {
            goto LABEL_17;
          }
          unint64_t v19 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v7;
          if (!v7) {
            unint64_t v19 = 0;
          }
          *(void *)a1 = v19 & (*(void *)a1 - *(void *)a2);
          unsigned int v18 = sub_1CD03DB34(a1) - v13;
LABEL_29:
          if (v7 == v18) {
            *(void *)a1 = 0;
          }
          else {
            *(void *)a1 >>= v18;
          }
        }
      }
    }
LABEL_46:
    *(_DWORD *)(a3 + 8) = *(_DWORD *)(a2 + 8);
    unint64_t v8 = v9;
    unint64_t v6 = (_DWORD *)(a2 + 8);
    goto LABEL_4;
  }
LABEL_3:
  *(_DWORD *)(a3 + 8) = v7;
LABEL_4:
  *(void *)a3 = v8;
  *unint64_t v6 = 0;
}

uint64_t sub_1CD03DB34(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 8);
  if (v1 >= 0x41)
  {
    uint64_t v4 = 0;
    unint64_t v5 = (unint64_t)(v1 + 63) >> 6;
    unint64_t v6 = *(unint64_t **)a1;
    unsigned int v2 = v5 << 6;
    unint64_t v7 = v5 << 6;
    while (!*v6)
    {
      ++v6;
      v4 += 64;
      if (v7 == v4) {
        goto LABEL_3;
      }
    }
    unsigned int v2 = __clz(__rbit64(*v6)) + v4;
  }
  else
  {
    unsigned int v2 = __clz(__rbit64(*(void *)a1));
  }
LABEL_3:
  if (v1 >= v2) {
    return v2;
  }
  else {
    return v1;
  }
}

uint64_t llvm::APIntOps::RoundDoubleToAPInt@<X0>(uint64_t this@<X0>, double a2@<D0>, uint64_t a3@<X8>)
{
  unsigned int v3 = this;
  unint64_t v5 = (*(void *)&a2 >> 52) & 0x7FFLL;
  if (v5 <= 0x3FE)
  {
    *(_DWORD *)(a3 + 8) = this;
    if (this <= 0x40)
    {
LABEL_3:
      *(void *)a3 = 0;
      return this;
    }
LABEL_30:
    operator new[]();
  }
  unint64_t v6 = *(void *)&a2 & 0xFFFFFFFFFFFFFLL | 0x10000000000000;
  if (v5 <= 0x432)
  {
    unint64_t v7 = v6 >> (51 - (*(void *)&a2 >> 52));
    if ((*(void *)&a2 & 0x8000000000000000) != 0)
    {
      int v19 = this;
      if (this > 0x40) {
        operator new[]();
      }
      unint64_t v14 = (0xFFFFFFFFFFFFFFFFLL >> -(char)this) & ~v7;
      if (!this) {
        unint64_t v14 = 0;
      }
      unint64_t v18 = v14;
      this = llvm::APInt::operator++((uint64_t)&v18);
      *(_DWORD *)(a3 + 8) = v19;
      unint64_t v9 = v18;
    }
    else
    {
      *(_DWORD *)(a3 + 8) = this;
      if (this > 0x40) {
        operator new[]();
      }
      unint64_t v8 = 0xFFFFFFFFFFFFFFFFLL >> -(char)this;
      if (!this) {
        unint64_t v8 = 0;
      }
      unint64_t v9 = v8 & v7;
    }
    *(void *)a3 = v9;
    return this;
  }
  if (v5 - 1075 >= this)
  {
    *(_DWORD *)(a3 + 8) = this;
    if (this <= 0x40) {
      goto LABEL_3;
    }
    goto LABEL_30;
  }
  if (this > 0x40) {
    operator new[]();
  }
  if (this)
  {
    unint64_t v10 = 0xFFFFFFFFFFFFFFFFLL >> -(char)this;
    int v11 = v5 - 1075;
    if (v11 == this) {
      unint64_t v12 = 0;
    }
    else {
      unint64_t v12 = (v10 & v6) << v11;
    }
    unint64_t v13 = v12 & v10;
    if ((*(void *)&a2 & 0x8000000000000000) == 0) {
      goto LABEL_17;
    }
    int v17 = this;
    unint64_t v15 = v13 ^ v10;
  }
  else
  {
    unint64_t v13 = 0;
    if ((*(void *)&a2 & 0x8000000000000000) == 0)
    {
LABEL_17:
      *(_DWORD *)(a3 + 8) = this;
      *(void *)a3 = v13;
      return this;
    }
    unint64_t v15 = 0;
    int v17 = 0;
  }
  unint64_t v16 = v15;
  this = llvm::APInt::operator++((uint64_t)&v16);
  *(_DWORD *)(a3 + 8) = v17;
  *(void *)a3 = v16;
  int v17 = 0;
  if (v3 >= 0x41 && v13) {
    return MEMORY[0x1D25D9CB0](v13, 0x1000C8000313F17);
  }
  return this;
}

double llvm::APInt::roundToDouble(llvm::APInt *this, int a2)
{
  unsigned int v2 = (unint64_t *)this;
  uint64_t v3 = *((unsigned int *)this + 2);
  if (v3 >= 0x41)
  {
    int v5 = 0;
    int64_t v6 = (unint64_t)(v3 + 63) >> 6;
    do
    {
      if (v6-- < 1) {
        break;
      }
      unint64_t v8 = *(void *)(*(void *)this + 8 * v6);
      v5 += __clz(v8);
    }
    while (!v8);
    int v9 = v3 | 0xFFFFFFC0;
    if ((v3 & 0x3F) == 0) {
      int v9 = 0;
    }
    if ((v3 - v5 - v9) > 0x40)
    {
      if (a2
        && ((*(void *)(*(void *)this + 8 * ((v3 - 1) >> 6)) >> (v3 - 1)) & 1) != 0)
      {
        operator new[]();
      }
      operator new[]();
    }
    unsigned int v2 = *(unint64_t **)this;
    if (a2) {
      return (double)((uint64_t)(*v2 << -(char)v3) >> -(char)v3);
    }
    return (double)*v2;
  }
  if (!a2) {
    return (double)*v2;
  }
  return (double)((uint64_t)(*v2 << -(char)v3) >> -(char)v3);
}

uint64_t llvm::APInt::trunc@<X0>(uint64_t this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  unsigned int v3 = *(_DWORD *)(this + 8);
  if (a2 > 0x40)
  {
    if (v3 != a2) {
      operator new[]();
    }
    return sub_1CD0463BC(a3, this);
  }
  else
  {
    if (v3 >= 0x41) {
      this = *(void *)this;
    }
    uint64_t v4 = *(void *)this;
    *(_DWORD *)(a3 + 8) = a2;
    unint64_t v5 = 0xFFFFFFFFFFFFFFFFLL >> -(char)a2;
    if (!a2) {
      unint64_t v5 = 0;
    }
    *(void *)a3 = v5 & v4;
  }
  return this;
}

uint64_t llvm::APInt::truncUSat@<X0>(uint64_t this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v4 = *(unsigned int *)(this + 8);
  if (v4 > 0x40)
  {
    int v9 = 0;
    int64_t v10 = (unint64_t)(v4 + 63) >> 6;
    do
    {
      if (v10-- < 1) {
        break;
      }
      unint64_t v12 = *(void *)(*(void *)this + 8 * v10);
      v9 += __clz(v12);
    }
    while (!v12);
    int v13 = v4 | 0xFFFFFFC0;
    if ((v4 & 0x3F) == 0) {
      int v13 = 0;
    }
    int v5 = v9 + v13;
  }
  else
  {
    int v5 = v4 + __clz(*(void *)this) - 64;
  }
  if ((int)v4 - v5 <= a2)
  {
    if (a2 > 0x40)
    {
      if (v4 != a2) {
        operator new[]();
      }
      *(_DWORD *)(a3 + 8) = a2;
      operator new[]();
    }
    if (v4 >= 0x41) {
      this = *(void *)this;
    }
    unint64_t v7 = *(void *)this;
    *(_DWORD *)(a3 + 8) = a2;
    unint64_t v8 = 0xFFFFFFFFFFFFFFFFLL >> -(char)a2;
    if (!a2) {
      unint64_t v8 = 0;
    }
    unint64_t v6 = v8 & v7;
  }
  else
  {
    *(_DWORD *)(a3 + 8) = a2;
    if (a2 > 0x40) {
      operator new[]();
    }
    unint64_t v6 = 0xFFFFFFFFFFFFFFFFLL >> -(char)a2;
    if (!a2) {
      unint64_t v6 = 0;
    }
  }
  *(void *)a3 = v6;
  return this;
}

unint64_t llvm::APInt::truncSSat@<X0>(llvm::APInt *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v4 = this;
  int v6 = *((_DWORD *)this + 2);
  unint64_t result = sub_1CBAB1CB8(this);
  if (v6 - (int)result + 1 <= a2)
  {
    unsigned int v11 = *((_DWORD *)v4 + 2);
    if (a2 > 0x40)
    {
      if (v11 != a2) {
        operator new[]();
      }
      *(_DWORD *)(a3 + 8) = a2;
      operator new[]();
    }
    if (v11 >= 0x41) {
      uint64_t v4 = *(llvm::APInt **)v4;
    }
    unint64_t v12 = *(llvm::APInt **)v4;
    *(_DWORD *)(a3 + 8) = a2;
    unint64_t v13 = 0xFFFFFFFFFFFFFFFFLL >> -(char)a2;
    if (!a2) {
      unint64_t v13 = 0;
    }
    uint64_t v10 = v13 & (unint64_t)v12;
  }
  else
  {
    unsigned int v8 = *((_DWORD *)v4 + 2);
    unsigned int v9 = v8 - 1;
    if (v8 >= 0x41) {
      uint64_t v4 = (llvm::APInt *)(*(void *)v4 + 8 * (v9 >> 6));
    }
    if ((*(void *)v4 >> v9))
    {
      *(_DWORD *)(a3 + 8) = a2;
      if (a2 > 0x40) {
        operator new[]();
      }
      uint64_t v10 = 1 << (a2 - 1);
    }
    else
    {
      *(_DWORD *)(a3 + 8) = a2;
      if (a2 > 0x40) {
        operator new[]();
      }
      char v14 = (a2 - 1) & 0x3F;
      unint64_t v15 = 0xFFFFFFFFFFFFFFFFLL >> (v14 ^ 0x3Fu);
      if (!a2) {
        unint64_t v15 = 0;
      }
      uint64_t v10 = v15 & ~(1 << v14);
    }
  }
  *(void *)a3 = v10;
  return result;
}

uint64_t llvm::APInt::sext@<X0>(uint64_t this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  if (a2 > 0x40)
  {
    if (*(_DWORD *)(this + 8) != a2) {
      operator new[]();
    }
    return sub_1CD0463BC(a3, this);
  }
  else
  {
    uint64_t v4 = (uint64_t)(*(void *)this << -*(unsigned char *)(this + 8)) >> -*(unsigned char *)(this + 8);
    *(_DWORD *)(a3 + 8) = a2;
    unint64_t v5 = 0xFFFFFFFFFFFFFFFFLL >> -(char)a2;
    if (!a2) {
      unint64_t v5 = 0;
    }
    *(void *)a3 = v5 & v4;
  }
  return this;
}

uint64_t *llvm::APInt::zext@<X0>(uint64_t *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  if (a2 > 0x40)
  {
    if (*((_DWORD *)this + 2) != a2) {
      operator new[]();
    }
    return (uint64_t *)sub_1CD0463BC(a3, (uint64_t)this);
  }
  else
  {
    uint64_t v4 = *this;
    *(_DWORD *)(a3 + 8) = a2;
    unint64_t v5 = 0xFFFFFFFFFFFFFFFFLL >> -(char)a2;
    if (!a2) {
      unint64_t v5 = 0;
    }
    *(void *)a3 = v5 & v4;
  }
  return this;
}

uint64_t *llvm::APInt::zextOrTrunc@<X0>(uint64_t *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  unsigned int v3 = this;
  unsigned int v5 = *((_DWORD *)this + 2);
  if (v5 >= a2)
  {
    if (v5 > a2)
    {
      if (a2 > 0x40) {
        operator new[]();
      }
      if (v5 >= 0x41) {
        unsigned int v3 = (uint64_t *)*this;
      }
      uint64_t v8 = *v3;
      *(_DWORD *)(a3 + 8) = a2;
      unint64_t v9 = 0xFFFFFFFFFFFFFFFFLL >> -(char)a2;
      if (!a2) {
        unint64_t v9 = 0;
      }
      unint64_t v7 = v9 & v8;
    }
    else
    {
      *(_DWORD *)(a3 + 8) = v5;
      if (v5 > 0x40) {
        operator new[]();
      }
      unint64_t v7 = *this;
    }
  }
  else
  {
    if (a2 > 0x40) {
      operator new[]();
    }
    uint64_t v6 = *this;
    *(_DWORD *)(a3 + 8) = a2;
    unint64_t v7 = v6 & (0xFFFFFFFFFFFFFFFFLL >> -(char)a2);
  }
  *(void *)a3 = v7;
  return this;
}

uint64_t llvm::APInt::sextOrTrunc@<X0>(uint64_t this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  unsigned int v3 = *(_DWORD *)(this + 8);
  if (v3 < a2)
  {
    return llvm::APInt::sext(this, a2, a3);
  }
  else
  {
    if (v3 > a2)
    {
      if (a2 > 0x40) {
        operator new[]();
      }
      if (v3 >= 0x41) {
        this = *(void *)this;
      }
      uint64_t v5 = *(void *)this;
      *(_DWORD *)(a3 + 8) = a2;
      unint64_t v6 = 0xFFFFFFFFFFFFFFFFLL >> -(char)a2;
      if (!a2) {
        unint64_t v6 = 0;
      }
      uint64_t v4 = v6 & v5;
    }
    else
    {
      *(_DWORD *)(a3 + 8) = v3;
      if (v3 > 0x40) {
        operator new[]();
      }
      uint64_t v4 = *(void *)this;
    }
    *(void *)a3 = v4;
  }
  return this;
}

uint64_t llvm::APInt::sextOrSelf@<X0>(uint64_t this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  unsigned int v3 = *(_DWORD *)(this + 8);
  if (v3 < a2)
  {
    return llvm::APInt::sext(this, a2, a3);
  }
  else
  {
    *(_DWORD *)(a3 + 8) = v3;
    if (v3 > 0x40) {
      operator new[]();
    }
    *(void *)a3 = *(void *)this;
  }
  return this;
}

unsigned int *llvm::APInt::ashrInPlace(unsigned int *this, const llvm::APInt *a2)
{
  unint64_t v2 = this[2];
  uint64_t v3 = *((unsigned int *)a2 + 2);
  if (v3 < 0x41)
  {
    uint64_t v4 = *(void **)a2;
    goto LABEL_3;
  }
  int v9 = 0;
  int64_t v10 = (unint64_t)(v3 + 63) >> 6;
  unsigned int v11 = *(void **)a2;
  do
  {
    if (v10-- < 1) {
      break;
    }
    unint64_t v13 = v11[v10];
    v9 += __clz(v13);
  }
  while (!v13);
  int v14 = v3 | 0xFFFFFFC0;
  if ((v3 & 0x3F) == 0) {
    int v14 = 0;
  }
  unsigned int v5 = this[2];
  if ((v3 - v9 - v14) <= 0x40)
  {
    uint64_t v4 = (void *)*v11;
LABEL_3:
    unsigned int v5 = this[2];
    if ((unint64_t)v4 <= v2) {
      unsigned int v5 = v4;
    }
  }
  if (v2 > 0x40) {
    return llvm::APInt::ashrSlowCase(this, v5);
  }
  char v6 = v5;
  if (v2 == v5) {
    char v6 = 63;
  }
  uint64_t v7 = (uint64_t)(*(void *)this << -(char)v2) >> -(char)v2 >> v6;
  if (v2) {
    unint64_t v8 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v2;
  }
  else {
    unint64_t v8 = 0;
  }
  *(void *)this = v8 & v7;
  return this;
}

unsigned int *llvm::APInt::ashrSlowCase(unsigned int *this, unsigned int a2)
{
  if (a2)
  {
    unint64_t v2 = this;
    uint64_t v3 = this[2];
    unsigned int v4 = v3 - 1;
    unsigned int v5 = this;
    if (v3 >= 0x41) {
      unsigned int v5 = (void *)(*(void *)this + 8 * (v4 >> 6));
    }
    uint64_t v6 = *v5 & (1 << v4);
    unsigned int v7 = a2 >> 6;
    unint64_t v8 = (unint64_t)(v3 + 63) >> 6;
    unsigned int v9 = v8 - (a2 >> 6);
    if (v8 != a2 >> 6)
    {
      uint64_t v10 = (v8 - 1);
      *(void *)(*(void *)this + 8 * v10) = (uint64_t)(*(void *)(*(void *)this
                                                                                   + 8 * v10) << -(char)v3) >> -(char)v3;
      char v11 = a2 & 0x3F;
      if ((a2 & 0x3F) != 0)
      {
        uint64_t v12 = v9 - 1;
        if (v9 == 1)
        {
          uint64_t v12 = 0;
        }
        else
        {
          uint64_t v13 = 0;
          do
          {
            *(void *)(*(void *)this + 8 * v13) = (*(void *)(*(void *)this
                                                                + 8 * ((a2 >> 6) + v13 + 1)) << (64 - v11)) | (*(void *)(*(void *)this + 8 * ((a2 >> 6) + v13)) >> v11);
            ++v13;
          }
          while (v12 != v13);
        }
        *(void *)(*(void *)this + 8 * v12) = *(void *)(*(void *)this + 8 * v10) >> v11;
        *(void *)(*(void *)this + 8 * v12) = (uint64_t)(*(void *)(*(void *)this + 8 * v12) << v11) >> v11;
      }
      else
      {
        uint64_t v19 = v6;
        unsigned int v17 = a2 >> 6;
        unsigned int v18 = v9;
        memmove(*(void **)this, (const void *)(*(void *)this + 8 * v7), 8 * v9);
        unsigned int v7 = v17;
        unsigned int v9 = v18;
        uint64_t v6 = v19;
      }
    }
    if (v6) {
      int v14 = -1;
    }
    else {
      int v14 = 0;
    }
    this = (unsigned int *)memset((void *)(*(void *)v2 + 8 * v9), v14, 8 * v7);
    uint64_t v15 = v2[2];
    if (v15)
    {
      unint64_t v16 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v15;
      if (v15 >= 0x41) {
        unint64_t v2 = (unsigned int *)(*(void *)v2 + 8 * (((unint64_t)(v15 + 63) >> 6) - 1));
      }
    }
    else
    {
      unint64_t v16 = 0;
    }
    *(void *)v2 &= v16;
  }
  return this;
}

void llvm::APInt::lshrInPlace(llvm::APInt *this, const llvm::APInt *a2)
{
  unint64_t v2 = *((unsigned int *)this + 2);
  uint64_t v3 = *((unsigned int *)a2 + 2);
  if (v3 < 0x41)
  {
    unsigned int v4 = *(void **)a2;
    goto LABEL_3;
  }
  int v6 = 0;
  int64_t v7 = (unint64_t)(v3 + 63) >> 6;
  unint64_t v8 = *(void **)a2;
  do
  {
    if (v7-- < 1) {
      break;
    }
    unint64_t v10 = v8[v7];
    v6 += __clz(v10);
  }
  while (!v10);
  int v11 = v3 | 0xFFFFFFC0;
  if ((v3 & 0x3F) == 0) {
    int v11 = 0;
  }
  unsigned int v12 = v3 - v6 - v11;
  unsigned int v5 = *((_DWORD *)this + 2);
  if (v12 <= 0x40)
  {
    unsigned int v4 = (void *)*v8;
LABEL_3:
    unsigned int v5 = *((_DWORD *)this + 2);
    if ((unint64_t)v4 <= v2) {
      unsigned int v5 = v4;
    }
  }
  if (v2 > 0x40)
  {
    if (v5)
    {
      uint64_t v13 = *(void **)this;
      unint64_t v14 = (v2 + 63) >> 6;
      if (v5 >> 6 >= v14) {
        int v15 = (v2 + 63) >> 6;
      }
      else {
        int v15 = v5 >> 6;
      }
      uint64_t v16 = (v14 - v15);
      char v17 = v5 & 0x3F;
      if ((v5 & 0x3F) != 0)
      {
        if (v5 >> 6 < v14)
        {
          uint64_t v18 = v13[v15] >> v5;
          void *v13 = v18;
          if (v16 != 1)
          {
            char v19 = v5 & 0x3F;
            char v20 = 64 - v17;
            uint64_t v21 = 1 - v16;
            unint64_t v22 = v13 + 1;
            int v23 = v15 + 1;
            do
            {
              *(v22 - 1) = (v13[v23] << v20) | v18;
              uint64_t v18 = v13[v23] >> v19;
              *v22++ = v18;
              ++v23;
            }
            while (!__CFADD__(v21++, 1));
          }
        }
      }
      else
      {
        unint64_t v27 = *(void **)this;
        int v26 = v15;
        int v25 = v14 - v15;
        memmove(v13, &v13[v15], (8 * v16));
        LODWORD(v16) = v25;
        int v15 = v26;
        uint64_t v13 = v27;
      }
      bzero(&v13[v16], (8 * v15));
    }
  }
  else if (v2 == v5)
  {
    *(void *)this = 0;
  }
  else
  {
    *(void *)this >>= v5;
  }
}

void llvm::APInt::lshrSlowCase(void **this, unsigned int a2)
{
  if (a2)
  {
    unint64_t v2 = *this;
    unint64_t v3 = ((unint64_t)*((unsigned int *)this + 2) + 63) >> 6;
    if (a2 >> 6 >= v3) {
      int v4 = ((unint64_t)*((unsigned int *)this + 2) + 63) >> 6;
    }
    else {
      int v4 = a2 >> 6;
    }
    uint64_t v5 = (v3 - v4);
    char v6 = a2 & 0x3F;
    if ((a2 & 0x3F) != 0)
    {
      if (a2 >> 6 < v3)
      {
        uint64_t v7 = v2[v4] >> v6;
        void *v2 = v7;
        if (v5 != 1)
        {
          uint64_t v8 = 1 - v5;
          unsigned int v9 = v2 + 1;
          int v10 = v4 + 1;
          do
          {
            *(v9 - 1) = (v2[v10] << (64 - v6)) | v7;
            uint64_t v7 = v2[v10] >> v6;
            *v9++ = v7;
            ++v10;
          }
          while (!__CFADD__(v8++, 1));
        }
      }
    }
    else
    {
      memmove(*this, &v2[v4], (8 * v5));
    }
    bzero(&v2[v5], (8 * v4));
  }
}

void llvm::APInt::tcShiftRight(llvm::APInt *this, unint64_t *a2, unsigned int a3)
{
  if (a3)
  {
    if (a3 >> 6 >= a2) {
      unsigned int v4 = a2;
    }
    else {
      unsigned int v4 = a3 >> 6;
    }
    uint64_t v5 = a2 - v4;
    char v6 = a3 & 0x3F;
    if ((a3 & 0x3F) != 0)
    {
      if (a3 >> 6 < a2)
      {
        uint64_t v7 = *((void *)this + v4) >> v6;
        *(void *)this = v7;
        if (v5 != 1)
        {
          unsigned int v8 = v4 + 1;
          unsigned int v9 = (void *)((char *)this + 8);
          uint64_t v10 = 1 - v5;
          do
          {
            *(v9 - 1) = (*((void *)this + v8) << (64 - v6)) | v7;
            uint64_t v7 = *((void *)this + v8) >> v6;
            *v9++ = v7;
            ++v8;
          }
          while (!__CFADD__(v10++, 1));
        }
      }
    }
    else
    {
      memmove(this, (char *)this + 8 * v4, (8 * v5));
    }
    bzero((char *)this + 8 * v5, 8 * v4);
  }
}

llvm::APInt *llvm::APInt::operator<<=(llvm::APInt *this, uint64_t *a2)
{
  unint64_t v4 = *((unsigned int *)this + 2);
  uint64_t v5 = *((unsigned int *)a2 + 2);
  if (v5 < 0x41) {
    goto LABEL_2;
  }
  int v8 = 0;
  int64_t v9 = (unint64_t)(v5 + 63) >> 6;
  a2 = (uint64_t *)*a2;
  do
  {
    if (v9-- < 1) {
      break;
    }
    unint64_t v11 = a2[v9];
    v8 += __clz(v11);
  }
  while (!v11);
  int v12 = v5 | 0xFFFFFFC0;
  if ((v5 & 0x3F) == 0) {
    int v12 = 0;
  }
  if ((v5 - v8 - v12) <= 0x40)
  {
LABEL_2:
    char v6 = (uint64_t *)*a2;
    if ((unint64_t)v6 <= v4) {
      LODWORD(v4) = v6;
    }
  }
  sub_1CCA66680(this, v4);
  return this;
}

void llvm::APInt::shlSlowCase(llvm::APInt *this, unsigned int a2)
{
  unint64_t v2 = this;
  uint64_t v3 = *((unsigned int *)this + 2);
  if (a2)
  {
    unint64_t v4 = *(void **)this;
    unint64_t v5 = (unint64_t)(v3 + 63) >> 6;
    if (a2 >> 6 >= v5) {
      unsigned int v6 = (unint64_t)(v3 + 63) >> 6;
    }
    else {
      unsigned int v6 = a2 >> 6;
    }
    char v7 = a2 & 0x3F;
    if ((a2 & 0x3F) != 0)
    {
      if (a2 >> 6 < v5)
      {
        unint64_t v8 = v5 - 1;
        unint64_t v9 = v4[v5 - 1 - v6] << (a2 & 0x3F);
        uint64_t v10 = &v4[(v5 - 1)];
        *uint64_t v10 = v9;
        if ((int)v5 - 1 > v6)
        {
          int v12 = &v4[(v5 - 1) - 1 + (uint64_t)-v6];
          uint64_t v13 = &v4[(v5 - 2)];
          do
          {
            unint64_t v14 = *v12--;
            *uint64_t v10 = (v14 >> (64 - v7)) | v9;
            unint64_t v9 = v4[v8 - v6 - 1] << v7;
            uint64_t v10 = &v4[(v8 - 1)];
            *v13-- = v9;
            --v8;
          }
          while (v6 < v8);
        }
      }
    }
    else
    {
      uint64_t v16 = *(void **)this;
      unsigned int v15 = v6;
      memmove(&v4[v6], v4, 8 * (v5 - v6));
      unsigned int v6 = v15;
      unint64_t v4 = v16;
    }
    bzero(v4, 8 * v6);
    LODWORD(v3) = *((_DWORD *)v2 + 2);
  }
  if (v3)
  {
    unint64_t v11 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v3;
    if (v3 >= 0x41) {
      unint64_t v2 = (llvm::APInt *)(*(void *)v2 + 8 * ((((unint64_t)v3 + 63) >> 6) - 1));
    }
  }
  else
  {
    unint64_t v11 = 0;
  }
  *(void *)v2 &= v11;
}

void llvm::APInt::tcShiftLeft(llvm::APInt *this, unint64_t *a2, unsigned int a3)
{
  if (a3)
  {
    uint64_t v3 = this;
    if (a3 >> 6 >= a2) {
      unsigned int v4 = a2;
    }
    else {
      unsigned int v4 = a3 >> 6;
    }
    char v5 = a3 & 0x3F;
    if ((a3 & 0x3F) != 0)
    {
      if (a3 >> 6 < a2)
      {
        uint64_t v6 = a2 - 1;
        uint64_t v7 = *((void *)this + v6 - v4) << (a3 & 0x3F);
        unint64_t v8 = (char *)this + 8 * v6;
        *(void *)unint64_t v8 = v7;
        if (v6 > v4)
        {
          unint64_t v9 = (unint64_t *)((char *)this + 8 * a2 + 8 * (uint64_t)-v4 - 16);
          uint64_t v10 = (void *)((char *)this + 8 * (a2 - 2));
          do
          {
            unint64_t v11 = *v9--;
            *(void *)unint64_t v8 = (v11 >> (64 - v5)) | v7;
            uint64_t v7 = *((void *)this + v6 - v4 - 1) << v5;
            unint64_t v8 = (char *)this + 8 * (v6 - 1);
            *v10-- = v7;
            --v6;
          }
          while (v4 < v6);
        }
      }
    }
    else
    {
      unsigned int v12 = v4;
      memmove((char *)this + 8 * v4, this, 8 * (a2 - v4));
      unsigned int v4 = v12;
      uint64_t v3 = this;
    }
    bzero(v3, 8 * v4);
  }
}

void *sub_1CD03F8B0(void *a1, uint64_t a2)
{
  unint64_t v2 = a1;
  if (!a1) {
    return v2;
  }
  unsigned int v3 = *(_DWORD *)(a2 + 8);
  unsigned int v21 = v3;
  if (v3 > 0x40) {
    operator new[]();
  }
  unint64_t v4 = *(void *)a2;
  char v20 = *(void **)a2;
  if (v3 < a1)
  {
    if (a1 > 0x40)
    {
      if (*(_DWORD *)(a2 + 8) != a1) {
        operator new[]();
      }
      sub_1CD0463BC((uint64_t)&v18, a2);
    }
    else
    {
      unsigned int v19 = a1;
      unint64_t v18 = v4 & (0xFFFFFFFFFFFFFFFFLL >> -(char)a1);
    }
    char v20 = (void *)v18;
    unsigned int v3 = v19;
    unsigned int v21 = v19;
  }
  unint64_t v5 = v2;
  unsigned int v17 = v3;
  if (v3 > 0x40) {
    operator new[]();
  }
  if (v3) {
    unint64_t v6 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v3;
  }
  else {
    LODWORD(v6) = 0;
  }
  uint64_t v16 = v6 & v2;
  llvm::APInt::urem((llvm::APInt *)&v20, (const llvm::APInt *)&v16, (uint64_t)&v18);
  if (v21 >= 0x41 && v20) {
    MEMORY[0x1D25D9CB0](v20, 0x1000C8000313F17);
  }
  char v20 = (void *)v18;
  unsigned int v7 = v19;
  unsigned int v21 = v19;
  unsigned int v19 = 0;
  if (v17 >= 0x41 && v16)
  {
    MEMORY[0x1D25D9CB0](v16, 0x1000C8000313F17);
    unsigned int v7 = v21;
  }
  if (v7 >= 0x41)
  {
    int v11 = 0;
    int64_t v12 = ((unint64_t)v7 + 63) >> 6;
    unint64_t v8 = v20;
    do
    {
      if (v12-- < 1) {
        break;
      }
      unint64_t v14 = v20[v12];
      v11 += __clz(v14);
    }
    while (!v14);
    unsigned int v15 = v7 | 0xFFFFFFC0;
    if ((v7 & 0x3F) == 0) {
      unsigned int v15 = 0;
    }
    if (v7 - v11 - v15 > 0x40) {
      goto LABEL_22;
    }
    unint64_t v9 = (void *)*v20;
    if (*v20 > (unint64_t)v2) {
      goto LABEL_22;
    }
  }
  else
  {
    unint64_t v8 = v20;
    if ((unint64_t)v20 > v2) {
      return v2;
    }
    unint64_t v9 = v20;
  }
  unint64_t v5 = (unint64_t)v9;
LABEL_22:
  unint64_t v2 = (void *)v5;
  if (v7 >= 0x41 && v8) {
    MEMORY[0x1D25D9CB0](v8, 0x1000C8000313F17);
  }
  return v2;
}

llvm::APInt *llvm::APInt::rotr@<X0>(llvm::APInt *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  unsigned int v5 = *((_DWORD *)this + 2);
  if (v5 && (int v6 = a2 % v5) != 0)
  {
    sub_1CB8F02F4((uint64_t)this, v6, (uint64_t)&v18);
    unsigned int v7 = *((_DWORD *)this + 2);
    unsigned int v8 = v7 - v6;
    unsigned int v17 = v7;
    if (v7 > 0x40) {
      operator new[]();
    }
    unint64_t v16 = *(void *)this;
    unint64_t result = sub_1CCA66680((llvm::APInt *)&v16, v8);
    unsigned int v10 = v17;
    if (v17 > 0x40)
    {
      int64_t v12 = (void *)v16;
      uint64_t v13 = (uint64_t *)v18;
      unint64_t v14 = ((unint64_t)v17 + 63) >> 6;
      do
      {
        uint64_t v15 = *v13++;
        *v12++ |= v15;
        --v14;
      }
      while (v14);
      unint64_t v11 = v16;
    }
    else
    {
      unint64_t v11 = v16 | v18;
    }
    *(_DWORD *)(a3 + 8) = v10;
    *(void *)a3 = v11;
    if (v19 >= 0x41)
    {
      unint64_t result = (llvm::APInt *)v18;
      if (v18) {
        return (llvm::APInt *)MEMORY[0x1D25D9CB0](v18, 0x1000C8000313F17);
      }
    }
  }
  else
  {
    return (llvm::APInt *)sub_1CD0463BC(a3, (uint64_t)this);
  }
  return result;
}

uint64_t llvm::APInt::nearestLogBase2(llvm::APInt *this)
{
  uint64_t v1 = *((unsigned int *)this + 2);
  if (v1 == 1) {
    return (*(_DWORD *)this - 1);
  }
  if (v1 > 0x40)
  {
    int v6 = 0;
    int64_t v7 = (unint64_t)(v1 + 63) >> 6;
    uint64_t v8 = v7;
    do
    {
      BOOL v9 = v8-- < 1;
      if (v9) {
        break;
      }
      unint64_t v10 = *(void *)(*(void *)this + 8 * v8);
      v6 += __clz(v10);
    }
    while (!v10);
    int v11 = v1 | 0xFFFFFFC0;
    if ((v1 & 0x3F) == 0) {
      int v11 = 0;
    }
    if (v6 + v11 != v1)
    {
      int v12 = 0;
      uint64_t v13 = *(void *)this;
      do
      {
        BOOL v9 = v7-- < 1;
        if (v9) {
          break;
        }
        unint64_t v14 = *(void *)(v13 + 8 * v7);
        v12 += __clz(v14);
      }
      while (!v14);
      int v4 = v1 + ~(v12 + v11);
      char v5 = v4 - 1;
      unint64_t v3 = *(void *)(v13 + 8 * ((v4 - 1) >> 6));
      return v4 + ((v3 >> v5) & 1);
    }
    return 0xFFFFFFFFLL;
  }
  unint64_t v3 = *(void *)this;
  if (!*(void *)this) {
    return 0xFFFFFFFFLL;
  }
  int v4 = v1 + ~(v1 + __clz(v3) - 64);
  char v5 = v4 - 1;
  return v4 + ((v3 >> v5) & 1);
}

unint64_t *llvm::APInt::sqrt@<X0>(unint64_t *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *((unsigned int *)this + 2);
  if (v3 >= 0x41)
  {
    int v11 = 0;
    int64_t v12 = (unint64_t)(v3 + 63) >> 6;
    do
    {
      BOOL v23 = v12-- < 1;
      if (v23) {
        break;
      }
      unint64_t v13 = *(void *)(*this + 8 * v12);
      v11 += __clz(v13);
    }
    while (!v13);
    int v14 = v3 | 0xFFFFFFC0;
    if ((v3 & 0x3F) == 0) {
      int v14 = 0;
    }
    unsigned int v15 = v3 - v11 - v14;
    if (v15 < 6)
    {
      *(_DWORD *)(a2 + 8) = v3;
      operator new[]();
    }
    if (v15 < 0x34)
    {
      unint64_t v4 = *(void *)*this;
      goto LABEL_4;
    }
  }
  else
  {
    unint64_t v4 = *this;
    unsigned int v5 = __clz(*this);
    if (v5 >= 0x3B)
    {
      uint64_t v9 = byte_1CFB2E408[v4];
      *(_DWORD *)(a2 + 8) = v3;
      unint64_t v10 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v3;
      if (!v3) {
        unint64_t v10 = 0;
      }
      unint64_t v8 = v10 & v9;
      goto LABEL_8;
    }
    if (v5 > 0xC)
    {
LABEL_4:
      unint64_t v6 = vcvtad_u64_f64(sqrt((double)v4));
      *(_DWORD *)(a2 + 8) = v3;
      if (v3 > 0x40) {
        operator new[]();
      }
      unint64_t v7 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v3;
      if (!v3) {
        unint64_t v7 = 0;
      }
      unint64_t v8 = v7 & v6;
LABEL_8:
      *(void *)a2 = v8;
      return this;
    }
  }
  unint64_t v16 = this;
  sub_1CB8F1EEC((uint64_t)&v70, v3, 16);
  sub_1CB8F1EEC((uint64_t)&v68, *((_DWORD *)v16 + 2), 1);
  sub_1CB8F1EEC((uint64_t)&v66, *((_DWORD *)v16 + 2), 0);
  int v43 = (llvm::APInt *)v16;
  sub_1CB8F1EEC((uint64_t)&v64, *((_DWORD *)v16 + 2), 2);
  unsigned int v17 = 4;
  if (v3 >= 5)
  {
    while (1)
    {
      uint64_t v18 = *((unsigned int *)v43 + 2);
      if (v18 > 0x40) {
        break;
      }
      unsigned int v19 = v70;
      if (*(void *)v43 <= (unint64_t)v70) {
        goto LABEL_38;
      }
LABEL_26:
      unsigned int v63 = v71;
      if (v71 > 0x40) {
        operator new[]();
      }
      unint64_t v62 = v19;
      sub_1CCA66680((llvm::APInt *)&v62, 2u);
      if (v71 >= 0x41 && v70) {
        MEMORY[0x1D25D9CB0](v70, 0x1000C8000313F17);
      }
      v17 += 2;
      v70 = v62;
      unsigned int v71 = v63;
      if (v17 >= v3) {
        goto LABEL_38;
      }
    }
    unsigned int v19 = v70;
    unint64_t v20 = ((unint64_t)(v18 + 63) >> 3) & 0x3FFFFFF8;
    while (v20)
    {
      unint64_t v21 = *(void *)(*(void *)v43 - 8 + v20);
      unint64_t v22 = *(unint64_t *)((char *)v70 + v20 - 8);
      v20 -= 8;
      if (v21 != v22)
      {
        if (v21 > v22) {
          goto LABEL_26;
        }
        break;
      }
    }
  }
LABEL_38:
  unsigned int v63 = v69;
  if (v69 > 0x40) {
    operator new[]();
  }
  unint64_t v62 = v68;
  sub_1CCA66680((llvm::APInt *)&v62, v17 >> 1);
  if (v69 >= 0x41 && v68) {
    MEMORY[0x1D25D9CB0](v68, 0x1000C8000313F17);
  }
  unint64_t v68 = v62;
  unsigned int v69 = v63;
  while (1)
  {
    llvm::APInt::udiv((uint64_t)v43, (const llvm::APInt *)&v68, (uint64_t)&v58);
    llvm::APInt::operator+=((uint64_t)&v58, (uint64_t **)&v68);
    unsigned int v61 = v59;
    unint64_t __src = v58;
    unsigned int v59 = 0;
    llvm::APInt::udiv((uint64_t)&__src, (const llvm::APInt *)&v64, (uint64_t)&v62);
    if (v67 >= 0x41 && v66) {
      MEMORY[0x1D25D9CB0](v66, 0x1000C8000313F17);
    }
    int v66 = v62;
    unsigned int v67 = v63;
    unsigned int v63 = 0;
    if (v61 >= 0x41 && __src) {
      MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
    }
    if (v59 >= 0x41 && v58) {
      MEMORY[0x1D25D9CB0](v58, 0x1000C8000313F17);
    }
    if (v69 > 0x40) {
      break;
    }
    BOOL v23 = v68 > v66;
LABEL_56:
    if (!v23) {
      goto LABEL_63;
    }
    sub_1CD828004((void **)&v68, (uint64_t)&v66);
  }
  unint64_t v24 = (((unint64_t)v69 + 63) >> 3) & 0x3FFFFFF8;
  while (v24)
  {
    unint64_t v25 = *(unint64_t *)((char *)v68 + v24 - 8);
    unint64_t v26 = *(unint64_t *)((char *)v66 + v24 - 8);
    v24 -= 8;
    BOOL v23 = v25 > v26;
    if (v25 != v26) {
      goto LABEL_56;
    }
  }
LABEL_63:
  llvm::APInt::operator*((uint64_t)&v68, &v68, (uint64_t)&v62);
  unsigned int v55 = v69;
  if (v69 > 0x40) {
    operator new[]();
  }
  unint64_t v54 = v68;
  llvm::APInt::operator+=((uint64_t)&v54, 1uLL);
  unsigned int v27 = v55;
  unsigned int v57 = v55;
  int v28 = v54;
  unint64_t v56 = v54;
  unsigned int v55 = 0;
  unsigned int v51 = v69;
  if (v69 > 0x40) {
    operator new[]();
  }
  unsigned int v50 = v68;
  llvm::APInt::operator+=((uint64_t)&v50, 1uLL);
  unsigned int v29 = v51;
  unsigned int v53 = v51;
  BOOL v30 = v50;
  unsigned int v52 = v50;
  unsigned int v51 = 0;
  this = (unint64_t *)llvm::APInt::operator*((uint64_t)&v56, &v52, (uint64_t)&__src);
  if (v29 >= 0x41 && v30) {
    this = (unint64_t *)MEMORY[0x1D25D9CB0](v30, 0x1000C8000313F17);
  }
  if (v51 >= 0x41)
  {
    this = v50;
    if (v50) {
      this = (unint64_t *)MEMORY[0x1D25D9CB0](v50, 0x1000C8000313F17);
    }
  }
  if (v27 >= 0x41 && v28) {
    this = (unint64_t *)MEMORY[0x1D25D9CB0](v28, 0x1000C8000313F17);
  }
  if (v55 >= 0x41)
  {
    this = v54;
    if (v54) {
      this = (unint64_t *)MEMORY[0x1D25D9CB0](v54, 0x1000C8000313F17);
    }
  }
  uint64_t v31 = *((unsigned int *)v43 + 2);
  if (v31 > 0x40)
  {
    int v32 = v62;
    unint64_t v34 = ((unint64_t)(v31 + 63) >> 3) & 0x3FFFFFF8;
    while (v34)
    {
      unint64_t v35 = *(void *)(*(void *)v43 - 8 + v34);
      unint64_t v36 = *(unint64_t *)((char *)v62 + v34 - 8);
      v34 -= 8;
      if (v35 != v36)
      {
        if (v35 <= v36) {
          goto LABEL_83;
        }
        break;
      }
    }
LABEL_106:
    unsigned int v33 = v61;
    unsigned int v49 = v61;
    if (v61 > 0x40) {
      operator new[]();
    }
    uint64_t v48 = (unint64_t *)__src;
    llvm::APInt::operator-=((uint64_t)&v48, &v62);
    unsigned int v53 = v49;
    unsigned int v52 = v48;
    unsigned int v49 = 0;
    llvm::APInt::udiv((uint64_t)&v52, (const llvm::APInt *)&v64, (uint64_t)&v56);
    if (v53 >= 0x41 && v52) {
      MEMORY[0x1D25D9CB0](v52, 0x1000C8000313F17);
    }
    if (v49 >= 0x41 && v48) {
      MEMORY[0x1D25D9CB0](v48, 0x1000C8000313F17);
    }
    unsigned int v47 = *((_DWORD *)v43 + 2);
    if (v47 > 0x40) {
      operator new[]();
    }
    unint64_t v46 = *(void *)v43;
    this = (unint64_t *)llvm::APInt::operator-=((uint64_t)&v46, &v62);
    uint64_t v37 = v47;
    unint64_t v38 = v46;
    unsigned int v47 = 0;
    if (v37 > 0x40)
    {
      unint64_t v40 = ((unint64_t)(v37 + 63) >> 3) & 0x3FFFFFF8;
      while (v40)
      {
        unint64_t v41 = *(void *)(v46 - 8 + v40);
        unint64_t v42 = *(unint64_t *)((char *)v56 + v40 - 8);
        v40 -= 8;
        if (v41 != v42)
        {
          if (v41 <= v42) {
            goto LABEL_120;
          }
          break;
        }
      }
    }
    else if (v46 < (unint64_t)v56)
    {
LABEL_120:
      unint64_t v39 = &v68;
LABEL_128:
      *(_DWORD *)(a2 + 8) = *((_DWORD *)v39 + 2);
      *(void *)a2 = *v39;
      *((_DWORD *)v39 + 2) = 0;
      if (v37 >= 0x41 && v38) {
        this = (unint64_t *)MEMORY[0x1D25D9CB0](v38, 0x1000C8000313F17);
      }
      if (v57 >= 0x41)
      {
        this = v56;
        if (v56) {
          this = (unint64_t *)MEMORY[0x1D25D9CB0](v56, 0x1000C8000313F17);
        }
      }
      goto LABEL_84;
    }
    unsigned int v45 = v69;
    if (v69 > 0x40) {
      operator new[]();
    }
    int64_t v44 = v68;
    unint64_t v39 = &v44;
    this = (unint64_t *)llvm::APInt::operator+=((uint64_t)&v44, 1uLL);
    goto LABEL_128;
  }
  int v32 = v62;
  if (*(void *)v43 >= (unint64_t)v62) {
    goto LABEL_106;
  }
LABEL_83:
  *(_DWORD *)(a2 + 8) = v69;
  *(void *)a2 = v68;
  unsigned int v69 = 0;
  unsigned int v33 = v61;
LABEL_84:
  if (v33 >= 0x41)
  {
    this = (unint64_t *)__src;
    if (__src) {
      this = (unint64_t *)MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
    }
  }
  if (v63 >= 0x41 && v32) {
    this = (unint64_t *)MEMORY[0x1D25D9CB0](v32, 0x1000C8000313F17);
  }
  if (v65 >= 0x41)
  {
    this = v64;
    if (v64) {
      this = (unint64_t *)MEMORY[0x1D25D9CB0](v64, 0x1000C8000313F17);
    }
  }
  if (v67 >= 0x41)
  {
    this = v66;
    if (v66) {
      this = (unint64_t *)MEMORY[0x1D25D9CB0](v66, 0x1000C8000313F17);
    }
  }
  if (v69 >= 0x41)
  {
    this = v68;
    if (v68) {
      this = (unint64_t *)MEMORY[0x1D25D9CB0](v68, 0x1000C8000313F17);
    }
  }
  if (v71 >= 0x41)
  {
    this = v70;
    if (v70) {
      return (unint64_t *)MEMORY[0x1D25D9CB0](v70, 0x1000C8000313F17);
    }
  }
  return this;
}

uint64_t llvm::APInt::udiv@<X0>(uint64_t this@<X0>, const llvm::APInt *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = *(unsigned int *)(this + 8);
  if (v4 <= 0x40)
  {
    uint64_t v5 = *(void *)this / *(void *)a2;
    *(_DWORD *)(a3 + 8) = v4;
    unint64_t v6 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v4;
    if (!v4) {
      unint64_t v6 = 0;
    }
    *(void *)a3 = v6 & v5;
    return this;
  }
  int v7 = 0;
  int64_t v8 = (unint64_t)(v4 + 63) >> 6;
  do
  {
    BOOL v9 = v8-- < 1;
    if (v9) {
      break;
    }
    unint64_t v10 = *(void *)(*(void *)this + 8 * v8);
    v7 += __clz(v10);
  }
  while (!v10);
  int v11 = v4 | 0xFFFFFFC0;
  if ((v4 & 0x3F) == 0) {
    int v11 = 0;
  }
  unint64_t v12 = ((unint64_t)(v4 - v7 - v11) + 63) >> 6;
  uint64_t v13 = *((unsigned int *)a2 + 2);
  if (v13 > 0x40)
  {
    int v20 = 0;
    int64_t v21 = (unint64_t)(v13 + 63) >> 6;
    int v14 = *(void **)a2;
    do
    {
      BOOL v9 = v21-- < 1;
      if (v9) {
        break;
      }
      unint64_t v22 = v14[v21];
      v20 += __clz(v22);
    }
    while (!v22);
    int v23 = v13 | 0xFFFFFFC0;
    if ((v13 & 0x3F) == 0) {
      int v23 = 0;
    }
    int v15 = v20 + v23;
  }
  else
  {
    int v14 = *(void **)a2;
    int v15 = v13 + __clz(*(void *)a2) - 64;
  }
  if (!v12)
  {
LABEL_23:
    *(_DWORD *)(a3 + 8) = v4;
    operator new[]();
  }
  uint64_t v16 = (v13 - v15);
  if (v16 != 1)
  {
    if (v12 >= ((unint64_t)(v16 + 63) >> 6))
    {
      unint64_t v17 = (unint64_t)(v4 + 63) >> 6;
      do
      {
        if (!(v17 * 8)) {
          goto LABEL_19;
        }
        unint64_t v18 = *(void *)(*(void *)this + v17 * 8 - 8);
        unint64_t v19 = v14[--v17];
      }
      while (v18 == v19);
      if (v18 > v19)
      {
LABEL_19:
        if (memcmp(*(const void **)this, v14, ((unint64_t)(v4 + 63) >> 3) & 0x3FFFFFF8))
        {
          if (v12 != 1)
          {
            *(_DWORD *)(a3 + 8) = v4;
            operator new[]();
          }
          *(_DWORD *)(a3 + 8) = v4;
          operator new[]();
        }
        *(_DWORD *)(a3 + 8) = v4;
        operator new[]();
      }
    }
    goto LABEL_23;
  }

  return sub_1CD0463BC(a3, this);
}

void llvm::APInt::udivrem(llvm::APInt *this, const llvm::APInt *a2, const llvm::APInt *a3, llvm::APInt *a4, llvm::APInt *a5)
{
  uint64_t v9 = *((unsigned int *)this + 2);
  if (v9 <= 0x40)
  {
    uint64_t v10 = *(void *)this % *(void *)a2;
    if (v9) {
      unint64_t v11 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v9;
    }
    else {
      unint64_t v11 = 0;
    }
    unint64_t v12 = v11 & (*(void *)this / *(void *)a2);
    if (*((_DWORD *)a3 + 2) >= 0x41u && *(void *)a3) {
      MEMORY[0x1D25D9CB0](*(void *)a3, 0x1000C8000313F17);
    }
    *(void *)a3 = v12;
    *((_DWORD *)a3 + 2) = v9;
    if (v9) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v9;
    }
    else {
      unint64_t v13 = 0;
    }
    unint64_t v14 = v13 & v10;
    if (*((_DWORD *)a4 + 2) >= 0x41u)
    {
      if (*(void *)a4) {
        MEMORY[0x1D25D9CB0](*(void *)a4, 0x1000C8000313F17);
      }
    }
    *(void *)a4 = v14;
    *((_DWORD *)a4 + 2) = v9;
    return;
  }
  int v15 = 0;
  unint64_t v16 = (unint64_t)(v9 + 63) >> 6;
  uint64_t v17 = v16;
  do
  {
    BOOL v18 = v17-- < 1;
    if (v18) {
      break;
    }
    unint64_t v19 = *(void *)(*(void *)this + 8 * v17);
    v15 += __clz(v19);
  }
  while (!v19);
  int v20 = v9 | 0xFFFFFFC0;
  if ((v9 & 0x3F) == 0) {
    int v20 = 0;
  }
  unint64_t v21 = ((unint64_t)(v9 - v15 - v20) + 63) >> 6;
  uint64_t v22 = *((unsigned int *)a2 + 2);
  if (v22 > 0x40)
  {
    int v35 = 0;
    int64_t v36 = (unint64_t)(v22 + 63) >> 6;
    do
    {
      BOOL v18 = v36-- < 1;
      if (v18) {
        break;
      }
      unint64_t v37 = *(void *)(*(void *)a2 + 8 * v36);
      v35 += __clz(v37);
    }
    while (!v37);
    int v38 = v22 | 0xFFFFFFC0;
    if ((v22 & 0x3F) == 0) {
      int v38 = 0;
    }
    int v23 = v35 + v38;
  }
  else
  {
    int v23 = v22 + __clz(*(void *)a2) - 64;
  }
  if (!v21)
  {
    unsigned int v39 = *((_DWORD *)this + 2);
    uint64_t v40 = 0;
    goto LABEL_36;
  }
  uint64_t v24 = (v22 - v23);
  unint64_t v25 = (unint64_t)(v24 + 63) >> 6;
  if (v24 == 1)
  {
    sub_1CD828004((void **)a3, (uint64_t)this);
    sub_1CB8F1EEC((uint64_t)&v44, v9, 0);
    if (*((_DWORD *)a4 + 2) >= 0x41u && *(void *)a4) {
      MEMORY[0x1D25D9CB0](*(void *)a4, 0x1000C8000313F17);
    }
    *(void *)a4 = v44;
    *((_DWORD *)a4 + 2) = v45;
  }
  if (v21 >= v25)
  {
    uint64_t v26 = *((unsigned int *)this + 2);
    if (v26 > 0x40)
    {
      unsigned int v27 = *(char **)this;
      int v28 = *(char **)a2;
      unint64_t v29 = (unint64_t)(v26 + 63) >> 3;
      unint64_t v30 = v29 & 0x3FFFFFF8;
      while (v30)
      {
        unint64_t v31 = *(void *)&v27[v30 - 8];
        unint64_t v32 = *(void *)&v28[v30 - 8];
        v30 -= 8;
        if (v31 != v32)
        {
          if (v31 <= v32) {
            goto LABEL_50;
          }
          break;
        }
      }
      if (memcmp(v27, v28, v29 & 0x3FFFFFF8)) {
        goto LABEL_27;
      }
LABEL_49:
      unsigned int v39 = v9;
      uint64_t v40 = 1;
LABEL_36:
      sub_1CB8F1EEC((uint64_t)&v44, v39, v40);
      if (*((_DWORD *)a3 + 2) >= 0x41u && *(void *)a3) {
        MEMORY[0x1D25D9CB0](*(void *)a3, 0x1000C8000313F17);
      }
      *(void *)a3 = v44;
      *((_DWORD *)a3 + 2) = v45;
      sub_1CB8F1EEC((uint64_t)&v44, v9, 0);
      if (*((_DWORD *)a4 + 2) >= 0x41u && *(void *)a4) {
        MEMORY[0x1D25D9CB0](*(void *)a4, 0x1000C8000313F17);
      }
      *(void *)a4 = v44;
      *((_DWORD *)a4 + 2) = v45;
      return;
    }
    if (*(void *)this >= *(void *)a2)
    {
      if (*(void *)this != *(void *)a2)
      {
LABEL_27:
        llvm::APInt::reallocate((uint64_t)a3, v9);
        llvm::APInt::reallocate((uint64_t)a4, v9);
        unint64_t v34 = *(llvm::APInt **)this;
        if (v21 == 1)
        {
          uint64_t v41 = *(void *)v34;
          unint64_t v42 = **(void **)a2;
          uint64_t v43 = *(void *)v34 / v42;
          sub_1CD042A34((unsigned int *)a3, v43);
          sub_1CD042A34((unsigned int *)a4, v41 - v43 * v42);
        }
        else
        {
          llvm::APInt::divide(v34, (const unint64_t *)v21, *(uint64_t **)a2, (const unint64_t *)v25, *(unint64_t **)a3, *(unint64_t **)a4, v33);
          bzero((void *)(*(void *)a3 + 8 * v21), (8 * (v16 - v21)));
          bzero((void *)(*(void *)a4 + 8 * v25), (8 * (v16 - v25)));
        }
        return;
      }
      goto LABEL_49;
    }
  }
LABEL_50:
  sub_1CD828004((void **)a4, (uint64_t)this);
  sub_1CB8F1EEC((uint64_t)&v44, v9, 0);
  if (*((_DWORD *)a3 + 2) >= 0x41u && *(void *)a3) {
    MEMORY[0x1D25D9CB0](*(void *)a3, 0x1000C8000313F17);
  }
  *(void *)a3 = v44;
  *((_DWORD *)a3 + 2) = v45;
}

void llvm::APInt::divide(llvm::APInt *this, const unint64_t *a2, uint64_t *a3, const unint64_t *a4, unint64_t *a5, unint64_t *a6, unint64_t *a7)
{
  int v7 = a6;
  uint64_t v76 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = (2 * a4);
  uint64_t v12 = (2 * a2);
  unsigned int v73 = a2;
  uint64_t v74 = a4;
  if (a6) {
    int v13 = 4;
  }
  else {
    int v13 = 3;
  }
  int v72 = v12 - 2 * a4;
  unsigned int v14 = (v13 * v11 + 2 * v72) | 1;
  uint64_t v15 = (2 * a2) | 1u;
  size_t v16 = 4 * v15;
  if (v14 > 0x80) {
    operator new[]();
  }
  uint64_t v17 = &v75[v15];
  int v18 = v11 + v15;
  unint64_t v19 = &v75[v18];
  int v20 = &v75[(v18 + v12)];
  if (a6) {
    unint64_t v21 = v20;
  }
  else {
    unint64_t v21 = 0;
  }
  bzero(v75, v16);
  if (v73)
  {
    uint64_t v22 = 0;
    do
    {
      uint64_t v23 = *(void *)this;
      this = (llvm::APInt *)((char *)this + 8);
      v75[v22] = v23;
      v75[(v22 + 1)] = HIDWORD(v23);
      v22 += 2;
    }
    while (2 * v73 != v22);
  }
  v75[v12] = 0;
  bzero(v17, 4 * v11);
  if (v74)
  {
    uint64_t v24 = 0;
    uint64_t v25 = 2 * v74;
    do
    {
      uint64_t v26 = *a3++;
      v17[v24] = v26;
      v17[(v24 + 1)] = HIDWORD(v26);
      v24 += 2;
    }
    while (v25 != v24);
  }
  bzero(v19, 4 * v12);
  if (v7) {
    bzero(v21, 4 * v11);
  }
  if (v11)
  {
    while (!v17[v11 - 1])
    {
      if (!--v11) {
        goto LABEL_23;
      }
    }
    LODWORD(v12) = v12 - v11;
  }
  else
  {
    LODWORD(v12) = v72;
  }
LABEL_23:
  if (v11 + v12)
  {
    uint64_t v27 = (v11 + v12);
    while (!v75[v27 - 1])
    {
      LODWORD(v12) = v12 - 1;
      if (!(--v27 * 4))
      {
        LODWORD(v12) = -(int)v11;
        break;
      }
    }
  }
  uint64_t v28 = (v11 - 1);
  if (v11 != 1)
  {
    unsigned int v36 = __clz(v17[v28]);
    int v37 = v12 + v11;
    if (!v36)
    {
      unsigned int v41 = 0;
      goto LABEL_53;
    }
    if (v37)
    {
      unsigned int v38 = 0;
      unsigned int v39 = v75;
      uint64_t v40 = (v12 + v11);
      do
      {
        unsigned int v41 = *v39 >> (32 - v36);
        *unsigned int v39 = (*v39 << v36) | v38;
        ++v39;
        unsigned int v38 = v41;
        --v40;
      }
      while (v40);
      if (!v11)
      {
LABEL_53:
        v75[v37] = v41;
        uint64_t v46 = (v11 - 2);
        uint64_t v47 = (int)v12;
        do
        {
          uint64_t v48 = (v11 + v47);
          unint64_t v49 = v75[(v48 - 1)] | ((unint64_t)v75[v48] << 32);
          unint64_t v50 = v17[v28];
          unint64_t v51 = v49 / v50;
          unint64_t v52 = v49 % v50;
          if (v49 / v50 == 0x100000000
            || (unint64_t v53 = v49 / v50, v51 * v17[v46] > (v75[(v48 - 2)] | (v52 << 32))))
          {
            unint64_t v53 = v51 - 1;
            unint64_t v54 = v52 + v50;
            if (!HIDWORD(v54)
              && (v51 == 0x100000001 || v53 * v17[v46] > (v75[(v48 - 2)] | (v54 << 32))))
            {
              unint64_t v53 = v51 - 2;
            }
          }
          if (v11)
          {
            uint64_t v55 = 0;
            uint64_t v56 = 0;
            do
            {
              unint64_t v57 = v53 * v17[v55];
              unint64_t v58 = v75[(v47 + v55)] - (v56 + v57);
              v75[(v47 + v55)] = v58;
              unint64_t v59 = HIDWORD(v57) - HIDWORD(v58);
              uint64_t v56 = v59;
              ++v55;
            }
            while (v11 != v55);
            unint64_t v60 = v75[v48];
            v75[v48] = v60 - v59;
            v19[v47] = v53;
            if (v59 > v60)
            {
              uint64_t v61 = 0;
              LOBYTE(v62) = 0;
              v19[v47] = v53 - 1;
              do
              {
                unsigned int v63 = v17[v61];
                unsigned int v64 = v75[(v47 + v61)];
                if (v63 >= v64) {
                  unsigned int v65 = v75[(v47 + v61)];
                }
                else {
                  unsigned int v65 = v17[v61];
                }
                unsigned int v66 = v63 + (v62 & 1) + v64;
                v75[(v47 + v61)] = v66;
                if (v66 >= v65) {
                  int v62 = v62 & (v66 == v65);
                }
                else {
                  int v62 = 1;
                }
                ++v61;
              }
              while (v11 != v61);
              v75[v48] += v62;
            }
          }
          else
          {
            v19[v47] = v53;
          }
          BOOL v34 = v47-- <= 0;
        }
        while (!v34);
        if (v21)
        {
          if (v36)
          {
            if ((v28 & 0x80000000) == 0)
            {
              int v67 = 0;
              do
              {
                unsigned int v68 = v75[v28];
                v21[v28] = (v68 >> v36) | v67;
                int v67 = v68 << (32 - v36);
                BOOL v34 = v28-- <= 0;
              }
              while (!v34);
            }
          }
          else if ((v28 & 0x80000000) == 0)
          {
            do
            {
              v21[v28] = v75[v28];
              BOOL v34 = v28-- <= 0;
            }
            while (!v34);
          }
        }
        goto LABEL_86;
      }
    }
    else
    {
      unsigned int v41 = 0;
      if (!v11) {
        goto LABEL_53;
      }
    }
    unsigned int v42 = 0;
    uint64_t v43 = v11;
    uint64_t v44 = (int *)v17;
    do
    {
      unsigned int v45 = *v44 >> (32 - v36);
      *uint64_t v44 = (*v44 << v36) | v42;
      ++v44;
      unsigned int v42 = v45;
      --v43;
    }
    while (v43);
    goto LABEL_53;
  }
  uint64_t v29 = 0;
  if ((v12 & 0x80000000) == 0)
  {
    unint64_t v30 = *v17;
    uint64_t v31 = v12;
    do
    {
      uint64_t v32 = v29;
      uint64_t v29 = v75[v31];
      unint64_t v33 = v29 | (v32 << 32);
      if (v33)
      {
        if (v33 >= v30)
        {
          if (v33 == v30)
          {
            uint64_t v29 = 0;
            v19[v31] = 1;
          }
          else
          {
            unint64_t v35 = v33 / v30;
            v19[v31] = v35;
            uint64_t v29 = (v29 - v30 * v35);
          }
          goto LABEL_38;
        }
      }
      else
      {
        uint64_t v29 = 0;
      }
      v19[v31] = 0;
LABEL_38:
      BOOL v34 = v31-- <= 0;
    }
    while (!v34);
  }
  if (v21) {
    *unint64_t v21 = v29;
  }
LABEL_86:
  if (v73 && a5)
  {
    uint64_t v69 = 0;
    do
    {
      *a5++ = v19[v69] | ((unint64_t)v19[(v69 + 1)] << 32);
      v69 += 2;
    }
    while (2 * v73 != v69);
  }
  if (v74 && v7)
  {
    uint64_t v70 = 0;
    uint64_t v71 = 2 * v74;
    do
    {
      *v7++ = v21[v70] | ((unint64_t)v21[(v70 + 1)] << 32);
      v70 += 2;
    }
    while (v71 != v70);
  }
}

void llvm::APInt::udiv(llvm::APInt *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v20 = a2;
  unsigned int v3 = *((_DWORD *)this + 2);
  if (v3 <= 0x40)
  {
    unint64_t v4 = *(void *)this / a2;
    *(_DWORD *)(a3 + 8) = v3;
    unint64_t v5 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v3;
    if (!v3) {
      unint64_t v5 = 0;
    }
    *(void *)a3 = v5 & v4;
    return;
  }
  int v7 = (const unint64_t *)(((unint64_t)(v3 - sub_1CD0442FC((uint64_t)this)) + 63) >> 6);
  if (v7)
  {
    if (a2 == 1)
    {
      sub_1CD0463BC(a3, (uint64_t)this);
      return;
    }
    uint64_t v11 = this;
    unsigned int v12 = *((_DWORD *)this + 2);
    if (v12 >= 0x41)
    {
      unsigned int v13 = v12 - sub_1CD0442FC((uint64_t)this);
      unsigned int v12 = *((_DWORD *)this + 2);
      if (v13 > 0x40)
      {
LABEL_22:
        if (v12 < 0x41) {
          goto LABEL_23;
        }
        unsigned int v15 = v12 - sub_1CD0442FC((uint64_t)this);
        unsigned int v12 = *((_DWORD *)this + 2);
        if (v15 > 0x40) {
          goto LABEL_29;
        }
        if (v12 < 0x41) {
LABEL_23:
        }
          unsigned int v14 = this;
        else {
          unsigned int v14 = *(llvm::APInt **)this;
        }
        if (*(void *)v14 == a2)
        {
          uint64_t v8 = a3;
          unsigned int v9 = v12;
          uint64_t v10 = 1;
          goto LABEL_13;
        }
LABEL_29:
        if (v7 != 1)
        {
          size_t v16 = (unint64_t **)sub_1CB8F1EEC(a3, v12, 0);
          llvm::APInt::divide(*(llvm::APInt **)this, v7, (uint64_t *)&v20, (const unint64_t *)1, *v16, 0, v17);
          return;
        }
        uint64_t v8 = a3;
        uint64_t v10 = **(void **)this / a2;
        unsigned int v9 = v12;
        goto LABEL_13;
      }
      if (v12 >= 0x41) {
        uint64_t v11 = *(llvm::APInt **)this;
      }
      else {
        uint64_t v11 = this;
      }
    }
    if (*(void *)v11 < a2)
    {
      uint64_t v8 = a3;
      unsigned int v9 = v12;
      goto LABEL_12;
    }
    goto LABEL_22;
  }
  uint64_t v8 = a3;
  unsigned int v9 = *((_DWORD *)this + 2);
LABEL_12:
  uint64_t v10 = 0;
LABEL_13:

  sub_1CB8F1EEC(v8, v9, v10);
}

uint64_t llvm::APInt::sdiv@<X0>(llvm::APInt *this@<X0>, const llvm::APInt *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v6 = *((_DWORD *)this + 2);
  unsigned int v7 = v6 - 1;
  uint64_t v8 = this;
  if (v6 >= 0x41) {
    uint64_t v8 = (llvm::APInt *)(*(void *)this + 8 * (v7 >> 6));
  }
  unint64_t v9 = *(void *)v8;
  unsigned int v10 = *((_DWORD *)a2 + 2);
  uint64_t v11 = *(void *)a2;
  unsigned int v12 = (const llvm::APInt *)(*(void *)a2 + 8 * ((v10 - 1) >> 6));
  if (v10 < 0x41) {
    unsigned int v12 = a2;
  }
  uint64_t v13 = (1 << (v10 - 1)) & *(void *)v12;
  if ((v9 >> v7))
  {
    if (v13)
    {
      unsigned int v39 = *((_DWORD *)this + 2);
      if (v6 > 0x40) {
        operator new[]();
      }
      if (v6) {
        unint64_t v15 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v6;
      }
      else {
        unint64_t v15 = 0;
      }
      uint64_t v38 = v15 & ~*(void *)this;
      llvm::APInt::operator++((uint64_t)&v38);
      unsigned int v41 = v39;
      uint64_t v40 = v38;
      unsigned int v39 = 0;
      unsigned int v16 = *((_DWORD *)a2 + 2);
      unsigned int v35 = v16;
      if (v16 > 0x40) {
        operator new[]();
      }
      if (v16) {
        unint64_t v17 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v16;
      }
      else {
        unint64_t v17 = 0;
      }
      uint64_t v34 = v17 & ~*(void *)a2;
      llvm::APInt::operator++((uint64_t)&v34);
      unsigned int v18 = v35;
      unsigned int v37 = v35;
      uint64_t v19 = v34;
      uint64_t v36 = v34;
      unsigned int v35 = 0;
      uint64_t result = llvm::APInt::udiv((uint64_t)&v40, (const llvm::APInt *)&v36, a3);
      if (v18 >= 0x41 && v19) {
        uint64_t result = MEMORY[0x1D25D9CB0](v19, 0x1000C8000313F17);
      }
      if (v35 >= 0x41)
      {
        uint64_t result = v34;
        if (v34) {
          uint64_t result = MEMORY[0x1D25D9CB0](v34, 0x1000C8000313F17);
        }
      }
      if (v41 >= 0x41)
      {
        uint64_t result = v40;
        if (v40) {
          uint64_t result = MEMORY[0x1D25D9CB0](v40, 0x1000C8000313F17);
        }
      }
      if (v39 >= 0x41)
      {
        uint64_t result = v38;
        if (v38) {
          return MEMORY[0x1D25D9CB0](result, 0x1000C8000313F17);
        }
      }
    }
    else
    {
      unsigned int v31 = *((_DWORD *)this + 2);
      if (v6 > 0x40) {
        operator new[]();
      }
      if (v6) {
        unint64_t v24 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v6;
      }
      else {
        unint64_t v24 = 0;
      }
      uint64_t v30 = v24 & ~*(void *)this;
      llvm::APInt::operator++((uint64_t)&v30);
      unsigned int v41 = v31;
      uint64_t v40 = v30;
      unsigned int v31 = 0;
      llvm::APInt::udiv((uint64_t)&v40, a2, (uint64_t)&v32);
      if (v33 > 0x40)
      {
        llvm::APInt::flipAllBitsSlowCase((uint64_t)&v32);
      }
      else
      {
        if (v33) {
          unint64_t v25 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v33;
        }
        else {
          unint64_t v25 = 0;
        }
        unint64_t v32 = v25 & ~v32;
      }
      uint64_t result = llvm::APInt::operator++((uint64_t)&v32);
      *(_DWORD *)(a3 + 8) = v33;
      *(void *)a3 = v32;
      unsigned int v33 = 0;
      if (v41 >= 0x41)
      {
        uint64_t result = v40;
        if (v40) {
          uint64_t result = MEMORY[0x1D25D9CB0](v40, 0x1000C8000313F17);
        }
      }
      if (v31 >= 0x41)
      {
        uint64_t result = v30;
        if (v30) {
          return MEMORY[0x1D25D9CB0](result, 0x1000C8000313F17);
        }
      }
    }
  }
  else
  {
    if (!v13)
    {
      return llvm::APInt::udiv((uint64_t)this, a2, a3);
    }
    unsigned int v27 = *((_DWORD *)a2 + 2);
    if (v10 > 0x40) {
      operator new[]();
    }
    if (v10) {
      unint64_t v20 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v10;
    }
    else {
      unint64_t v20 = 0;
    }
    uint64_t v26 = v20 & ~v11;
    llvm::APInt::operator++((uint64_t)&v26);
    unsigned int v21 = v27;
    unsigned int v41 = v27;
    uint64_t v22 = v26;
    uint64_t v40 = v26;
    unsigned int v27 = 0;
    llvm::APInt::udiv((uint64_t)this, (const llvm::APInt *)&v40, (uint64_t)&v28);
    if (v29 > 0x40)
    {
      llvm::APInt::flipAllBitsSlowCase((uint64_t)&v28);
    }
    else
    {
      if (v29) {
        unint64_t v23 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v29;
      }
      else {
        unint64_t v23 = 0;
      }
      unint64_t v28 = v23 & ~v28;
    }
    uint64_t result = llvm::APInt::operator++((uint64_t)&v28);
    *(_DWORD *)(a3 + 8) = v29;
    *(void *)a3 = v28;
    unsigned int v29 = 0;
    if (v21 >= 0x41 && v22) {
      uint64_t result = MEMORY[0x1D25D9CB0](v22, 0x1000C8000313F17);
    }
    if (v27 >= 0x41)
    {
      uint64_t result = v26;
      if (v26) {
        return MEMORY[0x1D25D9CB0](result, 0x1000C8000313F17);
      }
    }
  }
  return result;
}

void llvm::APInt::sdiv(llvm::APInt *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v3 = *((_DWORD *)this + 2);
  unsigned int v4 = v3 - 1;
  unint64_t v5 = this;
  if (v3 >= 0x41) {
    unint64_t v5 = (llvm::APInt *)(*(void *)this + 8 * (v4 >> 6));
  }
  if (((*(void *)v5 >> v4) & 1) == 0)
  {
    if ((a2 & 0x8000000000000000) != 0)
    {
      llvm::APInt::udiv(this, -(uint64_t)a2, (uint64_t)&v10);
      sub_1CBA14940((uint64_t)&v10);
      llvm::APInt::operator++((uint64_t)&v10);
      *(_DWORD *)(a3 + 8) = v11;
      *(void *)a3 = v10;
    }
    else
    {
      llvm::APInt::udiv(this, a2, a3);
    }
    return;
  }
  if ((a2 & 0x8000000000000000) == 0)
  {
    unsigned int v13 = *((_DWORD *)this + 2);
    if (v3 > 0x40) {
      operator new[]();
    }
    uint64_t v12 = *(void *)this;
    sub_1CBA14940((uint64_t)&v12);
    llvm::APInt::operator++((uint64_t)&v12);
    unsigned int v19 = v13;
    uint64_t v18 = v12;
    unsigned int v13 = 0;
    llvm::APInt::udiv((llvm::APInt *)&v18, a2, (uint64_t)&v14);
    sub_1CBA14940((uint64_t)&v14);
    llvm::APInt::operator++((uint64_t)&v14);
    *(_DWORD *)(a3 + 8) = v15;
    *(void *)a3 = v14;
    int v15 = 0;
    if (v19 >= 0x41 && v18) {
      MEMORY[0x1D25D9CB0](v18, 0x1000C8000313F17);
    }
    if (v13 < 0x41) {
      return;
    }
    uint64_t v7 = v12;
    if (!v12) {
      return;
    }
LABEL_27:
    MEMORY[0x1D25D9CB0](v7, 0x1000C8000313F17);
    return;
  }
  unsigned int v17 = *((_DWORD *)this + 2);
  if (v3 > 0x40) {
    operator new[]();
  }
  uint64_t v16 = *(void *)this;
  sub_1CBA14940((uint64_t)&v16);
  llvm::APInt::operator++((uint64_t)&v16);
  unsigned int v19 = v17;
  uint64_t v18 = v16;
  unsigned int v17 = 0;
  llvm::APInt::udiv((llvm::APInt *)&v18, -(uint64_t)a2, a3);
  if (v19 >= 0x41 && v18) {
    MEMORY[0x1D25D9CB0](v18, 0x1000C8000313F17);
  }
  if (v17 >= 0x41)
  {
    uint64_t v7 = v16;
    if (v16) {
      goto LABEL_27;
    }
  }
}

void llvm::APInt::urem(llvm::APInt *this@<X0>, const llvm::APInt *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v3 = *((_DWORD *)this + 2);
  if (v3 <= 0x40)
  {
    uint64_t v4 = *(void *)this % *(void *)a2;
    *(_DWORD *)(a3 + 8) = v3;
    unint64_t v5 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v3;
    if (!v3) {
      unint64_t v5 = 0;
    }
    *(void *)a3 = v5 & v4;
    return;
  }
  uint64_t v7 = (const unint64_t *)(((unint64_t)(v3 - sub_1CD0442FC((uint64_t)this)) + 63) >> 6);
  int v8 = *((_DWORD *)a2 + 2);
  unint64_t v9 = (const void **)a2;
  int v10 = sub_1CD0442FC((uint64_t)a2);
  if (!v7 || (uint64_t v11 = (v8 - v10), v11 == 1))
  {
    uint64_t v12 = a3;
    unsigned int v13 = *((_DWORD *)this + 2);
LABEL_8:
    uint64_t v14 = 0;
LABEL_9:
    sub_1CB8F1EEC(v12, v13, v14);
    return;
  }
  int v15 = (const unint64_t *)((unint64_t)(v11 + 63) >> 6);
  if (v7 < v15) {
    goto LABEL_13;
  }
  uint64_t v16 = *((unsigned int *)this + 2);
  if (v16 > 0x40)
  {
    unsigned int v17 = *(void **)this;
    uint64_t v18 = *v9;
    unint64_t v19 = (unint64_t)(v16 + 63) >> 3;
    unint64_t v20 = v19 & 0x3FFFFFF8;
    while (v20)
    {
      unint64_t v21 = *(void *)((char *)v17 + v20 - 8);
      unint64_t v22 = *(void *)((char *)v18 + v20 - 8);
      v20 -= 8;
      if (v21 != v22)
      {
        if (v21 <= v22) {
          goto LABEL_13;
        }
        break;
      }
    }
    if (!memcmp(*(const void **)this, *v9, v19 & 0x3FFFFFF8)) {
      goto LABEL_19;
    }
  }
  else
  {
    unsigned int v17 = *(void **)this;
    uint64_t v18 = *v9;
    if (*(void *)this < (unint64_t)*v9)
    {
LABEL_13:
      sub_1CD0463BC(a3, (uint64_t)this);
      return;
    }
    if (*(const void **)this == *v9)
    {
LABEL_19:
      uint64_t v12 = a3;
      unsigned int v13 = v16;
      goto LABEL_8;
    }
  }
  if (v7 == 1)
  {
    uint64_t v14 = *v17 % *v18;
    uint64_t v12 = a3;
    unsigned int v13 = v16;
    goto LABEL_9;
  }
  unint64_t v23 = (unint64_t **)sub_1CB8F1EEC(a3, v16, 0);
  unint64_t v25 = (uint64_t *)*v9;
  uint64_t v26 = *v23;
  unsigned int v27 = *(llvm::APInt **)this;

  llvm::APInt::divide(v27, v7, v25, v15, 0, v26, v24);
}

unint64_t llvm::APInt::urem(uint64_t **this, unint64_t a2)
{
  unint64_t v15 = a2;
  unsigned int v2 = *((_DWORD *)this + 2);
  if (v2 <= 0x40) {
    return (unint64_t)*this % a2;
  }
  int v6 = sub_1CD0442FC((uint64_t)this);
  unint64_t result = 0;
  if (a2 != 1)
  {
    unint64_t v7 = a2;
    int v8 = (const unint64_t *)(((unint64_t)(v2 - v6) + 63) >> 6);
    if (v8)
    {
      unsigned int v9 = *((_DWORD *)this + 2);
      if (v9 < 0x41) {
        goto LABEL_7;
      }
      int v11 = sub_1CD0442FC((uint64_t)this);
      unsigned int v12 = *((_DWORD *)this + 2);
      if (v9 - v11 > 0x40)
      {
        int v10 = this;
        if (v12 < 0x41) {
          goto LABEL_8;
        }
      }
      else
      {
        if (v12 <= 0x40)
        {
LABEL_7:
          int v10 = this;
          unint64_t result = (unint64_t)*this;
          if ((unint64_t)*this < v7) {
            return result;
          }
          goto LABEL_8;
        }
        unint64_t result = **this;
        if (result < v7) {
          return result;
        }
      }
      if (v12 - sub_1CD0442FC((uint64_t)this) > 0x40)
      {
LABEL_18:
        if (v8 == 1) {
          return **this % v7;
        }
        unint64_t v14 = 0;
        llvm::APInt::divide((llvm::APInt *)*this, v8, (uint64_t *)&v15, (const unint64_t *)1, 0, &v14, v5);
        return v14;
      }
      int v10 = this;
      if (*((_DWORD *)this + 2) >= 0x41u) {
        int v10 = (uint64_t **)*this;
      }
LABEL_8:
      if (*v10 == (uint64_t *)v7) {
        return 0;
      }
      goto LABEL_18;
    }
  }
  return result;
}

void llvm::APInt::srem(llvm::APInt *this@<X0>, const llvm::APInt *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v5 = *((_DWORD *)this + 2);
  unsigned int v6 = v5 - 1;
  unint64_t v7 = this;
  if (v5 >= 0x41) {
    unint64_t v7 = (llvm::APInt *)(*(void *)this + 8 * (v6 >> 6));
  }
  unint64_t v8 = *(void *)v7;
  unsigned int v9 = *((_DWORD *)a2 + 2);
  int v10 = (const llvm::APInt *)(*(void *)a2 + 8 * ((v9 - 1) >> 6));
  if (v9 < 0x41) {
    int v10 = a2;
  }
  uint64_t v11 = (1 << (v9 - 1)) & *(void *)v10;
  if ((v8 >> v6))
  {
    if (v11)
    {
      unsigned int v28 = *((_DWORD *)this + 2);
      if (v5 > 0x40) {
        operator new[]();
      }
      unint64_t v27 = *(void *)this;
      sub_1CBA14940((uint64_t)&v27);
      llvm::APInt::operator++((uint64_t)&v27);
      unsigned int v30 = v28;
      unint64_t v29 = v27;
      unsigned int v28 = 0;
      unsigned int v24 = *((_DWORD *)a2 + 2);
      if (v24 > 0x40) {
        operator new[]();
      }
      uint64_t v23 = *(void *)a2;
      sub_1CBA14940((uint64_t)&v23);
      llvm::APInt::operator++((uint64_t)&v23);
      unsigned int v26 = v24;
      uint64_t v25 = v23;
      unsigned int v24 = 0;
      llvm::APInt::urem((llvm::APInt *)&v29, (const llvm::APInt *)&v25, (uint64_t)&v31);
      sub_1CBA14940((uint64_t)&v31);
      llvm::APInt::operator++((uint64_t)&v31);
      *(_DWORD *)(a3 + 8) = v32;
      *(void *)a3 = v31;
      int v32 = 0;
      if (v26 >= 0x41 && v25) {
        MEMORY[0x1D25D9CB0](v25, 0x1000C8000313F17);
      }
      if (v24 >= 0x41 && v23) {
        MEMORY[0x1D25D9CB0](v23, 0x1000C8000313F17);
      }
      if (v30 >= 0x41 && v29) {
        MEMORY[0x1D25D9CB0](v29, 0x1000C8000313F17);
      }
      if (v28 < 0x41) {
        return;
      }
      unint64_t v15 = v27;
      if (!v27) {
        return;
      }
    }
    else
    {
      unsigned int v20 = *((_DWORD *)this + 2);
      if (v5 > 0x40) {
        operator new[]();
      }
      if (v5) {
        unint64_t v12 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v5;
      }
      else {
        unint64_t v12 = 0;
      }
      unint64_t v19 = v12 & ~*(void *)this;
      llvm::APInt::operator++((uint64_t)&v19);
      unsigned int v30 = v20;
      unint64_t v29 = v19;
      unsigned int v20 = 0;
      llvm::APInt::urem((llvm::APInt *)&v29, a2, (uint64_t)&v21);
      if (v22 > 0x40)
      {
        llvm::APInt::flipAllBitsSlowCase((uint64_t)&v21);
      }
      else
      {
        if (v22) {
          unint64_t v13 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v22;
        }
        else {
          unint64_t v13 = 0;
        }
        unint64_t v21 = v13 & ~v21;
      }
      llvm::APInt::operator++((uint64_t)&v21);
      *(_DWORD *)(a3 + 8) = v22;
      *(void *)a3 = v21;
      unsigned int v22 = 0;
      if (v30 >= 0x41 && v29) {
        MEMORY[0x1D25D9CB0](v29, 0x1000C8000313F17);
      }
      if (v20 < 0x41) {
        return;
      }
      unint64_t v15 = v19;
      if (!v19) {
        return;
      }
    }
LABEL_54:
    MEMORY[0x1D25D9CB0](v15, 0x1000C8000313F17);
    return;
  }
  if (!v11)
  {
    llvm::APInt::urem(this, a2, a3);
    return;
  }
  unint64_t v14 = *(void *)a2;
  unsigned int v18 = *((_DWORD *)a2 + 2);
  if (v9 >= 0x41) {
    operator new[]();
  }
  unint64_t v17 = v14;
  sub_1CBA14940((uint64_t)&v17);
  llvm::APInt::operator++((uint64_t)&v17);
  unsigned int v30 = v18;
  unint64_t v29 = v17;
  unsigned int v18 = 0;
  llvm::APInt::urem(this, (const llvm::APInt *)&v29, a3);
  if (v30 >= 0x41 && v29) {
    MEMORY[0x1D25D9CB0](v29, 0x1000C8000313F17);
  }
  if (v18 >= 0x41)
  {
    unint64_t v15 = v17;
    if (v17) {
      goto LABEL_54;
    }
  }
}

unint64_t llvm::APInt::srem(llvm::APInt *this, unint64_t a2)
{
  unint64_t v2 = a2;
  unsigned int v3 = *((_DWORD *)this + 2);
  unsigned int v4 = v3 - 1;
  unsigned int v5 = this;
  if (v3 >= 0x41) {
    unsigned int v5 = (llvm::APInt *)(*(void *)this + 8 * (v4 >> 6));
  }
  if ((*(void *)v5 >> v4))
  {
    if ((a2 & 0x8000000000000000) != 0)
    {
      unsigned int v16 = *((_DWORD *)this + 2);
      if (v3 > 0x40) {
        operator new[]();
      }
      if (v3) {
        unint64_t v7 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v3;
      }
      else {
        unint64_t v7 = 0;
      }
      unint64_t v15 = (uint64_t *)(v7 & ~*(void *)this);
      llvm::APInt::operator++((uint64_t)&v15);
      unsigned int v18 = v16;
      unint64_t v17 = v15;
      unsigned int v16 = 0;
      unint64_t v12 = llvm::APInt::urem(&v17, -(uint64_t)v2);
      if (v18 >= 0x41 && v17) {
        MEMORY[0x1D25D9CB0](v17, 0x1000C8000313F17);
      }
      uint64_t v9 = -(uint64_t)v12;
      if (v16 < 0x41) {
        return v9;
      }
      int v10 = v15;
      if (!v15) {
        return v9;
      }
    }
    else
    {
      unsigned int v14 = *((_DWORD *)this + 2);
      if (v3 > 0x40) {
        operator new[]();
      }
      if (v3) {
        unint64_t v6 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v3;
      }
      else {
        unint64_t v6 = 0;
      }
      unint64_t v13 = (uint64_t *)(v6 & ~*(void *)this);
      llvm::APInt::operator++((uint64_t)&v13);
      unsigned int v18 = v14;
      unint64_t v17 = v13;
      unsigned int v14 = 0;
      unint64_t v8 = llvm::APInt::urem(&v17, v2);
      if (v18 >= 0x41 && v17) {
        MEMORY[0x1D25D9CB0](v17, 0x1000C8000313F17);
      }
      uint64_t v9 = -(uint64_t)v8;
      if (v14 < 0x41) {
        return v9;
      }
      int v10 = v13;
      if (!v13) {
        return v9;
      }
    }
    MEMORY[0x1D25D9CB0](v10, 0x1000C8000313F17);
    return v9;
  }
  if ((a2 & 0x8000000000000000) != 0) {
    a2 = -(uint64_t)a2;
  }

  return llvm::APInt::urem((uint64_t **)this, a2);
}

unsigned int *sub_1CD042A34(unsigned int *a1, uint64_t a2)
{
  uint64_t v3 = a1[2];
  if (v3 > 0x40)
  {
    **(void **)a1 = a2;
    bzero((void *)(*(void *)a1 + 8), (((unint64_t)(v3 + 63) >> 3) - 8) & 0xFFFFFFF8);
  }
  else
  {
    if (v3) {
      unint64_t v4 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v3;
    }
    else {
      unint64_t v4 = 0;
    }
    *(void *)a1 = v4 & a2;
  }
  return a1;
}

void llvm::APInt::udivrem(llvm::APInt *this, unint64_t a2, void **a3, llvm::APInt *a4, unint64_t *a5)
{
  unint64_t v36 = a2;
  uint64_t v9 = *((unsigned int *)this + 2);
  if (v9 > 0x40)
  {
    int v10 = 0;
    unint64_t v11 = (unint64_t)(v9 + 63) >> 6;
    unint64_t v12 = *(llvm::APInt **)this;
    uint64_t v13 = v11;
    do
    {
      BOOL v14 = v13-- < 1;
      if (v14) {
        break;
      }
      unint64_t v15 = *((void *)v12 + v13);
      v10 += __clz(v15);
    }
    while (!v15);
    int v16 = v9 | 0xFFFFFFC0;
    if ((v9 & 0x3F) == 0) {
      int v16 = 0;
    }
    unint64_t v17 = ((unint64_t)(v9 - v10 - v16) + 63) >> 6;
    if (v17)
    {
      if (a2 == 1)
      {
        sub_1CD828004(a3, (uint64_t)this);
LABEL_41:
        *(void *)a4 = 0;
        return;
      }
      int v18 = 0;
      int64_t v19 = (unint64_t)(v9 + 63) >> 6;
      do
      {
        BOOL v14 = v19-- < 1;
        if (v14) {
          break;
        }
        unint64_t v20 = *((void *)v12 + v19);
        v18 += __clz(v20);
      }
      while (!v20);
      if ((v9 - (v16 + v18)) < 0x41 && *(void *)v12 < a2)
      {
        *(void *)a4 = *(void *)v12;
        operator new[]();
      }
      int v21 = 0;
      int64_t v22 = (unint64_t)(v9 + 63) >> 6;
      do
      {
        BOOL v14 = v22-- < 1;
        if (v14) {
          break;
        }
        unint64_t v23 = *((void *)v12 + v22);
        v21 += __clz(v23);
      }
      while (!v23);
      if ((v9 - (v16 + v21)) > 0x40 || *(void *)v12 != a2)
      {
        llvm::APInt::reallocate((uint64_t)a3, v9);
        uint64_t v25 = *(llvm::APInt **)this;
        if (v17 == 1)
        {
          uint64_t v27 = *(void *)v25;
          uint64_t v28 = *((unsigned int *)a3 + 2);
          unint64_t v29 = *(void *)v25 / a2;
          if (v28 > 0x40)
          {
            *(void *)*a3 = v29;
            bzero((char *)*a3 + 8, (((unint64_t)(v28 + 63) >> 3) - 8) & 0xFFFFFFF8);
          }
          else
          {
            if (v28) {
              unint64_t v30 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v28;
            }
            else {
              unint64_t v30 = 0;
            }
            *a3 = (void *)(v30 & v29);
          }
          *(void *)a4 = v27 - v29 * a2;
        }
        else
        {
          llvm::APInt::divide(v25, (const unint64_t *)v17, (uint64_t *)&v36, (const unint64_t *)1, (unint64_t *)*a3, (unint64_t *)a4, v24);
          unsigned int v26 = (char *)*a3 + 8 * v17;
          bzero(v26, (8 * (v11 - v17)));
        }
        return;
      }
      unsigned int v32 = *((_DWORD *)this + 2);
      uint64_t v33 = 1;
    }
    else
    {
      unsigned int v32 = *((_DWORD *)this + 2);
      uint64_t v33 = 0;
    }
    sub_1CB8F1EEC((uint64_t)&v34, v32, v33);
    if (*((_DWORD *)a3 + 2) >= 0x41u && *a3) {
      MEMORY[0x1D25D9CB0](*a3, 0x1000C8000313F17);
    }
    *a3 = v34;
    *((_DWORD *)a3 + 2) = v35;
    goto LABEL_41;
  }
  unint64_t v31 = *(void *)this / a2;
  *(void *)a4 = *(void *)this % a2;
  sub_1CB8F1EEC((uint64_t)&v34, v9, v31);
  if (*((_DWORD *)a3 + 2) >= 0x41u && *a3) {
    MEMORY[0x1D25D9CB0](*a3, 0x1000C8000313F17);
  }
  *a3 = v34;
  *((_DWORD *)a3 + 2) = v35;
}

void llvm::APInt::sdivrem(llvm::APInt *this, const llvm::APInt *a2, const llvm::APInt *a3, llvm::APInt *a4, llvm::APInt *a5)
{
  unsigned int v9 = *((_DWORD *)this + 2);
  uint64_t v10 = *(void *)this;
  unint64_t v11 = (llvm::APInt *)(*(void *)this + 8 * ((v9 - 1) >> 6));
  if (v9 < 0x41) {
    unint64_t v11 = this;
  }
  unint64_t v12 = *(void *)v11;
  unsigned int v13 = *((_DWORD *)a2 + 2);
  uint64_t v14 = *(void *)a2;
  unint64_t v15 = (const llvm::APInt *)(*(void *)a2 + 8 * ((v13 - 1) >> 6));
  if (v13 < 0x41) {
    unint64_t v15 = a2;
  }
  uint64_t v16 = (1 << (v13 - 1)) & *(void *)v15;
  if ((v12 >> (v9 - 1)))
  {
    if (v16)
    {
      unsigned int v47 = *((_DWORD *)this + 2);
      if (v9 > 0x40) {
        operator new[]();
      }
      uint64_t v25 = ~v10;
      if (v9) {
        unint64_t v26 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v9;
      }
      else {
        unint64_t v26 = 0;
      }
      unint64_t v46 = v26 & v25;
      llvm::APInt::operator++((uint64_t)&v46);
      unsigned int v49 = v47;
      unint64_t v48 = v46;
      unsigned int v47 = 0;
      unsigned int v27 = *((_DWORD *)a2 + 2);
      unsigned int v43 = v27;
      if (v27 > 0x40) {
        operator new[]();
      }
      if (v27) {
        unint64_t v28 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v27;
      }
      else {
        unint64_t v28 = 0;
      }
      unint64_t v42 = v28 & ~*(void *)a2;
      llvm::APInt::operator++((uint64_t)&v42);
      unsigned int v29 = v43;
      unsigned int v45 = v43;
      unint64_t v30 = v42;
      unint64_t v44 = v42;
      unsigned int v43 = 0;
      llvm::APInt::udivrem((llvm::APInt *)&v48, (const llvm::APInt *)&v44, a3, a4, v31);
      if (v29 >= 0x41 && v30) {
        MEMORY[0x1D25D9CB0](v30, 0x1000C8000313F17);
      }
      if (v43 >= 0x41 && v42) {
        MEMORY[0x1D25D9CB0](v42, 0x1000C8000313F17);
      }
      if (v49 >= 0x41 && v48) {
        MEMORY[0x1D25D9CB0](v48, 0x1000C8000313F17);
      }
      if (v47 >= 0x41 && v46) {
        MEMORY[0x1D25D9CB0](v46, 0x1000C8000313F17);
      }
    }
    else
    {
      unsigned int v41 = *((_DWORD *)this + 2);
      if (v9 > 0x40) {
        operator new[]();
      }
      uint64_t v17 = ~v10;
      if (v9) {
        unint64_t v18 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v9;
      }
      else {
        unint64_t v18 = 0;
      }
      unint64_t v40 = v18 & v17;
      llvm::APInt::operator++((uint64_t)&v40);
      unsigned int v49 = v41;
      unint64_t v48 = v40;
      unsigned int v41 = 0;
      llvm::APInt::udivrem((llvm::APInt *)&v48, a2, a3, a4, v19);
      if (v49 >= 0x41 && v48) {
        MEMORY[0x1D25D9CB0](v48, 0x1000C8000313F17);
      }
      if (v41 >= 0x41 && v40) {
        MEMORY[0x1D25D9CB0](v40, 0x1000C8000313F17);
      }
      unsigned int v20 = *((_DWORD *)a3 + 2);
      if (v20 > 0x40)
      {
        llvm::APInt::flipAllBitsSlowCase((uint64_t)a3);
      }
      else
      {
        if (v20) {
          unint64_t v21 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v20;
        }
        else {
          unint64_t v21 = 0;
        }
        *(void *)a3 = v21 & ~*(void *)a3;
      }
      llvm::APInt::operator++((uint64_t)a3);
    }
    unsigned int v22 = *((_DWORD *)a4 + 2);
    if (v22 > 0x40)
    {
      llvm::APInt::flipAllBitsSlowCase((uint64_t)a4);
    }
    else
    {
      if (v22) {
        unint64_t v23 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v22;
      }
      else {
        unint64_t v23 = 0;
      }
      *(void *)a4 = v23 & ~*(void *)a4;
    }
    unsigned int v24 = a4;
    goto LABEL_27;
  }
  if (v16)
  {
    unsigned int v39 = *((_DWORD *)a2 + 2);
    if (v13 > 0x40) {
      operator new[]();
    }
    unint64_t v32 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v13;
    if (!v13) {
      unint64_t v32 = 0;
    }
    unint64_t v38 = v32 & ~v14;
    llvm::APInt::operator++((uint64_t)&v38);
    unsigned int v33 = v39;
    unsigned int v49 = v39;
    unint64_t v34 = v38;
    unint64_t v48 = v38;
    unsigned int v39 = 0;
    llvm::APInt::udivrem(this, (const llvm::APInt *)&v48, a3, a4, v35);
    if (v33 >= 0x41 && v34) {
      MEMORY[0x1D25D9CB0](v34, 0x1000C8000313F17);
    }
    if (v39 >= 0x41 && v38) {
      MEMORY[0x1D25D9CB0](v38, 0x1000C8000313F17);
    }
    unsigned int v36 = *((_DWORD *)a3 + 2);
    if (v36 > 0x40)
    {
      llvm::APInt::flipAllBitsSlowCase((uint64_t)a3);
    }
    else
    {
      if (v36) {
        unint64_t v37 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v36;
      }
      else {
        unint64_t v37 = 0;
      }
      *(void *)a3 = v37 & ~*(void *)a3;
    }
    unsigned int v24 = a3;
LABEL_27:
    llvm::APInt::operator++((uint64_t)v24);
    return;
  }

  llvm::APInt::udivrem(this, a2, a3, a4, a5);
}

void llvm::APInt::sdivrem(llvm::APInt *this, uint64_t a2, void **a3, llvm::APInt *a4, unint64_t *a5)
{
  uint64_t v27 = *(void *)a4;
  unsigned int v8 = *((_DWORD *)this + 2);
  uint64_t v9 = *(void *)this;
  uint64_t v10 = (llvm::APInt *)(*(void *)this + 8 * ((v8 - 1) >> 6));
  if (v8 < 0x41) {
    uint64_t v10 = this;
  }
  if ((*(void *)v10 >> (v8 - 1)))
  {
    if (a2 < 0)
    {
      unsigned int v24 = *((_DWORD *)this + 2);
      if (v8 > 0x40) {
        operator new[]();
      }
      uint64_t v13 = ~v9;
      if (v8) {
        unint64_t v14 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v8;
      }
      else {
        unint64_t v14 = 0;
      }
      unint64_t v23 = v14 & v13;
      llvm::APInt::operator++((uint64_t)&v23);
      unsigned int v26 = v24;
      unint64_t v25 = v23;
      unsigned int v24 = 0;
      llvm::APInt::udivrem((llvm::APInt *)&v25, -a2, a3, (llvm::APInt *)&v27, v20);
      if (v26 >= 0x41 && v25) {
        MEMORY[0x1D25D9CB0](v25, 0x1000C8000313F17);
      }
      if (v24 >= 0x41 && v23) {
        MEMORY[0x1D25D9CB0](v23, 0x1000C8000313F17);
      }
    }
    else
    {
      unsigned int v22 = *((_DWORD *)this + 2);
      if (v8 > 0x40) {
        operator new[]();
      }
      uint64_t v11 = ~v9;
      if (v8) {
        unint64_t v12 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v8;
      }
      else {
        unint64_t v12 = 0;
      }
      unint64_t v21 = v12 & v11;
      llvm::APInt::operator++((uint64_t)&v21);
      unsigned int v26 = v22;
      unint64_t v25 = v21;
      unsigned int v22 = 0;
      llvm::APInt::udivrem((llvm::APInt *)&v25, a2, a3, (llvm::APInt *)&v27, v15);
      if (v26 >= 0x41 && v25) {
        MEMORY[0x1D25D9CB0](v25, 0x1000C8000313F17);
      }
      if (v22 >= 0x41 && v21) {
        MEMORY[0x1D25D9CB0](v21, 0x1000C8000313F17);
      }
      unsigned int v16 = *((_DWORD *)a3 + 2);
      if (v16 > 0x40)
      {
        llvm::APInt::flipAllBitsSlowCase((uint64_t)a3);
      }
      else
      {
        if (v16) {
          unint64_t v17 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v16;
        }
        else {
          unint64_t v17 = 0;
        }
        *a3 = (void *)(v17 & ~(unint64_t)*a3);
      }
      llvm::APInt::operator++((uint64_t)a3);
    }
    uint64_t v27 = -v27;
  }
  else if (a2 < 0)
  {
    llvm::APInt::udivrem(this, -a2, a3, (llvm::APInt *)&v27, a5);
    unsigned int v18 = *((_DWORD *)a3 + 2);
    if (v18 > 0x40)
    {
      llvm::APInt::flipAllBitsSlowCase((uint64_t)a3);
    }
    else
    {
      if (v18) {
        unint64_t v19 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v18;
      }
      else {
        unint64_t v19 = 0;
      }
      *a3 = (void *)(v19 & ~(unint64_t)*a3);
    }
    llvm::APInt::operator++((uint64_t)a3);
  }
  else
  {
    llvm::APInt::udivrem(this, a2, a3, (llvm::APInt *)&v27, a5);
  }
  *(void *)a4 = v27;
}

uint64_t llvm::APInt::sadd_ov@<X0>(llvm::APInt *this@<X0>, const llvm::APInt *a2@<X1>, BOOL *a3@<X2>, uint64_t a4@<X8>)
{
  unsigned int v4 = *((_DWORD *)this + 2);
  if (v4 >= 0x41) {
    operator new[]();
  }
  uint64_t v5 = *(void *)this;
  uint64_t v6 = *(void *)a2;
  uint64_t v7 = *(void *)a2 + *(void *)this;
  unint64_t v8 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v4;
  if (!v4) {
    unint64_t v8 = 0;
  }
  *(_DWORD *)(a4 + 8) = v4;
  *(void *)a4 = v8 & v7;
  uint64_t v9 = 1 << (v4 - 1);
  unsigned int v10 = *((_DWORD *)a2 + 2);
  uint64_t result = v10 - 1;
  unint64_t v12 = (const llvm::APInt *)(v6 + 8 * (result >> 6));
  if (v10 < 0x41) {
    unint64_t v12 = a2;
  }
  if (((v5 & v9) == 0) != (((*(void *)v12 >> (v10 - 1)) & 1) == 0)) {
    BOOL v13 = 0;
  }
  else {
    BOOL v13 = ((*(void *)a4 & (1 << (v4 - 1))) == 0) ^ ((v5 & v9) == 0);
  }
  *a3 = v13;
  return result;
}

uint64_t llvm::APInt::uadd_ov@<X0>(uint64_t this@<X0>, const llvm::APInt *a2@<X1>, BOOL *a3@<X2>, uint64_t a4@<X8>)
{
  unsigned int v4 = *(_DWORD *)(this + 8);
  if (v4 >= 0x41) {
    operator new[]();
  }
  unint64_t v5 = *(void *)a2;
  unint64_t v6 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v4;
  if (!v4) {
    unint64_t v6 = 0;
  }
  unint64_t v7 = v6 & (*(void *)a2 + *(void *)this);
  *(_DWORD *)(a4 + 8) = v4;
  *(void *)a4 = v7;
  *a3 = v7 < v5;
  return this;
}

uint64_t llvm::APInt::ssub_ov@<X0>(llvm::APInt *this@<X0>, const llvm::APInt *a2@<X1>, BOOL *a3@<X2>, uint64_t a4@<X8>)
{
  unsigned int v4 = *((_DWORD *)this + 2);
  if (v4 >= 0x41) {
    operator new[]();
  }
  uint64_t v5 = *(void *)this;
  uint64_t v6 = *(void *)a2;
  uint64_t v7 = *(void *)this - *(void *)a2;
  unint64_t v8 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v4;
  if (!v4) {
    unint64_t v8 = 0;
  }
  *(_DWORD *)(a4 + 8) = v4;
  *(void *)a4 = v8 & v7;
  unsigned int v9 = *((_DWORD *)a2 + 2);
  uint64_t result = v9 - 1;
  uint64_t v11 = (const llvm::APInt *)(v6 + 8 * (result >> 6));
  if (v9 < 0x41) {
    uint64_t v11 = a2;
  }
  if (((v5 & (1 << (v4 - 1))) == 0) == (((*(void *)v11 >> (v9 - 1)) & 1) == 0)) {
    BOOL v12 = 0;
  }
  else {
    BOOL v12 = ((*(void *)a4 & (1 << (v4 - 1))) == 0) ^ ((v5 & (1 << (v4 - 1))) == 0);
  }
  *a3 = v12;
  return result;
}

uint64_t llvm::APInt::usub_ov@<X0>(uint64_t this@<X0>, const llvm::APInt *a2@<X1>, BOOL *a3@<X2>, uint64_t a4@<X8>)
{
  unsigned int v4 = *(_DWORD *)(this + 8);
  if (v4 >= 0x41) {
    operator new[]();
  }
  unint64_t v5 = *(void *)this;
  unint64_t v6 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v4;
  if (!v4) {
    unint64_t v6 = 0;
  }
  unint64_t v7 = v6 & (*(void *)this - *(void *)a2);
  *(_DWORD *)(a4 + 8) = v4;
  *(void *)a4 = v7;
  *a3 = v7 > v5;
  return this;
}

BOOL sub_1CD043DA0(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 8);
  if (!v1) {
    return 1;
  }
  if (v1 >= 0x41)
  {
    uint64_t v4 = 0;
    unint64_t v5 = (unint64_t)(v1 + 63) >> 6;
    unint64_t v6 = *(void **)a1;
    int v7 = v5 << 6;
    unint64_t v8 = v5 << 6;
    while (*v6 == -1)
    {
      ++v6;
      v4 += 64;
      if (v8 == v4) {
        return v7 == v1;
      }
    }
    int v7 = __clz(__rbit64(~*v6)) + v4;
    return v7 == v1;
  }
  else
  {
    return *(void *)a1 == 0xFFFFFFFFFFFFFFFFLL >> -(char)v1;
  }
}

uint64_t llvm::APInt::smul_ov@<X0>(const void **this@<X0>, const llvm::APInt *a2@<X1>, BOOL *a3@<X2>, llvm::APInt *a4@<X8>)
{
  uint64_t result = llvm::APInt::operator*((uint64_t)this, a2, (uint64_t)a4);
  unsigned int v9 = *((_DWORD *)a2 + 2);
  if (v9 >= 0x41)
  {
    int v11 = *((_DWORD *)a2 + 2);
    uint64_t result = sub_1CD0442FC((uint64_t)a2);
    if ((v11 - result) > 0x40) {
      goto LABEL_6;
    }
    unsigned int v9 = *((_DWORD *)a2 + 2);
  }
  if (v9 >= 0x41) {
    unsigned int v10 = *(const llvm::APInt **)a2;
  }
  else {
    unsigned int v10 = a2;
  }
  if (!*(void *)v10)
  {
    *a3 = 0;
    return result;
  }
LABEL_6:
  llvm::APInt::sdiv(a4, a2, (uint64_t)&__s1);
  if (v13 > 0x40)
  {
    if (!memcmp(__s1, *this, (((unint64_t)v13 + 63) >> 3) & 0x3FFFFFF8))
    {
LABEL_8:
      uint64_t result = sub_1CB8C0D18((uint64_t)this);
      if (result) {
        uint64_t result = sub_1CD043DA0((uint64_t)a2);
      }
      goto LABEL_10;
    }
  }
  else if (__s1 == *this)
  {
    goto LABEL_8;
  }
  uint64_t result = 1;
LABEL_10:
  *a3 = result;
  if (v13 >= 0x41)
  {
    uint64_t result = (uint64_t)__s1;
    if (__s1) {
      return MEMORY[0x1D25D9CB0](__s1, 0x1000C8000313F17);
    }
  }
  return result;
}

unint64_t llvm::APInt::umul_ov@<X0>(llvm::APInt *this@<X0>, const llvm::APInt *a2@<X1>, BOOL *a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t v6 = this;
  uint64_t v8 = *((unsigned int *)this + 2);
  if (v8 > 0x40)
  {
    int v20 = 0;
    int64_t v21 = (unint64_t)(v8 + 63) >> 6;
    do
    {
      BOOL v22 = v21-- < 1;
      if (v22) {
        break;
      }
      unint64_t v23 = *(void *)(*(void *)this + 8 * v21);
      v20 += __clz(v23);
    }
    while (!v23);
    int v24 = v8 | 0xFFFFFFC0;
    if ((v8 & 0x3F) == 0) {
      int v24 = 0;
    }
    int v9 = v20 + v24;
  }
  else
  {
    int v9 = v8 + __clz(*(void *)this) - 64;
  }
  uint64_t v10 = *((unsigned int *)a2 + 2);
  if (v10 > 0x40)
  {
    int v25 = 0;
    int64_t v26 = (unint64_t)(v10 + 63) >> 6;
    do
    {
      BOOL v22 = v26-- < 1;
      if (v22) {
        break;
      }
      unint64_t v27 = *(void *)(*(void *)a2 + 8 * v26);
      v25 += __clz(v27);
    }
    while (!v27);
    if ((v10 & 0x3F) != 0) {
      int v28 = v10 | 0xFFFFFFC0;
    }
    else {
      int v28 = 0;
    }
    int v11 = v25 + v28;
  }
  else
  {
    int v11 = v10 + __clz(*(void *)a2) - 64;
  }
  if (v9 + v11 + 2 <= v8)
  {
    *a3 = 1;
    return llvm::APInt::operator*((uint64_t)this, a2, a4);
  }
  sub_1CB8F02F4((uint64_t)this, 1, (uint64_t)&v53);
  unint64_t result = llvm::APInt::operator*((uint64_t)&v53, a2, a4);
  if (v54 >= 0x41)
  {
    unint64_t result = v53;
    if (v53) {
      unint64_t result = MEMORY[0x1D25D9CB0](v53, 0x1000C8000313F17);
    }
  }
  uint64_t v13 = *(unsigned int *)(a4 + 8);
  unsigned int v14 = v13 - 1;
  unint64_t v15 = *(void *)a4;
  if ((v13 - 2) > 0x3E)
  {
    unint64_t v44 = (void *)(v15 + 8 * (v14 >> 6));
    if (v13 < 0x41) {
      unint64_t v44 = (void *)a4;
    }
    *a3 = (*v44 >> v14) & 1;
    if (v13 <= 0x40)
    {
      if (v13 == 1)
      {
        uint64_t v45 = 0;
        unint64_t v46 = 1;
      }
      else
      {
        uint64_t v45 = 2 * v15;
        unint64_t v46 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v13;
        if (!v13) {
          unint64_t v46 = 0;
        }
      }
      unint64_t v15 = v46 & v45;
      goto LABEL_13;
    }
    unint64_t v29 = (unint64_t)(v13 + 63) >> 6;
    unint64_t v47 = v15 + 8 * v29;
    uint64_t v49 = *(void *)(v47 - 8);
    unint64_t v48 = (uint64_t *)(v47 - 8);
    uint64_t v50 = 2 * v49;
    *unint64_t v48 = 2 * v49;
    unint64_t v51 = v29 - 2;
    do
    {
      *unint64_t v48 = v50 | (*(void *)(v15 + 8 * v51) >> 63);
      unint64_t v48 = (uint64_t *)(v15 + 8 * v51);
      uint64_t v50 = 2 * *v48;
      *unint64_t v48 = v50;
    }
    while ((unint64_t)v51--);
  }
  else
  {
    *a3 = (*(void *)a4 >> v14) & 1;
    if (v13 <= 0x40)
    {
      unint64_t v15 = (0xFFFFFFFFFFFFFFFFLL >> -(char)v13) & (2 * v15);
LABEL_13:
      *(void *)a4 = v15;
      goto LABEL_14;
    }
    unint64_t v29 = (unint64_t)(v13 + 63) >> 6;
    unint64_t v30 = v15 + 8 * v29;
    *((void *)&v31 + 1) = *(void *)(v30 - 8);
    *(void *)&long long v31 = *(void *)(v15 + 8 * (v29 - 2));
    *(void *)(v30 - 8) = v31 >> 63;
    *(void *)(v15 + 8 * (v29 - 2)) *= 2;
  }
  *(void *)(v15 + 8 * (v29 - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v13;
LABEL_14:
  if (*((_DWORD *)v6 + 2) >= 0x41u) {
    unint64_t v6 = *(llvm::APInt **)v6;
  }
  if (*(unsigned char *)v6)
  {
    if (v13 >= 0x41)
    {
      uint64_t v32 = 0;
      unsigned int v33 = *(uint64_t **)a2;
      unint64_t v34 = (unint64_t)(v13 + 63) >> 6;
      int v35 = (unint64_t *)v15;
      unint64_t v36 = v34;
      do
      {
        uint64_t v37 = *v33++;
        unint64_t v38 = v37 + *v35;
        unint64_t result = v38 + 1;
        BOOL v39 = v38 + 1 <= *v35;
        if (v32)
        {
          ++v38;
          uint64_t v32 = v39;
        }
        else
        {
          uint64_t v32 = v38 < *v35;
        }
        *v35++ = v38;
        --v36;
      }
      while (v36);
      *(void *)(v15 + 8 * (v34 - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v13;
      uint64_t v40 = 8 * v34;
      unint64_t v41 = v15 - 8;
      while (v40)
      {
        unint64_t v42 = *(void *)(v41 + v40);
        unint64_t v43 = *(void *)(*(void *)a2 - 8 + v40);
        v40 -= 8;
        if (v42 != v43)
        {
          if (v42 > v43) {
            return result;
          }
          goto LABEL_23;
        }
      }
    }
    else
    {
      unint64_t v16 = *(void *)a2;
      unint64_t v17 = *(void *)a2 + v15;
      if (v13) {
        unint64_t v18 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v13;
      }
      else {
        unint64_t v18 = 0;
      }
      unint64_t v19 = v18 & v17;
      *(void *)a4 = v19;
      if (v19 < v16) {
LABEL_23:
      }
        *a3 = 1;
    }
  }
  return result;
}

uint64_t sub_1CD0442FC(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 8);
  if (v1 <= 0x40) {
    return v1 + __clz(*(void *)a1) - 64;
  }
  int v3 = 0;
  int64_t v4 = (unint64_t)(v1 + 63) >> 6;
  do
  {
    if (v4-- < 1) {
      break;
    }
    unint64_t v6 = *(void *)(*(void *)a1 + 8 * v4);
    v3 += __clz(v6);
  }
  while (!v6);
  if ((v1 & 0x3F) != 0) {
    int v7 = v1 | 0xFFFFFFC0;
  }
  else {
    int v7 = 0;
  }
  return (v3 + v7);
}

uint64_t llvm::APInt::sadd_sat@<X0>(llvm::APInt *this@<X0>, const llvm::APInt *a2@<X1>, uint64_t a3@<X8>)
{
  BOOL v12 = 0;
  uint64_t result = llvm::APInt::sadd_ov(this, a2, &v12, (uint64_t)&v10);
  if (v12)
  {
    unsigned int v6 = *((_DWORD *)this + 2);
    if (v6 > 0x40)
    {
      *(_DWORD *)(a3 + 8) = v6;
      operator new[]();
    }
    char v7 = (v6 - 1) & 0x3F;
    if ((*(void *)this >> (v6 - 1)))
    {
      *(_DWORD *)(a3 + 8) = v6;
      uint64_t v9 = 1 << v7;
    }
    else
    {
      *(_DWORD *)(a3 + 8) = v6;
      if (v6) {
        unint64_t v8 = 0xFFFFFFFFFFFFFFFFLL >> (v7 ^ 0x3Fu);
      }
      else {
        unint64_t v8 = 0;
      }
      uint64_t v9 = v8 & ~(1 << v7);
    }
    *(void *)a3 = v9;
  }
  else
  {
    *(_DWORD *)(a3 + 8) = v11;
    *(void *)a3 = v10;
    unsigned int v11 = 0;
  }
  if (v11 >= 0x41)
  {
    uint64_t result = v10;
    if (v10)
    {
      JUMPOUT(0x1D25D9CB0);
    }
  }
  return result;
}

unint64_t llvm::APInt::uadd_sat@<X0>(llvm::APInt *this@<X0>, const llvm::APInt *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v3 = *((_DWORD *)this + 2);
  if (v3 >= 0x41) {
    operator new[]();
  }
  uint64_t v4 = *(void *)a2 + *(void *)this;
  unint64_t v5 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v3;
  if (!v3) {
    unint64_t v5 = 0;
  }
  unint64_t result = v5 & v4;
  if ((v5 & v4) < *(void *)a2)
  {
    *(_DWORD *)(a3 + 8) = v3;
    if (v3) {
      unint64_t v7 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v3;
    }
    else {
      unint64_t v7 = 0;
    }
    *(void *)a3 = v7;
  }
  else
  {
    *(_DWORD *)(a3 + 8) = v3;
    *(void *)a3 = result;
  }
  return result;
}

uint64_t llvm::APInt::ssub_sat@<X0>(llvm::APInt *this@<X0>, const llvm::APInt *a2@<X1>, llvm::APInt *a3@<X8>)
{
  BOOL v11 = 0;
  uint64_t result = llvm::APInt::ssub_ov(this, a2, &v11, (uint64_t)&v9);
  if (!v11)
  {
    *((_DWORD *)a3 + 2) = v10;
    *(void *)a3 = v9;
    unsigned int v10 = 0;
    goto LABEL_3;
  }
  uint64_t result = *((unsigned int *)this + 2);
  unsigned int v6 = result - 1;
  if (result > 0x40)
  {
    if ((*(void *)(*(void *)this + 8 * (v6 >> 6)) & (1 << v6)) == 0)
    {
      *((_DWORD *)a3 + 2) = result;
      operator new[]();
    }
    goto LABEL_16;
  }
  if ((*(void *)this >> v6))
  {
LABEL_16:
    uint64_t result = sub_1CBA62420(result, a3);
    goto LABEL_3;
  }
  *((_DWORD *)a3 + 2) = result;
  char v7 = (result - 1) & 0x3F;
  unint64_t v8 = 0xFFFFFFFFFFFFFFFFLL >> (v7 ^ 0x3Fu);
  if (!result) {
    unint64_t v8 = 0;
  }
  *(void *)a3 = v8 & ~(1 << v7);
LABEL_3:
  if (v10 >= 0x41)
  {
    uint64_t result = v9;
    if (v9)
    {
      JUMPOUT(0x1D25D9CB0);
    }
  }
  return result;
}

uint64_t llvm::APInt::usub_sat@<X0>(llvm::APInt *this@<X0>, const llvm::APInt *a2@<X1>, uint64_t a3@<X8>)
{
  BOOL v9 = 0;
  uint64_t result = llvm::APInt::usub_ov((uint64_t)this, a2, &v9, (uint64_t)&v7);
  if (v9)
  {
    unsigned int v6 = *((_DWORD *)this + 2);
    *(_DWORD *)(a3 + 8) = v6;
    if (v6 > 0x40) {
      operator new[]();
    }
    *(void *)a3 = 0;
  }
  else
  {
    *(_DWORD *)(a3 + 8) = v8;
    *(void *)a3 = v7;
    unsigned int v8 = 0;
  }
  if (v8 >= 0x41)
  {
    uint64_t result = v7;
    if (v7)
    {
      JUMPOUT(0x1D25D9CB0);
    }
  }
  return result;
}

uint64_t llvm::APInt::smul_sat@<X0>(const void **this@<X0>, const llvm::APInt *a2@<X1>, llvm::APInt *a3@<X8>)
{
  uint64_t v4 = this;
  BOOL v15 = 0;
  uint64_t result = llvm::APInt::smul_ov(this, a2, &v15, (llvm::APInt *)&v13);
  if (v15)
  {
    uint64_t v7 = *((unsigned int *)v4 + 2);
    unsigned int v8 = v7 - 1;
    if (v7 >= 0x41) {
      uint64_t v4 = (const void **)((char *)*v4 + 8 * (v8 >> 6));
    }
    uint64_t v9 = ((unint64_t)*v4 >> v8) & 1;
    unsigned int v10 = *((_DWORD *)a2 + 2);
    char v11 = v10 - 1;
    if (v10 >= 0x41) {
      BOOL v12 = (const llvm::APInt *)(*(void *)a2 + 8 * ((v10 - 1) >> 6));
    }
    else {
      BOOL v12 = a2;
    }
    if (v9 == ((*(void *)v12 >> v11) & 1)) {
      uint64_t result = sub_1CBFD9168(v7, a3);
    }
    else {
      uint64_t result = sub_1CBA62420(v7, a3);
    }
  }
  else
  {
    *((_DWORD *)a3 + 2) = v14;
    *(void *)a3 = v13;
    unsigned int v14 = 0;
  }
  if (v14 >= 0x41)
  {
    uint64_t result = v13;
    if (v13) {
      return MEMORY[0x1D25D9CB0](v13, 0x1000C8000313F17);
    }
  }
  return result;
}

unint64_t llvm::APInt::umul_sat@<X0>(llvm::APInt *this@<X0>, const llvm::APInt *a2@<X1>, uint64_t a3@<X8>)
{
  BOOL v10 = 0;
  unint64_t result = llvm::APInt::umul_ov(this, a2, &v10, (uint64_t)&v8);
  if (v10)
  {
    unsigned int v6 = *((_DWORD *)this + 2);
    *(_DWORD *)(a3 + 8) = v6;
    if (v6 > 0x40) {
      operator new[]();
    }
    unint64_t v7 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v6;
    if (!v6) {
      unint64_t v7 = 0;
    }
    *(void *)a3 = v7;
  }
  else
  {
    *(_DWORD *)(a3 + 8) = v9;
    *(void *)a3 = v8;
    unsigned int v9 = 0;
  }
  if (v9 >= 0x41)
  {
    unint64_t result = v8;
    if (v8)
    {
      JUMPOUT(0x1D25D9CB0);
    }
  }
  return result;
}

unsigned int *llvm::APInt::toString(unsigned int *result, void *a2, unsigned int a3, int a4, int a5)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if (a5)
  {
    HIDWORD(v26) = a3;
    LODWORD(v26) = a3 - 2;
    unsigned int v6 = off_1E6852F48[(int)(v26 >> 1)];
  }
  else
  {
    unsigned int v6 = &byte_1CFC267E6;
  }
  uint64_t v7 = result[2];
  if (v7 > 0x40)
  {
    int v16 = 0;
    int64_t v17 = (unint64_t)(v7 + 63) >> 6;
    do
    {
      if (v17-- < 1) {
        break;
      }
      unint64_t v19 = *(void *)(*(void *)result + 8 * v17);
      v16 += __clz(v19);
    }
    while (!v19);
    int v20 = v7 | 0xFFFFFFC0;
    if ((v7 & 0x3F) == 0) {
      int v20 = 0;
    }
    if (v16 + v20 != v7)
    {
      unsigned int v30 = result[2];
      operator new[]();
    }
  }
  else
  {
    unint64_t v8 = *(void *)result;
    if (*(void *)result)
    {
      if (a4)
      {
        unint64_t v8 = (uint64_t)(v8 << -(char)v7) >> -(char)v7;
        if ((v8 & 0x8000000000000000) != 0)
        {
          uint64_t v15 = a2[1];
          if ((unint64_t)(v15 + 1) > a2[2]) {
            llvm::SmallVectorBase<unsigned long long>::grow_pod();
          }
          *(unsigned char *)(*a2 + v15) = 45;
          ++a2[1];
          unint64_t v8 = -(uint64_t)v8;
        }
      }
      char v9 = *v6;
      if (*v6)
      {
        uint64_t v23 = a2[1];
        int v24 = (unsigned __int8 *)(v6 + 1);
        do
        {
          if ((unint64_t)(v23 + 1) > a2[2]) {
            llvm::SmallVectorBase<unsigned long long>::grow_pod();
          }
          *(unsigned char *)(*a2 + v23) = v9;
          uint64_t v23 = a2[1] + 1;
          a2[1] = v23;
          int v25 = *v24++;
          char v9 = v25;
        }
        while (v25);
      }
      if (v8)
      {
        uint64_t v10 = 64;
        do
        {
          *((unsigned char *)&v29 + v10--) = a0123456789abcd_3[v8 % a3];
          BOOL v11 = v8 >= a3;
          v8 /= a3;
        }
        while (v11);
        uint64_t v12 = v10 + 1;
      }
      else
      {
        uint64_t v12 = 65;
      }
      uint64_t v13 = a2[1];
      if (a2[2] < (unint64_t)(v13 + 65 - v12)) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      if (v12 != 65)
      {
        unint64_t result = (unsigned int *)memcpy((void *)(*a2 + v13), (char *)&v29 + v12, 65 - v12);
        uint64_t v13 = a2[1];
      }
      uint64_t v14 = v13 + 65 - v12;
      goto LABEL_16;
    }
  }
  char v21 = *v6;
  if (*v6)
  {
    uint64_t v22 = a2[1];
    unint64_t v27 = (unsigned __int8 *)(v6 + 1);
    do
    {
      if ((unint64_t)(v22 + 1) > a2[2]) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      *(unsigned char *)(*a2 + v22) = v21;
      uint64_t v22 = a2[1] + 1;
      a2[1] = v22;
      int v28 = *v27++;
      char v21 = v28;
    }
    while (v28);
  }
  else
  {
    uint64_t v22 = a2[1];
  }
  if ((unint64_t)(v22 + 1) > a2[2]) {
    llvm::SmallVectorBase<unsigned long long>::grow_pod();
  }
  *(unsigned char *)(*a2 + v22) = 48;
  uint64_t v14 = a2[1] + 1;
LABEL_16:
  a2[1] = v14;
  return result;
}

void llvm::APInt::print(llvm::APInt *this, llvm::raw_ostream *a2, int a3)
{
  v6[5] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = v6;
  long long v5 = xmmword_1CDB15B30;
  llvm::APInt::toString((unsigned int *)this, &v4, 0xAu, a3, 0);
  llvm::raw_ostream::write(a2, (const char *)v4, v5);
  if (v4 != v6) {
    free(v4);
  }
}

void llvm::APInt::tcSet(llvm::APInt *this, unint64_t *a2, unsigned int a3)
{
  *(void *)this = a2;
  if (a3 >= 2) {
    bzero((char *)this + 8, 8 * (a3 - 2) + 8);
  }
}

void *llvm::APInt::tcAssign(void *this, unint64_t *a2, const unint64_t *a3)
{
  if (a3)
  {
    uint64_t v3 = a3;
    do
    {
      uint64_t v4 = *a2++;
      *this++ = v4;
      --v3;
    }
    while (v3);
  }
  return this;
}

BOOL llvm::APInt::tcIsZero(llvm::APInt *this, const unint64_t *a2)
{
  if (!a2) {
    return 1;
  }
  if (*(void *)this) {
    return 0;
  }
  uint64_t v3 = 1;
  do
  {
    unint64_t v4 = v3;
    if (a2 == v3) {
      break;
    }
  }
  while (!*((void *)this + v3++));
  return v4 >= a2;
}

uint64_t llvm::APInt::tcExtractBit(llvm::APInt *this, const unint64_t *a2)
{
  return (*((void *)this + (a2 >> 6)) >> (char)a2) & 1;
}

uint64_t llvm::APInt::tcSetBit(uint64_t this, unint64_t *a2)
{
  *(void *)(this + 8 * (a2 >> 6)) |= 1 << (char)a2;
  return this;
}

uint64_t llvm::APInt::tcLSB(llvm::APInt *this, const unint64_t *a2)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = 0;
  while (1)
  {
    unint64_t v4 = *(void *)this;
    this = (llvm::APInt *)((char *)this + 8);
    unint64_t v3 = v4;
    if (v4) {
      break;
    }
    v2 -= 64;
    if (!(((unint64_t)a2 << 6) + v2)) {
      return 0xFFFFFFFFLL;
    }
  }
  return __clz(__rbit64(v3)) - v2;
}

uint64_t llvm::APInt::tcMSB(llvm::APInt *this, const unint64_t *a2)
{
  int v2 = 64 - (a2 << 6);
  unsigned int v3 = a2 - 1;
  do
  {
    unint64_t v4 = *((void *)this + v3);
    if (v4) {
      return (__clz(v4) - v2) ^ 0x3F;
    }
    v2 += 64;
    --v3;
  }
  while (v3 != -1);
  return 0xFFFFFFFFLL;
}

void llvm::APInt::tcExtract(llvm::APInt *this, unint64_t *a2, uint64_t a3, const unint64_t *a4, unsigned int a5)
{
  unsigned int v5 = a4 + 63;
  uint64_t v6 = (a4 + 63) >> 6;
  unsigned int v7 = a5 >> 6;
  if (a4 != 0 && a4 < 0xFFFFFFC1)
  {
    uint64_t v12 = 0;
    if (v6 <= 1) {
      unsigned int v13 = 1;
    }
    else {
      unsigned int v13 = (a4 + 63) >> 6;
    }
    uint64_t v14 = 8 * v13;
    do
    {
      *(void *)((char *)this + v12) = *(void *)(a3 + 8 * v7 + v12);
      v12 += 8;
    }
    while (v14 != v12);
    int v8 = a5 & 0x3F;
    if ((a5 & 0x3F) != 0)
    {
      uint64_t v15 = *(void *)this >> v8;
      *(void *)this = v15;
      if (v6 != 1)
      {
        uint64_t v16 = 0;
        do
        {
          int64_t v17 = (uint64_t *)((char *)this + 8 * v16++);
          uint64_t *v17 = (*((void *)this + v16) << (64 - v8)) | v15;
          uint64_t v15 = *((void *)this + v16) >> v8;
          v17[1] = v15;
        }
        while (v6 - 1 != v16);
      }
    }
  }
  else
  {
    int v8 = a5 & 0x3F;
  }
  unsigned int v9 = (v5 & 0xFFFFFFC0) - v8;
  if (v9 < a4)
  {
    unint64_t v18 = (*(void *)(a3 + 8 * (v7 + v6)) & (0xFFFFFFFFFFFFFFFFLL >> (v9
                                                                                     - a4))) << v9;
    unsigned int v10 = v6 - 1;
    unint64_t v11 = v18 | *((void *)this + (v6 - 1));
  }
  else
  {
    if (v9 <= a4 || (a4 & 0x3F) == 0) {
      goto LABEL_8;
    }
    unsigned int v10 = v6 - 1;
    unint64_t v11 = *((void *)this + (v6 - 1)) & (0xFFFFFFFFFFFFFFFFLL >> -(a4 & 0x3F));
  }
  *((void *)this + v10) = v11;
LABEL_8:
  if (v6 < a2) {
    bzero((char *)this + ((v5 >> 3) & 0x1FFFFFF8), 8 * (~v6 + a2) + 8);
  }
}

uint64_t *llvm::APInt::tcNegate(uint64_t *this, unint64_t *a2)
{
  if (a2)
  {
    int v2 = this;
    uint64_t v3 = a2;
    do
    {
      uint64_t *v2 = ~*v2;
      ++v2;
      --v3;
    }
    while (v3);
    uint64_t v4 = a2 - 1;
    do
    {
      uint64_t v5 = *this + 1;
      *this++ = v5;
      if (v5) {
        BOOL v6 = 1;
      }
      else {
        BOOL v6 = v4 == 0;
      }
      --v4;
    }
    while (!v6);
  }
  return this;
}

void llvm::APInt::tcFullMultiply(llvm::APInt *this, unint64_t *a2, unint64_t *a3, const unint64_t *a4, const unint64_t *a5)
{
  do
  {
    int v8 = a5;
    a5 = a4;
    unsigned int v9 = a3;
    a3 = a2;
    a2 = v9;
    a4 = v8;
  }
  while (a5 > v8);
  *(void *)this = 0;
  if (v8 >= 2) {
    bzero((char *)this + 8, 8 * (v8 - 2) + 8);
  }
  if (a5)
  {
    uint64_t v10 = 0;
    if (v8 < (int)v8 + 1) {
      uint64_t v11 = v8;
    }
    else {
      uint64_t v11 = (v8 + 1);
    }
    uint64_t v12 = this;
    do
    {
      if (v11)
      {
        uint64_t v13 = 0;
        unint64_t v14 = a3[v10];
        uint64_t v15 = v9;
        uint64_t v16 = v12;
        uint64_t v17 = v11;
        do
        {
          uint64_t v18 = 0;
          unint64_t v20 = *v15++;
          unint64_t v19 = v20;
          if (v14 && v19)
          {
            unint64_t v21 = v19 * (unint64_t)v14;
            unint64_t v22 = HIDWORD(v19);
            unint64_t v23 = v19 * (unint64_t)HIDWORD(v14);
            unint64_t v24 = HIDWORD(v23) + HIDWORD(v19) * (unint64_t)HIDWORD(v14);
            unint64_t v25 = v19 * v14;
            BOOL v26 = __CFADD__(v25, v13);
            v13 += v25;
            BOOL v27 = v26;
            uint64_t v18 = (__PAIR128__(v27, v21)
                 + __PAIR128__(v24 + ((v22 * (unint64_t)v14) >> 32), v23 << 32)) >> 64;
            if (v25 < v21 + (v23 << 32)) {
              ++v18;
            }
          }
          uint64_t v28 = *(void *)v16 + v13;
          if (__CFADD__(v13, *(void *)v16)) {
            uint64_t v13 = v18 + 1;
          }
          else {
            uint64_t v13 = v18;
          }
          *(void *)uint64_t v16 = v28;
          uint64_t v16 = (llvm::APInt *)((char *)v16 + 8);
          --v17;
        }
        while (v17);
        if (v8 == -1) {
          goto LABEL_25;
        }
      }
      else
      {
        if (v8 == -1) {
          goto LABEL_25;
        }
        uint64_t v13 = 0;
      }
      *((void *)this + v10 + v8) = v13;
LABEL_25:
      ++v10;
      uint64_t v12 = (llvm::APInt *)((char *)v12 + 8);
    }
    while (v10 != a5);
  }
}

uint64_t llvm::APInt::tcDivide(llvm::APInt *this, unint64_t *a2, unint64_t *a3, void *__src, unint64_t *a5)
{
  unsigned int v5 = a5;
  int v9 = a5 - 1;
  for (int i = 64 - (a5 << 6); ; i += 64)
  {
    unint64_t v11 = a2[v9];
    if (v11) {
      break;
    }
    if (--v9 == -1) {
      return 1;
    }
  }
  int v12 = (__clz(v11) - i) ^ 0x3F;
  BOOL v13 = __CFADD__(v12, 1);
  int v14 = v12 + 1;
  if (v13) {
    return 1;
  }
  unsigned int v16 = (a5 << 6) - v14;
  if (a5)
  {
    uint64_t v17 = a5;
    uint64_t v18 = __src;
    do
    {
      uint64_t v19 = *a2++;
      *v18++ = v19;
      --v17;
    }
    while (v17);
  }
  unsigned int v20 = v16 >> 6;
  if (v16)
  {
    if (v20 >= a5) {
      unsigned int v21 = a5;
    }
    else {
      unsigned int v21 = v16 >> 6;
    }
    char v22 = v16 & 0x3F;
    if ((v16 & 0x3F) != 0)
    {
      if (v20 < a5)
      {
        uint64_t v23 = a5 - 1;
        unint64_t v24 = __src[v23 - v21] << v22;
        unint64_t v25 = &__src[v23];
        *unint64_t v25 = v24;
        if (v23 > v21)
        {
          uint64_t v45 = &__src[(int)a5 - 2];
          unint64_t v46 = &__src[a5 - 2 + (uint64_t)-v21];
          do
          {
            unint64_t v47 = *v46--;
            *unint64_t v25 = (v47 >> (64 - v22)) | v24;
            LODWORD(v23) = v23 - 1;
            unint64_t v25 = v45;
            unint64_t v24 = __src[v23 - v21] << v22;
            *v45-- = v24;
          }
          while (v21 < v23);
        }
      }
    }
    else
    {
      memmove(&__src[v21], __src, 8 * (a5 - v21));
    }
    bzero(__src, 8 * v21);
  }
  unint64_t v26 = 1 << v16;
  if (v5)
  {
    uint64_t v27 = 0;
    uint64_t v28 = v5;
    do
    {
      a3[v27] = *(void *)((char *)this + v27 * 8);
      ++v27;
    }
    while (v5 != v27);
    *(void *)this = 0;
    if (v5 >= 2) {
      bzero((char *)this + 8, 8 * (v5 - 2) + 8);
    }
  }
  else
  {
    uint64_t v28 = 0;
    *(void *)this = 0;
  }
  while (2)
  {
    uint64_t v29 = v28;
    while (v29 * 8)
    {
      unint64_t v30 = a3[v29 - 1];
      unint64_t v31 = __src[--v29];
      if (v30 != v31)
      {
        if (v30 <= v31) {
          goto LABEL_36;
        }
        break;
      }
    }
    if (v5)
    {
      uint64_t v32 = 0;
      unsigned int v33 = a3;
      unint64_t v34 = __src;
      uint64_t v35 = v28;
      do
      {
        unint64_t v36 = *v34++;
        unint64_t v37 = *v33 - v36;
        BOOL v38 = *v33 < v36;
        unint64_t v39 = *v33 + ~v36;
        if (v32)
        {
          uint64_t v32 = v39 >= *v33;
        }
        else
        {
          unint64_t v39 = v37;
          uint64_t v32 = v38;
        }
        *v33++ = v39;
        --v35;
      }
      while (v35);
    }
    *((void *)this + v20) |= v26;
LABEL_36:
    if (v16)
    {
      if (v5)
      {
        uint64_t v40 = *__src >> 1;
        *unint64_t __src = v40;
        if (v5 != 1)
        {
          unint64_t v41 = __src + 1;
          uint64_t v42 = v28 - 1;
          do
          {
            unint64_t v43 = *v41;
            *(v41 - 1) = v40 | (*v41 << 63);
            uint64_t v40 = v43 >> 1;
            *v41++ = v43 >> 1;
            --v42;
          }
          while (v42);
        }
      }
      --v16;
      int v44 = v26 < 2;
      if (v26 >= 2) {
        v26 >>= 1;
      }
      else {
        unint64_t v26 = 0x8000000000000000;
      }
      v20 -= v44;
      continue;
    }
    return 0;
  }
}

void llvm::APIntOps::RoundingUDiv(llvm::APInt *a1@<X0>, const llvm::APInt *a2@<X1>, unsigned int a3@<W2>, llvm::APInt *a4@<X4>, uint64_t a5@<X8>)
{
  if (a3 <= 1)
  {
    llvm::APInt::udiv((uint64_t)a1, a2, a5);
    return;
  }
  unsigned int v17 = 1;
  unint64_t __src = 0;
  unsigned int v15 = 1;
  uint64_t v14 = 0;
  llvm::APInt::udivrem(a1, a2, (const llvm::APInt *)&__src, (llvm::APInt *)&v14, a4);
  unsigned int v6 = v15;
  if (v15 > 0x40)
  {
    int v7 = 0;
    int64_t v8 = ((unint64_t)v15 + 63) >> 6;
    do
    {
      if (v8-- < 1) {
        break;
      }
      unint64_t v10 = *(void *)(v14 + 8 * v8);
      v7 += __clz(v10);
    }
    while (!v10);
    unsigned int v11 = v15 | 0xFFFFFFC0;
    if ((v15 & 0x3F) == 0) {
      unsigned int v11 = 0;
    }
    if (v7 + v11 == v15) {
      goto LABEL_7;
    }
LABEL_17:
    unsigned int v13 = v17;
    if (v17 > 0x40) {
      operator new[]();
    }
    int v12 = __src;
    llvm::APInt::operator+=((uint64_t)&v12, 1uLL);
    *(_DWORD *)(a5 + 8) = v13;
    *(void *)a5 = v12;
    unsigned int v13 = 0;
    unsigned int v6 = v15;
    goto LABEL_8;
  }
  if (v14) {
    goto LABEL_17;
  }
LABEL_7:
  *(_DWORD *)(a5 + 8) = v17;
  *(void *)a5 = __src;
  unsigned int v17 = 0;
LABEL_8:
  if (v6 >= 0x41 && v14) {
    MEMORY[0x1D25D9CB0](v14, 0x1000C8000313F17);
  }
  if (v17 >= 0x41 && __src) {
    MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
  }
}

void llvm::APIntOps::RoundingSDiv(llvm::APInt *a1@<X1>, llvm::APInt *a2@<X0>, int a3@<W2>, llvm::APInt *a4@<X4>, uint64_t a5@<X8>)
{
  if (a3 != 1)
  {
    unsigned int v30 = 1;
    unint64_t __src = 0;
    unsigned int v28 = 1;
    uint64_t v27 = 0;
    llvm::APInt::sdivrem(a2, a1, (const llvm::APInt *)&__src, (llvm::APInt *)&v27, a4);
    if (v28 > 0x40)
    {
      int v17 = 0;
      int64_t v18 = ((unint64_t)v28 + 63) >> 6;
      uint64_t v8 = v27;
      do
      {
        if (v18-- < 1) {
          break;
        }
        unint64_t v20 = *(void *)(v27 + 8 * v18);
        v17 += __clz(v20);
      }
      while (!v20);
      unsigned int v21 = v28 | 0xFFFFFFC0;
      if ((v28 & 0x3F) == 0) {
        unsigned int v21 = 0;
      }
      if (v17 + v21 != v28)
      {
LABEL_4:
        int v9 = (uint64_t *)(v8 + 8 * ((v28 - 1) >> 6));
        unint64_t v10 = &v27;
        if (v28 >= 0x41) {
          unint64_t v10 = v9;
        }
        unint64_t v11 = (unint64_t)*v10 >> (v28 - 1);
        unsigned int v12 = *((_DWORD *)a1 + 2);
        char v13 = v12 - 1;
        if (v12 >= 0x41) {
          uint64_t v14 = (llvm::APInt *)(*(void *)a1 + 8 * ((v12 - 1) >> 6));
        }
        else {
          uint64_t v14 = a1;
        }
        char v15 = v11 ^ (*(void *)v14 >> v13);
        if (a3)
        {
          if (v15) {
            goto LABEL_11;
          }
          unsigned int v24 = v30;
          if (v30 > 0x40) {
            operator new[]();
          }
          uint64_t v23 = __src;
          p_src = &v23;
          llvm::APInt::operator+=((uint64_t)&v23, 1uLL);
          unsigned int v22 = v24;
        }
        else
        {
          if ((v15 & 1) == 0)
          {
LABEL_11:
            *(_DWORD *)(a5 + 8) = v30;
LABEL_12:
            p_src = &__src;
            goto LABEL_13;
          }
          unsigned int v26 = v30;
          if (v30 > 0x40) {
            operator new[]();
          }
          unint64_t v25 = __src;
          p_src = &v25;
          llvm::APInt::operator-=((uint64_t)&v25, 1uLL);
          unsigned int v22 = v26;
        }
        *(_DWORD *)(a5 + 8) = v22;
LABEL_13:
        *(void *)a5 = *p_src;
        *((_DWORD *)p_src + 2) = 0;
        if (v28 >= 0x41 && v27) {
          MEMORY[0x1D25D9CB0](v27, 0x1000C8000313F17);
        }
        if (v30 >= 0x41)
        {
          if (__src) {
            MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
          }
        }
        return;
      }
    }
    else
    {
      uint64_t v8 = v27;
      if (v27) {
        goto LABEL_4;
      }
    }
    *(_DWORD *)(a5 + 8) = v30;
    goto LABEL_12;
  }

  llvm::APInt::sdiv(a2, a1, a5);
}

void sub_1CD045EE4(uint64_t a1, const llvm::APInt *a2, const llvm::APInt *a3)
{
  sub_1CBF71A98(a2, (llvm::APInt *)&v21);
  llvm::APInt::urem((llvm::APInt *)&v21, a3, (uint64_t)&v23);
  if (v22 >= 0x41 && v21) {
    MEMORY[0x1D25D9CB0](v21, 0x1000C8000313F17);
  }
  if (v24 > 0x40)
  {
    int v12 = 0;
    int64_t v13 = ((unint64_t)v24 + 63) >> 6;
    uint64_t v6 = v23;
    do
    {
      if (v13-- < 1) {
        break;
      }
      unint64_t v15 = *(void *)(v23 + 8 * v13);
      v12 += __clz(v15);
    }
    while (!v15);
    unsigned int v16 = v24 | 0xFFFFFFC0;
    if ((v24 & 0x3F) == 0) {
      unsigned int v16 = 0;
    }
    if (v12 + v16 != v24) {
      goto LABEL_6;
    }
LABEL_19:
    sub_1CD0463BC(a1, (uint64_t)a2);
    goto LABEL_29;
  }
  uint64_t v6 = v23;
  if (!v23) {
    goto LABEL_19;
  }
LABEL_6:
  unsigned int v7 = *((_DWORD *)a2 + 2);
  uint64_t v8 = *(void *)a2;
  int v9 = (const llvm::APInt *)(*(void *)a2 + 8 * ((v7 - 1) >> 6));
  if (v7 < 0x41) {
    int v9 = a2;
  }
  if ((*(void *)v9 >> (v7 - 1)))
  {
    if (v7 >= 0x41) {
      operator new[]();
    }
    uint64_t v10 = v6 + v8;
    unint64_t v11 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v7;
    if (!v7) {
      unint64_t v11 = 0;
    }
    *(_DWORD *)(a1 + 8) = v7;
    *(void *)a1 = v11 & v10;
  }
  else
  {
    unsigned int v17 = *((_DWORD *)a3 + 2);
    if (v17 >= 0x41) {
      operator new[]();
    }
    unint64_t v18 = (*(void *)a3 - v6) & (0xFFFFFFFFFFFFFFFFLL >> -(char)v17);
    if (!v17) {
      unint64_t v18 = 0;
    }
    uint64_t v19 = v18 + v8;
    if (v17) {
      unint64_t v20 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v17;
    }
    else {
      unint64_t v20 = 0;
    }
    *(_DWORD *)(a1 + 8) = v17;
    *(void *)a1 = v19 & v20;
  }
LABEL_29:
  if (v24 >= 0x41)
  {
    if (v23) {
      MEMORY[0x1D25D9CB0](v23, 0x1000C8000313F17);
    }
  }
}

uint64_t llvm::APIntOps::GetMostSignificantDifferentBit(const void **this, const void **a2, const llvm::APInt *a3)
{
  uint64_t v3 = *((unsigned int *)this + 2);
  if (v3 > 0x40)
  {
    if (memcmp(*this, *a2, ((unint64_t)(v3 + 63) >> 3) & 0x3FFFFFF8)) {
      operator new[]();
    }
    uint64_t v5 = 0;
    unsigned __int8 v6 = 0;
    unsigned int v7 = 0;
  }
  else
  {
    int v4 = v3 + ~(v3 + __clz((unint64_t)*a2 ^ (unint64_t)*this) - 64);
    if (*this == *a2) {
      uint64_t v5 = 0;
    }
    else {
      uint64_t v5 = 0x100000000;
    }
    if (*this == *a2) {
      unsigned __int8 v6 = 0;
    }
    else {
      unsigned __int8 v6 = v4;
    }
    if (*this == *a2) {
      unsigned int v7 = 0;
    }
    else {
      unsigned int v7 = v4 & 0xFFFFFF00;
    }
  }
  return v5 | v7 | v6;
}

void *llvm::StoreIntToMemory(llvm **this, const llvm::APInt *__dst, size_t __n)
{
  if (*((_DWORD *)this + 2) >= 0x41u) {
    int v4 = *this;
  }
  else {
    int v4 = (llvm *)this;
  }
  return memcpy(__dst, v4, __n);
}

void *llvm::LoadIntFromMemory(llvm *this, llvm::APInt *a2, size_t __n)
{
  if (*((_DWORD *)this + 2) >= 0x41u) {
    this = *(llvm **)this;
  }
  return memcpy(this, a2, __n);
}

uint64_t sub_1CD0463BC(uint64_t result, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(result + 8) = v2;
  if (v2 > 0x40) {
    operator new[]();
  }
  *(void *)unint64_t result = *(void *)a2;
  return result;
}

uint64_t llvm::APSInt::Profile(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a2 + 8);
  if (v2 >= *(_DWORD *)(a2 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)a2 + 4 * v2) = *(unsigned __int8 *)(a1 + 12);
  ++*(_DWORD *)(a2 + 8);

  return llvm::APInt::Profile(a1, a2);
}

uint64_t llvm::ARMAttributeParser::stringAttribute@<X0>(void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = a1[15];
  if (v6)
  {
    int v9 = (void *)(a1[14] + 16);
    uint64_t v10 = 24 * v6;
    uint64_t v8 = &unk_1CFC290E7;
    while (*((_DWORD *)v9 - 4) != a2)
    {
      v9 += 3;
      v10 -= 24;
      if (!v10)
      {
        unint64_t v7 = 0;
        goto LABEL_10;
      }
    }
    uint64_t v12 = *(v9 - 1);
    unint64_t v11 = *v9;
    uint64_t v13 = 4;
    if (v11 < 4) {
      uint64_t v13 = v11;
    }
    uint64_t v8 = (void *)(v12 + v13);
    unint64_t v7 = v11 - v13;
  }
  else
  {
    unint64_t v7 = 0;
    uint64_t v8 = &unk_1CFC290E7;
  }
LABEL_10:
  CStrRef = llvm::DataExtractor::getCStrRef(a1 + 16, a1 + 19, a1 + 20);
  uint64_t result = a1[13];
  if (result)
  {
    uint64_t v17 = v14;
    uint64_t v18 = a1[13];
    (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)result + 208))(result, "Attribute", 9);
    (*(void (**)(void, const char *, uint64_t, uint64_t))(*(void *)a1[13] + 24))(a1[13], "Tag", 3, a2);
    if (v7) {
      (*(void (**)(void, const char *, uint64_t, void *, unint64_t))(*(void *)a1[13] + 192))(a1[13], "TagName", 7, v8, v7);
    }
    (*(void (**)(void, const char *, uint64_t, void *, uint64_t))(*(void *)a1[13] + 192))(a1[13], "Value", 5, CStrRef, v17);
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v18 + 216))(v18);
  }
  *a3 = 0;
  return result;
}

uint64_t llvm::ARMAttributeParser::compatibility@<X0>(void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = a1 + 16;
  unint64_t v7 = a1 + 19;
  uint64_t v8 = a1 + 20;
  unint64_t ULEB128 = llvm::DataExtractor::getULEB128(a1 + 16, a1 + 19, a1 + 20);
  CStrRef = llvm::DataExtractor::getCStrRef(v6, v7, v8);
  uint64_t result = a1[13];
  if (result)
  {
    size_t v13 = v10;
    uint64_t v27 = a1[13];
    (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)result + 208))(result, "Attribute", 9);
    (*(void (**)(void, const char *, uint64_t, uint64_t))(*(void *)a1[13] + 24))(a1[13], "Tag", 3, a2);
    uint64_t v14 = (llvm::raw_ostream *)(*(uint64_t (**)(void))(*(void *)a1[13] + 248))(a1[13]);
    unint64_t v15 = v14;
    unsigned int v16 = (_DWORD *)*((void *)v14 + 4);
    if (*((void *)v14 + 3) - (void)v16 > 6uLL)
    {
      *(_DWORD *)((char *)v16 + 3) = 540697973;
      *unsigned int v16 = 1970037078;
      *((void *)v14 + 4) += 7;
    }
    else
    {
      llvm::raw_ostream::write(v14, "Value: ", 7uLL);
    }
    sub_1CD098D14(v15, ULEB128, 0, 0, 0);
    uint64_t v17 = (_WORD *)*((void *)v15 + 4);
    if (*((void *)v15 + 3) - (void)v17 > 1uLL)
    {
      _WORD *v17 = 8236;
      uint64_t v18 = (unsigned char *)(*((void *)v15 + 4) + 2);
      *((void *)v15 + 4) = v18;
    }
    else
    {
      llvm::raw_ostream::write(v15, ", ", 2uLL);
      uint64_t v18 = (unsigned char *)*((void *)v15 + 4);
    }
    if (v13 <= *((void *)v15 + 3) - (void)v18)
    {
      if (v13)
      {
        memcpy(v18, CStrRef, v13);
        uint64_t v18 = (unsigned char *)(*((void *)v15 + 4) + v13);
        *((void *)v15 + 4) = v18;
      }
    }
    else
    {
      llvm::raw_ostream::write(v15, (const char *)CStrRef, v13);
      uint64_t v18 = (unsigned char *)*((void *)v15 + 4);
    }
    if ((unint64_t)v18 >= *((void *)v15 + 3))
    {
      llvm::raw_ostream::write(v15, 10);
    }
    else
    {
      *((void *)v15 + 4) = v18 + 1;
      *uint64_t v18 = 10;
    }
    uint64_t v19 = a1[15];
    if (v19)
    {
      unint64_t v20 = (void *)(a1[14] + 16);
      uint64_t v21 = 24 * v19;
      unsigned int v22 = &unk_1CFC290E7;
      while (*((_DWORD *)v20 - 4) != a2)
      {
        v20 += 3;
        v21 -= 24;
        if (!v21)
        {
          unint64_t v23 = 0;
          goto LABEL_22;
        }
      }
      uint64_t v25 = *(v20 - 1);
      unint64_t v24 = *v20;
      uint64_t v26 = 4;
      if (v24 < 4) {
        uint64_t v26 = v24;
      }
      unsigned int v22 = (void *)(v25 + v26);
      unint64_t v23 = v24 - v26;
    }
    else
    {
      unint64_t v23 = 0;
      unsigned int v22 = &unk_1CFC290E7;
    }
LABEL_22:
    (*(void (**)(void, const char *, uint64_t, void *, unint64_t))(*(void *)a1[13] + 192))(a1[13], "TagName", 7, v22, v23);
    (*(void (**)(void))(*(void *)a1[13] + 192))();
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v27 + 216))(v27);
  }
  *a3 = 0;
  return result;
}

unint64_t llvm::ARM::WinEH::SavedRegisterMask(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 4);
  int v2 = (v1 >> 10) & 0x800 | (v1 >> 6) & 0x4000;
  unint64_t v3 = (unint64_t)~(-1 << ((BYTE2(v1) + 1) & 7)) << 40;
  if ((v1 & 0x80000) == 0)
  {
    v2 |= (32 << (BYTE2(v1) & 7)) - 16;
    unint64_t v3 = 0;
  }
  unsigned int v4 = v1 >> 22;
  int v5 = v2 | (((2 << (BYTE2(v1) & 7)) + 0xFFFF) << (~(v1 >> 22) & 3));
  if ((v4 & 4) == 0) {
    LOWORD(v5) = v2;
  }
  if (v4 < 0x3F4) {
    LOWORD(v5) = v2;
  }
  return v3 | (unsigned __int16)v5;
}

llvm::raw_ostream *llvm::PrintRecyclerStats(llvm *this, unint64_t a2, unint64_t a3)
{
  uint64_t v6 = (llvm::raw_ostream *)llvm::errs(this);
  unint64_t v7 = v6;
  uint64_t v8 = (void *)*((void *)v6 + 4);
  if (*((void *)v6 + 3) - (void)v8 > 0x16uLL)
  {
    qmemcpy(v8, "Recycler element size: ", 23);
    *((void *)v6 + 4) += 23;
  }
  else
  {
    llvm::raw_ostream::write(v6, "Recycler element size: ", 0x17uLL);
  }
  sub_1CD098D14(v7, (unint64_t)this, 0, 0, 0);
  int v9 = (unsigned char *)*((void *)v7 + 4);
  if ((unint64_t)v9 >= *((void *)v7 + 3))
  {
    llvm::raw_ostream::write(v7, 10);
  }
  else
  {
    *((void *)v7 + 4) = v9 + 1;
    unsigned char *v9 = 10;
  }
  size_t v10 = (void *)*((void *)v7 + 4);
  if (*((void *)v7 + 3) - (void)v10 > 0x1BuLL)
  {
    qmemcpy(v10, "Recycler element alignment: ", 28);
    *((void *)v7 + 4) += 28;
  }
  else
  {
    llvm::raw_ostream::write(v7, "Recycler element alignment: ", 0x1CuLL);
  }
  sub_1CD098D14(v7, a2, 0, 0, 0);
  unint64_t v11 = (unsigned char *)*((void *)v7 + 4);
  if ((unint64_t)v11 >= *((void *)v7 + 3))
  {
    llvm::raw_ostream::write(v7, 10);
  }
  else
  {
    *((void *)v7 + 4) = v11 + 1;
    *unint64_t v11 = 10;
  }
  uint64_t v12 = (void *)*((void *)v7 + 4);
  if (*((void *)v7 + 3) - (void)v12 > 0x26uLL)
  {
    qmemcpy(v12, "Number of elements free for recycling: ", 39);
    *((void *)v7 + 4) += 39;
  }
  else
  {
    llvm::raw_ostream::write(v7, "Number of elements free for recycling: ", 0x27uLL);
  }
  uint64_t result = sub_1CD098D14(v7, a3, 0, 0, 0);
  uint64_t v14 = (unsigned char *)*((void *)v7 + 4);
  if ((unint64_t)v14 >= *((void *)v7 + 3))
  {
    return llvm::raw_ostream::write(v7, 10);
  }
  else
  {
    *((void *)v7 + 4) = v14 + 1;
    *uint64_t v14 = 10;
  }
  return result;
}

void llvm::decodeBase64(uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t *a3@<X2>, void *a4@<X8>)
{
  unsigned int v4 = (unsigned char *)*a3;
  a3[1] = *a3;
  if (!a2)
  {
    *a4 = 0;
    return;
  }
  if ((a2 & 3) != 0)
  {
    v59[0] = 92;
    v59[1] = std::generic_category();
    sub_1CD06481C();
  }
  uint64_t v6 = a1;
  unint64_t v7 = 0;
  unint64_t v8 = a2 - 2;
  unint64_t v9 = a2 - 1;
  unint64_t v57 = 2 - a2;
  unint64_t v58 = a2 - 1;
  do
  {
    for (uint64_t i = 0; i != 4; ++i)
    {
      unint64_t v11 = i + v7;
      unint64_t v12 = *(unsigned __int8 *)(v6 + v7 + i);
      if (v12 > 0x7A) {
        goto LABEL_78;
      }
      int v13 = a456789[v12];
      if (v12 != 61 || v13 == 64)
      {
        if (v13 == 64)
        {
          unint64_t v11 = v7 + i;
LABEL_78:
          uint64_t v53 = std::generic_category();
          sub_1CD82AEC4((uint64_t)a4, 92, (uint64_t)v53, v12, v11);
        }
      }
      else
      {
        if (v11 < v8) {
          goto LABEL_78;
        }
        if (!(v57 + v7 + i) && *(unsigned char *)(v6 + v9) != 61)
        {
          unint64_t v11 = v8;
          goto LABEL_78;
        }
      }
      *((unsigned char *)v59 + i) = v13;
    }
    int v14 = (4 * LOBYTE(v59[0])) | (BYTE1(v59[0]) >> 4) & 3;
    unint64_t v15 = a3[2];
    if ((unint64_t)v4 >= v15)
    {
      unint64_t v17 = *a3;
      uint64_t v18 = &v4[-*a3];
      unint64_t v19 = (unint64_t)(v18 + 1);
      if ((uint64_t)(v18 + 1) < 0) {
        goto LABEL_79;
      }
      unint64_t v20 = v15 - v17;
      if (2 * v20 > v19) {
        unint64_t v19 = 2 * v20;
      }
      if (v20 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v21 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v21 = v19;
      }
      if (v21) {
        unsigned int v22 = (char *)operator new(v21);
      }
      else {
        unsigned int v22 = 0;
      }
      unint64_t v23 = &v18[(void)v22];
      unint64_t v24 = &v18[(void)v22];
      *unint64_t v24 = v14;
      unsigned int v16 = v24 + 1;
      if (v4 != (unsigned char *)v17)
      {
        uint64_t v25 = &v4[~v17];
        do
        {
          char v26 = *--v4;
          (v25--)[(void)v22] = v26;
        }
        while (v4 != (unsigned char *)v17);
        unsigned int v4 = (unsigned char *)*a3;
        unint64_t v23 = v22;
      }
      *a3 = (unint64_t)v23;
      a3[1] = (unint64_t)v16;
      a3[2] = (unint64_t)&v22[v21];
      if (v4) {
        operator delete(v4);
      }
      unint64_t v9 = v58;
    }
    else
    {
      *unsigned int v4 = v14;
      unsigned int v16 = v4 + 1;
    }
    a3[1] = (unint64_t)v16;
    int v27 = (16 * BYTE1(v59[0])) | (BYTE2(v59[0]) >> 2) & 0xF;
    unint64_t v28 = a3[2];
    if ((unint64_t)v16 < v28)
    {
      *unsigned int v16 = v27;
      uint64_t v29 = v16 + 1;
      goto LABEL_53;
    }
    unint64_t v30 = *a3;
    unint64_t v31 = &v16[-*a3];
    unint64_t v32 = (unint64_t)(v31 + 1);
    if ((uint64_t)(v31 + 1) < 0) {
      goto LABEL_79;
    }
    unint64_t v33 = v28 - v30;
    if (2 * v33 > v32) {
      unint64_t v32 = 2 * v33;
    }
    if (v33 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v34 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v34 = v32;
    }
    if (v34) {
      unint64_t v35 = (unint64_t)operator new(v34);
    }
    else {
      unint64_t v35 = 0;
    }
    unint64_t v36 = &v31[v35];
    unint64_t v37 = (char *)(v35 + v34);
    BOOL v38 = &v31[v35];
    unsigned char *v38 = v27;
    uint64_t v29 = v38 + 1;
    if (v16 == (unsigned char *)v30)
    {
      *a3 = (unint64_t)v36;
      a3[1] = (unint64_t)v29;
      a3[2] = (unint64_t)v37;
    }
    else
    {
      unint64_t v39 = &v16[~v30];
      do
      {
        char v40 = *--v16;
        (v39--)[v35] = v40;
      }
      while (v16 != (unsigned char *)v30);
      unsigned int v16 = (unsigned char *)*a3;
      *a3 = v35;
      a3[1] = (unint64_t)v29;
      a3[2] = (unint64_t)v37;
      if (!v16) {
        goto LABEL_52;
      }
    }
    operator delete(v16);
LABEL_52:
    unint64_t v9 = v58;
LABEL_53:
    a3[1] = (unint64_t)v29;
    char v41 = BYTE3(v59[0]) & 0x3F | (BYTE2(v59[0]) << 6);
    unint64_t v42 = a3[2];
    if ((unint64_t)v29 < v42)
    {
      *uint64_t v29 = v41;
      unsigned int v4 = v29 + 1;
      unint64_t v43 = a2;
      uint64_t v6 = a1;
      goto LABEL_72;
    }
    unint64_t v44 = *a3;
    uint64_t v45 = &v29[-*a3];
    unint64_t v46 = (unint64_t)(v45 + 1);
    if ((uint64_t)(v45 + 1) < 0) {
LABEL_79:
    }
      abort();
    unint64_t v47 = v42 - v44;
    if (2 * v47 > v46) {
      unint64_t v46 = 2 * v47;
    }
    if (v47 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v48 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v48 = v46;
    }
    if (v48) {
      unint64_t v49 = (unint64_t)operator new(v48);
    }
    else {
      unint64_t v49 = 0;
    }
    uint64_t v50 = (char *)(v49 + v48);
    v45[v49] = v41;
    unsigned int v4 = &v45[v49 + 1];
    if (v29 == (unsigned char *)v44)
    {
      *a3 = (unint64_t)&v45[v49];
      a3[1] = (unint64_t)v4;
      a3[2] = (unint64_t)v50;
      uint64_t v6 = a1;
    }
    else
    {
      unint64_t v51 = &v29[~v44];
      uint64_t v6 = a1;
      do
      {
        char v52 = *--v29;
        (v51--)[v49] = v52;
      }
      while (v29 != (unsigned char *)v44);
      uint64_t v29 = (unsigned char *)*a3;
      *a3 = v49;
      a3[1] = (unint64_t)v4;
      a3[2] = (unint64_t)v50;
      if (!v29) {
        goto LABEL_71;
      }
    }
    operator delete(v29);
LABEL_71:
    unint64_t v43 = a2;
    unint64_t v9 = v58;
LABEL_72:
    a3[1] = (unint64_t)v4;
    v7 += 4;
  }
  while (v7 < v43);
  if (*(unsigned char *)(v6 + v9) == 61)
  {
    a3[1] = (unint64_t)(v4 - 1);
    if (*(unsigned char *)(v6 + v8) == 61) {
      a3[1] = (unint64_t)(v4 - 2);
    }
  }
  *a4 = 0;
}

uint64_t llvm::BinaryStreamError::BinaryStreamError(uint64_t a1, unsigned int a2)
{
  return llvm::BinaryStreamError::BinaryStreamError(a1, a2, (const std::string::value_type *)&unk_1CFC27472, 0);
}

{
  return llvm::BinaryStreamError::BinaryStreamError(a1, a2, (const std::string::value_type *)&unk_1CFC27472, 0);
}

uint64_t llvm::BinaryStreamError::BinaryStreamError(uint64_t a1, const std::string::value_type *a2, std::string::size_type a3)
{
  return llvm::BinaryStreamError::BinaryStreamError(a1, 0, a2, a3);
}

{
  return llvm::BinaryStreamError::BinaryStreamError(a1, 0, a2, a3);
}

char *llvm::BinaryStreamError::getErrorMessage(llvm::BinaryStreamError *this)
{
  uint64_t v3 = *((void *)this + 1);
  unsigned int v1 = (char *)this + 8;
  uint64_t v2 = v3;
  if (v1[23] >= 0) {
    return v1;
  }
  return (char *)v2;
}

__n128 llvm::BinaryStreamReader::BinaryStreamReader(uint64_t a1, __n128 *a2)
{
  unint64_t v3 = a2->n128_u64[0];
  uint64_t v2 = a2->n128_i64[1];
  *(void *)a1 = &unk_1F2632A58;
  *(void *)(a1 + 8) = v3;
  *(void *)(a1 + 16) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  __n128 result = a2[1];
  *(__n128 *)(a1 + 40) = a2[2];
  *(__n128 *)(a1 + 24) = result;
  *(void *)(a1 + 56) = 0;
  return result;
}

{
  uint64_t v2;
  unint64_t v3;
  __n128 result;

  unint64_t v3 = a2->n128_u64[0];
  uint64_t v2 = a2->n128_i64[1];
  *(void *)a1 = &unk_1F2632A58;
  *(void *)(a1 + 8) = v3;
  *(void *)(a1 + 16) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  __n128 result = a2[1];
  *(__n128 *)(a1 + 40) = a2[2];
  *(__n128 *)(a1 + 24) = result;
  *(void *)(a1 + 56) = 0;
  return result;
}

void *llvm::BinaryStreamReader::BinaryStreamReader(void *a1, uint64_t a2)
{
  *a1 = &unk_1F2632A58;
  llvm::BinaryStreamRef::BinaryStreamRef((uint64_t)(a1 + 1), a2);
  a1[7] = 0;
  return a1;
}

{
  *a1 = &unk_1F2632A58;
  llvm::BinaryStreamRef::BinaryStreamRef((uint64_t)(a1 + 1), a2);
  a1[7] = 0;
  return a1;
}

void *llvm::BinaryStreamReader::BinaryStreamReader(void *a1, std::__shared_weak_count_vtbl *a2, uint64_t a3, int a4)
{
  *a1 = &unk_1F2632A58;
  llvm::BinaryStreamRef::BinaryStreamRef(a1 + 1, a2, a3, a4);
  a1[7] = 0;
  return a1;
}

{
  *a1 = &unk_1F2632A58;
  llvm::BinaryStreamRef::BinaryStreamRef(a1 + 1, a2, a3, a4);
  a1[7] = 0;
  return a1;
}

{
  *a1 = &unk_1F2632A58;
  llvm::BinaryStreamRef::BinaryStreamRef(a1 + 1, a2, a3, a4);
  a1[7] = 0;
  return a1;
}

{
  *a1 = &unk_1F2632A58;
  llvm::BinaryStreamRef::BinaryStreamRef(a1 + 1, a2, a3, a4);
  a1[7] = 0;
  return a1;
}

uint64_t llvm::BinaryStreamReader::readLongestContiguousChunk@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t result = llvm::BinaryStreamRef::readLongestContiguousChunk(a1 + 8, *(void *)(a1 + 56), a2, a3);
  if (!*a3)
  {
    *(void *)(a1 + 56) += *(void *)(a2 + 8);
    *a3 = 0;
  }
  return result;
}

void llvm::BinaryStreamReader::readULEB128(llvm::BinaryStreamReader *this@<X0>, unint64_t *a2@<X1>, void *a3@<X8>)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = 0;
  uint64_t v6 = (char *)this + 8;
  while (1)
  {
    llvm::BinaryStreamRef::readBytes((uint64_t)v6, *((void *)this + 7), 1, a3);
    if (*a3) {
      break;
    }
    ++*((void *)this + 7);
    *a3 = 0;
    if ((unint64_t)(v13 + 1) > 0xA) {
      llvm::SmallVectorBase<unsigned long long>::grow_pod();
    }
    v14[v13] = MEMORY[0];
    uint64_t v7 = ++v13;
    if ((MEMORY[0] & 0x80000000) == 0)
    {
      uint64_t v8 = 0;
      unint64_t v9 = 0;
      unsigned int v10 = 0;
      while (v7 != v8)
      {
        char v11 = v14[v8];
        uint64_t v12 = v11 & 0x7F;
        if (v10 >= 0x40 && (v11 & 0x7F) != 0) {
          break;
        }
        if ((unint64_t)(v12 << v10) >> v10 != v12) {
          break;
        }
        v9 += v12 << v10;
        v10 += 7;
        ++v8;
        if ((v11 & 0x80) == 0) {
          goto LABEL_14;
        }
      }
      unint64_t v9 = 0;
LABEL_14:
      *a2 = v9;
      *a3 = 0;
      return;
    }
  }
}

void llvm::BinaryStreamReader::readSLEB128(llvm::BinaryStreamReader *this@<X0>, uint64_t *a2@<X1>, void *a3@<X8>)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v17 = 0;
  uint64_t v6 = (char *)this + 8;
  while (1)
  {
    llvm::BinaryStreamRef::readBytes((uint64_t)v6, *((void *)this + 7), 1, a3);
    if (*a3) {
      break;
    }
    ++*((void *)this + 7);
    *a3 = 0;
    if ((unint64_t)(v17 + 1) > 0xA) {
      llvm::SmallVectorBase<unsigned long long>::grow_pod();
    }
    v18[v17] = MEMORY[0];
    uint64_t v7 = ++v17;
    if ((MEMORY[0] & 0x80000000) == 0)
    {
      uint64_t v8 = 0;
      uint64_t v9 = 0;
      unsigned int v10 = 0;
      do
      {
        if (v7 == v8)
        {
LABEL_18:
          uint64_t v14 = 0;
          goto LABEL_25;
        }
        char v11 = v18[v8];
        uint64_t v12 = v11 & 0x7F;
        if (v10 >= 0x40)
        {
          if (((v9 >> 63) & 0x7F) != v12) {
            goto LABEL_18;
          }
        }
        else if (v10 == 63 && v12 != 127 && v12 != 0)
        {
          goto LABEL_18;
        }
        v9 |= v12 << v10;
        v10 += 7;
        ++v8;
      }
      while (v11 < 0);
      BOOL v15 = (v11 & 0x40) == 0 || v10 > 0x3F;
      uint64_t v16 = -1 << v10;
      if (v15) {
        uint64_t v16 = 0;
      }
      uint64_t v14 = v9 | v16;
LABEL_25:
      *a2 = v14;
      *a3 = 0;
      return;
    }
  }
}

uint64_t llvm::BinaryStreamReader::readWideString@<X0>(uint64_t a1@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = *(void *)(a1 + 56);
  unsigned int v10 = 0;
  uint64_t result = sub_1CD0477F0(a1, &v10, a3);
  if (!*a3)
  {
    unsigned int v8 = 0;
    while (*v10)
    {
      ++v8;
      uint64_t result = sub_1CD0477F0(a1, &v10, a3);
      if (*a3) {
        return result;
      }
    }
    uint64_t v9 = *(void *)(a1 + 56);
    *(void *)(a1 + 56) = v6;
    uint64_t result = sub_1CCC21EB0(a1, a2, v8, a3);
    if (!*a3)
    {
      *(void *)(a1 + 56) = v9;
      *a3 = 0;
    }
  }
  return result;
}

uint64_t sub_1CD0477F0@<X0>(uint64_t a1@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  uint64_t result = llvm::BinaryStreamRef::readBytes(a1 + 8, *(void *)(a1 + 56), 2, a3);
  if (!*a3)
  {
    *(void *)(a1 + 56) += 2;
    *a2 = 0;
    *a3 = 0;
  }
  return result;
}

uint64_t llvm::BinaryStreamReader::readStreamRef@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  if (*(unsigned char *)(a1 + 48))
  {
    uint64_t v6 = *(void *)(a1 + 40);
  }
  else
  {
    uint64_t v7 = *(void *)(a1 + 24);
    if (v7) {
      uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 40))(v7) - *(void *)(a1 + 32);
    }
    else {
      LODWORD(v6) = 0;
    }
  }
  unsigned int v8 = v6 - *(_DWORD *)(a1 + 56);

  return llvm::BinaryStreamReader::readStreamRef(a1, a2, v8, a3);
}

uint64_t llvm::BinaryStreamReader::readStreamRef@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned int a3@<W2>, void *a4@<X8>)
{
  if (*(unsigned char *)(a1 + 48))
  {
    uint64_t v8 = *(void *)(a1 + 40);
  }
  else
  {
    uint64_t v9 = *(void *)(a1 + 24);
    if (v9) {
      uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 40))(v9) - *(void *)(a1 + 32);
    }
    else {
      uint64_t v8 = 0;
    }
  }
  unint64_t v10 = *(void *)(a1 + 56);
  if (v8 - v10 < a3) {
    operator new();
  }
  sub_1CD047A9C(a1 + 8, v10, a3, (uint64_t)v16);
  long long v11 = v16[0];
  v16[0] = 0uLL;
  uint64_t v12 = *(std::__shared_weak_count **)(a2 + 8);
  *(_OWORD *)a2 = v11;
  if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
  long long v13 = v16[2];
  *(_OWORD *)(a2 + 16) = v16[1];
  *(_OWORD *)(a2 + 32) = v13;
  uint64_t v14 = (std::__shared_weak_count *)*((void *)&v16[0] + 1);
  if (*((void *)&v16[0] + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v16[0] + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
  uint64_t result = 0;
  *(void *)(a1 + 56) += a3;
  *a4 = 0;
  return result;
}

void sub_1CD047A9C(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  sub_1CD047F18(a1, a2, (uint64_t)&v7);
  sub_1CD047FEC((uint64_t)&v7, a3, a4);
  uint64_t v6 = v8;
  if (v8)
  {
    if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

uint64_t llvm::BinaryStreamReader::readSubstream@<X0>(uint64_t a1@<X0>, void *a2@<X1>, unsigned int a3@<W2>, void *a4@<X8>)
{
  *a2 = *(void *)(a1 + 56);
  return llvm::BinaryStreamReader::readStreamRef(a1, (uint64_t)(a2 + 1), a3, a4);
}

uint64_t llvm::BinaryStreamReader::padToAlignment@<X0>(llvm::BinaryStreamReader *this@<X0>, unsigned int a2@<W1>, void *a3@<X8>)
{
  return llvm::BinaryStreamReader::skip(this, ((*((void *)this + 7) + (unint64_t)a2 - 1) / a2) * a2 - *((void *)this + 7), a3);
}

void llvm::BinaryStreamReader::split(llvm::BinaryStreamReader *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  sub_1CD047F18((uint64_t)this + 8, *((void *)this + 7), (uint64_t)&v35);
  sub_1CD047F18((uint64_t)&v35, a2, (uint64_t)&v31);
  sub_1CD047FEC((uint64_t)&v35, a2, (uint64_t)v29);
  long long v5 = *(_OWORD *)v29;
  *(_OWORD *)uint64_t v29 = 0uLL;
  uint64_t v6 = (std::__shared_weak_count *)*((void *)&v35 + 1);
  long long v35 = v5;
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  long long v36 = *(_OWORD *)&v29[16];
  long long v37 = *(_OWORD *)&v29[32];
  uint64_t v7 = *(std::__shared_weak_count **)&v29[8];
  if (*(void *)&v29[8]
    && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v29[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  long long v8 = v35;
  if (*((void *)&v35 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v35 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  long long v27 = v36;
  long long v28 = v37;
  *(void *)uint64_t v29 = &unk_1F2632A58;
  *(_OWORD *)&v29[8] = v8;
  if (*((void *)&v8 + 1))
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v8 + 1) + 8), 1uLL, memory_order_relaxed);
    *(_OWORD *)&v29[24] = v27;
    *(_OWORD *)&v29[40] = v28;
    uint64_t v30 = 0;
    if (!atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v8 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      (*(void (**)(void))(**((void **)&v8 + 1) + 16))(*((void *)&v8 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v8 + 1));
    }
  }
  else
  {
    *(_OWORD *)&v29[24] = v36;
    *(_OWORD *)&v29[40] = v37;
    uint64_t v30 = 0;
  }
  uint64_t v9 = v31;
  unint64_t v10 = v32;
  if (v32) {
    atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  long long v19 = v33;
  long long v20 = v34;
  size_t v21 = &unk_1F2632A58;
  uint64_t v22 = v9;
  unint64_t v23 = v10;
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    long long v24 = v19;
    long long v25 = v20;
    uint64_t v26 = 0;
    if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  else
  {
    long long v24 = v33;
    long long v25 = v34;
    uint64_t v26 = 0;
  }
  uint64_t v12 = *(void *)&v29[8];
  uint64_t v11 = *(void *)&v29[16];
  *(void *)a3 = &unk_1F2632A58;
  *(void *)(a3 + 8) = v12;
  *(void *)(a3 + 16) = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  long long v13 = *(_OWORD *)&v29[40];
  *(_OWORD *)(a3 + 24) = *(_OWORD *)&v29[24];
  *(_OWORD *)(a3 + 40) = v13;
  uint64_t v15 = v22;
  uint64_t v14 = v23;
  *(void *)(a3 + 56) = v30;
  *(void *)(a3 + 64) = &unk_1F2632A58;
  *(void *)(a3 + 72) = v15;
  *(void *)(a3 + 80) = v14;
  if (v14) {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  long long v16 = v25;
  *(_OWORD *)(a3 + 88) = v24;
  *(_OWORD *)(a3 + 104) = v16;
  *(void *)(a3 + 120) = v26;
  sub_1CCC22DBC(&v21);
  sub_1CCC22DBC(v29);
  uint64_t v17 = v32;
  if (v32 && !atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
  uint64_t v18 = (std::__shared_weak_count *)*((void *)&v35 + 1);
  if (*((void *)&v35 + 1))
  {
    if (!atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v35 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
}

uint64_t sub_1CD047F18@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = (_OWORD *)(a1 + 16);
  uint64_t result = *(void *)(a1 + 16);
  if (result)
  {
    if (*(unsigned char *)(a1 + 40))
    {
      unint64_t v8 = *(void *)(a1 + 32);
    }
    else
    {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 40))(result);
      unint64_t v8 = result - *(void *)(a1 + 24);
    }
    if (v8 >= a2) {
      unint64_t v8 = a2;
    }
    uint64_t v9 = *(void *)(a1 + 8);
    *(void *)a3 = *(void *)a1;
    *(void *)(a3 + 8) = v9;
    if (v9) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
    }
    long long v10 = v6[1];
    *(_OWORD *)(a3 + 16) = *v6;
    *(_OWORD *)(a3 + 32) = v10;
    if (v8)
    {
      *(void *)(a3 + 24) += v8;
      if (*(unsigned char *)(a3 + 40)) {
        *(void *)(a3 + 32) -= v8;
      }
    }
  }
  else
  {
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
  }
  return result;
}

uint64_t sub_1CD047FEC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (*(unsigned char *)(a1 + 40))
  {
    uint64_t v6 = *(void *)(a1 + 32);
  }
  else
  {
    uint64_t v7 = *(void *)(a1 + 16);
    if (v7) {
      uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 40))(v7) - *(void *)(a1 + 24);
    }
    else {
      uint64_t v6 = 0;
    }
  }

  return sub_1CD048084(a1, v6 - a2, a3);
}

uint64_t sub_1CD048084@<X0>(uint64_t result@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v4 = (_OWORD *)(result + 16);
  if (*(void *)(result + 16))
  {
    uint64_t v6 = result;
    uint64_t v7 = *(void *)(result + 8);
    *(void *)a3 = *(void *)result;
    *(void *)(a3 + 8) = v7;
    if (v7) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
    }
    long long v8 = *(_OWORD *)(result + 32);
    *(_OWORD *)(a3 + 16) = *v4;
    *(_OWORD *)(a3 + 32) = v8;
    if (*(unsigned char *)(result + 40))
    {
      unint64_t v9 = *(void *)(result + 32);
    }
    else
    {
      uint64_t result = *(void *)v4;
      if (*(void *)v4)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 40))(result);
        unint64_t v9 = result - *(void *)(v6 + 24);
      }
      else
      {
        unint64_t v9 = 0;
      }
    }
    if (v9 < a2) {
      a2 = v9;
    }
    if (a2)
    {
      if (*(unsigned char *)(a3 + 40))
      {
        uint64_t v10 = *(void *)(a3 + 32);
      }
      else
      {
        if (*(unsigned char *)(v6 + 40))
        {
          uint64_t v10 = *(void *)(v6 + 32);
        }
        else
        {
          uint64_t result = *(void *)v4;
          if (*(void *)v4)
          {
            uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 40))(result);
            uint64_t v10 = result - *(void *)(v6 + 24);
          }
          else
          {
            uint64_t v10 = 0;
          }
        }
        *(unsigned char *)(a3 + 40) = 1;
      }
      *(void *)(a3 + 32) = v10 - a2;
    }
  }
  else
  {
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
  }
  return result;
}

void *llvm::BinaryStreamRef::BinaryStreamRef(void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  llvm::raw_ostream *result = 0;
  result[1] = 0;
  result[2] = a2;
  result[3] = a3;
  result[4] = a4;
  result[5] = a5;
  return result;
}

{
  llvm::raw_ostream *result = 0;
  result[1] = 0;
  result[2] = a2;
  result[3] = a3;
  result[4] = a4;
  result[5] = a5;
  return result;
}

void *llvm::BinaryStreamRef::BinaryStreamRef(void *a1, std::__shared_weak_count_vtbl *a2, uint64_t a3, int a4)
{
  long long v8 = (std::__shared_weak_count *)operator new(0x40uLL);
  v8->__shared_owners_ = 0;
  v8->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2643648;
  v8->__shared_weak_owners_ = 0;
  v8[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2643680;
  v8[1].__shared_owners_ = (uint64_t)&unk_1F2632A10;
  LODWORD(v8[1].__shared_weak_owners_) = a4;
  v8[2].__vftable = a2;
  v8[2].__shared_owners_ = a3;
  *a1 = v8 + 1;
  a1[1] = v8;
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  a1[2] = v8 + 1;
  a1[3] = 0;
  a1[4] = a3;
  a1[5] = 1;
  if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    unint64_t v9 = v8;
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v9);
  }
  return a1;
}

void *llvm::WritableBinaryStreamRef::WritableBinaryStreamRef(void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  llvm::raw_ostream *result = 0;
  result[1] = 0;
  result[2] = a2;
  result[3] = a3;
  result[4] = a4;
  result[5] = a5;
  return result;
}

{
  llvm::raw_ostream *result = 0;
  result[1] = 0;
  result[2] = a2;
  result[3] = a3;
  result[4] = a4;
  result[5] = a5;
  return result;
}

__n128 llvm::WritableBinaryStreamRef::operator llvm::BinaryStreamRef@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = *(void *)(a1 + 40);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = v2;
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(a2 + 24) = result;
  *(void *)(a2 + 40) = v3;
  return result;
}

uint64_t llvm::WritableBinaryStreamRef::commit(llvm::WritableBinaryStreamRef *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 64))();
}

void sub_1CD048354(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2643648;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1CD048374(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2643648;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD0483C8(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1CD0483F4()
{
}

uint64_t sub_1CD048408(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t sub_1CD048410@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X3>, void *a5@<X8>)
{
  uint64_t result = sub_1CD6C8158(a1 + 8, a2, a3, a5);
  if (!*a5)
  {
    *a4 = *(void *)(a1 + 24) + a2;
    a4[1] = a3;
    *a5 = 0;
  }
  return result;
}

uint64_t sub_1CD048470@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  uint64_t result = sub_1CD6C8158(a1 + 8, a2, 1, a4);
  if (!*a4)
  {
    unint64_t v9 = *(void *)(a1 + 32) - a2;
    *a3 = *(void *)(a1 + 24) + a2;
    a3[1] = v9;
    *a4 = 0;
  }
  return result;
}

uint64_t sub_1CD0484CC(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

void sub_1CD0484D4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26436C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1CD0484F4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26436C8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD048548(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1CD048574()
{
}

uint64_t sub_1CD048588(uint64_t a1)
{
  return *(unsigned int *)(a1 + 40);
}

uint64_t sub_1CD048590@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X3>, void *a5@<X8>)
{
  uint64_t result = sub_1CD6C8158(a1 + 32, a2, a3, a5);
  if (!*a5)
  {
    *a4 = *(void *)(a1 + 48) + a2;
    a4[1] = a3;
    *a5 = 0;
  }
  return result;
}

uint64_t sub_1CD0485F0@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  uint64_t result = sub_1CD6C8158(a1 + 32, a2, 1, a4);
  if (!*a4)
  {
    unint64_t v9 = *(void *)(a1 + 56) - a2;
    *a3 = *(void *)(a1 + 48) + a2;
    a3[1] = v9;
    *a4 = 0;
  }
  return result;
}

uint64_t sub_1CD04864C(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

unint64_t sub_1CD048654@<X0>(unint64_t result@<X0>, unint64_t a2@<X1>, const void *a3@<X2>, size_t a4@<X3>, void *a5@<X8>)
{
  if (!a4) {
    goto LABEL_2;
  }
  unint64_t v9 = result;
  uint64_t result = sub_1CD82BE68(result + 8, a2, a4, a5);
  if (!*a5)
  {
    uint64_t result = (unint64_t)memcpy((void *)(*(void *)(v9 + 16) + a2), a3, a4);
LABEL_2:
    *a5 = 0;
  }
  return result;
}

void sub_1CD0486CC(void *a1@<X8>)
{
  *a1 = 0;
}

__n128 llvm::BinaryStreamWriter::BinaryStreamWriter(uint64_t a1, __n128 *a2)
{
  unint64_t v3 = a2->n128_u64[0];
  uint64_t v2 = a2->n128_i64[1];
  *(void *)a1 = &unk_1F26437B0;
  *(void *)(a1 + 8) = v3;
  *(void *)(a1 + 16) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  __n128 result = a2[1];
  *(__n128 *)(a1 + 40) = a2[2];
  *(__n128 *)(a1 + 24) = result;
  *(void *)(a1 + 56) = 0;
  return result;
}

{
  uint64_t v2;
  unint64_t v3;
  __n128 result;

  unint64_t v3 = a2->n128_u64[0];
  uint64_t v2 = a2->n128_i64[1];
  *(void *)a1 = &unk_1F26437B0;
  *(void *)(a1 + 8) = v3;
  *(void *)(a1 + 16) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  __n128 result = a2[1];
  *(__n128 *)(a1 + 40) = a2[2];
  *(__n128 *)(a1 + 24) = result;
  *(void *)(a1 + 56) = 0;
  return result;
}

void *llvm::BinaryStreamWriter::BinaryStreamWriter(void *a1, uint64_t a2)
{
  *a1 = &unk_1F26437B0;
  llvm::BinaryStreamRef::BinaryStreamRef((uint64_t)(a1 + 1), a2);
  a1[7] = 0;
  return a1;
}

{
  *a1 = &unk_1F26437B0;
  llvm::BinaryStreamRef::BinaryStreamRef((uint64_t)(a1 + 1), a2);
  a1[7] = 0;
  return a1;
}

void *llvm::BinaryStreamWriter::BinaryStreamWriter(void *a1, std::__shared_weak_count_vtbl *a2, std::__shared_weak_count_vtbl *a3, int a4)
{
  *a1 = &unk_1F26437B0;
  llvm::WritableBinaryStreamRef::WritableBinaryStreamRef(a1 + 1, a2, a3, a4);
  a1[7] = 0;
  return a1;
}

{
  *a1 = &unk_1F26437B0;
  llvm::WritableBinaryStreamRef::WritableBinaryStreamRef(a1 + 1, a2, a3, a4);
  a1[7] = 0;
  return a1;
}

uint64_t llvm::BinaryStreamWriter::writeULEB128@<X0>(llvm::BinaryStreamWriter *this@<X0>, unint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = 0;
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  __int16 v9 = 0;
  uint64_t v8 = 0;
  do
  {
    BOOL v6 = a2 > 0x7F;
    *((unsigned char *)&v8 + v5++) = a2 & 0x7F | ((a2 > 0x7F) << 7);
    a2 >>= 7;
  }
  while (v6);
  uint64_t result = llvm::WritableBinaryStreamRef::writeBytes((uint64_t)this + 8, *((void *)this + 7), v5, a3);
  if (!*a3)
  {
    *((void *)this + 7) += v5;
    *a3 = 0;
  }
  return result;
}

uint64_t llvm::BinaryStreamWriter::writeSLEB128@<X0>(llvm::BinaryStreamWriter *this@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  __int16 v13 = 0;
  uint64_t v12 = 0;
  uint64_t v5 = &v12;
  while (1)
  {
    char v6 = a2 & 0x7F;
    if ((unint64_t)a2 <= 0x3F) {
      break;
    }
    uint64_t v7 = ((unint64_t)a2 >> 6) & 1;
    a2 >>= 7;
    int v8 = (a2 == -1) & v7;
    if (v8) {
      char v9 = 0;
    }
    else {
      char v9 = 0x80;
    }
    *(unsigned char *)uint64_t v5 = v9 | v6;
    uint64_t v5 = (uint64_t *)((char *)v5 + 1);
    if (v8) {
      goto LABEL_9;
    }
  }
  *(unsigned char *)uint64_t v5 = v6;
  LODWORD(v5) = v5 + 1;
LABEL_9:
  uint64_t v10 = v5 - &v12;
  uint64_t result = llvm::WritableBinaryStreamRef::writeBytes((uint64_t)this + 8, *((void *)this + 7), v10, a3);
  if (!*a3)
  {
    *((void *)this + 7) += v10;
    *a3 = 0;
  }
  return result;
}

uint64_t llvm::BinaryStreamWriter::writeFixedString@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, void *a3@<X8>)
{
  uint64_t result = llvm::WritableBinaryStreamRef::writeBytes(a1 + 8, *(void *)(a1 + 56), a2, a3);
  if (!*a3)
  {
    *(void *)(a1 + 56) += a2;
    *a3 = 0;
  }
  return result;
}

void llvm::BinaryStreamWriter::writeStreamRef(uint64_t a1@<X0>, uint64_t *a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = (std::__shared_weak_count *)a2[1];
  uint64_t v10 = *a2;
  uint64_t v11 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  long long v6 = *((_OWORD *)a2 + 2);
  long long v12 = *((_OWORD *)a2 + 1);
  long long v13 = v6;
  if (*((unsigned char *)a2 + 40))
  {
    uint64_t v7 = a2[4];
  }
  else
  {
    uint64_t v8 = a2[2];
    if (v8) {
      uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 40))(v8) - a2[3];
    }
    else {
      uint64_t v7 = 0;
    }
  }
  llvm::BinaryStreamWriter::writeStreamRef(a1, (uint64_t)&v10, v7, a3);
  char v9 = v11;
  if (v11)
  {
    if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
}

void *llvm::BinaryStreamWriter::writeStreamRef@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  sub_1CD047A9C(a2, 0, a3, (uint64_t)&v13);
  v17[0] = &unk_1F2632A58;
  v17[1] = v13;
  v17[2] = v14;
  if (v14)
  {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    long long v6 = v14;
    long long v18 = v15;
    long long v19 = v16;
    uint64_t v20 = 0;
    if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  else
  {
    long long v18 = v15;
    long long v19 = v16;
    uint64_t v20 = 0;
  }
  while (1)
  {
    if (BYTE8(v19))
    {
      uint64_t v7 = v19;
    }
    else if ((void)v18)
    {
      uint64_t v8 = (*(uint64_t (**)(void))(*(void *)v18 + 40))(v18);
      uint64_t v7 = v8 - *((void *)&v18 + 1);
    }
    else
    {
      uint64_t v7 = 0;
    }
    if (v7 == v20) {
      break;
    }
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    llvm::BinaryStreamReader::readLongestContiguousChunk((uint64_t)v17, (uint64_t)&v11, a4);
    if (*a4) {
      return sub_1CCC22DBC(v17);
    }
    uint64_t v9 = v12;
    llvm::WritableBinaryStreamRef::writeBytes(a1 + 8, *(void *)(a1 + 56), v12, a4);
    if (*a4) {
      return sub_1CCC22DBC(v17);
    }
    *(void *)(a1 + 56) += v9;
    *a4 = 0;
  }
  *a4 = 0;
  return sub_1CCC22DBC(v17);
}

void llvm::BinaryStreamWriter::split(llvm::BinaryStreamWriter *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  sub_1CD047F18((uint64_t)this + 8, *((void *)this + 7), (uint64_t)&v35);
  sub_1CD047F18((uint64_t)&v35, a2, (uint64_t)&v31);
  sub_1CD047FEC((uint64_t)&v35, a2, (uint64_t)v29);
  long long v5 = *(_OWORD *)v29;
  *(_OWORD *)uint64_t v29 = 0uLL;
  long long v6 = (std::__shared_weak_count *)*((void *)&v35 + 1);
  long long v35 = v5;
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  long long v36 = *(_OWORD *)&v29[16];
  long long v37 = *(_OWORD *)&v29[32];
  uint64_t v7 = *(std::__shared_weak_count **)&v29[8];
  if (*(void *)&v29[8]
    && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v29[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  long long v8 = v35;
  if (*((void *)&v35 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v35 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  long long v27 = v36;
  long long v28 = v37;
  *(void *)uint64_t v29 = &unk_1F26437B0;
  *(_OWORD *)&v29[8] = v8;
  if (*((void *)&v8 + 1))
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v8 + 1) + 8), 1uLL, memory_order_relaxed);
    *(_OWORD *)&v29[24] = v27;
    *(_OWORD *)&v29[40] = v28;
    uint64_t v30 = 0;
    if (!atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v8 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      (*(void (**)(void))(**((void **)&v8 + 1) + 16))(*((void *)&v8 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v8 + 1));
    }
  }
  else
  {
    *(_OWORD *)&v29[24] = v36;
    *(_OWORD *)&v29[40] = v37;
    uint64_t v30 = 0;
  }
  uint64_t v9 = v31;
  uint64_t v10 = v32;
  if (v32) {
    atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  long long v19 = v33;
  long long v20 = v34;
  size_t v21 = &unk_1F26437B0;
  uint64_t v22 = v9;
  unint64_t v23 = v10;
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    long long v24 = v19;
    long long v25 = v20;
    uint64_t v26 = 0;
    if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  else
  {
    long long v24 = v33;
    long long v25 = v34;
    uint64_t v26 = 0;
  }
  uint64_t v12 = *(void *)&v29[8];
  uint64_t v11 = *(void *)&v29[16];
  *(void *)a3 = &unk_1F26437B0;
  *(void *)(a3 + 8) = v12;
  *(void *)(a3 + 16) = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  long long v13 = *(_OWORD *)&v29[40];
  *(_OWORD *)(a3 + 24) = *(_OWORD *)&v29[24];
  *(_OWORD *)(a3 + 40) = v13;
  uint64_t v15 = v22;
  uint64_t v14 = v23;
  *(void *)(a3 + 56) = v30;
  *(void *)(a3 + 64) = &unk_1F26437B0;
  *(void *)(a3 + 72) = v15;
  *(void *)(a3 + 80) = v14;
  if (v14) {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  long long v16 = v25;
  *(_OWORD *)(a3 + 88) = v24;
  *(_OWORD *)(a3 + 104) = v16;
  *(void *)(a3 + 120) = v26;
  sub_1CD049224(&v21);
  sub_1CD049224(v29);
  uint64_t v17 = v32;
  if (v32 && !atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
  long long v18 = (std::__shared_weak_count *)*((void *)&v35 + 1);
  if (*((void *)&v35 + 1))
  {
    if (!atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v35 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
}

uint64_t llvm::BinaryStreamWriter::padToAlignment@<X0>(llvm::BinaryStreamWriter *this@<X0>, unsigned int a2@<W1>, void *a3@<X8>)
{
  unint64_t v5 = (*((void *)this + 7) + (unint64_t)a2 - 1) / a2 * a2;
  if (*((unsigned char *)this + 48))
  {
    unint64_t v6 = *((void *)this + 5);
  }
  else
  {
    uint64_t v7 = *((void *)this + 3);
    if (v7) {
      unint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 40))(v7) - *((void *)this + 4);
    }
    else {
      unint64_t v6 = 0;
    }
  }
  if (v5 > v6) {
    operator new();
  }
  while (*((void *)this + 7) < v5)
  {
    uint64_t result = sub_1CD049154((uint64_t)this, a3);
    if (*a3) {
      return result;
    }
  }
  uint64_t result = 0;
  *a3 = 0;
  return result;
}

uint64_t sub_1CD049154@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = a1 + 8;
  (*(void (**)(void))(**(void **)(a1 + 24) + 16))(*(void *)(a1 + 24));
  uint64_t result = llvm::WritableBinaryStreamRef::writeBytes(v4, *(void *)(a1 + 56), 1, a2);
  if (!*a2)
  {
    ++*(void *)(a1 + 56);
    *a2 = 0;
  }
  return result;
}

void sub_1CD0491EC(void *a1)
{
  sub_1CD049224(a1);

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CD049224(void *a1)
{
  *a1 = &unk_1F26437B0;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void llvm::Bisector<std::string>::resetAndStartLearning(uint64_t a1)
{
  *(_DWORD *)(a1 + 56) = 0;
  *(unsigned char *)(a1 + 120) = 1;
}

void sub_1CD0492DC(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 + 8);
  sub_1CB833850(a1, *(char **)(a1 + 8));
  *(void *)a1 = v2;
  *(void *)(a1 + 16) = 0;
  void *v2 = 0;
  uint64_t v3 = *(void *)(a1 + 24);
  for (uint64_t i = *(void *)(a1 + 32); i != v3; i -= 32)
  {
    if (*(char *)(i - 9) < 0) {
      operator delete(*(void **)(i - 32));
    }
  }
  *(void *)(a1 + 32) = v3;
}

uint64_t llvm::Bisector<std::string>::startBisect(uint64_t result)
{
  *(unsigned char *)(result + 120) = 0;
  uint64_t v1 = (*(void *)(result + 32) - *(void *)(result + 24)) >> 6;
  unsigned int v2 = *(_DWORD *)(result + 56);
  if (v2 >= *(_DWORD *)(result + 60)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)(result + 48) + 4 * v2) = v1;
  ++*(_DWORD *)(result + 56);
  uint64_t v3 = *(void *)(result + 24);
  uint64_t v4 = *(void *)(result + 32) - v3;
  uint64_t v5 = (unint64_t)v4 >> 5;
  if (v4 >= 1)
  {
    uint64_t v6 = 0;
    if (v5 <= 1) {
      uint64_t v7 = 1;
    }
    else {
      uint64_t v7 = v5;
    }
    uint64x2_t v8 = (uint64x2_t)vdupq_n_s64(v7 - 1);
    int64x2_t v9 = (int64x2_t)xmmword_1CD96D880;
    uint64_t v10 = (BOOL *)(v3 + 56);
    int64x2_t v11 = vdupq_n_s64(2uLL);
    do
    {
      int32x2_t v12 = vmovn_s64((int64x2_t)vcgeq_u64(v8, (uint64x2_t)v9));
      if (v12.i8[0]) {
        *(v10 - 32) = v6 < (int)v1;
      }
      if (v12.i8[4]) {
        *uint64_t v10 = v6 + 1 < (int)v1;
      }
      v6 += 2;
      int64x2_t v9 = vaddq_s64(v9, v11);
      v10 += 64;
    }
    while (((v7 + 1) & 0xFFFFFFFFFFFFFFELL) != v6);
  }
  *(_DWORD *)(result + 112) = v5;
  *(_DWORD *)(result + 116) = 0;
  return result;
}

uint64_t llvm::Bisector<std::string>::updateMapForNewCounter(uint64_t result, int a2)
{
  uint64_t v2 = *(void *)(result + 24);
  uint64_t v3 = *(void *)(result + 32) - v2;
  if (v3 >= 1)
  {
    uint64_t v4 = 0;
    uint64_t v5 = (unint64_t)v3 >> 5;
    if (v5 <= 1) {
      uint64_t v6 = 1;
    }
    else {
      uint64_t v6 = v5;
    }
    uint64x2_t v7 = (uint64x2_t)vdupq_n_s64(v6 - 1);
    int64x2_t v8 = (int64x2_t)xmmword_1CD96D880;
    int64x2_t v9 = (BOOL *)(v2 + 56);
    int64x2_t v10 = vdupq_n_s64(2uLL);
    do
    {
      int32x2_t v11 = vmovn_s64((int64x2_t)vcgeq_u64(v7, (uint64x2_t)v8));
      if (v11.i8[0]) {
        *(v9 - 32) = v4 < a2;
      }
      if (v11.i8[4]) {
        BOOL *v9 = v4 + 1 < a2;
      }
      v4 += 2;
      int64x2_t v8 = vaddq_s64(v8, v10);
      v9 += 64;
    }
    while (((v6 + 1) & 0xFFFFFFFFFFFFFFELL) != v4);
  }
  return result;
}

void llvm::Bisector<std::string>::learnKey(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_1CB8BDF7C((uint64_t)__p, *(const void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)__p = *(_OWORD *)a2;
    uint64_t v4 = *(void *)(a2 + 16);
  }
  v5[0] = 1;
  sub_1CD04A44C(a1, (long long *)__p, v5);
  if (SHIBYTE(v4) < 0) {
    operator delete(__p[0]);
  }
}

BOOL llvm::Bisector<std::string>::shouldPerformActionOnKey(uint64_t a1, void *a2)
{
  uint64_t v3 = sub_1CD4F3EC8(a1, a2);
  return a1 + 8 != v3 && *(unsigned char *)(*(void *)(a1 + 24) + 32 * *(unsigned int *)(v3 + 56) + 24) != 0;
}

unsigned int *llvm::Bisector<std::string>::finishBisectionRound@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v7 = *(void *)(a1 + 48);
  uint64_t result = (unsigned int *)(a1 + 48);
  uint64_t v6 = v7;
  uint64_t v8 = result[2];
  int v9 = *(_DWORD *)(v7 + 4 * v8 - 4);
  if (a2)
  {
    *(_DWORD *)(a1 + 116) = v9;
    int v10 = *(_DWORD *)(a1 + 112);
  }
  else
  {
    *(_DWORD *)(a1 + 112) = v9;
    int v10 = v9;
    int v9 = *(_DWORD *)(a1 + 116);
  }
  if (v9 + 1 != v10)
  {
    BOOL v13 = __OFADD__(v9, v10);
    int v14 = v9 + v10;
    if (v14 < 0 != v13) {
      ++v14;
    }
    int v15 = v14 >> 1;
    if (v8 >= *(_DWORD *)(a1 + 60)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(_DWORD *)(v6 + 4 * v8) = v15;
    ++*(_DWORD *)(a1 + 56);
    uint64_t v16 = *(void *)(a1 + 24);
    uint64_t v17 = *(void *)(a1 + 32) - v16;
    if (v17 >= 1)
    {
      uint64_t v18 = 0;
      uint64_t v19 = (unint64_t)v17 >> 5;
      if (v19 <= 1) {
        uint64_t v20 = 1;
      }
      else {
        uint64_t v20 = v19;
      }
      uint64x2_t v21 = (uint64x2_t)vdupq_n_s64(v20 - 1);
      int64x2_t v22 = (int64x2_t)xmmword_1CD96D880;
      unint64_t v23 = (BOOL *)(v16 + 56);
      int64x2_t v24 = vdupq_n_s64(2uLL);
      do
      {
        int32x2_t v25 = vmovn_s64((int64x2_t)vcgeq_u64(v21, (uint64x2_t)v22));
        if (v25.i8[0]) {
          *(v23 - 32) = v18 < v15;
        }
        if (v25.i8[4]) {
          *unint64_t v23 = v18 + 1 < v15;
        }
        v18 += 2;
        int64x2_t v22 = vaddq_s64(v22, v24);
        v23 += 64;
      }
      while (((v20 + 1) & 0xFFFFFFFFFFFFFFELL) != v18);
    }
    if (*(char *)(a1 + 151) < 0)
    {
      if (*(void *)(a1 + 136)) {
LABEL_22:
      }
        llvm::Bisector<std::string>::serializeToFile();
    }
    else if (*(unsigned char *)(a1 + 151))
    {
      goto LABEL_22;
    }
    char v26 = 0;
    *(unsigned char *)a3 = 0;
    goto LABEL_26;
  }
  uint64_t v11 = *(void *)(a1 + 24) + 32 * v9;
  if (*(char *)(v11 + 23) < 0)
  {
    uint64_t result = (unsigned int *)sub_1CB8BDF7C(a3, *(const void **)v11, *(void *)(v11 + 8));
  }
  else
  {
    long long v12 = *(_OWORD *)v11;
    *(void *)(a3 + 16) = *(void *)(v11 + 16);
    *(_OWORD *)a3 = v12;
  }
  char v26 = 1;
LABEL_26:
  *(unsigned char *)(a3 + 24) = v26;
  return result;
}

void llvm::Bisector<std::string>::serializeToFile(uint64_t a1, unsigned char *a2, uint64_t a3)
{
  v85[4] = *(void ***)MEMORY[0x1E4F143B8];
  int v53 = 0;
  unsigned int v54 = std::system_category();
  llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)v52, a2, a3, (uint64_t)&v53);
  if (v53) {
    llvm::report_fatal_error((llvm *)"Could not open file for saving", (const llvm::Twine *)1);
  }
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  uint64_t v49 = 0;
  uint64_t v50 = 0;
  int v51 = 0;
  unint64_t v46 = 0;
  unint64_t v47 = 0;
  size_t v48 = 0;
  unint64_t v43 = 0;
  unint64_t v44 = 0;
  unint64_t v45 = 0;
  uint64_t v8 = *(long long **)(a1 + 24);
  int v9 = *(long long **)(a1 + 32);
  if (v8 != v9)
  {
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    do
    {
      if (*((char *)v8 + 23) < 0)
      {
        sub_1CB8BDF7C((uint64_t)__p, *(const void **)v8, *((void *)v8 + 1));
      }
      else
      {
        long long v10 = *v8;
        uint64_t v42 = *((void *)v8 + 2);
        *(_OWORD *)__p = v10;
      }
      sub_1CD452764((uint64_t)v85, (unint64_t)__p);
      if (SHIBYTE(v42) < 0) {
        operator delete(__p[0]);
      }
      if (v7 >= (unsigned __int16 *)v48)
      {
        uint64_t v7 = sub_1CD04A694((unsigned __int16 **)&v46, (unsigned __int16 *)v85);
      }
      else
      {
        llvm::json::Value::copyFrom(v7, (unsigned __int16 *)v85);
        v7 += 16;
        uint64_t v6 = v44;
      }
      unint64_t v47 = v7;
      char v11 = *((unsigned char *)v8 + 24);
      unsigned __int16 v81 = 1;
      LOBYTE(v82) = v11;
      if ((unint64_t)v6 >= v45)
      {
        uint64_t v6 = sub_1CD04A694(&v43, &v81);
      }
      else
      {
        llvm::json::Value::copyFrom(v6, &v81);
        v6 += 16;
      }
      unint64_t v44 = v6;
      llvm::json::Value::destroy((llvm::json::Value *)&v81);
      llvm::json::Value::destroy((llvm::json::Value *)v85);
      v8 += 2;
    }
    while (v8 != v9);
  }
  long long v12 = 0;
  unint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t v38 = 0;
  unint64_t v39 = 0;
  char v40 = 0;
  uint64_t v15 = *(unsigned int *)(a1 + 56);
  if (v15)
  {
    unint64_t v13 = 0;
    uint64_t v37 = a1;
    uint64_t v16 = *(int **)(a1 + 48);
    uint64_t v17 = &v16[v15];
    do
    {
      uint64_t v18 = *v16;
      if (v13 >= (unint64_t)v40)
      {
        uint64_t v19 = v38;
        uint64_t v20 = (uint64_t)(v13 - v38) >> 5;
        unint64_t v21 = v20 + 1;
        if ((unint64_t)(v20 + 1) >> 59) {
          abort();
        }
        uint64_t v22 = (uint64_t)&v40[-v38];
        if ((uint64_t)&v40[-v38] >> 4 > v21) {
          unint64_t v21 = v22 >> 4;
        }
        if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v23 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v23 = v21;
        }
        if (v23 >> 59) {
          sub_1CB833614();
        }
        int64x2_t v24 = (char *)operator new(32 * v23);
        uint64_t v25 = (uint64_t)&v24[32 * v20];
        char v26 = &v24[32 * v23];
        *(_WORD *)uint64_t v25 = 3;
        *(void *)(v25 + 8) = v18;
        uint64_t v27 = v25 + 32;
        if (v13 == v19)
        {
          uint64_t v38 = v25;
          unint64_t v39 = (llvm::json::Value *)(v25 + 32);
          char v40 = &v24[32 * v23];
        }
        else
        {
          do
          {
            v25 -= 32;
            v13 -= 32;
            llvm::json::Value::moveFrom(v25, (unsigned __int16 *)v13);
          }
          while (v13 != v19);
          unint64_t v13 = v38;
          long long v28 = v39;
          uint64_t v38 = v25;
          unint64_t v39 = (llvm::json::Value *)v27;
          char v40 = v26;
          while (v28 != (llvm::json::Value *)v13)
          {
            long long v28 = (llvm::json::Value *)((char *)v28 - 32);
            llvm::json::Value::destroy(v28);
          }
        }
        if (v13) {
          operator delete((void *)v13);
        }
        unint64_t v13 = v27;
      }
      else
      {
        *(_WORD *)unint64_t v13 = 3;
        *(void *)(v13 + 8) = v18;
        v13 += 32;
      }
      unint64_t v39 = (llvm::json::Value *)v13;
      ++v16;
    }
    while (v16 != v17);
    uint64_t v7 = v47;
    uint64_t v6 = v44;
    a1 = v37;
    uint64_t v14 = v38;
    long long v12 = v40;
  }
  LOWORD(v85[0]) = 8;
  v85[1] = v46;
  v85[2] = (void **)v7;
  v85[3] = v48;
  unint64_t v47 = 0;
  size_t v48 = 0;
  unsigned __int16 v81 = 8;
  unsigned int v82 = v43;
  int v83 = v6;
  unint64_t v84 = v45;
  unint64_t v45 = 0;
  unint64_t v46 = 0;
  unint64_t v43 = 0;
  unint64_t v44 = 0;
  unsigned __int16 v77 = 8;
  uint64_t v78 = v14;
  unint64_t v79 = v13;
  uint64_t v80 = v12;
  uint64_t v38 = 0;
  unint64_t v39 = 0;
  char v40 = 0;
  unsigned __int16 v75 = 3;
  uint64_t v29 = *(int *)(a1 + 116);
  uint64_t v76 = *(int *)(a1 + 112);
  unsigned __int16 v73 = 3;
  uint64_t v74 = v29;
  char v30 = *(unsigned char *)(a1 + 120);
  unsigned __int16 v71 = 1;
  char v72 = v30;
  sub_1CBF2C538(v69, "key_state_strings", 0x11uLL);
  llvm::json::Value::copyFrom(v70, (unsigned __int16 *)v85);
  sub_1CD82C208((uint64_t)&v55, (uint64_t)&v49, (uint64_t)v69, (unsigned __int16 *)v70);
  llvm::json::Value::destroy((llvm::json::Value *)v70);
  uint64_t v31 = v69[0];
  v69[0] = 0;
  if (v31)
  {
    if (*(char *)(v31 + 23) < 0) {
      operator delete(*(void **)v31);
    }
    MEMORY[0x1D25D9CE0](v31, 0x1012C40EC159624);
  }
  sub_1CBF2C538(v67, "key_state_BOOLs", 0xFuLL);
  llvm::json::Value::copyFrom(v68, &v81);
  sub_1CD82C208((uint64_t)&v55, (uint64_t)&v49, (uint64_t)v67, (unsigned __int16 *)v68);
  llvm::json::Value::destroy((llvm::json::Value *)v68);
  uint64_t v32 = v67[0];
  v67[0] = 0;
  if (v32)
  {
    if (*(char *)(v32 + 23) < 0) {
      operator delete(*(void **)v32);
    }
    MEMORY[0x1D25D9CE0](v32, 0x1012C40EC159624);
  }
  sub_1CBF2C538(v65, "bisect_history", 0xEuLL);
  llvm::json::Value::copyFrom(v66, &v77);
  sub_1CD82C208((uint64_t)&v55, (uint64_t)&v49, (uint64_t)v65, (unsigned __int16 *)v66);
  llvm::json::Value::destroy((llvm::json::Value *)v66);
  uint64_t v33 = v65[0];
  v65[0] = 0;
  if (v33)
  {
    if (*(char *)(v33 + 23) < 0) {
      operator delete(*(void **)v33);
    }
    MEMORY[0x1D25D9CE0](v33, 0x1012C40EC159624);
  }
  sub_1CBF2C538(v63, "last_fail_counter", 0x11uLL);
  llvm::json::Value::copyFrom(v64, &v75);
  sub_1CD82C208((uint64_t)&v55, (uint64_t)&v49, (uint64_t)v63, (unsigned __int16 *)v64);
  llvm::json::Value::destroy((llvm::json::Value *)v64);
  uint64_t v34 = v63[0];
  v63[0] = 0;
  if (v34)
  {
    if (*(char *)(v34 + 23) < 0) {
      operator delete(*(void **)v34);
    }
    MEMORY[0x1D25D9CE0](v34, 0x1012C40EC159624);
  }
  sub_1CBF2C538(v61, "last_pass_counter", 0x11uLL);
  llvm::json::Value::copyFrom(v62, &v73);
  sub_1CD82C208((uint64_t)&v55, (uint64_t)&v49, (uint64_t)v61, (unsigned __int16 *)v62);
  llvm::json::Value::destroy((llvm::json::Value *)v62);
  uint64_t v35 = v61[0];
  v61[0] = 0;
  if (v35)
  {
    if (*(char *)(v35 + 23) < 0) {
      operator delete(*(void **)v35);
    }
    MEMORY[0x1D25D9CE0](v35, 0x1012C40EC159624);
  }
  sub_1CBF2C538(v59, "learning_mode", 0xDuLL);
  llvm::json::Value::copyFrom(v60, &v71);
  sub_1CD82C208((uint64_t)&v55, (uint64_t)&v49, (uint64_t)v59, (unsigned __int16 *)v60);
  llvm::json::Value::destroy((llvm::json::Value *)v60);
  uint64_t v36 = v59[0];
  v59[0] = 0;
  if (v36)
  {
    if (*(char *)(v36 + 23) < 0) {
      operator delete(*(void **)v36);
    }
    MEMORY[0x1D25D9CE0](v36, 0x1012C40EC159624);
  }
  unsigned __int16 v55 = 7;
  uint64_t v56 = v49;
  uint64_t v57 = v50;
  uint64_t v49 = 0;
  uint64_t v50 = 0;
  int v58 = v51;
  int v51 = 0;
  sub_1CD82C0D8((uint64_t)v52, &v55);
  llvm::json::Value::destroy((llvm::json::Value *)&v55);
  llvm::raw_fd_ostream::close((llvm::raw_fd_ostream *)v52);
  llvm::json::Value::destroy((llvm::json::Value *)&v71);
  llvm::json::Value::destroy((llvm::json::Value *)&v73);
  llvm::json::Value::destroy((llvm::json::Value *)&v75);
  llvm::json::Value::destroy((llvm::json::Value *)&v77);
  llvm::json::Value::destroy((llvm::json::Value *)&v81);
  llvm::json::Value::destroy((llvm::json::Value *)v85);
  v85[0] = (void **)&v38;
  sub_1CBF2C7E0(v85);
  v85[0] = (void **)&v43;
  sub_1CBF2C7E0(v85);
  v85[0] = (void **)&v46;
  sub_1CBF2C7E0(v85);
  sub_1CD452448((unsigned int *)&v49);
  MEMORY[0x1D25D9CD0](v49, 8);
  llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)v52);
}

uint64_t llvm::Bisector<std::string>::getNumKeys(uint64_t a1)
{
  return (*(void *)(a1 + 32) - *(void *)(a1 + 24)) >> 5;
}

uint64_t llvm::Bisector<std::string>::getCurrentCounterKey(uint64_t a1)
{
  return *(void *)(a1 + 24) + 32 * *(int *)(*(void *)(a1 + 48) + 4 * *(unsigned int *)(a1 + 56) - 4) - 32;
}

uint64_t llvm::Bisector<std::string>::getLastFailCounter(uint64_t a1)
{
  return *(unsigned int *)(a1 + 112);
}

uint64_t llvm::Bisector<std::string>::getLastPassCounter(uint64_t a1)
{
  return *(unsigned int *)(a1 + 116);
}

BOOL llvm::Bisector<std::string>::isBisecting(uint64_t a1)
{
  return *(unsigned char *)(a1 + 120) == 0;
}

void llvm::Bisector<std::string>::loadFromFile(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  __int16 v60 = 261;
  uint64_t v57 = a2;
  v58[0] = a3;
  sub_1CD096690((unsigned __int8 *)&v57, (llvm::WritableMemoryBuffer *)0xFFFFFFFFFFFFFFFFLL, 0, 1, 1, 0, (uint64_t)&v61);
  if (v62)
  {
    unint64_t v46 = "Cannot open json file";
    goto LABEL_70;
  }
  sub_1CD0492DC(a1);
  *(_DWORD *)(a1 + 56) = 0;
  *(unsigned char *)(a1 + 120) = 1;
  llvm::json::parse(*(unsigned __int8 **)(v61 + 8), *(void *)(v61 + 16) - *(void *)(v61 + 8), v6, (uint64_t)&v57);
  if (v60)
  {
    unint64_t v46 = "Could not parse json";
    goto LABEL_70;
  }
  if ((unsigned __int16)v57 != 7)
  {
    unint64_t v46 = "JSON: Top level object should be an object/dict";
    goto LABEL_70;
  }
  uint64_t v7 = sub_1CD83B044((uint64_t)v58, (uint64_t)"key_state_strings", 17);
  if (v58[0] + 56 * v59 == v7 || (uint64_t v8 = v7, *(_WORD *)(v7 + 24) != 8))
  {
    unint64_t v46 = "JSON: key_state_strings key not found";
    goto LABEL_70;
  }
  uint64_t v9 = sub_1CD83B044((uint64_t)v58, (uint64_t)"key_state_BOOLs", 15);
  if (v58[0] + 56 * v59 == v9 || (uint64_t v10 = v9, *(_WORD *)(v9 + 24) != 8))
  {
    unint64_t v46 = "JSON: key_state_BOOLs key not found";
    goto LABEL_70;
  }
  uint64_t v11 = sub_1CD83B044((uint64_t)v58, (uint64_t)"bisect_history", 14);
  if (v58[0] + 56 * v59 == v11 || (uint64_t v12 = v11, *(_WORD *)(v11 + 24) != 8))
  {
    unint64_t v46 = "JSON: bisect_history key not found";
LABEL_70:
    llvm::report_fatal_error((llvm *)v46, (const llvm::Twine *)1);
  }
  int Integer = llvm::json::Object::getInteger((uint64_t)v58, (uint64_t)"last_fail_counter", 17);
  if (!v14)
  {
    unint64_t v46 = "JSON: last_fail_counter key not found";
    goto LABEL_70;
  }
  int v15 = Integer;
  int v16 = llvm::json::Object::getInteger((uint64_t)v58, (uint64_t)"last_pass_counter", 17);
  if (!v17)
  {
    unint64_t v46 = "JSON: last_pass_counter key not found";
    goto LABEL_70;
  }
  int v18 = v16;
  unsigned __int16 Boolean = llvm::json::Object::getBoolean((uint64_t)v58, (uint64_t)"learning_mode", 13);
  if (Boolean <= 0xFFu)
  {
    unint64_t v46 = "JSON: learning_mode key not found";
    goto LABEL_70;
  }
  char v47 = Boolean;
  int v48 = v18;
  int v49 = v15;
  uint64_t v20 = *(void *)(v8 + 32);
  uint64_t v21 = *(void *)(v8 + 40);
  if (v21 - v20 != *(void *)(v10 + 40) - *(void *)(v10 + 32))
  {
    unint64_t v46 = "key_state_strings and key_state_BOOLs have different sizes";
    goto LABEL_70;
  }
  if (v21 != v20)
  {
    unint64_t v22 = 0;
    unsigned int v23 = 1;
    while (1)
    {
      int v24 = *(unsigned __int16 *)(v20 + 32 * v22);
      if (v24 == 6) {
        break;
      }
      if (v24 == 5)
      {
        uint64_t v33 = v20 + 32 * v22;
        char v30 = *(unsigned __int8 **)(v33 + 8);
        unint64_t v32 = *(void *)(v33 + 16);
LABEL_25:
        sub_1CD452690((llvm::json::Value *)&v63, v30, v32);
        goto LABEL_26;
      }
      LOWORD(v63) = 0;
LABEL_26:
      llvm::json::Value::moveFrom((uint64_t)&v54, (unsigned __int16 *)&v63);
      llvm::json::Value::destroy((llvm::json::Value *)&v63);
      uint64_t v34 = *(void *)(v10 + 32);
      if (*(_WORD *)(v34 + 32 * v22) == 1)
      {
        BYTE8(v63) = *(unsigned char *)(v34 + 32 * v22 + 8);
        __int16 v35 = 1;
      }
      else
      {
        __int16 v35 = 0;
      }
      LOWORD(v63) = v35;
      llvm::json::Value::moveFrom((uint64_t)&v52, (unsigned __int16 *)&v63);
      llvm::json::Value::destroy((llvm::json::Value *)&v63);
      if (v54 == 6)
      {
        if (((char)v56 & 0x80000000) == 0)
        {
          size_t v4 = v56;
          unint64_t v3 = (unint64_t)v55;
          goto LABEL_38;
        }
LABEL_32:
        unint64_t v3 = v55[0];
        size_t v4 = v55[1];
        if (v55[0]) {
          goto LABEL_37;
        }
        goto LABEL_33;
      }
      if (v54 == 5) {
        goto LABEL_32;
      }
      v3 &= 0xFFFFFFFFFFFFFF00;
      if (v3)
      {
LABEL_37:
        if (v4 >= 0x7FFFFFFFFFFFFFF8) {
          abort();
        }
LABEL_38:
        if (v4 >= 0x17)
        {
          uint64_t v37 = (v4 & 0x7FFFFFFFFFFFFFF8) + 8;
          if ((v4 | 7) != 0x17) {
            uint64_t v37 = v4 | 7;
          }
          uint64_t v38 = v37 + 1;
          p_dst = (long long *)operator new(v37 + 1);
          *((void *)&__dst + 1) = v4;
          unint64_t v51 = v38 | 0x8000000000000000;
          *(void *)&long long __dst = p_dst;
        }
        else
        {
          HIBYTE(v51) = v4;
          p_dst = &__dst;
          if (!v4) {
            goto LABEL_45;
          }
        }
        memmove(p_dst, (const void *)v3, v4);
LABEL_45:
        *((unsigned char *)p_dst + v4) = 0;
        goto LABEL_46;
      }
LABEL_33:
      long long __dst = 0uLL;
      unint64_t v51 = 0;
LABEL_46:
      if (v52 == 1) {
        char v39 = v53;
      }
      else {
        char v39 = 0;
      }
      long long v63 = __dst;
      unint64_t v64 = v51;
      v65[0] = v39;
      sub_1CD04A44C(a1, &v63, v65);
      if (SHIBYTE(v64) < 0) {
        operator delete((void *)v63);
      }
      llvm::json::Value::destroy((llvm::json::Value *)&v52);
      llvm::json::Value::destroy((llvm::json::Value *)&v54);
      unint64_t v22 = v23;
      uint64_t v20 = *(void *)(v8 + 32);
      ++v23;
      if (v22 >= (*(void *)(v8 + 40) - v20) >> 5) {
        goto LABEL_52;
      }
    }
    uint64_t v25 = v20 + 32 * v22;
    long long v28 = *(unsigned __int8 **)(v25 + 8);
    uint64_t v26 = v25 + 8;
    uint64_t v27 = v28;
    char v29 = *(unsigned char *)(v26 + 23);
    if (v29 >= 0) {
      char v30 = (unsigned __int8 *)v26;
    }
    else {
      char v30 = v27;
    }
    unint64_t v31 = *(void *)(v26 + 8);
    if (v29 >= 0) {
      unint64_t v32 = v29 & 0x7F;
    }
    else {
      unint64_t v32 = v31;
    }
    goto LABEL_25;
  }
LABEL_52:
  uint64_t v40 = *(void *)(v12 + 32);
  if (*(void *)(v12 + 40) != v40)
  {
    unint64_t v41 = 0;
    unsigned int v42 = 1;
    do
    {
      int v43 = sub_1CD82C174((unsigned __int16 *)(v40 + 32 * v41));
      uint64_t v44 = *(unsigned int *)(a1 + 56);
      if (v44 >= *(_DWORD *)(a1 + 60)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)(a1 + 48) + 4 * v44) = v43;
      ++*(_DWORD *)(a1 + 56);
      unint64_t v41 = v42;
      uint64_t v40 = *(void *)(v12 + 32);
      ++v42;
    }
    while (v41 < (*(void *)(v12 + 40) - v40) >> 5);
  }
  *(_DWORD *)(a1 + 112) = v49;
  *(_DWORD *)(a1 + 116) = v48;
  *(unsigned char *)(a1 + 120) = v47;
  if (v60)
  {
    uint64_t v45 = v57;
    uint64_t v57 = 0;
    if (v45) {
      (*(void (**)(uint64_t))(*(void *)v45 + 8))(v45);
    }
  }
  else
  {
    llvm::json::Value::destroy((llvm::json::Value *)&v57);
  }
  if ((v62 & 1) == 0)
  {
    if (v61) {
      (*(void (**)(uint64_t))(*(void *)v61 + 8))(v61);
    }
  }
}

void sub_1CD04A44C(uint64_t a1, long long *a2, char *a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1CB8BDF7C((uint64_t)__p, *(const void **)a2, *((void *)a2 + 1));
  }
  else
  {
    *(_OWORD *)__p = *a2;
    __p[2] = *((void **)a2 + 2);
  }
  LODWORD(v32) = 0;
  uint64_t v6 = (uint64_t **)sub_1CB835798(a1, &v34, (const void **)__p);
  uint64_t v7 = *v6;
  uint64_t v8 = (void **)*v6;
  if (!*v6)
  {
    uint64_t v9 = v6;
    uint64_t v8 = (void **)operator new(0x40uLL);
    *((_OWORD *)v8 + 2) = *(_OWORD *)__p;
    v8[6] = __p[2];
    memset(__p, 0, sizeof(__p));
    *((_DWORD *)v8 + 14) = v32;
    uint64_t v10 = v34;
    long long *v8 = 0;
    v8[1] = 0;
    v8[2] = v10;
    long long *v9 = (uint64_t *)v8;
    uint64_t v11 = **(void **)a1;
    uint64_t v12 = (uint64_t *)v8;
    if (v11)
    {
      *(void *)a1 = v11;
      uint64_t v12 = *v9;
    }
    sub_1CB8358B8(*(uint64_t **)(a1 + 8), v12);
    ++*(void *)(a1 + 16);
  }
  if (SHIBYTE(__p[2]) < 0)
  {
    operator delete(__p[0]);
    if (v7) {
      return;
    }
  }
  else if (v7)
  {
    return;
  }
  unint64_t v13 = *(void *)(a1 + 40);
  uint64_t v15 = *(void *)(a1 + 24);
  unint64_t v14 = *(void *)(a1 + 32);
  uint64_t v16 = v14 - v15;
  *((_DWORD *)v8 + 14) = (v14 - v15) >> 5;
  if (v14 >= v13)
  {
    uint64_t v19 = v16 >> 5;
    unint64_t v20 = (v16 >> 5) + 1;
    if (v20 >> 59) {
      abort();
    }
    uint64_t v21 = v13 - v15;
    if (v21 >> 4 > v20) {
      unint64_t v20 = v21 >> 4;
    }
    if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v22 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v22 = v20;
    }
    uint64_t v33 = a1 + 40;
    if (v22 >> 59) {
      sub_1CB833614();
    }
    unsigned int v23 = (char *)operator new(32 * v22);
    int v24 = &v23[32 * v19];
    *(_OWORD *)int v24 = *a2;
    *((void *)v24 + 2) = *((void *)a2 + 2);
    *(void *)a2 = 0;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    v24[24] = *a3;
    uint64_t v26 = *(void *)(a1 + 24);
    unint64_t v25 = *(void *)(a1 + 32);
    if (v25 == v26)
    {
      int64x2_t v27 = vdupq_n_s64(v25);
      long long v28 = &v23[32 * v19];
    }
    else
    {
      long long v28 = &v23[32 * v19];
      do
      {
        long long v29 = *(_OWORD *)(v25 - 32);
        *((void *)v28 - 2) = *(void *)(v25 - 16);
        *((_OWORD *)v28 - 2) = v29;
        *(void *)(v25 - 24) = 0;
        *(void *)(v25 - 16) = 0;
        *(void *)(v25 - 32) = 0;
        *(v28 - 8) = *(unsigned char *)(v25 - 8);
        v28 -= 32;
        v25 -= 32;
      }
      while (v25 != v26);
      int64x2_t v27 = *(int64x2_t *)(a1 + 24);
    }
    int v18 = v24 + 32;
    *(void *)(a1 + 24) = v28;
    *(void *)(a1 + 32) = v24 + 32;
    *(int64x2_t *)&__p[1] = v27;
    uint64_t v30 = *(void *)(a1 + 40);
    *(void *)(a1 + 40) = &v23[32 * v22];
    uint64_t v32 = v30;
    __p[0] = (void *)v27.i64[0];
    sub_1CD573B00((uint64_t)__p);
  }
  else
  {
    long long v17 = *a2;
    *(void *)(v14 + 16) = *((void *)a2 + 2);
    *(_OWORD *)unint64_t v14 = v17;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    *(unsigned char *)(v14 + 24) = *a3;
    int v18 = (char *)(v14 + 32);
  }
  *(void *)(a1 + 32) = v18;
}

unsigned __int16 *sub_1CD04A694(unsigned __int16 **a1, unsigned __int16 *a2)
{
  uint64_t v2 = ((char *)a1[1] - (char *)*a1) >> 5;
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 59) {
    abort();
  }
  uint64_t v6 = (char *)a1[2] - (char *)*a1;
  if (v6 >> 4 > v3) {
    unint64_t v3 = v6 >> 4;
  }
  if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v7 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v7 = v3;
  }
  if (v7)
  {
    if (v7 >> 59) {
      sub_1CB833614();
    }
    uint64_t v8 = (char *)operator new(32 * v7);
  }
  else
  {
    uint64_t v8 = 0;
  }
  uint64_t v9 = &v8[32 * v2];
  uint64_t v10 = (unsigned __int16 *)&v8[32 * v7];
  llvm::json::Value::copyFrom(v9, a2);
  uint64_t v11 = (unsigned __int16 *)(v9 + 32);
  unint64_t v13 = *a1;
  uint64_t v12 = a1[1];
  if (v12 == *a1)
  {
    *a1 = (unsigned __int16 *)v9;
    a1[1] = v11;
    a1[2] = v10;
  }
  else
  {
    do
    {
      v9 -= 32;
      v12 -= 16;
      llvm::json::Value::moveFrom((uint64_t)v9, v12);
    }
    while (v12 != v13);
    uint64_t v12 = *a1;
    unint64_t v14 = (llvm::json::Value *)a1[1];
    *a1 = (unsigned __int16 *)v9;
    a1[1] = v11;
    a1[2] = v10;
    while (v14 != (llvm::json::Value *)v12)
    {
      unint64_t v14 = (llvm::json::Value *)((char *)v14 - 32);
      llvm::json::Value::destroy(v14);
    }
  }
  if (v12) {
    operator delete(v12);
  }
  return v11;
}

unint64_t llvm::BlockFrequency::operator*(unint64_t *a1, unsigned int a2)
{
  unint64_t result = *a1;
  if (a2 != 0x80000000 && result != 0)
  {
    unint64_t v4 = result * (unint64_t)a2;
    unint64_t v5 = HIDWORD(v4) + HIDWORD(result) * (unint64_t)a2;
    if (((((unint64_t)(v5 < HIDWORD(result) * a2) << 32) + HIDWORD(result) * (unint64_t)a2) & 0x8000000000000000) != 0) {
      return -1;
    }
    else {
      return ((v4 & 0x80000000 | ((v5 & 0x7FFFFFFF) << 32)) >> 31) | ((unint64_t)(((((unint64_t)(v5 < HIDWORD(result) * a2) << 32) + HIDWORD(result) * (unint64_t)a2) & 0xFFFFFFFF00000000 | v5) >> 31) << 32);
    }
  }
  return result;
}

uint64_t *llvm::BlockFrequency::operator+=(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = a2 + *result;
  if (__CFADD__(a2, *result)) {
    uint64_t v2 = -1;
  }
  unsigned int *result = v2;
  return result;
}

uint64_t llvm::BlockFrequency::operator+(void *a1, uint64_t a2)
{
  if (__CFADD__(a2, *a1)) {
    return -1;
  }
  else {
    return a2 + *a1;
  }
}

void *llvm::BlockFrequency::operator>>=(void *result, char a2)
{
  unsigned int *result = (*result >> a2) | (*result >> a2 == 0);
  return result;
}

_DWORD *llvm::BranchProbability::BranchProbability(_DWORD *this, unint64_t a2, unsigned int a3)
{
  if (a3 != 0x80000000) {
    a2 = ((a3 >> 1) | ((unint64_t)a2 << 31)) / a3;
  }
  *this = a2;
  return this;
}

{
  if (a3 != 0x80000000) {
    a2 = ((a3 >> 1) | ((unint64_t)a2 << 31)) / a3;
  }
  *this = a2;
  return this;
}

uint64_t llvm::BranchProbability::getBranchProbability(unint64_t this, unint64_t a2)
{
  unint64_t v2 = HIDWORD(a2);
  if (HIDWORD(a2))
  {
    LOBYTE(v2) = 0;
    unint64_t v4 = a2;
    do
    {
      a2 = v4 >> 1;
      LOBYTE(v2) = v2 + 1;
      unint64_t v5 = v4 >> 33;
      v4 >>= 1;
    }
    while (v5);
  }
  uint64_t result = this >> v2;
  if (a2 != 0x80000000) {
    return (((unint64_t)result << 31) | (a2 >> 1)) / a2;
  }
  return result;
}

unint64_t llvm::BranchProbability::scale(llvm::BranchProbability *this, uint64_t a2)
{
  if (a2)
  {
    unsigned int v2 = *(_DWORD *)this;
    if (*(_DWORD *)this != 0x80000000)
    {
      unint64_t v3 = a2 * (unint64_t)v2;
      unint64_t v4 = HIDWORD(v3) + HIDWORD(a2) * (unint64_t)v2;
      unint64_t v5 = (((unint64_t)(v4 < HIDWORD(a2) * v2) << 32) + HIDWORD(a2) * (unint64_t)v2) & 0xFFFFFFFF00000000 | v4;
      if ((v5 & 0x8000000000000000) != 0) {
        return -1;
      }
      else {
        return ((v3 & 0x80000000 | ((v4 & 0x7FFFFFFF) << 32)) >> 31) | ((unint64_t)(v5 >> 31) << 32);
      }
    }
  }
  return a2;
}

llvm *llvm::parseCachePruningPolicy@<X0>(llvm *result@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  uint64_t v57 = "";
  unint64_t v58 = 0;
  unint64_t v4 = 1000000;
  uint64_t v59 = (uint64_t)result;
  unint64_t v60 = a2;
  if (a2)
  {
    unint64_t v5 = a2;
    uint64_t v6 = (uint64_t)result;
    LODWORD(v7) = 75;
    uint64_t v50 = 0;
    uint64_t v51 = 1200;
    uint64_t v52 = 604800;
    while (1)
    {
      LOBYTE(v61) = 58;
      unint64_t v8 = llvm::StringRef::find(&v59, (char *)&v61, 1uLL, 0);
      if (v5 >= v8) {
        unint64_t v9 = v8;
      }
      else {
        unint64_t v9 = v5;
      }
      if (v5 >= v8 + 1) {
        unint64_t v10 = v8 + 1;
      }
      else {
        unint64_t v10 = v5;
      }
      uint64_t v11 = v6 + v10;
      unint64_t v12 = v5 - v10;
      unint64_t v13 = (const char *)v6;
      if (v8 == -1) {
        unint64_t v14 = v5;
      }
      else {
        unint64_t v14 = v9;
      }
      if (v8 == -1) {
        uint64_t v6 = 0;
      }
      else {
        uint64_t v6 = v11;
      }
      uint64_t v57 = v13;
      unint64_t v58 = v14;
      if (v8 == -1) {
        unint64_t v5 = 0;
      }
      else {
        unint64_t v5 = v12;
      }
      uint64_t v59 = v6;
      unint64_t v60 = v5;
      LOBYTE(v61) = 61;
      uint64_t result = (llvm *)llvm::StringRef::find((uint64_t *)&v57, (char *)&v61, 1uLL, 0);
      if (v14 >= (unint64_t)result) {
        unint64_t v15 = (unint64_t)result;
      }
      else {
        unint64_t v15 = v14;
      }
      if (v14 >= (unint64_t)result + 1) {
        unint64_t v16 = (unint64_t)result + 1;
      }
      else {
        unint64_t v16 = v14;
      }
      long long v17 = (const char **)&v13[v16];
      unint64_t v18 = v14 - v16;
      if (result == (llvm *)-1)
      {
        unint64_t v15 = v14;
        uint64_t v19 = 0;
      }
      else
      {
        uint64_t v19 = v17;
      }
      if (result == (llvm *)-1) {
        unint64_t v20 = 0;
      }
      else {
        unint64_t v20 = v18;
      }
      switch(v15)
      {
        case 0xAuLL:
          if (*(void *)v13 != 0x69735F6568636163 || *((_WORD *)v13 + 4) != 25978) {
            goto LABEL_121;
          }
          if (*((unsigned char *)v19 + v20 - 1) != 37)
          {
            __int16 v56 = 1283;
            char v53 = "'";
            __int16 v54 = v19;
            unint64_t v55 = v20;
            int v48 = "' must be a percentage";
            goto LABEL_122;
          }
          if (v20 >= v20 - 1) {
            --v20;
          }
          uint64_t v61 = v19;
          unint64_t v62 = v20;
          uint64_t result = (llvm *)sub_1CD0AF898((uint64_t)&v61);
          unint64_t v22 = v62;
          if (!v62) {
            goto LABEL_120;
          }
          unint64_t v23 = 0;
          int v24 = v61;
          do
          {
            int v25 = *(unsigned __int8 *)v24;
            if ((v25 - 48) >= 0xA)
            {
              if ((v25 - 97) >= 0x1A)
              {
                if ((v25 - 65) > 0x19) {
                  goto LABEL_120;
                }
                int v26 = -55;
              }
              else
              {
                int v26 = -87;
              }
            }
            else
            {
              int v26 = -48;
            }
            unsigned int v27 = v26 + v25;
            if (v27 >= result) {
              goto LABEL_120;
            }
            unint64_t v7 = v23 * result + v27;
            if (v7 / result < v23) {
              goto LABEL_120;
            }
            int v24 = (const char **)((char *)v24 + 1);
            unint64_t v23 = v23 * result + v27;
            --v22;
          }
          while (v22);
          if (v7 > 0x64)
          {
            __int16 v56 = 1283;
            char v53 = "'";
            __int16 v54 = v19;
            unint64_t v55 = v20;
            int v48 = "' must be between 0 and 100";
            goto LABEL_122;
          }
LABEL_89:
          if (!v5) {
            goto LABEL_119;
          }
          continue;
        case 0xBuLL:
          if (*(void *)v13 != 0x66615F656E757270 || *(void *)(v13 + 3) != 0x72657466615F656ELL) {
            goto LABEL_121;
          }
          uint64_t result = sub_1CD04AFF8((llvm *)&v61, v19, v20);
          if (v62) {
            goto LABEL_123;
          }
          uint64_t v52 = (uint64_t)v61;
          if (!v5) {
            goto LABEL_119;
          }
          continue;
        case 0xEuLL:
          if (*(void *)v13 != 0x6E695F656E757270 || *(void *)(v13 + 6) != 0x6C61767265746E69) {
            goto LABEL_121;
          }
          uint64_t result = sub_1CD04AFF8((llvm *)&v61, v19, v20);
          if (v62)
          {
LABEL_123:
            int v49 = v61;
            *(unsigned char *)(a3 + 48) |= 1u;
            *(void *)a3 = v49;
            return result;
          }
          uint64_t v51 = (uint64_t)v61;
          if (!v5) {
            goto LABEL_119;
          }
          break;
        case 0x10uLL:
          if (*(void *)v13 != 0x69735F6568636163 || *((void *)v13 + 1) != 0x73657479625F657ALL)
          {
            if (*(void *)v13 == 0x69735F6568636163 && *((void *)v13 + 1) == 0x73656C69665F657ALL)
            {
              uint64_t v61 = v19;
              unint64_t v62 = v20;
              uint64_t result = (llvm *)sub_1CD0AF898((uint64_t)&v61);
              unint64_t v31 = v62;
              if (v62)
              {
                unint64_t v32 = 0;
                uint64_t v33 = v61;
                while (1)
                {
                  int v34 = *(unsigned __int8 *)v33;
                  if ((v34 - 48) >= 0xA)
                  {
                    if ((v34 - 97) >= 0x1A)
                    {
                      if ((v34 - 65) > 0x19) {
                        break;
                      }
                      int v35 = -55;
                    }
                    else
                    {
                      int v35 = -87;
                    }
                  }
                  else
                  {
                    int v35 = -48;
                  }
                  unsigned int v36 = v35 + v34;
                  if (v36 >= result) {
                    break;
                  }
                  unint64_t v4 = v32 * result + v36;
                  if (v4 / result < v32) {
                    break;
                  }
                  uint64_t v33 = (const char **)((char *)v33 + 1);
                  unint64_t v32 = v32 * result + v36;
                  if (!--v31) {
                    goto LABEL_89;
                  }
                }
              }
LABEL_120:
              __int16 v56 = 1283;
              char v53 = "'";
              __int16 v54 = v19;
              unint64_t v55 = v20;
              int v48 = "' not an integer";
            }
            else
            {
LABEL_121:
              __int16 v56 = 1283;
              char v53 = "Unknown key: '";
              __int16 v54 = (void *)v13;
              unint64_t v55 = v15;
              int v48 = "'";
            }
LABEL_122:
            uint64_t v61 = &v53;
            long long v63 = v48;
            __int16 v64 = 770;
            llvm::inconvertibleErrorCode(result);
            operator new();
          }
          unint64_t v38 = v20 - 1;
          __darwin_ct_rune_t v39 = __tolower(*((char *)v19 + v20 - 1));
          switch(v39)
          {
            case 'g':
              if (v20 >= v38) {
                --v20;
              }
              uint64_t v40 = 0x40000000;
              break;
            case 'm':
              if (v20 >= v38) {
                --v20;
              }
              uint64_t v40 = 0x100000;
              break;
            case 'k':
              if (v20 >= v38) {
                --v20;
              }
              uint64_t v40 = 1024;
              break;
            default:
              uint64_t v40 = 1;
              break;
          }
          uint64_t v61 = v19;
          unint64_t v62 = v20;
          uint64_t result = (llvm *)sub_1CD0AF898((uint64_t)&v61);
          unint64_t v41 = v62;
          if (!v62) {
            goto LABEL_120;
          }
          unint64_t v42 = 0;
          int v43 = v61;
          do
          {
            int v44 = *(unsigned __int8 *)v43;
            if ((v44 - 48) >= 0xA)
            {
              if ((v44 - 97) >= 0x1A)
              {
                if ((v44 - 65) > 0x19) {
                  goto LABEL_120;
                }
                int v45 = -55;
              }
              else
              {
                int v45 = -87;
              }
            }
            else
            {
              int v45 = -48;
            }
            unsigned int v46 = v45 + v44;
            if (v46 >= result) {
              goto LABEL_120;
            }
            unint64_t v47 = v42 * result + v46;
            if (v47 / result < v42) {
              goto LABEL_120;
            }
            int v43 = (const char **)((char *)v43 + 1);
            unint64_t v42 = v47;
            --v41;
          }
          while (v41);
          uint64_t v50 = v47 * v40;
          if (!v5) {
            goto LABEL_119;
          }
          continue;
        default:
          goto LABEL_121;
      }
    }
  }
  LODWORD(v7) = 75;
  uint64_t v52 = 604800;
  uint64_t v50 = 0;
  uint64_t v51 = 1200;
LABEL_119:
  *(unsigned char *)(a3 + 48) &= ~1u;
  *(void *)a3 = v51;
  *(unsigned char *)(a3 + 8) = 1;
  *(void *)(a3 + 16) = v52;
  *(_DWORD *)(a3 + 24) = v7;
  *(void *)(a3 + 32) = v50;
  *(void *)(a3 + 40) = v4;
  return result;
}

llvm *sub_1CD04AFF8(llvm *a1, const char **a2, unint64_t a3)
{
  if (!a3)
  {
    llvm::inconvertibleErrorCode(a1);
    operator new();
  }
  unint64_t v6 = a3 - 1;
  if (a3 >= a3 - 1) {
    unint64_t v7 = a3 - 1;
  }
  else {
    unint64_t v7 = a3;
  }
  unint64_t v23 = a2;
  unint64_t v24 = v7;
  uint64_t result = (llvm *)sub_1CD0AF898((uint64_t)&v23);
  unint64_t v9 = v24;
  if (!v24)
  {
LABEL_26:
    __int16 v22 = 1283;
    uint64_t v19 = "'";
    unint64_t v20 = a2;
    unint64_t v21 = v7;
    unint64_t v18 = "' not an integer";
    goto LABEL_27;
  }
  unint64_t v10 = 0;
  uint64_t v11 = v23;
  do
  {
    int v12 = *(unsigned __int8 *)v11;
    if ((v12 - 48) >= 0xA)
    {
      if ((v12 - 97) >= 0x1A)
      {
        if ((v12 - 65) > 0x19) {
          goto LABEL_26;
        }
        int v13 = -55;
      }
      else
      {
        int v13 = -87;
      }
    }
    else
    {
      int v13 = -48;
    }
    unsigned int v14 = v13 + v12;
    if (v14 >= result) {
      goto LABEL_26;
    }
    unint64_t v15 = v10 * result + v14;
    if (v15 / result < v10) {
      goto LABEL_26;
    }
    uint64_t v11 = (const char **)((char *)v11 + 1);
    unint64_t v10 = v15;
    --v9;
  }
  while (v9);
  int v16 = *((char *)a2 + v6);
  switch(v16)
  {
    case 'h':
      *((unsigned char *)a1 + 8) &= ~1u;
      uint64_t v17 = 3600 * v15;
      break;
    case 'm':
      *((unsigned char *)a1 + 8) &= ~1u;
      uint64_t v17 = 60 * v15;
      break;
    case 's':
      *((unsigned char *)a1 + 8) &= ~1u;
      *(void *)a1 = v15;
      return result;
    default:
      __int16 v22 = 1283;
      uint64_t v19 = "'";
      unint64_t v20 = a2;
      unint64_t v21 = a3;
      unint64_t v18 = "' must end with one of 's', 'm' or 'h'";
LABEL_27:
      unint64_t v23 = &v19;
      int v25 = v18;
      __int16 v26 = 770;
      llvm::inconvertibleErrorCode(result);
      operator new();
  }
  *(void *)a1 = v17;
  return result;
}

uint64_t llvm::pruneCache(void *a1, size_t a2, uint64_t a3)
{
  uint64_t v109 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 0;
  }
  unint64_t v5 = a1;
  char v85 = 0;
  v108[4] = 261;
  unsigned int v106 = a1;
  *(void *)&long long v107 = a2;
  uint64_t v6 = 0;
  if (llvm::sys::fs::is_directory((llvm::sys::fs *)&v106, (const llvm::Twine *)&v85, (BOOL *)a3) || !v85) {
    return v6;
  }
  unsigned int v7 = *(_DWORD *)(a3 + 24);
  if (v7 >= 0x64) {
    unsigned int v7 = 100;
  }
  *(_DWORD *)(a3 + 24) = v7;
  if (!*(void *)(a3 + 16) && !v7 && !*(void *)(a3 + 32) && !*(void *)(a3 + 40)) {
    return 0;
  }
  unsigned int v106 = v108;
  long long v107 = xmmword_1CFAC3020;
  if (a2 >= 0x81) {
    llvm::SmallVectorBase<unsigned long long>::grow_pod();
  }
  memcpy(v108, v5, a2);
  *(void *)&long long v107 = v107 + a2;
  uint64_t v99 = "llvmcache.timestamp";
  __int16 v102 = 259;
  *(_WORD *)&v81[16] = 257;
  LOWORD(v96) = 257;
  LOWORD(v105) = 257;
  llvm::sys::path::append(&v106, 0, (const char **)&v99, (void **)__t, (uint64_t)&__dst, (uint64_t)&v103);
  *(_OWORD *)__t = 0u;
  memset(v81, 0, sizeof(v81));
  uint64_t v82 = 0xFFFFLL;
  __int16 v83 = 0;
  uint64_t v84 = 0;
  v8.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
  __int16 v102 = 261;
  uint64_t v99 = v106;
  *(void *)&long long v100 = v107;
  int v10 = llvm::sys::fs::status((llvm::sys::fs *)&v99, (const llvm::Twine *)__t, (llvm::sys::fs::file_status *)1);
  if (v10)
  {
    uint64_t v11 = v9;
    int v12 = std::generic_category();
    uint64_t v6 = 0;
    if (v10 == 2 && v12 == v11) {
      goto LABEL_23;
    }
  }
  else
  {
    if (*(unsigned char *)(a3 + 8))
    {
      if (!*(void *)a3
        || (uint64_t v13 = *(unsigned int *)&v81[4],
            1000000000 * *(void *)a3 < 1000
                                         * (v8.__d_.__rep_ - std::chrono::system_clock::from_time_t(__t[1]).__d_.__rep_)
                                         - v13))
      {
LABEL_23:
        int v16 = v106;
        size_t v15 = v107;
        std::system_category();
        if (!v16)
        {
          uint64_t v17 = 0;
          unint64_t v18 = 0;
          char v19 = 0;
          long long __dst = 0;
          uint64_t v93 = 0;
          unint64_t v94 = 0;
LABEL_34:
          BOOL v23 = v19 < 0;
          if (v19 >= 0) {
            p_dst = &__dst;
          }
          else {
            p_dst = v18;
          }
          uint64_t v25 = v19 & 0x7F;
          if (v23) {
            uint64_t v26 = v17;
          }
          else {
            uint64_t v26 = v25;
          }
          llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)&v99, p_dst, v26, (uint64_t)&v103, 0);
          if (SHIBYTE(v94) < 0) {
            operator delete(__dst);
          }
          llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)&v99);
          uint64_t v78 = 0;
          unint64_t v79 = 0;
          unsigned __int16 v77 = &v78;
          LODWORD(v75) = 0;
          uint64_t v76 = std::system_category();
          uint64_t v99 = &v101;
          LOWORD(v96) = 261;
          long long __dst = v5;
          uint64_t v93 = a2;
          long long v100 = xmmword_1CFAC3020;
          llvm::Twine::toVector((uint64_t)&__dst, (uint64_t)&v99);
          llvm::sys::path::native((char **)&v99, 0);
          LOWORD(v96) = 261;
          long long __dst = v99;
          uint64_t v93 = v100;
          sub_1CD501E54((uint64_t)&v73, &__dst, &v75, 1);
          uint64_t v70 = 0;
          unsigned __int16 v71 = 0;
          char v72 = 1;
          unint64_t v27 = 0;
          if ((sub_1CC22AEBC((uint64_t *)&v73, &v70) & 1) == 0 && !v75)
          {
            unint64_t v27 = 0;
            int v67 = v5;
            do
            {
              long long v28 = (DIR **)v73[1];
              char v29 = *((unsigned char *)v73 + 31);
              int v30 = v29;
              if (v29 >= 0) {
                long long v28 = v73 + 1;
              }
              unint64_t v31 = v73[2];
              unint64_t v32 = (DIR *)(v29 & 0x7F);
              if (v30 >= 0) {
                unint64_t v31 = v32;
              }
              unint64_t v94 = 0;
              unint64_t v95 = 0;
              long long __dst = v28;
              uint64_t v93 = (uint64_t)v31;
              char v96 = v31;
              int v97 = 0;
              llvm::sys::path::reverse_iterator::operator++((uint64_t)&__dst);
              if (v95 >= 0xA)
              {
                BOOL v33 = *(void *)v94 == 0x686361636D766C6CLL && *(_WORD *)(v94 + 8) == 11621;
                if (v33)
                {
LABEL_61:
                  llvm::sys::fs::directory_entry::status((llvm::sys::fs::directory_entry *)(v73 + 1), (uint64_t)&__dst);
                  if ((v98 & 1) == 0)
                  {
                    unint64_t v69 = v27;
                    uint64_t v35 = v94;
                    v36.__d_.__rep_ = std::chrono::system_clock::from_time_t((time_t)__dst).__d_.__rep_;
                    uint64_t v37 = *(void *)(a3 + 16);
                    if (v37 && 1000000000 * v37 < 1000 * v8.__d_.__rep_ - (v35 + 1000 * v36.__d_.__rep_))
                    {
                      LOWORD(v105) = 260;
                      *(void *)&long long v103 = v73 + 1;
                      llvm::sys::fs::remove((llvm::sys::fs *)&v103, (const llvm::Twine *)1);
                      unint64_t v27 = v69;
                    }
                    else
                    {
                      *(void *)&long long v103 = v35 + 1000 * v36.__d_.__rep_;
                      *((void *)&v103 + 1) = v96;
                      unsigned int v68 = v96;
                      if (*((char *)v73 + 31) < 0)
                      {
                        sub_1CB8BDF7C((uint64_t)&__p, v73[1], (unint64_t)v73[2]);
                      }
                      else
                      {
                        long long v38 = *(_OWORD *)(v73 + 1);
                        uint64_t v105 = v73[3];
                        long long __p = v38;
                      }
                      __darwin_ct_rune_t v39 = v78;
                      uint64_t v40 = &v78;
                      unint64_t v41 = &v78;
                      if (!v78) {
                        goto LABEL_76;
                      }
                      unint64_t v41 = &v78;
                      while (1)
                      {
                        while (1)
                        {
                          uint64_t v40 = (uint64_t **)v39;
                          unint64_t v42 = v39 + 4;
                          int v43 = v39 + 5;
                          uint64_t v89 = (uint64_t *)&v103;
                          char v90 = (char *)(v39 + 5);
                          p_p = (uint64_t *)&__p;
                          int v44 = v39 + 6;
                          uint64_t v86 = (long long *)(v39 + 4);
                          unint64_t v87 = (uint64_t *)&v103 + 1;
                          uint64_t v88 = (long long *)(v39 + 6);
                          if (!sub_1CD04BB90(&v89, (uint64_t **)&v86)) {
                            break;
                          }
                          __darwin_ct_rune_t v39 = *v40;
                          unint64_t v41 = v40;
                          if (!*v40) {
                            goto LABEL_76;
                          }
                        }
                        uint64_t v89 = v42;
                        char v90 = (char *)&v103 + 8;
                        p_p = v44;
                        uint64_t v86 = &v103;
                        unint64_t v87 = v43;
                        uint64_t v88 = &__p;
                        if (!sub_1CD04BB90(&v89, (uint64_t **)&v86)) {
                          break;
                        }
                        unint64_t v41 = v40 + 1;
                        __darwin_ct_rune_t v39 = v40[1];
                        if (!v39) {
                          goto LABEL_76;
                        }
                      }
                      if (!*v41)
                      {
LABEL_76:
                        int v45 = operator new(0x48uLL);
                        long long v46 = __p;
                        v45[2] = v103;
                        v45[3] = v46;
                        *((void *)v45 + 8) = v105;
                        long long __p = 0uLL;
                        uint64_t v105 = 0;
                        *(void *)int v45 = 0;
                        *((void *)v45 + 1) = 0;
                        *((void *)v45 + 2) = v40;
                        *unint64_t v41 = (uint64_t *)v45;
                        if (*v77)
                        {
                          unsigned __int16 v77 = (uint64_t **)*v77;
                          unint64_t v47 = *v41;
                        }
                        else
                        {
                          unint64_t v47 = (uint64_t *)v45;
                        }
                        sub_1CB8358B8(v78, v47);
                        ++v79;
                      }
                      if (SHIBYTE(v105) < 0) {
                        operator delete((void *)__p);
                      }
                      unint64_t v27 = (unint64_t)v68 + v69;
                      unint64_t v5 = v67;
                    }
                  }
                  goto LABEL_83;
                }
              }
              else if (v95 < 5)
              {
                goto LABEL_83;
              }
              if (*(_DWORD *)v94 == 1852401748 && *(unsigned char *)(v94 + 4) == 45) {
                goto LABEL_61;
              }
LABEL_83:
              unint64_t v75 = llvm::sys::fs::detail::directory_iterator_increment(v73);
              uint64_t v76 = v48;
            }
            while ((sub_1CC22AEBC((uint64_t *)&v73, &v70) & 1) == 0 && !v75);
          }
          int v49 = v71;
          if (v71 && !atomic_fetch_add(&v71->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
            std::__shared_weak_count::__release_weak(v49);
          }
          uint64_t v50 = v74;
          if (v74 && !atomic_fetch_add(&v74->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
            std::__shared_weak_count::__release_weak(v50);
          }
          uint64_t v51 = v77;
          unint64_t v52 = *(void *)(a3 + 40);
          if (v52 && (unint64_t v53 = v79, v79 > v52))
          {
            do
            {
              LOWORD(v96) = 260;
              long long __dst = v51 + 6;
              llvm::sys::fs::remove((llvm::sys::fs *)&__dst, (const llvm::Twine *)1);
              __int16 v54 = v51[1];
              unint64_t v55 = v51;
              if (v54)
              {
                do
                {
                  __int16 v56 = (uint64_t **)v54;
                  __int16 v54 = (uint64_t *)*v54;
                }
                while (v54);
              }
              else
              {
                do
                {
                  __int16 v56 = (uint64_t **)v55[2];
                  BOOL v33 = *v56 == (uint64_t *)v55;
                  unint64_t v55 = v56;
                }
                while (!v33);
              }
              v27 -= (unint64_t)v51[5];
              --v53;
              uint64_t v51 = v56;
            }
            while (v53 > *(void *)(a3 + 40));
          }
          else
          {
            __int16 v56 = v77;
          }
          if (*(_DWORD *)(a3 + 24) || *(void *)(a3 + 32))
          {
            LOWORD(v96) = 261;
            long long __dst = v5;
            uint64_t v93 = a2;
            llvm::sys::fs::disk_space((llvm::sys::fs *)&__dst, (uint64_t)&v103);
            if (BYTE8(__p)) {
              llvm::report_fatal_error((llvm *)"Can't get available size", (const llvm::Twine *)1);
            }
            uint64_t v57 = *((void *)&v103 + 1);
            unsigned int v58 = *(_DWORD *)(a3 + 24);
            if (!v58)
            {
              unsigned int v58 = 100;
              *(_DWORD *)(a3 + 24) = 100;
            }
            unint64_t v59 = v57 + v27;
            unint64_t v60 = *(void *)(a3 + 32);
            if (!v60)
            {
              *(void *)(a3 + 32) = v59;
              unint64_t v60 = v59;
            }
            unint64_t v61 = v59 * v58;
            if (v60 >= v61 / 0x64) {
              unint64_t v62 = v61 / 0x64;
            }
            else {
              unint64_t v62 = v60;
            }
            if (v27 > v62 && v56 != &v78)
            {
              do
              {
                LOWORD(v96) = 260;
                long long __dst = v56 + 6;
                llvm::sys::fs::remove((llvm::sys::fs *)&__dst, (const llvm::Twine *)1);
                __int16 v64 = v56[1];
                uint64_t v65 = v56;
                if (v64)
                {
                  do
                  {
                    uint64_t v66 = (uint64_t **)v64;
                    __int16 v64 = (uint64_t *)*v64;
                  }
                  while (v64);
                }
                else
                {
                  do
                  {
                    uint64_t v66 = (uint64_t **)v65[2];
                    BOOL v33 = *v66 == (uint64_t *)v65;
                    uint64_t v65 = v66;
                  }
                  while (!v33);
                }
                v27 -= (unint64_t)v56[5];
                if (v27 <= v62) {
                  break;
                }
                __int16 v56 = v66;
              }
              while (v66 != &v78);
            }
          }
          if (v99 != &v101) {
            free(v99);
          }
          sub_1CD04BB34((char *)v78);
          uint64_t v6 = 1;
          goto LABEL_20;
        }
        if (v15 >= 0x7FFFFFFFFFFFFFF8) {
          abort();
        }
        if (v15 >= 0x17)
        {
          uint64_t v21 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v15 | 7) != 0x17) {
            uint64_t v21 = v15 | 7;
          }
          uint64_t v22 = v21 + 1;
          unint64_t v20 = operator new(v21 + 1);
          uint64_t v93 = v15;
          unint64_t v94 = v22 | 0x8000000000000000;
          long long __dst = v20;
        }
        else
        {
          HIBYTE(v94) = v15;
          unint64_t v20 = &__dst;
          if (!v15) {
            goto LABEL_33;
          }
        }
        memmove(v20, v16, v15);
LABEL_33:
        *((unsigned char *)v20 + v15) = 0;
        char v19 = HIBYTE(v94);
        unint64_t v18 = __dst;
        uint64_t v17 = v93;
        goto LABEL_34;
      }
    }
    uint64_t v6 = 0;
  }
LABEL_20:
  if (v106 != v108) {
    free(v106);
  }
  return v6;
}

void sub_1CD04BB34(char *a1)
{
  if (a1)
  {
    sub_1CD04BB34(*(void *)a1);
    sub_1CD04BB34(*((void *)a1 + 1));
    if (a1[71] < 0) {
      operator delete(*((void **)a1 + 6));
    }
    operator delete(a1);
  }
}

BOOL sub_1CD04BB90(uint64_t **a1, uint64_t **a2)
{
  uint64_t v2 = **a1;
  uint64_t v3 = **a2;
  if (v2 < v3) {
    return 1;
  }
  if (v3 < v2) {
    return 0;
  }
  unint64_t v5 = *a1[1];
  unint64_t v6 = *a2[1];
  if (v5 < v6) {
    return 1;
  }
  if (v6 < v5) {
    return 0;
  }
  unsigned int v7 = (const void **)a1[2];
  std::chrono::system_clock::time_point v8 = a2[2];
  char v9 = *((unsigned char *)v8 + 23);
  if (*((char *)v7 + 23) < 0)
  {
    uint64_t v17 = v7;
    unsigned int v7 = (const void **)*v7;
    size_t v10 = (size_t)v17[1];
  }
  else
  {
    size_t v10 = *((unsigned __int8 *)v7 + 23);
  }
  int v11 = v9;
  size_t v12 = v9 & 0x7F;
  if (v11 >= 0) {
    size_t v13 = v12;
  }
  else {
    size_t v13 = v8[1];
  }
  if (v11 >= 0) {
    unsigned int v14 = a2[2];
  }
  else {
    unsigned int v14 = (uint64_t *)*v8;
  }
  if (v13 >= v10) {
    size_t v15 = v10;
  }
  else {
    size_t v15 = v13;
  }
  int v16 = memcmp(v7, v14, v15);
  if (v16) {
    return v16 < 0;
  }
  else {
    return v10 < v13;
  }
}

void llvm::localCache(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  v51[8] = *MEMORY[0x1E4F143B8];
  BOOL v33 = v35;
  long long v34 = xmmword_1CD96DBD0;
  int v30 = v32;
  long long v31 = xmmword_1CD96DBD0;
  unint64_t v27 = v29;
  long long v28 = xmmword_1CD96DBD0;
  LODWORD(v37) = 0;
  char v40 = 0;
  uint64_t v41 = 0;
  int v43 = &v33;
  int v42 = 0;
  std::chrono::system_clock::time_point v36 = &unk_1F2646FA8;
  *((void *)&v37 + 1) = 0;
  uint64_t v39 = 0;
  uint64_t v38 = 0;
  size_t v10 = llvm::Twine::printOneChild((llvm::raw_ostream *)a1, (llvm::raw_ostream *)&v36, *(void *)a1, *(void *)(a1 + 8), *(unsigned char *)(a1 + 32));
  int v11 = llvm::Twine::printOneChild(v10, (llvm::raw_ostream *)&v36, *(void *)(a1 + 16), *(void *)(a1 + 24), *(unsigned char *)(a1 + 33));
  std::chrono::system_clock::time_point v36 = &unk_1F2646B98;
  if (v42 == 1)
  {
    int v11 = (llvm::raw_ostream *)*((void *)&v37 + 1);
    if (*((void *)&v37 + 1)) {
      int v11 = (llvm::raw_ostream *)MEMORY[0x1D25D9CB0](*((void *)&v37 + 1), 0x1000C8077774924);
    }
  }
  LODWORD(v37) = 0;
  char v40 = 0;
  uint64_t v41 = 0;
  int v43 = &v30;
  int v42 = 0;
  std::chrono::system_clock::time_point v36 = &unk_1F2646FA8;
  *((void *)&v37 + 1) = 0;
  uint64_t v39 = 0;
  uint64_t v38 = 0;
  size_t v12 = llvm::Twine::printOneChild(v11, (llvm::raw_ostream *)&v36, *(void *)a2, *(void *)(a2 + 8), *(unsigned char *)(a2 + 32));
  size_t v13 = llvm::Twine::printOneChild(v12, (llvm::raw_ostream *)&v36, *(void *)(a2 + 16), *(void *)(a2 + 24), *(unsigned char *)(a2 + 33));
  std::chrono::system_clock::time_point v36 = &unk_1F2646B98;
  if (v42 == 1)
  {
    size_t v13 = (llvm::raw_ostream *)*((void *)&v37 + 1);
    if (*((void *)&v37 + 1)) {
      size_t v13 = (llvm::raw_ostream *)MEMORY[0x1D25D9CB0](*((void *)&v37 + 1), 0x1000C8077774924);
    }
  }
  LODWORD(v37) = 0;
  char v40 = 0;
  uint64_t v41 = 0;
  int v43 = &v27;
  int v42 = 0;
  std::chrono::system_clock::time_point v36 = &unk_1F2646FA8;
  *((void *)&v37 + 1) = 0;
  uint64_t v39 = 0;
  uint64_t v38 = 0;
  unsigned int v14 = llvm::Twine::printOneChild(v13, (llvm::raw_ostream *)&v36, *(void *)a3, *(void *)(a3 + 8), *(unsigned char *)(a3 + 32));
  llvm::Twine::printOneChild(v14, (llvm::raw_ostream *)&v36, *(void *)(a3 + 16), *(void *)(a3 + 24), *(unsigned char *)(a3 + 33));
  std::chrono::system_clock::time_point v36 = &unk_1F2646B98;
  if (v42 == 1 && *((void *)&v37 + 1)) {
    MEMORY[0x1D25D9CB0](*((void *)&v37 + 1), 0x1000C8077774924);
  }
  int v16 = v18;
  long long v17 = xmmword_1CD96DBD0;
  if ((void)v28) {
    sub_1CC223970((uint64_t)&v16, (uint64_t)&v27);
  }
  sub_1CD04C2EC((uint64_t)v19, a4);
  uint64_t v21 = v23;
  long long v22 = xmmword_1CD96DBD0;
  if ((void)v31) {
    sub_1CC223970((uint64_t)&v21, (uint64_t)&v30);
  }
  unint64_t v24 = v26;
  long long v25 = xmmword_1CD96DBD0;
  if ((void)v34) {
    sub_1CC223970((uint64_t)&v24, (uint64_t)&v33);
  }
  *(unsigned char *)(a5 + 32) &= ~1u;
  std::chrono::system_clock::time_point v36 = &v38;
  long long v37 = xmmword_1CD96DBD0;
  if ((void)v17) {
    sub_1CC1B8518((uint64_t)&v36, (uint64_t)&v16);
  }
  if (v20)
  {
    if (v20 == v19)
    {
      int v45 = v44;
      (*(void (**)(void *, void *))(v19[0] + 24))(v19, v44);
    }
    else
    {
      int v45 = v20;
      unint64_t v20 = 0;
    }
  }
  else
  {
    int v45 = 0;
  }
  long long v46 = v48;
  long long v47 = xmmword_1CD96DBD0;
  if ((void)v22) {
    sub_1CC1B8518((uint64_t)&v46, (uint64_t)&v21);
  }
  int v49 = v51;
  long long v50 = xmmword_1CD96DBD0;
  if ((void)v25) {
    sub_1CC1B8518((uint64_t)&v49, (uint64_t)&v24);
  }
  *(void *)(a5 + 24) = 0;
  size_t v15 = (char *)operator new(0x130uLL);
  *(void *)size_t v15 = &unk_1F26437F0;
  *((void *)v15 + 1) = v15 + 32;
  *((_OWORD *)v15 + 1) = xmmword_1CD96DBD0;
  if ((void)v37) {
    sub_1CC1B8518((uint64_t)(v15 + 8), (uint64_t)&v36);
  }
  if (v45)
  {
    if (v45 == v44)
    {
      *((void *)v15 + 15) = v15 + 96;
      (*(void (**)(void *))(v44[0] + 24))(v44);
    }
    else
    {
      *((void *)v15 + 15) = v45;
      int v45 = 0;
    }
  }
  else
  {
    *((void *)v15 + 15) = 0;
  }
  *((void *)v15 + 16) = v15 + 152;
  *(_OWORD *)(v15 + 136) = xmmword_1CD96DBD0;
  if ((void)v47) {
    sub_1CC1B8518((uint64_t)(v15 + 128), (uint64_t)&v46);
  }
  *((void *)v15 + 27) = v15 + 240;
  *((_OWORD *)v15 + 14) = xmmword_1CD96DBD0;
  if ((void)v50) {
    sub_1CC1B8518((uint64_t)(v15 + 216), (uint64_t)&v49);
  }
  *(void *)(a5 + 24) = v15;
  if (v49 != v51) {
    free(v49);
  }
  if (v46 != v48) {
    free(v46);
  }
  if (v45 == v44)
  {
    (*(void (**)(void *))(v44[0] + 32))(v44);
  }
  else if (v45)
  {
    (*(void (**)(void))(*v45 + 40))();
  }
  if (v36 != &v38) {
    free(v36);
  }
  if (v24 != v26) {
    free(v24);
  }
  if (v21 != v23) {
    free(v21);
  }
  if (v20 == v19)
  {
    (*(void (**)(void *))(v19[0] + 32))(v19);
  }
  else if (v20)
  {
    (*(void (**)(void))(*v20 + 40))();
  }
  if (v16 != v18) {
    free(v16);
  }
  if (v27 != v29) {
    free(v27);
  }
  if (v30 != v32) {
    free(v30);
  }
  if (v33 != v35) {
    free(v33);
  }
}

uint64_t sub_1CD04C2EC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *sub_1CD04C384(void *a1)
{
  *a1 = &unk_1F26437F0;
  uint64_t v2 = (void *)a1[27];
  if (v2 != a1 + 30) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[16];
  if (v3 != a1 + 19) {
    free(v3);
  }
  unint64_t v4 = (void *)a1[15];
  if (v4 == a1 + 12)
  {
    (*(void (**)(void *))(a1[12] + 32))(a1 + 12);
  }
  else if (v4)
  {
    (*(void (**)(void *))(*v4 + 40))(v4);
  }
  unint64_t v5 = (void *)a1[1];
  if (v5 != a1 + 4) {
    free(v5);
  }
  return a1;
}

void sub_1CD04C464(void *a1)
{
  *a1 = &unk_1F26437F0;
  uint64_t v2 = (void *)a1[27];
  if (v2 != a1 + 30) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[16];
  if (v3 != a1 + 19) {
    free(v3);
  }
  unint64_t v4 = (void *)a1[15];
  if (v4 == a1 + 12)
  {
    (*(void (**)(void *))(a1[12] + 32))(a1 + 12);
  }
  else if (v4)
  {
    (*(void (**)(void *))(*v4 + 40))(v4);
  }
  unint64_t v5 = (void *)a1[1];
  if (v5 != a1 + 4) {
    free(v5);
  }

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CD04C564(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x130uLL);
  void *v2 = &unk_1F26437F0;
  sub_1CD04CDB0((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t sub_1CD04C5B8(uint64_t a1, void *a2)
{
  *a2 = &unk_1F26437F0;
  return sub_1CD04CDB0((uint64_t)(a2 + 1), (void *)(a1 + 8));
}

void sub_1CD04C5E4(void *a1)
{
  uint64_t v2 = (void *)a1[27];
  if (v2 != a1 + 30) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[16];
  if (v3 != a1 + 19) {
    free(v3);
  }
  unint64_t v4 = (void *)a1[15];
  if (v4 == a1 + 12)
  {
    (*(void (**)(void *))(a1[12] + 32))(a1 + 12);
  }
  else if (v4)
  {
    (*(void (**)(void *))(*v4 + 40))(v4);
  }
  unint64_t v5 = (void *)a1[1];
  if (v5 != a1 + 4)
  {
    free(v5);
  }
}

void sub_1CD04C6BC(char *__p)
{
  uint64_t v2 = (char *)*((void *)__p + 27);
  if (v2 != __p + 240) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)__p + 16);
  if (v3 != __p + 152) {
    free(v3);
  }
  unint64_t v4 = (char *)*((void *)__p + 15);
  if (v4 == __p + 96)
  {
    (*(void (**)(char *))(*((void *)__p + 12) + 32))(__p + 96);
  }
  else if (v4)
  {
    (*(void (**)(char *))(*(void *)v4 + 40))(v4);
  }
  unint64_t v5 = (char *)*((void *)__p + 1);
  if (v5 != __p + 32) {
    free(v5);
  }

  operator delete(__p);
}

void sub_1CD04C790(void *a1@<X0>, int *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  char v65[8] = *MEMORY[0x1E4F143B8];
  int v6 = *a2;
  uint64_t v7 = *a3;
  uint64_t v8 = a3[1];
  long long v50 = v52;
  long long v51 = xmmword_1CD96DBD0;
  char v9 = (void *)a1[1];
  uint64_t v10 = a1[2];
  uint64_t v11 = (uint64_t)(a1 + 1);
  __int16 v57 = 261;
  unint64_t v53 = v9;
  uint64_t v54 = v10;
  __int16 v33 = 1283;
  int v30 = "llvmcache-";
  *((void *)&v31 + 1) = v7;
  uint64_t v32 = v8;
  v49[4] = 257;
  __int16 v29 = 257;
  llvm::sys::path::append(&v50, 0, (const char **)&v53, (void **)&v30, (uint64_t)&v47, (uint64_t)v28);
  long long v47 = v49;
  long long v48 = xmmword_1CD96DBD0;
  __int16 v57 = 261;
  unint64_t v53 = v50;
  uint64_t v54 = v51;
  llvm::sys::fs::openNativeFileForRead((unsigned __int8 *)&v53, 32, &v47, (uint64_t)v45);
  std::system_category();
  char v12 = v46;
  if (v46)
  {
    int v16 = *(char **)v45;
    *(void *)int v45 = 0;
    uint64_t v26 = v16;
    uint64_t v17 = llvm::errorToErrorCode(&v26);
    char v19 = v18;
    *(void *)&v27.__val_ = v17;
    v27.__cat_ = v18;
    if (v26) {
      (*(void (**)(char *))(*(void *)v26 + 8))(v26);
    }
    goto LABEL_10;
  }
  size_t v13 = (llvm::sys::Process *)v45[0];
  __int16 v57 = 261;
  unint64_t v53 = v50;
  uint64_t v54 = v51;
  sub_1CD097170((llvm::WritableMemoryBuffer *)0xFFFFFFFFFFFFFFFFLL, v45[0], (const void ***)&v53, (llvm::WritableMemoryBuffer *)0xFFFFFFFFFFFFFFFFLL, 0, 0, 0, (uint64_t)&v30);
  v45[0] = -1;
  llvm::sys::Process::SafelyCloseFileDescriptor(v13);
  if (BYTE8(v31))
  {
    uint64_t v17 = (uint64_t)v30;
    char v19 = (const std::error_category *)v31;
    *(void *)&v27.__val_ = v30;
    v27.__cat_ = (const std::error_category *)v31;
LABEL_10:
    if ((v19 != std::generic_category() || v17 != 2) && (v19 != std::generic_category() || v17 != 13))
    {
      v24[0] = "Failed to open cache file ";
      v24[2] = v50;
      v24[3] = v51;
      __int16 v25 = 1283;
      v28[0] = v24;
      v28[2] = ": ";
      __int16 v29 = 770;
      std::error_code::message(&v23, &v27);
      int v30 = v28;
      *((void *)&v31 + 1) = &v23;
      __int16 v33 = 1026;
      unint64_t v53 = &v30;
      unint64_t v55 = "\n";
      __int16 v57 = 770;
      sub_1CD4FF4BC(v17, (uint64_t)v19, (llvm::Twine *)&v53);
    }
    int v30 = &v32;
    long long v31 = xmmword_1CD96DBD0;
    if (a1[2]) {
      sub_1CC223970((uint64_t)&v30, v11);
    }
    long long v34 = v36;
    long long v35 = xmmword_1CD96DBD0;
    if (a1[17]) {
      sub_1CC223970((uint64_t)&v34, (uint64_t)(a1 + 16));
    }
    long long v37 = v39;
    long long v38 = xmmword_1CD96DBD0;
    if (a1[28]) {
      sub_1CC223970((uint64_t)&v37, (uint64_t)(a1 + 27));
    }
    sub_1CD04C2EC((uint64_t)v40, (uint64_t)(a1 + 12));
    int v42 = v44;
    long long v43 = xmmword_1CD96DBD0;
    if ((void)v51) {
      sub_1CC223970((uint64_t)&v42, (uint64_t)&v50);
    }
    *(unsigned char *)(a4 + 32) &= ~1u;
    sub_1CD04CE60((uint64_t)&v53, &v30);
    unint64_t v20 = operator new(0x188uLL);
    *unint64_t v20 = &unk_1F2643838;
    sub_1CD04CE60((uint64_t)(v20 + 1), &v53);
    *(void *)(a4 + 24) = v20;
    if (v64 != v65) {
      free(v64);
    }
    if (v63 == v62)
    {
      (*(void (**)(void *))(v62[0] + 32))(v62);
    }
    else if (v63)
    {
      (*(void (**)(void))(*v63 + 40))();
    }
    if (v60 != &v61) {
      free(v60);
    }
    if (v58 != &v59) {
      free(v58);
    }
    if (v53 != &v56) {
      free(v53);
    }
    if (v42 != v44) {
      free(v42);
    }
    if (v41 == v40)
    {
      (*(void (**)(void *))(v40[0] + 32))(v40);
    }
    else if (v41)
    {
      (*(void (**)(void))(*v41 + 40))();
    }
    if (v37 != v39) {
      free(v37);
    }
    if (v34 != v36) {
      free(v34);
    }
    if (v30 != &v32) {
      free(v30);
    }
    if ((v12 & 1) != 0 && *(void *)v45) {
      (*(void (**)(void))(**(void **)v45 + 8))(*(void *)v45);
    }
    goto LABEL_49;
  }
  unint64_t v53 = v30;
  LODWORD(v28[0]) = v6;
  uint64_t v14 = a1[15];
  if (!v14)
  {
    sub_1CB920400();
    sub_1CD04CDB0(v21, v22);
    return;
  }
  (*(void (**)(uint64_t, void *, void **))(*(void *)v14 + 48))(v14, v28, &v53);
  size_t v15 = v53;
  unint64_t v53 = 0;
  if (v15) {
    (*(void (**)(void *))(*(void *)v15 + 8))(v15);
  }
  *(unsigned char *)(a4 + 32) &= ~1u;
  *(void *)(a4 + 24) = 0;
LABEL_49:
  if (v47 != v49) {
    free(v47);
  }
  if (v50 != v52) {
    free(v50);
  }
}

uint64_t sub_1CD04CDB0(uint64_t a1, void *a2)
{
  *(void *)a1 = a1 + 24;
  *(_OWORD *)(a1 + 8) = xmmword_1CD96DBD0;
  if (a2[1]) {
    sub_1CC223970(a1, (uint64_t)a2);
  }
  sub_1CD04C2EC(a1 + 88, (uint64_t)(a2 + 11));
  *(void *)(a1 + 120) = a1 + 144;
  *(_OWORD *)(a1 + 128) = xmmword_1CD96DBD0;
  if (a2[16]) {
    sub_1CC223970(a1 + 120, (uint64_t)(a2 + 15));
  }
  *(void *)(a1 + 208) = a1 + 232;
  *(_OWORD *)(a1 + 216) = xmmword_1CD96DBD0;
  if (a2[27]) {
    sub_1CC223970(a1 + 208, (uint64_t)(a2 + 26));
  }
  return a1;
}

uint64_t sub_1CD04CE60(uint64_t a1, void *a2)
{
  *(void *)a1 = a1 + 24;
  *(_OWORD *)(a1 + 8) = xmmword_1CD96DBD0;
  if (a2[1]) {
    sub_1CC1B8518(a1, (uint64_t)a2);
  }
  *(void *)(a1 + 88) = a1 + 112;
  *(_OWORD *)(a1 + 96) = xmmword_1CD96DBD0;
  if (a2[12]) {
    sub_1CC1B8518(a1 + 88, (uint64_t)(a2 + 11));
  }
  *(void *)(a1 + 176) = a1 + 200;
  *(_OWORD *)(a1 + 184) = xmmword_1CD96DBD0;
  if (a2[23]) {
    sub_1CC1B8518(a1 + 176, (uint64_t)(a2 + 22));
  }
  unint64_t v4 = (void *)a2[36];
  if (v4)
  {
    if (v4 == a2 + 33)
    {
      *(void *)(a1 + 288) = a1 + 264;
      (*(void (**)(void))(*(void *)a2[36] + 24))(a2[36]);
    }
    else
    {
      *(void *)(a1 + 288) = v4;
      a2[36] = 0;
    }
  }
  else
  {
    *(void *)(a1 + 288) = 0;
  }
  *(void *)(a1 + 296) = a1 + 320;
  *(_OWORD *)(a1 + 304) = xmmword_1CD96DBD0;
  if (a2[38]) {
    sub_1CC1B8518(a1 + 296, (uint64_t)(a2 + 37));
  }
  return a1;
}

void *sub_1CD04CF80(void *a1)
{
  *a1 = &unk_1F2643838;
  uint64_t v2 = (void *)a1[38];
  if (v2 != a1 + 41) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[37];
  if (v3 == a1 + 34)
  {
    (*(void (**)(void *))(a1[34] + 32))(a1 + 34);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  unint64_t v4 = (void *)a1[23];
  if (v4 != a1 + 26) {
    free(v4);
  }
  unint64_t v5 = (void *)a1[12];
  if (v5 != a1 + 15) {
    free(v5);
  }
  int v6 = (void *)a1[1];
  if (v6 != a1 + 4) {
    free(v6);
  }
  return a1;
}

void sub_1CD04D074(void *a1)
{
  *a1 = &unk_1F2643838;
  uint64_t v2 = (void *)a1[38];
  if (v2 != a1 + 41) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[37];
  if (v3 == a1 + 34)
  {
    (*(void (**)(void *))(a1[34] + 32))(a1 + 34);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  unint64_t v4 = (void *)a1[23];
  if (v4 != a1 + 26) {
    free(v4);
  }
  unint64_t v5 = (void *)a1[12];
  if (v5 != a1 + 15) {
    free(v5);
  }
  int v6 = (void *)a1[1];
  if (v6 != a1 + 4) {
    free(v6);
  }

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CD04D188(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x188uLL);
  void *v2 = &unk_1F2643838;
  sub_1CD04D8C0((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t sub_1CD04D1DC(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2643838;
  return sub_1CD04D8C0((uint64_t)(a2 + 1), (void *)(a1 + 8));
}

void sub_1CD04D208(void *a1)
{
  uint64_t v2 = (void *)a1[38];
  if (v2 != a1 + 41) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[37];
  if (v3 == a1 + 34)
  {
    (*(void (**)(void *))(a1[34] + 32))(a1 + 34);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  unint64_t v4 = (void *)a1[23];
  if (v4 != a1 + 26) {
    free(v4);
  }
  unint64_t v5 = (void *)a1[12];
  if (v5 != a1 + 15) {
    free(v5);
  }
  int v6 = (void *)a1[1];
  if (v6 != a1 + 4)
  {
    free(v6);
  }
}

void sub_1CD04D2F4(char *__p)
{
  uint64_t v2 = (char *)*((void *)__p + 38);
  if (v2 != __p + 328) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)__p + 37);
  if (v3 == __p + 272)
  {
    (*(void (**)(char *))(*((void *)__p + 34) + 32))(__p + 272);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }
  unint64_t v4 = (char *)*((void *)__p + 23);
  if (v4 != __p + 208) {
    free(v4);
  }
  unint64_t v5 = (char *)*((void *)__p + 12);
  if (v5 != __p + 120) {
    free(v5);
  }
  int v6 = (char *)*((void *)__p + 1);
  if (v6 != __p + 32) {
    free(v6);
  }

  operator delete(__p);
}

uint64_t sub_1CD04D3DC@<X0>(const char **a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  v33[4] = 261;
  unint64_t v4 = a1[2];
  long long v31 = a1[1];
  *(void *)&long long v32 = v4;
  directories = (llvm *)llvm::sys::fs::create_directories((void **)&v31, 1, 504);
  if (!directories)
  {
    long long v31 = (const char *)v33;
    long long v32 = xmmword_1CD96DBD0;
    LOWORD(v22) = 261;
    uint64_t v8 = a1[2];
    v21[0] = a1[1];
    v21[1] = v8;
    char v9 = a1[12];
    uint64_t v10 = a1[13];
    __int16 v30 = 773;
    std::error_code v27 = v9;
    uint64_t v28 = (uint64_t)v10;
    __int16 v29 = "-%%%%%%.tmp.o";
    __int16 v20 = 257;
    __int16 v26 = 257;
    llvm::sys::path::append(&v31, 0, v21, (void **)&v27, (uint64_t)__dst, (uint64_t)__p);
    __int16 v30 = 261;
    std::error_code v27 = v31;
    uint64_t v28 = v32;
    llvm::sys::fs::TempFile::create((uint64_t)&v27, 384, 0, (uint64_t)v21);
    if ((v23 & 1) == 0) {
      operator new();
    }
    uint64_t v11 = std::generic_category();
    if (v23)
    {
      char v12 = v21[0];
      v21[0] = 0;
    }
    else
    {
      char v12 = 0;
    }
    uint64_t v17 = v12;
    sub_1CD4FB504((uint64_t *)&v17, &v18);
    size_t v13 = std::string::append(&v18, ": ");
    std::string::size_type v14 = v13->__r_.__value_.__r.__words[2];
    *(_OWORD *)long long __p = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    std::string::size_type v25 = v14;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    size_t v15 = a1[23];
    int v16 = a1[24];
    __dst[0] = __p;
    __dst[2] = v15;
    __dst[3] = v16;
    __int16 v20 = 1284;
    std::error_code v27 = (const char *)__dst;
    __int16 v29 = ": Can't get a temporary file";
    __int16 v30 = 770;
    sub_1CD4FF4BC(5, (uint64_t)v11, (llvm::Twine *)&v27);
  }
  uint64_t result = llvm::errorCodeToError(directories, v6, (void *)a2);
  *(unsigned char *)(a2 + 8) |= 1u;
  return result;
}

uint64_t sub_1CD04D8C0(uint64_t a1, void *a2)
{
  *(void *)a1 = a1 + 24;
  *(_OWORD *)(a1 + 8) = xmmword_1CD96DBD0;
  if (a2[1]) {
    sub_1CC223970(a1, (uint64_t)a2);
  }
  *(void *)(a1 + 88) = a1 + 112;
  *(_OWORD *)(a1 + 96) = xmmword_1CD96DBD0;
  if (a2[12]) {
    sub_1CC223970(a1 + 88, (uint64_t)(a2 + 11));
  }
  *(void *)(a1 + 176) = a1 + 200;
  *(_OWORD *)(a1 + 184) = xmmword_1CD96DBD0;
  if (a2[23]) {
    sub_1CC223970(a1 + 176, (uint64_t)(a2 + 22));
  }
  sub_1CD04C2EC(a1 + 264, (uint64_t)(a2 + 33));
  *(void *)(a1 + 296) = a1 + 320;
  *(_OWORD *)(a1 + 304) = xmmword_1CD96DBD0;
  if (a2[38]) {
    sub_1CC223970(a1 + 296, (uint64_t)(a2 + 37));
  }
  return a1;
}

uint64_t sub_1CD04D994(uint64_t a1)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)a1 = &unk_1F2643880;
  *(void *)(a1 + 8) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  int v3 = *(_DWORD *)(a1 + 104);
  __int16 v46 = 260;
  v45[0] = (const void **)(a1 + 16);
  sub_1CD097170((llvm::WritableMemoryBuffer *)0xFFFFFFFFFFFFFFFFLL, v3, v45, (llvm::WritableMemoryBuffer *)0xFFFFFFFFFFFFFFFFLL, 0, 0, 0, (uint64_t)v47);
  if (v48)
  {
    v40[0] = (uint64_t)"Failed to open new cache file ";
    __int16 v41 = 259;
    __int16 v39 = 260;
    v38[0] = a1 + 80;
    sub_1CD3E3950(v40, v38, (uint64_t)v42);
    v36[0] = (uint64_t)": ";
    __int16 v37 = 259;
    sub_1CD3E3950((uint64_t *)v42, v36, (uint64_t)v43);
    *(void *)&v27.__val_ = sub_1CD82C58C(v47);
    v27.__cat_ = v19;
    std::error_code::message(&v29, &v27);
    __int16 v35 = 260;
    v34[0] = (uint64_t)&v29;
    sub_1CD3E3950((uint64_t *)v43, v34, (uint64_t)v44);
    v32[0] = (uint64_t)"\n";
    __int16 v33 = 259;
    __int16 v20 = v32;
    goto LABEL_39;
  }
  __int16 v46 = 260;
  v45[0] = (const void **)(a1 + 16);
  llvm::sys::fs::TempFile::keep((llvm::sys::fs::TempFile *)(a1 + 72), (const llvm::Twine *)v45, v4, &v31);
  unint64_t v5 = (void *)v31;
  uint64_t v31 = 0;
  v45[0] = (const void **)v47;
  v45[1] = (const void **)a1;
  if (!v5)
  {
    uint64_t v31 = 0;
    goto LABEL_23;
  }
  if ((*(unsigned int (**)(void *, void *))(*v5 + 48))(v5, &llvm::ErrorList::ID))
  {
    std::error_code v6 = (uint64_t *)v5[1];
    uint64_t v7 = (uint64_t *)v5[2];
    if (v6 == v7)
    {
      uint64_t v8 = 0;
    }
    else
    {
      uint64_t v8 = 0;
      do
      {
        v43[0] = v8;
        uint64_t v9 = *v6;
        *std::error_code v6 = 0;
        v40[0] = v9;
        sub_1CD04DF58(v42, v40, (std::error_category **)v45);
        sub_1CD451630(v43, v42, v44);
        uint64_t v8 = v44[0];
        v44[0] = 0;
        if (v42[0]) {
          (*(void (**)(char *))(*(void *)v42[0] + 8))(v42[0]);
        }
        uint64_t v10 = v40[0];
        v40[0] = 0;
        if (v10) {
          (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
        }
        if (v43[0]) {
          (*(void (**)(char *))(*(void *)v43[0] + 8))(v43[0]);
        }
        ++v6;
      }
      while (v6 != v7);
    }
    v36[0] = (uint64_t)v8;
  }
  else
  {
    v38[0] = (uint64_t)v5;
    sub_1CD04DF58(v36, v38, (std::error_category **)v45);
    unint64_t v5 = (void *)v38[0];
    if (!v38[0]) {
      goto LABEL_22;
    }
  }
  (*(void (**)(void *))(*v5 + 8))(v5);
LABEL_22:
  uint64_t v31 = v36[0];
  if (v36[0])
  {
    v36[0] = (uint64_t)"Failed to rename temporary file ";
    __int16 v37 = 259;
    __int16 v35 = 260;
    v34[0] = a1 + 80;
    sub_1CD3E3950(v36, v34, (uint64_t)v38);
    v32[0] = (uint64_t)" to ";
    __int16 v33 = 259;
    sub_1CD3E3950(v38, v32, (uint64_t)v40);
    __int16 v30 = 260;
    v29.__r_.__value_.__r.__words[0] = a1 + 16;
    sub_1CD3E3950(v40, (uint64_t *)&v29, (uint64_t)v42);
    *(void *)&v27.__val_ = ": ";
    __int16 v28 = 259;
    sub_1CD3E3950((uint64_t *)v42, (uint64_t *)&v27.__val_, (uint64_t)v43);
    uint64_t v23 = v31;
    uint64_t v31 = 0;
    sub_1CD4FB504(&v23, &v24);
    __int16 v26 = 260;
    std::string::size_type v25 = &v24;
    sub_1CD3E3950((uint64_t *)v43, (uint64_t *)&v25, (uint64_t)v44);
    uint64_t v21 = "\n";
    __int16 v22 = 259;
    __int16 v20 = (uint64_t *)&v21;
LABEL_39:
    sub_1CD3E3950((uint64_t *)v44, v20, (uint64_t)v45);
    llvm::report_fatal_error((llvm *)v45, (const llvm::Twine *)1);
  }
LABEL_23:
  int v11 = *(_DWORD *)(a1 + 112);
  char v12 = (const void **)v47[0];
  v47[0] = 0;
  v45[0] = v12;
  LODWORD(v44[0]) = v11;
  uint64_t v13 = *(void *)(a1 + 64);
  if (!v13) {
    sub_1CB920400();
  }
  (*(void (**)(uint64_t, char **, const void ***))(*(void *)v13 + 48))(v13, v44, v45);
  std::string::size_type v14 = v45[0];
  v45[0] = 0;
  if (v14) {
    (*((void (**)(const void **))*v14 + 1))(v14);
  }
  if (v31) {
    (*(void (**)(uint64_t))(*(void *)v31 + 8))(v31);
  }
  if ((v48 & 1) == 0)
  {
    uint64_t v15 = v47[0];
    v47[0] = 0;
    if (v15) {
      (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
    }
  }
  uint64_t v16 = a1 + 40;
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  uint64_t v17 = *(void *)(a1 + 64);
  if (v17 == v16)
  {
    (*(void (**)(uint64_t))(*(void *)v16 + 32))(a1 + 40);
  }
  else if (v17)
  {
    (*(void (**)(uint64_t))(*(void *)v17 + 40))(v17);
  }
  sub_1CCB83EC4(a1);
  return a1;
}

void sub_1CD04DF20(uint64_t a1)
{
  sub_1CD04D994(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD04DF58(void *a1, void *a2, std::error_category **a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t result = (*(uint64_t (**)(void, void *))(*(void *)*a2 + 48))(*a2, &llvm::ECError::ID);
  uint64_t v7 = *a2;
  *a2 = 0;
  if (result)
  {
    uint64_t v8 = a3[1];
    uint64_t v9 = (llvm *)(*(uint64_t (**)(uint64_t))(*(void *)v7 + 32))(v7);
    int v11 = v10;
    if (std::generic_category() == v10 && v9 == 13)
    {
      std::string::size_type v14 = (*a3)->__vftable;
      uint64_t v15 = v14->~error_category_0;
      uint64_t v16 = (llvm::WritableMemoryBuffer *)((char *)v14->name - (char *)v15);
      __int16 v21 = 260;
      v19[0] = &v8[2].__vftable;
      sub_1CD0963EC(v16, v15, (const void ***)v19, (uint64_t)&v22);
      if (v23) {
        uint64_t v17 = 0;
      }
      else {
        uint64_t v17 = v22;
      }
      char v20 = 0;
      v19[0] = v17;
      sub_1CCB73F2C(*a3, (uint64_t)v19);
      if ((v20 & 1) == 0)
      {
        std::string v18 = v19[0];
        v19[0] = 0;
        if (v18) {
          (*(void (**)(void *))(*v18 + 8))(v18);
        }
      }
      llvm::sys::fs::TempFile::discard((llvm::sys::fs::TempFile *)&v8[9], v19);
      sub_1CD4515D0(v19);
      if (v19[0]) {
        (*(void (**)(void *))(*v19[0] + 8))(v19[0]);
      }
      *a1 = 0;
    }
    else
    {
      *(void *)&v12.__val_ = v11;
      llvm::errorCodeToError(v9, v12, a1);
    }
    return (*(uint64_t (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  else
  {
    *a1 = v7;
  }
  return result;
}

llvm::raw_ostream *llvm::circular_raw_ostream::write_impl(llvm::raw_ostream *this, const char *a2, size_t a3)
{
  size_t v3 = a3;
  unint64_t v5 = this;
  uint64_t v6 = *((void *)this + 10);
  if (v6)
  {
    if (a3)
    {
      uint64_t v7 = (llvm::raw_ostream *)*((void *)this + 11);
      this = (llvm::raw_ostream *)*((void *)this + 12);
      do
      {
        unsigned int v8 = v7 - this + v6;
        if (v8 >= v3) {
          size_t v9 = v3;
        }
        else {
          size_t v9 = v8;
        }
        memcpy(this, a2, v9);
        uint64_t v7 = (llvm::raw_ostream *)*((void *)v5 + 11);
        this = (llvm::raw_ostream *)(*((void *)v5 + 12) + v9);
        *((void *)v5 + 12) = this;
        uint64_t v6 = *((void *)v5 + 10);
        if (this == (llvm::raw_ostream *)((char *)v7 + v6))
        {
          *((void *)v5 + 12) = v7;
          *((unsigned char *)v5 + 104) = 1;
          this = v7;
        }
        v3 -= v9;
      }
      while (v3);
    }
  }
  else
  {
    uint64_t v10 = (llvm::raw_ostream *)*((void *)this + 8);
    return llvm::raw_ostream::write(v10, a2, a3);
  }
  return this;
}

llvm::raw_ostream *llvm::circular_raw_ostream::flushBufferWithBanner(llvm::raw_ostream *this)
{
  if (*((void *)this + 10))
  {
    uint64_t v1 = (uint64_t)this;
    uint64_t v2 = (llvm::raw_ostream *)*((void *)this + 8);
    size_t v3 = (const char *)*((void *)this + 14);
    size_t v4 = strlen(v3);
    llvm::raw_ostream::write(v2, v3, v4);
    if (*(unsigned char *)(v1 + 104)) {
      llvm::raw_ostream::write(*(llvm::raw_ostream **)(v1 + 64), *(const char **)(v1 + 96), *(void *)(v1 + 88) + *(void *)(v1 + 80) - *(void *)(v1 + 96));
    }
    this = llvm::raw_ostream::write(*(llvm::raw_ostream **)(v1 + 64), *(const char **)(v1 + 88), *(void *)(v1 + 96) - *(void *)(v1 + 88));
    *(void *)(v1 + 96) = *(void *)(v1 + 88);
    *(unsigned char *)(v1 + 104) = 0;
  }
  return this;
}

void sub_1CD04E2B0(llvm::circular_raw_ostream *a1)
{
  sub_1CD04E380(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD04E2E8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 48))();
}

uint64_t sub_1CD04E310(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 64);
  return (*(uint64_t (**)(void *))(*v1 + 80))(v1) + v1[4] - (v1[2] + v1[4]) + v1[2];
}

llvm::circular_raw_ostream *sub_1CD04E380(llvm::circular_raw_ostream *this)
{
  *(void *)this = &unk_1F26438A0;
  uint64_t v2 = (const char *)*((void *)this + 2);
  if (*((const char **)this + 4) != v2)
  {
    *((void *)this + 4) = v2;
    llvm::raw_ostream::flush_tied_then_write(this, v2);
  }
  llvm::circular_raw_ostream::flushBufferWithBanner(this);
  uint64_t v3 = *((void *)this + 8);
  if (v3 && *((unsigned char *)this + 72)) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = *((void *)this + 11);
  if (v4) {
    MEMORY[0x1D25D9CB0](v4, 0x1000C8077774924);
  }
  *(void *)this = &unk_1F2646B98;
  if (*((_DWORD *)this + 14) == 1)
  {
    uint64_t v6 = *((void *)this + 2);
    if (v6) {
      MEMORY[0x1D25D9CB0](v6, 0x1000C8077774924);
    }
  }
  return this;
}

void llvm::format_provider<std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>>,void>::format(void *a1, llvm::raw_ostream *a2, const char *a3, unint64_t a4)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *a1 / 1000000000;
  uint64_t v8 = *a1 % 1000000000;
  memset(&v32, 0, sizeof(v32));
  __t.__d_.__rep_ = 1000000 * v7;
  __t.__d_.__rep_ = std::chrono::system_clock::to_time_t(&__t);
  localtime_r(&__t.__d_.__rep_, &v32);
  unint64_t v9 = 0;
  int v10 = 0;
  if (a4)
  {
    unint64_t v11 = a4;
  }
  else
  {
    a3 = "%Y-%m-%d %H:%M:%S.%N";
    unint64_t v11 = 20;
  }
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v31 = 0;
  int v22 = 0;
  char v26 = 0;
  uint64_t v27 = 0;
  std::string v29 = __p;
  int v28 = 0;
  __int16 v21 = &unk_1F2646F30;
  char v23 = 0;
  unint64_t v24 = 0;
  std::string::size_type v25 = 0;
  do
  {
    int v12 = a3[v9];
    unint64_t v13 = (v10 + 1);
    if (v12 == 37 && v11 > v13)
    {
      int v16 = a3[v13];
      if (v16 > 77)
      {
        if (v16 == 78)
        {
          __t.__d_.__rep_ = (std::chrono::duration<long long, std::ratio<1, 1000000>>::rep)&unk_1F2643918;
          uint64_t v34 = "%.6lu";
          uint64_t v35 = v8;
          goto LABEL_25;
        }
        if (v16 == 102)
        {
          __t.__d_.__rep_ = (std::chrono::duration<long long, std::ratio<1, 1000000>>::rep)&unk_1F2643918;
          uint64_t v34 = "%.6lu";
          uint64_t v35 = v8 / 1000;
          goto LABEL_25;
        }
      }
      else
      {
        if (v16 == 37)
        {
          if (v24 - (unint64_t)v25 > 1)
          {
            *(_WORD *)std::string::size_type v25 = 9509;
            v25 += 2;
          }
          else
          {
            llvm::raw_ostream::write((llvm::raw_ostream *)&v21, "%%", 2uLL);
          }
          goto LABEL_13;
        }
        if (v16 == 76)
        {
          __t.__d_.__rep_ = (std::chrono::duration<long long, std::ratio<1, 1000000>>::rep)&unk_1F2643918;
          uint64_t v34 = "%.3lu";
          uint64_t v35 = v8 / 1000000;
LABEL_25:
          llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v21, (uint64_t)&__t);
          goto LABEL_13;
        }
      }
    }
    uint64_t v15 = v25;
    if ((unint64_t)v25 >= v24)
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v21, v12);
    }
    else
    {
      ++v25;
      *uint64_t v15 = v12;
    }
    LODWORD(v13) = v10;
LABEL_13:
    unint64_t v9 = (v13 + 1);
    int v10 = v13 + 1;
  }
  while (v11 > v9);
  if (v25 != v23)
  {
    std::string::size_type v25 = v23;
    llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)&v21, v23);
  }
  if (v31 >= 0) {
    uint64_t v17 = __p;
  }
  else {
    uint64_t v17 = (void **)__p[0];
  }
  p_t = (const char *)&__t;
  if (!strftime((char *)&__t, 0x100uLL, (const char *)v17, &v32)) {
    p_t = "BAD-DATE-FORMAT";
  }
  size_t v19 = strlen(p_t);
  char v20 = (void *)*((void *)a2 + 4);
  if (v19 <= *((void *)a2 + 3) - (void)v20)
  {
    if (v19)
    {
      memcpy(v20, p_t, v19);
      *((void *)a2 + 4) += v19;
    }
  }
  else
  {
    llvm::raw_ostream::write(a2, p_t, v19);
  }
  __int16 v21 = &unk_1F2646B98;
  if (v28 == 1 && v23) {
    MEMORY[0x1D25D9CB0](v23, 0x1000C8077774924);
  }
  if (SHIBYTE(v31) < 0) {
    operator delete(__p[0]);
  }
}

double llvm::CodeGenCoverage::CodeGenCoverage(llvm::CodeGenCoverage *this)
{
  *(void *)this = (char *)this + 16;
  *(void *)&double result = 0x600000000;
  *((void *)this + 1) = 0x600000000;
  *((_DWORD *)this + 16) = 0;
  return result;
}

{
  double result;

  *(void *)this = (char *)this + 16;
  *(void *)&double result = 0x600000000;
  *((void *)this + 1) = 0x600000000;
  *((_DWORD *)this + 16) = 0;
  return result;
}

uint64_t llvm::CodeGenCoverage::isCovered(llvm::CodeGenCoverage *this, unint64_t a2)
{
  if (*((unsigned int *)this + 16) <= a2) {
    return 0;
  }
  else {
    return (*(void *)(*(void *)this + 8 * (a2 >> 6)) >> a2) & 1;
  }
}

uint64_t llvm::CodeGenCoverage::covered@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  int v2 = *(_DWORD *)(this + 64);
  if (v2)
  {
    uint64_t v3 = 0;
    uint64_t v4 = *(uint64_t **)this;
    unint64_t v5 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v2;
    uint64_t v6 = (v2 - 1) & 0xFFFFFFC0;
    uint64_t v7 = 0xFFFFFFFFLL;
    while (1)
    {
      uint64_t v9 = *v4++;
      uint64_t v8 = v9;
      unint64_t v10 = v6 == v3 ? v5 : -1;
      unint64_t v11 = v10 & v8;
      if (v11) {
        break;
      }
      v3 += 64;
      if (v6 + 64 == v3) {
        goto LABEL_10;
      }
    }
    uint64_t v7 = __clz(__rbit64(v11)) + v3;
  }
  else
  {
    uint64_t v7 = 0xFFFFFFFFLL;
  }
LABEL_10:
  *a2 = this;
  a2[1] = v7;
  a2[2] = this;
  a2[3] = 0xFFFFFFFFLL;
  return this;
}

uint64_t llvm::CodeGenCoverage::parse(uint64_t *a1, uint64_t a2, const void *a3, size_t a4)
{
  uint64_t v4 = *(const char **)(a2 + 8);
  unint64_t v5 = *(const char **)(a2 + 16);
  if (v4 == v5) {
    return 1;
  }
  uint64_t v7 = a3;
  BOOL v10 = a4 == 0;
  BOOL v31 = v10;
  do
  {
    uint64_t v11 = 0;
    do
      uint64_t v12 = v11;
    while (v4[v11++]);
    std::string::size_type v14 = &v4[v11];
    if (&v4[v11] == v5) {
      return 0;
    }
    if (v4)
    {
      size_t v15 = strlen(v4);
      BOOL v10 = a4 == v15;
      if (a4)
      {
        if (a4 == v15) {
          BOOL v10 = memcmp(v7, v4, a4) == 0;
        }
      }
    }
    if (v5 - v4 - v11 < 8) {
      return 0;
    }
    unint64_t v16 = ~(unint64_t)&v4[v12];
    uint64_t v17 = (unint64_t *)&v4[v11];
    while (1)
    {
      unint64_t v19 = *v17++;
      unint64_t v18 = v19;
      if (v19 == -1 || !v10) {
        break;
      }
      if (v18 >= *((unsigned int *)a1 + 16))
      {
        int v23 = a1[8] & 0x3F;
        uint64_t v24 = *((unsigned int *)a1 + 2);
        if (v23) {
          *(void *)(*a1 + 8 * v24 - 8) &= ~(-1 << v23);
        }
        unsigned int v25 = v24;
        LOBYTE(v26) = v18 + 1;
        *((_DWORD *)a1 + 16) = v18 + 1;
        unsigned int v27 = v18 + 64;
        if (v24 != (v18 + 64) >> 6)
        {
          uint64_t v28 = v27 >> 6;
          if (v24 > v28)
          {
            *((_DWORD *)a1 + 2) = v28;
            unsigned int v25 = v27 >> 6;
          }
          else
          {
            if (v28 > *((_DWORD *)a1 + 3)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            if (v28 != v24) {
              bzero((void *)(*a1 + 8 * v24), 8 * (v28 - v24));
            }
            unsigned int v25 = v28;
            *((_DWORD *)a1 + 2) = v28;
            int v26 = *((_DWORD *)a1 + 16);
          }
        }
        uint64_t v21 = *a1;
        int v29 = v26 & 0x3F;
        if (v29) {
          *(void *)(v21 + 8 * v25 - 8) &= ~(-1 << v29);
        }
      }
      else
      {
        uint64_t v21 = *a1;
      }
      uint64_t result = 1;
      *(void *)(v21 + 8 * (v18 >> 6)) |= 1 << v18;
      unint64_t v5 = *(const char **)(a2 + 16);
      if (v17 == (unint64_t *)v5) {
        return result;
      }
LABEL_35:
      v16 -= 8;
      std::string::size_type v14 = (const char *)v17;
      if ((uint64_t)&v5[v16] < 8) {
        return 0;
      }
    }
    if (v18 != -1 && v17 != (unint64_t *)v5) {
      goto LABEL_35;
    }
    uint64_t v4 = v14 + 8;
    uint64_t result = 1;
    uint64_t v7 = a3;
    BOOL v10 = v31;
  }
  while (v14 + 8 != v5);
  return result;
}

uint64_t llvm::CodeGenCoverage::emit(llvm *a1, uint64_t a2, uint64_t a3)
{
  if (a3 && *((_DWORD *)a1 + 16))
  {
    if (llvm::llvm_is_multithreaded(a1)) {
      std::recursive_mutex::lock(&stru_1EBCFABA0);
    }
    else {
      ++dword_1EBCFABE0;
    }
    pid_t ProcessId = llvm::sys::Process::getProcessId();
    sub_1CD82C7A0((uint64_t)v15, ProcessId);
    __int16 v11 = 261;
    *(void *)uint64_t v9 = a2;
    uint64_t v10 = a3;
    __int16 v8 = 260;
    *(void *)uint64_t v7 = v15;
    sub_1CB8F1E58((uint64_t *)v9, (uint64_t *)v7, (uint64_t)&v12);
    llvm::Twine::str((llvm::Twine *)&v12, &v14);
    int v12 = 0;
    unint64_t v13 = std::system_category();
    operator new();
  }
  return 1;
}

uint64_t llvm::CodeGenCoverage::reset(uint64_t this)
{
  if ((*(_DWORD *)(this + 64) & 0x3F) != 0)
  {
    uint64_t v1 = *(unsigned int *)(this + 8);
    *(void *)(*(void *)this + 8 * v1 - 8) &= ~(-1 << (*(_DWORD *)(this + 64) & 0x3F));
  }
  else
  {
    LODWORD(v1) = *(_DWORD *)(this + 8);
  }
  *(_DWORD *)(this + 64) = 0;
  if (v1) {
    *(_DWORD *)(this + 8) = 0;
  }
  return this;
}

uint64_t sub_1CD04EE18()
{
  MEMORY[0x1D25D9910](&stru_1EBCFABA0);
  dword_1EBCFABE0 = 0;

  return __cxa_atexit((void (*)(void *))std::recursive_mutex::~recursive_mutex, &stru_1EBCFABA0, &dword_1CB82C000);
}

void *llvm::cl::basic_parser<BOOL>::basic_parser(void *result)
{
  llvm *result = &unk_1F2643938;
  return result;
}

{
  llvm *result = &unk_1F2643938;
  return result;
}

void *llvm::cl::basic_parser<llvm::cl::BOOLOrDefault>::basic_parser(void *result)
{
  llvm *result = &unk_1F2643968;
  return result;
}

{
  llvm *result = &unk_1F2643968;
  return result;
}

void *llvm::cl::basic_parser<int>::basic_parser(void *result)
{
  llvm *result = &unk_1F2643998;
  return result;
}

{
  llvm *result = &unk_1F2643998;
  return result;
}

void *llvm::cl::basic_parser<long>::basic_parser(void *result)
{
  llvm *result = &unk_1F26439C8;
  return result;
}

{
  llvm *result = &unk_1F26439C8;
  return result;
}

void *llvm::cl::basic_parser<long long>::basic_parser(void *result)
{
  llvm *result = &unk_1F26439F8;
  return result;
}

{
  llvm *result = &unk_1F26439F8;
  return result;
}

void *llvm::cl::basic_parser<unsigned int>::basic_parser(void *result)
{
  llvm *result = &unk_1F2643A28;
  return result;
}

{
  llvm *result = &unk_1F2643A28;
  return result;
}

void *llvm::cl::basic_parser<unsigned long>::basic_parser(void *result)
{
  llvm *result = &unk_1F2643A58;
  return result;
}

{
  llvm *result = &unk_1F2643A58;
  return result;
}

void *llvm::cl::basic_parser<unsigned long long>::basic_parser(void *result)
{
  llvm *result = &unk_1F2643A88;
  return result;
}

{
  llvm *result = &unk_1F2643A88;
  return result;
}

void *llvm::cl::basic_parser<double>::basic_parser(void *result)
{
  llvm *result = &unk_1F2643AB8;
  return result;
}

{
  llvm *result = &unk_1F2643AB8;
  return result;
}

void *llvm::cl::basic_parser<float>::basic_parser(void *result)
{
  llvm *result = &unk_1F2643AE8;
  return result;
}

{
  llvm *result = &unk_1F2643AE8;
  return result;
}

void *llvm::cl::basic_parser<std::string>::basic_parser(void *result)
{
  llvm *result = &unk_1F2643B18;
  return result;
}

{
  llvm *result = &unk_1F2643B18;
  return result;
}

void *llvm::cl::basic_parser<char>::basic_parser(void *result)
{
  llvm *result = &unk_1F2643B48;
  return result;
}

{
  llvm *result = &unk_1F2643B48;
  return result;
}

uint64_t llvm::cl::opt<unsigned int,false,llvm::cl::parser<unsigned int>>::setDefault(uint64_t result)
{
  int v1 = *(unsigned __int8 *)(result + 148);
  if (*(unsigned char *)(result + 148)) {
    int v1 = *(_DWORD *)(result + 144);
  }
  *(_DWORD *)(result + 128) = v1;
  return result;
}

void llvm::cl::Option::addArgument(llvm::cl::Option *this)
{
  if (!atomic_load_explicit(&qword_1EBCFABE8, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1EBCFABE8, (void *(*)(void))sub_1CD05B850, (void (*)(void *))sub_1CD05B978);
  }
  sub_1CD0502D0(qword_1EBCFABE8, (uint64_t)this, 0);
  *((_WORD *)this + 5) |= 0x4000u;
}

uint64_t llvm::cl::opt<unsigned int,false,llvm::cl::parser<unsigned int>>::setInitialValue(uint64_t result, _DWORD *a2)
{
  *(_DWORD *)(result + 128) = *a2;
  *(unsigned char *)(result + 148) = 1;
  *(_DWORD *)(result + 144) = *a2;
  return result;
}

uint64_t llvm::cl::opt<unsigned int,false,llvm::cl::parser<unsigned int>>::getParser(uint64_t a1)
{
  return a1 + 152;
}

uint64_t llvm::cl::opt<unsigned int,false,llvm::cl::parser<unsigned int>>::setCallback(uint64_t a1, void *a2)
{
  v10[3] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (void *)(a1 + 160);
  uint64_t v4 = (void *)a2[3];
  if (v4)
  {
    if (v4 == a2)
    {
      uint64_t v9 = v8;
      (*(void (**)(void *, void *))(*a2 + 24))(a2, v8);
    }
    else
    {
      uint64_t v9 = (void *)(*(uint64_t (**)(void *))(*v4 + 16))(v4);
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  if (v8 != v3)
  {
    unint64_t v5 = v9;
    uint64_t v6 = *(void **)(a1 + 184);
    if (v9 == v8)
    {
      if (v6 == v3)
      {
        (*(void (**)(void *, void *))(v8[0] + 24))(v8, v10);
        (*(void (**)(void *))(*v9 + 32))(v9);
        uint64_t v9 = 0;
        (*(void (**)(void, void *))(**(void **)(a1 + 184) + 24))(*(void *)(a1 + 184), v8);
        (*(void (**)(void))(**(void **)(a1 + 184) + 32))(*(void *)(a1 + 184));
        *(void *)(a1 + 184) = 0;
        uint64_t v9 = v8;
        (*(void (**)(void *, void *))(v10[0] + 24))(v10, v3);
        (*(void (**)(void *))(v10[0] + 32))(v10);
      }
      else
      {
        (*(void (**)(void *, void *))(v8[0] + 24))(v8, v3);
        (*(void (**)(void *))(*v9 + 32))(v9);
        uint64_t v9 = *(void **)(a1 + 184);
      }
      *(void *)(a1 + 184) = v3;
    }
    else if (v6 == v3)
    {
      (*(void (**)(void *, void *))(*(void *)(a1 + 160) + 24))(v3, v8);
      (*(void (**)(void))(**(void **)(a1 + 184) + 32))(*(void *)(a1 + 184));
      *(void *)(a1 + 184) = v9;
      uint64_t v9 = v8;
    }
    else
    {
      uint64_t v9 = *(void **)(a1 + 184);
      *(void *)(a1 + 184) = v5;
    }
  }
  uint64_t result = (uint64_t)v9;
  if (v9 == v8) {
    return (*(uint64_t (**)(void *))(v8[0] + 32))(v8);
  }
  if (v9) {
    return (*(uint64_t (**)(void))(*v9 + 40))();
  }
  return result;
}

uint64_t llvm::cl::opt<int,false,llvm::cl::parser<int>>::setDefault(uint64_t result)
{
  int v1 = *(unsigned __int8 *)(result + 148);
  if (*(unsigned char *)(result + 148)) {
    int v1 = *(_DWORD *)(result + 144);
  }
  *(_DWORD *)(result + 128) = v1;
  return result;
}

uint64_t llvm::cl::opt<int,false,llvm::cl::parser<int>>::setInitialValue(uint64_t result, _DWORD *a2)
{
  *(_DWORD *)(result + 128) = *a2;
  *(unsigned char *)(result + 148) = 1;
  *(_DWORD *)(result + 144) = *a2;
  return result;
}

uint64_t llvm::cl::opt<int,false,llvm::cl::parser<int>>::getParser(uint64_t a1)
{
  return a1 + 152;
}

void *llvm::cl::opt<int,false,llvm::cl::parser<int>>::setCallback(uint64_t a1, uint64_t a2)
{
  return sub_1CC612CC8((void *)(a1 + 160), a2);
}

uint64_t llvm::cl::opt<std::string,false,llvm::cl::parser<std::string>>::handleOccurrence(uint64_t a1, __int16 a2, int a3, int a4, void *__src, size_t __len)
{
  memset(&__p, 0, sizeof(__p));
  if (!__src)
  {
    memset(&__dst, 0, sizeof(__dst));
    goto LABEL_13;
  }
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    goto LABEL_18;
  }
  if (__len >= 0x17)
  {
    size_t v11 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v11 = __len | 7;
    }
    size_t v12 = v11 + 1;
    p_dst = (std::string *)operator new(v11 + 1);
    __dst.__r_.__value_.__l.__size_ = __len;
    __dst.__r_.__value_.__r.__words[2] = v12 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_10;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = __len;
  p_dst = &__dst;
  if (__len) {
LABEL_10:
  }
    memmove(p_dst, __src, __len);
  p_dst->__r_.__value_.__s.__data_[__len] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
LABEL_13:
  std::string __p = __dst;
  std::string::operator=((std::string *)(a1 + 128), &__p);
  *(_WORD *)(a1 + 12) = a2;
  uint64_t v13 = *(void *)(a1 + 224);
  if (!v13)
  {
    sub_1CB920400();
LABEL_18:
    abort();
  }
  (*(void (**)(uint64_t, std::string *))(*(void *)v13 + 48))(v13, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return 0;
}

void llvm::cl::opt<std::string,false,llvm::cl::parser<std::string>>::setDefault(uint64_t a1)
{
  int v2 = (std::string *)(a1 + 128);
  if (*(unsigned char *)(a1 + 184))
  {
    std::string::operator=(v2, (const std::string *)(a1 + 160));
  }
  else
  {
    memset(&__str, 0, sizeof(__str));
    std::string::operator=(v2, &__str);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
  }
}

std::string *llvm::cl::opt<std::string,false,llvm::cl::parser<std::string>>::setInitialValue(uint64_t a1, const std::string *a2)
{
  std::string::operator=((std::string *)(a1 + 128), a2);
  *(unsigned char *)(a1 + 184) = 1;

  return std::string::operator=((std::string *)(a1 + 160), a2);
}

uint64_t llvm::cl::opt<std::string,false,llvm::cl::parser<std::string>>::getParser(uint64_t a1)
{
  return a1 + 192;
}

uint64_t llvm::cl::opt<std::string,false,llvm::cl::parser<std::string>>::setCallback(uint64_t a1, uint64_t a2)
{
  v9[3] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (void *)(a1 + 200);
  sub_1CCB75D8C((uint64_t)v7, a2);
  if (v7 != v3)
  {
    uint64_t v4 = v8;
    unint64_t v5 = *(void **)(a1 + 224);
    if (v8 == v7)
    {
      if (v5 == v3)
      {
        (*(void (**)(void *, void *))(v7[0] + 24))(v7, v9);
        (*(void (**)(void *))(*v8 + 32))(v8);
        __int16 v8 = 0;
        (*(void (**)(void, void *))(**(void **)(a1 + 224) + 24))(*(void *)(a1 + 224), v7);
        (*(void (**)(void))(**(void **)(a1 + 224) + 32))(*(void *)(a1 + 224));
        *(void *)(a1 + 224) = 0;
        __int16 v8 = v7;
        (*(void (**)(void *, void *))(v9[0] + 24))(v9, v3);
        (*(void (**)(void *))(v9[0] + 32))(v9);
      }
      else
      {
        (*(void (**)(void *, void *))(v7[0] + 24))(v7, v3);
        (*(void (**)(void *))(*v8 + 32))(v8);
        __int16 v8 = *(void **)(a1 + 224);
      }
      *(void *)(a1 + 224) = v3;
    }
    else if (v5 == v3)
    {
      (*(void (**)(void *, void *))(*(void *)(a1 + 200) + 24))(v3, v7);
      (*(void (**)(void))(**(void **)(a1 + 224) + 32))(*(void *)(a1 + 224));
      *(void *)(a1 + 224) = v8;
      __int16 v8 = v7;
    }
    else
    {
      __int16 v8 = *(void **)(a1 + 224);
      *(void *)(a1 + 224) = v4;
    }
  }
  uint64_t result = (uint64_t)v8;
  if (v8 == v7) {
    return (*(uint64_t (**)(void *))(v7[0] + 32))(v7);
  }
  if (v8) {
    return (*(uint64_t (**)(void))(*v8 + 40))();
  }
  return result;
}

uint64_t llvm::cl::opt<char,false,llvm::cl::parser<char>>::handleOccurrence(uint64_t a1, __int16 a2, uint64_t a3, uint64_t a4, char *a5)
{
  char v7 = *a5;
  *(unsigned char *)(a1 + 128) = v7;
  *(_WORD *)(a1 + 12) = a2;
  uint64_t v5 = *(void *)(a1 + 184);
  if (v5)
  {
    (*(void (**)(uint64_t, char *))(*(void *)v5 + 48))(v5, &v7);
    return 0;
  }
  else
  {
    sub_1CB920400();
    return llvm::cl::opt<char,false,llvm::cl::parser<char>>::getValueExpectedFlagDefault();
  }
}

uint64_t llvm::cl::opt<char,false,llvm::cl::parser<char>>::getValueExpectedFlagDefault()
{
  return 2;
}

uint64_t llvm::cl::opt<char,false,llvm::cl::parser<char>>::getOptionWidth(uint64_t a1)
{
  return llvm::cl::basic_parser_impl::getOptionWidth(a1 + 152, a1);
}

llvm::raw_ostream *llvm::cl::opt<char,false,llvm::cl::parser<char>>::printOptionInfo(llvm::cl::Option *a1, unsigned int a2)
{
  return llvm::cl::basic_parser_impl::printOptionInfo((llvm::cl::Option *)((char *)a1 + 152), a1, a2);
}

void llvm::cl::opt<char,false,llvm::cl::parser<char>>::printOptionValue(uint64_t a1, int a2, int a3)
{
  if (a3)
  {
    LOBYTE(v3) = *(unsigned char *)(a1 + 128);
LABEL_5:
    __int16 v5 = *(_WORD *)(a1 + 144);
    uint64_t v4 = &unk_1F2644430;
    llvm::cl::parser<char>::printOptionDiff((llvm::cl::basic_parser_impl *)a1, (const llvm::cl::Option *)a1, v3, (uint64_t)&v4, a2);
    return;
  }
  if (*(unsigned char *)(a1 + 145))
  {
    int v3 = *(unsigned __int8 *)(a1 + 128);
    if (*(unsigned __int8 *)(a1 + 144) != v3) {
      goto LABEL_5;
    }
  }
}

unsigned char *llvm::cl::opt<char,false,llvm::cl::parser<char>>::setDefault(unsigned char *result)
{
  char v1 = result[145];
  if (v1) {
    char v1 = result[144];
  }
  result[128] = v1;
  return result;
}

unsigned char *llvm::cl::opt<char,false,llvm::cl::parser<char>>::setInitialValue(unsigned char *result, unsigned char *a2)
{
  result[128] = *a2;
  result[145] = 1;
  result[144] = *a2;
  return result;
}

uint64_t llvm::cl::opt<char,false,llvm::cl::parser<char>>::getParser(uint64_t a1)
{
  return a1 + 152;
}

uint64_t llvm::cl::opt<char,false,llvm::cl::parser<char>>::setCallback(uint64_t a1, void *a2)
{
  v10[3] = *MEMORY[0x1E4F143B8];
  int v3 = (void *)(a1 + 160);
  uint64_t v4 = (void *)a2[3];
  if (v4)
  {
    if (v4 == a2)
    {
      uint64_t v9 = v8;
      (*(void (**)(void *, void *))(*a2 + 24))(a2, v8);
    }
    else
    {
      uint64_t v9 = (void *)(*(uint64_t (**)(void *))(*v4 + 16))(v4);
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  if (v8 != v3)
  {
    __int16 v5 = v9;
    uint64_t v6 = *(void **)(a1 + 184);
    if (v9 == v8)
    {
      if (v6 == v3)
      {
        (*(void (**)(void *, void *))(v8[0] + 24))(v8, v10);
        (*(void (**)(void *))(*v9 + 32))(v9);
        uint64_t v9 = 0;
        (*(void (**)(void, void *))(**(void **)(a1 + 184) + 24))(*(void *)(a1 + 184), v8);
        (*(void (**)(void))(**(void **)(a1 + 184) + 32))(*(void *)(a1 + 184));
        *(void *)(a1 + 184) = 0;
        uint64_t v9 = v8;
        (*(void (**)(void *, void *))(v10[0] + 24))(v10, v3);
        (*(void (**)(void *))(v10[0] + 32))(v10);
      }
      else
      {
        (*(void (**)(void *, void *))(v8[0] + 24))(v8, v3);
        (*(void (**)(void *))(*v9 + 32))(v9);
        uint64_t v9 = *(void **)(a1 + 184);
      }
      *(void *)(a1 + 184) = v3;
    }
    else if (v6 == v3)
    {
      (*(void (**)(void *, void *))(*(void *)(a1 + 160) + 24))(v3, v8);
      (*(void (**)(void))(**(void **)(a1 + 184) + 32))(*(void *)(a1 + 184));
      *(void *)(a1 + 184) = v9;
      uint64_t v9 = v8;
    }
    else
    {
      uint64_t v9 = *(void **)(a1 + 184);
      *(void *)(a1 + 184) = v5;
    }
  }
  uint64_t result = (uint64_t)v9;
  if (v9 == v8) {
    return (*(uint64_t (**)(void *))(v8[0] + 32))(v8);
  }
  if (v9) {
    return (*(uint64_t (**)(void))(*v9 + 40))();
  }
  return result;
}

unsigned char *llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>::setDefault(unsigned char *result)
{
  char v1 = result[145];
  if (v1) {
    char v1 = result[144];
  }
  result[128] = v1;
  return result;
}

unsigned char *llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>::setInitialValue(unsigned char *result, unsigned char *a2)
{
  result[128] = *a2;
  result[145] = 1;
  result[144] = *a2;
  return result;
}

uint64_t llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>::getParser(uint64_t a1)
{
  return a1 + 152;
}

void *llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>::setCallback(uint64_t a1, uint64_t a2)
{
  return sub_1CC619354((void *)(a1 + 160), a2);
}

void llvm::cl::AddLiteralOption(uint64_t a1, unsigned __int8 *a2, size_t a3)
{
  size_t v3 = a3;
  uint64_t v4 = a2;
  uint64_t v5 = a1;
  if (!atomic_load_explicit(&qword_1EBCFABE8, memory_order_acquire))
  {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1EBCFABE8, (void *(*)(void))sub_1CD05B850, (void (*)(void *))sub_1CD05B978);
    uint64_t v5 = a1;
    uint64_t v4 = a2;
    size_t v3 = a3;
  }
  uint64_t v6 = (uint64_t *)qword_1EBCFABE8;
  unsigned int v7 = *(_DWORD *)(v5 + 108);
  if (v7 == *(_DWORD *)(v5 + 112))
  {
    if (!atomic_load_explicit(llvm::cl::TopLevelSubCommand, memory_order_acquire))
    {
      uint64_t v24 = v6;
      uint64_t v27 = v5;
      size_t v15 = v3;
      unint64_t v16 = v4;
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)llvm::cl::TopLevelSubCommand, (void *(*)(void))sub_1CD83084C, (void (*)(void *))sub_1CD8308C4);
      uint64_t v6 = v24;
      uint64_t v5 = v27;
      uint64_t v4 = v16;
      size_t v3 = v15;
    }
    uint64_t v8 = llvm::cl::TopLevelSubCommand[0];
    sub_1CD057A1C(v6, v5, v8, v4, v3);
  }
  else
  {
    int v22 = v4;
    int v23 = (uint64_t *)qword_1EBCFABE8;
    size_t v21 = v3;
    size_t v12 = *(uint64_t **)(v5 + 88);
    size_t v11 = *(uint64_t **)(v5 + 96);
    uint64_t v26 = v5;
    LODWORD(v5) = *(_DWORD *)(v5 + 104);
    if (v11 == v12) {
      uint64_t v5 = v7;
    }
    else {
      uint64_t v5 = v5;
    }
    if (v5)
    {
      uint64_t v13 = 8 * v5;
      for (uint64_t i = v11; (unint64_t)*i >= 0xFFFFFFFFFFFFFFFELL; ++i)
      {
        v13 -= 8;
        if (!v13) {
          return;
        }
      }
    }
    else
    {
      uint64_t i = v11;
    }
    uint64_t v17 = &v11[v5];
    if (i != v17)
    {
      uint64_t v18 = *i;
LABEL_20:
      sub_1CD057A1C(v23, v26, v18, v22, v21);
      unint64_t v19 = (unint64_t *)(i + 1);
      while (v19 != (unint64_t *)v17)
      {
        unint64_t v20 = *v19++;
        uint64_t v18 = v20;
        if (v20 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          uint64_t i = (uint64_t *)(v19 - 1);
          goto LABEL_20;
        }
      }
    }
  }
}

void *llvm::cl::extrahelp::extrahelp(void *a1, uint64_t a2, uint64_t a3)
{
  *a1 = a2;
  a1[1] = a3;
  if (!atomic_load_explicit(&qword_1EBCFABE8, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1EBCFABE8, (void *(*)(void))sub_1CD05B850, (void (*)(void *))sub_1CD05B978);
  }
  uint64_t v6 = (void *)qword_1EBCFABE8;
  uint64_t v8 = *(char **)(qword_1EBCFABE8 + 48);
  unint64_t v7 = *(void *)(qword_1EBCFABE8 + 56);
  if ((unint64_t)v8 >= v7)
  {
    uint64_t v10 = *(char **)(qword_1EBCFABE8 + 40);
    uint64_t v11 = (v8 - v10) >> 4;
    unint64_t v12 = v11 + 1;
    if ((unint64_t)(v11 + 1) >> 60) {
      abort();
    }
    uint64_t v13 = v7 - (void)v10;
    if (v13 >> 3 > v12) {
      unint64_t v12 = v13 >> 3;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v14 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v12;
    }
    if (v14)
    {
      if (v14 >> 60) {
        sub_1CB833614();
      }
      size_t v15 = (char *)operator new(16 * v14);
    }
    else
    {
      size_t v15 = 0;
    }
    unint64_t v16 = &v15[16 * v11];
    *(void *)unint64_t v16 = a2;
    *((void *)v16 + 1) = a3;
    uint64_t v9 = v16 + 16;
    if (v8 != v10)
    {
      do
      {
        *((_OWORD *)v16 - 1) = *((_OWORD *)v8 - 1);
        v16 -= 16;
        v8 -= 16;
      }
      while (v8 != v10);
      uint64_t v8 = (char *)v6[5];
    }
    v6[5] = v16;
    void v6[6] = v9;
    v6[7] = &v15[16 * v14];
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    *(void *)uint64_t v8 = a2;
    *((void *)v8 + 1) = a3;
    uint64_t v9 = v8 + 16;
  }
  void v6[6] = v9;
  return a1;
}

void sub_1CD0502D0(uint64_t a1, uint64_t a2, char a3)
{
  if ((a3 & 1) == 0 && (*(_WORD *)(a2 + 10) & 0x2000) != 0)
  {
    unsigned int v11 = *(_DWORD *)(a1 + 72);
    if (v11 >= *(_DWORD *)(a1 + 76)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(a1 + 64) + 8 * v11) = a2;
    ++*(_DWORD *)(a1 + 72);
  }
  else if (*(_DWORD *)(a2 + 108) == *(_DWORD *)(a2 + 112))
  {
    if (!atomic_load_explicit(llvm::cl::TopLevelSubCommand, memory_order_acquire)) {
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)llvm::cl::TopLevelSubCommand, (void *(*)(void))sub_1CD83084C, (void (*)(void *))sub_1CD8308C4);
    }
    uint64_t v5 = llvm::cl::TopLevelSubCommand[0];
    sub_1CD057DC8(a1, a2, v5);
  }
  else
  {
    uint64_t v6 = *(void *)(a2 + 96);
    uint64_t v7 = 104;
    if (v6 == *(void *)(a2 + 88)) {
      uint64_t v7 = 108;
    }
    uint64_t v8 = *(unsigned int *)(a2 + v7);
    if (v8)
    {
      uint64_t v9 = 8 * v8;
      for (uint64_t i = *(uint64_t **)(a2 + 96); (unint64_t)*i >= 0xFFFFFFFFFFFFFFFELL; ++i)
      {
        v9 -= 8;
        if (!v9) {
          return;
        }
      }
    }
    else
    {
      uint64_t i = *(uint64_t **)(a2 + 96);
    }
    unint64_t v12 = (void *)(v6 + 8 * v8);
    if (i != v12)
    {
      uint64_t v13 = *i;
LABEL_21:
      sub_1CD057DC8(a1, a2, v13);
      unint64_t v14 = (unint64_t *)(i + 1);
      while (v14 != v12)
      {
        unint64_t v15 = *v14++;
        uint64_t v13 = v15;
        if (v15 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          uint64_t i = (uint64_t *)(v14 - 1);
          goto LABEL_21;
        }
      }
    }
  }
}

uint64_t llvm::cl::Option::setArgStr(uint64_t result, unsigned __int8 *a2, size_t a3)
{
  if ((*(_WORD *)(result + 10) & 0x4000) != 0)
  {
    int v22 = a2;
    size_t v23 = a3;
    uint64_t v24 = result;
    if (!atomic_load_explicit(&qword_1EBCFABE8, memory_order_acquire)) {
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1EBCFABE8, (void *(*)(void))sub_1CD05B850, (void (*)(void *))sub_1CD05B978);
    }
    size_t v3 = (uint64_t *)qword_1EBCFABE8;
    if (*(_DWORD *)(v24 + 108) == *(_DWORD *)(v24 + 112))
    {
      if (!atomic_load_explicit(llvm::cl::TopLevelSubCommand, memory_order_acquire)) {
        llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)llvm::cl::TopLevelSubCommand, (void *(*)(void))sub_1CD83084C, (void (*)(void *))sub_1CD8308C4);
      }
      sub_1CD0585F8(v3, v24, v22, v23, llvm::cl::TopLevelSubCommand[0]);
      a2 = v22;
      a3 = v23;
      uint64_t result = v24;
    }
    else if (sub_1CD830960(v24))
    {
      uint64_t v4 = v3[35];
      uint64_t v5 = 288;
      if (v4 == v3[34]) {
        uint64_t v5 = 292;
      }
      uint64_t v6 = *(unsigned int *)((char *)v3 + v5);
      if (v6)
      {
        uint64_t v7 = 8 * v6;
        uint64_t v8 = (uint64_t *)v3[35];
        a3 = v23;
        uint64_t result = v24;
        a2 = v22;
        while ((unint64_t)*v8 >= 0xFFFFFFFFFFFFFFFELL)
        {
          ++v8;
          v7 -= 8;
          if (!v7) {
            goto LABEL_2;
          }
        }
      }
      else
      {
        uint64_t v8 = (uint64_t *)v3[35];
      }
      unint64_t v14 = (void *)(v4 + 8 * v6);
      a3 = v23;
      uint64_t result = v24;
      a2 = v22;
      if (v8 != v14)
      {
        uint64_t v15 = *v8;
LABEL_29:
        sub_1CD0585F8(v3, v24, v22, v23, v15);
        unint64_t v16 = (unint64_t *)(v8 + 1);
        while (1)
        {
          a3 = v23;
          uint64_t result = v24;
          a2 = v22;
          if (v16 == v14) {
            break;
          }
          unint64_t v17 = *v16++;
          uint64_t v15 = v17;
          if (v17 <= 0xFFFFFFFFFFFFFFFDLL)
          {
            uint64_t v8 = (uint64_t *)(v16 - 1);
            goto LABEL_29;
          }
        }
      }
    }
    else
    {
      uint64_t v9 = *(void *)(v24 + 96);
      uint64_t v10 = 104;
      if (v9 == *(void *)(v24 + 88)) {
        uint64_t v10 = 108;
      }
      uint64_t v11 = *(unsigned int *)(v24 + v10);
      if (v11)
      {
        uint64_t v12 = 8 * v11;
        uint64_t v13 = *(uint64_t **)(v24 + 96);
        a3 = v23;
        uint64_t result = v24;
        a2 = v22;
        while ((unint64_t)*v13 >= 0xFFFFFFFFFFFFFFFELL)
        {
          ++v13;
          v12 -= 8;
          if (!v12) {
            goto LABEL_2;
          }
        }
      }
      else
      {
        uint64_t v13 = *(uint64_t **)(v24 + 96);
      }
      uint64_t v18 = (void *)(v9 + 8 * v11);
      a3 = v23;
      uint64_t result = v24;
      a2 = v22;
      if (v13 != v18)
      {
        uint64_t v19 = *v13;
LABEL_36:
        sub_1CD0585F8(v3, v24, v22, v23, v19);
        unint64_t v20 = (unint64_t *)(v13 + 1);
        while (1)
        {
          a3 = v23;
          uint64_t result = v24;
          a2 = v22;
          if (v20 == v18) {
            break;
          }
          unint64_t v21 = *v20++;
          uint64_t v19 = v21;
          if (v21 <= 0xFFFFFFFFFFFFFFFDLL)
          {
            uint64_t v13 = (uint64_t *)(v20 - 1);
            goto LABEL_36;
          }
        }
      }
    }
  }
LABEL_2:
  *(void *)(result + 16) = a2;
  *(void *)(result + 24) = a3;
  if (a3 == 1) {
    *(_WORD *)(result + 10) |= 0x1000u;
  }
  return result;
}

uint64_t *llvm::cl::Option::addCategory(llvm::cl::Option *this, llvm::cl::OptionCategory *a2)
{
  GeneralCategory = llvm::cl::getGeneralCategory(this);
  if (a2 == (llvm::cl::OptionCategory *)&qword_1EBD0C040
    || (uint64_t v5 = (uint64_t *)**((void **)this + 8),
        uint64_t result = llvm::cl::getGeneralCategory((llvm::cl *)GeneralCategory),
        v5 != &qword_1EBD0C040))
  {
    uint64_t result = (uint64_t *)((char *)this + 64);
    uint64_t v7 = (llvm::cl::OptionCategory **)*((void *)this + 8);
    uint64_t v8 = *((unsigned int *)this + 18);
    uint64_t v9 = v7;
    if (v8)
    {
      uint64_t v10 = 8 * v8;
      uint64_t v9 = (llvm::cl::OptionCategory **)*((void *)this + 8);
      while (*v9 != a2)
      {
        ++v9;
        v10 -= 8;
        if (!v10)
        {
          uint64_t v9 = &v7[v8];
          break;
        }
      }
    }
    if (v8 == v9 - v7)
    {
      if (v8 >= *((_DWORD *)this + 19)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      v7[v8] = a2;
      ++*((_DWORD *)this + 18);
    }
  }
  else
  {
    **((void **)this + 8) = a2;
  }
  return result;
}

uint64_t *llvm::cl::getGeneralCategory(llvm::cl *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBD0C060, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EBD0C060))
  {
    qword_1EBD0C040 = (uint64_t)"General options";
    *(void *)algn_1EBD0C048 = 15;
    qword_1EBD0C050 = (uint64_t)&unk_1CFC27923;
    unk_1EBD0C058 = 0;
    llvm::cl::OptionCategory::registerCategory((llvm::cl::OptionCategory *)&qword_1EBD0C040);
    __cxa_guard_release(&qword_1EBD0C060);
  }
  return &qword_1EBD0C040;
}

void llvm::cl::Option::reset(llvm::cl::Option *this)
{
  *((_WORD *)this + 4) = 0;
  (*(void (**)(llvm::cl::Option *))(*(void *)this + 64))(this);
  if ((*((_WORD *)this + 5) & 0x2000) != 0)
  {
    llvm::cl::Option::removeArgument(this);
  }
}

void llvm::cl::SubCommand::registerSubCommand(llvm::cl::SubCommand *this)
{
  if (!atomic_load_explicit(&qword_1EBCFABE8, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1EBCFABE8, (void *(*)(void))sub_1CD05B850, (void (*)(void *))sub_1CD05B978);
  }
  uint64_t v2 = qword_1EBCFABE8;

  sub_1CD0508E0(v2, (uint64_t)this);
}

void sub_1CD0508E0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 280);
  uint64_t v5 = *(unsigned int *)(a1 + 292);
  if (v4 != *(void *)(a1 + 272))
  {
    unsigned int v9 = *(_DWORD *)(a1 + 288);
    goto LABEL_12;
  }
  if (!v5)
  {
LABEL_9:
    unsigned int v9 = *(_DWORD *)(a1 + 288);
    if (v5 < v9)
    {
      *(_DWORD *)(a1 + 292) = v5 + 1;
      *(void *)(v4 + 8 * v5) = a2;
      goto LABEL_33;
    }
LABEL_12:
    if (3 * v9 <= 4 * ((int)v5 - *(_DWORD *)(a1 + 296)))
    {
      if (v9 >= 0x40) {
        v9 *= 2;
      }
      else {
        unsigned int v9 = 128;
      }
    }
    else if (v9 - v5 >= v9 >> 3)
    {
      goto LABEL_14;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)(a1 + 272), v9);
    unsigned int v9 = *(_DWORD *)(a1 + 288);
    uint64_t v4 = *(void *)(a1 + 280);
LABEL_14:
    unsigned int v10 = v9 - 1;
    unsigned int v11 = (v9 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v12 = (uint64_t *)(v4 + 8 * v11);
    uint64_t v13 = *v12;
    if (*v12 == -1)
    {
      unint64_t v14 = 0;
LABEL_26:
      if (v14) {
        uint64_t v18 = v14;
      }
      else {
        uint64_t v18 = v12;
      }
      if (*v18 != a2)
      {
        if (*v18 == -2) {
          --*(_DWORD *)(a1 + 296);
        }
        else {
          ++*(_DWORD *)(a1 + 292);
        }
        *uint64_t v18 = a2;
      }
    }
    else
    {
      unint64_t v14 = 0;
      int v15 = 1;
      while (v13 != a2)
      {
        if (v14) {
          BOOL v16 = 0;
        }
        else {
          BOOL v16 = v13 == -2;
        }
        if (v16) {
          unint64_t v14 = v12;
        }
        unsigned int v17 = v11 + v15++;
        unsigned int v11 = v17 & v10;
        uint64_t v12 = (uint64_t *)(v4 + 8 * (v17 & v10));
        uint64_t v13 = *v12;
        if (*v12 == -1) {
          goto LABEL_26;
        }
      }
    }
    goto LABEL_33;
  }
  uint64_t v6 = 0;
  uint64_t v7 = 8 * v5;
  uint64_t v8 = *(uint64_t **)(a1 + 280);
  while (*v8 != a2)
  {
    if (*v8 == -2) {
      uint64_t v6 = v8;
    }
    ++v8;
    v7 -= 8;
    if (!v7)
    {
      if (!v6) {
        goto LABEL_9;
      }
      *uint64_t v6 = a2;
      --*(_DWORD *)(a1 + 296);
      break;
    }
  }
LABEL_33:
  if (!atomic_load_explicit(&llvm::cl::AllSubCommands, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&llvm::cl::AllSubCommands, (void *(*)(void))sub_1CD83084C, (void (*)(void *))sub_1CD8308C4);
  }
  if (llvm::cl::AllSubCommands != a2)
  {
    if (!atomic_load_explicit(&llvm::cl::AllSubCommands, memory_order_acquire)) {
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&llvm::cl::AllSubCommands, (void *(*)(void))sub_1CD83084C, (void (*)(void *))sub_1CD8308C4);
    }
    uint64_t v19 = *(unsigned int *)(llvm::cl::AllSubCommands + 136);
    if (v19)
    {
      for (uint64_t i = *(uint64_t **)(llvm::cl::AllSubCommands + 128); !*i || *i == -8; ++i)
        ;
    }
    else
    {
      uint64_t i = *(uint64_t **)(llvm::cl::AllSubCommands + 128);
    }
    uint64_t v22 = *(void *)(llvm::cl::AllSubCommands + 128) + 8 * v19;
    if (i != (uint64_t *)v22)
    {
      uint64_t v23 = *i;
      do
      {
        uint64_t v24 = *(void *)(v23 + 8);
        __int16 v25 = *(_WORD *)(v24 + 10);
        if ((v25 & 7) == 4
          || ((v26 = v25 & 0x180, int v27 = v25 & 0x800, v26 != 128) ? (v28 = v27 == 0) : (v28 = 0),
              !v28 || *(void *)(v24 + 24)))
        {
          sub_1CD057DC8(a1, v24, a2);
        }
        else
        {
          sub_1CD057A1C((uint64_t *)a1, v24, a2, (unsigned __int8 *)(v23 + 16), *(void *)v23);
        }
        do
        {
          uint64_t v29 = i[1];
          ++i;
          uint64_t v23 = v29;
          if (v29) {
            BOOL v30 = v23 == -8;
          }
          else {
            BOOL v30 = 1;
          }
        }
        while (v30);
      }
      while (i != (uint64_t *)v22);
    }
  }
}

void llvm::cl::SubCommand::unregisterSubCommand(llvm::cl::SubCommand *this)
{
  if (!atomic_load_explicit(&qword_1EBCFABE8, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1EBCFABE8, (void *(*)(void))sub_1CD05B850, (void (*)(void *))sub_1CD05B978);
  }
  uint64_t v2 = qword_1EBCFABE8;
  uint64_t v4 = *(void *)(qword_1EBCFABE8 + 272);
  uint64_t v3 = *(void *)(qword_1EBCFABE8 + 280);
  if (v3 == v4)
  {
    uint64_t v5 = *(unsigned int *)(qword_1EBCFABE8 + 292);
    uint64_t v6 = (llvm::cl::SubCommand **)(v3 + 8 * v5);
    if (v5)
    {
      uint64_t v7 = 0;
      uint64_t v8 = 8 * v5;
      while (*(llvm::cl::SubCommand **)(v3 + v7) != this)
      {
        v7 += 8;
        if (v8 == v7) {
          goto LABEL_21;
        }
      }
      uint64_t v6 = (llvm::cl::SubCommand **)(v3 + v7);
    }
LABEL_21:
    uint64_t v4 = *(void *)(qword_1EBCFABE8 + 280);
  }
  else
  {
    uint64_t v9 = *(unsigned int *)(qword_1EBCFABE8 + 288);
    int v10 = v9 - 1;
    unsigned int v11 = (v9 - 1) & ((this >> 4) ^ (this >> 9));
    uint64_t v6 = (llvm::cl::SubCommand **)(v3 + 8 * v11);
    uint64_t v12 = *v6;
    if (*v6 == (llvm::cl::SubCommand *)-1)
    {
      uint64_t v13 = 0;
LABEL_28:
      if (v13) {
        uint64_t v6 = v13;
      }
      if (*v6 != this) {
        uint64_t v6 = (llvm::cl::SubCommand **)(v3 + 8 * v9);
      }
    }
    else
    {
      uint64_t v13 = 0;
      int v14 = 1;
      while (v12 != this)
      {
        if (v13) {
          BOOL v15 = 0;
        }
        else {
          BOOL v15 = v12 == (llvm::cl::SubCommand *)-2;
        }
        if (v15) {
          uint64_t v13 = v6;
        }
        unsigned int v16 = v11 + v14++;
        unsigned int v11 = v16 & v10;
        uint64_t v6 = (llvm::cl::SubCommand **)(v3 + 8 * (v16 & v10));
        uint64_t v12 = *v6;
        if (*v6 == (llvm::cl::SubCommand *)-1) {
          goto LABEL_28;
        }
      }
    }
  }
  BOOL v15 = v3 == v4;
  uint64_t v17 = 288;
  if (v15) {
    uint64_t v17 = 292;
  }
  if (v6 != (llvm::cl::SubCommand **)(v3 + 8 * *(unsigned int *)(qword_1EBCFABE8 + v17)))
  {
    *uint64_t v6 = (llvm::cl::SubCommand *)-2;
    ++*(_DWORD *)(v2 + 296);
  }
}

uint64_t llvm::cl::SubCommand::reset(llvm::cl::SubCommand *this)
{
  *((_DWORD *)this + 10) = 0;
  *((_DWORD *)this + 22) = 0;
  uint64_t result = sub_1CD67F6F0((uint64_t)this + 128);
  *((void *)this + 20) = 0;
  return result;
}

BOOL llvm::cl::SubCommand::operator BOOL(uint64_t a1)
{
  if (!atomic_load_explicit(&qword_1EBCFABE8, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1EBCFABE8, (void *(*)(void))sub_1CD05B850, (void (*)(void *))sub_1CD05B978);
  }
  return *(void *)(qword_1EBCFABE8 + 336) == a1;
}

uint64_t llvm::cl::ProvidePositionalOption(uint64_t a1, char *a2, size_t a3, unsigned int a4)
{
  unsigned int v5 = a4;
  return sub_1CD050DD8((unsigned __int16 *)a1, *(void *)(a1 + 16), *(void *)(a1 + 24), a2, a3, 0, 0, &v5);
}

uint64_t sub_1CD050DD8(unsigned __int16 *a1, uint64_t a2, uint64_t a3, char *__s, size_t __n, int a6, uint64_t a7, unsigned int *a8)
{
  int v16 = a1[7];
  uint64_t result = (a1[5] >> 3) & 3;
  if (!result) {
    uint64_t result = (*(uint64_t (**)(unsigned __int16 *))(*(void *)a1 + 8))(a1);
  }
  if (result == 3)
  {
    if (!v16)
    {
      if (__s)
      {
        v30[0] = "does not allow a value! '";
        v30[2] = __s;
        v30[3] = __n;
        __int16 v31 = 1283;
        v32[0] = v30;
        v32[2] = "' specified.";
        __int16 v28 = 770;
LABEL_37:
        __int16 v33 = v28;
        uint64_t v29 = (llvm::raw_ostream *)llvm::errs((llvm *)result);
        llvm::cl::Option::error(a1, (llvm::Twine *)v32, 0, 0, v29);
        return 1;
      }
      goto LABEL_13;
    }
    int v27 = "multi-valued option specified with ValueDisallowed modifier!";
LABEL_36:
    v32[0] = v27;
    __int16 v28 = 259;
    goto LABEL_37;
  }
  if (result != 2 || __s)
  {
    if (v16) {
      goto LABEL_7;
    }
    goto LABEL_13;
  }
  uint64_t v20 = (int)*a8 + 1;
  if ((int)v20 >= a6 || (~a1[5] & 0x180) == 0)
  {
    int v27 = "requires a value!";
    goto LABEL_36;
  }
  *a8 = v20;
  __s = *(char **)(a7 + 8 * v20);
  if (__s)
  {
    uint64_t result = strlen(*(const char **)(a7 + 8 * v20));
    __n = result;
    if (v16)
    {
LABEL_7:
      if (__s)
      {
        uint64_t result = sub_1CD05885C(a1, *a8, a2, a3, __s, __n, 0);
        if (result) {
          return 1;
        }
        --v16;
        char v18 = 1;
        if (!v16) {
          return 0;
        }
        goto LABEL_23;
      }
LABEL_22:
      char v18 = 0;
LABEL_23:
      int v21 = v16 - 1;
      while (1)
      {
        int v22 = v21;
        uint64_t v23 = (int)*a8;
        uint64_t v24 = v23 + 1;
        if ((int)v23 + 1 >= a6) {
          break;
        }
        *a8 = v24;
        __int16 v25 = *(char **)(a7 + 8 * v24);
        if (v25) {
          size_t v26 = strlen(*(const char **)(a7 + 8 * v24));
        }
        else {
          size_t v26 = 0;
        }
        uint64_t result = sub_1CD05885C(a1, v24, a2, a3, v25, v26, v18 & 1);
        if ((result & 1) == 0)
        {
          int v21 = v22 - 1;
          char v18 = 1;
          if (v22) {
            continue;
          }
        }
        return result;
      }
      int v27 = "not enough values!";
      goto LABEL_36;
    }
  }
  else
  {
    if (v16) {
      goto LABEL_22;
    }
    __n = 0;
    __s = 0;
  }
LABEL_13:
  uint64_t v19 = *a8;

  return sub_1CD05885C(a1, v19, a2, a3, __s, __n, 0);
}

void sub_1CD05105C(uint64_t a1, unint64_t a2, uint64_t **a3, void (*a4)(uint64_t, unsigned char *, size_t), uint64_t a5, int a6, void (*a7)(uint64_t), uint64_t a8)
{
  v50[16] = *MEMORY[0x1E4F143B8];
  char v48 = v50;
  long long v49 = xmmword_1CFAC3020;
  if (!a2) {
    return;
  }
  int v12 = 0;
  unint64_t v13 = 0;
  unint64_t v44 = a2 - 1;
  do
  {
    if (v12 == 2)
    {
      int v21 = *(unsigned __int8 *)(a1 + v13);
      if (v21 == 92)
      {
        unint64_t v13 = sub_1CD0589C0(a1, a2, v13, &v48);
      }
      else
      {
        if (v21 == 34)
        {
          if (v13 >= v44 || *(unsigned char *)(a1 + v13 + 1) != 34) {
            goto LABEL_36;
          }
          if ((unint64_t)(v49 + 1) > *((void *)&v49 + 1)) {
            llvm::SmallVectorBase<unsigned long long>::grow_pod();
          }
          *((unsigned char *)v48 + v49) = 34;
          *(void *)&long long v49 = v49 + 1;
          int v12 = 2;
          ++v13;
          goto LABEL_37;
        }
        if ((unint64_t)(v49 + 1) > *((void *)&v49 + 1)) {
          llvm::SmallVectorBase<unsigned long long>::grow_pod();
        }
        *((unsigned char *)v48 + v49) = v21;
        size_t v22 = v49 + 1;
LABEL_29:
        *(void *)&long long v49 = v22;
      }
LABEL_31:
      int v12 = 2;
      goto LABEL_37;
    }
    if (v12 == 1)
    {
      uint64_t v16 = *(unsigned __int8 *)(a1 + v13);
      if (v16 <= 0x22)
      {
        if (((1 << v16) & 0x100002601) != 0)
        {
          char v18 = v48;
          size_t v17 = v49;
          uint64_t v19 = (unsigned char *)sub_1CB906F34(*a3, v49 + 1, 0);
          uint64_t v20 = v19;
          if (v17) {
            memcpy(v19, v18, v17);
          }
          v20[v17] = 0;
          a4(a5, v20, v17);
          *(void *)&long long v49 = 0;
          if (*(unsigned char *)(a1 + v13) != 10) {
            goto LABEL_19;
          }
LABEL_18:
          a7(a8);
LABEL_19:
          int v12 = 0;
          goto LABEL_37;
        }
        if (v16 == 34) {
          goto LABEL_31;
        }
      }
      if (v16 == 92) {
        goto LABEL_33;
      }
      if ((unint64_t)(v49 + 1) > *((void *)&v49 + 1)) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      *((unsigned char *)v48 + v49) = v16;
      *(void *)&long long v49 = v49 + 1;
LABEL_36:
      int v12 = 1;
      goto LABEL_37;
    }
    if (v13 >= a2) {
      goto LABEL_19;
    }
    unint64_t v14 = v13;
    while (1)
    {
      uint64_t v15 = *(unsigned __int8 *)(a1 + v14);
      if (v15 > 0x20) {
        break;
      }
      if (((1 << v15) & 0x100002201) == 0)
      {
        if (v15 != 10) {
          break;
        }
        a7(a8);
      }
      if (a2 == ++v14)
      {
        int v12 = 0;
        unint64_t v13 = a2;
        goto LABEL_37;
      }
    }
    unint64_t v13 = v14;
    if (v14 >= a2)
    {
      int v25 = 0;
      unint64_t v13 = v14;
    }
    else
    {
      while (1)
      {
        unsigned int v23 = *(unsigned __int8 *)(a1 + v13);
        BOOL v24 = v23 > 0x22 || ((1 << v23) & 0x500002601) == 0;
        if (!v24 || v23 == 92) {
          break;
        }
        if (++v13 >= a2)
        {
          int v25 = 0;
          unint64_t v13 = a2;
          goto LABEL_50;
        }
      }
      int v25 = 1;
    }
LABEL_50:
    if (a2 >= v14) {
      unint64_t v26 = v14;
    }
    else {
      unint64_t v26 = a2;
    }
    if (v26 <= v13) {
      unint64_t v27 = v13;
    }
    else {
      unint64_t v27 = v26;
    }
    if (a2 >= v27) {
      unint64_t v28 = v27;
    }
    else {
      unint64_t v28 = a2;
    }
    uint64_t v29 = (unsigned char *)(a1 + v26);
    if (v25)
    {
      uint64_t v30 = *(unsigned __int8 *)(a1 + v13);
      if (v30 > 0x22) {
        goto LABEL_74;
      }
      if (((1 << v30) & 0x100002601) == 0)
      {
        if (v30 == 34)
        {
          size_t v33 = v28 - v26;
          uint64_t v34 = v49;
          if (*((void *)&v49 + 1) < (unint64_t)v49 + v28 - v26) {
            llvm::SmallVectorBase<unsigned long long>::grow_pod();
          }
          if (v28 != v26)
          {
            memcpy((char *)v48 + v49, (const void *)(a1 + v26), v33);
            uint64_t v34 = v49;
          }
          size_t v22 = v34 + v33;
          goto LABEL_29;
        }
LABEL_74:
        size_t v35 = v28 - v26;
        uint64_t v36 = v49;
        if (*((void *)&v49 + 1) < (unint64_t)v49 + v28 - v26) {
          llvm::SmallVectorBase<unsigned long long>::grow_pod();
        }
        if (v28 != v26)
        {
          memcpy((char *)v48 + v49, (const void *)(a1 + v26), v35);
          uint64_t v36 = v49;
        }
        *(void *)&long long v49 = v36 + v35;
LABEL_33:
        unint64_t v13 = sub_1CD0589C0(a1, a2, v13, &v48);
        goto LABEL_36;
      }
    }
    int v42 = v25;
    size_t v31 = v28 - v26;
    if (a6)
    {
      unint64_t v41 = v28;
      tm v32 = (unsigned char *)sub_1CB906F34(*a3, v31 + 1, 0);
      uint64_t v29 = v32;
      if (v41 != v26) {
        memcpy(v32, (const void *)(a1 + v26), v31);
      }
      v29[v31] = 0;
    }
    a4(a5, v29, v31);
    int v12 = v42;
    if (v42)
    {
      if (*(unsigned char *)(a1 + v13) != 10) {
        goto LABEL_19;
      }
      goto LABEL_18;
    }
LABEL_37:
    ++v13;
  }
  while (v13 < a2);
  __int16 v37 = v48;
  if (v12 == 1)
  {
    size_t v38 = v49;
    __int16 v39 = (unsigned char *)sub_1CB906F34(*a3, v49 + 1, 0);
    char v40 = v39;
    if (v38) {
      memcpy(v39, v37, v38);
    }
    v40[v38] = 0;
    a4(a5, v40, v38);
    __int16 v37 = v48;
  }
  if (v37 != v50) {
    free(v37);
  }
}

void llvm::cl::TokenizeWindowsCommandLineNoCopy(uint64_t a1, unint64_t a2, uint64_t **a3, uint64_t a4)
{
  uint64_t v5 = a4;
  sub_1CD05105C(a1, a2, a3, (void (*)(uint64_t, unsigned char *, size_t))sub_1CD05BAE4, (uint64_t)&v5, 0, (void (*)(uint64_t))nullsub_1387, (uint64_t)&v4);
}

uint64_t llvm::cl::ExpandResponseFiles(uint64_t **a1, void (*a2)(std::string *, unint64_t, uint64_t **, uint64_t, uint64_t), unsigned int *a3, unsigned int a4, char a5, unsigned __int8 a6, uint64_t a7, uint64_t a8)
{
  uint64_t v77 = *MEMORY[0x1E4F143B8];
  unint64_t v62 = v64;
  uint64_t v63 = 0x300000000;
  HIBYTE(v60) = 0;
  LOBYTE(__p) = 0;
  v61[0] = a3[2];
  sub_1CD051CDC((uint64_t)&v62, (unint64_t)&__p);
  if (SHIBYTE(v60) < 0) {
    operator delete(__p);
  }
  if (a3[2])
  {
    uint64_t v10 = 0;
    unsigned int v11 = 0;
    uint64_t v12 = 1;
    while (1)
    {
      unint64_t v13 = v62;
      LODWORD(v14) = v63;
      if (*((void *)v62 + 4 * v63 - 1) == v10)
      {
        do
        {
          uint64_t v14 = (v14 - 1);
          LODWORD(v63) = v14;
          uint64_t v15 = (void **)&v13[4 * v14];
          if (*((char *)v15 + 23) < 0)
          {
            operator delete(*v15);
            unint64_t v13 = v62;
            uint64_t v14 = v63;
          }
        }
        while (v13[4 * v14 - 1] == v10);
      }
      uint64_t v16 = *(unsigned char **)(*(void *)a3 + 8 * v10);
      if (v16)
      {
        if (*v16 == 64) {
          break;
        }
      }
      ++v11;
LABEL_57:
      uint64_t v10 = v11;
      if (a3[2] == v11) {
        goto LABEL_89;
      }
    }
    std::string __p = v61;
    long long v60 = xmmword_1CFAC3020;
    LOWORD(v75) = 257;
    int v18 = v16[1];
    size_t v17 = v16 + 1;
    if (v18)
    {
      std::string __dst = (llvm *)v17;
      char v19 = 3;
    }
    else
    {
      char v19 = 1;
    }
    LOBYTE(v75) = v19;
    if (llvm::sys::path::is_absolute((const char **)&__dst, 0))
    {
      uint64_t v20 = v12;
    }
    else
    {
      if (*(unsigned char *)(a7 + 16))
      {
        uint64_t v21 = 0;
        unsigned int v23 = *(const void **)a7;
        size_t v22 = *(void *)(a7 + 8);
        *(void *)&long long v60 = 0;
        if (*((void *)&v60 + 1) < v22) {
          llvm::SmallVectorBase<unsigned long long>::grow_pod();
        }
        if (v22)
        {
          memcpy(__p, v23, v22);
          uint64_t v21 = v60;
        }
        *(void *)&long long v60 = v21 + v22;
      }
      else
      {
        llvm::sys::fs::current_path((uint64_t)&__p);
      }
      LOWORD(v75) = 257;
      if (*v17)
      {
        std::string __dst = (llvm *)v17;
        char v24 = 3;
      }
      else
      {
        char v24 = 1;
      }
      LOBYTE(v75) = v24;
      LOWORD(v69) = 257;
      __int16 v58 = 257;
      __int16 v56 = 257;
      llvm::sys::path::append(&__p, 0, (const char **)&__dst, (void **)&__src, (uint64_t)v57, (uint64_t)v55);
      if ((unint64_t)(v60 + 1) > *((void *)&v60 + 1)) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      uint64_t v20 = v12;
      *((unsigned char *)__p + v60) = 0;
      size_t v17 = (char *)__p;
    }
    int v25 = (char *)v62 + 32;
    uint64_t v26 = 32 * v63 - 32;
    while (v26)
    {
      LOWORD(v69) = 257;
      if (*v17)
      {
        unint64_t __src = v17;
        char v27 = 3;
      }
      else
      {
        char v27 = 1;
      }
      LOBYTE(v69) = v27;
      (*(void (**)(llvm **__return_ptr, uint64_t, void **))(*(void *)a8 + 16))(&__dst, a8, &__src);
      if (v76)
      {
        *(void *)&v28.__val_ = v72;
        llvm::errorCodeToError(__dst, v28, &__src);
        sub_1CD4515D0((void **)&__src);
        if (__src) {
          (*(void (**)(void *))(*(void *)__src + 8))(__src);
        }
        BOOL v31 = 0;
      }
      else
      {
        __int16 v58 = 260;
        v57[0] = v25;
        (*(void (**)(void **__return_ptr, uint64_t, void **))(*(void *)a8 + 16))(&__src, a8, v57);
        if (v70)
        {
          *(void *)&v29.__val_ = v66;
          llvm::errorCodeToError((llvm *)__src, v29, v57);
          sub_1CD4515D0(v57);
          if (v57[0]) {
            (*(void (**)(void *))(*v57[0] + 8))(v57[0]);
          }
          BOOL v31 = 0;
        }
        else
        {
          BOOL v31 = v74 == v68 && v75 == v69;
        }
        if ((v70 & 1) == 0 && (v67[7] & 0x80000000) != 0) {
          operator delete(__src);
        }
      }
      if ((v76 & 1) == 0 && SHIBYTE(v73) < 0) {
        operator delete(__dst);
      }
      v25 += 4;
      v26 -= 32;
      if (v31)
      {
        uint64_t v12 = 0;
        ++v11;
        goto LABEL_55;
      }
    }
    unint64_t __src = v67;
    uint64_t v66 = 0;
    if (v17) {
      size_t v32 = strlen(v17);
    }
    else {
      size_t v32 = 0;
    }
    sub_1CD051E84(&__dst, v17, v32, a1, a2, (uint64_t)&__src, a4, a5, a6, a8);
    if (__dst)
    {
      uint64_t v54 = __dst;
      std::string __dst = 0;
      sub_1CD4515D0((void **)&v54);
      if (v54) {
        (*(void (**)(llvm *))(*(void *)v54 + 8))(v54);
      }
      if (__dst) {
        (*(void (**)(llvm *))(*(void *)__dst + 8))(__dst);
      }
      uint64_t v12 = 0;
      ++v11;
LABEL_84:
      if (__src != v67) {
        free(__src);
      }
LABEL_55:
      if (__p != v61) {
        free(__p);
      }
      goto LABEL_57;
    }
    uint64_t v12 = v20;
    if (v63)
    {
      uint64_t v33 = v66 - 1;
      uint64_t v34 = 32 * v63;
      size_t v35 = (char *)v62 + 24;
      do
      {
        *v35 += v33;
        v35 += 4;
        v34 -= 32;
      }
      while (v34);
    }
    size_t v36 = strlen(v17);
    if (v36 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    size_t v37 = v36;
    if (v36 >= 0x17)
    {
      uint64_t v39 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v36 | 7) != 0x17) {
        uint64_t v39 = v36 | 7;
      }
      uint64_t v47 = v39 + 1;
      p_dst = (char *)operator new(v39 + 1);
      size_t v72 = v37;
      unint64_t v73 = v47 | 0x8000000000000000;
      std::string __dst = (llvm *)p_dst;
    }
    else
    {
      HIBYTE(v73) = v36;
      p_dst = (char *)&__dst;
      if (!v36) {
        goto LABEL_79;
      }
    }
    memmove(p_dst, v17, v37);
LABEL_79:
    p_dst[v37] = 0;
    unint64_t v74 = v66 + (unint64_t)v11;
    sub_1CD051CDC((uint64_t)&v62, (unint64_t)&__dst);
    if (SHIBYTE(v73) < 0) {
      operator delete(__dst);
    }
    uint64_t v40 = *(void *)a3;
    uint64_t v41 = *(void *)a3 + 8 * v11;
    uint64_t v42 = a3[2];
    uint64_t v43 = *(void *)a3 + 8 * v42;
    if (v43 != v41 + 8)
    {
      memmove((void *)v41, (const void *)(v41 + 8), v43 - (v41 + 8));
      LODWORD(v42) = a3[2];
      uint64_t v40 = *(void *)a3;
    }
    a3[2] = v42 - 1;
    sub_1CD82DBBC(a3, v40 + 8 * v11, (uint64_t *)__src, (uint64_t *)__src + v66);
    goto LABEL_84;
  }
  LOBYTE(v12) = 1;
LABEL_89:
  unint64_t v44 = (char *)v62;
  if (v63)
  {
    uint64_t v45 = 32 * v63;
    do
    {
      if (v44[v45 - 9] < 0) {
        operator delete(*(void **)&v44[v45 - 32]);
      }
      v45 -= 32;
    }
    while (v45);
    unint64_t v44 = (char *)v62;
  }
  if (v44 != v64) {
    free(v44);
  }
  return v12 & 1;
}

__n128 sub_1CD051CDC(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = (__n128 *)a2;
  uint64_t v4 = *(unsigned int *)(a1 + 8);
  uint64_t v5 = *(unsigned int *)(a1 + 12);
  uint64_t v6 = *(char **)a1;
  if (v4 >= v5)
  {
    unint64_t v9 = v4 + 1;
    BOOL v11 = (unint64_t)v6 <= a2 && (unint64_t)&v6[32 * v4] > a2;
    if (v11) {
      uint64_t v12 = (uint64_t)(a2 - (void)v6) >> 5;
    }
    else {
      uint64_t v12 = -1;
    }
    if (v4 == -1) {
      sub_1CD0A88F0(v9);
    }
    if (v5 == -1) {
      sub_1CD0A89A8(0xFFFFFFFFuLL);
    }
    unint64_t v13 = (2 * v5) | 1;
    if (v13 <= v9) {
      unint64_t v13 = v9;
    }
    if (v13 >= 0xFFFFFFFF) {
      uint64_t v14 = 0xFFFFFFFFLL;
    }
    else {
      uint64_t v14 = v13;
    }
    uint64_t v15 = (char *)malloc_type_malloc(32 * v14, 0x4065EBACuLL);
    if (!v15) {
      llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
    }
    uint64_t v6 = v15;
    uint64_t v16 = *(char **)a1;
    uint64_t v17 = *(unsigned int *)(a1 + 8);
    if (v17)
    {
      int v18 = &v16[32 * v17];
      char v19 = v15;
      do
      {
        long long v20 = *(_OWORD *)v16;
        *((void *)v19 + 2) = *((void *)v16 + 2);
        *(_OWORD *)char v19 = v20;
        *((void *)v16 + 1) = 0;
        *((void *)v16 + 2) = 0;
        *(void *)uint64_t v16 = 0;
        *((void *)v19 + 3) = *((void *)v16 + 3);
        v16 += 32;
        v19 += 32;
      }
      while (v16 != v18);
      uint64_t v16 = *(char **)a1;
      uint64_t v21 = *(unsigned int *)(a1 + 8);
      if (v21)
      {
        uint64_t v22 = 32 * v21;
        do
        {
          if (v16[v22 - 9] < 0) {
            operator delete(*(void **)&v16[v22 - 32]);
          }
          v22 -= 32;
        }
        while (v22);
        uint64_t v16 = *(char **)a1;
      }
    }
    if (v16 != (char *)(a1 + 16)) {
      free(v16);
    }
    *(void *)a1 = v6;
    *(_DWORD *)(a1 + 12) = v14;
    if (v11) {
      uint64_t v2 = (__n128 *)&v6[32 * v12];
    }
    uint64_t v4 = *(unsigned int *)(a1 + 8);
  }
  uint64_t v7 = (__n128 *)&v6[32 * v4];
  __n128 result = *v2;
  v7[1].n128_u64[0] = v2[1].n128_u64[0];
  *uint64_t v7 = result;
  v2->n128_u64[1] = 0;
  v2[1].n128_u64[0] = 0;
  v2->n128_u64[0] = 0;
  v7[1].n128_u64[1] = v2[1].n128_u64[1];
  ++*(_DWORD *)(a1 + 8);
  return result;
}

void sub_1CD051E84(void *a1, const char *a2, unint64_t a3, uint64_t **a4, void (*a5)(std::string *, unint64_t, uint64_t **, uint64_t, uint64_t), uint64_t a6, uint64_t a7, char a8, unsigned __int8 a9, uint64_t a10)
{
  uint64_t v15 = (unsigned __int8 *)a2;
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  __int16 v72 = 261;
  uint64_t v69 = (uint64_t)a2;
  *(void *)&long long v70 = a3;
  llvm::vfs::FileSystem::getBufferForFile(a10, (uint64_t)&v69, -1, 1, 0, 0, (uint64_t)v67);
  if (v68)
  {
    *(llvm **)&v17.__val_ = v67[1];
    llvm::errorCodeToError(v67[0], v17, a1);
    goto LABEL_78;
  }
  p_p = (std::string *)*((void *)v67[0] + 1);
  unint64_t size = *((void *)v67[0] + 2) - (void)p_p;
  memset(&__p, 0, sizeof(__p));
  if (size >= 2)
  {
    int v20 = p_p->__r_.__value_.__s.__data_[0];
    if (v20 == 255)
    {
      int v21 = 254;
    }
    else
    {
      if (v20 != 254) {
        goto LABEL_16;
      }
      int v21 = 255;
    }
    if (p_p->__r_.__value_.__s.__data_[1] == v21)
    {
      if (!llvm::convertUTF16ToUTF8String((char *)p_p, size, &__p))
      {
        unint64_t v52 = std::generic_category();
        uint64_t v69 = 92;
        *(void *)&long long v70 = v52;
        uint64_t v63 = "Could not convert UTF16 to UTF8";
        sub_1CD06481C();
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        unint64_t size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
      }
      else {
        unint64_t size = __p.__r_.__value_.__l.__size_;
      }
      goto LABEL_22;
    }
LABEL_16:
    if (size < 3)
    {
      unint64_t size = 2;
    }
    else if (v20 == 239 {
           && p_p->__r_.__value_.__s.__data_[1] == 187
    }
           && p_p->__r_.__value_.__s.__data_[2] == 191)
    {
      p_p = (std::string *)((char *)p_p + 3);
      size -= 3;
    }
  }
LABEL_22:
  a5(p_p, size, a4, a6, a7);
  if (a8)
  {
    unint64_t v22 = sub_1CD0E3AC0(v15, a3, 0);
    uint64_t v23 = *(unsigned int *)(a6 + 8);
    if (v23)
    {
      int v24 = a9;
      int v25 = *(const char ***)a6;
      uint64_t v26 = &v25[v23];
      if (a3 >= v22) {
        size_t v27 = v22;
      }
      else {
        size_t v27 = a3;
      }
      if (v22 == -1)
      {
        uint64_t v15 = 0;
        size_t v28 = 0;
      }
      else
      {
        size_t v28 = v27;
      }
      unint64_t v53 = a1;
      uint64_t v54 = v26;
      do
      {
        std::error_code v29 = *v25;
        if (*v25)
        {
          if (v24)
          {
            v66[0] = (uint64_t)*v25;
            size_t v30 = strlen(v29);
            v66[1] = v30;
            uint64_t v69 = (uint64_t)&v71;
            long long v70 = xmmword_1CFAC3020;
            uint64_t v31 = llvm::StringRef::find(v66, "<CFGDIR>", 8uLL, 0);
            if (v31 != -1)
            {
              uint64_t v32 = v31;
              size_t v33 = 0;
              size_t v34 = 0;
              do
              {
                if (v30 >= v34) {
                  size_t v35 = v34;
                }
                else {
                  size_t v35 = v30;
                }
                size_t v36 = &v29[v35];
                size_t v37 = v30 - v35;
                if (v37 >= v32 - v34) {
                  size_t v38 = v32 - v34;
                }
                else {
                  size_t v38 = v37;
                }
                if (v33)
                {
                  __int16 v65 = 261;
                  uint64_t v63 = v36;
                  size_t v64 = v38;
                  __int16 v62 = 257;
                  __int16 v60 = 257;
                  __int16 v58 = 257;
                  llvm::sys::path::append(&v69, 0, &v63, v61, (uint64_t)v59, (uint64_t)v57);
                  size_t v39 = v70;
                }
                else
                {
                  *(void *)&long long v70 = 0;
                  if (*((void *)&v70 + 1) < v38) {
                    llvm::SmallVectorBase<unsigned long long>::grow_pod();
                  }
                  uint64_t v40 = 0;
                  if (v38)
                  {
                    memcpy((void *)v69, v36, v38);
                    uint64_t v40 = v70;
                  }
                  size_t v39 = v40 + v38;
                  *(void *)&long long v70 = v40 + v38;
                }
                if (*((void *)&v70 + 1) < v39 + v28) {
                  llvm::SmallVectorBase<unsigned long long>::grow_pod();
                }
                if (v28)
                {
                  memcpy((void *)(v69 + v39), v15, v28);
                  size_t v39 = v70;
                }
                size_t v33 = v39 + v28;
                *(void *)&long long v70 = v39 + v28;
                size_t v34 = v32 + 8;
                uint64_t v32 = llvm::StringRef::find(v66, "<CFGDIR>", 8uLL, v32 + 8);
              }
              while (v32 != -1);
              if (v33)
              {
                if (v30 > v34)
                {
                  __int16 v65 = 261;
                  uint64_t v63 = &v29[v34];
                  size_t v64 = v30 - v34;
                  __int16 v62 = 257;
                  __int16 v60 = 257;
                  __int16 v58 = 257;
                  llvm::sys::path::append(&v69, 0, &v63, v61, (uint64_t)v59, (uint64_t)v57);
                  size_t v33 = v70;
                }
                uint64_t v41 = (const void *)v69;
                uint64_t v42 = (char *)sub_1CB906F34(*a4, v33 + 1, 0);
                uint64_t v43 = v42;
                if (v33) {
                  memcpy(v42, v41, v33);
                }
                v43[v33] = 0;
                *int v25 = v43;
              }
            }
            if ((char *)v69 != &v71) {
              free((void *)v69);
            }
            std::error_code v29 = *v25;
            a1 = v53;
            uint64_t v26 = v54;
            int v24 = a9;
          }
          if (*v29 == 64)
          {
            unint64_t v44 = v29 + 1;
            size_t v45 = strlen(v29 + 1);
            __int16 v72 = 261;
            uint64_t v69 = (uint64_t)v44;
            *(void *)&long long v70 = v45;
            if ((llvm::sys::path::is_absolute((const char **)&v69, 0) & 1) == 0)
            {
              uint64_t v69 = (uint64_t)&v71;
              char v71 = 64;
              long long v70 = xmmword_1CFAC7A00;
              if (v28 + 1 >= 0x81) {
                llvm::SmallVectorBase<unsigned long long>::grow_pod();
              }
              uint64_t v46 = 1;
              if (v28)
              {
                memcpy((void *)(v69 + 1), v15, v28);
                uint64_t v46 = v70;
              }
              *(void *)&long long v70 = v46 + v28;
              __int16 v65 = 261;
              uint64_t v63 = v44;
              size_t v64 = v45;
              __int16 v62 = 257;
              __int16 v60 = 257;
              __int16 v58 = 257;
              llvm::sys::path::append(&v69, 0, &v63, v61, (uint64_t)v59, (uint64_t)v57);
              char v48 = (const void *)v69;
              size_t v47 = v70;
              long long v49 = (char *)sub_1CB906F34(*a4, v70 + 1, 0);
              long long v50 = v49;
              if (v47) {
                memcpy(v49, v48, v47);
              }
              v50[v47] = 0;
              *int v25 = v50;
              if ((char *)v69 != &v71) {
                free((void *)v69);
              }
              uint64_t v26 = v54;
            }
          }
        }
        ++v25;
      }
      while (v25 != v26);
    }
  }
  *a1 = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
LABEL_78:
  if ((v68 & 1) == 0)
  {
    long long v51 = v67[0];
    v67[0] = 0;
    if (v51) {
      (*(void (**)(llvm *))(*(void *)v51 + 8))(v51);
    }
  }
}

uint64_t llvm::cl::expandResponseFiles(int a1, uint64_t a2, const char *a3, uint64_t **a4, unsigned int *a5)
{
  llvm::sys::getProcessTriple((uint64_t)v17);
  __int16 v20 = 260;
  char v19 = v17;
  llvm::Triple::Triple((llvm::Triple *)&__p, (const llvm::Twine *)&v19);
  if (v23 == 15) {
    uint64_t v10 = (void (*)(std::string *, unint64_t, uint64_t **, uint64_t, uint64_t))llvm::cl::TokenizeWindowsCommandLine;
  }
  else {
    uint64_t v10 = (void (*)(std::string *, unint64_t, uint64_t **, uint64_t, uint64_t))llvm::cl::TokenizeGNUCommandLine;
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v18 < 0) {
    operator delete(v17[0]);
  }
  if (a3)
  {
    std::string::size_type v11 = strlen(a3);
    llvm::sys::Process::GetEnv(a3, v11, &__p);
    if (v22)
    {
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
      }
      else {
        std::string::size_type size = __p.__r_.__value_.__l.__size_;
      }
      v10(p_p, size, a4, (uint64_t)a5, 0);
      if (v22 && SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
  }
  sub_1CB935BDC(a5, (unsigned char *)(a2 + 8), (unsigned char *)(a2 + 8 * a1));
  LOBYTE(v15) = 0;
  char v16 = 0;
  return llvm::cl::ExpandResponseFiles(a4, v10, a5, 0, 0, 0, &v15);
}

BOOL llvm::cl::ParseCommandLineOptions(llvm *a1, void *a2, uint64_t a3, uint64_t a4, llvm::raw_ostream *a5, const char *a6, int a7)
{
  int v12 = (int)a1;
  uint64_t v322 = *MEMORY[0x1E4F143B8];
  sub_1CD054360(a1);
  v302 = v304;
  v295[0] = 0;
  v295[1] = 0;
  v296 = v298;
  uint64_t v297 = 0x400000000;
  v299 = v301;
  uint64_t v300 = 0;
  unsigned int v13 = 1;
  v301[0] = 0;
  v301[1] = 1;
  v274 = v295;
  v304[0] = *a2;
  uint64_t v303 = 0x1400000001;
  if (a6)
  {
    std::string::size_type v14 = strlen(a6);
    llvm::sys::Process::GetEnv(a6, v14, &__p);
    if ((_BYTE)__len)
    {
      long long v15 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &__p
          : (std::string *)__p.__r_.__value_.__r.__words[0];
      unint64_t v16 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F
          : __p.__r_.__value_.__l.__size_;
      llvm::cl::TokenizeGNUCommandLine((uint64_t)v15, v16, &v274, (uint64_t)&v302, 0);
      if ((_BYTE)__len)
      {
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
      }
    }
    unsigned int v13 = v303;
  }
  if (v12 >= 2)
  {
    uint64_t v17 = v12 - 1;
    char v18 = a2 + 1;
    do
    {
      if (v13 >= HIDWORD(v303)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v302 + v13) = *v18;
      unsigned int v13 = v303 + 1;
      LODWORD(v303) = v303 + 1;
      ++v18;
      --v17;
    }
    while (v17);
  }
  char v19 = &qword_1EBCFABE8;
  if (!atomic_load_explicit(&qword_1EBCFABE8, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1EBCFABE8, (void *(*)(void))sub_1CD05B850, (void (*)(void *))sub_1CD05B978);
  }
  __int16 v20 = &byte_1EBCFA000;
  uint64_t v265 = qword_1EBCFABE8;
  v315 = v317;
  uint64_t v316 = 0x1400000000;
  sub_1CB935BDC((unsigned int *)&v315, v302, (unsigned char *)v302 + 8 * (int)v13);
  v308[1] = 0;
  v308[0] = 0;
  v309 = v311;
  uint64_t v310 = 0x400000000;
  v312 = v314;
  uint64_t v313 = 0;
  v314[0] = 0;
  v314[1] = 1;
  v284 = v308;
  llvm::sys::getProcessTriple((uint64_t)__dst);
  v307[8] = 260;
  v305 = __dst;
  llvm::Triple::Triple((llvm::Triple *)&__p, (const llvm::Twine *)&v305);
  if (HIDWORD(v320) == 15) {
    int v21 = (void (*)(std::string *, unint64_t, uint64_t **, uint64_t, uint64_t))llvm::cl::TokenizeWindowsCommandLine;
  }
  else {
    int v21 = (void (*)(std::string *, unint64_t, uint64_t **, uint64_t, uint64_t))llvm::cl::TokenizeGNUCommandLine;
  }
  LOBYTE(v282) = 0;
  char v283 = 0;
  llvm::cl::ExpandResponseFiles(&v284, v21, (unsigned int *)&v315, 0, 0, 0, &v282);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v288) < 0) {
    operator delete(__dst[0]);
  }
  int v269 = v316;
  v266 = v315;
  char v22 = *(const char **)v315;
  if (*(void *)v315) {
    size_t v23 = strlen(*(const char **)v315);
  }
  else {
    size_t v23 = 0;
  }
  size_t __len = 0;
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v22;
  *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = v23;
  size_t v320 = v23;
  int v321 = 0;
  unint64_t v24 = llvm::sys::path::reverse_iterator::operator++((uint64_t)&__p);
  std::string::size_type v25 = __len;
  if (__len > 0x7FFFFFFFFFFFFFF7) {
LABEL_472:
  }
    abort();
  uint64_t v26 = (const void *)__p.__r_.__value_.__r.__words[2];
  if (__len >= 0x17)
  {
    size_t v28 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v28 = __len | 7;
    }
    size_t v29 = v28 + 1;
    p_p = (std::string *)operator new(v28 + 1);
    __p.__r_.__value_.__r.__words[2] = v29 | 0x8000000000000000;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)p_p;
    __p.__r_.__value_.__l.__size_ = v25;
    goto LABEL_38;
  }
  *((unsigned char *)&__p.__r_.__value_.__s + 23) = __len;
  p_p = &__p;
  if (__len) {
LABEL_38:
  }
    unint64_t v24 = (unint64_t)memmove(p_p, v26, v25);
  p_p->__r_.__value_.__s.__data_[v25] = 0;
  if (*(char *)(v265 + 23) < 0) {
    operator delete(*(void **)v265);
  }
  *(std::string *)uint64_t v265 = __p;
  *(void *)(v265 + 24) = a3;
  *(void *)(v265 + 32) = a4;
  v262 = a5;
  if (!a5)
  {
    unint64_t v24 = (unint64_t)llvm::errs((llvm *)v24);
    v262 = (llvm::raw_ostream *)v24;
  }
  int v259 = a7;
  if (!atomic_load_explicit(llvm::cl::TopLevelSubCommand, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)llvm::cl::TopLevelSubCommand, (void *(*)(void))sub_1CD83084C, (void (*)(void *))sub_1CD8308C4);
  }
  uint64_t v30 = llvm::cl::TopLevelSubCommand[0];
  if (v269 >= 2)
  {
    uint64_t v31 = (unsigned char *)*((void *)v266 + 1);
    if (*v31 != 45)
    {
      unint64_t v24 = strlen(*((const char **)v266 + 1));
      if (v24)
      {
        size_t v33 = v24;
        uint64_t v34 = *(void *)(v265 + 280);
        uint64_t v35 = 288;
        if (v34 == *(void *)(v265 + 272)) {
          uint64_t v35 = 292;
        }
        uint64_t v36 = *(unsigned int *)(v265 + v35);
        if (v36)
        {
          uint64_t v37 = 8 * v36;
          size_t v38 = *(uint64_t **)(v265 + 280);
          while ((unint64_t)*v38 >= 0xFFFFFFFFFFFFFFFELL)
          {
            ++v38;
            v37 -= 8;
            if (!v37) {
              goto LABEL_72;
            }
          }
        }
        else
        {
          size_t v38 = *(uint64_t **)(v265 + 280);
        }
        size_t v39 = (void *)(v34 + 8 * v36);
        if (v38 != v39)
        {
          uint64_t v30 = *v38;
          uint64_t v40 = (llvm::ManagedStaticBase *)&llvm::cl::AllSubCommands;
LABEL_59:
          if (!atomic_load_explicit((atomic_ullong *volatile)v40, memory_order_acquire))
          {
            uint64_t v41 = v19;
            uint64_t v42 = v40;
            llvm::ManagedStaticBase::RegisterManagedStatic(v40, (void *(*)(void))sub_1CD83084C, (void (*)(void *))sub_1CD8308C4);
            uint64_t v40 = v42;
            char v19 = v41;
            __int16 v20 = &byte_1EBCFA000;
          }
          if (v30 != llvm::cl::AllSubCommands)
          {
            uint64_t v43 = *(void *)(v30 + 8);
            if (v43 && v43 == v33)
            {
              size_t v45 = v19;
              uint64_t v46 = v40;
              unint64_t v24 = memcmp(*(const void **)v30, v31, v33);
              uint64_t v40 = v46;
              char v19 = v45;
              __int16 v20 = &byte_1EBCFA000;
              if (!v24) {
                goto LABEL_75;
              }
            }
          }
          size_t v47 = (unint64_t *)(v38 + 1);
          while (v47 != v39)
          {
            unint64_t v48 = *v47++;
            uint64_t v30 = v48;
            if (v48 <= 0xFFFFFFFFFFFFFFFDLL)
            {
              size_t v38 = (uint64_t *)(v47 - 1);
              goto LABEL_59;
            }
          }
        }
      }
LABEL_72:
      if (!atomic_load_explicit(llvm::cl::TopLevelSubCommand, memory_order_acquire)) {
        llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)llvm::cl::TopLevelSubCommand, (void *(*)(void))sub_1CD83084C, (void (*)(void *))sub_1CD8308C4);
      }
      uint64_t v30 = llvm::cl::TopLevelSubCommand[0];
LABEL_75:
      if (!atomic_load_explicit(llvm::cl::TopLevelSubCommand, memory_order_acquire)) {
        llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)llvm::cl::TopLevelSubCommand, (void *(*)(void))sub_1CD83084C, (void (*)(void *))sub_1CD8308C4);
      }
      if (v30 == llvm::cl::TopLevelSubCommand[0]) {
        uint64_t v32 = 1;
      }
      else {
        uint64_t v32 = 2;
      }
      goto LABEL_80;
    }
  }
  uint64_t v32 = 1;
LABEL_80:
  uint64_t v49 = v265;
  if (!atomic_load_explicit(v19, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1EBCFABE8, (void *(*)(void))sub_1CD05B850, (void (*)(void *))sub_1CD05B978);
  }
  *(void *)(*((void *)v20 + 381) + 336) = v30;
  uint64_t v50 = *(unsigned int *)(v265 + 72);
  long long v51 = v262;
  if (v50)
  {
    unint64_t v52 = *(uint64_t **)(v265 + 64);
    uint64_t v53 = 8 * v50;
    do
    {
      uint64_t v54 = *v52++;
      sub_1CD0502D0(v265, v54, 1);
      v53 -= 8;
    }
    while (v53);
  }
  uint64_t v55 = *(unsigned int *)(v30 + 40);
  uint64_t v273 = v30;
  if (!v55)
  {
    int v270 = 0;
    char v257 = 0;
    unsigned int v272 = 0;
    uint64_t v75 = (const char **)v266;
    goto LABEL_125;
  }
  uint64_t v56 = 0;
  unsigned int v272 = 0;
  char v57 = 0;
  int v270 = 0;
  uint64_t v58 = 8 * v55;
  uint64_t v59 = a5;
  do
  {
    uint64_t v60 = v30;
    uint64_t v61 = *(void *)(*(void *)(v30 + 32) + v56);
    if ((*(_WORD *)(v61 + 10) & 6) == 2)
    {
      ++v272;
      goto LABEL_116;
    }
    if (*(void *)(v60 + 160))
    {
      int v62 = v270;
      if (*(_DWORD *)(v60 + 40) >= 2u) {
        int v62 = 1;
      }
      int v270 = v62;
      if (!v59 && *(_DWORD *)(v60 + 40) >= 2u)
      {
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)"error - this positional option will never be matched,"
                                                                   " because it does not Require a value, and a cl::Consu"
                                                                   "meAfter option is active!";
        LOWORD(v320) = 259;
        uint64_t v63 = (llvm::raw_ostream *)llvm::errs((llvm *)v24);
        unint64_t v24 = llvm::cl::Option::error((void *)v61, (llvm::Twine *)&__p, 0, 0, v63);
LABEL_115:
        int v270 = 1;
      }
    }
    else if ((v57 & 1) != 0 && !*(void *)(v61 + 24))
    {
      if (!v59)
      {
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)"error - option can never match, because another posit"
                                                                   "ional argument will match an unbounded number of valu"
                                                                   "es, and this option does not require a value!";
        LOWORD(v320) = 259;
        unint64_t v74 = (llvm::raw_ostream *)llvm::errs((llvm *)v24);
        llvm::cl::Option::error((void *)v61, (llvm::Twine *)&__p, 0, 0, v74);
      }
      char v64 = *(unsigned char *)(v265 + 23);
      BOOL v65 = v64 < 0;
      if (v64 >= 0) {
        uint64_t v66 = (const char *)v265;
      }
      else {
        uint64_t v66 = *(const char **)v265;
      }
      size_t v67 = v64 & 0x7F;
      if (v65) {
        size_t v68 = *(void *)(v265 + 8);
      }
      else {
        size_t v68 = v67;
      }
      uint64_t v69 = v262;
      llvm::raw_ostream::write(v262, v66, v68);
      long long v70 = (void *)*((void *)v262 + 4);
      if (*((void *)v262 + 3) - (void)v70 > 0x1CuLL)
      {
        qmemcpy(v70, ": CommandLine Error: Option '", 29);
        char v71 = (_DWORD *)(*((void *)v262 + 4) + 29);
        *((void *)v262 + 4) = v71;
      }
      else
      {
        llvm::raw_ostream::write(v262, ": CommandLine Error: Option '", 0x1DuLL);
        char v71 = (_DWORD *)*((void *)v262 + 4);
      }
      __int16 v72 = *(const void **)(v61 + 16);
      unint64_t v73 = *(void *)(v61 + 24);
      if (v73 <= *((void *)v262 + 3) - (void)v71)
      {
        if (v73)
        {
          memcpy(v71, v72, *(void *)(v61 + 24));
          uint64_t v69 = v262;
          char v71 = (_DWORD *)(*((void *)v262 + 4) + v73);
          *((void *)v262 + 4) = v71;
        }
        else
        {
          uint64_t v69 = v262;
        }
      }
      else
      {
        llvm::raw_ostream::write(v262, (const char *)v72, *(void *)(v61 + 24));
        char v71 = (_DWORD *)*((void *)v262 + 4);
      }
      uint64_t v59 = a5;
      if (*((void *)v69 + 3) - (void)v71 > 0x13uLL)
      {
        v71[4] = 169963637;
        *(_OWORD *)char v71 = *(_OWORD *)"' is all messed up!\n";
        *((void *)v69 + 4) += 20;
      }
      else
      {
        llvm::raw_ostream::write(v69, "' is all messed up!\n", 0x14uLL);
      }
      unint64_t v24 = (unint64_t)sub_1CD098D14(v69, *(unsigned int *)(v273 + 40), 0, 0, 0);
      goto LABEL_115;
    }
LABEL_116:
    v57 |= (*(_WORD *)(v61 + 10) & 5) == 1;
    v56 += 8;
    uint64_t v30 = v273;
  }
  while (v58 != v56);
  long long v51 = v262;
  uint64_t v75 = (const char **)v266;
  BOOL v76 = (v57 & 1) != 0 || *(void *)(v273 + 160) != 0;
  char v257 = v76;
  uint64_t v49 = v265;
LABEL_125:
  v305 = v307;
  uint64_t v306 = 0x400000000;
  int v281 = v32;
  if ((int)v32 >= v269)
  {
    unsigned int v176 = 0;
    goto LABEL_338;
  }
  unint64_t v77 = 0;
  char v267 = 0;
  v258 = (uint64_t *)(v30 + 128);
  v253 = v75 + 1;
  while (2)
  {
    v279[0] = 0;
    v279[1] = 0;
    int64_t v280 = 0;
    v277 = 0;
    v278 = 0;
    __s1 = &unk_1CFC27923;
    size_t __n = 0;
    uint64_t v78 = (int)v32;
    unint64_t v79 = (char *)v75[(int)v32];
    if (*v79 != 45 || (int v80 = v79[1], (v79[1] == 0) | v267 & 1))
    {
      if (v77)
      {
        size_t v81 = strlen(v75[(int)v32]);
        LODWORD(__p.__r_.__value_.__l.__data_) = v32;
        unint64_t v24 = sub_1CD050DD8((unsigned __int16 *)v77, *(void *)(v77 + 16), *(void *)(v77 + 24), v79, v81, 0, 0, (unsigned int *)&__p);
        goto LABEL_131;
      }
      if (!*(_DWORD *)(v30 + 40))
      {
        uint64_t v83 = 0;
        goto LABEL_134;
      }
      std::string::size_type v132 = strlen(v75[(int)v32]);
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v75[(int)v32];
      __p.__r_.__value_.__l.__size_ = v132;
      LODWORD(__p.__r_.__value_.__r.__words[2]) = v32;
      unint64_t v24 = sub_1CBA0E760((uint64_t)&v305, (unint64_t)&__p, 1);
      v133 = (char *)v305 + 24 * v306;
      long long v134 = *(_OWORD *)v24;
      *((void *)v133 + 2) = *(void *)(v24 + 16);
      *(_OWORD *)v133 = v134;
      LODWORD(v306) = v306 + 1;
      if (v306 >= v272 && *(void *)(v30 + 160))
      {
        int v135 = v32 + 1;
        if ((int)v32 + 1 < v269)
        {
          v136 = &v253[(int)v32];
          do
          {
            if (*v136) {
              std::string::size_type v137 = strlen(*v136);
            }
            else {
              std::string::size_type v137 = 0;
            }
            __p.__r_.__value_.__r.__words[0] = (std::string::size_type)*v136;
            __p.__r_.__value_.__l.__size_ = v137;
            LODWORD(__p.__r_.__value_.__r.__words[2]) = v135;
            unint64_t v24 = sub_1CBA0E760((uint64_t)&v305, (unint64_t)&__p, 1);
            v138 = (char *)v305 + 24 * v306;
            long long v139 = *(_OWORD *)v24;
            *((void *)v138 + 2) = *(void *)(v24 + 16);
            *(_OWORD *)v138 = v139;
            LODWORD(v306) = v306 + 1;
            ++v135;
            ++v136;
          }
          while (v269 != v135);
          int v135 = v269;
        }
        unint64_t v77 = 0;
        int v281 = v135;
        int v82 = 7;
        goto LABEL_207;
      }
      unint64_t v77 = 0;
LABEL_131:
      int v82 = 9;
      goto LABEL_207;
    }
    if (v80 == 45 && !v79[2])
    {
      char v267 = 1;
      goto LABEL_131;
    }
    if (v77 && (*(_WORD *)(v77 + 10) & 0x400) != 0)
    {
      size_t v117 = strlen(v79 + 1);
      __s1 = v79 + 1;
      size_t __n = v117;
      BOOL v118 = v80 != 45 || v117 == 0;
      char v119 = v118;
      if (!v118)
      {
        __s1 = v79 + 2;
        size_t __n = v117 - 1;
      }
      unint64_t v24 = sub_1CD058B44(v30, (uint64_t)&__s1, &v277, v259, v119 ^ 1u);
      if (v24 && (unint64_t v94 = v24, (*(_WORD *)(v24 + 10) & 0x180) == 0x80))
      {
LABEL_156:
        if ((*(_WORD *)(v94 + 10) & 0x180) == 0x80)
        {
          int v82 = 0;
          if ((*(_WORD *)(v94 + 10) & 0x400) != 0 && v278)
          {
            __p.__r_.__value_.__r.__words[0] = (std::string::size_type)"This argument does not take a value.\n"
                                                                       "\tInstead, it consumes any positional arguments u"
                                                                       "ntil the next recognized option.";
            LOWORD(v320) = 259;
            unint64_t v24 = llvm::cl::Option::error((void *)v94, (llvm::Twine *)&__p, 0, 0, v51);
            int v82 = 0;
            char v267 = 0;
            int v270 = 1;
          }
          else
          {
            char v267 = 0;
          }
          unint64_t v77 = v94;
        }
        else
        {
          unint64_t v24 = sub_1CD050DD8((unsigned __int16 *)v94, (uint64_t)__s1, __n, v277, (size_t)v278, v269, (uint64_t)v75, (unsigned int *)&v281);
          int v82 = 0;
          char v267 = 0;
          v270 |= v24;
        }
      }
      else
      {
        size_t v120 = strlen(v79);
        LODWORD(__p.__r_.__value_.__l.__data_) = v32;
        unint64_t v24 = sub_1CD050DD8((unsigned __int16 *)v77, *(void *)(v77 + 16), *(void *)(v77 + 24), v79, v120, 0, 0, (unsigned int *)&__p);
        char v267 = 0;
        int v82 = 9;
      }
      uint64_t v30 = v273;
      goto LABEL_207;
    }
    size_t v90 = strlen(v79 + 1);
    __s1 = v79 + 1;
    size_t __n = v90;
    BOOL v91 = v80 != 45 || v90 == 0;
    char v92 = v91;
    if (!v91)
    {
      __s1 = v79 + 2;
      size_t __n = v90 - 1;
    }
    char v93 = v92 ^ 1;
    unint64_t v24 = sub_1CD058B44(v30, (uint64_t)&__s1, &v277, v259, v92 ^ 1u);
    if (v24)
    {
      unint64_t v94 = v24;
      goto LABEL_156;
    }
    char v121 = v93 & v259;
    unsigned int v122 = (char *)__n;
    if ((v121 & 1) != 0 || __n == 1)
    {
      v127 = (char *)__n;
      goto LABEL_235;
    }
    unint64_t v123 = v77;
    __dst[0] = 0;
    long long v124 = (char *)__s1;
    unint64_t v24 = sub_1CD058DC4((unsigned __int8 *)__s1, __n, (size_t *)__dst, (uint64_t (*)(void))sub_1CD05907C, v258);
    if (!v24)
    {
LABEL_231:
      v127 = v122;
      goto LABEL_232;
    }
    unint64_t v94 = v24;
    while (2)
    {
      v125 = v122;
      BOOL v126 = v122 >= __dst[0];
      if (v122 >= __dst[0]) {
        v122 -= (unint64_t)__dst[0];
      }
      else {
        unsigned int v122 = 0;
      }
      if (v126) {
        v127 = (char *)__dst[0];
      }
      else {
        v127 = v125;
      }
      __s1 = v124;
      size_t __n = (size_t)v127;
      if (__dst[0] >= v125)
      {
        v128 = 0;
LABEL_324:
        v277 = v128;
        v278 = v122;
        long long v51 = v262;
        unint64_t v77 = v123;
        goto LABEL_156;
      }
      v128 = &v124[(unint64_t)__dst[0]];
      unsigned int v129 = *(unsigned __int16 *)(v94 + 10);
      int v130 = (v129 >> 7) & 3;
      if (v130 == 3) {
        goto LABEL_324;
      }
      if (v130 == 2)
      {
        if (*v128 == 61)
        {
LABEL_323:
          ++v128;
          --v122;
        }
        goto LABEL_324;
      }
      if (*v128 == 61) {
        goto LABEL_323;
      }
      v131 = (llvm *)((v129 >> 3) & 3);
      if (!v131) {
        v131 = (llvm *)(*(uint64_t (**)(unint64_t))(*(void *)v94 + 8))(v94);
      }
      if (v131 != 2)
      {
        LODWORD(__p.__r_.__value_.__l.__data_) = 0;
        v270 |= sub_1CD050DD8((unsigned __int16 *)v94, (uint64_t)v124, (uint64_t)v127, 0, 0, 0, 0, (unsigned int *)&__p);
        __s1 = v128;
        size_t __n = (size_t)v122;
        unint64_t v24 = sub_1CD058DC4((unsigned __int8 *)v128, (size_t)v122, (size_t *)__dst, sub_1CD058DB8, v258);
        unint64_t v94 = v24;
        long long v124 = v128;
        if (!v24) {
          goto LABEL_231;
        }
        continue;
      }
      break;
    }
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)"may not occur within a group!";
    LOWORD(v320) = 259;
    v175 = (llvm::raw_ostream *)llvm::errs(v131);
    llvm::cl::Option::error((void *)v94, (llvm::Twine *)&__p, 0, 0, v175);
    int v270 = 1;
LABEL_232:
    unint64_t v77 = v123;
LABEL_235:
    uint64_t v30 = v273;
    uint64_t v84 = *(unsigned int *)(v273 + 88);
    if (v84)
    {
      unint64_t v85 = v77;
      long long v51 = v262;
      goto LABEL_136;
    }
    v140 = (unsigned __int8 *)__s1;
    v293 = (unsigned __int8 *)__s1;
    v294 = v127;
    if (v127)
    {
      __p.__r_.__value_.__s.__data_[0] = 61;
      unint64_t v141 = llvm::StringRef::find((uint64_t *)&v293, (char *)&__p, 1uLL, 0);
      if ((unint64_t)v127 >= v141) {
        v142 = (char *)v141;
      }
      else {
        v142 = v127;
      }
      if ((unint64_t)v127 >= v141 + 1) {
        v143 = (char *)(v141 + 1);
      }
      else {
        v143 = v127;
      }
      v144 = &v143[(void)v140];
      v145 = (char *)(v127 - v143);
      if (v141 == -1) {
        v144 = 0;
      }
      unint64_t v261 = (unint64_t)v144;
      if (v141 == -1) {
        v145 = 0;
      }
      v263 = v145;
      if (v141 == -1) {
        v142 = v127;
      }
      v255 = v142;
      uint64_t v146 = *(unsigned int *)(v273 + 136);
      if (v146)
      {
        v147 = *(uint64_t **)(v273 + 128);
        long long v51 = v262;
        while (!*v147 || *v147 == -8)
          ++v147;
      }
      else
      {
        v147 = *(uint64_t **)(v273 + 128);
        long long v51 = v262;
      }
      uint64_t v149 = *(void *)(v273 + 128) + 8 * v146;
      if (v147 != (uint64_t *)v149)
      {
        uint64_t v83 = 0;
        unsigned int v150 = 0;
        uint64_t v151 = *v147;
        v254 = v140;
        uint64_t v256 = v149;
        while (1)
        {
          uint64_t v152 = *(void *)(v151 + 8);
          if ((*(_WORD *)(v152 + 10) & 0x60) != 0x40)
          {
            __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p.__r_.__value_.__r.__words[2];
            __p.__r_.__value_.__l.__size_ = 0x1000000000;
            (*(void (**)(uint64_t, std::string *))(*(void *)v152 + 72))(v152, &__p);
            uint64_t v153 = v152;
            uint64_t v154 = *(void *)(v152 + 24);
            uint64_t v264 = v153;
            if (v154)
            {
              if (LODWORD(__p.__r_.__value_.__r.__words[1]) >= (unint64_t)HIDWORD(__p.__r_.__value_.__r.__words[1])) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              v155 = (void *)(__p.__r_.__value_.__r.__words[0] + 16 * LODWORD(__p.__r_.__value_.__r.__words[1]));
              void *v155 = *(void *)(v153 + 16);
              v155[1] = v154;
              ++LODWORD(__p.__r_.__value_.__r.__words[1]);
            }
            int v156 = (*(unsigned __int16 *)(v153 + 10) >> 3) & 3;
            uint64_t v157 = v153;
            if (!v156) {
              int v156 = (*(uint64_t (**)(uint64_t))(*(void *)v153 + 8))(v153);
            }
            v158 = (std::string *)__p.__r_.__value_.__r.__words[0];
            if (LODWORD(__p.__r_.__value_.__r.__words[1]))
            {
              BOOL v159 = v156 == 3;
              unint64_t v160 = (unint64_t)v294;
              if (!v159) {
                unint64_t v160 = (unint64_t)v255;
              }
              unint64_t v271 = v160;
              if (v159) {
                v161 = v293;
              }
              else {
                v161 = v140;
              }
              BOOL v162 = v159 || v263 == 0;
              BOOL v268 = v162;
              v163 = (unint64_t *)(__p.__r_.__value_.__r.__words[0] + 8);
              uint64_t v164 = 16 * LODWORD(__p.__r_.__value_.__r.__words[1]);
              while (1)
              {
                unsigned int v165 = sub_1CD0AEE00(*(v163 - 1), *v163, v161, v271, 1, v150);
                unsigned int v166 = v165;
                if (!v83 || v165 < v150) {
                  break;
                }
LABEL_308:
                v163 += 2;
                v164 -= 16;
                if (!v164)
                {
                  v158 = (std::string *)__p.__r_.__value_.__r.__words[0];
                  uint64_t v30 = v273;
                  long long v51 = v262;
                  v140 = v254;
                  goto LABEL_310;
                }
              }
              if (!v268)
              {
                unint64_t v170 = *v163;
                v285[0] = *(v163 - 1);
                v285[1] = v170;
                v285[2] = "=";
                __int16 v286 = 773;
                __dst[0] = v285;
                unint64_t v288 = v261;
                v289 = v263;
                __int16 v290 = 1282;
                llvm::Twine::str((llvm::Twine *)__dst, &v291);
                if (SHIBYTE(v280) < 0) {
                  operator delete(v279[0]);
                }
                *(_OWORD *)v279 = v291;
                int64_t v280 = v292;
                unsigned int v150 = v166;
                uint64_t v83 = v157;
                goto LABEL_308;
              }
              size_t v167 = *v163;
              if (*v163 > 0x7FFFFFFFFFFFFFF7) {
                goto LABEL_472;
              }
              v168 = (const void *)*(v163 - 1);
              if (v167 >= 0x17)
              {
                uint64_t v171 = (v167 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v167 | 7) != 0x17) {
                  uint64_t v171 = v167 | 7;
                }
                uint64_t v172 = v171 + 1;
                v169 = operator new(v171 + 1);
                __dst[1] = (void *)v167;
                unint64_t v288 = v172 | 0x8000000000000000;
                __dst[0] = v169;
              }
              else
              {
                HIBYTE(v288) = *v163;
                v169 = __dst;
                if (!v167) {
                  goto LABEL_305;
                }
              }
              memmove(v169, v168, v167);
LABEL_305:
              uint64_t v157 = v264;
              *((unsigned char *)v169 + v167) = 0;
              if (SHIBYTE(v280) < 0) {
                operator delete(v279[0]);
              }
              *(_OWORD *)v279 = *(_OWORD *)__dst;
              int64_t v280 = v288;
              unsigned int v150 = v166;
              uint64_t v83 = v264;
              uint64_t v75 = (const char **)v266;
              goto LABEL_308;
            }
LABEL_310:
            if (v158 != (std::string *)&__p.__r_.__value_.__r.__words[2]) {
              free(v158);
            }
            uint64_t v149 = v256;
          }
          do
          {
            uint64_t v173 = v147[1];
            ++v147;
            uint64_t v151 = v173;
            if (v173) {
              BOOL v174 = v151 == -8;
            }
            else {
              BOOL v174 = 1;
            }
          }
          while (v174);
          if (v147 == (uint64_t *)v149) {
            goto LABEL_321;
          }
        }
      }
      uint64_t v83 = 0;
    }
    else
    {
      uint64_t v83 = 0;
      long long v51 = v262;
    }
LABEL_321:
    uint64_t v49 = v265;
LABEL_134:
    uint64_t v84 = *(unsigned int *)(v30 + 88);
    if (!v84)
    {
      char v95 = *(unsigned char *)(v49 + 23);
      BOOL v96 = v95 < 0;
      if (v95 >= 0) {
        int v97 = (const char *)v49;
      }
      else {
        int v97 = *(const char **)v49;
      }
      size_t v98 = v95 & 0x7F;
      if (v96) {
        size_t v99 = *(void *)(v49 + 8);
      }
      else {
        size_t v99 = v98;
      }
      unint64_t v24 = (unint64_t)llvm::raw_ostream::write(v51, v97, v99);
      long long v100 = (void *)*((void *)v51 + 4);
      if (*((void *)v51 + 3) - (void)v100 > 0x20uLL)
      {
        qmemcpy(v100, ": Unknown command line argument '", 33);
        uint64_t v101 = (_WORD *)(*((void *)v51 + 4) + 33);
        *((void *)v51 + 4) = v101;
      }
      else
      {
        unint64_t v24 = (unint64_t)llvm::raw_ostream::write(v51, ": Unknown command line argument '", 0x21uLL);
        uint64_t v101 = (_WORD *)*((void *)v51 + 4);
      }
      unint64_t v102 = v77;
      long long v103 = v75[v281];
      if (v103)
      {
        unint64_t v24 = strlen(v75[v281]);
        unint64_t v104 = v24;
        if (v24 <= *((void *)v51 + 3) - (void)v101)
        {
          if (v24)
          {
            unint64_t v24 = (unint64_t)memcpy(v101, v103, v24);
            uint64_t v101 = (_WORD *)(*((void *)v51 + 4) + v104);
            *((void *)v51 + 4) = v101;
          }
        }
        else
        {
          unint64_t v24 = (unint64_t)llvm::raw_ostream::write(v51, v103, v24);
          uint64_t v101 = (_WORD *)*((void *)v51 + 4);
        }
      }
      if (*((void *)v51 + 3) - (void)v101 > 9uLL)
      {
        v101[4] = 10016;
        *(void *)uint64_t v101 = *(void *)"'.  Try: '";
        uint64_t v105 = (unsigned char *)(*((void *)v51 + 4) + 10);
        *((void *)v51 + 4) = v105;
      }
      else
      {
        unint64_t v24 = (unint64_t)llvm::raw_ostream::write(v51, "'.  Try: '", 0xAuLL);
        uint64_t v105 = (unsigned char *)*((void *)v51 + 4);
      }
      unsigned int v106 = *v75;
      if (*v75)
      {
        unint64_t v24 = strlen(*v75);
        unint64_t v107 = v24;
        if (v24 <= *((void *)v51 + 3) - (void)v105)
        {
          if (v24)
          {
            unint64_t v24 = (unint64_t)memcpy(v105, v106, v24);
            uint64_t v105 = (unsigned char *)(*((void *)v51 + 4) + v107);
            *((void *)v51 + 4) = v105;
          }
        }
        else
        {
          unint64_t v24 = (unint64_t)llvm::raw_ostream::write(v51, v106, v24);
          uint64_t v105 = (unsigned char *)*((void *)v51 + 4);
        }
      }
      unint64_t v77 = v102;
      if (*((void *)v51 + 3) - (void)v105 > 8uLL)
      {
        v105[8] = 10;
        *(void *)uint64_t v105 = *(void *)" --help'\n";
        *((void *)v51 + 4) += 9;
        if (v83) {
          goto LABEL_179;
        }
      }
      else
      {
        unint64_t v24 = (unint64_t)llvm::raw_ostream::write(v51, " --help'\n", 9uLL);
        if (v83)
        {
LABEL_179:
          char v108 = *(unsigned char *)(v49 + 23);
          BOOL v109 = v108 < 0;
          if (v108 >= 0) {
            uint64_t v110 = (const char *)v49;
          }
          else {
            uint64_t v110 = *(const char **)v49;
          }
          size_t v111 = v108 & 0x7F;
          if (v109) {
            size_t v112 = *(void *)(v49 + 8);
          }
          else {
            size_t v112 = v111;
          }
          llvm::raw_ostream::write(v51, v110, v112);
          unsigned int v113 = (_OWORD *)*((void *)v51 + 4);
          if (*((void *)v51 + 3) - (void)v113 > 0xFuLL)
          {
            *unsigned int v113 = *(_OWORD *)": Did you mean '";
            *((void *)v51 + 4) += 16;
          }
          else
          {
            llvm::raw_ostream::write(v51, ": Did you mean '", 0x10uLL);
          }
          v114 = (void **)v279[0];
          if (v280 >= 0) {
            v114 = v279;
          }
          unint64_t v115 = HIBYTE(v280) & 0x7F;
          if (v280 < 0) {
            unint64_t v115 = (unint64_t)v279[1];
          }
          __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v114;
          *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = v115;
          unint64_t v24 = (unint64_t)sub_1CD0543E0(v51, (uint64_t)&__p);
          uint64_t v116 = *((void *)v51 + 4);
          if ((unint64_t)(*((void *)v51 + 3) - v116) > 2)
          {
            *(unsigned char *)(v116 + 2) = 10;
            *(_WORD *)uint64_t v116 = 16167;
            *((void *)v51 + 4) += 3;
          }
          else
          {
            unint64_t v24 = (unint64_t)llvm::raw_ostream::write(v51, "'?\n", 3uLL);
          }
        }
      }
      int v82 = 9;
      int v270 = 1;
      goto LABEL_207;
    }
    unint64_t v85 = v77;
    uint64_t v32 = v281;
    uint64_t v78 = v281;
LABEL_136:
    uint64_t v86 = *(void **)(v30 + 80);
    uint64_t v87 = 8 * v84;
    do
    {
      uint64_t v88 = v75[v78];
      if (v88) {
        size_t v89 = strlen(v75[v78]);
      }
      else {
        size_t v89 = 0;
      }
      unint64_t v24 = (*(uint64_t (**)(void, uint64_t, void *, void, const char *, size_t, void))(*(void *)*v86 + 80))(*v86, v32, &unk_1CFC27923, 0, v88, v89, 0);
      ++v86;
      v87 -= 8;
    }
    while (v87);
    int v82 = 9;
    unint64_t v77 = v85;
    uint64_t v49 = v265;
LABEL_207:
    if (SHIBYTE(v280) < 0) {
      operator delete(v279[0]);
    }
    if (v82 == 9 || !v82)
    {
      uint64_t v32 = (v281 + 1);
      int v281 = v32;
      if ((int)v32 < v269) {
        continue;
      }
    }
    break;
  }
  unsigned int v176 = v306;
LABEL_338:
  if (v176 < v272)
  {
    char v177 = *(unsigned char *)(v49 + 23);
    BOOL v178 = v177 < 0;
    if (v177 >= 0) {
      v179 = (const char *)v49;
    }
    else {
      v179 = *(const char **)v49;
    }
    size_t v180 = v177 & 0x7F;
    if (v178) {
      size_t v181 = *(void *)(v49 + 8);
    }
    else {
      size_t v181 = v180;
    }
    llvm::raw_ostream::write(v51, v179, v181);
    v182 = (void *)*((void *)v51 + 4);
    if (*((void *)v51 + 3) - (void)v182 > 0x39uLL)
    {
      qmemcpy(v182, ": Not enough positional command line arguments specified!\n", 58);
      v183 = (void *)(*((void *)v51 + 4) + 58);
      *((void *)v51 + 4) = v183;
    }
    else
    {
      llvm::raw_ostream::write(v51, ": Not enough positional command line arguments specified!\n", 0x3AuLL);
      v183 = (void *)*((void *)v51 + 4);
    }
    if (*((void *)v51 + 3) - (void)v183 > 0x15uLL)
    {
      qmemcpy(v183, "Must specify at least ", 22);
      *((void *)v51 + 4) += 22;
    }
    else
    {
      llvm::raw_ostream::write(v51, "Must specify at least ", 0x16uLL);
    }
    sub_1CD098D14(v51, v272, 0, 0, 0);
    uint64_t v184 = *((void *)v51 + 4);
    if ((unint64_t)(*((void *)v51 + 3) - v184) > 0x13)
    {
      *(_DWORD *)(v184 + 16) = 1953391981;
      *(_OWORD *)uint64_t v184 = *(_OWORD *)" positional argument";
      unint64_t v24 = *((void *)v51 + 4) + 20;
      *((void *)v51 + 4) = v24;
    }
    else
    {
      llvm::raw_ostream::write(v51, " positional argument", 0x14uLL);
      unint64_t v24 = *((void *)v51 + 4);
    }
    unint64_t v185 = v272 > 1;
    if (*((void *)v51 + 3) - v24 >= v185)
    {
      if (v272 >= 2)
      {
        memcpy((void *)v24, "s", v272 > 1);
        unint64_t v24 = *((void *)v51 + 4) + v185;
        *((void *)v51 + 4) = v24;
      }
    }
    else
    {
      if (v272 <= 1) {
        v186 = (const char *)&unk_1CFC27923;
      }
      else {
        v186 = "s";
      }
      llvm::raw_ostream::write(v51, v186, v272 > 1);
      unint64_t v24 = *((void *)v51 + 4);
    }
    if (*((void *)v51 + 3) - v24 <= 6)
    {
      v187 = ": See: ";
      v188 = v51;
      size_t v189 = 7;
LABEL_386:
      unint64_t v24 = (unint64_t)llvm::raw_ostream::write(v188, v187, v189);
      v211 = (void *)*((void *)v51 + 4);
LABEL_387:
      v212 = *v75;
      if (*v75)
      {
        unint64_t v24 = strlen(*v75);
        unint64_t v213 = v24;
        if (v24 <= *((void *)v51 + 3) - (void)v211)
        {
          if (v24)
          {
            unint64_t v24 = (unint64_t)memcpy(v211, v212, v24);
            v211 = (void *)(*((void *)v51 + 4) + v213);
            *((void *)v51 + 4) = v211;
          }
        }
        else
        {
          unint64_t v24 = (unint64_t)llvm::raw_ostream::write(v51, v212, v24);
          v211 = (void *)*((void *)v51 + 4);
        }
      }
      if (*((void *)v51 + 3) - (void)v211 > 7uLL)
      {
        void *v211 = 0xA706C65682D2D20;
        *((void *)v51 + 4) += 8;
      }
      else
      {
        unint64_t v24 = (unint64_t)llvm::raw_ostream::write(v51, " --help\n", 8uLL);
      }
      char v195 = 1;
      goto LABEL_393;
    }
    *(_DWORD *)(v24 + 3) = 540697957;
    *(_DWORD *)unint64_t v24 = 1699946554;
    v211 = (void *)(*((void *)v51 + 4) + 7);
    goto LABEL_465;
  }
  uint64_t v190 = *(unsigned int *)(v30 + 40);
  char v191 = v257;
  if (v176 <= v190) {
    char v191 = 1;
  }
  if ((v191 & 1) == 0)
  {
    char v203 = *(unsigned char *)(v49 + 23);
    BOOL v204 = v203 < 0;
    if (v203 >= 0) {
      v205 = (const char *)v49;
    }
    else {
      v205 = *(const char **)v49;
    }
    size_t v206 = v203 & 0x7F;
    if (v204) {
      size_t v207 = *(void *)(v49 + 8);
    }
    else {
      size_t v207 = v206;
    }
    llvm::raw_ostream::write(v51, v205, v207);
    v208 = (void *)*((void *)v51 + 4);
    if (*((void *)v51 + 3) - (void)v208 > 0x2AuLL)
    {
      qmemcpy(v208, ": Too many positional arguments specified!\n", 43);
      uint64_t v209 = *((void *)v51 + 4) + 43;
      *((void *)v51 + 4) = v209;
    }
    else
    {
      llvm::raw_ostream::write(v51, ": Too many positional arguments specified!\n", 0x2BuLL);
      uint64_t v209 = *((void *)v51 + 4);
    }
    if ((unint64_t)(*((void *)v51 + 3) - v209) > 0x13)
    {
      *(_DWORD *)(v209 + 16) = 544502639;
      *(_OWORD *)uint64_t v209 = *(_OWORD *)"Can specify at most ";
      *((void *)v51 + 4) += 20;
    }
    else
    {
      llvm::raw_ostream::write(v51, "Can specify at most ", 0x14uLL);
    }
    unint64_t v24 = (unint64_t)sub_1CD098D14(v51, *(unsigned int *)(v30 + 40), 0, 0, 0);
    v210 = (void *)*((void *)v51 + 4);
    if (*((void *)v51 + 3) - (void)v210 <= 0x1BuLL)
    {
      v187 = " positional arguments: See: ";
      v188 = v51;
      size_t v189 = 28;
      goto LABEL_386;
    }
    qmemcpy(v210, " positional arguments: See: ", 28);
    v211 = (void *)(*((void *)v51 + 4) + 28);
LABEL_465:
    *((void *)v51 + 4) = v211;
    goto LABEL_387;
  }
  if (*(void *)(v30 + 160))
  {
    if (v190)
    {
      uint64_t v192 = 0;
      unsigned int v193 = 0;
      uint64_t v194 = 8 * v190;
      char v195 = v270;
      do
      {
        unint64_t v24 = *(void *)(*(void *)(v30 + 32) + v192);
        if ((*(_WORD *)(v24 + 10) & 6) == 2)
        {
          v196 = (char *)v305 + 24 * v193;
          v197 = *(char **)v196;
          size_t v198 = *((void *)v196 + 1);
          LODWORD(__p.__r_.__value_.__l.__data_) = *((_DWORD *)v196 + 4);
          unint64_t v24 = sub_1CD050DD8((unsigned __int16 *)v24, *(void *)(v24 + 16), *(void *)(v24 + 24), v197, v198, 0, 0, (unsigned int *)&__p);
          v195 |= v24;
          ++v193;
        }
        v192 += 8;
      }
      while (v194 != v192);
      unsigned int v176 = v306;
      if (*(_DWORD *)(v30 + 40) == 1 && v193 == 0)
      {
        if (!v306) {
          goto LABEL_393;
        }
        uint64_t v200 = **(void **)(v30 + 32);
        v201 = *(char **)v305;
        size_t v202 = *((void *)v305 + 1);
        LODWORD(__p.__r_.__value_.__l.__data_) = *((_DWORD *)v305 + 4);
        unint64_t v24 = sub_1CD050DD8((unsigned __int16 *)v200, *(void *)(v200 + 16), *(void *)(v200 + 24), v201, v202, 0, 0, (unsigned int *)&__p);
        v195 |= v24;
        unsigned int v193 = 1;
        unsigned int v176 = v306;
      }
    }
    else
    {
      unsigned int v193 = 0;
      char v195 = v270;
    }
    if (v176 != v193)
    {
      do
      {
        uint64_t v245 = *(void *)(v30 + 160);
        v246 = (char *)v305 + 24 * v193;
        v247 = *(char **)v246;
        size_t v248 = *((void *)v246 + 1);
        LODWORD(__p.__r_.__value_.__l.__data_) = *((_DWORD *)v246 + 4);
        unint64_t v24 = sub_1CD050DD8((unsigned __int16 *)v245, *(void *)(v245 + 16), *(void *)(v245 + 24), v247, v248, 0, 0, (unsigned int *)&__p);
        v195 |= v24;
        ++v193;
      }
      while (v193 != v306);
    }
  }
  else
  {
    if (v190)
    {
      uint64_t v232 = 0;
      unsigned int v233 = 0;
      unsigned int v234 = v272;
      do
      {
        unint64_t v24 = *(void *)(*(void *)(v30 + 32) + 8 * v232);
        __int16 v235 = *(_WORD *)(v24 + 10);
        if ((v235 & 6) == 2)
        {
          v236 = (char *)v305 + 24 * v233;
          v237 = *(char **)v236;
          size_t v238 = *((void *)v236 + 1);
          LODWORD(__p.__r_.__value_.__l.__data_) = *((_DWORD *)v236 + 4);
          unint64_t v24 = sub_1CD050DD8((unsigned __int16 *)v24, *(void *)(v24 + 16), *(void *)(v24 + 24), v237, v238, 0, 0, (unsigned int *)&__p);
          ++v233;
          --v234;
          __int16 v235 = *(_WORD *)(*(void *)(*(void *)(v30 + 32) + 8 * v232) + 10);
        }
        if (v176 - v233 > v234 && (v235 & 7) != 2)
        {
          unsigned int v239 = v176 - 1 - v233;
          do
          {
            uint64_t v240 = *(void *)(*(void *)(v30 + 32) + 8 * v232);
            __int16 v241 = *(_WORD *)(v240 + 10);
            v242 = (char *)v305 + 24 * v233;
            v243 = *(char **)v242;
            size_t v244 = *((void *)v242 + 1);
            LODWORD(__p.__r_.__value_.__l.__data_) = *((_DWORD *)v242 + 4);
            unint64_t v24 = sub_1CD050DD8((unsigned __int16 *)v240, *(void *)(v240 + 16), *(void *)(v240 + 24), v243, v244, 0, 0, (unsigned int *)&__p);
            ++v233;
            if (v239 <= v234) {
              break;
            }
            --v239;
          }
          while ((v241 & 7) != 0);
        }
        ++v232;
      }
      while (v232 != v190);
      uint64_t v49 = v265;
    }
    char v195 = v270;
  }
LABEL_393:
  uint64_t v214 = *(unsigned int *)(v30 + 136);
  if (v214)
  {
    for (uint64_t i = *(uint64_t **)(v30 + 128); !*i || *i == -8; ++i)
      ;
  }
  else
  {
    uint64_t i = *(uint64_t **)(v30 + 128);
  }
  uint64_t v217 = *(void *)(v30 + 128) + 8 * v214;
  if (i != (uint64_t *)v217)
  {
    uint64_t v218 = *i;
    do
    {
      uint64_t v219 = *(void *)(v218 + 8);
      if ((*(_WORD *)(v219 + 10) & 6) == 2 && !*(_WORD *)(v219 + 8))
      {
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)"must be specified at least once!";
        LOWORD(v320) = 259;
        v222 = (llvm::raw_ostream *)llvm::errs((llvm *)v24);
        unint64_t v24 = llvm::cl::Option::error((void *)v219, (llvm::Twine *)&__p, 0, 0, v222);
        char v195 = 1;
      }
      do
      {
        uint64_t v220 = i[1];
        ++i;
        uint64_t v218 = v220;
        if (v220) {
          BOOL v221 = v218 == -8;
        }
        else {
          BOOL v221 = 1;
        }
      }
      while (v221);
    }
    while (i != (uint64_t *)v217);
  }
  *(void *)(v49 + 48) = *(void *)(v49 + 40);
  if (!a5 && v195) {
    exit(1);
  }
  if (v305 != v307) {
    free(v305);
  }
  if (v310)
  {
    v223 = (uint64_t *)v309;
    uint64_t v224 = 8 * v310;
    do
    {
      uint64_t v225 = *v223++;
      MEMORY[0x1D25D9CD0](v225, 8);
      v224 -= 8;
    }
    while (v224);
  }
  v226 = (uint64_t *)v312;
  if (v313)
  {
    uint64_t v249 = 16 * v313;
    do
    {
      uint64_t v250 = *v226;
      v226 += 2;
      MEMORY[0x1D25D9CD0](v250, 8);
      v249 -= 16;
    }
    while (v249);
    v226 = (uint64_t *)v312;
  }
  if (v226 != v314) {
    free(v226);
  }
  if (v309 != v311) {
    free(v309);
  }
  if (v315 != v317) {
    free(v315);
  }
  if (v297)
  {
    v227 = (uint64_t *)v296;
    uint64_t v228 = 8 * v297;
    do
    {
      uint64_t v229 = *v227++;
      MEMORY[0x1D25D9CD0](v229, 8);
      v228 -= 8;
    }
    while (v228);
  }
  v230 = (uint64_t *)v299;
  if (v300)
  {
    uint64_t v251 = 16 * v300;
    do
    {
      uint64_t v252 = *v230;
      v230 += 2;
      MEMORY[0x1D25D9CD0](v252, 8);
      v251 -= 16;
    }
    while (v251);
    v230 = (uint64_t *)v299;
  }
  if (v230 != v301) {
    free(v230);
  }
  if (v296 != v298) {
    free(v296);
  }
  if (v302 != v304) {
    free(v302);
  }
  return v195 == 0;
}

void sub_1CD054360(llvm *a1)
{
  if (!atomic_load_explicit(qword_1EBCFAC00, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EBCFAC00, (void *(*)(void))sub_1CD059090, (void (*)(void *))sub_1CD059908);
  }
  llvm::initDebugCounterOptions(a1);
  llvm::initSignalsOptions(v1);
  llvm::initStatisticOptions(v2);
  llvm::initTimerOptions(v3);
  llvm::initTypeSizeOptions(v4);
  llvm::initWithColorOptions(v5);

  llvm::initRandomSeedOptions(v6);
}

llvm::raw_ostream *sub_1CD0543E0(llvm::raw_ostream *a1, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  unint64_t v4 = *(void *)(a2 + 8);
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t v13 = 0;
  for (uint64_t i = 0; v5; --v5)
  {
    if ((unint64_t)(i + 1) > 8) {
      llvm::SmallVectorBase<unsigned long long>::grow_pod();
    }
    v14[i] = 32;
    uint64_t i = ++v13;
  }
  if (v4 <= 1) {
    uint64_t v7 = "-";
  }
  else {
    uint64_t v7 = "--";
  }
  if (v4 <= 1) {
    size_t v8 = 1;
  }
  else {
    size_t v8 = 2;
  }
  if (i + v8 > 8) {
    llvm::SmallVectorBase<unsigned long long>::grow_pod();
  }
  memcpy(&v14[i], v7, v8);
  llvm::raw_ostream::write(a1, v14, v13 + v8);
  unint64_t v9 = *(const void **)a2;
  size_t v10 = *(void *)(a2 + 8);
  std::string::size_type v11 = (void *)*((void *)a1 + 4);
  if (v10 <= *((void *)a1 + 3) - (void)v11)
  {
    if (v10)
    {
      memcpy(v11, v9, v10);
      *((void *)a1 + 4) += v10;
    }
  }
  else
  {
    llvm::raw_ostream::write(a1, (const char *)v9, v10);
  }
  return a1;
}

uint64_t llvm::cl::parser<long>::parse(uint64_t a1, void *a2, uint64_t a3, unint64_t *a4, unint64_t a5, unint64_t a6, void *a7)
{
  v15[0] = 0;
  uint64_t v17 = (unint64_t *)a5;
  unint64_t v18 = a6;
  std::string::size_type v11 = (llvm *)llvm::consumeSignedInteger((llvm *)&v17, 0, v15, a4);
  if (v18) {
    uint64_t v12 = 1;
  }
  else {
    uint64_t v12 = v11;
  }
  if (v12)
  {
    __int16 v16 = 1283;
    v15[0] = (unint64_t)"'";
    void v15[2] = a5;
    v15[3] = a6;
    uint64_t v17 = v15;
    char v19 = "' value invalid for long argument!";
    __int16 v20 = 770;
    std::string::size_type v14 = (llvm::raw_ostream *)llvm::errs(v11);
    llvm::cl::Option::error(a2, (llvm::Twine *)&v17, 0, 0, v14);
  }
  else
  {
    *a7 = v15[0];
  }
  return v12;
}

uint64_t llvm::cl::parser<long long>::parse(uint64_t a1, void *a2, uint64_t a3, unint64_t *a4, unint64_t a5, unint64_t a6, void *a7)
{
  v15[0] = 0;
  uint64_t v17 = (unint64_t *)a5;
  unint64_t v18 = a6;
  std::string::size_type v11 = (llvm *)llvm::consumeSignedInteger((llvm *)&v17, 0, v15, a4);
  if (v18) {
    uint64_t v12 = 1;
  }
  else {
    uint64_t v12 = v11;
  }
  if (v12)
  {
    __int16 v16 = 1283;
    v15[0] = (unint64_t)"'";
    void v15[2] = a5;
    v15[3] = a6;
    uint64_t v17 = v15;
    char v19 = "' value invalid for llong argument!";
    __int16 v20 = 770;
    std::string::size_type v14 = (llvm::raw_ostream *)llvm::errs(v11);
    llvm::cl::Option::error(a2, (llvm::Twine *)&v17, 0, 0, v14);
  }
  else
  {
    *a7 = v15[0];
  }
  return v12;
}

BOOL sub_1CD054730(void *a1, uint64_t a2, uint64_t a3, double *a4)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  __int16 v15 = 261;
  v14[0] = a2;
  v14[1] = a3;
  uint64_t v17 = v19;
  long long v18 = xmmword_1CDC7F9D0;
  size_t v8 = (const char *)llvm::Twine::toNullTerminatedStringRef((unsigned __int8 *)v14, &v17);
  __int16 v16 = 0;
  double v9 = strtod(v8, &v16);
  int v10 = *v16;
  if (!*v16) {
    *a4 = v9;
  }
  std::string::size_type v11 = (llvm *)v17;
  if (v17 != v19) {
    free(v17);
  }
  if (v10)
  {
    __int16 v15 = 1283;
    v14[0] = "'";
    v14[2] = a2;
    v14[3] = a3;
    uint64_t v17 = v14;
    *((void *)&v18 + 1) = "' value invalid for floating point argument!";
    v19[4] = 770;
    uint64_t v13 = (llvm::raw_ostream *)llvm::errs(v11);
    llvm::cl::Option::error(a1, (llvm::Twine *)&v17, 0, 0, v13);
  }
  return v10 != 0;
}

void llvm::cl::parser<long>::printOptionDiff(llvm::cl::basic_parser_impl *a1, const llvm::cl::Option *a2, unint64_t a3, uint64_t a4, int a5)
{
  llvm::cl::basic_parser_impl::printOptionName(a1, a2, a5);
  size_t v38 = 0;
  size_t v39 = 0;
  uint64_t v40 = 0;
  int v30 = 0;
  char v34 = 0;
  uint64_t v35 = 0;
  uint64_t v37 = (void **)&v38;
  int v36 = 0;
  size_t v29 = &unk_1F2646F30;
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  if ((a3 & 0x8000000000000000) != 0)
  {
    unint64_t v7 = -(uint64_t)a3;
    int v8 = 1;
  }
  else
  {
    unint64_t v7 = a3;
    int v8 = 0;
  }
  double v9 = sub_1CD098D14((llvm::raw_ostream *)&v29, v7, 0, 0, v8);
  size_t v29 = &unk_1F2646B98;
  if (v36 == 1)
  {
    double v9 = v31;
    if (v31) {
      double v9 = (llvm *)MEMORY[0x1D25D9CB0](v31, 0x1000C8077774924);
    }
  }
  int v10 = (llvm::raw_ostream *)llvm::outs(v9);
  std::string::size_type v11 = (_WORD *)*((void *)v10 + 4);
  if (*((void *)v10 + 3) - (void)v11 > 1uLL)
  {
    *std::string::size_type v11 = 8253;
    *((void *)v10 + 4) += 2;
  }
  else
  {
    int v10 = llvm::raw_ostream::write(v10, "= ", 2uLL);
  }
  if (v40 >= 0) {
    uint64_t v12 = (const char *)&v38;
  }
  else {
    uint64_t v12 = v38;
  }
  if (v40 >= 0) {
    size_t v13 = HIBYTE(v40) & 0x7F;
  }
  else {
    size_t v13 = v39;
  }
  std::string::size_type v14 = llvm::raw_ostream::write(v10, v12, v13);
  if (v40 >= 0) {
    unint64_t v15 = HIBYTE(v40) & 0x78;
  }
  else {
    unint64_t v15 = v39;
  }
  int v16 = HIBYTE(v40) & 0x7F;
  if (v40 < 0) {
    int v16 = v39;
  }
  unsigned int v17 = 8 - v16;
  if (v15 >= 8) {
    unsigned int v18 = 0;
  }
  else {
    unsigned int v18 = v17;
  }
  char v19 = (llvm::raw_ostream *)llvm::outs(v14);
  uint64_t v20 = llvm::raw_ostream::indent(v19, v18);
  uint64_t v21 = *((void *)v20 + 4);
  if ((unint64_t)(*((void *)v20 + 3) - v21) > 0xA)
  {
    *(_DWORD *)(v21 + 7) = 540701804;
    *(void *)uint64_t v21 = *(void *)" (default: ";
    *((void *)v20 + 4) += 11;
  }
  else
  {
    uint64_t v20 = llvm::raw_ostream::write(v20, " (default: ", 0xBuLL);
  }
  int v22 = *(unsigned __int8 *)(a4 + 16);
  size_t v23 = (llvm::raw_ostream *)llvm::outs(v20);
  if (v22)
  {
    unint64_t v24 = *(void *)(a4 + 8);
    if ((v24 & 0x8000000000000000) != 0)
    {
      unint64_t v24 = -(uint64_t)v24;
      int v25 = 1;
    }
    else
    {
      int v25 = 0;
    }
    size_t v23 = sub_1CD098D14(v23, v24, 0, 0, v25);
  }
  else
  {
    uint64_t v26 = *((void *)v23 + 4);
    if ((unint64_t)(*((void *)v23 + 3) - v26) > 0xB)
    {
      *(_DWORD *)(v26 + 8) = 712273013;
      *(void *)uint64_t v26 = *(void *)"*no default*";
      *((void *)v23 + 4) += 12;
    }
    else
    {
      size_t v23 = llvm::raw_ostream::write(v23, "*no default*", 0xCuLL);
    }
  }
  size_t v27 = (llvm::raw_ostream *)llvm::outs(v23);
  size_t v28 = (_WORD *)*((void *)v27 + 4);
  if (*((void *)v27 + 3) - (void)v28 > 1uLL)
  {
    *size_t v28 = 2601;
    *((void *)v27 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(v27, ")\n", 2uLL);
  }
  if (SHIBYTE(v40) < 0) {
    operator delete(v38);
  }
}

void llvm::cl::parser<long long>::printOptionDiff(llvm::cl::basic_parser_impl *a1, const llvm::cl::Option *a2, unint64_t a3, uint64_t a4, int a5)
{
  llvm::cl::basic_parser_impl::printOptionName(a1, a2, a5);
  char v34 = 0;
  size_t v35 = 0;
  uint64_t v36 = 0;
  int v26 = 0;
  char v30 = 0;
  uint64_t v31 = 0;
  uint64_t v33 = (void **)&v34;
  int v32 = 0;
  int v25 = &unk_1F2646F30;
  size_t v27 = 0;
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  unint64_t v7 = llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v25, a3);
  int v25 = &unk_1F2646B98;
  if (v32 == 1)
  {
    unint64_t v7 = v27;
    if (v27) {
      unint64_t v7 = (llvm *)MEMORY[0x1D25D9CB0](v27, 0x1000C8077774924);
    }
  }
  int v8 = (llvm::raw_ostream *)llvm::outs(v7);
  double v9 = (_WORD *)*((void *)v8 + 4);
  if (*((void *)v8 + 3) - (void)v9 > 1uLL)
  {
    _WORD *v9 = 8253;
    *((void *)v8 + 4) += 2;
  }
  else
  {
    int v8 = llvm::raw_ostream::write(v8, "= ", 2uLL);
  }
  if (v36 >= 0) {
    int v10 = (const char *)&v34;
  }
  else {
    int v10 = v34;
  }
  if (v36 >= 0) {
    size_t v11 = HIBYTE(v36) & 0x7F;
  }
  else {
    size_t v11 = v35;
  }
  uint64_t v12 = llvm::raw_ostream::write(v8, v10, v11);
  if (v36 >= 0) {
    unint64_t v13 = HIBYTE(v36) & 0x78;
  }
  else {
    unint64_t v13 = v35;
  }
  int v14 = HIBYTE(v36) & 0x7F;
  if (v36 < 0) {
    int v14 = v35;
  }
  unsigned int v15 = 8 - v14;
  if (v13 >= 8) {
    unsigned int v16 = 0;
  }
  else {
    unsigned int v16 = v15;
  }
  unsigned int v17 = (llvm::raw_ostream *)llvm::outs(v12);
  unsigned int v18 = llvm::raw_ostream::indent(v17, v16);
  uint64_t v19 = *((void *)v18 + 4);
  if ((unint64_t)(*((void *)v18 + 3) - v19) > 0xA)
  {
    *(_DWORD *)(v19 + 7) = 540701804;
    *(void *)uint64_t v19 = *(void *)" (default: ";
    *((void *)v18 + 4) += 11;
  }
  else
  {
    unsigned int v18 = llvm::raw_ostream::write(v18, " (default: ", 0xBuLL);
  }
  int v20 = *(unsigned __int8 *)(a4 + 16);
  uint64_t v21 = (llvm::raw_ostream *)llvm::outs(v18);
  if (v20)
  {
    uint64_t v21 = llvm::raw_ostream::operator<<(v21, *(void *)(a4 + 8));
  }
  else
  {
    uint64_t v22 = *((void *)v21 + 4);
    if ((unint64_t)(*((void *)v21 + 3) - v22) > 0xB)
    {
      *(_DWORD *)(v22 + 8) = 712273013;
      *(void *)uint64_t v22 = *(void *)"*no default*";
      *((void *)v21 + 4) += 12;
    }
    else
    {
      uint64_t v21 = llvm::raw_ostream::write(v21, "*no default*", 0xCuLL);
    }
  }
  size_t v23 = (llvm::raw_ostream *)llvm::outs(v21);
  unint64_t v24 = (_WORD *)*((void *)v23 + 4);
  if (*((void *)v23 + 3) - (void)v24 > 1uLL)
  {
    *unint64_t v24 = 2601;
    *((void *)v23 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(v23, ")\n", 2uLL);
  }
  if (SHIBYTE(v36) < 0) {
    operator delete(v34);
  }
}

void llvm::cl::parser<char>::printOptionDiff(llvm::cl::basic_parser_impl *a1, const llvm::cl::Option *a2, char a3, uint64_t a4, int a5)
{
  llvm::cl::basic_parser_impl::printOptionName(a1, a2, a5);
  size_t v35 = 0;
  size_t v36 = 0;
  uint64_t v37 = 0;
  int v27 = 0;
  char v31 = 0;
  uint64_t v32 = 0;
  char v34 = (void **)&v35;
  int v33 = 0;
  int v26 = &unk_1F2646F30;
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  unint64_t v7 = llvm::raw_ostream::write((llvm::raw_ostream *)&v26, a3);
  int v26 = &unk_1F2646B98;
  if (v33 == 1)
  {
    unint64_t v7 = v28;
    if (v28) {
      unint64_t v7 = (llvm *)MEMORY[0x1D25D9CB0](v28, 0x1000C8077774924);
    }
  }
  int v8 = (llvm::raw_ostream *)llvm::outs(v7);
  double v9 = (_WORD *)*((void *)v8 + 4);
  if (*((void *)v8 + 3) - (void)v9 > 1uLL)
  {
    _WORD *v9 = 8253;
    *((void *)v8 + 4) += 2;
  }
  else
  {
    int v8 = llvm::raw_ostream::write(v8, "= ", 2uLL);
  }
  if (v37 >= 0) {
    int v10 = (const char *)&v35;
  }
  else {
    int v10 = v35;
  }
  if (v37 >= 0) {
    size_t v11 = HIBYTE(v37) & 0x7F;
  }
  else {
    size_t v11 = v36;
  }
  uint64_t v12 = llvm::raw_ostream::write(v8, v10, v11);
  if (v37 >= 0) {
    unint64_t v13 = HIBYTE(v37) & 0x78;
  }
  else {
    unint64_t v13 = v36;
  }
  int v14 = HIBYTE(v37) & 0x7F;
  if (v37 < 0) {
    int v14 = v36;
  }
  unsigned int v15 = 8 - v14;
  if (v13 >= 8) {
    unsigned int v16 = 0;
  }
  else {
    unsigned int v16 = v15;
  }
  unsigned int v17 = (llvm::raw_ostream *)llvm::outs(v12);
  unsigned int v18 = llvm::raw_ostream::indent(v17, v16);
  uint64_t v19 = *((void *)v18 + 4);
  if ((unint64_t)(*((void *)v18 + 3) - v19) > 0xA)
  {
    *(_DWORD *)(v19 + 7) = 540701804;
    *(void *)uint64_t v19 = *(void *)" (default: ";
    *((void *)v18 + 4) += 11;
  }
  else
  {
    unsigned int v18 = llvm::raw_ostream::write(v18, " (default: ", 0xBuLL);
  }
  int v20 = *(unsigned __int8 *)(a4 + 9);
  uint64_t v21 = (llvm::raw_ostream *)llvm::outs(v18);
  unint64_t v22 = *((void *)v21 + 4);
  if (v20)
  {
    char v23 = *(unsigned char *)(a4 + 8);
    if (v22 >= *((void *)v21 + 3))
    {
      uint64_t v21 = llvm::raw_ostream::write(v21, v23);
    }
    else
    {
      *((void *)v21 + 4) = v22 + 1;
      *(unsigned char *)unint64_t v22 = v23;
    }
  }
  else if (*((void *)v21 + 3) - v22 > 0xB)
  {
    *(_DWORD *)(v22 + 8) = 712273013;
    *(void *)unint64_t v22 = *(void *)"*no default*";
    *((void *)v21 + 4) += 12;
  }
  else
  {
    uint64_t v21 = llvm::raw_ostream::write(v21, "*no default*", 0xCuLL);
  }
  unint64_t v24 = (llvm::raw_ostream *)llvm::outs(v21);
  int v25 = (_WORD *)*((void *)v24 + 4);
  if (*((void *)v24 + 3) - (void)v25 > 1uLL)
  {
    *int v25 = 2601;
    *((void *)v24 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(v24, ")\n", 2uLL);
  }
  if (SHIBYTE(v37) < 0) {
    operator delete(v35);
  }
}

void llvm::cl::PrintHelpMessage(llvm::cl *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (this & 1) != 0 || (a2)
  {
    if (!a2 || (this & 1) != 0)
    {
      unint64_t explicit = atomic_load_explicit(qword_1EBCFAC00, memory_order_acquire);
      if (!this || (a2 & 1) != 0)
      {
        if (!explicit) {
          llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EBCFAC00, (void *(*)(void))sub_1CD059090, (void (*)(void *))sub_1CD059908);
        }
        uint64_t v4 = qword_1EBCFAC00[0] + 48;
      }
      else
      {
        if (!explicit) {
          llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EBCFAC00, (void *(*)(void))sub_1CD059090, (void (*)(void *))sub_1CD059908);
        }
        uint64_t v4 = qword_1EBCFAC00[0] + 16;
      }
    }
    else
    {
      if (!atomic_load_explicit(qword_1EBCFAC00, memory_order_acquire)) {
        llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EBCFAC00, (void *(*)(void))sub_1CD059090, (void (*)(void *))sub_1CD059908);
      }
      uint64_t v4 = qword_1EBCFAC00[0] + 32;
    }
  }
  else
  {
    if (!atomic_load_explicit(qword_1EBCFAC00, memory_order_acquire)) {
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EBCFAC00, (void *(*)(void))sub_1CD059090, (void (*)(void *))sub_1CD059908);
    }
    uint64_t v4 = qword_1EBCFAC00[0];
  }

  sub_1CD0551C4(v4, a2, a3, a4);
}

atomic_ullong sub_1CD05516C()
{
  if (!atomic_load_explicit(qword_1EBCFAC00, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EBCFAC00, (void *(*)(void))sub_1CD059090, (void (*)(void *))sub_1CD059908);
  }
  return qword_1EBCFAC00[0];
}

void sub_1CD0551C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = MEMORY[0x1F4188790](a1, a2, a3, a4);
  v122[256] = *MEMORY[0x1E4F143B8];
  if (!atomic_load_explicit(&qword_1EBCFABE8, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1EBCFABE8, (void *(*)(void))sub_1CD05B850, (void (*)(void *))sub_1CD05B978);
  }
  uint64_t v5 = *(void *)(qword_1EBCFABE8 + 336);
  size_t v120 = v122;
  uint64_t v121 = 0x8000000000;
  sub_1CD05B550(*(void **)(v5 + 128), *(_DWORD *)(v5 + 136), (uint64_t)&v120, *(unsigned __int8 *)(v4 + 8));
  unsigned int __nel = 0;
  if (!atomic_load_explicit(&qword_1EBCFABE8, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1EBCFABE8, (void *(*)(void))sub_1CD05B850, (void (*)(void *))sub_1CD05B978);
  }
  uint64_t v116 = (uint64_t (***)(void, void **, llvm::raw_ostream *))v4;
  uint64_t v7 = *(void *)(qword_1EBCFABE8 + 280);
  int v8 = (unsigned int *)(qword_1EBCFABE8 + 288);
  if (v7 == *(void *)(qword_1EBCFABE8 + 272)) {
    int v8 = (unsigned int *)(qword_1EBCFABE8 + 292);
  }
  uint64_t v9 = *v8;
  if (v9)
  {
    uint64_t v10 = 8 * v9;
    size_t v11 = *(unint64_t **)(qword_1EBCFABE8 + 280);
    while (*v11 >= 0xFFFFFFFFFFFFFFFELL)
    {
      ++v11;
      v10 -= 8;
      if (!v10) {
        goto LABEL_23;
      }
    }
  }
  else
  {
    size_t v11 = *(unint64_t **)(qword_1EBCFABE8 + 280);
  }
  uint64_t v12 = (unint64_t *)(v7 + 8 * v9);
  if (v11 != v12)
  {
    unint64_t v13 = (uint64_t *)*v11;
LABEL_15:
    if (v13[1])
    {
      if (__nel >= 0x80uLL) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      int v14 = &v118 + 2 * __nel;
      *int v14 = *v13;
      v14[1] = (uint64_t)v13;
      ++__nel;
    }
    unsigned int v15 = v11 + 1;
    while (v15 != v12)
    {
      unint64_t v16 = *v15++;
      unint64_t v13 = (uint64_t *)v16;
      if (v16 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        size_t v11 = v15 - 1;
        goto LABEL_15;
      }
    }
  }
LABEL_23:
  if (__nel >= 2) {
    qsort(&v118, __nel, 0x10uLL, (int (__cdecl *)(const void *, const void *))sub_1CD05B818);
  }
  if (!atomic_load_explicit(&qword_1EBCFABE8, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1EBCFABE8, (void *(*)(void))sub_1CD05B850, (void (*)(void *))sub_1CD05B978);
  }
  if (*(void *)(qword_1EBCFABE8 + 32))
  {
    unsigned int v17 = (llvm::raw_ostream *)llvm::outs(v6);
    unsigned int v18 = v17;
    uint64_t v19 = *((void *)v17 + 4);
    if ((unint64_t)(*((void *)v17 + 3) - v19) > 9)
    {
      *(_WORD *)(v19 + 8) = 8250;
      *(void *)uint64_t v19 = *(void *)"OVERVIEW: ";
      *((void *)v17 + 4) += 10;
    }
    else
    {
      llvm::raw_ostream::write(v17, "OVERVIEW: ", 0xAuLL);
    }
    if (!atomic_load_explicit(&qword_1EBCFABE8, memory_order_acquire)) {
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1EBCFABE8, (void *(*)(void))sub_1CD05B850, (void (*)(void *))sub_1CD05B978);
    }
    int v20 = *(const void **)(qword_1EBCFABE8 + 24);
    unint64_t v21 = *(void *)(qword_1EBCFABE8 + 32);
    uint64_t v6 = (llvm *)*((void *)v18 + 4);
    if (v21 <= *((void *)v18 + 3) - (void)v6)
    {
      if (v21)
      {
        memcpy(v6, v20, *(void *)(qword_1EBCFABE8 + 32));
        uint64_t v6 = (llvm *)(*((void *)v18 + 4) + v21);
        *((void *)v18 + 4) = v6;
      }
    }
    else
    {
      llvm::raw_ostream::write(v18, (const char *)v20, *(void *)(qword_1EBCFABE8 + 32));
      uint64_t v6 = (llvm *)*((void *)v18 + 4);
    }
    if (*((llvm **)v18 + 3) == v6)
    {
      uint64_t v6 = llvm::raw_ostream::write(v18, "\n", 1uLL);
    }
    else
    {
      *(unsigned char *)uint64_t v6 = 10;
      ++*((void *)v18 + 4);
    }
  }
  if (!atomic_load_explicit(llvm::cl::TopLevelSubCommand, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)llvm::cl::TopLevelSubCommand, (void *(*)(void))sub_1CD83084C, (void (*)(void *))sub_1CD8308C4);
  }
  if (v5 == llvm::cl::TopLevelSubCommand[0])
  {
    uint64_t v28 = (llvm::raw_ostream *)llvm::outs(v6);
    uint64_t v29 = v28;
    uint64_t v30 = (_DWORD *)*((void *)v28 + 4);
    if (*((void *)v28 + 3) - (void)v30 > 6uLL)
    {
      *(_DWORD *)((char *)v30 + 3) = 540689735;
      *uint64_t v30 = 1195463509;
      *((void *)v28 + 4) += 7;
    }
    else
    {
      llvm::raw_ostream::write(v28, "USAGE: ", 7uLL);
    }
    if (!atomic_load_explicit(&qword_1EBCFABE8, memory_order_acquire)) {
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1EBCFABE8, (void *(*)(void))sub_1CD05B850, (void (*)(void *))sub_1CD05B978);
    }
    char v31 = *(unsigned char *)(qword_1EBCFABE8 + 23);
    if (v31 >= 0) {
      uint64_t v32 = (const char *)qword_1EBCFABE8;
    }
    else {
      uint64_t v32 = *(const char **)qword_1EBCFABE8;
    }
    if (v31 >= 0) {
      size_t v33 = v31 & 0x7F;
    }
    else {
      size_t v33 = *(void *)(qword_1EBCFABE8 + 8);
    }
    char v34 = llvm::raw_ostream::write(v29, v32, v33);
    if (__nel >= 3)
    {
      char v34 = (llvm *)llvm::outs(v34);
      size_t v35 = (void *)*((void *)v34 + 4);
      if (*((void *)v34 + 3) - (void)v35 > 0xCuLL)
      {
        qmemcpy(v35, " [subcommand]", 13);
        *((void *)v34 + 4) += 13;
      }
      else
      {
        char v34 = llvm::raw_ostream::write(v34, " [subcommand]", 0xDuLL);
      }
    }
    size_t v36 = llvm::outs(v34);
    uint64_t v37 = v36[4];
    if ((unint64_t)(v36[3] - v37) <= 9) {
      goto LABEL_89;
    }
    *(_WORD *)(v37 + 8) = 23923;
    *(void *)uint64_t v37 = *(void *)" [options]";
    v36[4] += 10;
  }
  else
  {
    if (*(void *)(v5 + 24))
    {
      unint64_t v22 = (llvm::raw_ostream *)llvm::outs(v6);
      char v23 = v22;
      uint64_t v24 = *((void *)v22 + 4);
      if ((unint64_t)(*((void *)v22 + 3) - v24) > 0xB)
      {
        *(_DWORD *)(v24 + 8) = 656426062;
        *(void *)uint64_t v24 = *(void *)"SUBCOMMAND '";
        int v25 = (unsigned char *)(*((void *)v22 + 4) + 12);
        *((void *)v23 + 4) = v25;
      }
      else
      {
        llvm::raw_ostream::write(v22, "SUBCOMMAND '", 0xCuLL);
        int v25 = (unsigned char *)*((void *)v23 + 4);
      }
      int v26 = *(const void **)v5;
      unint64_t v27 = *(void *)(v5 + 8);
      if (v27 <= *((void *)v23 + 3) - (void)v25)
      {
        if (v27)
        {
          memcpy(v25, v26, *(void *)(v5 + 8));
          int v25 = (unsigned char *)(*((void *)v23 + 4) + v27);
          *((void *)v23 + 4) = v25;
        }
      }
      else
      {
        llvm::raw_ostream::write(v23, (const char *)v26, *(void *)(v5 + 8));
        int v25 = (unsigned char *)*((void *)v23 + 4);
      }
      if (*((void *)v23 + 3) - (void)v25 > 2uLL)
      {
        v25[2] = 32;
        *(_WORD *)int v25 = 14887;
        uint64_t v6 = (llvm *)(*((void *)v23 + 4) + 3);
        *((void *)v23 + 4) = v6;
      }
      else
      {
        llvm::raw_ostream::write(v23, "': ", 3uLL);
        uint64_t v6 = (llvm *)*((void *)v23 + 4);
      }
      size_t v38 = *(const void **)(v5 + 16);
      unint64_t v39 = *(void *)(v5 + 24);
      if (v39 <= *((void *)v23 + 3) - (void)v6)
      {
        if (v39)
        {
          memcpy(v6, v38, *(void *)(v5 + 24));
          uint64_t v6 = (llvm *)(*((void *)v23 + 4) + v39);
          *((void *)v23 + 4) = v6;
        }
      }
      else
      {
        llvm::raw_ostream::write(v23, (const char *)v38, *(void *)(v5 + 24));
        uint64_t v6 = (llvm *)*((void *)v23 + 4);
      }
      if (*((void *)v23 + 3) - (void)v6 > 1uLL)
      {
        *(_WORD *)uint64_t v6 = 2570;
        *((void *)v23 + 4) += 2;
      }
      else
      {
        uint64_t v6 = llvm::raw_ostream::write(v23, "\n\n", 2uLL);
      }
    }
    uint64_t v40 = (llvm::raw_ostream *)llvm::outs(v6);
    uint64_t v41 = v40;
    uint64_t v42 = (_DWORD *)*((void *)v40 + 4);
    if (*((void *)v40 + 3) - (void)v42 > 6uLL)
    {
      *(_DWORD *)((char *)v42 + 3) = 540689735;
      *uint64_t v42 = 1195463509;
      *((void *)v40 + 4) += 7;
    }
    else
    {
      llvm::raw_ostream::write(v40, "USAGE: ", 7uLL);
    }
    if (!atomic_load_explicit(&qword_1EBCFABE8, memory_order_acquire)) {
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1EBCFABE8, (void *(*)(void))sub_1CD05B850, (void (*)(void *))sub_1CD05B978);
    }
    char v43 = *(unsigned char *)(qword_1EBCFABE8 + 23);
    if (v43 >= 0) {
      unint64_t v44 = (const char *)qword_1EBCFABE8;
    }
    else {
      unint64_t v44 = *(const char **)qword_1EBCFABE8;
    }
    if (v43 >= 0) {
      size_t v45 = v43 & 0x7F;
    }
    else {
      size_t v45 = *(void *)(qword_1EBCFABE8 + 8);
    }
    llvm::raw_ostream::write(v41, v44, v45);
    uint64_t v46 = (unsigned char *)*((void *)v41 + 4);
    if (*((unsigned char **)v41 + 3) == v46)
    {
      llvm::raw_ostream::write(v41, " ", 1uLL);
      size_t v36 = (void *)*((void *)v41 + 4);
    }
    else
    {
      *uint64_t v46 = 32;
      size_t v36 = (void *)(*((void *)v41 + 4) + 1);
      *((void *)v41 + 4) = v36;
    }
    size_t v47 = *(const void **)v5;
    unint64_t v48 = *(void *)(v5 + 8);
    if (v48 <= *((void *)v41 + 3) - (void)v36)
    {
      if (v48)
      {
        memcpy(v36, v47, *(void *)(v5 + 8));
        size_t v36 = (void *)(*((void *)v41 + 4) + v48);
        *((void *)v41 + 4) = v36;
      }
    }
    else
    {
      llvm::raw_ostream::write(v41, (const char *)v47, *(void *)(v5 + 8));
      size_t v36 = (void *)*((void *)v41 + 4);
    }
    if (*((void *)v41 + 3) - (void)v36 <= 9uLL)
    {
      size_t v36 = v41;
LABEL_89:
      size_t v36 = llvm::raw_ostream::write((llvm::raw_ostream *)v36, " [options]", 0xAuLL);
      goto LABEL_90;
    }
    *((_WORD *)v36 + 4) = 23923;
    *size_t v36 = *(void *)" [options]";
    *((void *)v41 + 4) += 10;
  }
LABEL_90:
  uint64_t v49 = *(unsigned int *)(v5 + 40);
  if (v49)
  {
    uint64_t v50 = *(void *)(v5 + 32);
    uint64_t v51 = 8 * v49;
    do
    {
      unint64_t v52 = *(void **)v50;
      if (*(void *)(*(void *)v50 + 24))
      {
        uint64_t v53 = (llvm::raw_ostream *)llvm::outs((llvm *)v36);
        uint64_t v54 = v53;
        uint64_t v55 = *((void *)v53 + 4);
        if ((unint64_t)(*((void *)v53 + 3) - v55) > 2)
        {
          *(unsigned char *)(v55 + 2) = 45;
          *(_WORD *)uint64_t v55 = 11552;
          size_t v36 = (void *)(*((void *)v53 + 4) + 3);
          *((void *)v54 + 4) = v36;
        }
        else
        {
          llvm::raw_ostream::write(v53, " --", 3uLL);
          size_t v36 = (void *)*((void *)v54 + 4);
        }
        uint64_t v56 = (const void *)v52[2];
        unint64_t v57 = v52[3];
        if (v57 <= *((void *)v54 + 3) - (void)v36)
        {
          if (v57)
          {
            size_t v36 = memcpy(v36, v56, v52[3]);
            *((void *)v54 + 4) += v57;
          }
        }
        else
        {
          size_t v36 = llvm::raw_ostream::write(v54, (const char *)v56, v52[3]);
        }
      }
      uint64_t v58 = (llvm::raw_ostream *)llvm::outs((llvm *)v36);
      uint64_t v59 = v58;
      uint64_t v60 = (unsigned char *)*((void *)v58 + 4);
      if (*((unsigned char **)v58 + 3) == v60)
      {
        llvm::raw_ostream::write(v58, " ", 1uLL);
        size_t v36 = (void *)*((void *)v59 + 4);
      }
      else
      {
        *uint64_t v60 = 32;
        size_t v36 = (void *)(*((void *)v58 + 4) + 1);
        *((void *)v59 + 4) = v36;
      }
      uint64_t v61 = (const void *)v52[4];
      unint64_t v62 = v52[5];
      if (v62 <= *((void *)v59 + 3) - (void)v36)
      {
        if (v62)
        {
          size_t v36 = memcpy(v36, v61, v52[5]);
          *((void *)v59 + 4) += v62;
        }
      }
      else
      {
        size_t v36 = llvm::raw_ostream::write(v59, (const char *)v61, v52[5]);
      }
      v50 += 8;
      v51 -= 8;
    }
    while (v51);
  }
  if (*(void *)(v5 + 160))
  {
    uint64_t v63 = (llvm::raw_ostream *)llvm::outs((llvm *)v36);
    char v64 = v63;
    BOOL v65 = (unsigned char *)*((void *)v63 + 4);
    if (*((unsigned char **)v63 + 3) == v65)
    {
      llvm::raw_ostream::write(v63, " ", 1uLL);
      size_t v36 = (void *)*((void *)v64 + 4);
    }
    else
    {
      *BOOL v65 = 32;
      size_t v36 = (void *)(*((void *)v63 + 4) + 1);
      *((void *)v64 + 4) = v36;
    }
    uint64_t v66 = *(void *)(v5 + 160);
    size_t v67 = *(const void **)(v66 + 32);
    size_t v68 = *(void *)(v66 + 40);
    if (v68 <= *((void *)v64 + 3) - (void)v36)
    {
      if (v68)
      {
        size_t v36 = memcpy(v36, v67, v68);
        *((void *)v64 + 4) += v68;
      }
    }
    else
    {
      size_t v36 = llvm::raw_ostream::write(v64, (const char *)v67, v68);
    }
  }
  if (!atomic_load_explicit(llvm::cl::TopLevelSubCommand, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)llvm::cl::TopLevelSubCommand, (void *(*)(void))sub_1CD83084C, (void (*)(void *))sub_1CD8308C4);
  }
  if (v5 == llvm::cl::TopLevelSubCommand[0])
  {
    uint64_t v69 = __nel;
    if (__nel)
    {
      long long v70 = 0;
      char v71 = (const char **)&v118;
      do
      {
        __int16 v72 = *v71;
        v71 += 2;
        unint64_t v73 = (llvm *)strlen(v72);
        if (v70 <= v73) {
          long long v70 = v73;
        }
        --v69;
      }
      while (v69);
      unint64_t v74 = (llvm::raw_ostream *)llvm::outs(v73);
      uint64_t v75 = (_WORD *)*((void *)v74 + 4);
      if (*((void *)v74 + 3) - (void)v75 > 1uLL)
      {
        *uint64_t v75 = 2570;
        *((void *)v74 + 4) += 2;
      }
      else
      {
        unint64_t v74 = llvm::raw_ostream::write(v74, "\n\n", 2uLL);
      }
      BOOL v76 = (llvm::raw_ostream *)llvm::outs(v74);
      unint64_t v77 = (void *)*((void *)v76 + 4);
      if (*((void *)v76 + 3) - (void)v77 > 0xDuLL)
      {
        qmemcpy(v77, "SUBCOMMANDS:\n\n", 14);
        *((void *)v76 + 4) += 14;
      }
      else
      {
        BOOL v76 = llvm::raw_ostream::write(v76, "SUBCOMMANDS:\n\n", 0xEuLL);
      }
      uint64_t v78 = 16 * __nel;
      unint64_t v79 = &v119;
      do
      {
        int v80 = (llvm::raw_ostream *)llvm::outs(v76);
        size_t v81 = v80;
        int v82 = (_WORD *)*((void *)v80 + 4);
        if (*((void *)v80 + 3) - (void)v82 > 1uLL)
        {
          *int v82 = 8224;
          *((void *)v80 + 4) += 2;
        }
        else
        {
          int v80 = llvm::raw_ostream::write(v80, "  ", 2uLL);
        }
        uint64_t v83 = (const void *)*(v79 - 1);
        if (v83)
        {
          size_t v84 = strlen((const char *)*(v79 - 1));
          int v80 = (llvm::raw_ostream *)*((void *)v81 + 4);
          if (v84 <= *((void *)v81 + 3) - (void)v80)
          {
            if (v84)
            {
              int v80 = (llvm::raw_ostream *)memcpy(v80, v83, v84);
              *((void *)v81 + 4) += v84;
            }
          }
          else
          {
            int v80 = llvm::raw_ostream::write(v81, (const char *)v83, v84);
          }
        }
        if (*(void *)(*v79 + 24))
        {
          unint64_t v85 = (llvm::raw_ostream *)llvm::outs(v80);
          int v86 = strlen((const char *)*(v79 - 1));
          uint64_t v87 = llvm::raw_ostream::indent(v85, (int)v70 - v86);
          uint64_t v88 = (llvm::raw_ostream *)llvm::outs(v87);
          size_t v89 = v88;
          uint64_t v90 = *((void *)v88 + 4);
          if ((unint64_t)(*((void *)v88 + 3) - v90) > 2)
          {
            *(unsigned char *)(v90 + 2) = 32;
            *(_WORD *)uint64_t v90 = 11552;
            int v80 = (llvm::raw_ostream *)(*((void *)v88 + 4) + 3);
            *((void *)v89 + 4) = v80;
          }
          else
          {
            llvm::raw_ostream::write(v88, " - ", 3uLL);
            int v80 = (llvm::raw_ostream *)*((void *)v89 + 4);
          }
          BOOL v91 = *(const void **)(*v79 + 16);
          unint64_t v92 = *(void *)(*v79 + 24);
          if (v92 <= *((void *)v89 + 3) - (void)v80)
          {
            if (v92)
            {
              int v80 = (llvm::raw_ostream *)memcpy(v80, v91, *(void *)(*v79 + 24));
              *((void *)v89 + 4) += v92;
            }
          }
          else
          {
            int v80 = llvm::raw_ostream::write(v89, (const char *)v91, *(void *)(*v79 + 24));
          }
        }
        BOOL v76 = (llvm::raw_ostream *)llvm::outs(v80);
        char v93 = (unsigned char *)*((void *)v76 + 4);
        if (*((unsigned char **)v76 + 3) == v93)
        {
          BOOL v76 = llvm::raw_ostream::write(v76, "\n", 1uLL);
        }
        else
        {
          *char v93 = 10;
          ++*((void *)v76 + 4);
        }
        v79 += 2;
        v78 -= 16;
      }
      while (v78);
      unint64_t v94 = (llvm::raw_ostream *)llvm::outs(v76);
      char v95 = (unsigned char *)*((void *)v94 + 4);
      if (*((unsigned char **)v94 + 3) == v95)
      {
        unint64_t v94 = llvm::raw_ostream::write(v94, "\n", 1uLL);
      }
      else
      {
        *char v95 = 10;
        ++*((void *)v94 + 4);
      }
      BOOL v96 = (llvm::raw_ostream *)llvm::outs(v94);
      int v97 = v96;
      size_t v98 = (void *)*((void *)v96 + 4);
      if (*((void *)v96 + 3) - (void)v98 > 7uLL)
      {
        *size_t v98 = 0x2220657079542020;
        *((void *)v96 + 4) += 8;
      }
      else
      {
        llvm::raw_ostream::write(v96, "  Type \"", 8uLL);
      }
      if (!atomic_load_explicit(&qword_1EBCFABE8, memory_order_acquire)) {
        llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1EBCFABE8, (void *(*)(void))sub_1CD05B850, (void (*)(void *))sub_1CD05B978);
      }
      char v99 = *(unsigned char *)(qword_1EBCFABE8 + 23);
      if (v99 >= 0) {
        long long v100 = (const char *)qword_1EBCFABE8;
      }
      else {
        long long v100 = *(const char **)qword_1EBCFABE8;
      }
      if (v99 >= 0) {
        size_t v101 = v99 & 0x7F;
      }
      else {
        size_t v101 = *(void *)(qword_1EBCFABE8 + 8);
      }
      size_t v36 = llvm::raw_ostream::write(v97, v100, v101);
      unint64_t v102 = (void *)*((void *)v97 + 4);
      if (*((void *)v97 + 3) - (void)v102 > 0x3EuLL)
      {
        qmemcpy(v102, " <subcommand> --help\" to get more help on a specific subcommand", 63);
        *((void *)v97 + 4) += 63;
      }
      else
      {
        size_t v36 = llvm::raw_ostream::write(v97, " <subcommand> --help\" to get more help on a specific subcommand", 0x3FuLL);
      }
    }
  }
  long long v103 = (llvm::raw_ostream *)llvm::outs((llvm *)v36);
  unint64_t v104 = (_WORD *)*((void *)v103 + 4);
  if (*((void *)v103 + 3) - (void)v104 > 1uLL)
  {
    *unint64_t v104 = 2570;
    *((void *)v103 + 4) += 2;
  }
  else
  {
    long long v103 = llvm::raw_ostream::write(v103, "\n\n", 2uLL);
  }
  if (v121)
  {
    uint64_t v105 = 0;
    unsigned int v106 = 0;
    uint64_t v107 = 16 * v121;
    do
    {
      long long v103 = (llvm::raw_ostream *)(*(uint64_t (**)(void))(**(void **)((char *)v120 + v105 + 8) + 40))(*(void *)((char *)v120 + v105 + 8));
      if (v106 <= v103) {
        unsigned int v106 = v103;
      }
      v105 += 16;
    }
    while (v107 != v105);
  }
  else
  {
    unsigned int v106 = 0;
  }
  char v108 = (llvm::raw_ostream *)llvm::outs(v103);
  uint64_t v109 = *((void *)v108 + 4);
  if ((unint64_t)(*((void *)v108 + 3) - v109) > 8)
  {
    *(unsigned char *)(v109 + 8) = 10;
    *(void *)uint64_t v109 = *(void *)"OPTIONS:\n";
    *((void *)v108 + 4) += 9;
  }
  else
  {
    llvm::raw_ostream::write(v108, "OPTIONS:\n", 9uLL);
  }
  uint64_t v110 = (llvm *)(**v116)(v116, &v120, v106);
  if (!atomic_load_explicit(&qword_1EBCFABE8, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1EBCFABE8, (void *(*)(void))sub_1CD05B850, (void (*)(void *))sub_1CD05B978);
  }
  uint64_t v111 = *(void *)(qword_1EBCFABE8 + 40);
  uint64_t v112 = *(void *)(qword_1EBCFABE8 + 48);
  while (v111 != v112)
  {
    unsigned int v113 = (llvm::raw_ostream *)llvm::outs(v110);
    v114 = *(const void **)v111;
    unint64_t v115 = *(void *)(v111 + 8);
    uint64_t v110 = (llvm *)*((void *)v113 + 4);
    if (v115 <= *((void *)v113 + 3) - (void)v110)
    {
      if (v115)
      {
        uint64_t v110 = (llvm *)memcpy(v110, v114, *(void *)(v111 + 8));
        *((void *)v113 + 4) += v115;
      }
    }
    else
    {
      uint64_t v110 = llvm::raw_ostream::write(v113, (const char *)v114, *(void *)(v111 + 8));
    }
    v111 += 16;
  }
  if (!atomic_load_explicit(&qword_1EBCFABE8, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1EBCFABE8, (void *(*)(void))sub_1CD05B850, (void (*)(void *))sub_1CD05B978);
  }
  *(void *)(qword_1EBCFABE8 + 48) = *(void *)(qword_1EBCFABE8 + 40);
  if (v120 != v122) {
    free(v120);
  }
}

void sub_1CD0561A4(llvm *a1)
{
  char v1 = (llvm::raw_ostream *)llvm::outs(a1);
  uint64_t v2 = v1;
  uint64_t v3 = (void *)*((void *)v1 + 4);
  if (*((void *)v1 + 3) - (void)v3 > 0x1AuLL)
  {
    qmemcpy(v3, "LLVM (http://llvm.org/):\n  ", 27);
    uint64_t v4 = (_DWORD *)(*((void *)v1 + 4) + 27);
    *((void *)v1 + 4) = v4;
  }
  else
  {
    char v1 = llvm::raw_ostream::write(v1, "LLVM (http://llvm.org/):\n  ", 0x1BuLL);
    uint64_t v4 = (_DWORD *)*((void *)v2 + 4);
  }
  if (*((void *)v2 + 3) - (void)v4 > 3uLL)
  {
    *uint64_t v4 = 1297501260;
    uint64_t v5 = *((void *)v2 + 4) + 4;
    *((void *)v2 + 4) = v5;
  }
  else
  {
    char v1 = llvm::raw_ostream::write(v2, "LLVM", 4uLL);
    uint64_t v5 = *((void *)v2 + 4);
  }
  if ((unint64_t)(*((void *)v2 + 3) - v5) > 8)
  {
    *(unsigned char *)(v5 + 8) = 32;
    *(void *)uint64_t v5 = *(void *)" version ";
    uint64_t v6 = *((void *)v2 + 4) + 9;
    *((void *)v2 + 4) = v6;
  }
  else
  {
    char v1 = llvm::raw_ostream::write(v2, " version ", 9uLL);
    uint64_t v6 = *((void *)v2 + 4);
  }
  if ((unint64_t)(*((void *)v2 + 3) - v6) > 8)
  {
    *(unsigned char *)(v6 + 8) = 56;
    *(void *)uint64_t v6 = *(void *)"32023.408";
    uint64_t v7 = *((void *)v2 + 4) + 9;
    *((void *)v2 + 4) = v7;
  }
  else
  {
    char v1 = llvm::raw_ostream::write(v2, "32023.408", 9uLL);
    uint64_t v7 = *((void *)v2 + 4);
  }
  if ((unint64_t)(*((void *)v2 + 3) - v7) > 2)
  {
    *(unsigned char *)(v7 + 2) = 32;
    *(_WORD *)uint64_t v7 = 8202;
    int v8 = (void *)(*((void *)v2 + 4) + 3);
    *((void *)v2 + 4) = v8;
  }
  else
  {
    char v1 = llvm::raw_ostream::write(v2, "\n  ", 3uLL);
    int v8 = (void *)*((void *)v2 + 4);
  }
  if (*((void *)v2 + 3) - (void)v8 > 0xEuLL)
  {
    qmemcpy(v8, "Optimized build", 15);
    *((void *)v2 + 4) += 15;
  }
  else
  {
    char v1 = llvm::raw_ostream::write(v2, "Optimized build", 0xFuLL);
  }
  HostCPUName = llvm::sys::getHostCPUName(v1);
  if (v10 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  size_t v11 = HostCPUName;
  size_t v12 = v10;
  if (v10 >= 0x17)
  {
    uint64_t v14 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v10 | 7) != 0x17) {
      uint64_t v14 = v10 | 7;
    }
    uint64_t v15 = v14 + 1;
    p_dst = (void **)operator new(v14 + 1);
    size_t v32 = v12;
    int64_t v33 = v15 | 0x8000000000000000;
    std::string __dst = p_dst;
    goto LABEL_20;
  }
  HIBYTE(v33) = v10;
  p_dst = (void **)&__dst;
  if (v10) {
LABEL_20:
  }
    memmove(p_dst, v11, v12);
  *((unsigned char *)p_dst + v12) = 0;
  unint64_t v16 = HIBYTE(v33);
  if (v33 >= 0) {
    size_t v17 = HIBYTE(v33) & 0x7F;
  }
  else {
    size_t v17 = v32;
  }
  if (v17 == 7)
  {
    if (v33 < 0)
    {
      unsigned int v18 = __dst;
      unint64_t v16 = v32;
    }
    else
    {
      unsigned int v18 = (void **)&__dst;
    }
    size_t v19 = v16 >= 7 ? 7 : v16;
    if (!memcmp(v18, "generic", v19) && v16 == 7) {
      MEMORY[0x1D25D9630](&__dst, "(unknown)");
    }
  }
  int v20 = (_WORD *)*((void *)v2 + 4);
  if (*((void *)v2 + 3) - (void)v20 > 1uLL)
  {
    *int v20 = 2606;
    uint64_t v21 = *((void *)v2 + 4) + 2;
    *((void *)v2 + 4) = v21;
  }
  else
  {
    llvm::raw_ostream::write(v2, ".\n", 2uLL);
    uint64_t v21 = *((void *)v2 + 4);
  }
  if ((unint64_t)(*((void *)v2 + 3) - v21) > 0x11)
  {
    *(_WORD *)(v21 + 16) = 8250;
    *(_OWORD *)uint64_t v21 = *(_OWORD *)"  Default target: ";
    *((void *)v2 + 4) += 18;
  }
  else
  {
    llvm::raw_ostream::write(v2, "  Default target: ", 0x12uLL);
  }
  llvm::sys::getDefaultTargetTriple((uint64_t)__p);
  if (v30 >= 0) {
    unint64_t v22 = __p;
  }
  else {
    unint64_t v22 = (void **)__p[0];
  }
  if (v30 >= 0) {
    size_t v23 = v30 & 0x7F;
  }
  else {
    size_t v23 = (size_t)__p[1];
  }
  llvm::raw_ostream::write(v2, (const char *)v22, v23);
  uint64_t v24 = (unsigned char *)*((void *)v2 + 4);
  if ((unint64_t)v24 >= *((void *)v2 + 3))
  {
    llvm::raw_ostream::write(v2, 10);
  }
  else
  {
    *((void *)v2 + 4) = v24 + 1;
    *uint64_t v24 = 10;
  }
  uint64_t v25 = *((void *)v2 + 4);
  if ((unint64_t)(*((void *)v2 + 3) - v25) > 0xB)
  {
    *(_DWORD *)(v25 + 8) = 540693840;
    *(void *)uint64_t v25 = *(void *)"  Host CPU: ";
    *((void *)v2 + 4) += 12;
  }
  else
  {
    llvm::raw_ostream::write(v2, "  Host CPU: ", 0xCuLL);
  }
  if (v33 >= 0) {
    int v26 = (const char *)&__dst;
  }
  else {
    int v26 = (const char *)__dst;
  }
  if (v33 >= 0) {
    size_t v27 = HIBYTE(v33) & 0x7F;
  }
  else {
    size_t v27 = v32;
  }
  llvm::raw_ostream::write(v2, v26, v27);
  if (v30 < 0) {
    operator delete(__p[0]);
  }
  uint64_t v28 = (unsigned char *)*((void *)v2 + 4);
  if ((unint64_t)v28 >= *((void *)v2 + 3))
  {
    llvm::raw_ostream::write(v2, 10);
  }
  else
  {
    *((void *)v2 + 4) = v28 + 1;
    *uint64_t v28 = 10;
  }
  if (SHIBYTE(v33) < 0) {
    operator delete(__dst);
  }
}

uint64_t llvm::cl::SetVersionPrinter(uint64_t a1)
{
  v9[3] = *MEMORY[0x1E4F143B8];
  if (!atomic_load_explicit(qword_1EBCFAC00, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EBCFAC00, (void *(*)(void))sub_1CD059090, (void (*)(void *))sub_1CD059908);
  }
  atomic_ullong v2 = qword_1EBCFAC00[0];
  uint64_t v3 = (void *)(qword_1EBCFAC00[0] + 1384);
  sub_1CD05BB58((uint64_t)v7, a1);
  if (v7 != v3)
  {
    uint64_t v4 = v8;
    uint64_t v5 = *(void **)(v2 + 1408);
    if (v8 == v7)
    {
      if (v5 == v3)
      {
        (*(void (**)(void *, void *))(v7[0] + 24))(v7, v9);
        (*(void (**)(void *))(*v8 + 32))(v8);
        int v8 = 0;
        (*(void (**)(void, void *))(**(void **)(v2 + 1408) + 24))(*(void *)(v2 + 1408), v7);
        (*(void (**)(void))(**(void **)(v2 + 1408) + 32))(*(void *)(v2 + 1408));
        *(void *)(v2 + 1408) = 0;
        int v8 = v7;
        (*(void (**)(void *, void *))(v9[0] + 24))(v9, v3);
        (*(void (**)(void *))(v9[0] + 32))(v9);
      }
      else
      {
        (*(void (**)(void *, void *))(v7[0] + 24))(v7, v3);
        (*(void (**)(void *))(*v8 + 32))(v8);
        int v8 = *(void **)(v2 + 1408);
      }
      *(void *)(v2 + 1408) = v3;
    }
    else if (v5 == v3)
    {
      (*(void (**)(void *, void *))(*(void *)(v2 + 1384) + 24))(v3, v7);
      (*(void (**)(void))(**(void **)(v2 + 1408) + 32))(*(void *)(v2 + 1408));
      *(void *)(v2 + 1408) = v8;
      int v8 = v7;
    }
    else
    {
      int v8 = *(void **)(v2 + 1408);
      *(void *)(v2 + 1408) = v4;
    }
  }
  uint64_t result = (uint64_t)v8;
  if (v8 == v7) {
    return (*(uint64_t (**)(void *))(v7[0] + 32))(v7);
  }
  if (v8) {
    return (*(uint64_t (**)(void))(*v8 + 40))();
  }
  return result;
}

void llvm::cl::AddExtraVersionPrinter(uint64_t a1)
{
  if (!atomic_load_explicit(qword_1EBCFAC00, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EBCFAC00, (void *(*)(void))sub_1CD059090, (void (*)(void *))sub_1CD059908);
  }
  atomic_ullong v2 = qword_1EBCFAC00[0];
  unint64_t v3 = *(void *)(qword_1EBCFAC00[0] + 1424);
  unint64_t v4 = *(void *)(qword_1EBCFAC00[0] + 1432);
  if (v3 >= v4)
  {
    uint64_t v6 = *(void *)(qword_1EBCFAC00[0] + 1416);
    uint64_t v7 = (uint64_t)(v3 - v6) >> 5;
    if ((unint64_t)(v7 + 1) >> 59) {
      abort();
    }
    uint64_t v8 = v4 - v6;
    uint64_t v9 = v8 >> 4;
    if (v8 >> 4 <= (unint64_t)(v7 + 1)) {
      uint64_t v9 = v7 + 1;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v10 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v10 = v9;
    }
    atomic_ullong v21 = qword_1EBCFAC00[0] + 1432;
    if (v10)
    {
      if (v10 >> 59) {
        sub_1CB833614();
      }
      size_t v11 = (char *)operator new(32 * v10);
    }
    else
    {
      size_t v11 = 0;
    }
    std::string __p = v11;
    unsigned int v18 = &v11[32 * v7];
    int v20 = &v11[32 * v10];
    sub_1CD05BB58((uint64_t)v18, a1);
    size_t v19 = v18 + 32;
    sub_1CD830E00((void *)(v2 + 1416), &__p);
    uint64_t v5 = *(void *)(v2 + 1424);
    uint64_t v12 = (uint64_t)v18;
    if (v19 != v18)
    {
      unint64_t v13 = v19 - 32;
      uint64_t v14 = v19 - 32;
      do
      {
        uint64_t v15 = (char *)*((void *)v14 + 3);
        if (v14 == v15)
        {
          (*(void (**)(char *))(*(void *)v14 + 32))(v14);
        }
        else if (v15)
        {
          (*(void (**)(char *))(*(void *)v15 + 40))(v15);
        }
        v13 -= 32;
        BOOL v16 = v14 == (char *)v12;
        v14 -= 32;
      }
      while (!v16);
    }
    if (__p) {
      operator delete(__p);
    }
  }
  else
  {
    uint64_t v5 = sub_1CD05BB58(v3, a1) + 32;
  }
  *(void *)(v2 + 1424) = v5;
}

uint64_t llvm::cl::getRegisteredOptions(llvm::cl *this, llvm::cl::SubCommand *a2)
{
  if (!atomic_load_explicit(&qword_1EBCFABE8, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1EBCFABE8, (void *(*)(void))sub_1CD05B850, (void (*)(void *))sub_1CD05B978);
  }
  return (uint64_t)this + 128;
}

void llvm::cl::getRegisteredSubcommands(void *a1@<X8>)
{
  if (!atomic_load_explicit(&qword_1EBCFABE8, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1EBCFABE8, (void *(*)(void))sub_1CD05B850, (void (*)(void *))sub_1CD05B978);
  }
  unint64_t v3 = *(void **)(qword_1EBCFABE8 + 280);
  uint64_t v4 = 288;
  if (v3 == *(void **)(qword_1EBCFABE8 + 272)) {
    uint64_t v4 = 292;
  }
  uint64_t v5 = *(unsigned int *)(qword_1EBCFABE8 + v4);
  uint64_t v6 = &v3[v5];
  if (v5)
  {
    uint64_t v7 = 8 * v5;
    while (*v3 >= 0xFFFFFFFFFFFFFFFELL)
    {
      ++v3;
      v7 -= 8;
      if (!v7)
      {
        unint64_t v3 = v6;
        break;
      }
    }
  }
  *a1 = v3;
  a1[1] = v6;
  a1[2] = v6;
  a1[3] = v6;
}

void llvm::cl::HideUnrelatedOptions(llvm::cl *this, llvm::cl::OptionCategory *a2, llvm::cl::SubCommand *a3)
{
  sub_1CD054360(this);
  uint64_t v5 = *((unsigned int *)a2 + 34);
  if (v5)
  {
    for (uint64_t i = (uint64_t *)*((void *)a2 + 16); !*i || *i == -8; ++i)
      ;
  }
  else
  {
    uint64_t i = (uint64_t *)*((void *)a2 + 16);
  }
  uint64_t v8 = *((void *)a2 + 16) + 8 * v5;
  if (i != (uint64_t *)v8)
  {
    uint64_t v9 = *i;
    do
    {
      uint64_t v10 = *(void *)(v9 + 8);
      uint64_t v11 = *(unsigned int *)(v10 + 72);
      if (v11)
      {
        uint64_t v12 = *(llvm::cl ***)(v10 + 64);
        unint64_t v13 = &v12[v11];
        char v14 = 1;
        do
        {
          while (1)
          {
            uint64_t v15 = *v12;
            if (*v12 != this)
            {
              if (!atomic_load_explicit(qword_1EBCFAC00, memory_order_acquire)) {
                llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EBCFAC00, (void *(*)(void))sub_1CD059090, (void (*)(void *))sub_1CD059908);
              }
              if (v15 != (llvm::cl *)(qword_1EBCFAC00[0] + 96)) {
                break;
              }
            }
            char v14 = 0;
            if (++v12 == v13) {
              goto LABEL_25;
            }
          }
          ++v12;
        }
        while (v12 != v13);
        if ((v14 & 1) == 0) {
          goto LABEL_25;
        }
        uint64_t v10 = *(void *)(v9 + 8);
      }
      *(_WORD *)(v10 + 10) = *(_WORD *)(v10 + 10) & 0xFF9F | 0x40;
      do
      {
LABEL_25:
        uint64_t v16 = i[1];
        ++i;
        uint64_t v9 = v16;
        if (v16) {
          BOOL v17 = v9 == -8;
        }
        else {
          BOOL v17 = 1;
        }
      }
      while (v17);
    }
    while (i != (uint64_t *)v8);
  }
}

void llvm::cl::HideUnrelatedOptions(llvm *a1, uint64_t a2, uint64_t a3)
{
  sub_1CD054360(a1);
  uint64_t v6 = *(unsigned int *)(a3 + 136);
  if (v6)
  {
    for (uint64_t i = *(uint64_t **)(a3 + 128); !*i || *i == -8; ++i)
      ;
  }
  else
  {
    uint64_t i = *(uint64_t **)(a3 + 128);
  }
  uint64_t v19 = *(void *)(a3 + 128) + 8 * v6;
  if (i != (uint64_t *)v19)
  {
    uint64_t v9 = *i;
    do
    {
      uint64_t v10 = *(void *)(v9 + 8);
      uint64_t v11 = *(unsigned int *)(v10 + 72);
      if (v11)
      {
        uint64_t v12 = *(uint64_t **)(v10 + 64);
        unint64_t v13 = &v12[v11];
        char v20 = 1;
        do
        {
          while (1)
          {
            if (a2)
            {
              uint64_t v14 = 8 * a2;
              uint64_t v15 = (char *)a1;
              while (*(void *)v15 != *v12)
              {
                v15 += 8;
                v14 -= 8;
                if (!v14)
                {
                  uint64_t v15 = (char *)a1 + 8 * a2;
                  break;
                }
              }
            }
            else
            {
              uint64_t v15 = (char *)a1;
            }
            if (a2 == (v15 - (char *)a1) >> 3)
            {
              uint64_t v16 = *v12;
              if (!atomic_load_explicit(qword_1EBCFAC00, memory_order_acquire)) {
                llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EBCFAC00, (void *(*)(void))sub_1CD059090, (void (*)(void *))sub_1CD059908);
              }
              if (v16 != qword_1EBCFAC00[0] + 96) {
                break;
              }
            }
            char v20 = 0;
            if (++v12 == v13) {
              goto LABEL_31;
            }
          }
          ++v12;
        }
        while (v12 != v13);
        if ((v20 & 1) == 0) {
          goto LABEL_31;
        }
        uint64_t v10 = *(void *)(v9 + 8);
      }
      *(_WORD *)(v10 + 10) = *(_WORD *)(v10 + 10) & 0xFF9F | 0x40;
      do
      {
LABEL_31:
        uint64_t v17 = i[1];
        ++i;
        uint64_t v9 = v17;
        if (v17) {
          BOOL v18 = v9 == -8;
        }
        else {
          BOOL v18 = 1;
        }
      }
      while (v18);
    }
    while (i != (uint64_t *)v19);
  }
}

void llvm::cl::ResetCommandLineParser(llvm::cl *this)
{
  if (!atomic_load_explicit(&qword_1EBCFABE8, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1EBCFABE8, (void *(*)(void))sub_1CD05B850, (void (*)(void *))sub_1CD05B978);
  }
  uint64_t v1 = qword_1EBCFABE8;
  *(void *)(qword_1EBCFABE8 + 336) = 0;
  if (*(char *)(v1 + 23) < 0)
  {
    **(unsigned char **)uint64_t v1 = 0;
    *(void *)(v1 + 8) = 0;
  }
  else
  {
    *(unsigned char *)uint64_t v1 = 0;
    *(unsigned char *)(v1 + 23) = 0;
  }
  uint64_t v2 = *(void *)(v1 + 112);
  *(void *)(v1 + 24) = 0;
  *(void *)(v1 + 32) = 0;
  *(void *)(v1 + 48) = *(void *)(v1 + 40);
  if (*(void *)(v1 + 120) == v2) {
    goto LABEL_7;
  }
  uint64_t v6 = *(unsigned int *)(v1 + 128);
  if (v6 < 0x21 || 4 * (*(_DWORD *)(v1 + 132) - *(_DWORD *)(v1 + 136)) >= v6)
  {
    memset(*(void **)(v1 + 120), 255, 8 * v6);
LABEL_7:
    *(_DWORD *)(v1 + 132) = 0;
    *(_DWORD *)(v1 + 136) = 0;
    goto LABEL_8;
  }
  llvm::SmallPtrSetImplBase::shrink_and_clear((void **)(v1 + 112));
LABEL_8:
  sub_1CD0571BC(v1);
  unint64_t v3 = *(void **)(v1 + 280);
  if (v3 == *(void **)(v1 + 272))
  {
LABEL_9:
    *(void *)(v1 + 292) = 0;
    goto LABEL_10;
  }
  uint64_t v8 = *(unsigned int *)(v1 + 288);
  if (v8 < 0x21 || 4 * (*(_DWORD *)(v1 + 292) - *(_DWORD *)(v1 + 296)) >= v8)
  {
    memset(v3, 255, 8 * v8);
    goto LABEL_9;
  }
  llvm::SmallPtrSetImplBase::shrink_and_clear((void **)(v1 + 272));
LABEL_10:
  if (!atomic_load_explicit(llvm::cl::TopLevelSubCommand, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)llvm::cl::TopLevelSubCommand, (void *(*)(void))sub_1CD83084C, (void (*)(void *))sub_1CD8308C4);
  }
  atomic_ullong v4 = llvm::cl::TopLevelSubCommand[0];
  *(_DWORD *)(llvm::cl::TopLevelSubCommand[0] + 40) = 0;
  *(_DWORD *)(v4 + 88) = 0;
  sub_1CD67F6F0(v4 + 128);
  *(void *)(v4 + 160) = 0;
  if (!atomic_load_explicit(&llvm::cl::AllSubCommands, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&llvm::cl::AllSubCommands, (void *(*)(void))sub_1CD83084C, (void (*)(void *))sub_1CD8308C4);
  }
  uint64_t v5 = llvm::cl::AllSubCommands;
  *(_DWORD *)(llvm::cl::AllSubCommands + 40) = 0;
  *(_DWORD *)(v5 + 88) = 0;
  sub_1CD67F6F0(v5 + 128);
  *(void *)(v5 + 160) = 0;
  if (!atomic_load_explicit(llvm::cl::TopLevelSubCommand, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)llvm::cl::TopLevelSubCommand, (void *(*)(void))sub_1CD83084C, (void (*)(void *))sub_1CD8308C4);
  }
  sub_1CD0508E0(v1, llvm::cl::TopLevelSubCommand[0]);
  if (!atomic_load_explicit(&llvm::cl::AllSubCommands, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&llvm::cl::AllSubCommands, (void *(*)(void))sub_1CD83084C, (void (*)(void *))sub_1CD8308C4);
  }
  sub_1CD0508E0(v1, llvm::cl::AllSubCommands);
  *(_DWORD *)(v1 + 72) = 0;
}

void sub_1CD0571BC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 280);
  uint64_t v2 = 288;
  if (v1 == *(void *)(a1 + 272)) {
    uint64_t v2 = 292;
  }
  uint64_t v3 = *(unsigned int *)(a1 + v2);
  if (v3)
  {
    uint64_t v4 = 8 * v3;
    for (uint64_t i = *(unint64_t **)(a1 + 280); *i >= 0xFFFFFFFFFFFFFFFELL; ++i)
    {
      v4 -= 8;
      if (!v4) {
        return;
      }
    }
  }
  else
  {
    uint64_t i = *(unint64_t **)(a1 + 280);
  }
  uint64_t v6 = (unint64_t *)(v1 + 8 * v3);
  if (i != v6)
  {
    unint64_t v7 = *i;
LABEL_11:
    uint64_t v8 = *(unsigned int *)(v7 + 136);
    if (v8)
    {
      for (j = *(uint64_t **)(v7 + 128); !*j || *j == -8; ++j)
        ;
    }
    else
    {
      j = *(uint64_t **)(v7 + 128);
    }
    uint64_t v11 = *(void *)(v7 + 128) + 8 * v8;
    if (j != (uint64_t *)v11)
    {
      uint64_t v12 = *j;
      do
      {
        unint64_t v13 = *(llvm::cl::Option **)(v12 + 8);
        *((_WORD *)v13 + 4) = 0;
        (*(void (**)(llvm::cl::Option *))(*(void *)v13 + 64))(v13);
        if ((*((_WORD *)v13 + 5) & 0x2000) != 0) {
          llvm::cl::Option::removeArgument(v13);
        }
        do
        {
          uint64_t v14 = j[1];
          ++j;
          uint64_t v12 = v14;
          if (v14) {
            BOOL v15 = v12 == -8;
          }
          else {
            BOOL v15 = 1;
          }
        }
        while (v15);
      }
      while (j != (uint64_t *)v11);
    }
    uint64_t v16 = *(unsigned int *)(v7 + 40);
    if (v16)
    {
      uint64_t v17 = *(llvm::cl::Option ***)(v7 + 32);
      uint64_t v18 = 8 * v16;
      do
      {
        uint64_t v19 = *v17;
        *((_WORD *)v19 + 4) = 0;
        (*(void (**)(llvm::cl::Option *))(*(void *)v19 + 64))(v19);
        if ((*((_WORD *)v19 + 5) & 0x2000) != 0) {
          llvm::cl::Option::removeArgument(v19);
        }
        ++v17;
        v18 -= 8;
      }
      while (v18);
    }
    uint64_t v20 = *(unsigned int *)(v7 + 88);
    if (v20)
    {
      atomic_ullong v21 = *(llvm::cl::Option ***)(v7 + 80);
      uint64_t v22 = 8 * v20;
      do
      {
        size_t v23 = *v21;
        *((_WORD *)v23 + 4) = 0;
        (*(void (**)(llvm::cl::Option *))(*(void *)v23 + 64))(v23);
        if ((*((_WORD *)v23 + 5) & 0x2000) != 0) {
          llvm::cl::Option::removeArgument(v23);
        }
        ++v21;
        v22 -= 8;
      }
      while (v22);
    }
    uint64_t v24 = *(llvm::cl::Option **)(v7 + 160);
    if (v24)
    {
      *((_WORD *)v24 + 4) = 0;
      (*(void (**)(llvm::cl::Option *))(*(void *)v24 + 64))(v24);
      if ((*((_WORD *)v24 + 5) & 0x2000) != 0) {
        llvm::cl::Option::removeArgument(v24);
      }
    }
    uint64_t v25 = i + 1;
    while (v25 != v6)
    {
      unint64_t v26 = *v25++;
      unint64_t v7 = v26;
      if (v26 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        uint64_t i = v25 - 1;
        goto LABEL_11;
      }
    }
  }
}

BOOL LLVMParseCommandLineOptions(llvm *a1, void *a2, char *__s)
{
  uint64_t v5 = a1;
  if (__s)
  {
    a1 = (llvm *)strlen(__s);
    uint64_t v6 = (uint64_t)a1;
  }
  else
  {
    uint64_t v6 = 0;
  }
  unint64_t v7 = llvm::nulls(a1);

  return llvm::cl::ParseCommandLineOptions(v5, a2, (uint64_t)__s, v6, (llvm::raw_ostream *)v7, 0, 0);
}

void sub_1CD05748C()
{
}

const char *sub_1CD0574A0()
{
  return "value";
}

void sub_1CD0574B4()
{
}

void sub_1CD0574CC()
{
}

void sub_1CD0574E4()
{
}

void sub_1CD0574FC()
{
}

void sub_1CD057514()
{
}

const char *sub_1CD057528()
{
  return "long";
}

void sub_1CD05753C()
{
}

void sub_1CD057554()
{
}

const char *sub_1CD057568()
{
  return "long";
}

void sub_1CD05757C()
{
}

void sub_1CD057594()
{
}

void sub_1CD0575AC()
{
}

void sub_1CD0575C4()
{
}

void sub_1CD0575DC()
{
}

void sub_1CD0575F4()
{
}

void sub_1CD05760C()
{
}

void sub_1CD057624()
{
}

const char *sub_1CD057638()
{
  return "char";
}

void sub_1CD057648(void *a1)
{
  *a1 = &unk_1F2643F00;
  uint64_t v2 = a1 + 20;
  uint64_t v3 = (void *)a1[23];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  sub_1CB87DD48(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD057710(void *a1)
{
  *a1 = &unk_1F2643F68;
  uint64_t v2 = a1 + 20;
  uint64_t v3 = (void *)a1[23];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  sub_1CB87DD48(a1);

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CD0577D8(void *a1)
{
  *a1 = &unk_1F2644038;
  uint64_t v2 = a1 + 20;
  uint64_t v3 = (void *)a1[23];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }

  return sub_1CB87DD48(a1);
}

void sub_1CD05788C(void *a1)
{
  *a1 = &unk_1F2644038;
  uint64_t v2 = a1 + 20;
  uint64_t v3 = (void *)a1[23];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  sub_1CB87DD48(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD057954(void *a1)
{
  *a1 = &unk_1F26440A0;
  uint64_t v2 = a1 + 20;
  uint64_t v3 = (void *)a1[23];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  sub_1CB87DD48(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD057A1C(uint64_t *a1, uint64_t a2, uint64_t a3, unsigned __int8 *a4, size_t a5)
{
  if (!*(void *)(a2 + 24))
  {
    uint64_t v24 = a2;
    uint64_t v10 = sub_1CD057BB4((llvm::StringMapImpl *)(a3 + 128), a4, a5, &v24);
    if ((v10 & 1) == 0)
    {
      uint64_t v20 = (llvm::raw_ostream *)llvm::errs((llvm *)v10);
      atomic_ullong v21 = sub_1CD55ABE0(v20, a1);
      uint64_t v22 = sub_1CB8E509C(v21, ": CommandLine Error: Option '");
      size_t v23 = sub_1CD5D5C70(v22, a4, a5);
      sub_1CB8E509C(v23, "' registered more than once!\n");
      llvm::report_fatal_error((llvm *)"inconsistency in registered CommandLine options", (const llvm::Twine *)1);
    }
    if (!atomic_load_explicit(&llvm::cl::AllSubCommands, memory_order_acquire)) {
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&llvm::cl::AllSubCommands, (void *(*)(void))sub_1CD83084C, (void (*)(void *))sub_1CD8308C4);
    }
    if (llvm::cl::AllSubCommands == a3)
    {
      uint64_t v11 = a1[35];
      uint64_t v12 = 288;
      if (v11 == a1[34]) {
        uint64_t v12 = 292;
      }
      uint64_t v13 = *(unsigned int *)((char *)a1 + v12);
      if (v13)
      {
        uint64_t v14 = 8 * v13;
        for (uint64_t i = (unint64_t *)a1[35]; *i >= 0xFFFFFFFFFFFFFFFELL; ++i)
        {
          v14 -= 8;
          if (!v14) {
            return;
          }
        }
      }
      else
      {
        uint64_t i = (unint64_t *)a1[35];
      }
      uint64_t v16 = (unint64_t *)(v11 + 8 * v13);
      if (i != v16)
      {
        unint64_t v17 = *i;
LABEL_17:
        if (v17 != a3) {
          sub_1CD057A1C(a1, a2, v17, a4, a5);
        }
        uint64_t v18 = i + 1;
        while (v18 != v16)
        {
          unint64_t v19 = *v18++;
          unint64_t v17 = v19;
          if (v19 <= 0xFFFFFFFFFFFFFFFDLL)
          {
            uint64_t i = v18 - 1;
            goto LABEL_17;
          }
        }
      }
    }
  }
}

uint64_t sub_1CD057BB4(llvm::StringMapImpl *a1, unsigned __int8 *a2, size_t __n, uint64_t *a4)
{
  unsigned int v7 = *((_DWORD *)a1 + 2);
  if (!v7)
  {
    *((_DWORD *)a1 + 3) = 0;
    *((_DWORD *)a1 + 4) = 0;
    uint64_t v28 = malloc_type_calloc(0x11uLL, 0xCuLL, 0x6D9A4F0CuLL);
    if (!v28) {
      llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
    }
    v28[16] = 2;
    *(void *)a1 = v28;
    unsigned int v7 = 16;
    *((_DWORD *)a1 + 2) = 16;
  }
  uint64_t v29 = a4;
  int v8 = 0;
  if (__n)
  {
    size_t v9 = __n;
    uint64_t v10 = a2;
    do
    {
      int v11 = *v10++;
      int v8 = 33 * v8 + v11;
      --v9;
    }
    while (v9);
  }
  uint64_t v12 = *(void *)a1;
  unsigned int v13 = v7 - 1;
  uint64_t v14 = *(void *)a1 + 8 * v7 + 8;
  int v15 = -1;
  int v16 = 1;
  int v17 = v8;
  while (1)
  {
    uint64_t v18 = v17 & v13;
    unint64_t v19 = *(void **)(v12 + 8 * v18);
    if (!v19) {
      break;
    }
    if (v19 == (void *)-8)
    {
      if (v15 == -1) {
        int v15 = v17 & v13;
      }
    }
    else if (*(_DWORD *)(v14 + 4 * v18) == v8 {
           && __n == *v19
    }
           && (!__n || !memcmp(a2, (char *)v19 + *((unsigned int *)a1 + 5), __n)))
    {
      goto LABEL_17;
    }
    int v17 = v16 + v18;
    ++v16;
  }
  uint64_t v20 = v15;
  if (v15 == -1)
  {
    uint64_t v20 = v18;
    uint64_t v18 = v18;
  }
  else
  {
    uint64_t v18 = v15;
  }
  *(_DWORD *)(v14 + 4 * v20) = v8;
  unint64_t v19 = *(void **)(v12 + 8 * v18);
LABEL_17:
  if (v19)
  {
    if (v19 != (void *)-8) {
      return 0;
    }
    --*((_DWORD *)a1 + 4);
  }
  atomic_ullong v21 = operator new(__n + 17, (std::align_val_t)8uLL);
  uint64_t v22 = v21;
  size_t v23 = (char *)(v21 + 2);
  if (__n) {
    memcpy(v21 + 2, a2, __n);
  }
  v23[__n] = 0;
  uint64_t v24 = *v29;
  *uint64_t v22 = __n;
  v22[1] = v24;
  *(void *)(v12 + 8 * v18) = v22;
  ++*((_DWORD *)a1 + 3);
  uint64_t v25 = (void *)(*(void *)a1 + 8 * llvm::StringMapImpl::RehashTable(a1, v18));
  uint64_t result = 1;
  while (!*v25 || *v25 == -8)
    ++v25;
  return result;
}

void sub_1CD057DC8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v39 = a1;
  size_t v5 = *(void *)(a2 + 24);
  if (!v5) {
    goto LABEL_30;
  }
  if ((*(_WORD *)(a2 + 10) & 0x2000) == 0) {
    goto LABEL_3;
  }
  uint64_t v38 = *(unsigned int *)(a3 + 136);
  if (!v38) {
    goto LABEL_3;
  }
  uint64_t v17 = 0;
  int v18 = 0;
  unint64_t v19 = *(unsigned __int8 **)(a2 + 16);
  do
    int v18 = 33 * v18 + v19[v17++];
  while (v5 != v17);
  uint64_t v20 = *(void *)(a3 + 128);
  int v21 = 1;
  int v22 = v18;
  while (1)
  {
    uint64_t v23 = v22 & (v38 - 1);
    uint64_t v24 = *(void **)(v20 + 8 * v23);
    if (v24 != (void *)-8)
    {
      if (!v24) {
        goto LABEL_3;
      }
      if (*(_DWORD *)(v20 + 8 * v38 + 8 + 4 * v23) == v18
        && v5 == *v24
        && !memcmp(v19, (char *)v24 + *(unsigned int *)(a3 + 148), v5))
      {
        break;
      }
    }
    int v22 = v21 + v23;
    ++v21;
  }
  if (v23 == -1 || (int)v23 == v38)
  {
LABEL_3:
    long long v42 = *(_OWORD *)(a2 + 16);
    uint64_t v43 = a2;
    a1 = sub_1CD057BB4((llvm::StringMapImpl *)(a3 + 128), (unsigned __int8 *)v42, *((size_t *)&v42 + 1), &v43);
    if (a1)
    {
      LODWORD(v5) = 0;
    }
    else
    {
      uint64_t v6 = (llvm::raw_ostream *)llvm::errs((llvm *)a1);
      unsigned int v7 = v6;
      char v8 = *(unsigned char *)(v39 + 23);
      BOOL v9 = v8 < 0;
      if (v8 >= 0) {
        uint64_t v10 = (const char *)v39;
      }
      else {
        uint64_t v10 = *(const char **)v39;
      }
      size_t v11 = v8 & 0x7F;
      if (v9) {
        size_t v12 = *(void *)(v39 + 8);
      }
      else {
        size_t v12 = v11;
      }
      unsigned int v13 = llvm::raw_ostream::write(v6, v10, v12);
      uint64_t v14 = (void *)*((void *)v13 + 4);
      if (*((void *)v13 + 3) - (void)v14 > 0x1CuLL)
      {
        qmemcpy(v14, ": CommandLine Error: Option '", 29);
        a1 = *((void *)v7 + 4) + 29;
        *((void *)v7 + 4) = a1;
      }
      else
      {
        llvm::raw_ostream::write(v7, ": CommandLine Error: Option '", 0x1DuLL);
        a1 = *((void *)v7 + 4);
      }
      int v15 = *(const void **)(a2 + 16);
      unint64_t v16 = *(void *)(a2 + 24);
      if (v16 <= *((void *)v7 + 3) - a1)
      {
        if (v16)
        {
          memcpy((void *)a1, v15, *(void *)(a2 + 24));
          a1 = *((void *)v7 + 4) + v16;
          *((void *)v7 + 4) = a1;
        }
      }
      else
      {
        llvm::raw_ostream::write(v7, (const char *)v15, *(void *)(a2 + 24));
        a1 = *((void *)v7 + 4);
      }
      if ((unint64_t)(*((void *)v7 + 3) - a1) > 0x1C)
      {
        qmemcpy((void *)a1, "' registered more than once!\n", 29);
        *((void *)v7 + 4) += 29;
      }
      else
      {
        a1 = (uint64_t)llvm::raw_ostream::write(v7, "' registered more than once!\n", 0x1DuLL);
      }
      LODWORD(v5) = 1;
    }
LABEL_30:
    __int16 v25 = *(_WORD *)(a2 + 10);
    if ((v25 & 0x180) == 0x80)
    {
      unsigned int v26 = *(_DWORD *)(a3 + 40);
      if (v26 >= *(_DWORD *)(a3 + 44)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(a3 + 32) + 8 * v26) = a2;
      ++*(_DWORD *)(a3 + 40);
      if (v5) {
        goto LABEL_67;
      }
      goto LABEL_43;
    }
    if ((*(_WORD *)(a2 + 10) & 0x800) != 0)
    {
      unsigned int v27 = *(_DWORD *)(a3 + 88);
      if (v27 >= *(_DWORD *)(a3 + 92)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(a3 + 80) + 8 * v27) = a2;
      ++*(_DWORD *)(a3 + 88);
      if (v5) {
        goto LABEL_67;
      }
    }
    else if ((v25 & 7) == 4)
    {
      if (*(void *)(a3 + 160))
      {
        uint64_t v40 = "Cannot specify more than one option with cl::ConsumeAfter!";
        __int16 v41 = 259;
        uint64_t v37 = (llvm::raw_ostream *)llvm::errs((llvm *)a1);
        llvm::cl::Option::error((void *)a2, (llvm::Twine *)&v40, 0, 0, v37);
        *(void *)(a3 + 160) = a2;
        goto LABEL_67;
      }
      *(void *)(a3 + 160) = a2;
      if (v5) {
LABEL_67:
      }
        llvm::report_fatal_error((llvm *)"inconsistency in registered CommandLine options", (const llvm::Twine *)1);
    }
    else if (v5)
    {
      goto LABEL_67;
    }
LABEL_43:
    if (!atomic_load_explicit(&llvm::cl::AllSubCommands, memory_order_acquire)) {
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&llvm::cl::AllSubCommands, (void *(*)(void))sub_1CD83084C, (void (*)(void *))sub_1CD8308C4);
    }
    if (llvm::cl::AllSubCommands == a3)
    {
      uint64_t v28 = *(void *)(v39 + 280);
      uint64_t v29 = 288;
      if (v28 == *(void *)(v39 + 272)) {
        uint64_t v29 = 292;
      }
      uint64_t v30 = *(unsigned int *)(v39 + v29);
      if (v30)
      {
        uint64_t v31 = 8 * v30;
        for (uint64_t i = *(unint64_t **)(v39 + 280); *i >= 0xFFFFFFFFFFFFFFFELL; ++i)
        {
          v31 -= 8;
          if (!v31) {
            return;
          }
        }
      }
      else
      {
        uint64_t i = *(unint64_t **)(v39 + 280);
      }
      int64_t v33 = (unint64_t *)(v28 + 8 * v30);
      if (i != v33)
      {
        unint64_t v34 = *i;
LABEL_57:
        if (v34 != a3) {
          sub_1CD057DC8(v39, a2);
        }
        size_t v35 = i + 1;
        while (v35 != v33)
        {
          unint64_t v36 = *v35++;
          unint64_t v34 = v36;
          if (v36 <= 0xFFFFFFFFFFFFFFFDLL)
          {
            uint64_t i = v35 - 1;
            goto LABEL_57;
          }
        }
      }
    }
  }
}

void sub_1CD0581F4(void *a1, uint64_t a2)
{
  v53[32] = *MEMORY[0x1E4F143B8];
  uint64_t v51 = v53;
  uint64_t v52 = 0x1000000000;
  (*(void (**)(void *, void **))(*a1 + 72))(a1, &v51);
  uint64_t v3 = a1[3];
  unsigned int v4 = v52;
  uint64_t v46 = a1;
  if (v3)
  {
    uint64_t v5 = a2;
    if (v52 >= HIDWORD(v52)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v6 = (char *)v51 + 16 * v52;
    *uint64_t v6 = a1[2];
    v6[1] = v3;
    unsigned int v4 = v52 + 1;
    LODWORD(v52) = v4;
    if (!v4) {
      goto LABEL_43;
    }
  }
  else
  {
    uint64_t v5 = a2;
    if (!v52) {
      goto LABEL_43;
    }
  }
  unsigned int v7 = (const void **)v51;
  size_t v47 = (const void **)((char *)v51 + 16 * v4);
  uint64_t v48 = *(void *)(v5 + 128) + 8 * *(unsigned int *)(v5 + 136);
  do
  {
    uint64_t v8 = *(unsigned int *)(v5 + 136);
    if (v8)
    {
      uint64_t v10 = *v7;
      size_t v9 = (size_t)v7[1];
      int v11 = 0;
      if (v9)
      {
        size_t v12 = (char *)v7[1];
        unsigned int v13 = (unsigned __int8 *)*v7;
        do
        {
          int v14 = *v13++;
          int v11 = 33 * v11 + v14;
          --v12;
        }
        while (v12);
      }
      uint64_t v15 = *(void *)(v5 + 128);
      int v16 = 1;
      int v17 = v11;
      while (1)
      {
        uint64_t v18 = v17 & (v8 - 1);
        unint64_t v19 = *(void **)(v15 + 8 * v18);
        if (v19 != (void *)-8)
        {
          if (!v19)
          {
            uint64_t v21 = v8;
            goto LABEL_20;
          }
          if (*(_DWORD *)(v15 + 8 * v8 + 8 + 4 * v18) == v11 && v9 == *v19)
          {
            if (!v9) {
              break;
            }
            int v20 = memcmp(v10, (char *)v19 + *(unsigned int *)(v5 + 148), v9);
            uint64_t v5 = a2;
            if (!v20) {
              break;
            }
          }
        }
        int v17 = v16 + v18;
        ++v16;
      }
      uint64_t v21 = (int)v18;
      if (v18 == -1) {
        uint64_t v21 = v8;
      }
    }
    else
    {
      uint64_t v21 = 0;
      uint64_t v15 = *(void *)(v5 + 128);
    }
LABEL_20:
    int v22 = (size_t **)(v15 + 8 * v21);
    if (v22 != (size_t **)v48)
    {
      uint64_t v23 = *v22;
      if ((void *)(*v22)[1] == v46)
      {
        if (v8)
        {
          uint64_t v49 = *(unsigned int *)(v5 + 148);
          size_t v24 = *v23;
          if (*v23)
          {
            int v25 = 0;
            size_t v26 = *v23;
            unsigned int v27 = (unsigned __int8 *)v23 + v49;
            do
            {
              int v28 = *v27++;
              int v25 = 33 * v25 + v28;
              --v26;
            }
            while (v26);
          }
          else
          {
            int v25 = 0;
          }
          unsigned int v29 = v8 - 1;
          uint64_t v30 = v15 + 8 * v8 + 8;
          int v31 = 1;
          int v32 = v25;
          while (1)
          {
            uint64_t v33 = v32 & v29;
            unint64_t v34 = *(void **)(v15 + 8 * v33);
            if (v34 != (void *)-8)
            {
              if (!v34) {
                goto LABEL_38;
              }
              if (*(_DWORD *)(v30 + 4 * v33) == v25 && v24 == *v34)
              {
                if (!v24) {
                  break;
                }
                int v35 = memcmp((char *)v23 + v49, (char *)v34 + v49, v24);
                uint64_t v5 = a2;
                if (!v35) {
                  break;
                }
              }
            }
            int v32 = v31 + v33;
            ++v31;
          }
          *(void *)(v15 + 8 * (int)v33) = -8;
          *(int32x2_t *)(v5 + 140) = vadd_s32(*(int32x2_t *)(v5 + 140), (int32x2_t)0x1FFFFFFFFLL);
        }
LABEL_38:
        MEMORY[0x1D25D9CD0](v23, 8);
        uint64_t v5 = a2;
      }
    }
    v7 += 2;
  }
  while (v7 != v47);
LABEL_43:
  if ((*((_WORD *)v46 + 5) & 0x180) == 0x80)
  {
    uint64_t v36 = *(unsigned int *)(v5 + 40);
    if (v36)
    {
      uint64_t v37 = *(void **)(v5 + 32);
      size_t v38 = 8 * v36 - 8;
      uint64_t v39 = v37;
      while (1)
      {
        uint64_t v40 = (void *)*v39++;
        if (v40 == v46) {
          break;
        }
        v38 -= 8;
        uint64_t v37 = v39;
        if (v38 == -8) {
          goto LABEL_63;
        }
      }
      if (v38)
      {
        memmove(v37, v37 + 1, v38);
        uint64_t v5 = a2;
        LODWORD(v36) = *(_DWORD *)(a2 + 40);
      }
      *(_DWORD *)(v5 + 40) = v36 - 1;
    }
  }
  else if ((*((_WORD *)v46 + 5) & 0x800) != 0)
  {
    uint64_t v41 = *(unsigned int *)(v5 + 88);
    if (v41)
    {
      long long v42 = *(void **)(v5 + 80);
      size_t v43 = 8 * v41 - 8;
      unint64_t v44 = v42;
      while (1)
      {
        size_t v45 = (void *)*v44++;
        if (v45 == v46) {
          break;
        }
        v43 -= 8;
        long long v42 = v44;
        if (v43 == -8) {
          goto LABEL_63;
        }
      }
      if (v43)
      {
        memmove(v42, v42 + 1, v43);
        uint64_t v5 = a2;
        LODWORD(v41) = *(_DWORD *)(a2 + 88);
      }
      *(_DWORD *)(v5 + 88) = v41 - 1;
    }
  }
  else if (*(void **)(v5 + 160) == v46)
  {
    *(void *)(v5 + 160) = 0;
  }
LABEL_63:
  if (v51 != v53) {
    free(v51);
  }
}

uint64_t sub_1CD0585F8(uint64_t *a1, uint64_t a2, unsigned __int8 *a3, size_t __n, uint64_t a5)
{
  uint64_t v44 = a2;
  uint64_t result = sub_1CD057BB4((llvm::StringMapImpl *)(a5 + 128), a3, __n, &v44);
  if ((result & 1) == 0)
  {
    uint64_t v39 = (llvm::raw_ostream *)llvm::errs((llvm *)result);
    uint64_t v40 = sub_1CD55ABE0(v39, a1);
    uint64_t v41 = sub_1CB8E509C(v40, ": CommandLine Error: Option '");
    long long v42 = sub_1CD5D5C70(v41, *(const void **)(a2 + 16), *(void *)(a2 + 24));
    sub_1CB8E509C(v42, "' registered more than once!\n");
    llvm::report_fatal_error((llvm *)"inconsistency in registered CommandLine options", (const llvm::Twine *)1);
  }
  uint64_t v43 = *(unsigned int *)(a5 + 136);
  if (v43)
  {
    uint64_t v9 = a5;
    uint64_t v12 = a2 + 16;
    int v11 = *(unsigned __int8 **)(a2 + 16);
    size_t v10 = *(void *)(v12 + 8);
    int v13 = 0;
    if (v10)
    {
      size_t v14 = v10;
      uint64_t v15 = v11;
      do
      {
        int v16 = *v15++;
        int v13 = 33 * v13 + v16;
        --v14;
      }
      while (v14);
    }
    unsigned int v17 = v43 - 1;
    uint64_t v18 = *(void *)(a5 + 128);
    uint64_t v19 = v18 + 8 * v43 + 8;
    int v20 = 1;
    int v21 = v13;
    while (1)
    {
      uint64_t v22 = v21 & v17;
      uint64_t v23 = *(void **)(v18 + 8 * v22);
      if (v23 != (void *)-8)
      {
        if (!v23) {
          return result;
        }
        if (*(_DWORD *)(v19 + 4 * v22) == v13 && v10 == *v23)
        {
          uint64_t v24 = *(unsigned int *)(v9 + 148);
          if (!v10) {
            break;
          }
          uint64_t v25 = v9;
          uint64_t result = memcmp(v11, (char *)v23 + v24, v10);
          uint64_t v9 = v25;
          if (!result) {
            break;
          }
        }
      }
      int v21 = v20 + v22;
      ++v20;
    }
    if (v22 != -1 && (int)v22 != v43)
    {
      size_t v26 = *(size_t **)(v18 + 8 * (int)v22);
      unsigned int v27 = (unsigned __int8 *)v26 + v24;
      size_t v28 = *v26;
      int v29 = 0;
      if (*v26)
      {
        size_t v30 = *v26;
        int v31 = v27;
        do
        {
          int v32 = *v31++;
          int v29 = 33 * v29 + v32;
          --v30;
        }
        while (v30);
      }
      int v33 = 1;
      int v34 = v29;
      while (1)
      {
        uint64_t v35 = v34 & v17;
        uint64_t v36 = *(void **)(v18 + 8 * v35);
        if (v36 != (void *)-8)
        {
          if (!v36) {
            goto LABEL_29;
          }
          if (*(_DWORD *)(v19 + 4 * v35) == v29 && v28 == *v36)
          {
            if (!v28) {
              break;
            }
            uint64_t v37 = v9;
            int v38 = memcmp(v27, (char *)v36 + v24, v28);
            uint64_t v9 = v37;
            if (!v38) {
              break;
            }
          }
        }
        int v34 = v33 + v35;
        ++v33;
      }
      *(void *)(v18 + 8 * (int)v35) = -8;
      *(int32x2_t *)(v9 + 140) = vadd_s32(*(int32x2_t *)(v9 + 140), (int32x2_t)0x1FFFFFFFFLL);
LABEL_29:
      JUMPOUT(0x1D25D9CD0);
    }
  }
  return result;
}

uint64_t sub_1CD05885C(_WORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, char *__s, size_t __n, uint64_t a7)
{
  size_t v8 = __n;
  uint64_t v9 = __s;
  if ((a1[5] & 0x200) != 0 && __n && (v14 = memchr(__s, 44, __n)) != 0 && (unint64_t v15 = v14 - v9, v14 - v9 != -1))
  {
    while (1)
    {
      unint64_t v16 = v8 >= v15 ? v15 : v8;
      if ((*(uint64_t (**)(_WORD *, uint64_t, uint64_t, uint64_t, char *, unint64_t, uint64_t))(*(void *)a1 + 80))(a1, a2, a3, a4, v9, v16, a7))return 1; {
      if (v8 >= v15 + 1)
      }
        size_t v17 = v15 + 1;
      else {
        size_t v17 = v8;
      }
      v9 += v17;
      v8 -= v17;
      if (v8)
      {
        uint64_t v18 = memchr(v9, 44, v8);
        unint64_t v15 = v18 - v9;
        if (v18 && v15 != -1) {
          continue;
        }
      }
      goto LABEL_18;
    }
  }
  else
  {
LABEL_18:
    int v20 = *(uint64_t (**)(_WORD *, uint64_t, uint64_t, uint64_t, char *, size_t, uint64_t))(*(void *)a1 + 80);
    return v20(a1, a2, a3, a4, v9, v8, a7);
  }
}

uint64_t sub_1CD0589C0(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v5 = 0;
  uint64_t v6 = a2 - 1;
  unsigned int v7 = a2 - a3;
  do
  {
    if (!(a3 - a2 + 1 + v5)) {
      goto LABEL_10;
    }
    int v8 = *(unsigned __int8 *)(a3 + a1 + 1 + v5++);
  }
  while (v8 == 92);
  if (v8 != 34)
  {
    uint64_t v6 = a3 + v5 - 1;
    unsigned int v7 = v5;
LABEL_10:
    uint64_t v13 = v7;
    int v11 = a4 + 1;
    uint64_t v14 = a4[1];
    if (v14 + (unint64_t)v7 > a4[2]) {
      llvm::SmallVectorBase<unsigned long long>::grow_pod();
    }
    memset((void *)(*a4 + v14), 92, v7);
    goto LABEL_15;
  }
  uint64_t v9 = v5 >> 1;
  uint64_t v10 = a4[1];
  int v11 = a4 + 1;
  if ((unint64_t)(v10 + v9) > a4[2]) {
    llvm::SmallVectorBase<unsigned long long>::grow_pod();
  }
  uint64_t v6 = a3 + v5;
  if (v5 == 1)
  {
    uint64_t v12 = v10 + v9;
    *int v11 = v12;
  }
  else
  {
    memset((void *)(*a4 + v10), 92, v5 >> 1);
    uint64_t v12 = a4[1] + v9;
    a4[1] = v12;
    if ((v5 & 1) == 0) {
      return --v6;
    }
  }
  if ((unint64_t)(v12 + 1) > a4[2]) {
    llvm::SmallVectorBase<unsigned long long>::grow_pod();
  }
  *(unsigned char *)(*a4 + v12) = 34;
  uint64_t v13 = 1;
LABEL_15:
  *v11 += v13;
  return v6;
}

uint64_t sub_1CD058B44(uint64_t a1, uint64_t a2, void *a3, int a4, char a5)
{
  size_t v5 = *(void *)(a2 + 8);
  if (!v5) {
    return 0;
  }
  uint64_t v10 = *(unsigned __int8 **)a2;
  int v11 = memchr(*(void **)a2, 61, v5);
  size_t v12 = v11 - v10;
  if (v11) {
    BOOL v13 = v12 == -1;
  }
  else {
    BOOL v13 = 1;
  }
  int v47 = a4;
  if (!v13)
  {
    if (v5 >= v12) {
      size_t v23 = v11 - v10;
    }
    else {
      size_t v23 = v5;
    }
    uint64_t v24 = *(unsigned int *)(a1 + 136);
    if (!v24) {
      return 0;
    }
    unint64_t v42 = v11 - v10;
    uint64_t v43 = a3;
    uint64_t v44 = a2;
    int v25 = 0;
    if (v23)
    {
      size_t v26 = v23;
      unsigned int v27 = v10;
      do
      {
        int v28 = *v27++;
        int v25 = 33 * v25 + v28;
        --v26;
      }
      while (v26);
    }
    unsigned int v29 = v24 - 1;
    uint64_t v30 = *(void *)(a1 + 128);
    uint64_t v45 = *(unsigned int *)(a1 + 136);
    uint64_t v31 = v30 + 8 * v24 + 8;
    uint64_t v32 = *(unsigned int *)(a1 + 148);
    int v33 = 1;
    for (int i = v25; ; int i = v35 + v33++)
    {
      uint64_t v35 = i & v29;
      uint64_t v36 = *(void **)(v30 + 8 * v35);
      if (v36 != (void *)-8)
      {
        if (!v36) {
          return 0;
        }
        if (*(_DWORD *)(v31 + 4 * v35) == v25 && v23 == *v36 && (!v23 || !memcmp(v10, (char *)v36 + v32, v23))) {
          break;
        }
      }
    }
    if (v35 == -1) {
      return 0;
    }
    if ((int)v35 == v45) {
      return 0;
    }
    uint64_t v38 = v30 + 8 * (int)v35;
    if ((~*(unsigned __int16 *)(*(void *)(*(void *)v38 + 8) + 10) & 0x180) == 0) {
      return 0;
    }
    if (v5 >= v42 + 1) {
      size_t v39 = v42 + 1;
    }
    else {
      size_t v39 = v5;
    }
    *uint64_t v43 = &v10[v39];
    v43[1] = v5 - v39;
    unint64_t v40 = *(void *)(v44 + 8);
    if (v40 >= v42) {
      unint64_t v40 = v42;
    }
    *(void *)(v44 + 8) = v40;
    goto LABEL_44;
  }
  uint64_t v14 = *(unsigned int *)(a1 + 136);
  if (!v14) {
    return 0;
  }
  uint64_t v15 = 0;
  int v16 = 0;
  do
    int v16 = 33 * v16 + v10[v15++];
  while (v5 != v15);
  uint64_t v17 = *(void *)(a1 + 128);
  uint64_t v18 = *(unsigned int *)(a1 + 148);
  int v19 = 1;
  int v20 = v16;
  while (1)
  {
    uint64_t v21 = v20 & (v14 - 1);
    uint64_t v22 = *(void **)(v17 + 8 * v21);
    if (v22 != (void *)-8)
    {
      if (!v22) {
        return 0;
      }
      if (*(_DWORD *)(v17 + 8 * v14 + 8 + 4 * v21) == v16 && v5 == *v22 && !memcmp(v10, (char *)v22 + v18, v5)) {
        break;
      }
    }
    int v20 = v19 + v21;
    ++v19;
  }
  uint64_t result = 0;
  if (v21 == -1 || (int)v21 == v14) {
    return result;
  }
  uint64_t v38 = v17 + 8 * (int)v21;
LABEL_44:
  uint64_t result = *(void *)(*(void *)v38 + 8);
  if (result) {
    BOOL v41 = v47 == 0;
  }
  else {
    BOOL v41 = 1;
  }
  if (!v41 && (a5 & 1) == 0 && (*(_WORD *)(result + 10) & 0x1000) == 0) {
    return 0;
  }
  return result;
}

uint64_t sub_1CD058DB8(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 10) >> 12) & 1;
}

uint64_t sub_1CD058DC4(unsigned __int8 *__s1, size_t __n, size_t *a3, uint64_t (*a4)(void), uint64_t *a5)
{
  size_t v5 = __n;
  uint64_t v7 = *((unsigned int *)a5 + 2);
  if (v7)
  {
    int v8 = 0;
    if (__n)
    {
      size_t v9 = __n;
      uint64_t v10 = __s1;
      do
      {
        int v11 = *v10++;
        int v8 = 33 * v8 + v11;
        --v9;
      }
      while (v9);
    }
    uint64_t v12 = *a5;
    uint64_t v13 = *a5 + 8 * v7 + 8;
    uint64_t v14 = *((unsigned int *)a5 + 5);
    int v15 = 1;
    for (int i = v8; ; int i = v17 + v15++)
    {
      uint64_t v17 = i & (v7 - 1);
      uint64_t v18 = *(void **)(v12 + 8 * v17);
      if (v18 != (void *)-8)
      {
        if (!v18) {
          goto LABEL_16;
        }
        if (*(_DWORD *)(v13 + 4 * v17) == v8 && v5 == *v18 && (!v5 || !memcmp(__s1, (char *)v18 + v14, v5))) {
          break;
        }
      }
    }
    if (v17 == -1)
    {
LABEL_16:
      uint64_t v20 = v7;
      goto LABEL_17;
    }
    uint64_t v19 = v12 + 8 * (int)v17;
    if ((int)v17 == v7)
    {
      uint64_t v20 = v7;
    }
    else
    {
      int v35 = a4(*(void *)(*(void *)v19 + 8));
      uint64_t v12 = *a5;
      uint64_t v20 = *((unsigned int *)a5 + 2);
      if (!v35) {
        uint64_t v19 = *a5 + 8 * v20;
      }
      uint64_t v7 = *((unsigned int *)a5 + 2);
    }
  }
  else
  {
    uint64_t v20 = 0;
    uint64_t v12 = *a5;
LABEL_17:
    uint64_t v19 = v12 + 8 * v20;
  }
  BOOL v21 = v19 == v12 + 8 * v20;
  if (v21 && v5 >= 2)
  {
    do
    {
      if (v5 >= v5 - 1) {
        --v5;
      }
      if (v7)
      {
        uint64_t v24 = 0;
        int v25 = 0;
        do
          int v25 = 33 * v25 + __s1[v24++];
        while (v5 != v24);
        unsigned int v26 = v7 - 1;
        uint64_t v27 = v7;
        uint64_t v39 = v7;
        uint64_t v28 = v12 + 8 * v7 + 8;
        uint64_t v29 = *((unsigned int *)a5 + 5);
        int v30 = 1;
        for (int j = v25; ; int j = v32 + v30++)
        {
          uint64_t v32 = j & v26;
          int v33 = *(void **)(v12 + 8 * v32);
          if (v33 != (void *)-8)
          {
            if (!v33) {
              goto LABEL_41;
            }
            if (*(_DWORD *)(v28 + 4 * v32) == v25 && v5 == *v33 && !memcmp(__s1, (char *)v33 + v29, v5)) {
              break;
            }
          }
        }
        if (v32 == -1)
        {
LABEL_41:
          uint64_t v7 = v39;
          goto LABEL_42;
        }
        uint64_t v19 = v12 + 8 * (int)v32;
        if ((int)v32 == v27)
        {
          uint64_t v7 = v39;
        }
        else
        {
          int v34 = a4(*(void *)(*(void *)v19 + 8));
          uint64_t v12 = *a5;
          uint64_t v7 = *((unsigned int *)a5 + 2);
          if (!v34) {
            uint64_t v19 = *a5 + 8 * v7;
          }
          uint64_t v27 = *((unsigned int *)a5 + 2);
        }
      }
      else
      {
        uint64_t v27 = 0;
LABEL_42:
        uint64_t v19 = v12 + 8 * v27;
      }
      BOOL v21 = v19 == v12 + 8 * v27;
    }
    while (v19 == v12 + 8 * v27 && v5 > 1);
  }
  if (v21 || !a4(*(void *)(*(void *)v19 + 8))) {
    return 0;
  }
  *a3 = v5;
  return *(void *)(*(void *)v19 + 8);
}

BOOL sub_1CD05907C(uint64_t a1)
{
  return (*(_WORD *)(a1 + 10) & 0x1100) != 0;
}

void sub_1CD059090()
{
}

void *sub_1CD059908(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = result + 181;
    result[181] = &unk_1F2644360;
    uint64_t v3 = result + 200;
    unsigned int v4 = (void *)result[203];
    if (v4 == v3)
    {
      (*(void (**)(void *))(*v3 + 32))(v3);
    }
    else if (v4)
    {
      (*(void (**)(void *))(*v4 + 40))(v4);
    }
    sub_1CB87DD48(v2);
    size_t v5 = (void *)v1[177];
    if (v5)
    {
      uint64_t v6 = (void *)v1[178];
      uint64_t v7 = (void *)v1[177];
      if (v6 != v5)
      {
        int v8 = v6 - 4;
        size_t v9 = v6 - 4;
        do
        {
          uint64_t v10 = (void *)v9[3];
          if (v9 == v10)
          {
            (*(void (**)(void *))(*v9 + 32))(v9);
          }
          else if (v10)
          {
            (*(void (**)(void *))(*v10 + 40))(v10);
          }
          v8 -= 4;
          BOOL v11 = v9 == v5;
          v9 -= 4;
        }
        while (!v11);
        uint64_t v7 = (void *)v1[177];
      }
      v1[178] = v5;
      operator delete(v7);
    }
    uint64_t v12 = (void *)v1[176];
    if (v12 == v1 + 173)
    {
      (*(void (**)(void *))(v1[173] + 32))(v1 + 173);
    }
    else if (v12)
    {
      (*(void (**)(void *))(*v12 + 40))(v12);
    }
    v1[149] = &unk_1F26440A0;
    uint64_t v13 = (void *)v1[172];
    if (v13 == v1 + 169)
    {
      (*(void (**)(void *))(v1[169] + 32))(v1 + 169);
    }
    else if (v13)
    {
      (*(void (**)(void *))(*v13 + 40))(v13);
    }
    sub_1CB87DD48(v1 + 149);
    v1[125] = &unk_1F26440A0;
    uint64_t v14 = (void *)v1[148];
    if (v14 == v1 + 145)
    {
      (*(void (**)(void *))(v1[145] + 32))(v1 + 145);
    }
    else if (v14)
    {
      (*(void (**)(void *))(*v14 + 40))(v14);
    }
    sub_1CB87DD48(v1 + 125);
    v1[102] = &unk_1F2644290;
    int v15 = (void *)v1[124];
    if (v15 == v1 + 121)
    {
      (*(void (**)(void *))(v1[121] + 32))(v1 + 121);
    }
    else if (v15)
    {
      (*(void (**)(void *))(*v15 + 40))(v15);
    }
    sub_1CB87DD48(v1 + 102);
    sub_1CB87DD48(v1 + 85);
    v1[62] = &unk_1F2644290;
    int v16 = (void *)v1[84];
    if (v16 == v1 + 81)
    {
      (*(void (**)(void *))(v1[81] + 32))(v1 + 81);
    }
    else if (v16)
    {
      (*(void (**)(void *))(*v16 + 40))(v16);
    }
    sub_1CB87DD48(v1 + 62);
    v1[39] = &unk_1F26441C0;
    uint64_t v17 = (void *)v1[61];
    if (v17 == v1 + 58)
    {
      (*(void (**)(void *))(v1[58] + 32))(v1 + 58);
    }
    else if (v17)
    {
      (*(void (**)(void *))(*v17 + 40))(v17);
    }
    sub_1CB87DD48(v1 + 39);
    v1[16] = &unk_1F26441C0;
    uint64_t v18 = (void *)v1[38];
    if (v18 == v1 + 35)
    {
      (*(void (**)(void *))(v1[35] + 32))(v1 + 35);
    }
    else if (v18)
    {
      (*(void (**)(void *))(*v18 + 40))(v18);
    }
    sub_1CB87DD48(v1 + 16);
    JUMPOUT(0x1D25D9CE0);
  }
  return result;
}

uint64_t sub_1CD059E3C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(a2 + 8);
  if (v3)
  {
    uint64_t v6 = 0;
    uint64_t v7 = 16 * v3;
    do
    {
      uint64_t result = (*(uint64_t (**)(void, uint64_t))(**(void **)(*(void *)a2 + v6 + 8) + 48))(*(void *)(*(void *)a2 + v6 + 8), a3);
      v6 += 16;
    }
    while (v7 != v6);
  }
  return result;
}

void sub_1CD059EBC()
{
}

void sub_1CD059ED0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v76[0] = 0;
  v76[1] = 0;
  unsigned int v77 = 0;
  if (!atomic_load_explicit(&qword_1EBCFABE8, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1EBCFABE8, (void *(*)(void))sub_1CD05B850, (void (*)(void *))sub_1CD05B978);
  }
  uint64_t v4 = *(void *)(qword_1EBCFABE8 + 120);
  uint64_t v5 = 128;
  if (v4 == *(void *)(qword_1EBCFABE8 + 112)) {
    uint64_t v5 = 132;
  }
  uint64_t v6 = *(unsigned int *)(qword_1EBCFABE8 + v5);
  uint64_t v71 = a3;
  if (v6)
  {
    uint64_t v7 = 8 * v6;
    int v8 = *(unint64_t **)(qword_1EBCFABE8 + 120);
    while (*v8 >= 0xFFFFFFFFFFFFFFFELL)
    {
      ++v8;
      v7 -= 8;
      if (!v7) {
        goto LABEL_35;
      }
    }
  }
  else
  {
    int v8 = *(unint64_t **)(qword_1EBCFABE8 + 120);
  }
  size_t v9 = (unint64_t *)(v4 + 8 * v6);
  if (v8 == v9)
  {
LABEL_35:
    unint64_t v73 = 0;
    uint64_t v10 = 0;
  }
  else
  {
    uint64_t v10 = 0;
    BOOL v11 = 0;
    uint64_t v12 = 0;
    unint64_t v13 = *v8;
LABEL_13:
    if (v11 >= v12)
    {
      uint64_t v14 = (v11 - v10) >> 3;
      unint64_t v15 = v14 + 1;
      if ((unint64_t)(v14 + 1) >> 61) {
LABEL_104:
      }
        abort();
      if ((v12 - v10) >> 2 > v15) {
        unint64_t v15 = (v12 - v10) >> 2;
      }
      if ((unint64_t)(v12 - v10) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v16 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v16 = v15;
      }
      if (v16)
      {
        if (v16 >> 61) {
LABEL_105:
        }
          sub_1CB833614();
        uint64_t v17 = (char *)operator new(8 * v16);
      }
      else
      {
        uint64_t v17 = 0;
      }
      uint64_t v18 = (unint64_t *)&v17[8 * v14];
      *uint64_t v18 = v13;
      unint64_t v73 = (uint64_t *)(v18 + 1);
      while (v11 != v10)
      {
        unint64_t v19 = *((void *)v11 - 1);
        v11 -= 8;
        *--uint64_t v18 = v19;
      }
      uint64_t v12 = &v17[8 * v16];
      if (v10) {
        operator delete(v10);
      }
      uint64_t v10 = (char *)v18;
    }
    else
    {
      *(void *)BOOL v11 = v13;
      unint64_t v73 = (uint64_t *)(v11 + 8);
    }
    uint64_t v20 = v8 + 1;
    while (v20 != v9)
    {
      unint64_t v21 = *v20++;
      unint64_t v13 = v21;
      if (v21 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        int v8 = v20 - 1;
        BOOL v11 = (char *)v73;
        goto LABEL_13;
      }
    }
  }
  if ((char *)v73 - v10 >= 16) {
    qsort(v10, (unint64_t)((char *)v73 - v10) >> 3, 8uLL, (int (__cdecl *)(const void *, const void *))sub_1CD05A4C0);
  }
  std::string __p = (uint64_t *)v10;
  uint64_t v22 = *(unsigned int *)(a2 + 8);
  if (v22)
  {
    for (uint64_t i = 0; i != v22; ++i)
    {
      uint64_t v24 = *(void *)(*(void *)a2 + 16 * i + 8);
      uint64_t v25 = *(unsigned int *)(v24 + 72);
      if (v25)
      {
        unsigned int v26 = *(uint64_t **)(v24 + 64);
        uint64_t v27 = &v26[v25];
        do
        {
          uint64_t v28 = sub_1CD4F7F5C((uint64_t)v76, v26);
          uint64_t v29 = v28;
          uint64_t v31 = (void *)v28[2];
          unint64_t v30 = v28[3];
          if ((unint64_t)v31 >= v30)
          {
            int v33 = (void *)v28[1];
            uint64_t v34 = v31 - v33;
            unint64_t v35 = v34 + 1;
            if ((unint64_t)(v34 + 1) >> 61) {
              goto LABEL_104;
            }
            uint64_t v36 = v30 - (void)v33;
            if (v36 >> 2 > v35) {
              unint64_t v35 = v36 >> 2;
            }
            if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v37 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v37 = v35;
            }
            if (v37)
            {
              if (v37 >> 61) {
                goto LABEL_105;
              }
              uint64_t v38 = (char *)operator new(8 * v37);
            }
            else
            {
              uint64_t v38 = 0;
            }
            uint64_t v39 = &v38[8 * v34];
            *(void *)uint64_t v39 = v24;
            uint64_t v32 = v39 + 8;
            if (v31 != v33)
            {
              do
              {
                uint64_t v40 = *--v31;
                *((void *)v39 - 1) = v40;
                v39 -= 8;
              }
              while (v31 != v33);
              uint64_t v31 = (void *)v29[1];
            }
            v29[1] = v39;
            v29[2] = v32;
            v29[3] = &v38[8 * v37];
            if (v31) {
              operator delete(v31);
            }
          }
          else
          {
            *uint64_t v31 = v24;
            uint64_t v32 = v31 + 1;
          }
          v29[2] = v32;
          ++v26;
        }
        while (v26 != v27);
      }
    }
  }
  if (__p != v73)
  {
    for (int j = __p; j != v73; ++j)
    {
      uint64_t v75 = 0;
      uint64_t v43 = *j;
      uint64_t v75 = *j;
      uint64_t v44 = (llvm *)sub_1CD4F7F5C((uint64_t)v76, &v75);
      uint64_t v46 = *((void *)v44 + 1);
      uint64_t v45 = *((void *)v44 + 2);
      if (*(unsigned char *)(a1 + 8)) {
        BOOL v47 = 0;
      }
      else {
        BOOL v47 = v46 == v45;
      }
      if (v47) {
        continue;
      }
      uint64_t v48 = v44;
      uint64_t v49 = (llvm::raw_ostream *)llvm::outs(v44);
      uint64_t v50 = (unsigned char *)*((void *)v49 + 4);
      if (*((unsigned char **)v49 + 3) == v50)
      {
        uint64_t v49 = llvm::raw_ostream::write(v49, "\n", 1uLL);
      }
      else
      {
        *uint64_t v50 = 10;
        ++*((void *)v49 + 4);
      }
      uint64_t v51 = (llvm::raw_ostream *)llvm::outs(v49);
      uint64_t v52 = *(const void **)v43;
      unint64_t v53 = *(void *)(v43 + 8);
      uint64_t v54 = (llvm::raw_ostream *)*((void *)v51 + 4);
      if (v53 <= *((void *)v51 + 3) - (void)v54)
      {
        if (v53)
        {
          memcpy(v54, v52, *(void *)(v43 + 8));
          uint64_t v54 = (llvm::raw_ostream *)(*((void *)v51 + 4) + v53);
          *((void *)v51 + 4) = v54;
        }
      }
      else
      {
        llvm::raw_ostream::write(v51, (const char *)v52, *(void *)(v43 + 8));
        uint64_t v54 = (llvm::raw_ostream *)*((void *)v51 + 4);
      }
      uint64_t v55 = v71;
      if (*((void *)v51 + 3) - (void)v54 > 1uLL)
      {
        *(_WORD *)uint64_t v54 = 2618;
        *((void *)v51 + 4) += 2;
      }
      else
      {
        uint64_t v54 = llvm::raw_ostream::write(v51, ":\n", 2uLL);
      }
      uint64_t v56 = *(void *)(v43 + 24);
      unint64_t v57 = (llvm::raw_ostream *)llvm::outs(v54);
      uint64_t v58 = v57;
      if (v56)
      {
        unint64_t v62 = *(const void **)(v43 + 16);
        unint64_t v63 = *(void *)(v43 + 24);
        unint64_t v57 = (llvm::raw_ostream *)*((void *)v57 + 4);
        if (v63 <= *((void *)v58 + 3) - (void)v57)
        {
          if (v63)
          {
            memcpy(v57, v62, *(void *)(v43 + 24));
            unint64_t v57 = (llvm::raw_ostream *)(*((void *)v58 + 4) + v63);
            *((void *)v58 + 4) = v57;
          }
        }
        else
        {
          llvm::raw_ostream::write(v58, (const char *)v62, *(void *)(v43 + 24));
          unint64_t v57 = (llvm::raw_ostream *)*((void *)v58 + 4);
        }
        uint64_t v55 = v71;
        if (*((void *)v58 + 3) - (void)v57 <= 1uLL)
        {
          unint64_t v57 = v58;
          uint64_t v60 = "\n\n";
          size_t v61 = 2;
          goto LABEL_88;
        }
        *(_WORD *)unint64_t v57 = 2570;
        uint64_t v69 = *((void *)v58 + 4) + 2;
      }
      else
      {
        uint64_t v59 = (unsigned char *)*((void *)v57 + 4);
        if (*((unsigned char **)v57 + 3) == v59)
        {
          uint64_t v60 = "\n";
          size_t v61 = 1;
LABEL_88:
          unint64_t v57 = llvm::raw_ostream::write(v57, v60, v61);
          goto LABEL_89;
        }
        *uint64_t v59 = 10;
        uint64_t v69 = *((void *)v57 + 4) + 1;
      }
      *((void *)v58 + 4) = v69;
LABEL_89:
      if (v46 == v45)
      {
        size_t v67 = (llvm::raw_ostream *)llvm::outs(v57);
        size_t v68 = (void *)*((void *)v67 + 4);
        if (*((void *)v67 + 3) - (void)v68 > 0x26uLL)
        {
          qmemcpy(v68, "  This option category has no options.\n", 39);
          *((void *)v67 + 4) += 39;
        }
        else
        {
          llvm::raw_ostream::write(v67, "  This option category has no options.\n", 0x27uLL);
        }
      }
      else
      {
        char v64 = (uint64_t *)*((void *)v48 + 1);
        BOOL v65 = (uint64_t *)*((void *)v48 + 2);
        while (v64 != v65)
        {
          uint64_t v66 = *v64++;
          (*(void (**)(uint64_t, uint64_t))(*(void *)v66 + 48))(v66, v55);
        }
      }
    }
  }
  uint64_t v41 = v76[0];
  sub_1CD6A1B6C(v76[0], v77);
  MEMORY[0x1D25D9CD0](v41, 8);
  if (__p)
  {
    operator delete(__p);
  }
}

void sub_1CD05A4AC()
{
}

uint64_t sub_1CD05A4C0(const void ***a1, const void ***a2)
{
  uint64_t v2 = (*a1)[1];
  uint64_t v3 = (*a2)[1];
  if (v3 >= v2) {
    size_t v4 = (size_t)(*a1)[1];
  }
  else {
    size_t v4 = (size_t)(*a2)[1];
  }
  if (v4)
  {
    int v5 = memcmp(**a1, **a2, v4);
    if (v5) {
      return (v5 >> 31) | 1u;
    }
  }
  if (v2 < v3) {
    unsigned int v7 = -1;
  }
  else {
    unsigned int v7 = 1;
  }
  if (v2 == v3) {
    return 0;
  }
  else {
    return v7;
  }
}

uint64_t sub_1CD05A524(uint64_t a1, __int16 a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5, uint64_t a6)
{
  char v14 = 0;
  uint64_t v11 = llvm::cl::parser<BOOL>::parse(a1, (void *)a1, a3, a4, a5, a6, &v14);
  if (v11) {
    return v11;
  }
  if (v14)
  {
    sub_1CD0551C4(*(void *)(a1 + 128), v8, v9, v10);
    exit(0);
  }
  *(_WORD *)(a1 + 12) = a2;
  uint64_t v12 = *(void *)(a1 + 176);
  if (v12)
  {
    (*(void (**)(uint64_t, char *))(*(void *)v12 + 48))(v12, &v14);
    return v11;
  }
  sub_1CB920400();
  return sub_1CD05A5C4();
}

uint64_t sub_1CD05A5C4()
{
  return 1;
}

void *sub_1CD05A5CC(void *a1)
{
  *a1 = &unk_1F26441C0;
  uint64_t v2 = a1 + 19;
  uint64_t v3 = (void *)a1[22];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }

  return sub_1CB87DD48(a1);
}

void sub_1CD05A680(void *a1)
{
  *a1 = &unk_1F26441C0;
  uint64_t v2 = a1 + 19;
  uint64_t v3 = (void *)a1[22];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  sub_1CB87DD48(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD05A748(uint64_t a1)
{
  return llvm::cl::basic_parser_impl::getOptionWidth(a1 + 144, a1);
}

llvm::raw_ostream *sub_1CD05A754(llvm::cl::Option *a1, unsigned int a2)
{
  return llvm::cl::basic_parser_impl::printOptionInfo((llvm::cl::Option *)((char *)a1 + 144), a1, a2);
}

llvm::raw_ostream *sub_1CD05A764(llvm::raw_ostream *result, int a2, int a3)
{
  if (a3)
  {
    uint64_t v3 = llvm::cl::basic_parser_impl::printOptionName(result, result, a2);
    uint64_t result = (llvm::raw_ostream *)llvm::outs(v3);
    size_t v4 = (void *)*((void *)result + 4);
    if (*((void *)result + 3) - (void)v4 > 0x1DuLL)
    {
      qmemcpy(v4, "= *cannot print option value*\n", 30);
      *((void *)result + 4) += 30;
    }
    else
    {
      return llvm::raw_ostream::write(result, "= *cannot print option value*\n", 0x1EuLL);
    }
  }
  return result;
}

uint64_t sub_1CD05A7F4()
{
  return 0;
}

void sub_1CD05A800()
{
}

void *sub_1CD05A814()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1F2644248;
  return result;
}

void sub_1CD05A84C(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2644248;
}

void sub_1CD05A878(llvm::cl::Option *this, uint64_t a2, uint64_t a3, void *a4, _WORD *a5, _WORD *a6, llvm::cl::OptionCategory **a7, uint64_t *a8)
{
  *((void *)this + 4) = a2;
  *((void *)this + 5) = a3;
  if (*((void *)this + 16))
  {
    uint64_t v31 = "cl::location(x) specified more than once!";
    __int16 v32 = 259;
    unint64_t v30 = (llvm::raw_ostream *)llvm::errs(this);
    llvm::cl::Option::error(this, (llvm::Twine *)&v31, 0, 0, v30);
  }
  else
  {
    *((void *)this + 16) = *a4;
  }
  __int16 v13 = *((_WORD *)this + 5) & 0xFF9F | (32 * (*a5 & 3));
  *((_WORD *)this + 5) = v13;
  *((_WORD *)this + 5) = (8 * (*a6 & 3)) | v13 & 0xFFE7;
  llvm::cl::Option::addCategory(this, *a7);
  uint64_t v14 = *a8;
  uint64_t v15 = *((void *)this + 12);
  uint64_t v16 = *((unsigned int *)this + 27);
  if (v15 != *((void *)this + 11))
  {
    unsigned int v20 = *((_DWORD *)this + 26);
    goto LABEL_14;
  }
  if (!v16)
  {
LABEL_11:
    unsigned int v20 = *((_DWORD *)this + 26);
    if (v16 < v20)
    {
      *((_DWORD *)this + 27) = v16 + 1;
      *(void *)(v15 + 8 * v16) = v14;
      return;
    }
LABEL_14:
    if (3 * v20 <= 4 * ((int)v16 - *((_DWORD *)this + 28)))
    {
      if (v20 >= 0x40) {
        v20 *= 2;
      }
      else {
        unsigned int v20 = 128;
      }
    }
    else if (v20 - v16 >= v20 >> 3)
    {
      goto LABEL_16;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::cl::Option *)((char *)this + 88), v20);
    unsigned int v20 = *((_DWORD *)this + 26);
    uint64_t v15 = *((void *)this + 12);
LABEL_16:
    unsigned int v21 = v20 - 1;
    unsigned int v22 = (v20 - 1) & ((v14 >> 4) ^ (v14 >> 9));
    size_t v23 = (void *)(v15 + 8 * v22);
    uint64_t v24 = *v23;
    if (*v23 == -1)
    {
      uint64_t v25 = 0;
LABEL_28:
      if (v25) {
        uint64_t v29 = v25;
      }
      else {
        uint64_t v29 = v23;
      }
      if (*v29 != v14)
      {
        if (*v29 == -2) {
          --*((_DWORD *)this + 28);
        }
        else {
          ++*((_DWORD *)this + 27);
        }
        *uint64_t v29 = v14;
      }
    }
    else
    {
      uint64_t v25 = 0;
      int v26 = 1;
      while (v24 != v14)
      {
        if (v25) {
          BOOL v27 = 0;
        }
        else {
          BOOL v27 = v24 == -2;
        }
        if (v27) {
          uint64_t v25 = v23;
        }
        unsigned int v28 = v22 + v26++;
        unsigned int v22 = v28 & v21;
        size_t v23 = (void *)(v15 + 8 * (v28 & v21));
        uint64_t v24 = *v23;
        if (*v23 == -1) {
          goto LABEL_28;
        }
      }
    }
    return;
  }
  uint64_t v17 = 0;
  uint64_t v18 = 8 * v16;
  unint64_t v19 = (void *)*((void *)this + 12);
  while (*v19 != v14)
  {
    if (*v19 == -2) {
      uint64_t v17 = v19;
    }
    ++v19;
    v18 -= 8;
    if (!v18)
    {
      if (!v17) {
        goto LABEL_11;
      }
      void *v17 = v14;
      --*((_DWORD *)this + 28);
      return;
    }
  }
}

uint64_t *sub_1CD05AA98(uint64_t a1, __int16 a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5, uint64_t a6)
{
  char v15 = 0;
  uint64_t v11 = (uint64_t *)llvm::cl::parser<BOOL>::parse(a1, (void *)a1, a3, a4, a5, a6, &v15);
  if ((v11 & 1) == 0)
  {
    if (v15)
    {
      uint64_t v11 = *(uint64_t **)(a1 + 128);
      if (!atomic_load_explicit(&qword_1EBCFABE8, memory_order_acquire)) {
        llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1EBCFABE8, (void *(*)(void))sub_1CD05B850, (void (*)(void *))sub_1CD05B978);
      }
      if ((*(_DWORD *)(qword_1EBCFABE8 + 132) - *(_DWORD *)(qword_1EBCFABE8 + 136)) >= 2)
      {
        if (!atomic_load_explicit(qword_1EBCFAC00, memory_order_acquire)) {
          llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EBCFAC00, (void *(*)(void))sub_1CD059090, (void (*)(void *))sub_1CD059908);
        }
        *(_WORD *)(qword_1EBCFAC00[0] + 138) &= 0xFF9Fu;
        uint64_t v14 = v11[1];
LABEL_14:
        sub_1CD0551C4(v14, v8, v9, v10);
        exit(0);
      }
    }
    else
    {
      *(_WORD *)(a1 + 12) = a2;
      uint64_t v12 = *(void *)(a1 + 176);
      if (v12)
      {
        (*(void (**)(uint64_t, char *))(*(void *)v12 + 48))(v12, &v15);
        return v11;
      }
      sub_1CB920400();
    }
    uint64_t v14 = *v11;
    goto LABEL_14;
  }
  return v11;
}

uint64_t sub_1CD05ABE8()
{
  return 1;
}

void *sub_1CD05ABF0(void *a1)
{
  *a1 = &unk_1F2644290;
  uint64_t v2 = a1 + 19;
  uint64_t v3 = (void *)a1[22];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }

  return sub_1CB87DD48(a1);
}

void sub_1CD05ACA4(void *a1)
{
  *a1 = &unk_1F2644290;
  uint64_t v2 = a1 + 19;
  uint64_t v3 = (void *)a1[22];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  sub_1CB87DD48(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD05AD6C(uint64_t a1)
{
  return llvm::cl::basic_parser_impl::getOptionWidth(a1 + 144, a1);
}

llvm::raw_ostream *sub_1CD05AD78(llvm::cl::Option *a1, unsigned int a2)
{
  return llvm::cl::basic_parser_impl::printOptionInfo((llvm::cl::Option *)((char *)a1 + 144), a1, a2);
}

llvm::raw_ostream *sub_1CD05AD88(llvm::raw_ostream *result, int a2, int a3)
{
  if (a3)
  {
    uint64_t v3 = llvm::cl::basic_parser_impl::printOptionName(result, result, a2);
    uint64_t result = (llvm::raw_ostream *)llvm::outs(v3);
    size_t v4 = (void *)*((void *)result + 4);
    if (*((void *)result + 3) - (void)v4 > 0x1DuLL)
    {
      qmemcpy(v4, "= *cannot print option value*\n", 30);
      *((void *)result + 4) += 30;
    }
    else
    {
      return llvm::raw_ostream::write(result, "= *cannot print option value*\n", 0x1EuLL);
    }
  }
  return result;
}

uint64_t sub_1CD05AE18()
{
  return 0;
}

void sub_1CD05AE24()
{
}

void *sub_1CD05AE38()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1F2644318;
  return result;
}

void sub_1CD05AE70(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2644318;
}

llvm *sub_1CD05AE9C(llvm *result, void *a2)
{
  if (a2[16])
  {
    size_t v4 = "cl::location(x) specified more than once!";
    __int16 v5 = 259;
    uint64_t v3 = (llvm::raw_ostream *)llvm::errs(result);
    return (llvm *)llvm::cl::Option::error(a2, (llvm::Twine *)&v4, 0, 0, v3);
  }
  else
  {
    a2[16] = result;
  }
  return result;
}

void sub_1CD05AF04(uint64_t a1, char a2, llvm::cl::OptionCategory **a3, uint64_t *a4)
{
  *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 10) & 0xFFE7 | (8 * (a2 & 3));
  llvm::cl::Option::addCategory((llvm::cl::Option *)a1, *a3);
  uint64_t v6 = *a4;
  uint64_t v7 = *(void *)(a1 + 96);
  uint64_t v8 = *(unsigned int *)(a1 + 108);
  if (v7 != *(void *)(a1 + 88))
  {
    unsigned int v12 = *(_DWORD *)(a1 + 104);
    goto LABEL_12;
  }
  if (!v8)
  {
LABEL_9:
    unsigned int v12 = *(_DWORD *)(a1 + 104);
    if (v8 < v12)
    {
      *(_DWORD *)(a1 + 108) = v8 + 1;
      *(void *)(v7 + 8 * v8) = v6;
      return;
    }
LABEL_12:
    if (3 * v12 <= 4 * ((int)v8 - *(_DWORD *)(a1 + 112)))
    {
      if (v12 >= 0x40) {
        v12 *= 2;
      }
      else {
        unsigned int v12 = 128;
      }
    }
    else if (v12 - v8 >= v12 >> 3)
    {
      goto LABEL_14;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)(a1 + 88), v12);
    unsigned int v12 = *(_DWORD *)(a1 + 104);
    uint64_t v7 = *(void *)(a1 + 96);
LABEL_14:
    unsigned int v13 = v12 - 1;
    unsigned int v14 = (v12 - 1) & ((v6 >> 4) ^ (v6 >> 9));
    char v15 = (void *)(v7 + 8 * v14);
    uint64_t v16 = *v15;
    if (*v15 == -1)
    {
      uint64_t v17 = 0;
LABEL_26:
      if (v17) {
        unsigned int v21 = v17;
      }
      else {
        unsigned int v21 = v15;
      }
      if (*v21 != v6)
      {
        if (*v21 == -2) {
          --*(_DWORD *)(a1 + 112);
        }
        else {
          ++*(_DWORD *)(a1 + 108);
        }
        *unsigned int v21 = v6;
      }
    }
    else
    {
      uint64_t v17 = 0;
      int v18 = 1;
      while (v16 != v6)
      {
        if (v17) {
          BOOL v19 = 0;
        }
        else {
          BOOL v19 = v16 == -2;
        }
        if (v19) {
          uint64_t v17 = v15;
        }
        unsigned int v20 = v14 + v18++;
        unsigned int v14 = v20 & v13;
        char v15 = (void *)(v7 + 8 * (v20 & v13));
        uint64_t v16 = *v15;
        if (*v15 == -1) {
          goto LABEL_26;
        }
      }
    }
    return;
  }
  uint64_t v9 = 0;
  uint64_t v10 = 8 * v8;
  uint64_t v11 = *(void **)(a1 + 96);
  while (*v11 != v6)
  {
    if (*v11 == -2) {
      uint64_t v9 = v11;
    }
    ++v11;
    v10 -= 8;
    if (!v10)
    {
      if (!v9) {
        goto LABEL_9;
      }
      void *v9 = v6;
      --*(_DWORD *)(a1 + 112);
      return;
    }
  }
}

uint64_t sub_1CD05B0A4(uint64_t a1, __int16 a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5, uint64_t a6)
{
  char v20 = 0;
  uint64_t v8 = llvm::cl::parser<BOOL>::parse(a1, (void *)a1, a3, a4, a5, a6, &v20);
  uint64_t v9 = v8;
  if (v8) {
    return v9;
  }
  if (v20)
  {
    if (!atomic_load_explicit(qword_1EBCFAC00, memory_order_acquire)) {
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EBCFAC00, (void *(*)(void))sub_1CD059090, (void (*)(void *))sub_1CD059908);
    }
    if (*(void *)(qword_1EBCFAC00[0] + 1408))
    {
      char v15 = (uint64_t *)sub_1CD05516C();
      llvm::outs((llvm *)v15);
      sub_1CD830DB4(v15[176]);
    }
    else
    {
      sub_1CD0561A4((llvm *)v8);
      if (!atomic_load_explicit(qword_1EBCFAC00, memory_order_acquire)) {
        llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EBCFAC00, (void *(*)(void))sub_1CD059090, (void (*)(void *))sub_1CD059908);
      }
      if (*(void *)(qword_1EBCFAC00[0] + 1416) != *(void *)(qword_1EBCFAC00[0] + 1424))
      {
        unsigned int v13 = (llvm::raw_ostream *)llvm::outs(v12);
        unsigned int v14 = (unsigned char *)*((void *)v13 + 4);
        if ((unint64_t)v14 >= *((void *)v13 + 3))
        {
          unsigned int v13 = llvm::raw_ostream::write(v13, 10);
        }
        else
        {
          *((void *)v13 + 4) = v14 + 1;
          *unsigned int v14 = 10;
        }
        if (!atomic_load_explicit(qword_1EBCFAC00, memory_order_acquire)) {
          llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EBCFAC00, (void *(*)(void))sub_1CD059090, (void (*)(void *))sub_1CD059908);
        }
        uint64_t v16 = *(void *)(qword_1EBCFAC00[0] + 1416);
        uint64_t v17 = *(void *)(qword_1EBCFAC00[0] + 1424);
        while (v16 != v17)
        {
          int v18 = llvm::outs(v13);
          uint64_t v19 = *(void *)(v16 + 24);
          if (!v19) {
            goto LABEL_23;
          }
          unsigned int v13 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t, void *))(*(void *)v19 + 48))(v19, v18);
          v16 += 32;
        }
      }
    }
    exit(0);
  }
  *(_WORD *)(a1 + 12) = a2;
  uint64_t v10 = *(void *)(a1 + 176);
  if (v10)
  {
    (*(void (**)(uint64_t, char *))(*(void *)v10 + 48))(v10, &v20);
    return v9;
  }
LABEL_23:
  sub_1CB920400();
  return sub_1CD05B29C();
}

uint64_t sub_1CD05B29C()
{
  return 1;
}

void *sub_1CD05B2A4(void *a1)
{
  *a1 = &unk_1F2644360;
  uint64_t v2 = a1 + 19;
  uint64_t v3 = (void *)a1[22];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }

  return sub_1CB87DD48(a1);
}

void sub_1CD05B358(void *a1)
{
  *a1 = &unk_1F2644360;
  uint64_t v2 = a1 + 19;
  uint64_t v3 = (void *)a1[22];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  sub_1CB87DD48(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD05B420(uint64_t a1)
{
  return llvm::cl::basic_parser_impl::getOptionWidth(a1 + 144, a1);
}

llvm::raw_ostream *sub_1CD05B42C(llvm::cl::Option *a1, unsigned int a2)
{
  return llvm::cl::basic_parser_impl::printOptionInfo((llvm::cl::Option *)((char *)a1 + 144), a1, a2);
}

llvm::raw_ostream *sub_1CD05B43C(llvm::raw_ostream *result, int a2, int a3)
{
  if (a3)
  {
    uint64_t v3 = llvm::cl::basic_parser_impl::printOptionName(result, result, a2);
    uint64_t result = (llvm::raw_ostream *)llvm::outs(v3);
    size_t v4 = (void *)*((void *)result + 4);
    if (*((void *)result + 3) - (void)v4 > 0x1DuLL)
    {
      qmemcpy(v4, "= *cannot print option value*\n", 30);
      *((void *)result + 4) += 30;
    }
    else
    {
      return llvm::raw_ostream::write(result, "= *cannot print option value*\n", 0x1EuLL);
    }
  }
  return result;
}

uint64_t sub_1CD05B4CC()
{
  return 0;
}

void sub_1CD05B4D8()
{
}

void *sub_1CD05B4EC()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1F26443E8;
  return result;
}

void sub_1CD05B524(uint64_t a1, void *a2)
{
  *a2 = &unk_1F26443E8;
}

void sub_1CD05B550(void *a1, int a2, uint64_t a3, int a4)
{
  unint64_t v35 = v39;
  uint64_t v36 = v39;
  uint64_t v37 = 32;
  int v38 = 0;
  uint64_t i = a1;
  if (a2)
  {
    for (uint64_t i = a1; !*i || *i == -8; ++i)
      ;
  }
  uint64_t v8 = &a1[a2];
  if (i != v8)
  {
    uint64_t v9 = *i;
    while (1)
    {
      uint64_t v10 = *(void *)(v9 + 8);
      int v11 = (*(unsigned __int16 *)(v10 + 10) >> 5) & 3;
      int v12 = v11 == 1 ? a4 : 1;
      if (v11 != 2 && v12 != 0) {
        break;
      }
      do
      {
LABEL_52:
        uint64_t v32 = i[1];
        ++i;
        uint64_t v9 = v32;
        if (v32) {
          BOOL v33 = v9 == -8;
        }
        else {
          BOOL v33 = 1;
        }
      }
      while (v33);
      if (i == v8) {
        goto LABEL_65;
      }
    }
    unsigned int v14 = v36;
    uint64_t v15 = HIDWORD(v37);
    if (v36 == v35)
    {
      if (HIDWORD(v37))
      {
        uint64_t v16 = 0;
        uint64_t v17 = 8 * HIDWORD(v37);
        int v18 = v36;
        while (*(void *)v18 != v10)
        {
          if (*(void *)v18 == -2) {
            uint64_t v16 = v18;
          }
          v18 += 8;
          v17 -= 8;
          if (!v17)
          {
            if (!v16) {
              goto LABEL_26;
            }
            *(void *)uint64_t v16 = v10;
            --v38;
            goto LABEL_50;
          }
        }
        goto LABEL_52;
      }
LABEL_26:
      unsigned int v19 = v37;
      if (HIDWORD(v37) < v37)
      {
        ++HIDWORD(v37);
        *(void *)&v36[8 * v15] = v10;
LABEL_50:
        uint64_t v29 = *(void *)(*i + 8);
        unint64_t v30 = *(unsigned int *)(a3 + 8);
        if (v30 >= *(unsigned int *)(a3 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        uint64_t v31 = (void *)(*(void *)a3 + 16 * v30);
        *uint64_t v31 = *i + 16;
        v31[1] = v29;
        ++*(_DWORD *)(a3 + 8);
        goto LABEL_52;
      }
    }
    else
    {
      unsigned int v19 = v37;
    }
    if (3 * v19 <= 4 * (HIDWORD(v37) - v38))
    {
      if (v19 >= 0x40) {
        v19 *= 2;
      }
      else {
        unsigned int v19 = 128;
      }
    }
    else if (v19 - HIDWORD(v37) >= v19 >> 3)
    {
LABEL_31:
      unsigned int v20 = v19 - 1;
      unsigned int v21 = (v19 - 1) & ((v10 >> 4) ^ (v10 >> 9));
      unsigned int v22 = &v14[8 * v21];
      uint64_t v23 = *(void *)v22;
      if (*(void *)v22 != -1)
      {
        uint64_t v24 = 0;
        int v25 = 1;
        while (v23 != v10)
        {
          if (v24) {
            BOOL v26 = 0;
          }
          else {
            BOOL v26 = v23 == -2;
          }
          if (v26) {
            uint64_t v24 = v22;
          }
          unsigned int v27 = v21 + v25++;
          unsigned int v21 = v27 & v20;
          unsigned int v22 = &v14[8 * (v27 & v20)];
          uint64_t v23 = *(void *)v22;
          if (*(void *)v22 == -1) {
            goto LABEL_43;
          }
        }
        goto LABEL_52;
      }
      uint64_t v24 = 0;
LABEL_43:
      if (v24) {
        unsigned int v28 = v24;
      }
      else {
        unsigned int v28 = v22;
      }
      if (*(void *)v28 == v10) {
        goto LABEL_52;
      }
      if (*(void *)v28 == -2) {
        --v38;
      }
      else {
        ++HIDWORD(v37);
      }
      *(void *)unsigned int v28 = v10;
      goto LABEL_50;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v35, v19);
    unsigned int v19 = v37;
    unsigned int v14 = v36;
    goto LABEL_31;
  }
LABEL_65:
  size_t v34 = *(unsigned int *)(a3 + 8);
  if (v34 >= 2) {
    qsort(*(void **)a3, v34, 0x10uLL, (int (__cdecl *)(const void *, const void *))sub_1CD05B80C);
  }
  if (v36 != v35) {
    free(v36);
  }
}

uint64_t sub_1CD05B80C(const char **a1, const char **a2)
{
  return strcmp(*a1, *a2);
}

uint64_t sub_1CD05B818(const char **a1, const char **a2)
{
  return strcmp(*a1, *a2);
}

BOOL sub_1CD05B824(uint64_t a1, uint64_t a2)
{
  return *(unsigned char *)(a2 + 9) && *(unsigned char *)(a1 + 9) && *(unsigned __int8 *)(a1 + 8) != *(unsigned __int8 *)(a2 + 8);
}

void sub_1CD05B850()
{
}

uint64_t sub_1CD05B978(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *(void **)(result + 280);
    if (v2 != *(void **)(v1 + 272)) {
      free(v2);
    }
    uint64_t v3 = *(void **)(v1 + 120);
    if (v3 != *(void **)(v1 + 112)) {
      free(v3);
    }
    size_t v4 = *(void **)(v1 + 64);
    if (v4 != (void *)(v1 + 80)) {
      free(v4);
    }
    __int16 v5 = *(void **)(v1 + 40);
    if (v5)
    {
      *(void *)(v1 + 48) = v5;
      operator delete(v5);
    }
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    JUMPOUT(0x1D25D9CE0);
  }
  return result;
}

uint64_t *sub_1CD05BA1C(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  unsigned int v3 = *(_DWORD *)(*result + 8);
  if (v3 >= *(_DWORD *)(*result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)v2 + 8 * v3) = a2;
  ++*(_DWORD *)(v2 + 8);
  return result;
}

uint64_t sub_1CD05BA7C(uint64_t result)
{
  if (**(unsigned char **)result)
  {
    uint64_t v1 = *(void *)(result + 8);
    unsigned int v2 = *(_DWORD *)(v1 + 8);
    if (v2 >= *(_DWORD *)(v1 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)v1 + 8 * v2) = 0;
    ++*(_DWORD *)(v1 + 8);
  }
  return result;
}

uint64_t *sub_1CD05BAE4(uint64_t *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *result;
  unsigned int v4 = *(_DWORD *)(*result + 8);
  if (v4 >= *(_DWORD *)(*result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  __int16 v5 = (void *)(*(void *)v3 + 16 * v4);
  *__int16 v5 = a2;
  v5[1] = a3;
  ++*(_DWORD *)(v3 + 8);
  return result;
}

uint64_t sub_1CD05BB58(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t llvm::crc32(uint64_t result, char *a2, uint64_t a3)
{
  if (a3)
  {
    unsigned int v3 = ~result;
    do
    {
      char v4 = *a2++;
      unsigned int v3 = dword_1CFB2E4B8[(v4 ^ v3)] ^ (v3 >> 8);
      --a3;
    }
    while (a3);
    return ~v3;
  }
  return result;
}

uint64_t llvm::ConvertUTF32toUTF16(unsigned int **a1, unint64_t a2, _WORD **a3, unint64_t a4, int a5)
{
  __int16 v5 = *a1;
  uint64_t v6 = *a3;
  if ((unint64_t)*a1 >= a2)
  {
    uint64_t v7 = 0;
    goto LABEL_20;
  }
  uint64_t v7 = 0;
  uint64_t v8 = *a1;
  while ((unint64_t)v6 < a4)
  {
    __int16 v5 = v8 + 1;
    unsigned int v9 = *v8;
    if (!HIWORD(*v8))
    {
      if (v9 >> 11 != 27)
      {
        *v6++ = v9;
        goto LABEL_15;
      }
      if (!a5)
      {
        uint64_t v7 = 3;
        goto LABEL_19;
      }
      goto LABEL_10;
    }
    if (v9 >= 0x110000)
    {
      if (!a5)
      {
        uint64_t v7 = 3;
        goto LABEL_15;
      }
LABEL_10:
      *v6++ = -3;
      goto LABEL_15;
    }
    if ((unint64_t)(v6 + 1) >= a4) {
      break;
    }
    *uint64_t v6 = ((v9 + 67043328) >> 10) - 10240;
    v6[1] = v9 & 0x3FF | 0xDC00;
    v6 += 2;
LABEL_15:
    ++v8;
    if ((unint64_t)v5 >= a2) {
      goto LABEL_20;
    }
  }
  uint64_t v7 = 2;
LABEL_19:
  __int16 v5 = v8;
LABEL_20:
  *a1 = v5;
  *a3 = v6;
  return v7;
}

uint64_t llvm::ConvertUTF16toUTF32(unint64_t *a1, unint64_t a2, int **a3, unint64_t a4, int a5)
{
  __int16 v5 = (unsigned __int16 *)*a1;
  uint64_t v6 = *a3;
  if (*a1 < a2)
  {
    uint64_t v7 = (unsigned __int16 *)*a1;
    while (1)
    {
      int v9 = *v7++;
      int v8 = v9;
      int v10 = v9 & 0xFC00;
      if (v10 == 55296)
      {
        if ((unint64_t)v7 >= a2)
        {
          uint64_t v12 = 1;
          goto LABEL_18;
        }
        int v11 = *v7;
        if ((v11 & 0xFC00) == 0xDC00)
        {
          int v8 = v11 + (v8 << 10) - 56613888;
          uint64_t v7 = v5 + 2;
        }
        else if (!a5)
        {
          goto LABEL_16;
        }
      }
      else if (!a5 && v10 == 56320)
      {
LABEL_16:
        uint64_t v12 = 3;
        goto LABEL_18;
      }
      if ((unint64_t)v6 >= a4)
      {
        uint64_t v12 = 2;
        goto LABEL_18;
      }
      *v6++ = v8;
      __int16 v5 = v7;
      if ((unint64_t)v7 >= a2)
      {
        uint64_t v12 = 0;
        __int16 v5 = v7;
        goto LABEL_18;
      }
    }
  }
  uint64_t v12 = 0;
LABEL_18:
  *a1 = (unint64_t)v5;
  *a3 = v6;
  return v12;
}

uint64_t llvm::ConvertUTF16toUTF8(unint64_t *a1, unint64_t a2, uint64_t *a3, unint64_t a4, int a5)
{
  __int16 v5 = (unsigned __int16 *)*a1;
  unint64_t v6 = *a3;
  if (*a1 < a2)
  {
    uint64_t v7 = (unsigned __int16 *)*a1;
    while (1)
    {
      unsigned int v9 = *v7++;
      unsigned int v8 = v9;
      int v10 = v9 & 0xFC00;
      if (v10 == 55296)
      {
        if ((unint64_t)v7 >= a2)
        {
          uint64_t v15 = 1;
          goto LABEL_31;
        }
        int v11 = *v7;
        if ((v11 & 0xFC00) == 0xDC00)
        {
          unsigned int v8 = v11 + (v8 << 10) - 56613888;
          uint64_t v7 = v5 + 2;
        }
        else if (!a5)
        {
          goto LABEL_29;
        }
      }
      else if (!a5 && v10 == 56320)
      {
LABEL_29:
        uint64_t v15 = 3;
        goto LABEL_31;
      }
      if (v8 < 0x10000) {
        __int16 v12 = 3;
      }
      else {
        __int16 v12 = 4;
      }
      if (v8 < 0x800) {
        __int16 v12 = 2;
      }
      if (v8 >= 0x80) {
        unsigned __int16 v13 = v12;
      }
      else {
        unsigned __int16 v13 = 1;
      }
      unint64_t v14 = v6 + v13;
      if (v14 > a4)
      {
        uint64_t v15 = 2;
        goto LABEL_31;
      }
      switch(v13)
      {
        case 1u:
          goto LABEL_24;
        case 2u:
          goto LABEL_23;
        case 3u:
          goto LABEL_22;
        case 4u:
          *(unsigned char *)--unint64_t v14 = v8 & 0x3F | 0x80;
          v8 >>= 6;
LABEL_22:
          *(unsigned char *)--unint64_t v14 = v8 & 0x3F | 0x80;
          v8 >>= 6;
LABEL_23:
          *(unsigned char *)--unint64_t v14 = v8 & 0x3F | 0x80;
          v8 >>= 6;
LABEL_24:
          *(unsigned char *)--unint64_t v14 = byte_1CFB2E8B8[v13] | v8;
          break;
        default:
          break;
      }
      unint64_t v6 = v14 + v13;
      __int16 v5 = v7;
      if ((unint64_t)v7 >= a2)
      {
        uint64_t v15 = 0;
        __int16 v5 = v7;
        goto LABEL_31;
      }
    }
  }
  uint64_t v15 = 0;
LABEL_31:
  *a1 = (unint64_t)v5;
  *a3 = v6;
  return v15;
}

BOOL llvm::isLegalUTF8Sequence(llvm *this, const unsigned __int8 *a2, const unsigned __int8 *a3)
{
  uint64_t v4 = byte_1CFB2E8BF[*(unsigned __int8 *)this] + 1;
  return a2 - (const unsigned __int8 *)this >= v4 && sub_1CD05BF68((unsigned __int8 *)this, v4);
}

BOOL sub_1CD05BF68(unsigned __int8 *a1, int a2)
{
  unsigned int v2 = &a1[a2];
  switch(a2)
  {
    case 1:
      unsigned int v3 = *a1;
      goto LABEL_3;
    case 2:
      goto LABEL_7;
    case 3:
      goto LABEL_6;
    case 4:
      int v5 = (char)*--v2;
      if (v5 > -65) {
        return 0;
      }
LABEL_6:
      int v6 = (char)*--v2;
      if (v6 > -65) {
        return 0;
      }
LABEL_7:
      int v7 = (char)*(v2 - 1);
      if (v7 > -65) {
        return 0;
      }
      unsigned int v8 = v7;
      unsigned int v3 = *a1;
      if (v3 > 0xEF)
      {
        if (v3 == 240)
        {
          if (v8 >= 0x90)
          {
            unsigned int v3 = 240;
            return v3 < 0xF5;
          }
          return 0;
        }
        if (v3 == 244)
        {
          if (v8 <= 0x8F)
          {
            unsigned int v3 = 244;
            return v3 < 0xF5;
          }
          return 0;
        }
      }
      else
      {
        if (v3 == 224)
        {
          if (v8 >= 0xA0)
          {
            unsigned int v3 = 224;
            return v3 < 0xF5;
          }
          return 0;
        }
        if (v3 == 237)
        {
          if (v8 <= 0x9F)
          {
            unsigned int v3 = 237;
            return v3 < 0xF5;
          }
          return 0;
        }
      }
LABEL_3:
      if ((char)v3 >= -62) {
        return v3 < 0xF5;
      }
      return 0;
    default:
      return 0;
  }
}

uint64_t llvm::getNumBytesForUTF8(llvm *this)
{
  return (byte_1CFB2E8BF[this] + 1);
}

BOOL llvm::isLegalUTF8String(unsigned __int8 **this, const unsigned __int8 **a2, const unsigned __int8 *a3)
{
  unsigned int v3 = *this;
  if (*this == (unsigned __int8 *)a2) {
    return 1;
  }
  while (1)
  {
    uint64_t v6 = byte_1CFB2E8BF[*v3] + 1;
    if ((char *)a2 - (char *)v3 < v6) {
      break;
    }
    BOOL result = sub_1CD05BF68(v3, byte_1CFB2E8BF[*v3] + 1);
    if (!result) {
      return result;
    }
    v3 += v6;
    *this = v3;
    if (v3 == (unsigned __int8 *)a2) {
      return 1;
    }
  }
  return 0;
}

uint64_t llvm::ConvertUTF8toUTF32Partial(unint64_t *a1, unsigned __int8 *a2, unsigned int **a3, unint64_t a4, int a5)
{
  return sub_1CD05C120(a1, a2, a3, a4, a5, 1);
}

uint64_t sub_1CD05C120(unint64_t *a1, unsigned __int8 *a2, unsigned int **a3, unint64_t a4, int a5, int a6)
{
  uint64_t v6 = (unsigned __int8 *)*a1;
  int v7 = *a3;
  if (*a1 >= (unint64_t)a2)
  {
    uint64_t v10 = 0;
    goto LABEL_64;
  }
  uint64_t v10 = 0;
  if (a5) {
    BOOL v11 = a6 == 0;
  }
  else {
    BOOL v11 = 0;
  }
  char v12 = !v11;
  while (1)
  {
    uint64_t v13 = *v6;
    if (a2 - v6 <= (unsigned __int16)byte_1CFB2E8BF[v13])
    {
      if (v12)
      {
        uint64_t v10 = 1;
        goto LABEL_64;
      }
      goto LABEL_28;
    }
    if ((unint64_t)v7 >= a4)
    {
      uint64_t v10 = 2;
      goto LABEL_64;
    }
    uint64_t v14 = (unsigned __int16)byte_1CFB2E8BF[v13];
    unsigned int v15 = (unsigned __int16)byte_1CFB2E8BF[v13] + 1;
    if (sub_1CD05BF68(v6, v15)) {
      break;
    }
    if (!a5) {
      goto LABEL_66;
    }
LABEL_28:
    if (v6 == a2)
    {
      uint64_t v26 = 0;
      goto LABEL_48;
    }
    if ((v13 + 62) < 0x1Eu || v6 + 1 == a2)
    {
LABEL_34:
      uint64_t v26 = 1;
      goto LABEL_48;
    }
    int v27 = (char)v6[1];
    if (v13 == 224)
    {
      uint64_t v26 = 1;
      if ((v27 & 0xFFFFFFE0) == 0xFFFFFFA0) {
        uint64_t v26 = 2;
      }
      goto LABEL_48;
    }
    if ((v13 + 31) <= 0xBu) {
      goto LABEL_44;
    }
    if (v13 == 237)
    {
      BOOL v28 = v27 < -96;
      goto LABEL_45;
    }
    if ((v13 & 0xFE) == 0xEE)
    {
LABEL_44:
      BOOL v28 = v27 < -64;
LABEL_45:
      uint64_t v26 = 1;
LABEL_46:
      if (v28) {
        ++v26;
      }
      goto LABEL_48;
    }
    uint64_t v29 = (char *)(v6 + 2);
    if (v13 == 240)
    {
      if ((v27 + 112) > 0x2F) {
        goto LABEL_34;
      }
    }
    else if ((v13 + 15) > 2u)
    {
      if (v13 != 244) {
        goto LABEL_34;
      }
      uint64_t v26 = 1;
      if (v27 > -113) {
        goto LABEL_48;
      }
    }
    else if (v27 > -65)
    {
      goto LABEL_34;
    }
    if (v29 != (char *)a2)
    {
      BOOL v28 = *v29 < -64;
      uint64_t v26 = 2;
      goto LABEL_46;
    }
    uint64_t v26 = 2;
LABEL_48:
    v6 += v26;
LABEL_49:
    uint64_t v10 = 3;
    unsigned int v23 = 65533;
LABEL_50:
    *v7++ = v23;
    if (v6 >= a2) {
      goto LABEL_64;
    }
  }
  int v16 = 0;
  int v17 = v14;
  switch((int)v14)
  {
    case 0:
      goto LABEL_17;
    case 1:
      goto LABEL_16;
    case 2:
      goto LABEL_15;
    case 3:
      goto LABEL_14;
    case 4:
      goto LABEL_13;
    case 5:
      int v16 = v13 << 6;
      int v18 = *++v6;
      LODWORD(v13) = v18;
LABEL_13:
      int v19 = *++v6;
      int v16 = (v16 + v13) << 6;
      LODWORD(v13) = v19;
LABEL_14:
      int v20 = *++v6;
      int v16 = (v16 + v13) << 6;
      LODWORD(v13) = v20;
LABEL_15:
      int v21 = *++v6;
      int v16 = (v16 + v13) << 6;
      LODWORD(v13) = v21;
LABEL_16:
      int v22 = *++v6;
      int v17 = (v16 + v13) << 6;
      LODWORD(v13) = v22;
LABEL_17:
      ++v6;
      int v16 = v17 + v13;
      break;
    default:
      break;
  }
  unsigned int v23 = v16 - dword_1CFB2E9C0[v14];
  if (HIWORD(v23) > 0x10u) {
    goto LABEL_49;
  }
  BOOL v24 = (v23 & 0xFFFFF800) == 55296;
  if ((v23 & 0xFFFFF800) == 0xD800) {
    unsigned int v23 = 65533;
  }
  if (a5 || !v24) {
    goto LABEL_50;
  }
  v6 -= v15;
LABEL_66:
  uint64_t v10 = 3;
LABEL_64:
  *a1 = (unint64_t)v6;
  *a3 = v7;
  return v10;
}

uint64_t llvm::ConvertUTF8toUTF32(unint64_t *a1, unsigned __int8 *a2, unsigned int **a3, unint64_t a4, int a5)
{
  return sub_1CD05C120(a1, a2, a3, a4, a5, 0);
}

BOOL llvm::ConvertUTF8toWide(int a1, unsigned __int8 *a2, size_t a3, void **a4, void *a5)
{
  switch(a1)
  {
    case 1:
      uint64_t v13 = a2;
      if (!llvm::isLegalUTF8String(&v13, (const unsigned __int8 **)&a2[a3], (const unsigned __int8 *)a3))
      {
        *a5 = v13;
        int v9 = 3;
        return v9 == 0;
      }
      memcpy(*a4, a2, a3);
      int v9 = 0;
      uint64_t v10 = (char *)*a4 + a3;
      goto LABEL_4;
    case 2:
      char v12 = *a4;
      uint64_t v13 = a2;
      int v9 = llvm::ConvertUTF8toUTF16(&v13, (unint64_t)&a2[a3], &v12, (unint64_t)&v12[a3], 0);
      if (v9)
      {
LABEL_8:
        *a5 = v13;
        return v9 == 0;
      }
      break;
    case 4:
      char v12 = *a4;
      uint64_t v13 = a2;
      int v9 = sub_1CD05C120((unint64_t *)&v13, &a2[a3], (unsigned int **)&v12, (unint64_t)&v12[2 * a3], 0, 0);
      if (v9) {
        goto LABEL_8;
      }
      break;
    default:
      int v9 = 0;
      return v9 == 0;
  }
  uint64_t v10 = v12;
LABEL_4:
  *a4 = v10;
  return v9 == 0;
}

BOOL llvm::convertUTF16ToUTF8String(char *a1, uint64_t a2, std::string *a3)
{
  return llvm::convertUTF16ToUTF8String(a1, 2 * a2, a3);
}

BOOL llvm::convertUTF32ToUTF8String(unsigned int *__src, uint64_t a2, std::string *this)
{
  if ((a2 & 3) != 0) {
    return 0;
  }
  if (!a2) {
    return 1;
  }
  int v7 = __src;
  uint64_t v25 = 0;
  uint64_t v26 = __src;
  unsigned int v8 = (char *)__src + a2;
  std::string __p = 0;
  BOOL v24 = 0;
  unsigned int v9 = *__src;
  if (*__src == -131072)
  {
    sub_1CD05CD1C((char **)&__p, 0, (char *)__src, v8, a2 >> 2);
    int v7 = (unsigned int *)__p;
    unsigned int v8 = v24;
    if (__p != v24)
    {
      uint64_t v10 = (unsigned int *)__p;
      do
      {
        *uint64_t v10 = bswap32(*v10);
        ++v10;
      }
      while (v10 != (unsigned int *)v8);
    }
    uint64_t v26 = v7;
    unsigned int v9 = *v7;
  }
  if (v9 == 65279) {
    uint64_t v26 = v7 + 1;
  }
  std::string::resize(this, (4 * a2) | 1, 0);
  char v11 = HIBYTE(this->__r_.__value_.__r.__words[2]);
  BOOL v12 = v11 < 0;
  uint64_t v13 = (std::string *)this->__r_.__value_.__r.__words[0];
  std::string::size_type size = this->__r_.__value_.__l.__size_;
  if (v11 >= 0) {
    uint64_t v13 = this;
  }
  int v22 = v13;
  std::string::size_type v15 = v11 & 0x7F;
  if (v12) {
    std::string::size_type v15 = size;
  }
  int v16 = llvm::ConvertUTF32toUTF8(&v26, (unint64_t)v8, (uint64_t *)&v22, (unint64_t)v13 + v15, 0);
  BOOL v3 = v16 == 0;
  if (v16)
  {
    if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
    {
      *this->__r_.__value_.__l.__data_ = 0;
      this->__r_.__value_.__l.__size_ = 0;
    }
    else
    {
      this->__r_.__value_.__s.__data_[0] = 0;
      *((unsigned char *)&this->__r_.__value_.__s + 23) = 0;
    }
  }
  else
  {
    if ((this->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v17 = this;
    }
    else {
      int v17 = (std::string *)this->__r_.__value_.__r.__words[0];
    }
    std::string::resize(this, (char *)v22 - (char *)v17, 0);
    std::string::push_back(this, 0);
    int v18 = SHIBYTE(this->__r_.__value_.__r.__words[2]);
    std::string::size_type v19 = this->__r_.__value_.__l.__size_;
    if (v18 < 0)
    {
      int v20 = (std::string *)this->__r_.__value_.__r.__words[0];
    }
    else
    {
      std::string::size_type v19 = HIBYTE(this->__r_.__value_.__r.__words[2]);
      int v20 = this;
    }
    std::string::size_type v21 = v19 - 1;
    if (v18 < 0) {
      this->__r_.__value_.__l.__size_ = v21;
    }
    else {
      *((unsigned char *)&this->__r_.__value_.__s + 23) = v21 & 0x7F;
    }
    v20->__r_.__value_.__s.__data_[v21] = 0;
  }
  if (__p)
  {
    BOOL v24 = (char *)__p;
    operator delete(__p);
  }
  return v3;
}

BOOL llvm::convertUTF32ToUTF8String(unsigned int *a1, uint64_t a2, std::string *a3)
{
  return llvm::convertUTF32ToUTF8String(a1, 4 * a2, a3);
}

uint64_t llvm::convertUTF8ToUTF16String(unsigned __int8 *a1, uint64_t a2, void *a3)
{
  if (a2)
  {
    int v20 = a1;
    unint64_t v5 = (unint64_t)&a1[a2];
    unint64_t v6 = a2 + 1;
    unint64_t v7 = a3[1];
    if (v7 != v6)
    {
      if (v7 <= v6)
      {
        unint64_t v15 = v5;
        unint64_t v17 = v6;
        if (a3[2] < v6) {
          llvm::SmallVectorBase<unsigned long long>::grow_pod();
        }
        if (v6 != v7)
        {
          bzero((void *)(*a3 + 2 * v7), 2 * (v6 - v7));
          unint64_t v5 = v15;
          unint64_t v6 = v17;
        }
      }
      a3[1] = v6;
    }
    std::string::size_type v19 = (_WORD *)*a3;
    int v8 = llvm::ConvertUTF8toUTF16(&v20, v5, &v19, (unint64_t)&v19[v6], 0);
    uint64_t result = v8 == 0;
    if (v8)
    {
      uint64_t v10 = 0;
    }
    else
    {
      unint64_t v12 = a3[1];
      uint64_t v13 = (uint64_t)v19 - *a3;
      unint64_t v14 = v13 >> 1;
      if (v12 != v13 >> 1)
      {
        if (v12 <= v14)
        {
          uint64_t v16 = v13 >> 1;
          unsigned int v18 = result;
          if (a3[2] < v14) {
            llvm::SmallVectorBase<unsigned long long>::grow_pod();
          }
          unint64_t v14 = v13 >> 1;
          uint64_t result = result;
          if (v12 != v16)
          {
            bzero((void *)(*a3 + 2 * v12), (size_t)v19 - *a3 + -2 * v12);
            unint64_t v14 = v16;
            uint64_t result = v18;
          }
        }
        a3[1] = v14;
      }
      if (v14 + 1 > a3[2]) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      *(_WORD *)(*a3 + 2 * v14) = 0;
      uint64_t v10 = a3[1];
    }
    a3[1] = v10;
  }
  else
  {
    uint64_t v11 = a3[1];
    if ((unint64_t)(v11 + 1) > a3[2]) {
      llvm::SmallVectorBase<unsigned long long>::grow_pod();
    }
    *(_WORD *)(*a3 + 2 * v11) = 0;
    return 1;
  }
  return result;
}

BOOL llvm::ConvertUTF8toWide(unint64_t a1, uint64_t a2, std::wstring *this)
{
  std::wstring::resize(this, a2 + 1, 0);
  if ((this->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unint64_t v6 = this;
  }
  else {
    unint64_t v6 = (std::wstring *)this->__r_.__value_.__r.__words[0];
  }
  uint64_t v11 = (char *)v6;
  unint64_t v12 = a1;
  int v7 = sub_1CD05C120(&v12, (unsigned __int8 *)(a1 + a2), (unsigned int **)&v11, (unint64_t)v6 + 4 * a2, 0, 0);
  int v8 = SHIBYTE(this->__r_.__value_.__r.__words[2]);
  if (v7)
  {
    if (v8 < 0)
    {
      *this->__r_.__value_.__l.__data_ = 0;
      this->__r_.__value_.__l.__size_ = 0;
    }
    else
    {
      this->__r_.__value_.__s.__data_[0] = 0;
      *((unsigned char *)&this->__r_.__value_.__s + 23) = 0;
    }
  }
  else
  {
    if (v8 >= 0) {
      unsigned int v9 = this;
    }
    else {
      unsigned int v9 = (std::wstring *)this->__r_.__value_.__r.__words[0];
    }
    std::wstring::resize(this, (v11 - (char *)v9) >> 2, 0);
  }
  return v7 == 0;
}

BOOL llvm::ConvertUTF8toWide(const char *a1, uint64_t a2)
{
  if (a1)
  {
    size_t v4 = strlen(a1);
    return llvm::ConvertUTF8toWide((unint64_t)a1, v4, (std::wstring *)a2);
  }
  else
  {
    if (*(char *)(a2 + 23) < 0)
    {
      **(_DWORD **)a2 = 0;
      *(void *)(a2 + 8) = 0;
    }
    else
    {
      *(_DWORD *)a2 = 0;
      *(unsigned char *)(a2 + 23) = 0;
    }
    return 1;
  }
}

BOOL llvm::convertWideToUTF8(uint64_t a1, std::string *this)
{
  char v3 = *(unsigned char *)(a1 + 23);
  BOOL v4 = v3 < 0;
  unint64_t v5 = *(unsigned int **)a1;
  uint64_t v6 = *(void *)(a1 + 8);
  if (v3 >= 0) {
    unint64_t v5 = (unsigned int *)a1;
  }
  unsigned int v18 = v5;
  uint64_t v7 = v3 & 0x7F;
  if (v4) {
    uint64_t v7 = v6;
  }
  unint64_t v8 = (unint64_t)&v5[v7];
  std::string::resize(this, 4 * v7, 0);
  char v9 = HIBYTE(this->__r_.__value_.__r.__words[2]);
  BOOL v10 = v9 < 0;
  uint64_t v11 = (std::string *)this->__r_.__value_.__r.__words[0];
  std::string::size_type size = this->__r_.__value_.__l.__size_;
  if (v9 >= 0) {
    uint64_t v11 = this;
  }
  unint64_t v17 = v11;
  std::string::size_type v13 = v9 & 0x7F;
  if (v10) {
    std::string::size_type v13 = size;
  }
  int v14 = llvm::ConvertUTF32toUTF8(&v18, v8, (uint64_t *)&v17, (unint64_t)v11 + v13, 0);
  if (v14)
  {
    if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
    {
      *this->__r_.__value_.__l.__data_ = 0;
      this->__r_.__value_.__l.__size_ = 0;
    }
    else
    {
      this->__r_.__value_.__s.__data_[0] = 0;
      *((unsigned char *)&this->__r_.__value_.__s + 23) = 0;
    }
  }
  else
  {
    if ((this->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unint64_t v15 = this;
    }
    else {
      unint64_t v15 = (std::string *)this->__r_.__value_.__r.__words[0];
    }
    std::string::resize(this, (char *)v17 - (char *)v15, 0);
  }
  return v14 == 0;
}

void sub_1CD05CADC(char **a1, char *__src, char *a3, uint64_t a4)
{
  if (a4 < 1) {
    return;
  }
  unint64_t v8 = *a1;
  unint64_t v7 = (unint64_t)a1[1];
  uint64_t v9 = -(uint64_t)*a1;
  BOOL v10 = &(*a1)[v9 & 0xFFFFFFFFFFFFFFFELL];
  uint64_t v11 = a1[2];
  if (a4 > (uint64_t)&v11[-v7] >> 1)
  {
    uint64_t v12 = a4 + ((uint64_t)(v7 - (void)v8) >> 1);
    if (v12 < 0) {
      abort();
    }
    unint64_t v13 = v11 - v8;
    if (v13 > v12) {
      uint64_t v12 = v13;
    }
    if (v13 >= 0x7FFFFFFFFFFFFFFELL) {
      uint64_t v14 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v14 = v12;
    }
    __srca = &(*a1)[v9 & 0xFFFFFFFFFFFFFFFELL];
    if (v14)
    {
      if (v14 < 0) {
        sub_1CB833614();
      }
      unint64_t v15 = (char *)operator new(2 * v14);
    }
    else
    {
      unint64_t v15 = 0;
    }
    BOOL v24 = &v15[2 * (v9 >> 1)];
    memcpy(v24, __src, 2 * a4);
    unint64_t v25 = (v9 & 0xFFFFFFFFFFFFFFFELL) + 2 * a4;
    if (v8)
    {
      uint64_t v26 = 2 * (v9 >> 1);
      do
      {
        *(_WORD *)&v15[v26 - 2] = *(_WORD *)&v8[v26 - 2];
        v26 -= 2;
      }
      while (v26);
      BOOL v24 = v15;
    }
    int v27 = &v15[v25];
    size_t v28 = v7 - (void)__srca;
    if (v28) {
      memmove(&v15[v25], __srca, v28);
    }
    *a1 = v24;
    a1[1] = &v27[v28];
    a1[2] = &v15[2 * v14];
    if (v8)
    {
      operator delete(v8);
    }
    return;
  }
  uint64_t v16 = (uint64_t)(v7 - (void)v10) >> 1;
  if (v16 >= a4)
  {
    unint64_t v17 = &__src[2 * a4];
    std::string::size_type v19 = a1[1];
LABEL_18:
    int v20 = &v10[2 * a4];
    std::string::size_type v21 = (__int16 *)&v19[-2 * a4];
    int v22 = v19;
    if ((unint64_t)v21 < v7)
    {
      int v22 = v19;
      do
      {
        __int16 v23 = *v21++;
        *(_WORD *)int v22 = v23;
        v22 += 2;
      }
      while ((unint64_t)v21 < v7);
    }
    a1[1] = v22;
    if (v19 != v20) {
      memmove(&v19[-2 * ((v19 - v20) >> 1)], v10, v19 - v20);
    }
    if (v17 != __src)
    {
      memmove(v10, __src, v17 - __src);
    }
    return;
  }
  unint64_t v17 = &__src[2 * v16];
  int64_t v18 = a3 - v17;
  if (a3 != v17) {
    memmove(a1[1], &__src[2 * v16], a3 - v17);
  }
  std::string::size_type v19 = (char *)(v7 + v18);
  a1[1] = (char *)(v7 + v18);
  if ((uint64_t)(v7 - (void)v10) >= 1) {
    goto LABEL_18;
  }
}

char *sub_1CD05CD1C(char **a1, char *a2, char *__src, char *a4, uint64_t a5)
{
  unint64_t v5 = *a1;
  uint64_t v6 = a2 - *a1;
  unint64_t v7 = &(*a1)[v6 & 0xFFFFFFFFFFFFFFFCLL];
  if (a5 < 1) {
    return v7;
  }
  unint64_t v12 = (unint64_t)a1[1];
  uint64_t v11 = a1[2];
  if (a5 > (uint64_t)&v11[-v12] >> 2)
  {
    unint64_t v13 = a5 + ((uint64_t)(v12 - (void)v5) >> 2);
    if (v13 >> 62) {
      abort();
    }
    uint64_t v15 = v11 - v5;
    if (v15 >> 1 > v13) {
      unint64_t v13 = v15 >> 1;
    }
    if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v13 = 0x3FFFFFFFFFFFFFFFLL;
    }
    unint64_t v32 = v13;
    if (v13)
    {
      if (v13 >> 62) {
        sub_1CB833614();
      }
      uint64_t v16 = (char *)operator new(4 * v13);
    }
    else
    {
      uint64_t v16 = 0;
    }
    unint64_t v25 = &v16[4 * (v6 >> 2)];
    memcpy(v25, __src, 4 * a5);
    unint64_t v26 = (v6 & 0xFFFFFFFFFFFFFFFCLL) + 4 * a5;
    int v27 = v25;
    if (v5 != a2)
    {
      uint64_t v28 = 4 * (v6 >> 2);
      do
      {
        *(_DWORD *)&v16[v28 - 4] = *(_DWORD *)&v5[v28 - 4];
        v28 -= 4;
      }
      while (v28);
      unint64_t v25 = v16;
    }
    uint64_t v29 = &v16[v26];
    size_t v30 = v12 - (void)v7;
    if (v30) {
      memmove(v29, v7, v30);
    }
    *a1 = v25;
    a1[1] = &v29[v30];
    a1[2] = &v16[4 * v32];
    if (v5) {
      operator delete(v5);
    }
    return v27;
  }
  uint64_t v17 = (uint64_t)(v12 - (void)v7) >> 2;
  if (v17 >= a5)
  {
    int64_t v18 = &__src[4 * a5];
    int v20 = a1[1];
LABEL_17:
    std::string::size_type v21 = &v7[4 * a5];
    int v22 = (int *)&v20[-4 * a5];
    __int16 v23 = v20;
    if ((unint64_t)v22 < v12)
    {
      __int16 v23 = v20;
      do
      {
        int v24 = *v22++;
        *(_DWORD *)__int16 v23 = v24;
        v23 += 4;
      }
      while ((unint64_t)v22 < v12);
    }
    a1[1] = v23;
    if (v20 != v21) {
      memmove(&v20[-4 * ((v20 - v21) >> 2)], v7, v20 - v21);
    }
    if (v18 != __src) {
      memmove(v7, __src, v18 - __src);
    }
    return v7;
  }
  int64_t v18 = &__src[4 * v17];
  int64_t v19 = a4 - v18;
  if (a4 != v18) {
    memmove(a1[1], &__src[4 * v17], a4 - v18);
  }
  int v20 = (char *)(v12 + v19);
  a1[1] = (char *)(v12 + v19);
  if ((uint64_t)(v12 - (void)v7) >= 1) {
    goto LABEL_17;
  }
  return v7;
}

uint64_t llvm::CrashRecoveryContext::CrashRecoveryContext(uint64_t this)
{
  *(_DWORD *)(this + 20) = 0;
  *(unsigned char *)(this + 24) = 0;
  *(void *)this = 0;
  *(void *)(this + 8) = 0;
  *(unsigned char *)(this + 16) = 0;
  return this;
}

{
  *(_DWORD *)(this + 20) = 0;
  *(unsigned char *)(this + 24) = 0;
  *(void *)this = 0;
  *(void *)(this + 8) = 0;
  *(unsigned char *)(this + 16) = 0;
  return this;
}

BOOL llvm::CrashRecoveryContext::isRecoveringFromCrash(llvm::CrashRecoveryContext *this)
{
  if (!atomic_load_explicit(qword_1EBCFAC20, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EBCFAC20, (void *(*)(void))sub_1CD831C3C, (void (*)(void *))sub_1CD831CBC);
  }
  return pthread_getspecific(*(void *)(qword_1EBCFAC20[0] + 8)) != 0;
}

const char *llvm::CrashRecoveryContext::getStacktrace(llvm::CrashRecoveryContext *this)
{
  if (!*((unsigned char *)this + 16)) {
    return "";
  }
  uint64_t v1 = *(void *)this;
  if (!*(void *)this) {
    return "";
  }
  uint64_t v4 = *(void *)(v1 + 216);
  uint64_t v2 = v1 + 216;
  uint64_t v3 = v4;
  if (*(char *)(v2 + 23) >= 0) {
    return (const char *)v2;
  }
  else {
    return (const char *)v3;
  }
}

__int32 *sub_1CD05CFF4(uint64_t a1, int a2, llvm::sys *a3)
{
  if (!atomic_load_explicit(qword_1EBCFAC38, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EBCFAC38, (void *(*)(void))sub_1CD05D21C, (void (*)(void *))sub_1CD05D29C);
  }
  uint64_t result = (__int32 *)pthread_setspecific(*(void *)(qword_1EBCFAC38[0] + 8), *(const void **)a1);
  *(unsigned char *)(a1 + 208) |= 1u;
  uint64_t v7 = *(void *)(a1 + 8);
  if (*(unsigned char *)(v7 + 24))
  {
    uint64_t result = llvm::sys::CleanupOnSignal(a3);
    uint64_t v7 = *(void *)(a1 + 8);
  }
  *(_DWORD *)(v7 + 20) = a2;
  if ((*(unsigned char *)(a1 + 208) & 8) != 0) {
    longjmp((int *)(a1 + 16), 1);
  }
  return result;
}

BOOL llvm::CrashRecoveryContext::throwIfCrash(llvm::CrashRecoveryContext *this)
{
  int v1 = (int)this;
  if ((int)this >= 129)
  {
    llvm::sys::unregisterHandlers(this);
    raise(v1 - 128);
  }
  return v1 > 128;
}

uint64_t sub_1CD05D0EC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 24)) {
    setpriority(3, 0, 4096);
  }
  uint64_t result = llvm::CrashRecoveryContext::RunSafely(*(void *)(a1 + 16), *(void (**)(uint64_t))a1, *(void *)(a1 + 8));
  *(unsigned char *)(a1 + 25) = result;
  return result;
}

__int32 *sub_1CD05D134(int a1)
{
  if (!atomic_load_explicit(qword_1EBCFAC38, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EBCFAC38, (void *(*)(void))sub_1CD05D21C, (void (*)(void *))sub_1CD05D29C);
  }
  uint64_t v2 = pthread_getspecific(*(void *)(qword_1EBCFAC38[0] + 8));
  if (v2)
  {
    uint64_t v3 = (uint64_t)v2;
    sigset_t v4 = 1 << (a1 - 1);
    if (a1 > 32) {
      sigset_t v4 = 0;
    }
    sigset_t v7 = v4;
    sigprocmask(2, &v7, 0);
    if (a1 == 13) {
      int v5 = 74;
    }
    else {
      int v5 = a1 + 128;
    }
    return sub_1CD05CFF4(v3, v5, (llvm::sys *)a1);
  }
  else
  {
    llvm::CrashRecoveryContext::Disable(0);
    return (__int32 *)raise(a1);
  }
}

void sub_1CD05D21C()
{
}

uint64_t sub_1CD05D29C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void *sub_1CD05D2C8(void *a1)
{
  *a1 = &unk_1F2647198;
  pthread_key_delete(a1[1]);
  return a1;
}

void sub_1CD05D310(void *a1)
{
  *a1 = &unk_1F2647198;
  pthread_key_delete(a1[1]);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD05D378(uint64_t a1)
{
  return 0;
}

_UNKNOWN **llvm::CSKYAttrs::getCSKYAttributeTags(llvm::CSKYAttrs *this)
{
  return &off_1E68534E0;
}

uint64_t llvm::CSKYAttributeParser::dspVersion@<X0>(llvm::CSKYAttributeParser *this@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  return llvm::ELFAttributeParser::parseStringAttribute((uint64_t *)this, "Tag_CSKY_DSP_VERSION", a2, (uint64_t)&off_1EA6186D8, 3uLL, a3);
}

uint64_t llvm::CSKYAttributeParser::vdspVersion@<X0>(llvm::CSKYAttributeParser *this@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  return llvm::ELFAttributeParser::parseStringAttribute((uint64_t *)this, "Tag_CSKY_VDSP_VERSION", a2, (uint64_t)&off_1EA6186F0, 3uLL, a3);
}

uint64_t llvm::CSKYAttributeParser::fpuVersion@<X0>(llvm::CSKYAttributeParser *this@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  return llvm::ELFAttributeParser::parseStringAttribute((uint64_t *)this, "Tag_CSKY_FPU_VERSION", a2, (uint64_t)&off_1EA618708, 4uLL, a3);
}

uint64_t llvm::CSKYAttributeParser::fpuABI@<X0>(llvm::CSKYAttributeParser *this@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  return llvm::ELFAttributeParser::parseStringAttribute((uint64_t *)this, "Tag_CSKY_FPU_ABI", a2, (uint64_t)&off_1EA618728, 4uLL, a3);
}

uint64_t llvm::CSKYAttributeParser::fpuRounding@<X0>(llvm::CSKYAttributeParser *this@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  return llvm::ELFAttributeParser::parseStringAttribute((uint64_t *)this, "Tag_CSKY_FPU_ROUNDING", a2, (uint64_t)&off_1EA618748, 2uLL, a3);
}

uint64_t llvm::CSKYAttributeParser::fpuDenormal@<X0>(llvm::CSKYAttributeParser *this@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  return llvm::ELFAttributeParser::parseStringAttribute((uint64_t *)this, "Tag_CSKY_FPU_DENORMAL", a2, (uint64_t)&off_1EA618758, 2uLL, a3);
}

uint64_t llvm::CSKYAttributeParser::fpuException@<X0>(llvm::CSKYAttributeParser *this@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  return llvm::ELFAttributeParser::parseStringAttribute((uint64_t *)this, "Tag_CSKY_FPU_EXCEPTION", a2, (uint64_t)&off_1EA618768, 2uLL, a3);
}

void llvm::CSKYAttributeParser::fpuHardFP(llvm::CSKYAttributeParser *this@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t ULEB128 = llvm::DataExtractor::getULEB128((uint64_t *)this + 16, (uint64_t *)this + 19, (void *)this + 20);
  uint64_t v16 = ULEB128;
  memset(&v15, 0, sizeof(v15));
  if (ULEB128)
  {
    std::string::append(&v15, 0, 0);
    std::string::append(&v15, "Half");
    int v7 = 0;
  }
  else
  {
    int v7 = 1;
  }
  if ((ULEB128 & 2) != 0)
  {
    if (ULEB128) {
      unint64_t v8 = " ";
    }
    else {
      unint64_t v8 = 0;
    }
    std::string::append(&v15, v8, ULEB128 & 1);
    std::string::append(&v15, "Single");
    int v7 = 0;
  }
  if ((ULEB128 & 4) != 0)
  {
    if (v7) {
      uint64_t v9 = 0;
    }
    else {
      uint64_t v9 = " ";
    }
    std::string::append(&v15, v9, v7 == 0);
    std::string::append(&v15, "Double");
  }
  if ((v15.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t size = *((unsigned char *)&v15.__r_.__value_.__s + 23) & 0x7F;
  }
  else {
    uint64_t size = v15.__r_.__value_.__l.__size_;
  }
  if (!size)
  {
    llvm::ELFAttributeParser::printAttribute((uint64_t)this, a2, ULEB128, (uint64_t)"", 0);
    unint64_t v12 = std::generic_category();
    v13[0] = "unknown Tag_CSKY_FPU_HARDFP value: ";
    v13[2] = &v16;
    __int16 v14 = 3075;
    sub_1CD4FF4BC(22, (uint64_t)v12, (llvm::Twine *)v13);
  }
  if ((v15.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v11 = &v15;
  }
  else {
    uint64_t v11 = (std::string *)v15.__r_.__value_.__r.__words[0];
  }
  llvm::ELFAttributeParser::printAttribute((uint64_t)this, a2, ULEB128, (uint64_t)v11, size);
  *a3 = 0;
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v15.__r_.__value_.__l.__data_);
  }
}

uint64_t llvm::CSKYAttributeParser::handler@<X0>(uint64_t this@<X0>, BOOL *a2@<X2>, uint64_t a3@<X1>, void *a4@<X8>)
{
  uint64_t v6 = 0;
  *a2 = 0;
  while (llvm::CSKYAttributeParser::displayRoutines[v6] != a3)
  {
    v6 += 6;
    if (v6 == 78) {
      goto LABEL_7;
    }
  }
  this = (*(uint64_t (**)(uint64_t))&llvm::CSKYAttributeParser::displayRoutines[v6 + 2])(this);
  if (*a4) {
    return this;
  }
  *a2 = 1;
LABEL_7:
  *a4 = 0;
  return this;
}

void sub_1CD05D690(void *a1)
{
  sub_1CD6D6C64(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t llvm::CSKY::getFPUFeatures(int a1, const char ***a2)
{
  BOOL v2 = a1 >= 9 || a1 == 0;
  uint64_t v3 = !v2;
  if (!v2)
  {
    switch(a1)
    {
      case 2:
        uint64_t v9 = a2[1];
        unint64_t v8 = (unint64_t)a2[2];
        if ((unint64_t)v9 >= v8)
        {
          size_t v30 = *a2;
          uint64_t v31 = ((char *)v9 - (char *)*a2) >> 4;
          unint64_t v32 = v31 + 1;
          if ((unint64_t)(v31 + 1) >> 60) {
            goto LABEL_296;
          }
          uint64_t v33 = v8 - (void)v30;
          if (v33 >> 3 > v32) {
            unint64_t v32 = v33 >> 3;
          }
          if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v34 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v34 = v32;
          }
          if (v34)
          {
            if (v34 >> 60) {
              goto LABEL_297;
            }
            unint64_t v35 = (char *)operator new(16 * v34);
          }
          else
          {
            unint64_t v35 = 0;
          }
          size_t v81 = &v35[16 * v31];
          *(void *)size_t v81 = "+fpuv2_sf";
          *((void *)v81 + 1) = 9;
          BOOL v10 = (const char **)(v81 + 16);
          if (v9 != v30)
          {
            do
            {
              *((_OWORD *)v81 - 1) = *((_OWORD *)v9 - 1);
              v81 -= 16;
              v9 -= 2;
            }
            while (v9 != v30);
            uint64_t v9 = *a2;
          }
          *a2 = (const char **)v81;
          a2[1] = v10;
          a2[2] = (const char **)&v35[16 * v34];
          if (v9) {
            operator delete(v9);
          }
        }
        else
        {
          const std::string::value_type *v9 = "+fpuv2_sf";
          v9[1] = (const char *)9;
          BOOL v10 = v9 + 2;
        }
        a2[1] = v10;
        unint64_t v82 = (unint64_t)a2[2];
        if ((unint64_t)v10 < v82)
        {
          std::string v15 = "+fpuv2_df";
          goto LABEL_198;
        }
        uint64_t v83 = *a2;
        uint64_t v84 = ((char *)v10 - (char *)*a2) >> 4;
        unint64_t v85 = v84 + 1;
        if (!((unint64_t)(v84 + 1) >> 60))
        {
          uint64_t v86 = v82 - (void)v83;
          if (v86 >> 3 > v85) {
            unint64_t v85 = v86 >> 3;
          }
          if ((unint64_t)v86 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v87 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v87 = v85;
          }
          if (!v87)
          {
            uint64_t v88 = 0;
LABEL_214:
            int v97 = &v88[16 * v84];
            size_t v98 = &v88[16 * v87];
            *(void *)int v97 = "+fpuv2_df";
            *((void *)v97 + 1) = 9;
            char v99 = (const char **)(v97 + 16);
            if (v10 != v83)
            {
              do
              {
                *((_OWORD *)v97 - 1) = *((_OWORD *)v10 - 1);
                v97 -= 16;
                v10 -= 2;
              }
              while (v10 != v83);
              goto LABEL_234;
            }
LABEL_237:
            *a2 = (const char **)v97;
            a2[1] = v99;
            a2[2] = (const char **)v98;
LABEL_238:
            int v130 = v10;
LABEL_293:
            operator delete(v130);
            goto LABEL_294;
          }
          if (!(v87 >> 60))
          {
            uint64_t v88 = (char *)operator new(16 * v87);
            goto LABEL_214;
          }
LABEL_297:
          sub_1CB833614();
        }
        goto LABEL_296;
      case 3:
        unint64_t v12 = a2[1];
        unint64_t v11 = (unint64_t)a2[2];
        if ((unint64_t)v12 >= v11)
        {
          uint64_t v36 = *a2;
          uint64_t v37 = ((char *)v12 - (char *)*a2) >> 4;
          unint64_t v38 = v37 + 1;
          if ((unint64_t)(v37 + 1) >> 60) {
            goto LABEL_296;
          }
          uint64_t v39 = v11 - (void)v36;
          if (v39 >> 3 > v38) {
            unint64_t v38 = v39 >> 3;
          }
          if ((unint64_t)v39 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v40 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v40 = v38;
          }
          if (v40)
          {
            if (v40 >> 60) {
              goto LABEL_297;
            }
            uint64_t v41 = (char *)operator new(16 * v40);
          }
          else
          {
            uint64_t v41 = 0;
          }
          size_t v89 = &v41[16 * v37];
          *(void *)size_t v89 = "+fpuv2_sf";
          *((void *)v89 + 1) = 9;
          unint64_t v13 = (const char **)(v89 + 16);
          if (v12 != v36)
          {
            do
            {
              *((_OWORD *)v89 - 1) = *((_OWORD *)v12 - 1);
              v89 -= 16;
              v12 -= 2;
            }
            while (v12 != v36);
            unint64_t v12 = *a2;
          }
          *a2 = (const char **)v89;
          a2[1] = v13;
          a2[2] = (const char **)&v41[16 * v40];
          if (v12) {
            operator delete(v12);
          }
        }
        else
        {
          const std::error_category *v12 = "+fpuv2_sf";
          v12[1] = (const char *)9;
          unint64_t v13 = v12 + 2;
        }
        a2[1] = v13;
        unint64_t v90 = (unint64_t)a2[2];
        if ((unint64_t)v13 < v90)
        {
          std::string *v13 = "+fpuv2_df";
          v13[1] = (const char *)9;
          unint64_t v74 = v13 + 2;
          goto LABEL_253;
        }
        BOOL v91 = *a2;
        uint64_t v92 = ((char *)v13 - (char *)*a2) >> 4;
        unint64_t v93 = v92 + 1;
        if ((unint64_t)(v92 + 1) >> 60) {
          goto LABEL_296;
        }
        uint64_t v94 = v90 - (void)v91;
        if (v94 >> 3 > v93) {
          unint64_t v93 = v94 >> 3;
        }
        if ((unint64_t)v94 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v95 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v95 = v93;
        }
        if (v95)
        {
          if (v95 >> 60) {
            goto LABEL_297;
          }
          BOOL v96 = (char *)operator new(16 * v95);
        }
        else
        {
          BOOL v96 = 0;
        }
        BOOL v126 = (const char **)&v96[16 * v92];
        v127 = (const char **)&v96[16 * v95];
        *BOOL v126 = "+fpuv2_df";
        v126[1] = (const char *)9;
        unint64_t v74 = v126 + 2;
        if (v13 == v91)
        {
          *a2 = v126;
          a2[1] = v74;
          a2[2] = v127;
        }
        else
        {
          do
          {
            *((_OWORD *)v126 - 1) = *((_OWORD *)v13 - 1);
            v126 -= 2;
            v13 -= 2;
          }
          while (v13 != v91);
          unint64_t v13 = *a2;
          *a2 = v126;
          a2[1] = v74;
          a2[2] = v127;
          if (!v13)
          {
LABEL_253:
            a2[1] = v74;
            unint64_t v138 = (unint64_t)a2[2];
            if ((unint64_t)v74 < v138) {
              goto LABEL_254;
            }
            unint64_t v141 = *a2;
            uint64_t v142 = ((char *)v74 - (char *)*a2) >> 4;
            unint64_t v143 = v142 + 1;
            if (!((unint64_t)(v142 + 1) >> 60))
            {
              uint64_t v144 = v138 - (void)v141;
              if (v144 >> 3 > v143) {
                unint64_t v143 = v144 >> 3;
              }
              if ((unint64_t)v144 >= 0x7FFFFFFFFFFFFFF0) {
                unint64_t v145 = 0xFFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v145 = v143;
              }
              if (v145)
              {
                if (v145 >> 60) {
                  goto LABEL_297;
                }
                uint64_t v146 = (char *)operator new(16 * v145);
              }
              else
              {
                uint64_t v146 = 0;
              }
              uint64_t v154 = &v146[16 * v142];
              v155 = &v146[16 * v145];
              *(void *)uint64_t v154 = "+fdivdu";
              *((void *)v154 + 1) = 7;
              char v99 = (const char **)(v154 + 16);
              if (v74 != v141)
              {
                do
                {
                  *((_OWORD *)v154 - 1) = *((_OWORD *)v74 - 1);
                  v154 -= 16;
                  v74 -= 2;
                }
                while (v74 != v141);
                goto LABEL_289;
              }
LABEL_291:
              *a2 = (const char **)v154;
              a2[1] = v99;
              a2[2] = (const char **)v155;
LABEL_292:
              int v130 = v74;
              goto LABEL_293;
            }
LABEL_296:
            abort();
          }
        }
        operator delete(v13);
        goto LABEL_253;
      case 4:
        BOOL v10 = a2[1];
        unint64_t v14 = (unint64_t)a2[2];
        if ((unint64_t)v10 >= v14)
        {
          unint64_t v42 = *a2;
          uint64_t v43 = ((char *)v10 - (char *)*a2) >> 4;
          unint64_t v44 = v43 + 1;
          if (!((unint64_t)(v43 + 1) >> 60))
          {
            uint64_t v45 = v14 - (void)v42;
            if (v45 >> 3 > v44) {
              unint64_t v44 = v45 >> 3;
            }
            if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v46 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v46 = v44;
            }
            if (v46)
            {
              if (v46 >> 60) {
                goto LABEL_297;
              }
              BOOL v47 = (char *)operator new(16 * v46);
            }
            else
            {
              BOOL v47 = 0;
            }
            int v97 = &v47[16 * v43];
            size_t v98 = &v47[16 * v46];
            *(void *)int v97 = "+fpuv2_sf";
            *((void *)v97 + 1) = 9;
            char v99 = (const char **)(v97 + 16);
            if (v10 == v42) {
              goto LABEL_235;
            }
            do
            {
              *((_OWORD *)v97 - 1) = *((_OWORD *)v10 - 1);
              v97 -= 16;
              v10 -= 2;
            }
            while (v10 != v42);
            goto LABEL_234;
          }
          goto LABEL_296;
        }
        std::string v15 = "+fpuv2_sf";
        goto LABEL_198;
      case 5:
        uint64_t v17 = a2[1];
        unint64_t v16 = (unint64_t)a2[2];
        if ((unint64_t)v17 >= v16)
        {
          uint64_t v48 = *a2;
          uint64_t v49 = ((char *)v17 - (char *)*a2) >> 4;
          unint64_t v50 = v49 + 1;
          if ((unint64_t)(v49 + 1) >> 60) {
            goto LABEL_296;
          }
          uint64_t v51 = v16 - (void)v48;
          if (v51 >> 3 > v50) {
            unint64_t v50 = v51 >> 3;
          }
          if ((unint64_t)v51 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v52 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v52 = v50;
          }
          if (v52)
          {
            if (v52 >> 60) {
              goto LABEL_297;
            }
            unint64_t v53 = (char *)operator new(16 * v52);
          }
          else
          {
            unint64_t v53 = 0;
          }
          long long v100 = &v53[16 * v49];
          *(void *)long long v100 = "+fpuv3_hf";
          *((void *)v100 + 1) = 9;
          int64_t v18 = (const char **)(v100 + 16);
          if (v17 != v48)
          {
            do
            {
              *((_OWORD *)v100 - 1) = *((_OWORD *)v17 - 1);
              v100 -= 16;
              v17 -= 2;
            }
            while (v17 != v48);
            uint64_t v17 = *a2;
          }
          *a2 = (const char **)v100;
          a2[1] = v18;
          a2[2] = (const char **)&v53[16 * v52];
          if (v17) {
            operator delete(v17);
          }
        }
        else
        {
          char *v17 = "+fpuv3_hf";
          v17[1] = (const char *)9;
          int64_t v18 = v17 + 2;
        }
        a2[1] = v18;
        unint64_t v101 = (unint64_t)a2[2];
        if ((unint64_t)v18 >= v101)
        {
          unint64_t v102 = *a2;
          uint64_t v103 = ((char *)v18 - (char *)*a2) >> 4;
          unint64_t v104 = v103 + 1;
          if ((unint64_t)(v103 + 1) >> 60) {
            goto LABEL_296;
          }
          uint64_t v105 = v101 - (void)v102;
          if (v105 >> 3 > v104) {
            unint64_t v104 = v105 >> 3;
          }
          if ((unint64_t)v105 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v106 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v106 = v104;
          }
          if (v106)
          {
            if (v106 >> 60) {
              goto LABEL_297;
            }
            uint64_t v107 = (char *)operator new(16 * v106);
          }
          else
          {
            uint64_t v107 = 0;
          }
          v128 = (const char **)&v107[16 * v103];
          unsigned int v129 = (const char **)&v107[16 * v106];
          char *v128 = "+fpuv3_sf";
          v128[1] = (const char *)9;
          unint64_t v74 = v128 + 2;
          if (v18 == v102)
          {
            *a2 = v128;
            a2[1] = v74;
            a2[2] = v129;
          }
          else
          {
            do
            {
              *((_OWORD *)v128 - 1) = *((_OWORD *)v18 - 1);
              v128 -= 2;
              v18 -= 2;
            }
            while (v18 != v102);
            int64_t v18 = *a2;
            *a2 = v128;
            a2[1] = v74;
            a2[2] = v129;
            if (!v18) {
              goto LABEL_266;
            }
          }
          operator delete(v18);
        }
        else
        {
          *int64_t v18 = "+fpuv3_sf";
          v18[1] = (const char *)9;
          unint64_t v74 = v18 + 2;
        }
LABEL_266:
        a2[1] = v74;
        unint64_t v147 = (unint64_t)a2[2];
        if ((unint64_t)v74 < v147)
        {
          long long v139 = "+fpuv3_df";
          uint64_t v140 = 9;
          goto LABEL_268;
        }
        v148 = *a2;
        uint64_t v149 = ((char *)v74 - (char *)*a2) >> 4;
        unint64_t v150 = v149 + 1;
        if ((unint64_t)(v149 + 1) >> 60) {
          goto LABEL_296;
        }
        uint64_t v151 = v147 - (void)v148;
        if (v151 >> 3 > v150) {
          unint64_t v150 = v151 >> 3;
        }
        if ((unint64_t)v151 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v152 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v152 = v150;
        }
        if (v152)
        {
          if (v152 >> 60) {
            goto LABEL_297;
          }
          uint64_t v153 = (char *)operator new(16 * v152);
        }
        else
        {
          uint64_t v153 = 0;
        }
        uint64_t v154 = &v153[16 * v149];
        v155 = &v153[16 * v152];
        *(void *)uint64_t v154 = "+fpuv3_df";
        *((void *)v154 + 1) = 9;
        char v99 = (const char **)(v154 + 16);
        if (v74 == v148) {
          goto LABEL_291;
        }
        do
        {
          *((_OWORD *)v154 - 1) = *((_OWORD *)v74 - 1);
          v154 -= 16;
          v74 -= 2;
        }
        while (v74 != v148);
        goto LABEL_289;
      case 6:
        BOOL v10 = a2[1];
        unint64_t v19 = (unint64_t)a2[2];
        if ((unint64_t)v10 < v19)
        {
          std::string v15 = "+fpuv3_hf";
LABEL_198:
          *BOOL v10 = v15;
          v10[1] = (const char *)9;
          char v99 = v10 + 2;
LABEL_294:
          a2[1] = v99;
          return v3;
        }
        uint64_t v54 = *a2;
        uint64_t v55 = ((char *)v10 - (char *)*a2) >> 4;
        unint64_t v56 = v55 + 1;
        if (!((unint64_t)(v55 + 1) >> 60))
        {
          uint64_t v57 = v19 - (void)v54;
          if (v57 >> 3 > v56) {
            unint64_t v56 = v57 >> 3;
          }
          if ((unint64_t)v57 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v58 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v58 = v56;
          }
          if (v58)
          {
            if (v58 >> 60) {
              goto LABEL_297;
            }
            uint64_t v59 = (char *)operator new(16 * v58);
          }
          else
          {
            uint64_t v59 = 0;
          }
          int v97 = &v59[16 * v55];
          size_t v98 = &v59[16 * v58];
          *(void *)int v97 = "+fpuv3_hf";
          *((void *)v97 + 1) = 9;
          char v99 = (const char **)(v97 + 16);
          if (v10 == v54) {
            goto LABEL_235;
          }
          do
          {
            *((_OWORD *)v97 - 1) = *((_OWORD *)v10 - 1);
            v97 -= 16;
            v10 -= 2;
          }
          while (v10 != v54);
LABEL_234:
          BOOL v10 = *a2;
LABEL_235:
          *a2 = (const char **)v97;
          a2[1] = v99;
          a2[2] = (const char **)v98;
          if (!v10) {
            goto LABEL_294;
          }
          goto LABEL_238;
        }
        goto LABEL_296;
      case 7:
        std::string::size_type v21 = a2[1];
        unint64_t v20 = (unint64_t)a2[2];
        if ((unint64_t)v21 >= v20)
        {
          uint64_t v60 = *a2;
          uint64_t v61 = ((char *)v21 - (char *)*a2) >> 4;
          unint64_t v62 = v61 + 1;
          if ((unint64_t)(v61 + 1) >> 60) {
            goto LABEL_296;
          }
          uint64_t v63 = v20 - (void)v60;
          if (v63 >> 3 > v62) {
            unint64_t v62 = v63 >> 3;
          }
          if ((unint64_t)v63 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v64 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v64 = v62;
          }
          if (v64)
          {
            if (v64 >> 60) {
              goto LABEL_297;
            }
            BOOL v65 = (char *)operator new(16 * v64);
          }
          else
          {
            BOOL v65 = 0;
          }
          char v108 = &v65[16 * v61];
          *(void *)char v108 = "+fpuv3_hf";
          *((void *)v108 + 1) = 9;
          BOOL v10 = (const char **)(v108 + 16);
          if (v21 != v60)
          {
            do
            {
              *((_OWORD *)v108 - 1) = *((_OWORD *)v21 - 1);
              v108 -= 16;
              v21 -= 2;
            }
            while (v21 != v60);
            std::string::size_type v21 = *a2;
          }
          *a2 = (const char **)v108;
          a2[1] = v10;
          a2[2] = (const char **)&v65[16 * v64];
          if (v21) {
            operator delete(v21);
          }
        }
        else
        {
          *std::string::size_type v21 = "+fpuv3_hf";
          v21[1] = (const char *)9;
          BOOL v10 = v21 + 2;
        }
        a2[1] = v10;
        unint64_t v109 = (unint64_t)a2[2];
        if ((unint64_t)v10 < v109)
        {
          std::string v15 = "+fpuv3_sf";
          goto LABEL_198;
        }
        uint64_t v110 = *a2;
        uint64_t v111 = ((char *)v10 - (char *)*a2) >> 4;
        unint64_t v112 = v111 + 1;
        if (!((unint64_t)(v111 + 1) >> 60))
        {
          uint64_t v113 = v109 - (void)v110;
          if (v113 >> 3 > v112) {
            unint64_t v112 = v113 >> 3;
          }
          if ((unint64_t)v113 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v114 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v114 = v112;
          }
          if (v114)
          {
            if (v114 >> 60) {
              goto LABEL_297;
            }
            unint64_t v115 = (char *)operator new(16 * v114);
          }
          else
          {
            unint64_t v115 = 0;
          }
          int v97 = &v115[16 * v111];
          size_t v98 = &v115[16 * v114];
          *(void *)int v97 = "+fpuv3_sf";
          *((void *)v97 + 1) = 9;
          char v99 = (const char **)(v97 + 16);
          if (v10 != v110)
          {
            do
            {
              *((_OWORD *)v97 - 1) = *((_OWORD *)v10 - 1);
              v97 -= 16;
              v10 -= 2;
            }
            while (v10 != v110);
            goto LABEL_234;
          }
          goto LABEL_237;
        }
        goto LABEL_296;
      case 8:
        __int16 v23 = a2[1];
        unint64_t v22 = (unint64_t)a2[2];
        if ((unint64_t)v23 >= v22)
        {
          uint64_t v66 = *a2;
          uint64_t v67 = ((char *)v23 - (char *)*a2) >> 4;
          unint64_t v68 = v67 + 1;
          if ((unint64_t)(v67 + 1) >> 60) {
            goto LABEL_296;
          }
          uint64_t v69 = v22 - (void)v66;
          if (v69 >> 3 > v68) {
            unint64_t v68 = v69 >> 3;
          }
          if ((unint64_t)v69 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v70 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v70 = v68;
          }
          if (v70)
          {
            if (v70 >> 60) {
              goto LABEL_297;
            }
            uint64_t v71 = (char *)operator new(16 * v70);
          }
          else
          {
            uint64_t v71 = 0;
          }
          uint64_t v116 = &v71[16 * v67];
          *(void *)uint64_t v116 = "+fpuv3_sf";
          *((void *)v116 + 1) = 9;
          BOOL v10 = (const char **)(v116 + 16);
          if (v23 != v66)
          {
            do
            {
              *((_OWORD *)v116 - 1) = *((_OWORD *)v23 - 1);
              v116 -= 16;
              v23 -= 2;
            }
            while (v23 != v66);
            __int16 v23 = *a2;
          }
          *a2 = (const char **)v116;
          a2[1] = v10;
          a2[2] = (const char **)&v71[16 * v70];
          if (v23) {
            operator delete(v23);
          }
        }
        else
        {
          *__int16 v23 = "+fpuv3_sf";
          v23[1] = (const char *)9;
          BOOL v10 = v23 + 2;
        }
        a2[1] = v10;
        unint64_t v117 = (unint64_t)a2[2];
        if ((unint64_t)v10 < v117)
        {
          std::string v15 = "+fpuv3_df";
          goto LABEL_198;
        }
        uint64_t v118 = *a2;
        uint64_t v119 = ((char *)v10 - (char *)*a2) >> 4;
        unint64_t v120 = v119 + 1;
        if (!((unint64_t)(v119 + 1) >> 60))
        {
          uint64_t v121 = v117 - (void)v118;
          if (v121 >> 3 > v120) {
            unint64_t v120 = v121 >> 3;
          }
          if ((unint64_t)v121 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v122 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v122 = v120;
          }
          if (v122)
          {
            if (v122 >> 60) {
              goto LABEL_297;
            }
            unint64_t v123 = (char *)operator new(16 * v122);
          }
          else
          {
            unint64_t v123 = 0;
          }
          int v97 = &v123[16 * v119];
          size_t v98 = &v123[16 * v122];
          *(void *)int v97 = "+fpuv3_df";
          *((void *)v97 + 1) = 9;
          char v99 = (const char **)(v97 + 16);
          if (v10 != v118)
          {
            do
            {
              *((_OWORD *)v97 - 1) = *((_OWORD *)v10 - 1);
              v97 -= 16;
              v10 -= 2;
            }
            while (v10 != v118);
            goto LABEL_234;
          }
          goto LABEL_237;
        }
        goto LABEL_296;
      default:
        uint64_t v6 = a2[1];
        unint64_t v5 = (unint64_t)a2[2];
        if ((unint64_t)v6 >= v5)
        {
          int v24 = *a2;
          uint64_t v25 = ((char *)v6 - (char *)*a2) >> 4;
          unint64_t v26 = v25 + 1;
          if ((unint64_t)(v25 + 1) >> 60) {
            goto LABEL_296;
          }
          uint64_t v27 = v5 - (void)v24;
          if (v27 >> 3 > v26) {
            unint64_t v26 = v27 >> 3;
          }
          if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v28 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v28 = v26;
          }
          if (v28)
          {
            if (v28 >> 60) {
              goto LABEL_297;
            }
            uint64_t v29 = (char *)operator new(16 * v28);
          }
          else
          {
            uint64_t v29 = 0;
          }
          __int16 v72 = &v29[16 * v25];
          *(void *)__int16 v72 = "+fpuv2_sf";
          *((void *)v72 + 1) = 9;
          int v7 = (const char **)(v72 + 16);
          if (v6 != v24)
          {
            do
            {
              *((_OWORD *)v72 - 1) = *((_OWORD *)v6 - 1);
              v72 -= 16;
              v6 -= 2;
            }
            while (v6 != v24);
            uint64_t v6 = *a2;
          }
          *a2 = (const char **)v72;
          a2[1] = v7;
          a2[2] = (const char **)&v29[16 * v28];
          if (v6) {
            operator delete(v6);
          }
        }
        else
        {
          *uint64_t v6 = "+fpuv2_sf";
          v6[1] = (const char *)9;
          int v7 = v6 + 2;
        }
        a2[1] = v7;
        unint64_t v73 = (unint64_t)a2[2];
        if ((unint64_t)v7 >= v73)
        {
          uint64_t v75 = *a2;
          uint64_t v76 = ((char *)v7 - (char *)*a2) >> 4;
          unint64_t v77 = v76 + 1;
          if ((unint64_t)(v76 + 1) >> 60) {
            goto LABEL_296;
          }
          uint64_t v78 = v73 - (void)v75;
          if (v78 >> 3 > v77) {
            unint64_t v77 = v78 >> 3;
          }
          if ((unint64_t)v78 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v79 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v79 = v77;
          }
          if (v79)
          {
            if (v79 >> 60) {
              goto LABEL_297;
            }
            int v80 = (char *)operator new(16 * v79);
          }
          else
          {
            int v80 = 0;
          }
          long long v124 = (const char **)&v80[16 * v76];
          v125 = (const char **)&v80[16 * v79];
          *long long v124 = "+fpuv2_df";
          v124[1] = (const char *)9;
          unint64_t v74 = v124 + 2;
          if (v7 == v75)
          {
            *a2 = v124;
            a2[1] = v74;
            a2[2] = v125;
          }
          else
          {
            do
            {
              *((_OWORD *)v124 - 1) = *((_OWORD *)v7 - 1);
              v124 -= 2;
              v7 -= 2;
            }
            while (v7 != v75);
            int v7 = *a2;
            *a2 = v124;
            a2[1] = v74;
            a2[2] = v125;
            if (!v7) {
              goto LABEL_241;
            }
          }
          operator delete(v7);
        }
        else
        {
          *int v7 = "+fpuv2_df";
          v7[1] = (const char *)9;
          unint64_t v74 = v7 + 2;
        }
LABEL_241:
        a2[1] = v74;
        unint64_t v131 = (unint64_t)a2[2];
        if ((unint64_t)v74 < v131)
        {
LABEL_254:
          long long v139 = "+fdivdu";
          uint64_t v140 = 7;
LABEL_268:
          *unint64_t v74 = v139;
          v74[1] = (const char *)v140;
          char v99 = v74 + 2;
          goto LABEL_294;
        }
        std::string::size_type v132 = *a2;
        uint64_t v133 = ((char *)v74 - (char *)*a2) >> 4;
        unint64_t v134 = v133 + 1;
        if ((unint64_t)(v133 + 1) >> 60) {
          goto LABEL_296;
        }
        uint64_t v135 = v131 - (void)v132;
        if (v135 >> 3 > v134) {
          unint64_t v134 = v135 >> 3;
        }
        if ((unint64_t)v135 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v136 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v136 = v134;
        }
        if (v136)
        {
          if (v136 >> 60) {
            goto LABEL_297;
          }
          std::string::size_type v137 = (char *)operator new(16 * v136);
        }
        else
        {
          std::string::size_type v137 = 0;
        }
        uint64_t v154 = &v137[16 * v133];
        v155 = &v137[16 * v136];
        *(void *)uint64_t v154 = "+fdivdu";
        *((void *)v154 + 1) = 7;
        char v99 = (const char **)(v154 + 16);
        if (v74 == v132) {
          goto LABEL_291;
        }
        do
        {
          *((_OWORD *)v154 - 1) = *((_OWORD *)v74 - 1);
          v154 -= 16;
          v74 -= 2;
        }
        while (v74 != v132);
LABEL_289:
        unint64_t v74 = *a2;
        *a2 = (const char **)v154;
        a2[1] = v99;
        a2[2] = (const char **)v155;
        if (!v74) {
          goto LABEL_294;
        }
        goto LABEL_292;
    }
  }
  return v3;
}

void *llvm::CSKY::getDefaultCPU(void *__s2, size_t __n)
{
  for (uint64_t i = &dword_1E6853650; ; i += 8)
  {
    unint64_t v5 = i - 4;
    if (*((void *)i - 1) == __n && (!__n || !memcmp(*((const void **)i - 2), __s2, __n))) {
      break;
    }
    if (v5 + 8 == (int *)&off_1E68537C0) {
      return 0;
    }
  }
  if (*i) {
    return __s2;
  }
  return 0;
}

uint64_t llvm::CSKY::parseArchExt(void *__s1, size_t __n)
{
  for (uint64_t i = &qword_1E6854A10; ; i += 5)
  {
    unint64_t v5 = i - 2;
    if (__n == *(i - 1) && (!__n || !memcmp(__s1, (const void *)*(i - 2), __n))) {
      break;
    }
    if (v5 + 5 == (uint64_t *)&off_1E68551F8) {
      return 0;
    }
  }
  return *i;
}

uint64_t llvm::CSKY::fillValidCPUArchList(uint64_t result)
{
  unint64_t v1 = 0x1FFFFFFFFFFFFDB8uLL;
  do
  {
    BOOL v2 = &(&off_1E68537C0)[v1];
    if (LODWORD((&off_1E68537C0)[v1 + 586]))
    {
      uint64_t v3 = v2[584];
      sigset_t v4 = v2[585];
      unint64_t v5 = *(unsigned int *)(result + 8);
      if (v5 >= *(unsigned int *)(result + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v6 = (char **)(*(void *)result + 16 * v5);
      *uint64_t v6 = v3;
      v6[1] = v4;
      ++*(_DWORD *)(result + 8);
    }
    v1 += 4;
  }
  while (v1 * 8);
  return result;
}

char *llvm::CSKY::getFPUName(llvm::CSKY *this)
{
  if (this <= 8) {
    return (&off_1E68551F8)[3 * this];
  }
  else {
    return 0;
  }
}

uint64_t llvm::CSKY::getFPUVersion(llvm::CSKY *this)
{
  if (this <= 8) {
    return *((unsigned int *)&off_1E68551F8 + 6 * this + 5);
  }
  else {
    return 0;
  }
}

char *llvm::CSKY::getArchExtName(llvm::CSKY *this)
{
  uint64_t v1 = 0;
  while ((&off_1E6854A00)[v1 + 2] != (char *)this)
  {
    v1 += 5;
    if (v1 == 255) {
      return 0;
    }
  }
  return (&off_1E6854A00)[v1];
}

char *llvm::CSKY::getArchExtFeature(char *__s1, size_t __n)
{
  size_t v2 = __n;
  uint64_t v3 = __s1;
  if (__n >= 2)
  {
    int v5 = *(unsigned __int16 *)__s1;
    BOOL v4 = v5 == 28526;
    if (v5 == 28526)
    {
      size_t v2 = __n - 2;
      uint64_t v3 = __s1 + 2;
    }
  }
  else
  {
    BOOL v4 = 0;
  }
  uint64_t v6 = 0;
  while (1)
  {
    int v7 = &(&off_1E6854A00)[v6];
    if ((&off_1E6854A00)[v6 + 3])
    {
      if ((char *)v2 == v7[1] && (!v2 || !memcmp(v3, *v7, v2))) {
        break;
      }
    }
    v6 += 5;
    if (v6 == 255) {
      return 0;
    }
  }
  uint64_t v9 = &(&off_1E6854A00)[v6];
  uint64_t v10 = 3;
  if (v4) {
    uint64_t v10 = 4;
  }
  unint64_t v8 = v9[v10];
  if (v8) {
    strlen(v9[v10]);
  }
  return v8;
}

BOOL llvm::CSKY::getExtensionFeatures(uint64_t a1, char ***a2)
{
  if (a1)
  {
    BOOL v4 = &off_1E6854A00;
    do
    {
      if (((unint64_t)v4[2] & ~a1) == 0)
      {
        int v5 = v4[3];
        if (v5)
        {
          size_t v6 = strlen(v4[3]);
          size_t v7 = v6;
          uint64_t v9 = a2[1];
          unint64_t v8 = (unint64_t)a2[2];
          if ((unint64_t)v9 >= v8)
          {
            unint64_t v11 = *a2;
            uint64_t v12 = ((char *)v9 - (char *)*a2) >> 4;
            unint64_t v13 = v12 + 1;
            if ((unint64_t)(v12 + 1) >> 60) {
              abort();
            }
            uint64_t v14 = v8 - (void)v11;
            if (v14 >> 3 > v13) {
              unint64_t v13 = v14 >> 3;
            }
            if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v15 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v15 = v13;
            }
            if (v15)
            {
              if (v15 >> 60) {
                sub_1CB833614();
              }
              unint64_t v16 = (char *)operator new(16 * v15);
            }
            else
            {
              unint64_t v16 = 0;
            }
            uint64_t v17 = (char **)&v16[16 * v12];
            char *v17 = v5;
            v17[1] = (char *)v7;
            int64_t v18 = v17;
            if (v9 != v11)
            {
              do
              {
                *((_OWORD *)v18 - 1) = *((_OWORD *)v9 - 1);
                v18 -= 2;
                v9 -= 2;
              }
              while (v9 != v11);
              uint64_t v9 = *a2;
            }
            uint64_t v10 = v17 + 2;
            *a2 = v18;
            a2[1] = v17 + 2;
            a2[2] = (char **)&v16[16 * v15];
            if (v9) {
              operator delete(v9);
            }
          }
          else
          {
            const std::string::value_type *v9 = v5;
            v9[1] = (char *)v6;
            uint64_t v10 = v9 + 2;
          }
          a2[1] = v10;
        }
      }
      v4 += 5;
    }
    while (v4 != &off_1E68551F8);
  }
  return a1 != 0;
}

BOOL llvm::DataExtractor::prepareRead(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v4 = !__CFADD__(a3, a2) && *(void *)(a1 + 8) > a3 + a2 - 1;
  if (a4 && !v4)
  {
    uint64_t v8 = a3 + a2;
    if (*(void *)(a1 + 8) < a2)
    {
      size_t v6 = std::generic_category();
      sub_1CD833494((uint64_t)&v11, 22, (uint64_t)v6, a2, *(void *)(a1 + 8));
    }
    size_t v7 = std::generic_category();
    sub_1CD833384((uint64_t)&v11, 92, (uint64_t)v7, *(void *)(a1 + 8), a2, v8);
  }
  return v4;
}

uint64_t sub_1CD05EA24(void *a1, unint64_t *a2, void *a3)
{
  if (a3 && *a3) {
    return 0;
  }
  unint64_t v6 = *a2;
  uint64_t result = llvm::DataExtractor::prepareRead((uint64_t)a1, *a2, 1, (uint64_t)a3);
  if (result)
  {
    uint64_t result = *(unsigned __int8 *)(*a1 + v6);
    ++*a2;
  }
  if (a3)
  {
    if (!*a3) {
      *a3 = 0;
    }
  }
  return result;
}

unsigned char *llvm::DataExtractor::getU8(llvm::DataExtractor *this, unint64_t *a2, unsigned __int8 *a3, unsigned int a4)
{
  return sub_1CD8335A0(this, a2, a3, a4, 0);
}

unsigned __int16 *llvm::DataExtractor::getU16(llvm::DataExtractor *this, unint64_t *a2, unsigned __int16 *a3, unsigned int a4)
{
  unint64_t v4 = *a2;
  if (__CFADD__(*a2, 2 * a4) || *((void *)this + 1) <= *a2 + 2 * a4 - 1) {
    return 0;
  }
  unint64_t v6 = a3;
  if (a4)
  {
    uint64_t v8 = 2 * a4;
    uint64_t v9 = a3;
    do
    {
      *v9++ = sub_1CD833674((uint64_t)this, a2, 0);
      v4 += 2;
      v8 -= 2;
    }
    while (v8);
  }
  *a2 = v4;
  return v6;
}

unsigned int *llvm::DataExtractor::getU32(llvm::DataExtractor *this, unint64_t *a2, unsigned int *a3, unsigned int a4)
{
  unint64_t v4 = *a2;
  if (__CFADD__(*a2, 4 * a4) || *((void *)this + 1) <= *a2 + 4 * a4 - 1) {
    return 0;
  }
  unint64_t v6 = a3;
  if (a4)
  {
    uint64_t v8 = 4 * a4;
    uint64_t v9 = a3;
    do
    {
      *v9++ = sub_1CD8337FC((uint64_t)this, a2, 0);
      v4 += 4;
      v8 -= 4;
    }
    while (v8);
  }
  *a2 = v4;
  return v6;
}

unint64_t *llvm::DataExtractor::getU64(llvm::DataExtractor *this, unint64_t *a2, unint64_t *a3, unsigned int a4)
{
  unint64_t v4 = *a2;
  if (__CFADD__(*a2, 8 * a4) || *((void *)this + 1) <= *a2 + 8 * a4 - 1) {
    return 0;
  }
  unint64_t v6 = a3;
  if (a4)
  {
    uint64_t v8 = 8 * a4;
    uint64_t v9 = a3;
    do
    {
      *v9++ = sub_1CD833894((uint64_t)this, a2, 0);
      v4 += 8;
      v8 -= 8;
    }
    while (v8);
  }
  *a2 = v4;
  return v6;
}

unint64_t llvm::DataExtractor::getSigned(llvm::DataExtractor *this, unint64_t *a2, int a3)
{
  switch(a3)
  {
    case 2:
      unint64_t v8 = *a2;
      if (*a2 > 0xFFFFFFFFFFFFFFFDLL || *((void *)this + 1) <= v8 + 1) {
        return 0;
      }
      unsigned int v9 = *(unsigned __int16 *)(*(void *)this + v8);
      unsigned int v10 = bswap32(v9) >> 16;
      if (*((unsigned char *)this + 16) != 1) {
        LOWORD(v9) = v10;
      }
      *a2 = v8 + 2;
      return (__int16)v9;
    case 3:
    case 5:
    case 6:
    case 7:
      __break(1u);
      JUMPOUT(0x1CD05ED88);
    case 4:
      unint64_t v11 = *a2;
      if (*a2 > 0xFFFFFFFFFFFFFFFBLL || *((void *)this + 1) <= v11 + 3) {
        return 0;
      }
      signed int v12 = *(_DWORD *)(*(void *)this + v11);
      unsigned int v13 = bswap32(v12);
      if (*((unsigned char *)this + 16) != 1) {
        signed int v12 = v13;
      }
      *a2 = v11 + 4;
      return v12;
    case 8:
      unint64_t v6 = *a2;
      if (*a2 > 0xFFFFFFFFFFFFFFF7 || *((void *)this + 1) <= v6 + 7) {
        return 0;
      }
      unint64_t v7 = bswap64(*(void *)(*(void *)this + v6));
      if (*((unsigned char *)this + 16) == 1) {
        unint64_t result = *(void *)(*(void *)this + v6);
      }
      else {
        unint64_t result = v7;
      }
      unint64_t v5 = v6 + 8;
      goto LABEL_11;
    default:
      unint64_t v3 = *a2;
      if (*a2 == -1 || *((void *)this + 1) <= v3) {
        return 0;
      }
      unint64_t result = *(char *)(*(void *)this + v3);
      unint64_t v5 = v3 + 1;
LABEL_11:
      *a2 = v5;
      return result;
  }
}

uint64_t llvm::DataExtractor::getFixedLengthString(void *a1, unint64_t *a2, unint64_t a3, unsigned __int8 *a4, uint64_t a5)
{
  unint64_t v5 = *a2;
  unint64_t v6 = *a2 + a3;
  if (__CFADD__(*a2, a3) || (unint64_t v7 = a1[1], v7 <= v6 - 1))
  {
    unint64_t v9 = 0;
    unint64_t v8 = 0;
  }
  else
  {
    if (v7 < v5) {
      unint64_t v5 = a1[1];
    }
    unint64_t v8 = *a1 + v5;
    unint64_t v9 = v7 - v5;
    if (v9 >= a3) {
      unint64_t v9 = a3;
    }
    *a2 = v6;
  }
  v11[0] = v8;
  v11[1] = v9;
  return sub_1CD5A69D0(v11, a4, a5);
}

uint64_t llvm::DataExtractor::getULEB128(uint64_t *a1, uint64_t *a2, void *a3)
{
  uint64_t v4 = *a1;
  uint64_t v3 = a1[1];
  if (!a3 || !*a3)
  {
    uint64_t v5 = 0;
    uint64_t result = 0;
    unsigned int v7 = 0;
    uint64_t v8 = v4 + *a2;
    uint64_t v9 = v3 - *a2;
    unsigned int v10 = "malformed uleb128, extends past end";
    while (v9 != v5)
    {
      char v11 = *(unsigned char *)(v8 + v5);
      uint64_t v12 = v11 & 0x7F;
      if (v7 >= 0x40 && (v11 & 0x7F) != 0 || (unint64_t)(v12 << v7) >> v7 != v12)
      {
        uint64_t v14 = a2;
        unint64_t v15 = a3;
        unsigned int v10 = "uleb128 too big for uint64";
        goto LABEL_11;
      }
      result += v12 << v7;
      v7 += 7;
      ++v5;
      if ((v11 & 0x80) == 0)
      {
        *a2 += v5;
        if (a3)
        {
          if (!*a3) {
            *a3 = 0;
          }
        }
        return result;
      }
    }
    uint64_t v14 = a2;
    unint64_t v15 = a3;
LABEL_11:
    unint64_t v16 = v10;
    if (v15)
    {
      unsigned int v13 = std::generic_category();
      sub_1CD5E2210(92, (uint64_t)v13, (uint64_t)"unable to decode LEB128 at offset 0x%8.8llx: %s", v14, (uint64_t *)&v16);
    }
  }
  return 0;
}

uint64_t llvm::DataExtractor::getSLEB128(void *a1, uint64_t *a2, void *a3)
{
  if (a3 && *a3) {
    return 0;
  }
  uint64_t v3 = 0;
  uint64_t v4 = 0;
  unsigned int v5 = 0;
  unint64_t v6 = "malformed sleb128, extends past end";
  do
  {
    if (a1[1] - *a2 == v3)
    {
      uint64_t v14 = a2;
      unint64_t v15 = a3;
      goto LABEL_24;
    }
    char v7 = *(unsigned char *)(*a1 + *a2 + v3);
    uint64_t v8 = v7 & 0x7F;
    if (v5 >= 0x40)
    {
      if (((v4 >> 63) & 0x7F) != v8) {
        goto LABEL_23;
      }
    }
    else if (v5 == 63 && v8 != 127 && v8 != 0)
    {
LABEL_23:
      uint64_t v14 = a2;
      unint64_t v15 = a3;
      unint64_t v6 = "sleb128 too big for int64";
LABEL_24:
      unint64_t v16 = v6;
      if (v15)
      {
        unsigned int v13 = std::generic_category();
        sub_1CD5E2210(92, (uint64_t)v13, (uint64_t)"unable to decode LEB128 at offset 0x%8.8llx: %s", v14, (uint64_t *)&v16);
      }
      return 0;
    }
    v4 |= v8 << v5;
    v5 += 7;
    ++v3;
  }
  while (v7 < 0);
  BOOL v9 = (v7 & 0x40) == 0 || v5 > 0x3F;
  uint64_t v10 = -1 << v5;
  if (v9) {
    uint64_t v10 = 0;
  }
  uint64_t result = v4 | v10;
  *a2 += v3;
  if (a3)
  {
    if (!*a3) {
      *a3 = 0;
    }
  }
  return result;
}

uint64_t llvm::isCurrentDebugType(llvm *this, const char *a2)
{
  if (!atomic_load_explicit(&qword_1EA61DFC8, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1EA61DFC8, (void *(*)(void))sub_1CD05F8D4, (void (*)(void *))sub_1CD05F908);
  }
  if (*(void *)qword_1EA61DFC8 == *(void *)(qword_1EA61DFC8 + 8)) {
    return 1;
  }
  if (!atomic_load_explicit(&qword_1EA61DFC8, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1EA61DFC8, (void *(*)(void))sub_1CD05F8D4, (void (*)(void *))sub_1CD05F908);
  }
  uint64_t v3 = *(const void ***)qword_1EA61DFC8;
  uint64_t v4 = *(const void ***)(qword_1EA61DFC8 + 8);
  if (*(const void ***)qword_1EA61DFC8 != v4)
  {
    size_t v5 = strlen((const char *)this);
    while (1)
    {
      size_t v6 = *((unsigned __int8 *)v3 + 23);
      size_t v7 = (v6 & 0x80u) == 0 ? v6 & 0x7F : (size_t)v3[1];
      if (v5 == v7)
      {
        if ((v6 & 0x80) != 0)
        {
          if (v5 == -1) {
LABEL_27:
          }
            abort();
          uint64_t v8 = *v3;
          size_t v6 = (size_t)v3[1];
        }
        else
        {
          uint64_t v8 = v3;
          if (v5 == -1) {
            goto LABEL_27;
          }
        }
        size_t v9 = v6 >= v5 ? v5 : v6;
        if (!memcmp(v8, this, v9) && v6 == v5) {
          return 1;
        }
      }
      v3 += 3;
      if (v3 == v4) {
        return 0;
      }
    }
  }
  return 0;
}

void llvm::setCurrentDebugType(llvm *this, const char *a2)
{
  size_t v2 = this;
  llvm::setCurrentDebugTypes((llvm *)&v2, (const char **)1);
}

void llvm::setCurrentDebugTypes(llvm *this, const char **a2)
{
  unsigned int v2 = a2;
  if (!atomic_load_explicit(&qword_1EA61DFC8, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1EA61DFC8, (void *(*)(void))sub_1CD05F8D4, (void (*)(void *))sub_1CD05F908);
  }
  uint64_t v4 = qword_1EA61DFC8;
  uint64_t v5 = *(void *)qword_1EA61DFC8;
  for (uint64_t i = *(void *)(qword_1EA61DFC8 + 8); i != v5; i -= 24)
  {
    if (*(char *)(i - 1) < 0) {
      operator delete(*(void **)(i - 24));
    }
  }
  *(void *)(v4 + 8) = v5;
  if (v2)
  {
    uint64_t v7 = 0;
    uint64_t v8 = v2;
    do
    {
      if (!atomic_load_explicit(&qword_1EA61DFC8, memory_order_acquire)) {
        llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1EA61DFC8, (void *(*)(void))sub_1CD05F8D4, (void (*)(void *))sub_1CD05F908);
      }
      size_t v9 = (char **)qword_1EA61DFC8;
      uint64_t v10 = (const char *)*((void *)this + v7);
      size_t v11 = strlen(v10);
      if (v11 >= 0x7FFFFFFFFFFFFFF8) {
LABEL_41:
      }
        abort();
      uint64_t v12 = (void *)v11;
      if (v11 >= 0x17)
      {
        uint64_t v14 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v11 | 7) != 0x17) {
          uint64_t v14 = v11 | 7;
        }
        uint64_t v15 = v14 + 1;
        unsigned int v13 = operator new(v14 + 1);
        __p[1] = v12;
        unint64_t v33 = v15 | 0x8000000000000000;
        __p[0] = v13;
      }
      else
      {
        HIBYTE(v33) = v11;
        unsigned int v13 = __p;
        if (!v11) {
          goto LABEL_20;
        }
      }
      memmove(v13, v10, (size_t)v12);
LABEL_20:
      *((unsigned char *)v12 + (void)v13) = 0;
      unint64_t v16 = (unint64_t)v9[2];
      unint64_t v17 = (unint64_t)v9[1];
      if (v17 >= v16)
      {
        unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v17 - (void)*v9) >> 3);
        unint64_t v19 = v18 + 1;
        if (v18 + 1 > 0xAAAAAAAAAAAAAAALL) {
          goto LABEL_41;
        }
        unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v16 - (void)*v9) >> 3);
        if (2 * v20 > v19) {
          unint64_t v19 = 2 * v20;
        }
        if (v20 >= 0x555555555555555) {
          unint64_t v21 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v21 = v19;
        }
        uint64_t v34[4] = v9 + 2;
        if (v21)
        {
          if (v21 > 0xAAAAAAAAAAAAAAALL) {
            sub_1CB833614();
          }
          unint64_t v22 = (char *)operator new(24 * v21);
        }
        else
        {
          unint64_t v22 = 0;
        }
        __int16 v23 = &v22[24 * v18];
        *((void *)v23 + 2) = v33;
        *(_OWORD *)__int16 v23 = *(_OWORD *)__p;
        __p[1] = 0;
        unint64_t v33 = 0;
        __p[0] = 0;
        uint64_t v25 = *v9;
        int v24 = v9[1];
        if (v24 == *v9)
        {
          char v29 = 0;
          unint64_t v28 = v9[1];
          unint64_t v26 = v23;
        }
        else
        {
          unint64_t v26 = &v22[24 * v18];
          do
          {
            long long v27 = *(_OWORD *)(v24 - 24);
            *((void *)v26 - 1) = *((void *)v24 - 1);
            *(_OWORD *)(v26 - 24) = v27;
            v26 -= 24;
            *((void *)v24 - 2) = 0;
            *((void *)v24 - 1) = 0;
            *((void *)v24 - 3) = 0;
            v24 -= 24;
          }
          while (v24 != v25);
          unint64_t v28 = *v9;
          int v24 = v9[1];
          char v29 = HIBYTE(v33);
        }
        size_t v30 = v23 + 24;
        unint64_t *v9 = v26;
        v34[0] = v28;
        v34[1] = v28;
        v9[1] = v23 + 24;
        v34[2] = v24;
        uint64_t v31 = v9[2];
        v9[2] = &v22[24 * v21];
        v34[3] = v31;
        sub_1CBF4EE0C((uint64_t)v34);
        v9[1] = v30;
        if (v29 < 0) {
          operator delete(__p[0]);
        }
      }
      else
      {
        *(_OWORD *)unint64_t v17 = *(_OWORD *)__p;
        *(void *)(v17 + 16) = v33;
        v9[1] = (char *)(v17 + 24);
      }
      ++v7;
    }
    while (v7 != v8);
  }
}

void sub_1CD05F4D4()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCFACC8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EBCFACC8))
  {
    qword_1EA61F060 = 0;
    __cxa_atexit((void (*)(void *))sub_1CD833CD4, &qword_1EA61F048, &dword_1CB82C000);
    __cxa_guard_release(&qword_1EBCFACC8);
  }
}

void *sub_1CD05F550(void *a1)
{
  v6[3] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = (void *)a1[3];
  if (!v1)
  {
    uint64_t v5 = 0;
    uint64_t result = (void *)qword_1EA61F060;
    if ((uint64_t *)qword_1EA61F060 != &qword_1EA61F048)
    {
      unsigned int v2 = 0;
LABEL_9:
      uint64_t v5 = result;
      qword_1EA61F060 = (uint64_t)v2;
      goto LABEL_14;
    }
LABEL_10:
    (*(void (**)(uint64_t *, void *))(qword_1EA61F048 + 24))(&qword_1EA61F048, v4);
    (*(void (**)(uint64_t))(*(void *)qword_1EA61F060 + 32))(qword_1EA61F060);
    qword_1EA61F060 = (uint64_t)v5;
    uint64_t v5 = v4;
    return (void *)(*(uint64_t (**)(void *))(v4[0] + 32))(v4);
  }
  if (v1 == a1)
  {
    uint64_t v5 = v4;
    (*(void (**)(void *, void *))(*a1 + 24))(a1, v4);
    unsigned int v2 = v5;
  }
  else
  {
    unsigned int v2 = (void *)(*(uint64_t (**)(void))(*v1 + 16))(a1[3]);
    uint64_t v5 = v2;
  }
  uint64_t result = (void *)qword_1EA61F060;
  if (v2 != v4)
  {
    if ((uint64_t *)qword_1EA61F060 != &qword_1EA61F048) {
      goto LABEL_9;
    }
    goto LABEL_10;
  }
  if ((uint64_t *)qword_1EA61F060 == &qword_1EA61F048)
  {
    (*(void (**)(void *, void *))(v4[0] + 24))(v4, v6);
    (*(void (**)(void *))(*v5 + 32))(v5);
    uint64_t v5 = 0;
    (*(void (**)(uint64_t, void *))(*(void *)qword_1EA61F060 + 24))(qword_1EA61F060, v4);
    (*(void (**)(uint64_t))(*(void *)qword_1EA61F060 + 32))(qword_1EA61F060);
    qword_1EA61F060 = 0;
    uint64_t v5 = v4;
    (*(void (**)(void *, uint64_t *))(v6[0] + 24))(v6, &qword_1EA61F048);
    (*(void (**)(void *))(v6[0] + 32))(v6);
    qword_1EA61F060 = (uint64_t)&qword_1EA61F048;
    uint64_t result = v5;
  }
  else
  {
    (*(void (**)(void *, uint64_t *))(v4[0] + 24))(v4, &qword_1EA61F048);
    (*(void (**)(void *))(*v5 + 32))(v5);
    uint64_t result = (void *)qword_1EA61F060;
    uint64_t v5 = (void *)qword_1EA61F060;
    qword_1EA61F060 = (uint64_t)&qword_1EA61F048;
  }
LABEL_14:
  if (result == v4) {
    return (void *)(*(uint64_t (**)(void *))(v4[0] + 32))(v4);
  }
  if (result) {
    return (void *)(*(uint64_t (**)(void *))(*result + 40))(result);
  }
  return result;
}

void sub_1CD05F8D4()
{
}

void **sub_1CD05F908(void **result)
{
  if (result)
  {
    uint64_t v1 = result;
    unsigned int v2 = result;
    sub_1CB8338B8(&v2);
    return (void **)MEMORY[0x1D25D9CE0](v1, 0x20C40960023A9);
  }
  return result;
}

uint64_t _ZTWN4llvm24ThisThreadsStreamIDTokenE()
{
  return off_1EC7DFBE8();
}

void llvm::DebugCounter::~DebugCounter(char **this)
{
  unsigned int v2 = (char *)(this + 3);
  uint64_t v3 = (void **)(this + 6);
  sub_1CB8338B8(&v3);
  sub_1CB833850((uint64_t)v2, this[4]);
  sub_1CD060070((uint64_t)this);
}

{
  char *v2;
  void **v3;

  unsigned int v2 = (char *)(this + 3);
  uint64_t v3 = (void **)(this + 6);
  sub_1CB8338B8(&v3);
  sub_1CB833850((uint64_t)v2, this[4]);
  sub_1CD060070((uint64_t)this);
}

atomic_ullong llvm::DebugCounter::instance(llvm::DebugCounter *this)
{
  if (!atomic_load_explicit(qword_1EBCFACD0, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EBCFACD0, (void *(*)(void))sub_1CD834B8C, (void (*)(void *))sub_1CD834BDC);
  }
  return qword_1EBCFACD0[0];
}

void sub_1CD05FA7C()
{
}

uint64_t sub_1CD05FB58(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 32))();
  }
  return result;
}

uint64_t sub_1CD05FB84(uint64_t a1, int a2, int a3, int a4, void *__src, size_t __len)
{
  __p[0] = 0;
  __p[1] = 0;
  unint64_t v27 = 0;
  if (!__src)
  {
    long long __dst = 0uLL;
    unint64_t v29 = 0;
    goto LABEL_13;
  }
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    goto LABEL_34;
  }
  if (__len >= 0x17)
  {
    size_t v11 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v11 = __len | 7;
    }
    size_t v12 = v11 + 1;
    p_dst = (long long *)operator new(v11 + 1);
    *((void *)&__dst + 1) = __len;
    unint64_t v29 = v12 | 0x8000000000000000;
    *(void *)&long long __dst = p_dst;
    goto LABEL_10;
  }
  HIBYTE(v29) = __len;
  p_dst = &__dst;
  if (__len) {
LABEL_10:
  }
    memmove(p_dst, __src, __len);
  *((unsigned char *)p_dst + __len) = 0;
  if (SHIBYTE(v27) < 0) {
    operator delete(__p[0]);
  }
LABEL_13:
  *(_OWORD *)std::string __p = __dst;
  unint64_t v27 = v29;
  llvm::DebugCounter::push_back(*(llvm::raw_ostream **)(a1 + 128), (std::string::size_type)__p);
  *(_WORD *)(a1 + 12) = a2;
  uint64_t v14 = *(char **)(a1 + 144);
  unint64_t v13 = *(void *)(a1 + 152);
  if ((unint64_t)v14 >= v13)
  {
    unint64_t v16 = *(char **)(a1 + 136);
    uint64_t v17 = (v14 - v16) >> 2;
    unint64_t v18 = v17 + 1;
    if (!((unint64_t)(v17 + 1) >> 62))
    {
      uint64_t v19 = v13 - (void)v16;
      if (v19 >> 1 > v18) {
        unint64_t v18 = v19 >> 1;
      }
      if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v20 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v20 = v18;
      }
      if (v20)
      {
        if (v20 >> 62) {
          goto LABEL_36;
        }
        unint64_t v21 = (char *)operator new(4 * v20);
      }
      else
      {
        unint64_t v21 = 0;
      }
      unint64_t v22 = &v21[4 * v17];
      *(_DWORD *)unint64_t v22 = a2;
      uint64_t v15 = v22 + 4;
      while (v14 != v16)
      {
        int v23 = *((_DWORD *)v14 - 1);
        v14 -= 4;
        *((_DWORD *)v22 - 1) = v23;
        v22 -= 4;
      }
      *(void *)(a1 + 136) = v22;
      *(void *)(a1 + 144) = v15;
      *(void *)(a1 + 152) = &v21[4 * v20];
      if (v16) {
        operator delete(v16);
      }
      goto LABEL_30;
    }
LABEL_34:
    abort();
  }
  *(_DWORD *)uint64_t v14 = a2;
  uint64_t v15 = v14 + 4;
LABEL_30:
  *(void *)(a1 + 144) = v15;
  uint64_t v24 = *(void *)(a1 + 192);
  if (!v24)
  {
    sub_1CB920400();
LABEL_36:
    sub_1CB833614();
  }
  (*(void (**)(uint64_t, void **))(*(void *)v24 + 48))(v24, __p);
  if (SHIBYTE(v27) < 0) {
    operator delete(__p[0]);
  }
  return 0;
}

void sub_1CD05FD74(void *a1)
{
  sub_1CD8347C8(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD05FDAC(llvm *a1, unsigned int a2)
{
  uint64_t v4 = (llvm::raw_ostream *)llvm::outs(a1);
  uint64_t v5 = v4;
  uint64_t v6 = *((void *)v4 + 4);
  if ((unint64_t)(*((void *)v4 + 3) - v6) > 2)
  {
    *(unsigned char *)(v6 + 2) = 45;
    *(_WORD *)uint64_t v6 = 8224;
    uint64_t v7 = (void *)(*((void *)v4 + 4) + 3);
    *((void *)v5 + 4) = v7;
  }
  else
  {
    llvm::raw_ostream::write(v4, "  -", 3uLL);
    uint64_t v7 = (void *)*((void *)v5 + 4);
  }
  uint64_t v8 = (const void *)*((void *)a1 + 2);
  unint64_t v9 = *((void *)a1 + 3);
  if (v9 <= *((void *)v5 + 3) - (void)v7)
  {
    if (v9)
    {
      memcpy(v7, v8, *((void *)a1 + 3));
      *((void *)v5 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v5, (const char *)v8, *((void *)a1 + 3));
  }
  llvm::cl::Option::printHelpStr(*((void *)a1 + 4), *((void *)a1 + 5), a2, *((void *)a1 + 3) + 6);
  if (!atomic_load_explicit(qword_1EBCFACD0, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EBCFACD0, (void *(*)(void))sub_1CD834B8C, (void (*)(void *))sub_1CD834BDC);
  }
  uint64_t v10 = qword_1EBCFACD0[0];
  size_t v11 = *(void **)(qword_1EBCFACD0[0] + 48);
  size_t v12 = *(void **)(qword_1EBCFACD0[0] + 56);
  if (v11 != v12)
  {
    atomic_ullong v13 = qword_1EBCFACD0[0] + 32;
    do
    {
      uint64_t v14 = sub_1CD4F3EC8(v10 + 24, v11);
      if (v13 == v14) {
        int v15 = 0;
      }
      else {
        int v15 = *(_DWORD *)(v14 + 56);
      }
      sub_1CD834890((uint64_t)&v31, v10, v15);
      if (v33 >= 0) {
        int v17 = v33 & 0x7F;
      }
      else {
        int v17 = v32;
      }
      unint64_t v18 = (llvm::raw_ostream *)llvm::outs(v16);
      uint64_t v19 = *((void *)v18 + 4);
      if ((unint64_t)(*((void *)v18 + 3) - v19) > 4)
      {
        *(unsigned char *)(v19 + 4) = 61;
        *(_DWORD *)uint64_t v19 = 538976288;
        *((void *)v18 + 4) += 5;
      }
      else
      {
        unint64_t v18 = llvm::raw_ostream::write(v18, "    =", 5uLL);
      }
      unsigned int v20 = a2 - v17;
      if (v33 >= 0) {
        unint64_t v21 = (const char *)&v31;
      }
      else {
        unint64_t v21 = (const char *)v31;
      }
      if (v33 >= 0) {
        size_t v22 = v33 & 0x7F;
      }
      else {
        size_t v22 = v32;
      }
      int v23 = llvm::raw_ostream::write(v18, v21, v22);
      uint64_t v24 = (llvm::raw_ostream *)llvm::outs(v23);
      uint64_t v25 = llvm::raw_ostream::indent(v24, v20 - 8);
      uint64_t v26 = *((void *)v25 + 4);
      if ((unint64_t)(*((void *)v25 + 3) - v26) > 4)
      {
        *(unsigned char *)(v26 + 4) = 32;
        *(_DWORD *)uint64_t v26 = 538979616;
        *((void *)v25 + 4) += 5;
      }
      else
      {
        uint64_t v25 = llvm::raw_ostream::write(v25, " -   ", 5uLL);
      }
      if (v35 >= 0) {
        unint64_t v27 = __p;
      }
      else {
        unint64_t v27 = (void **)__p[0];
      }
      if (v35 >= 0) {
        size_t v28 = v35 & 0x7F;
      }
      else {
        size_t v28 = (size_t)__p[1];
      }
      unint64_t v29 = llvm::raw_ostream::write(v25, (const char *)v27, v28);
      size_t v30 = (unsigned char *)*((void *)v29 + 4);
      if ((unint64_t)v30 >= *((void *)v29 + 3))
      {
        llvm::raw_ostream::write(v29, 10);
      }
      else
      {
        *((void *)v29 + 4) = v30 + 1;
        *size_t v30 = 10;
      }
      if (v35 < 0) {
        operator delete(__p[0]);
      }
      if (v33 < 0) {
        operator delete(v31);
      }
      v11 += 3;
    }
    while (v11 != v12);
  }
}

void sub_1CD060070(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 16);
  uint64_t v3 = *(llvm **)a1;
  if (v2)
  {
    uint64_t v4 = v2 << 6;
    uint64_t v5 = (char *)v3 + 40;
    do
    {
      if (*((_DWORD *)v5 - 10) <= 0xFFFFFFFD && v5[23] < 0) {
        operator delete(*(void **)v5);
      }
      v5 += 64;
      v4 -= 64;
    }
    while (v4);
    uint64_t v3 = *(llvm **)a1;
    uint64_t v6 = (void *)((unint64_t)*(unsigned int *)(a1 + 16) << 6);
  }
  else
  {
    uint64_t v6 = 0;
  }
  llvm::deallocate_buffer(v3, v6);
}

uint64_t sub_1CD0600FC(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  unint64_t v3 = 0xAAAAAAAAAAAAAAABLL * (a3 - a2);
  uint64_t v4 = *(unsigned int *)(result + 8);
  if (v3 + v4 > *(unsigned int *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (a2 != a3)
  {
    uint64_t v5 = (void *)(*(void *)result + 16 * v4);
    do
    {
      if (*((char *)a2 + 23) >= 0) {
        uint64_t v6 = a2;
      }
      else {
        uint64_t v6 = (uint64_t *)*a2;
      }
      *uint64_t v5 = v6;
      char v7 = *((unsigned char *)a2 + 23);
      int v8 = v7;
      uint64_t v9 = v7 & 0x7F;
      if (v8 < 0) {
        uint64_t v9 = a2[1];
      }
      v5[1] = v9;
      a2 += 3;
      v5 += 2;
    }
    while (a2 != a3);
  }
  *(_DWORD *)(result + 8) = v4 + v3;
  return result;
}

void llvm::DeltaAlgorithm::~DeltaAlgorithm(llvm::DeltaAlgorithm *this)
{
  *(void *)this = &unk_1F2644770;
  sub_1CD060AE8((uint64_t)this + 8, *((void **)this + 2));
}

uint64_t llvm::DeltaAlgorithm::GetTestResult(uint64_t a1, void **a2)
{
  uint64_t v4 = a1 + 8;
  if (!sub_1CD060B48(a1 + 8, a2))
  {
    if ((*(uint64_t (**)(uint64_t, void **))(*(void *)a1 + 8))(a1, a2)) {
      return 1;
    }
    sub_1CD060C80(v4, a2, a2);
  }
  return 0;
}

void llvm::DeltaAlgorithm::Split(uint64_t a1, void *a2, uint64_t *a3)
{
  unint64_t v3 = a3;
  unint64_t v29 = 0;
  uint64_t v30 = 0;
  uint64_t v27 = 0;
  size_t v28 = &v29;
  uint64_t v25 = &v26;
  uint64_t v26 = 0;
  uint64_t v4 = (void *)*a2;
  uint64_t v5 = a2 + 1;
  if ((void *)*a2 != a2 + 1)
  {
    unsigned int v6 = 0;
    uint64_t v7 = a2[2] >> 1;
    do
    {
      if (v6 >= v7) {
        int v8 = &v25;
      }
      else {
        int v8 = &v28;
      }
      if (v6 >= v7) {
        uint64_t v9 = &v26;
      }
      else {
        uint64_t v9 = &v29;
      }
      uint64_t v10 = v8[1];
      if (v10)
      {
        unsigned int v11 = *((_DWORD *)v4 + 7);
        do
        {
          while (1)
          {
            size_t v12 = v10;
            unsigned int v13 = *((_DWORD *)v10 + 7);
            if (v11 >= v13) {
              break;
            }
            uint64_t v10 = (void **)*v12;
            uint64_t v9 = v12;
            if (!*v12) {
              goto LABEL_16;
            }
          }
          if (v13 >= v11) {
            goto LABEL_22;
          }
          uint64_t v10 = (void **)v12[1];
        }
        while (v10);
        uint64_t v9 = v12 + 1;
      }
      else
      {
        size_t v12 = v9;
      }
LABEL_16:
      uint64_t v14 = operator new(0x20uLL);
      v14[7] = *((_DWORD *)v4 + 7);
      *(void *)uint64_t v14 = 0;
      *((void *)v14 + 1) = 0;
      *((void *)v14 + 2) = v12;
      void *v9 = v14;
      int v15 = (void **)**v8;
      if (v15)
      {
        const void *v8 = v15;
        uint64_t v14 = (_DWORD *)*v9;
      }
      sub_1CB8358B8((uint64_t *)v8[1], (uint64_t *)v14);
      if (v6 >= v7) {
        unint64_t v16 = &v25;
      }
      else {
        unint64_t v16 = &v28;
      }
      v16[2] = (void **)((char *)v16[2] + 1);
LABEL_22:
      int v17 = (void *)v4[1];
      if (v17)
      {
        do
        {
          unint64_t v18 = v17;
          int v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          unint64_t v18 = (void *)v4[2];
          BOOL v19 = *v18 == (void)v4;
          uint64_t v4 = v18;
        }
        while (!v19);
      }
      ++v6;
      uint64_t v4 = v18;
    }
    while (v18 != v5);
    unint64_t v3 = a3;
    if (v30)
    {
      unint64_t v20 = a3[1];
      if (v20 >= a3[2]) {
        uint64_t v21 = sub_1CD060DE8(a3, &v28);
      }
      else {
        uint64_t v21 = sub_1CC4063DC(v20, &v28) + 24;
      }
      a3[1] = v21;
    }
  }
  if (v27)
  {
    unint64_t v22 = v3[1];
    if (v22 >= v3[2]) {
      uint64_t v23 = sub_1CD060DE8(v3, &v25);
    }
    else {
      uint64_t v23 = sub_1CC4063DC(v22, &v25) + 24;
    }
    v3[1] = v23;
  }
  sub_1CB833A08((uint64_t)&v25, v26);
  sub_1CB833A08((uint64_t)&v28, v29);
}

void llvm::DeltaAlgorithm::Delta(void (***a1)(void)@<X0>, void *a2@<X1>, uint64_t *a3@<X2>, void *a4@<X8>)
{
  (**a1)(a1);
  if (0xAAAAAAAAAAAAAAABLL * ((a3[1] - *a3) >> 3) > 1)
  {
    unint64_t v20 = 0;
    uint64_t v21 = 0;
    BOOL v19 = &v20;
    uint64_t v8 = llvm::DeltaAlgorithm::Search((uint64_t)a1, a2, a3, (uint64_t)&v19);
    if (v8)
    {
      uint64_t v9 = v20;
      *a4 = v19;
      a4[1] = v9;
      uint64_t v10 = a4 + 1;
      uint64_t v11 = v21;
      a4[2] = v21;
      if (v11)
      {
        v9[2] = v10;
        BOOL v19 = &v20;
        unint64_t v20 = 0;
        uint64_t v21 = 0;
        uint64_t v9 = 0;
      }
      else
      {
        *a4 = v10;
      }
    }
    else
    {
      uint64_t v16 = 0;
      uint64_t v17 = 0;
      uint64_t v18 = 0;
      size_t v12 = (void *)*a3;
      unsigned int v13 = (void *)a3[1];
      if ((void *)*a3 == v13)
      {
        uint64_t v15 = 0;
        uint64_t v14 = *a3;
      }
      else
      {
        do
        {
          llvm::DeltaAlgorithm::Split(v8, v12, &v16);
          v12 += 3;
        }
        while (v12 != v13);
        size_t v12 = (void *)*a3;
        uint64_t v14 = a3[1];
        uint64_t v15 = v17 - v16;
      }
      if (v15 == v14 - (void)v12) {
        sub_1CC4063DC((uint64_t)a4, a2);
      }
      else {
        llvm::DeltaAlgorithm::Delta(a4, a1, a2, &v16);
      }
      unint64_t v22 = (void **)&v16;
      sub_1CD060F64(&v22);
      uint64_t v9 = v20;
    }
    sub_1CB833A08((uint64_t)&v19, v9);
  }
  else
  {
    sub_1CC4063DC((uint64_t)a4, a2);
  }
}

uint64_t llvm::DeltaAlgorithm::Search(uint64_t a1, void *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v4 = (void *)*a3;
  uint64_t v5 = (void *)a3[1];
  if ((void *)*a3 == v5) {
    return 0;
  }
  uint64_t v9 = a2 + 1;
  while (1)
  {
    uint64_t TestResult = llvm::DeltaAlgorithm::GetTestResult(a1, (void **)v4);
    if (TestResult) {
      break;
    }
    if (0xAAAAAAAAAAAAAAABLL * ((a3[1] - *a3) >> 3) >= 3)
    {
      unint64_t v46 = 0;
      uint64_t v47 = 0;
      uint64_t v45 = &v46;
      uint64_t v11 = (void *)*a2;
      if ((void *)*a2 != v9)
      {
        size_t v12 = (void *)*v4;
        unsigned int v13 = (uint64_t *)&v46;
        while (v12 != v4 + 1)
        {
          unsigned int v14 = *((_DWORD *)v11 + 7);
          unsigned int v15 = *((_DWORD *)v12 + 7);
          if (v14 >= v15)
          {
            if (v15 >= v14)
            {
              uint64_t v23 = (void *)v11[1];
              if (v23)
              {
                do
                {
                  uint64_t v24 = v23;
                  uint64_t v23 = (void *)*v23;
                }
                while (v23);
              }
              else
              {
                do
                {
                  uint64_t v24 = (void *)v11[2];
                  BOOL v18 = *v24 == (void)v11;
                  uint64_t v11 = v24;
                }
                while (!v18);
              }
              uint64_t v25 = (void *)v12[1];
              if (v25)
              {
                do
                {
                  size_t v12 = v25;
                  uint64_t v25 = (void *)*v25;
                }
                while (v25);
              }
              else
              {
                do
                {
                  uint64_t v26 = v12;
                  size_t v12 = (void *)v12[2];
                }
                while ((void *)*v12 != v26);
              }
              uint64_t v11 = v24;
            }
            else
            {
              uint64_t v21 = (void *)v12[1];
              if (v21)
              {
                do
                {
                  size_t v12 = v21;
                  uint64_t v21 = (void *)*v21;
                }
                while (v21);
              }
              else
              {
                do
                {
                  unint64_t v22 = v12;
                  size_t v12 = (void *)v12[2];
                }
                while ((void *)*v12 != v22);
              }
            }
          }
          else
          {
            uint64_t v16 = sub_1CC406474(&v45, v13, (unsigned int *)v11 + 7, (_DWORD *)v11 + 7);
            uint64_t v17 = (uint64_t *)*((void *)v16 + 1);
            if (v17)
            {
              do
              {
                unsigned int v13 = v17;
                uint64_t v17 = (uint64_t *)*v17;
              }
              while (v17);
            }
            else
            {
              do
              {
                unsigned int v13 = (uint64_t *)*((void *)v16 + 2);
                BOOL v18 = *v13 == (void)v16;
                uint64_t v16 = v13;
              }
              while (!v18);
            }
            BOOL v19 = (void *)v11[1];
            if (v19)
            {
              do
              {
                uint64_t v11 = v19;
                BOOL v19 = (void *)*v19;
              }
              while (v19);
            }
            else
            {
              do
              {
                unint64_t v20 = v11;
                uint64_t v11 = (void *)v11[2];
              }
              while ((void *)*v11 != v20);
            }
          }
          if (v11 == v9) {
            goto LABEL_48;
          }
        }
        do
        {
          uint64_t v27 = sub_1CC406474(&v45, v13, (unsigned int *)v11 + 7, (_DWORD *)v11 + 7);
          size_t v28 = (uint64_t *)*((void *)v27 + 1);
          if (v28)
          {
            do
            {
              unsigned int v13 = v28;
              size_t v28 = (uint64_t *)*v28;
            }
            while (v28);
          }
          else
          {
            do
            {
              unsigned int v13 = (uint64_t *)*((void *)v27 + 2);
              BOOL v18 = *v13 == (void)v27;
              uint64_t v27 = v13;
            }
            while (!v18);
          }
          unint64_t v29 = (void *)v11[1];
          if (v29)
          {
            do
            {
              uint64_t v30 = v29;
              unint64_t v29 = (void *)*v29;
            }
            while (v29);
          }
          else
          {
            do
            {
              uint64_t v30 = (void *)v11[2];
              BOOL v18 = *v30 == (void)v11;
              uint64_t v11 = v30;
            }
            while (!v18);
          }
          uint64_t v11 = v30;
        }
        while (v30 != v9);
      }
LABEL_48:
      if (llvm::DeltaAlgorithm::GetTestResult(a1, &v45))
      {
        unint64_t v42 = 0;
        uint64_t v43 = 0;
        uint64_t v44 = 0;
        sub_1CD060FF0(&v42, 0, (void *)*a3, v4, 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v4 - *a3) >> 3));
        sub_1CD060FF0(&v42, (uint64_t)v43, v4 + 3, (void *)a3[1], 0xAAAAAAAAAAAAAAABLL * ((a3[1] - (uint64_t)(v4 + 3)) >> 3));
        llvm::DeltaAlgorithm::Delta(&v39, a1, &v45, &v42);
        uint64_t v35 = a4 + 8;
        sub_1CB833A08(a4, *(void **)(a4 + 8));
        uint64_t v36 = v40;
        *(void *)a4 = v39;
        *(void *)(a4 + 8) = v36;
        uint64_t v37 = v41;
        *(void *)(a4 + 16) = v41;
        if (v37)
        {
          v36[2] = v35;
          uint64_t v39 = (char **)&v40;
          unint64_t v40 = 0;
          uint64_t v41 = 0;
          uint64_t v36 = 0;
        }
        else
        {
          *(void *)a4 = v35;
        }
        sub_1CB833A08((uint64_t)&v39, v36);
        uint64_t v39 = &v42;
        sub_1CD060F64((void ***)&v39);
        sub_1CB833A08((uint64_t)&v45, v46);
        return 1;
      }
      sub_1CB833A08((uint64_t)&v45, v46);
    }
    v4 += 3;
    if (v4 == v5) {
      return 0;
    }
  }
  uint64_t v45 = 0;
  unint64_t v46 = 0;
  uint64_t v47 = 0;
  llvm::DeltaAlgorithm::Split(TestResult, v4, (uint64_t *)&v45);
  llvm::DeltaAlgorithm::Delta(&v42, a1, v4, &v45);
  uint64_t v32 = a4 + 8;
  sub_1CB833A08(a4, *(void **)(a4 + 8));
  char v33 = v43;
  *(void *)a4 = v42;
  *(void *)(a4 + 8) = v33;
  uint64_t v34 = v44;
  *(void *)(a4 + 16) = v44;
  if (v34)
  {
    v33[2] = v32;
    unint64_t v42 = (char *)&v43;
    uint64_t v43 = 0;
    uint64_t v44 = 0;
    char v33 = 0;
  }
  else
  {
    *(void *)a4 = v32;
  }
  sub_1CB833A08((uint64_t)&v42, v33);
  unint64_t v42 = (char *)&v45;
  sub_1CD060F64((void ***)&v42);
  return 1;
}

void llvm::DeltaAlgorithm::Run(void (***a1)(void)@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v8 = &v9;
  int TestResult = llvm::DeltaAlgorithm::GetTestResult((uint64_t)a1, &v8);
  sub_1CB833A08((uint64_t)&v8, v9);
  if (TestResult)
  {
    a3[2] = 0;
    a3[1] = 0;
    *a3 = a3 + 1;
  }
  else
  {
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    llvm::DeltaAlgorithm::Split(v7, a2, (uint64_t *)&v8);
    llvm::DeltaAlgorithm::Delta(a1, a2, (uint64_t *)&v8, a3);
    uint64_t v11 = (void **)&v8;
    sub_1CD060F64(&v11);
  }
}

void sub_1CD060AE8(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1CD060AE8(a1, *a2);
    sub_1CD060AE8(a1, a2[1]);
    sub_1CB833A08((uint64_t)(a2 + 4), (void *)a2[5]);
    operator delete(a2);
  }
}

uint64_t sub_1CD060B48(uint64_t a1, void **a2)
{
  uint64_t v2 = *(uint64_t ***)(a1 + 8);
  if (v2)
  {
    uint64_t v4 = a2 + 1;
    uint64_t v5 = 1;
    do
    {
      if ((sub_1CD060BE0(*a2, v4, v2[4], v2 + 5) & 1) == 0)
      {
        if (!sub_1CD060BE0(v2[4], v2 + 5, *a2, v4)) {
          return v5;
        }
        ++v2;
      }
      uint64_t v2 = (uint64_t **)*v2;
    }
    while (v2);
  }
  return 0;
}

uint64_t sub_1CD060BE0(void *a1, void *a2, void *a3, void *a4)
{
  if (a3 == a4) {
    return 0;
  }
  while (a1 != a2)
  {
    unsigned int v4 = *((_DWORD *)a1 + 7);
    unsigned int v5 = *((_DWORD *)a3 + 7);
    if (v4 < v5) {
      break;
    }
    if (v5 >= v4)
    {
      unsigned int v6 = (void *)a1[1];
      uint64_t v7 = a1;
      if (v6)
      {
        do
        {
          a1 = v6;
          unsigned int v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          a1 = (void *)v7[2];
          BOOL v8 = *a1 == (void)v7;
          uint64_t v7 = a1;
        }
        while (!v8);
      }
      uint64_t v9 = (void *)a3[1];
      if (v9)
      {
        do
        {
          uint64_t v10 = v9;
          uint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          uint64_t v10 = (void *)a3[2];
          BOOL v8 = *v10 == (void)a3;
          a3 = v10;
        }
        while (!v8);
      }
      a3 = v10;
      if (v10 != a4) {
        continue;
      }
    }
    return 0;
  }
  return 1;
}

uint64_t *sub_1CD060C80(uint64_t a1, void **a2, void *a3)
{
  unsigned int v5 = sub_1CD060D30(a1, &v12, a2);
  unsigned int v6 = (uint64_t *)*v5;
  if (!*v5)
  {
    uint64_t v7 = v5;
    unsigned int v6 = (uint64_t *)operator new(0x38uLL);
    sub_1CC4063DC((uint64_t)(v6 + 4), a3);
    uint64_t v8 = v12;
    *unsigned int v6 = 0;
    v6[1] = 0;
    void v6[2] = v8;
    *uint64_t v7 = (uint64_t)v6;
    uint64_t v9 = **(void **)a1;
    uint64_t v10 = v6;
    if (v9)
    {
      *(void *)a1 = v9;
      uint64_t v10 = (uint64_t *)*v7;
    }
    sub_1CB8358B8(*(uint64_t **)(a1 + 8), v10);
    ++*(void *)(a1 + 16);
  }
  return v6;
}

uint64_t *sub_1CD060D30(uint64_t a1, void *a2, void **a3)
{
  unsigned int v5 = (uint64_t *)(a1 + 8);
  unsigned int v4 = *(uint64_t **)(a1 + 8);
  if (v4)
  {
    uint64_t v7 = a3 + 1;
    do
    {
      while (1)
      {
        uint64_t v8 = v4;
        uint64_t v9 = v4 + 5;
        if (!sub_1CD060BE0(*a3, v7, (void *)v4[4], v4 + 5)) {
          break;
        }
        unsigned int v4 = (uint64_t *)*v8;
        unsigned int v5 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (!sub_1CD060BE0((void *)v8[4], v9, *a3, v7)) {
        break;
      }
      unsigned int v5 = v8 + 1;
      unsigned int v4 = (uint64_t *)v8[1];
    }
    while (v4);
  }
  else
  {
    uint64_t v8 = (uint64_t *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

uint64_t sub_1CD060DE8(uint64_t *a1, void *a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * ((a1[2] - *a1) >> 3) > v3) {
    unint64_t v3 = 0x5555555555555556 * ((a1[2] - *a1) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 3) >= 0x555555555555555) {
    unint64_t v6 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v6 = v3;
  }
  if (v6)
  {
    if (v6 > 0xAAAAAAAAAAAAAAALL) {
      sub_1CB833614();
    }
    uint64_t v7 = (char *)operator new(24 * v6);
  }
  else
  {
    uint64_t v7 = 0;
  }
  uint64_t v8 = &v7[24 * v6];
  uint64_t v9 = sub_1CC4063DC((uint64_t)&v7[24 * v2], a2);
  uint64_t v10 = v9 + 24;
  uint64_t v11 = (char *)*a1;
  uint64_t v12 = (char *)a1[1];
  if (v12 == (char *)*a1)
  {
    *a1 = v9;
    a1[1] = v10;
    a1[2] = (uint64_t)v8;
    if (!v12) {
      return v10;
    }
    goto LABEL_20;
  }
  uint64_t v13 = 0;
  do
  {
    uint64_t v14 = v9 + v13;
    *(void *)(v14 - 24) = *(void *)&v12[v13 - 24];
    unsigned int v15 = &v12[v13 - 16];
    uint64_t v16 = *(void *)v15;
    *(void *)(v9 + v13 - 16) = *(void *)v15;
    uint64_t v17 = v9 + v13 - 16;
    uint64_t v18 = *(void *)&v12[v13 - 8];
    *(void *)(v14 - 8) = v18;
    if (v18)
    {
      *(void *)(v16 + 16) = v17;
      *(void *)&v12[v13 - 24] = v15;
      *(void *)unsigned int v15 = 0;
      *(void *)&v12[v13 - 8] = 0;
    }
    else
    {
      *(void *)(v14 - 24) = v17;
    }
    v13 -= 24;
  }
  while (&v12[v13] != v11);
  uint64_t v12 = (char *)*a1;
  BOOL v19 = (char *)a1[1];
  *a1 = v9 + v13;
  a1[1] = v10;
  a1[2] = (uint64_t)v8;
  if (v19 != v12)
  {
    do
    {
      unint64_t v20 = v19 - 24;
      sub_1CB833A08((uint64_t)(v19 - 24), *((void **)v19 - 2));
      BOOL v19 = v20;
    }
    while (v20 != v12);
  }
  if (v12) {
LABEL_20:
  }
    operator delete(v12);
  return v10;
}

void sub_1CD060F64(void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = (char *)**a1;
  if (v2)
  {
    unsigned int v4 = (char *)v1[1];
    unsigned int v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        unint64_t v6 = v4 - 24;
        sub_1CB833A08((uint64_t)(v4 - 24), *((void **)v4 - 2));
        unsigned int v4 = v6;
      }
      while (v6 != v2);
      unsigned int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1CD060FF0(char **a1, uint64_t a2, void *a3, void *a4, uint64_t a5)
{
  if (a5 < 1) {
    return;
  }
  unint64_t v6 = a3;
  uint64_t v8 = *a1;
  uint64_t v9 = a1[1];
  uint64_t v10 = (a2 - (uint64_t)*a1) / 24;
  uint64_t v11 = (uint64_t)&(*a1)[24 * v10];
  uint64_t v12 = a1[2];
  if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((v12 - v9) >> 3)) < a5)
  {
    unint64_t v13 = a5 - 0x5555555555555555 * ((v9 - v8) >> 3);
    if (v13 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((v12 - v8) >> 3);
    if (2 * v14 > v13) {
      unint64_t v13 = 2 * v14;
    }
    if (v14 >= 0x555555555555555) {
      unint64_t v15 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v15 = v13;
    }
    if (v15)
    {
      if (v15 > 0xAAAAAAAAAAAAAAALL) {
        sub_1CB833614();
      }
      uint64_t v16 = v10;
      uint64_t v17 = (char *)operator new(24 * v15);
      uint64_t v10 = v16;
    }
    else
    {
      uint64_t v17 = 0;
    }
    uint64_t v67 = v10;
    unint64_t v68 = &v17[24 * v10];
    unint64_t v93 = &v68[24 * a5];
    uint64_t v69 = 24 * a5;
    uint64_t v70 = (uint64_t)v68;
    do
    {
      uint64_t v70 = sub_1CC4063DC(v70, v6) + 24;
      v6 += 3;
      v69 -= 24;
    }
    while (v69);
    uint64_t v71 = *a1;
    if (*a1 != (char *)v11)
    {
      uint64_t v72 = 24 * v67;
      unint64_t v73 = v17;
      unint64_t v74 = v8;
      do
      {
        uint64_t v75 = &v73[v72];
        *((void *)v75 - 3) = *(void *)&v74[v72 - 24];
        uint64_t v76 = (uint64_t *)&v74[v72 - 16];
        uint64_t v77 = *v76;
        *(void *)&v73[v72 - 16] = *v76;
        uint64_t v78 = (uint64_t)&v73[v72 - 16];
        uint64_t v79 = *(void *)&v74[v72 - 8];
        *((void *)v75 - 1) = v79;
        if (v79)
        {
          *(void *)(v77 + 16) = v78;
          *(void *)&v74[v72 - 24] = v76;
          *uint64_t v76 = 0;
          *(void *)&v74[v72 - 8] = 0;
        }
        else
        {
          *((void *)v75 - 3) = v78;
        }
        v74 -= 24;
        v73 -= 24;
      }
      while (&v74[v72] != v71);
      unint64_t v68 = &v73[24 * v67];
    }
    int v80 = a1[1];
    size_t v81 = v93;
    if (v80 != (char *)v11)
    {
      uint64_t v82 = 24 * v67;
      uint64_t v83 = &v17[24 * a5];
      do
      {
        uint64_t v84 = (uint64_t *)&v83[v82];
        *uint64_t v84 = *(void *)&v8[24 * v67];
        unint64_t v85 = (uint64_t *)&v8[v82 + 8];
        uint64_t v86 = *v85;
        *(void *)&v83[v82 + 8] = *v85;
        uint64_t v87 = (uint64_t)&v83[v82 + 8];
        uint64_t v88 = *(void *)&v8[v82 + 16];
        v84[2] = v88;
        if (v88)
        {
          *(void *)(v86 + 16) = v87;
          *(void *)&v8[24 * v67] = v85;
          *unint64_t v85 = 0;
          *(void *)&v8[v82 + 16] = 0;
        }
        else
        {
          *uint64_t v84 = v87;
        }
        v8 += 24;
        v83 += 24;
      }
      while (&v8[v82] != v80);
      uint64_t v11 = (uint64_t)a1[1];
      size_t v81 = &v83[24 * v67];
    }
    size_t v89 = *a1;
    *a1 = v68;
    a1[1] = v81;
    for (a1[2] = &v17[24 * v15]; (char *)v11 != v89; v11 -= 24)
      sub_1CB833A08(v11 - 24, *(void **)(v11 - 16));
    if (v89)
    {
      operator delete(v89);
    }
    return;
  }
  if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v9[-v11] >> 3)) >= a5)
  {
    uint64_t v23 = &a3[3 * a5];
    unint64_t v20 = v9;
  }
  else
  {
    BOOL v19 = &a3[(uint64_t)&v9[-v11] >> 3];
    uint64_t v90 = v10;
    BOOL v91 = v19;
    unint64_t v20 = a1[1];
    if (v19 != a4)
    {
      uint64_t v21 = (uint64_t)a1[1];
      do
      {
        uint64_t v22 = sub_1CC4063DC(v21, v19);
        v19 += 3;
        uint64_t v21 = v22 + 24;
        v20 += 24;
      }
      while (v19 != a4);
    }
    a1[1] = v20;
    uint64_t v23 = v91;
    if ((uint64_t)&v9[-v11] < 1) {
      return;
    }
    uint64_t v10 = v90;
  }
  uint64_t v24 = v11 + 24 * a5;
  unint64_t v25 = (unint64_t)&v20[-24 * a5];
  uint64_t v26 = v20;
  if (v25 < (unint64_t)v9)
  {
    uint64_t v27 = 0;
    size_t v28 = &v8[24 * v10 + 8 * ((uint64_t)&v20[-v24] >> 3)];
    do
    {
      unint64_t v29 = (uint64_t *)&v20[v27];
      *unint64_t v29 = *(void *)&v28[v27];
      uint64_t v30 = &v28[v27 + 8];
      uint64_t v31 = *(void *)v30;
      *(void *)&v20[v27 + 8] = *(void *)v30;
      uint64_t v32 = (uint64_t)&v20[v27 + 8];
      uint64_t v33 = *(void *)&v28[v27 + 16];
      v29[2] = v33;
      if (v33)
      {
        *(void *)(v31 + 16) = v32;
        *(void *)&v28[v27] = v30;
        *(void *)uint64_t v30 = 0;
        *(void *)&v28[v27 + 16] = 0;
      }
      else
      {
        *unint64_t v29 = v32;
      }
      v27 += 24;
    }
    while (&v28[v27] < v9);
    uint64_t v26 = &v20[v27];
  }
  uint64_t v92 = v23;
  a1[1] = v26;
  if (v20 != (char *)v24)
  {
    uint64_t v34 = 0;
    uint64_t v35 = &v8[24 * v10 + 8 * ((uint64_t)&v20[-v24] >> 3)];
    uint64_t v36 = -8 * ((uint64_t)&v20[-v24] >> 3);
    do
    {
      uint64_t v37 = &v20[v34 - 16];
      sub_1CB833A08((uint64_t)&v20[v34 - 24], *(void **)v37);
      *(void *)&v20[v34 - 24] = *(void *)(v25 + v34 - 24);
      unint64_t v38 = *(void **)&v35[v34 - 16];
      *(void *)uint64_t v37 = v38;
      uint64_t v39 = *(void *)&v35[v34 - 8];
      *(void *)&v20[v34 - 8] = v39;
      if (v39)
      {
        v38[2] = v37;
        *(void *)(v25 + v34 - 24) = v25 + v34 - 16;
        *(void *)&v35[v34 - 16] = 0;
        *(void *)&v35[v34 - 8] = 0;
      }
      else
      {
        *(void *)&v20[v34 - 24] = v37;
      }
      v34 -= 24;
    }
    while (v36 != v34);
  }
  for (; v6 != v92; v11 += 24)
  {
    if ((void *)v11 != v6)
    {
      unint64_t v40 = v6 + 1;
      uint64_t v41 = (void *)*v6;
      if (!*(void *)(v11 + 16)) {
        goto LABEL_59;
      }
      unint64_t v42 = *(uint64_t **)v11;
      uint64_t v44 = (uint64_t **)(v11 + 8);
      uint64_t v43 = *(void *)(v11 + 8);
      *(void *)uint64_t v11 = v11 + 8;
      *(void *)(v43 + 16) = 0;
      *(void *)(v11 + 16) = 0;
      *(void *)(v11 + 8) = 0;
      uint64_t v45 = v42[1] ? v42[1] : (uint64_t)v42;
      if (v45)
      {
        unint64_t v46 = sub_1CD4F3428(v45);
        if (v41 == v40)
        {
          uint64_t v47 = (void *)v45;
          uint64_t v54 = v41;
        }
        else
        {
          do
          {
            uint64_t v47 = v46;
            unsigned int v48 = *((_DWORD *)v41 + 7);
            *(_DWORD *)(v45 + 28) = v48;
            uint64_t v49 = *v44;
            unint64_t v50 = (uint64_t *)(v11 + 8);
            uint64_t v51 = (uint64_t *)(v11 + 8);
            if (*v44)
            {
              do
              {
                while (1)
                {
                  unint64_t v50 = v49;
                  if (v48 >= *((_DWORD *)v49 + 7)) {
                    break;
                  }
                  uint64_t v49 = (uint64_t *)*v49;
                  uint64_t v51 = v50;
                  if (!*v50) {
                    goto LABEL_46;
                  }
                }
                uint64_t v49 = (uint64_t *)v49[1];
              }
              while (v49);
              uint64_t v51 = v50 + 1;
            }
LABEL_46:
            *(void *)uint64_t v45 = 0;
            *(void *)(v45 + 8) = 0;
            *(void *)(v45 + 16) = v50;
            *uint64_t v51 = v45;
            uint64_t v52 = **(void **)v11;
            if (v52)
            {
              *(void *)uint64_t v11 = v52;
              uint64_t v45 = *v51;
            }
            sub_1CB8358B8(*(uint64_t **)(v11 + 8), (uint64_t *)v45);
            ++*(void *)(v11 + 16);
            if (v46) {
              unint64_t v46 = sub_1CD4F3428((uint64_t)v46);
            }
            else {
              unint64_t v46 = 0;
            }
            unint64_t v53 = (void *)v41[1];
            if (v53)
            {
              do
              {
                uint64_t v54 = v53;
                unint64_t v53 = (void *)*v53;
              }
              while (v53);
            }
            else
            {
              do
              {
                uint64_t v54 = (void *)v41[2];
                BOOL v55 = *v54 == (void)v41;
                uint64_t v41 = v54;
              }
              while (!v55);
            }
            if (!v47) {
              break;
            }
            uint64_t v41 = v54;
            uint64_t v45 = (uint64_t)v47;
          }
          while (v54 != v40);
        }
        sub_1CB833A08(v11, v47);
        if (v46)
        {
          do
          {
            unint64_t v56 = v46;
            unint64_t v46 = (void *)v46[2];
          }
          while (v46);
          sub_1CB833A08(v11, v56);
        }
      }
      else
      {
LABEL_59:
        uint64_t v54 = v41;
      }
      if (v54 != v40)
      {
        uint64_t v57 = (uint64_t ***)(v11 + 8);
        do
        {
          unsigned int v58 = *((_DWORD *)v54 + 7);
          uint64_t v59 = (uint64_t *)operator new(0x20uLL);
          uint64_t v60 = v59;
          *((_DWORD *)v59 + 7) = v58;
          uint64_t v61 = *v57;
          unint64_t v62 = (uint64_t **)(v11 + 8);
          uint64_t v63 = (uint64_t **)(v11 + 8);
          if (*v57)
          {
            do
            {
              while (1)
              {
                unint64_t v62 = v61;
                if (*((_DWORD *)v61 + 7) <= v58) {
                  break;
                }
                uint64_t v61 = (uint64_t **)*v61;
                uint64_t v63 = v62;
                if (!*v62) {
                  goto LABEL_72;
                }
              }
              uint64_t v61 = (uint64_t **)v61[1];
            }
            while (v61);
            uint64_t v63 = v62 + 1;
          }
LABEL_72:
          *uint64_t v59 = 0;
          v59[1] = 0;
          void v59[2] = (uint64_t)v62;
          *uint64_t v63 = v59;
          uint64_t v64 = **(void **)v11;
          if (v64)
          {
            *(void *)uint64_t v11 = v64;
            uint64_t v60 = *v63;
          }
          sub_1CB8358B8(*(uint64_t **)(v11 + 8), v60);
          ++*(void *)(v11 + 16);
          BOOL v65 = (void *)v54[1];
          if (v65)
          {
            do
            {
              uint64_t v66 = v65;
              BOOL v65 = (void *)*v65;
            }
            while (v65);
          }
          else
          {
            do
            {
              uint64_t v66 = (void *)v54[2];
              BOOL v55 = *v66 == (void)v54;
              uint64_t v54 = v66;
            }
            while (!v55);
          }
          uint64_t v54 = v66;
        }
        while (v66 != v40);
      }
    }
    v6 += 3;
  }
}

void llvm::DAGDeltaAlgorithm::Run(uint64_t a1@<X0>, void *a2@<X1>, unsigned int **a3@<X2>, void *a4@<X8>)
{
  uint64_t v130 = a1;
  std::string __p = 0;
  std::string::size_type v132 = 0;
  uint64_t v133 = 0;
  unint64_t v134 = v135;
  v135[0] = 0;
  v137[0] = 0;
  v137[1] = 0;
  v135[1] = 0;
  unint64_t v136 = (uint64_t *)v137;
  unint64_t v138 = (uint64_t *)v139;
  v139[0] = 0;
  unint64_t v141 = 0;
  uint64_t v142 = 0;
  v139[1] = 0;
  uint64_t v140 = &v141;
  v144[0] = 0;
  v144[1] = 0;
  unint64_t v143 = (uint64_t *)v144;
  uint64_t v7 = a2 + 1;
  unint64_t v6 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      LODWORD(v147) = *((_DWORD *)v6 + 7);
      unsigned int v8 = v147;
      uint64_t v149 = 0;
      uint64_t v150 = 0;
      v148 = 0;
      sub_1CD06226C((uint64_t *)&v136, v147, (uint64_t)&v147);
      if (v148) {
        operator delete(v148);
      }
      LODWORD(v147) = v8;
      uint64_t v149 = 0;
      uint64_t v150 = 0;
      v148 = 0;
      sub_1CD06226C((uint64_t *)&v138, v8, (uint64_t)&v147);
      if (v148) {
        operator delete(v148);
      }
      uint64_t v9 = (void *)v6[1];
      if (v9)
      {
        do
        {
          uint64_t v10 = v9;
          uint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          uint64_t v10 = (void *)v6[2];
          BOOL v11 = *v10 == (void)v6;
          unint64_t v6 = v10;
        }
        while (!v11);
      }
      unint64_t v6 = v10;
    }
    while (v10 != v7);
  }
  unint64_t v13 = *a3;
  uint64_t v12 = a3[1];
  v127 = a4;
  v128 = v7;
  if (*a3 != v12)
  {
    do
    {
      unint64_t v14 = v13 + 1;
      unint64_t v15 = sub_1CD4F4F28(&v136, v13[1], v13 + 1);
      uint64_t v16 = v15;
      uint64_t v18 = (unsigned int *)v15[6];
      uint64_t v17 = v15[7];
      if (v18 >= (unsigned int *)v17)
      {
        unint64_t v20 = v15[5];
        uint64_t v21 = ((char *)v18 - (char *)v20) >> 2;
        unint64_t v22 = v21 + 1;
        if ((unint64_t)(v21 + 1) >> 62) {
          goto LABEL_195;
        }
        uint64_t v23 = (char *)v17 - (char *)v20;
        if (v23 >> 1 > v22) {
          unint64_t v22 = v23 >> 1;
        }
        if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v24 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v24 = v22;
        }
        if (v24)
        {
          if (v24 >> 62) {
            goto LABEL_196;
          }
          unint64_t v25 = (char *)operator new(4 * v24);
        }
        else
        {
          unint64_t v25 = 0;
        }
        uint64_t v26 = (unsigned int *)&v25[4 * v21];
        unsigned int *v26 = *v13;
        BOOL v19 = (uint64_t *)(v26 + 1);
        while (v18 != (unsigned int *)v20)
        {
          unsigned int v27 = *--v18;
          *--uint64_t v26 = v27;
        }
        v16[5] = (uint64_t *)v26;
        v16[6] = v19;
        v16[7] = (uint64_t *)&v25[4 * v24];
        if (v20) {
          operator delete(v20);
        }
        uint64_t v7 = v128;
      }
      else
      {
        *uint64_t v18 = *v13;
        BOOL v19 = (uint64_t *)(v18 + 1);
      }
      v16[6] = v19;
      size_t v28 = sub_1CD4F4F28(&v138, *v13, v13);
      unint64_t v29 = v28;
      uint64_t v31 = (char *)v28[6];
      uint64_t v30 = v28[7];
      if (v31 >= (char *)v30)
      {
        uint64_t v33 = v28[5];
        uint64_t v34 = (v31 - (char *)v33) >> 2;
        unint64_t v35 = v34 + 1;
        if ((unint64_t)(v34 + 1) >> 62) {
          goto LABEL_195;
        }
        uint64_t v36 = (char *)v30 - (char *)v33;
        if (v36 >> 1 > v35) {
          unint64_t v35 = v36 >> 1;
        }
        if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v37 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v37 = v35;
        }
        if (v37)
        {
          if (v37 >> 62) {
LABEL_196:
          }
            sub_1CB833614();
          unint64_t v38 = (char *)operator new(4 * v37);
        }
        else
        {
          unint64_t v38 = 0;
        }
        uint64_t v39 = &v38[4 * v34];
        *(_DWORD *)uint64_t v39 = *v14;
        uint64_t v32 = (uint64_t *)(v39 + 4);
        while (v31 != (char *)v33)
        {
          int v40 = *((_DWORD *)v31 - 1);
          v31 -= 4;
          *((_DWORD *)v39 - 1) = v40;
          v39 -= 4;
        }
        v29[5] = (uint64_t *)v39;
        v29[6] = v32;
        v29[7] = (uint64_t *)&v38[4 * v37];
        if (v33) {
          operator delete(v33);
        }
        uint64_t v7 = v128;
      }
      else
      {
        *(_DWORD *)uint64_t v31 = *v14;
        uint64_t v32 = (uint64_t *)(v31 + 4);
      }
      v29[6] = v32;
      v13 += 2;
    }
    while (v13 != v12);
  }
  uint64_t v41 = (void *)*a2;
  if ((void *)*a2 != v7)
  {
    do
    {
      LODWORD(v147) = *((_DWORD *)v41 + 7);
      unsigned int v42 = v147;
      uint64_t v43 = sub_1CD4F4F28(&v138, v147, &v147)[5];
      LODWORD(v147) = v42;
      if (v43 == sub_1CD4F4F28(&v138, v42, &v147)[6])
      {
        uint64_t v44 = v132;
        if (v132 >= v133)
        {
          unint64_t v46 = (unsigned int *)__p;
          uint64_t v47 = ((char *)v132 - (unsigned char *)__p) >> 2;
          unint64_t v48 = v47 + 1;
          if ((unint64_t)(v47 + 1) >> 62) {
            goto LABEL_195;
          }
          uint64_t v49 = (char *)v133 - (unsigned char *)__p;
          if (((char *)v133 - (unsigned char *)__p) >> 1 > v48) {
            unint64_t v48 = v49 >> 1;
          }
          if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v50 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v50 = v48;
          }
          if (v50)
          {
            if (v50 >> 62) {
              goto LABEL_196;
            }
            uint64_t v51 = (char *)operator new(4 * v50);
          }
          else
          {
            uint64_t v51 = 0;
          }
          uint64_t v52 = (unsigned int *)&v51[4 * v47];
          *uint64_t v52 = v42;
          uint64_t v45 = v52 + 1;
          while (v44 != v46)
          {
            unsigned int v53 = *--v44;
            *--uint64_t v52 = v53;
          }
          std::string __p = v52;
          std::string::size_type v132 = v45;
          uint64_t v133 = (unsigned int *)&v51[4 * v50];
          if (v46) {
            operator delete(v46);
          }
        }
        else
        {
          *std::string::size_type v132 = v42;
          uint64_t v45 = v44 + 1;
        }
        std::string::size_type v132 = v45;
      }
      uint64_t v54 = (void *)v41[1];
      if (v54)
      {
        do
        {
          BOOL v55 = v54;
          uint64_t v54 = (void *)*v54;
        }
        while (v54);
      }
      else
      {
        do
        {
          BOOL v55 = (void *)v41[2];
          BOOL v11 = *v55 == (void)v41;
          uint64_t v41 = v55;
        }
        while (!v11);
      }
      uint64_t v41 = v55;
    }
    while (v55 != v7);
  }
  int64_t v56 = (char *)v132 - (unsigned char *)__p;
  if (v132 == __p)
  {
    uint64_t v57 = 0;
  }
  else
  {
    if (v56 < 0) {
LABEL_195:
    }
      abort();
    uint64_t v57 = (unsigned int *)operator new((char *)v132 - (unsigned char *)__p);
    unsigned int v58 = (char *)&v57[v56 >> 2];
    memmove(v57, __p, v56);
    uint64_t v59 = (unsigned int *)v58;
    do
    {
      LODWORD(v153) = 0;
      unsigned int v61 = *(v59 - 1);
      uint64_t v60 = v59 - 1;
      LODWORD(v153) = v61;
      unint64_t v62 = sub_1CC407240(&v143, v61, &v153);
      LODWORD(v147) = v61;
      uint64_t v63 = (unsigned int *)sub_1CD4F4F28(&v136, v61, &v147)[5];
      LODWORD(v147) = v61;
      unsigned int v129 = sub_1CD4F4F28(&v136, v61, &v147)[6];
      if (v63 == (unsigned int *)v129)
      {
        int v80 = v60;
      }
      else
      {
        uint64_t v64 = v62 + 6;
        do
        {
          BOOL v65 = sub_1CC407240(&v143, *v63, v63);
          uint64_t v66 = v65;
          unint64_t v68 = (uint64_t *)(v65 + 6);
          uint64_t v67 = v65[6];
          int v69 = (int)v153;
          if (v67)
          {
            do
            {
              while (1)
              {
                uint64_t v70 = v67;
                unsigned int v71 = *((_DWORD *)v67 + 7);
                if (v153 >= v71) {
                  break;
                }
                uint64_t v67 = (uint64_t *)*v70;
                unint64_t v68 = v70;
                if (!*v70) {
                  goto LABEL_87;
                }
              }
              if (v71 >= v153) {
                goto LABEL_90;
              }
              uint64_t v67 = (uint64_t *)v70[1];
            }
            while (v67);
            unint64_t v68 = v70 + 1;
          }
          else
          {
            uint64_t v70 = (uint64_t *)(v65 + 6);
          }
LABEL_87:
          uint64_t v72 = operator new(0x20uLL);
          v72[7] = v69;
          *(void *)uint64_t v72 = 0;
          *((void *)v72 + 1) = 0;
          *((void *)v72 + 2) = v70;
          *unint64_t v68 = (uint64_t)v72;
          unint64_t v73 = (uint64_t *)*v66[5];
          if (v73)
          {
            v66[5] = v73;
            uint64_t v72 = (_DWORD *)*v68;
          }
          sub_1CB8358B8(v66[6], (uint64_t *)v72);
          v66[7] = (uint64_t *)((char *)v66[7] + 1);
LABEL_90:
          unint64_t v74 = sub_1CC407240(&v143, *v63, v63);
          uint64_t v75 = v62[5];
          if (v75 != (uint64_t *)v64)
          {
            uint64_t v76 = v74 + 5;
            uint64_t v77 = (uint64_t *)(v74 + 6);
            do
            {
              sub_1CC406474(v76, v77, (unsigned int *)v75 + 7, (_DWORD *)v75 + 7);
              uint64_t v78 = (uint64_t *)v75[1];
              if (v78)
              {
                do
                {
                  uint64_t v79 = v78;
                  uint64_t v78 = (uint64_t *)*v78;
                }
                while (v78);
              }
              else
              {
                do
                {
                  uint64_t v79 = (uint64_t *)v75[2];
                  BOOL v11 = *v79 == (void)v75;
                  uint64_t v75 = v79;
                }
                while (!v11);
              }
              uint64_t v75 = v79;
            }
            while (v79 != (uint64_t *)v64);
          }
          if (v60 >= (unsigned int *)v58)
          {
            uint64_t v81 = v60 - v57;
            unint64_t v82 = v81 + 1;
            if ((unint64_t)(v81 + 1) >> 62) {
              goto LABEL_195;
            }
            if ((v58 - (char *)v57) >> 1 > v82) {
              unint64_t v82 = (v58 - (char *)v57) >> 1;
            }
            if ((unint64_t)(v58 - (char *)v57) >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v83 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v83 = v82;
            }
            if (v83)
            {
              if (v83 >> 62) {
                goto LABEL_196;
              }
              uint64_t v84 = (char *)operator new(4 * v83);
            }
            else
            {
              uint64_t v84 = 0;
            }
            unint64_t v85 = (unsigned int *)&v84[4 * v81];
            *unint64_t v85 = *v63;
            int v80 = v85 + 1;
            while (v60 != v57)
            {
              unsigned int v86 = *--v60;
              *--unint64_t v85 = v86;
            }
            unsigned int v58 = &v84[4 * v83];
            if (v57) {
              operator delete(v57);
            }
            uint64_t v57 = v85;
          }
          else
          {
            *uint64_t v60 = *v63;
            int v80 = v60 + 1;
          }
          ++v63;
          uint64_t v60 = v80;
        }
        while (v63 != (unsigned int *)v129);
      }
      uint64_t v59 = v80;
    }
    while (v57 != v80);
  }
  uint64_t v87 = (void *)*a2;
  if ((void *)*a2 != v128)
  {
    do
    {
      unsigned int v88 = *((_DWORD *)v87 + 7);
      uint64_t v154 = 0;
      uint64_t v155 = 0;
      uint64_t v153 = &v154;
      LODWORD(v147) = v88;
      uint64_t v149 = 0;
      uint64_t v150 = 0;
      v148 = &v149;
      size_t v89 = v141;
      uint64_t v90 = &v141;
LABEL_125:
      BOOL v91 = v90;
      if (v89)
      {
        while (1)
        {
          uint64_t v90 = (uint64_t **)v89;
          unsigned int v92 = *((_DWORD *)v89 + 8);
          if (v92 > v88)
          {
            size_t v89 = *v90;
            goto LABEL_125;
          }
          if (v92 >= v88) {
            break;
          }
          size_t v89 = v90[1];
          if (!v89)
          {
            BOOL v91 = v90 + 1;
            goto LABEL_132;
          }
        }
        unint64_t v93 = 0;
      }
      else
      {
LABEL_132:
        uint64_t v94 = operator new(0x40uLL);
        v94[8] = v88;
        *((void *)v94 + 7) = 0;
        *((void *)v94 + 6) = 0;
        *((void *)v94 + 5) = v94 + 12;
        *(void *)uint64_t v94 = 0;
        *((void *)v94 + 1) = 0;
        *((void *)v94 + 2) = v90;
        *BOOL v91 = (uint64_t *)v94;
        if (*v140)
        {
          uint64_t v140 = (uint64_t **)*v140;
          unint64_t v95 = *v91;
        }
        else
        {
          unint64_t v95 = (uint64_t *)v94;
        }
        sub_1CB8358B8(v141, v95);
        ++v142;
        unint64_t v93 = v149;
      }
      sub_1CB833A08((uint64_t)&v148, v93);
      sub_1CB833A08((uint64_t)&v153, v154);
      BOOL v96 = (void *)v87[1];
      if (v96)
      {
        do
        {
          int v97 = v96;
          BOOL v96 = (void *)*v96;
        }
        while (v96);
      }
      else
      {
        do
        {
          int v97 = (void *)v87[2];
          BOOL v11 = *v97 == (void)v87;
          uint64_t v87 = v97;
        }
        while (!v11);
      }
      uint64_t v87 = v97;
    }
    while (v97 != v128);
    size_t v98 = (void *)*a2;
    if ((void *)*a2 != v128)
    {
      do
      {
        LODWORD(v147) = *((_DWORD *)v98 + 7);
        unsigned int v99 = v147;
        long long v100 = sub_1CC407240(&v143, v147, &v147)[5];
        LODWORD(v147) = v99;
        unint64_t v101 = sub_1CC407240(&v143, v99, &v147) + 6;
        if (v100 != (uint64_t *)v101)
        {
          do
          {
            uint64_t v103 = sub_1CC407240((uint64_t **)&v140, *((_DWORD *)v100 + 7), (_DWORD *)v100 + 7);
            unint64_t v104 = v103;
            unint64_t v106 = (uint64_t *)(v103 + 6);
            uint64_t v105 = v103[6];
            if (v105)
            {
              do
              {
                while (1)
                {
                  unint64_t v102 = v105;
                  unsigned int v107 = *((_DWORD *)v105 + 7);
                  if (v99 >= v107) {
                    break;
                  }
                  uint64_t v105 = (uint64_t *)*v102;
                  unint64_t v106 = v102;
                  if (!*v102) {
                    goto LABEL_152;
                  }
                }
                if (v107 >= v99) {
                  goto LABEL_155;
                }
                uint64_t v105 = (uint64_t *)v102[1];
              }
              while (v105);
              unint64_t v106 = v102 + 1;
            }
            else
            {
              unint64_t v102 = (uint64_t *)(v103 + 6);
            }
LABEL_152:
            char v108 = operator new(0x20uLL);
            v108[7] = v99;
            *(void *)char v108 = 0;
            *((void *)v108 + 1) = 0;
            *((void *)v108 + 2) = v102;
            *unint64_t v106 = (uint64_t)v108;
            unint64_t v109 = (uint64_t *)*v104[5];
            if (v109)
            {
              v104[5] = v109;
              char v108 = (_DWORD *)*v106;
            }
            sub_1CB8358B8(v104[6], (uint64_t *)v108);
            v104[7] = (uint64_t *)((char *)v104[7] + 1);
LABEL_155:
            uint64_t v110 = (uint64_t *)v100[1];
            if (v110)
            {
              do
              {
                uint64_t v111 = v110;
                uint64_t v110 = (uint64_t *)*v110;
              }
              while (v110);
            }
            else
            {
              do
              {
                uint64_t v111 = (uint64_t *)v100[2];
                BOOL v11 = *v111 == (void)v100;
                long long v100 = v111;
              }
              while (!v11);
            }
            long long v100 = v111;
          }
          while (v111 != (uint64_t *)v101);
        }
        unint64_t v112 = (void *)v98[1];
        if (v112)
        {
          do
          {
            uint64_t v113 = v112;
            unint64_t v112 = (void *)*v112;
          }
          while (v112);
        }
        else
        {
          do
          {
            uint64_t v113 = (void *)v98[2];
            BOOL v11 = *v113 == (void)v98;
            size_t v98 = v113;
          }
          while (!v11);
        }
        size_t v98 = v113;
      }
      while (v113 != v128);
    }
  }
  if (v57) {
    operator delete(v57);
  }
  unint64_t v114 = (unsigned int *)__p;
  uint64_t v154 = 0;
  uint64_t v155 = 0;
  uint64_t v153 = &v154;
  unint64_t v115 = (void **)v127;
  if (__p == v132)
  {
    v127[2] = 0;
    v127[1] = 0;
    void *v127 = v127 + 1;
  }
  else
  {
    do
    {
      sub_1CC406474(&v153, (uint64_t *)&v154, v114, v114);
      ++v114;
    }
    while (v114 != v132);
    uint64_t v116 = v155;
    v127[1] = 0;
    v127[2] = 0;
    void *v127 = v127 + 1;
    if (v116)
    {
      do
      {
        uint64_t v149 = 0;
        uint64_t v150 = 0;
        unint64_t v147 = (void (**)(void))&unk_1F26447D8;
        v148 = &v149;
        uint64_t v151 = &v130;
        unint64_t v152 = v115;
        llvm::DeltaAlgorithm::Run(&v147, &v153, &v145);
        unint64_t v117 = v145;
        if (v145 != (unsigned int *)v146)
        {
          do
          {
            sub_1CC406474(v115, v127 + 1, v117 + 7, v117 + 7);
            uint64_t v118 = (unsigned int *)*((void *)v117 + 1);
            if (v118)
            {
              do
              {
                uint64_t v119 = v118;
                uint64_t v118 = *(unsigned int **)v118;
              }
              while (v118);
            }
            else
            {
              do
              {
                uint64_t v119 = (unsigned int *)*((void *)v117 + 2);
                BOOL v11 = *(void *)v119 == (void)v117;
                unint64_t v117 = v119;
              }
              while (!v11);
            }
            unint64_t v117 = v119;
          }
          while (v119 != (unsigned int *)v146);
        }
        sub_1CB833A08((uint64_t)&v153, v154);
        uint64_t v154 = 0;
        uint64_t v155 = 0;
        uint64_t v153 = &v154;
        unint64_t v120 = v145;
        if (v145 != (unsigned int *)v146)
        {
          do
          {
            v156[0] = v120[7];
            unsigned int v121 = v156[0];
            unint64_t v122 = (unsigned int *)sub_1CD4F4F28(&v136, v156[0], v156)[5];
            v156[0] = v121;
            unint64_t v123 = sub_1CD4F4F28(&v136, v121, v156)[6];
            while (v122 != (unsigned int *)v123)
            {
              sub_1CC406474(&v153, (uint64_t *)&v154, v122, v122);
              ++v122;
            }
            long long v124 = (unsigned int *)*((void *)v120 + 1);
            if (v124)
            {
              do
              {
                v125 = v124;
                long long v124 = *(unsigned int **)v124;
              }
              while (v124);
            }
            else
            {
              do
              {
                v125 = (unsigned int *)*((void *)v120 + 2);
                BOOL v11 = *(void *)v125 == (void)v120;
                unint64_t v120 = v125;
              }
              while (!v11);
            }
            unint64_t v120 = v125;
          }
          while (v125 != (unsigned int *)v146);
        }
        sub_1CB833A08((uint64_t)&v145, v146[0]);
        unint64_t v147 = (void (**)(void))&unk_1F2644770;
        sub_1CD060AE8((uint64_t)&v148, v149);
        unint64_t v115 = (void **)v127;
      }
      while (v155);
    }
  }
  sub_1CB833A08((uint64_t)&v153, v154);
  sub_1CD06260C(v144[0]);
  sub_1CD06260C(v141);
  sub_1CC42D5E4(v139[0]);
  sub_1CC42D5E4(v137[0]);
  sub_1CD060AE8((uint64_t)&v134, v135[0]);
  if (__p)
  {
    std::string::size_type v132 = (unsigned int *)__p;
    operator delete(__p);
  }
}

uint64_t *sub_1CD06226C(uint64_t *result, unsigned int a2, uint64_t a3)
{
  unsigned int v4 = result;
  unint64_t v6 = (uint64_t **)(result + 1);
  uint64_t v5 = result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (void *)v5;
        unsigned int v8 = *(_DWORD *)(v5 + 32);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        unint64_t v6 = (uint64_t **)v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        unint64_t v6 = (uint64_t **)(v7 + 1);
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = result + 1;
LABEL_9:
    uint64_t v9 = (char *)operator new(0x40uLL);
    *((_DWORD *)v9 + 8) = *(_DWORD *)a3;
    *(_OWORD *)(v9 + 40) = *(_OWORD *)(a3 + 8);
    *((void *)v9 + 7) = *(void *)(a3 + 24);
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)(a3 + 24) = 0;
    *(void *)uint64_t v9 = 0;
    *((void *)v9 + 1) = 0;
    *((void *)v9 + 2) = v7;
    *unint64_t v6 = (uint64_t *)v9;
    uint64_t v10 = *(void *)*v4;
    if (v10)
    {
      *unsigned int v4 = v10;
      BOOL v11 = *v6;
    }
    else
    {
      BOOL v11 = (uint64_t *)v9;
    }
    uint64_t result = sub_1CB8358B8((uint64_t *)v4[1], v11);
    ++v4[2];
  }
  return result;
}

uint64_t sub_1CD062340(uint64_t a1)
{
  *(void *)a1 = &unk_1F2644770;
  sub_1CD060AE8(a1 + 8, *(void **)(a1 + 16));
  return a1;
}

uint64_t sub_1CD062388(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, void))(***(void ***)(a1 + 32) + 24))(**(void **)(a1 + 32), a2, a3, *(void *)(a1 + 40));
}

uint64_t sub_1CD0623B4(uint64_t a1, void *a2)
{
  unint64_t v3 = *(uint64_t ***)(a1 + 32);
  sub_1CC4063DC((uint64_t)&v18, *(void **)(a1 + 40));
  unsigned int v4 = (unsigned int *)(a2 + 1);
  uint64_t v5 = (unsigned int *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      sub_1CC406474(&v18, (uint64_t *)v19, v5 + 7, v5 + 7);
      unint64_t v6 = (unsigned int *)*((void *)v5 + 1);
      if (v6)
      {
        do
        {
          uint64_t v7 = v6;
          unint64_t v6 = *(unsigned int **)v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v7 = (unsigned int *)*((void *)v5 + 2);
          BOOL v8 = *(void *)v7 == (void)v5;
          uint64_t v5 = v7;
        }
        while (!v8);
      }
      uint64_t v5 = v7;
    }
    while (v7 != v4);
    uint64_t v5 = (unsigned int *)*a2;
  }
  if (v5 != v4)
  {
    do
    {
      unsigned int v20 = v5[7];
      unsigned int v9 = v20;
      uint64_t v10 = sub_1CC407240(v3 + 13, v20, &v20)[5];
      unsigned int v20 = v9;
      BOOL v11 = sub_1CC407240(v3 + 13, v9, &v20) + 6;
      if (v10 != (uint64_t *)v11)
      {
        do
        {
          sub_1CC406474(&v18, (uint64_t *)v19, (unsigned int *)v10 + 7, (_DWORD *)v10 + 7);
          uint64_t v12 = (uint64_t *)v10[1];
          if (v12)
          {
            do
            {
              unint64_t v13 = v12;
              uint64_t v12 = (uint64_t *)*v12;
            }
            while (v12);
          }
          else
          {
            do
            {
              unint64_t v13 = (uint64_t *)v10[2];
              BOOL v8 = *v13 == (void)v10;
              uint64_t v10 = v13;
            }
            while (!v8);
          }
          uint64_t v10 = v13;
        }
        while (v13 != (uint64_t *)v11);
      }
      unint64_t v14 = (unsigned int *)*((void *)v5 + 1);
      if (v14)
      {
        do
        {
          unint64_t v15 = v14;
          unint64_t v14 = *(unsigned int **)v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          unint64_t v15 = (unsigned int *)*((void *)v5 + 2);
          BOOL v8 = *(void *)v15 == (void)v5;
          uint64_t v5 = v15;
        }
        while (!v8);
      }
      uint64_t v5 = v15;
    }
    while (v15 != v4);
  }
  if (sub_1CD060B48((uint64_t)(v3 + 4), &v18)) {
    goto LABEL_27;
  }
  if (((*(uint64_t (**)(uint64_t *, void **))(**v3 + 32))(*v3, &v18) & 1) == 0)
  {
    sub_1CD060C80((uint64_t)(v3 + 4), &v18, &v18);
LABEL_27:
    uint64_t v16 = 0;
    goto LABEL_28;
  }
  uint64_t v16 = 1;
LABEL_28:
  sub_1CB833A08((uint64_t)&v18, v19[0]);
  return v16;
}

void sub_1CD0625A4(uint64_t a1)
{
  *(void *)a1 = &unk_1F2644770;
  sub_1CD060AE8(a1 + 8, *(void **)(a1 + 16));

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD06260C(void *a1)
{
  if (a1)
  {
    sub_1CD06260C(*a1);
    sub_1CD06260C(a1[1]);
    sub_1CB833A08((uint64_t)(a1 + 5), (void *)a1[6]);
    operator delete(a1);
  }
}

uint64_t llvm::ELFAttributeParser::printAttribute(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v11 = (uint64_t *)(a1 + 24);
  unint64_t v12 = a2;
  unint64_t v13 = *(void *)(a1 + 32);
  if (v13)
  {
    uint8x8_t v14 = (uint8x8_t)vcnt_s8((int8x8_t)v13);
    v14.i16[0] = vaddlv_u8(v14);
    if (v14.u32[0] > 1uLL)
    {
      unint64_t v5 = a2;
      if (v13 <= a2) {
        unint64_t v5 = a2 % v13;
      }
    }
    else
    {
      unint64_t v5 = (v13 - 1) & a2;
    }
    unint64_t v15 = *(uint64_t ***)(*v11 + 8 * v5);
    if (v15)
    {
      for (uint64_t i = *v15; i; uint64_t i = (uint64_t *)*i)
      {
        unint64_t v17 = i[1];
        if (v17 == a2)
        {
          if (*((_DWORD *)i + 4) == a2) {
            goto LABEL_40;
          }
        }
        else
        {
          if (v14.u32[0] > 1uLL)
          {
            if (v17 >= v13) {
              v17 %= v13;
            }
          }
          else
          {
            v17 &= v13 - 1;
          }
          if (v17 != v5) {
            break;
          }
        }
      }
    }
  }
  uint64_t v18 = operator new(0x18uLL);
  v18[1] = v12;
  *((_DWORD *)v18 + 4) = a2;
  *((_DWORD *)v18 + 5) = a3;
  float v19 = (float)(unint64_t)(*(void *)(a1 + 48) + 1);
  float v20 = *(float *)(a1 + 56);
  if (!v13 || (float)(v20 * (float)v13) < v19)
  {
    BOOL v21 = 1;
    if (v13 >= 3) {
      BOOL v21 = (v13 & (v13 - 1)) != 0;
    }
    unint64_t v22 = v21 | (2 * v13);
    unint64_t v23 = vcvtps_u32_f32(v19 / v20);
    if (v22 <= v23) {
      size_t v24 = v23;
    }
    else {
      size_t v24 = v22;
    }
    sub_1CC9B3D48((uint64_t)v11, v24);
    unint64_t v13 = *(void *)(a1 + 32);
    if ((v13 & (v13 - 1)) != 0)
    {
      if (v13 <= v12) {
        unint64_t v5 = v12 % v13;
      }
      else {
        unint64_t v5 = v12;
      }
    }
    else
    {
      unint64_t v5 = (v13 - 1) & v12;
    }
  }
  uint64_t v25 = *v11;
  uint64_t v26 = *(void **)(*v11 + 8 * v5);
  if (v26)
  {
    *uint64_t v18 = *v26;
LABEL_38:
    void *v26 = v18;
    goto LABEL_39;
  }
  uint64_t v27 = *(void *)(a1 + 40);
  *uint64_t v18 = v27;
  *(void *)(a1 + 40) = v18;
  *(void *)(v25 + 8 * v5) = a1 + 40;
  if (v27)
  {
    unint64_t v28 = *(void *)(v27 + 8);
    if ((v13 & (v13 - 1)) != 0)
    {
      if (v28 >= v13) {
        v28 %= v13;
      }
    }
    else
    {
      v28 &= v13 - 1;
    }
    uint64_t v26 = (void *)(*v11 + 8 * v28);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 48);
LABEL_40:
  uint64_t result = *(void *)(a1 + 104);
  if (result)
  {
    uint64_t v30 = *(void *)(a1 + 120);
    if (v30)
    {
      uint64_t v31 = (void *)(*(void *)(a1 + 112) + 16);
      uint64_t v32 = 24 * v30;
      uint64_t v33 = &unk_1CFC290E7;
      while (*((_DWORD *)v31 - 4) != a2)
      {
        v31 += 3;
        v32 -= 24;
        if (!v32)
        {
          unint64_t v34 = 0;
          goto LABEL_50;
        }
      }
      uint64_t v36 = *(v31 - 1);
      unint64_t v35 = *v31;
      uint64_t v37 = 4;
      if (v35 < 4) {
        uint64_t v37 = v35;
      }
      uint64_t v33 = (void *)(v36 + v37);
      unint64_t v34 = v35 - v37;
    }
    else
    {
      unint64_t v34 = 0;
      uint64_t v33 = &unk_1CFC290E7;
    }
LABEL_50:
    uint64_t v38 = *(void *)(a1 + 104);
    (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)result + 208))(result, "Attribute", 9);
    (*(void (**)(void, const char *, uint64_t, uint64_t))(**(void **)(a1 + 104) + 24))(*(void *)(a1 + 104), "Tag", 3, a2);
    (*(void (**)(void, const char *, uint64_t, uint64_t))(**(void **)(a1 + 104) + 24))(*(void *)(a1 + 104), "Value", 5, a3);
    if (v34) {
      (*(void (**)(void, const char *, uint64_t, void *, unint64_t))(**(void **)(a1 + 104) + 192))(*(void *)(a1 + 104), "TagName", 7, v33, v34);
    }
    if (a5) {
      (*(void (**)(void, const char *, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 104) + 192))(*(void *)(a1 + 104), "Description", 11, a4, a5);
    }
    return (*(uint64_t (**)(uint64_t))(*(void *)v38 + 216))(v38);
  }
  return result;
}

uint64_t llvm::ELFAttributeParser::integerAttribute@<X0>(llvm::ELFAttributeParser *this@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v7 = *((void *)this + 15);
  if (v7)
  {
    BOOL v8 = (void *)(*((void *)this + 14) + 16);
    uint64_t v9 = 24 * v7;
    while (*((_DWORD *)v8 - 4) != a2)
    {
      v8 += 3;
      v9 -= 24;
      if (!v9)
      {
        uint64_t v33 = &unk_1CFC290E7;
        unint64_t v10 = 0;
        goto LABEL_10;
      }
    }
    uint64_t v12 = *(v8 - 1);
    unint64_t v11 = *v8;
    uint64_t v13 = 4;
    if (v11 < 4) {
      uint64_t v13 = v11;
    }
    uint64_t v33 = (void *)(v12 + v13);
    unint64_t v10 = v11 - v13;
  }
  else
  {
    unint64_t v10 = 0;
    uint64_t v33 = &unk_1CFC290E7;
  }
LABEL_10:
  uint64_t ULEB128 = llvm::DataExtractor::getULEB128((uint64_t *)this + 16, (uint64_t *)this + 19, (void *)this + 20);
  unint64_t v15 = (uint64_t *)((char *)this + 24);
  unint64_t v16 = *((void *)this + 4);
  if (v16)
  {
    uint8x8_t v17 = (uint8x8_t)vcnt_s8((int8x8_t)v16);
    v17.i16[0] = vaddlv_u8(v17);
    if (v17.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v16 <= a2) {
        unint64_t v3 = a2 % v16;
      }
    }
    else
    {
      unint64_t v3 = (v16 - 1) & a2;
    }
    uint64_t v18 = *(uint64_t ***)(*v15 + 8 * v3);
    if (v18)
    {
      for (uint64_t i = *v18; i; uint64_t i = (uint64_t *)*i)
      {
        unint64_t v20 = i[1];
        if (v20 == a2)
        {
          if (*((_DWORD *)i + 4) == a2) {
            goto LABEL_49;
          }
        }
        else
        {
          if (v17.u32[0] > 1uLL)
          {
            if (v20 >= v16) {
              v20 %= v16;
            }
          }
          else
          {
            v20 &= v16 - 1;
          }
          if (v20 != v3) {
            break;
          }
        }
      }
    }
  }
  BOOL v21 = operator new(0x18uLL);
  v21[1] = a2;
  *((_DWORD *)v21 + 4) = a2;
  *((_DWORD *)v21 + 5) = ULEB128;
  float v22 = (float)(unint64_t)(*((void *)this + 6) + 1);
  float v23 = *((float *)this + 14);
  if (!v16 || (float)(v23 * (float)v16) < v22)
  {
    BOOL v24 = 1;
    if (v16 >= 3) {
      BOOL v24 = (v16 & (v16 - 1)) != 0;
    }
    unint64_t v25 = v24 | (2 * v16);
    unint64_t v26 = vcvtps_u32_f32(v22 / v23);
    if (v25 <= v26) {
      size_t v27 = v26;
    }
    else {
      size_t v27 = v25;
    }
    sub_1CC9B3D48((uint64_t)this + 24, v27);
    unint64_t v16 = *((void *)this + 4);
    if ((v16 & (v16 - 1)) != 0)
    {
      if (v16 <= a2) {
        unint64_t v3 = a2 % v16;
      }
      else {
        unint64_t v3 = a2;
      }
    }
    else
    {
      unint64_t v3 = (v16 - 1) & a2;
    }
  }
  uint64_t v28 = *v15;
  unint64_t v29 = *(void **)(*v15 + 8 * v3);
  if (v29)
  {
    *BOOL v21 = *v29;
LABEL_47:
    *unint64_t v29 = v21;
    goto LABEL_48;
  }
  uint64_t v30 = *((void *)this + 5);
  *BOOL v21 = v30;
  *((void *)this + 5) = v21;
  *(void *)(v28 + 8 * v3) = (char *)this + 40;
  if (v30)
  {
    unint64_t v31 = *(void *)(v30 + 8);
    if ((v16 & (v16 - 1)) != 0)
    {
      if (v31 >= v16) {
        v31 %= v16;
      }
    }
    else
    {
      v31 &= v16 - 1;
    }
    unint64_t v29 = (void *)(*v15 + 8 * v31);
    goto LABEL_47;
  }
LABEL_48:
  ++*((void *)this + 6);
LABEL_49:
  uint64_t result = *((void *)this + 13);
  if (result)
  {
    uint64_t v34 = *((void *)this + 13);
    (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)result + 208))(result, "Attribute", 9);
    (*(void (**)(void, const char *, uint64_t, uint64_t))(**((void **)this + 13) + 24))(*((void *)this + 13), "Tag", 3, a2);
    if (v10) {
      (*(void (**)(void, const char *, uint64_t, void *, unint64_t))(**((void **)this + 13) + 192))(*((void *)this + 13), "TagName", 7, v33, v10);
    }
    (*(void (**)(void, const char *, uint64_t, uint64_t))(**((void **)this + 13) + 16))(*((void *)this + 13), "Value", 5, ULEB128);
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v34 + 216))(v34);
  }
  *a3 = 0;
  return result;
}

uint64_t llvm::ELFAttributeParser::stringAttribute@<X0>(llvm::ELFAttributeParser *this@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = *((void *)this + 15);
  if (v6)
  {
    BOOL v8 = (void *)(*((void *)this + 14) + 16);
    uint64_t v9 = 24 * v6;
    while (*((_DWORD *)v8 - 4) != a2)
    {
      v8 += 3;
      v9 -= 24;
      if (!v9)
      {
        unint64_t v35 = &unk_1CFC290E7;
        uint64_t v7 = 0;
        goto LABEL_10;
      }
    }
    uint64_t v10 = 4;
    if (*v8 < 4uLL) {
      uint64_t v10 = *v8;
    }
    unint64_t v35 = (void *)(*(v8 - 1) + v10);
    uint64_t v7 = *v8 - v10;
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v35 = &unk_1CFC290E7;
  }
LABEL_10:
  CStrRef = llvm::DataExtractor::getCStrRef((uint64_t *)this + 16, (unint64_t *)this + 19, (void *)this + 20);
  uint64_t v13 = v12;
  uint8x8_t v14 = (uint64_t *)((char *)this + 64);
  unint64_t v15 = *((void *)this + 9);
  if (v15)
  {
    uint8x8_t v16 = (uint8x8_t)vcnt_s8((int8x8_t)v15);
    v16.i16[0] = vaddlv_u8(v16);
    if (v16.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v15 <= a2) {
        unint64_t v3 = a2 % v15;
      }
    }
    else
    {
      unint64_t v3 = (v15 - 1) & a2;
    }
    uint8x8_t v17 = *(uint64_t ***)(*v14 + 8 * v3);
    if (v17)
    {
      for (uint64_t i = *v17; i; uint64_t i = (uint64_t *)*i)
      {
        unint64_t v19 = i[1];
        if (v19 == a2)
        {
          if (*((_DWORD *)i + 4) == a2) {
            goto LABEL_64;
          }
        }
        else
        {
          if (v16.u32[0] > 1uLL)
          {
            if (v19 >= v15) {
              v19 %= v15;
            }
          }
          else
          {
            v19 &= v15 - 1;
          }
          if (v19 != v3) {
            break;
          }
        }
      }
    }
  }
  unint64_t v20 = operator new(0x28uLL);
  v20[1] = a2;
  *((_DWORD *)v20 + 4) = a2;
  v20[3] = CStrRef;
  v20[4] = v13;
  float v21 = (float)(unint64_t)(*((void *)this + 11) + 1);
  float v22 = *((float *)this + 24);
  if (!v15 || (float)(v22 * (float)v15) < v21)
  {
    BOOL v23 = 1;
    if (v15 >= 3) {
      BOOL v23 = (v15 & (v15 - 1)) != 0;
    }
    unint64_t v24 = v23 | (2 * v15);
    unint64_t v25 = vcvtps_u32_f32(v21 / v22);
    if (v24 <= v25) {
      size_t prime = v25;
    }
    else {
      size_t prime = v24;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v15 = *((void *)this + 9);
    }
    if (prime > v15) {
      goto LABEL_69;
    }
    if (prime < v15)
    {
      unint64_t v27 = vcvtps_u32_f32((float)*((unint64_t *)this + 11) / *((float *)this + 24));
      if (v15 < 3 || (uint8x8_t v28 = (uint8x8_t)vcnt_s8((int8x8_t)v15), v28.i16[0] = vaddlv_u8(v28), v28.u32[0] > 1uLL))
      {
        unint64_t v27 = std::__next_prime(v27);
      }
      else
      {
        uint64_t v29 = 1 << -(char)__clz(v27 - 1);
        if (v27 >= 2) {
          unint64_t v27 = v29;
        }
      }
      if (prime <= v27) {
        size_t prime = v27;
      }
      if (prime < v15) {
LABEL_69:
      }
        sub_1CD3F1760((uint64_t)this + 64, prime);
    }
    unint64_t v15 = *((void *)this + 9);
    if ((v15 & (v15 - 1)) != 0)
    {
      if (v15 <= a2) {
        unint64_t v3 = a2 % v15;
      }
      else {
        unint64_t v3 = a2;
      }
    }
    else
    {
      unint64_t v3 = (v15 - 1) & a2;
    }
  }
  uint64_t v30 = *v14;
  unint64_t v31 = *(void **)(*v14 + 8 * v3);
  if (v31)
  {
    *unint64_t v20 = *v31;
LABEL_62:
    *unint64_t v31 = v20;
    goto LABEL_63;
  }
  uint64_t v32 = *((void *)this + 10);
  *unint64_t v20 = v32;
  *((void *)this + 10) = v20;
  *(void *)(v30 + 8 * v3) = (char *)this + 80;
  if (v32)
  {
    unint64_t v33 = *(void *)(v32 + 8);
    if ((v15 & (v15 - 1)) != 0)
    {
      if (v33 >= v15) {
        v33 %= v15;
      }
    }
    else
    {
      v33 &= v15 - 1;
    }
    unint64_t v31 = (void *)(*v14 + 8 * v33);
    goto LABEL_62;
  }
LABEL_63:
  ++*((void *)this + 11);
LABEL_64:
  uint64_t result = *((void *)this + 13);
  if (result)
  {
    uint64_t v37 = *((void *)this + 13);
    (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)result + 208))(result, "Attribute", 9);
    (*(void (**)(void, const char *, uint64_t, uint64_t))(**((void **)this + 13) + 24))(*((void *)this + 13), "Tag", 3, a2);
    if (v7) {
      (*(void (**)(void, const char *, uint64_t, void *, uint64_t))(**((void **)this + 13) + 192))(*((void *)this + 13), "TagName", 7, v35, v7);
    }
    (*(void (**)(void, const char *, uint64_t, void *, uint64_t))(**((void **)this + 13) + 192))(*((void *)this + 13), "Value", 5, CStrRef, v13);
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v37 + 216))(v37);
  }
  *a3 = 0;
  return result;
}

void llvm::ELFAttributeParser::parseSubsection(llvm::ELFAttributeParser *this@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  v51[1] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (unint64_t *)((char *)this + 152);
  uint64_t v7 = *((void *)this + 19);
  BOOL v8 = (void *)((char *)this + 128);
  uint64_t v9 = (void *)((char *)this + 160);
  CStrRef = (uint64_t *)llvm::DataExtractor::getCStrRef((uint64_t *)this + 16, (unint64_t *)this + 19, (void *)this + 20);
  uint64_t v47 = CStrRef;
  uint64_t v48 = v10;
  uint64_t v12 = *(v6 - 6);
  if (v12)
  {
    uint64_t v13 = v10;
    (*(void (**)(uint64_t, const char *, uint64_t, uint64_t))(*(void *)v12 + 24))(v12, "SectionLength", 13, a2);
    (*(void (**)(void, const char *, uint64_t, uint64_t *, uint64_t))(**((void **)this + 13) + 192))(*((void *)this + 13), "Vendor", 6, CStrRef, v13);
  }
  llvm::StringRef::lower((llvm::StringRef *)&v47, &v42);
  int v14 = SHIBYTE(v44);
  unint64_t v15 = (char *)v42;
  if (SHIBYTE(v44) >= 0) {
    uint8x8_t v16 = &v42;
  }
  else {
    uint8x8_t v16 = (const char **)v42;
  }
  if (SHIBYTE(v44) >= 0) {
    size_t v17 = HIBYTE(v44) & 0x7F;
  }
  else {
    size_t v17 = v43;
  }
  if (v17 == *((void *)this + 2))
  {
    if (!v17)
    {
      BOOL v18 = 0;
      if ((SHIBYTE(v44) & 0x80000000) == 0) {
        goto LABEL_15;
      }
      goto LABEL_14;
    }
    BOOL v18 = memcmp(v16, *((const void **)this + 1), v17) != 0;
    if (v14 < 0) {
LABEL_14:
    }
      operator delete(v15);
  }
  else
  {
    BOOL v18 = 1;
    if (SHIBYTE(v44) < 0) {
      goto LABEL_14;
    }
  }
LABEL_15:
  if (v18)
  {
    unint64_t v31 = std::generic_category();
    __int16 v46 = 1283;
    unsigned int v42 = "unrecognized vendor-name: ";
    uint64_t v44 = v47;
    uint64_t v45 = v48;
    goto LABEL_52;
  }
  unint64_t v19 = v7 + a2 - 4;
  while (1)
  {
    if (*v6 >= v19)
    {
      *a3 = 0;
      return;
    }
    unsigned int v20 = sub_1CD05EA24(v8, v6, v9);
    uint64_t v21 = sub_1CD8337FC((uint64_t)v8, v6, v9);
    if (*v9) {
      break;
    }
    uint64_t v22 = v21;
    uint64_t v23 = *((void *)this + 13);
    if (v23)
    {
      sub_1CD8371F0(v23, v20);
      (*(void (**)(void, const char *, uint64_t, uint64_t))(**((void **)this + 13) + 24))(*((void *)this + 13), "Size", 4, v22);
    }
    if (v22 <= 4)
    {
      unint64_t v31 = std::generic_category();
      v36[0] = "invalid attribute size ";
      unint64_t v37 = v22;
      __int16 v38 = 2051;
      v39[0] = v36;
      int v40 = " at offset 0x";
      __int16 v41 = 770;
      uint64_t v49 = (void *)(*v6 - 5);
      unsigned int v42 = (const char *)v39;
      uint64_t v44 = (uint64_t *)&v49;
      __int16 v46 = 3586;
LABEL_52:
      sub_1CD4FF4BC(22, (uint64_t)v31, (llvm::Twine *)&v42);
    }
    uint64_t v49 = v51;
    long long v50 = xmmword_1CD96EEC0;
    if (v20 == 1)
    {
      unint64_t v24 = a3;
      uint64_t v32 = 0;
      unint64_t v33 = 0;
      unint64_t v25 = "FileAttributes";
      uint64_t v26 = 14;
    }
    else
    {
      if (v20 == 2)
      {
        unint64_t v24 = a3;
        uint64_t v32 = 8;
        unint64_t v33 = "Sections";
        unint64_t v25 = "SectionAttributes";
        uint64_t v26 = 17;
      }
      else
      {
        if (v20 != 3)
        {
          uint64_t v30 = std::generic_category();
          uint64_t v35 = v20;
          v36[0] = "unrecognized tag 0x";
          unint64_t v37 = (unint64_t)&v35;
          __int16 v38 = 3587;
          v39[0] = v36;
          int v40 = " at offset 0x";
          __int16 v41 = 770;
          uint64_t v34 = *v6 - 5;
          unsigned int v42 = (const char *)v39;
          uint64_t v44 = &v34;
          __int16 v46 = 3586;
          sub_1CD4FF4BC(22, (uint64_t)v30, (llvm::Twine *)&v42);
        }
        unint64_t v24 = a3;
        uint64_t v32 = 7;
        unint64_t v33 = "Symbols";
        unint64_t v25 = "SymbolAttributes";
        uint64_t v26 = 16;
      }
      llvm::ELFAttributeParser::parseIndexList((uint64_t *)this, &v49);
    }
    size_t v27 = *((void *)this + 13);
    if (v27)
    {
      unsigned int v42 = (const char *)&unk_1F2618938;
      size_t v43 = v27;
      (*(void (**)(size_t, const char *, uint64_t))(*(void *)v27 + 208))(v27, v25, v26);
      if ((void)v50) {
        (*(void (**)(void, const char *, uint64_t, void *))(**((void **)this + 13) + 136))(*((void *)this + 13), v33, v32, v49);
      }
      a3 = v24;
      llvm::ELFAttributeParser::parseAttributeList((uint64_t *)this, v22 - 5, v24);
      uint64_t v29 = *v24;
      unsigned int v42 = (const char *)&unk_1F2618938;
      if (v29)
      {
        if (v43) {
          (*(void (**)(void))(*(void *)v43 + 216))();
        }
        BOOL v28 = 1;
      }
      else
      {
        if (v43) {
          (*(void (**)(void))(*(void *)v43 + 216))();
        }
        BOOL v28 = 0;
      }
    }
    else
    {
      a3 = v24;
      llvm::ELFAttributeParser::parseAttributeList((uint64_t *)this, v22 - 5, v24);
      BOOL v28 = *v24 != 0;
    }
    if (v49 != v51) {
      free(v49);
    }
    if (v28) {
      return;
    }
  }
  *a3 = *v9;
  void *v9 = 0;
}

uint64_t llvm::ELFAttrs::attrTypeFromString(_DWORD *__s2, size_t __n, uint64_t a3, uint64_t a4)
{
  if (__n >= 4)
  {
    unint64_t v6 = 4 * (*__s2 != 1600610644);
    if (!a4)
    {
LABEL_13:
      uint64_t v10 = 0;
      uint64_t v11 = 0;
      return v11 | v10;
    }
  }
  else
  {
    unint64_t v6 = 4;
    if (!a4) {
      goto LABEL_13;
    }
  }
  uint64_t v7 = (unint64_t *)(a3 + 16);
  uint64_t v8 = 24 * a4;
  while (1)
  {
    unint64_t v9 = *v7 >= v6 ? v6 : *v7;
    if (*v7 - v9 == __n && (!__n || !memcmp((const void *)(*(v7 - 1) + v9), __s2, __n))) {
      break;
    }
    v7 += 3;
    v8 -= 24;
    if (!v8) {
      goto LABEL_13;
    }
  }
  uint64_t v11 = *((unsigned int *)v7 - 4);
  uint64_t v10 = 0x100000000;
  return v11 | v10;
}

llvm::raw_ostream *llvm::logAllUnhandledErrors(llvm::raw_ostream *result, llvm::raw_ostream *a2, uint64_t a3)
{
  if (*(void *)result)
  {
    unint64_t v5 = (char **)result;
    unint64_t v6 = llvm::Twine::printOneChild(result, a2, *(void *)a3, *(void *)(a3 + 8), *(unsigned char *)(a3 + 32));
    uint64_t result = llvm::Twine::printOneChild(v6, a2, *(void *)(a3 + 16), *(void *)(a3 + 24), *(unsigned char *)(a3 + 33));
    uint64_t v7 = *v5;
    *unint64_t v5 = 0;
    size_t v17 = a2;
    if (v7)
    {
      if ((*(unsigned int (**)(char *, void *))(*(void *)v7 + 48))(v7, &llvm::ErrorList::ID))
      {
        uint64_t v10 = (uint64_t *)*((void *)v7 + 1);
        uint64_t v11 = (uint64_t *)*((void *)v7 + 2);
        if (v10 == v11)
        {
          uint64_t v12 = 0;
        }
        else
        {
          uint64_t v12 = 0;
          do
          {
            uint64_t v21 = v12;
            uint64_t v13 = *v10;
            *uint64_t v10 = 0;
            uint64_t v19 = v13;
            sub_1CD0644B0(&v20, &v19, &v17);
            sub_1CD451630(&v21, &v20, &v22);
            uint64_t v12 = v22;
            uint64_t v22 = 0;
            if (v20) {
              (*(void (**)(char *))(*(void *)v20 + 8))(v20);
            }
            uint64_t v14 = v19;
            uint64_t v19 = 0;
            if (v14) {
              (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
            }
            if (v21) {
              (*(void (**)(char *))(*(void *)v21 + 8))(v21);
            }
            ++v10;
          }
          while (v10 != v11);
        }
        BOOL v18 = v12;
        return (llvm::raw_ostream *)(*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)v7 + 8))(v7, v8, v9);
      }
      else
      {
        uint64_t v22 = v7;
        sub_1CD0644B0(&v18, &v22, &v17);
        uint64_t result = (llvm::raw_ostream *)v22;
        if (v22) {
          return (llvm::raw_ostream *)(*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)v22 + 8))(v22, v15, v16);
        }
      }
    }
    else
    {
      BOOL v18 = 0;
    }
  }
  return result;
}

uint64_t llvm::inconvertibleErrorCode(llvm *this)
{
  if (!atomic_load_explicit(qword_1EBCFADD0, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EBCFADD0, (void *(*)(void))sub_1CD0645CC, (void (*)(void *))sub_1CD064614);
  }
  return 3;
}

uint64_t llvm::errorCodeToError@<X0>(llvm *this@<X0>, std::error_code a2@<0:X1, 8:X2>, void *a3@<X8>)
{
  if (this) {
    operator new();
  }
  uint64_t result = 0;
  *a3 = 0;
  return result;
}

uint64_t llvm::errorToErrorCode(char **a1)
{
  v15.__val_ = 0;
  v15.__cat_ = std::system_category();
  unint64_t v2 = *a1;
  *a1 = 0;
  uint64_t v14 = &v15;
  if (!v2)
  {
    uint64_t v16 = 0;
    goto LABEL_19;
  }
  if ((*(unsigned int (**)(char *, void *))(*(void *)v2 + 48))(v2, &llvm::ErrorList::ID))
  {
    unint64_t v3 = (uint64_t *)*((void *)v2 + 1);
    unsigned int v4 = (uint64_t *)*((void *)v2 + 2);
    if (v3 == v4)
    {
      unint64_t v5 = 0;
    }
    else
    {
      unint64_t v5 = 0;
      do
      {
        v11.__r_.__value_.__r.__words[0] = (std::string::size_type)v5;
        uint64_t v6 = *v3;
        *unint64_t v3 = 0;
        uint64_t v17 = v6;
        sub_1CD064750(&v18, &v17, (uint64_t **)&v14);
        sub_1CD451630(&v11.__r_.__value_.__l.__data_, &v18, v12);
        unint64_t v5 = v12[0];
        v12[0] = 0;
        if (v18) {
          (*(void (**)(char *))(*(void *)v18 + 8))(v18);
        }
        uint64_t v7 = v17;
        uint64_t v17 = 0;
        if (v7) {
          (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
        }
        if (v11.__r_.__value_.__r.__words[0]) {
          (*(void (**)(std::string::size_type))(*(void *)v11.__r_.__value_.__l.__data_ + 8))(v11.__r_.__value_.__r.__words[0]);
        }
        ++v3;
      }
      while (v3 != v4);
    }
    uint64_t v16 = v5;
    uint64_t v8 = *(void (**)(void))(*(void *)v2 + 8);
  }
  else
  {
    v12[0] = v2;
    sub_1CD064750(&v16, v12, (uint64_t **)&v14);
    if (!v12[0]) {
      goto LABEL_19;
    }
    uint64_t v8 = *(void (**)(void))(*(void *)v12[0] + 8);
  }
  v8();
LABEL_19:
  if (!atomic_load_explicit(qword_1EBCFADD0, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EBCFADD0, (void *(*)(void))sub_1CD0645CC, (void (*)(void *))sub_1CD064614);
  }
  if (v15.__cat_ == (const std::error_category *)qword_1EBCFADD0[0] && v15.__val_ == 3)
  {
    std::error_code::message(&v11, &v15);
    __int16 v13 = 260;
    v12[0] = (char *)&v11;
    llvm::report_fatal_error((llvm *)v12, (const llvm::Twine *)1);
  }
  return *(void *)&v15.__val_;
}

llvm::StringError *llvm::StringError::StringError(llvm::StringError *this, std::error_code a2, const llvm::Twine *a3)
{
  cat = a2.__cat_;
  uint64_t v4 = *(void *)&a2.__val_;
  *(void *)this = &unk_1F2644808;
  llvm::Twine::str(a3, (void *)this + 1);
  *((void *)this + 4) = v4;
  *((void *)this + 5) = cat;
  *((unsigned char *)this + 48) = 0;
  return this;
}

{
  const std::error_category *cat;
  uint64_t v4;

  cat = a2.__cat_;
  uint64_t v4 = *(void *)&a2.__val_;
  *(void *)this = &unk_1F2644808;
  llvm::Twine::str(a3, (void *)this + 1);
  *((void *)this + 4) = v4;
  *((void *)this + 5) = cat;
  *((unsigned char *)this + 48) = 0;
  return this;
}

llvm::StringError *llvm::StringError::StringError(llvm::StringError *this, const llvm::Twine *a2, std::error_code a3)
{
  cat = a3.__cat_;
  uint64_t v4 = *(void *)&a3.__val_;
  *(void *)this = &unk_1F2644808;
  llvm::Twine::str(a2, (void *)this + 1);
  *((void *)this + 4) = v4;
  *((void *)this + 5) = cat;
  *((unsigned char *)this + 48) = 1;
  return this;
}

{
  const std::error_category *cat;
  uint64_t v4;

  cat = a3.__cat_;
  uint64_t v4 = *(void *)&a3.__val_;
  *(void *)this = &unk_1F2644808;
  llvm::Twine::str(a2, (void *)this + 1);
  *((void *)this + 4) = v4;
  *((void *)this + 5) = cat;
  *((unsigned char *)this + 48) = 1;
  return this;
}

void llvm::report_fatal_error(uint64_t *a1)
{
  memset(v6, 0, sizeof(v6));
  sub_1CD490168((uint64_t)v4, (uint64_t)v6);
  uint64_t v3 = *a1;
  *a1 = 0;
  v2[16] = 257;
  llvm::logAllUnhandledErrors((llvm::raw_ostream *)&v3, (llvm::raw_ostream *)v4, (uint64_t)v2);
  sub_1CC950BC0(&v3);
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)v4);
  __int16 v5 = 260;
  v4[0] = v6;
  llvm::report_fatal_error((llvm *)v4, (const llvm::Twine *)1);
}

uint64_t LLVMGetErrorTypeId(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 40))();
}

void *LLVMConsumeError(void *a1)
{
  unint64_t v2 = a1;
  sub_1CD4515D0(&v2);
  uint64_t result = v2;
  if (v2) {
    return (void *)(*(uint64_t (**)(void *))(*v2 + 8))(v2);
  }
  return result;
}

void LLVMGetErrorMessage(uint64_t a1)
{
  uint64_t v1 = a1;
  sub_1CD4FB504(&v1, &v2);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  operator new[]();
}

uint64_t LLVMDisposeErrorMessage(uint64_t result)
{
  if (result) {
    JUMPOUT(0x1D25D9CB0);
  }
  return result;
}

void *LLVMGetStringErrorTypeId()
{
  return &llvm::StringError::ID;
}

void LLVMCreateStringError()
{
  if (!atomic_load_explicit(qword_1EBCFADD0, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EBCFADD0, (void *(*)(void))sub_1CD0645CC, (void (*)(void *))sub_1CD064614);
  }
  operator new();
}

BOOL sub_1CD064240(uint64_t a1, void *a2)
{
  return a2 == &llvm::ErrorInfoBase::ID;
}

void sub_1CD064254()
{
}

BOOL sub_1CD064268(uint64_t a1, void *a2)
{
  return a2 == &llvm::ECError::ID || a2 == &llvm::ErrorInfoBase::ID;
}

uint64_t sub_1CD064288(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_1CD0642EC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD064370(uint64_t a1)
{
  *(void *)a1 = &unk_1F2644808;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  JUMPOUT(0x1D25D9CE0);
}

BOOL sub_1CD0643E8(uint64_t a1, void *a2)
{
  return a2 == &llvm::StringError::ID || a2 == &llvm::ErrorInfoBase::ID;
}

void sub_1CD064408(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    __int16 v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = *--v4;
        uint64_t v6 = v7;
        *uint64_t v4 = 0;
        if (v7) {
          (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
        }
      }
      while (v4 != v2);
      __int16 v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1CD0644B0(void *a1, void *a2, llvm::raw_ostream **a3)
{
  uint64_t result = (*(uint64_t (**)(void, void *))(*(void *)*a2 + 48))(*a2, &llvm::ErrorInfoBase::ID);
  uint64_t v7 = *a2;
  *a2 = 0;
  if (result)
  {
    (*(void (**)(uint64_t, llvm::raw_ostream *))(*(void *)v7 + 16))(v7, *a3);
    uint64_t v8 = *a3;
    uint64_t v9 = (unsigned char *)*((void *)*a3 + 4);
    if (*((unsigned char **)*a3 + 3) == v9)
    {
      llvm::raw_ostream::write(v8, "\n", 1uLL);
    }
    else
    {
      unsigned char *v9 = 10;
      ++*((void *)v8 + 4);
    }
    *a1 = 0;
    uint64_t v10 = *(uint64_t (**)(uint64_t))(*(void *)v7 + 8);
    return v10(v7);
  }
  else
  {
    *a1 = v7;
  }
  return result;
}

void sub_1CD0645CC()
{
}

uint64_t sub_1CD064614(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1CD064644(std::error_category *a1)
{
  std::error_category::~error_category(a1);

  JUMPOUT(0x1D25D9CE0);
}

const char *sub_1CD06467C()
{
  return "Error";
}

void sub_1CD064688(int a1@<W1>, uint64_t a2@<X8>)
{
  if (a1 == 3)
  {
    uint64_t v3 = (char *)operator new(0x80uLL);
    *(void *)a2 = v3;
    *(_OWORD *)(a2 + 8) = xmmword_1CFB2E9F0;
    strcpy(v3, "Inconvertible error value. An error has occurred that could not be converted to a known std::error_code. Please file a bug.");
  }
  else if (a1 == 2)
  {
    strcpy((char *)a2, "A file error occurred.");
    *(unsigned char *)(a2 + 23) = 22;
  }
  else
  {
    *(unsigned char *)(a2 + 23) = 15;
    strcpy((char *)a2, "Multiple errors");
  }
}

uint64_t sub_1CD064750(void *a1, void *a2, uint64_t **a3)
{
  uint64_t result = (*(uint64_t (**)(void, void *))(*(void *)*a2 + 48))(*a2, &llvm::ErrorInfoBase::ID);
  uint64_t v7 = *a2;
  *a2 = 0;
  if (result)
  {
    uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 32))(v7);
    uint64_t v9 = *a3;
    uint64_t *v9 = v8;
    v9[1] = v10;
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 8))(v7);
    uint64_t v7 = 0;
  }
  *a1 = v7;
  return result;
}

void sub_1CD06481C()
{
}

void llvm::install_bad_alloc_error_handler(llvm *this, void (*a2)(void *, const char *, BOOL), void *a3)
{
  std::mutex::lock(&stru_1EA618778);
  off_1EA61F070 = this;
  qword_1EA61F078 = (uint64_t)a2;

  std::mutex::unlock(&stru_1EA618778);
}

void llvm::remove_bad_alloc_error_handler(llvm *this)
{
  std::mutex::lock(&stru_1EA618778);
  off_1EA61F070 = 0;
  qword_1EA61F078 = 0;

  std::mutex::unlock(&stru_1EA618778);
}

void sub_1CD064988()
{
}

void LLVMInstallFatalErrorHandler(uint64_t a1)
{
  std::mutex::lock(&stru_1EBCBE7D0);
  off_1EBD0C068 = sub_1CD064A04;
  qword_1EBD0C070 = a1;

  std::mutex::unlock(&stru_1EBCBE7D0);
}

uint64_t sub_1CD064A04(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

void LLVMResetFatalErrorHandler()
{
  std::mutex::lock(&stru_1EBCBE7D0);
  off_1EBD0C068 = 0;
  qword_1EBD0C070 = 0;

  std::mutex::unlock(&stru_1EBCBE7D0);
}

uint64_t sub_1CD064A60()
{
  v0 = (void (*)(void *))MEMORY[0x1E4FBA268];
  __cxa_atexit(MEMORY[0x1E4FBA268], &stru_1EBCBE7D0, &dword_1CB82C000);

  return __cxa_atexit(v0, &stru_1EA618778, &dword_1CB82C000);
}

BOOL sub_1CD064AD0(uint64_t a1, void *a2)
{
  return a2 == &llvm::RTTIRoot::ID;
}

double llvm::FileCollectorBase::FileCollectorBase(llvm::FileCollectorBase *this)
{
  *(void *)this = &unk_1F2644A18;
  *((void *)this + 1) = 850045863;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *(_OWORD *)((char *)this + 76) = 0u;
  *((_DWORD *)this + 23) = 8;
  return result;
}

void llvm::FileCollectorBase::~FileCollectorBase(llvm::FileCollectorBase *this)
{
  *(void *)this = &unk_1F2644A18;
  uint64_t v1 = (std::mutex *)((char *)this + 8);
  sub_1CC0D7CD8((uint64_t)this + 72);
  std::mutex::~mutex(v1);
}

void llvm::FileCollectorBase::addFile(llvm::FileCollectorBase *this, const llvm::Twine *a2)
{
  uint64_t v4 = (std::mutex *)((char *)this + 8);
  std::mutex::lock((std::mutex *)((char *)this + 8));
  llvm::Twine::str(a2, &__p);
  char v5 = v13;
  if (v13 >= 0) {
    size_t v6 = v13 & 0x7F;
  }
  else {
    size_t v6 = v12;
  }
  if (v6)
  {
    uint64_t v7 = v13 >= 0 ? (unsigned __int8 *)&__p : (unsigned __int8 *)__p;
    sub_1CC0D7F54((llvm::FileCollectorBase *)((char *)this + 72), v7, v6);
    char v5 = v13;
    if (v8)
    {
      if (v13 >= 0) {
        p_p = &__p;
      }
      else {
        p_p = __p;
      }
      if (v13 >= 0) {
        size_t v10 = v13 & 0x7F;
      }
      else {
        size_t v10 = v12;
      }
      (*(void (**)(llvm::FileCollectorBase *, void *, size_t))(*(void *)this + 16))(this, p_p, v10);
      char v5 = v13;
    }
  }
  if (v5 < 0) {
    operator delete(__p);
  }
  std::mutex::unlock(v4);
}

uint64_t llvm::FileCollectorBase::addDirectory(uint64_t a1, uint64_t a2)
{
  int v9 = 0;
  size_t v10 = std::system_category();
  llvm::vfs::getRealFileSystem(&v6);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, uint64_t *, int *))(*(void *)a1 + 24))(&v7, a1, a2, &v6, &v9);
  uint64_t v4 = v8;
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  uint64_t result = v6;
  if (v6)
  {
    if (atomic_fetch_add((atomic_uint *volatile)(v6 + 8), 0xFFFFFFFF) == 1) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  return result;
}

double llvm::FileCollector::FileCollector(uint64_t a1, long long *a2, long long *a3)
{
  *(void *)(a1 + 8) = 850045863;
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 76) = 0u;
  *(_DWORD *)(a1 + 92) = 8;
  *(void *)a1 = &unk_1F2644A48;
  long long v4 = *a2;
  *(void *)(a1 + 120) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 104) = v4;
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *(void *)a2 = 0;
  long long v5 = *a3;
  *(void *)(a1 + 144) = *((void *)a3 + 2);
  *(_OWORD *)(a1 + 128) = v5;
  *((void *)a3 + 1) = 0;
  *((void *)a3 + 2) = 0;
  *(void *)a3 = 0;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 174) = 0;
  *(void *)(a1 + 168) = 0;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 212) = 0u;
  *(_DWORD *)(a1 + 228) = 32;
  return result;
}

{
  double result;
  long long v4;
  long long v5;

  *(void *)(a1 + 8) = 850045863;
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 76) = 0u;
  *(_DWORD *)(a1 + 92) = 8;
  *(void *)a1 = &unk_1F2644A48;
  long long v4 = *a2;
  *(void *)(a1 + 120) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 104) = v4;
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *(void *)a2 = 0;
  long long v5 = *a3;
  *(void *)(a1 + 144) = *((void *)a3 + 2);
  *(_OWORD *)(a1 + 128) = v5;
  *((void *)a3 + 1) = 0;
  *((void *)a3 + 2) = 0;
  *(void *)a3 = 0;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 174) = 0;
  *(void *)(a1 + 168) = 0;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 212) = 0u;
  *(_DWORD *)(a1 + 228) = 32;
  return result;
}

void *sub_1CD064E8C(void *result, void *a2)
{
  if (result != a2)
  {
    uint64_t v3 = result;
    long long v4 = (void *)*result;
    if ((void *)*result == result + 3 || (void *)*a2 == a2 + 3)
    {
      if (result[2] < a2[1]) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      unint64_t v5 = result[1];
      if (a2[2] < v5) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      unint64_t v6 = a2[1];
      if (v5 >= v6) {
        uint64_t v7 = a2[1];
      }
      else {
        uint64_t v7 = result[1];
      }
      if (v7)
      {
        for (uint64_t i = 0; i != v7; ++i)
        {
          int v9 = (void *)*a2;
          char v10 = *(unsigned char *)(*result + i);
          *(unsigned char *)(*result + i) = *(unsigned char *)(*a2 + i);
          *((unsigned char *)v9 + i) = v10;
        }
        unint64_t v5 = result[1];
        unint64_t v6 = a2[1];
      }
      unint64_t v11 = v5 - v6;
      if (v5 > v6)
      {
        if (v7 != v5)
        {
          double result = memcpy((void *)(*a2 + v6), (const void *)(*result + v7), *result + v5 - (*result + v7));
          unint64_t v6 = a2[1];
        }
        a2[1] = v11 + v6;
        v3[1] = v7;
      }
      else
      {
        unint64_t v12 = v6 - v5;
        if (v6 > v5)
        {
          if (v7 != v6)
          {
            double result = memcpy((void *)(*result + v5), (const void *)(*a2 + v7), *a2 + v6 - (*a2 + v7));
            unint64_t v5 = v3[1];
          }
          v3[1] = v12 + v5;
          a2[1] = v7;
        }
      }
    }
    else
    {
      uint64_t v13 = result[1];
      uint64_t v14 = a2[1];
      void *result = *a2;
      result[1] = v14;
      *a2 = v4;
      a2[1] = v13;
      uint64_t v15 = result[2];
      result[2] = a2[2];
      a2[2] = v15;
    }
  }
  return result;
}

void llvm::FileCollector::addFileImpl(uint64_t a1, unsigned char *a2, uint64_t a3)
{
  v35[32] = *MEMORY[0x1E4F143B8];
  llvm::FileCollector::PathCanonicalizer::canonicalize(a1 + 208, a2, a3, (uint64_t)&v30);
  char v4 = *(unsigned char *)(a1 + 127);
  if (v4 >= 0) {
    unint64_t v5 = (const void *)(a1 + 104);
  }
  else {
    unint64_t v5 = *(const void **)(a1 + 104);
  }
  if (v4 >= 0) {
    size_t v6 = v4 & 0x7F;
  }
  else {
    size_t v6 = *(void *)(a1 + 112);
  }
  size_t v27 = v29;
  long long v28 = xmmword_1CD96DBF0;
  if (v6 >= 0x101) {
    llvm::SmallVectorBase<unsigned long long>::grow_pod();
  }
  uint64_t v7 = 0;
  if (v6)
  {
    memcpy(v29, v5, v6);
    uint64_t v7 = v28;
  }
  *(void *)&long long v28 = v7 + v6;
  char v8 = (char *)v30;
  unint64_t v9 = v31;
  llvm::sys::path::root_path((unint64_t)v30, v31, 0);
  __int16 v26 = 261;
  if (v9 >= v10) {
    unint64_t v11 = v10;
  }
  else {
    unint64_t v11 = v9;
  }
  unint64_t v24 = &v8[v11];
  uint64_t v25 = v9 - v11;
  __int16 v23 = 257;
  __int16 v21 = 257;
  _WORD v19[16] = 257;
  llvm::sys::path::append(&v27, 0, (const char **)&v24, v22, (uint64_t)v20, (uint64_t)v19);
  unint64_t v12 = (const char *)v33;
  uint64_t v13 = v34;
  uint64_t v15 = v27;
  uint64_t v14 = (void *)v28;
  __int16 v26 = 261;
  unint64_t v24 = (char *)v33;
  uint64_t v25 = v34;
  LOBYTE(v22[0]) = 0;
  int is_directory = llvm::sys::fs::is_directory((llvm::sys::fs *)&v24, (const llvm::Twine *)v22, v16);
  uint64_t v18 = a1 + 152;
  if (is_directory || !LOBYTE(v22[0]))
  {
    llvm::vfs::YAMLVFSWriter::addFileMapping(v18, (uint64_t)v12, v13, (uint64_t)v15, (uint64_t)v14);
  }
  else
  {
    unint64_t v24 = (char *)v12;
    uint64_t v25 = v13;
    v22[0] = v15;
    v22[1] = v14;
    v20[0] = 1;
    sub_1CD856114(v18, (uint64_t)&v24, (uint64_t)v22, v20);
  }
  if (v27 != v29) {
    free(v27);
  }
  if (v33 != v35) {
    free(v33);
  }
  if (v30 != &v32) {
    free(v30);
  }
}

void llvm::FileCollector::addDirectoryImpl(llvm::FileCollectorBase *a1@<X0>, const llvm::Twine *a2@<X1>, void *a3@<X2>, void *a4@<X3>, _OWORD *a5@<X8>)
{
  (*(void (**)(long long *__return_ptr))(*(void *)*a3 + 32))(&v21);
  if (*(_DWORD *)a4) {
    goto LABEL_16;
  }
  llvm::FileCollectorBase::addFile(a1, a2);
  if (*(_DWORD *)a4) {
    goto LABEL_16;
  }
  while (1)
  {
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    BOOL v10 = sub_1CD065CEC((uint64_t *)&v21, &v18);
    unint64_t v11 = v19;
    if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
    if (v10) {
      break;
    }
    if ((*(_DWORD *)(v21 + 32) - 2) <= 2)
    {
      uint64_t v12 = *(void *)(v21 + 8);
      char v13 = *(unsigned char *)(v21 + 31);
      int v14 = v13;
      if (v13 >= 0) {
        uint64_t v12 = v21 + 8;
      }
      uint64_t v15 = *(std::__shared_weak_count **)(v21 + 16);
      uint64_t v16 = (std::__shared_weak_count *)(v13 & 0x7F);
      if (v14 >= 0) {
        uint64_t v15 = v16;
      }
      __int16 v20 = 261;
      uint64_t v18 = v12;
      uint64_t v19 = v15;
      llvm::FileCollectorBase::addFile(a1, (const llvm::Twine *)&v18);
    }
    sub_1CD06540C(&v21, a4);
    if (*(_DWORD *)a4) {
      goto LABEL_16;
    }
  }
  if (*(_DWORD *)a4)
  {
LABEL_16:
    *a5 = v21;
  }
  else
  {
    (*(void (**)(void, const llvm::Twine *, void *))(*(void *)*a3 + 32))(*a3, a2, a4);
    uint64_t v17 = (std::__shared_weak_count *)*((void *)&v21 + 1);
    if (*((void *)&v21 + 1)
      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v21 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
}

void *sub_1CD06540C(void *a1, void *a2)
{
  *a2 = (*(uint64_t (**)(void))(*(void *)*a1 + 16))(*a1);
  a2[1] = v4;
  char v5 = *(unsigned char *)(*a1 + 31);
  int v6 = v5;
  uint64_t v7 = *(void *)(*a1 + 16);
  uint64_t v8 = v5 & 0x7F;
  if (v6 >= 0) {
    uint64_t v7 = v8;
  }
  if (!v7) {
    sub_1CC22C6DC(a1);
  }
  return a1;
}

unint64_t llvm::FileCollector::copyFiles(llvm::FileCollector *this, char a2)
{
  __int16 v46 = 260;
  uint64_t v44 = (unsigned __int8 *)this + 104;
  unint64_t directories = llvm::sys::fs::create_directories((void **)&v44, 1, 504);
  uint64_t v5 = directories;
  if (directories)
  {
    unint64_t v6 = HIDWORD(directories);
    return v5 | (v6 << 32);
  }
  uint64_t v7 = (std::mutex *)((char *)this + 8);
  std::mutex::lock((std::mutex *)((char *)this + 8));
  uint64_t v8 = *((void *)this + 19);
  uint64_t v9 = *((void *)this + 20);
  if (v8 != v9)
  {
    uint64_t v10 = v8 + 24;
    while (1)
    {
      *(_OWORD *)std::chrono::system_clock::time_point __t = 0u;
      memset(v40, 0, sizeof(v40));
      uint64_t v41 = 0xFFFFLL;
      __int16 v42 = 0;
      uint64_t v43 = 0;
      __int16 v46 = 260;
      uint64_t v44 = (unsigned __int8 *)(v10 - 24);
      unint64_t v11 = llvm::sys::fs::status((llvm::sys::fs *)&v44, (const llvm::Twine *)__t, (llvm::sys::fs::file_status *)1);
      unsigned int v12 = v11;
      unint64_t v6 = HIDWORD(v11);
      if (v11) {
        break;
      }
      if (v40[6] != 1)
      {
        char v14 = *(unsigned char *)(v10 + 23);
        BOOL v15 = v14 < 0;
        if (v14 >= 0) {
          uint64_t v16 = (unsigned __int8 *)v10;
        }
        else {
          uint64_t v16 = *(unsigned __int8 **)v10;
        }
        unint64_t v17 = v14 & 0x7F;
        if (v15) {
          unint64_t v18 = *(void *)(v10 + 8);
        }
        else {
          unint64_t v18 = v17;
        }
        unint64_t v19 = sub_1CD0E3AC0(v16, v18, 0);
        if (v18 >= v19) {
          unint64_t v20 = v19;
        }
        else {
          unint64_t v20 = v18;
        }
        if (v19 == -1) {
          unint64_t v20 = 0;
        }
        __int16 v46 = 261;
        if (v19 == -1) {
          long long v21 = 0;
        }
        else {
          long long v21 = v16;
        }
        uint64_t v44 = v21;
        unint64_t v45 = v20;
        unint64_t v22 = llvm::sys::fs::create_directories((void **)&v44, 1, 504);
        unsigned int v12 = v22;
        if v22 && (a2)
        {
          unint64_t v6 = HIDWORD(v22);
          goto LABEL_47;
        }
        if (v40[6] == 3)
        {
          __int16 v46 = 260;
          uint64_t v44 = (unsigned __int8 *)v10;
          unint64_t v24 = llvm::sys::fs::create_directories((void **)&v44, 1, 504);
          unsigned int v12 = v24;
          unint64_t v6 = HIDWORD(v24);
          if (v24) {
            break;
          }
        }
        else
        {
          __int16 v46 = 260;
          uint64_t v44 = (unsigned __int8 *)(v10 - 24);
          __int16 v38 = 260;
          *(void *)unint64_t v37 = v10;
          unint64_t v25 = llvm::sys::fs::copy_file((llvm::sys::fs *)&v44, (const llvm::Twine *)v37, v23);
          unsigned int v12 = v25;
          unint64_t v6 = HIDWORD(v25);
          if v25 && (a2) {
            goto LABEL_47;
          }
          __int16 v38 = 260;
          *(void *)unint64_t v37 = v10 - 24;
          int v47 = 0xFFFF;
          if (!llvm::sys::fs::status((llvm::sys::fs *)v37, (const llvm::Twine *)&v44, (llvm::sys::fs::file_status *)1))
          {
            __int16 v46 = 260;
            uint64_t v44 = (unsigned __int8 *)v10;
            unint64_t v26 = llvm::sys::fs::setPermissions((unsigned __int8 *)&v44, v47);
            unsigned int v12 = v26;
            unint64_t v6 = HIDWORD(v26);
            if (v26)
            {
              if (a2) {
                goto LABEL_47;
              }
            }
          }
          char v27 = *(unsigned char *)(v10 + 23);
          BOOL v28 = v27 < 0;
          uint64_t v29 = *(unsigned __int8 **)v10;
          if (v27 >= 0) {
            uint64_t v29 = (unsigned __int8 *)v10;
          }
          unint64_t v30 = v27 & 0x7F;
          if (v28) {
            unint64_t v30 = *(void *)(v10 + 8);
          }
          v37[0] = 0;
          __int16 v46 = 261;
          uint64_t v44 = v29;
          unint64_t v45 = v30;
          if (!llvm::sys::fs::openFile((unsigned __int8 *)&v44, (int *)v37, 2, 2, 0, 438))
          {
            unint64_t v31 = (llvm::sys::Process *)v37[0];
            uint64_t v32 = v40[0];
            uint64_t v33 = v32 + 1000 * std::chrono::system_clock::from_time_t(__t[0]).__d_.__rep_;
            uint64_t v34 = v40[1];
            v35.__d_.__rep_ = std::chrono::system_clock::from_time_t(__t[1]).__d_.__rep_;
            if (!llvm::sys::fs::setLastAccessAndModificationTime((int)v31, v33, v34 + 1000 * v35.__d_.__rep_)&& !llvm::sys::Process::SafelyCloseFileDescriptor(v31))
            {
              std::system_category();
            }
          }
        }
      }
LABEL_9:
      uint64_t v13 = v10 + 32;
      v10 += 56;
      if (v13 == v9) {
        goto LABEL_44;
      }
    }
    if (a2) {
      goto LABEL_47;
    }
    goto LABEL_9;
  }
  unint64_t v6 = 0;
LABEL_44:
  std::system_category();
  unsigned int v12 = 0;
LABEL_47:
  std::mutex::unlock(v7);
  uint64_t v5 = v12;
  return v5 | (v6 << 32);
}

unint64_t llvm::FileCollector::writeMapping(uint64_t a1, unsigned char *a2, uint64_t a3)
{
  v41[32] = *MEMORY[0x1E4F143B8];
  unint64_t v6 = (std::mutex *)(a1 + 8);
  std::mutex::lock((std::mutex *)(a1 + 8));
  char v7 = *(unsigned char *)(a1 + 151);
  int v8 = v7;
  if (v7 >= 0) {
    uint64_t v9 = (const std::string::value_type *)(a1 + 128);
  }
  else {
    uint64_t v9 = *(const std::string::value_type **)(a1 + 128);
  }
  std::string::size_type v10 = v7 & 0x7F;
  if (v8 >= 0) {
    std::string::size_type v11 = v10;
  }
  else {
    std::string::size_type v11 = *(void *)(a1 + 136);
  }
  sub_1CD838354(a1 + 152, v9, v11);
  char v12 = *(unsigned char *)(a1 + 151);
  BOOL v13 = v12 < 0;
  if (v12 >= 0) {
    char v14 = (void *)(a1 + 128);
  }
  else {
    char v14 = *(void **)(a1 + 128);
  }
  size_t v15 = v12 & 0x7F;
  if (v13) {
    size_t v16 = *(void *)(a1 + 136);
  }
  else {
    size_t v16 = v15;
  }
  __s1 = v14;
  uint64_t v32 = v16;
  uint64_t v39 = v41;
  long long v40 = xmmword_1CD96DBF0;
  if (v16 >= 0x101) {
    llvm::SmallVectorBase<unsigned long long>::grow_pod();
  }
  uint64_t v17 = 0;
  if (v16)
  {
    memcpy(v41, v14, v16);
    uint64_t v17 = v40;
  }
  *(void *)&long long v40 = v17 + v16;
  uint64_t v36 = v38;
  long long v37 = xmmword_1CD96DBF0;
  __s2 = v35;
  *(_OWORD *)size_t __n = xmmword_1CD96DBF0;
  __int16 v30 = 261;
  std::string __p = v14;
  size_t v28 = v16;
  if (llvm::sys::fs::real_path((unsigned __int8 *)&__p, &v39, 0)) {
    goto LABEL_33;
  }
  __s1 = v39;
  uint64_t v32 = v40;
  llvm::StringRef::upper((llvm::StringRef *)&__s1, &__p);
  char v18 = v29;
  if (v29 >= 0) {
    p_p = &__p;
  }
  else {
    p_p = __p;
  }
  if (v29 >= 0) {
    size_t v20 = v29 & 0x7F;
  }
  else {
    size_t v20 = v28;
  }
  *(void *)&long long v37 = 0;
  if (*((void *)&v37 + 1) < v20) {
    llvm::SmallVectorBase<unsigned long long>::grow_pod();
  }
  uint64_t v21 = 0;
  if (v20)
  {
    memcpy(v36, p_p, v20);
    uint64_t v21 = v37;
    char v18 = v29;
  }
  size_t v22 = v21 + v20;
  *(void *)&long long v37 = v22;
  if (v18 < 0)
  {
    operator delete(__p);
    size_t v22 = v37;
  }
  __int16 v30 = 261;
  std::string __p = v36;
  size_t v28 = v22;
  if (llvm::sys::fs::real_path((unsigned __int8 *)&__p, &__s2, 0)
    || v32 != __n[0]
    || __n[0] && memcmp(__s1, __s2, __n[0]))
  {
LABEL_33:
    char v23 = 1;
  }
  else
  {
    char v23 = 0;
  }
  if (__s2 != v35) {
    free(__s2);
  }
  if (v36 != v38) {
    free(v36);
  }
  if (v39 != v41) {
    free(v39);
  }
  if (!*(unsigned char *)(a1 + 177)) {
    *(unsigned char *)(a1 + 177) = 1;
  }
  *(unsigned char *)(a1 + 176) = v23;
  if (!*(unsigned char *)(a1 + 181)) {
    *(unsigned char *)(a1 + 181) = 1;
  }
  *(unsigned char *)(a1 + 180) = 0;
  LODWORD(v36) = 0;
  *(void *)&long long v37 = std::system_category();
  llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)&v39, a2, a3, (uint64_t)&v36, 3);
  if (v36)
  {
    unint64_t v25 = (unint64_t)v36 & 0xFFFFFFFF00000000;
    uint64_t v24 = v36;
  }
  else
  {
    llvm::vfs::YAMLVFSWriter::write((llvm::vfs::YAMLVFSWriter *)(a1 + 152), (llvm::raw_ostream *)&v39);
    std::system_category();
    uint64_t v24 = 0;
    unint64_t v25 = 0;
  }
  llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)&v39);
  std::mutex::unlock(v6);
  return v25 | v24;
}

void llvm::FileCollector::createCollectorVFS()
{
}

uint64_t sub_1CD065B54(uint64_t a1)
{
  *(void *)a1 = &unk_1F2644A48;
  sub_1CCB7ABD0(a1 + 208);
  if (*(char *)(a1 + 207) < 0) {
    operator delete(*(void **)(a1 + 184));
  }
  uint64_t v3 = (void **)(a1 + 152);
  sub_1CD06622C(&v3);
  if (*(char *)(a1 + 151) < 0) {
    operator delete(*(void **)(a1 + 128));
  }
  if (*(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }
  *(void *)a1 = &unk_1F2644A18;
  sub_1CC0D7CD8(a1 + 72);
  std::mutex::~mutex((std::mutex *)(a1 + 8));
  return a1;
}

void sub_1CD065C10(uint64_t a1)
{
  *(void *)a1 = &unk_1F2644A48;
  sub_1CCB7ABD0(a1 + 208);
  if (*(char *)(a1 + 207) < 0) {
    operator delete(*(void **)(a1 + 184));
  }
  uint64_t v2 = (void **)(a1 + 152);
  sub_1CD06622C(&v2);
  if (*(char *)(a1 + 151) < 0) {
    operator delete(*(void **)(a1 + 128));
  }
  if (*(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }
  *(void *)a1 = &unk_1F2644A18;
  sub_1CC0D7CD8(a1 + 72);
  std::mutex::~mutex((std::mutex *)(a1 + 8));

  JUMPOUT(0x1D25D9CE0);
}

BOOL sub_1CD065CEC(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *a2;
  BOOL result = (*a1 | *a2) == 0;
  if (v2) {
    BOOL v5 = v3 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    int v8 = *(const void **)(v2 + 8);
    uint64_t v6 = v2 + 8;
    char v7 = v8;
    char v9 = *(unsigned char *)(v6 + 23);
    if (v9 >= 0) {
      std::string::size_type v10 = (const void *)v6;
    }
    else {
      std::string::size_type v10 = v7;
    }
    size_t v11 = *(void *)(v6 + 8);
    if (v9 >= 0) {
      size_t v12 = v9 & 0x7F;
    }
    else {
      size_t v12 = v11;
    }
    size_t v15 = *(const void **)(v3 + 8);
    uint64_t v13 = v3 + 8;
    char v14 = v15;
    char v16 = *(unsigned char *)(v13 + 23);
    if (v16 >= 0) {
      uint64_t v17 = (const void *)v13;
    }
    else {
      uint64_t v17 = v14;
    }
    uint64_t v18 = *(void *)(v13 + 8);
    if (v16 >= 0) {
      uint64_t v18 = v16 & 0x7F;
    }
    if (v12 == v18) {
      return !v12 || memcmp(v10, v17, v12) == 0;
    }
    else {
      return 0;
    }
  }
  return result;
}

void *sub_1CD065D8C(void *a1)
{
  *a1 = &unk_1F2644A78;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (atomic_uint *)a1[2];
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 8))(v3);
  }
  return a1;
}

void sub_1CD065E54(void *a1)
{
  *a1 = &unk_1F2644A78;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (atomic_uint *)a1[2];
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 8))(v3);
  }

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD065F3C(uint64_t a1@<X0>, const llvm::Twine *a2@<X1>, uint64_t a3@<X8>)
{
  (*(void (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
  if ((*(unsigned char *)(a3 + 80) & 1) == 0 && *(_DWORD *)(a3 + 64) >= 2u)
  {
    uint64_t v6 = *(llvm::FileCollectorBase **)(a1 + 24);
    llvm::FileCollectorBase::addFile(v6, a2);
  }
}

void sub_1CD065FD0(uint64_t a1@<X0>, const llvm::Twine *a2@<X1>, uint64_t a3@<X8>)
{
  (*(void (**)(void))(**(void **)(a1 + 16) + 24))(*(void *)(a1 + 16));
  if ((*(unsigned char *)(a3 + 16) & 1) == 0 && *(void *)a3)
  {
    uint64_t v6 = *(llvm::FileCollectorBase **)(a1 + 24);
    llvm::FileCollectorBase::addFile(v6, a2);
  }
}

uint64_t sub_1CD066060(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v7 = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v5 + 8), 1u, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t))(*(void *)v4 + 24))(v4, a2, &v7, a3);
  uint64_t result = v7;
  if (v7)
  {
    if (atomic_fetch_add((atomic_uint *volatile)(v7 + 8), 0xFFFFFFFF) == 1) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  return result;
}

uint64_t sub_1CD066108(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 40))();
}

uint64_t sub_1CD066130(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 48))();
}

uint64_t sub_1CD066158(uint64_t a1, const llvm::Twine *a2, void *a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 56))(*(void *)(a1 + 16));
  if (!v6)
  {
    llvm::FileCollectorBase::addFile(*(llvm::FileCollectorBase **)(a1 + 24), a2);
    uint64_t v7 = a3[1];
    if (v7)
    {
      int v8 = *(llvm::FileCollectorBase **)(a1 + 24);
      __int16 v11 = 261;
      v10[0] = *a3;
      v10[1] = v7;
      llvm::FileCollectorBase::addFile(v8, (const llvm::Twine *)v10);
    }
  }
  return v6;
}

uint64_t sub_1CD066204(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 80))();
}

void sub_1CD06622C(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        uint64_t v4 = sub_1CD3C4FA4(v4 - 56);
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t llvm::DiffFilesWithTolerance(std::string::size_type a1, std::string::size_type a2, std::string::size_type a3, std::string::size_type a4, uint64_t a5, double a6, double a7)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  __int16 v34 = 261;
  v33.__r_.__value_.__r.__words[0] = a1;
  v33.__r_.__value_.__l.__size_ = a2;
  sub_1CD096690((unsigned __int8 *)&v33, (llvm::WritableMemoryBuffer *)0xFFFFFFFFFFFFFFFFLL, 0, 0, 1, 0, (uint64_t)&v37);
  char v12 = v38;
  if (v38)
  {
    uint64_t v13 = *(void **)&v37.__val_;
    std::error_code v35 = v37;
    if (v37.__val_)
    {
      if (a5)
      {
        std::error_code::message(&v33, &v35);
        if (*(char *)(a5 + 23) < 0) {
          operator delete(*(void **)a5);
        }
        *(std::string *)a5 = v33;
      }
      return 2;
    }
  }
  else
  {
    std::system_category();
    uint64_t v13 = *(void **)&v37.__val_;
  }
  __int16 v34 = 261;
  v33.__r_.__value_.__r.__words[0] = a3;
  v33.__r_.__value_.__l.__size_ = a4;
  sub_1CD096690((unsigned __int8 *)&v33, (llvm::WritableMemoryBuffer *)0xFFFFFFFFFFFFFFFFLL, 0, 0, 1, 0, (uint64_t)&v35);
  int v15 = v36;
  if ((v36 & 1) == 0)
  {
    std::system_category();
    char v16 = *(void **)&v35.__val_;
    goto LABEL_17;
  }
  char v16 = *(void **)&v35.__val_;
  std::error_code v32 = v35;
  if (!v35.__val_)
  {
LABEL_17:
    uint64_t v18 = (unsigned char *)v13[1];
    uint64_t v17 = (std::string::value_type *)v13[2];
    size_t v20 = (unsigned char *)v16[1];
    unint64_t v19 = (char *)v16[2];
    v33.__r_.__value_.__r.__words[0] = (std::string::size_type)v18;
    *(void *)&v32.__val_ = v20;
    if (v17 - v18 != v19 - v20 || memcmp(v18, v20, v17 - v18))
    {
      if (a6 == 0.0 && a7 == 0.0)
      {
        if (a5) {
          MEMORY[0x1D25D9630](a5, "Files differ without tolerance allowance");
        }
        uint64_t v14 = 1;
        goto LABEL_51;
      }
      while (1)
      {
        char v23 = (std::string::value_type *)v33.__r_.__value_.__r.__words[0];
        uint64_t v24 = *(char **)&v32.__val_;
        if (v33.__r_.__value_.__r.__words[0] >= (unint64_t)v17) {
          break;
        }
        int v31 = v15;
        uint64_t v21 = &v17[-v33.__r_.__value_.__r.__words[0]];
        size_t v22 = *(char **)&v32.__val_;
        while (1)
        {
          if (v22 >= v19)
          {
            uint64_t v24 = v22;
            goto LABEL_33;
          }
          if (*v23 != *v22) {
            break;
          }
          ++v23;
          ++v22;
          if (!--v21)
          {
            uint64_t v24 = &v17[*(void *)&v32.__val_ - v33.__r_.__value_.__r.__words[0]];
            char v23 = v17;
LABEL_33:
            LOBYTE(v15) = v31;
            goto LABEL_34;
          }
        }
        v33.__r_.__value_.__r.__words[0] = (std::string::size_type)sub_1CD0666C0(v23, (unint64_t)v18);
        *(void *)&v32.__val_ = sub_1CD0666C0(v22, (unint64_t)v20);
        uint64_t v14 = 1;
        int v15 = v31;
        if (sub_1CD0667B0(&v33.__r_.__value_.__l.__data_, (const char **)&v32, v17, v19, (std::string *)a5, a6, a7)) {
          goto LABEL_51;
        }
      }
LABEL_34:
      v33.__r_.__value_.__r.__words[0] = (std::string::size_type)v23;
      *(void *)&v32.__val_ = v24;
      if (v23 < v17 || v24 < v19)
      {
        if (v23 >= v17)
        {
          int v26 = *(v23 - 1);
          if ((v26 - 48) < 0xA
            || v26 == 46
            || v26 == 43
            || *(v23 - 1) == 45
            || ((v26 - 68) & 0xFFFFFFDE) == 0)
          {
            v33.__r_.__value_.__r.__words[0] = (std::string::size_type)--v23;
          }
        }
        if (v24 >= v19)
        {
          int v27 = *(v24 - 1);
          if ((v27 - 48) < 0xA
            || v27 == 46
            || v27 == 43
            || *(v24 - 1) == 45
            || ((v27 - 68) & 0xFFFFFFDE) == 0)
          {
            *(void *)&v32.__val_ = --v24;
          }
        }
        v33.__r_.__value_.__r.__words[0] = (std::string::size_type)sub_1CD0666C0(v23, (unint64_t)v18);
        *(void *)&v32.__val_ = sub_1CD0666C0(v24, (unint64_t)v20);
        unsigned int v28 = sub_1CD0667B0(&v33.__r_.__value_.__l.__data_, (const char **)&v32, v17, v19, (std::string *)a5, a6, a7);
        if (v33.__r_.__value_.__r.__words[0] >= (unint64_t)v17
          && *(void *)&v32.__val_ >= (unint64_t)v19)
        {
          uint64_t v14 = v28;
        }
        else
        {
          uint64_t v14 = 1;
        }
        goto LABEL_51;
      }
    }
    uint64_t v14 = 0;
LABEL_51:
    if ((v15 & 1) == 0 && v16) {
      (*(void (**)(void *))(*v16 + 8))(v16);
    }
    goto LABEL_54;
  }
  if (a5)
  {
    std::error_code::message(&v33, &v32);
    if (*(char *)(a5 + 23) < 0) {
      operator delete(*(void **)a5);
    }
    *(std::string *)a5 = v33;
  }
  uint64_t v14 = 2;
LABEL_54:
  if ((v12 & 1) == 0 && v13) {
    (*(void (**)(void *))(*v13 + 8))(v13);
  }
  return v14;
}

unsigned char *sub_1CD0666C0(unsigned char *result, unint64_t a2)
{
  int v2 = (char)*result;
  if ((v2 - 48) < 0xA || v2 == 46 || v2 == 43 || *result == 45)
  {
    if ((unint64_t)result <= a2) {
      return result;
    }
    goto LABEL_3;
  }
  if ((unint64_t)result > a2 && ((v2 - 68) & 0xFFFFFFDE) == 0)
  {
LABEL_3:
    unsigned __int8 v3 = 0;
    for (uint64_t i = result - 1; ; --i)
    {
      int v5 = (char)*i;
      if ((v5 - 48) >= 0xA && v5 != 46)
      {
        if (v5 == 43 || *i == 45) {
          goto LABEL_7;
        }
        if (((v5 - 68) & 0xFFFFFFDE) != 0) {
          return i + 1;
        }
      }
      if (((v5 == 46) & v3) != 0) {
        return result;
      }
      v3 |= v5 == 46;
LABEL_7:
      --result;
      if ((unint64_t)i <= a2) {
        return result;
      }
      if ((v5 == 45 || *i == 43) && (((char)*(i - 1) - 68) & 0xFFFFFFDE) != 0) {
        return i;
      }
    }
  }
  return result;
}

uint64_t sub_1CD0667B0(std::string::value_type **a1, const char **a2, std::string::value_type *a3, char *a4, std::string *a5, double a6, double a7)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  __int16 v46 = 0;
  int v47 = 0;
  for (uint64_t i = *a1; ; *a1 = i)
  {
    int v13 = *i;
    if ((v13 - 9) >= 5 && v13 != 32) {
      break;
    }
    if (i == a3) {
      break;
    }
    ++i;
  }
  for (int j = (char *)*a2; ; *a2 = j)
  {
    int v15 = *j;
    if ((v15 - 9) >= 5 && v15 != 32) {
      break;
    }
    if (j == a4)
    {
      int j = a4;
      break;
    }
    ++j;
  }
  char v16 = *a1;
  int v17 = **a1;
  if (((v17 - 48) < 0xA || v17 == 46 || v17 == 43 || **a1 == 45 || ((v17 - 68) & 0xFFFFFFDE) == 0)
    && (((char)v15 - 48) < 0xA
     || (char)v15 == 46
     || (char)v15 == 43
     || v15 == 45
     || (((char)v15 - 68) & 0xFFFFFFDE) == 0))
  {
    double v18 = strtod(v16, &v47);
    double v19 = strtod(*a2, &v46);
    int v20 = *v47;
    if ((v20 | 0x20) == 0x64)
    {
      uint64_t v21 = *a1;
      unint64_t v22 = (unint64_t)&(*a1)[~(unint64_t)v47];
      char v23 = v47 + 1;
      while (((char)v20 - 48) < 0xA
           || (char)v20 == 46
           || (char)v20 == 43
           || v20 == 45
           || (((char)v20 - 68) & 0xFFFFFFDE) == 0)
      {
        char v24 = *v23++;
        LOBYTE(v20) = v24;
        --v22;
      }
      uint64_t v48 = (char *)&v50;
      long long v49 = xmmword_1CFB2C4B0;
      if ((unint64_t)-(uint64_t)v22 >= 0xC9) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      uint64_t v25 = 0;
      int v26 = (char *)&v50;
      if (v23 != v21)
      {
        memcpy(&v50, v21, -(uint64_t)v22);
        int v26 = v48;
        uint64_t v25 = v49;
      }
      *(void *)&long long v49 = v25 - v22;
      v26[v47 - *(_DWORD *)a1] = 101;
      double v18 = strtod(v48, &v47);
      int v47 = &(*a1)[v47 - v48];
      if (v48 != (char *)&v50) {
        free(v48);
      }
    }
    int v27 = *v46;
    if ((v27 | 0x20) == 0x64)
    {
      unsigned int v28 = *a2;
      unint64_t v29 = (unint64_t)&(*a2)[~(unint64_t)v46];
      __int16 v30 = v46 + 1;
      while (((char)v27 - 48) < 0xA
           || (char)v27 == 46
           || (char)v27 == 43
           || v27 == 45
           || (((char)v27 - 68) & 0xFFFFFFDE) == 0)
      {
        char v31 = *v30++;
        LOBYTE(v27) = v31;
        --v29;
      }
      uint64_t v48 = (char *)&v50;
      long long v49 = xmmword_1CFB2C4B0;
      if ((unint64_t)-(uint64_t)v29 >= 0xC9) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      uint64_t v32 = 0;
      std::string v33 = (char *)&v50;
      if (v30 != v28)
      {
        memcpy(&v50, v28, -(uint64_t)v29);
        std::string v33 = v48;
        uint64_t v32 = v49;
      }
      *(void *)&long long v49 = v32 - v29;
      v33[v46 - *(_DWORD *)a2] = 101;
      double v19 = strtod(v48, &v46);
      __int16 v46 = (char *)&(*a2)[v46 - v48];
      if (v48 != (char *)&v50) {
        free(v48);
      }
    }
  }
  else
  {
    __int16 v46 = j;
    int v47 = v16;
    double v19 = 0.0;
    double v18 = 0.0;
  }
  if (v47 == *a1 || (__int16 v34 = v46, v46 == *a2))
  {
    if (a5)
    {
      MEMORY[0x1D25D9630](a5, "FP Comparison failed, not a numeric difference between '");
      std::string::push_back(a5, **a1);
      std::string::append(a5, "' and '");
      std::string::push_back(a5, **a2);
      std::string::append(a5, "'");
    }
    return 1;
  }
  double v35 = vabdd_f64(v18, v19);
  if (v35 > a6)
  {
    if (v19 == 0.0)
    {
      if (v18 == 0.0)
      {
        double v38 = 0.0;
        goto LABEL_62;
      }
      double v36 = v19 / v18;
    }
    else
    {
      double v36 = v18 / v19;
    }
    double v38 = fabs(v36 + -1.0);
LABEL_62:
    if (v38 <= a7) {
      goto LABEL_63;
    }
    if (a5)
    {
      LODWORD(v49) = 0;
      char v52 = 0;
      uint64_t v53 = 0;
      BOOL v55 = a5;
      int v54 = 0;
      uint64_t v48 = (char *)&unk_1F2646F30;
      *((void *)&v49 + 1) = 0;
      unint64_t v50 = 0;
      unint64_t v51 = 0;
      llvm::raw_ostream::write((llvm::raw_ostream *)&v48, "Compared: ", 0xAuLL);
      llvm::write_double((llvm::raw_ostream *)&v48, 0, 0, 0, v18);
      uint64_t v39 = (_DWORD *)v51;
      if (v50 - v51 > 4)
      {
        *(unsigned char *)(v51 + 4) = 32;
        *uint64_t v39 = 1684955424;
        v51 += 5;
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v48, " and ", 5uLL);
      }
      llvm::write_double((llvm::raw_ostream *)&v48, 0, 0, 0, v19);
      long long v40 = (unsigned char *)v51;
      if (v51 >= v50)
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v48, 10);
      }
      else
      {
        ++v51;
        unsigned char *v40 = 10;
      }
      uint64_t v41 = (void *)v51;
      if (v50 - v51 > 0xB)
      {
        *(_DWORD *)(v51 + 8) = 540876902;
        *uint64_t v41 = *(void *)"abs. diff = ";
        v51 += 12;
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v48, "abs. diff = ", 0xCuLL);
      }
      llvm::write_double((llvm::raw_ostream *)&v48, 0, 0, 0, v35);
      __int16 v42 = (void *)v51;
      if (v50 - v51 > 0xB)
      {
        *(_DWORD *)(v51 + 8) = 540876902;
        *__int16 v42 = *(void *)" rel.diff = ";
        v51 += 12;
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v48, " rel.diff = ", 0xCuLL);
      }
      llvm::write_double((llvm::raw_ostream *)&v48, 0, 0, 0, v38);
      uint64_t v43 = (unsigned char *)v51;
      if (v51 >= v50)
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v48, 10);
      }
      else
      {
        ++v51;
        *uint64_t v43 = 10;
      }
      unint64_t v44 = v51;
      if (v50 - v51 > 0x1A)
      {
        *(_OWORD *)unint64_t v51 = *(_OWORD *)"Out of tolerance: rel/abs: ";
        *(_OWORD *)(v44 + 11) = *(_OWORD *)"rance: rel/abs: ";
        v51 += 27;
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v48, "Out of tolerance: rel/abs: ", 0x1BuLL);
      }
      llvm::write_double((llvm::raw_ostream *)&v48, 0, 0, 0, a7);
      unint64_t v45 = (unsigned char *)v51;
      if (v51 >= v50)
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v48, 47);
      }
      else
      {
        ++v51;
        *unint64_t v45 = 47;
      }
      llvm::write_double((llvm::raw_ostream *)&v48, 0, 0, 0, a6);
      uint64_t v48 = (char *)&unk_1F2646B98;
      if (v54 == 1)
      {
        if (*((void *)&v49 + 1)) {
          MEMORY[0x1D25D9CB0](*((void *)&v49 + 1), 0x1000C8077774924);
        }
      }
    }
    return 1;
  }
LABEL_63:
  uint64_t result = 0;
  *a1 = v47;
  *a2 = v34;
  return result;
}

void sub_1CD066F54()
{
}

void *sub_1CD066F68(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1F2644B48;
  result[1] = v3;
  return result;
}

uint64_t sub_1CD066FB0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F2644B48;
  a2[1] = v2;
  return result;
}

llvm::raw_ostream *sub_1CD066FDC@<X0>(llvm::raw_ostream *this@<X1>, uint64_t a2@<X0>, void *a3@<X8>)
{
  uint64_t result = llvm::raw_ostream::write(this, **(const char ***)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
  *a3 = 0;
  return result;
}

uint64_t *llvm::FileOutputBuffer::create@<X0>(const char *a1@<X0>, void *a2@<X1>, size_t a3@<X2>, char a4@<W3>, uint64_t a5@<X8>)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  if (a2 == (void *)1 && *a1 == 45)
  {
    std::string::size_type v10 = "-";
    uint64_t v11 = 1;
    uint64_t v12 = a3;
LABEL_14:
    uint64_t result = (uint64_t *)sub_1CD0674E4((uint64_t)v30, (uint64_t)v10, v11, v12);
    *(unsigned char *)(a5 + 8) = *(unsigned char *)(a5 + 8) & 0xFE | v30[8] & 1;
    uint64_t v16 = *(void *)v30;
LABEL_18:
    *(void *)a5 = v16;
    return result;
  }
  if (a4) {
    uint64_t v13 = 511;
  }
  else {
    uint64_t v13 = 438;
  }
  if (!a3)
  {
    std::string::size_type v10 = a1;
    uint64_t v11 = (uint64_t)a2;
    uint64_t v12 = 0;
    goto LABEL_14;
  }
  memset(v30, 0, sizeof(v30));
  uint64_t v31 = 0xFFFFLL;
  __int16 v32 = 0;
  uint64_t v33 = 0;
  LOWORD(v39) = 261;
  double v36 = a1;
  *(void *)&long long v37 = a2;
  llvm::sys::fs::status((llvm::sys::fs *)&v36, (const llvm::Twine *)v30, (llvm::sys::fs::file_status *)1);
  if (*(_DWORD *)&v30[40] >= 3u)
  {
    if (*(_DWORD *)&v30[40] == 3)
    {
      *(void *)&v42.__val_ = std::generic_category();
      uint64_t result = (uint64_t *)llvm::errorCodeToError((llvm *)0x15, v42, (void *)a5);
      *(unsigned char *)(a5 + 8) |= 1u;
      return result;
    }
    goto LABEL_17;
  }
  if ((a4 & 2) != 0)
  {
LABEL_17:
    uint64_t result = (uint64_t *)sub_1CD0674E4((uint64_t)&v36, (uint64_t)a1, (uint64_t)a2, a3);
    *(unsigned char *)(a5 + 8) = *(unsigned char *)(a5 + 8) & 0xFE | v37 & 1;
    uint64_t v16 = (uint64_t)v36;
    goto LABEL_18;
  }
  LOWORD(v29) = 773;
  int v26 = a1;
  __p[0] = a2;
  __p[1] = ".tmp%%%%%%%";
  llvm::sys::fs::TempFile::create((uint64_t)&v26, v13, 0, (uint64_t)&v36);
  if (v40)
  {
    uint64_t v14 = (uint64_t)v36;
    double v36 = 0;
    *(unsigned char *)(a5 + 8) |= 1u;
    *(void *)a5 = v14;
  }
  else
  {
    LOBYTE(v26) = 0;
    *(_OWORD *)std::string __p = v37;
    uint64_t v28 = v38;
    HIBYTE(v38) = 0;
    LOBYTE(v37) = 0;
    int v17 = (llvm::sys::fs *)v39;
    int v29 = v39;
    LOBYTE(v36) = 1;
    unsigned int v39 = -1;
    double v19 = (llvm *)llvm::sys::fs::resize_file(v17, a3);
    if (v19)
    {
      uint64_t v20 = v18;
      llvm::sys::fs::TempFile::discard((llvm::sys::fs::TempFile *)&v26, &v23);
      sub_1CD4515D0((void **)&v23);
      if (v23) {
        (*(void (**)(size_t))(*(void *)v23 + 8))(v23);
      }
      *(void *)&v21.__val_ = v20;
      llvm::errorCodeToError(v19, v21, &v34);
      *(unsigned char *)(a5 + 8) |= 1u;
      *(void *)a5 = v34;
    }
    else
    {
      std::system_category();
      size_t v23 = a3;
      char v24 = 0;
      int v25 = 1;
      if (!llvm::sys::fs::mapped_file_region::init(&v23, v29, 0, 1)) {
        operator new();
      }
      size_t v23 = 0;
      char v24 = 0;
      int v25 = 0;
      llvm::sys::fs::TempFile::discard((llvm::sys::fs::TempFile *)&v26, &v22);
      sub_1CD4515D0(&v22);
      if (v22) {
        (*(void (**)(void *))(*v22 + 8))(v22);
      }
      sub_1CD0674E4((uint64_t)&v34, (uint64_t)a1, (uint64_t)a2, a3);
      *(unsigned char *)(a5 + 8) = *(unsigned char *)(a5 + 8) & 0xFE | v35 & 1;
      *(void *)a5 = v34;
      if (v24) {
        munmap(v24, v23);
      }
    }
    if (SHIBYTE(v28) < 0) {
      operator delete(__p[0]);
    }
  }
  return sub_1CCC1A4A0((uint64_t *)&v36);
}

uint64_t sub_1CD0674E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  LODWORD(v10) = 0;
  uint64_t v11 = std::system_category();
  llvm::sys::Memory::allocateMappedMemory(a4, 0, 50331648, (uint64_t)&v10, (uint64_t)&v9);
  if (!v10) {
    operator new();
  }
  *(void *)&v6.__val_ = v11;
  uint64_t result = llvm::errorCodeToError(v10, v6, &v8);
  *(unsigned char *)(a1 + 8) |= 1u;
  *(void *)a1 = v8;
  return result;
}

uint64_t sub_1CD067674(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t sub_1CD06767C(uint64_t a1)
{
  return *(void *)(a1 + 32) + *(void *)(a1 + 56);
}

uint64_t sub_1CD06768C(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

void sub_1CD067694(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = (const void **)(a1 + 8);
  uint64_t v5 = *(unsigned __int8 *)(a1 + 31);
  uint64_t v6 = *(void *)(a1 + 16);
  if ((v5 & 0x80u) == 0) {
    uint64_t v7 = v5 & 0x7F;
  }
  else {
    uint64_t v7 = *(void *)(a1 + 16);
  }
  if (v7 != 1) {
    goto LABEL_11;
  }
  uint64_t v8 = (const void *)(a1 + 8);
  if ((v5 & 0x80) != 0)
  {
    uint64_t v8 = *v4;
    uint64_t v5 = v6;
  }
  long long v9 = (llvm *)memcmp(v8, "-", v5 != 0);
  if (v5 == 1 && !v9)
  {
    std::string::size_type v10 = (llvm::raw_ostream *)llvm::outs(v9);
    uint64_t v11 = *(const void **)(a1 + 32);
    size_t v12 = *(void *)(a1 + 56);
    uint64_t v13 = (void *)*((void *)v10 + 4);
    if (v12 <= *((void *)v10 + 3) - (void)v13)
    {
      if (v12)
      {
        uint64_t v13 = memcpy(v13, v11, v12);
        *((void *)v10 + 4) += v12;
      }
    }
    else
    {
      uint64_t v13 = llvm::raw_ostream::write(v10, (const char *)v11, v12);
    }
    uint64_t v16 = (llvm::raw_ostream *)llvm::outs((llvm *)v13);
    int v17 = (const char *)*((void *)v16 + 2);
    if (*((const char **)v16 + 4) != v17)
    {
      *((void *)v16 + 4) = v17;
      llvm::raw_ostream::flush_tied_then_write(v16, v17);
    }
    *a2 = 0;
  }
  else
  {
LABEL_11:
    int v22 = 0;
    std::system_category();
    LOWORD(v21) = 260;
    v20[0] = v4;
    uint64_t v14 = (llvm *)llvm::sys::fs::openFile((unsigned __int8 *)v20, &v22, 0, 2, 0, *(unsigned int *)(a1 + 64));
    if (v14)
    {
      llvm::errorCodeToError(v14, v15, a2);
    }
    else
    {
      llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)v20, v22, 1, 1, 0);
      uint64_t v18 = *(const void **)(a1 + 32);
      size_t v19 = *(void *)(a1 + 56);
      if (v19 <= v20[3] - (void)v21)
      {
        if (v19)
        {
          memcpy(v21, v18, v19);
          v21 += v19;
        }
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)v20, (const char *)v18, v19);
      }
      *a2 = 0;
      llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)v20);
    }
  }
}

uint64_t sub_1CD067830(uint64_t a1)
{
  *(void *)a1 = &unk_1F2644B90;
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v2 = a1 + 32;
  if (v3) {
    llvm::sys::Memory::releaseMappedMemory(v2);
  }
  *(void *)a1 = &unk_1F2644BD8;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_1CD0678AC(uint64_t a1)
{
  *(void *)a1 = &unk_1F2644B90;
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v2 = a1 + 32;
  if (v3) {
    llvm::sys::Memory::releaseMappedMemory(v2);
  }
  *(void *)a1 = &unk_1F2644BD8;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD067948(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

uint64_t sub_1CD067950(uint64_t a1)
{
  return *(void *)(a1 + 40) + *(void *)(a1 + 32);
}

uint64_t sub_1CD06795C(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t sub_1CD067964@<X0>(uint64_t a1@<X0>, const llvm::Twine *a2@<X2>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 32;
  uint64_t v6 = *(void **)(a1 + 40);
  if (v6) {
    munmap(v6, *(void *)v5);
  }
  *(void *)uint64_t v5 = 0;
  *(void *)(v5 + 8) = 0;
  *(_DWORD *)(v5 + 16) = 0;
  __int16 v9 = 260;
  v8[0] = a1 + 8;
  return llvm::sys::fs::TempFile::keep((llvm::sys::fs::TempFile *)(a1 + 56), (const llvm::Twine *)v8, a2, a3);
}

uint64_t sub_1CD0679D4(uint64_t a1)
{
  *(void *)a1 = &unk_1F2644C20;
  uint64_t v2 = a1 + 32;
  uint64_t v3 = *(void **)(a1 + 40);
  if (v3) {
    munmap(v3, *(void *)v2);
  }
  *(void *)uint64_t v2 = 0;
  *(void *)(v2 + 8) = 0;
  *(_DWORD *)(v2 + 16) = 0;
  llvm::sys::fs::TempFile::discard((llvm::sys::fs::TempFile *)(a1 + 56), &v6);
  sub_1CD4515D0(&v6);
  if (v6) {
    (*(void (**)(void *))(*v6 + 8))(v6);
  }
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  uint64_t v4 = *(void **)(a1 + 40);
  if (v4) {
    munmap(v4, *(void *)v2);
  }
  *(void *)a1 = &unk_1F2644BD8;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_1CD067AC4(uint64_t a1)
{
  sub_1CD0679D4(a1);

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CD067AFC(uint64_t a1)
{
  llvm::sys::fs::TempFile::discard((llvm::sys::fs::TempFile *)(a1 + 56), &v2);
  sub_1CD4515D0(&v2);
  uint64_t result = v2;
  if (v2) {
    return (void *)(*(uint64_t (**)(void *))(*v2 + 8))(v2);
  }
  return result;
}

BOOL llvm::FoldingSetNodeIDRef::operator==(uint64_t a1, const void *a2, uint64_t a3)
{
  return *(void *)(a1 + 8) == a3 && memcmp(*(const void **)a1, a2, 4 * a3) == 0;
}

BOOL llvm::FoldingSetNodeIDRef::operator<(uint64_t a1, const void *a2, unint64_t a3)
{
  unint64_t v3 = *(void *)(a1 + 8);
  if (v3 == a3) {
    return memcmp(*(const void **)a1, a2, 4 * a3) >> 31;
  }
  else {
    return v3 < a3;
  }
}

unsigned int *llvm::FoldingSetNodeID::AddString(unsigned int *result, unsigned __int8 *a2, unsigned int a3)
{
  uint64_t v5 = result;
  uint64_t v6 = result[2];
  unint64_t v7 = result[3];
  if (v6 + (((unint64_t)a3 + 3) >> 2) + 1 > v7) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (v6 >= v7) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v6) = a3;
  unsigned int v8 = result[2] + 1;
  result[2] = v8;
  if (a3)
  {
    if ((a2 & 3) != 0)
    {
      for (unsigned int i = 4; i <= a3; i += 4)
      {
        if (v8 >= result[3]) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(_DWORD *)(*(void *)result + 4 * v8) = (a2[i - 1] << 24) | (a2[i - 2] << 16) | (a2[i - 3] << 8) | a2[i - 4];
        unsigned int v8 = result[2] + 1;
        result[2] = v8;
      }
    }
    else
    {
      uint64_t v9 = a3 >> 2;
      if (v9 + (unint64_t)v8 > result[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (a3 >> 2)
      {
        uint64_t result = (unsigned int *)memcpy((void *)(*(void *)result + 4 * v8), a2, 4 * v9);
        unsigned int v8 = v5[2];
      }
      v8 += (unint64_t)(4 * v9) >> 2;
      v5[2] = v8;
      unsigned int i = (a3 & 0xFFFFFFFC) + 4;
    }
    int v11 = 0;
    unsigned int v12 = i - a3;
    if (i - a3 != 3)
    {
      if (v12 != 2)
      {
        if (v12 != 1) {
          return result;
        }
        int v11 = a2[a3 - 3] << 16;
      }
      v11 |= a2[a3 - 2] << 8;
    }
    int v13 = v11 | a2[a3 - 1];
    if (v8 >= v5[3]) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(_DWORD *)(*(void *)v5 + 4 * v8) = v13;
    ++v5[2];
  }
  return result;
}

unsigned int *llvm::FoldingSetNodeID::AddNodeID(unsigned int *result, uint64_t a2)
{
  uint64_t v2 = result;
  uint64_t v3 = *(unsigned int *)(a2 + 8);
  uint64_t v4 = result[2];
  if (v4 + v3 > (unint64_t)result[3]) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (v3)
  {
    uint64_t result = (unsigned int *)memcpy((void *)(*(void *)result + 4 * v4), *(const void **)a2, 4 * v3);
    LODWORD(v4) = v2[2];
  }
  v2[2] = v4 + v3;
  return result;
}

BOOL llvm::FoldingSetNodeID::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a2 + 8);
  return v2 == *(_DWORD *)(a1 + 8) && memcmp(*(const void **)a1, *(const void **)a2, 4 * v2) == 0;
}

BOOL llvm::FoldingSetNodeID::operator==(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(a1 + 8);
  return a3 == v3 && memcmp(*(const void **)a1, a2, 4 * v3) == 0;
}

BOOL llvm::FoldingSetNodeID::operator<(uint64_t a1, const void *a2, unint64_t a3)
{
  unint64_t v3 = *(unsigned int *)(a1 + 8);
  if (a3 == v3) {
    return memcmp(*(const void **)a1, a2, 4 * v3) >> 31;
  }
  else {
    return a3 > v3;
  }
}

_DWORD *llvm::FoldingSetNodeID::Intern(uint64_t a1, uint64_t *__sz)
{
  uint64_t result = (_DWORD *)sub_1CB906F34(__sz, 4 * *(unsigned int *)(a1 + 8), 2);
  uint64_t v4 = *(unsigned int *)(a1 + 8);
  if (v4)
  {
    uint64_t v5 = *(int **)a1;
    uint64_t v6 = 4 * v4;
    unint64_t v7 = result;
    do
    {
      int v8 = *v5++;
      *v7++ = v8;
      v6 -= 4;
    }
    while (v6);
  }
  return result;
}

llvm::FoldingSetBase *llvm::FoldingSetBase::FoldingSetBase(llvm::FoldingSetBase *this, char a2)
{
  unsigned int v3 = 1 << a2;
  *((_DWORD *)this + 2) = 1 << a2;
  uint64_t v4 = malloc_type_calloc(((1 << a2) + 1), 8uLL, 0x6D9A4F0CuLL);
  if (!v4) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  v4[v3] = -1;
  *(void *)this = v4;
  *((_DWORD *)this + 3) = 0;
  return this;
}

{
  unsigned int v3;
  void *v4;

  unsigned int v3 = 1 << a2;
  *((_DWORD *)this + 2) = 1 << a2;
  uint64_t v4 = malloc_type_calloc(((1 << a2) + 1), 8uLL, 0x6D9A4F0CuLL);
  if (!v4) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  v4[v3] = -1;
  *(void *)this = v4;
  *((_DWORD *)this + 3) = 0;
  return this;
}

double llvm::FoldingSetBase::FoldingSetBase(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  double result = *(double *)(a2 + 8);
  *(double *)(a1 + 8) = result;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  return result;
}

{
  double result;

  *(void *)a1 = *(void *)a2;
  double result = *(double *)(a2 + 8);
  *(double *)(a1 + 8) = result;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  return result;
}

uint64_t llvm::FoldingSetBase::operator=(uint64_t a1, void *a2)
{
  *(void *)a1 = *a2;
  *(void *)(a1 + 8) = a2[1];
  *a2 = 0;
  a2[1] = 0;
  return a1;
}

void llvm::FoldingSetBase::~FoldingSetBase(void **this)
{
}

{
  free(*this);
}

void llvm::FoldingSetBase::clear(void **this)
{
  *((void *)*this + *((unsigned int *)this + bzero(*this, 8 * *((unsigned int *)this + 2)) = -1;
  *((_DWORD *)this + 3) = 0;
}

void llvm::FoldingSetBase::GrowBucketCount(uint64_t a1, int a2, uint64_t a3)
{
  v32[16] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void **)a1;
  uint64_t v7 = *(unsigned int *)(a1 + 8);
  int v8 = a2 + 1;
  uint64_t v9 = malloc_type_calloc((a2 + 1), 8uLL, 0x6D9A4F0CuLL);
  if (!v9 && (v8 || (uint64_t v9 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0)) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  v9[a2] = -1;
  *(void *)a1 = v9;
  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 12) = 0;
  uint64_t v28 = v30;
  uint64_t v29 = 0x2000000000;
  if (!v7) {
    goto LABEL_21;
  }
  uint64_t v10 = 0;
  int v11 = v32;
  do
  {
    unsigned int v12 = (uint64_t *)v6[v10];
    if (v12) {
      BOOL v13 = (v6[v10] & 1) == 0;
    }
    else {
      BOOL v13 = 0;
    }
    if (v13)
    {
      do
      {
        uint64_t v14 = (uint64_t *)*v12;
        uint64_t *v12 = 0;
        unsigned int v15 = (*(uint64_t (**)(uint64_t, uint64_t *, unsigned char **))(a3 + 16))(a1, v12, &v28);
        int v16 = *(_DWORD *)(a1 + 8);
        unsigned int v17 = *(_DWORD *)(a1 + 12) + 1;
        if (v17 > 2 * v16)
        {
          llvm::FoldingSetBase::GrowBucketCount(a1, (2 * v16), a3);
          v31[0] = v11;
          v31[1] = (void *)0x2000000000;
          unsigned int v20 = (*(uint64_t (**)(uint64_t, uint64_t *, void **))(a3 + 16))(a1, v12, v31);
          std::error_code v21 = v11;
          unsigned int v22 = v20;
          size_t v23 = *(void **)a1;
          int v24 = *(_DWORD *)(a1 + 8);
          int v27 = v21;
          if (v31[0] != v21)
          {
            int v26 = *(void **)a1;
            free(v31[0]);
            size_t v23 = v26;
          }
          uint64_t v18 = (uint64_t)&v23[(v24 - 1) & v22];
          unsigned int v17 = *(_DWORD *)(a1 + 12) + 1;
          int v11 = v27;
        }
        else
        {
          uint64_t v18 = *(void *)a1 + 8 * ((v16 - 1) & v15);
        }
        *(_DWORD *)(a1 + 12) = v17;
        uint64_t v19 = *(void *)v18;
        if (!*(void *)v18) {
          uint64_t v19 = v18 | 1;
        }
        uint64_t *v12 = v19;
        *(void *)uint64_t v18 = v12;
        LODWORD(v29) = 0;
        if (!v14) {
          break;
        }
        unsigned int v12 = v14;
      }
      while ((v14 & 1) == 0);
    }
    ++v10;
  }
  while (v10 != v7);
  int v25 = v28;
  free(v6);
  uint64_t v6 = v25;
  if (v25 != v30) {
LABEL_21:
  }
    free(v6);
}

void llvm::FoldingSetBase::InsertNode(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  v12[16] = *MEMORY[0x1E4F143B8];
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 12) + 1;
  if (v7 > 2 * v6)
  {
    llvm::FoldingSetBase::GrowBucketCount(a1, 2 * v6, a4);
    v11[0] = v12;
    v11[1] = (void *)0x2000000000;
    a3 = *(void *)a1
       + 8
       * ((*(_DWORD *)(a1 + 8) - 1) & (*(unsigned int (**)(uint64_t, uint64_t *, void **))(a4 + 16))(a1, a2, v11));
    if (v11[0] != v12)
    {
      uint64_t v10 = a3;
      free(v11[0]);
      a3 = v10;
    }
    unsigned int v7 = *(_DWORD *)(a1 + 12) + 1;
  }
  *(_DWORD *)(a1 + 12) = v7;
  uint64_t v8 = *(void *)a3;
  if (!*(void *)a3) {
    uint64_t v8 = a3 | 1;
  }
  *a2 = v8;
  *(void *)a3 = a2;
}

void llvm::FoldingSetBase::GrowHashTable(uint64_t a1, uint64_t a2)
{
}

void *llvm::FoldingSetBase::FindNodeOrInsertPos(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  v15[16] = *MEMORY[0x1E4F143B8];
  unint64_t v8 = sub_1CC13A6B8(*(void **)a2, *(void *)a2 + 4 * *(unsigned int *)(a2 + 8));
  uint64_t v9 = (void **)(*(void *)a1 + 8 * ((*(_DWORD *)(a1 + 8) - 1) & v8));
  uint64_t v10 = *v9;
  *a3 = 0;
  BOOL v13 = v15;
  uint64_t v14 = 0x2000000000;
  while (v10 && (v10 & 1) == 0)
  {
    if ((*(uint64_t (**)(uint64_t, void *, uint64_t, unint64_t, void **))(a4 + 8))(a1, v10, a2, v8, &v13))goto LABEL_9; {
    LODWORD(v14) = 0;
    }
    uint64_t v10 = (void *)*v10;
  }
  uint64_t v10 = 0;
  *a3 = v9;
LABEL_9:
  if (v13 != v15) {
    free(v13);
  }
  return v10;
}

BOOL llvm::FoldingSetBase::RemoveNode(uint64_t a1, void *a2)
{
  uint64_t v2 = (void *)*a2;
  if (*a2)
  {
    --*(_DWORD *)(a1 + 12);
    *a2 = 0;
    unint64_t v3 = (unint64_t)v2;
    do
    {
      uint64_t v4 = (unint64_t *)v3;
      if (!v3 || (v3 & 1) != 0) {
        uint64_t v4 = (unint64_t *)(v3 & 0xFFFFFFFFFFFFFFFELL);
      }
      unint64_t v3 = *v4;
    }
    while ((void *)*v4 != a2);
    *uint64_t v4 = (unint64_t)v2;
  }
  return v2 != 0;
}

void *llvm::FoldingSetBase::GetOrInsertNode(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  v20[16] = *MEMORY[0x1E4F143B8];
  unsigned int v15 = v17;
  uint64_t v16 = 0x2000000000;
  (*(void (**)(uint64_t, uint64_t *, void **))a3)(a1, a2, &v15);
  unint64_t v6 = sub_1CC13A6B8(v15, (uint64_t)v15 + 4 * v16);
  int v7 = *(_DWORD *)(a1 + 8);
  uint64_t v8 = *(void *)a1 + 8 * ((v7 - 1) & v6);
  uint64_t v9 = *(void **)v8;
  uint64_t v18 = v20;
  uint64_t v19 = 0x2000000000;
  if (v9) {
    BOOL v10 = (v9 & 1) == 0;
  }
  else {
    BOOL v10 = 0;
  }
  if (!v10) {
    goto LABEL_17;
  }
  while (((*(uint64_t (**)(uint64_t, void *, void **, unint64_t, void **))(a3 + 8))(a1, v9, &v15, v6, &v18) & 1) == 0)
  {
    LODWORD(v19) = 0;
    uint64_t v9 = (void *)*v9;
    if (v9) {
      BOOL v11 = (v9 & 1) == 0;
    }
    else {
      BOOL v11 = 0;
    }
    if (!v11)
    {
      uint64_t v9 = 0;
      goto LABEL_13;
    }
  }
  uint64_t v8 = 0;
LABEL_13:
  if (v18 != v20) {
    free(v18);
  }
  if (!v9)
  {
    int v7 = *(_DWORD *)(a1 + 8);
LABEL_17:
    unsigned int v12 = *(_DWORD *)(a1 + 12) + 1;
    if (v12 > 2 * v7)
    {
      llvm::FoldingSetBase::GrowBucketCount(a1, 2 * v7, a3);
      uint64_t v18 = v20;
      uint64_t v19 = 0x2000000000;
      uint64_t v8 = *(void *)a1
         + 8
         * ((*(_DWORD *)(a1 + 8) - 1) & (*(unsigned int (**)(uint64_t, uint64_t *, void **))(a3 + 16))(a1, a2, &v18));
      if (v18 != v20) {
        free(v18);
      }
      unsigned int v12 = *(_DWORD *)(a1 + 12) + 1;
    }
    *(_DWORD *)(a1 + 12) = v12;
    uint64_t v13 = *(void *)v8;
    if (!*(void *)v8) {
      uint64_t v13 = v8 | 1;
    }
    *a2 = v13;
    *(void *)uint64_t v8 = a2;
    uint64_t v9 = a2;
  }
  if (v15 != v17) {
    free(v15);
  }
  return v9;
}

unint64_t *llvm::FoldingSetIteratorImpl::FoldingSetIteratorImpl(unint64_t *this, void **a2)
{
  while (1)
  {
    unint64_t v2 = (unint64_t)*a2;
    if (*a2)
    {
      if (v2 == -1) {
        break;
      }
      if (v2 && ((unint64_t)*a2 & 1) == 0) {
        break;
      }
    }
    ++a2;
  }
  *this = v2;
  return this;
}

{
  unint64_t v2;

  while (1)
  {
    unint64_t v2 = (unint64_t)*a2;
    if (*a2)
    {
      if (v2 == -1) {
        break;
      }
      if (v2 && ((unint64_t)*a2 & 1) == 0) {
        break;
      }
    }
    ++a2;
  }
  *this = v2;
  return this;
}

unint64_t **llvm::FoldingSetIteratorImpl::advance(unint64_t **this)
{
  unint64_t v1 = **this;
  if (v1) {
    BOOL v2 = (**this & 1) == 0;
  }
  else {
    BOOL v2 = 0;
  }
  if (!v2)
  {
    for (unsigned int i = (unint64_t *)((v1 & 0xFFFFFFFFFFFFFFFELL) + 8); ; ++i)
    {
      unint64_t v1 = *i;
      if (*i)
      {
        if (v1 == -1) {
          break;
        }
        if (v1 && (*i & 1) == 0) {
          break;
        }
      }
    }
  }
  *this = (unint64_t *)v1;
  return this;
}

void ***llvm::FoldingSetBucketIteratorImpl::FoldingSetBucketIteratorImpl(void ***this, void **a2)
{
  if ((unint64_t)*a2) {
    BOOL v2 = a2;
  }
  else {
    BOOL v2 = (void **)*a2;
  }
  if (*a2) {
    unint64_t v3 = v2;
  }
  else {
    unint64_t v3 = a2;
  }
  *this = v3;
  return this;
}

{
  void **v2;
  void **v3;

  if ((unint64_t)*a2) {
    BOOL v2 = a2;
  }
  else {
    BOOL v2 = (void **)*a2;
  }
  if (*a2) {
    unint64_t v3 = v2;
  }
  else {
    unint64_t v3 = a2;
  }
  *this = v3;
  return this;
}

void llvm::PrintfStyleFormatReader::refillSpecifierQueue(char **this)
{
  for (unsigned int i = *this; ; *this = i)
  {
    unint64_t v3 = strchr(i, 37);
    if (!v3)
    {
      uint64_t v4 = this[2];
      if (v4 + 1 > this[3]) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      v4[(void)this[1]] = 0;
      ++this[2];
      return;
    }
    *this = v3 + 1;
    if (v3[1] != 37) {
      break;
    }
    unsigned int i = v3 + 2;
  }
  uint64_t v5 = (void **)(this + 1);
  unint64_t v6 = this[2];
  if (v6 + 1 > this[3]) {
    llvm::SmallVectorBase<unsigned long long>::grow_pod();
  }
  v6[(void)this[1]] = 1;
  ++this[2];
  uint64_t v38 = v40;
  long long v39 = xmmword_1CFB2CC50;
  int v7 = (unsigned __int8 *)(*this + 1);
  unint64_t v8 = 0x129C2FA010000E2;
  while (1)
  {
    int v9 = (char)*(v7 - 1);
    if (v9 <= 42) {
      break;
    }
    if (v9 != 43 && v9 != 45)
    {
      if (v9 != 48) {
        goto LABEL_18;
      }
      v8 &= 0x12082F2010000E2uLL;
    }
LABEL_17:
    *this = (char *)v7++;
  }
  if (v9 == 32) {
    goto LABEL_17;
  }
  if (v9 == 35)
  {
    v8 &= 0x10000E2010000E2uLL;
    goto LABEL_17;
  }
LABEL_18:
  int v10 = *(v7 - 1);
  if (v10 == 42)
  {
    v40[0] = 3;
    uint64_t v11 = 1;
    *(void *)&long long v39 = 1;
    *this = (char *)v7;
    int v10 = *v7;
  }
  else
  {
    if ((v10 - 48) <= 9)
    {
      do
      {
        *this = (char *)v7;
        int v12 = *v7++;
        int v10 = v12;
      }
      while ((v12 - 48) < 0xA);
    }
    uint64_t v11 = 0;
    --v7;
  }
  if (v10 == 46)
  {
    v8 &= 0x12882F2010000E2uLL;
    *this = (char *)(v7 + 1);
    int v13 = v7[1];
    if (v13 == 42)
    {
      v40[v11++] = 3;
      *(void *)&long long v39 = v11;
      v7 += 2;
      *this = (char *)v7;
    }
    else if ((v13 - 48) > 9)
    {
      ++v7;
    }
    else
    {
      uint64_t v14 = (char *)(v7 + 2);
      do
      {
        *this = v14;
        int v15 = *v14++;
      }
      while ((v15 - 48) < 0xA);
      int v7 = (unsigned __int8 *)(v14 - 1);
    }
  }
  uint64_t v16 = v7 + 1;
  unsigned int v17 = 2;
  while (2)
  {
    int v18 = (char)*(v16 - 1);
    if (v18 <= 107)
    {
      switch(v18)
      {
        case 'L':
          int v19 = 8;
          goto LABEL_49;
        case 'h':
          if (v17 != 1)
          {
            int v19 = 1;
            goto LABEL_49;
          }
          int v19 = 0;
          break;
        case 'j':
          int v19 = 5;
LABEL_49:
          if (v17 != 2) {
            goto LABEL_83;
          }
          break;
        default:
          goto LABEL_51;
      }
LABEL_50:
      *this = (char *)v16++;
      unsigned int v17 = v19;
      continue;
    }
    break;
  }
  switch(v18)
  {
    case 'l':
      if (v17 != 3)
      {
        int v19 = 3;
        goto LABEL_49;
      }
      int v19 = 4;
      goto LABEL_50;
    case 't':
      int v19 = 7;
      goto LABEL_49;
    case 'z':
      int v19 = 6;
      goto LABEL_49;
  }
LABEL_51:
  if (*(v16 - 1))
  {
    *this = (char *)v16;
    if (char)v18 >= 64 && ((v8 >> v18))
    {
      uint64_t v20 = 0;
      switch(v18)
      {
        case 'X':
        case 'd':
        case 'i':
        case 'o':
        case 'u':
        case 'x':
          goto LABEL_59;
        case 'Y':
        case 'Z':
        case '[':
        case '\\':
        case ']':
        case '^':
        case '_':
        case 'b':
        case 'h':
        case 'j':
        case 'k':
        case 'l':
        case 'm':
        case 'q':
        case 'r':
        case 't':
        case 'v':
        case 'w':
          break;
        case 'a':
        case 'e':
        case 'f':
        case 'g':
          goto LABEL_58;
        case 'c':
          uint64_t v20 = 2;
          goto LABEL_59;
        case 'n':
          uint64_t v20 = 5;
          goto LABEL_59;
        case 'p':
          uint64_t v20 = 4;
          goto LABEL_59;
        case 's':
          uint64_t v20 = 3;
          goto LABEL_59;
        default:
          if ((v18 - 69) < 3 || v18 == 65)
          {
LABEL_58:
            uint64_t v20 = 1;
LABEL_59:
            int v21 = byte_1CFB2EA00[(v20 | (8 * v20)) + v17];
            if (v21 != 1)
            {
              v40[v11] = v21;
              unsigned int v22 = (char *)v38;
              size_t v23 = (char *)(v39 + 1);
              *(void *)&long long v39 = v23;
              if (v23)
              {
                int v24 = &v23[(void)v38 - 1];
                if (v38 < v24)
                {
                  int v25 = (char *)v38 + 1;
                  do
                  {
                    char v26 = *(v25 - 1);
                    *(v25 - 1) = *v24;
                    *v24-- = v26;
                  }
                  while (v25++ < v24);
                }
              }
              if (&v38 != v5)
              {
                if (v22 == v40 || this[1] == (char *)(this + 4))
                {
                  if (*((void *)&v39 + 1) < (unint64_t)this[2]) {
                    llvm::SmallVectorBase<unsigned long long>::grow_pod();
                  }
                  if (this[3] < v23) {
                    llvm::SmallVectorBase<unsigned long long>::grow_pod();
                  }
                  __int16 v30 = this[2];
                  if (v23 >= v30) {
                    uint64_t v31 = this[2];
                  }
                  else {
                    uint64_t v31 = v23;
                  }
                  if (v31)
                  {
                    __int16 v32 = (char *)v38;
                    uint64_t v33 = (char *)*v5;
                    uint64_t v34 = v31;
                    do
                    {
                      char v35 = *v32;
                      *v32++ = *v33;
                      *v33++ = v35;
                      --v34;
                    }
                    while (v34);
                  }
                  int64_t v36 = v23 - v30;
                  if (v23 <= v30)
                  {
                    int64_t v37 = v30 - v23;
                    if (v30 > v23)
                    {
                      memcpy(&v23[(void)v38], &v31[(void)this[1]], v30 - v31);
                      *(void *)&long long v39 = v37 + v39;
                      this[2] = v31;
                    }
                  }
                  else
                  {
                    memcpy(&v30[(void)this[1]], &v31[(void)v38], v23 - v31);
                    this[2] += v36;
                    *(void *)&long long v39 = v31;
                  }
                }
                else
                {
                  uint64_t v38 = this[1];
                  uint64_t v28 = (char *)*((void *)&v39 + 1);
                  long long v29 = *((_OWORD *)this + 1);
                  this[1] = v22;
                  this[2] = v23;
                  long long v39 = v29;
                  this[3] = v28;
                }
              }
            }
          }
          break;
      }
    }
  }
LABEL_83:
  if (v38 != v40) {
    free(v38);
  }
}

llvm::PrintfStyleFormatReader *llvm::PrintfStyleFormatReader::ensureCompatible(llvm::PrintfStyleFormatReader *this, char *a2, const char *a3)
{
  uint64_t v4 = this;
  uint64_t v5 = 0;
  uint64_t v14 = (char *)this;
  int v15 = &v17;
  long long v16 = xmmword_1CFB2CC50;
  int v10 = a2;
  uint64_t v11 = &v13;
  long long v12 = xmmword_1CFB2CC50;
  while (1)
  {
    uint64_t v6 = v16;
    if (!(void)v16)
    {
      llvm::PrintfStyleFormatReader::refillSpecifierQueue(&v14);
      uint64_t v6 = v16;
      uint64_t v5 = v12;
    }
    int v7 = *((char *)v15 + v6 - 1);
    *(void *)&long long v16 = v6 - 1;
    if (!v5)
    {
      llvm::PrintfStyleFormatReader::refillSpecifierQueue(&v10);
      uint64_t v5 = v12;
    }
    int v8 = *((char *)v11 + --v5);
    *(void *)&long long v12 = v5;
    if (v7 != v8) {
      break;
    }
    if (!v7)
    {
      uint64_t v4 = (llvm::PrintfStyleFormatReader *)a2;
      break;
    }
  }
  if (v11 != &v13) {
    free(v11);
  }
  if (v15 != &v17) {
    free(v15);
  }
  return v4;
}

uint64_t llvm::formatted_raw_ostream::UpdatePosition(uint64_t this, char *a2, uint64_t a3)
{
  unint64_t v3 = a2;
  uint64_t v4 = this;
  uint64_t v5 = (int *)(this + 72);
  uint64_t v6 = (_DWORD *)(this + 76);
  v17[0] = (_DWORD *)(this + 76);
  v17[1] = (_DWORD *)(this + 72);
  int v7 = (void *)(this + 88);
  uint64_t v8 = *(void *)(this + 96);
  if (v8)
  {
    unint64_t v14 = (byte_1CFB2E8BF[*(unsigned __int8 *)*v7] + 1) - v8;
    uint64_t v15 = a3 - v14;
    if (a3 < v14)
    {
      uint64_t v13 = &a2[a3];
LABEL_19:
      return (uint64_t)sub_1CC22C75C(v7, v3, v13);
    }
    long long v16 = &a2[v14];
    sub_1CC22C75C((void *)(this + 88), a2, &a2[v14]);
    this = sub_1CD069144(v17, *(char **)(v4 + 88), *(void *)(v4 + 96));
    *(void *)(v4 + 96) = 0;
    a3 = v15;
    unint64_t v3 = (char *)v16;
  }
  if (a3 >= 1)
  {
    int v9 = &v3[a3];
    do
    {
      uint64_t v10 = (byte_1CFB2E8BF[*v3] + 1);
      if (v10 > (int)v9 - (int)v3)
      {
        uint64_t v13 = v9;
        *(void *)(v4 + 96) = 0;
        goto LABEL_19;
      }
      this = llvm::sys::unicode::columnWidthUTF8((uint64_t)v3, (byte_1CFB2E8BF[*v3] + 1));
      if (this != -1) {
        *v5 += this;
      }
      if (v10 <= 1)
      {
        int v11 = *v3;
        switch(v11)
        {
          case 9:
            int v12 = (-*v5 & 7) + *v5;
            goto LABEL_16;
          case 13:
            int v12 = 0;
            goto LABEL_16;
          case 10:
            int v12 = 0;
            ++*v6;
LABEL_16:
            *uint64_t v5 = v12;
            break;
        }
      }
      v3 += v10;
    }
    while (v3 < v9);
  }
  return this;
}

uint64_t sub_1CD069144(_DWORD **a1, char *a2, unint64_t a3)
{
  uint64_t result = llvm::sys::unicode::columnWidthUTF8((uint64_t)a2, a3);
  if (result != -1) {
    *a1[1] += result;
  }
  if (a3 <= 1)
  {
    int v7 = *a2;
    if (v7 == 9)
    {
      *a1[1] += -*a1[1] & 7;
    }
    else
    {
      if (v7 != 13)
      {
        if (v7 != 10) {
          return result;
        }
        ++**a1;
      }
      *a1[1] = 0;
    }
  }
  return result;
}

uint64_t llvm::formatted_raw_ostream::ComputePosition(llvm::formatted_raw_ostream *this, char *a2, uint64_t a3)
{
  uint64_t v5 = (char *)*((void *)this + 10);
  uint64_t v6 = &a2[a3];
  if (v5 < a2 || v5 > v6) {
    uint64_t v5 = a2;
  }
  else {
    a3 = v6 - v5;
  }
  uint64_t result = llvm::formatted_raw_ostream::UpdatePosition((uint64_t)this, v5, a3);
  *((void *)this + 10) = v6;
  return result;
}

llvm::raw_ostream *llvm::formatted_raw_ostream::PadToColumn(llvm::formatted_raw_ostream *this, int a2)
{
  uint64_t v4 = (char *)*((void *)this + 2);
  uint64_t v5 = (char *)*((void *)this + 4);
  unint64_t v6 = *((void *)this + 10);
  if (v6 < (unint64_t)v4 || v6 > (unint64_t)v5)
  {
    uint64_t v13 = v5 - v4;
  }
  else
  {
    uint64_t v13 = (uint64_t)&v5[-v6];
    uint64_t v4 = (char *)*((void *)this + 10);
  }
  llvm::formatted_raw_ostream::UpdatePosition((uint64_t)this, v4, v13);
  *((void *)this + 10) = v5;
  uint64_t v8 = (char *)*((void *)this + 2);
  unint64_t v9 = *((void *)this + 4);
  if (v5 < v8 || (unint64_t)v5 > v9)
  {
    uint64_t v14 = v9 - (void)v8;
    uint64_t v15 = this;
  }
  else
  {
    uint64_t v14 = v9 - (void)v5;
    uint64_t v15 = this;
    uint64_t v8 = v5;
  }
  llvm::formatted_raw_ostream::UpdatePosition((uint64_t)v15, v8, v14);
  *((void *)this + 10) = v9;
  if (a2 - *((_DWORD *)this + 18) <= 1) {
    unsigned int v11 = 1;
  }
  else {
    unsigned int v11 = a2 - *((_DWORD *)this + 18);
  }

  return llvm::raw_ostream::indent(this, v11);
}

llvm::raw_ostream *llvm::formatted_raw_ostream::write_impl(llvm::formatted_raw_ostream *this, char *a2, uint64_t a3)
{
  size_t v3 = a3;
  unint64_t v6 = (char *)*((void *)this + 10);
  int v7 = &a2[a3];
  if (v6 < a2 || v6 > v7) {
    unint64_t v6 = a2;
  }
  else {
    a3 = v7 - v6;
  }
  llvm::formatted_raw_ostream::UpdatePosition((uint64_t)this, v6, a3);
  *((void *)this + 10) = v7;
  uint64_t result = llvm::raw_ostream::write(*((llvm::raw_ostream **)this + 8), a2, v3);
  *((void *)this + 10) = 0;
  return result;
}

void *llvm::fouts(llvm *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCFADE8, memory_order_acquire) & 1) == 0)
  {
    BOOL v2 = (llvm *)__cxa_guard_acquire(&qword_1EBCFADE8);
    if (v2)
    {
      size_t v3 = llvm::outs(v2);
      sub_1CD8388CC((uint64_t)&unk_1EBCFAE00, (uint64_t)v3);
      __cxa_atexit((void (*)(void *))sub_1CD838944, &unk_1EBCFAE00, &dword_1CB82C000);
      __cxa_guard_release(&qword_1EBCFADE8);
    }
  }
  return &unk_1EBCFAE00;
}

void *llvm::ferrs(llvm *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCFADF0, memory_order_acquire) & 1) == 0)
  {
    BOOL v2 = (llvm *)__cxa_guard_acquire(&qword_1EBCFADF0);
    if (v2)
    {
      size_t v3 = llvm::errs(v2);
      sub_1CD8388CC((uint64_t)&unk_1EBCFAE78, (uint64_t)v3);
      __cxa_atexit((void (*)(void *))sub_1CD838944, &unk_1EBCFAE78, &dword_1CB82C000);
      __cxa_guard_release(&qword_1EBCFADF0);
    }
  }
  return &unk_1EBCFAE78;
}

uint64_t llvm::GPUBaseInfo::getArchFromTriple(const std::string *a1)
{
  if (!std::string::compare(a1, 0, 4uLL, "agx1")) {
    return 27;
  }
  if (!std::string::compare(a1, 0, 4uLL, "agx2")) {
    return 28;
  }
  if (!std::string::compare(a1, 0, 4uLL, "agx3")) {
    return 29;
  }
  return 0;
}

BOOL llvm::GPUBaseInfo::getArchAllowsMergeAttributes(uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0) {
    sub_1CB8BDF7C((uint64_t)&__p, *(const void **)a1, *(void *)(a1 + 8));
  }
  else {
    std::string __p = *(std::string *)a1;
  }
  if (!std::string::compare(&__p, 0, 4uLL, "agx1"))
  {
    int v1 = 26;
  }
  else
  {
    int v1 = 28;
    if (std::string::compare(&__p, 0, 4uLL, "agx2"))
    {
      if (!std::string::compare(&__p, 0, 4uLL, "agx3")) {
        int v1 = 28;
      }
      else {
        int v1 = 0;
      }
    }
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v1 != 28;
}

uint64_t sub_1CD0695E4(uint64_t *a1, uint64_t a2)
{
  unint64_t v4 = a1[1];
  if (v4 >= a1[2])
  {
    uint64_t result = sub_1CB838200(a1, a2);
  }
  else
  {
    *(void *)unint64_t v4 = v4 + 16;
    *(void *)(v4 + 8) = 0x600000000;
    unsigned int v5 = *(_DWORD *)(a2 + 8);
    if (v4 != a2 && v5 != 0)
    {
      if (v5 >= 7) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy((void *)(v4 + 16), *(const void **)a2, 8 * *(unsigned int *)(a2 + 8));
      *(_DWORD *)(v4 + 8) = v5;
    }
    *(_DWORD *)(v4 + 64) = *(_DWORD *)(a2 + 64);
    uint64_t result = v4 + 72;
  }
  a1[1] = result;
  return result;
}

uint64_t sub_1CD0696A4(uint64_t result, unsigned __int8 *a2, unint64_t a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  v9[0] = &v10;
  long long v10 = 0u;
  long long v11 = 0u;
  v9[1] = (void *)0x600000004;
  int v12 = 256;
  if (a3 >= 3)
  {
    do
    {
      unint64_t v3 = *a2;
      if (a2[1] == 45)
      {
        unsigned int v4 = a2[2];
        if (v3 > v4) {
          operator new();
        }
        unsigned int v5 = v4 + 1;
        do
        {
          *((void *)&v10 + (v3 >> 6)) |= 1 << v3;
          LODWORD(v3) = v3 + 1;
        }
        while (v5 != v3);
        a2 += 3;
        uint64_t v6 = -3;
      }
      else
      {
        *(void *)((char *)&v10 + ((v3 >> 3) & 0x18)) |= 1 << v3;
        uint64_t v6 = -1;
        ++a2;
      }
      a3 += v6;
    }
    while (a3 > 2);
  }
  for (; a3; --a3)
  {
    unsigned int v7 = *a2++;
    *(void *)((char *)&v10 + (((unint64_t)v7 >> 3) & 0x18)) |= 1 << v7;
  }
  *(unsigned char *)(result + 72) &= ~1u;
  *(void *)uint64_t result = result + 16;
  *(void *)(result + 8) = 0x600000000;
  if (v9 != (void **)result)
  {
    long long v8 = v11;
    *(_OWORD *)(result + 16) = v10;
    *(_OWORD *)(result + 32) = v8;
    *(_DWORD *)(result + 8) = 4;
  }
  *(_DWORD *)(result + 64) = 256;
  return result;
}

char *llvm::DOT::EscapeString@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[23] < 0)
  {
    uint64_t result = (char *)sub_1CB8BDF7C(a2, *(const void **)result, *((void *)result + 1));
  }
  else
  {
    *(_OWORD *)a2 = *(_OWORD *)result;
    *(void *)(a2 + 16) = *((void *)result + 2);
  }
  char v3 = *(unsigned char *)(a2 + 23);
  BOOL v4 = v3 < 0;
  BOOL v5 = v4;
  uint64_t v6 = v3 & 0x7F;
  if (v4) {
    uint64_t v6 = *(void *)(a2 + 8);
  }
  if (v6)
  {
    std::string::size_type v7 = 0;
    unsigned int v8 = 0;
    do
    {
      if (v5) {
        uint64_t v9 = *(void *)a2;
      }
      else {
        uint64_t v9 = a2;
      }
      int v10 = *(char *)(v9 + v7);
      if (v10 <= 61)
      {
        if (v10 <= 33)
        {
          if (v10 == 9)
          {
            v17.__i_ = (std::__wrap_iter<const char *>::iterator_type)(v9 + v7);
            uint64_t result = std::string::insert((std::string *)a2, v17, 32).__i_;
            ++v8;
            if (*(char *)(a2 + 23) >= 0) {
              uint64_t v18 = a2;
            }
            else {
              uint64_t v18 = *(void *)a2;
            }
            *(unsigned char *)(v18 + v8) = 32;
          }
          else if (v10 == 10)
          {
            v13.__i_ = (std::__wrap_iter<const char *>::iterator_type)(v9 + v7);
            uint64_t result = std::string::insert((std::string *)a2, v13, 92).__i_;
            ++v8;
            if (*(char *)(a2 + 23) >= 0) {
              uint64_t v14 = a2;
            }
            else {
              uint64_t v14 = *(void *)a2;
            }
            *(unsigned char *)(v14 + v8) = 110;
          }
          goto LABEL_28;
        }
        if (v10 == 34 || v10 == 60) {
          goto LABEL_27;
        }
      }
      else
      {
        if ((v10 - 123) < 3 || v10 == 62) {
          goto LABEL_27;
        }
        if (v10 == 92)
        {
          uint64_t v11 = v8 + 1;
          if (v6 == v11) {
            goto LABEL_27;
          }
          int v12 = *(char *)(v9 + v11);
          if ((v12 - 123) >= 3)
          {
            if (v12 == 108) {
              goto LABEL_28;
            }
LABEL_27:
            v15.__i_ = (std::__wrap_iter<const char *>::iterator_type)(v9 + v7);
            uint64_t result = std::string::insert((std::string *)a2, v15, 92).__i_;
            ++v8;
            goto LABEL_28;
          }
          uint64_t result = (char *)std::string::erase((std::string *)a2, v7, 1uLL);
        }
      }
LABEL_28:
      std::string::size_type v7 = v8 + 1;
      char v16 = *(unsigned char *)(a2 + 23);
      BOOL v4 = v16 < 0;
      BOOL v5 = v4;
      uint64_t v6 = v16 & 0x7F;
      if (v4) {
        uint64_t v6 = *(void *)(a2 + 8);
      }
      ++v8;
    }
    while (v6 != v7);
  }
  return result;
}

const char *llvm::DOT::getColorString(llvm::DOT *this)
{
  int v1 = off_1E6855360[this % 0x14];
  strlen(v1);
  return v1;
}

uint64_t sub_1CD069ABC(uint64_t a1, uint64_t a2, uint64_t a3, std::string *a4)
{
  v27[16] = *MEMORY[0x1E4F143B8];
  v22[0] = a2;
  v22[1] = a3;
  int v14 = 0;
  char v18 = 0;
  uint64_t v19 = 0;
  uint64_t v21 = a1;
  int v20 = 0;
  std::string::const_iterator v13 = &unk_1F2646F30;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  long long __dst = 0;
  int v25 = v27;
  uint64_t v26 = 0x800000000;
  llvm::StringRef::split((char *)v22, (uint64_t)&v25, 124, -1, 1);
  if (v26)
  {
    BOOL v5 = (const void **)v25;
    uint64_t v6 = (const void **)((char *)v25 + 16 * v26);
    while (1)
    {
      unsigned int v8 = *v5;
      size_t v7 = (size_t)v5[1];
      llvm::sys::findProgramByName((void *)*v5, v7, 0, 0, &__str);
      if ((v24 & 1) == 0) {
        break;
      }
      uint64_t v9 = __dst;
      if ((unint64_t)(v16 - (void)__dst) > 8)
      {
        *((unsigned char *)__dst + 8) = 39;
        void *v9 = *(void *)"  Tried '";
        int v10 = (char *)__dst + 9;
        long long __dst = (char *)__dst + 9;
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v13, "  Tried '", 9uLL);
        int v10 = (char *)__dst;
      }
      if (v7 <= v16 - (uint64_t)v10)
      {
        if (v7)
        {
          memcpy(v10, v8, v7);
          int v10 = (char *)__dst + v7;
          long long __dst = (char *)__dst + v7;
        }
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v13, (const char *)v8, v7);
        int v10 = (char *)__dst;
      }
      if ((unint64_t)(v16 - (void)v10) > 1)
      {
        *(_WORD *)int v10 = 2599;
        long long __dst = (char *)__dst + 2;
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v13, "'\n", 2uLL);
      }
      v5 += 2;
      if (v5 == v6) {
        goto LABEL_16;
      }
    }
    std::string::operator=(a4, &__str);
    if ((v24 & 1) == 0 && SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    uint64_t v11 = 1;
  }
  else
  {
LABEL_16:
    uint64_t v11 = 0;
  }
  if (v25 != v27) {
    free(v25);
  }
  std::string::const_iterator v13 = &unk_1F2646B98;
  if (v20 == 1 && v15) {
    MEMORY[0x1D25D9CB0](v15, 0x1000C8077774924);
  }
  return v11;
}

uint64_t sub_1CD069D44(const void *a1, std::string::size_type a2, uint64_t a3, uint64_t a4, const void *a5, size_t a6, int a7, uint64_t a8)
{
  if (!a7)
  {
    LOBYTE(v33[0]) = 0;
    char v34 = 0;
    BOOL v11 = sub_1CD0E8F3C(v38, a1, a2, a3, (a4 - a3) >> 4, (uint64_t)v33, 0, 0, 0, a8);
    int v12 = (llvm::raw_ostream *)llvm::errs((llvm *)v11);
    std::string::const_iterator v13 = v12;
    int v14 = (void *)*((void *)v12 + 4);
    if (*((void *)v12 + 3) - (void)v14 > 0x1DuLL)
    {
      qmemcpy(v14, "Remember to erase graph file: ", 30);
      uint64_t v15 = (unsigned char *)(*((void *)v12 + 4) + 30);
      *((void *)v13 + 4) = v15;
    }
    else
    {
      llvm::raw_ostream::write(v12, "Remember to erase graph file: ", 0x1EuLL);
      uint64_t v15 = (unsigned char *)*((void *)v13 + 4);
    }
    if (a6 <= *((void *)v13 + 3) - (void)v15)
    {
      if (a6)
      {
        memcpy(v15, a5, a6);
        uint64_t v15 = (unsigned char *)(*((void *)v13 + 4) + a6);
        *((void *)v13 + 4) = v15;
      }
    }
    else
    {
      llvm::raw_ostream::write(v13, (const char *)a5, a6);
      uint64_t v15 = (unsigned char *)*((void *)v13 + 4);
    }
    if (*((unsigned char **)v13 + 3) != v15)
    {
      uint64_t v19 = 0;
      *uint64_t v15 = 10;
      ++*((void *)v13 + 4);
      return v19;
    }
    uint64_t v16 = "\n";
    std::string::const_iterator v17 = v13;
    size_t v18 = 1;
    goto LABEL_10;
  }
  LOBYTE(v36) = 0;
  char v37 = 0;
  uint64_t v21 = (llvm *)llvm::sys::ExecuteAndWait(a1, a2, a3, (a4 - a3) >> 4, &v36, 0, 0, 0, 0, a8, 0, 0);
  if (!v21)
  {
    __int16 v35 = 261;
    v33[0] = a5;
    v33[1] = a6;
    uint64_t v31 = (llvm *)llvm::sys::fs::remove((llvm::sys::fs *)v33, (const llvm::Twine *)1);
    std::string::const_iterator v17 = (llvm::raw_ostream *)llvm::errs(v31);
    __int16 v32 = (void *)*((void *)v17 + 4);
    if (*((void *)v17 + 3) - (void)v32 > 7uLL)
    {
      uint64_t v19 = 0;
      *__int16 v32 = 0xA202E656E6F6420;
      *((void *)v17 + 4) += 8;
      return v19;
    }
    uint64_t v16 = " done. \n";
    size_t v18 = 8;
LABEL_10:
    llvm::raw_ostream::write(v17, v16, v18);
    return 0;
  }
  unsigned int v22 = (llvm::raw_ostream *)llvm::errs(v21);
  size_t v23 = (_DWORD *)*((void *)v22 + 4);
  if (*((void *)v22 + 3) - (void)v23 > 6uLL)
  {
    *(_DWORD *)((char *)v23 + 3) = 540701295;
    *size_t v23 = 1869771333;
    *((void *)v22 + 4) += 7;
  }
  else
  {
    unsigned int v22 = llvm::raw_ostream::write(v22, "Error: ", 7uLL);
  }
  char v24 = *(unsigned char *)(a8 + 23);
  BOOL v25 = v24 < 0;
  if (v24 >= 0) {
    uint64_t v26 = (const char *)a8;
  }
  else {
    uint64_t v26 = *(const char **)a8;
  }
  size_t v27 = v24 & 0x7F;
  if (v25) {
    size_t v28 = *(void *)(a8 + 8);
  }
  else {
    size_t v28 = v27;
  }
  long long v29 = llvm::raw_ostream::write(v22, v26, v28);
  __int16 v30 = (unsigned char *)*((void *)v29 + 4);
  if (*((unsigned char **)v29 + 3) == v30)
  {
    uint64_t v19 = 1;
    llvm::raw_ostream::write(v29, "\n", 1uLL);
  }
  else
  {
    *__int16 v30 = 10;
    ++*((void *)v29 + 4);
    return 1;
  }
  return v19;
}

uint64_t llvm::set_fixed_execution_hash_seed(uint64_t this)
{
  llvm::hashing::detail::fixed_seed_override = this;
  return this;
}

uint64_t llvm::IntEqClasses::grow(uint64_t this, unsigned int a2)
{
  if (*(_DWORD *)(this + 12) < a2) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  for (unsigned int i = *(_DWORD *)(this + 8); i < a2; *(_DWORD *)(this + 8) = i)
  {
    if (i >= *(_DWORD *)(this + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(_DWORD *)(*(void *)this + 4 * i) = i;
    unsigned int i = *(_DWORD *)(this + 8) + 1;
  }
  return this;
}

unint64_t llvm::IntEqClasses::join(llvm::IntEqClasses *this, unsigned int a2, unsigned int a3)
{
  uint64_t v3 = *(void *)this;
  unint64_t result = *(unsigned int *)(*(void *)this + 4 * a2);
  unint64_t v5 = *(unsigned int *)(v3 + 4 * a3);
  if (result != v5)
  {
    unint64_t v6 = a2;
    unint64_t v7 = a3;
    do
    {
      if (result < v5)
      {
        *(_DWORD *)(v3 + 4 * v7) = result;
        unint64_t v7 = v5;
        unint64_t v5 = *(unsigned int *)(v3 + 4 * v5);
      }
      else
      {
        *(_DWORD *)(v3 + 4 * v6) = v5;
        unint64_t v6 = result;
        unint64_t result = *(unsigned int *)(v3 + 4 * result);
      }
    }
    while (result != v5);
  }
  return result;
}

uint64_t llvm::IntEqClasses::findLeader(llvm::IntEqClasses *this, unsigned int a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = *(void *)this;
  do
  {
    uint64_t result = v2;
    uint64_t v2 = *(unsigned int *)(v3 + 4 * v2);
  }
  while (result != v2);
  return result;
}

uint64_t *llvm::IntEqClasses::compress(uint64_t *this)
{
  if (!*((_DWORD *)this + 12))
  {
    uint64_t v1 = *((unsigned int *)this + 2);
    if (v1)
    {
      uint64_t v2 = 0;
      uint64_t v3 = *this;
      do
      {
        uint64_t v4 = *(unsigned int *)(v3 + 4 * v2);
        if (v2 == v4)
        {
          int v5 = *((_DWORD *)this + 12);
          *((_DWORD *)this + 12) = v5 + 1;
        }
        else
        {
          int v5 = *(_DWORD *)(v3 + 4 * v4);
        }
        *(_DWORD *)(v3 + 4 * v2++) = v5;
      }
      while (v1 != v2);
    }
  }
  return this;
}

void llvm::IntEqClasses::uncompress(llvm::IntEqClasses *this)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (*((_DWORD *)this + 12))
  {
    unsigned int v5 = 0;
    uint64_t v1 = *((unsigned int *)this + 2);
    if (v1)
    {
      for (uint64_t i = 0; i != v1; ++i)
      {
        uint64_t v3 = *(void *)this;
        uint64_t v4 = *(unsigned int *)(*(void *)this + 4 * i);
        if (v5 <= v4)
        {
          *(_DWORD *)(v3 + 4 * i) = i;
          if (v5 >= 8uLL) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          v6[v5++] = i;
        }
        else
        {
          *(_DWORD *)(v3 + 4 * i) = v6[v4];
        }
      }
      *((_DWORD *)this + 12) = 0;
    }
    else
    {
      *((_DWORD *)this + 12) = 0;
    }
  }
}

unsigned int *llvm::IntervalMapImpl::Path::replaceRoot(unsigned int *result, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v4 = result;
  unsigned int v5 = *(void **)result;
  *unsigned int v5 = a2;
  *((_DWORD *)v5 + 2) = a3;
  *((_DWORD *)v5 + 3) = a4;
  unint64_t v6 = *(void **)result;
  unint64_t v7 = *(void *)(**(void **)result + 8 * *(unsigned int *)(*(void *)result + 12)) & 0xFFFFFFFFFFFFFFC0;
  unint64_t v8 = (a4 & 0xFFFFFFFF00000000 | *(void *)(**(void **)result + 8 * *(unsigned int *)(*(void *)result + 12)) & 0x3FLL)
     + 1;
  uint64_t v9 = result[2];
  unsigned int v10 = result[3];
  if (v9 == 1)
  {
    if (v10 <= 1) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    void v6[2] = v7;
    void v6[3] = v8;
    ++result[2];
  }
  else
  {
    if (v9 >= v10) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(_OWORD *)&v6[2 * v9] = *(_OWORD *)&v6[2 * v9 - 2];
    uint64_t v11 = result[2];
    uint64_t v12 = *(void *)result + 16 * v11 - 16;
    if ((void *)v12 != v6 + 2)
    {
      uint64_t result = (unsigned int *)memmove(v6 + 4, v6 + 2, v12 - (void)(v6 + 2));
      LODWORD(v11) = v4[2];
    }
    v4[2] = v11 + 1;
    void v6[2] = v7;
    void v6[3] = v8;
  }
  return result;
}

uint64_t llvm::IntervalMapImpl::Path::getLeftSibling(llvm::IntervalMapImpl::Path *this, int a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v2 = *(void *)this;
  int v3 = -1;
  while (1)
  {
    uint64_t v4 = (a2 + v3);
    if (!(a2 + v3)) {
      break;
    }
    int v5 = *(_DWORD *)(v2 + 16 * v4 + 12);
    --v3;
    if (v5)
    {
      int v6 = a2 + v3 + 2;
      goto LABEL_10;
    }
  }
  int v5 = *(_DWORD *)(v2 + 12);
  if (!v5) {
    return 0;
  }
  int v6 = 1;
LABEL_10:
  uint64_t result = *(void *)(*(void *)(v2 + 16 * v4) + 8 * (v5 - 1));
  if (v6 != a2)
  {
    int v8 = a2 - v6;
    do
    {
      uint64_t result = *(void *)((result & 0xFFFFFFFFFFFFFFC0) + 8 * (result & 0x3F));
      --v8;
    }
    while (v8);
  }
  return result;
}

void llvm::IntervalMapImpl::Path::moveLeft(llvm::IntervalMapImpl::Path *this, unsigned int a2)
{
  uint64_t v4 = *((unsigned int *)this + 2);
  if (!v4 || *(_DWORD *)(*(void *)this + 12) >= *(_DWORD *)(*(void *)this + 8))
  {
    uint64_t v12 = a2 + 1;
    if ((int)v4 - 1 >= a2 || v4 >= v12)
    {
      uint64_t v20 = *((unsigned int *)this + 2);
      if ((int)v4 - 1 >= a2 || (uint64_t v19 = a2 + 1, v20 == v19))
      {
        unsigned int v5 = 0;
        goto LABEL_5;
      }
      if (v20 > v19)
      {
        unsigned int v17 = a2 + 1;
        goto LABEL_14;
      }
      if (v19 > *((_DWORD *)this + 3)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      int v14 = (void *)(*(void *)this + 16 * v20);
      LODWORD(v12) = a2 + 1;
      LODWORD(v4) = v20;
      uint64_t v15 = v19 - v20;
    }
    else
    {
      if (v12 > *((_DWORD *)this + 3)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      int v14 = (void *)(*(void *)this + 16 * *((unsigned int *)this + 2));
      uint64_t v15 = v12 - v4;
    }
    int v16 = v12 - v4;
    bzero(v14, 16 * v15);
    unsigned int v17 = v16 + *((_DWORD *)this + 2);
LABEL_14:
    unsigned int v5 = 0;
    *((_DWORD *)this + 2) = v17;
    goto LABEL_5;
  }
  unsigned int v5 = a2;
  do
    --v5;
  while (!*(_DWORD *)(*(void *)this + 16 * v5 + 12));
LABEL_5:
  uint64_t v6 = *(void *)this;
  uint64_t v7 = *(void *)this + 16 * v5;
  unsigned int v8 = *(_DWORD *)(v7 + 12) - 1;
  *(_DWORD *)(v7 + 12) = v8;
  uint64_t v9 = *(void *)(*(void *)v7 + 8 * v8);
  unsigned int v10 = v5 + 1;
  if (v10 != a2)
  {
    do
    {
      uint64_t v18 = *(void *)this + 16 * v10;
      *(void *)uint64_t v18 = v9 & 0xFFFFFFFFFFFFFFC0;
      *(_DWORD *)(v18 + 8) = (v9 & 0x3F) + 1;
      *(_DWORD *)(v18 + 12) = v9 & 0x3F;
      uint64_t v9 = *(void *)((v9 & 0xFFFFFFFFFFFFFFC0) + 8 * (v9 & 0x3F));
      ++v10;
    }
    while (a2 != v10);
    uint64_t v6 = *(void *)this;
  }
  uint64_t v11 = v6 + 16 * a2;
  *(void *)uint64_t v11 = v9 & 0xFFFFFFFFFFFFFFC0;
  *(_DWORD *)(v11 + 8) = (v9 & 0x3F) + 1;
  *(_DWORD *)(v11 + 12) = v9 & 0x3F;
}

uint64_t llvm::IntervalMapImpl::Path::getRightSibling(llvm::IntervalMapImpl::Path *this, int a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v2 = *(void *)this;
  int v3 = -1;
  while (1)
  {
    uint64_t v4 = (a2 + v3);
    if (!(a2 + v3)) {
      break;
    }
    int v5 = *(_DWORD *)(v2 + 16 * v4 + 12);
    int v6 = *(_DWORD *)(v2 + 16 * v4 + 8) - 1;
    --v3;
    if (v5 != v6)
    {
      int v7 = a2 + v3 + 2;
      goto LABEL_7;
    }
  }
  int v5 = *(_DWORD *)(v2 + 12);
  int v6 = *(_DWORD *)(v2 + 8) - 1;
  int v7 = 1;
LABEL_7:
  if (v5 == v6) {
    return 0;
  }
  uint64_t result = *(void *)(*(void *)(v2 + 16 * v4) + 8 * (v5 + 1));
  if (v7 != a2)
  {
    int v9 = a2 - v7;
    do
    {
      uint64_t result = *(void *)(result & 0xFFFFFFFFFFFFFFC0);
      --v9;
    }
    while (v9);
  }
  return result;
}

uint64_t *llvm::IntervalMapImpl::Path::moveRight(uint64_t *this, unsigned int a2)
{
  int v2 = 0;
  uint64_t v3 = *this;
  unsigned int v4 = a2 - 1;
  while (1)
  {
    int v5 = v2;
    uint64_t v6 = v4 + v2;
    if (!(v4 + v2)) {
      break;
    }
    int v8 = *(_DWORD *)(v3 + 16 * v6 + 8);
    int v7 = *(_DWORD *)(v3 + 16 * v6 + 12);
    --v2;
    if (v7 != v8 - 1) {
      goto LABEL_6;
    }
  }
  uint64_t v6 = 0;
  int v8 = *(_DWORD *)(v3 + 8);
  int v7 = *(_DWORD *)(v3 + 12);
LABEL_6:
  unsigned int v9 = v7 + 1;
  *(_DWORD *)(v3 + 16 * v6 + 12) = v9;
  if (v9 != v8)
  {
    uint64_t v10 = *(void *)(*(void *)(v3 + 16 * v6) + 8 * v9);
    if (v5)
    {
      do
      {
        uint64_t v12 = *this + 16 * (a2 + v5);
        *(void *)uint64_t v12 = v10 & 0xFFFFFFFFFFFFFFC0;
        *(_DWORD *)(v12 + 8) = (v10 & 0x3F) + 1;
        *(_DWORD *)(v12 + 12) = 0;
        uint64_t v10 = *(void *)(v10 & 0xFFFFFFFFFFFFFFC0);
      }
      while (!__CFADD__(v5++, 1));
      uint64_t v3 = *this;
    }
    uint64_t v11 = (unint64_t *)(v3 + 16 * a2);
    *uint64_t v11 = v10 & 0xFFFFFFFFFFFFFFC0;
    v11[1] = (v10 & 0x3F) + 1;
  }
  return this;
}

unint64_t llvm::IntervalMapImpl::distribute(llvm::IntervalMapImpl *this, int a2, unsigned int a3, unsigned int a4, const unsigned int *a5, unsigned int *a6, int a7)
{
  if (this)
  {
    unint64_t v7 = 0;
    unsigned int v8 = 0;
    LODWORD(v9) = 0;
    uint64_t v10 = this;
    unsigned int v11 = (a7 + a2) / this;
    unint64_t v12 = (a7 + a2) % this;
    do
    {
      if (v7 >= v12) {
        unsigned int v13 = v11;
      }
      else {
        unsigned int v13 = v11 + 1;
      }
      a5[v7] = v13;
      unsigned int v14 = a6 - v8;
      v8 += v13;
      if (this == v10 && v8 > a6)
      {
        LODWORD(this) = v7;
        uint64_t v9 = v14;
      }
      else
      {
        uint64_t v9 = v9;
      }
      ++v7;
    }
    while (v10 != v7);
    if (a7) {
      --a5[this];
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  return this | (unint64_t)(v9 << 32);
}

void llvm::ItaniumManglingCanonicalizer::ItaniumManglingCanonicalizer(llvm::ItaniumManglingCanonicalizer *this)
{
}

{
  operator new();
}

void llvm::ItaniumManglingCanonicalizer::~ItaniumManglingCanonicalizer(llvm::ItaniumManglingCanonicalizer *this)
{
  uint64_t v1 = *(void *)this;
  if (v1)
  {
    uint64_t v2 = sub_1CD83AB70(v1);
    MEMORY[0x1D25D9CE0](v2, 0x10F0C408BC9DC32);
  }
}

{
  uint64_t v1;
  uint64_t v2;

  uint64_t v1 = *(void *)this;
  if (v1)
  {
    uint64_t v2 = sub_1CD83AB70(v1);
    MEMORY[0x1D25D9CE0](v2, 0x10F0C408BC9DC32);
  }
}

uint64_t sub_1CD06A80C(uint64_t a1, char *__s2, uint64_t a3, uint64_t a4)
{
  unsigned int v4 = *(uint64_t **)a1;
  uint64_t v5 = **(void **)a1;
  *(void *)uint64_t v5 = __s2;
  *(void *)(v5 + 8) = &__s2[a3];
  *(void *)(v5 + 24) = *(void *)(v5 + 16);
  *(void *)(v5 + 304) = *(void *)(v5 + 296);
  *(void *)(v5 + 672) = *(void *)(v5 + 664);
  *(void *)(v5 + 784) = -1;
  *(_WORD *)(v5 + 776) = 1;
  *(void *)(v5 + 792) = 0;
  *(_DWORD *)(v5 + 800) = 0;
  *(void *)(v5 + 920) = 0;
  int v6 = **(_DWORD **)(a1 + 8);
  if (v6 == 2)
  {
    uint64_t result = sub_1CD06E7AC((unsigned __int8 **)v5);
    goto LABEL_11;
  }
  if (v6 == 1)
  {
LABEL_8:
    uint64_t result = sub_1CD06B2C4(v5, (uint64_t)__s2, a3, a4);
    goto LABEL_11;
  }
  uint64_t result = 0;
  if (v6) {
    goto LABEL_11;
  }
  if (!a3) {
    goto LABEL_10;
  }
  if (a3 != 2 || strncmp("St", __s2, 2uLL))
  {
    if (*__s2 == 83) {
      goto LABEL_8;
    }
LABEL_10:
    uint64_t result = sub_1CD06E334(v5, 0, a3, a4);
    goto LABEL_11;
  }
  *(void *)uint64_t v5 = __s2 + 2;
  uint64_t result = sub_1CD06AF4C(v5, "std");
LABEL_11:
  if (*(void *)(*v4 + 8) != *(void *)*v4) {
    return 0;
  }
  return result;
}

uint64_t sub_1CD06A938(uint64_t a1, char *__s2, unint64_t a3, char a4)
{
  v47[16] = *MEMORY[0x1E4F143B8];
  *(unsigned char *)(a1 + 937) = a4;
  *(void *)a1 = __s2;
  *(void *)(a1 + 8) = &__s2[a3];
  *(void *)(a1 + 24) = *(void *)(a1 + 16);
  *(void *)(a1 + 304) = *(void *)(a1 + 296);
  *(void *)(a1 + 672) = *(void *)(a1 + 664);
  *(void *)(a1 + 784) = -1;
  *(_WORD *)(a1 + 776) = 1;
  *(void *)(a1 + 792) = 0;
  *(_DWORD *)(a1 + 800) = 0;
  *(void *)(a1 + 920) = 0;
  if (a3 < 2
    || *(_WORD *)__s2 != 23135
    && (a3 < 3
     || (*(_WORD *)__s2 == 24415 ? (BOOL v6 = __s2[2] == 90) : (BOOL v6 = 0),
         !v6
      && (a3 < 4
       || *(_DWORD *)__s2 != 1516199775
       && (a3 < 5 || (*(_DWORD *)__s2 == 1600085855 ? (BOOL v7 = __s2[4] == 90) : (BOOL v7 = 0), !v7))))))
  {
    *(void *)&long long v46 = __s2;
    *((void *)&v46 + 1) = &__s2[a3];
    return sub_1CD077500(a1, &v46);
  }
  uint64_t v10 = 2;
  if (strncmp("_Z", __s2, 2uLL))
  {
    if (a3 < 3)
    {
LABEL_23:
      uint64_t result = sub_1CD06B2C4(a1, v11, v12, v13);
      if (*(void *)(a1 + 8) != *(void *)a1) {
        return 0;
      }
      return result;
    }
    uint64_t v10 = 3;
    if (strncmp("__Z", __s2, 3uLL))
    {
      if (a3 < 4) {
        goto LABEL_23;
      }
      uint64_t v14 = 4;
      if (strncmp("___Z", __s2, 4uLL))
      {
        if (a3 < 5) {
          goto LABEL_23;
        }
        uint64_t v14 = 5;
        if (strncmp("____Z", __s2, 5uLL)) {
          goto LABEL_23;
        }
      }
      *(void *)a1 = &__s2[v14];
      uint64_t result = sub_1CD06E7AC((unsigned __int8 **)a1);
      *(void *)&long long v46 = result;
      if (!result) {
        return result;
      }
      uint64_t v26 = *(unsigned __int8 **)a1;
      size_t v27 = *(unsigned __int8 **)(a1 + 8);
      if ((unint64_t)&v27[-*(void *)a1] < 0xD || strncmp("_block_invoke", *(const char **)a1, 0xDuLL)) {
        return 0;
      }
      *(void *)a1 = v26 + 13;
      if (v26 + 13 == v27 || v26[13] != 95)
      {
        sub_1CC6B5BE0((char **)a1, 0);
      }
      else
      {
        *(void *)a1 = v26 + 14;
        size_t v28 = sub_1CC6B5BE0((char **)a1, 0);
        if (v28 == v29) {
          return 0;
        }
      }
      uint64_t v30 = *(void *)(a1 + 8);
      if (v30 != *(void *)a1)
      {
        if (**(unsigned char **)a1 != 46) {
          return 0;
        }
        *(void *)a1 = v30;
      }
      return sub_1CD08985C(a1, "invocation function for block in ", (uint64_t *)&v46);
    }
  }
  *(void *)a1 = &__s2[v10];
  uint64_t result = sub_1CD06E7AC((unsigned __int8 **)a1);
  if (!result) {
    return result;
  }
  uint64_t v15 = result;
  int v16 = *(unsigned __int8 **)a1;
  unsigned int v17 = *(unsigned __int8 **)(a1 + 8);
  uint64_t v18 = &v17[-*(void *)a1];
  if (v17 == *(unsigned __int8 **)a1)
  {
    int v16 = *(unsigned __int8 **)(a1 + 8);
  }
  else if (*v16 == 46)
  {
    int v19 = *(unsigned __int8 *)(a1 + 937);
    uint64_t v43 = (char *)&v44 + 8;
    uint64_t v45 = result;
    long long v44 = xmmword_1CFB2EA40;
    llvm::FoldingSetNodeID::AddString((unsigned int *)&v43, v16, v18);
    unint64_t v20 = sub_1CC13A6B8(v43, (uint64_t)v43 + 4 * v44);
    uint64_t v22 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v20);
    size_t v23 = *(unsigned int **)v22;
    *(void *)&long long v46 = v47;
    *((void *)&v46 + 1) = 0x2000000000;
    if (v23 && (v23 & 1) == 0)
    {
      while (1)
      {
        LOBYTE(v20) = sub_1CD071418(v20, v23, (uint64_t)&v43, v21, (unsigned int *)&v46);
        if (v20) {
          break;
        }
        DWORD2(v46) = 0;
        size_t v23 = *(unsigned int **)v23;
        if (v23) {
          BOOL v24 = (v23 & 1) == 0;
        }
        else {
          BOOL v24 = 0;
        }
        if (!v24)
        {
          size_t v23 = 0;
          goto LABEL_39;
        }
      }
      uint64_t v22 = 0;
LABEL_39:
      if ((void *)v46 == v47)
      {
        if (v23)
        {
LABEL_41:
          int v25 = 0;
          uint64_t v15 = (uint64_t)(v23 + 2);
LABEL_64:
          if (v43 != (char *)&v44 + 8) {
            free(v43);
          }
          if (v25)
          {
            *(void *)(a1 + 920) = v15;
          }
          else if (v15)
          {
            *(void *)&long long v46 = 0;
            int v37 = sub_1CD640748(a1 + 944, v15, &v46);
            uint64_t v38 = 0;
            if (v37) {
              uint64_t v38 = *(void *)(v46 + 8);
            }
            if (v38) {
              uint64_t v15 = v38;
            }
            if (v15 == *(void *)(a1 + 928)) {
              *(unsigned char *)(a1 + 936) = 1;
            }
          }
          int v16 = *(unsigned __int8 **)(a1 + 8);
          *(void *)a1 = v16;
          unsigned int v17 = v16;
          goto LABEL_70;
        }
      }
      else
      {
        free((void *)v46);
        if (v23) {
          goto LABEL_41;
        }
      }
    }
    if (v19)
    {
      *(void *)(a1 + 888) += 48;
      uint64_t v31 = *(void *)(a1 + 808);
      if (((v31 + 7) & 0xFFFFFFFFFFFFFFF8) - v31 + 48 > *(void *)(a1 + 816) - v31)
      {
        unsigned int v39 = *(_DWORD *)(a1 + 832) >> 7;
        if (v39 >= 0x1E) {
          LOBYTE(v39) = 30;
        }
        uint64_t v40 = 4096 << v39;
        unint64_t v32 = (unint64_t)operator new(4096 << v39, (std::align_val_t)8uLL);
        unsigned int v41 = *(_DWORD *)(a1 + 832);
        if (v41 >= *(_DWORD *)(a1 + 836)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 824) + 8 * v41) = v32;
        ++*(_DWORD *)(a1 + 832);
        *(void *)(a1 + 816) = v32 + v40;
      }
      else
      {
        unint64_t v32 = (v31 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(a1 + 808) = v32 + 48;
      uint64_t v33 = v32 + 8;
      *(unsigned char *)(v32 + 16) = 1;
      *(_WORD *)(v32 + 17) = *(_WORD *)(v32 + 17) & 0xF000 | 0x540;
      *(void *)unint64_t v32 = 0;
      *(void *)(v32 + 8) = &unk_1F261AC80;
      *(void *)(v32 + 24) = v15;
      *(void *)(v32 + 32) = v16;
      *(void *)(v32 + 40) = v17;
      unsigned int v34 = *(_DWORD *)(a1 + 916) + 1;
      int v35 = *(_DWORD *)(a1 + 912);
      if (v34 > 2 * v35)
      {
        std::error_code v42 = (unsigned int *)v32;
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v35, (uint64_t)off_1F2644D00);
        *(void *)&long long v46 = v47;
        *((void *)&v46 + 1) = 0x2000000000;
        sub_1CD0714B4(v42, (unsigned int *)&v46);
        uint64_t v22 = *(void *)(a1 + 904)
            + 8 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8((void *)v46, v46 + 4 * DWORD2(v46)));
        if ((void *)v46 != v47) {
          free((void *)v46);
        }
        unsigned int v34 = *(_DWORD *)(a1 + 916) + 1;
        unint64_t v32 = (unint64_t)v42;
      }
      *(_DWORD *)(a1 + 916) = v34;
      uint64_t v36 = *(void *)v22;
      if (!*(void *)v22) {
        uint64_t v36 = v22 | 1;
      }
      *(void *)unint64_t v32 = v36;
      *(void *)uint64_t v22 = v32;
      int v25 = 1;
      uint64_t v15 = v33;
    }
    else
    {
      uint64_t v15 = 0;
      int v25 = 1;
    }
    goto LABEL_64;
  }
LABEL_70:
  if (v17 == v16) {
    return v15;
  }
  else {
    return 0;
  }
}

uint64_t sub_1CD06AF4C(uint64_t a1, char *__s)
{
  v30[16] = *MEMORY[0x1E4F143B8];
  int v4 = *(unsigned __int8 *)(a1 + 937);
  uint64_t v26 = &v27[2];
  *(_OWORD *)size_t v27 = xmmword_1CFB2EA50;
  unsigned int v5 = strlen(__s);
  llvm::FoldingSetNodeID::AddString((unsigned int *)&v26, (unsigned __int8 *)__s, v5);
  unint64_t v6 = sub_1CC13A6B8(v26, (uint64_t)v26 + 4 * v27[0]);
  uint64_t v8 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v6);
  uint64_t v9 = *(unsigned int **)v8;
  size_t v28 = v30;
  uint64_t v29 = 0x2000000000;
  if (v9) {
    BOOL v10 = (v9 & 1) == 0;
  }
  else {
    BOOL v10 = 0;
  }
  if (!v10) {
    goto LABEL_17;
  }
  while (1)
  {
    LOBYTE(v6) = sub_1CD071418(v6, v9, (uint64_t)&v26, v7, (unsigned int *)&v28);
    if (v6) {
      break;
    }
    LODWORD(v29) = 0;
    uint64_t v9 = *(unsigned int **)v9;
    if (v9) {
      BOOL v11 = (v9 & 1) == 0;
    }
    else {
      BOOL v11 = 0;
    }
    if (!v11)
    {
      uint64_t v9 = 0;
      goto LABEL_13;
    }
  }
  uint64_t v8 = 0;
LABEL_13:
  if (v28 == v30)
  {
    if (v9)
    {
LABEL_15:
      int v12 = 0;
      uint64_t v13 = (uint64_t)(v9 + 2);
      goto LABEL_26;
    }
  }
  else
  {
    free(v28);
    if (v9) {
      goto LABEL_15;
    }
  }
LABEL_17:
  if (v4)
  {
    *(void *)(a1 + 888) += 40;
    uint64_t v14 = *(void *)(a1 + 808);
    if (((v14 + 7) & 0xFFFFFFFFFFFFFFF8) - v14 + 40 > *(void *)(a1 + 816) - v14)
    {
      unsigned int v23 = *(_DWORD *)(a1 + 832) >> 7;
      if (v23 >= 0x1E) {
        LOBYTE(v23) = 30;
      }
      uint64_t v24 = 4096 << v23;
      unint64_t v15 = (unint64_t)operator new(4096 << v23, (std::align_val_t)8uLL);
      unsigned int v25 = *(_DWORD *)(a1 + 832);
      if (v25 >= *(_DWORD *)(a1 + 836)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(a1 + 824) + 8 * v25) = v15;
      ++*(_DWORD *)(a1 + 832);
      *(void *)(a1 + 816) = v15 + v24;
    }
    else
    {
      unint64_t v15 = (v14 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    *(void *)(a1 + 808) = v15 + 40;
    *(void *)unint64_t v15 = 0;
    uint64_t v13 = v15 + 8;
    size_t v16 = strlen(__s);
    *(unsigned char *)(v15 + 16) = 7;
    *(_WORD *)(v15 + 17) = *(_WORD *)(v15 + 17) & 0xF000 | 0x540;
    *(void *)(v15 + 8) = &unk_1F26197E0;
    *(void *)(v15 + 24) = __s;
    *(void *)(v15 + 32) = &__s[v16];
    unsigned int v17 = *(_DWORD *)(a1 + 916) + 1;
    int v18 = *(_DWORD *)(a1 + 912);
    if (v17 > 2 * v18)
    {
      llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v18, (uint64_t)off_1F2644D00);
      size_t v28 = v30;
      uint64_t v29 = 0x2000000000;
      sub_1CD0714B4((unsigned int *)v15, (unsigned int *)&v28);
      uint64_t v8 = *(void *)(a1 + 904)
         + 8 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v28, (uint64_t)v28 + 4 * v29));
      if (v28 != v30) {
        free(v28);
      }
      unsigned int v17 = *(_DWORD *)(a1 + 916) + 1;
    }
    *(_DWORD *)(a1 + 916) = v17;
    uint64_t v19 = *(void *)v8;
    if (!*(void *)v8) {
      uint64_t v19 = v8 | 1;
    }
    *(void *)unint64_t v15 = v19;
    *(void *)uint64_t v8 = v15;
  }
  else
  {
    uint64_t v13 = 0;
  }
  int v12 = 1;
LABEL_26:
  if (v26 != &v27[2]) {
    free(v26);
  }
  if (v12)
  {
    *(void *)(a1 + 920) = v13;
  }
  else if (v13)
  {
    size_t v28 = 0;
    int v21 = sub_1CD640748(a1 + 944, v13, &v28);
    uint64_t v22 = 0;
    if (v21) {
      uint64_t v22 = *((void *)v28 + 1);
    }
    if (v22) {
      uint64_t v13 = v22;
    }
    if (v13 == *(void *)(a1 + 928)) {
      *(unsigned char *)(a1 + 936) = 1;
    }
  }
  return v13;
}

uint64_t sub_1CD06B2C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a1;
  v256[16] = *MEMORY[0x1E4F143B8];
  uint64_t v249 = 0;
  unint64_t v6 = *(char **)a1;
  unsigned int v5 = *(char **)(a1 + 8);
  unint64_t v7 = (unint64_t)&v5[-*(void *)a1];
  if (v5 == *(char **)a1)
  {
LABEL_129:
    uint64_t v17 = sub_1CD07CC88(a1, a2, a3, a4);
LABEL_130:
    uint64_t v31 = v17;
    goto LABEL_131;
  }
  int v8 = *v6;
  switch(*v6)
  {
    case 'A':
      if (v8 != 65) {
        return 0;
      }
      *(void *)a1 = v6 + 1;
      if (v5 == v6 + 1)
      {
        if ((*(unsigned char *)(MEMORY[0x1E4F14390] + 61) & 4) != 0)
        {
LABEL_254:
          *(void *)&long long v255 = sub_1CC6B5BE0((char **)a1, 0);
          *((void *)&v255 + 1) = v111;
          uint64_t v110 = sub_1CD077500(v4, &v255);
          if (!v110) {
            return 0;
          }
LABEL_255:
          unint64_t v112 = *(char **)v4;
          if (*(void *)v4 == *(void *)(v4 + 8) || *v112 != 95) {
            return 0;
          }
          uint64_t v33 = v110;
          unsigned int v34 = v112 + 1;
LABEL_258:
          *(void *)uint64_t v4 = v34;
          uint64_t v113 = sub_1CD06B2C4(v4);
          if (!v113) {
            return 0;
          }
          uint64_t v115 = v113;
          int v116 = *(unsigned __int8 *)(v4 + 937);
          uint64_t v251 = (char *)&v252 + 8;
          uint64_t v253 = v113;
          BOOL v254 = v33;
          long long v252 = xmmword_1CFB2EA90;
          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
          {
            uint64_t v113 = __cxa_guard_acquire(&qword_1EBCBE588);
            if (v113)
            {
              unint64_t v240 = llvm::hashing::detail::fixed_seed_override;
              if (!llvm::hashing::detail::fixed_seed_override) {
                unint64_t v240 = 0xFF51AFD7ED558CCDLL;
              }
              qword_1EBCBE580 = v240;
              __cxa_guard_release(&qword_1EBCBE588);
            }
          }
          uint64_t v117 = __ROR8__(0xB492B66FBE98F273 * *((void *)&v252 + 1) - v253, 43)
               - 0x3C5A37A36834CED9 * v253
               + __ROR8__((0x9AE16A3B2F90404FLL * v254) ^ qword_1EBCBE580, 30);
          unint64_t v118 = qword_1EBCBE580
               + __ROR8__(v253 ^ 0xC949D7C7509E6557, 20)
               - 0x4B6D499041670D8DLL * *((void *)&v252 + 1)
               - 0x9AE16A3B2F90404FLL * v254
               + 24;
          unint64_t v119 = 0x9DDFEA08EB382D69
               * (v118 ^ ((0x9DDFEA08EB382D69 * (v117 ^ v118)) >> 47) ^ (0x9DDFEA08EB382D69 * (v117 ^ v118)));
          uint64_t v45 = *(void *)(v4 + 904)
              + 8 * ((-348639895 * ((v119 >> 47) ^ v119)) & (*(_DWORD *)(v4 + 912) - 1));
          long long v46 = *(unsigned int **)v45;
          *(void *)&long long v255 = v256;
          *((void *)&v255 + 1) = 0x2000000000;
          if (v46) {
            BOOL v120 = (v46 & 1) == 0;
          }
          else {
            BOOL v120 = 0;
          }
          if (v120)
          {
            while (1)
            {
              LOBYTE(v113) = sub_1CD071418(v113, v46, (uint64_t)&v251, v114, (unsigned int *)&v255);
              if (v113) {
                break;
              }
              DWORD2(v255) = 0;
              long long v46 = *(unsigned int **)v46;
              if (v46) {
                BOOL v121 = (v46 & 1) == 0;
              }
              else {
                BOOL v121 = 0;
              }
              if (!v121)
              {
                long long v46 = 0;
                goto LABEL_295;
              }
            }
            uint64_t v45 = 0;
LABEL_295:
            if ((void *)v255 == v256)
            {
              if (v46) {
                goto LABEL_297;
              }
            }
            else
            {
              free((void *)v255);
              if (v46) {
                goto LABEL_297;
              }
            }
          }
          if (!v116) {
            goto LABEL_505;
          }
          *(void *)(v4 + 888) += 40;
          uint64_t v218 = *(void *)(v4 + 808);
          if (((v218 + 7) & 0xFFFFFFFFFFFFFFF8) - v218 + 40 > *(void *)(v4 + 816) - v218)
          {
            unsigned int v221 = *(_DWORD *)(v4 + 832) >> 7;
            if (v221 >= 0x1E) {
              LOBYTE(v221) = 30;
            }
            uint64_t v222 = 4096 << v221;
            size_t v248 = (char *)operator new(4096 << v221, (std::align_val_t)8uLL);
            unsigned int v223 = *(_DWORD *)(v4 + 832);
            if (v223 >= *(_DWORD *)(v4 + 836)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            unint64_t v95 = (unint64_t)v248;
            *(void *)(*(void *)(v4 + 824) + 8 * v223) = v248;
            ++*(_DWORD *)(v4 + 832);
            *(void *)(v4 + 816) = &v248[v222];
          }
          else
          {
            unint64_t v95 = (v218 + 7) & 0xFFFFFFFFFFFFFFF8;
          }
          *(void *)(v4 + 808) = v95 + 40;
          uint64_t v31 = v95 + 8;
          *(unsigned char *)(v95 + 16) = 14;
          *(_WORD *)(v95 + 17) = *(_WORD *)(v95 + 17) & 0xF000 | 0x400;
          *(void *)unint64_t v95 = 0;
          *(void *)(v95 + 8) = &unk_1F261B048;
          *(void *)(v95 + 24) = v115;
          *(void *)(v95 + 32) = v33;
LABEL_228:
          unsigned int v98 = *(_DWORD *)(v4 + 916) + 1;
          int v99 = *(_DWORD *)(v4 + 912);
          if (v98 > 2 * v99)
          {
            BOOL v204 = (unsigned int *)v95;
            llvm::FoldingSetBase::GrowBucketCount(v4 + 904, 2 * v99, (uint64_t)off_1F2644D00);
            *(void *)&long long v255 = v256;
            *((void *)&v255 + 1) = 0x2000000000;
            sub_1CD0714B4(v204, (unsigned int *)&v255);
            uint64_t v45 = *(void *)(v4 + 904)
                + 8
                * ((*(_DWORD *)(v4 + 912) - 1) & sub_1CC13A6B8((void *)v255, v255 + 4 * DWORD2(v255)));
            if ((void *)v255 != v256) {
              free((void *)v255);
            }
            unsigned int v98 = *(_DWORD *)(v4 + 916) + 1;
            unint64_t v95 = (unint64_t)v204;
          }
          *(_DWORD *)(v4 + 916) = v98;
          uint64_t v100 = *(void *)v45;
          if (!*(void *)v45) {
            uint64_t v100 = v45 | 1;
          }
          *(void *)unint64_t v95 = v100;
          *(void *)uint64_t v45 = v95;
LABEL_506:
          int v134 = 1;
          goto LABEL_507;
        }
      }
      else if ((v6[1] & 0x80000000) == 0)
      {
        uint64_t v32 = v6[1];
        if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v32 + 60) & 0x400) == 0)
        {
          if (v32 == 95)
          {
            uint64_t v33 = 0;
            unsigned int v34 = v6 + 2;
            goto LABEL_258;
          }
          goto LABEL_252;
        }
        goto LABEL_254;
      }
LABEL_252:
      uint64_t v110 = sub_1CD077868(a1);
      if (!v110) {
        return 0;
      }
      goto LABEL_255;
    case 'C':
      *(void *)a1 = v6 + 1;
      uint64_t v40 = sub_1CD06B2C4(a1);
      if (!v40) {
        return 0;
      }
      uint64_t v41 = v40;
      int v42 = *(unsigned __int8 *)(v4 + 937);
      uint64_t v251 = (char *)&v252 + 8;
      uint64_t v253 = v40;
      long long v252 = xmmword_1CFB2EA60;
      llvm::FoldingSetNodeID::AddString((unsigned int *)&v251, " complex", 8u);
      unint64_t v43 = sub_1CC13A6B8(v251, (uint64_t)v251 + 4 * v252);
      uint64_t v45 = *(void *)(v4 + 904) + 8 * ((*(_DWORD *)(v4 + 912) - 1) & v43);
      long long v46 = *(unsigned int **)v45;
      *(void *)&long long v255 = v256;
      *((void *)&v255 + 1) = 0x2000000000;
      if (v46) {
        BOOL v47 = (v46 & 1) == 0;
      }
      else {
        BOOL v47 = 0;
      }
      if (!v47) {
        goto LABEL_216;
      }
      while (1)
      {
        LOBYTE(v43) = sub_1CD071418(v43, v46, (uint64_t)&v251, v44, (unsigned int *)&v255);
        if (v43) {
          break;
        }
        DWORD2(v255) = 0;
        long long v46 = *(unsigned int **)v46;
        if (v46) {
          BOOL v48 = (v46 & 1) == 0;
        }
        else {
          BOOL v48 = 0;
        }
        if (!v48)
        {
          long long v46 = 0;
          goto LABEL_214;
        }
      }
      uint64_t v45 = 0;
LABEL_214:
      if ((void *)v255 == v256)
      {
        if (v46) {
          goto LABEL_297;
        }
      }
      else
      {
        free((void *)v255);
        if (v46) {
          goto LABEL_297;
        }
      }
LABEL_216:
      if (!v42) {
        goto LABEL_505;
      }
      *(void *)(v4 + 888) += 48;
      uint64_t v94 = *(void *)(v4 + 808);
      if (((v94 + 7) & 0xFFFFFFFFFFFFFFF8) - v94 + 48 > *(void *)(v4 + 816) - v94)
      {
        unsigned int v177 = *(_DWORD *)(v4 + 832) >> 7;
        if (v177 >= 0x1E) {
          LOBYTE(v177) = 30;
        }
        uint64_t v178 = 4096 << v177;
        uint64_t v245 = (char *)operator new(4096 << v177, (std::align_val_t)8uLL);
        unsigned int v179 = *(_DWORD *)(v4 + 832);
        if (v179 >= *(_DWORD *)(v4 + 836)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        unint64_t v95 = (unint64_t)v245;
        *(void *)(*(void *)(v4 + 824) + 8 * v179) = v245;
        ++*(_DWORD *)(v4 + 832);
        *(void *)(v4 + 816) = &v245[v178];
      }
      else
      {
        unint64_t v95 = (v94 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(v4 + 808) = v95 + 48;
      uint64_t v31 = v95 + 8;
      *(unsigned char *)(v95 + 16) = 5;
      *(_WORD *)(v95 + 17) = *(_WORD *)(v95 + 17) & 0xF000 | 0x540;
      *(void *)unint64_t v95 = 0;
      *(void *)(v95 + 8) = &unk_1F261B200;
      *(void *)(v95 + 24) = v41;
      *(void *)(v95 + 32) = " complex";
      BOOL v96 = "";
      goto LABEL_227;
    case 'D':
      if (v7 < 2) {
        return 0;
      }
      uint64_t v31 = 0;
      int v71 = v6[1];
      switch(v6[1])
      {
        case 'O':
        case 'o':
        case 'w':
        case 'x':
          goto LABEL_250;
        case 'P':
        case 'Q':
        case 'R':
        case 'S':
        case 'V':
        case 'W':
        case 'X':
        case 'Y':
        case 'Z':
        case '[':
        case '\\':
        case ']':
        case '^':
        case '_':
        case 'b':
        case 'g':
        case 'j':
        case 'k':
        case 'l':
        case 'm':
        case 'q':
        case 'r':
          return v31;
        case 'T':
        case 't':
          uint64_t v17 = sub_1CD07C41C(a1);
          goto LABEL_130;
        case 'U':
          goto LABEL_298;
        case 'a':
          *(void *)a1 = v6 + 2;
          uint64_t v26 = "auto";
          goto LABEL_186;
        case 'c':
          *(void *)a1 = v6 + 2;
          uint64_t v26 = "decltype(auto)";
          goto LABEL_158;
        case 'd':
          *(void *)a1 = v6 + 2;
          uint64_t v26 = "decimal64";
          goto LABEL_178;
        case 'e':
          *(void *)a1 = v6 + 2;
          uint64_t v26 = "decimal128";
          goto LABEL_56;
        case 'f':
          *(void *)a1 = v6 + 2;
          uint64_t v26 = "decimal32";
          goto LABEL_178;
        case 'h':
          *(void *)a1 = v6 + 2;
          uint64_t v26 = "half";
          goto LABEL_186;
        case 'i':
          *(void *)a1 = v6 + 2;
          uint64_t v26 = "char32_t";
          goto LABEL_30;
        case 'n':
          *(void *)a1 = v6 + 2;
          uint64_t v26 = "std::nullptr_t";
          goto LABEL_158;
        case 'p':
          *(void *)a1 = v6 + 2;
          *(void *)&long long v255 = sub_1CD06B2C4(a1);
          if (!(void)v255) {
            return 0;
          }
          uint64_t v17 = sub_1CD07C88C(v4, (uint64_t *)&v255, v138, v139);
          goto LABEL_130;
        case 's':
          *(void *)a1 = v6 + 2;
          uint64_t v26 = "char16_t";
          goto LABEL_30;
        case 'u':
          *(void *)a1 = v6 + 2;
          uint64_t v26 = "char8_t";
          goto LABEL_48;
        case 'v':
          if (strncmp("Dv", v6, 2uLL)) {
            return 0;
          }
          *(void *)uint64_t v4 = v6 + 2;
          if (v5 == v6 + 2 || v6[2] < 49) {
            goto LABEL_417;
          }
          unsigned int v140 = v6[2];
          if (v140 <= 0x39)
          {
            *(void *)&long long v255 = sub_1CC6B5BE0((char **)v4, 0);
            *((void *)&v255 + 1) = v141;
            uint64_t v142 = sub_1CD077500(v4, &v255);
            uint64_t v250 = v142;
            if (v142)
            {
              uint64_t v144 = *(char **)v4;
              unint64_t v145 = *(char **)(v4 + 8);
              if (*(char **)v4 != v145 && *v144 == 95)
              {
                *(void *)uint64_t v4 = v144 + 1;
                if (v144 + 1 != v145 && v144[1] == 112)
                {
                  uint64_t v146 = v142;
                  *(void *)uint64_t v4 = v144 + 2;
                  int v147 = *(unsigned __int8 *)(v4 + 937);
                  uint64_t v251 = (char *)&v252 + 8;
                  uint64_t v253 = v142;
                  long long v252 = xmmword_1CFB2EAB0;
                  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
                  {
                    uint64_t v142 = __cxa_guard_acquire(&qword_1EBCBE588);
                    if (v142)
                    {
                      unint64_t v244 = llvm::hashing::detail::fixed_seed_override;
                      if (!llvm::hashing::detail::fixed_seed_override) {
                        unint64_t v244 = 0xFF51AFD7ED558CCDLL;
                      }
                      qword_1EBCBE580 = v244;
                      __cxa_guard_release(&qword_1EBCBE588);
                    }
                  }
                  unint64_t v148 = 0x9DDFEA08EB382D69 * (*((void *)&v252 + 1) ^ qword_1EBCBE580 ^ __ROR8__(v253 + 16, 16));
                  unint64_t v149 = __ROR8__(v253 + 16, 16) ^ (v148 >> 47);
                  uint64_t v150 = *(void *)(v4 + 904)
                       + 8
                       * ((*(_DWORD *)(v4 + 912) - 1) & ((-348639895
                                                        * ((((0x9DDFEA08EB382D69 * (v149 ^ v148)) >> 32) >> 15) ^ (-348639895 * (v149 ^ v148)))) ^ v253));
                  uint64_t v151 = *(unsigned int **)v150;
                  *(void *)&long long v255 = v256;
                  *((void *)&v255 + 1) = 0x2000000000;
                  if (v151) {
                    BOOL v152 = (v151 & 1) == 0;
                  }
                  else {
                    BOOL v152 = 0;
                  }
                  if (!v152) {
                    goto LABEL_541;
                  }
                  while (1)
                  {
                    LOBYTE(v142) = sub_1CD071418(v142, v151, (uint64_t)&v251, v143, (unsigned int *)&v255);
                    if (v142) {
                      break;
                    }
                    DWORD2(v255) = 0;
                    uint64_t v151 = *(unsigned int **)v151;
                    if (v151) {
                      BOOL v153 = (v151 & 1) == 0;
                    }
                    else {
                      BOOL v153 = 0;
                    }
                    if (!v153)
                    {
                      uint64_t v151 = 0;
                      goto LABEL_490;
                    }
                  }
                  uint64_t v150 = 0;
LABEL_490:
                  if ((void *)v255 == v256)
                  {
                    if (v151)
                    {
LABEL_492:
                      int v214 = 0;
                      uint64_t v31 = (uint64_t)(v151 + 2);
                      goto LABEL_550;
                    }
                  }
                  else
                  {
                    free((void *)v255);
                    if (v151) {
                      goto LABEL_492;
                    }
                  }
LABEL_541:
                  if (v147)
                  {
                    *(void *)(v4 + 888) += 32;
                    uint64_t v230 = *(void *)(v4 + 808);
                    if (((v230 + 7) & 0xFFFFFFFFFFFFFFF8) - v230 + 32 > *(void *)(v4 + 816) - v230)
                    {
                      unsigned int v235 = *(_DWORD *)(v4 + 832) >> 7;
                      if (v235 >= 0x1E) {
                        LOBYTE(v235) = 30;
                      }
                      uint64_t v236 = 4096 << v235;
                      unint64_t v231 = (unint64_t)operator new(4096 << v235, (std::align_val_t)8uLL);
                      unsigned int v237 = *(_DWORD *)(v4 + 832);
                      if (v237 >= *(_DWORD *)(v4 + 836)) {
                        llvm::SmallVectorBase<unsigned int>::grow_pod();
                      }
                      *(void *)(*(void *)(v4 + 824) + 8 * v237) = v231;
                      ++*(_DWORD *)(v4 + 832);
                      *(void *)(v4 + 816) = v231 + v236;
                    }
                    else
                    {
                      unint64_t v231 = (v230 + 7) & 0xFFFFFFFFFFFFFFF8;
                    }
                    *(void *)(v4 + 808) = v231 + 32;
                    uint64_t v31 = v231 + 8;
                    *(unsigned char *)(v231 + 16) = 28;
                    *(_WORD *)(v231 + 17) = *(_WORD *)(v231 + 17) & 0xF000 | 0x540;
                    *(void *)unint64_t v231 = 0;
                    *(void *)(v231 + 8) = &unk_1F261AF98;
                    *(void *)(v231 + 24) = v146;
                    unsigned int v232 = *(_DWORD *)(v4 + 916) + 1;
                    int v233 = *(_DWORD *)(v4 + 912);
                    if (v232 > 2 * v233)
                    {
                      llvm::FoldingSetBase::GrowBucketCount(v4 + 904, 2 * v233, (uint64_t)off_1F2644D00);
                      *(void *)&long long v255 = v256;
                      *((void *)&v255 + 1) = 0x2000000000;
                      sub_1CD0714B4((unsigned int *)v231, (unsigned int *)&v255);
                      uint64_t v150 = *(void *)(v4 + 904)
                           + 8
                           * ((*(_DWORD *)(v4 + 912) - 1) & sub_1CC13A6B8((void *)v255, v255 + 4 * DWORD2(v255)));
                      if ((void *)v255 != v256) {
                        free((void *)v255);
                      }
                      unsigned int v232 = *(_DWORD *)(v4 + 916) + 1;
                    }
                    *(_DWORD *)(v4 + 916) = v232;
                    uint64_t v234 = *(void *)v150;
                    if (!*(void *)v150) {
                      uint64_t v234 = v150 | 1;
                    }
                    *(void *)unint64_t v231 = v234;
                    *(void *)uint64_t v150 = v231;
                  }
                  else
                  {
                    uint64_t v31 = 0;
                  }
                  int v214 = 1;
LABEL_550:
                  if (v251 != (char *)&v252 + 8) {
                    free(v251);
                  }
                  if (v214) {
                    goto LABEL_510;
                  }
                  if (v31)
                  {
LABEL_512:
                    *(void *)&long long v255 = 0;
                    int v219 = sub_1CD640748(v4 + 944, v31, &v255);
                    uint64_t v220 = 0;
                    if (v219) {
                      uint64_t v220 = *(void *)(v255 + 8);
                    }
                    if (v220) {
                      uint64_t v31 = v220;
                    }
                    if (v31 == *(void *)(v4 + 928)) {
                      *(unsigned char *)(v4 + 936) = 1;
                    }
                  }
LABEL_131:
                  if (v31)
                  {
LABEL_132:
                    uint64_t v70 = *(uint64_t **)(v4 + 304);
                    if (v70 == *(uint64_t **)(v4 + 312))
                    {
                      sub_1CD5F0ACC(v4 + 296, ((uint64_t)v70 - *(void *)(v4 + 296)) >> 2);
                      uint64_t v70 = *(uint64_t **)(v4 + 304);
                    }
                    *(void *)(v4 + 304) = v70 + 1;
                    uint64_t *v70 = v31;
                  }
                  return v31;
                }
                *(void *)&long long v255 = sub_1CD06B2C4(v4);
                if ((void)v255)
                {
                  size_t v198 = (uint64_t *)&v255;
                  v199 = &v250;
                  goto LABEL_422;
                }
              }
            }
            goto LABEL_473;
          }
          if (v140 != 95)
          {
LABEL_417:
            *(void *)&long long v255 = sub_1CD077868(v4);
            if ((void)v255)
            {
              v196 = *(char **)v4;
              if (*(void *)v4 != *(void *)(v4 + 8) && *v196 == 95)
              {
                *(void *)uint64_t v4 = v196 + 1;
                uint64_t v251 = (void *)sub_1CD06B2C4(v4);
                if (v251)
                {
                  size_t v198 = (uint64_t *)&v251;
                  v199 = (uint64_t *)&v255;
LABEL_422:
                  uint64_t v17 = sub_1CD086D28(v4, v198, v199, v197);
                  goto LABEL_130;
                }
              }
            }
LABEL_473:
            uint64_t v31 = 0;
            goto LABEL_131;
          }
          *(void *)uint64_t v4 = v6 + 3;
          uint64_t v187 = sub_1CD06B2C4(v4);
          if (!v187) {
            return 0;
          }
          uint64_t v189 = v187;
          int v190 = *(unsigned __int8 *)(v4 + 937);
          uint64_t v251 = (char *)&v252 + 8;
          uint64_t v253 = v187;
          BOOL v254 = 0;
          long long v252 = xmmword_1CFB2EAA0;
          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
          {
            uint64_t v187 = __cxa_guard_acquire(&qword_1EBCBE588);
            if (v187)
            {
              unint64_t v243 = llvm::hashing::detail::fixed_seed_override;
              if (!llvm::hashing::detail::fixed_seed_override) {
                unint64_t v243 = 0xFF51AFD7ED558CCDLL;
              }
              qword_1EBCBE580 = v243;
              __cxa_guard_release(&qword_1EBCBE588);
            }
          }
          uint64_t v191 = __ROR8__(0xB492B66FBE98F273 * *((void *)&v252 + 1) - v253, 43)
               - 0x3C5A37A36834CED9 * v253
               + __ROR8__((0x9AE16A3B2F90404FLL * v254) ^ qword_1EBCBE580, 30);
          unint64_t v192 = qword_1EBCBE580
               + __ROR8__(v253 ^ 0xC949D7C7509E6557, 20)
               - 0x4B6D499041670D8DLL * *((void *)&v252 + 1)
               - 0x9AE16A3B2F90404FLL * v254
               + 24;
          unint64_t v193 = 0x9DDFEA08EB382D69
               * (v192 ^ ((0x9DDFEA08EB382D69 * (v191 ^ v192)) >> 47) ^ (0x9DDFEA08EB382D69 * (v191 ^ v192)));
          uint64_t v84 = *(void *)(v4 + 904)
              + 8 * ((-348639895 * ((v193 >> 47) ^ v193)) & (*(_DWORD *)(v4 + 912) - 1));
          long long v46 = *(unsigned int **)v84;
          *(void *)&long long v255 = v256;
          *((void *)&v255 + 1) = 0x2000000000;
          if (v46) {
            BOOL v194 = (v46 & 1) == 0;
          }
          else {
            BOOL v194 = 0;
          }
          if (!v194) {
            goto LABEL_430;
          }
          while (1)
          {
            LOBYTE(v187) = sub_1CD071418(v187, v46, (uint64_t)&v251, v188, (unsigned int *)&v255);
            if (v187) {
              break;
            }
            DWORD2(v255) = 0;
            long long v46 = *(unsigned int **)v46;
            if (v46) {
              BOOL v195 = (v46 & 1) == 0;
            }
            else {
              BOOL v195 = 0;
            }
            if (!v195)
            {
              long long v46 = 0;
              goto LABEL_428;
            }
          }
          uint64_t v84 = 0;
LABEL_428:
          if ((void *)v255 == v256)
          {
            if (!v46) {
              goto LABEL_430;
            }
          }
          else
          {
            free((void *)v255);
            if (!v46)
            {
LABEL_430:
              if (v190)
              {
                *(void *)(v4 + 888) += 40;
                uint64_t v203 = *(void *)(v4 + 808);
                if (((v203 + 7) & 0xFFFFFFFFFFFFFFF8) - v203 + 40 > *(void *)(v4 + 816) - v203)
                {
                  unsigned int v227 = *(_DWORD *)(v4 + 832) >> 7;
                  if (v227 >= 0x1E) {
                    LOBYTE(v227) = 30;
                  }
                  uint64_t v228 = 4096 << v227;
                  unint64_t v102 = (unint64_t)operator new(4096 << v227, (std::align_val_t)8uLL);
                  unsigned int v229 = *(_DWORD *)(v4 + 832);
                  if (v229 >= *(_DWORD *)(v4 + 836)) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  *(void *)(*(void *)(v4 + 824) + 8 * v229) = v102;
                  ++*(_DWORD *)(v4 + 832);
                  *(void *)(v4 + 816) = v102 + v228;
                }
                else
                {
                  unint64_t v102 = (v203 + 7) & 0xFFFFFFFFFFFFFFF8;
                }
                *(void *)(v4 + 808) = v102 + 40;
                uint64_t v31 = v102 + 8;
                *(unsigned char *)(v102 + 16) = 27;
                *(_WORD *)(v102 + 17) = *(_WORD *)(v102 + 17) & 0xF000 | 0x540;
                *(void *)unint64_t v102 = 0;
                *(void *)(v102 + 8) = &unk_1F261AFF0;
                *(void *)(v102 + 24) = v189;
                *(void *)(v102 + 32) = 0;
LABEL_239:
                unsigned int v104 = *(_DWORD *)(v4 + 916) + 1;
                int v105 = *(_DWORD *)(v4 + 912);
                if (v104 > 2 * v105)
                {
                  llvm::FoldingSetBase::GrowBucketCount(v4 + 904, 2 * v105, (uint64_t)off_1F2644D00);
                  *(void *)&long long v255 = v256;
                  *((void *)&v255 + 1) = 0x2000000000;
                  sub_1CD0714B4((unsigned int *)v102, (unsigned int *)&v255);
                  uint64_t v84 = *(void *)(v4 + 904)
                      + 8
                      * ((*(_DWORD *)(v4 + 912) - 1) & sub_1CC13A6B8((void *)v255, v255 + 4 * DWORD2(v255)));
                  if ((void *)v255 != v256) {
                    free((void *)v255);
                  }
                  unsigned int v104 = *(_DWORD *)(v4 + 916) + 1;
                }
                *(_DWORD *)(v4 + 916) = v104;
                uint64_t v106 = *(void *)v84;
                if (!*(void *)v84) {
                  uint64_t v106 = v84 | 1;
                }
                *(void *)unint64_t v102 = v106;
                *(void *)uint64_t v84 = v102;
              }
              else
              {
LABEL_505:
                uint64_t v31 = 0;
              }
              goto LABEL_506;
            }
          }
LABEL_297:
          int v134 = 0;
          uint64_t v31 = (uint64_t)(v46 + 2);
LABEL_507:
          if (v251 != (char *)&v252 + 8) {
            free(v251);
          }
          if (v134)
          {
LABEL_510:
            *(void *)(v4 + 920) = v31;
            goto LABEL_131;
          }
          if (!v31) {
            return v31;
          }
          goto LABEL_512;
        default:
          if (v71 != 66)
          {
            if (v71 != 70) {
              return v31;
            }
            *(void *)a1 = v6 + 2;
            *(void *)&long long v255 = sub_1CC6B5BE0((char **)a1, 0);
            *((void *)&v255 + 1) = v124;
            uint64_t v125 = sub_1CD077500(v4, &v255);
            if (!v125) {
              return 0;
            }
            uint64_t v126 = v125;
            uint64_t v127 = (*(uint64_t (**)(uint64_t))(*(void *)v125 + 48))(v125);
            if (v129 - v127 == 2)
            {
              uint64_t v127 = strncmp((const char *)v127, "16", 2uLL);
              uint64_t v130 = *(char **)v4;
              unint64_t v131 = *(char **)(v4 + 8);
              if (!v127)
              {
                if (v130 == v131) {
                  return 0;
                }
                if (*v130 == 98)
                {
                  *(void *)uint64_t v4 = v130 + 1;
                  uint64_t v26 = "__bf16";
                  goto LABEL_52;
                }
              }
            }
            else
            {
              uint64_t v130 = *(char **)v4;
              unint64_t v131 = *(char **)(v4 + 8);
            }
            if (v130 == v131 || *v130 != 95) {
              return 0;
            }
            *(void *)uint64_t v4 = v130 + 1;
            int v165 = *(unsigned __int8 *)(v4 + 937);
            uint64_t v251 = (char *)&v252 + 8;
            uint64_t v253 = v126;
            long long v252 = xmmword_1CFB2EAD0;
            if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
            {
              uint64_t v127 = __cxa_guard_acquire(&qword_1EBCBE588);
              if (v127)
              {
                unint64_t v242 = llvm::hashing::detail::fixed_seed_override;
                if (!llvm::hashing::detail::fixed_seed_override) {
                  unint64_t v242 = 0xFF51AFD7ED558CCDLL;
                }
                qword_1EBCBE580 = v242;
                __cxa_guard_release(&qword_1EBCBE588);
              }
            }
            unint64_t v166 = 0x9DDFEA08EB382D69 * (*((void *)&v252 + 1) ^ qword_1EBCBE580 ^ __ROR8__(v253 + 16, 16));
            unint64_t v167 = __ROR8__(v253 + 16, 16) ^ (v166 >> 47);
            uint64_t v22 = *(void *)(v4 + 904)
                + 8
                * ((*(_DWORD *)(v4 + 912) - 1) & ((-348639895
                                                 * ((((0x9DDFEA08EB382D69 * (v167 ^ v166)) >> 32) >> 15) ^ (-348639895 * (v167 ^ v166)))) ^ v253));
            unsigned int v23 = *(unsigned int **)v22;
            *(void *)&long long v255 = v256;
            *((void *)&v255 + 1) = 0x2000000000;
            if (v23) {
              BOOL v168 = (v23 & 1) == 0;
            }
            else {
              BOOL v168 = 0;
            }
            if (v168)
            {
              while (1)
              {
                LOBYTE(v127) = sub_1CD071418(v127, v23, (uint64_t)&v251, v128, (unsigned int *)&v255);
                if (v127) {
                  break;
                }
                DWORD2(v255) = 0;
                unsigned int v23 = *(unsigned int **)v23;
                if (v23) {
                  BOOL v169 = (v23 & 1) == 0;
                }
                else {
                  BOOL v169 = 0;
                }
                if (!v169)
                {
                  unsigned int v23 = 0;
                  goto LABEL_396;
                }
              }
              uint64_t v22 = 0;
LABEL_396:
              if ((void *)v255 == v256)
              {
                if (v23) {
                  goto LABEL_212;
                }
              }
              else
              {
                free((void *)v255);
                if (v23) {
                  goto LABEL_212;
                }
              }
            }
            if (!v165) {
              goto LABEL_451;
            }
            *(void *)(v4 + 888) += 32;
            uint64_t v186 = *(void *)(v4 + 808);
            if (((v186 + 7) & 0xFFFFFFFFFFFFFFF8) - v186 + 32 > *(void *)(v4 + 816) - v186)
            {
              unsigned int v224 = *(_DWORD *)(v4 + 832) >> 7;
              if (v224 >= 0x1E) {
                LOBYTE(v224) = 30;
              }
              uint64_t v225 = 4096 << v224;
              unint64_t v90 = (unint64_t)operator new(4096 << v224, (std::align_val_t)8uLL);
              unsigned int v226 = *(_DWORD *)(v4 + 832);
              if (v226 >= *(_DWORD *)(v4 + 836)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *(void *)(*(void *)(v4 + 824) + 8 * v226) = v90;
              ++*(_DWORD *)(v4 + 832);
              *(void *)(v4 + 816) = v90 + v225;
            }
            else
            {
              unint64_t v90 = (v186 + 7) & 0xFFFFFFFFFFFFFFF8;
            }
            *(void *)(v4 + 808) = v90 + 32;
            uint64_t v31 = v90 + 8;
            *(unsigned char *)(v90 + 16) = 29;
            *(_WORD *)(v90 + 17) = *(_WORD *)(v90 + 17) & 0xF000 | 0x540;
            *(void *)unint64_t v90 = 0;
            *(void *)(v90 + 8) = &unk_1F261AEE8;
            *(void *)(v90 + 24) = v126;
            goto LABEL_447;
          }
LABEL_298:
          int v135 = v6[1];
          BOOL v136 = v135 == 66;
          *(void *)a1 = v6 + 2;
          if (v5 == v6 + 2)
          {
            uint64_t v137 = 0;
          }
          else
          {
            if (v6[2] < 0) {
              goto LABEL_336;
            }
            uint64_t v137 = v6[2];
          }
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v137 + 60) & 0x400) != 0)
          {
            *(void *)&long long v255 = sub_1CC6B5BE0((char **)a1, 0);
            *((void *)&v255 + 1) = v156;
            uint64_t v154 = sub_1CD077500(v4, &v255);
            goto LABEL_338;
          }
LABEL_336:
          uint64_t v154 = sub_1CD077868(a1);
LABEL_338:
          uint64_t v157 = v154;
          if (!v154) {
            return 0;
          }
          v158 = *(char **)v4;
          if (*(void *)v4 == *(void *)(v4 + 8) || *v158 != 95) {
            return 0;
          }
          *(void *)uint64_t v4 = v158 + 1;
          int v159 = *(unsigned __int8 *)(v4 + 937);
          uint64_t v251 = (char *)&v252 + 8;
          uint64_t v253 = v154;
          BOOL v254 = v135 == 66;
          long long v252 = xmmword_1CFB2EAC0;
          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
          {
            uint64_t v154 = __cxa_guard_acquire(&qword_1EBCBE588);
            if (v154)
            {
              unint64_t v241 = llvm::hashing::detail::fixed_seed_override;
              if (!llvm::hashing::detail::fixed_seed_override) {
                unint64_t v241 = 0xFF51AFD7ED558CCDLL;
              }
              qword_1EBCBE580 = v241;
              __cxa_guard_release(&qword_1EBCBE588);
            }
          }
          uint64_t v160 = __ROR8__(0xB492B66FBE98F273 * *((void *)&v252 + 1) - v253, 43)
               - 0x3C5A37A36834CED9 * v253
               + __ROR8__((0x9AE16A3B2F90404FLL * v254) ^ qword_1EBCBE580, 30);
          unint64_t v161 = qword_1EBCBE580
               + __ROR8__(v253 ^ 0xC949D7C7509E6557, 20)
               - 0x4B6D499041670D8DLL * *((void *)&v252 + 1)
               - 0x9AE16A3B2F90404FLL * v254
               + 24;
          unint64_t v162 = 0x9DDFEA08EB382D69
               * (v161 ^ ((0x9DDFEA08EB382D69 * (v160 ^ v161)) >> 47) ^ (0x9DDFEA08EB382D69 * (v160 ^ v161)));
          uint64_t v22 = *(void *)(v4 + 904)
              + 8 * ((-348639895 * ((v162 >> 47) ^ v162)) & (*(_DWORD *)(v4 + 912) - 1));
          unsigned int v23 = *(unsigned int **)v22;
          *(void *)&long long v255 = v256;
          *((void *)&v255 + 1) = 0x2000000000;
          if (v23) {
            BOOL v163 = (v23 & 1) == 0;
          }
          else {
            BOOL v163 = 0;
          }
          if (v163)
          {
            do
            {
              LOBYTE(v154) = sub_1CD071418(v154, v23, (uint64_t)&v251, v155, (unsigned int *)&v255);
              if (v154)
              {
                uint64_t v22 = 0;
                goto LABEL_377;
              }
              DWORD2(v255) = 0;
              unsigned int v23 = *(unsigned int **)v23;
              if (v23) {
                BOOL v164 = (v23 & 1) == 0;
              }
              else {
                BOOL v164 = 0;
              }
            }
            while (v164);
            unsigned int v23 = 0;
LABEL_377:
            if ((void *)v255 == v256)
            {
              if (v23) {
                goto LABEL_212;
              }
            }
            else
            {
              free((void *)v255);
              if (v23) {
                goto LABEL_212;
              }
            }
          }
          if (!v159) {
            goto LABEL_451;
          }
          *(void *)(v4 + 888) += 40;
          uint64_t v176 = *(void *)(v4 + 808);
          if (((v176 + 7) & 0xFFFFFFFFFFFFFFF8) - v176 + 40 > *(void *)(v4 + 816) - v176)
          {
            unsigned int v215 = *(_DWORD *)(v4 + 832) >> 7;
            if (v215 >= 0x1E) {
              LOBYTE(v215) = 30;
            }
            uint64_t v216 = 4096 << v215;
            unint64_t v90 = (unint64_t)operator new(4096 << v215, (std::align_val_t)8uLL);
            unsigned int v217 = *(_DWORD *)(v4 + 832);
            if (v217 >= *(_DWORD *)(v4 + 836)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(*(void *)(v4 + 824) + 8 * v217) = v90;
            ++*(_DWORD *)(v4 + 832);
            *(void *)(v4 + 816) = v90 + v216;
          }
          else
          {
            unint64_t v90 = (v176 + 7) & 0xFFFFFFFFFFFFFFF8;
          }
          *(void *)(v4 + 808) = v90 + 40;
          uint64_t v31 = v90 + 8;
          *(unsigned char *)(v90 + 16) = 30;
          *(_WORD *)(v90 + 17) = *(_WORD *)(v90 + 17) & 0xF000 | 0x540;
          *(void *)unint64_t v90 = 0;
          *(void *)(v90 + 8) = &unk_1F261AF40;
          *(void *)(v90 + 24) = v157;
          *(unsigned char *)(v90 + 32) = v136;
          goto LABEL_447;
      }
    case 'F':
      goto LABEL_250;
    case 'G':
      *(void *)a1 = v6 + 1;
      uint64_t v49 = sub_1CD06B2C4(a1);
      if (!v49) {
        return 0;
      }
      uint64_t v50 = v49;
      int v51 = *(unsigned __int8 *)(v4 + 937);
      uint64_t v251 = (char *)&v252 + 8;
      uint64_t v253 = v49;
      long long v252 = xmmword_1CFB2EA60;
      llvm::FoldingSetNodeID::AddString((unsigned int *)&v251, " imaginary", 0xAu);
      unint64_t v52 = sub_1CC13A6B8(v251, (uint64_t)v251 + 4 * v252);
      uint64_t v45 = *(void *)(v4 + 904) + 8 * ((*(_DWORD *)(v4 + 912) - 1) & v52);
      long long v46 = *(unsigned int **)v45;
      *(void *)&long long v255 = v256;
      *((void *)&v255 + 1) = 0x2000000000;
      if (v46) {
        BOOL v54 = (v46 & 1) == 0;
      }
      else {
        BOOL v54 = 0;
      }
      if (!v54) {
        goto LABEL_223;
      }
      while (1)
      {
        LOBYTE(v52) = sub_1CD071418(v52, v46, (uint64_t)&v251, v53, (unsigned int *)&v255);
        if (v52) {
          break;
        }
        DWORD2(v255) = 0;
        long long v46 = *(unsigned int **)v46;
        if (v46) {
          BOOL v55 = (v46 & 1) == 0;
        }
        else {
          BOOL v55 = 0;
        }
        if (!v55)
        {
          long long v46 = 0;
          goto LABEL_221;
        }
      }
      uint64_t v45 = 0;
LABEL_221:
      if ((void *)v255 == v256)
      {
        if (v46) {
          goto LABEL_297;
        }
      }
      else
      {
        free((void *)v255);
        if (v46) {
          goto LABEL_297;
        }
      }
LABEL_223:
      if (!v51) {
        goto LABEL_505;
      }
      *(void *)(v4 + 888) += 48;
      uint64_t v97 = *(void *)(v4 + 808);
      if (((v97 + 7) & 0xFFFFFFFFFFFFFFF8) - v97 + 48 > *(void *)(v4 + 816) - v97)
      {
        unsigned int v180 = *(_DWORD *)(v4 + 832) >> 7;
        if (v180 >= 0x1E) {
          LOBYTE(v180) = 30;
        }
        uint64_t v181 = 4096 << v180;
        v246 = (char *)operator new(4096 << v180, (std::align_val_t)8uLL);
        unsigned int v182 = *(_DWORD *)(v4 + 832);
        if (v182 >= *(_DWORD *)(v4 + 836)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        unint64_t v95 = (unint64_t)v246;
        *(void *)(*(void *)(v4 + 824) + 8 * v182) = v246;
        ++*(_DWORD *)(v4 + 832);
        *(void *)(v4 + 816) = &v246[v181];
      }
      else
      {
        unint64_t v95 = (v97 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(v4 + 808) = v95 + 48;
      uint64_t v31 = v95 + 8;
      *(unsigned char *)(v95 + 16) = 5;
      *(_WORD *)(v95 + 17) = *(_WORD *)(v95 + 17) & 0xF000 | 0x540;
      *(void *)unint64_t v95 = 0;
      *(void *)(v95 + 8) = &unk_1F261B200;
      *(void *)(v95 + 24) = v50;
      *(void *)(v95 + 32) = " imaginary";
      BOOL v96 = "";
LABEL_227:
      *(void *)(v95 + 40) = v96;
      goto LABEL_228;
    case 'K':
    case 'V':
    case 'r':
      unint64_t v9 = v8 == 114;
      BOOL v10 = v7 > v9 && v6[v9] == 86;
      unint64_t v11 = v10 + (unint64_t)v9;
      BOOL v12 = v7 > v11 && v6[v11] == 75;
      unint64_t v13 = v11 + v12;
      if (v7 <= v13) {
        goto LABEL_15;
      }
      int v14 = v6[v13];
      if (v14 != 70)
      {
        unint64_t v15 = v13 + 1;
        BOOL v16 = v14 == 68 && v7 > v15;
        if (!v16) {
          goto LABEL_15;
        }
        unsigned int v107 = v6[v15] - 79;
        BOOL v16 = v107 > 0x29;
        uint64_t v108 = (1 << v107) & 0x30100000001;
        if (v16 || v108 == 0) {
          goto LABEL_15;
        }
      }
LABEL_250:
      uint64_t v17 = sub_1CD075AB8(a1);
      goto LABEL_130;
    case 'M':
      if (v8 != 77) {
        return 0;
      }
      *(void *)a1 = v6 + 1;
      uint64_t v56 = sub_1CD06B2C4(a1);
      if (!v56) {
        return 0;
      }
      uint64_t v57 = v56;
      uint64_t v58 = sub_1CD06B2C4(v4);
      if (!v58) {
        return 0;
      }
      uint64_t v60 = v58;
      int v61 = *(unsigned __int8 *)(v4 + 937);
      uint64_t v251 = (char *)&v252 + 8;
      uint64_t v253 = v57;
      BOOL v254 = v58;
      long long v252 = xmmword_1CFB2EA80;
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
      {
        uint64_t v58 = __cxa_guard_acquire(&qword_1EBCBE588);
        if (v58)
        {
          unint64_t v239 = llvm::hashing::detail::fixed_seed_override;
          if (!llvm::hashing::detail::fixed_seed_override) {
            unint64_t v239 = 0xFF51AFD7ED558CCDLL;
          }
          qword_1EBCBE580 = v239;
          __cxa_guard_release(&qword_1EBCBE588);
        }
      }
      uint64_t v62 = __ROR8__(0xB492B66FBE98F273 * *((void *)&v252 + 1) - v253, 43)
          - 0x3C5A37A36834CED9 * v253
          + __ROR8__((0x9AE16A3B2F90404FLL * v254) ^ qword_1EBCBE580, 30);
      unint64_t v63 = qword_1EBCBE580
          + __ROR8__(v253 ^ 0xC949D7C7509E6557, 20)
          - 0x4B6D499041670D8DLL * *((void *)&v252 + 1)
          - 0x9AE16A3B2F90404FLL * v254
          + 24;
      unint64_t v64 = 0x9DDFEA08EB382D69
          * (v63 ^ ((0x9DDFEA08EB382D69 * (v62 ^ v63)) >> 47) ^ (0x9DDFEA08EB382D69 * (v62 ^ v63)));
      uint64_t v45 = *(void *)(v4 + 904)
          + 8 * ((-348639895 * ((v64 >> 47) ^ v64)) & (*(_DWORD *)(v4 + 912) - 1));
      long long v46 = *(unsigned int **)v45;
      *(void *)&long long v255 = v256;
      *((void *)&v255 + 1) = 0x2000000000;
      if (v46) {
        BOOL v65 = (v46 & 1) == 0;
      }
      else {
        BOOL v65 = 0;
      }
      if (!v65) {
        goto LABEL_277;
      }
      while (1)
      {
        LOBYTE(v58) = sub_1CD071418(v58, v46, (uint64_t)&v251, v59, (unsigned int *)&v255);
        if (v58) {
          break;
        }
        DWORD2(v255) = 0;
        long long v46 = *(unsigned int **)v46;
        if (v46) {
          BOOL v66 = (v46 & 1) == 0;
        }
        else {
          BOOL v66 = 0;
        }
        if (!v66)
        {
          long long v46 = 0;
          goto LABEL_275;
        }
      }
      uint64_t v45 = 0;
LABEL_275:
      if ((void *)v255 == v256)
      {
        if (v46) {
          goto LABEL_297;
        }
      }
      else
      {
        free((void *)v255);
        if (v46) {
          goto LABEL_297;
        }
      }
LABEL_277:
      if (!v61) {
        goto LABEL_505;
      }
      *(void *)(v4 + 888) += 40;
      uint64_t v122 = *(void *)(v4 + 808);
      if (((v122 + 7) & 0xFFFFFFFFFFFFFFF8) - v122 + 40 > *(void *)(v4 + 816) - v122)
      {
        unsigned int v200 = *(_DWORD *)(v4 + 832) >> 7;
        if (v200 >= 0x1E) {
          LOBYTE(v200) = 30;
        }
        uint64_t v201 = 4096 << v200;
        v247 = (char *)operator new(4096 << v200, (std::align_val_t)8uLL);
        unsigned int v202 = *(_DWORD *)(v4 + 832);
        if (v202 >= *(_DWORD *)(v4 + 836)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        unint64_t v95 = (unint64_t)v247;
        *(void *)(*(void *)(v4 + 824) + 8 * v202) = v247;
        ++*(_DWORD *)(v4 + 832);
        *(void *)(v4 + 816) = &v247[v201];
      }
      else
      {
        unint64_t v95 = (v122 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(v4 + 808) = v95 + 40;
      *(void *)unint64_t v95 = 0;
      uint64_t v31 = v95 + 8;
      char v123 = *(_WORD *)(v60 + 9);
      *(unsigned char *)(v95 + 16) = 13;
      *(_WORD *)(v95 + 17) = v123 & 0xC0 | 0x500 | *(_WORD *)(v95 + 17) & 0xF000;
      *(void *)(v95 + 8) = &unk_1F261B0A0;
      *(void *)(v95 + 24) = v57;
      *(void *)(v95 + 32) = v60;
      goto LABEL_228;
    case 'O':
      *(void *)a1 = v6 + 1;
      *(void *)&long long v255 = sub_1CD06B2C4(a1);
      if (!(void)v255) {
        return 0;
      }
      LODWORD(v251) = 1;
      goto LABEL_163;
    case 'P':
      *(void *)a1 = v6 + 1;
      uint64_t v78 = sub_1CD06B2C4(a1);
      if (!v78) {
        return 0;
      }
      uint64_t v80 = v78;
      int v81 = *(unsigned __int8 *)(v4 + 937);
      uint64_t v251 = (char *)&v252 + 8;
      uint64_t v253 = v78;
      long long v252 = xmmword_1CFB2EA70;
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
      {
        uint64_t v78 = __cxa_guard_acquire(&qword_1EBCBE588);
        if (v78)
        {
          unint64_t v238 = llvm::hashing::detail::fixed_seed_override;
          if (!llvm::hashing::detail::fixed_seed_override) {
            unint64_t v238 = 0xFF51AFD7ED558CCDLL;
          }
          qword_1EBCBE580 = v238;
          __cxa_guard_release(&qword_1EBCBE588);
        }
      }
      unint64_t v82 = 0x9DDFEA08EB382D69 * (*((void *)&v252 + 1) ^ qword_1EBCBE580 ^ __ROR8__(v253 + 16, 16));
      unint64_t v83 = __ROR8__(v253 + 16, 16) ^ (v82 >> 47);
      uint64_t v84 = *(void *)(v4 + 904)
          + 8
          * ((*(_DWORD *)(v4 + 912) - 1) & ((-348639895
                                           * ((((0x9DDFEA08EB382D69 * (v83 ^ v82)) >> 32) >> 15) ^ (-348639895 * (v83 ^ v82)))) ^ v253));
      long long v46 = *(unsigned int **)v84;
      *(void *)&long long v255 = v256;
      *((void *)&v255 + 1) = 0x2000000000;
      if (v46) {
        BOOL v85 = (v46 & 1) == 0;
      }
      else {
        BOOL v85 = 0;
      }
      if (!v85) {
        goto LABEL_235;
      }
      while (1)
      {
        LOBYTE(v78) = sub_1CD071418(v78, v46, (uint64_t)&v251, v79, (unsigned int *)&v255);
        if (v78) {
          break;
        }
        DWORD2(v255) = 0;
        long long v46 = *(unsigned int **)v46;
        if (v46) {
          BOOL v86 = (v46 & 1) == 0;
        }
        else {
          BOOL v86 = 0;
        }
        if (!v86)
        {
          long long v46 = 0;
          goto LABEL_233;
        }
      }
      uint64_t v84 = 0;
LABEL_233:
      if ((void *)v255 == v256)
      {
        if (v46) {
          goto LABEL_297;
        }
      }
      else
      {
        free((void *)v255);
        if (v46) {
          goto LABEL_297;
        }
      }
LABEL_235:
      if (!v81) {
        goto LABEL_505;
      }
      *(void *)(v4 + 888) += 32;
      uint64_t v101 = *(void *)(v4 + 808);
      if (((v101 + 7) & 0xFFFFFFFFFFFFFFF8) - v101 + 32 > *(void *)(v4 + 816) - v101)
      {
        unsigned int v183 = *(_DWORD *)(v4 + 832) >> 7;
        if (v183 >= 0x1E) {
          LOBYTE(v183) = 30;
        }
        uint64_t v184 = 4096 << v183;
        unint64_t v102 = (unint64_t)operator new(4096 << v183, (std::align_val_t)8uLL);
        unsigned int v185 = *(_DWORD *)(v4 + 832);
        if (v185 >= *(_DWORD *)(v4 + 836)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v4 + 824) + 8 * v185) = v102;
        ++*(_DWORD *)(v4 + 832);
        *(void *)(v4 + 816) = v102 + v184;
      }
      else
      {
        unint64_t v102 = (v101 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(v4 + 808) = v102 + 32;
      *(void *)unint64_t v102 = 0;
      uint64_t v31 = v102 + 8;
      char v103 = *(_WORD *)(v80 + 9);
      *(unsigned char *)(v102 + 16) = 11;
      *(_WORD *)(v102 + 17) = v103 & 0xC0 | 0x500 | *(_WORD *)(v102 + 17) & 0xF000;
      *(void *)(v102 + 8) = &unk_1F261B150;
      *(void *)(v102 + 24) = v80;
      goto LABEL_239;
    case 'R':
      *(void *)a1 = v6 + 1;
      *(void *)&long long v255 = sub_1CD06B2C4(a1);
      if (!(void)v255) {
        return 0;
      }
      LODWORD(v251) = 0;
LABEL_163:
      uint64_t v17 = sub_1CD07E1AC(v4, (unint64_t *)&v255, (int *)&v251, v72);
      goto LABEL_130;
    case 'S':
      if (v7 >= 2 && v6[1] == 116) {
        goto LABEL_129;
      }
      LOBYTE(v251) = 0;
      uint64_t v87 = sub_1CD07E648((const char **)a1, 0, &v251, a4);
      uint64_t v249 = v87;
      if (!v87) {
        return 0;
      }
      uint64_t v31 = v87;
      if (*(void *)(v4 + 8) == *(void *)v4)
      {
        int v88 = v251;
      }
      else
      {
        int v88 = v251;
        if (**(unsigned char **)v4 == 73)
        {
          if ((_BYTE)v251)
          {
            if (!*(unsigned char *)(v4 + 776)) {
              return v31;
            }
          }
          else
          {
            std::string::size_type v132 = *(uint64_t **)(v4 + 304);
            if (v132 == *(uint64_t **)(v4 + 312))
            {
              sub_1CD5F0ACC(v4 + 296, ((uint64_t)v132 - *(void *)(v4 + 296)) >> 2);
              std::string::size_type v132 = *(uint64_t **)(v4 + 304);
            }
            *(void *)(v4 + 304) = v132 + 1;
            *std::string::size_type v132 = v31;
          }
LABEL_292:
          *(void *)&long long v255 = sub_1CD07D418(v4, 0);
          if ((void)v255)
          {
            uint64_t v17 = sub_1CD07DD24(v4, &v249, (uint64_t *)&v255, v133);
            goto LABEL_130;
          }
          return 0;
        }
      }
      if (v88) {
        return v31;
      }
      goto LABEL_132;
    case 'T':
      if (v7 >= 2)
      {
        unsigned int v28 = v6[1] - 101;
        BOOL v16 = v28 > 0x10;
        int v29 = (1 << v28) & 0x14001;
        if (!v16 && v29 != 0) {
          goto LABEL_129;
        }
      }
      uint64_t v31 = sub_1CD07D120(a1);
      uint64_t v249 = v31;
      if (!v31) {
        return v31;
      }
      if (*(unsigned char *)(v4 + 776) && *(void *)(v4 + 8) != *(void *)v4 && **(unsigned char **)v4 == 73) {
        goto LABEL_292;
      }
      goto LABEL_132;
    case 'U':
LABEL_15:
      uint64_t v17 = sub_1CD076988(a1);
      goto LABEL_130;
    case 'a':
      *(void *)a1 = v6 + 1;
      uint64_t v26 = "signed char";
      goto LABEL_182;
    case 'b':
      *(void *)a1 = v6 + 1;
      uint64_t v26 = "BOOL";
      goto LABEL_186;
    case 'c':
      *(void *)a1 = v6 + 1;
      uint64_t v26 = "char";
      goto LABEL_186;
    case 'd':
      *(void *)a1 = v6 + 1;
      uint64_t v26 = "double";
LABEL_52:
      a1 = v4;
      return sub_1CD06AF4C(a1, v26);
    case 'e':
      *(void *)a1 = v6 + 1;
      uint64_t v26 = "long double";
LABEL_182:
      return sub_1CD06AF4C(a1, v26);
    case 'f':
      *(void *)a1 = v6 + 1;
      uint64_t v26 = "float";
      goto LABEL_121;
    case 'g':
      *(void *)a1 = v6 + 1;
      uint64_t v26 = "__float128";
LABEL_56:
      return sub_1CD06AF4C(a1, v26);
    case 'h':
      *(void *)a1 = v6 + 1;
      uint64_t v26 = "unsigned char";
      goto LABEL_140;
    case 'i':
      *(void *)a1 = v6 + 1;
      uint64_t v26 = "int";
      goto LABEL_78;
    case 'j':
      *(void *)a1 = v6 + 1;
      int v73 = *(unsigned __int8 *)(a1 + 937);
      uint64_t v251 = (char *)&v252 + 8;
      long long v252 = xmmword_1CFB2EA50;
      uint64_t v19 = "unsigned int";
      llvm::FoldingSetNodeID::AddString((unsigned int *)&v251, "unsigned int", 0xCu);
      unint64_t v74 = sub_1CC13A6B8(v251, (uint64_t)v251 + 4 * v252);
      uint64_t v22 = *(void *)(v4 + 904) + 8 * ((*(_DWORD *)(v4 + 912) - 1) & v74);
      unsigned int v23 = *(unsigned int **)v22;
      *(void *)&long long v255 = v256;
      *((void *)&v255 + 1) = 0x2000000000;
      if (v23) {
        BOOL v76 = (v23 & 1) == 0;
      }
      else {
        BOOL v76 = 0;
      }
      if (!v76) {
        goto LABEL_442;
      }
      while (1)
      {
        LOBYTE(v74) = sub_1CD071418(v74, v23, (uint64_t)&v251, v75, (unsigned int *)&v255);
        if (v74) {
          break;
        }
        DWORD2(v255) = 0;
        unsigned int v23 = *(unsigned int **)v23;
        if (v23) {
          BOOL v77 = (v23 & 1) == 0;
        }
        else {
          BOOL v77 = 0;
        }
        if (!v77)
        {
          unsigned int v23 = 0;
          goto LABEL_210;
        }
      }
      uint64_t v22 = 0;
LABEL_210:
      if ((void *)v255 == v256)
      {
        if (v23) {
          goto LABEL_212;
        }
      }
      else
      {
        free((void *)v255);
        if (v23) {
          goto LABEL_212;
        }
      }
LABEL_442:
      if (!v73) {
        goto LABEL_451;
      }
      *(void *)(v4 + 888) += 40;
      uint64_t v205 = *(void *)(v4 + 808);
      if (((v205 + 7) & 0xFFFFFFFFFFFFFFF8) - v205 + 40 > *(void *)(v4 + 816) - v205)
      {
        unsigned int v211 = *(_DWORD *)(v4 + 832) >> 7;
        if (v211 >= 0x1E) {
          LOBYTE(v211) = 30;
        }
        uint64_t v212 = 4096 << v211;
        unint64_t v90 = (unint64_t)operator new(4096 << v211, (std::align_val_t)8uLL);
        unsigned int v213 = *(_DWORD *)(v4 + 832);
        if (v213 >= *(_DWORD *)(v4 + 836)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v4 + 824) + 8 * v213) = v90;
        ++*(_DWORD *)(v4 + 832);
        *(void *)(v4 + 816) = v90 + v212;
      }
      else
      {
        unint64_t v90 = (v205 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(v4 + 808) = v90 + 40;
      uint64_t v31 = v90 + 8;
      *(unsigned char *)(v90 + 16) = 7;
      *(_WORD *)(v90 + 17) = *(_WORD *)(v90 + 17) & 0xF000 | 0x540;
      *(void *)unint64_t v90 = 0;
      *(void *)(v90 + 8) = &unk_1F26197E0;
      BOOL v91 = "";
      goto LABEL_446;
    case 'l':
      *(void *)a1 = v6 + 1;
      uint64_t v26 = "long";
      goto LABEL_186;
    case 'm':
      *(void *)a1 = v6 + 1;
      uint64_t v26 = "unsigned long";
LABEL_140:
      return sub_1CD06AF4C(a1, v26);
    case 'n':
      *(void *)a1 = v6 + 1;
      uint64_t v26 = "__int128";
LABEL_30:
      return sub_1CD06AF4C(a1, v26);
    case 'o':
      *(void *)a1 = v6 + 1;
      int v35 = *(unsigned __int8 *)(a1 + 937);
      uint64_t v251 = (char *)&v252 + 8;
      long long v252 = xmmword_1CFB2EA50;
      uint64_t v19 = "unsigned __int128";
      llvm::FoldingSetNodeID::AddString((unsigned int *)&v251, "unsigned __int128", 0x11u);
      unint64_t v36 = sub_1CC13A6B8(v251, (uint64_t)v251 + 4 * v252);
      uint64_t v22 = *(void *)(v4 + 904) + 8 * ((*(_DWORD *)(v4 + 912) - 1) & v36);
      unsigned int v23 = *(unsigned int **)v22;
      *(void *)&long long v255 = v256;
      *((void *)&v255 + 1) = 0x2000000000;
      if (v23) {
        BOOL v38 = (v23 & 1) == 0;
      }
      else {
        BOOL v38 = 0;
      }
      if (!v38) {
        goto LABEL_205;
      }
      while (1)
      {
        LOBYTE(v36) = sub_1CD071418(v36, v23, (uint64_t)&v251, v37, (unsigned int *)&v255);
        if (v36) {
          break;
        }
        DWORD2(v255) = 0;
        unsigned int v23 = *(unsigned int **)v23;
        if (v23) {
          BOOL v39 = (v23 & 1) == 0;
        }
        else {
          BOOL v39 = 0;
        }
        if (!v39)
        {
          unsigned int v23 = 0;
          goto LABEL_203;
        }
      }
      uint64_t v22 = 0;
LABEL_203:
      if ((void *)v255 == v256)
      {
        if (v23) {
          goto LABEL_212;
        }
      }
      else
      {
        free((void *)v255);
        if (v23) {
          goto LABEL_212;
        }
      }
LABEL_205:
      if (!v35) {
        goto LABEL_451;
      }
      *(void *)(v4 + 888) += 40;
      uint64_t v92 = *(void *)(v4 + 808);
      if (((v92 + 7) & 0xFFFFFFFFFFFFFFF8) - v92 + 40 > *(void *)(v4 + 816) - v92)
      {
        unsigned int v173 = *(_DWORD *)(v4 + 832) >> 7;
        if (v173 >= 0x1E) {
          LOBYTE(v173) = 30;
        }
        uint64_t v174 = 4096 << v173;
        unint64_t v90 = (unint64_t)operator new(4096 << v173, (std::align_val_t)8uLL);
        unsigned int v175 = *(_DWORD *)(v4 + 832);
        if (v175 >= *(_DWORD *)(v4 + 836)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v4 + 824) + 8 * v175) = v90;
        ++*(_DWORD *)(v4 + 832);
        *(void *)(v4 + 816) = v90 + v174;
      }
      else
      {
        unint64_t v90 = (v92 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(v4 + 808) = v90 + 40;
      uint64_t v31 = v90 + 8;
      *(unsigned char *)(v90 + 16) = 7;
      *(_WORD *)(v90 + 17) = *(_WORD *)(v90 + 17) & 0xF000 | 0x540;
      *(void *)unint64_t v90 = 0;
      *(void *)(v90 + 8) = &unk_1F26197E0;
      BOOL v91 = "";
      goto LABEL_446;
    case 's':
      *(void *)a1 = v6 + 1;
      uint64_t v26 = "short";
LABEL_121:
      return sub_1CD06AF4C(a1, v26);
    case 't':
      *(void *)a1 = v6 + 1;
      uint64_t v26 = "unsigned short";
LABEL_158:
      return sub_1CD06AF4C(a1, v26);
    case 'u':
      *(void *)a1 = v6 + 1;
      uint64_t v251 = 0;
      char v67 = sub_1CC6B813C((unsigned __int8 **)a1, (uint64_t *)&v251);
      unint64_t v68 = 0;
      int v69 = 0;
      if ((v67 & 1) == 0)
      {
        int v69 = *(char **)v4;
        if (*(void *)(v4 + 8) - *(void *)v4 >= (unint64_t)v251)
        {
          unint64_t v68 = (char *)v251 + (void)v69;
          *(void *)uint64_t v4 = (char *)v251 + (void)v69;
        }
        else
        {
          unint64_t v68 = 0;
          int v69 = 0;
        }
      }
      *(void *)&long long v255 = v69;
      *((void *)&v255 + 1) = v68;
      if (v68 == v69) {
        return 0;
      }
      uint64_t v17 = sub_1CD077500(v4, &v255);
      goto LABEL_130;
    case 'v':
      *(void *)a1 = v6 + 1;
      uint64_t v26 = "void";
LABEL_186:
      return sub_1CD06AF4C(a1, v26);
    case 'w':
      *(void *)a1 = v6 + 1;
      uint64_t v26 = "wchar_t";
LABEL_48:
      return sub_1CD06AF4C(a1, v26);
    case 'x':
      *(void *)a1 = v6 + 1;
      uint64_t v26 = "long long";
LABEL_178:
      return sub_1CD06AF4C(a1, v26);
    case 'y':
      *(void *)a1 = v6 + 1;
      int v18 = *(unsigned __int8 *)(a1 + 937);
      uint64_t v251 = (char *)&v252 + 8;
      long long v252 = xmmword_1CFB2EA50;
      uint64_t v19 = "unsigned long long";
      llvm::FoldingSetNodeID::AddString((unsigned int *)&v251, "unsigned long long", 0x12u);
      unint64_t v20 = sub_1CC13A6B8(v251, (uint64_t)v251 + 4 * v252);
      uint64_t v22 = *(void *)(v4 + 904) + 8 * ((*(_DWORD *)(v4 + 912) - 1) & v20);
      unsigned int v23 = *(unsigned int **)v22;
      *(void *)&long long v255 = v256;
      *((void *)&v255 + 1) = 0x2000000000;
      if (v23) {
        BOOL v24 = (v23 & 1) == 0;
      }
      else {
        BOOL v24 = 0;
      }
      if (!v24) {
        goto LABEL_198;
      }
      while (1)
      {
        LOBYTE(v20) = sub_1CD071418(v20, v23, (uint64_t)&v251, v21, (unsigned int *)&v255);
        if (v20) {
          break;
        }
        DWORD2(v255) = 0;
        unsigned int v23 = *(unsigned int **)v23;
        if (v23) {
          BOOL v25 = (v23 & 1) == 0;
        }
        else {
          BOOL v25 = 0;
        }
        if (!v25)
        {
          unsigned int v23 = 0;
          goto LABEL_196;
        }
      }
      uint64_t v22 = 0;
LABEL_196:
      if ((void *)v255 != v256)
      {
        free((void *)v255);
        if (!v23) {
          goto LABEL_198;
        }
LABEL_212:
        int v93 = 0;
        uint64_t v31 = (uint64_t)(v23 + 2);
        goto LABEL_453;
      }
      if (v23) {
        goto LABEL_212;
      }
LABEL_198:
      if (!v18)
      {
LABEL_451:
        uint64_t v31 = 0;
        goto LABEL_452;
      }
      *(void *)(v4 + 888) += 40;
      uint64_t v89 = *(void *)(v4 + 808);
      if (((v89 + 7) & 0xFFFFFFFFFFFFFFF8) - v89 + 40 > *(void *)(v4 + 816) - v89)
      {
        unsigned int v170 = *(_DWORD *)(v4 + 832) >> 7;
        if (v170 >= 0x1E) {
          LOBYTE(v170) = 30;
        }
        uint64_t v171 = 4096 << v170;
        unint64_t v90 = (unint64_t)operator new(4096 << v170, (std::align_val_t)8uLL);
        unsigned int v172 = *(_DWORD *)(v4 + 832);
        if (v172 >= *(_DWORD *)(v4 + 836)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v4 + 824) + 8 * v172) = v90;
        ++*(_DWORD *)(v4 + 832);
        *(void *)(v4 + 816) = v90 + v171;
      }
      else
      {
        unint64_t v90 = (v89 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(v4 + 808) = v90 + 40;
      uint64_t v31 = v90 + 8;
      *(unsigned char *)(v90 + 16) = 7;
      *(_WORD *)(v90 + 17) = *(_WORD *)(v90 + 17) & 0xF000 | 0x540;
      *(void *)unint64_t v90 = 0;
      *(void *)(v90 + 8) = &unk_1F26197E0;
      BOOL v91 = "";
LABEL_446:
      *(void *)(v90 + 24) = v19;
      *(void *)(v90 + 32) = v91;
LABEL_447:
      unsigned int v206 = *(_DWORD *)(v4 + 916) + 1;
      int v207 = *(_DWORD *)(v4 + 912);
      if (v206 > 2 * v207)
      {
        llvm::FoldingSetBase::GrowBucketCount(v4 + 904, 2 * v207, (uint64_t)off_1F2644D00);
        *(void *)&long long v255 = v256;
        *((void *)&v255 + 1) = 0x2000000000;
        sub_1CD0714B4((unsigned int *)v90, (unsigned int *)&v255);
        uint64_t v22 = *(void *)(v4 + 904)
            + 8
            * ((*(_DWORD *)(v4 + 912) - 1) & sub_1CC13A6B8((void *)v255, v255 + 4 * DWORD2(v255)));
        if ((void *)v255 != v256) {
          free((void *)v255);
        }
        unsigned int v206 = *(_DWORD *)(v4 + 916) + 1;
      }
      *(_DWORD *)(v4 + 916) = v206;
      uint64_t v208 = *(void *)v22;
      if (!*(void *)v22) {
        uint64_t v208 = v22 | 1;
      }
      *(void *)unint64_t v90 = v208;
      *(void *)uint64_t v22 = v90;
LABEL_452:
      int v93 = 1;
LABEL_453:
      if (v251 != (char *)&v252 + 8) {
        free(v251);
      }
      if (v93)
      {
        *(void *)(v4 + 920) = v31;
      }
      else if (v31)
      {
        *(void *)&long long v255 = 0;
        int v209 = sub_1CD640748(v4 + 944, v31, &v255);
        uint64_t v210 = 0;
        if (v209) {
          uint64_t v210 = *(void *)(v255 + 8);
        }
        if (v210) {
          uint64_t v31 = v210;
        }
        if (v31 == *(void *)(v4 + 928)) {
          *(unsigned char *)(v4 + 936) = 1;
        }
      }
      return v31;
    case 'z':
      *(void *)a1 = v6 + 1;
      uint64_t v26 = "...";
LABEL_78:
      return sub_1CD06AF4C(a1, v26);
    default:
      goto LABEL_129;
  }
}

uint64_t sub_1CD06E334(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v6 = *(char **)a1;
  if (*(void *)(a1 + 8) == *(void *)a1) {
    goto LABEL_11;
  }
  int v7 = *v6;
  if (v7 == 90)
  {
    *(void *)a1 = v6 + 1;
    uint64_t v38 = sub_1CD06E7AC(a1);
    if (!v38) {
      return 0;
    }
    uint64_t v21 = *(char **)a1;
    unint64_t v20 = *(const char **)(a1 + 8);
    if (*(const char **)a1 == v20 || *v21 != 69) {
      return 0;
    }
    *(void *)a1 = v21 + 1;
    if (v21 + 1 == v20) {
      goto LABEL_31;
    }
    int v22 = v21[1];
    if (v22 == 100)
    {
      *(void *)a1 = v21 + 2;
      sub_1CC6B5BE0((char **)a1, 1);
      uint64_t v33 = *(char **)a1;
      if (*(void *)a1 == *(void *)(a1 + 8) || *v33 != 95) {
        return 0;
      }
      *(void *)a1 = v33 + 1;
      uint64_t v34 = sub_1CD06E334(a1, a2);
    }
    else
    {
      if (v22 != 115)
      {
LABEL_31:
        uint64_t v37 = sub_1CD06E334(a1, a2);
        if (!v37) {
          return 0;
        }
        *(void *)a1 = llvm::itanium_demangle::parse_discriminator(*(const char **)a1, *(const char **)(a1 + 8), v23);
        return sub_1CD088DAC(a1, &v38, &v37, v24);
      }
      *(void *)a1 = v21 + 2;
      *(void *)a1 = llvm::itanium_demangle::parse_discriminator(v21 + 2, v20, v19);
      uint64_t v34 = sub_1CD06AF4C(a1, "string literal");
    }
    uint64_t v37 = v34;
    if (!v34) {
      return 0;
    }
    return sub_1CD088DAC(a1, &v38, &v37, v24);
  }
  if (v7 != 78)
  {
LABEL_11:
    char v36 = 0;
    uint64_t v15 = sub_1CD07E648((const char **)a1, (unsigned char *)a2, &v36, a4);
    uint64_t v38 = v15;
    if (!v15) {
      return v15;
    }
    if (*(void *)(a1 + 8) == *(void *)a1 || **(unsigned char **)a1 != 73)
    {
      if (!v36) {
        return v15;
      }
      return 0;
    }
    if (!v36)
    {
      BOOL v16 = *(uint64_t **)(a1 + 304);
      if (v16 == *(uint64_t **)(a1 + 312))
      {
        sub_1CD5F0ACC(a1 + 296, ((uint64_t)v16 - *(void *)(a1 + 296)) >> 2);
        BOOL v16 = *(uint64_t **)(a1 + 304);
      }
      *(void *)(a1 + 304) = v16 + 1;
      *BOOL v16 = v15;
    }
    uint64_t v37 = sub_1CD07D418(a1, a2 != 0);
    if (!v37) {
      return 0;
    }
    if (a2) {
      *(unsigned char *)(a2 + 1) = 1;
    }
    return sub_1CD07DD24(a1, &v38, &v37, v17);
  }
  *(void *)a1 = v6 + 1;
  int v8 = sub_1CC6B8620(a1);
  if (a2) {
    *(_DWORD *)(a2 + 4) = v8;
  }
  unint64_t v11 = *(char **)a1;
  BOOL v12 = *(char **)(a1 + 8);
  if (*(char **)a1 == v12) {
    goto LABEL_33;
  }
  int v13 = *v11;
  if (v13 == 82)
  {
    *(void *)a1 = ++v11;
    if (a2)
    {
      char v14 = 1;
      goto LABEL_37;
    }
    goto LABEL_38;
  }
  if (v13 != 79)
  {
LABEL_33:
    if (a2)
    {
      char v14 = 0;
      goto LABEL_37;
    }
  }
  else
  {
    *(void *)a1 = ++v11;
    if (a2)
    {
      char v14 = 2;
LABEL_37:
      *(unsigned char *)(a2 + 8) = v14;
    }
  }
LABEL_38:
  uint64_t v15 = 0;
  uint64_t v38 = 0;
  while (v11 == v12 || *v11 != 69)
  {
    if (a2) {
      *(unsigned char *)(a2 + 1) = 0;
    }
    if (v11 == v12)
    {
LABEL_61:
      uint64_t v25 = 0;
LABEL_62:
      uint64_t v28 = sub_1CD0871B0(a1, (unsigned char *)a2, v15, v25);
      goto LABEL_63;
    }
    uint64_t v25 = 0;
    unsigned int v26 = *v11;
    if (v26 > 0x52)
    {
      if (v26 != 83)
      {
        if (v26 != 84) {
          goto LABEL_62;
        }
        if (v15) {
          return 0;
        }
        uint64_t v28 = sub_1CD07D120(a1);
        goto LABEL_63;
      }
      if ((unint64_t)(v12 - v11) >= 2 && v11[1] == 116)
      {
        *(void *)a1 = v11 + 2;
        uint64_t v31 = sub_1CD06AF4C(a1, "std");
      }
      else
      {
        uint64_t v31 = sub_1CD085A00(a1, v9, v10, 0);
      }
      uint64_t v25 = v31;
      if (!v31) {
        return 0;
      }
      if (*(unsigned char *)(v31 + 8) == 25) {
        goto LABEL_62;
      }
      if (v15) {
        return 0;
      }
      uint64_t v38 = v31;
      uint64_t v15 = v31;
      unint64_t v11 = *(char **)a1;
      BOOL v12 = *(char **)(a1 + 8);
    }
    else
    {
      if (v26 == 68)
      {
        if ((unint64_t)(v12 - v11) < 2 || (v11[1] | 0x20) != 0x74) {
          goto LABEL_61;
        }
        if (v15) {
          return 0;
        }
        uint64_t v28 = sub_1CD07C41C(a1);
      }
      else
      {
        if (v26 != 73) {
          goto LABEL_62;
        }
        if (!v15) {
          return v15;
        }
        uint64_t v37 = sub_1CD07D418(a1, a2 != 0);
        if (!v37 || *(unsigned char *)(v15 + 8) == 41) {
          return 0;
        }
        if (a2) {
          *(unsigned char *)(a2 + 1) = 1;
        }
        uint64_t v28 = sub_1CD07DD24(a1, &v38, &v37, v27);
      }
LABEL_63:
      uint64_t v15 = v28;
      uint64_t v38 = v28;
      if (!v28) {
        return v15;
      }
      int v29 = *(uint64_t **)(a1 + 304);
      if (v29 == *(uint64_t **)(a1 + 312))
      {
        sub_1CD5F0ACC(a1 + 296, ((uint64_t)v29 - *(void *)(a1 + 296)) >> 2);
        int v29 = *(uint64_t **)(a1 + 304);
      }
      *(void *)(a1 + 304) = v29 + 1;
      *int v29 = v15;
      unint64_t v11 = *(char **)a1;
      uint64_t v30 = *(char **)(a1 + 8);
      BOOL v12 = *(char **)a1;
      if (*(char **)a1 != v30)
      {
        BOOL v12 = *(char **)(a1 + 8);
        if (*v11 == 77)
        {
          *(void *)a1 = ++v11;
          BOOL v12 = v30;
        }
      }
    }
  }
  *(void *)a1 = v11 + 1;
  if (v15)
  {
    uint64_t v32 = *(void *)(a1 + 304);
    if (*(void *)(a1 + 296) != v32)
    {
      *(void *)(a1 + 304) = v32 - 8;
      return v15;
    }
    return 0;
  }
  return v15;
}

uint64_t sub_1CD06E7AC(unsigned __int8 **a1)
{
  v282[16] = *MEMORY[0x1E4F143B8];
  unint64_t v271 = (char *)a1;
  v272[0] = v273;
  v272[1] = v273;
  v272[2] = v274;
  memset(v273, 0, sizeof(v273));
  v274[0] = v275;
  v274[1] = v275;
  v274[2] = &v276;
  memset(v275, 0, sizeof(v275));
  sub_1CD5F0174((char *)v272, (uint64_t)(a1 + 83));
  sub_1CD5F0258((char *)v274, (uint64_t)(v271 + 576));
  uint64_t v4 = v271;
  *((void *)v271 + 84) = *((void *)v271 + 83);
  *((void *)v4 + 73) = *((void *)v4 + 72);
  unsigned int v5 = *a1;
  unint64_t v6 = a1[1];
  unint64_t v7 = v6 - *a1;
  if (v6 != *a1)
  {
    int v8 = *v5;
    if (v8 == 71)
    {
      if (v7 < 2) {
        goto LABEL_103;
      }
      int v39 = (char)v5[1];
      switch(v39)
      {
        case 'I':
          *a1 = v5 + 2;
          uint64_t v268 = 0;
          uint64_t v18 = 0;
          if (sub_1CD0883BC((uint64_t)a1, &v268)) {
            goto LABEL_104;
          }
          uint64_t v55 = v268;
          if (!v268) {
            goto LABEL_104;
          }
          int v56 = *((unsigned __int8 *)a1 + 937);
          v276 = (char *)&v277 + 8;
          long long v277 = xmmword_1CFB2EAE0;
          llvm::FoldingSetNodeID::AddString((unsigned int *)&v276, "initializer for module ", 0x17u);
          if (v277 >= DWORD1(v277)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((_DWORD *)v276 + v277) = v55;
          unsigned int v57 = v277 + 1;
          LODWORD(v277) = v57;
          if (v57 >= DWORD1(v277)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((_DWORD *)v276 + v57) = HIDWORD(v55);
          LODWORD(v277) = v277 + 1;
          unint64_t v58 = sub_1CC13A6B8(v276, (uint64_t)v276 + 4 * v277);
          uint64_t v60 = (uint64_t)&a1[113][8 * ((*((_DWORD *)a1 + 228) - 1) & v58)];
          BOOL v16 = *(unsigned int **)v60;
          int64_t v280 = v282;
          uint64_t v281 = 0x2000000000;
          if (v16 && (v16 & 1) == 0)
          {
            while (1)
            {
              LOBYTE(v58) = sub_1CD071418(v58, v16, (uint64_t)&v276, v59, (unsigned int *)&v280);
              if (v58) {
                break;
              }
              LODWORD(v281) = 0;
              BOOL v16 = *(unsigned int **)v16;
              if (v16) {
                BOOL v61 = (v16 & 1) == 0;
              }
              else {
                BOOL v61 = 0;
              }
              if (!v61)
              {
                BOOL v16 = 0;
                goto LABEL_231;
              }
            }
            uint64_t v60 = 0;
LABEL_231:
            if (v280 == v282)
            {
              if (v16) {
                goto LABEL_437;
              }
            }
            else
            {
              free(v280);
              if (v16) {
                goto LABEL_437;
              }
            }
          }
          if (v56)
          {
            a1[111] += 48;
            uint64_t v144 = a1[101];
            if (((unint64_t)(v144 + 7) & 0xFFFFFFFFFFFFFFF8) - (unint64_t)v144 + 48 > a1[102] - v144)
            {
              unsigned int v196 = *((_DWORD *)a1 + 208) >> 7;
              if (v196 >= 0x1E) {
                LOBYTE(v196) = 30;
              }
              uint64_t v197 = 4096 << v196;
              unint64_t v145 = (unint64_t)operator new(4096 << v196, (std::align_val_t)8uLL);
              unsigned int v198 = *((_DWORD *)a1 + 208);
              if (v198 >= *((_DWORD *)a1 + 209)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *(void *)&a1[103][8 * v198] = v145;
              ++*((_DWORD *)a1 + 208);
              a1[102] = (unsigned __int8 *)(v145 + v197);
            }
            else
            {
              unint64_t v145 = (unint64_t)(v144 + 7) & 0xFFFFFFFFFFFFFFF8;
            }
            a1[101] = (unsigned __int8 *)(v145 + 48);
            uint64_t v18 = v145 + 8;
            *(unsigned char *)(v145 + 16) = 20;
            *(_WORD *)(v145 + 17) = *(_WORD *)(v145 + 17) & 0xF000 | 0x540;
            *(void *)unint64_t v145 = 0;
            *(void *)(v145 + 8) = &unk_1F2619730;
            *(void *)(v145 + 24) = "initializer for module ";
            *(void *)(v145 + 32) = "";
            *(void *)(v145 + 40) = v55;
            unsigned int v146 = *((_DWORD *)a1 + 229) + 1;
            int v147 = *((_DWORD *)a1 + 228);
            if (v146 > 2 * v147)
            {
              llvm::FoldingSetBase::GrowBucketCount((uint64_t)(a1 + 113), 2 * v147, (uint64_t)off_1F2644D00);
              int64_t v280 = v282;
              uint64_t v281 = 0x2000000000;
              sub_1CD0714B4((unsigned int *)v145, (unsigned int *)&v280);
              uint64_t v60 = (uint64_t)&a1[113][8
                                    * ((*((_DWORD *)a1 + 228) - 1) & sub_1CC13A6B8(v280, (uint64_t)v280+ 4 * v281))];
              if (v280 != v282) {
                free(v280);
              }
              unsigned int v146 = *((_DWORD *)a1 + 229) + 1;
            }
            *((_DWORD *)a1 + 229) = v146;
            uint64_t v148 = *(void *)v60;
            if (!*(void *)v60) {
              uint64_t v148 = v60 | 1;
            }
            *(void *)unint64_t v145 = v148;
            *(void *)uint64_t v60 = v145;
            goto LABEL_314;
          }
          goto LABEL_287;
        case 'R':
          *a1 = v5 + 2;
          uint64_t v52 = sub_1CD06E334((uint64_t)a1, 0, v2, v3);
          uint64_t v18 = 0;
          if (!v52) {
            goto LABEL_104;
          }
          uint64_t v10 = v52;
          int v53 = sub_1CC6B7DD0(a1, &v268);
          BOOL v54 = *a1;
          if (*a1 == a1[1] || *v54 != 95)
          {
            if (!v53) {
              goto LABEL_103;
            }
          }
          else
          {
            *a1 = v54 + 1;
          }
          int v127 = *((unsigned __int8 *)a1 + 937);
          v276 = (char *)&v277 + 8;
          long long v277 = xmmword_1CFB2EAE0;
          llvm::FoldingSetNodeID::AddString((unsigned int *)&v276, "reference temporary for ", 0x18u);
          if (v277 >= DWORD1(v277)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((_DWORD *)v276 + v277) = v10;
          unsigned int v128 = v277 + 1;
          LODWORD(v277) = v128;
          if (v128 >= DWORD1(v277)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((_DWORD *)v276 + v128) = HIDWORD(v10);
          LODWORD(v277) = v277 + 1;
          unint64_t v129 = sub_1CC13A6B8(v276, (uint64_t)v276 + 4 * v277);
          uint64_t v15 = (uint64_t)&a1[113][8 * ((*((_DWORD *)a1 + 228) - 1) & v129)];
          BOOL v16 = *(unsigned int **)v15;
          int64_t v280 = v282;
          uint64_t v281 = 0x2000000000;
          if (v16 && (v16 & 1) == 0)
          {
            while (1)
            {
              LOBYTE(v129) = sub_1CD071418(v129, v16, (uint64_t)&v276, v130, (unsigned int *)&v280);
              if (v129) {
                break;
              }
              LODWORD(v281) = 0;
              BOOL v16 = *(unsigned int **)v16;
              if (v16) {
                BOOL v131 = (v16 & 1) == 0;
              }
              else {
                BOOL v131 = 0;
              }
              if (!v131)
              {
                BOOL v16 = 0;
                goto LABEL_241;
              }
            }
            uint64_t v15 = 0;
LABEL_241:
            if (v280 == v282)
            {
              if (v16) {
                goto LABEL_437;
              }
            }
            else
            {
              free(v280);
              if (v16) {
                goto LABEL_437;
              }
            }
          }
          if (!v127) {
            goto LABEL_287;
          }
          a1[111] += 48;
          unint64_t v149 = a1[101];
          if (((unint64_t)(v149 + 7) & 0xFFFFFFFFFFFFFFF8) - (unint64_t)v149 + 48 > a1[102] - v149)
          {
            unsigned int v199 = *((_DWORD *)a1 + 208) >> 7;
            if (v199 >= 0x1E) {
              LOBYTE(v199) = 30;
            }
            uint64_t v200 = 4096 << v199;
            v258 = (char *)operator new(4096 << v199, (std::align_val_t)8uLL);
            unsigned int v201 = *((_DWORD *)a1 + 208);
            if (v201 >= *((_DWORD *)a1 + 209)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            unint64_t v141 = (unint64_t)v258;
            *(void *)&a1[103][8 * v201] = v258;
            ++*((_DWORD *)a1 + 208);
            a1[102] = (unsigned __int8 *)&v258[v200];
          }
          else
          {
            unint64_t v141 = (unint64_t)(v149 + 7) & 0xFFFFFFFFFFFFFFF8;
          }
          uint64_t v142 = "reference temporary for ";
          a1[101] = (unsigned __int8 *)(v141 + 48);
          uint64_t v18 = v141 + 8;
          *(unsigned char *)(v141 + 16) = 20;
          *(_WORD *)(v141 + 17) = *(_WORD *)(v141 + 17) & 0xF000 | 0x540;
          *(void *)unint64_t v141 = 0;
          *(void *)(v141 + 8) = &unk_1F2619730;
          uint64_t v143 = "";
          break;
        case 'V':
          *a1 = v5 + 2;
          uint64_t v40 = sub_1CD06E334((uint64_t)a1, 0, v2, v3);
          uint64_t v18 = 0;
          if (!v40) {
            goto LABEL_104;
          }
          uint64_t v10 = v40;
          int v41 = *((unsigned __int8 *)a1 + 937);
          v276 = (char *)&v277 + 8;
          long long v277 = xmmword_1CFB2EAE0;
          llvm::FoldingSetNodeID::AddString((unsigned int *)&v276, "guard variable for ", 0x13u);
          if (v277 >= DWORD1(v277)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((_DWORD *)v276 + v277) = v10;
          unsigned int v42 = v277 + 1;
          LODWORD(v277) = v42;
          if (v42 >= DWORD1(v277)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((_DWORD *)v276 + v42) = HIDWORD(v10);
          LODWORD(v277) = v277 + 1;
          unint64_t v43 = sub_1CC13A6B8(v276, (uint64_t)v276 + 4 * v277);
          uint64_t v15 = (uint64_t)&a1[113][8 * ((*((_DWORD *)a1 + 228) - 1) & v43)];
          BOOL v16 = *(unsigned int **)v15;
          int64_t v280 = v282;
          uint64_t v281 = 0x2000000000;
          if (v16 && (v16 & 1) == 0)
          {
            while (1)
            {
              LOBYTE(v43) = sub_1CD071418(v43, v16, (uint64_t)&v276, v44, (unsigned int *)&v280);
              if (v43) {
                break;
              }
              LODWORD(v281) = 0;
              BOOL v16 = *(unsigned int **)v16;
              if (v16) {
                BOOL v45 = (v16 & 1) == 0;
              }
              else {
                BOOL v45 = 0;
              }
              if (!v45)
              {
                BOOL v16 = 0;
                goto LABEL_224;
              }
            }
            uint64_t v15 = 0;
LABEL_224:
            if (v280 == v282)
            {
              if (v16) {
                goto LABEL_437;
              }
            }
            else
            {
              free(v280);
              if (v16) {
                goto LABEL_437;
              }
            }
          }
          if (!v41) {
            goto LABEL_287;
          }
          a1[111] += 48;
          unsigned int v140 = a1[101];
          if (((unint64_t)(v140 + 7) & 0xFFFFFFFFFFFFFFF8) - (unint64_t)v140 + 48 > a1[102] - v140)
          {
            unsigned int v193 = *((_DWORD *)a1 + 208) >> 7;
            if (v193 >= 0x1E) {
              LOBYTE(v193) = 30;
            }
            uint64_t v194 = 4096 << v193;
            char v257 = (char *)operator new(4096 << v193, (std::align_val_t)8uLL);
            unsigned int v195 = *((_DWORD *)a1 + 208);
            if (v195 >= *((_DWORD *)a1 + 209)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            unint64_t v141 = (unint64_t)v257;
            *(void *)&a1[103][8 * v195] = v257;
            ++*((_DWORD *)a1 + 208);
            a1[102] = (unsigned __int8 *)&v257[v194];
          }
          else
          {
            unint64_t v141 = (unint64_t)(v140 + 7) & 0xFFFFFFFFFFFFFFF8;
          }
          uint64_t v142 = "guard variable for ";
          a1[101] = (unsigned __int8 *)(v141 + 48);
          uint64_t v18 = v141 + 8;
          *(unsigned char *)(v141 + 16) = 20;
          *(_WORD *)(v141 + 17) = *(_WORD *)(v141 + 17) & 0xF000 | 0x540;
          *(void *)unint64_t v141 = 0;
          *(void *)(v141 + 8) = &unk_1F2619730;
          uint64_t v143 = "";
          break;
        default:
          goto LABEL_103;
      }
LABEL_309:
      *(void *)(v141 + 24) = v142;
LABEL_310:
      *(void *)(v141 + 32) = v143;
      *(void *)(v141 + 40) = v10;
      unsigned int v170 = *((_DWORD *)a1 + 229) + 1;
      int v171 = *((_DWORD *)a1 + 228);
      if (v170 > 2 * v171)
      {
        unsigned int v223 = (unsigned int *)v141;
        llvm::FoldingSetBase::GrowBucketCount((uint64_t)(a1 + 113), 2 * v171, (uint64_t)off_1F2644D00);
        int64_t v280 = v282;
        uint64_t v281 = 0x2000000000;
        sub_1CD0714B4(v223, (unsigned int *)&v280);
        uint64_t v15 = (uint64_t)&a1[113][8
                              * ((*((_DWORD *)a1 + 228) - 1) & sub_1CC13A6B8(v280, (uint64_t)v280 + 4 * v281))];
        if (v280 != v282) {
          free(v280);
        }
        unsigned int v170 = *((_DWORD *)a1 + 229) + 1;
        unint64_t v141 = (unint64_t)v223;
      }
      *((_DWORD *)a1 + 229) = v170;
      uint64_t v172 = *(void *)v15;
      if (!*(void *)v15) {
        uint64_t v172 = v15 | 1;
      }
      *(void *)unint64_t v141 = v172;
      *(void *)uint64_t v15 = v141;
      goto LABEL_314;
    }
    if (v8 == 84)
    {
      if (v7 >= 2)
      {
        if (v7 > 2)
        {
          switch(v5[1])
          {
            case 'S':
              *a1 = v5 + 2;
              uint64_t v9 = sub_1CD06B2C4(a1);
              if (!v9) {
                goto LABEL_103;
              }
              uint64_t v10 = v9;
              int v11 = *((unsigned __int8 *)a1 + 937);
              v276 = (char *)&v277 + 8;
              long long v277 = xmmword_1CFB2EAE0;
              llvm::FoldingSetNodeID::AddString((unsigned int *)&v276, "typeinfo name for ", 0x12u);
              if (v277 >= DWORD1(v277)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((_DWORD *)v276 + v277) = v10;
              unsigned int v12 = v277 + 1;
              LODWORD(v277) = v12;
              if (v12 >= DWORD1(v277)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((_DWORD *)v276 + v12) = HIDWORD(v10);
              LODWORD(v277) = v277 + 1;
              unint64_t v13 = sub_1CC13A6B8(v276, (uint64_t)v276 + 4 * v277);
              uint64_t v15 = (uint64_t)&a1[113][8 * ((*((_DWORD *)a1 + 228) - 1) & v13)];
              BOOL v16 = *(unsigned int **)v15;
              int64_t v280 = v282;
              uint64_t v281 = 0x2000000000;
              if (!v16 || (v16 & 1) != 0) {
                goto LABEL_278;
              }
              while (1)
              {
                LOBYTE(v13) = sub_1CD071418(v13, v16, (uint64_t)&v276, v14, (unsigned int *)&v280);
                if (v13) {
                  break;
                }
                LODWORD(v281) = 0;
                BOOL v16 = *(unsigned int **)v16;
                if (v16) {
                  BOOL v17 = (v16 & 1) == 0;
                }
                else {
                  BOOL v17 = 0;
                }
                if (!v17)
                {
                  BOOL v16 = 0;
                  goto LABEL_276;
                }
              }
              uint64_t v15 = 0;
LABEL_276:
              if (v280 == v282)
              {
                if (v16) {
                  goto LABEL_437;
                }
              }
              else
              {
                free(v280);
                if (v16) {
                  goto LABEL_437;
                }
              }
LABEL_278:
              if (!v11) {
                goto LABEL_287;
              }
              a1[111] += 48;
              uint64_t v155 = a1[101];
              if (((unint64_t)(v155 + 7) & 0xFFFFFFFFFFFFFFF8) - (unint64_t)v155 + 48 > a1[102] - v155)
              {
                unsigned int v214 = *((_DWORD *)a1 + 208) >> 7;
                if (v214 >= 0x1E) {
                  LOBYTE(v214) = 30;
                }
                uint64_t v215 = 4096 << v214;
                v263 = (char *)operator new(4096 << v214, (std::align_val_t)8uLL);
                unsigned int v216 = *((_DWORD *)a1 + 208);
                if (v216 >= *((_DWORD *)a1 + 209)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                unint64_t v141 = (unint64_t)v263;
                *(void *)&a1[103][8 * v216] = v263;
                ++*((_DWORD *)a1 + 208);
                a1[102] = (unsigned __int8 *)&v263[v215];
              }
              else
              {
                unint64_t v141 = (unint64_t)(v155 + 7) & 0xFFFFFFFFFFFFFFF8;
              }
              a1[101] = (unsigned __int8 *)(v141 + 48);
              uint64_t v18 = v141 + 8;
              *(unsigned char *)(v141 + 16) = 20;
              *(_WORD *)(v141 + 17) = *(_WORD *)(v141 + 17) & 0xF000 | 0x540;
              *(void *)unint64_t v141 = 0;
              *(void *)(v141 + 8) = &unk_1F2619730;
              uint64_t v151 = "typeinfo name for ";
              uint64_t v143 = "";
              goto LABEL_282;
            case 'T':
              *a1 = v5 + 2;
              uint64_t v120 = sub_1CD06B2C4(a1);
              if (!v120) {
                goto LABEL_103;
              }
              uint64_t v10 = v120;
              int v121 = *((unsigned __int8 *)a1 + 937);
              v276 = (char *)&v277 + 8;
              long long v277 = xmmword_1CFB2EAE0;
              llvm::FoldingSetNodeID::AddString((unsigned int *)&v276, "VTT for ", 8u);
              if (v277 >= DWORD1(v277)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((_DWORD *)v276 + v277) = v10;
              unsigned int v122 = v277 + 1;
              LODWORD(v277) = v122;
              if (v122 >= DWORD1(v277)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((_DWORD *)v276 + v122) = HIDWORD(v10);
              LODWORD(v277) = v277 + 1;
              unint64_t v123 = sub_1CC13A6B8(v276, (uint64_t)v276 + 4 * v277);
              uint64_t v15 = (uint64_t)&a1[113][8 * ((*((_DWORD *)a1 + 228) - 1) & v123)];
              BOOL v16 = *(unsigned int **)v15;
              int64_t v280 = v282;
              uint64_t v281 = 0x2000000000;
              if (!v16 || (v16 & 1) != 0) {
                goto LABEL_286;
              }
              while (1)
              {
                LOBYTE(v123) = sub_1CD071418(v123, v16, (uint64_t)&v276, v124, (unsigned int *)&v280);
                if (v123) {
                  break;
                }
                LODWORD(v281) = 0;
                BOOL v16 = *(unsigned int **)v16;
                if (v16) {
                  BOOL v125 = (v16 & 1) == 0;
                }
                else {
                  BOOL v125 = 0;
                }
                if (!v125)
                {
                  BOOL v16 = 0;
                  goto LABEL_284;
                }
              }
              uint64_t v15 = 0;
LABEL_284:
              if (v280 == v282)
              {
                if (v16) {
                  goto LABEL_437;
                }
              }
              else
              {
                free(v280);
                if (v16) {
                  goto LABEL_437;
                }
              }
LABEL_286:
              if (!v121) {
                goto LABEL_287;
              }
              a1[111] += 48;
              BOOL v169 = a1[101];
              if (((unint64_t)(v169 + 7) & 0xFFFFFFFFFFFFFFF8) - (unint64_t)v169 + 48 > a1[102] - v169)
              {
                unsigned int v217 = *((_DWORD *)a1 + 208) >> 7;
                if (v217 >= 0x1E) {
                  LOBYTE(v217) = 30;
                }
                uint64_t v218 = 4096 << v217;
                uint64_t v264 = (char *)operator new(4096 << v217, (std::align_val_t)8uLL);
                unsigned int v219 = *((_DWORD *)a1 + 208);
                if (v219 >= *((_DWORD *)a1 + 209)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                unint64_t v141 = (unint64_t)v264;
                *(void *)&a1[103][8 * v219] = v264;
                ++*((_DWORD *)a1 + 208);
                a1[102] = (unsigned __int8 *)&v264[v218];
              }
              else
              {
                unint64_t v141 = (unint64_t)(v169 + 7) & 0xFFFFFFFFFFFFFFF8;
              }
              uint64_t v142 = "VTT for ";
              a1[101] = (unsigned __int8 *)(v141 + 48);
              uint64_t v18 = v141 + 8;
              *(unsigned char *)(v141 + 16) = 20;
              *(_WORD *)(v141 + 17) = *(_WORD *)(v141 + 17) & 0xF000 | 0x540;
              *(void *)unint64_t v141 = 0;
              *(void *)(v141 + 8) = &unk_1F2619730;
              uint64_t v143 = "";
              goto LABEL_309;
            case 'U':
              goto LABEL_98;
            case 'V':
              *a1 = v5 + 2;
              uint64_t v114 = sub_1CD06B2C4(a1);
              if (!v114) {
                goto LABEL_103;
              }
              uint64_t v10 = v114;
              int v115 = *((unsigned __int8 *)a1 + 937);
              v276 = (char *)&v277 + 8;
              long long v277 = xmmword_1CFB2EAE0;
              llvm::FoldingSetNodeID::AddString((unsigned int *)&v276, "vtable for ", 0xBu);
              if (v277 >= DWORD1(v277)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((_DWORD *)v276 + v277) = v10;
              unsigned int v116 = v277 + 1;
              LODWORD(v277) = v116;
              if (v116 >= DWORD1(v277)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((_DWORD *)v276 + v116) = HIDWORD(v10);
              LODWORD(v277) = v277 + 1;
              unint64_t v117 = sub_1CC13A6B8(v276, (uint64_t)v276 + 4 * v277);
              uint64_t v15 = (uint64_t)&a1[113][8 * ((*((_DWORD *)a1 + 228) - 1) & v117)];
              BOOL v16 = *(unsigned int **)v15;
              int64_t v280 = v282;
              uint64_t v281 = 0x2000000000;
              if (!v16 || (v16 & 1) != 0) {
                goto LABEL_271;
              }
              while (1)
              {
                LOBYTE(v117) = sub_1CD071418(v117, v16, (uint64_t)&v276, v118, (unsigned int *)&v280);
                if (v117) {
                  break;
                }
                LODWORD(v281) = 0;
                BOOL v16 = *(unsigned int **)v16;
                if (v16) {
                  BOOL v119 = (v16 & 1) == 0;
                }
                else {
                  BOOL v119 = 0;
                }
                if (!v119)
                {
                  BOOL v16 = 0;
                  goto LABEL_269;
                }
              }
              uint64_t v15 = 0;
LABEL_269:
              if (v280 == v282)
              {
                if (v16) {
                  goto LABEL_437;
                }
              }
              else
              {
                free(v280);
                if (v16) {
                  goto LABEL_437;
                }
              }
LABEL_271:
              if (!v115) {
                goto LABEL_287;
              }
              a1[111] += 48;
              uint64_t v154 = a1[101];
              if (((unint64_t)(v154 + 7) & 0xFFFFFFFFFFFFFFF8) - (unint64_t)v154 + 48 > a1[102] - v154)
              {
                unsigned int v211 = *((_DWORD *)a1 + 208) >> 7;
                if (v211 >= 0x1E) {
                  LOBYTE(v211) = 30;
                }
                uint64_t v212 = 4096 << v211;
                v262 = (char *)operator new(4096 << v211, (std::align_val_t)8uLL);
                unsigned int v213 = *((_DWORD *)a1 + 208);
                if (v213 >= *((_DWORD *)a1 + 209)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                unint64_t v141 = (unint64_t)v262;
                *(void *)&a1[103][8 * v213] = v262;
                ++*((_DWORD *)a1 + 208);
                a1[102] = (unsigned __int8 *)&v262[v212];
              }
              else
              {
                unint64_t v141 = (unint64_t)(v154 + 7) & 0xFFFFFFFFFFFFFFF8;
              }
              a1[101] = (unsigned __int8 *)(v141 + 48);
              uint64_t v18 = v141 + 8;
              *(unsigned char *)(v141 + 16) = 20;
              *(_WORD *)(v141 + 17) = *(_WORD *)(v141 + 17) & 0xF000 | 0x540;
              *(void *)unint64_t v141 = 0;
              *(void *)(v141 + 8) = &unk_1F2619730;
              uint64_t v151 = "vtable for ";
              uint64_t v143 = "";
              goto LABEL_282;
            case 'W':
              *a1 = v5 + 2;
              uint64_t v18 = 0;
              int64_t v280 = (void *)sub_1CD06E334((uint64_t)a1, 0, v2, v3);
              if (!v280) {
                goto LABEL_104;
              }
              uint64_t v126 = sub_1CD08985C((uint64_t)a1, "thread-local wrapper routine for ", (uint64_t *)&v280);
              goto LABEL_488;
            default:
              if (v5[1] != 99) {
                goto LABEL_98;
              }
              *a1 = v5 + 2;
              if (sub_1CC6B7CFC((uint64_t)a1)) {
                goto LABEL_103;
              }
              if (sub_1CC6B7CFC((uint64_t)a1)) {
                goto LABEL_103;
              }
              uint64_t v62 = sub_1CD06E7AC(a1);
              if (!v62) {
                goto LABEL_103;
              }
              uint64_t v10 = v62;
              int v63 = *((unsigned __int8 *)a1 + 937);
              v276 = (char *)&v277 + 8;
              long long v277 = xmmword_1CFB2EAE0;
              llvm::FoldingSetNodeID::AddString((unsigned int *)&v276, "covariant return thunk to ", 0x1Au);
              if (v277 >= DWORD1(v277)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((_DWORD *)v276 + v277) = v10;
              unsigned int v64 = v277 + 1;
              LODWORD(v277) = v64;
              if (v64 >= DWORD1(v277)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((_DWORD *)v276 + v64) = HIDWORD(v10);
              LODWORD(v277) = v277 + 1;
              unint64_t v65 = sub_1CC13A6B8(v276, (uint64_t)v276 + 4 * v277);
              uint64_t v15 = (uint64_t)&a1[113][8 * ((*((_DWORD *)a1 + 228) - 1) & v65)];
              BOOL v16 = *(unsigned int **)v15;
              int64_t v280 = v282;
              uint64_t v281 = 0x2000000000;
              if (!v16 || (v16 & 1) != 0) {
                goto LABEL_325;
              }
              break;
          }
          while (1)
          {
            LOBYTE(v65) = sub_1CD071418(v65, v16, (uint64_t)&v276, v66, (unsigned int *)&v280);
            if (v65) {
              break;
            }
            LODWORD(v281) = 0;
            BOOL v16 = *(unsigned int **)v16;
            if (v16) {
              BOOL v67 = (v16 & 1) == 0;
            }
            else {
              BOOL v67 = 0;
            }
            if (!v67)
            {
              BOOL v16 = 0;
              goto LABEL_323;
            }
          }
          uint64_t v15 = 0;
LABEL_323:
          if (v280 == v282)
          {
            if (!v16) {
              goto LABEL_325;
            }
          }
          else
          {
            free(v280);
            if (!v16)
            {
LABEL_325:
              if (v63)
              {
                a1[111] += 48;
                unsigned int v180 = a1[101];
                if (((unint64_t)(v180 + 7) & 0xFFFFFFFFFFFFFFF8) - (unint64_t)v180 + 48 > a1[102] - v180)
                {
                  unsigned int v224 = *((_DWORD *)a1 + 208) >> 7;
                  if (v224 >= 0x1E) {
                    LOBYTE(v224) = 30;
                  }
                  uint64_t v225 = 4096 << v224;
                  uint64_t v265 = (char *)operator new(4096 << v224, (std::align_val_t)8uLL);
                  unsigned int v226 = *((_DWORD *)a1 + 208);
                  if (v226 >= *((_DWORD *)a1 + 209)) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  unint64_t v141 = (unint64_t)v265;
                  *(void *)&a1[103][8 * v226] = v265;
                  ++*((_DWORD *)a1 + 208);
                  a1[102] = (unsigned __int8 *)&v265[v225];
                }
                else
                {
                  unint64_t v141 = (unint64_t)(v180 + 7) & 0xFFFFFFFFFFFFFFF8;
                }
                uint64_t v142 = "covariant return thunk to ";
                a1[101] = (unsigned __int8 *)(v141 + 48);
                uint64_t v18 = v141 + 8;
                *(unsigned char *)(v141 + 16) = 20;
                *(_WORD *)(v141 + 17) = *(_WORD *)(v141 + 17) & 0xF000 | 0x540;
                *(void *)unint64_t v141 = 0;
                *(void *)(v141 + 8) = &unk_1F2619730;
                uint64_t v143 = "";
                goto LABEL_309;
              }
              goto LABEL_287;
            }
          }
LABEL_437:
          int v173 = 0;
          uint64_t v18 = (uint64_t)(v16 + 2);
          goto LABEL_438;
        }
        switch(v5[1])
        {
          case 'A':
            *a1 = v5 + 2;
            uint64_t v46 = sub_1CD0810A0(a1);
            if (!v46) {
              goto LABEL_103;
            }
            uint64_t v10 = v46;
            int v47 = *((unsigned __int8 *)a1 + 937);
            v276 = (char *)&v277 + 8;
            long long v277 = xmmword_1CFB2EAE0;
            llvm::FoldingSetNodeID::AddString((unsigned int *)&v276, "template parameter object for ", 0x1Eu);
            if (v277 >= DWORD1(v277)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((_DWORD *)v276 + v277) = v10;
            unsigned int v48 = v277 + 1;
            LODWORD(v277) = v48;
            if (v48 >= DWORD1(v277)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((_DWORD *)v276 + v48) = HIDWORD(v10);
            LODWORD(v277) = v277 + 1;
            unint64_t v49 = sub_1CC13A6B8(v276, (uint64_t)v276 + 4 * v277);
            uint64_t v15 = (uint64_t)&a1[113][8 * ((*((_DWORD *)a1 + 228) - 1) & v49)];
            BOOL v16 = *(unsigned int **)v15;
            int64_t v280 = v282;
            uint64_t v281 = 0x2000000000;
            if (!v16 || (v16 & 1) != 0) {
              goto LABEL_257;
            }
            while (1)
            {
              LOBYTE(v49) = sub_1CD071418(v49, v16, (uint64_t)&v276, v50, (unsigned int *)&v280);
              if (v49) {
                break;
              }
              LODWORD(v281) = 0;
              BOOL v16 = *(unsigned int **)v16;
              if (v16) {
                BOOL v51 = (v16 & 1) == 0;
              }
              else {
                BOOL v51 = 0;
              }
              if (!v51)
              {
                BOOL v16 = 0;
                goto LABEL_255;
              }
            }
            uint64_t v15 = 0;
LABEL_255:
            if (v280 == v282)
            {
              if (v16) {
                goto LABEL_437;
              }
            }
            else
            {
              free(v280);
              if (v16) {
                goto LABEL_437;
              }
            }
LABEL_257:
            if (!v47) {
              goto LABEL_287;
            }
            a1[111] += 48;
            BOOL v152 = a1[101];
            if (((unint64_t)(v152 + 7) & 0xFFFFFFFFFFFFFFF8) - (unint64_t)v152 + 48 > a1[102] - v152)
            {
              unsigned int v205 = *((_DWORD *)a1 + 208) >> 7;
              if (v205 >= 0x1E) {
                LOBYTE(v205) = 30;
              }
              uint64_t v206 = 4096 << v205;
              v260 = (char *)operator new(4096 << v205, (std::align_val_t)8uLL);
              unsigned int v207 = *((_DWORD *)a1 + 208);
              if (v207 >= *((_DWORD *)a1 + 209)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              unint64_t v141 = (unint64_t)v260;
              *(void *)&a1[103][8 * v207] = v260;
              ++*((_DWORD *)a1 + 208);
              a1[102] = (unsigned __int8 *)&v260[v206];
            }
            else
            {
              unint64_t v141 = (unint64_t)(v152 + 7) & 0xFFFFFFFFFFFFFFF8;
            }
            a1[101] = (unsigned __int8 *)(v141 + 48);
            uint64_t v18 = v141 + 8;
            *(unsigned char *)(v141 + 16) = 20;
            *(_WORD *)(v141 + 17) = *(_WORD *)(v141 + 17) & 0xF000 | 0x540;
            *(void *)unint64_t v141 = 0;
            *(void *)(v141 + 8) = &unk_1F2619730;
            uint64_t v151 = "template parameter object for ";
            uint64_t v143 = "";
            goto LABEL_282;
          case 'B':
          case 'D':
          case 'E':
          case 'F':
          case 'G':
            break;
          case 'C':
            *a1 = v5 + 2;
            uint64_t v90 = sub_1CD06B2C4(a1);
            if (!v90) {
              goto LABEL_103;
            }
            uint64_t v91 = v90;
            uint64_t v92 = sub_1CC6B5BE0((char **)a1, 1);
            if (v92 == v93) {
              goto LABEL_103;
            }
            uint64_t v94 = *a1;
            if (*a1 == a1[1]) {
              goto LABEL_103;
            }
            if (*v94 != 95) {
              goto LABEL_103;
            }
            *a1 = v94 + 1;
            uint64_t v95 = sub_1CD06B2C4(a1);
            if (!v95) {
              goto LABEL_103;
            }
            uint64_t v97 = v95;
            int v98 = *((unsigned __int8 *)a1 + 937);
            v276 = (char *)&v277 + 8;
            uint64_t v278 = v95;
            uint64_t v279 = v91;
            long long v277 = xmmword_1CFB2EAF0;
            if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
            {
              int v250 = v98;
              uint64_t v95 = __cxa_guard_acquire(&qword_1EBCBE588);
              int v98 = v250;
              if (v95)
              {
                unint64_t v251 = llvm::hashing::detail::fixed_seed_override;
                if (!llvm::hashing::detail::fixed_seed_override) {
                  unint64_t v251 = 0xFF51AFD7ED558CCDLL;
                }
                qword_1EBCBE580 = v251;
                __cxa_guard_release(&qword_1EBCBE588);
                int v98 = v250;
              }
            }
            uint64_t v99 = __ROR8__(0xB492B66FBE98F273 * *((void *)&v277 + 1) - v278, 43);
            uint64_t v100 = __ROR8__((0x9AE16A3B2F90404FLL * v279) ^ qword_1EBCBE580, 30);
            unint64_t v101 = qword_1EBCBE580
                 + __ROR8__(v278 ^ 0xC949D7C7509E6557, 20)
                 - 0x4B6D499041670D8DLL * *((void *)&v277 + 1)
                 - 0x9AE16A3B2F90404FLL * v279
                 + 24;
            unint64_t v102 = 0x9DDFEA08EB382D69
                 * (v101 ^ ((0x9DDFEA08EB382D69 * ((v99 - 0x3C5A37A36834CED9 * v278 + v100) ^ v101)) >> 47) ^ (0x9DDFEA08EB382D69 * ((v99 - 0x3C5A37A36834CED9 * v278 + v100) ^ v101)));
            char v103 = (unsigned int **)&a1[113][8
                                           * ((-348639895 * ((v102 >> 47) ^ v102)) & (*((_DWORD *)a1 + 228) - 1))];
            unsigned int v104 = *v103;
            int64_t v280 = v282;
            uint64_t v281 = 0x2000000000;
            if (v104) {
              BOOL v105 = (v104 & 1) == 0;
            }
            else {
              BOOL v105 = 0;
            }
            if (!v105) {
              goto LABEL_332;
            }
            uint64_t v253 = v103;
            int v106 = v98;
            while (1)
            {
              LOBYTE(v95) = sub_1CD071418(v95, v104, (uint64_t)&v276, v96, (unsigned int *)&v280);
              if (v95) {
                break;
              }
              LODWORD(v281) = 0;
              unsigned int v104 = *(unsigned int **)v104;
              if (v104) {
                BOOL v107 = (v104 & 1) == 0;
              }
              else {
                BOOL v107 = 0;
              }
              if (!v107)
              {
                unsigned int v104 = 0;
                int v98 = v106;
                char v103 = v253;
                goto LABEL_330;
              }
            }
            char v103 = 0;
            int v98 = v106;
LABEL_330:
            if (v280 == v282)
            {
              if (!v104) {
                goto LABEL_332;
              }
            }
            else
            {
              uint64_t v249 = v103;
              free(v280);
              char v103 = v249;
              int v98 = v106;
              if (!v104)
              {
LABEL_332:
                if (v98)
                {
                  uint64_t v181 = (uint64_t)v103;
                  a1[111] += 40;
                  unsigned int v182 = a1[101];
                  if (((unint64_t)(v182 + 7) & 0xFFFFFFFFFFFFFFF8) - (unint64_t)v182 + 40 > a1[102] - v182)
                  {
                    unsigned int v228 = *((_DWORD *)a1 + 208) >> 7;
                    if (v228 >= 0x1E) {
                      LOBYTE(v228) = 30;
                    }
                    uint64_t v229 = 4096 << v228;
                    unint64_t v183 = (unint64_t)operator new(4096 << v228, (std::align_val_t)8uLL);
                    unsigned int v230 = *((_DWORD *)a1 + 208);
                    if (v230 >= *((_DWORD *)a1 + 209)) {
                      llvm::SmallVectorBase<unsigned int>::grow_pod();
                    }
                    *(void *)&a1[103][8 * v230] = v183;
                    ++*((_DWORD *)a1 + 208);
                    a1[102] = (unsigned __int8 *)(v183 + v229);
                  }
                  else
                  {
                    unint64_t v183 = (unint64_t)(v182 + 7) & 0xFFFFFFFFFFFFFFF8;
                  }
                  a1[101] = (unsigned __int8 *)(v183 + 40);
                  uint64_t v18 = v183 + 8;
                  *(unsigned char *)(v183 + 16) = 21;
                  *(_WORD *)(v183 + 17) = *(_WORD *)(v183 + 17) & 0xF000 | 0x540;
                  *(void *)unint64_t v183 = 0;
                  *(void *)(v183 + 8) = &unk_1F2619788;
                  *(void *)(v183 + 24) = v97;
                  *(void *)(v183 + 32) = v91;
                  unsigned int v184 = *((_DWORD *)a1 + 229) + 1;
                  int v185 = *((_DWORD *)a1 + 228);
                  if (v184 > 2 * v185)
                  {
                    llvm::FoldingSetBase::GrowBucketCount((uint64_t)(a1 + 113), 2 * v185, (uint64_t)off_1F2644D00);
                    int64_t v280 = v282;
                    uint64_t v281 = 0x2000000000;
                    sub_1CD0714B4((unsigned int *)v183, (unsigned int *)&v280);
                    uint64_t v181 = (uint64_t)&a1[113][8
                                           * ((*((_DWORD *)a1 + 228) - 1) & sub_1CC13A6B8(v280, (uint64_t)v280+ 4 * v281))];
                    if (v280 != v282) {
                      free(v280);
                    }
                    unsigned int v184 = *((_DWORD *)a1 + 229) + 1;
                  }
                  *((_DWORD *)a1 + 229) = v184;
                  uint64_t v186 = *(void *)v181;
                  if (!*(void *)v181) {
                    uint64_t v186 = v181 | 1;
                  }
                  *(void *)unint64_t v183 = v186;
                  *(void *)uint64_t v181 = v183;
                }
                else
                {
                  uint64_t v18 = 0;
                }
                int v173 = 1;
LABEL_517:
                unint64_t v231 = (char *)v276;
                goto LABEL_439;
              }
            }
            int v173 = 0;
            uint64_t v18 = (uint64_t)(v104 + 2);
            goto LABEL_517;
          case 'H':
            *a1 = v5 + 2;
            uint64_t v84 = sub_1CD06E334((uint64_t)a1, 0, v2, v3);
            uint64_t v18 = 0;
            if (!v84) {
              goto LABEL_104;
            }
            uint64_t v10 = v84;
            int v85 = *((unsigned __int8 *)a1 + 937);
            v276 = (char *)&v277 + 8;
            long long v277 = xmmword_1CFB2EAE0;
            llvm::FoldingSetNodeID::AddString((unsigned int *)&v276, "thread-local initialization routine for ", 0x28u);
            if (v277 >= DWORD1(v277)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((_DWORD *)v276 + v277) = v10;
            unsigned int v86 = v277 + 1;
            LODWORD(v277) = v86;
            if (v86 >= DWORD1(v277)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((_DWORD *)v276 + v86) = HIDWORD(v10);
            LODWORD(v277) = v277 + 1;
            unint64_t v87 = sub_1CC13A6B8(v276, (uint64_t)v276 + 4 * v277);
            uint64_t v15 = (uint64_t)&a1[113][8 * ((*((_DWORD *)a1 + 228) - 1) & v87)];
            BOOL v16 = *(unsigned int **)v15;
            int64_t v280 = v282;
            uint64_t v281 = 0x2000000000;
            if (!v16 || (v16 & 1) != 0) {
              goto LABEL_250;
            }
            while (1)
            {
              LOBYTE(v87) = sub_1CD071418(v87, v16, (uint64_t)&v276, v88, (unsigned int *)&v280);
              if (v87) {
                break;
              }
              LODWORD(v281) = 0;
              BOOL v16 = *(unsigned int **)v16;
              if (v16) {
                BOOL v89 = (v16 & 1) == 0;
              }
              else {
                BOOL v89 = 0;
              }
              if (!v89)
              {
                BOOL v16 = 0;
                goto LABEL_248;
              }
            }
            uint64_t v15 = 0;
LABEL_248:
            if (v280 == v282)
            {
              if (v16) {
                goto LABEL_437;
              }
            }
            else
            {
              free(v280);
              if (v16) {
                goto LABEL_437;
              }
            }
LABEL_250:
            if (!v85) {
              goto LABEL_287;
            }
            a1[111] += 48;
            uint64_t v150 = a1[101];
            if (((unint64_t)(v150 + 7) & 0xFFFFFFFFFFFFFFF8) - (unint64_t)v150 + 48 > a1[102] - v150)
            {
              unsigned int v202 = *((_DWORD *)a1 + 208) >> 7;
              if (v202 >= 0x1E) {
                LOBYTE(v202) = 30;
              }
              uint64_t v203 = 4096 << v202;
              int v259 = (char *)operator new(4096 << v202, (std::align_val_t)8uLL);
              unsigned int v204 = *((_DWORD *)a1 + 208);
              if (v204 >= *((_DWORD *)a1 + 209)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              unint64_t v141 = (unint64_t)v259;
              *(void *)&a1[103][8 * v204] = v259;
              ++*((_DWORD *)a1 + 208);
              a1[102] = (unsigned __int8 *)&v259[v203];
            }
            else
            {
              unint64_t v141 = (unint64_t)(v150 + 7) & 0xFFFFFFFFFFFFFFF8;
            }
            a1[101] = (unsigned __int8 *)(v141 + 48);
            uint64_t v18 = v141 + 8;
            *(unsigned char *)(v141 + 16) = 20;
            *(_WORD *)(v141 + 17) = *(_WORD *)(v141 + 17) & 0xF000 | 0x540;
            *(void *)unint64_t v141 = 0;
            *(void *)(v141 + 8) = &unk_1F2619730;
            uint64_t v151 = "thread-local initialization routine for ";
            uint64_t v143 = "";
            goto LABEL_282;
          case 'I':
            *a1 = v5 + 2;
            uint64_t v108 = sub_1CD06B2C4(a1);
            if (!v108) {
              goto LABEL_103;
            }
            uint64_t v10 = v108;
            int v109 = *((unsigned __int8 *)a1 + 937);
            v276 = (char *)&v277 + 8;
            long long v277 = xmmword_1CFB2EAE0;
            llvm::FoldingSetNodeID::AddString((unsigned int *)&v276, "typeinfo for ", 0xDu);
            if (v277 >= DWORD1(v277)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((_DWORD *)v276 + v277) = v10;
            unsigned int v110 = v277 + 1;
            LODWORD(v277) = v110;
            if (v110 >= DWORD1(v277)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((_DWORD *)v276 + v110) = HIDWORD(v10);
            LODWORD(v277) = v277 + 1;
            unint64_t v111 = sub_1CC13A6B8(v276, (uint64_t)v276 + 4 * v277);
            uint64_t v15 = (uint64_t)&a1[113][8 * ((*((_DWORD *)a1 + 228) - 1) & v111)];
            BOOL v16 = *(unsigned int **)v15;
            int64_t v280 = v282;
            uint64_t v281 = 0x2000000000;
            if (!v16 || (v16 & 1) != 0) {
              goto LABEL_264;
            }
            while (1)
            {
              LOBYTE(v111) = sub_1CD071418(v111, v16, (uint64_t)&v276, v112, (unsigned int *)&v280);
              if (v111) {
                break;
              }
              LODWORD(v281) = 0;
              BOOL v16 = *(unsigned int **)v16;
              if (v16) {
                BOOL v113 = (v16 & 1) == 0;
              }
              else {
                BOOL v113 = 0;
              }
              if (!v113)
              {
                BOOL v16 = 0;
                goto LABEL_262;
              }
            }
            uint64_t v15 = 0;
LABEL_262:
            if (v280 == v282)
            {
              if (v16) {
                goto LABEL_437;
              }
            }
            else
            {
              free(v280);
              if (v16) {
                goto LABEL_437;
              }
            }
LABEL_264:
            if (!v109) {
              goto LABEL_287;
            }
            a1[111] += 48;
            BOOL v153 = a1[101];
            if (((unint64_t)(v153 + 7) & 0xFFFFFFFFFFFFFFF8) - (unint64_t)v153 + 48 > a1[102] - v153)
            {
              unsigned int v208 = *((_DWORD *)a1 + 208) >> 7;
              if (v208 >= 0x1E) {
                LOBYTE(v208) = 30;
              }
              uint64_t v209 = 4096 << v208;
              unint64_t v261 = (char *)operator new(4096 << v208, (std::align_val_t)8uLL);
              unsigned int v210 = *((_DWORD *)a1 + 208);
              if (v210 >= *((_DWORD *)a1 + 209)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              unint64_t v141 = (unint64_t)v261;
              *(void *)&a1[103][8 * v210] = v261;
              ++*((_DWORD *)a1 + 208);
              a1[102] = (unsigned __int8 *)&v261[v209];
            }
            else
            {
              unint64_t v141 = (unint64_t)(v153 + 7) & 0xFFFFFFFFFFFFFFF8;
            }
            a1[101] = (unsigned __int8 *)(v141 + 48);
            uint64_t v18 = v141 + 8;
            *(unsigned char *)(v141 + 16) = 20;
            *(_WORD *)(v141 + 17) = *(_WORD *)(v141 + 17) & 0xF000 | 0x540;
            *(void *)unint64_t v141 = 0;
            *(void *)(v141 + 8) = &unk_1F2619730;
            uint64_t v151 = "typeinfo for ";
            uint64_t v143 = "";
LABEL_282:
            *(void *)(v141 + 24) = v151;
            goto LABEL_310;
          default:
            JUMPOUT(0);
        }
      }
LABEL_98:
      unint64_t v68 = v5 + 1;
      *a1 = v68;
      BOOL v69 = v6 != v68 && *v68 == 118;
      if (sub_1CC6B7CFC((uint64_t)a1)) {
        goto LABEL_103;
      }
      unint64_t v70 = sub_1CD06E7AC(a1);
      if (!v70) {
        goto LABEL_103;
      }
      unint64_t v72 = v70;
      int v73 = *((unsigned __int8 *)a1 + 937);
      unint64_t v74 = HIDWORD(v70);
      if (v69)
      {
        v276 = (char *)&v277 + 8;
        long long v277 = xmmword_1CFB2EAE0;
        llvm::FoldingSetNodeID::AddString((unsigned int *)&v276, "virtual thunk to ", 0x11u);
        if (v277 >= DWORD1(v277)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((_DWORD *)v276 + v277) = v72;
        unsigned int v75 = v277 + 1;
        LODWORD(v277) = v75;
        if (v75 >= DWORD1(v277)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((_DWORD *)v276 + v75) = v74;
        LODWORD(v277) = v277 + 1;
        unint64_t v76 = sub_1CC13A6B8(v276, (uint64_t)v276 + 4 * v277);
        uint64_t v78 = (uint64_t)&a1[113][8 * ((*((_DWORD *)a1 + 228) - 1) & v76)];
        BOOL v16 = *(unsigned int **)v78;
        int64_t v280 = v282;
        uint64_t v281 = 0x2000000000;
        if (v16 && (v16 & 1) == 0)
        {
          while (1)
          {
            LOBYTE(v76) = sub_1CD071418(v76, v16, (uint64_t)&v276, v77, (unsigned int *)&v280);
            if (v76) {
              break;
            }
            LODWORD(v281) = 0;
            BOOL v16 = *(unsigned int **)v16;
            if (v16) {
              BOOL v79 = (v16 & 1) == 0;
            }
            else {
              BOOL v79 = 0;
            }
            if (!v79)
            {
              BOOL v16 = 0;
              goto LABEL_206;
            }
          }
          uint64_t v78 = 0;
LABEL_206:
          if (v280 == v282)
          {
            if (v16) {
              goto LABEL_437;
            }
          }
          else
          {
            free(v280);
            if (v16) {
              goto LABEL_437;
            }
          }
        }
        if (v73)
        {
          a1[111] += 48;
          std::string::size_type v132 = a1[101];
          if (((unint64_t)(v132 + 7) & 0xFFFFFFFFFFFFFFF8) - (unint64_t)v132 + 48 > a1[102] - v132)
          {
            unsigned int v187 = *((_DWORD *)a1 + 208) >> 7;
            if (v187 >= 0x1E) {
              LOBYTE(v187) = 30;
            }
            uint64_t v188 = 4096 << v187;
            long long v255 = (char *)operator new(4096 << v187, (std::align_val_t)8uLL);
            unsigned int v189 = *((_DWORD *)a1 + 208);
            if (v189 >= *((_DWORD *)a1 + 209)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            unint64_t v133 = (unint64_t)v255;
            *(void *)&a1[103][8 * v189] = v255;
            ++*((_DWORD *)a1 + 208);
            a1[102] = (unsigned __int8 *)&v255[v188];
          }
          else
          {
            unint64_t v133 = (unint64_t)(v132 + 7) & 0xFFFFFFFFFFFFFFF8;
          }
          a1[101] = (unsigned __int8 *)(v133 + 48);
          uint64_t v18 = v133 + 8;
          *(unsigned char *)(v133 + 16) = 20;
          *(_WORD *)(v133 + 17) = *(_WORD *)(v133 + 17) & 0xF000 | 0x540;
          *(void *)unint64_t v133 = 0;
          *(void *)(v133 + 8) = &unk_1F2619730;
          int v134 = "virtual thunk to ";
          int v135 = "";
LABEL_219:
          *(void *)(v133 + 24) = v134;
          *(void *)(v133 + 32) = v135;
          *(void *)(v133 + 40) = v72;
          unsigned int v137 = *((_DWORD *)a1 + 229) + 1;
          int v138 = *((_DWORD *)a1 + 228);
          if (v137 > 2 * v138)
          {
            unsigned int v227 = (unsigned int *)v133;
            llvm::FoldingSetBase::GrowBucketCount((uint64_t)(a1 + 113), 2 * v138, (uint64_t)off_1F2644D00);
            int64_t v280 = v282;
            uint64_t v281 = 0x2000000000;
            sub_1CD0714B4(v227, (unsigned int *)&v280);
            uint64_t v78 = (uint64_t)&a1[113][8
                                  * ((*((_DWORD *)a1 + 228) - 1) & sub_1CC13A6B8(v280, (uint64_t)v280+ 4 * v281))];
            if (v280 != v282) {
              free(v280);
            }
            unsigned int v137 = *((_DWORD *)a1 + 229) + 1;
            unint64_t v133 = (unint64_t)v227;
          }
          *((_DWORD *)a1 + 229) = v137;
          uint64_t v139 = *(void *)v78;
          if (!*(void *)v78) {
            uint64_t v139 = v78 | 1;
          }
          *(void *)unint64_t v133 = v139;
          *(void *)uint64_t v78 = v133;
          goto LABEL_314;
        }
      }
      else
      {
        v276 = (char *)&v277 + 8;
        long long v277 = xmmword_1CFB2EAE0;
        llvm::FoldingSetNodeID::AddString((unsigned int *)&v276, "non-virtual thunk to ", 0x15u);
        if (v277 >= DWORD1(v277)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((_DWORD *)v276 + v277) = v72;
        unsigned int v80 = v277 + 1;
        LODWORD(v277) = v80;
        if (v80 >= DWORD1(v277)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((_DWORD *)v276 + v80) = v74;
        LODWORD(v277) = v277 + 1;
        unint64_t v81 = sub_1CC13A6B8(v276, (uint64_t)v276 + 4 * v277);
        uint64_t v78 = (uint64_t)&a1[113][8 * ((*((_DWORD *)a1 + 228) - 1) & v81)];
        BOOL v16 = *(unsigned int **)v78;
        int64_t v280 = v282;
        uint64_t v281 = 0x2000000000;
        if (v16 && (v16 & 1) == 0)
        {
          while (1)
          {
            LOBYTE(v81) = sub_1CD071418(v81, v16, (uint64_t)&v276, v82, (unsigned int *)&v280);
            if (v81) {
              break;
            }
            LODWORD(v281) = 0;
            BOOL v16 = *(unsigned int **)v16;
            if (v16) {
              BOOL v83 = (v16 & 1) == 0;
            }
            else {
              BOOL v83 = 0;
            }
            if (!v83)
            {
              BOOL v16 = 0;
              goto LABEL_213;
            }
          }
          uint64_t v78 = 0;
LABEL_213:
          if (v280 == v282)
          {
            if (v16) {
              goto LABEL_437;
            }
          }
          else
          {
            free(v280);
            if (v16) {
              goto LABEL_437;
            }
          }
        }
        if (v73)
        {
          a1[111] += 48;
          BOOL v136 = a1[101];
          if (((unint64_t)(v136 + 7) & 0xFFFFFFFFFFFFFFF8) - (unint64_t)v136 + 48 > a1[102] - v136)
          {
            unsigned int v190 = *((_DWORD *)a1 + 208) >> 7;
            if (v190 >= 0x1E) {
              LOBYTE(v190) = 30;
            }
            uint64_t v191 = 4096 << v190;
            uint64_t v256 = (char *)operator new(4096 << v190, (std::align_val_t)8uLL);
            unsigned int v192 = *((_DWORD *)a1 + 208);
            if (v192 >= *((_DWORD *)a1 + 209)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            unint64_t v133 = (unint64_t)v256;
            *(void *)&a1[103][8 * v192] = v256;
            ++*((_DWORD *)a1 + 208);
            a1[102] = (unsigned __int8 *)&v256[v191];
          }
          else
          {
            unint64_t v133 = (unint64_t)(v136 + 7) & 0xFFFFFFFFFFFFFFF8;
          }
          a1[101] = (unsigned __int8 *)(v133 + 48);
          uint64_t v18 = v133 + 8;
          *(unsigned char *)(v133 + 16) = 20;
          *(_WORD *)(v133 + 17) = *(_WORD *)(v133 + 17) & 0xF000 | 0x540;
          *(void *)unint64_t v133 = 0;
          *(void *)(v133 + 8) = &unk_1F2619730;
          int v134 = "non-virtual thunk to ";
          int v135 = "";
          goto LABEL_219;
        }
      }
LABEL_287:
      uint64_t v18 = 0;
LABEL_314:
      int v173 = 1;
LABEL_438:
      unint64_t v231 = (char *)v276;
LABEL_439:
      if (v231 != (char *)&v277 + 8) {
        free(v231);
      }
      if (v173)
      {
        a1[115] = (unsigned __int8 *)v18;
      }
      else if (v18)
      {
        int64_t v280 = 0;
        int v232 = sub_1CD640748((uint64_t)(a1 + 118), v18, &v280);
        uint64_t v233 = 0;
        if (v232) {
          uint64_t v233 = v280[1];
        }
        if (v233) {
          uint64_t v18 = v233;
        }
        if ((unsigned __int8 *)v18 == a1[116]) {
          *((unsigned char *)a1 + 936) = 1;
        }
      }
      goto LABEL_104;
    }
  }
  LOWORD(v268) = 0;
  HIDWORD(v268) = 0;
  v269[0] = 0;
  unint64_t v270 = (a1[91] - a1[90]) >> 3;
  uint64_t v18 = sub_1CD06E334((uint64_t)a1, (uint64_t)&v268, v2, v3);
  uint64_t v267 = v18;
  if (!v18) {
    goto LABEL_104;
  }
  unint64_t v19 = v270;
  unint64_t v20 = a1[90];
  unint64_t v21 = (a1[91] - v20) >> 3;
  BOOL v22 = v21 > v270;
  unint64_t v23 = v21 - v270;
  if (v22)
  {
    uint64_t v24 = a1[83];
    if (v24 != a1[84])
    {
      uint64_t v25 = &v20[8 * v270];
      while (*(void *)v24)
      {
        unint64_t v26 = *(void *)(*(void *)v25 + 16);
        uint64_t v27 = **(void **)v24;
        if (v26 >= (*(void *)(*(void *)v24 + 8) - v27) >> 3) {
          break;
        }
        *(void *)(*(void *)v25 + 24) = *(void *)(v27 + 8 * v26);
        v25 += 8;
        if (!--v23) {
          goto LABEL_26;
        }
      }
    }
    goto LABEL_103;
  }
LABEL_26:
  a1[91] = &v20[8 * v19];
  uint64_t v28 = *a1;
  int v29 = a1[1];
  unint64_t v30 = v29 - *a1;
  if (v29 == *a1) {
    goto LABEL_104;
  }
  unsigned int v31 = *v28 - 46;
  BOOL v22 = v31 > 0x31;
  uint64_t v32 = (1 << v31) & 0x2000000800001;
  if (!v22 && v32 != 0) {
    goto LABEL_104;
  }
  uint64_t v266 = 0;
  if (v30 >= 0xD && !strncmp("Ua9enable_ifI", (const char *)v28, 0xDuLL))
  {
    uint64_t v34 = v28 + 13;
    *a1 = v28 + 13;
    uint64_t v35 = (a1[3] - a1[2]) >> 3;
    while (v34 == v29 || *v34 != 69)
    {
      uint64_t v36 = sub_1CD0810A0(a1);
      if (!v36) {
        goto LABEL_103;
      }
      uint64_t v37 = v36;
      uint64_t v38 = a1[3];
      if (v38 == a1[4])
      {
        sub_1CD5F0ACC((uint64_t)(a1 + 2), (v38 - a1[2]) >> 2);
        uint64_t v38 = a1[3];
      }
      a1[3] = v38 + 8;
      *(void *)uint64_t v38 = v37;
      uint64_t v34 = *a1;
      int v29 = a1[1];
    }
    *a1 = v34 + 1;
    uint64_t v156 = a1[3];
    uint64_t v157 = &a1[2][8 * v35];
    v158 = (uint64_t *)sub_1CB906F34((uint64_t *)a1 + 101, v156 - v157, 3);
    int v159 = v158;
    uint64_t v160 = v156 - v157;
    BOOL v254 = v158;
    if (v156 != v157)
    {
      memmove(v158, v157, v156 - v157);
      int v159 = v254;
    }
    a1[3] = &a1[2][8 * v35];
    int v161 = *((unsigned __int8 *)a1 + 937);
    v276 = (char *)&v277 + 8;
    *(void *)&long long v277 = 0x2000000000;
    uint64_t v252 = v160 >> 3;
    sub_1CD074590((uint64_t)&v276, 9, v159, v160 >> 3);
    unint64_t v162 = sub_1CC13A6B8(v276, (uint64_t)v276 + 4 * v277);
    uint64_t v164 = (uint64_t)&a1[113][8 * ((*((_DWORD *)a1 + 228) - 1) & v162)];
    int v165 = *(unsigned int **)v164;
    int64_t v280 = v282;
    uint64_t v281 = 0x2000000000;
    if (v165) {
      BOOL v166 = (v165 & 1) == 0;
    }
    else {
      BOOL v166 = 0;
    }
    if (!v166) {
      goto LABEL_304;
    }
    while (1)
    {
      LOBYTE(v162) = sub_1CD071418(v162, v165, (uint64_t)&v276, v163, (unsigned int *)&v280);
      if (v162) {
        break;
      }
      LODWORD(v281) = 0;
      int v165 = *(unsigned int **)v165;
      if (v165) {
        BOOL v167 = (v165 & 1) == 0;
      }
      else {
        BOOL v167 = 0;
      }
      if (!v167)
      {
        int v165 = 0;
        goto LABEL_302;
      }
    }
    uint64_t v164 = 0;
LABEL_302:
    if (v280 == v282)
    {
      if (!v165)
      {
LABEL_304:
        if (v161)
        {
          a1[111] += 40;
          uint64_t v174 = a1[101];
          if (((unint64_t)(v174 + 7) & 0xFFFFFFFFFFFFFFF8) - (unint64_t)v174 + 40 > a1[102] - v174)
          {
            unsigned int v220 = *((_DWORD *)a1 + 208) >> 7;
            if (v220 >= 0x1E) {
              LOBYTE(v220) = 30;
            }
            uint64_t v221 = 4096 << v220;
            unint64_t v175 = (unint64_t)operator new(4096 << v220, (std::align_val_t)8uLL);
            unsigned int v222 = *((_DWORD *)a1 + 208);
            if (v222 >= *((_DWORD *)a1 + 209)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)&a1[103][8 * v222] = v175;
            ++*((_DWORD *)a1 + 208);
            a1[102] = (unsigned __int8 *)(v175 + v221);
          }
          else
          {
            unint64_t v175 = (unint64_t)(v174 + 7) & 0xFFFFFFFFFFFFFFF8;
          }
          a1[101] = (unsigned __int8 *)(v175 + 40);
          uint64_t v168 = v175 + 8;
          *(unsigned char *)(v175 + 16) = 9;
          *(_WORD *)(v175 + 17) = *(_WORD *)(v175 + 17) & 0xF000 | 0x540;
          *(void *)unint64_t v175 = 0;
          *(void *)(v175 + 8) = &unk_1F261ABD0;
          *(void *)(v175 + 24) = v254;
          *(void *)(v175 + 32) = v252;
          unsigned int v176 = *((_DWORD *)a1 + 229) + 1;
          int v177 = *((_DWORD *)a1 + 228);
          if (v176 > 2 * v177)
          {
            llvm::FoldingSetBase::GrowBucketCount((uint64_t)(a1 + 113), 2 * v177, (uint64_t)off_1F2644D00);
            int64_t v280 = v282;
            uint64_t v281 = 0x2000000000;
            sub_1CD0714B4((unsigned int *)v175, (unsigned int *)&v280);
            uint64_t v164 = (uint64_t)&a1[113][8
                                   * ((*((_DWORD *)a1 + 228) - 1) & sub_1CC13A6B8(v280, (uint64_t)v280+ 4 * v281))];
            if (v280 != v282) {
              free(v280);
            }
            unsigned int v176 = *((_DWORD *)a1 + 229) + 1;
          }
          *((_DWORD *)a1 + 229) = v176;
          uint64_t v178 = *(void *)v164;
          if (!*(void *)v164) {
            uint64_t v178 = v164 | 1;
          }
          *(void *)unint64_t v175 = v178;
          *(void *)uint64_t v164 = v175;
        }
        else
        {
          uint64_t v168 = 0;
        }
        int v179 = 1;
LABEL_464:
        if (v276 != (char *)&v277 + 8) {
          free(v276);
        }
        if (v179)
        {
          a1[115] = (unsigned __int8 *)v168;
        }
        else
        {
          if (!v168) {
            goto LABEL_103;
          }
          int64_t v280 = 0;
          int v247 = sub_1CD640748((uint64_t)(a1 + 118), v168, &v280);
          uint64_t v248 = 0;
          if (v247) {
            uint64_t v248 = v280[1];
          }
          if (v248) {
            uint64_t v168 = v248;
          }
          if ((unsigned __int8 *)v168 == a1[116]) {
            *((unsigned char *)a1 + 936) = 1;
          }
        }
        uint64_t v266 = v168;
        if (!v168)
        {
LABEL_103:
          uint64_t v18 = 0;
          goto LABEL_104;
        }
        goto LABEL_469;
      }
    }
    else
    {
      free(v280);
      if (!v165) {
        goto LABEL_304;
      }
    }
    int v179 = 0;
    uint64_t v168 = (uint64_t)(v165 + 2);
    goto LABEL_464;
  }
LABEL_469:
  v276 = 0;
  if (!(_BYTE)v268)
  {
    if (BYTE1(v268))
    {
      v276 = (void *)sub_1CD06B2C4(a1);
      if (!v276) {
        goto LABEL_103;
      }
    }
  }
  uint64_t v234 = *a1;
  if (*a1 == a1[1] || *v234 != 118)
  {
    uint64_t v236 = (a1[3] - a1[2]) >> 3;
    while (1)
    {
      uint64_t v237 = sub_1CD06B2C4(a1);
      if (!v237) {
        goto LABEL_103;
      }
      uint64_t v238 = v237;
      unint64_t v239 = a1[3];
      if (v239 == a1[4])
      {
        sub_1CD5F0ACC((uint64_t)(a1 + 2), (v239 - a1[2]) >> 2);
        unint64_t v239 = a1[3];
      }
      a1[3] = v239 + 8;
      *(void *)unint64_t v239 = v238;
      if (a1[1] != *a1)
      {
        unsigned int v240 = **a1 - 46;
        BOOL v22 = v240 > 0x31;
        uint64_t v241 = (1 << v240) & 0x2000000800001;
        if (v22 || v241 == 0) {
          continue;
        }
      }
      unint64_t v243 = a1[3];
      unint64_t v244 = &a1[2][8 * v236];
      uint64_t v245 = (void *)sub_1CB906F34((uint64_t *)a1 + 101, v243 - v244, 3);
      v246 = v245;
      if (v243 != v244) {
        memmove(v245, v244, v243 - v244);
      }
      a1[3] = &a1[2][8 * v236];
      int64_t v280 = v246;
      uint64_t v281 = (v243 - v244) >> 3;
      uint64_t v235 = (uint64_t)a1;
      goto LABEL_487;
    }
  }
  *a1 = v234 + 1;
  int64_t v280 = 0;
  uint64_t v281 = 0;
  uint64_t v235 = (uint64_t)a1;
LABEL_487:
  uint64_t v126 = sub_1CD089234(v235, (uint64_t *)&v276, &v267, (uint64_t)&v280, &v266, (int *)&v268 + 1, v269);
LABEL_488:
  uint64_t v18 = v126;
LABEL_104:
  sub_1CD5F0174(v271 + 664, (uint64_t)v272);
  sub_1CD5F0258(v271 + 576, (uint64_t)v274);
  if (v274[0] != v275) {
    free(v274[0]);
  }
  if (v272[0] != v273) {
    free(v272[0]);
  }
  return v18;
}

unsigned int *sub_1CD07140C(uint64_t a1, unsigned int *a2, unsigned int *a3)
{
  return sub_1CD0714B4(a2, a3);
}

BOOL sub_1CD071418(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, unsigned int *a5)
{
  sub_1CD0714B4(a2, a5);
  uint64_t v7 = *(unsigned int *)(a3 + 8);
  return v7 == a5[2] && memcmp(*(const void **)a5, *(const void **)a3, 4 * v7) == 0;
}

unint64_t sub_1CD071478(uint64_t a1, unsigned int *a2, unsigned int *a3)
{
  return sub_1CC13A6B8(*(void **)a3, *(void *)a3 + 4 * a3[2]);
}

unsigned int *sub_1CD0714B4(unsigned int *result, unsigned int *a2)
{
  switch(*((unsigned char *)result + 16))
  {
    case 0:
      uint64_t v3 = (uint64_t *)*((void *)result + 3);
      uint64_t v4 = *((void *)result + 4);
      uint64_t v5 = (uint64_t)a2;
      int v6 = 0;
      goto LABEL_152;
    case 1:
      uint64_t v8 = *((void *)result + 3);
      uint64_t v7 = (unsigned __int8 *)*((void *)result + 4);
      uint64_t v9 = *((void *)result + 5);
      unsigned int v10 = a2[2];
      if (v10 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v11 = *(void *)a2;
      int v12 = 1;
      goto LABEL_274;
    case 2:
      uint64_t v14 = *((void *)result + 3);
      unint64_t v13 = (unsigned __int8 *)*((void *)result + 4);
      uint64_t v16 = *((void *)result + 5);
      unint64_t v15 = *((void *)result + 6);
      unsigned int v17 = a2[2];
      if (v17 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v17) = 2;
      unsigned int v18 = a2[3];
      unsigned int v19 = a2[2] + 1;
      a2[2] = v19;
      if (v19 >= v18) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v19) = 0;
      unsigned int v20 = a2[3];
      unsigned int v21 = a2[2] + 1;
      a2[2] = v21;
      if (v21 >= v20) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v21) = v14;
      unsigned int v22 = a2[3];
      unsigned int v23 = a2[2] + 1;
      a2[2] = v23;
      if (v23 >= v22) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v23) = HIDWORD(v14);
      ++a2[2];
      uint64_t result = llvm::FoldingSetNodeID::AddString(a2, v13, (int)v16 - (int)v13);
      unsigned int v24 = a2[2];
      unsigned int v25 = a2[3];
      goto LABEL_268;
    case 3:
      uint64_t v26 = *((void *)result + 3);
      unsigned int v27 = result[5];
      unsigned int v28 = a2[2];
      if (v28 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v29 = *(void *)a2;
      int v30 = 3;
      goto LABEL_97;
    case 4:
      unint64_t v15 = *((void *)result + 3);
      unsigned int v31 = a2[2];
      if (v31 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v32 = *(void *)a2;
      int v33 = 4;
      goto LABEL_264;
    case 5:
      uint64_t v8 = *((void *)result + 3);
      uint64_t v7 = (unsigned __int8 *)*((void *)result + 4);
      uint64_t v9 = *((void *)result + 5);
      unsigned int v10 = a2[2];
      if (v10 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v11 = *(void *)a2;
      int v12 = 5;
      goto LABEL_274;
    case 6:
      uint64_t v34 = (unsigned __int8 *)*((void *)result + 3);
      uint64_t v35 = *((void *)result + 4);
      unint64_t v36 = *((void *)result + 5);
      unsigned int v37 = a2[2];
      if (v37 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v38 = *(void *)a2;
      int v39 = 6;
      goto LABEL_73;
    case 7:
      uint64_t v40 = (unsigned __int8 *)*((void *)result + 3);
      uint64_t v41 = *((void *)result + 4);
      unsigned int v42 = a2[2];
      if (v42 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v43 = *(void *)a2;
      int v44 = 7;
      goto LABEL_287;
    case 8:
      uint64_t v8 = *((void *)result + 3);
      uint64_t v7 = (unsigned __int8 *)*((void *)result + 4);
      uint64_t v9 = *((void *)result + 5);
      unsigned int v10 = a2[2];
      if (v10 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v11 = *(void *)a2;
      int v12 = 8;
      goto LABEL_274;
    case 9:
      uint64_t v3 = (uint64_t *)*((void *)result + 3);
      uint64_t v4 = *((void *)result + 4);
      uint64_t v5 = (uint64_t)a2;
      int v6 = 9;
      goto LABEL_152;
    case 0xA:
      uint64_t v8 = *((void *)result + 3);
      uint64_t v7 = (unsigned __int8 *)*((void *)result + 4);
      uint64_t v9 = *((void *)result + 5);
      unsigned int v10 = a2[2];
      if (v10 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v11 = *(void *)a2;
      int v12 = 10;
      goto LABEL_274;
    case 0xB:
      unint64_t v15 = *((void *)result + 3);
      unsigned int v31 = a2[2];
      if (v31 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v32 = *(void *)a2;
      int v33 = 11;
      goto LABEL_264;
    case 0xC:
      uint64_t v45 = *((void *)result + 3);
      int v46 = result[8];
      unsigned int v47 = a2[2];
      if (v47 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v47) = 12;
      unsigned int v48 = a2[3];
      unsigned int v49 = a2[2] + 1;
      a2[2] = v49;
      if (v49 >= v48) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v49) = 0;
      unsigned int v50 = a2[3];
      unsigned int v51 = a2[2] + 1;
      a2[2] = v51;
      if (v51 >= v50) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v51) = v45;
      unsigned int v52 = a2[3];
      unsigned int v53 = a2[2] + 1;
      a2[2] = v53;
      if (v53 >= v52) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v53) = HIDWORD(v45);
      goto LABEL_141;
    case 0xD:
      uint64_t v54 = *((void *)result + 3);
      unint64_t v15 = *((void *)result + 4);
      unsigned int v55 = a2[2];
      if (v55 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v56 = *(void *)a2;
      int v57 = 13;
      goto LABEL_120;
    case 0xE:
      uint64_t v54 = *((void *)result + 3);
      unint64_t v15 = *((void *)result + 4);
      unsigned int v55 = a2[2];
      if (v55 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v56 = *(void *)a2;
      int v57 = 14;
      goto LABEL_120;
    case 0xF:
      uint64_t v59 = *((void *)result + 3);
      unint64_t v58 = (uint64_t *)*((void *)result + 4);
      uint64_t v60 = *((void *)result + 5);
      unsigned int v61 = result[12];
      int v62 = *((unsigned __int8 *)result + 52);
      unint64_t v15 = *((void *)result + 7);
      unsigned int v63 = a2[2];
      if (v63 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v63) = 15;
      unsigned int v64 = a2[3];
      unsigned int v65 = a2[2] + 1;
      a2[2] = v65;
      if (v65 >= v64) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v65) = 0;
      unsigned int v66 = a2[3];
      unsigned int v67 = a2[2] + 1;
      a2[2] = v67;
      if (v67 >= v66) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v67) = v59;
      unsigned int v68 = a2[3];
      unsigned int v69 = a2[2] + 1;
      a2[2] = v69;
      if (v69 >= v68) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v69) = HIDWORD(v59);
      unsigned int v70 = a2[3];
      unsigned int v71 = a2[2] + 1;
      a2[2] = v71;
      if (v71 >= v70) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v71) = v60;
      unsigned int v72 = a2[3];
      unsigned int v73 = a2[2] + 1;
      a2[2] = v73;
      if (v73 >= v72) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v73) = HIDWORD(v60);
      unsigned int v74 = a2[2] + 1;
      a2[2] = v74;
      if (v60)
      {
        uint64_t v75 = 8 * v60;
        do
        {
          uint64_t v76 = *v58;
          if (v74 >= a2[3]) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(_DWORD *)(*(void *)a2 + 4 * v74) = v76;
          unsigned int v77 = a2[3];
          unsigned int v78 = a2[2] + 1;
          a2[2] = v78;
          if (v78 >= v77) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(_DWORD *)(*(void *)a2 + 4 * v78) = HIDWORD(v76);
          unsigned int v74 = a2[2] + 1;
          a2[2] = v74;
          ++v58;
          v75 -= 8;
        }
        while (v75);
      }
      if (v74 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v74) = v61;
      unsigned int v347 = a2[3];
      unsigned int v348 = a2[2] + 1;
      a2[2] = v348;
      if (v348 >= v347) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v348) = 0;
      unsigned int v349 = a2[3];
      unsigned int v350 = a2[2] + 1;
      a2[2] = v350;
      if (v350 >= v349) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v350) = v62;
      goto LABEL_265;
    case 0x10:
      unint64_t v15 = *((void *)result + 3);
      unsigned int v31 = a2[2];
      if (v31 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v32 = *(void *)a2;
      int v33 = 16;
      goto LABEL_264;
    case 0x11:
      uint64_t v3 = (uint64_t *)*((void *)result + 3);
      uint64_t v4 = *((void *)result + 4);
      uint64_t v5 = (uint64_t)a2;
      int v6 = 17;
      goto LABEL_152;
    case 0x12:
      uint64_t v80 = *((void *)result + 3);
      uint64_t v79 = *((void *)result + 4);
      unint64_t v81 = (uint64_t *)*((void *)result + 5);
      uint64_t v82 = *((void *)result + 6);
      uint64_t v83 = *((void *)result + 7);
      unsigned int v84 = result[16];
      unsigned int v27 = *((unsigned __int8 *)result + 68);
      unsigned int v85 = a2[2];
      if (v85 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v85) = 18;
      unsigned int v86 = a2[3];
      unsigned int v87 = a2[2] + 1;
      a2[2] = v87;
      if (v87 >= v86) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v87) = 0;
      unsigned int v88 = a2[3];
      unsigned int v89 = a2[2] + 1;
      a2[2] = v89;
      if (v89 >= v88) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v89) = v80;
      unsigned int v90 = a2[3];
      unsigned int v91 = a2[2] + 1;
      a2[2] = v91;
      if (v91 >= v90) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v91) = HIDWORD(v80);
      unsigned int v92 = a2[3];
      unsigned int v93 = a2[2] + 1;
      a2[2] = v93;
      if (v93 >= v92) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v93) = v79;
      unsigned int v94 = a2[3];
      unsigned int v95 = a2[2] + 1;
      a2[2] = v95;
      if (v95 >= v94) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v95) = HIDWORD(v79);
      unsigned int v96 = a2[3];
      unsigned int v97 = a2[2] + 1;
      a2[2] = v97;
      if (v97 >= v96) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v97) = v82;
      unsigned int v98 = a2[3];
      unsigned int v99 = a2[2] + 1;
      a2[2] = v99;
      if (v99 >= v98) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v99) = HIDWORD(v82);
      unsigned int v100 = a2[2] + 1;
      a2[2] = v100;
      if (v82)
      {
        uint64_t v101 = 8 * v82;
        do
        {
          uint64_t v102 = *v81;
          if (v100 >= a2[3]) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(_DWORD *)(*(void *)a2 + 4 * v100) = v102;
          unsigned int v103 = a2[3];
          unsigned int v104 = a2[2] + 1;
          a2[2] = v104;
          if (v104 >= v103) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(_DWORD *)(*(void *)a2 + 4 * v104) = HIDWORD(v102);
          unsigned int v100 = a2[2] + 1;
          a2[2] = v100;
          ++v81;
          v101 -= 8;
        }
        while (v101);
      }
      if (v100 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v100) = v83;
      unsigned int v351 = a2[3];
      unsigned int v352 = a2[2] + 1;
      a2[2] = v352;
      if (v352 >= v351) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v352) = HIDWORD(v83);
      unsigned int v353 = a2[3];
      unsigned int v354 = a2[2] + 1;
      a2[2] = v354;
      if (v354 >= v353) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v354) = v84;
      goto LABEL_315;
    case 0x13:
      unint64_t v15 = *((void *)result + 3);
      unsigned int v31 = a2[2];
      if (v31 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v32 = *(void *)a2;
      int v33 = 19;
      goto LABEL_264;
    case 0x14:
      uint64_t v34 = (unsigned __int8 *)*((void *)result + 3);
      uint64_t v35 = *((void *)result + 4);
      unint64_t v36 = *((void *)result + 5);
      unsigned int v37 = a2[2];
      if (v37 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v38 = *(void *)a2;
      int v39 = 20;
LABEL_73:
      *(_DWORD *)(v38 + 4 * v37) = v39;
      unsigned int v105 = a2[3];
      unsigned int v106 = a2[2] + 1;
      a2[2] = v106;
      if (v106 >= v105) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v106) = 0;
      ++a2[2];
      uint64_t result = llvm::FoldingSetNodeID::AddString(a2, v34, (int)v35 - (int)v34);
      unsigned int v107 = a2[2];
      if (v107 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v107) = v36;
      unsigned int v108 = a2[3];
      unsigned int v109 = a2[2] + 1;
      a2[2] = v109;
      if (v109 >= v108) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      unint64_t v110 = HIDWORD(v36);
      goto LABEL_271;
    case 0x15:
      uint64_t v54 = *((void *)result + 3);
      unint64_t v15 = *((void *)result + 4);
      unsigned int v55 = a2[2];
      if (v55 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v56 = *(void *)a2;
      int v57 = 21;
      goto LABEL_120;
    case 0x16:
      uint64_t v54 = *((void *)result + 3);
      unint64_t v15 = *((void *)result + 4);
      unsigned int v55 = a2[2];
      if (v55 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v56 = *(void *)a2;
      int v57 = 22;
      goto LABEL_120;
    case 0x17:
      uint64_t v54 = *((void *)result + 3);
      unint64_t v15 = *((void *)result + 4);
      unsigned int v55 = a2[2];
      if (v55 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v56 = *(void *)a2;
      int v57 = 23;
      goto LABEL_120;
    case 0x18:
      uint64_t v54 = *((void *)result + 3);
      unint64_t v15 = *((void *)result + 4);
      unsigned int v55 = a2[2];
      if (v55 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v56 = *(void *)a2;
      int v57 = 24;
      goto LABEL_120;
    case 0x19:
      uint64_t v111 = *((void *)result + 3);
      uint64_t v26 = *((void *)result + 4);
      unsigned int v27 = *((unsigned __int8 *)result + 40);
      unsigned int v112 = a2[2];
      if (v112 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v113 = *(void *)a2;
      int v114 = 25;
      goto LABEL_295;
    case 0x1A:
      uint64_t v54 = *((void *)result + 3);
      unint64_t v15 = *((void *)result + 4);
      unsigned int v55 = a2[2];
      if (v55 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v56 = *(void *)a2;
      int v57 = 26;
      goto LABEL_120;
    case 0x1B:
      uint64_t v54 = *((void *)result + 3);
      unint64_t v15 = *((void *)result + 4);
      unsigned int v55 = a2[2];
      if (v55 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v56 = *(void *)a2;
      int v57 = 27;
      goto LABEL_120;
    case 0x1C:
      unint64_t v15 = *((void *)result + 3);
      unsigned int v31 = a2[2];
      if (v31 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v32 = *(void *)a2;
      int v33 = 28;
      goto LABEL_264;
    case 0x1D:
      unint64_t v15 = *((void *)result + 3);
      unsigned int v31 = a2[2];
      if (v31 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v32 = *(void *)a2;
      int v33 = 29;
      goto LABEL_264;
    case 0x1E:
      uint64_t v26 = *((void *)result + 3);
      unsigned int v27 = *((unsigned __int8 *)result + 32);
      unsigned int v28 = a2[2];
      if (v28 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v29 = *(void *)a2;
      int v30 = 30;
LABEL_97:
      *(_DWORD *)(v29 + 4 * v28) = v30;
      unsigned int v115 = a2[3];
      unsigned int v116 = a2[2] + 1;
      a2[2] = v116;
      if (v116 >= v115) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v116) = 0;
      goto LABEL_299;
    case 0x1F:
      int v117 = result[5];
      unsigned int v27 = result[6];
      unsigned int v118 = a2[2];
      if (v118 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v118) = 31;
      unsigned int v119 = a2[3];
      unsigned int v120 = a2[2] + 1;
      a2[2] = v120;
      if (v120 >= v119) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v120) = 0;
      unsigned int v121 = a2[3];
      unsigned int v122 = a2[2] + 1;
      a2[2] = v122;
      if (v122 >= v121) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v122) = v117;
      unsigned int v123 = a2[3];
      unsigned int v124 = a2[2] + 1;
      a2[2] = v124;
      if (v124 >= v123) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v124) = v117 >> 31;
      goto LABEL_317;
    case 0x20:
      unint64_t v15 = *((void *)result + 3);
      unsigned int v31 = a2[2];
      if (v31 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v32 = *(void *)a2;
      int v33 = 32;
      goto LABEL_264;
    case 0x21:
      uint64_t v54 = *((void *)result + 3);
      unint64_t v15 = *((void *)result + 4);
      unsigned int v55 = a2[2];
      if (v55 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v56 = *(void *)a2;
      int v57 = 33;
      goto LABEL_120;
    case 0x22:
      uint64_t v125 = *((void *)result + 3);
      uint64_t v126 = (uint64_t *)*((void *)result + 4);
      uint64_t v127 = *((void *)result + 5);
      return (unsigned int *)sub_1CD074750((uint64_t)a2, 34, v125, v126, v127);
    case 0x23:
      unint64_t v15 = *((void *)result + 3);
      unsigned int v31 = a2[2];
      if (v31 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v32 = *(void *)a2;
      int v33 = 35;
      goto LABEL_264;
    case 0x24:
      uint64_t v3 = (uint64_t *)*((void *)result + 3);
      uint64_t v4 = *((void *)result + 4);
      uint64_t v5 = (uint64_t)a2;
      int v6 = 36;
      goto LABEL_152;
    case 0x25:
      uint64_t v3 = (uint64_t *)*((void *)result + 3);
      uint64_t v4 = *((void *)result + 4);
      uint64_t v5 = (uint64_t)a2;
      int v6 = 37;
      goto LABEL_152;
    case 0x26:
      unint64_t v15 = *((void *)result + 3);
      unsigned int v31 = a2[2];
      if (v31 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v32 = *(void *)a2;
      int v33 = 38;
      goto LABEL_264;
    case 0x27:
      uint64_t v3 = (uint64_t *)*((void *)result + 3);
      uint64_t v4 = *((void *)result + 4);
      uint64_t v5 = (uint64_t)a2;
      int v6 = 39;
      goto LABEL_152;
    case 0x29:
      uint64_t v54 = *((void *)result + 3);
      unint64_t v15 = *((void *)result + 4);
      unsigned int v55 = a2[2];
      if (v55 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v56 = *(void *)a2;
      int v57 = 41;
LABEL_120:
      *(_DWORD *)(v56 + 4 * v55) = v57;
      unsigned int v128 = a2[3];
      unsigned int v129 = a2[2] + 1;
      a2[2] = v129;
      if (v129 >= v128) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v129) = 0;
      goto LABEL_122;
    case 0x2A:
      unint64_t v15 = *((void *)result + 3);
      unsigned int v31 = a2[2];
      if (v31 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v32 = *(void *)a2;
      int v33 = 42;
      goto LABEL_264;
    case 0x2B:
      int v46 = result[5];
      unsigned int v134 = a2[2];
      if (v134 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v135 = *(void *)a2;
      int v136 = 43;
      goto LABEL_132;
    case 0x2C:
      int v46 = result[5];
      unsigned int v134 = a2[2];
      if (v134 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v135 = *(void *)a2;
      int v136 = 44;
LABEL_132:
      *(_DWORD *)(v135 + 4 * v134) = v136;
      goto LABEL_139;
    case 0x2D:
      uint64_t v137 = *((void *)result + 3);
      int v138 = *((unsigned __int8 *)result + 32);
      int v46 = result[9];
      unsigned int v139 = a2[2];
      if (v139 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v139) = 45;
      unsigned int v140 = a2[3];
      unsigned int v141 = a2[2] + 1;
      a2[2] = v141;
      if (v141 >= v140) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v141) = 0;
      unsigned int v142 = a2[3];
      unsigned int v143 = a2[2] + 1;
      a2[2] = v143;
      if (v143 >= v142) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v143) = v137;
      unsigned int v144 = a2[3];
      unsigned int v145 = a2[2] + 1;
      a2[2] = v145;
      if (v145 >= v144) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v145) = HIDWORD(v137);
      unsigned int v146 = a2[3];
      unsigned int v147 = a2[2] + 1;
      a2[2] = v147;
      if (v147 >= v146) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v147) = v138;
LABEL_139:
      unsigned int v148 = a2[3];
      unsigned int v149 = a2[2] + 1;
      a2[2] = v149;
      if (v149 >= v148) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v149) = 0;
LABEL_141:
      unsigned int v150 = a2[3];
      unsigned int v151 = a2[2] + 1;
      a2[2] = v151;
      if (v151 >= v150) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v151) = v46;
      unsigned int v152 = a2[3];
      unsigned int v153 = a2[2] + 1;
      a2[2] = v153;
      if (v153 >= v152) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      int v154 = v46 >> 31;
      goto LABEL_236;
    case 0x2E:
      unint64_t v15 = *((void *)result + 3);
      unsigned int v31 = a2[2];
      if (v31 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v32 = *(void *)a2;
      int v33 = 46;
      goto LABEL_264;
    case 0x2F:
      uint64_t v40 = (unsigned __int8 *)*((void *)result + 3);
      uint64_t v41 = *((void *)result + 4);
      unsigned int v42 = a2[2];
      if (v42 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v43 = *(void *)a2;
      int v44 = 47;
      goto LABEL_287;
    case 0x30:
      uint64_t v155 = (uint64_t *)*((void *)result + 3);
      uint64_t v156 = *((void *)result + 4);
      uint64_t v157 = (uint64_t *)*((void *)result + 5);
      uint64_t v158 = *((void *)result + 6);
      int v159 = (unsigned __int8 *)*((void *)result + 7);
      uint64_t v160 = *((void *)result + 8);
      return sub_1CD074990(a2, v155, v156, v157, v158, v159, v160);
    case 0x31:
      uint64_t v3 = (uint64_t *)*((void *)result + 3);
      uint64_t v4 = *((void *)result + 4);
      uint64_t v5 = (uint64_t)a2;
      int v6 = 49;
LABEL_152:
      return (unsigned int *)sub_1CD074590(v5, v6, v3, v4);
    case 0x32:
      uint64_t v161 = *((void *)result + 3);
      unint64_t v162 = (unsigned __int8 *)*((void *)result + 4);
      uint64_t v163 = *((void *)result + 5);
      uint64_t v164 = *((void *)result + 6);
      int v165 = *(unsigned __int16 *)((char *)result + 17) << 26 >> 26;
      BOOL v166 = a2;
      int v167 = 50;
      goto LABEL_174;
    case 0x33:
      uint64_t v169 = *((void *)result + 3);
      uint64_t v168 = *((void *)result + 4);
      int v170 = *(unsigned __int16 *)((char *)result + 17);
      unsigned int v171 = a2[2];
      if (v171 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v171) = 51;
      unsigned int v172 = a2[3];
      unsigned int v173 = a2[2] + 1;
      a2[2] = v173;
      if (v173 >= v172) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v173) = 0;
      goto LABEL_167;
    case 0x34:
      uint64_t v175 = *((void *)result + 3);
      uint64_t v174 = (unsigned __int8 *)*((void *)result + 4);
      uint64_t v176 = *((void *)result + 5);
      int v170 = *(unsigned __int16 *)((char *)result + 17);
      unsigned int v177 = a2[2];
      if (v177 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v177) = 52;
      unsigned int v178 = a2[3];
      unsigned int v179 = a2[2] + 1;
      a2[2] = v179;
      if (v179 >= v178) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v179) = 0;
      goto LABEL_229;
    case 0x35:
      uint64_t v180 = *((void *)result + 3);
      uint64_t v169 = *((void *)result + 4);
      uint64_t v168 = *((void *)result + 5);
      int v170 = *(unsigned __int16 *)((char *)result + 17);
      unsigned int v181 = a2[2];
      if (v181 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v181) = 53;
      unsigned int v182 = a2[3];
      unsigned int v183 = a2[2] + 1;
      a2[2] = v183;
      if (v183 >= v182) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v183) = 0;
      unsigned int v184 = a2[3];
      unsigned int v185 = a2[2] + 1;
      a2[2] = v185;
      if (v185 >= v184) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v185) = v180;
      unsigned int v186 = a2[3];
      unsigned int v187 = a2[2] + 1;
      a2[2] = v187;
      if (v187 >= v186) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v187) = HIDWORD(v180);
LABEL_167:
      unsigned int v188 = a2[3];
      unsigned int v189 = a2[2] + 1;
      a2[2] = v189;
      if (v189 >= v188) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v189) = v169;
      unsigned int v190 = a2[3];
      unsigned int v191 = a2[2] + 1;
      a2[2] = v191;
      if (v191 >= v190) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v191) = HIDWORD(v169);
      unsigned int v192 = a2[3];
      unsigned int v193 = a2[2] + 1;
      a2[2] = v193;
      if (v193 >= v192) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v193) = v168;
      unsigned int v194 = a2[3];
      unsigned int v195 = a2[2] + 1;
      a2[2] = v195;
      if (v195 >= v194) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v195) = HIDWORD(v168);
      unsigned int v196 = a2[3];
      unsigned int v197 = a2[2] + 1;
      a2[2] = v197;
      if (v197 >= v196) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v197) = v170 << 26 >> 26;
      goto LABEL_233;
    case 0x36:
      uint64_t v161 = *((void *)result + 3);
      unint64_t v162 = (unsigned __int8 *)*((void *)result + 4);
      uint64_t v163 = *((void *)result + 5);
      uint64_t v164 = *((void *)result + 6);
      int v165 = *(unsigned __int16 *)((char *)result + 17) << 26 >> 26;
      BOOL v166 = a2;
      int v167 = 54;
LABEL_174:
      return sub_1CD074CA4(v166, v167, v161, v162, v163, v164, v165);
    case 0x37:
      uint64_t v199 = *((void *)result + 3);
      uint64_t v198 = *((void *)result + 4);
      uint64_t v200 = (unsigned __int8 *)*((void *)result + 5);
      uint64_t v201 = *((void *)result + 6);
      unsigned int v202 = (uint64_t *)*((void *)result + 7);
      uint64_t v203 = *((void *)result + 8);
      int v204 = *((unsigned __int8 *)result + 72);
      unsigned int v205 = a2[2];
      if (v205 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v205) = 55;
      unsigned int v206 = a2[3];
      unsigned int v207 = a2[2] + 1;
      a2[2] = v207;
      if (v207 >= v206) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v207) = 0;
      unsigned int v208 = a2[3];
      unsigned int v209 = a2[2] + 1;
      a2[2] = v209;
      if (v209 >= v208) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v209) = v199;
      unsigned int v210 = a2[3];
      unsigned int v211 = a2[2] + 1;
      a2[2] = v211;
      if (v211 >= v210) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v211) = HIDWORD(v199);
      unsigned int v212 = a2[3];
      unsigned int v213 = a2[2] + 1;
      a2[2] = v213;
      if (v213 >= v212) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v213) = v198;
      unsigned int v214 = a2[3];
      unsigned int v215 = a2[2] + 1;
      a2[2] = v215;
      if (v215 >= v214) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v215) = HIDWORD(v198);
      ++a2[2];
      uint64_t result = llvm::FoldingSetNodeID::AddString(a2, v200, (int)v201 - (int)v200);
      unsigned int v216 = a2[2];
      if (v216 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v216) = v203;
      unsigned int v217 = a2[3];
      unsigned int v218 = a2[2] + 1;
      a2[2] = v218;
      if (v218 >= v217) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v218) = HIDWORD(v203);
      unsigned int v219 = a2[2] + 1;
      a2[2] = v219;
      if (v203)
      {
        uint64_t v220 = 8 * v203;
        do
        {
          uint64_t v221 = *v202;
          if (v219 >= a2[3]) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(_DWORD *)(*(void *)a2 + 4 * v219) = v221;
          unsigned int v222 = a2[3];
          unsigned int v223 = a2[2] + 1;
          a2[2] = v223;
          if (v223 >= v222) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(_DWORD *)(*(void *)a2 + 4 * v223) = HIDWORD(v221);
          unsigned int v219 = a2[2] + 1;
          a2[2] = v219;
          ++v202;
          v220 -= 8;
        }
        while (v220);
      }
      if (v219 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v219) = v204;
      goto LABEL_319;
    case 0x38:
      uint64_t v225 = (unsigned __int8 *)*((void *)result + 3);
      uint64_t v224 = *((void *)result + 4);
      uint64_t v226 = *((void *)result + 5);
      int v227 = *(unsigned __int16 *)((char *)result + 17);
      unsigned int v228 = a2[2];
      if (v228 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v228) = 56;
      unsigned int v229 = a2[3];
      unsigned int v230 = a2[2] + 1;
      a2[2] = v230;
      if (v230 >= v229) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v230) = 0;
      ++a2[2];
      uint64_t result = llvm::FoldingSetNodeID::AddString(a2, v225, (int)v224 - (int)v225);
      unsigned int v231 = a2[2];
      if (v231 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v231) = v226;
      unsigned int v232 = a2[3];
      unsigned int v233 = a2[2] + 1;
      a2[2] = v233;
      if (v233 >= v232) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v233) = HIDWORD(v226);
      unsigned int v234 = a2[3];
      unsigned int v235 = a2[2] + 1;
      a2[2] = v235;
      if (v235 >= v234) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v235) = v227 << 26 >> 26;
      goto LABEL_207;
    case 0x39:
      uint64_t v237 = (unsigned __int8 *)*((void *)result + 3);
      uint64_t v236 = *((void *)result + 4);
      uint64_t v239 = *((void *)result + 5);
      uint64_t v238 = *((void *)result + 6);
      int v227 = *(unsigned __int16 *)((char *)result + 17);
      unsigned int v240 = a2[2];
      if (v240 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v240) = 57;
      unsigned int v241 = a2[3];
      unsigned int v242 = a2[2] + 1;
      a2[2] = v242;
      if (v242 >= v241) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v242) = 0;
      ++a2[2];
      uint64_t result = llvm::FoldingSetNodeID::AddString(a2, v237, (int)v236 - (int)v237);
      unsigned int v243 = a2[2];
      if (v243 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v243) = v239;
      unsigned int v244 = a2[3];
      unsigned int v245 = a2[2] + 1;
      a2[2] = v245;
      if (v245 >= v244) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v245) = HIDWORD(v239);
      unsigned int v246 = a2[3];
      unsigned int v247 = a2[2] + 1;
      a2[2] = v247;
      if (v247 >= v246) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v247) = v238;
      unsigned int v248 = a2[3];
      unsigned int v249 = a2[2] + 1;
      a2[2] = v249;
      if (v249 >= v248) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v249) = HIDWORD(v238);
      unsigned int v250 = a2[3];
      unsigned int v251 = a2[2] + 1;
      a2[2] = v251;
      if (v251 >= v250) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v251) = v227 << 26 >> 26;
LABEL_207:
      __int16 v252 = (_WORD)v227 << 10;
      goto LABEL_234;
    case 0x3A:
      unint64_t v15 = *((void *)result + 3);
      unsigned int v31 = a2[2];
      if (v31 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v32 = *(void *)a2;
      int v33 = 58;
      goto LABEL_264;
    case 0x3B:
      uint64_t v253 = *((void *)result + 3);
      BOOL v254 = (uint64_t *)*((void *)result + 4);
      uint64_t v255 = *((void *)result + 5);
      int v256 = *(unsigned __int16 *)((char *)result + 17) << 26 >> 26;
      uint64_t v257 = (uint64_t)a2;
      int v258 = 59;
      goto LABEL_221;
    case 0x3C:
      return (unsigned int *)sub_1CD0751A0((uint64_t)a2, *((uint64_t **)result + 3), *((void *)result + 4), *((void *)result + 5), *((uint64_t **)result + 6), *((void *)result + 7), *((unsigned __int8 *)result + 64), *((unsigned __int8 *)result + 65), *(unsigned __int16 *)((char *)result + 17) << 26 >> 26);
    case 0x3D:
      uint64_t v259 = *((void *)result + 3);
      int v260 = *((unsigned __int8 *)result + 32);
      int v261 = *((unsigned __int8 *)result + 33);
      int v262 = *(unsigned __int16 *)((char *)result + 17) << 26 >> 26;
      return (unsigned int *)sub_1CD075670((uint64_t)a2, v259, v260, v261, v262);
    case 0x3E:
      v263 = (unsigned __int8 *)*((void *)result + 3);
      uint64_t v264 = *((void *)result + 4);
      uint64_t v265 = *((void *)result + 5);
      int v266 = *(unsigned __int16 *)((char *)result + 17) << 26 >> 26;
      return sub_1CD0758F0(a2, 62, v263, v264, v265, v266);
    case 0x3F:
      uint64_t v40 = (unsigned __int8 *)*((void *)result + 3);
      uint64_t v41 = *((void *)result + 4);
      unsigned int v42 = a2[2];
      if (v42 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v43 = *(void *)a2;
      int v44 = 63;
      goto LABEL_287;
    case 0x40:
      uint64_t v253 = *((void *)result + 3);
      BOOL v254 = (uint64_t *)*((void *)result + 4);
      uint64_t v255 = *((void *)result + 5);
      int v256 = *(unsigned __int16 *)((char *)result + 17) << 26 >> 26;
      uint64_t v257 = (uint64_t)a2;
      int v258 = 64;
LABEL_221:
      return (unsigned int *)sub_1CD074EE0(v257, v258, v253, v254, v255, v256);
    case 0x41:
      uint64_t v267 = *((void *)result + 3);
      uint64_t v175 = *((void *)result + 4);
      uint64_t v174 = (unsigned __int8 *)*((void *)result + 5);
      uint64_t v176 = *((void *)result + 6);
      int v170 = *(unsigned __int16 *)((char *)result + 17);
      unsigned int v268 = a2[2];
      if (v268 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v268) = 65;
      unsigned int v269 = a2[3];
      unsigned int v270 = a2[2] + 1;
      a2[2] = v270;
      if (v270 >= v269) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v270) = 0;
      unsigned int v271 = a2[3];
      unsigned int v272 = a2[2] + 1;
      a2[2] = v272;
      if (v272 >= v271) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v272) = v267;
      unsigned int v273 = a2[3];
      unsigned int v274 = a2[2] + 1;
      a2[2] = v274;
      if (v274 >= v273) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v274) = HIDWORD(v267);
LABEL_229:
      unsigned int v275 = a2[3];
      unsigned int v276 = a2[2] + 1;
      a2[2] = v276;
      if (v276 >= v275) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v276) = v175;
      unsigned int v277 = a2[3];
      unsigned int v278 = a2[2] + 1;
      a2[2] = v278;
      if (v278 >= v277) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v278) = HIDWORD(v175);
      ++a2[2];
      uint64_t result = llvm::FoldingSetNodeID::AddString(a2, v174, (int)v176 - (int)v174);
      unsigned int v279 = a2[2];
      if (v279 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v279) = v170 << 26 >> 26;
LABEL_233:
      __int16 v252 = (_WORD)v170 << 10;
LABEL_234:
      unsigned int v280 = a2[3];
      unsigned int v153 = a2[2] + 1;
      a2[2] = v153;
      if (v153 >= v280) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      int v154 = v252 >> 15;
LABEL_236:
      *(_DWORD *)(*(void *)a2 + 4 * v153) = v154;
      goto LABEL_321;
    case 0x42:
      uint64_t v281 = *((void *)result + 3);
      long long v282 = (uint64_t *)*((void *)result + 4);
      uint64_t v283 = *((void *)result + 5);
      unsigned int v284 = a2[2];
      if (v284 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v284) = 66;
      unsigned int v285 = a2[3];
      unsigned int v286 = a2[2] + 1;
      a2[2] = v286;
      if (v286 >= v285) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v286) = 0;
      unsigned int v287 = a2[3];
      unsigned int v288 = a2[2] + 1;
      a2[2] = v288;
      if (v288 >= v287) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v288) = v281;
      unsigned int v289 = a2[3];
      unsigned int v290 = a2[2] + 1;
      a2[2] = v290;
      if (v290 >= v289) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v290) = HIDWORD(v281);
      unsigned int v291 = a2[3];
      unsigned int v292 = a2[2] + 1;
      a2[2] = v292;
      if (v292 >= v291) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v292) = v283;
      unsigned int v293 = a2[3];
      unsigned int v294 = a2[2] + 1;
      a2[2] = v294;
      if (v294 >= v293) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v294) = HIDWORD(v283);
      unsigned int v295 = a2[2] + 1;
      a2[2] = v295;
      if (v283)
      {
        uint64_t v296 = 8 * v283;
        do
        {
          uint64_t v297 = *v282;
          if (v295 >= a2[3]) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(_DWORD *)(*(void *)a2 + 4 * v295) = v297;
          unsigned int v298 = a2[3];
          unsigned int v299 = a2[2] + 1;
          a2[2] = v299;
          if (v299 >= v298) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(_DWORD *)(*(void *)a2 + 4 * v299) = HIDWORD(v297);
          unsigned int v295 = a2[2] + 1;
          a2[2] = v295;
          ++v282;
          v296 -= 8;
        }
        while (v296);
      }
      return result;
    case 0x43:
      int v300 = *((unsigned __int8 *)result + 56);
      v301 = (unsigned __int8 *)*((void *)result + 5);
      uint64_t v302 = *((void *)result + 6);
      uint64_t v54 = *((void *)result + 3);
      unint64_t v15 = *((void *)result + 4);
      unsigned int v303 = a2[2];
      if (v303 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v303) = 67;
      unsigned int v304 = a2[3];
      unsigned int v305 = a2[2] + 1;
      a2[2] = v305;
      if (v305 >= v304) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v305) = 0;
      unsigned int v306 = a2[3];
      unsigned int v307 = a2[2] + 1;
      a2[2] = v307;
      if (v307 >= v306) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v307) = v300;
      unsigned int v308 = a2[3];
      unsigned int v309 = a2[2] + 1;
      a2[2] = v309;
      if (v309 >= v308) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v309) = 0;
      ++a2[2];
      uint64_t result = llvm::FoldingSetNodeID::AddString(a2, v301, (int)v302 - (int)v301);
      unsigned int v131 = a2[2];
      unsigned int v130 = a2[3];
      goto LABEL_123;
    case 0x44:
      unint64_t v15 = *((void *)result + 3);
      unsigned int v31 = a2[2];
      if (v31 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v32 = *(void *)a2;
      int v33 = 68;
      goto LABEL_264;
    case 0x45:
      unsigned int v27 = *((unsigned __int8 *)result + 19);
      unsigned int v310 = a2[2];
      if (v310 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v310) = 69;
LABEL_315:
      unsigned int v355 = a2[3];
      unsigned int v356 = a2[2] + 1;
      a2[2] = v356;
      if (v356 >= v355) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v356) = 0;
      goto LABEL_317;
    case 0x46:
      unint64_t v15 = *((void *)result + 3);
      unsigned int v31 = a2[2];
      if (v31 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v32 = *(void *)a2;
      int v33 = 70;
      goto LABEL_264;
    case 0x47:
      unint64_t v15 = *((void *)result + 3);
      unsigned int v31 = a2[2];
      if (v31 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v32 = *(void *)a2;
      int v33 = 71;
LABEL_264:
      *(_DWORD *)(v32 + 4 * v31) = v33;
LABEL_265:
      unsigned int v311 = a2[3];
      unsigned int v312 = a2[2] + 1;
      a2[2] = v312;
      if (v312 >= v311) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v312) = 0;
      goto LABEL_267;
    case 0x48:
      uint64_t v8 = *((void *)result + 3);
      uint64_t v7 = (unsigned __int8 *)*((void *)result + 4);
      uint64_t v9 = *((void *)result + 5);
      unsigned int v10 = a2[2];
      if (v10 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v11 = *(void *)a2;
      int v12 = 72;
LABEL_274:
      *(_DWORD *)(v11 + 4 * v10) = v12;
      unsigned int v314 = a2[3];
      unsigned int v315 = a2[2] + 1;
      a2[2] = v315;
      if (v315 >= v314) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v315) = 0;
      unsigned int v316 = a2[3];
      unsigned int v317 = a2[2] + 1;
      a2[2] = v317;
      if (v317 >= v316) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v317) = v8;
      unsigned int v318 = a2[3];
      unsigned int v319 = a2[2] + 1;
      a2[2] = v319;
      if (v319 >= v318) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v319) = HIDWORD(v8);
      ++a2[2];
      unsigned int v320 = v9 - v7;
      int v321 = a2;
      goto LABEL_290;
    case 0x49:
      uint64_t v322 = (unsigned __int8 *)*((void *)result + 3);
      uint64_t v323 = *((void *)result + 4);
      uint64_t v40 = (unsigned __int8 *)*((void *)result + 5);
      uint64_t v41 = *((void *)result + 6);
      unsigned int v324 = a2[2];
      if (v324 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v324) = 73;
      unsigned int v325 = a2[3];
      unsigned int v326 = a2[2] + 1;
      a2[2] = v326;
      if (v326 >= v325) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v326) = 0;
      ++a2[2];
      llvm::FoldingSetNodeID::AddString(a2, v322, v323 - v322);
      goto LABEL_289;
    case 0x4A:
      uint64_t v40 = (unsigned __int8 *)*((void *)result + 3);
      uint64_t v41 = *((void *)result + 4);
      unsigned int v42 = a2[2];
      if (v42 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v43 = *(void *)a2;
      int v44 = 74;
      goto LABEL_287;
    case 0x4B:
      uint64_t v40 = (unsigned __int8 *)*((void *)result + 3);
      uint64_t v41 = *((void *)result + 4);
      unsigned int v42 = a2[2];
      if (v42 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v43 = *(void *)a2;
      int v44 = 75;
      goto LABEL_287;
    case 0x4C:
      uint64_t v40 = (unsigned __int8 *)*((void *)result + 3);
      uint64_t v41 = *((void *)result + 4);
      unsigned int v42 = a2[2];
      if (v42 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v43 = *(void *)a2;
      int v44 = 76;
LABEL_287:
      *(_DWORD *)(v43 + 4 * v42) = v44;
      unsigned int v327 = a2[3];
      unsigned int v328 = a2[2] + 1;
      a2[2] = v328;
      if (v328 >= v327) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v328) = 0;
      ++a2[2];
LABEL_289:
      unsigned int v320 = v41 - v40;
      int v321 = a2;
      uint64_t v7 = v40;
LABEL_290:
      return llvm::FoldingSetNodeID::AddString(v321, v7, v320);
    case 0x4D:
      uint64_t v111 = *((void *)result + 3);
      uint64_t v26 = *((void *)result + 4);
      unsigned int v27 = *((unsigned __int8 *)result + 40);
      unsigned int v112 = a2[2];
      if (v112 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v113 = *(void *)a2;
      int v114 = 77;
LABEL_295:
      *(_DWORD *)(v113 + 4 * v112) = v114;
      unsigned int v329 = a2[3];
      unsigned int v330 = a2[2] + 1;
      a2[2] = v330;
      if (v330 >= v329) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v330) = 0;
      unsigned int v331 = a2[3];
      unsigned int v332 = a2[2] + 1;
      a2[2] = v332;
      if (v332 >= v331) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v332) = v111;
      unsigned int v333 = a2[3];
      unsigned int v334 = a2[2] + 1;
      a2[2] = v334;
      if (v334 >= v333) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v334) = HIDWORD(v111);
LABEL_299:
      unsigned int v335 = a2[3];
      unsigned int v336 = a2[2] + 1;
      a2[2] = v336;
      if (v336 >= v335) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v336) = v26;
      unsigned int v337 = a2[3];
      unsigned int v338 = a2[2] + 1;
      a2[2] = v338;
      if (v338 >= v337) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v338) = HIDWORD(v26);
LABEL_317:
      unsigned int v357 = a2[3];
      unsigned int v358 = a2[2] + 1;
      a2[2] = v358;
      if (v358 >= v357) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v358) = v27;
LABEL_319:
      unsigned int v359 = a2[3];
      unsigned int v360 = a2[2] + 1;
      a2[2] = v360;
      if (v360 >= v359) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v360) = 0;
      goto LABEL_321;
    case 0x4E:
      uint64_t v339 = *((void *)result + 3);
      uint64_t v54 = *((void *)result + 4);
      unint64_t v15 = *((void *)result + 5);
      unsigned int v340 = a2[2];
      if (v340 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v340) = 78;
      unsigned int v341 = a2[3];
      unsigned int v342 = a2[2] + 1;
      a2[2] = v342;
      if (v342 >= v341) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v342) = 0;
      unsigned int v343 = a2[3];
      unsigned int v344 = a2[2] + 1;
      a2[2] = v344;
      if (v344 >= v343) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v344) = v339;
      unsigned int v345 = a2[3];
      unsigned int v346 = a2[2] + 1;
      a2[2] = v346;
      if (v346 >= v345) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v346) = HIDWORD(v339);
LABEL_122:
      unsigned int v130 = a2[3];
      unsigned int v131 = a2[2] + 1;
      a2[2] = v131;
LABEL_123:
      if (v131 >= v130) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v131) = v54;
      unsigned int v132 = a2[3];
      unsigned int v133 = a2[2] + 1;
      a2[2] = v133;
      if (v133 >= v132) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v133) = HIDWORD(v54);
LABEL_267:
      unsigned int v25 = a2[3];
      unsigned int v24 = a2[2] + 1;
      a2[2] = v24;
LABEL_268:
      if (v24 >= v25) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v24) = v15;
      unsigned int v313 = a2[3];
      unsigned int v109 = a2[2] + 1;
      a2[2] = v109;
      if (v109 >= v313) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      unint64_t v110 = HIDWORD(v15);
LABEL_271:
      *(_DWORD *)(*(void *)a2 + 4 * v109) = v110;
LABEL_321:
      ++a2[2];
      break;
    default:
      return result;
  }
  return result;
}

uint64_t sub_1CD074590(uint64_t result, int a2, uint64_t *a3, uint64_t a4)
{
  unsigned int v5 = *(_DWORD *)(result + 8);
  if (v5 >= *(_DWORD *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v5) = a2;
  unsigned int v6 = *(_DWORD *)(result + 12);
  unsigned int v7 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v7;
  if (v7 >= v6) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v7) = 0;
  unsigned int v8 = *(_DWORD *)(result + 12);
  unsigned int v9 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v9;
  if (v9 >= v8) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v9) = a4;
  unsigned int v10 = *(_DWORD *)(result + 12);
  unsigned int v11 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v11;
  if (v11 >= v10) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v11) = HIDWORD(a4);
  unsigned int v12 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v12;
  if (a4)
  {
    uint64_t v13 = 8 * a4;
    do
    {
      uint64_t v14 = *a3;
      if (v12 >= *(_DWORD *)(result + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)result + 4 * v12) = v14;
      unsigned int v15 = *(_DWORD *)(result + 12);
      unsigned int v16 = *(_DWORD *)(result + 8) + 1;
      *(_DWORD *)(result + 8) = v16;
      if (v16 >= v15) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)result + 4 * v16) = HIDWORD(v14);
      unsigned int v12 = *(_DWORD *)(result + 8) + 1;
      *(_DWORD *)(result + 8) = v12;
      ++a3;
      v13 -= 8;
    }
    while (v13);
  }
  return result;
}

uint64_t sub_1CD074750(uint64_t result, int a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  unsigned int v6 = *(_DWORD *)(result + 8);
  if (v6 >= *(_DWORD *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v6) = a2;
  unsigned int v7 = *(_DWORD *)(result + 12);
  unsigned int v8 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v8;
  if (v8 >= v7) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v8) = 0;
  unsigned int v9 = *(_DWORD *)(result + 12);
  unsigned int v10 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v10;
  if (v10 >= v9) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v10) = a3;
  unsigned int v11 = *(_DWORD *)(result + 12);
  unsigned int v12 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v12;
  if (v12 >= v11) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v12) = HIDWORD(a3);
  unsigned int v13 = *(_DWORD *)(result + 12);
  unsigned int v14 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v14;
  if (v14 >= v13) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v14) = a5;
  unsigned int v15 = *(_DWORD *)(result + 12);
  unsigned int v16 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v16;
  if (v16 >= v15) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v16) = HIDWORD(a5);
  unsigned int v17 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v17;
  if (a5)
  {
    uint64_t v18 = 8 * a5;
    do
    {
      uint64_t v19 = *a4;
      if (v17 >= *(_DWORD *)(result + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)result + 4 * v17) = v19;
      unsigned int v20 = *(_DWORD *)(result + 12);
      unsigned int v21 = *(_DWORD *)(result + 8) + 1;
      *(_DWORD *)(result + 8) = v21;
      if (v21 >= v20) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)result + 4 * v21) = HIDWORD(v19);
      unsigned int v17 = *(_DWORD *)(result + 8) + 1;
      *(_DWORD *)(result + 8) = v17;
      ++a4;
      v18 -= 8;
    }
    while (v18);
  }
  return result;
}

unsigned int *sub_1CD074990(unsigned int *a1, uint64_t *a2, uint64_t a3, uint64_t *a4, uint64_t a5, unsigned __int8 *a6, int a7)
{
  unsigned int v9 = a1[2];
  if (v9 >= a1[3]) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)a1 + 4 * v9) = 48;
  unsigned int v10 = a1[3];
  unsigned int v11 = a1[2] + 1;
  a1[2] = v11;
  if (v11 >= v10) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)a1 + 4 * v11) = 0;
  unsigned int v12 = a1[3];
  unsigned int v13 = a1[2] + 1;
  a1[2] = v13;
  if (v13 >= v12) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)a1 + 4 * v13) = a3;
  unsigned int v14 = a1[3];
  unsigned int v15 = a1[2] + 1;
  a1[2] = v15;
  if (v15 >= v14) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)a1 + 4 * v15) = HIDWORD(a3);
  unsigned int v16 = a1[2] + 1;
  a1[2] = v16;
  if (a3)
  {
    uint64_t v17 = 8 * a3;
    do
    {
      uint64_t v18 = *a2;
      if (v16 >= a1[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a1 + 4 * v16) = v18;
      unsigned int v19 = a1[3];
      unsigned int v20 = a1[2] + 1;
      a1[2] = v20;
      if (v20 >= v19) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a1 + 4 * v20) = HIDWORD(v18);
      unsigned int v16 = a1[2] + 1;
      a1[2] = v16;
      ++a2;
      v17 -= 8;
    }
    while (v17);
  }
  if (v16 >= a1[3]) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)a1 + 4 * v16) = a5;
  unsigned int v21 = a1[3];
  unsigned int v22 = a1[2] + 1;
  a1[2] = v22;
  if (v22 >= v21) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)a1 + 4 * v22) = HIDWORD(a5);
  unsigned int v23 = a1[2] + 1;
  a1[2] = v23;
  if (a5)
  {
    uint64_t v24 = 8 * a5;
    do
    {
      uint64_t v25 = *a4;
      if (v23 >= a1[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a1 + 4 * v23) = v25;
      unsigned int v26 = a1[3];
      unsigned int v27 = a1[2] + 1;
      a1[2] = v27;
      if (v27 >= v26) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a1 + 4 * v27) = HIDWORD(v25);
      unsigned int v23 = a1[2] + 1;
      a1[2] = v23;
      ++a4;
      v24 -= 8;
    }
    while (v24);
  }

  return llvm::FoldingSetNodeID::AddString(a1, a6, a7 - (int)a6);
}

unsigned int *sub_1CD074CA4(unsigned int *a1, int a2, uint64_t a3, unsigned __int8 *a4, int a5, uint64_t a6, int a7)
{
  unsigned int v10 = a1[2];
  if (v10 >= a1[3]) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)a1 + 4 * v10) = a2;
  unsigned int v11 = a1[3];
  unsigned int v12 = a1[2] + 1;
  a1[2] = v12;
  if (v12 >= v11) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)a1 + 4 * v12) = 0;
  unsigned int v13 = a1[3];
  unsigned int v14 = a1[2] + 1;
  a1[2] = v14;
  if (v14 >= v13) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)a1 + 4 * v14) = a3;
  unsigned int v15 = a1[3];
  unsigned int v16 = a1[2] + 1;
  a1[2] = v16;
  if (v16 >= v15) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)a1 + 4 * v16) = HIDWORD(a3);
  ++a1[2];
  uint64_t result = llvm::FoldingSetNodeID::AddString(a1, a4, a5 - (int)a4);
  unsigned int v18 = a1[2];
  if (v18 >= a1[3]) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)a1 + 4 * v18) = a6;
  unsigned int v19 = a1[3];
  unsigned int v20 = a1[2] + 1;
  a1[2] = v20;
  if (v20 >= v19) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)a1 + 4 * v20) = HIDWORD(a6);
  unsigned int v21 = a1[3];
  unsigned int v22 = a1[2] + 1;
  a1[2] = v22;
  if (v22 >= v21) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)a1 + 4 * v22) = a7;
  unsigned int v23 = a1[3];
  unsigned int v24 = a1[2] + 1;
  a1[2] = v24;
  if (v24 >= v23) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)a1 + 4 * v24) = a7 >> 31;
  ++a1[2];
  return result;
}

uint64_t sub_1CD074EE0(uint64_t result, int a2, uint64_t a3, uint64_t *a4, uint64_t a5, int a6)
{
  unsigned int v7 = *(_DWORD *)(result + 8);
  if (v7 >= *(_DWORD *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v7) = a2;
  unsigned int v8 = *(_DWORD *)(result + 12);
  unsigned int v9 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v9;
  if (v9 >= v8) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v9) = 0;
  unsigned int v10 = *(_DWORD *)(result + 12);
  unsigned int v11 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v11;
  if (v11 >= v10) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v11) = a3;
  unsigned int v12 = *(_DWORD *)(result + 12);
  unsigned int v13 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v13;
  if (v13 >= v12) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v13) = HIDWORD(a3);
  unsigned int v14 = *(_DWORD *)(result + 12);
  unsigned int v15 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v15;
  if (v15 >= v14) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v15) = a5;
  unsigned int v16 = *(_DWORD *)(result + 12);
  unsigned int v17 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v17;
  if (v17 >= v16) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v17) = HIDWORD(a5);
  unsigned int v18 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v18;
  if (a5)
  {
    uint64_t v19 = 8 * a5;
    do
    {
      uint64_t v20 = *a4;
      if (v18 >= *(_DWORD *)(result + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)result + 4 * v18) = v20;
      unsigned int v21 = *(_DWORD *)(result + 12);
      unsigned int v22 = *(_DWORD *)(result + 8) + 1;
      *(_DWORD *)(result + 8) = v22;
      if (v22 >= v21) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)result + 4 * v22) = HIDWORD(v20);
      unsigned int v18 = *(_DWORD *)(result + 8) + 1;
      *(_DWORD *)(result + 8) = v18;
      ++a4;
      v19 -= 8;
    }
    while (v19);
  }
  if (v18 >= *(_DWORD *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v18) = a6;
  unsigned int v23 = *(_DWORD *)(result + 12);
  unsigned int v24 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v24;
  if (v24 >= v23) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v24) = a6 >> 31;
  ++*(_DWORD *)(result + 8);
  return result;
}

uint64_t sub_1CD0751A0(uint64_t result, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, int a7, int a8, int a9)
{
  unsigned int v11 = *(_DWORD *)(result + 8);
  if (v11 >= *(_DWORD *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v11) = 60;
  unsigned int v12 = *(_DWORD *)(result + 12);
  unsigned int v13 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v13;
  if (v13 >= v12) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v13) = 0;
  unsigned int v14 = *(_DWORD *)(result + 12);
  unsigned int v15 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v15;
  if (v15 >= v14) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v15) = a3;
  unsigned int v16 = *(_DWORD *)(result + 12);
  unsigned int v17 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v17;
  if (v17 >= v16) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v17) = HIDWORD(a3);
  unsigned int v18 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v18;
  if (a3)
  {
    uint64_t v19 = 8 * a3;
    do
    {
      uint64_t v20 = *a2;
      if (v18 >= *(_DWORD *)(result + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)result + 4 * v18) = v20;
      unsigned int v21 = *(_DWORD *)(result + 12);
      unsigned int v22 = *(_DWORD *)(result + 8) + 1;
      *(_DWORD *)(result + 8) = v22;
      if (v22 >= v21) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)result + 4 * v22) = HIDWORD(v20);
      unsigned int v18 = *(_DWORD *)(result + 8) + 1;
      *(_DWORD *)(result + 8) = v18;
      ++a2;
      v19 -= 8;
    }
    while (v19);
  }
  if (v18 >= *(_DWORD *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v18) = a4;
  unsigned int v23 = *(_DWORD *)(result + 12);
  unsigned int v24 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v24;
  if (v24 >= v23) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v24) = HIDWORD(a4);
  unsigned int v25 = *(_DWORD *)(result + 12);
  unsigned int v26 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v26;
  if (v26 >= v25) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v26) = a6;
  unsigned int v27 = *(_DWORD *)(result + 12);
  unsigned int v28 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v28;
  if (v28 >= v27) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v28) = HIDWORD(a6);
  unsigned int v29 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v29;
  if (a6)
  {
    uint64_t v30 = 8 * a6;
    do
    {
      uint64_t v31 = *a5;
      if (v29 >= *(_DWORD *)(result + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)result + 4 * v29) = v31;
      unsigned int v32 = *(_DWORD *)(result + 12);
      unsigned int v33 = *(_DWORD *)(result + 8) + 1;
      *(_DWORD *)(result + 8) = v33;
      if (v33 >= v32) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)result + 4 * v33) = HIDWORD(v31);
      unsigned int v29 = *(_DWORD *)(result + 8) + 1;
      *(_DWORD *)(result + 8) = v29;
      ++a5;
      v30 -= 8;
    }
    while (v30);
  }
  if (v29 >= *(_DWORD *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v29) = a7;
  unsigned int v34 = *(_DWORD *)(result + 12);
  unsigned int v35 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v35;
  if (v35 >= v34) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v35) = 0;
  unsigned int v36 = *(_DWORD *)(result + 12);
  unsigned int v37 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v37;
  if (v37 >= v36) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v37) = a8;
  unsigned int v38 = *(_DWORD *)(result + 12);
  unsigned int v39 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v39;
  if (v39 >= v38) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v39) = 0;
  unsigned int v40 = *(_DWORD *)(result + 12);
  unsigned int v41 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v41;
  if (v41 >= v40) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v41) = a9;
  unsigned int v42 = *(_DWORD *)(result + 12);
  unsigned int v43 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v43;
  if (v43 >= v42) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v43) = a9 >> 31;
  ++*(_DWORD *)(result + 8);
  return result;
}

uint64_t sub_1CD075670(uint64_t result, uint64_t a2, int a3, int a4, int a5)
{
  unsigned int v5 = *(_DWORD *)(result + 8);
  if (v5 >= *(_DWORD *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v5) = 61;
  unsigned int v6 = *(_DWORD *)(result + 12);
  unsigned int v7 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v7;
  if (v7 >= v6) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v7) = 0;
  unsigned int v8 = *(_DWORD *)(result + 12);
  unsigned int v9 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v9;
  if (v9 >= v8) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v9) = a2;
  unsigned int v10 = *(_DWORD *)(result + 12);
  unsigned int v11 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v11;
  if (v11 >= v10) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v11) = HIDWORD(a2);
  unsigned int v12 = *(_DWORD *)(result + 12);
  unsigned int v13 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v13;
  if (v13 >= v12) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v13) = a3;
  unsigned int v14 = *(_DWORD *)(result + 12);
  unsigned int v15 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v15;
  if (v15 >= v14) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v15) = 0;
  unsigned int v16 = *(_DWORD *)(result + 12);
  unsigned int v17 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v17;
  if (v17 >= v16) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v17) = a4;
  unsigned int v18 = *(_DWORD *)(result + 12);
  unsigned int v19 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v19;
  if (v19 >= v18) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v19) = 0;
  unsigned int v20 = *(_DWORD *)(result + 12);
  unsigned int v21 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v21;
  if (v21 >= v20) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v21) = a5;
  unsigned int v22 = *(_DWORD *)(result + 12);
  unsigned int v23 = *(_DWORD *)(result + 8) + 1;
  *(_DWORD *)(result + 8) = v23;
  if (v23 >= v22) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)result + 4 * v23) = a5 >> 31;
  ++*(_DWORD *)(result + 8);
  return result;
}

unsigned int *sub_1CD0758F0(unsigned int *a1, int a2, unsigned __int8 *a3, int a4, uint64_t a5, int a6)
{
  unsigned int v9 = a1[2];
  if (v9 >= a1[3]) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)a1 + 4 * v9) = a2;
  unsigned int v10 = a1[3];
  unsigned int v11 = a1[2] + 1;
  a1[2] = v11;
  if (v11 >= v10) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)a1 + 4 * v11) = 0;
  ++a1[2];
  uint64_t result = llvm::FoldingSetNodeID::AddString(a1, a3, a4 - (int)a3);
  unsigned int v13 = a1[2];
  if (v13 >= a1[3]) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)a1 + 4 * v13) = a5;
  unsigned int v14 = a1[3];
  unsigned int v15 = a1[2] + 1;
  a1[2] = v15;
  if (v15 >= v14) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)a1 + 4 * v15) = HIDWORD(a5);
  unsigned int v16 = a1[3];
  unsigned int v17 = a1[2] + 1;
  a1[2] = v17;
  if (v17 >= v16) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)a1 + 4 * v17) = a6;
  unsigned int v18 = a1[3];
  unsigned int v19 = a1[2] + 1;
  a1[2] = v19;
  if (v19 >= v18) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)a1 + 4 * v19) = a6 >> 31;
  ++a1[2];
  return result;
}

uint64_t sub_1CD075AB8(uint64_t a1)
{
  v111[16] = *MEMORY[0x1E4F143B8];
  int v2 = sub_1CC6B8620(a1);
  uint64_t v3 = *(const char **)a1;
  uint64_t v4 = *(const char **)(a1 + 8);
  if ((unint64_t)&v4[-*(void *)a1] < 2) {
    goto LABEL_2;
  }
  if (!strncmp("Do", *(const char **)a1, 2uLL))
  {
    *(void *)a1 = v3 + 2;
    uint64_t v5 = sub_1CD06AF4C(a1, "noexcept");
    if (v5) {
      goto LABEL_3;
    }
    return 0;
  }
  if (!strncmp("DO", v3, 2uLL))
  {
    *(void *)a1 = v3 + 2;
    uint64_t v24 = sub_1CD077868(a1);
    if (!v24) {
      return 0;
    }
    unsigned int v26 = *(const char **)a1;
    if (*(void *)a1 == *(void *)(a1 + 8) || *v26 != 69) {
      return 0;
    }
    uint64_t v27 = v24;
    *(void *)a1 = v26 + 1;
    int v28 = *(unsigned __int8 *)(a1 + 937);
    unsigned int v105 = (char *)&v106 + 8;
    uint64_t v107 = v24;
    long long v106 = xmmword_1CFB2EB00;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
    {
      uint64_t v24 = __cxa_guard_acquire(&qword_1EBCBE588);
      if (v24)
      {
        unint64_t v102 = llvm::hashing::detail::fixed_seed_override;
        if (!llvm::hashing::detail::fixed_seed_override) {
          unint64_t v102 = 0xFF51AFD7ED558CCDLL;
        }
        qword_1EBCBE580 = v102;
        __cxa_guard_release(&qword_1EBCBE588);
      }
    }
    unint64_t v29 = 0x9DDFEA08EB382D69 * (*((void *)&v106 + 1) ^ qword_1EBCBE580 ^ __ROR8__(v107 + 16, 16));
    unint64_t v30 = __ROR8__(v107 + 16, 16) ^ (v29 >> 47);
    uint64_t v31 = *(void *)(a1 + 904)
        + 8
        * ((*(_DWORD *)(a1 + 912) - 1) & ((-348639895
                                         * ((((0x9DDFEA08EB382D69 * (v30 ^ v29)) >> 32) >> 15) ^ (-348639895 * (v30 ^ v29)))) ^ v107));
    unsigned int v32 = *(unsigned int **)v31;
    unsigned int v109 = v111;
    uint64_t v110 = 0x2000000000;
    if (v32) {
      BOOL v33 = (v32 & 1) == 0;
    }
    else {
      BOOL v33 = 0;
    }
    if (!v33) {
      goto LABEL_167;
    }
    while (1)
    {
      LOBYTE(v24) = sub_1CD071418(v24, v32, (uint64_t)&v105, v25, (unsigned int *)&v109);
      if (v24) {
        break;
      }
      LODWORD(v110) = 0;
      unsigned int v32 = *(unsigned int **)v32;
      if (v32) {
        BOOL v34 = (v32 & 1) == 0;
      }
      else {
        BOOL v34 = 0;
      }
      if (!v34)
      {
        unsigned int v32 = 0;
        goto LABEL_102;
      }
    }
    uint64_t v31 = 0;
LABEL_102:
    if (v109 == v111)
    {
      if (v32)
      {
LABEL_104:
        int v70 = 0;
        uint64_t v5 = (uint64_t)(v32 + 2);
        goto LABEL_176;
      }
    }
    else
    {
      free(v109);
      if (v32) {
        goto LABEL_104;
      }
    }
LABEL_167:
    if (v28)
    {
      *(void *)(a1 + 888) += 32;
      uint64_t v94 = *(void *)(a1 + 808);
      if (((v94 + 7) & 0xFFFFFFFFFFFFFFF8) - v94 + 32 > *(void *)(a1 + 816) - v94)
      {
        unsigned int v99 = *(_DWORD *)(a1 + 832) >> 7;
        if (v99 >= 0x1E) {
          LOBYTE(v99) = 30;
        }
        uint64_t v100 = 4096 << v99;
        unint64_t v95 = (unint64_t)operator new(4096 << v99, (std::align_val_t)8uLL);
        unsigned int v101 = *(_DWORD *)(a1 + 832);
        if (v101 >= *(_DWORD *)(a1 + 836)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 824) + 8 * v101) = v95;
        ++*(_DWORD *)(a1 + 832);
        *(void *)(a1 + 816) = v95 + v100;
      }
      else
      {
        unint64_t v95 = (v94 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(a1 + 808) = v95 + 32;
      uint64_t v5 = v95 + 8;
      *(unsigned char *)(v95 + 16) = 16;
      *(_WORD *)(v95 + 17) = *(_WORD *)(v95 + 17) & 0xF000 | 0x540;
      *(void *)unint64_t v95 = 0;
      *(void *)(v95 + 8) = &unk_1F261ACD8;
      *(void *)(v95 + 24) = v27;
      unsigned int v96 = *(_DWORD *)(a1 + 916) + 1;
      int v97 = *(_DWORD *)(a1 + 912);
      if (v96 > 2 * v97)
      {
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v97, (uint64_t)off_1F2644D00);
        unsigned int v109 = v111;
        uint64_t v110 = 0x2000000000;
        sub_1CD0714B4((unsigned int *)v95, (unsigned int *)&v109);
        uint64_t v31 = *(void *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v109, (uint64_t)v109 + 4 * v110));
        if (v109 != v111) {
          free(v109);
        }
        unsigned int v96 = *(_DWORD *)(a1 + 916) + 1;
      }
      *(_DWORD *)(a1 + 916) = v96;
      uint64_t v98 = *(void *)v31;
      if (!*(void *)v31) {
        uint64_t v98 = v31 | 1;
      }
      *(void *)unint64_t v95 = v98;
      *(void *)uint64_t v31 = v95;
    }
    else
    {
      uint64_t v5 = 0;
    }
    int v70 = 1;
LABEL_176:
    unsigned int v87 = v105;
    if (v105 == (char *)&v106 + 8) {
      goto LABEL_148;
    }
    goto LABEL_147;
  }
  if (!strncmp("Dw", v3, 2uLL))
  {
    unsigned int v19 = v3 + 2;
    *(void *)a1 = v3 + 2;
    uint64_t v20 = (uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 3;
    while (v19 == v4 || *v19 != 69)
    {
      uint64_t v21 = sub_1CD06B2C4(a1);
      if (!v21) {
        return 0;
      }
      uint64_t v22 = v21;
      unsigned int v23 = *(uint64_t **)(a1 + 24);
      if (v23 == *(uint64_t **)(a1 + 32))
      {
        sub_1CD5F0ACC(a1 + 16, ((uint64_t)v23 - *(void *)(a1 + 16)) >> 2);
        unsigned int v23 = *(uint64_t **)(a1 + 24);
      }
      *(void *)(a1 + 24) = v23 + 1;
      *unsigned int v23 = v22;
      unsigned int v19 = *(const char **)a1;
      uint64_t v4 = *(const char **)(a1 + 8);
    }
    *(void *)a1 = v19 + 1;
    uint64_t v35 = *(void *)(a1 + 24);
    unsigned int v36 = (const void *)(*(void *)(a1 + 16) + 8 * v20);
    unsigned int v37 = (uint64_t *)sub_1CB906F34((uint64_t *)(a1 + 808), v35 - (void)v36, 3);
    unsigned int v38 = v37;
    int64_t v39 = v35 - (void)v36;
    if (v39) {
      memmove(v37, v36, v39);
    }
    uint64_t v40 = v39 >> 3;
    *(void *)(a1 + 24) = *(void *)(a1 + 16) + 8 * v20;
    int v41 = *(unsigned __int8 *)(a1 + 937);
    unsigned int v105 = (char *)&v106 + 8;
    *(void *)&long long v106 = 0x2000000000;
    sub_1CD074590((uint64_t)&v105, 17, v38, v40);
    unint64_t v42 = sub_1CC13A6B8(v105, (uint64_t)v105 + 4 * v106);
    uint64_t v44 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v42);
    uint64_t v45 = *(unsigned int **)v44;
    unsigned int v109 = v111;
    uint64_t v110 = 0x2000000000;
    if (v45) {
      BOOL v46 = (v45 & 1) == 0;
    }
    else {
      BOOL v46 = 0;
    }
    if (!v46) {
      goto LABEL_137;
    }
    while (1)
    {
      LOBYTE(v42) = sub_1CD071418(v42, v45, (uint64_t)&v105, v43, (unsigned int *)&v109);
      if (v42) {
        break;
      }
      LODWORD(v110) = 0;
      uint64_t v45 = *(unsigned int **)v45;
      if (v45) {
        BOOL v47 = (v45 & 1) == 0;
      }
      else {
        BOOL v47 = 0;
      }
      if (!v47)
      {
        uint64_t v45 = 0;
        goto LABEL_98;
      }
    }
    uint64_t v44 = 0;
LABEL_98:
    if (v109 == v111)
    {
      if (v45)
      {
LABEL_100:
        int v70 = 0;
        uint64_t v5 = (uint64_t)(v45 + 2);
        goto LABEL_146;
      }
    }
    else
    {
      free(v109);
      if (v45) {
        goto LABEL_100;
      }
    }
LABEL_137:
    if (v41)
    {
      *(void *)(a1 + 888) += 40;
      uint64_t v82 = *(void *)(a1 + 808);
      if (((v82 + 7) & 0xFFFFFFFFFFFFFFF8) - v82 + 40 > *(void *)(a1 + 816) - v82)
      {
        unsigned int v91 = *(_DWORD *)(a1 + 832) >> 7;
        if (v91 >= 0x1E) {
          LOBYTE(v91) = 30;
        }
        uint64_t v92 = 4096 << v91;
        unint64_t v83 = (unint64_t)operator new(4096 << v91, (std::align_val_t)8uLL);
        unsigned int v93 = *(_DWORD *)(a1 + 832);
        if (v93 >= *(_DWORD *)(a1 + 836)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 824) + 8 * v93) = v83;
        ++*(_DWORD *)(a1 + 832);
        *(void *)(a1 + 816) = v83 + v92;
      }
      else
      {
        unint64_t v83 = (v82 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(a1 + 808) = v83 + 40;
      uint64_t v5 = v83 + 8;
      *(unsigned char *)(v83 + 16) = 17;
      *(_WORD *)(v83 + 17) = *(_WORD *)(v83 + 17) & 0xF000 | 0x540;
      *(void *)unint64_t v83 = 0;
      *(void *)(v83 + 8) = &unk_1F261AD30;
      *(void *)(v83 + 24) = v38;
      *(void *)(v83 + 32) = v40;
      unsigned int v84 = *(_DWORD *)(a1 + 916) + 1;
      int v85 = *(_DWORD *)(a1 + 912);
      if (v84 > 2 * v85)
      {
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v85, (uint64_t)off_1F2644D00);
        unsigned int v109 = v111;
        uint64_t v110 = 0x2000000000;
        sub_1CD0714B4((unsigned int *)v83, (unsigned int *)&v109);
        uint64_t v44 = *(void *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v109, (uint64_t)v109 + 4 * v110));
        if (v109 != v111) {
          free(v109);
        }
        unsigned int v84 = *(_DWORD *)(a1 + 916) + 1;
      }
      *(_DWORD *)(a1 + 916) = v84;
      uint64_t v86 = *(void *)v44;
      if (!*(void *)v44) {
        uint64_t v86 = v44 | 1;
      }
      *(void *)unint64_t v83 = v86;
      *(void *)uint64_t v44 = v83;
    }
    else
    {
      uint64_t v5 = 0;
    }
    int v70 = 1;
LABEL_146:
    unsigned int v87 = v105;
    if (v105 == (char *)&v106 + 8)
    {
LABEL_148:
      if (v70)
      {
        *(void *)(a1 + 920) = v5;
      }
      else
      {
        if (!v5) {
          return 0;
        }
        unsigned int v109 = 0;
        int v89 = sub_1CD640748(a1 + 944, v5, &v109);
        uint64_t v90 = 0;
        if (v89) {
          uint64_t v90 = *((void *)v109 + 1);
        }
        if (v90) {
          uint64_t v5 = v90;
        }
        if (v5 == *(void *)(a1 + 928)) {
          *(unsigned char *)(a1 + 936) = 1;
        }
      }
      if (v5) {
        goto LABEL_3;
      }
      return 0;
    }
LABEL_147:
    free(v87);
    goto LABEL_148;
  }
LABEL_2:
  uint64_t v5 = 0;
LABEL_3:
  unsigned int v7 = *(const char **)a1;
  unsigned int v6 = *(const char **)(a1 + 8);
  if ((unint64_t)&v6[-*(void *)a1] >= 2 && !strncmp("Dx", *(const char **)a1, 2uLL))
  {
    v7 += 2;
    *(void *)a1 = v7;
  }
  if (v7 == v6 || *v7 != 70) {
    return 0;
  }
  *(void *)a1 = v7 + 1;
  if (v7 + 1 != v6 && v7[1] == 89) {
    *(void *)a1 = v7 + 2;
  }
  uint64_t v8 = sub_1CD06B2C4(a1);
  if (!v8) {
    return 0;
  }
  uint64_t v9 = v8;
  int v104 = v2;
  uint64_t v10 = (uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 3;
  uint64_t v11 = 2;
  while (1)
  {
    while (1)
    {
      unsigned int v13 = *(const char **)a1;
      uint64_t v12 = *(void *)(a1 + 8);
      if (*(void *)a1 != v12) {
        break;
      }
LABEL_16:
      if ((unint64_t)(v12 - (void)v13) >= 2)
      {
        if (!strncmp("RE", *(const char **)a1, 2uLL))
        {
          int v15 = 1;
          goto LABEL_67;
        }
        int v15 = 2;
        if (!strncmp("OE", v13, 2uLL))
        {
          uint64_t v11 = 2;
          goto LABEL_67;
        }
      }
      uint64_t v16 = sub_1CD06B2C4(a1);
      if (!v16) {
        return 0;
      }
      uint64_t v17 = v16;
      unsigned int v18 = *(uint64_t **)(a1 + 24);
      if (v18 == *(uint64_t **)(a1 + 32))
      {
        sub_1CD5F0ACC(a1 + 16, ((uint64_t)v18 - *(void *)(a1 + 16)) >> 2);
        unsigned int v18 = *(uint64_t **)(a1 + 24);
      }
      *(void *)(a1 + 24) = v18 + 1;
      *unsigned int v18 = v17;
    }
    int v14 = *(unsigned __int8 *)v13;
    if (v14 != 118) {
      break;
    }
    *(void *)a1 = v13 + 1;
  }
  if (v14 != 69) {
    goto LABEL_16;
  }
  int v15 = 0;
  uint64_t v11 = 1;
LABEL_67:
  *(void *)a1 = &v13[v11];
  unsigned int v48 = *(unsigned char **)(a1 + 24);
  unsigned int v49 = (unsigned char *)(*(void *)(a1 + 16) + 8 * v10);
  unsigned int v50 = (uint64_t *)sub_1CB906F34((uint64_t *)(a1 + 808), v48 - v49, 3);
  unsigned int v51 = v50;
  if (v48 != v49) {
    memmove(v50, v49, v48 - v49);
  }
  uint64_t v52 = (v48 - v49) >> 3;
  *(void *)(a1 + 24) = *(void *)(a1 + 16) + 8 * v10;
  int v103 = *(unsigned __int8 *)(a1 + 937);
  unsigned int v105 = (char *)&v106 + 8;
  uint64_t v107 = v9;
  uint64_t v108 = v52;
  long long v106 = xmmword_1CFB2EB10;
  if (v48 == v49)
  {
    unsigned int v54 = 6;
  }
  else
  {
    uint64_t v53 = 8 * v52;
    unsigned int v54 = 6;
    unsigned int v55 = v51;
    do
    {
      uint64_t v56 = *v55;
      if (v54 >= DWORD1(v106)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)v105 + v54) = v56;
      unsigned int v57 = v106 + 1;
      LODWORD(v106) = v57;
      if (v57 >= DWORD1(v106)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)v105 + v57) = HIDWORD(v56);
      unsigned int v54 = v106 + 1;
      LODWORD(v106) = v106 + 1;
      ++v55;
      v53 -= 8;
    }
    while (v53);
    if (v54 >= DWORD1(v106)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
  }
  *((_DWORD *)v105 + v54) = v104;
  unsigned int v58 = v106 + 1;
  LODWORD(v106) = v58;
  if (v58 >= DWORD1(v106)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((_DWORD *)v105 + v58) = 0;
  unsigned int v59 = v106 + 1;
  LODWORD(v106) = v59;
  if (v59 >= DWORD1(v106)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((_DWORD *)v105 + v59) = v15;
  unsigned int v60 = v106 + 1;
  LODWORD(v106) = v60;
  if (v60 >= DWORD1(v106)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((_DWORD *)v105 + v60) = 0;
  unsigned int v61 = v106 + 1;
  LODWORD(v106) = v61;
  if (v61 >= DWORD1(v106)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((_DWORD *)v105 + v61) = v5;
  unsigned int v62 = v106 + 1;
  LODWORD(v106) = v62;
  if (v62 >= DWORD1(v106)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((_DWORD *)v105 + v62) = HIDWORD(v5);
  LODWORD(v106) = v106 + 1;
  unint64_t v63 = sub_1CC13A6B8(v105, (uint64_t)v105 + 4 * v106);
  uint64_t v65 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v63);
  unsigned int v66 = *(unsigned int **)v65;
  unsigned int v109 = v111;
  uint64_t v110 = 0x2000000000;
  if (!v66 || (v66 & 1) != 0) {
    goto LABEL_106;
  }
  while (1)
  {
    LOBYTE(v63) = sub_1CD071418(v63, v66, (uint64_t)&v105, v64, (unsigned int *)&v109);
    if (v63) {
      break;
    }
    LODWORD(v110) = 0;
    unsigned int v66 = *(unsigned int **)v66;
    if (v66) {
      BOOL v67 = (v66 & 1) == 0;
    }
    else {
      BOOL v67 = 0;
    }
    if (!v67)
    {
      unsigned int v66 = 0;
      goto LABEL_94;
    }
  }
  uint64_t v65 = 0;
LABEL_94:
  if (v109 == v111)
  {
    if (v66) {
      goto LABEL_96;
    }
LABEL_106:
    if (v103)
    {
      *(void *)(a1 + 888) += 64;
      uint64_t v71 = *(void *)(a1 + 808);
      if (((v71 + 7) & 0xFFFFFFFFFFFFFFF8) - v71 + 64 > *(void *)(a1 + 816) - v71)
      {
        unsigned int v78 = *(_DWORD *)(a1 + 832) >> 7;
        if (v78 >= 0x1E) {
          LOBYTE(v78) = 30;
        }
        uint64_t v79 = 4096 << v78;
        unint64_t v72 = (unint64_t)operator new(4096 << v78, (std::align_val_t)8uLL);
        unsigned int v80 = *(_DWORD *)(a1 + 832);
        if (v80 >= *(_DWORD *)(a1 + 836)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 824) + 8 * v80) = v72;
        ++*(_DWORD *)(a1 + 832);
        *(void *)(a1 + 816) = v72 + v79;
      }
      else
      {
        unint64_t v72 = (v71 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(a1 + 808) = v72 + 64;
      uint64_t v69 = v72 + 8;
      *(unsigned char *)(v72 + 16) = 15;
      *(_WORD *)(v72 + 17) = *(_WORD *)(v72 + 17) & 0xF000 | 0x100;
      *(void *)unint64_t v72 = 0;
      *(void *)(v72 + 8) = &unk_1F261AD88;
      *(void *)(v72 + 24) = v9;
      *(void *)(v72 + 32) = v51;
      *(void *)(v72 + 40) = v52;
      *(_DWORD *)(v72 + 48) = v104;
      *(unsigned char *)(v72 + 52) = v15;
      *(void *)(v72 + 56) = v5;
      unsigned int v73 = *(_DWORD *)(a1 + 916) + 1;
      int v74 = *(_DWORD *)(a1 + 912);
      if (v73 > 2 * v74)
      {
        unint64_t v81 = (unsigned int *)v72;
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v74, (uint64_t)off_1F2644D00);
        unsigned int v109 = v111;
        uint64_t v110 = 0x2000000000;
        sub_1CD0714B4(v81, (unsigned int *)&v109);
        uint64_t v65 = *(void *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v109, (uint64_t)v109 + 4 * v110));
        if (v109 != v111) {
          free(v109);
        }
        unsigned int v73 = *(_DWORD *)(a1 + 916) + 1;
        unint64_t v72 = (unint64_t)v81;
      }
      *(_DWORD *)(a1 + 916) = v73;
      uint64_t v75 = *(void *)v65;
      if (!*(void *)v65) {
        uint64_t v75 = v65 | 1;
      }
      *(void *)unint64_t v72 = v75;
      *(void *)uint64_t v65 = v72;
    }
    else
    {
      uint64_t v69 = 0;
    }
    int v68 = 1;
  }
  else
  {
    free(v109);
    if (!v66) {
      goto LABEL_106;
    }
LABEL_96:
    int v68 = 0;
    uint64_t v69 = (uint64_t)(v66 + 2);
  }
  if (v105 != (char *)&v106 + 8) {
    free(v105);
  }
  if (v68)
  {
    *(void *)(a1 + 920) = v69;
  }
  else if (v69)
  {
    unsigned int v109 = 0;
    int v76 = sub_1CD640748(a1 + 944, v69, &v109);
    uint64_t v77 = 0;
    if (v76) {
      uint64_t v77 = *((void *)v109 + 1);
    }
    if (v77) {
      uint64_t v69 = v77;
    }
    if (v69 == *(void *)(a1 + 928)) {
      *(unsigned char *)(a1 + 936) = 1;
    }
  }
  return v69;
}

uint64_t sub_1CD076988(uint64_t a1)
{
  v78[16] = *MEMORY[0x1E4F143B8];
  int v2 = *(unsigned __int8 **)a1;
  if (*(void *)a1 == *(void *)(a1 + 8) || *v2 != 85)
  {
    unsigned int v5 = sub_1CC6B8620(a1);
    uint64_t v6 = sub_1CD06B2C4(a1);
    uint64_t v8 = v6;
    if (!v6 || !v5) {
      return v8;
    }
    int v9 = *(unsigned __int8 *)(a1 + 937);
    unint64_t v72 = (char *)&v73 + 8;
    uint64_t v74 = v6;
    uint64_t v75 = v5;
    long long v73 = xmmword_1CFB2EB40;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
    {
      uint64_t v6 = __cxa_guard_acquire(&qword_1EBCBE588);
      if (v6)
      {
        unint64_t v71 = llvm::hashing::detail::fixed_seed_override;
        if (!llvm::hashing::detail::fixed_seed_override) {
          unint64_t v71 = 0xFF51AFD7ED558CCDLL;
        }
        qword_1EBCBE580 = v71;
        __cxa_guard_release(&qword_1EBCBE588);
      }
    }
    uint64_t v10 = __ROR8__(0xB492B66FBE98F273 * *((void *)&v73 + 1) - v74, 43)
        - 0x3C5A37A36834CED9 * v74
        + __ROR8__((0x9AE16A3B2F90404FLL * v75) ^ qword_1EBCBE580, 30);
    unint64_t v11 = qword_1EBCBE580
        + __ROR8__(v74 ^ 0xC949D7C7509E6557, 20)
        - 0x4B6D499041670D8DLL * *((void *)&v73 + 1)
        - 0x9AE16A3B2F90404FLL * v75
        + 24;
    unint64_t v12 = 0x9DDFEA08EB382D69
        * (v11 ^ ((0x9DDFEA08EB382D69 * (v10 ^ v11)) >> 47) ^ (0x9DDFEA08EB382D69 * (v10 ^ v11)));
    uint64_t v13 = *(void *)(a1 + 904)
        + 8 * ((-348639895 * ((v12 >> 47) ^ v12)) & (*(_DWORD *)(a1 + 912) - 1));
    int v14 = *(unsigned int **)v13;
    int v76 = v78;
    uint64_t v77 = 0x2000000000;
    if (v14) {
      BOOL v15 = (v14 & 1) == 0;
    }
    else {
      BOOL v15 = 0;
    }
    if (!v15)
    {
LABEL_72:
      if (v9)
      {
        *(void *)(a1 + 888) += 32;
        uint64_t v42 = *(void *)(a1 + 808);
        if (((v42 + 7) & 0xFFFFFFFFFFFFFFF8) - v42 + 32 > *(void *)(a1 + 816) - v42)
        {
          unsigned int v48 = *(_DWORD *)(a1 + 832) >> 7;
          if (v48 >= 0x1E) {
            LOBYTE(v48) = 30;
          }
          uint64_t v49 = 4096 << v48;
          unint64_t v43 = (unint64_t)operator new(4096 << v48, (std::align_val_t)8uLL);
          unsigned int v50 = *(_DWORD *)(a1 + 832);
          if (v50 >= *(_DWORD *)(a1 + 836)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)(a1 + 824) + 8 * v50) = v43;
          ++*(_DWORD *)(a1 + 832);
          *(void *)(a1 + 816) = v43 + v49;
        }
        else
        {
          unint64_t v43 = (v42 + 7) & 0xFFFFFFFFFFFFFFF8;
        }
        *(void *)(a1 + 808) = v43 + 32;
        *(void *)unint64_t v43 = 0;
        __int16 v44 = *(_WORD *)(v8 + 9);
        *(unsigned char *)(v43 + 16) = 3;
        *(_WORD *)(v43 + 17) = *(_WORD *)(v43 + 17) & 0xF000 | v44 & 0xFC0;
        *(void *)(v43 + 8) = &unk_1F261AE90;
        *(_DWORD *)(v43 + 20) = v5;
        *(void *)(v43 + 24) = v8;
        unsigned int v45 = *(_DWORD *)(a1 + 916) + 1;
        int v46 = *(_DWORD *)(a1 + 912);
        if (v45 > 2 * v46)
        {
          llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v46, (uint64_t)off_1F2644D00);
          int v76 = v78;
          uint64_t v77 = 0x2000000000;
          sub_1CD0714B4((unsigned int *)v43, (unsigned int *)&v76);
          uint64_t v13 = *(void *)(a1 + 904)
              + 8
              * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v76, (uint64_t)v76 + 4 * v77));
          if (v76 != v78) {
            free(v76);
          }
          unsigned int v45 = *(_DWORD *)(a1 + 916) + 1;
        }
        *(_DWORD *)(a1 + 916) = v45;
        uint64_t v47 = *(void *)v13;
        if (!*(void *)v13) {
          uint64_t v47 = v13 | 1;
        }
        *(void *)unint64_t v43 = v47;
        *(void *)uint64_t v13 = v43;
        int v17 = 1;
        uint64_t v8 = v43 + 8;
LABEL_126:
        if (v72 != (char *)&v73 + 8) {
          free(v72);
        }
        if (!v17) {
          goto LABEL_100;
        }
LABEL_129:
        *(void *)(a1 + 920) = v8;
        return v8;
      }
      goto LABEL_124;
    }
    while (1)
    {
      LOBYTE(v6) = sub_1CD071418(v6, v14, (uint64_t)&v72, v7, (unsigned int *)&v76);
      if (v6) {
        break;
      }
      LODWORD(v77) = 0;
      int v14 = *(unsigned int **)v14;
      if (v14) {
        BOOL v16 = (v14 & 1) == 0;
      }
      else {
        BOOL v16 = 0;
      }
      if (!v16)
      {
        int v14 = 0;
        goto LABEL_21;
      }
    }
    uint64_t v13 = 0;
LABEL_21:
    if (v76 == v78)
    {
      if (!v14) {
        goto LABEL_72;
      }
    }
    else
    {
      free(v76);
      if (!v14) {
        goto LABEL_72;
      }
    }
    int v17 = 0;
    uint64_t v8 = (uint64_t)(v14 + 2);
    goto LABEL_126;
  }
  *(void *)a1 = v2 + 1;
  int v76 = 0;
  uint64_t v3 = 0;
  uint64_t v4 = 0;
  if ((sub_1CC6B813C((unsigned __int8 **)a1, (uint64_t *)&v76) & 1) == 0)
  {
    uint64_t v4 = *(char **)a1;
    if (*(void *)(a1 + 8) - *(void *)a1 >= (unint64_t)v76)
    {
      uint64_t v3 = (char *)v76 + (void)v4;
      *(void *)a1 = (char *)v76 + (void)v4;
    }
    else
    {
      uint64_t v3 = 0;
      uint64_t v4 = 0;
    }
  }
  if (v4 == v3) {
    return 0;
  }
  if ((unint64_t)(v3 - v4) > 8)
  {
    int v20 = strncmp("objcproto", v4, 9uLL);
    unsigned int v18 = *(unsigned __int8 **)a1;
    unsigned int v19 = *(unsigned __int8 **)(a1 + 8);
    if (v20) {
      goto LABEL_29;
    }
    *(void *)a1 = v4 + 9;
    *(void *)(a1 + 8) = v3;
    int v76 = 0;
    unsigned int v32 = 0;
    BOOL v33 = 0;
    if ((sub_1CC6B813C((unsigned __int8 **)a1, (uint64_t *)&v76) & 1) == 0)
    {
      if (*(void *)(a1 + 8) - *(void *)a1 >= (unint64_t)v76) {
        unsigned int v32 = (unsigned __int8 *)v76 + *(void *)a1;
      }
      else {
        unsigned int v32 = 0;
      }
      if (*(void *)(a1 + 8) - *(void *)a1 >= (unint64_t)v76) {
        BOOL v33 = *(unsigned __int8 **)a1;
      }
      else {
        BOOL v33 = 0;
      }
    }
    *(void *)a1 = v18;
    *(void *)(a1 + 8) = v19;
    if (v33 == v32) {
      return 0;
    }
    uint64_t v34 = sub_1CD076988(a1);
    if (!v34) {
      return 0;
    }
    uint64_t v35 = v34;
    int v36 = *(unsigned __int8 *)(a1 + 937);
    unint64_t v72 = (char *)&v73 + 8;
    uint64_t v74 = v34;
    long long v73 = xmmword_1CFB2EB20;
    llvm::FoldingSetNodeID::AddString((unsigned int *)&v72, v33, v32 - v33);
    unint64_t v37 = sub_1CC13A6B8(v72, (uint64_t)v72 + 4 * v73);
    uint64_t v39 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v37);
    uint64_t v40 = *(unsigned int **)v39;
    int v76 = v78;
    uint64_t v77 = 0x2000000000;
    if (v40 && (v40 & 1) == 0)
    {
      while (1)
      {
        LOBYTE(v37) = sub_1CD071418(v37, v40, (uint64_t)&v72, v38, (unsigned int *)&v76);
        if (v37) {
          break;
        }
        LODWORD(v77) = 0;
        uint64_t v40 = *(unsigned int **)v40;
        if (v40) {
          BOOL v41 = (v40 & 1) == 0;
        }
        else {
          BOOL v41 = 0;
        }
        if (!v41)
        {
          uint64_t v40 = 0;
          goto LABEL_68;
        }
      }
      uint64_t v39 = 0;
LABEL_68:
      if (v76 == v78)
      {
        if (v40)
        {
LABEL_70:
          int v17 = 0;
          uint64_t v8 = (uint64_t)(v40 + 2);
          goto LABEL_126;
        }
      }
      else
      {
        free(v76);
        if (v40) {
          goto LABEL_70;
        }
      }
    }
    if (v36)
    {
      *(void *)(a1 + 888) += 48;
      uint64_t v62 = *(void *)(a1 + 808);
      if (((v62 + 7) & 0xFFFFFFFFFFFFFFF8) - v62 + 48 > *(void *)(a1 + 816) - v62)
      {
        unsigned int v68 = *(_DWORD *)(a1 + 832) >> 7;
        if (v68 >= 0x1E) {
          LOBYTE(v68) = 30;
        }
        uint64_t v69 = 4096 << v68;
        unint64_t v63 = (unint64_t)operator new(4096 << v68, (std::align_val_t)8uLL);
        unsigned int v70 = *(_DWORD *)(a1 + 832);
        if (v70 >= *(_DWORD *)(a1 + 836)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 824) + 8 * v70) = v63;
        ++*(_DWORD *)(a1 + 832);
        *(void *)(a1 + 816) = v63 + v69;
      }
      else
      {
        unint64_t v63 = (v62 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(a1 + 808) = v63 + 48;
      uint64_t v8 = v63 + 8;
      *(unsigned char *)(v63 + 16) = 10;
      *(_WORD *)(v63 + 17) = *(_WORD *)(v63 + 17) & 0xF000 | 0x540;
      *(void *)unint64_t v63 = 0;
      *(void *)(v63 + 8) = &unk_1F261ADE0;
      *(void *)(v63 + 24) = v35;
      *(void *)(v63 + 32) = v33;
      *(void *)(v63 + 40) = v32;
      unsigned int v64 = *(_DWORD *)(a1 + 916) + 1;
      int v65 = *(_DWORD *)(a1 + 912);
      if (v64 > 2 * v65)
      {
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v65, (uint64_t)off_1F2644D00);
        int v76 = v78;
        uint64_t v77 = 0x2000000000;
        sub_1CD0714B4((unsigned int *)v63, (unsigned int *)&v76);
        uint64_t v39 = *(void *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v76, (uint64_t)v76 + 4 * v77));
        if (v76 != v78) {
          free(v76);
        }
        unsigned int v64 = *(_DWORD *)(a1 + 916) + 1;
      }
      *(_DWORD *)(a1 + 916) = v64;
      uint64_t v66 = *(void *)v39;
      if (!*(void *)v39) {
        uint64_t v66 = v39 | 1;
      }
      *(void *)unint64_t v63 = v66;
      *(void *)uint64_t v39 = v63;
      goto LABEL_125;
    }
LABEL_124:
    uint64_t v8 = 0;
LABEL_125:
    int v17 = 1;
    goto LABEL_126;
  }
  unsigned int v18 = *(unsigned __int8 **)a1;
  unsigned int v19 = *(unsigned __int8 **)(a1 + 8);
LABEL_29:
  if (v19 == v18 || *v18 != 73)
  {
    uint64_t v21 = 0;
  }
  else
  {
    uint64_t v21 = sub_1CD07D418(a1, 0);
    if (!v21) {
      return 0;
    }
  }
  uint64_t v22 = sub_1CD076988(a1);
  if (!v22) {
    return 0;
  }
  uint64_t v23 = v22;
  int v24 = *(unsigned __int8 *)(a1 + 937);
  unint64_t v72 = (char *)&v73 + 8;
  uint64_t v74 = v22;
  long long v73 = xmmword_1CFB2EB30;
  llvm::FoldingSetNodeID::AddString((unsigned int *)&v72, (unsigned __int8 *)v4, v3 - v4);
  if (v73 >= DWORD1(v73)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((_DWORD *)v72 + v73) = v21;
  unsigned int v25 = v73 + 1;
  LODWORD(v73) = v25;
  if (v25 >= DWORD1(v73)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((_DWORD *)v72 + v25) = HIDWORD(v21);
  LODWORD(v73) = v73 + 1;
  unint64_t v26 = sub_1CC13A6B8(v72, (uint64_t)v72 + 4 * v73);
  uint64_t v28 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v26);
  unint64_t v29 = *(unsigned int **)v28;
  int v76 = v78;
  uint64_t v77 = 0x2000000000;
  if (v29 && (v29 & 1) == 0)
  {
    while (1)
    {
      LOBYTE(v26) = sub_1CD071418(v26, v29, (uint64_t)&v72, v27, (unsigned int *)&v76);
      if (v26) {
        break;
      }
      LODWORD(v77) = 0;
      unint64_t v29 = *(unsigned int **)v29;
      if (v29) {
        BOOL v30 = (v29 & 1) == 0;
      }
      else {
        BOOL v30 = 0;
      }
      if (!v30)
      {
        unint64_t v29 = 0;
        goto LABEL_46;
      }
    }
    uint64_t v28 = 0;
LABEL_46:
    if (v76 == v78)
    {
      if (v29)
      {
LABEL_48:
        int v31 = 0;
        uint64_t v8 = (uint64_t)(v29 + 2);
        goto LABEL_97;
      }
    }
    else
    {
      free(v76);
      if (v29) {
        goto LABEL_48;
      }
    }
  }
  if (v24)
  {
    *(void *)(a1 + 888) += 56;
    uint64_t v51 = *(void *)(a1 + 808);
    if (((v51 + 7) & 0xFFFFFFFFFFFFFFF8) - v51 + 56 > *(void *)(a1 + 816) - v51)
    {
      unsigned int v58 = *(_DWORD *)(a1 + 832) >> 7;
      if (v58 >= 0x1E) {
        LOBYTE(v58) = 30;
      }
      uint64_t v59 = 4096 << v58;
      unint64_t v52 = (unint64_t)operator new(4096 << v58, (std::align_val_t)8uLL);
      unsigned int v60 = *(_DWORD *)(a1 + 832);
      if (v60 >= *(_DWORD *)(a1 + 836)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(a1 + 824) + 8 * v60) = v52;
      ++*(_DWORD *)(a1 + 832);
      *(void *)(a1 + 816) = v52 + v59;
    }
    else
    {
      unint64_t v52 = (v51 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    *(void *)(a1 + 808) = v52 + 56;
    uint64_t v8 = v52 + 8;
    *(unsigned char *)(v52 + 16) = 2;
    *(_WORD *)(v52 + 17) = *(_WORD *)(v52 + 17) & 0xF000 | 0x540;
    *(void *)unint64_t v52 = 0;
    *(void *)(v52 + 8) = &unk_1F261AE38;
    *(void *)(v52 + 24) = v23;
    *(void *)(v52 + 32) = v4;
    *(void *)(v52 + 40) = v3;
    *(void *)(v52 + 48) = v21;
    unsigned int v53 = *(_DWORD *)(a1 + 916) + 1;
    int v54 = *(_DWORD *)(a1 + 912);
    if (v53 > 2 * v54)
    {
      unsigned int v61 = (unsigned int *)v52;
      llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v54, (uint64_t)off_1F2644D00);
      int v76 = v78;
      uint64_t v77 = 0x2000000000;
      sub_1CD0714B4(v61, (unsigned int *)&v76);
      uint64_t v28 = *(void *)(a1 + 904)
          + 8 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v76, (uint64_t)v76 + 4 * v77));
      if (v76 != v78) {
        free(v76);
      }
      unsigned int v53 = *(_DWORD *)(a1 + 916) + 1;
      unint64_t v52 = (unint64_t)v61;
    }
    *(_DWORD *)(a1 + 916) = v53;
    uint64_t v55 = *(void *)v28;
    if (!*(void *)v28) {
      uint64_t v55 = v28 | 1;
    }
    *(void *)unint64_t v52 = v55;
    *(void *)uint64_t v28 = v52;
  }
  else
  {
    uint64_t v8 = 0;
  }
  int v31 = 1;
LABEL_97:
  if (v72 != (char *)&v73 + 8) {
    free(v72);
  }
  if (v31) {
    goto LABEL_129;
  }
LABEL_100:
  if (v8)
  {
    int v76 = 0;
    int v56 = sub_1CD640748(a1 + 944, v8, &v76);
    uint64_t v57 = 0;
    if (v56) {
      uint64_t v57 = *((void *)v76 + 1);
    }
    if (v57) {
      uint64_t v8 = v57;
    }
    if (v8 == *(void *)(a1 + 928)) {
      *(unsigned char *)(a1 + 936) = 1;
    }
  }
  return v8;
}

uint64_t sub_1CD077500(uint64_t a1, long long *a2)
{
  v32[16] = *MEMORY[0x1E4F143B8];
  int v4 = *(unsigned __int8 *)(a1 + 937);
  uint64_t v28 = &v29[2];
  unsigned int v5 = *(unsigned __int8 **)a2;
  uint64_t v6 = *((void *)a2 + 1);
  *(_OWORD *)unint64_t v29 = xmmword_1CFB2EA50;
  llvm::FoldingSetNodeID::AddString((unsigned int *)&v28, v5, v6 - v5);
  unint64_t v7 = sub_1CC13A6B8(v28, (uint64_t)v28 + 4 * v29[0]);
  uint64_t v9 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v7);
  uint64_t v10 = *(unsigned int **)v9;
  BOOL v30 = v32;
  uint64_t v31 = 0x2000000000;
  if (v10) {
    BOOL v11 = (v10 & 1) == 0;
  }
  else {
    BOOL v11 = 0;
  }
  if (!v11) {
    goto LABEL_17;
  }
  while (1)
  {
    LOBYTE(v7) = sub_1CD071418(v7, v10, (uint64_t)&v28, v8, (unsigned int *)&v30);
    if (v7) {
      break;
    }
    LODWORD(v31) = 0;
    uint64_t v10 = *(unsigned int **)v10;
    if (v10) {
      BOOL v12 = (v10 & 1) == 0;
    }
    else {
      BOOL v12 = 0;
    }
    if (!v12)
    {
      uint64_t v10 = 0;
      goto LABEL_13;
    }
  }
  uint64_t v9 = 0;
LABEL_13:
  if (v30 == v32)
  {
    if (v10)
    {
LABEL_15:
      int v13 = 0;
      uint64_t v14 = (uint64_t)(v10 + 2);
      goto LABEL_26;
    }
  }
  else
  {
    free(v30);
    if (v10) {
      goto LABEL_15;
    }
  }
LABEL_17:
  if (v4)
  {
    *(void *)(a1 + 888) += 40;
    uint64_t v15 = *(void *)(a1 + 808);
    if (((v15 + 7) & 0xFFFFFFFFFFFFFFF8) - v15 + 40 > *(void *)(a1 + 816) - v15)
    {
      unsigned int v25 = *(_DWORD *)(a1 + 832) >> 7;
      if (v25 >= 0x1E) {
        LOBYTE(v25) = 30;
      }
      uint64_t v26 = 4096 << v25;
      unint64_t v16 = (unint64_t)operator new(4096 << v25, (std::align_val_t)8uLL);
      unsigned int v27 = *(_DWORD *)(a1 + 832);
      if (v27 >= *(_DWORD *)(a1 + 836)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(a1 + 824) + 8 * v27) = v16;
      ++*(_DWORD *)(a1 + 832);
      *(void *)(a1 + 816) = v16 + v26;
    }
    else
    {
      unint64_t v16 = (v15 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    *(void *)(a1 + 808) = v16 + 40;
    uint64_t v14 = v16 + 8;
    *(unsigned char *)(v16 + 16) = 7;
    __int16 v17 = *(_WORD *)(v16 + 17) & 0xF000 | 0x540;
    *(void *)unint64_t v16 = 0;
    *(void *)(v16 + 8) = &unk_1F26197E0;
    long long v18 = *a2;
    *(_WORD *)(v16 + 17) = v17;
    *(_OWORD *)(v16 + 24) = v18;
    unsigned int v19 = *(_DWORD *)(a1 + 916) + 1;
    int v20 = *(_DWORD *)(a1 + 912);
    if (v19 > 2 * v20)
    {
      llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v20, (uint64_t)off_1F2644D00);
      BOOL v30 = v32;
      uint64_t v31 = 0x2000000000;
      sub_1CD0714B4((unsigned int *)v16, (unsigned int *)&v30);
      uint64_t v9 = *(void *)(a1 + 904)
         + 8 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v30, (uint64_t)v30 + 4 * v31));
      if (v30 != v32) {
        free(v30);
      }
      unsigned int v19 = *(_DWORD *)(a1 + 916) + 1;
    }
    *(_DWORD *)(a1 + 916) = v19;
    uint64_t v21 = *(void *)v9;
    if (!*(void *)v9) {
      uint64_t v21 = v9 | 1;
    }
    *(void *)unint64_t v16 = v21;
    *(void *)uint64_t v9 = v16;
  }
  else
  {
    uint64_t v14 = 0;
  }
  int v13 = 1;
LABEL_26:
  if (v28 != &v29[2]) {
    free(v28);
  }
  if (v13)
  {
    *(void *)(a1 + 920) = v14;
  }
  else if (v14)
  {
    BOOL v30 = 0;
    int v23 = sub_1CD640748(a1 + 944, v14, &v30);
    uint64_t v24 = 0;
    if (v23) {
      uint64_t v24 = *((void *)v30 + 1);
    }
    if (v24) {
      uint64_t v14 = v24;
    }
    if (v14 == *(void *)(a1 + 928)) {
      *(unsigned char *)(a1 + 936) = 1;
    }
  }
  return v14;
}

uint64_t sub_1CD077868(uint64_t a1)
{
  v550[16] = *MEMORY[0x1E4F143B8];
  int v2 = *(unsigned __int8 **)a1;
  if (*(void *)(a1 + 8) - *(void *)a1 >= 2uLL && !strncmp("gs", (const char *)v2, 2uLL))
  {
    *(void *)a1 = v2 + 2;
    int v3 = 1;
  }
  else
  {
    int v3 = 0;
  }
  int v4 = sub_1CD07E754((unsigned __int8 **)a1);
  if (v4)
  {
    unsigned int v5 = v4;
    uint64_t v6 = (const char *)*((void *)v4 + 1);
    size_t v7 = strlen(v6);
    uint64_t v8 = (unsigned __int8 *)v6;
    if (v5[2] <= 0xAu)
    {
      uint64_t v9 = 8;
      if (v7 < 8) {
        uint64_t v9 = v7;
      }
      uint64_t v8 = (unsigned __int8 *)&v6[v9];
      if (v7 >= 9 && *v8 == 32) {
        ++v8;
      }
    }
    uint64_t v10 = (uint64_t)&v6[v7];
    uint64_t v11 = 0;
    switch(v5[2])
    {
      case 1:
        BOOL v12 = *(unsigned __int8 **)a1;
        if (*(void *)a1 != *(void *)(a1 + 8) && *v12 == 95)
        {
          *(void *)a1 = v12 + 1;
LABEL_15:
          int v13 = v5[3] >> 1;
          return sub_1CD07E7FC(a1, v8, v10, v13);
        }
        uint64_t v121 = sub_1CD077868(a1);
        if (!v121) {
          return 0;
        }
        uint64_t v122 = v121;
        unsigned int v123 = v5[3];
        int v124 = *(unsigned __int8 *)(a1 + 937);
        v543 = (char *)&v544 + 8;
        uint64_t v545 = v121;
        long long v544 = xmmword_1CFB2EB80;
        llvm::FoldingSetNodeID::AddString((unsigned int *)&v543, v8, v10 - v8);
        if (v544 >= DWORD1(v544)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((_DWORD *)v543 + v544) = (char)v123 >> 1;
        unsigned int v125 = v544 + 1;
        LODWORD(v544) = v125;
        if (v125 >= DWORD1(v544)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((_DWORD *)v543 + v125) = (char)v123 >> 7;
        LODWORD(v544) = v544 + 1;
        unint64_t v126 = sub_1CC13A6B8(v543, (uint64_t)v543 + 4 * v544);
        uint64_t v128 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v126);
        unsigned int v32 = *(unsigned int **)v128;
        *(void *)&long long v549 = v550;
        *((void *)&v549 + 1) = 0x2000000000;
        if (!v32 || (v32 & 1) != 0) {
          goto LABEL_228;
        }
        while (1)
        {
          LOBYTE(v126) = sub_1CD071418(v126, v32, (uint64_t)&v543, v127, (unsigned int *)&v549);
          if (v126) {
            break;
          }
          DWORD2(v549) = 0;
          unsigned int v32 = *(unsigned int **)v32;
          if (v32) {
            BOOL v129 = (v32 & 1) == 0;
          }
          else {
            BOOL v129 = 0;
          }
          if (!v129)
          {
            unsigned int v32 = 0;
            goto LABEL_226;
          }
        }
        uint64_t v128 = 0;
LABEL_226:
        if ((void *)v549 == v550)
        {
          if (v32) {
            goto LABEL_243;
          }
        }
        else
        {
          free((void *)v549);
          if (v32) {
            goto LABEL_243;
          }
        }
LABEL_228:
        if (!v124) {
          goto LABEL_691;
        }
        *(void *)(a1 + 888) += 48;
        uint64_t v167 = *(void *)(a1 + 808);
        if (((v167 + 7) & 0xFFFFFFFFFFFFFFF8) - v167 + 48 > *(void *)(a1 + 816) - v167)
        {
          unsigned int v397 = *(_DWORD *)(a1 + 832) >> 7;
          if (v397 >= 0x1E) {
            LOBYTE(v397) = 30;
          }
          uint64_t v398 = 4096 << v397;
          unint64_t v168 = (unint64_t)operator new(4096 << v397, (std::align_val_t)8uLL);
          unsigned int v399 = *(_DWORD *)(a1 + 832);
          if (v399 >= *(_DWORD *)(a1 + 836)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)(a1 + 824) + 8 * v399) = v168;
          ++*(_DWORD *)(a1 + 832);
          *(void *)(a1 + 816) = v168 + v398;
        }
        else
        {
          unint64_t v168 = (v167 + 7) & 0xFFFFFFFFFFFFFFF8;
        }
        *(void *)(a1 + 808) = v168 + 48;
        uint64_t v11 = v168 + 8;
        *(unsigned char *)(v168 + 16) = 52;
        *(_WORD *)(v168 + 17) = *(_WORD *)(v168 + 17) & 0xF000 | (v123 >> 1) | 0x540;
        *(void *)unint64_t v168 = 0;
        *(void *)(v168 + 8) = &unk_1F2619998;
        *(void *)(v168 + 24) = v122;
        *(void *)(v168 + 32) = v8;
        *(void *)(v168 + 40) = v10;
        unsigned int v169 = *(_DWORD *)(a1 + 916) + 1;
        int v170 = *(_DWORD *)(a1 + 912);
        if (v169 > 2 * v170)
        {
          llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v170, (uint64_t)off_1F2644D00);
          *(void *)&long long v549 = v550;
          *((void *)&v549 + 1) = 0x2000000000;
          sub_1CD0714B4((unsigned int *)v168, (unsigned int *)&v549);
          uint64_t v128 = *(void *)(a1 + 904)
               + 8
               * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8((void *)v549, v549 + 4 * DWORD2(v549)));
          if ((void *)v549 != v550) {
            free((void *)v549);
          }
          unsigned int v169 = *(_DWORD *)(a1 + 916) + 1;
        }
        *(_DWORD *)(a1 + 916) = v169;
        uint64_t v171 = *(void *)v128;
        if (!*(void *)v128) {
          uint64_t v171 = v128 | 1;
        }
        *(void *)unint64_t v168 = v171;
        *(void *)uint64_t v128 = v168;
        goto LABEL_692;
      case 2:
        unsigned int v55 = v5[3];
        uint64_t v56 = sub_1CD077868(a1);
        if (!v56) {
          return 0;
        }
        uint64_t v57 = v56;
        uint64_t v58 = sub_1CD077868(a1);
        if (!v58) {
          return 0;
        }
        uint64_t v59 = v58;
        int v60 = *(unsigned __int8 *)(a1 + 937);
        v543 = (char *)&v544 + 8;
        *(void *)&long long v544 = 0x2000000000;
        sub_1CD074CA4((unsigned int *)&v543, 50, v57, v8, v10, v58, (char)v55 >> 1);
        unint64_t v61 = sub_1CC13A6B8(v543, (uint64_t)v543 + 4 * v544);
        uint64_t v63 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v61);
        unsigned int v64 = *(unsigned int **)v63;
        *(void *)&long long v549 = v550;
        *((void *)&v549 + 1) = 0x2000000000;
        if (v64) {
          BOOL v65 = (v64 & 1) == 0;
        }
        else {
          BOOL v65 = 0;
        }
        if (!v65) {
          goto LABEL_251;
        }
        while (1)
        {
          LOBYTE(v61) = sub_1CD071418(v61, v64, (uint64_t)&v543, v62, (unsigned int *)&v549);
          if (v61) {
            break;
          }
          DWORD2(v549) = 0;
          unsigned int v64 = *(unsigned int **)v64;
          if (v64) {
            BOOL v66 = (v64 & 1) == 0;
          }
          else {
            BOOL v66 = 0;
          }
          if (!v66)
          {
            unsigned int v64 = 0;
            goto LABEL_249;
          }
        }
        uint64_t v63 = 0;
LABEL_249:
        if ((void *)v549 == v550)
        {
          if (v64) {
            goto LABEL_261;
          }
        }
        else
        {
          free((void *)v549);
          if (v64) {
            goto LABEL_261;
          }
        }
LABEL_251:
        if (!v60) {
          goto LABEL_725;
        }
        *(void *)(a1 + 888) += 56;
        uint64_t v180 = *(void *)(a1 + 808);
        if (((v180 + 7) & 0xFFFFFFFFFFFFFFF8) - v180 + 56 > *(void *)(a1 + 816) - v180)
        {
          unsigned int v403 = *(_DWORD *)(a1 + 832) >> 7;
          if (v403 >= 0x1E) {
            LOBYTE(v403) = 30;
          }
          uint64_t v404 = 4096 << v403;
          unint64_t v181 = (unint64_t)operator new(4096 << v403, (std::align_val_t)8uLL);
          unsigned int v405 = *(_DWORD *)(a1 + 832);
          if (v405 >= *(_DWORD *)(a1 + 836)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)(a1 + 824) + 8 * v405) = v181;
          ++*(_DWORD *)(a1 + 832);
          *(void *)(a1 + 816) = v181 + v404;
        }
        else
        {
          unint64_t v181 = (v180 + 7) & 0xFFFFFFFFFFFFFFF8;
        }
        *(void *)(a1 + 808) = v181 + 56;
        uint64_t v11 = v181 + 8;
        *(unsigned char *)(v181 + 16) = 50;
        *(_WORD *)(v181 + 17) = *(_WORD *)(v181 + 17) & 0xF000 | (v55 >> 1) | 0x540;
        *(void *)unint64_t v181 = 0;
        *(void *)(v181 + 8) = &unk_1F26198E8;
        *(void *)(v181 + 24) = v57;
        *(void *)(v181 + 32) = v8;
        *(void *)(v181 + 40) = v10;
        *(void *)(v181 + 48) = v59;
        unsigned int v182 = *(_DWORD *)(a1 + 916) + 1;
        int v183 = *(_DWORD *)(a1 + 912);
        if (v182 > 2 * v183)
        {
          llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v183, (uint64_t)off_1F2644D00);
          *(void *)&long long v549 = v550;
          *((void *)&v549 + 1) = 0x2000000000;
          sub_1CD0714B4((unsigned int *)v181, (unsigned int *)&v549);
          uint64_t v63 = *(void *)(a1 + 904)
              + 8
              * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8((void *)v549, v549 + 4 * DWORD2(v549)));
          if ((void *)v549 != v550) {
            free((void *)v549);
          }
          unsigned int v182 = *(_DWORD *)(a1 + 916) + 1;
        }
        *(_DWORD *)(a1 + 916) = v182;
        uint64_t v184 = *(void *)v63;
        if (!*(void *)v63) {
          uint64_t v184 = v63 | 1;
        }
        *(void *)unint64_t v181 = v184;
        *(void *)uint64_t v63 = v181;
        goto LABEL_726;
      case 3:
        uint64_t v34 = sub_1CD077868(a1);
        if (!v34) {
          return 0;
        }
        uint64_t v35 = v34;
        uint64_t v36 = sub_1CD077868(a1);
        if (!v36) {
          return 0;
        }
        uint64_t v38 = v36;
        unsigned int v39 = v5[3];
        int v40 = *(unsigned __int8 *)(a1 + 937);
        v543 = (char *)&v544 + 8;
        uint64_t v545 = v35;
        uint64_t v546 = v36;
        uint64_t v547 = (char)v39 >> 1;
        long long v544 = xmmword_1CFB2EB70;
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
        {
          uint64_t v36 = __cxa_guard_acquire(&qword_1EBCBE588);
          if (v36)
          {
            unint64_t v527 = llvm::hashing::detail::fixed_seed_override;
            if (!llvm::hashing::detail::fixed_seed_override) {
              unint64_t v527 = 0xFF51AFD7ED558CCDLL;
            }
            qword_1EBCBE580 = v527;
            __cxa_guard_release(&qword_1EBCBE588);
          }
        }
        uint64_t v41 = __ROR8__(0xB492B66FBE98F273 * *((void *)&v544 + 1) - v545, 43)
            - 0x3C5A37A36834CED9 * v546
            + __ROR8__((0x9AE16A3B2F90404FLL * v547) ^ qword_1EBCBE580, 30);
        unint64_t v42 = qword_1EBCBE580
            + __ROR8__(v545 ^ 0xC949D7C7509E6557, 20)
            - 0x4B6D499041670D8DLL * *((void *)&v544 + 1)
            - 0x9AE16A3B2F90404FLL * v547
            + 32;
        unint64_t v43 = 0x9DDFEA08EB382D69
            * (v42 ^ ((0x9DDFEA08EB382D69 * (v41 ^ v42)) >> 47) ^ (0x9DDFEA08EB382D69 * (v41 ^ v42)));
        uint64_t v44 = *(void *)(a1 + 904)
            + 8 * ((-348639895 * ((v43 >> 47) ^ v43)) & (*(_DWORD *)(a1 + 912) - 1));
        unsigned int v45 = *(unsigned int **)v44;
        *(void *)&long long v549 = v550;
        *((void *)&v549 + 1) = 0x2000000000;
        if (v45) {
          BOOL v46 = (v45 & 1) == 0;
        }
        else {
          BOOL v46 = 0;
        }
        if (!v46) {
          goto LABEL_700;
        }
        while (1)
        {
          LOBYTE(v36) = sub_1CD071418(v36, v45, (uint64_t)&v543, v37, (unsigned int *)&v549);
          if (v36) {
            break;
          }
          DWORD2(v549) = 0;
          unsigned int v45 = *(unsigned int **)v45;
          if (v45) {
            BOOL v47 = (v45 & 1) == 0;
          }
          else {
            BOOL v47 = 0;
          }
          if (!v47)
          {
            unsigned int v45 = 0;
            goto LABEL_245;
          }
        }
        uint64_t v44 = 0;
LABEL_245:
        if ((void *)v549 == v550)
        {
          if (v45)
          {
LABEL_247:
            int v179 = 0;
            uint64_t v11 = (uint64_t)(v45 + 2);
            goto LABEL_709;
          }
        }
        else
        {
          free((void *)v549);
          if (v45) {
            goto LABEL_247;
          }
        }
LABEL_700:
        if (v40)
        {
          *(void *)(a1 + 888) += 40;
          uint64_t v463 = *(void *)(a1 + 808);
          if (((v463 + 7) & 0xFFFFFFFFFFFFFFF8) - v463 + 40 > *(void *)(a1 + 816) - v463)
          {
            unsigned int v468 = *(_DWORD *)(a1 + 832) >> 7;
            if (v468 >= 0x1E) {
              LOBYTE(v468) = 30;
            }
            uint64_t v469 = 4096 << v468;
            unint64_t v464 = (unint64_t)operator new(4096 << v468, (std::align_val_t)8uLL);
            unsigned int v470 = *(_DWORD *)(a1 + 832);
            if (v470 >= *(_DWORD *)(a1 + 836)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(*(void *)(a1 + 824) + 8 * v470) = v464;
            ++*(_DWORD *)(a1 + 832);
            *(void *)(a1 + 816) = v464 + v469;
          }
          else
          {
            unint64_t v464 = (v463 + 7) & 0xFFFFFFFFFFFFFFF8;
          }
          *(void *)(a1 + 808) = v464 + 40;
          uint64_t v11 = v464 + 8;
          *(unsigned char *)(v464 + 16) = 51;
          *(_WORD *)(v464 + 17) = *(_WORD *)(v464 + 17) & 0xF000 | (v39 >> 1) | 0x540;
          *(void *)unint64_t v464 = 0;
          *(void *)(v464 + 8) = &unk_1F26199F0;
          *(void *)(v464 + 24) = v35;
          *(void *)(v464 + 32) = v38;
          unsigned int v465 = *(_DWORD *)(a1 + 916) + 1;
          int v466 = *(_DWORD *)(a1 + 912);
          if (v465 > 2 * v466)
          {
            llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v466, (uint64_t)off_1F2644D00);
            *(void *)&long long v549 = v550;
            *((void *)&v549 + 1) = 0x2000000000;
            sub_1CD0714B4((unsigned int *)v464, (unsigned int *)&v549);
            uint64_t v44 = *(void *)(a1 + 904)
                + 8
                * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8((void *)v549, v549 + 4 * DWORD2(v549)));
            if ((void *)v549 != v550) {
              free((void *)v549);
            }
            unsigned int v465 = *(_DWORD *)(a1 + 916) + 1;
          }
          *(_DWORD *)(a1 + 916) = v465;
          uint64_t v467 = *(void *)v44;
          if (!*(void *)v44) {
            uint64_t v467 = v44 | 1;
          }
          *(void *)unint64_t v464 = v467;
          *(void *)uint64_t v44 = v464;
        }
        else
        {
          uint64_t v11 = 0;
        }
        int v179 = 1;
LABEL_709:
        v459 = v543;
        if (v543 == (char *)&v544 + 8) {
          goto LABEL_781;
        }
        goto LABEL_780;
      case 4:
        uint64_t v77 = sub_1CD077868(a1);
        if (!v77) {
          return 0;
        }
        uint64_t v78 = v77;
        uint64_t v79 = sub_1CD077868(a1);
        if (!v79) {
          return 0;
        }
        uint64_t v80 = v79;
        unsigned int v81 = v5[3];
        int v82 = *(unsigned __int8 *)(a1 + 937);
        v543 = (char *)&v544 + 8;
        *(void *)&long long v544 = 0x2000000000;
        sub_1CD074CA4((unsigned int *)&v543, 54, v78, v8, v10, v79, (char)v81 >> 1);
        unint64_t v83 = sub_1CC13A6B8(v543, (uint64_t)v543 + 4 * v544);
        uint64_t v85 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v83);
        unsigned int v64 = *(unsigned int **)v85;
        *(void *)&long long v549 = v550;
        *((void *)&v549 + 1) = 0x2000000000;
        if (v64) {
          BOOL v86 = (v64 & 1) == 0;
        }
        else {
          BOOL v86 = 0;
        }
        if (!v86) {
          goto LABEL_718;
        }
        while (1)
        {
          LOBYTE(v83) = sub_1CD071418(v83, v64, (uint64_t)&v543, v84, (unsigned int *)&v549);
          if (v83) {
            break;
          }
          DWORD2(v549) = 0;
          unsigned int v64 = *(unsigned int **)v64;
          if (v64) {
            BOOL v87 = (v64 & 1) == 0;
          }
          else {
            BOOL v87 = 0;
          }
          if (!v87)
          {
            unsigned int v64 = 0;
            goto LABEL_259;
          }
        }
        uint64_t v85 = 0;
LABEL_259:
        if ((void *)v549 == v550)
        {
          if (v64)
          {
LABEL_261:
            int v179 = 0;
            uint64_t v11 = (uint64_t)(v64 + 2);
            goto LABEL_727;
          }
        }
        else
        {
          free((void *)v549);
          if (v64) {
            goto LABEL_261;
          }
        }
LABEL_718:
        if (v82)
        {
          *(void *)(a1 + 888) += 56;
          uint64_t v471 = *(void *)(a1 + 808);
          if (((v471 + 7) & 0xFFFFFFFFFFFFFFF8) - v471 + 56 > *(void *)(a1 + 816) - v471)
          {
            unsigned int v476 = *(_DWORD *)(a1 + 832) >> 7;
            if (v476 >= 0x1E) {
              LOBYTE(v476) = 30;
            }
            uint64_t v477 = 4096 << v476;
            unint64_t v472 = (unint64_t)operator new(4096 << v476, (std::align_val_t)8uLL);
            unsigned int v478 = *(_DWORD *)(a1 + 832);
            if (v478 >= *(_DWORD *)(a1 + 836)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(*(void *)(a1 + 824) + 8 * v478) = v472;
            ++*(_DWORD *)(a1 + 832);
            *(void *)(a1 + 816) = v472 + v477;
          }
          else
          {
            unint64_t v472 = (v471 + 7) & 0xFFFFFFFFFFFFFFF8;
          }
          *(void *)(a1 + 808) = v472 + 56;
          uint64_t v11 = v472 + 8;
          *(unsigned char *)(v472 + 16) = 54;
          *(_WORD *)(v472 + 17) = *(_WORD *)(v472 + 17) & 0xF000 | (v81 >> 1) | 0x540;
          *(void *)unint64_t v472 = 0;
          *(void *)(v472 + 8) = &unk_1F2619A48;
          *(void *)(v472 + 24) = v78;
          *(void *)(v472 + 32) = v8;
          *(void *)(v472 + 40) = v10;
          *(void *)(v472 + 48) = v80;
          unsigned int v473 = *(_DWORD *)(a1 + 916) + 1;
          int v474 = *(_DWORD *)(a1 + 912);
          if (v473 > 2 * v474)
          {
            llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v474, (uint64_t)off_1F2644D00);
            *(void *)&long long v549 = v550;
            *((void *)&v549 + 1) = 0x2000000000;
            sub_1CD0714B4((unsigned int *)v472, (unsigned int *)&v549);
            uint64_t v85 = *(void *)(a1 + 904)
                + 8
                * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8((void *)v549, v549 + 4 * DWORD2(v549)));
            if ((void *)v549 != v550) {
              free((void *)v549);
            }
            unsigned int v473 = *(_DWORD *)(a1 + 916) + 1;
          }
          *(_DWORD *)(a1 + 916) = v473;
          uint64_t v475 = *(void *)v85;
          if (!*(void *)v85) {
            uint64_t v475 = v85 | 1;
          }
          *(void *)unint64_t v472 = v475;
          *(void *)uint64_t v85 = v472;
        }
        else
        {
LABEL_725:
          uint64_t v11 = 0;
        }
LABEL_726:
        int v179 = 1;
LABEL_727:
        v459 = v543;
LABEL_728:
        if (v459 == (long long *)((char *)&v544 + 8)) {
          goto LABEL_781;
        }
        goto LABEL_780;
      case 5:
        uint64_t v88 = (uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 3;
        while (2)
        {
          int v89 = *(unsigned __int8 **)a1;
          if (*(void *)a1 == *(void *)(a1 + 8) || *v89 != 95)
          {
            uint64_t v90 = sub_1CD077868(a1);
            if (v90)
            {
              uint64_t v91 = v90;
              uint64_t v92 = *(uint64_t **)(a1 + 24);
              if (v92 == *(uint64_t **)(a1 + 32))
              {
                sub_1CD5F0ACC(a1 + 16, ((uint64_t)v92 - *(void *)(a1 + 16)) >> 2);
                uint64_t v92 = *(uint64_t **)(a1 + 24);
              }
              *(void *)(a1 + 24) = v92 + 1;
              *uint64_t v92 = v91;
              continue;
            }
            return 0;
          }
          break;
        }
        *(void *)a1 = v89 + 1;
        unsigned int v150 = *(unsigned char **)(a1 + 24);
        unsigned int v151 = (unsigned char *)(*(void *)(a1 + 16) + 8 * v88);
        unsigned int v152 = (uint64_t *)sub_1CB906F34((uint64_t *)(a1 + 808), v150 - v151, 3);
        unsigned int v153 = v152;
        uint64_t v154 = v150 - v151;
        if (v150 != v151) {
          memmove(v152, v151, v150 - v151);
        }
        *(void *)(a1 + 24) = *(void *)(a1 + 16) + 8 * v88;
        uint64_t v155 = sub_1CD06B2C4(a1);
        if (!v155) {
          return 0;
        }
        uint64_t v536 = v155;
        v539 = v153;
        uint64_t v157 = *(unsigned __int8 **)a1;
        uint64_t v156 = *(unsigned __int8 **)(a1 + 8);
        if ((unint64_t)&v156[-*(void *)a1] >= 2 && !strncmp("pi", *(const char **)a1, 2uLL))
        {
          v157 += 2;
          *(void *)a1 = v157;
          int v158 = 1;
        }
        else
        {
          int v158 = 0;
        }
        uint64_t v159 = v154 >> 3;
        uint64_t v160 = (uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 3;
        while (v157 == v156 || *v157 != 69)
        {
          if (!v158) {
            return 0;
          }
          uint64_t v161 = sub_1CD077868(a1);
          if (!v161) {
            return 0;
          }
          uint64_t v162 = v161;
          uint64_t v163 = *(uint64_t **)(a1 + 24);
          if (v163 == *(uint64_t **)(a1 + 32))
          {
            sub_1CD5F0ACC(a1 + 16, ((uint64_t)v163 - *(void *)(a1 + 16)) >> 2);
            uint64_t v163 = *(uint64_t **)(a1 + 24);
          }
          *(void *)(a1 + 24) = v163 + 1;
          uint64_t *v163 = v162;
          uint64_t v157 = *(unsigned __int8 **)a1;
          uint64_t v156 = *(unsigned __int8 **)(a1 + 8);
        }
        *(void *)a1 = v157 + 1;
        unsigned int v247 = *(unsigned char **)(a1 + 24);
        unsigned int v248 = (unsigned char *)(*(void *)(a1 + 16) + 8 * v160);
        unsigned int v249 = (uint64_t *)sub_1CB906F34((uint64_t *)(a1 + 808), v247 - v248, 3);
        unsigned int v250 = v249;
        uint64_t v251 = v536;
        if (v247 != v248) {
          memmove(v249, v248, v247 - v248);
        }
        *(void *)(a1 + 24) = *(void *)(a1 + 16) + 8 * v160;
        unsigned int v252 = v5[3];
        int v253 = *(unsigned __int8 *)(a1 + 937);
        v543 = (char *)&v544 + 8;
        *(void *)&long long v544 = 0x2000000000;
        uint64_t v534 = (v247 - v248) >> 3;
        sub_1CD0751A0((uint64_t)&v543, v539, v159, v536, v250, v534, v3, v252 & 1, (char)v252 >> 1);
        unint64_t v254 = sub_1CC13A6B8(v543, (uint64_t)v543 + 4 * v544);
        uint64_t v256 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v254);
        uint64_t v257 = *(unsigned int **)v256;
        *(void *)&long long v549 = v550;
        *((void *)&v549 + 1) = 0x2000000000;
        if (v257) {
          BOOL v258 = (v257 & 1) == 0;
        }
        else {
          BOOL v258 = 0;
        }
        if (!v258) {
          goto LABEL_802;
        }
        while (1)
        {
          LOBYTE(v254) = sub_1CD071418(v254, v257, (uint64_t)&v543, v255, (unsigned int *)&v549);
          if (v254) {
            break;
          }
          DWORD2(v549) = 0;
          uint64_t v257 = *(unsigned int **)v257;
          if (v257) {
            BOOL v259 = (v257 & 1) == 0;
          }
          else {
            BOOL v259 = 0;
          }
          if (!v259)
          {
            uint64_t v257 = 0;
            goto LABEL_373;
          }
        }
        uint64_t v256 = 0;
LABEL_373:
        if ((void *)v549 == v550)
        {
          if (v257)
          {
LABEL_375:
            int v179 = 0;
            uint64_t v11 = (uint64_t)(v257 + 2);
LABEL_811:
            v459 = v543;
            goto LABEL_728;
          }
        }
        else
        {
          free((void *)v549);
          if (v257) {
            goto LABEL_375;
          }
        }
LABEL_802:
        if (v253)
        {
          *(void *)(a1 + 888) += 72;
          uint64_t v490 = *(void *)(a1 + 808);
          if (((v490 + 7) & 0xFFFFFFFFFFFFFFF8) - v490 + 72 > *(void *)(a1 + 816) - v490)
          {
            unsigned int v495 = *(_DWORD *)(a1 + 832) >> 7;
            if (v495 >= 0x1E) {
              LOBYTE(v495) = 30;
            }
            uint64_t v496 = 4096 << v495;
            v533 = (char *)operator new(4096 << v495, (std::align_val_t)8uLL);
            unsigned int v497 = *(_DWORD *)(a1 + 832);
            if (v497 >= *(_DWORD *)(a1 + 836)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            unint64_t v491 = (unint64_t)v533;
            *(void *)(*(void *)(a1 + 824) + 8 * v497) = v533;
            ++*(_DWORD *)(a1 + 832);
            *(void *)(a1 + 816) = &v533[v496];
            uint64_t v251 = v536;
          }
          else
          {
            unint64_t v491 = (v490 + 7) & 0xFFFFFFFFFFFFFFF8;
          }
          *(void *)(a1 + 808) = v491 + 72;
          uint64_t v11 = v491 + 8;
          *(unsigned char *)(v491 + 16) = 60;
          *(_WORD *)(v491 + 17) = *(_WORD *)(v491 + 17) & 0xF000 | (v252 >> 1) | 0x540;
          *(void *)unint64_t v491 = 0;
          *(void *)(v491 + 8) = &unk_1F2619AA0;
          *(void *)(v491 + 24) = v539;
          *(void *)(v491 + 32) = v159;
          *(void *)(v491 + 40) = v251;
          *(void *)(v491 + 48) = v250;
          *(void *)(v491 + 56) = v534;
          *(unsigned char *)(v491 + 64) = v3;
          *(unsigned char *)(v491 + 65) = v252 & 1;
          unsigned int v492 = *(_DWORD *)(a1 + 916) + 1;
          int v493 = *(_DWORD *)(a1 + 912);
          if (v492 > 2 * v493)
          {
            llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v493, (uint64_t)off_1F2644D00);
            *(void *)&long long v549 = v550;
            *((void *)&v549 + 1) = 0x2000000000;
            sub_1CD0714B4((unsigned int *)v491, (unsigned int *)&v549);
            uint64_t v256 = *(void *)(a1 + 904)
                 + 8
                 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8((void *)v549, v549 + 4 * DWORD2(v549)));
            if ((void *)v549 != v550) {
              free((void *)v549);
            }
            unsigned int v492 = *(_DWORD *)(a1 + 916) + 1;
          }
          *(_DWORD *)(a1 + 916) = v492;
          uint64_t v494 = *(void *)v256;
          if (!*(void *)v256) {
            uint64_t v494 = v256 | 1;
          }
          *(void *)unint64_t v491 = v494;
          *(void *)uint64_t v256 = v491;
        }
        else
        {
          uint64_t v11 = 0;
        }
        int v179 = 1;
        goto LABEL_811;
      case 6:
        uint64_t v67 = sub_1CD077868(a1);
        if (!v67) {
          return 0;
        }
        uint64_t v68 = v67;
        unsigned int v69 = v5[3];
        int v70 = *(unsigned __int8 *)(a1 + 937);
        v543 = (char *)&v544 + 8;
        *(void *)&long long v544 = 0x2000000000;
        sub_1CD075670((uint64_t)&v543, v67, v3, v69 & 1, (char)v69 >> 1);
        unint64_t v71 = sub_1CC13A6B8(v543, (uint64_t)v543 + 4 * v544);
        uint64_t v73 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v71);
        uint64_t v74 = *(unsigned int **)v73;
        *(void *)&long long v549 = v550;
        *((void *)&v549 + 1) = 0x2000000000;
        if (v74) {
          BOOL v75 = (v74 & 1) == 0;
        }
        else {
          BOOL v75 = 0;
        }
        if (!v75) {
          goto LABEL_221;
        }
        while (1)
        {
          LOBYTE(v71) = sub_1CD071418(v71, v74, (uint64_t)&v543, v72, (unsigned int *)&v549);
          if (v71) {
            break;
          }
          DWORD2(v549) = 0;
          uint64_t v74 = *(unsigned int **)v74;
          if (v74) {
            BOOL v76 = (v74 & 1) == 0;
          }
          else {
            BOOL v76 = 0;
          }
          if (!v76)
          {
            uint64_t v74 = 0;
            goto LABEL_219;
          }
        }
        uint64_t v73 = 0;
LABEL_219:
        if ((void *)v549 == v550)
        {
          if (v74) {
            goto LABEL_297;
          }
        }
        else
        {
          free((void *)v549);
          if (v74) {
            goto LABEL_297;
          }
        }
LABEL_221:
        if (!v70) {
          goto LABEL_777;
        }
        *(void *)(a1 + 888) += 40;
        uint64_t v166 = *(void *)(a1 + 808);
        if (((v166 + 7) & 0xFFFFFFFFFFFFFFF8) - v166 + 40 > *(void *)(a1 + 816) - v166)
        {
          unsigned int v370 = *(_DWORD *)(a1 + 832) >> 7;
          if (v370 >= 0x1E) {
            LOBYTE(v370) = 30;
          }
          uint64_t v371 = 4096 << v370;
          unint64_t v165 = (unint64_t)operator new(4096 << v370, (std::align_val_t)8uLL);
          unsigned int v372 = *(_DWORD *)(a1 + 832);
          if (v372 >= *(_DWORD *)(a1 + 836)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)(a1 + 824) + 8 * v372) = v165;
          ++*(_DWORD *)(a1 + 832);
          *(void *)(a1 + 816) = v165 + v371;
        }
        else
        {
          unint64_t v165 = (v166 + 7) & 0xFFFFFFFFFFFFFFF8;
        }
        *(void *)(a1 + 808) = v165 + 40;
        uint64_t v11 = v165 + 8;
        *(unsigned char *)(v165 + 16) = 61;
        *(_WORD *)(v165 + 17) = *(_WORD *)(v165 + 17) & 0xF000 | (v69 >> 1) | 0x540;
        *(void *)unint64_t v165 = 0;
        *(void *)(v165 + 8) = &unk_1F2619AF8;
        *(void *)(v165 + 24) = v68;
        *(unsigned char *)(v165 + 32) = v3;
        *(unsigned char *)(v165 + 33) = v69 & 1;
        goto LABEL_773;
      case 7:
        v543 = (void *)sub_1CD077868(a1);
        if (!v543) {
          return 0;
        }
        uint64_t v113 = (uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 3;
        while (2)
        {
          int v114 = *(unsigned __int8 **)a1;
          if (*(void *)a1 != *(void *)(a1 + 8) && *v114 == 69)
          {
            *(void *)a1 = v114 + 1;
            uint64_t v172 = *(void *)(a1 + 24);
            unsigned int v173 = (const void *)(*(void *)(a1 + 16) + 8 * v113);
            uint64_t v174 = (void *)sub_1CB906F34((uint64_t *)(a1 + 808), v172 - (void)v173, 3);
            uint64_t v175 = v174;
            int64_t v176 = v172 - (void)v173;
            if (v176) {
              memmove(v174, v173, v176);
            }
            *(void *)(a1 + 24) = *(void *)(a1 + 16) + 8 * v113;
            *(void *)&long long v549 = v175;
            *((void *)&v549 + 1) = v176 >> 3;
            int v177 = v5[3] >> 1;
            goto LABEL_238;
          }
          uint64_t v115 = sub_1CD077868(a1);
          if (v115)
          {
            uint64_t v116 = v115;
            int v117 = *(uint64_t **)(a1 + 24);
            if (v117 == *(uint64_t **)(a1 + 32))
            {
              sub_1CD5F0ACC(a1 + 16, ((uint64_t)v117 - *(void *)(a1 + 16)) >> 2);
              int v117 = *(uint64_t **)(a1 + 24);
            }
            *(void *)(a1 + 24) = v117 + 1;
            uint64_t *v117 = v116;
            continue;
          }
          return 0;
        }
      case 8:
        char v49 = *(unsigned char *)(a1 + 776);
        *(unsigned char *)(a1 + 776) = 0;
        uint64_t v50 = sub_1CD06B2C4(a1);
        *(unsigned char *)(a1 + 776) = v49;
        if (!v50) {
          return 0;
        }
        uint64_t v51 = v50;
        uint64_t v52 = *(void *)(a1 + 24) - *(void *)(a1 + 16);
        unsigned int v53 = *(unsigned __int8 **)a1;
        if (*(void *)a1 == *(void *)(a1 + 8) || *v53 != 95)
        {
          int v54 = 0;
        }
        else
        {
          *(void *)a1 = v53 + 1;
          int v54 = 1;
        }
        uint64_t v145 = v52 >> 3;
        while (1)
        {
          unsigned int v146 = *(unsigned __int8 **)a1;
          if (*(void *)a1 != *(void *)(a1 + 8) && *v146 == 69) {
            break;
          }
          uint64_t v147 = sub_1CD077868(a1);
          if (!v147) {
            return 0;
          }
          uint64_t v148 = v147;
          unsigned int v149 = *(uint64_t **)(a1 + 24);
          if (v149 == *(uint64_t **)(a1 + 32))
          {
            sub_1CD5F0ACC(a1 + 16, ((uint64_t)v149 - *(void *)(a1 + 16)) >> 2);
            unsigned int v149 = *(uint64_t **)(a1 + 24);
          }
          *(void *)(a1 + 24) = v149 + 1;
          *unsigned int v149 = v148;
          if ((v54 & 1) == 0) {
            goto LABEL_270;
          }
        }
        *(void *)a1 = v146 + 1;
LABEL_270:
        uint64_t v190 = *(void *)(a1 + 24);
        unsigned int v191 = (const void *)(*(void *)(a1 + 16) + 8 * v145);
        unsigned int v192 = (uint64_t *)sub_1CB906F34((uint64_t *)(a1 + 808), v190 - (void)v191, 3);
        unsigned int v193 = v192;
        int64_t v194 = v190 - (void)v191;
        if (v194) {
          memmove(v192, v191, v194);
        }
        *(void *)(a1 + 24) = *(void *)(a1 + 16) + 8 * v145;
        if (((v194 != 8) & ~v54) != 0) {
          return 0;
        }
        uint64_t v130 = v194 >> 3;
        unsigned int v195 = v5[3];
        int v196 = *(unsigned __int8 *)(a1 + 937);
        v543 = (char *)&v544 + 8;
        *(void *)&long long v544 = 0x2000000000;
        sub_1CD074EE0((uint64_t)&v543, 64, v51, v193, v194 >> 3, (char)v195 >> 1);
        unint64_t v197 = sub_1CC13A6B8(v543, (uint64_t)v543 + 4 * v544);
        uint64_t v73 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v197);
        uint64_t v74 = *(unsigned int **)v73;
        *(void *)&long long v549 = v550;
        *((void *)&v549 + 1) = 0x2000000000;
        if (v74) {
          BOOL v199 = (v74 & 1) == 0;
        }
        else {
          BOOL v199 = 0;
        }
        if (!v199) {
          goto LABEL_767;
        }
        while (1)
        {
          LOBYTE(v197) = sub_1CD071418(v197, v74, (uint64_t)&v543, v198, (unsigned int *)&v549);
          if (v197) {
            break;
          }
          DWORD2(v549) = 0;
          uint64_t v74 = *(unsigned int **)v74;
          if (v74) {
            BOOL v200 = (v74 & 1) == 0;
          }
          else {
            BOOL v200 = 0;
          }
          if (!v200)
          {
            uint64_t v74 = 0;
            goto LABEL_295;
          }
        }
        uint64_t v73 = 0;
LABEL_295:
        if ((void *)v549 == v550)
        {
          if (v74) {
            goto LABEL_297;
          }
        }
        else
        {
          free((void *)v549);
          if (v74) {
            goto LABEL_297;
          }
        }
LABEL_767:
        if (!v196) {
          goto LABEL_777;
        }
        *(void *)(a1 + 888) += 48;
        uint64_t v480 = *(void *)(a1 + 808);
        if (((v480 + 7) & 0xFFFFFFFFFFFFFFF8) - v480 + 48 > *(void *)(a1 + 816) - v480)
        {
          unsigned int v484 = *(_DWORD *)(a1 + 832) >> 7;
          if (v484 >= 0x1E) {
            LOBYTE(v484) = 30;
          }
          uint64_t v485 = 4096 << v484;
          unint64_t v165 = (unint64_t)operator new(4096 << v484, (std::align_val_t)8uLL);
          unsigned int v486 = *(_DWORD *)(a1 + 832);
          if (v486 >= *(_DWORD *)(a1 + 836)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)(a1 + 824) + 8 * v486) = v165;
          ++*(_DWORD *)(a1 + 832);
          *(void *)(a1 + 816) = v165 + v485;
        }
        else
        {
          unint64_t v165 = (v480 + 7) & 0xFFFFFFFFFFFFFFF8;
        }
        *(void *)(a1 + 808) = v165 + 48;
        *(void *)unint64_t v165 = 0;
        uint64_t v11 = v165 + 8;
        *(unsigned char *)(v165 + 16) = 64;
        *(_WORD *)(v165 + 17) = *(_WORD *)(v165 + 17) & 0xF000 | (v195 >> 1) | 0x540;
        v428 = &unk_1F2619BA8;
        goto LABEL_771;
      case 9:
        uint64_t v93 = sub_1CD077868(a1);
        if (!v93) {
          return 0;
        }
        uint64_t v94 = v93;
        uint64_t v95 = sub_1CD077868(a1);
        if (!v95) {
          return 0;
        }
        uint64_t v96 = v95;
        uint64_t v97 = sub_1CD077868(a1);
        if (!v97) {
          return 0;
        }
        uint64_t v99 = v97;
        unsigned int v100 = v5[3];
        int v101 = *(unsigned __int8 *)(a1 + 937);
        v543 = (char *)&v544 + 8;
        uint64_t v545 = v94;
        uint64_t v546 = v96;
        uint64_t v547 = v97;
        uint64_t v548 = (char)v100 >> 1;
        long long v544 = xmmword_1CFB2EB60;
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
        {
          uint64_t v97 = __cxa_guard_acquire(&qword_1EBCBE588);
          if (v97)
          {
            unint64_t v528 = llvm::hashing::detail::fixed_seed_override;
            if (!llvm::hashing::detail::fixed_seed_override) {
              unint64_t v528 = 0xFF51AFD7ED558CCDLL;
            }
            qword_1EBCBE580 = v528;
            __cxa_guard_release(&qword_1EBCBE588);
          }
        }
        uint64_t v102 = *((void *)&v544 + 1) - 0x3C5A37A36834CED9 * v547 - 0x6E18B188484051E8;
        uint64_t v103 = __ROR8__(v102 + v547, 52);
        uint64_t v104 = v102 + v545;
        uint64_t v105 = __ROR8__(v104, 7);
        uint64_t v106 = v104 + v546;
        uint64_t v107 = v105
             + __ROR8__(*((void *)&v544 + 1) - 0x3C5A37A36834CED9 * v547 - 0x6E18B188484051E8, 37)
             + v103
             + __ROR8__(v106, 31);
        unint64_t v108 = 0xC3A5C85C97CB3127 * (v546 + v545 + v546 + v547 + v548 + v107)
             - 0x651E95C4D06FBFB1
             * (v106
              + v547
              + __ROR8__(v545 + v546, 37)
              + __ROR8__(v545 + v546 + v548, 52)
              + __ROR8__(v546 + v545 + v546, 7)
              + __ROR8__(v546 + v545 + v546 + v547, 31));
        unint64_t v109 = ((0xC3A5C85C97CB3127 * (v108 ^ (v108 >> 47))) ^ qword_1EBCBE580) + v107;
        uint64_t v110 = *(void *)(a1 + 904)
             + 8 * ((797982799 * ((v109 >> 47) ^ v109)) & (*(_DWORD *)(a1 + 912) - 1));
        uint64_t v74 = *(unsigned int **)v110;
        *(void *)&long long v549 = v550;
        *((void *)&v549 + 1) = 0x2000000000;
        if (v74) {
          BOOL v111 = (v74 & 1) == 0;
        }
        else {
          BOOL v111 = 0;
        }
        if (!v111) {
          goto LABEL_287;
        }
        while (1)
        {
          LOBYTE(v97) = sub_1CD071418(v97, v74, (uint64_t)&v543, v98, (unsigned int *)&v549);
          if (v97) {
            break;
          }
          DWORD2(v549) = 0;
          uint64_t v74 = *(unsigned int **)v74;
          if (v74) {
            BOOL v112 = (v74 & 1) == 0;
          }
          else {
            BOOL v112 = 0;
          }
          if (!v112)
          {
            uint64_t v74 = 0;
            goto LABEL_285;
          }
        }
        uint64_t v110 = 0;
LABEL_285:
        if ((void *)v549 == v550)
        {
          if (v74) {
            goto LABEL_297;
          }
        }
        else
        {
          free((void *)v549);
          if (v74) {
            goto LABEL_297;
          }
        }
LABEL_287:
        if (!v101) {
          goto LABEL_777;
        }
        *(void *)(a1 + 888) += 48;
        uint64_t v201 = *(void *)(a1 + 808);
        if (((v201 + 7) & 0xFFFFFFFFFFFFFFF8) - v201 + 48 > *(void *)(a1 + 816) - v201)
        {
          unsigned int v420 = *(_DWORD *)(a1 + 832) >> 7;
          if (v420 >= 0x1E) {
            LOBYTE(v420) = 30;
          }
          uint64_t v421 = 4096 << v420;
          unint64_t v202 = (unint64_t)operator new(4096 << v420, (std::align_val_t)8uLL);
          unsigned int v422 = *(_DWORD *)(a1 + 832);
          if (v422 >= *(_DWORD *)(a1 + 836)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)(a1 + 824) + 8 * v422) = v202;
          ++*(_DWORD *)(a1 + 832);
          *(void *)(a1 + 816) = v202 + v421;
        }
        else
        {
          unint64_t v202 = (v201 + 7) & 0xFFFFFFFFFFFFFFF8;
        }
        *(void *)(a1 + 808) = v202 + 48;
        uint64_t v11 = v202 + 8;
        *(unsigned char *)(v202 + 16) = 53;
        *(_WORD *)(v202 + 17) = *(_WORD *)(v202 + 17) & 0xF000 | (v100 >> 1) | 0x540;
        *(void *)unint64_t v202 = 0;
        *(void *)(v202 + 8) = &unk_1F2619C00;
        *(void *)(v202 + 24) = v94;
        *(void *)(v202 + 32) = v96;
        *(void *)(v202 + 40) = v99;
        unsigned int v203 = *(_DWORD *)(a1 + 916) + 1;
        int v204 = *(_DWORD *)(a1 + 912);
        if (v203 > 2 * v204)
        {
          llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v204, (uint64_t)off_1F2644D00);
          *(void *)&long long v549 = v550;
          *((void *)&v549 + 1) = 0x2000000000;
          sub_1CD0714B4((unsigned int *)v202, (unsigned int *)&v549);
          uint64_t v110 = *(void *)(a1 + 904)
               + 8
               * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8((void *)v549, v549 + 4 * DWORD2(v549)));
          if ((void *)v549 != v550) {
            free((void *)v549);
          }
          unsigned int v203 = *(_DWORD *)(a1 + 916) + 1;
        }
        *(_DWORD *)(a1 + 916) = v203;
        uint64_t v205 = *(void *)v110;
        if (!*(void *)v110) {
          uint64_t v205 = v110 | 1;
        }
        *(void *)unint64_t v202 = v205;
        *(void *)uint64_t v110 = v202;
        goto LABEL_778;
      case 10:
        return v11;
      case 11:
        uint64_t v19 = sub_1CD06B2C4(a1);
        if (!v19) {
          return 0;
        }
        uint64_t v20 = v19;
        uint64_t v21 = sub_1CD077868(a1);
        if (!v21) {
          return 0;
        }
        uint64_t v22 = v21;
        unsigned int v23 = v5[3];
        int v538 = *(unsigned __int8 *)(a1 + 937);
        v543 = (char *)&v544 + 8;
        long long v544 = xmmword_1CFB2EB50;
        llvm::FoldingSetNodeID::AddString((unsigned int *)&v543, v8, v10 - v8);
        if (v544 >= DWORD1(v544)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((_DWORD *)v543 + v544) = v20;
        unsigned int v24 = v544 + 1;
        LODWORD(v544) = v24;
        if (v24 >= DWORD1(v544)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((_DWORD *)v543 + v24) = HIDWORD(v20);
        unsigned int v25 = v544 + 1;
        LODWORD(v544) = v25;
        if (v25 >= DWORD1(v544)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((_DWORD *)v543 + v25) = v22;
        unsigned int v26 = v544 + 1;
        LODWORD(v544) = v26;
        if (v26 >= DWORD1(v544)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((_DWORD *)v543 + v26) = HIDWORD(v22);
        unsigned int v27 = v544 + 1;
        LODWORD(v544) = v27;
        if (v27 >= DWORD1(v544)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((_DWORD *)v543 + v27) = (char)v23 >> 1;
        unsigned int v28 = v544 + 1;
        LODWORD(v544) = v28;
        if (v28 >= DWORD1(v544)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((_DWORD *)v543 + v28) = (char)v23 >> 31;
        LODWORD(v544) = v544 + 1;
        unint64_t v29 = sub_1CC13A6B8(v543, (uint64_t)v543 + 4 * v544);
        uint64_t v31 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v29);
        unsigned int v32 = *(unsigned int **)v31;
        *(void *)&long long v549 = v550;
        *((void *)&v549 + 1) = 0x2000000000;
        if (!v32 || (v32 & 1) != 0) {
          goto LABEL_684;
        }
        while (1)
        {
          LOBYTE(v29) = sub_1CD071418(v29, v32, (uint64_t)&v543, v30, (unsigned int *)&v549);
          if (v29) {
            break;
          }
          DWORD2(v549) = 0;
          unsigned int v32 = *(unsigned int **)v32;
          if (v32) {
            BOOL v33 = (v32 & 1) == 0;
          }
          else {
            BOOL v33 = 0;
          }
          if (!v33)
          {
            unsigned int v32 = 0;
            goto LABEL_241;
          }
        }
        uint64_t v31 = 0;
LABEL_241:
        if ((void *)v549 == v550)
        {
          if (v32) {
            goto LABEL_243;
          }
        }
        else
        {
          free((void *)v549);
          if (v32) {
            goto LABEL_243;
          }
        }
LABEL_684:
        if (!v538) {
          goto LABEL_691;
        }
        *(void *)(a1 + 888) += 56;
        uint64_t v454 = *(void *)(a1 + 808);
        if (((v454 + 7) & 0xFFFFFFFFFFFFFFF8) - v454 + 56 > *(void *)(a1 + 816) - v454)
        {
          unsigned int v460 = *(_DWORD *)(a1 + 832) >> 7;
          if (v460 >= 0x1E) {
            LOBYTE(v460) = 30;
          }
          uint64_t v461 = 4096 << v460;
          unint64_t v455 = (unint64_t)operator new(4096 << v460, (std::align_val_t)8uLL);
          unsigned int v462 = *(_DWORD *)(a1 + 832);
          if (v462 >= *(_DWORD *)(a1 + 836)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)(a1 + 824) + 8 * v462) = v455;
          ++*(_DWORD *)(a1 + 832);
          *(void *)(a1 + 816) = v455 + v461;
        }
        else
        {
          unint64_t v455 = (v454 + 7) & 0xFFFFFFFFFFFFFFF8;
        }
        *(void *)(a1 + 808) = v455 + 56;
        uint64_t v11 = v455 + 8;
        *(unsigned char *)(v455 + 16) = 57;
        *(_WORD *)(v455 + 17) = *(_WORD *)(v455 + 17) & 0xF000 | (v23 >> 1) | 0x540;
        *(void *)unint64_t v455 = 0;
        *(void *)(v455 + 8) = &unk_1F2619C58;
        *(void *)(v455 + 24) = v8;
        *(void *)(v455 + 32) = v10;
        *(void *)(v455 + 40) = v20;
        *(void *)(v455 + 48) = v22;
        unsigned int v456 = *(_DWORD *)(a1 + 916) + 1;
        int v457 = *(_DWORD *)(a1 + 912);
        if (v456 > 2 * v457)
        {
          llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v457, (uint64_t)off_1F2644D00);
          *(void *)&long long v549 = v550;
          *((void *)&v549 + 1) = 0x2000000000;
          sub_1CD0714B4((unsigned int *)v455, (unsigned int *)&v549);
          uint64_t v31 = *(void *)(a1 + 904)
              + 8
              * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8((void *)v549, v549 + 4 * DWORD2(v549)));
          if ((void *)v549 != v550) {
            free((void *)v549);
          }
          unsigned int v456 = *(_DWORD *)(a1 + 916) + 1;
        }
        *(_DWORD *)(a1 + 916) = v456;
        uint64_t v458 = *(void *)v31;
        if (!*(void *)v31) {
          uint64_t v458 = v31 | 1;
        }
        *(void *)unint64_t v455 = v458;
        *(void *)uint64_t v31 = v455;
        goto LABEL_692;
      case 12:
        if (v5[3]) {
          uint64_t v48 = sub_1CD06B2C4(a1);
        }
        else {
          uint64_t v48 = sub_1CD077868(a1);
        }
        uint64_t v130 = v48;
        if (!v48) {
          return 0;
        }
        unsigned int v131 = v5[3];
        int v132 = *(unsigned __int8 *)(a1 + 937);
        v543 = (char *)&v544 + 8;
        *(void *)&long long v544 = 0x2000000000;
        sub_1CD0758F0((unsigned int *)&v543, 56, v8, v10, v48, (char)v131 >> 1);
        unint64_t v133 = sub_1CC13A6B8(v543, (uint64_t)v543 + 4 * v544);
        uint64_t v73 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v133);
        uint64_t v74 = *(unsigned int **)v73;
        *(void *)&long long v549 = v550;
        *((void *)&v549 + 1) = 0x2000000000;
        if (v74) {
          BOOL v135 = (v74 & 1) == 0;
        }
        else {
          BOOL v135 = 0;
        }
        if (!v135) {
          goto LABEL_214;
        }
        while (1)
        {
          LOBYTE(v133) = sub_1CD071418(v133, v74, (uint64_t)&v543, v134, (unsigned int *)&v549);
          if (v133) {
            break;
          }
          DWORD2(v549) = 0;
          uint64_t v74 = *(unsigned int **)v74;
          if (v74) {
            BOOL v136 = (v74 & 1) == 0;
          }
          else {
            BOOL v136 = 0;
          }
          if (!v136)
          {
            uint64_t v74 = 0;
            goto LABEL_212;
          }
        }
        uint64_t v73 = 0;
LABEL_212:
        if ((void *)v549 == v550)
        {
          if (v74) {
            goto LABEL_297;
          }
        }
        else
        {
          free((void *)v549);
          if (v74) {
            goto LABEL_297;
          }
        }
LABEL_214:
        if (!v132) {
          goto LABEL_777;
        }
        *(void *)(a1 + 888) += 64;
        uint64_t v164 = *(void *)(a1 + 808);
        if (((v164 + 7) & 0xFFFFFFFFFFFFFFF8) - v164 + 64 > *(void *)(a1 + 816) - v164)
        {
          unsigned int v367 = *(_DWORD *)(a1 + 832) >> 7;
          if (v367 >= 0x1E) {
            LOBYTE(v367) = 30;
          }
          uint64_t v368 = 4096 << v367;
          unint64_t v165 = (unint64_t)operator new(4096 << v367, (std::align_val_t)8uLL);
          unsigned int v369 = *(_DWORD *)(a1 + 832);
          if (v369 >= *(_DWORD *)(a1 + 836)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)(a1 + 824) + 8 * v369) = v165;
          ++*(_DWORD *)(a1 + 832);
          *(void *)(a1 + 816) = v165 + v368;
        }
        else
        {
          unint64_t v165 = (v164 + 7) & 0xFFFFFFFFFFFFFFF8;
        }
        *(void *)(a1 + 808) = v165 + 64;
        uint64_t v11 = v165 + 8;
        *(unsigned char *)(v165 + 16) = 56;
        *(_WORD *)(v165 + 17) = *(_WORD *)(v165 + 17) & 0xF000 | (v131 >> 1) | 0x540;
        *(void *)unint64_t v165 = 0;
        *(void *)(v165 + 8) = &unk_1F2619CB0;
        *(void *)(v165 + 24) = v8;
        *(void *)(v165 + 32) = v10;
        *(void *)(v165 + 48) = 0;
        *(void *)(v165 + 56) = 0;
        goto LABEL_772;
      default:
        goto LABEL_15;
    }
  }
  uint64_t v15 = *(unsigned __int8 **)a1;
  unint64_t v16 = *(unsigned __int8 **)(a1 + 8);
  unint64_t v17 = (unint64_t)&v16[-*(void *)a1];
  if (v17 < 2) {
    return 0;
  }
  int v18 = *v15;
  if (v18 == 76)
  {
    return sub_1CD07EF14(a1);
  }
  if (v16 != v15 && v18 == 84)
  {
    return sub_1CD07D120(a1);
  }
  if (v16 != v15 && v18 == 102)
  {
    unsigned int v118 = (char *)(v15 + 1);
    int v119 = v15[1];
    if (v119 == 112)
    {
LABEL_319:
      return sub_1CD08057C(a1);
    }
    if (v119 == 76)
    {
      if (v17 < 3)
      {
        uint64_t v120 = 0;
LABEL_313:
        if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v120 + 60) & 0x400) == 0) {
          goto LABEL_314;
        }
        goto LABEL_319;
      }
      if (((char)v15[2] & 0x80000000) == 0)
      {
        uint64_t v120 = v15[2];
        goto LABEL_313;
      }
    }
LABEL_314:
    *(void *)a1 = v118;
    if (v16 == (unsigned __int8 *)v118) {
      return 0;
    }
    uint64_t v11 = 0;
    int v222 = *v118;
    if (v222 > 107)
    {
      if (v222 == 108)
      {
        int v224 = 0;
        unsigned int v223 = 1;
      }
      else
      {
        if (v222 != 114) {
          return v11;
        }
        unsigned int v223 = 0;
        int v224 = 0;
      }
    }
    else
    {
      if (v222 == 76)
      {
        unsigned int v223 = 1;
      }
      else
      {
        if (v222 != 82) {
          return v11;
        }
        unsigned int v223 = 0;
      }
      int v224 = 1;
    }
    *(void *)a1 = v15 + 2;
    unsigned int v278 = sub_1CD07E754((unsigned __int8 **)a1);
    uint64_t v11 = (uint64_t)v278;
    if (!v278) {
      return v11;
    }
    if (v278[2] != 2) {
      return 0;
    }
    uint64_t v279 = sub_1CD077868(a1);
    if (!v279) {
      return 0;
    }
    uint64_t v280 = v279;
    if (v224)
    {
      uint64_t v281 = sub_1CD077868(a1);
      if (!v281) {
        return 0;
      }
    }
    else
    {
      uint64_t v281 = 0;
    }
    BOOL v308 = v281 != 0;
    if ((v223 & v308) != 0) {
      uint64_t v309 = v280;
    }
    else {
      uint64_t v309 = v281;
    }
    if ((v223 & v308) != 0) {
      uint64_t v310 = v281;
    }
    else {
      uint64_t v310 = v280;
    }
    unsigned int v311 = *(const char **)(v11 + 8);
    size_t v312 = strlen(v311);
    unsigned int v313 = (unsigned __int8 *)v311;
    if (*(unsigned __int8 *)(v11 + 2) <= 0xAu)
    {
      uint64_t v314 = 8;
      if (v312 < 8) {
        uint64_t v314 = v312;
      }
      unsigned int v313 = (unsigned __int8 *)&v311[v314];
      if (v312 >= 9 && *v313 == 32) {
        ++v313;
      }
    }
    unsigned int v315 = &v311[v312];
    int v540 = *(unsigned __int8 *)(a1 + 937);
    v543 = (char *)&v544 + 8;
    uint64_t v545 = v223;
    long long v544 = xmmword_1CFB2EBF0;
    llvm::FoldingSetNodeID::AddString((unsigned int *)&v543, v313, v311 + v312 - v313);
    if (v544 >= DWORD1(v544)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((_DWORD *)v543 + v544) = v310;
    unsigned int v316 = v544 + 1;
    LODWORD(v544) = v316;
    if (v316 >= DWORD1(v544)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((_DWORD *)v543 + v316) = HIDWORD(v310);
    unsigned int v317 = v544 + 1;
    LODWORD(v544) = v317;
    if (v317 >= DWORD1(v544)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((_DWORD *)v543 + v317) = v309;
    unsigned int v318 = v544 + 1;
    LODWORD(v544) = v318;
    if (v318 >= DWORD1(v544)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((_DWORD *)v543 + v318) = HIDWORD(v309);
    LODWORD(v544) = v544 + 1;
    unint64_t v319 = sub_1CC13A6B8(v543, (uint64_t)v543 + 4 * v544);
    uint64_t v321 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v319);
    uint64_t v220 = *(unsigned int **)v321;
    *(void *)&long long v549 = v550;
    *((void *)&v549 + 1) = 0x2000000000;
    if (v220 && (v220 & 1) == 0)
    {
      while (1)
      {
        LOBYTE(v319) = sub_1CD071418(v319, v220, (uint64_t)&v543, v320, (unsigned int *)&v549);
        if (v319) {
          break;
        }
        DWORD2(v549) = 0;
        uint64_t v220 = *(unsigned int **)v220;
        if (v220) {
          BOOL v322 = (v220 & 1) == 0;
        }
        else {
          BOOL v322 = 0;
        }
        if (!v322)
        {
          uint64_t v220 = 0;
          goto LABEL_460;
        }
      }
      uint64_t v321 = 0;
LABEL_460:
      if ((void *)v549 == v550)
      {
        if (!v220) {
          goto LABEL_462;
        }
LABEL_482:
        int v334 = 0;
        uint64_t v11 = (uint64_t)(v220 + 2);
        goto LABEL_863;
      }
      free((void *)v549);
      if (v220) {
        goto LABEL_482;
      }
    }
LABEL_462:
    if (v540)
    {
      *(void *)(a1 + 888) += 64;
      uint64_t v323 = *(void *)(a1 + 808);
      if (((v323 + 7) & 0xFFFFFFFFFFFFFFF8) - v323 + 64 > *(void *)(a1 + 816) - v323)
      {
        unsigned int v451 = *(_DWORD *)(a1 + 832) >> 7;
        if (v451 >= 0x1E) {
          LOBYTE(v451) = 30;
        }
        uint64_t v452 = 4096 << v451;
        unint64_t v324 = (unint64_t)operator new(4096 << v451, (std::align_val_t)8uLL);
        unsigned int v453 = *(_DWORD *)(a1 + 832);
        if (v453 >= *(_DWORD *)(a1 + 836)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 824) + 8 * v453) = v324;
        ++*(_DWORD *)(a1 + 832);
        *(void *)(a1 + 816) = v324 + v452;
      }
      else
      {
        unint64_t v324 = (v323 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(a1 + 808) = v324 + 64;
      uint64_t v11 = v324 + 8;
      *(unsigned char *)(v324 + 16) = 67;
      *(_WORD *)(v324 + 17) = *(_WORD *)(v324 + 17) & 0xF000 | 0x540;
      *(void *)unint64_t v324 = 0;
      *(void *)(v324 + 8) = &unk_1F261A288;
      *(void *)(v324 + 24) = v310;
      *(void *)(v324 + 32) = v309;
      *(void *)(v324 + 40) = v313;
      *(void *)(v324 + 48) = v315;
      *(unsigned char *)(v324 + 56) = v223;
      unsigned int v325 = *(_DWORD *)(a1 + 916) + 1;
      int v326 = *(_DWORD *)(a1 + 912);
      if (v325 > 2 * v326)
      {
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v326, (uint64_t)off_1F2644D00);
        *(void *)&long long v549 = v550;
        *((void *)&v549 + 1) = 0x2000000000;
        sub_1CD0714B4((unsigned int *)v324, (unsigned int *)&v549);
        uint64_t v321 = *(void *)(a1 + 904)
             + 8
             * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8((void *)v549, v549 + 4 * DWORD2(v549)));
        if ((void *)v549 != v550) {
          free((void *)v549);
        }
        unsigned int v325 = *(_DWORD *)(a1 + 916) + 1;
      }
      *(_DWORD *)(a1 + 916) = v325;
      uint64_t v327 = *(void *)v321;
      if (!*(void *)v321) {
        uint64_t v327 = v321 | 1;
      }
      *(void *)unint64_t v324 = v327;
      *(void *)uint64_t v321 = v324;
      goto LABEL_862;
    }
LABEL_861:
    uint64_t v11 = 0;
LABEL_862:
    int v334 = 1;
LABEL_863:
    if (v543 != (char *)&v544 + 8) {
      free(v543);
    }
    if (!v334) {
      goto LABEL_866;
    }
    goto LABEL_782;
  }
  if (!strncmp("il", *(const char **)a1, 2uLL))
  {
    unsigned int v185 = v15 + 2;
    *(void *)a1 = v15 + 2;
    uint64_t v186 = (uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 3;
    while (v185 == v16 || *v185 != 69)
    {
      uint64_t v187 = sub_1CD0806CC(a1);
      if (!v187) {
        return 0;
      }
      uint64_t v188 = v187;
      unsigned int v189 = *(uint64_t **)(a1 + 24);
      if (v189 == *(uint64_t **)(a1 + 32))
      {
        sub_1CD5F0ACC(a1 + 16, ((uint64_t)v189 - *(void *)(a1 + 16)) >> 2);
        unsigned int v189 = *(uint64_t **)(a1 + 24);
      }
      *(void *)(a1 + 24) = v189 + 1;
      *unsigned int v189 = v188;
      unsigned int v185 = *(unsigned __int8 **)a1;
      unint64_t v16 = *(unsigned __int8 **)(a1 + 8);
    }
    *(void *)a1 = v185 + 1;
    unsigned int v235 = *(unsigned char **)(a1 + 24);
    uint64_t v236 = (unsigned char *)(*(void *)(a1 + 16) + 8 * v186);
    uint64_t v237 = (uint64_t *)sub_1CB906F34((uint64_t *)(a1 + 808), v235 - v236, 3);
    uint64_t v238 = v237;
    uint64_t v239 = v235 - v236;
    if (v235 != v236) {
      memmove(v237, v236, v235 - v236);
    }
    uint64_t v240 = v239 >> 3;
    *(void *)(a1 + 24) = *(void *)(a1 + 16) + 8 * v186;
    int v241 = *(unsigned __int8 *)(a1 + 937);
    v543 = (char *)&v544 + 8;
    uint64_t v545 = 0;
    uint64_t v546 = v239 >> 3;
    long long v544 = xmmword_1CFB2EBE0;
    if (v235 == v236)
    {
      uint64_t v243 = 6;
      unsigned int v277 = (void *)&v544 + 1;
    }
    else
    {
      uint64_t v242 = 8 * v240;
      LODWORD(v243) = 6;
      unsigned int v244 = v238;
      do
      {
        uint64_t v245 = *v244;
        if (v243 >= DWORD1(v544)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((_DWORD *)v543 + v243) = v245;
        unsigned int v246 = v544 + 1;
        LODWORD(v544) = v246;
        if (v246 >= DWORD1(v544)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((_DWORD *)v543 + v246) = HIDWORD(v245);
        uint64_t v243 = (v544 + 1);
        LODWORD(v544) = v544 + 1;
        ++v244;
        v242 -= 8;
      }
      while (v242);
      unsigned int v277 = v543;
    }
    unint64_t v284 = sub_1CC13A6B8(v277, (uint64_t)v277 + 4 * v243);
    uint64_t v286 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v284);
    uint64_t v220 = *(unsigned int **)v286;
    *(void *)&long long v549 = v550;
    *((void *)&v549 + 1) = 0x2000000000;
    if (v220) {
      BOOL v287 = (v220 & 1) == 0;
    }
    else {
      BOOL v287 = 0;
    }
    if (v287)
    {
      while (1)
      {
        LOBYTE(v284) = sub_1CD071418(v284, v220, (uint64_t)&v543, v285, (unsigned int *)&v549);
        if (v284) {
          break;
        }
        DWORD2(v549) = 0;
        uint64_t v220 = *(unsigned int **)v220;
        if (v220) {
          BOOL v288 = (v220 & 1) == 0;
        }
        else {
          BOOL v288 = 0;
        }
        if (!v288)
        {
          uint64_t v220 = 0;
          goto LABEL_400;
        }
      }
      uint64_t v286 = 0;
LABEL_400:
      if ((void *)v549 == v550)
      {
        if (v220) {
          goto LABEL_482;
        }
      }
      else
      {
        free((void *)v549);
        if (v220) {
          goto LABEL_482;
        }
      }
    }
    if (v241)
    {
      *(void *)(a1 + 888) += 48;
      uint64_t v289 = *(void *)(a1 + 808);
      if (((v289 + 7) & 0xFFFFFFFFFFFFFFF8) - v289 + 48 > *(void *)(a1 + 816) - v289)
      {
        unsigned int v436 = *(_DWORD *)(a1 + 832) >> 7;
        if (v436 >= 0x1E) {
          LOBYTE(v436) = 30;
        }
        uint64_t v437 = 4096 << v436;
        unint64_t v290 = (unint64_t)operator new(4096 << v436, (std::align_val_t)8uLL);
        unsigned int v438 = *(_DWORD *)(a1 + 832);
        if (v438 >= *(_DWORD *)(a1 + 836)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 824) + 8 * v438) = v290;
        ++*(_DWORD *)(a1 + 832);
        *(void *)(a1 + 816) = v290 + v437;
      }
      else
      {
        unint64_t v290 = (v289 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(a1 + 808) = v290 + 48;
      uint64_t v11 = v290 + 8;
      *(unsigned char *)(v290 + 16) = 66;
      *(_WORD *)(v290 + 17) = *(_WORD *)(v290 + 17) & 0xF000 | 0x540;
      *(void *)unint64_t v290 = 0;
      *(void *)(v290 + 8) = &unk_1F261A3E8;
      *(void *)(v290 + 24) = 0;
      *(void *)(v290 + 32) = v238;
      *(void *)(v290 + 40) = v240;
      unsigned int v291 = *(_DWORD *)(a1 + 916) + 1;
      int v292 = *(_DWORD *)(a1 + 912);
      if (v291 > 2 * v292)
      {
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v292, (uint64_t)off_1F2644D00);
        *(void *)&long long v549 = v550;
        *((void *)&v549 + 1) = 0x2000000000;
        sub_1CD0714B4((unsigned int *)v290, (unsigned int *)&v549);
        uint64_t v286 = *(void *)(a1 + 904)
             + 8
             * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8((void *)v549, v549 + 4 * DWORD2(v549)));
        if ((void *)v549 != v550) {
          free((void *)v549);
        }
        unsigned int v291 = *(_DWORD *)(a1 + 916) + 1;
      }
      *(_DWORD *)(a1 + 916) = v291;
      uint64_t v293 = *(void *)v286;
      if (!*(void *)v286) {
        uint64_t v293 = v286 | 1;
      }
      *(void *)unint64_t v290 = v293;
      *(void *)uint64_t v286 = v290;
      goto LABEL_862;
    }
    goto LABEL_861;
  }
  if (!strncmp("mc", (const char *)v15, 2uLL))
  {
    *(void *)a1 = v15 + 2;
    uint64_t v206 = sub_1CD06B2C4(a1);
    if (!v206) {
      return 0;
    }
    uint64_t v207 = v206;
    uint64_t v208 = sub_1CD077868(a1);
    if (!v208) {
      return 0;
    }
    uint64_t v209 = v208;
    unsigned int v210 = (unsigned __int8 *)sub_1CC6B5BE0((char **)a1, 1);
    unsigned int v212 = *(unsigned __int8 **)a1;
    if (*(void *)a1 == *(void *)(a1 + 8) || *v212 != 69) {
      return 0;
    }
    unsigned int v213 = v210;
    uint64_t v214 = v211;
    *(void *)a1 = v212 + 1;
    int v215 = *(unsigned __int8 *)(a1 + 937);
    v543 = (char *)&v544 + 8;
    uint64_t v545 = v207;
    uint64_t v546 = v209;
    long long v544 = xmmword_1CFB2EBD0;
    llvm::FoldingSetNodeID::AddString((unsigned int *)&v543, v210, v211 - v210);
    if (v544 >= DWORD1(v544)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((_DWORD *)v543 + v544) = 2;
    unsigned int v216 = v544 + 1;
    LODWORD(v544) = v216;
    if (v216 >= DWORD1(v544)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((_DWORD *)v543 + v216) = 0;
    LODWORD(v544) = v544 + 1;
    unint64_t v217 = sub_1CC13A6B8(v543, (uint64_t)v543 + 4 * v544);
    uint64_t v219 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v217);
    uint64_t v220 = *(unsigned int **)v219;
    *(void *)&long long v549 = v550;
    *((void *)&v549 + 1) = 0x2000000000;
    if (v220 && (v220 & 1) == 0)
    {
      while (1)
      {
        LOBYTE(v217) = sub_1CD071418(v217, v220, (uint64_t)&v543, v218, (unsigned int *)&v549);
        if (v217) {
          break;
        }
        DWORD2(v549) = 0;
        uint64_t v220 = *(unsigned int **)v220;
        if (v220) {
          BOOL v221 = (v220 & 1) == 0;
        }
        else {
          BOOL v221 = 0;
        }
        if (!v221)
        {
          uint64_t v220 = 0;
          goto LABEL_480;
        }
      }
      uint64_t v219 = 0;
LABEL_480:
      if ((void *)v549 == v550)
      {
        if (v220) {
          goto LABEL_482;
        }
      }
      else
      {
        free((void *)v549);
        if (v220) {
          goto LABEL_482;
        }
      }
    }
    if (v215)
    {
      *(void *)(a1 + 888) += 56;
      uint64_t v507 = *(void *)(a1 + 808);
      if (((v507 + 7) & 0xFFFFFFFFFFFFFFF8) - v507 + 56 > *(void *)(a1 + 816) - v507)
      {
        unsigned int v514 = *(_DWORD *)(a1 + 832) >> 7;
        if (v514 >= 0x1E) {
          LOBYTE(v514) = 30;
        }
        uint64_t v515 = 4096 << v514;
        unint64_t v508 = (unint64_t)operator new(4096 << v514, (std::align_val_t)8uLL);
        unsigned int v516 = *(_DWORD *)(a1 + 832);
        if (v516 >= *(_DWORD *)(a1 + 836)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 824) + 8 * v516) = v508;
        ++*(_DWORD *)(a1 + 832);
        *(void *)(a1 + 816) = v508 + v515;
      }
      else
      {
        unint64_t v508 = (v507 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(a1 + 808) = v508 + 56;
      uint64_t v11 = v508 + 8;
      *(unsigned char *)(v508 + 16) = 65;
      *(_WORD *)(v508 + 17) = *(_WORD *)(v508 + 17) & 0xF000 | 0x542;
      *(void *)unint64_t v508 = 0;
      *(void *)(v508 + 8) = &unk_1F261A440;
      *(void *)(v508 + 24) = v207;
      *(void *)(v508 + 32) = v209;
      *(void *)(v508 + 40) = v213;
      *(void *)(v508 + 48) = v214;
      unsigned int v509 = *(_DWORD *)(a1 + 916) + 1;
      int v510 = *(_DWORD *)(a1 + 912);
      if (v509 > 2 * v510)
      {
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v510, (uint64_t)off_1F2644D00);
        *(void *)&long long v549 = v550;
        *((void *)&v549 + 1) = 0x2000000000;
        sub_1CD0714B4((unsigned int *)v508, (unsigned int *)&v549);
        uint64_t v219 = *(void *)(a1 + 904)
             + 8
             * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8((void *)v549, v549 + 4 * DWORD2(v549)));
        if ((void *)v549 != v550) {
          free((void *)v549);
        }
        unsigned int v509 = *(_DWORD *)(a1 + 916) + 1;
      }
      *(_DWORD *)(a1 + 916) = v509;
      uint64_t v511 = *(void *)v219;
      if (!*(void *)v219) {
        uint64_t v511 = v219 | 1;
      }
      *(void *)unint64_t v508 = v511;
      *(void *)uint64_t v219 = v508;
      goto LABEL_862;
    }
    goto LABEL_861;
  }
  if (!strncmp("nx", (const char *)v15, 2uLL))
  {
    *(void *)a1 = v15 + 2;
    uint64_t v225 = sub_1CD077868(a1);
    if (!v225) {
      return 0;
    }
    uint64_t v226 = v225;
    int v227 = *(unsigned __int8 *)(a1 + 937);
    v543 = (char *)&v544 + 8;
    long long v544 = xmmword_1CFB2EBC0;
    llvm::FoldingSetNodeID::AddString((unsigned int *)&v543, "noexcept ", 9u);
    if (v544 >= DWORD1(v544)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((_DWORD *)v543 + v544) = v226;
    unsigned int v228 = v544 + 1;
    LODWORD(v544) = v228;
    if (v228 >= DWORD1(v544)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((_DWORD *)v543 + v228) = HIDWORD(v226);
    unsigned int v229 = v544 + 1;
    LODWORD(v544) = v229;
    if (v229 >= DWORD1(v544)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((_DWORD *)v543 + v229) = 2;
    unsigned int v230 = v544 + 1;
    LODWORD(v544) = v230;
    if (v230 >= DWORD1(v544)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((_DWORD *)v543 + v230) = 0;
    LODWORD(v544) = v544 + 1;
    unint64_t v231 = sub_1CC13A6B8(v543, (uint64_t)v543 + 4 * v544);
    uint64_t v233 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v231);
    uint64_t v220 = *(unsigned int **)v233;
    *(void *)&long long v549 = v550;
    *((void *)&v549 + 1) = 0x2000000000;
    if (v220 && (v220 & 1) == 0)
    {
      while (1)
      {
        LOBYTE(v231) = sub_1CD071418(v231, v220, (uint64_t)&v543, v232, (unsigned int *)&v549);
        if (v231) {
          break;
        }
        DWORD2(v549) = 0;
        uint64_t v220 = *(unsigned int **)v220;
        if (v220) {
          BOOL v234 = (v220 & 1) == 0;
        }
        else {
          BOOL v234 = 0;
        }
        if (!v234)
        {
          uint64_t v220 = 0;
          goto LABEL_410;
        }
      }
      uint64_t v233 = 0;
LABEL_410:
      if ((void *)v549 == v550)
      {
        if (v220) {
          goto LABEL_482;
        }
      }
      else
      {
        free((void *)v549);
        if (v220) {
          goto LABEL_482;
        }
      }
    }
    if (v227)
    {
      *(void *)(a1 + 888) += 64;
      uint64_t v294 = *(void *)(a1 + 808);
      if (((v294 + 7) & 0xFFFFFFFFFFFFFFF8) - v294 + 64 > *(void *)(a1 + 816) - v294)
      {
        unsigned int v448 = *(_DWORD *)(a1 + 832) >> 7;
        if (v448 >= 0x1E) {
          LOBYTE(v448) = 30;
        }
        uint64_t v449 = 4096 << v448;
        unint64_t v295 = (unint64_t)operator new(4096 << v448, (std::align_val_t)8uLL);
        unsigned int v450 = *(_DWORD *)(a1 + 832);
        if (v450 >= *(_DWORD *)(a1 + 836)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 824) + 8 * v450) = v295;
        ++*(_DWORD *)(a1 + 832);
        *(void *)(a1 + 816) = v295 + v449;
      }
      else
      {
        unint64_t v295 = (v294 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(a1 + 808) = v295 + 64;
      uint64_t v11 = v295 + 8;
      *(unsigned char *)(v295 + 16) = 56;
      *(_WORD *)(v295 + 17) = *(_WORD *)(v295 + 17) & 0xF000 | 0x542;
      *(void *)unint64_t v295 = 0;
      *(void *)(v295 + 8) = &unk_1F2619CB0;
      *(void *)(v295 + 24) = "noexcept ";
      *(void *)(v295 + 32) = "";
      *(void *)(v295 + 48) = 0;
      *(void *)(v295 + 56) = 0;
      *(void *)(v295 + 40) = v226;
      unsigned int v296 = *(_DWORD *)(a1 + 916) + 1;
      int v297 = *(_DWORD *)(a1 + 912);
      if (v296 > 2 * v297)
      {
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v297, (uint64_t)off_1F2644D00);
        *(void *)&long long v549 = v550;
        *((void *)&v549 + 1) = 0x2000000000;
        sub_1CD0714B4((unsigned int *)v295, (unsigned int *)&v549);
        uint64_t v233 = *(void *)(a1 + 904)
             + 8
             * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8((void *)v549, v549 + 4 * DWORD2(v549)));
        if ((void *)v549 != v550) {
          free((void *)v549);
        }
        unsigned int v296 = *(_DWORD *)(a1 + 916) + 1;
      }
      *(_DWORD *)(a1 + 916) = v296;
      uint64_t v298 = *(void *)v233;
      if (!*(void *)v233) {
        uint64_t v298 = v233 | 1;
      }
      *(void *)unint64_t v295 = v298;
      *(void *)uint64_t v233 = v295;
      goto LABEL_862;
    }
    goto LABEL_861;
  }
  if (!strncmp("so", (const char *)v15, 2uLL))
  {
    *(void *)a1 = v15 + 2;
    uint64_t v260 = sub_1CD06B2C4(a1);
    if (!v260) {
      return 0;
    }
    uint64_t v261 = v260;
    uint64_t v262 = sub_1CD077868(a1);
    if (!v262) {
      return 0;
    }
    uint64_t v263 = v262;
    uint64_t v264 = sub_1CC6B5BE0((char **)a1, 1);
    int v266 = *(unsigned __int8 **)a1;
    uint64_t v267 = *(unsigned __int8 **)(a1 + 8);
    if (*(unsigned __int8 **)a1 == v267) {
      return 0;
    }
    unsigned int v268 = (unsigned __int8 *)v264;
    uint64_t v269 = v265;
    uint64_t v270 = *(void *)(a1 + 16);
    uint64_t v271 = *(void *)(a1 + 24);
    while (1)
    {
      int v272 = *v266;
      if (v272 != 95) {
        break;
      }
      *(void *)a1 = v266 + 1;
      *(void *)&long long v549 = sub_1CC6B5BE0((char **)a1, 0);
      *((void *)&v549 + 1) = v273;
      uint64_t v274 = sub_1CD077500(a1, &v549);
      if (v274)
      {
        uint64_t v275 = v274;
        unsigned int v276 = *(uint64_t **)(a1 + 24);
        if (v276 == *(uint64_t **)(a1 + 32))
        {
          sub_1CD5F0ACC(a1 + 16, ((uint64_t)v276 - *(void *)(a1 + 16)) >> 2);
          unsigned int v276 = *(uint64_t **)(a1 + 24);
        }
        *(void *)(a1 + 24) = v276 + 1;
        uint64_t *v276 = v275;
        int v266 = *(unsigned __int8 **)a1;
        uint64_t v267 = *(unsigned __int8 **)(a1 + 8);
        if (*(unsigned __int8 **)a1 != v267) {
          continue;
        }
      }
      return 0;
    }
    if (v272 == 112) {
      *(void *)a1 = ++v266;
    }
    if (v266 == v267) {
      return 0;
    }
    BOOL v537 = v272 == 112;
    uint64_t v541 = v269;
    if (*v266 != 69) {
      return 0;
    }
    uint64_t v335 = (v271 - v270) >> 3;
    *(void *)a1 = v266 + 1;
    unsigned int v336 = *(unsigned char **)(a1 + 24);
    unsigned int v337 = (unsigned char *)(*(void *)(a1 + 16) + 8 * v335);
    unsigned int v338 = (uint64_t *)sub_1CB906F34((uint64_t *)(a1 + 808), v336 - v337, 3);
    uint64_t v339 = v338;
    if (v336 != v337) {
      memmove(v338, v337, v336 - v337);
    }
    uint64_t v340 = (v336 - v337) >> 3;
    *(void *)(a1 + 24) = *(void *)(a1 + 16) + 8 * v335;
    int v341 = *(unsigned __int8 *)(a1 + 937);
    v543 = (char *)&v544 + 8;
    uint64_t v545 = v261;
    uint64_t v546 = v263;
    long long v544 = xmmword_1CFB2EBB0;
    llvm::FoldingSetNodeID::AddString((unsigned int *)&v543, v268, v541 - v268);
    if (v544 >= DWORD1(v544)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((_DWORD *)v543 + v544) = v340;
    unsigned int v342 = v544 + 1;
    LODWORD(v544) = v342;
    if (v342 >= DWORD1(v544)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((_DWORD *)v543 + v342) = HIDWORD(v340);
    unsigned int v343 = v544 + 1;
    LODWORD(v544) = v544 + 1;
    uint64_t v535 = (v336 - v337) >> 3;
    if (v336 != v337)
    {
      uint64_t v344 = 8 * v340;
      unsigned int v345 = v339;
      do
      {
        uint64_t v346 = *v345;
        if (v343 >= DWORD1(v544)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((_DWORD *)v543 + v343) = v346;
        unsigned int v347 = v544 + 1;
        LODWORD(v544) = v347;
        if (v347 >= DWORD1(v544)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((_DWORD *)v543 + v347) = HIDWORD(v346);
        unsigned int v343 = v544 + 1;
        LODWORD(v544) = v544 + 1;
        ++v345;
        v344 -= 8;
      }
      while (v344);
    }
    if (v343 >= DWORD1(v544)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((_DWORD *)v543 + v343) = v272 == 112;
    unsigned int v382 = v544 + 1;
    LODWORD(v544) = v382;
    if (v382 >= DWORD1(v544)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((_DWORD *)v543 + v382) = 0;
    LODWORD(v544) = v544 + 1;
    unint64_t v383 = sub_1CC13A6B8(v543, (uint64_t)v543 + 4 * v544);
    uint64_t v385 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v383);
    uint64_t v74 = *(unsigned int **)v385;
    *(void *)&long long v549 = v550;
    *((void *)&v549 + 1) = 0x2000000000;
    if (v74) {
      BOOL v386 = (v74 & 1) == 0;
    }
    else {
      BOOL v386 = 0;
    }
    if (v386)
    {
      while (1)
      {
        LOBYTE(v383) = sub_1CD071418(v383, v74, (uint64_t)&v543, v384, (unsigned int *)&v549);
        if (v383) {
          break;
        }
        DWORD2(v549) = 0;
        uint64_t v74 = *(unsigned int **)v74;
        if (v74) {
          BOOL v387 = (v74 & 1) == 0;
        }
        else {
          BOOL v387 = 0;
        }
        if (!v387)
        {
          uint64_t v74 = 0;
          goto LABEL_596;
        }
      }
      uint64_t v385 = 0;
LABEL_596:
      if ((void *)v549 == v550)
      {
        if (v74) {
          goto LABEL_297;
        }
      }
      else
      {
        free((void *)v549);
        if (v74) {
          goto LABEL_297;
        }
      }
    }
    if (v341)
    {
      *(void *)(a1 + 888) += 80;
      uint64_t v415 = *(void *)(a1 + 808);
      if (((v415 + 7) & 0xFFFFFFFFFFFFFFF8) - v415 + 80 > *(void *)(a1 + 816) - v415)
      {
        unsigned int v498 = *(_DWORD *)(a1 + 832) >> 7;
        if (v498 >= 0x1E) {
          LOBYTE(v498) = 30;
        }
        uint64_t v499 = 4096 << v498;
        unint64_t v416 = (unint64_t)operator new(4096 << v498, (std::align_val_t)8uLL);
        unsigned int v500 = *(_DWORD *)(a1 + 832);
        if (v500 >= *(_DWORD *)(a1 + 836)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 824) + 8 * v500) = v416;
        ++*(_DWORD *)(a1 + 832);
        *(void *)(a1 + 816) = v416 + v499;
      }
      else
      {
        unint64_t v416 = (v415 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(a1 + 808) = v416 + 80;
      uint64_t v11 = v416 + 8;
      *(unsigned char *)(v416 + 16) = 55;
      *(_WORD *)(v416 + 17) = *(_WORD *)(v416 + 17) & 0xF000 | 0x540;
      *(void *)unint64_t v416 = 0;
      *(void *)(v416 + 8) = &unk_1F261A498;
      *(void *)(v416 + 24) = v261;
      *(void *)(v416 + 32) = v263;
      *(void *)(v416 + 40) = v268;
      *(void *)(v416 + 48) = v541;
      *(void *)(v416 + 56) = v339;
      *(void *)(v416 + 64) = v535;
      *(unsigned char *)(v416 + 72) = v537;
      unsigned int v417 = *(_DWORD *)(a1 + 916) + 1;
      int v418 = *(_DWORD *)(a1 + 912);
      if (v417 > 2 * v418)
      {
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v418, (uint64_t)off_1F2644D00);
        *(void *)&long long v549 = v550;
        *((void *)&v549 + 1) = 0x2000000000;
        sub_1CD0714B4((unsigned int *)v416, (unsigned int *)&v549);
        uint64_t v385 = *(void *)(a1 + 904)
             + 8
             * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8((void *)v549, v549 + 4 * DWORD2(v549)));
        if ((void *)v549 != v550) {
          free((void *)v549);
        }
        unsigned int v417 = *(_DWORD *)(a1 + 916) + 1;
      }
      *(_DWORD *)(a1 + 916) = v417;
      uint64_t v419 = *(void *)v385;
      if (!*(void *)v385) {
        uint64_t v419 = v385 | 1;
      }
      *(void *)unint64_t v416 = v419;
      *(void *)uint64_t v385 = v416;
      goto LABEL_778;
    }
LABEL_777:
    uint64_t v11 = 0;
LABEL_778:
    int v179 = 1;
LABEL_779:
    v459 = v543;
    if (v543 == (char *)&v544 + 8) {
      goto LABEL_781;
    }
    goto LABEL_780;
  }
  if (!strncmp("sp", (const char *)v15, 2uLL))
  {
    *(void *)a1 = v15 + 2;
    *(void *)&long long v549 = sub_1CD077868(a1);
    if (!(void)v549) {
      return 0;
    }
    return sub_1CD07C88C(a1, (uint64_t *)&v549, v282, v283);
  }
  if (!strncmp("sZ", (const char *)v15, 2uLL))
  {
    *(void *)a1 = v15 + 2;
    if (v16 != v15 + 2 && v15[2] == 84)
    {
      uint64_t v299 = sub_1CD07D120(a1);
      if (!v299) {
        return 0;
      }
      uint64_t v301 = v299;
      int v302 = *(unsigned __int8 *)(a1 + 937);
      v543 = (char *)&v544 + 8;
      uint64_t v545 = v299;
      long long v544 = xmmword_1CFB2EBA0;
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
      {
        uint64_t v299 = __cxa_guard_acquire(&qword_1EBCBE588);
        if (v299)
        {
          unint64_t v529 = llvm::hashing::detail::fixed_seed_override;
          if (!llvm::hashing::detail::fixed_seed_override) {
            unint64_t v529 = 0xFF51AFD7ED558CCDLL;
          }
          qword_1EBCBE580 = v529;
          __cxa_guard_release(&qword_1EBCBE588);
        }
      }
      unint64_t v303 = 0x9DDFEA08EB382D69 * (*((void *)&v544 + 1) ^ qword_1EBCBE580 ^ __ROR8__(v545 + 16, 16));
      unint64_t v304 = __ROR8__(v545 + 16, 16) ^ (v303 >> 47);
      uint64_t v305 = *(void *)(a1 + 904)
           + 8
           * ((*(_DWORD *)(a1 + 912) - 1) & ((-348639895
                                            * ((((0x9DDFEA08EB382D69 * (v304 ^ v303)) >> 32) >> 15) ^ (-348639895 * (v304 ^ v303)))) ^ v545));
      unsigned int v32 = *(unsigned int **)v305;
      *(void *)&long long v549 = v550;
      *((void *)&v549 + 1) = 0x2000000000;
      if (v32) {
        BOOL v306 = (v32 & 1) == 0;
      }
      else {
        BOOL v306 = 0;
      }
      if (v306)
      {
        while (1)
        {
          LOBYTE(v299) = sub_1CD071418(v299, v32, (uint64_t)&v543, v300, (unsigned int *)&v549);
          if (v299) {
            break;
          }
          DWORD2(v549) = 0;
          unsigned int v32 = *(unsigned int **)v32;
          if (v32) {
            BOOL v307 = (v32 & 1) == 0;
          }
          else {
            BOOL v307 = 0;
          }
          if (!v307)
          {
            unsigned int v32 = 0;
            goto LABEL_572;
          }
        }
        uint64_t v305 = 0;
LABEL_572:
        if ((void *)v549 == v550)
        {
          if (v32) {
            goto LABEL_243;
          }
        }
        else
        {
          free((void *)v549);
          if (v32) {
            goto LABEL_243;
          }
        }
      }
      if (v302)
      {
        *(void *)(a1 + 888) += 32;
        uint64_t v400 = *(void *)(a1 + 808);
        if (((v400 + 7) & 0xFFFFFFFFFFFFFFF8) - v400 + 32 > *(void *)(a1 + 816) - v400)
        {
          unsigned int v487 = *(_DWORD *)(a1 + 832) >> 7;
          if (v487 >= 0x1E) {
            LOBYTE(v487) = 30;
          }
          uint64_t v488 = 4096 << v487;
          unint64_t v401 = (unint64_t)operator new(4096 << v487, (std::align_val_t)8uLL);
          unsigned int v489 = *(_DWORD *)(a1 + 832);
          if (v489 >= *(_DWORD *)(a1 + 836)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)(a1 + 824) + 8 * v489) = v401;
          ++*(_DWORD *)(a1 + 832);
          *(void *)(a1 + 816) = v401 + v488;
        }
        else
        {
          unint64_t v401 = (v400 + 7) & 0xFFFFFFFFFFFFFFF8;
        }
        *(void *)(a1 + 808) = v401 + 32;
        *(void *)unint64_t v401 = 0;
        uint64_t v11 = v401 + 8;
        *(unsigned char *)(v401 + 16) = 58;
        *(_WORD *)(v401 + 17) = *(_WORD *)(v401 + 17) & 0xF000 | 0x540;
        v402 = &unk_1F261A4F0;
        goto LABEL_616;
      }
LABEL_691:
      uint64_t v11 = 0;
LABEL_692:
      int v179 = 1;
LABEL_693:
      v459 = v543;
      if (v543 == (char *)&v544 + 8)
      {
LABEL_781:
        if (!v179)
        {
LABEL_866:
          if (v11)
          {
            *(void *)&long long v549 = 0;
            int v512 = sub_1CD640748(a1 + 944, v11, &v549);
            uint64_t v513 = 0;
            if (v512) {
              uint64_t v513 = *(void *)(v549 + 8);
            }
            if (v513) {
              uint64_t v11 = v513;
            }
            if (v11 == *(void *)(a1 + 928)) {
              *(unsigned char *)(a1 + 936) = 1;
            }
          }
          return v11;
        }
LABEL_782:
        *(void *)(a1 + 920) = v11;
        return v11;
      }
LABEL_780:
      free(v459);
      goto LABEL_781;
    }
    *(void *)&long long v549 = sub_1CD08057C(a1);
    if (!(void)v549) {
      return 0;
    }
    unsigned int v328 = (uint64_t *)&v549;
    return sub_1CD080CA4(a1, v328);
  }
  if (!strncmp("sP", (const char *)v15, 2uLL))
  {
    unsigned int v329 = v15 + 2;
    *(void *)a1 = v15 + 2;
    uint64_t v330 = (uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 3;
    while (v329 == v16 || *v329 != 69)
    {
      uint64_t v331 = sub_1CD0810A0(a1);
      if (!v331) {
        return 0;
      }
      uint64_t v332 = v331;
      unsigned int v333 = *(uint64_t **)(a1 + 24);
      if (v333 == *(uint64_t **)(a1 + 32))
      {
        sub_1CD5F0ACC(a1 + 16, ((uint64_t)v333 - *(void *)(a1 + 16)) >> 2);
        unsigned int v333 = *(uint64_t **)(a1 + 24);
      }
      *(void *)(a1 + 24) = v333 + 1;
      *unsigned int v333 = v332;
      unsigned int v329 = *(unsigned __int8 **)a1;
      unint64_t v16 = *(unsigned __int8 **)(a1 + 8);
    }
    *(void *)a1 = v329 + 1;
    uint64_t v542 = 0;
    uint64_t v354 = *(void *)(a1 + 24);
    unsigned int v355 = (const void *)(*(void *)(a1 + 16) + 8 * v330);
    unsigned int v356 = (uint64_t *)sub_1CB906F34((uint64_t *)(a1 + 808), v354 - (void)v355, 3);
    unsigned int v357 = v356;
    int64_t v358 = v354 - (void)v355;
    if (v358) {
      memmove(v356, v355, v358);
    }
    uint64_t v359 = v358 >> 3;
    *(void *)(a1 + 24) = *(void *)(a1 + 16) + 8 * v330;
    int v360 = *(unsigned __int8 *)(a1 + 937);
    v543 = (char *)&v544 + 8;
    *(void *)&long long v544 = 0x2000000000;
    sub_1CD074590((uint64_t)&v543, 0, v357, v358 >> 3);
    unint64_t v361 = sub_1CC13A6B8(v543, (uint64_t)v543 + 4 * v544);
    uint64_t v363 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v361);
    v364 = *(unsigned int **)v363;
    *(void *)&long long v549 = v550;
    *((void *)&v549 + 1) = 0x2000000000;
    if (v364) {
      BOOL v365 = (v364 & 1) == 0;
    }
    else {
      BOOL v365 = 0;
    }
    if (!v365) {
      goto LABEL_887;
    }
    while (1)
    {
      LOBYTE(v361) = sub_1CD071418(v361, v364, (uint64_t)&v543, v362, (unsigned int *)&v549);
      if (v361) {
        break;
      }
      DWORD2(v549) = 0;
      v364 = *(unsigned int **)v364;
      if (v364) {
        BOOL v366 = (v364 & 1) == 0;
      }
      else {
        BOOL v366 = 0;
      }
      if (!v366)
      {
        v364 = 0;
        goto LABEL_545;
      }
    }
    uint64_t v363 = 0;
LABEL_545:
    if ((void *)v549 == v550)
    {
      if (v364)
      {
LABEL_547:
        int v380 = 0;
        uint64_t v381 = (uint64_t)(v364 + 2);
LABEL_896:
        if (v543 != (char *)&v544 + 8) {
          free(v543);
        }
        if (v380)
        {
          *(void *)(a1 + 920) = v381;
        }
        else
        {
          if (!v381) {
            return 0;
          }
          *(void *)&long long v549 = 0;
          int v522 = sub_1CD640748(a1 + 944, v381, &v549);
          uint64_t v523 = 0;
          if (v522) {
            uint64_t v523 = *(void *)(v549 + 8);
          }
          if (v523) {
            uint64_t v381 = v523;
          }
          if (v381 == *(void *)(a1 + 928)) {
            *(unsigned char *)(a1 + 936) = 1;
          }
        }
        uint64_t v542 = v381;
        if (!v381) {
          return 0;
        }
        unsigned int v328 = &v542;
        return sub_1CD080CA4(a1, v328);
      }
    }
    else
    {
      free((void *)v549);
      if (v364) {
        goto LABEL_547;
      }
    }
LABEL_887:
    if (v360)
    {
      *(void *)(a1 + 888) += 40;
      uint64_t v517 = *(void *)(a1 + 808);
      if (((v517 + 7) & 0xFFFFFFFFFFFFFFF8) - v517 + 40 > *(void *)(a1 + 816) - v517)
      {
        unsigned int v524 = *(_DWORD *)(a1 + 832) >> 7;
        if (v524 >= 0x1E) {
          LOBYTE(v524) = 30;
        }
        uint64_t v525 = 4096 << v524;
        unint64_t v518 = (unint64_t)operator new(4096 << v524, (std::align_val_t)8uLL);
        unsigned int v526 = *(_DWORD *)(a1 + 832);
        if (v526 >= *(_DWORD *)(a1 + 836)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 824) + 8 * v526) = v518;
        ++*(_DWORD *)(a1 + 832);
        *(void *)(a1 + 816) = v518 + v525;
      }
      else
      {
        unint64_t v518 = (v517 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(a1 + 808) = v518 + 40;
      uint64_t v381 = v518 + 8;
      *(unsigned char *)(v518 + 16) = 0;
      *(_WORD *)(v518 + 17) = *(_WORD *)(v518 + 17) & 0xF000 | 0x540;
      *(void *)unint64_t v518 = 0;
      *(void *)(v518 + 8) = &unk_1F261A548;
      *(void *)(v518 + 24) = v357;
      *(void *)(v518 + 32) = v359;
      unsigned int v519 = *(_DWORD *)(a1 + 916) + 1;
      int v520 = *(_DWORD *)(a1 + 912);
      if (v519 > 2 * v520)
      {
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v520, (uint64_t)off_1F2644D00);
        *(void *)&long long v549 = v550;
        *((void *)&v549 + 1) = 0x2000000000;
        sub_1CD0714B4((unsigned int *)v518, (unsigned int *)&v549);
        uint64_t v363 = *(void *)(a1 + 904)
             + 8
             * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8((void *)v549, v549 + 4 * DWORD2(v549)));
        if ((void *)v549 != v550) {
          free((void *)v549);
        }
        unsigned int v519 = *(_DWORD *)(a1 + 916) + 1;
      }
      *(_DWORD *)(a1 + 916) = v519;
      uint64_t v521 = *(void *)v363;
      if (!*(void *)v363) {
        uint64_t v521 = v363 | 1;
      }
      *(void *)unint64_t v518 = v521;
      *(void *)uint64_t v363 = v518;
    }
    else
    {
      uint64_t v381 = 0;
    }
    int v380 = 1;
    goto LABEL_896;
  }
  if (!strncmp("tl", (const char *)v15, 2uLL))
  {
    *(void *)a1 = v15 + 2;
    uint64_t v348 = sub_1CD06B2C4(a1);
    if (!v348) {
      return 0;
    }
    uint64_t v51 = v348;
    uint64_t v349 = (uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 3;
    while (1)
    {
      unsigned int v350 = *(unsigned __int8 **)a1;
      if (*(void *)a1 != *(void *)(a1 + 8) && *v350 == 69) {
        break;
      }
      uint64_t v351 = sub_1CD0806CC(a1);
      if (!v351) {
        return 0;
      }
      uint64_t v352 = v351;
      unsigned int v353 = *(uint64_t **)(a1 + 24);
      if (v353 == *(uint64_t **)(a1 + 32))
      {
        sub_1CD5F0ACC(a1 + 16, ((uint64_t)v353 - *(void *)(a1 + 16)) >> 2);
        unsigned int v353 = *(uint64_t **)(a1 + 24);
      }
      *(void *)(a1 + 24) = v353 + 1;
      *unsigned int v353 = v352;
    }
    *(void *)a1 = v350 + 1;
    uint64_t v406 = *(void *)(a1 + 24);
    v407 = (const void *)(*(void *)(a1 + 16) + 8 * v349);
    v408 = (uint64_t *)sub_1CB906F34((uint64_t *)(a1 + 808), v406 - (void)v407, 3);
    unsigned int v193 = v408;
    int64_t v409 = v406 - (void)v407;
    if (v409) {
      memmove(v408, v407, v409);
    }
    uint64_t v130 = v409 >> 3;
    *(void *)(a1 + 24) = *(void *)(a1 + 16) + 8 * v349;
    int v410 = *(unsigned __int8 *)(a1 + 937);
    v543 = (char *)&v544 + 8;
    *(void *)&long long v544 = 0x2000000000;
    sub_1CD074750((uint64_t)&v543, 66, v51, v193, v130);
    unint64_t v411 = sub_1CC13A6B8(v543, (uint64_t)v543 + 4 * v544);
    uint64_t v73 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v411);
    uint64_t v74 = *(unsigned int **)v73;
    *(void *)&long long v549 = v550;
    *((void *)&v549 + 1) = 0x2000000000;
    if (v74) {
      BOOL v413 = (v74 & 1) == 0;
    }
    else {
      BOOL v413 = 0;
    }
    if (!v413)
    {
LABEL_623:
      if (v410)
      {
        *(void *)(a1 + 888) += 48;
        uint64_t v427 = *(void *)(a1 + 808);
        if (((v427 + 7) & 0xFFFFFFFFFFFFFFF8) - v427 + 48 > *(void *)(a1 + 816) - v427)
        {
          unsigned int v504 = *(_DWORD *)(a1 + 832) >> 7;
          if (v504 >= 0x1E) {
            LOBYTE(v504) = 30;
          }
          uint64_t v505 = 4096 << v504;
          unint64_t v165 = (unint64_t)operator new(4096 << v504, (std::align_val_t)8uLL);
          unsigned int v506 = *(_DWORD *)(a1 + 832);
          if (v506 >= *(_DWORD *)(a1 + 836)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)(a1 + 824) + 8 * v506) = v165;
          ++*(_DWORD *)(a1 + 832);
          *(void *)(a1 + 816) = v165 + v505;
        }
        else
        {
          unint64_t v165 = (v427 + 7) & 0xFFFFFFFFFFFFFFF8;
        }
        *(void *)(a1 + 808) = v165 + 48;
        *(void *)unint64_t v165 = 0;
        uint64_t v11 = v165 + 8;
        *(unsigned char *)(v165 + 16) = 66;
        *(_WORD *)(v165 + 17) = *(_WORD *)(v165 + 17) & 0xF000 | 0x540;
        v428 = &unk_1F261A3E8;
LABEL_771:
        *(void *)(v165 + 8) = v428;
        *(void *)(v165 + 24) = v51;
        *(void *)(v165 + 32) = v193;
LABEL_772:
        *(void *)(v165 + 40) = v130;
LABEL_773:
        unsigned int v481 = *(_DWORD *)(a1 + 916) + 1;
        int v482 = *(_DWORD *)(a1 + 912);
        if (v481 > 2 * v482)
        {
          llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v482, (uint64_t)off_1F2644D00);
          *(void *)&long long v549 = v550;
          *((void *)&v549 + 1) = 0x2000000000;
          sub_1CD0714B4((unsigned int *)v165, (unsigned int *)&v549);
          uint64_t v73 = *(void *)(a1 + 904)
              + 8
              * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8((void *)v549, v549 + 4 * DWORD2(v549)));
          if ((void *)v549 != v550) {
            free((void *)v549);
          }
          unsigned int v481 = *(_DWORD *)(a1 + 916) + 1;
        }
        *(_DWORD *)(a1 + 916) = v481;
        uint64_t v483 = *(void *)v73;
        if (!*(void *)v73) {
          uint64_t v483 = v73 | 1;
        }
        *(void *)unint64_t v165 = v483;
        *(void *)uint64_t v73 = v165;
        goto LABEL_778;
      }
      goto LABEL_777;
    }
    while (1)
    {
      LOBYTE(v411) = sub_1CD071418(v411, v74, (uint64_t)&v543, v412, (unsigned int *)&v549);
      if (v411) {
        break;
      }
      DWORD2(v549) = 0;
      uint64_t v74 = *(unsigned int **)v74;
      if (v74) {
        BOOL v414 = (v74 & 1) == 0;
      }
      else {
        BOOL v414 = 0;
      }
      if (!v414)
      {
        uint64_t v74 = 0;
        goto LABEL_621;
      }
    }
    uint64_t v73 = 0;
LABEL_621:
    if ((void *)v549 == v550)
    {
      if (!v74) {
        goto LABEL_623;
      }
    }
    else
    {
      free((void *)v549);
      if (!v74) {
        goto LABEL_623;
      }
    }
LABEL_297:
    int v179 = 0;
    uint64_t v11 = (uint64_t)(v74 + 2);
    goto LABEL_779;
  }
  if (strncmp("tr", (const char *)v15, 2uLL))
  {
    if (strncmp("tw", (const char *)v15, 2uLL))
    {
      if (v16 != v15 && v18 == 117)
      {
        *(void *)a1 = v15 + 1;
        uint64_t v137 = (void *)sub_1CD081610(a1);
        v543 = v137;
        if (!v137) {
          return 0;
        }
        int v138 = (const char *)(*(uint64_t (**)(void *))(*(void *)v137 + 48))(v137);
        if (v139 - (void)v138 == 8 && !strncmp(v138, "__uuidof", 8uLL))
        {
          v439 = *(unsigned __int8 **)a1;
          if (*(void *)a1 != *(void *)(a1 + 8))
          {
            int v440 = *v439;
            if (v440 == 122)
            {
              *(void *)a1 = v439 + 1;
              uint64_t v441 = sub_1CD077868(a1);
              goto LABEL_756;
            }
            if (v440 == 116)
            {
              *(void *)a1 = v439 + 1;
              uint64_t v441 = sub_1CD06B2C4(a1);
LABEL_756:
              uint64_t v11 = v441;
              if (!v441) {
                return v11;
              }
              v479 = *(uint64_t **)(a1 + 24);
              uint64_t v140 = (uint64_t)v479 - *(void *)(a1 + 16);
              if (v479 == *(uint64_t **)(a1 + 32))
              {
                sub_1CD5F0ACC(a1 + 16, v140 >> 2);
                v479 = *(uint64_t **)(a1 + 24);
              }
              *(void *)(a1 + 24) = v479 + 1;
              uint64_t *v479 = v11;
              goto LABEL_631;
            }
          }
        }
        uint64_t v140 = *(void *)(a1 + 24) - *(void *)(a1 + 16);
        while (1)
        {
          unsigned int v141 = *(unsigned __int8 **)a1;
          if (*(void *)a1 != *(void *)(a1 + 8) && *v141 == 69) {
            break;
          }
          uint64_t v142 = sub_1CD0810A0(a1);
          if (!v142) {
            return 0;
          }
          uint64_t v143 = v142;
          unsigned int v144 = *(uint64_t **)(a1 + 24);
          if (v144 == *(uint64_t **)(a1 + 32))
          {
            sub_1CD5F0ACC(a1 + 16, ((uint64_t)v144 - *(void *)(a1 + 16)) >> 2);
            unsigned int v144 = *(uint64_t **)(a1 + 24);
          }
          *(void *)(a1 + 24) = v144 + 1;
          uint64_t *v144 = v143;
        }
        *(void *)a1 = v141 + 1;
LABEL_631:
        v430 = *(unsigned char **)(a1 + 24);
        v431 = (unsigned char *)(*(void *)(a1 + 16) + v140);
        v432 = (void *)sub_1CB906F34((uint64_t *)(a1 + 808), v430 - v431, 3);
        v433 = v432;
        if (v430 != v431) {
          memmove(v432, v431, v430 - v431);
        }
        *(void *)(a1 + 24) = *(void *)(a1 + 16) + 8 * (v140 >> 3);
        *(void *)&long long v549 = v433;
        *((void *)&v549 + 1) = (v430 - v431) >> 3;
        int v177 = 1;
LABEL_238:
        LODWORD(v542) = v177;
        return sub_1CD07EB8C(a1, (uint64_t *)&v543, &v549, (int *)&v542);
      }
      *(void *)&long long v549 = 0;
      if (v17 >= 3 && !strncmp("srN", (const char *)v15, 3uLL))
      {
        *(void *)a1 = v15 + 3;
        *(void *)&long long v549 = sub_1CD084ADC((unsigned __int8 **)a1, v388, v389, v390);
        if ((void)v549)
        {
          if (*(void *)(a1 + 8) == *(void *)a1 || **(unsigned char **)a1 != 73) {
            goto LABEL_959;
          }
          v543 = (void *)sub_1CD07D418(a1, 0);
          if (v543)
          {
            for (uint64_t i = sub_1CD07DD24(a1, (uint64_t *)&v549, (uint64_t *)&v543, v434);
                  ;
                  uint64_t i = sub_1CD084C00(a1, (uint64_t *)&v549, (uint64_t *)&v543, v531))
            {
              *(void *)&long long v549 = i;
              if (!i) {
                break;
              }
LABEL_959:
              v447 = *(unsigned __int8 **)a1;
              if (*(void *)a1 != *(void *)(a1 + 8) && *v447 == 69)
              {
LABEL_963:
                *(void *)a1 = v447 + 1;
                goto LABEL_964;
              }
              v543 = (void *)sub_1CD084B90((void *)a1);
              if (!v543) {
                return 0;
              }
            }
          }
        }
        return 0;
      }
      if (strncmp("sr", (const char *)v15, 2uLL))
      {
        uint64_t v394 = sub_1CD085088(a1);
        uint64_t v11 = v394;
        *(void *)&long long v549 = v394;
        if (!v3 || !v394) {
          return v11;
        }
        return sub_1CD085604(a1, (uint64_t *)&v549, v395, v396);
      }
      *(void *)a1 = v15 + 2;
      if (v16 == v15 + 2)
      {
        uint64_t v429 = 0;
      }
      else
      {
        if ((char)v15[2] < 0)
        {
LABEL_649:
          *(void *)&long long v549 = sub_1CD084ADC((unsigned __int8 **)a1, v391, v392, v393);
          if (!(void)v549) {
            return 0;
          }
          if (*(void *)(a1 + 8) != *(void *)a1 && **(unsigned char **)a1 == 73)
          {
            v543 = (void *)sub_1CD07D418(a1, 0);
            if (!v543) {
              return 0;
            }
            *(void *)&long long v549 = sub_1CD07DD24(a1, (uint64_t *)&v549, (uint64_t *)&v543, v442);
            if (!(void)v549) {
              return 0;
            }
          }
LABEL_964:
          v543 = (void *)sub_1CD085088(a1);
          if (v543) {
            return sub_1CD084C00(a1, (uint64_t *)&v549, (uint64_t *)&v543, v532);
          }
          return 0;
        }
        uint64_t v429 = v15[2];
      }
      if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v429 + 60) & 0x400) == 0) {
        goto LABEL_649;
      }
      v443 = (void *)sub_1CD084B90((void *)a1);
      v543 = v443;
      if (!v443) {
        return 0;
      }
      uint64_t v11 = 0;
      while (1)
      {
        if (v11)
        {
          uint64_t v446 = sub_1CD084C00(a1, (uint64_t *)&v549, (uint64_t *)&v543, v445);
        }
        else
        {
          if (!v3)
          {
            *(void *)&long long v549 = v443;
            uint64_t v11 = (uint64_t)v443;
            goto LABEL_662;
          }
          uint64_t v446 = sub_1CD085604(a1, (uint64_t *)&v543, v444, v445);
        }
        uint64_t v11 = v446;
        *(void *)&long long v549 = v446;
        if (!v446) {
          return v11;
        }
LABEL_662:
        v447 = *(unsigned __int8 **)a1;
        if (*(void *)a1 != *(void *)(a1 + 8) && *v447 == 69) {
          goto LABEL_963;
        }
        v443 = (void *)sub_1CD084B90((void *)a1);
        v543 = v443;
        if (!v443) {
          return 0;
        }
      }
    }
    *(void *)a1 = v15 + 2;
    uint64_t v373 = sub_1CD077868(a1);
    if (!v373) {
      return 0;
    }
    uint64_t v301 = v373;
    int v375 = *(unsigned __int8 *)(a1 + 937);
    v543 = (char *)&v544 + 8;
    uint64_t v545 = v373;
    long long v544 = xmmword_1CFB2EB90;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
    {
      uint64_t v373 = __cxa_guard_acquire(&qword_1EBCBE588);
      if (v373)
      {
        unint64_t v530 = llvm::hashing::detail::fixed_seed_override;
        if (!llvm::hashing::detail::fixed_seed_override) {
          unint64_t v530 = 0xFF51AFD7ED558CCDLL;
        }
        qword_1EBCBE580 = v530;
        __cxa_guard_release(&qword_1EBCBE588);
      }
    }
    unint64_t v376 = 0x9DDFEA08EB382D69 * (*((void *)&v544 + 1) ^ qword_1EBCBE580 ^ __ROR8__(v545 + 16, 16));
    unint64_t v377 = __ROR8__(v545 + 16, 16) ^ (v376 >> 47);
    uint64_t v305 = *(void *)(a1 + 904)
         + 8
         * ((*(_DWORD *)(a1 + 912) - 1) & ((-348639895
                                          * ((((0x9DDFEA08EB382D69 * (v377 ^ v376)) >> 32) >> 15) ^ (-348639895 * (v377 ^ v376)))) ^ v545));
    unsigned int v32 = *(unsigned int **)v305;
    *(void *)&long long v549 = v550;
    *((void *)&v549 + 1) = 0x2000000000;
    if (v32) {
      BOOL v378 = (v32 & 1) == 0;
    }
    else {
      BOOL v378 = 0;
    }
    if (!v378)
    {
LABEL_612:
      if (v375)
      {
        *(void *)(a1 + 888) += 32;
        uint64_t v423 = *(void *)(a1 + 808);
        if (((v423 + 7) & 0xFFFFFFFFFFFFFFF8) - v423 + 32 > *(void *)(a1 + 816) - v423)
        {
          unsigned int v501 = *(_DWORD *)(a1 + 832) >> 7;
          if (v501 >= 0x1E) {
            LOBYTE(v501) = 30;
          }
          uint64_t v502 = 4096 << v501;
          unint64_t v401 = (unint64_t)operator new(4096 << v501, (std::align_val_t)8uLL);
          unsigned int v503 = *(_DWORD *)(a1 + 832);
          if (v503 >= *(_DWORD *)(a1 + 836)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)(a1 + 824) + 8 * v503) = v401;
          ++*(_DWORD *)(a1 + 832);
          *(void *)(a1 + 816) = v401 + v502;
        }
        else
        {
          unint64_t v401 = (v423 + 7) & 0xFFFFFFFFFFFFFFF8;
        }
        *(void *)(a1 + 808) = v401 + 32;
        *(void *)unint64_t v401 = 0;
        uint64_t v11 = v401 + 8;
        *(unsigned char *)(v401 + 16) = 68;
        *(_WORD *)(v401 + 17) = *(_WORD *)(v401 + 17) & 0xF000 | 0x540;
        v402 = &unk_1F261A5A0;
LABEL_616:
        *(void *)(v401 + 8) = v402;
        *(void *)(v401 + 24) = v301;
        unsigned int v424 = *(_DWORD *)(a1 + 916) + 1;
        int v425 = *(_DWORD *)(a1 + 912);
        if (v424 > 2 * v425)
        {
          llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v425, (uint64_t)off_1F2644D00);
          *(void *)&long long v549 = v550;
          *((void *)&v549 + 1) = 0x2000000000;
          sub_1CD0714B4((unsigned int *)v401, (unsigned int *)&v549);
          uint64_t v305 = *(void *)(a1 + 904)
               + 8
               * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8((void *)v549, v549 + 4 * DWORD2(v549)));
          if ((void *)v549 != v550) {
            free((void *)v549);
          }
          unsigned int v424 = *(_DWORD *)(a1 + 916) + 1;
        }
        *(_DWORD *)(a1 + 916) = v424;
        uint64_t v426 = *(void *)v305;
        if (!*(void *)v305) {
          uint64_t v426 = v305 | 1;
        }
        *(void *)unint64_t v401 = v426;
        *(void *)uint64_t v305 = v401;
        goto LABEL_692;
      }
      goto LABEL_691;
    }
    while (1)
    {
      LOBYTE(v373) = sub_1CD071418(v373, v32, (uint64_t)&v543, v374, (unsigned int *)&v549);
      if (v373) {
        break;
      }
      DWORD2(v549) = 0;
      unsigned int v32 = *(unsigned int **)v32;
      if (v32) {
        BOOL v379 = (v32 & 1) == 0;
      }
      else {
        BOOL v379 = 0;
      }
      if (!v379)
      {
        unsigned int v32 = 0;
        goto LABEL_610;
      }
    }
    uint64_t v305 = 0;
LABEL_610:
    if ((void *)v549 == v550)
    {
      if (!v32) {
        goto LABEL_612;
      }
    }
    else
    {
      free((void *)v549);
      if (!v32) {
        goto LABEL_612;
      }
    }
LABEL_243:
    int v179 = 0;
    uint64_t v11 = (uint64_t)(v32 + 2);
    goto LABEL_693;
  }
  *(void *)a1 = v15 + 2;

  return sub_1CD06AF4C(a1, "throw");
}

uint64_t sub_1CD07C41C(uint64_t a1)
{
  v32[16] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(unsigned char **)a1;
  int v2 = *(unsigned char **)(a1 + 8);
  if (*(unsigned char **)a1 == v2) {
    return 0;
  }
  if (*v1 != 68) {
    return 0;
  }
  *(void *)a1 = v1 + 1;
  if (v1 + 1 == v2) {
    return 0;
  }
  if ((v1[1] | 0x20) != 0x74) {
    return 0;
  }
  *(void *)a1 = v1 + 2;
  uint64_t v4 = sub_1CD077868(a1);
  if (!v4) {
    return 0;
  }
  unsigned int v5 = *(unsigned char **)a1;
  if (*(void *)a1 == *(void *)(a1 + 8) || *v5 != 69) {
    return 0;
  }
  uint64_t v6 = v4;
  *(void *)a1 = v5 + 1;
  int v7 = *(unsigned __int8 *)(a1 + 937);
  unsigned int v28 = &v29[2];
  *(_OWORD *)unint64_t v29 = xmmword_1CFB2EBC0;
  llvm::FoldingSetNodeID::AddString((unsigned int *)&v28, "decltype", 8u);
  if (v29[0] >= v29[1]) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((_DWORD *)v28 + v29[0]) = v6;
  unsigned int v8 = v29[0] + 1;
  v29[0] = v8;
  if (v8 >= v29[1]) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((_DWORD *)v28 + v8) = HIDWORD(v6);
  ++v29[0];
  unint64_t v9 = sub_1CC13A6B8(v28, (uint64_t)v28 + 4 * v29[0]);
  uint64_t v11 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v9);
  BOOL v12 = *(unsigned int **)v11;
  uint64_t v30 = v32;
  uint64_t v31 = 0x2000000000;
  if (!v12 || (v12 & 1) != 0) {
    goto LABEL_25;
  }
  while (1)
  {
    LOBYTE(v9) = sub_1CD071418(v9, v12, (uint64_t)&v28, v10, (unsigned int *)&v30);
    if (v9) {
      break;
    }
    LODWORD(v31) = 0;
    BOOL v12 = *(unsigned int **)v12;
    if (v12) {
      BOOL v13 = (v12 & 1) == 0;
    }
    else {
      BOOL v13 = 0;
    }
    if (!v13)
    {
      BOOL v12 = 0;
      goto LABEL_21;
    }
  }
  uint64_t v11 = 0;
LABEL_21:
  if (v30 != v32)
  {
    free(v30);
    if (v12) {
      goto LABEL_23;
    }
LABEL_25:
    if (v7)
    {
      *(void *)(a1 + 888) += 64;
      uint64_t v17 = *(void *)(a1 + 808);
      if (((v17 + 7) & 0xFFFFFFFFFFFFFFF8) - v17 + 64 > *(void *)(a1 + 816) - v17)
      {
        unsigned int v24 = *(_DWORD *)(a1 + 832) >> 7;
        if (v24 >= 0x1E) {
          LOBYTE(v24) = 30;
        }
        uint64_t v25 = 4096 << v24;
        unint64_t v18 = (unint64_t)operator new(4096 << v24, (std::align_val_t)8uLL);
        unsigned int v26 = *(_DWORD *)(a1 + 832);
        if (v26 >= *(_DWORD *)(a1 + 836)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 824) + 8 * v26) = v18;
        ++*(_DWORD *)(a1 + 832);
        *(void *)(a1 + 816) = v18 + v25;
      }
      else
      {
        unint64_t v18 = (v17 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(a1 + 808) = v18 + 64;
      uint64_t v14 = v18 + 8;
      *(unsigned char *)(v18 + 16) = 56;
      *(_WORD *)(v18 + 17) = *(_WORD *)(v18 + 17) & 0xF000 | 0x540;
      *(void *)unint64_t v18 = 0;
      *(void *)(v18 + 8) = &unk_1F2619CB0;
      *(void *)(v18 + 24) = "decltype";
      *(void *)(v18 + 32) = "";
      *(void *)(v18 + 48) = 0;
      *(void *)(v18 + 56) = 0;
      *(void *)(v18 + 40) = v6;
      unsigned int v19 = *(_DWORD *)(a1 + 916) + 1;
      int v20 = *(_DWORD *)(a1 + 912);
      if (v19 > 2 * v20)
      {
        unsigned int v27 = (unsigned int *)v18;
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v20, (uint64_t)off_1F2644D00);
        uint64_t v30 = v32;
        uint64_t v31 = 0x2000000000;
        sub_1CD0714B4(v27, (unsigned int *)&v30);
        uint64_t v11 = *(void *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v30, (uint64_t)v30 + 4 * v31));
        if (v30 != v32) {
          free(v30);
        }
        unsigned int v19 = *(_DWORD *)(a1 + 916) + 1;
        unint64_t v18 = (unint64_t)v27;
      }
      *(_DWORD *)(a1 + 916) = v19;
      uint64_t v21 = *(void *)v11;
      if (!*(void *)v11) {
        uint64_t v21 = v11 | 1;
      }
      *(void *)unint64_t v18 = v21;
      *(void *)uint64_t v11 = v18;
    }
    else
    {
      uint64_t v14 = 0;
    }
    int v16 = 1;
    goto LABEL_34;
  }
  if (!v12) {
    goto LABEL_25;
  }
LABEL_23:
  int v16 = 0;
  uint64_t v14 = (uint64_t)(v12 + 2);
LABEL_34:
  if (v28 != &v29[2]) {
    free(v28);
  }
  if (v16)
  {
    *(void *)(a1 + 920) = v14;
  }
  else if (v14)
  {
    uint64_t v30 = 0;
    int v22 = sub_1CD640748(a1 + 944, v14, &v30);
    uint64_t v23 = 0;
    if (v22) {
      uint64_t v23 = *((void *)v30 + 1);
    }
    if (v23) {
      uint64_t v14 = v23;
    }
    if (v14 == *(void *)(a1 + 928)) {
      *(unsigned char *)(a1 + 936) = 1;
    }
  }
  return v14;
}

uint64_t sub_1CD07C88C(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a1;
  v33[16] = *MEMORY[0x1E4F143B8];
  int v6 = *(unsigned __int8 *)(a1 + 937);
  unsigned int v28 = (char *)&v29 + 8;
  uint64_t v30 = *a2;
  long long v29 = xmmword_1CFB2EC00;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
  {
    a1 = __cxa_guard_acquire(&qword_1EBCBE588);
    if (a1)
    {
      unint64_t v27 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v27 = 0xFF51AFD7ED558CCDLL;
      }
      qword_1EBCBE580 = v27;
      __cxa_guard_release(&qword_1EBCBE588);
    }
  }
  unint64_t v7 = 0x9DDFEA08EB382D69 * (*((void *)&v29 + 1) ^ qword_1EBCBE580 ^ __ROR8__(v30 + 16, 16));
  unint64_t v8 = __ROR8__(v30 + 16, 16) ^ (v7 >> 47);
  uint64_t v9 = *(void *)(v5 + 904)
     + 8
     * ((*(_DWORD *)(v5 + 912) - 1) & ((-348639895
                                      * ((((0x9DDFEA08EB382D69 * (v8 ^ v7)) >> 32) >> 15) ^ (-348639895 * (v8 ^ v7)))) ^ v30));
  uint64_t v10 = *(unsigned int **)v9;
  uint64_t v31 = v33;
  uint64_t v32 = 0x2000000000;
  if (v10) {
    BOOL v11 = (v10 & 1) == 0;
  }
  else {
    BOOL v11 = 0;
  }
  if (!v11) {
    goto LABEL_18;
  }
  while (1)
  {
    LOBYTE(a1) = sub_1CD071418(a1, v10, (uint64_t)&v28, a4, (unsigned int *)&v31);
    if (a1) {
      break;
    }
    LODWORD(v32) = 0;
    uint64_t v10 = *(unsigned int **)v10;
    if (v10) {
      BOOL v12 = (v10 & 1) == 0;
    }
    else {
      BOOL v12 = 0;
    }
    if (!v12)
    {
      uint64_t v10 = 0;
      goto LABEL_14;
    }
  }
  uint64_t v9 = 0;
LABEL_14:
  if (v31 == v33)
  {
    if (v10)
    {
LABEL_16:
      int v13 = 0;
      uint64_t v14 = (uint64_t)(v10 + 2);
      goto LABEL_27;
    }
  }
  else
  {
    free(v31);
    if (v10) {
      goto LABEL_16;
    }
  }
LABEL_18:
  if (v6)
  {
    *(void *)(v5 + 888) += 32;
    uint64_t v15 = *(void *)(v5 + 808);
    if (((v15 + 7) & 0xFFFFFFFFFFFFFFF8) - v15 + 32 > *(void *)(v5 + 816) - v15)
    {
      unsigned int v24 = *(_DWORD *)(v5 + 832) >> 7;
      if (v24 >= 0x1E) {
        LOBYTE(v24) = 30;
      }
      uint64_t v25 = 4096 << v24;
      unint64_t v16 = (unint64_t)operator new(4096 << v24, (std::align_val_t)8uLL);
      unsigned int v26 = *(_DWORD *)(v5 + 832);
      if (v26 >= *(_DWORD *)(v5 + 836)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(v5 + 824) + 8 * v26) = v16;
      ++*(_DWORD *)(v5 + 832);
      *(void *)(v5 + 816) = v16 + v25;
    }
    else
    {
      unint64_t v16 = (v15 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    *(void *)(v5 + 808) = v16 + 32;
    *(void *)unint64_t v16 = 0;
    uint64_t v14 = v16 + 8;
    uint64_t v17 = *a2;
    *(unsigned char *)(v16 + 16) = 38;
    *(_WORD *)(v16 + 17) = *(_WORD *)(v16 + 17) & 0xF000 | 0x540;
    *(void *)(v16 + 8) = &unk_1F261A2E0;
    *(void *)(v16 + 24) = v17;
    unsigned int v18 = *(_DWORD *)(v5 + 916) + 1;
    int v19 = *(_DWORD *)(v5 + 912);
    if (v18 > 2 * v19)
    {
      llvm::FoldingSetBase::GrowBucketCount(v5 + 904, 2 * v19, (uint64_t)off_1F2644D00);
      uint64_t v31 = v33;
      uint64_t v32 = 0x2000000000;
      sub_1CD0714B4((unsigned int *)v16, (unsigned int *)&v31);
      uint64_t v9 = *(void *)(v5 + 904)
         + 8 * ((*(_DWORD *)(v5 + 912) - 1) & sub_1CC13A6B8(v31, (uint64_t)v31 + 4 * v32));
      if (v31 != v33) {
        free(v31);
      }
      unsigned int v18 = *(_DWORD *)(v5 + 916) + 1;
    }
    *(_DWORD *)(v5 + 916) = v18;
    uint64_t v20 = *(void *)v9;
    if (!*(void *)v9) {
      uint64_t v20 = v9 | 1;
    }
    *(void *)unint64_t v16 = v20;
    *(void *)uint64_t v9 = v16;
  }
  else
  {
    uint64_t v14 = 0;
  }
  int v13 = 1;
LABEL_27:
  if (v28 != (char *)&v29 + 8) {
    free(v28);
  }
  if (v13)
  {
    *(void *)(v5 + 920) = v14;
  }
  else if (v14)
  {
    uint64_t v31 = 0;
    int v22 = sub_1CD640748(v5 + 944, v14, &v31);
    uint64_t v23 = 0;
    if (v22) {
      uint64_t v23 = *((void *)v31 + 1);
    }
    if (v23) {
      uint64_t v14 = v23;
    }
    if (v14 == *(void *)(v5 + 928)) {
      *(unsigned char *)(v5 + 936) = 1;
    }
  }
  return v14;
}

uint64_t sub_1CD07CC88(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v33[16] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(const char **)a1;
  if (*(void *)(a1 + 8) - *(void *)a1 < 2uLL) {
    goto LABEL_2;
  }
  if (!strncmp("Ts", v5, 2uLL))
  {
    int v6 = "struct";
    unint64_t v7 = "";
    goto LABEL_9;
  }
  if (!strncmp("Tu", v5, 2uLL))
  {
    int v6 = "union";
    unint64_t v7 = "";
    goto LABEL_9;
  }
  if (!strncmp("Te", v5, 2uLL))
  {
    int v6 = "enum";
    unint64_t v7 = "";
LABEL_9:
    *(void *)a1 = v5 + 2;
    goto LABEL_10;
  }
LABEL_2:
  int v6 = 0;
  unint64_t v7 = 0;
LABEL_10:
  uint64_t v8 = sub_1CD06E334(a1, 0, a3, a4);
  if (!v8 || v6 == v7) {
    return v8;
  }
  int v9 = *(unsigned __int8 *)(a1 + 937);
  long long v29 = &v30[2];
  *(_OWORD *)uint64_t v30 = xmmword_1CFB2EC10;
  llvm::FoldingSetNodeID::AddString((unsigned int *)&v29, (unsigned __int8 *)v6, v7 - v6);
  if (v30[0] >= v30[1]) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((_DWORD *)v29 + v30[0]) = v8;
  unsigned int v10 = v30[0] + 1;
  v30[0] = v10;
  if (v10 >= v30[1]) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((_DWORD *)v29 + v10) = HIDWORD(v8);
  ++v30[0];
  unint64_t v11 = sub_1CC13A6B8(v29, (uint64_t)v29 + 4 * v30[0]);
  uint64_t v13 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v11);
  uint64_t v14 = *(unsigned int **)v13;
  uint64_t v31 = v33;
  uint64_t v32 = 0x2000000000;
  if (v14) {
    BOOL v15 = (v14 & 1) == 0;
  }
  else {
    BOOL v15 = 0;
  }
  if (!v15) {
    goto LABEL_30;
  }
  while (1)
  {
    LOBYTE(v11) = sub_1CD071418(v11, v14, (uint64_t)&v29, v12, (unsigned int *)&v31);
    if (v11) {
      break;
    }
    LODWORD(v32) = 0;
    uint64_t v14 = *(unsigned int **)v14;
    if (v14) {
      BOOL v16 = (v14 & 1) == 0;
    }
    else {
      BOOL v16 = 0;
    }
    if (!v16)
    {
      uint64_t v14 = 0;
      goto LABEL_26;
    }
  }
  uint64_t v13 = 0;
LABEL_26:
  if (v31 != v33)
  {
    free(v31);
    if (v14) {
      goto LABEL_28;
    }
LABEL_30:
    if (v9)
    {
      *(void *)(a1 + 888) += 48;
      uint64_t v18 = *(void *)(a1 + 808);
      if (((v18 + 7) & 0xFFFFFFFFFFFFFFF8) - v18 + 48 > *(void *)(a1 + 816) - v18)
      {
        unsigned int v26 = *(_DWORD *)(a1 + 832) >> 7;
        if (v26 >= 0x1E) {
          LOBYTE(v26) = 30;
        }
        uint64_t v27 = 4096 << v26;
        unint64_t v19 = (unint64_t)operator new(4096 << v26, (std::align_val_t)8uLL);
        unsigned int v28 = *(_DWORD *)(a1 + 832);
        if (v28 >= *(_DWORD *)(a1 + 836)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 824) + 8 * v28) = v19;
        ++*(_DWORD *)(a1 + 832);
        *(void *)(a1 + 816) = v19 + v27;
      }
      else
      {
        unint64_t v19 = (v18 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(a1 + 808) = v19 + 48;
      *(unsigned char *)(v19 + 16) = 6;
      *(_WORD *)(v19 + 17) = *(_WORD *)(v19 + 17) & 0xF000 | 0x540;
      *(void *)unint64_t v19 = 0;
      *(void *)(v19 + 8) = &unk_1F261B0F8;
      *(void *)(v19 + 24) = v6;
      *(void *)(v19 + 32) = v7;
      *(void *)(v19 + 40) = v8;
      unsigned int v20 = *(_DWORD *)(a1 + 916) + 1;
      int v21 = *(_DWORD *)(a1 + 912);
      if (v20 > 2 * v21)
      {
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v21, (uint64_t)off_1F2644D00);
        uint64_t v31 = v33;
        uint64_t v32 = 0x2000000000;
        sub_1CD0714B4((unsigned int *)v19, (unsigned int *)&v31);
        uint64_t v13 = *(void *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v31, (uint64_t)v31 + 4 * v32));
        if (v31 != v33) {
          free(v31);
        }
        unsigned int v20 = *(_DWORD *)(a1 + 916) + 1;
      }
      *(_DWORD *)(a1 + 916) = v20;
      uint64_t v22 = *(void *)v13;
      if (!*(void *)v13) {
        uint64_t v22 = v13 | 1;
      }
      *(void *)unint64_t v19 = v22;
      *(void *)uint64_t v13 = v19;
      int v17 = 1;
      uint64_t v8 = v19 + 8;
    }
    else
    {
      uint64_t v8 = 0;
      int v17 = 1;
    }
    goto LABEL_38;
  }
  if (!v14) {
    goto LABEL_30;
  }
LABEL_28:
  int v17 = 0;
  uint64_t v8 = (uint64_t)(v14 + 2);
LABEL_38:
  if (v29 != &v30[2]) {
    free(v29);
  }
  if (v17)
  {
    *(void *)(a1 + 920) = v8;
  }
  else if (v8)
  {
    uint64_t v31 = 0;
    int v24 = sub_1CD640748(a1 + 944, v8, &v31);
    uint64_t v25 = 0;
    if (v24) {
      uint64_t v25 = *((void *)v31 + 1);
    }
    if (v25) {
      uint64_t v8 = v25;
    }
    if (v8 == *(void *)(a1 + 928)) {
      *(unsigned char *)(a1 + 936) = 1;
    }
  }
  return v8;
}

uint64_t sub_1CD07D120(uint64_t a1)
{
  int v2 = *(unsigned __int8 **)a1;
  uint64_t v1 = *(unsigned __int8 **)(a1 + 8);
  if (*(unsigned __int8 **)a1 == v1 || *v2 != 84) {
    return 0;
  }
  uint64_t v4 = v2 + 1;
  *(void *)a1 = v2 + 1;
  uint64_t v22 = 0;
  if (v2 + 1 == v1)
  {
    unint64_t v6 = 0;
    uint64_t v21 = 0;
    goto LABEL_14;
  }
  if (*v4 == 76)
  {
    *(void *)a1 = v2 + 2;
    if (sub_1CC6B813C((unsigned __int8 **)a1, &v22)) {
      return 0;
    }
    uint64_t v5 = *(unsigned __int8 **)a1;
    uint64_t v1 = *(unsigned __int8 **)(a1 + 8);
    if (*(unsigned __int8 **)a1 == v1 || *v5 != 95) {
      return 0;
    }
    unint64_t v6 = v22 + 1;
    uint64_t v4 = v5 + 1;
    *(void *)a1 = v4;
  }
  else
  {
    unint64_t v6 = 0;
  }
  uint64_t v21 = 0;
  if (v4 == v1 || *v4 != 95)
  {
LABEL_14:
    if ((sub_1CC6B813C((unsigned __int8 **)a1, &v21) & 1) == 0)
    {
      uint64_t v4 = *(unsigned __int8 **)a1;
      if (*(void *)a1 != *(void *)(a1 + 8) && *v4 == 95)
      {
        unint64_t v7 = v21 + 1;
        goto LABEL_18;
      }
    }
    return 0;
  }
  unint64_t v7 = 0;
LABEL_18:
  *(void *)a1 = v4 + 1;
  if (!*(unsigned char *)(a1 + 777) || v6)
  {
    uint64_t v12 = *(void **)(a1 + 672);
    uint64_t v13 = *(void *)(a1 + 664);
    uint64_t v14 = (uint64_t)v12 - v13;
    if (v6 < ((uint64_t)v12 - v13) >> 3
      && (BOOL v15 = *(void **)(v13 + 8 * v6)) != 0
      && (v17 = v15, uint64_t v16 = *v15, v7 < (v17[1] - v16) >> 3))
    {
      return *(void *)(v16 + 8 * v7);
    }
    else
    {
      unint64_t v9 = 0;
      if (v6 <= v14 >> 3 && *(void *)(a1 + 784) == v6)
      {
        if (v6 == v14 >> 3)
        {
          if (v12 == *(void **)(a1 + 680))
          {
            sub_1CD5F0ACC(a1 + 664, v14 >> 2);
            uint64_t v12 = *(void **)(a1 + 672);
          }
          *(void *)(a1 + 672) = v12 + 1;
          void *v12 = 0;
        }
        return sub_1CD06AF4C(a1, "auto");
      }
    }
  }
  else
  {
    *(void *)(a1 + 888) += 40;
    uint64_t v8 = *(void *)(a1 + 808);
    if (((v8 + 7) & 0xFFFFFFFFFFFFFFF8) - v8 + 40 > *(void *)(a1 + 816) - v8)
    {
      unsigned int v18 = *(_DWORD *)(a1 + 832) >> 7;
      if (v18 >= 0x1E) {
        LOBYTE(v18) = 30;
      }
      uint64_t v19 = 4096 << v18;
      unint64_t v9 = (unint64_t)operator new(4096 << v18, (std::align_val_t)8uLL);
      unsigned int v20 = *(_DWORD *)(a1 + 832);
      if (v20 >= *(_DWORD *)(a1 + 836)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(a1 + 824) + 8 * v20) = v9;
      ++*(_DWORD *)(a1 + 832);
      *(void *)(a1 + 816) = v9 + v19;
    }
    else
    {
      unint64_t v9 = (v8 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    *(void *)(a1 + 808) = v9 + 40;
    *(unsigned char *)(v9 + 8) = 40;
    *(_WORD *)(v9 + 9) = *(_WORD *)(v9 + 9) & 0xF000 | 0xA80;
    *(void *)unint64_t v9 = &unk_1F2619890;
    *(void *)(v9 + 16) = v7;
    *(void *)(v9 + 24) = 0;
    *(unsigned char *)(v9 + 32) = 0;
    *(void *)(a1 + 920) = v9;
    unsigned int v10 = *(unint64_t **)(a1 + 728);
    if (v10 == *(unint64_t **)(a1 + 736))
    {
      sub_1CD5F0ACC(a1 + 720, ((uint64_t)v10 - *(void *)(a1 + 720)) >> 2);
      unsigned int v10 = *(unint64_t **)(a1 + 728);
    }
    *(void *)(a1 + 728) = v10 + 1;
    *unsigned int v10 = v9;
  }
  return v9;
}

uint64_t sub_1CD07D418(uint64_t a1, int a2)
{
  v89[16] = *MEMORY[0x1E4F143B8];
  int v2 = *(unsigned char **)a1;
  if (*(void *)a1 == *(void *)(a1 + 8) || *v2 != 73) {
    return 0;
  }
  *(void *)a1 = v2 + 1;
  if (a2)
  {
    uint64_t v5 = *(void **)(a1 + 664);
    *(void *)(a1 + 672) = v5;
    if (v5 == *(void **)(a1 + 680))
    {
      sub_1CD5F0ACC(a1 + 664, 0);
      uint64_t v5 = *(void **)(a1 + 672);
    }
    *(void *)(a1 + 672) = v5 + 1;
    *uint64_t v5 = a1 + 576;
    *(void *)(a1 + 584) = *(void *)(a1 + 576);
  }
  uint64_t v6 = (uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 3;
  unint64_t v7 = (void **)(a1 + 664);
  uint64_t v8 = &v84;
  unint64_t v9 = (unsigned char *)(a1 + 688);
  uint64_t v78 = a1 + 904;
  uint64_t v10 = a1 + 944;
  while (1)
  {
    unint64_t v11 = *(unsigned char **)a1;
    if (*(void *)a1 != *(void *)(a1 + 8) && *v11 == 69) {
      break;
    }
    if (a2)
    {
      unsigned int v81 = v83;
      *((void *)&v82 + 1) = v8;
      memset(v83, 0, sizeof(v83));
      if (*v7 == v9)
      {
        BOOL v15 = *(unsigned char **)(a1 + 672);
        int64_t v16 = v15 - v9;
        if (v15 != v9) {
          memcpy(v83, v9, v15 - v9);
        }
        *(void *)&long long v82 = &v83[v16];
        *(void *)(a1 + 672) = v9;
      }
      else
      {
        unsigned int v81 = *v7;
        long long v82 = *(_OWORD *)(a1 + 672);
        *(void *)(a1 + 664) = v9;
        *(void *)(a1 + 672) = v9;
        *(void *)(a1 + 680) = a1 + 720;
      }
      uint64_t v17 = sub_1CD0810A0(a1);
      sub_1CD5F0174((char *)v7, (uint64_t)&v81);
      if (!v17) {
        goto LABEL_52;
      }
      unsigned int v18 = *(uint64_t **)(a1 + 24);
      if (v18 == *(uint64_t **)(a1 + 32))
      {
        sub_1CD5F0ACC(a1 + 16, ((uint64_t)v18 - *(void *)(a1 + 16)) >> 2);
        unsigned int v18 = *(uint64_t **)(a1 + 24);
      }
      *(void *)(a1 + 24) = v18 + 1;
      *unsigned int v18 = v17;
      if (*(unsigned char *)(v17 + 8) != 37)
      {
        uint64_t v80 = v9;
        uint64_t v27 = v6;
        unsigned int v28 = v7;
        uint64_t v29 = v10;
LABEL_46:
        uint64_t v31 = v8;
        uint64_t v32 = *(void **)(*(void *)(a1 + 672) - 8);
        BOOL v33 = (uint64_t *)v32[1];
        if (v33 == (uint64_t *)v32[2])
        {
          sub_1CD5F0ACC(*(void *)(*(void *)(a1 + 672) - 8), ((uint64_t)v33 - *v32) >> 2);
          BOOL v33 = (uint64_t *)v32[1];
        }
        v32[1] = v33 + 1;
        *BOOL v33 = v17;
        LOBYTE(v17) = 1;
        uint64_t v8 = v31;
        goto LABEL_49;
      }
      BOOL v76 = v8;
      uint64_t v77 = v10;
      uint64_t v79 = v6;
      uint64_t v19 = *(uint64_t **)(v17 + 16);
      uint64_t v20 = *(void *)(v17 + 24);
      int v21 = *(unsigned __int8 *)(a1 + 937);
      uint64_t v84 = v86;
      uint64_t v85 = 0x2000000000;
      uint64_t v74 = (uint64_t)v19;
      sub_1CD074590((uint64_t)&v84, 36, v19, v20);
      unint64_t v22 = sub_1CC13A6B8(v84, (uint64_t)v84 + 4 * v85);
      uint64_t v24 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v22);
      uint64_t v25 = *(unsigned int **)v24;
      BOOL v87 = v89;
      uint64_t v88 = 0x2000000000;
      if (v25 && (v25 & 1) == 0)
      {
        while (1)
        {
          LOBYTE(v22) = sub_1CD071418(v22, v25, (uint64_t)&v84, v23, (unsigned int *)&v87);
          if (v22) {
            break;
          }
          LODWORD(v88) = 0;
          uint64_t v25 = *(unsigned int **)v25;
          if (v25) {
            BOOL v26 = (v25 & 1) == 0;
          }
          else {
            BOOL v26 = 0;
          }
          if (!v26)
          {
            uint64_t v25 = 0;
            goto LABEL_34;
          }
        }
        uint64_t v24 = 0;
LABEL_34:
        if (v87 == v89)
        {
          if (v25) {
            goto LABEL_36;
          }
        }
        else
        {
          free(v87);
          if (v25)
          {
LABEL_36:
            int v30 = 0;
            uint64_t v17 = (uint64_t)(v25 + 2);
            goto LABEL_41;
          }
        }
      }
      if (v21)
      {
        *(void *)(a1 + 888) += 40;
        uint64_t v34 = *(void *)(a1 + 808);
        if (((v34 + 7) & 0xFFFFFFFFFFFFFFF8) - v34 + 40 > *(void *)(a1 + 816) - v34)
        {
          unsigned int v41 = *(_DWORD *)(a1 + 832) >> 7;
          if (v41 >= 0x1E) {
            LOBYTE(v41) = 30;
          }
          uint64_t v42 = 4096 << v41;
          uint64_t v35 = (unsigned int *)operator new(4096 << v41, (std::align_val_t)8uLL);
          unint64_t v43 = *(unsigned int *)(a1 + 832);
          if (v43 >= *(unsigned int *)(a1 + 836)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)(a1 + 824) + 8 * v43) = v35;
          ++*(_DWORD *)(a1 + 832);
          *(void *)(a1 + 816) = (char *)v35 + v42;
        }
        else
        {
          uint64_t v35 = (unsigned int *)((v34 + 7) & 0xFFFFFFFFFFFFFFF8);
        }
        *(void *)(a1 + 808) = v35 + 10;
        *(void *)uint64_t v35 = 0;
        uint64_t v17 = (uint64_t)(v35 + 2);
        sub_1CD5F4F5C((uint64_t)(v35 + 2), v74, v20);
        unsigned int v36 = *(_DWORD *)(a1 + 916) + 1;
        int v37 = *(_DWORD *)(a1 + 912);
        if (v36 > 2 * v37)
        {
          BOOL v75 = v7;
          llvm::FoldingSetBase::GrowBucketCount(v78, 2 * v37, (uint64_t)off_1F2644D00);
          BOOL v87 = v89;
          uint64_t v88 = 0x2000000000;
          uint64_t v73 = v35;
          sub_1CD0714B4(v35, (unsigned int *)&v87);
          unsigned int v44 = sub_1CC13A6B8(v87, (uint64_t)v87 + 4 * v88);
          uint64_t v45 = *(void *)(a1 + 904);
          int v46 = *(_DWORD *)(a1 + 912);
          if (v87 != v89) {
            free(v87);
          }
          uint64_t v24 = v45 + 8 * ((v46 - 1) & v44);
          unsigned int v36 = *(_DWORD *)(a1 + 916) + 1;
          uint64_t v35 = v73;
          unint64_t v7 = v75;
        }
        *(_DWORD *)(a1 + 916) = v36;
        uint64_t v38 = *(void *)v24;
        if (!*(void *)v24) {
          uint64_t v38 = v24 | 1;
        }
        *(void *)uint64_t v35 = v38;
        *(void *)uint64_t v24 = v35;
      }
      else
      {
        uint64_t v17 = 0;
      }
      int v30 = 1;
LABEL_41:
      uint64_t v6 = v79;
      uint64_t v10 = v77;
      if (v84 != v86) {
        free(v84);
      }
      if (v30)
      {
        uint64_t v80 = v9;
        uint64_t v27 = v6;
        unsigned int v28 = v7;
        uint64_t v29 = v77;
        *(void *)(a1 + 920) = v17;
        uint64_t v8 = v76;
      }
      else
      {
        if (!v17)
        {
          uint64_t v8 = v76;
          goto LABEL_52;
        }
        uint64_t v80 = v9;
        uint64_t v27 = v6;
        BOOL v87 = 0;
        int v39 = sub_1CD640748(v77, v17, &v87);
        uint64_t v40 = 0;
        uint64_t v8 = v76;
        if (v39) {
          uint64_t v40 = v87[1];
        }
        unsigned int v28 = v7;
        if (v40) {
          uint64_t v17 = v40;
        }
        uint64_t v29 = v77;
        if (v17 == *(void *)(a1 + 928)) {
          *(unsigned char *)(a1 + 936) = 1;
        }
      }
      if (v17) {
        goto LABEL_46;
      }
LABEL_49:
      uint64_t v10 = v29;
      unint64_t v7 = v28;
      uint64_t v6 = v27;
      unint64_t v9 = v80;
LABEL_52:
      if (v81 != v83) {
        free(v81);
      }
      if ((v17 & 1) == 0) {
        return 0;
      }
    }
    else
    {
      uint64_t v12 = sub_1CD0810A0(a1);
      if (!v12) {
        return 0;
      }
      uint64_t v13 = v12;
      uint64_t v14 = *(uint64_t **)(a1 + 24);
      if (v14 == *(uint64_t **)(a1 + 32))
      {
        sub_1CD5F0ACC(a1 + 16, ((uint64_t)v14 - *(void *)(a1 + 16)) >> 2);
        uint64_t v14 = *(uint64_t **)(a1 + 24);
      }
      *(void *)(a1 + 24) = v14 + 1;
      *uint64_t v14 = v13;
    }
  }
  *(void *)a1 = v11 + 1;
  uint64_t v49 = *(void *)(a1 + 24);
  uint64_t v50 = (const void *)(*(void *)(a1 + 16) + 8 * v6);
  uint64_t v51 = (uint64_t *)sub_1CB906F34((uint64_t *)(a1 + 808), v49 - (void)v50, 3);
  uint64_t v52 = v51;
  int64_t v53 = v49 - (void)v50;
  if (v53) {
    memmove(v51, v50, v53);
  }
  uint64_t v54 = v53 >> 3;
  *(void *)(a1 + 24) = *(void *)(a1 + 16) + 8 * v6;
  int v55 = *(unsigned __int8 *)(a1 + 937);
  uint64_t v84 = v86;
  uint64_t v85 = 0x2000000000;
  sub_1CD074590((uint64_t)&v84, 39, v52, v53 >> 3);
  unint64_t v56 = sub_1CC13A6B8(v84, (uint64_t)v84 + 4 * v85);
  uint64_t v58 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v56);
  uint64_t v59 = *(unsigned int **)v58;
  BOOL v87 = v89;
  uint64_t v88 = 0x2000000000;
  if (v59) {
    BOOL v60 = (v59 & 1) == 0;
  }
  else {
    BOOL v60 = 0;
  }
  if (v60)
  {
    while (1)
    {
      LOBYTE(v56) = sub_1CD071418(v56, v59, (uint64_t)&v84, v57, (unsigned int *)&v87);
      if (v56) {
        break;
      }
      LODWORD(v88) = 0;
      uint64_t v59 = *(unsigned int **)v59;
      if (v59) {
        BOOL v61 = (v59 & 1) == 0;
      }
      else {
        BOOL v61 = 0;
      }
      if (!v61)
      {
        uint64_t v59 = 0;
        goto LABEL_92;
      }
    }
    uint64_t v58 = 0;
LABEL_92:
    if (v87 == v89)
    {
      if (!v59) {
        goto LABEL_96;
      }
    }
    else
    {
      free(v87);
      if (!v59) {
        goto LABEL_96;
      }
    }
    int v62 = 0;
    uint64_t v47 = (uint64_t)(v59 + 2);
  }
  else
  {
LABEL_96:
    if (v55)
    {
      *(void *)(a1 + 888) += 40;
      uint64_t v63 = *(void *)(a1 + 808);
      if (((v63 + 7) & 0xFFFFFFFFFFFFFFF8) - v63 + 40 > *(void *)(a1 + 816) - v63)
      {
        unsigned int v70 = *(_DWORD *)(a1 + 832) >> 7;
        if (v70 >= 0x1E) {
          LOBYTE(v70) = 30;
        }
        uint64_t v71 = 4096 << v70;
        unint64_t v64 = (unint64_t)operator new(4096 << v70, (std::align_val_t)8uLL);
        unsigned int v72 = *(_DWORD *)(a1 + 832);
        if (v72 >= *(_DWORD *)(a1 + 836)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 824) + 8 * v72) = v64;
        ++*(_DWORD *)(a1 + 832);
        *(void *)(a1 + 816) = v64 + v71;
      }
      else
      {
        unint64_t v64 = (v63 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(a1 + 808) = v64 + 40;
      uint64_t v47 = v64 + 8;
      *(unsigned char *)(v64 + 16) = 39;
      *(_WORD *)(v64 + 17) = *(_WORD *)(v64 + 17) & 0xF000 | 0x540;
      *(void *)unint64_t v64 = 0;
      *(void *)(v64 + 8) = &unk_1F261AAC8;
      *(void *)(v64 + 24) = v52;
      *(void *)(v64 + 32) = v54;
      unsigned int v65 = *(_DWORD *)(a1 + 916) + 1;
      int v66 = *(_DWORD *)(a1 + 912);
      if (v65 > 2 * v66)
      {
        llvm::FoldingSetBase::GrowBucketCount(v78, 2 * v66, (uint64_t)off_1F2644D00);
        BOOL v87 = v89;
        uint64_t v88 = 0x2000000000;
        sub_1CD0714B4((unsigned int *)v64, (unsigned int *)&v87);
        uint64_t v58 = *(void *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v87, (uint64_t)v87 + 4 * v88));
        if (v87 != v89) {
          free(v87);
        }
        unsigned int v65 = *(_DWORD *)(a1 + 916) + 1;
      }
      *(_DWORD *)(a1 + 916) = v65;
      uint64_t v67 = *(void *)v58;
      if (!*(void *)v58) {
        uint64_t v67 = v58 | 1;
      }
      *(void *)unint64_t v64 = v67;
      *(void *)uint64_t v58 = v64;
    }
    else
    {
      uint64_t v47 = 0;
    }
    int v62 = 1;
  }
  if (v84 != v86) {
    free(v84);
  }
  if (v62)
  {
    *(void *)(a1 + 920) = v47;
  }
  else if (v47)
  {
    BOOL v87 = 0;
    int v68 = sub_1CD640748(v10, v47, &v87);
    uint64_t v69 = 0;
    if (v68) {
      uint64_t v69 = v87[1];
    }
    if (v69) {
      uint64_t v47 = v69;
    }
    if (v47 == *(void *)(a1 + 928)) {
      *(unsigned char *)(a1 + 936) = 1;
    }
  }
  return v47;
}

uint64_t sub_1CD07DD24(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v6 = a1;
  v39[16] = *MEMORY[0x1E4F143B8];
  int v7 = *(unsigned __int8 *)(a1 + 937);
  BOOL v33 = (char *)&v34 + 8;
  uint64_t v8 = *a3;
  unint64_t v9 = HIDWORD(*a2);
  LODWORD(v35) = *a2;
  HIDWORD(v35) = v9;
  uint64_t v36 = v8;
  long long v34 = xmmword_1CFB2EC20;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
  {
    a1 = __cxa_guard_acquire(&qword_1EBCBE588);
    if (a1)
    {
      unint64_t v32 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v32 = 0xFF51AFD7ED558CCDLL;
      }
      qword_1EBCBE580 = v32;
      __cxa_guard_release(&qword_1EBCBE588);
    }
  }
  uint64_t v10 = __ROR8__(0xB492B66FBE98F273 * *((void *)&v34 + 1) - v35, 43)
      - 0x3C5A37A36834CED9 * v35
      + __ROR8__((0x9AE16A3B2F90404FLL * v36) ^ qword_1EBCBE580, 30);
  unint64_t v11 = qword_1EBCBE580
      + __ROR8__(v35 ^ 0xC949D7C7509E6557, 20)
      - 0x4B6D499041670D8DLL * *((void *)&v34 + 1)
      - 0x9AE16A3B2F90404FLL * v36
      + 24;
  unint64_t v12 = 0x9DDFEA08EB382D69
      * (v11 ^ ((0x9DDFEA08EB382D69 * (v10 ^ v11)) >> 47) ^ (0x9DDFEA08EB382D69 * (v10 ^ v11)));
  uint64_t v13 = *(void *)(v6 + 904)
      + 8 * ((-348639895 * ((v12 >> 47) ^ v12)) & (*(_DWORD *)(v6 + 912) - 1));
  uint64_t v14 = *(unsigned int **)v13;
  int v37 = v39;
  uint64_t v38 = 0x2000000000;
  if (v14) {
    BOOL v15 = (v14 & 1) == 0;
  }
  else {
    BOOL v15 = 0;
  }
  if (!v15) {
    goto LABEL_18;
  }
  while (1)
  {
    LOBYTE(a1) = sub_1CD071418(a1, v14, (uint64_t)&v33, a4, (unsigned int *)&v37);
    if (a1) {
      break;
    }
    LODWORD(v38) = 0;
    uint64_t v14 = *(unsigned int **)v14;
    if (v14) {
      BOOL v16 = (v14 & 1) == 0;
    }
    else {
      BOOL v16 = 0;
    }
    if (!v16)
    {
      uint64_t v14 = 0;
      goto LABEL_14;
    }
  }
  uint64_t v13 = 0;
LABEL_14:
  if (v37 == v39)
  {
    if (v14)
    {
LABEL_16:
      int v17 = 0;
      uint64_t v18 = (uint64_t)(v14 + 2);
      goto LABEL_27;
    }
  }
  else
  {
    free(v37);
    if (v14) {
      goto LABEL_16;
    }
  }
LABEL_18:
  if (v7)
  {
    *(void *)(v6 + 888) += 40;
    uint64_t v19 = *(void *)(v6 + 808);
    if (((v19 + 7) & 0xFFFFFFFFFFFFFFF8) - v19 + 40 > *(void *)(v6 + 816) - v19)
    {
      unsigned int v29 = *(_DWORD *)(v6 + 832) >> 7;
      if (v29 >= 0x1E) {
        LOBYTE(v29) = 30;
      }
      uint64_t v30 = 4096 << v29;
      unint64_t v20 = (unint64_t)operator new(4096 << v29, (std::align_val_t)8uLL);
      unsigned int v31 = *(_DWORD *)(v6 + 832);
      if (v31 >= *(_DWORD *)(v6 + 836)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(v6 + 824) + 8 * v31) = v20;
      ++*(_DWORD *)(v6 + 832);
      *(void *)(v6 + 816) = v20 + v30;
    }
    else
    {
      unint64_t v20 = (v19 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    *(void *)(v6 + 808) = v20 + 40;
    *(void *)unint64_t v20 = 0;
    uint64_t v18 = v20 + 8;
    uint64_t v21 = *a2;
    uint64_t v22 = *a3;
    *(unsigned char *)(v20 + 16) = 41;
    *(_WORD *)(v20 + 17) = *(_WORD *)(v20 + 17) & 0xF000 | 0x540;
    *(void *)(v20 + 8) = &unk_1F261AB20;
    *(void *)(v20 + 24) = v21;
    *(void *)(v20 + 32) = v22;
    unsigned int v23 = *(_DWORD *)(v6 + 916) + 1;
    int v24 = *(_DWORD *)(v6 + 912);
    if (v23 > 2 * v24)
    {
      llvm::FoldingSetBase::GrowBucketCount(v6 + 904, 2 * v24, (uint64_t)off_1F2644D00);
      int v37 = v39;
      uint64_t v38 = 0x2000000000;
      sub_1CD0714B4((unsigned int *)v20, (unsigned int *)&v37);
      uint64_t v13 = *(void *)(v6 + 904)
          + 8 * ((*(_DWORD *)(v6 + 912) - 1) & sub_1CC13A6B8(v37, (uint64_t)v37 + 4 * v38));
      if (v37 != v39) {
        free(v37);
      }
      unsigned int v23 = *(_DWORD *)(v6 + 916) + 1;
    }
    *(_DWORD *)(v6 + 916) = v23;
    uint64_t v25 = *(void *)v13;
    if (!*(void *)v13) {
      uint64_t v25 = v13 | 1;
    }
    *(void *)unint64_t v20 = v25;
    *(void *)uint64_t v13 = v20;
  }
  else
  {
    uint64_t v18 = 0;
  }
  int v17 = 1;
LABEL_27:
  if (v33 != (char *)&v34 + 8) {
    free(v33);
  }
  if (v17)
  {
    *(void *)(v6 + 920) = v18;
  }
  else if (v18)
  {
    int v37 = 0;
    int v27 = sub_1CD640748(v6 + 944, v18, &v37);
    uint64_t v28 = 0;
    if (v27) {
      uint64_t v28 = *((void *)v37 + 1);
    }
    if (v28) {
      uint64_t v18 = v28;
    }
    if (v18 == *(void *)(v6 + 928)) {
      *(unsigned char *)(v6 + 936) = 1;
    }
  }
  return v18;
}

uint64_t sub_1CD07E1AC(uint64_t a1, unint64_t *a2, int *a3, uint64_t a4)
{
  uint64_t v6 = a1;
  v40[16] = *MEMORY[0x1E4F143B8];
  int v7 = *(unsigned __int8 *)(a1 + 937);
  long long v34 = (char *)&v35 + 8;
  int v8 = *a3;
  unint64_t v9 = HIDWORD(*a2);
  LODWORD(v36) = *a2;
  HIDWORD(v36) = v9;
  uint64_t v37 = v8;
  long long v35 = xmmword_1CFB2EC30;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
  {
    a1 = __cxa_guard_acquire(&qword_1EBCBE588);
    if (a1)
    {
      unint64_t v33 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v33 = 0xFF51AFD7ED558CCDLL;
      }
      qword_1EBCBE580 = v33;
      __cxa_guard_release(&qword_1EBCBE588);
    }
  }
  uint64_t v10 = __ROR8__(0xB492B66FBE98F273 * *((void *)&v35 + 1) - v36, 43)
      - 0x3C5A37A36834CED9 * v36
      + __ROR8__((0x9AE16A3B2F90404FLL * v37) ^ qword_1EBCBE580, 30);
  unint64_t v11 = qword_1EBCBE580
      + __ROR8__(v36 ^ 0xC949D7C7509E6557, 20)
      - 0x4B6D499041670D8DLL * *((void *)&v35 + 1)
      - 0x9AE16A3B2F90404FLL * v37
      + 24;
  unint64_t v12 = 0x9DDFEA08EB382D69
      * (v11 ^ ((0x9DDFEA08EB382D69 * (v10 ^ v11)) >> 47) ^ (0x9DDFEA08EB382D69 * (v10 ^ v11)));
  uint64_t v13 = *(void *)(v6 + 904)
      + 8 * ((-348639895 * ((v12 >> 47) ^ v12)) & (*(_DWORD *)(v6 + 912) - 1));
  uint64_t v14 = *(unsigned int **)v13;
  uint64_t v38 = v40;
  uint64_t v39 = 0x2000000000;
  if (v14) {
    BOOL v15 = (v14 & 1) == 0;
  }
  else {
    BOOL v15 = 0;
  }
  if (!v15) {
    goto LABEL_18;
  }
  while (1)
  {
    LOBYTE(a1) = sub_1CD071418(a1, v14, (uint64_t)&v34, a4, (unsigned int *)&v38);
    if (a1) {
      break;
    }
    LODWORD(v39) = 0;
    uint64_t v14 = *(unsigned int **)v14;
    if (v14) {
      BOOL v16 = (v14 & 1) == 0;
    }
    else {
      BOOL v16 = 0;
    }
    if (!v16)
    {
      uint64_t v14 = 0;
      goto LABEL_14;
    }
  }
  uint64_t v13 = 0;
LABEL_14:
  if (v38 == v40)
  {
    if (v14)
    {
LABEL_16:
      int v17 = 0;
      uint64_t v18 = (uint64_t)(v14 + 2);
      goto LABEL_27;
    }
  }
  else
  {
    free(v38);
    if (v14) {
      goto LABEL_16;
    }
  }
LABEL_18:
  if (v7)
  {
    *(void *)(v6 + 888) += 40;
    uint64_t v19 = *(void *)(v6 + 808);
    if (((v19 + 7) & 0xFFFFFFFFFFFFFFF8) - v19 + 40 > *(void *)(v6 + 816) - v19)
    {
      unsigned int v30 = *(_DWORD *)(v6 + 832) >> 7;
      if (v30 >= 0x1E) {
        LOBYTE(v30) = 30;
      }
      uint64_t v31 = 4096 << v30;
      unint64_t v20 = (unint64_t)operator new(4096 << v30, (std::align_val_t)8uLL);
      unsigned int v32 = *(_DWORD *)(v6 + 832);
      if (v32 >= *(_DWORD *)(v6 + 836)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(v6 + 824) + 8 * v32) = v20;
      ++*(_DWORD *)(v6 + 832);
      *(void *)(v6 + 816) = v20 + v31;
    }
    else
    {
      unint64_t v20 = (v19 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    *(void *)(v6 + 808) = v20 + 40;
    *(void *)unint64_t v20 = 0;
    uint64_t v18 = v20 + 8;
    unint64_t v21 = *a2;
    int v22 = *a3;
    char v23 = *(_WORD *)(*a2 + 9);
    *(unsigned char *)(v20 + 16) = 12;
    *(_WORD *)(v20 + 17) = v23 & 0xC0 | 0x500 | *(_WORD *)(v20 + 17) & 0xF000;
    *(void *)(v20 + 8) = &unk_1F261B1A8;
    *(void *)(v20 + 24) = v21;
    *(_DWORD *)(v20 + 32) = v22;
    *(unsigned char *)(v20 + 36) = 0;
    unsigned int v24 = *(_DWORD *)(v6 + 916) + 1;
    int v25 = *(_DWORD *)(v6 + 912);
    if (v24 > 2 * v25)
    {
      llvm::FoldingSetBase::GrowBucketCount(v6 + 904, 2 * v25, (uint64_t)off_1F2644D00);
      uint64_t v38 = v40;
      uint64_t v39 = 0x2000000000;
      sub_1CD0714B4((unsigned int *)v20, (unsigned int *)&v38);
      uint64_t v13 = *(void *)(v6 + 904)
          + 8 * ((*(_DWORD *)(v6 + 912) - 1) & sub_1CC13A6B8(v38, (uint64_t)v38 + 4 * v39));
      if (v38 != v40) {
        free(v38);
      }
      unsigned int v24 = *(_DWORD *)(v6 + 916) + 1;
    }
    *(_DWORD *)(v6 + 916) = v24;
    uint64_t v26 = *(void *)v13;
    if (!*(void *)v13) {
      uint64_t v26 = v13 | 1;
    }
    *(void *)unint64_t v20 = v26;
    *(void *)uint64_t v13 = v20;
  }
  else
  {
    uint64_t v18 = 0;
  }
  int v17 = 1;
LABEL_27:
  if (v34 != (char *)&v35 + 8) {
    free(v34);
  }
  if (v17)
  {
    *(void *)(v6 + 920) = v18;
  }
  else if (v18)
  {
    uint64_t v38 = 0;
    int v28 = sub_1CD640748(v6 + 944, v18, &v38);
    uint64_t v29 = 0;
    if (v28) {
      uint64_t v29 = *((void *)v38 + 1);
    }
    if (v29) {
      uint64_t v18 = v29;
    }
    if (v18 == *(void *)(v6 + 928)) {
      *(unsigned char *)(v6 + 936) = 1;
    }
  }
  return v18;
}

uint64_t sub_1CD07E648(const char **a1, unsigned char *a2, unsigned char *a3, uint64_t a4)
{
  int v7 = *a1;
  int v8 = a1[1];
  if ((unint64_t)(v8 - *a1) >= 2 && !strncmp("St", v7, 2uLL))
  {
    *a1 = v7 + 2;
    uint64_t result = sub_1CD06AF4C((uint64_t)a1, "std");
    if (!result) {
      return result;
    }
    uint64_t v9 = result;
    int v7 = *a1;
    int v8 = a1[1];
  }
  else
  {
    uint64_t v9 = 0;
  }
  if (v8 == v7 || *v7 != 83)
  {
    uint64_t v11 = 0;
  }
  else
  {
    uint64_t result = sub_1CD085A00((uint64_t)a1, (uint64_t)a2, (uint64_t)a3, a4);
    if (!result) {
      return result;
    }
    uint64_t v11 = result;
    if (*(unsigned char *)(result + 8) != 25)
    {
      uint64_t result = 0;
      if (a3)
      {
        if (!v9)
        {
          *a3 = 1;
          return v11;
        }
      }
      return result;
    }
  }

  return sub_1CD0871B0((uint64_t)a1, a2, v9, v11);
}

char *sub_1CD07E754(unsigned __int8 **a1)
{
  uint64_t v1 = *a1;
  if ((unint64_t)(a1[1] - *a1) < 2) {
    return 0;
  }
  int v3 = *v1;
  uint64_t result = &byte_1E6855428;
  unint64_t v5 = 62;
  do
  {
    unint64_t v6 = v5 >> 1;
    int v7 = &result[16 * (v5 >> 1)];
    if (*v7 < (char)v3 || *v7 == v3 && v7[1] < (char)v1[1])
    {
      uint64_t result = v7 + 16;
      unint64_t v6 = v5 + ~v6;
    }
    unint64_t v5 = v6;
  }
  while (v6);
  if (result == (char *)&off_1E6855808 || *result != v3 || result[1] != v1[1]) {
    return 0;
  }
  *a1 = v1 + 2;
  return result;
}

uint64_t sub_1CD07E7FC(uint64_t a1, unsigned __int8 *a2, uint64_t a3, int a4)
{
  v35[16] = *MEMORY[0x1E4F143B8];
  uint64_t v8 = sub_1CD077868(a1);
  if (!v8) {
    return 0;
  }
  uint64_t v9 = v8;
  int v10 = *(unsigned __int8 *)(a1 + 937);
  unsigned int v30 = v32;
  uint64_t v31 = 0x2000000000;
  sub_1CD0758F0((unsigned int *)&v30, 62, a2, a3, v8, a4);
  unint64_t v11 = sub_1CC13A6B8(v30, (uint64_t)v30 + 4 * v31);
  uint64_t v13 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v11);
  uint64_t v14 = *(unsigned int **)v13;
  unint64_t v33 = v35;
  uint64_t v34 = 0x2000000000;
  if (v14) {
    BOOL v15 = (v14 & 1) == 0;
  }
  else {
    BOOL v15 = 0;
  }
  if (!v15) {
    goto LABEL_19;
  }
  while (1)
  {
    LOBYTE(v11) = sub_1CD071418(v11, v14, (uint64_t)&v30, v12, (unsigned int *)&v33);
    if (v11) {
      break;
    }
    LODWORD(v34) = 0;
    uint64_t v14 = *(unsigned int **)v14;
    if (v14) {
      BOOL v16 = (v14 & 1) == 0;
    }
    else {
      BOOL v16 = 0;
    }
    if (!v16)
    {
      uint64_t v14 = 0;
      goto LABEL_15;
    }
  }
  uint64_t v13 = 0;
LABEL_15:
  if (v33 != v35)
  {
    free(v33);
    if (v14) {
      goto LABEL_17;
    }
LABEL_19:
    if (v10)
    {
      *(void *)(a1 + 888) += 48;
      uint64_t v19 = *(void *)(a1 + 808);
      if (((v19 + 7) & 0xFFFFFFFFFFFFFFF8) - v19 + 48 > *(void *)(a1 + 816) - v19)
      {
        unsigned int v27 = *(_DWORD *)(a1 + 832) >> 7;
        if (v27 >= 0x1E) {
          LOBYTE(v27) = 30;
        }
        uint64_t v28 = 4096 << v27;
        unint64_t v20 = (unint64_t)operator new(4096 << v27, (std::align_val_t)8uLL);
        unsigned int v29 = *(_DWORD *)(a1 + 832);
        if (v29 >= *(_DWORD *)(a1 + 836)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 824) + 8 * v29) = v20;
        ++*(_DWORD *)(a1 + 832);
        *(void *)(a1 + 816) = v20 + v28;
      }
      else
      {
        unint64_t v20 = (v19 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(a1 + 808) = v20 + 48;
      uint64_t v17 = v20 + 8;
      *(unsigned char *)(v20 + 16) = 62;
      *(_WORD *)(v20 + 17) = *(_WORD *)(v20 + 17) & 0xF000 | a4 & 0x3F | 0x540;
      *(void *)unint64_t v20 = 0;
      *(void *)(v20 + 8) = &unk_1F2619940;
      *(void *)(v20 + 24) = a2;
      *(void *)(v20 + 32) = a3;
      *(void *)(v20 + 40) = v9;
      unsigned int v21 = *(_DWORD *)(a1 + 916) + 1;
      int v22 = *(_DWORD *)(a1 + 912);
      if (v21 > 2 * v22)
      {
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v22, (uint64_t)off_1F2644D00);
        unint64_t v33 = v35;
        uint64_t v34 = 0x2000000000;
        sub_1CD0714B4((unsigned int *)v20, (unsigned int *)&v33);
        uint64_t v13 = *(void *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v33, (uint64_t)v33 + 4 * v34));
        if (v33 != v35) {
          free(v33);
        }
        unsigned int v21 = *(_DWORD *)(a1 + 916) + 1;
      }
      *(_DWORD *)(a1 + 916) = v21;
      uint64_t v23 = *(void *)v13;
      if (!*(void *)v13) {
        uint64_t v23 = v13 | 1;
      }
      *(void *)unint64_t v20 = v23;
      *(void *)uint64_t v13 = v20;
    }
    else
    {
      uint64_t v17 = 0;
    }
    int v18 = 1;
    goto LABEL_28;
  }
  if (!v14) {
    goto LABEL_19;
  }
LABEL_17:
  int v18 = 0;
  uint64_t v17 = (uint64_t)(v14 + 2);
LABEL_28:
  if (v30 != v32) {
    free(v30);
  }
  if (v18)
  {
    *(void *)(a1 + 920) = v17;
  }
  else if (v17)
  {
    unint64_t v33 = 0;
    int v25 = sub_1CD640748(a1 + 944, v17, &v33);
    uint64_t v26 = 0;
    if (v25) {
      uint64_t v26 = *((void *)v33 + 1);
    }
    if (v26) {
      uint64_t v17 = v26;
    }
    if (v17 == *(void *)(a1 + 928)) {
      *(unsigned char *)(a1 + 936) = 1;
    }
  }
  return v17;
}

uint64_t sub_1CD07EB8C(uint64_t a1, uint64_t *a2, long long *a3, int *a4)
{
  v37[16] = *MEMORY[0x1E4F143B8];
  int v8 = *(unsigned __int8 *)(a1 + 937);
  unsigned int v32 = v34;
  uint64_t v33 = 0x2000000000;
  sub_1CD074EE0((uint64_t)&v32, 59, *a2, *(uint64_t **)a3, *((void *)a3 + 1), *a4);
  unint64_t v9 = sub_1CC13A6B8(v32, (uint64_t)v32 + 4 * v33);
  uint64_t v11 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v9);
  uint64_t v12 = *(unsigned int **)v11;
  long long v35 = v37;
  uint64_t v36 = 0x2000000000;
  if (v12) {
    BOOL v13 = (v12 & 1) == 0;
  }
  else {
    BOOL v13 = 0;
  }
  if (!v13) {
    goto LABEL_17;
  }
  while (1)
  {
    LOBYTE(v9) = sub_1CD071418(v9, v12, (uint64_t)&v32, v10, (unsigned int *)&v35);
    if (v9) {
      break;
    }
    LODWORD(v36) = 0;
    uint64_t v12 = *(unsigned int **)v12;
    if (v12) {
      BOOL v14 = (v12 & 1) == 0;
    }
    else {
      BOOL v14 = 0;
    }
    if (!v14)
    {
      uint64_t v12 = 0;
      goto LABEL_13;
    }
  }
  uint64_t v11 = 0;
LABEL_13:
  if (v35 == v37)
  {
    if (v12)
    {
LABEL_15:
      int v15 = 0;
      uint64_t v16 = (uint64_t)(v12 + 2);
      goto LABEL_26;
    }
  }
  else
  {
    free(v35);
    if (v12) {
      goto LABEL_15;
    }
  }
LABEL_17:
  if (v8)
  {
    *(void *)(a1 + 888) += 48;
    uint64_t v17 = *(void *)(a1 + 808);
    if (((v17 + 7) & 0xFFFFFFFFFFFFFFF8) - v17 + 48 > *(void *)(a1 + 816) - v17)
    {
      unsigned int v29 = *(_DWORD *)(a1 + 832) >> 7;
      if (v29 >= 0x1E) {
        LOBYTE(v29) = 30;
      }
      uint64_t v30 = 4096 << v29;
      unint64_t v18 = (unint64_t)operator new(4096 << v29, (std::align_val_t)8uLL);
      unsigned int v31 = *(_DWORD *)(a1 + 832);
      if (v31 >= *(_DWORD *)(a1 + 836)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(a1 + 824) + 8 * v31) = v18;
      ++*(_DWORD *)(a1 + 832);
      *(void *)(a1 + 816) = v18 + v30;
    }
    else
    {
      unint64_t v18 = (v17 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    *(void *)(a1 + 808) = v18 + 48;
    *(void *)unint64_t v18 = 0;
    uint64_t v16 = v18 + 8;
    uint64_t v19 = *a2;
    char v20 = *(_WORD *)a4;
    *(unsigned char *)(v18 + 16) = 59;
    __int16 v21 = *(_WORD *)(v18 + 17) & 0xF000 | v20 & 0x3F | 0x540;
    *(void *)(v18 + 8) = &unk_1F2619B50;
    long long v22 = *a3;
    *(_WORD *)(v18 + 17) = v21;
    *(void *)(v18 + 24) = v19;
    *(_OWORD *)(v18 + 32) = v22;
    unsigned int v23 = *(_DWORD *)(a1 + 916) + 1;
    int v24 = *(_DWORD *)(a1 + 912);
    if (v23 > 2 * v24)
    {
      llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v24, (uint64_t)off_1F2644D00);
      long long v35 = v37;
      uint64_t v36 = 0x2000000000;
      sub_1CD0714B4((unsigned int *)v18, (unsigned int *)&v35);
      uint64_t v11 = *(void *)(a1 + 904)
          + 8 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v35, (uint64_t)v35 + 4 * v36));
      if (v35 != v37) {
        free(v35);
      }
      unsigned int v23 = *(_DWORD *)(a1 + 916) + 1;
    }
    *(_DWORD *)(a1 + 916) = v23;
    uint64_t v25 = *(void *)v11;
    if (!*(void *)v11) {
      uint64_t v25 = v11 | 1;
    }
    *(void *)unint64_t v18 = v25;
    *(void *)uint64_t v11 = v18;
  }
  else
  {
    uint64_t v16 = 0;
  }
  int v15 = 1;
LABEL_26:
  if (v32 != v34) {
    free(v32);
  }
  if (v15)
  {
    *(void *)(a1 + 920) = v16;
  }
  else if (v16)
  {
    long long v35 = 0;
    int v27 = sub_1CD640748(a1 + 944, v16, &v35);
    uint64_t v28 = 0;
    if (v27) {
      uint64_t v28 = *((void *)v35 + 1);
    }
    if (v28) {
      uint64_t v16 = v28;
    }
    if (v16 == *(void *)(a1 + 928)) {
      *(unsigned char *)(a1 + 936) = 1;
    }
  }
  return v16;
}

uint64_t sub_1CD07EF14(uint64_t a1)
{
  v116[16] = *MEMORY[0x1E4F143B8];
  int v2 = *(unsigned __int8 **)a1;
  uint64_t v1 = *(unsigned char **)(a1 + 8);
  if (*(unsigned char **)a1 == v1 || *v2 != 76) {
    return 0;
  }
  *(void *)a1 = v2 + 1;
  unint64_t v4 = v1 - (v2 + 1);
  if (v1 != v2 + 1)
  {
    uint64_t v5 = 0;
    switch(v2[1])
    {
      case 'A':
        uint64_t v6 = sub_1CD06B2C4(a1);
        if (!v6) {
          return 0;
        }
        int v8 = *(unsigned __int8 **)a1;
        if (*(void *)a1 == *(void *)(a1 + 8) || *v8 != 69) {
          return 0;
        }
        uint64_t v9 = v6;
        *(void *)a1 = v8 + 1;
        int v10 = *(unsigned __int8 *)(a1 + 937);
        BOOL v111 = (char *)&v112 + 8;
        uint64_t v113 = v6;
        long long v112 = xmmword_1CFB2EC50;
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
        {
          uint64_t v6 = __cxa_guard_acquire(&qword_1EBCBE588);
          if (v6)
          {
            unint64_t v109 = llvm::hashing::detail::fixed_seed_override;
            if (!llvm::hashing::detail::fixed_seed_override) {
              unint64_t v109 = 0xFF51AFD7ED558CCDLL;
            }
            qword_1EBCBE580 = v109;
            __cxa_guard_release(&qword_1EBCBE588);
          }
        }
        unint64_t v11 = 0x9DDFEA08EB382D69 * (*((void *)&v112 + 1) ^ qword_1EBCBE580 ^ __ROR8__(v113 + 16, 16));
        unint64_t v12 = __ROR8__(v113 + 16, 16) ^ (v11 >> 47);
        uint64_t v13 = *(void *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & ((-348639895
                                             * ((((0x9DDFEA08EB382D69 * (v12 ^ v11)) >> 32) >> 15) ^ (-348639895 * (v12 ^ v11)))) ^ v113));
        BOOL v14 = *(unsigned int **)v13;
        int v114 = v116;
        uint64_t v115 = 0x2000000000;
        if (v14) {
          BOOL v15 = (v14 & 1) == 0;
        }
        else {
          BOOL v15 = 0;
        }
        if (!v15) {
          goto LABEL_151;
        }
        while (1)
        {
          LOBYTE(v6) = sub_1CD071418(v6, v14, (uint64_t)&v111, v7, (unsigned int *)&v114);
          if (v6) {
            break;
          }
          LODWORD(v115) = 0;
          BOOL v14 = *(unsigned int **)v14;
          if (v14) {
            BOOL v16 = (v14 & 1) == 0;
          }
          else {
            BOOL v16 = 0;
          }
          if (!v16)
          {
            BOOL v14 = 0;
            goto LABEL_149;
          }
        }
        uint64_t v13 = 0;
LABEL_149:
        if (v114 == v116)
        {
          if (v14) {
            goto LABEL_183;
          }
        }
        else
        {
          free(v114);
          if (v14) {
            goto LABEL_183;
          }
        }
LABEL_151:
        if (!v10) {
          goto LABEL_250;
        }
        *(void *)(a1 + 888) += 32;
        uint64_t v67 = *(void *)(a1 + 808);
        if (((v67 + 7) & 0xFFFFFFFFFFFFFFF8) - v67 + 32 > *(void *)(a1 + 816) - v67)
        {
          unsigned int v78 = *(_DWORD *)(a1 + 832) >> 7;
          if (v78 >= 0x1E) {
            LOBYTE(v78) = 30;
          }
          uint64_t v79 = 4096 << v78;
          unint64_t v68 = (unint64_t)operator new(4096 << v78, (std::align_val_t)8uLL);
          unsigned int v80 = *(_DWORD *)(a1 + 832);
          if (v80 >= *(_DWORD *)(a1 + 836)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)(a1 + 824) + 8 * v80) = v68;
          ++*(_DWORD *)(a1 + 832);
          *(void *)(a1 + 816) = v68 + v79;
        }
        else
        {
          unint64_t v68 = (v67 + 7) & 0xFFFFFFFFFFFFFFF8;
        }
        *(void *)(a1 + 808) = v68 + 32;
        *(void *)unint64_t v68 = 0;
        uint64_t v5 = v68 + 8;
        *(unsigned char *)(v68 + 16) = 70;
        *(_WORD *)(v68 + 17) = *(_WORD *)(v68 + 17) & 0xF000 | 0x540;
        uint64_t v69 = &unk_1F2619EC0;
        goto LABEL_246;
      case 'D':
        if (v4 < 3 || strncmp("DnE", (const char *)v2 + 1, 3uLL)) {
          return 0;
        }
        *(void *)a1 = v2 + 4;
        return sub_1CD06AF4C(a1, "nullptr");
      case 'T':
        return v5;
      case 'U':
        if (v4 < 2) {
          return 0;
        }
        if (v2[2] != 108) {
          return 0;
        }
        uint64_t v45 = sub_1CD0821D8(a1, 0);
        if (!v45) {
          return 0;
        }
        uint64_t v47 = *(unsigned __int8 **)a1;
        if (*(void *)a1 == *(void *)(a1 + 8) || *v47 != 69) {
          return 0;
        }
        uint64_t v9 = v45;
        *(void *)a1 = v47 + 1;
        int v48 = *(unsigned __int8 *)(a1 + 937);
        BOOL v111 = (char *)&v112 + 8;
        uint64_t v113 = v45;
        long long v112 = xmmword_1CFB2EC40;
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
        {
          uint64_t v45 = __cxa_guard_acquire(&qword_1EBCBE588);
          if (v45)
          {
            unint64_t v110 = llvm::hashing::detail::fixed_seed_override;
            if (!llvm::hashing::detail::fixed_seed_override) {
              unint64_t v110 = 0xFF51AFD7ED558CCDLL;
            }
            qword_1EBCBE580 = v110;
            __cxa_guard_release(&qword_1EBCBE588);
          }
        }
        unint64_t v49 = 0x9DDFEA08EB382D69 * (*((void *)&v112 + 1) ^ qword_1EBCBE580 ^ __ROR8__(v113 + 16, 16));
        unint64_t v50 = __ROR8__(v113 + 16, 16) ^ (v49 >> 47);
        uint64_t v13 = *(void *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & ((-348639895
                                             * ((((0x9DDFEA08EB382D69 * (v50 ^ v49)) >> 32) >> 15) ^ (-348639895 * (v50 ^ v49)))) ^ v113));
        BOOL v14 = *(unsigned int **)v13;
        int v114 = v116;
        uint64_t v115 = 0x2000000000;
        if (v14) {
          BOOL v51 = (v14 & 1) == 0;
        }
        else {
          BOOL v51 = 0;
        }
        if (!v51) {
          goto LABEL_242;
        }
        while (1)
        {
          LOBYTE(v45) = sub_1CD071418(v45, v14, (uint64_t)&v111, v46, (unsigned int *)&v114);
          if (v45) {
            break;
          }
          LODWORD(v115) = 0;
          BOOL v14 = *(unsigned int **)v14;
          if (v14) {
            BOOL v52 = (v14 & 1) == 0;
          }
          else {
            BOOL v52 = 0;
          }
          if (!v52)
          {
            BOOL v14 = 0;
            goto LABEL_181;
          }
        }
        uint64_t v13 = 0;
LABEL_181:
        if (v114 == v116)
        {
          if (v14) {
            goto LABEL_183;
          }
        }
        else
        {
          free(v114);
          if (v14) {
            goto LABEL_183;
          }
        }
LABEL_242:
        if (!v48) {
          goto LABEL_250;
        }
        *(void *)(a1 + 888) += 32;
        uint64_t v102 = *(void *)(a1 + 808);
        if (((v102 + 7) & 0xFFFFFFFFFFFFFFF8) - v102 + 32 > *(void *)(a1 + 816) - v102)
        {
          unsigned int v106 = *(_DWORD *)(a1 + 832) >> 7;
          if (v106 >= 0x1E) {
            LOBYTE(v106) = 30;
          }
          uint64_t v107 = 4096 << v106;
          unint64_t v68 = (unint64_t)operator new(4096 << v106, (std::align_val_t)8uLL);
          unsigned int v108 = *(_DWORD *)(a1 + 832);
          if (v108 >= *(_DWORD *)(a1 + 836)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)(a1 + 824) + 8 * v108) = v68;
          ++*(_DWORD *)(a1 + 832);
          *(void *)(a1 + 816) = v68 + v107;
        }
        else
        {
          unint64_t v68 = (v102 + 7) & 0xFFFFFFFFFFFFFFF8;
        }
        *(void *)(a1 + 808) = v68 + 32;
        *(void *)unint64_t v68 = 0;
        uint64_t v5 = v68 + 8;
        *(unsigned char *)(v68 + 16) = 71;
        *(_WORD *)(v68 + 17) = *(_WORD *)(v68 + 17) & 0xF000 | 0x540;
        uint64_t v69 = &unk_1F261A180;
LABEL_246:
        *(void *)(v68 + 8) = v69;
        *(void *)(v68 + 24) = v9;
        unsigned int v103 = *(_DWORD *)(a1 + 916) + 1;
        int v104 = *(_DWORD *)(a1 + 912);
        if (v103 > 2 * v104)
        {
          llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v104, (uint64_t)off_1F2644D00);
          int v114 = v116;
          uint64_t v115 = 0x2000000000;
          sub_1CD0714B4((unsigned int *)v68, (unsigned int *)&v114);
          uint64_t v13 = *(void *)(a1 + 904)
              + 8
              * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v114, (uint64_t)v114 + 4 * v115));
          if (v114 != v116) {
            free(v114);
          }
          unsigned int v103 = *(_DWORD *)(a1 + 916) + 1;
        }
        *(_DWORD *)(a1 + 916) = v103;
        uint64_t v105 = *(void *)v13;
        if (!*(void *)v13) {
          uint64_t v105 = v13 | 1;
        }
        *(void *)unint64_t v68 = v105;
        *(void *)uint64_t v13 = v68;
        goto LABEL_251;
      case '_':
        if (v4 < 2 || strncmp("_Z", (const char *)v2 + 1, 2uLL)) {
          return 0;
        }
        *(void *)a1 = v2 + 3;
        uint64_t v5 = sub_1CD06E7AC((unsigned __int8 **)a1);
        if (!v5) {
          return v5;
        }
        unsigned int v44 = *(unsigned __int8 **)a1;
        if (*(void *)a1 == *(void *)(a1 + 8) || *v44 != 69) {
          return 0;
        }
        *(void *)a1 = v44 + 1;
        return v5;
      case 'a':
        *(void *)a1 = v2 + 2;
        unsigned int v32 = "signed char";
        uint64_t v33 = "";
        goto LABEL_126;
      case 'b':
        if (v4 < 3) {
          return 0;
        }
        if (!strncmp("b0E", (const char *)v2 + 1, 3uLL))
        {
          *(void *)a1 = v2 + 4;
          LODWORD(v114) = 0;
        }
        else
        {
          if (strncmp("b1E", (const char *)v2 + 1, 3uLL)) {
            return 0;
          }
          *(void *)a1 = v2 + 4;
          LODWORD(v114) = 1;
        }
        return sub_1CD081DD0(a1, &v114, v53, v54);
      case 'c':
        *(void *)a1 = v2 + 2;
        unsigned int v32 = "char";
        uint64_t v33 = "";
        goto LABEL_126;
      case 'd':
        uint64_t v34 = v2 + 2;
        *(void *)a1 = v2 + 2;
        if ((unint64_t)(v1 - (v2 + 2)) < 0x11) {
          return 0;
        }
        uint64_t v61 = 0;
        uint64_t v36 = v2 + 18;
        while (((char)v34[v61] & 0x80000000) == 0
             && (*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v34[v61] + 60) & 0x10000) != 0)
        {
          if (++v61 == 16)
          {
            *(void *)a1 = v36;
            if (v36 == v1 || *v36 != 69) {
              return 0;
            }
            *(void *)a1 = v2 + 19;
            int v62 = *(unsigned __int8 *)(a1 + 937);
            BOOL v111 = (char *)&v112 + 8;
            long long v112 = xmmword_1CFB2EC70;
            llvm::FoldingSetNodeID::AddString((unsigned int *)&v111, v34, 0x10u);
            unint64_t v63 = sub_1CC13A6B8(v111, (uint64_t)v111 + 4 * v112);
            uint64_t v40 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v63);
            BOOL v14 = *(unsigned int **)v40;
            int v114 = v116;
            uint64_t v115 = 0x2000000000;
            if (v14) {
              BOOL v65 = (v14 & 1) == 0;
            }
            else {
              BOOL v65 = 0;
            }
            if (v65)
            {
              while (1)
              {
                LOBYTE(v63) = sub_1CD071418(v63, v14, (uint64_t)&v111, v64, (unsigned int *)&v114);
                if (v63) {
                  break;
                }
                LODWORD(v115) = 0;
                BOOL v14 = *(unsigned int **)v14;
                if (v14) {
                  BOOL v66 = (v14 & 1) == 0;
                }
                else {
                  BOOL v66 = 0;
                }
                if (!v66)
                {
                  BOOL v14 = 0;
                  goto LABEL_170;
                }
              }
              uint64_t v40 = 0;
LABEL_170:
              if (v114 == v116)
              {
                if (v14) {
                  goto LABEL_183;
                }
              }
              else
              {
                free(v114);
                if (v14) {
                  goto LABEL_183;
                }
              }
            }
            if (!v62) {
              goto LABEL_250;
            }
            *(void *)(a1 + 888) += 40;
            uint64_t v74 = *(void *)(a1 + 808);
            if (((v74 + 7) & 0xFFFFFFFFFFFFFFF8) - v74 + 40 > *(void *)(a1 + 816) - v74)
            {
              unsigned int v99 = *(_DWORD *)(a1 + 832) >> 7;
              if (v99 >= 0x1E) {
                LOBYTE(v99) = 30;
              }
              uint64_t v100 = 4096 << v99;
              unint64_t v71 = (unint64_t)operator new(4096 << v99, (std::align_val_t)8uLL);
              unsigned int v101 = *(_DWORD *)(a1 + 832);
              if (v101 >= *(_DWORD *)(a1 + 836)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *(void *)(*(void *)(a1 + 824) + 8 * v101) = v71;
              ++*(_DWORD *)(a1 + 832);
              *(void *)(a1 + 816) = v71 + v100;
            }
            else
            {
              unint64_t v71 = (v74 + 7) & 0xFFFFFFFFFFFFFFF8;
            }
            *(void *)(a1 + 808) = v71 + 40;
            *(void *)unint64_t v71 = 0;
            uint64_t v5 = v71 + 8;
            *(unsigned char *)(v71 + 16) = 75;
            *(_WORD *)(v71 + 17) = *(_WORD *)(v71 + 17) & 0xF000 | 0x540;
            unsigned int v72 = &unk_1F2619E10;
            goto LABEL_176;
          }
        }
        return 0;
      case 'e':
        uint64_t v34 = v2 + 2;
        *(void *)a1 = v2 + 2;
        if ((unint64_t)(v1 - (v2 + 2)) < 0x21) {
          return 0;
        }
        uint64_t v55 = 0;
        uint64_t v36 = v2 + 34;
        while (((char)v34[v55] & 0x80000000) == 0
             && (*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v34[v55] + 60) & 0x10000) != 0)
        {
          if (++v55 == 32)
          {
            *(void *)a1 = v36;
            if (v36 == v1 || *v36 != 69) {
              return 0;
            }
            *(void *)a1 = v2 + 35;
            int v56 = *(unsigned __int8 *)(a1 + 937);
            BOOL v111 = (char *)&v112 + 8;
            long long v112 = xmmword_1CFB2EC60;
            llvm::FoldingSetNodeID::AddString((unsigned int *)&v111, v34, 0x20u);
            unint64_t v57 = sub_1CC13A6B8(v111, (uint64_t)v111 + 4 * v112);
            uint64_t v40 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v57);
            BOOL v14 = *(unsigned int **)v40;
            int v114 = v116;
            uint64_t v115 = 0x2000000000;
            if (v14) {
              BOOL v59 = (v14 & 1) == 0;
            }
            else {
              BOOL v59 = 0;
            }
            if (v59)
            {
              while (1)
              {
                LOBYTE(v57) = sub_1CD071418(v57, v14, (uint64_t)&v111, v58, (unsigned int *)&v114);
                if (v57) {
                  break;
                }
                LODWORD(v115) = 0;
                BOOL v14 = *(unsigned int **)v14;
                if (v14) {
                  BOOL v60 = (v14 & 1) == 0;
                }
                else {
                  BOOL v60 = 0;
                }
                if (!v60)
                {
                  BOOL v14 = 0;
                  goto LABEL_163;
                }
              }
              uint64_t v40 = 0;
LABEL_163:
              if (v114 == v116)
              {
                if (v14) {
                  goto LABEL_183;
                }
              }
              else
              {
                free(v114);
                if (v14) {
                  goto LABEL_183;
                }
              }
            }
            if (!v56) {
              goto LABEL_250;
            }
            *(void *)(a1 + 888) += 40;
            uint64_t v73 = *(void *)(a1 + 808);
            if (((v73 + 7) & 0xFFFFFFFFFFFFFFF8) - v73 + 40 > *(void *)(a1 + 816) - v73)
            {
              unsigned int v96 = *(_DWORD *)(a1 + 832) >> 7;
              if (v96 >= 0x1E) {
                LOBYTE(v96) = 30;
              }
              uint64_t v97 = 4096 << v96;
              unint64_t v71 = (unint64_t)operator new(4096 << v96, (std::align_val_t)8uLL);
              unsigned int v98 = *(_DWORD *)(a1 + 832);
              if (v98 >= *(_DWORD *)(a1 + 836)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *(void *)(*(void *)(a1 + 824) + 8 * v98) = v71;
              ++*(_DWORD *)(a1 + 832);
              *(void *)(a1 + 816) = v71 + v97;
            }
            else
            {
              unint64_t v71 = (v73 + 7) & 0xFFFFFFFFFFFFFFF8;
            }
            *(void *)(a1 + 808) = v71 + 40;
            *(void *)unint64_t v71 = 0;
            uint64_t v5 = v71 + 8;
            *(unsigned char *)(v71 + 16) = 76;
            *(_WORD *)(v71 + 17) = *(_WORD *)(v71 + 17) & 0xF000 | 0x540;
            unsigned int v72 = &unk_1F2619E68;
            goto LABEL_176;
          }
        }
        return 0;
      case 'f':
        uint64_t v34 = v2 + 2;
        *(void *)a1 = v2 + 2;
        if ((unint64_t)(v1 - (v2 + 2)) < 9) {
          return 0;
        }
        uint64_t v35 = 0;
        uint64_t v36 = v2 + 10;
        break;
      case 'h':
        *(void *)a1 = v2 + 2;
        unsigned int v32 = "unsigned char";
        uint64_t v33 = "";
        goto LABEL_126;
      case 'i':
        *(void *)a1 = v2 + 2;
        unsigned int v32 = "";
        uint64_t v33 = "";
        goto LABEL_126;
      case 'j':
        *(void *)a1 = v2 + 2;
        unsigned int v32 = "u";
        goto LABEL_99;
      case 'l':
        *(void *)a1 = v2 + 2;
        unsigned int v32 = "l";
LABEL_99:
        uint64_t v33 = v32 + 1;
        goto LABEL_126;
      case 'm':
        *(void *)a1 = v2 + 2;
        unsigned int v32 = "ul";
        goto LABEL_101;
      case 'n':
        *(void *)a1 = v2 + 2;
        unsigned int v32 = "__int128";
        uint64_t v33 = "";
        goto LABEL_126;
      case 'o':
        *(void *)a1 = v2 + 2;
        unsigned int v32 = "unsigned __int128";
        uint64_t v33 = "";
        goto LABEL_126;
      case 's':
        *(void *)a1 = v2 + 2;
        unsigned int v32 = "short";
        uint64_t v33 = "";
        goto LABEL_126;
      case 't':
        *(void *)a1 = v2 + 2;
        unsigned int v32 = "unsigned short";
        uint64_t v33 = "";
        goto LABEL_126;
      case 'w':
        *(void *)a1 = v2 + 2;
        unsigned int v32 = "wchar_t";
        uint64_t v33 = "";
        goto LABEL_126;
      case 'x':
        *(void *)a1 = v2 + 2;
        unsigned int v32 = "ll";
LABEL_101:
        uint64_t v33 = v32 + 2;
        goto LABEL_126;
      case 'y':
        *(void *)a1 = v2 + 2;
        unsigned int v32 = "ull";
        uint64_t v33 = "";
LABEL_126:
        return sub_1CD0819FC(a1, (unsigned __int8 *)v32, (uint64_t)v33);
      default:
        goto LABEL_20;
    }
    do
    {
      if ((char)v34[v35] < 0 || (*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v34[v35] + 60) & 0x10000) == 0) {
        return 0;
      }
      ++v35;
    }
    while (v35 != 8);
    *(void *)a1 = v36;
    if (v36 == v1 || *v36 != 69) {
      return 0;
    }
    *(void *)a1 = v2 + 11;
    int v37 = *(unsigned __int8 *)(a1 + 937);
    BOOL v111 = (char *)&v112 + 8;
    long long v112 = xmmword_1CFB2EC80;
    llvm::FoldingSetNodeID::AddString((unsigned int *)&v111, v34, 8u);
    unint64_t v38 = sub_1CC13A6B8(v111, (uint64_t)v111 + 4 * v112);
    uint64_t v40 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v38);
    BOOL v14 = *(unsigned int **)v40;
    int v114 = v116;
    uint64_t v115 = 0x2000000000;
    if (v14) {
      BOOL v41 = (v14 & 1) == 0;
    }
    else {
      BOOL v41 = 0;
    }
    if (!v41) {
      goto LABEL_158;
    }
    while (1)
    {
      LOBYTE(v38) = sub_1CD071418(v38, v14, (uint64_t)&v111, v39, (unsigned int *)&v114);
      if (v38) {
        break;
      }
      LODWORD(v115) = 0;
      BOOL v14 = *(unsigned int **)v14;
      if (v14) {
        BOOL v42 = (v14 & 1) == 0;
      }
      else {
        BOOL v42 = 0;
      }
      if (!v42)
      {
        BOOL v14 = 0;
        goto LABEL_156;
      }
    }
    uint64_t v40 = 0;
LABEL_156:
    if (v114 == v116)
    {
      if (!v14)
      {
LABEL_158:
        if (v37)
        {
          *(void *)(a1 + 888) += 40;
          uint64_t v70 = *(void *)(a1 + 808);
          if (((v70 + 7) & 0xFFFFFFFFFFFFFFF8) - v70 + 40 > *(void *)(a1 + 816) - v70)
          {
            unsigned int v93 = *(_DWORD *)(a1 + 832) >> 7;
            if (v93 >= 0x1E) {
              LOBYTE(v93) = 30;
            }
            uint64_t v94 = 4096 << v93;
            unint64_t v71 = (unint64_t)operator new(4096 << v93, (std::align_val_t)8uLL);
            unsigned int v95 = *(_DWORD *)(a1 + 832);
            if (v95 >= *(_DWORD *)(a1 + 836)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(*(void *)(a1 + 824) + 8 * v95) = v71;
            ++*(_DWORD *)(a1 + 832);
            *(void *)(a1 + 816) = v71 + v94;
          }
          else
          {
            unint64_t v71 = (v70 + 7) & 0xFFFFFFFFFFFFFFF8;
          }
          *(void *)(a1 + 808) = v71 + 40;
          *(void *)unint64_t v71 = 0;
          uint64_t v5 = v71 + 8;
          *(unsigned char *)(v71 + 16) = 74;
          *(_WORD *)(v71 + 17) = *(_WORD *)(v71 + 17) & 0xF000 | 0x540;
          unsigned int v72 = &unk_1F2619DB8;
LABEL_176:
          *(void *)(v71 + 8) = v72;
          *(void *)(v71 + 24) = v34;
          *(void *)(v71 + 32) = v36;
          unsigned int v75 = *(_DWORD *)(a1 + 916) + 1;
          int v76 = *(_DWORD *)(a1 + 912);
          if (v75 > 2 * v76)
          {
            llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v76, (uint64_t)off_1F2644D00);
            int v114 = v116;
            uint64_t v115 = 0x2000000000;
            sub_1CD0714B4((unsigned int *)v71, (unsigned int *)&v114);
            uint64_t v40 = *(void *)(a1 + 904)
                + 8
                * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v114, (uint64_t)v114 + 4 * v115));
            if (v114 != v116) {
              free(v114);
            }
            unsigned int v75 = *(_DWORD *)(a1 + 916) + 1;
          }
          *(_DWORD *)(a1 + 916) = v75;
          uint64_t v77 = *(void *)v40;
          if (!*(void *)v40) {
            uint64_t v77 = v40 | 1;
          }
          *(void *)unint64_t v71 = v77;
          *(void *)uint64_t v40 = v71;
        }
        else
        {
LABEL_250:
          uint64_t v5 = 0;
        }
LABEL_251:
        int v31 = 1;
LABEL_252:
        BOOL v86 = v111;
        if (v111 != (char *)&v112 + 8) {
          goto LABEL_199;
        }
        goto LABEL_200;
      }
    }
    else
    {
      free(v114);
      if (!v14) {
        goto LABEL_158;
      }
    }
LABEL_183:
    int v31 = 0;
    uint64_t v5 = (uint64_t)(v14 + 2);
    goto LABEL_252;
  }
LABEL_20:
  uint64_t v17 = sub_1CD06B2C4(a1);
  if (!v17) {
    return 0;
  }
  uint64_t v18 = v17;
  uint64_t v19 = (unsigned __int8 *)sub_1CC6B5BE0((char **)a1, 1);
  if (v20 == v19) {
    return 0;
  }
  __int16 v21 = *(unsigned __int8 **)a1;
  if (*(void *)a1 == *(void *)(a1 + 8) || *v21 != 69) {
    return 0;
  }
  long long v22 = v19;
  unsigned int v23 = v20;
  *(void *)a1 = v21 + 1;
  int v24 = *(unsigned __int8 *)(a1 + 937);
  BOOL v111 = (char *)&v112 + 8;
  uint64_t v113 = v18;
  long long v112 = xmmword_1CFB2EC90;
  llvm::FoldingSetNodeID::AddString((unsigned int *)&v111, v19, v20 - v19);
  unint64_t v25 = sub_1CC13A6B8(v111, (uint64_t)v111 + 4 * v112);
  uint64_t v27 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v25);
  uint64_t v28 = *(unsigned int **)v27;
  int v114 = v116;
  uint64_t v115 = 0x2000000000;
  if (v28) {
    BOOL v29 = (v28 & 1) == 0;
  }
  else {
    BOOL v29 = 0;
  }
  if (!v29) {
    goto LABEL_189;
  }
  while (1)
  {
    LOBYTE(v25) = sub_1CD071418(v25, v28, (uint64_t)&v111, v26, (unsigned int *)&v114);
    if (v25) {
      break;
    }
    LODWORD(v115) = 0;
    uint64_t v28 = *(unsigned int **)v28;
    if (v28) {
      BOOL v30 = (v28 & 1) == 0;
    }
    else {
      BOOL v30 = 0;
    }
    if (!v30)
    {
      uint64_t v28 = 0;
      goto LABEL_36;
    }
  }
  uint64_t v27 = 0;
LABEL_36:
  if (v114 != v116)
  {
    free(v114);
    if (v28) {
      goto LABEL_38;
    }
LABEL_189:
    if (v24)
    {
      *(void *)(a1 + 888) += 48;
      uint64_t v81 = *(void *)(a1 + 808);
      if (((v81 + 7) & 0xFFFFFFFFFFFFFFF8) - v81 + 48 > *(void *)(a1 + 816) - v81)
      {
        unsigned int v89 = *(_DWORD *)(a1 + 832) >> 7;
        if (v89 >= 0x1E) {
          LOBYTE(v89) = 30;
        }
        uint64_t v90 = 4096 << v89;
        unint64_t v82 = (unint64_t)operator new(4096 << v89, (std::align_val_t)8uLL);
        unsigned int v91 = *(_DWORD *)(a1 + 832);
        if (v91 >= *(_DWORD *)(a1 + 836)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 824) + 8 * v91) = v82;
        ++*(_DWORD *)(a1 + 832);
        *(void *)(a1 + 816) = v82 + v90;
      }
      else
      {
        unint64_t v82 = (v81 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(a1 + 808) = v82 + 48;
      uint64_t v5 = v82 + 8;
      *(unsigned char *)(v82 + 16) = 72;
      *(_WORD *)(v82 + 17) = *(_WORD *)(v82 + 17) & 0xF000 | 0x540;
      *(void *)unint64_t v82 = 0;
      *(void *)(v82 + 8) = &unk_1F261A1D8;
      *(void *)(v82 + 24) = v18;
      *(void *)(v82 + 32) = v22;
      *(void *)(v82 + 40) = v23;
      unsigned int v83 = *(_DWORD *)(a1 + 916) + 1;
      int v84 = *(_DWORD *)(a1 + 912);
      if (v83 > 2 * v84)
      {
        uint64_t v92 = (unsigned int *)v82;
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v84, (uint64_t)off_1F2644D00);
        int v114 = v116;
        uint64_t v115 = 0x2000000000;
        sub_1CD0714B4(v92, (unsigned int *)&v114);
        uint64_t v27 = *(void *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v114, (uint64_t)v114 + 4 * v115));
        if (v114 != v116) {
          free(v114);
        }
        unsigned int v83 = *(_DWORD *)(a1 + 916) + 1;
        unint64_t v82 = (unint64_t)v92;
      }
      *(_DWORD *)(a1 + 916) = v83;
      uint64_t v85 = *(void *)v27;
      if (!*(void *)v27) {
        uint64_t v85 = v27 | 1;
      }
      *(void *)unint64_t v82 = v85;
      *(void *)uint64_t v27 = v82;
    }
    else
    {
      uint64_t v5 = 0;
    }
    int v31 = 1;
    goto LABEL_198;
  }
  if (!v28) {
    goto LABEL_189;
  }
LABEL_38:
  int v31 = 0;
  uint64_t v5 = (uint64_t)(v28 + 2);
LABEL_198:
  BOOL v86 = v111;
  if (v111 != (char *)&v112 + 8) {
LABEL_199:
  }
    free(v86);
LABEL_200:
  if (v31)
  {
    *(void *)(a1 + 920) = v5;
  }
  else if (v5)
  {
    int v114 = 0;
    int v87 = sub_1CD640748(a1 + 944, v5, &v114);
    uint64_t v88 = 0;
    if (v87) {
      uint64_t v88 = *((void *)v114 + 1);
    }
    if (v88) {
      uint64_t v5 = v88;
    }
    if (v5 == *(void *)(a1 + 928)) {
      *(unsigned char *)(a1 + 936) = 1;
    }
  }
  return v5;
}

uint64_t sub_1CD08057C(uint64_t a1)
{
  int v2 = *(const char **)a1;
  unint64_t v3 = *(void *)(a1 + 8) - *(void *)a1;
  if (v3 < 3)
  {
    if (v3 != 2) {
      return 0;
    }
LABEL_5:
    if (!strncmp("fp", v2, 2uLL))
    {
      uint64_t v7 = (char *)(v2 + 2);
    }
    else
    {
      if (strncmp("fL", v2, 2uLL)) {
        return 0;
      }
      *(void *)a1 = v2 + 2;
      unint64_t v4 = sub_1CC6B5BE0((char **)a1, 0);
      if (v4 == v5) {
        return 0;
      }
      uint64_t v6 = *(char **)a1;
      if (*(void *)a1 == *(void *)(a1 + 8) || *v6 != 112) {
        return 0;
      }
      uint64_t v7 = v6 + 1;
    }
    *(void *)a1 = v7;
    sub_1CC6B8620(a1);
    *(void *)&long long v11 = sub_1CC6B5BE0((char **)a1, 0);
    *((void *)&v11 + 1) = v8;
    uint64_t v9 = *(char **)a1;
    if (*(void *)a1 != *(void *)(a1 + 8) && *v9 == 95)
    {
      *(void *)a1 = v9 + 1;
      return sub_1CD0842D8(a1, &v11);
    }
    return 0;
  }
  if (strncmp("fpT", v2, 3uLL)) {
    goto LABEL_5;
  }
  *(void *)a1 = v2 + 3;

  return sub_1CD06AF4C(a1, "this");
}

uint64_t sub_1CD0806CC(uint64_t a1)
{
  v42[16] = *MEMORY[0x1E4F143B8];
  int v2 = *(unsigned char **)a1;
  if (*(void *)(a1 + 8) - *(void *)a1 < 2uLL || *v2 != 100) {
    goto LABEL_9;
  }
  int v3 = (char)v2[1];
  switch(v3)
  {
    case 'X':
      *(void *)a1 = v2 + 2;
      uint64_t v6 = sub_1CD077868(a1);
      if (!v6) {
        return 0;
      }
      uint64_t v7 = v6;
      uint64_t v8 = sub_1CD077868(a1);
      if (!v8) {
        return 0;
      }
      uint64_t v9 = v8;
      uint64_t v10 = sub_1CD0806CC(a1);
      if (!v10) {
        return 0;
      }
      uint64_t v12 = v10;
      int v13 = *(unsigned __int8 *)(a1 + 937);
      uint64_t v35 = (char *)&v36 + 8;
      uint64_t v37 = v7;
      uint64_t v38 = v9;
      uint64_t v39 = v10;
      long long v36 = xmmword_1CFB2ECA0;
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
      {
        uint64_t v10 = __cxa_guard_acquire(&qword_1EBCBE588);
        if (v10)
        {
          unint64_t v33 = llvm::hashing::detail::fixed_seed_override;
          if (!llvm::hashing::detail::fixed_seed_override) {
            unint64_t v33 = 0xFF51AFD7ED558CCDLL;
          }
          qword_1EBCBE580 = v33;
          __cxa_guard_release(&qword_1EBCBE588);
        }
      }
      uint64_t v14 = __ROR8__(0xB492B66FBE98F273 * *((void *)&v36 + 1) - v37, 43)
          - 0x3C5A37A36834CED9 * v38
          + __ROR8__((0x9AE16A3B2F90404FLL * v39) ^ qword_1EBCBE580, 30);
      unint64_t v15 = qword_1EBCBE580
          + __ROR8__(v37 ^ 0xC949D7C7509E6557, 20)
          - 0x4B6D499041670D8DLL * *((void *)&v36 + 1)
          - 0x9AE16A3B2F90404FLL * v39
          + 32;
      unint64_t v16 = 0x9DDFEA08EB382D69
          * (v15 ^ ((0x9DDFEA08EB382D69 * (v14 ^ v15)) >> 47) ^ (0x9DDFEA08EB382D69 * (v14 ^ v15)));
      uint64_t v17 = *(void *)(a1 + 904)
          + 8 * ((-348639895 * ((v16 >> 47) ^ v16)) & (*(_DWORD *)(a1 + 912) - 1));
      uint64_t v18 = *(unsigned int **)v17;
      uint64_t v40 = v42;
      uint64_t v41 = 0x2000000000;
      if (v18) {
        BOOL v19 = (v18 & 1) == 0;
      }
      else {
        BOOL v19 = 0;
      }
      if (!v19) {
        goto LABEL_38;
      }
      while (1)
      {
        LOBYTE(v10) = sub_1CD071418(v10, v18, (uint64_t)&v35, v11, (unsigned int *)&v40);
        if (v10) {
          break;
        }
        LODWORD(v41) = 0;
        uint64_t v18 = *(unsigned int **)v18;
        if (v18) {
          BOOL v20 = (v18 & 1) == 0;
        }
        else {
          BOOL v20 = 0;
        }
        if (!v20)
        {
          uint64_t v18 = 0;
          goto LABEL_34;
        }
      }
      uint64_t v17 = 0;
LABEL_34:
      if (v40 == v42)
      {
        if (v18)
        {
LABEL_36:
          int v21 = 0;
          uint64_t v5 = (uint64_t)(v18 + 2);
LABEL_47:
          if (v35 != (char *)&v36 + 8) {
            free(v35);
          }
          if (v21)
          {
            *(void *)(a1 + 920) = v5;
          }
          else if (v5)
          {
            uint64_t v40 = 0;
            int v27 = sub_1CD640748(a1 + 944, v5, &v40);
            uint64_t v28 = 0;
            if (v27) {
              uint64_t v28 = v40[1];
            }
            if (v28) {
              uint64_t v5 = v28;
            }
            if (v5 == *(void *)(a1 + 928)) {
              *(unsigned char *)(a1 + 936) = 1;
            }
          }
          return v5;
        }
      }
      else
      {
        free(v40);
        if (v18) {
          goto LABEL_36;
        }
      }
LABEL_38:
      if (v13)
      {
        *(void *)(a1 + 888) += 48;
        uint64_t v22 = *(void *)(a1 + 808);
        if (((v22 + 7) & 0xFFFFFFFFFFFFFFF8) - v22 + 48 > *(void *)(a1 + 816) - v22)
        {
          unsigned int v29 = *(_DWORD *)(a1 + 832) >> 7;
          if (v29 >= 0x1E) {
            LOBYTE(v29) = 30;
          }
          uint64_t v30 = 4096 << v29;
          unint64_t v23 = (unint64_t)operator new(4096 << v29, (std::align_val_t)8uLL);
          unsigned int v31 = *(_DWORD *)(a1 + 832);
          if (v31 >= *(_DWORD *)(a1 + 836)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)(a1 + 824) + 8 * v31) = v23;
          ++*(_DWORD *)(a1 + 832);
          *(void *)(a1 + 816) = v23 + v30;
        }
        else
        {
          unint64_t v23 = (v22 + 7) & 0xFFFFFFFFFFFFFFF8;
        }
        *(void *)(a1 + 808) = v23 + 48;
        uint64_t v5 = v23 + 8;
        *(unsigned char *)(v23 + 16) = 78;
        *(_WORD *)(v23 + 17) = *(_WORD *)(v23 + 17) & 0xF000 | 0x540;
        *(void *)unint64_t v23 = 0;
        *(void *)(v23 + 8) = &unk_1F261A390;
        *(void *)(v23 + 24) = v7;
        *(void *)(v23 + 32) = v9;
        *(void *)(v23 + 40) = v12;
        unsigned int v24 = *(_DWORD *)(a1 + 916) + 1;
        int v25 = *(_DWORD *)(a1 + 912);
        if (v24 > 2 * v25)
        {
          unsigned int v32 = (unsigned int *)v23;
          llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v25, (uint64_t)off_1F2644D00);
          uint64_t v40 = v42;
          uint64_t v41 = 0x2000000000;
          sub_1CD0714B4(v32, (unsigned int *)&v40);
          uint64_t v17 = *(void *)(a1 + 904)
              + 8
              * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v40, (uint64_t)v40 + 4 * v41));
          if (v40 != v42) {
            free(v40);
          }
          unsigned int v24 = *(_DWORD *)(a1 + 916) + 1;
          unint64_t v23 = (unint64_t)v32;
        }
        *(_DWORD *)(a1 + 916) = v24;
        uint64_t v26 = *(void *)v17;
        if (!*(void *)v17) {
          uint64_t v26 = v17 | 1;
        }
        *(void *)unint64_t v23 = v26;
        *(void *)uint64_t v17 = v23;
      }
      else
      {
        uint64_t v5 = 0;
      }
      int v21 = 1;
      goto LABEL_47;
    case 'x':
      *(void *)a1 = v2 + 2;
      uint64_t v40 = (void *)sub_1CD077868(a1);
      if (v40)
      {
        uint64_t v35 = (void *)sub_1CD0806CC(a1);
        if (v35)
        {
          char v34 = 1;
          return sub_1CD084640(a1, (uint64_t *)&v40, (uint64_t *)&v35, &v34);
        }
      }
      return 0;
    case 'i':
      *(void *)a1 = v2 + 2;
      uint64_t v40 = (void *)sub_1CD081610(a1);
      if (v40)
      {
        uint64_t v35 = (void *)sub_1CD0806CC(a1);
        if (v35)
        {
          char v34 = 0;
          return sub_1CD084640(a1, (uint64_t *)&v40, (uint64_t *)&v35, &v34);
        }
      }
      return 0;
  }
LABEL_9:

  return sub_1CD077868(a1);
}

uint64_t sub_1CD080CA4(uint64_t a1, uint64_t *a2)
{
  v31[16] = *MEMORY[0x1E4F143B8];
  int v4 = *(unsigned __int8 *)(a1 + 937);
  int v27 = &v28[2];
  uint64_t v5 = *a2;
  *(_OWORD *)uint64_t v28 = xmmword_1CFB2EBC0;
  llvm::FoldingSetNodeID::AddString((unsigned int *)&v27, "sizeof... ", 0xAu);
  if (v28[0] >= v28[1]) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((_DWORD *)v27 + v28[0]) = v5;
  unsigned int v6 = v28[0] + 1;
  v28[0] = v6;
  if (v6 >= v28[1]) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((_DWORD *)v27 + v6) = HIDWORD(v5);
  ++v28[0];
  unint64_t v7 = sub_1CC13A6B8(v27, (uint64_t)v27 + 4 * v28[0]);
  uint64_t v9 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v7);
  uint64_t v10 = *(unsigned int **)v9;
  unsigned int v29 = v31;
  uint64_t v30 = 0x2000000000;
  if (v10) {
    BOOL v11 = (v10 & 1) == 0;
  }
  else {
    BOOL v11 = 0;
  }
  if (!v11) {
    goto LABEL_19;
  }
  while (1)
  {
    LOBYTE(v7) = sub_1CD071418(v7, v10, (uint64_t)&v27, v8, (unsigned int *)&v29);
    if (v7) {
      break;
    }
    LODWORD(v30) = 0;
    uint64_t v10 = *(unsigned int **)v10;
    if (v10) {
      BOOL v12 = (v10 & 1) == 0;
    }
    else {
      BOOL v12 = 0;
    }
    if (!v12)
    {
      uint64_t v10 = 0;
      goto LABEL_15;
    }
  }
  uint64_t v9 = 0;
LABEL_15:
  if (v29 == v31)
  {
    if (v10)
    {
LABEL_17:
      int v13 = 0;
      uint64_t v14 = (uint64_t)(v10 + 2);
      goto LABEL_28;
    }
  }
  else
  {
    free(v29);
    if (v10) {
      goto LABEL_17;
    }
  }
LABEL_19:
  if (v4)
  {
    *(void *)(a1 + 888) += 64;
    uint64_t v15 = *(void *)(a1 + 808);
    if (((v15 + 7) & 0xFFFFFFFFFFFFFFF8) - v15 + 64 > *(void *)(a1 + 816) - v15)
    {
      unsigned int v24 = *(_DWORD *)(a1 + 832) >> 7;
      if (v24 >= 0x1E) {
        LOBYTE(v24) = 30;
      }
      uint64_t v25 = 4096 << v24;
      unint64_t v16 = (unint64_t)operator new(4096 << v24, (std::align_val_t)8uLL);
      unsigned int v26 = *(_DWORD *)(a1 + 832);
      if (v26 >= *(_DWORD *)(a1 + 836)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(a1 + 824) + 8 * v26) = v16;
      ++*(_DWORD *)(a1 + 832);
      *(void *)(a1 + 816) = v16 + v25;
    }
    else
    {
      unint64_t v16 = (v15 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    *(void *)(a1 + 808) = v16 + 64;
    *(void *)unint64_t v16 = 0;
    uint64_t v14 = v16 + 8;
    uint64_t v17 = *a2;
    *(unsigned char *)(v16 + 16) = 56;
    *(_WORD *)(v16 + 17) = *(_WORD *)(v16 + 17) & 0xF000 | 0x540;
    *(void *)(v16 + 8) = &unk_1F2619CB0;
    *(void *)(v16 + 24) = "sizeof... ";
    *(void *)(v16 + 32) = "";
    *(void *)(v16 + 48) = 0;
    *(void *)(v16 + 56) = 0;
    *(void *)(v16 + 40) = v17;
    unsigned int v18 = *(_DWORD *)(a1 + 916) + 1;
    int v19 = *(_DWORD *)(a1 + 912);
    if (v18 > 2 * v19)
    {
      llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v19, (uint64_t)off_1F2644D00);
      unsigned int v29 = v31;
      uint64_t v30 = 0x2000000000;
      sub_1CD0714B4((unsigned int *)v16, (unsigned int *)&v29);
      uint64_t v9 = *(void *)(a1 + 904)
         + 8 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v29, (uint64_t)v29 + 4 * v30));
      if (v29 != v31) {
        free(v29);
      }
      unsigned int v18 = *(_DWORD *)(a1 + 916) + 1;
    }
    *(_DWORD *)(a1 + 916) = v18;
    uint64_t v20 = *(void *)v9;
    if (!*(void *)v9) {
      uint64_t v20 = v9 | 1;
    }
    *(void *)unint64_t v16 = v20;
    *(void *)uint64_t v9 = v16;
  }
  else
  {
    uint64_t v14 = 0;
  }
  int v13 = 1;
LABEL_28:
  if (v27 != &v28[2]) {
    free(v27);
  }
  if (v13)
  {
    *(void *)(a1 + 920) = v14;
  }
  else if (v14)
  {
    unsigned int v29 = 0;
    int v22 = sub_1CD640748(a1 + 944, v14, &v29);
    uint64_t v23 = 0;
    if (v22) {
      uint64_t v23 = *((void *)v29 + 1);
    }
    if (v23) {
      uint64_t v14 = v23;
    }
    if (v14 == *(void *)(a1 + 928)) {
      *(unsigned char *)(a1 + 936) = 1;
    }
  }
  return v14;
}

uint64_t sub_1CD0810A0(uint64_t a1)
{
  v44[16] = *MEMORY[0x1E4F143B8];
  int v3 = *(unsigned __int8 **)a1;
  int v2 = *(unsigned __int8 **)(a1 + 8);
  if (v2 == *(unsigned __int8 **)a1)
  {
LABEL_10:
    return sub_1CD06B2C4(a1);
  }
  int v4 = (char)*v3;
  if (v4 == 74)
  {
    uint64_t v9 = v3 + 1;
    *(void *)a1 = v9;
    uint64_t v10 = (uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 3;
    while (v9 == v2 || *v9 != 69)
    {
      uint64_t v11 = sub_1CD0810A0(a1);
      if (!v11) {
        return 0;
      }
      uint64_t v12 = v11;
      int v13 = *(uint64_t **)(a1 + 24);
      if (v13 == *(uint64_t **)(a1 + 32))
      {
        sub_1CD5F0ACC(a1 + 16, ((uint64_t)v13 - *(void *)(a1 + 16)) >> 2);
        int v13 = *(uint64_t **)(a1 + 24);
      }
      *(void *)(a1 + 24) = v13 + 1;
      uint64_t *v13 = v12;
      uint64_t v9 = *(unsigned __int8 **)a1;
      int v2 = *(unsigned __int8 **)(a1 + 8);
    }
    *(void *)a1 = v9 + 1;
    uint64_t v14 = *(void *)(a1 + 24);
    uint64_t v15 = (const void *)(*(void *)(a1 + 16) + 8 * v10);
    unint64_t v16 = (uint64_t *)sub_1CB906F34((uint64_t *)(a1 + 808), v14 - (void)v15, 3);
    uint64_t v17 = v16;
    int64_t v18 = v14 - (void)v15;
    if (v18) {
      memmove(v16, v15, v18);
    }
    uint64_t v19 = v18 >> 3;
    *(void *)(a1 + 24) = *(void *)(a1 + 16) + 8 * v10;
    int v20 = *(unsigned __int8 *)(a1 + 937);
    uint64_t v39 = v41;
    uint64_t v40 = 0x2000000000;
    sub_1CD074590((uint64_t)&v39, 37, v17, v19);
    unint64_t v21 = sub_1CC13A6B8(v39, (uint64_t)v39 + 4 * v40);
    uint64_t v23 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v21);
    unsigned int v24 = *(unsigned int **)v23;
    BOOL v42 = v44;
    uint64_t v43 = 0x2000000000;
    if (v24) {
      BOOL v25 = (v24 & 1) == 0;
    }
    else {
      BOOL v25 = 0;
    }
    if (!v25) {
      goto LABEL_46;
    }
    while (1)
    {
      LOBYTE(v21) = sub_1CD071418(v21, v24, (uint64_t)&v39, v22, (unsigned int *)&v42);
      if (v21) {
        break;
      }
      LODWORD(v43) = 0;
      unsigned int v24 = *(unsigned int **)v24;
      if (v24) {
        BOOL v26 = (v24 & 1) == 0;
      }
      else {
        BOOL v26 = 0;
      }
      if (!v26)
      {
        unsigned int v24 = 0;
        goto LABEL_42;
      }
    }
    uint64_t v23 = 0;
LABEL_42:
    if (v42 == v44)
    {
      if (v24)
      {
LABEL_44:
        int v27 = 0;
        uint64_t v6 = (uint64_t)(v24 + 2);
LABEL_55:
        if (v39 != v41) {
          free(v39);
        }
        if (v27)
        {
          *(void *)(a1 + 920) = v6;
        }
        else if (v6)
        {
          BOOL v42 = 0;
          int v33 = sub_1CD640748(a1 + 944, v6, &v42);
          uint64_t v34 = 0;
          if (v33) {
            uint64_t v34 = *((void *)v42 + 1);
          }
          if (v34) {
            uint64_t v6 = v34;
          }
          if (v6 == *(void *)(a1 + 928)) {
            *(unsigned char *)(a1 + 936) = 1;
          }
        }
        return v6;
      }
    }
    else
    {
      free(v42);
      if (v24) {
        goto LABEL_44;
      }
    }
LABEL_46:
    if (v20)
    {
      *(void *)(a1 + 888) += 40;
      uint64_t v28 = *(void *)(a1 + 808);
      if (((v28 + 7) & 0xFFFFFFFFFFFFFFF8) - v28 + 40 > *(void *)(a1 + 816) - v28)
      {
        unsigned int v35 = *(_DWORD *)(a1 + 832) >> 7;
        if (v35 >= 0x1E) {
          LOBYTE(v35) = 30;
        }
        uint64_t v36 = 4096 << v35;
        unint64_t v29 = (unint64_t)operator new(4096 << v35, (std::align_val_t)8uLL);
        unsigned int v37 = *(_DWORD *)(a1 + 832);
        if (v37 >= *(_DWORD *)(a1 + 836)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 824) + 8 * v37) = v29;
        ++*(_DWORD *)(a1 + 832);
        *(void *)(a1 + 816) = v29 + v36;
      }
      else
      {
        unint64_t v29 = (v28 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(a1 + 808) = v29 + 40;
      uint64_t v6 = v29 + 8;
      *(unsigned char *)(v29 + 16) = 37;
      *(_WORD *)(v29 + 17) = *(_WORD *)(v29 + 17) & 0xF000 | 0x540;
      *(void *)unint64_t v29 = 0;
      *(void *)(v29 + 8) = &unk_1F261AB78;
      *(void *)(v29 + 24) = v17;
      *(void *)(v29 + 32) = v19;
      unsigned int v30 = *(_DWORD *)(a1 + 916) + 1;
      int v31 = *(_DWORD *)(a1 + 912);
      if (v30 > 2 * v31)
      {
        uint64_t v38 = (unsigned int *)v29;
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v31, (uint64_t)off_1F2644D00);
        BOOL v42 = v44;
        uint64_t v43 = 0x2000000000;
        sub_1CD0714B4(v38, (unsigned int *)&v42);
        uint64_t v23 = *(void *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v42, (uint64_t)v42 + 4 * v43));
        if (v42 != v44) {
          free(v42);
        }
        unsigned int v30 = *(_DWORD *)(a1 + 916) + 1;
        unint64_t v29 = (unint64_t)v38;
      }
      *(_DWORD *)(a1 + 916) = v30;
      uint64_t v32 = *(void *)v23;
      if (!*(void *)v23) {
        uint64_t v32 = v23 | 1;
      }
      *(void *)unint64_t v29 = v32;
      *(void *)uint64_t v23 = v29;
    }
    else
    {
      uint64_t v6 = 0;
    }
    int v27 = 1;
    goto LABEL_55;
  }
  if (v4 != 76)
  {
    if (v4 == 88)
    {
      *(void *)a1 = v3 + 1;
      uint64_t v5 = sub_1CD077868(a1);
      goto LABEL_6;
    }
    goto LABEL_10;
  }
  if ((unint64_t)&v2[-*(void *)a1] >= 2 && v3[1] == 90)
  {
    *(void *)a1 = v3 + 2;
    uint64_t v5 = sub_1CD06E7AC((unsigned __int8 **)a1);
LABEL_6:
    uint64_t v6 = v5;
    if (v5)
    {
      unint64_t v7 = *(unsigned __int8 **)a1;
      if (*(void *)a1 == *(void *)(a1 + 8) || *v7 != 69) {
        return 0;
      }
      else {
        *(void *)a1 = v7 + 1;
      }
    }
    return v6;
  }

  return sub_1CD07EF14(a1);
}

uint64_t sub_1CD081610(uint64_t a1)
{
  v31[16] = *MEMORY[0x1E4F143B8];
  unint64_t v26 = 0;
  uint64_t v2 = 0;
  if (sub_1CC6B813C((unsigned __int8 **)a1, (uint64_t *)&v26)) {
    return v2;
  }
  int v3 = *(unsigned __int8 **)a1;
  unint64_t v4 = v26;
  if (v26 - 1 >= *(void *)(a1 + 8) - *(void *)a1) {
    return 0;
  }
  *(void *)&long long v25 = *(void *)a1;
  *((void *)&v25 + 1) = &v3[v26];
  *(void *)a1 = &v3[v26];
  if (v4 < 0xA || strncmp("_GLOBAL__N", (const char *)v3, 0xAuLL)) {
    return sub_1CD077500(a1, &v25);
  }
  int v6 = *(unsigned __int8 *)(a1 + 937);
  int v27 = &v28[2];
  *(_OWORD *)uint64_t v28 = xmmword_1CFB2EA50;
  llvm::FoldingSetNodeID::AddString((unsigned int *)&v27, "(anonymous namespace)", 0x15u);
  unint64_t v7 = sub_1CC13A6B8(v27, (uint64_t)v27 + 4 * v28[0]);
  uint64_t v9 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v7);
  uint64_t v10 = *(unsigned int **)v9;
  unint64_t v29 = v31;
  uint64_t v30 = 0x2000000000;
  if (v10) {
    BOOL v11 = (v10 & 1) == 0;
  }
  else {
    BOOL v11 = 0;
  }
  if (!v11) {
    goto LABEL_24;
  }
  while (1)
  {
    LOBYTE(v7) = sub_1CD071418(v7, v10, (uint64_t)&v27, v8, (unsigned int *)&v29);
    if (v7) {
      break;
    }
    LODWORD(v30) = 0;
    uint64_t v10 = *(unsigned int **)v10;
    if (v10) {
      BOOL v12 = (v10 & 1) == 0;
    }
    else {
      BOOL v12 = 0;
    }
    if (!v12)
    {
      uint64_t v10 = 0;
      goto LABEL_20;
    }
  }
  uint64_t v9 = 0;
LABEL_20:
  if (v29 != v31)
  {
    free(v29);
    if (v10) {
      goto LABEL_22;
    }
LABEL_24:
    if (v6)
    {
      *(void *)(a1 + 888) += 40;
      uint64_t v14 = *(void *)(a1 + 808);
      if (((v14 + 7) & 0xFFFFFFFFFFFFFFF8) - v14 + 40 > *(void *)(a1 + 816) - v14)
      {
        unsigned int v21 = *(_DWORD *)(a1 + 832) >> 7;
        if (v21 >= 0x1E) {
          LOBYTE(v21) = 30;
        }
        uint64_t v22 = 4096 << v21;
        unint64_t v15 = (unint64_t)operator new(4096 << v21, (std::align_val_t)8uLL);
        unsigned int v23 = *(_DWORD *)(a1 + 832);
        if (v23 >= *(_DWORD *)(a1 + 836)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 824) + 8 * v23) = v15;
        ++*(_DWORD *)(a1 + 832);
        *(void *)(a1 + 816) = v15 + v22;
      }
      else
      {
        unint64_t v15 = (v14 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(a1 + 808) = v15 + 40;
      uint64_t v2 = v15 + 8;
      *(unsigned char *)(v15 + 16) = 7;
      *(_WORD *)(v15 + 17) = *(_WORD *)(v15 + 17) & 0xF000 | 0x540;
      *(void *)unint64_t v15 = 0;
      *(void *)(v15 + 8) = &unk_1F26197E0;
      *(void *)(v15 + 24) = "(anonymous namespace)";
      *(void *)(v15 + 32) = "";
      unsigned int v16 = *(_DWORD *)(a1 + 916) + 1;
      int v17 = *(_DWORD *)(a1 + 912);
      if (v16 > 2 * v17)
      {
        unsigned int v24 = (unsigned int *)v15;
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v17, (uint64_t)off_1F2644D00);
        unint64_t v29 = v31;
        uint64_t v30 = 0x2000000000;
        sub_1CD0714B4(v24, (unsigned int *)&v29);
        uint64_t v9 = *(void *)(a1 + 904)
           + 8
           * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v29, (uint64_t)v29 + 4 * v30));
        if (v29 != v31) {
          free(v29);
        }
        unsigned int v16 = *(_DWORD *)(a1 + 916) + 1;
        unint64_t v15 = (unint64_t)v24;
      }
      *(_DWORD *)(a1 + 916) = v16;
      uint64_t v18 = *(void *)v9;
      if (!*(void *)v9) {
        uint64_t v18 = v9 | 1;
      }
      *(void *)unint64_t v15 = v18;
      *(void *)uint64_t v9 = v15;
    }
    else
    {
      uint64_t v2 = 0;
    }
    int v13 = 1;
    goto LABEL_33;
  }
  if (!v10) {
    goto LABEL_24;
  }
LABEL_22:
  int v13 = 0;
  uint64_t v2 = (uint64_t)(v10 + 2);
LABEL_33:
  if (v27 != &v28[2]) {
    free(v27);
  }
  if (v13)
  {
    *(void *)(a1 + 920) = v2;
  }
  else if (v2)
  {
    unint64_t v29 = 0;
    int v19 = sub_1CD640748(a1 + 944, v2, &v29);
    uint64_t v20 = 0;
    if (v19) {
      uint64_t v20 = *((void *)v29 + 1);
    }
    if (v20) {
      uint64_t v2 = v20;
    }
    if (v2 == *(void *)(a1 + 928)) {
      *(unsigned char *)(a1 + 936) = 1;
    }
  }
  return v2;
}

uint64_t sub_1CD0819FC(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  v36[16] = *MEMORY[0x1E4F143B8];
  int v6 = sub_1CC6B5BE0((char **)a1, 1);
  if (v6 == v7) {
    return 0;
  }
  uint64_t v8 = *(char **)a1;
  if (*(void *)a1 == *(void *)(a1 + 8) || *v8 != 69) {
    return 0;
  }
  uint64_t v9 = (unsigned __int8 *)v6;
  uint64_t v10 = v7;
  *(void *)a1 = v8 + 1;
  int v11 = *(unsigned __int8 *)(a1 + 937);
  uint64_t v32 = &v33[2];
  *(_OWORD *)int v33 = xmmword_1CFB2ECB0;
  llvm::FoldingSetNodeID::AddString((unsigned int *)&v32, a2, a3 - a2);
  llvm::FoldingSetNodeID::AddString((unsigned int *)&v32, v9, v10 - v9);
  unint64_t v12 = sub_1CC13A6B8(v32, (uint64_t)v32 + 4 * v33[0]);
  uint64_t v14 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v12);
  unint64_t v15 = *(unsigned int **)v14;
  uint64_t v34 = v36;
  uint64_t v35 = 0x2000000000;
  if (v15) {
    BOOL v16 = (v15 & 1) == 0;
  }
  else {
    BOOL v16 = 0;
  }
  if (!v16) {
    goto LABEL_22;
  }
  while (1)
  {
    LOBYTE(v12) = sub_1CD071418(v12, v15, (uint64_t)&v32, v13, (unsigned int *)&v34);
    if (v12) {
      break;
    }
    LODWORD(v35) = 0;
    unint64_t v15 = *(unsigned int **)v15;
    if (v15) {
      BOOL v17 = (v15 & 1) == 0;
    }
    else {
      BOOL v17 = 0;
    }
    if (!v17)
    {
      unint64_t v15 = 0;
      goto LABEL_18;
    }
  }
  uint64_t v14 = 0;
LABEL_18:
  if (v34 != v36)
  {
    free(v34);
    if (v15) {
      goto LABEL_20;
    }
LABEL_22:
    if (v11)
    {
      *(void *)(a1 + 888) += 56;
      uint64_t v21 = *(void *)(a1 + 808);
      if (((v21 + 7) & 0xFFFFFFFFFFFFFFF8) - v21 + 56 > *(void *)(a1 + 816) - v21)
      {
        unsigned int v28 = *(_DWORD *)(a1 + 832) >> 7;
        if (v28 >= 0x1E) {
          LOBYTE(v28) = 30;
        }
        uint64_t v29 = 4096 << v28;
        unint64_t v22 = (unint64_t)operator new(4096 << v28, (std::align_val_t)8uLL);
        unsigned int v30 = *(_DWORD *)(a1 + 832);
        if (v30 >= *(_DWORD *)(a1 + 836)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 824) + 8 * v30) = v22;
        ++*(_DWORD *)(a1 + 832);
        *(void *)(a1 + 816) = v22 + v29;
      }
      else
      {
        unint64_t v22 = (v21 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(a1 + 808) = v22 + 56;
      uint64_t v18 = v22 + 8;
      *(unsigned char *)(v22 + 16) = 73;
      *(_WORD *)(v22 + 17) = *(_WORD *)(v22 + 17) & 0xF000 | 0x540;
      *(void *)unint64_t v22 = 0;
      *(void *)(v22 + 8) = &unk_1F2619D08;
      *(void *)(v22 + 24) = a2;
      *(void *)(v22 + 32) = a3;
      *(void *)(v22 + 40) = v9;
      *(void *)(v22 + 48) = v10;
      unsigned int v23 = *(_DWORD *)(a1 + 916) + 1;
      int v24 = *(_DWORD *)(a1 + 912);
      if (v23 > 2 * v24)
      {
        int v31 = (unsigned int *)v22;
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v24, (uint64_t)off_1F2644D00);
        uint64_t v34 = v36;
        uint64_t v35 = 0x2000000000;
        sub_1CD0714B4(v31, (unsigned int *)&v34);
        uint64_t v14 = *(void *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v34, (uint64_t)v34 + 4 * v35));
        if (v34 != v36) {
          free(v34);
        }
        unsigned int v23 = *(_DWORD *)(a1 + 916) + 1;
        unint64_t v22 = (unint64_t)v31;
      }
      *(_DWORD *)(a1 + 916) = v23;
      uint64_t v25 = *(void *)v14;
      if (!*(void *)v14) {
        uint64_t v25 = v14 | 1;
      }
      *(void *)unint64_t v22 = v25;
      *(void *)uint64_t v14 = v22;
    }
    else
    {
      uint64_t v18 = 0;
    }
    int v20 = 1;
    goto LABEL_31;
  }
  if (!v15) {
    goto LABEL_22;
  }
LABEL_20:
  int v20 = 0;
  uint64_t v18 = (uint64_t)(v15 + 2);
LABEL_31:
  if (v32 != &v33[2]) {
    free(v32);
  }
  if (v20)
  {
    *(void *)(a1 + 920) = v18;
  }
  else if (v18)
  {
    uint64_t v34 = 0;
    int v26 = sub_1CD640748(a1 + 944, v18, &v34);
    uint64_t v27 = 0;
    if (v26) {
      uint64_t v27 = *((void *)v34 + 1);
    }
    if (v27) {
      uint64_t v18 = v27;
    }
    if (v18 == *(void *)(a1 + 928)) {
      *(unsigned char *)(a1 + 936) = 1;
    }
  }
  return v18;
}

uint64_t sub_1CD081DD0(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a1;
  v33[16] = *MEMORY[0x1E4F143B8];
  int v6 = *(unsigned __int8 *)(a1 + 937);
  unsigned int v28 = (char *)&v29 + 8;
  LODWORD(v30) = *a2;
  uint64_t v30 = (int)v30;
  long long v29 = xmmword_1CFB2ECC0;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
  {
    a1 = __cxa_guard_acquire(&qword_1EBCBE588);
    if (a1)
    {
      unint64_t v27 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v27 = 0xFF51AFD7ED558CCDLL;
      }
      qword_1EBCBE580 = v27;
      __cxa_guard_release(&qword_1EBCBE588);
    }
  }
  unint64_t v7 = 0x9DDFEA08EB382D69 * (*((void *)&v29 + 1) ^ qword_1EBCBE580 ^ __ROR8__(v30 + 16, 16));
  unint64_t v8 = __ROR8__(v30 + 16, 16) ^ (v7 >> 47);
  uint64_t v9 = *(void *)(v5 + 904)
     + 8
     * ((*(_DWORD *)(v5 + 912) - 1) & ((-348639895
                                      * ((((0x9DDFEA08EB382D69 * (v8 ^ v7)) >> 32) >> 15) ^ (-348639895 * (v8 ^ v7)))) ^ v30));
  uint64_t v10 = *(unsigned int **)v9;
  int v31 = v33;
  uint64_t v32 = 0x2000000000;
  if (v10) {
    BOOL v11 = (v10 & 1) == 0;
  }
  else {
    BOOL v11 = 0;
  }
  if (!v11) {
    goto LABEL_18;
  }
  while (1)
  {
    LOBYTE(a1) = sub_1CD071418(a1, v10, (uint64_t)&v28, a4, (unsigned int *)&v31);
    if (a1) {
      break;
    }
    LODWORD(v32) = 0;
    uint64_t v10 = *(unsigned int **)v10;
    if (v10) {
      BOOL v12 = (v10 & 1) == 0;
    }
    else {
      BOOL v12 = 0;
    }
    if (!v12)
    {
      uint64_t v10 = 0;
      goto LABEL_14;
    }
  }
  uint64_t v9 = 0;
LABEL_14:
  if (v31 == v33)
  {
    if (v10)
    {
LABEL_16:
      int v13 = 0;
      uint64_t v14 = (uint64_t)(v10 + 2);
      goto LABEL_27;
    }
  }
  else
  {
    free(v31);
    if (v10) {
      goto LABEL_16;
    }
  }
LABEL_18:
  if (v6)
  {
    *(void *)(v5 + 888) += 24;
    uint64_t v15 = *(void *)(v5 + 808);
    if (((v15 + 7) & 0xFFFFFFFFFFFFFFF8) - v15 + 24 > *(void *)(v5 + 816) - v15)
    {
      unsigned int v24 = *(_DWORD *)(v5 + 832) >> 7;
      if (v24 >= 0x1E) {
        LOBYTE(v24) = 30;
      }
      uint64_t v25 = 4096 << v24;
      unint64_t v16 = (unint64_t)operator new(4096 << v24, (std::align_val_t)8uLL);
      unsigned int v26 = *(_DWORD *)(v5 + 832);
      if (v26 >= *(_DWORD *)(v5 + 836)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(v5 + 824) + 8 * v26) = v16;
      ++*(_DWORD *)(v5 + 832);
      *(void *)(v5 + 816) = v16 + v25;
    }
    else
    {
      unint64_t v16 = (v15 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    *(void *)(v5 + 808) = v16 + 24;
    *(void *)unint64_t v16 = 0;
    uint64_t v14 = v16 + 8;
    BOOL v17 = *a2 != 0;
    *(unsigned char *)(v16 + 16) = 69;
    *(_WORD *)(v16 + 17) = *(_WORD *)(v16 + 17) & 0xF000 | 0x540;
    *(void *)(v16 + 8) = &unk_1F2619D60;
    *(unsigned char *)(v16 + 19) = v17;
    unsigned int v18 = *(_DWORD *)(v5 + 916) + 1;
    int v19 = *(_DWORD *)(v5 + 912);
    if (v18 > 2 * v19)
    {
      llvm::FoldingSetBase::GrowBucketCount(v5 + 904, 2 * v19, (uint64_t)off_1F2644D00);
      int v31 = v33;
      uint64_t v32 = 0x2000000000;
      sub_1CD0714B4((unsigned int *)v16, (unsigned int *)&v31);
      uint64_t v9 = *(void *)(v5 + 904)
         + 8 * ((*(_DWORD *)(v5 + 912) - 1) & sub_1CC13A6B8(v31, (uint64_t)v31 + 4 * v32));
      if (v31 != v33) {
        free(v31);
      }
      unsigned int v18 = *(_DWORD *)(v5 + 916) + 1;
    }
    *(_DWORD *)(v5 + 916) = v18;
    uint64_t v20 = *(void *)v9;
    if (!*(void *)v9) {
      uint64_t v20 = v9 | 1;
    }
    *(void *)unint64_t v16 = v20;
    *(void *)uint64_t v9 = v16;
  }
  else
  {
    uint64_t v14 = 0;
  }
  int v13 = 1;
LABEL_27:
  if (v28 != (char *)&v29 + 8) {
    free(v28);
  }
  if (v13)
  {
    *(void *)(v5 + 920) = v14;
  }
  else if (v14)
  {
    int v31 = 0;
    int v22 = sub_1CD640748(v5 + 944, v14, &v31);
    uint64_t v23 = 0;
    if (v22) {
      uint64_t v23 = *((void *)v31 + 1);
    }
    if (v23) {
      uint64_t v14 = v23;
    }
    if (v14 == *(void *)(v5 + 928)) {
      *(unsigned char *)(v5 + 936) = 1;
    }
  }
  return v14;
}

uint64_t sub_1CD0821D8(uint64_t a1, uint64_t a2)
{
  v110[16] = *MEMORY[0x1E4F143B8];
  if (a2) {
    *(void *)(a1 + 672) = *(void *)(a1 + 664);
  }
  int v3 = *(const char **)a1;
  if (*(void *)(a1 + 8) - *(void *)a1 < 2uLL) {
    return 0;
  }
  if (!strncmp("Ut", *(const char **)a1, 2uLL))
  {
    *(void *)a1 = v3 + 2;
    uint64_t v14 = (unsigned __int8 *)sub_1CC6B5BE0((char **)a1, 0);
    unint64_t v16 = *(char **)a1;
    if (*(void *)a1 == *(void *)(a1 + 8) || *v16 != 95) {
      return 0;
    }
    BOOL v17 = v14;
    uint64_t v18 = v15;
    *(void *)a1 = v16 + 1;
    int v19 = *(unsigned __int8 *)(a1 + 937);
    unsigned int v106 = &v107[2];
    *(_OWORD *)uint64_t v107 = xmmword_1CFB2ECD0;
    llvm::FoldingSetNodeID::AddString((unsigned int *)&v106, v14, v15 - v14);
    unint64_t v20 = sub_1CC13A6B8(v106, (uint64_t)v106 + 4 * v107[0]);
    uint64_t v22 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v20);
    uint64_t v23 = *(unsigned int **)v22;
    unsigned int v108 = v110;
    uint64_t v109 = 0x2000000000;
    if (v23) {
      BOOL v24 = (v23 & 1) == 0;
    }
    else {
      BOOL v24 = 0;
    }
    if (!v24) {
      goto LABEL_95;
    }
    while (1)
    {
      LOBYTE(v20) = sub_1CD071418(v20, v23, (uint64_t)&v106, v21, (unsigned int *)&v108);
      if (v20) {
        break;
      }
      LODWORD(v109) = 0;
      uint64_t v23 = *(unsigned int **)v23;
      if (v23) {
        BOOL v25 = (v23 & 1) == 0;
      }
      else {
        BOOL v25 = 0;
      }
      if (!v25)
      {
        uint64_t v23 = 0;
        goto LABEL_62;
      }
    }
    uint64_t v22 = 0;
LABEL_62:
    if (v108 == v110)
    {
      if (v23)
      {
LABEL_64:
        int v50 = 0;
        uint64_t v4 = (uint64_t)(v23 + 2);
        goto LABEL_104;
      }
    }
    else
    {
      free(v108);
      if (v23) {
        goto LABEL_64;
      }
    }
LABEL_95:
    if (v19)
    {
      *(void *)(a1 + 888) += 40;
      uint64_t v71 = *(void *)(a1 + 808);
      if (((v71 + 7) & 0xFFFFFFFFFFFFFFF8) - v71 + 40 > *(void *)(a1 + 816) - v71)
      {
        unsigned int v76 = *(_DWORD *)(a1 + 832) >> 7;
        if (v76 >= 0x1E) {
          LOBYTE(v76) = 30;
        }
        uint64_t v77 = 4096 << v76;
        unint64_t v72 = (unint64_t)operator new(4096 << v76, (std::align_val_t)8uLL);
        unsigned int v78 = *(_DWORD *)(a1 + 832);
        if (v78 >= *(_DWORD *)(a1 + 836)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 824) + 8 * v78) = v72;
        ++*(_DWORD *)(a1 + 832);
        *(void *)(a1 + 816) = v72 + v77;
      }
      else
      {
        unint64_t v72 = (v71 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(a1 + 808) = v72 + 40;
      uint64_t v4 = v72 + 8;
      *(unsigned char *)(v72 + 16) = 47;
      *(_WORD *)(v72 + 17) = *(_WORD *)(v72 + 17) & 0xF000 | 0x540;
      *(void *)unint64_t v72 = 0;
      *(void *)(v72 + 8) = &unk_1F2619F18;
      *(void *)(v72 + 24) = v17;
      *(void *)(v72 + 32) = v18;
      unsigned int v73 = *(_DWORD *)(a1 + 916) + 1;
      int v74 = *(_DWORD *)(a1 + 912);
      if (v73 > 2 * v74)
      {
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v74, (uint64_t)off_1F2644D00);
        unsigned int v108 = v110;
        uint64_t v109 = 0x2000000000;
        sub_1CD0714B4((unsigned int *)v72, (unsigned int *)&v108);
        uint64_t v22 = *(void *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v108, (uint64_t)v108 + 4 * v109));
        if (v108 != v110) {
          free(v108);
        }
        unsigned int v73 = *(_DWORD *)(a1 + 916) + 1;
      }
      *(_DWORD *)(a1 + 916) = v73;
      uint64_t v75 = *(void *)v22;
      if (!*(void *)v22) {
        uint64_t v75 = v22 | 1;
      }
      *(void *)unint64_t v72 = v75;
      *(void *)uint64_t v22 = v72;
    }
    else
    {
      uint64_t v4 = 0;
    }
    int v50 = 1;
LABEL_104:
    if (v106 != &v107[2]) {
      free(v106);
    }
    if (!v50) {
      goto LABEL_129;
    }
    goto LABEL_107;
  }
  if (strncmp("Ul", v3, 2uLL))
  {
    if (!strncmp("Ub", v3, 2uLL))
    {
      *(void *)a1 = v3 + 2;
      sub_1CC6B5BE0((char **)a1, 0);
      int v6 = *(char **)a1;
      if (*(void *)a1 != *(void *)(a1 + 8) && *v6 == 95)
      {
        *(void *)a1 = v6 + 1;
        int v7 = *(unsigned __int8 *)(a1 + 937);
        unsigned int v106 = &v107[2];
        *(_OWORD *)uint64_t v107 = xmmword_1CFB2EA50;
        llvm::FoldingSetNodeID::AddString((unsigned int *)&v106, "'block-literal'", 0xFu);
        unint64_t v8 = sub_1CC13A6B8(v106, (uint64_t)v106 + 4 * v107[0]);
        uint64_t v10 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v8);
        BOOL v11 = *(unsigned int **)v10;
        unsigned int v108 = v110;
        uint64_t v109 = 0x2000000000;
        if (v11) {
          BOOL v12 = (v11 & 1) == 0;
        }
        else {
          BOOL v12 = 0;
        }
        if (!v12) {
          goto LABEL_117;
        }
        while (1)
        {
          LOBYTE(v8) = sub_1CD071418(v8, v11, (uint64_t)&v106, v9, (unsigned int *)&v108);
          if (v8) {
            break;
          }
          LODWORD(v109) = 0;
          BOOL v11 = *(unsigned int **)v11;
          if (v11) {
            BOOL v13 = (v11 & 1) == 0;
          }
          else {
            BOOL v13 = 0;
          }
          if (!v13)
          {
            BOOL v11 = 0;
            goto LABEL_87;
          }
        }
        uint64_t v10 = 0;
LABEL_87:
        if (v108 == v110)
        {
          if (v11)
          {
LABEL_89:
            int v69 = 0;
            uint64_t v4 = (uint64_t)(v11 + 2);
            goto LABEL_126;
          }
        }
        else
        {
          free(v108);
          if (v11) {
            goto LABEL_89;
          }
        }
LABEL_117:
        if (v7)
        {
          *(void *)(a1 + 888) += 40;
          uint64_t v79 = *(void *)(a1 + 808);
          if (((v79 + 7) & 0xFFFFFFFFFFFFFFF8) - v79 + 40 > *(void *)(a1 + 816) - v79)
          {
            unsigned int v86 = *(_DWORD *)(a1 + 832) >> 7;
            if (v86 >= 0x1E) {
              LOBYTE(v86) = 30;
            }
            uint64_t v87 = 4096 << v86;
            unint64_t v80 = (unint64_t)operator new(4096 << v86, (std::align_val_t)8uLL);
            unsigned int v88 = *(_DWORD *)(a1 + 832);
            if (v88 >= *(_DWORD *)(a1 + 836)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(*(void *)(a1 + 824) + 8 * v88) = v80;
            ++*(_DWORD *)(a1 + 832);
            *(void *)(a1 + 816) = v80 + v87;
          }
          else
          {
            unint64_t v80 = (v79 + 7) & 0xFFFFFFFFFFFFFFF8;
          }
          *(void *)(a1 + 808) = v80 + 40;
          uint64_t v4 = v80 + 8;
          *(unsigned char *)(v80 + 16) = 7;
          *(_WORD *)(v80 + 17) = *(_WORD *)(v80 + 17) & 0xF000 | 0x540;
          *(void *)unint64_t v80 = 0;
          *(void *)(v80 + 8) = &unk_1F26197E0;
          *(void *)(v80 + 24) = "'block-literal'";
          *(void *)(v80 + 32) = "";
          unsigned int v81 = *(_DWORD *)(a1 + 916) + 1;
          int v82 = *(_DWORD *)(a1 + 912);
          if (v81 > 2 * v82)
          {
            llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v82, (uint64_t)off_1F2644D00);
            unsigned int v108 = v110;
            uint64_t v109 = 0x2000000000;
            sub_1CD0714B4((unsigned int *)v80, (unsigned int *)&v108);
            uint64_t v10 = *(void *)(a1 + 904)
                + 8
                * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v108, (uint64_t)v108 + 4 * v109));
            if (v108 != v110) {
              free(v108);
            }
            unsigned int v81 = *(_DWORD *)(a1 + 916) + 1;
          }
          *(_DWORD *)(a1 + 916) = v81;
          uint64_t v83 = *(void *)v10;
          if (!*(void *)v10) {
            uint64_t v83 = v10 | 1;
          }
          *(void *)unint64_t v80 = v83;
          *(void *)uint64_t v10 = v80;
        }
        else
        {
          uint64_t v4 = 0;
        }
        int v69 = 1;
LABEL_126:
        if (v106 != &v107[2]) {
          free(v106);
        }
        if (!v69)
        {
LABEL_129:
          if (v4)
          {
            unsigned int v108 = 0;
            int v84 = sub_1CD640748(a1 + 944, v4, &v108);
            uint64_t v85 = 0;
            if (v84) {
              uint64_t v85 = v108[1];
            }
            if (v85) {
              uint64_t v4 = v85;
            }
            if (v4 == *(void *)(a1 + 928)) {
              *(unsigned char *)(a1 + 936) = 1;
            }
          }
          return v4;
        }
LABEL_107:
        *(void *)(a1 + 920) = v4;
        return v4;
      }
    }
    return 0;
  }
  *(void *)a1 = v3 + 2;
  uint64_t v26 = *(void *)(a1 + 784);
  *(void *)(a1 + 784) = (uint64_t)(*(void *)(a1 + 672) - *(void *)(a1 + 664)) >> 3;
  sub_1CC6BC124((uint64_t)v103, (void *)a1);
  uint64_t v27 = *(void *)(a1 + 16);
  uint64_t v28 = *(void *)(a1 + 24);
  long long v29 = *(char **)a1;
  uint64_t v30 = *(void *)(a1 + 8);
  if (v30 == *(void *)a1)
  {
    unsigned int v37 = *(unsigned char **)(a1 + 24);
    uint64_t v36 = *(void *)(a1 + 16);
  }
  else
  {
    do
    {
      if (*v29 != 84) {
        break;
      }
      char v31 = (unint64_t)(v30 - (void)v29) < 2 ? 0 : v29[1];
      uint64_t v32 = memchr("yptn", v31, 4uLL);
      if (!v32 || v32 - "yptn" == -1) {
        break;
      }
      uint64_t v33 = sub_1CD082E70(a1);
      if (!v33) {
        goto LABEL_82;
      }
      uint64_t v34 = v33;
      uint64_t v35 = *(uint64_t **)(a1 + 24);
      if (v35 == *(uint64_t **)(a1 + 32))
      {
        sub_1CD5F0ACC(a1 + 16, ((uint64_t)v35 - *(void *)(a1 + 16)) >> 2);
        uint64_t v35 = *(uint64_t **)(a1 + 24);
      }
      *(void *)(a1 + 24) = v35 + 1;
      uint64_t *v35 = v34;
      long long v29 = *(char **)a1;
      uint64_t v30 = *(void *)(a1 + 8);
    }
    while (v30 != *(void *)a1);
    uint64_t v36 = *(void *)(a1 + 16);
    unsigned int v37 = *(unsigned char **)(a1 + 24);
  }
  uint64_t v38 = (v28 - v27) >> 3;
  uint64_t v39 = (unsigned char *)(v36 + 8 * v38);
  uint64_t v40 = v37 - v39;
  uint64_t v41 = (uint64_t *)sub_1CB906F34((uint64_t *)(a1 + 808), v37 - v39, 3);
  BOOL v42 = v41;
  if (v37 == v39)
  {
    uint64_t v43 = *(void *)(a1 + 16);
    *(void *)(a1 + 672) -= 8;
  }
  else
  {
    memmove(v41, v39, v37 - v39);
    uint64_t v43 = *(void *)(a1 + 16);
  }
  uint64_t v44 = v43 + 8 * v38;
  *(void *)(a1 + 24) = v44;
  uint64_t v45 = *(char **)a1;
  if (*(void *)(a1 + 8) - *(void *)a1 > 1uLL && !strncmp("vE", *(const char **)a1, 2uLL))
  {
    BOOL v51 = v45 + 2;
  }
  else
  {
    uint64_t v46 = sub_1CD06B2C4(a1);
    if (!v46) {
      goto LABEL_82;
    }
    uint64_t v47 = v46;
    while (1)
    {
      int v48 = *(uint64_t **)(a1 + 24);
      if (v48 == *(uint64_t **)(a1 + 32))
      {
        sub_1CD5F0ACC(a1 + 16, ((uint64_t)v48 - *(void *)(a1 + 16)) >> 2);
        int v48 = *(uint64_t **)(a1 + 24);
      }
      *(void *)(a1 + 24) = v48 + 1;
      *int v48 = v47;
      unint64_t v49 = *(char **)a1;
      if (*(void *)a1 != *(void *)(a1 + 8) && *v49 == 69) {
        break;
      }
      uint64_t v47 = sub_1CD06B2C4(a1);
      if (!v47) {
        goto LABEL_82;
      }
    }
    BOOL v51 = v49 + 1;
    uint64_t v43 = *(void *)(a1 + 16);
    uint64_t v44 = *(void *)(a1 + 24);
  }
  *(void *)a1 = v51;
  uint64_t v52 = v43 + 8 * v38;
  uint64_t v53 = (uint64_t *)sub_1CB906F34((uint64_t *)(a1 + 808), v44 - v52, 3);
  uint64_t v54 = v53;
  uint64_t v55 = v44 - v52;
  if (v44 != v52) {
    memmove(v53, (const void *)(v43 + 8 * v38), v44 - v52);
  }
  *(void *)(a1 + 24) = *(void *)(a1 + 16) + 8 * v38;
  int v56 = (unsigned __int8 *)sub_1CC6B5BE0((char **)a1, 0);
  uint64_t v58 = *(char **)a1;
  if (*(void *)a1 != *(void *)(a1 + 8) && *v58 == 95)
  {
    BOOL v59 = v56;
    uint64_t v60 = v57;
    uint64_t v61 = v40 >> 3;
    *(void *)a1 = v58 + 1;
    int v62 = *(unsigned __int8 *)(a1 + 937);
    unsigned int v106 = &v107[2];
    *(void *)uint64_t v107 = 0x2000000000;
    uint64_t v101 = v55 >> 3;
    uint64_t v102 = v61;
    sub_1CD074990((unsigned int *)&v106, v42, v61, v54, v55 >> 3, v56, v57);
    unint64_t v63 = sub_1CC13A6B8(v106, (uint64_t)v106 + 4 * v107[0]);
    uint64_t v65 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v63);
    BOOL v66 = *(unsigned int **)v65;
    unsigned int v108 = v110;
    uint64_t v109 = 0x2000000000;
    if (v66) {
      BOOL v67 = (v66 & 1) == 0;
    }
    else {
      BOOL v67 = 0;
    }
    if (!v67) {
      goto LABEL_145;
    }
    while (1)
    {
      LOBYTE(v63) = sub_1CD071418(v63, v66, (uint64_t)&v106, v64, (unsigned int *)&v108);
      if (v63) {
        break;
      }
      LODWORD(v109) = 0;
      BOOL v66 = *(unsigned int **)v66;
      if (v66) {
        BOOL v68 = (v66 & 1) == 0;
      }
      else {
        BOOL v68 = 0;
      }
      if (!v68)
      {
        BOOL v66 = 0;
        goto LABEL_91;
      }
    }
    uint64_t v65 = 0;
LABEL_91:
    if (v108 == v110)
    {
      if (v66)
      {
LABEL_93:
        int v70 = 0;
        uint64_t v4 = (uint64_t)(v66 + 2);
LABEL_154:
        if (v106 != &v107[2]) {
          free(v106);
        }
        if (v70)
        {
          *(void *)(a1 + 920) = v4;
        }
        else if (v4)
        {
          unsigned int v108 = 0;
          int v94 = sub_1CD640748(a1 + 944, v4, &v108);
          uint64_t v95 = 0;
          if (v94) {
            uint64_t v95 = v108[1];
          }
          if (v95) {
            uint64_t v4 = v95;
          }
          if (v4 == *(void *)(a1 + 928)) {
            *(unsigned char *)(a1 + 936) = 1;
          }
        }
        goto LABEL_83;
      }
    }
    else
    {
      free(v108);
      if (v66) {
        goto LABEL_93;
      }
    }
LABEL_145:
    if (v62)
    {
      *(void *)(a1 + 888) += 72;
      uint64_t v89 = *(void *)(a1 + 808);
      if (((v89 + 7) & 0xFFFFFFFFFFFFFFF8) - v89 + 72 > *(void *)(a1 + 816) - v89)
      {
        unsigned int v96 = *(_DWORD *)(a1 + 832) >> 7;
        if (v96 >= 0x1E) {
          LOBYTE(v96) = 30;
        }
        uint64_t v97 = 4096 << v96;
        uint64_t v100 = (char *)operator new(4096 << v96, (std::align_val_t)8uLL);
        unsigned int v98 = *(_DWORD *)(a1 + 832);
        if (v98 >= *(_DWORD *)(a1 + 836)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        unint64_t v90 = (unint64_t)v100;
        *(void *)(*(void *)(a1 + 824) + 8 * v98) = v100;
        ++*(_DWORD *)(a1 + 832);
        *(void *)(a1 + 816) = &v100[v97];
      }
      else
      {
        unint64_t v90 = (v89 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(a1 + 808) = v90 + 72;
      uint64_t v4 = v90 + 8;
      *(unsigned char *)(v90 + 16) = 48;
      *(_WORD *)(v90 + 17) = *(_WORD *)(v90 + 17) & 0xF000 | 0x540;
      *(void *)unint64_t v90 = 0;
      *(void *)(v90 + 8) = &unk_1F261A128;
      *(void *)(v90 + 24) = v42;
      *(void *)(v90 + 32) = v102;
      *(void *)(v90 + 40) = v54;
      *(void *)(v90 + 48) = v101;
      *(void *)(v90 + 56) = v59;
      *(void *)(v90 + 64) = v60;
      unsigned int v91 = *(_DWORD *)(a1 + 916) + 1;
      int v92 = *(_DWORD *)(a1 + 912);
      if (v91 > 2 * v92)
      {
        unsigned int v99 = (unsigned int *)v90;
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v92, (uint64_t)off_1F2644D00);
        unsigned int v108 = v110;
        uint64_t v109 = 0x2000000000;
        sub_1CD0714B4(v99, (unsigned int *)&v108);
        uint64_t v65 = *(void *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v108, (uint64_t)v108 + 4 * v109));
        if (v108 != v110) {
          free(v108);
        }
        unsigned int v91 = *(_DWORD *)(a1 + 916) + 1;
        unint64_t v90 = (unint64_t)v99;
      }
      *(_DWORD *)(a1 + 916) = v91;
      uint64_t v93 = *(void *)v65;
      if (!*(void *)v65) {
        uint64_t v93 = v65 | 1;
      }
      *(void *)unint64_t v90 = v93;
      *(void *)uint64_t v65 = v90;
    }
    else
    {
      uint64_t v4 = 0;
    }
    int v70 = 1;
    goto LABEL_154;
  }
LABEL_82:
  uint64_t v4 = 0;
LABEL_83:
  *(void *)(v103[0] + 672) = *(void *)(v103[0] + 664) + 8 * v103[1];
  if (v104 != &v105) {
    free(v104);
  }
  *(void *)(a1 + 784) = v26;
  return v4;
}

uint64_t sub_1CD082E70(uint64_t a1)
{
  v117[16] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(const char **)a1;
  if (*(void *)(a1 + 8) - *(void *)a1 < 2uLL) {
    return 0;
  }
  if (!strncmp("Ty", v1, 2uLL))
  {
    *(void *)a1 = v1 + 2;
    uint64_t v21 = sub_1CD083E20(a1, 0, v5, v6);
    if (!v21) {
      return 0;
    }
    uint64_t v23 = v21;
    int v24 = *(unsigned __int8 *)(a1 + 937);
    BOOL v111 = (char *)&v112 + 8;
    uint64_t v113 = v21;
    long long v112 = xmmword_1CFB2ED00;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
    {
      uint64_t v21 = __cxa_guard_acquire(&qword_1EBCBE588);
      if (v21)
      {
        unint64_t v105 = llvm::hashing::detail::fixed_seed_override;
        if (!llvm::hashing::detail::fixed_seed_override) {
          unint64_t v105 = 0xFF51AFD7ED558CCDLL;
        }
        qword_1EBCBE580 = v105;
        __cxa_guard_release(&qword_1EBCBE588);
      }
    }
    unint64_t v25 = 0x9DDFEA08EB382D69 * (*((void *)&v112 + 1) ^ qword_1EBCBE580 ^ __ROR8__(v113 + 16, 16));
    unint64_t v26 = __ROR8__(v113 + 16, 16) ^ (v25 >> 47);
    uint64_t v27 = *(void *)(a1 + 904)
        + 8
        * ((*(_DWORD *)(a1 + 912) - 1) & ((-348639895
                                         * ((((0x9DDFEA08EB382D69 * (v26 ^ v25)) >> 32) >> 15) ^ (-348639895 * (v26 ^ v25)))) ^ v113));
    uint64_t v28 = *(unsigned int **)v27;
    uint64_t v115 = v117;
    uint64_t v116 = 0x2000000000;
    if (v28) {
      BOOL v29 = (v28 & 1) == 0;
    }
    else {
      BOOL v29 = 0;
    }
    if (!v29) {
      goto LABEL_87;
    }
    while (1)
    {
      LOBYTE(v21) = sub_1CD071418(v21, v28, (uint64_t)&v111, v22, (unsigned int *)&v115);
      if (v21) {
        break;
      }
      LODWORD(v116) = 0;
      uint64_t v28 = *(unsigned int **)v28;
      if (v28) {
        BOOL v30 = (v28 & 1) == 0;
      }
      else {
        BOOL v30 = 0;
      }
      if (!v30)
      {
        uint64_t v28 = 0;
        goto LABEL_57;
      }
    }
    uint64_t v27 = 0;
LABEL_57:
    if (v115 == v117)
    {
      if (v28)
      {
LABEL_59:
        int v51 = 0;
        uint64_t v2 = (uint64_t)(v28 + 2);
        goto LABEL_96;
      }
    }
    else
    {
      free(v115);
      if (v28) {
        goto LABEL_59;
      }
    }
LABEL_87:
    if (v24)
    {
      *(void *)(a1 + 888) += 32;
      uint64_t v67 = *(void *)(a1 + 808);
      if (((v67 + 7) & 0xFFFFFFFFFFFFFFF8) - v67 + 32 > *(void *)(a1 + 816) - v67)
      {
        unsigned int v72 = *(_DWORD *)(a1 + 832) >> 7;
        if (v72 >= 0x1E) {
          LOBYTE(v72) = 30;
        }
        uint64_t v73 = 4096 << v72;
        unint64_t v68 = (unint64_t)operator new(4096 << v72, (std::align_val_t)8uLL);
        unsigned int v74 = *(_DWORD *)(a1 + 832);
        if (v74 >= *(_DWORD *)(a1 + 836)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 824) + 8 * v74) = v68;
        ++*(_DWORD *)(a1 + 832);
        *(void *)(a1 + 816) = v68 + v73;
      }
      else
      {
        unint64_t v68 = (v67 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(a1 + 808) = v68 + 32;
      uint64_t v2 = v68 + 8;
      *(unsigned char *)(v68 + 16) = 32;
      *(_WORD *)(v68 + 17) = *(_WORD *)(v68 + 17) & 0xF000 | 0x500;
      *(void *)unint64_t v68 = 0;
      *(void *)(v68 + 8) = &unk_1F2619FC8;
      *(void *)(v68 + 24) = v23;
      unsigned int v69 = *(_DWORD *)(a1 + 916) + 1;
      int v70 = *(_DWORD *)(a1 + 912);
      if (v69 > 2 * v70)
      {
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v70, (uint64_t)off_1F2644D00);
        uint64_t v115 = v117;
        uint64_t v116 = 0x2000000000;
        sub_1CD0714B4((unsigned int *)v68, (unsigned int *)&v115);
        uint64_t v27 = *(void *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v115, (uint64_t)v115 + 4 * v116));
        if (v115 != v117) {
          free(v115);
        }
        unsigned int v69 = *(_DWORD *)(a1 + 916) + 1;
      }
      *(_DWORD *)(a1 + 916) = v69;
      uint64_t v71 = *(void *)v27;
      if (!*(void *)v27) {
        uint64_t v71 = v27 | 1;
      }
      *(void *)unint64_t v68 = v71;
      *(void *)uint64_t v27 = v68;
    }
    else
    {
      uint64_t v2 = 0;
    }
    int v51 = 1;
LABEL_96:
    if (v111 != (char *)&v112 + 8) {
      free(v111);
    }
    if (!v51) {
      goto LABEL_121;
    }
    goto LABEL_99;
  }
  if (!strncmp("Tn", v1, 2uLL))
  {
    *(void *)a1 = v1 + 2;
    uint64_t v31 = sub_1CD083E20(a1, 1u, v7, v8);
    if (!v31) {
      return 0;
    }
    uint64_t v32 = v31;
    uint64_t v33 = sub_1CD06B2C4(a1);
    if (!v33) {
      return 0;
    }
    uint64_t v35 = v33;
    int v36 = *(unsigned __int8 *)(a1 + 937);
    BOOL v111 = (char *)&v112 + 8;
    uint64_t v113 = v32;
    uint64_t v114 = v33;
    long long v112 = xmmword_1CFB2ECF0;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
    {
      uint64_t v33 = __cxa_guard_acquire(&qword_1EBCBE588);
      if (v33)
      {
        unint64_t v106 = llvm::hashing::detail::fixed_seed_override;
        if (!llvm::hashing::detail::fixed_seed_override) {
          unint64_t v106 = 0xFF51AFD7ED558CCDLL;
        }
        qword_1EBCBE580 = v106;
        __cxa_guard_release(&qword_1EBCBE588);
      }
    }
    uint64_t v37 = __ROR8__(0xB492B66FBE98F273 * *((void *)&v112 + 1) - v113, 43)
        - 0x3C5A37A36834CED9 * v113
        + __ROR8__((0x9AE16A3B2F90404FLL * v114) ^ qword_1EBCBE580, 30);
    unint64_t v38 = qword_1EBCBE580
        + __ROR8__(v113 ^ 0xC949D7C7509E6557, 20)
        - 0x4B6D499041670D8DLL * *((void *)&v112 + 1)
        - 0x9AE16A3B2F90404FLL * v114
        + 24;
    unint64_t v39 = 0x9DDFEA08EB382D69
        * (v38 ^ ((0x9DDFEA08EB382D69 * (v37 ^ v38)) >> 47) ^ (0x9DDFEA08EB382D69 * (v37 ^ v38)));
    uint64_t v40 = *(void *)(a1 + 904)
        + 8 * ((-348639895 * ((v39 >> 47) ^ v39)) & (*(_DWORD *)(a1 + 912) - 1));
    uint64_t v41 = *(unsigned int **)v40;
    uint64_t v115 = v117;
    uint64_t v116 = 0x2000000000;
    if (v41) {
      BOOL v42 = (v41 & 1) == 0;
    }
    else {
      BOOL v42 = 0;
    }
    if (!v42) {
      goto LABEL_109;
    }
    while (1)
    {
      LOBYTE(v33) = sub_1CD071418(v33, v41, (uint64_t)&v111, v34, (unsigned int *)&v115);
      if (v33) {
        break;
      }
      LODWORD(v116) = 0;
      uint64_t v41 = *(unsigned int **)v41;
      if (v41) {
        BOOL v43 = (v41 & 1) == 0;
      }
      else {
        BOOL v43 = 0;
      }
      if (!v43)
      {
        uint64_t v41 = 0;
        goto LABEL_62;
      }
    }
    uint64_t v40 = 0;
LABEL_62:
    if (v115 == v117)
    {
      if (v41)
      {
LABEL_64:
        int v52 = 0;
        uint64_t v2 = (uint64_t)(v41 + 2);
        goto LABEL_118;
      }
    }
    else
    {
      free(v115);
      if (v41) {
        goto LABEL_64;
      }
    }
LABEL_109:
    if (v36)
    {
      *(void *)(a1 + 888) += 40;
      uint64_t v75 = *(void *)(a1 + 808);
      if (((v75 + 7) & 0xFFFFFFFFFFFFFFF8) - v75 + 40 > *(void *)(a1 + 816) - v75)
      {
        unsigned int v83 = *(_DWORD *)(a1 + 832) >> 7;
        if (v83 >= 0x1E) {
          LOBYTE(v83) = 30;
        }
        uint64_t v84 = 4096 << v83;
        unint64_t v76 = (unint64_t)operator new(4096 << v83, (std::align_val_t)8uLL);
        unsigned int v85 = *(_DWORD *)(a1 + 832);
        if (v85 >= *(_DWORD *)(a1 + 836)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 824) + 8 * v85) = v76;
        ++*(_DWORD *)(a1 + 832);
        *(void *)(a1 + 816) = v76 + v84;
      }
      else
      {
        unint64_t v76 = (v75 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(a1 + 808) = v76 + 40;
      uint64_t v2 = v76 + 8;
      *(unsigned char *)(v76 + 16) = 33;
      *(_WORD *)(v76 + 17) = *(_WORD *)(v76 + 17) & 0xF000 | 0x500;
      *(void *)unint64_t v76 = 0;
      *(void *)(v76 + 8) = &unk_1F261A020;
      *(void *)(v76 + 24) = v32;
      *(void *)(v76 + 32) = v35;
      unsigned int v77 = *(_DWORD *)(a1 + 916) + 1;
      int v78 = *(_DWORD *)(a1 + 912);
      if (v77 > 2 * v78)
      {
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v78, (uint64_t)off_1F2644D00);
        uint64_t v115 = v117;
        uint64_t v116 = 0x2000000000;
        sub_1CD0714B4((unsigned int *)v76, (unsigned int *)&v115);
        uint64_t v40 = *(void *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v115, (uint64_t)v115 + 4 * v116));
        if (v115 != v117) {
          free(v115);
        }
        unsigned int v77 = *(_DWORD *)(a1 + 916) + 1;
      }
      *(_DWORD *)(a1 + 916) = v77;
      uint64_t v79 = *(void *)v40;
      if (!*(void *)v40) {
        uint64_t v79 = v40 | 1;
      }
      *(void *)unint64_t v76 = v79;
      *(void *)uint64_t v40 = v76;
    }
    else
    {
      uint64_t v2 = 0;
    }
    int v52 = 1;
LABEL_118:
    unint64_t v80 = v111;
    if (v111 == (char *)&v112 + 8) {
      goto LABEL_120;
    }
    goto LABEL_119;
  }
  if (strncmp("Tt", v1, 2uLL))
  {
    if (!strncmp("Tp", v1, 2uLL))
    {
      *(void *)a1 = v1 + 2;
      uint64_t v11 = sub_1CD082E70(a1);
      if (v11)
      {
        uint64_t v13 = v11;
        int v14 = *(unsigned __int8 *)(a1 + 937);
        BOOL v111 = (char *)&v112 + 8;
        uint64_t v113 = v11;
        long long v112 = xmmword_1CFB2ECE0;
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
        {
          uint64_t v11 = __cxa_guard_acquire(&qword_1EBCBE588);
          if (v11)
          {
            unint64_t v107 = llvm::hashing::detail::fixed_seed_override;
            if (!llvm::hashing::detail::fixed_seed_override) {
              unint64_t v107 = 0xFF51AFD7ED558CCDLL;
            }
            qword_1EBCBE580 = v107;
            __cxa_guard_release(&qword_1EBCBE588);
          }
        }
        uint64_t v15 = __ROR8__(v113 + 16, 16);
        unint64_t v16 = 0x9DDFEA08EB382D69 * (*((void *)&v112 + 1) ^ qword_1EBCBE580 ^ v15);
        uint64_t v17 = *(void *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & ((-348639895
                                             * ((((0x9DDFEA08EB382D69 * (v15 ^ (v16 >> 47) ^ v16)) >> 32) >> 15) ^ (-348639895 * (v15 ^ (v16 >> 47) ^ v16)))) ^ v113));
        uint64_t v18 = *(unsigned int **)v17;
        uint64_t v115 = v117;
        uint64_t v116 = 0x2000000000;
        if (v18) {
          BOOL v19 = (v18 & 1) == 0;
        }
        else {
          BOOL v19 = 0;
        }
        if (!v19) {
          goto LABEL_137;
        }
        while (1)
        {
          LOBYTE(v11) = sub_1CD071418(v11, v18, (uint64_t)&v111, v12, (unsigned int *)&v115);
          if (v11) {
            break;
          }
          LODWORD(v116) = 0;
          uint64_t v18 = *(unsigned int **)v18;
          if (v18) {
            BOOL v20 = (v18 & 1) == 0;
          }
          else {
            BOOL v20 = 0;
          }
          if (!v20)
          {
            uint64_t v18 = 0;
            goto LABEL_79;
          }
        }
        uint64_t v17 = 0;
LABEL_79:
        if (v115 == v117)
        {
          if (v18)
          {
LABEL_81:
            int v52 = 0;
            uint64_t v2 = (uint64_t)(v18 + 2);
            goto LABEL_146;
          }
        }
        else
        {
          free(v115);
          if (v18) {
            goto LABEL_81;
          }
        }
LABEL_137:
        if (v14)
        {
          *(void *)(a1 + 888) += 32;
          uint64_t v86 = *(void *)(a1 + 808);
          if (((v86 + 7) & 0xFFFFFFFFFFFFFFF8) - v86 + 32 > *(void *)(a1 + 816) - v86)
          {
            unsigned int v91 = *(_DWORD *)(a1 + 832) >> 7;
            if (v91 >= 0x1E) {
              LOBYTE(v91) = 30;
            }
            uint64_t v92 = 4096 << v91;
            unint64_t v87 = (unint64_t)operator new(4096 << v91, (std::align_val_t)8uLL);
            unsigned int v93 = *(_DWORD *)(a1 + 832);
            if (v93 >= *(_DWORD *)(a1 + 836)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(*(void *)(a1 + 824) + 8 * v93) = v87;
            ++*(_DWORD *)(a1 + 832);
            *(void *)(a1 + 816) = v87 + v92;
          }
          else
          {
            unint64_t v87 = (v86 + 7) & 0xFFFFFFFFFFFFFFF8;
          }
          *(void *)(a1 + 808) = v87 + 32;
          uint64_t v2 = v87 + 8;
          *(unsigned char *)(v87 + 16) = 35;
          *(_WORD *)(v87 + 17) = *(_WORD *)(v87 + 17) & 0xF000 | 0x500;
          *(void *)unint64_t v87 = 0;
          *(void *)(v87 + 8) = &unk_1F261A0D0;
          *(void *)(v87 + 24) = v13;
          unsigned int v88 = *(_DWORD *)(a1 + 916) + 1;
          int v89 = *(_DWORD *)(a1 + 912);
          if (v88 > 2 * v89)
          {
            llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v89, (uint64_t)off_1F2644D00);
            uint64_t v115 = v117;
            uint64_t v116 = 0x2000000000;
            sub_1CD0714B4((unsigned int *)v87, (unsigned int *)&v115);
            uint64_t v17 = *(void *)(a1 + 904)
                + 8
                * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v115, (uint64_t)v115 + 4 * v116));
            if (v115 != v117) {
              free(v115);
            }
            unsigned int v88 = *(_DWORD *)(a1 + 916) + 1;
          }
          *(_DWORD *)(a1 + 916) = v88;
          uint64_t v90 = *(void *)v17;
          if (!*(void *)v17) {
            uint64_t v90 = v17 | 1;
          }
          *(void *)unint64_t v87 = v90;
          *(void *)uint64_t v17 = v87;
        }
        else
        {
          uint64_t v2 = 0;
        }
        int v52 = 1;
LABEL_146:
        unint64_t v80 = v111;
        if (v111 == (char *)&v112 + 8)
        {
LABEL_120:
          if (!v52)
          {
LABEL_121:
            if (v2)
            {
              uint64_t v115 = 0;
              int v81 = sub_1CD640748(a1 + 944, v2, &v115);
              uint64_t v82 = 0;
              if (v81) {
                uint64_t v82 = *((void *)v115 + 1);
              }
              if (v82) {
                uint64_t v2 = v82;
              }
              if (v2 == *(void *)(a1 + 928)) {
                *(unsigned char *)(a1 + 936) = 1;
              }
            }
            return v2;
          }
LABEL_99:
          *(void *)(a1 + 920) = v2;
          return v2;
        }
LABEL_119:
        free(v80);
        goto LABEL_120;
      }
    }
    return 0;
  }
  *(void *)a1 = v1 + 2;
  uint64_t v44 = sub_1CD083E20(a1, 2u, v9, v10);
  if (!v44) {
    return 0;
  }
  uint64_t v45 = v44;
  uint64_t v46 = (uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 3;
  sub_1CC6BC124((uint64_t)v108, (void *)a1);
  while (1)
  {
    uint64_t v47 = *(const char **)a1;
    if (*(void *)(a1 + 8) != *(void *)a1 && *v47 == 69) {
      break;
    }
    uint64_t v48 = sub_1CD082E70(a1);
    if (!v48)
    {
      uint64_t v2 = 0;
      goto LABEL_171;
    }
    uint64_t v49 = v48;
    int v50 = *(uint64_t **)(a1 + 24);
    if (v50 == *(uint64_t **)(a1 + 32))
    {
      sub_1CD5F0ACC(a1 + 16, ((uint64_t)v50 - *(void *)(a1 + 16)) >> 2);
      int v50 = *(uint64_t **)(a1 + 24);
    }
    *(void *)(a1 + 24) = v50 + 1;
    *int v50 = v49;
  }
  *(void *)a1 = v47 + 1;
  uint64_t v53 = *(void *)(a1 + 24);
  uint64_t v54 = (const void *)(*(void *)(a1 + 16) + 8 * v46);
  uint64_t v55 = (uint64_t *)sub_1CB906F34((uint64_t *)(a1 + 808), v53 - (void)v54, 3);
  int v56 = v55;
  int64_t v57 = v53 - (void)v54;
  if (v57) {
    memmove(v55, v54, v57);
  }
  uint64_t v58 = v57 >> 3;
  *(void *)(a1 + 24) = *(void *)(a1 + 16) + 8 * v46;
  int v59 = *(unsigned __int8 *)(a1 + 937);
  BOOL v111 = (char *)&v112 + 8;
  *(void *)&long long v112 = 0x2000000000;
  sub_1CD074750((uint64_t)&v111, 34, v45, v56, v58);
  unint64_t v60 = sub_1CC13A6B8(v111, (uint64_t)v111 + 4 * v112);
  uint64_t v62 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v60);
  unint64_t v63 = *(unsigned int **)v62;
  uint64_t v115 = v117;
  uint64_t v116 = 0x2000000000;
  if (v63) {
    BOOL v64 = (v63 & 1) == 0;
  }
  else {
    BOOL v64 = 0;
  }
  if (!v64) {
    goto LABEL_157;
  }
  while (1)
  {
    LOBYTE(v60) = sub_1CD071418(v60, v63, (uint64_t)&v111, v61, (unsigned int *)&v115);
    if (v60) {
      break;
    }
    LODWORD(v116) = 0;
    unint64_t v63 = *(unsigned int **)v63;
    if (v63) {
      BOOL v65 = (v63 & 1) == 0;
    }
    else {
      BOOL v65 = 0;
    }
    if (!v65)
    {
      unint64_t v63 = 0;
      goto LABEL_83;
    }
  }
  uint64_t v62 = 0;
LABEL_83:
  if (v115 == v117)
  {
    if (v63)
    {
LABEL_85:
      int v66 = 0;
      uint64_t v2 = (uint64_t)(v63 + 2);
      goto LABEL_166;
    }
  }
  else
  {
    free(v115);
    if (v63) {
      goto LABEL_85;
    }
  }
LABEL_157:
  if (v59)
  {
    *(void *)(a1 + 888) += 48;
    uint64_t v94 = *(void *)(a1 + 808);
    if (((v94 + 7) & 0xFFFFFFFFFFFFFFF8) - v94 + 48 > *(void *)(a1 + 816) - v94)
    {
      unsigned int v101 = *(_DWORD *)(a1 + 832) >> 7;
      if (v101 >= 0x1E) {
        LOBYTE(v101) = 30;
      }
      uint64_t v102 = 4096 << v101;
      unint64_t v95 = (unint64_t)operator new(4096 << v101, (std::align_val_t)8uLL);
      unsigned int v103 = *(_DWORD *)(a1 + 832);
      if (v103 >= *(_DWORD *)(a1 + 836)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(a1 + 824) + 8 * v103) = v95;
      ++*(_DWORD *)(a1 + 832);
      *(void *)(a1 + 816) = v95 + v102;
    }
    else
    {
      unint64_t v95 = (v94 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    *(void *)(a1 + 808) = v95 + 48;
    uint64_t v2 = v95 + 8;
    *(unsigned char *)(v95 + 16) = 34;
    *(_WORD *)(v95 + 17) = *(_WORD *)(v95 + 17) & 0xF000 | 0x500;
    *(void *)unint64_t v95 = 0;
    *(void *)(v95 + 8) = &unk_1F261A078;
    *(void *)(v95 + 24) = v45;
    *(void *)(v95 + 32) = v56;
    *(void *)(v95 + 40) = v58;
    unsigned int v96 = *(_DWORD *)(a1 + 916) + 1;
    int v97 = *(_DWORD *)(a1 + 912);
    if (v96 > 2 * v97)
    {
      int v104 = (unsigned int *)v95;
      llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v97, (uint64_t)off_1F2644D00);
      uint64_t v115 = v117;
      uint64_t v116 = 0x2000000000;
      sub_1CD0714B4(v104, (unsigned int *)&v115);
      uint64_t v62 = *(void *)(a1 + 904)
          + 8
          * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v115, (uint64_t)v115 + 4 * v116));
      if (v115 != v117) {
        free(v115);
      }
      unsigned int v96 = *(_DWORD *)(a1 + 916) + 1;
      unint64_t v95 = (unint64_t)v104;
    }
    *(_DWORD *)(a1 + 916) = v96;
    uint64_t v98 = *(void *)v62;
    if (!*(void *)v62) {
      uint64_t v98 = v62 | 1;
    }
    *(void *)unint64_t v95 = v98;
    *(void *)uint64_t v62 = v95;
  }
  else
  {
    uint64_t v2 = 0;
  }
  int v66 = 1;
LABEL_166:
  if (v111 != (char *)&v112 + 8) {
    free(v111);
  }
  if (v66)
  {
    *(void *)(a1 + 920) = v2;
  }
  else if (v2)
  {
    uint64_t v115 = 0;
    int v99 = sub_1CD640748(a1 + 944, v2, &v115);
    uint64_t v100 = 0;
    if (v99) {
      uint64_t v100 = *((void *)v115 + 1);
    }
    if (v100) {
      uint64_t v2 = v100;
    }
    if (v2 == *(void *)(a1 + 928)) {
      *(unsigned char *)(a1 + 936) = 1;
    }
  }
LABEL_171:
  *(void *)(v108[0] + 672) = *(void *)(v108[0] + 664) + 8 * v108[1];
  if (v109 != &v110) {
    free(v109);
  }
  return v2;
}

uint64_t sub_1CD083E20(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a1;
  v38[16] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = a1 + 4 * a2;
  unsigned int v7 = *(_DWORD *)(v6 + 792);
  *(_DWORD *)(v6 + 792) = v7 + 1;
  int v8 = *(unsigned __int8 *)(a1 + 937);
  uint64_t v32 = (char *)&v33 + 8;
  uint64_t v34 = a2;
  uint64_t v35 = v7;
  long long v33 = xmmword_1CFB2ED10;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
  {
    a1 = __cxa_guard_acquire(&qword_1EBCBE588);
    if (a1)
    {
      unint64_t v31 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v31 = 0xFF51AFD7ED558CCDLL;
      }
      qword_1EBCBE580 = v31;
      __cxa_guard_release(&qword_1EBCBE588);
    }
  }
  uint64_t v9 = __ROR8__(0xB492B66FBE98F273 * *((void *)&v33 + 1) - v34, 43)
     - 0x3C5A37A36834CED9 * v34
     + __ROR8__((0x9AE16A3B2F90404FLL * v35) ^ qword_1EBCBE580, 30);
  unint64_t v10 = qword_1EBCBE580
      + __ROR8__(v34 ^ 0xC949D7C7509E6557, 20)
      - 0x4B6D499041670D8DLL * *((void *)&v33 + 1)
      - 0x9AE16A3B2F90404FLL * v35
      + 24;
  unint64_t v11 = 0x9DDFEA08EB382D69 * (v10 ^ ((0x9DDFEA08EB382D69 * (v9 ^ v10)) >> 47) ^ (0x9DDFEA08EB382D69 * (v9 ^ v10)));
  uint64_t v12 = *(void *)(v5 + 904)
      + 8 * ((-348639895 * ((v11 >> 47) ^ v11)) & (*(_DWORD *)(v5 + 912) - 1));
  uint64_t v13 = *(unsigned int **)v12;
  int v36 = v38;
  uint64_t v37 = 0x2000000000;
  if (v13) {
    BOOL v14 = (v13 & 1) == 0;
  }
  else {
    BOOL v14 = 0;
  }
  if (!v14) {
    goto LABEL_18;
  }
  while (1)
  {
    LOBYTE(a1) = sub_1CD071418(a1, v13, (uint64_t)&v32, a4, (unsigned int *)&v36);
    if (a1) {
      break;
    }
    LODWORD(v37) = 0;
    uint64_t v13 = *(unsigned int **)v13;
    if (v13) {
      BOOL v15 = (v13 & 1) == 0;
    }
    else {
      BOOL v15 = 0;
    }
    if (!v15)
    {
      uint64_t v13 = 0;
      goto LABEL_14;
    }
  }
  uint64_t v12 = 0;
LABEL_14:
  if (v36 == v38)
  {
    if (v13)
    {
LABEL_16:
      int v16 = 0;
      uint64_t v17 = (uint64_t)(v13 + 2);
      goto LABEL_27;
    }
  }
  else
  {
    free(v36);
    if (v13) {
      goto LABEL_16;
    }
  }
LABEL_18:
  if (v8)
  {
    *(void *)(v5 + 888) += 32;
    uint64_t v18 = *(void *)(v5 + 808);
    if (((v18 + 7) & 0xFFFFFFFFFFFFFFF8) - v18 + 32 > *(void *)(v5 + 816) - v18)
    {
      unsigned int v28 = *(_DWORD *)(v5 + 832) >> 7;
      if (v28 >= 0x1E) {
        LOBYTE(v28) = 30;
      }
      uint64_t v29 = 4096 << v28;
      unint64_t v19 = (unint64_t)operator new(4096 << v28, (std::align_val_t)8uLL);
      unsigned int v30 = *(_DWORD *)(v5 + 832);
      if (v30 >= *(_DWORD *)(v5 + 836)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(v5 + 824) + 8 * v30) = v19;
      ++*(_DWORD *)(v5 + 832);
      *(void *)(v5 + 816) = v19 + v29;
    }
    else
    {
      unint64_t v19 = (v18 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    *(void *)(v5 + 808) = v19 + 32;
    uint64_t v17 = v19 + 8;
    *(unsigned char *)(v19 + 16) = 31;
    *(_WORD *)(v19 + 17) = *(_WORD *)(v19 + 17) & 0xF000 | 0x540;
    *(void *)unint64_t v19 = 0;
    *(void *)(v19 + 8) = &unk_1F2619F70;
    *(_DWORD *)(v19 + 20) = a2;
    *(_DWORD *)(v19 + 24) = v7;
    unsigned int v20 = *(_DWORD *)(v5 + 916) + 1;
    int v21 = *(_DWORD *)(v5 + 912);
    if (v20 > 2 * v21)
    {
      llvm::FoldingSetBase::GrowBucketCount(v5 + 904, 2 * v21, (uint64_t)off_1F2644D00);
      int v36 = v38;
      uint64_t v37 = 0x2000000000;
      sub_1CD0714B4((unsigned int *)v19, (unsigned int *)&v36);
      uint64_t v12 = *(void *)(v5 + 904)
          + 8 * ((*(_DWORD *)(v5 + 912) - 1) & sub_1CC13A6B8(v36, (uint64_t)v36 + 4 * v37));
      if (v36 != v38) {
        free(v36);
      }
      unsigned int v20 = *(_DWORD *)(v5 + 916) + 1;
    }
    *(_DWORD *)(v5 + 916) = v20;
    uint64_t v22 = *(void *)v12;
    if (!*(void *)v12) {
      uint64_t v22 = v12 | 1;
    }
    *(void *)unint64_t v19 = v22;
    *(void *)uint64_t v12 = v19;
  }
  else
  {
    uint64_t v17 = 0;
  }
  int v16 = 1;
LABEL_27:
  if (v32 != (char *)&v33 + 8) {
    free(v32);
  }
  if (v16)
  {
    *(void *)(v5 + 920) = v17;
  }
  else
  {
    if (!v17) {
      return v17;
    }
    int v36 = 0;
    int v26 = sub_1CD640748(v5 + 944, v17, &v36);
    uint64_t v27 = 0;
    if (v26) {
      uint64_t v27 = *((void *)v36 + 1);
    }
    if (v27) {
      uint64_t v17 = v27;
    }
    if (v17 == *(void *)(v5 + 928)) {
      *(unsigned char *)(v5 + 936) = 1;
    }
  }
  if (v17)
  {
    uint64_t v23 = *(void **)(*(void *)(v5 + 672) - 8);
    int v24 = (uint64_t *)v23[1];
    if (v24 == (uint64_t *)v23[2])
    {
      sub_1CD5F0ACC((uint64_t)v23, ((uint64_t)v24 - *v23) >> 2);
      int v24 = (uint64_t *)v23[1];
    }
    v23[1] = v24 + 1;
    *int v24 = v17;
  }
  return v17;
}

uint64_t sub_1CD0842D8(uint64_t a1, long long *a2)
{
  v32[16] = *MEMORY[0x1E4F143B8];
  int v4 = *(unsigned __int8 *)(a1 + 937);
  unsigned int v28 = &v29[2];
  uint64_t v5 = *(unsigned __int8 **)a2;
  uint64_t v6 = *((void *)a2 + 1);
  *(_OWORD *)uint64_t v29 = xmmword_1CFB2ED20;
  llvm::FoldingSetNodeID::AddString((unsigned int *)&v28, v5, v6 - v5);
  unint64_t v7 = sub_1CC13A6B8(v28, (uint64_t)v28 + 4 * v29[0]);
  uint64_t v9 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v7);
  unint64_t v10 = *(unsigned int **)v9;
  unsigned int v30 = v32;
  uint64_t v31 = 0x2000000000;
  if (v10) {
    BOOL v11 = (v10 & 1) == 0;
  }
  else {
    BOOL v11 = 0;
  }
  if (!v11) {
    goto LABEL_17;
  }
  while (1)
  {
    LOBYTE(v7) = sub_1CD071418(v7, v10, (uint64_t)&v28, v8, (unsigned int *)&v30);
    if (v7) {
      break;
    }
    LODWORD(v31) = 0;
    unint64_t v10 = *(unsigned int **)v10;
    if (v10) {
      BOOL v12 = (v10 & 1) == 0;
    }
    else {
      BOOL v12 = 0;
    }
    if (!v12)
    {
      unint64_t v10 = 0;
      goto LABEL_13;
    }
  }
  uint64_t v9 = 0;
LABEL_13:
  if (v30 == v32)
  {
    if (v10)
    {
LABEL_15:
      int v13 = 0;
      uint64_t v14 = (uint64_t)(v10 + 2);
      goto LABEL_26;
    }
  }
  else
  {
    free(v30);
    if (v10) {
      goto LABEL_15;
    }
  }
LABEL_17:
  if (v4)
  {
    *(void *)(a1 + 888) += 40;
    uint64_t v15 = *(void *)(a1 + 808);
    if (((v15 + 7) & 0xFFFFFFFFFFFFFFF8) - v15 + 40 > *(void *)(a1 + 816) - v15)
    {
      unsigned int v25 = *(_DWORD *)(a1 + 832) >> 7;
      if (v25 >= 0x1E) {
        LOBYTE(v25) = 30;
      }
      uint64_t v26 = 4096 << v25;
      unint64_t v16 = (unint64_t)operator new(4096 << v25, (std::align_val_t)8uLL);
      unsigned int v27 = *(_DWORD *)(a1 + 832);
      if (v27 >= *(_DWORD *)(a1 + 836)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(a1 + 824) + 8 * v27) = v16;
      ++*(_DWORD *)(a1 + 832);
      *(void *)(a1 + 816) = v16 + v26;
    }
    else
    {
      unint64_t v16 = (v15 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    *(void *)(a1 + 808) = v16 + 40;
    uint64_t v14 = v16 + 8;
    *(unsigned char *)(v16 + 16) = 63;
    __int16 v17 = *(_WORD *)(v16 + 17) & 0xF000 | 0x540;
    *(void *)unint64_t v16 = 0;
    *(void *)(v16 + 8) = &unk_1F261A230;
    long long v18 = *a2;
    *(_WORD *)(v16 + 17) = v17;
    *(_OWORD *)(v16 + 24) = v18;
    unsigned int v19 = *(_DWORD *)(a1 + 916) + 1;
    int v20 = *(_DWORD *)(a1 + 912);
    if (v19 > 2 * v20)
    {
      llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v20, (uint64_t)off_1F2644D00);
      unsigned int v30 = v32;
      uint64_t v31 = 0x2000000000;
      sub_1CD0714B4((unsigned int *)v16, (unsigned int *)&v30);
      uint64_t v9 = *(void *)(a1 + 904)
         + 8 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v30, (uint64_t)v30 + 4 * v31));
      if (v30 != v32) {
        free(v30);
      }
      unsigned int v19 = *(_DWORD *)(a1 + 916) + 1;
    }
    *(_DWORD *)(a1 + 916) = v19;
    uint64_t v21 = *(void *)v9;
    if (!*(void *)v9) {
      uint64_t v21 = v9 | 1;
    }
    *(void *)unint64_t v16 = v21;
    *(void *)uint64_t v9 = v16;
  }
  else
  {
    uint64_t v14 = 0;
  }
  int v13 = 1;
LABEL_26:
  if (v28 != &v29[2]) {
    free(v28);
  }
  if (v13)
  {
    *(void *)(a1 + 920) = v14;
  }
  else if (v14)
  {
    unsigned int v30 = 0;
    int v23 = sub_1CD640748(a1 + 944, v14, &v30);
    uint64_t v24 = 0;
    if (v23) {
      uint64_t v24 = *((void *)v30 + 1);
    }
    if (v24) {
      uint64_t v14 = v24;
    }
    if (v14 == *(void *)(a1 + 928)) {
      *(unsigned char *)(a1 + 936) = 1;
    }
  }
  return v14;
}

uint64_t sub_1CD084640(uint64_t a1, uint64_t *a2, uint64_t *a3, char *a4)
{
  uint64_t v7 = a1;
  v43[16] = *MEMORY[0x1E4F143B8];
  int v8 = *(unsigned __int8 *)(a1 + 937);
  int v36 = (char *)&v37 + 8;
  uint64_t v9 = *a3;
  unsigned int v10 = *a4;
  unint64_t v11 = HIDWORD(*a2);
  LODWORD(v38) = *a2;
  HIDWORD(v38) = v11;
  uint64_t v39 = v9;
  uint64_t v40 = v10;
  long long v37 = xmmword_1CFB2ED30;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
  {
    a1 = __cxa_guard_acquire(&qword_1EBCBE588);
    if (a1)
    {
      unint64_t v35 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v35 = 0xFF51AFD7ED558CCDLL;
      }
      qword_1EBCBE580 = v35;
      __cxa_guard_release(&qword_1EBCBE588);
    }
  }
  uint64_t v12 = __ROR8__(0xB492B66FBE98F273 * *((void *)&v37 + 1) - v38, 43)
      - 0x3C5A37A36834CED9 * v39
      + __ROR8__((0x9AE16A3B2F90404FLL * v40) ^ qword_1EBCBE580, 30);
  unint64_t v13 = qword_1EBCBE580
      + __ROR8__(v38 ^ 0xC949D7C7509E6557, 20)
      - 0x4B6D499041670D8DLL * *((void *)&v37 + 1)
      - 0x9AE16A3B2F90404FLL * v40
      + 32;
  unint64_t v14 = 0x9DDFEA08EB382D69
      * (v13 ^ ((0x9DDFEA08EB382D69 * (v12 ^ v13)) >> 47) ^ (0x9DDFEA08EB382D69 * (v12 ^ v13)));
  uint64_t v15 = *(void *)(v7 + 904)
      + 8 * ((-348639895 * ((v14 >> 47) ^ v14)) & (*(_DWORD *)(v7 + 912) - 1));
  unint64_t v16 = *(unsigned int **)v15;
  uint64_t v41 = v43;
  uint64_t v42 = 0x2000000000;
  if (v16) {
    BOOL v17 = (v16 & 1) == 0;
  }
  else {
    BOOL v17 = 0;
  }
  if (!v17) {
    goto LABEL_18;
  }
  while (1)
  {
    LOBYTE(a1) = sub_1CD071418(a1, v16, (uint64_t)&v36, (uint64_t)a4, (unsigned int *)&v41);
    if (a1) {
      break;
    }
    LODWORD(v42) = 0;
    unint64_t v16 = *(unsigned int **)v16;
    if (v16) {
      BOOL v18 = (v16 & 1) == 0;
    }
    else {
      BOOL v18 = 0;
    }
    if (!v18)
    {
      unint64_t v16 = 0;
      goto LABEL_14;
    }
  }
  uint64_t v15 = 0;
LABEL_14:
  if (v41 == v43)
  {
    if (v16)
    {
LABEL_16:
      int v19 = 0;
      uint64_t v20 = (uint64_t)(v16 + 2);
      goto LABEL_27;
    }
  }
  else
  {
    free(v41);
    if (v16) {
      goto LABEL_16;
    }
  }
LABEL_18:
  if (v8)
  {
    *(void *)(v7 + 888) += 48;
    uint64_t v21 = *(void *)(v7 + 808);
    if (((v21 + 7) & 0xFFFFFFFFFFFFFFF8) - v21 + 48 > *(void *)(v7 + 816) - v21)
    {
      unsigned int v32 = *(_DWORD *)(v7 + 832) >> 7;
      if (v32 >= 0x1E) {
        LOBYTE(v32) = 30;
      }
      uint64_t v33 = 4096 << v32;
      unint64_t v22 = (unint64_t)operator new(4096 << v32, (std::align_val_t)8uLL);
      unsigned int v34 = *(_DWORD *)(v7 + 832);
      if (v34 >= *(_DWORD *)(v7 + 836)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(v7 + 824) + 8 * v34) = v22;
      ++*(_DWORD *)(v7 + 832);
      *(void *)(v7 + 816) = v22 + v33;
    }
    else
    {
      unint64_t v22 = (v21 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    *(void *)(v7 + 808) = v22 + 48;
    *(void *)unint64_t v22 = 0;
    uint64_t v20 = v22 + 8;
    uint64_t v23 = *a2;
    uint64_t v24 = *a3;
    char v25 = *a4;
    *(unsigned char *)(v22 + 16) = 77;
    *(_WORD *)(v22 + 17) = *(_WORD *)(v22 + 17) & 0xF000 | 0x540;
    *(void *)(v22 + 8) = &unk_1F261A338;
    *(void *)(v22 + 24) = v23;
    *(void *)(v22 + 32) = v24;
    *(unsigned char *)(v22 + 40) = v25;
    unsigned int v26 = *(_DWORD *)(v7 + 916) + 1;
    int v27 = *(_DWORD *)(v7 + 912);
    if (v26 > 2 * v27)
    {
      llvm::FoldingSetBase::GrowBucketCount(v7 + 904, 2 * v27, (uint64_t)off_1F2644D00);
      uint64_t v41 = v43;
      uint64_t v42 = 0x2000000000;
      sub_1CD0714B4((unsigned int *)v22, (unsigned int *)&v41);
      uint64_t v15 = *(void *)(v7 + 904)
          + 8 * ((*(_DWORD *)(v7 + 912) - 1) & sub_1CC13A6B8(v41, (uint64_t)v41 + 4 * v42));
      if (v41 != v43) {
        free(v41);
      }
      unsigned int v26 = *(_DWORD *)(v7 + 916) + 1;
    }
    *(_DWORD *)(v7 + 916) = v26;
    uint64_t v28 = *(void *)v15;
    if (!*(void *)v15) {
      uint64_t v28 = v15 | 1;
    }
    *(void *)unint64_t v22 = v28;
    *(void *)uint64_t v15 = v22;
  }
  else
  {
    uint64_t v20 = 0;
  }
  int v19 = 1;
LABEL_27:
  if (v36 != (char *)&v37 + 8) {
    free(v36);
  }
  if (v19)
  {
    *(void *)(v7 + 920) = v20;
  }
  else if (v20)
  {
    uint64_t v41 = 0;
    int v30 = sub_1CD640748(v7 + 944, v20, &v41);
    uint64_t v31 = 0;
    if (v30) {
      uint64_t v31 = *((void *)v41 + 1);
    }
    if (v31) {
      uint64_t v20 = v31;
    }
    if (v20 == *(void *)(v7 + 928)) {
      *(unsigned char *)(v7 + 936) = 1;
    }
  }
  return v20;
}

uint64_t sub_1CD084ADC(unsigned __int8 **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1[1] != *a1)
  {
    int v5 = **a1;
    if (v5 == 68)
    {
      uint64_t v6 = sub_1CD07C41C((uint64_t)a1);
      goto LABEL_9;
    }
    if (v5 == 84)
    {
      uint64_t v6 = sub_1CD07D120((uint64_t)a1);
LABEL_9:
      uint64_t v8 = v6;
      if (v6)
      {
        uint64_t v9 = a1[38];
        if (v9 == a1[39])
        {
          sub_1CD5F0ACC((uint64_t)(a1 + 37), (v9 - a1[37]) >> 2);
          uint64_t v9 = a1[38];
        }
        a1[38] = v9 + 8;
        *(void *)uint64_t v9 = v8;
      }
      return v8;
    }
  }

  return sub_1CD085A00((uint64_t)a1, a2, a3, a4);
}

uint64_t sub_1CD084B90(void *a1)
{
  uint64_t result = sub_1CD081610((uint64_t)a1);
  uint64_t v5 = result;
  if (result && a1[1] != *a1 && *(unsigned char *)*a1 == 73)
  {
    uint64_t result = sub_1CD07D418((uint64_t)a1, 0);
    uint64_t v4 = result;
    if (result) {
      return sub_1CD07DD24((uint64_t)a1, &v5, &v4, v3);
    }
  }
  return result;
}

uint64_t sub_1CD084C00(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v6 = a1;
  v39[16] = *MEMORY[0x1E4F143B8];
  int v7 = *(unsigned __int8 *)(a1 + 937);
  uint64_t v33 = (char *)&v34 + 8;
  uint64_t v8 = *a3;
  unint64_t v9 = HIDWORD(*a2);
  LODWORD(v35) = *a2;
  HIDWORD(v35) = v9;
  uint64_t v36 = v8;
  long long v34 = xmmword_1CFB2ED40;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
  {
    a1 = __cxa_guard_acquire(&qword_1EBCBE588);
    if (a1)
    {
      unint64_t v32 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v32 = 0xFF51AFD7ED558CCDLL;
      }
      qword_1EBCBE580 = v32;
      __cxa_guard_release(&qword_1EBCBE588);
    }
  }
  uint64_t v10 = __ROR8__(0xB492B66FBE98F273 * *((void *)&v34 + 1) - v35, 43)
      - 0x3C5A37A36834CED9 * v35
      + __ROR8__((0x9AE16A3B2F90404FLL * v36) ^ qword_1EBCBE580, 30);
  unint64_t v11 = qword_1EBCBE580
      + __ROR8__(v35 ^ 0xC949D7C7509E6557, 20)
      - 0x4B6D499041670D8DLL * *((void *)&v34 + 1)
      - 0x9AE16A3B2F90404FLL * v36
      + 24;
  unint64_t v12 = 0x9DDFEA08EB382D69
      * (v11 ^ ((0x9DDFEA08EB382D69 * (v10 ^ v11)) >> 47) ^ (0x9DDFEA08EB382D69 * (v10 ^ v11)));
  uint64_t v13 = *(void *)(v6 + 904)
      + 8 * ((-348639895 * ((v12 >> 47) ^ v12)) & (*(_DWORD *)(v6 + 912) - 1));
  unint64_t v14 = *(unsigned int **)v13;
  long long v37 = v39;
  uint64_t v38 = 0x2000000000;
  if (v14) {
    BOOL v15 = (v14 & 1) == 0;
  }
  else {
    BOOL v15 = 0;
  }
  if (!v15) {
    goto LABEL_18;
  }
  while (1)
  {
    LOBYTE(a1) = sub_1CD071418(a1, v14, (uint64_t)&v33, a4, (unsigned int *)&v37);
    if (a1) {
      break;
    }
    LODWORD(v38) = 0;
    unint64_t v14 = *(unsigned int **)v14;
    if (v14) {
      BOOL v16 = (v14 & 1) == 0;
    }
    else {
      BOOL v16 = 0;
    }
    if (!v16)
    {
      unint64_t v14 = 0;
      goto LABEL_14;
    }
  }
  uint64_t v13 = 0;
LABEL_14:
  if (v37 == v39)
  {
    if (v14)
    {
LABEL_16:
      int v17 = 0;
      uint64_t v18 = (uint64_t)(v14 + 2);
      goto LABEL_27;
    }
  }
  else
  {
    free(v37);
    if (v14) {
      goto LABEL_16;
    }
  }
LABEL_18:
  if (v7)
  {
    *(void *)(v6 + 888) += 40;
    uint64_t v19 = *(void *)(v6 + 808);
    if (((v19 + 7) & 0xFFFFFFFFFFFFFFF8) - v19 + 40 > *(void *)(v6 + 816) - v19)
    {
      unsigned int v29 = *(_DWORD *)(v6 + 832) >> 7;
      if (v29 >= 0x1E) {
        LOBYTE(v29) = 30;
      }
      uint64_t v30 = 4096 << v29;
      unint64_t v20 = (unint64_t)operator new(4096 << v29, (std::align_val_t)8uLL);
      unsigned int v31 = *(_DWORD *)(v6 + 832);
      if (v31 >= *(_DWORD *)(v6 + 836)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(v6 + 824) + 8 * v31) = v20;
      ++*(_DWORD *)(v6 + 832);
      *(void *)(v6 + 816) = v20 + v30;
    }
    else
    {
      unint64_t v20 = (v19 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    *(void *)(v6 + 808) = v20 + 40;
    *(void *)unint64_t v20 = 0;
    uint64_t v18 = v20 + 8;
    uint64_t v21 = *a2;
    uint64_t v22 = *a3;
    *(unsigned char *)(v20 + 16) = 22;
    *(_WORD *)(v20 + 17) = *(_WORD *)(v20 + 17) & 0xF000 | 0x540;
    *(void *)(v20 + 8) = &unk_1F261A5F8;
    *(void *)(v20 + 24) = v21;
    *(void *)(v20 + 32) = v22;
    unsigned int v23 = *(_DWORD *)(v6 + 916) + 1;
    int v24 = *(_DWORD *)(v6 + 912);
    if (v23 > 2 * v24)
    {
      llvm::FoldingSetBase::GrowBucketCount(v6 + 904, 2 * v24, (uint64_t)off_1F2644D00);
      long long v37 = v39;
      uint64_t v38 = 0x2000000000;
      sub_1CD0714B4((unsigned int *)v20, (unsigned int *)&v37);
      uint64_t v13 = *(void *)(v6 + 904)
          + 8 * ((*(_DWORD *)(v6 + 912) - 1) & sub_1CC13A6B8(v37, (uint64_t)v37 + 4 * v38));
      if (v37 != v39) {
        free(v37);
      }
      unsigned int v23 = *(_DWORD *)(v6 + 916) + 1;
    }
    *(_DWORD *)(v6 + 916) = v23;
    uint64_t v25 = *(void *)v13;
    if (!*(void *)v13) {
      uint64_t v25 = v13 | 1;
    }
    *(void *)unint64_t v20 = v25;
    *(void *)uint64_t v13 = v20;
  }
  else
  {
    uint64_t v18 = 0;
  }
  int v17 = 1;
LABEL_27:
  if (v33 != (char *)&v34 + 8) {
    free(v33);
  }
  if (v17)
  {
    *(void *)(v6 + 920) = v18;
  }
  else if (v18)
  {
    long long v37 = 0;
    int v27 = sub_1CD640748(v6 + 944, v18, &v37);
    uint64_t v28 = 0;
    if (v27) {
      uint64_t v28 = *((void *)v37 + 1);
    }
    if (v28) {
      uint64_t v18 = v28;
    }
    if (v18 == *(void *)(v6 + 928)) {
      *(unsigned char *)(v6 + 936) = 1;
    }
  }
  return v18;
}

uint64_t sub_1CD085088(uint64_t a1)
{
  v40[16] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(const char **)a1;
  uint64_t v3 = *(char **)(a1 + 8);
  if (v3 == *(char **)a1)
  {
    LOBYTE(v4) = 0;
  }
  else
  {
    int v4 = *v2;
    if (v4 < 0)
    {
LABEL_6:
      if ((unint64_t)&v3[-*(void *)a1] < 2) {
        goto LABEL_10;
      }
      if (strncmp("dn", v2, 2uLL))
      {
        if (!strncmp("on", v2, 2uLL)) {
          *(void *)a1 = v2 + 2;
        }
LABEL_10:
        uint64_t v8 = (void *)sub_1CD0863D0(a1, 0);
        uint64_t v38 = v8;
        if (!v8 || *(void *)(a1 + 8) == *(void *)a1 || **(unsigned char **)a1 != 73) {
          return (uint64_t)v8;
        }
        uint64_t v35 = (void *)sub_1CD07D418(a1, 0);
        if (v35) {
          return sub_1CD07DD24(a1, (uint64_t *)&v38, (uint64_t *)&v35, v9);
        }
        return 0;
      }
      *(void *)a1 = v2 + 2;
      if (v3 == v2 + 2)
      {
        uint64_t v11 = 0;
      }
      else
      {
        if (v2[2] < 0) {
          goto LABEL_23;
        }
        uint64_t v11 = *((unsigned __int8 *)v2 + 2);
      }
      if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v11 + 60) & 0x400) != 0)
      {
        uint64_t v12 = sub_1CD084B90((void *)a1);
LABEL_25:
        uint64_t v14 = v12;
        if (!v12) {
          return 0;
        }
        int v15 = *(unsigned __int8 *)(a1 + 937);
        uint64_t v35 = (char *)&v36 + 8;
        uint64_t v37 = v12;
        long long v36 = xmmword_1CFB2ED50;
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
        {
          uint64_t v12 = __cxa_guard_acquire(&qword_1EBCBE588);
          if (v12)
          {
            unint64_t v34 = llvm::hashing::detail::fixed_seed_override;
            if (!llvm::hashing::detail::fixed_seed_override) {
              unint64_t v34 = 0xFF51AFD7ED558CCDLL;
            }
            qword_1EBCBE580 = v34;
            __cxa_guard_release(&qword_1EBCBE588);
          }
        }
        uint64_t v16 = __ROR8__(v37 + 16, 16);
        unint64_t v17 = 0x9DDFEA08EB382D69 * (*((void *)&v36 + 1) ^ qword_1EBCBE580 ^ v16);
        uint64_t v18 = *(void *)(a1 + 904)
            + 8
            * ((*(_DWORD *)(a1 + 912) - 1) & ((-348639895
                                             * ((((0x9DDFEA08EB382D69 * (v16 ^ (v17 >> 47) ^ v17)) >> 32) >> 15) ^ (-348639895 * (v16 ^ (v17 >> 47) ^ v17)))) ^ v37));
        uint64_t v19 = *(unsigned int **)v18;
        uint64_t v38 = v40;
        uint64_t v39 = 0x2000000000;
        if (v19) {
          BOOL v20 = (v19 & 1) == 0;
        }
        else {
          BOOL v20 = 0;
        }
        if (!v20) {
          goto LABEL_44;
        }
        while (1)
        {
          LOBYTE(v12) = sub_1CD071418(v12, v19, (uint64_t)&v35, v13, (unsigned int *)&v38);
          if (v12) {
            break;
          }
          LODWORD(v39) = 0;
          uint64_t v19 = *(unsigned int **)v19;
          if (v19) {
            BOOL v21 = (v19 & 1) == 0;
          }
          else {
            BOOL v21 = 0;
          }
          if (!v21)
          {
            uint64_t v19 = 0;
            goto LABEL_40;
          }
        }
        uint64_t v18 = 0;
LABEL_40:
        if (v38 == v40)
        {
          if (v19)
          {
LABEL_42:
            int v22 = 0;
            uint64_t v8 = v19 + 2;
LABEL_53:
            if (v35 != (char *)&v36 + 8) {
              free(v35);
            }
            if (v22)
            {
              *(void *)(a1 + 920) = v8;
            }
            else if (v8)
            {
              uint64_t v38 = 0;
              int v28 = sub_1CD640748(a1 + 944, (uint64_t)v8, &v38);
              unsigned int v29 = 0;
              if (v28) {
                unsigned int v29 = (void *)*((void *)v38 + 1);
              }
              if (v29) {
                uint64_t v8 = v29;
              }
              if (v8 == *(void **)(a1 + 928)) {
                *(unsigned char *)(a1 + 936) = 1;
              }
            }
            return (uint64_t)v8;
          }
        }
        else
        {
          free(v38);
          if (v19) {
            goto LABEL_42;
          }
        }
LABEL_44:
        if (v15)
        {
          *(void *)(a1 + 888) += 32;
          uint64_t v23 = *(void *)(a1 + 808);
          if (((v23 + 7) & 0xFFFFFFFFFFFFFFF8) - v23 + 32 > *(void *)(a1 + 816) - v23)
          {
            unsigned int v30 = *(_DWORD *)(a1 + 832) >> 7;
            if (v30 >= 0x1E) {
              LOBYTE(v30) = 30;
            }
            uint64_t v31 = 4096 << v30;
            unint64_t v24 = (unint64_t)operator new(4096 << v30, (std::align_val_t)8uLL);
            unsigned int v32 = *(_DWORD *)(a1 + 832);
            if (v32 >= *(_DWORD *)(a1 + 836)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(*(void *)(a1 + 824) + 8 * v32) = v24;
            ++*(_DWORD *)(a1 + 832);
            *(void *)(a1 + 816) = v24 + v31;
          }
          else
          {
            unint64_t v24 = (v23 + 7) & 0xFFFFFFFFFFFFFFF8;
          }
          *(void *)(a1 + 808) = v24 + 32;
          uint64_t v8 = (void *)(v24 + 8);
          *(unsigned char *)(v24 + 16) = 46;
          *(_WORD *)(v24 + 17) = *(_WORD *)(v24 + 17) & 0xF000 | 0x540;
          *(void *)unint64_t v24 = 0;
          *(void *)(v24 + 8) = &unk_1F261A650;
          *(void *)(v24 + 24) = v14;
          unsigned int v25 = *(_DWORD *)(a1 + 916) + 1;
          int v26 = *(_DWORD *)(a1 + 912);
          if (v25 > 2 * v26)
          {
            uint64_t v33 = (unsigned int *)v24;
            llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v26, (uint64_t)off_1F2644D00);
            uint64_t v38 = v40;
            uint64_t v39 = 0x2000000000;
            sub_1CD0714B4(v33, (unsigned int *)&v38);
            uint64_t v18 = *(void *)(a1 + 904)
                + 8
                * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v38, (uint64_t)v38 + 4 * v39));
            if (v38 != v40) {
              free(v38);
            }
            unsigned int v25 = *(_DWORD *)(a1 + 916) + 1;
            unint64_t v24 = (unint64_t)v33;
          }
          *(_DWORD *)(a1 + 916) = v25;
          uint64_t v27 = *(void *)v18;
          if (!*(void *)v18) {
            uint64_t v27 = v18 | 1;
          }
          *(void *)unint64_t v24 = v27;
          *(void *)uint64_t v18 = v24;
        }
        else
        {
          uint64_t v8 = 0;
        }
        int v22 = 1;
        goto LABEL_53;
      }
LABEL_23:
      uint64_t v12 = sub_1CD084ADC((unsigned __int8 **)a1, v5, v6, v7);
      goto LABEL_25;
    }
  }
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v4 + 60) & 0x400) == 0) {
    goto LABEL_6;
  }

  return sub_1CD084B90((void *)a1);
}

uint64_t sub_1CD085604(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a1;
  v33[16] = *MEMORY[0x1E4F143B8];
  int v6 = *(unsigned __int8 *)(a1 + 937);
  int v28 = (char *)&v29 + 8;
  uint64_t v30 = *a2;
  long long v29 = xmmword_1CFB2ED60;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
  {
    a1 = __cxa_guard_acquire(&qword_1EBCBE588);
    if (a1)
    {
      unint64_t v27 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v27 = 0xFF51AFD7ED558CCDLL;
      }
      qword_1EBCBE580 = v27;
      __cxa_guard_release(&qword_1EBCBE588);
    }
  }
  unint64_t v7 = 0x9DDFEA08EB382D69 * (*((void *)&v29 + 1) ^ qword_1EBCBE580 ^ __ROR8__(v30 + 16, 16));
  unint64_t v8 = __ROR8__(v30 + 16, 16) ^ (v7 >> 47);
  uint64_t v9 = *(void *)(v5 + 904)
     + 8
     * ((*(_DWORD *)(v5 + 912) - 1) & ((-348639895
                                      * ((((0x9DDFEA08EB382D69 * (v8 ^ v7)) >> 32) >> 15) ^ (-348639895 * (v8 ^ v7)))) ^ v30));
  uint64_t v10 = *(unsigned int **)v9;
  uint64_t v31 = v33;
  uint64_t v32 = 0x2000000000;
  if (v10) {
    BOOL v11 = (v10 & 1) == 0;
  }
  else {
    BOOL v11 = 0;
  }
  if (!v11) {
    goto LABEL_18;
  }
  while (1)
  {
    LOBYTE(a1) = sub_1CD071418(a1, v10, (uint64_t)&v28, a4, (unsigned int *)&v31);
    if (a1) {
      break;
    }
    LODWORD(v32) = 0;
    uint64_t v10 = *(unsigned int **)v10;
    if (v10) {
      BOOL v12 = (v10 & 1) == 0;
    }
    else {
      BOOL v12 = 0;
    }
    if (!v12)
    {
      uint64_t v10 = 0;
      goto LABEL_14;
    }
  }
  uint64_t v9 = 0;
LABEL_14:
  if (v31 == v33)
  {
    if (v10)
    {
LABEL_16:
      int v13 = 0;
      uint64_t v14 = (uint64_t)(v10 + 2);
      goto LABEL_27;
    }
  }
  else
  {
    free(v31);
    if (v10) {
      goto LABEL_16;
    }
  }
LABEL_18:
  if (v6)
  {
    *(void *)(v5 + 888) += 32;
    uint64_t v15 = *(void *)(v5 + 808);
    if (((v15 + 7) & 0xFFFFFFFFFFFFFFF8) - v15 + 32 > *(void *)(v5 + 816) - v15)
    {
      unsigned int v24 = *(_DWORD *)(v5 + 832) >> 7;
      if (v24 >= 0x1E) {
        LOBYTE(v24) = 30;
      }
      uint64_t v25 = 4096 << v24;
      unint64_t v16 = (unint64_t)operator new(4096 << v24, (std::align_val_t)8uLL);
      unsigned int v26 = *(_DWORD *)(v5 + 832);
      if (v26 >= *(_DWORD *)(v5 + 836)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(v5 + 824) + 8 * v26) = v16;
      ++*(_DWORD *)(v5 + 832);
      *(void *)(v5 + 816) = v16 + v25;
    }
    else
    {
      unint64_t v16 = (v15 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    *(void *)(v5 + 808) = v16 + 32;
    *(void *)unint64_t v16 = 0;
    uint64_t v14 = v16 + 8;
    uint64_t v17 = *a2;
    *(unsigned char *)(v16 + 16) = 42;
    *(_WORD *)(v16 + 17) = *(_WORD *)(v16 + 17) & 0xF000 | 0x540;
    *(void *)(v16 + 8) = &unk_1F261A758;
    *(void *)(v16 + 24) = v17;
    unsigned int v18 = *(_DWORD *)(v5 + 916) + 1;
    int v19 = *(_DWORD *)(v5 + 912);
    if (v18 > 2 * v19)
    {
      llvm::FoldingSetBase::GrowBucketCount(v5 + 904, 2 * v19, (uint64_t)off_1F2644D00);
      uint64_t v31 = v33;
      uint64_t v32 = 0x2000000000;
      sub_1CD0714B4((unsigned int *)v16, (unsigned int *)&v31);
      uint64_t v9 = *(void *)(v5 + 904)
         + 8 * ((*(_DWORD *)(v5 + 912) - 1) & sub_1CC13A6B8(v31, (uint64_t)v31 + 4 * v32));
      if (v31 != v33) {
        free(v31);
      }
      unsigned int v18 = *(_DWORD *)(v5 + 916) + 1;
    }
    *(_DWORD *)(v5 + 916) = v18;
    uint64_t v20 = *(void *)v9;
    if (!*(void *)v9) {
      uint64_t v20 = v9 | 1;
    }
    *(void *)unint64_t v16 = v20;
    *(void *)uint64_t v9 = v16;
  }
  else
  {
    uint64_t v14 = 0;
  }
  int v13 = 1;
LABEL_27:
  if (v28 != (char *)&v29 + 8) {
    free(v28);
  }
  if (v13)
  {
    *(void *)(v5 + 920) = v14;
  }
  else if (v14)
  {
    uint64_t v31 = 0;
    int v22 = sub_1CD640748(v5 + 944, v14, &v31);
    uint64_t v23 = 0;
    if (v22) {
      uint64_t v23 = *((void *)v31 + 1);
    }
    if (v23) {
      uint64_t v14 = v23;
    }
    if (v14 == *(void *)(v5 + 928)) {
      *(unsigned char *)(v5 + 936) = 1;
    }
  }
  return v14;
}

uint64_t sub_1CD085A00(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v43[16] = *MEMORY[0x1E4F143B8];
  int v4 = *(unsigned __int8 **)a1;
  uint64_t v5 = *(unsigned __int8 **)(a1 + 8);
  if (*(unsigned __int8 **)a1 == v5 || *v4 != 83) {
    return 0;
  }
  uint64_t v6 = a1;
  *(void *)a1 = v4 + 1;
  if (v5 == v4 + 1) {
    goto LABEL_11;
  }
  unsigned int v7 = v4[1];
  if ((char)v4[1] < 97)
  {
    if (v7 == 95)
    {
      *(void *)a1 = v4 + 2;
      uint64_t v10 = *(void *)(a1 + 296);
      if (v10 != *(void *)(a1 + 304)) {
        return *(void *)v10;
      }
      return 0;
    }
LABEL_11:
    uint64_t v41 = 0;
    uint64_t v8 = 0;
    if (sub_1CC6B7DD0((unsigned __int8 **)a1, (uint64_t *)&v41)) {
      return v8;
    }
    BOOL v11 = *(unsigned char **)v6;
    if (*(void *)v6 != *(void *)(v6 + 8) && *v11 == 95)
    {
      unint64_t v12 = (unint64_t)v41 + 1;
      *(void *)uint64_t v6 = v11 + 1;
      uint64_t v13 = *(void *)(v6 + 296);
      if (v12 < (*(void *)(v6 + 304) - v13) >> 3) {
        return *(void *)(v13 + 8 * v12);
      }
    }
    return 0;
  }
  if (v7 > 0x7A) {
    goto LABEL_11;
  }
  uint64_t v8 = 0;
  unsigned int v9 = 0;
  switch(v4[1])
  {
    case 'a':
      goto LABEL_24;
    case 'b':
      unsigned int v9 = 1;
      goto LABEL_24;
    case 'c':
    case 'e':
    case 'f':
    case 'g':
    case 'h':
      return v8;
    case 'd':
      unsigned int v9 = 5;
      goto LABEL_24;
    case 'i':
      unsigned int v9 = 3;
      goto LABEL_24;
    default:
      if (v7 == 111)
      {
        unsigned int v9 = 4;
      }
      else
      {
        if (v7 != 115) {
          return v8;
        }
        unsigned int v9 = 2;
      }
LABEL_24:
      *(void *)a1 = v4 + 2;
      int v15 = *(unsigned __int8 *)(a1 + 937);
      uint64_t v38 = (char *)&v39 + 8;
      uint64_t v40 = v9;
      long long v39 = xmmword_1CFB2ED70;
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
      {
        a1 = __cxa_guard_acquire(&qword_1EBCBE588);
        if (a1)
        {
          unint64_t v37 = llvm::hashing::detail::fixed_seed_override;
          if (!llvm::hashing::detail::fixed_seed_override) {
            unint64_t v37 = 0xFF51AFD7ED558CCDLL;
          }
          qword_1EBCBE580 = v37;
          __cxa_guard_release(&qword_1EBCBE588);
        }
      }
      uint64_t v16 = __ROR8__(v40 + 16, 16);
      unint64_t v17 = 0x9DDFEA08EB382D69 * (*((void *)&v39 + 1) ^ qword_1EBCBE580 ^ v16);
      uint64_t v18 = *(void *)(v6 + 904)
          + 8
          * ((*(_DWORD *)(v6 + 912) - 1) & ((-348639895
                                           * ((((0x9DDFEA08EB382D69 * (v16 ^ (v17 >> 47) ^ v17)) >> 32) >> 15) ^ (-348639895 * (v16 ^ (v17 >> 47) ^ v17)))) ^ v40));
      int v19 = *(unsigned int **)v18;
      uint64_t v41 = v43;
      uint64_t v42 = 0x2000000000;
      if (v19) {
        BOOL v20 = (v19 & 1) == 0;
      }
      else {
        BOOL v20 = 0;
      }
      if (!v20) {
        goto LABEL_41;
      }
      break;
  }
  while (1)
  {
    LOBYTE(a1) = sub_1CD071418(a1, v19, (uint64_t)&v38, a4, (unsigned int *)&v41);
    if (a1) {
      break;
    }
    LODWORD(v42) = 0;
    int v19 = *(unsigned int **)v19;
    if (v19) {
      BOOL v21 = (v19 & 1) == 0;
    }
    else {
      BOOL v21 = 0;
    }
    if (!v21)
    {
      int v19 = 0;
      goto LABEL_37;
    }
  }
  uint64_t v18 = 0;
LABEL_37:
  if (v41 != v43)
  {
    free(v41);
    if (v19) {
      goto LABEL_39;
    }
LABEL_41:
    if (v15)
    {
      *(void *)(v6 + 888) += 24;
      uint64_t v23 = *(void *)(v6 + 808);
      if (((v23 + 7) & 0xFFFFFFFFFFFFFFF8) - v23 + 24 > *(void *)(v6 + 816) - v23)
      {
        unsigned int v33 = *(_DWORD *)(v6 + 832) >> 7;
        if (v33 >= 0x1E) {
          LOBYTE(v33) = 30;
        }
        uint64_t v34 = 4096 << v33;
        unint64_t v24 = (unint64_t)operator new(4096 << v33, (std::align_val_t)8uLL);
        unsigned int v35 = *(_DWORD *)(v6 + 832);
        if (v35 >= *(_DWORD *)(v6 + 836)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v6 + 824) + 8 * v35) = v24;
        ++*(_DWORD *)(v6 + 832);
        *(void *)(v6 + 816) = v24 + v34;
      }
      else
      {
        unint64_t v24 = (v23 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(v6 + 808) = v24 + 24;
      uint64_t v8 = v24 + 8;
      *(unsigned char *)(v24 + 16) = 44;
      *(_WORD *)(v24 + 17) = *(_WORD *)(v24 + 17) & 0xF000 | 0x540;
      *(void *)unint64_t v24 = 0;
      *(void *)(v24 + 8) = &unk_1F261A7B0;
      *(_DWORD *)(v24 + 20) = v9;
      unsigned int v25 = *(_DWORD *)(v6 + 916) + 1;
      int v26 = *(_DWORD *)(v6 + 912);
      if (v25 > 2 * v26)
      {
        long long v36 = (unsigned int *)v24;
        llvm::FoldingSetBase::GrowBucketCount(v6 + 904, 2 * v26, (uint64_t)off_1F2644D00);
        uint64_t v41 = v43;
        uint64_t v42 = 0x2000000000;
        sub_1CD0714B4(v36, (unsigned int *)&v41);
        uint64_t v18 = *(void *)(v6 + 904)
            + 8
            * ((*(_DWORD *)(v6 + 912) - 1) & sub_1CC13A6B8(v41, (uint64_t)v41 + 4 * v42));
        if (v41 != v43) {
          free(v41);
        }
        unsigned int v25 = *(_DWORD *)(v6 + 916) + 1;
        unint64_t v24 = (unint64_t)v36;
      }
      *(_DWORD *)(v6 + 916) = v25;
      uint64_t v27 = *(void *)v18;
      if (!*(void *)v18) {
        uint64_t v27 = v18 | 1;
      }
      *(void *)unint64_t v24 = v27;
      *(void *)uint64_t v18 = v24;
    }
    else
    {
      uint64_t v8 = 0;
    }
    int v22 = 1;
    goto LABEL_50;
  }
  if (!v19) {
    goto LABEL_41;
  }
LABEL_39:
  int v22 = 0;
  uint64_t v8 = (uint64_t)(v19 + 2);
LABEL_50:
  if (v38 != (char *)&v39 + 8) {
    free(v38);
  }
  if (v22)
  {
    *(void *)(v6 + 920) = v8;
  }
  else
  {
    if (!v8) {
      return v8;
    }
    uint64_t v41 = 0;
    int v31 = sub_1CD640748(v6 + 944, v8, &v41);
    uint64_t v32 = 0;
    if (v31) {
      uint64_t v32 = *((void *)v41 + 1);
    }
    if (v32) {
      uint64_t v8 = v32;
    }
    if (v8 == *(void *)(v6 + 928)) {
      *(unsigned char *)(v6 + 936) = 1;
    }
  }
  if (v8)
  {
    uint64_t v28 = sub_1CD085FB4(v6, v8);
    if (v28 != v8)
    {
      uint64_t v29 = v28;
      uint64_t v30 = *(uint64_t **)(v6 + 304);
      if (v30 == *(uint64_t **)(v6 + 312))
      {
        sub_1CD5F0ACC(v6 + 296, ((uint64_t)v30 - *(void *)(v6 + 296)) >> 2);
        uint64_t v30 = *(uint64_t **)(v6 + 304);
      }
      *(void *)(v6 + 304) = v30 + 1;
      *uint64_t v30 = v29;
      return v29;
    }
  }
  return v8;
}

uint64_t sub_1CD085FB4(uint64_t a1, uint64_t a2)
{
  v37[16] = *MEMORY[0x1E4F143B8];
  uint64_t v31 = a1 + 904;
  uint64_t v4 = a1 + 944;
  while (1)
  {
    uint64_t v5 = *(unsigned __int8 **)a1;
    if (*(void *)a1 == *(void *)(a1 + 8) || *v5 != 66) {
      return a2;
    }
    *(void *)a1 = v5 + 1;
    unsigned int v35 = 0;
    uint64_t v6 = 0;
    unsigned int v7 = 0;
    if ((sub_1CC6B813C((unsigned __int8 **)a1, (uint64_t *)&v35) & 1) == 0)
    {
      unsigned int v7 = *(unsigned __int8 **)a1;
      if (*(void *)(a1 + 8) - *(void *)a1 >= (unint64_t)v35)
      {
        uint64_t v6 = (unsigned __int8 *)v35 + (void)v7;
        *(void *)a1 = (char *)v35 + (void)v7;
      }
      else
      {
        uint64_t v6 = 0;
        unsigned int v7 = 0;
      }
    }
    if (v7 == v6) {
      return 0;
    }
    int v8 = *(unsigned __int8 *)(a1 + 937);
    uint64_t v32 = (char *)&v33 + 8;
    uint64_t v34 = a2;
    long long v33 = xmmword_1CFB2ED80;
    llvm::FoldingSetNodeID::AddString((unsigned int *)&v32, v7, v6 - v7);
    unint64_t v9 = sub_1CC13A6B8(v32, (uint64_t)v32 + 4 * v33);
    uint64_t v11 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v9);
    unint64_t v12 = *(unsigned int **)v11;
    unsigned int v35 = v37;
    uint64_t v36 = 0x2000000000;
    if (v12) {
      BOOL v13 = (v12 & 1) == 0;
    }
    else {
      BOOL v13 = 0;
    }
    if (!v13)
    {
LABEL_25:
      if (v8)
      {
        *(void *)(a1 + 888) += 48;
        uint64_t v16 = *(void *)(a1 + 808);
        if (((v16 + 7) & 0xFFFFFFFFFFFFFFF8) - v16 + 48 > *(void *)(a1 + 816) - v16)
        {
          unsigned int v24 = *(_DWORD *)(a1 + 832) >> 7;
          if (v24 >= 0x1E) {
            LOBYTE(v24) = 30;
          }
          uint64_t v25 = 4096 << v24;
          unint64_t v17 = (unint64_t)operator new(4096 << v24, (std::align_val_t)8uLL);
          unint64_t v26 = *(unsigned int *)(a1 + 832);
          if (v26 >= *(unsigned int *)(a1 + 836)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)(a1 + 824) + 8 * v26) = v17;
          ++*(_DWORD *)(a1 + 832);
          *(void *)(a1 + 816) = v17 + v25;
        }
        else
        {
          unint64_t v17 = (v16 + 7) & 0xFFFFFFFFFFFFFFF8;
        }
        *(void *)(a1 + 808) = v17 + 48;
        *(void *)unint64_t v17 = 0;
        __int16 v18 = *(_WORD *)(a2 + 9);
        *(unsigned char *)(v17 + 16) = 8;
        *(_WORD *)(v17 + 17) = *(_WORD *)(v17 + 17) & 0xF000 | v18 & 0xFC0;
        *(void *)(v17 + 8) = &unk_1F261A808;
        *(void *)(v17 + 24) = a2;
        *(void *)(v17 + 32) = v7;
        *(void *)(v17 + 40) = v6;
        unsigned int v19 = *(_DWORD *)(a1 + 916) + 1;
        int v20 = *(_DWORD *)(a1 + 912);
        if (v19 > 2 * v20)
        {
          llvm::FoldingSetBase::GrowBucketCount(v31, 2 * v20, (uint64_t)off_1F2644D00);
          unsigned int v35 = v37;
          uint64_t v36 = 0x2000000000;
          sub_1CD0714B4((unsigned int *)v17, (unsigned int *)&v35);
          unsigned int v27 = sub_1CC13A6B8(v35, (uint64_t)v35 + 4 * v36);
          uint64_t v28 = *(void *)(a1 + 904);
          int v29 = *(_DWORD *)(a1 + 912);
          if (v35 != v37) {
            free(v35);
          }
          uint64_t v11 = v28 + 8 * ((v29 - 1) & v27);
          unsigned int v19 = *(_DWORD *)(a1 + 916) + 1;
        }
        *(_DWORD *)(a1 + 916) = v19;
        uint64_t v21 = *(void *)v11;
        if (!*(void *)v11) {
          uint64_t v21 = v11 | 1;
        }
        *(void *)unint64_t v17 = v21;
        *(void *)uint64_t v11 = v17;
        int v15 = 1;
        a2 = v17 + 8;
      }
      else
      {
        a2 = 0;
        int v15 = 1;
      }
      goto LABEL_33;
    }
    while (1)
    {
      LOBYTE(v9) = sub_1CD071418(v9, v12, (uint64_t)&v32, v10, (unsigned int *)&v35);
      if (v9) {
        break;
      }
      LODWORD(v36) = 0;
      unint64_t v12 = *(unsigned int **)v12;
      if (v12) {
        BOOL v14 = (v12 & 1) == 0;
      }
      else {
        BOOL v14 = 0;
      }
      if (!v14)
      {
        unint64_t v12 = 0;
        goto LABEL_21;
      }
    }
    uint64_t v11 = 0;
LABEL_21:
    if (v35 == v37)
    {
      if (!v12) {
        goto LABEL_25;
      }
    }
    else
    {
      free(v35);
      if (!v12) {
        goto LABEL_25;
      }
    }
    int v15 = 0;
    a2 = (uint64_t)(v12 + 2);
LABEL_33:
    if (v32 != (char *)&v33 + 8) {
      free(v32);
    }
    if (v15)
    {
      *(void *)(a1 + 920) = a2;
      if (!a2) {
        return a2;
      }
    }
    else
    {
      if (!a2) {
        return a2;
      }
      unsigned int v35 = 0;
      int v22 = sub_1CD640748(v4, a2, &v35);
      uint64_t v23 = 0;
      if (v22) {
        uint64_t v23 = *((void *)v35 + 1);
      }
      if (v23) {
        a2 = v23;
      }
      if (a2 == *(void *)(a1 + 928)) {
        *(unsigned char *)(a1 + 936) = 1;
      }
    }
  }
}

uint64_t sub_1CD0863D0(uint64_t a1, unsigned char *a2)
{
  v47[16] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = sub_1CD07E754((unsigned __int8 **)a1);
  if (v4)
  {
    unsigned int v5 = v4[2];
    if (v5 == 8)
    {
      char v6 = *(unsigned char *)(a1 + 776);
      *(unsigned char *)(a1 + 776) = 0;
      int v7 = *(unsigned __int8 *)(a1 + 777);
      if (a2) {
        BOOL v8 = 0;
      }
      else {
        BOOL v8 = v7 == 0;
      }
      char v9 = !v8;
      *(unsigned char *)(a1 + 777) = v9;
      *(void *)&long long v46 = sub_1CD06B2C4(a1);
      if ((void)v46)
      {
        if (a2) {
          *a2 = 1;
        }
        uint64_t v12 = sub_1CD08692C(a1, (uint64_t *)&v46, v10, v11);
      }
      else
      {
        uint64_t v12 = 0;
      }
      *(unsigned char *)(a1 + 777) = v7;
      *(unsigned char *)(a1 + 776) = v6;
      return v12;
    }
    if (v5 <= 0xA && (v5 != 4 || (v4[3] & 1) != 0))
    {
      __int16 v18 = (const char *)*((void *)v4 + 1);
      *(void *)&long long v46 = v18;
      *((void *)&v46 + 1) = &v18[strlen(v18)];
      return sub_1CD077500(a1, &v46);
    }
    return 0;
  }
  BOOL v13 = *(unsigned __int8 **)a1;
  BOOL v14 = *(unsigned __int8 **)(a1 + 8);
  if ((unint64_t)&v14[-*(void *)a1] < 2 || strncmp("li", *(const char **)a1, 2uLL))
  {
    if (v13 != v14 && *v13 == 118)
    {
      *(void *)a1 = v13 + 1;
      if (v14 != v13 + 1 && v13[1] - 48 <= 9)
      {
        *(void *)a1 = v13 + 2;
        *(void *)&long long v46 = sub_1CD081610(a1);
        if ((void)v46) {
          return sub_1CD08692C(a1, (uint64_t *)&v46, v15, v16);
        }
      }
    }
    return 0;
  }
  *(void *)a1 = v13 + 2;
  uint64_t v20 = sub_1CD081610(a1);
  if (!v20) {
    return 0;
  }
  uint64_t v22 = v20;
  int v23 = *(unsigned __int8 *)(a1 + 937);
  BOOL v43 = (char *)&v44 + 8;
  uint64_t v45 = v20;
  long long v44 = xmmword_1CFB2ED90;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
  {
    uint64_t v20 = __cxa_guard_acquire(&qword_1EBCBE588);
    if (v20)
    {
      unint64_t v42 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v42 = 0xFF51AFD7ED558CCDLL;
      }
      qword_1EBCBE580 = v42;
      __cxa_guard_release(&qword_1EBCBE588);
    }
  }
  unint64_t v24 = 0x9DDFEA08EB382D69 * (*((void *)&v44 + 1) ^ qword_1EBCBE580 ^ __ROR8__(v45 + 16, 16));
  unint64_t v25 = __ROR8__(v45 + 16, 16) ^ (v24 >> 47);
  uint64_t v26 = *(void *)(a1 + 904)
      + 8
      * ((*(_DWORD *)(a1 + 912) - 1) & ((-348639895
                                       * ((((0x9DDFEA08EB382D69 * (v25 ^ v24)) >> 32) >> 15) ^ (-348639895 * (v25 ^ v24)))) ^ v45));
  unsigned int v27 = *(unsigned int **)v26;
  *(void *)&long long v46 = v47;
  *((void *)&v46 + 1) = 0x2000000000;
  if (v27) {
    BOOL v28 = (v27 & 1) == 0;
  }
  else {
    BOOL v28 = 0;
  }
  if (!v28) {
    goto LABEL_48;
  }
  while (1)
  {
    LOBYTE(v20) = sub_1CD071418(v20, v27, (uint64_t)&v43, v21, (unsigned int *)&v46);
    if (v20) {
      break;
    }
    DWORD2(v46) = 0;
    unsigned int v27 = *(unsigned int **)v27;
    if (v27) {
      BOOL v29 = (v27 & 1) == 0;
    }
    else {
      BOOL v29 = 0;
    }
    if (!v29)
    {
      unsigned int v27 = 0;
      goto LABEL_44;
    }
  }
  uint64_t v26 = 0;
LABEL_44:
  if ((void *)v46 != v47)
  {
    free((void *)v46);
    if (v27) {
      goto LABEL_46;
    }
LABEL_48:
    if (v23)
    {
      *(void *)(a1 + 888) += 32;
      uint64_t v31 = *(void *)(a1 + 808);
      if (((v31 + 7) & 0xFFFFFFFFFFFFFFF8) - v31 + 32 > *(void *)(a1 + 816) - v31)
      {
        unsigned int v38 = *(_DWORD *)(a1 + 832) >> 7;
        if (v38 >= 0x1E) {
          LOBYTE(v38) = 30;
        }
        uint64_t v39 = 4096 << v38;
        unint64_t v32 = (unint64_t)operator new(4096 << v38, (std::align_val_t)8uLL);
        unsigned int v40 = *(_DWORD *)(a1 + 832);
        if (v40 >= *(_DWORD *)(a1 + 836)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 824) + 8 * v40) = v32;
        ++*(_DWORD *)(a1 + 832);
        *(void *)(a1 + 816) = v32 + v39;
      }
      else
      {
        unint64_t v32 = (v31 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(a1 + 808) = v32 + 32;
      uint64_t v12 = v32 + 8;
      *(unsigned char *)(v32 + 16) = 19;
      *(_WORD *)(v32 + 17) = *(_WORD *)(v32 + 17) & 0xF000 | 0x540;
      *(void *)unint64_t v32 = 0;
      *(void *)(v32 + 8) = &unk_1F261A700;
      *(void *)(v32 + 24) = v22;
      unsigned int v33 = *(_DWORD *)(a1 + 916) + 1;
      int v34 = *(_DWORD *)(a1 + 912);
      if (v33 > 2 * v34)
      {
        uint64_t v41 = (unsigned int *)v32;
        llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v34, (uint64_t)off_1F2644D00);
        *(void *)&long long v46 = v47;
        *((void *)&v46 + 1) = 0x2000000000;
        sub_1CD0714B4(v41, (unsigned int *)&v46);
        uint64_t v26 = *(void *)(a1 + 904)
            + 8 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8((void *)v46, v46 + 4 * DWORD2(v46)));
        if ((void *)v46 != v47) {
          free((void *)v46);
        }
        unsigned int v33 = *(_DWORD *)(a1 + 916) + 1;
        unint64_t v32 = (unint64_t)v41;
      }
      *(_DWORD *)(a1 + 916) = v33;
      uint64_t v35 = *(void *)v26;
      if (!*(void *)v26) {
        uint64_t v35 = v26 | 1;
      }
      *(void *)unint64_t v32 = v35;
      *(void *)uint64_t v26 = v32;
    }
    else
    {
      uint64_t v12 = 0;
    }
    int v30 = 1;
    goto LABEL_57;
  }
  if (!v27) {
    goto LABEL_48;
  }
LABEL_46:
  int v30 = 0;
  uint64_t v12 = (uint64_t)(v27 + 2);
LABEL_57:
  if (v43 != (char *)&v44 + 8) {
    free(v43);
  }
  if (v30)
  {
    *(void *)(a1 + 920) = v12;
  }
  else if (v12)
  {
    *(void *)&long long v46 = 0;
    int v36 = sub_1CD640748(a1 + 944, v12, &v46);
    uint64_t v37 = 0;
    if (v36) {
      uint64_t v37 = *(void *)(v46 + 8);
    }
    if (v37) {
      uint64_t v12 = v37;
    }
    if (v12 == *(void *)(a1 + 928)) {
      *(unsigned char *)(a1 + 936) = 1;
    }
  }
  return v12;
}

uint64_t sub_1CD08692C(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a1;
  v33[16] = *MEMORY[0x1E4F143B8];
  int v6 = *(unsigned __int8 *)(a1 + 937);
  BOOL v28 = (char *)&v29 + 8;
  uint64_t v30 = *a2;
  long long v29 = xmmword_1CFB2EDA0;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
  {
    a1 = __cxa_guard_acquire(&qword_1EBCBE588);
    if (a1)
    {
      unint64_t v27 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v27 = 0xFF51AFD7ED558CCDLL;
      }
      qword_1EBCBE580 = v27;
      __cxa_guard_release(&qword_1EBCBE588);
    }
  }
  unint64_t v7 = 0x9DDFEA08EB382D69 * (*((void *)&v29 + 1) ^ qword_1EBCBE580 ^ __ROR8__(v30 + 16, 16));
  unint64_t v8 = __ROR8__(v30 + 16, 16) ^ (v7 >> 47);
  uint64_t v9 = *(void *)(v5 + 904)
     + 8
     * ((*(_DWORD *)(v5 + 912) - 1) & ((-348639895
                                      * ((((0x9DDFEA08EB382D69 * (v8 ^ v7)) >> 32) >> 15) ^ (-348639895 * (v8 ^ v7)))) ^ v30));
  uint64_t v10 = *(unsigned int **)v9;
  uint64_t v31 = v33;
  uint64_t v32 = 0x2000000000;
  if (v10) {
    BOOL v11 = (v10 & 1) == 0;
  }
  else {
    BOOL v11 = 0;
  }
  if (!v11) {
    goto LABEL_18;
  }
  while (1)
  {
    LOBYTE(a1) = sub_1CD071418(a1, v10, (uint64_t)&v28, a4, (unsigned int *)&v31);
    if (a1) {
      break;
    }
    LODWORD(v32) = 0;
    uint64_t v10 = *(unsigned int **)v10;
    if (v10) {
      BOOL v12 = (v10 & 1) == 0;
    }
    else {
      BOOL v12 = 0;
    }
    if (!v12)
    {
      uint64_t v10 = 0;
      goto LABEL_14;
    }
  }
  uint64_t v9 = 0;
LABEL_14:
  if (v31 == v33)
  {
    if (v10)
    {
LABEL_16:
      int v13 = 0;
      uint64_t v14 = (uint64_t)(v10 + 2);
      goto LABEL_27;
    }
  }
  else
  {
    free(v31);
    if (v10) {
      goto LABEL_16;
    }
  }
LABEL_18:
  if (v6)
  {
    *(void *)(v5 + 888) += 32;
    uint64_t v15 = *(void *)(v5 + 808);
    if (((v15 + 7) & 0xFFFFFFFFFFFFFFF8) - v15 + 32 > *(void *)(v5 + 816) - v15)
    {
      unsigned int v24 = *(_DWORD *)(v5 + 832) >> 7;
      if (v24 >= 0x1E) {
        LOBYTE(v24) = 30;
      }
      uint64_t v25 = 4096 << v24;
      unint64_t v16 = (unint64_t)operator new(4096 << v24, (std::align_val_t)8uLL);
      unsigned int v26 = *(_DWORD *)(v5 + 832);
      if (v26 >= *(_DWORD *)(v5 + 836)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(v5 + 824) + 8 * v26) = v16;
      ++*(_DWORD *)(v5 + 832);
      *(void *)(v5 + 816) = v16 + v25;
    }
    else
    {
      unint64_t v16 = (v15 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    *(void *)(v5 + 808) = v16 + 32;
    *(void *)unint64_t v16 = 0;
    uint64_t v14 = v16 + 8;
    uint64_t v17 = *a2;
    *(unsigned char *)(v16 + 16) = 4;
    *(_WORD *)(v16 + 17) = *(_WORD *)(v16 + 17) & 0xF000 | 0x540;
    *(void *)(v16 + 8) = &unk_1F261A6A8;
    *(void *)(v16 + 24) = v17;
    unsigned int v18 = *(_DWORD *)(v5 + 916) + 1;
    int v19 = *(_DWORD *)(v5 + 912);
    if (v18 > 2 * v19)
    {
      llvm::FoldingSetBase::GrowBucketCount(v5 + 904, 2 * v19, (uint64_t)off_1F2644D00);
      uint64_t v31 = v33;
      uint64_t v32 = 0x2000000000;
      sub_1CD0714B4((unsigned int *)v16, (unsigned int *)&v31);
      uint64_t v9 = *(void *)(v5 + 904)
         + 8 * ((*(_DWORD *)(v5 + 912) - 1) & sub_1CC13A6B8(v31, (uint64_t)v31 + 4 * v32));
      if (v31 != v33) {
        free(v31);
      }
      unsigned int v18 = *(_DWORD *)(v5 + 916) + 1;
    }
    *(_DWORD *)(v5 + 916) = v18;
    uint64_t v20 = *(void *)v9;
    if (!*(void *)v9) {
      uint64_t v20 = v9 | 1;
    }
    *(void *)unint64_t v16 = v20;
    *(void *)uint64_t v9 = v16;
  }
  else
  {
    uint64_t v14 = 0;
  }
  int v13 = 1;
LABEL_27:
  if (v28 != (char *)&v29 + 8) {
    free(v28);
  }
  if (v13)
  {
    *(void *)(v5 + 920) = v14;
  }
  else if (v14)
  {
    uint64_t v31 = 0;
    int v22 = sub_1CD640748(v5 + 944, v14, &v31);
    uint64_t v23 = 0;
    if (v22) {
      uint64_t v23 = *((void *)v31 + 1);
    }
    if (v23) {
      uint64_t v14 = v23;
    }
    if (v14 == *(void *)(v5 + 928)) {
      *(unsigned char *)(v5 + 936) = 1;
    }
  }
  return v14;
}

uint64_t sub_1CD086D28(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v6 = a1;
  v39[16] = *MEMORY[0x1E4F143B8];
  int v7 = *(unsigned __int8 *)(a1 + 937);
  unsigned int v33 = (char *)&v34 + 8;
  uint64_t v8 = *a3;
  unint64_t v9 = HIDWORD(*a2);
  LODWORD(v35) = *a2;
  HIDWORD(v35) = v9;
  uint64_t v36 = v8;
  long long v34 = xmmword_1CFB2EAA0;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
  {
    a1 = __cxa_guard_acquire(&qword_1EBCBE588);
    if (a1)
    {
      unint64_t v32 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v32 = 0xFF51AFD7ED558CCDLL;
      }
      qword_1EBCBE580 = v32;
      __cxa_guard_release(&qword_1EBCBE588);
    }
  }
  uint64_t v10 = __ROR8__(0xB492B66FBE98F273 * *((void *)&v34 + 1) - v35, 43)
      - 0x3C5A37A36834CED9 * v35
      + __ROR8__((0x9AE16A3B2F90404FLL * v36) ^ qword_1EBCBE580, 30);
  unint64_t v11 = qword_1EBCBE580
      + __ROR8__(v35 ^ 0xC949D7C7509E6557, 20)
      - 0x4B6D499041670D8DLL * *((void *)&v34 + 1)
      - 0x9AE16A3B2F90404FLL * v36
      + 24;
  unint64_t v12 = 0x9DDFEA08EB382D69
      * (v11 ^ ((0x9DDFEA08EB382D69 * (v10 ^ v11)) >> 47) ^ (0x9DDFEA08EB382D69 * (v10 ^ v11)));
  uint64_t v13 = *(void *)(v6 + 904)
      + 8 * ((-348639895 * ((v12 >> 47) ^ v12)) & (*(_DWORD *)(v6 + 912) - 1));
  uint64_t v14 = *(unsigned int **)v13;
  uint64_t v37 = v39;
  uint64_t v38 = 0x2000000000;
  if (v14) {
    BOOL v15 = (v14 & 1) == 0;
  }
  else {
    BOOL v15 = 0;
  }
  if (!v15) {
    goto LABEL_18;
  }
  while (1)
  {
    LOBYTE(a1) = sub_1CD071418(a1, v14, (uint64_t)&v33, a4, (unsigned int *)&v37);
    if (a1) {
      break;
    }
    LODWORD(v38) = 0;
    uint64_t v14 = *(unsigned int **)v14;
    if (v14) {
      BOOL v16 = (v14 & 1) == 0;
    }
    else {
      BOOL v16 = 0;
    }
    if (!v16)
    {
      uint64_t v14 = 0;
      goto LABEL_14;
    }
  }
  uint64_t v13 = 0;
LABEL_14:
  if (v37 == v39)
  {
    if (v14)
    {
LABEL_16:
      int v17 = 0;
      uint64_t v18 = (uint64_t)(v14 + 2);
      goto LABEL_27;
    }
  }
  else
  {
    free(v37);
    if (v14) {
      goto LABEL_16;
    }
  }
LABEL_18:
  if (v7)
  {
    *(void *)(v6 + 888) += 40;
    uint64_t v19 = *(void *)(v6 + 808);
    if (((v19 + 7) & 0xFFFFFFFFFFFFFFF8) - v19 + 40 > *(void *)(v6 + 816) - v19)
    {
      unsigned int v29 = *(_DWORD *)(v6 + 832) >> 7;
      if (v29 >= 0x1E) {
        LOBYTE(v29) = 30;
      }
      uint64_t v30 = 4096 << v29;
      unint64_t v20 = (unint64_t)operator new(4096 << v29, (std::align_val_t)8uLL);
      unsigned int v31 = *(_DWORD *)(v6 + 832);
      if (v31 >= *(_DWORD *)(v6 + 836)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(v6 + 824) + 8 * v31) = v20;
      ++*(_DWORD *)(v6 + 832);
      *(void *)(v6 + 816) = v20 + v30;
    }
    else
    {
      unint64_t v20 = (v19 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    *(void *)(v6 + 808) = v20 + 40;
    *(void *)unint64_t v20 = 0;
    uint64_t v18 = v20 + 8;
    uint64_t v21 = *a2;
    uint64_t v22 = *a3;
    *(unsigned char *)(v20 + 16) = 27;
    *(_WORD *)(v20 + 17) = *(_WORD *)(v20 + 17) & 0xF000 | 0x540;
    *(void *)(v20 + 8) = &unk_1F261AFF0;
    *(void *)(v20 + 24) = v21;
    *(void *)(v20 + 32) = v22;
    unsigned int v23 = *(_DWORD *)(v6 + 916) + 1;
    int v24 = *(_DWORD *)(v6 + 912);
    if (v23 > 2 * v24)
    {
      llvm::FoldingSetBase::GrowBucketCount(v6 + 904, 2 * v24, (uint64_t)off_1F2644D00);
      uint64_t v37 = v39;
      uint64_t v38 = 0x2000000000;
      sub_1CD0714B4((unsigned int *)v20, (unsigned int *)&v37);
      uint64_t v13 = *(void *)(v6 + 904)
          + 8 * ((*(_DWORD *)(v6 + 912) - 1) & sub_1CC13A6B8(v37, (uint64_t)v37 + 4 * v38));
      if (v37 != v39) {
        free(v37);
      }
      unsigned int v23 = *(_DWORD *)(v6 + 916) + 1;
    }
    *(_DWORD *)(v6 + 916) = v23;
    uint64_t v25 = *(void *)v13;
    if (!*(void *)v13) {
      uint64_t v25 = v13 | 1;
    }
    *(void *)unint64_t v20 = v25;
    *(void *)uint64_t v13 = v20;
  }
  else
  {
    uint64_t v18 = 0;
  }
  int v17 = 1;
LABEL_27:
  if (v33 != (char *)&v34 + 8) {
    free(v33);
  }
  if (v17)
  {
    *(void *)(v6 + 920) = v18;
  }
  else if (v18)
  {
    uint64_t v37 = 0;
    int v27 = sub_1CD640748(v6 + 944, v18, &v37);
    uint64_t v28 = 0;
    if (v27) {
      uint64_t v28 = *((void *)v37 + 1);
    }
    if (v28) {
      uint64_t v18 = v28;
    }
    if (v18 == *(void *)(v6 + 928)) {
      *(unsigned char *)(v6 + 936) = 1;
    }
  }
  return v18;
}

uint64_t sub_1CD0871B0(uint64_t a1, unsigned char *a2, uint64_t a3, uint64_t a4)
{
  v124[16] = *MEMORY[0x1E4F143B8];
  uint64_t v116 = a4;
  uint64_t v117 = a3;
  uint64_t v7 = sub_1CD0883BC(a1, &v116);
  if (v7) {
    return 0;
  }
  unint64_t v11 = *(unsigned __int8 **)a1;
  unint64_t v12 = *(unsigned __int8 **)(a1 + 8);
  if (*(unsigned __int8 **)a1 != v12 && *v11 == 76) {
    *(void *)a1 = ++v11;
  }
  if (v12 != v11 && (char)*v11 >= 49)
  {
    unsigned int v13 = *v11;
    if (v13 <= 0x39)
    {
      uint64_t v14 = sub_1CD081610(a1);
LABEL_34:
      uint64_t v24 = v14;
      goto LABEL_35;
    }
    if (v13 == 85)
    {
      uint64_t v14 = sub_1CD0821D8(a1, (uint64_t)a2);
      goto LABEL_34;
    }
  }
  if ((unint64_t)(v12 - v11) >= 2)
  {
    uint64_t v7 = strncmp("DC", (const char *)v11, 2uLL);
    if (!v7)
    {
      *(void *)a1 = v11 + 2;
      uint64_t v35 = *(void *)(a1 + 16);
      uint64_t v36 = *(void *)(a1 + 24);
      uint64_t v37 = sub_1CD081610(a1);
      if (!v37) {
        return 0;
      }
      uint64_t v38 = v37;
      uint64_t v39 = (v36 - v35) >> 3;
      while (1)
      {
        unsigned int v40 = *(uint64_t **)(a1 + 24);
        if (v40 == *(uint64_t **)(a1 + 32))
        {
          sub_1CD5F0ACC(a1 + 16, ((uint64_t)v40 - *(void *)(a1 + 16)) >> 2);
          unsigned int v40 = *(uint64_t **)(a1 + 24);
        }
        *(void *)(a1 + 24) = v40 + 1;
        uint64_t *v40 = v38;
        uint64_t v41 = *(unsigned __int8 **)a1;
        if (*(void *)a1 != *(void *)(a1 + 8) && *v41 == 69) {
          break;
        }
        uint64_t v38 = sub_1CD081610(a1);
        uint64_t v9 = 0;
        if (!v38) {
          return v9;
        }
      }
      *(void *)a1 = v41 + 1;
      uint64_t v42 = *(void *)(a1 + 24);
      BOOL v43 = (const void *)(*(void *)(a1 + 16) + 8 * v39);
      long long v44 = (uint64_t *)sub_1CB906F34((uint64_t *)(a1 + 808), v42 - (void)v43, 3);
      uint64_t v45 = v44;
      int64_t v46 = v42 - (void)v43;
      if (v46) {
        memmove(v44, v43, v46);
      }
      uint64_t v47 = v46 >> 3;
      *(void *)(a1 + 24) = *(void *)(a1 + 16) + 8 * v39;
      int v48 = *(unsigned __int8 *)(a1 + 937);
      unsigned int v118 = (char *)&v119 + 8;
      *(void *)&long long v119 = 0x2000000000;
      sub_1CD074590((uint64_t)&v118, 49, v45, v47);
      unint64_t v49 = sub_1CC13A6B8(v118, (uint64_t)v118 + 4 * v119);
      uint64_t v50 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v49);
      int v51 = *(unsigned int **)v50;
      uint64_t v122 = v124;
      uint64_t v123 = 0x2000000000;
      if (v51) {
        BOOL v52 = (v51 & 1) == 0;
      }
      else {
        BOOL v52 = 0;
      }
      if (!v52) {
        goto LABEL_158;
      }
      while (1)
      {
        LOBYTE(v49) = sub_1CD071418(v49, v51, (uint64_t)&v118, v15, (unsigned int *)&v122);
        if (v49) {
          break;
        }
        LODWORD(v123) = 0;
        int v51 = *(unsigned int **)v51;
        if (v51) {
          BOOL v53 = (v51 & 1) == 0;
        }
        else {
          BOOL v53 = 0;
        }
        if (!v53)
        {
          int v51 = 0;
          goto LABEL_75;
        }
      }
      uint64_t v50 = 0;
LABEL_75:
      if (v122 == v124)
      {
        if (v51)
        {
LABEL_77:
          int v54 = 0;
          uint64_t v24 = (uint64_t)(v51 + 2);
          goto LABEL_167;
        }
      }
      else
      {
        free(v122);
        if (v51) {
          goto LABEL_77;
        }
      }
LABEL_158:
      if (v48)
      {
        *(void *)(a1 + 888) += 40;
        uint64_t v89 = *(void *)(a1 + 808);
        if (((v89 + 7) & 0xFFFFFFFFFFFFFFF8) - v89 + 40 > *(void *)(a1 + 816) - v89)
        {
          unsigned int v95 = *(_DWORD *)(a1 + 832) >> 7;
          if (v95 >= 0x1E) {
            LOBYTE(v95) = 30;
          }
          uint64_t v96 = 4096 << v95;
          unint64_t v90 = (unint64_t)operator new(4096 << v95, (std::align_val_t)8uLL);
          unsigned int v97 = *(_DWORD *)(a1 + 832);
          if (v97 >= *(_DWORD *)(a1 + 836)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)(a1 + 824) + 8 * v97) = v90;
          ++*(_DWORD *)(a1 + 832);
          *(void *)(a1 + 816) = v90 + v96;
        }
        else
        {
          unint64_t v90 = (v89 + 7) & 0xFFFFFFFFFFFFFFF8;
        }
        *(void *)(a1 + 808) = v90 + 40;
        uint64_t v24 = v90 + 8;
        *(unsigned char *)(v90 + 16) = 49;
        *(_WORD *)(v90 + 17) = *(_WORD *)(v90 + 17) & 0xF000 | 0x540;
        *(void *)unint64_t v90 = 0;
        *(void *)(v90 + 8) = &unk_1F261A860;
        *(void *)(v90 + 24) = v45;
        *(void *)(v90 + 32) = v47;
        unsigned int v91 = *(_DWORD *)(a1 + 916) + 1;
        int v92 = *(_DWORD *)(a1 + 912);
        if (v91 > 2 * v92)
        {
          uint64_t v98 = (unsigned int *)v90;
          llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v92, (uint64_t)off_1F2644D00);
          uint64_t v122 = v124;
          uint64_t v123 = 0x2000000000;
          sub_1CD0714B4(v98, (unsigned int *)&v122);
          uint64_t v50 = *(void *)(a1 + 904)
              + 8
              * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v122, (uint64_t)v122 + 4 * v123));
          if (v122 != v124) {
            free(v122);
          }
          unsigned int v91 = *(_DWORD *)(a1 + 916) + 1;
          unint64_t v90 = (unint64_t)v98;
        }
        *(_DWORD *)(a1 + 916) = v91;
        uint64_t v93 = *(void *)v50;
        if (!*(void *)v50) {
          uint64_t v93 = v50 | 1;
        }
        *(void *)unint64_t v90 = v93;
        *(void *)uint64_t v50 = v90;
      }
      else
      {
        uint64_t v24 = 0;
      }
      int v54 = 1;
LABEL_167:
      uint64_t v14 = (uint64_t)v118;
      if (v118 != (char *)&v119 + 8) {
        free(v118);
      }
      if (v54)
      {
        *(void *)(a1 + 920) = v24;
      }
      else
      {
        if (!v24) {
          return 0;
        }
        uint64_t v122 = 0;
        uint64_t v14 = sub_1CD640748(a1 + 944, v24, &v122);
        uint64_t v94 = 0;
        if (v14) {
          uint64_t v94 = *((void *)v122 + 1);
        }
        if (v94) {
          uint64_t v24 = v94;
        }
        if (v24 == *(void *)(a1 + 928)) {
          *(unsigned char *)(a1 + 936) = 1;
        }
      }
LABEL_35:
      if (!v24 || (uint64_t v25 = v116) == 0)
      {
LABEL_95:
        if (v24)
        {
          uint64_t v61 = sub_1CD085FB4(a1, v24);
          uint64_t v9 = v61;
          if (!v61) {
            return v9;
          }
          uint64_t v63 = v117;
          if (!v117) {
            return v9;
          }
          int v64 = *(unsigned __int8 *)(a1 + 937);
          unsigned int v118 = (char *)&v119 + 8;
          uint64_t v120 = v117;
          uint64_t v121 = v61;
          long long v119 = xmmword_1CFB2EDD0;
          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
          {
            uint64_t v61 = __cxa_guard_acquire(&qword_1EBCBE588);
            if (v61)
            {
              unint64_t v114 = llvm::hashing::detail::fixed_seed_override;
              if (!llvm::hashing::detail::fixed_seed_override) {
                unint64_t v114 = 0xFF51AFD7ED558CCDLL;
              }
              qword_1EBCBE580 = v114;
              __cxa_guard_release(&qword_1EBCBE588);
            }
          }
          uint64_t v65 = __ROR8__(0xB492B66FBE98F273 * *((void *)&v119 + 1) - v120, 43);
          uint64_t v66 = __ROR8__((0x9AE16A3B2F90404FLL * v121) ^ qword_1EBCBE580, 30);
          unint64_t v67 = qword_1EBCBE580
              + __ROR8__(v120 ^ 0xC949D7C7509E6557, 20)
              - 0x4B6D499041670D8DLL * *((void *)&v119 + 1)
              - 0x9AE16A3B2F90404FLL * v121
              + 24;
          unint64_t v68 = 0x9DDFEA08EB382D69
              * (v67 ^ ((0x9DDFEA08EB382D69 * ((v65 - 0x3C5A37A36834CED9 * v120 + v66) ^ v67)) >> 47) ^ (0x9DDFEA08EB382D69 * ((v65 - 0x3C5A37A36834CED9 * v120 + v66) ^ v67)));
          uint64_t v69 = *(void *)(a1 + 904)
              + 8 * ((-348639895 * ((v68 >> 47) ^ v68)) & (*(_DWORD *)(a1 + 912) - 1));
          int v70 = *(unsigned int **)v69;
          uint64_t v122 = v124;
          uint64_t v123 = 0x2000000000;
          if (v70) {
            BOOL v71 = (v70 & 1) == 0;
          }
          else {
            BOOL v71 = 0;
          }
          if (!v71) {
            goto LABEL_130;
          }
          while (1)
          {
            LOBYTE(v61) = sub_1CD071418(v61, v70, (uint64_t)&v118, v62, (unsigned int *)&v122);
            if (v61) {
              break;
            }
            LODWORD(v123) = 0;
            int v70 = *(unsigned int **)v70;
            if (v70) {
              BOOL v72 = (v70 & 1) == 0;
            }
            else {
              BOOL v72 = 0;
            }
            if (!v72)
            {
              int v70 = 0;
              goto LABEL_118;
            }
          }
          uint64_t v69 = 0;
LABEL_118:
          if (v122 == v124)
          {
            if (v70)
            {
LABEL_120:
              int v75 = 0;
              uint64_t v9 = (uint64_t)(v70 + 2);
LABEL_138:
              if (v118 != (char *)&v119 + 8) {
                free(v118);
              }
              if (v75)
              {
                *(void *)(a1 + 920) = v9;
              }
              else if (v9)
              {
                uint64_t v122 = 0;
                int v84 = sub_1CD640748(a1 + 944, v9, &v122);
                uint64_t v85 = 0;
                if (v84) {
                  uint64_t v85 = *((void *)v122 + 1);
                }
                if (v85) {
                  uint64_t v9 = v85;
                }
                if (v9 == *(void *)(a1 + 928)) {
                  *(unsigned char *)(a1 + 936) = 1;
                }
              }
              return v9;
            }
          }
          else
          {
            free(v122);
            if (v70) {
              goto LABEL_120;
            }
          }
LABEL_130:
          if (v64)
          {
            *(void *)(a1 + 888) += 40;
            uint64_t v79 = *(void *)(a1 + 808);
            if (((v79 + 7) & 0xFFFFFFFFFFFFFFF8) - v79 + 40 > *(void *)(a1 + 816) - v79)
            {
              unsigned int v86 = *(_DWORD *)(a1 + 832) >> 7;
              if (v86 >= 0x1E) {
                LOBYTE(v86) = 30;
              }
              uint64_t v87 = 4096 << v86;
              unint64_t v80 = (unint64_t)operator new(4096 << v86, (std::align_val_t)8uLL);
              unsigned int v88 = *(_DWORD *)(a1 + 832);
              if (v88 >= *(_DWORD *)(a1 + 836)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *(void *)(*(void *)(a1 + 824) + 8 * v88) = v80;
              ++*(_DWORD *)(a1 + 832);
              *(void *)(a1 + 816) = v80 + v87;
            }
            else
            {
              unint64_t v80 = (v79 + 7) & 0xFFFFFFFFFFFFFFF8;
            }
            *(void *)(a1 + 808) = v80 + 40;
            *(unsigned char *)(v80 + 16) = 23;
            *(_WORD *)(v80 + 17) = *(_WORD *)(v80 + 17) & 0xF000 | 0x540;
            *(void *)unint64_t v80 = 0;
            *(void *)(v80 + 8) = &unk_1F261A9C0;
            *(void *)(v80 + 24) = v63;
            *(void *)(v80 + 32) = v9;
            unsigned int v81 = *(_DWORD *)(a1 + 916) + 1;
            int v82 = *(_DWORD *)(a1 + 912);
            if (v81 > 2 * v82)
            {
              llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v82, (uint64_t)off_1F2644D00);
              uint64_t v122 = v124;
              uint64_t v123 = 0x2000000000;
              sub_1CD0714B4((unsigned int *)v80, (unsigned int *)&v122);
              uint64_t v69 = *(void *)(a1 + 904)
                  + 8
                  * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v122, (uint64_t)v122 + 4 * v123));
              if (v122 != v124) {
                free(v122);
              }
              unsigned int v81 = *(_DWORD *)(a1 + 916) + 1;
            }
            *(_DWORD *)(a1 + 916) = v81;
            uint64_t v83 = *(void *)v69;
            if (!*(void *)v69) {
              uint64_t v83 = v69 | 1;
            }
            *(void *)unint64_t v80 = v83;
            *(void *)uint64_t v69 = v80;
            int v75 = 1;
            uint64_t v9 = v80 + 8;
          }
          else
          {
            uint64_t v9 = 0;
            int v75 = 1;
          }
          goto LABEL_138;
        }
        return 0;
      }
      int v26 = *(unsigned __int8 *)(a1 + 937);
      unsigned int v118 = (char *)&v119 + 8;
      uint64_t v120 = v116;
      uint64_t v121 = v24;
      long long v119 = xmmword_1CFB2EDC0;
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
      {
        uint64_t v14 = __cxa_guard_acquire(&qword_1EBCBE588);
        if (v14)
        {
          unint64_t v113 = llvm::hashing::detail::fixed_seed_override;
          if (!llvm::hashing::detail::fixed_seed_override) {
            unint64_t v113 = 0xFF51AFD7ED558CCDLL;
          }
          qword_1EBCBE580 = v113;
          __cxa_guard_release(&qword_1EBCBE588);
        }
      }
      uint64_t v27 = __ROR8__(0xB492B66FBE98F273 * *((void *)&v119 + 1) - v120, 43)
          - 0x3C5A37A36834CED9 * v120
          + __ROR8__((0x9AE16A3B2F90404FLL * v121) ^ qword_1EBCBE580, 30);
      unint64_t v28 = qword_1EBCBE580
          + __ROR8__(v120 ^ 0xC949D7C7509E6557, 20)
          - 0x4B6D499041670D8DLL * *((void *)&v119 + 1)
          - 0x9AE16A3B2F90404FLL * v121
          + 24;
      unint64_t v29 = 0x9DDFEA08EB382D69
          * (v28 ^ ((0x9DDFEA08EB382D69 * (v27 ^ v28)) >> 47) ^ (0x9DDFEA08EB382D69 * (v27 ^ v28)));
      uint64_t v30 = *(void *)(a1 + 904)
          + 8 * ((-348639895 * ((v29 >> 47) ^ v29)) & (*(_DWORD *)(a1 + 912) - 1));
      unsigned int v31 = *(unsigned int **)v30;
      uint64_t v122 = v124;
      uint64_t v123 = 0x2000000000;
      if (v31) {
        BOOL v32 = (v31 & 1) == 0;
      }
      else {
        BOOL v32 = 0;
      }
      if (!v32) {
        goto LABEL_83;
      }
      while (1)
      {
        LOBYTE(v14) = sub_1CD071418(v14, v31, (uint64_t)&v118, v15, (unsigned int *)&v122);
        if (v14) {
          break;
        }
        LODWORD(v123) = 0;
        unsigned int v31 = *(unsigned int **)v31;
        if (v31) {
          BOOL v33 = (v31 & 1) == 0;
        }
        else {
          BOOL v33 = 0;
        }
        if (!v33)
        {
          unsigned int v31 = 0;
          goto LABEL_50;
        }
      }
      uint64_t v30 = 0;
LABEL_50:
      if (v122 == v124)
      {
        if (v31)
        {
LABEL_52:
          int v34 = 0;
          uint64_t v24 = (uint64_t)(v31 + 2);
          goto LABEL_91;
        }
      }
      else
      {
        free(v122);
        if (v31) {
          goto LABEL_52;
        }
      }
LABEL_83:
      if (v26)
      {
        *(void *)(a1 + 888) += 40;
        uint64_t v56 = *(void *)(a1 + 808);
        if (((v56 + 7) & 0xFFFFFFFFFFFFFFF8) - v56 + 40 > *(void *)(a1 + 816) - v56)
        {
          unsigned int v76 = *(_DWORD *)(a1 + 832) >> 7;
          if (v76 >= 0x1E) {
            LOBYTE(v76) = 30;
          }
          uint64_t v77 = 4096 << v76;
          unint64_t v57 = (unint64_t)operator new(4096 << v76, (std::align_val_t)8uLL);
          unsigned int v78 = *(_DWORD *)(a1 + 832);
          if (v78 >= *(_DWORD *)(a1 + 836)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)(a1 + 824) + 8 * v78) = v57;
          ++*(_DWORD *)(a1 + 832);
          *(void *)(a1 + 816) = v57 + v77;
        }
        else
        {
          unint64_t v57 = (v56 + 7) & 0xFFFFFFFFFFFFFFF8;
        }
        *(void *)(a1 + 808) = v57 + 40;
        *(unsigned char *)(v57 + 16) = 26;
        *(_WORD *)(v57 + 17) = *(_WORD *)(v57 + 17) & 0xF000 | 0x540;
        *(void *)unint64_t v57 = 0;
        *(void *)(v57 + 8) = &unk_1F261A968;
        *(void *)(v57 + 24) = v25;
        *(void *)(v57 + 32) = v24;
        unsigned int v58 = *(_DWORD *)(a1 + 916) + 1;
        int v59 = *(_DWORD *)(a1 + 912);
        if (v58 > 2 * v59)
        {
          llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v59, (uint64_t)off_1F2644D00);
          uint64_t v122 = v124;
          uint64_t v123 = 0x2000000000;
          sub_1CD0714B4((unsigned int *)v57, (unsigned int *)&v122);
          uint64_t v30 = *(void *)(a1 + 904)
              + 8
              * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v122, (uint64_t)v122 + 4 * v123));
          if (v122 != v124) {
            free(v122);
          }
          unsigned int v58 = *(_DWORD *)(a1 + 916) + 1;
        }
        *(_DWORD *)(a1 + 916) = v58;
        uint64_t v60 = *(void *)v30;
        if (!*(void *)v30) {
          uint64_t v60 = v30 | 1;
        }
        *(void *)unint64_t v57 = v60;
        *(void *)uint64_t v30 = v57;
        int v34 = 1;
        uint64_t v24 = v57 + 8;
      }
      else
      {
        uint64_t v24 = 0;
        int v34 = 1;
      }
LABEL_91:
      if (v118 != (char *)&v119 + 8) {
        free(v118);
      }
      if (v34)
      {
        *(void *)(a1 + 920) = v24;
      }
      else
      {
        if (!v24) {
          return 0;
        }
        uint64_t v122 = 0;
        int v73 = sub_1CD640748(a1 + 944, v24, &v122);
        uint64_t v74 = 0;
        if (v73) {
          uint64_t v74 = *((void *)v122 + 1);
        }
        if (v74) {
          uint64_t v24 = v74;
        }
        if (v24 == *(void *)(a1 + 928)) {
          *(unsigned char *)(a1 + 936) = 1;
        }
      }
      goto LABEL_95;
    }
  }
  if (v12 == v11 || *v11 - 67 > 1)
  {
    uint64_t v14 = sub_1CD0863D0(a1, a2);
    goto LABEL_34;
  }
  uint64_t v9 = 0;
  if (!a3 || v116) {
    return v9;
  }
  if (*(unsigned char *)(a3 + 8) != 44 || (unsigned int v16 = *(_DWORD *)(a3 + 12), v16 - 2 > 3))
  {
LABEL_202:
    if (v11 == v12) {
      return 0;
    }
    int v104 = *v11;
    if (v104 == 67)
    {
      unint64_t v105 = v11 + 1;
      *(void *)a1 = v11 + 1;
      if (v11 + 1 == v12)
      {
        int v106 = 0;
        unint64_t v105 = v12;
      }
      else if (*v105 == 73)
      {
        unint64_t v105 = v11 + 2;
        *(void *)a1 = v11 + 2;
        int v106 = 1;
      }
      else
      {
        int v106 = 0;
      }
      if (v12 == v105 || *v105 - 49 > 4) {
        return 0;
      }
      LODWORD(v122) = 0;
      LODWORD(v122) = (char)*v105 - 48;
      *(void *)a1 = v105 + 1;
      if (a2) {
        *a2 = 1;
      }
      if (v106)
      {
        uint64_t v14 = sub_1CD06E334(a1, a2);
        if (!v14)
        {
          uint64_t v24 = 0;
          goto LABEL_35;
        }
      }
      LOBYTE(v118) = 0;
    }
    else
    {
      uint64_t v9 = 0;
      if ((unint64_t)(v12 - v11) < 2) {
        return v9;
      }
      if (v104 != 68) {
        return v9;
      }
      uint64_t v9 = 0;
      unsigned int v107 = v11[1];
      if (v107 > 0x35 || ((1 << v107) & 0x37000000000000) == 0) {
        return v9;
      }
      LODWORD(v122) = 0;
      LODWORD(v122) = (char)v11[1] - 48;
      *(void *)a1 = v11 + 2;
      if (a2) {
        *a2 = 1;
      }
      LOBYTE(v118) = 1;
    }
    uint64_t v14 = sub_1CD08890C(a1, &v117, (char *)&v118, (int *)&v122);
    goto LABEL_34;
  }
  int v17 = *(unsigned __int8 *)(a1 + 937);
  unsigned int v118 = (char *)&v119 + 8;
  LODWORD(v120) = v16;
  HIDWORD(v120) = v16 >> 31;
  long long v119 = xmmword_1CFB2EDB0;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
  {
    uint64_t v7 = __cxa_guard_acquire(&qword_1EBCBE588);
    if (v7)
    {
      unint64_t v115 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v115 = 0xFF51AFD7ED558CCDLL;
      }
      qword_1EBCBE580 = v115;
      __cxa_guard_release(&qword_1EBCBE588);
    }
  }
  unint64_t v18 = 0x9DDFEA08EB382D69 * (*((void *)&v119 + 1) ^ qword_1EBCBE580 ^ __ROR8__(v120 + 16, 16));
  unint64_t v19 = __ROR8__(v120 + 16, 16) ^ (v18 >> 47);
  uint64_t v20 = *(void *)(a1 + 904)
      + 8
      * ((*(_DWORD *)(a1 + 912) - 1) & ((-348639895
                                       * ((((0x9DDFEA08EB382D69 * (v19 ^ v18)) >> 32) >> 15) ^ (-348639895 * (v19 ^ v18)))) ^ v120));
  uint64_t v21 = *(unsigned int **)v20;
  uint64_t v122 = v124;
  uint64_t v123 = 0x2000000000;
  if (v21) {
    BOOL v22 = (v21 & 1) == 0;
  }
  else {
    BOOL v22 = 0;
  }
  if (!v22) {
    goto LABEL_187;
  }
  while (1)
  {
    LOBYTE(v7) = sub_1CD071418(v7, v21, (uint64_t)&v118, v8, (unsigned int *)&v122);
    if (v7) {
      break;
    }
    LODWORD(v123) = 0;
    uint64_t v21 = *(unsigned int **)v21;
    if (v21) {
      BOOL v23 = (v21 & 1) == 0;
    }
    else {
      BOOL v23 = 0;
    }
    if (!v23)
    {
      uint64_t v21 = 0;
      goto LABEL_79;
    }
  }
  uint64_t v20 = 0;
LABEL_79:
  if (v122 == v124)
  {
    if (v21)
    {
LABEL_81:
      int v55 = 0;
      uint64_t v9 = (uint64_t)(v21 + 2);
      goto LABEL_196;
    }
  }
  else
  {
    free(v122);
    if (v21) {
      goto LABEL_81;
    }
  }
LABEL_187:
  if (v17)
  {
    *(void *)(a1 + 888) += 24;
    uint64_t v99 = *(void *)(a1 + 808);
    if (((v99 + 7) & 0xFFFFFFFFFFFFFFF8) - v99 + 24 > *(void *)(a1 + 816) - v99)
    {
      unsigned int v110 = *(_DWORD *)(a1 + 832) >> 7;
      if (v110 >= 0x1E) {
        LOBYTE(v110) = 30;
      }
      uint64_t v111 = 4096 << v110;
      unint64_t v100 = (unint64_t)operator new(4096 << v110, (std::align_val_t)8uLL);
      unsigned int v112 = *(_DWORD *)(a1 + 832);
      if (v112 >= *(_DWORD *)(a1 + 836)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(a1 + 824) + 8 * v112) = v100;
      ++*(_DWORD *)(a1 + 832);
      *(void *)(a1 + 816) = v100 + v111;
    }
    else
    {
      unint64_t v100 = (v99 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    *(void *)(a1 + 808) = v100 + 24;
    uint64_t v9 = v100 + 8;
    *(unsigned char *)(v100 + 16) = 43;
    *(_WORD *)(v100 + 17) = *(_WORD *)(v100 + 17) & 0xF000 | 0x540;
    *(void *)unint64_t v100 = 0;
    *(void *)(v100 + 8) = &unk_1F261A8B8;
    *(_DWORD *)(v100 + 20) = v16;
    unsigned int v101 = *(_DWORD *)(a1 + 916) + 1;
    int v102 = *(_DWORD *)(a1 + 912);
    if (v101 > 2 * v102)
    {
      llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v102, (uint64_t)off_1F2644D00);
      uint64_t v122 = v124;
      uint64_t v123 = 0x2000000000;
      sub_1CD0714B4((unsigned int *)v100, (unsigned int *)&v122);
      uint64_t v20 = *(void *)(a1 + 904)
          + 8
          * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v122, (uint64_t)v122 + 4 * v123));
      if (v122 != v124) {
        free(v122);
      }
      unsigned int v101 = *(_DWORD *)(a1 + 916) + 1;
    }
    *(_DWORD *)(a1 + 916) = v101;
    uint64_t v103 = *(void *)v20;
    if (!*(void *)v20) {
      uint64_t v103 = v20 | 1;
    }
    *(void *)unint64_t v100 = v103;
    *(void *)uint64_t v20 = v100;
  }
  else
  {
    uint64_t v9 = 0;
  }
  int v55 = 1;
LABEL_196:
  if (v118 != (char *)&v119 + 8) {
    free(v118);
  }
  if (v55)
  {
    *(void *)(a1 + 920) = v9;
  }
  else
  {
    if (!v9) {
      return v9;
    }
    uint64_t v122 = 0;
    int v108 = sub_1CD640748(a1 + 944, v9, &v122);
    uint64_t v109 = 0;
    if (v108) {
      uint64_t v109 = *((void *)v122 + 1);
    }
    if (v109) {
      uint64_t v9 = v109;
    }
    if (v9 == *(void *)(a1 + 928)) {
      *(unsigned char *)(a1 + 936) = 1;
    }
  }
  uint64_t v117 = v9;
  if (v9)
  {
    unint64_t v11 = *(unsigned __int8 **)a1;
    unint64_t v12 = *(unsigned __int8 **)(a1 + 8);
    goto LABEL_202;
  }
  return v9;
}

uint64_t sub_1CD0883BC(uint64_t a1, uint64_t *a2)
{
  v49[16] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(unsigned char **)a1;
  uint64_t v3 = *(unsigned char **)(a1 + 8);
  if (*(unsigned char **)a1 != v3)
  {
    uint64_t v39 = a1 + 904;
    uint64_t v40 = a1 + 944;
    uint64_t v41 = a1 + 296;
    while (1)
    {
      if (*v2 != 87) {
        return 0;
      }
      *(void *)a1 = v2 + 1;
      if (v2 + 1 == v3 || v2[1] != 80)
      {
        unsigned int v6 = 0;
      }
      else
      {
        *(void *)a1 = v2 + 2;
        unsigned int v6 = 1;
      }
      uint64_t v7 = sub_1CD081610(a1);
      if (!v7) {
        return 1;
      }
      uint64_t v9 = v7;
      int v10 = *(unsigned __int8 *)(a1 + 937);
      uint64_t v42 = (char *)&v43 + 8;
      unint64_t v11 = HIDWORD(*a2);
      LODWORD(v44) = *a2;
      HIDWORD(v44) = v11;
      uint64_t v45 = v7;
      uint64_t v46 = v6;
      long long v43 = xmmword_1CFB2EDE0;
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
      {
        uint64_t v7 = __cxa_guard_acquire(&qword_1EBCBE588);
        if (v7)
        {
          unint64_t v37 = llvm::hashing::detail::fixed_seed_override;
          if (!llvm::hashing::detail::fixed_seed_override) {
            unint64_t v37 = 0xFF51AFD7ED558CCDLL;
          }
          qword_1EBCBE580 = v37;
          __cxa_guard_release(&qword_1EBCBE588);
        }
      }
      uint64_t v12 = __ROR8__((0x9AE16A3B2F90404FLL * v46) ^ qword_1EBCBE580, 30);
      uint64_t v13 = __ROR8__(0xB492B66FBE98F273 * *((void *)&v43 + 1) - v44, 43) - 0x3C5A37A36834CED9 * v45;
      unint64_t v14 = qword_1EBCBE580
          + __ROR8__(v44 ^ 0xC949D7C7509E6557, 20)
          - 0x4B6D499041670D8DLL * *((void *)&v43 + 1)
          - 0x9AE16A3B2F90404FLL * v46
          + 32;
      unint64_t v15 = 0x9DDFEA08EB382D69
          * (v14 ^ ((0x9DDFEA08EB382D69 * ((v13 + v12) ^ v14)) >> 47) ^ (0x9DDFEA08EB382D69 * ((v13 + v12) ^ v14)));
      unint64_t v16 = *(void *)(a1 + 904)
          + 8 * ((-348639895 * ((v15 >> 47) ^ v15)) & (*(_DWORD *)(a1 + 912) - 1));
      int v17 = *(unsigned int **)v16;
      uint64_t v47 = v49;
      uint64_t v48 = 0x2000000000;
      if (!v17 || (v17 & 1) != 0) {
        break;
      }
      while (1)
      {
        LOBYTE(v7) = sub_1CD071418(v7, v17, (uint64_t)&v42, v8, (unsigned int *)&v47);
        if (v7) {
          break;
        }
        LODWORD(v48) = 0;
        int v17 = *(unsigned int **)v17;
        if (v17) {
          BOOL v19 = (v17 & 1) == 0;
        }
        else {
          BOOL v19 = 0;
        }
        if (!v19)
        {
          int v17 = 0;
          goto LABEL_22;
        }
      }
      unint64_t v16 = 0;
LABEL_22:
      if (v47 == v49)
      {
        if (!v17) {
          break;
        }
      }
      else
      {
        free(v47);
        if (!v17) {
          break;
        }
      }
      int v20 = 0;
      uint64_t v21 = (uint64_t)(v17 + 2);
LABEL_35:
      if (v42 != (char *)&v43 + 8) {
        free(v42);
      }
      if (v20)
      {
        *(void *)(a1 + 920) = v21;
      }
      else if (v21)
      {
        uint64_t v47 = 0;
        int v29 = sub_1CD640748(v40, v21, &v47);
        uint64_t v30 = 0;
        if (v29) {
          uint64_t v30 = *((void *)v47 + 1);
        }
        if (v30) {
          uint64_t v21 = v30;
        }
        if (v21 == *(void *)(a1 + 928)) {
          *(unsigned char *)(a1 + 936) = 1;
        }
      }
      *a2 = v21;
      unint64_t v28 = *(uint64_t **)(a1 + 304);
      if (v28 == *(uint64_t **)(a1 + 312))
      {
        sub_1CD5F0ACC(v41, ((uint64_t)v28 - *(void *)(a1 + 296)) >> 2);
        unint64_t v28 = *(uint64_t **)(a1 + 304);
      }
      *(void *)(a1 + 304) = v28 + 1;
      *unint64_t v28 = v21;
      uint64_t v2 = *(unsigned char **)a1;
      uint64_t v3 = *(unsigned char **)(a1 + 8);
      if (*(unsigned char **)a1 == v3) {
        return 0;
      }
    }
    if (v10)
    {
      *(void *)(a1 + 888) += 48;
      uint64_t v22 = *(void *)(a1 + 808);
      if (((v22 + 7) & 0xFFFFFFFFFFFFFFF8) - v22 + 48 > *(void *)(a1 + 816) - v22)
      {
        unsigned int v31 = *(_DWORD *)(a1 + 832) >> 7;
        if (v31 >= 0x1E) {
          LOBYTE(v31) = 30;
        }
        uint64_t v32 = 4096 << v31;
        unint64_t v23 = (unint64_t)operator new(4096 << v31, (std::align_val_t)8uLL);
        unint64_t v33 = *(unsigned int *)(a1 + 832);
        if (v33 >= *(unsigned int *)(a1 + 836)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 824) + 8 * v33) = v23;
        ++*(_DWORD *)(a1 + 832);
        *(void *)(a1 + 816) = v23 + v32;
      }
      else
      {
        unint64_t v23 = (v22 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(a1 + 808) = v23 + 48;
      *(void *)unint64_t v23 = 0;
      uint64_t v21 = v23 + 8;
      uint64_t v24 = *a2;
      *(unsigned char *)(v23 + 16) = 25;
      *(_WORD *)(v23 + 17) = *(_WORD *)(v23 + 17) & 0xF000 | 0x540;
      *(void *)(v23 + 8) = &unk_1F2619838;
      *(void *)(v23 + 24) = v24;
      *(void *)(v23 + 32) = v9;
      *(unsigned char *)(v23 + 40) = v6;
      unsigned int v25 = *(_DWORD *)(a1 + 916) + 1;
      int v26 = *(_DWORD *)(a1 + 912);
      if (v25 > 2 * v26)
      {
        llvm::FoldingSetBase::GrowBucketCount(v39, 2 * v26, (uint64_t)off_1F2644D00);
        uint64_t v47 = v49;
        uint64_t v48 = 0x2000000000;
        sub_1CD0714B4((unsigned int *)v23, (unsigned int *)&v47);
        unsigned int v34 = sub_1CC13A6B8(v47, (uint64_t)v47 + 4 * v48);
        uint64_t v35 = *(void *)(a1 + 904);
        int v36 = *(_DWORD *)(a1 + 912);
        if (v47 != v49) {
          free(v47);
        }
        unint64_t v16 = v35 + 8 * ((v36 - 1) & v34);
        unsigned int v25 = *(_DWORD *)(a1 + 916) + 1;
      }
      *(_DWORD *)(a1 + 916) = v25;
      uint64_t v27 = *(void *)v16;
      if (!*(void *)v16) {
        uint64_t v27 = v16 | 1;
      }
      *(void *)unint64_t v23 = v27;
      *(void *)unint64_t v16 = v23;
    }
    else
    {
      uint64_t v21 = 0;
    }
    int v20 = 1;
    goto LABEL_35;
  }
  return 0;
}

uint64_t sub_1CD08890C(uint64_t a1, uint64_t *a2, char *a3, int *a4)
{
  uint64_t v7 = a1;
  v43[16] = *MEMORY[0x1E4F143B8];
  int v8 = *(unsigned __int8 *)(a1 + 937);
  int v36 = (char *)&v37 + 8;
  unsigned int v9 = *a3;
  int v10 = *a4;
  unint64_t v11 = HIDWORD(*a2);
  LODWORD(v38) = *a2;
  HIDWORD(v38) = v11;
  uint64_t v39 = v9;
  uint64_t v40 = v10;
  long long v37 = xmmword_1CFB2EDF0;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
  {
    a1 = __cxa_guard_acquire(&qword_1EBCBE588);
    if (a1)
    {
      unint64_t v35 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v35 = 0xFF51AFD7ED558CCDLL;
      }
      qword_1EBCBE580 = v35;
      __cxa_guard_release(&qword_1EBCBE588);
    }
  }
  uint64_t v12 = __ROR8__(0xB492B66FBE98F273 * *((void *)&v37 + 1) - v38, 43)
      - 0x3C5A37A36834CED9 * v39
      + __ROR8__((0x9AE16A3B2F90404FLL * v40) ^ qword_1EBCBE580, 30);
  unint64_t v13 = qword_1EBCBE580
      + __ROR8__(v38 ^ 0xC949D7C7509E6557, 20)
      - 0x4B6D499041670D8DLL * *((void *)&v37 + 1)
      - 0x9AE16A3B2F90404FLL * v40
      + 32;
  unint64_t v14 = 0x9DDFEA08EB382D69
      * (v13 ^ ((0x9DDFEA08EB382D69 * (v12 ^ v13)) >> 47) ^ (0x9DDFEA08EB382D69 * (v12 ^ v13)));
  uint64_t v15 = *(void *)(v7 + 904)
      + 8 * ((-348639895 * ((v14 >> 47) ^ v14)) & (*(_DWORD *)(v7 + 912) - 1));
  unint64_t v16 = *(unsigned int **)v15;
  uint64_t v41 = v43;
  uint64_t v42 = 0x2000000000;
  if (v16) {
    BOOL v17 = (v16 & 1) == 0;
  }
  else {
    BOOL v17 = 0;
  }
  if (!v17) {
    goto LABEL_18;
  }
  while (1)
  {
    LOBYTE(a1) = sub_1CD071418(a1, v16, (uint64_t)&v36, (uint64_t)a4, (unsigned int *)&v41);
    if (a1) {
      break;
    }
    LODWORD(v42) = 0;
    unint64_t v16 = *(unsigned int **)v16;
    if (v16) {
      BOOL v18 = (v16 & 1) == 0;
    }
    else {
      BOOL v18 = 0;
    }
    if (!v18)
    {
      unint64_t v16 = 0;
      goto LABEL_14;
    }
  }
  uint64_t v15 = 0;
LABEL_14:
  if (v41 == v43)
  {
    if (v16)
    {
LABEL_16:
      int v19 = 0;
      uint64_t v20 = (uint64_t)(v16 + 2);
      goto LABEL_27;
    }
  }
  else
  {
    free(v41);
    if (v16) {
      goto LABEL_16;
    }
  }
LABEL_18:
  if (v8)
  {
    *(void *)(v7 + 888) += 40;
    uint64_t v21 = *(void *)(v7 + 808);
    if (((v21 + 7) & 0xFFFFFFFFFFFFFFF8) - v21 + 40 > *(void *)(v7 + 816) - v21)
    {
      unsigned int v32 = *(_DWORD *)(v7 + 832) >> 7;
      if (v32 >= 0x1E) {
        LOBYTE(v32) = 30;
      }
      uint64_t v33 = 4096 << v32;
      unint64_t v22 = (unint64_t)operator new(4096 << v32, (std::align_val_t)8uLL);
      unsigned int v34 = *(_DWORD *)(v7 + 832);
      if (v34 >= *(_DWORD *)(v7 + 836)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(v7 + 824) + 8 * v34) = v22;
      ++*(_DWORD *)(v7 + 832);
      *(void *)(v7 + 816) = v22 + v33;
    }
    else
    {
      unint64_t v22 = (v21 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    *(void *)(v7 + 808) = v22 + 40;
    *(void *)unint64_t v22 = 0;
    uint64_t v20 = v22 + 8;
    uint64_t v23 = *a2;
    char v24 = *a3;
    int v25 = *a4;
    *(unsigned char *)(v22 + 16) = 45;
    *(_WORD *)(v22 + 17) = *(_WORD *)(v22 + 17) & 0xF000 | 0x540;
    *(void *)(v22 + 8) = &unk_1F261A910;
    *(void *)(v22 + 24) = v23;
    *(unsigned char *)(v22 + 32) = v24;
    *(_DWORD *)(v22 + 36) = v25;
    unsigned int v26 = *(_DWORD *)(v7 + 916) + 1;
    int v27 = *(_DWORD *)(v7 + 912);
    if (v26 > 2 * v27)
    {
      llvm::FoldingSetBase::GrowBucketCount(v7 + 904, 2 * v27, (uint64_t)off_1F2644D00);
      uint64_t v41 = v43;
      uint64_t v42 = 0x2000000000;
      sub_1CD0714B4((unsigned int *)v22, (unsigned int *)&v41);
      uint64_t v15 = *(void *)(v7 + 904)
          + 8 * ((*(_DWORD *)(v7 + 912) - 1) & sub_1CC13A6B8(v41, (uint64_t)v41 + 4 * v42));
      if (v41 != v43) {
        free(v41);
      }
      unsigned int v26 = *(_DWORD *)(v7 + 916) + 1;
    }
    *(_DWORD *)(v7 + 916) = v26;
    uint64_t v28 = *(void *)v15;
    if (!*(void *)v15) {
      uint64_t v28 = v15 | 1;
    }
    *(void *)unint64_t v22 = v28;
    *(void *)uint64_t v15 = v22;
  }
  else
  {
    uint64_t v20 = 0;
  }
  int v19 = 1;
LABEL_27:
  if (v36 != (char *)&v37 + 8) {
    free(v36);
  }
  if (v19)
  {
    *(void *)(v7 + 920) = v20;
  }
  else if (v20)
  {
    uint64_t v41 = 0;
    int v30 = sub_1CD640748(v7 + 944, v20, &v41);
    uint64_t v31 = 0;
    if (v30) {
      uint64_t v31 = *((void *)v41 + 1);
    }
    if (v31) {
      uint64_t v20 = v31;
    }
    if (v20 == *(void *)(v7 + 928)) {
      *(unsigned char *)(v7 + 936) = 1;
    }
  }
  return v20;
}

uint64_t sub_1CD088DAC(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v6 = a1;
  v39[16] = *MEMORY[0x1E4F143B8];
  int v7 = *(unsigned __int8 *)(a1 + 937);
  uint64_t v33 = (char *)&v34 + 8;
  uint64_t v8 = *a3;
  unint64_t v9 = HIDWORD(*a2);
  LODWORD(v35) = *a2;
  HIDWORD(v35) = v9;
  uint64_t v36 = v8;
  long long v34 = xmmword_1CFB2EE00;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
  {
    a1 = __cxa_guard_acquire(&qword_1EBCBE588);
    if (a1)
    {
      unint64_t v32 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v32 = 0xFF51AFD7ED558CCDLL;
      }
      qword_1EBCBE580 = v32;
      __cxa_guard_release(&qword_1EBCBE588);
    }
  }
  uint64_t v10 = __ROR8__(0xB492B66FBE98F273 * *((void *)&v34 + 1) - v35, 43)
      - 0x3C5A37A36834CED9 * v35
      + __ROR8__((0x9AE16A3B2F90404FLL * v36) ^ qword_1EBCBE580, 30);
  unint64_t v11 = qword_1EBCBE580
      + __ROR8__(v35 ^ 0xC949D7C7509E6557, 20)
      - 0x4B6D499041670D8DLL * *((void *)&v34 + 1)
      - 0x9AE16A3B2F90404FLL * v36
      + 24;
  unint64_t v12 = 0x9DDFEA08EB382D69
      * (v11 ^ ((0x9DDFEA08EB382D69 * (v10 ^ v11)) >> 47) ^ (0x9DDFEA08EB382D69 * (v10 ^ v11)));
  uint64_t v13 = *(void *)(v6 + 904)
      + 8 * ((-348639895 * ((v12 >> 47) ^ v12)) & (*(_DWORD *)(v6 + 912) - 1));
  unint64_t v14 = *(unsigned int **)v13;
  long long v37 = v39;
  uint64_t v38 = 0x2000000000;
  if (v14) {
    BOOL v15 = (v14 & 1) == 0;
  }
  else {
    BOOL v15 = 0;
  }
  if (!v15) {
    goto LABEL_18;
  }
  while (1)
  {
    LOBYTE(a1) = sub_1CD071418(a1, v14, (uint64_t)&v33, a4, (unsigned int *)&v37);
    if (a1) {
      break;
    }
    LODWORD(v38) = 0;
    unint64_t v14 = *(unsigned int **)v14;
    if (v14) {
      BOOL v16 = (v14 & 1) == 0;
    }
    else {
      BOOL v16 = 0;
    }
    if (!v16)
    {
      unint64_t v14 = 0;
      goto LABEL_14;
    }
  }
  uint64_t v13 = 0;
LABEL_14:
  if (v37 == v39)
  {
    if (v14)
    {
LABEL_16:
      int v17 = 0;
      uint64_t v18 = (uint64_t)(v14 + 2);
      goto LABEL_27;
    }
  }
  else
  {
    free(v37);
    if (v14) {
      goto LABEL_16;
    }
  }
LABEL_18:
  if (v7)
  {
    *(void *)(v6 + 888) += 40;
    uint64_t v19 = *(void *)(v6 + 808);
    if (((v19 + 7) & 0xFFFFFFFFFFFFFFF8) - v19 + 40 > *(void *)(v6 + 816) - v19)
    {
      unsigned int v29 = *(_DWORD *)(v6 + 832) >> 7;
      if (v29 >= 0x1E) {
        LOBYTE(v29) = 30;
      }
      uint64_t v30 = 4096 << v29;
      unint64_t v20 = (unint64_t)operator new(4096 << v29, (std::align_val_t)8uLL);
      unsigned int v31 = *(_DWORD *)(v6 + 832);
      if (v31 >= *(_DWORD *)(v6 + 836)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(v6 + 824) + 8 * v31) = v20;
      ++*(_DWORD *)(v6 + 832);
      *(void *)(v6 + 816) = v20 + v30;
    }
    else
    {
      unint64_t v20 = (v19 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    *(void *)(v6 + 808) = v20 + 40;
    *(void *)unint64_t v20 = 0;
    uint64_t v18 = v20 + 8;
    uint64_t v21 = *a2;
    uint64_t v22 = *a3;
    *(unsigned char *)(v20 + 16) = 24;
    *(_WORD *)(v20 + 17) = *(_WORD *)(v20 + 17) & 0xF000 | 0x540;
    *(void *)(v20 + 8) = &unk_1F261AA18;
    *(void *)(v20 + 24) = v21;
    *(void *)(v20 + 32) = v22;
    unsigned int v23 = *(_DWORD *)(v6 + 916) + 1;
    int v24 = *(_DWORD *)(v6 + 912);
    if (v23 > 2 * v24)
    {
      llvm::FoldingSetBase::GrowBucketCount(v6 + 904, 2 * v24, (uint64_t)off_1F2644D00);
      long long v37 = v39;
      uint64_t v38 = 0x2000000000;
      sub_1CD0714B4((unsigned int *)v20, (unsigned int *)&v37);
      uint64_t v13 = *(void *)(v6 + 904)
          + 8 * ((*(_DWORD *)(v6 + 912) - 1) & sub_1CC13A6B8(v37, (uint64_t)v37 + 4 * v38));
      if (v37 != v39) {
        free(v37);
      }
      unsigned int v23 = *(_DWORD *)(v6 + 916) + 1;
    }
    *(_DWORD *)(v6 + 916) = v23;
    uint64_t v25 = *(void *)v13;
    if (!*(void *)v13) {
      uint64_t v25 = v13 | 1;
    }
    *(void *)unint64_t v20 = v25;
    *(void *)uint64_t v13 = v20;
  }
  else
  {
    uint64_t v18 = 0;
  }
  int v17 = 1;
LABEL_27:
  if (v33 != (char *)&v34 + 8) {
    free(v33);
  }
  if (v17)
  {
    *(void *)(v6 + 920) = v18;
  }
  else if (v18)
  {
    long long v37 = 0;
    int v27 = sub_1CD640748(v6 + 944, v18, &v37);
    uint64_t v28 = 0;
    if (v27) {
      uint64_t v28 = *((void *)v37 + 1);
    }
    if (v28) {
      uint64_t v18 = v28;
    }
    if (v18 == *(void *)(v6 + 928)) {
      *(unsigned char *)(v6 + 936) = 1;
    }
  }
  return v18;
}

uint64_t sub_1CD089234(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t *a5, int *a6, char *a7)
{
  int v7 = a7;
  uint64_t v8 = a6;
  unint64_t v9 = a5;
  uint64_t v10 = (long long *)a4;
  v64[16] = *MEMORY[0x1E4F143B8];
  int v55 = *(unsigned __int8 *)(a1 + 937);
  uint64_t v56 = (char *)&v57 + 8;
  uint64_t v12 = *a3;
  unint64_t v14 = *(uint64_t **)a4;
  uint64_t v13 = *(void *)(a4 + 8);
  uint64_t v15 = *a5;
  int v16 = *a6;
  int v17 = *a7;
  unint64_t v18 = HIDWORD(*a2);
  int v58 = *a2;
  int v59 = v18;
  uint64_t v60 = v12;
  uint64_t v61 = v13;
  long long v57 = xmmword_1CFB2EE10;
  if (v13)
  {
    uint64_t v19 = 8 * v13;
    unsigned int v20 = 8;
    do
    {
      uint64_t v21 = *v14;
      if (v20 >= DWORD1(v57)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)v56 + v20) = v21;
      unsigned int v22 = v57 + 1;
      LODWORD(v57) = v22;
      if (v22 >= DWORD1(v57)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)v56 + v22) = HIDWORD(v21);
      unsigned int v20 = v57 + 1;
      LODWORD(v57) = v57 + 1;
      ++v14;
      v19 -= 8;
    }
    while (v19);
    int v7 = a7;
    uint64_t v8 = a6;
    uint64_t v10 = (long long *)a4;
    unint64_t v9 = a5;
    if (v20 >= DWORD1(v57)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
  }
  else
  {
    unsigned int v20 = 8;
  }
  *((_DWORD *)v56 + v20) = v15;
  unsigned int v23 = v57 + 1;
  LODWORD(v57) = v23;
  if (v23 >= DWORD1(v57)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((_DWORD *)v56 + v23) = HIDWORD(v15);
  unsigned int v24 = v57 + 1;
  LODWORD(v57) = v24;
  if (v24 >= DWORD1(v57)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((_DWORD *)v56 + v24) = v16;
  unsigned int v25 = v57 + 1;
  LODWORD(v57) = v25;
  if (v25 >= DWORD1(v57)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((_DWORD *)v56 + v25) = 0;
  unsigned int v26 = v57 + 1;
  LODWORD(v57) = v26;
  if (v26 >= DWORD1(v57)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((_DWORD *)v56 + v26) = v17;
  unsigned int v27 = v57 + 1;
  LODWORD(v57) = v27;
  if (v27 >= DWORD1(v57)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((_DWORD *)v56 + v27) = 0;
  LODWORD(v57) = v57 + 1;
  unint64_t v28 = sub_1CC13A6B8(v56, (uint64_t)v56 + 4 * v57);
  uint64_t v30 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v28);
  unsigned int v31 = *(unsigned int **)v30;
  uint64_t v62 = v64;
  uint64_t v63 = 0x2000000000;
  if (v31 && (v31 & 1) == 0)
  {
    while (1)
    {
      LOBYTE(v28) = sub_1CD071418(v28, v31, (uint64_t)&v56, v29, (unsigned int *)&v62);
      if (v28) {
        break;
      }
      LODWORD(v63) = 0;
      unsigned int v31 = *(unsigned int **)v31;
      if (v31) {
        BOOL v32 = (v31 & 1) == 0;
      }
      else {
        BOOL v32 = 0;
      }
      if (!v32)
      {
        unsigned int v31 = 0;
        goto LABEL_26;
      }
    }
    uint64_t v30 = 0;
LABEL_26:
    if (v62 == v64)
    {
      if (v31)
      {
LABEL_28:
        int v33 = 0;
        uint64_t v34 = (uint64_t)(v31 + 2);
        goto LABEL_39;
      }
    }
    else
    {
      free(v62);
      if (v31) {
        goto LABEL_28;
      }
    }
  }
  if (v55)
  {
    *(void *)(a1 + 888) += 72;
    uint64_t v35 = *(void *)(a1 + 808);
    if (((v35 + 7) & 0xFFFFFFFFFFFFFFF8) - v35 + 72 > *(void *)(a1 + 816) - v35)
    {
      unsigned int v50 = *(_DWORD *)(a1 + 832) >> 7;
      if (v50 >= 0x1E) {
        LOBYTE(v50) = 30;
      }
      uint64_t v51 = 4096 << v50;
      unint64_t v36 = (unint64_t)operator new(4096 << v50, (std::align_val_t)8uLL);
      unsigned int v52 = *(_DWORD *)(a1 + 832);
      if (v52 >= *(_DWORD *)(a1 + 836)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(a1 + 824) + 8 * v52) = v36;
      ++*(_DWORD *)(a1 + 832);
      *(void *)(a1 + 816) = v36 + v51;
    }
    else
    {
      unint64_t v36 = (v35 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    *(void *)(a1 + 808) = v36 + 72;
    *(void *)unint64_t v36 = 0;
    uint64_t v34 = v36 + 8;
    uint64_t v37 = *a2;
    uint64_t v38 = *a3;
    uint64_t v39 = *v9;
    int v40 = *v8;
    char v41 = *v7;
    *(unsigned char *)(v36 + 16) = 18;
    __int16 v42 = *(_WORD *)(v36 + 17) & 0xF000 | 0x100;
    *(void *)(v36 + 8) = &unk_1F261AC28;
    long long v43 = *v10;
    *(_WORD *)(v36 + 17) = v42;
    *(void *)(v36 + 24) = v37;
    *(void *)(v36 + 32) = v38;
    *(_OWORD *)(v36 + 40) = v43;
    *(void *)(v36 + 56) = v39;
    *(_DWORD *)(v36 + 64) = v40;
    *(unsigned char *)(v36 + 68) = v41;
    unsigned int v44 = *(_DWORD *)(a1 + 916) + 1;
    int v45 = *(_DWORD *)(a1 + 912);
    if (v44 > 2 * v45)
    {
      llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v45, (uint64_t)off_1F2644D00);
      uint64_t v62 = v64;
      uint64_t v63 = 0x2000000000;
      sub_1CD0714B4((unsigned int *)v36, (unsigned int *)&v62);
      uint64_t v30 = *(void *)(a1 + 904)
          + 8 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v62, (uint64_t)v62 + 4 * v63));
      if (v62 != v64) {
        free(v62);
      }
      unsigned int v44 = *(_DWORD *)(a1 + 916) + 1;
    }
    *(_DWORD *)(a1 + 916) = v44;
    uint64_t v46 = *(void *)v30;
    if (!*(void *)v30) {
      uint64_t v46 = v30 | 1;
    }
    *(void *)unint64_t v36 = v46;
    *(void *)uint64_t v30 = v36;
  }
  else
  {
    uint64_t v34 = 0;
  }
  int v33 = 1;
LABEL_39:
  if (v56 != (char *)&v57 + 8) {
    free(v56);
  }
  if (v33)
  {
    *(void *)(a1 + 920) = v34;
  }
  else if (v34)
  {
    uint64_t v62 = 0;
    int v48 = sub_1CD640748(a1 + 944, v34, &v62);
    uint64_t v49 = 0;
    if (v48) {
      uint64_t v49 = *((void *)v62 + 1);
    }
    if (v49) {
      uint64_t v34 = v49;
    }
    if (v34 == *(void *)(a1 + 928)) {
      *(unsigned char *)(a1 + 936) = 1;
    }
  }
  return v34;
}

uint64_t sub_1CD08985C(uint64_t a1, char *__s, uint64_t *a3)
{
  v35[16] = *MEMORY[0x1E4F143B8];
  int v6 = *(unsigned __int8 *)(a1 + 937);
  unsigned int v31 = &v32[2];
  uint64_t v7 = *a3;
  *(_OWORD *)BOOL v32 = xmmword_1CFB2EAE0;
  unsigned int v8 = strlen(__s);
  llvm::FoldingSetNodeID::AddString((unsigned int *)&v31, (unsigned __int8 *)__s, v8);
  if (v32[0] >= v32[1]) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((_DWORD *)v31 + v32[0]) = v7;
  unsigned int v9 = v32[0] + 1;
  v32[0] = v9;
  if (v9 >= v32[1]) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((_DWORD *)v31 + v9) = HIDWORD(v7);
  ++v32[0];
  unint64_t v10 = sub_1CC13A6B8(v31, (uint64_t)v31 + 4 * v32[0]);
  uint64_t v12 = *(void *)(a1 + 904) + 8 * ((*(_DWORD *)(a1 + 912) - 1) & v10);
  uint64_t v13 = *(unsigned int **)v12;
  int v33 = v35;
  uint64_t v34 = 0x2000000000;
  if (v13) {
    BOOL v14 = (v13 & 1) == 0;
  }
  else {
    BOOL v14 = 0;
  }
  if (!v14) {
    goto LABEL_19;
  }
  while (1)
  {
    LOBYTE(v10) = sub_1CD071418(v10, v13, (uint64_t)&v31, v11, (unsigned int *)&v33);
    if (v10) {
      break;
    }
    LODWORD(v34) = 0;
    uint64_t v13 = *(unsigned int **)v13;
    if (v13) {
      BOOL v15 = (v13 & 1) == 0;
    }
    else {
      BOOL v15 = 0;
    }
    if (!v15)
    {
      uint64_t v13 = 0;
      goto LABEL_15;
    }
  }
  uint64_t v12 = 0;
LABEL_15:
  if (v33 == v35)
  {
    if (v13)
    {
LABEL_17:
      int v16 = 0;
      uint64_t v17 = (uint64_t)(v13 + 2);
      goto LABEL_28;
    }
  }
  else
  {
    free(v33);
    if (v13) {
      goto LABEL_17;
    }
  }
LABEL_19:
  if (v6)
  {
    *(void *)(a1 + 888) += 48;
    uint64_t v18 = *(void *)(a1 + 808);
    if (((v18 + 7) & 0xFFFFFFFFFFFFFFF8) - v18 + 48 > *(void *)(a1 + 816) - v18)
    {
      unsigned int v28 = *(_DWORD *)(a1 + 832) >> 7;
      if (v28 >= 0x1E) {
        LOBYTE(v28) = 30;
      }
      uint64_t v29 = 4096 << v28;
      unint64_t v19 = (unint64_t)operator new(4096 << v28, (std::align_val_t)8uLL);
      unsigned int v30 = *(_DWORD *)(a1 + 832);
      if (v30 >= *(_DWORD *)(a1 + 836)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(a1 + 824) + 8 * v30) = v19;
      ++*(_DWORD *)(a1 + 832);
      *(void *)(a1 + 816) = v19 + v29;
    }
    else
    {
      unint64_t v19 = (v18 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    *(void *)(a1 + 808) = v19 + 48;
    *(void *)unint64_t v19 = 0;
    uint64_t v17 = v19 + 8;
    size_t v20 = strlen(__s);
    uint64_t v21 = *a3;
    *(unsigned char *)(v19 + 16) = 20;
    *(_WORD *)(v19 + 17) = *(_WORD *)(v19 + 17) & 0xF000 | 0x540;
    *(void *)(v19 + 8) = &unk_1F2619730;
    *(void *)(v19 + 24) = __s;
    *(void *)(v19 + 32) = &__s[v20];
    *(void *)(v19 + 40) = v21;
    unsigned int v22 = *(_DWORD *)(a1 + 916) + 1;
    int v23 = *(_DWORD *)(a1 + 912);
    if (v22 > 2 * v23)
    {
      llvm::FoldingSetBase::GrowBucketCount(a1 + 904, 2 * v23, (uint64_t)off_1F2644D00);
      int v33 = v35;
      uint64_t v34 = 0x2000000000;
      sub_1CD0714B4((unsigned int *)v19, (unsigned int *)&v33);
      uint64_t v12 = *(void *)(a1 + 904)
          + 8 * ((*(_DWORD *)(a1 + 912) - 1) & sub_1CC13A6B8(v33, (uint64_t)v33 + 4 * v34));
      if (v33 != v35) {
        free(v33);
      }
      unsigned int v22 = *(_DWORD *)(a1 + 916) + 1;
    }
    *(_DWORD *)(a1 + 916) = v22;
    uint64_t v24 = *(void *)v12;
    if (!*(void *)v12) {
      uint64_t v24 = v12 | 1;
    }
    *(void *)unint64_t v19 = v24;
    *(void *)uint64_t v12 = v19;
  }
  else
  {
    uint64_t v17 = 0;
  }
  int v16 = 1;
LABEL_28:
  if (v31 != &v32[2]) {
    free(v31);
  }
  if (v16)
  {
    *(void *)(a1 + 920) = v17;
  }
  else if (v17)
  {
    int v33 = 0;
    int v26 = sub_1CD640748(a1 + 944, v17, &v33);
    uint64_t v27 = 0;
    if (v26) {
      uint64_t v27 = *((void *)v33 + 1);
    }
    if (v27) {
      uint64_t v17 = v27;
    }
    if (v17 == *(void *)(a1 + 928)) {
      *(unsigned char *)(a1 + 936) = 1;
    }
  }
  return v17;
}

uint64_t llvm::json::Object::operator[](uint64_t a1, uint64_t a2)
{
  sub_1CD451CA8(a1, a2, (uint64_t)v3);
  return v3[0] + 24;
}

{
  void v3[3];

  sub_1CD83C238((uint64_t)v3, a1, a2);
  return v3[0] + 24;
}

uint64_t llvm::json::Object::get(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = sub_1CD83B044(a1, a2, a3);
  if (*(void *)a1 + 56 * *(unsigned int *)(a1 + 16) == v4) {
    return 0;
  }
  else {
    return v4 + 24;
  }
}

{
  uint64_t v4;

  uint64_t v4 = sub_1CD83B09C(a1, a2, a3);
  if (*(void *)a1 + 56 * *(unsigned int *)(a1 + 16) == v4) {
    return 0;
  }
  else {
    return v4 + 24;
  }
}

uint64_t llvm::json::Object::getNull(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return 0;
}

uint64_t llvm::json::Object::getBoolean(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = sub_1CD83B09C(a1, a2, a3);
  if (*(void *)a1 + 56 * *(unsigned int *)(a1 + 16) == v4 || *(_WORD *)(v4 + 24) != 1)
  {
    int v5 = 0;
    int v6 = 0;
  }
  else
  {
    int v5 = *(unsigned __int8 *)(v4 + 32);
    int v6 = 1;
  }
  return v5 | (v6 << 8);
}

uint64_t llvm::json::Object::getNumber(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = sub_1CD83B09C(a1, a2, a3);
  if (*(void *)a1 + 56 * *(unsigned int *)(a1 + 16) == v4) {
    return 0;
  }
  int v5 = *(unsigned __int16 *)(v4 + 24);
  switch(v5)
  {
    case 2:
      double v6 = *(double *)(v4 + 32);
      break;
    case 3:
      double v6 = (double)*(uint64_t *)(v4 + 32);
      break;
    case 4:
      double v6 = (double)*(unint64_t *)(v4 + 32);
      break;
    default:
      double v6 = 0.0;
      break;
  }
  return *(void *)&v6;
}

uint64_t llvm::json::Object::getString@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t result = sub_1CD83B09C(a1, a2, a3);
  if (*(void *)a1 + 56 * *(unsigned int *)(a1 + 16) == result) {
    goto LABEL_11;
  }
  int v7 = *(unsigned __int16 *)(result + 24);
  if (v7 == 6)
  {
    uint64_t v9 = *(void *)(result + 32);
    result += 32;
    uint64_t v8 = v9;
    char v10 = *(unsigned char *)(result + 23);
    int v11 = v10;
    if (v10 >= 0) {
      uint64_t v8 = result;
    }
    uint64_t v12 = v10 & 0x7F;
    if (v11 < 0) {
      uint64_t v12 = *(void *)(result + 8);
    }
    *(void *)a4 = v8;
    *(void *)(a4 + 8) = v12;
    goto LABEL_10;
  }
  if (v7 != 5)
  {
LABEL_11:
    char v13 = 0;
    *(unsigned char *)a4 = 0;
    goto LABEL_12;
  }
  *(_OWORD *)a4 = *(_OWORD *)(result + 32);
LABEL_10:
  char v13 = 1;
LABEL_12:
  *(unsigned char *)(a4 + 16) = v13;
  return result;
}

uint64_t llvm::json::Object::getArray(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = sub_1CD83B09C(a1, a2, a3);
  if (*(void *)a1 + 56 * *(unsigned int *)(a1 + 16) == v4) {
    return 0;
  }
  if (*(_WORD *)(v4 + 24) == 8) {
    return v4 + 32;
  }
  return 0;
}

{
  uint64_t v4;

  uint64_t v4 = sub_1CD83B044(a1, a2, a3);
  if (*(void *)a1 + 56 * *(unsigned int *)(a1 + 16) == v4) {
    return 0;
  }
  if (*(_WORD *)(v4 + 24) == 8) {
    return v4 + 32;
  }
  return 0;
}

uint64_t llvm::json::operator==(uint64_t *a1, uint64_t a2)
{
  int v2 = *((_DWORD *)a1 + 2);
  if (v2 != *(_DWORD *)(a2 + 8)) {
    return 0;
  }
  if (v2)
  {
    uint64_t v4 = *((unsigned int *)a1 + 4);
    if (v4)
    {
      uint64_t v5 = 56 * v4;
      for (uint64_t i = *a1; *(void *)(i + 8) >= 0xFFFFFFFFFFFFFFFELL; i += 56)
      {
        v5 -= 56;
        if (!v5) {
          return 1;
        }
      }
    }
    else
    {
      uint64_t i = *a1;
    }
    uint64_t v7 = *a1 + 56 * v4;
    if (i != v7)
    {
      unint64_t v8 = *(void *)(i + 8);
LABEL_11:
      uint64_t v9 = sub_1CD83B09C(a2, v8, *(void *)(i + 16));
      if (*(void *)a2 + 56 * *(unsigned int *)(a2 + 16) != v9)
      {
        uint64_t result = llvm::json::operator==((unsigned __int16 *)(i + 24), (__int16 *)(v9 + 24));
        if (!result) {
          return result;
        }
        while (1)
        {
          i += 56;
          if (i == v7) {
            return 1;
          }
          unint64_t v8 = *(void *)(i + 8);
          if (v8 < 0xFFFFFFFFFFFFFFFELL)
          {
            uint64_t result = 1;
            if (i != v7) {
              goto LABEL_11;
            }
            return result;
          }
        }
      }
      return 0;
    }
  }
  return 1;
}

uint64_t llvm::json::Value::Value(uint64_t a1, unsigned __int16 *a2, unint64_t a3)
{
  llvm::json::Array::Array((uint64_t)&v5, a2, a3);
  *(_WORD *)a1 = 8;
  *(_OWORD *)(a1 + 8) = v5;
  *(void *)(a1 + 24) = v6;
  long long v5 = 0uLL;
  uint64_t v6 = 0;
  uint64_t v7 = (void **)&v5;
  sub_1CBF2C7E0(&v7);
  return a1;
}

{
  long long v5;
  uint64_t v6;
  void **v7;

  llvm::json::Array::Array((uint64_t)&v5, a2, a3);
  *(_WORD *)a1 = 8;
  *(_OWORD *)(a1 + 8) = v5;
  *(void *)(a1 + 24) = v6;
  long long v5 = 0uLL;
  uint64_t v6 = 0;
  uint64_t v7 = (void **)&v5;
  sub_1CBF2C7E0(&v7);
  return a1;
}

uint64_t llvm::json::operator==(unsigned __int16 *a1, __int16 *a2)
{
  if (dword_1CFB2EE30[(__int16)*a1] != dword_1CFB2EE30[*a2]) {
    return 0;
  }
  int v2 = a1;
  uint64_t v3 = *a1;
  int v4 = (unsigned __int16)*a2;
  uint64_t result = 1;
  switch(v3)
  {
    case 1:
      int v27 = *((unsigned __int8 *)v2 + 8);
      unsigned __int8 v28 = *((unsigned char *)a2 + 8);
      if (v4 != 1) {
        unsigned __int8 v28 = 0;
      }
      BOOL v10 = v27 == v28;
      goto LABEL_47;
    case 2:
    case 3:
    case 4:
      if (v3 != 3 && v4 != 3)
      {
        if (v3 == 2)
        {
          double v8 = *((double *)v2 + 1);
        }
        else if (v3 == 4)
        {
          double v8 = (double)*((unint64_t *)v2 + 1);
        }
        else
        {
          double v8 = 0.0;
        }
        if (v4 == 2)
        {
          double v9 = *((double *)a2 + 1);
        }
        else if (v4 == 4)
        {
          double v9 = (double)*((unint64_t *)a2 + 1);
        }
        else
        {
          double v9 = 0.0;
        }
        BOOL v10 = v8 == v9;
        goto LABEL_47;
      }
      unint64_t v29 = sub_1CD82C174(v2);
      char v31 = v30;
      unint64_t v32 = sub_1CD82C174((unsigned __int16 *)a2);
      if (v31 && v33)
      {
        BOOL v10 = v29 == v32;
        goto LABEL_47;
      }
      uint64_t result = (v31 == 0) ^ (v33 != 0);
      break;
    case 5:
      uint64_t v12 = (__int16 *)*((void *)v2 + 1);
      size_t v13 = *((void *)v2 + 2);
      goto LABEL_25;
    case 6:
      int v16 = (__int16 *)*((void *)v2 + 1);
      BOOL v14 = (__int16 *)(v2 + 4);
      BOOL v15 = v16;
      char v17 = *((unsigned char *)v14 + 23);
      if (v17 >= 0) {
        uint64_t v12 = v14;
      }
      else {
        uint64_t v12 = v15;
      }
      int v2 = (unsigned __int16 *)*((void *)v14 + 1);
      if (v17 >= 0) {
        size_t v13 = v17 & 0x7F;
      }
      else {
        size_t v13 = (size_t)v2;
      }
LABEL_25:
      if (v4 == 6)
      {
        uint64_t v18 = a2 + 4;
        char v19 = *((unsigned char *)a2 + 31);
        int v20 = v19;
        if (v19 >= 0) {
          uint64_t v21 = a2 + 4;
        }
        else {
          uint64_t v21 = (const void *)*((void *)a2 + 1);
        }
        int v2 = (unsigned __int16 *)*((void *)v18 + 1);
        unsigned int v22 = (unsigned __int16 *)(v19 & 0x7F);
        if (v20 >= 0) {
          int v2 = v22;
        }
      }
      else if (v4 == 5)
      {
        uint64_t v21 = (const void *)*((void *)a2 + 1);
        int v2 = (unsigned __int16 *)*((void *)a2 + 2);
      }
      else
      {
        uint64_t v21 = 0;
      }
      if ((unsigned __int16 *)v13 != v2) {
        return 0;
      }
      if (v13)
      {
        BOOL v10 = memcmp(v12, v21, v13) == 0;
LABEL_47:
        uint64_t result = v10;
      }
      else
      {
        uint64_t result = 1;
      }
      break;
    case 7:
      if (v4 == 7) {
        int v11 = a2 + 4;
      }
      else {
        int v11 = 0;
      }
      return llvm::json::operator==(v2 + 4, v11);
    case 8:
      int v23 = (uint64_t *)(a2 + 4);
      if (v4 != 8) {
        int v23 = 0;
      }
      uint64_t v24 = *((void *)v2 + 1);
      uint64_t v25 = *((void *)v2 + 2);
      uint64_t v26 = *v23;
      if (v25 - v24 != v23[1] - *v23) {
        return 0;
      }
      while (v24 != v25)
      {
        uint64_t result = llvm::json::operator==(v24, v26);
        if (!result) {
          break;
        }
        v24 += 32;
        v26 += 32;
      }
      return result;
    default:
      return result;
  }
  return result;
}

__n128 llvm::json::Path::report(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a1;
  LODWORD(v4) = -1;
  long long v5 = a1;
  do
  {
    uint64_t v6 = v5;
    long long v5 = (void *)*v5;
    unint64_t v4 = (v4 + 1);
  }
  while (v5);
  uint64_t v7 = v6[1];
  *(void *)(v7 + 16) = a2;
  *(void *)(v7 + 24) = a3;
  double v9 = *(__n128 **)(v7 + 32);
  double v8 = *(__n128 **)(v7 + 40);
  unint64_t v10 = v8 - v9;
  if (v4 <= v10)
  {
    if (v4 < v10) {
      *(void *)(v7 + 40) = &v9[v4];
    }
  }
  else
  {
    unint64_t v11 = v4 - v10;
    uint64_t v12 = *(void *)(v7 + 48);
    if (v4 - v10 <= (v12 - (uint64_t)v8) >> 4)
    {
      bzero(*(void **)(v7 + 40), 16 * v11);
      *(void *)(v7 + 40) = &v8[v11];
    }
    else
    {
      uint64_t v13 = v12 - (void)v9;
      if (v13 >> 3 > v4) {
        unint64_t v4 = v13 >> 3;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v14 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v4;
      }
      if (v14 >> 60) {
        sub_1CB833614();
      }
      BOOL v15 = (char *)operator new(16 * v14);
      int v16 = (__n128 *)&v15[16 * v10];
      char v17 = &v15[16 * v14];
      bzero(v16, 16 * v11);
      char v19 = &v15[16 * v11 + (char *)v8 - (char *)v9];
      if (v8 != v9)
      {
        do
        {
          __n128 result = v8[-1];
          v16[-1] = result;
          --v16;
          --v8;
        }
        while (v8 != v9);
        double v8 = *(__n128 **)(v7 + 32);
      }
      *(void *)(v7 + 32) = v16;
      *(void *)(v7 + 40) = v19;
      *(void *)(v7 + 48) = v17;
      if (v8) {
        operator delete(v8);
      }
    }
    double v9 = *(__n128 **)(v7 + 32);
  }
  while (*v3)
  {
    __n128 result = *(__n128 *)(v3 + 1);
    *v9++ = result;
    uint64_t v3 = (void *)*v3;
  }
  return result;
}

void llvm::json::Path::Root::getError(llvm::json::Path::Root *this)
{
  memset(v32, 0, sizeof(v32));
  int v24 = 0;
  char v28 = 0;
  uint64_t v29 = 0;
  char v31 = v32;
  int v30 = 0;
  int v23 = &unk_1F2646F30;
  uint64_t v25 = 0;
  unint64_t v26 = 0;
  long long __dst = 0;
  size_t v2 = *((void *)this + 3);
  if (v2)
  {
    uint64_t v3 = (const char *)*((void *)this + 2);
  }
  else
  {
    uint64_t v3 = "invalid JSON contents";
    size_t v2 = 21;
  }
  unint64_t v4 = (char *)llvm::raw_ostream::write((llvm::raw_ostream *)&v23, v3, v2);
  if (*((void *)this + 4) == *((void *)this + 5))
  {
    if (*((void *)this + 1))
    {
      long long v5 = (char *)__dst;
      if (v26 - (unint64_t)__dst > 0xD)
      {
        *(void *)long long __dst = *(void *)" when parsing ";
        *(void *)(v5 + 6) = *(void *)"parsing ";
        unint64_t v4 = (char *)__dst + 14;
        long long __dst = (char *)__dst + 14;
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v23, " when parsing ", 0xEuLL);
        unint64_t v4 = (char *)__dst;
      }
      uint64_t v6 = *(const void **)this;
      size_t v7 = *((void *)this + 1);
      if (v7 <= v26 - (unint64_t)v4)
      {
        if (v7)
        {
          unint64_t v4 = (char *)memcpy(v4, v6, v7);
          long long __dst = (char *)__dst + v7;
        }
      }
      else
      {
        unint64_t v4 = (char *)llvm::raw_ostream::write((llvm::raw_ostream *)&v23, (const char *)v6, v7);
      }
    }
    goto LABEL_34;
  }
  if (v26 - (unint64_t)__dst > 3)
  {
    *(_DWORD *)long long __dst = 544497952;
    long long __dst = (char *)__dst + 4;
  }
  else
  {
    llvm::raw_ostream::write((llvm::raw_ostream *)&v23, " at ", 4uLL);
  }
  size_t v8 = *((void *)this + 1);
  if (v8)
  {
    unint64_t v10 = *(const char **)this;
    double v9 = __dst;
    if (v8 <= v26 - (unint64_t)__dst) {
      goto LABEL_14;
    }
  }
  else
  {
    double v9 = __dst;
    unint64_t v10 = "(root)";
    size_t v8 = 6;
    if (v26 - (unint64_t)__dst > 5)
    {
LABEL_14:
      unint64_t v4 = (char *)memcpy(v9, v10, v8);
      long long __dst = (char *)__dst + v8;
      goto LABEL_17;
    }
  }
  unint64_t v4 = (char *)llvm::raw_ostream::write((llvm::raw_ostream *)&v23, v10, v8);
LABEL_17:
  uint64_t v11 = *((void *)this + 4);
  uint64_t v12 = *((void *)this + 5);
  if (v12 != v11)
  {
    uint64_t v13 = *((void *)this + 5);
    do
    {
      uint64_t v14 = *(void *)(v13 - 16);
      v13 -= 16;
      BOOL v15 = __dst;
      if (v14)
      {
        if ((unint64_t)__dst >= v26)
        {
          llvm::raw_ostream::write((llvm::raw_ostream *)&v23, 46);
        }
        else
        {
          long long __dst = (char *)__dst + 1;
          *BOOL v15 = 46;
        }
        int v16 = *(const void **)(v12 - 16);
        unint64_t v17 = *(unsigned int *)(v12 - 8);
        unint64_t v4 = (char *)__dst;
        if (v26 - (unint64_t)__dst >= v17)
        {
          if (v17)
          {
            unint64_t v4 = (char *)memcpy(__dst, v16, *(unsigned int *)(v12 - 8));
            long long __dst = (char *)__dst + v17;
          }
        }
        else
        {
          unint64_t v4 = (char *)llvm::raw_ostream::write((llvm::raw_ostream *)&v23, (const char *)v16, *(unsigned int *)(v12 - 8));
        }
      }
      else
      {
        if ((unint64_t)__dst >= v26)
        {
          llvm::raw_ostream::write((llvm::raw_ostream *)&v23, 91);
        }
        else
        {
          long long __dst = (char *)__dst + 1;
          *BOOL v15 = 91;
        }
        unint64_t v4 = (char *)sub_1CD098D14((llvm::raw_ostream *)&v23, *(unsigned int *)(v12 - 8), 0, 0, 0);
        uint64_t v18 = __dst;
        if ((unint64_t)__dst >= v26)
        {
          unint64_t v4 = (char *)llvm::raw_ostream::write((llvm::raw_ostream *)&v23, 93);
        }
        else
        {
          long long __dst = (char *)__dst + 1;
          *uint64_t v18 = 93;
        }
      }
      uint64_t v12 = v13;
    }
    while (v13 != v11);
  }
LABEL_34:
  uint64_t v19 = llvm::inconvertibleErrorCode((llvm *)v4);
  __int16 v22 = 260;
  uint64_t v21 = v31;
  sub_1CD4FF4BC(v19, v20, (llvm::Twine *)&v21);
}

void llvm::json::Path::Root::printErrorContext(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v3[1] = (uint64_t)v4;
  v4[0] = v5;
  v5[17] = 0;
  v5[18] = a3;
  v5[19] = 2;
  char v6 = 0;
  v5[16] = 0;
  v5[0] = 0;
  v4[1] = (void *)0x1000000001;
  v3[0] = a1;
  sub_1CD08A8C8(v3, a2, *(void *)(a1 + 32), (uint64_t)(*(void *)(a1 + 40) - *(void *)(a1 + 32)) >> 4, (uint64_t)v3);
  if (v4[0] != v5) {
    free(v4[0]);
  }
}

void sub_1CD08A8C8(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  long long v5 = (llvm::json::OStream *)a1[1];
  v25[0] = *a1;
  v25[1] = (uint64_t)v5;
  v25[2] = a2;
  if (!a4) {
    goto LABEL_20;
  }
  uint64_t v9 = a4 - 1;
  unint64_t v10 = *(const void **)(a3 + 16 * (a4 - 1));
  if (v10)
  {
    uint64_t v11 = (uint64_t *)(a2 + 8);
    if (*(_WORD *)a2 == 7)
    {
      size_t v13 = *(unsigned int *)(a3 + 16 * v9 + 8);
      if (*(void *)(a2 + 8) + 56 * *(unsigned int *)(a2 + 24) != sub_1CD83B09C(a2 + 8, (uint64_t)v10, v13))
      {
        uint64_t v14 = (llvm::json::OStream *)a1[1];
        llvm::json::OStream::objectBegin(v14);
        sub_1CD08C1D4((uint64_t *)&v26, v11);
        BOOL v15 = v26;
        int v16 = v27;
        if (v26 != v27)
        {
          uint64_t v17 = (uint64_t)v26;
          do
          {
            uint64_t v18 = *(void *)v17;
            llvm::json::OStream::attributeBegin((uint64_t)v14, *(char **)(*(void *)v17 + 8), *(void *)(*(void *)v17 + 16));
            if (*(void *)(v18 + 16) == v13 && (!v13 || !memcmp(v10, *(const void **)(v18 + 8), v13))) {
              sub_1CD08A8C8(a5, v18 + 24, a3, v9, a5);
            }
            else {
              sub_1CD08BF4C(v18 + 24, (llvm::raw_ostream **)v14);
            }
            --*((_DWORD *)v14 + 2);
            v17 += 8;
          }
          while ((void *)v17 != v16);
        }
        if (v15) {
          operator delete(v15);
        }
        llvm::json::OStream::objectEnd(v14);
        return;
      }
    }
LABEL_20:
    sub_1CD08BDD8(v25);
    return;
  }
  if (*(_WORD *)a2 != 8) {
    goto LABEL_20;
  }
  uint64_t v19 = a3 + 16 * v9;
  unsigned int v21 = *(_DWORD *)(v19 + 8);
  uint64_t v20 = (_DWORD *)(v19 + 8);
  if (v21 >= (unint64_t)((uint64_t)(*(void *)(a2 + 16) - *(void *)(a2 + 8)) >> 5)) {
    goto LABEL_20;
  }
  llvm::json::OStream::arrayBegin(v5);
  uint64_t v22 = *(void *)(a2 + 8);
  uint64_t v23 = *(void *)(a2 + 16);
  if (v22 != v23)
  {
    int v24 = 0;
    do
    {
      if (v24 == *v20) {
        sub_1CD08A8C8(a5, v22, a3, v9, a5);
      }
      else {
        sub_1CD08BF4C(v22, (llvm::raw_ostream **)v5);
      }
      v22 += 32;
      ++v24;
    }
    while (v22 != v23);
  }

  llvm::json::OStream::arrayEnd(v5);
}

void llvm::json::parse(unsigned __int8 *a1@<X0>, uint64_t a2@<X1>, const unsigned __int8 *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  LOBYTE(v12) = 0;
  char v13 = 0;
  uint64_t v14 = a1;
  BOOL v15 = a1;
  int v16 = &a1[a2];
  v18[0] = 0;
  if (a2)
  {
    uint64_t v5 = 0;
    while (((char)a1[v5] & 0x80000000) == 0)
    {
      if (a2 == ++v5) {
        goto LABEL_7;
      }
    }
    uint64_t v17 = a1;
    if (!llvm::isLegalUTF8String(&v17, (const unsigned __int8 **)&a1[a2], a3))
    {
      BOOL v15 = v17;
      goto LABEL_15;
    }
  }
LABEL_7:
  if (sub_1CD08AC98((uint64_t)&v12, (llvm::json::Value *)v18))
  {
    char v6 = v15;
    if (v15 != v16)
    {
      while (1)
      {
        unsigned int v7 = *v6;
        BOOL v8 = v7 > 0x20;
        uint64_t v9 = (1 << v7) & 0x100002600;
        if (v8 || v9 == 0) {
          break;
        }
        BOOL v15 = ++v6;
        if (v6 == v16) {
          goto LABEL_14;
        }
      }
LABEL_15:
      sub_1CD08CFAC((uint64_t)&v12);
    }
LABEL_14:
    *(unsigned char *)(a4 + 32) &= ~1u;
    llvm::json::Value::moveFrom(a4, v18);
  }
  else
  {
    uint64_t v11 = v12;
    uint64_t v12 = 0;
    *(unsigned char *)(a4 + 32) |= 1u;
    *(void *)a4 = v11;
  }
  llvm::json::Value::destroy((llvm::json::Value *)v18);
  if (v13)
  {
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    }
  }
}

uint64_t sub_1CD08AC98(uint64_t a1, llvm::json::Value *a2)
{
  v68[3] = *MEMORY[0x1E4F143B8];
  unint64_t v4 = *(char **)(a1 + 24);
  uint64_t v3 = *(unsigned __int8 **)(a1 + 32);
  if (v4 == (char *)v3) {
    goto LABEL_7;
  }
  while (1)
  {
    unsigned int v6 = *v4;
    BOOL v7 = v6 > 0x20;
    uint64_t v8 = (1 << v6) & 0x100002600;
    if (v7 || v8 == 0) {
      break;
    }
    *(void *)(a1 + 24) = ++v4;
    if (v4 == (char *)v3) {
      goto LABEL_7;
    }
  }
  uint64_t v11 = v4 + 1;
  *(void *)(a1 + 24) = v4 + 1;
  int v12 = *v4;
  if (v12 <= 90)
  {
    if (v12 == 34)
    {
      memset(&__p, 0, sizeof(__p));
      int v13 = sub_1CD08D150(a1, &__p);
      char v14 = v13;
      if (v13)
      {
        std::string v64 = __p;
        memset(&__p, 0, sizeof(__p));
        sub_1CD452764((uint64_t)&__str, (unint64_t)&v64);
        llvm::json::Value::destroy(a2);
        llvm::json::Value::moveFrom((uint64_t)a2, (unsigned __int16 *)&__str);
        llvm::json::Value::destroy((llvm::json::Value *)&__str);
        if (SHIBYTE(v64.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v64.__r_.__value_.__l.__data_);
        }
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      return v14 & 1;
    }
LABEL_27:
    if (v12 - 43 <= 0x3A
      && ((1 << (v12 - 43)) & 0x400000004007FEDLL) != 0)
    {
      std::string __str = (char *)v68;
      LOBYTE(v68[0]) = v12;
      long long v67 = xmmword_1CFB2EE20;
      if (v11 == (char *)v3)
      {
        uint64_t v18 = 0;
        unint64_t v19 = 24;
        uint64_t v20 = 1;
      }
      else
      {
        uint64_t v18 = 0;
        uint64_t v20 = 1;
        do
        {
          int v21 = *v11;
          if ((v21 - 48) >= 0xA)
          {
            unsigned int v22 = v21 - 43;
            BOOL v7 = v22 > 0x3A;
            uint64_t v23 = (1 << v22) & 0x40000000400000DLL;
            if (v7 || v23 == 0) {
              break;
            }
          }
          *(void *)(a1 + 24) = v11 + 1;
          if ((unint64_t)(v18 + 2) > *((void *)&v67 + 1)) {
            llvm::SmallVectorBase<unsigned long long>::grow_pod();
          }
          __str[v20] = *v11;
          uint64_t v18 = v67;
          uint64_t v20 = v67 + 1;
          *(void *)&long long v67 = v67 + 1;
          uint64_t v11 = *(char **)(a1 + 24);
        }
        while (v11 != *(char **)(a1 + 32));
        unint64_t v19 = *((void *)&v67 + 1);
      }
      __endptr[0] = 0;
      if (v18 + 2 > v19) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      __str[v20] = 0;
      std::string::size_type v25 = strtoll(__str, __endptr, 10);
      if (__endptr[0] == &__str[(void)v67])
      {
        LOWORD(__p.__r_.__value_.__l.__data_) = 3;
        __p.__r_.__value_.__l.__size_ = v25;
        llvm::json::Value::destroy(a2);
        llvm::json::Value::moveFrom((uint64_t)a2, (unsigned __int16 *)&__p);
        llvm::json::Value::destroy((llvm::json::Value *)&__p);
      }
      else
      {
        if ((unint64_t)(v67 + 1) > *((void *)&v67 + 1)) {
          llvm::SmallVectorBase<unsigned long long>::grow_pod();
        }
        __str[v67] = 0;
        double v26 = strtod(__str, __endptr);
        LOWORD(__p.__r_.__value_.__l.__data_) = 2;
        *(double *)&__p.__r_.__value_.__l.__size_ = v26;
        llvm::json::Value::destroy(a2);
        llvm::json::Value::moveFrom((uint64_t)a2, (unsigned __int16 *)&__p);
        llvm::json::Value::destroy((llvm::json::Value *)&__p);
        if (__endptr[0] != &__str[(void)v67]) {
          sub_1CD08CFAC(a1);
        }
      }
      char v14 = 1;
      if (__str != (char *)v68) {
        free(__str);
      }
      return v14 & 1;
    }
LABEL_7:
    sub_1CD08CFAC(a1);
  }
  if (v12 > 109)
  {
    if (v12 != 123)
    {
      if (v12 == 116)
      {
        LOWORD(__str) = 1;
        LOBYTE(v67) = 1;
        llvm::json::Value::destroy(a2);
        llvm::json::Value::moveFrom((uint64_t)a2, (unsigned __int16 *)&__str);
        llvm::json::Value::destroy((llvm::json::Value *)&__str);
        char v31 = *(unsigned char **)(a1 + 24);
        unint64_t v32 = *(unsigned char **)(a1 + 32);
        if (v31 == v32) {
          goto LABEL_7;
        }
        *(void *)(a1 + 24) = v31 + 1;
        if (*v31 != 114) {
          goto LABEL_7;
        }
        if (v31 + 1 == v32) {
          goto LABEL_7;
        }
        *(void *)(a1 + 24) = v31 + 2;
        if (v31[1] != 117) {
          goto LABEL_7;
        }
        if (v31 + 2 == v32) {
          goto LABEL_7;
        }
        *(void *)(a1 + 24) = v31 + 3;
        if (v31[2] != 101) {
          goto LABEL_7;
        }
      }
      else
      {
        if (v12 != 110) {
          goto LABEL_27;
        }
        LOWORD(__str) = 0;
        llvm::json::Value::destroy(a2);
        llvm::json::Value::moveFrom((uint64_t)a2, (unsigned __int16 *)&__str);
        llvm::json::Value::destroy((llvm::json::Value *)&__str);
        BOOL v15 = *(unsigned char **)(a1 + 24);
        int v16 = *(unsigned char **)(a1 + 32);
        if (v15 == v16) {
          goto LABEL_7;
        }
        *(void *)(a1 + 24) = v15 + 1;
        if (*v15 != 117) {
          goto LABEL_7;
        }
        if (v15 + 1 == v16) {
          goto LABEL_7;
        }
        *(void *)(a1 + 24) = v15 + 2;
        if (v15[1] != 108) {
          goto LABEL_7;
        }
        if (v15 + 2 == v16) {
          goto LABEL_7;
        }
        *(void *)(a1 + 24) = v15 + 3;
        if (v15[2] != 108) {
          goto LABEL_7;
        }
      }
      goto LABEL_114;
    }
    LOWORD(__str) = 7;
    long long v67 = 0uLL;
    memset(&__p, 0, sizeof(__p));
    LODWORD(v68[0]) = 0;
    llvm::json::Value::destroy(a2);
    llvm::json::Value::moveFrom((uint64_t)a2, (unsigned __int16 *)&__str);
    llvm::json::Value::destroy((llvm::json::Value *)&__str);
    sub_1CD452448((unsigned int *)&__p);
    MEMORY[0x1D25D9CD0](__p.__r_.__value_.__r.__words[0], 8);
    int v27 = *(unsigned __int8 **)(a1 + 24);
    char v28 = *(unsigned __int8 **)(a1 + 32);
    if (v27 == v28) {
      goto LABEL_89;
    }
    while (1)
    {
      unsigned int v29 = *v27;
      if (v29 > 0x20 || ((1 << v29) & 0x100002600) == 0) {
        break;
      }
      *(void *)(a1 + 24) = ++v27;
      if (v27 == v28) {
        goto LABEL_89;
      }
    }
    if (v29 != 125)
    {
LABEL_89:
      int v40 = *(unsigned char **)(a1 + 24);
      if (v40 == *(unsigned char **)(a1 + 32)) {
        goto LABEL_7;
      }
      *(void *)(a1 + 24) = v40 + 1;
      if (*v40 != 34) {
        goto LABEL_7;
      }
      memset(&__p, 0, sizeof(__p));
      if (sub_1CD08D150(a1, &__p))
      {
        __int16 v42 = *(unsigned __int8 **)(a1 + 24);
        char v41 = *(unsigned __int8 **)(a1 + 32);
        while (1)
        {
          if (v42 == v41) {
            goto LABEL_99;
          }
          unsigned int v43 = *v42;
          BOOL v7 = v43 > 0x20;
          uint64_t v44 = (1 << v43) & 0x100002600;
          if (v7 || v44 == 0) {
            break;
          }
          *(void *)(a1 + 24) = ++v42;
        }
        uint64_t v46 = v42 + 1;
        *(void *)(a1 + 24) = v42 + 1;
        if (*v42 == 58)
        {
          while (v46 != v41)
          {
            unsigned int v47 = *v46;
            BOOL v7 = v47 > 0x20;
            uint64_t v48 = (1 << v47) & 0x100002600;
            if (v7 || v48 == 0) {
              break;
            }
            *(void *)(a1 + 24) = ++v46;
          }
          memset(&__p, 0, sizeof(__p));
          sub_1CD451A6C();
        }
LABEL_99:
        sub_1CD08CFAC(a1);
      }
      char v14 = 0;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      return v14 & 1;
    }
LABEL_113:
    *(void *)(a1 + 24) = v27 + 1;
    goto LABEL_114;
  }
  if (v12 != 91)
  {
    if (v12 != 102) {
      goto LABEL_27;
    }
    LOWORD(__str) = 1;
    LOBYTE(v67) = 0;
    llvm::json::Value::destroy(a2);
    llvm::json::Value::moveFrom((uint64_t)a2, (unsigned __int16 *)&__str);
    llvm::json::Value::destroy((llvm::json::Value *)&__str);
    uint64_t v38 = *(unsigned char **)(a1 + 24);
    uint64_t v39 = *(unsigned char **)(a1 + 32);
    if (v38 == v39) {
      goto LABEL_7;
    }
    *(void *)(a1 + 24) = v38 + 1;
    if (*v38 != 97) {
      goto LABEL_7;
    }
    if (v38 + 1 == v39) {
      goto LABEL_7;
    }
    *(void *)(a1 + 24) = v38 + 2;
    if (v38[1] != 108) {
      goto LABEL_7;
    }
    if (v38 + 2 == v39) {
      goto LABEL_7;
    }
    *(void *)(a1 + 24) = v38 + 3;
    if (v38[2] != 115) {
      goto LABEL_7;
    }
    if (v38 + 3 == v39) {
      goto LABEL_7;
    }
    *(void *)(a1 + 24) = v38 + 4;
    if (v38[3] != 101) {
      goto LABEL_7;
    }
LABEL_114:
    char v14 = 1;
    return v14 & 1;
  }
  LOWORD(__str) = 8;
  v68[0] = 0;
  long long v67 = 0uLL;
  memset(&__p, 0, sizeof(__p));
  llvm::json::Value::destroy(a2);
  llvm::json::Value::moveFrom((uint64_t)a2, (unsigned __int16 *)&__str);
  llvm::json::Value::destroy((llvm::json::Value *)&__str);
  __endptr[0] = (char *)&__p;
  sub_1CBF2C7E0((void ***)__endptr);
  int v34 = *(unsigned __int16 *)a2;
  char v33 = (char *)a2 + 8;
  if (v34 != 8) {
    char v33 = 0;
  }
  int v27 = *(unsigned __int8 **)(a1 + 24);
  uint64_t v35 = *(unsigned __int8 **)(a1 + 32);
  if (v27 != v35)
  {
    while (1)
    {
      unsigned int v36 = *v27;
      if (v36 > 0x20 || ((1 << v36) & 0x100002600) == 0) {
        break;
      }
      *(void *)(a1 + 24) = ++v27;
      if (v27 == v35) {
        goto LABEL_115;
      }
    }
    if (v36 != 93) {
      goto LABEL_115;
    }
    goto LABEL_113;
  }
  while (1)
  {
LABEL_115:
    unsigned int v50 = (_WORD *)*((void *)v33 + 1);
    if ((unint64_t)v50 >= *((void *)v33 + 2))
    {
      uint64_t v51 = sub_1CD08D674((unsigned __int16 **)v33);
    }
    else
    {
      *unsigned int v50 = 0;
      uint64_t v51 = v50 + 16;
    }
    *((void *)v33 + 1) = v51;
    int v52 = sub_1CD08AC98(a1, v51 - 16);
    char v14 = v52;
    if (!v52) {
      return v14 & 1;
    }
    int v54 = *(unsigned __int8 **)(a1 + 24);
    BOOL v53 = *(unsigned __int8 **)(a1 + 32);
    if (v54 == v53) {
      goto LABEL_7;
    }
    while (1)
    {
      unsigned int v55 = *v54;
      BOOL v7 = v55 > 0x20;
      uint64_t v56 = (1 << v55) & 0x100002600;
      if (v7 || v56 == 0) {
        break;
      }
      *(void *)(a1 + 24) = ++v54;
      if (v54 == v53) {
        goto LABEL_7;
      }
    }
    int v58 = v54 + 1;
    *(void *)(a1 + 24) = v54 + 1;
    int v59 = (char)*v54;
    if (v59 != 44) {
      break;
    }
    for (; v58 != v53; *(void *)(a1 + 24) = v58)
    {
      unsigned int v60 = *v58;
      BOOL v7 = v60 > 0x20;
      uint64_t v61 = (1 << v60) & 0x100002600;
      if (v7 || v61 == 0) {
        break;
      }
      ++v58;
    }
  }
  if (v59 != 93) {
    goto LABEL_7;
  }
  return v14 & 1;
}

BOOL llvm::json::isUTF8(unsigned __int8 *a1, uint64_t a2, unsigned __int8 *a3)
{
  if (!a2) {
    return 1;
  }
  uint64_t v6 = 0;
  BOOL v7 = (const unsigned __int8 **)&a1[a2];
  while (((char)a1[v6] & 0x80000000) == 0)
  {
    if (a2 == ++v6) {
      return 1;
    }
  }
  unint64_t v10 = a1;
  BOOL isLegalUTF8String = llvm::isLegalUTF8String(&v10, v7, a3);
  BOOL result = isLegalUTF8String;
  if (!isLegalUTF8String)
  {
    if (a3) {
      *(void *)a3 = v10 - a1;
    }
  }
  return result;
}

llvm::raw_ostream *llvm::json::OStream::value(uint64_t a1, unsigned __int16 *a2)
{
  switch(*a2)
  {
    case 1u:
      llvm::json::OStream::valueBegin((llvm::json::OStream *)a1);
      uint64_t v23 = *(llvm::raw_ostream **)(a1 + 160);
      BOOL v24 = *a2 != 1 || *((unsigned char *)a2 + 8) == 0;
      if (v24) {
        int v21 = "false";
      }
      else {
        int v21 = "true";
      }
      if (v24) {
        size_t v25 = 5;
      }
      else {
        size_t v25 = 4;
      }
      double v26 = (void *)*((void *)v23 + 4);
      if (v25 > *((void *)v23 + 3) - (void)v26)
      {
        BOOL result = v23;
        size_t v22 = v25;
        goto LABEL_31;
      }
      BOOL result = (llvm::raw_ostream *)memcpy(v26, v21, v25);
      *((void *)v23 + 4) += v25;
      break;
    case 2u:
    case 3u:
    case 4u:
      llvm::json::OStream::valueBegin((llvm::json::OStream *)a1);
      int v4 = *a2;
      if (v4 == 4)
      {
        uint64_t v18 = *(llvm::raw_ostream **)(a1 + 160);
        unint64_t v19 = *((void *)a2 + 1);
        BOOL result = sub_1CD098D14(v18, v19, 0, 0, 0);
      }
      else if (v4 == 3)
      {
        uint64_t v39 = *(llvm::raw_ostream **)(a1 + 160);
        unint64_t v40 = sub_1CD82C174(a2);
        BOOL result = llvm::raw_ostream::operator<<(v39, v40);
      }
      else
      {
        uint64_t v5 = *(llvm::raw_ostream **)(a1 + 160);
        double v6 = *((double *)a2 + 1);
        if (v4 != 2) {
          double v6 = 0.0;
        }
        char v41 = (const char *)&unk_1F2644DA8;
        __int16 v42 = "%.*g";
        int v43 = 17;
        double v44 = v6;
        BOOL result = llvm::raw_ostream::operator<<(v5, (uint64_t)&v41);
      }
      break;
    case 5u:
    case 6u:
      llvm::json::OStream::valueBegin((llvm::json::OStream *)a1);
      uint64_t v9 = *(llvm::raw_ostream **)(a1 + 160);
      int v10 = *a2;
      if (v10 == 6)
      {
        int v13 = (unsigned __int8 *)*((void *)a2 + 1);
        int v12 = a2 + 4;
        uint64_t v11 = v13;
        char v14 = *((unsigned char *)v12 + 23);
        int v15 = v14;
        if (v14 >= 0) {
          int v16 = (unsigned __int8 *)v12;
        }
        else {
          int v16 = v11;
        }
        uint64_t v17 = v14 & 0x7F;
        if (v15 >= 0) {
          uint64_t v8 = v17;
        }
        else {
          uint64_t v8 = *((void *)v12 + 1);
        }
      }
      else if (v10 == 5)
      {
        int v16 = (unsigned __int8 *)*((void *)a2 + 1);
        uint64_t v8 = *((void *)a2 + 2);
      }
      else
      {
        int v16 = 0;
      }
      BOOL result = sub_1CD08BB00(v9, v16, v8);
      break;
    case 7u:
      llvm::json::OStream::objectBegin((llvm::json::OStream *)a1);
      int v28 = *a2;
      int v27 = (uint64_t *)(a2 + 4);
      if (v28 == 7) {
        unsigned int v29 = v27;
      }
      else {
        unsigned int v29 = 0;
      }
      sub_1CD08C1D4((uint64_t *)&v41, v29);
      int v30 = (char *)v41;
      char v31 = v42;
      if (v41 != v42)
      {
        unint64_t v32 = v41;
        do
        {
          uint64_t v33 = *(void *)v32;
          v32 += 8;
          llvm::json::OStream::attributeBegin(a1, *(char **)(v33 + 8), *(void *)(v33 + 16));
          llvm::json::OStream::value((llvm::json::OStream *)a1, (const llvm::json::Value *)(v33 + 24));
          --*(_DWORD *)(a1 + 8);
        }
        while (v32 != v31);
      }
      if (v30) {
        operator delete(v30);
      }
      BOOL result = llvm::json::OStream::objectEnd((llvm::json::OStream *)a1);
      break;
    case 8u:
      llvm::json::OStream::arrayBegin((llvm::json::OStream *)a1);
      int v35 = *a2;
      int v34 = a2 + 4;
      if (v35 == 8) {
        unsigned int v36 = (const llvm::json::Value **)v34;
      }
      else {
        unsigned int v36 = 0;
      }
      uint64_t v37 = *v36;
      uint64_t v38 = v36[1];
      while (v37 != v38)
      {
        llvm::json::OStream::value((llvm::json::OStream *)a1, v37);
        uint64_t v37 = (const llvm::json::Value *)((char *)v37 + 32);
      }
      BOOL result = llvm::json::OStream::arrayEnd((llvm::json::OStream *)a1);
      break;
    default:
      llvm::json::OStream::valueBegin((llvm::json::OStream *)a1);
      BOOL result = *(llvm::raw_ostream **)(a1 + 160);
      uint64_t v20 = (_DWORD *)*((void *)result + 4);
      if (*((void *)result + 3) - (void)v20 > 3uLL)
      {
        *uint64_t v20 = 1819047278;
        *((void *)result + 4) += 4;
      }
      else
      {
        int v21 = "null";
        size_t v22 = 4;
LABEL_31:
        BOOL result = llvm::raw_ostream::write(result, v21, v22);
      }
      break;
  }
  return result;
}

llvm::raw_ostream *sub_1CD08BB00(llvm::raw_ostream *this, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v5 = this;
  double v6 = (unsigned char *)*((void *)this + 4);
  if ((unint64_t)v6 < *((void *)this + 3))
  {
    *((void *)this + 4) = v6 + 1;
    *double v6 = 34;
    if (!a3) {
      goto LABEL_36;
    }
    while (1)
    {
LABEL_5:
      unint64_t v7 = *a2;
      if (v7 == 92 || v7 == 34)
      {
        uint64_t v8 = (unsigned char *)*((void *)v5 + 4);
        if ((unint64_t)v8 >= *((void *)v5 + 3))
        {
          this = llvm::raw_ostream::write(v5, 92);
        }
        else
        {
          *((void *)v5 + 4) = v8 + 1;
          unsigned char *v8 = 92;
        }
      }
      else if (v7 < 0x20)
      {
        uint64_t v9 = (unsigned char *)*((void *)v5 + 4);
        if ((unint64_t)v9 >= *((void *)v5 + 3))
        {
          this = llvm::raw_ostream::write(v5, 92);
        }
        else
        {
          *((void *)v5 + 4) = v9 + 1;
          unsigned char *v9 = 92;
        }
        switch(v7)
        {
          case 0xD:
            char v14 = (unsigned char *)*((void *)v5 + 4);
            if ((unint64_t)v14 < *((void *)v5 + 3))
            {
              *((void *)v5 + 4) = v14 + 1;
              *char v14 = 114;
              goto LABEL_17;
            }
            uint64_t v11 = v5;
            char v12 = 114;
            break;
          case 0xA:
            int v15 = (unsigned char *)*((void *)v5 + 4);
            if ((unint64_t)v15 < *((void *)v5 + 3))
            {
              *((void *)v5 + 4) = v15 + 1;
              *int v15 = 110;
              goto LABEL_17;
            }
            uint64_t v11 = v5;
            char v12 = 110;
            break;
          case 9:
            int v13 = (unsigned char *)*((void *)v5 + 4);
            if ((unint64_t)v13 < *((void *)v5 + 3))
            {
              *((void *)v5 + 4) = v13 + 1;
              unsigned char *v13 = 116;
              goto LABEL_17;
            }
            uint64_t v11 = v5;
            char v12 = 116;
            break;
          default:
            int v16 = (unsigned char *)*((void *)v5 + 4);
            if ((unint64_t)v16 >= *((void *)v5 + 3))
            {
              llvm::raw_ostream::write(v5, 117);
            }
            else
            {
              *((void *)v5 + 4) = v16 + 1;
              *int v16 = 117;
            }
            this = llvm::write_hex(v5, v7, 1, 4uLL, 1);
            goto LABEL_17;
        }
        goto LABEL_16;
      }
      int v10 = (unsigned char *)*((void *)v5 + 4);
      if ((unint64_t)v10 >= *((void *)v5 + 3))
      {
        uint64_t v11 = v5;
        char v12 = v7;
LABEL_16:
        this = llvm::raw_ostream::write(v11, v12);
        goto LABEL_17;
      }
      *((void *)v5 + 4) = v10 + 1;
      *int v10 = v7;
LABEL_17:
      ++a2;
      if (!--v3) {
        goto LABEL_36;
      }
    }
  }
  this = llvm::raw_ostream::write(this, 34);
  if (v3) {
    goto LABEL_5;
  }
LABEL_36:
  uint64_t v17 = (unsigned char *)*((void *)v5 + 4);
  if ((unint64_t)v17 >= *((void *)v5 + 3))
  {
    return llvm::raw_ostream::write(v5, 34);
  }
  else
  {
    *((void *)v5 + 4) = v17 + 1;
    unsigned char *v17 = 34;
  }
  return this;
}

uint64_t llvm::json::OStream::comment(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 144) = a2;
  *(void *)(result + 152) = a3;
  return result;
}

uint64_t llvm::json::OStream::rawValueBegin(llvm::json::OStream *this)
{
  llvm::json::OStream::valueBegin(this);
  uint64_t v2 = *((unsigned int *)this + 2);
  if (v2 >= *((_DWORD *)this + 3))
  {
    sub_1CD83C1D0((uint64_t)this);
    unsigned int v3 = *((_DWORD *)this + 2);
  }
  else
  {
    *(void *)(*(void *)this + 8 * v2) = 0;
    unsigned int v3 = *((_DWORD *)this + 2) + 1;
    *((_DWORD *)this + 2) = v3;
  }
  *(_DWORD *)(*(void *)this + 8 * v3 - 8) = 4;
  return *((void *)this + 20);
}

uint64_t llvm::json::OStream::rawValueEnd(uint64_t this)
{
  return this;
}

void sub_1CD08BDD8(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *((unsigned char *)&__p.__r_.__value_.__s + 23) = 7;
  strcpy((char *)&__p, "error: ");
  std::string::append(&__p, *(const std::string::value_type **)(v2 + 16), *(void *)(v2 + 24));
  uint64_t v3 = a1[1];
  p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  std::string::size_type size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  *(void *)(v3 + 144) = p_p;
  *(void *)(v3 + 152) = size;
  uint64_t v8 = a1 + 1;
  double v6 = (llvm::json::OStream *)a1[1];
  unint64_t v7 = (unsigned __int16 *)v8[1];
  unsigned int v9 = *v7;
  if (v9 >= 7)
  {
    if (v9 == 7)
    {
      llvm::json::OStream::objectBegin(v6);
      int v11 = *v7;
      int v10 = (uint64_t *)(v7 + 4);
      if (v11 == 7) {
        char v12 = v10;
      }
      else {
        char v12 = 0;
      }
      sub_1CD08C1D4((uint64_t *)&v23, v12);
      int v13 = v23;
      char v14 = v24;
      if (v23 != v24)
      {
        int v15 = v23;
        do
        {
          uint64_t v16 = *v15++;
          llvm::json::OStream::attributeBegin((uint64_t)v6, *(char **)(v16 + 8), *(void *)(v16 + 16));
          sub_1CD08BF4C(v16 + 24, (llvm::raw_ostream **)v6);
          --*((_DWORD *)v6 + 2);
        }
        while (v15 != v14);
      }
      if (v13) {
        operator delete(v13);
      }
      llvm::json::OStream::objectEnd(v6);
    }
    else
    {
      llvm::json::OStream::arrayBegin(v6);
      int v18 = *v7;
      uint64_t v17 = (uint64_t *)(v7 + 4);
      if (v18 == 8) {
        unint64_t v19 = v17;
      }
      else {
        unint64_t v19 = 0;
      }
      uint64_t v20 = *v19;
      uint64_t v21 = v19[1];
      while (v20 != v21)
      {
        sub_1CD08BF4C(v20, (llvm::raw_ostream **)v6);
        v20 += 32;
      }
      llvm::json::OStream::arrayEnd(v6);
    }
  }
  else
  {
    llvm::json::OStream::value((uint64_t)v6, v7);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1CD08BF4C(uint64_t a1, llvm::raw_ostream **this)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  switch(*(_WORD *)a1)
  {
    case 5:
      unint64_t v4 = *(void *)(a1 + 8);
      unint64_t v5 = *(void *)(a1 + 16);
      goto LABEL_8;
    case 6:
      char v6 = *(unsigned char *)(a1 + 31);
      if (v6 >= 0) {
        unint64_t v4 = a1 + 8;
      }
      else {
        unint64_t v4 = *(void *)(a1 + 8);
      }
      unint64_t v5 = *(void *)(a1 + 16);
      if (v6 >= 0) {
        unint64_t v5 = v6 & 0x7F;
      }
LABEL_8:
      if (v5 <= 0x27) {
        goto LABEL_9;
      }
      llvm::json::fixUTF8(v4, 0x25uLL, (uint64_t)&v22);
      std::string::append(&v22, "...");
      if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
        sub_1CB8BDF7C((uint64_t)&__p, v22.__r_.__value_.__l.__data_, v22.__r_.__value_.__l.__size_);
      }
      else {
        std::string __p = v22;
      }
      sub_1CD452764((uint64_t)v23, (unint64_t)&__p);
      llvm::json::OStream::value((uint64_t)this, v23);
      llvm::json::Value::destroy((llvm::json::Value *)v23);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v22.__r_.__value_.__l.__data_);
      }
      return;
    case 7:
      int v7 = *(_DWORD *)(a1 + 16);
      llvm::json::OStream::rawValueBegin((llvm::json::OStream *)this);
      BOOL v8 = v7 == 0;
      if (v7) {
        size_t v9 = 7;
      }
      else {
        size_t v9 = 2;
      }
      int v10 = this[20];
      if (v8) {
        int v11 = "{}";
      }
      else {
        int v11 = "{ ... }";
      }
      char v12 = (void *)*((void *)v10 + 4);
      if (v9 > *((void *)v10 + 3) - (void)v12)
      {
        int v13 = this[20];
        size_t v14 = v9;
        goto LABEL_28;
      }
      memcpy(v12, v11, v9);
      *((void *)v10 + 4) += v9;
      break;
    case 8:
      uint64_t v15 = *(void *)(a1 + 8);
      uint64_t v16 = *(void *)(a1 + 16);
      if (v15 == v16) {
        uint64_t v17 = "[]";
      }
      else {
        uint64_t v17 = "[ ... ]";
      }
      if (v15 == v16) {
        size_t v18 = 2;
      }
      else {
        size_t v18 = 7;
      }
      llvm::json::OStream::rawValueBegin((llvm::json::OStream *)this);
      unint64_t v19 = this[20];
      uint64_t v20 = (void *)*((void *)v19 + 4);
      if (v18 <= *((void *)v19 + 3) - (void)v20)
      {
        memcpy(v20, v17, v18);
        *((void *)v19 + 4) += v18;
      }
      else
      {
        int v13 = this[20];
        int v11 = v17;
        size_t v14 = v18;
LABEL_28:
        llvm::raw_ostream::write(v13, v11, v14);
      }
      break;
    default:
LABEL_9:
      llvm::json::OStream::value((uint64_t)this, (unsigned __int16 *)a1);
      return;
  }
  --*((_DWORD *)this + 2);
}

uint64_t sub_1CD08C1D4(uint64_t *a1, uint64_t *a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (!*((_DWORD *)a2 + 2)) {
    goto LABEL_33;
  }
  uint64_t v3 = *((unsigned int *)a2 + 4);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    uint64_t v5 = *a2;
    while (*(void *)(v5 + 8) >= 0xFFFFFFFFFFFFFFFELL)
    {
      v5 += 56;
      v4 -= 56;
      if (!v4) {
        goto LABEL_33;
      }
    }
  }
  else
  {
    uint64_t v5 = *a2;
  }
  uint64_t v6 = *a2 + 56 * v3;
  if (v5 == v6)
  {
LABEL_33:
    int v7 = 0;
    uint64_t v18 = 0;
  }
  else
  {
    int v7 = 0;
LABEL_10:
    unint64_t v8 = a1[2];
    if ((unint64_t)v7 >= v8)
    {
      size_t v9 = (void *)*a1;
      uint64_t v10 = ((uint64_t)v7 - *a1) >> 3;
      unint64_t v11 = v10 + 1;
      if ((unint64_t)(v10 + 1) >> 61) {
        abort();
      }
      uint64_t v12 = v8 - (void)v9;
      if (v12 >> 2 > v11) {
        unint64_t v11 = v12 >> 2;
      }
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v13 = v11;
      }
      if (v13)
      {
        if (v13 >> 61) {
          sub_1CB833614();
        }
        size_t v14 = (char *)operator new(8 * v13);
      }
      else
      {
        size_t v14 = 0;
      }
      uint64_t v15 = &v14[8 * v10];
      *(void *)uint64_t v15 = v5;
      uint64_t v16 = v15 + 8;
      if (v7 != v9)
      {
        do
        {
          uint64_t v17 = *--v7;
          *((void *)v15 - 1) = v17;
          v15 -= 8;
        }
        while (v7 != v9);
        int v7 = (void *)*a1;
      }
      *a1 = (uint64_t)v15;
      a1[1] = (uint64_t)v16;
      a1[2] = (uint64_t)&v14[8 * v13];
      if (v7) {
        operator delete(v7);
      }
      int v7 = v16;
    }
    else
    {
      *v7++ = v5;
    }
    a1[1] = (uint64_t)v7;
    while (1)
    {
      v5 += 56;
      if (v5 == v6) {
        break;
      }
      if (*(void *)(v5 + 8) < 0xFFFFFFFFFFFFFFFELL)
      {
        if (v5 != v6) {
          goto LABEL_10;
        }
        break;
      }
    }
    uint64_t v18 = *a1;
  }
  unint64_t v19 = 126 - 2 * __clz(((uint64_t)v7 - v18) >> 3);
  if (v7 == (void *)v18) {
    uint64_t v20 = 0;
  }
  else {
    uint64_t v20 = v19;
  }

  return sub_1CD08C38C(v18, v7, v20, 1);
}

uint64_t sub_1CD08C38C(uint64_t result, uint64_t *a2, uint64_t a3, char a4)
{
  int v7 = (uint64_t *)result;
  while (2)
  {
    unint64_t v8 = a2;
    unsigned int v95 = a2 - 1;
    size_t v9 = v7;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          int v7 = v9;
          uint64_t v10 = (char *)v8 - (char *)v9;
          uint64_t v11 = v8 - v9;
          if (v5 || !v4)
          {
            switch(v11)
            {
              case 0:
              case 1:
                return result;
              case 2:
                uint64_t v84 = *(a2 - 1);
                uint64_t v85 = *v9;
                BOOL result = sub_1CD506DA0(*(const void **)(v84 + 8), *(void *)(v84 + 16), *(void **)(*v9 + 8), *(void *)(*v9 + 16));
                if (result)
                {
                  uint64_t *v9 = v84;
                  *(a2 - 1) = v85;
                }
                break;
              case 3:
                BOOL result = sub_1CD08CBDC(v9, v9 + 1, v95);
                break;
              case 4:
                BOOL result = sub_1CD08CF08(v9, v9 + 1, v9 + 2, v95);
                break;
              case 5:
                unsigned int v86 = v9 + 2;
                uint64_t v87 = v9 + 3;
                sub_1CD08CF08(v9, v9 + 1, v9 + 2, v9 + 3);
                uint64_t v88 = *(a2 - 1);
                uint64_t v89 = v9[3];
                BOOL result = sub_1CD506DA0(*(const void **)(v88 + 8), *(void *)(v88 + 16), *(void **)(v89 + 8), *(void *)(v89 + 16));
                if (result)
                {
                  *uint64_t v87 = v88;
                  *(a2 - 1) = v89;
                  uint64_t v90 = *v87;
                  uint64_t v91 = *v86;
                  size_t v92 = *(void *)(*v87 + 16);
                  BOOL result = sub_1CD506DA0(*(const void **)(*v87 + 8), v92, *(void **)(*v86 + 8), *(void *)(*v86 + 16));
                  if (result)
                  {
                    *unsigned int v86 = v90;
                    *uint64_t v87 = v91;
                    uint64_t v93 = v9[1];
                    BOOL result = sub_1CD506DA0(*(const void **)(v90 + 8), v92, *(void **)(v93 + 8), *(void *)(v93 + 16));
                    if (result)
                    {
                      v9[1] = v90;
                      v9[2] = v93;
                      uint64_t v94 = *v9;
                      BOOL result = sub_1CD506DA0(*(const void **)(v90 + 8), v92, *(void **)(*v9 + 8), *(void *)(*v9 + 16));
                      if (result)
                      {
                        uint64_t *v9 = v90;
                        v9[1] = v94;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v10 <= 191)
          {
            unint64_t v40 = v9 + 1;
            BOOL v42 = v9 == v8 || v40 == v8;
            if (a4)
            {
              if (!v42)
              {
                uint64_t v43 = 0;
                double v44 = v9;
                do
                {
                  uint64_t v46 = *v44;
                  uint64_t v45 = v44[1];
                  double v44 = v40;
                  size_t v47 = *(void *)(v45 + 16);
                  BOOL result = sub_1CD506DA0(*(const void **)(v45 + 8), v47, *(void **)(v46 + 8), *(void *)(v46 + 16));
                  if (result)
                  {
                    uint64_t v48 = v43;
                    while (1)
                    {
                      *(uint64_t *)((char *)v9 + v48 + --*(_DWORD *)(this + 8) = v46;
                      if (!v48) {
                        break;
                      }
                      uint64_t v46 = *(uint64_t *)((char *)v9 + v48 - 8);
                      BOOL result = sub_1CD506DA0(*(const void **)(v45 + 8), v47, *(void **)(v46 + 8), *(void *)(v46 + 16));
                      v48 -= 8;
                      if ((result & 1) == 0)
                      {
                        uint64_t v49 = (uint64_t *)((char *)v9 + v48 + 8);
                        goto LABEL_78;
                      }
                    }
                    uint64_t v49 = v9;
LABEL_78:
                    *uint64_t v49 = v45;
                  }
                  unint64_t v40 = v44 + 1;
                  v43 += 8;
                }
                while (v44 + 1 != a2);
              }
            }
            else if (!v42)
            {
              do
              {
                uint64_t v81 = *v7;
                uint64_t v80 = v7[1];
                int v7 = v40;
                size_t v82 = *(void *)(v80 + 16);
                BOOL result = sub_1CD506DA0(*(const void **)(v80 + 8), v82, *(void **)(v81 + 8), *(void *)(v81 + 16));
                if (result)
                {
                  uint64_t v83 = v7;
                  do
                  {
                    *uint64_t v83 = v81;
                    uint64_t v81 = *(v83 - 2);
                    BOOL result = sub_1CD506DA0(*(const void **)(v80 + 8), v82, *(void **)(v81 + 8), *(void *)(v81 + 16));
                    --v83;
                  }
                  while ((result & 1) != 0);
                  *uint64_t v83 = v80;
                }
                unint64_t v40 = v7 + 1;
              }
              while (v7 + 1 != a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v9 != v8)
            {
              int64_t v50 = (unint64_t)(v11 - 2) >> 1;
              int64_t v51 = v50;
              do
              {
                int64_t v52 = v51;
                if (v50 >= v51)
                {
                  uint64_t v53 = (2 * v51) | 1;
                  int v54 = &v7[v53];
                  uint64_t v55 = *v54;
                  if (2 * v51 + 2 < v11)
                  {
                    uint64_t v56 = v54[1];
                    if (sub_1CD506DA0(*(const void **)(v55 + 8), *(void *)(v55 + 16), *(void **)(v56 + 8), *(void *)(v56 + 16)))
                    {
                      uint64_t v55 = v56;
                      ++v54;
                      uint64_t v53 = 2 * v52 + 2;
                    }
                  }
                  long long v57 = &v7[v52];
                  size_t v97 = *(void *)(*v57 + 16);
                  uint64_t v99 = *v57;
                  BOOL result = sub_1CD506DA0(*(const void **)(v55 + 8), *(void *)(v55 + 16), *(void **)(*v57 + 8), v97);
                  if ((result & 1) == 0)
                  {
                    do
                    {
                      int v58 = v54;
                      *long long v57 = v55;
                      if (v50 < v53) {
                        break;
                      }
                      uint64_t v59 = (2 * v53) | 1;
                      int v54 = &v7[v59];
                      uint64_t v60 = 2 * v53 + 2;
                      uint64_t v55 = *v54;
                      if (v60 < v11)
                      {
                        uint64_t v61 = v54[1];
                        if (sub_1CD506DA0(*(const void **)(v55 + 8), *(void *)(v55 + 16), *(void **)(v61 + 8), *(void *)(v61 + 16)))
                        {
                          uint64_t v55 = v61;
                          ++v54;
                          uint64_t v59 = v60;
                        }
                      }
                      BOOL result = sub_1CD506DA0(*(const void **)(v55 + 8), *(void *)(v55 + 16), *(void **)(v99 + 8), v97);
                      long long v57 = v58;
                      uint64_t v53 = v59;
                    }
                    while (!result);
                    *int v58 = v99;
                  }
                }
                int64_t v51 = v52 - 1;
              }
              while (v52);
              do
              {
                uint64_t v62 = 0;
                uint64_t v100 = *v7;
                uint64_t v63 = v7;
                do
                {
                  std::string v64 = &v63[v62];
                  uint64_t v67 = v64[1];
                  uint64_t v65 = v64 + 1;
                  uint64_t v66 = v67;
                  uint64_t v68 = (2 * v62) | 1;
                  uint64_t v69 = 2 * v62 + 2;
                  if (v69 < v11)
                  {
                    uint64_t v70 = v65[1];
                    BOOL result = sub_1CD506DA0(*(const void **)(v66 + 8), *(void *)(v66 + 16), *(void **)(v70 + 8), *(void *)(v70 + 16));
                    if (result)
                    {
                      uint64_t v66 = v70;
                      ++v65;
                      uint64_t v68 = v69;
                    }
                  }
                  *uint64_t v63 = v66;
                  uint64_t v63 = v65;
                  uint64_t v62 = v68;
                }
                while (v68 <= (uint64_t)((unint64_t)(v11 - 2) >> 1));
                BOOL v71 = a2 - 1;
                BOOL v5 = v65 == --a2;
                if (v5)
                {
                  *uint64_t v65 = v100;
                }
                else
                {
                  *uint64_t v65 = *v71;
                  *BOOL v71 = v100;
                  uint64_t v72 = (char *)v65 - (char *)v7 + 8;
                  if (v72 >= 9)
                  {
                    unint64_t v73 = (((unint64_t)v72 >> 3) - 2) >> 1;
                    uint64_t v74 = &v7[v73];
                    uint64_t v75 = *v74;
                    uint64_t v76 = *v65;
                    size_t v77 = *(void *)(*v65 + 16);
                    BOOL result = sub_1CD506DA0(*(const void **)(*v74 + 8), *(void *)(*v74 + 16), *(void **)(*v65 + 8), v77);
                    if (result)
                    {
                      do
                      {
                        unsigned int v78 = v74;
                        *uint64_t v65 = v75;
                        if (!v73) {
                          break;
                        }
                        unint64_t v73 = (v73 - 1) >> 1;
                        uint64_t v74 = &v7[v73];
                        uint64_t v75 = *v74;
                        BOOL result = sub_1CD506DA0(*(const void **)(*v74 + 8), *(void *)(*v74 + 16), *(void **)(v76 + 8), v77);
                        uint64_t v65 = v78;
                      }
                      while ((result & 1) != 0);
                      *unsigned int v78 = v76;
                    }
                  }
                }
              }
              while (v11-- > 2);
            }
            return result;
          }
          unint64_t v12 = (unint64_t)v11 >> 1;
          unint64_t v13 = &v9[(unint64_t)v11 >> 1];
          if ((unint64_t)v10 < 0x401)
          {
            sub_1CD08CBDC(v13, v9, v95);
          }
          else
          {
            sub_1CD08CBDC(v9, v13, v95);
            sub_1CD08CBDC(v9 + 1, v13 - 1, a2 - 2);
            sub_1CD08CBDC(v9 + 2, &v9[v12 + 1], a2 - 3);
            sub_1CD08CBDC(v13 - 1, v13, &v9[v12 + 1]);
            uint64_t v14 = *v9;
            uint64_t *v9 = *v13;
            uint64_t *v13 = v14;
          }
          uint64_t v15 = *v9;
          uint64_t v98 = a3 - 1;
          if (a4) {
            break;
          }
          uint64_t v17 = *(void **)(v15 + 8);
          size_t v16 = *(void *)(v15 + 16);
          if (sub_1CD506DA0(*(const void **)(*(v9 - 1) + 8), *(void *)(*(v9 - 1) + 16), v17, v16)) {
            goto LABEL_12;
          }
          BOOL result = sub_1CD506DA0(v17, v16, *(void **)(*v95 + 8), *(void *)(*v95 + 16));
          if (result)
          {
            do
            {
              uint64_t v30 = v9[1];
              ++v9;
              BOOL result = sub_1CD506DA0(v17, v16, *(void **)(v30 + 8), *(void *)(v30 + 16));
            }
            while ((result & 1) == 0);
          }
          else
          {
            uint64_t v39 = v9 + 1;
            do
            {
              size_t v9 = v39;
              if (v39 >= v8) {
                break;
              }
              ++v39;
              BOOL result = sub_1CD506DA0(v17, v16, *(void **)(*v9 + 8), *(void *)(*v9 + 16));
            }
            while (!result);
          }
          char v31 = v8;
          if (v9 < v8)
          {
            char v31 = v8;
            do
            {
              uint64_t v32 = *--v31;
              BOOL result = sub_1CD506DA0(v17, v16, *(void **)(v32 + 8), *(void *)(v32 + 16));
            }
            while ((result & 1) != 0);
          }
          if (v9 < v31)
          {
            uint64_t v33 = *v9;
            uint64_t v34 = *v31;
            do
            {
              uint64_t *v9 = v34;
              *char v31 = v33;
              int v35 = *(const void **)(v15 + 8);
              do
              {
                uint64_t v36 = v9[1];
                ++v9;
                uint64_t v33 = v36;
              }
              while (!sub_1CD506DA0(v35, v16, *(void **)(v36 + 8), *(void *)(v36 + 16)));
              do
              {
                uint64_t v37 = *--v31;
                uint64_t v34 = v37;
                BOOL result = sub_1CD506DA0(v35, v16, *(void **)(v37 + 8), *(void *)(v37 + 16));
              }
              while ((result & 1) != 0);
            }
            while (v9 < v31);
          }
          uint64_t v38 = v9 - 1;
          BOOL v4 = v9 - 1 >= v7;
          BOOL v5 = v9 - 1 == v7;
          unint64_t v8 = a2;
          if (v9 - 1 != v7) {
            *int v7 = *v38;
          }
          a4 = 0;
          uint64_t *v38 = v15;
          a3 = v98;
        }
        uint64_t v17 = *(void **)(v15 + 8);
        size_t v16 = *(void *)(v15 + 16);
LABEL_12:
        uint64_t v18 = 0;
        do
          uint64_t v19 = v9[++v18];
        while (sub_1CD506DA0(*(const void **)(v19 + 8), *(void *)(v19 + 16), v17, v16));
        uint64_t v20 = &v9[v18];
        if (v18 == 1)
        {
          unint64_t v8 = a2;
          do
          {
            if (v20 >= v8) {
              break;
            }
            uint64_t v29 = *--v8;
          }
          while (!sub_1CD506DA0(*(const void **)(v29 + 8), *(void *)(v29 + 16), v17, v16));
        }
        else
        {
          do
            uint64_t v21 = *--v8;
          while (!sub_1CD506DA0(*(const void **)(v21 + 8), *(void *)(v21 + 16), v17, v16));
        }
        if (v20 >= v8)
        {
          size_t v9 = (uint64_t *)((char *)v9 + v18 * 8);
        }
        else
        {
          uint64_t v22 = *v8;
          size_t v9 = (uint64_t *)((char *)v9 + v18 * 8);
          uint64_t v23 = v8;
          do
          {
            uint64_t *v9 = v22;
            *uint64_t v23 = v19;
            uint64_t v24 = *(void **)(v15 + 8);
            do
            {
              uint64_t v25 = v9[1];
              ++v9;
              uint64_t v19 = v25;
            }
            while (sub_1CD506DA0(*(const void **)(v25 + 8), *(void *)(v25 + 16), v24, v16));
            do
            {
              uint64_t v26 = *--v23;
              uint64_t v22 = v26;
            }
            while (!sub_1CD506DA0(*(const void **)(v26 + 8), *(void *)(v26 + 16), v24, v16));
          }
          while (v9 < v23);
        }
        int v27 = v9 - 1;
        if (v9 - 1 != v7) {
          *int v7 = *v27;
        }
        *int v27 = v15;
        BOOL v4 = v20 >= v8;
        a3 = v98;
        unint64_t v8 = a2;
        if (v4) {
          break;
        }
LABEL_30:
        BOOL result = sub_1CD08C38C(v7, v9 - 1, v98, a4 & 1);
        a4 = 0;
      }
      BOOL v28 = sub_1CD08CCC8(v7, v9 - 1);
      BOOL result = sub_1CD08CCC8(v9, a2);
      if (result) {
        break;
      }
      if (!v28) {
        goto LABEL_30;
      }
    }
    a2 = v9 - 1;
    if (!v28) {
      continue;
    }
    return result;
  }
}

BOOL sub_1CD08CBDC(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6 = *a2;
  uint64_t v7 = *a1;
  unint64_t v8 = *(void **)(*a2 + 8);
  size_t v9 = *(void *)(*a2 + 16);
  size_t v10 = *(void *)(*a1 + 16);
  BOOL v11 = sub_1CD506DA0(v8, v9, *(void **)(*a1 + 8), v10);
  uint64_t v12 = *a3;
  BOOL result = sub_1CD506DA0(*(const void **)(*a3 + 8), *(void *)(*a3 + 16), v8, v9);
  if (v11)
  {
    if (result)
    {
      *a1 = v12;
LABEL_4:
      *a3 = v7;
      return result;
    }
    *a1 = v6;
    *a2 = v7;
    uint64_t v14 = *a3;
    BOOL result = sub_1CD506DA0(*(const void **)(*a3 + 8), *(void *)(*a3 + 16), *(void **)(v7 + 8), v10);
    if (result)
    {
      *a2 = v14;
      goto LABEL_4;
    }
  }
  else if (result)
  {
    *a2 = v12;
    *a3 = v6;
    uint64_t v15 = *a2;
    uint64_t v16 = *a1;
    BOOL result = sub_1CD506DA0(*(const void **)(*a2 + 8), *(void *)(*a2 + 16), *(void **)(*a1 + 8), *(void *)(*a1 + 16));
    if (result)
    {
      *a1 = v15;
      *a2 = v16;
    }
  }
  return result;
}

BOOL sub_1CD08CCC8(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v17 = *(a2 - 1);
      uint64_t v18 = *a1;
      if (sub_1CD506DA0(*(const void **)(v17 + 8), *(void *)(v17 + 16), *(void **)(*a1 + 8), *(void *)(*a1 + 16)))
      {
        *a1 = v17;
        *(a2 - 1) = v18;
      }
      return 1;
    case 3:
      sub_1CD08CBDC(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      sub_1CD08CF08(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      uint64_t v19 = a1 + 2;
      uint64_t v20 = a1 + 3;
      sub_1CD08CF08(a1, a1 + 1, a1 + 2, a1 + 3);
      uint64_t v21 = *(a2 - 1);
      uint64_t v22 = a1[3];
      if (sub_1CD506DA0(*(const void **)(v21 + 8), *(void *)(v21 + 16), *(void **)(v22 + 8), *(void *)(v22 + 16)))
      {
        *uint64_t v20 = v21;
        *(a2 - 1) = v22;
        uint64_t v23 = *v20;
        uint64_t v24 = *v19;
        size_t v25 = *(void *)(*v20 + 16);
        if (sub_1CD506DA0(*(const void **)(*v20 + 8), v25, *(void **)(*v19 + 8), *(void *)(*v19 + 16)))
        {
          *uint64_t v19 = v23;
          *uint64_t v20 = v24;
          uint64_t v26 = a1[1];
          if (sub_1CD506DA0(*(const void **)(v23 + 8), v25, *(void **)(v26 + 8), *(void *)(v26 + 16)))
          {
            a1[1] = v23;
            a1[2] = v26;
            uint64_t v27 = *a1;
            if (sub_1CD506DA0(*(const void **)(v23 + 8), v25, *(void **)(*a1 + 8), *(void *)(*a1 + 16)))
            {
              *a1 = v23;
              a1[1] = v27;
            }
          }
        }
      }
      return 1;
    default:
      uint64_t v6 = a1 + 2;
      sub_1CD08CBDC(a1, a1 + 1, a1 + 2);
      uint64_t v7 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v8 = 0;
      uint64_t v9 = 24;
      break;
  }
  while (1)
  {
    uint64_t v10 = *v7;
    uint64_t v11 = *v6;
    size_t v12 = *(void *)(*v7 + 16);
    if (sub_1CD506DA0(*(const void **)(*v7 + 8), v12, *(void **)(v11 + 8), *(void *)(v11 + 16)))
    {
      uint64_t v13 = v9;
      while (1)
      {
        *(uint64_t *)((char *)a1 + v13) = v11;
        uint64_t v14 = v13 - 8;
        if (v13 == 8) {
          break;
        }
        uint64_t v11 = *(uint64_t *)((char *)a1 + v13 - 16);
        BOOL v15 = sub_1CD506DA0(*(const void **)(v10 + 8), v12, *(void **)(v11 + 8), *(void *)(v11 + 16));
        uint64_t v13 = v14;
        if (!v15)
        {
          uint64_t v16 = (uint64_t *)((char *)a1 + v14);
          goto LABEL_11;
        }
      }
      uint64_t v16 = a1;
LABEL_11:
      *uint64_t v16 = v10;
      if (++v8 == 8) {
        return v7 + 1 == a2;
      }
    }
    uint64_t v6 = v7;
    v9 += 8;
    BOOL result = 1;
    if (++v7 == a2) {
      return result;
    }
  }
}

BOOL sub_1CD08CF08(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  sub_1CD08CBDC(a1, a2, a3);
  uint64_t v8 = *a4;
  uint64_t v9 = *a3;
  BOOL result = sub_1CD506DA0(*(const void **)(*a4 + 8), *(void *)(*a4 + 16), *(void **)(*a3 + 8), *(void *)(*a3 + 16));
  if (result)
  {
    *a3 = v8;
    *a4 = v9;
    uint64_t v11 = *a3;
    uint64_t v12 = *a2;
    BOOL result = sub_1CD506DA0(*(const void **)(*a3 + 8), *(void *)(*a3 + 16), *(void **)(*a2 + 8), *(void *)(*a2 + 16));
    if (result)
    {
      *a2 = v11;
      *a3 = v12;
      uint64_t v13 = *a2;
      uint64_t v14 = *a1;
      BOOL result = sub_1CD506DA0(*(const void **)(*a2 + 8), *(void *)(*a2 + 16), *(void **)(*a1 + 8), *(void *)(*a1 + 16));
      if (result)
      {
        *a1 = v13;
        *a2 = v14;
      }
    }
  }
  return result;
}

void sub_1CD08CFAC(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 16);
  unint64_t v2 = *(void *)(a1 + 24);
  if (v2 > v1)
  {
    unint64_t v3 = v1 + 1;
    int v4 = 1;
    unint64_t v5 = v2 - v1;
    do
    {
      int v6 = *(unsigned __int8 *)(v3 - 1);
      if (v6 == 10) {
        ++v4;
      }
      ++v3;
      --v5;
    }
    while (v5);
  }
  operator new();
}

void *sub_1CD08D0A4(void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  llvm::raw_ostream *result = "[{0}:{1}, byte={2}]: {3}";
  result[1] = 24;
  result[12] = result + 4;
  result[2] = result + 12;
  result[3] = 4;
  result[4] = &unk_1F2607908;
  result[5] = a2;
  result[6] = &unk_1F2607908;
  result[7] = a3;
  result[8] = &unk_1F2607908;
  result[9] = a4;
  result[10] = &unk_1F2644D78;
  result[11] = a5;
  result[13] = result + 6;
  result[14] = result + 8;
  result[15] = result + 10;
  return result;
}

uint64_t sub_1CD08D150(uint64_t a1, std::string *this)
{
  unint64_t v5 = *(std::string::value_type **)(a1 + 24);
  int v4 = *(std::string::value_type **)(a1 + 32);
  if (v5 == v4)
  {
    LOBYTE(v6) = 0;
  }
  else
  {
    *(void *)(a1 + 24) = v5 + 1;
    int v6 = *v5;
    if (v6 == 34) {
      return 1;
    }
    ++v5;
  }
  uint64_t v8 = MEMORY[0x1E4F14390];
  while (2)
  {
    if (v5 == v4 || v6 <= 0x1Fu) {
      goto LABEL_74;
    }
    if (v6 != 92)
    {
      std::string::value_type v9 = v6;
LABEL_11:
      uint64_t v10 = this;
      break;
    }
    *(void *)(a1 + 24) = v5 + 1;
    int v11 = *v5;
    if (v11 <= 97)
    {
      if (v11 != 34 && v11 != 47 && v11 != 92) {
LABEL_74:
      }
        sub_1CD08CFAC(a1);
      std::string::value_type v9 = *v5;
      goto LABEL_11;
    }
    switch(*v5)
    {
      case 'n':
        uint64_t v10 = this;
        std::string::value_type v9 = 10;
        break;
      case 'o':
      case 'p':
      case 'q':
      case 's':
        goto LABEL_74;
      case 'r':
        uint64_t v10 = this;
        std::string::value_type v9 = 13;
        break;
      case 't':
        uint64_t v10 = this;
        std::string::value_type v9 = 9;
        break;
      case 'u':
        if (v5 + 1 == v4)
        {
          __s[0] = 0;
LABEL_37:
          __s[1] = 0;
LABEL_38:
          std::string::value_type v12 = 0;
          char v29 = 0;
          goto LABEL_39;
        }
        *(void *)(a1 + 24) = v5 + 2;
        __s[0] = v5[1];
        if (v5 + 2 == v4) {
          goto LABEL_37;
        }
        *(void *)(a1 + 24) = v5 + 3;
        __s[1] = v5[2];
        if (v5 + 3 == v4) {
          goto LABEL_38;
        }
        *(void *)(a1 + 24) = v5 + 4;
        char v29 = v5[3];
        if (v5 + 4 == v4)
        {
          std::string::value_type v12 = 0;
        }
        else
        {
          *(void *)(a1 + 24) = v5 + 5;
          std::string::value_type v12 = v5[4];
        }
LABEL_39:
        uint64_t v13 = 0;
        unsigned __int16 v14 = 0;
        std::string::value_type v30 = v12;
        do
        {
          uint64_t v15 = __s[v13];
          if ((*(_DWORD *)(v8 + 4 * v15 + 60) & 0x10000) == 0) {
            goto LABEL_74;
          }
          if (v15 <= 0x39) {
            __int16 v16 = v15 - 48;
          }
          else {
            __int16 v16 = (v15 & 0xFFDF) - 55;
          }
          unsigned __int16 v14 = v16 | (16 * v14);
          ++v13;
        }
        while (v13 != 4);
        unsigned int v17 = (unsigned __int16)(v14 + 0x2000) >> 11;
        while (2)
        {
          if (v17 < 0x1F)
          {
            unsigned int v27 = v14;
LABEL_70:
            sub_1CD08D584(v27, this);
            goto LABEL_13;
          }
          if ((unsigned __int16)(v14 >> 10) < 0x37u)
          {
            uint64_t v19 = *(unsigned char **)(a1 + 24);
            unint64_t v18 = *(void *)(a1 + 32);
            uint64_t v20 = v19 + 2;
            if ((unint64_t)(v19 + 2) <= v18 && *v19 == 92 && v19[1] == 117)
            {
              *(void *)(a1 + 24) = v20;
              if (v20 == (std::string::value_type *)v18)
              {
                std::string::value_type v21 = 0;
              }
              else
              {
                uint64_t v20 = v19 + 3;
                *(void *)(a1 + 24) = v19 + 3;
                std::string::value_type v21 = v19[2];
              }
              __s[0] = v21;
              if (v20 == (std::string::value_type *)v18)
              {
                __s[1] = 0;
              }
              else
              {
                *(void *)(a1 + 24) = v20 + 1;
                __s[1] = *v20;
                if (v20 + 1 != (std::string::value_type *)v18)
                {
                  *(void *)(a1 + 24) = v20 + 2;
                  char v29 = v20[1];
                  if (v20 + 2 == (std::string::value_type *)v18)
                  {
                    std::string::value_type v22 = 0;
                  }
                  else
                  {
                    *(void *)(a1 + 24) = v20 + 3;
                    std::string::value_type v22 = v20[2];
                  }
LABEL_60:
                  unsigned __int16 v23 = 0;
                  uint64_t v24 = 0;
                  std::string::value_type v30 = v22;
                  do
                  {
                    uint64_t v25 = __s[v24];
                    if ((*(_DWORD *)(v8 + 4 * v25 + 60) & 0x10000) == 0) {
                      goto LABEL_74;
                    }
                    if (v25 <= 0x39) {
                      __int16 v26 = v25 - 48;
                    }
                    else {
                      __int16 v26 = (v25 & 0xFFDF) - 55;
                    }
                    unsigned __int16 v23 = v26 | (16 * v23);
                    ++v24;
                  }
                  while (v24 != 4);
                  if ((unsigned __int16)((unsigned __int16)(v23 + 0x2000) >> 10) >= 0x3Fu)
                  {
                    unsigned int v27 = (v23 - 56320) | (((v14 << 10) | 0x10000) - 56623104);
                    goto LABEL_70;
                  }
                  *(_WORD *)__s = -16401;
                  char v29 = -67;
                  std::string::append(this, __s, 3uLL);
                  unsigned int v17 = (unsigned __int16)(v23 + 0x2000) >> 11;
                  unsigned __int16 v14 = v23;
                  continue;
                }
              }
              std::string::value_type v22 = 0;
              char v29 = 0;
              goto LABEL_60;
            }
          }
          break;
        }
        *(_WORD *)__s = -16401;
        char v29 = -67;
        std::string::append(this, __s, 3uLL);
LABEL_13:
        unint64_t v5 = *(std::string::value_type **)(a1 + 24);
        int v4 = *(std::string::value_type **)(a1 + 32);
        if (v5 == v4)
        {
          int v6 = 0;
        }
        else
        {
          *(void *)(a1 + 24) = v5 + 1;
          int v6 = *v5++;
        }
        if (v6 != 34) {
          continue;
        }
        return 1;
      default:
        if (v11 == 98)
        {
          uint64_t v10 = this;
          std::string::value_type v9 = 8;
          goto LABEL_12;
        }
        if (v11 != 102) {
          goto LABEL_74;
        }
        uint64_t v10 = this;
        std::string::value_type v9 = 12;
        break;
    }
    break;
  }
LABEL_12:
  std::string::push_back(v10, v9);
  goto LABEL_13;
}

void sub_1CD08D584(unsigned int a1, std::string *this)
{
  if (a1 > 0x7F)
  {
    if (a1 > 0x7FF)
    {
      if (HIWORD(a1))
      {
        unsigned int v6 = (a1 >> 12) & 0x3F | 0xFFFFFF80;
        unsigned int v7 = (a1 >> 6) & 0x3F | 0xFFFFFF80;
        char v8 = a1 & 0x3F | 0x80;
        std::string::push_back(this, (a1 >> 18) | 0xF0);
        std::string::push_back(this, v6);
        std::string::push_back(this, v7);
        LOBYTE(a1) = v8;
      }
      else
      {
        unsigned int v4 = (a1 >> 6) & 0x3F | 0xFFFFFF80;
        char v5 = a1 & 0x3F | 0x80;
        std::string::push_back(this, (a1 >> 12) | 0xE0);
        std::string::push_back(this, v4);
        LOBYTE(a1) = v5;
      }
    }
    else
    {
      char v3 = a1 & 0x3F | 0x80;
      std::string::push_back(this, (a1 >> 6) | 0xC0);
      LOBYTE(a1) = v3;
    }
  }

  std::string::push_back(this, a1);
}

unsigned __int16 *sub_1CD08D674(unsigned __int16 **a1)
{
  unint64_t v2 = *a1;
  unint64_t v1 = a1[1];
  uint64_t v3 = ((char *)v1 - (char *)*a1) >> 5;
  unint64_t v4 = v3 + 1;
  if ((unint64_t)(v3 + 1) >> 59) {
    abort();
  }
  uint64_t v6 = (char *)a1[2] - (char *)v2;
  if (v6 >> 4 > v4) {
    unint64_t v4 = v6 >> 4;
  }
  if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v7 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v7 = v4;
  }
  if (v7)
  {
    if (v7 >> 59) {
      sub_1CB833614();
    }
    char v8 = (char *)operator new(32 * v7);
  }
  else
  {
    char v8 = 0;
  }
  std::string::value_type v9 = (unsigned __int16 *)&v8[32 * v3];
  uint64_t v10 = (unsigned __int16 *)&v8[32 * v7];
  unsigned __int16 *v9 = 0;
  int v11 = v9 + 16;
  if (v1 == v2)
  {
    *a1 = v9;
    a1[1] = v11;
    a1[2] = v10;
  }
  else
  {
    do
    {
      v9 -= 16;
      v1 -= 16;
      llvm::json::Value::moveFrom((uint64_t)v9, v1);
    }
    while (v1 != v2);
    unint64_t v1 = *a1;
    std::string::value_type v12 = (llvm::json::Value *)a1[1];
    *a1 = v9;
    a1[1] = v11;
    a1[2] = v10;
    while (v12 != (llvm::json::Value *)v1)
    {
      std::string::value_type v12 = (llvm::json::Value *)((char *)v12 - 32);
      llvm::json::Value::destroy(v12);
    }
  }
  if (v1) {
    operator delete(v1);
  }
  return v11;
}

void *sub_1CD08D774(void *result, const llvm::json::Value *a2, const llvm::json::Value *a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >> 59) {
      abort();
    }
    unint64_t v7 = result;
    BOOL result = operator new(32 * a4);
    char v8 = (llvm::json::Value *)result;
    *unint64_t v7 = result;
    v7[1] = result;
    v7[2] = &result[4 * a4];
    while (a2 != a3)
    {
      BOOL result = (void *)llvm::json::Value::copyFrom(v8, a2);
      a2 = (const llvm::json::Value *)((char *)a2 + 32);
      char v8 = (llvm::json::Value *)((char *)v8 + 32);
    }
    v7[1] = v8;
  }
  return result;
}

uint64_t sub_1CD08D7FC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, unsigned int a4@<W3>, uint64_t a5@<X8>)
{
  unsigned int v8 = *(_DWORD *)(a1 + 8);
  unsigned int v31 = v8;
  if (v8 > 0x40) {
    operator new[]();
  }
  unint64_t v9 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v8;
  if (!v8) {
    unint64_t v9 = 0;
  }
  unint64_t v10 = v9 & ~*(void *)a1;
  unsigned int v11 = *(_DWORD *)(a2 + 8);
  unsigned int v31 = v11;
  if (v11 > 0x40) {
    operator new[]();
  }
  unint64_t v12 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v11;
  if (v11) {
    unint64_t v13 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v11;
  }
  else {
    unint64_t v13 = 0;
  }
  unint64_t v14 = (v13 & ~*(void *)a2) + v10;
  if (!v11) {
    unint64_t v12 = 0;
  }
  unsigned int v30 = v11;
  unint64_t v29 = v12 & v14;
  llvm::APInt::operator+=((uint64_t)&v29, a3 ^ 1u);
  unsigned int v15 = v30;
  unint64_t __src = v29;
  unsigned int v30 = 0;
  if (*(_DWORD *)(a1 + 24) > 0x40u) {
    operator new[]();
  }
  unsigned int v16 = *(_DWORD *)(a2 + 24);
  if (v16 >= 0x41) {
    operator new[]();
  }
  uint64_t v17 = *(void *)(a2 + 16) + *(void *)(a1 + 16);
  unint64_t v18 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v16;
  if (!v16) {
    unint64_t v18 = 0;
  }
  unsigned int v28 = *(_DWORD *)(a2 + 24);
  unint64_t v27 = v18 & v17;
  uint64_t result = llvm::APInt::operator+=((uint64_t)&v27, a4);
  unsigned int v20 = v28;
  unsigned int v28 = 0;
  if (v15 >= 0x41) {
    operator new[]();
  }
  unint64_t v21 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v15;
  if (!v15) {
    unint64_t v21 = 0;
  }
  unint64_t v22 = v27;
  if (v20 >= 0x41) {
    operator new[]();
  }
  if (*(_DWORD *)(a1 + 8) > 0x40u) {
    operator new[]();
  }
  if (*(_DWORD *)(a2 + 8) > 0x40u) {
    operator new[]();
  }
  unint64_t v23 = (*(void *)(a2 + 16) | *(void *)a2) & (*(void *)(a1 + 16) | *(void *)a1) & (*(void *)(a1 + 16) ^ *(void *)(a2 + 16) ^ v27 | v21 & (*(void *)a1 ^ *(void *)a2 ^ ~__src));
  unint64_t v24 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v15;
  if (!v15) {
    unint64_t v24 = 0;
  }
  *(void *)a5 = v24 & ~__src & v23;
  *(_DWORD *)(a5 + --*(_DWORD *)(this + 8) = v15;
  *(void *)(a5 + 16) = v23 & v22;
  *(_DWORD *)(a5 + 24) = v20;
  return result;
}

uint64_t llvm::KnownBits::computeForAddSub@<X0>(int a1@<W0>, int a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v9 = (uint64_t *)(a5 + 16);
  if (a1)
  {
    uint64_t v10 = a3;
    uint64_t v11 = a4;
    int v12 = 1;
    unsigned int v13 = 0;
  }
  else
  {
    int v28 = *(_DWORD *)(a4 + 8);
    uint64_t v29 = *(void *)a4;
    *(void *)a4 = *(void *)(a4 + 16);
    *(_DWORD *)(a4 + --*(_DWORD *)(this + 8) = *(_DWORD *)(a4 + 24);
    *(void *)(a4 + 16) = v29;
    *(_DWORD *)(a4 + 24) = v28;
    uint64_t v10 = a3;
    uint64_t v11 = a4;
    int v12 = 0;
    unsigned int v13 = 1;
  }
  uint64_t result = sub_1CD08D7FC(v10, v11, v12, v13, (uint64_t)&v43);
  uint64_t v15 = v43;
  unsigned int v16 = v44;
  uint64_t v17 = v45;
  unsigned int v18 = v46;
  *(void *)a5 = v43;
  *(_DWORD *)(a5 + --*(_DWORD *)(this + 8) = v16;
  *(void *)(a5 + 16) = v17;
  *(_DWORD *)(a5 + 24) = v18;
  unsigned int v19 = v18 - 1;
  if (v18 >= 0x41) {
    unint64_t v21 = (uint64_t *)(v17 + 8 * (v19 >> 6));
  }
  else {
    unint64_t v21 = v9;
  }
  uint64_t v22 = 1 << v19;
  if ((v22 & *v21) == 0)
  {
    unsigned int v23 = v16 - 1;
    uint64_t v25 = (void *)(v16 >= 0x41 ? v15 + 8 * (v23 >> 6) : a5);
    uint64_t v26 = 1 << v23;
    if ((*v25 & v26) == 0 && a2 != 0)
    {
      unsigned int v30 = *(_DWORD *)(a3 + 8);
      char v31 = v30 - 1;
      unsigned int v32 = (v30 - 1) >> 6;
      uint64_t result = *(void *)a3 + 8 * v32;
      if (v30 >= 0x41) {
        uint64_t v33 = (void *)(*(void *)a3 + 8 * v32);
      }
      else {
        uint64_t v33 = (void *)a3;
      }
      if (((*v33 >> v31) & 1) == 0) {
        goto LABEL_24;
      }
      uint64_t result = *(unsigned int *)(a4 + 8);
      unsigned int v34 = result - 1;
      int v35 = (void *)a4;
      if (result >= 0x41)
      {
        uint64_t result = v34 >> 6;
        int v35 = (void *)(*(void *)a4 + 8 * result);
      }
      if ((*v35 >> v34))
      {
        if (v16 > 0x40)
        {
          unint64_t v24 = (void *)(v15 + 8 * ((v16 - 1) >> 6));
          *v24 |= v26;
        }
        else
        {
          *(void *)a5 = v26 | v15;
        }
      }
      else
      {
LABEL_24:
        uint64_t v37 = *(void *)(a3 + 16);
        uint64_t v36 = a3 + 16;
        unsigned int v38 = *(_DWORD *)(v36 + 8);
        uint64_t v39 = (void *)(v37 + 8 * ((v38 - 1) >> 6));
        if (v38 < 0x41) {
          uint64_t v39 = (void *)v36;
        }
        if ((*v39 >> (v38 - 1)))
        {
          unint64_t v40 = (void *)(a4 + 16);
          unsigned int v41 = *(_DWORD *)(a4 + 24);
          unsigned int v42 = v41 - 1;
          if (v41 >= 0x41) {
            unint64_t v40 = (void *)(*v40 + 8 * (v42 >> 6));
          }
          if ((*v40 >> v42))
          {
            if (v18 > 0x40)
            {
              unsigned int v20 = (void *)(v17 + 8 * ((v18 - 1) >> 6));
              *v20 |= v22;
            }
            else
            {
              uint64_t *v9 = v22 | v17;
            }
          }
        }
      }
    }
  }
  return result;
}

unsigned int *llvm::KnownBits::sextInReg@<X0>(llvm::KnownBits *this@<X0>, int a2@<W1>, unsigned int *a3@<X8>)
{
  unsigned int v4 = *((_DWORD *)this + 2) - a2;
  if (v4)
  {
    a3[2] = 1;
    *(void *)a3 = 0;
    *((void *)a3 + 2) = 0;
    uint64_t result = a3 + 4;
    a3[6] = 1;
    unsigned int v6 = *((_DWORD *)this + 6);
    unsigned int v26 = v6;
    if (v6 > 0x40) {
      operator new[]();
    }
    uint64_t v7 = *((void *)this + 2) << v4;
    if (v6 == v4) {
      uint64_t v7 = 0;
    }
    if (v6) {
      unint64_t v8 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v6;
    }
    else {
      unint64_t v8 = 0;
    }
    *((void *)a3 + 2) = v8 & v7;
    a3[6] = v26;
    unsigned int v9 = *((_DWORD *)this + 2);
    unsigned int v27 = v9;
    if (v9 > 0x40) {
      operator new[]();
    }
    uint64_t v10 = *(void *)this << v4;
    if (v9 == v4) {
      uint64_t v10 = 0;
    }
    if (v9) {
      unint64_t v11 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v9;
    }
    else {
      unint64_t v11 = 0;
    }
    unint64_t v25 = v11 & v10;
    if (a3[2] >= 0x41 && *(void *)a3)
    {
      uint64_t v22 = a3 + 4;
      unsigned int v24 = v4;
      unint64_t v21 = a3;
      MEMORY[0x1D25D9CB0](*(void *)a3, 0x1000C8000313F17);
      uint64_t result = v22;
      unsigned int v4 = v24;
      a3 = v21;
    }
    *(void *)a3 = v25;
    unsigned int v12 = v27;
    a3[2] = v27;
    unsigned int v13 = a3[6];
    if (v13 > 0x40)
    {
      unsigned int v23 = v4;
      unsigned int v20 = a3;
      uint64_t result = llvm::APInt::ashrSlowCase(result, v4);
      unsigned int v4 = v23;
      a3 = v20;
      unsigned int v12 = v20[2];
    }
    else
    {
      if (v13 == v4) {
        char v14 = 63;
      }
      else {
        char v14 = v4;
      }
      uint64_t v15 = (uint64_t)(*(void *)result << -(char)v13) >> -(char)v13 >> v14;
      if (v13) {
        unint64_t v16 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v13;
      }
      else {
        unint64_t v16 = 0;
      }
      *(void *)uint64_t result = v16 & v15;
    }
    if (v12 > 0x40)
    {
      return llvm::APInt::ashrSlowCase(a3, v4);
    }
    else
    {
      if (v12 == v4) {
        char v17 = 63;
      }
      else {
        char v17 = v4;
      }
      uint64_t v18 = (uint64_t)(*(void *)a3 << -(char)v12) >> -(char)v12 >> v17;
      if (v12) {
        unint64_t v19 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v12;
      }
      else {
        unint64_t v19 = 0;
      }
      *(void *)a3 = v19 & v18;
    }
  }
  else
  {
    return (unsigned int *)sub_1CCF6FB70((uint64_t)a3, (uint64_t)this);
  }
  return result;
}

uint64_t llvm::KnownBits::makeGE@<X0>(llvm::KnownBits *this@<X0>, const llvm::APInt *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v5 = *((_DWORD *)this + 2);
  if (v5 >= 0x41) {
    operator new[]();
  }
  if (v5) {
    int v6 = __clz(~((*(void *)a2 | *(void *)this) << -(char)v5));
  }
  else {
    int v6 = 0;
  }
  unsigned int v7 = *((_DWORD *)a2 + 2);
  if (v7 > 0x40) {
    operator new[]();
  }
  uint64_t v8 = *(void *)a2;
  int v9 = *((_DWORD *)this + 2);
  int v19 = *((_DWORD *)a2 + 2);
  uint64_t v18 = 0;
  unsigned int v10 = v9 - v6 - v7;
  if (v10)
  {
    unsigned int v11 = v10 + v7;
    if (v10 + v7 > 0x3F) {
      llvm::APInt::setBitsSlowCase(&v18, v11, v7);
    }
    else {
      v18 |= 0xFFFFFFFFFFFFFFFFLL >> v10 << v11;
    }
  }
  uint64_t result = v18;
  uint64_t v13 = v18 & v8;
  unsigned int v14 = *((_DWORD *)this + 2);
  if (v14 > 0x40) {
    operator new[]();
  }
  uint64_t v15 = *(void *)this;
  unsigned int v16 = *((_DWORD *)this + 6);
  if (v16 > 0x40) {
    operator new[]();
  }
  uint64_t v17 = *((void *)this + 2) | v13;
  *(_DWORD *)(a3 + --*(_DWORD *)(this + 8) = v14;
  *(void *)a3 = v15;
  *(_DWORD *)(a3 + 24) = v16;
  *(void *)(a3 + 16) = v17;
  return result;
}

uint64_t llvm::KnownBits::umax@<X0>(llvm::KnownBits *this@<X0>, const llvm::KnownBits *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v4 = a2;
  if (*((_DWORD *)this + 6) > 0x40u) {
    operator new[]();
  }
  unint64_t v7 = *((void *)this + 2);
  unsigned int v8 = *((_DWORD *)a2 + 2);
  unsigned int v37 = v8;
  if (v8 > 0x40) {
    operator new[]();
  }
  unint64_t v9 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v8;
  if (!v8) {
    unint64_t v9 = 0;
  }
  unint64_t v10 = v9 & ~*(void *)a2;
  if (v7 < v10) {
    int v11 = -1;
  }
  else {
    int v11 = v7 > v10;
  }
  if (v11 < 0)
  {
    if (*((_DWORD *)a2 + 6) > 0x40u) {
      operator new[]();
    }
    unint64_t v12 = *((void *)a2 + 2);
    unsigned int v13 = *((_DWORD *)this + 2);
    unsigned int v37 = v13;
    if (v13 > 0x40) {
      operator new[]();
    }
    unint64_t v14 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v13;
    if (!v13) {
      unint64_t v14 = 0;
    }
    unint64_t v15 = v14 & ~*(void *)this;
    if (v12 < v15) {
      int v16 = -1;
    }
    else {
      int v16 = v12 > v15;
    }
    if (v16 < 0)
    {
      unsigned int v33 = *((_DWORD *)a2 + 6);
      if (v33 > 0x40) {
        operator new[]();
      }
      uint64_t v32 = *((void *)a2 + 2);
      llvm::KnownBits::makeGE(this, (const llvm::APInt *)&v32, (uint64_t)&__src);
      unsigned int v31 = *((_DWORD *)this + 6);
      if (v31 > 0x40) {
        operator new[]();
      }
      uint64_t v30 = *((void *)this + 2);
      llvm::KnownBits::makeGE(v4, (const llvm::APInt *)&v30, (uint64_t)&v32);
      unsigned int v17 = v37;
      if (v37 > 0x40) {
        operator new[]();
      }
      uint64_t v18 = __src;
      uint64_t v19 = v32;
      unint64_t v20 = v32 & (unint64_t)__src;
      unsigned int v21 = v39;
      if (v39 > 0x40) {
        operator new[]();
      }
      uint64_t v22 = v38;
      uint64_t result = v34;
      unint64_t v24 = v34 & (unint64_t)v38;
      *(_DWORD *)(a3 + --*(_DWORD *)(this + 8) = v37;
      *(void *)a3 = v20;
      *(_DWORD *)(a3 + 24) = v21;
      *(void *)(a3 + 16) = v24;
      if (v35 >= 0x41 && result != 0)
      {
        unsigned int v27 = v22;
        uint64_t result = MEMORY[0x1D25D9CB0]();
        uint64_t v22 = v27;
      }
      if (v33 >= 0x41 && v19 != 0)
      {
        int v28 = v22;
        uint64_t result = MEMORY[0x1D25D9CB0](v19, 0x1000C8000313F17);
        uint64_t v22 = v28;
      }
      if (v21 >= 0x41 && v22) {
        uint64_t result = MEMORY[0x1D25D9CB0](v22, 0x1000C8000313F17);
      }
      if (v17 >= 0x41 && v18)
      {
        JUMPOUT(0x1D25D9CB0);
      }
      return result;
    }
    uint64_t v29 = a3;
  }
  else
  {
    uint64_t v29 = a3;
    a2 = this;
  }

  return sub_1CCF6FB70(v29, (uint64_t)a2);
}

uint64_t llvm::KnownBits::umin@<X0>(llvm::KnownBits *this@<X0>, const llvm::KnownBits *a2@<X1>, uint64_t a3@<X8>)
{
  if (*((_DWORD *)this + 6) > 0x40u) {
    operator new[]();
  }
  uint64_t v5 = *((void *)this + 2);
  unsigned int v6 = *((_DWORD *)this + 2);
  if (v6 >= 0x41) {
    operator new[]();
  }
  uint64_t v7 = *(void *)this;
  unsigned int v20 = *((_DWORD *)this + 6);
  uint64_t v19 = v5;
  unsigned int v22 = v6;
  uint64_t v21 = v7;
  if (*((_DWORD *)a2 + 6) > 0x40u) {
    operator new[]();
  }
  uint64_t v8 = *((void *)a2 + 2);
  unsigned int v9 = *((_DWORD *)a2 + 2);
  if (v9 >= 0x41) {
    operator new[]();
  }
  uint64_t v10 = *(void *)a2;
  unsigned int v16 = *((_DWORD *)a2 + 6);
  uint64_t v15 = v8;
  unsigned int v18 = v9;
  uint64_t v17 = v10;
  uint64_t result = llvm::KnownBits::umax((llvm::KnownBits *)&v19, (const llvm::KnownBits *)&v15, (uint64_t)&v23);
  if (v26 > 0x40) {
    operator new[]();
  }
  unint64_t v12 = __src;
  unsigned int v13 = v24;
  if (v24 >= 0x41) {
    operator new[]();
  }
  unint64_t v14 = v23;
  *(_DWORD *)(a3 + --*(_DWORD *)(this + 8) = v26;
  *(void *)a3 = v12;
  *(_DWORD *)(a3 + 24) = v13;
  *(void *)(a3 + 16) = v14;
  if (v26 >= 0x41)
  {
    uint64_t result = (uint64_t)__src;
    if (__src) {
      uint64_t result = MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
    }
  }
  if (v24 >= 0x41)
  {
    uint64_t result = (uint64_t)v23;
    if (v23) {
      uint64_t result = MEMORY[0x1D25D9CB0](v23, 0x1000C8000313F17);
    }
  }
  if (v18 >= 0x41)
  {
    uint64_t result = v17;
    if (v17) {
      uint64_t result = MEMORY[0x1D25D9CB0](v17, 0x1000C8000313F17);
    }
  }
  if (v16 >= 0x41)
  {
    uint64_t result = v15;
    if (v15) {
      uint64_t result = MEMORY[0x1D25D9CB0](v15, 0x1000C8000313F17);
    }
  }
  if (v22 >= 0x41)
  {
    uint64_t result = v21;
    if (v21) {
      uint64_t result = MEMORY[0x1D25D9CB0](v21, 0x1000C8000313F17);
    }
  }
  if (v20 >= 0x41)
  {
    uint64_t result = v19;
    if (v19) {
      return MEMORY[0x1D25D9CB0](v19, 0x1000C8000313F17);
    }
  }
  return result;
}

uint64_t *llvm::KnownBits::smax@<X0>(llvm::KnownBits *this@<X0>, const llvm::KnownBits *a2@<X1>, uint64_t a3@<X8>)
{
  sub_1CD08F3A4((uint64_t *)this, (uint64_t)&v11);
  sub_1CD08F3A4((uint64_t *)a2, (uint64_t)&v7);
  llvm::KnownBits::umax((llvm::KnownBits *)&v11, (const llvm::KnownBits *)&v7, (uint64_t)&v15);
  uint64_t result = sub_1CD08F3A4((uint64_t *)&v15, a3);
  if (v18 >= 0x41)
  {
    uint64_t result = v17;
    if (v17) {
      uint64_t result = (uint64_t *)MEMORY[0x1D25D9CB0](v17, 0x1000C8000313F17);
    }
  }
  if (v16 >= 0x41)
  {
    uint64_t result = v15;
    if (v15) {
      uint64_t result = (uint64_t *)MEMORY[0x1D25D9CB0](v15, 0x1000C8000313F17);
    }
  }
  if (v10 >= 0x41)
  {
    uint64_t result = v9;
    if (v9) {
      uint64_t result = (uint64_t *)MEMORY[0x1D25D9CB0](v9, 0x1000C8000313F17);
    }
  }
  if (v8 >= 0x41)
  {
    uint64_t result = v7;
    if (v7) {
      uint64_t result = (uint64_t *)MEMORY[0x1D25D9CB0](v7, 0x1000C8000313F17);
    }
  }
  if (v14 >= 0x41)
  {
    uint64_t result = v13;
    if (v13) {
      uint64_t result = (uint64_t *)MEMORY[0x1D25D9CB0](v13, 0x1000C8000313F17);
    }
  }
  if (v12 >= 0x41)
  {
    uint64_t result = v11;
    if (v11) {
      return (uint64_t *)MEMORY[0x1D25D9CB0](v11, 0x1000C8000313F17);
    }
  }
  return result;
}

uint64_t *sub_1CD08F3A4@<X0>(uint64_t *result@<X0>, uint64_t a2@<X8>)
{
  unsigned int v2 = *((_DWORD *)result + 2);
  unsigned int v3 = v2 - 1;
  if (v2 > 0x40) {
    operator new[]();
  }
  uint64_t v4 = *result;
  uint64_t v5 = result + 2;
  unsigned int v6 = *((_DWORD *)result + 6);
  if (v6 > 0x40) {
    operator new[]();
  }
  uint64_t v7 = *v5;
  uint64_t v8 = 1 << v3;
  if ((*v5 & (1 << v3)) != 0) {
    uint64_t v9 = v4 | v8;
  }
  else {
    uint64_t v9 = v4 & ~v8;
  }
  if (*((_DWORD *)result + 2) >= 0x41u) {
    unsigned int v10 = (void *)(*result + 8 * (v3 >> 6));
  }
  else {
    unsigned int v10 = result;
  }
  if ((*v10 & v8) != 0) {
    uint64_t v11 = v7 | v8;
  }
  else {
    uint64_t v11 = v7 & ~v8;
  }
  *(_DWORD *)(a2 + --*(_DWORD *)(this + 8) = v2;
  *(void *)a2 = v9;
  *(_DWORD *)(a2 + 24) = v6;
  *(void *)(a2 + 16) = v11;
  return result;
}

uint64_t *llvm::KnownBits::smin@<X0>(llvm::KnownBits *this@<X0>, const llvm::KnownBits *a2@<X1>, uint64_t a3@<X8>)
{
  sub_1CD08F7B4((uint64_t *)this, (uint64_t)&v11);
  sub_1CD08F7B4((uint64_t *)a2, (uint64_t)&v7);
  llvm::KnownBits::umax((llvm::KnownBits *)&v11, (const llvm::KnownBits *)&v7, (uint64_t)&v15);
  uint64_t result = sub_1CD08F7B4((uint64_t *)&v15, a3);
  if (v18 >= 0x41)
  {
    uint64_t result = v17;
    if (v17) {
      uint64_t result = (uint64_t *)MEMORY[0x1D25D9CB0](v17, 0x1000C8000313F17);
    }
  }
  if (v16 >= 0x41)
  {
    uint64_t result = v15;
    if (v15) {
      uint64_t result = (uint64_t *)MEMORY[0x1D25D9CB0](v15, 0x1000C8000313F17);
    }
  }
  if (v10 >= 0x41)
  {
    uint64_t result = v9;
    if (v9) {
      uint64_t result = (uint64_t *)MEMORY[0x1D25D9CB0](v9, 0x1000C8000313F17);
    }
  }
  if (v8 >= 0x41)
  {
    uint64_t result = v7;
    if (v7) {
      uint64_t result = (uint64_t *)MEMORY[0x1D25D9CB0](v7, 0x1000C8000313F17);
    }
  }
  if (v14 >= 0x41)
  {
    uint64_t result = v13;
    if (v13) {
      uint64_t result = (uint64_t *)MEMORY[0x1D25D9CB0](v13, 0x1000C8000313F17);
    }
  }
  if (v12 >= 0x41)
  {
    uint64_t result = v11;
    if (v11) {
      return (uint64_t *)MEMORY[0x1D25D9CB0](v11, 0x1000C8000313F17);
    }
  }
  return result;
}

uint64_t *sub_1CD08F7B4@<X0>(uint64_t *result@<X0>, uint64_t a2@<X8>)
{
  unsigned int v2 = *((_DWORD *)result + 2);
  unsigned int v3 = v2 - 1;
  unsigned int v4 = *((_DWORD *)result + 6);
  if (v4 > 0x40) {
    operator new[]();
  }
  uint64_t v5 = result[2];
  if (v2 > 0x40) {
    operator new[]();
  }
  uint64_t v6 = *result;
  uint64_t v7 = 1 << v3;
  if ((*result & (1 << v3)) != 0) {
    uint64_t v8 = v5 | v7;
  }
  else {
    uint64_t v8 = v5 & ~v7;
  }
  if (*((_DWORD *)result + 6) >= 0x41u) {
    uint64_t v9 = (void *)(result[2] + 8 * (v3 >> 6));
  }
  else {
    uint64_t v9 = result + 2;
  }
  if ((*v9 & v7) != 0) {
    uint64_t v10 = v6 | v7;
  }
  else {
    uint64_t v10 = v6 & ~v7;
  }
  *(_DWORD *)(a2 + --*(_DWORD *)(this + 8) = v4;
  *(void *)a2 = v8;
  *(_DWORD *)(a2 + 24) = v2;
  *(void *)(a2 + 16) = v10;
  return result;
}

void llvm::KnownBits::shl(llvm::KnownBits *this@<X0>, int8x8_t *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v7 = *((unsigned int *)this + 2);
  *(_DWORD *)(a3 + --*(_DWORD *)(this + 8) = v7;
  if (v7 > 0x40) {
    operator new[]();
  }
  *(void *)a3 = 0;
  *(_DWORD *)(a3 + 24) = v7;
  *(void *)(a3 + 16) = 0;
  uint64_t v8 = a2[1].u32[0];
  if (v8 > 0x40)
  {
    __int32 v10 = 0;
    unint64_t v25 = (unint64_t)(v8 + 63) >> 6;
    unsigned int v26 = (int8x8_t *)*a2;
    do
    {
      int8x8_t v27 = *v26++;
      uint8x8_t v28 = (uint8x8_t)vcnt_s8(v27);
      v28.i16[0] = vaddlv_u8(v28);
      v10 += v28.i32[0];
      --v25;
    }
    while (v25);
  }
  else
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8(*a2);
    v9.i16[0] = vaddlv_u8(v9);
    __int32 v10 = v9.i32[0];
  }
  uint64_t v11 = (void **)(a3 + 16);
  unsigned int v12 = a2 + 2;
  uint64_t v13 = a2[3].u32[0];
  if (v13 > 0x40)
  {
    int v29 = 0;
    int64_t v30 = (unint64_t)(v13 + 63) >> 6;
    unsigned int v31 = (int8x8_t *)*v12;
    int64_t v32 = v30;
    do
    {
      int8x8_t v33 = *v31++;
      uint8x8_t v34 = (uint8x8_t)vcnt_s8(v33);
      v34.i16[0] = vaddlv_u8(v34);
      v29 += v34.i32[0];
      --v32;
    }
    while (v32);
    if (v29 + v10 != v8) {
      goto LABEL_47;
    }
    int v35 = 0;
    uint64_t v36 = (unint64_t *)*v12;
    do
    {
      if (v30-- < 1) {
        break;
      }
      unint64_t v38 = v36[v30];
      v35 += __clz(v38);
    }
    while (!v38);
    int v39 = v13 | 0xFFFFFFC0;
    if ((v13 & 0x3F) == 0) {
      int v39 = 0;
    }
    if ((v13 - v35 - v39) > 0x40) {
      goto LABEL_47;
    }
    unint64_t v14 = *v36;
  }
  else
  {
    unint64_t v14 = (unint64_t)*v12;
    uint8x8_t v15 = (uint8x8_t)vcnt_s8(*v12);
    v15.i16[0] = vaddlv_u8(v15);
    if (v10 + v15.i32[0] != v8) {
      goto LABEL_47;
    }
  }
  if (v14 < v7)
  {
    unsigned int v16 = *((_DWORD *)this + 2);
    if (v16 > 0x40)
    {
      if ((llvm::KnownBits *)a3 != this)
      {
        llvm::APInt::reallocate(a3, *((_DWORD *)this + 2));
        uint64_t v74 = *(unsigned int *)(a3 + 8);
        if (v74 <= 0x40) {
          *(void *)a3 = *(void *)this;
        }
        else {
          memcpy(*(void **)a3, *(const void **)this, ((unint64_t)(v74 + 63) >> 3) & 0x3FFFFFF8);
        }
      }
    }
    else
    {
      *(void *)a3 = *(void *)this;
      *(_DWORD *)(a3 + --*(_DWORD *)(this + 8) = v16;
    }
    if (*(_DWORD *)(a3 + 24) > 0x40u || (unsigned int v17 = *((_DWORD *)this + 6), v17 > 0x40))
    {
      if ((llvm::KnownBits *)a3 != this)
      {
        llvm::APInt::reallocate(a3 + 16, *((_DWORD *)this + 6));
        uint64_t v75 = *(unsigned int *)(a3 + 24);
        if (v75 <= 0x40) {
          *uint64_t v11 = (void *)*((void *)this + 2);
        }
        else {
          memcpy(*v11, *((const void **)this + 2), ((unint64_t)(v75 + 63) >> 3) & 0x3FFFFFF8);
        }
      }
    }
    else
    {
      *(void *)(a3 + 16) = *((void *)this + 2);
      *(_DWORD *)(a3 + 24) = v17;
    }
    unsigned int v18 = *(_DWORD *)(a3 + 8);
    if (v18 > 0x40)
    {
      llvm::APInt::shlSlowCase((llvm::APInt *)a3, v14);
    }
    else
    {
      uint64_t v19 = *(void *)a3 << v14;
      if (!v18 || v18 == v14)
      {
        if (v18 == v14) {
          uint64_t v19 = 0;
        }
        if (v18) {
          unint64_t v20 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v18;
        }
        else {
          unint64_t v20 = 0;
        }
      }
      else
      {
        unint64_t v20 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v18;
      }
      *(void *)a3 = v20 & v19;
    }
    unsigned int v21 = *(_DWORD *)(a3 + 24);
    if (v21 > 0x40)
    {
      llvm::APInt::shlSlowCase((llvm::APInt *)(a3 + 16), v14);
    }
    else
    {
      uint64_t v22 = (void)*v11 << v14;
      if (!v21 || v21 == v14)
      {
        if (v21 == v14) {
          uint64_t v22 = 0;
        }
        if (v21) {
          unint64_t v23 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v21;
        }
        else {
          unint64_t v23 = 0;
        }
      }
      else
      {
        unint64_t v23 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v21;
      }
      *uint64_t v11 = (void *)(v23 & v22);
    }
    if (v14)
    {
      if (v14 > 0x40)
      {
        llvm::APInt::setBitsSlowCase((void *)a3, 0, v14);
      }
      else
      {
        unint64_t v24 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v14;
        if (*(_DWORD *)(a3 + 8) > 0x40u) {
          **(void **)a3 |= v24;
        }
        else {
          *(void *)a3 |= v24;
        }
      }
    }
    return;
  }
LABEL_47:
  if (*((_DWORD *)this + 2) > 0x40u) {
    unsigned int v40 = llvm::APInt::countTrailingOnesSlowCase(this);
  }
  else {
    unsigned int v40 = __clz(__rbit64(~*(void *)this));
  }
  unsigned int v95 = v13;
  if (v13 > 0x40) {
    operator new[]();
  }
  int8x8_t v94 = *v12;
  int8x8_t v41 = v94;
  if (*(void *)&v94 < v7)
  {
    if (v7 >= v40 + v94.i32[0]) {
      v40 += v94.i32[0];
    }
    else {
      unsigned int v40 = v7;
    }
  }
  unsigned int v42 = a2[1].u32[0];
  unsigned int v96 = v42;
  if (v42 > 0x40) {
    operator new[]();
  }
  unint64_t v43 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v42;
  if (!v42) {
    unint64_t v43 = 0;
  }
  unint64_t v44 = v43 & ~*(void *)a2;
  unsigned int v93 = v42;
  size_t v92 = (unint64_t *)v44;
  if (v44 >= v7) {
    goto LABEL_58;
  }
  unsigned int v47 = *((_DWORD *)this + 2);
  if (v47 > 0x40)
  {
    unint64_t v87 = v44;
    unsigned int v90 = v40;
    int v82 = llvm::APInt::countLeadingZerosSlowCase(this);
    unint64_t v44 = v87;
    int8x8_t v41 = v94;
    unsigned int v40 = v90;
    if (v82 != v47) {
      goto LABEL_74;
    }
  }
  else if (*(void *)this)
  {
    goto LABEL_74;
  }
  unsigned int v48 = *((_DWORD *)this + 6);
  if (v48 > 0x40)
  {
    unint64_t v88 = v44;
    int8x8_t v89 = v41;
    unsigned int v91 = v40;
    int v86 = llvm::APInt::countLeadingZerosSlowCase((llvm::KnownBits *)((char *)this + 16));
    unint64_t v44 = v88;
    int8x8_t v41 = v89;
    unsigned int v40 = v91;
    if (v86 == v48) {
      goto LABEL_58;
    }
LABEL_74:
    unsigned int v49 = a2[1].u32[0];
    if (v49 > 0x40) {
      operator new[]();
    }
    if (v49) {
      unint64_t v50 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v49;
    }
    else {
      unint64_t v50 = 0;
    }
    unint64_t v51 = v50 & ~*(void *)a2;
    unsigned int v52 = a2[3].u32[0];
    if (v52 <= 0x40 && v7)
    {
      int8x8_t v53 = *v12;
      *(void *)a3 = -1;
      unint64_t v54 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v7;
      uint64_t v55 = (void *)a3;
    }
    else
    {
      if (v52 >= 0x41) {
        uint64_t v84 = (int8x8_t *)*v12;
      }
      else {
        uint64_t v84 = v12;
      }
      int8x8_t v85 = *v84;
      *(void *)a3 = -1;
      unint64_t v54 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v7;
      if (!v7) {
        unint64_t v54 = 0;
      }
      uint64_t v55 = (void *)a3;
      int8x8_t v53 = v85;
    }
    *uint64_t v55 = v54;
    uint64_t v56 = *(unsigned int *)(a3 + 24);
    if (v56 > 0x40)
    {
      unsigned int v78 = (char *)*v11;
      unsigned int v79 = v40;
      unint64_t v80 = v51;
      int8x8_t v81 = v53;
      memset(*v11, 255, ((unint64_t)(v56 + 63) >> 3) & 0x3FFFFFF8);
      int8x8_t v53 = v81;
      unint64_t v51 = v80;
      unsigned int v40 = v79;
      unint64_t v58 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v56;
      uint64_t v59 = (uint64_t *)&v78[8 * ((unint64_t)(v56 + 63) >> 6) - 8];
      uint64_t v57 = *v59;
    }
    else
    {
      uint64_t v57 = -1;
      *uint64_t v11 = (void *)-1;
      unint64_t v58 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v56;
      if (!v56) {
        unint64_t v58 = 0;
      }
      uint64_t v59 = (uint64_t *)(a3 + 16);
    }
    *uint64_t v59 = v57 & v58;
    int8x8_t v41 = v94;
    int8x8_t v60 = v94;
    unint64_t v44 = (unint64_t)v92;
    uint64_t v61 = (unint64_t *)&v92;
    if (v93 >= 0x41) {
      uint64_t v61 = v92;
    }
    unint64_t v62 = *v61;
    if (*(void *)&v94 <= *v61)
    {
      do
      {
        while ((*(void *)&v60 & ~v51) != 0 || (*(void *)&v60 | *(void *)&v53) != *(void *)&v60)
        {
          if (++*(void *)&v60 > v62) {
            goto LABEL_58;
          }
        }
        unsigned int v63 = *((_DWORD *)this + 2);
        unsigned int v96 = v63;
        if (v63 > 0x40) {
          operator new[]();
        }
        uint64_t v64 = *(void *)this << v60.i8[0];
        if (!v63 || v63 == v60.i32[0])
        {
          if (v63 == v60.i32[0]) {
            uint64_t v64 = 0;
          }
          unint64_t v65 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v63;
          if (!v63) {
            unint64_t v65 = 0;
          }
        }
        else
        {
          unint64_t v65 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v63;
        }
        unint64_t v66 = v65 & v64;
        unsigned int v67 = *((_DWORD *)this + 6);
        unsigned int v96 = v67;
        if (v67 > 0x40) {
          operator new[]();
        }
        uint64_t v68 = *((void *)this + 2) << v60.i8[0];
        if (!v67 || v67 == v60.i32[0])
        {
          if (v67 == v60.i32[0]) {
            uint64_t v68 = 0;
          }
          unint64_t v69 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v67;
          if (!v67) {
            unint64_t v69 = 0;
          }
        }
        else
        {
          unint64_t v69 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v67;
        }
        unsigned int v70 = *(_DWORD *)(a3 + 8);
        if (v70 > 0x40) {
          operator new[]();
        }
        unint64_t v71 = *(void *)a3 & v66;
        if (v56 > 0x40) {
          operator new[]();
        }
        unint64_t v72 = (unint64_t)*v11 & v69 & v68;
        *(void *)a3 = v71;
        *(_DWORD *)(a3 + --*(_DWORD *)(this + 8) = v70;
        *(void *)(a3 + 16) = v72;
        *(_DWORD *)(a3 + 24) = v56;
        if (v71) {
          BOOL v73 = 0;
        }
        else {
          BOOL v73 = v72 == 0;
        }
        if (++*(void *)&v60 > v62) {
          BOOL v73 = 1;
        }
      }
      while (!v73);
    }
    goto LABEL_58;
  }
  if (*((void *)this + 2)) {
    goto LABEL_74;
  }
LABEL_58:
  if (v40)
  {
    if (v40 > 0x40)
    {
      int8x8_t v76 = v41;
      unint64_t v77 = v44;
      llvm::APInt::setBitsSlowCase((void *)a3, 0, v40);
      unint64_t v44 = v77;
      int8x8_t v41 = v76;
    }
    else
    {
      unint64_t v45 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v40;
      if (*(_DWORD *)(a3 + 8) > 0x40u) {
        **(void **)a3 |= v45;
      }
      else {
        *(void *)a3 |= v45;
      }
    }
  }
  if (v93 >= 0x41 && v44 != 0)
  {
    int8x8_t v83 = v41;
    MEMORY[0x1D25D9CB0](v44, 0x1000C8000313F17);
    int8x8_t v41 = v83;
  }
  if (v95 >= 0x41 && *(void *)&v41) {
    MEMORY[0x1D25D9CB0](*(void *)&v41, 0x1000C8000313F17);
  }
}

void llvm::KnownBits::lshr(llvm::KnownBits *this@<X0>, int8x8_t *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v7 = *((unsigned int *)this + 2);
  *(_DWORD *)(a3 + --*(_DWORD *)(this + 8) = v7;
  if (v7 > 0x40) {
    operator new[]();
  }
  *(void *)a3 = 0;
  *(_DWORD *)(a3 + 24) = v7;
  *(void *)(a3 + 16) = 0;
  uint64_t v8 = a2[1].u32[0];
  if (v8 > 0x40)
  {
    __int32 v10 = 0;
    unint64_t v22 = (unint64_t)(v8 + 63) >> 6;
    unint64_t v23 = (int8x8_t *)*a2;
    do
    {
      int8x8_t v24 = *v23++;
      uint8x8_t v25 = (uint8x8_t)vcnt_s8(v24);
      v25.i16[0] = vaddlv_u8(v25);
      v10 += v25.i32[0];
      --v22;
    }
    while (v22);
  }
  else
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8(*a2);
    v9.i16[0] = vaddlv_u8(v9);
    __int32 v10 = v9.i32[0];
  }
  uint64_t v11 = (void **)(a3 + 16);
  unsigned int v12 = a2 + 2;
  uint64_t v13 = a2[3].u32[0];
  if (v13 > 0x40)
  {
    int v26 = 0;
    int64_t v27 = (unint64_t)(v13 + 63) >> 6;
    uint8x8_t v28 = (int8x8_t *)*v12;
    int64_t v29 = v27;
    do
    {
      int8x8_t v30 = *v28++;
      uint8x8_t v31 = (uint8x8_t)vcnt_s8(v30);
      v31.i16[0] = vaddlv_u8(v31);
      v26 += v31.i32[0];
      --v29;
    }
    while (v29);
    if (v26 + v10 != v8) {
      goto LABEL_42;
    }
    int v32 = 0;
    int8x8_t v33 = (unint64_t *)*v12;
    do
    {
      if (v27-- < 1) {
        break;
      }
      unint64_t v35 = v33[v27];
      v32 += __clz(v35);
    }
    while (!v35);
    int v36 = v13 | 0xFFFFFFC0;
    if ((v13 & 0x3F) == 0) {
      int v36 = 0;
    }
    if ((v13 - v32 - v36) > 0x40) {
      goto LABEL_42;
    }
    unint64_t v14 = *v33;
  }
  else
  {
    unint64_t v14 = (unint64_t)*v12;
    uint8x8_t v15 = (uint8x8_t)vcnt_s8(*v12);
    v15.i16[0] = vaddlv_u8(v15);
    if (v10 + v15.i32[0] != v8) {
      goto LABEL_42;
    }
  }
  if (v14 < v7)
  {
    unsigned int v16 = *((_DWORD *)this + 2);
    if (v16 > 0x40)
    {
      if ((llvm::KnownBits *)a3 != this)
      {
        llvm::APInt::reallocate(a3, *((_DWORD *)this + 2));
        uint64_t v66 = *(unsigned int *)(a3 + 8);
        if (v66 <= 0x40) {
          *(void *)a3 = *(void *)this;
        }
        else {
          memcpy(*(void **)a3, *(const void **)this, ((unint64_t)(v66 + 63) >> 3) & 0x3FFFFFF8);
        }
      }
    }
    else
    {
      *(void *)a3 = *(void *)this;
      *(_DWORD *)(a3 + --*(_DWORD *)(this + 8) = v16;
    }
    if (*(_DWORD *)(a3 + 24) > 0x40u || (unsigned int v17 = *((_DWORD *)this + 6), v17 > 0x40))
    {
      if ((llvm::KnownBits *)a3 != this)
      {
        llvm::APInt::reallocate(a3 + 16, *((_DWORD *)this + 6));
        uint64_t v67 = *(unsigned int *)(a3 + 24);
        if (v67 <= 0x40) {
          *uint64_t v11 = (void *)*((void *)this + 2);
        }
        else {
          memcpy(*v11, *((const void **)this + 2), ((unint64_t)(v67 + 63) >> 3) & 0x3FFFFFF8);
        }
      }
    }
    else
    {
      *(void *)(a3 + 16) = *((void *)this + 2);
      *(_DWORD *)(a3 + 24) = v17;
    }
    unsigned int v18 = *(_DWORD *)(a3 + 8);
    if (v18 > 0x40)
    {
      llvm::APInt::lshrSlowCase((void **)a3, v14);
    }
    else if (v18 == v14)
    {
      *(void *)a3 = 0;
    }
    else
    {
      *(void *)a3 >>= v14;
    }
    unsigned int v19 = *(_DWORD *)(a3 + 24);
    if (v19 > 0x40)
    {
      llvm::APInt::lshrSlowCase((void **)(a3 + 16), v14);
    }
    else if (v19 == v14)
    {
      *uint64_t v11 = 0;
    }
    else
    {
      *uint64_t v11 = (void *)((unint64_t)*v11 >> v14);
    }
    if (v14)
    {
      unsigned int v20 = *(_DWORD *)(a3 + 8);
      unsigned int v21 = v20 - v14;
      if (v20 <= 0x40 && v21 <= 0x3F)
      {
        *(void *)a3 |= 0xFFFFFFFFFFFFFFFFLL >> -(char)v14 << v21;
        return;
      }
LABEL_26:
      llvm::APInt::setBitsSlowCase((void *)a3, v21, v20);
      return;
    }
    return;
  }
LABEL_42:
  unsigned int v37 = *((_DWORD *)this + 2);
  if (v37 > 0x40)
  {
    unsigned int v73 = llvm::APInt::countLeadingOnesSlowCase(this);
    unsigned int v12 = a2 + 2;
    unsigned int v37 = v73;
  }
  else if (v37)
  {
    unsigned int v37 = __clz(~(*(void *)this << -(char)v37));
  }
  if (v13 > 0x40) {
    operator new[]();
  }
  int8x8_t v38 = *v12;
  unsigned int v39 = v37 + *(void *)v12;
  if (v7 < v39) {
    unsigned int v39 = v7;
  }
  if (*(void *)v12 < v7) {
    unsigned int v37 = v39;
  }
  unsigned int v40 = a2[1].u32[0];
  if (v40 > 0x40) {
    operator new[]();
  }
  unint64_t v41 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v40;
  if (!v40) {
    unint64_t v41 = 0;
  }
  unint64_t v42 = v41 & ~*(void *)a2;
  if (v42 >= v7) {
    goto LABEL_54;
  }
  unsigned int v43 = *((_DWORD *)this + 2);
  if (v43 > 0x40)
  {
    int8x8_t v86 = *v12;
    unsigned int v89 = v37;
    unint64_t v83 = v41 & ~*(void *)a2;
    uint64_t v74 = v12;
    int v75 = llvm::APInt::countLeadingZerosSlowCase(this);
    unsigned int v12 = v74;
    int v76 = v75;
    unint64_t v42 = v83;
    int8x8_t v38 = v86;
    unsigned int v37 = v89;
    if (v76 == v43)
    {
LABEL_61:
      unsigned int v44 = *((_DWORD *)this + 6);
      if (v44 > 0x40)
      {
        int8x8_t v87 = v38;
        unsigned int v91 = v37;
        unint64_t v84 = v42;
        unsigned int v79 = v12;
        int v80 = llvm::APInt::countLeadingZerosSlowCase((llvm::KnownBits *)((char *)this + 16));
        unsigned int v12 = v79;
        int v81 = v80;
        unint64_t v42 = v84;
        int8x8_t v38 = v87;
        unsigned int v37 = v91;
        if (v81 == v44) {
          goto LABEL_54;
        }
      }
      else if (!*((void *)this + 2))
      {
        goto LABEL_54;
      }
    }
  }
  else if (!*(void *)this)
  {
    goto LABEL_61;
  }
  unsigned int v45 = a2[1].u32[0];
  if (v45 > 0x40) {
    operator new[]();
  }
  if (v45) {
    unint64_t v46 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v45;
  }
  else {
    unint64_t v46 = 0;
  }
  unint64_t v47 = v46 & ~*(void *)a2;
  unsigned int v48 = a2[3].u32[0];
  if (v48 <= 0x40 && v7)
  {
    int8x8_t v49 = *v12;
    *(void *)a3 = -1;
    unint64_t v50 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v7;
    unint64_t v51 = (void *)a3;
  }
  else
  {
    unsigned int v90 = v37;
    unint64_t v77 = (int8x8_t *)*v12;
    if (v48 < 0x41) {
      unint64_t v77 = v12;
    }
    int8x8_t v78 = *v77;
    *(void *)a3 = -1;
    if (v7) {
      unint64_t v50 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v7;
    }
    else {
      unint64_t v50 = 0;
    }
    unint64_t v51 = (void *)a3;
    unsigned int v37 = v90;
    int8x8_t v49 = v78;
  }
  *unint64_t v51 = v50;
  uint64_t v52 = *(unsigned int *)(a3 + 24);
  if (v52 > 0x40)
  {
    int v82 = (char *)*v11;
    int8x8_t v85 = v38;
    unint64_t v68 = v52 + 63;
    unsigned int v88 = v37;
    unint64_t v69 = v42;
    unint64_t v70 = v47;
    int8x8_t v71 = v49;
    int v72 = *(_DWORD *)(a3 + 24);
    memset(*v11, 255, ((unint64_t)(v52 + 63) >> 3) & 0x3FFFFFF8);
    LODWORD(v52) = v72;
    int8x8_t v49 = v71;
    unint64_t v47 = v70;
    unint64_t v42 = v69;
    int8x8_t v38 = v85;
    unsigned int v37 = v88;
    unint64_t v54 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v72;
    uint64_t v55 = (uint64_t *)&v82[8 * (v68 >> 6) - 8];
    uint64_t v53 = *v55;
  }
  else
  {
    uint64_t v53 = -1;
    *uint64_t v11 = (void *)-1;
    unint64_t v54 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v52;
    if (!v52) {
      unint64_t v54 = 0;
    }
    uint64_t v55 = (uint64_t *)(a3 + 16);
  }
  *uint64_t v55 = v53 & v54;
  int8x8_t v56 = v38;
  if (*(void *)&v38 <= v42)
  {
    do
    {
      while ((*(void *)&v56 & ~v47) != 0 || (*(void *)&v56 | *(void *)&v49) != *(void *)&v56)
      {
        if (++*(void *)&v56 > v42) {
          goto LABEL_54;
        }
      }
      unsigned int v57 = *((_DWORD *)this + 2);
      if (v57 > 0x40) {
        operator new[]();
      }
      unsigned int v58 = *((_DWORD *)this + 6);
      if (v58 > 0x40) {
        operator new[]();
      }
      if (v57 == v56.i32[0]) {
        uint64_t v59 = 0;
      }
      else {
        uint64_t v59 = *(void *)this >> v56.i8[0];
      }
      if (v58 == v56.i32[0]) {
        uint64_t v60 = 0;
      }
      else {
        uint64_t v60 = *((void *)this + 2) >> v56.i8[0];
      }
      unsigned int v61 = *(_DWORD *)(a3 + 8);
      if (v61 > 0x40) {
        operator new[]();
      }
      uint64_t v62 = v59 & *(void *)a3;
      if (v52 > 0x40) {
        operator new[]();
      }
      unint64_t v63 = v60 & (unint64_t)*v11;
      *(void *)a3 = v62;
      *(_DWORD *)(a3 + --*(_DWORD *)(this + 8) = v61;
      *(void *)(a3 + 16) = v63;
      *(_DWORD *)(a3 + 24) = v52;
      if (v62) {
        LOBYTE(v64) = 0;
      }
      else {
        BOOL v64 = v63 == 0;
      }
      char v65 = ++*(void *)&v56 > v42 || v64;
    }
    while ((v65 & 1) == 0);
  }
LABEL_54:
  if (v37)
  {
    unsigned int v20 = *(_DWORD *)(a3 + 8);
    unsigned int v21 = v20 - v37;
    if (v20 > 0x40 || v21 > 0x3F) {
      goto LABEL_26;
    }
    *(void *)a3 |= 0xFFFFFFFFFFFFFFFFLL >> -(char)v37 << v21;
  }
}

uint64_t llvm::KnownBits::ashr@<X0>(uint64_t this@<X0>, int8x8_t *a2@<X1>, unint64_t a3@<X2>, _DWORD *a4@<X8>)
{
  uint64_t v5 = (_DWORD *)this;
  unint64_t v7 = *(unsigned int *)(this + 8);
  a4[2] = v7;
  if (v7 > 0x40) {
    operator new[]();
  }
  *(void *)a4 = 0;
  a4[6] = v7;
  *((void *)a4 + 2) = 0;
  uint64_t v8 = a2[1].u32[0];
  if (v8 > 0x40)
  {
    __int32 v10 = 0;
    unint64_t v27 = (unint64_t)(v8 + 63) >> 6;
    uint8x8_t v28 = (int8x8_t *)*a2;
    do
    {
      int8x8_t v29 = *v28++;
      uint8x8_t v30 = (uint8x8_t)vcnt_s8(v29);
      v30.i16[0] = vaddlv_u8(v30);
      v10 += v30.i32[0];
      --v27;
    }
    while (v27);
  }
  else
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8(*a2);
    v9.i16[0] = vaddlv_u8(v9);
    __int32 v10 = v9.i32[0];
  }
  uint64_t v11 = (void **)(a4 + 4);
  unsigned int v12 = a2 + 2;
  uint64_t v13 = a2[3].u32[0];
  if (v13 > 0x40)
  {
    int v31 = 0;
    int64_t v32 = (unint64_t)(v13 + 63) >> 6;
    int8x8_t v33 = (int8x8_t *)*v12;
    int64_t v34 = v32;
    do
    {
      int8x8_t v35 = *v33++;
      uint8x8_t v36 = (uint8x8_t)vcnt_s8(v35);
      v36.i16[0] = vaddlv_u8(v36);
      v31 += v36.i32[0];
      --v34;
    }
    while (v34);
    if (v31 + v10 != v8) {
      goto LABEL_40;
    }
    int v37 = 0;
    int8x8_t v38 = (unint64_t *)*v12;
    do
    {
      if (v32-- < 1) {
        break;
      }
      unint64_t v40 = v38[v32];
      v37 += __clz(v40);
    }
    while (!v40);
    int v41 = v13 | 0xFFFFFFC0;
    if ((v13 & 0x3F) == 0) {
      int v41 = 0;
    }
    if ((v13 - v37 - v41) > 0x40) {
      goto LABEL_40;
    }
    unint64_t v14 = *v38;
  }
  else
  {
    unint64_t v14 = (unint64_t)*v12;
    uint8x8_t v15 = (uint8x8_t)vcnt_s8(*v12);
    v15.i16[0] = vaddlv_u8(v15);
    if (v10 + v15.i32[0] != v8) {
      goto LABEL_40;
    }
  }
  if (v14 < v7)
  {
    unsigned int v16 = *(_DWORD *)(this + 8);
    if (v16 > 0x40)
    {
      int v50 = v14;
      this = (uint64_t)llvm::APInt::assignSlowCase((const llvm::APInt *)a4, (const llvm::APInt *)this);
      LODWORD(v14) = v50;
      unsigned int v17 = (const llvm::APInt *)(v5 + 4);
      if (a4[6] > 0x40u) {
        goto LABEL_72;
      }
    }
    else
    {
      unsigned int v17 = (const llvm::APInt *)(this + 16);
      *(void *)a4 = *(void *)this;
      a4[2] = v16;
    }
    unsigned int v18 = v5[6];
    if (v18 <= 0x40)
    {
      *((void *)a4 + 2) = *(void *)v17;
      a4[6] = v18;
LABEL_11:
      unsigned int v19 = a4[2];
      if (v19 > 0x40)
      {
        int v56 = v14;
        this = (uint64_t)llvm::APInt::ashrSlowCase(a4, v14);
        LODWORD(v14) = v56;
      }
      else
      {
        char v20 = v14;
        if (v19 == v14) {
          char v20 = 63;
        }
        uint64_t v21 = (uint64_t)(*(void *)a4 << -(char)v19) >> -(char)v19 >> v20;
        if (v19) {
          unint64_t v22 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v19;
        }
        else {
          unint64_t v22 = 0;
        }
        *(void *)a4 = v22 & v21;
      }
      unsigned int v23 = a4[6];
      if (v23 > 0x40)
      {
        return (uint64_t)llvm::APInt::ashrSlowCase(a4 + 4, v14);
      }
      else
      {
        char v24 = v14;
        if (v23 == v14) {
          char v24 = 63;
        }
        uint64_t v25 = (uint64_t)((void)*v11 << -(char)v23) >> -(char)v23 >> v24;
        if (v23) {
          unint64_t v26 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v23;
        }
        else {
          unint64_t v26 = 0;
        }
        *uint64_t v11 = (void *)(v26 & v25);
      }
      return this;
    }
LABEL_72:
    int v51 = v14;
    this = (uint64_t)llvm::APInt::assignSlowCase((const llvm::APInt *)(a4 + 4), v17);
    LODWORD(v14) = v51;
    goto LABEL_11;
  }
LABEL_40:
  unint64_t v42 = *(unsigned int *)(this + 8);
  if (v42 > 0x40)
  {
    __int32 v90 = a2[3].i32[0];
    unint64_t v91 = llvm::APInt::countLeadingOnesSlowCase((llvm::APInt *)this);
    LODWORD(v13) = v90;
    unint64_t v42 = v91;
  }
  else if (v42)
  {
    unint64_t v42 = __clz(~(*(void *)this << -(char)v42));
  }
  unsigned int v43 = (llvm::APInt *)(v5 + 4);
  unsigned int v44 = v5[6];
  if (v44 > 0x40)
  {
    unint64_t v111 = v42;
    int v102 = v13;
    this = llvm::APInt::countLeadingOnesSlowCase((llvm::APInt *)(v5 + 4));
    LODWORD(v13) = v102;
    unint64_t v42 = v111;
  }
  else if (v44)
  {
    this = __clz(~(*(void *)v43 << -(char)v44));
  }
  else
  {
    this = 0;
  }
  unsigned int v119 = v13;
  if (v13 > 0x40) {
    operator new[]();
  }
  int8x8_t v118 = *v12;
  if (*(void *)&v118 < v7)
  {
    if (v42)
    {
      LODWORD(v42) = v42 + v118.i32[0];
      if (v7 >= v42) {
        unint64_t v42 = v42;
      }
      else {
        unint64_t v42 = v7;
      }
    }
    if (this)
    {
      if (v7 >= (int)this + v118.i32[0]) {
        this = (this + v118.i32[0]);
      }
      else {
        this = v7;
      }
    }
  }
  unsigned int v45 = a2[1].u32[0];
  if (v45 > 0x40) {
    operator new[]();
  }
  if (v45) {
    unint64_t v46 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v45;
  }
  else {
    unint64_t v46 = 0;
  }
  unint64_t v47 = v46 & ~*(void *)a2;
  unsigned int v117 = a2[1].u32[0];
  uint64_t v116 = (unint64_t *)v47;
  if (v47 >= v7) {
    goto LABEL_54;
  }
  if (v5[2] <= 0x40u)
  {
    if (!*(void *)v5) {
      goto LABEL_68;
    }
LABEL_81:
    unsigned int v60 = a2[1].u32[0];
    if (v60 > 0x40) {
      operator new[]();
    }
    if (v60) {
      unint64_t v61 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v60;
    }
    else {
      unint64_t v61 = 0;
    }
    unint64_t v62 = v61 & ~*(void *)a2;
    unsigned int v63 = a2[3].u32[0];
    if (v63 <= 0x40 && v7)
    {
      int8x8_t v64 = *v12;
      *(void *)a4 = -1;
      unint64_t v65 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v7;
      uint64_t v66 = (unint64_t *)a4;
    }
    else
    {
      unint64_t v92 = v42;
      unsigned int v93 = (int8x8_t *)*v12;
      if (v63 < 0x41) {
        unsigned int v93 = v12;
      }
      int8x8_t v94 = *v93;
      *(void *)a4 = -1;
      if (v7) {
        unint64_t v65 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v7;
      }
      else {
        unint64_t v65 = 0;
      }
      uint64_t v66 = (unint64_t *)a4;
      unint64_t v42 = v92;
      int8x8_t v64 = v94;
    }
    *uint64_t v66 = v65;
    uint64_t v67 = a4[6];
    if (v67 > 0x40)
    {
      unint64_t v105 = (char *)*v11;
      unint64_t v109 = v42;
      uint64_t v85 = this;
      unint64_t v86 = v62;
      int8x8_t v87 = v64;
      memset(*v11, 255, ((unint64_t)(v67 + 63) >> 3) & 0x3FFFFFF8);
      int8x8_t v64 = v87;
      unint64_t v62 = v86;
      this = v85;
      unint64_t v42 = v109;
      unint64_t v69 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v67;
      unint64_t v70 = (uint64_t *)&v105[8 * ((unint64_t)(v67 + 63) >> 6) - 8];
      uint64_t v68 = *v70;
    }
    else
    {
      uint64_t v68 = -1;
      *uint64_t v11 = (void *)-1;
      unint64_t v69 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v67;
      if (!v67) {
        unint64_t v69 = 0;
      }
      unint64_t v70 = (uint64_t *)(a4 + 4);
    }
    uint64_t *v70 = v68 & v69;
    int8x8_t v71 = v118;
    unint64_t v47 = (unint64_t)v116;
    int v72 = (unint64_t *)&v116;
    if (v117 >= 0x41) {
      int v72 = v116;
    }
    unint64_t v73 = *v72;
    if (*(void *)&v118 <= *v72)
    {
      unint64_t v74 = (unint64_t)(v67 + 63) >> 6;
      do
      {
        while ((*(void *)&v71 & ~v62) != 0 || (*(void *)&v71 | *(void *)&v64) != *(void *)&v71)
        {
          if (++*(void *)&v71 > v73) {
            goto LABEL_124;
          }
        }
        unsigned int v75 = v5[2];
        unsigned int v114 = v75;
        if (v75 > 0x40) {
          operator new[]();
        }
        unsigned int v76 = v5[6];
        if (v76 > 0x40) {
          operator new[]();
        }
        char v77 = v71.i8[0];
        if (v75 == v71.i32[0]) {
          char v77 = 63;
        }
        if (v75) {
          unint64_t v78 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v75;
        }
        else {
          unint64_t v78 = 0;
        }
        uint64_t v113 = v78 & ((uint64_t)(*(void *)v5 << -(char)v75) >> -(char)v75 >> v77);
        char v79 = v71.i8[0];
        if (v76 == v71.i32[0]) {
          char v79 = 63;
        }
        if (v76) {
          unint64_t v80 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v76;
        }
        else {
          unint64_t v80 = 0;
        }
        uint64_t v115 = v80 & ((uint64_t)(*(void *)v43 << -(char)v76) >> -(char)v76 >> v79);
        unsigned int v81 = a4[2];
        if (v81 > 0x40) {
          operator new[]();
        }
        uint64_t v82 = v113 & *(void *)a4;
        if (v67 > 0x40) {
          operator new[]();
        }
        a3 = v115 & (unint64_t)*v11;
        *(void *)a4 = v82;
        a4[2] = v81;
        *((void *)a4 + 2) = a3;
        a4[6] = v67;
        if (v82) {
          LOBYTE(v83) = 0;
        }
        else {
          BOOL v83 = a3 == 0;
        }
        if (v114 >= 0x41 && v113)
        {
          uint64_t v106 = this;
          unint64_t v110 = v42;
          unint64_t v88 = v47;
          unint64_t v103 = v62;
          unint64_t v100 = v74;
          int8x8_t v101 = v64;
          unint64_t v89 = v73;
          MEMORY[0x1D25D9CB0](v113, 0x1000C8000313F17);
          unint64_t v74 = v100;
          int8x8_t v64 = v101;
          unint64_t v73 = v89;
          unint64_t v62 = v103;
          unint64_t v47 = v88;
          this = v106;
          unint64_t v42 = v110;
        }
        char v84 = ++*(void *)&v71 > v73 || v83;
      }
      while ((v84 & 1) == 0);
    }
LABEL_124:
    LODWORD(v7) = v67;
    goto LABEL_54;
  }
  uint64_t v104 = this;
  unint64_t v108 = v42;
  unint64_t v98 = v47;
  int v57 = v5[2];
  int v58 = llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)v5);
  unint64_t v47 = v98;
  int v59 = v58;
  this = v104;
  unint64_t v42 = v108;
  if (v59 != v57) {
    goto LABEL_81;
  }
LABEL_68:
  if (v5[6] > 0x40u)
  {
    uint64_t v107 = this;
    unint64_t v112 = v42;
    unint64_t v99 = v47;
    int v95 = v5[6];
    int v96 = llvm::APInt::countLeadingZerosSlowCase(v43);
    unint64_t v47 = v99;
    int v97 = v96;
    this = v107;
    unint64_t v42 = v112;
    if (v97 != v95) {
      goto LABEL_81;
    }
  }
  else if (*(void *)v43)
  {
    goto LABEL_81;
  }
LABEL_54:
  if (v42)
  {
    a3 = a4[2];
    unsigned int v48 = a3 - v42;
    if (a3 > 0x40 || v48 > 0x3F)
    {
      uint64_t v52 = this;
      uint64_t v53 = a4;
      unint64_t v54 = v47;
      llvm::APInt::setBitsSlowCase(v53, v48, a3);
      unint64_t v47 = v54;
      this = v52;
    }
    else
    {
      *(void *)a4 |= 0xFFFFFFFFFFFFFFFFLL >> -(char)v42 << v48;
    }
  }
  if (this)
  {
    unsigned int v49 = v7 - this;
    if (v7 > 0x40 || v49 > 0x3F)
    {
      unint64_t v55 = v47;
      this = (uint64_t)llvm::APInt::setBitsSlowCase(v11, v49, v7);
      unint64_t v47 = v55;
    }
    else
    {
      *uint64_t v11 = (void *)((unint64_t)*v11 | (0xFFFFFFFFFFFFFFFFLL >> -(char)this << v49));
    }
  }
  if (v117 >= 0x41 && v47) {
    this = MEMORY[0x1D25D9CB0](v47, 0x1000C8000313F17, a3);
  }
  if (v119 >= 0x41)
  {
    this = (uint64_t)v118;
    if (v118) {
      return MEMORY[0x1D25D9CB0](*(void *)&v118, 0x1000C8000313F17);
    }
  }
  return this;
}

uint64_t llvm::KnownBits::eq(int8x8_t *a1, int8x8_t *a2)
{
  uint64_t v2 = a1[1].u32[0];
  if (v2 > 0x40)
  {
    uint64_t v33 = 0;
    __int32 v5 = 0;
    int8x8_t v3 = *a1;
    do
    {
      uint8x8_t v34 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(*(void *)&v3 + v33));
      v34.i16[0] = vaddlv_u8(v34);
      v5 += v34.i32[0];
      v33 += 8;
    }
    while ((((unint64_t)(v2 + 63) >> 3) & 0x3FFFFFF8) != v33);
  }
  else
  {
    int8x8_t v3 = *a1;
    uint8x8_t v4 = (uint8x8_t)vcnt_s8(*a1);
    v4.i16[0] = vaddlv_u8(v4);
    __int32 v5 = v4.i32[0];
  }
  uint64_t v6 = a1[3].u32[0];
  if (v6 > 0x40)
  {
    __int32 v8 = 0;
    unint64_t v35 = (unint64_t)(v6 + 63) >> 6;
    uint8x8_t v36 = (int8x8_t *)a1[2];
    do
    {
      int8x8_t v37 = *v36++;
      uint8x8_t v38 = (uint8x8_t)vcnt_s8(v37);
      v38.i16[0] = vaddlv_u8(v38);
      v8 += v38.i32[0];
      --v35;
    }
    while (v35);
  }
  else
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8(a1[2]);
    v7.i16[0] = vaddlv_u8(v7);
    __int32 v8 = v7.i32[0];
  }
  if (v8 + v5 == v2)
  {
    uint64_t v9 = a2[1].u32[0];
    if (v9 > 0x40)
    {
      __int32 v11 = 0;
      unint64_t v39 = (unint64_t)(v9 + 63) >> 6;
      unint64_t v40 = (int8x8_t *)*a2;
      do
      {
        int8x8_t v41 = *v40++;
        uint8x8_t v42 = (uint8x8_t)vcnt_s8(v41);
        v42.i16[0] = vaddlv_u8(v42);
        v11 += v42.i32[0];
        --v39;
      }
      while (v39);
    }
    else
    {
      uint8x8_t v10 = (uint8x8_t)vcnt_s8(*a2);
      v10.i16[0] = vaddlv_u8(v10);
      __int32 v11 = v10.i32[0];
    }
    uint64_t v12 = a2[3].u32[0];
    if (v12 > 0x40)
    {
      __int32 v14 = 0;
      unint64_t v43 = (unint64_t)(v12 + 63) >> 6;
      unsigned int v44 = (int8x8_t *)a2[2];
      do
      {
        int8x8_t v45 = *v44++;
        uint8x8_t v46 = (uint8x8_t)vcnt_s8(v45);
        v46.i16[0] = vaddlv_u8(v46);
        v14 += v46.i32[0];
        --v43;
      }
      while (v43);
    }
    else
    {
      uint8x8_t v13 = (uint8x8_t)vcnt_s8(a2[2]);
      v13.i16[0] = vaddlv_u8(v13);
      __int32 v14 = v13.i32[0];
    }
    if (v14 + v11 == v9)
    {
      if (v6 > 0x40) {
        BOOL v15 = memcmp(*(const void **)&a1[2], *(const void **)&a2[2], ((unint64_t)(v6 + 63) >> 3) & 0x3FFFFFF8) == 0;
      }
      else {
        BOOL v15 = *(void *)&a1[2] == *(void *)&a2[2];
      }
      int v16 = v15;
      goto LABEL_32;
    }
  }
  if (v6 > 0x40)
  {
    unint64_t v17 = (unint64_t)(v6 + 63) >> 6;
    unsigned int v18 = (uint64_t *)a1[2];
    unsigned int v19 = (uint64_t *)*a2;
    while (1)
    {
      uint64_t v21 = *v18++;
      uint64_t v20 = v21;
      uint64_t v22 = *v19++;
      if ((v22 & v20) != 0) {
        goto LABEL_15;
      }
      if (!--v17) {
        goto LABEL_19;
      }
    }
  }
  if ((*(void *)a2 & *(void *)&a1[2]) != 0)
  {
LABEL_15:
    int v16 = 0;
LABEL_32:
    int v24 = 1;
    return v16 | (v24 << 8);
  }
LABEL_19:
  uint64_t v23 = a2[3].u32[0];
  if (v23 > 0x40)
  {
    uint64_t v25 = (uint64_t *)a2[2];
    unint64_t v26 = ((unint64_t)(v23 + 63) >> 6) - 1;
    do
    {
      uint64_t v28 = *v25++;
      uint64_t v27 = v28;
      uint64_t v29 = **(void **)&v3;
      *(void *)&v3 += 8;
      uint64_t v30 = v29 & v27;
      int v24 = (v29 & v27) != 0;
      if (v30) {
        BOOL v31 = 1;
      }
      else {
        BOOL v31 = v26 == 0;
      }
      --v26;
    }
    while (!v31);
  }
  else
  {
    int v24 = (*(void *)&v3 & *(void *)&a2[2]) != 0;
  }
  int v16 = 0;
  return v16 | (v24 << 8);
}

uint64_t llvm::KnownBits::ne(int8x8_t *a1, int8x8_t *a2)
{
  __int16 v2 = llvm::KnownBits::eq(a1, a2);
  if ((v2 & 0xFF00) != 0) {
    return v2 ^ 1 | 0x100u;
  }
  else {
    return 0;
  }
}

uint64_t llvm::KnownBits::sgt(llvm::KnownBits *this, const llvm::KnownBits *a2, const llvm::KnownBits *a3)
{
  int8x8_t v3 = this;
  unsigned int v4 = *((_DWORD *)this + 2);
  if (v4 > 0x40) {
    operator new[]();
  }
  unint64_t v5 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v4;
  if (!v4) {
    unint64_t v5 = 0;
  }
  unint64_t v6 = v5 & ~*(void *)this;
  uint64_t v37 = v6;
  uint8x8_t v7 = (uint64_t *)((char *)this + 16);
  unsigned int v8 = *((_DWORD *)this + 6);
  unsigned int v9 = v8 - 1;
  uint8x8_t v10 = (void *)((char *)this + 16);
  if (v8 >= 0x41) {
    uint8x8_t v10 = (void *)(*v7 + 8 * (v9 >> 6));
  }
  if (((*v10 >> v9) & 1) == 0) {
    uint64_t v37 = v6 & ~(1 << (v4 - 1));
  }
  __int32 v11 = (uint64_t *)((char *)a2 + 16);
  unsigned int v12 = *((_DWORD *)a2 + 6);
  if (v12 > 0x40) {
    operator new[]();
  }
  uint64_t v39 = *v11;
  unsigned int v13 = *((_DWORD *)a2 + 2);
  unsigned int v14 = v13 - 1;
  BOOL v15 = a2;
  if (v13 >= 0x41) {
    BOOL v15 = (const llvm::KnownBits *)(*(void *)a2 + 8 * (v14 >> 6));
  }
  if (((*(void *)v15 >> v14) & 1) == 0) {
    uint64_t v39 = *v11 | (1 << (v12 - 1));
  }
  uint64_t v16 = v37 << -(char)v4 >> -(char)v4;
  uint64_t v17 = v39 << -(char)v4 >> -(char)v4;
  BOOL v18 = v16 < v17;
  BOOL v19 = v16 > v17;
  if (v18) {
    int v20 = -1;
  }
  else {
    int v20 = v19;
  }
  if (v20 < 1)
  {
    BOOL v33 = 0;
    int v34 = 1;
  }
  else
  {
    unsigned int v21 = *((_DWORD *)this + 6);
    if (v21 > 0x40) {
      operator new[]();
    }
    uint64_t v38 = *v7;
    unsigned int v22 = *((_DWORD *)this + 2);
    unsigned int v23 = v22 - 1;
    if (v22 >= 0x41) {
      int8x8_t v3 = (llvm::KnownBits *)(*(void *)this + 8 * (v23 >> 6));
    }
    if (((*(void *)v3 >> v23) & 1) == 0) {
      uint64_t v38 = *v7 | (1 << (v21 - 1));
    }
    unsigned int v24 = *((_DWORD *)a2 + 2);
    if (v24 > 0x40) {
      operator new[]();
    }
    unint64_t v25 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v24;
    if (!v24) {
      unint64_t v25 = 0;
    }
    unint64_t v26 = v25 & ~*(void *)a2;
    uint64_t v36 = v26;
    unsigned int v27 = *((_DWORD *)a2 + 6);
    unsigned int v28 = v27 - 1;
    if (v27 >= 0x41) {
      __int32 v11 = (uint64_t *)(*v11 + 8 * (v28 >> 6));
    }
    if ((((unint64_t)*v11 >> v28) & 1) == 0) {
      uint64_t v36 = v26 & ~(1 << (v24 - 1));
    }
    uint64_t v29 = v38 << -(char)v21 >> -(char)v21;
    uint64_t v30 = v36 << -(char)v21 >> -(char)v21;
    BOOL v18 = v29 < v30;
    BOOL v31 = v29 > v30;
    if (v18) {
      int v32 = -1;
    }
    else {
      int v32 = v31;
    }
    BOOL v33 = v32 > 0;
    int v34 = v33;
  }
  return v33 | (v34 << 8);
}

uint64_t llvm::KnownBits::sge(llvm::KnownBits *this, const llvm::KnownBits *a2, const llvm::KnownBits *a3)
{
  __int16 v3 = llvm::KnownBits::sgt(a2, this, a3);
  if ((v3 & 0xFF00) != 0) {
    return v3 ^ 1 | 0x100u;
  }
  else {
    return 0;
  }
}

uint64_t llvm::KnownBits::slt(llvm::KnownBits *this, const llvm::KnownBits *a2, const llvm::KnownBits *a3)
{
  return llvm::KnownBits::sgt(a2, this, a3);
}

uint64_t llvm::KnownBits::sle(llvm::KnownBits *this, const llvm::KnownBits *a2, const llvm::KnownBits *a3)
{
  __int16 v3 = llvm::KnownBits::sgt(this, a2, a3);
  if ((v3 & 0xFF00) != 0) {
    return v3 ^ 1 | 0x100u;
  }
  else {
    return 0;
  }
}

uint64_t llvm::KnownBits::abs@<X0>(uint64_t this@<X0>, char a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v4 = this;
  unsigned int v6 = *(_DWORD *)(this + 8);
  unsigned int v7 = v6 - 1;
  if (v6 > 0x40)
  {
    if (((*(void *)(*(void *)this + 8 * (v7 >> 6)) >> v7) & 1) == 0)
    {
      *(_DWORD *)(a3 + --*(_DWORD *)(this + 8) = v6;
      llvm::APInt::initSlowCase((llvm::APInt *)a3);
    }
    goto LABEL_15;
  }
  uint64_t v8 = *(void *)this;
  if ((*(void *)this >> v7))
  {
LABEL_15:
    return sub_1CCF6FB70(a3, this);
  }
  *(_DWORD *)(a3 + --*(_DWORD *)(this + 8) = v6;
  unsigned int v9 = (_DWORD *)(a3 + 8);
  *(void *)a3 = 0;
  *(_DWORD *)(a3 + 24) = v6;
  *(void *)(a3 + 16) = 0;
  unsigned int v10 = __clz(__rbit64(~v8));
  if (v10)
  {
    if (v10 > 0x40)
    {
      this = (uint64_t)llvm::APInt::setBitsSlowCase((void *)a3, 0, v10);
    }
    else
    {
      unint64_t v11 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v10;
      if (*v9 > 0x40u) {
        **(void **)a3 |= v11;
      }
      else {
        *(void *)a3 |= v11;
      }
    }
  }
  if (a2) {
    goto LABEL_20;
  }
  unsigned int v12 = (llvm::APInt *)(v4 + 16);
  unsigned int v13 = *(_DWORD *)(v4 + 24);
  if (v13 > 0x40)
  {
    this = llvm::APInt::countLeadingZerosSlowCase(v12);
    if (this == v13) {
      return this;
    }
  }
  else if (!*(void *)v12)
  {
    return this;
  }
  this = sub_1CB8C0D18((uint64_t)v12);
  if ((this & 1) == 0)
  {
LABEL_20:
    uint64_t v14 = 1 << (*v9 - 1);
    if (*v9 > 0x40u) {
      *(void *)(*(void *)a3 + 8 * ((*v9 - 1) >> 6)) |= v14;
    }
    else {
      *(void *)a3 |= v14;
    }
  }
  return this;
}

uint64_t llvm::KnownBits::mul@<X0>(llvm::KnownBits *this@<X0>, const llvm::KnownBits *a2@<X1>, const llvm::KnownBits *a3@<X2>, uint64_t a4@<X8>)
{
  int v32 = (int)a3;
  unsigned int v7 = *((_DWORD *)this + 2);
  unsigned int v45 = v7;
  if (v7 > 0x40) {
    operator new[]();
  }
  unint64_t v8 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v7;
  if (!v7) {
    unint64_t v8 = 0;
  }
  unint64_t v9 = v8 & ~*(void *)this;
  unsigned int v43 = v7;
  uint64_t v42 = v9;
  unsigned int v10 = *((_DWORD *)a2 + 2);
  unsigned int v45 = v10;
  if (v10 > 0x40) {
    operator new[]();
  }
  unint64_t v11 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v10;
  if (!v10) {
    unint64_t v11 = 0;
  }
  unint64_t v12 = v11 & ~*(void *)a2;
  unsigned int v41 = v10;
  uint64_t v40 = v12;
  BOOL v39 = 0;
  llvm::APInt::umul_ov((llvm::APInt *)&v42, (const llvm::APInt *)&v40, &v39, (uint64_t)&v44);
  int v13 = 0;
  if (!v39)
  {
    if (v45 > 0x40) {
      int v13 = llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v44);
    }
    else {
      int v13 = v45 + __clz(v44) - 64;
    }
  }
  if (*((_DWORD *)this + 2) >= 0x41u) {
    operator new[]();
  }
  unsigned int v14 = __clz(__rbit64(~(*((void *)this + 2) | *(void *)this)));
  if (*((_DWORD *)a2 + 2) >= 0x41u) {
    operator new[]();
  }
  unsigned int v15 = __clz(__rbit64(~(*((void *)a2 + 2) | *(void *)a2)));
  if (*((_DWORD *)this + 2) > 0x40u) {
    int v16 = llvm::APInt::countTrailingOnesSlowCase(this);
  }
  else {
    int v16 = __clz(__rbit64(~*(void *)this));
  }
  if (*((_DWORD *)a2 + 2) > 0x40u) {
    int v17 = llvm::APInt::countTrailingOnesSlowCase(a2);
  }
  else {
    int v17 = __clz(__rbit64(~*(void *)a2));
  }
  int v18 = v14 - v16;
  if (v15 - v17 < v14 - v16) {
    int v18 = v15 - v17;
  }
  if (v7 >= v17 + v16 + v18) {
    unsigned int v19 = v17 + v16 + v18;
  }
  else {
    unsigned int v19 = v7;
  }
  unsigned int v36 = *((_DWORD *)this + 6);
  if (v36 >= 0x41) {
    operator new[]();
  }
  unint64_t v20 = 0;
  unint64_t v35 = 0;
  if (v14)
  {
    if (v14 > 0x40) {
      llvm::APInt::setBitsSlowCase(&v35, 0, v14);
    }
    else {
      unint64_t v20 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v14;
    }
  }
  unint64_t v35 = *((void *)this + 2) & v20;
  unsigned int v34 = *((_DWORD *)a2 + 6);
  if (v34 >= 0x41) {
    operator new[]();
  }
  unint64_t v21 = 0;
  unint64_t v33 = 0;
  if (v15)
  {
    if (v15 > 0x40) {
      llvm::APInt::setBitsSlowCase(&v33, 0, v15);
    }
    else {
      unint64_t v21 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v15;
    }
  }
  unint64_t v33 = *((void *)a2 + 2) & v21;
  uint64_t result = llvm::APInt::operator*((uint64_t)&v35, &v33, (uint64_t)&__src);
  *(_DWORD *)(a4 + --*(_DWORD *)(this + 8) = v7;
  unint64_t v23 = 0;
  *(void *)a4 = 0;
  *(_DWORD *)(a4 + 24) = v7;
  *(void *)(a4 + 16) = 0;
  if (v13)
  {
    unsigned int v24 = v7 - v13;
    if (v7 - v13 > 0x3F)
    {
      uint64_t result = (uint64_t)llvm::APInt::setBitsSlowCase((void *)a4, v24, v7);
    }
    else
    {
      unint64_t v23 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v13 << v24;
      *(void *)a4 = v23;
    }
  }
  unsigned int v25 = v38;
  if (v38 > 0x40) {
    operator new[]();
  }
  unint64_t v26 = 0;
  unint64_t v27 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v38;
  if (!v38) {
    unint64_t v27 = 0;
  }
  unint64_t v28 = v27 & ~(unint64_t)__src;
  unsigned int v36 = v38;
  unint64_t v35 = 0;
  if (v19)
  {
    if (v19 > 0x40) {
      uint64_t result = (uint64_t)llvm::APInt::setBitsSlowCase(&v35, 0, v19);
    }
    else {
      unint64_t v26 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v19;
    }
  }
  unint64_t v35 = v26 & v28;
  *(void *)a4 = v23 | v26 & v28;
  unsigned int v36 = v25;
  if (v25 >= 0x41) {
    operator new[]();
  }
  unint64_t v29 = 0;
  unint64_t v35 = 0;
  if (v19)
  {
    if (v19 > 0x40) {
      uint64_t result = (uint64_t)llvm::APInt::setBitsSlowCase(&v35, 0, v19);
    }
    else {
      unint64_t v29 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v19;
    }
  }
  unint64_t v30 = (unint64_t)__src & v29;
  if (v7 > 1) {
    int v31 = v32;
  }
  else {
    int v31 = 0;
  }
  if (v31)
  {
    *(void *)(a4 + 16) = v30;
    *(_DWORD *)(a4 + 24) = v25;
    if (v7 >= 2 && v32) {
      *(void *)a4 |= 2uLL;
    }
  }
  else
  {
    *(void *)(a4 + 16) = v30;
    *(_DWORD *)(a4 + 24) = v25;
  }
  if (v45 >= 0x41)
  {
    uint64_t result = v44;
    if (v44) {
      uint64_t result = MEMORY[0x1D25D9CB0](v44, 0x1000C8000313F17);
    }
  }
  if (v41 >= 0x41)
  {
    uint64_t result = v40;
    if (v40) {
      uint64_t result = MEMORY[0x1D25D9CB0](v40, 0x1000C8000313F17);
    }
  }
  if (v43 >= 0x41)
  {
    uint64_t result = v42;
    if (v42) {
      return MEMORY[0x1D25D9CB0](v42, 0x1000C8000313F17);
    }
  }
  return result;
}

uint64_t sub_1CD093FC0@<X0>(uint64_t a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  llvm::APInt::sext(a1, a2, (uint64_t)&v9);
  uint64_t result = llvm::APInt::sext(a1 + 16, a2, (uint64_t)&v7);
  *(_DWORD *)(a3 + --*(_DWORD *)(this + 8) = v10;
  *(void *)a3 = v9;
  *(_DWORD *)(a3 + 24) = v8;
  *(void *)(a3 + 16) = v7;
  return result;
}

uint64_t sub_1CD094030@<X0>(uint64_t a1@<X0>, unsigned int a2@<W1>, unsigned int a3@<W2>, uint64_t a4@<X8>)
{
  llvm::APInt::extractBits(a1, a2, a3, (uint64_t)&v11);
  uint64_t result = llvm::APInt::extractBits(a1 + 16, a2, a3, (uint64_t)&v9);
  *(_DWORD *)(a4 + --*(_DWORD *)(this + 8) = v12;
  *(void *)a4 = v11;
  *(_DWORD *)(a4 + 24) = v10;
  *(void *)(a4 + 16) = v9;
  return result;
}

uint64_t llvm::KnownBits::udiv@<X0>(llvm::KnownBits *this@<X0>, const llvm::KnownBits *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v5 = *((_DWORD *)this + 2);
  *(_DWORD *)(a3 + --*(_DWORD *)(this + 8) = v5;
  if (v5 > 0x40) {
    operator new[]();
  }
  *(void *)a3 = 0;
  *(_DWORD *)(a3 + 24) = v5;
  *(void *)(a3 + 16) = 0;
  if (v5) {
    unsigned int v6 = __clz(~(*(void *)this << -(char)v5));
  }
  else {
    unsigned int v6 = 0;
  }
  uint64_t v7 = (const llvm::KnownBits *)((char *)a2 + 16);
  unsigned int v8 = *((_DWORD *)a2 + 6);
  if (v8 > 0x40) {
    uint64_t result = llvm::APInt::countLeadingZerosSlowCase(v7);
  }
  else {
    uint64_t result = v8 + __clz(*(void *)v7) - 64;
  }
  unsigned int v10 = v6 + v5 + ~result;
  if (v10 >= v5) {
    unsigned int v10 = v5;
  }
  if (result == v5) {
    unsigned int v10 = v6;
  }
  if (v10)
  {
    unsigned int v11 = v5 - v10;
    if (v5 - v10 > 0x3F)
    {
      return (uint64_t)llvm::APInt::setBitsSlowCase((void *)a3, v11, v5);
    }
    else
    {
      *(void *)a3 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v10 << v11;
    }
  }
  return result;
}

uint64_t llvm::KnownBits::urem@<X0>(llvm::KnownBits *this@<X0>, int8x8_t *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v7 = *((_DWORD *)this + 2);
  *(_DWORD *)(a3 + --*(_DWORD *)(this + 8) = v7;
  if (v7 >= 0x41) {
    operator new[]();
  }
  *(void *)a3 = 0;
  *(_DWORD *)(a3 + 24) = v7;
  *(void *)(a3 + 16) = 0;
  uint64_t v8 = a2[1].u32[0];
  if (v8 > 0x40)
  {
    __int32 v11 = 0;
    unint64_t v27 = (unint64_t)(v8 + 63) >> 6;
    int8x8_t v9 = *a2;
    unint64_t v28 = (int8x8_t *)*a2;
    do
    {
      int8x8_t v29 = *v28++;
      uint8x8_t v30 = (uint8x8_t)vcnt_s8(v29);
      v30.i16[0] = vaddlv_u8(v30);
      v11 += v30.i32[0];
      --v27;
    }
    while (v27);
  }
  else
  {
    int8x8_t v9 = *a2;
    uint8x8_t v10 = (uint8x8_t)vcnt_s8(*a2);
    v10.i16[0] = vaddlv_u8(v10);
    __int32 v11 = v10.i32[0];
  }
  uint64_t v12 = a2[3].u32[0];
  if (v12 > 0x40)
  {
    int v31 = 0;
    unint64_t v32 = (unint64_t)(v12 + 63) >> 6;
    unint64_t v33 = (int8x8_t *)a2[2];
    do
    {
      int8x8_t v34 = *v33++;
      uint8x8_t v35 = (uint8x8_t)vcnt_s8(v34);
      v35.i16[0] = vaddlv_u8(v35);
      v31 += v35.i32[0];
      --v32;
    }
    while (v32);
    int v36 = v31 + v11;
    if (v31 == 1 && v36 == v8)
    {
      unsigned int v41 = a2[3].u32[0];
      operator new[]();
    }
    goto LABEL_9;
  }
  int8x8_t v13 = a2[2];
  uint8x8_t v14 = (uint8x8_t)vcnt_s8(v13);
  v14.i16[0] = vaddlv_u8(v14);
  __int32 v15 = v11 + v14.i32[0];
  if (v14.u32[0] != 1 || v15 != v8)
  {
LABEL_9:
    unsigned int v17 = *((_DWORD *)this + 2);
    if (v17 > 0x40)
    {
      int8x8_t v38 = v9;
      unsigned int v39 = llvm::APInt::countLeadingOnesSlowCase(this);
      int8x8_t v9 = v38;
      unsigned int v18 = v39;
    }
    else if (v17)
    {
      unsigned int v18 = __clz(~(*(void *)this << -(char)v17));
    }
    else
    {
      unsigned int v18 = 0;
    }
    if (v8 > 0x40)
    {
      uint64_t result = llvm::APInt::countLeadingOnesSlowCase((llvm::APInt *)a2);
    }
    else
    {
      unsigned int v19 = __clz(~(*(void *)&v9 << -(char)v8));
      if (v8) {
        uint64_t result = v19;
      }
      else {
        uint64_t result = 0;
      }
    }
    if (v18 <= result) {
      unsigned int v21 = result;
    }
    else {
      unsigned int v21 = v18;
    }
    if (v21)
    {
      unsigned int v22 = v7 - v21;
      if (v7 - v21 > 0x3F)
      {
        return (uint64_t)llvm::APInt::setBitsSlowCase((void *)a3, v22, v7);
      }
      else
      {
        *(void *)a3 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v21 << v22;
      }
    }
    return result;
  }
  unsigned int v41 = a2[3].u32[0];
  int8x8_t v40 = v13;
  uint64_t result = llvm::APInt::operator-=((uint64_t)&v40, 1uLL);
  unsigned int v23 = v41;
  int8x8_t v24 = v40;
  unsigned int v41 = 0;
  if (v23 > 0x40) {
    operator new[]();
  }
  unint64_t v25 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v23;
  if (!v23) {
    unint64_t v25 = 0;
  }
  *(void *)a3 = *(void *)this | v25 & ~*(void *)&v40;
  *(_DWORD *)(a3 + --*(_DWORD *)(this + 8) = v23;
  unsigned int v26 = *((_DWORD *)this + 6);
  if (v26 > 0x40) {
    operator new[]();
  }
  *(void *)(a3 + 16) = *((void *)this + 2) & *(void *)&v24;
  *(_DWORD *)(a3 + 24) = v26;
  return result;
}

uint64_t llvm::KnownBits::srem@<X0>(uint64_t this@<X0>, int8x8_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = this;
  unsigned int v6 = *(_DWORD *)(this + 8);
  *(_DWORD *)(a3 + --*(_DWORD *)(this + 8) = v6;
  unsigned int v7 = (uint64_t *)(a3 + 16);
  if (v6 > 0x40) {
    llvm::APInt::initSlowCase((llvm::APInt *)a3);
  }
  *(void *)a3 = 0;
  *(_DWORD *)(a3 + 24) = v6;
  *(void *)(a3 + 16) = 0;
  uint64_t v8 = a2[1].u32[0];
  if (v8 > 0x40)
  {
    __int32 v10 = 0;
    unint64_t v37 = (unint64_t)(v8 + 63) >> 6;
    int8x8_t v38 = (int8x8_t *)*a2;
    do
    {
      int8x8_t v39 = *v38++;
      uint8x8_t v40 = (uint8x8_t)vcnt_s8(v39);
      v40.i16[0] = vaddlv_u8(v40);
      v10 += v40.i32[0];
      --v37;
    }
    while (v37);
  }
  else
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8(*a2);
    v9.i16[0] = vaddlv_u8(v9);
    __int32 v10 = v9.i32[0];
  }
  uint64_t v11 = a2[3].u32[0];
  if (v11 > 0x40)
  {
    int v41 = 0;
    unint64_t v42 = (unint64_t)(v11 + 63) >> 6;
    unsigned int v43 = (int8x8_t *)a2[2];
    do
    {
      int8x8_t v44 = *v43++;
      uint8x8_t v45 = (uint8x8_t)vcnt_s8(v44);
      v45.i16[0] = vaddlv_u8(v45);
      v41 += v45.i32[0];
      --v42;
    }
    while (v42);
    int v46 = v41 + v10;
    if (v41 == 1 && v46 == v8)
    {
      unsigned int v70 = a2[3].u32[0];
      operator new[]();
    }
    goto LABEL_9;
  }
  int8x8_t v12 = a2[2];
  uint8x8_t v13 = (uint8x8_t)vcnt_s8(v12);
  v13.i16[0] = vaddlv_u8(v13);
  __int32 v14 = v10 + v13.i32[0];
  if (v13.u32[0] == 1 && v14 == v8)
  {
    unsigned int v70 = a2[3].u32[0];
    int8x8_t v69 = v12;
    this = llvm::APInt::operator-=((uint64_t)&v69, 1uLL);
    unsigned int v72 = v70;
    unint64_t __src = (void *)v69;
    unsigned int v70 = 0;
    unsigned int v19 = *(_DWORD *)(v4 + 8);
    if (v19 > 0x40) {
      operator new[]();
    }
    unint64_t v20 = *(void *)v4 & *(void *)&v69;
    if (*(_DWORD *)(a3 + 8) >= 0x41u)
    {
      this = *(void *)a3;
      if (*(void *)a3) {
        this = MEMORY[0x1D25D9CB0](this, 0x1000C8000313F17);
      }
    }
    *(void *)a3 = v20;
    *(_DWORD *)(a3 + --*(_DWORD *)(this + 8) = v19;
    unsigned int v21 = *(_DWORD *)(v4 + 24);
    if (v21 > 0x40) {
      operator new[]();
    }
    unint64_t v22 = (unint64_t)__src & *(void *)(v4 + 16);
    if (*(_DWORD *)(a3 + 24) >= 0x41u)
    {
      this = *v7;
      if (*v7)
      {
        unsigned int v64 = *(_DWORD *)(v4 + 24);
        this = MEMORY[0x1D25D9CB0](this, 0x1000C8000313F17);
        unsigned int v21 = v64;
      }
    }
    *(void *)(a3 + 16) = v22;
    *(_DWORD *)(a3 + 24) = v21;
    unsigned int v23 = *(_DWORD *)(v4 + 8);
    unsigned int v24 = v23 - 1;
    if (v23 >= 0x41) {
      unint64_t v25 = (unint64_t *)(*(void *)v4 + 8 * (v24 >> 6));
    }
    else {
      unint64_t v25 = (unint64_t *)v4;
    }
    unint64_t v26 = *v25;
    unsigned int v27 = v72;
    if ((v26 >> v24))
    {
      unsigned int v68 = v72;
      if (v72 <= 0x40)
      {
        unint64_t v28 = (unint64_t)__src;
LABEL_35:
        unint64_t v33 = ~v28;
        if (v72) {
          unint64_t v34 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v72;
        }
        else {
          unint64_t v34 = 0;
        }
        this = v34 & v33;
        uint64_t v67 = v34 & v33;
        unsigned int v35 = v68;
        unsigned int v68 = 0;
        uint64_t v36 = *(unsigned int *)(a3 + 8);
        if (v36 > 0x40)
        {
          unsigned int v60 = *(void **)a3;
          unint64_t v61 = (unint64_t)(v36 + 63) >> 6;
          unint64_t v62 = (uint64_t *)this;
          do
          {
            uint64_t v63 = *v62++;
            *v60++ |= v63;
            --v61;
          }
          while (v61);
        }
        else
        {
          *(void *)a3 |= this;
        }
        if (v35 >= 0x41 && this) {
          this = MEMORY[0x1D25D9CB0](this, 0x1000C8000313F17);
        }
        if (v68 >= 0x41)
        {
          this = v67;
          if (v67) {
            this = MEMORY[0x1D25D9CB0](v67, 0x1000C8000313F17);
          }
        }
        unsigned int v27 = v72;
LABEL_27:
        unsigned int v29 = *(_DWORD *)(v4 + 24);
        unsigned int v30 = v29 - 1;
        unint64_t v31 = *(void *)(v4 + 16);
        if (v29 >= 0x41) {
          unint64_t v32 = (void *)(v31 + 8 * (v30 >> 6));
        }
        else {
          unint64_t v32 = (void *)(v4 + 16);
        }
        if ((*v32 >> v30))
        {
          if (v27 > 0x40)
          {
            unint64_t v51 = ((unint64_t)v27 + 63) >> 6;
            uint64_t v52 = (uint64_t *)__src;
            do
            {
              uint64_t v54 = *v52++;
              uint64_t v53 = v54;
              uint64_t v55 = *(void *)v31;
              v31 += 8;
              if ((v55 & v53) != 0)
              {
                unsigned int v66 = v27;
                operator new[]();
              }
              --v51;
            }
            while (v51);
LABEL_76:
            this = (uint64_t)__src;
            if (__src) {
              return MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
            }
            return this;
          }
          if (((unint64_t)__src & v31) == 0) {
            return this;
          }
          unsigned int v66 = v27;
          uint64_t v65 = (uint64_t)__src;
          sub_1CBA14940((uint64_t)&v65);
          unsigned int v48 = v66;
          this = v65;
          unsigned int v66 = 0;
          uint64_t v49 = *(unsigned int *)(a3 + 24);
          if (v49 > 0x40)
          {
            int v56 = (void *)*v7;
            unint64_t v57 = (unint64_t)(v49 + 63) >> 6;
            int v58 = (uint64_t *)v65;
            do
            {
              uint64_t v59 = *v58++;
              *v56++ |= v59;
              --v57;
            }
            while (v57);
          }
          else
          {
            *v7 |= v65;
          }
          if (v48 >= 0x41)
          {
            if (this)
            {
              this = MEMORY[0x1D25D9CB0](this, 0x1000C8000313F17);
              if (v66 >= 0x41)
              {
                this = v65;
                if (v65) {
                  this = MEMORY[0x1D25D9CB0](v65, 0x1000C8000313F17);
                }
              }
            }
          }
          unsigned int v27 = v72;
        }
        if (v27 < 0x41) {
          return this;
        }
        goto LABEL_76;
      }
    }
    else
    {
      if (v72 <= 0x40)
      {
        unint64_t v28 = (unint64_t)__src;
        if (((unint64_t)__src & ~*(void *)v4) != 0) {
          goto LABEL_27;
        }
        unsigned int v68 = v72;
        goto LABEL_35;
      }
      unsigned int v50 = v72;
      this = llvm::APInt::isSubsetOfSlowCase((uint64_t **)&__src, (uint64_t **)v4);
      unsigned int v27 = v50;
      if (!this) {
        goto LABEL_27;
      }
      unsigned int v68 = v50;
    }
    operator new[]();
  }
LABEL_9:
  unsigned int v16 = *(_DWORD *)(this + 8);
  if (v16 > 0x40)
  {
    this = llvm::APInt::countLeadingOnesSlowCase((llvm::APInt *)this);
  }
  else
  {
    if (!v16) {
      return this;
    }
    this = __clz(~(*(void *)this << -(char)v16));
  }
  if (this)
  {
    unsigned int v17 = *(_DWORD *)(a3 + 8);
    unsigned int v18 = v17 - this;
    if (v17 > 0x40 || v18 > 0x3F)
    {
      return (uint64_t)llvm::APInt::setBitsSlowCase((void *)a3, v18, v17);
    }
    else
    {
      *(void *)a3 |= 0xFFFFFFFFFFFFFFFFLL >> -(char)this << v18;
    }
  }
  return this;
}

uint64_t llvm::KnownBits::operator&=(uint64_t result, uint64_t **a2)
{
  uint64_t v2 = *(unsigned int *)(result + 8);
  if (v2 > 0x40)
  {
    uint64_t v4 = *(void **)result;
    unsigned int v5 = *a2;
    unint64_t v6 = (unint64_t)(v2 + 63) >> 6;
    do
    {
      uint64_t v7 = *v5++;
      *v4++ |= v7;
      --v6;
    }
    while (v6);
  }
  else
  {
    *(void *)result |= (unint64_t)*a2;
  }
  uint64_t v3 = *(unsigned int *)(result + 24);
  if (v3 > 0x40)
  {
    uint64_t v8 = *(void **)(result + 16);
    uint8x8_t v9 = a2[2];
    unint64_t v10 = (unint64_t)(v3 + 63) >> 6;
    do
    {
      uint64_t v11 = *v9++;
      *v8++ &= v11;
      --v10;
    }
    while (v10);
  }
  else
  {
    *(void *)(result + 16) &= (unint64_t)a2[2];
  }
  return result;
}

uint64_t llvm::KnownBits::operator|=(uint64_t result, uint64_t **a2)
{
  uint64_t v2 = *(unsigned int *)(result + 8);
  if (v2 > 0x40)
  {
    uint64_t v4 = *(void **)result;
    unsigned int v5 = *a2;
    unint64_t v6 = (unint64_t)(v2 + 63) >> 6;
    do
    {
      uint64_t v7 = *v5++;
      *v4++ &= v7;
      --v6;
    }
    while (v6);
  }
  else
  {
    *(void *)result &= (unint64_t)*a2;
  }
  uint64_t v3 = *(unsigned int *)(result + 24);
  if (v3 > 0x40)
  {
    uint64_t v8 = *(void **)(result + 16);
    uint8x8_t v9 = a2[2];
    unint64_t v10 = (unint64_t)(v3 + 63) >> 6;
    do
    {
      uint64_t v11 = *v9++;
      *v8++ |= v11;
      --v10;
    }
    while (v10);
  }
  else
  {
    *(void *)(result + 16) |= (unint64_t)a2[2];
  }
  return result;
}

uint64_t llvm::KnownBits::operator^=(uint64_t result, void *a2)
{
  if (*(_DWORD *)(result + 8) > 0x40u) {
    operator new[]();
  }
  unsigned int v2 = *(_DWORD *)(result + 24);
  if (v2 >= 0x41) {
    operator new[]();
  }
  uint64_t v3 = a2[2] & *(void *)(result + 16) | *a2 & *(void *)result;
  if (*(_DWORD *)(result + 8) > 0x40u) {
    operator new[]();
  }
  unsigned int v4 = *(_DWORD *)(result + 24);
  if (v4 >= 0x41) {
    operator new[]();
  }
  *(void *)(result + 16) = *a2 & *(void *)(result + 16) | a2[2] & *(void *)result;
  *(_DWORD *)(result + 24) = v4;
  if (*(_DWORD *)(result + 8) >= 0x41u && *(void *)result)
  {
    uint64_t v5 = result;
    uint64_t v6 = v3;
    MEMORY[0x1D25D9CB0](*(void *)result, 0x1000C8000313F17);
    uint64_t v3 = v6;
    uint64_t result = v5;
  }
  *(void *)uint64_t result = v3;
  *(_DWORD *)(result + --*(_DWORD *)(this + 8) = v2;
  return result;
}

void llvm::KnownBits::print(llvm::KnownBits *this, llvm::raw_ostream *a2)
{
  v9[5] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *((void *)a2 + 4);
  if ((unint64_t)(*((void *)a2 + 3) - v4) > 5)
  {
    *(_WORD *)(v4 + 4) = 15727;
    *(_DWORD *)uint64_t v4 = 1919244923;
    *((void *)a2 + 4) += 6;
  }
  else
  {
    llvm::raw_ostream::write(a2, "{Zero=", 6uLL);
  }
  uint64_t v7 = v9;
  long long v8 = xmmword_1CDB15B30;
  llvm::APInt::toString((unsigned int *)this, &v7, 0xAu, 1, 0);
  llvm::raw_ostream::write(a2, (const char *)v7, v8);
  if (v7 != v9) {
    free(v7);
  }
  uint64_t v5 = *((void *)a2 + 4);
  if ((unint64_t)(*((void *)a2 + 3) - v5) > 5)
  {
    *(_WORD *)(v5 + 4) = 15717;
    *(_DWORD *)uint64_t v5 = 1850679340;
    *((void *)a2 + 4) += 6;
  }
  else
  {
    llvm::raw_ostream::write(a2, ", One=", 6uLL);
  }
  uint64_t v7 = v9;
  long long v8 = xmmword_1CDB15B30;
  llvm::APInt::toString((unsigned int *)this + 4, &v7, 0xAu, 1, 0);
  llvm::raw_ostream::write(a2, (const char *)v7, v8);
  if (v7 != v9) {
    free(v7);
  }
  uint64_t v6 = (unsigned char *)*((void *)a2 + 4);
  if (*((unsigned char **)a2 + 3) == v6)
  {
    llvm::raw_ostream::write(a2, "}", 1uLL);
  }
  else
  {
    *uint64_t v6 = 125;
    ++*((void *)a2 + 4);
  }
}

llvm *llvm::KnownBits::dump(llvm::KnownBits *this)
{
  unsigned int v2 = llvm::dbgs(this);
  llvm::KnownBits::print(this, v2);
  uint64_t result = llvm::dbgs(v3);
  uint64_t v5 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v5)
  {
    return llvm::raw_ostream::write(result, "\n", 1uLL);
  }
  else
  {
    *uint64_t v5 = 10;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t llvm::getULEB128Size(unint64_t this)
{
  LODWORD(v1) = 0;
  do
  {
    uint64_t v1 = (v1 + 1);
    BOOL v2 = this > 0x7F;
    this >>= 7;
  }
  while (v2);
  return v1;
}

uint64_t llvm::getSLEB128Size(uint64_t this)
{
  uint64_t v1 = this;
  LODWORD(this) = 0;
  uint64_t v2 = v1 >> 63;
  do
  {
    do
    {
      int v3 = v1;
      v1 >>= 7;
      this = (this + 1);
    }
    while (v1 != v2);
  }
  while (((v3 ^ v2) & 0x40) != 0);
  return this;
}

llvm::line_iterator *llvm::line_iterator::line_iterator(llvm::line_iterator *this, const llvm::MemoryBuffer *a2, char a3, char a4)
{
  uint64_t v7 = *((void *)a2 + 1);
  uint64_t v8 = *((void *)a2 + 2) - v7;
  uint64_t v9 = (*(uint64_t (**)(const llvm::MemoryBuffer *))(*(void *)a2 + 16))(a2);
  v12[0] = v7;
  v12[1] = v8;
  v12[2] = v9;
  v12[3] = v10;
  return llvm::line_iterator::line_iterator(this, (const llvm::MemoryBufferRef *)v12, a3, a4);
}

{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void v12[4];

  uint64_t v7 = *((void *)a2 + 1);
  uint64_t v8 = *((void *)a2 + 2) - v7;
  uint64_t v9 = (*(uint64_t (**)(const llvm::MemoryBuffer *))(*(void *)a2 + 16))(a2);
  v12[0] = v7;
  v12[1] = v8;
  v12[2] = v9;
  v12[3] = v10;
  return llvm::line_iterator::line_iterator(this, (const llvm::MemoryBufferRef *)v12, a3, a4);
}

BOOL llvm::sys::locale::isPrint(llvm::sys::locale *this)
{
  if (this >> 16 > 0x10) {
    return 0;
  }
  uint64_t v1 = (char *)&unk_1CFB2F8C0;
  unint64_t v2 = 548;
  do
  {
    unint64_t v3 = v2 >> 1;
    uint64_t v4 = &v1[8 * (v2 >> 1)];
    unsigned int v5 = *((_DWORD *)v4 + 1);
    uint64_t v6 = v4 + 8;
    v2 += ~(v2 >> 1);
    if (v5 < this) {
      uint64_t v1 = v6;
    }
    else {
      unint64_t v2 = v3;
    }
  }
  while (v2);
  return v1 == (char *)&unk_1CFB309E0 || *(_DWORD *)v1 > this;
}

uint64_t sub_1CD095710(void *a1)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  a1[1] = 0;
  __s[255] = 0;
  __s[0] = 0;
  gethostname(__s, 0xFFuLL);
  size_t v2 = strlen(__s);
  size_t v3 = v2;
  uint64_t v4 = a1[1];
  if (a1[2] < v4 + v2) {
    llvm::SmallVectorBase<unsigned long long>::grow_pod();
  }
  if (v2)
  {
    memcpy((void *)(*a1 + v4), __s, v2);
    uint64_t v4 = a1[1];
  }
  a1[1] = v4 + v3;
  std::system_category();
  return 0;
}

uint64_t llvm::LockFileManager::waitForUnlock(llvm::LockFileManager *this, unsigned int a2)
{
  if (!*((unsigned char *)this + 488)) {
    return 0;
  }
  *((unsigned char *)&__token.__r_.__value_.__s + 23) = 12;
  strcpy((char *)&__token, "/dev/urandom");
  std::random_device::random_device(&v29, &__token);
  if (SHIBYTE(__token.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__token.__r_.__value_.__l.__data_);
  }
  uint32_t v4 = arc4random();
  unsigned int v5 = v4 + ((v4 / 0x7FFFFFFF) | ((v4 / 0x7FFFFFFF) << 31));
  if (v5 <= 1) {
    unsigned int v5 = 1;
  }
  unsigned int v28 = v5;
  v6.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  uint64_t v7 = (void *)((char *)this + 152);
  uint64_t v8 = 1;
  unint64_t v9 = a2;
  while (1)
  {
    v27[0] = 1;
    v27[1] = v8;
    uint64_t v10 = sub_1CD83D984((uint64_t)&v28, v27);
    if (10 * v10 >= 1)
    {
      uint64_t v11 = 0x7FFFFFFFFFFFFFFFLL;
      if ((unint64_t)(10 * v10) < 0x8637BD057A0) {
        uint64_t v11 = 10000000 * v10;
      }
      __token.__r_.__value_.__r.__words[0] = v11;
      std::this_thread::sleep_for ((const std::chrono::nanoseconds *)&__token);
    }
    uint64_t v12 = *((void *)this + 20);
    if ((unint64_t)(v12 + 1) > *((void *)this + 21)) {
      llvm::SmallVectorBase<unsigned long long>::grow_pod();
    }
    *(unsigned char *)(*v7 + v12) = 0;
    uint8x8_t v13 = (unsigned char *)*v7;
    __int16 v26 = 257;
    if (*v13)
    {
      __token.__r_.__value_.__r.__words[0] = (std::string::size_type)v13;
      char v14 = 3;
    }
    else
    {
      char v14 = 1;
    }
    LOBYTE(v26) = v14;
    int v15 = llvm::sys::fs::access((unsigned __int8 *)&__token, 0);
    if (std::generic_category() == v16 && v15 == 2)
    {
      __int16 v26 = 261;
      std::string::size_type v22 = *((void *)this + 1);
      __token.__r_.__value_.__r.__words[0] = *(void *)this;
      __token.__r_.__value_.__l.__size_ = v22;
      uint64_t v23 = llvm::sys::fs::access((unsigned __int8 *)&__token, 0) != 0;
      goto LABEL_32;
    }
    char v17 = *((unsigned char *)this + 479);
    BOOL v18 = v17 < 0;
    unsigned int v19 = v17 >= 0 ? (llvm::LockFileManager *)((char *)this + 456) : (llvm::LockFileManager *)*((void *)this + 57);
    uint64_t v20 = v17 & 0x7F;
    uint64_t v21 = v18 ? *((void *)this + 58) : v20;
    if (!llvm::LockFileManager::processStillExecuting(v19, v21, *((_DWORD *)this + 120))) {
      break;
    }
    if ((unint64_t)(2 * v8) >= 0x32) {
      uint64_t v8 = 50;
    }
    else {
      v8 *= 2;
    }
    if ((std::chrono::steady_clock::now().__d_.__rep_ - v6.__d_.__rep_) / 1000000000 >= v9)
    {
      uint64_t v23 = 2;
      goto LABEL_32;
    }
  }
  uint64_t v23 = 1;
LABEL_32:
  std::random_device::~random_device(&v29);
  return v23;
}

llvm::raw_ostream *llvm::LLT::print(llvm::raw_ostream *this, llvm::raw_ostream *a2)
{
  size_t v3 = this;
  unint64_t v4 = *(void *)this & 0xFFFFFFFFFFFFFFF9;
  if (v4) {
    BOOL v5 = (*(void *)this & 4) == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    uint8x8_t v13 = (unsigned char *)*((void *)a2 + 4);
    if (*((unsigned char **)a2 + 3) == v13)
    {
      llvm::raw_ostream::write(a2, "<", 1uLL);
    }
    else
    {
      unsigned char *v13 = 60;
      ++*((void *)a2 + 4);
    }
    unint64_t v14 = *(void *)v3;
    uint64_t v15 = 0x800000000000000;
    if ((*(void *)v3 & 2) == 0) {
      uint64_t v15 = 0x8000000000000;
    }
    unint64_t v16 = (unsigned __int16)(v14 >> 3);
    if ((v15 & v14) != 0)
    {
      uint64_t v17 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v17) > 8)
      {
        *(unsigned char *)(v17 + --*(_DWORD *)(this + 8) = 32;
        *(void *)uint64_t v17 = *(void *)"vscale x ";
        *((void *)a2 + 4) += 9;
      }
      else
      {
        llvm::raw_ostream::write(a2, "vscale x ", 9uLL);
      }
    }
    sub_1CD098D14(a2, v16, 0, 0, 0);
    uint64_t v18 = *((void *)a2 + 4);
    if ((unint64_t)(*((void *)a2 + 3) - v18) > 2)
    {
      *(unsigned char *)(v18 + 2) = 32;
      *(_WORD *)uint64_t v18 = 30752;
      *((void *)a2 + 4) += 3;
    }
    else
    {
      llvm::raw_ostream::write(a2, " x ", 3uLL);
    }
    unint64_t v19 = *(void *)v3;
    char v20 = 3;
    if ((*(void *)v3 & 1) == 0) {
      char v20 = 19;
    }
    unint64_t v21 = v19 & 0x8000000000000000 | (8 * (v19 >> v20)) | 1;
    char v22 = 35;
    char v23 = 19;
    if ((v19 & 4) == 0) {
      char v22 = 19;
    }
    unint64_t v24 = v19 >> v22;
    if ((v19 & 4) == 0) {
      char v23 = 3;
    }
    if (v19) {
      char v23 = 3;
    }
    unint64_t v25 = (8 * (unsigned __int16)(v19 >> v23)) & 0xFFFFF8000007FFFFLL | ((v24 & 0xFFFFFF) << 19);
    if ((v19 & 2) != 0) {
      uint64_t v26 = v25 | 2;
    }
    else {
      uint64_t v26 = v21;
    }
    uint64_t v35 = v26;
    this = (llvm::raw_ostream *)llvm::LLT::print((llvm::LLT *)&v35, a2);
    unsigned int v27 = (unsigned char *)*((void *)a2 + 4);
    if (*((unsigned char **)a2 + 3) == v27) {
      return llvm::raw_ostream::write(a2, ">", 1uLL);
    }
    *unsigned int v27 = 62;
    uint64_t v34 = *((void *)a2 + 4) + 1;
LABEL_62:
    *((void *)a2 + 4) = v34;
    return this;
  }
  if (v4) {
    BOOL v6 = (*(void *)this & 6) == 2;
  }
  else {
    BOOL v6 = 0;
  }
  if (v6)
  {
    unsigned int v28 = (unsigned char *)*((void *)a2 + 4);
    if (*((unsigned char **)a2 + 3) == v28)
    {
      llvm::raw_ostream::write(a2, "p", 1uLL);
    }
    else
    {
      *unsigned int v28 = 112;
      ++*((void *)a2 + 4);
    }
    char v29 = 35;
    if ((*(void *)v3 & 4) == 0) {
      char v29 = 19;
    }
    unint64_t v12 = (*(void *)v3 >> v29) & 0xFFFFFFLL;
    goto LABEL_49;
  }
  if (v4)
  {
    uint64_t v8 = *((void *)a2 + 3);
    uint64_t v7 = *((void *)a2 + 4);
    if ((*(void *)this & 0x8000000000000000) == 0)
    {
      if (v8 == v7)
      {
        llvm::raw_ostream::write(a2, "s", 1uLL);
      }
      else
      {
        *(unsigned char *)uint64_t v7 = 115;
        ++*((void *)a2 + 4);
      }
      unint64_t v9 = *(void *)v3;
      unint64_t v10 = (unsigned __int16)(*(void *)v3 >> 3);
      unint64_t v11 = (unsigned __int16)(*(void *)v3 >> 19);
      if ((*(void *)v3 & 2) == 0) {
        unint64_t v11 = (*(void *)v3 >> 19);
      }
      if ((v9 & 4) != 0) {
        unint64_t v10 = v11;
      }
      if (v9) {
        unint64_t v12 = (v9 >> 3);
      }
      else {
        unint64_t v12 = v10;
      }
LABEL_49:
      return sub_1CD098D14(a2, v12, 0, 0, 0);
    }
    if ((unint64_t)(v8 - v7) > 5)
    {
      *(_WORD *)(v7 + 4) = 29793;
      *(_DWORD *)uint64_t v7 = 1869375074;
      uint64_t v34 = *((void *)a2 + 4) + 6;
      goto LABEL_62;
    }
    unint64_t v31 = "bfloat";
    unint64_t v32 = a2;
    size_t v33 = 6;
  }
  else
  {
    uint64_t v30 = *((void *)a2 + 4);
    if ((unint64_t)(*((void *)a2 + 3) - v30) > 0xA)
    {
      *(_DWORD *)(v30 + 7) = 1684630625;
      *(void *)uint64_t v30 = *(void *)"LLT_invalid";
      uint64_t v34 = *((void *)a2 + 4) + 11;
      goto LABEL_62;
    }
    unint64_t v31 = "LLT_invalid";
    unint64_t v32 = a2;
    size_t v33 = 11;
  }

  return llvm::raw_ostream::write(v32, v31, v33);
}

unint64_t *llvm::LLT::LLT(unint64_t *a1, unsigned __int8 a2)
{
  unsigned __int8 v17 = a2;
  if (a2 - 15 <= 0x9B)
  {
    unsigned int v7 = sub_1CB8C32B0(&v17);
    unsigned __int16 v8 = sub_1CB8C32B0(&v17);
    int v9 = v17;
    unsigned __int8 v16 = sub_1CB8C2FBC(&v17);
    unsigned int v11 = sub_1CB87E200(&v16);
    if (v10 == 1) {
    unsigned int v12 = v9 - 120;
    }
    unsigned __int8 v13 = v17;
    if ((v17 - 15) <= 0x9Bu) {
      unsigned __int8 v13 = sub_1CB8C2FBC(&v17);
    }
    uint64_t v14 = 8 * (((unint64_t)v11 << 16) | ((unint64_t)(v12 < 0x33) << 48) | v8);
    uint64_t v15 = 4;
    if (v7 <= 1)
    {
      uint64_t v15 = 0;
      uint64_t v14 = 8 * v11;
    }
    unint64_t v5 = (v7 < 2) | ((unint64_t)(v13 == 8) << 63) | v15 | v14;
  }
  else
  {
    if (a2 - 1 > 0xB1)
    {
      *a1 = 0;
      return a1;
    }
    unsigned int v4 = sub_1CB87E200(&v17);
    if (v3 == 1) {
    unint64_t v5 = ((unint64_t)(v17 == 8) << 63) | (8 * v4) | 1;
    }
  }
  *a1 = v5;
  return a1;
}

{
  return llvm::LLT::LLT(a1, a2);
}

void llvm::ManagedStaticBase::RegisterManagedStatic(llvm::ManagedStaticBase *this, void *(*a2)(void), void (*a3)(void *))
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCFAF68, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EBCFAF68))
  {
    MEMORY[0x1D25D9910](&stru_1EBCFAF70);
    __cxa_atexit(MEMORY[0x1E4FBA230], &stru_1EBCFAF70, &dword_1CB82C000);
    __cxa_guard_release(&qword_1EBCFAF68);
  }
  std::recursive_mutex::lock(&stru_1EBCFAF70);
  if (!*(void *)this)
  {
    atomic_store((uint64_t)a2(), (unint64_t *)this);
    uint64_t v6 = qword_1EBD0C078;
    *((void *)this + 1) = a3;
    *((void *)this + 2) = v6;
    qword_1EBD0C078 = (uint64_t)this;
  }

  std::recursive_mutex::unlock(&stru_1EBCFAF70);
}

uint64_t llvm::ManagedStaticBase::destroy(llvm::ManagedStaticBase *this)
{
  size_t v2 = (uint64_t (*)(unint64_t))*((void *)this + 1);
  qword_1EBD0C078 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  unint64_t v3 = atomic_load((unint64_t *)this);
  uint64_t result = v2(v3);
  atomic_store(0, (unint64_t *)this);
  *((void *)this + 1) = 0;
  return result;
}

uint64_t llvm::llvm_shutdown(llvm *this)
{
  while (1)
  {
    uint64_t v1 = (unint64_t *)qword_1EBD0C078;
    if (!qword_1EBD0C078) {
      break;
    }
    size_t v2 = *(uint64_t (**)(unint64_t))(qword_1EBD0C078 + 8);
    qword_1EBD0C078 = *(void *)(qword_1EBD0C078 + 16);
    v1[2] = 0;
    unint64_t v3 = atomic_load(v1);
    uint64_t result = v2(v3);
    atomic_store(0, v1);
    v1[1] = 0;
  }
  return result;
}

void llvm::deallocate_buffer(llvm *this, void *a2)
{
}

uint64_t llvm::MemoryBuffer::init(uint64_t this, const char *a2, const char *a3)
{
  *(void *)(this + --*(_DWORD *)(this + 8) = a2;
  *(void *)(this + 16) = a3;
  return this;
}

void *llvm::MemoryBuffer::getMemBuffer@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  __int16 v10 = 261;
  v9[0] = a3;
  v9[1] = a4;
  unsigned int v11 = v9;
  uint64_t result = sub_1CD096174((llvm::raw_ostream *)0x18, (uint64_t)&v11);
  void *result = &unk_1F2644E70;
  result[1] = a1;
  result[2] = a1 + a2;
  *a5 = result;
  return result;
}

void *sub_1CD096174(llvm::raw_ostream *a1, uint64_t a2)
{
  v23[32] = *MEMORY[0x1E4F143B8];
  unint64_t v21 = v23;
  long long v22 = xmmword_1CD96DBF0;
  unint64_t v3 = *(void ***)a2;
  char v4 = *(unsigned char *)(*(void *)a2 + 32);
  if (*(unsigned char *)(*(void *)a2 + 33) == 1)
  {
    size_t v5 = 0;
    uint64_t v6 = 0;
    switch(*(unsigned char *)(*(void *)a2 + 32))
    {
      case 1:
        break;
      case 3:
        uint64_t v6 = (const void **)*v3;
        if (*v3) {
          size_t v5 = strlen((const char *)*v3);
        }
        else {
          size_t v5 = 0;
        }
        break;
      case 4:
        char v11 = *((unsigned char *)*v3 + 23);
        if (v11 >= 0) {
          uint64_t v6 = (const void **)*v3;
        }
        else {
          uint64_t v6 = (const void **)**v3;
        }
        if (v11 >= 0) {
          size_t v5 = v11 & 0x7F;
        }
        else {
          size_t v5 = (*v3)[1];
        }
        break;
      case 5:
        uint64_t v6 = (const void **)*v3;
        size_t v5 = (size_t)v3[1];
        break;
      default:
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    int v13 = 0;
    char v17 = 0;
    uint64_t v18 = 0;
    char v20 = &v21;
    int v19 = 0;
    unsigned int v12 = &unk_1F2646FA8;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    unsigned int v7 = llvm::Twine::printOneChild(a1, (llvm::raw_ostream *)&v12, (uint64_t)*v3, (size_t)v3[1], v4);
    llvm::Twine::printOneChild(v7, (llvm::raw_ostream *)&v12, (uint64_t)v3[2], (size_t)v3[3], *((unsigned char *)v3 + 33));
    unsigned int v12 = &unk_1F2646B98;
    if (v19 == 1 && v14) {
      MEMORY[0x1D25D9CB0](v14, 0x1000C8077774924);
    }
    uint64_t v6 = (const void **)v21;
    size_t v5 = v22;
  }
  unsigned __int16 v8 = operator new((size_t)a1 + v5 + 1);
  int v9 = (char *)a1 + (void)v8;
  if (v5) {
    memcpy(v9, v6, v5);
  }
  v9[v5] = 0;
  if (v21 != v23) {
    free(v21);
  }
  return v8;
}

void *llvm::MemoryBuffer::getMemBufferCopy@<X0>(const void *a1@<X0>, llvm::WritableMemoryBuffer *a2@<X1>, const void ***a3@<X2>, void *a4@<X8>)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t result = sub_1CD0963EC(a2, a1, a3, (uint64_t)&v7);
  if (v8) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = v7;
  }
  *a4 = v6;
  return result;
}

void *sub_1CD0963EC@<X0>(llvm::WritableMemoryBuffer *this@<X1>, const void *a2@<X0>, const void ***a3@<X2>, uint64_t a4@<X8>)
{
  llvm::WritableMemoryBuffer::getNewUninitMemBuffer(this, a3, &v9);
  uint64_t v7 = v9;
  if (v9)
  {
    uint64_t result = memcpy(*(void **)(v9 + 8), a2, (size_t)this);
    *(unsigned char *)(a4 + 16) &= ~1u;
  }
  else
  {
    uint64_t result = (void *)std::generic_category();
    *(unsigned char *)(a4 + 16) |= 1u;
    *(void *)(a4 + --*(_DWORD *)(this + 8) = result;
    uint64_t v7 = 12;
  }
  *(void *)a4 = v7;
  return result;
}

void llvm::MemoryBuffer::getFileOrSTDIN(llvm::MemoryBuffer *this@<X0>, const llvm::Twine *a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  int v5 = (int)a2;
  v24[32] = *MEMORY[0x1E4F143B8];
  long long v22 = v24;
  long long v23 = xmmword_1CD96DBF0;
  char v8 = *((unsigned char *)this + 32);
  if (*((unsigned char *)this + 33) == 1)
  {
    switch(*((unsigned char *)this + 32))
    {
      case 1:
        goto LABEL_7;
      case 3:
        uint64_t v9 = *(unsigned char **)this;
        if (!*(void *)this) {
          goto LABEL_7;
        }
        size_t v10 = strlen(*(const char **)this);
        break;
      case 4:
        char v12 = *(unsigned char *)(*(void *)this + 23);
        if (v12 >= 0) {
          uint64_t v9 = *(unsigned char **)this;
        }
        else {
          uint64_t v9 = **(unsigned char ***)this;
        }
        if (v12 >= 0) {
          size_t v10 = v12 & 0x7F;
        }
        else {
          size_t v10 = *(void *)(*(void *)this + 8);
        }
        break;
      case 5:
        uint64_t v9 = *(unsigned char **)this;
        size_t v10 = *((void *)this + 1);
        break;
      default:
        goto LABEL_11;
    }
  }
  else
  {
LABEL_11:
    int v14 = 0;
    char v18 = 0;
    uint64_t v19 = 0;
    unint64_t v21 = &v22;
    int v20 = 0;
    int v13 = &unk_1F2646FA8;
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    char v11 = llvm::Twine::printOneChild(this, (llvm::raw_ostream *)&v13, *(void *)this, *((void *)this + 1), v8);
    llvm::Twine::printOneChild(v11, (llvm::raw_ostream *)&v13, *((void *)this + 2), *((void *)this + 3), *((unsigned char *)this + 33));
    int v13 = &unk_1F2646B98;
    if (v20 == 1 && v15) {
      MEMORY[0x1D25D9CB0](v15, 0x1000C8077774924);
    }
    uint64_t v9 = v22;
    size_t v10 = v23;
  }
  if (v10 == 1 && *v9 == 45) {
    llvm::MemoryBuffer::getSTDIN(a4);
  }
  else {
LABEL_7:
  }
    sub_1CD096690((unsigned __int8 *)this, (llvm::WritableMemoryBuffer *)0xFFFFFFFFFFFFFFFFLL, 0, v5, a3, 0, a4);
  if (v22 != v24) {
    free(v22);
  }
}

char *sub_1CD096690@<X0>(unsigned __int8 *a1@<X0>, llvm::WritableMemoryBuffer *a2@<X1>, off_t a3@<X2>, int a4@<W3>, int a5@<W4>, char a6@<W5>, uint64_t a7@<X8>)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (a4) {
    int v13 = 3;
  }
  else {
    int v13 = 0;
  }
  llvm::sys::fs::openNativeFileForRead(a1, v13, 0, (uint64_t)v19);
  if (v20)
  {
    char v18 = *(char **)v19;
    uint64_t v16 = llvm::errorToErrorCode(&v18);
    *(unsigned char *)(a7 + 16) |= 1u;
    *(void *)a7 = v16;
    *(void *)(a7 + --*(_DWORD *)(this + 8) = v17;
    uint64_t result = v18;
    if (v18) {
      return (char *)(*(uint64_t (**)(char *))(*(void *)v18 + 8))(v18);
    }
  }
  else
  {
    int v14 = (llvm::sys::Process *)v19[0];
    sub_1CD097170(a2, v19[0], (const void ***)a1, (llvm::WritableMemoryBuffer *)0xFFFFFFFFFFFFFFFFLL, a3, a5, a6, a7);
    return (char *)llvm::sys::Process::SafelyCloseFileDescriptor(v14);
  }
  return result;
}

uint64_t llvm::WritableMemoryBuffer::getFile@<X0>(llvm::WritableMemoryBuffer *this@<X0>, uint64_t a2@<X8>)
{
  return sub_1CD096800(a2, (unsigned __int8 *)this, (llvm::WritableMemoryBuffer *)0xFFFFFFFFFFFFFFFFLL, 0);
}

uint64_t sub_1CD096800(uint64_t a1, unsigned __int8 *a2, llvm::WritableMemoryBuffer *a3, off_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  llvm::sys::fs::openNativeFileForRead(a2, 0, 0, (uint64_t)v34);
  if (v35)
  {
    uint64_t v16 = *(char **)v34;
    *(void *)uint64_t v34 = 0;
    unint64_t v31 = v16;
    uint64_t v17 = llvm::errorToErrorCode(&v31);
    *(unsigned char *)(a1 + 16) |= 1u;
    *(void *)a1 = v17;
    *(void *)(a1 + --*(_DWORD *)(this + 8) = v18;
    if (v31) {
      (*(void (**)(char *))(*(void *)v31 + 8))(v31);
    }
    goto LABEL_39;
  }
  char v8 = (llvm::sys::Process *)v34[0];
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCFAFB8, memory_order_acquire) & 1) == 0)
  {
    long long v22 = (llvm::sys::fs::mapped_file_region *)__cxa_guard_acquire(&qword_1EBCFAFB8);
    if (v22)
    {
      dword_1EBCFAFB0 = llvm::sys::fs::mapped_file_region::alignment(v22);
      __cxa_guard_release(&qword_1EBCFAFB8);
    }
  }
  if (a3 == (llvm::WritableMemoryBuffer *)-1)
  {
    memset(v33, 0, 44);
    int v19 = fstat((int)v8, &v36);
    uint64_t v20 = sub_1CD0E6A50(v19, &v36.st_dev, (uint64_t)v33);
    if (v20)
    {
      *(unsigned char *)(a1 + 16) |= 1u;
      *(void *)a1 = v20;
      *(void *)(a1 + --*(_DWORD *)(this + 8) = v21;
      goto LABEL_38;
    }
    if (DWORD2(v33[2]) != 2 && DWORD2(v33[2]) != 5)
    {
      sub_1CD0975D8();
      goto LABEL_38;
    }
    a3 = *(llvm::WritableMemoryBuffer **)&v33[2];
  }
  if ((unint64_t)a3 >= 0x4000 && (unint64_t)a3 >= dword_1EBCFAFB0)
  {
    std::system_category();
    *(void *)&v36.st_dev = a2;
    uint64_t v9 = (size_t *)sub_1CD096174((llvm::raw_ostream *)0x30, (uint64_t)&v36);
    size_t *v9 = (size_t)&unk_1F2644EA8;
    size_t v10 = (llvm::sys::fs::mapped_file_region *)llvm::sys::fs::mapped_file_region::alignment((llvm::sys::fs::mapped_file_region *)v9);
    char v11 = (char *)a3 + (((int)v10 - 1) & (unint64_t)a4);
    int v12 = llvm::sys::fs::mapped_file_region::alignment(v10);
    v9[3] = (size_t)v11;
    void v9[4] = 0;
    *((_DWORD *)v9 + 10) = 2;
    int v13 = (llvm::sys::fs::mapped_file_region *)llvm::sys::fs::mapped_file_region::init(v9 + 3, (int)v8, -v12 & (unint64_t)a4, 2);
    if (!v13)
    {
      size_t v14 = v9[4];
      size_t v15 = v14 + ((int)(llvm::sys::fs::mapped_file_region::alignment(v13) - 1) & (unint64_t)a4);
      v9[1] = v15;
      v9[2] = (size_t)a3 + v15;
      *(unsigned char *)(a1 + 16) &= ~1u;
      *(void *)a1 = v9;
      goto LABEL_38;
    }
    v9[3] = 0;
    void v9[4] = 0;
    *((_DWORD *)v9 + 10) = 0;
    (*(void (**)(size_t *))(*v9 + 8))(v9);
  }
  llvm::WritableMemoryBuffer::getNewUninitMemBuffer(a3, (const void ***)a2, v33);
  if (!*(void *)&v33[0])
  {
    char v29 = std::generic_category();
    *(unsigned char *)(a1 + 16) |= 1u;
    *(void *)a1 = 12;
    *(void *)(a1 + --*(_DWORD *)(this + 8) = v29;
    goto LABEL_38;
  }
  long long v23 = *(char **)(*(void *)&v33[0] + 8);
  unint64_t v24 = *(void *)(*(void *)&v33[0] + 16) - (void)v23;
  do
  {
    if (!v24) {
      goto LABEL_34;
    }
    llvm::sys::fs::readNativeFileSlice((int)v8, v23, v24, a4, (uint64_t)&v36);
    if (v36.st_ino)
    {
      uint64_t v26 = *(char **)&v36.st_dev;
      *(void *)&v36.st_dev = 0;
      unint64_t v32 = v26;
      uint64_t v27 = llvm::errorToErrorCode(&v32);
      *(unsigned char *)(a1 + 16) |= 1u;
      *(void *)a1 = v27;
      *(void *)(a1 + --*(_DWORD *)(this + 8) = v28;
      if (v32) {
        (*(void (**)(char *))(*(void *)v32 + 8))(v32);
      }
      int v25 = 1;
    }
    else
    {
      if (*(void *)&v36.st_dev)
      {
        int v25 = 0;
        v24 -= *(void *)&v36.st_dev;
        v23 += *(void *)&v36.st_dev;
        a4 += *(void *)&v36.st_dev;
        continue;
      }
      bzero(v23, v24);
      if ((v36.st_ino & 1) == 0) {
        goto LABEL_34;
      }
      int v25 = 3;
    }
    if (*(void *)&v36.st_dev) {
      (*(void (**)(void))(**(void **)&v36.st_dev + 8))(*(void *)&v36.st_dev);
    }
  }
  while (!v25);
  if (v25 == 3)
  {
LABEL_34:
    *(unsigned char *)(a1 + 16) &= ~1u;
    *(void *)a1 = *(void *)&v33[0];
    goto LABEL_38;
  }
  if (*(void *)&v33[0]) {
    (*(void (**)(void))(**(void **)&v33[0] + 8))(*(void *)&v33[0]);
  }
LABEL_38:
  uint64_t result = llvm::sys::Process::SafelyCloseFileDescriptor(v8);
  if (v35)
  {
LABEL_39:
    uint64_t result = *(void *)v34;
    if (*(void *)v34) {
      return (*(uint64_t (**)(void))(**(void **)v34 + 8))(*(void *)v34);
    }
  }
  return result;
}

uint64_t llvm::WritableMemoryBuffer::getFileSlice@<X0>(llvm::WritableMemoryBuffer *this@<X0>, const llvm::Twine *a2@<X1>, off_t a3@<X2>, uint64_t a4@<X8>)
{
  return sub_1CD096800(a4, (unsigned __int8 *)this, a2, a3);
}

void llvm::WritableMemoryBuffer::getNewUninitMemBuffer(llvm::WritableMemoryBuffer *this@<X0>, const void ***a2@<X1>, void *a3@<X8>)
{
  v29[32] = *MEMORY[0x1E4F143B8];
  uint64_t v27 = v29;
  long long v28 = xmmword_1CD96DBF0;
  char v7 = *((unsigned char *)a2 + 32);
  if (*((unsigned char *)a2 + 33) == 1)
  {
    size_t v8 = 0;
    uint64_t v9 = 0;
    switch(*((unsigned char *)a2 + 32))
    {
      case 1:
        break;
      case 3:
        uint64_t v9 = *a2;
        if (*a2) {
          size_t v8 = strlen((const char *)*a2);
        }
        else {
          size_t v8 = 0;
        }
        break;
      case 4:
        char v17 = *((unsigned char *)*a2 + 23);
        if (v17 >= 0) {
          uint64_t v9 = *a2;
        }
        else {
          uint64_t v9 = **a2;
        }
        if (v17 >= 0) {
          size_t v8 = v17 & 0x7F;
        }
        else {
          size_t v8 = (size_t)(*a2)[1];
        }
        break;
      case 5:
        uint64_t v9 = *a2;
        size_t v8 = (size_t)a2[1];
        break;
      default:
        goto LABEL_14;
    }
  }
  else
  {
LABEL_14:
    int v19 = 0;
    char v23 = 0;
    uint64_t v24 = 0;
    uint64_t v26 = &v27;
    int v25 = 0;
    uint64_t v18 = &unk_1F2646FA8;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    uint64_t v16 = llvm::Twine::printOneChild(this, (llvm::raw_ostream *)&v18, (uint64_t)*a2, (size_t)a2[1], v7);
    llvm::Twine::printOneChild(v16, (llvm::raw_ostream *)&v18, (uint64_t)a2[2], (size_t)a2[3], *((unsigned char *)a2 + 33));
    uint64_t v18 = &unk_1F2646B98;
    if (v25 == 1 && v20) {
      MEMORY[0x1D25D9CB0](v20, 0x1000C8077774924);
    }
    uint64_t v9 = v27;
    size_t v8 = v28;
  }
  unint64_t v10 = (v8 + 40) & 0xFFFFFFFFFFFFFFF0;
  char v11 = (char *)this + v10 + 1;
  if (v11 <= (char *)this)
  {
    int v13 = 0;
  }
  else
  {
    int v12 = operator new((size_t)v11, MEMORY[0x1E4FBA2D0]);
    int v13 = v12;
    if (v12)
    {
      size_t v14 = (char *)(v12 + 3);
      if (v8) {
        memcpy(v12 + 3, v9, v8);
      }
      v14[v8] = 0;
      size_t v15 = (char *)this + (void)v13 + v10;
      *size_t v15 = 0;
      void *v13 = &unk_1F2644EE0;
      v13[1] = (char *)v13 + v10;
      v13[2] = v15;
    }
  }
  *a3 = v13;
  if (v27 != v29) {
    free(v27);
  }
}

uint64_t llvm::WriteThroughMemoryBuffer::getFile@<X0>(llvm::WriteThroughMemoryBuffer *this@<X0>, const llvm::Twine *a2@<X1>, uint64_t a3@<X8>)
{
  return sub_1CD096EE0(a3, (unsigned __int8 *)this, (uint64_t)a2, (uint64_t)a2, 0);
}

uint64_t sub_1CD096EE0(uint64_t a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  llvm::sys::fs::openNativeFile(a2, 2, 3, 0, 438, (uint64_t)&v27);
  if ((v28 & 1) == 0)
  {
    int v10 = (int)v27;
    if (a4 != -1) {
      goto LABEL_4;
    }
    a4 = a3;
    if (a3 != -1) {
      goto LABEL_4;
    }
    memset(v24, 0, 44);
    int v22 = fstat((int)v27, &v26);
    uint64_t result = sub_1CD0E6A50(v22, &v26.st_dev, (uint64_t)v24);
    if (!result)
    {
      if (DWORD2(v24[2]) == 2 || DWORD2(v24[2]) == 5)
      {
        a4 = *(void *)&v24[2];
LABEL_4:
        std::system_category();
        *(void *)&v26.st_dev = a2;
        char v11 = (size_t *)sub_1CD096174((llvm::raw_ostream *)0x30, (uint64_t)&v26);
        *char v11 = (size_t)&unk_1F2644E38;
        int v12 = (llvm::sys::fs::mapped_file_region *)llvm::sys::fs::mapped_file_region::alignment((llvm::sys::fs::mapped_file_region *)v11);
        size_t v13 = (((int)v12 - 1) & a5) + a4;
        int v14 = llvm::sys::fs::mapped_file_region::alignment(v12);
        v11[3] = v13;
        v11[4] = 0;
        *((_DWORD *)v11 + 10) = 1;
        size_t v15 = (llvm::sys::fs::mapped_file_region *)llvm::sys::fs::mapped_file_region::init(v11 + 3, v10, -v14 & a5, 1);
        if (v15)
        {
          v11[3] = 0;
          v11[4] = 0;
          *((_DWORD *)v11 + 10) = 0;
          *(unsigned char *)(a1 + 16) |= 1u;
          *(void *)a1 = v15;
          *(void *)(a1 + --*(_DWORD *)(this + 8) = v16;
          return (*(uint64_t (**)(size_t *))(*v11 + 8))(v11);
        }
        else
        {
          size_t v17 = v11[4];
          uint64_t result = llvm::sys::fs::mapped_file_region::alignment(v15);
          size_t v19 = v17 + (((int)result - 1) & a5);
          v11[1] = v19;
          void v11[2] = v19 + a4;
          *(unsigned char *)(a1 + 16) &= ~1u;
          *(void *)a1 = v11;
        }
        return result;
      }
      char v23 = std::generic_category();
      uint64_t result = 22;
    }
    *(unsigned char *)(a1 + 16) |= 1u;
    *(void *)a1 = result;
    *(void *)(a1 + --*(_DWORD *)(this + 8) = v23;
    return result;
  }
  int v25 = v27;
  uint64_t v20 = llvm::errorToErrorCode(&v25);
  *(unsigned char *)(a1 + 16) |= 1u;
  *(void *)a1 = v20;
  *(void *)(a1 + --*(_DWORD *)(this + 8) = v21;
  uint64_t result = (uint64_t)v25;
  if (v25) {
    return (*(uint64_t (**)(char *))(*(void *)v25 + 8))(v25);
  }
  return result;
}

uint64_t llvm::WriteThroughMemoryBuffer::getFileSlice@<X0>(llvm::WriteThroughMemoryBuffer *this@<X0>, const llvm::Twine *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return sub_1CD096EE0(a4, (unsigned __int8 *)this, -1, (uint64_t)a2, a3);
}

void llvm::MemoryBuffer::getOpenFile(llvm::MemoryBuffer *this@<X0>, const llvm::Twine *a2@<X2>, const void ***a3@<X1>, int a4@<W3>, char a5@<W4>, uint64_t a6@<X8>)
{
}

void sub_1CD097170(llvm::WritableMemoryBuffer *this@<X3>, int a2@<W0>, const void ***a3@<X1>, llvm::WritableMemoryBuffer *a4@<X2>, off_t a5@<X4>, int a6@<W5>, char a7@<W6>, uint64_t a8@<X8>)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCFAFC0, memory_order_acquire) & 1) == 0)
  {
    int8x8_t v39 = a4;
    uint8x8_t v40 = (llvm::sys::fs::mapped_file_region *)__cxa_guard_acquire(&qword_1EBCFAFC0);
    a4 = v39;
    if (v40)
    {
      dword_1EBCFAFB4 = llvm::sys::fs::mapped_file_region::alignment(v40);
      __cxa_guard_release(&qword_1EBCFAFC0);
      a4 = v39;
    }
  }
  if (this == (llvm::WritableMemoryBuffer *)-1)
  {
    this = a4;
    if (a4 == (llvm::WritableMemoryBuffer *)-1)
    {
      long long v42 = 0u;
      memset(v43, 0, 28);
      int v32 = fstat(a2, &v44);
      uint64_t v33 = sub_1CD0E6A50(v32, &v44.st_dev, (uint64_t)&v42);
      if (v33)
      {
        *(unsigned char *)(a8 + 16) |= 1u;
        *(void *)a8 = v33;
        *(void *)(a8 + --*(_DWORD *)(this + 8) = v34;
        return;
      }
      if (LODWORD(v43[3]) != 2 && LODWORD(v43[3]) != 5)
      {
        sub_1CD0975D8();
        char v36 = *(unsigned char *)(a8 + 16);
        if (v44.st_uid)
        {
          char v37 = v36 | 1;
          uint64_t v38 = *(void *)&v44.st_dev;
          *(void *)(a8 + --*(_DWORD *)(this + 8) = v44.st_ino;
        }
        else
        {
          char v37 = v36 & 0xFE;
          uint64_t v38 = *(void *)&v44.st_dev;
        }
        *(unsigned char *)(a8 + 16) = v37;
        *(void *)a8 = v38;
        return;
      }
      this = (llvm::WritableMemoryBuffer *)v43[2];
      a4 = (llvm::WritableMemoryBuffer *)v43[2];
    }
  }
  int v15 = dword_1EBCFAFB4;
  if (a6 && (a7 & 1) != 0) {
    goto LABEL_6;
  }
  BOOL v22 = (unint64_t)this >= 0x4000 && (unint64_t)this >= dword_1EBCFAFB4;
  char v23 = !v22;
  if (v22 && a6)
  {
    if (a4 != (llvm::WritableMemoryBuffer *)-1)
    {
LABEL_32:
      if ((llvm::WritableMemoryBuffer *)((char *)this + a5) != a4 || ((unint64_t)a4 & (v15 - 1)) == 0) {
        goto LABEL_6;
      }
LABEL_37:
      std::system_category();
      *(void *)&v44.st_dev = a3;
      int v25 = (size_t *)sub_1CD096174((llvm::raw_ostream *)0x30, (uint64_t)&v44);
      *int v25 = (size_t)&unk_1F2644F18;
      stat v26 = (llvm::sys::fs::mapped_file_region *)llvm::sys::fs::mapped_file_region::alignment((llvm::sys::fs::mapped_file_region *)v25);
      uint64_t v27 = (char *)this + (((int)v26 - 1) & (unint64_t)a5);
      int v28 = llvm::sys::fs::mapped_file_region::alignment(v26);
      uint64_t v25[3] = (size_t)v27;
      v25[4] = 0;
      *((_DWORD *)v25 + 10) = 0;
      uint64_t v29 = (llvm::sys::fs::mapped_file_region *)llvm::sys::fs::mapped_file_region::init(v25 + 3, a2, -v28 & (unint64_t)a5, 0);
      if (!v29)
      {
        size_t v30 = v25[4];
        size_t v31 = v30 + ((int)(llvm::sys::fs::mapped_file_region::alignment(v29) - 1) & (unint64_t)a5);
        v25[1] = v31;
        v25[2] = (size_t)this + v31;
        *(unsigned char *)(a8 + 16) &= ~1u;
        *(void *)a8 = v25;
        return;
      }
      uint64_t v25[3] = 0;
      v25[4] = 0;
      *((_DWORD *)v25 + 10) = 0;
      (*(void (**)(size_t *))(*v25 + 8))(v25);
      goto LABEL_6;
    }
    long long v42 = 0u;
    memset(v43, 0, 28);
    int v35 = fstat(a2, &v44);
    if (!sub_1CD0E6A50(v35, &v44.st_dev, (uint64_t)&v42))
    {
      a4 = (llvm::WritableMemoryBuffer *)v43[2];
      goto LABEL_32;
    }
  }
  else if ((v23 & 1) == 0)
  {
    goto LABEL_37;
  }
LABEL_6:
  llvm::WritableMemoryBuffer::getNewUninitMemBuffer(this, a3, &v42);
  if (!(void)v42)
  {
    uint64_t v24 = std::generic_category();
    *(unsigned char *)(a8 + 16) |= 1u;
    *(void *)a8 = 12;
    *(void *)(a8 + --*(_DWORD *)(this + 8) = v24;
    return;
  }
  uint64_t v16 = *(char **)(v42 + 8);
  unint64_t v17 = *(void *)(v42 + 16) - (void)v16;
  do
  {
    if (!v17) {
      goto LABEL_21;
    }
    llvm::sys::fs::readNativeFileSlice(a2, v16, v17, a5, (uint64_t)&v44);
    if (v44.st_ino)
    {
      size_t v19 = *(char **)&v44.st_dev;
      *(void *)&v44.st_dev = 0;
      int v41 = v19;
      uint64_t v20 = llvm::errorToErrorCode(&v41);
      *(unsigned char *)(a8 + 16) |= 1u;
      *(void *)a8 = v20;
      *(void *)(a8 + --*(_DWORD *)(this + 8) = v21;
      if (v41) {
        (*(void (**)(char *))(*(void *)v41 + 8))(v41);
      }
      int v18 = 1;
    }
    else
    {
      if (*(void *)&v44.st_dev)
      {
        int v18 = 0;
        v17 -= *(void *)&v44.st_dev;
        v16 += *(void *)&v44.st_dev;
        a5 += *(void *)&v44.st_dev;
        continue;
      }
      bzero(v16, v17);
      if ((v44.st_ino & 1) == 0) {
        goto LABEL_21;
      }
      int v18 = 3;
    }
    if (*(void *)&v44.st_dev) {
      (*(void (**)(void))(**(void **)&v44.st_dev + 8))(*(void *)&v44.st_dev);
    }
  }
  while (!v18);
  if (v18 == 3)
  {
LABEL_21:
    *(unsigned char *)(a8 + 16) &= ~1u;
    *(void *)a8 = v42;
    return;
  }
  if ((void)v42) {
    (*(void (**)(void))(*(void *)v42 + 8))(v42);
  }
}

void llvm::MemoryBuffer::getOpenFileSlice(llvm::MemoryBuffer *this@<X0>, const llvm::Twine *a2@<X2>, const void ***a3@<X1>, off_t a4@<X3>, char a5@<W4>, uint64_t a6@<X8>)
{
}

void sub_1CD0975D8()
{
  int v0 = MEMORY[0x1F4188790]();
  size_t v2 = v1;
  uint64_t v4 = v3;
  v11[2048] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = v11;
  long long v10 = xmmword_1CFB2EEB0;
  llvm::sys::fs::readNativeFileToEOF(v0, &v9, 0x4000uLL, &v8);
  if (v8)
  {
    char v7 = v8;
    uint64_t v5 = llvm::errorToErrorCode(&v7);
    *(unsigned char *)(v4 + 16) |= 1u;
    *(void *)uint64_t v4 = v5;
    *(void *)(v4 + --*(_DWORD *)(this + 8) = v6;
    if (v7) {
      (*(void (**)(char *))(*(void *)v7 + 8))(v7);
    }
  }
  else
  {
    sub_1CD0963EC((llvm::WritableMemoryBuffer *)v10, v9, v2, v4);
  }
  if (v9 != v11) {
    free(v9);
  }
}

char *llvm::MemoryBuffer::getFileAsStream@<X0>(llvm::MemoryBuffer *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  llvm::sys::fs::openNativeFileForRead((unsigned __int8 *)this, 0, 0, (uint64_t)&v15);
  if (v16)
  {
    char v11 = v15;
    uint64_t v8 = llvm::errorToErrorCode(&v11);
    *(unsigned char *)(a2 + 16) |= 1u;
    *(void *)a2 = v8;
    *(void *)(a2 + --*(_DWORD *)(this + 8) = v9;
    uint64_t result = v11;
    if (v11) {
      return (char *)(*(uint64_t (**)(char *))(*(void *)v11 + 8))(v11);
    }
  }
  else
  {
    uint64_t v4 = (llvm::sys::Process *)v15;
    sub_1CD0975D8();
    char v5 = *(unsigned char *)(a2 + 16);
    if (v14)
    {
      char v6 = v5 | 1;
      uint64_t v7 = v12;
      *(void *)(a2 + --*(_DWORD *)(this + 8) = v13;
    }
    else
    {
      char v6 = v5 & 0xFE;
      uint64_t v7 = v12;
    }
    *(unsigned char *)(a2 + 16) = v6;
    *(void *)a2 = v7;
    return (char *)llvm::sys::Process::SafelyCloseFileDescriptor(v4);
  }
  return result;
}

uint64_t llvm::MemoryBuffer::getMemBufferRef@<X0>(llvm::MemoryBuffer *this@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *((void *)this + 1);
  uint64_t v4 = *((void *)this + 2) - v3;
  uint64_t result = (*(uint64_t (**)(llvm::MemoryBuffer *))(*(void *)this + 16))(this);
  *a2 = v3;
  a2[1] = v4;
  a2[2] = result;
  a2[3] = v6;
  return result;
}

void llvm::SmallVectorMemoryBuffer::~SmallVectorMemoryBuffer(void **this)
{
  *this = &unk_1F2644DC8;
  if (*((char *)this + 71) < 0) {
    operator delete(this[6]);
  }
  size_t v2 = (void **)this[3];
  if (v2 != this + 6) {
    free(v2);
  }
}

{
  uint64_t vars8;

  llvm::SmallVectorMemoryBuffer::~SmallVectorMemoryBuffer(this);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD097930(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 48);
  uint64_t v1 = a1 + 48;
  uint64_t v2 = v3;
  if (*(char *)(v1 + 23) >= 0) {
    return v1;
  }
  return v2;
}

uint64_t sub_1CD097958()
{
  return 0;
}

const char *sub_1CD097960()
{
  return "Unknown buffer";
}

void *sub_1CD097970(void *a1)
{
  *a1 = &unk_1F2644E38;
  uint64_t v2 = (void *)a1[4];
  if (v2) {
    munmap(v2, a1[3]);
  }
  return a1;
}

void sub_1CD0979C0(void *__p)
{
  *std::string __p = &unk_1F2644E38;
  uint64_t v2 = (void *)__p[4];
  if (v2) {
    munmap(v2, __p[3]);
  }

  operator delete(__p);
}

uint64_t sub_1CD097A20(uint64_t a1)
{
  uint64_t v1 = a1 + 48;
  strlen((const char *)(a1 + 48));
  return v1;
}

void *sub_1CD097A50(uint64_t a1)
{
  uint64_t result = *(void **)(a1 + 32);
  if (result) {
    return (void *)posix_madvise(result, *(void *)(a1 + 24), 4);
  }
  return result;
}

uint64_t sub_1CD097A6C()
{
  return 1;
}

uint64_t sub_1CD097A7C(uint64_t a1)
{
  uint64_t v1 = a1 + 24;
  strlen((const char *)(a1 + 24));
  return v1;
}

uint64_t sub_1CD097AAC()
{
  return 0;
}

void *sub_1CD097AB4(void *a1)
{
  *a1 = &unk_1F2644EA8;
  uint64_t v2 = (void *)a1[4];
  if (v2) {
    munmap(v2, a1[3]);
  }
  return a1;
}

void sub_1CD097B04(void *__p)
{
  *std::string __p = &unk_1F2644EA8;
  uint64_t v2 = (void *)__p[4];
  if (v2) {
    munmap(v2, __p[3]);
  }

  operator delete(__p);
}

uint64_t sub_1CD097B64(uint64_t a1)
{
  uint64_t v1 = a1 + 48;
  strlen((const char *)(a1 + 48));
  return v1;
}

void *sub_1CD097B94(uint64_t a1)
{
  uint64_t result = *(void **)(a1 + 32);
  if (result) {
    return (void *)posix_madvise(result, *(void *)(a1 + 24), 4);
  }
  return result;
}

uint64_t sub_1CD097BB0()
{
  return 1;
}

uint64_t sub_1CD097BC0(uint64_t a1)
{
  uint64_t v1 = a1 + 24;
  strlen((const char *)(a1 + 24));
  return v1;
}

uint64_t sub_1CD097BF0()
{
  return 0;
}

void *sub_1CD097BF8(void *a1)
{
  *a1 = &unk_1F2644F18;
  uint64_t v2 = (void *)a1[4];
  if (v2) {
    munmap(v2, a1[3]);
  }
  return a1;
}

void sub_1CD097C48(void *__p)
{
  *std::string __p = &unk_1F2644F18;
  uint64_t v2 = (void *)__p[4];
  if (v2) {
    munmap(v2, __p[3]);
  }

  operator delete(__p);
}

uint64_t sub_1CD097CA8(uint64_t a1)
{
  uint64_t v1 = a1 + 48;
  strlen((const char *)(a1 + 48));
  return v1;
}

void *sub_1CD097CD8(uint64_t a1)
{
  uint64_t result = *(void **)(a1 + 32);
  if (result) {
    return (void *)posix_madvise(result, *(void *)(a1 + 24), 4);
  }
  return result;
}

uint64_t sub_1CD097CF4()
{
  return 1;
}

llvm::MemoryBufferRef *llvm::MemoryBufferRef::MemoryBufferRef(llvm::MemoryBufferRef *this, const llvm::MemoryBuffer *a2)
{
  uint64_t v3 = *((void *)a2 + 1);
  uint64_t v4 = *((void *)a2 + 2) - v3;
  *(void *)this = v3;
  *((void *)this + 1) = v4;
  *((void *)this + 2) = (*(uint64_t (**)(const llvm::MemoryBuffer *))(*(void *)a2 + 16))(a2);
  *((void *)this + 3) = v5;
  return this;
}

{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  uint64_t v3 = *((void *)a2 + 1);
  uint64_t v4 = *((void *)a2 + 2) - v3;
  *(void *)this = v3;
  *((void *)this + 1) = v4;
  *((void *)this + 2) = (*(uint64_t (**)(const llvm::MemoryBuffer *))(*(void *)a2 + 16))(a2);
  *((void *)this + 3) = v5;
  return this;
}

int *llvm::MD5::body(int *a1, int *a2, uint64_t a3)
{
  int v3 = *a1;
  int v4 = a1[1];
  int v6 = a1[2];
  int v5 = a1[3];
  do
  {
    int v88 = v5;
    int v7 = *a2;
    a1[22] = *a2;
    HIDWORD(v--*(_DWORD *)(this + 8) = v3 + (v6 & v4 | v5 & ~v4) - 680876936 + v7;
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v9 = (v8 >> 25) + v4;
    int v10 = a2[1];
    a1[23] = v10;
    HIDWORD(v--*(_DWORD *)(this + 8) = v88 + v10 - 389564586 + (v4 & v9 | v6 & ~v9);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v11 = (v8 >> 20) + v9;
    int v12 = a2[2];
    a1[24] = v12;
    HIDWORD(v--*(_DWORD *)(this + 8) = v6 + v12 + 606105819 + (v9 & v11 | v4 & ~v11);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v13 = (v8 >> 15) + v11;
    int v14 = a2[3];
    a1[25] = v14;
    HIDWORD(v--*(_DWORD *)(this + 8) = v4 + v14 - 1044525330 + (v11 & v13 | v9 & ~v13);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v15 = (v8 >> 10) + v13;
    int v16 = a2[4];
    a1[26] = v16;
    HIDWORD(v--*(_DWORD *)(this + 8) = v9 + v16 - 176418897 + (v13 & v15 | v11 & ~v15);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v17 = (v8 >> 25) + v15;
    int v18 = a2[5];
    HIDWORD(v--*(_DWORD *)(this + 8) = v11 + v18 + 1200080426 + (v15 & v17 | v13 & ~v17);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    a1[27] = v18;
    int v19 = (v8 >> 20) + v17;
    int v20 = a2[6];
    a1[28] = v20;
    HIDWORD(v--*(_DWORD *)(this + 8) = v13 + v20 - 1473231341 + (v17 & v19 | v15 & ~v19);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v21 = (v8 >> 15) + v19;
    int v22 = a2[7];
    a1[29] = v22;
    HIDWORD(v--*(_DWORD *)(this + 8) = v15 + v22 - 45705983 + (v19 & v21 | v17 & ~v21);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v23 = (v8 >> 10) + v21;
    int v24 = a2[8];
    a1[30] = v24;
    HIDWORD(v--*(_DWORD *)(this + 8) = v17 + v24 + 1770035416 + (v21 & v23 | v19 & ~v23);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v25 = (v8 >> 25) + v23;
    int v26 = a2[9];
    a1[31] = v26;
    HIDWORD(v--*(_DWORD *)(this + 8) = v19 + v26 - 1958414417 + (v23 & v25 | v21 & ~v25);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v27 = (v8 >> 20) + v25;
    int v28 = a2[10];
    a1[32] = v28;
    HIDWORD(v--*(_DWORD *)(this + 8) = v21 + v28 - 42063 + (v25 & v27 | v23 & ~v27);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v29 = (v8 >> 15) + v27;
    int v30 = a2[11];
    HIDWORD(v--*(_DWORD *)(this + 8) = v23 + v30 - 1990404162 + (v27 & v29 | v25 & ~v29);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    a1[33] = v30;
    int v31 = (v8 >> 10) + v29;
    int v32 = a2[12];
    a1[34] = v32;
    HIDWORD(v--*(_DWORD *)(this + 8) = v25 + v32 + 1804603682 + (v29 & v31 | v27 & ~v31);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v33 = (v8 >> 25) + v31;
    int v34 = a2[13];
    a1[35] = v34;
    HIDWORD(v--*(_DWORD *)(this + 8) = v27 + v34 - 40341101 + (v31 & v33 | v29 & ~v33);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v35 = (v8 >> 20) + v33;
    int v36 = a2[14];
    a1[36] = v36;
    HIDWORD(v--*(_DWORD *)(this + 8) = v29 + v36 - 1502002290 + (v33 & v35 | v31 & ~v35);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v37 = (v8 >> 15) + v35;
    int v38 = a2[15];
    HIDWORD(v--*(_DWORD *)(this + 8) = v31 + v38 + 1236535329 + (v35 & v37 | v33 & ~v37);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v39 = (v8 >> 10) + v37;
    HIDWORD(v--*(_DWORD *)(this + 8) = v10 + v33 - 165796510 + (v39 & v35 | v37 & ~v35);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v40 = (v8 >> 27) + v39;
    HIDWORD(v--*(_DWORD *)(this + 8) = v20 + v35 - 1069501632 + (v40 & v37 | v39 & ~v37);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v41 = (v8 >> 23) + v40;
    HIDWORD(v--*(_DWORD *)(this + 8) = v30 + v37 + 643717713 + (v41 & v39 | v40 & ~v39);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v42 = (v8 >> 18) + v41;
    HIDWORD(v--*(_DWORD *)(this + 8) = v7 + v39 - 373897302 + (v42 & v40 | v41 & ~v40);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v43 = (v8 >> 12) + v42;
    HIDWORD(v--*(_DWORD *)(this + 8) = v18 + v40 - 701558691 + (v43 & v41 | v42 & ~v41);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v44 = (v8 >> 27) + v43;
    HIDWORD(v--*(_DWORD *)(this + 8) = v28 + v41 + 38016083 + (v44 & v42 | v43 & ~v42);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v45 = (v8 >> 23) + v44;
    HIDWORD(v--*(_DWORD *)(this + 8) = v38 + v42 - 660478335 + (v45 & v43 | v44 & ~v43);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v46 = (v8 >> 18) + v45;
    HIDWORD(v--*(_DWORD *)(this + 8) = v16 + v43 - 405537848 + (v46 & v44 | v45 & ~v44);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v47 = (v8 >> 12) + v46;
    HIDWORD(v--*(_DWORD *)(this + 8) = v26 + v44 + 568446438 + (v47 & v45 | v46 & ~v45);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v48 = (v8 >> 27) + v47;
    HIDWORD(v--*(_DWORD *)(this + 8) = v36 + v45 - 1019803690 + (v48 & v46 | v47 & ~v46);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v49 = (v8 >> 23) + v48;
    HIDWORD(v--*(_DWORD *)(this + 8) = v14 + v46 - 187363961 + (v49 & v47 | v48 & ~v47);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v50 = (v8 >> 18) + v49;
    HIDWORD(v--*(_DWORD *)(this + 8) = v24 + v47 + 1163531501 + (v50 & v48 | v49 & ~v48);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v51 = (v8 >> 12) + v50;
    HIDWORD(v--*(_DWORD *)(this + 8) = v34 + v48 - 1444681467 + (v51 & v49 | v50 & ~v49);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v52 = (v8 >> 27) + v51;
    HIDWORD(v--*(_DWORD *)(this + 8) = v12 + v49 - 51403784 + (v52 & v50 | v51 & ~v50);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v53 = (v8 >> 23) + v52;
    HIDWORD(v--*(_DWORD *)(this + 8) = v22 + v50 + 1735328473 + (v53 & v51 | v52 & ~v51);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v54 = (v8 >> 18) + v53;
    HIDWORD(v--*(_DWORD *)(this + 8) = v32 + v51 - 1926607734 + ((v54 ^ v53) & v52 ^ v53);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v55 = (v8 >> 12) + v54;
    HIDWORD(v--*(_DWORD *)(this + 8) = v18 + v52 - 378558 + (v55 ^ v54 ^ v53);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v56 = (v8 >> 28) + v55;
    HIDWORD(v--*(_DWORD *)(this + 8) = v24 + v53 - 2022574463 + (v56 ^ v55 ^ v54);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v57 = (v8 >> 21) + v56;
    HIDWORD(v--*(_DWORD *)(this + 8) = v30 + v54 + 1839030562 + (v56 ^ v55 ^ v57);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v58 = (v8 >> 16) + v57;
    HIDWORD(v--*(_DWORD *)(this + 8) = v36 + v55 - 35309556 + (v57 ^ v56 ^ v58);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v59 = (v8 >> 9) + v58;
    HIDWORD(v--*(_DWORD *)(this + 8) = v10 + v56 - 1530992060 + (v58 ^ v57 ^ v59);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v60 = (v8 >> 28) + v59;
    HIDWORD(v--*(_DWORD *)(this + 8) = v16 + v57 + 1272893353 + (v59 ^ v58 ^ v60);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v61 = (v8 >> 21) + v60;
    HIDWORD(v--*(_DWORD *)(this + 8) = v22 + v58 - 155497632 + (v60 ^ v59 ^ v61);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v62 = (v8 >> 16) + v61;
    HIDWORD(v--*(_DWORD *)(this + 8) = v28 + v59 - 1094730640 + (v61 ^ v60 ^ v62);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v63 = (v8 >> 9) + v62;
    HIDWORD(v--*(_DWORD *)(this + 8) = v34 + v60 + 681279174 + (v62 ^ v61 ^ v63);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v64 = (v8 >> 28) + v63;
    HIDWORD(v--*(_DWORD *)(this + 8) = v7 + v61 - 358537222 + (v63 ^ v62 ^ v64);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v65 = (v8 >> 21) + v64;
    HIDWORD(v--*(_DWORD *)(this + 8) = v14 + v62 - 722521979 + (v64 ^ v63 ^ v65);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v66 = (v8 >> 16) + v65;
    HIDWORD(v--*(_DWORD *)(this + 8) = v20 + v63 + 76029189 + (v65 ^ v64 ^ v66);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v67 = (v8 >> 9) + v66;
    HIDWORD(v--*(_DWORD *)(this + 8) = v26 + v64 - 640364487 + (v66 ^ v65 ^ v67);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v68 = (v8 >> 28) + v67;
    HIDWORD(v--*(_DWORD *)(this + 8) = v32 + v65 - 421815835 + (v67 ^ v66 ^ v68);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v69 = (v8 >> 21) + v68;
    HIDWORD(v--*(_DWORD *)(this + 8) = v38 + v66 + 530742520 + (v68 ^ v67 ^ v69);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v70 = (v8 >> 16) + v69;
    HIDWORD(v--*(_DWORD *)(this + 8) = v12 + v67 - 995338651 + (v69 ^ v68 ^ v70);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v71 = (v8 >> 9) + v70;
    HIDWORD(v--*(_DWORD *)(this + 8) = v7 + v68 - 198630844 + ((v71 | ~v69) ^ v70);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v72 = (v8 >> 26) + v71;
    HIDWORD(v--*(_DWORD *)(this + 8) = v22 + v69 + 1126891415 + ((v72 | ~v70) ^ v71);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v73 = (v8 >> 22) + v72;
    HIDWORD(v--*(_DWORD *)(this + 8) = v36 + v70 - 1416354905 + ((v73 | ~v71) ^ v72);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v74 = (v8 >> 17) + v73;
    HIDWORD(v--*(_DWORD *)(this + 8) = v18 + v71 - 57434055 + ((v74 | ~v72) ^ v73);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v75 = (v8 >> 11) + v74;
    HIDWORD(v--*(_DWORD *)(this + 8) = v32 + v72 + 1700485571 + ((v75 | ~v73) ^ v74);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v76 = (v8 >> 26) + v75;
    HIDWORD(v--*(_DWORD *)(this + 8) = v14 + v73 - 1894986606 + ((v76 | ~v74) ^ v75);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v77 = (v8 >> 22) + v76;
    HIDWORD(v--*(_DWORD *)(this + 8) = v28 + v74 - 1051523 + ((v77 | ~v75) ^ v76);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v78 = (v8 >> 17) + v77;
    HIDWORD(v--*(_DWORD *)(this + 8) = v10 + v75 - 2054922799 + ((v78 | ~v76) ^ v77);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v79 = (v8 >> 11) + v78;
    HIDWORD(v--*(_DWORD *)(this + 8) = v24 + v76 + 1873313359 + ((v79 | ~v77) ^ v78);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v80 = (v8 >> 26) + v79;
    HIDWORD(v--*(_DWORD *)(this + 8) = v38 + v77 - 30611744 + ((v80 | ~v78) ^ v79);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v81 = (v8 >> 22) + v80;
    HIDWORD(v--*(_DWORD *)(this + 8) = v20 + v78 - 1560198380 + ((v81 | ~v79) ^ v80);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v82 = (v8 >> 17) + v81;
    HIDWORD(v--*(_DWORD *)(this + 8) = v34 + v79 + 1309151649 + ((v82 | ~v80) ^ v81);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v83 = (v8 >> 11) + v82;
    HIDWORD(v--*(_DWORD *)(this + 8) = v16 + v80 - 145523070 + ((v83 | ~v81) ^ v82);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v84 = (v8 >> 26) + v83;
    HIDWORD(v--*(_DWORD *)(this + 8) = v30 + v81 - 1120210379 + ((v84 | ~v82) ^ v83);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    a1[37] = v38;
    int v85 = (v8 >> 22) + v84;
    HIDWORD(v--*(_DWORD *)(this + 8) = v12 + v82 + 718787259 + ((v85 | ~v83) ^ v84);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    int v86 = (v8 >> 17) + v85;
    v3 += v84;
    HIDWORD(v--*(_DWORD *)(this + 8) = v26 + v83 - 343485551 + ((v86 | ~v84) ^ v85);
    LODWORD(v--*(_DWORD *)(this + 8) = HIDWORD(v8);
    v4 += v86 + (v8 >> 11);
    v6 += v86;
    int v5 = v85 + v88;
    a2 += 16;
    a3 -= 64;
  }
  while (a3);
  *a1 = v3;
  a1[1] = v4;
  a1[2] = v6;
  a1[3] = v5;
  return a2;
}

double llvm::MD5::MD5(llvm::MD5 *this)
{
  double result = -3.59869635e230;
  *(_OWORD *)this = xmmword_1CFAC4320;
  *((void *)this + 2) = 0;
  return result;
}

{
  double result;

  double result = -3.59869635e230;
  *(_OWORD *)this = xmmword_1CFAC4320;
  *((void *)this + 2) = 0;
  return result;
}

void *llvm::MD5::update(int *a1, int *__src, size_t __n)
{
  size_t v3 = __n;
  int v4 = __src;
  int v7 = a1[4];
  unsigned int v6 = a1[5];
  unsigned int v8 = (v6 + __n) & 0x1FFFFFFF;
  if (v8 < v6) {
    ++v7;
  }
  a1[4] = v7 + (__n >> 29);
  a1[5] = v8;
  uint64_t v9 = v6 & 0x3F;
  if (v9)
  {
    uint64_t v12 = 64 - v9;
    size_t v13 = __n - (64 - v9);
    if (__n < 64 - v9)
    {
      int v10 = (char *)a1 + v9 + 24;
      goto LABEL_7;
    }
    memcpy((char *)a1 + v9 + 24, __src, 64 - v9);
    int v4 = (int *)((char *)v4 + v12);
    llvm::MD5::body(a1, a1 + 6, 64);
    size_t v3 = v13;
  }
  if (v3 >= 0x40)
  {
    int v4 = llvm::MD5::body(a1, v4, v3 & 0xFFFFFFFFFFFFFFC0);
    v3 &= 0x3Fu;
  }
  int v10 = (char *)(a1 + 6);
LABEL_7:

  return memcpy(v10, v4, v3);
}

int *llvm::MD5::final(int *a1, int *a2)
{
  uint64_t v4 = a1[5] & 0x3F;
  int v5 = a1 + 6;
  uint64_t v6 = v4 + 1;
  *((unsigned char *)a1 + v4 + 24) = 0x80;
  if ((v4 ^ 0x3FuLL) < 8)
  {
    bzero((char *)a1 + v6 + 24, v4 ^ 0x3F);
    llvm::MD5::body(a1, v5, 64);
    uint64_t v6 = 0;
    size_t v7 = 56;
  }
  else
  {
    size_t v7 = 55 - v4;
  }
  bzero((char *)a1 + v6 + 24, v7);
  int v8 = a1[4];
  int v9 = 8 * a1[5];
  a1[5] = v9;
  a1[20] = v9;
  a1[21] = v8;
  double result = llvm::MD5::body(a1, v5, 64);
  *a2 = *a1;
  a2[1] = a1[1];
  a2[2] = a1[2];
  a2[3] = a1[3];
  return result;
}

uint64_t llvm::MD5::final(llvm::MD5 *this)
{
  v2[2] = *MEMORY[0x1E4F143B8];
  llvm::MD5::final((int *)this, (int *)v2);
  return v2[0];
}

__n128 llvm::MD5::result(llvm::MD5 *this)
{
  v13[2] = *MEMORY[0x1E4F143B8];
  long long v9 = *((_OWORD *)this + 6);
  long long v10 = *((_OWORD *)this + 7);
  long long v11 = *((_OWORD *)this + 8);
  uint64_t v12 = *((void *)this + 18);
  long long v5 = *((_OWORD *)this + 2);
  long long v6 = *((_OWORD *)this + 3);
  long long v7 = *((_OWORD *)this + 4);
  long long v8 = *((_OWORD *)this + 5);
  __n128 v3 = *(__n128 *)this;
  long long v4 = *((_OWORD *)this + 1);
  llvm::MD5::final((int *)this, (int *)v13);
  *((_OWORD *)this + 6) = v9;
  *((_OWORD *)this + 7) = v10;
  *((_OWORD *)this + --*(_DWORD *)(this + 8) = v11;
  *((void *)this + 1--*(_DWORD *)(this + 8) = v12;
  *((_OWORD *)this + 2) = v5;
  *((_OWORD *)this + 3) = v6;
  *((_OWORD *)this + 4) = v7;
  *((_OWORD *)this + 5) = v8;
  __n128 result = v3;
  *(__n128 *)this = v3;
  *((_OWORD *)this + 1) = v4;
  return result;
}

uint64_t llvm::MD5::stringifyResult(unsigned __int8 *a1, void *a2)
{
  uint64_t result = sub_1CC223914((uint64_t)a2, 0x20uLL);
  for (uint64_t i = 0; i != 32; i += 2)
  {
    unsigned int v6 = *a1++;
    *(unsigned char *)(*a2 + i) = a0123456789abcd_6[(unint64_t)v6 >> 4] | 0x20;
    *(unsigned char *)(*a2 + i + 1) = a0123456789abcd_6[v6 & 0xF] | 0x20;
  }
  return result;
}

_UNKNOWN **llvm::MSP430Attrs::getMSP430AttributeTags(llvm::MSP430Attrs *this)
{
  return &off_1E6855808;
}

uint64_t llvm::MSP430AttributeParser::parseISA@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  return llvm::ELFAttributeParser::parseStringAttribute(a1, "ISA", a2, (uint64_t)off_1EA6187B8, 3uLL, a3);
}

uint64_t llvm::MSP430AttributeParser::parseCodeModel@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  return llvm::ELFAttributeParser::parseStringAttribute(a1, "Code Model", a2, (uint64_t)off_1EA6187D0, 3uLL, a3);
}

uint64_t llvm::MSP430AttributeParser::parseDataModel@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  return llvm::ELFAttributeParser::parseStringAttribute(a1, "Data Model", a2, (uint64_t)off_1EA6187E8, 4uLL, a3);
}

uint64_t llvm::MSP430AttributeParser::parseEnumSize@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  return llvm::ELFAttributeParser::parseStringAttribute(a1, "Enum Size", a2, (uint64_t)off_1EA618808, 4uLL, a3);
}

uint64_t llvm::MSP430AttributeParser::handler@<X0>(uint64_t this@<X0>, BOOL *a2@<X2>, uint64_t a3@<X1>, void *a4@<X8>)
{
  uint64_t v6 = 0;
  *a2 = 0;
  while (*(_DWORD *)((char *)&llvm::MSP430AttributeParser::DisplayRoutines + v6) != a3)
  {
    v6 += 24;
    if (v6 == 96) {
      goto LABEL_9;
    }
  }
  long long v7 = (char *)&llvm::MSP430AttributeParser::DisplayRoutines + v6;
  long long v9 = (uint64_t (*)(void *))*((void *)v7 + 1);
  uint64_t v8 = *((void *)v7 + 2);
  long long v10 = (void *)(this + (v8 >> 1));
  if (v8) {
    long long v9 = *(uint64_t (**)(void *))(*v10 + v9);
  }
  this = v9(v10);
  if (!*a4)
  {
    *a2 = 1;
LABEL_9:
    *a4 = 0;
  }
  return this;
}

void sub_1CD098CD4(void *a1)
{
  sub_1CD6D6C64(a1);

  JUMPOUT(0x1D25D9CE0);
}

llvm::raw_ostream *llvm::write_integer(llvm::raw_ostream *a1, unint64_t a2, size_t a3, int a4)
{
  return sub_1CD098D14(a1, a2, a3, a4, 0);
}

{
  int v4;

  if ((a2 & 0x8000000000000000) != 0)
  {
    a2 = -(uint64_t)a2;
    long long v4 = 1;
  }
  else
  {
    long long v4 = 0;
  }
  return sub_1CD098D14(a1, a2, a3, a4, v4);
}

{
  return sub_1CD098D14(a1, a2, a3, a4, 0);
}

{
  int v4;

  if ((a2 & 0x8000000000000000) != 0)
  {
    a2 = -(uint64_t)a2;
    long long v4 = 1;
  }
  else
  {
    long long v4 = 0;
  }
  return sub_1CD098D14(a1, a2, a3, a4, v4);
}

llvm::raw_ostream *sub_1CD098D14(llvm::raw_ostream *a1, unint64_t a2, size_t a3, int a4, int a5)
{
  v18[1] = *MEMORY[0x1E4F143B8];
  if (HIDWORD(a2))
  {
    uint64_t v8 = 0;
    *(void *)&long long v9 = 0x3030303030303030;
    *((void *)&v9 + 1) = 0x3030303030303030;
    v17[6] = v9;
    v17[7] = v9;
    v17[4] = v9;
    v17[5] = v9;
    v17[2] = v9;
    void v17[3] = v9;
    uint64_t v10 = 127;
    v17[0] = v9;
    v17[1] = v9;
    do
    {
      *((unsigned char *)v17 + v10) = (a2 % 0xA) | 0x30;
      v8 += 0x100000000;
      --v10;
      BOOL v11 = a2 > 9;
      a2 /= 0xAuLL;
    }
    while (v11);
    size_t v12 = v8 >> 32;
    if (a5)
    {
      size_t v13 = (unsigned char *)*((void *)a1 + 4);
      if ((unint64_t)v13 >= *((void *)a1 + 3))
      {
        a1 = llvm::raw_ostream::write(a1, 45);
      }
      else
      {
        *((void *)a1 + 4) = v13 + 1;
        unsigned char *v13 = 45;
      }
    }
    if (a4 != 1 && v12 < a3)
    {
      size_t v14 = v12;
      do
      {
        int v15 = (unsigned char *)*((void *)a1 + 4);
        if ((unint64_t)v15 >= *((void *)a1 + 3))
        {
          a1 = llvm::raw_ostream::write(a1, 48);
        }
        else
        {
          *((void *)a1 + 4) = v15 + 1;
          *int v15 = 48;
        }
        ++v14;
      }
      while (v14 < a3);
    }
    int v16 = (char *)v18 - v12;
    if (a4 == 1) {
      return sub_1CD09914C(a1, v16, v12);
    }
    else {
      return llvm::raw_ostream::write(a1, v16, v12);
    }
  }
  else
  {
    return sub_1CD098FF4(a1, a2, a3, a4, a5);
  }
}

llvm::raw_ostream *llvm::write_hex(llvm::raw_ostream *a1, unint64_t a2, int a3, unint64_t a4, char a5)
{
  LODWORD(v5) = 128;
  if (a4 < 0x80) {
    LODWORD(v5) = a4;
  }
  unsigned int v6 = (67 - __clz(a2)) >> 2;
  if (!a5) {
    LODWORD(v5) = 0;
  }
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (v6 <= 1) {
    unsigned int v6 = 1;
  }
  *(void *)&long long v7 = 0x3030303030303030;
  *((void *)&v7 + 1) = 0x3030303030303030;
  v12[6] = v7;
  v12[7] = v7;
  void v12[4] = v7;
  v12[5] = v7;
  unsigned int v8 = v6 + 2 * ((a3 & 0xFFFFFFFE) == 2);
  v12[2] = v7;
  v12[3] = v7;
  if (v5 <= v8) {
    size_t v5 = v8;
  }
  else {
    size_t v5 = v5;
  }
  v12[0] = v7;
  v12[1] = v7;
  if ((a3 & 0xFFFFFFFE) == 2) {
    BYTE1(v12[0]) = 120;
  }
  if (a2)
  {
    long long v9 = (char *)&v12[-1] + v5 + 15;
    do
    {
      *v9-- = a0123456789abcd_6[a2 & 0xF] | (32 * ((a3 & 0xFFFFFFFD) != 0));
      BOOL v10 = a2 > 0xF;
      a2 >>= 4;
    }
    while (v10);
  }
  return llvm::raw_ostream::write(a1, (const char *)v12, v5);
}

llvm::raw_ostream *sub_1CD098FF4(llvm::raw_ostream *a1, unsigned int a2, size_t a3, int a4, int a5)
{
  uint64_t v7 = 0;
  v18[1] = *MEMORY[0x1E4F143B8];
  *(void *)&long long v8 = 0x3030303030303030;
  *((void *)&v8 + 1) = 0x3030303030303030;
  v17[6] = v8;
  v17[7] = v8;
  v17[4] = v8;
  v17[5] = v8;
  v17[2] = v8;
  void v17[3] = v8;
  v17[0] = v8;
  v17[1] = v8;
  uint64_t v9 = 127;
  do
  {
    *((unsigned char *)v17 + v9) = (a2 % 0xA) | 0x30;
    v7 += 0x100000000;
    --v9;
    BOOL v10 = a2 > 9;
    a2 /= 0xAu;
  }
  while (v10);
  size_t v11 = v7 >> 32;
  if (a5)
  {
    size_t v12 = (unsigned char *)*((void *)a1 + 4);
    if ((unint64_t)v12 >= *((void *)a1 + 3))
    {
      a1 = llvm::raw_ostream::write(a1, 45);
    }
    else
    {
      *((void *)a1 + 4) = v12 + 1;
      unsigned char *v12 = 45;
    }
  }
  if (a4 != 1 && v11 < a3)
  {
    size_t v13 = v11;
    do
    {
      size_t v14 = (unsigned char *)*((void *)a1 + 4);
      if ((unint64_t)v14 >= *((void *)a1 + 3))
      {
        a1 = llvm::raw_ostream::write(a1, 48);
      }
      else
      {
        *((void *)a1 + 4) = v14 + 1;
        *size_t v14 = 48;
      }
      ++v13;
    }
    while (v13 < a3);
  }
  int v15 = (char *)v18 - v11;
  if (a4 == 1) {
    return sub_1CD09914C(a1, v15, v11);
  }
  else {
    return llvm::raw_ostream::write(a1, v15, v11);
  }
}

llvm::raw_ostream *sub_1CD09914C(llvm::raw_ostream *a1, const char *a2, size_t a3)
{
  size_t v3 = a3;
  unint64_t v5 = (a3 - 1) / 3;
  unint64_t v6 = (a3 - 1) % 3;
  size_t v7 = a3 - (v6 + 1);
  if (a3 >= v6 + 1) {
    a3 = v6 + 1;
  }
  uint64_t result = llvm::raw_ostream::write(a1, a2, a3);
  if (v7)
  {
    uint64_t v9 = -3 * v5;
    BOOL v10 = &a2[v3];
    do
    {
      size_t v11 = (unsigned char *)*((void *)result + 4);
      if ((unint64_t)v11 >= *((void *)result + 3))
      {
        uint64_t result = llvm::raw_ostream::write(result, 44);
      }
      else
      {
        *((void *)result + 4) = v11 + 1;
        *size_t v11 = 44;
      }
      uint64_t result = llvm::raw_ostream::write(result, &v10[v9], 3uLL);
      v9 += 3;
    }
    while (v9);
  }
  return result;
}

const std::error_category *llvm::Obfuscator::lookupForwardMap@<X0>(unsigned __int8 *__s1@<X1>, std::error_category_vtbl *__n@<X2>, uint64_t a3@<X0>, uint64_t a4@<X8>)
{
  uint64_t v31 = *(unsigned int *)(a3 + 112);
  if (!v31) {
    goto LABEL_26;
  }
  int v7 = 0;
  if (__n)
  {
    size_t v8 = (size_t)__n;
    uint64_t v9 = __s1;
    do
    {
      int v10 = *v9++;
      int v7 = 33 * v7 + v10;
      --v8;
    }
    while (v8);
  }
  unsigned int v11 = v31 - 1;
  uint64_t v12 = *(void *)(a3 + 104);
  uint64_t v13 = v12 + 8 * v31 + 8;
  int v14 = 1;
  int v15 = v7;
  while (1)
  {
    uint64_t v16 = v15 & v11;
    int v17 = *(std::error_category_vtbl ***)(v12 + 8 * v16);
    if (v17 != (std::error_category_vtbl **)-8)
    {
      if (!v17) {
        goto LABEL_26;
      }
      if (*(_DWORD *)(v13 + 4 * v16) == v7 && __n == *v17)
      {
        uint64_t v18 = *(unsigned int *)(a3 + 124);
        if (!__n || !memcmp(__s1, (char *)v17 + v18, (size_t)__n)) {
          break;
        }
      }
    }
    int v15 = v14 + v16;
    ++v14;
  }
  if (v16 == -1 || (int)v16 == v31)
  {
LABEL_26:
    uint64_t result = std::generic_category();
    uint64_t v27 = a4;
    *(unsigned char *)(a4 + 16) |= 1u;
    uint64_t v28 = 1;
  }
  else
  {
    int v19 = 0;
    if (__n)
    {
      size_t v20 = (size_t)__n;
      int v21 = __s1;
      do
      {
        int v22 = *v21++;
        int v19 = 33 * v19 + v22;
        --v20;
      }
      while (v20);
    }
    int v23 = 1;
    int v24 = v19;
    while (1)
    {
      uint64_t v25 = v24 & v11;
      uint64_t result = *(const std::error_category **)(v12 + 8 * v25);
      if (result != (const std::error_category *)-8)
      {
        if (!result)
        {
          uint64_t v28 = 0;
          uint64_t v27 = a4;
          goto LABEL_29;
        }
        if (*(_DWORD *)(v13 + 4 * v25) == v19
          && __n == result->__vftable
          && (!__n || !memcmp(__s1, (char *)result + v18, (size_t)__n)))
        {
          break;
        }
      }
      int v24 = v23 + v25;
      ++v23;
    }
    uint64_t v27 = a4;
    if (v25 == -1 || (int)v25 == v31)
    {
      uint64_t result = 0;
      uint64_t v28 = 0;
    }
    else
    {
      uint64_t v29 = *(void *)(v12 + 8 * (int)v25);
      uint64_t v28 = *(void *)(v29 + 8);
      uint64_t result = *(const std::error_category **)(v29 + 16);
    }
LABEL_29:
    *(unsigned char *)(v27 + 16) &= ~1u;
  }
  *(void *)uint64_t v27 = v28;
  *(void *)(v27 + --*(_DWORD *)(this + 8) = result;
  return result;
}

const char *llvm::Rot13Obfuscator::obfuscateImpl(uint64_t a1, unsigned __int8 *a2, size_t a3, char a4)
{
  size_t v8 = (const char *)sub_1CB906F34((uint64_t *)(a1 + 8), (a3 + 1), 0);
  uint64_t v9 = v8;
  v8[a3] = 0;
  if (a3)
  {
    uint64_t v10 = 0;
    do
    {
      int v11 = (char)a2[v10];
      if ((v11 - 65) > 0x19)
      {
        LOBYTE(v12) = a2[v10];
        if (v12 - 97 <= 0x19) {
          unsigned int v12 = (v11 - 84) % 0x1Au + 97;
        }
      }
      else
      {
        unsigned int v12 = (v11 - 52) % 0x1Au + 65;
      }
      v8[v10++] = v12;
    }
    while (a3 > v10);
  }
  if (a4)
  {
    *(void *)&long long v14 = v8;
    *((void *)&v14 + 1) = strlen(v8);
    sub_1CD099B48(a1 + 168, a2, a3, &v14);
  }
  strlen(v9);
  return v9;
}

const std::error_category *llvm::Rot13Obfuscator::lookupImpl@<X0>(unsigned __int8 *__s1@<X1>, std::error_category_vtbl *__n@<X2>, uint64_t a3@<X0>, uint64_t a4@<X8>)
{
  uint64_t v31 = *(unsigned int *)(a3 + 176);
  if (!v31) {
    goto LABEL_26;
  }
  int v7 = 0;
  if (__n)
  {
    size_t v8 = (size_t)__n;
    uint64_t v9 = __s1;
    do
    {
      int v10 = *v9++;
      int v7 = 33 * v7 + v10;
      --v8;
    }
    while (v8);
  }
  unsigned int v11 = v31 - 1;
  uint64_t v12 = *(void *)(a3 + 168);
  uint64_t v13 = v12 + 8 * v31 + 8;
  int v14 = 1;
  int v15 = v7;
  while (1)
  {
    uint64_t v16 = v15 & v11;
    int v17 = *(std::error_category_vtbl ***)(v12 + 8 * v16);
    if (v17 != (std::error_category_vtbl **)-8)
    {
      if (!v17) {
        goto LABEL_26;
      }
      if (*(_DWORD *)(v13 + 4 * v16) == v7 && __n == *v17)
      {
        uint64_t v18 = *(unsigned int *)(a3 + 188);
        if (!__n || !memcmp(__s1, (char *)v17 + v18, (size_t)__n)) {
          break;
        }
      }
    }
    int v15 = v14 + v16;
    ++v14;
  }
  if (v16 == -1 || (int)v16 == v31)
  {
LABEL_26:
    uint64_t result = std::generic_category();
    uint64_t v27 = a4;
    *(unsigned char *)(a4 + 16) |= 1u;
    uint64_t v28 = 1;
  }
  else
  {
    int v19 = 0;
    if (__n)
    {
      size_t v20 = (size_t)__n;
      int v21 = __s1;
      do
      {
        int v22 = *v21++;
        int v19 = 33 * v19 + v22;
        --v20;
      }
      while (v20);
    }
    int v23 = 1;
    int v24 = v19;
    while (1)
    {
      uint64_t v25 = v24 & v11;
      uint64_t result = *(const std::error_category **)(v12 + 8 * v25);
      if (result != (const std::error_category *)-8)
      {
        if (!result)
        {
          uint64_t v28 = 0;
          uint64_t v27 = a4;
          goto LABEL_29;
        }
        if (*(_DWORD *)(v13 + 4 * v25) == v19
          && __n == result->__vftable
          && (!__n || !memcmp(__s1, (char *)result + v18, (size_t)__n)))
        {
          break;
        }
      }
      int v24 = v23 + v25;
      ++v23;
    }
    uint64_t v27 = a4;
    if (v25 == -1 || (int)v25 == v31)
    {
      uint64_t result = 0;
      uint64_t v28 = 0;
    }
    else
    {
      uint64_t v29 = *(void *)(v12 + 8 * (int)v25);
      uint64_t v28 = *(void *)(v29 + 8);
      uint64_t result = *(const std::error_category **)(v29 + 16);
    }
LABEL_29:
    *(unsigned char *)(v27 + 16) &= ~1u;
  }
  *(void *)uint64_t v27 = v28;
  *(void *)(v27 + --*(_DWORD *)(this + 8) = result;
  return result;
}

llvm::raw_ostream *llvm::Rot13Obfuscator::writeReverseMapImpl(llvm::raw_ostream *this, llvm::raw_ostream *a2)
{
  uint64_t v3 = *((unsigned int *)this + 44);
  if (v3)
  {
    for (uint64_t i = (size_t **)*((void *)this + 21); !*i || *i + 1 == 0; ++i)
      ;
  }
  else
  {
    uint64_t i = (size_t **)*((void *)this + 21);
  }
  uint64_t v6 = *((void *)this + 21) + 8 * v3;
  if (i != (size_t **)v6)
  {
    int v7 = *i;
    do
    {
      size_t v8 = v7 + 3;
      size_t v9 = *v7;
      int v10 = (unsigned char *)*((void *)a2 + 4);
      if (*v7 <= *((void *)a2 + 3) - (void)v10)
      {
        if (v9)
        {
          memcpy(v10, v8, *v7);
          int v10 = (unsigned char *)(*((void *)a2 + 4) + v9);
          *((void *)a2 + 4) = v10;
        }
      }
      else
      {
        llvm::raw_ostream::write(a2, (const char *)v8, *v7);
        int v10 = (unsigned char *)*((void *)a2 + 4);
      }
      if (*((unsigned char **)a2 + 3) == v10)
      {
        llvm::raw_ostream::write(a2, ":", 1uLL);
        this = (llvm::raw_ostream *)*((void *)a2 + 4);
      }
      else
      {
        *int v10 = 58;
        this = (llvm::raw_ostream *)(*((void *)a2 + 4) + 1);
        *((void *)a2 + 4) = this;
      }
      unsigned int v11 = (const void *)v7[1];
      unint64_t v12 = v7[2];
      if (v12 <= *((void *)a2 + 3) - (void)this)
      {
        if (v12)
        {
          memcpy(this, v11, v7[2]);
          this = (llvm::raw_ostream *)(*((void *)a2 + 4) + v12);
          *((void *)a2 + 4) = this;
        }
      }
      else
      {
        llvm::raw_ostream::write(a2, (const char *)v11, v7[2]);
        this = (llvm::raw_ostream *)*((void *)a2 + 4);
      }
      if (*((llvm::raw_ostream **)a2 + 3) == this)
      {
        this = llvm::raw_ostream::write(a2, "\n", 1uLL);
      }
      else
      {
        *(unsigned char *)this = 10;
        ++*((void *)a2 + 4);
      }
      do
      {
        uint64_t v13 = i[1];
        ++i;
        int v7 = v13;
        if (v13) {
          BOOL v14 = v7 + 1 == 0;
        }
        else {
          BOOL v14 = 1;
        }
      }
      while (v14);
    }
    while (i != (size_t **)v6);
  }
  return this;
}

uint64_t llvm::Rot13Obfuscator::readReverseMapImpl(uint64_t this, llvm::MemoryBuffer *a2)
{
  uint64_t v3 = *((void *)a2 + 1);
  uint64_t v2 = *((void *)a2 + 2);
  unint64_t v4 = v2 - v3;
  uint64_t v29 = v3;
  unint64_t v30 = v2 - v3;
  if (v2 != v3)
  {
    uint64_t v5 = this + 168;
    uint64_t v6 = (uint64_t *)(this + 8);
    do
    {
      char v31 = 10;
      unint64_t v7 = llvm::StringRef::find(&v29, &v31, 1uLL, 0);
      if (v4 >= v7) {
        unint64_t v8 = v7;
      }
      else {
        unint64_t v8 = v4;
      }
      if (v4 >= v7 + 1) {
        unint64_t v9 = v7 + 1;
      }
      else {
        unint64_t v9 = v4;
      }
      uint64_t v10 = v3 + v9;
      unint64_t v11 = v4 - v9;
      unint64_t v12 = (char *)v3;
      if (v7 == -1) {
        unint64_t v13 = v4;
      }
      else {
        unint64_t v13 = v8;
      }
      if (v7 == -1) {
        uint64_t v3 = 0;
      }
      else {
        uint64_t v3 = v10;
      }
      v28[0] = (uint64_t)v12;
      v28[1] = v13;
      if (v7 == -1) {
        unint64_t v4 = 0;
      }
      else {
        unint64_t v4 = v11;
      }
      uint64_t v29 = v3;
      unint64_t v30 = v4;
      char v31 = 58;
      unint64_t v14 = llvm::StringRef::find(v28, &v31, 1uLL, 0);
      if (v13 >= v14) {
        size_t v15 = v14;
      }
      else {
        size_t v15 = v13;
      }
      if (v13 >= v14 + 1) {
        unint64_t v16 = v14 + 1;
      }
      else {
        unint64_t v16 = v13;
      }
      int v17 = &v12[v16];
      size_t v18 = v13 - v16;
      if (v14 == -1) {
        size_t v19 = 0;
      }
      else {
        size_t v19 = v18;
      }
      if (v14 == -1) {
        size_t v20 = 0;
      }
      else {
        size_t v20 = v17;
      }
      if (v14 == -1) {
        size_t v21 = v13;
      }
      else {
        size_t v21 = v15;
      }
      int v22 = (char *)sub_1CB906F34(v6, (v19 + 1), 0);
      int v23 = v22;
      v22[v19] = 0;
      if (v19) {
        memmove(v22, v20, v19);
      }
      int v24 = (char *)sub_1CB906F34(v6, (v21 + 1), 0);
      uint64_t v25 = v24;
      v24[v21] = 0;
      if (v21) {
        memmove(v24, v12, v21);
      }
      size_t v26 = strlen(v23);
      *(void *)&long long v27 = v25;
      *((void *)&v27 + 1) = strlen(v25);
      this = sub_1CD099B48(v5, (unsigned __int8 *)v23, v26, &v27);
    }
    while (v4);
  }
  return this;
}

void sub_1CD099A14(uint64_t a1)
{
  sub_1CD099A4C(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD099A4C(uint64_t a1)
{
  *(void *)a1 = &unk_1F2644FD8;
  free(*(void **)(a1 + 168));
  *(void *)a1 = &unk_1F2610720;
  free(*(void **)(a1 + 136));
  free(*(void **)(a1 + 104));
  uint64_t v2 = *(unsigned int *)(a1 + 32);
  if (v2)
  {
    uint64_t v3 = *(uint64_t **)(a1 + 24);
    uint64_t v4 = 8 * v2;
    do
    {
      uint64_t v5 = *v3++;
      MEMORY[0x1D25D9CD0](v5, 8);
      v4 -= 8;
    }
    while (v4);
  }
  uint64_t v6 = *(uint64_t **)(a1 + 72);
  uint64_t v7 = *(unsigned int *)(a1 + 80);
  if (v7)
  {
    uint64_t v10 = 16 * v7;
    do
    {
      uint64_t v11 = *v6;
      v6 += 2;
      MEMORY[0x1D25D9CD0](v11, 8);
      v10 -= 16;
    }
    while (v10);
    uint64_t v6 = *(uint64_t **)(a1 + 72);
  }
  if (v6 != (uint64_t *)(a1 + 88)) {
    free(v6);
  }
  unint64_t v8 = *(void **)(a1 + 24);
  if (v8 != (void *)(a1 + 40)) {
    free(v8);
  }
  return a1;
}

uint64_t sub_1CD099B48(uint64_t result, unsigned __int8 *a2, size_t __n, _OWORD *a4)
{
  uint64_t v6 = result;
  unsigned int v7 = *(_DWORD *)(result + 8);
  if (!v7)
  {
    *(_DWORD *)(result + 12) = 0;
    *(_DWORD *)(result + 16) = 0;
    uint64_t result = (uint64_t)malloc_type_calloc(0x11uLL, 0xCuLL, 0x6D9A4F0CuLL);
    if (!result) {
      llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
    }
    *(void *)(result + 12--*(_DWORD *)(this + 8) = 2;
    *(void *)uint64_t v6 = result;
    unsigned int v7 = 16;
    *(_DWORD *)(v6 + --*(_DWORD *)(this + 8) = 16;
  }
  long long v27 = a4;
  int v8 = 0;
  if (__n)
  {
    size_t v9 = __n;
    uint64_t v10 = a2;
    do
    {
      int v11 = *v10++;
      int v8 = 33 * v8 + v11;
      --v9;
    }
    while (v9);
  }
  uint64_t v12 = *(void *)v6;
  unsigned int v13 = v7 - 1;
  uint64_t v14 = *(void *)v6 + 8 * v7 + 8;
  int v15 = -1;
  int v16 = 1;
  int v17 = v8;
  while (1)
  {
    uint64_t v18 = v17 & v13;
    size_t v19 = *(void **)(v12 + 8 * v18);
    if (!v19) {
      break;
    }
    if (v19 == (void *)-8)
    {
      if (v15 == -1) {
        int v15 = v17 & v13;
      }
    }
    else if (*(_DWORD *)(v14 + 4 * v18) == v8 && __n == *v19)
    {
      if (!__n) {
        goto LABEL_20;
      }
      uint64_t result = memcmp(a2, (char *)v19 + *(unsigned int *)(v6 + 20), __n);
      if (!result) {
        goto LABEL_20;
      }
    }
    int v17 = v16 + v18;
    ++v16;
  }
  uint64_t v20 = v15;
  if (v15 == -1)
  {
    uint64_t v20 = v18;
    uint64_t v18 = v18;
  }
  else
  {
    uint64_t v18 = v15;
  }
  *(_DWORD *)(v14 + 4 * v20) = v8;
  size_t v19 = *(void **)(v12 + 8 * v18);
LABEL_20:
  if (v19 == (void *)-8)
  {
    --*(_DWORD *)(v6 + 16);
  }
  else if (v19)
  {
    return result;
  }
  uint64_t v21 = sub_1CB906F34(*(uint64_t **)(v6 + 24), __n + 25, 3);
  uint64_t v22 = v21;
  uint64_t v23 = v21 + 24;
  if (__n) {
    memcpy((void *)(v21 + 24), a2, __n);
  }
  *(unsigned char *)(v23 + __n) = 0;
  *(void *)uint64_t v22 = __n;
  *(_OWORD *)(v22 + --*(_DWORD *)(this + 8) = *v27;
  int v24 = *(_DWORD *)(v6 + 12);
  *(void *)(v12 + 8 * v1--*(_DWORD *)(this + 8) = v22;
  *(_DWORD *)(v6 + 12) = v24 + 1;
  uint64_t result = llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)v6, v18);
  for (uint64_t i = (void *)(*(void *)v6 + 8 * result); !*i || *i == -8; ++i)
    ;
  return result;
}

void *sub_1CD099D58(void **a1, const char *a2)
{
  uint64_t v3 = (char *)*a1;
  uint64_t v2 = (char *)a1[1];
  uint64_t v4 = (v2 - (unsigned char *)*a1) >> 4;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 60) {
    abort();
  }
  uint64_t v8 = (unsigned char *)a1[2] - v3;
  if (v8 >> 3 > v5) {
    unint64_t v5 = v8 >> 3;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v9 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  if (v9)
  {
    if (v9 >> 60) {
      sub_1CB833614();
    }
    uint64_t v10 = (char *)operator new(16 * v9);
  }
  else
  {
    uint64_t v10 = 0;
  }
  int v11 = (const char **)&v10[16 * v4];
  *int v11 = a2;
  if (a2) {
    size_t v12 = strlen(a2);
  }
  else {
    size_t v12 = 0;
  }
  v11[1] = (const char *)v12;
  unsigned int v13 = v11 + 2;
  if (v2 != v3)
  {
    do
    {
      *((_OWORD *)v11 - 1) = *((_OWORD *)v2 - 1);
      v11 -= 2;
      v2 -= 16;
    }
    while (v2 != v3);
    uint64_t v2 = (char *)*a1;
  }
  *a1 = v11;
  a1[1] = v13;
  a1[2] = &v10[16 * v9];
  if (v2) {
    operator delete(v2);
  }
  return v13;
}

unint64_t llvm::performOptimizedStructLayout(unint64_t *a1, unint64_t a2)
{
  v45[24] = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 0;
  }
  unint64_t v4 = 0;
  unsigned __int8 v5 = 0;
  uint64_t v6 = (char *)&a1[5 * a2];
  uint64_t v7 = 40 * a2;
  uint64_t v8 = 40 * a2;
  while (a1[v4 / 8] != -1)
  {
    if (v5 <= LOBYTE(a1[v4 / 8 + 4])) {
      unsigned __int8 v5 = a1[v4 / 8 + 4];
    }
    v8 -= 40;
    v4 += 40;
    if (v7 == v4) {
      return a1[5 * a2 - 4] + a1[5 * a2 - 5];
    }
  }
  uint64_t v10 = &a1[v4 / 8];
  if (v7 != v4)
  {
    unint64_t v11 = 0;
    uint64_t v12 = 0;
    do
    {
      unsigned int v13 = (char *)&a1[v11 / 8 + v4 / 8];
      *((void *)v13 + 3) = v12++;
      unsigned int v14 = v13[32];
      if (v5 <= v14) {
        unsigned __int8 v5 = v14;
      }
      v11 += 40;
    }
    while (v8 != v11);
  }
  if (v8 >= 80) {
    qsort(&a1[v4 / 8], v8 / 0x28uLL, 0x28uLL, (int (__cdecl *)(const void *, const void *))sub_1CD09A4F4);
  }
  unint64_t v9 = 0;
  if (v4)
  {
    int v15 = a1;
    while (v9 == *v15)
    {
      v9 += v15[1];
      v15 += 5;
      if (v10 == v15) {
        goto LABEL_20;
      }
    }
  }
  else
  {
LABEL_20:
    if (v7 == v4) {
      return v9;
    }
    for (uint64_t i = (char *)&a1[v4 / 8]; v9 == ((v9 + (1 << i[32]) - 1) & -(1 << i[32])); i += 40)
    {
      *(void *)uint64_t i = v9;
      v9 += *((void *)i + 1);
      v8 -= 40;
      if (!v8) {
        return v9;
      }
    }
  }
  int v43 = v45;
  uint64_t v44 = 0x800000000;
  if (v7 != v4)
  {
    unsigned int v17 = 0;
    uint64_t v18 = (char *)&a1[v4 / 8];
    do
    {
      size_t v19 = v18;
      int v20 = v18[32];
      unint64_t v21 = *((void *)v18 + 1);
      uint64_t v22 = v18 + 40;
      if (v18 + 40 == v6)
      {
        uint64_t v23 = v18;
LABEL_34:
        uint64_t v18 = v6;
      }
      else
      {
        while (1)
        {
          uint64_t v18 = v22;
          if (v22[32] != v20) {
            break;
          }
          *((void *)v22 - 2) = v22;
          if (*((void *)v22 + 1) < v21) {
            unint64_t v21 = *((void *)v22 + 1);
          }
          v22 += 40;
          if (v18 + 40 == v6)
          {
            uint64_t v23 = v18;
            goto LABEL_34;
          }
        }
        uint64_t v23 = v22 - 40;
      }
      *((void *)v23 + 3) = 0;
      *(void *)&long long __src = v21;
      *((void *)&__src + 1) = v19;
      LOBYTE(v42[0]) = v20;
      if (v17 >= HIDWORD(v44))
      {
        BOOL v26 = (char *)v43 + 24 * v17 > (char *)&__src;
        if (v43 > &__src || !v26) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      int v24 = (char *)v43 + 24 * v44;
      long long v25 = __src;
      *((void *)v24 + 2) = v42[0];
      *(_OWORD *)int v24 = v25;
      unsigned int v17 = v44 + 1;
      LODWORD(v44) = v44 + 1;
    }
    while (v18 != v6);
  }
  int v40 = &v43;
  *(void *)&long long __src = v42;
  *((void *)&__src + 1) = 0x1000000000;
  if (a2 >= 0x11) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  v38[0] = &v40;
  v38[1] = &__src;
  v38[2] = &v39;
  unint64_t v39 = 0;
  int v37 = v38;
  v36[0] = (uint64_t *)&v43;
  v36[1] = (uint64_t *)&v39;
  void v36[2] = (uint64_t *)&v37;
  if (v4)
  {
    long long v27 = a1;
    do
    {
      while (v39 != *v27 && (sub_1CD09A2C4(v36, *v27, 1) & 1) != 0)
        ;
      unint64_t v28 = sub_1CD59E054((uint64_t)&__src, (unint64_t)v27, 1);
      uint64_t v29 = __src + 40 * DWORD2(__src);
      uint64_t v30 = *(void *)(v28 + 32);
      long long v31 = *(_OWORD *)(v28 + 16);
      *(_OWORD *)uint64_t v29 = *(_OWORD *)v28;
      *(_OWORD *)(v29 + 16) = v31;
      *(void *)(v29 + 32) = v30;
      ++DWORD2(__src);
      unint64_t v32 = *v27;
      unint64_t v33 = v27[1];
      v27 += 5;
      unint64_t v9 = v33 + v32;
      unint64_t v39 = v33 + v32;
    }
    while (v10 != v27);
  }
  else
  {
    unint64_t v9 = 0;
  }
  if (v44)
  {
    do
      sub_1CD09A2C4(v36, 0, 0);
    while (v44);
    unint64_t v9 = v39;
  }
  int v34 = (void *)__src;
  memcpy(a1, (const void *)__src, 40 * a2);
  if (v34 != v42) {
    free(v34);
  }
  if (v43 != v45) {
    free(v43);
  }
  return v9;
}

uint64_t sub_1CD09A2C4(uint64_t **a1, unint64_t a2, char a3)
{
  uint64_t v3 = **a1;
  uint64_t v4 = *((unsigned int *)*a1 + 2);
  uint64_t v5 = v3 + 24 * v4;
  unint64_t v6 = *a1[1];
  uint64_t v7 = v3;
  if (v4)
  {
    uint64_t v8 = 24 * v4;
    uint64_t v7 = **a1;
    while ((v6 & ~(-1 << *(unsigned char *)(v7 + 16))) != 0)
    {
      v7 += 24;
      v8 -= 24;
      if (!v8)
      {
        uint64_t v7 = v5;
        break;
      }
    }
  }
  unint64_t v9 = v6 - 1;
  while (1)
  {
    uint64_t v10 = v7;
    if (v7 != v5) {
      break;
    }
LABEL_14:
    if (v10 == v3) {
      return 0;
    }
    unint64_t v6 = ((1 << *(unsigned char *)(v10 - 8)) + v9) & -(1 << *(unsigned char *)(v10 - 8));
    if (a3)
    {
      if (v6 >= a2) {
        return 0;
      }
    }
    uint64_t v13 = v10;
    while (1)
    {
      uint64_t v7 = v13 - 24;
      if (v13 - 24 == v3) {
        break;
      }
      uint64_t v14 = ((1 << *(unsigned char *)(v13 - 32)) + v9) & -(1 << *(unsigned char *)(v13 - 32));
      v13 -= 24;
      if (v6 != v14) {
        goto LABEL_22;
      }
    }
    uint64_t v7 = **a1;
LABEL_22:
    uint64_t v5 = v10;
  }
  if (a3) {
    unint64_t v11 = a2 - v6;
  }
  else {
    unint64_t v11 = -1;
  }
  uint64_t v12 = v7 + 31;
  while (*(void *)v7 > v11)
  {
    v7 += 24;
    v12 += 24;
    if (v7 == v5) {
      goto LABEL_14;
    }
  }
  unint64_t v16 = 0;
  uint64_t v17 = v7 + 8;
  do
  {
    unint64_t v18 = v16;
    unint64_t v16 = *(void *)v17;
    unint64_t v19 = *(void *)(*(void *)v17 + 8);
    uint64_t v17 = *(void *)v17 + 24;
  }
  while (v19 > v11);
  int v20 = (uint64_t **)*a1[2];
  unint64_t v21 = *(void *)v17;
  if (v18)
  {
    *(void *)(v18 + 24) = v21;
    if (!*(void *)v17) {
      *(void *)uint64_t v7 = *(void *)(v18 + 8);
    }
  }
  else if (v21)
  {
    *(void *)(v7 + --*(_DWORD *)(this + 8) = v21;
  }
  else
  {
    uint64_t v22 = **v20;
    unsigned int v23 = *(_DWORD *)(v22 + 8);
    uint64_t v24 = *(void *)v22 + 24 * v23;
    if (v7 + 24 != v24)
    {
      memmove((void *)v7, (const void *)(v7 + 24), v24 - v12);
      unsigned int v23 = *(_DWORD *)(v22 + 8);
    }
    *(_DWORD *)(v22 + --*(_DWORD *)(this + 8) = v23 - 1;
  }
  uint64_t v25 = (uint64_t)v20[1];
  uint64_t v15 = 1;
  unint64_t v26 = sub_1CD59E054(v25, v16, 1);
  uint64_t v27 = *(void *)v25 + 40 * *(unsigned int *)(v25 + 8);
  long long v28 = *(_OWORD *)v26;
  long long v29 = *(_OWORD *)(v26 + 16);
  *(void *)(v27 + 32) = *(void *)(v26 + 32);
  *(_OWORD *)uint64_t v27 = v28;
  *(_OWORD *)(v27 + 16) = v29;
  ++*(_DWORD *)(v25 + 8);
  uint64_t v30 = v20[2];
  uint64_t v31 = *v20[1] + 40 * *((unsigned int *)v20[1] + 2);
  *(void *)(v31 - 40) = v6;
  *uint64_t v30 = *(void *)(v31 - 32) + v6;
  return v15;
}

uint64_t sub_1CD09A4F4(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int8 *)(a1 + 32);
  unsigned int v3 = *(unsigned __int8 *)(a2 + 32);
  BOOL v4 = v2 >= v3;
  if (v2 == v3 && (v5 = *(void *)(a1 + 8), v6 = *(void *)(a2 + 8), BOOL v4 = v5 >= v6, v5 == v6))
  {
    unint64_t v7 = *(void *)(a1 + 24);
    unint64_t v8 = *(void *)(a2 + 24);
    BOOL v9 = v7 == v8;
    if (v7 < v8) {
      unsigned int v10 = -1;
    }
    else {
      unsigned int v10 = 1;
    }
    if (v9) {
      return 0;
    }
    else {
      return v10;
    }
  }
  else if (v4)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    return 1;
  }
}

uint64_t llvm::parallel::detail::TaskGroup::TaskGroup(uint64_t this)
{
  *(_DWORD *)this = 0;
  *(void *)(this + --*(_DWORD *)(this + 8) = 850045863;
  *(_OWORD *)(this + 16) = 0u;
  *(_OWORD *)(this + 32) = 0u;
  *(_OWORD *)(this + 4--*(_DWORD *)(this + 8) = 0u;
  *(void *)(this + 64) = 0;
  *(void *)(this + 72) = 1018212795;
  *(_OWORD *)(this + 80) = 0u;
  *(_OWORD *)(this + 96) = 0u;
  *(void *)(this + 112) = 0;
  *(unsigned char *)(this + 120) = atomic_fetch_add(&dword_1EA61F094, 1u) == 0;
  return this;
}

{
  *(_DWORD *)this = 0;
  *(void *)(this + --*(_DWORD *)(this + 8) = 850045863;
  *(_OWORD *)(this + 16) = 0u;
  *(_OWORD *)(this + 32) = 0u;
  *(_OWORD *)(this + 4--*(_DWORD *)(this + 8) = 0u;
  *(void *)(this + 64) = 0;
  *(void *)(this + 72) = 1018212795;
  *(_OWORD *)(this + 80) = 0u;
  *(_OWORD *)(this + 96) = 0u;
  *(void *)(this + 112) = 0;
  *(unsigned char *)(this + 120) = atomic_fetch_add(&dword_1EA61F094, 1u) == 0;
  return this;
}

void llvm::parallel::detail::TaskGroup::~TaskGroup(llvm::parallel::detail::TaskGroup *this)
{
}

{
  sub_1CD09A624((uint64_t)this);
  atomic_fetch_add(&dword_1EA61F094, 0xFFFFFFFF);
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 72));
  std::mutex::~mutex((std::mutex *)((char *)this + 8));
}

void sub_1CD09A624(uint64_t a1)
{
  m = (std::mutex *)(a1 + 8);
  v3.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 8);
  v3.__owns_ = 1;
  std::mutex::lock((std::mutex *)(a1 + 8));
  if (!*(_DWORD *)a1) {
    goto LABEL_5;
  }
  do
    std::condition_variable::wait((std::condition_variable *)(a1 + 72), &v3);
  while (*(_DWORD *)a1);
  if (v3.__owns_)
  {
    m = v3.__m_;
LABEL_5:
    std::mutex::unlock(m);
  }
}

uint64_t llvm::parallel::detail::TaskGroup::spawn(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 120))
  {
    std::unique_lock<std::mutex> v3 = (_DWORD *)a1;
    BOOL v4 = (std::mutex *)(a1 + 8);
    std::mutex::lock((std::mutex *)(a1 + 8));
    ++*v3;
    std::mutex::unlock(v4);
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCFAFD0, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EBCFAFD0))
    {
      if (!atomic_load_explicit(qword_1EBCFAFD8, memory_order_acquire)) {
        llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EBCFAFD8, (void *(*)(void))sub_1CD09AC88, (void (*)(void *))sub_1CD09AF20);
      }
      qword_1EBCFAFC8 = qword_1EBCFAFD8[0];
      __cxa_atexit((void (*)(void *))sub_1CD09AC34, &qword_1EBCFAFC8, &dword_1CB82C000);
      __cxa_guard_release(&qword_1EBCFAFD0);
    }
    uint64_t v5 = qword_1EBCFAFC8;
    sub_1CC3DAE00((uint64_t)v11, a2);
    uint64_t v13 = v3;
    unint64_t v6 = operator new(0x30uLL);
    unint64_t v7 = v6;
    *unint64_t v6 = &unk_1F2645090;
    if (v12)
    {
      if (v12 == v11)
      {
        void v6[4] = v6 + 1;
        (*(void (**)(void *))(v11[0] + 24))(v11);
        std::unique_lock<std::mutex> v3 = v13;
      }
      else
      {
        void v6[4] = v12;
        uint64_t v12 = 0;
      }
    }
    else
    {
      void v6[4] = 0;
    }
    v7[5] = v3;
    uint64_t v15 = v7;
    (*(void (**)(uint64_t, void *))(*(void *)v5 + 16))(v5, v14);
    if (v15 == v14)
    {
      (*(void (**)(void *))(v14[0] + 32))(v14);
    }
    else if (v15)
    {
      (*(void (**)(void))(*v15 + 40))();
    }
    uint64_t result = (uint64_t)v12;
    if (v12 == v11)
    {
      return (*(uint64_t (**)(void *))(v11[0] + 32))(v11);
    }
    else if (v12)
    {
      return (*(uint64_t (**)(void))(*v12 + 40))();
    }
  }
  else
  {
    uint64_t v8 = *(void *)(a2 + 24);
    if (v8)
    {
      BOOL v9 = *(uint64_t (**)(void))(*(void *)v8 + 48);
      return v9();
    }
    else
    {
      sub_1CB920400();
      return llvm::parallelForEachN();
    }
  }
  return result;
}

void llvm::parallelForEachN(uint64_t a1, unint64_t a2, void (*a3)(uint64_t, uint64_t), uint64_t a4)
{
  uint64_t v5 = a1;
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a3;
  uint64_t v13 = a4;
  unint64_t v6 = a2 - a1;
  if (a2 - a1 < 2 || llvm::parallel::strategy == 1)
  {
    if (a2 != a1)
    {
      do
        a3(a4, v5++);
      while (a2 != v5);
    }
  }
  else
  {
    if (v6 < 0x400) {
      uint64_t v10 = 1;
    }
    else {
      uint64_t v10 = v6 >> 10;
    }
    int v16 = 0;
    v17.__m_.__sig = 850045863;
    memset(v17.__m_.__opaque, 0, sizeof(v17.__m_.__opaque));
    v18.__cv_.__sig = 1018212795;
    memset(v18.__cv_.__opaque, 0, sizeof(v18.__cv_.__opaque));
    BOOL v19 = atomic_fetch_add(&dword_1EA61F094, 1u) == 0;
    if (v10 + a1 < a2)
    {
      do
      {
        unint64_t v11 = operator new(0x20uLL);
        *unint64_t v11 = &unk_1F26450D8;
        v11[1] = &v12;
        void v11[2] = v5;
        void v11[3] = v10;
        uint64_t v15 = v11;
        llvm::parallel::detail::TaskGroup::spawn((uint64_t)&v16, (uint64_t)v14);
        if (v15 == v14)
        {
          (*(void (**)(void *))(v14[0] + 32))(v14);
        }
        else if (v15)
        {
          (*(void (**)(void))(*v15 + 40))();
        }
        v5 += v10;
      }
      while (v10 + v5 < a2);
    }
    for (; a2 != v5; ++v5)
      v12(v13, v5);
    sub_1CD09A624((uint64_t)&v16);
    atomic_fetch_add(&dword_1EA61F094, 0xFFFFFFFF);
    std::condition_variable::~condition_variable(&v18);
    std::mutex::~mutex(&v17);
  }
}

uint64_t *sub_1CD09AC34(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_1CD09AC88()
{
}

uint64_t sub_1CD09AF24(uint64_t a1)
{
  *(void *)a1 = &unk_1F2645068;
  sub_1CD09BD30(a1);
  pthread_t v2 = pthread_self();
  std::unique_lock<std::mutex> v3 = *(std::thread **)(a1 + 184);
  BOOL v4 = *(std::thread **)(a1 + 192);
  if (v3 != v4)
  {
    uint64_t v5 = v2;
    while (1)
    {
      if (v3->__t_)
      {
        if (!v5 || v3->__t_ != v5)
        {
LABEL_8:
          std::thread::join(v3);
          goto LABEL_9;
        }
      }
      else if (v5)
      {
        goto LABEL_8;
      }
      std::thread::detach(v3);
LABEL_9:
      if (++v3 == v4)
      {
        std::unique_lock<std::mutex> v3 = *(std::thread **)(a1 + 184);
        break;
      }
    }
  }
  if (v3)
  {
    unint64_t v6 = *(std::thread **)(a1 + 192);
    unint64_t v7 = v3;
    if (v6 != v3)
    {
      do
        std::thread::~thread(v6 - 1);
      while (v6 != v3);
      unint64_t v7 = *(std::thread **)(a1 + 184);
    }
    *(void *)(a1 + 192) = v3;
    operator delete(v7);
  }
  MEMORY[0x1D25D9BD0](a1 + 176);
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 128));
  std::mutex::~mutex((std::mutex *)(a1 + 64));
  uint64_t v8 = *(void ***)(a1 + 24);
  BOOL v9 = *(void ***)(a1 + 32);
  if (v9 == v8)
  {
    uint64_t v10 = (void *)(a1 + 56);
    BOOL v9 = *(void ***)(a1 + 24);
  }
  else
  {
    uint64_t v10 = (void *)(a1 + 56);
    unint64_t v11 = *(void *)(a1 + 48);
    uint64_t v12 = &v8[v11 >> 7];
    uint64_t v13 = (char *)*v12 + 32 * (v11 & 0x7F);
    uint64_t v14 = *(uint64_t *)((char *)v8 + (((*(void *)(a1 + 56) + v11) >> 4) & 0xFFFFFFFFFFFFFF8))
        + 32 * ((*(void *)(a1 + 56) + v11) & 0x7F);
    if (v13 != (char *)v14)
    {
      do
      {
        uint64_t v15 = (char *)*((void *)v13 + 3);
        if (v15 == v13)
        {
          (*(void (**)(char *))(*(void *)v13 + 32))(v13);
        }
        else if (v15)
        {
          (*(void (**)(char *))(*(void *)v15 + 40))(v15);
        }
        v13 += 32;
        if (v13 - (unsigned char *)*v12 == 4096)
        {
          int v16 = (char *)v12[1];
          ++v12;
          uint64_t v13 = v16;
        }
      }
      while (v13 != (char *)v14);
      uint64_t v8 = *(void ***)(a1 + 24);
      BOOL v9 = *(void ***)(a1 + 32);
    }
  }
  *uint64_t v10 = 0;
  unint64_t v17 = (char *)v9 - (char *)v8;
  if ((unint64_t)((char *)v9 - (char *)v8) >= 0x11)
  {
    do
    {
      operator delete(*v8);
      BOOL v9 = *(void ***)(a1 + 32);
      uint64_t v8 = (void **)(*(void *)(a1 + 24) + 8);
      *(void *)(a1 + 24) = v8;
      unint64_t v17 = (char *)v9 - (char *)v8;
    }
    while ((unint64_t)((char *)v9 - (char *)v8) > 0x10);
  }
  unint64_t v18 = v17 >> 3;
  if (v18 == 1)
  {
    uint64_t v19 = 64;
    goto LABEL_33;
  }
  if (v18 == 2)
  {
    uint64_t v19 = 128;
LABEL_33:
    *(void *)(a1 + 4--*(_DWORD *)(this + 8) = v19;
  }
  if (v8 != v9)
  {
    do
    {
      uint64_t v20 = *v8++;
      operator delete(v20);
    }
    while (v8 != v9);
    uint64_t v22 = *(void *)(a1 + 24);
    uint64_t v21 = *(void *)(a1 + 32);
    if (v21 != v22) {
      *(void *)(a1 + 32) = v21 + ((v22 - v21 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  unsigned int v23 = *(void **)(a1 + 16);
  if (v23) {
    operator delete(v23);
  }
  return a1;
}

void sub_1CD09B190(uint64_t a1)
{
  sub_1CD09AF24(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD09B1C8(uint64_t a1, uint64_t a2)
{
  BOOL v4 = (std::mutex *)(a1 + 64);
  std::mutex::lock((std::mutex *)(a1 + 64));
  uint64_t v5 = *(char **)(a1 + 24);
  unint64_t v6 = *(char **)(a1 + 32);
  uint64_t v7 = v6 - v5;
  if (v6 == v5) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = 16 * (v6 - v5) - 1;
  }
  unint64_t v9 = *(void *)(a1 + 48);
  if (v8 != *(void *)(a1 + 56) + v9) {
    goto LABEL_37;
  }
  BOOL v10 = v9 >= 0x80;
  unint64_t v11 = v9 - 128;
  if (v10)
  {
    *(void *)(a1 + 4--*(_DWORD *)(this + 8) = v11;
    uint64_t v14 = *(void *)v5;
    uint64_t v12 = v5 + 8;
    uint64_t v13 = v14;
    *(void *)(a1 + 24) = v12;
    if (v6 == *(char **)(a1 + 40))
    {
      uint64_t v15 = *(char **)(a1 + 16);
      if (v12 <= v15)
      {
        if (v6 == v15) {
          unint64_t v32 = 1;
        }
        else {
          unint64_t v32 = (v6 - v15) >> 2;
        }
        if (v32 >> 61) {
          goto LABEL_101;
        }
        unint64_t v33 = (char *)operator new(8 * v32);
        int v34 = &v33[8 * (v32 >> 2)];
        uint64_t v36 = v6 - v12;
        BOOL v35 = v6 == v12;
        unint64_t v6 = v34;
        if (!v35)
        {
          unint64_t v6 = &v34[v36 & 0xFFFFFFFFFFFFFFF8];
          uint64_t v37 = 8 * (v36 >> 3);
          int v38 = &v33[8 * (v32 >> 2)];
          do
          {
            uint64_t v39 = *(void *)v12;
            v12 += 8;
            *(void *)int v38 = v39;
            v38 += 8;
            v37 -= 8;
          }
          while (v37);
        }
        *(void *)(a1 + 16) = v33;
        *(void *)(a1 + 24) = v34;
        *(void *)(a1 + 32) = v6;
        *(void *)(a1 + 40) = &v33[8 * v32];
        if (v15)
        {
          operator delete(v15);
          unint64_t v6 = *(char **)(a1 + 32);
        }
      }
      else
      {
        uint64_t v16 = (v12 - v15) >> 3;
        if (v16 >= -1) {
          uint64_t v17 = v16 + 1;
        }
        else {
          uint64_t v17 = v16 + 2;
        }
        uint64_t v18 = -(v17 >> 1);
        uint64_t v19 = v17 >> 1;
        uint64_t v20 = &v12[-8 * v19];
        int64_t v21 = v6 - v12;
        if (v6 != v12)
        {
          memmove(&v12[-8 * v19], v12, v6 - v12);
          unint64_t v6 = *(char **)(a1 + 24);
        }
        uint64_t v22 = &v6[8 * v18];
        unint64_t v6 = &v20[v21];
        *(void *)(a1 + 24) = v22;
        *(void *)(a1 + 32) = &v20[v21];
      }
    }
    *(void *)unint64_t v6 = v13;
    goto LABEL_35;
  }
  unsigned int v23 = *(char **)(a1 + 40);
  uint64_t v24 = *(char **)(a1 + 16);
  if (v7 >= (unint64_t)(v23 - v24))
  {
    if (v23 == v24) {
      unint64_t v27 = 1;
    }
    else {
      unint64_t v27 = (v23 - v24) >> 2;
    }
    if (v27 >> 61) {
      goto LABEL_101;
    }
    long long v28 = (char *)operator new(8 * v27);
    long long v29 = &v28[v7];
    uint64_t v30 = &v28[8 * v27];
    uint64_t v31 = operator new(0x1000uLL);
    if (v27 == v7 >> 3)
    {
      if (v7 < 1)
      {
        if (v6 == v5) {
          unint64_t v43 = 1;
        }
        else {
          unint64_t v43 = v7 >> 2;
        }
        if (v43 >> 61) {
          goto LABEL_101;
        }
        uint64_t v44 = v31;
        int v45 = (char *)operator new(8 * v43);
        long long v29 = &v45[8 * (v43 >> 2)];
        uint64_t v30 = &v45[8 * v43];
        operator delete(v28);
        uint64_t v5 = *(char **)(a1 + 24);
        unint64_t v6 = *(char **)(a1 + 32);
        long long v28 = v45;
        uint64_t v31 = v44;
      }
      else
      {
        v29 -= (4 * v27 + 4) & 0xFFFFFFFFFFFFFFF8;
      }
    }
    *(void *)long long v29 = v31;
    int v46 = v29 + 8;
    if (v6 == v5)
    {
      int v59 = v29;
      int v47 = v29 + 8;
LABEL_72:
      int v60 = *(void **)(a1 + 16);
      *(void *)(a1 + 16) = v28;
      *(void *)(a1 + 24) = v59;
      unint64_t v6 = v47;
      *(void *)(a1 + 32) = v47;
      *(void *)(a1 + 40) = v30;
      if (v60)
      {
        operator delete(v60);
        unint64_t v6 = *(char **)(a1 + 32);
      }
      goto LABEL_36;
    }
    while (1)
    {
      if (v29 == v28)
      {
        if (v46 < v30)
        {
          uint64_t v49 = (v30 - v46) >> 3;
          if (v49 >= -1) {
            unint64_t v50 = v49 + 1;
          }
          else {
            unint64_t v50 = v49 + 2;
          }
          int v47 = &v46[8 * (v50 >> 1)];
          int v48 = &v29[8 * (v50 >> 1)];
          if (v46 == v29) {
            long long v29 = v46;
          }
          else {
            memmove(&v29[8 * (v50 >> 1)], v29, v46 - v29);
          }
          goto LABEL_68;
        }
        if (v30 == v29) {
          unint64_t v51 = 1;
        }
        else {
          unint64_t v51 = (v30 - v29) >> 2;
        }
        if (v51 >> 61) {
          goto LABEL_101;
        }
        int v52 = (char *)operator new(8 * v51);
        long long v28 = v52;
        int v48 = &v52[(2 * v51 + 6) & 0xFFFFFFFFFFFFFFF8];
        int v47 = v48;
        uint64_t v53 = v46 - v29;
        if (v46 != v29)
        {
          int v47 = &v48[v53 & 0xFFFFFFFFFFFFFFF8];
          uint64_t v54 = 8 * (v53 >> 3);
          int v55 = &v52[(2 * v51 + 6) & 0xFFFFFFFFFFFFFFF8];
          int v56 = v29;
          do
          {
            uint64_t v57 = *(void *)v56;
            v56 += 8;
            *(void *)int v55 = v57;
            v55 += 8;
            v54 -= 8;
          }
          while (v54);
        }
        uint64_t v30 = &v52[8 * v51];
        operator delete(v29);
      }
      else
      {
        int v47 = v46;
        int v48 = v29;
      }
      long long v29 = v28;
LABEL_68:
      long long v28 = v29;
      uint64_t v58 = *((void *)v6 - 1);
      v6 -= 8;
      *((void *)v48 - 1) = v58;
      int v59 = v48 - 8;
      int v46 = v47;
      long long v29 = v59;
      if (v6 == *(char **)(a1 + 24)) {
        goto LABEL_72;
      }
    }
  }
  uint64_t v25 = operator new(0x1000uLL);
  unint64_t v26 = v25;
  if (v23 == v6)
  {
    if (v5 == v24)
    {
      if (v6 == v5) {
        unint64_t v61 = 1;
      }
      else {
        unint64_t v61 = (v23 - v5) >> 2;
      }
      if (v61 >> 61) {
        goto LABEL_101;
      }
      int v62 = (char *)operator new(8 * v61);
      int v42 = &v62[(2 * v61 + 6) & 0xFFFFFFFFFFFFFFF8];
      int v63 = v42;
      if (v6 != v5)
      {
        int v63 = &v42[v7 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v64 = 8 * (v7 >> 3);
        int v65 = &v62[(2 * v61 + 6) & 0xFFFFFFFFFFFFFFF8];
        int v66 = v5;
        do
        {
          uint64_t v67 = *(void *)v66;
          v66 += 8;
          *(void *)int v65 = v67;
          v65 += 8;
          v64 -= 8;
        }
        while (v64);
      }
      *(void *)(a1 + 16) = v62;
      *(void *)(a1 + 24) = v42;
      *(void *)(a1 + 32) = v63;
      *(void *)(a1 + 40) = &v62[8 * v61];
      if (v5)
      {
        operator delete(v5);
        int v42 = *(char **)(a1 + 24);
      }
    }
    else
    {
      int v42 = v5;
    }
    *((void *)v42 - 1) = v26;
    int v68 = *(char **)(a1 + 24);
    int v69 = *(char **)(a1 + 32);
    *(void *)(a1 + 24) = v68 - 8;
    uint64_t v70 = *((void *)v68 - 1);
    *(void *)(a1 + 24) = v68;
    if (v69 != *(char **)(a1 + 40))
    {
LABEL_100:
      *(void *)int v69 = v70;
      goto LABEL_35;
    }
    int v71 = *(char **)(a1 + 16);
    if (v68 > v71)
    {
      uint64_t v72 = (v68 - v71) >> 3;
      if (v72 >= -1) {
        uint64_t v73 = v72 + 1;
      }
      else {
        uint64_t v73 = v72 + 2;
      }
      uint64_t v74 = -(v73 >> 1);
      uint64_t v75 = v73 >> 1;
      int v76 = &v68[-8 * v75];
      size_t v77 = v69 - v68;
      if (v77)
      {
        memmove(&v68[-8 * v75], v68, v77);
        int v68 = *(char **)(a1 + 24);
      }
      int v69 = &v76[v77];
      *(void *)(a1 + 24) = &v68[8 * v74];
      *(void *)(a1 + 32) = v69;
      goto LABEL_100;
    }
    if (v69 == v71) {
      unint64_t v78 = 1;
    }
    else {
      unint64_t v78 = (v69 - v71) >> 2;
    }
    if (!(v78 >> 61))
    {
      int v79 = (char *)operator new(8 * v78);
      int v80 = &v79[8 * (v78 >> 2)];
      uint64_t v81 = v69 - v68;
      BOOL v35 = v69 == v68;
      int v69 = v80;
      if (!v35)
      {
        int v69 = &v80[v81 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v82 = 8 * (v81 >> 3);
        int v83 = &v79[8 * (v78 >> 2)];
        do
        {
          uint64_t v84 = *(void *)v68;
          v68 += 8;
          *(void *)int v83 = v84;
          v83 += 8;
          v82 -= 8;
        }
        while (v82);
      }
      *(void *)(a1 + 16) = v79;
      *(void *)(a1 + 24) = v80;
      *(void *)(a1 + 32) = v69;
      *(void *)(a1 + 40) = &v79[8 * v78];
      if (v71)
      {
        operator delete(v71);
        int v69 = *(char **)(a1 + 32);
      }
      goto LABEL_100;
    }
LABEL_101:
    sub_1CB833614();
  }
  *(void *)unint64_t v6 = v25;
LABEL_35:
  unint64_t v6 = (char *)(*(void *)(a1 + 32) + 8);
  *(void *)(a1 + 32) = v6;
LABEL_36:
  uint64_t v5 = *(char **)(a1 + 24);
LABEL_37:
  if (v6 == v5)
  {
    uint64_t v41 = 0;
  }
  else
  {
    unint64_t v40 = *(void *)(a1 + 48) + *(void *)(a1 + 56);
    uint64_t v41 = *(void *)&v5[(v40 >> 4) & 0xFFFFFFFFFFFFFF8] + 32 * (v40 & 0x7F);
  }
  sub_1CC3DAE00(v41, a2);
  ++*(void *)(a1 + 56);
  std::mutex::unlock(v4);

  std::condition_variable::notify_one((std::condition_variable *)(a1 + 128));
}

uint64_t sub_1CD09B710(uint64_t a1)
{
  v13[0] = (uint64_t *)a1;
  pthread_t v2 = std::__thread_local_data();
  std::unique_lock<std::mutex> v3 = *(const void **)a1;
  *(void *)a1 = 0;
  pthread_setspecific(v2->__key_, v3);
  BOOL v4 = *(std::promise<void> **)(a1 + 8);
  if (*(_DWORD *)(a1 + 16) >= 2u)
  {
    v13[1] = *(uint64_t **)(a1 + 8);
    int v14 = *(_DWORD *)(a1 + 20);
    __int16 v15 = *(_WORD *)(a1 + 24);
    int v16 = 1;
    state = v4[24].__state_;
    uint64_t v5 = v4[25].__state_;
    if (state < v5) {
      sub_1CD09BBB4();
    }
    uint64_t v7 = v4[23].__state_;
    uint64_t v8 = ((char *)state - (char *)v7) >> 3;
    if (!((unint64_t)(v8 + 1) >> 61))
    {
      uint64_t v9 = (char *)v5 - (char *)v7;
      uint64_t v10 = v9 >> 2;
      if (v9 >> 2 <= (unint64_t)(v8 + 1)) {
        uint64_t v10 = v8 + 1;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v11 = v10;
      }
      if (v11)
      {
        if (v11 >> 61) {
          sub_1CB833614();
        }
        operator new(8 * v11);
      }
      sub_1CD09BBB4();
    }
    abort();
  }
  std::promise<void>::set_value(v4 + 22);
  sub_1CD09B938((uint64_t)v4);
  sub_1CD09B8CC(v13);
  return 0;
}

uint64_t **sub_1CD09B8CC(uint64_t **a1)
{
  pthread_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = *v2;
    uint64_t *v2 = 0;
    if (v3)
    {
      uint64_t v4 = MEMORY[0x1D25D98C0]();
      MEMORY[0x1D25D9CE0](v4, 0x20C4093837F09);
    }
    MEMORY[0x1D25D9CE0](v2, 0x1020C4059B2DB7BLL);
  }
  return a1;
}

void sub_1CD09B938(uint64_t a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  pthread_t v2 = (std::mutex *)(a1 + 64);
  uint64_t v3 = (std::condition_variable *)(a1 + 128);
  do
  {
    __lk.__m_ = v2;
    __lk.__owns_ = 1;
    std::mutex::lock(v2);
    unsigned __int8 v4 = atomic_load((unsigned __int8 *)(a1 + 8));
    if ((v4 & 1) == 0)
    {
      do
      {
        if (*(void *)(a1 + 56)) {
          break;
        }
        std::condition_variable::wait(v3, &__lk);
        unsigned __int8 v5 = atomic_load((unsigned __int8 *)(a1 + 8));
      }
      while ((v5 & 1) == 0);
    }
    unsigned __int8 v6 = atomic_load((unsigned __int8 *)(a1 + 8));
    if ((v6 & 1) == 0)
    {
      unint64_t v7 = *(void *)(a1 + 56) + *(void *)(a1 + 48) - 1;
      sub_1CC3DAE00((uint64_t)v19, *(void *)(*(void *)(a1 + 24) + ((v7 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v7 & 0x7F));
      unint64_t v8 = *(void *)(a1 + 56) + *(void *)(a1 + 48) - 1;
      uint64_t v9 = (void *)(*(void *)(*(void *)(a1 + 24) + ((v8 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v8 & 0x7F));
      uint64_t v10 = (void *)v9[3];
      if (v10 == v9)
      {
        (*(void (**)(void *))(*v9 + 32))(v9);
      }
      else if (v10)
      {
        (*(void (**)(void *))(*v10 + 40))(v10);
      }
      uint64_t v12 = *(void *)(a1 + 24);
      uint64_t v11 = *(void *)(a1 + 32);
      uint64_t v13 = v11 - v12;
      BOOL v14 = v11 == v12;
      uint64_t v16 = *(void *)(a1 + 48);
      uint64_t v15 = *(void *)(a1 + 56);
      *(void *)(a1 + 56) = v15 - 1;
      uint64_t v17 = 16 * v13 - 1;
      if (v14) {
        uint64_t v17 = 0;
      }
      if ((unint64_t)(v17 - (v15 + v16) - 255) <= 0xFFFFFFFFFFFFFEFFLL)
      {
        operator delete(*(void **)(v11 - 8));
        *(void *)(a1 + 32) -= 8;
      }
      if (!__lk.__owns_)
      {
        std::__throw_system_error(1, "unique_lock::unlock: not locked");
LABEL_25:
        sub_1CB920400();
      }
      std::mutex::unlock(__lk.__m_);
      __lk.__owns_ = 0;
      if (!v20) {
        goto LABEL_25;
      }
      (*(void (**)(void *))(*v20 + 48))(v20);
      if (v20 == v19)
      {
        (*(void (**)(void *))(v19[0] + 32))(v19);
      }
      else if (v20)
      {
        (*(void (**)(void))(*v20 + 40))();
      }
    }
    if (__lk.__owns_) {
      std::mutex::unlock(__lk.__m_);
    }
  }
  while ((v6 & 1) == 0);
}

void sub_1CD09BBB4()
{
}

uint64_t sub_1CD09BC70(uint64_t *a1)
{
  unsigned __int8 v5 = a1;
  pthread_t v2 = std::__thread_local_data();
  uint64_t v3 = (const void *)*a1;
  *a1 = 0;
  pthread_setspecific(v2->__key_, v3);
  sub_1CD09B938(a1[1]);
  sub_1CD09BCC4(&v5);
  return 0;
}

uint64_t **sub_1CD09BCC4(uint64_t **a1)
{
  pthread_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = *v2;
    uint64_t *v2 = 0;
    if (v3)
    {
      uint64_t v4 = MEMORY[0x1D25D98C0]();
      MEMORY[0x1D25D9CE0](v4, 0x20C4093837F09);
    }
    MEMORY[0x1D25D9CE0](v2, 0x1020C40A82BEB12);
  }
  return a1;
}

void sub_1CD09BD30(uint64_t a1)
{
  pthread_t v2 = (std::mutex *)(a1 + 64);
  std::mutex::lock((std::mutex *)(a1 + 64));
  unsigned __int8 v3 = atomic_load((unsigned __int8 *)(a1 + 8));
  if (v3)
  {
    std::mutex::unlock(v2);
  }
  else
  {
    atomic_store(1u, (unsigned __int8 *)(a1 + 8));
    std::mutex::unlock(v2);
    std::condition_variable::notify_all((std::condition_variable *)(a1 + 128));
    std::promise<void>::get_future((std::promise<void> *)(a1 + 176));
    std::__assoc_sub_state::wait(v4.__state_);
    std::future<void>::~future(&v4);
  }
}

void *sub_1CD09BDC8(void *a1)
{
  *a1 = &unk_1F2645090;
  pthread_t v2 = a1 + 1;
  unsigned __int8 v3 = (void *)a1[4];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  return a1;
}

void sub_1CD09BE6C(void *a1)
{
  *a1 = &unk_1F2645090;
  uint64_t v1 = a1 + 1;
  pthread_t v2 = (void *)a1[4];
  if (v2 == v1)
  {
    (*(void (**)(void *))(*v1 + 32))(v1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CD09BF30(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  unsigned __int8 v3 = operator new(0x30uLL);
  *unsigned __int8 v3 = &unk_1F2645090;
  sub_1CC3DAE00((uint64_t)(v3 + 1), v2);
  v3[5] = *(void *)(a1 + 40);
  return v3;
}

uint64_t sub_1CD09BF98(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2645090;
  uint64_t result = sub_1CC3DAE00((uint64_t)(a2 + 1), a1 + 8);
  a2[5] = *(void *)(a1 + 40);
  return result;
}

uint64_t sub_1CD09BFEC(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t result = *(void *)(a1 + 32);
  if (result == v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 32))(v1);
  }
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

void sub_1CD09C050(char *__p)
{
  uint64_t v2 = __p + 8;
  unsigned __int8 v3 = (char *)*((void *)__p + 4);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }

  operator delete(__p);
}

void sub_1CD09C0E8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2)
  {
    sub_1CB920400();
    JUMPOUT(0x1CD09C174);
  }
  uint64_t v3 = *(void *)(a1 + 40);
  (*(void (**)(uint64_t))(*(void *)v2 + 48))(v2);
  std::mutex::lock((std::mutex *)(v3 + 8));
  if ((*(_DWORD *)v3)-- == 1) {
    std::condition_variable::notify_all((std::condition_variable *)(v3 + 72));
  }

  std::mutex::unlock((std::mutex *)(v3 + 8));
}

void sub_1CD09C178()
{
}

__n128 sub_1CD09C18C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1F26450D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + --*(_DWORD *)(this + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1CD09C1E0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F26450D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + --*(_DWORD *)(this + 8) = result;
  return result;
}

uint64_t sub_1CD09C218(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 24);
  if (v1)
  {
    uint64_t v2 = result;
    uint64_t v3 = *(void *)(result + 16);
    do
    {
      __n128 result = (**(uint64_t (***)(void, uint64_t))(v2 + 8))(*(void *)(*(void *)(v2 + 8) + 8), v3++);
      --v1;
    }
    while (v1);
  }
  return result;
}

void llvm::PluginLoader::operator=(uint64_t a1, uint64_t a2)
{
  if (!atomic_load_explicit(qword_1EBCFAFF0, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EBCFAFF0, (void *(*)(void))sub_1CD5D7578, (void (*)(void *))sub_1CD5D75BC);
  }
  uint64_t v3 = (std::recursive_mutex *)qword_1EBCFAFF0[0];
  std::recursive_mutex::lock((std::recursive_mutex *)qword_1EBCFAFF0[0]);
  std::string __p = 0;
  size_t v24 = 0;
  uint64_t v25 = 0;
  if (*(char *)(a2 + 23) >= 0) {
    std::future<void> v4 = (const char *)a2;
  }
  else {
    std::future<void> v4 = *(const char **)a2;
  }
  PermanentLibrary = (llvm *)llvm::sys::DynamicLibrary::getPermanentLibrary(v4, (uint64_t)&__p);
  if (PermanentLibrary == (llvm *)&llvm::sys::DynamicLibrary::Invalid)
  {
    uint64_t v9 = (llvm::raw_ostream *)llvm::errs(PermanentLibrary);
    uint64_t v10 = (void *)*((void *)v9 + 4);
    if (*((void *)v9 + 3) - (void)v10 > 0xEuLL)
    {
      qmemcpy(v10, "Error opening '", 15);
      *((void *)v9 + 4) += 15;
    }
    else
    {
      uint64_t v9 = llvm::raw_ostream::write(v9, "Error opening '", 0xFuLL);
    }
    char v11 = *(unsigned char *)(a2 + 23);
    BOOL v12 = v11 < 0;
    if (v11 >= 0) {
      uint64_t v13 = (const char *)a2;
    }
    else {
      uint64_t v13 = *(const char **)a2;
    }
    size_t v14 = v11 & 0x7F;
    if (v12) {
      size_t v15 = *(void *)(a2 + 8);
    }
    else {
      size_t v15 = v14;
    }
    uint64_t v16 = llvm::raw_ostream::write(v9, v13, v15);
    uint64_t v17 = *((void *)v16 + 4);
    if ((unint64_t)(*((void *)v16 + 3) - v17) > 2)
    {
      *(unsigned char *)(v17 + 2) = 32;
      *(_WORD *)uint64_t v17 = 14887;
      *((void *)v16 + 4) += 3;
    }
    else
    {
      uint64_t v16 = llvm::raw_ostream::write(v16, "': ", 3uLL);
    }
    if (v25 >= 0) {
      p_p = (const char *)&__p;
    }
    else {
      p_p = (const char *)__p;
    }
    if (v25 >= 0) {
      size_t v19 = HIBYTE(v25) & 0x7F;
    }
    else {
      size_t v19 = v24;
    }
    uint64_t v20 = llvm::raw_ostream::write(v16, p_p, v19);
    uint64_t v21 = (void *)*((void *)v20 + 4);
    if (*((void *)v20 + 3) - (void)v21 > 0x19uLL)
    {
      qmemcpy(v21, "\n  -load request ignored.\n", 26);
      *((void *)v20 + 4) += 26;
    }
    else
    {
      llvm::raw_ostream::write(v20, "\n  -load request ignored.\n", 0x1AuLL);
    }
  }
  else
  {
    if (!atomic_load_explicit(&qword_1EBCFB008, memory_order_acquire)) {
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1EBCFB008, (void *(*)(void))sub_1CD05F8D4, (void (*)(void *))sub_1CD05F908);
    }
    uint64_t v6 = qword_1EBCFB008;
    unint64_t v7 = *(void *)(qword_1EBCFB008 + 8);
    if (v7 >= *(void *)(qword_1EBCFB008 + 16))
    {
      uint64_t v22 = sub_1CBF64E70((unint64_t *)qword_1EBCFB008, a2);
    }
    else
    {
      if (*(char *)(a2 + 23) < 0)
      {
        sub_1CB8BDF7C(*(void *)(qword_1EBCFB008 + 8), *(const void **)a2, *(void *)(a2 + 8));
      }
      else
      {
        long long v8 = *(_OWORD *)a2;
        *(void *)(v7 + 16) = *(void *)(a2 + 16);
        *(_OWORD *)unint64_t v7 = v8;
      }
      uint64_t v22 = v7 + 24;
    }
    *(void *)(v6 + --*(_DWORD *)(this + 8) = v22;
  }
  if (SHIBYTE(v25) < 0) {
    operator delete(__p);
  }
  std::recursive_mutex::unlock(v3);
}

uint64_t llvm::PluginLoader::getNumPlugins(llvm::PluginLoader *this)
{
  if (!atomic_load_explicit(qword_1EBCFAFF0, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EBCFAFF0, (void *(*)(void))sub_1CD5D7578, (void (*)(void *))sub_1CD5D75BC);
  }
  uint64_t v1 = (std::recursive_mutex *)qword_1EBCFAFF0[0];
  std::recursive_mutex::lock((std::recursive_mutex *)qword_1EBCFAFF0[0]);
  if (atomic_load((unint64_t *)&qword_1EBCFB008))
  {
    if (!atomic_load_explicit(&qword_1EBCFB008, memory_order_acquire)) {
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1EBCFB008, (void *(*)(void))sub_1CD05F8D4, (void (*)(void *))sub_1CD05F908);
    }
    uint64_t v3 = -1431655765 * ((*(void *)(qword_1EBCFB008 + 8) - *(void *)qword_1EBCFB008) >> 3);
  }
  else
  {
    uint64_t v3 = 0;
  }
  std::recursive_mutex::unlock(v1);
  return v3;
}

uint64_t llvm::PluginLoader::getPlugin(llvm::PluginLoader *this)
{
  unsigned int v1 = this;
  if (!atomic_load_explicit(qword_1EBCFAFF0, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EBCFAFF0, (void *(*)(void))sub_1CD5D7578, (void (*)(void *))sub_1CD5D75BC);
  }
  uint64_t v2 = (std::recursive_mutex *)qword_1EBCFAFF0[0];
  std::recursive_mutex::lock((std::recursive_mutex *)qword_1EBCFAFF0[0]);
  if (!atomic_load_explicit(&qword_1EBCFB008, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)&qword_1EBCFB008, (void *(*)(void))sub_1CD05F8D4, (void (*)(void *))sub_1CD05F908);
  }
  uint64_t v3 = *(void *)qword_1EBCFB008;
  std::recursive_mutex::unlock(v2);
  return v3 + 24 * v1;
}

llvm *llvm::MappedPrefix::transformJoined@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, llvm *a4@<X8>)
{
  if (a2)
  {
    uint64_t v6 = a1;
    unint64_t v7 = *(unsigned int *)(a3 + 8);
    uint64_t v8 = a1 + 16 * a2;
    while (1)
    {
      uint64_t v9 = *(std::string::value_type **)v6;
      size_t v10 = *(void *)(v6 + 8);
      llvm::MappedPrefix::getFromJoined(*(std::string::value_type **)v6, v10, (uint64_t)v16);
      if (!v20) {
        break;
      }
      char v11 = (long long *)sub_1CD83FB5C(a3, (unint64_t)v16);
      sub_1CD746C48(*(void *)a3 + 48 * *(unsigned int *)(a3 + 8), v11);
      ++*(_DWORD *)(a3 + 8);
      if (v20)
      {
        if (v19 < 0) {
          operator delete(__p);
        }
        if (v17 < 0) {
          operator delete(v16[0]);
        }
      }
      v6 += 16;
      if (v6 == v8) {
        goto LABEL_10;
      }
    }
    sub_1CD09CCE8(a3, v7);
    v14[0] = (uint64_t)v9;
    v14[1] = v10;
    char v12 = 1;
  }
  else
  {
LABEL_10:
    char v12 = 0;
    LOBYTE(v14[0]) = 0;
  }
  char v15 = v12;
  return sub_1CD09C780(a4, v14);
}

{
  unint64_t v7;
  uint64_t v8;
  char v9;
  BOOL v10;
  std::string::value_type *v11;
  uint64_t v12;
  size_t v13;
  long long *v14;
  char v15;
  uint64_t v17[2];
  char v18;
  void *v19[2];
  char v20;
  void *__p;
  char v22;
  char v23;

  if (a2)
  {
    unint64_t v7 = *(unsigned int *)(a3 + 8);
    uint64_t v8 = 24 * a2;
    while (1)
    {
      uint64_t v9 = *(unsigned char *)(a1 + 23);
      size_t v10 = v9 < 0;
      char v11 = v9 >= 0 ? (std::string::value_type *)a1 : *(std::string::value_type **)a1;
      char v12 = v9 & 0x7F;
      uint64_t v13 = v10 ? *(void *)(a1 + 8) : v12;
      llvm::MappedPrefix::getFromJoined(v11, v13, (uint64_t)v19);
      if (!v23) {
        break;
      }
      size_t v14 = (long long *)sub_1CD83FB5C(a3, (unint64_t)v19);
      sub_1CD746C48(*(void *)a3 + 48 * *(unsigned int *)(a3 + 8), v14);
      ++*(_DWORD *)(a3 + 8);
      if (v23)
      {
        if (v22 < 0) {
          operator delete(__p);
        }
        if (v20 < 0) {
          operator delete(v19[0]);
        }
      }
      a1 += 24;
      v8 -= 24;
      if (!v8) {
        goto LABEL_16;
      }
    }
    sub_1CD09CCE8(a3, v7);
    v17[0] = (uint64_t)v11;
    v17[1] = v13;
    char v15 = 1;
  }
  else
  {
LABEL_16:
    char v15 = 0;
    LOBYTE(v17[0]) = 0;
  }
  uint64_t v18 = v15;
  return sub_1CD09C780(a4, v17);
}

llvm *sub_1CD09C780(llvm *result, uint64_t *a2)
{
  if (*((unsigned char *)a2 + 16))
  {
    uint64_t v3 = llvm::inconvertibleErrorCode(result);
    __int16 v8 = 1283;
    uint64_t v4 = *a2;
    uint64_t v5 = a2[1];
    v7[0] = "invalid prefix map: '";
    v7[2] = v4;
    void v7[3] = v5;
    v9[0] = v7;
    v9[2] = "'";
    __int16 v10 = 770;
    sub_1CD4FF4BC(v3, v6, (llvm::Twine *)v9);
  }
  *(void *)__n128 result = 0;
  return result;
}

void llvm::PrefixMapper::map(uint64_t a1@<X0>, const void *a2@<X1>, size_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  llvm::PrefixMapper::mapToString(a1, a2, a3, (uint64_t)&v8);
  if (v10)
  {
    uint64_t v7 = v8;
  }
  else
  {
    if (*(char *)(a4 + 23) < 0) {
      operator delete(*(void **)a4);
    }
    uint64_t v7 = 0;
    *(_OWORD *)a4 = v8;
    *(void *)(a4 + 16) = v9;
  }
  *a5 = v7;
}

void llvm::PrefixMapper::mapToString(uint64_t a1@<X0>, const void *a2@<X1>, size_t a3@<X2>, uint64_t a4@<X8>)
{
  char v20[32] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = v20;
  long long v19 = xmmword_1CD96DBF0;
  (*(void (**)(size_t *__return_ptr))(*(void *)a1 + 16))(__len);
  uint64_t v7 = (const void *)__len[0];
  if (v17)
  {
    if (__len[0])
    {
      *(unsigned char *)(a4 + 24) |= 1u;
      *(void *)a4 = v7;
      goto LABEL_27;
    }
  }
  else if ((_BYTE)v16)
  {
    if (__len[0])
    {
      size_t v8 = __len[1];
      if (__len[1] <= 0x7FFFFFFFFFFFFFF7)
      {
        if (__len[1] >= 0x17)
        {
          size_t v13 = (__len[1] & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((__len[1] | 7) != 0x17) {
            size_t v13 = __len[1] | 7;
          }
          size_t v14 = v13 + 1;
          uint64_t v9 = operator new(v13 + 1);
          __len[1] = v8;
          unint64_t v16 = v14 | 0x8000000000000000;
          __len[0] = (size_t)v9;
        }
        else
        {
          HIBYTE(v16) = __len[1];
          uint64_t v9 = __len;
          if (!__len[1]) {
            goto LABEL_25;
          }
        }
        memmove(v9, v7, v8);
LABEL_25:
        *((unsigned char *)v9 + v--*(_DWORD *)(this + 8) = 0;
        goto LABEL_26;
      }
LABEL_30:
      abort();
    }
    goto LABEL_15;
  }
  if (a2)
  {
    if (a3 > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_30;
    }
    if (a3 >= 0x17)
    {
      uint64_t v11 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((a3 | 7) != 0x17) {
        uint64_t v11 = a3 | 7;
      }
      uint64_t v12 = v11 + 1;
      char v10 = operator new(v11 + 1);
      __len[1] = a3;
      unint64_t v16 = v12 | 0x8000000000000000;
      __len[0] = (size_t)v10;
    }
    else
    {
      HIBYTE(v16) = a3;
      char v10 = __len;
      if (!a3) {
        goto LABEL_20;
      }
    }
    memmove(v10, a2, a3);
LABEL_20:
    *((unsigned char *)v10 + a3) = 0;
    goto LABEL_26;
  }
LABEL_15:
  __len[0] = 0;
  __len[1] = 0;
  unint64_t v16 = 0;
LABEL_26:
  *(unsigned char *)(a4 + 24) &= ~1u;
  *(_OWORD *)a4 = *(_OWORD *)__len;
  *(void *)(a4 + 16) = v16;
LABEL_27:
  if (v18 != v20) {
    free(v18);
  }
}

double llvm::TreePathPrefixMapper::TreePathPrefixMapper(uint64_t a1, void *a2, int a3)
{
  *(_DWORD *)(a1 + --*(_DWORD *)(this + 8) = a3;
  *(void *)(a1 + 16) = a1 + 32;
  *(void *)&double result = 0x100000000;
  *(void *)(a1 + 24) = 0x100000000;
  *(void *)a1 = &unk_1F2645120;
  *(void *)(a1 + 80) = *a2;
  *a2 = 0;
  return result;
}

{
  double result;

  *(_DWORD *)(a1 + --*(_DWORD *)(this + 8) = a3;
  *(void *)(a1 + 16) = a1 + 32;
  *(void *)&double result = 0x100000000;
  *(void *)(a1 + 24) = 0x100000000;
  *(void *)a1 = &unk_1F2645120;
  *(void *)(a1 + 80) = *a2;
  *a2 = 0;
  return result;
}

void llvm::TreePathPrefixMapper::~TreePathPrefixMapper(llvm::TreePathPrefixMapper *this)
{
  *(void *)this = &unk_1F2645120;
  uint64_t v2 = (atomic_uint *)*((void *)this + 10);
  if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v2 + 8))(v2);
  }
  *(void *)this = &unk_1F2645150;
  sub_1CD83FAF4((char **)this + 2);
}

{
  uint64_t vars8;

  llvm::TreePathPrefixMapper::~TreePathPrefixMapper(this);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD09CCE8(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2 != a2)
  {
    int v3 = a2;
    if (v2 <= a2)
    {
      if (*(unsigned int *)(a1 + 12) < a2) {
        sub_1CD83FBC8();
      }
      if (v2 != a2) {
        bzero((void *)(*(void *)a1 + 48 * v2), 48 * ((-48 * v2 + 48 * a2 - 48) / 0x30) + 48);
      }
    }
    else
    {
      uint64_t v5 = 3 * v2;
      uint64_t v6 = 48 * a2 - 16 * v5;
      uint64_t v7 = *(void *)a1 + 16 * v5 - 48;
      do
      {
        uint64_t v7 = sub_1CD3C4FA4(v7) - 48;
        v6 += 48;
      }
      while (v6);
    }
    *(_DWORD *)(a1 + --*(_DWORD *)(this + 8) = v3;
  }
}

void sub_1CD09CDB8(void **a1, void **a2, unint64_t a3, char *a4, uint64_t a5, __n128 a6)
{
  if (a3 >= 2)
  {
    uint64_t v7 = (uint64_t)a1;
    if (a3 == 2)
    {
      uint64_t v8 = (uint64_t)(a2 - 6);
      char v9 = *((unsigned char *)a2 - 25);
      int v10 = v9;
      if (v9 >= 0) {
        uint64_t v11 = a2 - 6;
      }
      else {
        uint64_t v11 = (void **)*(a2 - 6);
      }
      size_t v12 = v9 & 0x7F;
      if (v10 >= 0) {
        size_t v13 = v12;
      }
      else {
        size_t v13 = *(void *)(v8 + 8);
      }
      if (*((char *)a1 + 23) < 0)
      {
        a1 = (void **)*a1;
        size_t v14 = *(void *)(v7 + 8);
      }
      else
      {
        size_t v14 = *((unsigned __int8 *)a1 + 23);
      }
      if (v13 >= v14) {
        size_t v15 = v14;
      }
      else {
        size_t v15 = v13;
      }
      int v16 = memcmp(a1, v11, v15);
      BOOL v17 = v14 < v13;
      if (v16) {
        BOOL v17 = v16 < 0;
      }
      if (v17)
      {
        *(_OWORD *)uint64_t v67 = *(_OWORD *)v7;
        uint64_t v68 = *(void *)(v7 + 16);
        *(void *)uint64_t v7 = 0;
        *(void *)(v7 + --*(_DWORD *)(this + 8) = 0;
        long long v65 = *(_OWORD *)(v7 + 24);
        *(void *)(v7 + 16) = 0;
        *(void *)(v7 + 24) = 0;
        *(_OWORD *)std::string __p = v65;
        uint64_t v70 = *(void **)(v7 + 40);
        *(void *)(v7 + 32) = 0;
        *(void *)(v7 + 40) = 0;
        sub_1CD83FCD0(v7, (long long *)v8);
        sub_1CD83FCD0(v8, (long long *)v67);
        if (SHIBYTE(v70) < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v68) < 0) {
          operator delete(v67[0]);
        }
      }
    }
    else if ((uint64_t)a3 <= 0)
    {
      if (a1 != a2)
      {
        size_t v24 = (char *)(a1 + 6);
        if (a1 + 6 != a2)
        {
          uint64_t v25 = 0;
          unint64_t v26 = a1;
          do
          {
            unint64_t v27 = v24;
            char v28 = *((unsigned char *)v26 + 71);
            BOOL v29 = v28 < 0;
            if (v28 >= 0) {
              uint64_t v30 = v27;
            }
            else {
              uint64_t v30 = (char *)v26[6];
            }
            size_t v31 = v28 & 0x7F;
            if (v29) {
              size_t v32 = (size_t)v26[7];
            }
            else {
              size_t v32 = v31;
            }
            if (*((char *)v26 + 23) < 0)
            {
              int v34 = *v26;
              size_t v33 = (size_t)v26[1];
            }
            else
            {
              size_t v33 = *((unsigned __int8 *)v26 + 23);
              int v34 = v26;
            }
            if (v32 >= v33) {
              size_t v35 = v33;
            }
            else {
              size_t v35 = v32;
            }
            int v36 = memcmp(v34, v30, v35);
            BOOL v37 = v33 < v32;
            if (v36) {
              BOOL v37 = v36 < 0;
            }
            if (v37)
            {
              uint64_t v68 = *((void *)v27 + 2);
              *(_OWORD *)uint64_t v67 = *(_OWORD *)v27;
              *((void *)v27 + 1) = 0;
              *((void *)v27 + 2) = 0;
              *(void *)unint64_t v27 = 0;
              *(_OWORD *)std::string __p = *(_OWORD *)(v26 + 9);
              uint64_t v70 = v26[11];
              v26[9] = 0;
              v26[10] = 0;
              v26[11] = 0;
              if (v68 >= 0) {
                int v38 = v67;
              }
              else {
                int v38 = (void **)v67[0];
              }
              if (v68 >= 0) {
                uint64_t v39 = (void *)(HIBYTE(v68) & 0x7F);
              }
              else {
                uint64_t v39 = v67[1];
              }
              uint64_t v40 = v25;
              while (1)
              {
                uint64_t v41 = v7 + v40;
                sub_1CD83FCD0(v7 + v40 + 48, (long long *)(v7 + v40));
                if (!v40) {
                  break;
                }
                int v42 = (void *)(v41 - 48);
                if (*(char *)(v41 - 25) < 0)
                {
                  size_t v43 = *(void *)(v7 + v40 - 40);
                  int v42 = (void *)*v42;
                }
                else
                {
                  size_t v43 = *(unsigned __int8 *)(v41 - 25);
                }
                if ((unint64_t)v39 >= v43) {
                  size_t v44 = v43;
                }
                else {
                  size_t v44 = (size_t)v39;
                }
                int v45 = memcmp(v42, v38, v44);
                BOOL v46 = v43 < (unint64_t)v39;
                if (v45) {
                  BOOL v46 = v45 < 0;
                }
                v40 -= 48;
                if (!v46)
                {
                  uint64_t v47 = v7 + v40 + 48;
                  goto LABEL_62;
                }
              }
              uint64_t v47 = v7;
LABEL_62:
              sub_1CD83FCD0(v47, (long long *)v67);
              if (SHIBYTE(v70) < 0) {
                operator delete(__p[0]);
              }
              if (SHIBYTE(v68) < 0) {
                operator delete(v67[0]);
              }
            }
            size_t v24 = v27 + 48;
            v25 += 48;
            unint64_t v26 = (void **)v27;
          }
          while (v27 + 48 != (char *)a2);
        }
      }
    }
    else
    {
      uint64_t v20 = (uint64_t)a4;
      unint64_t v21 = a3 >> 1;
      uint64_t v22 = &a1[6 * (a3 >> 1)];
      unint64_t v23 = a3 >> 1;
      if ((uint64_t)a3 <= a5)
      {
        __n128 v48 = sub_1CD09D240(a1, v22, v23, a4, a6);
        uint64_t v49 = (char *)(v20 + 48 * v21);
        sub_1CD09D240((void **)(v7 + 48 * (a3 >> 1)), a2, a3 - (a3 >> 1), v49, v48);
        unint64_t v50 = v20 + 48 * a3;
        unint64_t v51 = v49;
        int v52 = (char *)v20;
        while (v51 != (char *)v50)
        {
          char v53 = v51[23];
          BOOL v54 = v53 < 0;
          if (v53 >= 0) {
            int v55 = v51;
          }
          else {
            int v55 = *(char **)v51;
          }
          size_t v56 = v53 & 0x7F;
          if (v54) {
            size_t v57 = *((void *)v51 + 1);
          }
          else {
            size_t v57 = v56;
          }
          if (v52[23] < 0)
          {
            int v59 = *(char **)v52;
            size_t v58 = *((void *)v52 + 1);
          }
          else
          {
            size_t v58 = v52[23];
            int v59 = v52;
          }
          if (v57 >= v58) {
            size_t v60 = v58;
          }
          else {
            size_t v60 = v57;
          }
          int v61 = memcmp(v59, v55, v60);
          BOOL v62 = v58 < v57;
          if (v61) {
            BOOL v62 = v61 < 0;
          }
          if (v62)
          {
            sub_1CD83FCD0(v7, (long long *)v51);
            v51 += 48;
          }
          else
          {
            sub_1CD83FCD0(v7, (long long *)v52);
            v52 += 48;
          }
          v7 += 48;
          if (v52 == v49)
          {
            if (v51 != (char *)v50)
            {
              uint64_t v66 = 0;
              do
              {
                sub_1CD83FCD0(v7 + v66, (long long *)&v51[v66]);
                v66 += 48;
              }
              while (&v51[v66] != (char *)v50);
            }
            goto LABEL_90;
          }
        }
        if (v52 != v49)
        {
          uint64_t v63 = 0;
          do
          {
            sub_1CD83FCD0(v7 + v63, (long long *)&v52[v63]);
            v63 += 48;
          }
          while (&v52[v63] != v49);
        }
LABEL_90:
        if (v20)
        {
          unint64_t v64 = a3;
          do
          {
            sub_1CD3C4FA4(v20);
            v20 += 48;
            --v64;
          }
          while (v64);
        }
      }
      else
      {
        sub_1CD09CDB8(a1, v22, v23, a4, a5);
        sub_1CD09CDB8(v7 + 48 * (a3 >> 1), a2, a3 - (a3 >> 1), v20, a5);
        sub_1CD09D7C0(v7, v7 + 48 * (a3 >> 1), (long long *)a2, a3 >> 1, a3 - (a3 >> 1), v20, a5);
      }
    }
  }
}

__n128 sub_1CD09D240(void **__s1, void **a2, unint64_t a3, char *a4, __n128 result)
{
  if (a3)
  {
    uint64_t v5 = a4;
    uint64_t v7 = a2;
    uint64_t v8 = __s1;
    if (a3 == 2)
    {
      uint64_t v11 = a2 - 6;
      char v12 = *((unsigned char *)a2 - 25);
      int v13 = v12;
      if (v12 >= 0) {
        size_t v14 = a2 - 6;
      }
      else {
        size_t v14 = (void **)*(a2 - 6);
      }
      size_t v15 = v12 & 0x7F;
      if (v13 >= 0) {
        size_t v16 = v15;
      }
      else {
        size_t v16 = (size_t)*(v7 - 5);
      }
      if (*((char *)__s1 + 23) < 0)
      {
        __s1 = (void **)*__s1;
        size_t v17 = (size_t)v8[1];
      }
      else
      {
        size_t v17 = *((unsigned __int8 *)__s1 + 23);
      }
      if (v16 >= v17) {
        size_t v18 = v17;
      }
      else {
        size_t v18 = v16;
      }
      int v19 = memcmp(__s1, v14, v18);
      if (v19) {
        BOOL v20 = v19 < 0;
      }
      else {
        BOOL v20 = v17 < v16;
      }
      unint64_t v21 = v5 + 24;
      uint64_t v22 = v5 + 48;
      if (v20)
      {
        long long v23 = *(_OWORD *)v11;
        *((void *)v5 + 2) = *(v7 - 4);
        *(_OWORD *)uint64_t v5 = v23;
        *(v7 - 5) = 0;
        *(v7 - 4) = 0;
        *uint64_t v11 = 0;
        long long v24 = *(_OWORD *)(v7 - 3);
        *((void *)v5 + 5) = *(v7 - 1);
        *unint64_t v21 = v24;
        *(v7 - 2) = 0;
        *(v7 - 1) = 0;
        *(v7 - 3) = 0;
        long long v25 = *(_OWORD *)v8;
        *((void *)v5 + --*(_DWORD *)(this + 8) = v8[2];
        *uint64_t v22 = v25;
        v8[1] = 0;
        v8[2] = 0;
        void *v8 = 0;
        int v10 = v8 + 3;
        double result = *(__n128 *)(v8 + 3);
        unint64_t v26 = v8[5];
      }
      else
      {
        long long v59 = *(_OWORD *)v8;
        *((void *)v5 + 2) = v8[2];
        *(_OWORD *)uint64_t v5 = v59;
        v8[1] = 0;
        v8[2] = 0;
        void *v8 = 0;
        long long v60 = *(_OWORD *)(v8 + 3);
        *((void *)v5 + 5) = v8[5];
        *unint64_t v21 = v60;
        void v8[4] = 0;
        v8[5] = 0;
        void v8[3] = 0;
        long long v61 = *(_OWORD *)v11;
        *((void *)v5 + --*(_DWORD *)(this + 8) = *(v7 - 4);
        *uint64_t v22 = v61;
        *(v7 - 5) = 0;
        *(v7 - 4) = 0;
        *uint64_t v11 = 0;
        int v10 = v7 - 3;
        double result = *(__n128 *)(v7 - 3);
        unint64_t v26 = *(v7 - 1);
      }
      *((void *)v5 + 11) = v26;
      *(__n128 *)(v5 + 72) = result;
      goto LABEL_67;
    }
    if (a3 == 1)
    {
      long long v9 = *(_OWORD *)__s1;
      *((void *)a4 + 2) = __s1[2];
      *(_OWORD *)a4 = v9;
      __s1[1] = 0;
      __s1[2] = 0;
      void *__s1 = 0;
      int v10 = __s1 + 3;
      double result = *(__n128 *)(__s1 + 3);
      *((void *)a4 + 5) = __s1[5];
      *(__n128 *)(a4 + 24) = result;
LABEL_67:
      *int v10 = 0;
      v10[1] = 0;
      v10[2] = 0;
      return result;
    }
    if ((uint64_t)a3 > 8)
    {
      BOOL v62 = &__s1[6 * (a3 >> 1)];
      sub_1CD09CDB8(__s1, v62, a3 >> 1, a4, a3 >> 1);
      sub_1CD09CDB8(&v8[6 * (a3 >> 1)], v7, a3 - (a3 >> 1), &v5[48 * (a3 >> 1)], a3 - (a3 >> 1));
      uint64_t v63 = (const void **)&v8[6 * (a3 >> 1)];
      while (v63 != (const void **)v7)
      {
        char v64 = *((unsigned char *)v63 + 23);
        BOOL v65 = v64 < 0;
        if (v64 >= 0) {
          uint64_t v66 = v63;
        }
        else {
          uint64_t v66 = *v63;
        }
        size_t v67 = v64 & 0x7F;
        if (v65) {
          size_t v68 = (size_t)v63[1];
        }
        else {
          size_t v68 = v67;
        }
        if (*((char *)v8 + 23) < 0)
        {
          uint64_t v70 = *v8;
          size_t v69 = (size_t)v8[1];
        }
        else
        {
          size_t v69 = *((unsigned __int8 *)v8 + 23);
          uint64_t v70 = v8;
        }
        if (v68 >= v69) {
          size_t v71 = v69;
        }
        else {
          size_t v71 = v68;
        }
        int v72 = memcmp(v70, v66, v71);
        BOOL v73 = v72 < 0;
        if (!v72) {
          BOOL v73 = v69 < v68;
        }
        uint64_t v74 = (__n128 *)(v5 + 24);
        if (v73)
        {
          long long v75 = *(_OWORD *)v63;
          *((void *)v5 + 2) = v63[2];
          *(_OWORD *)uint64_t v5 = v75;
          v63[1] = 0;
          v63[2] = 0;
          *uint64_t v63 = 0;
          double result = *(__n128 *)(v63 + 3);
          *((void *)v5 + 5) = v63[5];
          *uint64_t v74 = result;
          v63[4] = 0;
          v63[5] = 0;
          void v63[3] = 0;
          v63 += 6;
        }
        else
        {
          long long v76 = *(_OWORD *)v8;
          *((void *)v5 + 2) = v8[2];
          *(_OWORD *)uint64_t v5 = v76;
          v8[1] = 0;
          v8[2] = 0;
          void *v8 = 0;
          double result = *(__n128 *)(v8 + 3);
          *((void *)v5 + 5) = v8[5];
          *uint64_t v74 = result;
          void v8[4] = 0;
          v8[5] = 0;
          void v8[3] = 0;
          v8 += 6;
        }
        v5 += 48;
        if (v8 == v62)
        {
          if (v63 != (const void **)v7)
          {
            uint64_t v81 = 0;
            do
            {
              uint64_t v82 = &v63[v81];
              int v83 = &v5[v81 * 8];
              long long v84 = *(_OWORD *)&v63[v81];
              *((void *)v83 + 2) = v63[v81 + 2];
              *(_OWORD *)int v83 = v84;
              v82[1] = 0;
              v82[2] = 0;
              *uint64_t v82 = 0;
              double result = *(__n128 *)&v63[v81 + 3];
              *((void *)v83 + 5) = v63[v81 + 5];
              *(__n128 *)(v83 + 24) = result;
              v82[4] = 0;
              v82[5] = 0;
              v82[3] = 0;
              v81 += 6;
            }
            while (v82 + 6 != (const void **)v7);
          }
          return result;
        }
      }
      if (v8 != v62)
      {
        uint64_t v77 = 0;
        do
        {
          unint64_t v78 = &v5[v77 * 8];
          int v79 = &v8[v77];
          long long v80 = *(_OWORD *)&v8[v77];
          *((void *)v78 + 2) = v8[v77 + 2];
          *(_OWORD *)unint64_t v78 = v80;
          v79[1] = 0;
          v79[2] = 0;
          *int v79 = 0;
          double result = *(__n128 *)&v8[v77 + 3];
          *((void *)v78 + 5) = v8[v77 + 5];
          *(__n128 *)(v78 + 24) = result;
          v79[4] = 0;
          v79[5] = 0;
          v79[3] = 0;
          v77 += 6;
        }
        while (v79 + 6 != v62);
      }
    }
    else if (__s1 != a2)
    {
      long long v27 = *(_OWORD *)__s1;
      *((void *)a4 + 2) = __s1[2];
      *(_OWORD *)a4 = v27;
      __s1[1] = 0;
      __s1[2] = 0;
      void *__s1 = 0;
      double result = *(__n128 *)(__s1 + 3);
      *((void *)a4 + 5) = __s1[5];
      *(__n128 *)(a4 + 24) = result;
      __s1[4] = 0;
      __s1[5] = 0;
      __s1[3] = 0;
      char v28 = (char *)(__s1 + 6);
      if (__s1 + 6 != a2)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (long long *)a4;
        do
        {
          size_t v31 = v28;
          char v32 = *((unsigned char *)v8 + 71);
          BOOL v33 = v32 < 0;
          if (v32 >= 0) {
            int v34 = v31;
          }
          else {
            int v34 = (char *)v8[6];
          }
          size_t v35 = (void *)(v32 & 0x7F);
          if (v33) {
            int v36 = v8[7];
          }
          else {
            int v36 = v35;
          }
          if (*((char *)v30 + 23) < 0)
          {
            int v38 = *(long long **)v30;
            size_t v37 = *((void *)v30 + 1);
          }
          else
          {
            size_t v37 = *((unsigned __int8 *)v30 + 23);
            int v38 = v30;
          }
          uint64_t v39 = v30 + 3;
          if ((unint64_t)v36 >= v37) {
            size_t v40 = v37;
          }
          else {
            size_t v40 = (size_t)v36;
          }
          int v41 = memcmp(v38, v34, v40);
          BOOL v42 = v41 < 0;
          if (!v41) {
            BOOL v42 = v37 < (unint64_t)v36;
          }
          size_t v43 = (long long *)((char *)v30 + 72);
          if (v42)
          {
            *uint64_t v39 = *v30;
            *((void *)v30 + --*(_DWORD *)(this + 8) = *((void *)v30 + 2);
            *(void *)uint64_t v30 = 0;
            *((void *)v30 + 1) = 0;
            long long v45 = *(long long *)((char *)v30 + 24);
            *((void *)v30 + 2) = 0;
            *((void *)v30 + 3) = 0;
            *size_t v43 = v45;
            *((void *)v30 + 11) = *((void *)v30 + 5);
            uint64_t v46 = (uint64_t)v5;
            *((void *)v30 + 4) = 0;
            *((void *)v30 + 5) = 0;
            if (v30 != (long long *)v5)
            {
              int v85 = v7;
              uint64_t v47 = v29;
              while (1)
              {
                __n128 v48 = &v5[v47];
                char v49 = *((unsigned char *)v8 + 71);
                int v50 = v49;
                unint64_t v51 = v49 >= 0 ? v31 : *(char **)v31;
                int v52 = (void *)(v49 & 0x7F);
                char v53 = v50 >= 0 ? v52 : v8[7];
                if (*(v48 - 25) < 0)
                {
                  unint64_t v54 = *((void *)v48 - 5);
                  int v55 = *(char **)&v5[v47 - 48];
                }
                else
                {
                  unint64_t v54 = *(v48 - 25);
                  int v55 = &v5[v47 - 48];
                }
                size_t v56 = (unint64_t)v53 >= v54 ? v54 : (size_t)v53;
                int v57 = memcmp(v55, v51, v56);
                BOOL v58 = v54 < (unint64_t)v53;
                if (v57) {
                  BOOL v58 = v57 < 0;
                }
                if (!v58) {
                  break;
                }
                sub_1CD83FCD0((uint64_t)&v5[v47], (long long *)&v5[v47 - 48]);
                v47 -= 48;
                if (!v47)
                {
                  uint64_t v46 = (uint64_t)v5;
                  goto LABEL_63;
                }
              }
              uint64_t v46 = (uint64_t)&v5[v47];
LABEL_63:
              uint64_t v7 = v85;
            }
            sub_1CD83FCD0(v46, (long long *)v31);
          }
          else
          {
            long long v44 = *(_OWORD *)v31;
            *((void *)v30 + --*(_DWORD *)(this + 8) = *((void *)v31 + 2);
            *uint64_t v39 = v44;
            *((void *)v31 + 1) = 0;
            *((void *)v31 + 2) = 0;
            *(void *)size_t v31 = 0;
            double result = *(__n128 *)(v8 + 9);
            *((void *)v30 + 11) = v8[11];
            *size_t v43 = result;
            v8[10] = 0;
            v8[11] = 0;
            v8[9] = 0;
          }
          char v28 = v31 + 48;
          v29 += 48;
          uint64_t v30 = v39;
          uint64_t v8 = (void **)v31;
        }
        while (v31 + 48 != (char *)v7);
      }
    }
  }
  return result;
}

void sub_1CD09D7C0(uint64_t a1, uint64_t a2, long long *a3, int64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v128 = a5;
  if (a5)
  {
    while (a4 > a7 && v128 > a7)
    {
      if (!a4) {
        return;
      }
      uint64_t v13 = 0;
      char v14 = *(unsigned char *)(a2 + 23);
      BOOL v15 = v14 < 0;
      if (v14 >= 0) {
        size_t v16 = (const void *)a2;
      }
      else {
        size_t v16 = *(const void **)a2;
      }
      size_t v17 = v14 & 0x7F;
      if (v15) {
        size_t v18 = *(void *)(a2 + 8);
      }
      else {
        size_t v18 = v17;
      }
      uint64_t v19 = -a4;
      while (1)
      {
        BOOL v20 = (void *)(a1 + v13);
        if (*(char *)(a1 + v13 + 23) < 0)
        {
          BOOL v20 = (void *)*v20;
          size_t v21 = *(void *)(a1 + v13 + 8);
        }
        else
        {
          size_t v21 = *(unsigned __int8 *)(a1 + v13 + 23);
        }
        if (v18 >= v21) {
          size_t v22 = v21;
        }
        else {
          size_t v22 = v18;
        }
        int v23 = memcmp(v20, v16, v22);
        BOOL v24 = v21 < v18;
        if (v23) {
          BOOL v24 = v23 < 0;
        }
        if (v24) {
          break;
        }
        v13 += 48;
        if (__CFADD__(v19++, 1)) {
          return;
        }
      }
      uint64_t v26 = -v19;
      uint64_t v27 = a1 + v13;
      uint64_t v121 = a7;
      uint64_t v122 = a6;
      uint64_t v120 = a3;
      unint64_t v126 = (const void **)(a1 + v13);
      uint64_t v127 = (long long *)a2;
      if (-v19 >= v128)
      {
        if (v19 == -1)
        {
          uint64_t v115 = (void *)(a1 + v13);
          long long v116 = *(_OWORD *)(a1 + v13);
          uint64_t v130 = *(void *)(a1 + v13 + 16);
          *(_OWORD *)BOOL v129 = v116;
          v115[1] = 0;
          v115[2] = 0;
          *uint64_t v115 = 0;
          long long v117 = *(_OWORD *)(a1 + v13 + 24);
          uint64_t v132 = *(void *)(a1 + v13 + 40);
          *(_OWORD *)std::string __p = v117;
          v115[4] = 0;
          v115[5] = 0;
          v115[3] = 0;
          sub_1CD83FCD0(a1 + v13, (long long *)a2);
          sub_1CD83FCD0(a2, (long long *)v129);
          if (SHIBYTE(v132) < 0) {
            operator delete(__p[0]);
          }
          if (SHIBYTE(v130) < 0) {
            operator delete(v129[0]);
          }
          return;
        }
        if (v19 > 0) {
          uint64_t v26 = 1 - v19;
        }
        uint64_t v124 = v26 >> 1;
        uint64_t v44 = a1;
        size_t v31 = (const void **)(a1 + 48 * (v26 >> 1) + v13);
        uint64_t v30 = (uint64_t)a3;
        if (a3 != (long long *)a2)
        {
          unint64_t v45 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)a3 - a2) >> 4);
          uint64_t v46 = v44 + 48 * v124 + v13;
          size_t v47 = *(unsigned __int8 *)(v46 + 23);
          uint64_t v30 = a2;
          do
          {
            unint64_t v48 = v30 + 48 * (v45 >> 1);
            char v49 = *(unsigned char *)(v48 + 23);
            BOOL v50 = v49 < 0;
            if (v49 >= 0) {
              unint64_t v51 = (const void *)(v30 + 48 * (v45 >> 1));
            }
            else {
              unint64_t v51 = *(const void **)v48;
            }
            size_t v52 = v49 & 0x7F;
            if (v50) {
              size_t v53 = *(void *)(v48 + 8);
            }
            else {
              size_t v53 = v52;
            }
            size_t v54 = v47;
            int v55 = v31;
            if ((v47 & 0x80) != 0)
            {
              size_t v54 = *(void *)(v46 + 8);
              int v55 = *v31;
            }
            if (v53 >= v54) {
              size_t v56 = v54;
            }
            else {
              size_t v56 = v53;
            }
            int v57 = memcmp(v55, v51, v56);
            BOOL v58 = v54 < v53;
            if (v57) {
              BOOL v58 = v57 < 0;
            }
            if (v58) {
              v45 += ~(v45 >> 1);
            }
            else {
              v45 >>= 1;
            }
            if (v58) {
              uint64_t v30 = v48 + 48;
            }
          }
          while (v45);
        }
        long long v60 = v127;
        unint64_t v61 = 0xAAAAAAAAAAAAAAABLL * ((v30 - (uint64_t)v127) >> 4);
        unint64_t v59 = v124;
      }
      else
      {
        uint64_t v123 = a1;
        if (v128 >= 0) {
          uint64_t v28 = v128;
        }
        else {
          uint64_t v28 = v128 + 1;
        }
        uint64_t v29 = v28 >> 1;
        uint64_t v118 = v28 >> 1;
        uint64_t v30 = a2 + 48 * (v28 >> 1);
        size_t v31 = (const void **)a2;
        if (v27 != a2)
        {
          size_t v31 = v126;
          unint64_t v32 = 0xAAAAAAAAAAAAAAABLL * ((a2 - v123 - v13) >> 4);
          char v33 = *(unsigned char *)(v30 + 23);
          BOOL v34 = v33 < 0;
          if (v33 >= 0) {
            size_t v35 = (const void *)(a2 + 48 * v29);
          }
          else {
            size_t v35 = *(const void **)v30;
          }
          size_t v36 = v33 & 0x7F;
          if (v34) {
            size_t v37 = *(void *)(v30 + 8);
          }
          else {
            size_t v37 = v36;
          }
          do
          {
            int v38 = &v31[6 * (v32 >> 1)];
            if (*((char *)v38 + 23) < 0)
            {
              size_t v40 = (const void **)*v38;
              size_t v39 = (size_t)v38[1];
            }
            else
            {
              size_t v39 = *((unsigned __int8 *)v38 + 23);
              size_t v40 = &v31[6 * (v32 >> 1)];
            }
            if (v37 >= v39) {
              size_t v41 = v39;
            }
            else {
              size_t v41 = v37;
            }
            int v42 = memcmp(v40, v35, v41);
            BOOL v43 = v39 < v37;
            if (v42) {
              BOOL v43 = v42 < 0;
            }
            if (v43)
            {
              v32 >>= 1;
            }
            else
            {
              size_t v31 = v38 + 6;
              v32 += ~(v32 >> 1);
            }
          }
          while (v32);
        }
        unint64_t v59 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v31 - v123 - v13) >> 4);
        long long v60 = v127;
        unint64_t v61 = v118;
      }
      BOOL v62 = (long long *)v30;
      a7 = v121;
      a6 = v122;
      if (v31 != (const void **)v60)
      {
        BOOL v62 = (long long *)v31;
        if (v60 != (long long *)v30)
        {
          unint64_t v125 = v59;
          uint64_t v63 = (uint64_t)v31;
          BOOL v62 = v60;
          while (1)
          {
            long long v64 = *(_OWORD *)v63;
            uint64_t v130 = *(void *)(v63 + 16);
            *(_OWORD *)BOOL v129 = v64;
            *(void *)(v63 + --*(_DWORD *)(this + 8) = 0;
            *(void *)(v63 + 16) = 0;
            *(void *)uint64_t v63 = 0;
            long long v65 = *(_OWORD *)(v63 + 24);
            uint64_t v132 = *(void *)(v63 + 40);
            *(_OWORD *)std::string __p = v65;
            *(void *)(v63 + 32) = 0;
            *(void *)(v63 + 40) = 0;
            *(void *)(v63 + 24) = 0;
            sub_1CD83FCD0(v63, v60);
            sub_1CD83FCD0((uint64_t)v60, (long long *)v129);
            if (SHIBYTE(v132) < 0) {
              operator delete(__p[0]);
            }
            if (SHIBYTE(v130) < 0) {
              operator delete(v129[0]);
            }
            v60 += 3;
            v63 += 48;
            if (v60 == (long long *)v30) {
              break;
            }
            if ((long long *)v63 == v62) {
              BOOL v62 = v60;
            }
          }
          if ((long long *)v63 != v62)
          {
            unint64_t v119 = v61;
            uint64_t v66 = v63;
            size_t v67 = v62;
            do
            {
              while (1)
              {
                long long v68 = *(_OWORD *)v66;
                uint64_t v130 = *(void *)(v66 + 16);
                *(_OWORD *)BOOL v129 = v68;
                *(void *)(v66 + --*(_DWORD *)(this + 8) = 0;
                *(void *)(v66 + 16) = 0;
                *(void *)uint64_t v66 = 0;
                long long v69 = *(_OWORD *)(v66 + 24);
                uint64_t v132 = *(void *)(v66 + 40);
                *(_OWORD *)std::string __p = v69;
                *(void *)(v66 + 32) = 0;
                *(void *)(v66 + 40) = 0;
                *(void *)(v66 + 24) = 0;
                sub_1CD83FCD0(v66, v62);
                sub_1CD83FCD0((uint64_t)v62, (long long *)v129);
                if (SHIBYTE(v132) < 0) {
                  operator delete(__p[0]);
                }
                if (SHIBYTE(v130) < 0) {
                  operator delete(v129[0]);
                }
                v66 += 48;
                v62 += 3;
                if (v62 == (long long *)v30) {
                  break;
                }
                if ((long long *)v66 == v67) {
                  size_t v67 = v62;
                }
              }
              BOOL v62 = v67;
            }
            while ((long long *)v66 != v67);
            BOOL v62 = (long long *)v63;
            unint64_t v61 = v119;
          }
          unint64_t v59 = v125;
        }
      }
      a4 = -(uint64_t)v59 - v19;
      unint64_t v70 = v128 - v61;
      if ((uint64_t)(v59 + v61) >= (uint64_t)(v128 - (v59 + v61) - v19))
      {
        sub_1CD09D7C0(v62, v30, v120, -(uint64_t)v59 - v19, v128 - v61, v122, v121);
        uint64_t v30 = (uint64_t)v31;
        unint64_t v70 = v61;
        a4 = v59;
        a3 = v62;
        a1 = (uint64_t)v126;
      }
      else
      {
        sub_1CD09D7C0(v126, v31, v62, v59, v61, v122, v121);
        a1 = (uint64_t)v62;
        a3 = v120;
      }
      uint64_t v128 = v70;
      a2 = v30;
      if (!v70) {
        return;
      }
    }
    if (a4 <= v128)
    {
      if (a1 == a2) {
        return;
      }
      uint64_t v93 = 0;
      uint64_t v72 = 0;
      do
      {
        uint64_t v94 = a6 + v93;
        int v95 = (void *)(a1 + v93);
        long long v96 = *(_OWORD *)(a1 + v93);
        *(void *)(v94 + 16) = *(void *)(a1 + v93 + 16);
        *(_OWORD *)uint64_t v94 = v96;
        v95[1] = 0;
        v95[2] = 0;
        *int v95 = 0;
        long long v97 = *(_OWORD *)(a1 + v93 + 24);
        *(void *)(v94 + 40) = *(void *)(a1 + v93 + 40);
        *(_OWORD *)(v94 + 24) = v97;
        v95[4] = 0;
        v95[5] = 0;
        v95[3] = 0;
        ++v72;
        v93 += 48;
      }
      while (v95 + 6 != (void *)a2);
      if (v93)
      {
        unint64_t v98 = (char *)(a6 + v93);
        uint64_t v99 = a6 + v93 - 48;
        unint64_t v100 = (char *)a6;
        while ((long long *)a2 != a3)
        {
          char v101 = *(unsigned char *)(a2 + 23);
          BOOL v102 = v101 < 0;
          unint64_t v103 = (long long *)a2;
          if (v101 >= 0) {
            uint64_t v104 = (const void *)a2;
          }
          else {
            uint64_t v104 = *(const void **)a2;
          }
          size_t v105 = v101 & 0x7F;
          if (v102) {
            size_t v106 = *(void *)(a2 + 8);
          }
          else {
            size_t v106 = v105;
          }
          if (v100[23] < 0)
          {
            unint64_t v108 = *(char **)v100;
            size_t v107 = *((void *)v100 + 1);
          }
          else
          {
            size_t v107 = v100[23];
            unint64_t v108 = v100;
          }
          if (v106 >= v107) {
            size_t v109 = v107;
          }
          else {
            size_t v109 = v106;
          }
          int v110 = memcmp(v108, v104, v109);
          BOOL v111 = v107 < v106;
          if (v110) {
            BOOL v111 = v110 < 0;
          }
          if (v111)
          {
            sub_1CD83FCD0(a1, v103);
            a2 = (uint64_t)(v103 + 3);
          }
          else
          {
            sub_1CD83FCD0(a1, (long long *)v100);
            v100 += 48;
            a2 = (uint64_t)v103;
          }
          a1 += 48;
          if (v98 == v100) {
            goto LABEL_167;
          }
        }
        if (v98 != v100)
        {
          uint64_t v114 = 0;
          do
          {
            sub_1CD83FCD0(a1 + v114, (long long *)&v100[v114]);
            v114 += 48;
          }
          while ((char *)v99 != &v100[v114 - 48]);
        }
      }
    }
    else
    {
      if ((long long *)a2 == a3) {
        return;
      }
      uint64_t v71 = 0;
      uint64_t v72 = 0;
      do
      {
        uint64_t v73 = a6 + v71;
        uint64_t v74 = (void *)(a2 + v71);
        long long v75 = *(_OWORD *)(a2 + v71);
        *(void *)(v73 + 16) = *(void *)(a2 + v71 + 16);
        *(_OWORD *)uint64_t v73 = v75;
        v74[1] = 0;
        v74[2] = 0;
        *uint64_t v74 = 0;
        long long v76 = *(_OWORD *)(a2 + v71 + 24);
        *(void *)(v73 + 40) = *(void *)(a2 + v71 + 40);
        *(_OWORD *)(v73 + 24) = v76;
        v74[4] = 0;
        v74[5] = 0;
        v74[3] = 0;
        ++v72;
        v71 += 48;
      }
      while (v74 + 6 != (void *)a3);
      if (v71)
      {
        uint64_t v77 = a6 + v71;
        uint64_t v78 = (uint64_t)(a3 - 3);
        while (a2 != a1)
        {
          int v79 = (void *)(a2 - 48);
          char v80 = *(unsigned char *)(v77 - 25);
          BOOL v81 = v80 < 0;
          if (v80 >= 0) {
            uint64_t v82 = (const void *)(v77 - 48);
          }
          else {
            uint64_t v82 = *(const void **)(v77 - 48);
          }
          size_t v83 = v80 & 0x7F;
          uint64_t v84 = a2;
          if (v81) {
            size_t v85 = *(void *)(v77 - 40);
          }
          else {
            size_t v85 = v83;
          }
          uint64_t v86 = v84;
          if (*(char *)(v84 - 25) < 0)
          {
            int v88 = *(const void **)(v84 - 48);
            size_t v87 = *(void *)(v84 - 40);
          }
          else
          {
            size_t v87 = *(unsigned __int8 *)(v84 - 25);
            int v88 = v79;
          }
          if (v85 >= v87) {
            size_t v89 = v87;
          }
          else {
            size_t v89 = v85;
          }
          int v90 = memcmp(v88, v82, v89);
          BOOL v91 = v87 < v85;
          if (v90) {
            BOOL v91 = v90 < 0;
          }
          if (v91) {
            unint64_t v92 = (long long *)v79;
          }
          else {
            unint64_t v92 = (long long *)(v77 - 48);
          }
          if (v91) {
            a2 = (uint64_t)v79;
          }
          else {
            a2 = v86;
          }
          if (!v91) {
            v77 -= 48;
          }
          sub_1CD83FCD0(v78, v92);
          v78 -= 48;
          if (v77 == a6) {
            goto LABEL_167;
          }
        }
        if (v77 != a6)
        {
          uint64_t v112 = 0;
          do
          {
            uint64_t v113 = v78 + v112;
            v112 -= 48;
            sub_1CD83FCD0(v113, (long long *)(v77 + v112));
          }
          while (v77 + v112 != a6);
        }
      }
    }
LABEL_167:
    if (a6)
    {
      do
      {
        sub_1CD3C4FA4(a6);
        a6 += 48;
        --v72;
      }
      while (v72);
    }
  }
}

std::string *sub_1CD09DFB8(std::string *__str, std::string *a2, std::string *this)
{
  if (__str != a2)
  {
    uint64_t v5 = __str;
    do
    {
      std::string::operator=(this, v5);
      std::string::operator=(this + 1, v5 + 1);
      this += 2;
      v5 += 2;
    }
    while (v5 != a2);
  }
  return this;
}

uint64_t sub_1CD09E01C(uint64_t a1)
{
  *(void *)(a1 + 24) = &unk_1F2645150;
  sub_1CD83FAF4((char **)(a1 + 40));
  *(void *)a1 = &unk_1F2645A20;
  unint64_t v2 = *(atomic_uint **)(a1 + 16);
  if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_1CD09E0C4(uint64_t a1)
{
  *(void *)(a1 + 24) = &unk_1F2645150;
  sub_1CD83FAF4((char **)(a1 + 40));
  *(void *)a1 = &unk_1F2645A20;
  unint64_t v2 = *(atomic_uint **)(a1 + 16);
  if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v2 + 8))(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD09E18C(llvm::raw_ostream *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v21[32] = *MEMORY[0x1E4F143B8];
  size_t v18 = &v19;
  uint64_t v19 = v21;
  long long v20 = xmmword_1CD96DBF0;
  LODWORD(v11) = 0;
  char v15 = 0;
  uint64_t v16 = 0;
  int v17 = 0;
  int v10 = (char *)&unk_1F2646FA8;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t v6 = llvm::Twine::printOneChild(a1, (llvm::raw_ostream *)&v10, *(void *)a2, *(void *)(a2 + 8), *(unsigned char *)(a2 + 32));
  llvm::Twine::printOneChild(v6, (llvm::raw_ostream *)&v10, *(void *)(a2 + 16), *(void *)(a2 + 24), *(unsigned char *)(a2 + 33));
  int v10 = (char *)&unk_1F2646B98;
  if (v17 == 1 && v12) {
    MEMORY[0x1D25D9CB0](v12, 0x1000C8077774924);
  }
  llvm::PrefixMapper::mapInPlace((uint64_t)a1 + 24, &v19, &v10);
  if (v10)
  {
    long long v9 = v10;
    uint64_t v7 = llvm::errorToErrorCode(&v9);
    *(unsigned char *)(a3 + 80) |= 1u;
    *(void *)a3 = v7;
    *(void *)(a3 + --*(_DWORD *)(this + 8) = v8;
    if (v9) {
      (*(void (**)(char *))(*(void *)v9 + 8))(v9);
    }
  }
  else
  {
    LOWORD(v14) = 261;
    int v10 = (char *)v19;
    uint64_t v11 = v20;
    (*(void (**)(void *, char **))(**((void **)a1 + 2) + 16))(*((void **)a1 + 2), &v10);
  }
  if (v19 != v21) {
    free(v19);
  }
}

void sub_1CD09E364(llvm::raw_ostream *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v21[32] = *MEMORY[0x1E4F143B8];
  size_t v18 = &v19;
  uint64_t v19 = v21;
  long long v20 = xmmword_1CD96DBF0;
  LODWORD(v11) = 0;
  char v15 = 0;
  uint64_t v16 = 0;
  int v17 = 0;
  int v10 = (char *)&unk_1F2646FA8;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t v6 = llvm::Twine::printOneChild(a1, (llvm::raw_ostream *)&v10, *(void *)a2, *(void *)(a2 + 8), *(unsigned char *)(a2 + 32));
  llvm::Twine::printOneChild(v6, (llvm::raw_ostream *)&v10, *(void *)(a2 + 16), *(void *)(a2 + 24), *(unsigned char *)(a2 + 33));
  int v10 = (char *)&unk_1F2646B98;
  if (v17 == 1 && v12) {
    MEMORY[0x1D25D9CB0](v12, 0x1000C8077774924);
  }
  llvm::PrefixMapper::mapInPlace((uint64_t)a1 + 24, &v19, &v10);
  if (v10)
  {
    long long v9 = v10;
    uint64_t v7 = llvm::errorToErrorCode(&v9);
    *(unsigned char *)(a3 + 16) |= 1u;
    *(void *)a3 = v7;
    *(void *)(a3 + --*(_DWORD *)(this + 8) = v8;
    if (v9) {
      (*(void (**)(char *))(*(void *)v9 + 8))(v9);
    }
  }
  else
  {
    LOWORD(v14) = 261;
    int v10 = (char *)v19;
    uint64_t v11 = v20;
    (*(void (**)(void *, char **))(**((void **)a1 + 2) + 24))(*((void **)a1 + 2), &v10);
  }
  if (v19 != v21) {
    free(v19);
  }
}

void sub_1CD09E53C(llvm::raw_ostream *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, void *a4@<X8>)
{
  v22[32] = *MEMORY[0x1E4F143B8];
  uint64_t v19 = &v20;
  long long v20 = v22;
  long long v21 = xmmword_1CD96DBF0;
  LODWORD(v12) = 0;
  char v16 = 0;
  uint64_t v17 = 0;
  int v18 = 0;
  uint64_t v11 = (char *)&unk_1F2646FA8;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v8 = llvm::Twine::printOneChild(a1, (llvm::raw_ostream *)&v11, *(void *)a2, *(void *)(a2 + 8), *(unsigned char *)(a2 + 32));
  llvm::Twine::printOneChild(v8, (llvm::raw_ostream *)&v11, *(void *)(a2 + 16), *(void *)(a2 + 24), *(unsigned char *)(a2 + 33));
  uint64_t v11 = (char *)&unk_1F2646B98;
  if (v18 == 1 && v13) {
    MEMORY[0x1D25D9CB0](v13, 0x1000C8077774924);
  }
  llvm::PrefixMapper::mapInPlace((uint64_t)a1 + 24, &v20, &v11);
  if (v11)
  {
    int v10 = v11;
    *a3 = llvm::errorToErrorCode(&v10);
    a3[1] = v9;
    if (v10) {
      (*(void (**)(char *))(*(void *)v10 + 8))(v10);
    }
    *a4 = 0;
    a4[1] = 0;
  }
  else
  {
    LOWORD(v15) = 261;
    uint64_t v11 = (char *)v20;
    uint64_t v12 = v21;
    (*(void (**)(void *, char **, uint64_t *))(**((void **)a1 + 2) + 32))(*((void **)a1 + 2), &v11, a3);
  }
  if (v20 != v22) {
    free(v20);
  }
}

uint64_t sub_1CD09E71C(llvm::raw_ostream *a1, uint64_t a2)
{
  v19[32] = *MEMORY[0x1E4F143B8];
  char v16 = &v17;
  uint64_t v17 = v19;
  long long v18 = xmmword_1CD96DBF0;
  LODWORD(v9) = 0;
  char v13 = 0;
  uint64_t v14 = 0;
  int v15 = 0;
  uint64_t v8 = (char *)&unk_1F2646FA8;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v4 = llvm::Twine::printOneChild(a1, (llvm::raw_ostream *)&v8, *(void *)a2, *(void *)(a2 + 8), *(unsigned char *)(a2 + 32));
  llvm::Twine::printOneChild(v4, (llvm::raw_ostream *)&v8, *(void *)(a2 + 16), *(void *)(a2 + 24), *(unsigned char *)(a2 + 33));
  uint64_t v8 = (char *)&unk_1F2646B98;
  if (v15 == 1 && v10) {
    MEMORY[0x1D25D9CB0](v10, 0x1000C8077774924);
  }
  llvm::PrefixMapper::mapInPlace((uint64_t)a1 + 24, &v17, &v8);
  if (v8)
  {
    uint64_t v7 = v8;
    uint64_t v5 = llvm::errorToErrorCode(&v7);
    if (v7) {
      (*(void (**)(char *))(*(void *)v7 + 8))(v7);
    }
  }
  else
  {
    LOWORD(v12) = 261;
    uint64_t v8 = (char *)v17;
    uint64_t v9 = v18;
    uint64_t v5 = (*(uint64_t (**)(void *, char **))(**((void **)a1 + 2) + 40))(*((void **)a1 + 2), &v8);
  }
  if (v17 != v19) {
    free(v17);
  }
  return v5;
}

uint64_t sub_1CD09E8F4(llvm::raw_ostream *a1, uint64_t a2, uint64_t a3)
{
  v21[32] = *MEMORY[0x1E4F143B8];
  long long v18 = &v19;
  uint64_t v19 = v21;
  long long v20 = xmmword_1CD96DBF0;
  LODWORD(v11) = 0;
  char v15 = 0;
  uint64_t v16 = 0;
  int v17 = 0;
  uint64_t v10 = (char *)&unk_1F2646FA8;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t v6 = llvm::Twine::printOneChild(a1, (llvm::raw_ostream *)&v10, *(void *)a2, *(void *)(a2 + 8), *(unsigned char *)(a2 + 32));
  llvm::Twine::printOneChild(v6, (llvm::raw_ostream *)&v10, *(void *)(a2 + 16), *(void *)(a2 + 24), *(unsigned char *)(a2 + 33));
  uint64_t v10 = (char *)&unk_1F2646B98;
  if (v17 == 1 && v12) {
    MEMORY[0x1D25D9CB0](v12, 0x1000C8077774924);
  }
  llvm::PrefixMapper::mapInPlace((uint64_t)a1 + 24, &v19, &v10);
  if (v10)
  {
    uint64_t v9 = v10;
    uint64_t v7 = llvm::errorToErrorCode(&v9);
    if (v9) {
      (*(void (**)(char *))(*(void *)v9 + 8))(v9);
    }
  }
  else
  {
    LOWORD(v14) = 261;
    uint64_t v10 = (char *)v19;
    uint64_t v11 = v20;
    uint64_t v7 = (*(uint64_t (**)(void *, char **, uint64_t))(**((void **)a1 + 2) + 56))(*((void **)a1 + 2), &v10, a3);
  }
  if (v19 != v21) {
    free(v19);
  }
  return v7;
}

uint64_t sub_1CD09EAD4(llvm::raw_ostream *a1, uint64_t a2, uint64_t a3)
{
  v21[32] = *MEMORY[0x1E4F143B8];
  long long v18 = &v19;
  uint64_t v19 = v21;
  long long v20 = xmmword_1CD96DBF0;
  LODWORD(v11) = 0;
  char v15 = 0;
  uint64_t v16 = 0;
  int v17 = 0;
  uint64_t v10 = (char *)&unk_1F2646FA8;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t v6 = llvm::Twine::printOneChild(a1, (llvm::raw_ostream *)&v10, *(void *)a2, *(void *)(a2 + 8), *(unsigned char *)(a2 + 32));
  llvm::Twine::printOneChild(v6, (llvm::raw_ostream *)&v10, *(void *)(a2 + 16), *(void *)(a2 + 24), *(unsigned char *)(a2 + 33));
  uint64_t v10 = (char *)&unk_1F2646B98;
  if (v17 == 1 && v12) {
    MEMORY[0x1D25D9CB0](v12, 0x1000C8077774924);
  }
  llvm::PrefixMapper::mapInPlace((uint64_t)a1 + 24, &v19, &v10);
  if (v10)
  {
    uint64_t v9 = v10;
    uint64_t v7 = llvm::errorToErrorCode(&v9);
    if (v9) {
      (*(void (**)(char *))(*(void *)v9 + 8))(v9);
    }
  }
  else
  {
    LOWORD(v14) = 261;
    uint64_t v10 = (char *)v19;
    uint64_t v11 = v20;
    uint64_t v7 = (*(uint64_t (**)(void *, char **, uint64_t))(**((void **)a1 + 2) + 80))(*((void **)a1 + 2), &v10, a3);
  }
  if (v19 != v21) {
    free(v19);
  }
  return v7;
}

uint64_t llvm::PrettyStackTraceEntry::PrettyStackTraceEntry(uint64_t result, int a2)
{
  *(void *)double result = &unk_1F2645208;
  *(_DWORD *)(result + --*(_DWORD *)(this + 8) = a2;
  return result;
}

llvm::PrettyStackTraceFormat *llvm::PrettyStackTraceFormat::PrettyStackTraceFormat(llvm::PrettyStackTraceFormat *this, const char *__format, ...)
{
  va_start(va, __format);
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 3) = (char *)this + 48;
  uint64_t v4 = (char **)((char *)this + 24);
  *(void *)this = &unk_1F2645230;
  *((_OWORD *)this + 2) = xmmword_1CDC7F9D0;
  int v5 = vsnprintf(0, 0, __format, va);
  if ((v5 & 0x80000000) == 0)
  {
    size_t v6 = (v5 + 1);
    size_t v7 = *((void *)this + 4);
    if (v7 != v6)
    {
      if (v7 <= v6)
      {
        if (*((void *)this + 5) < v6) {
          llvm::SmallVectorBase<unsigned long long>::grow_pod();
        }
        if (v6 != v7) {
          bzero(&(*v4)[v7], v6 - v7);
        }
      }
      *((void *)this + 4) = v6;
    }
    vsnprintf(*v4, v6, __format, va);
  }
  return this;
}

{
  char **v4;
  int v5;
  size_t v6;
  size_t v7;
  va_list va;

  va_start(va, __format);
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 3) = (char *)this + 48;
  uint64_t v4 = (char **)((char *)this + 24);
  *(void *)this = &unk_1F2645230;
  *((_OWORD *)this + 2) = xmmword_1CDC7F9D0;
  int v5 = vsnprintf(0, 0, __format, va);
  if ((v5 & 0x80000000) == 0)
  {
    size_t v6 = (v5 + 1);
    size_t v7 = *((void *)this + 4);
    if (v7 != v6)
    {
      if (v7 <= v6)
      {
        if (*((void *)this + 5) < v6) {
          llvm::SmallVectorBase<unsigned long long>::grow_pod();
        }
        if (v6 != v7) {
          bzero(&(*v4)[v7], v6 - v7);
        }
      }
      *((void *)this + 4) = v6;
    }
    vsnprintf(*v4, v6, __format, va);
  }
  return this;
}

llvm::raw_ostream *llvm::PrettyStackTraceFormat::print(llvm::PrettyStackTraceFormat *this, llvm::raw_ostream *a2)
{
  double result = llvm::raw_ostream::write(a2, *((const char **)this + 3), *((void *)this + 4));
  uint64_t v4 = (unsigned char *)*((void *)a2 + 4);
  if (*((unsigned char **)a2 + 3) == v4)
  {
    return llvm::raw_ostream::write(a2, "\n", 1uLL);
  }
  else
  {
    *uint64_t v4 = 10;
    ++*((void *)a2 + 4);
  }
  return result;
}

void *sub_1CD09EF6C(void *a1)
{
  *a1 = &unk_1F2645230;
  unint64_t v2 = (void *)a1[3];
  if (v2 != a1 + 6) {
    free(v2);
  }
  return a1;
}

void sub_1CD09EFC0(void *a1)
{
  *a1 = &unk_1F2645230;
  unint64_t v2 = (void *)a1[3];
  if (v2 != a1 + 6) {
    free(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

void *llvm::RandomNumberGenerator::RandomNumberGenerator(void *a1, char *a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v63 = *MEMORY[0x1E4F143B8];
  unint64_t v6 = 5489;
  *a1 = 5489;
  for (uint64_t i = 1; i != 312; ++i)
  {
    unint64_t v6 = i + 0x5851F42D4C957F2DLL * (v6 ^ (v6 >> 62));
    a1[i] = v6;
  }
  a1[312] = 0;
  std::string __p = 0;
  long long v60 = 0;
  uint64_t v61 = 0;
  if (a3 != -2) {
    sub_1CBF2A8C4((char **)&__p, a3 + 2);
  }
  if (!atomic_load_explicit(qword_1EBCFB020, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EBCFB020, (void *(*)(void))sub_1CD09F6A4, (void (*)(void *))sub_1CD8402F4);
  }
  *(_DWORD *)std::string __p = *(void *)(qword_1EBCFB020[0] + 128);
  if (!atomic_load_explicit(qword_1EBCFB020, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EBCFB020, (void *(*)(void))sub_1CD09F6A4, (void (*)(void *))sub_1CD8402F4);
  }
  uint64_t v8 = (int *)__p;
  *((_DWORD *)__p + 1) = *(_DWORD *)(qword_1EBCFB020[0] + 132);
  if (v3)
  {
    uint64_t v9 = v8 + 2;
    do
    {
      int v10 = *a2++;
      *v9++ = v10;
      --v3;
    }
    while (v3);
  }
  uint64_t v11 = v60;
  if (v8 == v60)
  {
    uint64_t v12 = 0;
    int v17 = 0;
  }
  else
  {
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    char v15 = 0;
    do
    {
      int v16 = *v8;
      if (v15 >= v14)
      {
        uint64_t v18 = (v15 - v13) >> 2;
        unint64_t v19 = v18 + 1;
        if ((unint64_t)(v18 + 1) >> 62) {
          abort();
        }
        if ((v14 - v13) >> 1 > v19) {
          unint64_t v19 = (v14 - v13) >> 1;
        }
        if ((unint64_t)(v14 - v13) >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v20 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v20 = v19;
        }
        if (v20)
        {
          if (v20 >> 62) {
            sub_1CB833614();
          }
          long long v21 = (char *)operator new(4 * v20);
        }
        else
        {
          long long v21 = 0;
        }
        uint64_t v12 = &v21[4 * v18];
        *(_DWORD *)uint64_t v12 = v16;
        int v17 = v12 + 4;
        while (v15 != v13)
        {
          int v22 = *((_DWORD *)v15 - 1);
          v15 -= 4;
          *((_DWORD *)v12 - 1) = v22;
          v12 -= 4;
        }
        uint64_t v14 = &v21[4 * v20];
        if (v13) {
          operator delete(v13);
        }
        uint64_t v13 = v12;
      }
      else
      {
        *(_DWORD *)char v15 = v16;
        int v17 = v15 + 4;
      }
      ++v8;
      char v15 = v17;
    }
    while (v8 != v11);
  }
  memset(&v62[1], 139, 0x9BCuLL);
  uint64_t v23 = (v17 - v12) >> 2;
  unint64_t v24 = v23 + 1;
  if ((unint64_t)(v23 + 1) > 0x270) {
    unint64_t v25 = v23 + 1;
  }
  else {
    unint64_t v25 = 624;
  }
  v62[317] = v23 - 582287779;
  v62[306] = -582287779;
  v62[0] = v23 + 1371501266;
  if (v17 == v12)
  {
    uint64_t v26 = 0;
    uint64_t v31 = 623;
    uint64_t v30 = 306;
    uint64_t v29 = 317;
  }
  else
  {
    uint64_t v26 = 0;
    uint64_t v27 = 2;
    if (v24 > 2) {
      uint64_t v27 = v23 + 1;
    }
    uint64_t v28 = v27 - 1;
    uint64_t v29 = 317;
    uint64_t v30 = 306;
    uint64_t v31 = 623;
    unint64_t v32 = v12;
    do
    {
      if (v26 == 623) {
        uint64_t v26 = 0;
      }
      else {
        ++v26;
      }
      if (v31 == 623) {
        uint64_t v31 = 0;
      }
      else {
        ++v31;
      }
      if (v30 == 623) {
        uint64_t v30 = 0;
      }
      else {
        ++v30;
      }
      if (v29 == 623) {
        uint64_t v29 = 0;
      }
      else {
        ++v29;
      }
      unsigned int v33 = v62[v30];
      unsigned int v34 = 1664525 * (v62[v26] ^ v62[v31] ^ v33 ^ ((v62[v26] ^ v62[v31] ^ v33) >> 27));
      v62[v30] = v34 + v33;
      int v35 = *(_DWORD *)v32;
      v32 += 4;
      int v36 = v35 + v26 + v34;
      v62[v29] += v36;
      v62[v26] = v36;
      --v28;
    }
    while (v28);
  }
  if (v24 <= 0x26F)
  {
    unint64_t v37 = ~v23 + v25;
    do
    {
      if (v26 == 623) {
        uint64_t v26 = 0;
      }
      else {
        ++v26;
      }
      if (v31 == 623) {
        uint64_t v31 = 0;
      }
      else {
        ++v31;
      }
      if (v30 == 623) {
        uint64_t v30 = 0;
      }
      else {
        ++v30;
      }
      if (v29 == 623) {
        uint64_t v29 = 0;
      }
      else {
        ++v29;
      }
      int v38 = v62[v30];
      unsigned int v39 = v62[v26] ^ v62[v31] ^ v38;
      int v40 = 1664525 * (v39 ^ (v39 >> 27));
      v62[v30] = v40 + v38;
      int v41 = v40 + v26;
      v62[v29] += v41;
      v62[v26] = v41;
      --v37;
    }
    while (v37);
  }
  if (v25 <= 0xFFFFFFFFFFFFFD8FLL)
  {
    uint64_t v42 = 624;
    do
    {
      if (v26 == 623) {
        uint64_t v26 = 0;
      }
      else {
        ++v26;
      }
      if (v31 == 623) {
        uint64_t v31 = 0;
      }
      else {
        ++v31;
      }
      if (v30 == 623) {
        uint64_t v30 = 0;
      }
      else {
        ++v30;
      }
      if (v29 == 623) {
        uint64_t v29 = 0;
      }
      else {
        ++v29;
      }
      int v43 = v62[v30];
      unsigned int v44 = v43 + v62[v26] + v62[v31];
      int v45 = 1566083941 * (v44 ^ (v44 >> 27));
      v62[v30] = v45 ^ v43;
      int v46 = v45 - v26;
      v62[v29] ^= v46;
      v62[v26] = v46;
      --v42;
    }
    while (v42);
  }
  for (unint64_t j = 0; j != 2496; j += 32)
  {
    unint64_t v48 = (const float *)&v62[j / 4];
    float32x4x2_t v64 = vld2q_f32(v48);
    v49.i64[0] = v64.val[0].u32[2];
    v49.i64[1] = v64.val[0].u32[3];
    int8x16_t v50 = v49;
    v49.i64[0] = v64.val[0].u32[0];
    v49.i64[1] = v64.val[0].u32[1];
    __asm { SHLL2           V4.2D, V1.4S, #0x20 ; ' ' }
    size_t v56 = (int8x16_t *)&a1[j / 8];
    *size_t v56 = vorrq_s8((int8x16_t)vshll_n_s32(*(int32x2_t *)v64.val[1].f32, 0x20uLL), v49);
    v56[1] = vorrq_s8(_Q4, v50);
  }
  a1[312] = 0;
  if (!(*a1 >> 31))
  {
    uint64_t v57 = 1;
    while (!a1[v57])
    {
      if (++v57 == 312)
      {
        *a1 = 0x8000000000000000;
        break;
      }
    }
  }
  if (v12) {
    operator delete(v12);
  }
  if (__p)
  {
    long long v60 = (int *)__p;
    operator delete(__p);
  }
  return a1;
}

unint64_t llvm::RandomNumberGenerator::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 2496);
  unint64_t v2 = (v1 + 1) % 0x138uLL;
  unint64_t v3 = *(void *)(a1 + 8 * ((v1 + 156) % 0x138uLL)) ^ ((*(void *)(a1 + 8 * v2) & 0x7FFFFFFELL | *(void *)(a1 + 8 * v1) & 0xFFFFFFFF80000000) >> 1) ^ ((uint64_t)(*(void *)(a1 + 8 * v2) << 63) >> 63) & 0xB5026F5AA96619E9;
  *(void *)(a1 + 8 * v1) = v3;
  *(void *)(a1 + 2496) = v2;
  uint64_t v4 = (((v3 >> 29) & 0x5555555555555555 ^ v3) << 17) & 0x71D67FFFEDA60000 ^ (v3 >> 29) & 0x5555555555555555 ^ v3;
  return (v4 << 37) & 0xFFF7EEE000000000 ^ v4 ^ (((v4 << 37) & 0xFFF7EEE000000000 ^ v4) >> 43);
}

uint64_t llvm::getRandomBytes(llvm *this, void *a2)
{
  int v4 = open("/dev/urandom", 0);
  if (v4 == -1) {
    goto LABEL_9;
  }
  int v5 = v4;
  std::system_category();
  unint64_t v6 = (void *)read(v5, this, (size_t)a2);
  if (v6 == (void *)-1)
  {
    unsigned int v7 = *__error();
  }
  else
  {
    if (v6 == a2)
    {
      unsigned int v7 = 0;
      goto LABEL_8;
    }
    unsigned int v7 = 5;
  }
  std::system_category();
LABEL_8:
  if (close(v5) == -1)
  {
LABEL_9:
    unsigned int v7 = *__error();
    std::system_category();
  }
  return v7;
}

void sub_1CD09F6A4()
{
}

uint64_t llvm::Regex::Regex(uint64_t this)
{
  *(void *)this = 0;
  *(_DWORD *)(this + --*(_DWORD *)(this + 8) = 2;
  return this;
}

{
  *(void *)this = 0;
  *(_DWORD *)(this + --*(_DWORD *)(this + 8) = 2;
  return this;
}

void llvm::Regex::Regex()
{
}

{
  operator new();
}

{
  operator new();
}

{
  operator new();
}

uint64_t llvm::Regex::Regex(uint64_t result, uint64_t a2)
{
  *(void *)double result = *(void *)a2;
  *(_DWORD *)(result + --*(_DWORD *)(this + 8) = *(_DWORD *)(a2 + 8);
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + --*(_DWORD *)(this + 8) = 2;
  return result;
}

{
  *(void *)double result = *(void *)a2;
  *(_DWORD *)(result + --*(_DWORD *)(this + 8) = *(_DWORD *)(a2 + 8);
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + --*(_DWORD *)(this + 8) = 2;
  return result;
}

void llvm::Regex::~Regex(llvm::Regex *this)
{
  uint64_t v2 = *(void *)this;
  if (v2)
  {
    llvm_regfree(v2);
    if (*(void *)this) {
      MEMORY[0x1D25D9CE0](*(void *)this, 0x1070C404B019E81);
    }
  }
}

{
  uint64_t v2;

  uint64_t v2 = *(void *)this;
  if (v2)
  {
    llvm_regfree(v2);
    if (*(void *)this) {
      MEMORY[0x1D25D9CE0](*(void *)this, 0x1070C404B019E81);
    }
  }
}

size_t sub_1CD09F948(int a1, uint64_t a2, uint64_t a3)
{
  size_t v6 = llvm_regerror(a1, a2, 0, 0);
  std::string::resize((std::string *)a3, v6 - 1, 0);
  if (*(char *)(a3 + 23) >= 0) {
    unsigned int v7 = (unsigned char *)a3;
  }
  else {
    unsigned int v7 = *(unsigned char **)a3;
  }

  return llvm_regerror(a1, a2, v7, v6);
}

uint64_t llvm::Regex::getNumMatches(llvm::Regex *this)
{
  return *(unsigned int *)(*(void *)this + 8);
}

uint64_t llvm::Regex::match(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unsigned __int16 v23[16] = *MEMORY[0x1E4F143B8];
  if (!a5)
  {
    if (*(_DWORD *)(a1 + 8)) {
      return 0;
    }
    goto LABEL_9;
  }
  if ((*(char *)(a5 + 23) & 0x80000000) == 0)
  {
    if (!*(unsigned char *)(a5 + 23)) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  if (*(void *)(a5 + 8)) {
LABEL_4:
  }
    MEMORY[0x1D25D9630](a5, "");
LABEL_5:
  int v10 = *(_DWORD *)(a1 + 8);
  if (v10)
  {
    sub_1CD09F948(v10, *(void *)a1, a5);
    return 0;
  }
LABEL_9:
  if (a4) {
    unsigned int v12 = *(_DWORD *)(*(void *)a1 + 8) + 1;
  }
  else {
    unsigned int v12 = 0;
  }
  if (v12 <= 1) {
    uint64_t v13 = 1;
  }
  else {
    uint64_t v13 = v12;
  }
  if (v13 >= 9) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  bzero(v23, 16 * v13);
  v23[0] = 0;
  v23[1] = a3;
  int v14 = llvm_regexec(*(void *)a1, a2, v12, v23, 4);
  if (v14)
  {
    if (v14 != 1 && a5) {
      sub_1CD09F948(*(_DWORD *)(a1 + 8), *(void *)a1, a5);
    }
    return 0;
  }
  else
  {
    if (a4)
    {
      *(_DWORD *)(a4 + --*(_DWORD *)(this + 8) = 0;
      if (v12)
      {
        unint64_t v15 = 0;
        unsigned int v16 = 0;
        uint64_t v17 = 16 * v12;
        do
        {
          uint64_t v18 = v23[v15 / 8];
          if (v18 == -1)
          {
            if (v16 >= *(_DWORD *)(a4 + 12)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            long long v21 = (void *)(*(void *)a4 + 16 * v16);
            *long long v21 = 0;
            v21[1] = 0;
          }
          else
          {
            uint64_t v19 = v23[v15 / 8 + 1];
            if (v16 >= *(_DWORD *)(a4 + 12)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            unint64_t v20 = (void *)(*(void *)a4 + 16 * v16);
            *unint64_t v20 = &a2[v18];
            v20[1] = v19 - v18;
          }
          unsigned int v16 = *(_DWORD *)(a4 + 8) + 1;
          *(_DWORD *)(a4 + --*(_DWORD *)(this + 8) = v16;
          v15 += 16;
        }
        while (v17 != v15);
      }
    }
    return 1;
  }
}

void llvm::Regex::sub(uint64_t a1@<X0>, uint64_t a2@<X1>, std::string::size_type a3@<X2>, void *a4@<X3>, size_t a5@<X4>, uint64_t a6@<X5>, std::string *a7@<X8>)
{
  std::string::size_type v10 = a3;
  uint64_t v11 = (const std::string::value_type *)a2;
  v50[16] = *MEMORY[0x1E4F143B8];
  int v46 = (const std::string::value_type *)a2;
  std::string::size_type v47 = a3;
  unint64_t v48 = v50;
  uint64_t v49 = 0x800000000;
  if ((llvm::Regex::match(a1, (char *)a4, a5, (uint64_t)&v48, a6) & 1) == 0)
  {
    if (a5 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    if (a5 >= 0x17)
    {
      uint64_t v36 = (a5 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((a5 | 7) != 0x17) {
        uint64_t v36 = a5 | 7;
      }
      uint64_t v37 = v36 + 1;
      int v38 = (std::string *)operator new(v36 + 1);
      a7->__r_.__value_.__l.__size_ = a5;
      a7->__r_.__value_.__r.__words[2] = v37 | 0x8000000000000000;
      a7->__r_.__value_.__r.__words[0] = (std::string::size_type)v38;
      a7 = v38;
    }
    else
    {
      *((unsigned char *)&a7->__r_.__value_.__s + 23) = a5;
      if (!a5) {
        goto LABEL_65;
      }
    }
    memmove(a7, a4, a5);
LABEL_65:
    a7->__r_.__value_.__s.__data_[a5] = 0;
    goto LABEL_68;
  }
  sub_1CC028D80(a7, (char *)a4, *(char **)v48, *(void *)v48 - (void)a4);
  if (!v10) {
    goto LABEL_67;
  }
  LOBYTE(v42[0]) = 92;
  unint64_t v13 = llvm::StringRef::find((uint64_t *)&v46, (char *)v42, 1uLL, 0);
  if (v13 == -1) {
    goto LABEL_66;
  }
  while (1)
  {
    std::string::size_type v14 = v10 >= v13 ? v13 : v10;
    std::string::size_type v15 = v13 + 1;
    std::string::append(a7, v11, v14);
    BOOL v16 = v10 > v15;
    unint64_t v17 = v10 - v15;
    if (!v16) {
      break;
    }
    uint64_t v18 = &v11[v15];
    int v46 = &v11[v15];
    std::string::size_type v47 = v17;
    int v19 = v11[v15];
    if ((v19 - 48) >= 0xA)
    {
      if (v19 == 110)
      {
        uint64_t v29 = a7;
        std::string::value_type v30 = 10;
      }
      else if (v19 == 116)
      {
        uint64_t v29 = a7;
        std::string::value_type v30 = 9;
      }
      else
      {
        std::string::value_type v30 = v11[v15];
        uint64_t v29 = a7;
      }
      std::string::push_back(v29, v30);
      uint64_t v11 = v18 + 1;
      std::string::size_type v10 = v17 - 1;
      int v46 = v18 + 1;
      std::string::size_type v47 = v10;
      goto LABEL_50;
    }
    unint64_t first_not_of = llvm::StringRef::find_first_not_of(&v46, "0123456789", 10, 0);
    if (v17 >= first_not_of) {
      unint64_t v21 = first_not_of;
    }
    else {
      unint64_t v21 = v17;
    }
    uint64_t v11 = &v18[v21];
    std::string::size_type v10 = v17 - v21;
    int v46 = &v18[v21];
    std::string::size_type v47 = v10;
    if (!v21)
    {
      unint64_t v28 = 0;
      BOOL v31 = 0;
LABEL_32:
      BOOL v32 = 1;
      goto LABEL_36;
    }
    unint64_t v22 = 0;
    uint64_t v23 = v18;
    unint64_t v24 = v21;
    while (1)
    {
      int v25 = *(unsigned __int8 *)v23;
      if ((v25 - 48) < 0xA)
      {
        int v26 = -48;
        goto LABEL_17;
      }
      if ((v25 - 97) < 0x1A)
      {
        int v26 = -87;
        goto LABEL_17;
      }
      if ((v25 - 65) > 0x19) {
        break;
      }
      int v26 = -55;
LABEL_17:
      unsigned int v27 = v26 + v25;
      if (v27 > 9) {
        break;
      }
      unint64_t v28 = 10 * v22 + v27;
      if (v22 > v28 / 0xA)
      {
        BOOL v31 = 1;
        goto LABEL_32;
      }
      ++v23;
      unint64_t v22 = v28;
      if (!--v24) {
        goto LABEL_35;
      }
    }
    unint64_t v28 = v22;
LABEL_35:
    BOOL v32 = v21 == v24;
    BOOL v31 = v24 != 0;
LABEL_36:
    if (HIDWORD(v28)) {
      BOOL v33 = 0;
    }
    else {
      BOOL v33 = !v31;
    }
    if (v33 && !v32 && v28 < v49)
    {
      std::string::append(a7, *((const std::string::value_type **)v48 + 2 * v28), *((void *)v48 + 2 * v28 + 1));
      goto LABEL_50;
    }
    if (a6)
    {
      if (*(char *)(a6 + 23) < 0)
      {
        if (!*(void *)(a6 + 8)) {
          goto LABEL_54;
        }
      }
      else
      {
        if (*(unsigned char *)(a6 + 23)) {
          goto LABEL_50;
        }
LABEL_54:
        v40[0] = "invalid backreference string '";
        v40[2] = v18;
        void v40[3] = v21;
        __int16 v41 = 1283;
        v42[0] = v40;
        v42[2] = "'";
        __int16 v43 = 770;
        llvm::Twine::str((llvm::Twine *)v42, &v44);
        if (*(char *)(a6 + 23) < 0) {
          operator delete(*(void **)a6);
        }
        *(_OWORD *)a6 = v44;
        *(void *)(a6 + 16) = v45;
      }
    }
LABEL_50:
    if (!v10) {
      goto LABEL_67;
    }
    LOBYTE(v42[0]) = 92;
    unint64_t v13 = llvm::StringRef::find((uint64_t *)&v46, (char *)v42, 1uLL, 0);
    if (v13 == -1)
    {
LABEL_66:
      std::string::append(a7, v11, v10);
      goto LABEL_67;
    }
  }
  if (a6 && v47 != v14 && !(*(char *)(a6 + 23) < 0 ? *(void *)(a6 + 8) : *(unsigned __int8 *)(a6 + 23))) {
    MEMORY[0x1D25D9630](a6, "replacement string contained trailing backslash");
  }
LABEL_67:
  std::string::append(a7, (const std::string::value_type *)(*(void *)v48 + *((void *)v48 + 1)), (std::string::size_type)a4 + a5 - (*(void *)v48 + *((void *)v48 + 1)));
LABEL_68:
  if (v48 != v50) {
    free(v48);
  }
}

BOOL llvm::RISCVISAInfo::isSupportedExtensionFeature(void *a1, size_t a2)
{
  if (a2 > 0xC
    && (*a1 == 0x656D697265707865 ? (BOOL v4 = *(void *)((char *)a1 + 5) == 0x2D6C61746E656D69) : (BOOL v4 = 0), v4))
  {
    uint64_t v7 = 0;
    uint64_t v8 = (char *)a1 + 13;
    size_t v9 = a2 - 13;
    do
    {
      BOOL result = sub_1CD0A37EC(v8, v9, (&off_1E6855918)[v7]);
      if (result) {
        break;
      }
      BOOL v4 = v7 == 12;
      v7 += 2;
    }
    while (!v4);
  }
  else
  {
    uint64_t v5 = 0;
    do
    {
      BOOL result = sub_1CD0A37EC(a1, a2, (&off_1E6855988)[v5]);
      if (result) {
        break;
      }
      BOOL v4 = v5 == 96;
      v5 += 2;
    }
    while (!v4);
  }
  return result;
}

BOOL llvm::RISCVISAInfo::isSupportedExtension(const void *a1, size_t a2)
{
  for (uint64_t i = 0; i != 98; i += 2)
  {
    if (sub_1CD0A37EC(a1, a2, (&off_1E6855988)[i])) {
      return 1;
    }
  }
  uint64_t v5 = 0;
  do
  {
    BOOL result = sub_1CD0A37EC(a1, a2, (&off_1E6855918)[v5]);
    if (result) {
      break;
    }
    BOOL v7 = v5 == 12;
    v5 += 2;
  }
  while (!v7);
  return result;
}

uint64_t llvm::RISCVISAInfo::hasExtension(uint64_t a1, void *a2, unint64_t a3)
{
  size_t v3 = a3;
  BOOL v4 = a2;
  if (a3 >= 0xD && *a2 == 0x656D697265707865 && *(void *)((char *)a2 + 5) == 0x2D6C61746E656D69)
  {
    size_t v3 = a3 - 13;
    BOOL v4 = (char *)a2 + 13;
  }
  if (!llvm::RISCVISAInfo::isSupportedExtension(v4, v3)) {
    return 0;
  }
  if (v4)
  {
    if (v3 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    if (v3 >= 0x17)
    {
      uint64_t v10 = (v3 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v3 | 7) != 0x17) {
        uint64_t v10 = v3 | 7;
      }
      uint64_t v11 = v10 + 1;
      p_dst = (void **)operator new(v10 + 1);
      size_t v15 = v3;
      unint64_t v16 = v11 | 0x8000000000000000;
      long long __dst = p_dst;
    }
    else
    {
      HIBYTE(v16) = v3;
      p_dst = (void **)&__dst;
      if (!v3) {
        goto LABEL_22;
      }
    }
    memmove(p_dst, v4, v3);
LABEL_22:
    *((unsigned char *)p_dst + v3) = 0;
    goto LABEL_23;
  }
  long long __dst = 0;
  size_t v15 = 0;
  unint64_t v16 = 0;
LABEL_23:
  for (uint64_t i = *(char **)(a1 + 32); i; uint64_t i = *(char **)i)
  {
    if ((llvm::RISCVISAInfo::compareExtension((char *)&__dst, i + 32) & 1) == 0)
    {
      if (!llvm::RISCVISAInfo::compareExtension(i + 32, (char *)&__dst))
      {
        uint64_t v9 = 1;
        goto LABEL_30;
      }
      i += 8;
    }
  }
  uint64_t v9 = 0;
LABEL_30:
  if (SHIBYTE(v16) < 0) {
    operator delete(__dst);
  }
  return v9;
}

uint64_t sub_1CD0A0368(int __c)
{
  if (__c == 105) {
    return 4294967294;
  }
  if (__c == 101) {
    return 0xFFFFFFFFLL;
  }
  size_t v3 = memchr("mafdqlcbjtpvn", __c, 0xDuLL);
  uint64_t v4 = v3 - "mafdqlcbjtpvn";
  if (!v3) {
    uint64_t v4 = -1;
  }
  if (v4 == -1) {
    return (__c - 84);
  }
  else {
    return v4;
  }
}

uint64_t sub_1CD0A03DC(char *a1)
{
  if (a1[23] >= 0) {
    uint64_t v1 = a1;
  }
  else {
    uint64_t v1 = *(char **)a1;
  }
  int v2 = *v1;
  if (v2 > 119)
  {
    if (v2 == 120)
    {
      int v3 = 0;
      int v4 = 768;
    }
    else
    {
      int v3 = sub_1CD0A0368(v1[1]);
      int v4 = 512;
    }
  }
  else
  {
    int v3 = 0;
    if (v2 == 104) {
      int v4 = 256;
    }
    else {
      int v4 = 0;
    }
  }
  return (v4 + v3);
}

void llvm::RISCVISAInfo::parseArchString(_DWORD *a1, unint64_t a2)
{
  if (a2)
  {
    uint64_t v4 = 0;
    uint64_t v5 = MEMORY[0x1E4F14390];
    do
    {
      unsigned int v6 = *((char *)a1 + v4);
      if ((v6 & 0x80000000) != 0)
      {
        if (__maskrune(v6, 0x8000uLL))
        {
LABEL_16:
          std::generic_category();
          sub_1CD06481C();
        }
      }
      else if ((*(_DWORD *)(v5 + 4 * v6 + 60) & 0x8000) != 0)
      {
        goto LABEL_16;
      }
      ++v4;
    }
    while (a2 != v4);
    if (a2 >= 4)
    {
      BOOL v7 = *a1 == 875984498 || *a1 == 842233458;
      if (a2 != 4 && v7) {
        operator new();
      }
    }
  }
  std::generic_category();
  sub_1CD06481C();
}

uint64_t sub_1CD0A1588(void *a1, unsigned char *a2, size_t a3, unsigned __int8 *a4, std::string::size_type a5, int *a6, int *a7, _DWORD *a8, char a9, char a10)
{
  uint64_t v143 = *MEMORY[0x1E4F143B8];
  *a6 = 0;
  *a7 = 0;
  *a8 = 0;
  if (a5)
  {
    unint64_t v13 = 0;
    while (a4[v13] - 48 <= 9)
    {
      if (a5 == ++v13) {
        goto LABEL_5;
      }
    }
  }
  else
  {
LABEL_5:
    unint64_t v13 = -1;
  }
  if (a5 >= v13) {
    std::string::size_type v14 = v13;
  }
  else {
    std::string::size_type v14 = a5;
  }
  unint64_t v15 = a5 - v14;
  if (!v14)
  {
    unint64_t v28 = a6;
    uint64_t v16 = 0;
LABEL_56:
    int v38 = a7;
    unint64_t v19 = 0;
    char v37 = 1;
    int v39 = v14;
    goto LABEL_57;
  }
  if (v15 && a4[v14] == 112)
  {
    uint64_t v16 = (uint64_t)&a4[v14 + 1];
    unint64_t v17 = v15 - 1;
    if (v17)
    {
      unint64_t v18 = 0;
      while (*(unsigned __int8 *)(v16 + v18) - 48 <= 9)
      {
        if (v17 == ++v18) {
          goto LABEL_16;
        }
      }
    }
    else
    {
LABEL_16:
      unint64_t v18 = -1;
    }
    if (v17 >= v18) {
      unint64_t v19 = v18;
    }
    else {
      unint64_t v19 = v17;
    }
    if (!v19)
    {
      uint64_t v29 = std::generic_category();
      __int16 v140 = 1283;
      std::string::value_type v30 = "minor version number missing after 'p' for extension '";
      goto LABEL_85;
    }
    BOOL v20 = v17 >= v14 + 1;
    unint64_t v15 = v17 - (v14 + 1);
    if (!v20) {
      unint64_t v15 = 0;
    }
  }
  else
  {
    unint64_t v19 = 0;
    uint64_t v16 = 0;
  }
  unint64_t v21 = 0;
  unint64_t v22 = a4;
  std::string::size_type v23 = v14;
  while (1)
  {
    int v24 = *v22;
    if ((v24 - 48) < 0xA)
    {
      int v25 = -48;
      goto LABEL_28;
    }
    if ((v24 - 97) < 0x1A)
    {
      int v25 = -87;
      goto LABEL_28;
    }
    if ((v24 - 65) > 0x19) {
      break;
    }
    int v25 = -55;
LABEL_28:
    unsigned int v26 = v25 + v24;
    if (v26 > 9) {
      break;
    }
    unint64_t v27 = 10 * v21 + v26;
    if (v21 > v27 / 0xA) {
      goto LABEL_79;
    }
    ++v22;
    unint64_t v21 = v27;
    if (!--v23) {
      goto LABEL_39;
    }
  }
  unint64_t v27 = v21;
LABEL_39:
  if (HIDWORD(v27) || v23)
  {
LABEL_79:
    uint64_t v29 = std::generic_category();
    __int16 v140 = 1283;
    std::string::value_type v30 = "Failed to parse major version number for extension '";
    goto LABEL_85;
  }
  *a6 = v27;
  if (!v19)
  {
    unint64_t v28 = a6;
    goto LABEL_56;
  }
  uint64_t v31 = 0;
  unint64_t v32 = 0;
  do
  {
    int v33 = *(unsigned __int8 *)(v16 + v31);
    if ((v33 - 48) >= 0xA)
    {
      if ((v33 - 97) >= 0x1A)
      {
        if ((v33 - 65) > 0x19) {
          goto LABEL_84;
        }
        int v34 = -55;
      }
      else
      {
        int v34 = -87;
      }
    }
    else
    {
      int v34 = -48;
    }
    unsigned int v35 = v34 + v33;
    if (v35 > 9) {
      goto LABEL_84;
    }
    unint64_t v36 = 10 * v32 + v35;
    if (v32 > v36 / 0xA) {
      goto LABEL_84;
    }
    ++v31;
    unint64_t v32 = v36;
  }
  while (v19 != v31);
  if (HIDWORD(v36))
  {
LABEL_84:
    uint64_t v29 = std::generic_category();
    __int16 v140 = 1283;
    std::string::value_type v30 = "Failed to parse minor version number for extension '";
LABEL_85:
    v138.__r_.__value_.__r.__words[0] = (std::string::size_type)v30;
    v138.__r_.__value_.__r.__words[2] = (std::string::size_type)a2;
    size_t v139 = a3;
    v141.__r_.__value_.__r.__words[0] = (std::string::size_type)&v138;
    v141.__r_.__value_.__r.__words[2] = (std::string::size_type)"'";
    __int16 v142 = 770;
    sub_1CD4FF4BC(22, (uint64_t)v29, (llvm::Twine *)&v141);
  }
  unint64_t v28 = a6;
  char v37 = 0;
  int v38 = a7;
  *a7 = v36;
  int v39 = v14 + v19 + 1;
LABEL_57:
  *a8 = v39;
  if (a3 >= 2 && v15)
  {
    v138.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x40uLL);
    *(_OWORD *)&v138.__r_.__value_.__r.__words[1] = xmmword_1CFB2EEE0;
    strcpy(v138.__r_.__value_.__l.__data_, "multi-character extensions must be separated by underscores");
    goto LABEL_118;
  }
  char v125 = v37;
  std::string::size_type __len = v19;
  long long __src = (void *)v16;
  for (uint64_t i = 0; i != 14; i += 2)
  {
    uint64_t result = sub_1CD0A37EC(a2, a3, (&off_1E6855918)[i]);
    if (result)
    {
      if (a9)
      {
        std::string::size_type v43 = (std::string::size_type)(&off_1E6855918)[i + 1];
        std::string::size_type v44 = __len;
        if (__len | v14 || !a10)
        {
          if (!a10) {
            goto LABEL_77;
          }
          unint64_t v45 = HIDWORD(v43);
          if (*v28 == v43 && *v38 == HIDWORD(v43)) {
            goto LABEL_77;
          }
          if (!a4)
          {
            memset(&v141, 0, sizeof(v141));
            goto LABEL_128;
          }
          if (v14 > 0x7FFFFFFFFFFFFFF7) {
            goto LABEL_254;
          }
          if (v14 >= 0x17)
          {
            uint64_t v64 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v14 | 7) != 0x17) {
              uint64_t v64 = v14 | 7;
            }
            uint64_t v65 = v64 + 1;
            uint64_t v63 = operator new(v64 + 1);
            v141.__r_.__value_.__l.__size_ = v14;
            v141.__r_.__value_.__r.__words[2] = v65 | 0x8000000000000000;
            v141.__r_.__value_.__r.__words[0] = (std::string::size_type)v63;
          }
          else
          {
            *((unsigned char *)&v141.__r_.__value_.__s + 23) = v14;
            uint64_t v63 = &v141;
            if (!v14) {
              goto LABEL_127;
            }
          }
          memmove(v63, a4, v14);
LABEL_127:
          *((unsigned char *)v63 + v14) = 0;
          std::string::size_type v44 = __len;
LABEL_128:
          uint64_t v66 = std::string::insert(&v141, 0, "unsupported version number ");
          std::string::size_type v67 = v66->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v138.__r_.__value_.__l.__data_ = *(_OWORD *)&v66->__r_.__value_.__l.__data_;
          v138.__r_.__value_.__r.__words[2] = v67;
          v66->__r_.__value_.__l.__size_ = 0;
          v66->__r_.__value_.__r.__words[2] = 0;
          v66->__r_.__value_.__r.__words[0] = 0;
          if (SHIBYTE(v141.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v141.__r_.__value_.__l.__data_);
          }
          if ((v125 & 1) == 0)
          {
            long long v68 = __src;
            if (__src)
            {
              if (v44 > 0x7FFFFFFFFFFFFFF7) {
                goto LABEL_254;
              }
              if (v44 >= 0x17)
              {
                uint64_t v70 = (v44 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v44 | 7) != 0x17) {
                  uint64_t v70 = v44 | 7;
                }
                uint64_t v71 = v70 + 1;
                uint64_t v72 = (std::string *)operator new(v70 + 1);
                long long v68 = __src;
                p_dst = v72;
                __dst.__r_.__value_.__l.__size_ = v44;
                __dst.__r_.__value_.__r.__words[2] = v71 | 0x8000000000000000;
                __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v72;
              }
              else
              {
                *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v44;
                p_dst = &__dst;
              }
              memmove(p_dst, v68, v44);
              p_dst->__r_.__value_.__s.__data_[v44] = 0;
            }
            else
            {
              memset(&__dst, 0, sizeof(__dst));
            }
            uint64_t v73 = std::string::insert(&__dst, 0, ".");
            std::string::size_type v74 = v73->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v141.__r_.__value_.__l.__data_ = *(_OWORD *)&v73->__r_.__value_.__l.__data_;
            v141.__r_.__value_.__r.__words[2] = v74;
            v73->__r_.__value_.__l.__size_ = 0;
            v73->__r_.__value_.__r.__words[2] = 0;
            v73->__r_.__value_.__r.__words[0] = 0;
            if ((v141.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              long long v75 = &v141;
            }
            else {
              long long v75 = (std::string *)v141.__r_.__value_.__r.__words[0];
            }
            if ((v141.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              std::string::size_type size = *((unsigned char *)&v141.__r_.__value_.__s + 23) & 0x7F;
            }
            else {
              std::string::size_type size = v141.__r_.__value_.__l.__size_;
            }
            std::string::append(&v138, (const std::string::value_type *)v75, size);
            if (SHIBYTE(v141.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v141.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__dst.__r_.__value_.__l.__data_);
            }
          }
          if (!a2)
          {
            memset(&v132, 0, sizeof(v132));
LABEL_161:
            char v80 = std::string::insert(&v132, 0, " for experimental extension '");
            std::string::size_type v81 = v80->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v133.__r_.__value_.__l.__data_ = *(_OWORD *)&v80->__r_.__value_.__l.__data_;
            v133.__r_.__value_.__r.__words[2] = v81;
            v80->__r_.__value_.__l.__size_ = 0;
            v80->__r_.__value_.__r.__words[2] = 0;
            v80->__r_.__value_.__r.__words[0] = 0;
            uint64_t v82 = std::string::append(&v133, "'(this compiler supports ");
            std::string::size_type v83 = v82->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v134.__r_.__value_.__l.__data_ = *(_OWORD *)&v82->__r_.__value_.__l.__data_;
            v134.__r_.__value_.__r.__words[2] = v83;
            v82->__r_.__value_.__l.__size_ = 0;
            v82->__r_.__value_.__r.__words[2] = 0;
            v82->__r_.__value_.__r.__words[0] = 0;
            unint64_t v84 = v43;
            if (v43)
            {
              size_t v85 = &v141.__r_.__value_.__s.__data_[21];
              do
              {
                *--size_t v85 = (v84 % 0xA) | 0x30;
                BOOL v86 = v84 > 9;
                v84 /= 0xAuLL;
              }
              while (v86);
            }
            else
            {
              size_t v85 = &v141.__r_.__value_.__s.__data_[20];
              v141.__r_.__value_.__s.__data_[20] = 48;
            }
            sub_1CC028D80(v130, v85, &v141.__r_.__value_.__s.__data_[21], (char *)&v141.__r_.__value_.__r.__words[2] + 5 - v85);
            if (v131 >= 0) {
              size_t v87 = v130;
            }
            else {
              size_t v87 = (void **)v130[0];
            }
            if (v131 >= 0) {
              std::string::size_type v88 = v131 & 0x7F;
            }
            else {
              std::string::size_type v88 = (std::string::size_type)v130[1];
            }
            size_t v89 = std::string::append(&v134, (const std::string::value_type *)v87, v88);
            std::string::size_type v90 = v89->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v135.__r_.__value_.__l.__data_ = *(_OWORD *)&v89->__r_.__value_.__l.__data_;
            v135.__r_.__value_.__r.__words[2] = v90;
            v89->__r_.__value_.__l.__size_ = 0;
            v89->__r_.__value_.__r.__words[2] = 0;
            v89->__r_.__value_.__r.__words[0] = 0;
            BOOL v91 = std::string::append(&v135, ".");
            std::string::size_type v92 = v91->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v136.__r_.__value_.__l.__data_ = *(_OWORD *)&v91->__r_.__value_.__l.__data_;
            v136.__r_.__value_.__r.__words[2] = v92;
            v91->__r_.__value_.__l.__size_ = 0;
            v91->__r_.__value_.__r.__words[2] = 0;
            v91->__r_.__value_.__r.__words[0] = 0;
            if (v45)
            {
              uint64_t v93 = &v141.__r_.__value_.__s.__data_[21];
              do
              {
                *--uint64_t v93 = (v45 % 0xA) | 0x30;
                BOOL v86 = v45 > 9;
                v45 /= 0xAuLL;
              }
              while (v86);
            }
            else
            {
              uint64_t v93 = &v141.__r_.__value_.__s.__data_[20];
              v141.__r_.__value_.__s.__data_[20] = 48;
            }
            sub_1CC028D80(__p, v93, &v141.__r_.__value_.__s.__data_[21], (char *)&v141.__r_.__value_.__r.__words[2] + 5 - v93);
            if (v129 >= 0) {
              uint64_t v94 = __p;
            }
            else {
              uint64_t v94 = (void **)__p[0];
            }
            if (v129 >= 0) {
              std::string::size_type v95 = v129 & 0x7F;
            }
            else {
              std::string::size_type v95 = (std::string::size_type)__p[1];
            }
            long long v96 = std::string::append(&v136, (const std::string::value_type *)v94, v95);
            std::string::size_type v97 = v96->__r_.__value_.__r.__words[2];
            *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = *(_OWORD *)&v96->__r_.__value_.__l.__data_;
            __dst.__r_.__value_.__r.__words[2] = v97;
            v96->__r_.__value_.__l.__size_ = 0;
            v96->__r_.__value_.__r.__words[2] = 0;
            v96->__r_.__value_.__r.__words[0] = 0;
            unint64_t v98 = std::string::append(&__dst, ")");
            std::string::size_type v99 = v98->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v141.__r_.__value_.__l.__data_ = *(_OWORD *)&v98->__r_.__value_.__l.__data_;
            v141.__r_.__value_.__r.__words[2] = v99;
            v98->__r_.__value_.__l.__size_ = 0;
            v98->__r_.__value_.__r.__words[2] = 0;
            v98->__r_.__value_.__r.__words[0] = 0;
            if ((v141.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              unint64_t v100 = &v141;
            }
            else {
              unint64_t v100 = (std::string *)v141.__r_.__value_.__r.__words[0];
            }
            if ((v141.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              std::string::size_type v101 = *((unsigned char *)&v141.__r_.__value_.__s + 23) & 0x7F;
            }
            else {
              std::string::size_type v101 = v141.__r_.__value_.__l.__size_;
            }
            std::string::append(&v138, (const std::string::value_type *)v100, v101);
            if (SHIBYTE(v141.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v141.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__dst.__r_.__value_.__l.__data_);
            }
            if (v129 < 0) {
              operator delete(__p[0]);
            }
            if (SHIBYTE(v136.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v136.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v135.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v135.__r_.__value_.__l.__data_);
            }
            if (v131 < 0) {
              operator delete(v130[0]);
            }
            if (SHIBYTE(v134.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v134.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v133.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v133.__r_.__value_.__l.__data_);
            }
            if ((SHIBYTE(v132.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_118;
            }
            uint64_t v61 = (void *)v132.__r_.__value_.__r.__words[0];
            goto LABEL_117;
          }
          if (a3 > 0x7FFFFFFFFFFFFFF7) {
            goto LABEL_254;
          }
          int v77 = v43;
          if (a3 >= 0x17)
          {
            uint64_t v78 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((a3 | 7) != 0x17) {
              uint64_t v78 = a3 | 7;
            }
            uint64_t v79 = v78 + 1;
            std::string::size_type v43 = (std::string::size_type)operator new(v78 + 1);
            v132.__r_.__value_.__l.__size_ = a3;
            v132.__r_.__value_.__r.__words[2] = v79 | 0x8000000000000000;
            v132.__r_.__value_.__r.__words[0] = v43;
          }
          else
          {
            *((unsigned char *)&v132.__r_.__value_.__s + 23) = a3;
            std::string::size_type v43 = (std::string::size_type)&v132;
            if (!a3) {
              goto LABEL_160;
            }
          }
          memmove((void *)v43, a2, a3);
LABEL_160:
          *(unsigned char *)(v43 + a3) = 0;
          LODWORD(v43) = v77;
          goto LABEL_161;
        }
        if (!a2)
        {
          memset(&__dst, 0, sizeof(__dst));
LABEL_112:
          std::string::size_type v58 = v57->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v141.__r_.__value_.__l.__data_ = *(_OWORD *)&v57->__r_.__value_.__l.__data_;
          v141.__r_.__value_.__r.__words[2] = v58;
          v57->__r_.__value_.__l.__size_ = 0;
          v57->__r_.__value_.__r.__words[2] = 0;
          v57->__r_.__value_.__r.__words[0] = 0;
          goto LABEL_113;
        }
        if (a3 > 0x7FFFFFFFFFFFFFF7) {
          goto LABEL_254;
        }
        if (a3 >= 0x17)
        {
          uint64_t v55 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((a3 | 7) != 0x17) {
            uint64_t v55 = a3 | 7;
          }
          uint64_t v56 = v55 + 1;
          uint64_t v49 = (std::string *)operator new(v55 + 1);
          __dst.__r_.__value_.__l.__size_ = a3;
          __dst.__r_.__value_.__r.__words[2] = v56 | 0x8000000000000000;
          __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v49;
        }
        else
        {
          *((unsigned char *)&__dst.__r_.__value_.__s + 23) = a3;
          uint64_t v49 = &__dst;
          if (!a3) {
            goto LABEL_111;
          }
        }
        memmove(v49, a2, a3);
LABEL_111:
        v49->__r_.__value_.__s.__data_[a3] = 0;
        goto LABEL_112;
      }
      if (!a2)
      {
        memset(&__dst, 0, sizeof(__dst));
LABEL_106:
        size_t v52 = std::string::insert(&__dst, 0, "requires '-menable-experimental-extensions' for experimental extension '");
        std::string::size_type v53 = v52->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v141.__r_.__value_.__l.__data_ = *(_OWORD *)&v52->__r_.__value_.__l.__data_;
        v141.__r_.__value_.__r.__words[2] = v53;
        v52->__r_.__value_.__l.__size_ = 0;
        v52->__r_.__value_.__r.__words[2] = 0;
        v52->__r_.__value_.__r.__words[0] = 0;
        size_t v54 = "'";
LABEL_113:
        unint64_t v59 = std::string::append(&v141, v54);
        std::string::size_type v60 = v59->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v138.__r_.__value_.__l.__data_ = *(_OWORD *)&v59->__r_.__value_.__l.__data_;
        v138.__r_.__value_.__r.__words[2] = v60;
        v59->__r_.__value_.__l.__size_ = 0;
        v59->__r_.__value_.__r.__words[2] = 0;
        v59->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v141.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v141.__r_.__value_.__l.__data_);
        }
        if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_118;
        }
        uint64_t v61 = (void *)__dst.__r_.__value_.__r.__words[0];
LABEL_117:
        operator delete(v61);
        goto LABEL_118;
      }
      if (a3 > 0x7FFFFFFFFFFFFFF7) {
        goto LABEL_254;
      }
      if (a3 >= 0x17)
      {
        uint64_t v50 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((a3 | 7) != 0x17) {
          uint64_t v50 = a3 | 7;
        }
        uint64_t v51 = v50 + 1;
        unint64_t v48 = (std::string *)operator new(v50 + 1);
        __dst.__r_.__value_.__l.__size_ = a3;
        __dst.__r_.__value_.__r.__words[2] = v51 | 0x8000000000000000;
        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v48;
      }
      else
      {
        *((unsigned char *)&__dst.__r_.__value_.__s + 23) = a3;
        unint64_t v48 = &__dst;
        if (!a3) {
          goto LABEL_105;
        }
      }
      memmove(v48, a2, a3);
LABEL_105:
      v48->__r_.__value_.__s.__data_[a3] = 0;
      goto LABEL_106;
    }
  }
  if (a3 == 1 && *a2 == 103)
  {
LABEL_77:
    *a1 = 0;
    return result;
  }
  if (__len | v14)
  {
    uint64_t result = llvm::RISCVISAInfo::isSupportedExtension((uint64_t)a2, a3, *v28, *v38);
    if (result) {
      goto LABEL_67;
    }
    if (v14 > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_254;
    }
    if (v14 >= 0x17)
    {
      uint64_t v102 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v14 | 7) != 0x17) {
        uint64_t v102 = v14 | 7;
      }
      uint64_t v103 = v102 + 1;
      std::string::size_type v47 = operator new(v102 + 1);
      v141.__r_.__value_.__l.__size_ = v14;
      v141.__r_.__value_.__r.__words[2] = v103 | 0x8000000000000000;
      v141.__r_.__value_.__r.__words[0] = (std::string::size_type)v47;
    }
    else
    {
      *((unsigned char *)&v141.__r_.__value_.__s + 23) = v14;
      std::string::size_type v47 = &v141;
      if (!v14) {
        goto LABEL_209;
      }
    }
    memmove(v47, a4, v14);
LABEL_209:
    *((unsigned char *)v47 + v14) = 0;
    uint64_t v104 = std::string::insert(&v141, 0, "unsupported version number ");
    std::string::size_type v105 = v104->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v138.__r_.__value_.__l.__data_ = *(_OWORD *)&v104->__r_.__value_.__l.__data_;
    v138.__r_.__value_.__r.__words[2] = v105;
    v104->__r_.__value_.__l.__size_ = 0;
    v104->__r_.__value_.__r.__words[2] = 0;
    v104->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v141.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v141.__r_.__value_.__l.__data_);
    }
    if ((v125 & 1) == 0)
    {
      size_t v106 = __src;
      if (__src)
      {
        if (__len > 0x7FFFFFFFFFFFFFF7) {
          goto LABEL_254;
        }
        if (__len >= 0x17)
        {
          uint64_t v108 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((__len | 7) != 0x17) {
            uint64_t v108 = __len | 7;
          }
          uint64_t v109 = v108 + 1;
          int v110 = (std::string *)operator new(v108 + 1);
          size_t v106 = __src;
          size_t v107 = v110;
          __dst.__r_.__value_.__l.__size_ = __len;
          __dst.__r_.__value_.__r.__words[2] = v109 | 0x8000000000000000;
          __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v110;
        }
        else
        {
          *((unsigned char *)&__dst.__r_.__value_.__s + 23) = __len;
          size_t v107 = &__dst;
        }
        memmove(v107, v106, __len);
        v107->__r_.__value_.__s.__data_[__len] = 0;
      }
      else
      {
        memset(&__dst, 0, sizeof(__dst));
      }
      BOOL v111 = std::string::insert(&__dst, 0, ".");
      std::string::size_type v112 = v111->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v141.__r_.__value_.__l.__data_ = *(_OWORD *)&v111->__r_.__value_.__l.__data_;
      v141.__r_.__value_.__r.__words[2] = v112;
      v111->__r_.__value_.__l.__size_ = 0;
      v111->__r_.__value_.__r.__words[2] = 0;
      v111->__r_.__value_.__r.__words[0] = 0;
      if ((v141.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v113 = &v141;
      }
      else {
        uint64_t v113 = (std::string *)v141.__r_.__value_.__r.__words[0];
      }
      if ((v141.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v114 = *((unsigned char *)&v141.__r_.__value_.__s + 23) & 0x7F;
      }
      else {
        std::string::size_type v114 = v141.__r_.__value_.__l.__size_;
      }
      std::string::append(&v138, (const std::string::value_type *)v113, v114);
      if (SHIBYTE(v141.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v141.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
    }
    if (!a2)
    {
      memset(&v136, 0, sizeof(v136));
      goto LABEL_242;
    }
    if (a3 <= 0x7FFFFFFFFFFFFFF7)
    {
      if (a3 >= 0x17)
      {
        uint64_t v116 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((a3 | 7) != 0x17) {
          uint64_t v116 = a3 | 7;
        }
        uint64_t v117 = v116 + 1;
        uint64_t v115 = operator new(v116 + 1);
        v136.__r_.__value_.__l.__size_ = a3;
        v136.__r_.__value_.__r.__words[2] = v117 | 0x8000000000000000;
        v136.__r_.__value_.__r.__words[0] = (std::string::size_type)v115;
      }
      else
      {
        *((unsigned char *)&v136.__r_.__value_.__s + 23) = a3;
        uint64_t v115 = &v136;
        if (!a3) {
          goto LABEL_241;
        }
      }
      memmove(v115, a2, a3);
LABEL_241:
      *((unsigned char *)v115 + a3) = 0;
LABEL_242:
      uint64_t v118 = std::string::insert(&v136, 0, " for extension '");
      std::string::size_type v119 = v118->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = *(_OWORD *)&v118->__r_.__value_.__l.__data_;
      __dst.__r_.__value_.__r.__words[2] = v119;
      v118->__r_.__value_.__l.__size_ = 0;
      v118->__r_.__value_.__r.__words[2] = 0;
      v118->__r_.__value_.__r.__words[0] = 0;
      uint64_t v120 = std::string::append(&__dst, "'");
      std::string::size_type v121 = v120->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v141.__r_.__value_.__l.__data_ = *(_OWORD *)&v120->__r_.__value_.__l.__data_;
      v141.__r_.__value_.__r.__words[2] = v121;
      v120->__r_.__value_.__l.__size_ = 0;
      v120->__r_.__value_.__r.__words[2] = 0;
      v120->__r_.__value_.__r.__words[0] = 0;
      if ((v141.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v122 = &v141;
      }
      else {
        uint64_t v122 = (std::string *)v141.__r_.__value_.__r.__words[0];
      }
      if ((v141.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v123 = *((unsigned char *)&v141.__r_.__value_.__s + 23) & 0x7F;
      }
      else {
        std::string::size_type v123 = v141.__r_.__value_.__l.__size_;
      }
      std::string::append(&v138, (const std::string::value_type *)v122, v123);
      if (SHIBYTE(v141.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v141.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v136.__r_.__value_.__r.__words[2]) < 0)
      {
        uint64_t v61 = (void *)v136.__r_.__value_.__r.__words[0];
        goto LABEL_117;
      }
LABEL_118:
      BOOL v62 = std::generic_category();
      __int16 v142 = 260;
      v141.__r_.__value_.__r.__words[0] = (std::string::size_type)&v138;
      sub_1CD4FF4BC(22, (uint64_t)v62, (llvm::Twine *)&v141);
    }
LABEL_254:
    abort();
  }
  uint64_t result = sub_1CD0A2384(a2, a3);
  if (v42)
  {
    *unint64_t v28 = result;
    int *v38 = HIDWORD(result);
  }
LABEL_67:
  *a1 = 0;
  return result;
}

uint64_t sub_1CD0A2384(const void *a1, size_t a2)
{
  char v4 = 0;
  uint64_t v5 = 0;
  void v12[4] = *MEMORY[0x1E4F143B8];
  v12[0] = &off_1E6855988;
  v12[1] = 49;
  v12[2] = &off_1E6855918;
  v12[3] = 7;
  while (1)
  {
    char v6 = v4;
    BOOL v7 = &v12[2 * v5];
    uint64_t v8 = v7[1];
    if (v8) {
      break;
    }
LABEL_6:
    char v4 = 1;
    uint64_t v5 = 1;
    if (v6) {
      return 0;
    }
  }
  uint64_t v9 = *v7 + 8;
  uint64_t v10 = 16 * v8;
  while (!sub_1CD0A37EC(a1, a2, *(char **)(v9 - 8)))
  {
    v9 += 16;
    v10 -= 16;
    if (!v10) {
      goto LABEL_6;
    }
  }
  return *(void *)v9;
}

const char *sub_1CD0A2474(_WORD *a1, unint64_t a2)
{
  if (a2 >= 2)
  {
    if (*a1 == 30835) {
      return "sx";
    }
  }
  else if (!a2)
  {
    return 0;
  }
  int v3 = *(unsigned __int8 *)a1;
  char v4 = "x";
  uint64_t v5 = "z";
  if (v3 != 122) {
    uint64_t v5 = 0;
  }
  if (v3 != 120) {
    char v4 = v5;
  }
  if (v3 == 115) {
    return "s";
  }
  else {
    return v4;
  }
}

const char *sub_1CD0A24F4(_WORD *a1, unint64_t a2)
{
  if (a2 >= 2)
  {
    if (*a1 == 30835) {
      return "non-standard supervisor-level extension";
    }
  }
  else if (!a2)
  {
    return 0;
  }
  int v3 = *(unsigned __int8 *)a1;
  char v4 = "non-standard user-level extension";
  uint64_t v5 = "standard user-level extension";
  if (v3 != 122) {
    uint64_t v5 = 0;
  }
  if (v3 != 120) {
    char v4 = v5;
  }
  if (v3 == 115) {
    return "standard supervisor-level extension";
  }
  else {
    return v4;
  }
}

void llvm::RISCVISAInfo::checkDependency(llvm::RISCVISAInfo *this@<X0>, void *a2@<X8>)
{
  int v36 = *(_DWORD *)this;
  int v3 = 1;
  char v48 = 1;
  LOWORD(v46) = 101;
  char v4 = (char *)*((void *)this + 4);
  if (!v4)
  {
    char v5 = 1;
    goto LABEL_10;
  }
  while ((llvm::RISCVISAInfo::compareExtension((char *)&v46, v4 + 32) & 1) != 0)
  {
LABEL_3:
    char v4 = *(char **)v4;
    if (!v4)
    {
      char v5 = 1;
      goto LABEL_7;
    }
  }
  if (llvm::RISCVISAInfo::compareExtension(v4 + 32, (char *)&v46))
  {
    v4 += 8;
    goto LABEL_3;
  }
  char v5 = 0;
LABEL_7:
  if (v48 < 0) {
    operator delete((void *)v46);
  }
LABEL_10:
  char v48 = 1;
  LOWORD(v46) = 100;
  char v6 = (char *)*((void *)this + 4);
  if (!v6) {
    goto LABEL_18;
  }
  while (2)
  {
    if (llvm::RISCVISAInfo::compareExtension((char *)&v46, v6 + 32))
    {
LABEL_12:
      char v6 = *(char **)v6;
      if (!v6)
      {
        int v3 = 1;
        goto LABEL_16;
      }
      continue;
    }
    break;
  }
  if (llvm::RISCVISAInfo::compareExtension(v6 + 32, (char *)&v46))
  {
    v6 += 8;
    goto LABEL_12;
  }
  int v3 = 0;
LABEL_16:
  if (v48 < 0) {
    operator delete((void *)v46);
  }
LABEL_18:
  char v48 = 1;
  LOWORD(v46) = 102;
  BOOL v7 = (char *)*((void *)this + 4);
  if (!v7)
  {
    int v8 = 0;
    goto LABEL_27;
  }
  while (2)
  {
    if (llvm::RISCVISAInfo::compareExtension((char *)&v46, v7 + 32))
    {
LABEL_20:
      BOOL v7 = *(char **)v7;
      if (!v7)
      {
        int v8 = 0;
        goto LABEL_24;
      }
      continue;
    }
    break;
  }
  if (llvm::RISCVISAInfo::compareExtension(v7 + 32, (char *)&v46))
  {
    v7 += 8;
    goto LABEL_20;
  }
  int v8 = 1;
LABEL_24:
  if (v48 < 0) {
    operator delete((void *)v46);
  }
LABEL_27:
  char v48 = 5;
  strcpy((char *)&v46, "zfinx");
  uint64_t v9 = (char *)*((void *)this + 4);
  if (!v9) {
    goto LABEL_39;
  }
  while (2)
  {
    if (llvm::RISCVISAInfo::compareExtension((char *)&v46, v9 + 32))
    {
LABEL_29:
      uint64_t v9 = *(char **)v9;
      if (!v9) {
        goto LABEL_37;
      }
      continue;
    }
    break;
  }
  if (llvm::RISCVISAInfo::compareExtension(v9 + 32, (char *)&v46))
  {
    v9 += 8;
    goto LABEL_29;
  }
  LODWORD(v9) = 1;
LABEL_37:
  if (v48 < 0) {
    operator delete((void *)v46);
  }
LABEL_39:
  char v48 = 5;
  strcpy((char *)&v46, "zdinx");
  uint64_t v10 = (char *)*((void *)this + 4);
  if (!v10)
  {
    int v11 = 0;
    goto LABEL_48;
  }
  while (2)
  {
    if (llvm::RISCVISAInfo::compareExtension((char *)&v46, v10 + 32))
    {
LABEL_41:
      uint64_t v10 = *(char **)v10;
      if (!v10)
      {
        int v11 = 0;
        goto LABEL_45;
      }
      continue;
    }
    break;
  }
  if (llvm::RISCVISAInfo::compareExtension(v10 + 32, (char *)&v46))
  {
    v10 += 8;
    goto LABEL_41;
  }
  int v11 = 1;
LABEL_45:
  if (v48 < 0) {
    operator delete((void *)v46);
  }
LABEL_48:
  char v48 = 6;
  strcpy((char *)&v46, "zve32x");
  unsigned int v12 = (char *)*((void *)this + 4);
  if (!v12) {
    goto LABEL_58;
  }
  while (2)
  {
    if (llvm::RISCVISAInfo::compareExtension((char *)&v46, v12 + 32))
    {
LABEL_50:
      unsigned int v12 = *(char **)v12;
      if (!v12) {
        goto LABEL_56;
      }
      continue;
    }
    break;
  }
  if (llvm::RISCVISAInfo::compareExtension(v12 + 32, (char *)&v46))
  {
    v12 += 8;
    goto LABEL_50;
  }
  LOBYTE(v12) = 1;
LABEL_56:
  if (v48 < 0) {
    operator delete((void *)v46);
  }
LABEL_58:
  char v48 = 6;
  strcpy((char *)&v46, "zve32f");
  unint64_t v13 = (char *)*((void *)this + 4);
  if (!v13)
  {
    int v14 = 1;
    goto LABEL_67;
  }
  while (2)
  {
    if (llvm::RISCVISAInfo::compareExtension((char *)&v46, v13 + 32))
    {
LABEL_60:
      unint64_t v13 = *(char **)v13;
      if (!v13)
      {
        int v14 = 1;
        goto LABEL_64;
      }
      continue;
    }
    break;
  }
  if (llvm::RISCVISAInfo::compareExtension(v13 + 32, (char *)&v46))
  {
    v13 += 8;
    goto LABEL_60;
  }
  int v14 = 0;
LABEL_64:
  if (v48 < 0) {
    operator delete((void *)v46);
  }
LABEL_67:
  char v48 = 6;
  strcpy((char *)&v46, "zve64d");
  unint64_t v15 = (char *)*((void *)this + 4);
  if (!v15)
  {
    int v16 = 1;
    goto LABEL_76;
  }
  while (2)
  {
    if (llvm::RISCVISAInfo::compareExtension((char *)&v46, v15 + 32))
    {
LABEL_69:
      unint64_t v15 = *(char **)v15;
      if (!v15)
      {
        int v16 = 1;
        goto LABEL_73;
      }
      continue;
    }
    break;
  }
  if (llvm::RISCVISAInfo::compareExtension(v15 + 32, (char *)&v46))
  {
    v15 += 8;
    goto LABEL_69;
  }
  int v16 = 0;
LABEL_73:
  if (v48 < 0) {
    operator delete((void *)v46);
  }
LABEL_76:
  if (v36 == 32) {
    char v17 = 1;
  }
  else {
    char v17 = v5;
  }
  if ((v17 & 1) == 0)
  {
    unint64_t v21 = std::generic_category();
    uint64_t v46 = 22;
    std::string::size_type v47 = v21;
    unint64_t v22 = "standard user-level extension 'e' requires 'rv32'";
LABEL_93:
    v44[0] = (void *)v22;
    goto LABEL_94;
  }
  if (((v3 | v8) & 1) == 0)
  {
    std::string::size_type v23 = std::generic_category();
    uint64_t v46 = 22;
    std::string::size_type v47 = v23;
    unint64_t v22 = "d requires f extension to also be specified";
    goto LABEL_93;
  }
  if (((v8 | v9 | v14) & 1) == 0)
  {
    int v24 = std::generic_category();
    uint64_t v46 = 22;
    std::string::size_type v47 = v24;
    unint64_t v22 = "zve32f requires f or zfinx extension to also be specified";
    goto LABEL_93;
  }
  if (((v11 | v16 | v3 ^ 1) & 1) == 0)
  {
    int v25 = std::generic_category();
    uint64_t v46 = 22;
    std::string::size_type v47 = v25;
    unint64_t v22 = "zve64d requires d or zdinx extension to also be specified";
    goto LABEL_93;
  }
  char v18 = (char)v12;
  int v19 = *((_DWORD *)this + 2);
  char v48 = 4;
  strcpy((char *)&v46, "zvfh");
  BOOL v20 = (char *)*((void *)this + 4);
  if (!v20)
  {
LABEL_95:
    int v26 = 0;
    unint64_t v27 = a2;
    goto LABEL_96;
  }
  while (2)
  {
    if (llvm::RISCVISAInfo::compareExtension((char *)&v46, v20 + 32))
    {
LABEL_85:
      BOOL v20 = *(char **)v20;
      if (!v20) {
        goto LABEL_95;
      }
      continue;
    }
    break;
  }
  if (llvm::RISCVISAInfo::compareExtension(v20 + 32, (char *)&v46))
  {
    v20 += 8;
    goto LABEL_85;
  }
  char v45 = 3;
  LODWORD(v44[0]) = 6841978;
  unint64_t v32 = (char *)*((void *)this + 4);
  if (!v32)
  {
    char v43 = 6;
    strcpy((char *)v42, "zfhmin");
LABEL_128:
    char v41 = 5;
    strcpy((char *)__p, "zhinx");
    goto LABEL_129;
  }
  do
  {
    if ((llvm::RISCVISAInfo::compareExtension((char *)v44, v32 + 32) & 1) == 0)
    {
      if (!llvm::RISCVISAInfo::compareExtension(v32 + 32, (char *)v44))
      {
        int v26 = 0;
        unint64_t v27 = a2;
        goto LABEL_134;
      }
      v32 += 8;
    }
    unint64_t v32 = *(char **)v32;
  }
  while (v32);
  int v33 = (char *)*((void *)this + 4);
  char v43 = 6;
  strcpy((char *)v42, "zfhmin");
  if (!v33) {
    goto LABEL_128;
  }
  do
  {
    if ((llvm::RISCVISAInfo::compareExtension((char *)v42, v33 + 32) & 1) == 0)
    {
      if (!llvm::RISCVISAInfo::compareExtension(v33 + 32, (char *)v42))
      {
        int v26 = 0;
        unint64_t v27 = a2;
        goto LABEL_132;
      }
      v33 += 8;
    }
    int v33 = *(char **)v33;
  }
  while (v33);
  int v34 = (char *)*((void *)this + 4);
  char v41 = 5;
  strcpy((char *)__p, "zhinx");
  if (!v34) {
    goto LABEL_129;
  }
  do
  {
    if ((llvm::RISCVISAInfo::compareExtension((char *)__p, v34 + 32) & 1) == 0)
    {
      if (!llvm::RISCVISAInfo::compareExtension(v34 + 32, (char *)__p))
      {
        int v26 = 0;
        goto LABEL_130;
      }
      v34 += 8;
    }
    int v34 = *(char **)v34;
  }
  while (v34);
  unsigned int v35 = (char *)*((void *)this + 4);
  char v39 = 8;
  strcpy((char *)v38, "zhinxmin");
  if (!v35)
  {
LABEL_129:
    int v26 = 1;
    goto LABEL_130;
  }
  while (2)
  {
    if (llvm::RISCVISAInfo::compareExtension((char *)v38, v35 + 32)) {
      goto LABEL_138;
    }
    if (llvm::RISCVISAInfo::compareExtension(v35 + 32, (char *)v38))
    {
      v35 += 8;
LABEL_138:
      unsigned int v35 = *(char **)v35;
      if (!v35)
      {
        int v26 = 1;
        goto LABEL_142;
      }
      continue;
    }
    break;
  }
  int v26 = 0;
LABEL_142:
  if (v39 < 0) {
    operator delete(v38[0]);
  }
LABEL_130:
  unint64_t v27 = a2;
  if (v41 < 0) {
    operator delete(__p[0]);
  }
LABEL_132:
  if (v43 < 0) {
    operator delete(v42[0]);
  }
LABEL_134:
  if (v45 < 0) {
    operator delete(v44[0]);
  }
LABEL_96:
  if (v48 < 0) {
    operator delete((void *)v46);
  }
  if (v26)
  {
    unint64_t v28 = std::generic_category();
    uint64_t v46 = 22;
    std::string::size_type v47 = v28;
    uint64_t v29 = "zvfh requires zfh, zfhmin, zhinx or zhinxmin extension to also be specified";
    goto LABEL_106;
  }
  if (v19) {
    char v30 = v18;
  }
  else {
    char v30 = 1;
  }
  if ((v30 & 1) == 0)
  {
    uint64_t v31 = std::generic_category();
    uint64_t v46 = 22;
    std::string::size_type v47 = v31;
    uint64_t v29 = "zvl*b requires v or zve* extension to also be specified";
LABEL_106:
    v44[0] = (void *)v29;
LABEL_94:
    sub_1CD06481C();
  }
  *unint64_t v27 = 0;
}

void llvm::RISCVISAInfo::updateImplication(llvm::RISCVISAInfo *this)
{
  v51[32] = *MEMORY[0x1E4F143B8];
  int v2 = 1;
  char v48 = 1;
  LOWORD(__p[0]) = 101;
  char v4 = (char **)((char *)this + 32);
  int v3 = (char *)*((void *)this + 4);
  if (!v3)
  {
    int v5 = 1;
    goto LABEL_10;
  }
  while ((llvm::RISCVISAInfo::compareExtension((char *)__p, v3 + 32) & 1) != 0)
  {
LABEL_3:
    int v3 = *(char **)v3;
    if (!v3)
    {
      int v5 = 1;
      goto LABEL_7;
    }
  }
  if (llvm::RISCVISAInfo::compareExtension(v3 + 32, (char *)__p))
  {
    v3 += 8;
    goto LABEL_3;
  }
  int v5 = 0;
LABEL_7:
  if (v48 < 0) {
    operator delete(__p[0]);
  }
LABEL_10:
  char v48 = 1;
  LOWORD(__p[0]) = 105;
  char v6 = *v4;
  if (!*v4) {
    goto LABEL_18;
  }
  while (2)
  {
    if (llvm::RISCVISAInfo::compareExtension((char *)__p, v6 + 32))
    {
LABEL_12:
      char v6 = *(char **)v6;
      if (!v6)
      {
        int v2 = 1;
        goto LABEL_16;
      }
      continue;
    }
    break;
  }
  if (llvm::RISCVISAInfo::compareExtension(v6 + 32, (char *)__p))
  {
    v6 += 8;
    goto LABEL_12;
  }
  int v2 = 0;
LABEL_16:
  if (v48 < 0) {
    operator delete(__p[0]);
  }
LABEL_18:
  if ((v5 & v2) == 1)
  {
    uint64_t v41 = sub_1CD0A2384("i", 1uLL);
    llvm::RISCVISAInfo::addExtension((uint64_t)this, "i", 1uLL, v41, HIDWORD(v41));
  }
  __p[0] = (void *)1;
  for (uint64_t i = 1; i != 33; i += 4)
  {
    int v8 = &__p[i];
    *(_OWORD *)int v8 = xmmword_1CFAC4A20;
    *((_OWORD *)v8 + 1) = xmmword_1CFAC4A20;
  }
  uint64_t v49 = v51;
  uint64_t v50 = 0x1000000000;
  char v42 = this;
  uint64_t v9 = (char **)*((void *)this + 3);
  if (v9 != v4)
  {
    do
    {
      uint64_t v10 = (void **)v9[4];
      char v11 = *((unsigned char *)v9 + 55);
      int v12 = v11;
      if (v11 >= 0) {
        uint64_t v10 = (void **)(v9 + 4);
      }
      size_t v13 = v11 & 0x7F;
      if (v12 < 0) {
        size_t v13 = (size_t)v9[5];
      }
      std::string __dst = v10;
      size_t v44 = v13;
      sub_1CD841518((uint64_t)__p, (const void **)&__dst);
      int v14 = v9[1];
      if (v14)
      {
        do
        {
          unint64_t v15 = (char **)v14;
          int v14 = *(char **)v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          unint64_t v15 = (char **)v9[2];
          BOOL v16 = *v15 == (char *)v9;
          uint64_t v9 = v15;
        }
        while (!v16);
      }
      uint64_t v9 = v15;
    }
    while (v15 != v4);
    unsigned int v17 = v50;
    if (v50)
    {
      while (1)
      {
        char v18 = (char *)v49 + 16 * v17;
        int v19 = (const void *)*((void *)v18 - 2);
        size_t v20 = *((void *)v18 - 1);
        sub_1CD8421D8(__p, (const void **)v18 - 2);
        unsigned int v17 = v50 - 1;
        LODWORD(v50) = v50 - 1;
        unint64_t v21 = &off_1E6855D00;
        unint64_t v22 = 26;
        do
        {
          uint64_t v23 = (uint64_t)&v21[4 * (v22 >> 1)];
          BOOL v24 = sub_1CC1565A8(v23, v19, v20);
          if (v24) {
            v22 += ~(v22 >> 1);
          }
          else {
            v22 >>= 1;
          }
          if (v24) {
            unint64_t v21 = (char **)(v23 + 32);
          }
        }
        while (v22);
        if (v21 != &off_1E6856040 && v21[1] == (char *)v20 && (!v20 || !memcmp(*v21, v19, v20)))
        {
          int v25 = v21[3];
          if (v25) {
            break;
          }
        }
LABEL_76:
        if (!v17) {
          goto LABEL_77;
        }
      }
      int v26 = (const void **)v21[2];
      unint64_t v27 = &v26[(void)v25];
LABEL_47:
      unint64_t v28 = (void **)*v26;
      std::string __dst = v28;
      if (v28) {
        size_t v29 = strlen((const char *)v28);
      }
      else {
        size_t v29 = 0;
      }
      size_t v44 = v29;
      if (sub_1CD841DA0((uint64_t)__p, (const void **)&__dst, &v46)) {
        goto LABEL_69;
      }
      size_t v30 = strlen((const char *)v28);
      if (v30 >= 0x7FFFFFFFFFFFFFF8) {
        abort();
      }
      size_t v31 = v30;
      if (v30 >= 0x17)
      {
        uint64_t v33 = (v30 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v30 | 7) != 0x17) {
          uint64_t v33 = v30 | 7;
        }
        uint64_t v34 = v33 + 1;
        p_dst = (void **)operator new(v33 + 1);
        size_t v44 = v31;
        unint64_t v45 = v34 | 0x8000000000000000;
        std::string __dst = p_dst;
      }
      else
      {
        HIBYTE(v45) = v30;
        p_dst = (void **)&__dst;
        if (!v30)
        {
LABEL_59:
          *((unsigned char *)p_dst + v31) = 0;
          unsigned int v35 = *v4;
          if (!*v4)
          {
LABEL_65:
            int v36 = 1;
            goto LABEL_66;
          }
          while (1)
          {
            if ((llvm::RISCVISAInfo::compareExtension((char *)&__dst, v35 + 32) & 1) == 0)
            {
              if (!llvm::RISCVISAInfo::compareExtension(v35 + 32, (char *)&__dst))
              {
                int v36 = 0;
LABEL_66:
                if (SHIBYTE(v45) < 0) {
                  operator delete(__dst);
                }
                if (v36)
                {
                  if (v28)
                  {
                    size_t v39 = strlen((const char *)v28);
                    uint64_t v40 = sub_1CD0A2384(v28, v39);
                    llvm::RISCVISAInfo::addExtension((uint64_t)v42, (const std::string::value_type *)v28, v39, v40, HIDWORD(v40));
                    size_t v38 = strlen((const char *)v28);
                  }
                  else
                  {
                    uint64_t v37 = sub_1CD0A2384(0, 0);
                    llvm::RISCVISAInfo::addExtension((uint64_t)v42, 0, 0, v37, HIDWORD(v37));
                    size_t v38 = 0;
                  }
                  std::string __dst = v28;
                  size_t v44 = v38;
                  sub_1CD841518((uint64_t)__p, (const void **)&__dst);
                }
LABEL_69:
                if (++v26 == v27)
                {
                  unsigned int v17 = v50;
                  goto LABEL_76;
                }
                goto LABEL_47;
              }
              v35 += 8;
            }
            unsigned int v35 = *(char **)v35;
            if (!v35) {
              goto LABEL_65;
            }
          }
        }
      }
      memmove(p_dst, v28, v31);
      goto LABEL_59;
    }
  }
LABEL_77:
  if (v49 != v51) {
    free(v49);
  }
  if (((uint64_t)__p[0] & 1) == 0) {
    MEMORY[0x1D25D9CD0](__p[1], 8);
  }
}

uint64_t llvm::RISCVISAInfo::updateMinVLen(uint64_t this)
{
  uint64_t v1 = *(void **)(this + 24);
  if (v1 != (void *)(this + 32))
  {
    do
    {
      int v2 = (void *)v1[4];
      char v3 = *((unsigned char *)v1 + 55);
      int v4 = v3;
      if (v3 >= 0) {
        int v2 = v1 + 4;
      }
      unint64_t v5 = v3 & 0x7F;
      if (v4 < 0) {
        unint64_t v5 = v1[5];
      }
      unint64_t v6 = v5 - 3;
      if (v5 >= 3)
      {
        BOOL v7 = *(_WORD *)v2 == 30330 && *((unsigned char *)v2 + 2) == 108;
        if (v7 && v5 >= 4 && *((unsigned char *)v2 + v5 - 1) == 98)
        {
          if (v6 >= v5 - 4) {
            unint64_t v6 = v5 - 4;
          }
          if (v6)
          {
            unint64_t v8 = 0;
            uint64_t v9 = (unsigned __int8 *)v2 + 3;
            while (1)
            {
              int v10 = *v9;
              if ((v10 - 48) >= 0xA)
              {
                if ((v10 - 97) >= 0x1A)
                {
                  if ((v10 - 65) > 0x19) {
                    break;
                  }
                  int v11 = -55;
                }
                else
                {
                  int v11 = -87;
                }
              }
              else
              {
                int v11 = -48;
              }
              unsigned int v12 = v11 + v10;
              if (v12 > 9) {
                break;
              }
              unint64_t v13 = 10 * v8 + v12;
              if (v8 > v13 / 0xA) {
                break;
              }
              ++v9;
              unint64_t v8 = v13;
              if (!--v6)
              {
                if (!HIDWORD(v13))
                {
                  unsigned int v14 = *(_DWORD *)(this + 8);
                  if (v14 <= v13) {
                    unsigned int v14 = v13;
                  }
                  *(_DWORD *)(this + --*(_DWORD *)(this + 8) = v14;
                }
                break;
              }
            }
          }
        }
      }
      unint64_t v15 = (void *)v1[1];
      if (v15)
      {
        do
        {
          BOOL v16 = v15;
          unint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          BOOL v16 = (void *)v1[2];
          BOOL v7 = *v16 == (void)v1;
          uint64_t v1 = v16;
        }
        while (!v7);
      }
      uint64_t v1 = v16;
    }
    while (v16 != (void *)(this + 32));
  }
  return this;
}

uint64_t llvm::RISCVISAInfo::updateMaxELen(uint64_t this)
{
  uint64_t v1 = *(void **)(this + 24);
  if (v1 == (void *)(this + 32)) {
    return this;
  }
  do
  {
    int v2 = (void *)v1[4];
    char v3 = *((unsigned char *)v1 + 55);
    int v4 = v3;
    if (v3 >= 0) {
      int v2 = v1 + 4;
    }
    unint64_t v5 = v3 & 0x7F;
    if (v4 < 0) {
      unint64_t v5 = v1[5];
    }
    unint64_t v6 = v5 - 3;
    if (v5 < 3) {
      goto LABEL_48;
    }
    BOOL v7 = *(_WORD *)v2 == 30330 && *((unsigned char *)v2 + 2) == 101;
    if (!v7) {
      goto LABEL_48;
    }
    unint64_t v8 = (unsigned __int8 *)v2 + 3;
    unint64_t v9 = v5 - 4;
    int v10 = v8[v9];
    if (v10 == 102)
    {
      unsigned int v11 = *(_DWORD *)(this + 16);
      if (v11 <= 0x20) {
        unsigned int v11 = 32;
      }
      *(_DWORD *)(this + 16) = v11;
      int v10 = v8[v9];
    }
    if (v10 == 100)
    {
      unsigned int v12 = *(_DWORD *)(this + 16);
      if (v12 <= 0x40) {
        unsigned int v12 = 64;
      }
      *(_DWORD *)(this + 16) = v12;
    }
    if (v6 >= v9) {
      unint64_t v6 = v9;
    }
    if (!v6)
    {
      unint64_t v18 = 0;
      BOOL v19 = 0;
LABEL_35:
      BOOL v20 = 1;
      goto LABEL_39;
    }
    unint64_t v13 = 0;
    unint64_t v14 = v6;
    while (1)
    {
      int v15 = *v8;
      if ((v15 - 48) < 0xA)
      {
        int v16 = -48;
        goto LABEL_26;
      }
      if ((v15 - 97) < 0x1A)
      {
        int v16 = -87;
        goto LABEL_26;
      }
      if ((v15 - 65) > 0x19) {
        break;
      }
      int v16 = -55;
LABEL_26:
      unsigned int v17 = v16 + v15;
      if (v17 > 9) {
        break;
      }
      unint64_t v18 = 10 * v13 + v17;
      if (v13 > v18 / 0xA)
      {
        BOOL v19 = 1;
        goto LABEL_35;
      }
      ++v8;
      unint64_t v13 = v18;
      if (!--v14) {
        goto LABEL_38;
      }
    }
    unint64_t v18 = v13;
LABEL_38:
    BOOL v20 = v6 == v14;
    BOOL v19 = v14 != 0;
LABEL_39:
    int v21 = v19 || v20;
    if (v18 >= 0x100000000) {
      unsigned int v22 = 0;
    }
    else {
      unsigned int v22 = v18;
    }
    if (v21) {
      unsigned int v23 = 0;
    }
    else {
      unsigned int v23 = v22;
    }
    if (*(_DWORD *)(this + 12) > v23) {
      unsigned int v23 = *(_DWORD *)(this + 12);
    }
    *(_DWORD *)(this + 12) = v23;
LABEL_48:
    BOOL v24 = (void *)v1[1];
    if (v24)
    {
      do
      {
        int v25 = v24;
        BOOL v24 = (void *)*v24;
      }
      while (v24);
    }
    else
    {
      do
      {
        int v25 = (void *)v1[2];
        BOOL v7 = *v25 == (void)v1;
        uint64_t v1 = v25;
      }
      while (!v7);
    }
    uint64_t v1 = v25;
  }
  while (v25 != (void *)(this + 32));
  return this;
}

void llvm::RISCVISAInfo::toString(llvm::RISCVISAInfo *this@<X0>, uint64_t a2@<X8>)
{
  v30[0] = 0;
  v30[1] = 0;
  uint64_t v31 = 0;
  int v22 = 0;
  char v26 = 0;
  uint64_t v27 = 0;
  size_t v29 = v30;
  int v28 = 0;
  int v21 = &unk_1F2646F30;
  uint64_t v23 = 0;
  BOOL v24 = 0;
  int v25 = 0;
  llvm::raw_ostream::write((llvm::raw_ostream *)&v21, "rv", 2uLL);
  sub_1CD098D14((llvm::raw_ostream *)&v21, *(unsigned int *)this, 0, 0, 0);
  int v4 = (llvm::RISCVISAInfo *)*((void *)this + 3);
  if (v4 != (llvm::RISCVISAInfo *)((char *)this + 32))
  {
    char v5 = 0;
    do
    {
      char v6 = *((unsigned char *)v4 + 55);
      int v7 = v6;
      if (v6 >= 0) {
        unint64_t v8 = (char *)v4 + 32;
      }
      else {
        unint64_t v8 = (const void *)*((void *)v4 + 4);
      }
      size_t v9 = v6 & 0x7F;
      if (v7 >= 0) {
        size_t v10 = v9;
      }
      else {
        size_t v10 = *((void *)v4 + 5);
      }
      if (*((char *)v4 + 79) < 0)
      {
        sub_1CB8BDF7C((uint64_t)__p, *((const void **)v4 + 7), *((void *)v4 + 8));
      }
      else
      {
        *(_OWORD *)std::string __p = *(_OWORD *)((char *)v4 + 56);
        uint64_t v19 = *((void *)v4 + 9);
      }
      uint64_t v20 = *((void *)v4 + 10);
      unint64_t v11 = v5 & 1;
      unsigned int v12 = v25;
      if (v24 - v25 >= v11)
      {
        if (v5)
        {
          memcpy(v25, "_", v5 & 1);
          unsigned int v12 = &v25[v11];
          v25 += v11;
        }
      }
      else
      {
        if (v5) {
          unint64_t v13 = "_";
        }
        else {
          unint64_t v13 = 0;
        }
        llvm::raw_ostream::write((llvm::raw_ostream *)&v21, v13, v5 & 1);
        unsigned int v12 = v25;
      }
      if (v10 <= v24 - v12)
      {
        if (v10)
        {
          memcpy(v12, v8, v10);
          v25 += v10;
        }
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v21, (const char *)v8, v10);
      }
      sub_1CD098D14((llvm::raw_ostream *)&v21, v20, 0, 0, 0);
      if (v24 == v25) {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v21, "p", 1uLL);
      }
      else {
        *v25++ = 112;
      }
      sub_1CD098D14((llvm::raw_ostream *)&v21, HIDWORD(v20), 0, 0, 0);
      if (SHIBYTE(v19) < 0) {
        operator delete(__p[0]);
      }
      unint64_t v14 = (llvm::RISCVISAInfo *)*((void *)v4 + 1);
      if (v14)
      {
        do
        {
          int v15 = v14;
          unint64_t v14 = *(llvm::RISCVISAInfo **)v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          int v15 = (llvm::RISCVISAInfo *)*((void *)v4 + 2);
          BOOL v16 = *(void *)v15 == (void)v4;
          int v4 = v15;
        }
        while (!v16);
      }
      char v5 = 1;
      int v4 = v15;
    }
    while (v15 != (llvm::RISCVISAInfo *)((char *)this + 32));
  }
  if (*((char *)v29 + 23) < 0)
  {
    sub_1CB8BDF7C(a2, *v29, (unint64_t)v29[1]);
  }
  else
  {
    long long v17 = *(_OWORD *)v29;
    *(void *)(a2 + 16) = v29[2];
    *(_OWORD *)a2 = v17;
  }
  int v21 = &unk_1F2646B98;
  if (v28 == 1 && v23) {
    MEMORY[0x1D25D9CB0](v23, 0x1000C8077774924);
  }
  if (SHIBYTE(v31) < 0) {
    operator delete(v30[0]);
  }
}

BOOL sub_1CD0A37EC(const void *a1, size_t a2, char *__s)
{
  if (__s)
  {
    if (strlen(__s) != a2) {
      return 0;
    }
    if (!a2) {
      return 1;
    }
    return memcmp(__s, a1, a2) == 0;
  }
  else
  {
    return a2 == 0;
  }
}

uint64_t sub_1CD0A3864(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 == a2) {
    return 0;
  }
  uint64_t v5 = a1;
  char v6 = *(const void **)a3;
  size_t v7 = *(void *)(a3 + 8);
  while (1)
  {
    size_t v8 = *(void *)v5 ? strlen(*(const char **)v5) : 0;
    if (v8 == v7
      && (!v7 || !memcmp(*(const void **)v5, v6, v7))
      && *(_DWORD *)(a3 + 16) == *(_DWORD *)(v5 + 8)
      && *(_DWORD *)(a3 + 20) == *(_DWORD *)(v5 + 12))
    {
      break;
    }
    v5 += 16;
    if (v5 == a2) {
      return 0;
    }
  }
  return 1;
}

unint64_t llvm::ScaledNumbers::multiply64(unint64_t this, uint64_t a2)
{
  unint64_t v2 = HIDWORD(this);
  unint64_t v3 = a2 * (unint64_t)HIDWORD(this);
  unint64_t v4 = HIDWORD(a2) * (unint64_t)this;
  unint64_t v5 = a2 * (unint64_t)this;
  unint64_t result = a2 * this;
  if (result >= v5 + (v3 << 32)) {
    unint64_t v7 = (__PAIR128__(HIDWORD(v3) + HIDWORD(a2) * (unint64_t)v2, v5)
  }
        + __PAIR128__(HIDWORD(v4), v3 << 32)) >> 64;
  else {
    unint64_t v7 = ((__PAIR128__(HIDWORD(v3) + HIDWORD(a2) * (unint64_t)v2, v5)
  }
         + __PAIR128__(HIDWORD(v4), v3 << 32)) >> 64)
       + 1;
  if (v7)
  {
    int v8 = __clz(v7);
    if (v8) {
      unint64_t v7 = (result >> -(char)v8) | (v7 << v8);
    }
    if ((result >> (v8 ^ 0x3Fu)))
    {
      BOOL v9 = __CFADD__(v7, 1);
      unint64_t v10 = v7 + 1;
      if (v9) {
        return 0x8000000000000000;
      }
      else {
        return v10;
      }
    }
    else
    {
      return v7;
    }
  }
  return result;
}

unint64_t llvm::ScaledNumbers::divide32(llvm::ScaledNumbers *this, unsigned int a2)
{
  unsigned int v2 = __clz(this) + 32;
  if (!this) {
    unsigned int v2 = 64;
  }
  unint64_t v3 = ((unint64_t)this << v2) / a2;
  if (HIDWORD(v3))
  {
    __int16 v4 = __clz(v3);
    unint64_t v5 = v3 >> (32 - v4);
    LOWORD(v2) = 32 - v4 - v2;
    unint64_t v6 = v3 >> (31 - v4);
    unsigned int v7 = v5 + 1;
    if (v5 == -1)
    {
      unsigned int v7 = 0x80000000;
      __int16 v8 = v2 + 1;
    }
    else
    {
      __int16 v8 = v2;
    }
    BOOL v9 = (v6 & 1) == 0;
    if (v6) {
      unint64_t v3 = v7;
    }
    else {
      unint64_t v3 = v5;
    }
    if (!v9) {
      LOWORD(v2) = v8;
    }
  }
  else
  {
    int v10 = -v2;
    unint64_t v11 = ((unint64_t)this << v2) % a2;
    unint64_t v12 = (a2 & 1) + ((unint64_t)a2 >> 1);
    unsigned int v13 = v3 + 1;
    if (v3 == -1)
    {
      unsigned int v13 = 0x80000000;
      LOWORD(v10) = 1 - v2;
    }
    if (v11 >= v12) {
      unint64_t v3 = v13;
    }
    else {
      unint64_t v3 = v3;
    }
    if (v11 < v12) {
      unsigned int v2 = -v2;
    }
    else {
      LOWORD(v2) = v10;
    }
  }
  return v3 | ((unint64_t)(unsigned __int16)v2 << 32);
}

unint64_t llvm::ScaledNumbers::divide64(unint64_t this, unint64_t a2)
{
  int v2 = __clz(__rbit64(a2));
  int v3 = -v2;
  if (!v2) {
    LOBYTE(v2) = 0;
  }
  unint64_t v4 = a2 >> v2;
  if (v4 != 1)
  {
    int v5 = __clz(this);
    __int16 v6 = v3 - v5;
    if (!v5) {
      LOBYTE(v5) = 0;
    }
    uint64_t v7 = this << v5;
    unint64_t v8 = (this << v5) / v4;
    uint64_t v9 = v7 - v8 * v4;
    if (v9)
    {
      do
      {
        --v6;
        BOOL v10 = v9 < 0;
        unint64_t v11 = 2 * v9;
        uint64_t v13 = v10 || v4 <= v11;
        if (v13) {
          unint64_t v14 = v4;
        }
        else {
          unint64_t v14 = 0;
        }
        uint64_t v9 = v11 - v14;
        unint64_t v8 = v13 | (2 * v8);
      }
      while ((v8 & 0x8000000000000000) == 0 && v9);
    }
    unint64_t v15 = (v4 & 1) + (v4 >> 1);
    unint64_t v16 = v8 + 1;
    if (v8 == -1) {
      unint64_t v16 = 0x8000000000000000;
    }
    if (v9 >= v15) {
      return v16;
    }
    else {
      return v8;
    }
  }
  return this;
}

uint64_t llvm::ScaledNumbers::compareImpl(unint64_t this, unint64_t a2, char a3)
{
  BOOL v3 = this >> a3 << a3 < this;
  if (this >> a3 > a2) {
    BOOL v3 = 1;
  }
  if (this >> a3 >= a2) {
    return v3;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

void llvm::ScaledNumberBase::toString(unint64_t this@<X0>, unsigned int a2@<W1>, char a3@<W2>, unsigned int a4@<W3>, uint64_t a5@<X8>)
{
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  if (!this)
  {
    *(unsigned char *)(a5 + 23) = 3;
    *(_DWORD *)a5 = 3157552;
    return;
  }
  if (!a2)
  {
    unint64_t v10 = 0;
    unsigned int v11 = 0;
    unint64_t v12 = 0;
    BOOL v14 = 0;
    memset(&__str, 0, sizeof(__str));
    unint64_t v13 = this;
    do
    {
LABEL_36:
      std::string::push_back(&__str, (v13 % 0xA) | 0x30);
      BOOL v15 = v13 > 9;
      v13 /= 0xAuLL;
    }
    while (v15);
    char v16 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    std::string::size_type size = __str.__r_.__value_.__l.__size_;
    std::string::size_type v18 = *((unsigned char *)&__str.__r_.__value_.__s + 23) & 0x7F;
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unint64_t v19 = *((unsigned char *)&__str.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      unint64_t v19 = __str.__r_.__value_.__l.__size_;
    }
    goto LABEL_41;
  }
  if ((int)a2 < 1)
  {
    if (a2 < 0xFFFFFFC1)
    {
      if (a2 == -64)
      {
        unint64_t v10 = 0;
        unsigned int v11 = 0;
        memset(&__str, 0, sizeof(__str));
        BOOL v14 = 1;
        unint64_t v12 = this;
        goto LABEL_40;
      }
      if (a2 >= 0xFFFFFF89) {
        unint64_t v10 = this << a2;
      }
      else {
        unint64_t v10 = 0;
      }
      if (a2 >= 0xFFFFFF89) {
        unsigned int v11 = -64 - a2;
      }
      else {
        unsigned int v11 = 0;
      }
      if (a2 >= 0xFFFFFF89) {
        unint64_t v12 = this >> -(char)a2;
      }
      else {
        unint64_t v12 = 0;
      }
      unint64_t v13 = 0;
    }
    else
    {
      unint64_t v10 = 0;
      unsigned int v11 = 0;
      unint64_t v13 = this >> -(char)a2;
      unint64_t v12 = this << a2;
    }
  }
  else
  {
    unsigned int v7 = __clz(this);
    if ((int)v7 >= (int)a2) {
      unsigned int v8 = a2;
    }
    else {
      unsigned int v8 = v7;
    }
    if (v7 >= a2) {
      unint64_t v9 = this << v8;
    }
    else {
      unint64_t v9 = 0;
    }
    if (v8) {
      LOWORD(a2) = a2 - v8;
    }
    unint64_t v10 = 0;
    unsigned int v11 = 0;
    unint64_t v12 = 0;
    if (v8) {
      unint64_t v13 = v9;
    }
    else {
      unint64_t v13 = 0;
    }
    if (v8) {
      this <<= v8;
    }
  }
  BOOL v14 = v12 != 0;
  if (!(v13 | v12))
  {
    int v49 = (__int16)a2 + 63;
    int v50 = v49 - __clz(this);
    if (v50 >= 0x3FFF) {
      int v50 = 0x3FFF;
    }
    v59.__r_.__value_.__r.__words[0] = this << (v49 - v50);
    v59.__r_.__value_.__l.__size_ = (v50 + 0x3FFF) & (unint64_t)((uint64_t)v59.__r_.__value_.__l.__data_ >> 63);
    LODWORD(__str.__r_.__value_.__r.__words[1]) = 80;
    llvm::APInt::initFromArray((uint64_t)&__str, (uint64_t *)&v59);
    llvm::detail::IEEEFloat::initFromF80LongDoubleAPInt((llvm::detail::IEEEFloat *)&v61.__r_.__value_.__r.__words[1], (const llvm::APInt *)&__str);
  }
  memset(&__str, 0, sizeof(__str));
  if (v13) {
    goto LABEL_36;
  }
LABEL_40:
  std::string::push_back(&__str, 48);
  unint64_t v19 = 0;
  char v16 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  std::string::size_type size = __str.__r_.__value_.__l.__size_;
  std::string::size_type v18 = *((unsigned char *)&__str.__r_.__value_.__s + 23) & 0x7F;
LABEL_41:
  p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
  if (v16 >= 0)
  {
    p_str = &__str;
    std::string::size_type size = v18;
  }
  int v21 = (std::string *)((char *)p_str + size - 1);
  if (size) {
    BOOL v22 = p_str >= v21;
  }
  else {
    BOOL v22 = 1;
  }
  if (!v22)
  {
    uint64_t v23 = &p_str->__r_.__value_.__s.__data_[1];
    do
    {
      std::string::value_type v24 = *(v23 - 1);
      *(v23 - 1) = v21->__r_.__value_.__s.__data_[0];
      v21->__r_.__value_.__s.__data_[0] = v24;
      int v21 = (std::string *)((char *)v21 - 1);
      BOOL v22 = v23++ >= (char *)v21;
    }
    while (!v22);
  }
  if (!v14)
  {
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      size_t v38 = *((unsigned char *)&__str.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      size_t v38 = __str.__r_.__value_.__l.__size_;
    }
    sub_1CB907098(a5, v38 + 2);
    if (*(char *)(a5 + 23) >= 0) {
      size_t v39 = (void *)a5;
    }
    else {
      size_t v39 = *(void **)a5;
    }
    if (v38)
    {
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v40 = &__str;
      }
      else {
        uint64_t v40 = (std::string *)__str.__r_.__value_.__r.__words[0];
      }
      memmove(v39, v40, v38);
    }
    strcpy((char *)v39 + v38, ".0");
    goto LABEL_107;
  }
  std::string::push_back(&__str, 46);
  uint64_t v25 = 1;
  unint64_t v26 = 1 << -a3;
  unint64_t v27 = (v10 >> 8) & 0xF0FFFFFFFFFFFFFFLL | ((v12 & 0xF) << 56);
  unint64_t v28 = v12 >> 4;
  std::string::size_type v29 = *((unsigned char *)&__str.__r_.__value_.__s + 23) & 0x7F;
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v29 = __str.__r_.__value_.__l.__size_;
  }
  std::string::size_type v55 = v29;
  while (1)
  {
    unsigned int v30 = v11;
    unint64_t v31 = v25;
    if (v11) {
      --v11;
    }
    else {
      unsigned int v11 = 0;
    }
    if (v30) {
      uint64_t v32 = 5;
    }
    else {
      uint64_t v32 = 10;
    }
    uint64_t v33 = 10 * v27;
    unint64_t v34 = 10 * v28 + ((10 * v27) >> 60);
    unint64_t v35 = v34 >> 60;
    if ((v34 >> 60) >= 0xA) {
      LOBYTE(v35) = (v34 >> 60) - 10;
    }
    std::string::push_back(&__str, v35 | 0x30);
    if (v19) {
      goto LABEL_69;
    }
    int v36 = (std::string *)__str.__r_.__value_.__r.__words[0];
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v36 = &__str;
    }
    std::string::size_type v37 = *((unsigned char *)&__str.__r_.__value_.__s + 23) & 0x7F;
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v37 = __str.__r_.__value_.__l.__size_;
    }
    if (v36->__r_.__value_.__s.__data_[v37 - 1] != 48) {
LABEL_69:
    }
      ++v19;
    else {
      unint64_t v19 = 0;
    }
    v26 *= v32;
    if (!v26) {
      break;
    }
    unint64_t v28 = v34 & 0xFFFFFFFFFFFFFFFLL;
    if (16 * v34 < v26 >> 1) {
      break;
    }
    unint64_t v27 = v33 & 0xFFFFFFFFFFFFFFELL;
    uint64_t v25 = v31 + 1;
    if (a4 && a4 < v19 && v31 >= 2) {
      goto LABEL_90;
    }
  }
  if (!a4 || a4 >= v19)
  {
LABEL_106:
    sub_1CD0A41D0((std::string *)a5, &__str);
    goto LABEL_107;
  }
LABEL_90:
  std::string::size_type v41 = *((unsigned char *)&__str.__r_.__value_.__s + 23) & 0x7F;
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v41 = __str.__r_.__value_.__l.__size_;
  }
  if (a4 - v19 + v41 <= v55 + 1) {
    std::string::size_type v42 = v55 + 1;
  }
  else {
    std::string::size_type v42 = a4 - v19 + v41;
  }
  if (v42 >= v41) {
    goto LABEL_106;
  }
  char v43 = &__str;
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    char v43 = (std::string *)__str.__r_.__value_.__r.__words[0];
  }
  if ((v43->__r_.__value_.__s.__data_[v42] - 53) < 5)
  {
    if (!v42)
    {
LABEL_105:
      uint64_t v47 = 1;
      *((unsigned char *)&v59.__r_.__value_.__s + 23) = 1;
      v59.__r_.__value_.__s.__data_[0] = 49;
      goto LABEL_116;
    }
    size_t v44 = (char *)&v43[-1].__r_.__value_.__r.__words[2] + 7;
    std::string::size_type v45 = v42;
    while (1)
    {
      int v46 = v44[v45];
      if (v46 != 46)
      {
        if (v46 != 57)
        {
          uint64_t v47 = 0;
          v43->__r_.__value_.__s.__data_[v45 - 1] = v46 + 1;
          *((unsigned char *)&v59.__r_.__value_.__s + 23) = 0;
LABEL_116:
          *(unsigned char *)((unint64_t)&v59 | v47) = 0;
          std::string::basic_string(&v57, &__str, 0, v42, (std::allocator<char> *)&v58);
          if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v51 = &v57;
          }
          else {
            uint64_t v51 = (std::string *)v57.__r_.__value_.__r.__words[0];
          }
          if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v52 = *((unsigned char *)&v57.__r_.__value_.__s + 23) & 0x7F;
          }
          else {
            std::string::size_type v52 = v57.__r_.__value_.__l.__size_;
          }
          std::string::size_type v53 = std::string::append(&v59, (const std::string::value_type *)v51, v52);
          std::string::size_type v54 = v53->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v61.__r_.__value_.__l.__data_ = *(_OWORD *)&v53->__r_.__value_.__l.__data_;
          v61.__r_.__value_.__r.__words[2] = v54;
          v53->__r_.__value_.__l.__size_ = 0;
          v53->__r_.__value_.__r.__words[2] = 0;
          v53->__r_.__value_.__r.__words[0] = 0;
          sub_1CD0A41D0((std::string *)a5, &v61);
          if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v61.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v57.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v57.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0)
          {
            char v48 = (void *)v59.__r_.__value_.__r.__words[0];
LABEL_128:
            operator delete(v48);
          }
          goto LABEL_107;
        }
        v44[v45] = 48;
      }
      if (!--v45) {
        goto LABEL_105;
      }
    }
  }
  std::string::basic_string(&v61, &__str, 0, v42, (std::allocator<char> *)&v59);
  sub_1CD0A41D0((std::string *)a5, &v61);
  if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0)
  {
    char v48 = (void *)v61.__r_.__value_.__r.__words[0];
    goto LABEL_128;
  }
LABEL_107:
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
}

std::string *sub_1CD0A41D0(std::string *a1, const std::string *a2)
{
  char v2 = HIBYTE(a2->__r_.__value_.__r.__words[2]);
  BOOL v3 = v2 < 0;
  unint64_t v4 = (const std::string *)a2->__r_.__value_.__r.__words[0];
  if (v2 >= 0) {
    unint64_t v4 = a2;
  }
  uint64_t size = v2 & 0x7F;
  if (v3) {
    uint64_t size = a2->__r_.__value_.__l.__size_;
  }
  while (size)
  {
    int v6 = *((unsigned __int8 *)&v4[-1].__r_.__value_.__r.__words[2] + size-- + 7);
    if (v6 != 48) {
      goto LABEL_9;
    }
  }
  uint64_t size = -1;
LABEL_9:
  if (v4->__r_.__value_.__s.__data_[size] == 46) {
    uint64_t v7 = size + 1;
  }
  else {
    uint64_t v7 = size;
  }
  return std::string::basic_string(a1, a2, 0, v7 + 1, (std::allocator<char> *)&v9);
}

llvm::raw_ostream *llvm::ScaledNumberBase::dump(llvm::ScaledNumberBase *this, signed int a2, int a3)
{
  int v6 = llvm::dbgs(this);
  uint64_t v7 = llvm::ScaledNumberBase::print(v6, this, a2, a3, 0);
  unsigned int v8 = (unsigned char *)*((void *)v7 + 4);
  if (*((unsigned char **)v7 + 3) == v8)
  {
    llvm::raw_ostream::write(v6, "[", 1uLL);
  }
  else
  {
    unsigned char *v8 = 91;
    ++*((void *)v6 + 4);
  }
  unint64_t v9 = a3;
  if (a3 < 0)
  {
    unint64_t v9 = -(uint64_t)a3;
    unint64_t v10 = v6;
    int v11 = 1;
  }
  else
  {
    unint64_t v10 = v6;
    int v11 = 0;
  }
  sub_1CD098D14(v10, v9, 0, 0, v11);
  unint64_t v12 = (unsigned char *)*((void *)v6 + 4);
  if (*((unsigned char **)v6 + 3) == v12)
  {
    llvm::raw_ostream::write(v6, ":", 1uLL);
  }
  else
  {
    unsigned char *v12 = 58;
    ++*((void *)v6 + 4);
  }
  sub_1CD098D14(v6, (unint64_t)this, 0, 0, 0);
  uint64_t v13 = *((void *)v6 + 4);
  if ((unint64_t)(*((void *)v6 + 3) - v13) > 2)
  {
    *(unsigned char *)(v13 + 2) = 94;
    *(_WORD *)uint64_t v13 = 12842;
    *((void *)v6 + 4) += 3;
  }
  else
  {
    llvm::raw_ostream::write(v6, "*2^", 3uLL);
  }
  unint64_t v14 = a2;
  if (a2 < 0)
  {
    unint64_t v14 = -(uint64_t)a2;
    BOOL v15 = v6;
    int v16 = 1;
  }
  else
  {
    BOOL v15 = v6;
    int v16 = 0;
  }
  unint64_t result = sub_1CD098D14(v15, v14, 0, 0, v16);
  std::string::size_type v18 = (unsigned char *)*((void *)v6 + 4);
  if (*((unsigned char **)v6 + 3) == v18)
  {
    return llvm::raw_ostream::write(v6, "]", 1uLL);
  }
  else
  {
    *std::string::size_type v18 = 93;
    ++*((void *)v6 + 4);
  }
  return result;
}

uint64_t llvm::JSONScopedPrinter::JSONScopedPrinter(uint64_t a1, uint64_t a2, int a3, uint64_t *a4)
{
  *(_DWORD *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 40) = 1;
  *(void *)a1 = &unk_1F2645380;
  *(void *)(a1 + --*(_DWORD *)(this + 8) = a2;
  *(void *)(a1 + 4--*(_DWORD *)(this + 8) = a1 + 64;
  *(void *)(a1 + 56) = 0x800000000;
  if (a3) {
    int v5 = 2;
  }
  else {
    int v5 = 0;
  }
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 12--*(_DWORD *)(this + 8) = a1 + 144;
  *(void *)(a1 + 272) = 0;
  *(void *)(a1 + 280) = 0;
  *(void *)(a1 + 28--*(_DWORD *)(this + 8) = a2;
  *(_DWORD *)(a1 + 296) = v5;
  *(_DWORD *)(a1 + 300) = 0;
  *(unsigned char *)(a1 + 304) = 0;
  *(void *)(a1 + 136) = 0x1000000001;
  uint64_t v6 = *a4;
  *a4 = 0;
  *(void *)(a1 + 312) = v6;
  if (v6) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 16))(v6, a1);
  }
  return a1;
}

void *sub_1CD0A44EC(void *a1)
{
  *a1 = &unk_1F2645380;
  uint64_t v2 = a1[39];
  a1[39] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  BOOL v3 = (void *)a1[16];
  if (v3 != a1 + 18) {
    free(v3);
  }
  unint64_t v4 = (void *)a1[6];
  if (v4 != a1 + 8) {
    free(v4);
  }
  return a1;
}

void sub_1CD0A4584(void *a1)
{
  *a1 = &unk_1F2645380;
  uint64_t v2 = a1[39];
  a1[39] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  BOOL v3 = (void *)a1[16];
  if (v3 != a1 + 18) {
    free(v3);
  }
  unint64_t v4 = (void *)a1[6];
  if (v4 != a1 + 8) {
    free(v4);
  }

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD0A463C(uint64_t a1, char *a2, unint64_t a3, uint64_t a4)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a1 + 128;
  unsigned __int16 v6 = 4;
  uint64_t v7 = a4;
  llvm::json::OStream::attributeBegin(a1 + 128, a2, a3);
  llvm::json::OStream::value(v5, &v6);
  --*(_DWORD *)(a1 + 136);
  llvm::json::Value::destroy((llvm::json::Value *)&v6);
}

void sub_1CD0A46C8(uint64_t a1, char *a2, unint64_t a3, unsigned int a4)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a1 + 128;
  unsigned __int16 v6 = 3;
  uint64_t v7 = a4;
  llvm::json::OStream::attributeBegin(a1 + 128, a2, a3);
  llvm::json::OStream::value(v5, &v6);
  --*(_DWORD *)(a1 + 136);
  llvm::json::Value::destroy((llvm::json::Value *)&v6);
}

void sub_1CD0A4758(uint64_t a1, char *a2, unint64_t a3, unsigned int a4)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a1 + 128;
  unsigned __int16 v6 = 3;
  uint64_t v7 = a4;
  llvm::json::OStream::attributeBegin(a1 + 128, a2, a3);
  llvm::json::OStream::value(v5, &v6);
  --*(_DWORD *)(a1 + 136);
  llvm::json::Value::destroy((llvm::json::Value *)&v6);
}

void sub_1CD0A47E8(uint64_t a1, char *a2, unint64_t a3, unsigned int a4)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a1 + 128;
  unsigned __int16 v6 = 3;
  uint64_t v7 = a4;
  llvm::json::OStream::attributeBegin(a1 + 128, a2, a3);
  llvm::json::OStream::value(v5, &v6);
  --*(_DWORD *)(a1 + 136);
  llvm::json::Value::destroy((llvm::json::Value *)&v6);
}

void sub_1CD0A4878(uint64_t a1, char *a2, unint64_t a3, uint64_t a4)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a1 + 128;
  unsigned __int16 v6 = 3;
  uint64_t v7 = a4;
  llvm::json::OStream::attributeBegin(a1 + 128, a2, a3);
  llvm::json::OStream::value(v5, &v6);
  --*(_DWORD *)(a1 + 136);
  llvm::json::Value::destroy((llvm::json::Value *)&v6);
}

void sub_1CD0A4904(uint64_t a1, char *a2, unint64_t a3, int a4)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a1 + 128;
  unsigned __int16 v6 = 3;
  uint64_t v7 = a4;
  llvm::json::OStream::attributeBegin(a1 + 128, a2, a3);
  llvm::json::OStream::value(v5, &v6);
  --*(_DWORD *)(a1 + 136);
  llvm::json::Value::destroy((llvm::json::Value *)&v6);
}

void sub_1CD0A4994(uint64_t a1, char *a2, unint64_t a3, int a4)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a1 + 128;
  unsigned __int16 v6 = 3;
  uint64_t v7 = a4;
  llvm::json::OStream::attributeBegin(a1 + 128, a2, a3);
  llvm::json::OStream::value(v5, &v6);
  --*(_DWORD *)(a1 + 136);
  llvm::json::Value::destroy((llvm::json::Value *)&v6);
}

void sub_1CD0A4A24(uint64_t a1, char *a2, unint64_t a3, int a4)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a1 + 128;
  unsigned __int16 v6 = 3;
  uint64_t v7 = a4;
  llvm::json::OStream::attributeBegin(a1 + 128, a2, a3);
  llvm::json::OStream::value(v5, &v6);
  --*(_DWORD *)(a1 + 136);
  llvm::json::Value::destroy((llvm::json::Value *)&v6);
}

void sub_1CD0A4AB4(uint64_t a1, char *a2, unint64_t a3, uint64_t a4)
{
  v11[5] = *MEMORY[0x1E4F143B8];
  unsigned __int16 v6 = (llvm::json::OStream *)(a1 + 128);
  llvm::json::OStream::attributeBegin(a1 + 128, a2, a3);
  uint64_t v7 = (llvm::raw_ostream *)llvm::json::OStream::rawValueBegin(v6);
  BOOL v8 = *(unsigned char *)(a4 + 12) == 0;
  unint64_t v9 = v11;
  long long v10 = xmmword_1CDB15B30;
  llvm::APInt::toString((unsigned int *)a4, &v9, 0xAu, v8, 0);
  llvm::raw_ostream::write(v7, (const char *)v9, v10);
  if (v9 != v11) {
    free(v9);
  }
  *(_DWORD *)(a1 + 136) -= 2;
}

void sub_1CD0A4B90(uint64_t a1, char *a2, unint64_t a3, char a4)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a1 + 128;
  unsigned __int16 v6 = 1;
  char v7 = a4;
  llvm::json::OStream::attributeBegin(a1 + 128, a2, a3);
  llvm::json::OStream::value(v5, &v6);
  --*(_DWORD *)(a1 + 136);
  llvm::json::Value::destroy((llvm::json::Value *)&v6);
}

llvm::raw_ostream *sub_1CD0A4C1C(uint64_t a1, char *a2, unint64_t a3, char *a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = (llvm::json::OStream *)(a1 + 128);
  llvm::json::OStream::attributeBegin(a1 + 128, a2, a3);
  llvm::json::OStream::arrayBegin(v8);
  for (; a5; --a5)
  {
    char v9 = *a4++;
    unsigned __int16 v11 = 1;
    char v12 = v9;
    llvm::json::OStream::value((uint64_t)v8, &v11);
    llvm::json::Value::destroy((llvm::json::Value *)&v11);
  }
  unint64_t result = llvm::json::OStream::arrayEnd(v8);
  --*(_DWORD *)(a1 + 136);
  return result;
}

llvm::raw_ostream *sub_1CD0A4CE0(uint64_t a1, char *a2, unint64_t a3, long long *a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = (llvm::json::OStream *)(a1 + 128);
  llvm::json::OStream::attributeBegin(a1 + 128, a2, a3);
  llvm::json::OStream::arrayBegin(v8);
  if (a5)
  {
    uint64_t v9 = 24 * a5;
    do
    {
      if (*((char *)a4 + 23) < 0)
      {
        sub_1CB8BDF7C((uint64_t)__p, *(const void **)a4, *((void *)a4 + 1));
      }
      else
      {
        long long v10 = *a4;
        uint64_t v13 = *((void *)a4 + 2);
        *(_OWORD *)std::string __p = v10;
      }
      sub_1CD452764((uint64_t)v14, (unint64_t)__p);
      llvm::json::OStream::value((uint64_t)v8, v14);
      llvm::json::Value::destroy((llvm::json::Value *)v14);
      if (SHIBYTE(v13) < 0) {
        operator delete(__p[0]);
      }
      a4 = (long long *)((char *)a4 + 24);
      v9 -= 24;
    }
    while (v9);
  }
  unint64_t result = llvm::json::OStream::arrayEnd(v8);
  --*(_DWORD *)(a1 + 136);
  return result;
}

llvm::raw_ostream *sub_1CD0A4DDC(uint64_t a1, char *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = (llvm::json::OStream *)(a1 + 128);
  llvm::json::OStream::attributeBegin(a1 + 128, a2, a3);
  llvm::json::OStream::arrayBegin(v8);
  if (a5)
  {
    uint64_t v9 = 8 * a5;
    do
    {
      uint64_t v10 = *a4++;
      unsigned __int16 v12 = 4;
      uint64_t v13 = v10;
      llvm::json::OStream::value((uint64_t)v8, &v12);
      llvm::json::Value::destroy((llvm::json::Value *)&v12);
      v9 -= 8;
    }
    while (v9);
  }
  unint64_t result = llvm::json::OStream::arrayEnd(v8);
  --*(_DWORD *)(a1 + 136);
  return result;
}

llvm::raw_ostream *sub_1CD0A4EA4(uint64_t a1, char *a2, unint64_t a3, unsigned int *a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = (llvm::json::OStream *)(a1 + 128);
  llvm::json::OStream::attributeBegin(a1 + 128, a2, a3);
  llvm::json::OStream::arrayBegin(v8);
  if (a5)
  {
    uint64_t v9 = 4 * a5;
    do
    {
      unsigned int v10 = *a4++;
      unsigned __int16 v12 = 3;
      uint64_t v13 = v10;
      llvm::json::OStream::value((uint64_t)v8, &v12);
      llvm::json::Value::destroy((llvm::json::Value *)&v12);
      v9 -= 4;
    }
    while (v9);
  }
  unint64_t result = llvm::json::OStream::arrayEnd(v8);
  --*(_DWORD *)(a1 + 136);
  return result;
}

llvm::raw_ostream *sub_1CD0A4F6C(uint64_t a1, char *a2, unint64_t a3, unsigned __int16 *a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = (llvm::json::OStream *)(a1 + 128);
  llvm::json::OStream::attributeBegin(a1 + 128, a2, a3);
  llvm::json::OStream::arrayBegin(v8);
  if (a5)
  {
    uint64_t v9 = 2 * a5;
    do
    {
      unsigned int v10 = *a4++;
      unsigned __int16 v12 = 3;
      uint64_t v13 = v10;
      llvm::json::OStream::value((uint64_t)v8, &v12);
      llvm::json::Value::destroy((llvm::json::Value *)&v12);
      v9 -= 2;
    }
    while (v9);
  }
  unint64_t result = llvm::json::OStream::arrayEnd(v8);
  --*(_DWORD *)(a1 + 136);
  return result;
}

llvm::raw_ostream *sub_1CD0A5034(uint64_t a1, char *a2, unint64_t a3, unsigned __int8 *a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = (llvm::json::OStream *)(a1 + 128);
  llvm::json::OStream::attributeBegin(a1 + 128, a2, a3);
  llvm::json::OStream::arrayBegin(v8);
  for (; a5; --a5)
  {
    unsigned int v9 = *a4++;
    unsigned __int16 v11 = 3;
    uint64_t v12 = v9;
    llvm::json::OStream::value((uint64_t)v8, &v11);
    llvm::json::Value::destroy((llvm::json::Value *)&v11);
  }
  unint64_t result = llvm::json::OStream::arrayEnd(v8);
  --*(_DWORD *)(a1 + 136);
  return result;
}

llvm::raw_ostream *sub_1CD0A50F8(uint64_t a1, char *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = (llvm::json::OStream *)(a1 + 128);
  llvm::json::OStream::attributeBegin(a1 + 128, a2, a3);
  llvm::json::OStream::arrayBegin(v8);
  if (a5)
  {
    uint64_t v9 = 8 * a5;
    do
    {
      uint64_t v10 = *a4++;
      unsigned __int16 v12 = 3;
      uint64_t v13 = v10;
      llvm::json::OStream::value((uint64_t)v8, &v12);
      llvm::json::Value::destroy((llvm::json::Value *)&v12);
      v9 -= 8;
    }
    while (v9);
  }
  unint64_t result = llvm::json::OStream::arrayEnd(v8);
  --*(_DWORD *)(a1 + 136);
  return result;
}

llvm::raw_ostream *sub_1CD0A51C0(uint64_t a1, char *a2, unint64_t a3, int *a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = (llvm::json::OStream *)(a1 + 128);
  llvm::json::OStream::attributeBegin(a1 + 128, a2, a3);
  llvm::json::OStream::arrayBegin(v8);
  if (a5)
  {
    uint64_t v9 = 4 * a5;
    do
    {
      uint64_t v10 = *a4++;
      unsigned __int16 v12 = 3;
      uint64_t v13 = v10;
      llvm::json::OStream::value((uint64_t)v8, &v12);
      llvm::json::Value::destroy((llvm::json::Value *)&v12);
      v9 -= 4;
    }
    while (v9);
  }
  unint64_t result = llvm::json::OStream::arrayEnd(v8);
  --*(_DWORD *)(a1 + 136);
  return result;
}

llvm::raw_ostream *sub_1CD0A5288(uint64_t a1, char *a2, unint64_t a3, __int16 *a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = (llvm::json::OStream *)(a1 + 128);
  llvm::json::OStream::attributeBegin(a1 + 128, a2, a3);
  llvm::json::OStream::arrayBegin(v8);
  if (a5)
  {
    uint64_t v9 = 2 * a5;
    do
    {
      uint64_t v10 = *a4++;
      unsigned __int16 v12 = 3;
      uint64_t v13 = v10;
      llvm::json::OStream::value((uint64_t)v8, &v12);
      llvm::json::Value::destroy((llvm::json::Value *)&v12);
      v9 -= 2;
    }
    while (v9);
  }
  unint64_t result = llvm::json::OStream::arrayEnd(v8);
  --*(_DWORD *)(a1 + 136);
  return result;
}

llvm::raw_ostream *sub_1CD0A5350(uint64_t a1, char *a2, unint64_t a3, char *a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = (llvm::json::OStream *)(a1 + 128);
  llvm::json::OStream::attributeBegin(a1 + 128, a2, a3);
  llvm::json::OStream::arrayBegin(v8);
  for (; a5; --a5)
  {
    uint64_t v9 = *a4++;
    unsigned __int16 v11 = 3;
    uint64_t v12 = v9;
    llvm::json::OStream::value((uint64_t)v8, &v11);
    llvm::json::Value::destroy((llvm::json::Value *)&v11);
  }
  unint64_t result = llvm::json::OStream::arrayEnd(v8);
  --*(_DWORD *)(a1 + 136);
  return result;
}

llvm::raw_ostream *sub_1CD0A5414(uint64_t a1, char *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  void v15[5] = *MEMORY[0x1E4F143B8];
  uint64_t v8 = (llvm::json::OStream *)(a1 + 128);
  llvm::json::OStream::attributeBegin(a1 + 128, a2, a3);
  llvm::json::OStream::arrayBegin(v8);
  if (a5)
  {
    uint64_t v10 = 16 * a5;
    do
    {
      unsigned __int16 v11 = (llvm::raw_ostream *)llvm::json::OStream::rawValueBegin(v8);
      BOOL v12 = *(unsigned char *)(a4 + 12) == 0;
      uint64_t v13 = v15;
      long long v14 = xmmword_1CDB15B30;
      llvm::APInt::toString((unsigned int *)a4, &v13, 0xAu, v12, 0);
      llvm::raw_ostream::write(v11, (const char *)v13, v14);
      if (v13 != v15) {
        free(v13);
      }
      --*(_DWORD *)(a1 + 136);
      a4 += 16;
      v10 -= 16;
    }
    while (v10);
  }
  unint64_t result = llvm::json::OStream::arrayEnd(v8);
  --*(_DWORD *)(a1 + 136);
  return result;
}

void sub_1CD0A5538(uint64_t a1, unsigned __int8 *a2, unint64_t a3)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1 + 128;
  sub_1CD452690((llvm::json::Value *)v4, a2, a3);
  llvm::json::OStream::value(v3, v4);
  llvm::json::Value::destroy((llvm::json::Value *)v4);
}

void sub_1CD0A55A8(uint64_t a1, char *a2, unint64_t a3, unsigned __int8 *a4, unint64_t a5)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = a1 + 128;
  sub_1CD452690((llvm::json::Value *)v9, a4, a5);
  llvm::json::OStream::attributeBegin(v8, a2, a3);
  llvm::json::OStream::value(v8, v9);
  --*(_DWORD *)(a1 + 136);
  llvm::json::Value::destroy((llvm::json::Value *)v9);
}

llvm::raw_ostream *sub_1CD0A5650(llvm::raw_ostream *a1)
{
  return sub_1CD0A5FD4(a1, 1);
}

llvm::raw_ostream *sub_1CD0A5658(uint64_t a1, char *a2, unint64_t a3)
{
  return sub_1CD0A6058(a1, a2, a3, 1u);
}

llvm::raw_ostream *sub_1CD0A5664(llvm::raw_ostream *a1)
{
  return sub_1CD0A5FD4(a1, 0);
}

llvm::raw_ostream *sub_1CD0A566C(uint64_t a1, char *a2, unint64_t a3)
{
  return sub_1CD0A6058(a1, a2, a3, 0);
}

llvm::raw_ostream *sub_1CD0A5678(uint64_t a1, char *a2, unint64_t a3, unsigned __int8 *a4, unint64_t a5, unsigned __int8 *a6, uint64_t a7, uint64_t a8, unsigned int a9)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  long long v14 = (llvm::json::OStream *)(a1 + 128);
  llvm::json::OStream::attributeBegin(a1 + 128, a2, a3);
  llvm::json::OStream::objectBegin(v14);
  if (a5)
  {
    sub_1CD452690((llvm::json::Value *)&v17, a4, a5);
    llvm::json::OStream::attributeBegin((uint64_t)v14, "Value", 5uLL);
    llvm::json::OStream::value((uint64_t)v14, &v17);
    --*(_DWORD *)(a1 + 136);
    llvm::json::Value::destroy((llvm::json::Value *)&v17);
  }
  unsigned __int16 v17 = 3;
  uint64_t v18 = a9;
  llvm::json::OStream::attributeBegin((uint64_t)v14, "Offset", 6uLL);
  llvm::json::OStream::value((uint64_t)v14, &v17);
  --*(_DWORD *)(a1 + 136);
  llvm::json::Value::destroy((llvm::json::Value *)&v17);
  llvm::json::OStream::attributeBegin((uint64_t)v14, "Bytes", 5uLL);
  llvm::json::OStream::arrayBegin(v14);
  for (; a7; --a7)
  {
    unsigned int v15 = *a6++;
    unsigned __int16 v17 = 3;
    uint64_t v18 = v15;
    llvm::json::OStream::value((uint64_t)v14, &v17);
    llvm::json::Value::destroy((llvm::json::Value *)&v17);
  }
  llvm::json::OStream::arrayEnd(v14);
  --*(_DWORD *)(a1 + 136);
  unint64_t result = llvm::json::OStream::objectEnd(v14);
  --*(_DWORD *)(a1 + 136);
  return result;
}

llvm::raw_ostream *sub_1CD0A5804(uint64_t a1, char *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = (llvm::json::OStream *)(a1 + 128);
  llvm::json::OStream::attributeBegin(a1 + 128, a2, a3);
  llvm::json::OStream::objectBegin(v10);
  unsigned __int16 v14 = 4;
  uint64_t v15 = a4;
  llvm::json::OStream::attributeBegin((uint64_t)v10, "RawFlags", 8uLL);
  llvm::json::OStream::value((uint64_t)v10, &v14);
  --*(_DWORD *)(a1 + 136);
  llvm::json::Value::destroy((llvm::json::Value *)&v14);
  llvm::json::OStream::attributeBegin((uint64_t)v10, "Flags", 5uLL);
  llvm::json::OStream::arrayBegin(v10);
  if (a6)
  {
    uint64_t v11 = a5 + 24 * a6;
    do
    {
      llvm::json::OStream::objectBegin(v10);
      sub_1CD452690((llvm::json::Value *)&v14, *(unsigned __int8 **)a5, *(void *)(a5 + 8));
      llvm::json::OStream::attributeBegin((uint64_t)v10, "Name", 4uLL);
      llvm::json::OStream::value((uint64_t)v10, &v14);
      --*(_DWORD *)(a1 + 136);
      llvm::json::Value::destroy((llvm::json::Value *)&v14);
      uint64_t v12 = *(void *)(a5 + 16);
      unsigned __int16 v14 = 4;
      uint64_t v15 = v12;
      llvm::json::OStream::attributeBegin((uint64_t)v10, "Value", 5uLL);
      llvm::json::OStream::value((uint64_t)v10, &v14);
      --*(_DWORD *)(a1 + 136);
      llvm::json::Value::destroy((llvm::json::Value *)&v14);
      llvm::json::OStream::objectEnd(v10);
      a5 += 24;
    }
    while (a5 != v11);
  }
  llvm::json::OStream::arrayEnd(v10);
  --*(_DWORD *)(a1 + 136);
  unint64_t result = llvm::json::OStream::objectEnd(v10);
  --*(_DWORD *)(a1 + 136);
  return result;
}

llvm::raw_ostream *sub_1CD0A59C4(uint64_t a1, char *a2, unint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = (llvm::json::OStream *)(a1 + 128);
  llvm::json::OStream::attributeBegin(a1 + 128, a2, a3);
  llvm::json::OStream::objectBegin(v10);
  unsigned __int16 v14 = 4;
  uint64_t v15 = a4;
  llvm::json::OStream::attributeBegin((uint64_t)v10, "RawFlags", 8uLL);
  llvm::json::OStream::value((uint64_t)v10, &v14);
  --*(_DWORD *)(a1 + 136);
  llvm::json::Value::destroy((llvm::json::Value *)&v14);
  llvm::json::OStream::attributeBegin((uint64_t)v10, "Flags", 5uLL);
  llvm::json::OStream::arrayBegin(v10);
  if (a6)
  {
    uint64_t v11 = 8 * a6;
    do
    {
      uint64_t v12 = *a5++;
      unsigned __int16 v14 = 4;
      uint64_t v15 = v12;
      llvm::json::OStream::value((uint64_t)v10, &v14);
      llvm::json::Value::destroy((llvm::json::Value *)&v14);
      v11 -= 8;
    }
    while (v11);
  }
  llvm::json::OStream::arrayEnd(v10);
  --*(_DWORD *)(a1 + 136);
  unint64_t result = llvm::json::OStream::objectEnd(v10);
  --*(_DWORD *)(a1 + 136);
  return result;
}

llvm::raw_ostream *sub_1CD0A5AFC(uint64_t a1, char *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = (llvm::json::OStream *)(a1 + 128);
  llvm::json::OStream::attributeBegin(a1 + 128, a2, a3);
  llvm::json::OStream::arrayBegin(v8);
  if (a5)
  {
    uint64_t v9 = 8 * a5;
    do
    {
      uint64_t v10 = *a4++;
      unsigned __int16 v12 = 4;
      uint64_t v13 = v10;
      llvm::json::OStream::value((uint64_t)v8, &v12);
      llvm::json::Value::destroy((llvm::json::Value *)&v12);
      v9 -= 8;
    }
    while (v9);
  }
  unint64_t result = llvm::json::OStream::arrayEnd(v8);
  --*(_DWORD *)(a1 + 136);
  return result;
}

void sub_1CD0A5BC4(uint64_t a1, char *a2, unint64_t a3, uint64_t a4)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a1 + 128;
  unsigned __int16 v6 = 4;
  uint64_t v7 = a4;
  llvm::json::OStream::attributeBegin(a1 + 128, a2, a3);
  llvm::json::OStream::value(v5, &v6);
  --*(_DWORD *)(a1 + 136);
  llvm::json::Value::destroy((llvm::json::Value *)&v6);
}

llvm::raw_ostream *sub_1CD0A5C50(uint64_t a1, char *a2, unint64_t a3, unsigned __int8 *a4, unint64_t a5, uint64_t a6)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = (llvm::json::OStream *)(a1 + 128);
  llvm::json::OStream::attributeBegin(a1 + 128, a2, a3);
  llvm::json::OStream::objectBegin(v10);
  sub_1CD452690((llvm::json::Value *)&v12, a4, a5);
  llvm::json::OStream::attributeBegin((uint64_t)v10, "Value", 5uLL);
  llvm::json::OStream::value((uint64_t)v10, &v12);
  --*(_DWORD *)(a1 + 136);
  llvm::json::Value::destroy((llvm::json::Value *)&v12);
  unsigned __int16 v12 = 4;
  uint64_t v13 = a6;
  llvm::json::OStream::attributeBegin((uint64_t)v10, "RawValue", 8uLL);
  llvm::json::OStream::value((uint64_t)v10, &v12);
  --*(_DWORD *)(a1 + 136);
  llvm::json::Value::destroy((llvm::json::Value *)&v12);
  unint64_t result = llvm::json::OStream::objectEnd(v10);
  --*(_DWORD *)(a1 + 136);
  return result;
}

llvm::raw_ostream *sub_1CD0A5D6C(uint64_t a1, char *a2, unint64_t a3, unsigned __int8 *a4, unint64_t a5, uint64_t a6)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = (llvm::json::OStream *)(a1 + 128);
  llvm::json::OStream::attributeBegin(a1 + 128, a2, a3);
  llvm::json::OStream::objectBegin(v10);
  sub_1CD452690((llvm::json::Value *)&v12, a4, a5);
  llvm::json::OStream::attributeBegin((uint64_t)v10, "SymName", 7uLL);
  llvm::json::OStream::value((uint64_t)v10, &v12);
  --*(_DWORD *)(a1 + 136);
  llvm::json::Value::destroy((llvm::json::Value *)&v12);
  unsigned __int16 v12 = 4;
  uint64_t v13 = a6;
  llvm::json::OStream::attributeBegin((uint64_t)v10, "Offset", 6uLL);
  llvm::json::OStream::value((uint64_t)v10, &v12);
  --*(_DWORD *)(a1 + 136);
  llvm::json::Value::destroy((llvm::json::Value *)&v12);
  unint64_t result = llvm::json::OStream::objectEnd(v10);
  --*(_DWORD *)(a1 + 136);
  return result;
}

llvm::raw_ostream *sub_1CD0A5E88(uint64_t a1, char *a2, unint64_t a3, unsigned __int8 *a4, unint64_t a5, const void *a6, size_t a7)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  unsigned __int16 v12 = (llvm::json::OStream *)(a1 + 128);
  llvm::json::OStream::attributeBegin(a1 + 128, a2, a3);
  llvm::json::OStream::objectBegin(v12);
  sub_1CD452690((llvm::json::Value *)v16, a4, a5);
  llvm::json::OStream::attributeBegin((uint64_t)v12, "Value", 5uLL);
  llvm::json::OStream::value((uint64_t)v12, v16);
  --*(_DWORD *)(a1 + 136);
  llvm::json::Value::destroy((llvm::json::Value *)v16);
  llvm::json::OStream::attributeBegin((uint64_t)v12, "RawValue", 8uLL);
  uint64_t v13 = (llvm::raw_ostream *)llvm::json::OStream::rawValueBegin(v12);
  uint64_t v14 = (void *)*((void *)v13 + 4);
  if (a7 <= *((void *)v13 + 3) - (void)v14)
  {
    if (a7)
    {
      memcpy(v14, a6, a7);
      *((void *)v13 + 4) += a7;
    }
  }
  else
  {
    llvm::raw_ostream::write(v13, (const char *)a6, a7);
  }
  *(_DWORD *)(a1 + 136) -= 2;
  unint64_t result = llvm::json::OStream::objectEnd(v12);
  --*(_DWORD *)(a1 + 136);
  return result;
}

llvm::raw_ostream *sub_1CD0A5FD4(llvm::raw_ostream *result, uint64_t a2)
{
  uint64_t v3 = result;
  if (a2)
  {
    if (a2 == 1) {
      unint64_t result = llvm::json::OStream::objectBegin((llvm::raw_ostream *)((char *)result + 128));
    }
  }
  else
  {
    unint64_t result = llvm::json::OStream::arrayBegin((llvm::raw_ostream *)((char *)result + 128));
  }
  unsigned int v4 = *((_DWORD *)v3 + 14);
  if (v4 >= *((_DWORD *)v3 + 15)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*((void *)v3 + 6) + 8 * v4) = a2;
  ++*((_DWORD *)v3 + 14);
  return result;
}

llvm::raw_ostream *sub_1CD0A6058(uint64_t a1, char *a2, unint64_t a3, unsigned int a4)
{
  uint64_t v8 = *(unsigned int *)(a1 + 56);
  if (v8 && *(_DWORD *)(*(void *)(a1 + 48) + 8 * v8 - 8) == 1)
  {
    uint64_t v9 = 0x100000000;
  }
  else
  {
    llvm::json::OStream::objectBegin((llvm::json::OStream *)(a1 + 128));
    uint64_t v9 = 0x200000000;
  }
  llvm::json::OStream::attributeBegin(a1 + 128, a2, a3);

  return sub_1CD0A5FD4((llvm::raw_ostream *)a1, v9 | a4);
}

llvm::raw_ostream *sub_1CD0A60F0(llvm::raw_ostream *result)
{
  uint64_t v1 = result;
  uint64_t v2 = *((void *)result + 6) + 8 * *((unsigned int *)result + 14);
  int v3 = *(_DWORD *)(v2 - 8);
  int v4 = *(_DWORD *)(v2 - 4);
  if (v3)
  {
    if (v3 == 1) {
      unint64_t result = llvm::json::OStream::objectEnd((llvm::raw_ostream *)((char *)result + 128));
    }
  }
  else
  {
    unint64_t result = llvm::json::OStream::arrayEnd((llvm::raw_ostream *)((char *)result + 128));
  }
  if ((v4 - 1) <= 1)
  {
    --*((_DWORD *)v1 + 34);
    if (v4 == 2) {
      unint64_t result = llvm::json::OStream::objectEnd((llvm::raw_ostream *)((char *)v1 + 128));
    }
  }
  --*((_DWORD *)v1 + 14);
  return result;
}

_DWORD *llvm::SHA1::hashBlock(_DWORD *this)
{
  HIDWORD(v2) = this[16];
  LODWORD(v2) = HIDWORD(v2);
  int v1 = v2 >> 27;
  HIDWORD(v2) = this[17];
  LODWORD(v2) = HIDWORD(v2);
  int v3 = v2 >> 2;
  int v4 = this[18];
  int v475 = HIDWORD(v2);
  int v476 = this[20];
  int v473 = this[16];
  int v474 = this[19];
  int v5 = v473 & __ROR4__(HIDWORD(v2), 2);
  int v6 = this[1];
  int v7 = v1 + v476 + *this + (v4 & HIDWORD(v2) | v474 & ~HIDWORD(v2)) + 1518500249;
  HIDWORD(v2) = v7;
  LODWORD(v2) = v7;
  int v8 = v2 >> 27;
  HIDWORD(v2) = v473;
  LODWORD(v2) = v473;
  int v9 = v2 >> 2;
  int v472 = v4;
  int v10 = v474 + v6 + (v5 | v4 & ~v473) + 1518500249 + v8;
  HIDWORD(v2) = v10;
  LODWORD(v2) = v10;
  int v11 = v2 >> 27;
  HIDWORD(v2) = v7;
  LODWORD(v2) = v7;
  int v12 = v2 >> 2;
  int v13 = v7 & __ROR4__(v473, 2) | v3 & ~v7;
  int v14 = v10 & __ROR4__(v7, 2);
  int v16 = this[2];
  int v15 = this[3];
  int v17 = v4 + v16 + v13 + 1518500249 + v11;
  HIDWORD(v2) = v17;
  LODWORD(v2) = v17;
  int v18 = v2 >> 27;
  HIDWORD(v2) = v10;
  LODWORD(v2) = v10;
  int v19 = v2 >> 2;
  int v20 = v3 + v15 + (v14 | v9 & ~v10) + 1518500249 + v18;
  HIDWORD(v2) = v20;
  LODWORD(v2) = v20;
  int v21 = v2 >> 27;
  HIDWORD(v2) = v17;
  LODWORD(v2) = v17;
  int v22 = v2 >> 2;
  int v23 = this[4];
  int v24 = v9 + v23 + (v17 & __ROR4__(v10, 2) | v12 & ~v17) + 1518500249 + v21;
  HIDWORD(v2) = v24;
  LODWORD(v2) = v24;
  int v25 = v2 >> 27;
  HIDWORD(v2) = v20;
  LODWORD(v2) = v20;
  int v26 = v2 >> 2;
  int v27 = v12 + this[5] + (v20 & __ROR4__(v17, 2) | v19 & ~v20) + 1518500249 + v25;
  HIDWORD(v2) = v27;
  LODWORD(v2) = v27;
  int v28 = v2 >> 27;
  HIDWORD(v2) = v24;
  LODWORD(v2) = v24;
  int v29 = v2 >> 2;
  int v461 = this[6];
  int v465 = this[7];
  int v30 = v19 + v461 + (v24 & __ROR4__(v20, 2) | v22 & ~v24) + 1518500249 + v28;
  HIDWORD(v2) = v30;
  LODWORD(v2) = v30;
  int v31 = v2 >> 27;
  HIDWORD(v2) = v27;
  LODWORD(v2) = v27;
  int v32 = v2 >> 2;
  int v33 = v465 + v22 + (v27 & __ROR4__(v24, 2) | v26 & ~v27) + 1518500249 + v31;
  HIDWORD(v2) = v33;
  LODWORD(v2) = v33;
  int v34 = v2 >> 27;
  HIDWORD(v2) = v30;
  LODWORD(v2) = v30;
  int v35 = v2 >> 2;
  int v36 = this[8];
  int v37 = this[9];
  int v38 = v36 + v26 + (v30 & __ROR4__(v27, 2) | v29 & ~v30) + 1518500249 + v34;
  HIDWORD(v2) = v38;
  LODWORD(v2) = v38;
  int v39 = v2 >> 27;
  HIDWORD(v2) = v33;
  LODWORD(v2) = v33;
  int v40 = v2 >> 2;
  int v41 = v37 + v29 + (v33 & __ROR4__(v30, 2) | v32 & ~v33) + 1518500249 + v39;
  HIDWORD(v2) = v41;
  LODWORD(v2) = v41;
  int v42 = v2 >> 27;
  HIDWORD(v2) = v38;
  LODWORD(v2) = v38;
  int v43 = v2 >> 2;
  int v44 = this[10];
  int v45 = v44 + v32 + (v38 & __ROR4__(v33, 2) | v35 & ~v38) + 1518500249 + v42;
  HIDWORD(v2) = v45;
  LODWORD(v2) = v45;
  int v46 = v2 >> 27;
  HIDWORD(v2) = v41;
  LODWORD(v2) = v41;
  int v47 = v2 >> 2;
  int v457 = this[11];
  int v48 = v457 + v35 + (v41 & __ROR4__(v38, 2) | v40 & ~v41) + 1518500249 + v46;
  HIDWORD(v2) = v48;
  LODWORD(v2) = v48;
  int v49 = v2 >> 27;
  HIDWORD(v2) = v45;
  LODWORD(v2) = v45;
  int v50 = v2 >> 2;
  int v51 = this[12];
  int v52 = this[13];
  int v53 = v51 + v40 + (v45 & __ROR4__(v41, 2) | v43 & ~v45) + 1518500249 + v49;
  HIDWORD(v2) = v53;
  LODWORD(v2) = v53;
  int v54 = v2 >> 27;
  HIDWORD(v2) = v48;
  LODWORD(v2) = v48;
  int v55 = v2 >> 2;
  int v56 = v52 + v43 + (v48 & __ROR4__(v45, 2) | v47 & ~v48) + 1518500249 + v54;
  HIDWORD(v2) = v56;
  LODWORD(v2) = v56;
  int v57 = v2 >> 27;
  HIDWORD(v2) = v53;
  LODWORD(v2) = v53;
  int v58 = v2 >> 2;
  int v60 = this[14];
  int v59 = this[15];
  int v61 = v60 + v47 + (v53 & __ROR4__(v48, 2) | v50 & ~v53) + 1518500249 + v57;
  HIDWORD(v2) = v61;
  LODWORD(v2) = v61;
  int v62 = v2 >> 27;
  HIDWORD(v2) = v56;
  LODWORD(v2) = v56;
  int v63 = v2 >> 2;
  int v64 = v59 + v50 + (v56 & __ROR4__(v53, 2) | v55 & ~v56);
  int v65 = v16 ^ *this ^ v36 ^ v52;
  HIDWORD(v2) = v65;
  LODWORD(v2) = v65;
  int v66 = v2 >> 31;
  int v67 = v64 + 1518500249 + v62;
  int v68 = v61 & __ROR4__(v56, 2) | v58 & ~v61;
  HIDWORD(v2) = v67;
  LODWORD(v2) = v67;
  int v69 = v2 >> 27;
  int v70 = v66 + v55;
  HIDWORD(v2) = v61;
  LODWORD(v2) = v61;
  int v71 = v2 >> 2;
  int v72 = v70 + v68;
  int v73 = v15 ^ v6 ^ v37 ^ v60;
  HIDWORD(v2) = v73;
  LODWORD(v2) = v73;
  int v74 = v2 >> 31;
  int v75 = v72 + 1518500249 + v69;
  HIDWORD(v2) = v75;
  LODWORD(v2) = v75;
  int v76 = v2 >> 27;
  int v77 = v74 + v58;
  HIDWORD(v2) = v67;
  LODWORD(v2) = v67;
  int v78 = v2 >> 2;
  HIDWORD(v2) = v23 ^ v16 ^ v44 ^ v59;
  LODWORD(v2) = HIDWORD(v2);
  int v448 = v2 >> 31;
  int v79 = HIDWORD(v2);
  int v80 = v77 + (v67 & __ROR4__(v61, 2) | v63 & ~v67) + 1518500249 + v76;
  HIDWORD(v2) = v80;
  LODWORD(v2) = v80;
  int v81 = this[5];
  int v83 = v448 + v63 + (v75 & __ROR4__(v67, 2) | v71 & ~v75) + 1518500249 + (v2 >> 27);
  LODWORD(v2) = v81 ^ v15 ^ v457 ^ __ROR4__(v65, 31);
  int v82 = v2;
  HIDWORD(v2) = v2;
  int v445 = v2 >> 31;
  int v84 = v445 + v71 + (v80 & __ROR4__(v75, 2) | v78 & ~v80);
  HIDWORD(v2) = v83;
  LODWORD(v2) = v83;
  int v85 = v2 >> 27;
  HIDWORD(v2) = v80;
  LODWORD(v2) = v80;
  int v86 = v2 >> 2;
  int v87 = v84 + 1518500249 + v85;
  int v88 = v461 ^ v23 ^ v51 ^ __ROR4__(v73, 31);
  HIDWORD(v2) = v88;
  LODWORD(v2) = v88;
  int v469 = v2 >> 31;
  int v89 = v469 + v78 + (v86 ^ __ROR4__(v75, 2) ^ v83);
  HIDWORD(v2) = v75;
  LODWORD(v2) = v75;
  int v90 = v2 >> 2;
  int v91 = v89 + 1859775393;
  HIDWORD(v2) = v87;
  LODWORD(v2) = v87;
  int v92 = v2 >> 27;
  HIDWORD(v2) = v83;
  LODWORD(v2) = v83;
  int v93 = v2 >> 2;
  int v94 = v91 + v92;
  int v96 = v79;
  LODWORD(v2) = v465 ^ v81 ^ v52 ^ __ROR4__(v79, 31);
  int v95 = v2;
  HIDWORD(v2) = v2;
  int v442 = v2 >> 31;
  HIDWORD(v2) = v94;
  LODWORD(v2) = v94;
  int v97 = v442 + v90 + (v93 ^ __ROR4__(v80, 2) ^ v87) + 1859775393 + (v2 >> 27);
  HIDWORD(v2) = v87;
  LODWORD(v2) = v87;
  int v98 = v2 >> 2;
  int v99 = v98 ^ __ROR4__(v83, 2);
  LODWORD(v2) = v36 ^ v461 ^ v60 ^ __ROR4__(v82, 31);
  int v100 = v2;
  HIDWORD(v2) = v2;
  int v434 = v2 >> 31;
  HIDWORD(v2) = v97;
  LODWORD(v2) = v97;
  int v101 = v2 >> 27;
  HIDWORD(v2) = v94;
  LODWORD(v2) = v94;
  int v102 = v2 >> 2;
  int v103 = v434 + v86 + (v99 ^ v94) + 1859775393 + v101;
  LODWORD(v2) = v37 ^ v465 ^ v59 ^ __ROR4__(v88, 31);
  int v104 = v2;
  HIDWORD(v2) = v2;
  int v429 = v2 >> 31;
  HIDWORD(v2) = v103;
  LODWORD(v2) = v103;
  int v105 = v429 + v93 + (v102 ^ __ROR4__(v87, 2) ^ v97) + 1859775393 + (v2 >> 27);
  HIDWORD(v2) = v97;
  LODWORD(v2) = v97;
  int v106 = v2 >> 2;
  LODWORD(v2) = v44 ^ v36 ^ __ROR4__(v65, 31) ^ __ROR4__(v95, 31);
  int v107 = v2;
  HIDWORD(v2) = v2;
  int v108 = v2 >> 31;
  int v109 = v108 + v98 + (v106 ^ __ROR4__(v94, 2) ^ v103) + 1859775393;
  HIDWORD(v2) = v105;
  LODWORD(v2) = v105;
  int v110 = v2 >> 27;
  HIDWORD(v2) = v103;
  LODWORD(v2) = v103;
  int v111 = v2 >> 2;
  int v112 = v109 + v110;
  LODWORD(v2) = v457 ^ v37 ^ __ROR4__(v73, 31) ^ __ROR4__(v100, 31);
  int v113 = v2;
  HIDWORD(v2) = v2;
  int v431 = v2 >> 31;
  HIDWORD(v2) = v112;
  LODWORD(v2) = v112;
  int v114 = v431 + v102 + (v111 ^ __ROR4__(v97, 2) ^ v105) + 1859775393 + (v2 >> 27);
  HIDWORD(v2) = v105;
  LODWORD(v2) = v105;
  int v115 = v2 >> 2;
  int v116 = v96;
  LODWORD(v2) = v51 ^ v44 ^ __ROR4__(v96, 31) ^ __ROR4__(v104, 31);
  int v117 = v2;
  HIDWORD(v2) = v2;
  int v466 = v2 >> 31;
  int v118 = v466 + v106 + (v115 ^ __ROR4__(v103, 2) ^ v112) + 1859775393;
  HIDWORD(v2) = v114;
  LODWORD(v2) = v114;
  int v119 = v2 >> 27;
  HIDWORD(v2) = v112;
  LODWORD(v2) = v112;
  int v120 = v2 >> 2;
  int v121 = v118 + v119;
  LODWORD(v2) = v52 ^ v457 ^ __ROR4__(v82, 31) ^ __ROR4__(v107, 31);
  int v122 = v2;
  HIDWORD(v2) = v2;
  int v462 = v2 >> 31;
  HIDWORD(v2) = v121;
  LODWORD(v2) = v121;
  int v123 = v462 + v111 + (v120 ^ __ROR4__(v105, 2) ^ v114) + 1859775393 + (v2 >> 27);
  HIDWORD(v2) = v114;
  LODWORD(v2) = v114;
  int v124 = v2 >> 2;
  int v125 = v60 ^ v51 ^ __ROR4__(v88, 31) ^ __ROR4__(v113, 31);
  HIDWORD(v2) = v125;
  LODWORD(v2) = v125;
  int v436 = v2 >> 31;
  HIDWORD(v2) = v123;
  LODWORD(v2) = v123;
  int v126 = v2 >> 27;
  HIDWORD(v2) = v121;
  LODWORD(v2) = v121;
  int v127 = v2 >> 2;
  int v128 = v436 + v115 + (v124 ^ __ROR4__(v112, 2) ^ v121) + 1859775393 + v126;
  int v129 = v59 ^ v52 ^ __ROR4__(v95, 31) ^ __ROR4__(v117, 31);
  HIDWORD(v2) = v129;
  LODWORD(v2) = v129;
  int v130 = v2 >> 31;
  HIDWORD(v2) = v128;
  LODWORD(v2) = v128;
  unsigned int v131 = v130 + v120 + (v127 ^ __ROR4__(v114, 2) ^ v123) + 1859775393 + (v2 >> 27);
  HIDWORD(v2) = v123;
  LODWORD(v2) = v123;
  int v132 = v2 >> 2;
  LODWORD(v2) = v60 ^ __ROR4__(v65, 31) ^ __ROR4__(v100, 31) ^ __ROR4__(v122, 31);
  int v133 = v2;
  HIDWORD(v2) = v2;
  int v454 = v2 >> 31;
  int v458 = v130;
  int v134 = v454 + v124 + (v132 ^ __ROR4__(v121, 2) ^ v128) + 1859775393;
  HIDWORD(v2) = v131;
  LODWORD(v2) = v131;
  int v135 = v2 >> 27;
  HIDWORD(v2) = v128;
  LODWORD(v2) = v128;
  int v136 = v2 >> 2;
  unsigned int v137 = v134 + v135;
  LODWORD(v2) = v59 ^ __ROR4__(v73, 31) ^ __ROR4__(v104, 31) ^ __ROR4__(v125, 31);
  int v138 = v2;
  HIDWORD(v2) = v2;
  int v451 = v2 >> 31;
  HIDWORD(v2) = v137;
  LODWORD(v2) = v137;
  unsigned int v139 = v451 + v127 + (v136 ^ __ROR4__(v123, 2) ^ v131) + 1859775393 + (v2 >> 27);
  unint64_t v141 = __PAIR64__(v131, __ROR4__(v65, 31));
  int v140 = v448 ^ v141;
  LODWORD(v141) = v131;
  int v142 = v141 >> 2;
  LODWORD(v141) = v140 ^ __ROR4__(v107, 31) ^ __ROR4__(v129, 31);
  int v143 = v141;
  HIDWORD(v141) = v141;
  int v449 = v141 >> 31;
  HIDWORD(v141) = v139;
  LODWORD(v141) = v139;
  unsigned int v144 = v449 + v132 + (v142 ^ __ROR4__(v128, 2) ^ v137) + 1859775393 + (v141 >> 27);
  unint64_t v146 = __PAIR64__(v137, __ROR4__(v73, 31));
  int v145 = v445 ^ v146;
  LODWORD(v146) = v137;
  int v147 = v146 >> 2;
  int v148 = v145 ^ __ROR4__(v113, 31) ^ __ROR4__(v133, 31);
  HIDWORD(v146) = v148;
  LODWORD(v146) = v148;
  int v446 = v146 >> 31;
  HIDWORD(v146) = v144;
  LODWORD(v146) = v144;
  unsigned int v149 = v446 + v136 + (v147 ^ __ROR4__(v131, 2) ^ v139) + 1859775393 + (v146 >> 27);
  unint64_t v151 = __PAIR64__(v139, __ROR4__(v116, 31));
  int v150 = v469 ^ v151;
  LODWORD(v151) = v139;
  int v152 = v151 >> 2;
  int v153 = v150 ^ __ROR4__(v117, 31) ^ __ROR4__(v138, 31);
  HIDWORD(v151) = v153;
  LODWORD(v151) = v153;
  int v440 = v151 >> 31;
  HIDWORD(v151) = v149;
  LODWORD(v151) = v149;
  unsigned int v154 = v440 + v142 + (v152 ^ __ROR4__(v137, 2) ^ v144) + 1859775393 + (v151 >> 27);
  unint64_t v156 = __PAIR64__(v144, __ROR4__(v82, 31));
  int v155 = v442 ^ v156;
  LODWORD(v156) = v144;
  int v157 = v156 >> 2;
  int v158 = v155 ^ __ROR4__(v122, 31) ^ __ROR4__(v143, 31);
  HIDWORD(v156) = v158;
  LODWORD(v156) = v158;
  int v438 = v156 >> 31;
  HIDWORD(v156) = v154;
  LODWORD(v156) = v154;
  unsigned int v159 = v438 + v147 + (v157 ^ __ROR4__(v139, 2) ^ v149) + 1859775393 + (v156 >> 27);
  unint64_t v161 = __PAIR64__(v149, __ROR4__(v88, 31));
  int v160 = v434 ^ v161;
  LODWORD(v161) = v149;
  int v162 = v161 >> 2;
  LODWORD(v161) = v160 ^ __ROR4__(v125, 31) ^ __ROR4__(v148, 31);
  int v163 = v161;
  HIDWORD(v161) = v161;
  int v443 = v161 >> 31;
  HIDWORD(v161) = v159;
  LODWORD(v161) = v159;
  unsigned int v164 = v443 + v152 + (v162 ^ __ROR4__(v144, 2) ^ v154) + 1859775393 + (v161 >> 27);
  unint64_t v166 = __PAIR64__(v154, __ROR4__(v95, 31));
  int v165 = v429 ^ v166;
  LODWORD(v166) = v154;
  int v167 = v166 >> 2;
  LODWORD(v166) = v165 ^ __ROR4__(v129, 31) ^ __ROR4__(v153, 31);
  int v168 = v166;
  HIDWORD(v166) = v166;
  int v169 = v166 >> 31;
  HIDWORD(v166) = v164;
  LODWORD(v166) = v164;
  unsigned int v170 = v169 + v157 + (v167 ^ __ROR4__(v149, 2) ^ v159) + 1859775393 + (v166 >> 27);
  unint64_t v172 = __PAIR64__(v159, __ROR4__(v100, 31));
  int v171 = v108 ^ v172;
  LODWORD(v172) = v159;
  int v173 = v172 >> 2;
  LODWORD(v172) = v171 ^ __ROR4__(v133, 31) ^ __ROR4__(v158, 31);
  int v174 = v172;
  HIDWORD(v172) = v172;
  int v175 = v172 >> 31;
  HIDWORD(v172) = v170;
  LODWORD(v172) = v170;
  unsigned int v176 = v175 + v162 + (v173 ^ __ROR4__(v154, 2) ^ v164) + 1859775393 + (v172 >> 27);
  unint64_t v178 = __PAIR64__(v164, __ROR4__(v104, 31));
  int v177 = v431 ^ v178;
  LODWORD(v17--*(_DWORD *)(this + 8) = v164;
  int v179 = v178 >> 2;
  int v180 = v177 ^ __ROR4__(v138, 31) ^ __ROR4__(v163, 31);
  HIDWORD(v17--*(_DWORD *)(this + 8) = v180;
  LODWORD(v17--*(_DWORD *)(this + 8) = v180;
  int v470 = v178 >> 31;
  HIDWORD(v17--*(_DWORD *)(this + 8) = v176;
  LODWORD(v17--*(_DWORD *)(this + 8) = v176;
  unsigned int v181 = v470 + v167 + (v179 ^ __ROR4__(v159, 2) ^ v170) + 1859775393 + (v178 >> 27);
  LODWORD(v17--*(_DWORD *)(this + 8) = v466 ^ __ROR4__(v107, 31) ^ __ROR4__(v143, 31) ^ __ROR4__(v168, 31);
  int v182 = v178;
  HIDWORD(v17--*(_DWORD *)(this + 8) = v178;
  int v467 = v178 >> 31;
  HIDWORD(v17--*(_DWORD *)(this + 8) = v181;
  LODWORD(v17--*(_DWORD *)(this + 8) = v181;
  unsigned int v183 = v467
       + v173
       + ((v176 | __ROR4__(v170, 2)) & __ROR4__(v164, 2) | v176 & __ROR4__(v170, 2))
       + (v178 >> 27)
       - 1894007588;
  int v184 = v462 ^ __ROR4__(v113, 31) ^ __ROR4__(v148, 31) ^ __ROR4__(v174, 31);
  HIDWORD(v17--*(_DWORD *)(this + 8) = v184;
  LODWORD(v17--*(_DWORD *)(this + 8) = v184;
  int v463 = v178 >> 31;
  HIDWORD(v17--*(_DWORD *)(this + 8) = v183;
  LODWORD(v17--*(_DWORD *)(this + 8) = v183;
  unsigned int v185 = v463 + v179 + ((v181 | __ROR4__(v176, 2)) & __ROR4__(v170, 2) | v181 & __ROR4__(v176, 2)) + (v178 >> 27);
  unint64_t v187 = __PAIR64__(v170, __ROR4__(v117, 31));
  int v186 = v436 ^ v187;
  LODWORD(v187) = v170;
  int v188 = v187 >> 2;
  int v189 = v186 ^ __ROR4__(v153, 31) ^ __ROR4__(v180, 31);
  int v190 = v180;
  unint64_t v192 = __PAIR64__(v189, __ROR4__(v181, 2));
  int v191 = v183 & v192;
  LODWORD(v192) = v189;
  int v432 = v192 >> 31;
  v185 -= 1894007588;
  HIDWORD(v192) = v185;
  LODWORD(v192) = v185;
  unsigned int v193 = v432 + v188 + ((v183 | __ROR4__(v181, 2)) & __ROR4__(v176, 2) | v191) + (v192 >> 27);
  unint64_t v195 = __PAIR64__(v176, __ROR4__(v122, 31));
  int v194 = v458 ^ v195;
  LODWORD(v195) = v176;
  int v196 = v195 >> 2;
  int v197 = v194 ^ __ROR4__(v158, 31) ^ __ROR4__(v182, 31);
  HIDWORD(v195) = v197;
  LODWORD(v195) = v197;
  int v459 = v195 >> 31;
  v193 -= 1894007588;
  HIDWORD(v195) = v193;
  LODWORD(v195) = v193;
  unsigned int v198 = v459 + v196 + ((v185 | __ROR4__(v183, 2)) & __ROR4__(v181, 2) | v185 & __ROR4__(v183, 2)) + (v195 >> 27);
  unint64_t v199 = __PAIR64__(v181, __ROR4__(v185, 2));
  int v200 = (v193 | __ROR4__(v185, 2)) & __ROR4__(v183, 2) | v193 & v199;
  LODWORD(v199) = v181;
  int v201 = v199 >> 2;
  int v202 = v454 ^ __ROR4__(v125, 31) ^ __ROR4__(v163, 31) ^ __ROR4__(v184, 31);
  HIDWORD(v199) = v202;
  LODWORD(v199) = v202;
  int v455 = v199 >> 31;
  v198 -= 1894007588;
  HIDWORD(v199) = v198;
  LODWORD(v199) = v198;
  int v203 = v455 + v201 + v200 + (v199 >> 27);
  unint64_t v205 = __PAIR64__(v183, __ROR4__(v129, 31));
  int v204 = v451 ^ v205;
  LODWORD(v205) = v183;
  int v206 = v205 >> 2;
  LODWORD(v205) = v204 ^ __ROR4__(v168, 31) ^ __ROR4__(v189, 31);
  HIDWORD(v205) = v205;
  int v452 = v205 >> 31;
  int v207 = v205;
  int v208 = v452 + v206 + ((v198 | __ROR4__(v193, 2)) & __ROR4__(v185, 2) | v198 & __ROR4__(v193, 2));
  unsigned int v209 = v203 - 1894007588;
  HIDWORD(v205) = v203 - 1894007588;
  LODWORD(v205) = v203 - 1894007588;
  int v210 = v208 + (v205 >> 27);
  unint64_t v212 = __PAIR64__(v185, __ROR4__(v133, 31));
  int v211 = v449 ^ v212;
  LODWORD(v212) = v185;
  int v213 = v212 >> 2;
  int v215 = v197;
  int v426 = v197;
  LODWORD(v212) = v211 ^ __ROR4__(v174, 31) ^ __ROR4__(v197, 31);
  int v214 = v212;
  HIDWORD(v212) = v212;
  int v450 = v212 >> 31;
  unsigned int v216 = v210 - 1894007588;
  HIDWORD(v212) = v210 - 1894007588;
  LODWORD(v212) = v210 - 1894007588;
  unsigned int v217 = v450 + v213 + ((v209 | __ROR4__(v198, 2)) & __ROR4__(v193, 2) | v209 & __ROR4__(v198, 2)) + (v212 >> 27);
  unint64_t v219 = __PAIR64__(v193, __ROR4__(v138, 31));
  int v218 = v446 ^ v219;
  LODWORD(v219) = v193;
  int v220 = v219 >> 2;
  v217 -= 1894007588;
  LODWORD(v219) = v218 ^ __ROR4__(v190, 31) ^ __ROR4__(v202, 31);
  int v221 = v219;
  HIDWORD(v219) = v219;
  int v447 = v219 >> 31;
  HIDWORD(v219) = v217;
  LODWORD(v219) = v217;
  int v222 = v447
       + v220
       + (((v210 - 1894007588) | __ROR4__(v209, 2)) & __ROR4__(v198, 2) | (v210 - 1894007588) & __ROR4__(v209, 2))
       + (v219 >> 27);
  unint64_t v224 = __PAIR64__(v198, __ROR4__(v143, 31));
  int v223 = v440 ^ v224;
  LODWORD(v224) = v198;
  int v225 = v224 >> 2;
  int v226 = (v217 | __ROR4__(v210 - 1894007588, 2)) & __ROR4__(v209, 2);
  int v227 = v223 ^ __ROR4__(v182, 31);
  LODWORD(v224) = __ROR4__(v207, 31);
  int v228 = v227 ^ v224;
  int v229 = v207;
  unint64_t v231 = __PAIR64__(v227 ^ v224, __ROR4__(v216, 2));
  int v230 = v217 & v231;
  LODWORD(v231) = v228;
  int v441 = v231 >> 31;
  unsigned int v232 = v222 - 1894007588;
  HIDWORD(v231) = v222 - 1894007588;
  LODWORD(v231) = v222 - 1894007588;
  unsigned int v233 = v441 + v225 + (v226 | v230) + (v231 >> 27);
  unint64_t v235 = __PAIR64__(v209, __ROR4__(v148, 31));
  int v234 = v438 ^ v235;
  LODWORD(v235) = v209;
  int v236 = v235 >> 2;
  LODWORD(v235) = v234 ^ __ROR4__(v184, 31) ^ __ROR4__(v214, 31);
  int v237 = v235;
  HIDWORD(v235) = v235;
  int v439 = v235 >> 31;
  v233 -= 1894007588;
  HIDWORD(v235) = v233;
  LODWORD(v235) = v233;
  unsigned int v238 = v439
       + v236
       + (((v222 - 1894007588) | __ROR4__(v217, 2)) & __ROR4__(v216, 2) | (v222 - 1894007588) & __ROR4__(v217, 2))
       + (v235 >> 27);
  unint64_t v239 = __PAIR64__(v216, __ROR4__(v222 - 1894007588, 2));
  int v240 = (v233 | __ROR4__(v222 - 1894007588, 2)) & __ROR4__(v217, 2) | v233 & v239;
  LODWORD(v239) = v216;
  int v241 = v239 >> 2;
  int v243 = v221;
  LODWORD(v239) = v443 ^ __ROR4__(v153, 31) ^ __ROR4__(v189, 31) ^ __ROR4__(v221, 31);
  int v242 = v239;
  HIDWORD(v239) = v239;
  int v444 = v239 >> 31;
  v238 -= 1894007588;
  HIDWORD(v239) = v238;
  LODWORD(v239) = v238;
  unsigned int v244 = v444 + v241 + v240 + (v239 >> 27);
  unint64_t v246 = __PAIR64__(v217, __ROR4__(v158, 31));
  int v245 = v169 ^ v246;
  LODWORD(v246) = v217;
  int v247 = v246 >> 2;
  LODWORD(v246) = v245 ^ __ROR4__(v215, 31) ^ __ROR4__(v228, 31);
  int v248 = v246;
  HIDWORD(v246) = v246;
  int v437 = v246 >> 31;
  v244 -= 1894007588;
  HIDWORD(v246) = v244;
  LODWORD(v246) = v244;
  unsigned int v249 = v437 + v247 + ((v238 | __ROR4__(v233, 2)) & __ROR4__(v232, 2) | v238 & __ROR4__(v233, 2)) + (v246 >> 27);
  unint64_t v251 = __PAIR64__(v232, __ROR4__(v163, 31));
  int v250 = v175 ^ v251;
  LODWORD(v251) = v232;
  int v252 = v251 >> 2;
  int v253 = v250 ^ __ROR4__(v202, 31) ^ __ROR4__(v237, 31);
  HIDWORD(v251) = v253;
  LODWORD(v251) = v253;
  int v435 = v251 >> 31;
  v249 -= 1894007588;
  HIDWORD(v251) = v249;
  LODWORD(v251) = v249;
  int v254 = v435 + v252 + ((v244 | __ROR4__(v238, 2)) & __ROR4__(v233, 2) | v244 & __ROR4__(v238, 2)) + (v251 >> 27);
  unint64_t v256 = __PAIR64__(v233, __ROR4__(v168, 31));
  int v255 = v470 ^ v256;
  LODWORD(v256) = v233;
  int v257 = v256 >> 2;
  unsigned int v258 = v254 - 1894007588;
  int v259 = v229;
  LODWORD(v256) = v255 ^ __ROR4__(v229, 31) ^ __ROR4__(v242, 31);
  int v260 = v256;
  HIDWORD(v256) = v256;
  int v471 = v256 >> 31;
  HIDWORD(v256) = v254 - 1894007588;
  LODWORD(v256) = v254 - 1894007588;
  int v261 = v471 + v257 + ((v249 | __ROR4__(v244, 2)) & __ROR4__(v238, 2) | v249 & __ROR4__(v244, 2)) + (v256 >> 27);
  unint64_t v263 = __PAIR64__(v238, __ROR4__(v174, 31));
  int v262 = v467 ^ v263;
  LODWORD(v263) = v238;
  int v264 = v263 >> 2;
  int v265 = v262 ^ __ROR4__(v214, 31) ^ __ROR4__(v248, 31);
  unint64_t v267 = __PAIR64__(v265, __ROR4__(v249, 2));
  int v266 = v258 & v267;
  LODWORD(v267) = v265;
  int v268 = v267 >> 31;
  unsigned int v269 = v261 - 1894007588;
  HIDWORD(v267) = v261 - 1894007588;
  LODWORD(v267) = v261 - 1894007588;
  int v270 = v268 + v264 + ((v258 | __ROR4__(v249, 2)) & __ROR4__(v244, 2) | v266) + (v267 >> 27);
  int v271 = ((v261 - 1894007588) | __ROR4__(v258, 2)) & __ROR4__(v249, 2) | (v261 - 1894007588) & __ROR4__(v258, 2);
  unint64_t v273 = __PAIR64__(v244, __ROR4__(v190, 31));
  int v272 = v463 ^ v273;
  LODWORD(v273) = v244;
  int v274 = v273 >> 2;
  int v275 = v243;
  LODWORD(v273) = v272 ^ __ROR4__(v243, 31) ^ __ROR4__(v253, 31);
  int v276 = v273;
  HIDWORD(v273) = v273;
  int v464 = v273 >> 31;
  int v468 = v268;
  int v277 = v464 + v274 + v271;
  unsigned int v278 = v270 - 1894007588;
  HIDWORD(v273) = v270 - 1894007588;
  LODWORD(v273) = v270 - 1894007588;
  int v279 = v277 + (v273 >> 27);
  unint64_t v280 = __PAIR64__(v249, __ROR4__(v269, 2));
  int v281 = ((v270 - 1894007588) | __ROR4__(v269, 2)) & __ROR4__(v258, 2) | (v270 - 1894007588) & v280;
  LODWORD(v280) = v249;
  int v282 = v280 >> 2;
  LODWORD(v280) = v432 ^ __ROR4__(v182, 31) ^ __ROR4__(v228, 31) ^ __ROR4__(v260, 31);
  int v283 = v280;
  HIDWORD(v280) = v280;
  int v433 = v280 >> 31;
  unsigned int v284 = v279 - 1894007588;
  HIDWORD(v280) = v279 - 1894007588;
  LODWORD(v280) = v279 - 1894007588;
  int v285 = v433 + v282 + v281 + (v280 >> 27);
  unint64_t v287 = __PAIR64__(v258, __ROR4__(v184, 31));
  int v286 = v459 ^ v287;
  LODWORD(v287) = v258;
  int v288 = v287 >> 2;
  LODWORD(v287) = v286 ^ __ROR4__(v237, 31) ^ __ROR4__(v265, 31);
  int v289 = v287;
  HIDWORD(v287) = v287;
  int v430 = v287 >> 31;
  int v290 = v430 + v288 + ((v284 | __ROR4__(v278, 2)) & __ROR4__(v269, 2) | v284 & __ROR4__(v278, 2));
  unsigned int v291 = v285 - 1894007588;
  HIDWORD(v287) = v285 - 1894007588;
  LODWORD(v287) = v285 - 1894007588;
  int v292 = v290 + (v287 >> 27);
  unint64_t v294 = __PAIR64__(v269, __ROR4__(v189, 31));
  int v293 = v455 ^ v294;
  LODWORD(v294) = v269;
  int v295 = v294 >> 2;
  LODWORD(v294) = v293 ^ __ROR4__(v242, 31) ^ __ROR4__(v276, 31);
  int v296 = v294;
  HIDWORD(v294) = v294;
  int v428 = v294 >> 31;
  int v297 = v428 + v295 + ((v291 | __ROR4__(v284, 2)) & __ROR4__(v278, 2) | v291 & __ROR4__(v284, 2));
  int v298 = v292 - 1894007588;
  HIDWORD(v294) = v292 - 1894007588;
  LODWORD(v294) = v292 - 1894007588;
  int v299 = v297 + (v294 >> 27);
  unint64_t v301 = __PAIR64__(v278, __ROR4__(v426, 31));
  int v300 = v452 ^ v301;
  LODWORD(v301) = v278;
  int v302 = v301 >> 2;
  int v303 = v299 - 1894007588;
  LODWORD(v301) = v300 ^ __ROR4__(v248, 31) ^ __ROR4__(v283, 31);
  int v304 = v301;
  HIDWORD(v301) = v301;
  int v427 = v301 >> 31;
  HIDWORD(v301) = v299 - 1894007588;
  LODWORD(v301) = v299 - 1894007588;
  unsigned int v305 = v427
       + v302
       + ((v298 | __ROR4__(v291, 2)) & __ROR4__(v284, 2) | v298 & __ROR4__(v291, 2))
       + (v301 >> 27)
       - 1894007588;
  unint64_t v307 = __PAIR64__(v284, __ROR4__(v202, 31));
  int v306 = v450 ^ v307;
  LODWORD(v307) = v284;
  int v308 = v307 >> 2;
  HIDWORD(v307) = v298;
  LODWORD(v307) = v298;
  int v309 = v307 >> 2;
  LODWORD(v307) = v306 ^ __ROR4__(v253, 31) ^ __ROR4__(v289, 31);
  int v310 = v307;
  HIDWORD(v307) = v307;
  int v453 = v307 >> 31;
  HIDWORD(v307) = v305;
  LODWORD(v307) = v305;
  unsigned int v311 = v453 + v308 + (v309 ^ __ROR4__(v291, 2) ^ (v299 - 1894007588)) - 899497514 + (v307 >> 27);
  unint64_t v313 = __PAIR64__(v291, __ROR4__(v259, 31));
  int v312 = v447 ^ v313;
  LODWORD(v313) = v291;
  int v314 = v313 >> 2;
  HIDWORD(v313) = v303;
  LODWORD(v313) = v303;
  int v315 = v313 >> 2;
  int v316 = v315 ^ __ROR4__(v298, 2) ^ v305;
  LODWORD(v313) = v312 ^ __ROR4__(v260, 31) ^ __ROR4__(v296, 31);
  int v317 = v313;
  HIDWORD(v313) = v313;
  int v318 = v313 >> 31;
  HIDWORD(v313) = v311;
  LODWORD(v313) = v311;
  unsigned int v319 = v318 + v314 + v316 - 899497514 + (v313 >> 27);
  unint64_t v321 = __PAIR64__(v305, __ROR4__(v214, 31));
  int v320 = v441 ^ v321;
  LODWORD(v321) = v305;
  int v322 = v321 >> 2;
  int v323 = v320 ^ __ROR4__(v265, 31) ^ __ROR4__(v304, 31);
  HIDWORD(v321) = v323;
  LODWORD(v321) = v323;
  int v456 = v321 >> 31;
  HIDWORD(v321) = v319;
  LODWORD(v321) = v319;
  unsigned int v324 = v456 + v309 + (v322 ^ __ROR4__(v303, 2) ^ v311) - 899497514 + (v321 >> 27);
  unint64_t v326 = __PAIR64__(v311, __ROR4__(v275, 31));
  int v325 = v439 ^ v326;
  LODWORD(v326) = v311;
  int v327 = v326 >> 2;
  int v328 = v327 ^ __ROR4__(v305, 2) ^ v319;
  LODWORD(v326) = v325 ^ __ROR4__(v276, 31) ^ __ROR4__(v310, 31);
  int v329 = v326;
  HIDWORD(v326) = v326;
  int v460 = v326 >> 31;
  HIDWORD(v326) = v324;
  LODWORD(v326) = v324;
  unsigned int v330 = v460 + v315 + v328 - 899497514 + (v326 >> 27);
  unint64_t v332 = __PAIR64__(v319, __ROR4__(v228, 31));
  int v331 = v444 ^ v332;
  LODWORD(v332) = v319;
  int v333 = v332 >> 2;
  LODWORD(v332) = v331 ^ __ROR4__(v283, 31) ^ __ROR4__(v317, 31);
  int v334 = v332;
  HIDWORD(v332) = v332;
  int v335 = v332 >> 31;
  HIDWORD(v332) = v330;
  LODWORD(v332) = v330;
  int v336 = v335 + v322 + (v333 ^ __ROR4__(v311, 2) ^ v324) - 899497514 + (v332 >> 27);
  unint64_t v338 = __PAIR64__(v324, __ROR4__(v237, 31));
  int v337 = v437 ^ v338;
  LODWORD(v33--*(_DWORD *)(this + 8) = v324;
  int v339 = v338 >> 2;
  LODWORD(v33--*(_DWORD *)(this + 8) = v337 ^ __ROR4__(v289, 31) ^ __ROR4__(v323, 31);
  int v340 = v338;
  HIDWORD(v33--*(_DWORD *)(this + 8) = v338;
  int v341 = v338 >> 31;
  HIDWORD(v33--*(_DWORD *)(this + 8) = v336;
  LODWORD(v33--*(_DWORD *)(this + 8) = v336;
  int v342 = v341 + v327 + (v339 ^ __ROR4__(v319, 2) ^ v330) - 899497514 + (v338 >> 27);
  unint64_t v344 = __PAIR64__(v330, __ROR4__(v242, 31));
  int v343 = v435 ^ v344;
  LODWORD(v344) = v330;
  int v345 = v344 >> 2;
  LODWORD(v344) = v343 ^ __ROR4__(v296, 31) ^ __ROR4__(v329, 31);
  int v346 = v344;
  HIDWORD(v344) = v344;
  int v347 = v344 >> 31;
  HIDWORD(v344) = v342;
  LODWORD(v344) = v342;
  unsigned int v348 = v347 + v333 + (v345 ^ __ROR4__(v324, 2) ^ v336) - 899497514 + (v344 >> 27);
  LODWORD(v344) = v471 ^ __ROR4__(v248, 31) ^ __ROR4__(v304, 31) ^ __ROR4__(v334, 31);
  int v349 = v344;
  HIDWORD(v344) = v344;
  int v350 = v344 >> 31;
  this[2] = v347;
  this[3] = v350;
  int v351 = v350 + v339;
  HIDWORD(v344) = v336;
  LODWORD(v344) = v336;
  int v352 = v344 >> 2;
  unint64_t v353 = __PAIR64__(v348, __ROR4__(v330, 2));
  int v354 = v351 + (v352 ^ v353 ^ v342) - 899497514;
  LODWORD(v353) = v348;
  unsigned int v355 = v354 + (v353 >> 27);
  HIDWORD(v353) = v342;
  LODWORD(v353) = v342;
  int v356 = v353 >> 2;
  LODWORD(v353) = v468 ^ __ROR4__(v253, 31) ^ __ROR4__(v310, 31) ^ __ROR4__(v340, 31);
  int v357 = v353;
  HIDWORD(v353) = v353;
  int v358 = v353 >> 31;
  HIDWORD(v353) = v355;
  LODWORD(v353) = v355;
  unsigned int v359 = v358 + v345 + (v356 ^ __ROR4__(v336, 2) ^ v348) - 899497514 + (v353 >> 27);
  LODWORD(v353) = v464 ^ __ROR4__(v260, 31) ^ __ROR4__(v317, 31) ^ __ROR4__(v346, 31);
  int v360 = v353;
  HIDWORD(v353) = v353;
  int v361 = v353 >> 31;
  this[4] = v358;
  this[5] = v361;
  int v362 = v361 + v352;
  HIDWORD(v353) = v348;
  LODWORD(v353) = v348;
  int v363 = v353 >> 2;
  unint64_t v364 = __PAIR64__(v359, __ROR4__(v342, 2));
  int v365 = v362 + (v363 ^ v364 ^ v355) - 899497514;
  LODWORD(v364) = v359;
  unsigned int v366 = v365 + (v364 >> 27);
  unint64_t v368 = __PAIR64__(v355, __ROR4__(v265, 31));
  int v367 = v433 ^ v368;
  LODWORD(v36--*(_DWORD *)(this + 8) = v355;
  int v369 = v368 >> 2;
  LODWORD(v36--*(_DWORD *)(this + 8) = v367 ^ __ROR4__(v323, 31) ^ __ROR4__(v349, 31);
  int v370 = v368;
  HIDWORD(v36--*(_DWORD *)(this + 8) = v368;
  int v371 = v368 >> 31;
  HIDWORD(v36--*(_DWORD *)(this + 8) = v366;
  LODWORD(v36--*(_DWORD *)(this + 8) = v366;
  unsigned int v372 = v371 + v356 + (v369 ^ __ROR4__(v348, 2) ^ v359) - 899497514 + (v368 >> 27);
  int v373 = v430 ^ __ROR4__(v276, 31) ^ __ROR4__(v329, 31) ^ __ROR4__(v357, 31);
  HIDWORD(v36--*(_DWORD *)(this + 8) = v373;
  LODWORD(v36--*(_DWORD *)(this + 8) = v373;
  int v374 = v368 >> 31;
  this[6] = v371;
  this[7] = v374;
  HIDWORD(v36--*(_DWORD *)(this + 8) = v359;
  LODWORD(v36--*(_DWORD *)(this + 8) = v359;
  int v375 = v368 >> 2;
  unint64_t v376 = __PAIR64__(v372, __ROR4__(v355, 2));
  int v377 = v374 + v363 + (v375 ^ v376 ^ v366);
  LODWORD(v376) = v372;
  unsigned int v378 = v377 - 899497514 + (v376 >> 27);
  unint64_t v380 = __PAIR64__(v366, __ROR4__(v334, 31));
  int v379 = v428 ^ __ROR4__(v283, 31) ^ v380;
  LODWORD(v380) = v366;
  int v381 = v380 >> 2;
  int v382 = v379 ^ __ROR4__(v360, 31);
  HIDWORD(v380) = v382;
  LODWORD(v380) = v382;
  int v383 = v380 >> 31;
  HIDWORD(v380) = v378;
  LODWORD(v380) = v378;
  unsigned int v384 = v383 + v369 + (v381 ^ __ROR4__(v359, 2) ^ v372) - 899497514 + (v380 >> 27);
  int v385 = v427 ^ __ROR4__(v289, 31) ^ __ROR4__(v340, 31) ^ __ROR4__(v370, 31);
  HIDWORD(v380) = v385;
  LODWORD(v380) = v385;
  int v386 = v380 >> 31;
  this[8] = v383;
  this[9] = v386;
  HIDWORD(v380) = v372;
  LODWORD(v380) = v372;
  int v387 = v380 >> 2;
  unint64_t v388 = __PAIR64__(v384, __ROR4__(v366, 2));
  int v389 = v386 + v375 + (v387 ^ v388 ^ v378) - 899497514;
  LODWORD(v38--*(_DWORD *)(this + 8) = v384;
  unsigned int v390 = v389 + (v388 >> 27);
  unint64_t v392 = __PAIR64__(v378, __ROR4__(v346, 31));
  int v391 = v453 ^ __ROR4__(v296, 31) ^ v392;
  LODWORD(v392) = v378;
  int v393 = v392 >> 2;
  int v394 = v391 ^ __ROR4__(v373, 31);
  HIDWORD(v392) = v394;
  LODWORD(v392) = v394;
  int v395 = v392 >> 31;
  HIDWORD(v392) = v390;
  LODWORD(v392) = v390;
  unsigned int v396 = v395 + v381 + (v393 ^ __ROR4__(v372, 2) ^ v384) - 899497514 + (v392 >> 27);
  LODWORD(v392) = v318 ^ __ROR4__(v304, 31) ^ __ROR4__(v349, 31) ^ __ROR4__(v382, 31);
  int v397 = v392;
  HIDWORD(v392) = v392;
  int v398 = v392 >> 31;
  this[10] = v395;
  this[11] = v398;
  HIDWORD(v392) = v384;
  LODWORD(v392) = v384;
  int v399 = v392 >> 2;
  unint64_t v400 = __PAIR64__(v396, __ROR4__(v378, 2));
  int v401 = v398 + v387 + (v399 ^ v400 ^ v390);
  LODWORD(v400) = v396;
  unsigned int v402 = v401 - 899497514 + (v400 >> 27);
  unint64_t v404 = __PAIR64__(v390, __ROR4__(v310, 31));
  int v403 = v456 ^ v404;
  LODWORD(v404) = v390;
  int v405 = v404 >> 2;
  LODWORD(v404) = v403 ^ __ROR4__(v357, 31) ^ __ROR4__(v385, 31);
  int v406 = v404;
  HIDWORD(v404) = v404;
  int v407 = v404 >> 31;
  HIDWORD(v404) = v402;
  LODWORD(v404) = v402;
  unsigned int v408 = v407 + v393 + (v405 ^ __ROR4__(v384, 2) ^ v396) - 899497514 + (v404 >> 27);
  LODWORD(v404) = v460 ^ __ROR4__(v317, 31) ^ __ROR4__(v360, 31) ^ __ROR4__(v394, 31);
  HIDWORD(v404) = v404;
  int v409 = v404 >> 31;
  this[12] = v407;
  this[13] = v409;
  HIDWORD(v404) = v396;
  LODWORD(v404) = v396;
  int v410 = v404 >> 2;
  unint64_t v411 = __PAIR64__(v408, __ROR4__(v390, 2));
  int v412 = v409 + v399 + (v410 ^ v411 ^ v402);
  LODWORD(v411) = v408;
  int v413 = v412 - 899497514 + (v411 >> 27);
  unint64_t v415 = __PAIR64__(v402, __ROR4__(v370, 31));
  int v414 = v335 ^ __ROR4__(v323, 31) ^ v415;
  LODWORD(v415) = v402;
  int v416 = v415 >> 2;
  LODWORD(v415) = __ROR4__(v397, 31);
  int v417 = v414 ^ v415;
  unint64_t v418 = __PAIR64__(v414 ^ v415, __ROR4__(v396, 2));
  int v419 = v416 ^ v418 ^ v408;
  LODWORD(v41--*(_DWORD *)(this + 8) = v417;
  int v420 = v418 >> 31;
  HIDWORD(v41--*(_DWORD *)(this + 8) = v413;
  LODWORD(v41--*(_DWORD *)(this + 8) = v413;
  unsigned int v421 = v420 + v405 + v419 - 899497514 + (v418 >> 27);
  *this = v335;
  this[1] = v341;
  LODWORD(v41--*(_DWORD *)(this + 8) = v341 ^ __ROR4__(v329, 31) ^ __ROR4__(v373, 31) ^ __ROR4__(v406, 31);
  HIDWORD(v41--*(_DWORD *)(this + 8) = v418;
  int v422 = v418 >> 31;
  this[14] = v420;
  this[15] = v422;
  HIDWORD(v41--*(_DWORD *)(this + 8) = v408;
  LODWORD(v41--*(_DWORD *)(this + 8) = v408;
  int v423 = v418 >> 2;
  unint64_t v424 = __PAIR64__(v421, __ROR4__(v402, 2));
  int v425 = v473 + v422 + v410 + (v423 ^ v424 ^ v413) - 899497514;
  LODWORD(v424) = v421;
  this[16] = v425 + (v424 >> 27);
  this[17] = v421 + v475;
  HIDWORD(v424) = v413;
  LODWORD(v424) = v413;
  this[18] = (v424 >> 2) + v472;
  this[19] = v423 + v474;
  this[20] = v416 + v476;
  return this;
}

_DWORD *llvm::SHA1::addUncounted(_DWORD *this, char a2)
{
  *((unsigned char *)this + (*((unsigned __int8 *)this + 88) ^ 3)) = a2;
  int v2 = (*((unsigned char *)this + 88))++ + 1;
  if (v2 == 64)
  {
    int v3 = this;
    this = llvm::SHA1::hashBlock(this);
    *((unsigned char *)v3 + 8--*(_DWORD *)(this + 8) = 0;
  }
  return this;
}

_DWORD *llvm::SHA1::writebyte(_DWORD *this, char a2)
{
  ++this[21];
  *((unsigned char *)this + (*((unsigned __int8 *)this + 88) ^ 3)) = a2;
  int v2 = (*((unsigned char *)this + 88))++ + 1;
  if (v2 == 64)
  {
    int v3 = this;
    this = llvm::SHA1::hashBlock(this);
    *((unsigned char *)v3 + 8--*(_DWORD *)(this + 8) = 0;
  }
  return this;
}

_DWORD *llvm::SHA1::update(_DWORD *this, unsigned char *a2, unint64_t a3)
{
  unint64_t v3 = a3;
  int v4 = a2;
  uint64_t v5 = (uint64_t)this;
  this[21] += a3;
  uint64_t v6 = *((unsigned __int8 *)this + 88);
  if (*((unsigned char *)this + 88))
  {
    if (64 - v6 >= a3) {
      unint64_t v7 = a3;
    }
    else {
      unint64_t v7 = 64 - v6;
    }
    if (v7)
    {
      int v8 = a2;
      unint64_t v9 = v7;
      do
      {
        char v10 = *v8++;
        *(unsigned char *)(v5 + (v6 ^ 3)) = v10;
        LODWORD(v6) = (*(unsigned char *)(v5 + 88))++ + 1;
        if (v6 == 64)
        {
          this = llvm::SHA1::hashBlock((_DWORD *)v5);
          LOBYTE(v6) = 0;
          *(unsigned char *)(v5 + 8--*(_DWORD *)(this + 8) = 0;
        }
        --v9;
      }
      while (v9);
    }
    v3 -= v7;
    v4 += v7;
  }
  if (v3 >= 0x40)
  {
    do
    {
      for (uint64_t i = 0; i != 64; i += 4)
        *(_DWORD *)(v5 + i) = bswap32(*(_DWORD *)&v4[i]);
      this = llvm::SHA1::hashBlock((_DWORD *)v5);
      v3 -= 64;
      v4 += 64;
    }
    while (v3 > 0x3F);
  }
  if (v3)
  {
    LOBYTE(v12) = *(unsigned char *)(v5 + 88);
    do
    {
      *(unsigned char *)(v5 + (v12 ^ 3)) = *v4;
      int v12 = (*(unsigned char *)(v5 + 88))++ + 1;
      if (v12 == 64)
      {
        this = llvm::SHA1::hashBlock((_DWORD *)v5);
        LOBYTE(v12) = 0;
        *(unsigned char *)(v5 + 8--*(_DWORD *)(this + 8) = 0;
      }
      ++v4;
      --v3;
    }
    while (v3);
  }
  return this;
}

_DWORD *llvm::SHA1::pad(llvm::SHA1 *this)
{
  *((unsigned char *)this + (*((unsigned __int8 *)this + 88) ^ 3)) = 0x80;
  int v2 = *((unsigned __int8 *)this + 88);
  LOBYTE(v3) = v2 + 1;
  *((unsigned char *)this + 8--*(_DWORD *)(this + 8) = v2 + 1;
  if (v2 != 55)
  {
    if (v2 == 63)
    {
      llvm::SHA1::hashBlock(this);
      LOBYTE(v3) = 0;
      *((unsigned char *)this + 8--*(_DWORD *)(this + 8) = 0;
    }
    do
    {
      *((unsigned char *)this + (v3 ^ 3)) = 0;
      int v3 = (*((unsigned char *)this + 88))++ + 1;
      if (v3 == 64)
      {
        llvm::SHA1::hashBlock(this);
        LOBYTE(v3) = 0;
        *((unsigned char *)this + 8--*(_DWORD *)(this + 8) = 0;
      }
    }
    while (v3 != 56);
  }
  *((unsigned char *)this + 59) = 0;
  *(_WORD *)((char *)this + 57) = 0;
  unsigned int v4 = *((_DWORD *)this + 21);
  *((unsigned char *)this + 56) = v4 >> 29;
  *((unsigned char *)this + 63) = v4 >> 21;
  *((unsigned char *)this + 62) = v4 >> 13;
  *((_WORD *)this + 30) = __PAIR16__((8 * v4) >> 24, 8 * v4);
  *((unsigned char *)this + 8--*(_DWORD *)(this + 8) = 64;
  unint64_t result = llvm::SHA1::hashBlock(this);
  *((unsigned char *)this + 8--*(_DWORD *)(this + 8) = 0;
  return result;
}

_DWORD *llvm::SHA1::final(llvm::SHA1 *a1, uint64_t a2)
{
  unint64_t result = llvm::SHA1::pad(a1);
  for (uint64_t i = 0; i != 20; i += 4)
    *(_DWORD *)(a2 + i) = bswap32(*(_DWORD *)((char *)a1 + i + 64));
  return result;
}

__n128 llvm::SHA1::result@<Q0>(llvm::SHA1 *this@<X0>, uint64_t a2@<X8>)
{
  long long v8 = *((_OWORD *)this + 2);
  long long v9 = *((_OWORD *)this + 3);
  *(_OWORD *)char v10 = *((_OWORD *)this + 4);
  *(_OWORD *)&v10[12] = *(_OWORD *)((char *)this + 76);
  __n128 v6 = *(__n128 *)this;
  long long v7 = *((_OWORD *)this + 1);
  llvm::SHA1::pad(this);
  for (uint64_t i = 0; i != 20; i += 4)
    *(_DWORD *)((char *)&v11 + i) = bswap32(*(_DWORD *)((char *)this + i + 64));
  *(_OWORD *)a2 = v11;
  *(_DWORD *)(a2 + 16) = v12;
  *((_OWORD *)this + 2) = v8;
  *((_OWORD *)this + 3) = v9;
  *((_OWORD *)this + 4) = *(_OWORD *)v10;
  *(_OWORD *)((char *)this + 76) = *(_OWORD *)&v10[12];
  __n128 result = v6;
  *(__n128 *)this = v6;
  *((_OWORD *)this + 1) = v7;
  return result;
}

double llvm::SHA1::hash@<D0>(unsigned char *a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  long long v7 = xmmword_1CFAC4320;
  uint64_t v8 = 3285377520;
  char v9 = 0;
  llvm::SHA1::update(v6, a1, a2);
  llvm::SHA1::pad((llvm::SHA1 *)v6);
  for (uint64_t i = 0; i != 5; ++i)
    *(_DWORD *)((char *)&v10 + i * 4) = bswap32(v6[i + 16]);
  double result = *(double *)&v10;
  *(_OWORD *)a3 = v10;
  *(_DWORD *)(a3 + 16) = v11;
  return result;
}

void llvm::SHA256::SHA256(llvm::SHA256 *this)
{
}

{
  operator new();
}

void llvm::SHA256::SHA256(llvm::SHA256 *this, const llvm::SHA256 *a2)
{
}

{
  operator new();
}

void llvm::SHA256::~SHA256(llvm::SHA256 *this)
{
  uint64_t v1 = *(void *)this;
  if (v1) {
    MEMORY[0x1D25D9CE0](v1, 0x1000C40ED882C02);
  }
}

{
  uint64_t v1;

  uint64_t v1 = *(void *)this;
  if (v1) {
    MEMORY[0x1D25D9CE0](v1, 0x1000C40ED882C02);
  }
}

__n128 llvm::SHA256::operator=(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = *a1;
  long long v5 = *(_OWORD *)(*a2 + 64);
  long long v4 = *(_OWORD *)(*a2 + 80);
  long long v6 = *(_OWORD *)(*a2 + 48);
  *(void *)(v3 + 96) = *(void *)(*a2 + 96);
  *(_OWORD *)(v3 + 64) = v5;
  *(_OWORD *)(v3 + 80) = v4;
  *(_OWORD *)(v3 + 4--*(_DWORD *)(this + 8) = v6;
  __n128 result = *(__n128 *)v2;
  long long v8 = *(_OWORD *)(v2 + 32);
  *(_OWORD *)(v3 + 16) = *(_OWORD *)(v2 + 16);
  *(_OWORD *)(v3 + 32) = v8;
  *(__n128 *)uint64_t v3 = result;
  return result;
}

uint64_t llvm::SHA256::init(CC_SHA256_CTX **this)
{
  return CC_SHA256_Init(*this);
}

uint64_t llvm::SHA256::update(CC_SHA256_CTX **a1, const void *a2, CC_LONG a3)
{
  return CC_SHA256_Update(*a1, a2, a3);
}

{
  return CC_SHA256_Update(*a1, a2, a3);
}

uint64_t llvm::SHA256::final@<X0>(CC_SHA256_CTX **this@<X0>, unsigned __int8 *a2@<X8>)
{
  return CC_SHA256_Final(a2, *this);
}

__n128 llvm::SHA256::result@<Q0>(__n128 **this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *this;
  __n128 v8 = (*this)[4];
  __n128 v9 = (*this)[5];
  unint64_t v10 = (*this)[6].n128_u64[0];
  __n128 v4 = **this;
  __n128 v5 = (*this)[1];
  __n128 v6 = (*this)[2];
  __n128 v7 = (*this)[3];
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  CC_SHA256_Final((unsigned __int8 *)a2, (CC_SHA256_CTX *)v2);
  v2[4] = v8;
  v2[5] = v9;
  v2[6].n128_u64[0] = v10;
  __n128 *v2 = v4;
  v2[1] = v5;
  __n128 result = v7;
  v2[2] = v6;
  void v2[3] = v7;
  return result;
}

void llvm::SHA256::hash()
{
}

void *llvm::SignpostEmitter::SignpostEmitter(void *this)
{
  *this = 0;
  return this;
}

{
  *this = 0;
  return this;
}

void llvm::SignpostEmitter::~SignpostEmitter(llvm::SignpostEmitter *this)
{
  uint64_t v2 = *(void *)this;
  *(void *)this = 0;
  if (v2) {
    MEMORY[0x1D25D9CE0](v2, 0xC400A2AC0F1);
  }
}

{
  uint64_t v2;

  uint64_t v2 = *(void *)this;
  *(void *)this = 0;
  if (v2) {
    MEMORY[0x1D25D9CE0](v2, 0xC400A2AC0F1);
  }
}

uint64_t llvm::SignpostEmitter::isEnabled(llvm::SignpostEmitter *this)
{
  return 0;
}

void *llvm::SmallPtrSetImplBase::shrink_and_clear(void **this)
{
  free(this[1]);
  unsigned int v2 = *((_DWORD *)this + 5) - *((_DWORD *)this + 6);
  int v3 = 1 << (33 - __clz(v2 - 1));
  *((_DWORD *)this + 5) = 0;
  *((_DWORD *)this + 6) = 0;
  if (v2 <= 0x10) {
    unsigned int v4 = 32;
  }
  else {
    unsigned int v4 = v3;
  }
  *((_DWORD *)this + 4) = v4;
  __n128 v5 = malloc_type_malloc(8 * v4, 0x4065EBACuLL);
  if (!v5) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  this[1] = v5;
  size_t v6 = 8 * *((unsigned int *)this + 4);

  return memset(v5, 255, v6);
}

void *sub_1CD0A7B08(size_t a1)
{
  __n128 result = malloc_type_malloc(a1, 0x4065EBACuLL);
  if (!result && (a1 || (__n128 result = malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0)) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  return result;
}

const void **llvm::SmallPtrSetImplBase::insert_imp_big(llvm::SmallPtrSetImplBase *this, const void *a2)
{
  int v4 = *((_DWORD *)this + 5);
  unsigned int v5 = *((_DWORD *)this + 4);
  if (3 * v5 <= 4 * (v4 - *((_DWORD *)this + 6)))
  {
    if (v5 >= 0x40) {
      v5 *= 2;
    }
    else {
      unsigned int v5 = 128;
    }
  }
  else if (v5 - v4 >= v5 >> 3)
  {
    goto LABEL_3;
  }
  llvm::SmallPtrSetImplBase::Grow(this, v5);
  unsigned int v5 = *((_DWORD *)this + 4);
LABEL_3:
  uint64_t v6 = *((void *)this + 1);
  unsigned int v7 = (v5 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  __n128 result = (const void **)(v6 + 8 * v7);
  __n128 v9 = *result;
  if (*result == (const void *)-1)
  {
    unint64_t v10 = 0;
LABEL_15:
    if (v10) {
      __n128 result = v10;
    }
    if (*result != a2)
    {
      if (*result == (const void *)-2) {
        --*((_DWORD *)this + 6);
      }
      else {
        ++*((_DWORD *)this + 5);
      }
      void *result = a2;
    }
  }
  else
  {
    unint64_t v10 = 0;
    int v11 = 1;
    while (v9 != a2)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v9 == (const void *)-2;
      }
      if (v12) {
        unint64_t v10 = result;
      }
      unsigned int v13 = v7 + v11++;
      unsigned int v7 = v13 & (v5 - 1);
      __n128 result = (const void **)(v6 + 8 * v7);
      __n128 v9 = *result;
      if (*result == (const void *)-1) {
        goto LABEL_15;
      }
    }
  }
  return result;
}

void llvm::SmallPtrSetImplBase::Grow(llvm::SmallPtrSetImplBase *this, unsigned int a2)
{
  unsigned int v5 = *(uint64_t **)this;
  int v4 = (uint64_t *)*((void *)this + 1);
  uint64_t v6 = 16;
  if (v4 == *(uint64_t **)this) {
    uint64_t v6 = 20;
  }
  uint64_t v7 = *(unsigned int *)((char *)this + v6);
  __n128 v8 = malloc_type_malloc(8 * a2, 0x4065EBACuLL);
  if (!v8 && (a2 || (__n128 v8 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0)) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  *((void *)this + 1) = v8;
  *((_DWORD *)this + 4) = a2;
  memset(v8, 255, 8 * a2);
  if (v7)
  {
    __n128 v9 = v4;
    do
    {
      uint64_t v10 = *v9;
      if ((unint64_t)*v9 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        int v11 = *((_DWORD *)this + 4) - 1;
        uint64_t v12 = *((void *)this + 1);
        unsigned int v13 = v11 & ((v10 >> 4) ^ (v10 >> 9));
        int v14 = (void *)(v12 + 8 * v13);
        uint64_t v15 = *v14;
        if (*v14 == -1)
        {
          int v16 = 0;
LABEL_9:
          if (v16) {
            int v14 = v16;
          }
        }
        else
        {
          int v16 = 0;
          int v17 = 1;
          while (v15 != v10)
          {
            if (v16) {
              BOOL v18 = 0;
            }
            else {
              BOOL v18 = v15 == -2;
            }
            if (v18) {
              int v16 = v14;
            }
            unsigned int v19 = v13 + v17++;
            unsigned int v13 = v19 & v11;
            int v14 = (void *)(v12 + 8 * (v19 & v11));
            uint64_t v15 = *v14;
            if (*v14 == -1) {
              goto LABEL_9;
            }
          }
        }
        *int v14 = v10;
      }
      ++v9;
    }
    while (v9 != &v4[v7]);
  }
  if (v4 != v5) {
    free(v4);
  }
  *(void *)((char *)this + 20) = (*((_DWORD *)this + 5) - *((_DWORD *)this + 6));
}

const void **llvm::SmallPtrSetImplBase::FindBucketFor(llvm::SmallPtrSetImplBase *this, const void *a2)
{
  int v2 = *((_DWORD *)this + 4) - 1;
  uint64_t v3 = *((void *)this + 1);
  unsigned int v4 = v2 & ((a2 >> 4) ^ (a2 >> 9));
  __n128 result = (const void **)(v3 + 8 * v4);
  uint64_t v6 = *result;
  if (*result == (const void *)-1)
  {
    uint64_t v7 = 0;
LABEL_13:
    if (v7) {
      return v7;
    }
  }
  else
  {
    uint64_t v7 = 0;
    int v8 = 1;
    while (v6 != a2)
    {
      if (v7) {
        BOOL v9 = 0;
      }
      else {
        BOOL v9 = v6 == (const void *)-2;
      }
      if (v9) {
        uint64_t v7 = result;
      }
      unsigned int v10 = v4 + v8++;
      unsigned int v4 = v10 & v2;
      __n128 result = (const void **)(v3 + 8 * v4);
      uint64_t v6 = *result;
      if (*result == (const void *)-1) {
        goto LABEL_13;
      }
    }
  }
  return result;
}

llvm::SmallPtrSetImplBase *llvm::SmallPtrSetImplBase::SmallPtrSetImplBase(llvm::SmallPtrSetImplBase *this, const void **__dst, const llvm::SmallPtrSetImplBase *a3)
{
  *(void *)this = __dst;
  uint64_t v5 = *((void *)a3 + 1);
  if (v5 == *(void *)a3)
  {
    *((void *)this + 1) = __dst;
  }
  else
  {
    uint64_t v10 = *((unsigned int *)a3 + 4);
    std::string __dst = (const void **)malloc_type_malloc(8 * v10, 0x4065EBACuLL);
    if (!__dst && (v10 || (std::string __dst = (const void **)malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0)) {
      llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
    }
    *((void *)this + 1) = __dst;
    uint64_t v5 = *(void *)a3;
  }
  *((_DWORD *)this + 4) = *((_DWORD *)a3 + 4);
  int v6 = *((_DWORD *)a3 + 5);
  if (*((void *)a3 + 1) == v5) {
    unsigned int v7 = *((_DWORD *)a3 + 5);
  }
  else {
    unsigned int v7 = *((_DWORD *)a3 + 4);
  }
  if (v7)
  {
    memmove(__dst, *((const void **)a3 + 1), 8 * v7);
    int v6 = *((_DWORD *)a3 + 5);
  }
  int v8 = *((_DWORD *)a3 + 6);
  *((_DWORD *)this + 5) = v6;
  *((_DWORD *)this + 6) = v8;
  return this;
}

{
  uint64_t v5;
  int v6;
  unsigned int v7;
  int v8;
  uint64_t v10;

  *(void *)this = __dst;
  uint64_t v5 = *((void *)a3 + 1);
  if (v5 == *(void *)a3)
  {
    *((void *)this + 1) = __dst;
  }
  else
  {
    uint64_t v10 = *((unsigned int *)a3 + 4);
    std::string __dst = (const void **)malloc_type_malloc(8 * v10, 0x4065EBACuLL);
    if (!__dst && (v10 || (std::string __dst = (const void **)malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0)) {
      llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
    }
    *((void *)this + 1) = __dst;
    uint64_t v5 = *(void *)a3;
  }
  *((_DWORD *)this + 4) = *((_DWORD *)a3 + 4);
  int v6 = *((_DWORD *)a3 + 5);
  if (*((void *)a3 + 1) == v5) {
    unsigned int v7 = *((_DWORD *)a3 + 5);
  }
  else {
    unsigned int v7 = *((_DWORD *)a3 + 4);
  }
  if (v7)
  {
    memmove(__dst, *((const void **)a3 + 1), 8 * v7);
    int v6 = *((_DWORD *)a3 + 5);
  }
  int v8 = *((_DWORD *)a3 + 6);
  *((_DWORD *)this + 5) = v6;
  *((_DWORD *)this + 6) = v8;
  return this;
}

void **llvm::SmallPtrSetImplBase::CopyHelper(void **this, const llvm::SmallPtrSetImplBase *a2)
{
  uint64_t v3 = this;
  *((_DWORD *)this + 4) = *((_DWORD *)a2 + 4);
  unsigned int v4 = (const void *)*((void *)a2 + 1);
  int v5 = *((_DWORD *)a2 + 5);
  if (v4 == *(const void **)a2) {
    unsigned int v6 = *((_DWORD *)a2 + 5);
  }
  else {
    unsigned int v6 = *((_DWORD *)a2 + 4);
  }
  if (v6)
  {
    this = (void **)memmove(this[1], v4, 8 * v6);
    int v5 = *((_DWORD *)a2 + 5);
  }
  int v7 = *((_DWORD *)a2 + 6);
  *((_DWORD *)v3 + 5) = v5;
  *((_DWORD *)v3 + 6) = v7;
  return this;
}

uint64_t llvm::SmallPtrSetImplBase::SmallPtrSetImplBase(uint64_t a1, void *__dst, int a3, uint64_t *a4)
{
  *(void *)a1 = __dst;
  uint64_t v8 = *a4;
  uint64_t v7 = a4[1];
  if (v7 == *a4)
  {
    *(void *)(a1 + --*(_DWORD *)(this + 8) = __dst;
    uint64_t v9 = *((unsigned int *)a4 + 5);
    if (v9) {
      memmove(__dst, (const void *)a4[1], 8 * v9);
    }
  }
  else
  {
    *(void *)(a1 + --*(_DWORD *)(this + 8) = v7;
    a4[1] = v8;
  }
  *(void *)(a1 + 16) = a4[2];
  *(_DWORD *)(a1 + 24) = *((_DWORD *)a4 + 6);
  *((_DWORD *)a4 + 5) = 0;
  *((_DWORD *)a4 + 6) = 0;
  *((_DWORD *)a4 + 4) = a3;
  return a1;
}

{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  *(void *)a1 = __dst;
  uint64_t v8 = *a4;
  uint64_t v7 = a4[1];
  if (v7 == *a4)
  {
    *(void *)(a1 + --*(_DWORD *)(this + 8) = __dst;
    uint64_t v9 = *((unsigned int *)a4 + 5);
    if (v9) {
      memmove(__dst, (const void *)a4[1], 8 * v9);
    }
  }
  else
  {
    *(void *)(a1 + --*(_DWORD *)(this + 8) = v7;
    a4[1] = v8;
  }
  *(void *)(a1 + 16) = a4[2];
  *(_DWORD *)(a1 + 24) = *((_DWORD *)a4 + 6);
  *((_DWORD *)a4 + 5) = 0;
  *((_DWORD *)a4 + 6) = 0;
  *((_DWORD *)a4 + 4) = a3;
  return a1;
}

double llvm::SmallPtrSetImplBase::MoveHelper(uint64_t a1, int a2, double *a3)
{
  double v7 = *a3;
  uint64_t v6 = *((void *)a3 + 1);
  if (v6 == *(void *)a3)
  {
    uint64_t v8 = *(void **)a1;
    *(void *)(a1 + --*(_DWORD *)(this + 8) = *(void *)a1;
    uint64_t v9 = *((unsigned int *)a3 + 5);
    if (v9) {
      memmove(v8, *((const void **)a3 + 1), 8 * v9);
    }
  }
  else
  {
    *(void *)(a1 + --*(_DWORD *)(this + 8) = v6;
    a3[1] = v7;
  }
  double result = a3[2];
  *(double *)(a1 + 16) = result;
  *(_DWORD *)(a1 + 24) = *((_DWORD *)a3 + 6);
  *((_DWORD *)a3 + 5) = 0;
  *((_DWORD *)a3 + 6) = 0;
  *((_DWORD *)a3 + 4) = a2;
  return result;
}

void *llvm::SmallPtrSetImplBase::CopyFrom(llvm::SmallPtrSetImplBase *this, const llvm::SmallPtrSetImplBase *a2)
{
  double result = (void *)*((void *)this + 1);
  int v5 = *(void **)this;
  uint64_t v6 = (const void *)*((void *)a2 + 1);
  double v7 = *(const void **)a2;
  if (v6 == *(const void **)a2)
  {
    if (result != v5)
    {
      free(result);
      double result = *(void **)this;
    }
    goto LABEL_4;
  }
  int v8 = *((_DWORD *)this + 4);
  uint64_t v12 = *((unsigned int *)a2 + 4);
  if (v8 != v12)
  {
    if (result == v5) {
      double result = sub_1CD0A7B08(8 * v12);
    }
    else {
      double result = sub_1CD0A828C(result, 8 * v12);
    }
LABEL_4:
    *((void *)this + 1) = result;
    int v8 = *((_DWORD *)a2 + 4);
    double v7 = *(const void **)a2;
    uint64_t v6 = (const void *)*((void *)a2 + 1);
  }
  *((_DWORD *)this + 4) = v8;
  int v9 = *((_DWORD *)a2 + 5);
  if (v6 == v7) {
    unsigned int v10 = *((_DWORD *)a2 + 5);
  }
  else {
    unsigned int v10 = *((_DWORD *)a2 + 4);
  }
  if (v10)
  {
    double result = memmove(result, v6, 8 * v10);
    int v9 = *((_DWORD *)a2 + 5);
  }
  int v11 = *((_DWORD *)a2 + 6);
  *((_DWORD *)this + 5) = v9;
  *((_DWORD *)this + 6) = v11;
  return result;
}

void *sub_1CD0A828C(void *a1, size_t a2)
{
  double result = malloc_type_realloc(a1, a2, 0x1DB68EDCuLL);
  if (!result && (a2 || (double result = malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0)) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  return result;
}

double llvm::SmallPtrSetImplBase::MoveFrom(uint64_t a1, int a2, double *a3)
{
  uint64_t v6 = *(void **)(a1 + 8);
  if (v6 != *(void **)a1) {
    free(v6);
  }
  double v8 = *a3;
  uint64_t v7 = *((void *)a3 + 1);
  if (v7 == *(void *)a3)
  {
    int v9 = *(void **)a1;
    *(void *)(a1 + --*(_DWORD *)(this + 8) = *(void *)a1;
    uint64_t v10 = *((unsigned int *)a3 + 5);
    if (v10) {
      memmove(v9, *((const void **)a3 + 1), 8 * v10);
    }
  }
  else
  {
    *(void *)(a1 + --*(_DWORD *)(this + 8) = v7;
    a3[1] = v8;
  }
  double result = a3[2];
  *(double *)(a1 + 16) = result;
  *(_DWORD *)(a1 + 24) = *((_DWORD *)a3 + 6);
  *((_DWORD *)a3 + 5) = 0;
  *((_DWORD *)a3 + 6) = 0;
  *((_DWORD *)a3 + 4) = a2;
  return result;
}

uint64_t *llvm::SmallPtrSetImplBase::swap(uint64_t *this, uint64_t **a2)
{
  if (this != (uint64_t *)a2)
  {
    uint64_t v3 = this;
    int v5 = this;
    this = (uint64_t *)*this;
    unsigned int v4 = (uint64_t *)v5[1];
    uint64_t v7 = *a2;
    uint64_t v6 = a2[1];
    if (v4 == this)
    {
      if (v6 == v7)
      {
        uint64_t v8 = *((unsigned int *)a2 + 5);
        uint64_t v9 = *((unsigned int *)v3 + 5);
        if (v8 >= v9) {
          uint64_t v10 = v9;
        }
        else {
          uint64_t v10 = v8;
        }
        if (v10)
        {
          uint64_t v21 = 8 * v10;
          do
          {
            uint64_t v22 = *v4;
            *v4++ = *v6;
            *v6++ = v22;
            v21 -= 8;
          }
          while (v21);
        }
        if (v9 > v8)
        {
          unsigned int v13 = (uint64_t *)*v3;
          uint64_t v14 = *v3 + 8 * v9;
          uint64_t v15 = (llvm::SmallPtrSetImplBase *)a2;
        }
        else
        {
          if (v8 <= v9)
          {
LABEL_10:
            int v11 = *((_DWORD *)v3 + 5);
            *((_DWORD *)v3 + 5) = *((_DWORD *)a2 + 5);
            *((_DWORD *)a2 + 5) = v11;
            int v12 = *((_DWORD *)v3 + 6);
            *((_DWORD *)v3 + 6) = *((_DWORD *)a2 + 6);
            *((_DWORD *)a2 + 6) = v12;
            return this;
          }
          unsigned int v13 = *a2;
          uint64_t v14 = (uint64_t)&(*a2)[v8];
          uint64_t v15 = (llvm::SmallPtrSetImplBase *)v3;
        }
        this = (uint64_t *)memmove((void *)(*(void *)v15 + 8 * v10), &v13[v10], v14 - (void)&v13[v10]);
        goto LABEL_10;
      }
      uint64_t v17 = *((unsigned int *)v3 + 5);
      if (v17)
      {
        this = (uint64_t *)memmove(*a2, v4, 8 * v17);
        uint64_t v7 = *a2;
        uint64_t v6 = a2[1];
      }
      int v18 = *((_DWORD *)a2 + 4);
      *((_DWORD *)a2 + 4) = *((_DWORD *)v3 + 4);
      *((_DWORD *)v3 + 4) = v18;
      int v19 = *((_DWORD *)a2 + 5);
      *((_DWORD *)a2 + 5) = *((_DWORD *)v3 + 5);
      *((_DWORD *)v3 + 5) = v19;
      int v20 = *((_DWORD *)a2 + 6);
      *((_DWORD *)a2 + 6) = *((_DWORD *)v3 + 6);
      *((_DWORD *)v3 + 6) = v20;
      v3[1] = (uint64_t)v6;
      a2[1] = v7;
    }
    else
    {
      if (v6 != v7)
      {
        v3[1] = (uint64_t)v6;
        a2[1] = v4;
        int v16 = *((_DWORD *)v3 + 4);
        *((_DWORD *)v3 + 4) = *((_DWORD *)a2 + 4);
        *((_DWORD *)a2 + 4) = v16;
        goto LABEL_10;
      }
      uint64_t v23 = *((unsigned int *)a2 + 5);
      if (v23)
      {
        memmove(this, a2[1], 8 * v23);
        this = (uint64_t *)*v3;
        unsigned int v4 = (uint64_t *)v3[1];
      }
      int v24 = *((_DWORD *)a2 + 4);
      *((_DWORD *)a2 + 4) = *((_DWORD *)v3 + 4);
      *((_DWORD *)v3 + 4) = v24;
      int v25 = *((_DWORD *)v3 + 5);
      *((_DWORD *)v3 + 5) = *((_DWORD *)a2 + 5);
      *((_DWORD *)a2 + 5) = v25;
      int v26 = *((_DWORD *)v3 + 6);
      *((_DWORD *)v3 + 6) = *((_DWORD *)a2 + 6);
      *((_DWORD *)a2 + 6) = v26;
      a2[1] = v4;
      v3[1] = (uint64_t)this;
    }
  }
  return this;
}

uint64_t llvm::SmallVectorBase<unsigned int>::SizeTypeMax()
{
  return 0xFFFFFFFFLL;
}

uint64_t llvm::SmallVectorBase<unsigned int>::SmallVectorBase(uint64_t result, uint64_t a2, int a3)
{
  *(void *)double result = a2;
  *(_DWORD *)(result + --*(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(result + 12) = a3;
  return result;
}

{
  *(void *)double result = a2;
  *(_DWORD *)(result + --*(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(result + 12) = a3;
  return result;
}

void *llvm::SmallVectorBase<unsigned int>::mallocForGrow(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t *a4)
{
  if (HIDWORD(a2)) {
    sub_1CD0A88F0(a2);
  }
  uint64_t v4 = *(unsigned int *)(a1 + 12);
  if (v4 == -1) {
    sub_1CD0A89A8(0xFFFFFFFFuLL);
  }
  unint64_t v5 = (2 * v4) | 1;
  if (v5 <= a2) {
    unint64_t v5 = a2;
  }
  if (v5 >= 0xFFFFFFFF) {
    unint64_t v5 = 0xFFFFFFFFLL;
  }
  *a4 = v5;
  unint64_t v6 = v5 * a3;
  double result = malloc_type_malloc(v5 * a3, 0x4065EBACuLL);
  if (!result && (v6 || (double result = malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0)) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  return result;
}

uint64_t llvm::SmallVectorBase<unsigned int>::capacity(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

void *llvm::SmallVectorBase<unsigned int>::grow_pod(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  if (HIDWORD(a3)) {
    sub_1CD0A88F0(a3);
  }
  uint64_t v5 = *(unsigned int *)(a1 + 12);
  if (v5 == -1) {
    sub_1CD0A89A8(0xFFFFFFFFuLL);
  }
  unint64_t v7 = (2 * v5) | 1;
  if (v7 <= a3) {
    unint64_t v7 = a3;
  }
  if (v7 >= 0xFFFFFFFF) {
    uint64_t v8 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v8 = v7;
  }
  uint64_t v9 = *(void **)a1;
  uint64_t v10 = v8 * a4;
  if (*(void *)a1 == a2)
  {
    int v11 = malloc_type_malloc(v8 * a4, 0x4065EBACuLL);
    if (!v11)
    {
      if (v10) {
        goto LABEL_20;
      }
      int v11 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v11) {
        goto LABEL_20;
      }
    }
    double result = memcpy(v11, *(const void **)a1, *(unsigned int *)(a1 + 8) * a4);
  }
  else
  {
    double result = malloc_type_realloc(v9, v8 * a4, 0x1DB68EDCuLL);
    int v11 = result;
    if (!result)
    {
      if (v10 || (result = malloc_type_malloc(1uLL, 0x4065EBACuLL), (int v11 = result) == 0)) {
LABEL_20:
      }
        llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
    }
  }
  *(void *)a1 = v11;
  *(_DWORD *)(a1 + 12) = v8;
  return result;
}

uint64_t llvm::SmallVectorBase<unsigned int>::size(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

BOOL llvm::SmallVectorBase<unsigned int>::empty(uint64_t a1)
{
  return *(_DWORD *)(a1 + 8) == 0;
}

uint64_t llvm::SmallVectorBase<unsigned int>::set_size(uint64_t result, int a2)
{
  *(_DWORD *)(result + --*(_DWORD *)(this + 8) = a2;
  return result;
}

uint64_t llvm::SmallVectorBase<unsigned long long>::SizeTypeMax()
{
  return -1;
}

void *llvm::SmallVectorBase<unsigned long long>::SmallVectorBase(void *result, uint64_t a2, uint64_t a3)
{
  void *result = a2;
  result[1] = 0;
  result[2] = a3;
  return result;
}

{
  void *result = a2;
  result[1] = 0;
  result[2] = a3;
  return result;
}

void *llvm::SmallVectorBase<unsigned long long>::mallocForGrow(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t *a4)
{
  uint64_t v4 = *(void *)(a1 + 16);
  if (v4 == -1) {
    sub_1CD0A89A8(0xFFFFFFFFFFFFFFFFLL);
  }
  unint64_t v5 = (2 * v4) | 1;
  if (v5 <= a2) {
    unint64_t v5 = a2;
  }
  *a4 = v5;
  unint64_t v6 = v5 * a3;
  double result = malloc_type_malloc(v5 * a3, 0x4065EBACuLL);
  if (!result && (v6 || (double result = malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0)) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  return result;
}

uint64_t llvm::SmallVectorBase<unsigned long long>::capacity(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void *llvm::SmallVectorBase<unsigned long long>::grow_pod(uint64_t a1, void *a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 16);
  if (v4 == -1) {
    sub_1CD0A89A8(0xFFFFFFFFFFFFFFFFLL);
  }
  unint64_t v7 = (2 * v4) | 1;
  if (v7 <= a3) {
    unint64_t v8 = a3;
  }
  else {
    unint64_t v8 = v7;
  }
  uint64_t v9 = *(void **)a1;
  unint64_t v10 = v8 * a4;
  if (v9 == a2)
  {
    int v11 = malloc_type_malloc(v8 * a4, 0x4065EBACuLL);
    if (!v11)
    {
      if (v10) {
        goto LABEL_16;
      }
      int v11 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v11) {
        goto LABEL_16;
      }
    }
    double result = memcpy(v11, *(const void **)a1, *(void *)(a1 + 8) * a4);
  }
  else
  {
    double result = malloc_type_realloc(v9, v8 * a4, 0x1DB68EDCuLL);
    int v11 = result;
    if (!result)
    {
      if (v10 || (result = malloc_type_malloc(1uLL, 0x4065EBACuLL), (int v11 = result) == 0)) {
LABEL_16:
      }
        llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
    }
  }
  *(void *)a1 = v11;
  *(void *)(a1 + 16) = v8;
  return result;
}

uint64_t llvm::SmallVectorBase<unsigned long long>::size(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

BOOL llvm::SmallVectorBase<unsigned long long>::empty(uint64_t a1)
{
  return *(void *)(a1 + 8) == 0;
}

uint64_t llvm::SmallVectorBase<unsigned long long>::set_size(uint64_t result, uint64_t a2)
{
  *(void *)(result + --*(_DWORD *)(this + 8) = a2;
  return result;
}

void sub_1CD0A88F0(unint64_t a1)
{
  std::to_string(&v4, a1);
  sub_1CB935710("SmallVector unable to grow. Requested capacity (", &v4, &v5);
  sub_1CC224444(&v5, ") is larger than maximum value for size type (", &v6);
  std::to_string(&v3, 0xFFFFFFFFuLL);
  sub_1CC5BC848(&v6, (uint64_t *)&v3, &v1);
  sub_1CC224444(&v1, ")", &v7);
  std::string::~string(&v1);
  std::string::~string(&v3);
  std::string::~string(&v6);
  std::string::~string(&v5);
  std::string::~string(&v4);
  __int16 v2 = 260;
  v1.__r_.__value_.__r.__words[0] = (std::string::size_type)&v7;
  llvm::report_fatal_error((llvm *)&v1, (const llvm::Twine *)1);
}

void sub_1CD0A89A8(unint64_t a1)
{
  std::to_string(&v1, a1);
  sub_1CB935710("SmallVector capacity unable to grow. Already at maximum size ", &v1, &v3);
  std::string::~string(&v1);
  __int16 v2 = 260;
  v1.__r_.__value_.__r.__words[0] = (std::string::size_type)&v3;
  llvm::report_fatal_error((llvm *)&v1, (const llvm::Twine *)1);
}

double llvm::SourceMgr::SourceMgr(llvm::SourceMgr *this)
{
  *((void *)this + --*(_DWORD *)(this + 8) = 0;
  double result = 0.0;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return result;
}

{
  double result;

  *((void *)this + --*(_DWORD *)(this + 8) = 0;
  double result = 0.0;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return result;
}

__n128 llvm::SourceMgr::SourceMgr(__n128 *a1, uint64_t a2)
{
  a1->n128_u64[0] = 0;
  a1->n128_u64[1] = 0;
  a1[1].n128_u64[0] = 0;
  *a1 = *(__n128 *)a2;
  a1[1].n128_u64[0] = *(void *)(a2 + 16);
  *(void *)a2 = 0;
  *(void *)(a2 + --*(_DWORD *)(this + 8) = 0;
  *(void *)(a2 + 16) = 0;
  a1[1].n128_u64[1] = 0;
  a1[2].n128_u64[0] = 0;
  a1[2].n128_u64[1] = 0;
  *(__n128 *)((char *)a1 + 24) = *(__n128 *)(a2 + 24);
  a1[2].n128_u64[1] = *(void *)(a2 + 40);
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  __n128 result = *(__n128 *)(a2 + 48);
  a1[3] = result;
  a1[4].n128_u64[0] = *(void *)(a2 + 64);
  *(void *)(a2 + 64) = 0;
  return result;
}

{
  __n128 result;

  a1->n128_u64[0] = 0;
  a1->n128_u64[1] = 0;
  a1[1].n128_u64[0] = 0;
  *a1 = *(__n128 *)a2;
  a1[1].n128_u64[0] = *(void *)(a2 + 16);
  *(void *)a2 = 0;
  *(void *)(a2 + --*(_DWORD *)(this + 8) = 0;
  *(void *)(a2 + 16) = 0;
  a1[1].n128_u64[1] = 0;
  a1[2].n128_u64[0] = 0;
  a1[2].n128_u64[1] = 0;
  *(__n128 *)((char *)a1 + 24) = *(__n128 *)(a2 + 24);
  a1[2].n128_u64[1] = *(void *)(a2 + 40);
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  __n128 result = *(__n128 *)(a2 + 48);
  a1[3] = result;
  a1[4].n128_u64[0] = *(void *)(a2 + 64);
  *(void *)(a2 + 64) = 0;
  return result;
}

char **llvm::SourceMgr::operator=(char **a1, uint64_t a2)
{
  std::string v4 = *a1;
  if (*a1)
  {
    std::string v5 = a1[1];
    std::string v6 = v4;
    if (v5 != v4)
    {
      do
        llvm::SourceMgr::SrcBuffer::~SrcBuffer((llvm::SourceMgr::SrcBuffer *)(v5 - 24));
      while (v5 != v4);
      std::string v6 = *a1;
    }
    a1[1] = v4;
    operator delete(v6);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  *(_OWORD *)a1 = *(_OWORD *)a2;
  a1[2] = *(char **)(a2 + 16);
  *(void *)a2 = 0;
  *(void *)(a2 + --*(_DWORD *)(this + 8) = 0;
  *(void *)(a2 + 16) = 0;
  sub_1CBF4C5EC((void **)a1 + 3);
  *(_OWORD *)(a1 + 3) = *(_OWORD *)(a2 + 24);
  a1[5] = *(char **)(a2 + 40);
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  *((_OWORD *)a1 + 3) = *(_OWORD *)(a2 + 48);
  std::string v7 = *(char **)(a2 + 64);
  *(void *)(a2 + 64) = 0;
  unint64_t v8 = (atomic_uint *)a1[8];
  a1[8] = v7;
  if (v8 && atomic_fetch_add(v8 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v8 + 8))(v8);
  }
  return a1;
}

double llvm::SourceMgr::SourceMgr(uint64_t a1, void *a2)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 4--*(_DWORD *)(this + 8) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 64) = *a2;
  *a2 = 0;
  return result;
}

{
  double result;

  double result = 0.0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 4--*(_DWORD *)(this + 8) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 64) = *a2;
  *a2 = 0;
  return result;
}

atomic_uint *llvm::SourceMgr::setFileSystem(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *a2 = 0;
  double result = *(atomic_uint **)(a1 + 64);
  *(void *)(a1 + 64) = v3;
  if (result)
  {
    if (atomic_fetch_add(result + 2, 0xFFFFFFFF) == 1) {
      return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)result + 8))();
    }
  }
  return result;
}

void *llvm::SourceMgr::OpenIncludeFile@<X0>(std::string *this@<X2>, void *a2@<X0>, uint64_t a3@<X1>, uint64_t a4@<X8>)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  std::string::operator=(this, (const std::string *)a3);
  char v8 = HIBYTE(this->__r_.__value_.__r.__words[2]);
  BOOL v9 = v8 < 0;
  if (v8 >= 0) {
    unint64_t v10 = this;
  }
  else {
    unint64_t v10 = (std::string *)this->__r_.__value_.__r.__words[0];
  }
  std::string::size_type size = v8 & 0x7F;
  if (v9) {
    std::string::size_type size = this->__r_.__value_.__l.__size_;
  }
  uint64_t v12 = a2[8];
  __int16 v36 = 261;
  v35.__r_.__value_.__r.__words[0] = (std::string::size_type)v10;
  v35.__r_.__value_.__l.__size_ = size;
  if (v12) {
    double result = llvm::vfs::FileSystem::getBufferForFile(v12, (uint64_t)&v35, -1, 1, 0, 0, a4);
  }
  else {
    double result = sub_1CD096690((unsigned __int8 *)&v35, (llvm::WritableMemoryBuffer *)0xFFFFFFFFFFFFFFFFLL, 0, 0, 1, 0, a4);
  }
  uint64_t v14 = -1431655765 * ((a2[4] - a2[3]) >> 3);
  if (v14)
  {
    uint64_t v15 = 0;
    uint64_t v16 = 24 * v14;
    do
    {
      if ((*(unsigned char *)(a4 + 16) & 1) == 0) {
        break;
      }
      uint64_t v17 = (const void **)(a2[3] + v15);
      char v18 = *((unsigned char *)v17 + 23);
      int v19 = v18;
      size_t v20 = v18 & 0x7F;
      if (v19 >= 0) {
        size_t v21 = v20;
      }
      else {
        size_t v21 = (size_t)v17[1];
      }
      sub_1CB907098((uint64_t)&v35, v21 + 1);
      if ((v35.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v22 = &v35;
      }
      else {
        uint64_t v22 = (std::string *)v35.__r_.__value_.__r.__words[0];
      }
      if (v21)
      {
        if (*((char *)v17 + 23) >= 0) {
          uint64_t v23 = v17;
        }
        else {
          uint64_t v23 = *v17;
        }
        memmove(v22, v23, v21);
      }
      *(_WORD *)((char *)&v22->__r_.__value_.__l.__data_ + v21) = 47;
      char v24 = *(unsigned char *)(a3 + 23);
      BOOL v25 = v24 < 0;
      if (v24 >= 0) {
        int v26 = (const std::string::value_type *)a3;
      }
      else {
        int v26 = *(const std::string::value_type **)a3;
      }
      std::string::size_type v27 = v24 & 0x7F;
      if (v25) {
        std::string::size_type v28 = *(void *)(a3 + 8);
      }
      else {
        std::string::size_type v28 = v27;
      }
      int v29 = std::string::append(&v35, v26, v28);
      std::string::size_type v30 = v29->__r_.__value_.__r.__words[0];
      *(void *)int v37 = v29->__r_.__value_.__l.__size_;
      *(void *)&v37[7] = *(std::string::size_type *)((char *)&v29->__r_.__value_.__r.__words[1] + 7);
      char v31 = HIBYTE(v29->__r_.__value_.__r.__words[2]);
      v29->__r_.__value_.__l.__size_ = 0;
      v29->__r_.__value_.__r.__words[2] = 0;
      v29->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0) {
        operator delete(this->__r_.__value_.__l.__data_);
      }
      this->__r_.__value_.__r.__words[0] = v30;
      this->__r_.__value_.__l.__size_ = *(void *)v37;
      *(std::string::size_type *)((char *)&this->__r_.__value_.__r.__words[1] + 7) = *(void *)&v37[7];
      *((unsigned char *)&this->__r_.__value_.__s + 23) = v31;
      if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v35.__r_.__value_.__l.__data_);
        char v31 = HIBYTE(this->__r_.__value_.__r.__words[2]);
        std::string::size_type v30 = this->__r_.__value_.__r.__words[0];
      }
      if (v31 >= 0) {
        int v32 = this;
      }
      else {
        int v32 = (std::string *)v30;
      }
      std::string::size_type v33 = this->__r_.__value_.__l.__size_;
      if (v31 >= 0) {
        std::string::size_type v33 = v31 & 0x7F;
      }
      uint64_t v34 = a2[8];
      __int16 v36 = 261;
      v35.__r_.__value_.__r.__words[0] = (std::string::size_type)v32;
      v35.__r_.__value_.__l.__size_ = v33;
      if (v34) {
        llvm::vfs::FileSystem::getBufferForFile(v34, (uint64_t)&v35, -1, 1, 0, 0, (uint64_t)v37);
      }
      else {
        sub_1CD096690((unsigned __int8 *)&v35, (llvm::WritableMemoryBuffer *)0xFFFFFFFFFFFFFFFFLL, 0, 0, 1, 0, (uint64_t)v37);
      }
      double result = sub_1CCB73F2C((std::error_category *)a4, (uint64_t)v37);
      if ((v38 & 1) == 0)
      {
        double result = *(void **)v37;
        *(void *)int v37 = 0;
        if (result) {
          double result = (void *)(*(uint64_t (**)(void *))(*(void *)result + 8))(result);
        }
      }
      v15 += 24;
    }
    while (v16 != v15);
  }
  return result;
}